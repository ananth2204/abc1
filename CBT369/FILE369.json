{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011847000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2821728, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 20, "INMDSNAM": "CBT.V500.FILE369.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2821728, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2821728, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE369.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00.\\x03'", "DS1TRBAL": "b'\\xb2\\x1a'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\xac\\x00\\r\\x02\\xaf\\x00\\x0e\\x00/'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$DOC": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x99\\x02_\\x12\"\\x02\\xa4\\x02\\x98\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1999-01-25T12:22:00", "lines": 676, "newlines": 664, "modlines": 0, "user": "SBGOLOB"}, "text": "         I N T R O D U C T I O N\n            PRC-DULLES MODS, V4\n              NOVEMBER 1988\n--------------------------------------------------------INSERT 01/99\nDALE VICK:  UPDATED DSPACE COMMAND (JAN 1999)          -INSERT 01/99\n                                                       -INSERT 01/99\n      DALE VICK                                        -INSERT 01/99\n      USA GROUP, INC.                                  -INSERT 01/99\n      11100 USA PARKWAY                                -INSERT 01/99\n      MC: B131                                         -INSERT 01/99\n      FISHERS, IN 46038-9203                           -INSERT 01/99\n      WORK PHONE: (317) 578-6786                       -INSERT 01/99\n      E-MAIL:           DVICK@USAGROUP.COM             -INSERT 01/99\n--------------------------------------------------------INSERT 01/99\n\nTHESE PROGRAMS ARE IN THE PUBLIC DOMAIN.  NO WARRANTY IS GIVEN OR\nIMPLIED BY PLANNING RESEARCH CORPORATION.  NO LIABILITY IS ASSUMED BY\nPRC FOR ANY OF THE CODE IN THIS FILE.\n\nTHIS GROUCHY CAVEAT ASIDE, THE AUTHORS WILL BE HAPPY TO PROVIDE PHONE\nSUPPORT TO ANYONE WISHING TO INSTALL A SELECTION FROM OUR BAG OF TRICKS.\nWE ARE:\n    CHARLIE PITTS   -  (703) 883-8566\n    DICK SZIEDE     -  (703) 883-8551\n    PARKE WATSON    -  (703) 883-8599\n    WES KAKIGI      -  (703) 883-8569\n    DAN RIGGS       -  (703) 883-8550\n    KEN MATTHEWS    -  HAS PASSED ON TO SOME LUMBER COMPANY NEAR\n                       BOSTON.  GOOD LUCK KEN!\n\nPARKE AND CHARLIE GET TO HAVE MOST OF THE FUN AROUND HERE.  (THEY'VE\nEASED ME INTO MANAGEMENT TO KEEP ME FROM SCREWING UP THE SYSTEM).\nSOME HIGHLIGHTS OF WHAT WE'VE DONE ARE CHARLIE'S ACF2 INTERFACES,\nPARKE'S TP ACCOUNTING, AND OF COURSE THE OL' I/O COUNT ZAP.\n    ----- DICK SZIEDE, PRC 1988\n\n**************************************************************\n\nNOTES FOR VERSION 2 -- NEW STUFF JAN 1987:\n\n1). THE LM023XX MEMBERS ARE SUPPLIED BY SAM GOLOB OF NEWSWEEK.  HE'S\nMAINTAINING LM023 AS THE SP VERSION OF THE I/O COUNT ZAP.  I CALLOUSLY\nOVERWROTE THE SP VERSION I WROTE AT G.E. WITH CHARLIE'S XA VERSION.\nSORRY, SAM.  THE XA VERSION IS LM01601, ALSO IN THIS PDS.  SEE MEMBER\n$$NWKDOC FOR SAM'S COMMENTS ON LM023.\n\n2). PARKE HAS ENHANCED AUTOIPL TO ENQUE ON ITS STARTED TASK NAME TO\nKEEP CONFUSED OPERATORS FROM STARTING THE SAME PROCESS TWICE.\n\n3). ENQWAIT IS A CALLABLE SUBROUTINE THAT WILL POLL FOR A SPECIFIC\nENQ, AND RETURN WHEN SOMEBODY ELSE GETS IT.  CALLED FROM AUTOIPL,\nIT ALLOWS AUTOIPL TO WAIT UNTIL SOMETHING COMES UP, BEFORE PROCEEDING\n-- FROM PARKE.\n\n**************************************************************\n\nNOTES FOR VERSION 3 -- NEW STUFF APRIL 1987:\n\n1). CHARLIE'S TAPE LABEL WRITER NOW PRINTS VOLUME SEQUENCE NUMBER\nON THE LABEL.  MOST OF OUR TAPE FILES ARE MULTI-VOLUME, SO THIS\nHELPS.\n\n2). PARKE'S FULL-SCREEN SAS INTERFACE IS ENHANCED TO MATCH SAS\n5.16.  FSAS NOW RUNS UNDER ITS OWN ISPF APPLID, SO YOUR SAS\nPF-KEY DEFINITIONS, AND ENTRY-PANEL VARIABLES WILL BE STORED IN\nYOUR ISPF PROFILE.  THE EDIT INTERFACE NOW LOOKS LIKE A REGULAR\nEDIT, WITH MEMBER SELECT 'N ALL.\n\n3). PARKE'S FULL-SCREEN DSPACE.  GO FROM FREESPACE BY\nDEVICE-TYPE, OR MOUNT ATTRIBUTE, OR PARTIAL SERIAL TO VTOC MAP\n(VIA 3.4), TO DATASET BROWSE OR EDIT, ALL IN ONE SMOOTH SERIES OF\nPANELS.\n\n     (UPDATED BY DALE VICK -  JAN 99  - TO DO UCBSCAN TO FIND\n      DEVICES WITH DYNAMIC UCB'S)\n\n4). QALLOC AND QFLUSH ARE SOME TCAM UTILITIES FOR DEALING WITH TCAM\nAPPLICATIONS FROM TSO.\n\n5). ISFUSER MAKES THE SDSF SECURITY EXIT USE ACF2.\n\n6). LM00501 - MAKE JES2 RELOAD 6-LPI AFTER 8-LPI PRINTS.\n\n7). THE CLIB COMMAND IS USED TO ADD A PRIVATE  CLIST\n           LIBRARY TO SYSPROC.\n\n8). REPLYTO - WILL RESPOND TO AN OUTSTANDING WTOR.\n    WE USE IT TO SYNCH PROCESSING BETWEEN ADABAS AND\n    THE ADABAS LOG UTILITY.\n**************************************************************\n\n**************************************************************\n\nNOTES FOR VERSION 4 -- NEW STUFF NOVEMBER 1988;\n\n1). LM01603 - THE I/O COUNT ZAP IS UPGRADED FOR DFP/2.\n    THIS WORKS WITH XA 2.2, BUT DOESN'T PRODUCE COUNTS FOR CERTAIN\n    DYNAMIC DEALLOCATION MESSAGES.  WE WILL FIX WHEN WE GET 2.3 -\n    1ST QUARTER OF '89.\n\n2). SITEID - PASS RETURN CODE BASED ON JES2 NODE ID FROM JCT.\n\n3). PARKE'S SPY NOW SUPPORTS MVS 2.1.7, AND DYNAMIC CONSOLE.\n\n4). WAIT - WAIT-A-BIT UTILITY FOR MVS.\n\n5). DSNPOST - ACF2 POST.  ALLOW SDSF ACCESS TO SPOOL.\n\n6). A FIX TO SID TO PREVENT OC4 WITH BAD PARM FIELD.\n\n7). ENQWAIT NOW SUPPORTS LOOSLY-COUPLED GRS ENVIRONMENT.\n\n8). ISFUSER IS UPDATED FOR NEW SDSF (HQX1102).\n\n9). LM04202 - ZAPS TO NCCF TAF TO SUPPORT LARGE SCREEN SIZE.\n\n10) JESXIT9 - OUR \"LINES EXCEEDED\" EXIT\n\n\n**************************************************************\n\n\n               C O N T E N T S\n\nAC#VIOX  TITLE 'AC#VIOX -- ACF2 VIOLATION EXIT'\n         ALLOWS A USER WITH \"ACCOUNT\" AUTHORITY TO CREATE AN ALIAS IN\n         THE MASTER CATALOG, EVEN THOUGH HE DOESN'T HAVE \"WRITE\"\n         PERMISSION.  THE ROUTINE CHECKS THE ACF2 VIOLATION TO DETERMINE\n         WHETHER IT IS FROM VSAM CATALOG MANAGEMENT. IF SO, IT THEN\n         CHECKS TO SEE WHETHER THE REQUEST IS TO DEFINE OR DELETE AN\n         ALIAS. IF YES, IT CHECKS TO SEE IF THE USER HAS ACCOUNT\n         AUTHORITY. IF ALL CONDITIONS MATCH, THE ACCESS IS ALLOWED.\n\nACFFTSUB TITLE 'ACFFTSUB -- FILE TAILOR AND AUTHORIZED JOB SUBMISSION'\n         THIS ROUTINE PERFORMS THE FUNCTIONS OF ACF2'S ACFSUB PROGRAM.\n         THE MAIN REASON TO HAVE THIS IS TO PERMIT A USER TO SUBMIT A\n         JOB WHICH WILL DO THINGS THE USER WOULD NORMALLY NOT BE\n         PERMITTED TO DO.  (TYPICALLY, A DATA-CONTROL CLERK SUBMITTING\n         THE FDR BACKUPS).  THIS ROUTINE EXTENDS ACFSUB TO ALLOW A FINAL\n         STEP OF FILE TAILORING BY ISPF SERVICES PRIOR TO THE SUBMISSION\n         WHILE MAINTAINING SECURITY OVER PRODUCTION AND MAINTENANCE JCL.\n\n         NORMALLY ACFSUB-LIKE ROUTINES WHICH ARE USED TO TRIGGER THE\n         SUBAUTH LID ATTRIBUTE HAVE TO BE APF AUTHORIZED.  HOWEVER,\n         THERE IS A RESTRICTION IN FORCE WITH ISPF/PDF V2R2M0 AND TSO/E\n         WHICH PROHIBITS ANY APF AUTHORIZED PROGRAM OR COMMAND PROCESSOR\n         FROM USING ANY ISPF SERVICES.  THE SUBAUTHX EXIT, ALSO IN THIS\n         FILE, IS NECESSARY TO GET AROUND THIS RESTRICTION.\n\n         THE USER SHOULD HAVE READ AUTHORITY FOR THE FILE TAILORING\n         SKELETON LIBRARY. WRITE ACCESS TO THESE LIBRARIES SHOULD BE\n         CONTROLLED.  ONLY PROPER JOBSTREAMS CAN BE SUBMITTED.  THE\n         USER'S LEVEL OF MODIFICATION OF THE JOBSTREAMS IS LIMITED TO\n         SETTING DIALOG VARIABLES FOR THE FILE TAILORING.\n\nADAEX2 - 'ADABAS USER EXIT 2.'\n         THIS IS THE ADABAS SWITCH LOG EXIT. WE GET CONTROL FROM\n         ADABAS WHEN A PROTECTION LOG OR COMMAND LOG SWITCH TAKES\n         PLACE.  ADAEX2 DUMPS THE LOGS AS REQUIRED, AND TELLS\n         ADABAS TO GET ON WITH PROCESSING.  **NOTE** OUR ADABAS\n         LOG-DUMP UTILITY JCL CALLS THE \"REPLYTO\" PROGRAM ALSO IN\n         THIS FILE, TO GIVE ADABAS THE GO-AHEAD.\n\nASMTOZAP - THE ORIGINAL HOWARD GILBERT VERSION.  ACCEPT NO SUBSTITUTES!\n         THERE ARE OTHER ASMTOZAP PROGRAMS AROUND THAT WILL PRODUCE BAD\n         ZAPS FROM THE CODE IN THIS FILE.\n\n         THIS IS A UTILITY WHICH CONVERTS AN ASSEMBLER LISTING DATASET\n         INTO A FORMATTED IMASPZAP INPUT DECK OR SMP PTF. IT IS USEFUL\n         IN PREPARING, MAINTAINING, AND DOCUMENTING THOSE INSTALLATION\n         MODIFICATIONS WHICH CANNOT BE INSTALLED EXECPT BY MODIFING IBM\n         CODE. ONE CAN MAKE FREE USE OF MACROS, LITERALS, AND OTHER\n         CONVENIENCE FEATURES IN PREPARING THE DECK. CONTROL CARDS IN\n         SPECIAL ASSEMBLER COMMENT FORM PROVIDE FLEXABILITY IN\n         MODIFICATION DESIGN AND CONTROL OVER OUTPUT.\n\nAUTOIPL  TITLE 'A U T O M A T I C   I P L'\n         THIS PROGRAM ISSUES OPERATOR COMMANDS READ FROM AN INPUT FILE.\n         IT ALLOWS CONDITIONAL COMMAND EXECUTION, TIMED COMMAND\n         SUBMISSION, AND PROGRAM INVOCATION.  THESE FUNCTIONS PERMIT THE\n         PROGRAM TO BE USED FOR A FULLY AUTOMATED IPL PROCEDURE FOR THE\n         SYSTEM.\n\nBITENCOD TITLE ENCODE OR DECODE BITS INTO BYTES\n         PROVIDES BIT TESTING AND BIT SETTING FOR HIGH-LEVEL LANGUAGES\n\n         BITENCOD: THIS SUBROUTINE TAKES A SINGLE CHARACTER ARGUMENT\n                   OF ONE BYTE, AND RETURNS EIGHT CHARACTERS OF\n                   ONES OR ZEROS DEPENDING ON THE BITS SET IN THE\n                   ARGUMENT.\n         BITDECOD: THIS SUBROUTINE TAKESS EIGHT CHARACTERS OF\n                   DATA AND RETURNS A SINGLE BYTE, THE BITS OF\n                   WHICH ARE THE RIGHTMOST BITS OF EACH ARGUMENT\n                   BYTE.  THUS IS  IS THE OPPOSITE OF BITENCODE.\n\nCALENDAR - PRINT A CUSTOM CALENDAR FOR ANY YEAR: BIRTHDAYS, HOLIDAYS,\n           AND EVENTS TO YOUR ORDER.\n\nCLIB   --- CONCATENATE DATASET FIRST TO DDNAME '\n         PURPOSE: PROVIDE TSO USER QUICK ACCESS TO PRIVATE CLIST\n         METHOD:  USE SVC 99 TO DETERMINE THE DSNAMES OF ALL DATASETS\n                  CONCATENATED TO  A PARTICULAR DDNAME.\n                  REALLOCATE THE  ARGUMENT DSNAME IN FRONT OF ALL THE\n                  OTHERS.\n\nCOMMAND  TITLE 'COMMAND - ISSUE SVC34 FOR PROBLEM PROGRAM'\n         ALLOW COMMANDS TO BE ISSUED BY PROGRAM CONTROL EITHER THROUGH\n         THE PARM FIELD OR BY A CALL FROM ANOTHER PROGRAM.\n         NOT FULLY OPERATIONAL, BUT REQUIRED BY SPY.\n\nDSPACE   -- LIST DISK FREESPACE AND EXTENTS.\n          THIS IS THE GOOL OL' SHARE DSPACE COMMAND WITH\n          CLEARER FIELD LABELS, AND USING PUTLINE INSTEAD OF TPUT SO\n          IT CAN BE RUN FROM A CLIST.  THIS COMMAND IS USED BY PARKE'S\n          FULL-SCREEN \"FDSPACE\" PANELS.\n\nDOPROG  -- DOPROG/DOCP  (TSO) COMMAND PROCESSOR\n          DOPROG AND DOCP IN THE SAME MODULE.   USE TO INVOKE A COMMAND\n          PROCESSOR.  HAS A \"TASKLIB\" CAPABILITY.  THIS ISN'T JOE\n          SCHINDLER'S \"DOCP,\" WHICH IS A STAND-ALONE CP, RATHER, AN\n          ALIAS OF DOPROG.   JOE USED TPUT-TGET TO PROMPT FOR THE\n          COMMAND LINE, WHICH I DIDN'T LIKE.   THIS VERSION WILL TAKE A\n          CP COMMAND LINE IN QUOTES, OR WILL PROMPT WITH PUTGET IF IT\n          DOESN'T FIND ONE.  THUS IT CAN BE USED IN A CLIST.\n\nDSIEX04 - NCCF'S OWN LOGGING FACILITY IS PRETTY USELESS.  THIS EXIT\n          PROVIDES AN ALTERNATIVE.\n          WE GET A LOOKSEE AT ALL NCCF TERMINAL INPUTS AND OUTPUTS\n          BEFORE NCCF DOES ITS OWN LOGGING.  WE DECIDE WHAT'S IMPORTANT\n          AND WRITE IT FOR POSTERITY.  YOU'LL PROBABLY WANT TO SUPPRESS\n          MSGID NCCF/ IN YOUR MVS/XA MPF LIST.  NOTE THAT DSILOG TASK\n          MUST BE ACTIVE FOR THIS EXIT TO BE INVOKED.\n\nDSNPOST  TITLE 'DSNPOST - ACF2 DSN POST-PROCESSING EXIT.'\n          THIS IS AN ACF2 DSN POST-PROCESSING EXIT. WE USE THIS EXIT\n          TO OVERRIDE A PARTICULAR VIOLATION. WE ATTEMPTED TO LIMIT\n          ACCESS TO THE JES2 SPOOL AND CHECKPOINT DATASETS FROM\n          SDSF VIA ACF2'S PROGRAM PATHING FACILITY, BUT THE LIMITATIONS\n          OF THIS FACILITY ESPECIALLY WITHIN  ISPF DIALOGS BECAME\n          EVIDENT (YOU HAVE TO ACCURATELY DESCRIBE THE TASK AND RB\n          CHAINS FOR EVERY DIALOG THAT WILL BE USED). THUS WE ATTEMPT\n          TO OVERRIDE VIOLATIONS AGAINST THE JES2 DATASETS THAT ARE\n          REALLY NORMAL SDSF ACCESSES.  WE CHECK FOR OPEN FOR INPUT\n          ACCESSES TO FILES HASPCKPT OR HASPAC00, AND THEN CHECK FOR\n          THE PRESENCE OF AN AUTHORIZED LIBRARY VERSION OF ISFJINIT.\n\nDSNWAIT  TITLE 'DSNWAIT - WTO EXIT TO INFORM TSO USER OF DSN WAIT.'\n      NAME - DSNWAIT - WTO EXIT TO INFORM A TSO USER THAT JOB IS\n        WAITING FOR A DATASET.\n      DESCRIPTION -\n        WE GET CONTROL UPON ISSUANCE OF THE IEF099I WTO.  WE ISSUE\n        AN OPERATOR SEND COMMAND TO INFORM THE TSO USER THAT HIS BATCH\n        JOB IS WAITING FOR SOME DATASETS.  THE INTENT HERE IS TO ALERT\n        THE PERSON WHO CAN DO SOMETHING ABOUT THE SITUATION, SUCH AS\n        FREE THE DATASETS.  WE FIRST MAKE SURE THAT MSG IEF099I\n        WAS ISSUED, THAT ACF2 IS ALIVE AND WELL, THAT WE'RE A JOB,\n        AND THAT THE RESULTS OF OUR GQSCAN REQUEST FOR SYSDSN CONFLICTS\n        IS COOL. THEN WE ISSUE A SEND COMMAND FOR THE FIRST THREE\n        CONFLICTS THAT MEET THE FOLLOWING CONDITIONS:\n          1). 1 TASK HOLDS THE RESOURCE.\n          2). 1 TASK WAITS FOR THE RESOURCE.\n          3). WE ARE THE TASK THE WAITS FOR THE RESOURCE.\n          4). IT IS A TSO USER THAT HOLDS THE RESOURCE.\n          5). THE ACF2 LIDS FOR THE HOLDER AND WAITER ARE THE SAME.\n        WHILE IT IS ACKNOWLEDGED THAT THESE CRITERIA WILL ELIMINATE\n        SOME OTHERWISE VALID CANDIDATES FROM CONSIDERATION, IT IS HOPED\n        THAT THIS EXIT WILL OTHERWISE PROVE USEFUL IN MOST SITUATIONS.\n\n      NOTE - WE MUST BE IN AN APF-AUTHORIZED LINKLIST LIBRARY.\n        THE ACF2 SECURITY SYSTEM IS REQUIRED BY THIS EXIT.\n\n      TO USE -\n        SPECIFY IN AN MPFLSTXX MEMBER OF PARMLIB:\n        IEF099I,SUP(NO),USEREXIT(DSNWAIT)\n\nENQWAIT  TITLE 'ENQWAIT - STIMER UNTIL SOMEONE ELSE GETS AN ENQ.'\n          THIS PROGRAM WORKS IN CONJUNCTION WITH THE\n          AUTOIPL PROGRAM.  WE STIMER UNTIL A TARGET JOB\n          ACQUIRES A TARGET RESOURCE VIA AN ENQ REQUEST.\n          THUS WE CAN ENSURE THAT AUTOIPL WILL NOT PROCEED\n          UNTIL A PREVIOUS PROCESS IS READY FOR\n          PROCESSING.\n\n          FOR EXAMPLE, CONSIDER THE FOLLOWING AUTOIPL INPUT:\n            S TPJOB,M=TCAM\n            \"ENQWAIT \"JOB=TCAM,MAJOR=AUTOTCAM\n            S MESS,M=\n\n          THE \"S MESS,M=\" COMMAND WILL NOT PROCEED UNTIL\n          TCAM ACQUIRES THE RESOURCE WHOSE MAJOR NAME IS\n          AUTOTCAM.  WE STIMER EVERY 10 SECONDS FOR 5\n          MINUTES TO CHECK ON STATUS.  IF ANYTHING IS\n          FOUND THAT IS UNGOOD, WE ABEND WITH A S0C3.\n\n        TO USE -\n\n   EXEC PGM=ENQWAIT,PARM='MAJOR=MMMMMMMM,\n                          ACTION=WAIT/ABEND,\n                          CONTROL=E/S/ANY,\n                          JOB=JJJJJJJJ,\n                          MINOR=RRRRRRRR,\n                          MSG=YES/NO,\n                          NAME=NNNNNNNN,\n                          SCOPE=STEP/SYSTEM/SYSTEMS/ANY,\n                          SYSNAME=SSSSSSSS,\n                          TIME=9999,\n                          WANTENQ=HELD/NOTHELD'\n\n           MAJ(OR)  = TEST FOR THIS ENQ QNAME BEING HELD:\n                      MMMMMMMM = QNAME (1-8 CHARS).\n           A(CTION) = DO THIS IF CONDITION IS'NT INITIALLY MET:\n                      W(AIT): WAIT (DEFAULT) FOR TIME= SECONDS.\n                      A(BEND): ABEND IMMEDIATELY. (WITH AN U123).\n           C(ONTROL)= TEST FOR THIS ENQ RESOURCE CONTORL:\n                      E(XC): EXCLUSIVE\n                      S(HR): SHARED\n                      A(NY): DON'T TEST CONTROL (DEFAULT).\n           J(OB)    = TEST FOR THIS JOBNAME HOLDING RESOURCE:\n                      MMMMMMMM = QNMAE (1-8 CHARS).\n                      NOTE: A MASK IS ALLOWED - JOB=ABC*.\n           MIN(OR)  = TEST FOR THIS ENQ RNAME BEING HELD:\n                      RRRRRRRR = RNAME (1-44 CHARS).\n                      NOTE: A MASK IS ALLOWED - MINOR=ABC*.\n           MSG      = IF CONDITION IS'NT MET, NOTIFY ISSUER?\n                      Y(ES): NOTIFY (DEFAULT).\n                      N(O):  DON'T NOTIFY.\n           N(AME)   = DESCRIPTIVE NAME PUT IN NOTIFCATION MSG.\n                      NNNNNNNN = NAME (1-8 CHARS).\n           S(COPE)  = TEST FOR THIS ENQ SCOPE:\n                      S(TEP): WITHIN AN ADDRESS SPACE.\n                      SYS(TEM): BETWEEN ADDRESS SPACES.\n                      SYSTEMS: SHARED BETWEEN SYSTEMS.\n                      SYSS:    \"\"\n                      A(NY): DON'T TEST SCOPE (DEFAULT).\n           SYS(NAME)= TEST FOR THIS SYSNAME HOLDING RESOURCE:\n                      SSSSSSSS = SYSNAME (1-8 CHARS).\n                      NOTE: THIS IS FOR GRS SUPPORT.\n           T(IME)   = FOR ACTION=WAIT, ELAPSED SECONDS TO WAIT\n                      BEFORE ABENDING:\n                      NNNN = 1-9999 (DEFAULT=300).\n                      NOTE: ROUNDED UP TO NEXT 5 SECOND INTREVAL.\n           W(ANTENQ)= CONDITION TO BE MET BEFORE RETURNING CONTROL\n                      H(ELD): ENQ MUST BE HELD (DEFAULT)\n                      N(OTHELD): ENQ MUST NOT BE HELD.\n\n\nFSAS    - A FULL SCREEN SAS FACILITY THAT USES THE ISPF EDITOR.\n          NEEDS PANELS, CLISTS, MESSAGES AND CODE FOUND IN THIS PDS,\n          THAT START FSAS....   ALSO NEEDS THE CLIST SELMEMBR, AND THE\n          PANEL SELMEMP1.\n\nJESXIT9 - TITLE 'JES2 EXIT9 - OUTPUT EXCEEDED EXIT.'\n    DESCRIPTION -\n      THIS IS THE OUTPUT EXCEEDED JES EXIT. OUR INSTALLATION DOES\n      NOT BY DEFAULT CANCEL JOBS THAT EXCEED OUTPUT. THIS EXIT\n      PROMPTS THE OPERATOR ABOUT EVERY 100,000 LINES EXCEEDED TO\n      CANCEL THE JOB OR ALLOW THE JOB TO CONTINUE. THUS WE CAN\n      PREVENT RUNAWAY JOBS FROM FILLING UP SPOOL SPACE.\n\nHEX   TITLE ' BASE 16 ARITHMETIC '\n          FOR THOSE WHO HAVN'T BLOWN THE $15 FOR A CASIO CM-100, HERE'S\n          A LITTLE HELP.  THE IMPETUS FOR WRITING THIS PROGRAM COMES\n          FROM THOSE FRUSTRATING HOURS SPENT FUMBLING WITH A DUMP ONLY\n          TO DISCOVER THAT MY INABILITY TO FIND A SOLUTION STEMS FROM AN\n          ARITHMETIC ERROR IN THE INITIAL STEPS.\n\nIGC0022F TITLE 'IGC0022F,SVC 226, WRITE USER SMF RECORD'\n          WRITE USER SMF RECORD FROM NON APF-AUTHORIZED PROGRAM.\n          TYPICALLY, THE RECORD CONTAINS ACCOUNTING DATA FROM SUCH\n          PACKAGES AS TELAGRAF, THAT REQUIRE THEIR OWN ACCOUNTING DATA.\n          THE CALLER MUST PROVIDE A POINTER TO THE SMF RECORD IN\n          REGISTER ONE.  SVC226 WILL VALIDATE THE ARGUMENTS, FILL IN THE\n          STANDARD SMF HEADER AND DISPATCH THE RECORD WITH A SMFWTM\n          MACRO.\n\nIEFACTRT TITLE 'SMF JOB/STEP TERMINATION EXIT ROUTINE     '\n          SMF EXIT ROUTINE PUTS JOB SUMMARY MESSAGES ON THE JOB LOG WITH\n          STEP TERMINATION STATUS.  THIS IS THE SP IPO EXIT, DIDDLED TO\n          WORK UNDER XA.\n\nIEFUSI   'MEMLIMIT - IEFUSI EXIT TO SET REGION AND GETMAIN PARAMETERS\n          AVOID 40D ABENDS WHEN USING A REGION GREATER THAN 32 MEG.\n          SET LIMITS FOR REGION AND GETMAINS.  THE IEFUSI LIMIT FLAG IS\n          SET ON IN THE VSM PARAMETER LIST. THIS ENABLES VSM LOGIC TO\n          SET REGION AND GETMAIN LIMITS. NO SPECIFIC VALUES ARE SET.\n          THIS EXIT ADDRESSES A PROBLEM WHICH CAUSES ADDRESS SPACES TO\n          FAIL WHEN A V-FORM GETMAIN IS ISSUED WHICH GETS THE ENTIRE\n          PRIVATE AREA BELOW THE 16M LINE. ITS PURPOSE IS TO RESERVE FOR\n          SYSTEM USE (EG, ABTERM) A REASONABLE AMOUNT OF STORAGE.\n\nIKJEFF10 TITLE 'IKJEFF10 - TSO/E SUBMIT EXIT ROUTINE.'\n         WE USE THIS EXIT TO INSERT A COMMENT CARD AFTER EACH JOB CARD\n         THAT NAMES THE JCL SOURCE DATASET.  THUS:\n           //* SUBMITTED FROM ISPF EDIT OF USERID.TEST.CNTL(IEFBR14)\n         THIS ALLOWS THE DEBUGGER TO RELATE A JCL LISTING BACK TO THE\n         LIBRARY FROM WHICH THE JOB WAS SUBMITTED.\n\nIKJEFF53 TITLE ' FIB INSTALLATION EXIT'\n         VALIDITY CHECKS JOBNAME ON A CANCEL, OUTPUT OR STATUS FIB\n         (FOREGROUND INITIATED BACKGROUND) COMMAND.  USES AN ACF2\n         GENERALIZED RESOURCE RULE TEST, SO THE ACCESS RULES\n         CAN BE CHANGED WITH ACF2 COMMANDS INSTEAD OF REASSEMBLY\n         AND RELOAD OF IKJEFF53.\n\nISPFPRTO TITLE 'PRINTOFF SUBCOMMAND OF BROWSE & EDIT      '\n         THIS CLIST, PLUS AN ENTRY IN THE ISPTLIB MEMBER, \"ISPCMDS,\"\n         WILL PRINT THE DATASET BEING BROWSED OR EDITED, THUS:\n         COMMAND ==> PRINTO\n         INSTEAD OF:\n         COMMAND ==> TSO PRINTO ENDLESS.GODDAM.DATASET.NAME\n         NEEDS ISRBROBF AND ISREDDE REPLACEMENT PANELS IN THIS PDS.\n\nISFUSER  SDSF - ACF2 INTERFACE\n         WITH THIS INTERFACE, SDSF AND OUTPUT OBEY THE SAME RULES --\n         WHO CAN DO WHAT, AND WITH WHICH, AND TO WHOM?\n         IKJEFF53 AND ISFUSER BOTH CHECK THE SAME ACF2 GRO RULES.\n\nISRPID TITLE 'ISRPID - FETCH THE CURRENT ISPF PANELID.'\n         THIS ROUTINE RUNS UNDER THE ISPF DIALOG MANAGER AND RETURNS\n         THE NAME OF THE CURRENT PANEL IN DIALOG VARIABLE PANELID.\n         IT WAS DESIGNED FOR USE BY THE PRINTO SUBCOMMAND\n         OF EDIT AND BROWSE, ALSO IN THIS FILE.\n\nISRUOL   A FULL SCREEN 3.8 REPLACEMENT THAT ALLOWS MANIPULATION\n         OF JOBS/SYSOUT WITHOUT THE HASSLE OF AWKWARD \"JOB(JOBNUM)\"\n         SPECIFICATIONS.  REQUIRES TSO/E.\n\nISRUDLP  ISPF 3.4 MOD\n         DEFAULTS TO SEARCH UNDER YOUR USERID.  THUS\n         \"=3.4;;\" WILL DISPLAY WHAT YOU GET WITH, \"=3.4 **ENTER**\n         **TAB** MYUSERID **ENTER**\".  THIS PANEL ALSO HAS MODS TO\n         SUPPORT BEING CALLED AS A LINE COMMAND FROM FDSPACE.\n\nISTAUCAG TITLE 'VTAM SESSION ACCOUNTING EXIT ROUTINE.'\n         DESCRIPTION - THIS EXIT IS DOCUMENTED IN THE ACF/VTAM\n         CUSTOMIZ MANUAL (SC27-0613).  WHAT WE DO IN THIS EXIT IS\n         BANG OUT AN SMF RECORD (TYPE 240) THAT CONTAINS ALL\n         RELEVANT INFORMATION PASSED TO US.  THIS INCLUDES\n         PRIMARY AND SECONDARY LU NAMES.  RECORD IS IN RELOCATE\n         FORMAT (SECTIONS WITH A HEADER CONTAIN OFFSET, LENGTH,\n         AND NUMBER).  PLEASE NOTE THAT THE RECORD IS IN A FORMAT\n         COMPATIBLE WITH THE VECTORS THAT WILL BE OUTPUT BY THE\n         VTAM SESSION MANAGEMENT EXIT ROUTINE WE WILL USE WHEN\n         VTAM 2.2 IS IMPLEMENTED.\n\nLM04202  TITLE 'LM042 - ZAPS TO TAF TO SUPPORT LARGE SCREEN SIZE.'\n     DESCRIPTION - WE MODIFY TAF TO SUPPORT MOD3 AND MOD4 3270\n       TERMINALS. THE FIRST ZAPS CHANGE AN ERASE WRITE COMMAND TO AN\n       ERASE WRITE ALTERNATE COMMAND. THE OTHER ZAP CHANGES THE MAX\n       SEND BUFFER LENGTH TO ACCOMODATE MOD4 DATA. NOTE THAT NCCF/TAF\n       ONLY SUPPORTS THE MOD5 3270 (27X132) AS A MOD2 TERMINAL.\n\n     LEVEL - THESE ZAPS HAVE BEEN TESTED WITH NCCF V2.2 WITH 3278\n       MOD2 AND MOD4 TERMINALS.\n\n     NOTE  - USE THE ASSEMBLER H \"BATCH\" OPTION - WE ARE ZAPPING\n       THREE SEPERATE CSECTS.\n\n     ACKNOWLEDGMENTS  - THANKS TO MARK ANDERSON OF BOEING COMPUTER\n       SERVICES FOR POINTING ME IN THE RIGHT DIRECTION. HE HAD\n       SIMILAR NCCF/TAF ZAPS WORKING YEARS BEFORE I CAME UP WITH THIS.\n\n\nLM00501  FORCE JES2 TO RELOAD 6-LPI FCB AFTER 8-LPI DATASET PRINTS.\n         JES2 WILL ONLY RELOAD THE 3211 FCB WITH A STANDARD FCB,\n         IF THE CURRENT LOAD IS MARKED NON-STANDARD.\n         THIS MEANS, A JOB THAT DOESN'T SPECIFY A FCB WILL PRINT\n         AT THE DENSITY OF THE PRECEEDING DATASET, WHATEVER IT\n         MAY BE.  THE SOLUTION IS TO LEAVE ONLY THE 6-LPI FCB\n         MARKED STANDARD.\n\nLM01603  TITLE 'LM01603 -- IO COUNTS IN DEALLOCATION MESSAGES'\n\n            IEF285I SYS1.DATASET        KEPT *----2,301\n\n         I/O COUNT IN MSGS IEF283I, IEF285I, IEF287I UPDATED FOR XA.\n         IEFAB4B0 AT JBB2110, IEFAB4A2 AT JBB2125 ADDED LOOP TO SUM UP\n         COUNTS WHEN MULTIPLE UNITS ARE ALLOCATED.  ENHANCED TO SHOW\n         COUNTS FOR VIO DATASETS.\n         NOTE: THIS ZAP DEPENDS ON THE HOWARD GILBERT ASMTOZAP,\n               ALSO IN THIS FILE.  ACCEPT NO SUBSTITUTES.\n\nLM02701  TITLE 'ZAP TO IGG01946 FOR TCAM OPENQ SMF RECORD.'\nLM02801  TITLE 'ZAP TO IGG02046 FOR TCAM CLOSEQ SMF RECORD.'\n         DESCRIPTION - THESE TWO ZAPS WRITE AN SMF240 RECORD FOR EACH\n         OPEN OR CLOSE OF A TCAM APPLICATION Q.\n         NOTE: THIS ZAP DEPENDS ON THE HOWARD GILBERT ASMTOZAP,\n               ALSO IN THIS FILE.  ACCEPT NO SUBSTITUTES.\n\nNONDESC  TITLE 'NONDESC - WTO EXIT TO MAKE ACTION MESSAGES ROLLABLE\n         DESCRIPTION - IF EITHER DESC=1 OR DESC=2 FLAGS ARE ON, WE TURN\n         THEM OFF, MAKING THE MESSAGE ROLLABLE.  THIS EXIT WAS\n         ORIGINALLY DESIGNED TO MAKE SELECTED GARBAGE MESSAGES FROM\n         PROPRIETARY SOFTWARE, ROLLABLE.\n         THIS EXIT IS WELL DOCUMENTED IN THE USER EXITS SPL, GC28-1147.\n\nPRCJFCB  TITLE 'PRCJFCB -- READ JOB-FILE CONTROL BLOCK'\n         PURPOSE: THIS SUBROUTINE MOVES THE JOB-FILE CONTROL BLOCK FOR A\n         CALLER INTO AN AREA ACCESSABLE FROM HIGH-LEVEL LANGUAGE.\n\nPRC38DSN TITLE 'STORE THE DSN FOR A DDNAME IN A DIALOG VARIABLE.'\n         THIS ROUTINE RUNS UNDER CONTROL OF THE ISPF DIALOG MANAGER.\n         GIVEN AN ALLOCATED DDNAME VIA THE PARM FIELD, WE RETURN THE\n         DSN AND VOLSER IN DIALOG VARIABLES OUTDSN AND OUTVOL.  DESIGNED\n         FOR USE IN THE PRC 3.8 REPLACEMENT CLISTS SO WE CAN USE VIO\n         FOR OUR TEMPORARY FILES.\n\n           ISPEXEC SELECT PGM(PRC38DSN) PARM(DDNAME)\n           ISPEXEC VGET (OUTDSN OUTVOL)\n\nPRINTSEP TITLE 'APS JES2 EXITS: CUSTOM PRINTER BANNER SEPARATOR PAGE'\n         CUSTOM PRINT SEPARATOR EXIT ROUTINES.  PUTS ACF2 UID\n         OF JOB OWNER IN BANNER, AS WELL AS JOB NAME.\n         1.  ENTRY SEPEX1 IS TO BE INVOKED AT STANDARD JES2\n             EXIT 1.\n         2.  ENTRY SEPEX222 IS TO BE INVOKED AT ACF2-GENERATED\n             JES2 EXIT 222 BEFORE THE STANDARD ACF2X2J2 FUNCTION.\n         3.  THE ACF2 LOGON ID IS PASSED IN 8 BYTES OF JCTUSER.\n             CURRENTLY WE'RE USING THE 8 BTYES FOLLOWING WHATEVER\n             FIELD ACF2 IS USING.\n         4.  THE LOGOS ARE IN LOWER CASE. TAKE CARE WITH THE\n             EDITOR IF YOU MAKE CHANGES.\n\nQALLOC - ALLOCATE A TCAM QUEUE.\n  DESCRIPTION - WE DRIVE THE DYNAM PGM TO ALLOCATE A TCAM Q\n    FROM TSO.  PLEASE NOTE THAT THE ALLOCATE COMMAND DOES\n    NOT SUPPORT THIS.  CALL 'MY.LOAD.LIB(QALLOC)' 'DD=SYSUT1\n    QNAME=MYQNAME OPTCD=C ;' PLEASE NOTE THAT THE PARM FIELD\n    IS PASSED UNEDITED TO THE DYNAM PGM.  DON'T FORGET THE\n    ';' TO TERMINATE IT!\n\n    THE DYNAM PROGRAM IS FROM THE UNIVERSITY OF MANITOBA IS\n    ON SEVERAL CBT FILES.  I BELIEVE OURS CAME FROM CBT FILE\n    360.\n\nQFLUSH - FLUSH A TCAM QUEUE.\n  DESCRIPTION - THIS UTILITY FLUSHES RECORDS FROM A TCAM INPUT\n    QUEUE THAT IS ALLOCATED TO THE SYSUT1 FILE.  IT WRITES THESE\n    RECORDS TO THE SYSUT2 FILE IF IT'S FOUND ALLOCATED.  THIS PGM\n    CAN BE RUN FROM THE OPERATORS CONSOLE WHEN A QUEUE IS FOUND\n    TO BE CLOGGED UP WITH MESSAGES.\n  TO USE -\n    //QFLUSH PROC Q=BADQNAME,TCAM=TCAM,OUTDSN=NULLFILE\n    //S1     EXEC PGM=QFLUSH\n    //SYSUT1 DD   QNAME=&Q..&TCAM\n    //SYSUT2 DD   DSN=&OUTDSN,DISP=(,CATLG,DELETE),UNIT=SYSTS,\n    // SPACE=(TRK,(10,5),RLSE),DCB=(RECFM=VB,LRECL=4024,\n    // BLKSIZE=23200)\n\n   THE OPERATOR CAN ENTER: \"S QFLUSH,Q=MYQUEUE\"              (CVT)\n                           \"S QFLUSH,Q=MYQUEUE,TCAM=MYTCAM\"  (ASCB)\n\nRECEIVED TITLE 'RECEIVE NOTIFY EXIT'\n         FUNCTION     PROVIDE NOTIFICATION OF RECEIVED MESSAGE.\n\nREPLYTO - 'RESPOND TO AN OUTSTANDING WTOR.'\n    THIS PROGRAM WILL ISSUE A CANNED REPLY TO A SELECTED WTOR\n    MESSAGE.  WE USE IT TO SYNCH PROCESSING BETWEEN ADABAS AND\n    THE ADABAS LOG UTILITY.\n    IT ACCEPTS AS INPUT THE WTOR MESSAGE TEXT, THE CANNED REPLY\n    MESSAGE TEXT, AND OPTIONALLY THE JOBNAME OF THE WTOR ISSUER,\n    ALONG WITH OTHER MISC. OPTIONS, AS DESCRIBED BELOW.\n\n    FOR EXAMPLE, THE FOLLOWING JOB STEP:\n      //S1 EXEC PGM=REPLYTO,\n      // PARM='J=ADA8|M=ADA040A|R=OK'\n    WILL REPLY \"OK\" TO A WTOR MESSAGE BEGINNING \"ADA040A\" THAT\n    IS ISSUED BY JOB ADA8.\n\n    EXEC PGM=REPLYTO,PARM='MSG=MMMMMMMM...|\n                           REPLY=RRRRRRRR...|\n                           ABEND=YES/NO|\n                           COLUMN=99|\n                           JOB=JJJJJJJJ|\n                           TIME=999|\n                           WAIT=YES/NO'\n\nSD       PUNCH DIRECTORY OF PDS INTO SEQUENTIAL DATASET\n         NON-MODAL COMMAND TO FORMAT THE DIRECTORY INTO A DATASET\n         FOR SUBSEQUENT EDITING, OR TO THE SCREEN\n\nSID      TITLE 'SID - THIS PGM RETURNS SID INDICATOR IN R15'\n         THE INTENT OF THIS PROGRAM IS TO ALLOW JOBS TO EXECUTE\n         DIFFERENT STEPS BASED ON THE SYSTEM ON WHICH THEY ARE RUN.\n\nSITEID   TITLE 'SITEID - SET RETURN CODE BASED ON JES2 SPOOL NODE NAME'\n         THE INTENT OF THIS PROGRAM IS TO ALLOW JOBS TO EXECUTE\n         DIFFERENT STEPS BASED ON THE SITE AT WHICH THEY ARE RUN.\n\nSMF240   PURPOSE: MAP USER SMF RECORD 240\n\nSPY      TITLE 'S P Y --  MVS CONSOLE SPY PROGRAM  --  VERSION 3.1'\n         THIS PROGRAM DISPLAYS THE CONTENTS OF ALL ACTIVE GRAPHIC\n         OPERATOR'S CONSOLES ON A TSO CRT. THE OPERATOR'S SCREEN CAN BE\n         EITHER A 327X OR A 370-168 INTEGRATED CONSOLE WITH 35 LINES.\n         THE TSO USER CAN USE ANY 327X TERMINAL.  HEAVILY MODIFIED FOR\n         XA AT PRC.\n\nSRCDOC   ADD DOCUMENTATION TO LMF-MANAGED MEMBERS\n         CREATES AN EYE-CATCHER OF ISPF STATS AND PROMOTION TIME IN\n         THE OBJECT CODE OF A PROMOTED MODULE;\n\n         SRCLEVEL DC    C'IGC0022F V01.M05 85/09/26 17:57 PSYRRS  '\n\n         THE SHARED POOL IS ACCESSED TO GET THE MEMBER NAME AND LOW\n         LEVEL QUALIFIER (LANGUAGE TYPE).  THE LM DIALOG SERVICES ARE\n         THEN USED TO ACCESS VERSION, MODIFICATION LEVEL, DATE, TIME,\n         AND TSO LOGON FROM THE PDS DIRECTORY.  THE INPUT MEMBER IS\n         OPENED FOR UPDATE AND READ.  WHEN THE EXISTING TRGIGGER RECORD\n         OR SEQUENCE IS FOUND, THE RECORD IS UPDATED AND REWRITTEN.\n         NOTE: THIS ROUTINE IS INVOKED FROM THE PROMOTION EXIT\n         DEFINED TO LMF IN THE PROMOTION HIERARCHY, (PANEL 8.5).  THE\n         CLIST, \"LMFAPSEX,\" ALSO IN THIS FILE, IS THE EXIT WE USE.\n         THIS CLIST WILL NOT WORK FOR YOU WITHOUT MODIFICATION.  FOR\n         INSTANCE, YOU WON'T NEED THE \"IMP\" PRE-PROCESSOR CALL, AND YOUR\n         SYSLIB CONCATENATION IS GONNA' BE DIFFERENT.\n\nSUBAUTHX TITLE 'SUBAUTHX - CHECK FOR AUTHORIZED JOB SUBMISSION PROGRAM'\n         FUNCTION   CHECK FOR AUTHORIZED JOB SUBMISSION PROGRAM\n                    PROVIDES ACF2 \"JOBCOPY\" FUNCTION FROM WHITHIN ISPF\n         OPERATION  IF THE SUBMITTING PROGRAM IS REENTRANT AND COMES\n                    FROM AN APF-AUTHORIZED LIBRARY, THE BIT IN THE ACF\n                    DCT EXTENSION IS SET TO ALLOW THE 'SUBAUTH'\n                    RESTRICTION TO BE MET.\n         NOTES      THIS EXIT EXTENDS THE FUNCTIONS PROVIDED BY ACF2\n                    EXIT ACF2XIRD (INTERNAL READER OPEN) PACKAGED IN\n                    LOAD MODULE ACF2X1J2. THE EXIT POINT IS INSERTED IN\n                    HASPSSSM AS PART OF ACF2 INSTALLATION (RELEASE 4.0).\n                    THE ORIGINAL EXIT IS DESIGNED TO CAPTURE THE\n                    SUBMITTING ENVIRONMENT WHEN INTRDR IS OPENED. THE\n                    PROGRAM NAME AND ITS APF AUTHORIZATION ARE AMONG\n                    THE DATA PRESERVED. THESE DATA ARE THEN USED DURING\n                    ACF2 ENTRY VALIDATION, USUALLY FOR A LID WITH THE\n                    RESTRICT ATTRIBUTE. THE PROGRAM NAME IS MATCHED WITH\n                    THE PROGRAM SPECIFIED IN THE LID, AND APF\n                    AUTHORIZATION IS REQUIRED IF THE LID ALSO HAS\n                    SUBAUTH SPECIFIED.\n\nTCAMFIX DESCRIPTION - THIS ROUTINE CLEANS UP THE CVTAQAVB FIELD SO TCAM\n        WILL INITIALIZE.  THE CVT-BASED TCAM IS SUPPOSED TO DO THIS WHEN\n        IT TERMINATES, BUT IT ISN'T ALWAYS SO OBLIGING.  IF THE OPERATOR\n        RESPONDS \"Y\" TO OUR MESSAGE IEDPRC1D, THEN WE ZERO THIS FIELD.\n        NOTE - WE MUST RUN APF-AUTHORIZED.\n\nTLBLMAIN TITLE 'TLBLMAIN -- MAIN MODULE FOR TAPE LABEL WRITER'\n         FUNCTION     PROCESS REQUESTS TO PRINT EXTERNAL TAPE LABELS\n                      PRINT TAPE LABELS AT TAPE MOUNT TIME WITHOUT\n                      A TAPE MANAGEMENT SYSTEM.\n         OUTPUT       LABEL PRINTED ON 328X-TYPE PRINTER VIA VTAM\n\nWAIT   TITLE 'WAIT - WAIT A LITTLE BIT.'\n       THIS MODULE WILL WAIT THE REQUESTED NUMBER OF SECONDS.\n       PARM='NNNN', WHERE 0 < NNNN <= 9999, THE NUMBER OF SECONDS TO\n       WAIT. DEFAULT IS 10 SECONDS.\n\nWTO      TITLE 'WTO    - OPERATIONS COMMUNICATION'\n         THIS PROGRAM PROVIDES PROGRAMMER TO OPERATOR COMMUNICATION.\n         THIS IS THE IPO \"WTO\" DIDDLED TO ALLOW GREATER THAN 72 BYTE\n         MESSAGES.\n\nWTONR    TITLE 'WTONR - WRITE NON-ROLLABLE OPERATOR MESSAGES.'\n         DESCRIPTION - WE READ SYSIN INPUT AND WTO CARD IMAGES TO THE\n           OPERATOR CONSOLE THAT ARE NON-ROLLABLE.  ORGINALLY USED BY\n           THE MESSENGER JOBS FOR AN OPERATOR RESTART.\n\n         NOTE - WE MUST BE APF-AUTHORIZED TO WRITE NON-ROLLABLE MESSAGE\n\n         TO USE -\n          //S1 EXEC PGM=WTONR\n          //STEPLIB DD DSN=AN.APF.LIBRARY,DISP=SHR\n          //SYSIN   DD *\n          * THIS IS A COMMENT\n          ---> UP TO THREE LINES OF TEXT <---\n          ---> AFTER THREE LINES IGNORED <---\n          ---> COLS 1-72 ARE PROCESSED   <---\n          /*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$DVICK": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x07\\x0f\\x00\\x99\\x07\\x0f\\x13$\\x00!\\x00F\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-03-11T00:00:00", "modifydate": "1999-03-11T13:24:00", "lines": 33, "newlines": 70, "modlines": 0, "user": "SBGOLOB"}, "text": "From - Mon Jan 25 10:56:02 1999\nDate: Mon, 25 Jan 1999 08:30:29 -0600\nFrom: DALE VICK <DVICK@usagroup.com>\nTo: sbgolob@ibm.net\nSubject: Re: DSPACE Program Change\n\nHere is the requested info:\n\nDale Vick\nUSA Group, Inc.\n11100 USA Parkway\nMC: B131\nFishers, IN 46038-9203\n\nWork phone: (317) 578-6786\nE-Mail:           DVICK@USAGROUP.COM\n\ndv\n\n\nDALE VICK wrote:\n>\n> Attached is an update to the DSPACE command processor.\n>\n> Please give me a call at (317) 578-6786 for details.\n>\n> Thanks\n> dv\n>\n\n    Check out http://www.cbttape.org for CBT Tape information\n          and downloads of files.  \"Sponsored by NaSPA\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NWKDOC": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x90\\x00\\x1f\\x01\\x00)\\x9f\\x112\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "2000-10-25T11:32:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "WSBG"}, "text": "                NEWSWEEK DOCUMENTATION FOR MVS/370\n\n  WE AT NEWSWEEK HAVE TO RUN MVS/370 BECAUSE OF OUR MACHINE\nRESTRICTIONS AND BECAUSE OF RUNNING VM/CMS.  FOR ALL US PEOPLES, I AM\nTRYING TO MAINTAIN AND TEST DICK SZIEDE AND CHARLIE PITTS'S WORK ON\nTHE IO-COUNT ZAP, SO IT WILL ALSO RUN ON MVS/370.  OUR PROGRAMMERS\nLOVE THE IO-COUNT ZAP, AND WE WOULDN'T DREAM OF BEING WITHOUT IT.\n\n  RIGHT NOW, I'M INCLUDING THE ORIGINAL MVS/370 ASMTOZAP SOURCE,\nCALLED LM02301A, AND AN ACTUAL CODED ZAP PRODUCED BY ASSEMBLY OF THE\nSOURCE AND THE ASMTOZAP RUN.  THIS IS A CODED USERMOD THAT WE USE TO\nINSTALL THE ZAP ON OUR SYSTEM.  I'VE EDITED IT A BIT TO EXPLAIN IT\nBETTER, AND TO CHANGE THE NAME OF THE USERMOD.  IF I HAVE TIME AND\nENERGY, I HOPE TO TRY AND RECODE THE MVS/370 VERSION OF THE ZAP TO\nINCLUDE CHARLIE PITTS'S IMPROVEMENTS FOR XA.  MUCH THANKS TO DICK\nSZIEDE FOR HIS HELP.\n\n  PLEASE FEEL FREE TO CALL ME IF YOU'D LIKE TO SHOOT THE BREEZE,\nOR IF YOU'D LIKE TO PUT THIS MOD IN WITHOUT SMP.  I'LL BE GLAD TO\nHELP.\n\n            SAM GOLOB\n            P.O. BOX 906\n            TALLMAN, NY 10982-0906\n\n              PHONES:\n                        (845) 362-5843  FAX\n\n              EMAIL :   SBGOLOB@ATTGLOBAL.NET\n                        SBGOLOB@AOL.COM\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AC#VIOX": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\xd2\\x00\\xd2\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 210, "newlines": 210, "modlines": 0, "user": "FILE369"}, "text": "         TITLE 'AC#VIOX -- ACF2 VIOLATION EXIT'\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        MODULE NAME = AC#VIOX                                        *\n*                                                                     *\n*        DESCRIPTIVE NAME = ACF2 DATASET VIOLATION EXIT               *\n*                                                                     *\n*        AUTHOR = RUTH STUBBLEFIELD   DATE = MAY 19, 1981             *\n*                                                                     *\n*        FUNCTION =                                                   *\n*                                                                     *\n*           ALLOW USER SERVICES ANALYSTS TO DEFINE AND DELETE         *\n*           ALIASES IN A VSAM MASTER CATALOG.                         *\n*                                                                     *\n*        OPERATION =                                                  *\n*                                                                     *\n*           THE ROUTINE CHECKS THE ACF2 VIOLATION TO DETERMINE        *\n*           WHETHER IT IS FROM VSAM CATALOG MANAGEMENT. IF SO,        *\n*           IT THEN CHECKS TO SEE WHETHER THE REQUEST IS TO DEFINE    *\n*           OR DELETE AN ALIAS. IF YES, IT CHECKS TO SEE              *\n*           IF THE USER HAS ACCOUNT AUTHORITY. IF ALL                 *\n*           CONDITIONS MATCH, THE ACCESS IS ALLOWED.                  *\n*                                                                     *\n*        REGISTER CONVENTIONS = STANDARD CONVENTIONS.                 *\n*           REGISTER  0 = UNUSED                                      *\n*           REGISTER  1 = ADDRESS OF PARM LIST                        *\n*           REGISTER  2 = UNUSED                                      *\n*           REGISTER  3 = ADDRESS OF ACSXP                            *\n*           REGISTER  4 = ADDRESS OF CATALOG PARM LIST                *\n*           REGISTER  5 = ADDRESS OF ACUCB                            *\n*           REGISTER  6 = ADDRESS OF UID STRING                       *\n*           REGISTER  7 = WORK REGISTER                               *\n*           REGISTER  8 = ADDRESS OF FIELD VECTOR TABLE               *\n*           REGISTER  9 = ADDRESS OF LIDREC  ***MGK*** 3.20.84        *\n*           REGISTER 10 = UNUSED                                      *\n*           REGISTER 11 = UNUSED                                      *\n*           REGISTER 12 = BASE REGISTER                               *\n*           REGISTER 13 = SAVE AREA POINTER                           *\n*           REGISTER 14 = RETURN ADDRESS                              *\n*           REGISTER 15 = ENTRY POINT ADDDRESS                        *\n*                                                                     *\n*        MODULE TYPE = EXIT                                           *\n*                                                                     *\n*               PROCESSOR = ASM                                       *\n*                                                                     *\n*               ATTRIBUTES = REENTRANT                                *\n*                                                                     *\n*        ENTRY POINTS = AC#VIOX                                       *\n*                                                                     *\n*               LINKAGE FROM = ACF2 SVC                               *\n*                                                                     *\n*        INPUT =                                                      *\n*                                                                     *\n*               REGISTER 1 - POINTER TO ACSXP PARM LIST               *\n*                                                                     *\n*        OUTPUT =                                                     *\n*                                                                     *\n*               REGISTER 15 =  0--> CONTINUE NORMAL ACF2 PROCESSING   *\n*                           = 12--> ALLOW ACCESS                      *\n*                                                                     *\n*        EXIT - NORMAL = RETURN TO ACF2                               *\n*                                                                     *\n*               OUTPUT = RETURN CODE                                  *\n*                                                                     *\n*               RETURN CODE = 0 OR 12                                 *\n*                                                                     *\n*        EXIT - ERROR = NONE                                          *\n*                                                                     *\n*        EXTERNAL REFERENCES =                                        *\n*                                                                     *\n*               ROUTINES = NONE                                       *\n*                                                                     *\n*               DATA AREAS = IEZCTGPL                                 *\n*                            IEZCTGFV                                 *\n*                            ACSXP                                    *\n*                                                                     *\n*               CONTROL BLOCKS = ACUCB                                *\n*                                                                     *\n*               TABLES = NONE                                         *\n*                                                                     *\n*        MACROS USED =                                                *\n*                  MACRO           DSNAME                             *\n*                  --------        --------------------               *\n*                  ACUCB           SYSA.ACF2.R40.ACFMAC               *\n*                  ACSXP           SYSA.ACF2.R40.ACFMAC               *\n*                  ACFREGS         SYSA.ACF2.R40.ACFMAC               *\n*                  LIDREC          SYSA.ACF2.R40.ACFMAC               *\n*                                                                     *\n*        CHANGE ACTIVITY =                                            *\n*                  NAME            DATE                               *\n*                  MGK             03/21/84                           *\n*                                   CHANGES ALLOWS ACCOUNT USER TO    *\n*                                   DEFINE AND DELETE ALIAS USING AMS *\n*                                   WITHOUT ABORTING.  RETURN CODE    *\n*                                   OF 12 GENERATED TO ALLOW PROCESS- *\n*                                   ING TO CONTINUE IN ADDITIONAL TO  *\n*                                   LOGGING THE ACTION.               *\n*                  CJP             09/23/85                           *\n*                                   CLEANUP UNUSED PORTIONS, UPDATE   *\n*                                   COMMENTS FOR PRC, DULLES.         *\n*                                                                     *\n*        MESSAGES = NONE                                              *\n*                                                                     *\n*        ABEND CODES = NONE                                           *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nAC#VIOX  CSECT\n         SAVE  (14,12),,AC#VIOX.&SYSDATE..&SYSTIME\n         USING AC#VIOX,R12             CSECT ADDRESSABILITY\n         USING ACSXP,R3                PARM LIST ADDRESSABILITY\n         LR    R12,R15                 LOAD BASE REGISTER\n         LR    R3,R1                   LOAD PARM LIST ADDRESS\n         SPACE 2\n         TM    ACUUFLG1,ACUU1ABE       ABNORMAL CONDITION FOUND?\n         BO    RETURN                  YES, GO RETURN\n         SPACE 2\n         CLI   ACUUFLG3,ACUU3CMS       ENTERED FROM AMS CATLG MGMT?\n         BNE   RETURN                  NO, GO RETURN\n         SPACE 2\n*        CHECK PARAMETERS IN CATALOG PARAMETER LIST\n         SPACE 1\n         L     R4,ACUUCMS              LOAD ADDRESS OF CTG PL\n         USING IEZCTGPL,R4             ESTABLISH ADDRESSABILITY\n         IC    R7,CTGOPTNS             LOAD OPTION BYTE\n         N     R7,MASK                 ZERO OUT RESERVED BITS\n         CLM   R7,1,=AL1(CTGDEFIN)     IS REQUEST FOR DEFINE?\n         BNE   CHKDELET                NO, GO CHECK DELETE\n         TM    CTGOPTN1,CTGNAME        IS THERE A FIELD VECTOR TBL?\n         BNO   RETURN                  NO, GO RETURN\n         SPACE 1\n         L     R8,CTGFVT               LOAD ADDRESS OF FVT\n         USING IEZCTGFV,R8             ESTABLISH ADDRESSABILITY\n         CLI   CTGFVTYP,CTGFVANM       IS REQUEST FOR AN ALIAS RECORD?\n         BNE   RETURN                  NO, GO RETURN\n         B     CHKUID                  YES, CHECK UID STRING\n         DROP  R8\n         SPACE 2\n*        CHECK FOR DELETE REQUEST\n         SPACE 1\nCHKDELET EQU   *\n         CLM   R7,1,=AL1(CTGDELET)     IS REQUEST FOR DELETE?\n         BNE   RETURN                  NO, GO RETURN\n         SPACE 1\n         CLI   CTGTYPE,CTGTANM         IS REQUEST FOR AN ALIAS RECORD?\n         BNE   RETURN                  NO, GO RETURN\n         DROP  R4\n         SPACE 2\n*        DETERMINE WHETHER USER IS IN USER SERVICES\n         SPACE 1\nCHKUID   EQU   *\n         L     R5,ACUUAUCB             LOAD ADDRESS OF ACUCB\n         USING ACUCB,R5                ESTABLISH ADDRESSABILITY\n         SPACE 1\n         L     R9,ACULRECP             LOAD ADDRESS OF LOGONREC\n         USING LIDREC,R9               ESTABLISH ADDRESSIBLITY\n         TM    LIDTFLAG,LIDTACT        IS REQUEST BY ACCNT USER?\n         BNO   RETURN                  NO, GO RETURN\n         DROP  R5,R9\n         SPACE 2\n*        ALLOW ACCESS\n         SPACE 1\n         RETURN (14,12),RC=12\n         SPACE 2\n*        CONTINUE NORMAL ACF2 PROCESSING AND ABORT THE REQUEST\n         SPACE 1\nRETURN   EQU   *\n         RETURN (14,12),RC=0\n         EJECT\n*        CONSTANTS AND EQUATES\n         DS    0F                      ALIGN ON FULLWORD\nMASK     DC    X'000000F8'             AND MASK FOR CTGOPTNS FIELD\n         SPACE 2\n         LTORG\n         SPACE 2\n*        DSECTS\n         SPACE 2\n         ACUCB DSECT=YES               USER CONTROL BLOCK\n         SPACE 2\n         ACSXP DSECT=YES               DS EXIT PARAMETER LIST\n         SPACE 2                                                MGK\n         LIDREC DSECT=YES,SIZE=1024                             MGK\n         SPACE 2\n*        AMS CATALOG PARAMETER LIST\n         SPACE 2\nIEZCTGPL DSECT\nCTGOPTN1 DS    X                       OPTION BYTE 1\nCTGNAME  EQU   X'04'                   CTGFVT POINTS TO FVT\n         DS    XL3                     FILLER\nCTGFVT   DS    F                       ADDRESS OF FIELD VECTOR TABLE\nCTGFILL  DS    XL8                     FILLER\nCTGOPTNS DS    X                       CMS REQUEST OPTIONS\nCTGDEFIN EQU   X'08'                   DEFINE\nCTGDELET EQU   X'18'                   DELETE\n         DS    X                       RESERVED\nCTGTYPE  DS    X                       TYPE OF CATALOG RECORD\nCTGTANM  EQU   C'X'                    ALIAS NAME\n         DS    XL13                    FILLER\n         SPACE\n*        AMS FIELD VECTOR TABLE\n         SPACE\nIEZCTGFV DSECT\nCTGFVTYP DS    X                       RECORD TYPE\nCTGFVANM EQU   C'X'                    ALIAS NAME\nCTGFVFIL DS    XL91                    FILLER\n         SPACE 2\n         ACFREGS\n         SPACE 2\n         END   AC#VIOX\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ADAEX2": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x01\\xa8\\x01\\xa8\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 424, "newlines": 424, "modlines": 0, "user": "FILE369"}, "text": "PRC      TITLE 'ADAEX2 - ADABAS USER EXIT 2.'\n********************************************************************\n*                                                                  *\n* NAME - ADAEX2.                                                   *\n*                                                                  *\n* DESCRIPTION -                                                    *\n*  THIS IS THE ADABAS SWITCH LOG EXIT. WE GET CONTROL FROM ADABAS  *\n*  WHEN A PROTECTION LOG OR COMMAND LOG SWITCH TAKES PLACE. R1     *\n*  TELLS US WHETHER 1 OR BOTH PROTECTION OR COMMAND LOGS NEED      *\n*  DUMPING. HERE IS WHAT WE DO IN THIS MODULE (NOTE: \"AAAAAAAA\"    *\n*  IS THE ADABAS JOBNAME, \"JJJJJJJJ\" IS THE SUBMITTED JOBNAME):    *\n*                                                                  *\n*  R1 > 0 (1 PROTECTION LOG NEEDS DUMPING) :                       *\n*    1). WTO MSG 'ADA010I AAAAAAAA: ONE PROTECTION LOG FULL.'      *\n*    2). SUBMIT JCL TO INTRDR FILE FROM PROJCL FILE.               *L04\n*    3). WTO MSG 'ADA020I AAAAAAAA: JOB JJJJJJJJ WILL COPY 1 LOG.' *\n*    4). RETURN, CC=0.                                             *\n*                                                                  *\n*  R1 = 0 (2 PROTECTION LOGS NEEDS DUMPING) :                      *\n*    1). WTO MSG 'ADA010I AAAAAAAA: BOTH PROTECTION LOGS FULL.'    *\n*    2). SUBMIT JCL TO INTRDR FILE FROM PROJCL FILE.               *L04\n*    3). WTO MSG 'ADA020I AAAAAAAA: JOB JJJJJJJJ WILL COPY 1 LOG.' *\n*    4). WTO MSG '*ADA030A AAAAAAAA: IS WAITING FOR JOB JJJJJJJJ   *\n*                 TO RUN.'                                         *\n*          NOTE: THIS MESSAGE WILL STAY ON THE OPERATORS SCREEN    *\n*                UNTIL \"OK\" IS RESPONDED TO THE NEXT MSG, ADA040A. *\n*    5). WTOR MSG '*XX,ADA040A AAAAAAAA: REPLY \"OK\" WHEN JJJJJJJJ  *\n*                 IS DONE.'                                        *\n*    6). WAIT UNTIL \"OK\" HAS BEEN REPLIED. REMEMBER, BOTH LOGS     *\n*          ARE FULL. WE HAVE TO WAIT HERE BECAUSE WE DON'T WANT    *\n*          ADABAS OVERWRITING A LOG FILE BEFORE IT HAS BEEN COPIED.*\n*          AT PRC, THE LAST STEP OF THE COPY LOG JOB AUTOMATICALLY *\n*          REPLIES \"OK\" TO MSG ADA040A.  MESSAGE ADA040A IS NEVER  *\n*          EVEN SEEN BY THE OPERATOR ON THE CONSOLE BECAUSE IS IT  *\n*          SUPPRESSED BY THE MVS MPF FACILITY.                     *\n*    7). RETURN, CC=0.                                             *\n*    8). WE HAVE NOTICED THAT WHEN 2 PROTECTION LOGS NEED DUMPING, *\n*        ADABAS DRIVES THIS EXIT TWICE IN A ROW, ONCE FOR THE BOTH-*\n*        LOGS-FULL CONDITION, AND AGAIN FOR 1-LOG-FULL CONDITION.  *\n*        THE ADABAS DUMP LOG UTILITY WILL ONLY DUMP 1 LOG PER      *\n*        INVOCATION, SO ADABAS CALLS THIS EXIT TWICE HOPING THAT   *\n*        AT EACH CALL WE WILL DUMP ONE LOG.                        *\n*                                                                  *\n*  R1 = -1 (1 COMMAND LOG NEEDS DUMPING) :                         *\n*    1). WTO MSG 'ADA010I AAAAAAAA: ONE COMMAND LOG FULL.'         *L03\n*    2). SUBMIT JCL TO INTRDR FILE FROM CMDJCL FILE.               *L04\n*    3). WTO MSG 'ADA020I AAAAAAAA: JOB JJJJJJJJ WILL COPY 1 LOG.' *L03\n*    4). RETURN, CC=0.                                             *\n*                                                                  *\n*                                                                  *\n*  R1 = -2 (BOTH COMMAND LOGS NEED DUMPING) :                      *\n*    1). WTO MSG 'ADA010I AAAAAAAA: BOTH COMMAND LOGS FULL.'       *L03\n*    2). SUBMIT JCL TO INTRDR FILE FROM CMDJCL FILE.               *L04\n*    3). WTO MSG 'ADA020I AAAAAAAA: JOB JJJJJJJJ WILL COPY 1 LOG.' *L03\n*    4). WTO MSG '*ADA030A AAAAAAAA: IS WAITING FOR JOB JJJJJJJJ   *L03\n*                 TO RUN.'                                         *L03\n*          NOTE: THIS MESSAGE WILL STAY ON THE OPERATORS SCREEN    *L03\n*                UNTIL \"OK\" IS RESPONDED TO THE NEXT MSG, ADA040A. *L03\n*    5). WTOR MSG '*XX,ADA050A AAAAAAAA: REPLY \"OK\" WHEN JJJJJJJJ  *L03\n*                 IS DONE.'                                        *L03\n*    6). WAIT UNTIL \"OK\" HAS BEEN REPLIED. REMEMBER, BOTH LOGS     *L03\n*          ARE FULL. WE HAVE TO WAIT HERE BECAUSE WE DON'T WANT    *L03\n*          ADABAS OVERWRITING A LOG FILE BEFORE IT HAS BEEN COPIED.*L03\n*          AT PRC, THE LAST STEP OF THE COPY LOG JOB AUTOMATICALLY *L03\n*          REPLIES \"OK\" TO MSG ADA050A.  MESSAGE ADA050A IS NEVER  *L04\n*          EVEN SEEN BY THE OPERATOR ON THE CONSOLE BECAUSE IS IT  *L03\n*          SUPPRESSED BY THE MVS MPF FACILITY.                     *L03\n*    7). RETURN, CC=0.                                             *L03\n*    8). WE HAVE NOTICED THAT WHEN 2 COMMAND LOGS NEED DUMPING,    *L03\n*        ADABAS DRIVES THIS EXIT TWICE IN A ROW, ONCE FOR THE BOTH-*L03\n*        LOGS-FULL CONDITION, AND AGAIN FOR 1-LOG-FULL CONDITION.  *L03\n*        THE ADABAS DUMP LOG UTILITY WILL ONLY DUMP 1 LOG PER      *L03\n*        INVOCATION, SO ADABAS CALLS THIS EXIT TWICE HOPING THAT   *L03\n*        AT EACH CALL WE WILL DUMP ONE LOG.                        *L03\n*                                                                  *\n*  IF WE ARE ENTERED WITH AN UNKNOWN ENTRY CODE, WE WTO MESSAGE    *\n*    'ADA050E BAD ADAEX2 ENTRY CODE, IGNORED.' AND RETURN, CC=12.  *\n*                                                                  *\n*  IF EITHER INPUT OR OUTPUT FILE DOESN'T OPEN, WE WTO MESSAGE     *\n*    'ADA060E BAD RC FROM OPEN, NO JOB SUBMITTED.' AND RETURN,     *\n*    CC=12.                                                        *\n*                                                                  *\n* TO USE -                                                         *\n*   INCLUDE THE FOLLOWING JCL IN YOUR ADABAS PROC:                 *\n*     //INTRDR  DD SYSOUT=(*,INTRDR)                               *\n*   INCLUDE THE FOLLOWING JCL FOR PROTECTION LOGGING:              *L03\n*     //PROJCL  DD DSN=YOUR.PROLOG.JCL,DISP=SHR                    *L04\n*   INCLUDE THE FOLLOWING JCL FOR COMMAND LOGGING:                 *L03\n*     //CMDJCL  DD DSN=YOUR.CMDLOG.JCL,DISP=SHR                    *L04\n*   ALSO, LINK THIS MODULE INTO THE ADABAS STEPLIB OR A LINKLIST   *\n*   LIBRARY. IT IS REENTRANT.                                      *\n*                                                                  *\n* LOG -                                                            *\n*   04/01/87 L01 PTW IMPLEMENTED                                   *L01\n*   05/20/87 L02 PTW FREEPOOL ADDED                                *L02\n*   08/10/87 L03 PTW COMMAND LOGGING ADDED                         *L03\n*   11/10/87 L04 PTW USE ONLY PROJCL AND CMDJCL FILES, MSG ADA050A *L04\n*                    FOR 2 CLOGS FULL, MERGE LOGIC.                *L04\n*                                                                  *\n********************************************************************\n         LCLC  &CSECT\n&CSECT   SETC  'ADAEX2'\n&CSECT   CSECT ,\n********************************************************************\n*                                                                  *\n*        I N I T I A L I Z E                                       *\n*                                                                  *\n********************************************************************\n         PRINT NOGEN\n         SAVE  (14,12),,&CSECT-&SYSDATE-&SYSTIME\n         LR    R12,R15            ESTABLISH BASE.\n         USING &CSECT,R12         TELL ASSEMBLER.\n         GETMAIN RU,LV=DYNLEN     GET DYNAMIC AREA.\n         LR    R2,R13             SAVE AREA\n         LR    R13,R1             SAVE AREA\n         USING DYNAMIC,R13        TELL ASSEMBLER.\n         LA    R0,DYNAMIC         ZERO\n         L     R1,=A(DYNLEN)        DYNAMIC\n         LR    R14,R0                 STORAGE.\n         SLR   R15,R15            R15 = 0.\n         MVCL  R0,R14             DO IT.\n         ST    R2,4(,R13)         BACK CHAIN.\n         ST    R13,8(,R2)         FORWARD CHAIN.\n         XC    RC,RC              ASSUME GOOD RC.\n         MVC   INJCL(INJCLL),XINJCL INITIALIZE MACRO LISTS. INPUT DCB.\n         MVC   INTRDR(INTRDRL),XINTRDR OUTPUT DCB.\n         MVC   OPEN(OPENLEN),XOPEN  OPEN LIST.\n         MVC   WTO(WTOLEN),XWTO   WTO LIST.\n         MVI   CALL,0             ZERO CALL FLAG.                   L04\n         MVI   WTOFLG,0           ZERO WTO FLAG.\n         L     R2,PSAAOLD-PSA     GET OUR ADABAS JOBNAME. R2=A(ASCB).\n         L     R3,ASCBJBNI-ASCB(,R2) IF WE'RE A JOB, ASCBJBNI-> NAME.\n         LTR   R3,R3              ELSE,\n         BNZ   *+8                  IF WE'RE AN STC OR TSU,\n         L     R3,ASCBJBNS-ASCB(,R2) ASCBJBNS-> NAME.\n         MVC   OURJOB,0(R3)       SAVE NAME.\n********************************************************************\n*                                                                  *\n*        P A R M   P R O C E S S I N G                             *\n*                                                                  *\n********************************************************************\n         L     R2,4(,R13)         DIG BACK THRU SAVEAREAS\n         L     R2,24(,R2)           FOR THE A(PARM).\n         LTR   R2,R2              R2 = R1 UPON ENTRY TO THIS MODULE.\n         BP    DOLOG1             IF POSITIVE, ASSUME 1 PROLOG FULL.L04\n         BZ    DOLOG2             IF ZERO, IT'S BOTH PROLOGS FULL.  L04\n         CH    R2,=H'-1'          IF -1, IT'S 1 CMDLOG FULL.\n         BE    DOCMD1                                               L04\n         CH    R2,=H'-2'          IF -2, IT'S 2 CMDLOGS FULL.\n         BE    DOCMD2                                               L04\n         B     BADCODE            ELSE, PUT OUT A BAD CODE MSG.\n********************************************************************\n*                                                                  *\n*        M A I N L I N E                                           *\n*                                                                  *\n********************************************************************\nDOLOG1   DS    0H                 1 PROTECTION LOG FULL.            L04\n         MVI   CALL,PLOG1                                           L04\n         B     DOLOG                                                L04\nDOLOG2   DS    0H                 2 PROTECTION LOGS FULL.           L04\n         MVI   CALL,PLOG2                                           L04\nDOLOG    DS    0H                                                   L04\n         BAL   R10,FMTMSG         INIT MSG AREA.\n         MVC   MSGID,=CL8'ADA010I' MOVE IN MSGID.\n         MVC   MSGTEXT(L'MSGLOG1),MSGLOG1 MOVE IN MSGLOG1 TEXT.\n         CLI   CALL,PLOG1                                           L04\n         BE    *+10                                                 L04\n         MVC   MSGTEXT(L'MSGLOG2),MSGLOG2 MOVE IN MSGLOG2 TEXT.\n         BAL   R10,DOWTO          WTO MSGLOG1.\n         MVC   (DCBDDNAM-IHADCB)+INJCL,=CL8'PROJCL' USE PROJCL DDN. L04\n         BAL   R10,DOJOB          SUBMIT PROJCL JOB.                L04\n         BAL   R10,FMTMSG         REINIT MSG ARE.\n         MVC   MSGID,=CL8'ADA020I' MOVE IN MSGID.\n         MVC   MSGTEXT(L'MSGSUB),MSGSUB MOVE IN MSGSUB TEXT.\n         MVC   MSGSJOB+MSGTEXT,JCLJOB PUT SUBMITTED JOBNAME IN MSG.\n         BAL   R10,DOWTO          WTO MSGSUB.\n         CLI   CALL,PLOG1         IF  1 LOG FULL,                   L04\n         BE    RETURN               ALL DONE.                       L04\n         BAL   R10,FMTMSG         REIINIT MSG AREA.\n         MVC   MSGID,=CL8'ADA030A' MOVE IN MSGID.\n         MVC   MSGTEXT(L'MSGRUN2),MSGRUN2 MOVE IN MSGRUN2 TEXT.\n         MVC   MSGRJOB2+MSGTEXT,JCLJOB PUT SUBMITTED JOBNAME IN MSG.\n         OI    WTOFLG,NONROLL+DODOM MAKE MSG NONROLL AND DELETE AT END.\n         BAL   R10,DOWTO          WTO MSGRUN2.\n         MVC   DOMMSGID,SAVMSGID  SAVE RETURNED ID FOR DOM.\n         BAL   R10,FMTMSG         REINIT MSG AREA.\n         MVC   MSGID,=CL8'ADA040A' MOVE IN MSGID.\n         MVC   MSGTEXT(L'MSGREPLY),MSGREPLY MOVE IN MSGREPLY TEXT.\n         MVC   MSGPJOB1+MSGTEXT,JCLJOB PUB SUBMITTED JOBNAME IN MSG.\n         BAL   R10,DOWTOR         WTOR MSGREPLY.\n         B     RETURN             ALL DONE.\nDOCMD1   DS    0H                 1 COMMAND LOG FULL.               L04\n         MVI   CALL,CLOG1                                           L04\n         B     DOCMD                                                L04\nDOCMD2   DS    0H                 2 COMMAND LOGS FULL.              L04\n         MVI   CALL,CLOG2                                           L04\nDOCMD    DS    0H\n         BAL   R10,FMTMSG         INIT MSG AREA.                    L03\n         MVC   MSGID,=CL8'ADA010I' MOVE IN MSGID.                   L03\n         MVC   MSGTEXT(L'MSGCMD1),MSGCMD1 MOVE IN MSGCMD1 TEXT.     L03\n         CLI   CALL,CLOG1                                           L04\n         BE    *+10                                                 L04\n         MVC   MSGTEXT(L'MSGCMD2),MSGCMD2 MOVE IN MSGCMD2 TEXT.     L04\n         BAL   R10,DOWTO          WTO MSGCMD1.                      L03\n         MVC   (DCBDDNAM-IHADCB)+INJCL,=CL8'CMDJCL' USE CMDJCL DDN  L04\n         BAL   R10,DOJOB          SUBMIT CMDJCL JOB.                L04\n         BAL   R10,FMTMSG         REINIT MSG ARE.                   L03\n         MVC   MSGID,=CL8'ADA020I' MOVE IN MSGID.                   L03\n         MVC   MSGTEXT(L'MSGSUB),MSGSUB MOVE IN MSGSUB TEXT.        L03\n         MVC   MSGSJOB+MSGTEXT,JCLJOB PUT SUBMITTED JOBNAME IN MSG. L03\n         BAL   R10,DOWTO          WTO MSGSUB.                       L03\n         CLI   CALL,CLOG1         IF 1 LOG FULL,                    L04\n         BE    RETURN               ALL DONE.                       L04\n         BAL   R10,FMTMSG         REIINIT MSG AREA.                 L03\n         MVC   MSGID,=CL8'ADA030A' MOVE IN MSGID.                   L04\n         MVC   MSGTEXT(L'MSGRUN2),MSGRUN2 MOVE IN MSGRUN2 TEXT.     L03\n         MVC   MSGRJOB2+MSGTEXT,JCLJOB PUT SUBMITTED JOBNAME IN MSG.L03\n         OI    WTOFLG,NONROLL+DODOM MAKE MSG NONROLL AND DELETE AT EL03\n         BAL   R10,DOWTO          WTO MSGRUN2.                      L03\n         MVC   DOMMSGID,SAVMSGID  SAVE RETURNED ID FOR DOM.         L03\n         BAL   R10,FMTMSG         REINIT MSG AREA.                  L03\n         MVC   MSGID,=CL8'ADA050A' MOVE IN MSGID.                   L03\n         MVC   MSGTEXT(L'MSGREPLY),MSGREPLY MOVE IN MSGREPLY TEXT.  L03\n         MVC   MSGPJOB1+MSGTEXT,JCLJOB PUT SUBMITTED JOBNAME IN MSG.L03\n         BAL   R10,DOWTOR         WTOR MSGREPLY.                    L03\n         B     RETURN             ALL DONE.\n********************************************************************\n*                                                                  *\n*        S U B M I T   T H E   J O B                               *\n*                                                                  *\n********************************************************************\nDOJOB    DS    0H                 SUBMIT THE JOB.\n         OPEN  (INJCL,,INTRDR,(OUTPUT)),MF=(E,OPEN) OPEN BOTH FILES.\n         TM    (DCBOFLGS-IHADCB)+INJCL,DCBOFOPN\n         BZ    BADOPEN            CHECK RESULT OF OPEN.\n         TM    (DCBOFLGS-IHADCB)+INTRDR,DCBOFOPN\n         BZ    BADOPEN            CHECK RESULT OF OPEN.\n         GET   INJCL              GET AN INPUT RECORD.\n         MVC   JCLJOB,2(R1)       FOR 1ST RECORD, SAVE JOBNAME.\n         B     DOPUT              BRANCH INTO GET-PUT LOOP.\nDOGET    DS    0H\n         GET   INJCL              GET NEXT INPUT RECORD.\nDOPUT    DS    0H\n         LR    R0,R1\n         PUT   INTRDR,(0)         PUT NEXT OUTPUT RECORD.\n         B     DOGET              LOOP.\nEODAD    DS    0H\n         CLOSE (INJCL,,INTRDR),MF=(E,OPEN) CLOSE BOTH FILES.\n         FREEPOOL INJCL           RELEASE BUFFER POOL               L02\n         FREEPOOL INTRDR          RELEASE BUFFER POOL               L02\n         BR    R10                RETURN.\n********************************************************************\n*                                                                  *\n*        F O R M A T   M E S S A G E   H E A D E R                 *\n*                                                                  *\n********************************************************************\nFMTMSG   DS    0H\n         MVI   MSGAREA,C' '       BLANK MSGAREA.\n         MVC   MSGAREA+1(L'MSGAREA-1),MSGAREA\n         MVC   MSGJOB,OURJOB      MOVE IN OUR ADABAS JOBNAME.\n         MVI   MSGCOLON,C':'      THEN A COLON.\n         BR    R10                RETURN.\n********************************************************************\n*                                                                  *\n*        D O   W T O                                               *\n*                                                                  *\n********************************************************************\nDOWTO    DS    0H\n         MVC   WTO(WTOLEN),XWTO   INIT WTO PARM LIST.\n         MVC   WTOMSG(L'MSGAREA),MSGAREA MOVE MSGAREA TO WTO AREA.\n         TM    WTOFLG,NONROLL     IF REQUEST IS FOR NON-ROLLABLE MSG,\n         BZ    *+8\n         OI    WTODESC,X'40'        THEN MAKE MSG NON-ROLLABLE.\n         WTO   MF=(E,WTO)         WTO MSG.\n         ST    R1,SAVMSGID        SAVE MSGID FOR DOM.\n         NI    WTOFLG,255-NONROLL RESET WTOFLG.\n         BR    R10                RETURN.\n********************************************************************\n*                                                                  *\n*        D O   W T O R                                             *\n*                                                                  *\n********************************************************************\nDOWTOR   DS    0H\n         MVC   WTOR(WTORLEN),XWTOR INIT WTOR PARM LIST.\n         MVC   WTORMSG(L'MSGAREA),MSGAREA MOVE MSGAREA TO WTOR AREA.\nWTORLOOP DS    0H\n         XC    ECB,ECB            ZERO WTOR ECB.\n         WTOR  ,REPLY,L'REPLY,ECB,MF=(E,WTOR) WTOR MSG.\n         WAIT  ECB=ECB            WAIT FOR RESPONSE.\n         CLC   =C'OK',REPLY       WE WANT UPPER OR LOWERCASE \"OK\".\n         BE    OKWTOR             IF NEITHER, LOOP.\n         CLC   =XL2'9692',REPLY\n         BNE   WTORLOOP\nOKWTOR   DS    0H\n         BR    R10                RETURN.\n********************************************************************\n*                                                                  *\n*        R E T U R N                                               *\n*                                                                  *\n********************************************************************\nRETURN   DS    0H\n         CLOSE (INJCL,,INTRDR),MF=(E,OPEN) CLOSE FILES.\n         TM    WTOFLG,DODOM       IF A NON-ROLLABLE MESSAGE NEEDS\n         BZ    NODOM                DELETING,\n         L     R1,DOMMSGID        GET MSGID,\n         DOM   MSG=(1)              AND DELETE MESSAGE.\nNODOM    DS    0H\n         L     R2,RC                  R2 = RC.\n         LR    R1,R13              PREPARE\n         L     R13,4(,R13)         FOR FREEMAIN.\n         FREEMAIN RU,LV=DYNLEN,A=(1)\n         LR    R15,R2              AND RETURN\n         RETURN (14,12),RC=(15)      WITH R15 = RC.\n********************************************************************\n*                                                                  *\n*        E R R O R S                                               *\n*                                                                  *\n********************************************************************\nBADCODE  DS    0H                 EXIT ENTERED WITH BAD CODE.\n         MVC   RC,=F'12'          RC = 12.\n         BAL   R10,FMTMSG         INIT MSG AREA.\n         MVC   MSGID,=CL8'ADA060E' MOVE IN MSGID.                   L04\n         MVC   MSGTEXT(L'MSGCODE),MSGCODE MOVE IN MSGCODE TEXT.\n         BAL   R10,DOWTO          WTO MSGCODE.\n         B     RETURN             RETURN.\nBADOPEN  DS    0H                 BAD OPEN OF A FILE.\n         MVC   RC,=F'12'          RC = 12.\n         BAL   R10,FMTMSG         INIT MSG AREA.\n         MVC   MSGID,=CL8'ADA070E' MOVE IN MSGID.                   L04\n         MVC   MSGTEXT(L'MSGOPEN),MSGOPEN MOVE IN MSGOPEN TEXT.\n         OI    WTOFLG,NONROLL     MAKE MSG NON-ROLLABLE.\n         BAL   R10,DOWTO          WTO MSGOPEN.\n         B     RETURN             RETURN.\n********************************************************************\n*                                                                  *\n*        S T A T I C   A R E A S.                                  *\n*                                                                  *\n********************************************************************\nXINJCL   DCB   DDNAME=INJCL,MACRF=GL,DSORG=PS,EODAD=EODAD INPUT DCB.\nINJCLL   EQU   *-XINJCL\nXINTRDR  DCB   DDNAME=INTRDR,MACRF=PM,DSORG=PS,            OUTPUT DCB. X\n               RECFM=F,LRECL=80,BLKSIZE=80\nINTRDRL  EQU   *-XINTRDR\nXOPEN    OPEN  (0,,0),MF=L        OPEN LIST.\nOPENLEN  EQU   *-XOPEN\nXWTO     WTO   '                                                       X\n                                            ',ROUTCDE=11,MF=L\nWTOLEN   EQU   *-XWTO\nXWTOR    WTOR  '                                                       X\n                                            ',MF=L\nWTORLEN  EQU   *-XWTOR\nMSGOPEN  DC    C'BAD RC FROM OPEN, NO JOB SUBMITTED.'\nMSGLOG1  DC    C'ONE PROTECTION LOG FULL.'\nMSGLOG2  DC    C'BOTH PROTECTION LOGS FULL.'\nMSGCMD1  DC    C'ONE COMMAND LOG FULL.'                             L03\nMSGCMD2  DC    C'BOTH COMMAND LOGS FULL.'                           L03\nMSGCODE  DC    C'BAD ADAEX2 ENTRY CODE, IGNORED.'\nMSGSUB   DC    C'JOB          WILL COPY 1 LOG.'\nMSGSJOB  EQU   4,8\nMSGRUN2  DC    C'IS WAITING FOR JOB          TO RUN.'\nMSGRJOB2 EQU   19,8\nMSGREPLY DC    C'REPLY \"OK\" WHEN          IS DONE.'\nMSGPJOB1 EQU   16,8\n         LTORG *\nSRCLEVEL DC    C'                                        '\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   A R E A S.                                *\n*                                                                  *\n********************************************************************\nDYNAMIC  DSECT\nSAVE     DS    18F                SAVE AREA.\nDOUBLE   DS    D                  WORK AREA.\nRC       DS    F                  RETURN CODE.\nECB      DS    F                  WTOR ECB.\nSAVMSGID DS    F                  DOM MSGID.\nDOMMSGID DS    F                  DOM MSGID.\nINJCL    DS    0F,CL(INJCLL)      INPUT DCB.\nINTRDR   DS    0F,CL(INTRDRL)     OUTPUT DCB.\nOPEN     DS    0F,CL(OPENLEN)     OPEN AREA.\nWTO      DS    0F,CL(WTOLEN)      WTO AREA.\nWTODESC  EQU   *-4,2              DESCRIPTOR CODES.\nWTOMSG   EQU   WTO+4,80           MSGTEXT.\nWTOR     DS    0F,CL(WTORLEN)     WTOR AREA.\nWTORMSG  EQU   WTOR+12,80         MSGTEXT.\nCALL     DS    X                  CALL TYPE.                        L04\nPLOG1    EQU   1                  1 PROLOG.                         L04\nPLOG2    EQU   2                  2 PROLOGS.                        L04\nCLOG1    EQU   3                  1 CMDLOG.                         L04\nCLOG2    EQU   4                  2 CMDLOGS.                        L04\nWTOFLG   DS    X                  WTOFLG.\nNONROLL  EQU   X'80'              NON-ROLLABLE MESSAGE.\nDODOM    EQU   X'40'              NEED TO DELETE NON-ROLLABLE MESSAGE.\nOURJOB   DS    CL8                OUR ADABAS JOBNAME.\nJCLJOB   DS    CL8                SUBMITTED JOBNAME.\nMSGAREA  DS    CL80               MSG WORK AREA.\nMSGID    EQU   MSGAREA+0,8        MSGID.\nMSGJOB   EQU   MSGAREA+8,8        JOBNAME.\nMSGCOLON EQU   MSGAREA+16,1\nMSGTEXT  EQU   MSGAREA+18,62      TEXT.\nREPLY    DS    CL2                2 CHARACTER REPLY.\nDYNLEN   EQU   *-DYNAMIC          LENGTH.\n         PRINT OFF\nR0       EQU   00\nR1       EQU   01\nR2       EQU   02\nR3       EQU   03\nR4       EQU   04\nR5       EQU   05\nR6       EQU   06\nR7       EQU   07\nR8       EQU   08\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12                 PROGRAM BASE.\nR13      EQU   13                 A(SAVE AREA).\nR14      EQU   14\nR15      EQU   15\n         PRINT ON,NOGEN\n         DCBD  DSORG=PS,DEVD=DA   DCB\n         IHAPSA ,                 PSA\n         IHAASCB ,                ASCB\n         END   &CSECT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASMTOZAP": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\xc9\\x00\\xc9\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 201, "newlines": 201, "modlines": 0, "user": "FILE369"}, "text": "        /* DATA SET ASMTOZAP   AT LEVEL 001 AS OF 10/11/78    */\n ASZAP: PROC OPTIONS(MAIN) REORDER;                                     00001\n  /* THIS IS A UTILITY WHICH CONVERTS AN ASSEMBLER LISTING              00002\n     DATASET INTO A FORMATTED IMASPZAP INPUT DECK OR SMP PTF. IT        00003\n     IS USEFUL IN PREPARING, MAINTAINING, AND DOCUMENTING THOSE         00004\n     INSTALLATION MODIFICATIONS WHICH CANNOT BE INSTALLED EXECPT        00005\n     BY MODIFING IBM CODE. ONE CAN MAKE FREE USE OF MACROS,             00006\n     LITERALS, AND OTHER CONVENIENCE FEATURES IN PREPARING THE          00007\n     DECK. CONTROL CARDS IN SPECIAL ASSEMBLER COMMENT FORM              00008\n     PROVIDE FLEXABILITY IN MODIFICATION DESIGN AND CONTROL             00009\n     OVER OUTPUT.                                                       00010\n        ALL CONTROL CARDS ARE INCLUDED IN THE ASSEMBLER DECK            00011\n     BEGINNING WITH THE CHARACTERS '*ZAP'. THE PURPOSE OF THE           00012\n     CONTROL CARDS IS TO INTERRUPT AND RESUME GENERATION OF             00013\n     ZAP OUTPUT. STATEMENTS WHICH DO NOT GENERATE OBJECT CODE           00014\n     (COMMENTS,ORG,DS,EQU,ETC.) ARE TRANSFERRED TO THE OUTPUT AS        00015\n     ZAP COMMENT CARDS, UNLESS OUTPUT GENERATION IS CURRENTLY           00016\n     PAUSED. OTHER STATEMENTS (INSTRUCTIONS,DC,CCW,ETC.) ARE            00017\n     TRANSFERRED TO THE OUTPUT AS 'VER' OR 'REP' CARDS IF               00018\n     OUTPUT GENERATION HAS BEEN (RE)STARTED IN ONE OF THESE             00019\n     TWO MODES. THE CARDS GOVERNING THIS ARE                            00020\n          *ZAP START REP                                                00021\n          *ZAP START VER                                                00022\n          *ZAP PAUSE                                                    00023\n     ZAP GENERATION IS INITIALLY PAUSED. A '*ZAP START' CARD IS         00024\n     VALID AND (RE)STARTS GENERATION IN REP OR VER MODE, WHICHEVER      00025\n     WAS LAST ACTIVE, BUT IF IT IS THE FIRST START CARD IN THE          00026\n     DECK, IT CANNOT BE FOLLOWED BY OBJECT GENERATING STATEMENTS        00027\n     UNTIL MODE IS SPECIFIED ON A SUBSEQUENT '*ZAP START (VER/REP)'     00028\n     CARD.                                                              00029\n        WHEN THE ZAP IS DONE, A '*ZAP END' CARD WILL TERMINATE          00030\n     A SCAN OF THE LISTING AND CLOSE THE OUTPUT FILE. THIS NOT          00031\n     ONLY SAVES A FEW EXTRA MICROSECONDS OF CPU WHICH WOULD BE          00032\n     SPENT SCANNING THE MAPPING MACROS AND CROSS REFRENCE, BUT          00033\n     HELPS THE HUMAN READING THE ASSEMBLER TO KNOW WHERE THE            00034\n     ESSENTIAL CODE HAS STOPPED AND THE SUPPORT DEFINITIONS             00035\n     HAVE BEGUN. IT TAKES A LOT OF ZAP COMMENT CARDS TO DEFINE          00036\n     THE CVT DSECT.                                                     00037\n        THE '*ZAP CARD' CONTROL CARD ALLOWS ARBITRARY TEXT TO           00038\n     BE REPRODUCED INT THE OUTPUT. THE CHARACTERS UP TO THE             00039\n     SPACE AFTER 'CARD' ARE STRIPPED OFF AND THE REMAINDER OF           00040\n     THE CARD TO COLUMN 72 IS REPRODUCED IN THE OUTPUT DECK.            00041\n     THIS IS PRIMARILY FOR NAME,DUMP, AND SMP CONTROL CARDS.            00042\n          *ZAP CARD ++PTF(YU00001) /* TYPICAL PTF DECK * /.             00043\n          *ZAP CARD ++ZAP(IEXAMPLE).                                    00044\n          *ZAP CARD   EXPAND IEXAMPLE(50)                               00045\n          *ZAP CARD   NAME IEXAMPLE                                     00046\n          *ZAP START VER                                                00047\n     RESTRICTIONS:                                                      00048\n          YOU MUST SPECIFY 'PRINT DATA' IN THE ASSEMBLY IF YOU          00049\n             GENERATE CONSTANTS OR LITERAL IN EXCESS OF 8 BYTES         00050\n             LENGTH.                                                    00051\n          REMEMBER TO PUT THE 'LTORG' STATEMENT BEFORE THE              00052\n            '*ZAP END' CARD IF LITERALS ARE GENERATED.                  00053\n          NO RELOCATABLE ADDRESS CONSTANTS CAN BE CODED IN THE          00054\n            ZAP CARD.                                                   00055\n     IT IS NOT POSSIBLE AT THIS TIME TO DETECT VIOLATIONS OF THE        00056\n      RESTRICTIONS LISTED ABOVE. BE CAREFUL.                            00057\n     GOOD TECHNIQUE:                                                    00058\n        PUT ALL SENSITIVE ADDRESSES AT THE BEGINNING OF THE DECK AS     00059\n           EQU INSTRUCTIONS. THEY CAN BE EASILY MODIFIED WHEN HIT BY    00060\n           PTFS OR WHEN THE NEXT RELEASE IS DISTRIBUTED. CANDIDATES     00061\n           INCLUDE THE ZAPPED OVER INSTRUCTION, THE PATCH AREA, AND     00062\n           TARGETS OF CONDITIONAL BRANCH INSTRUCTIONS OTHER THAN THE    00063\n           NATURAL RETURN.                                              00064\n        IT IS SOMETIMES POSSIBLE TO IMBED THE ZAP INSTRUCTIONS IN       00065\n           ENOUGH SUPPORT CODE TO MAKE THE OBJECT DECK OUTPUT OF        00066\n           THE ASSEMBLY AN INDEPENDENTLY EXECUTABLE PROGRAM WHICH       00067\n           YOU CAN TSO TEST BEFORE INCORPORATING INTO THE SYSTEM.       00068\n           THIS SAVES A LITTLE SYSTEM TEST TIME TRACKING DOWN DATA      00069\n           EXCEPTIONS AND THE LIKE.                                     00070\n                                                                        00071\n     COMMENTS AND SUGGESTIONS SHOULD BE ADDRESSED TO                    00072\n          HOWARD GILBERT                                                00073\n          YALE COMPUTER CENTER                                          00074\n          175 WHITNEY AVE                                               00075\n          NEW HAVEN, CONN. 06520                                        00076\n                                                                        00077\n     DDNAMES USED: IN,OUT,SYSPRINT                                      00078\n  */                                                                    00079\n  DCL IN INPUT FILE RECORD /* DS CONTAINING SYSPRINT FROM ASSEMBLY */;  00080\n  DCL OUT OUTPUT FILE STREAM ENV(FB RECSIZE(80) BLKSIZE(800));          00081\n     /* RECEIVES ZAP CARDS */                                           00082\n  DCL LINE CHAR(133) VAR; /* ONE LINE OF ASSEMBLER */                   00083\n  DCL LINE2 CHAR(133);                                                  00084\n  DCL ADDR CHAR(4) DEF LINE2 POS(4); /* OFFSET OR ADDRESS PART */       00085\n  DCL DATA CHAR(16) DEF LINE2 POS(9); /* HEX INSTRUCTION CODE OR DATA */00086\n          /* NOTE THAT SUBSTR(DATA,1,1) OVERLAPS LAST DIGIT OF          00087\n             HEX REPRESENTATION OF ADDRESS GENERATED BY EQU             00088\n             STATEMENT, SO TEST IS ON SUBSTR(DATA,2,1) FOR              00089\n             PRESENCE OF ANY REAL DATA */                               00090\n  DCL CARD CHAR(72) DEF LINE2 POS(42); /* ASM SOURCE PART */            00091\n  DCL (DATE,TIME,INDEX,VERIFY,SUBSTR) BUILTIN;                          00092\n  DCL WHAT CHAR(3) INIT(' '); /* BECOMES 'VER' OR 'REP' */              00093\n  DCL SKP BIT(1) INIT('1'B);                                            00094\n  ON ERROR BEGIN;                                                       00095\n     ON ERROR SYSTEM;                                                   00096\n     PUT EDIT(' ERROR PROCESSING:',LINE)(SKIP,A);                       00097\n     END;                                                               00098\n  %PAGE;                                                                00099\n  /* LOGIC:                                                             00100\n     EACH LINE IS HANDLED SEPARATELY. THE ONLY INFORMATION WHICH        00101\n       EXTENDS ACROSS LINES IS THE MODE OF GENERATION IN 'WHAT'         00102\n       AND THE GENERATION (0) OR PAUSE (1) STATUS IN 'SKP'.             00103\n       FIRST ONE DETECTS AND PROCESSES CONTROL CARDS.                   00104\n       THEN ONE CHECKS FOR PAGE HEADER LINES AND BLANK LINES.           00105\n       ASSEMBLER COMMENT CARDS ARE REPRODUCED.                          00106\n       A COMMENT CARD IS PRODUCED FOR LABELS OR NON-OBJECT              00107\n         GENERATING STATEMENTS.                                         00108\n       A VER OR REP CARD IS CREATED FOR OBJECT GENERATING STATEMENTS.   00109\n    */                                                                  00110\n  GETLINE:                                                              00111\n     READ FILE(IN) INTO(LINE);                                          00112\n     LINE2=LINE;                                                        00113\n                                                                        00114\n                                                                        00115\n                                                                        00116\n     IF SUBSTR(CARD,1,4)='*ZAP' THEN                                    00117\n          DO /* ASMTOZAP CONTROL CARD PROCESSING */;                    00118\n          I=VERIFY(SUBSTR(CARD,5),' ') +4;                              00119\n          IF SUBSTR(CARD,I,5)='START' THEN                              00120\n               DO;                                                      00121\n               SKP='0'B;                                                00122\n               IF INDEX(CARD,'VER')>0 THEN WHAT='VER';                  00123\n               IF INDEX(CARD,'REP')>0 THEN WHAT='REP';                  00124\n               GO TO GETLINE;                                           00125\n               END;                                                     00126\n          IF SUBSTR(CARD,I,5)='PAUSE' THEN                              00127\n               DO;                                                      00128\n               SKP='1'B;                                                00129\n               GO TO GETLINE;                                           00130\n               END;                                                     00131\n          IF SUBSTR(CARD,I,4)='STOP'|SUBSTR(CARD,I,4)='END'             00132\n             THEN GO TO FINN;                                           00133\n          IF SUBSTR(CARD,I,4)='CARD' THEN                               00134\n               DO;                                                      00135\n               PUT FILE(OUT) EDIT(SUBSTR(CARD,I+5))(COL(1),A(72));      00136\n               GO TO GETLINE;                                           00137\n               END;                                                     00138\n          PUT EDIT ('***** UNRECOGNIZED CONTROL CARD ****',CARD)        00139\n               (SKIP(2),2 A);                                           00140\n          CALL PLIRETC(16);                                             00141\n          GO TO GETLINE;                                                00142\n          END /* OF CONTROL CARD PROCESSING */;                         00143\n     IF SKP THEN GO TO GETLINE;                                         00144\n  /* NO PROCESSING IS DONE IF GENERATION IS PAUSED */                   00145\n     IF VERIFY(SUBSTR(LINE2,2,23),' 0123456789ABCDEF')>0                00146\n        THEN GO TO GETLINE;                                             00147\n   /* IF THERE ARE NON HEX CHARACTERS IN THE ADDRESS AND DATA FIELDS    00148\n      THEN WE ARE PROBABLY LOOKING AT A PAGE TITLE LINE */              00149\n     IF CARD=' ' & DATA=' ' THEN GO TO GETLINE;                         00150\n          /* IF THESE FIELDS ARE BLANK, THEN WE ARE LOOKING AT BLANK    00151\n             LINES PRODUCED BY SPACE OR UNDER PAGE HEADER. */           00152\n     IF SUBSTR(CARD,1,1)='*' THEN                                       00153\n          DO /* REPRODUCE ASSEMBLER COMMENT CARD */;                    00154\n          PUT FILE(OUT) EDIT(CARD)(COL(1),A(72));                       00155\n          GO TO GETLINE;                                                00156\n          END;                                                          00157\n     IF SUBSTR(CARD,1,1)\u00ac=' ' & SUBSTR(DATA,2,1)\u00ac=' ' THEN              00158\n          DO /* WE HAVE A LABELLED OBJECT GENERATING STATEMENT.         00159\n            BREAK IT UP INTO TWO LINE, A COMMENTED 'LABEL EQU *' AND    00160\n            A VER OR REP LINE THIS ALLOWS LESS TRUNCATION OF THE        00161\n            COMMENT FIELD OF THE ASSEMBLER SOURCE, SINCE COLS 1-9 ARE   00162\n            NEVER REPRODUCED AS BLANKS. */;                             00163\n          PUT FILE(OUT) EDIT('*',SUBSTR(CARD,1,8),'EQU   *')            00164\n               (COL(1),A(1),COL(21),A(8),COL(30), A);                   00165\n          END;                                                          00166\n     IF SUBSTR(DATA,2,1)=' ' THEN                                       00167\n          DO /* NON-OBJECT-GENERATING STATEMENT */;                     00168\n          PUT FILE(OUT) EDIT('*',CARD)                                  00169\n               (COL(1),A(1),COL(21),A(60));                             00170\n          GO TO GETLINE;                                                00171\n          END /* IT IS PASSED AS A COMMENT */;                          00172\n     IF WHAT=' ' THEN                                                   00173\n          DO /* OBJECT GENERATOR HIT AFTER ONLY '*ZAP START' CARD */;   00174\n          PUT EDIT('**** NEITHER VER NOR REP HAS BEEN SPECIFIED ****',  00175\n               CARD)(SKIP, A);                                          00176\n          CALL PLIRETC(16);                                             00177\n          END;                                                          00178\n     /* ZAP IS WRITTEN IN TWO PIECES. FIRST VER OR REP AND OFFSET,      00179\n        NEXT DATA AND COLUMNS 10- ON ASSEMBLER SOURCE. */               00180\n     PUT FILE(OUT) EDIT(WHAT,ADDR,' ')(COL(1),A(3),X(1),A(4),A(1));     00181\n     I=1;                                                               00182\n               /* DATA GENERATING STATEMENTS ARE OF TWO KINDS:          00183\n                  MACHINE OPS GENERATE '0000 0000 0000' WITH            00184\n                  THE SECOND AND THIRD GROUP OPTIONAL.                  00185\n                  DC GENERATES A VARIABLE LENGTH                        00186\n                  '0000000000000000' WITH AN EVEN # DIGITS<17 */        00187\n          DO J=1 TO 4 WHILE(I<14);                                      00188\n          PUT FILE(OUT) EDIT(SUBSTR(DATA,I,4))(A(4));                   00189\n          IF SUBSTR(DATA,I+4,1)=' ' THEN I=I+1;                         00190\n          IF SUBSTR(DATA,I+4,1)\u00ac=' ' & I<10 THEN                        00191\n               PUT FILE(OUT) EDIT(',')(A(1));                           00192\n          I=I+4;                                                        00193\n          END;                                                          00194\n     PUT FILE(OUT) EDIT(SUBSTR(CARD,10))(COL(30),A(51));                00195\n     GO TO GETLINE;                                                     00196\n  FINN:                                                                 00197\n     PUT FILE(OUT) EDIT('* DECK PRODUCED BY THE ASMTOZAP UTILITY'       00198\n          ,DATE,TIME)(COL(1),A,X(1),P'99/99/99',X(1),A(6));             00199\n     END;                                                               00200\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AUTOIPL": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x01\\xc1\\x01\\xc1\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 449, "newlines": 449, "modlines": 0, "user": "FILE369"}, "text": "PRC      TITLE 'AUTOIPL - AUTOMATIC IPL PROGRAM.'\n********************************************************************\n*                                                                  *\n*  FUNCTION -                                                      *\n*                                                                  *\n*     THIS PROGRAM ISSUES OPERATOR COMMANDS READ FROM AN           *\n*     INPUT FILE.  IT ALLOWS CONDITIONAL COMMAND EXECUTION, TIMED  *\n*     COMMAND SUBMISSION, AND PROGRAM INVOCATION.  THESE FUNCTIONS *\n*     PERMIT THE PROGRAM TO BE USED FOR A FULLY AUTOMATED IPL      *\n*     PROCEDURE FOR THE SYSTEM.                                    *\n*                                                                  *\n*  USAGE -                                                         *\n*                                                                  *\n*     THE PROGRAM IS USUALLY INVOKED BY A STARTED SYSTEM TASK.     *\n*     THE FOLLOWING JCL SHOULD BE PLACED IN SYS1.PROCLIB:          *\n*                                                                  *\n*     //IPL     PROC   P=AUTOIPL,R=                                *\n*     //IEFPROC EXEC   PGM=AUTOIPL,PARM='&R'                       *\n*     //IEFRDER DD     DSN=SYS1.PROCLIB(&P),DISP=SHR               *\n*                                                                  *\n*     A SERIES OF OPERATOR COMMANDS ARE STORED IN THE DATASET      *\n*     ALLOCATED TO DDNAME IEFRDER.  ANY DATA IN COLUMNS 73-80 IS   *\n*     IGNORED IN THE INPUT DATA.  THE COMMANDS IN THE INPUT DATA   *\n*     ARE WRITTEN TO THE SYSTEM MASTER  CONSOLE AS THEY ARE ISSUED.*\n*                                                                  *\n*     SOME CHARACTERS IN THE INPUT DATA HAVE SPECIAL SIGNIFICANCE: *\n*                                                                  *\n*     AN ASTERISK (*) IN COLUMN 1 INDICATES THAT THIS LINE IS      *\n*     NOT TO BE ISSUED AS A COMMAND.  IT IS DISPLAYED ON THE       *\n*     SYSTEM MASTER CONSOLE, HOWEVER.  EXAMPLE:                    *\n*                                                                  *\n*     * THIS IS A MESSAGE TO THE OPERATOR                          *\n*                                                                  *\n*     A SEMICOLON (;) SEPARATES TWO COMMANDS ON THE                *\n*     SAME LINE.   IN THIS WAY, MULTIPLE COMMANDS PER LINE MAY BE  *\n*     ISSUED IF DESIRED.  EXAMPLE:                                 *\n*                                                                  *\n*     S TCAM; S TSO                                                *\n*                                                                  *\n*     A SLASH (/) FOLLOWED BY AN INTEGER INDICATES A WALL-CLOCK    *\n*     TIME DELAY OF AN INTEGER NUMBER OF SECONDS AFTER ISSUING THE *\n*     SPECIFIED OPERATOR COMMAND.  EXAMPLE:                        *\n*                                                                  *\n*     S TCAM/10                                                    *\n*     S TSO                                                        *\n*                                                                  *\n*     A LABEL PRECEEDING A COLON (:) BEFORE AN OPERATOR COMMAND    *\n*     CAN BE USED TO CONDITIONALLY EXECUTE A COMMAND LINE.         *\n*     IF THE LABEL NAME IS SPECIFIED IN THE PARM FIELD OF THE EXEC *\n*     CARD, ANY COMMAND LINES CONTAINING THAT LABEL FOLLOWED BY A  *\n*     COLON WILL NOT BE ISSUED. EXAMPLE:                           *\n*                                                                  *\n*     S TCAM/10                                                    *\n*     S TSO                                                        *\n*     NOCICS: S CICS                                               *\n*                                                                  *\n*     S IPL,R=NOCICS   WILL CAUSE CICS NOT TO BE STARTED           *\n*     S IPL            WILL CAUSE CICS TO BE STARTED               *\n*                                                                  *\n*     A SINGLE QUOTE IN COLUMN 1 INDICATES A PROGRAM CALL          *\n*     IS REQUESTED.  THE PROGRAM NAME TO BE LINKED TO IS           *\n*     ENCLOSED IN SINGLE QUOTES.  THE PARM FIELD FOR THE PROGRAM   *\n*     FOLLOWS THE ENDING QUOTE.  EXAMPLE:                          *\n*                                                                  *\n*     'MYPGM001'PARM-VALUE                                         *\n*                                                                  *\n*     A PROGRAM CALLED 'REPLYTO' HAS BEEN WRITTEN TO ISSUE CANNED  *\n*     REPLIES TO WTORS.  THE PROGRAM MAY BE INVOKED VIA THE        *\n*     PROGRAM CALL FUNCTION OF THIS PROGRAM. EXAMPLE:              *\n*                                                                  *\n*     S HASP                                                       *\n*     'REPLYTO 'HASP,U                                             *\n*                                                                  *\n*     EXECUTION OF OPERATOR COMMANDS IS DELAYED UNTIL THE INVOKED  *\n*     PROGRAM HAS RETURNED CONTROL.                                *\n*                                                                  *\n*     THE FOLLOWING IS AN EXAMPLE OF A DATA STREAM USING ALL OF    *\n*     THE FACILITIES OF THE START PROGRAM:                         *\n*                                                                  *\n*     * AUTOMATIC IPL IN PROGRESS                                  *\n*     S S168/10                                                    *\n*     S CLEAN,V=SCR001; S CLEAN,V=SCR002/10                        *\n*     S HASP                                                       *\n*     'REPLYTO 'HASP,U/10                                          *\n*     $PI10;$PI11;$PI12;$PI13;$PI14                                *\n*     $PI                                                          *\n*     $S                                                           *\n*     S TCAM/10                                                    *\n*     S TSO/16                                                     *\n*     NOLINES: S LINES/4                                           *\n*     $SI                                                          *\n*                                                                  *\n*  ATTRIBUTES -                                                    *\n*                                                                  *\n*     REENTRANT, MUST BE LINKEDITED INTO LINKLIST WITH AC=1.       *\n*                                                                  *\n*  ENVIRONMENT -                                                   *\n*                                                                  *\n*     VS/2 RELEASE 1.7-3.7.                                        *\n*                                                                  *\n*  LOG -                                                           *\n*                                                                  *\n*     04/00/85 L01 PTW IMPLEMENTED AT PRC.                         *\n*     11/17/86 L02 PTW ADD ENQ/DEQ FOR OPERATOR PROTECTION.        *L02\n*     12/03/86 L03 PTW GETMAIN 8192 BYTES FOR LARGER INPUT.        *L03\n*     06/09/87 L04 PTW BETTER ENQ/DEQ ERROR MESSAGE.               *L04\n*                                                                  *\n********************************************************************\nAUTOIPL  CSECT\n********************************************************************\n*                                                                  *\n*        I N I T I A L I Z E                                       *\n*                                                                  *\n********************************************************************\n         PRINT NOGEN                                                L02\n         BALR  R12,0              SET UP BASE REGISTER\n         USING *,R12              DECLARE IT\n* NOTE THAT NO SAVE AREA IS USED OR PROVIDED\n         L     R10,0(R1)          SAVE INPUT LOCATION\n         L     R0,=F'8192'        GET 8K WORK AREA                  L03\n         LA    R1,1                FROM\n         SLL   R1,24                SUBPOOL\n         OR    R0,R1                 ONE\n         GETMAIN R,LV=(0)         GET WORK CORE\n         LR    R13,R1             ADDRESS GOTTEN\n         USING WK,R13             MAP OUT WORK AREA\n         XC    WK(WKLEN),WK       CLEAR PART OF THE AREA\n         L     R2,PSAAOLD-PSA     ISSUE ENQ WITH MINOR=JOBNAME.     L02\n         L     R3,ASCBJBNI-ASCB(,R2)                                L02\n         LTR   R3,R3                                                L02\n         BNZ   *+8                                                  L02\n         L     R3,ASCBJBNS-ASCB(,R2)                                L02\n         MVC   ENQ(ENQLEN),XENQ                                     L02\n         ENQ   (=CL8'AUTOIPL',(R3)),MF=(E,ENQ)                      L02\n         LTR   R15,R15                                              L02\n         BNZ   BADENQ                                               L02\n         SR    R2,R2              CLEAR STOPPER VALUE\n         LH    R1,0(R10)          LENGTH OF FIELD\n         LTR   R4,R1              SAVE AND TEST LENGTH\n         BZ    *+10               IF NULL BYPASS MOVE\n         BCTR  R1,0               MOVE LENGTH FOR EXECUTE\n         EX    R1,MOVEPARM        COPY THE PARAMETER FIELD OUT OF SP 0\n* SET UP PARAMETER SCAN\n         LA    R3,PARMFLD         GET START OF PARAMETER LIST\n         AR    R4,R3              COMPUTE END\n         ST    R4,SCANEND         SAVE IT\n         MVI   0(R4),C';'         ENSURE RESTRICTIONS END HERE\n********************************************************************\n*                                                                  *\n*        M A I N L I N E   P R O C E S S I N G                     *\n*                                                                  *\n********************************************************************\n* READ IEFRDER INPUT IF PRESENT\n         L     R1,16              R1,--> CVT\n         L     R1,0(R1)           R1 -->--> TCB\n         L     R1,0(R1)           R1 --> TCB\n         L     R1,12(R1)          R1 --> TIOT\n         LA    R1,24(R1)          R1 --> FIRST DD ENTRY\n         SR    R0,R0              CLEAR FOR IC\nTIOTLOOP IC    R0,0(R1)           GET ENTRY LENGTH\n         LTR   R0,R0              TEST ENTRY\n         BZ    ENDIO              IF NOT QUIT\n         CLC   =C'IEFRDER ',4(R1) IS THIS IT?\n         BE    TIOTFND            IF SO GO OPEN IT\n         AR    R1,R0              ELSE TRY NEXT\n         B     TIOTLOOP            DD ENTRY\n* PREPARE FOR INPUT\nTIOTFND  MVC   DCB(DCBLEN),DCBMFL  MOVE DCB\n         OPEN  (DCB,INPUT),MF=(E,OPEN) OPEN IT\n         TM    DCB+48,X'10'       OPEN?\n         BZ    ENDIO              IF NOT QUIT\nGETLOOP  CLI   0(R4),C';'         SEMICOLON?\n         BE    *+12               IF SO SKIP\n         LA    R4,1(R4)           ELSE\n         MVI   0(R4),C';'         PUT IN ONE\n         LA    R4,1(R4)           ADVANCE OVER SEPARATOR\nGETLOOP1 GET   DCB,(R4)           READ NEXT RECORD\n         LA    R4,71(R4)          POINT TO LAST INPUT\n         CLI   0(R4),C' '         IS CHARACTER BLANK?\n         BNE   *+8                IF NOT END OF DATA\n         BCT   R4,*-8             ELSE BACK UP AND LOOP\n         B     GETLOOP            REPEAT THE LOOP\nEOF      ST    R4,SCANEND         SET NEW END\n         CLOSE (DCB),MF=(E,OPEN)  CLOSE OUT THE FILE\nENDIO    DS    0H                 END OF EXTERNAL INPUT\n         LA    R7,RSTRTAB         RESTRICTION TABLE\n         MVI   0(R7),X'FF'        SET IT EMPTY\n         XC    TABLE(256),TABLE    SET UP TRT TABLE\n         MVI   TABLE+C':',4        AND\n         MVI   TABLE+C'/',8         INSERT\n         MVI   TABLE+C';',12         STOPPER\n         MVI   TABLE+C',',4           VALUES\n         LA    R1,DWORK           SET UP EXECUTE FORM\n         ST    R1,LINK             OF LINK MACRO\nGETRESTR DS    0H                 GET RESTRICTIONS SPECIFIED\n         BAL   R11,GETPARM        GET NEXT SUBFIELD\n         B     *(R2)              BRANCH ON STOPPER\n         B     MOVERSTR           :\n         B     MOVERSTR           /\n         B     MOVERSTR           ;\n         B     EXIT               (END)\nMOVERSTR LTR   R5,R5              TEST LENGTH\n         BM    RSTRTEST           NULL - SKIP MOVE\n         EX    R5,MOVE1           MOVE IT\n         STC   R5,0(R7)           SAVE LENGTH\n         LA    R7,2(R5,R7)        NEXT SLOT\n         MVI   0(R7),X'FF'        CLEAR IT\nRSTRTEST B     *(R2)              BRANCH ON STOPPER\n         B     GETRESTR           :\n         B     GETRESTR           /\n*        B     GETCMD             ;\n         MVI   TABLE+C',',X'00'   DELETE COMMA AS SEPARATOR\nGETCMD   DS    0H                 GET THE COMMAND FIELD\n         BAL   R11,GETPARM        GET THE NEXT SUBFIELD\n         B     *(R2)              BRANCH ON STOPPER\n         B     TSTRSTR            :\n         B     MOVECMD            /\n         B     MOVECMD            ;\n*        B     MOVECMD            (END)\nMOVECMD  LTR   R5,R5              TEST LENGTH\n         BM    TESTCMD            NULL - SKIP MOVE\n         EX    R5,MOVE2           MOVE IT\n         LA    R0,6(R5)           BUFFER LENGTH\n         STH   R0,CMD             SET IT\n         LA    R5,COMMAND+1(R5)   END OF COMMAND\n         MVI   0(R5),C' '         PUT BLANK THERE\n         MODESET KEY=ZERO         GET PK=0\n         SR    R0,R0              CLEAR R0\n         STH   R0,CMD+2           CLEAR MCS FLAGS\n         LA    R1,CMD             POINT TO COMMAND\n         CLI   COMMAND,C''''      LINK REQUEST?\n         BE    MOVECMD2           IF SO GO LINK\n         CLI   COMMAND,C'*'       MESSAGE ONLY?\n         BE    MOVECMD1           IF SO BYPASS SVC 34\n         SVC   34                 ISSUE COMMAND\n         MODESET KEY=NZERO        RESET PROTECTION KEY\nMOVECMD1 DS    0H\n         LA    R1,CMD             POINT AGAIN\n         MVC   1(4,R5),=X'10004000' DESC=1,ROUTCDE=4\n         OI    CMD+2,X'80'        SHOW ROUTCDE AND DECR PRESENT\n         OI    CMD+3,X'04'        SHOW BYPASS HARDCOPY\n         SVC   35                 TELL OPERATOR\n         B     TESTCMD            BYPASS LINK CODE\nMOVECMD2 MVC   DWORK,COMMAND+1    ASSUMES EXACTLY 8 BYTES IN NAME\n         LA    R1,COMMAND+10      FIRST TEXT BYTE\n         SR    R5,R1              LENGTH OF TEXT FOR PARM\n         LA    R1,COMMAND+8       R1 --> PARAMETERS\n         ST    R1,CMD             SET POINTER\n         OI    CMD,X'80'          SET END OF LIST\n         STH   R5,0(R1)           SAVE IN PARAMETER\n         LA    R1,CMD             POINT TO LIST\n         LINK  SF=(E,LINK)        LINK TO THE GUY\nTESTCMD  B     *-4(R2)            BRANCH ON STOPPER\n         B     GETWAIT            /\n         B     GETCMD             ;\n*        B     EXIT               (END)\n********************************************************************\n*                                                                  *\n*        R E T U R N                                               *\n*                                                                  *\n********************************************************************\nEXIT     DS    0H                                                   L02\n         DEQ   RET=NONE,MF=(E,ENQ)     RELEASE ENQ.                 L02\nFREEEXIT DS    0H                                                   L02\n         FREEMAIN R,SP=1          FREE THE WORK AREA\n         SVC   3                   AND GET OUT\nGETWAIT  DS    0H                 GET TIME AND WAIT\n         BAL   R11,GETPARM        GET THE SUBFIELD\n         LTR   R5,R5              TEST LENGTH\n         BM    TESTWAIT           NULL - SKIP STIMER\n         LA    R5,X'70'(R5)       JIGGLE LENGTH\n         EX    R5,PACK1           PACK IT\n         CVB   R1,DWORK           AND CONVERT (0C6?)\n         MH    R1,=H'100'         COMPUTE HUNDREDTHS\n         ST    R1,DWORK           SAVE THE TIME\n         STIMER WAIT,BINTVL=DWORK SWEAT IT OUT\n         B     TESTWAIT           SHARED CODE\nGETSEMI  DS    0H                 RECOVER TO SEMICOLON\n         BAL   R11,GETPARM        GET NEXT SUBFIELD\nTESTWAIT B     *(R2)              BRANCH ON STOPPER\n         B     GETSEMI            :\n         B     GETSEMI            /\n         B     GETCMD             ;\n         B     EXIT               (END)\nTSTRSTR  DS    0H                 TEST RESTRICTIONS\n         LTR   R5,R5              TEST LENGTH\n         BM    GETCMD             NULL - RECYCLE\n         LA    R7,RSTRTAB         START OF TABLE\n         SR    R1,R1              IC REGISTER\nTSTRSTR1 CLI   0(R7),X'FF'        END OF TABLE\n         BE    GETCMD             YES - RETURN\n         IC    R1,0(R7)           GET TEST LENGTH\n         LR    R6,R1              TRY R1 LENGTH\n         CR    R1,R5              TEST LENGTHS\n         BNH   TSTRSTR2           R1 SHORTER\n         LR    R6,R5              USE R5 LENGTH\nTSTRSTR2 EX    R6,COMP1           COMPARE FIELDS\n         BE    GETSEMI            EQUAL - BYPASS CMD\n         LA    R7,2(R1,R7)        GO TO NEXT\n         B     TSTRSTR1           AND TEST AGAIN\nGETPARM  DS    0H                 GET A PARAMETER SUBFIELD\n         LR    R4,R3              START OF SUBFIELD\n         CLI   0(R4),C','         LEADING COMMA?\n         BNE   *+8                NO - SKIP NEXT\n         LA    R4,1(R4)           BYPASS COMMA AS JCL SEPARATOR\n         L     R3,SCANEND         END OF SCAN\n         SR    R3,R4              ARE WE THERE?\n         BNP   GETEND             YES - RETURN END\n         CH    R3,*+10            OVER 256 CHARACTERS LEFT?\n         BL    *+8                IF NOT SKIP\n         LA    R3,255             ELSE REDUCE TO 256\n         EX    R3,TRT1            SCAN FOR DELIMITER\n         LA    R3,1(R1)           START OF NEXT\n         BNZ   GETCNT             FOUND - PROCESS IT\nGETEND   L     R3,SCANEND         NOT FOUND - USE END\n         LR    R1,R3              CONTINUE THE FAKERY\n         LA    R2,16              END CODE\nGETCNT   LA    R5,0(R1)           END ADDRESS\n         SR    R5,R4              LENGTH\n         BNP   GETNULL            TEST FOR NULL\n         BCTR  R5,0               LENGTH-1\n         BR    R11                RETURN\nGETNULL  LA    R5,1               +1\n         LNR   R5,R5              -1\n         BR    R11                RETURN\nDCBEXIT  DC    0F'0',X'85',AL3(DCBEXIT+4)  EXIT LIST FOR DCB\n         OC    DCBLRECL,DCBLRECL  LRECL SPECIFIED?\n         BNZ   *+8                IF SO LEAVE IT\n         MVI   DCBLRECL+1,80      ELSE SET DEFAULT OF 80\n         OC    DCBBLKSI,DCBBLKSI  BLKSIZE SPECIFIED?\n         BNZR  R14                IF SO RETURN\n         MVI   DCBBLKSI+1,80      ELSE SET DEFAULT OF 80\n         MVI   DCBRECFM,X'80'     SET RECFM=F\n         BR    R14                RETURN\n********************************************************************\n*                                                                  *\n*        E R R O R S                                               *\n*                                                                  *\n********************************************************************\nBADENQ   DS    0H                                                   L04\n         BAL   R11,FMTMSG                                           L04\n         MVC   MSGTEXT(L'MSGENQ),MSGENQ                             L04\n         BAL   R11,DOWTO                                            L04\n         B     FREEEXIT                                             L02\n********************************************************************L04\n*                                                                  *L04\n*        F O R M A T   M E S S A G E                               *L04\n*                                                                  *L04\n********************************************************************L04\nFMTMSG   DS    0H                                                   L04\n         MVI   MSGAREA,C' '                                         L04\n         MVC   MSGAREA+1(L'MSGAREA-1),MSGAREA                       L04\n         MVC   MSGJOB,0(R3)        MOVE IN OUR JOBNAME.             L04\n         MVI   MSGCOLON,C':'      THEN A COLON.                     L04\n         BR    R11                                                  L04\n********************************************************************L04\n*                                                                  *L04\n*        D O   W T O                                               *L04\n*                                                                  *L04\n********************************************************************L04\nDOWTO    DS    0H                                                   L04\n         MVC   WTO(WTOL),XWTO     ELSE DO WTO.                      L04\n         MVI   WTOMSG,C' '        BLANK MSGTEXT.                    L04\n         MVC   WTOMSG+1(L'WTOMSG-1),WTOMSG                          L04\n         MVC   WTOMSG(L'MSGAREA),MSGAREA                            L04\n         MVI   WTODESC,X'40'                                        L04\n         WTO   MF=(E,WTO)                                           L04\n         BR    R11                                                  L04\n********************************************************************\n*                                                                  *\n*        S T A T I C   A R E A                                     *\n*                                                                  *\n********************************************************************\nMSGENQ   DC    C'IS ALREADY RUNNING, AN ABEND FOLLOWS.'             L04\nMOVEPARM MVC   PARMFLD(*-*),2(R10) MOVE PARAMETER TO SQS\nMOVE1    MVC   1(*-*,R7),0(R4)    MOVE RSTR\nMOVE2    MVC   COMMAND(*-*),0(R4) MOVE CMD\nPACK1    PACK  DWORK,0(*-*,R4)    PACK TIME\nCOMP1    CLC   1(*-*,R7),0(R4)    COMPARE RSTR\nTRT1     TRT   0(*-*,R4),TABLE    SEARCH FOR DELIMITER\nDCBMFL   DS    0F                 TRUE START OF DCB CODE\n         DCB   DDNAME=IEFRDER,DSORG=PS,MACRF=GM,                       *\n               EODAD=EOF,EXLST=DCBEXIT DCB SKELETON\n         OPEN  (0,INPUT),MF=L     OPEN SKELETON\nXENQ     ENQ   (,,E,8,SYSTEM),RET=USE,MF=L                          L02\nENQLEN   EQU   *-XENQ                                               L02\nXWTO     WTO   '                                                       X\n                                            ',MF=L,ROUTCDE=11       L04\nWTOL     EQU   *-XWTO\n         LTORG *\nSRCLEVEL DC    C'                                        '          L02\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   A R E A S                                 *\n*                                                                  *\n********************************************************************\nWORKSECT DSECT                    MAPPING OF GOTTEN CORE\nWK       DS    0D                 ALIAS FOR WORK AREA\nSAVEAREA DS    18F                SAVE AREA FOR LINKED PROGRAMS\nDWORK    DS    D                  GENERAL WORK, ALSO LINK NAME\nSCANEND  DS    A                  END OF COMMAND STRING\nRSTRTAB  DS    25F                COMMAND RESTRICTIONS\nLINK     LINK  EP=0,SF=L          PLACE FOR LINK PARAMETER\nENQ      DS    CL(ENQLEN)         PLACE FOR LINK PARAMETER          L02\nWKLEN    EQU   *-WK               LENGTH TO CLEAR INITIALLY         L02\nTABLE    DS    64F                STOPPER TABLE\n         ORG   TABLE              REUSE FOR DCB, ETC.\nDCB      DCB   DDNAME=IEFRDER,DSORG=PS,MACRF=GM\nOPEN     OPEN  (DCB,INPUT),MF=L\nDCBLEN   EQU   *-TABLE            LENGTH TO MOVE FOR DCB\n         ORG   DCB+36\nDCBRECFM DS    XL1                RECORD FORMAT\n         ORG   DCB+62\nDCBBLKSI DS    H                  BLOCK SIZE\n         ORG   DCB+82\nDCBLRECL DS    H                  RECORD LENGTH\n         ORG   ,                  BACK TO NORMAL?\nCMD      DS    F                  V-FORMAT HEADER\nCOMMAND  DS    0CL72              COMMAND TO EXECUTE\n         DS    CL8                SPACER\nPARMFLD  DS    0CL1               INPUT STRING BUILT HERE\nWTO      DS    0F,CL(WTOL)                                          L04\nWTOMSG   EQU   WTO+4,80                                             L04\nWTODESC  EQU   *-4,2                                                L04\nMSGAREA  DS    CL80                                                 L04\nMSGJOB   EQU   MSGAREA,8                                            L04\nMSGCOLON EQU   MSGAREA+8,1                                          L04\nMSGTEXT  EQU   MSGAREA+10,70                                        L04\n         IHAPSA ,                 PSA                               L02\n         IHAASCB ,                ASCB                              L02\n         PRINT OFF                                                  L02\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         PRINT ON                                                   L02\n         END   AUTOIPL\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BITENCOD": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00B\\x00B\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 66, "newlines": 66, "modlines": 0, "user": "FILE369"}, "text": "         PUNCH ' ALIAS BITDECOD'\nBITENCOD PRIME ID=DICK_SZIEDE_PRC_1986\n*-------\n*-------  TITLE  : BITENCODE\n*-------  AUTHOR : DICK SZIEDE, PRC, 1986\n*-------  PURPOSE: THIS SUBROUTINE TAKES A SINGLE CHARACTER ARGUMENT\n*-------           OF ONE BYTE, AND RETURNS EIGHT CHARACTERS OF\n*-------           ONES OR ZEROS DEPENDING ON THE BITS SET IN THE\n*-------           ARGUMENT.\n*-------  ARGUMENTS:\n*-------           1.  THE ADDRESS OF THE BYTE TO BE DECODED.\n*-------           2.  THE ADDRESS OF AN EIGHT BYTE CHARACTER VARIABLE\n*-------               THAT WILL CONTAIN THE RESULT.\n*-------  OUTPUT:  RETURN CODE IS ALWAYS ZERO.\n*-------\n*-------  ALIAS  : BITDECODE\n*-------  PURPOSE: THIS SUBROUTINE TAKESS EIGHT CHARACTERS OF\n*-------           DATA AND RETURNS A SINGLE BYTE, THE BITS OF\n*-------           WHICH ARE THE RIGHTMOST BITS OF EACH ARGUMENT\n*-------           BYTE.  THUS IS  IS THE OPPOSITE OF BITENCODE.\n*-------  ARGUMENTS:\n*-------           1.  THE ADDRESS OF THE BYTE TO BE ENCODED.\n*-------           2.  THE ADDRESS OF AN EIGHT BYTE CHARACTER VARIABLE\n*-------               THAT WILL BE CONVERTED TO 8 BITS.\n*-------  OUTPUT:  RETURN CODE IS ALWAYS ZERO.\n*-------\n*-------\n         REGS\nBITENCOD  AMODE 24\nBITENCOD  RMODE 24\n*\n         LM    R10,R11,0(R1)       POINTER TO PARMLIST.\n         ICM   R9,B'1000',0(R10)   R9 NOW HAS BYTE TO BE DECODED.\n         LA    R5,0(,R11)         R5 IS TARGET ADDRESS\n         LA    R7,8(,R11)         R7 IS LIMIT ADDRESS\n         LA    R6,1               LOOP INCREMENT OF 1\n         MVC   0(8,R5),=C'00000000'   SET DEFAULT\n         LA    R4,C'1'            SET FOR CUTE TRICK\n*\nLOOP     SR    R8,R8              BE SURE MASK IS SERO\n         SLDL  R8,1               GET MASK BIT FROM ARGUMENT\n         EX    R8,STOMPIT         STORE A 1 IF A BIT SHIFTED\n         BXLE  R5,R6,LOOP         INTO R8\n*\n         TERME RC=0\nSTOMPIT  STCM  R4,0,0(R5)\n         LTORG\nBITDECOD PRIME ID=DICK_SZIEDE_PRC_1986\nBITDECOD  AMODE 24\nBITDECOD  RMODE 24\n*\n         LM    R10,R11,0(R1)       POINTER TO PARMLIST.\n         LA    R2,2               OUTERLOOP COUNTER\n         L     R8,4(R11)          RIGHT 4 BYTES TO ENCODE\nOUTLOOP  LA    R3,4               INNER LOOP COUNTER\nINLOOP   SRDL  R8,1               GET RIGHTMOST BIT OF BYTE\n         SRL   R8,7               DUMP GARBAGE BITS\n         BCT   R3,INLOOP\n         L     R8,0(R11)          LEFT 4 BYTES TO ENCODE\n         BCT   R2,OUTLOOP\n*\nDEEND    STCM  R9,B'1000',0(R10)\n         TERME RC=0\nSRCLEVEL DC    C'BITENCOD V01.M06 86/05/13 13:15 PSYRRS  '\n         CSECT\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CALENDAR": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\xf9\\x00\\xf9\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 249, "newlines": 249, "modlines": 0, "user": "FILE369"}, "text": "OPTIONS S=72;\n*----  CALENDAR....DICK SZIEDE,  CSC 1982.                           ;\n*----                                                                ;\n*----  THE OUTPUT FORMAT IS COPIED FROM A COBOL PROGRAM I GOT FROM A ;\n*----  BURROUGHS SHOP.  AUTHOR UNKNOWN.                              ;\n*----                                                                ;\n*----  I WANTED TO MAKE IT PRINT 8-LPI.  I FOUND IT WAS EASIER TO    ;\n*----  REWRITE IT IN SAS THAN IT WAS TO FIGURE OUT UNCOMMENTED COBOL.;\n*----                                                                ;\n*---- AN 8-LPI ASSUMPTION IS HARD-CODED IN THIS CALENDAR.  A P-11    ;\n*---- OR PN TRAIN WILL WORK.  USE OF THE VERTICAL BAR FOR THE SIDES  ;\n*---- ASSUMES A PRETTY GOOD PRINT REGISTRATION.  I HAVE A STC-1800.  ;\n*---- ON AN IBM 1403 OR 3211, FORGET IT!  USE AN ASTERISK.           ;\n*---                                                                 ;\n*----                                                                ;\n*----                                                                ;\n*----                                                                ;\n*----                                                                ;\n*---- ALLOW PRETTY FREE-FORM INPUT BY SCANNING DATES FOR ALPHA MONTH  ;\n*---- THE INPUT FORMAT ALLOWS ONE EMBEDDED BLANK IN THE EVENT         ;\n*----                                                                 ;\nDATA EVENTS (KEEP=DATE KIND WORDS AGE)\n     PARMS  (KEEP=YEAR HEADER);\n     INFILE  EVENTS;\n     RETAIN YYYY;               *    SAVE A   4-CHARACTER YEAR        ;\n     RETAIN YEAR;               *    SAVE A   NUMERIC     YEAR        ;\n     FORMAT DATE DATE8.;\n\n     INPUT KKK $1.@;            *  WE ALLOW IMBEDDED COMMENTS BY      ;\n     IF  KKK > 'Z';             *  CHECKING FOR NON-NUMERIC FIRST     ;\n                                *  CHARACTER;                         ;\n     INPUT @1 KIND @;\n     IF  KIND=0 THEN DO;        *    GET HEADER STUFF                 ;\n         INPUT @3 YEAR @3 YYYY $4.\n               @7 HEADER $64.@;\n         OUTPUT PARMS;\n         END;\n     IF  KIND > 0 THEN DO;      *    READ EVENT DATES, ALLOWING ONE   ;\n         INPUT EVENT $     WORDS & $14.@;* EMBEDDED BLANK.;\n         MON_POS=VERIFY(EVENT,'0123456789');\n         TEMP=SUBSTR(EVENT,1,(MON_POS+2))||SUBSTR(YYYY,3,2);\n         IF  MON_POS=2 THEN TEMP='0'||TEMP; * STUFF IN A LEADING ZERO;\n         DATE=INPUT(TEMP,DATE7.);\n         IF  KIND>1 THEN DO;    * BIRTHDAY AND ANNIVERSARY            ;\n             TEMP=SUBSTR(EVENT,((LENGTH(EVENT)-1)),2); * LAST 2 CHARS ;\n             TEMP='19'||TEMP;\n             IF  VERIFY(TEMP,'0123456789')=5 THEN\n                 AGE=YEAR-INPUT(TEMP,4.);\n             END;\n         OUTPUT EVENTS;\n         END;\nPROC SORT DATA=EVENTS;\n     BY DATE KIND;\nMACRO MACBOXLN 11%\n\n*---                                                                 ;\n*--- PRE-SET THE PRINT POSITIONS WITHIN THE BOXES.                   ;\n*--- FEASTS START FROM TOP-DOWN. BIRTHDAYS AND ANNIVERSARIES,        ;\n*--- BOTTOM-UP.                                                      ;\n*---                                                                 ;\nDATA EVENT2;\n     SET EVENTS;\n     BY DATE KIND;\n     RETAIN PRT_POS BOTTOM;\n     IF  FIRST.DATE THEN DO;\n         PRT_POS=1;\n         BOTTOM=MACBOXLN-2;\n         END;\n     PRT_POS+1;\n     IF  KIND>1 THEN DO;\n         PRT_POS=BOTTOM;\n         BOTTOM=BOTTOM-1;\n         IF  LAST.KIND THEN BOTTOM=BOTTOM-1;  * SAVE ROOM FOR HEADER ;\n         END;\n     OUTPUT EVENT2;\n\nPROC FORMAT;\n     VALUE FMTMON 1='JANUARY' 2='FEBRUARY' 3='MARCH'\n                  4='APRIL  ' 5='MAY     ' 6='JUNE '\n                  7='JULY   ' 8='AUGUST  ' 9='SEPTEMBER'\n                 10='OCTOBER' 11='NOVEMBER' 12='DECEMBER';\n     VALUE FMTMONN 1='J A N U A R Y' 2='F E B R U A R Y' 3='M A R C H'\n                  4='A P R I L  ' 5='M A Y   ' 6='J U N E '\n                  7='J U L Y   ' 8='A U G U S T' 9='S E P T E M B E R'\n                 10='O C T O B E R' 11='N O V E M B E R'\n                 12='D E C E M B E R';\n     RUN;\n     PAGE;\n*---                                                                 ;\n*--- THE OUTER LOOP IS BY DAYS.  START AT JAN 1, AND LOOP TO DEC 31. ;\n*--- ON THE FIRST DAY OF EACH MONTH, PRINT THE PREVIOUS MONTH,       ;\n*--- SET UP HEADERS.   I RECALCULATE ROW AND COLUMN FOR EACH DAY.    ;\n*--- ROW RECALCULATION IS REDUNDANT, BUT IT SAVES A TEST FOR FIRST   ;\n*--- DAY OF WEEK.                                                    ;\n*---                                                                 ;\n*--- A MORE SAS-ORIENTED WAY OF DOING THIS WOULD HAVE BEEN TO        ;\n*--- GENERATE A DATASET WITH ONE OBSERVATION FOR EACH DAY, AND LET   ;\n*--- THAT DRIVE THE LOOP.  THE EVENTS FILE WOULD THEN HAVE BEEN      ;\n*--- READ USING THE \"UPDATE\" STATEMENT.  I CHOOSE DOING IT MYSELF    ;\n*--- FOR AESTHETIC REASONS.  THUS ONE WILL FIND A SET FOR THE EVENTS ;\n*--- FILE BURIED IN THE INNERMOST LOOP.                              ;\n*---                                                                 ;\n\nDATA _NULL_;\n     FILE PRINT NOPRINT N=PS PAGESIZE=92;\n     FORMAT HEADER $64. WORDS $14.;\n     FORMAT DATE TODAY DATE8.;\n     LINK RTNPARM;                   * FOR EACH DAY OF THE YEAR.     ;\n     TODAY=MDY(1,1,YEAR);            * WE WILL PASS THROUGH THIS     ;\n     RETAIN YEAR; RETAIN HEADER;     * HUGE LOOP.                    ;\n\n DO  WHILE (YEAR(TODAY)=YEAR);\n     THISMON=MONTH(TODAY);\n     DAY_MON=TODAY-MDY(THISMON,1,YEAR)+1;  *      DAY OF MONTH       ;\n\n     IF  DAY_MON=1 THEN LINK RTNDAY1; *HERE'S WHERE WE SET UP A PAGE.;\n\n*---                                                                 ;\n*--- SET UP A BOX.                                                   ;\n*---                                                                 ;\n     COL=1+(18*(WEEKDAY(TODAY)-1));  * THIS IS THE DAY OF THE WEEK   ;\n     ROW=21+(MACBOXLN*INT((TODAY-FRST_SUN)/7)); *AND WEEK OF MONTH   ;\n     L=ROW-1;          C=COL+1;      *  ROOF  THE CURRENT BOX.       ;\n     PUT #L @C '+-----------------+';\n     IF  WEEKDAY(TODAY)=1 THEN PUT #L @C '|';\n     IF  WEEKDAY(TODAY)=7 THEN PUT #L @C +18 '|';\n     L=ROW+MACBOXLN-1; C=COL+1;      *  FLOOR THE CURRENT BOX.       ;\n     PUT #L @C '*-----------------*';\n     C=COL+2; L=ROW;                 * AND JULIAN DATE, PRINTED.     ;\n     JUL_DAY=MOD(JULDATE(TODAY),1000);\n     PUT #L @C DAY_MON 2. +12 JUL_DAY 3.;\n*---                                                                 ;\n*--- FILL IN THE BOX.                                                ;\n*---                                                                 ;\n     DO  I=0 TO MACBOXLN-1;\n         L=ROW+I; C=COL+1;\n         IF  I < MACBOXLN-1 THEN PUT #L @C '|' +17 '|';\n         END;\n\n     DO  WHILE ((DATE <= TODAY) AND NOT END_EVNT);\n         IF  DATE=TODAY  THEN DO;\n             C=COL+2; L=ROW+PRT_POS;\n             IF  KIND > 1 THEN C=COL+4;\n             PUT #L @C WORDS;        * PRINT THE EVENT.              ;\n             IF  (KIND=2 AND (1<=AGE<=21)) OR (KIND=3 AND (1<=AGE))\n                 THEN DO;\n                 C=C+LENGTH(WORDS);\n                 PUT #L @C  '-' AGE;\n                 END;\n             IF  (LAST.KIND AND KIND > 1)    THEN DO;\n                 L=L-1; C=COL+2;\n                 IF  KIND=3 THEN PUT #L @C 'ANNIVERSARY';\n                 IF  KIND=2 THEN PUT #L @C 'BIRTHDAY';\n                 END;\n             END;\n         SET EVENT2 END=END_EVNT;     * HERE WE SUCK IN  THE         ;\n         BY DATE KIND;                *   EVENTS FILE.               ;\n         END;\n\n     TODAY+1;\n     END;\n     PUT _PAGE_; STOP;\n*---                                                                 ;\n*--- OVERPRINT THE TITLE, AND THE CURRENT MONTH. SET UP WEEK-DAY     ;\n*--- HEADINGS.  PRIME THE FIRST SIX DAY BOXES, IN CASE NOBODY        ;\n*--- WANTS THEM.  PRINT THE PREVIOUS MONTH.  DETERMINE THE DATE OF   ;\n*--- THE FIRST BOX IN THIS MONTH (IT WILL BE IN PREVIOUS MONTH).     ;\n*---                                                                 ;\n*---                                                                 ;\nRTNDAY1:\n     IF  THISMON > 1 THEN PUT _PAGE_;\n     FRST_SUN=TODAY-(WEEKDAY(TODAY)-1); * DATE OF 1ST SQUARE.    ;\n     C=66-INT(LENGTH(HEADER)/2);\n     PUT #1 @C  HEADER #2 '+' @C  HEADER #3 @1 '+' @C  HEADER;\n     BITTYMON=(THISMON-1)+12*(THISMON=1);\n     COL=2;                      *   STICK LAST MONTH AND THIS   ;\n     LINK RTNBITTY;              *   AT THE TOP OF THE PAGE.     ;\n     BITTYMON=(THISMON+1)-12*(THISMON=12);\n     COL=86;\n     LINK RTNBITTY;\n     C=66-INT(LENGTH(PUT(THISMON,FMTMONN.))/2); *  OVERPRINT MTH.;\n     PUT #10 @C  THISMON FMTMONN.\n         / @1 '+' @C THISMON FMTMONN.\n         / @1 '+' @C THISMON FMTMONN.;\n     PUT #14 @64 YEAR;\n         PUT #19 @2 '|   S U N D A Y   |   M O N D A Y   |  T U E S D A\nY  |W E D N E S D A Y| T H U R S D A Y |   F R I D A Y   | S A T U R D A\n Y |' /\n                 @2 '|-----------------+-----------------+--------------\n---+-----------------+-----------------+-----------------+--------------\n---|'    /\n         @2 '|' @20 '|' @38 '|' @56 '|' @74 '|' @92 '|' /\n         @2 '|' @20 '|' @38 '|' @56 '|' @74 '|' @92 '|' /\n         @2 '|' @20 '|' @38 '|' @56 '|' @74 '|' @92 '|' /\n         @2 '|' @20 '|' @38 '|' @56 '|' @74 '|' @92 '|' /\n         @2 '|' @20 '|' @38 '|' @56 '|' @74 '|' @92 '|' /\n         @2 '|' @20 '|' @38 '|' @56 '|' @74 '|' @92 '|' /\n         @2 '|' @20 '|' @38 '|' @56 '|' @74 '|' @92 '|' /\n         @2 '|' @20 '|' @38 '|' @56 '|' @74 '|' @92 '|' /\n         @2 '|' @20 '|' @38 '|' @56 '|' @74 '|' @92 '|' /\n         @2 '|' @20 '|' @38 '|' @56 '|' @74 '|' @92 '|' /\n         @2 '|' @20 '|' @38 '|' @56 '|' @74 '|' @92 '|' ;\n     RETURN;\n\n*---                                                                 ;\n*--- PRINT THE NEXT AND PREVIOUS MONTHS IN THE CORNERS OF THE        ;\n*--- CALENDAR.  NOTE THAT THE HICCOUGH IN THE LINE COUNT ALLOWS      ;\n*--- FOR THE OVERPRINT OF THE CURRENT MONTH.                         ;\n*---                                                                 ;\n RTNBITTY:\n     C=COL+21-INT(LENGTH(PUT(BITTYMON,FMTMON.))/2);\n     PUT #4 @C BITTYMON FMTMON. / /\n         @COL '| SUN | MON | TUE | WED | THU | FRI | SAT |' /\n         @COL '|-----+-----+-----+-----+-----+-----+-----|';\n     BIT_YEAR=YEAR+(BITTYMON=1  AND THISMON=12)\n                  -(BITTYMON=12 AND THISMON=1);\n     BIT_DAY=MDY(BITTYMON,1,BIT_YEAR);\n     BIT_SUN=BIT_DAY-(WEEKDAY(BIT_DAY)-1);\n     DO  WHILE (MONTH(BIT_DAY)=BITTYMON);\n         BIT_WKDY=WEEKDAY(BIT_DAY);\n         IF  (BIT_WKDY=1 OR BIT_DAY=MDY(BITTYMON,1,BIT_YEAR)) THEN DO;\n             BIT_ROW=8+INT((BIT_DAY-BIT_SUN)/7);\n             L=BIT_ROW+2*(BIT_ROW>10);\n             PUT #L @COL '|     |     |     |     |     |     |     |';\n             IF   L > 10 THEN PUT #L /\n                    @COL '*-----------------------------------------*';\n             END;\n         BIT_COL=COL+6*(BIT_WKDY-1);\n         C=BIT_COL+1;\n         BIT_DYMO=BIT_DAY-MDY(BITTYMON,1,BIT_YEAR)+1;\n         PUT #L @C BIT_DYMO 3.;\n         BIT_DAY+1;\n         END;\n     RETURN;\n\n*---                                                                   ;\n*--- READ THE TITLE, AND THE YEAR TO BE PRINTED.  THIS IS IN A SUB-    ;\n*--- ROUTINE, BECAUSE IT IS THE FIRST SAS DATASET \"SET'ED\" IN THE      ;\n*--- STEP, BUT IT CAN'T BE THE FIRST PHISICAL SET STATEMENT IN THE     ;\n*--- DECK, 'CAUSE I USE A \"BY\" VARIABLE IN THE OTHER SET STATEMENT.    ;\n*---                                                                   ;\nRTNPARM:\n     SET PARMS;\n     RETURN;\n\n*    FILE LOG;                              ******DEBUG;\n*    PUT  KIND= TODAY= WORDS= DATE= LAST.KIND= PRT_POS= BOTTOM=;\n*    FILE PRINT NOPRINT N=PS PAGESIZE=92;   ******DEBUG;\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CALENJCL": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00o\\x00o\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 111, "newlines": 111, "modlines": 0, "user": "FILE369"}, "text": "//PSYRRSC JOB (1,1M2),DICK,MSGCLASS=T,NOTIFY=PSYRRS\n//*        (CALENDAR)\n//FCB8     OUTPUT DEFAULT=YES,JESDS=YES,FCB=8  <== NOTE: 8 LPI\n//DIOT    EXEC SAS,OPTIONS='NOSOURCE'\n//SYSIN    DD DSN=PSYRRS.SHARE.ASM(CALENDAR),DISP=SHR\n//EVENTS   DD *\n*    * ==> COMMENT CARD\n*    0 ==> HEADER CARD, WITH YEAR AND TITLE\n*    1 ==> FEAST DAY. NOTE THAT ONE EMBEDDED BLANK IS ALLOWED\n*    2 ==> BIRTHDAY. AGE WILL PRINT IF UNDER 21.\n*    3 ==> ANNIVERSARY.  NUMBER WILL PRINT IF PRESENT.\n0 1986 JOAN'S PRIVATE CALENDAR\n*--- FIXED FEASTS\n1 01JAN                 NEW YEARS DAY\n2 12FEB                 LINCOLN'S\n1 14FEB                 ST VALENTINE'S\n2 22FEB                 REAL GEO WASH\n1 14JUN                 FLAG DAY\n1 17MAR                 ST. PATRICK'S\n1 01APR                 APRIL FOOL'S\n1 15MAY                 ARMED FORCES\n1 14JUN                 FLAG DAY\n1 04JUL                 INDEPENDENCE\n1 04JUL                     DAY\n1 14JUL                 BASTILLE DAY\n1 24OCT                 U.N. DAY\n1 31OCT                 HALLOWEEN\n1 11NOV                 VETERAN'S DAY\n1 24DEC                 CHRISTMAS EVE\n1 25DEC                 CHRISTMAS DAY\n1 31DEC                 NEW YEARS EVE\n*--- MOVABLE FEASTS\n*  1986   1987\n2 20JAN                          M.L.KING\n1 12FEB                          ASH WEDNESDAY\n2 17FEB                          OBSRVD WASH'S\n*                                PURIM\n1 23MAR                          PALM SUNDAY\n1 28MAR                          GOOD FRIDAY\n1 30MAR                          EASTER SUNDAY\n*                                BEGIN DAYLIGHT\n1 24APR                          PASSOVER\n1 11MAY                          MOTHER'S DAY\n1 26MAY                          MEMORIAL DAY\n1 15JUN                          FATHER'S DAY\n1 01SEP                          LABOR DAY\n1 04OCT                          ROSH HOSHANNA\n1 13OCT                          COLUMBUS DAY\n1 13OCT                          YOM KIPPUR\n*                                SUCCOS\n*                                END DAYLT SAVE\n1 04NOV                          ELECTION DAY\n1 27NOV                          THANKSGIVING\n1 27NOV                               DAY\n1 27DEC                          CHANUKAH\n*--- MOVABLE FEASTS\n**--- MOVABLE FEASTS  FOR NEXT YEAR >\n** 1987 1988\n*2 19JAN 18JAN                   M.L.KING\n*1 04MAR 17FEB                   ASH WEDNESDAY\n*2 16FEB 15FEB                   OBSRVD WASH'S\n**                               PURIM\n*1 12APR 27MAR                   PALM SUNDAY\n*1 17APR 01APR                   GOOD FRIDAY\n*1 19APR 03APR                   EASTER SUNDAY\n**                               BEGIN DAYLIGHT\n*1 14APR 02APR                   PASSOVER\n*1 10MAY 08MAY                   MOTHER'S DAY\n*1 25MAY 30MAY                   MEMORIAL DAY\n*1 21JUN 19JUN                   FATHER'S DAY\n*1 07SEP 05SEP                   LABOR DAY\n*1 24SEP 12SEP                   ROSH HOSHANNA\n*1 03OCT 21SEP                   YOM KIPPUR\n*1 12OCT 12OCT                   COLUMBUS DAY\n**                               SUCCOS\n**                               END DAYLT SAVE\n*1 03NOV 08NOV                   ELECTION DAY\n*1 26NOV 24NOV                   THANKSGIVING\n*1 26NOV 24NOV                        DAY\n*1 16DEC 04DEC                   CHANUKAH\n*--- CATHOLIC STUFF\n* 10JUN                 PENTECOST\n* 31MAY                 ASENSION\n* 06JUN                 TRINITY SUNDAY\n1 15AUG                 ASSUMPTION\n1 01NOV                 ALL SAINTS DAY\n1 08DEC                 IMMACULATE\n1 08DEC                 CONCEPTION\n*--- MISCELLANEOUS STUFF\n1 26APR                 MULLICA\n1 27APR                 MULLICA\n1 28APR                 MULLICA\n*--- FAMILY DATES\n2 14NOV                 GRANNY\n2 02JAN                 JACKIE H\n2 13SEP                 DICK S\n2 09JUN                 JOAN S\n2 06JAN71               MIKE S\n2 19DEC72               TOM S\n2 18APR                 JERRY O'C\n3 17MAY69               DICK & JOAN\n3 01JAN84               GEO & NANCY\n2 06APR55               JEAN L\n2 24DEC78               ERIN L\n2 29MAY83               JIMMY L\n3 06JUL74               JEAN & KEN\n2 11APR                 HELENA F\n2 25JUL72               ALEX F\n2 01AUG78               ELAINE F\n2 08DEC84               JIMMY S\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CLIB": {"ttr": 1542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x01\\xd1\\x01\\xd1\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 465, "newlines": 465, "modlines": 0, "user": "FILE369"}, "text": "         TITLE 'CLIB --- CONCATENATE DATASET FIRST TO DDNAME'\n*-------\n*------- PURPOSE: PROVIDE TSO USER QUICK ACCESS TO PRIVATE CLIST\n*-------\n*------- AUTHOR:  DICK SZIEDE  PRC. 1987.\n*-------\n*------- METHOD:  USE SVC 99 TO DETERMINE THE DSNAMES OF ALL DATASETS\n*-------          CONCATENATED TO  A PARTICULAR DDNAME.\n*-------          REALLOCATE THE  ARGUMENT DSNAME IN FRONT OF ALL THE\n*-------          OTHERS.\n*-------\n*-------\n*-------\n*------- OPTIONS: CLIB MYLIB.CLIST DD(SYSPROC)\n*-------\n*-------\n*------- DETAIL:  CLIB TAKES AN ARGUMENT OF DSNAME, AND OPTIONAL\n*-------          DDNAME, (DEFAULTS TO SYSPROC), AND MAKES A\n*-------          CONCATENATION.\n*-------\n*-------          POSSIBLE RETURN CODES ARE:\n*-------\n*-------             0 ===> DATASET ALLOCATED\n*-------             4 ===> DATASET NOT IN CATALOG\n*-------             8 ===> PARSE ERROR - UNABLE TO MAKE SENSE OF\n*-------                    COMMAND PARMS.\n*-------          IF CLIB DETECTS AN ERROR IN DYNAMIC ALLOCATION\n*-------          IT WILL ABEND WITH A COMPLETION CODE OF S0C3.\n*-------\n*-------\n*------- ATTRIBUTES:  SERIALLY REUSABLE, NOT REENTRANT, NOT AUTHORIZED\n*-------\n*-------          NOTE THAT REENTRANCY CAN BE ACHIEVED BY MOVING THE\n*-------          NON-REENTRANT DATA AREAS, FROM \"RBPTR\" ON\n*-------          INTO THE GETMAIN'ED WKA.  THESE AREAS CONTAIN THE\n*-------          DYNAMAC ALLOCATION REQUEST BLOCK, AND TEXT UNITS.\n*-------          WHILE THE UPL'S ARE NOT VOLITILE, ONE CANNOT HAVE\n*-------          AN ADCON FOR A GETMAIN'ED AREA, SO THEY TOO MUST\n*-------          GO TO WKA.\n*-------\n*-------          I CAN'T IMAGINE ANYONE ACTUALLY DOING THIS, BUT\n*-------          JUST IN CASE, I'VE USED THE MAPPING MACROS INSTEAD\n*-------          OF MY OWN LABELS.\n*-------\n*------- BACKGROUND:  THE NOTION  FOR THIS COMMAND COMES FROM THE\n*-------       CLIST \"CLIB\" BY KERMIT KISER & JEFF SPREHN OF WASH.\n*-------       STATE (FILE 270 ON CBT).   THEIR CODE WAS TOO\n*-------       INSTALLATION-DEPENDENT FOR MY TASTE, SO I WROTE MY OWN.\n*-------\n*-------)F FUNCTION -\n*-------   THE CLIB COMMAND IS USED TO CONCATENATE A PRIVATE\n*-------   LIBRARY AHEAD OF THE LIBRARIES ALREADY ALLOCATED\n*-------   TO A SPECIFIC DDNAME.\n*-------\n*-------)X SYNTAX -\n*-------     CLIB     ('DSNAME') DDNAME('DDNAME')\n*-------\n*-------     REQUIRED -- 'DSNAME'\n*-------     DEFAULTS -- DDNAME(SYSPROC)\n*-------)O OPERANDS -\n*-------))'DSNAME'  - 'DATA SET NAME' IS THE NAMES OF DATA SET TO BE\n*-------            CONCATENATED TO THE DDNAME.\n*-------))DDNAME('DDNAME') - DDNAME TO WHICH 'DSNAME' IS TO BE\n*-------            CONCATENATED.  DEFAULT IS 'SYSPROC'.\n*-------\n*------- CHANGE:  NO ACTIVITY.\n*-------\n*-------\n*-------\n         EJECT\nCLIB     PRIME ID=DICK_SZIEDE_PRC_1987,LV=4096\n         REGS\n         USING WKA,R13\n*-------\n*------- PARSE THE COMMAND BUFFER AND SAVE DSNAME AND (OPTIONAL)\n*------- DDNAME IN TEXT UNITS FOR LATER ALLOCATION.  DDNAME\n*------- DEFAULTS TO \"SYSPROC\".\n*-------\n         LR    R10,R1\n         ST    R10,DFCPPLP        SAVE CPPL FOR DAIRFAIL\n         USING CPPL,R10               CPPL ADDR WAS SAVED IN R10\n         MVC   IOPLUPT(4),CPPLUPT      PREPARE IOPL\n         MVC   IOPLECT(4),CPPLECT\n         LA    R2,ECB\n         ST    R2,IOPLECB\n         USING PPL,R8\nPARSINPT LA    R8,PPLAREA                MAKE PPL ADDRESSABLE\n         ST    R2,PPLECB\n         MVC   PPLUPT,CPPLUPT          SET UP IKJPARSE PARMS\n         MVC   PPLECT,CPPLECT\n         MVC   PPLCBUF,CPPLCBUF\n         MVC   PPLPCL(4),=A(PARMDSN)\n         LA    R9,ANS\n         ST    R9,PPLANS\n*-------\n         CALLTSSR EP=IKJPARS,MF=(E,PPL)  PARSE  THE INPUT BUFFER\n         LTR   R15,R15            CHECK RETURN CODE IMMEDIATELY\n         BNZ   PARSERR\n         ICM   R10,B'1111',PPLANS      TOP OF PDL CHAIN\n         BNP   PARSERR                 PARSE OF BUFFER UNSUCESSFUL\n         L     R10,0(R10)              PDL HEADER\n         DROP  R8\n         DROP  R10                WE NO LONGER NEED THE CPPL\n*-------\n         USING PARANSWR,R10\n         MVC   WKADDNL(10),REFRDDN  PRIME DDNAME WITH BLANKS\n         TM    PARDSN+6,X'80'     IS DSNAME PRESENT\n         BNO   PARSERR            QUIT IF NOT\n         LM    R2,R3,PARDSN       GET DSNAME POINTER & LENGTH\n         SRL   R3,16              STICK DSNAME IN TEXT UNIT\n         STH   R3,WKADSNL\n         BCTR  R3,0\n         EX    R3,DSNMOVE\n         TM    PARPND+6,X'80'     IS DDNAME PRESENT\n         BNO   SYSPORK            DEFAULT IF NOT\n         LM    R2,R3,PARPND       GET DDNAME POINTER & LENGTH\n         SRL   R3,16              STICK DDNAME IN TEXT UNIT\n*------- STH   R3,WKADDNL         *****NOTE**** ALWAYS USE 8 FOR\n         BCTR  R3,0               DDNAME LENGTH, EVEN IF IT'S A LIE\n         EX    R3,DDNMOVE\n         B     SEARCH\nSYSPORK  MVC   WKADDNAM,=C'SYSPROC ' SET DEFAULT OF SYSPROC\n         B     SEARCH\nDSNMOVE  MVC   WKADSNAM(0),0(R2)\nDDNMOVE  MVC   WKADDNAM(0),0(R2)\n         DROP  R10\n*-------\n*------- SAVE THE DSNAMES ATTACHED TO DDNAME, SO'S WE CAN REALLOCATE\n*-------       THEM LATER.\n*-------\nSEARCH   LA    R10,1               FIRST RELATIVE ENTRY\n         SLR   R9,R9               INITIAL HIT COUNT\n         MVI   RB1+(S99VERB-S99RB),S99VRBIN -- INFO REQUEST VERB\n         MVC   RB1+(S99TXTPP-S99RB)(4),=A(SRCHUPL)\n*-------\nSRCHLOOP STH   R10,TXT15+(S99TUPAR-S99TUNIT) RELATIVE ENTRY IN TEXT\n         LA    R10,1(R10)          INCREMENT FOR NEXT REQUEST\n         MVC   TXT5+(S99TULNG-S99TUNIT)(46),REFRDSN\n         MVC   TXT4+(S99TULNG-S99TUNIT)(10),REFRDDN\n         LA    R1,RBPTR\n         DYNALLOC\nSRCHED   LTR   R15,R15            AN INFO REQUEST SHOULDN'T FAIL\n         BZ    SRCHCK\n         BAL   R3,DARFL\n         BAL   R3,DAMNIT\nSRCHCK   LTR   R9,R9               HAVE WE ALREADY FOUND HITS?\n         BZ    SRCHDDNM            NO  ===> LOOK FOR DDNAME\n         CLC   =CL8' ',TXT4+(S99TUPAR-S99TUNIT) IZZIT A CONCATENATED\n         BNE   SRCHDONE                             DATASET?\n         B     SRCHHIT\nSRCHDDNM CLC   WKADDNAM,TXT4+(S99TUPAR-S99TUNIT) DOES IT MATCH DDNAME\n         BNE   SRCHLAST\nSRCHHIT  LA    R8,WKADSNS(R9)      ADDR OF NEXT DSN SAVE AREA\n         MVC   0(46,R8),TXT5+(S99TULNG-S99TUNIT) MOVE IN DSN\n         LA    R9,46(R9)           AND INCREMENT HIT COUNT\n*\nSRCHLAST CLI   TXT13+(S99TUPAR-S99TUNIT),X'80' CHECK FOR LAST NTRY\n         BE    SRCHDONE\n         B     SRCHLOOP\n*-------\n*------- THE FIRST NONBLANK DDNAME AFTER A DDNAME MATCH, OR THE\n*-------       LAST ALLOCATED DDNAME BRINGS US HERE FOR EVALUATION.\n*-------\nSRCHDONE ST    R9,WKAHITS\n         LTR   R9,R9               ANY HITS?\n         BZ    ALLOCIT             N0  ===> SKIP THE FREE\n*-------\n*------- WE CAN ADD THE 16TH LIBRARY TO A CONCATENATION, BUT THAT'S\n*-------       ALL.  IF HITS > 15 ==> QUIT WITH NO ACTION.\n*-------\n         C     R9,=A(16*46)       MORE THAN 15 HITS?\n         BL    PREALLOC\n         BAL   R3,TOOMANY\n         B     RET8\n*-------\n*------- PRE-ALLOCATE THE NEW LIBRARY, SO WE DON'T FREE THE\n*-------       CONCATENATION, THEN FIND THE NEW KID DOESN'T EXIST.\n*-------\nPREALLOC MVC   V1TXT2+(S99TULNG-S99TUNIT)(46),WKADSNL\n         MVC   V1TXT85+(S99TULNG-S99TUNIT)(10),REFRDDN\n         MVI   RB1+(S99VERB-S99RB),S99VRBAL ALLOCATE\n         MVC   RB1+(S99TXTPP-S99RB)(4),=A(ALOC2UPL)\n         LA    R1,RBPTR\n         DYNALLOC\n         LTR   R15,R15\n         BZ    FREEIT\n         BAL   R3,DARFL\n         B     RET4\n*-------\n*------- FREE  THE CONCATENATED DATASETS.\n*-------\nFREEIT   MVI   RB1+(S99VERB-S99RB),S99VRBUN -- FREE REQUEST\n         MVC   RB1+(S99TXTPP-S99RB)(4),=A(FREEUPL)\n         MVC   TXT1+(S99TULNG-S99TUNIT)(10),WKADDNL DDNAME & LENGTH\n         LA    R1,RBPTR\n         DYNALLOC\nFREESTOP LTR   R4,R15             HOW BAD WAS THE ERROR?\n         BZ    ALLOCIT\n         BAL   R3,DARFL           PRINT DAIR ERROR MESSAGE\n         CH    R4,=H'4'\n         BE    RET4\n         B     DAMNIT\n*-------\n*------- NOW   WE CAN FINNALLY ALLOCATE DATSET TO DDNAME.  WE WAIT\n*-------       TILL NOW SO THAT IF THE CONCATENATION DIDN'T EXIST,\n*-------       THIS COMMAND IS EQUIVALENT TO:\n*-------       \"ALLOC DSNAME DD(SYSPROC) SHR REUSE\"\n*-------\nALLOCIT  MVI   RB1+(S99VERB-S99RB),S99VRBAL -- ALLOCATE REQUEST\n         MVC   RB1+(S99TXTPP-S99RB)(4),=A(ALOCUPL)\n         MVC   V1TXT1+(S99TULNG-S99TUNIT)(10),WKADDNL DDNAME & LENGTH\n         MVC   V1TXT2+(S99TULNG-S99TUNIT)(46),WKADSNL DSNAME & LENGTH\n         LA    R1,RBPTR\n         DYNALLOC\n         B     *+4(R15)\n         B     COPYCON            GOOD RETURN\n         BAL   R3,DARFL           DATASET NOT FOUND\n         BAL   R3,DARFL           DYNAMIC ALLOCATION ERROR\n         BAL   R3,DAMNIT          SHOULD NOT HAPPEN\n         BAL   R3,DAMNIT          INSURANCE\n*-------\n*------- HERE  WE COPY THE CONCATENATION.\n*------- NOW   ALLOCATE EACH DSN SEPARATELY, THEN CONCATENATE BY DDN\n*-------\nCOPYCON  SLR   R8,R8               GET COUNT OF DATASETS IN REG 9\n         L     R9,WKAHITS\n         LTR   R9,R9              IF NO HITS, WE DON'T NEED TO DO THIS\n         BZ    RETZERO\n         D     R8,=F'46'\n         LA    R9,1(R9)           CONCATENATE COUNT IS HITS+1\n         STH   R9,V3TXT1+(S99TUNUM-S99TUNIT) COUNT FOR CONCATENATE\n         LA    R9,WKADSNS          SET UP TO LOOP THROUGH CONCATENATED\n         L     R11,WKAHITS         DATSETS.\n         LA    R10,46\n         SR    R11,R10\n         LA    R11,0(R9,R11)\n         LA    R8,V3TXT1+(S99TULNG-S99TUNIT) DDNAME FEEDBACK GOES\n*-------                                     INTO CONCAT TEXT UNIT\nCAT1LOOP MVC   V1TXT2+(S99TULNG-S99TUNIT)(46),0(R9) GET DAT DSN\n         MVC   V1TXT85+(S99TULNG-S99TUNIT)(10),REFRDDN\n         MVI   RB1+(S99VERB-S99RB),S99VRBAL ALLOCATE\n         MVC   RB1+(S99TXTPP-S99RB)(4),=A(ALOC2UPL)\n         LA    R1,RBPTR\n         DYNALLOC\nCATLPED  B     *+4(R15)\n         B     CATLPBMP            TO NEXT DATASET\n         B     FREEIT              RETRY FOR @0000001 --- NOTE THAT\n         BAL   R3,DARFL                THIS WILL CAUSE A  LOOP IF\n         B     DAMNIT                  @0000001 IS NOT THE DDNAME\n*-------                               THAT IS UNAVAILABLE.\nCATLPBMP LA    R8,10(R8)           AND BUMP DDNAME POINTER\n         MVC   0(10,R8),V1TXT85+(S99TULNG-S99TUNIT) DDN FEEBACK\n         BXLE  R9,R10,CAT1LOOP\n*-------\n*------- NOW   CONCATENATE ALL THE  DDNAMES TOGETHER\n*-------\n*-------\n         MVC   V3TXT1+(S99TULNG-S99TUNIT)(10),WKADDNL DDNAME & LENGTH\n         MVI   RB1+(S99VERB-S99RB),S99VRBCC   CONCATENATION VERB\n         MVC   RB1+(S99TXTPP-S99RB)(4),=A(CONCUPL)\n         LA    R1,RBPTR\n         DYNALLOC\n         LTR   R15,R15\n         BZ    RETZERO\n         BAL   R3,DARFL\n         B     DAMNIT\n*-------\n*------- EXITS\n*-------\nRET8     LA    R15,8               PARSE ERROR\n         B     QUIT\nRET4     LA    R15,4               DATASET NOT FOUND\n         B     QUIT\nRETZERO  SLR   R15,R15\nQUIT     TERME RC=(15)\n         EJECT\n*-------\n*-------     * ERROR ROUTINES *\n*-------\nDAMNIT   EX    0,*                 UNEXPECTED ERROR.\n*-------\nPARSERR  PUTLINE PARM=PUTBLOK,OUTPUT=(PAROLD1,TERM,MULTLVL,INFOR),     X\n               MF=(E,IOPL)\n         B     RET8\n*-------\nTOOMANY  PUTLINE PARM=PUTBLOK,OUTPUT=(PAROLD3,TERM,MULTLVL,INFOR),     X\n               MF=(E,IOPL)\n         BR    R3\n*-------\n*------- DAIR  FAIL\n*-------\nDARFL    ST    R15,MYRCP          SVC 99 RETURN CODE\n         LA    R15,MYRCP\n         ST    R15,DFRCP\n         SLR   R15,R15            ADDR OF IKJEFF02\n         ST    R15,MYJEFF02\n         LA    R15,MYJEFF02\n         ST    R15,DFJEFF02\n*-------\n         MVC   MYRFLSWT,=X'0032'  JUST WRITE MESSAGE - NO RETURN\n         LA    R15,MYRFLSWT       SWITCHES\n         ST    R15,DFIDP\n         LA    R15,DFBUFS\n         ST    R15,DFBUFP         DBUFS BUFFER\n         LA    R15,RB1\n         ST    R15,DFDAPLP\n         LA    R1,DFDAPLP\n         LINK  EP=IKJEFF18\n         LTR   R15,R15\n         BNZ   DAMNIT\n         BR    R3\n*-------\n*-------       CONSTANT DATA AREAS\n*-------\n*-------       STRAY CONSTANTS\n*-------\nREFRDSN  DC    H'44',CL44' '       REFRESH   DSNAME\nREFRDDN  DC    H'8',CL8' '         REFRESH   DDNAME\nSRCLEVEL DC    C' '\n         LTORG\n*-------\n*-------       PUTLINE STUFF\n*-------\nPUTBLOK  PUTLINE MF=L\n*-------\nPAROLD1  DC    A(PAROLD2),A(1),A(PARMSG1)\nPAROLD2  DC    A(0),A(1),A(PARMSG2)\nPARMSG1  DC    AL2(PARM1END-PARMSG1),AL2(0)\n         DC    C'CLIB0001 THE PROGRAM REGRETS TO INFORM YOU '\n         DC    C'IT IS UNABLE TO MAKE SENSE OF YOUR INPUT.'\nPARM1END EQU   *\nPARMSG2  DC    AL2(PARM2END-PARMSG2),AL2(0)\n         DC    C' LORDY!  DO YOU  TYPE WITH YOUR ELBOWS?'\nPARM2END EQU   *\n*-------\nPAROLD3  DC    A(PAROLD4),A(1),A(PARMSG3)\nPAROLD4  DC    A(0),A(1),A(PARMSG4)\nPARMSG3  DC    AL2(PARM3END-PARMSG3),AL2(0)\n         DC    C'CLIB0002 THE PROGRAM REGRETS TO INFORM YOU '\n         DC    C'THERE IS A LIMIT OF 16 FOR A PDS CONCATENATION'\nPARM3END EQU   *\nPARMSG4  DC    AL2(PARM4END-PARMSG4),AL2(0)\n         DC    C' RETURN CODE = 8 '\nPARM4END EQU   *\n*-------\n*-------       TEXT UNIT POINTERS\n*-------\nALOCUPL  DC    A(V1TXT1)           DDNAME\n         DC    A(V1TXT2)           DSNAME\n         DC    A(V1TXT4)           SHR\n         DC    A(V1TXT5)           KEEP\n         DC    A(V1TXT6)           KEEP\n         DC    AL1(128),AL3(V1TXT33) ,,,IN\nALOC2UPL DC    A(V1TXT2)           DSNAME\n         DC    A(V1TXT4)           SHR\n         DC    A(V1TXT5)           KEEP\n         DC    A(V1TXT6)           KEEP\n         DC    AL1(128),AL3(V1TXT85) RETURN DDNAME\nCONCUPL  DC    A(V3TXT1)             LIST OF DDNAMES\n         DC    AL1(128),AL3(V3TXT4)  PERMANANTLY ALLOCATED\nSRCHUPL  DC    A(TXT4)\n         DC    A(TXT5)\n         DC    A(TXT13)\n         DC    AL1(128),AL3(TXT15)\nFREEUPL  DC    A(TXT1)                      DDNAME\n         DC    AL1(128),AL3(TXT7)\n*-------\n*------- NON   REENTRANT DATA AREAS\n*-------\n         DS    0F\nRBPTR    DC    AL1(128),AL3(RB1)\n*-------       DYNAMIC ALLOCATION  REQUEST BLOCK\nRB1      DC    AL1(20)\nRBVERB   DC    AL1(7)              INFO REQUEST\nRBFLAG1  DC    B'00100000',AL1(0)\n         DC    A(0)\nRBTEXTP  DC    A(SRCHUPL)\n         DC    A(0)\n         DC    A(0)\n*-------       ALLOCATE TEXT UNITS\nV1TXT1   DC    H'1',H'1',H'8',CL8' '        DDNAME\nV1TXT2   DC    H'2',H'1',H'44',CL44' '      DATA SET NAME\nV1TXT3   DC    H'3',H'1',H'8',CL8' '        MEMBER NAME\nV1TXT4   DC    H'4',H'1',H'1',X'08'         SHR\nV1TXT5   DC    H'5',H'1',H'1',X'08'         KEEP\nV1TXT6   DC    H'6',H'1',H'1',X'08'         KEEP\nV1TXT33  DC    H'33',H'1',H'1',X'80'        ,,,IN\nV1TXT85  DC    H'85',H'1',H'8',CL8' '       RETURN DDNAME\n*-------       CONCATENATE TEXT UNITS\nV3TXT1   DC    H'1',H'2'                    DDNAMES\n         DC    H'8',CL8'@0000001',H'8',CL8'@0000002'\n         DC    H'8',CL8'@0000003',H'8',CL8'@0000004'\n         DC    H'8',CL8'@0000005',H'8',CL8'@0000006'\n         DC    H'8',CL8'@0000007',H'8',CL8'@0000008'\n         DC    H'8',CL8'@0000009',H'8',CL8'@0000010'\n         DC    H'8',CL8'@0000011',H'8',CL8'@0000012'\n         DC    H'8',CL8'@0000013',H'8',CL8'@0000014'\n         DC    H'8',CL8'@0000015',H'8',CL8'@0000016'\nV3TXT4   DC    H'4',H'0'                    PERMANANTLY CONCATENATED\n*-------       GENERAL     TEXT UNITS\nTXT1     DC    H'1',H'1',H'8',CL8' '        DDNAME\nTXT4     DC    H'4',H'1',H'8',CL8' '        RETURN DDNAME\nTXT5     DC    H'5',H'1',H'44',CL44' '      RETURN DSNAME\nTXT7     DC    H'7',H'0'                    UNALLOCATE DAMNIT\nTXT13    DC    H'13',H'1',H'1',H'0'         RETURN LAST ENTRY\nTXT15    DC    H'15',H'1',H'2',H'0'         SPECIFY RELATIVE REQUEST\n         EJECT\n*\n         PUSH  PRINT\n         PRINT ON,NOGEN\nPARMDSN  IKJPARM  DSECT=PARANSWR\nPARDSN   IKJPOSIT DSNAME,USID,PROMPT='DSNAME TO BE CONCATENATED'\nPARPNT   IKJKEYWD\n         IKJNAME  'FILE',SUBFLD=PARPN\n         IKJNAME  'DD',SUBFLD=PARPN\n         IKJNAME  'F',SUBFLD=PARPN\nPARPN    IKJSUBF\nPARPND   IKJPOSIT DSNAME,DDNAM,PROMPT='DDNAME OTHER THAN SYSPROC'\n         IKJENDP\n         POP   PRINT\n*-------\n*-------       REENTRANT DATA AREAS.  MY SETUP AND END MACROS PROVIDE\n*-------       A REENTRANT WORK AREA,  BASED ON REG 13.\n*-------\nWKA      DSECT\nWKASAVE  DS    18F\nWKADDNL  DS    H                  THIS IS THE LENGTH AND DDNAME\nWKADDNAM DS    CL8                TO WHICH WE'RE GONNA CONCATENATE\nWKADSNL  DS    H                  THIS IS THE LENGTH AND DSNAME\nWKADSNAM DS    CL44               WHICH WE'RE GONNA ADD\nWKADBL   DS    D\nWKAHITS  DS    F                   NUMBER OF CONCATENATED DSN'S  * 46\nWKADSNS  DS    16CL46              SAVE CONCATENATED DSNAMES\n         SPACE\n*-------\nECB      DS    F\nANS      DS    F\nPPLAREA  DS    7F\n*-------\nIOPL     DS    0F\nIOPLUPT  DS    F\nIOPLECT  DS    F\nIOPLECB  DS    F\nIOPLIOPB DS    F\n*-------\nMYRCP    DS    F\nMYJEFF02 DS    F\nMYRFLSWT DS    H\n         PUSH  PRINT\n         PRINT ON,NOGEN\n         IKJEFFDF ,               DAIRFAIL PARAMETERS\nWKLENGTH EQU   *-WKA\n         DROP  R13\n         EJECT\n*-------\n*-------                     * * *  DSECTS  * * *\n*-------\n         IKJPPL\n         IEFZB4D0\n         IEFZB4D2\n         CVT   DSECT=YES\n         POP   PRINT\n         SPACE\n         IKJCPPL\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMMAND": {"ttr": 1794, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\xc4\\x00\\xc4\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 196, "newlines": 196, "modlines": 0, "user": "FILE369"}, "text": "         TITLE 'COMMAND - ISSUE SVC34 FOR PROBLEM PROGRAM'\n         MACRO\n&NAME    SETUP &BASE2=\n&NAME    CSECT ,                            BEGIN CSECT\n         USING &NAME,R15                    TEMP. ADDRESS.\n         B     S&SYSNDX\n         DC    17XL4'FFFFFFFF'              SAVEAREA\n         DC    CL8'&NAME'                  'EYE CATCHER'\n         DC    CL8'&SYSDATE',CL6'&SYSTIME'  AUDIT TRAIL\n         AIF   ('&BASE2' EQ '').HNDBAS0\nB&SYSNDX DC    A(&NAME+X'1000')\n.HNDBAS0 ANOP\nS&SYSNDX DS    0H                           FOR COMPUTATION\n         STM   R14,R12,12(R13)              STORE HIS REGS.\n         LR    R2,R13                       SAVE ADDRESS OF SA.\n         LR    R13,R15                      SET UP NORMAL BASE\n         AIF   ('&BASE2' NE '').HNDBAS1\n         USING &NAME,R13                    NORMAL ADDRESS.\n         AGO   .HNDBAS2\n.HNDBAS1 ANOP\n         USING &NAME,R13,&BASE2             OBTAIN ADDRESSIBILITY\n         L     &BASE2,B&SYSNDX              LOAD SECOND BASE\n.HNDBAS2 ANOP\n         XR    R15,R15\n         DROP  R15                          DON'T NEED THIS\n         ST    R2,4(R13)                    BACKWARD POINTER\n         ST    R13,8(R2)                    FORWARD POINTER\n         MEND\n***********************************************************************\n*                                                                     *\n*        PROG  - COMMAND                                              *\n*        USE   - ALLOW COMMANDS TO BE ISSUED BY PROGRAM CONTROL       *\n*                EITHER THROUGH THE PARM FIELD OR BY A CALL FROM      *\n*                ANOTHER PROGRAM.                                     *\n*        DATE  - 6/16/82                                              *\n*                                                                     *\n*                                                                     *\n*        REGS                                                         *\n*        R1  - PARM REG                                               *\n*        R2  - PTR TO FULLWORD AUTHORIZATION CODE OR ZERO             *\n*        R3  - PTR TO COMMAND LIST (HALFWORD LENGTH, THEN COMMAND)    *\n*        R4  - WORK REG                                               *\n*        R5  - WORK REG                                               *\n*        R6  -                                                        *\n*        R7  -                                                        *\n*        R8  -                                                        *\n*        R9  -                                                        *\n*        R10 -                                                        *\n*        R11 - BAL REGISTER                                           *\n*        R12 -                                                        *\n*                                                                     *\n*        ATTRIBUTES                                                   *\n*        - AUTHORIZED, SUPERVISOR STATE (FOR SVC 34)                  *\n*                                                                     *\n*        METHOD-OF-OPERATION                                          *\n*        1. PARM FIELD IS PROCESSED :                                 *\n*           IF ONE ADDRESS IN LIST, PROGRAM IS MAIN PROGRAM AND       *\n*           COMMAND EXISTS IN PARM FIELD PASSED BY MVS.               *\n*                                                                     *\n*           IF TWO ADDRESSES IN LIST, PROGRAM IS SUBPROGRAM AND :     *\n*           PARM 1 -> FULLWORD AUTHORIZATION FIELD                    *\n*           PARM 2 -> COMMAND LIST FORMATTED AS IN MVS PARM FIELD     *\n*                                                                     *\n*        5. IF ISSUE -> SVC 34                                        *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         EJECT\nCOMMAND  SETUP\n         EJECT\n***********************************************************************\n*                                                                     *\n*        MAIN CALL ROUTINES                                           *\n*                                                                     *\n*                                                                     *\n***********************************************************************\nMAIN0    DS    0H\n         BAL   R11,IPARM0              PROCESS THE PARM\nMAIN1    DS    0H\n         BAL   R11,CMD0                ISSUE COMMAND\n         B     RETURN                  AND GET OUT\n         EJECT\n***********************************************************************\n*                                                                     *\n*        PROCESS THE PARM -                                           *\n*                                                                     *\n*         IF ONE FIELD, PARM FIELD FROM EXECUTE CARD                  *\n*         IF TWO FIELDS, CALLED FROM HIGHER LEVEL ROUTINE             *\n*                                                                     *\n*                                                                     *\n***********************************************************************\nIPARM0   DS    0H\n         XR    R2,R2                           AND CLEAR R2\n         L     R3,0(,R1)               LOAD FIRST ADDRESS\n         LTR   R3,R3                   IS IT THE ONLY ONE?\n         BM    IPARM1                     NO, CONTINUE\n         L     R2,4(,R1)              LOAD THE SECOND ADDRESS\n         L     R2,0(,R2)              LOAD THE SECOND PARAMETER\nIPARM1   DS    0H\n         LH    R4,0(,R3)              LOAD LENGTH OF COMMAND\n         CH    R4,=H'79'             CHECK LENGTH LIMIT             ptw\n         BNH   IPARM2                    GOOD, CONTINUE\n         LH    R4,=H'79'                BAD, FORCED SET TO LIMIT    ptw\nIPARM2   DS    0H\n         MVI   COMAND,C' '                                          ptw\n         MVC   COMAND(L'COMAND-1),COMAND+1                          ptw\n         LA    R5,4(,R4)              GET LENGTH OF COMMAND + 4\n         STH   R5,COMLEN              SAVE ACTUAL LENGTH\n         BCTR  R4,0                   BUMP DOWN BY ONE FOR HARDWARE\nEXECUTED MVC   COMAND(0),2(R3)        EXECUTED INSTRUCTION\n         EX    R4,EXECUTED            MOVE COMMAND INTO AREA\n         MVC   WTO,XWTO                                             ptw\n         EXTRACT PSCBADDR,'S',FIELDS=PSB                            ptw\n         L     R1,PSCBADDR                                          ptw\n         LTR   R1,R1                                                ptw\n         BZ    *+10                                                 ptw\n         MVC   WTOUSER,PSCBUSER-PSCB(R1)                            ptw\n         EX    R4,WTOMOVE             MOVE COMMAND INTO WTO AREA    ptw\n         BR    R11                    AND RETURN\n         EJECT\n***********************************************************************\n*                                                                     *\n*        ISSUE COMMAND                                                *\n*                                                                     *\n*                                                                     *\n***********************************************************************\nCMD0     DS    0H\n*        XAUTHON ,\n         WTO  MF=(E,WTO)                                            ptw\n         MODESET KEY=ZERO              GET AUTHORIZED FOR COMMANDS\n         LA    R0,0                    A SYSTEM REQUEST\n*        LR    R0,R2                   LOAD COMMAND AUTHORIZATION IN R0\n         LA    R1,COMAREA              POINT TO COMMAND\n         MGCR  (1)                     ISSUE COMMAND\n         STC   R15,RCODE               SAVE RETURN CODE\n         MODESET KEY=NZERO             NO MORE AUTH.\n*        XAUTHOFF ,\nCMD99    DS    0H\n         BR    R11\n         EJECT\n***********************************************************************\n*                                                                     *\n*         RETURN TO SYSTEM                                            *\n*                                                                     *\n*                                                                     *\n***********************************************************************\nRETURN   DS    0H\n         XR    R15,R15\n         IC    R15,RCODE\n         L     R13,4(R13)\n         RETURN (14,12),T,RC=(15)\n         EJECT\n***********************************************************************\n*                                                                     *\n*        DATA AREAS                                                   *\n*                                                                     *\n*                                                                     *\n***********************************************************************\nRCODE    DC    XL1'00'                 RETURN CODE\nPSCBADDR DS    F                                                    ptw\nCOMAREA  DS    0H                      RESULTANT COMMAND\nCOMLEN   DC    H'0',H'0'               1ST IS LENGTH, SECOND IS IGNORED\nCOMAND   DC    CL80' '                 COMMAND AREA                 ptw\nXWTO WTO 'SPY010I  USERID :                                            X\n                                                   ',ROUTCDE=2,MF=L\nWTOLEN   EQU   *-XWTO                                               ptw\nWTO      DS    XL(WTOLEN)         WTO AREA.                         ptw\nWTOUSER  EQU   WTO+13,7           USERID.                           ptw\nWTOMOVE  MVC   WTO+22(*-*),2(R3)                                    ptw\n         EJECT\n***********************************************************************\n*                                                                     *\n*         REGISTER EQUATES, LITERAL POOL                              *\n*                                                                     *\n*                                                                     *\n***********************************************************************\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         LTORG  *\n         IKJPSCB                                                    ptw\n         END   COMMAND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DOC$CHGS": {"ttr": 1798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x02\\x8f\\x00\\x99\\x02\\x8f\\x13\\x11\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe3\\xe2\\xc3\\xd7\\xf0\\xf0\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-01-28T00:00:00", "modifydate": "1999-01-28T13:11:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "TSCP004"}, "text": "********************************************************************\n*                                                                  *\n* NAME - DSPACE.                                                   *\n*                                                                  *\n* DESCRIPTION - TSO COMMAND TO DISPLAY AVAILABLE SPACE ON DIRECT   *\n*               ACCESS VOLUME(S).                                  *\n*                                                                  *\n* TO USE - ENTER: DSPACE VVVVVV   ,VVVVVV = A VOLSER (1-6 CHARS)   *\n*                 DSPACE UUUU     ,UUUU = A UCB ADDRESS (4 CHARS)  *\n*                 DSPACE NNNNNNNN ,NNNNNNNN = A UNITNAME (1-8 CHARS*\n*                 DSPACE STORAGE  ,FOR ALL STORAGE VOLUMES         *\n*                 DSPACE PUBLIC   ,FOR ALL PUBLIC VOLUMES          *\n*                 DSPACE PRIVATE  ,FOR ALL PRIVATE VOLUMES         *\n*                 DSPACE ONLINE   ,FOR ALL ONLINE VOLUMES (DEFAULT)*\n*                                                                  *\n*   NOTE: DSPACE ACCEPTS A MASK: DSPACE RES* OR DSPACE 3C*         *\n*         DSPACE ALSO ACCEPTS A LIST: DSPACE (VVVVVV,UUUU,...)     *\n*                                                                  *\n* LOG -                                                            *\n*   12/17/86 L01 PTW IMPLEMENTED                                   *L01\n*   05/16/95 DAV ADD 3390 TO DEVTABLE.                             *\n*   01/14/99 DAV CHANGE TO WORK WITH NEW I/O GEN, USING UCBSCAN.   *\n*                ALSO ADD 3390 DYNAMIC TO DEVTABLE.                *\n*   01/27/99 DAV CHANGE TO WORK 4 DIGIT ADDRESS AND CORRECT IXVTOC *\n*                NOT SHOWING.                                      *\n********************************************************************\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DOPROG": {"ttr": 1800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x04\\xd9\\x04\\xd9\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 1241, "newlines": 1241, "modlines": 0, "user": "FILE369"}, "text": "*************************************************************JFS03NOV77\n*             LATEST UPDATE DATE   3, JUNE '83   RRS         JFS03NOV77\n         LCLC  &DATE                                         JFS03NOV77\n&DATE    SETC  '03JUN83'                                     JFS03NOV77\n*************************************************************JFS03NOV77\nDOPG TITLE 'NASA/GSFC -- DOPROG/DOPGM (TSO) COMMAND PROCESSOR (&DATE)'\n*                                                            JFS03NOV77\n**\n** THE DOPROG TSO COMMAND WAS\n** DESIGNED AND DEVELOPED BY J. SCHINDLER (CSC), MARCH 1975\n**   THE DOPROG COMMAND IS BASED ON AN EARLIER VERSION THAT WAS\n**   DESIGNED AND DEVELOPED BY\n**       GENE CZARCINSKI\n**       NASA, GODDARD SPACE FLIGHT CENTER\n**       GREENBELT, MARYLAND\n**\n** UPDATED 10APR77, GENE CZARCINSKI, NASA/GSFC (GT00501)\n**      . RENAME CSECT FROM 'GSFTSODO' TO 'DOPROG' WITH AN\n**        ENTRY POINT OF DOPGM ... MORE CONSISTANCY AND\n**        CLEANER CMDLIB\n**      . CHANGE BASE REG INIT CODE .. IT IS FLAKY AND MAY CAUSE\n**        ERROR*********\n** UPDATED 03NOV77, J. SCHINDLER, (PAC) CSC\n**      . INCLUDED CODE SO THAT THE LATEST UPDATE DATE COULD BE\n**        CHANGED EASILY\n**      . CHANGED THE LOGIC SO THAT THE 2 BYTES FROM THE ATTACH\n**        ECB IS USED AS THE RETURN CODE THAT IS PASSED ON EXIT\n**        FROM THIS COMMAND PROCESSOR\n** UPDATED 18APR80, B. GODFREY, AFDSC\n**      . BALR TO IKJPARS INSTEAD OF LINK, FOR MVS\n**      . REPLACE REGS MACRO WITH 16 EQUATES\n**      . USE UPTPREFX INSTEAD OF PSCBUSER. ADDED IKJUPT MACRO.\n** UPDATED 03JUN83, DICK SZIEDE G.E.\n**      . ADD \"DOCP\" ALIAS, AND SUPPORT CODE TO INVOKE A COMMAND\n**        PROCESSOR.   THIS ISN'T JOE'S \"DOCP,\" WHICH IS A STAND-ALONE\n**        CP, RATHER THAN AN ALIAS OF DOPROG.   JOE USED TPUT-TGET TO\n**        PROMPT FOR THE COMMAND LINE, WHICH I DIDN'T LIKE.   THIS\n**        VERSION WILL TAKE A CP COMMAND LINE IN QUOTES, OR WILL\n**        PROMPT WITH PUTGET IF IT DOESN'T FIND ONE.  THUS WE CAN BE\n**        USED IN A CLIST.\n** UPDATED 06OCT87, CHARLIE PITTS PRC\n**        CORRECTED A PROBLEM WHICH OCCURED RUNNING THE TMP IN\n**        BATCH AND USING DOPROG. WITHOUT A VALID USERID/PREFIX,\n**        INTERNAL WORKAREA GOT CORRUPTED WITH VARYING RESULTS.\n**        ALSO ADDED 'PUNCH' STATEMENT TO AUTOMATICALLY GENERATE\n**        THE ALIAS CARD FOR LKED.\n**\n** ATTR - RENT\n** ALIAS - DOCP\n**\n** COMMAND -\n**\n** DOPROG/DOCP  'LOAD MOD NAME' ''PARMS'' TASKLIB/LIB('DSLIST')\n**               RC/NORC/ALLRC\n**    'LOAD MOD NAME' - NAME OF THE LOAD MODULE TO BE EXECUTED.\n**    ''PARMS'' - PARM FIELD TO BE PASSED TO THE LOAD MODULE, QUOTED\n**               STRING.\n**              - COMMAND LINE TO BE PASSED TO COMMAND PROCESSOR.\n**    TASKLIB('DSLIST') - SPECIFIES THE DATA SET NAME(S) THAT ARE\n**             CONTENATED AND USED FOR THE TASK LIBRARY.\n**    LIB('DSLIST') - SAME AS TASKLIB\n**    RC - SPECIFIES THAT THE NON-ZERO RETURN CODE FROM THE EXECUTED\n**              PROGRAM IS TO BE PRINTED.\n**    NORC - SPECIFIES THAT THE RETURN CODE IS NOT TO BE PRINTED.\n**          (DEFAULT).\n**    ALLRC - SPECIFIES THAT THE RETURN CODE IS TO BE PRINTED.\n**      NOTE - THE RETURN CODE FROM THE EXECUTED PROGRAM IS ALWAYS\n**             PASSED. IF THIS COMMAND PROCESSOR ENCOUNTERS AN ERROR\n**             OR AN ATTENTION IS ENTERED, THE RETURN CODE IS 16.\n**\n**\n** THIS COMMAND PROCESSOR IS DESIGNED TO LOAD AND EXECUTE (ATTACH) A\n** PROGRAM IN ONE OF THE SYSTEM LINK LIBRARIES OR A USER\n** LIBRARY (TASKLIB).\n**\n         SPACE 1                                              CJP OCT87\n         PUNCH ' ALIAS DOCP '                                 CJP OCT87\n         SPACE 1                                              CJP OCT87\nDOPROG   CSECT\n         ENTRY DOPGM\n*        REGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n**\n** FLAGS SETTINGS -\n**\n**       1... ... - RC (PRINT NON-ZERO RETURN CODES)\n**       .1.. .... - ALLRC (PRINT ALL RETURN CODES)\n**       ..1. .... - TASKLIB SPECIFIED\n**       ...1 .... - DSNAME INPUT IN QOUTES\n**       .... 1111 - NOT USED\n**\n**\n** FLAGS EQUATES -\n**\nRCFLG    EQU   B'10000000' PRINT NON-ZERO RC FLAG\nALLRCFLG EQU   B'01000000' PRINT ALL RC FLAG\nTASKFLG  EQU   B'00100000' TASKLIB WAS SPECIFIED\nQFLG     EQU   B'00010000' DSNAME WAS INPUT IN QUOTES FLAG\n**\nDOPGM    SAVE  (14,12),,DOPROG/DOPGM-GT00501-&DATE\n         LA    R10,0(,R15)    *** INIT BASE REGS ***        GT00501\n         LA    R11,2048                                     GT00501\n         AR    R11,R11                                      GT00501\n         AR    R11,R10                                      GT00501\n         USING DOPROG,R10,R11\n         LR    R9,R1 SAVE CPPL PTR\n         USING CPPL,R9\n         LA    R0,RENTLEN LOAD LENGTH OF RENT DSECT\n         GETMAIN R,LV=(0) SP=0\n         USING SAVE,R1\n         ST    R1,8(R13)\n         ST    R13,4(R1)\n         LR    R13,R1\n         DROP  R1\n         USING SAVE,R13\n**\n** INIT PARSE PARM LIST (PPL)\n**\nBEGIN    LA    R8,PARSEPL\n         USING PPL,R8\n         MVC   PPLUPT,CPPLUPT USER PROFILE TABLE\n         MVC   PPLECT,CPPLECT ENVIRONMENT CONTROL TABLE\n         LA    R2,ECB\n         ST    R2,PPLECB ECB\n         LA    R2,ANSWER\n         ST    R2,PPLANS ADDR OF PDL\n         MVC   PPLCBUF,CPPLCBUF COMMAND BUFFER\n         L     R3,CPPLCBUF         FIRST, DETERMINE IF WE'RE      RRS\n         AH    R3,2(R3)            A COMMAND PROCESSOR.  QUIT IF  RRS\n         BCTR  R3,0                NOT.                           RRS\n         OC    0(5,R3),=C'     '                                  RRS\n         LA    R15,4               4 ==> WE ARE DOPROG            RRS\n         CLC   0(5,R3),=C'DOCP '   R3 SHOULD POINT TO COMMAND THATRRS\n         BNE   NOTDOCP             INVOKED US.                    RRS\n         MVC   MYCPPL(16),CPPLCBUF COPY THE CPPL FOR LATER        RRS\n         SR    R15,R15             0 ==> WE ARE DOCP              RRS\nNOTDOCP  ST    R15,MYCPSWIT                                       RRS\n*                                                                 RRS\n         XC    PPLUWA,PPLUWA USER WORK AREA ADDR\n         MVC   PPLPCL,=A(PPLPARM) PARM CONTROL LIST\n**\n** INIT STACK IOPL\n**\n         LA    R8,STAKIOPL\n         USING IOPL,R8\n         MVC   IOPLUPT,CPPLUPT\n         MVC   IOPLECT,CPPLECT\n         LA    R2,STAKECB\n         ST    R2,IOPLECB\n** IOPLIOPB WILL BE INIT BY STACK MACRO\n**\n** INIT IOPL\n**\n         LA    R8,IOPLA\n         USING IOPL,R8\n         MVC   IOPLUPT,CPPLUPT\n         MVC   IOPLECT,CPPLECT\n         LA    R2,ECB\n         ST    R2,IOPLECB\n** IOPLIOPB WILL BE INIT BY MACRO\n**\n** INIT DAIR PARM LIST\n         LA    R8,DAIRPL\n         USING DAPL,R8\n         MVC   DAPLUPT,CPPLUPT\n         MVC   DAPLECT,CPPLECT\n         LA    R2,ECB\n         ST    R2,DAPLECB\n         MVC   DAPLPSCB,CPPLPSCB PROTECTED STEP CONTROL BLOCK\n         LA    R2,DAIRPB\n         ST    R2,DAPLDAPB ADDR OF DAIR PARM BLOCK\n**\n** SAVE PREFIX AND LENGTH WITH PERIOD (.)\n**\n         L     R15,CPPLUPT\n         SR    R3,R3\n         IC    R3,UPTPREFL-UPT(,R15)  LENGTH OF PREFIX\n         LA    R15,UPTPREFX-UPT(,R15) ADDRESS OF PREFIX\n         LTR   R4,R3                                          CJP OCT87\n         BNP   NOUSERID                                       CJP OCT87\n         BCTR  R3,R0\n         LA    R14,USERID\n         EX    R3,MOVE\n*MOVE    MVC   0(0,R14),0(R15)\n         LA    R3,USERID(R4)\n         MVI   0(R3),C'.' MOVE IN PERIOD\n         LA    R4,1(R4) FOR PERIOB\nNOUSERID DS    0H                                             CJP OCT87\n         STH   R4,USERIDL\n         DROP  R8,R9\n**\n** INIT PARM BLOCK, ETC.\n**\n         MVC   PTPB(PTREFL),PTREF INIT PUTLINE PARM BLOCK\n         MVC   PGPB(PGREFL),PGREF INIT PUTGET PARM BLOCK\n         MVC   STAK(STAKREFL),STAKREF INIT STACK PARM BLOCK\n         XC    NODDNS,NODDNS INIT NO. OF DDNAMES SPECIFIED BY TASKLIB\n         XC    ANSWER1,ANSWER1\n         MVI   FLAGS,0\n         MVC   EPENTRY(4),=Y(1,58)\n         MVC   EPNAME,BLANKS\n         LA    R2,1\n         ST    R2,OLD ONLY ONE SEGMENT\n**\n** PARSE THE COMMAND\n**\n         XC    ECB,ECB\n         LA    R1,PARSEPL\n         L     R15,16              CVTPTR\n         TM    524(R15),X'80'      IS IKJPARS IN LPA ?\n         BNO   PARSELNK            IF NOT, DO LINK\n         L     R15,524(,R15)       GET ADDRESS OF IKJPARS\n         BALR  R14,R15             CALL PARSE SERVICE ROUTINE\n         B     PARSELTR            BRANCH AROUND LINK\nPARSELNK EQU   *\n         LINK  EP=IKJPARS LINK TO PARSE\nPARSELTR LTR   R15,R15\n         BZ    PARSEOK\n         LA    R0,MSG01\n         BAL   R14,PUTLINE PARSE ERROR\n         B     ERRORRTN\nPARSEOK  DC    0H'0'\n         L     R12,ANSWER\n         USING PDL,R12\n         STM   R14,R12,STAXSAVE+12 SAVE REGS SO STAXEXIT CAN USE\n**             PROGRAM BASE REGS\n         MVC   STAXLIST(STAXREFL),STAXREF\n         LA    R2,STAXSAVE\n         STAX  STAXEXIT,USADDR=(R2),MF=(E,STAXLIST)\n         CLI   RCKEYWD+1,2 TEST FOR NO RC\n         BE    TESTAKW GO TEST FOR TASK LIB\n         BH    SETALLFL\n         OI    FLAGS,RCFLG\n         B     TESTAKW GO TEST FOR TASK LIB\nSETALLFL OI    FLAGS,ALLRCFLG\nTESTAKW  DC    0H'0'\n         CLI   TASKEYWD+1,0 TEST FOR TASKLIB\n         BE    MOVEEP\n**\n**INIT PARSEPL WITH DIFFERENT ANSWER ADDR AND COMMAND BUFFER IN\n** CASE THE DATA SET(S) WHOSE NAMES ARE SPECIFIED BY THE TASKLIB\n** KEYWORD ARE NOT IN THE CATALOG, CANT BE ALLOCATED, ETC.\n**\n         OI    FLAGS,TASKFLG\n         LA    R2,ANSWER1\n         ST    R2,PARSEPL+16\n         LA    R2,CMDLEN\n         ST    R2,PARSEPL+20\n         MVC   PARSEPL+12,=A(DSNPPL)\n         LA    R9,TASKDSNA USE R9 AS BASE FOR DSNAME PDE\nTASKLP1  DC    0H'0'\n         NI    FLAGS,255-QFLG\n         L     R15,0(R9) LOAD ADDR OF DSNAME\n         LTR   R15,R15 TEST FOR DSNAME\n         BNZ   TASKB\n**\n** DATA SET NAME ERROR -- PROBABLY MEMBER NAME ONLY\n**\n         TM    14(R9),B'10000000' TEST FOR MEMBER NAME\n         BO    TASKA\n         LA    R0,MSG02 INVALID DSNAME\n         BAL   R14,PUTLINE\n         B     TASKPRMT GO PROMPT FOR ANOTHER DSNAME\nTASKA    OI    FLAGS,QFLG SO ''( ... )'' WILL BE PRINTED\n         LA    R14,CMDBUF\n         MVI   0(R14),C'('\n         LA    R14,1(R14)\n         LA    R2,1\n         LH    R3,12(R9) LOAD LENGTH OF MEMBER NAME\n         AR    R2,R3\n         BCTR  R3,R0\n         L     R15,8(R9) LOAD ADDR OF MEMBER NAME\n         EX    R3,MOVE\n         LA    R14,1(R3,R14)\n         MVI   0(R14),C')'\n         LA    R2,1(R2)\n         STH   R2,CMDOFF\n         LA    R0,CMDOFF\n         LA    R1,MSG03\n         BAL   R14,MSGOUT GO OUTPUT 'DATA SET --- INVALID'\n         B     TASKPRMT GO PROMPT FOR ANOTHER DATA SET NAME\n**\n** DATA SET NAME WAS SPECIFIED, IGNORE MEMBER NAME IF SPECIFIED.\n**\nTASKB    DC    0H'0'\n         TM    6(R9),B'01000000' TEST FOR QUOTES\n         BZ    TASKC\n         OI    FLAGS,QFLG SET QUOTES FLAG\nTASKC    LH    R2,4(R9) LOAD LENGTH OF DATA SET NAME\n         STH   R2,DSNLEN\n         BCTR  R2,R0\n         LA    R14,DSNAME R15= ADDR OF INPUT DSNAME\n         EX    R2,MOVE\n**\n** ALLOC DSNAME\n**\n         LA    R8,DAIRPB\n         USING DAPB08,R8\n         MVC   DA08CD,=X'0008'\n         XC    DA08FLG(6),DA08FLG\n         LA    R2,DSNLEN\n         ST    R2,DA08PDSN\n         MVI   DA08DDN,C' '\n         MVC   DA08DDN+1(23),DA08DDN\n         XC    DA08BLK(16),DA08BLK\n         MVI   DA08MNM,C' '\n         MVC   DA08MNM+1(15),DA08MNM\n         MVI   DA08DSP1,B'00001000' SHR\n         MVI   DA08DPS2,B'00001000' KEEP\n         MVI   DA08DPS3,B'00001000' KEEP\n         XC    DA08CTL(5),DA08CTL\n         TM    FLAGS,QFLG TEST FOR QUOTE\n         BO    *+8\n         OI    DA08CTL,B'00100000' PREFIX USER ID\n         XC    ECB,ECB\n         LA    R1,DAIRPL\n         LINK  EP=IKJEFD00 LINK TO DAIR\n         LTR   R15,R15\n         BZ    TESTPDS\n         CH    R15,=H'8' TEST FOR CATALOG ERROR\n         BNE   TASKDAER\n         CLC   DA08DARC,=X'170C'\n         BNE   TASKCTER\n         TM    FLAGS,QFLG TEST FOR QUOTES\n         BO    TASKDAER\n**\n** SINCE THE DSNAME IS NOT IN QUOTES, APPEND .LOAD AND TRY ALLOC AGAIN\n**\n         LH    R2,DSNLEN\n         LA    R3,DSNAME(R2)\n         MVC   0(5,R3),=C'.LOAD'\n         LA    R2,5(R2)\n         STH   R2,DSNLEN\n         XC    DA08DARC(4),DA08DARC\n         XC    ECB,ECB\n         LA    R1,DAIRPL\n         LINK  EP=IKJEFD00 LINK TO DAIR\n         LTR   R15,R15\n         BZ    TESTPDS\n         LH    R2,DSNLEN\n         SH    R2,=H'5' FOR .LOAAD\n         STH   R2,DSNLEN\n         CH    R15,=H'8' TEST FOR CATALOG ERROR\n         BNE   TASKDAER\nTASKCTER DC    0H'0' CATALOG ERROR\n         LA    R0,DSNLEN\n         LA    R1,MSG06 DSNAME NOT IN CATALOG\n         BAL   R14,MSGOUT\n         B     TASKPRMT GO PROMPT\n**\n** ALLOCATION ERROR\n**\nTASKDAER DC    0H'0'\n         ST    R15,SAVER15\n         LA    R0,DSNLEN\n         LA    R1,MSG25\n         BAL   R14,MSGOUT\n         L     R15,SAVER15\n         CH    R15,=H'12'\n         BH    TESTDARC\n         MVC   WORKBUFF(L'MSG07),MSG07\n         LA    R6,L'MSG07+8\n         STH   R6,WORKLEN\n         XC    WORKOFF,WORKOFF\n         LH    R2,DA08DARC\n         LA    R4,4\n         SR    R5,R5\n         LA    R6,WORKBUFF+L'MSG07-1\nTASKLP2  SRDL  R2,4\n         SRL   R3,28\n         IC    R5,TABLE(R3)\n         STC   R5,0(R4,R6)\n         BCT   R4,TASKLP2\n         LA    R0,WORKLEN\n         BAL   R14,PUTLINE\n         B     TASKPRMT\nTESTDARC DC    0H'0'\n         CH    R15,=H'16'\n         BH    TSTDARC1\n         LA    R0,MSG26  ALLOCATIONS EXCEEDED\n         BAL   R14,PUTLINE\n         B     TASKPRMT\nTSTDARC1 DC    0H'0'\n         MVC   WORKBUFF(L'MSG27),MSG27\n         CVD   R15,DWORK\n         UNPK  DWORK(3),DWORK+6(2)\n         OI    DWORK+2,C'0'\n         MVC   WORKBUFF+L'MSG27(2),DWORK+1\n         LA    R2,L'MSG27+6\n         STH   R2,WORKLEN\n         XC    WORKOFF,WORKOFF\n         LA    R0,WORKLEN\n         BAL   R14,PUTLINE\n         B     TASKPRMT\n**\n** DATA SET IS ALLOCATED, TEST FOR PDS.\n**\nTESTPDS  TM    DA08DSO,B'00000010' TEST FOR PDS\n         BO    SAVEDDN\n         LA    R0,DSNLEN\n         LA    R1,MSG13\n         BAL   R14,MSGOUT DS IS NOT PDS\n         LA    R1,DA08DDN\n         BAL   R14,FREEDDN GO FREE DDNAME\n         B     TASKPRMT\nSAVEDDN  LH    R2,NODDNS SAVE ALLOCATED DDNAME\n         SLL   R2,3 MULTIPLY BY 8\n         LA    R3,DDNAMES(R2)\n         MVC   0(8,R3),DA08DDN SAVE DDNAME\n         DROP  R8\n         LH    R2,NODDNS\n         LA    R2,1(R2)\n         STH   R2,NODDNS\n         CH    R2,=H'10'\n         BL    TASKENLP\n         CLI   24(R9),X'FF' TEST FOR LAST PDE\n         BE    CONCAT  LAST PDE -- GO CONCAT.\n         LA    R0,MSG08  MORE THAN 10 DSNAMES SPECIFIED BY TASKLIB\n         BAL   R14,PUTLINE\n         LA    R2,MSG09\n         ST    R2,OLD+4\n         TCLEARQ INPUT\n         XC    ECB,ECB\n         PUTGET PARM=PGPB,OUTPUT=(OLD,SINGLE,PROMPT),                  X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     X\n               TERMGET=(EDIT,WAIT),MF=(E,IOPLA)\n         CH    R15,=H'4'\n         BH    TESTPGRC GO TEST RETURN CODE\n         L     R2,PGPB+12 LOAD ADDR OF INPUT LINE\n         LH    R3,0(R2) LOAD LENGTH OF INPUT LINE\n         CH    R3,=H'4' TEST FOR NULL LINE\n         BNH   CONCAT\n         B     ERRORRTN\n**\n** PROMPT FOR TASK LIBRARY DATA SET NAME\n**\nTASKPRMT LA    R2,MSG04 ENTER TASKLIB DSNAME\n         ST    R2,OLD+4\n         TCLEARQ INPUT\n         XC    ECB,ECB\nTASKPRMA PUTGET PARM=PGPB,OUTPUT=(OLD,SINGLE,PROMPT),                  X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     X\n               TERMGET=(EDIT,WAIT),MF=(E,IOPLA)\n         CH    R15,=H'4'\n         BH    TESTPGRC\n         L     R15,PGPB+12 LOAD ADDR OF INPUT LINE\n         LH    R2,0(R15) LOAD LENGTH\n         CH    R2,=H'48' TEST FOR MAX DSN LENGTH\n         BNH   TASKPRMB\n         LR    R0,R2\n         O     R0,=X'01000000' SP=1\n         LR    R1,R15\n         FREEMAIN R,LV=(0),A=(1)\n         LA    R0,MSG05 DSNAME TOO LONG\n         BAL   R14,PUTLINE\n         B     TASKPRMA\nTASKPRMB BCTR  R2,R0\n         LA    R14,CMDLEN\n         EX    R2,MOVE\n         LH    R0,0(R15)\n         O     R0,=X'01000000' SP=1\n         LR    R1,R15\n         FREEMAIN R,LV=(0),A=(1)\n         LH    R2,CMDLEN\n         CH    R2,=H'4' TEST FOR NULL LINE RESPONSE\n         BNH   TASKENLP GO TO END OF LOOP\n         IKJRLSA ANSWER1\n         XC    ECB,ECB\n         LA    R1,PARSEPL\n         LINK  EP=IKJPARS PARSE DSNAME\n         CH    R15,=H'8' TEST FOR ATTN\n         BE    ERRORRTN GO RETURN\n         BH    TASKPRMC\n         CH    R15,=H'4'\n         BNE   TASKPRMD\nTASKPRMC LA    R0,MSG01 PARSE ERROR\n         BAL   R14,PUTLINE\n         B     ERRORRTN\nTASKPRMD L     R15,ANSWER1\n         USING DSNPDL,R15\n         MVC   0(24,R9),NEWDSN OVERLAY OLD PDE WITH NEW ONE\n         B     TASKLP1\n         DROP  R15\n**\n** TEST FOR RETURN CODE FROM PUTGET\n**\nTESTPGRC CH    R15,=H'8'\n         BE    ERRORRTN\n         CH    R15,=H'12'\n         BNE   TESTRC24\n         TPUT  MSG10,MSG10L NO PROMPTING\n         B     ERRORRTN\nTESTRC24 CH    R15,=H'24'\n         BNE   PGRC28\n         TPUT  MSG11,MSG11L INVALID PARMS\n         B     ERRORRTN\nPGRC28   TPUT  MSG12,MSG12L NOT ENOUGH SPACE\n         B     ERRORRTN\n**\n** TEST FOR END OF PDE'S\n**\nTASKENLP CLI   24(R9),X'FF'\n         BE    CONCAT\n         L     R9,24(R9) ADDR OF NEXT PDE\n         B     TASKLP1\n**\n** ALL DATA SETS FOR TASKLIB HAVE BEEN ALLOCATED. NOW CONCATENATE THEM.\n**\nCONCAT   DC    0H'0'\n         LH    R2,NODDNS TEST FOR TASK LIBRARIES\n         CH    R2,=H'1'\n         BE    MOVEEP\n         BH    CONCAT1\n         LA    R0,MSG16\n         BAL   R14,PUTLINE\n         LA    R2,MSG09\n         ST    R2,OLD+4\n         TCLEARQ INPUT\n         XC    ECB,ECB\n         PUTGET PARM=PGPB,OUTPUT=(OLD,SINGLE,PROMPT),                  X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     X\n               TERMGET=(EDIT,WAIT),MF=(E,IOPLA)\n         CH    R15,=H'4'\n         BH    TESTPGRC GO TEST RC FROM PUTGET\n         L     R1,PGPB+12 LOAD ADDR OF INPUT LINE\n         LH    R0,0(R1) LOAD LENGTH\n         CH    R0,=H'4' TEST FOR NULL LINE\n         BH    ERRORRTN\n         O     R0,=X'01000000' SP=1\n         FREEMAIN R,LV=(0),A=(1)\n         B     MOVEEP\nCONCAT1  LA    R8,DAIRPB\n         USING DAPB0C,R8\n         MVC   DA0CCD,=X'000C'\n         XC    DA0CFLG(6),DA0CFLG\n         LH    R2,NODDNS\n         STH   R2,DA0CNUMB\n         XC    DA0CNUMB+2(2),DA0CNUMB+2\n         SLL   R2,3 MULTIPLY BY 8\n         BCTR  R2,R0\n         LA    R14,DA0CDDN\n         LA    R15,DDNAMES\n         EX    R2,MOVE\n         DROP  R8\n         XC    ECB,ECB\n         LA    R1,DAIRPL\n         LINK  EP=IKJEFD00 LINK TO DAIR\n         LTR   R15,R15\n         BZ    MOVEEP GO MOVE IN EP NAME\n         LA    R0,MSG14 CONCAT ERROR\n         BAL   R14,PUTLINE\n         B     ERRORRTN\n**\n** HAVE ALLOCATED AND CONCATENATED THE TASK LIBRARIES, WILL NOW\n** MOVE LOAD MOD NAME, MOVE THE PARM FIELD (IF SPECIFIED), OPEN THE\n** TASKLIB DCB, AND ATTACH.\n**\nMOVEEP   DC    0H'0'\n         LH    R2,LOADMOD+4\n         STH   R2,EPNAMEL   SAVE LENGTH OF PROGRAM NAME\n         BCTR  R2,R0\n         L     R15,LOADMOD\n         LA    R14,EPNAME\n         EX    R2,MOVE MOVE EP NAME\n         TM    PARMA+6,B'10000000' TEST FOR PARM FIELD\n         BO    TSTPARML\n         XC    PARMFLDL,PARMFLDL\n         B     TESTTSK\nTSTPARML LH    R2,PARMA+4 LOAD LENGTH OF QSTRING (PARMFIELD)\n         CH    R2,=H'256'\n         BNH   MOVEPARM\n         LA    R0,MSG15 PARM FIELD EXCEEDS 256 BYTES\n         BAL   R14,PUTLINE\n         LA    R2,256\nMOVEPARM STH   R2,PARMFLDL\n         BCTR  R2,R0\n         L     R15,PARMA LOAD ADDR OF QSTRING\n         LA    R14,PARMFLD\n         EX    R2,MOVE MOVE PARM FIELD\n         LH    R2,NODDNS\n         TM    FLAGS,TASKFLG WAS TASKLIB SPECIFIED?\n         BZ    RELEASE NO\nTESTTSK  DC    0H'0' TEST FOR TASKLIB DSNAMES\n         LH    R2,NODDNS\n         LTR   R2,R2\n         BZ    RELEASE\n         MVC   TASKLIB(SKELDCBL),SKELDCB\n         LA    R8,TASKLIB\n         USING IHADCB,R8\n         MVC   DCBDDNAM,DDNAMES MOVE DDNAME TO DCB\n         DROP  R8\n**\n** RELEASE PARSE SPACE BEFORE ATTACHING  (MOVED FOR DOCP---RRS)\n**\nRELEASE  DC    0H'0'\n*        IKJRLSA ANSWER                                   RRS\n*        XC    ANSWER,ANSWER                              RRS\n*        IKJRLSA ANSWER1                                  RRS\n*        XC    ANSWER1,ANSWER1                            RRS\n*        SR    R0,R0                                      RRS\n*        GETMAIN R,LV=(0) CLEAN UP SEGMENTS               RRS\n         MVC   ATTACH(ATREFL),ATREF\n         XC    ECB,ECB\n         LA    R1,PARMFLDL\n         ST    R1,PARMADDR\n         OI    PARMADDR,X'80'\n         TM    FLAGS,TASKFLG TEST FOR TASK LIB\n         BZ    ATTACH1\n         LH    R2,NODDNS\n         LTR   R2,R2\n         BNZ   OPENDCB\nATTACH1  DC    0H'0'\n         BLDL  0,EPENTRY\n         LTR   R15,R15 WAS EP NAME FOUND?\n         BNZ   EPERROR NO - GO PUT OUT MSG\n         LA    R1,PARMADDR\n         L     R15,MYCPSWIT        ARE WE ATTACHING A  CP?       RRS\n         B     *+4(R15)            RC=0 ==> DOCP                 RRS\n         BAL   R14,CPSTUFF         RC=4 ==> DOPROG               RRS\n         LA    R15,ATTACH\n         LA    R2,ECB\n         LA    R3,EPNAME\n         XC    ECB,ECB\n         ATTACH DE=(3),ECB=(2),SHSPL=SPLIST,                           X\n               MF=(E,(1)),SF=(E,(15))\n         B     WAIT\nOPENDCB  DC    0H'0'\n         MVC   OPEN(OPENREFL),OPENREF\n         LA    R1,OPEN\n         LA    R2,TASKLIB\n         OPEN  ((2),(INPUT)),MF=(E,(1))\n         LA    R8,TASKLIB\n         USING IHADCB,R8\n         TM    DCBOFLGS,B'00010000' TEST FOR OPEN\n         BO    OPENOK\n         LA    R0,MSG17 DCB NOT OPEN\n         BAL   R14,PUTLINE\n         B     ERRORRTN\n         DROP  R8\nOPENOK   DC    0H'0'\n         LA    R3,TASKLIB\n         BLDL  (3),EPENTRY\n         LTR   R15,R15\n         BZ    GOTEPOK\nEPERROR  DC    0H'0' PROGRAM NAME NOT FOUND\n         LA    R14,WORKBUFF\n         MVC   0(MSG20L,R14),MSG20  PROGRAM NAME\n         LA    R14,MSG20L(R14)\n         MVI   0(R14),C''''\n         LA    R14,1(R14)\n         LH    R2,EPNAMEL\n         BCTR  R2,R0\n         LA    R15,EPNAME\n         EX    R2,MOVE  EPNAME\n         LA    R14,1(R2,R14)\n         MVI   0(R14),C''''\n         LA    R14,1(R14)\n         MVC   0(MSG21L,R14),MSG21  NOT FOUND\n         LA    R14,MSG21L(R14)\n         LH    R2,NODDNS\n         LTR   R2,R2\n         BZ    EPERROR1\n         MVC   0(4,R14),=C'TASK'\n         B     EPERROR2\nEPERROR1 MVC   0(4,R14),=C'LINK'\nEPERROR2 LA    R14,4(R14)\n         MVC   0(MSG22L,R14),MSG22  LIBRARIES\n         LA    R14,MSG22L(R14)\n         LA    R2,WORKLEN\n         SR    R14,R2\n         STH   R14,WORKLEN\n         XC    WORKOFF,WORKOFF\n         LA    R0,WORKLEN\n         BAL   R14,PUTLINE\nEPERROR3 LA    R2,MSG23\n         ST    R2,OLD+4\n         TCLEARQ INPUT\n         XC    ECB,ECB\n         PUTGET PARM=PGPB,OUTPUT=(OLD,SINGLE,PROMPT),                  X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     X\n               TERMGET=(EDIT,WAIT),MF=(E,IOPLA)\n         CH    R15,=H'4'\n         BH    TESTPGRC\n         L     R1,PGPB+12  LOAD ADDR\n         LH    R3,0(R1)\n         SH    R3,=H'4'\n         BNP   ERRORRTN\n         CH    R3,=H'8'\n         BNH   EPERROR4\n         LA    R0,MSG24  PROGRAM NAME EXCEEDS 8 CHAR\n         BAL   R14,PUTLINE\n         B     EPERROR3\nEPERROR4 STH   R3,EPNAMEL  STORE LENGTH OF EP NAME\n         MVC   EPNAME,BLANKS\n         LA    R14,EPNAME\n         LA    R15,4(R1)\n         BCTR  R3,R0\n         EX    R3,MOVE\n         OC    EPNAME,BLANKS UPPER CASE EP NAME\n         LH    R0,0(R1)\n         O     R0,=X'01000000'  SP=1\n         FREEMAIN R,LV=(0),A=(1)\n         LH    R2,NODDNS\n         LTR   R2,R2\n         BNZ   OPENOK\n         B     ATTACH1\nGOTEPOK  DC    0H'0'\n         LA    R1,PARMADDR\n         L     R15,MYCPSWIT        ARE WE ATTACHING A  CP?       RRS\n         B     *+4(R15)            RC=0 ==> DOCP                 RRS\n         BAL   R14,CPSTUFF         RC=4 ==> DOPROG               RRS\n         LA    R15,ATTACH\n         LA    R2,ECB\n         LA    R4,EPNAME\n         XC    ECB,ECB\n         ATTACH DE=(4),ECB=(2),TASKLIB=(3),SHSPL=SPLIST,               X\n               MF=(E,(1)),SF=(E,(15))\nWAIT     ST    R1,TCB\n         LA    R2,ECB\n         WAIT  ECB=(2)\n         DETACH TCB\n         XC    COMPCDE,COMPCDE   CLEAR CONDITION CODE        JFS04NOV77\n         MVC   COMPCDE+2(2),ECB+2  SAVE CONDITION CODE     JFS03NOV77\n         B     RETURN\n*-------                                                          RRS\n*------- DOCP, PASS A CPPL IN R1, INSTESD OF A PARM.  THE PARM    RRS\n*------- QSTRING IS USED AS THE COMMAND LINE IF PRESENT.  ELSE    RRS\n*------- THE COMMAND LINE IS PROMPTED FOR.                        RRS\n*-------                                                          RRS\nCPSTUFF  DC    0H'0'                                              RRS\n         STM   R2,R9,MYSAVE        THIS BECAUSE I'M TOO LAZY TO   RRS\n         ST    R14,MYRET           FIGURE OUT WHICH REGISTERS     RRS\n*                                  JOE IS USING.                  RRS\nCPDOCP   TM    PARMA+6,X'80'       IS PARM FIELD PRESENT?         RRS\n         BNO   CPPRMPT             NO  ==> PROMPT FOR COMMAND     RRS\n         L     R15,PARMA           THE PARM QSTRING               RRS\n         LH    R2,PARMA+4          YES ==> GET LENGTH OF QSTRING  RRS\n         CH    R2,=H'256'          AND FORCE LENGTH TO 256        RRS\n         BNH   CPMOVE                                             RRS\n         LA    R0,MSG15            TOO LONG MSG                   RRS\n         BAL   R14,PUTLINE                                        RRS\n         LA    R2,256                                             RRS\n         L     R15,PARMA           THE PARM QSTRING               RRS\n         B     CPMOVE                                             RRS\nCPPRMPT  DC    0H'0'               PROMPT FOR A COMMAND LINE      RRS\n         LA    R2,MSG28                                           RRS\n         ST    R2,OLD+4                                           RRS\n         TCLEARQ INPUT                                            RRS\n         XC    ECB,ECB                                            RRS\n         PUTGET PARM=PGPB,OUTPUT=(OLD,SINGLE,PROMPT),             RRS  X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                RRS  X\n               TERMGET=(EDIT,WAIT),MF=(E,IOPLA)                   RRS\n         CH    R15,=H'4'           TEST FOR ERROR RETURN          RRS\n         BH    TESTPGRC                                           RRS\n         L     R15,PGPB+12         ADDR OF INPUT LINE             RRS\n         LH    R2,0(R15)           LENGTH OF INPUT LINE           RRS\n         LA    R15,4(R15)          SKIP OVER HEADER               RRS\n*                                                                 RRS\nCPMOVE   LA    R3,4(,R2)           ALLOW FOR RDW, AND             RRS\n         STH   R3,PARMFLDL         SAVE LENGTH OF COMMAND.        RRS\n         BCTR  R2,0                                               RRS\n         LA    R14,PARMFLD+2       OUR COMMAND BUFFER             RRS\n         EX    R2,MOVE             NOW WE ONLY NEED THE OPERAND   RRS\n*                                  POINTER.                       RRS\n*                                                                 RRS\n         SR    R3,R3               SCAN FOR THE FIRST BLANK AFTER RRS\nCPSCAN   CLI   0(R14),C' '         THE FIRST NON-BLANK.           RRS\n         BE    CPBLNK                                             RRS\n*                                                                 RRS\nCPNONBLK B     *+4(R3)                                            RRS\n         LA    R3,4                                               RRS\n         B     CPINCR                                             RRS\n*                                                                 RRS\nCPBLNK   B     *+4(R3)                                            RRS\n         B     CPINCR                                             RRS\n         B     CPGOTCHA                                           RRS\n*                                                                 RRS\nCPINCR   LA    R14,1(R14)          INVALID COMMAND SYNTAX WILL    RRS\n         BCT   R2,CPSCAN           FALL THROUGH.  LET THE COMMAND RRS\n         LA    R14,PARMFLD+3       PROCESSOR DEAL WITH IT!        RRS\n*                                                                 RRS\nCPGOTCHA LA    R15,PARMFLD+1       GET POSITION OF 1ST BLANK      RRS\n         SR    R14,R15             AFTER COMMAND.                 RRS\n         STH   R14,PARMFLDL+2                                     RRS\n*                                  NOW WE CONSTRUNT A CPPL        RRS\n         LA    R1,PARMFLDL         ADDRESS OF PHONEY COMMAND      RRS\n         ST    R1,MYCPPL                                          RRS\n         LA    R1,MYCPPL           PASS ADDR OF FAKE CPPL         RRS\n         LM    R2,R9,MYSAVE                                       RRS\n         L     R14,MYRET                                          RRS\n         BR    R14                                                RRS\n**\n** ERROR RETURN. ATTN, ERROR, ETC. WILL CAUSE CONTROL TO BE PASSED TO\n** THIS SECTION.\n**\nERRORRTN DC    0H'0'\n         IKJRLSA ANSWER\n         IKJRLSA ANSWER1\n         XC    STAKECB,STAKECB\n         STACK PARM=STAK,DELETE=ALL,MF=(E,STAKIOPL)\n         XC    COMPCDE,COMPCDE                               JFS03NOV77\n         MVI   COMPCDE+3,16                                  JFS03NOV77\n**\n** CLEAN UP AND RETURN\n**\nRETURN   DC    0H'0'\n         LH    R2,NODDNS ANY DDNAME TO DECONCATENATE?\n         LTR   R2,R2\n         BZ    RETURN1\n         MVC   CLOSE(CLOSREFL),CLOSREF\n         LA    R1,CLOSE\n         LA    R3,TASKLIB\n         CLOSE ((3)),MF=(E,(1))\n         CH    R2,=H'1'\n         BE    FREEUP ONLY ONE\n         LA    R8,DAIRPB\n         USING DAPB10,R8\n         MVC   DA10CD,=X'0010'\n         XC    DA10FLG(6),DA10FLG\n         MVC   DA10DDN,DDNAMES\n         XC    ECB,ECB\n         LA    R1,DAIRPL\n         LINK  EP=IKJEFD00 LINK TO DAIR\n         LTR   R15,R15\n         BZ    FREEUP\n         LA    R0,MSG18 DECONT. ERROR\n         BAL   R14,PUTLINE\n         DROP  R8\n**\n** FREE THE ALLOCATED DDNAMES\n**\nFREEUP   LR    R3,R2\n         BCTR  R3,R0\n         SLL   R3,3\n         LA    R1,DDNAMES(R3)\n         BAL   R14,FREEDDN\n         BCT   R2,FREEUP\nRETURN1  DC 0H'0'                                            JFS03NOV77\n         L     R2,COMPCDE     RETURN CODE FROM ATTACHED PROG JFS03NOV77\n         TM    FLAGS,ALLRCFLG\n         BO    PUTRCOUT\n         TM    FLAGS,RCFLG\n         BZ    RETURN2\n         LTR   R2,R2\n         BZ    RETURN2\n**                                                           JFS03NOV77\n** CONVERT CONDITION CODE FROM BINARY TO EBCDIC AND          JFS04NOV77\n** OUTPUT THE MESSAGE                                        JFS04NOV77\n**                                                           JFS03NOV77\nPUTRCOUT MVC   WORKBUFF(L'MSG19),MSG19\n         CVD   R2,DWORK\n         UNPK  DWORK(5),DWORK+5(3)                           JFS03NOV77\n         OI    DWORK+4,C'0'                                  JFS03NOV77\n         LA    R15,DWORK-1                                   JFS03NOV77\n         LA    R4,5                                          JFS04NOV77\nPUTRC1   LA    R15,1(R15)                                    JFS03NOV77\n         CLI   0(R15),C'0'  FIND NON ZERO                    JFS03NOV77\n         BNE   PUTRC2                                        JFS03NOV77\n         BCT   R4,PUTRC1                                     JFS03NOV77\n         LA    R4,1  SO AT LEAST 1 0 WILL BE OUTPUT          JFS04NOV77\nPUTRC2   LA    R14,WORKBUFF+L'MSG19                          JFS03NOV77\n         BCTR  R4,R0  -1 FOR MVC                             JFS03NOV77\n         EX    R4,MOVE MOVE IN COMP CODE RETURNED            JFS03NOV77\n         LA    R3,L'MSG19+4+1(R4) +4 FOR HEADER,+1 FOR MVC   JFS03NOV77\n         STH   R3,WORKLEN\n         XC    WORKOFF,WORKOFF\n         LA    R0,WORKLEN\n         BAL   R14,PUTLINE\nRETURN2  DC    0H'0'\n         LA    R0,RENTLEN\n         LR    R1,R13\n         L     R13,SAVE+4\n         FREEMAIN R,LV=(0),A=(1)\n         LR    R15,R2 LOAD RETURN CODE\n         RETURN (14,12),T,RC=(15)\n**\n**\n**\nMOVE     MVC   0(0,R14),0(R15)\n**\n**\n**\n** PUTLINE SECTION\n** ON ENTRY - R0 = ADDR OF MSG, R14 = RETURN ADDR\n**\nPUTLINE  DC    0H'0'\n         ST    R14,PTSVE14\n         XC    ECB,ECB\n         PUTLINE PARM=PTPB,OUTPUT=((R0),TERM,SINGLE,DATA),             X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=(E,IOPLA)\n         LTR   R15,R15 TEST FOR ERRORS, ATTN ETC\n         BZ    PTRTN\n         CH    R15,=H'4' TEST FOR ATTN\n         BE    ERRORRTN GO RETURN WITH RC=16\n         TPUT  PTERROR,PTERRORL PUTLINE ERROR\n         B     ERRORRTN\nPTRTN    L     R14,PTSVE14\n         BR    R14\n**\n** END OF PUTLINE SECTION\n**\n**\n** STAX EXIT\n**\nSTAXEXIT SAVE  (14,12)\n         LR    R2,R13 SAVE SAVE ADDR\n         L     R13,8(R1) LOAD ADDR OF STAXSAVE\n         USING STAXSAVE,R13\n         ST    R2,STAXSAVE+4\n         ST    R13,8(R2)\n         LM    R14,R12,STAXSAVE+12 RESTORE REGS\n         LA    R2,ECB\n         POST  (R2),16  SET RC=16\n         XC    STAKECB,STAKECB\n         STACK PARM=STAK,DELETE=ALL,MF=(E,STAKIOPL)\n         TCLEARQ INPUT\n         TCLEARQ OUTPUT\n         L     R13,STAXSAVE+4\n         RETURN (14,12),RC=0\n         USING SAVE,R13 REESTABLISH BASE REG\n**\n** END OF STAXEXIT\n**\n**\n** OUTPUT -- 'DATA SET ---- ' MSG\n** ON ENTRY - R0 = ADDR OF DSNAME, R1 = ADDR OF LAST PART OF MSG,\n** R14 = RETURN ADDR.\n**\nMSGOUT   DC    0H'0'\n         ST    R14,MSGSVE14\n         STM   R2,R8,MSGSVE28\n         LA    R14,WORKBUFF\n         LA    R3,DATAMSGL\n         LA    R15,DATAMSG\n         BCTR  R3,R0\n         EX    R3,MOVE\n*MOVE    MVC   0(0,R14),0(R15)\n         LA    R14,1(R3,R14)\n         MVI   0(R14),C''''\n         LA    R14,1(R14)\n         TM    FLAGS,QFLG TEST FOR QUOTES\n         BZ    MSGOUT1\n         MVI   0(R14),C''''\n         LA    R14,1(R14)\n         B     MSGOUT2\nMSGOUT1  DS    0H                                             CJP OCT87\n         XR    R3,R3                                          CJP OCT87\n         ICM   R3,B'0011',USERIDL                             CJP OCT87\n         BNP   MSGOUT2                                        CJP OCT87\n         LA    R15,USERID\n         BCTR  R3,R0\n         EX    R3,MOVE ID\n         LA    R14,1(R3,R14)\nMSGOUT2  DC    0H'0'\n         LR    R15,R0\n         LH    R3,0(R15) LOAD LENGTH OF DSNAME\n         LA    R15,2(R15)\n         BCTR  R3,R0\n         EX    R3,MOVE\n         LA    R14,1(R3,R14)\n         TM    FLAGS,QFLG\n         BZ    MSGOUT3\n         MVI   0(R14),C''''\n         LA    R14,1(R14)\nMSGOUT3  MVI   0(R14),C''''\n         LA    R14,1(R14)\n         MVI   0(R14),C' '\n         LA    R14,1(R14)\n         LH    R3,0(R1)\n         LA    R15,2(R1) LOAD ADDR DSNAME\n         BCTR  R3,R0\n         EX    R3,MOVE\n         LA    R14,1(R3,R14)\n         LA    R3,WORKLEN\n         SR    R14,R3\n         STH   R14,WORKLEN\n         XC    WORKOFF,WORKOFF\n         LA    R0,WORKLEN\n         BAL   R14,PUTLINE\n         LM    R2,R8,MSGSVE28\n         L     R14,MSGSVE14\n         BR    R14\n**\n** END OF OUTMSG SECTION\n**\n**\n** FREE DATA SETS BY DDNAME SECTION\n** ON ENTRY - R1 = ADDR OF DDNAME, R14 = RETURN ADDR\n**\nFREEDDN  DC    0H'0'\n         STM   R2,R8,FREESV28\n         ST    R14,FREESV14\n         LA    R8,DAIRPB\n         USING DAPB18,R8\n         MVC   DA18CD,=X'0018'\n         XC    DA18FLG(10),DA18FLG\n         MVC   DA18DDN,0(R1) MOVE IN DDNAME\n         MVI   DA18MNM,C' '\n         MVC   DA18MNM+1(9),DA18MNM\n         MVI   DA18DPS2,B'00001000' KEEP\n         MVI   DA18CTL,B'00010000' UNALLOC PERM\n         MVC   DA18JBNM,BLANKS\n         XC    ECB,ECB\n         LA    R1,DAIRPL\n         LINK  EP=IKJEFD00 LINK TO DAIR\n         LM    R2,R8,FREESV28\n         L     R14,FREESV14\n         BR    R14 RETURN\n         DROP  R8\n**\n** END OF FREE DDNAME SECTION\n**\n         EJECT\n**\n** ADDRS, PARM BLOCKS, ETC.\n**\nATREF    ATTACH SF=L\nATREFL  EQU   *-ATREF\nSTAXREF  STAX  STAXEXIT,MF=L\nSTAXREFL EQU   *-STAXREF\nPGREF    PUTGET MF=L\nPGREFL   EQU   *-PGREF\nPTREF    PUTLINE MF=L\nPTREFL   EQU   *-PTREF\nSTAKREF  STACK MF=L\nSTAKREFL EQU   *-STAKREF\nOPENREF  OPEN  (,),MF=L\nOPENREFL EQU   *-OPENREF\nCLOSREF  CLOSE (,),MF=L\nCLOSREFL EQU   *-CLOSREF\n         PRINT NOGEN\nSKELDCB  DCB   DSORG=PO,MACRF=R  SKELETON DCB\nSKELDCBL EQU   *-SKELDCB\nSPLIST   DC    AL1(3,0,1,78) SHARE SUBPOOL LIST\nBLANKS   DC    CL8' '\nTABLE    DC    C'0123456789ABCDEF' CONVERT TABLE\n         EJECT\n**\n** MESSAGES\n**\nMSG01    DC    Y(MSG01L,0)\n         DC    C'PARSE ERROR'\nMSG01L   EQU   *-MSG01\nMSG02    DC    Y(MSG02L,0)\n         DC    C'INVALID DATA SET NAME'\nMSG02L   EQU   *-MSG02\nMSG03    DC    Y(MSG03L)\n         DC    C'IS AN INVALID TASK LIBRARY NAME'\nMSG03L   EQU   *-MSG03-2\nMSG04    DC    Y(MSG04L,0)\n         DC    C' ENTER TASKLIB DATA SET NAME-'\nMSG04L   EQU   *-MSG04\nMSG05    DC    Y(MSG05L,0)\n         DC    C'DATA SET NAME LENGTH EXCEEDS 44 BYTES'\nMSG05L   EQU   *-MSG05\nMSG06    DC    Y(MSG06L)\n         DC    C'NOT IN CATALOG'\nMSG06L   EQU   *-MSG06-2\nMSG07    DC    C'DYNAMIC ALLOCATION ERROR CODE = '\nMSG08    DC    Y(MSG08L,0)\n         DC    C'NO MORE THAN 10 DATA SET NAMES MAY BE SPECIFIED BY THEX\n                TASKLIB KEYWORD'\nMSG08L   EQU   *-MSG08\nMSG09    DC    Y(MSG09L,0)\n         DC    C' ENTER NULL LINE TO CONTINUE, NON-NULL LINE TO STOP-'\nMSG09L   EQU   *-MSG09\nMSG10    DC    C'CANNOT PROMPT, EITHER YOU ARE EXECUTING A CLIST OR YOUX\n               R PROFILE REQUESTS NO PROMPTING.'\nMSG10L   EQU   *-MSG10\nMSG11    DC    C'INVALID PARAMETERS PASSED TO PUTGET'\nMSG11L   EQU   *-MSG11\nMSG12    DC    C'NOT ENOUGH SPACE FOR PUTGET TO OBTAIN OUTPUT BUFFERS'\nMSG12L   EQU   *-MSG12\nMSG13    DC    Y(MSG13L)\n         DC    C'IS NOT PARTITIONED'\nMSG13L   EQU   *-MSG13-2\nMSG14    DC    Y(MSG14L,0)\n         DC    C'ERROR IN CONCATENATING TASK LIBRARIES'\nMSG14L   EQU   *-MSG14\nMSG15    DC    Y(MSG15L,0)\n         DC    C'PARM FIELD SPECIFIED EXCEEDS 256 BYTES, TRUNCATED'\nMSG15L   EQU   *-MSG15\nMSG16    DC    Y(MSG16L,0)\n         DC    C'NO TASK LIBRARIES'\nMSG16L   EQU   *-MSG16\nMSG17    DC    Y(MSG17L,0)\n         DC    C'TASKLIB DCB OPEN ERROR'\nMSG17L   EQU   *-MSG17\nMSG18    DC    Y(MSG18L,0)\n         DC    C'ERROR IN DECONTENATING TASK LIBRARIES'\nMSG18L   EQU   *-MSG18\nMSG19    DC    C'CONDITION CODE = '                          JFS03NOV77\nMSG20    DC    C'PROGRAM NAME '\nMSG20L   EQU   *-MSG20\nMSG21    DC    C' NOT FOUND IN CONCATENATED '\nMSG21L   EQU   *-MSG21\nMSG22    DC    C' LIBRARIES'\nMSG22L   EQU   *-MSG22\nMSG23    DC    Y(MSG23L,0)\n         DC    C' ENTER PROGRAM NAME, OR NULL LINE TO STOP'\nMSG23L   EQU   *-MSG23\nMSG24    DC    Y(MSG24L,0)\n         DC    C'PROGRAM NAME EXCEEDS 8 CHARACTERS'\nMSG24L   EQU   *-MSG24\nMSG25    DC    Y(MSG25L)\n         DC    C'ALLOCATION ERROR'\nMSG25L   EQU   *-MSG25-2\nMSG26    DC    Y(MSG26L,0)\n         DC    C'MAXIMUM NUMBER OF ALLOCATIONS EXCEEDED'\nMSG26L   EQU   *-MSG26\nMSG27    DC    C'DYNAMIC ALLOCATION RETURN CODE = '\nMSG28    DC    Y(MSG28L,0)                                     RRS\n         DC    C' ENTER COMMAND LINE FOR CP '                  RRS\nMSG28L   EQU   *-MSG28                                         RRS\nDATAMSG  DC    C'DATA SET '\nDATAMSGL EQU   *-DATAMSG\nPTERROR  DC    C'PUTLINE ERROR'\nPTERRORL EQU   *-PTERROR\n         PRINT GEN\n         EJECT\n**\n** DSECT FOR REENTRANCY\n**\nRENTDSCT DSECT\nSAVE     DS    18F\nSTAXSAVE DS    18F\nDWORK    DS    D\nMSGSVE28 DS    7F\nMSGSVE14 DS    F\nPTSVE14  DS    F\nFREESV28 DS    7F\nFREESV14 DS    F\nSAVER15  DS    F\nIOPLA    DS    4F\nSTAKIOPL DS    4F\nPARMADDR DS    F ADDR OF PARM FIELD\nSTAKECB  DS    F\nECB      DS    F\nTCB      DS    F\nPARSEPL  DS    7F PARSE PARM LIST\nDAIRPL   DS    5F DAIR PARM LIST\nDAIRPB   DS    25F DAIR PARM BLOCK\nDA0CDDN  EQU   DAIRPB+12 DA0CDDN NOT DEFINED IN CSECT\nANSWER   DS    F\nANSWER1  DS    F\nOLD      DS    F\nCOMPCDE  DS    F                                             JFS04NOV77\n         DS    A\nEPENTRY  DC    Y(1,58) BLDL\nEPNAME   DS    CL8\n         DS    CL58\nWORKLEN  DS    H\nWORKOFF  DS    H\nWORKBUFF DS    CL120\nATTACH   ATTACH SF=L\nSTAXLIST STAX  STAXEXIT,USADDR=STAXSAVE,MF=L\nPGPB     PUTGET MF=L\nPTPB     PUTLINE MF=L\nSTAK     STACK MF=L\nOPEN     OPEN  (,),MF=L\nCLOSE    CLOSE (,),MF=L\nUSERIDL  DS    H\nUSERID   DS    CL8\nMYCPSWIT DS    F                   4 ==> DOPROG, 0 ==> DOCP       RRS\nMYSAVE   DS    9F                  DOCP REGISTER SAVE             RRS\nMYRET    DS    F                   DOCP RETURN ADDR               RRS\nMYCPPL   DS    4F                  DOCP CPPL FOR TARGET CP        RRS\n         PRINT NOGEN\nTASKLIB  DCB   DSORG=PO,MACRF=R\n         PRINT GEN\nEPNAMEL  DS    H\nCMDLEN   DS    H\nCMDOFF   DS    H\nCMDBUF   DS    CL44\nDSNLEN   DS    H\nDSNAME   DS    CL44\nNODDNS   DS    H\nDDNAMES  DS    10CL8\nPARMFLDL DS    H\nPARMFLD  DS    CL256\nFLAGS    DS    X\nRENTLEN  EQU   *-RENTDSCT\nDOPROG   CSECT\n         PRINT NOGEN\n         EJECT\n**\n** PARAMETER CONTROL LIST FOR PARSE\n**\nPPLPARM  IKJPARM DSECT=PDL\nLOADMOD  IKJIDENT 'LOAD MOD NAME',MAXLNTH=8,FIRST=ALPHA,               X\n               OTHER=ALPHANUM,PROMPT='NAME OF PROGRAM TO BE EXECUTED'\nPARMA    IKJPOSIT QSTRING,HELP='PARM FIELD TO BE PASSED TO PROGRAM'\nTASKEYWD IKJKEYWD\n         IKJNAME 'TASKLIB',SUBFLD=TASKSUBF\n         IKJNAME 'LIB',SUBFLD=TASKSUBF\nRCKEYWD  IKJKEYWD DEFAULT='RC'\n         IKJNAME 'RC'\n         IKJNAME 'NORC'\n         IKJNAME 'ALLRC'\nTASKSUBF IKJSUBF\nTASKDSNA IKJPOSIT DSNAME,LIST,PROMPT='TASKLIB DATA SET NAME'\n         IKJENDP\n**\n** PARSE PARM CONTROL LIST FOR PROMPT OF TASKLIB DATA SET NAME\n**\nDSNPPL   IKJPARM DSECT=DSNPDL\nNEWDSN   IKJPOSIT DSNAME,PROMPT='TASKLIB DATA SET NAME'\n         IKJENDP\n         PRINT NOGEN\n         EJECT\n**\n** MAPPING DSECTS\n**\n         IKJCPPL\n         IKJIOPL\n         IKJUPT\n         IKJPPL\n         IKJDAPL\n         IKJDAP08\n         IKJDAP0C\n         IKJDAP10\n         IKJDAP18\n         DCBD  DSORG=PO\nDOPROG   CSECT\n         LTORG\n         END   DOPROG\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSIEX04": {"ttr": 2310, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\xb4\\x00\\xb4\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 180, "newlines": 180, "modlines": 0, "user": "FILE369"}, "text": "PRC      TITLE 'NCCF EXIT04 FOR LOGGING MSGS TO THE SYSTEM LOG.'\n********************************************************************\n*                                                                  *\n* DSIEX04 -                                                        *\n*   NCCF'S OWN LOGGING FACILITY IS PRETTY USELESS.  THIS EXIT      *\n*   PROVIDES AN ALTERNATIVE.                                       *\n*                                                                  *\n*   WE GET A LOOKSIE AT ALL NCCF TERMINAL INPUTS AND OUTPUTS BEFORE*\n*   NCCF DOES ITS OWN LOGGING.  WE DECIDE WHAT'S IMPORTANT AND WTO *\n*   IT FOR POSTERITY.  NOTE THAT DSILOG TASK MUST BE ACTIVE FOR    *\n*   THIS EXIT TO BE INVOKED.                                       *\n*                                                                  *\n* LOG -                                                            *\n*   11/08/85 - PTW     IMPLEMENTATION                              *\n*   11/26/85 - PTW L02 ALLOW 8 CHARACTERS FOR OPID (AXXNCPPT)      *L02\n*   02/22/88 - PTW L03 REDO                                        *L03\n*                                                                  *\n********************************************************************\n         PRINT NOGEN\n         LCLC   &CSECT\n&CSECT   SETC   'DSIEX04'\n&CSECT   CSECT ,\n         DSICBS DSITIB,DSISWB,DSIUSE,DEFER=THESE\n********************************************************************\n*                                                                  *\n*        I N I T I A L I Z E                                       *\n*                                                                  *\n********************************************************************\n         SAVE  (14,12),,&CSECT-&SYSDATE-&SYSTIME\n         LR    R12,R15                 SET UP BASE REG.\n         USING &CSECT,R12\n         LR    R11,R1                  R11 = A(DSIUSE PARM LIST).\n         USING DSIUSE,R11\n         LR    R2,R13                  USE SUPPLIED SAVE AREA\n         L     R13,USERSWB               IN SWB PASSED TO US.\n         LA    R13,SWBSAVEA-DSISWB(,R13)\n         USING SWBSAVEA,R13\n         ST    R13,8(,R2)              BACK AND FORWARD CHAIN.\n         ST    R2,4(,R13)\n********************************************************************\n*                                                                  *\n*        W T O   S E L E C T E D   T R A F F I C                   *\n*                                                                  *\n********************************************************************\n         L     R10,USERMSG             R10 = A(MSG BUFFER).\n         USING BUFHDR,R10\n         LH    R9,HDRTDISP             R9 = A(MSG TEXT).\n         LA    R9,0(R10,R9)\n         USING MSG,R9\n         CLI   HDRMTYPE,HDRTYPET       TERMINAL INPUT\n         BE    TRYCMD\n         CLI   HDRMTYPE,HDRTYPEC       CMD OR MSG FROM CLIST\n         BNE   ENDCMD\nTRYCMD   DS    0H\n         CLC   =C'IST',MSGTEXT         IST* MESSAGES FROM CLISTS\n         BE    GOTMSG\n         LA    R2,CMDTAB\n         USING CMD,R2\n         SLR   R3,R3\nCMDLOOP  DS    0H\n         CLI   CMDLEN,255\n         BE    ENDCMD\n         IC    R3,CMDLEN\n         BCTR  R3,0\n         EX    R3,CLCCMD\n         BE    GOTMSG\n         LA    R2,L'CMDLEN+1(R3,R2)\n         B     CMDLOOP\nENDCMD   DS    0H\n         CLI   HDRMTYPE,HDRTYPEJ       NCCF GENERATED (IST TRAFFIC)\n         BNE   ENDTYPEJ\n         CLC   =C'IST',MSGTEXT         WE ONLY WANT IST* MESSAGES\n         BE    GOTMSG\n         B     ENDMSG\nENDTYPEJ DS    0H\n         CLI   HDRMTYPE,HDRTYPEQ       VTAM UNSOLICITED\n         BE    GOTMSG\n         CLI   HDRMTYPE,HDRTYPEV       VTAM SOLICITED\n         BNE   ENDMSG                  TAKE NO ACTION FOR OTHER MSGS\nGOTMSG   DS    0H\n         MVC   WTO(WTOLEN),XWTO        INIT WTO LIST.\n         MVC   WTOMSG(L'HDRDOMID),HDRDOMID\n         LA    R2,WTOMSG\nBLOOP1   DS    0H\n         CLI   0(R2),C' '\n         BE    ELOOP1\n         LA    R2,1(,R2)\n         B     BLOOP1\nELOOP1   DS    0H\n         MVI   0(R2),C'/'\n         LA    R2,1(,R2)\n         L     R3,USEROPID             MOVE IN NCCF OPID.\n         MVC   0(8,R2),0(R3)\nBLOOP2   DS    0H\n         CLI   0(R2),C' '\n         BE    ELOOP2\n         LA    R2,1(,R2)\n         B     BLOOP2\nELOOP2   DS    0H\n         MVI   0(R2),C':'\n         LA    R2,2(,R2)\n         LA    R4,WTOMSG+WTOMSGL\n         SLR   R4,R2\n         LH    R3,HDRMLENG             MAKE SURE WE DON'T OVERFLOW\n         CLR   R3,R4\n         BNH   *+6\n         LR    R3,R4\n         BCTR  R3,0\n         EX    R3,MVCWTO               MOVE MSG TEXT TO WTO.\n         WTO   MF=(E,WTO)\nENDMSG   DS    0H\n********************************************************************\n*                                                                  *\n*        R E T U R N                                               *\n*                                                                  *\n********************************************************************\nRETURN   DS    0H\n         LA    R15,USERASIS            SET RC = 0.\n         L     R13,4(,R13)\n         RETURN (14,12),RC=(15)\n         DROP  R10\n********************************************************************\n*                                                                  *\n*        S T A T I C   A R E A S                                   *\n*                                                                  *\n********************************************************************\nCMDTAB   DS    0C\n         DC    AL1(2),C'D '\n         DC    AL1(8),C'DISPLAY '\n         DC    AL1(2),C'F '\n         DC    AL1(7),C'MODIFY '\n         DC    AL1(2),C'V '\n         DC    AL1(5),C'VARY '\n         DC    AL1(255)\nCLCCMD   CLC   CMDNAME(*-*),MSGTEXT\nMVCWTO   MVC   0(*-*,R2),MSGTEXT\nXWTO     WTO   '                                                       X\n                                                                 ',    X\n               ROUTCDE=14,MCSFLAG=HRDCPY,MF=L                       L02\nWTOLEN   EQU   *-XWTO\nWTOMSGL  EQU   *-XWTO-8                LENGTH FOR ACTUAL MSG TEXT.  L02\n         LTORG *\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   A R E A S                                 *\n*                                                                  *\n********************************************************************\n         DSICBS DEFER=INCLUDE,PRINT=NO ,EJECT=YES\n*\nDSISWB   DSECT ,\n         ORG   SWBADATD\n         DS    0F\nWTO      DS    CL(WTOLEN)\nWTOMSG   EQU   WTO+4                   JUMP OVER ROUTE AND DESC CODE\n*\nMSG      DSECT ,\nMSGTEXT  DS    0C\n*\nCMD      DSECT\nCMDLEN   DS    AL1\nCMDNAME  DS    0C\n         PRINT OFF\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         PRINT ON\n         END   &CSECT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DSNPOST": {"ttr": 2314, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\xa3\\x00\\xa3\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 163, "newlines": 163, "modlines": 0, "user": "FILE369"}, "text": "PRC      TITLE 'DSNPOST - ACF2 DSN POST-PROCESSING EXIT.'\n********************************************************************\n*                                                                  *\n* NAME - DSNPOST.                                                  *\n*                                                                  *\n* DESCRIPTION -                                                    *\n*   THIS IS AN ACF2 DSN POST-PROCESSING EXIT. WE USE THIS EXIT     *\n*   TO OVERRIDE A PARTICULAR VIOLATION. WE ATTEMPTED TO LIMIT      *\n*   ACCESS TO THE JES2 SPOOL AND CHECKPOINT DATASETS FROM          *\n*   SDSF VIA ACF2'S PROGRAM PATHING FACILITY, BUT THE LIMITATIONS  *\n*   OF THIS FACILITY ESPECIALLY WITHIN  ISPF DIALOGS BECAME        *\n*   EVIDENT (YOU HAVE TO ACCURATELY DESCRIBE THE TASK AND RB       *\n*   CHAINS FOR EVERY DIALOG THAT WILL BE USED). THUS WE ATTEMPT    *\n*   TO OVERRIDE VIOLATIONS AGAINST THE JES2 DATASETS THAT ARE      *\n*   REALLY NORMAL SDSF ACCESSES.  WE CHECK FOR OPEN FOR INPUT      *\n*   ACCESSES TO FILES HASPCKPT OR HASPAC00, AND THEN CHECK FOR     *\n*   THE PRESENCE OF AN AUTHORIZED LIBRARY VERSION OF ISFJINIT.     *\n*                                                                  *\n* ON ENTRY -                                                       *\n*   R1 = A(ACSXP).                                                 *\n*                                                                  *\n* ON EXIT -                                                        *\n*   R15 = 0  - LEAVE ACF2 DECISION ALONE.                          *\n*   R15 = 12 - ALLOW BUT LOG ACCESS.                               *\n*                                                                  *\n* TO TEST ON THE FLY -                                             *\n*   FROM TSO:                                                      *\n*     ACF                                                          *\n*     SET CONTROL(GSO)                                             *\n*     LIST EXITS SYSID(****)                                       *\n*     CH SYSID(****) EXITS DEL DSNPOST()                           *\n*     END                                                          *\n*   FROM THE CONSOLE:                                              *\n*     F ACF2,REFRESH(EXITS),SYSID(****)                            *\n*     R XX,USERID                                                  *\n*     R XX,PASSWORD (SUPPRESSED)                                   *\n*   OMEGAMON OUT THE LOAD MODULE                                   *\n*   OMEGAMON IN THE NEW LOAD MODULE...                             *\n*   FROM TSO:                                                      *\n*     ACF                                                          *\n*     SET CONTROL(GSO)                                             *\n*     LIST EXITS SYSID(****)                                       *\n*     CH SYSID(****) EXITS REP DSNPOST(DSNPOST)                    *\n*     END                                                          *\n*   FROM THE CONSOLE:                                              *\n*     F ACF2,REFRESH(EXITS),SYSID(****)                            *\n*     R XX,USERID                                                  *\n*     R XX,PASSWORD (SUPPRESSED)                                   *\n*                                                                  *\n* NOTES -                                                          *\n*   WE ARE REENTRANT AND SHOULD BE INSTALLED IN LPALIB.            *\n*   WE NEED ACFMAC, AMODGEN, AND MACLIB TO ASSEMBLE.               *\n*                                                                  *\n* LOG -                                                            *\n*   09/25/88 L01 PTW IMPLEMENTED                                   *L01\n*                                                                  *\n********************************************************************\n         LCLC  &CSECT\n&CSECT   SETC  'DSNPOST'\n&CSECT   CSECT ,\n********************************************************************\n*                                                                  *\n*        I N I T I A L I Z E                                       *\n*                                                                  *\n********************************************************************\n         PRINT NOGEN\n         SAVE  (14,12),,&CSECT-&SYSDATE-&SYSTIME\n         LR    R12,R15\n         USING &CSECT,R12\n********************************************************************\n*                                                                  *\n*        M A I N L I N E                                           *\n*                                                                  *\n********************************************************************\n         LR    R11,R1             R1 = A(ACSXP).\n         USING ACSXP,R11\n         TM    ACUUFLG1,ACUU1ABE  IF ACF2 IS ABENDING,\n         BO    RETURN               GET LOST.\n*        L     R2,ACUUAUCB        R2 = A(AUCB).\n*        USING ACUCB,R2\n*        CLC   =CL8'PTR001',ACULID TESTING ONLY\n*        BNE   RETURN\n*        DROP  R2\nDOSDSF   DS    0H\n         TM    ACUUFLG1,ACUU1VIO  IF NOT A VIOLATION,\n         BZ    RETURN               RETURN.\n         CLI   ACUURRET,ACUURNAR  NO RULE APPLIES?\n         BNE   RETURN               IF A RULE APPLIES, LEAVE.\n         CLI   ACUUFLG3,ACUU3OPN  IF NOT AN OPEN REQUEST,\n         BNE   RETURN               RETURN.\n         CLI   ACUUFLG4,ACUU4INP  IF NOT AN INPUT REQUEST,\n         BNE   RETURN               RETURN.\n         L     R2,ACUUDDNP\n         CLC   =CL8'HASPCKPT',0(R2) DDNAMES USED BY SDSF.\n         BE    TESTRB\n         CLC   =CL8'HASPAC00',0(R2)\n         BE    TESTRB\nRETURN   DS    0H\n         RETURN (14,12),RC=0\nTESTRB   DS    0H\n         L     R2,PSATOLD-PSA     CHECK PR RB OFF TASK.\n         L     R2,TCBRBP-TCB(,R2) R2 = A(RB).\n         USING RBSECT,R2\nRBLOOP   DS    0H\n         TM    RBSTAB1,RBFTP      WE ONLY CARE ABOUT PRB'S.\n         BZ    GOTRB\n         TM    RBSTAB2,RBTCBNXT   IF LAST RB,\n         BO    RETURN               GET LOST.\n         L     R2,RBLINK          LOOP.\n         B     RBLOOP\nGOTRB    DS    0H                 LOOK FOR ISFJINIT.\n         SLR   R3,R3\n         ICM   R3,7,RBCDE1        R3 = A(CDE).\n         BZ    RETURN\n         USING CDENTRY,R3\n         CLC   =CL8'ISFJINIT',CDNAME\n         BNE   RETURN\nGOTCDE   DS    0H\n         TM    CDATTR,CDMIN       NO IDENTIFY'S ALLOWED.\n         BO    RETURN\n         TM    CDATTR2,CDSYSLIB   MAKE SURE AN AUTHORIZED LIB.\n         BZ    RETURN\n         TM    CDATTR,CDREN       AND MODULE IS REENTRANT.\n         BZ    RETURN\n         RETURN (14,12),RC=12\n         DROP  R2,R3\n********************************************************************\n*                                                                  *\n*        R E T U R N                                               *\n*                                                                  *\n********************************************************************\nSRCLEVEL DC    C'                                        '\n         LTORG *\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   A R E A S.                                *\n*                                                                  *\n********************************************************************\n         ACSXP  ,\n         ACUCB  ,\n         IHAPSA ,\n         IKJTCB ,\n         IKJRB  ,\n         IHACDE ,\n         PRINT OFF\nR0       EQU   00\nR1       EQU   01\nR2       EQU   02\nR3       EQU   03\nR4       EQU   04\nR5       EQU   05\nR6       EQU   06\nR7       EQU   07\nR8       EQU   08\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         PRINT ON,NOGEN\n         END   &CSECT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DSNWAIT": {"ttr": 2561, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x01\\n\\x01\\n\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 266, "newlines": 266, "modlines": 0, "user": "FILE369"}, "text": "PRC      TITLE 'DSNWAIT - WTO EXIT TO INFORM TSO USER OF DSN WAIT.'\n********************************************************************\n*                                                                  *\n* NAME - DSNWAIT - WTO EXIT TO INFORM A TSO USER THAT JOB IS       *\n*   WAITING FOR A DATASET.                                         *\n*                                                                  *\n* DESCRIPTION -                                                    *\n*   WE GET CONTROL UPON ISSUANCE OF THE IEF099I WTO.  WE ISSUE     *\n*   AN OPERATOR SEND COMMAND TO INFORM THE TSO USER THAT HIS BATCH *\n*   JOB IS WAITING FOR SOME DATASETS.  THE INTENT HERE IS TO ALERT *\n*   THE PERSON WHO CAN DO SOMETHING ABOUT THE SITUATION, SUCH AS   *\n*   FREE THE DATASETS.  WE FIRST MAKE SURE THAT MSG IEF099I        *\n*   WAS ISSUED, THAT ACF2 IS ALIVE AND WELL, THAT WE'RE A JOB,     *\n*   AND THAT THE RESULTS OF OUR GQSCAN REQUEST FOR SYSDSN CONFLICTS*\n*   IS COOL. THEN WE ISSUE A SEND COMMAND FOR THE FIRST THREE      *\n*   CONFLICTS THAT MEET THE FOLLOWING CONDITIONS:                  *\n*     1). 1 TASK HOLDS THE RESOURCE.                               *\n*     2). 1 TASK WAITS FOR THE RESOURCE.                           *\n*     3). WE ARE THE TASK THE WAITS FOR THE RESOURCE.              *\n*     4). IT IS A TSO USER THAT HOLDS THE RESOURCE.                *\n*     5). THE ACF2 LIDS FOR THE HOLDER AND WAITER ARE THE SAME.    *\n*   WHILE IT IS ACKNOWLEDGED THAT THESE CRITERIA WILL ELIMINATE    *\n*   SOME CANDIDATES FROM CONSIDERATION, IT IS HOPED THAT THIS EXIT *\n*   WILL OTHERWISE PROVE USEFUL FOR MANY SITUATIONS.               *\n*                                                                  *\n* NOTE - WE MUST BE IN AN APF-AUTHORIZED LINKLIST LIBRARY.         *\n*        THE ACF2 SECURITY SYSTEM IS REQUIRED BY THIS EXIT.        *\n*                                                                  *\n* TO USE -                                                         *\n*   SPECIFY IN AN MPFLSTXX MEMBER OF PARMLIB:                      *\n*     IEF099I,SUP(NO),USEREXIT(DSNWAIT)                            *\n*                                                                  *\n* ON ENTRY -                                                       *\n*   R1 = A(CTXT - COMMTASK EXIT PARMLIST).                         *\n*   STD LINKAGE.                                                   *\n*                                                                  *\n* ON EXIT -                                                        *\n*   R15 = NOT USED.                                                *\n*                                                                  *\n* LOG -                                                            *\n*     DATE   WHO LV    CHANGE                                      *\n*   07/XX/86 PTW L01 IMPLEMENTATION                                *\n*   09/20/88 PTW L02 FIX BROKEN-IN-GRS ENIRONMENT BUG.             *\n*                                                                  *L02\n********************************************************************\n         LCLC  &CSECT\n&CSECT   SETC  'DSNWAIT'\n&CSECT   CSECT ,\n&CSECT   AMODE 31\n&CSECT   RMODE ANY\n********************************************************************\n*                                                                  *\n*        I N I T I A L I Z E                                       *\n*                                                                  *\n********************************************************************\n         PRINT NOGEN\n         SAVE  (14,12),,&CSECT-&SYSDATE-&SYSTIME\n         LR    R12,R15            ESTABLISH BASE.\n         USING &CSECT,R12         TELL ASSEMBLER.\n         L     R11,0(,R1)          R11 = A(CTXT - PARMLIST).\n         USING CTXT,R11           TELL ASSEMBLER.\n         L     R10,CTXTTXPJ       R10 = A(CTXTATTR - TEXT).\n         USING CTXTATTR,R10       TELL ASSEMBLER.\n         CLC   =C'IEF099I ',CMSGID ENSURE WE ONLY DEAL WITH MSGIEF099I.\n         BNE   QUIKEXIT\n         GETMAIN RU,LV=DYNLEN,SP=230,LOC=BELOW MUST BE BELOW FOR SVC34.\n         LR    R2,R13             SAVE AREA\n         LR    R13,R1             SAVE AREA\n         USING DYNAMIC,R13        TELL ASSEMBLER.\n         LA    R0,DYNAMIC         ZERO\n         LA    R1,DYNLEN            DYNAMIC\n         LR    R14,R0                 STORAGE.\n         SLR   R15,R15\n         MVCL  R0,R14             DO IT.\n         ST    R2,4(,R13)         BACK CHAIN.\n         ST    R13,8(,R2)         FORWARD CHAIN.\n         MVC   GQSCAN(GQSCANL),XGQSCAN\n********************************************************************\n*                                                                  *\n*        M A I N L I N E   P R O C E S S I N G                     *\n*                                                                  *\n********************************************************************\n         ACFINCVT R2,NONE=NOACF   IF ACF2 NOT ACTIVE, LEAVE.\n         L     R2,ACCASVT-ACCVT(,R2) R2 = A(ACF2 ASVT).\n         ST    R2,ASVTADDR        SAVE THIS ADDRESS.\n         L     R3,PSAAOLD-P       R3 = A(OUR ASCB).\n         LH    R3,ASCBASID-ASCB(,R3) R3 = OUR ASID.\n         STH   R3,OURASID         SAVE OUR ASID.\n         MH    R3,=Y(ASVENLEN)    FIND OUR ACF2 ASVT ENTRY.\n         ALR   R2,R3              R2 = A(OUR ASVT ENTRY).\n         ST    R2,OURASVTE        SAVE THIS ADDRESS.\n         CLC   =C'JOB',ASVJID-ACFASVT(R2) IF WE'RE NOT A JOB,\n         BNE   CANTUSE                      LEAVE.\n         GQSCAN AREA=(WRKRIB,WRKRIBL),RESNAME==CL8'SYSDSN',            X\n               MF=(E,GQSCAN)      FIND ALL WAITED-ON DSN RESOURCES.\n         LTR   R15,R15            IF A BAD RC,\n         BNZ   BADSCAN              LEAVE.\n         LR    R6,R1              R1 = # RIBS RETURNED.\n         LA    R9,WRKRIB          R9 = A(1ST RIB).\n         USING RIB,R9\nDORIB    DS    0H                 LOOP THRU RIBS.\n         CLC   =H'1',RIBNTO+2     IF MORE THAN 1 OWNER OF DSN,\n         BNE   NEXTRIB              FORGET IT.\n         CLC   =H'2',RIBNRIBE+2   IF MORE THAN 1 OWNER + 1 WAITING,\n         BL    NEXTRIB              FORGET IT.\n         LH    R2,RIBVLEN         R2 = L(VARIABLE PORTION OF RIB).\n         LA    R8,RIBEND+(RIBEEND-RIBE)(R2) R8 = A(WAITING RIBE).\n         USING RIBE,R8\n         CLC   OURASID,RIBEASID   IF THE WAITING RIB IS NOT US,\n         BNE   NEXTRIB              FORGET IT.\n         L     R3,CVTPTR          R3 = A(CVT).                      L02\n         CLC   RIBESYSN,CVTSNAME-CVT(R3) MAKE SURE SYSNAMES         L02\n         BNE   NEXTRIB            MATCH.                            L02\n         LH    R2,RIBVLEN         R2 = L(VARIABLE PORTION OF RIB).\n         LA    R8,RIBEND(R2)      R8 = A(OWNING RIBE).\n         L     R3,CVTPTR          R3 = A(CVT).                      L02\n         CLC   RIBESYSN,CVTSNAME-CVT(R3) MAKE SURE OWNER            L02\n         BNE   NEXTRIB            IS RUNNING ON OUR SYSTEM.         L02\n         L     R2,ASVTADDR        R2 = A(ACF2 ASVT).\n         LH    R3,RIBEASID        R3 = OWNING ASID.\n         STH   R3,TSOASID         SAVE OWING ASID.\n         MH    R3,=Y(ASVENLEN)    FIND OWNING ACF2 ASVT ENTRY.\n         ALR   R2,R3              R2 = A(OWING ASVT ENTRY).\n         ST    R2,TSOASVTE        SAVE THIS ADDRESS.\n         CLC   =C'TSU',ASVJID-ACFASVT(R2) IF OWNER NOT A TSO SESSION,\n         BNE   NEXTRIB              FORGET IT.\n         L     R3,OURASVTE        R3 = A(OUR ASVT ENTRY).\n         CLC   ASVLID-ACFASVT(,R2),ASVLID-ACFASVT(R3) IF ACF2 LIDS \u00ac=,\n         BNE   NEXTRIB            FORGET IT.\n         XC    MGCR(MGCRTEXT-MGCR),MGCR PREPARE TO ISSUE SEND COMMAND.\n         MVI   MMSG,C' '          BLANK MSG AREA.\n         MVC   MMSG+1(MMSGL-1),MMSG\n         MVC   MMSGT1(L'MSGT1),MSGT1 \"SEND '\" TEXT.\n         MVC   MMSGT1+L'MSGT1(L'CMSGT1),CMSGT1 FIXED TEXT FROM IEF099I.\n         LA    R7,RIBEND          R7 = A(DSN).\n         USING RIBVAR,R7\n         SLR   R3,R3\n         IC    R3,RIBRNMLN        R3 = L=DSN.\n         BCTR  R3,0\n         EX    R3,MOVEDSN         MOVE DSN TO MSG AREA.\n         LA    R2,MMSGDSN+1(R3)   BUMP CURSOR.\n         MVC   0(L'MSGT2,R2),MSGT2 \"',USER=(\" TEXT.\n         LA    R2,L'MSGT2(,R2)    BUMP CURSOR.\n         MVC   0(L'RIBEJBNM,R2),RIBEJBNM  MOVE TARGET TSO USERID.\n         LA    R3,L'RIBEJBNM\nFINDEND  CLI   0(R2),C' '         SCAN TO THE NEXT BLANK.\n         BE    ENDTEXT\n         LA    R2,1(,R2)\n         BCT   R3,FINDEND\nENDTEXT  MVC   0(L'MSGT3,R2),MSGT3  \"),NOW\" TEXT.\n         LA    R2,L'MSGT3(,R2)    CALCULATE LENGTH OF COMMAND.\n         LA    R3,MGCR\n         SLR   R2,R3\n         STC   R2,MGCRLGTH        STORE LENGTH.\n         SR    R0,R0              ZERO 0.\n         MGCR  MGCR               ISSUE SVC 34.\n         LH    R2,SEND#           ALLOW AT MOST 3 SEND COMMANDS.\n         AH    R2,=H'1'\n         CH    R2,=H'3'\n         BNL   ENOUGH\n         STH   R2,SEND#\nNEXTRIB  DS    0H\n         LH    R2,RIBVLEN         CALCUTE THE ADDRESS OF THE\n         L     R3,RIBNRIBE          NEXT RIB.\n         MH    R3,=Y(RIBEEND-RIBE)\n         LA    R2,RIBEND-RIB(R3,R2)\n         LA    R9,0(R2,R9)        R9 = A(NEXT RIB).\n         BCT   R6,DORIB           LOOP UNTIL DONE.\n********************************************************************\n*                                                                  *\n*        R E T U R N                                               *\n*                                                                  *\n********************************************************************\nRETURN   DS    0H\n         L     R2,RC                  R2 = RC.\n         LR    R1,R13              PREPARE\n         L     R13,4(,R13)         FOR FREEMAIN.\n         FREEMAIN RU,LV=DYNLEN,A=(1),SP=230\n         LR    R15,R2              AND RETURN\n         RETURN (14,12),RC=(15)      WITH R15 = RC.\nQUIKEXIT DS    0H\n         RETURN (14,12),RC=4         WITH R15 = 4.\n********************************************************************\n*                                                                  *\n*        E R R O R S                                               *\n*                                                                  *\n********************************************************************\nBADSCAN  DS    0H                 ERROR FROM GQSCAN SERVICE.\nNOACF    DS    0H                 ACF2 NOT UP.\n         MVC   RC,=F'12'\n         B     RETURN\nCANTUSE  DS    0H                 CATCH ALL RETURN.\n         MVC   RC,=F'8'\n         B     RETURN\nENOUGH   DS    0H                 MAX SEND COMMANDS ISSUED.\n         MVC   RC,=F'4'\n         B     RETURN\n********************************************************************\n*                                                                  *\n*        S T A T I C   A R E A                                     *\n*                                                                  *\n********************************************************************\nMOVEDSN  MVC   MMSGDSN(*-*),RIBRNAME\nXGQSCAN  GQSCAN ,SCOPE=ALL,WAITCNT=1,MF=L                           L02\nGQSCANL  EQU   *-XGQSCAN\nMSGT1    DC    C'SEND '''\nMSGT2    DC    C''',USER=('\nMSGT3    DC    C'),NOW'\n         LTORG *\n         DROP  R11,R10,R9,R8,R7\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   A R E A S                                 *\n*                                                                  *\n********************************************************************\nDYNAMIC  DSECT\nSAVE     DS    18F .\nRC       DS    F                  RETURN CODE.\nASVTADDR DS    A                  A(ACF2 ASVT).\nOURASVTE DS    A                  A(OUR ASVT ENTRY).\nTSOASVTE DS    A                  A(TSO ASVT ENTRY).\nOURASID  DS    H                  OUR ASID.\nTSOASID  DS    H                  TSO ASID.\nSEND#    DS    H                  COUNTER FOR # COMMANDS ISSUED.\nGQSCAN   DS    0F,CL(GQSCANL)\n         IEZMGCR DSECT=NO\nMGCR     EQU   MGCRPL\n         ORG   MGCRTEXT\nMMSG     DS    0C\nMMSGT1   DS    CL40  \"SEND 'JOB XXXXXXXX WAITING FOR DATA SET \"\nMMSGDSN  DS    CL45  DSN\nMMSGT2   DS    CL21  \"',USER=(UUUUUUUU),NOW\"\nMMSGL    EQU   *-MMSG\n         ORG   ,\nWRKRIB   DS    0F,4CL256          RETURN RIBS.\nWRKRIBL  EQU  *-WRKRIB\nDYNLEN   EQU   *-DYNAMIC          LENGTH OF WRKAREA.\n         IEZVX100\nCMSGID   EQU   CTXTTMSG,8         \"IEF099I \"\nCMSGT1   EQU   CTXTTMSG+8,33      \"JOB XXXXXXXX WAITING...\"\n         ISGRIB\n         ACCVT ,\n         ACFASVT ,\n         IHAPSA\nP        EQU   PSA\n         CVT   DSECT=YES                                            L02\n         IHAASCB\n         PRINT OFF\nR0       EQU   00\nR1       EQU   01\nR2       EQU   02\nR3       EQU   03\nR4       EQU   04\nR5       EQU   05\nR6       EQU   06\nR7       EQU   07\nR8       EQU   08\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11                 A(PLIST).\nR12      EQU   12                 PROGRAM BASE.\nR13      EQU   13                 A(SAVE AREA).\nR14      EQU   14\nR15      EQU   15\n         PRINT ON\n         END   &CSECT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSPACE": {"ttr": 2566, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01A\\x00\\x00\\x00\\x88#o\\x00\\x99\\x05O\\x07\\x05\\x02.\\x01\\xca\\x00\\x00\\xe3\\xe2\\xc3\\xd7\\xf0\\xf0\\xf4@@@'", "ispf": {"version": "01.65", "flags": 0, "createdate": "1988-08-23T00:00:00", "modifydate": "1999-02-23T07:05:00", "lines": 558, "newlines": 458, "modlines": 0, "user": "TSCP004"}, "text": "PRC      TITLE 'DSPACE - DISPLAY DASD SPACE INFORMATION.'\n********************************************************************\n*                                                                  *\n* NAME - DSPACE.                                                   *\n*                                                                  *\n* DESCRIPTION - TSO COMMAND TO DISPLAY AVAILABLE SPACE ON DIRECT   *\n*               ACCESS VOLUME(S).                                  *\n*                                                                  *\n* TO USE - ENTER: DSPACE VVVVVV   ,VVVVVV = A VOLSER (1-6 CHARS)   *\n*                 DSPACE UUUU     ,UUUU = A UCB ADDRESS (4 CHARS)  *\n*                 DSPACE NNNNNNNN ,NNNNNNNN = A UNITNAME (1-8 CHARS*\n*                 DSPACE STORAGE  ,FOR ALL STORAGE VOLUMES         *\n*                 DSPACE PUBLIC   ,FOR ALL PUBLIC VOLUMES          *\n*                 DSPACE PRIVATE  ,FOR ALL PRIVATE VOLUMES         *\n*                 DSPACE ONLINE   ,FOR ALL ONLINE VOLUMES (DEFAULT)*\n*                                                                  *\n*   NOTE: DSPACE ACCEPTS A MASK: DSPACE RES* OR DSPACE 3C*         *\n*         DSPACE ALSO ACCEPTS A LIST: DSPACE (VVVVVV,UUUU,...)     *\n*                                                                  *\n* LOG -                                                            *\n*   12/17/86 L01 PTW IMPLEMENTED                                   *L01\n*   05/16/95 DAV ADD 3390 TO DEVTABLE.                             *\n*   01/14/99 DAV CHANGE TO WORK WITH NEW I/O GEN, USING UCBSCAN.   *\n*                ALSO ADD 3390 DYNAMIC TO DEVTABLE.                *\n*   01/27/99 DAV CHANGE TO WORK 4 DIGIT ADDRESS AND CORRECT IXVTOC *\n*                NOT SHOWING.                                      *\n*   02/22/99 DAV CHANGE TO LSPACE MACRO (FROM THE SVC DIRECT).     *\n*                                                                  *\n********************************************************************\n         EJECT\n********************************************************************\n*                                                                  *\n*        I N I T I A L I Z E                                       *\n*                                                                  *\n********************************************************************\n         LCLC  &CSECT\n&CSECT   SETC  'DSPACE'\n&CSECT   CSECT\n&CSECT   AMODE 31\n&CSECT   RMODE ANY\nR0       EQU   00\nR1       EQU   01\nR2       EQU   02                 WORK\nR3       EQU   03                 WORK\nR4       EQU   04                 WORK\nR5       EQU   05                 WORK\nR6       EQU   06                 WORK\nR7       EQU   07                 UCB ADR\nR8       EQU   08                 LSPACE PARM ADR\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12                 PROGRAM BASE.\nR13      EQU   13                 A(SAVE AREA).\nR14      EQU   14\nR15      EQU   15\n*\nDOSAVE   EQU   *\n         SAVE  (14,12),,&CSECT--&SYSDATE--&SYSTIME\n         LR    R12,R15            ESTABLISH BASE.\n         USING &CSECT,R12         TELL ASSEMBLER.\n         GETMAIN RU,LV=DYNLEN     DYNAMIC AREA.\n         EJECT\nDOPTRS   EQU   *\n         LR    R2,R13             SAVE AREA\n         LR    R13,R1               SWITCH.\n         USING DYNAMIC,R13        TELL ASSEMBLER.\n         LR    R0,R1\n         LA    R1,DYNLEN\n         LA    R14,R0\n         SLR   R15,R15\n         MVCL  R0,R14             ZERO STORAGE.\n         ST    R2,4(,R13)         BACK CHAIN.\n         ST    R13,8(,R2)         FORWARD CHAIN.\n         XC    RC,RC\n         L     R2,4(,R13)\n         L     R2,24(,R2)         R2 = A(PARMLIST).\n         USING CPPL,R2            CONSTRUCT TSO CONTROL BLOCKS.\n         MVC   MYIOPB(IOPBLEN),XIOPB INITIALIZE DYNAMIC IOPB.\n         LA    R3,MYPPL           BUILD PPL.\n         USING PPL,R3\n         MVC   PPLUPT,CPPLUPT\n         MVC   PPLECT,CPPLECT\n         LA    R4,ECB\n         ST    R4,PPLECB\n         MVC   PPLPCL,=A(MYPCL)\n         LA    R4,MYANS\n         ST    R4,PPLANS\n         MVC   PPLCBUF,CPPLCBUF\n         XC    PPLUWA,PPLUWA\n         DROP  R3\n         LA    R3,MYIOPL          BUILD IOPL.\n         USING IOPL,R3\n         MVC   IOPLUPT,CPPLUPT\n         MVC   IOPLECT,CPPLECT\n         LA    R4,ECB\n         ST    R4,IOPLECB\n         LA    R4,MYIOPB\n         ST    R4,IOPLIOPB\n         DROP  R2,R3\n         MVC   OUTAREA(4),=AL2(OUTAREAL,0) INITIALIZE PUTLINE MSG.\n         CALLTSSR EP=IKJPARS,MF=(E,MYPPL) CALL PARSE.\n         LTR   R15,R15\n         BNZ   BADPARS\n         L     R2,MYANS           R2 = A(PDL FROM PARSE)\n         USING MYPDL,R2\n         LA    R2,VOLUMES         R2 = A(VOLUME POSITIONAL PDE).\n         DROP  R2\n         XC    COUNT,COUNT\n         XC    SCANWORK,SCANWORK  CLEAR SCANWORK AREA\n         XC    UCBCOPY,UCBCOPY    CLEAR UCBCOPY  AREA\n         XC    UCBEXTN,UCBEXTN    CLEAR UCBEXTN  AREA\n         MVI   DCETEXT,X'00'      START CLEAR OF DCE AREA\n         MVC   DCETEXT+1(L'DCETEXT-1),DCETEXT\n         LA    R8,LSPCPRMW        -> R8 TO LSPACE PARM WORKAREA       |\n         USING LSPCPRM,R8         R8 = A(LSPACE PARM WORKAREA)        |\n         LA    R0,LSPCMSG         GET ADR TO LSPCMSG                  |\n         ST    R0,LSPCMSGA        STORE IT IN LSPCMSGA                |\n         EJECT\n********************************************************************\n*                                                                  *\n*        G E T   1 S T   T H I N G   I N   L I S T                 *\n*                                                                  *\n********************************************************************\nLOOPPDE  DS    0H\n         MVI   TYPE,0\n         MVI   TRY,0\n         MVI   ATTR,0\n         ST    R2,PDEADDR         SAVE A(PDE).\n         MVI   VALUE,C' '\n         MVC   VALUE+1(L'VALUE-1),VALUE\n         L     R3,0(,R2)          R3 = A(PDE).\n         LH    R4,4(,R2)          R5 = L'VALUE.\n         STH   R4,VALUELEN\n         BCTR  R4,R0\n         EX    R4,MVCVALUE\n         CLC   =C'STORAGE ',VALUE CHECK FOR STORAGE.\n         BNE   NOTSTOR\n         OI    TYPE,STORAGE\n         MVI   ATTR,UCBBSTR\n         B     DOSCAN\nNOTSTOR  DS    0H\n         CLC   =C'PUBLIC ',VALUE CHECK FOR PUBLIC.\n         BNE   NOTPUB\n         OI    TYPE,PUBLIC\n         MVI   ATTR,UCBBPUB\n         B     DOSCAN\nNOTPUB   DS    0H\n         CLC   =C'PRIVATE ',VALUE CHECK FOR PRIVATE.\n         BNE   NOTPRIV\n         OI    TYPE,PRIVATE\n         MVI   ATTR,UCBBPRV\n         B     DOSCAN\nNOTPRIV  DS    0H\n         CLC   =C'ONLINE ',VALUE CHECK FOR ONLINE.\n         BNE   ENDONL\n         OI    TYPE,ONLINE\n         B     DOSCAN\nENDONL   DS    0H\n         CLC   VALUELEN,=H'6'     IF L'VALUE > 6, CAN ONLY BE UNITNAME.\n         BH    TRYUNIT\n         CLC   VALUELEN,=H'2'     IF L'VALUE < 2, TRY UNITNAME.\n         BL    TRYUNIT\n         OI    TRY,VOLUME         SPECIFY TRY FOR VOLUME.\n         LH    R4,VALUELEN\n         BCTR  R4,0\n         LA    R5,VALUE(R4)\n         CLI   0(R5),C'*'\n         BNE   NOTMASK\n         OI    TRY,MASK\n         STH   R4,VALUELEN\n         EJECT\nNOTMASK  DS    0H\n         CLC   VALUELEN,=H'4'     IF L'VALUE > 4, CAN'T BE UCB.       |\n         BH    DOSCAN\n         OI    TRY,UCB\n         B     DOSCAN\n         SPACE 3\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        G E T   N E X T   T H I N G   I N   L I S T               *\n*                                                                  *\n********************************************************************\nNEXTPDE  DS    0H\n         XC    SCANWORK,SCANWORK  CLEAR SCANWORK AREA\n         XC    UCBCOPY,UCBCOPY    CLEAR UCBCOPY  AREA\n         XC    UCBEXTN,UCBEXTN    CLEAR UCBEXTN  AREA\n         MVI   DCETEXT,X'00'      START CLEAR OF DCE AREA\n         MVC   DCETEXT+1(L'DCETEXT-1),DCETEXT\n         L     R2,PDEADDR         GET NEXT ENTRY IS PARSE LIST.\n         L     R2,8(,R2)\n         CL    R2,=X'FF000000'    IF NO MORE, RETURN.\n         BNE   LOOPPDE\n         EJECT\n********************************************************************\n*                                                                  *\n*        R E T U R N                                               *\n*                                                                  *\n********************************************************************\nRETURN   DS    0H\n         IKJRLSA MYANS\n         L     R2,RC                  R2 = RC.\n         LR    R1,R13              PREPARE\n         L     R13,4(,R13)           FOR FREEMAIN.\n         FREEMAIN RU,LV=DYNLEN,A=(1)\n         LR    R15,R2              AND RETURN\n         RETURN (14,12),RC=(15)      WITH R15 = RC.\n         EJECT\n********************************************************************\n*                                                                  *\n*        U C B   S C A N                                           *\n*                                                                  *\n********************************************************************\nDOSCAN   DS    0H\n         UCBSCAN COPY,                                                 C\n               WORKAREA=SCANWORK,                                      C\n               UCBAREA=UCBCOPY,                                        C\n               CMXTAREA=UCBEXTN,                                       C\n               DCEAREA=DCETEXT,                                        C\n               DCELEN=DCELENTH,                                        C\n               DYNAMIC=YES,                                            C\n               RANGE=ALL,                                              C\n               DEVCLASS=DASD,                                          C\n               DEVNCHAR=DEVNAME,                                       C\n               RETCODE=RETCODE,                                        C\n               RSNCODE=RSNCODE,                                        C\n               MF=(E,UCBSCANL)\n         LTR   R15,R15            CHECK THE RETURN CODE.\n         BNZ   ENDSCAN            IF NOT 0, ASSUME NO MORE TO SCAN\nDOSCAN1  DS    0H\n         LA    R3,UCBCOPY         GET ADR OF UCB\n         LA    R7,UCBCOPY         GET ADR OF UCB\n         USING UCBDSECT,R7        TELL ASM\n         TM    TRY,VOLUME         IF WE ARE TO TRY FOR VOLUME,\n         BZ    NOTVOL\n         LA    R4,L'UCBVOLI-1     ASSUME FULL LENGTH COMPARE...\n         TM    TRY,MASK             UNLESS A MASK WAS SPECIFIED.\n         BZ    *+10\n         LH    R4,VALUELEN\n         BCTR  R4,0\n         EX    R4,CLCVOLI\n         BNE   NOTVOL\n         OI    TYPE,VOLUME\n         B     SCANSPAC\nNOTVOL   DS    0H\n         TM    TRY,UCB            IF WE ARE TO TRY FOR UCB,\n         BZ    NOTUCB\n         LA    R4,L'DEVNAME-1     ASSUME FULL LENGTH COMPARE...       |\n         TM    TRY,MASK             UNLESS A MASK WAS SPECIFIED.\n         BZ    *+10\n         LH    R4,VALUELEN\n         BCTR  R4,0\n         EX    R4,CLCNAME\n         BNE   NOTUCB\n         OI    TYPE,UCB\n         B     SCANSPAC\nNOTUCB   DS    0H\n         TM    TYPE,STORAGE+PUBLIC+PRIVATE\n         BZ    NOTATTR            IF ATTRIBUTE COMPARE, DO IT.\n         SLR   R4,R4\n         IC    R4,ATTR\n         EX    R4,TMATTR\n         BO    SCANSPAC\n         B     DOSCAN\nNOTATTR  DS    0H\n         TM    TYPE,ONLINE        IF NO ONLINE REQUEST,\n         BZ    DOSCAN               GET NEXT UCB.\nSCANSPAC DS    0H\n         BAL   R10,DOLSPACE       GO DO LSPACE.\n         TM    TYPE,VOLUME+UCB    IF WE HIT ON SINGLE REQUEST,\n         BZ    DOSCAN               ALL DONE.\n         TM    TRY,MASK           UNLESS IT WAS A MASK REQUEST.\n         BO    DOSCAN\nENDSCAN  DS    0H\n         CLI   TYPE,0             IF WE HAVE A HIT,\n         BNE   NEXTPDE              GO DO NEXT.\n         EJECT\n********************************************************************\n*                                                                  *\n*        U N I T   R E Q U E S T                                   *\n*                                                                  *\n********************************************************************\nTRYUNIT  DS    0H\n         MVC   UNITNAME,VALUE     INIT LISTS FO IEFEB4UV.\n         XC    UNITLIST,UNITLIST\n         XC    UNITATTR,UNITATTR\n         MVI   UNITFLG,X'10'\n         LINK  EP=IEFEB4UV,PARAM=(UNITTAB,UNITFLG),MF=(E,UNITPARM)\n         LTR   R15,R15            IF RC \u00ac= 0,\n         BNZ   ENDUNIT              ASSUME NOT A UNITNAME.\n         OI    TYPE,UNIT\n         L     R2,UNITLIST\n         L     R4,4(,R2)          R4 = # UCBS IN RETURNED LIST.\n         L     R3,8(,R2)          R3 = A(UCB).\n         LA    R2,8(,R2)          R2 = A(THIS UCB ENTRY IN TABLE).\nUNITLOOP DS    0H\n         BAL   R10,DOLSPACE\n         LA    R2,4(,R2)          R2 = A(NEXT UCB ENTRY IN TABLE).\n         L     R3,0(,R2)          R3 = A(NEXT UCB).\n         BCT   R4,UNITLOOP        LOOP.\n         L     R2,UNITLIST\n         L     R0,0(,R2)\n         FREEMAIN R,LV=(0),A=(R2) FREEMAIN IEFEB4UV STORAGE.\n         B     NEXTPDE\nENDUNIT  DS    0H\n         B     BADREQ             CAN'T IDENTIFY REQUEST.\n         EJECT\n********************************************************************\n*        D O   L S P A C E   S V C ( 7 8 )                         *\n********************************************************************\nDOLSPACE DS    0H\n         LH    R0,COUNT           PUT OUT HEADER FOR 1ST REQ ONLY.\n         AH    R0,=H'1'\n         STH   R0,COUNT\n         CH    R0,=H'1'\n         BNE   NOHDR\n         PUTLINE OUTPUT=(OUTHDR,SINGLE,DATA),MF=(E,MYIOPL)\nNOHDR    DS    0H\n         MVI   OUTAREA+4,C' '     FORMAT OUTPUT LINE.\n         MVC   OUTAREA+5(OUTAREAL-5),OUTAREA+4\n         MVC   OUTUCB,DEVNAME                                         |\n         TM    UCBSTAT,UCBONLI    IF UCB NOT ONLINE,\n         BZ    BADONL               GO TO ERROR ROUTINE.\n         TM    UCBSTAT,UCBCHGS+UCBUNLD NO FUNNY STATUS.\n         BNZ   BADUCB\n         MVC   OUTVOL,UCBVOLI\nGETDEVT  EQU   *\n         MVC   OUTDEVT(5),=C'???? ' MOVE IN SKELETON\n         LA    R6,DEVTABLE         POINT TO OUR TABLE\nDEVLOOP  EQU   *\n         CLI   0(R6),X'FF'         ARE WE AT END OF TABLE?\n         BE    ENDOTAB             IF SO, WE WILL KNOW\n         CLC   0(4,R6),UCBTYP      DO WE MATCH?\n         BE    GOTDEVT\n         A     R6,=F'09'           MOVE ALONG IN TABLE\n         B     DEVLOOP             LOOP BACK\nGOTDEVT  EQU   *\n         MVC   OUTDEVT(5),4(R6)    MOVE IN ITS NAME\nENDOTAB  EQU   *\n         TM    UCBSTAB,UCBBPRV     CHK IF MOUNTED PRIV\n         BO    PRTPRIV\n         TM    UCBSTAB,UCBBPUB     CHK IF MOUNTED PUB\n         BO    PRTPUB\n         TM    UCBSTAB,UCBBSTR     CHK IF MOUNTED STRG\n         BO    PRTSTRG\n         MVC   OUTATTR,=C'????'    NOT MOUNTED NORMALLY\n         B     CONTPRT\nPRTPRIV  MVC   OUTATTR,=C'PRIV'    IS MOUNTED PRIVATE\n         B     CONTPRT\nPRTPUB   MVC   OUTATTR,=C'PUB '    IS MOUNTED PUBLIC\n         B     CONTPRT\nPRTSTRG  MVC   OUTATTR,=C'STRG'    IS MOUNTED STORAGE\n*\nCONTPRT  EQU   *\n*        LR    R0,R7              R0 = A(UCB).\n*        LA    R1,LSPCMSG         R1 = A(MSG AREA).\n*        SVC   78                 DO LSPACE.\n         MVI   LSPCPRMW,X'00'     START CLEAR OF LSPACE PARM WORKAREA |\n         MVC   LSPCPRMW+1(L'LSPCPRMW-1),LSPCPRMW    FINISH CLEAR      |\n         MVC   LSPCPRMW,LSPCPRMT  COPY PARM TEMPLATE TO WORKAREA      |\nLSPCEXEC LSPACE EXPMSG=LSPCMSG,                                        C\n               F4DSCB=0,                                               C\n               SMF=NONE,                                               C\n               UCB=(R7),                                               C\n               MF=(E,LSPCPRM)\n         LTR   R15,R15            IF BAD RC,\n         BNZ   BADSVC78             GO TO ERROR ROUTINE.\n         MVC   OUTSPACE(L'LSPCMSG),LSPCMSG\n         CVAFTST UCB=(R7)         CHECK FOR INDEXED VTOC.\n         CH    R15,=H'8'          IF RC = 8, WE'RE INDEXED.\n         BNE   CONTPRT1\n         MVI   OUTINDEX,C'I'\nCONTPRT1 EQU   *\n         PUTLINE OUTPUT=(OUTAREA,SINGLE,DATA),MF=(E,MYIOPL)\n         BR    R10\n         EJECT\n********************************************************************\n*        E R R O R S                                               *\n********************************************************************\nBADPARS  DS    0H                 BAD PARSE.\n         MVC   RC,=F'12'\n         LA    R15,MSGPARS\n         LA    R10,RETURN\n         B     DOMSG\nBADREQ   DS    0H                 CAN'T IDENTIFY REQUEST.\n         MVC   RC,=F'8'\n         LA    R15,MSGREQ\n         LA    R10,NEXTPDE\n         B     DOMSG\nBADONL   DS    0H                 UCB NOT ONLINE.\n         TM    TYPE,STORAGE+PUBLIC+PRIVATE+ONLINE\n         BNZ   RETMSG             FOR ABOVE REQUESTS, IGNORE ERROR.\n         MVC   OUTSPACE(L'MSGONL),MSGONL\n         LA    R15,OUTAREA\n         B     DOMSG\nBADUCB   DS    0H                 FUNNY STATUS.\n         TM    TYPE,STORAGE+PUBLIC+PRIVATE+ONLINE\n         BNZ   RETMSG             FOR ABOVE REQUESTS, IGNORE ERROR.\n         MVC   OUTSPACE(L'MSGUCB),MSGUCB\n         LA    R15,OUTAREA\n         B     DOMSG\nBADSVC78 DS    0H                 BAD LSAPCE RC.\n         TM    TYPE,STORAGE+PUBLIC+PRIVATE+ONLINE\n         BNZ   RETMSG             FOR ABOVE REQUESTS, IGNORE ERROR.\n         MVC   OUTSPACE(L'MSGSVC78),MSGSVC78\n         LA    R10,NEXTPDE\n         B     DOMSG\nDOMSG    DS    0H\n         PUTLINE OUTPUT=((R15),SINGLE,DATA),MF=(E,MYIOPL)\nRETMSG   DS    0H\n         BR    R10\n         EJECT\n********************************************************************\n*                                                                  *\n*        S T A T I C   A R E A                                     *\n*                                                                  *\n********************************************************************\nMVCVALUE MVC   VALUE(*-*),0(R3)\nCLCVOLI  CLC   UCBVOLI(*-*),VALUE        COMPARE VOLSER.\nCLCNAME  CLC   DEVNAME(*-*),VALUE        COMPARE EBCDIC UCB NAME.     |\nTMATTR   TM    UCBSTAB,*-*\n*\n         DS    0F\nDCELENTH DC    AL2(L'DCETEXT)\nMSGONL   DC    C'OFFLINE'\nMSGUCB   DC    C'SPACE COULD NOT BE DETERMINED.'\nMSGSVC78 DC    C'LSPACE SVC ERROR, IGNORED.'\nMSGPARS  DC    AL2(MSGPARSL,0)\n         DC    C'TSO PARSE ERROR, PROGRAM TERMINATED.'\nMSGPARSL EQU   *-MSGPARS\nMSGREQ   DC    AL2(MSGREQL,0)\n         DC    C'VOLSER, UCB, OR UNIT NOT FOUND, IGNORED.'\nMSGREQL  EQU   *-MSGREQ\n*\nXIOPB    PUTLINE MF=L\nIOPBLEN  EQU   *-XIOPB\nMYPCL    IKJPARM DSECT=MYPDL\n*\nVOLUMES  IKJIDENT  VOLUME,LIST,FIRST=ALPHANUM,OTHER=ALPHANUM,CHAR,     X\n               MAXLNTH=8,DEFAULT='ONLINE'\n*\n         IKJENDP\n*\nOUTHDR   DC    AL2(OUTHDRL,0)\n         DC    C'VOL    '\n         DC    C'  '\n         DC    C'UNIT '\n         DC    C'DEVT  '\n         DC    C'ATTR '\n         DC    C'      '\n         DC    C'  #CYL '                                             |\n         DC    C'  #TRK '                                             |\n         DC    C'  #EXT '                                             |\n         DC    C' CYL-C '                                             |\n         DC    C' TRK-C '                                             |\nOUTHDRL  EQU   *-OUTHDR\n*\n         LTORG *\n*\nSRCLEVEL DC    C'                                        '\n*\n* DEVICE TABLE\n*\nDEVTABLE EQU   *\n         DC    X'3010200E',C'3380 '\n         DC    X'3010200F',C'3390 '    3390 \"NORMAL\"\n         DC    X'3030200F',C'3390 '    3390 DYNAMIC\n         DC    X'FFFFFFFF'             END OF TABLE\n*\nLSPCPRMT LSPACE MF=L              LSPACE PARM TEMPLATE                |\n         EJECT\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   A R E A                                   *\n*                                                                  *\n********************************************************************\nDYNAMIC  DSECT\nSAVE     DS    18F .\nRC       DS    F\nECB      DS    F\nMYANS    DS    A\nPDEADDR  DS    A\nMYCPPL   DS    0F,CL(CPPLLEN)\nMYPPL    DS    0F,CL(PPLLEN)\nMYIOPL   DS    0F,CL(IOPLLEN)\nMYIOPB   DS    0F,CL(IOPBLEN)\nCOUNT    DS    H\nVALUELEN DS    H\nVALUE    DS    CL8\nOUTAREA  DS    0F,AL2,AL2\nOUTVOL   DS    CL6,CL1\nOUTINDEX DS    CL1,CL1\nOUTUCB   DS    CL4,CL1                                                |\nOUTDEVT  DS    CL5,CL1\nOUTATTR  DS    CL4,CL1\nOUTSPACE DS    CL50\nOUTAREAL EQU   *-OUTAREA\n* IEFEB4UV PARM LIST.\nUNITPARM DS    2A                     IEFEB4UV PARM LIST\nUNITTAB  DS    0F                     UNIT TABLE\nUNITNAME DS    CL8                    UNITNAME (INPUT TO IEFEB4UV)\nUNITLIST DS    F                      UNITNAME LIST ADDR (OUTPUT)\nUNITATTR DS    F                      DON'T PROVIDE ATTRIBUTE LIST\nUNITFLG  DS    X                      IEFEB4UV PARM LIST\n* END IEFEB4UV PARM LIST.\nTYPE     DS    X\nTRY      DS    X\nPRIVATE  EQU   X'01'\nSTORAGE  EQU   X'02'\nPUBLIC   EQU   X'04'\nVOLUME   EQU   X'08'\nUCB      EQU   X'10'\nUNIT     EQU   X'20'\nONLINE   EQU   X'40'\nMASK     EQU   X'80'\nATTR     DS    X\n*\n         DS    0D\n         UCBSCAN MF=(L,UCBSCANL)\n         DS    0D\nSCANWORK DS    CL100    WORK AREA USED BY THE UCBSCAN SERVICES\n         DS    0D\nUCBCOPY  DS    48C      UCB COMN SEGMENT & DEVICE DEPENDENT SEGMENT\n         DS    0D\nUCBEXTN  DS    36C      UCB COMN EXTENTION SEGMENT\nRETCODE  DS    F        RETURN CODE USED BY UCBSCAN SERVICES\nRSNCODE  DS    F        REASON CODE USED BY UCBSCAN SERVICES\nDEVNAME  DS    CL4      DEVICE NUMBER ASSOCIATED WITH UCB.\nDCETEXT  DS    XL256    DCE AREA\n*\n* LSPACE ITEMS\n*\nLSPCMSGA DS    A                                                      |\nLSPCPRMW DS    XL(LSPAEND-LSPCPRM) LSPACE PARM WORKAREA               |\nLSPCMSG  LSPACE MF=(L,EXPMSG)                                         |\n*\nDYNLEN   EQU   *-DYNAMIC\n         TITLE 'DSPACE - MACRO LSPACE PARM LIST'\nLSPCPRM  LSPACE MF=D                                                  |\n         TITLE 'DSPACE - MACRO IKJCPPL'\n         IKJCPPL\nCPPLLEN  EQU   *-CPPL\n         TITLE 'DSPACE - MACRO IKJPPL'\n         IKJPPL\nPPLLEN   EQU   *-PPL\n         TITLE 'DSPACE - MACRO IKJIOPL'\n         IKJIOPL\nIOPLLEN  EQU   *-IOPL\n         SPACE 3\n         TITLE 'DSPACE - MACRO IHAPSA'\n         IHAPSA LIST=YES\n         TITLE 'DSPACE - MACRO CVT'\n         CVT   DSECT=YES,LIST=YES\n         TITLE 'DSPACE - MACRO UCB'\nUCBDSECT DSECT\n         IEFUCBOB LIST=YES\n         END   &CSECT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSPACE@": {"ttr": 2821, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x05o\\x01\\x00$?\\x18B\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-02-25T00:00:00", "modifydate": "2000-08-30T18:42:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "WSBG"}, "text": "Subject: DSPACE Update #3\nDate: Thu, 25 Feb 1999 12:34:55 -0600\nFrom: DALE VICK <DVICK@usagroup.com>\nTo: sbgolob@attglobal.net\n\nSam\n\nAttached you will find hopefully the last (for awhile) update to the\ncommand processor DSPACE.\n\nImprovements\n\n1)  It still includes the change from using the UCB scan services\n(found in the CVT) to using the UCBSCAN macro.  This was needed\nfor four digit addressing.\n\n2)  The latest change came in the switch from issuing the SVC 78\ndirect (loading R0 with the address to the UCB, doing a load\naddress R1 to the message return area and then issuing SVC 78) to\nusing the LSPACE macros with the EXPMSG sub-parameter.  With the\nEXPMSG parm LSPACE now passes back six digit information on free\nspace instead of four.  So it will now work on 3390 mod 9's.\n\nIf you have any questions please give me a call at (317) 578-6786.\n\ndv\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DSPACEH": {"ttr": 2823, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x00\\x83\\x01O\\x00\\x99\\x02\\x8f\\x12W\\x00\\x14\\x00\\n\\x00\\x00\\xe3\\xe2\\xc3\\xd7\\xf0\\xf0\\xf4@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1983-01-14T00:00:00", "modifydate": "1999-01-28T12:57:00", "lines": 20, "newlines": 10, "modlines": 0, "user": "TSCP004"}, "text": ")F FUNCTION -\n   THE DASDSPACE OR DSPACE COMMAND TELLS HOW MUCH FREE SPACE A\n   DASD VOLUME CONTAINS.  THIS IS HELPFUL IF YOU ARE LOOKING\n   FOR A DASD VOLUME THAT CONTAINS ENOUGH SPACE TO HOLD A NEW\n   DATASET.\n)X SYNTAX -\n          DSPACE VVVVVV   ,VVVVVV = A VOLSER (1-6 CHARS)\n          DSPACE UUUU     ,UUUU = A UCB ADDRESS (4 CHARS)\n          DSPACE NNNNNNNN ,NNNNNNNN = A UNITNAME (1-8 CHARS\n          DSPACE STORAGE  ,FOR ALL STORAGE VOLUMES\n          DSPACE PUBLIC   ,FOR ALL PUBLIC VOLUMES\n          DSPACE PRIVATE  ,FOR ALL PRIVATE VOLUMES\n          DSPACE ONLINE   ,FOR ALL ONLINE VOLUMES (DEFAULT)\n\n    NOTE: DSPACE ACCEPTS A MASK: DSPACE TSO* OR DSPACE WORK*\n          DSPACE ALSO ACCEPTS A LIST: DSPACE (VVVVVV,UUUU,...)\n)O OPERANDS -\n            MULTIPLE ITEMS MUST BE WITH IN PARENTHESIS AND SEPARATED\n            BY A SPACE OR COMMA.\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DSPACEOL": {"ttr": 2825, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x01\\xbc\\x01\\xbc\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 444, "newlines": 444, "modlines": 0, "user": "FILE369"}, "text": "PRC      TITLE 'DSPACE - DISPLAY DASD SPACE INFORMATION.'\n********************************************************************\n*                                                                  *\n* NAME - DSPACE.                                                   *\n*                                                                  *\n* DESCRIPTION - TSO COMMAND TO DISPLAY AVAILABLE SPACE ON DIRECT   *\n*               ACCESS VOLUME(S).                                  *\n*                                                                  *\n* TO USE - ENTER: DSPACE VVVVVV   ,VVVVVV = A VOLSER (1-6 CHARS)   *\n*                 DSPACE UUU      ,UUU = A UCB ADDRESS (3 CHARS)   *\n*                 DSPACE NNNNNNNN ,NNNNNNNN = A UNITNAME (1-8 CHARS*\n*                 DSPACE STORAGE  ,FOR ALL STORAGE VOLUMES         *\n*                 DSPACE PUBLIC   ,FOR ALL PUBLIC VOLUMES          *\n*                 DSPACE PRIVATE  ,FOR ALL PRIVATE VOLUMES         *\n*                 DSPACE ONLINE   ,FOR ALL ONLINE VOLUMES (DEFAULT)*\n*                                                                  *\n*   NOTE: DSPACE ACCEPTS A MASK: DSPACE RES* OR DSPACE 3C*         *\n*         DSPACE ALSO ACCEPTS A LIST: DSPACE (VVVVVV,UUU,...)      *\n*                                                                  *\n* LOG -                                                            *\n*   12/17/86 L01 PTW IMPLEMENTED                                   *L01\n*                                                                  *\n********************************************************************\n         LCLC  &CSECT\n&CSECT   SETC  'DSPACE'\n&CSECT   CSECT\n********************************************************************\n*                                                                  *\n*        I N I T I A L I Z E                                       *\n*                                                                  *\n********************************************************************\n         PRINT NOGEN\n         SAVE  (14,12),,&CSECT-&SYSDATE-&SYSTIME\n         LR    R12,R15            ESTABLISH BASE.\n         USING &CSECT,R12         TELL ASSEMBLER.\n         GETMAIN RU,LV=DYNLEN     DYNAMIC AREA.\n         LR    R2,R13             SAVE AREA\n         LR    R13,R1               SWITCH.\n         USING DYNAMIC,R13        TELL ASSEMBLER.\n         LR    R0,R1\n         LA    R1,DYNLEN\n         LA    R14,R0\n         SLR   R15,R15\n         MVCL  R0,R14             ZERO STORAGE.\n         ST    R2,4(,R13)         BACK CHAIN.\n         ST    R13,8(,R2)         FORWARD CHAIN.\n         XC    RC,RC\n         L     R2,4(,R13)\n         L     R2,24(,R2)         R2 = A(PARMLIST).\n         USING CPPL,R2            CONSTRUCT TSO CONTROL BLOCKS.\n         MVC   MYIOPB(IOPBLEN),XIOPB INITIALIZE DYNAMIC IOPB.\n         LA    R3,MYPPL           BUILD PPL.\n         USING PPL,R3\n         MVC   PPLUPT,CPPLUPT\n         MVC   PPLECT,CPPLECT\n         LA    R4,ECB\n         ST    R4,PPLECB\n         MVC   PPLPCL,=A(MYPCL)\n         LA    R4,MYANS\n         ST    R4,PPLANS\n         MVC   PPLCBUF,CPPLCBUF\n         XC    PPLUWA,PPLUWA\n         DROP  R3\n         LA    R3,MYIOPL          BUILD IOPL.\n         USING IOPL,R3\n         MVC   IOPLUPT,CPPLUPT\n         MVC   IOPLECT,CPPLECT\n         LA    R4,ECB\n         ST    R4,IOPLECB\n         LA    R4,MYIOPB\n         ST    R4,IOPLIOPB\n         DROP  R2,R3\n         LA    R2,UCBAREA         INITIALIZE UCB SCAN LIST.\n         ST    R2,UCBAAREA\n         MVI   UCBDEVC,UCB3DACC\n         LA    R2,UCBDEVC\n         ST    R2,UCBADEVC\n         LA    R2,UCBUCB\n         ST    R2,UCBAUCB\n         MVI   UCBAUCB,X'80'\n         MVC   OUTAREA(4),=AL2(OUTAREAL,0) INITIALIZE PUTLINE MSG.\n         CALLTSSR EP=IKJPARS,MF=(E,MYPPL) CALL PARSE.\n         LTR   R15,R15\n         BNZ   BADPARS\n         L     R2,MYANS           R2 = A(PDL FROM PARSE)\n         USING MYPDL,R2\n         LA    R2,VOLUMES         R2 = A(VOLUME POSITIONAL PDE).\n         DROP  R2\n         XC    COUNT,COUNT\n********************************************************************\n*                                                                  *\n*        G E T   1 S T   T H I N G   I N   L I S T                 *\n*                                                                  *\n********************************************************************\nLOOPPDE  DS    0H\n         MVI   TYPE,0\n         MVI   TRY,0\n         MVI   ATTR,0\n         ST    R2,PDEADDR         SAVE A(PDE).\n         XC    UCBAREA,UCBAREA\n         MVI   VALUE,C' '\n         MVC   VALUE+1(L'VALUE-1),VALUE\n         L     R3,0(,R2)          R3 = A(PDE).\n         LH    R4,4(,R2)          R5 = L'VALUE.\n         STH   R4,VALUELEN\n         BCTR  R4,R0\n         EX    R4,MVCVALUE\n         CLC   =C'STORAGE ',VALUE CHECK FOR STORAGE.\n         BNE   NOTSTOR\n         OI    TYPE,STORAGE\n         MVI   ATTR,UCBBSTR\n         B     DOSCAN\nNOTSTOR  DS    0H\n         CLC   =C'PUBLIC ',VALUE CHECK FOR PUBLIC.\n         BNE   NOTPUB\n         OI    TYPE,PUBLIC\n         MVI   ATTR,UCBBPUB\n         B     DOSCAN\nNOTPUB   DS    0H\n         CLC   =C'PRIVATE ',VALUE CHECK FOR PRIVATE.\n         BNE   NOTPRIV\n         OI    TYPE,PRIVATE\n         MVI   ATTR,UCBBPRV\n         B     DOSCAN\nNOTPRIV  DS    0H\n         CLC   =C'ONLINE ',VALUE CHECK FOR ONLINE.\n         BNE   ENDONL\n         OI    TYPE,ONLINE\n         B     DOSCAN\nENDONL   DS    0H\n         CLC   VALUELEN,=H'6'     IF L'VALUE > 6, CAN ONLY BE UNITNAME.\n         BH    TRYUNIT\n         CLC   VALUELEN,=H'2'     IF L'VALUE < 2, TRY UNITNAME.\n         BL    TRYUNIT\n         OI    TRY,VOLUME         SPECIFY TRY FOR VOLUME.\n         LH    R4,VALUELEN\n         BCTR  R4,0\n         LA    R5,VALUE(R4)\n         CLI   0(R5),C'*'\n         BNE   NOTMASK\n         OI    TRY,MASK\n         STH   R4,VALUELEN\nNOTMASK  DS    0H\n         CLC   VALUELEN,=H'3'     IF L'VALUE > 3, CAN'T BE UCB.\n         BH    DOSCAN\n         OI    TRY,UCB\n         B     DOSCAN\n********************************************************************\n*                                                                  *\n*        G E T   N E X T   T H I N G   I N   L I S T               *\n*                                                                  *\n********************************************************************\nNEXTPDE  DS    0H\n         L     R2,PDEADDR         GET NEXT ENTRY IS PARSE LIST.\n         L     R2,8(,R2)\n         CL    R2,=X'FF000000'    IF NO MORE, RETURN.\n         BNE   LOOPPDE\n********************************************************************\n*                                                                  *\n*        R E T U R N                                               *\n*                                                                  *\n********************************************************************\nRETURN   DS    0H\n         IKJRLSA MYANS\n         L     R2,RC                  R2 = RC.\n         LR    R1,R13              PREPARE\n         L     R13,4(,R13)           FOR FREEMAIN.\n         FREEMAIN RU,LV=DYNLEN,A=(1)\n         LR    R15,R2              AND RETURN\n         RETURN (14,12),RC=(15)      WITH R15 = RC.\n********************************************************************\n*                                                                  *\n*        U C B   S C A N                                           *\n*                                                                  *\n********************************************************************\nDOSCAN   DS    0H\n         LA    R1,UCBPARML\n         L     R15,FLCCVT-PSA\n         L     R15,CVTUCBSC-CVT(,R15) R15 = A(UCB SCAN ROUTINE).\n         BALR  R14,R15\n         LTR   R15,R15            IF BAD RC, ASSUME NO MORE TO SCAN.\n         BNZ   ENDSCAN\n         L     R3,UCBUCB          R3 = A(UCB).\n         USING UCBCMSEG,R3\n         TM    TRY,VOLUME         IF WE ARE TO TRY FOR VOLUME,\n         BZ    NOTVOL\n         LA    R4,L'UCBVOLI-1     ASSUME FULL LENGTH COMPARE...\n         TM    TRY,MASK             UNLESS A MASK WAS SPECIFIED.\n         BZ    *+10\n         LH    R4,VALUELEN\n         BCTR  R4,0\n         EX    R4,CLCVOLI\n         BNE   NOTVOL\n         OI    TYPE,VOLUME\n         B     SCANSPAC\nNOTVOL   DS    0H\n         TM    TRY,UCB            IF WE ARE TO TRY FOR UCB,\n         BZ    NOTUCB\n         LA    R4,L'UCBNAME-1     ASSUME FULL LENGTH COMPARE...\n         TM    TRY,MASK             UNLESS A MASK WAS SPECIFIED.\n         BZ    *+10\n         LH    R4,VALUELEN\n         BCTR  R4,0\n         EX    R4,CLCNAME\n         BNE   NOTUCB\n         OI    TYPE,UCB\n         B     SCANSPAC\nNOTUCB   DS    0H\n         TM    TYPE,STORAGE+PUBLIC+PRIVATE\n         BZ    NOTATTR            IF ATTRIBUTE COMPARE, DO IT.\n         SLR   R4,R4\n         IC    R4,ATTR\n         EX    R4,TMATTR\n         BO    SCANSPAC\n         B     DOSCAN\nNOTATTR  DS    0H\n         TM    TYPE,ONLINE        IF NO ONLINE REQUEST,\n         BZ    DOSCAN               GET NEXT UCB.\nSCANSPAC DS    0H\n         BAL   R10,DOLSPACE       GO DO LSPACE.\n         TM    TYPE,VOLUME+UCB    IF WE HIT ON SINGLE REQUEST,\n         BZ    DOSCAN               ALL DONE.\n         TM    TRY,MASK           UNLESS IT WAS A MASK REQUEST.\n         BO    DOSCAN\nENDSCAN  DS    0H\n         CLI   TYPE,0             IF WE HAVE A HIT,\n         BNE   NEXTPDE              GO DO NEXT.\n********************************************************************\n*                                                                  *\n*        U N I T   R E Q U E S T                                   *\n*                                                                  *\n********************************************************************\nTRYUNIT  DS    0H\n         MVC   UNITNAME,VALUE     INIT LISTS FO IEFEB4UV.\n         XC    UNITLIST,UNITLIST\n         XC    UNITATTR,UNITATTR\n         MVI   UNITFLG,X'10'\n         LINK  EP=IEFEB4UV,PARAM=(UNITTAB,UNITFLG),MF=(E,UNITPARM)\n         LTR   R15,R15            IF RC \u00ac= 0,\n         BNZ   ENDUNIT              ASSUME NOT A UNITNAME.\n         OI    TYPE,UNIT\n         L     R2,UNITLIST\n         L     R4,4(,R2)          R4 = # UCBS IN RETURNED LIST.\n         L     R3,8(,R2)          R3 = A(UCB).\n         LA    R2,8(,R2)          R2 = A(THIS UCB ENTRY IN TABLE).\nUNITLOOP DS    0H\n         BAL   R10,DOLSPACE\n         LA    R2,4(,R2)          R2 = A(NEXT UCB ENTRY IN TABLE).\n         L     R3,0(,R2)          R3 = A(NEXT UCB).\n         BCT   R4,UNITLOOP        LOOP.\n         L     R2,UNITLIST\n         L     R0,0(,R2)\n         FREEMAIN R,LV=(0),A=(R2) FREEMAIN IEFEB4UV STORAGE.\n         B     NEXTPDE\nENDUNIT  DS    0H\n         B     BADREQ             CAN'T IDENTIFY REQUEST.\n********************************************************************\n*                                                                  *\n*        D O   L S P A C E   S V C ( 7 8 )                         *\n*                                                                  *\n********************************************************************\nDOLSPACE DS    0H\n         LH    R0,COUNT           PUT OUT HEADER FOR 1ST REQ ONLY.\n         AH    R0,=H'1'\n         STH   R0,COUNT\n         CH    R0,=H'1'\n         BNE   NOHDR\n         PUTLINE OUTPUT=(OUTHDR,SINGLE,DATA),MF=(E,MYIOPL)\nNOHDR    DS    0H\n         MVI   OUTAREA+4,C' '     FORMAT OUTPUT LINE.\n         MVC   OUTAREA+5(OUTAREAL-5),OUTAREA+4\n         MVC   OUTUCB,UCBNAME\n         TM    UCBSTAT,UCBONLI    IF UCB NOT ONLINE,\n         BZ    BADONL               GO TO ERROR ROUTINE.\n         TM    UCBSTAT,UCBCHGS+UCBUNLD NO FUNNY STATUS.\n         BNZ   BADUCB\n         MVC   OUTVOL,UCBVOLI\n         LR    R0,R3              R0 = A(UCB).\n         LA    R1,SVCAREA         R1 = A(MSG AREA).\n         SVC   78                 DO LSPACE.\n         LTR   R15,R15            IF BAD RC,\n         BNZ   BADSVC78             GO TO ERROR ROUTINE.\n         MVC   OUTSPACE(L'SVCAREA),SVCAREA\n         CVAFTST UCB=(R3)         CHECK FOR INDEXED VTOC.\n         CH    R15,=H'8'          IF RC = 8, WE'RE INDEXED.\n         BNE   *+8\n         MVI   OUTINDEX,C'I'\n         PUTLINE OUTPUT=(OUTAREA,SINGLE,DATA),MF=(E,MYIOPL)\n         BR    R10\n********************************************************************\n*                                                                  *\n*        E R R O R S                                               *\n*                                                                  *\n********************************************************************\nBADPARS  DS    0H                 BAD PARSE.\n         MVC   RC,=F'12'\n         LA    R15,MSGPARS\n         LA    R10,RETURN\n         B     DOMSG\nBADREQ   DS    0H                 CAN'T IDENTIFY REQUEST.\n         MVC   RC,=F'8'\n         LA    R15,MSGREQ\n         LA    R10,NEXTPDE\n         B     DOMSG\nBADONL   DS    0H                 UCB NOT ONLINE.\n         TM    TYPE,STORAGE+PUBLIC+PRIVATE+ONLINE\n         BNZ   RETMSG             FOR ABOVE REQUESTS, IGNORE ERROR.\n         MVC   OUTSPACE(L'MSGONL),MSGONL\n         LA    R15,OUTAREA\n         B     DOMSG\nBADUCB   DS    0H                 FUNNY STATUS.\n         TM    TYPE,STORAGE+PUBLIC+PRIVATE+ONLINE\n         BNZ   RETMSG             FOR ABOVE REQUESTS, IGNORE ERROR.\n         MVC   OUTSPACE(L'MSGUCB),MSGUCB\n         LA    R15,OUTAREA\n         B     DOMSG\nBADSVC78 DS    0H                 BAD LSAPCE RC.\n         TM    TYPE,STORAGE+PUBLIC+PRIVATE+ONLINE\n         BNZ   RETMSG             FOR ABOVE REQUESTS, IGNORE ERROR.\n         MVC   OUTSPACE(L'MSGSVC78),MSGSVC78\n         LA    R10,NEXTPDE\n         B     DOMSG\nDOMSG    DS    0H\n         PUTLINE OUTPUT=((R15),SINGLE,DATA),MF=(E,MYIOPL)\nRETMSG   DS    0H\n         BR    R10\n********************************************************************\n*                                                                  *\n*        S T A T I C   A R E A                                     *\n*                                                                  *\n********************************************************************\nMVCVALUE MVC   VALUE(*-*),0(R3)\nCLCVOLI  CLC   UCBVOLI(*-*),VALUE        COMPARE VOLSER.\nCLCNAME  CLC   UCBNAME(*-*),VALUE        COMPARE EBCDIC UCB NAME.\nTMATTR   TM    UCBSTAB,*-*\nMSGONL   DC    C'OFFLINE'\nMSGUCB   DC    C'SPACE COULD NOT BE DETERMINED.'\nMSGSVC78 DC    C'LSPACE SVC ERROR, IGNORED.'\nMSGPARS  DC    AL2(MSGPARSL,0)\n         DC    C'TSO PARSE ERROR, PROGRAM TERMINATED.'\nMSGPARSL EQU   *-MSGPARS\nMSGREQ   DC    AL2(MSGREQL,0)\n         DC    C'VOLSER, UCB, OR UNIT NOT FOUND, IGNORED.'\nMSGREQL  EQU   *-MSGREQ\nXIOPB    PUTLINE MF=L\nIOPBLEN  EQU   *-XIOPB\nMYPCL    IKJPARM DSECT=MYPDL\nVOLUMES  IKJIDENT  VOLUME,LIST,FIRST=ALPHANUM,OTHER=ALPHANUM,CHAR,     X\n               MAXLNTH=8,DEFAULT='ONLINE'\n         IKJENDP\nOUTHDR   DC    AL2(OUTHDRL,0)\n         DC    C'VOL    '\n         DC    C'  '\n         DC    C'UNIT'\n         DC    C'     '\n         DC    C'#CYL '\n         DC    C'#TRK '\n         DC    C'#EXT '\n         DC    C'CYL-C '\n         DC    C'TRK-C '\nOUTHDRL  EQU   *-OUTHDR\n         DROP  R3\n         LTORG *\nSRCLEVEL DC    C'                                        '\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   A R E A                                   *\n*                                                                  *\n********************************************************************\n         IKJCPPL\nCPPLLEN  EQU   *-CPPL\n         IKJPPL\nPPLLEN   EQU   *-PPL\n         IKJIOPL\nIOPLLEN  EQU   *-IOPL\n         IHAPSA\n         CVT   DSECT=YES\n         IEFUCBOB\nDYNAMIC  DSECT\nSAVE     DS    18F .\nRC       DS    F\nECB      DS    F\nMYANS    DS    A\nPDEADDR  DS    A\nMYCPPL   DS    0F,CL(CPPLLEN)\nMYPPL    DS    0F,CL(PPLLEN)\nMYIOPL   DS    0F,CL(IOPLLEN)\nMYIOPB   DS    0F,CL(IOPBLEN)\nUCBPARML DS    0F\nUCBAAREA DS    F\nUCBADEVC DS    F\nUCBAUCB  DS    F\nUCBUCB   DS    F\nUCBAREA  DS    XL100\nUCBDEVC  DS    CL1\nCOUNT    DS    H\nVALUELEN DS    H\nVALUE    DS    CL8\nSVCAREA  DS    CL50\nOUTAREA  DS    0F,AL2,AL2\nOUTVOL   DS    CL6,CL1\nOUTINDEX DS    CL1,CL1\nOUTUCB   DS    CL3,CL1\nOUTSPACE DS    CL50\nOUTAREAL EQU   *-OUTAREA\n* IEFEB4UV PARM LIST.\nUNITPARM DS    2A                     IEFEB4UV PARM LIST\nUNITTAB  DS    0F                     UNIT TABLE\nUNITNAME DS    CL8                    UNITNAME (INPUT TO IEFEB4UV)\nUNITLIST DS    F                      UNITNAME LIST ADDR (OUTPUT)\nUNITATTR DS    F                      DON'T PROVIDE ATTRIBUTE LIST\nUNITFLG  DS    X                      IEFEB4UV PARM LIST\n* END IEFEB4UV PARM LIST.\nTYPE     DS    X\nTRY      DS    X\nPRIVATE  EQU   X'01'\nSTORAGE  EQU   X'02'\nPUBLIC   EQU   X'04'\nVOLUME   EQU   X'08'\nUCB      EQU   X'10'\nUNIT     EQU   X'20'\nONLINE   EQU   X'40'\nMASK     EQU   X'80'\nATTR     DS    X\nDYNLEN   EQU   *-DYNAMIC\n         PRINT OFF\nR0       EQU   00\nR1       EQU   01\nR2       EQU   02\nR3       EQU   03\nR4       EQU   04\nR5       EQU   05\nR6       EQU   06\nR7       EQU   07\nR8       EQU   08\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12                 PROGRAM BASE.\nR13      EQU   13                 A(SAVE AREA).\nR14      EQU   14\nR15      EQU   15\n         PRINT ON\n         END   &CSECT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENQWAIT": {"ttr": 3076, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x033\\x033\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 819, "newlines": 819, "modlines": 0, "user": "FILE369"}, "text": "PRC      TITLE 'ENQWAIT - STIMER UNTIL SOMEONE ELSE GETS AN ENQ.'\n********************************************************************\n*                                                                  *\n* NAME - ENQWAIT.                                                  *\n*                                                                  *\n* DESCRIPTION -                                                    *\n*                                                                  *\n*   THIS PROGRAM WORKS IN CONJUNCTION WITH THE AUTOIPL PROGRAM.    *\n*   WE STIMER UNTIL A TARGET JOB ACQUIRES A TARGET RESOURCE VIA AN *\n*   ENQ REQUEST.  THUS WE CAN ENSURE THAT AUTOIPL WILL NOT         *\n*   PROCEED UNTIL A PREVIOUS PROCESS IS READY FOR PROCESSING.      *\n*                                                                  *\n*   FOR EXAMPLE, CONSIDER THE FOLLOWING AUTOIPL INPUT:             *\n*     S TPJOB,M=TCAM                                               *\n*     \"ENQWAIT \"JOB=TCAM,MAJOR=AUTOTCAM                            *\n*     S MESS,M=                                                    *\n*                                                                  *\n*   THE \"S MESS,M=\" COMMAND WILL NOT PROCEED UNTIL TCAM ACQUIRES   *\n*   THE RESOURCE WHOSE MAJOR NAME IS AUTOTCAM.  WE STIMER EVERY    *\n*   10 SECONDS FOR 5 MINUTES TO CHECK ON STATUS.  IF ANYTHING IS   *\n*   FOUND THAT IS UNGOOD, WE ABEND WITH A U123.                    *\n*                                                                  *\n* TO USE -                                                         *\n*                                                                  *\n*   EXEC PGM=ENQWAIT,PARM='MAJOR=MMMMMMMM,                         *\n*                          ACTION=WAIT/ABEND,                      *\n*                          CONTROL=E/S/ANY,                        *\n*                          JOB=JJJJJJJJ,                           *\n*                          MINOR=RRRRRRRR,                         *\n*                          MSG=YES/NO,                             *\n*                          NAME=NNNNNNNN,                          *\n*                          SCOPE=STEP/SYSTEM/SYSTEMS/ANY,          *\n*                          SYSNAME=SSSSSSSS,                       *L04\n*                          TIME=9999,                              *\n*                          WANTENQ=HELD/NOTHELD'                   *\n*                                                                  *\n*           MAJ(OR)  = TEST FOR THIS ENQ QNAME BEING HELD:         *\n*                      MMMMMMMM = QNAME (1-8 CHARS).               *\n*           A(CTION) = DO THIS IF CONDITION IS'NT INITIALLY MET:   *\n*                      W(AIT): WAIT (DEFAULT) FOR TIME= SECONDS.   *\n*                      A(BEND): ABEND IMMEDIATELY. (WITH AN U123). *\n*           C(ONTROL)= TEST FOR THIS ENQ RESOURCE CONTORL:         *\n*                      E(XC): EXCLUSIVE                            *\n*                      S(HR): SHARED                               *\n*                      A(NY): DON'T TEST CONTROL (DEFAULT).        *\n*           J(OB)    = TEST FOR THIS JOBNAME HOLDING RESOURCE:     *\n*                      MMMMMMMM = QNMAE (1-8 CHARS).               *\n*                      NOTE: A MASK IS ALLOWED - JOB=ABC*.         *\n*           MIN(OR)  = TEST FOR THIS ENQ RNAME BEING HELD:         *\n*                      RRRRRRRR = RNAME (1-44 CHARS).              *\n*                      NOTE: A MASK IS ALLOWED - MINOR=ABC*.       *\n*           MSG      = IF CONDITION IS'NT MET, NOTIFY ISSUER?      *L03\n*                      Y(ES): NOTIFY (DEFAULT).                    *\n*                      N(O):  DON'T NOTIFY.                        *\n*           N(AME)   = DESCRIPTIVE NAME PUT IN NOTIFCATION MSG.    *\n*                      NNNNNNNN = NAME (1-8 CHARS).                *\n*           S(COPE)  = TEST FOR THIS ENQ SCOPE:                    *\n*                      S(TEP): WITHIN AN ADDRESS SPACE.            *\n*                      SYS(TEM): BETWEEN ADDRESS SPACES.           *\n*                      SYSTEMS: SHARED BETWEEN SYSTEMS.            *\n*                      SYSS:    \"\"                                 *\n*                      A(NY): DON'T TEST SCOPE (DEFAULT).          *\n*           SYS(NAME)= TEST FOR THIS SYSNAME HOLDING RESOURCE:     *L04\n*                      SSSSSSSS = SYSNAME (1-8 CHARS).             *L04\n*                      NOTE: THIS IS FOR GRS SUPPORT.              *L04\n*           T(IME)   = FOR ACTION=WAIT, ELAPSED SECONDS TO WAIT    *\n*                      BEFORE ABENDING:                            *\n*                      NNNN = 1-9999 (DEFAULT=300).                *\n*                      NOTE: ROUNDED UP TO NEXT 5 SECOND INTREVAL. *\n*           W(ANTENQ)= CONDITION TO BE MET BEFORE RETURNING CONTROL*\n*                      H(ELD): ENQ MUST BE HELD (DEFAULT)          *\n*                      N(OTHELD): ENQ MUST NOT BE HELD.            *\n*                                                                  *\n*     NOTE: MAJOR= IS REQUIRED. IF JOB= IS NOT SPECIFIED, BOTH     *\n*           MAJOR= AND MINOR= MUST BE.  ALSO, IF MSG=YES IS IN     *\n*           EFFECT, EITHER JOB= OR NAME= MUST BE SPECIFIED; IF     *\n*           ONLY JOB= IS SPECIFIED, THE VALUE MUST NOT BE A MASK.  *\n*                                                                  *\n* LOG -                                                            *\n*   11/11/86 L01 PTW IMPLEMENTED                                   *L01\n*   12/22/86 L02 PTW ADD'L PARMS SUPPORTED.                        *L02\n*   06/17/87 L03 PTW BETTER MSGS, FIX BUGS, ETC.                   *L03\n*   08/23/88 L04 PTW SYSNAME= SUPPORT FOR GRS.                     *L04\n*                                                                  *\n********************************************************************\n         LCLC  &CSECT\n&CSECT   SETC  'ENQWAIT'\n&CSECT   CSECT\n********************************************************************\n*                                                                  *\n*        I N I T I A L I Z E                                       *\n*                                                                  *\n********************************************************************\n         PRINT NOGEN\n         SAVE  (14,12),,&CSECT-&SYSDATE-&SYSTIME\n         LR    R12,R15            ESTABLISH BASE.\n         USING &CSECT,R12\n         GETMAIN RU,LV=DYNLEN     GET SOME STORAGE.\n         LR    R2,R13             DO THE USUAL SAVE AREA STUFF.\n         LR    R13,R1\n         USING DYNAMIC,R13\n         LR    R0,R1\n         L     R14,=A(DYNLEN)\n         LA    R1,R1\n         SLR   R15,R15\n         MVCL  R0,R14             ZERO STORAGE.\n         ST    R2,4(,R13)         BACK CHAIN.\n         ST    R13,8(,R2)         FORWARD CHAIN.\n         XC    RC,RC              ASSUME GOOD RC.\n********************************************************************\n*                                                                  *\n*        P A R M   P R O C E S S I N G                             *\n*                                                                  *\n********************************************************************\n         L     R2,PSAAOLD-PSA\n         L     R3,ASCBJBNI-ASCB(R2) GET OUR JOBNAME.\n         LTR   R3,R3\n         BNZ   *+8\n         L     R3,ASCBJBNS-ASCB(R2)\n         MVC   OURJOB,0(R3)\n         MVI   TSO,NO             ASSUME NOT TSO.\n         L     R3,ASCBTSB-ASCB(,R2)\n         LTR   R3,R3\n         BZ    *+8\n         MVI   TSO,YES            THEN INDICATE TPUT MODE.\n         MVI   WTOFLG,0           INITIALIZE FLAGS.\n         MVI   PARM1,0\n         MVI   PARM2,0\n         MVI   MASK,0\n         MVI   ACTION,WAIT\n         MVI   CONTROL,ANY\n         MVI   MSG,YES\n         MVI   SCOPE,ANY\n         MVC   TIME,=F'300'\n         MVI   WANTENQ,HELD\nDOPARM   DS    0H\n         L     R2,4(,R13)         DIG BACK THRU SAVEAREAS\n         L     R2,24(,R2)           FOR THE A(PARM).\n         L     R2,0(,R2)          R2 = A(PARM).\n         LH    R3,0(,R2)          R3 = L'PARM.\n         LTR   R3,R3              IF ZEROS +\n         BZ    BADPARM              THEN EXIT.\n         LA    R2,2(,R2)          R2 = A(START OF TEXT).\n         LA    R3,0(R3,R2)        R3 = A(END OF TEXT).\n         ST    R3,SAVE\n         LR    R3,R2\nTRYCOMMA DS    0H                 SCAN FOR THE ','.\n         CLI   0(R3),C','         IF A ',',\n         BE    GOTCOMMA             THEN EXIT.\n         LA    R3,1(,R3)          ELSE, LOOP.\n         CL    R3,SAVE            IF STILL MORE TO GO,\n         BL    TRYCOMMA             KEEP SCANNING.\nGOTCOMMA DS    0H\n         LR    R4,R3\n         SR    R4,R2              R4 = L'KEYWORD +L'VALUE.\n         L     R11,=A(KWORDTAB)    DO A TABLE LOOKUP ON THE\n         USING KTABLE,R11\nTRYKWORD DS    0H\n         CLI   KTABKEY,X'FF'\n         BE    BADPARM\n         SLR   R5,R5\n         IC    R5,KTABKEYL        CHECK THAT THE LENGTH IS FEASIBLE.\n         CLR   R4,R5\n         BNH   NXTKWORD\n         BCTR  R5,0\n         EX    R5,CLCKWORD        DO THE COMPARE.\n         BE    GOTKWORD\nNXTKWORD DS    0H\n         LA    R11,KTABLEN(,R11)    IF NOT EQUAL, BUMP TO NEXT ENTRY.\n         B     TRYKWORD\nCLCKWORD CLC   KTABKEY(*-*),0(R2)\nNXTPARM  DS    0H\n         CL    R3,SAVE            CHECK FOR ANY MORE PARM FIELD.\n         BNL   DOCHECK\n         LA    R2,1(,R3)          IF YES, POSITION CURSOR.\n         LR    R3,R2\n         B     TRYCOMMA\nGOTKWORD DS    0H\n         XC    VALUELEN,VALUELEN  INITIALIZE WORKAREAS.\n         MVI   VALUE,C' '\n         MVC   VALUE+1(L'VALUE-1),VALUE\n         MVI   VALUEFLG,0\n         SLR   R4,R4\n         IC    R4,KTABKEYL\n         LA    R2,0(R4,R2)        BUMP CURSOR PAST KEYWORD.\n         LR    R4,R3              CALCULATE LENGTH OF VALUE.\n         SR    R4,R2\n         BNP   BADPARM\n         STH   R4,VALUELEN        SAVE L'VALUE.\n         BCTR  R4,0\n         EX    R4,MVCVALUE        AND VALUE.\n         CLI   KTABTYPE,KEY       IF TYPE IS KEY, PROCESS.\n         BE    DOKEY\n         CLI   KTABTYPE,NUM       IF TYPE IS NUM, PROCESS.\n         BE    DONUM\n         CLI   KTABTYPE,FLG       IF TYPE IS FLG, PROCESS.\n         BE    DOFLG\nDOCHR    DS    0H                 ASSUME TYPE IS CHR.\n         CLC   KTABMINW,VALUELEN+1  CHECK FOR MINIMUM WIDTH.\n         BH    BADPARM\n         CLC   KTABMAXW,VALUELEN+1  CHECK FOR MINIMUM WIDTH.\n         BL    BADPARM\nDOROUT   DS    0H\n         L     R14,KTABROUT        GO TO THE PROPER ROUTINE.\n         BR    R14\n         DROP  R11\nMVCVALUE MVC   VALUE(*-*),0(R2)\nDOKEY    DS    0H                 TYPE IS KEY.\n         USING KTABLE,R11\n         L     R11,KTABVTAB       R11 = A(VALUE TABLE).\n         DROP  R11\n         L     R14,0(,11)         R14 = A(ROUTINE).\n         LA    R11,4(,R11)        R11 = A(VALUES).\n         USING VTABLE,R11\nVALLOOP  DS    0H                 DO TABLE LOOKUP.\n         CLI   VTABKEY,X'FF'      IF AT END, UNKNOWN VALUE.\n         BE    BADPARM\n         CLC   VTABKEYL,VALUELEN+1 LENGTHS MUST MATCH.\n         BNE   NXTVALUE\n         LH    R4,VALUELEN\n         BCTR  R4,0\n         EX    R4,CLCVALUE        DO COMPARE.\n         BE    GOTVALUE\nNXTVALUE DS    0H\n         LA    R11,VTABLEN(,R11)  BUMP TO NEXT ENTRY.\n         B     VALLOOP\nGOTVALUE DS    0H\n         MVC   VALUEFLG,VTABVAL   GOT HIT: MOVE VALUE FLAG.\n         BR    R14\nCLCVALUE CLC   VTABKEY(*-*),0(R2)\n         DROP  R11\nDONUM    DS    0H                 TYPE IS NUM.\n         LA    R4,VALUE\n         LH    R5,VALUELEN\nNUMLOOP  DS    0H                 VERIFY NUMERIC.\n         CLI   0(R4),C'0'            SCAN\n         BL    BADPARM              FORWARD\n         CLI   0(R4),C'9'            SCAN\n         BH    BADPARM              FORWARD\n         LA    R4,1(,R4)              TO FIRST\n         BCT   R5,NUMLOOP\n         B     DOROUT             GO TO ROUTINE.\nDOFLG    DS    0H                 TYPE IS KEY.\n         USING KTABLE,R11\n         L     R14,KTABROUT       R14 = A(ROUTINE).\n         DROP  R11\n         L     R11,=A(FLGTAB)     R11 = A(VALUE TABLE).\n         USING VTABLE,R11\nFLGLOOP  DS    0H\n         CLI   VTABKEY,X'FF'      IF AT END, BAD PARM.\n         BE    BADPARM\n         CLC   VTABKEYL,VALUELEN+1 CHECK LENGTHS.\n         BNE   NXTFLVAL\n         LH    R4,VALUELEN\n         BCTR  R4,0\n         EX    R4,CLCVALUE        COMPARE VALUES.\n         BE    GOTFLG\nNXTFLVAL DS    0H\n         LA    R11,VTABLEN(,R11)  BUMP TO NEXT ENTRY.\n         B     FLGLOOP\nGOTFLG   DS    0H\n         MVC   VALUEFLG,VTABVAL   GOT HIT: MOVE IN FLAG VALUE.\n         BR    R14\nDOMAJOR  DS    0H                 THE MAJOR= ROUTINE.\n         TM    PARM1,GOTMAJOR     ALLOW ONLY ONE SPECIFICATION.\n         BO    BADPARM\n         MVC   MAJORLEN,VALUELEN  MOVE VALUE.\n         MVC   MAJOR,VALUE        MOVE VALUE.\n         OI    PARM1,GOTMAJOR     INDICATE WE HAVE A VALUE.\n         B     NXTPARM\nDOACTION DS    0H                 THE ACTION= ROUTINE.\n         TM    PARM1,GOTACT       ALLOW ONLY ONE SPECIFICATION.\n         BO    BADPARM\n         MVC   ACTION,VALUEFLG\n         OI    PARM1,GOTACT       INDICATE WE HAVE A VALUE.\n         B     NXTPARM\nDOCONTRL DS    0H                 THE CONTROL= ROUTINE.\n         TM    PARM1,GOTCONT      ALLOW ONLY ONE SPECIFICATION.\n         BO    BADPARM\n         MVC   CONTROL,VALUEFLG\n         OI    PARM1,GOTCONT      INDICATE WE HAVE A VALUE.\n         B     NXTPARM\nDOJOB    DS    0H                 THE JOB= ROUTINE.\n         TM    PARM1,GOTJOB       ALLOW ONLY ONE SPECIFICATION.\n         BO    BADPARM\n         MVC   JOBLEN,VALUELEN    MOVE VALUE.\n         MVC   JOB,VALUE\n         OI    PARM1,GOTJOB       INDICATE WE HAVE A VALUE.\n         LH    R4,JOBLEN          CHECK FOR A MASK.\n         LA    R5,JOB-1(R4)\n         CLI   0(R5),C'*'\n         BNE   NOJOBMSK\n         BCTR  R4,0\n         STH   R4,JOBLEN          GOT MASK: INDICATE THUSLY.\n         OI    MASK,GOTJOB\nNOJOBMSK DS    0H\n         B     NXTPARM\nDOMINOR  DS    0H                 THE MINOR= ROUTINE.\n         TM    PARM1,GOTMINOR     ALLOW ONLY ONE SPECIFICATION.\n         BO    BADPARM\n         MVC   MINORLEN,VALUELEN  SAVE THE LENGTH.\n         MVC   MINOR,VALUE\n         OI    PARM1,GOTMINOR     INDICATE WE HAVE A VALUE.\n         LH    R4,MINORLEN        CHECK FOR MASK.\n         LA    R5,MINOR-1(R4)\n         CLI   0(R5),C'*'\n         BNE   NOMINMSK\n         BCTR  R4,0\n         STH   R4,MINORLEN        GOT MASK: INDICATE THUSLY.\n         OI    MASK,GOTMINOR\nNOMINMSK DS    0H\n         B     NXTPARM\nDOMSG    DS    0H                 THE MSG= ROUTINE.\n         TM    PARM1,GOTMSG       ALLOW ONLY ONE SPECIFICATION.\n         BO    BADPARM\n         MVC   MSG,VALUEFLG\n         OI    PARM1,GOTMSG       INDICATE WE HAVE A VALUE.\n         B     NXTPARM\nDONAME   DS    0H                 THE NAME= ROUTINE.\n         TM    PARM1,GOTNAME      ALLOW ONLY ONE SPECIFICATION.\n         BO    BADPARM\n         MVC   NAME,VALUE\n         OI    PARM1,GOTNAME      INDICATE WE HAVE A VALUE.\n         B     NXTPARM\nDOSCOPE  DS    0H                 THE SCOPE= ROUTINE.\n         TM    PARM1,GOTSCOPE     ALLOW ONLY ONE SPECIFICATION.\n         BO    BADPARM\n         MVC   SCOPE,VALUEFLG\n         OI    PARM1,GOTSCOPE     INDICATE WE HAVE A VALUE.\n         B     NXTPARM\nDOSYSN   DS    0H                 THE SYSNAME= ROUTINE.             L04\n         TM    PARM2,GOTSYSN      ALLOW ONLY ONE SPECIFICATION.     L04\n         BO    BADPARM                                              L04\n         MVC   SYSNLEN,VALUELEN   SAVE THE LENGTH.                  L04\n         MVC   SYSNAME,VALUE                                        L04\n         OI    PARM2,GOTSYSN      INDICATE WE HAVE A VALUE.         L04\n         B     NXTPARM                                              L04\nDOTIME   DS    0H                 THE TIME= ROUTINE.\n         TM    PARM2,GOTTIME      ALLOW ONLY ONE SPECIFICATION.\n         BO    BADPARM\n         LH    R4,VALUELEN\n         BCTR  R4,0               MACHINE LENGTH.\n         EX    R4,PACKTIME        PACK SECONDS.\n         CVB   R5,DOUBLE          CONVERT TO BINARY.\n         CH    R5,=H'1'           TEST SECONDS\n         BL    BADPARM             FOR LIMITS.\n         CH    R5,=H'9999'\n         BH    BADPARM\n         OI    PARM2,GOTTIME      INDICATE WE HAVE A VALUE.\n         ST    R5,TIME             AND STORE.\n         B     NXTPARM\nPACKTIME PACK  DOUBLE,VALUE(*-*)\nDOWENQ   DS    0H                 THE WANTENQ= ROUTINE.\n         TM    PARM2,GOTWENQ      ALLOW ONLY ONE SPECIFICATION.\n         BO    BADPARM\n         MVC   WANTENQ,VALUEFLG\n         OI    PARM2,GOTWENQ      INDICATE WE HAVE A VALUE.\n         B     NXTPARM\nDOCHECK  DS    0H                 CONSISTENCY CHECKING.\n         TM    PARM1,GOTMAJOR     MAJOR IS REQUIRED.\n         BZ    BADPARM\n         TM    PARM1,GOTJOB       IF JOB= NOT FOUND, BETTER HAVE\n         BO    OKJOB                BOTH MAJOR= , MINOR=.\n         TM    PARM1,GOTMAJOR+GOTMINOR\n         BNO   BADPARM\nOKJOB    DS    0H\n         CLI   MSG,NO             BYPASS NEXT IF MSG=NO.\n         BE    OKNAME\n         TM    PARM1,GOTNAME      IF MSG=YES, MUST HAVE EITHER\n         BO    OKNAME               NAME= OR JOB=.\n         TM    PARM1,GOTJOB       IF ONLY JOB=, BETTER NOT BE MASK:\n         BZ    BADPARM              WILL BE UNINTELLIGBLE MESSAGE.\n         TM    MASK,GOTJOB\n         BO    BADPARM\n         MVC   NAME,JOB           USE JOB= VALUE IN MESSAGE.\nOKNAME   DS    0H\n         B     ENDPARM\nENDPARM  DS    0H\n         DROP  R11\n********************************************************************\n*                                                                  *\n*        T E S T   F O R   E N Q                                   *\n*                                                                  *\n********************************************************************\n         MVC   TIMELIM,TIME       INIT ELAPSED TIME COUNTER.\nDOSCAN   DS    0H\n         MVC   GQSCAN(GQSCANL),XGQSCAN\n         TM    PARM1,GOTMINOR     ISSUE A DIFFERENT GQSCAN FOR MINOR.\n         BO    GQMINOR\n         GQSCAN AREA=(WRKRIB,WRKRIBL),RESNAME=(MAJOR),                 X\n               MF=(E,GQSCAN)\n         B     GQRC\nGQMINOR  DS    0H\n         LH    R3,MINORLEN\n         TM    MASK,GOTMINOR                                        L03\n         BO    GQMINGEN                                             L03\n         GQSCAN AREA=(WRKRIB,WRKRIBL),RESNAME=(MAJOR,MINOR,(R3)),      X\n               MF=(E,GQSCAN)\n         B     GQRC                                                 L03\nGQMINGEN DS    0H                                                   L03\n       GQSCAN AREA=(WRKRIB,WRKRIBL),RESNAME=(MAJOR,MINOR,(R3),GENERIC),X\n               MF=(E,GQSCAN)                                        L03\n         B     GQRC                                                 L03\nGQRC     DS    0H\n         LTR   R15,R15            IF A BAD RC,\n         BZ    GOTRIBS              LEAVE.\n         CH    R15,=H'4'          IF NO ONE HAS RESOURCE,\n         BE    NOHIT                WAIT A BIT.\n         B     BADSCAN              WAIT A BIT.\nGOTRIBS  DS    0H\n         LR    R4,R1              R1 = # RIBS RETURNED.\n         LA    R11,WRKRIB         R11 = A(1ST RIB).\n         USING RIB,R11\nDORIB    DS    0H                 LOOP THRU RIBS.\n         CLI   SCOPE,ANY          CHECK FOR MATCHING SCOPE=.\n         BE    OKSCOPE\n         CLI   SCOPE,STEP         SCOPE=STEP ROUTINE.\n         BNE   NOTSTEP\n         TM    RIBSCOPE,RIBSTEP\n         BZ    NEXTRIB\nNOTSTEP  DS    0H\n         CLI   SCOPE,SYSTEMS      SCOPE=SYSTEMS ROUTINE.\n         BNE   NOTSYSS\n         TM    RIBSCOPE,RIBSYSS\n         BZ    NEXTRIB\nNOTSYSS  DS    0H\n         TM    RIBSCOPE,RIBSYS    SCOPE=SYSTEM ROUTINE.\n         BZ    NEXTRIB\nOKSCOPE  DS    0H\n         LH    R2,RIBVLEN         R2 = L(VARIABLE PORTION OF RIB).\n         LA    R10,RIBEND(R2)     R10 = A(FIRST RIBE).\n         USING RIBE,R10\n         L     R5,RIBNRIBE        R5 = # RIBES.\nDORIBE   DS    0H                                                   L04\n         TM    PARM2,GOTSYSN      CHECK FOR MATCHING SYSNAME=       L04\n         BZ    OKRIBESN                                             L04\n         CLC   SYSNAME,RIBESYSN                                     L04\n         BNE   NEXTRIBE                                             L04\nOKRIBESN DS    0H\n         TM    PARM1,GOTJOB       CHECK FOR MATCHING JOB= .\n         BZ    OKRIBEJB\n         LA    R6,L'RIBEJBNM-1    DEFAULT LENGTH.\n         TM    MASK,GOTJOB        IF MASK, DO COMPARE AS IS.\n         BZ    *+10\n         LH    R6,JOBLEN          ELSE USE JOB= LENGTH.\n         BCTR  R6,0\n         EX    R6,CLCJOBNM        IF THIS RIBE IS OUR TARGET JOB,\n         BNE   NEXTRIBE             OKEYDOKE, EXIT.\nOKRIBEJB DS    0H\n         TM    RIBESFLG,RIBESTAT  CHECK FOR MATCHING CONTROL=.\n         BZ    NEXTRIBE\n         CLI   CONTROL,ANY        IF C=ANY, NO MATCHING NECESSARY.\n         BE    OKCONT                                               L03\n         CLI   CONTROL,SHR        C=SHR ROUTINE.\n         BNE   NOTSHR\n         TM    RIBERFLG,RIBETYPE\n         BO    OKCONT\n         B     NEXTRIBE\nNOTSHR   DS    0H\n         TM    RIBERFLG,RIBETYPE  C=EXC ROUTINE.\n         BZ    OKCONT\n         B     NEXTRIBE\nOKCONT   DS    0H\n         B     GOTHIT\nNEXTRIBE DS    0H\n         LA    R10,RIBEEND-RIBE(,R10)\n         BCT   R5,DORIBE          LOOP UNTIL DONE.\nNEXTRIB  DS    0H\n         LH    R2,RIBVLEN         CALCUTE THE ADDRESS OF THE\n         L     R3,RIBNRIBE          NEXT RIB.\n         MH    R3,=Y(RIBEEND-RIBE)\n         LA    R2,RIBEND-RIB(R3,R2)\n         LA    R11,0(R2,R11)      R11 = A(NEXT RIB).\n         BCT   R4,DORIB           LOOP UNTIL DONE.\n         B     NOHIT\nGOTHIT   DS    0H\n         CLI   WANTENQ,HELD       GOTHIT, DO WE WANT ONE?\n         BE    RETURN\n         B     DOWAIT\nNOHIT    DS    0H\n         CLI   WANTENQ,NOTHELD    NO HIT, DO WE NOT WANT ONE?\n         BE    RETURN\n         B     DOWAIT\nCLCJOBNM CLC   JOB(*-*),RIBEJBNM  IF THIS RIBE IS OUR TARGET JOB,\n         DROP  R11,R10\n********************************************************************\n*                                                                  *\n*        W A I T                                                   *\n*                                                                  *\n********************************************************************\nDOWAIT   DS    0H\n         CLC   TIMELIM,TIME       IF FIRST TIME THRU, CHECK\n         BNE   DOSTIMER             FOR ACTION=.\n         CLI   ACTION,ABEND       IF ACT=ABEND, DO IT.\n         BE    BADLIM\n         CLI   MSG,YES            IF MSG=YES, DO IT.\n         BNE   DOSTIMER\n         BAL   R4,INITMSG         FORMAT OUR WAITING MESSAGE.\nDOSTIMER DS    0H\n         STIMER WAIT,BINTVL==F'500' WAIT FOR 5 SECONDS.\n         L     R2,TIMELIM         SUBTRACT 5 SECONDS.\n         SH    R2,=H'5'\n         BNP   BADLIM\n         ST    R2,TIMELIM\n         B     DOSCAN             THEN HANG IT UP.\n********************************************************************\n*                                                                  *\n*        R E T U R N                                               *\n*                                                                  *\n********************************************************************\nRETURN   DS    0H\n         TM    WTOFLG,NEEDDOM\n         BZ    *+8\n         BAL   R4,DODOM\n         L     R2,RC                  R2 = RC.\n         LR    R1,R13              PREPARE\n         L     R13,4(,R13)         FOR FREEMAIN.\n         FREEMAIN RU,LV=DYNLEN,A=(1)\n         LR    R15,R2              AND RETURN\n         RETURN (14,12),RC=(15)      WITH R15 = RC.\nDODOM    DS    0H\n         L     R1,MSGID\n         DOM   MSG=(1)            DODOM IF REQUIRED.\n         STIMER WAIT,BINTVL==F'250' WAIT FOR 2.5 SECONDS.\n         BR    R4\n********************************************************************\n*                                                                  *\n*        M E S S A G E S                                           *\n*                                                                  *\n********************************************************************\nBADPARM  DS    0H                 FORMAT THE BAD PARM MESSAGE.      L03\n         MVC   RC,=F'12'          RC = 12.                          L03\n         BAL   R14,FMTMSG         INIT MSG AREA.                    L03\n         MVC   MSGTEXT(L'MSGPARM),MSGPARM                           L03\n         LA    R4,DOABEND                                           L03\n         B     DOMESSAG                                             L03\nBADSCAN  DS    0H                 FORMAT THE BAD SCAN MESSAGE.      L03\n         MVC   RC,=F'12'          RC = 12.                          L03\n         BAL   R14,FMTMSG         INIT MSG AREA.                    L03\n         MVC   MSGTEXT(L'MSGSCAN),MSGSCAN                           L03\n         LA    R4,DOABEND                                           L03\n         B     DOMESSAG                                             L03\nBADLIM   DS    0H                 FORMAT THE EXCEEDED LIMIT MESSAGE.L03\n         MVC   RC,=F'12'          RC = 12.                          L03\n         CLI   MSG,YES            IF MSG \u00ac= YES,                    L03\n         BNE   DOABEND              DON'T ISSUE MSG.                L03\n         BAL   R14,FMTMSG         INIT MSG AREA.                    L03\n         MVC   MSGTEXT(L'MSGLIM),MSGLIM                             L03\n         MVC   MSGLJOB,NAME                                         L03\n         MVC   MSGLSTOP,=CL6'START.'                                L04\n         CLI   WANTENQ,HELD                                         L03\n         BE    *+10                                                 L03\n         MVC   MSGLSTOP,=CL6'STOP. ' ONLY IF WANTENQ=NOTHELD.       L04\n         OI    WTOFLG,NONROLL\n         LA    R4,DOABEND\n         B     DOMESSAG\nINITMSG  DS    0H                 FORMAT THE  WAITING MESSAGE.      L03\n         BAL   R14,FMTMSG         INIT MSG AREA.                    L03\n         MVC   MSGTEXT(L'MSGINIT),MSGINIT MOVE IN MSGLOG1 TEXT.     L03\n         MVC   MSGIJOB,NAME                                         L03\n         MVC   MSGISTOP,=CL6'START.'                                L04\n         CLI   WANTENQ,HELD\n         BE    *+10\n         MVC   MSGISTOP,=CL6'STOP .' ONLY IF WANTENQ=NOTHELD.       L04\n         TM    PARM2,GOTSYSN                                        L04\n         BZ    OKISYSN                                              L04\n         MVI   MSGISYSN-1,C' '                                      L04\n         MVC   MSGISYSN(2),=CL2'ON'                                 L04\n         MVC   MSGISYSN+3(L'SYSNAME),SYSNAME                        L04\n         LH    R2,SYSNLEN                                           L04\n         LA    R2,MSGISYSN+3(R2)                                    L04\n         MVI   0(R2),C'.'                                           L04\nOKISYSN  DS    0H                                                   L04\n         OI    WTOFLG,NONROLL+SAVMSGID  INDICATE NONROLL, SAVE MSGID.\n         B     DOMESSAG\n********************************************************************\n*                                                                  *\n*        D O   M E S S A G E S.                                    *\n*                                                                  *\n********************************************************************\nDOMESSAG DS    0H\n         CLI   TSO,YES            ISSUE TPUT FOR TSO.\n         BE    DOTPUT\n         MVC   WTO(WTOL),XWTO     ELSE DO WTO.                      L03\n         MVC   WTOMSG(L'MSGAREA),MSGAREA                            L03\n         TM    WTOFLG,NONROLL\n         BZ    *+8\n         MVI   WTODESC,X'40'\nDOWTO    DS    0H\n         WTO   MF=(E,WTO)\n         TM    WTOFLG,SAVMSGID\n         BZ    *+12\n         ST    R1,MSGID\n         OI    WTOFLG,NEEDDOM\n         NI    WTOFLG,255-(NONROLL+SAVMSGID)\n         BR    R4\nDOTPUT   DS    0H\n         MVC   TPUT(TPUTL),XTPUT\n         TPUT  MSGAREA,L'MSGAREA,MF=(E,TPUT)                        L03\n         BR    R4\nMVCWTO   MVC   WTOMSG(*-*),0(R2)\nDOABEND  DS    0H\n         TM    WTOFLG,NEEDDOM\n         BZ    *+8\n         BAL   R4,DODOM\n         ABEND 123\n********************************************************************L03\n*                                                                  *L03\n*        F O R M A T   M E S S A G E   H E A D E R                 *L03\n*                                                                  *L03\n********************************************************************L03\nFMTMSG   DS    0H                                                   L03\n         MVI   MSGAREA,C' '       BLANK MSGTEXT.                    L03\n         MVC   MSGAREA+1(L'MSGAREA-1),MSGAREA                       L03\n         MVC   MSGJOB,OURJOB       MOVE IN OUR ADABAS JOBNAME.      L03\n         MVI   MSGCOLON,C':'      THEN A COLON.                     L03\n         BR    R14                RETURN.                           L03\n********************************************************************\n*                                                                  *\n*        S T A T I C   A R E A                                     *\n*                                                                  *\n********************************************************************\nXGQSCAN  GQSCAN ,SCOPE=ALL,MF=L\nGQSCANL  EQU   *-XGQSCAN\nXWTO     WTO   '                                                       X\n                                            ',MF=L,ROUTCDE=11\nWTOL     EQU   *-XWTO\nXTPUT    TPUT  0,0,EDIT,WAIT,,BREAKIN,MF=L\nTPUTL    EQU   *-XTPUT\nMSGINIT  DC    C'IS WAITING FOR          TO                   '     L04\nMSGPARM  DC    C'THE PARM FIELD IS BAD, AN ABEND FOLLOWS.'          L03\nMSGSCAN  DC    C'BAD RC FROM GQSCAN SVC, AN ABEND FOLLOWS.'         L03\nMSGLIM   DC    C'         DIDN''T       IN TIME, ABENDING.'         L03\n         LTORG *\nSRCLEVEL DC    C'                                        '\nKWORDTAB CSECT ,                  PARAMETER KEYWORD TABLE.\n         DC    CL8'A=      ',AL1(2,KEY,0,0),A(ACTTAB)\n         DC    CL8'ACTION= ',AL1(7,KEY,0,0),A(ACTTAB)\n         DC    CL8'C=      ',AL1(2,KEY,0,0),A(CONTAB)\n         DC    CL8'CONTROL=',AL1(8,KEY,0,0),A(CONTAB)\n         DC    CL8'J=      ',AL1(2,CHR,1,8),A(DOJOB)\n         DC    CL8'JOB=    ',AL1(4,CHR,1,8),A(DOJOB)\n         DC    CL8'MAJ=    ',AL1(4,CHR,1,8),A(DOMAJOR)\n         DC    CL8'MAJOR=  ',AL1(6,CHR,1,8),A(DOMAJOR)\n         DC    CL8'MIN=    ',AL1(4,CHR,1,44),A(DOMINOR)\n         DC    CL8'MINOR=  ',AL1(6,CHR,1,44),A(DOMINOR)\n         DC    CL8'MSG=    ',AL1(4,FLG,0,0),A(DOMSG)\n         DC    CL8'N=      ',AL1(2,CHR,1,8),A(DONAME)\n         DC    CL8'NAME=   ',AL1(5,CHR,1,8),A(DONAME)\n         DC    CL8'S=      ',AL1(2,KEY,0,0),A(SCOPTAB)\n         DC    CL8'SCOPE=  ',AL1(6,KEY,0,0),A(SCOPTAB)\n         DC    CL8'SYS=    ',AL1(4,CHR,1,8),A(DOSYSN)               L04\n         DC    CL8'SYSNAME=',AL1(8,CHR,1,8),A(DOSYSN)               L04\n         DC    CL8'T=      ',AL1(2,NUM,1,3),A(DOTIME)\n         DC    CL8'TIME=   ',AL1(5,NUM,1,3),A(DOTIME)\n         DC    CL8'W=      ',AL1(2,KEY,0,0),A(WENQTAB)\n         DC    CL8'WANTENQ=',AL1(8,KEY,0,0),A(WENQTAB)\n         DC    X'FF'\nKTABLE   DSECT\nKTABKEY  DS    CL8\nKTABKEYL DS    AL1\nKTABTYPE DS    AL1\nKEY      EQU   X'01'\nCHR      EQU   X'02'\nNUM      EQU   X'04'\nFLG      EQU   X'08'\nKTABMINW DS    AL1\nKTABMAXW DS    AL1\nKTABROUT DS    A\n         ORG   KTABROUT\nKTABVTAB DS    A\nKTABLEN  EQU   *-KTABLE\nACTTAB   CSECT ,                  ACTION= TABLE.\n         DC    A(DOACTION)\n         DC    CL8'A       ',AL1(1,ABEND)\n         DC    CL8'ABEND   ',AL1(5,ABEND)\n         DC    CL8'W       ',AL1(1,WAIT)\n         DC    CL8'WAIT    ',AL1(4,WAIT)\n         DC    X'FF'\nCONTAB   CSECT ,                  CONTROL= TABLE.\n         DC    A(DOCONTRL)\n         DC    CL8'A       ',AL1(1,ANY)\n         DC    CL8'ANY     ',AL1(3,ANY)\n         DC    CL8'E       ',AL1(1,EXC)\n         DC    CL8'EXC     ',AL1(3,EXC)\n         DC    CL8'EXCLUSIV',AL1(8,EXC)\n         DC    CL8'S       ',AL1(1,SHR)\n         DC    CL8'SHR     ',AL1(3,SHR)\n         DC    CL8'SHARED  ',AL1(6,SHR)\n         DC    X'FF'\nSCOPTAB  CSECT ,                  SCOPE= TABLE.\n         DC    A(DOSCOPE)\n         DC    CL8'A       ',AL1(1,ANY)\n         DC    CL8'ANY     ',AL1(3,ANY)\n         DC    CL8'S       ',AL1(1,SYSTEM)\n         DC    CL8'SYS     ',AL1(3,SYSTEM)\n         DC    CL8'SYSTEM  ',AL1(6,SYSTEM)\n         DC    CL8'SYSS    ',AL1(4,SYSTEMS)\n         DC    CL8'SYSTEMS ',AL1(7,SYSTEMS)\n         DC    X'FF'\nWENQTAB  CSECT ,                  WANTENQ= TABLE.\n         DC    A(DOWENQ)\n         DC    CL8'H       ',AL1(1,HELD)\n         DC    CL8'HELD    ',AL1(4,HELD)\n         DC    CL8'N       ',AL1(1,NOTHELD)\n         DC    CL8'NOTHELD ',AL1(7,NOTHELD)\n         DC    X'FF'\nFLGTAB   CSECT ,                  FLAG TABLE.\n         DC    CL8'YES     ',AL1(3,YES)\n         DC    CL8'Y       ',AL1(1,YES)\n         DC    CL8'NO      ',AL1(2,NO)\n         DC    CL8'N       ',AL1(1,NO)\n         DC    X'FF'\nVTABLE   DSECT\nVTABKEY  DS    CL8\nVTABKEYL DS    AL1\nVTABVAL  DS    AL1\nVTABLEN  EQU   *-VTABLE\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   A R E A                                   *\n*                                                                  *\n********************************************************************\nDYNAMIC  DSECT\nSAVE     DS    18F .\nDOUBLE   DS    D\nRC       DS    F\nMSGID    DS    F\nVALUELEN DS    H\nVALUE    DS    CL100\nTIME     DS    F\nTIMELIM  DS    F\nMAJORLEN DS    H\nMAJOR    DS    CL8\nMINORLEN DS    H\nMINOR    DS    CL44\nOURJOB   DS    CL8\nJOBLEN   DS    H\nJOB      DS    CL8\nNAME     DS    CL8\nSYSNLEN  DS    H                                                    L04\nSYSNAME  DS    CL8                                                  L04\nTSO      DS    X\nNO       EQU   0\nYES      EQU   1\nVALUEFLG DS    X\nPARM1    DS    X\nGOTMAJOR EQU   X'01'\nGOTACT   EQU   X'02'\nGOTCONT  EQU   X'04'\nGOTJOB   EQU   X'08'\nGOTMINOR EQU   X'10'\nGOTMSG   EQU   X'20'\nGOTNAME  EQU   X'40'\nGOTSCOPE EQU   X'80'\nPARM2    DS    X\nGOTTIME  EQU   X'10'\nGOTWENQ  EQU   X'20'\nGOTSYSN  EQU   X'40'                                                L04\nMASK     DS    X\nACTION   DS    X\nWAIT     EQU   1\nABEND    EQU   2\nCONTROL  DS    X\nEXC      EQU   1\nSHR      EQU   2\nANY      EQU   255\nMSG      DS    X\nSCOPE    DS    X\nSTEP     EQU   1\nSYSTEM   EQU   2\nSYSTEMS  EQU   3\n*ANY     EQU   255\nWANTENQ  DS    X\nHELD     EQU   1\nNOTHELD  EQU   2\nWTOFLG   DS    X                                                    L03\nNONROLL  EQU   X'01'                                                L03\nSAVMSGID EQU   X'02'                                                L03\nNEEDDOM  EQU   X'04'                                                L03\nMSGAREA  DS    CL80                                                 L03\nMSGJOB   EQU   MSGAREA,8                                            L03\nMSGCOLON EQU   MSGAREA+8,1                                          L03\nMSGTEXT  EQU   MSGAREA+10,70                                        L03\nMSGLJOB  EQU   MSGTEXT,8                                            L03\nMSGIJOB  EQU   MSGTEXT+15,8                                         L03\nMSGLSTOP EQU   MSGTEXT+16,6                                         L03\nMSGISTOP EQU   MSGTEXT+27,6                                         L03\nMSGISYSN EQU   MSGTEXT+33,12\nGQSCAN   DS    0F,CL(GQSCANL)                                       L03\nTPUT     DS    0F,CL(TPUTL)                                         L03\nWTO      DS    0F,CL(WTOL)                                          L03\nWTOMSG   EQU   WTO+4,80                                             L03\nWTODESC  EQU   *-4,2                                                L03\nWRKRIB   DS    0F,64CL256\nWRKRIBL  EQU  *-WRKRIB\nDYNLEN   EQU   *-DYNAMIC\n         ISGRIB ,\n         IHAPSA ,\n         IHAASCB ,\n         PRINT OFF\nR0       EQU   00\nR1       EQU   01\nR2       EQU   02\nR3       EQU   03\nR4       EQU   04\nR5       EQU   05\nR6       EQU   06\nR7       EQU   07\nR8       EQU   08\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12                 PROGRAM BASE.\nR13      EQU   13                 A(SAVE AREA).\nR14      EQU   14\nR15      EQU   15\n         PRINT ON\n         END   &CSECT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FDSPACE": {"ttr": 3335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\xcf\\x00\\xcf\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 207, "newlines": 207, "modlines": 0, "user": "FILE369"}, "text": "/*********************************************************************\n/*\n/* CHANGE LOG -\n/*  12/05/86 PTW IMPLEMENTED\n/*\n/*********************************************************************\nISPEXEC VGET (NAME SORT ZDEL) PROFILE\nCONTROL NOFLUSH\n\nSET OLDNAME = &STR(&NAME)\nSET OLDSORT = &STR(&SORT)\n\nIF &STR(&NAME) = &STR( ) THEN +\n  DO\n    SET NAME    = ONLINE\n    SET OLDNAME = ONLINE\n  END\n\nSET MODLINE  = &STR( )\nISPEXEC DISPLAY  PANEL(FDSPACEP) MSG(FDS003)\n\nIF &LASTCC \u00ac= 8 THEN +\n  DO\n    REFRESH: +\n    CONTROL NOCONLIST NOLIST\n    ISPEXEC CONTROL  NONDISPL\n    SET MODLINE  = &STR( )\n    ISPEXEC DISPLAY  PANEL(FDSPACEP)\n    SET &M =\n    SET &MSGID =\n\n    ISPEXEC TBCREATE MEMTABLE REPLACE NOWRITE                  +\n                              KEYS(VOLUME UCB)                 +\n                              NAMES(VTOC CYL TRK EXT CYLC TRKC +\n                                    SORTUCB SORTFREE SORTCONT)\n\n    SET &SYSOUTTRAP = 256\n    DSPACE &NAME\n    SET &SYSOUTTRAP = 0\n\n    SET &LINE = 1\n    SET &SL   = &SYSOUTLINE\n    SET &LNES = &EVAL(&SYSOUTLINE - 1)\n\n    DO WHILE &LINE < &SL+1\n      SET &T = &&SYSOUTLINE&LINE\n      SET &SYSDVAL = &STR(&T)\n\n      READDVAL  &A &B &C &D &E &F &G\n\n      IF &A = &STR(VOLSER) THEN +\n        DO\n          SET STEXT = &STR(\"&NAME\" NOT FOUND)\n          SET LTEXT = &STR(+\n           VOLSER, UCB, OR UNIT \"&NAME\" NOT FOUND, REQUEST IGNORED)\n          SET MSGNUM = &STR(FDS000)\n          ISPEXEC SETMSG  MSG(&MSGNUM)\n        END\n      ELSE +\n        DO\n          IF &SUBSTR(1:3,&A) \u00ac= &STR(VOL)  THEN +\n            DO\n              SET VOLUME   = &A\n              IF &B = &STR(I) THEN +\n                DO\n                  SET VTOC     = &B\n                  SET UCB      = &C\n                  SET CYL      = &SUBSTR(7:10,&D)\n                  SET TRK      = &STR(&E)\n                  SET EXT      = &SUBSTR(1:4,&STR(&F))\n                  SET CYLC     = &SUBSTR(6:9,&STR(&F))\n                  SET TRKC     = &STR(&G)\n                END\n              IF &B \u00ac= &STR(I)       AND  +\n                 &B \u00ac= &STR(OFFLINE) THEN +\n                DO\n                  SET VTOC     = &STR( )\n                  SET UCB      = &B\n                  SET CYL      = &SUBSTR(7:10,&C)\n                  SET TRK      = &STR(&D)\n                  SET EXT      = &SUBSTR(1:4,&STR(&E))\n                  SET CYLC     = &SUBSTR(6:9,&STR(&E))\n                  SET TRKC     = &STR(&F)\n                END\n              IF &STR(&B) = &STR(OFFLINE) THEN +\n                DO\n                  SET VOLUME   = &STR( )\n                  SET VTOC     = &B\n                  SET UCB      = &A\n                  SET CYL      = &STR( )\n                  SET TRK      = &STR( )\n                  SET EXT      = &STR( )\n                  SET CYLC     = &STR( )\n                  SET TRKC     = &STR( )\n                END\n              SET CNTR = 1\n              DO WHILE &CNTR <= 3\n                SET W&CNTR = &SUBSTR(&CNTR,&UCB)\n                SET DIGIT = &SUBSTR(&CNTR,&UCB)\n                IF &DIGIT = &STR(A) THEN SET W&CNTR = 10\n                IF &DIGIT = &STR(B) THEN SET W&CNTR = 11\n                IF &DIGIT = &STR(C) THEN SET W&CNTR = 12\n                IF &DIGIT = &STR(D) THEN SET W&CNTR = 13\n                IF &DIGIT = &STR(E) THEN SET W&CNTR = 14\n                IF &DIGIT = &STR(F) THEN SET W&CNTR = 15\n                SET CNTR = &CNTR + 1\n              END\n              SET SORTUCB  = &EVAL(&W1*256 + &W2*16 + &W3)\n              SET SORTFREE = &STR(&CYL || &TRK)\n              SET SORTCONT = &STR(&CYLC || &TRKC)\n              SET LNEC     = &LINE - 1\n              IF &EVAL(&LNEC//50) = 0 THEN +\n                DO\n                  ISPEXEC SETMSG   MSG(FDS004)\n                  ISPEXEC CONTROL  DISPLAY LOCK\n                  ISPEXEC DISPLAY  MSG(FDS004)\n                END\n              ISPEXEC TBADD    MEMTABLE\n              ISPEXEC TBVCLEAR MEMTABLE\n            END\n        END\n      SET &LINE = &LINE+1\n    END\n\n/*CONTROL LIST CONLIST\n\n    RESORT: +\n    IF &SORT =   THEN ISPEXEC TBSORT MEMTABLE FIELDS(VOLUME   C A  +\n                                                     SORTUCB  N A)\n    IF &SORT = 1 THEN ISPEXEC TBSORT MEMTABLE FIELDS(VOLUME   C A  +\n                                                     SORTUCB  N A)\n    IF &SORT = 2 THEN ISPEXEC TBSORT MEMTABLE FIELDS(SORTUCB  N A)\n    IF &SORT = 3 THEN ISPEXEC TBSORT MEMTABLE FIELDS(SORTFREE B D)\n    IF &SORT = 4 THEN ISPEXEC TBSORT MEMTABLE FIELDS(SORTCONT B D)\n    ISPEXEC TBTOP   MEMTABLE\n    SET MODLINE = &STR(           +\n         _S#VOLUME  @UCB  @VTOC   @CYL  @TRK    @EXT   @CYLC @TRKC)\n    ISPEXEC TBDISPL MEMTABLE PANEL(FDSPACEP) +\n                             POSITION(ROW)   +\n                             AUTOSEL(NO)     +\n                             MSG(&MSGNUM)\n    SET &TBDRC  = &LASTCC\n\n    DO WHILE &TBDRC < 8\n      IF &STR(&MSGNUM) \u00ac= &STR( ) THEN +\n        DO\n          SET OLDNAME = &STR(&NAME)\n          SET &MSGNUM = &STR( )\n          GOTO REFRESH\n        END\n      ELSE +\n        SET &MSGNUM = &STR( )\n\n      IF &STR(&NAME) \u00ac= &STR(&OLDNAME) THEN +\n        DO\n          SET OLDNAME = &STR(&NAME)\n          GOTO REFRESH\n        END\n\n      IF &STR(&SORT) \u00ac= &STR(&OLDSORT) THEN +\n        DO\n          SET OLDSORT = &STR(&SORT)\n          GOTO RESORT\n        END\n\n      IF &ZTDSELS > 0 THEN +\n        DO\n          IF &STR(&VTOC) = &STR(OFFLINE) THEN +\n            DO\n              ISPEXEC SETMSG  MSG(FDS001)\n              ISPEXEC TBDISPL MEMTABLE POSITION(ROW) +\n                                       AUTOSEL(NO)   +\n                                       CSRROW(&ROW)  +\n                                       MSG(FDS001)\n              SET &TBDRC = &LASTCC\n            END\n          ELSE +\n            DO\n              SET PRCMOD  = &STR(FDSPACE)\n              ISPEXEC VPUT (PRCMOD VOLUME) SHARED\n\n              ISPEXEC CONTROL DISPLAY SAVE\n              ISPEXEC CONTROL NONDISPL ENTER\n              ISPEXEC SELECT PGM(ISRUDL)\n              ISPEXEC CONTROL DISPLAY RESTORE\n\n              SET PRCMOD = &STR( )\n              SET VOLUME = &STR( )\n              ISPEXEC VPUT (PRCMOD VOLUME) SHARED\n\n              ISPEXEC TBDISPL MEMTABLE POSITION(ROW) +\n                                       AUTOSEL(NO)   +\n                                       CSRROW(&ROW)\n              SET &TBDRC = &LASTCC\n            END\n        END\n      ELSE +\n        DO\n          ISPEXEC TBDISPL MEMTABLE POSITION(ROW)\n          SET &TBDRC = &LASTCC\n        END\n      CONTROL NOLIST NOCONLIST\n    END\n    ISPEXEC TBEND MEMTABLE\n    ISPEXEC VPUT (NAME SORT) PROFILE\n  END\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FDSPACEP": {"ttr": 3339, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00<\\x00<\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 60, "newlines": 60, "modlines": 0, "user": "FILE369"}, "text": ")ATTR\n _ TYPE(INPUT)  INTENS(HIGH) CAPS(ON)\n # TYPE(OUTPUT) INTENS(HIGH) SKIP(OFF)\n @ TYPE(OUTPUT) INTENS(LOW)  SKIP(ON)\n)BODY WIDTH(80)\n%---------------------------- D A S D   S P A C E ------------------------------\n%COMMAND ===>_ZCMD                                            %SCROLL ===>_ZUSC+\n%                                                                              +\n+   NAME%===>_NAME    +\n+SORT BY%===>_Z+  (%1+= VOLSER;%2+= DEV NUM;%3+= TOTAL FREE;%4+= MAX CONTIG )\n%                                                                              +\n%                      DEV    IX     TOTAL FREE    EXT    MAX CONTIG\n%             VOLSER   NUM   VTOC    CYLS  TRKS    NUM    CYLS  TRKS\n+===============================================================================\n)MODEL\n&MODLINE\n)INIT\n\n .CURSOR = NAME\n .ZVARS  = 'SORT'\n &S      = ' '\n\n &OLDNAME = &NAME\n &OLDSORT = &SORT\n\n)REINIT\n\n REFRESH *\n\n IF (&S = ' ')\n   .CURSOR = NAME\n &S      = ' '\n\n)PROC\n\n VER (&S,LIST,B,S,MSG=FDS002)\n VER (&SORT,LIST,1,2,3,4,MSG=FDS002)\n\n &NAME = TRUNC(&NAME,' ')\n &NAME = '&NAME..'\n &NAME = TRUNC(&NAME,'*')\n &XTRA = .TRAIL\n IF (&XTRA = &Z)\n   &NAME = TRUNC(&NAME,'.')\n IF (&XTRA \u00ac= &Z)\n   &NAME = '&NAME.*'\n\n\n IF (&NAME = &Z)\n   &NAME = '&OLDNAME'\n\n IF (&SORT = &Z)\n   &SORT = '&OLDSORT'\n\n)END\n/*\n/* SAMPLE MODEL LINE FOLLOWS:\n/*\n/*         _S#VOLUME  @UCB  @VTOC   @CYL  @TRK    @EXT   @CYLC @TRKC\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FDS00": {"ttr": 3585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "FILE369"}, "text": "FDS000  '&STEXT'                   .ALARM=YES\n'&LTEXT..'\n\nFDS001  '&UCB OFFLINE; HIT ENTER '     .ALARM=YES\n'DISPLAYS CAN NOT BE PERFORMED ON OFFLINE DEVICES; HIT \"ENTER\" TO CONTINUE.'\n\nFDS002  'INVALID SELECT CODE     '    .ALARM=YES\n'VALID CODES FOR VTOC MAPS ARE \"S\" OR \"B\".'\n\nFDS003  'HIT \"ENTER\" TO CONTINUE '    .ALARM=YES\n'MAKE CHANGES TO \"NAMES\" OR \"SORT\" AS APPROPRIATE... HIT \"ENTER\" TO CONTINUE.'\n\nFDS004  'LINE &LNEC OF &LNES     '    .ALARM=YES\n' '\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FSAS": {"ttr": 3587, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00V\\x00V\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 86, "newlines": 86, "modlines": 0, "user": "FILE369"}, "text": "PROC 0 WORK(900) BLOCK(4114) QUAL(SAS) SORT(YES) SORTWORK(5) FMT(YES) +\n       GRAPH(YES) +\n       SASUTL  ('APS1.SAS.UTILLIB') +\n       SASHELP ('APS1.SAS.SASHELP') +\n       SASAUTOS('APS1.SAS.MACAUTOS') +\n       SASMSGS ('APS1.SAS.SASMSGS')\n/* LAST CHANGE:\n/* 04/20/87 PTW ALL PROFILE VARS BEGIN WITH SAS, FIX SASOPT BUG.\nCONTROL NOLIST NOCONLIST NOFLUSH NOMSG MAIN END(END)\nISPEXEC CONTROL ERRORS RETURN\nFREE F(SASPGM,FT11F001,FT12F001,FT14F001,SASLIB,LIBRARY,+\n  WORK,PRINTTO,SASUTL,SASHELP,SASAUTOS,SASMSGS) ATTRLIST(SASP,PO)\nATTRIB SASP RECFM(V B A) LRECL(137) BLKSIZE(&BLOCK.)\nATTRIB PO   DSORG(PO)\nALLOC F(WORK) BLOCK(6394) SPACE(&WORK. 20)\n/* ALLOCATE FORMAT LIBRARY.\nIF &FMT = &STR(YES) THEN +\n  DO\n    DEL &QUAL..LIB\n    ALLOC F(LIBRARY) TRACK SPACE(15 5) USING(PO) DI(10) +\n      DA(&QUAL..LIB)\n    ALLOC F(SASLIB) DA(&QUAL..LIB) SHR\n  END\n/* ALLOCATE SAS LOG.\nALLOC DA(&QUAL..LOG) F(FT11F001) SHR\nIF &LASTCC NE 0 THEN +\n  ALLOC F(FT11F001) DA(&QUAL..LOG) NEW TRA +\n    USING(SASP) SPACE(10 10)\n/* ALLOCATE SAS LIST.\nALLOC DA(&QUAL..LIST) F(FT12F001) USING(SASP) SHR\nIF &LASTCC NE 0 THEN +\n  ALLOC F(FT12F001) DA(&QUAL..LIST) NEW TRA +\n    USING(SASP) SPACE(10 10)\n/* ALLOCATE GRAPHICS FILES.\nIF &GRAPH = &STR(YES) THEN +\n  ALLOC F(FT14F001) DA(*)\n/* ALLOCATE SPECIAL SAS STATEMENT FOR PROC PRINTTO.\nALLOC DA(&QUAL..PRINTTO) F(PRINTTO) SHR\nIF &LASTCC NE 0 THEN +\n  DO\n    ALLOC F(PRINTTO) DA(&QUAL..PRINTTO) NEW BLOCK(80) SP(1 1)\n    OPENFILE PRINTTO OUTPUT\n    SET PRINTTO=&STR(PROC PRINTTO UNIT=12 NEW;)\n    PUTFILE  PRINTTO\n    CLOSFILE PRINTTO\n    FREE F(PRINTTO)\n  END\n/* ALLOCATE SORT FILES.\nIF &SORT = &STR(YES) THEN +\n  DO\n    FREE  F(SORTLIB,SORTWK01,SORTWK02,SORTWK03,SYSOUT,SYSORT)\n /* ALLOC F(SORTLIB) DA('SYS1.SYNCLIB') SHR\n    ALLOC F(SORTWK01) BLOCK(13030) SPACE(&SORTWORK.)\n    ALLOC F(SORTWK02) BLOCK(13030) SPACE(&SORTWORK.)\n    ALLOC F(SORTWK03) BLOCK(13030) SPACE(&SORTWORK.)\n    ALLOC F(SYSOUT) DUMMY BLOCK(80)\n    ALLOC F(SYSORT) DUMMY BLOCK(80)\n  END\n/* ALLOCATE V5 LIBRARIES.\nALLOC F(SASUTL  ) DA('&SASUTL'  ) SHR\nALLOC F(SASHELP ) DA('&SASHELP' ) SHR\nALLOC F(SASAUTOS) DA('&SASAUTOS') SHR\nALLOC F(SASMSGS)  DA('&SASMSGS') SHR\nSET &ERRMSG = &STR()\nSET &ERRSM  = &STR()\nSET &ERRLM  = &STR()\nISPEXEC VPUT (QUAL ERRMSG ERRSM ERRLM) SHARED\nISPEXEC VGET (SASPGM,SASOPT,SASPDEST,+\n              SASDD1,SASDD2,SASDD3,+\n              SASDSN1,SASDSN2,SASDSN3,+\n              SASDISP1,SASDISP2,SASDISP3,+\n              SASP1,SASP2,SASP3) PROFILE\nSET &RC = &LASTCC\nIF  &RC = 8 THEN +\n  ISPEXEC VPUT (SASPGM,SASOPT,SASPDEST,+\n                SASDD1,SASDD2,SASDD3,+\n                SASDSN1,SASDSN2,SASDSN3,+\n                SASDISP1,SASDISP2,SASDISP3,+\n                SASP1,SASP2,SASP3) PROFILE\nISPEXEC SELECT PANEL(FSASP)\nFREE F(SASPGM,FT11F001,FT12F001,FT14F001,SASLIB,LIBRARY,+\n  WORK,PRINTTO,SORTWK01,SORTWK02,SORTWK03,SYSOUT,SYSORT,+\n  SASUTL,SASHELP,SASAUTOS,SASMSGS) +\n  ATTRLIST(SASP,PO)\nEXIT CODE(0)\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FSASCMD": {"ttr": 3590, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x01\\x0c\\x01\\x0c\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 268, "newlines": 268, "modlines": 0, "user": "FILE369"}, "text": "PROC 0  LOADLIB('APS1.SAS.LIBRARY')\n  CONTROL NOLIST NOCONLIST MSG NOFLUSH NOPROMPT END(END)\n  ISPEXEC CONTROL ERRORS RETURN\n  ISPEXEC VGET (TYPE,QUAL,ERRSM,ERRLM,ERRMSG) SHARED\n  ISPEXEC VGET (SASPGM,SASOPT,SASPDEST,+\n                SASDD1,SASDD2,SASDD3,+\n                SASDSN1,SASDSN2,SASDSN3,+\n                SASDISP1,SASDISP2,SASDISP3,+\n                SASP1,SASP2,SASP3) PROFILE\n  SET &ZERRSM  = &STR()\n  SET &ZERRLM  = &STR()\n  ISPEXEC VPUT (ZERRSM,ZERRLM) SHARED\n  SET &ERRMSG = &STR()\n  SET &ERRSM  = &STR()\n  SET &ERRLM  = &STR()\n/* PROCESS A CHANGE PROGRAM.\n  IF &TYPE = C OR &TYPE = E THEN +\n    DO\n      SET &SASDSN =\n      SET &SASMEM =\n      ISPEXEC VPUT (SASDSN,SASMEM) SHARED\n      ISPEXEC EDIT DATASET(&SASPGM) MACRO(FSASEMAC)\n      SET &DSNAME = &SASPGM\n      ISPEXEC VPUT (DSNAME) SHARED\n      ISPEXEC VGET (SASDSN,SASMEM) SHARED\n      SET &MEMBER = &SASMEM\n      SET &ERRSM  = &ZERRSM\n      SET &ERRLM  = &ZERRLM\n      SET &A = &LENGTH(&DSNAME)\n      SET &B = &SUBSTR(&A,&DSNAME)\n      IF &B = ' THEN SET &B = &SUBSTR(&A-1,&DSNAME)\n      IF &MEMBER \u00ac= AND &B \u00ac= ) THEN +\n        DO\n          SET &A = &LENGTH(&DSNAME)\n          SET &B = &SUBSTR(&A,&DSNAME)\n          IF  &B \u00ac= ' THEN SET &SASPGM = &STR(&DSNAME(&MEMBER)\n          ELSE +\n            DO\n              SET &C =\n              SET &C = &SUBSTR(2:&A-1,&DSNAME)\n              SET &SASPGM = &STR('&C(&MEMBER)')\n            END\n        END\n      ISPEXEC VPUT (SASPGM) PROFILE\n    END\n/* PROCESS A RUN PROGRAM.\n  IF &TYPE = R THEN +\n    DO\n       SET &PURGE = NO\n       SET &DSNAME = &SASPGM\n       ISPEXEC VPUT (DSNAME) SHARED\n       SET &SYSOUTTRAP = 10\n       CONTROL NOLIST NOCONLIST\n       LISTD &DSNAME\n       SET &RC = &LASTCC\n     /*CONTROL   LIST   CONLIST\n       SET &SYSOUTTRAP = 0\n       IF &SYSOUTLINE = 5 AND &RC = 0 THEN +\n         DO\n           SET &SYSDVAL = &SYSOUTLINE3\n           READDVAL  &A &B &C &D\n           IF &D = PO THEN +\n             DO\n               SET &PURGE = YES\n               SELMEMBR\n               SET &RC = &LASTCC\n               IF &RC = 0 THEN +\n                 DO\n                   ISPEXEC VGET (MEMBER) SHARED\n                   SET &MEMBER = &MEMBER\n                   SET &A = &LENGTH(&DSNAME)\n                   SET &B = &SUBSTR(&A,&DSNAME)\n                   IF  &B \u00ac= ' THEN SET &SASPGM = &STR(&DSNAME(&MEMBER)\n                   ELSE +\n                     DO\n                       SET &C =\n                       SET &C = &SUBSTR(2:&A-1,&DSNAME)\n                       SET &SASPGM = &STR('&C(&MEMBER)')\n                     END\n                   ISPEXEC VPUT (SASPGM) PROFILE\n                   SET &PURGE = NO\n                 END\n             END\n         END\n      IF &PURGE = NO THEN +\n        DO\n          CONTROL NOMSG\n          FREE F(SASPGM,FT11F001,FT12F001)\n          CONTROL   MSG\n          SET &ALLOC = &SYSDSN(&SASPGM)\n          IF  &ALLOC = &STR(OK) THEN +\n            DO\n              CONTROL NOMSG\n              ALLOC DA(&QUAL..PRINTTO,&SASPGM) F(SASPGM) SHR\n              SET &RC = &LASTCC\n              CONTROL   MSG\n              IF &RC = 0 THEN +\n                DO\n                  ISPEXEC CONTROL DISPLAY LINE START(1)\n                  ALLOC F(FT11F001) DA(&QUAL..LOG) SHR\n                  ALLOC F(FT12F001) DA(&QUAL..LIST) USING(SASP) SHR\n                  WRITE ***********************************\n                  WRITE * SAS PROGRAM BEGINNING EXECUTION\n                  WRITE ***********************************\n                  TIME\n    CALL '&LOADLIB(SAS)' +\n      '&SASOPT,S=72,SYSIN=SASPGM,LOG=FT11F001'\n                  SET &RC = &LASTCC\n                  TIME\n                  WRITE *****************************************\n                  WRITE * SAS PROGRAM COMPLETED, RC = &RC..\n                  WRITE * HIT \"ENTER\" TO BROWSE THE LOG OUTPUT.\n                  WRITE *****************************************\n                  SET &ERRMSG = &STR(FSAS000)\n                  ISPEXEC BROWSE DATASET(&QUAL..LOG)\n                  SET &ERRSM  = &ZERRSM\n                  SET &ERRLM  = &ZERRLM\n                END\n              ELSE +\n                SET &ERRMSG = &STR(FSAS001)\n            END\n          ELSE +\n            DO\n              IF &ALLOC = &STR(DATASET NOT FOUND) THEN +\n                SET &ERRMSG = &STR(FSAS002)\n              ELSE +\n                IF &ALLOC = &STR(MEMBER NOT FOUND) THEN +\n                  SET &ERRMSG = &STR(FSAS003)\n                ELSE +\n                  SET &ERRMSG = &STR(FSAS004)\n            END\n        END\n    END\n/* PROCESS A BROWSE LOG.\n  IF &TYPE = 1 THEN +\n    DO\n      ISPEXEC BROWSE DATASET(&QUAL..LOG)\n      SET &ERRSM  = &ZERRSM\n      SET &ERRLM  = &ZERRLM\n    END\n/* PROCESS A BROWSE LIST.\n  IF &TYPE = 2 THEN +\n    DO\n      ISPEXEC BROWSE DATASET(&QUAL..LIST)\n      SET &ERRSM  = &ZERRSM\n      SET &ERRLM  = &ZERRLM\n    END\n/* PROCESS A CALL SAS INTERACTIVE.\n  IF &TYPE = I THEN +\n    DO\n      ISPEXEC CONTROL DISPLAY LINE START(1)\n      CONTROL NOMSG\n      FREE F(SYSIN,FT11F001,FT12F001)\n      CONTROL   MSG\n      ALLOC F(SYSIN) DA(*)\n      ALLOC F(FT11F001) DA(*)\n      ALLOC F(FT12F001) DA(*)\n      CALL '&LOADLIB(SAS)' '&SASOPT'\n      SET &RC = &LASTCC\n      SET &ERRMSG = &STR(FSAS000)\n    END\n/* PROCESS A PRINT.\n  IF &TYPE = P THEN +\n    DO\n      SET &SYSOUTTRAP = 20\n      SET &RC1 = &STR()\n      SET &RC2 = &STR()\n      SET &RC3 = &STR()\n      IF &SASP1 NE &STR() THEN +\n        DO\n          PRINTOFF &QUAL..LOG DEST(&SASPDEST)\n          SET &RC1 = &LASTCC\n          IF &RC1 \u00ac= 0 THEN SET &ERRLM = &STR(&SYSOUTLINE1)\n          ELSE SET &ERRLM = &STR(YOUR PRINT OUTPUT HAS BEEN SCHEDULED)\n        END\n      IF &SASP2 NE &STR() THEN +\n        DO\n          PRINTOFF &QUAL..LIST DEST(&SASPDEST)\n          SET &RC2 = &LASTCC\n          IF &RC2 \u00ac= 0 THEN SET &ERRLM = &STR(&SYSOUTLINE1)\n          ELSE SET &ERRLM = &STR(YOUR PRINT OUTPUT HAS BEEN SCHEDULED)\n        END\n      IF &SASP3 NE &STR() THEN +\n        DO\n          PRINTOFF &SASPGM DEST(&SASPDEST)\n          SET &RC3 = &LASTCC\n          IF &RC3 \u00ac= 0 THEN SET &ERRLM = &STR(&SYSOUTLINE1)\n          ELSE SET &ERRLM = &STR(YOUR PRINT OUTPUT HAS BEEN SCHEDULED)\n        END\n      SET &RC = &RC1\n      IF &RC2 > &RC THEN SET &RC = &RC2\n      IF &RC3 > &RC THEN SET &RC = &RC3\n      SET &ERRMSG = &STR(FSAS000)\n      SET &SYSOUTTRAP = 0\n    END\n/* PROCESS AN ALLOCATE.\n  IF &TYPE = A THEN +\n    DO\n      SET &SYSOUTTRAP = 20\n      SET &RC1 = &STR()\n      SET &RC2 = &STR()\n      SET &RC3 = &STR()\n      IF &SASDD1 NE &STR() THEN +\n        DO\n          SET &SYSOUTTRAP = 10\n          ALLOC F(&SASDD1) DA(&SASDSN1) &SASDISP1\n          SET &RC1 = &LASTCC\n          IF &RC1 \u00ac= 0 THEN SET &ERRLM = &STR(&SYSOUTLINE1)\n          ELSE SET &ERRLM = &STR(YOUR FILE WAS ALLOCATED OK)\n        END\n      IF &SASDD2 NE &STR() THEN +\n        DO\n          SET &SYSOUTTRAP = 10\n          ALLOC F(&SASDD2) DA(&SASDSN2) &SASDISP2\n          SET &RC2 = &LASTCC\n          IF &RC2 \u00ac= 0 THEN SET &ERRLM = &STR(&SYSOUTLINE1)\n          ELSE SET &ERRLM = &STR(YOUR FILE WAS ALLOCATED OK)\n        END\n      IF &SASDD3 NE &STR() THEN +\n        DO\n          SET &SYSOUTTRAP = 10\n          ALLOC F(&SASDD3) DA(&SASDSN3) &SASDISP3\n          SET &RC3 = &LASTCC\n          IF &RC3 \u00ac= 0 THEN SET &ERRLM = &STR(&SYSOUTLINE1)\n          ELSE SET &ERRLM = &STR(YOUR FILE WAS ALLOCATED OK)\n        END\n      SET &RC = &RC1\n      IF &RC2 > &RC THEN SET &RC = &RC2\n      IF &RC3 > &RC THEN SET &RC = &RC3\n      SET &ERRMSG = &STR(FSAS000)\n      SET &SYSOUTTRAP = 20\n    END\n/* PROCESS A FREE.\n  IF &TYPE = F THEN +\n    DO\n      SET &SYSOUTTRAP = 5\n      SET &RC1 = &STR()\n      SET &RC2 = &STR()\n      SET &RC3 = &STR()\n      IF &SASDD1 NE &STR() THEN +\n        DO\n          FREE F(&SASDD1)\n          SET &RC1 = &LASTCC\n          IF &RC1 \u00ac= 0 THEN SET &ERRLM = &STR(&SYSOUTLINE1)\n          ELSE SET &ERRLM = &STR(YOUR FILE WAS FREED SUCCESSFULLY)\n        END\n      IF &SASDD2 NE &STR() THEN +\n        DO\n          FREE F(&SASDD2)\n          SET &RC2 = &LASTCC\n          IF &RC2 \u00ac= 0 THEN SET &ERRLM = &STR(&SYSOUTLINE1)\n          ELSE SET &ERRLM = &STR(YOUR FILE WAS FREED SUCCESSFULLY)\n        END\n      IF &SASDD3 NE &STR() THEN +\n        DO\n          FREE F(&SASDD3)\n          SET &RC3 = &LASTCC\n          IF &RC3 \u00ac= 0 THEN SET &ERRLM = &STR(&SYSOUTLINE1)\n          ELSE SET &ERRLM = &STR(YOUR FILE WAS FREED SUCCESSFULLY)\n        END\n      SET &RC = &RC1\n      IF &RC2 > &RC THEN SET &RC = &RC2\n      IF &RC3 > &RC THEN SET &RC = &RC3\n      SET &ERRMSG = &STR(FSAS000)\n    END\n  ISPEXEC VPUT (ERRMSG,ERRSM,ERRLM,RC) SHARED\n  EXIT CODE(0)\nEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FSASDOC": {"ttr": 3595, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\n\\x00\\n\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "FILE369"}, "text": "FSAS CONSISTS OF 3 COMPONENTS:\n\n     3 - CLISTS ==>  FSAS      FSASCMD   FSASEMAC\n     1 - PANEL  ==>  FSASP\n     1 - MESSAGE MEMBER  ==> FSAS00\n\nFSAS DOES NOT REQUIRE THE NEW SAS PRODUCT, SAS/DMI.  IT JUST USES THE\nBATCH INTERFACE UNDER ISPF.  USE THE ISPF EDITOR UNDER FSAS TO MODIFY\nCODE, AND ISPF BROWSE TO LOOK AT THE SAS LOG AND SAS LIST DATASETS.\nTHE INTERFACE IS SIMILAR TO THAT UNDER VM/CMS.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FSASEMAC": {"ttr": 3597, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\x04\\x00\\x04\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 4, "newlines": 4, "modlines": 0, "user": "FILE369"}, "text": " ISREDIT MACRO\n ISREDIT (SASDSN) = DATASET\n ISREDIT (SASMEM) = MEMBER\n ISPEXEC VPUT (SASDSN SASMEM) SHARED\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FSASP": {"ttr": 3599, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\x83\\x00\\x83\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 131, "newlines": 131, "modlines": 0, "user": "FILE369"}, "text": ")ATTR\n $ TYPE(TEXT) SKIP(ON) INTENS(LOW)\n)BODY\n%-------------------- SAS: STATISTICAL ANALYSIS SYSTEM --&SM--------------------\n%OPTION  ===>_ZCMD\n%                                                             %USERID - &ZUSER\n%   E  +EDIT               - Edit a SAS program               %TIME   - &ZTIME\n%   R  +RUN                - Run a SAS program                %DATE   - &ZDATE\n%  1,2 +BROWSE OUTPUT      - 1 = LOG, 2 = LIST\n%   A  +ALLOCATE           - Allocate an OS dataset\n%   F  +FREE               - Free an OS dataset\n%   I  +INTERACTIVE        - Invoke SAS interactive mode (%ENDSAS;+to EXIT )\n%   P  +PRINT              - Print LOG, LIST, or SAS program\n%\n+      SAS PROGRAM DSN ===>_SASPGM\n$          SAS OPTIONS ===>_SASOPT\n$\n+    PRINT DESTINATION ===>_SASPDEST$( LOCAL, APS1, APS2, APS3, RMT1, ETC. )\n+            PRINT LOG ===>_Z$ LIST ===>_Z$ PGM ===>_Z$  ( enter \"Y\" to select )\n%\n+DDN ===>_SASDD1  $DSN ===>_SASDSN1                              $DISP ===>_Z  $\n+DDN ===>_SASDD2  $DSN ===>_SASDSN2                              $DISP ===>_Z  $\n+DDN ===>_SASDD3  $DSN ===>_SASDSN3                              $DISP ===>_Z  $\n%\n+Enter%END+command to terminate SAS dialogs.\n)INIT\n &ZPRIM = YES\n .ZVARS = '(SASP1 SASP2 SASP3 SASDISP1 SASDISP2 SASDISP3)'\n  .HELP    = ISR00003\n .CURSOR = ZCMD\n  &ZPRIM   = YES        /* ALWAYS A PRIMARY OPTION MENU      */\n  &ZHTOP   = ISR00003   /* TUTORIAL TABLE OF CONTENTS        */\n  &ZHINDEX = ISR91000   /* TUTORIAL INDEX - 1ST PAGE         */\n  VPUT (ZHTOP,ZHINDEX) PROFILE\n  IF (&ERRMSG \u00ac= ' ')\n   .MSG = &ERRMSG\n  &ERRMSG = ' '\n  &SM = '---'\n  IF (&ERRSM \u00ac= ' ')\n    &SM = &ERRSM\n)PROC\n  &OPT = &ZCMD\n  &SEL = TRANS( TRUNC (&OPT,'.')\n   C,'CMD(%FSASCMD)'\n   E,'CMD(%FSASCMD)'\n   R,'CMD(%FSASCMD)'\n   1,'CMD(%FSASCMD)'\n   2,'CMD(%FSASCMD)'\n   A,'CMD(%FSASCMD)'\n   F,'CMD(%FSASCMD)'\n   I,'CMD(%FSASCMD)'\n   P,'CMD(%FSASCMD)'\n   X,EXIT\n   ' ',' '\n   *, '?' )\n&ERRSM = ' '\n&TYPE = TRUNC (&OPT,'.')\nIF (&TYPE =C E )\n  VER (&SASPGM,NONBLANK)\n  VER (&SASPGM,DSNAME)\nIF (&TYPE =R )\n  VER (&SASPGM,NONBLANK)\n  VER (&SASPGM,DSNAME)\nIF (&TYPE =A )\n  IF (&SASDD3 = ' ')\n    IF (&SASDD2 = ' ')\n      VER(&SASDD1,NONBLANK)\n  IF (&SASDD1 \u00ac= ' ')\n    VER(&SASDD1,NONBLANK)\n    VER(&SASDD1,NAME)\n    VER(&SASDSN1,NONBLANK)\n    IF (&SASDSN1 \u00ac= '*')\n      VER(&SASDSN1,DSNAME)\n    &DISP = TRUNC(&SASDISP1,1)                     /* PSYWAK          *\n    VER(&DISP LIST N O S M)                        /* PSYWAK          *\n    &SASDISP1 = TRANS(&DISP,                       /* PSYWAK          *\n                       N,'NEW'                     /* PSYWAK          *\n                       O,'OLD'                     /* PSYWAK          *\n                       S,'SHR'                     /* PSYWAK          *\n                       M,'MOD'                     /* PSYWAK          *\n                       *,'SHR')                    /* PSYWAK          *\n  IF (&SASDD2 \u00ac= ' ')\n    VER(&SASDD2,NONBLANK)\n    VER(&SASDD2,NAME)\n    VER(&SASDSN2,NONBLANK)\n    IF (&SASDSN2 \u00ac= '*')\n      VER(&SASDSN2,DSNAME)\n    &DISP = TRUNC(&SASDISP2,1)                   /* PSYWAK          */\n    VER(&DISP LIST N O S M)                      /* PSYWAK          */\n    &SASDISP2 = TRANS(&DISP,                     /* PSYWAK          */\n                       N,'NEW'                   /* PSYWAK          */\n                       O,'OLD'                   /* PSYWAK          */\n                       S,'SHR'                   /* PSYWAK          */\n                       M,'MOD'                   /* PSYWAK          */\n                       *,'SHR')                  /* PSYWAK          */\n  IF (&SASDD3 \u00ac= ' ')\n    VER(&SASDD3,NONBLANK)\n    VER(&SASDD3,NAME)\n    VER(&SASDSN3,NONBLANK)\n    IF (&SASDSN3 \u00ac= '*')\n      VER(&SASDSN3,DSNAME)\n    &DISP = TRUNC(&SASDISP3,1)                   /* PSYWAK          */\n    VER(&DISP LIST N O S M)                      /* PSYWAK          */\n    &SASDISP3 = TRANS(&DISP,                     /* PSYWAK          */\n                       N,'NEW'                   /* PSYWAK          */\n                       O,'OLD'                   /* PSYWAK          */\n                       S,'SHR'                   /* PSYWAK          */\n                       M,'MOD'                   /* PSYWAK          */\n                       *,'SHR')                  /* PSYWAK          */\nIF (&TYPE =F )\n  VER(&SASDD1,NONBLANK)\n  VER(&SASDD1,NAME)\n  IF (&SASDD2 \u00ac= ' ')\n    VER(&SASDD2,NONBLANK)\n    VER(&SASDD2,NAME)\n  IF (&SASDD3 \u00ac= ' ')\n    VER(&SASDD3,NONBLANK)\n    VER(&SASDD3,NAME)\nIF (&TYPE =P )\n  IF  (&SASPDEST = ' ') &SASPDEST=LOCAL\n  VER (&SASPDEST,NAME)\n  IF (&SASP3 = ' ')\n    IF (&SASP2 = ' ')\n      VER(&SASP1,NONBLANK)\n  IF (&SASP1 \u00ac= ' ')\n    VER(&SASP1,LIST,Y)\n  IF (&SASP2 \u00ac= ' ')\n    VER(&SASP2,LIST,Y)\n  IF (&SASP3 \u00ac= ' ')\n    VER(&SASP3,LIST,Y)\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FSAS00": {"ttr": 3602, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\n\\x00\\n\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "FILE369"}, "text": "FSAS000   'CMD DONE, RC=&RC..'                       .ALARM=YES\n\nFSAS001   'NEED A MEMBER NAME'                       .ALARM=YES\n\nFSAS002   'DATASET NOT FOUND'                        .ALARM=YES\n\nFSAS003   'MEMBER NOT FOUND'                         .ALARM=YES\n\nFSAS004   'DATASET NOT A PDS'                        .ALARM=YES\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HEX": {"ttr": 3841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x02\\r\\x02\\r\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 525, "newlines": 525, "modlines": 0, "user": "FILE369"}, "text": "*          DATA SET HEX        AT LEVEL 001 AS OF 08/29/77\n      TITLE ' BASE 16 ARITHMETIC '                                      00001\n*                                                                       00002\n*       THE IMPETUS FOR WRITING THIS PROGRAM COMES FROM THOSE           00003\n*    FRUSTRATING HOURS SPENT FUMBLING WITH A DUMP ONLY TO DISCOVER      00004\n*    THAT MY INABILITY TO FIND A SOLUTION STEMS FROM AN ARITHMETIC      00005\n*    ERROR IN THE INITIAL STEPS.                                        00006\n*                                                                       00007\n*       SYNTAX FOLLOWS THIS FORM:                                       00008\n*       (OPERATOR)  (OPERAND A), (OPERAND B)                            00009\n*                                                                       00010\n*       BOTH THE OPERATOR (IMPERATIVE), AND THE OPERANDS ARE            00011\n*   OPTIONAL, WITH THE EXCEPTION THAT OPERAND B CANNOT BE SPECIFIED     00012\n*   WITHOUT OPERAND A.                                                  00013\n*                                                                       00014\n*       BLANKS OR COMMAS SEPARATE FIELDS. THE ONLY SPECIAL CHARACTER    00015\n*   ALLOWED IS THE MINUS(-) IN THE CONVERT TO HEX SUBCOMMAND.           00016\n*              HEX  -1                                                  00017\n*   THE INPUT IS SCANNED FROM LEFT TO RIGHT. IF THE FIRST FIELD         00018\n*   ENCOUNTERED IS A RECOGNISABLE OPERATOR, IT IS TAKEN AS SUCH.        00019\n*   OTHERWISE, IT IS ASSUMED TO BE OPERAND A. OPERAND B, IF             00020\n*   PRESENT, MUST FOLLOW OPERAND A. EVERYTHING PAST OPERAND B IS        00021\n*   IGNORED.                                                            00022\n*                                                                       00023\n*       HEX WILL \"REMEMBER\" ITS PREVIOUS OPERATION. THUS, IF ANY        00024\n*   PARAMETER IS LEFT OUT  OF  AN INPUT, IT WILL BE FILLED IN           00025\n*   BY THE PARAMETER FROM THE PREVIOUS OPERATION. THE SAME OPERATION    00026\n*   AND THE SAME OPERAND A WILL BE USED. OPERAND B IS THE RESULT        00027\n*   JUST DISPLAYED ON YOUR SCREEN. OBVIOUSLY, THE PURPOSE OF THIS       00028\n*   IS TO ALLOW \"CHAINING\" IN THE SENSE IT CAN BE DONE ON A             00029\n*   POCKET CALCULATOR WITH THE K= KEY.                                  00030\n*                                                                       00031\n*       THE ORDER OF OPERATIONS IS AS FOLLOWS:                          00032\n*                                                                       00033\n*    (ADD,A)          (OPERAND A)  TO    (OPERAND B)                    00034\n*    (SUBTR.,SUB,S)   (OPERAND A)  FROM  (OPERAND B)                    00035\n*    (MULTIPLY,MUL,M) (OPERAND A)  TIMES (OPERAND B)                    00036\n*    (DIVIDE,DIV,D)   (OPERAND A)  INTO  (OPERAND B)                    00037\n*    (HEX,X)          (OPERAND A)  OR -(OPERAND A)  CONVERT TO HEX      00038\n*    (DEC,P)           OPERAND A                    CONVERT TO DECIMAL  00039\n*    (BR)                                           BRANCH TO BRKPT     00040\n*    (END,E)                                        END                 00041\n*                                                                       00042\n*       ADDITION AND SUBTRACTION ARE STRAIGHTFOREWARD. REMEMBER THAT    00043\n*   NEGATIVE NUMBERS APPEAR IN TWO'S COMPLIMENT NOTATION.               00044\n*   MULTIPLICATION OUTPUTS A TWO FULLWORD MULTIPLICAND TO THE           00045\n*   TERMINAL, BUT ONLY THE SECOND FULLWORD IS \"REMEMBERED\" AS THE       00046\n*   PREVIOUS RESULT. IN DIVISION, THE REMAINDER IS \"FORGOTTEN.\"         00047\n*                                                                       00048\n*       CONVERT TO HEX WILL ACCEPT A MINUS SIGN IN FRONT OF OPERAND A.  00049\n*   OPERAND A IS REQUIRED FOR THIS COMMAND. CONVERT TO DECIMAL IS       00050\n*   STRAIGHTFOREWARD EXCEPT FOR THE ABBREVIATION, WHICH IS, \"P.\"        00051\n*                                                                       00052\n*       BREAK (BR) IS USED WITH THE TSO TEST COMMAND. PICK UP HEX       00053\n*   WITH TEST, AND SET A BREAKPOINT AT \"BRKPT\". THEN ENTER \"GO\"         00054\n*   TO USE THE HEX PROGAM, AND \"BR\" TO USE TEST. THIS FACILITATES       00055\n*   BROWSING THROUGH THE SYSTEMS' CONTROL BLOCKS.                       00056\n*                                                                       00057\n*       EXAMPLES.    (PROGRAM RESPONSES ARE INDENTED FROM COMMANDS).    00058\n*                                                                       00059\n*   HEX                            INVOKE PROGRAM                       00060\n*     HEX                             PROGAM IS ACTIVE                  00061\n*   A 1 1                          ADD 1 TO 1                           00062\n*     00000002                        RESPONSE                          00063\n*   8                              CHAIN ADD X'8'                       00064\n*     0000000A                        RESPONSE                          00065\n*   (HITS ENTER)                   NO OPERANDS AT ALL                   00066\n*     00000012                        REPEAT OF LAST OPERATION          00067\n*                                                                       00068\n*   S     4                        SUBTRACT 4                           00069\n*     0000000E                        RESULT IS STILL CHAINED           00070\n*   M  12345678 FEDCBA98           BY PROVIDING AN OPERAND B, WE        00071\n*     FFEB4992 35068740               REPLACE THE PREVIOUS RESULT OF    00072\n*                                     0000000E.                         00073\n*   ADD 1                                                               00074\n*     35068741                     THE DOUBLEWORD RESULT OF THE         00075\n*                                     MULTIPLICATION HAS BEEN TRUNCATED 00076\n*   DIV 400                        DIVIDING BY X'400' GIVES A RESULT    00077\n*     000D41A1  REMAINDER 00000341    THAT IS THE HEX EQUIVALENT OF K.  00078\n*                                                                       00079\n*   DEC                            CONVERT 000D41A1 TO DECIMAL          00080\n*              868,769                                                  00081\n*                                                                       00082\n*   END                                                                 00083\n*    READY                                                              00084\n*                                                                       00085\n*   TEST 'LIBRARY.NAME(HEX)'       PICK UP HEX UNDER TEST               00086\n*     TEST                            RESPONSE FROM TEST                00087\n*   AT BRKPT                       SET BREAKPOINT                       00088\n*     TEST                            RESPONSE FROM TEST                00089\n*   GO                             ENTER HEX PROGAM                     00090\n*     HEX                             RESPONSE FROM HEX                 00091\n*   A 1 1                          USE HEX                              00092\n*     00000002                                                          00093\n*   BR                             GO TO BREAKPOINT, TO INVOKE TEST     00094\n*     AT BRKPT                                                          00095\n*     TEST                            RESPONSES FROM TEST               00096\n*   L 10. X                        USE TEST                             00097\n*     000010. 0000B680                RESPONSE FROM TEST                00098\n*   GO                             GET BACK INTO HEX                    00099\n*                                                                       00100\n         EJECT                                                          00101\nHEX      PRIME ID=DICK_SZIEDE_CSC_1972                                  00102\n*                                                                       00103\n         REGS                                                           00104\n         EJECT                                                          00105\n         GETMAIN R,LV=1024,SP=0                                         00106\n         LR    R11,R1                                                   00107\n         USING WORKAREA,R11                SET UP WORK DSECT            00108\n*                                                                       00109\n         XC    WORKAREA(256),WORKAREA        SET TO ZEROA               00110\n         MVC   OPCODE,=C'A  '                                           00111\n         BAL   R2,PUTOUT               CLEAR OUTAREA                    00112\n         MVC   OUTAREA(3),=C'HEX'                                       00113\n         BAL   R2,PUTTER               INITIAL RESPONSE                 00114\n         EJECT                                                          00115\nREADCARD LA    R1,INAREA                                                00116\n         O     R1,=X'80000000'                SET TGET BITS             00117\n         LA    R0,80                           BUFFER LENGTH            00118\n         TGET  (R1),(R0),R                                              00119\n*                                                                       00120\n         OC    INAREA,OUTAREA              CONVERT TO UPPER CASE        00121\n         BAL   R14,SCANIT                  FORMAT INPUT                 00122\n         BAL   R14,CHOOSIT                    DECIDE ON ROUTINE         00123\n         BALR  R14,R15                     DO IT                        00124\n         BAL   R2,PUTTER                   RETURN OUTPUT                00125\n*                                                                       00126\n         CLI   OPCODE,C'E'             DID WE GIVE UP?                  00127\n         BNE   READCARD                                                 00128\n         B     QUIT                                                     00129\n*                                                                       00130\nPUTTER   LA    R10,3                                                    00131\nPUTPUT   LA    R8,OUTAREA                                               00132\n         LR    R1,R8                                                    00133\n         LA    R0,80                           BUFFER LENGTH            00134\n         TPUT  (R1),(R0),R                                              00135\n*                                                                       00136\n         LTR   R15,R15                                                  00137\n         BZ    PUTOUT                                                   00138\n         ST    R15,RESULT                                               00139\n         BAL   R15,RESTOHEX                                             00140\n         BCT   R10,PUTPUT                                               00141\nPUTOUT   MVI   INAREA,C' '                                              00142\n         MVC   INAREA+1(159),INAREA                                     00143\n         BR    R2                                                       00144\n*                                                                       00145\nQUIT     FREEMAIN R,LV=1024,A=(R11)                                     00146\n         TERME RC=0                                                     00147\n         EJECT                                                          00148\n*                                                                       00149\nSCANIT   EQU   *                                                        00150\n         XC    TABLE1(256),TABLE1                                       00151\n         MVI   TABLE1+193,X'01'                                         00152\n         MVC   TABLE1+194(56),TABLE1+193                                00153\n*                                                                       00154\n         XC    TABLE2(256),TABLE2                                       00155\n         MVI   TABLE2+64,C' '                                           00156\n         MVI   TABLE2+107,X'6B'                                         00157\n*                                                                       00158\n         SR    R3,R3                                                    00159\n         LA    R6,INAREA                                                00160\n         LR    R1,R6                                                    00161\n         LA    R9,3                    LIMIT LOOP                       00162\n*                                                                       00163\nSC1      LA    R7,INAREA+72                                             00164\n         SR    R7,R6                   GET LENGTH FOR TRANSLATE         00165\nSC1TR    EX    R7,SC1TRNB              FIND NON-BLANK                   00166\n         BZ    SC1END                  NOT FOUND                        00167\n         ST    R1,ARG1+4(R3)        STORE POINTER                       00168\n         LR    R6,R1                   SAVE POINTER TO FRONT OF FIELD   00169\n         LA    R7,INAREA+72                                             00170\n         SR    R7,R6                   GET LENGTH FOR SECOND TRANSLATE  00171\n         EX    R7,SC1TRBL              FIND NEXT BL OR COMMA            00172\n         BZ    SC1END                                                   00173\n         LR    R7,R1                                                    00174\n         SR    R7,R6                                                    00175\n         ST    R7,ARG1(R3)          STORE LENGTH                        00176\n         LR    R6,R1                                                    00177\n         LA    R3,8(R3)                INCREMENT INDEX                  00178\n         BCT   R9,SC1                                                   00179\n*                                                                       00180\nSC1END   ST    R3,ARGCT                                                 00181\n         B     SC2                                                      00182\n*                                                                       00183\nSC1TRNB  TRT   0(0,R1),TABLE1                                           00184\nSC1TRBL  TRT   0(0,R1),TABLE2                                           00185\nSC2      LTR   R3,R3                   IS ARGCT = 0 ?                   00186\n         BNZ   SC2A                                                     00187\n         ST    R3,FIELDCT              SAVE COUNT OF OPERANDS           00188\n         B     SCANEND                                                  00189\nSC2A     L     R2,ARG1                 LENGTH OF 1ST OPERAND            00190\n         BCTR  R2,0                    DECREMENT LGTH FOR MOVE          00191\n         LA    R7,OPTABLEN             LIMIT FOR SEARCH                 00192\n         LA    R4,OPTABLE                                               00193\n         L     R5,ARG1+4               ADDR OF NOMINAL OPCODE           00194\n         LA    R6,4                    INCREMENT                        00195\n*                                                                       00196\nSC2B     EX    R2,SC2COMP                                               00197\n         BE    SC2FOUND                                                 00198\n         BXLE  R4,R6,SC2B                                               00199\n         MVC   ARG3(8),ARG2               IF THERE IS NO OPCODE ENTERED 00200\n         MVC   ARG2(8),ARG1                     AS THE FIRST OPERAND,   00201\n*                                                 MAKE                  00202\n*                                          IT LOOK AS THOUGH THERE IS   00203\n*                                                                       00204\n         B     SCANEND                                                  00205\nSC2FOUND MVC   OPCODE(1),0(R4)         INPLANT NEW OPCODE               00206\n         SH    R3,=H'8'                REMOVE 1 FROM OPERAND COUNT      00207\n         B     SCANEND                 WITH ARGUMENT COUNT DECREMENTED  00208\n*                                                                       00209\nSC2COMP  CLC   0(0,R5),1(R4)                                            00210\n*                                                                       00211\nSC4      EQU   *                                                        00212\nSCANEND  ST     R3,FIELDCT              SAVE OPERAND COUNT              00213\n         BR     R14                                                     00214\n*                                                                       00215\n*                                                                       00216\n         EJECT                                                          00217\nCHOOSIT  LA    R2,RTNTABLE                                              00218\n         LA    R7,RTNEND                                                00219\n         LA    R6,4                                                     00220\n*                                                                       00221\nCH1      CLC   0(1,R2),OPCODE                                           00222\n         EJECT                                                          00223\n         BE    CH2                                                      00224\n         BXLE  R2,R6,CH1                                                00225\n         LA    R15,ENDIT               DEFAULT OPCODE IS END            00226\n         BR    R14                                                      00227\nCH2      L     R15,0(R2)               CHOSEN ROUTINE                   00228\n         BR    R14                                                      00229\n*                                                                       00230\nRESTOHEX EQU   *                                                        00231\n         LA    R4,2                                                     00232\n         LA    R5,OUTAREA+6                                             00233\n         LA    R3,OUTAREA                                               00234\n*                                                                       00235\n         MVO   CONVERT,RESULT          MOVE FOR LEFT HALF-BYTE          00236\n         BAL   R9,RESTCONV                                              00237\n         LA    R3,OUTAREA+1            SET POINTER TO RESULT            00238\n         LA    R5,OUTAREA+7                                             00239\n         MVC   CONVERT,RESULT          MOVE FOR RIGHT HALF-BYTE         00240\n         BAL   R9,RESTCONV                                              00241\n         BR    R15                     RETURN TO CALLER                 00242\n*                                                                       00243\nRESTCONV NC    CONVERT,ZEROLEFT                                         00244\n         TR    CONVERT(4),ONETOF                                        00245\n         LA    R6,CONVERT                                               00246\nRESTMOVE MVC   0(1,R3),0(R6)           INTERLEAVE RESULTS               00247\n         LA    R6,1(R6)                                                 00248\n         BXLE  R3,R4,RESTMOVE                                           00249\n         BR    R9                                                       00250\n*                                                                       00251\n*******************CONVERT DISPLAY HEX TO INTERNAL BINARY******         00252\n*                                                                       00253\nXTOBIN   MVI   TABLE2,X'01'            FIRST, WE                        00254\n         MVC   TABLE2+1(256),TABLE2        CHECK FOR VALIDITY           00255\n         MVI   TABLE2+193,X'00'                                         00256\n         MVC   TABLE2+194(5),TABLE2+193                                 00257\n         MVI   TABLE2+240,X'00'                                         00258\n         MVC   TABLE2+241(9),TABLE2+240                                 00259\n         LM    R3,R4,0(R3)          GET VICTUMS                         00260\n         BCTR  R3,0                DECREMENT LGTH FOR EX                00261\n         EX    R3,XTOTRT            CHECK FOR INVALID CHAR              00262\n         BZ    XTOTRAN                                                  00263\n         MVC   OUTAREA(L'VALCK),VALCK                                   00264\n         MVC   OUTAREA+18(1),0(R1)                                      00265\n         LA    R15,4                   INVALID CHARACTER RC             00266\n*         BAL   R8,SNAPPER              *****TEMPORARY*****             00267\n         BR    R9                                                       00268\n*                                                                       00269\nXTOTRAN  EQU  *                                                         00270\n         MVC   TABLE2+193(L'XABCDEF),XABCDEF     SET UP TABLE FOR       00271\n         MVC   TABLE2+240(L'X012345),X012345     TABLE                  00272\n         EX    R3,XTOTR                GET VALUES INTO RIGHT 4 BITS     00273\n         EX    R3,XTOPK                SQUEEZE OUT LEFT 4 BITS          00274\n         SR    R4,R4                                                    00275\n         L     R5,XTOPACK+1            GET IT INTO                      00276\n         IC    R4,XTOPACK                  REGISTERS                    00277\n         SRDL  R4,4                    SHIFT OUT UNWABTED HALF-BYTE     00278\n         LR    R4,R5                                                    00279\n         SR    R15,R15                 GOOD RC                          00280\n         BR    R9                                                       00281\n*                                                                       00282\n*                                                                       00283\nXTOTRT   TRT   0(0,R4),TABLE2         VALIDATE INPUT                    00284\nXTOTR    TR    0(0,R4),TABLE2         MAKE EACH DISPLAY BYTE INTO       00285\n*                                        THE HEX IT REPRESENTS          00286\nXTOPK    PACK  XTOPACK,0(0,R4)        GET RID OF LEFT HALF-BYTES        00287\n*                                                                       00288\n         EJECT                                                          00289\nOPERATIO EQU   *                                                        00290\n         CLI   FIELDCT+3,X'00'                                          00291\n         BE    OPEUP                                                    00292\n         LA    R3,ARG2                                                  00293\n         BAL   R9,XTOBIN               CONVERT 1ST ARGUMENT TO BINARY   00294\n         LTR   R15,R15                                                  00295\n         BZ    OPERES                  IF BAD RETURN CODE FROM CONVERT  00296\n         BR    R14                         PUT OUT ERROR MESSAGE        00297\nOPERES   ST    R4,ARGUMENT            REPLACE RESULT                    00298\n*                                                                       00299\nOPE1     EQU    *                                                       00300\n         CLI   FIELDCT+3,X'10'         IS THERE A FIELD TO REPLACE      00301\n         BNE   OPEUP                       RESULT                       00302\n         LA    R3,ARG3                YUP                               00303\n         BAL   R9,XTOBIN                                                00304\n         LTR   R15,R15                                                  00305\n         BZ    OPE3                                                     00306\n         BR    R14                                                      00307\nOPE3    ST     R4,RESULT                                                00308\n*                                                                       00309\nOPEUP    SR   R4,R4                    ZERO HO REG                      00310\n         LM    R5,R6,RESULT            GET OPERANDS- RESULT NEXT TO     00311\n*                                          ZERO REG                     00312\n         BR    R8                      RETURN TO OPERATION              00313\n*                                                                       00314\n*                                                                       00315\nADD      BAL   R8,OPERATIO                                              00316\n         AR    R5,R6                                                    00317\n         B     ADDSUB                                                   00318\n*                                                                       00319\nSUBTRACT BAL   R8,OPERATIO                                              00320\n         SR    R5,R6                                                    00321\n*                                                                       00322\nADDSUB   ST    R5,RESULT                                                00323\n         BAL   R15,RESTOHEX                                             00324\n         BR    R14                                                      00325\n*                                                                       00326\n         EJECT                                                          00327\n*                                                                       00328\nMULTIPLY BAL   R8,OPERATIO                                              00329\n         MR    R4,R6                                                    00330\n         ST    R4,RESULT                                                00331\n         LR    R10,R5                                                   00332\n         BAL   R15,RESTOHEX                                             00333\n         MVC   OUTAREA+9(8),OUTAREA                                     00334\n         ST    R10,RESULT                                               00335\n         BAL   R15,RESTOHEX                                             00336\nMULXC    XC    OUTAREA(8),OUTAREA+9                                     00337\n         XC    OUTAREA+9(8),OUTAREA                                     00338\n         EX    0,MULXC                                                  00339\n*         BAL   R8,SNAPPER                                              00340\n         BR    R14                                                      00341\n*                                                                       00342\n*                                                                       00343\nDIVIDE   BAL   R8,OPERATIO                                              00344\n         LTR   R6,R6            TEST FOR DIVIDE BY ZERO                 00345\n         BZ    DIVBY0                                                   00346\n         LR    R4,R5                                                    00347\n         SRDA  R4,32               SET UP FOR FULLWORD DIVIDE           00348\n         DR    R4,R6                                                    00349\n         LR    R10,R5                  SAVE R5                          00350\n         ST    R4,RESULT                                                00351\n         BAL   R15,RESTOHEX                                             00352\n         MVC   OUTAREA+20(8),OUTAREA                                    00353\n         MVC   OUTAREA+10(9),=C'REMAINDER'                              00354\n         ST    R10,RESULT                                               00355\n         BAL   R15,RESTOHEX                                             00356\n*         BAL   R8,SNAPPER                                              00357\n         BR    R14                                                      00358\n*                                                                       00359\nDIVBY0  MVC   OUTAREA(L'DIVMSG),DIVMSG      SAY \"NAUGHTY NAUGHTY\"       00360\n        BR    R14                                                       00361\n         EJECT                                                          00362\n*                                                                       00363\nHEXIDECI EQU   *                                                        00364\n         LM    R3,R7,ARGCT             INPUT ARGUMENTS                  00365\n         LTR   R3,R3                   MUST HAVE SOMETHING              00366\n         BZ    HEXERR                                                   00367\n         CH    R3,=H'8'                ONE FIELD ?                      00368\n         BH    HEXMOVE                     NO - TAKE SECOND FIELD       00369\n         CLI   0(R5),C'Z'              IS IT A NUMBER OR LETTER ?       00370\n         BH    HEX0                        IF A NUMBER, USE IT          00371\n         B     HEXERR                      ELSE ASK FOR NUMBER          00372\nHEXMOVE  LR    R4,R6                                                    00373\n         LR    R5,R7                                                    00374\n         B     HEX0                                                     00375\n*                                                                       00376\nHEXERR   EQU   *                                                        00377\n         MVC   OUTAREA(29),=C'ENTER DECIMAL NUMBER, PLEASE   '          00378\n         BR    R14                                                      00379\n*                                                                       00380\nHEX0     EQU   *                                                        00381\n*                                      VALIDATE INPUT                   00382\n         LR    R7,R5                   SAVE POINTER FROM TRT            00383\n         BCTR  R4,0                    DECREMENT LENGTH FOR EXECUTE     00384\n         CH    R4,=H'16'               CHECK FOR INVALID LENGTH         00385\n         BL    HEX0TAB                                                  00386\n         LA    R4,15                   ERROR MEANS DEFAULT TO 16        00387\nHEX0TAB  EQU   *                                                        00388\n         MVI   TABLE2,X'01'            SET UP                           00389\n         MVC   TABLE2+1(256),TABLE2        TABLE FOR TRT                00390\n         MVI   TABLE2+240,X'00'                                         00391\n         MVC   TABLE2+241(9),TABLE2+240                                 00392\n         EX    R4,HEXTRT               CHECK FOR NON-NUMERIC            00393\n         BZ    HEX1                    OK                               00394\n         MVC   OUTAREA(L'VALCK),VALCK                                   00395\n         MVC   OUTAREA+18(1),0(R1)     REPORT  BAD CHARACTER            00396\n         BR    R14                                                      00397\n*                                      CONVERT TO BINARY                00398\nHEX1     EQU   *                 CONVERT TO BINARY                      00399\n         EX    R4,HEXPACK              PACKIT                           00400\n         CP    OPER1,HEXTOP                                             00401\n         BH    HEXLIMIT                                                 00402\n         CP    OPER1,HEXBOT                                             00403\n         BL    HEXLIMIT                PREVENT OC9                      00404\n         CVB   R3,OPER1                CONVERT TO BINARY                00405\n*                                                                       00406\n         BCTR  R5,0                   POINT TO CHAR AHEAD OF ARGUMENT   00407\n         CLI   0(R5),C'-'             IS IT A MINUS?                    00408\n         BNE   HEXST                       NOPE - CONTINUE              00409\n         LNR   R3,R3                       YEP  - COMPLIMENTS TO THE    00410\n*                                                 OPERAND               00411\nHEXST    ST    R3,RESULT                                                00412\n         BAL   R15,RESTOHEX                                             00413\n*         BAL   R8,SNAPPER              *****TEMPORARY****              00414\n         BR    R14                                                      00415\n*                                                                       00416\nHEXLIMIT MVC   OUTAREA(L'HEXLIM),HEXLIM ENTER ERROR MSG                 00417\n         BR    R14                                                      00418\n*                                                                       00419\n*                                                                       00420\nHEXTRT   TRT   0(0,R7),TABLE2                                           00421\nHEXPACK  PACK  OPER1(8),0(0,R5)                                         00422\n*                                                                       00423\n*                                                                       00424\n         EJECT                                                          00425\nDECIMAL  EQU   *                       CONVERT HEX TO DECIMAL           00426\n         BAL   R8,OPERATIO             SCAN INPUT                       00427\n         CLI   FIELDCT+3,X'00'         CHECK FOR INPUT                  00428\n         BE    DEC1                    NO INPUT, WE CONVER              00429\n         MVC   RESULT,ARGUMENT                                          00430\n*                                                                       00431\nDEC1     L     R3,RESULT                                                00432\n         CVD   R3,OPER1                                                 00433\n         MVC   OUTAREA(L'DECMASK),DECMASK                               00434\n         ED    OUTAREA(L'DECMASK),OPER1                                 00435\n         BR    R14                                                      00436\n*                                                                       00437\nENDIT    B     QUIT                                                     00438\n*                                                                       00439\n*                                                                       00440\nBRKPT    MVC   OUTAREA(13),=C'PRAY CONTINUE'    THIS IS WHERE           00441\n         BR    R14               THE TEST BREAKPOINT IS SET BY XTEST    00442\n         EJECT                                                          00443\n*                                                                       00444\n*              CONSTANTS                                                00445\nENDED    DC    C'ENDED'                                                 00446\nOPTABLE  DC    C'AADD'                                                  00447\n         DC    C'AA  '                                                  00448\n         DC    C'SSUB'                                                  00449\n         DC    C'SS  '                                                  00450\n         DC    C'MMUL'                                                  00451\n         DC    C'MM  '                                                  00452\n         DC    C'DDIV'                                                  00453\n         DC    C'DD  '                                                  00454\n         DC    C'HHEX'                                                  00455\n         DC    C'HH  '                                                  00456\n         DC    C'HX  '                                                  00457\n         DC    C'EE  '                                                  00458\n         DC    C'EEND'                                                  00459\n         DC    C'PDEC'                                                  00460\n         DC    C'PP  '                                                  00461\n         DC    C'BB  '                                                  00462\n         DC    C'BBR '                                                  00463\n         DC    C'BBRK'                                                  00464\nOPTABLEN EQU   *-4                                                      00465\n*                                                                       00466\nRTNTABLE DS    0F                                                       00467\n         DC    C'A'                                                     00468\n         DC    AL3(ADD)                                                 00469\n         DC    C'S'                                                     00470\n         DC    AL3(SUBTRACT)                                            00471\n         DC    C'M'                                                     00472\n         DC    AL3(MULTIPLY)                                            00473\n         DC    C'D'                                                     00474\n         DC    AL3(DIVIDE)                                              00475\n         DC    C'H'                                                     00476\n         DC    AL3(HEXIDECI)                                            00477\n         DC    C'P'                                                     00478\n         DC    AL3(DECIMAL)                                             00479\n         DC    C'E'                                                     00480\n         DC    AL3(ENDIT)                                               00481\n         DC    C'B'                                                     00482\n         DC    AL3(BRKPT)                                               00483\nRTNEND   EQU   *-4                                                      00484\n*                                                                       00485\nONETOF   DC    C'0123456789ABCDEF'                                      00486\nZEROLEFT DC    5X'0F'                                                   00487\nXABCDEF  DC    X'0A0B0C0D0E0F'                                          00488\nX012345  DC    X'00010203040506070809'                                  00489\nVALCK    DC    C'INVALID CHARACTER '                                    00490\nDECMASK  DC    X'402020206B2020206B2020206B2020206B20202060'            00491\nHEXTOP   DC    P'2147483647'                                            00492\nHEXBOT   DC    P'-2147483648'                                           00493\nHEXLIM   DC    C'FULLWORD LIMITS 2,147,483,647, -2,147,483,648'         00494\nDIVMSG   DC    C'YOU CAN''T DIVIDE BY ZERO, SILLY.'                     00495\n         LTORG                                                          00496\n         EJECT                                                          00497\nWORKAREA DSECT                                                          00498\n         DS    0D                                                       00499\nINAREA      DS CL80                                                     00500\nOUTAREA  DS    CL80                                                     00501\nSAVEBL   DS    F                                                        00502\nSAVER14  DS    F                                                        00503\nSAVER15  DS    F                                                        00504\nFIELDCT  DS    F                                                        00505\nOPER1    DS    CL8                                                      00506\nOPER2    DS    CL8                                                      00507\nOPER3    DS    CL8                                                      00508\nOPCODE   DS    CL3                                                      00509\nRESULT   DS    F                                                        00510\nARGUMENT DS    F                                                        00511\nDADA     DS    D                                                        00512\nARGCT    DS    F                                                        00513\nARG1     DS    2F                                                       00514\nARG2     DS    2F                                                       00515\nARG3     DS    2F                                                       00516\nTABLE1   DS    256C                                                     00517\nTABLE2   DS    256C                                                     00518\n         ORG   TABLE1                                                   00519\nCONVERT  DS    CL5                                                      00520\n         DS    0F                                                       00521\n         DS    3C                                                       00522\nXTOPACK  DS    CL5                                                      00523\n         END                                                            00524\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IEFACTRT": {"ttr": 3850, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x02\\xcd\\x02\\xcd\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 717, "newlines": 717, "modlines": 0, "user": "FILE369"}, "text": "IEFACTRT TITLE 'SMF JOB/STEP TERMINATION EXIT ROUTINE     '\n*/* REFER:  IPO1.SAMPLIB(IEFACTRT)\n*/* COMPID: SYSTEM\n*/* DOC     THIS SAMPLE SMF EXIT ROUTINE PUTS JOB SUMMARY MESSAGES\n*/*         ON THE JOB LOG WITH STEP TERMINATION STATUS.\n***********************************************************************\n*                                                                     *\n*             MODULE NAME = IEFACTRT                                  *\n*                                                                     *\n*             DESCRIPTIVE NAME =  MVS/SP SYSTEM IPO SUPPLIED          *\n*                SMF EXIT ROUTINE TO PUT MESSAGES ON JOB LOG WITH     *\n*                STEP TERMINATION STATUS.                             *\n*                                                                     *\n*             FUNCTION =                                              *\n*                PUT MESSAGES VIA WTO ON JOB LOG.                     *\n*                                                                     *\n*                OPERATION =                                          *\n*                   FOR JOB STEP TERMINATION PUT STATISTICS OF STEP.  *\n*                   FOR JOB TERMINATION PUT OUT JOB ENDED MESSAGE.    *\n*                                                                     *\n*              NOTES =                                                *\n*                                                                     *\n*                 DEPENDENCIES = CHARACTER SET IS EBCDIC.  REASSEMBLE *\n*                    IF A DIFFERENT CHARACTER SET IS NEEDED.          *\n*                    REQUIRES WTO EXIT ROUTINE, IEECVXIT, TO          *\n*                    SUPPRESS ROUTE CODE 14 FROM CONSOLE.             *\n*                                                                     *\n*                 RESTRICTIONS = NONE                                 *\n*                                                                     *\n*                 REGISTER CONVENTIONS = STANDARD CONVENTIONS.        *\n*                    REGISTERS 0 TO 1  = WORK REGISTERS               *\n*                    REGISTERS 2 TO 5  = UNUSED                       *\n*                    REGISTER  6       = OUTPUT LINE REGISTER         *\n*                    REGISTER  7       = COMMON PARAMETER AREA        *\n*                    REGISTERS 8 TO 11 = UNUSED                       *\n*                    REGISTER  12      = ADDRESSABILITY TO IEFACTRT   *\n*                                        CSECT                        *\n*                    REGISTER  13      = ADDRESSIBILITY TO DATA DSECT *\n*                    REGISTERS 14,15   = WORK REGISTERS               *\n*                                                                     *\n*                PATCH LABEL = PATCH (UNUSED AND INTIALIZED TO        *\n*                   BINARY ZEROES)                                    *\n*                                                                     *\n*             MODULE TYPE = PROCEDURE                                 *\n*                                                                     *\n*                PROCESSOR = ASM                                      *\n*                                                                     *\n*                MODULE SIZE = 1200 BYTES                             *\n*                                                                     *\n*                ATTRIBUTES = KEY 0, REENTRANT,                       *\n*                   SUPERVISOR STATE, ENABLED, NO LOCKS HELD          *\n*                                                                     *\n*             ENTRY POINTS = IEFACTRT (ONLY ENTRY POINT)              *\n*                                                                     *\n*                LINKAGE =                                            *\n*                                                                     *\n*                                                                     *\n*             INPUT = REG1 POINTS TO LIST OF FULLWORD ADDRESSES       *\n*                     AS FOLLOWS.                                     *\n*                 1.  PTR TO COMMON EXIT PARAMETER AREA\n*                 2.  PTR TO STEPNAME FIELD\n*                 3.  PTR TO PROGRAMMER NAME FIELD\n*                 4.  PTR TO JOB CPU TIME FIELD\n*                 5.  PTR TO JOB ACCOUNTING FIELDS\n*                 6.  PTR TO STEP CPU TIME FIELD\n*                 7.  PTR TO STEP ACCOUNTING FIELDS\n*                 8.  PTR TO CANCEL FLAG & STEP NUMBER\n*                 9.  PTR TO CONDITION CODE FIELD\n*                10.  PTR TO SMF RECORD TO BE WRITTEN\n*                                                                     *\n*             OUTPUT = NONE                                           *\n*                                                                     *\n*             EXIT - NORMAL = AT PROGRAM END VIA BRANCH REGISTER 14   *\n*                                                                     *\n*                OUTPUT = NONE                                        *\n*                                                                     *\n*                RETURN CODE = ZERO                                   *\n*                                                                     *\n*             EXIT - ERROR = NONE                                     *\n*                                                                     *\n*                OUTPUT = NONE                                        *\n*                                                                     *\n*                RETURN CODE = ZERO                                   *\n*                                                                     *\n*             EXTERNAL REFERENCES =                                   *\n*                                                                     *\n*                ROUTINES = NONE                                      *\n*                                                                     *\n*                DATA AREAS = NONE                                    *\n*                                                                     *\n*                CONTROL BLOCKS = NONE                                *\n*                                                                     *\n*             TABLES = NONE                                           *\n*                                                                     *\n*             MACROS = SAVE, WTO, RETURN, GETMAIN, FREEMAIN, ESTAE,   *\n*                      SETRP, IFASMFR, IEFJMR, IHASDWA                *\n*                                                                     *\n*             CHANGE ACTIVITY = NONE                                  *\n*                                                                     *\n*             MESSAGES =                                              *\n*                STEP TERMINATION LINE AND JOB TERMINATION LINE.      *\n*                                                                     *\n*             ABEND CODES = NONE                                      *\n*                                                                     *\n***********************************************************************\n         EJECT\nIEFACTRT CSECT ,\n*\n* CONSTANT ADDRESS EQAUTES\n*\nPSAAOLD  EQU    X'224',4    ADDRESS IN PSA OF CURRENT ASCB\nASCBJBNI EQU    X'AC',4     ADDRESS IN JOBNAME IN ASCB\nCHSTEP   EQU    X'38',8     ADDRESS IN STEP NAME IN CSCB\nCHPROCSN EQU    X'18',8     ADDRESS IN PROC STEP NAME IN CSCB\n*\n* CONSTANT EQUATES\n*\nK0       EQU   00                  NON-RELOCATABLE CONSTANT 00\nK1       EQU   01                  NON-RELOCATABLE CONSTANT 01\nK2       EQU   02                  NON-RELOCATABLE CONSTANT 02\nK3       EQU   03                  NON-RELOCATABLE CONSTANT 03\nK4       EQU   04                  NON-RELOCATABLE CONSTANT 04\nK5       EQU   05                  NON-RELOCATABLE CONSTANT 05\nK6       EQU   06                  NON-RELOCATABLE CONSTANT 06\nK7       EQU   07                  NON-RELOCATABLE CONSTANT 07\nK8       EQU   08                  NON-RELOCATABLE CONSTANT 08\nK9       EQU   09                  NON-RELOCATABLE CONSTANT 09\nKA       EQU   10                  NON-RELOCATABLE CONSTANT 10\nKB       EQU   11                  NON-RELOCATABLE CONSTANT 11\nKC       EQU   12                  NON-RELOCATABLE CONSTANT 12\nKD       EQU   13                  NON-RELOCATABLE CONSTANT 13\nKE       EQU   14                  NON-RELOCATABLE CONSTANT 14\nKF       EQU   15                  NON-RELOCATABLE CONSTANT 15\n*\n* CONSTANT EQUATES\n*\nSUBPOOL  EQU   252                 USE SUBPOOL 252 FOR GETMAIN\nCK       EQU   C'K'                CONSTANT CHAR 'K'\nCASTR    EQU   C'*'                CONSTANT CHAR '*'\nC0       EQU   C'0'                CONSTANT CHAR '0'\n         IEZBITS\n*\n* REGISTER EQUATES\n*\nR00      EQU   00                  REG 00 - WORK REG\nR01      EQU   01                  REG 01 - WORK/PARMETER REG\nR02      EQU   02                  REG 02 - WORK REG\nR03      EQU   03                  REG 03 - WORK REG\nR04      EQU   04                  REG 04 - UNUSED\nR05      EQU   05                  REG 05 - UNUSED\nR06      EQU   06                  REG 06 - BASE FOR OUTPUT LINE\nR07      EQU   07                  REG 07 - BASE FOR COMMON PARM AREA\nR08      EQU   08                  REG 08 - BASE FOR BLDL LIST\nR09      EQU   09                  REG 09 - BASE FOR SMF RECORD\nR10      EQU   10                  REG 10 - UNUSED\nR11      EQU   11                  REG 11 - UNUSED\nR12      EQU   12                  REG 12 - CSECT BASE REG\nR13      EQU   13                  REG 13 - DATA DSECT BASE REG\nR14      EQU   14                  REG 14 - LINKAGE REGISTER\nR15      EQU   15                  REG 15 - WORK REG\n         EJECT\n         SAVE  (14,12),,IEFACTRT_R01.0_&SYSDATE_&SYSTIME\n         USING IEFACTRT,R12        SET UP CSECT ADDRESSABILITY\n         LR    R12,R15             LOAD BASE REGISTER\n         USING DATA,R13            SET UP DATA DSECT ADDR.\n         USING JMR,R07             SET UP ADDRESSABILITY TO COMMON\n         L     R07,PARMEPRM-PARMS(K0,R01) COMMON AREA ADDRESS\n         TM    JMRINDC,JMRFIND     IS IT TIME SHARING USER?\n         BO    QUICKOUT            YES, EXIT BEFORE GETMAIN\n         L     R00,DATALEN         LOAD GETMAIN PARMS\n         GETMAIN R,LV=(0)          GET STORAGE FOR DATA DSECT\n         ST    R13,SAVEBK-SAVE(,R01) SAVE CALLER'S SAVE AREA ADDR\n         ST    R01,SAVEFW          SAVE MY SAVE AREA ADDRESS\n         LR    R15,R01             SAVE GETMAINED STORE ADDRESS\n         L     R01,SAVER1          RELOAD REGISTERS AFTER GETMAIN\n         L     R02,SAVER0          RELOAD REG2 WITH REG0 ENTRY  CODE\n         LR    R13,R15             LOAD REGISTER 13 WITH GETMAINED ADDR\n         MVC   PARMS(LPARMS),K0(R01) SAVE INPUT PARMS\n*\n*        SET UP RECOVERY ENVIRONMENT\n*\n         MVC   ESTAEW(LESTAEL),ESTAEL  MOVE IN ESTAE PARAMETER LIST\n         LA    R00,RTRYRTN1            RETRY ROUTINE - NO SDWA\n         ST    R00,ESTAPARM            STORE IN PARAMETER LIST\n         LA    R00,RTRYRTN2            RETRY ROUTINE - WITH SDWA\n         ST    R00,ESTAPARM+K4         STORE IN PARAMETER LIST\n         STM   R12,R13,ESTAPARM+K8     STORE BASE & DATA REG IN PARM\n         ESTAE RECOVERY,CT,PARAM=ESTAPARM,MF=(E,ESTAEW) SETUP RCVRY\n*\n*        DETERMINE REASON FOR ENTRY  STEP/JOB TERMINATION\n*\n         L     R09,PARMRECD        LOAD ADDRESS OF SMF RECORD\n         C     R02,R30CODE         WAS ENTRY CODE FOR REC30     MSEIPO4\n         BNE   EXIT                NO - EXIT                    MSEIPO4\n         USING SMFRCD30,R09                                     MSEIPO4\n         CLI   SMF30SON+1,K1       CHECK IF SSSEGMENT IS THERE  MSEIPO4\n         BL    EXIT                NO - EXIT                    MSEIPO4\n         LR    R04,R09             GET RECORD ADDRESS           MSEIPO4\n         A     R04,SMF30SOF        POINT TO SS SEGMENT          MSEIPO4\n         USING SMF30PSS,R04                                     MSEIPO4\n         CLC   SMF30TYP,R30JOB     WAS IT JOB TERMINATION       MSEIPO4\n         BE    JOBTERM             YES, HANDLE JOB TERM         MSEIPO4\n         CLC   SMF30TYP,R30STEP    WAS IT STEP TERMINATION      MSEIPO4\n         BNE   EXIT                EXIT IF NOT                  MSEIPO4\n         DROP  R04                                              MSEIPO4\n         EJECT\n*\n*        HANDLE STEP TERMINATION CONDITIONS\n*\nSTEPTERM DS    0H                  ENTRY FROM STEP TERMINATION\n         LA    R06,WTO1TXT         GET ADDRESS OF WTO TEXT AREA\n         USING LINE2,R06           SET UP ADDRESSABILITY TO LINE\n         L     R01,PARMINDC        LOAD ADDRESS OF STEP NO\n         CLI   K1(R01),K1          IS IT STEP 1?\n         BNE   NOTFIRST            NO, BR PAST HEADER LINE\n         MVC   WTO1TXT,LINE3A      MOVE HEADER LINE 1 TO OUTPUT\n         BAL   R14,MSGRTN          PUT OUT LINE\n         MVC   WTO1TXT,LINE3       MOVE SECOND HEADER\n         BAL   R14,MSGRTN          PUT IT OUT\nNOTFIRST MVI   WTO1TXT,C' '        INIT OUTPUT LINE TO BLANKS\n         MVC   WTO1TXT+K1(L'WTO1TXT-K1),WTO1TXT COPY BLANKS\n         MVC   JOBNAME,JMRJOB      MOVE JOBNAME INTO LINE\n         L     R01,PSAAOLD         GET ADDRESS OF CURRENT ASCB\n         L     R01,ASCBJBNI(K0,R01) GET ADDRESS OF JOBNAME FIELD\n         CLI   CHPROCSN(R01),C' '  IS PROC STEP NAME BLANK?\n         BNH   NOPROC              YES, DO NOT MOVE IT IN\n         MVC   PROCSTEP,CHPROCSN(R01) MOVE IN PROC STEP NAME\nNOPROC   CLI   CHSTEP(R01),C' '    IS STEP NAME BLANK?\n         BNH   PUTMSG1             YES, DO NOT MOVE IT IN\n         MVC   STEPNAME,CHSTEP(R01) MOVE IN STEP NAME\n*                                                               MSEIPO4\n* GET INFORMATION FROM COMPLETION SEGMENT                       MSEIPO4\n*                                                               MSEIPO4\nPUTMSG1  DS    0H                  CONTINUE PROCESSING\n         CLI   SMF30TON+1,K1       DOES COMPL SEGM EXIST        MSEIPO4\n         BL    PUTMSG1A            NO - GOTO NEXT SEGMENT       MSEIPO4\n         LR    R04,R09             GET RECORD ADDRESS           MSEIPO4\n         A     R04,SMF30TOF        POINT TO SS SEGMENT          MSEIPO4\n         USING SMF30CMP,R04                                     MSEIPO4\n         LA    R01,SMF30STI\n         SLR   R00,R00\n         ICM   R00,K3,SMF30SCC     GET COND CODE\n         BAL   R14,PRETCDE         CALL RETURN CODE ROUTINE\n         DROP  R04                                              MSEIPO4\n*                                                               MSEIPO4\n* GET INFORMATION FROM PERFORMANCE SECTION                      MSEIPO4\n*                                                               MSEIPO4\nPUTMSG1A DS    0H                  CONTINUE PROCESSING          MSEIPO4\n         CLI   SMF30PON+1,K1       DOES PERFORMANCE SECT EXIST  MSEIPO4\n         BL    PUTMSG1B            NO - GOTO NEXT SEGMENT       MSEIPO4\n         LR    R04,R09             GET RECORD ADDRESS           MSEIPO4\n         A     R04,SMF30POF        POINT TO PERFORM SEGMENT     MSEIPO4\n         USING SMF30PRF,R04                                     MSEIPO4\n         L     R01,SMF30SRV        SET SERVICE UNITS USED       MSEIPO4\n         BAL   R14,PCOUNT          CALL CONVERT ROUTINE\n         MVC   SERV,DWORD+L'DWORD-L'SERV MOVE TO OUTPUT LINE\n         DROP  R04                                              MSEIPO4\n*                                                               MSEIPO4\n* GET INFORMATION FROM ID SEGMENT                               MSEIPO4\n*                                                               MSEIPO4\nPUTMSG1B DS    0H                  CONTINUE PROCESSING          MSEIPO4\n         CLI   SMF30ION+1,K1       DOES ID SEGMENT EXIST        MSEIPO4\n         BL    PUTMSG1C            NO - GOTO NEXT SEGMENT       MSEIPO4\n         LR    R04,R09             GET RECORD ADDRESS           MSEIPO4\n         A     R04,SMF30IOF        POINT TO ID SEGMENT          MSEIPO4\n         USING SMF30ID,R04                                      MSEIPO4\n         LH    R01,SMF30PGN        GET PERFORMANCE GROUP NUM    MSEIPO4\n         BAL   R14,PCOUNT          CALL CONVERT ROUTINE\n         MVC   PG,DWORD+L'DWORD-L'PG MOVE TO OUTPUT LINE\n         TIME  BIN                 GET TIME IN HUNDREDS/SEC     MSEIPO4\n         LR    R01,R00             LOAD STEP TERM INTO REG 1    MSEIPO4\n         ICM   R00,15,SMF30SIT     LOAD STEP INIT TIME          MSEIPO4\n         BAL   R14,PCLOCK          CONVERT IT\n         MVC   CLOCK,DWORD+L'DWORD-L'CLOCK-K2 MOVE TO OUTPUT LINE\n         DROP  R04                                              MSEIPO4\n*                                                               MSEIPO4\n* GET INFORMATION FROM STORAGE AND PAGING SECTION               MSEIPO4\n*                                                               MSEIPO4\nPUTMSG1C DS    0H                  CONTINUE PROCESSING          MSEIPO4\n         CLI   SMF30RON+1,K1       DOES STORAGE SECTION EXIST   MSEIPO4\n         BL    PUTMSG1D            NO - GOTO NEXT SEGMENT       MSEIPO4\n         LR    R04,R09             GET RECORD ADDRESS           MSEIPO4\n         A     R04,SMF30ROF        POINT TO ID SEGMENT          MSEIPO4\n         USING SMF30SAP,R04                                     MSEIPO4\n         L     R01,SMF30NSW        GET NUMBER OF SWAPS          MSEIPO4\n         BAL   R14,PCOUNT          CONVERT IT\n         MVC   SWAPS,DWORD+L'DWORD-L'SWAPS MOVE IT TO OUTPUT\n         L     R01,SMF30PGI        GET NUMBER OF PAGE INS       MSEIPO4\n         A     R01,SMF30PGO        ADD NUMBER OF PAGE OUTS      MSEIPO4\n         BAL   R14,PCOUNT          CONVERT COUNT\n         MVC   PAGE,DWORD+L'DWORD-L'PAGE MOVE TO OUTPUT LINE\n         L     R01,SMF30PSI        GET NUMBER OF SWAP PAGE INS  MSEIPO4\n         A     R01,SMF30PSO        ADD NUMBER OF SWAP PAGE OUTS MSEIPO4\n         BAL   R14,PCOUNT          CONVERT COUNT\n         MVC   SWAP,DWORD+L'DWORD-L'SWAP MOVE TO OUTPUT LINE\n         L     R01,SMF30VPI        GET NUMBER OF VIO PAGE INS   MSEIPO4\n         A     R01,SMF30VPO        ADD NUMBER OF VIO PAGE OUTS  MSEIPO4\n         BAL   R14,PCOUNT          CONVERT COUNT\n         MVC   VIO,DWORD+L'DWORD-L'VIO MOVE TO OUTPUT LINE\n         DROP  R04                                              MSEIPO4\n*                                                               MSEIPO4\n* GET INFORMATION FROM CPU ACCOUNTING SECTION                   MSEIPO4\n*                                                               MSEIPO4\nPUTMSG1D DS    0H                  CONTINUE PROCESSING          MSEIPO4\n         SLR   R00,R00             CLEAR REG 0\n         L     R01,PARMSTPC        LOAD STEP CPU TIME ADDRESS\n         ICM   R01,K7,K0(R01)      LOAD STEP CPU TIME           MSPIPOI\n         LA    R01,K0(,R01)        ZERO HIGH ORDER BYTE\n         BAL   R14,PCLOCK          CONVERT FOR OUTPUT\n         MVC   CPU,DWORD+L'DWORD-L'CPU-K1 MOVE TO OUTPUT LINE\n         CLI   SMF30CON+1,K1       DOES CPU/ACC SECTION EXIST   MSEIPO4\n         BL    PUTMSG1E            NO - GOTO NEXT SEGMENT       MSEIPO4\n         LR    R04,R09             GET RECORD ADDRESS           MSEIPO4\n         A     R04,SMF30COF        POINT TO ID SEGMENT          MSEIPO4\n         USING SMF30CAS,R04                                     MSEIPO4\n         SLR   R00,R00             CLEAR REG 0\n         LR    R01,R00             CLEAR REG 1\n         ICM   R01,KF,SMF30CPS     LOAD SRB TIME                MSPIPOI\n         BAL   R14,PCLOCK          CONVERT IT\n         MVC   SRB,DWORD+L'DWORD-L'SRB-K1 MOVE IT TO OUTPUT LINE\n         DROP  R04                                              MSEIPO4\n*                                                               MSEIPO4\n* GET INFORMATION FROM I/O ACTIVITY SEGMENT                     MSEIPO4\n*                                                               MSEIPO4\nPUTMSG1E DS    0H                  CONTINUE PROCESSING          MSEIPO4\n         CLI   SMF30UON+1,K1       DOES I/O ACT SECTION EXIST   MSEIPO4\n         BL    PUTMSG1F            NO - GOTO NEXT SEGMENT       MSEIPO4\n         LR    R04,R09             GET RECORD ADDRESS           MSEIPO4\n         A     R04,SMF30UOF        POINT TO ID SEGMENT          MSEIPO4\n         USING SMF30URA,R04                                     MSEIPO4\n         L     R01,SMF30TEP        GET TOTAL NUMBER OF EXCPS    MSEIPO4\n         DROP  R04                                              MSEIPO4\n         BAL   R14,PCOUNT          CALL CONVERT ROUTINE\n         MVC   EXCP,DWORD+L'DWORD-L'EXCP MOVE TO OUTPUT LINE\nPUTMSG1F DS    0H                                               MSEIPO4\n         BAL   R14,MSGRTN          PUT LINE OUT\n         B     EXIT                BR TO EPILOGUE CODE\n         SPACE 3                                                MSEIPO4\n*                                                               MSEIPO4\n*        HANDLE JOB TERMINATION CONDITIONS                      MSEIPO4\n*                                                               MSEIPO4\nJOBTERM  DS    0H                  ENTRY ON JOB TERMINATION\n         MVC   WTO1TXT,LINE4       SET UP OUTPUT LINE\n         MVC   WTO1TXT+LINE4J(L'LINE4J),JMRJOB MOVE IN JOB NAME\n         L     R01,PARMPROG        LOAD ADDR OF PROGRAMMER NAME\n         MVC   WTO1TXT+LINE4N(L'LINE4N),K0(R01) MOVE IN PROG NAME\n         SLR   R00,R00             ZERO REG\n         LR    R01,R00             ZERO REG 1\n         L     R02,PARMJOBC        LOAD ADDR OF JOB CPU TIME\n         ICM   R01,K7,K0(R02)      LOAD JOB CPU TIME\n         BAL   R14,PCLOCK          CONVERT TIME FOR OUTPUT\n         MVC   WTO1TXT+LINE4C(L'LINE4C),DWORD+L'DWORD-L'LINE4C-K1\n*                                                               MSEIPO4\n* GET INFORMATION FROM ID SEGMENT                               MSEIPO4\n*                                                               MSEIPO4\n         CLI   SMF30ION+1,K1       DOES ID SEGMENT EXIST        MSEIPO4\n         BL    PUTMSG2             NO - GOTO NEXT SEGMENT       MSEIPO4\n         LR    R04,R09             GET RECORD ADDRESS           MSEIPO4\n         A     R04,SMF30IOF        POINT TO ID SEGMENT          MSEIPO4\n         USING SMF30ID,R04                                      MSEIPO4\n         TIME  BIN                 GET TIME IN HUNDREDS/SEC     MSEIPO4\n         LR    R01,R00             GET JOB TERM TIME            MSEIPO4\n         ICM   R00,15,SMF30SIT     GET JOB INIT TIME            MSEIPO4\n         DROP  R04,R09                                          MSEIPO4\n         BAL   R14,PCLOCK          CONVERT TIME FOR OUTPUT\n         MVC   WTO1TXT+LINE4E(L'LINE4E),DWORD+L'DWORD-L'LINE4E-K2\n         BAL   R14,MSGRTN          PRINT LINE\nPUTMSG2  DS    0H                                               MSEIPO4\n*   FIND BULLETIN\n         LA    R08,BLDLWORK        LOAD ADDR OF BLDL LIST\n         USING BLDL,R08            SET UP ADDR. TO BLDL PARM LIST\n         LA    R01,K1              LOAD A 1\n         STH   R01,BLDLFF          STORE IN BLDL LIST\n         LA    R01,BLDLELEN        LOAD LENGTH OF BLDL ENTRY LEN\n         STH   R01,BLDLLL          STORE ENTRY LENGTH\n         MVC   BLDLNAME,=CL8'BULLETIN' LOAD PROGRAM NAME\n         LR    R00,R08             LOAD REG 0 WITH BLDL\n         BLDL  0,(0)               ISSUE BLDL FOR MODULE\n         LTR   R15,R15             WAS IT THERE?\n         BNZ   EXIT                NO, BR TO EXIT EPILOGUE\n         CLI   BLDLZ,K2            WAS IT OUT OF LINKLIST\n         BNL   EXIT                NO, BR TO EXIT PROLOGUE\n         LA    R02,BLDLNAME        GET BLDL ENTRY ADDRESS\n         MVC   LINKE,LINKL         MOVE IN LINK LIST FORM\n         LINK  DE=(2),SF=(E,LINKE) LINK TO BULLETIN ROUTINE\n         DROP  R08                 DROP BLDL DSECT\n         SPACE 3\nEXIT     DS    0H                  EXIT PROLOGUE\n         ESTAE 0                   CANCEL ESTAE EXIT\nRTRYRTN2 DS    0H                  ESTAE RETRY ROUTINE WITH SDWA\n*                                  JUST FREE STORAGE AND EXIT\n         LR    R01,R13             GET FREEMAIN ADDRESS\n         L     R13,SAVEBK          LOAD OLD REG 13\n         L     R00,DATALEN         LOAD FREEMAIN PARM\n         FREEMAIN R,LV=(0),A=(1)   FREE DATA DSECT STORAGE\nQUICKOUT RETURN (14,12),RC=0       RETURN TO CALLER\n         EJECT\nMSGRTN   DS    0H                  MESSAGE(WTO) ROUTINE\n         STM   R14,R01,SAVEAR2     SAVE A FEW REGISTERS\n         LA    R01,L'WTO1TXT+K4    GET LENGTH FOR WTO\n         STH   R01,WTO1LEN         STORE IN WTO PARM LIST\n         MVC   WTO1MCS,MCSFLAG     MOVE IN MCSFLAG\n         MVC   WTO1DESC,DESC       MOVE IN DESCRIPTOR CODES\n         MVC   WTO1ROUT,ROUT       MOVE IN ROUTE CODES\n         MVI   WTO1TXT,C'-'        MOVE IN MESSAGE PREFIX\n         WTO   MF=(E,WTO1)         ISSUE WTO\n         LM    R14,R01,SAVEAR2     RESTORE REGISTERS\n         BR    R14                 RETURN TO CALLER\n***********************************************************************\n*                                                                     *\n*  COUNT CONVERSION ROUTINE: CONVERTS BINARY TO CHARACTER OUTPUT      *\n*        INPUT   REG 1 HAS COUNT TO BE CONVERTED                      *\n*        OUTPUT  DWORD COUNTAINS CHARACTER OUTPUT FIELD               *\n*                                                                     *\n***********************************************************************\nPCOUNT   SAVE  (14,12)             SAVE CALLER'S REGISTERS\n         CVD   R01,DWORD           CONVERT COUNT TO DECIMAL\n         MVC   EDWORK2,EDMASK2     MOVE IN EDIT MASK\n         ED    EDWORK2,DWORD+K2    CONVERT TO CHARACTER\n         CP    DWORD,P99999        IS COUNT>99999?\n         BNH   NOFLOAT             NO, BR PAST FLOAT CODE\n         MVC   DWORD(L'DWORD-K1),EDWORK2+K2 SHIFT IT RIGHT 3 DEC DIGTS\n         MVI   DWORD+L'DWORD-K1,CK MOVE A 'K' FOR THOUSANDS\n         B     PCNTEX              BR TO RETURN\nNOFLOAT  MVC   DWORD,EDWORK2+K4    MOVE IN UNFLOATED COUNT\nPCNTEX   RETURN (14,12)            RETURN TO CALLER\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  CLOCK CONVERSION ROUTINE: CONVERTS BINARY TO CHARACTER OUTPUT      *\n*        INPUT   REG 1 HAS FIRST TIME                                 *\n*                REG 0 HAS SECOND TIME\n*        OUTPUT  DWORD COUNTAINS CHARACTER OUTPUT FIELD               *\n*                                                                     *\n***********************************************************************\nPCLOCK   SAVE  (14,12)             SAVE CALLER'S REGISTERS\n         SR    R01,R00             GET TIME DIFFERENCE\n         BNL   LSTH24              IF DIFFERENCE>=0 THEN SKIP\n         A     R01,HR24            ELSE ADD 24 HOURS TO TIME\nLSTH24   DS    0H                  SKIPPED TO HERE\n         SLR   R00,R00             ZERO REG FOR DIVIDE\n         D     R00,F6              DIVIDE TIME BY 6\n         C     R01,TOVER           IF TIME<MAX THEN\n         BL    NOTOVER              BR TO CONVERT IT\n         MVI   DWORD,CASTR         ELSE OVERFLOW FILL WITH\n         MVC   DWORD+K1(L'DWORD-K1),DWORD ********\n         B     PCLKEX              BR TO RETURN\nNOTOVER  CVD   R01,DWORD           CONVERT TIME TO DECIMAL\n         MVC   EDWORK,EDMASK       MOVE IN EDIT MASK\n         ED    EDWORK,DWORD+K4     CONVERT TO CHARACTER\n         MVC   DWORD,EDWORK+K1     MOVE TO RETURN AREA\nPCLKEX   RETURN (14,12)            RETURN TO CALLER\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  CONDITION CODE CONVERSION ROUTINE: CHARACTER OUTPUT INTO RC FIELD  *\n*        INPUT   REG 0 HAS            STEP TERM CONDTION CODE         *\n*                REG 1 HAS ADDRESS OF STEP TERM INDICATOR FIELD       *\n*        OUTPUT  FIELD RC OF OUTPUT LINE CONTAINS RETURN CODE         *\n*                                                                     *\n***********************************************************************\nPRETCDE  SAVE  (14,12)             SAVE CALLER'S REGISTERS\n         TM    K0(R01),SMF30FLH    WAS STEP FLUSHED             MSEIPO4\n         BNO   NOFLUSH             NO,BRANCH PAST\n         MVC   RC,=C'FLUSH'        MOVE IN FLUSHED MESSAGE\n         B     PRETEXT             BR TO RETURN\nNOFLUSH  TM    K0(R01),SMF30ABD    DID IT ABEND?                MSEIPO4\n         BO    STPABEND            YES, GO CONVERT ABEND CODE\n         N     R00,=A(X'FFF')      ZERO UNUSED PORTION\n         CVD   R00,RWORK           GET ADDRESS OF COND FIELD\n         MVC   RC-K1(L'RC+K1),=X'402020212020' MOVE IN EDIT MASK\n         ED    RC-K1(L'RC+K1),RWORK+K5 CONVERT RET CODE TO CHAR\n         B     PRETEXT             BR TO RETURN\nSTPABEND CLM   R00,2,=X'80'        WAS IT A USER ABEND CODE?\n         BL    SYSABND             NO, PROCESS SYSTEM ABEND CODE.\n         N     R00,=A(X'FFF')      TURN OFF X'80' BIT\n         CVD   R00,RWORK           CONVERT FOR OUTPUT\n         MVC   RC-K1(L'RC+K1),=X'402120202020' MOVE IN EDIT MASK\n         ED    RC-K1(L'RC+K1),RWORK+K5 CONVERT TO CHARACTER\n         MVI   RC,C'U'             MOVE IN 'U' USER ABEND\n         B     PRETEXT             BR TO RETURN\nSYSABND  STH   R00,RWORK           STORE ABEND CODE\n         UNPK  RWORK+K3(K5),RWORK(K3) ADD ZONES TO CC FIELD\n         TR    RWORK+K4(K3),TRTAB-C0 TRANSLATE TO CHARACTERS\n         MVC   RC+K2(L'RC-K2),RWORK+K4  MOVE TO OUTPUT LINE\n         MVC   RC(K2),=C'*S'       MOVE IN S FOR SYSTEM ABEND\nPRETEXT  RETURN (14,12)            RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*  ESTAE EXIT ROUTINE                                                 *\n*                                                                     *\n***********************************************************************\nRECOVERY DS    0H\n         USING *,R15               SET UP ADDRESSABILITY\n         LA    R04,K4              PUT 4 IN REGISTER FOR COMPARE\n         CR    R00,R04             IS SDWA PRESENT?\n         BNE   HAVESDWA            YES, BR TO PROCESS WITH SDWA\n         L     R00,K0(R02)         LOAD RETRY ADDRESS FROM PARAM LIST\n         LA    R15,K4              SET RETCODE TO RETRY ADDR IN R00\n         BR    R14                 RETURN TO PROCESSOR WITH RETRY ADDR\nHAVESDWA DS    0H                  ENTER HERE IF SDWA PRESENT\n         ST    R14,KC(R13)         SAVE RETURN ADDRESS\n         L     R02,K0(R01)         LOAD PARAM LIST ADDR FROM SDWA\n         L     R02,K4(R02)         LOAD RETRY ADDRESS\n         SETRP RC=4,,RETADDR=(2),RETREGS=YES,FRESDWA=YES,REGS=(14)\n         DROP  R15\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*  ESTAE RETRY ROUTINE WHEN NO SDWA WAS PRESENT                       *\n*                                                                     *\n***********************************************************************\nRTRYRTN1 DS    0H                  RETRY ROUTINE WITH NO SDWA PRESENT\n         LM    R12,R13,K8(R01)     LOAD REGS FOR ESTAE PARM LIST\n         B     RTRYRTN2            AND GET OUT\n         EJECT\n*\n*  OUTPUT LINE DSECT FOR STEP TERMINATION MESSAGE\n*\nLINE2    DSECT\n         DS    C\nJOBNAME  DS    CL8                 JOB NAME\n         DS    C\nSTEPNAME DS    CL8                 STEPNAME\n         DS    C\nPROCSTEP DS    CL8                 PROCEDURE STEP NAME\n         DS    C\nRC       DS    XL5                 RETURN/ABEND CODE\n         DS    C\nEXCP     DS    XL6                 EXCP COUNT\n         DS    C\nCPU      DS    XL6                 TCB CPU TIME\n         DS    C\nSRB      DS    XL6                 SRB CPU TIME\n         DS    C\nCLOCK    DS    XL6                 ELAPSED TIME\n         DS    C\nSERV     DS    XL6                 SERVICE UNITS\n         DS    C\nPG       DS    XL3                 PERFORMANCE GROUP\n         DS    C\nPAGE     DS    XL6                 NUMBER OF PAGE-INS + PAGE OUTS\n         DS    C\nSWAP     DS    XL6                 NUMBER OF PAGES XFER'D ON SWAPS\n         DS    C\nVIO      DS    XL6                 NUMBER OF PAGES XREF'D FOR VIO\n         DS    C\nSWAPS    DS    XL5                 NUMBER OF SWAPS\nLLINE2   EQU   *-LINE2\n*\nBLDL     DSECT                     BLDL PARM LIST\nBLDLFF   DS   H                    TOTAL LENGTH OF PARMLIST\nBLDLLL   DS   H                    LENGTH OF EACH ENTRY\nBLDLNAME DS   CL8                  MEMBERNAME\nBLDLTTR  DS   XL3                  TTR OF MEMBER\nBLDLK    DS   X                    K FIELD\nBLDLZ    DS   X                    Z FIELD\nBLDLC    DS   X                    C FIELD\nBLDLUSER DS   CL44                 USER DATA FIELD\nBLDLELEN EQU  *-BLDLNAME\nBLDLLEN  EQU  *-BLDLFF\n*\nIEFACTRT CSECT\nLINE3    DS    0CL(LLINE2)         OUTPUT LINE HEADER\n         DC    C' '\n         DC    CL30'JOBNAME  STEPNAME PROCSTEP'\n         DC    C'RC'\n         DC    CL3' '\n         DC    C'EXCP'\n         DC    CL4' '\n         DC    C'CPU'\n         DC    CL4' '\n         DC    C'SRB'\n         DC    CL2' '\n         DC    C'CLOCK'\n         DC    CL3' '\n         DC    C'SERV'\n         DC    CL2' '\n         DC    C'PG'\n         DC    CL3' '\n         DC    C'PAGE'\n         DC    CL3' '\n         DC    C'SWAP'\n         DC    CL4' '\n         DC    C'VIO'\n         DC    CL1' '\n         DC    C'SWAPS'\nLLINE3   EQU   *-LINE3\n         ORG   LINE3+LLINE2\n*\nLINE3A   DS    0CL(LLINE2)         OUTPUT LINE FIRST HEADER\n         DC    C' '\n         DC    CL41' '\n         DC    CL2'--'\n         DC    C'TIMINGS (MINS.)'\n         DC    CL2'--'\n         DC    CL12' '\n         DC    CL4'----'   12\n         DC    C'PAGING COUNTS'  3456\n         DC    CL3'---'   789\n         DC    CL6' '\n         ORG   LINE3A+LLINE2\n*\nLINE4    DC    CL(LLINE2)' '       JOB TERMINATION MESSAGE LINE\n         ORG   LINE4\n         DC    C' '\n         DC    C'XXXXXXXX ENDED.  NAME-XXXXXXXXXXXXXXXXXXXX TOTAL CPU TC\n               IME=XXX.XX  TOTAL ELAPSED TIME=XXXX.X'\n*                012345678901234567890123456789012345678901234567890123\n*         50-> 45678901234567890123456789012345678901234567890123456789\n         ORG   LINE4+LLINE2\nLINE4J   EQU   1,8         OFFSET OF JOBNAME IN LINE4 TEXT\nLINE4N   EQU   23,20       OFFSET OF NAME IN LINE4 TEXT\nLINE4C   EQU   59,6        OFFSET OF CPU TIME IN LINE4 TEXT\nLINE4E   EQU   86,6        OFFSET OF ELAPSED TIME IN LINE4 TEXT\n*\nR30CODE  DC    F'20'               CODE FOR NEW RECORD 30       MSEIPO4\nR30STEP  DC    H'4'                  STEP TERMINATION           MSEIPO4\nR30JOB   DC    H'5'                  JOB TERMINATION            MSEIPO4\nF6       DC    F'6'\nTOVER    DC    F'10000000'         OVERFLOW CONSTANT\nHR24     DC    A(24*60*60*100)     24 HRS IN .01 SECONDS\nMCSFLAG  DC    B'1000001000000000' ROUT+HRDCPY\n*                0123456789ABCDEF\nDESC     DC    B'0000000000000000' NO DEC CODES\n*                1234567890123456\nROUT     DC    B'0000000000000100' ROUT CODE=14\n*                1234567890123456\nEDMASK   DC    XL9'40202020214B202020'\nP99999   DC    P'99999'\nEDMASK2  DC    XL12'402020202020202020202120'\nTRTAB    DC    C'0123456789ABCDEF'\n*\n* DEFINE ESTAE LIST FORM\n*\nESTAEL   ESTAE MF=L               CREATE MODEL ESTAE PARM LIST\nLESTAEL  EQU   *-ESTAEL           NAME ITS LENGTH\n*\n* DEFINE LINK  LIST FORM\n*\nLINKL    LINK  DE=0,SF=L          CREATE MODEL LINK PARM LIST\nLLINKL   EQU   *-LINKL            NAME ITS LENGTH\n*\nDATA     DSECT\nSAVE     DS    18F              SAVE AREA FOR REGISTERS ON ENTRY\n         ORG   SAVE\nSAVEXX   DS    F\nSAVEBK   DS    F\nSAVEFW   DS    F\nSAVER14  DS    F\nSAVER15  DS    F\nSAVER0   DS    F\nSAVER1   DS    F\n         DS    11F\n*\nDWORD    DS    D\nRWORK    DS    D\n*\nLINKE    DS    XL(LLINKL)       LINK PARM LIST AREA\n*\nESTAEW   DS    XL(LESTAEL)      ESTAE PARM LIST AREA\nESTAPARM DS    4F               PARAMETER LIST PASSED TO RETRY ROUTINE\n*              RETRY ROUTINE ADDRESS  NO SWDA OBTAINED\n*              RETRY ROUTINE ADDRESS  SWDA OBTAINED\n*              BASE REGISTER R12\n*              DATA REGISTER R13\n*\nSAVEAR2  DS    6F               INTERNAL SAVE REGISTER SAVE AREA\n*\nPARMS    DS    0F               PARMS PASSED IN REG 1 TO ROUTINE\nPARMEPRM DS    F                PTR TO COMMON EXIT PARAMETER AREA\nPARMSTEP DS    F                PTR TO STEPNAME FIELD\nPARMPROG DS    F                PTR TO PROGRAMMER NAME FIELD\nPARMJOBC DS    F                PTR TO JOB CPU TIME FIELD\nPARMACCT DS    F                PTR TO JOB ACCOUNTING FIELDS\nPARMSTPC DS    F                PTR TO STEP CPU TIME FIELD\nPARMSACT DS    F                PTR TO STEP ACCOUNTING FIELDS\nPARMINDC DS    F                PTR TO CANCEL FLAG & STEP NUMBER\nPARMCOND DS    F                PTR TO CONDITION CODE FIELD\nPARMRECD DS    F                PTR TO SMF RECORD TO BE WRITTEN\nLPARMS   EQU   *-PARMS\n*\nBLDLWORK DS    CL(BLDLLEN)\n*\nEDWORK   DC    XL9'00'\nEDWORK2  DC    XL12'00'\n*\nLWTO1    EQU   LLINE2+KA\n         DS    0F\nWTO1     DS    0CL(LWTO1)\nWTO1LEN  DS    XL2\nWTO1MCS  DS    XL2\nWTO1TXT  DS    CL(LLINE2)       MESSAGE TEXT\nWTO1DESC DS    XL2\nWTO1ROUT DS    XL2\n*\n         EJECT\n         IFASMFR 30                SMF TYPE 30 RECORD           MSEIPO4\n         EJECT\n         IEFJMR                    JMR MAPS COMMON PARAMETER AREA\n         EJECT\n         IHASDWA DSECT=YES         SDWA FOR ESTAE/SETRP MACRO\n         EJECT\nDATA     DSECT\n         DS    6D             RESERVE FOR ZAPS\nLDATA    EQU   *-DATA\nIEFACTRT CSECT\n         LTORG ,\n         DS    0D\nDATALEN  DC    0F'0',AL1(SUBPOOL),AL3(LDATA)\nMODLEN   EQU   *-IEFACTRT\nLPATCH   EQU   (MODLEN+K9)/KA/K8+K1 ADD 10% FOR PATCH AREA\nLPATCHL  DC    AL2(LPATCH*K8)\nSPATCH   DC    S(PATCH)\nPATCH    DC    (LPATCH)D'00'\n         END   IEFACTRT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEFUSI": {"ttr": 4355, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00w\\x00w\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 119, "newlines": 119, "modlines": 0, "user": "FILE369"}, "text": "         TITLE 'MEMLIMIT - IEFUSI EXIT TO SET REGION AND GETMAIN PARAME+\n               TERS'\n***********************************************************************\n*                                                                     *\n* NAME         MEMLIMIT                                               *\n*                                                                     *\n* COMPONENT    SYSTEM IEFUSI EXIT                                     *\n*                                                                     *\n* FUNCTION     SET LIMITS FOR REGION AND GETMAINS.                    *\n*                                                                     *\n* ENTRY        FROM IEFSMFIE                                          *\n*                                                                     *\n* PARAMETERS   SEE PARMLIST DSECT                                     *\n*                                                                     *\n* INPUT        PARMLIST                                               *\n*                                                                     *\n* OUTPUT       UPDATED VSM PARAMETER LIST                             *\n*                                                                     *\n* RETURN CODES ZERO                                                   *\n*                                                                     *\n* EXT REF      NONE                                                   *\n*                                                                     *\n* MESSAGES     NONE                                                   *\n*                                                                     *\n* MACROS       SAVE                                                   *\n*              REGS                                                   *\n*              RETURN                                                 *\n*                                                                     *\n* TABLES       NONE                                                   *\n*                                                                     *\n* OPERATION    THE IEFUSI LIMIT FLAG IS SET ON IN THE VSM             *\n*              PARAMETER LIST. THIS ENABLES VSM LOGIC TO SET          *\n*              REGION AND GETMAIN LIMITS. NO SPECIFIC VALUES ARE      *\n*              SET.                                                   *\n*                                                                     *\n* ATTRIBUTES   REENTRANT                                              *\n*              REUSABLE                                               *\n*              SUPERVISOR STATE                                       *\n*              KEY ZERO                                               *\n*              AUTHORIZED                                             *\n*              LPALIB                                                 *\n*              AMODE ANY                                              *\n*              RMODE ANY                                              *\n*                                                                     *\n* RESTRICTIONS NONE                                                   *\n*                                                                     *\n* NOTES        THIS EXIT ADDRESSES A PROBLEM WHICH CAUSES ADDRESS     *\n*              SPACES TO FAIL WHEN A V-FORM GETMAIN IS ISSUED         *\n*              WHICH GETS THE ENTIRE PRIVATE AREA BELOW THE 16M       *\n*              LINE. ITS PURPOSE IS TO RESERVE FOR SYSTEM USE         *\n*              (EG, ABTERM) A REASONABLE AMOUNT OF STORAGE.           *\n*                                                                     *\n* PROGRAMMER   C. J. PITTS                                            *\n*                                                                     *\n* MAINTENANCE  WHO    DATE     DESCRIPTION                            *\n*                                                                     *\n**********************************************************************/\n*                                                                     *\n* REGISTERS AT ENTRY                                                  *\n*              R1    PARM LIST POINTER                                *\n*              R13   SAVE AREA                                        *\n*              R14   RETURN ADDRESS                                   *\n*              R15   ENTRY POINT                                      *\n*                                                                     *\n**********************************************************************/\n         EJECT\nMEMLIMIT CSECT\n         SPACE\nMEMLIMIT AMODE ANY\nMEMLIMIT RMODE ANY\n         SPACE\nIEFUSI   DS    0H\n         ENTRY IEFUSI\n         SAVE  (14,12),,MEMLIMIT.&SYSDATE..&SYSTIME\n         SPACE\n         LR    R11,R15             SET UP\n         USING MEMLIMIT,R11        REG 11 AS BASE\n         SPACE\n         USING PARMLIST,R1\n         L     R2,VSMLISTA         VSM LIST PARAMETER\n         USING VSMLIST,R2\n         LA    R2,0(,R2)           PURIFY R2 AGAINST ADDRESS MODE ERROR\n         SPACE\n         OI    VSMFLAG1,VSMFUSIL   TELL VSM IEFUSI IS SETTING LIMIT\n         SPACE\n         RETURN (14,12),RC=0\n         SPACE 2\n         LTORG\n         EJECT\n***********************************************************************\n*        DSECTS                                                       *\n***********************************************************************\n         SPACE\nPARMLIST DSECT\nSMFPA    DS    A                   COMMON SMF EXIT PARM AREA ADDRESS\nSTEPNMA  DS    A                   STEP NAME ADDRESS\nPROGNMA  DS    A                   PROGRAM NAME ADDRESS\nACCTA    DS    A                   ACCOUNTING INFO ADDRESS\nVSMLISTA DS    A                   VSM PARM LIST ADDRESS\nSRMINFOA DS    A                   SRM INFO WORD ADDRESS\n         SPACE\nVSMLIST  DSECT\nVSMFLAGS DS    0XL4                FLAGWORD\nVSMFLAG1 DS    X                   FLAG BYTE 1\nVSMFUSIL EQU   X'80'               IEFUSI SUPPLYING REGION LIMIT VALUES\nVSMFNOLO EQU   X'40'               NO VSM CHECK FOR FIT BELOW 16M\nVSMFGOHI EQU   X'20'               VSM CHECK FOR FIT ABOVE 16M\nVSMFLAG2 DS    X                   RESERVED\nVSMFLAG3 DS    X                   RESERVED\nVSMFLAG4 DS    X                   RESERVED\nVSMREGRQ DS    F                   REGION SIZE REQUESTED\nVSMGMLO  DS    F                   GETMAIN LIMIT BELOW 16M\nVSMREGLO DS    F                   REGION SIZE BELOW 16M\nVSMGMHI  DS    F                   GETMAIN LIMIT ABOVE 16M\nVSMREGHI DS    F                   REGION SIZE ABOVE 16M\n         SPACE\n         REGS    ,                 REGISTER EQUATE\n         SPACE 3\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IGC0022F": {"ttr": 4358, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\x85\\x00\\x85\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 133, "newlines": 133, "modlines": 0, "user": "FILE369"}, "text": "         TITLE 'IGC0022F,SVC 226, WRITE USER SMF RECORD'\n*-------\n*------- TITLE: IGC0022F,SVC 226, WRITE USER SMF RECORD.\n*-------\n*------- AUTHOR: DICK SZIEDE CSC 1972\n*-------\n*------- PURPOSE: WRITE SMF RECORD CONTAINING ACCOUNTING DATA\n*-------       FROM SUCH PACKAGES AS TELAGRAF, THAT REQUIRE THEIR\n*-------       OWN ACCOUNTING DATA.\n*-------\n*------- METHOD:THE CALLER MUST PROVIDE A POINTER TO THE SMF RECORD IN\n*-------       REGISTER ONE.  SVC226 WILL VALIDATE THE ARGUMENTS,\n*-------       FILL IN THE STANDARD SMF HEADER AND DISPATCH\n*-------       THE RECORD WITH A SMFWTM MACRO.\n*-------\n*-------       THE RECORD PROVIDED MUST CONTAIN 26-BYTES PREFIX FOR\n*-------       THE HEADER.\n*-------\n*------- ARGUMENTS: THE SMF HEADER MUST CONTAIN \"240\" FOR SMF\n*-------       RECORD TYPE.  THE USER SECTION LENGTH INDICATOR\n*-------       MUST BE VALID: GREATER THAN ZERO AND, JUST TO BE A\n*-------       SNOT, I'LL LIMIT IT TO LESS THAN 4096.\n*-------       THE USER RECORD TYPE MUST BELONG TO A KNOWN LIST.\n*-------       ASSIGNMENTS ARE:\n*-------           1-USPTO SYSTEM MANAGEMENT SUBSYSTEM\n*-------           2-VTAM SESSION ACCOUNTING\n*-------           3-USPTO MESSENGER ACCOUNTING\n*-------           4-\n*-------           5-\n*-------\n*-------\n*------- OUTPUT: RETURN CODES ARE PROVIDED IN REGISTERS 15, AND ZERO,\n*-------       AS FOLLOWS.\n*-------       R15 - 0  SMF RECORD WRITTEN\n*-------             4\n*-------             8  UNKNOWN USER RECORD TYPE.\n*-------            12  BAD RETURN FROM SMFWTM. R0 HAS SMFWTM RC.\n*-------            16  INVALID CALLING PARAMETERS.\n*-------       R0  - 0  WILL NOT HAPPEN.\n*-------            \u00ac0  WILL BE NON-ZERO RC FROM SMFWTM. R15 = 12\n*-------\n*------- NOTE: THIS CODE CONTAINS  NO PROTECTION AGAINST RECURSION.\n*-------       A LOOPING USER COULD FILL SMF.  AN 0C4 IS POSSIBLE\n*-------       IF R1 IS NON-ZERO,  BUT POINTS TO A PROTECTED AREA.\n*-------\n*------- CHANGES: CHANGE SMF230 MACRO TO SMF240.  SMF230 WAS ALREADY\n*-------       TAKEN HERE AT THE USPTO PROJECT, AND SET THE XA BIT\n*-------       IN THE RECORD HEADER.  CHECK TO BE SURE THE SMF RECORD\n*-------       IS BELOW 16MEG LINE.\n*-------       DICK SZIEDE, PRC, 1985.\n*-------       ALLOW  RECORD SUBTYPES 1-5. PTW 06/24/86.\n*-------\nIGC0022F CSECT\nIGC0022F AMODE 31\nIGC0022F RMODE ANY\n         REGS\n         USING *,R6                ADDRESSABILITY\n         USING TCB,R4              ADDRESSABILITY\n         USING ASCB,R7             ADDRESSABILITY\n         USING CVT,R3              ADDRESSABILITY\n*-------\n*-------       VALIDATION ROUTINES\n*-------\n         LTR   R11,R1              CHECK FOR VALID RECORD POINTER\n         BZ    DUWHUT              IT MUST BE NON-ZERO, AND LESS THAN\n         N     R11,=F'2130706432'  16-MEG.\n         BNZ   DUWHUT              NO SMF RECORD ==> RC 16.\n         LR    R11,R1\n         USING SM240BLK,R11        ELSE MAKE IT ADDRESSABLE\n         LR    R11,R1\n         CLI   SM240RTY,240        CSC USER RECORD?\n         BNE   DUWHUT              NO ==> RC 16\n         LH    R2,SM240ULN         IS THE LENGTH IF THE USER SECTION\n         CH    R2,=H'4096'            VALID?\n         BH    DUWHUT              NO ==> RC 16\n         CLC   SM240TYP,=H'1'      IZZIT A KNOWN USER RECORD TYPE?\n         BL    RET8                NO ==> RC 8.\n         CLC   SM240TYP,=H'5'      IZZIT A KNOWN USER RECORD TYPE?\n         BH    RET8                NO ==> RC 8.\n*-------\n*-------       FILL IN SMF HEADER\n*-------\nSMFHEAD  AH    R2,=H'26'           ADD IN LENGTH OF SMF HEADER\n         SLL   R2,16               AND ZERO SEGMENT DESCRIPTOR\n         ST    R2,SM240LEN\n         SPACE\n         L     R2,CVTSMCA          FIND THE SMF CONTROL AREA\n         MVC   SM240SID,X'10'(R2)  AND GIT THE SID\n         OI    SM240FLG,X'06'      SAY WE'RE MVS/XA  9/20/85--RRS\n         SPACE\n         ICM   R2,15,TCBTCT        GET THE READER TIME OUT OF JMR\n         BZ    NOJMR\n         USING SMFTCT,R2\n         ICM   R2,15,TCTJMR\n         BZ    NOJMR\n         DROP  R2\n         USING JMR,R2\n         MVC   SM240RST(8),JMRDRSTP\n         DROP  R2\n         SPACE\nNOJMR    TIME  BIN                 GET BUFFER MOVE TIME INTO RECORD\n         STCM  R0,15,SM240TME\n         STCM  R1,15,SM240DTE\n         SPACE\n*-------\n*-------       DO THE DEED\n*-------\n         SMFWTM (R11)\n         LTR   R15,R15             DID IT WORK?\n         BZR   R14\n         SPACE\nRETC     LR    R0,R15              NO ==> SAVE SMFWTM RC\n         LA    R15,12              AND RETURN 12 OURSELVES\n         BR    R14\n         SPACE\nRET8     LA    R15,8\n         BR    R14\nDUWHUT   LA    R15,16\n         BR    R14\n         LTORG\nSRCLEVEL DC    C'IGC0022F V01.M05 85/09/26 17:57 PSYRRS  '\n*                MODULE   VER/MOD   DATE   TIME  USER NAME\nCOPYRIGT DC    C' COPYRIGHT (C) 1985 PLANNING RESEARCH CORPORATION '\nASMSTAMP DC    C'ASM &SYSDATE &SYSTIME'\n         PRINT ON,NOGEN\n         IKJTCB\n         IHAASCB\n         IEFJMR\n         IEFTCT\n         CVT   DSECT=YES\n         PRINT ON,GEN\n         SMF240 DSECT=YES\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IKJEFF10": {"ttr": 4361, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x02\\x93\\x02\\x93\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 659, "newlines": 659, "modlines": 0, "user": "FILE369"}, "text": "PRC      TITLE 'IKJEFF10 - TSO/E SUBMIT EXIT ROUTINE.'\n***********************************************************************\n*                                                                     *\n* NAME - TSO/E SUBMIT EXIT ROUTINE.                                   *\n*                                                                     *\n* DESCRIPTION - THIS EXIT IS DOCUMENTED IN THE SPL: TSO MANUAL.       *\n*   WE USE THIS EXIT TO INSERT A COMMENT CARD AFTER EACH JOB CARD     *\n*   THAT NAMES THE JCL SOURCE DATASET.  IF IT'S SUB FROM TSO EDIT     *\n*   OR ISPF EDIT, WE HAVE TO DIG FOR THE REAL DATASET NAME.  IF       *\n*   IT'S A SPECIAL ISPF UTILITY DSN, WE PUT OUT A FIXED MESSAGE.      *\n*   IF IT'S SUBMIT *, WE SAY SO.  ELSE, WE USE THE SUBMIT DSN AS IS.  *\n*                                                                     *\n* LEVEL - THIS MODULE HAS BEEN TESTED WITH TSO/E R2 AND ISPF V2R2.    *\n*   THERE ARE MORE DEPENDENCIES THAN USUAL ON INTERNAL CONTROL        *\n*   BLOCKS WITHIN THESE PRODUCTS.  IT IS ALSO VERY SENSITIVE TO RB,   *\n*   TCB, AND CDE STRUCTURES.  THUS THIS MODULE WILL BE SENSITIVE      *\n*   TO RELEASE CHANGES IN THESE PRODUCTS.                             *\n*   NOTE: THIS MODULE IS INSTALLED VIA SMP/E LOCAL MOD.  THE LOAD     *\n*         MODULE IKJEFF10 NEEDS APF AUTHORIZATION, A LINKLIST         *\n*         LIBRARY, AND 'RENT,REUS' ATTRIBUTES.                        *\n*                                                                     *\n* LOG -                                                               *\n*     DATE   WHO LV    CHANGE                                         *\n*   01/14/86 PTW 01 IMPLEMENTATION                                    *\n*   03/31/86 PTW 02 REDO VERIFICATION OF ISPF EDIT. CHECKING FOR CDES *\n*                   ISRUDL OR ISREDIT DIDN'T CATCH \"ISPEXEC EDIT\".    *\n*                   CHECKING TLD PANELID ISREDDE DIDN'T CATCH IMACRO. *\n*                                                                     *\n***********************************************************************\n         LCLC  &CSECT\n&CSECT   SETC  'IKJEFF10'\n&CSECT   CSECT ,\n***********************************************************************\n*                                                                     *\n*        I N I T I A L I Z E   A N D   D E T E R M I N E              *\n*        T Y P E   O F   C A L L.                                     *\n*                                                                     *\n***********************************************************************\n         PRINT NOGEN                                                L02\n         SAVE  (14,12),,&CSECT-&SYSDATE-&SYSTIME\n         LR    R12,R15                 ESTABLISH BASE.\n         USING &CSECT,R12              TELL ASSEMBLER.\n         L     R11,0(,R1)              R11 = A(PLIST).\n         USING IEDSECTD,R11\n         L     R2,IEEXITWD             R2 = A(OUR SAVED WORKAREA).\n         LTR   R2,R2                   IF R2 \u00ac= 0,\n         BNZ   HAVSTOR                   WE ALREADY HAVE WORKAREA.\n         GETMAIN RU,LV=DYNLEN,SP=230  230 IS FREED AT TASK TERMINATION.\n         ST    R1,IEEXITWD             SAVE A(WORKAREA).\n         LR    R2,R1                   ZERO\n         LR    R0,R1                     DYNAMIC\n         LA    R1,DYNLEN                   STORAGE.\n         LR    R14,R0\n         SLR   R15,R15\n         MVCL  R0,R14                  DO IT.\nHAVSTOR  DS    0H\n         LR    R1,R13                  PREPARE TO\n         LR    R13,R2                    SAVEAREA CHAIN.\n         USING DYNAMIC,R13             TELL ASSEMBLER.\n         ST    R1,4(,R13)              BACK CHAIN.\n         ST    R13,8(,R1)              FORWARD CHAIN.\n         CLI   ENVTYPE,NOTINIT         IF FIRST ENTRY,\n         BE    ENVBEG                    WE NEED TO CALL\nTRYMSG   DS    0H\n         L     R2,IEMSGP               IF CALL TO FREE MSG AREA,\n         LTR   R2,R2                     DON'T NEED TO...\n         BNZ   RETCONT                     JUST RETURN.\n         L     R2,IECARDP              IF CALL TO INSERT A CARD,\n         LTR   R2,R2                     STORE THE PROPER\n         BNZ   JCLTYPE                     WORKAREA ADDRESS\n         LA    R2,INSLINE                    IN PARAMETER LIST\n         ST    R2,IECARDP                      AND RETURN.\n         B     RETCONT\nJCLTYPE  DS    0H\n         L     R10,IESUBCTP            ADDRESS THE FLAGS IN PLIST.\n         USING IESUBCTD,R10\n         TM    IESTMTYP,IETJOB         IF A JOBCARD,\n         BZ    RETCONT                   AND\n         TM    IESTMTYP,IESOPCON+IESSCON IF A CONTINUATION,\n         BNZ   RETCONT                   DON'T NEED...RETURN.\n         CLI   CERROR,NO               NO COMMENT ERROR,\n         BE    COMMENTS                  GO DO COMMENTS PROCESSING.\nRETCONT  DS    0H                      RETURN TO CONTINUE.\n         LA    R15,IECONTIN\n         MVI   IETAKEEX,IETJOB\n         B     RETURN\nRETMSG   DS    0H\n         LA    R15,IEMSG               RETURN TO OUTPUT MESSAGE.\n         MVI   IETAKEEX,IETJOB\n         B     RETURN\nRETRET   DS    0H\n         LA    R15,IERETURN            RETURN TO INSERT COMMENT.\n         MVI   IETAKEEX,IETJOB\n         B     RETURN\nRETURN   DS    0H\n         LR    R1,R13              PREPARE\n         L     R13,4(,R13)         FOR FREEMAIN.\n*        FREEMAIN RU,LV=DYNLEN,A=(1),SP=230  SUBMIT NEEDS A(BUFFER)!\n         RETURN (14,12),RC=(15)      WITH R15 = RC.\n***********************************************************************\n*                                                                     *\n*        D E T E R M I N E   E N V I R O N M E N T.                   *\n*                                                                     *\n***********************************************************************\nENVBEG   DS    0H\n*\n*  THIS ROUTINE DETERMINES WHAT ENVIRONMENT WE ARE RUNNING IN:\n*  REGULAR SUBMIT, TSO EDIT, ISPF, OR ISPF EDIT.\n*\n         MVI   CERROR,NO               ASSUME NO ERROR.\n         MVI   ENVTYPE,SUBMIT          ASSUME IT'S REGULAR SUBMIT.\n         MVI   INSLINE,C' '            BLANK BUFFER.\n         MVC   INSLINE+1(L'INSLINE-1),INSLINE\n*\n*  HERE WE FIND SUBMIT'S TCB. THIS EXIT RUNS UNDER A DIFFERENT\n*  CHAIN THAN SUBMIT, AND WE CAN'T PREDICT WHERE SUBMIT'S TCB WILL BE.\n*  THUS WE RUN THE DISPATCHING CHAIN LOOKING FOR AN SVC 100 SVRB.\n*\n         L     R2,PSATOLD-P            R2 = A(OUR TCB).\n         L     R2,TCBJSTCB-T(,R2)      R2 = A(JOB-STEP TCB).\nENVTCBL1 DS    0H\n         L     R3,TCBRBP-T(,R2)        R3 = A(MOST RECENT RB).\nENVRBL1  DS    0H\n         TM    RBSTAB1-R(R3),RBFTSVRB  IF NOT AN SVRB,\n         BNO   ENVTCBE1                  FORGET THIS ONE.\n         L     R4,RBLINK-R(,R3)        VERIFY ITS SVC 100.\n         SL    R4,=A(RBPRFXND-RBPREFIX)\n         CLI   RBINTCOD-RP+1(R4),100               LOOK FOR SVC 100.\n         BE    ENVOKSUB\nENVTCBE1 DS    0H\n         L     R2,TCBTCB-T(,R2)        DIG INTO TCB DISP. CHAIN.\n         LTR   R2,R2                   IF END OF LINE,\n         BNZ   ENVTCBL1\n         B     BADSUB1                   PUT OUT ERROR MESSAGE.\nENVOKSUB DS    0H\n         ST    R2,SUBTCB               SAVE SUBMIT'S TCB.\n*\n*  HERE WE RUN SAVE AREAS TO FIND THE CPPL SENT TO SUBMIT.\n*\n         L     R4,RBGRS13-R(,R3)       FIND CPPL SENT TO SUBMIT.\n         L     R4,SAVHSA(,R4)\n         L     R5,SAVR15(,R4)         CHECK FOR PRESENCE OF IKJEFF01.\n         CLC   =CL8'IKJEFF01',5(R5)\n         BNE   BADSUB2\n         L     R4,SAVR1(,R4)\n         L     R5,CPPLUPT-CPPL(,R4)\n         ST    R5,UPTPTR               SAVE A(UPT).\n         TM    UPTSWS-UPT(R5),UPTWTP   IF NO WTP MESSAGES,\n         BNO   BADWTP                    THEN NO COMMENTS!\n         MVC   PSCBPTR,CPPLPSCB-CPPL(R4) SAVE A(PSCB).\n*\n*  NEXT WE LOOK FOR THE DAPB FOR THE CURRENT DSN AND THE SUBMIT\n*  TABLE.  WE RUN SAVE AREAS ANCHORED IN THIS EXIT'S TCB TO DO THIS.\n*\n         L     R2,PSATOLD-P            R2 = A(OUR TCB).\n         L     R3,TCBFSA-T(,R2)        DIG THROUGH SAVE AREAS\n         L     R3,SAVLSA(,R3)\n         L     R3,SAVLSA(,R3)\n         L     R3,SAVLSA(,R3)\n         ST    R3,SUBSAREA             WILL BE USED LATER TO GET DSN.\n         L     R4,SAVR6(,R3)\n         CLC   =C'SUBMIT TABLE',0(R4)  CHECK EYE-CATCHER TO BE SURE.\n         BNE   BADSUB3                 AARGH! WE HAVE A PROBLEM HERE.\n*\n*  HERE WE CHECK SPECIFICALLY FOR TSO EDIT, ISPF, OR ISPF EDIT.\n*  FOR TSO EDIT, THE MOTHER TASK'S 2ND RB MUST BE RUNNING IKJEBESU,\n*  AND THE PREVIOUS RB MUST BE RUNNING IKJEBEMA.  FOR ISPF, ANY MOTHER\n*  TASK'S 1ST RB MUST BE RUNNING ISPTASK.  FOR ISPF EDIT, WE MUST BE\n*  ISPF. RUN TH SAVEAREAS ARE DETERMINE THAT ISPCSB AND ISREPSB ARE\n*  BEING USED.  THUS WE AREN'T FOOLED BY TSO COMMANDS, ETC.\n*\n         L     R2,SUBTCB               GET SUBMIT'S TCB.\n         L     R2,TCBOTC-T(,R2)        R2 = A(MOTHER TCB).\n         L     R3,TCBRBP-T(,R2)        R3 = A(LAST RB).\n         TM    RBSTAB2-R(R3),RBTCBNXT  LOOK FOR 2ND RB.\n         BO    ENVENDED\n         L     R3,RBLINK-R(,R3)\n         TM    RBSTAB2-R(R3),RBTCBNXT  LOOK FOR 3RD RB.\n         BO    ENVENDED\n         L     R4,RBCDE-R(,R3)         R4 = A(1ST CDE).\n         CLC   =CL8'IKJEBESU',CDNAME-C(R4)  LOOK FOR TSO EDIT.\n         BNE   ENVENDED\n         L     R3,RBLINK-R(,R3)\n         L     R4,RBCDE-R(,R3)         R5 = A(1ST CDE).\n         CLC   =CL8'IKJEBEMA',CDNAME-C(R4)\n         BNE   ENVENDED\n         MVI   ENVTYPE,EDIT            WE GOT EDIT.\n*        TPUT  =C'ENV: EDIT',9\n         MVC   EWAPTR,TCBGRS9-T(R2)    SAVE THE WORK AREA POINTER.\n         B     ENVEND\nENVENDED DS    0H\n*\n* NOW DO ISPF AND ISPF EDIT.\n*\n         L     R2,SUBTCB               GET SUBMIT'S TCB.\n         L     R2,TCBOTC-T(,R2)        R2 = A(MOTHER TCB).\nENVTCBL2 DS    0H\n         L     R3,TCBRBP-T(,R2)        R3 = A(LAST RB).\nENVRBL2  DS    0H\n         TM    RBSTAB2-R(R3),RBTCBNXT  LOOK FOR 1ST RB.\n         BO    ENVRBE2\n         L     R3,RBLINK-R(,R3)\n         B     ENVRBL2\nENVRBE2  DS    0H\n         L     R4,RBCDE-R(,R3)         R5 = A(1ST CDE).\n         CLC   =CL8'ISPTASK',CDNAME-C(R4)  LOOK FOR ISPF.\n         BNE   ENVTCBE2\n         MVI   ENVTYPE,ISPF            WE'RE IN ISPF.\n*        TPUT  =C'ENV: ISPF',9\n         BE    ENVISPFE\n         B     ENVENDIS\nENVTCBE2 DS    0H\n         CL    R2,TCBJSTCB-T(,R2)      WE WANT TO STOP AT THE\n         BE    ENVENDIS                  JOB-STEP TCB.\n         L     R2,TCBOTC-T(,R2)        GET PREVIOUS MOTHER.\n         B     ENVTCBL2                LOOP.\nENVISPFE DS    0H                      WE'VE PASSED THE CDE TEST.\n         L     R3,TCBGRS13-T(,R2)      NOW VERIFY THE SAVEAREA CHAIN.\n         L     R3,SAVHSA(,R3)          DIG BACK 2 LEVELS.\n         L     R3,SAVHSA(,R3)\n         L     R4,SAVR15(,R3)          CHECK FOR PRESENCE OF ISPCSB.\n         BAS   R14,TO31\n         CLC   =C'ISPCSB ',5(R4)\n         BNE   ENVIFROM\n         L     R4,SAVHSA(,R3)          DIG BACK ANOTHER LEVEL.      L02\n         L     R4,SAVR15(,R4)          CHECK FOR PRESENCE OF ISPEPSBL02\n         CLC   =C'ISREPSB ',5(R4)                                   L02\n         BNE   ENVIFROM                                             L02\n         BAS   R14,FROM31\n         MVI   ENVTYPE,ISPFEDIT        WE'RE ISPF EDIT!\n*        TPUT  =C'ENV: ISPFEDIT',13\n         MVC   EDTPTR,SAVR3(R3)        NEED THIS FOR LATER.\n         B     ENVEND\nENVIFROM DS    0H\n         BAS   R14,FROM31\nENVENDIS DS    0H\nENVEND   DS    0H\n         B     TRYMSG                  GO BACK FROM WHENCE.\n***********************************************************************\n*                                                                     *\n*        D E T E R M I N E   D S N T Y P E.                           *\n*                                                                     *\n***********************************************************************\nCOMMENTS DS    0H\n*\n*  THIS ROUTINE DETERMINES WHAT TYPE OF DSN SUBMIT IS HANDLING:\n*    PERMANENT        - YOUR.EVERYDAY.DSN\n*    TEMPORARY        - SYS99999.D99999.T99999999.USERID.R9999999\n*    ISPF UTILITY     - PREFIX(.USERID).SPFTEMP9.CNTL\n*    TSO EDIT UTILITY - PREFIX.SUB(MIT).D99999.T9999999.CNTL\n*    NONE             - DETERMINED BY ZERO BUFFER POINTER\n*\nDSNBEG   DS    0H\n         MVI   INSLINE,C' '            BLANK BUFFER.\n         MVC   INSLINE+1(L'INSLINE-1),INSLINE\n         MVI   DSNTYPE,PERM            ASSUME PERMANENT.\n         L     R2,SUBSAREA             R2 = A(SAVED BUFFER).\n         L     R3,SAVR6(,R2)           IF ZERO BUFFER\n         L     R3,SUBUFPTR(,R3)          POINTER,\n         LTR   R3,R3\n         BNZ   DSNENONE\n         MVI   DSNTYPE,NONE            INDICATE THUSLY.\n*        TPUT  =C'DSN: NONE',9\n         B     DSNEND\nDSNENONE DS    0H\n         L     R2,SUBSAREA             R2 = A(SAVED BUFFER).\n         L     R2,SAVR7(,R2)           TEST FOR TEMPORARY FORMAT.\n         L     R2,0(,R2)               R2 = A(DAPB).\n         L     R3,DA08PDSN-DAPB08(,R2) POINT TO DSN TEXT.\n         LH    R4,0(,R3)               R4 = L'DSN.\n         LA    R3,2(,R3)               R3 = A(DSN).\n         CH    R4,=H'33'               MIN LENGTH - A 1 BYTE JOBNAME.\n         BL    DSNENTMP\n         CLI   0(R3),C' '              IF BLANK NAME,\n         BE    BADSDSN                   FORGET NEXT.\n         CLI   DA08MNM-DAPB08(R2),C' ' IF MEMBER PRESENT, WE'RE\n         BNE   DSNENTMP                  NOT INTERESTED.\n         CLC   =C'SYS',0(R3)           DO TEXT CHECKS.\n         BNE   DSNENTMP\n         CLC   =C'.T',8(R3)\n         BNE   DSNENTMP\n         CLC   =C'.RA',16(R3)\n         BNE   DSNENTMP\n         CLI   22(R3),C'.'\n         BNE   DSNENTMP\n         L     R5,PSCBPTR              COMPARE USERID WITH USERID\n         SLR   R6,R6                     IN DSN.\n         IC    R6,PSCBUSRL-PSCB(,R5)\n         LTR   R6,R6\n         BZ    DSNENTMP\n         BCTR  R6,0\n         EX    R6,CLCUSER\n         BNE   DSNENTMP\n         MVI   DSNTYPE,TEMP            WE'RE A TEMPORARY! (PHEW)\n*        TPUT  =C'DSN: TEMP',9\n         B     DSNEND\nCLCUSER  CLC   23(*-*,R3),PSCBUSER-PSCB(R5)\nDSNENTMP DS    0H                      CHECK FOR ISPF UTILITY.\n         L     R5,UPTPTR               COMPARE PREFIX WITH DSN.\n         SLR   R6,R6\n         IC    R6,UPTPREFL-UPT(,R5)\n         LTR   R6,R6\n         BZ    DSNENIUT\n         BCTR  R6,0\n         EX    R6,CLCUPT\n         BNE   DSNENIUT\n         CH    R4,=H'14'               MIN LENGTH IS 14 W 1 BYTE PREFIX\n         BL    DSNENIUT\n         LA    R5,0(R4,R3)\n         SH    R5,=H'14'\n         CLC   =C'.SPFTEMP',0(R5)      DO BASIC TEXT CHECKS.\n         BNE   DSNENIUT\n         CLC   =C'.CNTL',9(R5)\n         BNE   DSNENIUT\n         MVI   DSNTYPE,ISPFUTIL        WE'RE AN ISPF UTILITY!\n*        TPUT  =C'DSN: ISPFUTIL',13\n         B     DSNEND\nCLCUPT   CLC   0(*-*,R3),UPTPREFX-UPT(R5)\nDSNENIUT DS    0H                      NOW TRY TSO EDIT UTILITY.\n         CH    R4,=H'24'               AGAIN CHECK MIN LENGTH.\n         BL    DSNENDED\n         L     R5,UPTPTR               IF PREFIX IS AVAILABLE,\n         SLR   R6,R6                     CHECK DSN.\n         IC    R6,UPTPREFL-UPT(,R5)\n         LA    R5,0(R6,R3)\n         LTR   R6,R6\n         BZ    *+8\n         LA    R5,1(,R5)               BUMP PAST '.'.\n         CLC   =C'SUB.D',0(R5)         DO BASIC TEXT CHECKS.\n         BE    DSNTRYED\n         CLC   =C'SUBMIT.D',0(R5)\n         BNE   DSNENDED\nDSNTRYED DS    0H\n         LA    R5,0(R4,R3)\n         SH    R5,=H'14'\n         CLC   =C'.T',0(R5)\n         BNE   DSNENDED\n         CLC   =C'.CNTL',9(R5)\n         BNE   DSNENDED\n         MVI   DSNTYPE,EDITUTIL        WE'RE A TSO EDIT UTILTIY DSN!\n*        TPUT  =C'DSN: EDITUTIL',13\nDSNENDED DS    0H\nDSNEND   DS    0H\n***********************************************************************\n*                                                                     *\n*        D E T E R M I N E   M S G T Y P E.                           *\n*                                                                     *\n***********************************************************************\nMSGBEG   DS    0H\n*\n* HERE WE DETERMINE THE TYPE OF COMMENT TO OUTPUT BASED ON THE\n* ENVIRONMENT AND THE DSN:\n*   -DSN-      -ENV-      -MSG-          -ACTION-\n*  NONE          .       PROMPT   FIXED TEXT.\n*  EDITUTIL   EDIT       EDITNAME MUST DIG OUT REAL DSN IN TSO EDIT\n*  ISPFUTIL   ISPFEDIT   ISPENAME MUST DIG OUT REAL DSN IN ISPFEDIT\n*  TEMP       ISPFEDIT   ISPENAME              \"\"\n*  ISPFUTIL   ISPF       ISPUNAME FIXED TEXT\n*  TEMP       ISPF       ISPUNAME FIXED TEXT\n*  ALL OTHER     .       SUBNAME  USE DSN ON COMMAND LINE\n*\n         MVI   MSGTYPE,SUBNAME         ASSUME SUBMIT DSN.\n         CLI   DSNTYPE,NONE            CHECK FOR PROMPT MSG.\n         BNE   MSGENDPR\n         MVI   MSGTYPE,PROMPT\n*        TPUT  =C'MSG: PROMPT',11\n         B     MSGEND\nMSGENDPR DS    0H                      CHECK FOR TSO EDIT.\n         CLI   DSNTYPE,EDITUTIL        ONLY EDIT UTILITY NAME.\n         BNE   MSGENDED\n         CLI   ENVTYPE,EDIT            MUST BE EDIT ENVIRONMENT.\n         BNE   MSGEND\n         MVI   MSGTYPE,EDITNAME        WE GOT TSO EDIT.\n*        TPUT  =C'MSG: EDITNAME',13\n         B     MSGEND\nMSGENDED DS    0H                      CHECK FOR ISPF.\n         CLI   DSNTYPE,ISPFUTIL        IF A ISPF UTILITY\n         BE    MSGTRYIE\n         CLI   DSNTYPE,TEMP              OR A TEMP, OK.\n         BNE   MSGEND\nMSGTRYIE DS    0H\n         CLI   ENVTYPE,ISPFEDIT        IF ISPF EDIT ENV.,\n         BNE   MSGTRYIU\n         MVI   MSGTYPE,ISPENAME        THAT'S COOL.\n*        TPUT  =C'MSG: ISPENAME',13\n         B     MSGEND\nMSGTRYIU DS    0H\n         CLI   ENVTYPE,ISPF            ELSE, TRY DIALOGS, ETC.\n         BNE   MSGENDIS\n         MVI   MSGTYPE,ISPUNAME\n*        TPUT  =C'MSG: ISPUNAME',13\n         B     MSGEND\nMSGENDIS DS    0H\nMSGEND   DS    0H\n***********************************************************************\n*                                                                     *\n*        F O R M A T   C O M M E N T S.                               *\n*                                                                     *\n***********************************************************************\nPUTBEG   DS    0H\n*\n* HERE WE BUILD THE COMMENT, BASED ON MSGTYPE.\n*\n         MVI   INSLINE,C' '            BLANK BUFFER.\n         MVC   INSLINE+1(L'INSLINE-1),INSLINE\n         CLI   MSGTYPE,SUBNAME         CHECK FOR SUBMIT DSNAME.\n         BNE   PUTENDSU\n         MVC   INSLINE(L'JCL),JCL\n         LA    R2,INSLINE+L'JCL\n         L     R3,SUBSAREA             R2 = A(SAVED BUFFER).\n         L     R3,SAVR7(,R3)           DIG FOR DSNAME.\n         L     R3,0(,R3)\n         L     R4,DA08PDSN-DAPB08(,R3)\n         LH    R5,0(,R4)               R5 = L'DSN.\n         LA    R4,2(,R4)               R4 = A(DSN).\n         BCTR  R5,0\n         EX    R5,MVCDSN               MOVE IT TO BUFFER.\n         LA    R2,1(R5,R2)\n         LA    R4,DA08MNM-DAPB08(,R3)  R4 = A(MEMBER).\n         CLI   0(R4),C' '              CHECK FOR PRESENCE OF MEMBER.\n         BE    PUTEND\n         MVI   0(R2),C'('\n         LA    R5,L'DA08MNM(,R4)       FIND LENGTH OF MEMBER.\n         BCTR  R5,0\n         CLI   0(R5),C' '\n         BE    *-6\n         SLR   R5,R4\n         EX    R5,MVCMEM               MOVE MEMBER.\n         LA    R2,2(R5,R2)\n         MVI   0(R2),C')'\n         B     PUTEND                  THAT'S IT.\nPUTENDSU DS    0H\n         CLI   MSGTYPE,ISPENAME        CHECK FOR ISPF EDIT DSN.\n         BNE   PUTENDIE\n         L     R3,EDTPTR               R3 = A(EDT).\n         LA    R4,ISPFEDSN(,R3)        R4 = A(DSN).\n         CLI   0(R4),C' '              IF BLANK, FORGET IT.\n         BE    BADIDSN\n         MVC   INSLINE(L'JCLISPED),JCLISPED\n         LA    R2,INSLINE+L'JCLISPED\n         LA    R5,L'ISPFEDSN(,R4)      FIND L'DSN.\n         BCTR  R5,0\n         CLI   0(R5),C' '\n         BE    *-6\n         SLR   R5,R4\n         EX    R5,MVCDSN               MOVE DSN.\n         LA    R2,1(R5,R2)\n         LA    R4,ISPFEMEM(,R3)        R4 = A(MEMBER).\n         CLI   0(R4),C' '              IF BLANK, FORGET IT.\n         BE    PUTEND\n         MVI   0(R2),C'('\n         LA    R5,L'ISPFEMEM(,R4)      FIND L'MEMBER.\n         BCTR  R5,0\n         CLI   0(R5),C' '\n         BE    *-6\n         SLR   R5,R4\n         EX    R5,MVCMEM               MOVE MEMBER.\n         LA    R2,2(R5,R2)\n         MVI   0(R2),C')'\n         B     PUTEND                  THAT'S IT.\nPUTENDIE DS    0H\n         CLI   MSGTYPE,EDITNAME        CHECK FOR TSO EDIT DSNAME.\n         BNE   PUTENDED\n         L     R3,EWAPTR               R3 = A(EWA).\n         LA    R4,EDITDSN(,R3)         R4 = A(DSN).\n         CLI   0(R4),C' '              IF BLANK, FORGET IT.\n         BE    BADEDSN\n         MVC   INSLINE(L'JCLEDIT),JCLEDIT\n         LA    R2,INSLINE+L'JCLEDIT\n         LH    R5,EDITDSNL(,R3)        R5 = L'DSN.\n         BCTR  R5,0\n         EX    R5,MVCDSN               MOVE DSN.\n         LA    R2,1(R5,R2)\n         LA    R4,EDITMEM(,R3)         R4 = A(MEMBER).\n         CLI   0(R4),C' '              IF BLANK, FORGET NEXT.\n         BE    PUTEND\n         MVI   0(R2),C'('\n         LA    R5,L'EDITMEM(,R4)       FIND L'MEMBER.\n         BCTR  R5,0\n         CLI   0(R5),C' '\n         BE    *-6\n         SLR   R5,R4\n         EX    R5,MVCMEM               MOVE MEMBER.\n         LA    R2,2(R5,R2)\n         MVI   0(R2),C')'\n         B     PUTEND                  THAT'S IT.\nPUTENDED DS    0H\n         CLI   MSGTYPE,ISPFUTIL        CHECK FOR ISPF UTILTIY.\n         BNE   PUTENDIU\n         MVC   INSLINE(L'JCLISPUT),JCLISPUT\n         B     PUTEND\nPUTENDIU DS    0H\n         CLI   MSGTYPE,PROMPT          CHECK FOR * IN READY.\n         BNE   PUTENDPR\n         MVC   INSLINE(L'JCLPROMP),JCLPROMP\n         B     PUTEND\nPUTENDPR DS    0H\nPUTEND   DS    0H\n*        TPUT  INSLINE,80\n         B     RETRET                  TELL SUBMIT TO RETURN TO INSERT.\n***********************************************************************\n*                                                                     *\n*        E R R O R   H A N D L I N G.                                 *\n*                                                                     *\n***********************************************************************\nBADSUB1  DS    0H                      CONTROL BLOCK MESSUP.\n         MVI   CERROR,YES\n         MVC   INSLINE(2),=AL2(L'BADSUB1M+2)\n         MVC   INSLINE+2(L'BADSUB1M),BADSUB1M\n         B     BADRET\nBADSUB1M DC    C'NO DSN COMMENT - CAN''T FIND SUBMIT TCB.'\nBADSUB2  DS    0H                      CONTROL BLOCK MESSUP.\n         MVI   CERROR,YES\n         MVC   INSLINE(2),=AL2(L'BADSUB2M+2)\n         MVC   INSLINE+2(L'BADSUB2M),BADSUB2M\n         B     BADRET\nBADSUB2M DC    C'NO DSN COMMENT - SUBMIT SAVE AREA CHAIN ERROR.'\nBADSUB3  DS    0H                      SUBMIT CONTROL BLOCK MESSUP.\n         MVI   CERROR,YES\n         MVC   INSLINE(2),=AL2(L'BADSUB3M+2)\n         MVC   INSLINE+2(L'BADSUB3M),BADSUB3M\n         B     BADRET\nBADSUB3M DC    C'NO DSN COMMENT - CAN''T FIND SUBMIT TABLE.'\nBADWTP   DS    0H                      NOWTP - NO COMMENT WANTED.\n         MVI   CERROR,YES\n         B     RETCONT\nBADSDSN  DS    0H                      BLANK SUBMIT DSN.\n         MVI   CERROR,YES\n         MVC   INSLINE(2),=AL2(L'BADSDSNM+2)\n         MVC   INSLINE+2(L'BADSDSNM),BADSDSNM\n         B     BADRET\nBADSDSNM DC    C'NO DSN COMMENT - INTERNAL SUBMIT DSN IS BLANK.'\nBADIDSN  DS    0H                      BLANK ISPF EDIT DSN.\n         MVC   INSLINE(2),=AL2(L'BADIDSNM+2)\n         MVC   INSLINE+2(L'BADIDSNM),BADIDSNM\n         B     BADRET\nBADIDSNM DC    C'NO DSN COMMENT - INTERNAL ISPF EDIT DSN IS BLANK.'\nBADEDSN  DS    0H                      BLANK TSO EDIT DSN.\n         MVC   INSLINE(2),=AL2(L'BADEDSNM+2)\n         MVC   INSLINE+2(L'BADEDSNM),BADEDSNM\n         B     BADRET\nBADEDSNM DC    C'NO DSN COMMENT - INTERNAL TSO EDIT DSN IS BLANK.'\nBADRET   DS    0H                      SAVE A(ERROR MSG).\n         LA    R2,INSLINE\n         ST    R2,IEMSGP\n         B     RETMSG\n         DROP  R10,R11\n***********************************************************************\n*                                                                     *\n*        T O   A N D   F R O M   3 1   B I T   M O D E.               *\n*                                                                     *\n***********************************************************************\nTO31     DS    0H\n         L     R1,LABEL1\n         BSM   0,R1\nLABEL1   DC    A(LABEL2+X'80000000')\nLABEL2   DS    0H\n         BR    R14\nFROM31   DS    0H\n         LA    R1,LABEL3\n         BSM   0,R1\nLABEL3   DS    0H\n         BR    R14\n***********************************************************************\n*                                                                     *\n*        S T A T I C   A R E A S.                                     *\n*                                                                     *\n***********************************************************************\nMVCDSN   MVC   0(*-*,R2),0(R4)\nMVCMEM   MVC   1(*-*,R2),0(R4)\nJCL      DC    C'//*JCL: '\nJCLISPED DC    C'//*ISPF EDIT OF '\nJCLISPUT DC    C'//*JCL: ISPF UTILITY DATASET'\nJCLEDIT  DC    C'//*TSO EDIT OF '\nJCLPROMP DC    C'//*JCL: INPUT FROM THE TERMINAL'\n         LTORG *\n***********************************************************************\n*                                                                     *\n*        D Y N A M I C   A R E A S.                                   *\n*                                                                     *\n***********************************************************************\nDYNAMIC  DSECT\nSAVE     DS    18F .                   SAVEAREA.\nINSLINE  DS    CL80                    BUFFER.\nSUBTCB   DS    A                       A(SUB TCB).\nUPTPTR   DS    A                       A(UPT).\nPSCBPTR  DS    A                       A(PSCB).\nSUBSAREA DS    A                       A(SUB TABLE).\nEDTPTR   DS    A                       A(ISPF EDIT EDT).\nEWAPTR   DS    A                       A(TSO EDIT EWA).\nCERROR   DS    X                       HAS THERE BEEN A SERIOUS ERROR?\nNO       EQU   1\nYES      EQU   2\nENVTYPE  DS    X                       ENVIRONMENT.\nNOTINIT  EQU   0                       NOT SET.\nSUBMIT   EQU   1\nISPF     EQU   2\nISPFEDIT EQU   3\nEDIT     EQU   4\nDSNTYPE  DS    X                       DSN TYPE.\nPERM     EQU   1\nTEMP     EQU   2\nISPFUTIL EQU   3\nEDITUTIL EQU   4\nNONE     EQU   5\nMSGTYPE  DS    X                       MSG TYPE.\nSUBNAME  EQU   1\nISPENAME EQU   2\nISPUNAME EQU   3\nEDITNAME EQU   4\nPROMPT   EQU   5\nDYNLEN   EQU   *-DYNAMIC\n*\nSAVHSA   EQU   X'04',4,C'A'       SAVE AREA HSA.\nSAVLSA   EQU   X'08',4,C'A'       SAVE AREA LSA.\nSAVR1    EQU   X'18',4,C'A'       PARM PTR IN SAVE AREA.\nSAVR3    EQU   X'20',4,C'A'       EDT POINTER IN SAVE AREA.\nSAVR6    EQU   X'2C',4,C'A'       SUBTAB POINTER IN SAVE AREA.\nSAVR7    EQU   X'30',4,C'A'       CURRENT DAPB POINTER.\nSAVR9    EQU   X'54',4,C'A'       EDIT TABLE POINTER IN SAVE AREA.\nSAVR15   EQU   X'10',4,C'A'       MODULE EP IN SAVE AREA.\nSUBUFPTR EQU   X'38',4,C'A'       DAIR PARAMETER BLOCK POINTER.\nISPFEDSN EQU   X'A80',44,C'C'     ISPF EDIT DSNAME.\nISPFEMEM EQU   X'AAC',8,C'C'      ISPF EDIT MEMBER.\nEDITDSNL EQU   X'EE',2,C'H'       TSO EDIT DSNAME LENGTH.\nEDITDSN  EQU   X'F0',44,C'C'      TSO EDIT DSNAME.\nEDITMEM  EQU   X'11C',8,C'C'      TSO EDIT MEMBER.\nR0       EQU   00\nR1       EQU   01\nR2       EQU   02\nR3       EQU   03\nR4       EQU   04\nR5       EQU   05\nR6       EQU   06\nR7       EQU   07\nR8       EQU   08\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11                 A(PLIST).\nR12      EQU   12                 PROGRAM BASE.\nR13      EQU   13                 A(SAVE AREA).\nR14      EQU   14\nR15      EQU   15\n         IHAPSA\nP        EQU   PSA\n         IKJTCB\nT        EQU   TCB\n         IKJRB\nRP       EQU   RBPREFIX\nR        EQU   RBSECT\nFLGPRB   EQU   X'E0'                 ITS A PRB.\n         IHACDE\nC        EQU   CDENTRY\n         IKJEFFIE IETYPE=SUBMIT\n         IKJCPPL\n         IKJPSCB\n         IKJUPT\n         IKJDAP08\n         END   &CSECT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IKJEFF53": {"ttr": 4616, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x02\\xd8\\x02\\xd8\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 728, "newlines": 728, "modlines": 0, "user": "FILE369"}, "text": "         TITLE 'MVS CUSTOM-BUILT IPO SUPPLIED FIB INSTALLATION EXIT'\n*/*\n*/* LIB: IPO1.SAMPLIB(IKJEFF53)\n*/* GDE: CBIPO MVS CUSTOMIZATION\n*/* DOC: THIS IS THE ASSEMBLER SOURCE CODE FOR THE\n*/*      SAMPLE MVS CUSTOM-BUILT IPO TSO OUTPUT, STATUS AND\n*/*      CANCEL EXIT ROUTINE.\n*/*\n*             MODULE NAME = IKJEFF53                                  *\n*                                                                     *\n*             DESCRIPTIVE NAME =  MVS CUSTOM-BUILT IPO                *\n*                SUPPLIED FIB EXIT FOR TSO                            *\n*                CANCEL, OUTPUT AND STATUS COMMANDS                   *\n*                                                                     *\n*             FUNCTION =                                              *\n*                VALIDITY CHECKS JOBNAME ON A CANCEL, OUTPUT OR       *\n*                STATUS FIB (FOREGROUND INITIATED BACKGROUND)         *\n*                COMMAND.  ALLOWS FOR STATUS WITH JOBNAME 'TSO'       *\n*                                                                     *\n*                OPERATION =                                          *\n*                   STATUS:  IF JOBNAME IS NOT 'TSO' RETURN TO        *\n*                   CALLER SINCE ANY JOBNAME WILL BE ALLOWED.         *\n*                   IF JOBNAME IS 'TSO' PUT OUT LIST OF USERIDS       *\n*                   WITH ADDRESS SPACE ID AND TERMINAL ADDRESS        *\n*                   OR SYMBOLIC TERMINAL NAME (TSO/VTAM).             *\n*                   RETURN TO CALLER WITH RETURN CODE OF 12 TO        *\n*                   SKIP JOBNAME SEARCH FOR 'TSO'.                    *\n*                                                                     *\n*                   OUTPUT:  FIRST CHECK IF THE USER HAS OPERATOR     *\n*                   AUTHORITY.  IF YES, ALLOW THE USER TO OUTPUT      *\n*                   ANY JOBNAME.  IF THE USER DOES NOT HAVE OPERATOR  *\n*                   AUTHORITY COMPARE THE USERID WITH THE JOBNAME     *\n*                   PASSED.  IF THE JOBNAME IS NOT THE USERID OR      *\n*                   DOES NOT START WITH THE USERID, THE JOBNAME       *\n*                   IS REJECTED BY FIRST RETURNING TO THE CALLER      *\n*                   AN ERROR MESSAGE AND A RETURN CODE REQUESTING     *\n*                   THAT THE MESSAGE BE ISSUED VIA THE PUTLINE        *\n*                   MECHANISM.  WHEN REENTERED FOR THE JOBNAME,       *\n*                   THE EXIT ISSUES A RETURN CODE REJECTING THE       *\n*                   JOBNAME.                                          *\n*                                                                     *\n*                   CANCEL:  FIRST CHECK IF THE USER HAS OPERATOR     *\n*                   AUTHORITY.  IF YES, ALLOW THE USER TO CANCEL      *\n*                   ANY JOBNAME (THE MVS SYSTEM WILL PREVENT THE      *\n*                   USER FROM CANCELLING STARTED TASKS AND TSO        *\n*                   SESSIONS).  IF THE USER DOES NOT HAVE OPERATOR    *\n*                   AUTHORITY COMPARE THE USERID WITH THE JOBNAME     *\n*                   PASSED.  IF THE JOBNAME IS NOT THE USERID PLUS    *\n*                   AT LEAST ONE CHARACTER, THE JOBNAME IS REJECTED   *\n*                   BY FIRST RETURNING TO THE CALLER AN ERROR         *\n*                   MESSAGE AND A RETURN CODE REQUESTING THAT THE     *\n*                   THAT THE MESSAGE BE ISSUED VIA THE PUTLINE        *\n*                   MECHANISM.  WHEN REENTERED FOR THE JOBNAME,       *\n*                   THE EXIT ISSUES A RETURN CODE REJECTING THE       *\n*                   JOBNAME.                                          *\n*                                                                     *\n*              NOTES =                                                *\n*                                                                     *\n*                 DEPENDENCIES = CHARACTER IS EBCDIC.  REASSEMBLE     *\n*                    IF A DIFFERENT CHARACTER SET IS NEEDED.          *\n*                                                                     *\n*                 RESTRICTIONS = USES SPKA FORM OF MODESET MACRO      *\n*                    INSTRUCTION SO MUST RUN SUPERVISOR STATE.        *\n*                                                                     *\n*                 REGISTER CONVENTIONS = STANDARD CONVENTIONS.        *\n*                    REGISTERS 0,1     = WORK REGISTERS               *\n*                    REGISTER  2       = MODESET KEYADDR              *\n*                    REGISTER  3       = WORK REGISTER                *\n*                    REGISTERS 4       = ADDRESSABILITY TO EXIT       *\n*                                              PARAMETER LIST         *\n*                    REGISTER  5       = RETURN CODE / ASVT MAXUSERS  *\n*                    REGISTERS 6,7,8,9 = WORK REGISTERS               *\n*                    REGISTER  10      = ADDRESSABILITY TO REJECT     *\n*                                              MESSAGE GETMAINED AREA *\n*                    REGISTER  11      = ADDRESSABILITY TO GETMAINED  *\n*                                              DATA AREA              *\n*                    REGISTER  12      = ADDRESSABILITY TO IKJEFF53   *\n*                                              CSECT                  *\n*                    REGISTER  13      = SAVE AREA REGISTER           *\n*                    REGISTERS 14,15   = WORK REGISTERS               *\n*                                                                     *\n*                PATCH LABEL = PATCH (UNUSED AND INTIALIZED TO        *\n*                   'ZAP*'S)                                          *\n*                                                                     *\n*             MODULE TYPE = PROCEDURE                                 *\n*                                                                     *\n*                PROCESSOR = ASM                                      *\n*                                                                     *\n*                MODULE SIZE = 1K                                     *\n*                                                                     *\n*                ATTRIBUTES = PROTECT KEY 1, REENTRANT,               *\n*                   SUPERVISOR STATE                                  *\n*                                                                     *\n*             ENTRY POINTS = IKJEFF53 (ONLY ENTRY POINT)              *\n*                                                                     *\n*                LINKAGE =                                            *\n*                   IKJEFF51:  (CANCEL OR STATUS COMMAND) VIA CALL    *\n*                   IKJCT469:  (OUTPUT COMMAND) VIA CALL              *\n*                                                                     *\n*             INPUT = REGISTER 1 POINTS TO PARAMETER LIST MAPPED      *\n*                BY IKJEFFIE MACRO                                    *\n*                                                                     *\n*             OUTPUT = SEE EXIT TOPICAL HEADING BELOW                 *\n*                                                                     *\n*             EXIT - NORMAL = AT PROGRAM END VIA BRANCH REGISTER 14   *\n*                                                                     *\n*                OUTPUT = NONE                                        *\n*                                                                     *\n*                RETURN CODE = ZERO                                   *\n*                                                                     *\n*             EXIT - ERROR = AT PROGRAM END VIA BRANCH REGISTER 14    *\n*                                                                     *\n*                OUTPUT = MESSAGEP SET IN THE INPUT PARAMETER LIST.   *\n*                   IF RETURN IS FROM STATUS FOR JOBNAME 'TSO' THEN   *\n*                   RETURN CODE IS 12 AND NO MESSAGE WILL BE ISSUED.  *\n*                                                                     *\n*                RETURN CODE =                                        *\n*                   4  - ISSUE PROMPT AND RETURN REPLY   (IEPROMPT)   *\n*                   8  - ISSUE MESSAGE AND RETURN        (IEMSG)      *\n*                   12 - REJECT THIS JOB                 (IEREJECT)   *\n*                   16 - TERMINATE THIS COMMAND          (IEABORT)    *\n*                   (THIS VERSION USES ERROR CODE 8 AND 12)           *\n*                                                                     *\n*             EXTERNAL REFERENCES =                                   *\n*                                                                     *\n*                ROUTINES = NONE                                      *\n*                                                                     *\n*                DATA AREAS = NONE                                    *\n*                                                                     *\n*                CONTROL BLOCKS = PARMLIST, CVT, ASVT, ASCB, TSB      *\n*                                                                     *\n*             TABLES = DATA AREA TO BE GETMAINED.  MAPPED BY DSECT    *\n*                BEGINNING AT LABEL DATA.                             *\n*                                                                     *\n*             MACROS = IKJEFFIE, FREEMAIN, GETMAIN, SAVE, TPUT, CVT,  *\n*                      IKJTSB, IKTTSBX                                *\n*                                                                     *\n*             CHANGE ACTIVITY =\n*                                                                     *\n*                COMPARE OF USERID AND JOBNAME LENGTH MOVED        CUJ*\n*                CHECK FOR INVALID JOBNAME ADDED                   INJ*\n*                SEE 'MAINTENANCE' SECTION FOR LOCAL CHANGES          *\n*                                                                     *\n*             MESSAGES =                                              *\n*                                                                     *\n*                NO MESSAGES ARE ISSUED BY THIS MODULE UNLESS         *\n*                STATUS IS ISSUED FOR JOBNAME 'TSO'.                  *\n*                MESSAGE TEXTS ARE, HOWEVER, PASSED BACK TO THE       *\n*                CALLER IN AN AREA GETMAINED BY THIS EXIT.            *\n*                FOR CANCEL THE MESSAGE IS THAT FOUND AT LABEL        *\n*                REJTEXT1.  FOR OUTPUT THE MESSAGE IS THAT FOUND      *\n*                AT LABEL REJTEXT2.  FOR STATUS WITH JOBAME 'TSO'     *\n*                TPUT IS USED TO PUT OUT LINES OF OUTPUT WHICH        *\n*                GIVE USERID, ADDRESS SPACE ID AND TERMINAL           *\n*                ADDRESS.  A HEADER LINE IS FOUND AT LABEL            *\n*                HEADER AND A TRAILER LINE IS FOUND AT LABEL          *\n*                USERS.  IF THIS MODULE ISSUED ITS OWN PUTLINE'S OR   *\n*                PUTGET'S WITH SECOND LEVELS, IT WOULD NEED TO DO     *\n*                MODESET TO KEY 0 BEFORE ISSUING THE MESSAGE(S).      *\n*                THEN DO A MODESET BACK TO KEY 1 BEFORE RETURNING     *\n*                TO THE CALLER.                                       *\n*                                                                     *\n*             ABEND CODES = NONE                                      *\n*                                                                     *\n* MAINTENANCE  WHO    DATE     DESCRIPTION                            *\n*              CJP     8/20/85 REDID AUTHORIZATION CHECKING. SEE      *\n*                              'PRCAUTH' SUBROUTINE.                  *\n*                                                                     *\n*              PTW    12/31/85 CREATED EXCEPTION TABLE TO FACILITATE  *\n*                              ADDING NEW RULES.                      *\n*                                                                     *\n*              PTW    02/21/86 ALLOW PDB TO ACCESS ANY PDB JOB        *\n*                                                                     *\n*              PTW    03/04/86 ALLOW PTR ACCESS TO A04, APS, A9 JOBS. *\n*                              ALLOW FOR RENAMING A04 JOBS TO A9.     *\n*                                                                     *\n*              PTW    03/06/86 ALLOW PDB ACCESS TO EV, EX JOBS.       *\n*                                                                     *\n*              PTW    03/11/86 ALLOW PDB ACCESS TO ER JOBS.           *\n*                                                                     *\n*              CJP    03/17/86 ALLOW CDV TO ACCESS ER, EV JOBS        *\n*                                                                     *\n*              CJP    03/22/86 ENOUGH OF THIS ALREADY. SINCE WE       *\n*                              NEVER ANTICIPATED THIS MUCH ACTIVITY   *\n*                              IN THE JOBNAME ACCESS TABLE, THE       *\n*                              ADMINISTRATIVE LOAD OF SMP'ING EVERY   *\n*                              LITTLE CHANGE HAS BECOME TIRESOME.     *\n*                              SO NOW WE WILL MAKE IT EASIER BY       *\n*                              REPLACING THE TABLE LOOKUP WITH ACF2   *\n*                              GENERALIZED RESOURCE RULE TEST.        *\n*                              ALSO CHANGED MESSAGE TEXT.             *\n*                                                                     *\n***********************************************************************\n         EJECT\nIKJEFF53 CSECT\n         SAVE  (14,12),,IKJEFF53.PRC.&SYSTIME..&SYSDATE SAVE REGISTERS\n         PRINT NOGEN\n         BALR  R12,0                   BRANCH AND LOAD REGISTER 12\nPSTART   DS    0H                      LABEL USED WHEN ESTABLISHING\n         USING PSTART,R12              CSECT ADDRESSABILITY\n         L     R0,SIZDATD              LOAD REGISTER 0 WITH SIZE FOR\n*                                      GETMAIN\n         GETMAIN R,LV=(0)              ISSUE REGISTER FORM OF GETMAIN\n*                                      FOR AREA IN SUBPOOL 0\n         LR    R11,R1                  LOAD REGISTER 11 WITH ADDRESS OF\n*                                      GETMAINED AREA\n         USING DATD,R11                ESTABLISH ADDRESSABILITY TO\n*                                      GETMAINED AREA\n         ST    R13,SAVEAREA+4          SAVE REGISTER 13 FOR SAVEAREA\n*                                      CHAINING\n         LM    R0,R1,20(R13)           RELOAD REGISTERS 0 AND 1 FROM\n*                                      PREVIOUS SAVEAREA\n         ST    R11,8(,R13)             SAVE ADDRESS OF CURRENT SAVEAREA\n         LR    R13,R11                 LOAD REGISTER 13 WITH ADDRESS OF\n*                                      CURRENT SAVEAREA\n         LR    R4,R1                   LOAD REGISTER 4 WITH POINTER TO\n*                                      PARAMETER LIST\n         USING IEPARML,R4              ESTABLISH ADDRESSABILITY TO\n*                                      PARAMETER LIST (USES\n*                                      IKJEFFIE MAPPING MACRO)\n         LA    R5,IECONTIN             INITIALIZE REGISTER 5 FOR RETURN\n*                                      CODE FOR NORMAL CASE - JOBNAME\n*                                      IS GOOD AND COMMAND SHOULD\n*                                      CONTINUE PROCESSING\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        ALWAYS DO PROCESSING                                         *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         L     R6,IECODEP              LOAD COMMAND CODE POINTER\n         CLI   0(R6),IECANCEL          SEE IF COMMAND IS CANCEL\n         BE    PROCESS                 YES....CONTINUE PROCESSING\n         CLI   0(R6),IEOUTPUT          SEE IF COMMAND IS OUTPUT\n         BE    PROCESS                 YES....CONTINUE PROCESSING\n         CLI   0(R6),IESTATUS          SEE IF COMMAND IS STATUS\n         BNE   ENDPROC                 NO.....DO NO PROCESSING\n*                                      IF INVALID CODE\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        SEE IF SECOND TIME ENTRY FOR A JOB -                         *\n*           MESSAGE POINTER NOT ZERO                                  *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nPROCESS  DS    0H\n         L     R6,IEMSGP               LOAD MESSAGE POINTER\n         LTR   R6,R6                   SEE IF MESSAGE ISSUED FOR LAST\n*                                      ENTRY\n         BNZ   FREEMESS                YES....GO FREE MESSAGE BUFFER\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        DETERMINE IF THIS IS FOR CANCEL                              *\n*           NO.....GO TO OUTPUT ROUTINE                               *\n*           YES....IF USER HAS OPERATOR AUTHORITY THEN O.K.           *\n*              ELSE CHECK IF JOBNAME IS VALID FOR CANCEL              *\n*              CANCEL NEEDS JOBNAME EQUAL TO USERID                   *\n*              PLUS AT LEAST ONE CHARACTER                            *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nVALIDITY DS    0H\n         L     R6,IECODEP              LOAD COMMAND POINTER\n         CLI   0(R6),IECANCEL          SEE IF COMMAND IS CANCEL\n         BNE   OUTPUT                  NO.....GO SEE IF OUTPUT COMMAND\n         SPACE\n         BAL   R7,PRCAUTH              CHECK AUTHORIZATION\n         LTR   R15,R15                 CHECK RETURN CODE\n         BZ    ENDPROC                 OK...ALLOW ACCESS\n         B     BADJOBN                 NOPE...GO BUILD MESSAGE\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        SEE IF THIS IS OUTPUT COMMAND                                *\n*           NO.....GO TO STATUS ROUTINE                               *\n*           YES....IF USER HAS OPERATOR AUTHORITY THEN O.K.           *\n*              ELSE CHECK IF JOBNAME IS VALID FOR OUTPUT              *\n*              OUTPUT NEEDS JOBNAME EQUAL TO USERID OR                *\n*              EQUAL TO USERID PLUS AT LEAST ONE CHARACTER            *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nOUTPUT   DS    0H\n         CLI   0(R6),IEOUTPUT          SEE IF COMMAND IS OUTPUT\n         BNE   STATUS                  NO.....GO SEE IF STATUS COMMAND\n         SPACE\n         BAL   R7,PRCAUTH              CHECK AUTHORIZATION\n         LTR   R15,R15                 CHECK RETURN CODE\n         BZ    ENDPROC                 OK...ALLOW ACCESS\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        REJECT THIS INVALID JOBNAME AND BUILD INVALID JOBNAME        *\n*           MESSAGE                                                   *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nBADJOBN  DS    0H                      BUILD BAD JOBNAME MESSAGE\n         L     R0,GETMINFO             SUBPOOL 0, LENGTH DECIMAL 84\n         GETMAIN R,LV=(0)              GET MESSAGE BUFFER\n         ST    R1,IEMSGP               STORE POINTER TO MESSAGE BUFFER\n*                                      INTO PARAMETER LIST\n         LR    R10,R1                  LOAD REGISTER 10 WITH ADDRESS OF\n*                                      GETMAINED AREA\n         USING REJMSG,R10              ESTABLISH REGISTER 10 AS BASE\n*                                      FOR REJECT MESSAGE DSECT\n         MVI   REJMSG,BLANK            INITIALIZE BUFFER WITH BLANKS\n         MVC   REJMSG+1(REJDLEN-1),REJMSG\n         MVC   REJMLEN,=Y(REJDLEN)     PUT IN MAXIMUM MESSAGE LENGTH\n         MVC   REJJOB,JOBWORD          PUT IN WORD 'JOB'\n         L     R1,IENAMELP             LOAD JOBNAME LENGTH POINTER\n         LH    R15,0(,R1)              LOAD JOBNAME LENGTH\n         LR    R14,R15                 LOAD REGISTER 14 WITH LENGTH\n         BCTR  R14,0                   DECREMENT REGISTER 14 FOR MOVE\n         L     R1,IEJOBNMP             LOAD JOBNAME POINTER\n         EX    R14,MOVEJOBN            INSERT THE BAD JOBNAME\n         AH    R15,HALF2               INDEX PAST BLANK AFTER JOBNAME\n         LR    R5,R15                  LOAD REGISTER 5 AS TEMPORARY\n*                                      SAVE AREA FOR REGISTER 15\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        DIFFERENT MESSAGE TEXTS FOR CANCEL AND OUTPUT                *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         L     R1,IECODEP              LOAD COMMAND POINTER\n         CLI   0(R1),IECANCEL          SEE IF COMMAND IS CANCEL\n         BNE   OUTPMESS                NO.....GO TO OUTPUT MESSAGE\n         ALR   R10,R5                  OFFSET MESSAGE IN BUFFER\n         MVC   REJSLOT-1(L'REJTEXT1),REJTEXT1  MOVE IN TEXT FOR CANCEL\n         B     SETRC                   GO SET RETURN CODE\nOUTPMESS DS    0H\n         ALR   R10,R5                  OFFSET MESSAGE IN BUFFER\n         MVC   REJSLOT-1(L'REJTEXT2),REJTEXT2  MOVE IN TEXT FOR OUTPUT\nSETRC    DS    0H\n         LA    R5,IEMSG                SET RETURN CODE TO PROMPT\n         B     ENDPROC                 GO TO RETURN\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        SEE IF THIS IS STATUS COMMAND                                *\n*           NO.....GO TO END OF PROCEDURE                             *\n*           YES....CHECK IF NAME IS 'TSO'                             *\n*              NO.....GO TO END OF PROCEDURE                          *\n*              YES....PUT OUT USERIDS, ASIDS, AND ADDRESSES           *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nSTATUS   DS    0H\n         CLI   0(R6),IESTATUS          SEE IF COMMAND IS STATUS\n         BNE   ENDPROC                 NO.....GO TO END OF PROCEDURE\n         L     R1,IEJOBNMP             LOAD POINTER TO JOBNAME\n         CLC   TSOWORD,0(R1)           SEE IF JOBNAME IS 'TSO'\n         BNE   ENDPROC                 NO.....GO TO END OF PROCEDURE\n         L     R1,IENAMELP             LOAD POINTER TO JOBNAME LENGTH\n         CLC   HALF3,0(R1)             SEE IF JOBNAME LENGTH IS 3\n         BNE   ENDPROC                 NO.....GO TO END OF PROCEDURE\n         L     R15,CVTPTR              LOAD POINTER TO CVT\n         USING CVTMAP,R15              ESTABLISH ADDRESSABILITY TO CVT\n         L     R6,CVTASVT              LOAD POINTER TO ASVT\n         DROP  R15                     DROP ADDRESSABILITY TO CVT\n         L     R5,ASVTMAXU(R6)         LOAD MAXIMUM NUMBER OF ADDRESS\n*                                      SPACES\n         LA    R6,ASVTENTY-4(R6)       LOAD ADDRESS OF FIRST ASVT ENTRY\n*                                      MINUS 4\n         LA    R3,0                    ZERO OUT USER COUNTER\n         TPUT  HEADER,L'HEADER         PUT OUT HEADER LINE\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        GO DOWN THE ADDRESS SPACE VECTOR TABLE                       *\n*           SEE IF ADDRESS SPACE CONTROL BLOCK IS FOR A TSO USER      *\n*              YES....GET ADDRESS SPACE ID, USERID, AND PHYSICAL      *\n*                     TERMINAL ADDRESS AND OUTPUT LINE                *\n*              NO.....GO CHECK NEXT ASCB                              *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nASCBNEXT DS    0H\n         LTR   R5,R5                   SEE IF MAXUSER COUNTER ZERO\n         BZ    LASTASCB                YES....GO HANDLE LAST ASCB\n         BCTR  R5,0                    DECREMENT MAXUSER COUNTER\n         MVI   LINE,C' '               BLANK OUT THE OUTPUT LINE\n         MVC   LINE+1(L'LINE-1),LINE\n         LA    R6,4(R6)                LOAD ADDRESS OF NEXT ASVT ENTRY\n         L     R7,0(R6)                LOAD ADDRESS OF ACSB\n         USING ASCB,R7                 ESTABLISH ADDRESSABILITY TO ASCB\n         TM    0(R6),X'80'             SEE IF ASID IS AVAILABLE\n         BO    ASCBNEXT                YES....GO ON TO NEXT ASVT ENTRY\n         CLC   ASCBASCB(4),ASCBWORD    ENSURE CONTROL BLOCK IS VALID\n         BNE   ASCBNEXT                NO.....GO ON TO NEXT ASVT ENTRY\n         L     R8,ASCBTSB              LOAD ADDRESS OF TSB\n         USING TSB,R8                  ESTABLISH ADDRESSABILITY TO TSB\n         LTR   R8,R8                   SEE IF ADDRESS ZERO - NOT TSO\n         BZ    ASCBNEXT                ZERO...GO ON TO NEXT ASVT ENTRY\n         MODESET EXTKEY=ZERO,SAVEKEY=(2)  MODESET AND SAVE OLD KEY\n         TM    TSBFLG5,TSBVTAM         SEE IF THIS IS A TSO/VTAM TSB\n         BO    GETTSBX                 YES....GO GET TSB EXTENSION\n         LH    R8,TSBLINE              GET BINARY LINE ADDRESS\n         STH   R8,PACK                 STORE ADDRESS IN WORKAREA\n         UNPK  PACK+3(5),PACK(3)       UNPACK THE ADDRESS\n         MVC   LINEADDR,PACK+4         MOVE UNPACKED ADDRESS INTO LINE\n         TR    LINEADDR,TRT-240        TRANSLATE TO EBCDIC\n         B     MODEREST                GO MODESET AND RESTORE OLD KEY\nGETTSBX  DS    0H\n         L     R9,TSBEXTNT             GET ADDRESS OF TSB EXTENSION\n         USING TSBX,R9                 ESTABLISH ADDRESSABILITY TO TSBX\n         TM    TSBXFLG1,TSBXWREC       SEE IF TERMINAL AWAITING RECON\n         BNO   GETSYM                  NO.....GO GET SYMBOLIC NAME\n         MVC   LINESYM(8),DISCON       MOVE IN DISCON'D\n         B     MODEREST                GO MODESET AND RESTORE OLD KEY\nGETSYM   DS    0H\n         MVC   LINESYM(8),TSBTRMID     MOVE IN TERMINAL SYMBOLIC NAME\n         DROP  R8,R9\nMODEREST DS    0H\n         MODESET KEYADDR=(2)           MODESET AND RESTORE OLD KEY\n         L     R8,ASCBJBNS             LOAD POINTER TO JOBNAME FIELD\n         LTR   R8,R8                   SEE IF POINTER IS ZERO\n         BZ    STARTING                YES....GO MOVE IN 'STARTING'\n         MVC   LINEUSID,0(R8)          MOVE USERID TO PRINT LINE\n         B     EDITASID                GO EDIT ASID TO EBCDIC\nSTARTING DS    0H\n         MVC   LINEUSID,STRTWORD       MOVE 'STARTING' TO PRINT LINE\nEDITASID DS    0H\n         LH    R8,ASCBASID             LOAD ADDRESS SPACE ID\n         CVD   R8,PACK                 CONVERT TO DECIMAL\n         MVC   CHAR,EDMSK              MOVE EDIT MASK TO CHAR\n         ED    CHAR,PACK+4             EDIT TO ASID TO EBCDIC\n         MVC   LINEASID,CHAR+5         MOVE THREE CHARS TO PRINT LINE\n         LA    R1,LINE                 LOAD POINTER TO LINE\n         TPUT  (R1),L'LINE             PUT OUT OUTPUT LINE\n         LA    R3,1(R3)                ADD 1 TO USER COUNT\n         B     ASCBNEXT                GO ON TO NEXT ASVT ENTRY\n         DROP  R7\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        AT END OF ASVT CHAIN SO PUT OUT TSO USER COUNT               *\n*           AND SET RETURN CODE FOR USERID REJECT                     *\n*           TO AVOID SEARCH FOR JOBNAME 'TSO'                         *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nLASTASCB DS    0H\n         CVD   R3,PACK                 CONVERT USER COUNT TO DECIMAL\n         MVC   CHAR,EDMSK              MOVE EDIT MASK TO CHAR\n         ED    CHAR,PACK+4             CONVERT DECIAML COUNT TO EBCDIC\n         MVC   LINE(4),CHAR+4          MOVE IN COUNT\n         MVC   LINE+4(L'USERS),USERS   MOVE IN MESSAGE\n         LA    R1,LINE                 LOAD POINTER TO OUTPUT LINE\n         TPUT  (R1),L'LINE             PUT OUT COUNT MESSAGE\n         LA    R5,IEREJECT             TREAT AS IF JOBNAME REJECTED\n         B     ENDPROC                 GO TO END OF PROCEDURE\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        SECOND TIME ENTRY (FREE MESSAGE BUFFER)                      *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nFREEMESS DS    0H\n         L     R1,IEMSGP               LOAD POINTER TO GETMAINED AREA\n         L     R0,GETMINFO             LOAD SUBPOOL NUMBER AND LENGTH\n*                                      OF GETMAINED AREA\n         FREEMAIN  R,LV=(0),A=(1)      FREE MESSAGE BUFFER\n         SLR   R6,R6                   ZERO OUT MESSAGE POINTER ENTRY\n         ST    R6,IEMSGP               IN PARMLIST\n         LA    R5,IEREJECT             SET RETURN CODE TO 12 - DELETE\n*                                      ENTRY\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        RETURN TO CALLER (STATUS, CANCEL, OR OUTPUT COMMAND)         *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nENDPROC  DS    0H\n         L     R13,4(,R13)             RESTORE REGISTER 13\n         L     R0,SIZDATD              LOAD REGISTER 0 WITH SIZE OF\n*                                      GETMAINED AREA\n         LR    R1,R11                  LOAD REGISTER 1 WITH ADDRESS OF\n*                                      GETMAINED AREA\n         FREEMAIN R,LV=(0),A=(1)       FREE GETMAINED AREA\n         LR    R15,R5                  LOAD REGISTER 15 WITH RETURN\n*                                      CODE\n         L     R14,12(,R13)            LOAD REGISTER 14 WITH RETURN\n*                                      ADDRESS\n         LM    R0,R12,20(R13)          RESTORE REGISTERS\n         BR    R14                     RETURN VIA REGISTER 14\n         EJECT\n***********************************************************************\n* PRCAUTH:                                                            *\n*                                                                     *\n*   /*  THIS REPLACES THE NORMAL AUTHORIZATION CHECK SUPPLIED     */  *\n*   /*  BY IBM WITH THE FOLLOWING:                                */  *\n*                                                                     *\n*       IF (USER HAS 'OPER' AUTHORITY)       -- OR --                 *\n*          (JOBNAME BEGINS WITH USERID)                               *\n*         THEN RETURN -- ALLOW ACCESS;                                *\n*                                                                     *\n*       LOCATE ACF2 CVT INLINE (AVOID EXT REF TO $ACFGCVT);           *\n*       FORMAT PARAMETER LIST;                                        *\n*       ISSUE ACF2 SVC TO VALIDATE ACCESS;                            *\n*                                                                     *\n*       IF (SVC RETURN CODE IS ZERO)                                  *\n*         THEN RETURN -- ALLOW ACCESS;                                *\n*         ELSE RETURN --  DENY ACCESS;                                *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*      REGISTERS ARE NOT SAVED OR RESTORED BY THIS SUBROUTINE.        *\n*                                                                     *\n* REGISTERS AT ENTRY                                                  *\n*              R4    IKJEFFIE PARAMETER LIST                          *\n*              R7    RETURN ADDRESS                                   *\n*                                                                     *\n* REGISTER USE IN PROGRAM                                             *\n*              R0    WORK                                             *\n*              R1    WORK                                             *\n*              R2    USER ID LENGTH                                   *\n*              R4    IKJEFFIE PARAMETER LIST                          *\n*              R6    JOBNAME LENGTH                                   *\n*              R7    RETURN ADDRESS                                   *\n*              R8    ACF2 CVT BASE                                    *\n*              R9    ACF2 SVC PARAMETER LIST BASE                     *\n*              R14   WORK                                             *\n*              R15   RETURN CODE                                      *\n*                                                                     *\n* REGISTERS AT EXIT                                                   *\n*              R4    IKJEFFIE PARAMETER LIST                          *\n*              R7    RETURN ADDRESS                                   *\n*              R15   RETURN CODE                                      *\n*                    0  ALLOW ACCESS                                  *\n*                    8  DENY ACCESS                                   *\n*                                                                     *\n**********************************************************************/\n         SPACE\nPRCAUTH  DS    0H\n         SPACE\n         EXTRACT PSCBADDR,'S',FIELDS=PSB,MF=(E,EXTLIST)\n*                                      GET ADDRESS OF PROTECTED STEP\n*                                      CONTROL BLOCK\n         XR    R15,R15                 ZERO RETURN CODE REGISTER\n         SPACE\n         L     R1,PSCBADDR             LOAD POINTER TO PSCB\n         TM    PSCBATR1(R1),PSCBCTRL   SEE IF USER HAS 'OPER' AUTHORITY\n         BOR   R7                      YEP...RETURN TO CALLER, ALLOW\n         SPACE\n         L     R1,IEIDLENP             LOAD USERID LENGTH POINTER\n         XR    R2,R2                   CLEAR WORK REGISTER\n         ICM   R2,B'0001',0(R1)        CHECK WHETHER JOBNAME IS VALID\n         BZ    PRCAUTHX                JOBNAME IS INVALID IF USERID\n*                                      IS NOT AVAILABLE (LENGTH=0 FOR\n*                                      FOR TSO COMMANDS IN BACKGROUND)\n         BCTR  R2,0                    DECREMENT COUNT FOR EXECUTE\n         L     R6,IENAMELP             LOAD JOBNAME LENGTH POINTER\n         LH    R6,0(,R6)               LOAD JOBNAME LENGTH\n         BCTR  R6,0                    DECREMENT COUNT FOR EXECUTE\n         SPACE\n         CR    R2,R6                   SEE IF USERID LENGTH\n*                                      IS EQUAL TO OR SHORTER\n*                                      THAN JOBNAME LENGTH\n         BH    PRCAUTHX                NOPE...GO BUILD INVALID\n*                                      JOBNAME MESSAGE\n         L     R1,IEUSRIDP             LOAD USERID POINTER\n         L     R14,IEJOBNMP            LOAD JOBNAME POINTER\n         EX    R2,PRCAUTHY             EXECUTE OF COMPARE\n         BER   R7                      OK...RETURN, ALLOW ACCESS\n         SPACE\n         ACFINCVT R8,NONE=PRCAUTHX     GET ACF2 CVT\n         USING ACCVT,R8\n         SPACE\n         LA    R9,ACFPLIST             SVC PARAMETER LIST\n         USING ACGRSRC,R9\n         SPACE\n         MVI   ACGRSRC,X'00'                  CLEAR CHARACTER\n         MVC   ACGRSRC+1(ACGRSLEN-1),ACGRSRC  FILL PARAMETER LIST\n         SPACE\n         MVI   ACGFCN,4                FUNCTION CODE\n         MVI   ACGSFCN,ACGSINP         SUBFUNCTION - INTERPRET RULE\n         MVI   ACGFLGS,ACGFADRQ        USE ADDRESS SPACE ACF2 UCB\n         LA    R14,ACFMSG              RETURN MESSAGE AREA\n         ST    R14,ACGMSG              INTO PARM LIST\n         MVC   ACGRTYPE,=C'RJOL'       RESOURCE TYPE - JOB OUTPUT LIST\n         MVI   ACGRNAME,C' '           BLANK OUT RESOURCE NAME\n         MVC   ACGRNAME+1(L'ACGRNAME-1),ACGRNAME\n         MVC   ACGMODID,=CL8'IKJEFF53' SMF RECORD MODID\n         SPACE\n         L     R14,IEJOBNMP            JOBNAME POINTER\n         EX    R6,PRCAUTHZ             MOVE JOBNAME TO PARAMETER LIST\n         SPACE\n         L     R1,IECODEP              POINTER TO COMMAND VERB CODE\n         CLI   0(R1),IECANCEL          CANCEL COMMAND?\n         BE    PRCAUTHB                YEP... REQUIRES DELETE ACCESS\n         ICM   R1,B'1111',IEOUTPLP     PARSE LIST POINTER\n         BZ    PRCAUTHX                NO PARSE LIST -- TILT\n         USING IEOUTPLD,R1\n         TM    IESYNTX1,IEDELETE       DELETE REQUESTED?\n         BO    PRCAUTHB                YEP...GET DELETE ACCESS\n         TM    IESYNTX1,IENCLASS       NEWCLASS REQUESTED?\n         BO    PRCAUTHC                YEP...GET UPDATE ACCESS\n*              ASSUME 'PRINT' IF NOT DELETE OR NEWCLASS\n         TM    IESYNTX2,IEKEEP         KEEP REQUESTED?\n         BNO   PRCAUTHB                NOPE...GET DELETE ACCESS\n         TM    IESYNTX1,IEHOLD         HOLD REQUESTED?\n         BNO   PRCAUTHC                NOPE...GET UPDATE ACCESS\n         OI    ACGFLGS,ACGFARD         READ ACCESS REQUEST\n         B     PRCAUTHD                ONWARD\nPRCAUTHB DS    0H\n         OI    ACGFLGS,ACGFADEL        DELETE ACCESS REQUEST\n         B     PRCAUTHD                ONWARD\nPRCAUTHC DS    0H\n         OI    ACGFLGS,ACGFAUPT        UPDATE ACCESS REQUEST\nPRCAUTHD DS    0H\n         DROP  R1\n         SPACE\n         ACFSVC ACGRSRC,TYPE=A,CVT=HAVE,NONE=PRCAUTHX\n         SPACE\n         LTR   R15,R15                 CHECK RETURN CODE\n         BZR   R7                      ALLOW ACCESS IF ZERO\n         SPACE\nPRCAUTHX DS    0H\n         LA    R15,8                   SET DENIAL RETURN CODE\n         BR    R7                      RETURN TO CALLER, DENY ACCESS\n         SPACE 2\nPRCAUTHY CLC   0(*-*,R1),0(R14)        EXECUTED -- JOBNAME :: USERID\nPRCAUTHZ MVC   ACGRNAME(*-*),0(R14)    EXECUTED -- JOBNAME TO PLIST\n         SPACE\n         DROP  R8,R9\n         EJECT\n******** CONSTANTS AND DSECTS *********\nIKJEFF53 CSECT\nDATA     DS    0H\nMOVEJOBN MVC   REJSLOT(0),0(R1)\nHALF84   DC    H'84'\nHALF2    DC    H'2'\nHALF3    DC    H'3'\nJOBWORD  DC    CL4'JOB '\nBLANK    EQU   C' '\n         SPACE\nDATD     DSECT\n         DS    0F\nSAVEAREA DS    18F\nEXTLIST  EXTRACT MF=L\nPSCBADDR DS    F\nPSCBATR1 EQU   16\nPSCBCTRL EQU   X'80'\nACFPLIST DS    XL(ACGRSLEN)        ACF2 SVC PARAMETER LIST\nACFMSG   DS    CL128               ACF2 SVC ERROR MESSAGE\nPACK     DS    D\nCHAR     DS    CL8\nLINE     DS    CL26\n         ORG   LINE+1\nLINEUSID DS    CL8\n         ORG   LINE+11\nLINEASID DS    CL3\n         ORG   LINE+17\nLINEADDR DS    CL3\n         ORG   LINE+17\nLINESYM  DS    CL8\n         ORG\n         DS    0D\nENDDATD  EQU   *\n         SPACE\nIKJEFF53 CSECT\n         DS    0F\nSIZDATD  DC    AL1(0)\n         DC    AL3(ENDDATD-DATD)\nREJTEXT1 DC    C'REJECTED - YOU DO NOT HAVE AUTHORITY TO CANCEL THIS JO+\n               B'\nREJTEXT2 DC    C'REJECTED - YOU DO NOT HAVE AUTHORITY TO ACCESS THIS JO+\n               B OUTPUT FOR THIS FUNCTION'\nHEADER   DC    CL21'  USERID  ASID  LINE '\nEDMSK    DC    XL8'4020202020202120'\nUSERS    DC    CL20' USERS ARE LOGGED ON'\nTRT      DC    CL16'0123456789ABCDEF'\nTSOWORD  DC    CL3'TSO'\nASCBWORD DC    CL4'ASCB'\nSTRTWORD DC    CL8'STARTING'\nDISCON   DC    CL8'DISCON''D'\nGETMINFO DS    0F                      SUBPOOL AND LENGTH FOR GETMAIN\n*                                      OF MESSAGE AREA\nGETMSP   DC    AL1(0)\nGETMLEN  DC    AL3(REJDLEN)\n         SPACE\n         LTORG\n         DS    0F\nPATCH    DC    8CL4'ZAP*'\n         SPACE\nR0       EQU   00                      EQUATES FOR REGISTERS 0-15\nR1       EQU   01\nR2       EQU   02\nR3       EQU   03\nR4       EQU   04\nR5       EQU   05\nR6       EQU   06\nR7       EQU   07\nR8       EQU   08\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nASVTENTY EQU   528\nASVTMAXU EQU   516\nREJMSG   DSECT                         DSECT FOR RETURN MESSAGE\nREJMLEN  DS    H\nREJJOB   DS    CL4\nREJSLOT  DS    CL9\nREJTEXT  DS    CL100                   ARBITRARY MAXIMUM LENGTH\nREJDLEN  EQU   *-REJMSG\n         SPACE\n         ACCVT\n         ACGRSRC\n         SPACE\n         IHAASCB  DSECT=YES\n         IKJEFFIE IETYPE=OUTPUT\n         IKJTSB   LIST=YES,EXT=NO\n         IKTTSBX\n         CVT      DSECT=YES\n         SPACE 3\n         END   IKJEFF53\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INITL": {"ttr": 4874, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "FILE369"}, "text": "         MACRO\n&NAME    INITL &FIELD,&CHAR\n         LCLC  &LEN\n&LEN     SETC  'L'''\n         AIF   (K'&FIELD EQ 0).EROR\n         AIF   (K'&CHAR EQ 0).BLANK\n&NAME    MVI   &FIELD,&CHAR\n.NXT     MVC   &FIELD+1(&LEN&FIELD-1),&FIELD\n         MEXIT\n.EROR    MNOTE 8,'*** FIELD TO BE SET MISSING ***'\n         MEXIT\n.BLANK   MNOTE *,'*** LITERAL MISSING - FIELD SET TO BLANKS ***'\n&NAME    MVI   &FIELD,X'40'\n         AGO   .NXT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ISFUSER": {"ttr": 4876, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x02\\t\\x02\\t\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 521, "newlines": 521, "modlines": 0, "user": "FILE369"}, "text": "         TITLE '<< SDSF USER AUTHORIZATION EXIT (ISFUSER) >>'\n***********************************************************************\n*                                                                     *\n* NAME         ISFUSER                                                *\n*                                                                     *\n* COMPONENT    SPOOL DISPLAY AND SEARCH FACILITY USER AUTHORIZATION   *\n*              EXIT                                                   *\n*                                                                     *\n* FUNCTION     REFER ALL SDSF USER AUTHORIZATION CHECKS TO ACF2       *\n*                                                                     *\n* ENTRY        CALLED FROM ISFAUTH                                    *\n*                                                                     *\n* PARAMETERS   N/A                                                    *\n*                                                                     *\n* OPERATION:                                                          *\n*          THE AUTHORIZATION CHECK EXIT IS ENTERED KEY ONE AND        *\n*        SUPERVISOR THROUGH THE SDSF SVC.                             *\n*                                                                     *\n*          THIS IS THE AUTHORIZATION CHECK USER EXIT FOR SDSF.        *\n*        ON ENTRY REGISTER 0 CONTAINS THE FOLLOWING:                  *\n*                                                                     *\n*              0 - FOR THE INITIALIZATION CALL                        *\n*              4 - FOR A COMMAND CHECK CALL                           *\n*              8 - FOR A DISPLAY SYSOUT CALL                          *\n*             12 - FOR THE TERMINATION CALL                           *\n*                                                                     *\n*              ON ENTRY REGISTER ONE CONTAINS A PARAMETER LIST        *\n*        WHICH IS MAPPED BY THE USERPARM DSECT CONTAINED IN THIS      *\n*        MEMBER.  A RETURN CODE OF OTHER THAN ZERO WILL CANCEL THE    *\n*        FUNCTION. NOTE THAT IF THE SVC IS AVAILABLE THE PARAMETER    *\n*        LIST IS IN KEY ONE STORAGE.                                  *\n*              THE TERMINATION CALL IS PROVIDED FOR THE USER EXIT     *\n*        TO CLEAN UP ANY WORK AREAS GOTTEN DURING PRIOR CALLS.        *\n*                                                                     *\n* INPUT        USERPARM DSECT PASSED IN REG1                          *\n*                                                                     *\n* OUTPUT       RETURN CODE IN REG15                                   *\n*                                                                     *\n* RETURN CODES 0 - COMMAND ISSUED                                     *\n*              4 - AUTHORIZATION CHECK FAILED                         *\n*                                                                     *\n* EXITS        SVC CALL TO ACF2                                       *\n*                                                                     *\n* MESSAGES     N/A                                                    *\n*                                                                     *\n* MACROS       FREEMAIN                                               *\n*              GETMAIN                                               *\n*              REGS                                                   *\n*              RETURN                                                 *\n*              SAVE                                                   *\n*              WTO                                                    *\n*                                                                     *\n* TABLES       ACCVT                                                  *\n*              ACFASVT                                                *\n*              ACGRSRC                                                *\n*              ACUCB                                                  *\n*              IHAASCB                                                *\n*              IHAPSA                                                 *\n*              ISFUPRM                                                *\n*              LIDREC                                                 *\n*                                                                     *\n* ATTRIBUTES   REENTRANT                                              *\n*              REFRESHABLE                                            *\n*              SUPERVISOR STATE                                       *\n*              STORAGE KEY 0                                          *\n*              NOT AUTHORIZED                                         *\n*              AMODE 24                                               *\n*              RMODE 24                                               *\n*                                                                     *\n* OTHER RESOURCES:                                                    *\n*              TWO RESOURCE DIRECTORIES ARE NEEDED WITHIN THE ACF2    *\n*              ENVIRONMENT TO ALLOW THE USE OF THE OPERATOR COMMAND   *\n*              AND JOB OUTLIST CHECKING FACILITIES PROVIDED WITHIN    *\n*              THIS EXIT. THEY ARE CALLED RCMD AND RJOL RESPECTIVELY  *\n*              AT OUR INSTALLATION, AND CONTAIN A CUSTOMIZED RESOURCE *\n*              RULE SET BASED ON OUR SECURITY STANDARDS.              *\n*                                                                     *\n* AUTHOR       KEN MATTHEWS                                           *\n*              (THE COMMAND PARSER IN CMDCHK WAS BASTARDIZED          *\n*              FROM MVSCMD WRITTEN BY C.J. PITTS)                     *\n*                                                                     *\n* MAINTENANCE  WHO    DATE     DESCRIPTION                            *\n*              KEN    05/87    ADDED CMD PARSER TO LIMIT USER         *\n*                              AUTHORITY TO ISSUE OPERATOR COMMANDS   *\n*                              THROUGH ACF2.                          *\n*              CJP    4/14/88  UPDATED FOR NEW SDSF HQX1102. DSECT    *\n*                              CHANGES. SLIGHT COSMETIC CLEANUP.      *\n*                              ADMININTERED VIA LM039.                *\n*                                                                     *\n**********************************************************************/\n*                                                                     *\n* REGISTERS AT ENTRY                                                  *\n*              R0    CALL TYPE                                        *\n*              R1    PARM LIST POINTER                                *\n*              R12   BASE                                             *\n*              R13   SAVE AREA                                        *\n*                                                                     *\n* REGISTER USE IN PROGRAM                                             *\n*              R2    GETMAINED STORAGE ADDRESS                        *\n*              R4    COMPARE REGISTER                                 *\n*              R8    ACF2 CVT POINTER                                 *\n*              R13   BASE REGISTER                                    *\n*              R15   RETURN CODE FROM ACF2 SVC                        *\n*                                                                     *\n* REGISTERS AT EXIT                                                   *\n*              R15   RETURN CODE                                      *\n*                                                                     *\n**********************************************************************/\n         EJECT\nISFUSER  CSECT\n         USING ISFUSER,R15\n         SAVE  (14,12),,ISFUSER-&SYSDATE-&SYSTIME\n         DROP  R15\n         BALR  R12,0                        BASE REGISTER\n         USING *,R12\n         LR    R11,R1                       PICK UP THE PARMLIST\n         USING USERPARM,R11                 ESTABLISH ADDRESSABILITY\n         LR    R10,R0                       LOAD CALL TYPE IN REG10\n         B     CALLTYPE(R10)                GO TO PROPER CODE\nCALLTYPE B     INITCK                       INITIALIZATION\n         B     CMDCK                        COMMAND CHECK\n         B     DSPCK                        DISPLAY SYSOUT CHECK\n         B     EXIT                         EXIT PROCESSING\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                      INITIALIZATION USER CHECK SECTION              *\n*                                                                     *\n***********************************************************************\n* THE INITIALIZATION CHECK SECTION ASSUMES THAT ANYONE MAKING IT      *\n* THIS FAR IS A VALID USER AND THEREFORE DOES NO USER AUTHORIZATION   *\n* CHECKING. THIS SECTION OBTAINS STORAGE FOR REENTERABILITY, AND      *\n* PERFORMS THE OPENING HOUSKEEPING ROUTINES.                          *\n***********************************************************************\n         SPACE 2\nINITCK   DS    0H                           INITIALIZATION USER CHECK\nGETMAIN  GETMAIN RU,LV=SAVLEN,SP=230        STORAGE FOR WTO REENTRANT\n         LR    R2,R1                        GETMAINED ADDR IN REG2\n         LR    R0,R2                        DITTO REG0\n         LA    R1,SAVLEN                    END OF GETMAIN AREA\n         LR    R14,R2                       GETMAINED ADDRESS AGAIN\n         XR    R15,R15                      ZERO OUT REG15\n         MVCL  R0,R14                       CLEAR OUT GETMAINED STORAGE\n         ST    R13,4(R2)                    BACKWARD...\n         ST    R2,8(R13)                    AND FORWARD CHAINING\n         LR    R13,R2                       LOAD REG 13 AS BASE\n         ST    R13,UPRUWORD                 STORE IN UPRUWORD\n         USING SAVEAREA,R13                 ESTABLISH BASE\n         B     RETURN                       AND RETURN (RC=0) TO CALLER\n         SPACE 5\n         EJECT\n***********************************************************************\n*                                                                     *\n*                      OPERATOR COMMAND CHECK SECTION                 *\n*                                                                     *\n***********************************************************************\n* THE OPERATOR COMMAND SECTION RECEIVES CONTROL AFTER AN MVS COMMAND  *\n* IS ENTERED THROUGH SDSF. THIS SECTION FIRST CHECKS FOR SECURITY, OR *\n* NON-CANCEL AUTHORITY AND LOGS THE COMMAND AND USER IF THIS BIT IS   *\n* ON. ALL OTHER USERS ARE SUMMARILY DENIED ACCESS TO ANY COMMANDS THAT*\n* ARE NORMALLY RESERVED FOR OPERATOR USE EXCEPT FOR SPECIAL EXCEPTIONS*\n* ON THE START, STOP, AND MODIFY COMMANDS AS DICTATED THROUGH ACF2.   *\n* THIS SECTION PARSES THE COMMAND ENTERED INTO THE VERB AND JOBNAME,  *\n* AND FEEDS THE DIGESTED INFORMATION TO ACF2. PLEASE NOTE THAT AN     *\n* ACF2 RESOURCE DIRECTORY FOR COMMANDS IS NEEDED ONLINE BEFORE USING  *\n* THIS VERSION OF ISFUSER. THE RESOURCE DIRECTORY USED AT OUR SITE    *\n* IS CALLED RCMD.                                                     *\n***********************************************************************\n         SPACE 2\nCMDCK    DS    0H                           OPERATOR COMMAND CHECK\n         L     R2,UPRUWORD                  PICK UP GETMAINED\n         ST    R13,4(R2)                    STORAGE,FORWARD CHAIN\n         ST    R2,8(R13)                    BACK CHAIN AND...\n         LR    R13,R2                       SET UP THE BASE\n         USING SAVEAREA,R13\n         SPACE\n         ACFINCVT R6,NONE=RETURN            GET CVT FOR ACF2\n         USING ACCVT,R6                     SET UP DSECT BASE\n         ACFGUCB R8,INLINE=YES,SYS=AOS2,NONE=RETURN\n         USING ACUCB,R8\n         L     R14,ACULRECP                 LIDREC ADDRESS\n         USING LIDREC,R14\n         TM    LIDTFLAG,LIDTSEC             SECURITY AUTHORITY?\n         BO    WTO2LOG                      YEP...GO ISSUE COMMAND\n         TM    LIDMFLG,LIDMNCNL             NON-CANCEL AUTHORITY?\n         BO    WTO2LOG                      YEP...GO ISSUE COMMAND\n         DROP  R14\n         MVI   UPRARETC,X'00'               ZERO PREVIOUS AUTH\n         SPACE 3\nCMD2000  DS    0H\n         MVC   VERB,=CL8' '                ---\n         XC    VERBL,VERBL                 -INITIALIZE\n         MVC   JOBNAME,=CL8' '             - ANSWER AREAS\n         XC    JOBNAMEL,JOBNAMEL           ---\n         XR    R1,R1                       CLEAR OUT TRT REGISTER\n         SPACE\n         LA    R7,UPROPCMD\n         LH    R14,0(,R7)                  LENGTH OF PARM STRING\n         BCTR  R14,0                       DECREMENT FOR EXECUTES\n         LA    R15,4(,R7)                  ADDRESS  FIRST BYTE OF PARM\n         EX    R14,NONBLANK                TRT TO GET NON-BLANK\n         CLI   UPRACTCR,X'00'              IF OUTLIST COMMAND\n         BH    JESCHK                      GO TO JES CHECK SECTION\n         SPACE\n         LTR   R14,R14                     REMAINING LENGTH OKAY?\n         BNP   CMD2900                     NONE LEFT --- GO EXIT\n         EX    R14,NONBLANK                TRT TO GET NON-BLANK\n         BZ    CMD2900                     NO NON-BLANKS - GO EXIT\n         SR    R1,R15                      ---\n         SR    R14,R1                    - ADJUST POINTERS AND COUNTERS\n         AR    R15,R1                      ---\n         SPACE\n         LTR   R14,R14                     REMAINING LENGTH OKAY?\n         BNP   CMD2900                     NONE LEFT --- GO EXIT\n         EX    R14,DELIMIT                 TRT TO GET DELIMITER\n         BZ    CMD2900                     GO EXIT IF NO DELIMITER\n         CLM   R2,B'0001',=C' '            BLANK DELIMITER?\n         BNE   CMD2900                     NOPE...INVALID - GO EXIT\n         LR    R3,R15                      SAVE STARTING ADDRESS\n         SR    R1,R15                      ---\n         SR    R14,R1                    - ADJUST POINTERS AND COUNTERS\n         AR    R15,R1                      ---\n         BCTR  R1,0                        DECREMENT FOR EXECUTE\n         CH    R1,=Y(L'VERB-1)             COMPARE TO MAX\n         BH    CMD2900                     TOO LONG...INVALID - GO EXIT\n         EX    R1,MOVEVERB                 EXTRACT VERB\n         STH   R1,VERBL                    SAVE LENGTH\n         SPACE\n         LTR   R14,R14                     REMAINING LENGTH OKAY?\n         BNP   CMD2900                     NONE LEFT --- GO EXIT\n         EX    R14,NONBLANK                TRT TO GET NON-BLANK\n         BZ    CMD2900                     NO NON-BLANKS - GO EXIT\n         SR    R1,R15                      ---\n         SR    R14,R1                    - ADJUST POINTERS AND COUNTERS\n         AR    R15,R1                      ---\n         SPACE\n         LTR   R14,R14                     REMAINING LENGTH OKAY?\n         BNP   CMD2900                     NONE LEFT --- GO EXIT\n         EX    R14,DELIMIT                 TRT TO GET DELIMITER\n         BNZ   CMD2100                     GO IF DELIMITER FOUND\n         LA    R1,2(R14,R15)               FAKE,NO TRAILING DELIMITER\nCMD2100  DS    0H\n         SR    R1,R15                      COMPUTE LENGTH\n         BCTR  R1,0                        DECREMENT FOR EXECUTE\n         CH    R1,=Y(L'JOBNAME-1)          COMPARE TO MAX\n         BH    CMD2900                     TOO LONG...INVALID - GO EXIT\n         EX    R1,MOVEJOBN                 EXTRACT JOBNAME\n         STH   R1,JOBNAMEL                 SAVE LENGTH\nCMD2900  DS    0H\n         EJECT\n***********************************************************************\n* CMD3000:                                                            *\n*        IF VERB IS START/STOP/MODIFY                                 *\n*          THEN SET ACCESS REQUIREMENT BASED ON VERB TYPE;            *\n*          ELSE DO;                                                   *\n*                 SET RETURN CODE;                                    *\n*                 GO RETURN;                         /*  CMD9000  */  *\n*               END;                                                  *\n*                                                                     *\n***********************************************************************\n         SPACE\nCMD3000  DS    0H\n         CLC   =C'START ',VERB              ---\n         BE    CMD3100                      -\n         CLC   =C'S ',VERB                  -\n         BE    CMD3100                      -\n         CLC   =C'STOP ',VERB               - IDENTIFY\n         BE    CMD3200                      -\n         CLC   =C'P ',VERB                  -\n         BE    CMD3200                      - VERB\n         CLC   =C'MODIFY ',VERB             -\n         BE    CMD3300                      -\n         CLC   =C'F ',VERB                  -\n         BE    CMD3300                      ---\n         SPACE\n         MVC   RETCODE,=H'12'               SET BAD RETURN CODE\n         B     FAIL                         GO EXIT\n         SPACE\nCMD3100  DS    0H\n         MVI   VERBTYPE,ACGFAADD            ADD AUTHORITY FOR START\n         B     CMD3500                      ONWARD\n         SPACE\nCMD3200  DS    0H\n         MVI   VERBTYPE,ACGFADEL            DELETE AUTHORITY FOR STOP\n         B     CMD3500                      ONWARD\n         SPACE\nCMD3300  DS    0H\n         MVI   VERBTYPE,ACGFAUPT            UPDATE AUTHORITY FOR MODIFY\n         SPACE\nCMD3500  DS    0H\n         EJECT\n***********************************************************************\n* CMD4000:                                                            *\n*        IF ACF2 USER ID MATCHES BEGINNING OF JOBNAME                 *\n*          THEN ALLOW ACCESS;                                         *\n*          ELSE DO;                                                   *\n*                 FORMAT PARAMETER LIST FOR ACF2 SVC;                 *\n*                 ISSUE ACF2 SVC TO VALIDATE REQUEST;                 *\n*                 IF ACCESS IS DENIED                                 *\n*                   THEN DO;                                          *\n*                          SET RETURN CODE;                           *\n*                          GO RETURN;                /*  CMD9000  */  *\n*                        END;                                         *\n*               END;                                                  *\n*                                                                     *\n***********************************************************************\n         SPACE\nCMD4000  DS    0H\n         LA    R14,L'ACULID-1              LENGTH FOR EXECUTE\n         LA    R15,ACULID                  ADDRESS OF LID\n         EX    R14,DELIMIT                 FIND TRAILING BLANK\n         BNZ   CMD4100                     GO IF NO DELIMITER\n         LA    R1,2(R14,R15)              FAKE OUT ADDRESS OF DELIMITER\nCMD4100  DS    0H\n         SR    R1,R15                      COMPUTE LENGTH\n         BCTR  R1,0                        DECREMENT FOR EXECUTE\n         CH    R1,JOBNAMEL                 CHECK JOBNAME LENGTH\n         BH    CMD4500                    GO IF LID LONGER THAN JOBNAME\n         EX    R1,OWNERCHK                 CHECK FOR 'OWNERSHIP'\n         BE    WTO2LOG                     GO IF 'OWNED'\n         SPACE\nCMD4500  DS    0H\n         XC    ACFPLIST,ACFPLIST           CLEAR PARAMETER LIST\n         LA    R10,ACFPLIST                BASE REGISTER\n         USING ACGRSRC,R10\n         MVI   ACGFCN,4                    FUNCTION CODE\n         MVI   ACGSFCN,ACGSINP             SUBFUNCTION - INTERPRET RULE\n         MVI   ACGFLGS,ACGFADRQ            USE ADDRESS SPACE ACUCB\n         OC    ACGFLGS,VERBTYPE            SET IN REQUEST CODE\n         LA    R14,ACFMSG                  MESSAGE BUFFER ADDRESS\n         ST    R14,ACGMSG                  SET IT\n         MVC   ACGRTYPE,RULETYPE           RESOURCE RULE TYPE CODE\n         MVC   ACGRNAME(L'JOBNAME),JOBNAME SET RESOURCE NAME\n         MVI   ACGRNAME+L'JOBNAME,C' '     BLANK OUT REST OF NAME\n         MVC   ACGRNAME+L'JOBNAME+1(L'ACGRNAME-L'JOBNAME-1),ACGRNAME+L'+\n               JOBNAME                     FILL REST OF NAME WITH BLANK\n         MVC   ACGMODID,=CL8'ISFUSER' SMF RECORD MODID\n         SPACE\n         ACFSVC ACGRSRC,TYPE=A,CVT=HAVE,NONE=RETURN\n         SPACE\n         DROP  R10\n         LTR   R15,R15                     CHECK RETURN CODE\n         BZ    WTO2LOG                     ONWARD IF OKAY\n         SPACE\n         MVC   RETCODE,=H'8'               SET RETURN CODE\n         B     FAIL                        GO EXIT\n         EJECT\n***********************************************************************\n* THE DISPLAY SYSOUT CHECK PORTION IS ENTERED AT DSPCK WHEN A DISPLAY *\n* IS REQUESTED FROM SDSF AND AT JESCHK FROM ANY OTHER LINE COMMAND    *\n* THAT MAY HAVE BEEN ENTERED. ALL OPERATOR TYPE COMMANDS ARE DENIED   *\n* (REMEMBER ONLY SECURITY AND NON-CNCL TYPE FOLKS ARE ALLOWED THESE   *\n* PRIVELEGES). IF THE JOBNAME AND THE USERID MATCH FOR THE LENGTH OF  *\n* THE USERID, THE REQUEST IS ALLOWED WITHOUT CHECKING ACF2. IF NOT    *\n* THE COMMAND INFO, JOBNAME, AND USER ARE PARSED AND LOADED INTO THE  *\n* PROPER ACF2 FIELDS AND THE BALL IS GIVEN TO ACF2. NOTE THAT A       *\n* RESOURCE DIRECTORY FOR JOB OUTLIST MUST BE ONLINE TO ACF2, IN THIS  *\n* CASE IT IS CALLED JOL.                                              *\n***********************************************************************\nDSPCK    DS    0H                           DISPLAY SYSOUT CHECK\n         L     R2,UPRUWORD                  PICK UP GETMAINED\n         ST    R13,4(R2)                    STORAGE,FORWARD CHAIN\n         ST    R2,8(R13)                    BACK CHAIN AND...\n         LR    R13,R2                       SET UP THE BASE\n         USING SAVEAREA,R13\n         SPACE\nJESCHK   DS    0H\n         LA    R4,UPRACTCR                  ACTION VERB FROM SDSF SESS\n         CLI   0(R4),C'A'                   CHECK FOR\n         BE    FAIL                         RESERVED OPERATOR COMMANDS\n         CLI   0(R4),C'E'                   AND DENY ACCESS TO ALL\n         BE    FAIL                         NON AUTHORIZED\n         CLI   0(R4),C'H'                   USERS...\n         BE    FAIL\n         CLI   0(R4),C'T'\n         BE    FAIL                         ELSE...\n         CLC   UPRTSOID(6),UPRJNAME         COMPARE USERID & JOBNAME\n         BE    RETURN                       AND ALLOW ANYTHING ELSE!\n         EJECT\n         ACFINCVT R8,NONE=RETURN            GET CVT FOR ACF2\n         USING ACCVT,R8                     SET UP DSECT BASE\n         XC    ACFPARMS,ACFPARMS            CLEAR PARAMETER LIST\n         LA    R9,ACFPARMS                  SET PARMS BASE\n         USING ACGRSRC,R9\n         MVI   ACGRSRC,X'00'                CLEAR OUT AREA\n         MVC   ACGRSRC+1(L'ACGRSRC-1),ACGRSRC\n         MVI   ACGFCN,4                     LOAD FUNCTION\n         MVI   ACGSFCN,ACGSINP              INTERPRET RULE SUBFUNCTION\n         MVI   ACGFLGS,ACGFADRQ\n         MVI   ACGRFLGS,0\n         LA    R14,ACFMSG                   MESSAGE BUFFER ADDRESS\n         ST    R14,ACGMSG                   SET IT\n         MVC   ACGRTYPE,=C'RJOL'            LOAD RESOURCE TYPE\n         MVI   ACGRNAME,C' '                CLEAR OUT AREA\n         MVC   ACGRNAME+1(L'ACGRNAME-1),ACGRNAME\n         MVC   ACGRNAME(L'UPRJNAME),UPRJNAME\n         MVC   ACGMODID,=CL8'ISFUSER'       WRITE PROGNAME\n         CLI   UPRACTCR,X'00'               LET EM SELECT\n         BE    READACC\n         CLI   UPRACTCR,C'D'\n         BE    READACC                      LOOK FOR\n         CLI   UPRACTCR,C'L'\n         BE    READACC                      READ ACCESS\n         CLI   UPRACTCR,C'O'\n         BE    UPDTACC                      UPDATE ACCESS\n         CLI   UPRACTCR,C'P'\n         BE    DELACC                       OR DELETE ACCESS\n         CLI   UPRACTCR,C'C'\n         BE    DELACC                       AND DEAL ACCORDINGLY\n         B     FAIL                         OTHERWISE...\nREADACC  DS    0H\n         OI    ACGFLGS,ACGFARD              SET READ FLAG\n         B     SVC                          AND CALL ACF2\nDELACC   DS    0H\n         OI    ACGFLGS,ACGFADEL             SET DELETE ACCESS FLAG\n         B     SVC                          AND CALL ACF2\nUPDTACC  DS    0H\n         OI    ACGFLGS,ACGFAUPT             SET UPDATE FLAG\nSVC      ACFSVC ACGRSRC,TYPE=A,CVT=HAVE,NONE=RETURN\n         LTR   R15,R15                      CHECK ACF2 RETCDE\n         BNZ   FAIL                         AND DENY ACCESS IF >0\n         B     RETURN                       OTHERWISE ALLOW ACCESS\n         EJECT\n***********************************************************************\n*                                                                     *\n*                      EXIT CLEAN UP SECTION                          *\n*                                                                     *\n***********************************************************************\n         SPACE 5\nEXIT     DS    0H                           EXIT PROCESSING\n         L     R1,UPRUWORD\n         FREEMAIN RU,LV=SAVLEN,A=(1),SP=230 VIRT STORAGE\n         RETURN (14,12),T,RC=0              RETURN RETURN CODE 0\n         SPACE 5\nWTO2LOG  MVC   LMESS(IMESSLEN),IMESSL       LOAD WTO MESSAGE AREA\n         MVC   LUSER,UPRTSOID               WHODUNIT,\n         MVC   LCMD,UPROPCMD+2              MOVE IN COMMAND ATTEMPTED,\n         WTO   MF=(E,LMESS)                 AND SEND IT TO MSTCONS\nRETURN   DS    0H\n         L     13,SAVE+4                    LOAD REG13 STUFF BACK\n         RETURN (14,12),T,RC=0              RETURN RETURN CODE 0\nFAIL     DS    0H\n         L     13,SAVE+4                    LOAD REG13 STUFF BACK\n         RETURN (14,12),T,RC=4              RETURN\n         EJECT\n***********************************************************************\n*                                                                     *\n*               LITERALS                                              *\n*                                                                     *\n***********************************************************************\nIMESSL   WTO   'SDSF069                              ',MF=L\nIMESSLEN EQU   *-IMESSL\nLUSER    EQU   LMESS+13,7\nLCMD     EQU   LMESS+20,20\nOPERCNTL EQU   X'80'\nNONBLANK TRT   0(*-*,R15),TRNBLANK       EXECUTED - FIND NEXT NON-BLANK\nDELIMIT  TRT   0(*-*,R15),TRTDELIM       EXECUTED - FIND NEXT DELIMITER\nMOVEVERB MVC   VERB(*-*),0(R3)           EXECUTED - MOVE VERB\nMOVEJOBN MVC   JOBNAME(*-*),0(R15)       EXECUTED - MOVE JOBNAME\nOWNERCHK CLC   0(*-*,R15),JOBNAME        EXECUTED - COMPARE OWNERSHIP\nMOVECMD  MVC   0(*-*,R15),2(R7)          EXECUTED - MOVE COMMAND >PLIST\n         SPACE\n         PRINT NOGEN\nRULETYPE DC    C'RCMD'                     RESOURCE RULE TYPE 'CMD'\n         SPACE\nEXTRACTL EXTRACT FIELDS=TJID,MF=L\n         SPACE\n         DS    0D\nTRTDELIM DC    256X'00'                TABLE TO LOCATE C' ', C'.', C','\n         ORG   TRTDELIM+C' '\n         DC    C' '\n         ORG   TRTDELIM+C'.'\n         DC    C'.'\n         ORG   TRTDELIM+C','\n         DC    C','\n         ORG\n         SPACE\nTRNBLANK DC    256X'FF'                  TABLE TO LOCATE NONBLANK\n         ORG   TRNBLANK+C' '\n         DC    X'00'\n         ORG\n         SPACE\n         LTORG\n         EJECT\n***********************************************************************\n*                                                                     *\n*               USER EXIT COMMUNICATION AREA                          *\n*                                                                     *\n***********************************************************************\n         SPACE 5\nSAVEAREA DSECT\nSAVE     DS    18F\nLMESS    DS    0F,CL(IMESSLEN)\nACFPARMS DS    0F,XL(ACGRSLEN)\nVERB     DS    CL8                         COMMAND VERB\nVERBL    DS    H                           VERB LENGTH LESS 1\nJOBNAME  DS    CL8                         COMMAND JOBNAME\nJOBNAMEL DS    H                           JOBNAME LENGTH LESS 1\nVERBTYPE DS    X                           ACCESS CD BASED ON VERB TYPE\nTJID     DS    A                           TSO TJID OR ZERO\n         DS    0F\nACFPLIST DS    0F,XL(ACGRSLEN)             ACF2 RULE CHECK PARM LIST\nACFMSG   DS    CL128                       ACF2 ERROR MESSAGE BUFFER\nRETCODE  DS    H                           RETURN CODE\nSAVLEN   EQU   *-SAVEAREA\n         SPACE 3\n         PRINT GEN\nUSERPARM DSECT                             USER EXIT PARM\n         ISFUPRM                           SDSF PARAMETER LIST\n         PRINT NOGEN\n         ACFASVT\n         ACCVT   ,                         ACF2 CVT\n         ACGRSRC ,                         ACF SVC PARMS\n         ACUCB   ,                         ACF USER CONTROL BLOCK\n         IEZBITS\n         IHAASCB ,                         ASCB\n         IHAPSA  ,                         PSA\n         LIDREC  ,                         ACF2 LOGICAL ID RECORDS\n         REGS\n         SPACE 3\n         END ISFUSER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ISPFPRTO": {"ttr": 5129, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00!\\x00!\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "FILE369"}, "text": " /* ISPFPRTO TITLE 'PRINTOFF SUBCOMMAND OF BROWSE & EDIT        */\n /*          AUTHOR - PARKE WATSON, PRC 1986                    */\n /*          THIS CLIST, PLUS THE FOLLOWING ENTRY IN THE        */\n /*          ISPTLIB MEMBER, \"ISPCMDS,\" WILL PRINT THE DATASET  */\n /*          BEING BROWSED OR EDITED, THUS;                     */\n /*                                                             */\n /*          COMMAND ==> PRINTO                                 */\n /*                                                             */\n /*          INSTEAD OF;                                        */\n /*                                                             */\n /*          COMMAND ==> TSO PRINTO ENDLESS.GODDAM.DATASET.NAME */\n /*                                                             */\n /*          NOTE THAT THE CLIST DEPENDS ON THE PROGRAM ISRPID, */\n /*          WHICH IS ALSO IN THIS FILE.                        */\n /*                                                             */\n /*        ----------ISPCMDS ENTRY--------------------          */\n /*        ZCTVERB    N       PRINTO                            */\n /*        ZCTTRUNC   N       0                                 */\n /*        ZCTACT     N       SELECT CMD(%ISPFPRTO &ZPARM)      */\n /*        ZCTDESC    N       PRINTOFF UNDER BROWSE AND EDIT    */\nPROC 0 COPIES(1) DEST(LOCAL) CLASS(A)\nISPEXEC SELECT PGM(ISRPID)\nISPEXEC VGET (PANELID) SHARED\nIF &PANELID = ISRBROBF OR &PANELID = ISREDDE THEN +\n  DO\n    ISPEXEC VGET (ZDSN,ZMEMB) SHARED\n    SET &DSN = &ZDSN\n    IF &ZMEMB \u00ac= THEN SET &DSN = &STR(&DSN(&ZMEMB))\n    SET &DSN = &STR('&DSN')\n    PRINTO &DSN COPIES(&COPIES) DEST(&DEST) CLASS(&CLASS)\n  END\nELSE +\n  WRITE YOU MUST BE IN BROWSE OR EDIT.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISRBROBF": {"ttr": 5131, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "FILE369"}, "text": ")ATTR\n   _ TYPE(INPUT) CAPS(OFF) INTENS(HIGH) FORMAT(&MIXED)\n   + TYPE(TEXT) INTENS(LOW)\n)BODY  WIDTH(&ZWIDTH) EXPAND(//)\n%BROWSE ----------------------------------/-/----------------------------------+\n%COMMAND ===>_ZCMD                        / /                 %SCROLL ===>_Z   +\n)INIT\n  .HELP = ISR10000\n  .ZVARS = 'ZSCBR'\n  &MIXED = MIX             /* SET FROMAT MIX            */\n  IF (&ZPDMIX = N)         /* IF EBCDIC MODE REQUESTED  */\n    &MIXED = EBCDIC        /*  SET FORMAT EBCDIC        */\n  VPUT (ZDSN,ZMEMB)        /* PRC MODS */\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ISREDDE": {"ttr": 5133, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\r\\x00\\r\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "FILE369"}, "text": ")ATTR\n   _ TYPE(INPUT) CAPS(OFF) INTENS(HIGH) FORMAT(&MIXED)\n)BODY  WIDTH(&ZWIDTH) EXPAND(//)\n%EDIT ------------------------------------/-/----------------------------------+\n%COMMAND ===>_ZCMD                        / /                 %SCROLL ===>_Z   %\n)INIT\n  .HELP = ISR20000\n  .ZVARS = 'ZSCED'\n  &MIXED = MIX             /* SET FROMAT MIX            */\n  IF (&ZPDMIX = N)         /* IF EBCDIC MODE REQUESTED  */\n    &MIXED = EBCDIC        /*  SET FORMAT EBCDIC        */\n  VPUT (ZDSN,ZMEMB)        /* PRC MODS */\n)END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ISRPID": {"ttr": 5135, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00r\\x00r\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 114, "newlines": 114, "modlines": 0, "user": "FILE369"}, "text": "PRC      TITLE 'ISRPID - FETCH THE CURRENT ISPF PANELID.'\n*********************************************************************\n*                                                                   *\n*   THIS ROUTINE RUNS UNDER THE ISPF DIALOG MANAGER AND RETURNS     *\n*   THE NAME OF THE CURRENT PANEL IN DIALOG VARIABLE PANELID.       *\n*   IT WAS DESIGNED FOR USE BY THE PRINTO COMMAND UNDER EDIT AND    *\n*   BROWSE.                                                         *\n*                                                                   *\n*   TO USE -                                                        *\n*     ISPEXEC SELECT PGM(ISRPID)                                    *\n*     ISPEXEC VGET (PANELID)                                        *\n*                                                                   *\n*   05/01/86 - L01 PTW IMPLEMENTED                                  *\n*                                                                   *\n*********************************************************************\n         LCLC  &CSECT\n&CSECT   SETC  'ISRPID'\n&CSECT   CSECT ,\n*********************************************************************\n*                                                                   *\n*        I N I T I A L I Z E   A N D   D E T E R M I N E            *\n*                                                                   *\n*********************************************************************\n         PRINT NOGEN\n         SAVE  (14,12),,&CSECT-&SYSDATE-&SYSTIME\n         LR    R12,R15            ESTABLISH BASE.\n         USING &CSECT,R12         TELL ASSEMBLER.\n         GETMAIN RU,LV=DYNLEN     GET DYNAMIC AREA.\n         LR    R2,R13             SAVE AREA\n         LR    R13,R1             SAVE AREA\n         USING DYNAMIC,R13        TELL ASSEMBLER.\n         LA    R0,DYNAMIC         ZERO\n         LA    R1,DYNLEN            DYNAMIC\n         LR    R14,R0                 STORAGE.\n         SLR   R15,R15\n         MVCL  R0,R14             DO IT.\n         ST    R2,4(,R13)         BACK CHAIN.\n         ST    R13,8(,R2)         FORWARD CHAIN.\n         XC    RC,RC              ASSUME GOOD RC.\n         MVC   CALL(CALLL),XCALL               MOVE DCB INTO WORK AREA\n         MVC   PID,=CL8' '\n*********************************************************************\n*                                                                   *\n*        M A I N L I N E                                            *\n*                                                                   *\n*********************************************************************\n         MVC   PID,PANELID(R9)         R9 = A(TLD).\n         LOAD  EP=ISPLINK\n         ST    R0,ISPLINK\n         L     R15,ISPLINK\n         CALL  (15),(=CL8'VREPLACE',=CL8'PANELID',=A(L'PID),PID),      X\n               VL,MF=(E,CALL)\n         LTR   R15,R15\n         BNZ   BADCALL\n         L     R15,ISPLINK\n         CALL  (15),(=CL8'VPUT',=C'(PANELID)',=CL8'SHARED'),           X\n               VL,MF=(E,CALL)\n         LTR   R15,R15\n         BNZ   BADCALL\n*        TPUT  PID,L'PID\n         DELETE EP=ISPLINK\nRETURN   DS    0H\n         L     R2,RC                  R2 = RC.\n         LR    R1,R13              PREPARE\n         L     R13,4(,R13)         FOR FREEMAIN.\n         FREEMAIN RU,LV=DYNLEN,A=(1)\n         LR    R15,R2              AND RETURN\n         RETURN (14,12),RC=(15)      WITH R15 = RC.\nBADCALL  DS    0H\n         MVC   RC,=F'12'              R2 = RC.\n*        TPUT  =C'BADCALL 12',10\n         B     RETURN\nBADCHAIN DS    0H\n         MVC   RC,=F'16'              R2 = RC.\n*        TPUT  =C'BADCALL 16',10\n         B     RETURN\nXCALL    CALL  ,(,,,,,,,,),VL,MF=L\nCALLL    EQU   *-XCALL\n         LTORG ,\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   A R E A S.                                *\n*                                                                  *\n********************************************************************\nDYNAMIC  DSECT\nSAVE     DS    18F                     SAVE AREA\nRC       DS    F\nISPLINK  DS    A\nCALL     DS    XL(CALLL)\nPID      DS    CL8\nDYNLEN   EQU   *-DYNAMIC\n*\nBACK     EQU   X'04',4\nSAVR1    EQU   X'18',4\nHIORDER  EQU   X'80'\nPANELID  EQU   X'158',8,C'C'     CURRENT PANELID.\n*\nR0       EQU   00\nR1       EQU   01\nR2       EQU   02\nR3       EQU   03\nR4       EQU   04\nR5       EQU   05\nR6       EQU   06\nR7       EQU   07\nR8       EQU   08\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11                 A(PLIST).\nR12      EQU   12                 PROGRAM BASE.\nR13      EQU   13                 A(SAVE AREA).\nR14      EQU   14\nR15      EQU   15\n         END   &CSECT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ISRP22": {"ttr": 5379, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\x14\\x00\\x14\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "FILE369"}, "text": "ISRP220      '&ERRCMD FAILED'           .ALARM = YES\n'&ERRMSG1'\n\nISRP221 'INVALID SELECT CODE'    .ALARM=YES\n'TYPE A VALID CODE IN FRONT OF THE MEMBER TO BE SELECTED.'\n\nISRP222 'NO JOBS FOUND'          .ALARM=YES\n'LOOKED FOR JOBNAMES EQUAL TO YOUR USERID PLUS ONE CHARACTER.'\n\nISRP223 'JOB &TJNM NOT FOUND'    .ALARM=YES\n\nISRP224 'BAD JOBNAME ENTERED'    .ALARM=YES\n'PLEASE CHECK THE SYNTAX OF THE JOBNAME ENTERED.'\n\nISRP225 'INVALID COMMAND'    .ALARM=YES\n'VALID COMMANDS ARE THOSE SHOWN BELOW PLUS SORT AND REFRESH.'\n\nISRP226 'WRONG TIME FOR COMMAND'    .ALARM=YES\n'YOUR MUST FIRST PROCESS A JOB VIA A VALID LINE COMMAND.'\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ISRUDLP": {"ttr": 5381, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00d\\x00d\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 100, "newlines": 100, "modlines": 0, "user": "FILE369"}, "text": "%-------------------------- DATA SET LIST UTILITY ------------------------------\n%OPTION  ===>_ZCMD                                                             +\n%\n%  blank+- Display data set list%*         %P+ - Print data set list\n%  V    +- Display VTOC information only   %PV+- Print VTOC information only\n%\n+Enter one or both of the parameters below:\n+  DSNAME LEVEL %===>_DSNLVL                                      +\n+  VOLUME       %===>_ZDLVOL+\n+\n+SPECIFY THE FOLLOWING, IF DISPLAYING A LIST OF DATA SETS:\n+  DISPLAY FORMAT OPTION %===>_ZUFOP+  (QUICK, SHORT, or LONG)\n+  CONFIRM DELETE REQUEST%===>_ZUPCD+  (YES or NO)\n+\n%*+The following line commands will be available when the list is displayed\n+\n%    B+- Browse data set                %C+- Catalog data set\n%    E+- Edit data set                  %U+- Uncatalog data set\n%    D+- Delete entire data set         %P+- Print entire data set\n%    R+- Rename entire data set         %X+- Print index listing\n%    I+- Data set information           %M+- Display member list\n%    S+- Data set information (short)   %Z+- Compress data set\n)INIT\n  .HELP = ISR34000\n  &ZCMD = &ZUOPT\n  &ZUFOP = TRANS (&FMOPT Q,'QUICK' S,'SHORT' L,'LONG' *,*)\n  &ZUPCD = TRANS (&ZUCDR Y,'YES' N,'NO' *,*)\n  .CURSOR = DSNLVL              /*  cjp  */\n  IF (&DSNLVL = &Z)\n    IF (&ZDLVOL = &Z)\n      &DSNLVL = &ZPREFIX        /*  cjp  */\n      &ZCMD   = &Z\n      &ZUFOP  = QUICK\n      &ZUPCD  = YES\n  &COMPGM = 'IEBCOPY '\n\n  IF (&PRCMOD = FDSPACE)                         /* PSYWAK */\n    IF (&ZDLVOL \u00ac= ' ')                          /* PSYWAK */\n      IF (&SELECT = ' ')                         /* PSYWAK */\n        .RESP = END                              /* PSYWAK */\n    &ZDLVOL = &VOLUME                            /* PSYWAK */\n    &DSNLVL = &Z                                 /* PSYWAK */\n    &ZUFOP  = SHORT                              /* PSYWAK */\n    &ZUPCD  = YES                                /* PSYWAK */\n    &ZCMD   = '&ZDEL.SORT SIZE'                  /* PSYWAK */\n\n)PROC\n  IF (&ZCMD \u00ac= ' ')\n    VER (&ZCMD,LIST,P,V,PV)\n  &ZUOPT = TRUNC (&ZCMD,2)\n  IF (&ZUOPT = V,PV)\n    VER (&ZDLVOL,NONBLANK)\n    IF (&DSNLVL \u00ac= ' ')\n       .MSG = ISRU188\n       .CURSOR = DSNLVL\n\n  IF (&ZUOPT = ' ')\n    IF (&ZDLVOL = ' ')\n      VER (&DSNLVL,NONBLANK,MSG=ISRU187)\n  IF (&ZUOPT = 'P ')\n    IF (&ZDLVOL = ' ')\n      VER (&DSNLVL,NONBLANK,MSG=ISRU187)\n\n  &ZUCDR = TRUNC (&ZUPCD,1)\n  VER (&ZUCDR,NB,LIST,Y,N)\n\n  &FMOPT = TRUNC (&ZUFOP,1)\n  VER (&FMOPT,NB,LIST,S,L,Q)\n\n  IF (&FMOPT = S)\n     &UDLPANEL = 'ISRUDSL1'\n  IF (&FMOPT = L)\n     &UDLPANEL = 'ISRUDSLX'\n  IF (&FMOPT = Q)\n     &UDLPANEL = 'ISRUDSL0'\n\n  IF (&ZDLVOL = &Z )\n     &ZUP2HDRC = 'BEGINNING WITH'\n     &ZUP2HDRV = &DSNLVL\n\n  IF (&ZDLVOL \u00ac= &Z )\n     &ZUP2HDRC = 'ON VOLUME'\n     &ZUP2HDRV = &ZDLVOL\n  &S1 = 'RENAME  '\n  &S2 = 'DELETE  '\n  &S3 = 'CATALOG '\n  &S4 = 'UNCAT   '\n  &S5 = 'PRINTED '\n  &S6 = 'PRINTX  '\n  &S7 = 'INFO-I  '\n  &S8 = 'MEMBLIST'\n  &S9 = 'COMPRESS'\n  &S10 = 'INFO-S  '\n  &S11 = 'BROWSE  '\n  &S12 = 'EDIT    '\n  &UPRTC = 'PPRINTED'\n  &URENC = 'RRENAMED'\n  &UDELC = 'DDELETED'\n  VPUT (S1 S2 S3 S4 S5 S6 S7 S8 S9 S10 S11 S12 UPRTC URENC UDELC) ASIS\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ISRUOL": {"ttr": 5384, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x02}\\x02}\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 637, "newlines": 637, "modlines": 0, "user": "FILE369"}, "text": "/*********************************************************************\n/*\n/* CHANGE LOG -\n/*  02/05/86 PTW IMPLEMENTED\n/*  03/17/86 CJP ADDED TBSORT PRIOR TO FIRST TBDISPL TO PUT JOBS IN\n/*               DESCENDING JES NUMBER ORDER\n/*  05/08/86 PTW FIX BUGS, ADD FEATURES, ETC.\n/*\n/*********************************************************************\n/*********************************************************************\n/*\n/* IBM CODE BEGINS HERE.  WE HAVE INCLUDED ISRUOL INTACT.  PRC CHANGES\n/*   ARE MARKED \"PRC\".\n/*\n/*********************************************************************\n         PROC 0\n           CONTROL NOFLUSH                     /* OUTLIST UTILITY(3.8)/\n           SET &MSGID =\n         LOOP: +\n           ISPEXEC DISPLAY PANEL(ISRUOL01) MSG(&MSGID)\n           IF &LASTCC = 8 THEN +\n             EXIT CODE(0)                      /* END WAS REQUESTED  */\n           ELSE +\n             DO                                /* END NOT REQUESTED  */\n  IF &ZCMD \u00ac= L THEN ISPEXEC CONTROL DISPLAY LINE START(20) /* PRC   */\n               SET &MSGID =\n               IF &ZC \u00ac=  THEN                                +\n                 SET &CLASS = CLASS(&ZC.)    /* SET UP CLASS         */\n               ELSE +\n                 SET &CLASS =\n               IF &TJID \u00ac=  THEN +\n                 SET &JOBID = &STR((&TJID.&STR())) /* SET UP JOBID   */\n               ELSE +\n                 SET &JOBID =\n               IF (&ZCMD = P OR &ZCMD =  )  THEN +\n                 DO                            /* ALLOC PRINT DATASET*/\n                   SET &ZOLID = 100            /*                    */\n                   ISPEXEC VGET (ZOLID) PROFILE\n                   IF (&LASTCC = 8 OR &ZOLID = 999) THEN +\n                     SET &ZOLID = 100          /* GENERATE 3 DIGIT # */\n                   ELSE                        /* TO MAKE DSN UNIQUE */+\n                     SET &ZOLID = &ZOLID + 1\n                   ISPEXEC VPUT (ZOLID) PROFILE\n                   /* OZ88258 REMOVED COMMENTS BEYOND COL 72 BELOW  */\n                   ISPEXEC VGET (ZAPPLID) ASIS\n                     /* GET APPLICATION ID  AND */\n                   ISPEXEC TBSAVE &ZAPPLID.PROF LIBRARY(ISPPROF)\n                     /* SAVE IT IN CASE OF ABNORMAL TERMINATION    */\n                     /* OZ80534 */\n                   IF (&STR(&SYSUID) = &STR(&SYSPREF) OR +\n                     &LENGTH(&SYSPREF)=0) THEN +\n                     SET &DSN = &SYSUID..SPF&ZOLID..OUTLIST\n                     /* OZ83124 */\n                   /* OZ88258 REMOVED COMMENTS BEYOND COL 72 ABOVE */\n                   ELSE  +\n                     SET &DSN = &SYSPREF..&SYSUID..SPF&ZOLID..OUTLIST\n                   CONTROL NOMSG\n                   FREE FI(SPFUOL1)\n                   IF (&ZCMD = ) THEN         /*            OZ83443 */+\n                     DO                       /*            OZ83443 */\n                   ATTR SPFUOL1 BLKSIZE(3059) LRECL(133)  /*OZ83443*/ +\n                     DSORG(PS) RECFM(F B)     /*            OZ83443 */\n                     END                      /*             OZ83443 */\n                   ELSE                       /*             OZ83443*/+\n                     DO                       /*            OZ83443 */\n                   ATTR SPFUOL1 BLKSIZE(3059) LRECL(133) +\n                     DSORG(PS) RECFM(F B &ZR)\n                     END                      /*             OZ83443 */\n                   CONTROL MSG\n                   ERROR +\n                     DO                        /* EXIT USED FOR      */\n                       SET &MSGID = ISRU220    /* ALLOCATION ERROR   */\n                       RETURN\n                     END\n                   ALLOC DA('&DSN') TRACKS     /* ATTRIBUTES OF THE  */+\n                     USING(SPFUOL1) RELEASE    /* PRINT DATASET MAY  */+\n                     SPACE(200 100) CATALOG    /* BE CHANGED TO FIT  */\n                   ERROR OFF                   /* LOCAL ENVIRONMENT. */\n                 END                           /* TAKE CARE          */\n               IF &ZCMD = P AND &MSGID =   THEN +\n                 DO                            /* PRINT OPTION       */\n                   OUTPUT &TJNM.&JOBID &CLASS PRINT('&DSN') BEGIN\n                   ISPEXEC LMINIT DATAID(PRINTDSN) DATASET('&DSN')\n                                               /* INIT DATAID OZ84629*/\n                   ISPEXEC LMOPEN DATAID(&PRINTDSN)\n                                               /* OPEN DATAID OZ84629*/\n                   ISPEXEC LMGET  DATAID(&PRINTDSN) MODE(LOCATE) +\n                           DATALOC(PRINTBUF) DATALEN(PRINTLEN)   +\n                           MAXLEN(32768)       /* READ REC    OZ84629*/\n                   SET &RC = &LASTCC\n                   ISPEXEC LMFREE DATAID(&PRINTDSN)\n                                               /* FREE DATAID OZ84629*/\n                   IF &RC \u00ac= 0 THEN            /* CHECK FOR          */+\n                     DO                        /* EMPTY DATASET      */\n                       SET &MSGID = ISRU222\n                       CONTROL NOMSG\n                       DELETE '&DSN'\n                       CONTROL MSG\n                     END\n                   ELSE +\n                     DO                        /* FOREGROUND PRINT   */\n                       FREE DA('&DSN')\n                       ISPEXEC CONTROL ERRORS CANCEL\n                       SET &ZOCLA =              /* INIT VARIABLES   */\n                       SET &ZOPID =              /* IN CASE THEY ARE */\n                       SET &ZOJB1 =              /* NOT IN THE       */\n                       SET &ZOJB2 =              /* PROFILE POOL     */\n                       SET &ZOJB3 =\n                       SET &ZOJB4 =\n                       ISPEXEC VGET (ZOCLA,ZOPID, +\n                         ZOJB1,ZOJB2,ZOJB3,ZOJB4) PROFILE\n                       SET &ZCLA = &STR(&ZOCLA)  /* THESE VARIABLES  */\n                       SET &ZPID = &STR(&ZOPID)  /* ARE NEEDED BY THE*/\n                       SET &ZJB1 = &STR(&ZOJB1)  /* ISRFPT PROGRAM   */\n                       SET &ZJB2 = &STR(&ZOJB2)  /* IN THE SHARED    */\n                       SET &ZJB3 = &STR(&ZOJB3)  /* VARIABLE POOL    */\n                       SET &ZJB4 = &STR(&ZOJB4)\n                       SET &ZFPRINT = ISRFPPRT\n                       SET &ZFLID = &DSN\n                       ISPEXEC VPUT (ZFPRINT,ZFLID,  +\n                         ZCLA,ZPID,ZJB1,ZJB2,ZJB3,ZJB4)\n                       ISPEXEC SELECT PGM(ISRFPT)\n                       ISPEXEC VGET (ZCLA,ZPID,ZJB1,ZJB2,ZJB3,ZJB4)\n                       SET &ZOCLA = &STR(&ZCLA)  /* SAVE VARIABLES   */\n                       SET &ZOPID = &STR(&ZPID)  /* FROM THE PRINT   */\n                       SET &ZOJB1 = &STR(&ZJB1)  /* PANEL IN THE     */\n                       SET &ZOJB2 = &STR(&ZJB2)  /* PROFILE POOL     */\n                       SET &ZOJB3 = &STR(&ZJB3)\n                       SET &ZOJB4 = &STR(&ZJB4)\n                       SET &MSGID = ISRU227\n                       ISPEXEC VPUT (ZOCLA,ZOPID, +\n                         ZOJB1,ZOJB2,ZOJB3,ZOJB4) PROFILE\n                     END\n                 END\n               ELSE +\n                 IF &ZCMD =  AND &MSGID =   THEN +\n                   DO                          /* BROWSE OPTION      */\n                     OUTPUT &TJNM.&JOBID &CLASS PRINT('&DSN') +\n                       BEGIN KEEP HOLD\n                     ISPEXEC CONTROL ERRORS RETURN\n                     ISPEXEC BROWSE DATASET('&DSN')\n                     IF &LASTCC \u00ac= 0 THEN      /* CHECK FOR          */+\n                       SET &MSGID = ISRU221    /* EMPTY DATASET      */\n                     ISPEXEC CONTROL ERRORS CANCEL\n                     CONTROL NOMSG\n                     DELETE '&DSN'\n                     CONTROL MSG\n                   END\n                 ELSE +\n                   IF &ZCMD = L THEN +\n                     DO                        /* LIST OPTION        */\n                       GOTO PRCUOL             /* PRC                */\n                       SET &L = &LENGTH(&SYSUID)\n                       IF &LENGTH(&TJNM) = &EVAL(&L + 1) THEN +\n                         IF (&SUBSTR(1:&L,&TJNM) = &SYSUID) THEN +\n                           STATUS\n                         ELSE +\n                           STATUS &TJNM\n                       ELSE +\n                         STATUS &TJNM\n                     END\n                   ELSE +\n                     IF &ZCMD = R THEN +\n                       DO                     /* REQUEUE OPTION      */\n                         OUTPUT &TJNM.&JOBID &CLASS NEWCLASS(&ZN)\n                         ISPEXEC LOG MSG(ISRU223)\n                         SET &MSGID = ISRU225  /* REQUEUE COMPLETED  */\n                       END\n                     ELSE +\n                       IF &ZCMD = D THEN +\n                         DO                   /* DELETE OPTION       */\n                           OUTPUT &TJNM.&JOBID &CLASS DELETE\n                           ISPEXEC LOG MSG(ISRU224)\n                           SET &MSGID = ISRU226 /* DELETE COMPLETED  */\n                         END\n             END\n           GOTO LOOP                           /* LOOP UNTIL END     */\n         END\n/*********************************************************************\n/*\n/* IBM CODE ENDS HERE.  PRCUOL ROUTINE FOLLOWS.\n/*\n/*********************************************************************\nPRCUOL: +\nCONTROL NOFLUSH\nSET &LAST =\nSET &M =\nSET &MSGID =\nSET &ERRCMD =\nSET &ERRMSG1 =\nISPEXEC VGET (ZSCREEN)\nSET &FILE = PRCUOL&ZSCREEN\nISPEXEC TBCREATE MEMTABLE REPLACE NOWRITE +\n        KEYS(JOB) NAMES(STATUS LAST)\n/* BE SURE THAT MSGID IS ON IN PROFILE...WE DEPEND ON THIS.\nSET &SETPROF =\nSET &SYSOUTTRAP = 2\nPROFILE LIST\nSET &SYSOUTTRAP = 0\nSET &SYSDVAL = &STR(&SYSOUTLINE1)\nREADDVAL &A &B &C &D &E &F &G &H\nIF &F = &STR(NOMSGID) OR &G = &STR(NOMSGID) THEN +\n  DO\n    SET &SETPROF = YES\n    PROFILE MSGID\n  END\nSET &SYSOUTTRAP = 60\nSET &L = &LENGTH(&SYSUID)\nISPEXEC VGET (TJNM TJID CLASS ZN ZR) PROFILE\n/* HERE WE DO OUR STATUS COMMAND AND TRAP OUTPUT.\nSET &SYSOUTTRAP = 60\nIF &LENGTH(&TJNM) = &EVAL(&L + 1) THEN +\n  IF (&SUBSTR(1:&L,&TJNM) = &SYSUID) THEN +\n    STATUS\n  ELSE +\n    STATUS &TJNM\nELSE +\n  STATUS &TJNM\nSET &SYSOUTTRAP = 0\nSET &S = 1\nSET &SL = &SYSOUTLINE\nDO WHILE &S < &SL+1\n  SET &T = &&SYSOUTLINE&S\n  SET &SYSDVAL = &STR(&T)\n  READDVAL  &A &B &C &D &E &F &G &H &I &J\n/* IKJ56216I = NO JOBS FOUND\n  IF &A = &STR(IKJ56216I) THEN +\n    DO\n      SET &MSGID = ISRP222\n      GOTO ENDPRC\n    END\n/* IKJ56202I = JOB JOBNAME NOT FOUND\n  IF &A = &STR(IKJ56202I) THEN +\n    DO\n      SET &MSGID = ISRP223\n      GOTO ENDPRC\n    END\n/* IKJ56192I = JOB ON OUTPUT QUEUE\n/* IKJ56211I = JOB EXECUTING\n/* IKJ56197I = JOB WAITING FOR EXECUTION\n/* IKJ56190I = JOB AWAITING NETWORK SERVICES\n  IF &A = &STR(IKJ56192I) OR &A = &STR(IKJ56211I) OR   +\n     &A = &STR(IKJ56197I) OR &A = &STR(IKJ56190I) THEN +\n    DO\n      SET J&S = &C\n      SET ST&S = &STR(&D &E &F &G &H &I)\n    END\n  ELSE +\n    DO\n      SET &MSGID = ISRP224\n      GOTO ENDPRC\n    END\n  SET &S = &S+1\nEND\n/* ST TSO IS TREATED SPECIAL BY IKJEFF53.\nIF &TJNM = &STR(TSO) THEN GOTO ENDPRC\n\n/* BUILD OUR TABLE.\nSET &S = 1\nDO WHILE &S < &SL+1\n  SET &K = &&J&S\n  SET JOB = &K\n  SET &L = &&ST&S\n  SET STATUS = &STR(&L)\n  ISPEXEC TBADD MEMTABLE\n  SET &S = &S + 1\nEND\n\n/* OUR PROCESSING LOOP.\nISPEXEC TBSORT  MEMTABLE FIELDS(JOB,C,D)\nISPEXEC TBTOP   MEMTABLE\nISPEXEC TBDISPL MEMTABLE PANEL(ISRUOLP ) POSITION(ROW)\nSET &TBDRC = &LASTCC\nMAINLOOP: DO WHILE &TBDRC < 8\n  DO WHILE &ZTDSELS > 0\n    IF &DOZCMD \u00ac= YES THEN ISPEXEC CONTROL DISPLAY SAVE\n    SET &SYSOUTLINE1 =\n    SET &SYSOUTLINE2 =\n    SET &LASTJOB =\n    SET &TBDRC = 0\n/* BROWSE.\n    IF &M = B THEN +\n      DO\n        SET &SYSOUTTRAP = 2\n        FREE  F(&FILE)\n        ALLOC F(&FILE) TRACKS RELEASE SPACE(20 50) UNIT(VIO)NEW +\n          BLKSIZE(3059) LRECL(133) DSORG(PS) RECFM(F B &ZR)\n        SET &RC = &LASTCC\n        SET &SYSOUTTRAP = 0\n        IF &RC = 0 THEN +\n          DO\n            ISPEXEC SELECT PGM(PRC38DSN) PARM(&FILE)\n            ISPEXEC VGET (OUTDSN OUTVOL)\n            SET &SYSOUTTRAP = 2\n            CONTROL NOLIST NOCONLIST\n            OUTPUT &JOB &CLASS PRINT('&OUTDSN') BEGIN KEEP HOLD\n            SET &SYSOUTTRAP = 0\n            IF &SYSOUTLINE = 0 THEN +\n              DO\n                ISPEXEC LMINIT DATAID(PRCDATA) DDNAME(&FILE)\n                ISPEXEC LMOPEN DATAID(&PRCDATA)\n                ISPEXEC LMGET  DATAID(&PRCDATA) MODE(LOCATE) +\n                  DATALOC(PRINTBUF) DATALEN(PRINTLEN) MAXLEN(32768)\n                SET &RC = &LASTCC\n                IF  &RC = 0 THEN +\n                  DO\n                    ISPEXEC BROWSE DATAID(&PRCDATA)\n                    SET &LAST = BROWSED\n                    SET &LASTJOB = &JOB\n                  END\n                ELSE +\n                  DO\n                    SET &MSGID = ISRU221\n                  END\n                ISPEXEC LMFREE DATAID(&PRCDATA)\n                SET &SYSOUTTRAP = 2\n                FREE F(&FILE)\n                SET &SYSOUTTRAP = 0\n              END\n            ELSE +\n              DO\n                SET &MSGID = ISRP220\n                SET &ERRCMD = BROWSE\n                SET &ERRMSG1 = &STR(&SYSOUTLINE1)\n                SET &SYSOUTTRAP = 2\n                FREE F(&FILE)\n                SET &SYSOUTTRAP = 0\n              END\n          END\n        ELSE +\n          DO\n            SET &MSGID = ISRU220\n            SET &SYSOUTTRAP = 2\n            FREE F(&FILE)\n            SET &SYSOUTTRAP = 0\n          END\n      END\n/* CANCEL.\n    IF &M = C THEN +\n      DO\n        SET &SYSOUTTRAP = 2\n        CANCEL &JOB\n        SET &RC = &LASTCC\n        SET &SYSOUTTRAP = 0\n        IF &RC = 0 THEN +\n          DO\n            SET &LAST = CANCELLED\n            SET &LASTJOB = &JOB\n          END\n        ELSE +\n          DO\n            SET &MSGID = ISRP220\n            SET &ERRCMD = CANCEL\n            SET &ERRMSG1= &STR(&SYSOUTLINE1)\n          END\n      END\n/* CANCEL/DELETE.\n    IF &M = CD THEN +\n      DO\n        SET &SYSOUTTRAP = 2\n        CANCEL &JOB PURGE\n        SET &RC = &LASTCC\n        SET &SYSOUTTRAP = 0\n        IF &RC = 0 THEN +\n          DO\n            SET &LAST = &STR(CANCEL/DELETED)\n          END\n        ELSE +\n          DO\n            SET &MSGID = ISRP220\n            SET &ERRCMD = &STR(CAN/DEL)\n            SET &ERRMSG1= &STR(&SYSOUTLINE1)\n          END\n      END\n/* DELETE.\n    IF &M = D THEN +\n      DO\n        SET &SYSOUTTRAP = 2\n        CONTROL NOLIST NOCONLIST\n        OUTPUT &JOB &CLASS DELETE\n        SET &RC = &LASTCC\n        SET &SYSOUTTRAP = 0\n        IF &SYSOUTLINE = 0 THEN +\n          DO\n            SET &LAST = DELETED\n          END\n        ELSE +\n          DO\n            SET &MSGID = ISRP220\n            SET &ERRCMD = DELETE\n            SET &ERRMSG1= &STR(&SYSOUTLINE1)\n          END\n      END\n/* KEEP.\n    IF &M = K THEN +\n      DO\n        SET &Q1 = &LENGTH(&JOB)-10\n        SET &QUAL1 = &SUBSTR(1:&Q1,&JOB)\n        SET &Q1 = &LENGTH(&JOB)-7\n        SET &Q2 = &LENGTH(&JOB)\n        SET &Q3 = &STR(&Q1:&Q2,)\n        SET &QUAL2 = &SUBSTR(&Q3,&JOB)\n      /*WRITE QUAL1= &QUAL1, QUAL2= &QUAL2..\n        IF (&STR(&SYSUID) = &STR(&SYSPREF) OR +\n          &LENGTH(&SYSPREF) = 0) THEN +\n          SET &OUTDSN = &SYSUID..&QUAL1..&QUAL2..OUTLIST\n        ELSE +\n          SET &OUTDSN = &SYSPREF..&SYSUID..&QUAL1..&QUAL2..OUTLIST\n        SET &SYSOUTTRAP = 2\n        ALLOC DA('&OUTDSN') TRACKS RELEASE SPACE(200 100) CATALOG  +\n          BLKSIZE(3059) LRECL(133) DSORG(PS) RECFM(F B &ZR)\n        SET &RC = &LASTCC\n        SET &SYSOUTTRAP = 0\n        IF &RC = 0 THEN +\n          DO\n            SET &SYSOUTTRAP = 2\n            CONTROL NOLIST NOCONLIST\n            OUTPUT &JOB &CLASS PRINT('&OUTDSN') BEGIN\n            SET &SYSOUTTRAP = 0\n            IF &SYSOUTLINE = 0 THEN +\n              DO\n                ISPEXEC LMINIT DATAID(PRCDATA) DATASET('&OUTDSN')\n                ISPEXEC LMOPEN DATAID(&PRCDATA)\n                ISPEXEC LMGET  DATAID(&PRCDATA) MODE(LOCATE) +\n                      DATALOC(PRINTBUF) DATALEN(PRINTLEN) MAXLEN(32768)\n                SET &RC = &LASTCC\n                IF  &RC = 0 THEN +\n                  DO\n                    SET &LAST = KEPT\n                  END\n                ELSE +\n                  DO\n                    SET &MSGID = ISRU222\n                    SET &SYSOUTTRAP = 2\n                    DELETE '&OUTDSN'\n                    SET &SYSOUTTRAP = 0\n                  END\n                ISPEXEC LMFREE DATAID(&PRCDATA)\n                SET &SYSOUTTRAP = 2\n                FREE DA('&OUTDSN')\n                SET &SYSOUTTRAP = 0\n              END\n            ELSE +\n              DO\n                SET &MSGID = ISRP220\n                SET &ERRCMD = KEEP\n                SET &ERRMSG1 = &STR(&SYSOUTLINE1)\n                SET &SYSOUTTRAP = 2\n                DELETE '&OUTDSN'\n                SET &SYSOUTTRAP = 0\n              END\n          END\n        ELSE +\n          DO\n            SET &MSGID = ISRU220\n            SET &ERRCMD = KEEP\n            SET &ERRMSG1 = &STR(&SYSOUTLINE1)\n            SET &SYSOUTTRAP = 2\n            DELETE '&OUTDSN'\n            SET &SYSOUTTRAP = 0\n          END\n      END\n/* PRINT.\n    IF &M = P THEN +\n      DO\n        SET &SYSOUTTRAP = 2\n        FREE  F(&FILE)\n        ALLOC F(&FILE) TRACKS RELEASE SPACE(20 50) UNIT(VIO)NEW +\n          BLKSIZE(3059) LRECL(133) DSORG(PS) RECFM(F B &ZR)\n        SET &RC = &LASTCC\n        SET &SYSOUTTRAP = 0\n        IF &RC = 0 THEN +\n          DO\n            ISPEXEC SELECT PGM(PRCGTDSN) PARM(&FILE)\n            ISPEXEC VGET (OUTDSN OUTVOL)\n            SET &SYSOUTTRAP = 2\n            CONTROL NOLIST NOCONLIST\n            OUTPUT &JOB &CLASS PRINT('&OUTDSN') BEGIN KEEP HOLD\n            SET &SYSOUTTRAP = 0\n            IF &SYSOUTLINE = 0 THEN +\n              DO\n                ISPEXEC LMINIT DATAID(PRCDATA) DDNAME(&FILE)\n                ISPEXEC LMOPEN DATAID(&PRCDATA)\n                ISPEXEC LMGET  DATAID(&PRCDATA) MODE(LOCATE) +\n                      DATALOC(PRINTBUF) DATALEN(PRINTLEN) MAXLEN(32768)\n                SET &RC = &LASTCC\n                IF  &RC = 0 THEN +\n                  DO\n                    SET &SYSOUTTRAP = 15\n                    CONTROL NOLIST NOCONLIST\n                    PRINTO '&OUTDSN' NOHEADING\n                    SET &SYSOUTTRAP = 0\n                    SET &SYSDVAL = &STR(&SYSOUTLINE1)\n                    READDVAL &A &B\n                    IF &A = &STR(PROCESSING) THEN +\n                      DO\n                        SET &LAST = PRINTED\n                        SET &LASTJOB = &JOB\n                      END\n                    ELSE +\n                      DO\n                        SET &MSGID  = ISRP220\n                        SET &ERRCMD = PRINT\n                        SET &ERRMSG1= &STR(&SYSOUTLINE1)\n                      END\n                  END\n                ELSE +\n                  DO\n                    SET &MSGID = ISRU222\n                  END\n                ISPEXEC LMFREE DATAID(&PRCDATA)\n                SET &SYSOUTTRAP = 2\n                FREE F(&FILE)\n                SET &SYSOUTTRAP = 0\n              END\n            ELSE +\n              DO\n                SET &MSGID = ISRP220\n                SET &ERRCMD = PRINT\n                SET &ERRMSG1 = &STR(&SYSOUTLINE1)\n                SET &SYSOUTTRAP = 2\n                FREE F(&FILE)\n                SET &SYSOUTTRAP = 0\n              END\n          END\n        ELSE +\n          DO\n            SET &MSGID = ISRU220\n            SET &SYSOUTTRAP = 2\n            FREE F(&FILE)\n            SET &SYSOUTTRAP = 0\n          END\n      END\n/* REQUE.\n    IF &M = R THEN +\n      DO\n        SET &SYSOUTTRAP = 2\n        OUTPUT &JOB &CLASS NEWCLASS(&ZN)\n        SET &RC = &LASTCC\n        SET &SYSOUTTRAP = 0\n        IF &SYSOUTLINE = 0 THEN +\n          DO\n            SET &LAST = REQUED\n            SET &LASTJOB = &JOB\n          END\n        ELSE +\n          DO\n            SET &MSGID = ISRP220\n            SET &ERRCMD = REQUE\n            SET &ERRMSG1= &STR(&SYSOUTLINE1)\n          END\n      END\n/* UPDATE ENTRY FOR LAST ACTION.\n    ISPEXEC TBPUT MEMTABLE\n/* HANDLE MULTIPLE LINE SELECTIONS.\n    IF &DOZCMD \u00ac= YES THEN +\n      DO\n        ISPEXEC CONTROL DISPLAY RESTORE\n        IF &MSGID \u00ac= THEN SET &ZTDSELS = 0\n        IF &ZTDSELS > 1 THEN ISPEXEC TBDISPL MEMTABLE POSITION(ROW)\n        ELSE SET &ZTDSELS = 0\n      END\n    ELSE +\n      DO\n        SET &ZCMD =\n        SET &ZTDSELS = 0\n      END\n  END\n  /*WRITE ZCMD= &ZCMD, ROW= &ROW, LASTJOB = &LASTJOB..\n/* REFRESH ON COMMAND LINE.\n  IF &ZCMD = REF OR &ZCMD = REFRESH THEN +\n    DO\n      GOTO PRCUOL\n    END\n/* HANDLE LINE COMMANDS ON COMMAND LINE.\n  IF &ZCMD \u00ac= THEN +\n    IF &LASTJOB \u00ac=  THEN +\n      DO\n        SET &ZTDSELS = 1\n        SET &M = &ZCMD\n        SET &DOZCMD = YES\n        SET &JOB = &LASTJOB\n        ISPEXEC TBGET MEMTABLE\n        GOTO MAINLOOP\n      END\n    ELSE +\n      DO\n        SET &MSGID = ISRP226\n        SET &LASTJOB =\n        SET &ZTDSELS = 0\n      END\n/* DO A SCREEN REDISPLAY.\n  IF &MSGID = THEN +\n    DO\n      IF &DOZCMD \u00ac= YES THEN +\n        DO\n          IF &M = B OR &M = P THEN +\n            DO\n/* KEEP CURSOR ON SAME LINE FOR BROWSE OR PRINT.\n              SET &M =\n              ISPEXEC TBDISPL MEMTABLE CSRROW(&ROW)AUTOSEL(NO) +\n                POSITION(ROW)\n              SET &TBDRC = &LASTCC\n            END\n          ELSE +\n            DO\n/* PUT CURSOR ON COMMAND LINE FOR ANYTHING ELSE.\n              SET &M =\n              ISPEXEC TBDISPL MEMTABLE POSITION(ROW)\n              SET &TBDRC = &LASTCC\n            END\n        END\n      IF &DOZCMD = YES THEN +\n        DO\n          SET &M =\n          SET &DOZCMD =\n          DO\n/* MUST REDISPLAY PANEL IF A COMMAND LINE COMMAND PROCESSED.\n            ISPEXEC TBDISPL MEMTABLE PANEL(ISRUOLP)\n             SET &TBDRC = &LASTCC\n          END\n        END\n    END\n  ELSE +\n    DO\n      ISPEXEC TBDISPL MEMTABLE +\n        MSG(&MSGID) CSRROW(&ROW) AUTOSEL(YES) POSITION(ROW)\n      SET &TBDRC = &LASTCC\n    END\n  SET &MSGID =\n  SET &ERRCMD =\n  SET &ERRMSG1 =\nEND\nISPEXEC TBEND MEMTABLE\nENDPRC: +\nIF &SETPROF = &STR(YES) THEN PROFILE NOMSGID\nGOTO LOOP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISRUOLP": {"ttr": 5638, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\x12\\x00\\x12\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "FILE369"}, "text": ")ATTR\n _ TYPE(INPUT)  INTENS(HIGH) CAPS(ON)\n @ TYPE(OUTPUT) INTENS(LOW)\n # TYPE(OUTPUT) INTENS(HIGH)\n)BODY WIDTH(80)\n%SELECT JOB ---&TJNM------------------------------------------------------------\n%COMMAND ===>_ZCMD                                            %SCROLL ===>_ZUSC+\n+   JOBNAME              LAST             STATUS\n+%B+BROWSE %C+CANCEL %CD+CANCEL/DELETE %D+DELETE %K+KEEP %P+PRINT %R+REQUE\n+===============================================================================\n)MODEL\n_M @JOB                #LAST           @STATUS\n)INIT\n)REINIT\n)PROC\n VER (&M,LIST,B,C,CD,D,K,P,R,MSG=ISRP221)\n VER (&ZCMD,LIST,B,C,CD,D,K,P,R,REF,REFRESH,SORT,MSG=ISRP225)\n)END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ISTAUCAG": {"ttr": 5640, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\xb3\\x00\\xb3\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 179, "newlines": 179, "modlines": 0, "user": "FILE369"}, "text": "PRC      TITLE 'VTAM SESSION ACCOUNTING EXIT ROUTINE.'\n********************************************************************\n*                                                                  *\n* NAME - VTAM SESSION ACCOUNTING EXIT ROUTINE.                     *\n*                                                                  *\n* DESCRIPTION - THIS EXIT IS DOCUMENTED IN THE ACF/VTAM CUSTOM.    *\n*   MANUAL (SC27-0613).  WHAT WE DO IN THIS EXIT IS BANG OUT AN    *\n*   SMF RECORD (TYPE 240) THAT CONTAINS ALL RELEVANT INFORMATION   *\n*   PASSED TO US.  THIS INCLUDES PRIMARY AND SECONDARY LU NAMES.   *\n*   RECORD IS IN RELOCATE FORMAT (SECTIONS WITH A HEADER CONTAIN   *\n*   OFFSET, LENGTH, AND NUMBER).  PLEASE NOTE THAT THE RECORD IS   *\n*   IN A FORMAT COMPATIBLE WITH THE VECTORS THAT WILL BE OUTPUT    *\n*   BY THE VTAM SESSION MANAGEMENT EXIT ROUTINE WE WILL USE WHEN   *\n*   VTAM 2.2 IS IMPLEMENTED.                                       *\n*                                                                  *\n*                                                                  *\n* LEVEL - WE TESTED THIS EXIT WITH VTAM V2R1.  PLEASE NOTE THE USE *\n*   OF MODLEV BELOW THAT INDICATES MAINTENANCE LEVEL OF THIS MODULE*\n*   IN THE SMF RECORD.                                             *\n*                                                                  *\n* UPON ENTRY -                                                     *\n*  R0 = X'00000000' IF SESSION ESTABLISHMENT                       *\n*       X'FFFFFFFF' IF SESSION TERMINATION                         *\n*  R7 = A(PLU NAME).                                               *\n*  R11 = A(SLU NAME).                                              *\n*  NOTE THAT R15 IS IGNORED UPON RETURN.                           *\n*                                                                  *\n* LOG -                                                            *\n*     DATE   WHO LV    CHANGE                                      *\n*   11/21/85 PTW 01 IMPLEMENTATION                                 *\n*   06/XX/86 PTW 02 CHANGE STCK TO TIME MACRO FOR GMT, MISC.CHGS.  *L02\n*                                                                  *\n********************************************************************\n         LCLC  &CSECT\n&CSECT   SETC  'ISTAUCAG'\n&CSECT   CSECT ,\nRECTYPE  EQU   240                SMF RECORD NUMBER.\nRECSTYPE EQU   2                  SMF RECORD SUBTYPE.\nMODLEV   EQU   2                  THIS MODULE'S LEVEL.              L02\nVTAMLEV  EQU   21                 VTAM VERSION/RELEASE.             L02\n********************************************************************\n*                                                                  *\n*        I N I T I A L I Z E                                       *\n*                                                                  *\n********************************************************************\n         PRINT NOGEN\n         SAVE  (14,12),,&CSECT-&SYSDATE-&SYSTIME\n         LR    R12,R15            ESTABLISH BASE.\n         USING &CSECT,R12         TELL ASSEMBLER.\n         LR    R10,R0             R10 = A(PLIST).\n         GETMAIN RU,LV=DYNLEN     GET DYNAMIC AREA.\n         LR    R2,R13             SAVE AREA\n         LR    R13,R1             SAVE AREA\n         USING DYNAMIC,R13        TELL ASSEMBLER.\n         LA    R0,DYNAMIC         ZERO\n         LA    R1,DYNLEN            DYNAMIC\n         LR    R14,R0                 STORAGE.\n         SLR   R15,R15\n         MVCL  R0,R14             DO IT.\n         ST    R2,4(,R13)         BACK CHAIN.\n         ST    R13,8(,R2)         FORWARD CHAIN.\n         XC    RC,RC              ASSUME GOOD RC.\n********************************************************************\n*                                                                  *\n*        C R E A T E   S M F   R E C O R D                         *\n*                                                                  *\n********************************************************************\n         MVI   SM240RTY,RECTYPE   RECORD TYPE 240.\n         MVC   SM240TYP,=AL2(RECSTYPE) WE ARE SUBTYPE 2.\n         LA    R2,S2402DAT        R2 = (SMF POINTER).\n         MVC   S2402TRN,=AL2(S2402TR#) # TRPILETS.\n* CREATE SOFTWARE LEVEL SECTION OF SMF RECORD.\n         LA    R3,S2402REC        CALCULATE AND STORE OFFSET.\n         LR    R4,R2\n         SLR   R4,R3\n         ST    R4,S2402LVO\n         MVC   S2402LVL,=AL2(S2402LLN) MOVE LENGTH.\n         MVC   S2402LV#,=H'1'     ONLY 1 SECTION.\n         USING S2402LEV,R2        USE LEV MAPPING.\n         MVI   S2402LAM,S2402LAV  MOVE ACCESS METHOD.\n         MVI   S2402LVR,VTAMLEV   MOVE VERSION/RELEASE.\n         MVI   S2402LMD,MODLEV    OUR RECORD VERSION.\n         DROP  R2\n         LA    R2,S2402LLN(,R2)   BUMP SMF POINTER.\n* CREATE ACCOUNTING SECTION OF SMF RECORD.\n         LA    R3,S2402REC        CALCULATE AND STORE OFFSET.\n         LR    R4,R2\n         SLR   R4,R3\n         ST    R4,S2402ACO\n         MVC   S2402ACL,=AL2(S2402ALN) MOVE LENGTH.\n         MVC   S2402AC#,=H'1'     ONLY 1 SECTION.\n         USING S2402ACT,R2        USE ACCT MAPPING.\n         TIME  BIN                STORE TIME, DATE.                 L02\n         STM   R0,R1,S2402ATM\n         MVI   S2402ATY,S2402ATS  MOVE FUNCTION CODE.\n         LTR   R10,R10\n         BZ    *+8\n         MVI   S2402ATY,S2402ATE  MOVE FUNCTION CODE.\n         MVC   S2402APL,0(R7)     MOVE PRIMARY LUNAME.\n         MVC   S2402ASL,0(R11)    MOVE LUNAME.\n         MVC   S2402AMJ,=CL8' '\n         L     R3,PSAAOLD-P\n         L     R4,ASCBJBNS-A(,R3)\n         LTR   R4,R4\n         BZ    *+10\n         MVC   S2402AMJ,0(R4)     MOVE IN ACCESS METHOD JOBNAME.\n         MVC   S2402AAJ,=CL8' '   BLANK APPL JOBNAME.\n         DROP  R2\n         LA    R2,S2402ALN(,R2)   BUMP SMF POINTER.\n         LA    R3,SM240ULN\n         LR    R4,R2              CALCULATE L'USER SECTION.\n         SLR   R4,R3\n         STH   R4,SM240ULN        STORE L'USER SECTION IN SMF REC.\n         LA    R1,S2402REC        R1 = A(SMF RECORD).\n         SVC   226                CALL USER SVC ROUTINE.\n         LTR   R15,R15            WTO IF BAD RC.\n         BNZ   BADSVC\n********************************************************************\n*                                                                  *\n*        R E T U R N                                               *\n*                                                                  *\n********************************************************************\nRETURN   DS    0H\n         L     R2,RC               R2 = RC.\n         LR    R1,R13              PREPARE\n         L     R13,4(,R13)         FOR FREEMAIN.\n         FREEMAIN RU,LV=DYNLEN,A=(1)\n         LR    R15,R2              AND RETURN\n         RETURN (14,12),RC=(15)      WITH R15 = RC.\n********************************************************************\n*                                                                  *\n*        E R R O R S                                               *\n*                                                                  *\n********************************************************************\nBADSVC   DS    0H\n WTO 'ISTCAGI NON-ZERO RC FROM PRC SMF SVC - NO ACCT RECORD WRITTEN.'\n         MVC   RC,=F'12'\n         B     RETURN\n********************************************************************\n*                                                                  *\n*        S T A T I C   A R E A                                     *\n*                                                                  *\n********************************************************************\n         LTORG *\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   A R E A S                                 *\n*                                                                  *\n********************************************************************\nDYNAMIC  DSECT\nSAVE     DS    18F .\nRC       DS    F\n         PRINT GEN\nS2402REC SMF240 DSECT=NO,SUBTYPE=2     TYPE 240 RECORD.\nDYNLEN   EQU   *-DYNAMIC\n         PRINT NOGEN\n         IHAPSA\nP        EQU   PSA\n         IHAASCB\nA        EQU   ASCB\n         PRINT OFF\nR0       EQU   00\nR1       EQU   01\nR2       EQU   02\nR3       EQU   03\nR4       EQU   04\nR5       EQU   05\nR6       EQU   06\nR7       EQU   07\nR8       EQU   08\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11                 A(PLIST).\nR12      EQU   12                 PROGRAM BASE.\nR13      EQU   13                 A(SAVE AREA).\nR14      EQU   14\nR15      EQU   15\n         PRINT ON\n         END   &CSECT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JESXIT9": {"ttr": 5644, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x01o\\x01o\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 367, "newlines": 367, "modlines": 0, "user": "FILE369"}, "text": "PRC      TITLE 'JES2 EXIT9 - OUTPUT EXCEEDED EXIT.'\n********************************************************************\n*                                                                  *\n*   NAME - JESXIT9 - JES2 OUTPUT EXCEEDED EXIT.                    *\n*                                                                  *\n*   DESCRIPTION -                                                  *\n*     THIS IS THE OUTPUT EXCEEDED JES EXIT. OUR INSTALLATION DOES  *\n*     NOT BY DEFAULT CANCEL JOBS THAT EXCEED OUTPUT. THIS EXIT     *\n*     PROMPTS THE OPERATOR ABOUT EVERY 100,000 LINES EXCEEDED TO   *\n*     CANCEL THE JOB OR ALLOW THE JOB TO CONTINUE. THUS WE CAN     *\n*     PREVENT RUNAWAY JOBS FROM FILLING UP SPOOL SPACE.            *\n*                                                                  *\n*     AT PRESENT ALL BATCH WORK IS SUBJECT TO THIS EXIT.           *\n*     WE ONLY USE THIS EXIT FOR PRINT LINES EXCEEDED. WHEN WE      *\n*     HAVE EXCEEDED OUPUT BY ANOTHER 100,000 LINES, THE OPERATOR   *\n*     SEES NON-ROLLABLE MESSAGES SUCH AS THESE:                    *\n*                                                                  *\n*       *JOBNAME : ESTIMATED LINES EXCEEDED BY   100,000.          *\n*       *JOBNAME : CURR.LINES   114,012, EST.LINES    12,000.      *\n*       *JOBNAME : FILE S2      .SYSABEND, CURR.LINE     1,070.    *\n*       *47 JOBNAME : CANCEL JOB?  REPLY \"YES\" OR \"NO\".            *\n*                                                                  *\n*     NOTES:                                                       *\n*     1.THIS EXIT MAKES USE OF THE FACT THAT THE SDB ADDRESS       *\n*       IS PASSED IN R10, ALTHOUGH THIS IS NOT DOCUMENTED. IF      *\n*       THIS CHANGES, WE SHOULD BE ABLE TO GET THIS ADDRESS FROM   *\n*       AN RB SAVEAREA (R2 OF SVC111 -> DEB, DEBIRBAD -> SDB).     *\n*     2.IT WAS IMPORTANT TO US TO PREVENT DUMPS (SYSUDUMP, ETC.)   *\n*       FROM FILLING UP SPOOL SPACE. THE HASPAM MODULE THAT CALLS  *\n*       US MAKES A POINT OF IGNORING A ABEND722 REQUEST WHEN RTM2  *\n*       IS IN CONTROL, SO WE SCHEDULE AN ABEND722 FROM WITHIN      *\n*       THIS EXIT.                                                 *\n*     3.THIS EXIT WAS TESTED USING JES2 HJE2330 WITH HASPAM PTF    *\n*       LEVEL UZ40391. MY INFO/MVS DATABASE NOTES SOME PLANNED     *\n*       CHANGES IN HASPAM AND NEW BITS IN THE PARAMETER LIST.      *\n*       THESE CHANGES MAY AFFECT THE PROCESING OF THIS EXIT.       *\n*     4.THERE ARE A SOME FUNNY CALLS TO THIS EXIT I DIDN'T         *\n*       EXPECT. JOBLOG AND SYSMSGS DATASET WRITES                  *\n*       RUN THROUGH THIS EXIT EVEN AFTER THE JOBSTEP ABENDS        *\n*       (POSSIBLY UNDER THE INITIATOR TASK). JES2 IGNORES          *\n*       REQUESTS FROM THIS EXIT FOR THESE DATASETS. WE IGNORE THEM *\n*       BY TESTING SDB1FOPN. THERE ARE OCCASIONAL DUMMY CALLS TO   *\n*       CLOSE DATASETS. WE IGNORE THESE BY TESTING SDB1CLOS.       *\n*                                                                  *\n*   MACROS USED -                                                  *\n*     $MODULE,$ENTRY,SAVE,RETURN,GETMAIN,WTO,WTOR,WAIT,CALLRTM,    *\n*     DOM,FREEMAIN,$MODEND                                         *\n*                                                                  *\n*   INPUTS -                                                       *\n*     R0 = N/A                                                     *\n*     R1 = ADDRESS OF THE 7 WORD PARAMETER LIST                    *\n*       +0  JCTLINES OR JCTPUNCH VALUE                             *\n*       +4  JCTPAGES VALUE                                         *\n*       +8  JCTMXOUT VALUE                                         *\n*       +12 USER'S INCREMENT FOR RECORDS                           *\n*       +16 USER'S INCREMENT FOR PAGES                             *\n*       +20 USER'S INCREMENT FOR BYTES                             *\n*       +24 OUTPUT OVERFLOW FLAG                                   *\n*     R2-R6 = N/A                                                  *\n*     R7  = ADDRESS OF THE JCT                                     *\n*     R8-R10 = N/A                                                 *\n*     R11 = ADDRESS OF THE SSVT                                    *\n*     R12 = N/A                                                    *\n*     R13 = OS-STYLE 18-WORD SAVE AREA                             *\n*     R14 = RETURN ADDRESS                                         *\n*     R15 = ENTRY ADDRESS                                          *\n*                                                                  *\n*   OUTPUTS -                                                      *\n*     R0  = FLAGS                                                  *\n*       BIT 0 = 0 TAKE DEFAULT ACTION IN JESPARMS                  *\n*       BIT 0 = 1 TAKE ACTION BASED ON BITS 24-31                  *\n*       BIT 1 = 0 USE INCREMENT FROM JESPARMS                      *\n*       BIT 1 = 1 USE INCREMENT SUPPLIED BY EXIT IN PLIST          *\n*       BIT 2 = 0 SEND $HASP375 TO OPERATOR                        *\n*       BIT 2 = 1 SUPPRESS $HASP375                                *\n*       BIT 24-31 IF = 0, CONTINUE PROCESSING                      *\n*                 IF = 1, ABEND722, NO DUMP                        *\n*                 IF = 2, ABEND722, DUMP                           *\n*                                                                  *\n*     R15 = A RETURN CODE                                          *\n*       0 = TAKE ADD'L EXITS, OR TAKE DEFAULT ACTIONS IN JESPARMS  *\n*       4 = IGNORE ADD'L EXITS, TAKE DEFAULT ACTIONS IN JESPARMS   *\n*       8 = TAKE ACTION BASED ON FLAGS IN R0                       *\n*                                                                  *\n*   INSTALLATION NOTES -                                           *\n*     INCLUDE THE FOLLOWING IN YOUR JES PARMLIB:                   *\n*       LOAD     JESXIT9                                           *\n*       EXIT009  ROUTINE=(EXIT9)                                   *\n*     THIS MODULE MUST BE PLACED INTO SYS1.LPALIB OR INCLUDED      *\n*     AS AN 'MLPA' OR 'FLPA' IN COMMON STORAGE, ELSE A S0C4 WILL   *\n*     RESULT.                                                      *\n*                                                                  *\n*   CHANGE LOG -                                                   *\n*     05/12/87 PTW L01 IMPLEMENTATION                              *\n*     10/15/87 PTW L02 FORMAT SDBFLGX IN WTO MESSAGES (TEMP).      *L02\n*     12/07/87 PTW L03 JES2 2.1.5                                  *L03\n*                                                                  *\n********************************************************************\n*        COPY  $HASPGBL\n         PRINT  OFF\n         COPY  $HASPGBL\n         PRINT ON\nJESXIT9 $MODULE SYSP=(NOGEN,NOGEN,NODATA,NOGEN,NOGEN),                 X\n               ENVIRON=USER,                                           X\n               TITLE='JES2 EXIT9 - JES2 OUTPUT EXCEEDED EXIT',         X\n               $BUFFER,            GENERATE HASP BUFFER DSECT          X\n               $HASPEQU,           GENERATE HASP EQUATES               X\n               $JCT,               GENERATE HASP JCT DSECT             X\n               $MIT,               GENERATE HASP MIT DSECT             X\n               $SCAT,              GENERATE HASP SCAT DSECT            X\n               $SDB,               GENERATE HASP SCAT DSECT            X\n               $SVT,               GENERATE HASP SVT DSECT             X\n               $TAB,               GENERATE HASP SVT DSECT             X\n               $XECB,              GENERATE HASP XECB DSECT            X\n               ASCB,               GENERATE HASP MIT DSECT             X\n               CVT,                GENERATE HASP MIT DSECT             X\n               PSA,                GENERATE HASP MIT DSECT             X\n               RPL,                GENERATE HASP MIT DSECT          L02X\n               TCB,                GENERATE HASP MIT DSECT             X\n               TIOT                GENERATE HASP MIT DSECT\n         TITLE 'JES2 EXIT9 - JES2 OUTPUT EXCEEDED EXIT'            L02\n***********************************************************************\n*                                                                     *\n*        M A I N   E N T R Y   P O I N T                              *\n*                                                                     *\n***********************************************************************\nEXIT9   $ENTRY BASE=R12\n         SAVE  (14,12)\n         LR    R12,R15            R12 = BASE REG.\n         SR    R15,R15            SET DEFAULT RC.\n         USING PLIST,R1           R1 = A(PLIST).\n         TM    PFLAGS,X'40'       IF NOT ENTERED FOR PRINT LINES,\n         BZ    QWIKEXIT             GET OUT.\n         USING JCT,R7             R7 = A(JCT).                      L02\n         USING SDB,R10            R10 = A(SDB).                     L02\n         USING SVT,R11            R11 = A(SSVT).                    L02\n         TM    SDBFLG1,SDB1FOPN   IF A FAKE-OPENED DS (JLOG,JMSGS,\n         BO    QWIKEXIT             JCLIMAGE), OUT (RC IGNORED).\n         TM    SDBFLG1,SDB1CLOS   FOR DUMMY CLOSE CALL,\n         BZ    NOTCLOS\n         L     R2,PSATOLD-PSA     IF RTM2 IN CONTROL (SYSUDUMP, ETC.),\n         TM    TCBFBYT1-TCB(R2),TCBRTM2\n         BO    QWIKRTM              NO SPURIOUS $HASP375.\nNOTCLOS  DS    0H\n         SLR   R2,R2              IF REMAINDER OF\n         L     R3,PLINES           (CURR.LINES-EST.LINES)/LIMIT\n         S     R3,JCTESTLN          IS < DEF.INCREMENT,\n         D     R2,=A(LIMIT)         THEN WE PROMPT OPERATOR.\n         LTR   R3,R3\n         BZ    QWIKEXIT\n         CL    R2,SVTLNINT                                          L02\n         BL    GOTONE\nQWIKEXIT DS    0H\n         RETURN (14,12),RC=(15)   ELSE WE RETURN.\nQWIKRTM  DS    0H\n         MVC   20(4,R13),=X'A0000000' ELIMINATE SPURIOUS $HASP375.\n         LA    R15,8\n         B     QWIKEXIT\nGOTONE   DS    0H\n         LR    R9,R1              R9 = A(PLIST).\n         USING PLIST,R9\n         GETMAIN RU,LV=DYNLEN,SP=230 DYNAMIC AREA, LSQA.\n         LR    R2,R13             SAVE AREA STUFF.\n         LR    R13,R1\n         USING DYNAMIC,R13\n         LA    R0,DYNAMIC         ZERO\n         L     R1,=A(DYNLEN)        DYNAMIC\n         LR    R14,R0                 STORAGE.\n         SLR   R15,R15\n         MVCL  R0,R14             DO IT.\n         ST    R2,4(,R13)         BACK CHAIN.\n         ST    R13,8(,R2)         FORWARD CHAIN.\n         XC    RC,RC              ASSUME GOOD RC.\n         MVI   MSGAREA,C' '       FORMAT LINES EXCEEDED MSG.\n         MVC   MSGAREA+1(L'MSGAREA-1),MSGAREA\n         MVC   MSGTEXT(L'MSGLINE1),MSGLINE1\n         MVC   MSGJOB,JCTJNAME    JOBNAME.\n         MVI   MSGCOLON,C':'\n         MVC   MSGEXC,EDITLINE\n         SLR   R2,R2              GET LINES EXCEEDED\n         L     R3,PLINES            IN MULTIPLES OF LIMIT.\n         S     R3,JCTESTLN\n         D     R2,=A(LIMIT)\n         SLR   R2,R2\n         M     R2,=A(LIMIT)\n         CVD   R3,DOUBLE\n         ED    MSGEXC,DOUBLE+4\n         MVC   WTO(WTOLEN),XWTO\n         MVC   WTOMSG(L'MSGAREA),MSGAREA\n         WTO   MF=(E,WTO)         WTO MSG.\n         ST    R1,MSGID           SAVE DOMID.\n         MVI   MSGAREA,C' '       FORMAT CURR.LINES MSG.\n         MVC   MSGAREA+1(L'MSGAREA-1),MSGAREA\n         MVC   MSGTEXT(L'MSGLINE2),MSGLINE2\n         MVC   MSGJOB,JCTJNAME    JOBNAME.\n         MVI   MSGCOLON,C':'\n         MVC   MSGCURR,EDITLINE\n         L     R2,PLINES          FORMAT CURR.LINES.\n         CVD   R2,DOUBLE\n         ED    MSGCURR,DOUBLE+4\n         MVC   MSGEST,EDITLINE\n         L     R2,JCTESTLN        FORMAT EST.LINES.\n         CVD   R2,DOUBLE\n         ED    MSGEST,DOUBLE+4\n         MVC   WTO(WTOLEN),XWTO\n         MVC   WTOMSG(L'MSGAREA),MSGAREA\n         WTO   MF=(E,WTO)         WTO MSG.\n         ST    R1,MSGID+4         SAVE DOMID.\n         MVI   MSGAREA,C' '       FORMAT FILE AND CURR.LINE MSG.\n         MVC   MSGAREA+1(L'MSGAREA-1),MSGAREA\n         MVC   MSGTEXT(L'MSGLINE3),MSGLINE3\n         MVC   MSGJOB,JCTJNAME    JOBNAME.\n         MVI   MSGCOLON,C':'\n* TRACE INSTRUCTIONS - FORMAT SDB FLAGS IN WTO TEXT FOR TESTING.    L02\n         LA    R2,=C'0123456789ABCDEF'                              L02\n         SLR   R1,R1                                                L02\n         IC    R1,SDBFLG1                                           L02\n         SRL   R1,4                                                 L02\n         IC    R1,0(R1,R2)                                          L02\n         STC   R1,MSGTEXT                                           L02\n         IC    R1,SDBFLG1                                           L02\n         N     R1,=X'0000000F'                                      L02\n         IC    R1,0(R1,R2)                                          L02\n         STC   R1,MSGTEXT+1                                         L02\n         IC    R1,SDBFLG2                                           L02\n         SRL   R1,4                                                 L02\n         IC    R1,0(R1,R2)                                          L02\n         STC   R1,MSGTEXT+2                                         L02\n         IC    R1,SDBFLG2                                           L02\n         N     R1,=X'0000000F'                                      L02\n         IC    R1,0(R1,R2)                                          L02\n         STC   R1,MSGTEXT+3                                         L02\n         L     R2,PSATOLD-PSA     GET STEPNAME FROM TIOT.\n         L     R2,TCBTIO-TCB(,R2)\n         USING TIOT,R2\n         MVC   MSGSTEP,TIOCSTEP+8\n         CLI   TIOCSTEP+8,C' '\n         BNE   ENDTIOT\n         MVC   MSGSTEP,TIOCSTEP\n         DROP  R2\nENDTIOT  DS    0H\n         MVC   MSGFILE,SDBDDNM    GET DDNAME FROM SDB.\n         MVC   MSGFCURR,EDITLINE\n         L     R2,SDBRECCT        FORMAT CURR.LINE.\n         CVD   R2,DOUBLE\n         ED    MSGFCURR,DOUBLE+4\n         MVC   WTO(WTOLEN),XWTO\n         MVC   WTOMSG(L'MSGAREA),MSGAREA\n         WTO   MF=(E,WTO)         WTO MSG.\n         ST    R1,MSGID+8         SAVE DOMID.\n         MVI   MSGAREA,C' '       FORMAT WTOR MSG.\n         MVC   MSGAREA+1(L'MSGAREA-1),MSGAREA\n         MVC   MSGTEXT(L'MSGLINE4),MSGLINE4\n         MVC   MSGJOB,JCTJNAME    JOBNAME.\n         MVI   MSGCOLON,C':'\n         MVC   WTOR(WTORLEN),XWTOR\n         MVC   WTORMSG(L'MSGAREA),MSGAREA\nWTORLOOP DS    0H\n         MVC   REPLY,=CL3' '      INIT REPLY.\n         XC    ECB,ECB            ZERO WTOR ECB.\n         WTOR  ,REPLY,L'REPLY,ECB,MF=(E,WTOR) WTOR MSG.\n         WAIT  ECB=ECB            WAIT FOR RESPONSE.\n         CLC   =C'YES',REPLY      WE WANT UPPER OR LOWERCASE \"YES\".\n         BE    KILLJOB            IF EITHER, ABEND722.\n         CLC   =X'A885A2',REPLY\n         BE    KILLJOB\n         CLC   =C'NO',REPLY       WE WANT UPPER OR LOWERCASE \"NO\".\n         BE    OKJOB              IF EITHER, ALLOW JOB TO CONTINUE.\n         CLC   =X'9596',REPLY     ELSE, REPROMPT.\n         BNE   WTORLOOP\nOKJOB    DS    0H\n         L     R2,4(,R13)\n         MVC   20(4,R2),=X'80000000'   CONTINUE.\n         MVC   RC,=F'8'\nRETURN   DS    0H\n         BAL   R5,CLEANUP         DO DOMS, FREEMAIN, ETC.\n         RETURN (14,12),RC=(15)      WITH R15 = RC.\nKILLJOB  DS    0H\n         L     R2,PSATOLD-PSA     IF RMT2 IN CONTROL, NEED TO ISSUE\n         TM    TCBFBYT1-TCB(R2),TCBRTM2\n         BO    CALLRTM              OUR OWN CALLRTM (JES IGNORES).\n         L     R2,4(,R13)         ELSE,\n         MVC   20(4,R2),=X'A0000001'   ABEND722, NO DUMP.\n         MVC   RC,=F'8'\n         B     RETURN\nCALLRTM  DS    0H\n         BAL   R5,CLEANUP         DO DOMS, FREEMAIN, ETC.\n         L     R2,PSAAOLD-PSA\n         LH    R2,ASCBASID-ASCB(,R2) R2 = ASID.\n         L     R3,PSATOLD-PSA\n         L     R3,TCBJSTCB-TCB(,R3) R3 = A(JSTCB).\n         LA    R13,SDBSAVE        R13 = RMT SAVEAREA.\n         CALLRTM TYPE=ABTERM,COMPCOD=X'722',ASID=(2),TCB=(3),DUMP=NO\n         MVI   SDBSAVE,0          WAIT FOREVER FOR RTM TO KILL STEP.\n         WAIT  1,ECB=SDBSAVE\nCLEANUP  DS    0H\n         LA    R3,MSGID#          LOOP TO DO DOMS.\n         SLR   R2,R2\nDOMLOOP  DS    0H                 DELETE ALL NON-ROLLABLE MSGS.\n         L     R1,MSGID(R2)\n         DOM   MSG=(1)\n         LA    R2,4(,R2)\n         BCT   R3,DOMLOOP\n         L     R2,RC\n         LR    R1,R13              PREPARE\n         L     R13,4(,R13)         FOR FREEMAIN.\n         FREEMAIN RU,LV=DYNLEN,A=(1),SP=230\n         LR    R15,R2             R15 = RC.\n         BR    R5\n********************************************************************\n*                                                                  *\n*        S T A T I C   A R E A S.                                  *\n*                                                                  *\n********************************************************************\nXWTO     WTO   '                                                       X\n                                            ',ROUTCDE=2,DESC=2,MF=L\nWTOLEN   EQU   *-XWTO\nXWTOR    WTOR  '                                                       X\n                                            ',ROUTCDE=2,DESC=6,MF=L\nWTORLEN  EQU   *-XWTOR\nMSGLINE1 DC    C'ESTIMATED LINES EXCEEDED BY N,NNN,NNN.'\nMSGLINE2 DC    C'CURR.LINES N,NNN,NNN, EST.LINES N,NNN,NNN.'\nMSGLINE3 DC    C'FILE SSSSSSSS.DDDDDDDD, CURR.LINE N,NNN,NNN.'\nMSGLINE4 DC    C'CANCEL JOB?  REPLY \"YES\" OR \"NO\".'\nEDITLINE DC    X'40206B2020206B202120'\n         LTORG *\nSRCLEVEL DC    C'                                        '\n        $MODEND\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   A R E A S.                                *\n*                                                                  *\n********************************************************************\nDYNAMIC  DSECT\nSAVE     DS    18F                SAVE AREA.\nDOUBLE   DS    D                  WORK AREA.\nRC       DS    F                  RETURN CODE.\nECB      DS    A                  WTOR ECB.\nMSGID    DS    3F                 DOM MSGIDS.\nMSGID#   EQU   3\nWTO      DS    0F,CL(WTOLEN)      WTO AREA.\nWTOMSG   EQU   WTO+4,80           MSGTEXT.\nWTOR     DS    0F,CL(WTORLEN)     WTOR AREA.\nWTORMSG  EQU   WTOR+12,80         MSGTEXT.\nMSGAREA  DS    CL80               MSG WORK AREA.\nMSGJOB   EQU   MSGAREA+0,8        JOBNAME.\nMSGCOLON EQU   MSGAREA+8,1        :.\nMSGTEXT  EQU   MSGAREA+10,70      TEXT.\nMSGEXC   EQU   MSGTEXT+27,10      LINES EXCEEDED.\nMSGCURR  EQU   MSGTEXT+10,10      CURRENT LINES.\nMSGEST   EQU   MSGTEXT+31,10      ESTIMATED LINES.\nMSGSTEP  EQU   MSGTEXT+5,8        STEPNAME.\nMSGFILE  EQU   MSGTEXT+14,8       DDNAME.\nMSGFCURR EQU   MSGTEXT+33,10      DD LINE.\nREPLY    DS    CL3                3 CHARACTER REPLY.\nDYNLEN   EQU   *-DYNAMIC          LENGTH.\n*\nPLIST    DSECT                    PARAMETER LIST.\nPLINES   DS    F                  CURRENT LINES.\nPPAGES   DS    F                  CURRENT PAGES.\nPMXOUT   DS    F                  CURRENT BYTES.\nPRECINC  DS    F                  USER LINE INCREMENT.\nLIMIT    EQU   100000             PROMPT EVERY 100,000 LINES OVER.\nPPAGINC  DS    F                  USER PAGE INCREMENT.\nPBYTINC  DS    F                  USER BYTE INCREMENT.\nPFLAGS   DS    F                  FLAGS.\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LM00501": {"ttr": 5894, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\x10\\x00\\x10\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "FILE369"}, "text": "++ USERMOD (LM00501) .\n++ VER (Z038) FMID(HBB2102) /*\n   LM00501   ZAP FCB28 TO BE NON-STANDARD.\n   NOTE: JES2 WILL ONLY RELOAD THE 3211 FCB WITH A STANDARD FCB,\n         I.E. 8-LPI IF THE CURRENT LOAD IS MARKED NON-STANDARD.\n         THIS MEANS, A JOB THAT DOESN'T SPECIFY A FCB WILL PRINT\n         AT THE DENSITY OF THE PRECEEDING DATASET, WHATEVER IT\n         MAY BE.  THE SOLOUTION IS TO LEAVE ONLY THE 6-LPI FCB\n         MARKED STANDARD. -- DICK SZIEDE CSC 1981.\n         .\n         REFIT FOR XA...DICK SZIEDE PRC 1985.\n   */ .\n++ ZAP (IASFCB28).\n NAME  FCB28\n VER 0000 80598111\n REP 0000 00\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LM01603": {"ttr": 5896, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x01\\x03\\x01\\x03\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 259, "newlines": 259, "modlines": 0, "user": "FILE369"}, "text": "         TITLE 'LM01603 -- IO COUNTS IN DEALLOCATION MESSAGES'\n*-------\n*------- TITLE LM01603...I/O COUNT IN MSGS IEF283I, IEF285I, IEF287I\n*-------\n*------- AUTHOR LARRY KRAUSE...LITTON COMPUTER SERVICES 1978\n*-------\n*------- BACKGROUND AS FAR AS I KNOW, LARRY IS THE ONLY ONE TO\n*-------       WRITE A MVS VERSION  OF THIS MOD,  ALTHOUGH IT\n*-------       COMMON IN MVT (RICK  DUVALL...CSC) AND SVS (AUTHOR\n*-------       UNKNOWN).  THIS VERSION HAS BEEN RECODED IN ASMTOZAP\n*-------       FORMAT FOR MVS SP1.3, WITH SOME COSMETIC CHANGES.\n*-------       DICK SZIEDE...CSC 1982.\n*------- UPDATED FOR XA.\n*-------       IEFAB4B0 AT JBB2110, IEFAB4A2 AT JBB2125.\n*-------       MORE COSMETIC CHANGES AND INCREASE THE NUMBER\n*-------       OF COUNT DIGITS. REMOVED CHECK FOR MSGID TO\n*-------       ENABLE IEF283I AND IEF287I.\n*-------       ADDED LOOP TO SUM UP COUNTS WHEN MULTIPLE UNITS\n*-------       ARE ALLOCATED.\n*-------       ENHANCED TO SHOW COUNTS FOR VIO DATASETS.\n*-------       CHARLIE PITTS - PRC, DULLES AIRPORT - 1985\n*------- UPDATED FOR DFP2.\n*-------       IEFAB4B0 AT JBB2110, IEFAB4A2 AT UZ84611.\n*-------       CORRECTED S0C4 WHEN DEALLOC IS FROM MSTR (JSCBTCBP\n*-------       OF ZERO). ADDED OTHER CHECKS FOR ZERO POINTERS.\n*-------       CHARLIE PITTS - PRC, DULLES AIRPORT - 1988\n*-------\n*-------\n*-------\n         SPACE 2\n*ZAP     CARD ++ USERMOD(LM01603)          /* IO COUNTS IN IEF283I,\n*ZAP     CARD                                 IEF285I, AND IEF287I\n*ZAP     CARD                                 ASM-TO-ZAP SOURCE FROM\n*ZAP     CARD                                 SYSA.USERMOD.ASM.     */.\n*ZAP     CARD ++ VER(Z038) FMID(JBB2110) SUP(LM01602) .\n*ZAP     CARD ++ ZAP (IEFAB4B0).\n*ZAP     CARD    NAME IEFAB4B0\n*ZAP     CARD  EXPAND IEFAB4B0(188)\n         SPACE 2\n*               EQUATES FOR LOCATIONS WITHIN IEFAB4B0\n         SPACE\n@PSTART  EQU   IEFAB4B0+X'22'\nCLRKEY   EQU   IEFAB4B0+X'66'\nCLRTXT   EQU   IEFAB4B0+X'8A'\nSTEAL    EQU   IEFAB4B0+X'16A'\n@EL00001 EQU   IEFAB4B0+X'300'\n@SIZDATD EQU   IEFAB4B0+X'44C'\nPATCH    EQU   IEFAB4B0+X'4C8'\n         SPACE\n*              AND OF COURSE, THE REGISTERS\n         SPACE\n@01      EQU   01\n@02      EQU   02\n@04      EQU   04\n@05      EQU   05\n@06      EQU   06\n@10      EQU   10\n@11      EQU   11\n@12      EQU   12\n@13      EQU   13\n         EJECT\nIEFAB4B0 CSECT\n         PRINT ON,GEN,DATA\n         SPACE\nIEFAB4B0 AMODE 31\nIEFAB4B0 RMODE ANY\n         SPACE 2\n         ORG   @PSTART\n         USING @PSTART,@12\n         USING @DATD,@11\n         SPACE\n*ZAP     START VER\n         SPACE\n         ORG   CLRKEY\n         STC   @02,@OLDKEY\n         SPACE\n         ORG   CLRTXT\n         MVC   MSGBUFFR+1(L'MSGBUFFR-1),MSGBUFFR  BLANK ENTIRE BUFFER\n         SPACE\n         ORG   STEAL\n         MVI   MSGDISP+1,C' '      DISPLACED INSTRUCTION\n         MVC   MSGDISP+2(L'MSGDISP-2),MSGDISP+1 CLEAR DISP FIELD\n         SPACE\n         ORG   @EL00001\n         IC    @02,@OLDKEY\n         SPACE\n         ORG   @SIZDATD\n         DC    AL1(230),AL3(@ENDATD-@DATD)\n         SPACE\n         ORG   PATCH\n         DC    (PATCHLEN)X'00'\n         EJECT\n*ZAP     START REP\n         SPACE\n         ORG   CLRKEY\n         STC   @02,@NEWKEY\n         SPACE\n         ORG   CLRTXT\n         MVC   MSGBUFFR+1(NEWBUFLN-1),MSGBUFFR BLANK IT\n         SPACE\n         ORG   STEAL\n         B     PATCHOUT\nMAINLINE DS    0H\n         MVC   MSGDISP+2(L'MSGDISP-3),MSGDISP+1 ONE BYTE LESS\n         SPACE\n         ORG   @EL00001\n         IC    @02,@NEWKEY\n         SPACE\n         ORG   @SIZDATD\n         DC    AL1(230),AL3(@NEWDATD-@DATD)\n         SPACE\n         ORG   PATCH\nPATCHOUT DS    0H\n         MVI   MSGLNGTH+3,NEWBUFLN  SET NEW LENGTH\n         USING SAVEAREA,@13\n         L     @10,SVHSA            ADDRESS OF IEFAB4A2'S SAVE AREA\n         USING SAVEAREA,@10\n         DROP  @13\n         L     @10,SVREG10          IEFAB4A2'S R10\n         USING #DATD,@10            IEFAB4A2'S WORKAREA\n         ICM   @10,B'1111',DSABPTR  ADDRESS OF DSAB\n         BZ    PATCHXIT             EXIT IF NO DSAB\n         USING DSAB,@10\n         SPACE\n         ICM   @10,B'1111',DSABTIOT ADDRESS OF TIOT ENTRY\n         BZ    PATCHXIT             EXIT IF NOT THERE\n         USING TIOELNGH,@10\n         SPACE\n         ICM   @01,B'1111',PJSCBPTR ADDRESS OF JSCB POINTER\n         BZ    PATCHXIT             EXIT IF NOT THERE\n         ICM   @01,B'1111',0(@01)   ADDRESS OF JSCB\n         BZ    PATCHXIT             EXIT IF NOT THERE\n         USING IEZJSCB,@01\n         SPACE\n         ICM   @05,B'1111',JSCBTCBP ADDRESS OF INIT'S TCB\n         BZ    PATCHXIT             EXIT IF NOT THERE\n         USING TCB,@05\n         SPACE\n         ICM   @01,B'1111',JSCTMCOR ADDRESS OF TIOT MGMT AREA\n         BZ    PATCHXIT             EXIT IF NOT THERE\n         USING TIOPREFX,@01\n         S     @10,TIOTPTR          CALC TIOT ENTRY OFFSET\n         DROP  @10\n         SPACE\n         XR    @04,@04              INSURE CLEAR HI-PART OF ADDRESS\n         ICM   @04,B'0111',TCBTCTB  ADDRESS OF TIMING CONTROL TABLE\n         USING SMFTCT,@04\n         BZ    PATCHXIT             EXIT IF NONE\n         SPACE\n         L     @04,TCTIOTBL         ADDRESS OF TCT I/O TABLE\n         USING TCTTIOT,@04\n         LA    @05,TCTDCBTD         ADDRESS OF 1ST DD LOOKUP TABLE ENT\n         USING TCTIODSP,@05\n         SPACE\n         XR    @06,@06              CLEAR WORK REGISTER\n         SPACE\nPATCHDDL DS    0H\n         C     @10,TCTDCBTD         DO THE TIOT DISPLACEMENTS MATCH?\n         BE    PATCHGOT                  YES ==> PRINT I/O COUNT.\n         C     @06,TCTDCBTD         LAST ENTRY IS ZERO\n         BE    PATCHXIT                  EXIT IF ZERO.\n         LA    @05,TCTDCBLE         BUMP TO NEXT DD TABLE ENTRY\n         B     PATCHDDL\n         SPACE\nPATCHGOT DS    0H\n         A     @04,TCTIOTSD         OFFSET TO THE DEVICE ENTRY\n         USING TCTDDENT,@04\n         DROP  @05\n         SPACE\n         C     @06,TCTUCBP          UCB ADDRESS EXIST?\n         BNE   PATCHPRT             YEP...ONWARD TO COUNTS\n         TM    TCTFLGS,TCTVAMDS     VIO DATASET? (NO UCB)\n         BNO   PATCHXIT             NOPE...SYSIN/SYSOUT/TERM=TS ETC\nPATCHPRT DS    0H\n         SPACE\n         XR    @05,@05              CLEAR LOOP COUNTER\n         XR    @06,@06              CLEAR ACCUMULATOR\n         IC    @05,TCTSCTR          UCB COUNT\n         SPACE\nPATCHADD DS    0H\n         A     @06,TCTDCTR          ADD IO COUNT\n         LA    @04,TCTDDLEN(,@04)   NEXT UCB ENTRY\n         BCT   @05,PATCHADD         LOOP\n         SPACE\n         CVD   @06,MSGDISP+1        INTO PACKED FORMAT\n         MVC   MSGCOUNT,EDITMASK    PREPARE TO EDIT\n         ED    MSGCOUNT,MSGDISP+4   STICK IN SOME COMMAS\n         MVI   MSGCOUNT,C'*'        MARK WITH A SPLAT\n         SPACE\nPATCHXIT DS    0H\n         MVI   MSGDISP+1,C' '       DISPLACED INSTRUCTION\n         SPACE\n         B     MAINLINE\n         SPACE\n*                - N N N , N N N , N N N\n         SPACE\nEDITMASK DC    X'602020206B2020206B202120'\n         SPACE\nPATCHEND DS    0H\nPATCHLEN EQU   PATCHEND-PATCHOUT\n         SPACE\n*ZAP     END\n         EJECT\n@DATD    DSECT ,                    IEFAB4B0 WORKAREA\n         DS    XL(X'48')\n@PC00001 DS    5F                   PARAMETER LIST PASSED TO IEFAB4B0\n         ORG   @PC00001\nPMSGDATA DS    A\nPVSLPTR  DS    A\nPDSNPTR  DS    A\nPERRCOD  DS    A\nPJSCBPTR DS    A\n         DS    XL(X'58')\nMSGLNGTH DS    F\n         DS    2F\nMSGBUFFR DS    CL74\nMSGDISP  EQU   MSGBUFFR+55,13,C'C'\n@OLDKEY  DS    AL1\n         DS    XL5\n@ENDATD  EQU   *                   END OF ORIGINAL IEFAB4B0 WORKAREA\n         SPACE\n         ORG   MSGDISP+L'MSGDISP-1 TRYING TO KEEP THE COUNT WITHIN THE -\n                                   AREA VISABLE UNDER ISPF BROWSE\nMSGCOUNT DS    CL(L'EDITMASK)      NEW FIELD FOR COUNT\nNEWBUFLN EQU   *-MSGBUFFR          NEW BUFFER LENGTH\n@NEWKEY  DS    AL1                 REPLACEMENT FOR DISPLACED FIELD\n         DS    0D                  ALIGN TO DOUBLEWORD FOR GETMAIN\n@NEWDATD EQU   *\n         SPACE 2\n#DATD    DSECT ,                   IEFAB4A2 WORKAREA\n         DS    XL(X'138')\nDSABPTR  DS    A\n         SPACE 2\nMSGDATA  DSECT ,                   MSGDATA PARAMETER\nMSGID    DS    X                   INDEX INTO MSGID TABLE\nMSGFLAGS DS    X                   MESSAGE PROCESSING FLAGS\nDISPID   DS    X                   INDEX INTO DISPID TABLE\n         EJECT\nSAVEAREA DSECT ,                   STANDARD OS SAVEAREA\nSVWORD1  DS    A\nSVHSA    DS    A                   HIGHER SAVE AREA\nSVLSA    DS    A                   LOWER SAVE AREA\n         DS    12A                 REGS 14-15,0-9\nSVREG10  DS    A\n         DS    2A                  REGS 11-12\n         SPACE 2\nTIOPREFX DSECT ,                   TIOT PREFIX (SEE IEFAB4FC)\n         DS    XL(X'18')\nTIOTPTR  DS    A                   ADDRESS OF TIOT\n         SPACE 2\n         PRINT NOGEN,NODATA\n         IHADSAB  ,                DASB\n         IEZJSCB  ,                JSCB\n         IKJTCB   ,                TCB\nTIOT     DSECT    ,                TIOT\n         IEFTIOT1 ,                TIOT\n         IEFTCT   ,                TCT\n         SPACE 3\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LM023ASM": {"ttr": 5901, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00 \\x00 \\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "FILE369"}, "text": "//TST2ASM$ JOB ,'TECH-S.GOLOB',CLASS=M,NOTIFY=TST2SSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//*******************************************************************\n//*\n//*******************************************************************\n//ASMVC   PROC MAC='SYS1.MACLIB',MAC1='SYS1.MACLIB',\n//        MEMBER=\n//*\n//* DOC: THIS PROCEDURE EXECUTES THE ASSEMBLER AND THE LINKAGE EDITOR.\n//*\n//ASM     EXEC PGM=ASMBLR,PARM=OBJ,REGION=2048K\n//STEPLIB  DD  DISP=SHR,DSN=TST2SSG.LOAD\n//SYSLIB   DD  DSN=&MAC,DISP=SHR\n//         DD  DSN=&MAC1,DISP=SHR\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=3380,SPACE=(1700,(600,600))\n//SYSUT2   DD  DSN=&&SYSUT2,UNIT=3380,SPACE=(1700,(300,300))\n//SYSUT3   DD  DSN=&&SYSUT3,UNIT=3380,SPACE=(1700,(300,300))\n//SYSPRINT DD  SYSOUT=*,DCB=BLKSIZE=1089\n//SYSPUNCH DD  DUMMY\n//SYSLIN   DD  DUMMY,\n//             DCB=(BLKSIZE=3120,LRECL=80,RECFM=FBS,BUFNO=1)\n//*YSGO    DD  DSN=&&OBJSET,UNIT=3380,SPACE=(80,(200,300)),\n//*            DISP=(MOD,PASS)\n//SYSIN    DD  DSN=&&TEMP(&MEMBER),DISP=(OLD,PASS)\n//*\n//  PEND\n//******************************************************************\n//S02ASM  EXEC ASMVC\n//SYSLIB DD DSN=TSY2.MACLIB,DISP=SHR\n//       DD DSN=TSY2.AMODGEN,DISP=SHR\n//ASM.SYSIN DD DISP=SHR,DSN=TST2SSG.NZPIO.SHIP(LM02301A)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LM023INS": {"ttr": 5903, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\x13\\x00\\x13\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "FILE369"}, "text": "                  NOTES ON INSTALL OF ZAP WITHOUT SMP\n\n  0.  I DO NOT RECOMMEND THIS METHOD OF INSTALLATION. (S.GOLOB)\n\n  1.  EXPAND(128) IS A LINKAGE EDITOR OPTION WHICH IS HONORED BY\n        SMP IN A ++ZAP REQUEST.  IF YOU WANT TO DO THIS WITHOUT\n        SMP, A SAMPLE RELINK JOB LM023RLK IS INCLUDED.\n\n  2.  THE ZAP MAY BE DONE TO THE OUTPUT MODULE OF THE RELINK JOB.\n\n  3.  AFTER ZAP IS RUN, THE LOAD MODULE IEFW21SD MAY BE\n        RELINKEDITED BY PULLING ITS LINKEDIT JCL OFF THE ASSEMBLY\n        OF AN IOGEN.  YOU'LL NEED TO EXECUTE THE ASSEMBLY STEPS\n        BEFORE, THAT ARE NEEDED TO CREATE THE OBJPDS01 MEMBERS.\n\n  4.  I HAVE ENCLOSED SUCH A SAMPLE JOB, BUT DO NOT EXECUTE IT ON\n        YOUR SYSTEM.  USE YOUR OWN SYSGEN ASSEMBLY STAGE2 DECK.\n        (MY SAMPLE JOB IS LM023LNK.)\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LM023LNK": {"ttr": 6145, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\x80\\x00\\x80\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 128, "newlines": 128, "modlines": 0, "user": "FILE369"}, "text": "//*\n//*\n//*  IMPORTANT NOTE....   DO NOT EXECUTE THIS JOB.  THIS IS ONLY\n//*     A SAMPLE.  THE ACTUAL JOB IS DEPENDENT ON YOUR STAGE1\n//*     IOGEN DECK.  YOU MUST ASSEMBLE AN IOGEN AND PULL THE\n//*     REQUIRED JCL OFF THE //SYSGEN1 JOB .\n//*\n//*\n//TST2RLNK JOB ,\n//           'TECH.SUPP-S.GOLOB',\n//             REGION=5120K,NOTIFY=TST2SSG,\n//             CLASS=M,MSGCLASS=T,MSGLEVEL=(1,1)\n//RLNK EXEC LINKS,\n// PARM='NCAL,LIST,XREF,LET,RENT,SIZE=(512K,100K)',\n//    UNIT='3380',SER=MVSTRS,N=SYS1,NAME=LPALIB,P1=' ',\n//    MOD=,P2=' ',OBJ=OBJPDS01,CLASS=T\n//AOSB3 DD DISP=SHR,VOLUME=(,RETAIN),DSNAME=TSY2.AOSB3\n//CMDLB DD DISP=SHR,VOLUME=(,RETAIN),DSNAME=TST.TSO.CMDLIB\n//SYSLIN DD *\n      INCLUDE SYSPUNCH(IEFSGOPT)\n      INCLUDE SYSPUNCH(IEFYRCDS)\n      INCLUDE CMDLB(IEFAB4B0)\n      INCLUDE SYSLMOD(IEFW21SD)\n      ORDER IEFDB400\n      ORDER IEFDB401\n      ORDER IEFAB4F7\n      ORDER IEFAB4F6\n      ORDER IEFDB4F0\n      ORDER IEFDB4FF\n      ORDER IEFDB4FC\n      ORDER IEFDB4FA\n      ORDER IEFDB410\n      ORDER IEFDB412\n      ORDER IEFDB411\n      ORDER IEFAB4DC\n      ORDER IEFDB417\n      ORDER IEFAB4E9\n      ORDER IEFAB445\n      ORDER IEFDB413\n      ORDER IEFDB414\n      ORDER IEFDB418\n      ORDER IEFDB4FE\n      ORDER IEFDB4F9\n      ORDER IEFDB4F8\n      ORDER IEEMB848\n      ORDER IEFDB4FD\n      ORDER IEFDB480\n      ORDER IEFDB481\n      ORDER IEFDB4A0\n      ORDER IEFDB4A1\n      ORDER IEFDB470\n      ORDER IEFDB450\n      ORDER IEFDB460\n      ORDER IEFDB490\n      ORDER IEFBB401\n      ORDER IEFAB4FE\n      ORDER IEFBB402\n      ORDER IEFBB404\n      ORDER IEFBB4M3\n      ORDER IEFAB451\n      ORDER IEFAB452\n      ORDER IEFAB453\n      ORDER IEFAB470\n      ORDER IEFAB454\n      ORDER IEFAB457\n      ORDER IEFAB464\n      ORDER IEFAB459\n      ORDER IEFAB421\n      ORDER IEFAB427\n      ORDER IEFAB431\n      ORDER IEFAB423\n      ORDER IEFAB424\n      ORDER IEFAB425\n      ORDER IEFAB426\n      ORDER IEFAB430\n      ORDER IEFAB433\n      ORDER IEFAB436\n      ORDER IEFAB440\n      ORDER IEFAB4F0\n      ORDER IEFAB434\n      ORDER IEFAB428\n      ORDER IEFAB4FC\n      ORDER IEFAB435\n      ORDER IEFAB441\n      ORDER IEFAB442\n      ORDER IEFAB432\n      ORDER IEFAB490\n      ORDER IEFAB4F3\n      ORDER IEFAB4FD\n      ORDER IEFAB471\n      ORDER IEFAB4FA\n      ORDER IEFAB473\n      ORDER IEFAB4M5\n      ORDER IEFAB4F9\n      ORDER IEFAB4F8\n      ORDER IEFAB475\n      ORDER IEFAB476\n      ORDER IEFAB480\n      ORDER IEFAB4F2\n      ORDER IEFAB492\n      ORDER IEFAB493\n      ORDER IEFAB494\n      ORDER IEFAB495\n      ORDER IEFBB410\n      ORDER IEFBB412\n      ORDER IEFBB414\n      ORDER IEFBB416\n      ORDER IEFAB4EC\n      ORDER IEFAB4A0\n      ORDER IEFAB4A2\n      ORDER IEFAB4SF\n      ORDER IEFAB4A4\n      ORDER IEFAB4A6\n      ORDER IEFAB4A8\n ALIAS IGC0009I\n ALIAS IEFAB4DC\n ALIAS IEFBB410\n ALIAS IEFAB49C\n ALIAS IEFAB4F5\n ALIAS IEFAB4F4\n ALIAS IEFAB4UV\n ALIAS IEFAB445\n ALIAS IEFAB4EC\n ALIAS IEFAB4SF\n ALIAS IEFTB723\n ENTRY IEFBB401\n NAME  IEFW21SD(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LM023ZAP": {"ttr": 6148, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00_\\x00_\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 95, "newlines": 95, "modlines": 0, "user": "FILE369"}, "text": "++ USERMOD(NZPIO01) /* I.O COUNTS IN IEF285I */.\n++ VER(Z038) FMID(EBB1102) PRE(JBB1329 UZ84610)\n  /*  THIS ZAP ALSO WORKS FOR IEFAB4A2 AT THE UZ75725 LEVEL.\n      FOR OTHER LEVELS, LOOK IN FICHE FOR NAME DSABPTR, AND\n      PLEASE SEE REMARKS BELOW  (FIND THE NAME \"DSABPTR\" IN\n      THIS CODE).  ANOTHER NOTE.  MODULE IEFAB4B0 HASN'T\n      CHANGED SINCE MVS 3.8, BUT MODULE IEFAB4A2, WHICH\n      POINTS TO THE DSAB CONTROL BLOCK, AND WHICH IS NEEDED\n      BY THIS ZAP, DOES CHANGE.  THEREFORE PLEASE DO THE\n      FOLLOWING UCLIN TO NOTICE ANY IBM CHANGES TO MODULE\n      IEFAB4A2.\n\n   UCLIN CDS.\n   REP MOD(IEFAB4A2) RMID(NZPIO01)\n   ENDUCL.\n          (WHERE THE RMID IS THE NAME OF THIS USERMOD)\n  */\n.\n++ ZAP (IEFAB4B0).\n NAME IEFAB4B0\n EXPAND IEFAB4B0(128)\n*                            ORG   CLRKEY\nVER 0052 4220,B10B           STC   @02,@OLDKEY\n*                            ORG   CLRTXT\nVER 0076 D248,B0C1,B0C0      MVC   MSGBUFFR+1(73),MSGBUFFR  BLANK ENTIRE BUFFER\n*                            ORG   STEAL\nVER 0156 9240,B0F8           MVI   MSGDISP+1,C' '      DISPLACED INSTRUCTION\n*                            ORG   @EL00001\nVER 02EE 4320,B10B           IC    @02,@OLDKEY\n*                            ORG   @SIZDATD\nVER 03E8 E600,010C           DC    AL1(230),AL3(@ENDATD-@DATD)\n*                            ORG   PATCH\nVER 045C 0000,0000,0000,0000 DC    4F'0'\nVER 0464 0000,0000,0000,0000\n*                            ORG   CLRKEY\nREP 0052 4220,B120           STC   @02,@NEWKEY\n*                            ORG   CLRTXT\nREP 0076 D24D,B0C1,B0C0      MVC   MSGBUFFR+1(78),MSGBUFFR  BLANK ENTIRE BUFFER\n*                            ORG   STEAL\nREP 0156 47F0,C440           B     PATCH\n*                   MAINLINE EQU   *\n*                            ORG   @EL00001\nREP 02EE 4320,B120           IC    @02,@NEWKEY\n*                            ORG   @SIZDATD\nREP 03E8 E600,0130           DC    AL1(230),AL3(@NEWDATD-@DATD)\n*\n*                            ORG   PATCH\n*                   PATCHOUT EQU   *\nREP 045C 924F,B0B7           MVI   MSGLNGTH+3,79       SET MSGLNGTH TO 79\nREP 0460 58A0,B048           L     @10,@PC00001        ADDR OF MSGID\nREP 0464 9101,A000           TM    0(@10),X'01'        MSGID=1 ?\nREP 0468 47E0,C4C6           BNO   PATEXIT                 NO ==> WE EXIT.\nREP 046C 58A0,D004           L     @10,4(,@13)         ADDR OF IEFAB4A2'S SAVE A\nREP 0470 58A0,A03C           L     @10,X'3C'(,@10)     IEFAB4A2'S R10\n*        ICM   @10,15,X'13C'(@10)  ADDR OF DSAB (IEFAB4A2 DSABPTR\n*                                       LEVEL JBB1326)\nREP 0474 BFAF,A138           ICM   @10,15,X'138'(@10)  ADDR OF DSAB (IEFAB4A2 DS\n*                                   LEVELS UZ75725 AND UZ84610)\nREP 0478 4780,C4C6           BZ    PATEXIT             EXIT IF NO DSAB\nREP 047C 58A0,A010           L     @10,DSABTIOT(,@10)  ADDR OF TIOT ENTRY\nREP 0480 1F66                SLR   @06,@06             CLEAR WORK REG\nREP 0482 4960,A012           CH    @06,TIOPSTTB(,@10)  IS THERE A UCB ENTRY IN T\nREP 0486 4780,C4C6           BZ    PATEXIT                NO ==> WE QUIT.\nREP 048A 5810,B058           L     @01,@PC00001+16     ADDR OF JSCB PTR\nREP 048E 5810,1000           L     @01,0(,@01)         ADDR OF JSCB\nREP 0492 5840,10D0           L     @04,JSCBTCBP(,@01)  ADDR OF INIT'S TCB\nREP 0496 5810,114C           L     @01,JSCTMCOR(,@01)  ADDR OF TIOT MGMT AREA\nREP 049A 5BA0,1018           S     @10,X'18'(,@01)     CALC TIOT ENTRY OFFSET\nREP 049E BF4F,40A4           ICM   @04,15,TCBTCT(@04)  ADDR OF TIMING CONTROL TA\nREP 04A2 4780,C4C6           BZ    PATEXIT             EXIT IF NONE\nREP 04A6 5840,400C           L     @04,TCTIOTBL(,@04)  ADDR OF TCT I/O TABLE\nREP 04AA 4150,4008           LA    @05,TCTDCBTD(,@04)  ADDR OF 1ST DD LOOKUP TAB\n*                   PATDDLOP EQU   *\nREP 04AE 4960,5000           CH    @06,0(,@05)         LAST ENTRY IS ZERO\nREP 04B2 4780,C4C6           BZ    PATEXIT                  EXIT IF ZERO.\nREP 04B6 49A0,5000           CH    @10,0(,@05)         DO THE TIOT DISPLACEMENTS\nREP 04BA 4780,C4AA           BE    PATPRINT                 YES ==> PRINT I/O CO\nREP 04BE 4150,5004           LA    @05,4(,@05)         BUMP TO NEXT DD TABLE ENT\nREP 04C2 47F0,C492           B     PATDDLOP\n*                   PATPRINT EQU   *\nREP 04C6 4A40,5002           AH    @04,TCTIOTSD(,@05)  OFFSET TO THE DEVICE ENTR\n*                                  (TCTDDENT OR TCBUCBP)\nREP 04CA 5860,4004           L     @06,TCTDCTR(,@04)   GET THE I/O COUNT\nREP 04CE 4E60,B0F8           CVD   @06,MSGDISP+1       INTO PACKED FORMAT\nREP 04D2 D209,B105,C4CE      MVC   MSGCOUNT(L'EDMSK1),EDMSK1 PREPARE TO EDIT\nREP 04D8 DE09,B105,B0FC      ED    MSGCOUNT(L'EDMSK1),MSGDISP+5 STICK IN SOME CO\nREP 04DE 925C,B105           MVI   MSGCOUNT,C'*'       MARK WITH A SPLAT\n*                   PATEXIT  EQU   *\nREP 04E2 9240,B0F8           MVI   MSGDISP+1,C' '      DISPLACED INSTRUCTION\nREP 04E6 47F0,C13E           B     MAINLINE\n*\n*                   EDMSK1   EQU   *\nREP 04EA 6020,6B20,2020,6B20 DC    X'60206B2020206B202120'\nREP 04F2 2120\n* DECK PRODUCED BY THE ASMTOZAP UTILITY 86/12/23 104029\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LM02301A": {"ttr": 6151, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\x92\\x00\\x92\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 146, "newlines": 146, "modlines": 0, "user": "FILE369"}, "text": "*-------     RESTORED BY S.GOLOB - NEWSWEEK INC.\n*-------\n*------- TITLE LM02301...I/O COUNT  IN MSG IEF285I\n*-------\n*------- AUTHOR LARRY KRAUSE...LITTON COMPUTER SERVICES 1978\n*-------        DICK SZIEDE....GENERAL ELECTRIC 1983\n*-------\n*------- BACKGROUND AS FAR AS I KNOW,LARRY IS THE ONLY ONE TO\n*-------       WRITE A MVS VERSION  OF THIS MOD,  ALTHOUGH IT\n*-------       COMMON IN MVT (RICK  DUVALL...CSC) AND SVS (AUTHOR\n*-------       UNKNOWN).  THIS VERSION HAS BEEN RECODED IN ASMTOZAP\n*-------       FORMAT FOR MVS SP1.3, WITH SOME COSMETIC CHANGES.\n*-------       ...DICK SZIEDE...CSC 1982.\n*-------       MAKE WORK UNDER VS ASSEMBLER INSTEAD OF ASMH, AND\n*-------       MORE COSMETIC CHANGES...DICK SZIEDE, GE 1983.\n*-------\n*ZAP     CARD ++ USERMOD(LM02301) /* I.O COUNTS IN IEF285I */.\n*ZAP     CARD ++ VER(Z038) FMID(EBB1102) PRE(JBB1326).\n*ZAP     CARD ++ ZAP (IEFAB4B0).\n*ZAP     CARD  NAME IEFAB4B0\n*ZAP     CARD  EXPAND IEFAB4B0(128)\nLM02301A CSECT\nIEFAB4B0 DS    0H\n         PRINT ON,GEN,DATA\n         ORG   @PSTART\n         USING *,@12\n         USING @DATD,@11\n*ZAP     START VER\n         ORG   CLRKEY\n         STC   @02,@OLDKEY\n         ORG   CLRTXT\n         MVC   MSGBUFFR+1(73),MSGBUFFR  BLANK ENTIRE BUFFER\n         ORG   STEAL\n         MVI   MSGDISP+1,C' '      DISPLACED INSTRUCTION\n         ORG   @EL00001\n         IC    @02,@OLDKEY\n         ORG   @SIZDATD\n         DC    AL1(230),AL3(@ENDATD-@DATD)\n         ORG   PATCH\n         DC    4F'0'\n*ZAP     START REP\n         ORG   CLRKEY\n         STC   @02,@NEWKEY\n         ORG   CLRTXT\n         MVC   MSGBUFFR+1(78),MSGBUFFR  BLANK ENTIRE BUFFER\n         ORG   STEAL\n         B     PATCH\nMAINLINE EQU   *\n         ORG   @EL00001\n         IC    @02,@NEWKEY\n         ORG   @SIZDATD\n         DC    AL1(230),AL3(@NEWDATD-@DATD)\n         ORG   PATCH\nPATCHOUT MVI   MSGLNGTH+3,79       SET MSGLNGTH TO 79\n         L     @10,@PC00001        ADDR OF MSGID\n         TM    0(@10),X'01'        MSGID=1 ?\n         BNO   PATEXIT                 NO ==> WE EXIT.\n         L     @10,4(,@13)         ADDR OF IEFAB4A2'S SAVE AREA\n         L     @10,X'3C'(,@10)     IEFAB4A2'S R10\n*        ICM   @10,15,X'13C'(@10)  ADDR OF DSAB (IEFAB4A2 DSABPTR\n*                                       LEVEL JBB1326)\n         ICM   @10,15,X'138'(@10)  ADDR OF DSAB (IEFAB4A2 DSABPTR\n*                                   LEVELS UZ75725 AND UZ84610)\n         BZ    PATEXIT             EXIT IF NO DSAB\n         L     @10,DSABTIOT(,@10)  ADDR OF TIOT ENTRY\n         SLR   @06,@06             CLEAR WORK REG\n         CH    @06,TIOPSTTB(,@10)  IS THERE A UCB ENTRY IN TIOT?\n         BZ    PATEXIT                NO ==> WE QUIT.\n         L     @01,@PC00001+16     ADDR OF JSCB PTR\n         L     @01,0(,@01)         ADDR OF JSCB\n         L     @04,JSCBTCBP(,@01)  ADDR OF INIT'S TCB\n         L     @01,JSCTMCOR(,@01)  ADDR OF TIOT MGMT AREA\n         S     @10,X'18'(,@01)     CALC TIOT ENTRY OFFSET\n         ICM   @04,15,TCBTCT(@04)  ADDR OF TIMING CONTROL TABLE\n         BZ    PATEXIT             EXIT IF NONE\n         L     @04,TCTIOTBL(,@04)  ADDR OF TCT I/O TABLE\n         LA    @05,TCTDCBTD(,@04)  ADDR OF 1ST DD LOOKUP TABLE ENTRY\nPATDDLOP CH    @06,0(,@05)         LAST ENTRY IS ZERO\n         BZ    PATEXIT                  EXIT IF ZERO.\n         CH    @10,0(,@05)         DO THE TIOT DISPLACEMENTS MATCH?\n         BE    PATPRINT                 YES ==> PRINT I/O COUNT.\n         LA    @05,4(,@05)         BUMP TO NEXT DD TABLE ENTRY\n         B     PATDDLOP\n         SPACE\nPATPRINT AH    @04,TCTIOTSD(,@05)  OFFSET TO THE DEVICE ENTRY\n*                                  (TCTDDENT OR TCBUCBP)\n         L     @06,TCTDCTR(,@04)   GET THE I/O COUNT\n         CVD   @06,MSGDISP+1       INTO PACKED FORMAT\n         MVC   MSGCOUNT(L'EDMSK1),EDMSK1 PREPARE TO EDIT\n         ED    MSGCOUNT(L'EDMSK1),MSGDISP+5 STICK IN SOME COMMAS\n         MVI   MSGCOUNT,C'*'       MARK WITH A SPLAT\nPATEXIT  MVI   MSGDISP+1,C' '      DISPLACED INSTRUCTION\n         B     MAINLINE\n*\nEDMSK1   DC    X'60206B2020206B202120'\n*ZAP     END\n@DATD    DSECT\n         ORG   @DATD+X'48'\n@PC00001 DS    5F\n         ORG   @DATD+X'B4'\nMSGLNGTH DS    F\n         DS    2F\nMSGBUFFR DS    C\n         ORG   @DATD+X'F7'\nMSGDISP  DS    X\n         ORG   @DATD+X'105'\nMSGCOUNT DS    CL6\n@OLDKEY  DS    AL1\n@ENDATD  EQU   *\n         ORG   @DATD+X'120'\n@NEWKEY  DS    AL1\n         DS    D                   ALIGN TO DUBBLEWORD FOR GETMAIN\n@NEWDATD EQU   *\n         SPACE\nLM02301A CSECT\n*        ***** EQUATES FOR DSECTS  I'M TOO LAZY TO DO THE DROPS\n*        ***** 'N USINGS FOR.\nDSABTIOT EQU   X'10'\nTIOPSTTB EQU   X'12'\nJSCBTCBP EQU   X'D0'                   '\nJSCTMCOR EQU   X'14C'                  '\nTCBTCT   EQU   X'A4'\nTCTIOTBL EQU   X'C'\nTCTDCBTD EQU   X'8'\nTCTIOTSD EQU   X'2'\nTCTDCTR  EQU   X'4'\n*\n*        ***** EQUATES FOR LOCATIONS WITHIN IEFAB4B0\n@PSTART  EQU   IEFAB4B0+X'1C'\nCLRKEY   EQU   IEFAB4B0+X'52'\nCLRTXT   EQU   IEFAB4B0+X'76'\nSTEAL    EQU   IEFAB4B0+X'156'\n@EL00001 EQU   IEFAB4B0+X'2EE'\n@SIZDATD EQU   IEFAB4B0+X'3E8'\nPATCH    EQU   IEFAB4B0+X'45C'\n*        ***** AND OF COURSE, THE REGISTERS\n@01      EQU   01\n@02      EQU   02\n@04      EQU   04\n@05      EQU   05\n@06      EQU   06\n@10      EQU   10\n@11      EQU   11\n@12      EQU   12\n@13      EQU   13\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LM02702": {"ttr": 6155, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\xdd\\x00\\xdd\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 221, "newlines": 221, "modlines": 0, "user": "FILE369"}, "text": "PRC      TITLE 'ZAP TO IGG01946 FOR TCAM OPENQ SMF RECORD.'\n********************************************************************\n*                                                                  *\n* NAME - TCAM OPENQ SMF RECORD WRITER.                             *\n*                                                                  *\n* DESCRIPTION - THIS CODE WRITES AN SMF240 RECORD FOR EACH OPEN    *\n*   OF AN TCAM APPLICATION Q.                                      *\n*                                                                  *\n* LEVEL - WE TESTED THIS EXIT WITH TCAM V2R4.  PLEASE NOTE THE USE *\n*   OF MODLEV BELOW THAT INDICATES MAINTENANCE LEVEL OF THIS MODULE*\n*   IN THE SMF RECORD.                                             *\n*                                                                  *\n* UPON ENTRY -                                                     *\n*                                                                  *\n* LOG -                                                            *\n*   07/XX/86 PTW L01 IMPLEMENTATION                                *L01\n*   05/21/87 PTW L02 REFIT FOR UY00456                             *L02\n*                                                                  *\n********************************************************************\n*ZAP     CARD ++USERMOD(LM02702).         /* TCAM OPENQ WRITE SMF */\n*ZAP     CARD ++VER(Z038) FMID(JTC2412) PRE(UY00456).\n*ZAP     CARD ++ZAP (IGG01946).\n*ZAP     CARD    NAME IGG01946\n*ZAP     CARD  EXPAND IGG01946(450)\n         LCLC  &CSECT\n&CSECT   SETC  'IGG01946'          LIST OUTPUT CSECT NAME.\n&CSECT   CSECT                     START THE CSECT.\n*\nRECTYPE  EQU   240                SMF RECORD NUMBER.\nRECSTYPE EQU   2                  SMF RECORD SUBTYPE.\nMODLEV   EQU   2                  THIS MODULE'S LEVEL.              L02\nTCAMLEV  EQU   24                 VTAM VERSION/RELEASE.\n*\nA        EQU   &CSECT              FOR CONVENIENCE.\nEXITTST  EQU   A+X'2E6'            BRANCH BACK LABEL.               L02\nHOOK     EQU   A+X'7DE'            OFFSET TO 'STEAL' POINT.         L02\nPATCH    EQU   A+X'8D4'            OFFSET TO 'PATCH' POINT.         L02\nOFFSET   EQU   X'004'              OFFSET OF CSECT ADDRESSIBILITY.\n* NOTE THAT WE ONLY DESTROY R0-R2, AND R14-R15 IN THIS ROUTINE.\nRCORE    EQU   3                   A(OPEN WORKAREA).\nRDCB     EQU   4                   A(DCB PROTECTED COPY).\nRTCX     EQU   9                   A(TCX).\nRBASE    EQU   12                  BASE REGISTER.\nRTCB     EQU   13                  A(TCB).\nTCXASCB  EQU   X'01C',4,C'A'       A(TCAM'S ASCB).\nFORCORE  DSECT                     A FAKE DSECT FOR THE WORKAREA.\n         ORG   *+X'20E'\nDXUKEY   DS    X\n&CSECT   CSECT                     START THE CSECT.\n         USING A+OFFSET,RBASE      ADDRESSIBILITY.\n         USING FORCORE,RCORE       WORKAREA.\n         PRINT DATA\n*ZAP START\n*ZAP START VER\n         ORG   HOOK\n         B     EXITTST            OUR STOLEN INSTRUCTION.\n         ORG   PATCH\n         DC    XL4'00'\n*ZAP START REP\n         ORG   HOOK               HOOK POINT.\n         B     DOSMF              BRANCH TO PATCH.\n         ORG   PATCH              PATCH POINT.\nDOSMF    DS    0H                 PATCH LABEL.\n********************************************************************\n*                                                                  *\n*        I N I T I A L I Z E                                       *\n*                                                                  *\n********************************************************************\n         GETMAIN RU,LV=DYNLEN,SP=230 GETMAIN (SP230 TASK PRIV HI).\n         LR    R2,R1              SAVE AREA\n         USING DYNAMIC,R2\n         LA    R0,DYNAMIC         ZERO\n         LA    R1,DYNLEN            DYNAMIC\n         LR    R14,R0                 STORAGE.\n         SLR   R15,R15\n         MVCL  R0,R14             DO IT.\n********************************************************************\n*                                                                  *\n*        C R E A T E   S M F   R E C O R D                         *\n*                                                                  *\n********************************************************************\n         MVI   SM240RTY,RECTYPE   RECORD TYPE 240.\n         MVC   SM240TYP,=AL2(RECSTYPE) WE ARE SUBTYPE 2.\n         LA    R14,S2402DAT       R14 = (SMF POINTER).\n         MVC   S2402TRN,=AL2(S2402TR#) # TRIPLETS.\n* CREATE SOFTWARE LEVEL SECTION OF SMF RECORD.\n         LA    R0,S2402REC        CALCULATE AND STORE OFFSET.\n         LR    R1,R14\n         SLR   R1,R0\n         ST    R1,S2402LVO\n         MVC   S2402LVL,=AL2(S2402LLN) MOVE LENGTH.\n         MVC   S2402LV#,=H'1'     ONLY 1 SECTION.\n         USING S2402LEV,R14       USE LEV MAPPING.\n         MVI   S2402LAM,S2402LAT  MOVE ACCESS METHOD.\n         MVI   S2402LVR,TCAMLEV   MOVE VERSION/RELEASE.\n         MVI   S2402LMD,MODLEV    OUR RECORD VERSION.\n         DROP  R14\n         LA    R14,S2402LLN(,R14) BUMP SMF POINTER.\n* CREATE ACCOUNTING SECTION OF SMF RECORD.\n         LA    R0,S2402REC        CALCULATE AND STORE OFFSET.\n         LR    R1,R14\n         SLR   R1,R0\n         ST    R1,S2402ACO\n         MVC   S2402ACL,=AL2(S2402ALN) MOVE LENGTH.\n         MVC   S2402AC#,=H'1'     ONLY 1 SECTION.\n         USING S2402ACT,R14       USE ACCT MAPPING.\n         TIME  BIN                STORE TIME, DATE.                 L02\n         STM   R0,R1,S2402ATM\n         MVI   S2402ATY,S2402ATS  MOVE FUNCTION CODE.\n         MVC   S2402APL,=CL8' '   INIT PLUNAME.\n         L     R1,TCBTIO-T(,RTCB) R1 = A(TCBTIOT).\n         AH    R1,DCBTIOT-D(,RDCB) R1 = A(TIOT ENTRY).\n         ICM   R1,7,TIOEJFCB-TIOENTRY(R1) R1 = A(JFCB).\n* MUST ADJUST A(JFCB) BY LENGTH OF HEADER IN NEXT INSTRUCTION.\n         LA    R1,JFCBQNAM-J+X'10'(,R1)\n         LA    R0,L'JFCBQNAM      THIS LOOP STRIPS OFF THE QUALIFIER\n         LR    R15,R1               FROM THE QNAME.JOBNAME FORM OF\nTESTQUAL DS    0H                   ALLOCATION.\n         CLI   1(R15),C'.'        LOOK FOR '.'.\n         BE    GOTQUAL            EXIT IF FOUND.\n         LA    R15,1(,R15)        BUMP POINTER.\n         BCT   R0,TESTQUAL        LIMIT OF 8 TIMES.\n         BCTR  R15,0              ADJUST POINTER BACK.\nGOTQUAL  DS    0H\n         SLR   R15,R1             FIND LENGTH.\n         EX    R15,MOVEQNAM       MOVE QNAME.\n         MVC   S2402ASL,=CL8' '   MOVE SLUNAME.\n         MVC   S2402AMJ,=CL8' '   INIT ACC METHOD JOBNAME.\n         MODESET EXTKEY=ZERO      TCX IS FETCH PROTECTED.\n         L     R1,TCXASCB(,RTCX)  R1 = A(TCAM ASCB).\n         MODESET KEYADDR=DXUKEY,WORKREG=15 RETURN TO USER KEY.\n         L     R15,ASCBJBNI-ASCB(,R1) IF A(JOB JOBNAME) NOT\n         LTR   R15,R15                  BLANK, USE IT.\n         BNZ   MOVEJOBM\n         L     R15,ASCBJBNS-ASCB(,R1) ELSE TRY FOR START/MOUNT/\n         LTR   R15,R15                  LOGON JOBNAME.\n         BZ    *+10\nMOVEJOBM MVC   S2402AMJ,0(R15)    MOVE IN ACCESS METHOD JOBNAME.\n         MVC   S2402AAJ,=CL8' '   BLANK APPL JOBNAME.\n         L     R1,PSAAOLD-P       R1 = A(CURRENT ASCB).\n         L     R15,ASCBJBNI-ASCB(,R1) SAME AS ABOVE.\n         LTR   R15,R15\n         BNZ   MOVEJOBA\n         L     R15,ASCBJBNS-ASCB(,R1)\n         LTR   R15,R15\n         BZ    *+10\nMOVEJOBA MVC   S2402AAJ,0(R15)    MOVE IN ACCESS METHOD JOBNAME.\n         DROP  R14\n         LA    R14,S2402ALN(,R14) BUMP SMF POINTER.\n         LA    R0,SM240ULN\n         LR    R1,R14             CALCULATE L'USER SECTION.\n         SLR   R1,R0\n         STH   R1,SM240ULN        STORE L'USER SECTION IN SMF REC.\n         LA    R1,S2402REC        R1 = A(SMF RECORD).\n         SVC   226                CALL USER SVC ROUTINE.\n         LTR   R15,R15            WTO IF BAD RC.\n         BNZ   BADSVC\n********************************************************************\n*                                                                  *\n*        R E T U R N                                               *\n*                                                                  *\n********************************************************************\nRETURN   DS    0H\n         FREEMAIN RU,LV=DYNLEN,A=(R2),SP=230\n         B     EXITTST\n********************************************************************\n*                                                                  *\n*        E R R O R S                                               *\n*                                                                  *\n********************************************************************\nBADSVC   DS    0H\n*WTO 'IEDPRC5I NON-ZERO RC FROM PRC SMF SVC - NO ACCT RECORD WRITTEN.'2\n         B     RETURN\n********************************************************************\n*                                                                  *\n*        S T A T I C   A R E A                                     *\n*                                                                  *\n********************************************************************\nMOVEQNAM MVC   S2402APL(*-*),0(R1)     MOVE PLUNAME.\n         LTORG *\n*ZAP END\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   A R E A S                                 *\n*                                                                  *\n********************************************************************\nDYNAMIC  DSECT\n         PRINT GEN\nS2402REC SMF240 DSECT=NO,SUBTYPE=2     TYPE 240 RECORD.\nDYNLEN   EQU   *-DYNAMIC\n         PRINT NOGEN\n         IHAPSA\nP        EQU   PSA\n         IHAASCB\n         IKJTCB\nT        EQU   TCB\nTI       DSECT\n         IEFTIOT1\nJ        DSECT\n         IEFJFCBN\n         DCBD  DSORG=PS,DEVD=DA\nD        EQU   IHADCB\n         PRINT OFF\nR0       EQU   00\nR1       EQU   01\nR2       EQU   02\nR3       EQU   03\nR4       EQU   04\nR5       EQU   05\nR6       EQU   06\nR7       EQU   07\nR8       EQU   08\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11                 A(PLIST).\nR12      EQU   12                 PROGRAM BASE.\nR13      EQU   13                 A(SAVE AREA).\nR14      EQU   14\nR15      EQU   15\n         PRINT ON\n         END   &CSECT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LM02802": {"ttr": 6401, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\xed\\x00\\xed\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 237, "newlines": 237, "modlines": 0, "user": "FILE369"}, "text": "PRC      TITLE 'ZAP TO IGG02046 FOR TCAM CLOSEQ SMF RECORD.'\n********************************************************************\n*                                                                  *\n* NAME - TCAM CLOSEQ SMF RECORD WRITER.                            *\n*                                                                  *\n* DESCRIPTION - THIS CODE WRITES AN SMF240 RECORD FOR EACH CLOSE   *\n*   OF AN TCAM APPLICATION Q.                                      *\n*                                                                  *\n* LEVEL - WE TESTED THIS EXIT WITH TCAM V2R4.  PLEASE NOTE THE USE *\n*   OF MODLEV BELOW THAT INDICATES MAINTENANCE LEVEL OF THIS MODULE*\n*   IN THE SMF RECORD.                                             *\n*                                                                  *\n* UPON ENTRY -                                                     *\n*                                                                  *\n* LOG -                                                            *\n*   07/XX/86 PTW L01 IMPLEMENTATION                                *L01\n*   05/21/87 PTW L02 REFIT FOR UY00456                             *L02\n*                                                                  *\n********************************************************************\n*ZAP     CARD ++USERMOD(LM02802) .        /* TCAM CLOSEQ WRITE SMF */\n*ZAP     CARD ++VER(Z038) FMID(JTC2412) PRE(UY00456).\n*ZAP     CARD ++ZAP (IGG02046).\n*ZAP     CARD    NAME IGG02046\n*ZAP     CARD  EXPAND IGG02046(450)\n         LCLC  &CSECT\n&CSECT   SETC  'IGG02046'          LIST OUTPUT CSECT NAME.\n&CSECT   CSECT                     START THE CSECT.\n*\nRECTYPE  EQU   240                SMF RECORD NUMBER.\nRECSTYPE EQU   2                  SMF RECORD SUBTYPE.\nMODLEV   EQU   2                  THIS MODULE'S LEVEL.              L02\nTCAMLEV  EQU   24                 VTAM VERSION/RELEASE.\n*\nA        EQU   &CSECT              FOR CONVENIENCE.\nHOOK     EQU   A+X'31A'            OFFSET TO 'STEAL' POINT.         L02\nNOEU     EQU   A+X'320'            BRANCH BACK LABEL.               L02\nPATCH    EQU   A+X'53C'            OFFSET TO 'PATCH' POINT.         L02\nOFFSET   EQU   X'002'              OFFSET OF CSECT ADDRESSIBILITY.\nONE      EQU   1\n* NOTE: WE DESTROY R0-R1,R3-R4,R14-R15 IN THIS ROUTINE.\nRRCB     EQU   1                   A(RCB).\nRCORE    EQU   2                   A(WORKAREA).\nRTCB     EQU   9                   A(TCB).\nRDCB     EQU   10                  A(DCB PROTECTED COPY).\nRBASE    EQU   12                  BASE REGISTER.\n*\nIEDQRECB DSECT                     A FAKE DSECT FOR THE RCB.\n         DS    XL22\nRCBOPECB DS    XL4\n         DS    XL11\nRCBPEBAD DS    AL3\n*\nFORCORE  DSECT                     A FAKE DSECT FOR THE WORKAREA.\n         ORG   *+X'170'\nDXCCW1   DS    D\n*\n&CSECT   CSECT                     START THE CSECT.\n         USING A+OFFSET,RBASE      ADDRESSIBILITY.\n         PRINT DATA\n*ZAP START\n*ZAP START VER\n         ORG   HOOK\n         USING FORCORE,RCORE\n         USING IEDQRECB,RRCB\n         MVC   DXCCW1+ONE(3),RCBOPECB\n         DROP  RCORE,RRCB\n         ORG   PATCH\n         DC    XL8'00'\n*ZAP START REP\n         ORG   HOOK                HOOK POINT.\n         B     DOSMF               BRANCH TO PATCH.\n         ORG   PATCH               PATCH POINT.\nDOSMF    DS    0H                  PATCH LABEL.\n********************************************************************\n*                                                                  *\n*        I N I T I A L I Z E                                       *\n*                                                                  *\n********************************************************************\n         LR    R3,R1              SAVE A(RCB).\n         GETMAIN RU,LV=DYNLEN,SP=230 GET SP230 (TASK,HI PRIVATE)\n         LR    R4,R1              SAVE AREA\n         USING DYNAMIC,R4\n         LA    R0,DYNAMIC         ZERO\n         LA    R1,DYNLEN            DYNAMIC\n         LR    R14,R0                 STORAGE.\n         SLR   R15,R15\n         MVCL  R0,R14             DO IT.\n********************************************************************\n*                                                                  *\n*        C R E A T E   S M F   R E C O R D                         *\n*                                                                  *\n********************************************************************\n         MVI   SM240RTY,RECTYPE   RECORD TYPE 240.\n         MVC   SM240TYP,=AL2(RECSTYPE) WE ARE SUBTYPE 2.\n         LA    R14,S2402DAT       R14 = (SMF POINTER).\n         MVC   S2402TRN,=AL2(S2402TR#) # TRIPLETS.\n* CREATE SOFTWARE LEVEL SECTION OF SMF RECORD.\n         LA    R0,S2402REC        CALCULATE AND STORE OFFSET.\n         LR    R1,R14\n         SLR   R1,R0\n         ST    R1,S2402LVO\n         MVC   S2402LVL,=AL2(S2402LLN) MOVE LENGTH.\n         MVC   S2402LV#,=H'1'     ONLY 1 SECTION.\n         USING S2402LEV,R14       USE LEV MAPPING.\n         MVI   S2402LAM,S2402LAT  MOVE ACCESS METHOD.\n         MVI   S2402LVR,TCAMLEV   MOVE VERSION/RELEASE.\n         MVI   S2402LMD,MODLEV    OUR RECORD VERSION.\n         DROP  R14\n         LA    R14,S2402LLN(,R14) BUMP SMF POINTER.\n* CREATE ACCOUNTING SECTION OF SMF RECORD.\n         LA    R0,S2402REC        CALCULATE AND STORE OFFSET.\n         LR    R1,R14\n         SLR   R1,R0\n         ST    R1,S2402ACO\n         MVC   S2402ACL,=AL2(S2402ALN) MOVE LENGTH.\n         MVC   S2402AC#,=H'1'     ONLY 1 SECTION.\n         USING S2402ACT,R14       USE ACCT MAPPING.\n         TIME  BIN                STORE TIME, DATE.                 L02\n         STM   R0,R1,S2402ATM\n         MVI   S2402ATY,S2402ATE  MOVE FUNCTION CODE.\n         L     R1,TCBTIO-T(,RTCB) R1= A(TIOT).\n         AH    R1,DCBTIOT-D(,RDCB) R1 = A(TIOT ENTRY).\n         ICM   R1,7,TIOEJFCB-TIOENTRY(R1)  R1 = A(JFCB).\n         MVC   S2402APL,=CL8' '   INIT PLUNAME.\n* MUST ADJUST A(JFCB) BY LENGTH OF HEADER IN NEXT INSTRUCTION.\n         LA    R1,JFCBQNAM-J+X'10'(,R1)\n         LA    R0,L'JFCBQNAM      THIS LOOP STRIPS OFF THE QUALIFIER\n         LR    R15,R1               FROM THE QNAME.JOBNAME FORM OF\nTESTQUAL DS    0H                   ALLOCATION.\n         CLI   1(R15),C'.'        LOOK FOR '.'.\n         BE    GOTQUAL            EXIT IF FOUND.\n         LA    R15,1(,R15)        BUMP POINTER.\n         BCT   R0,TESTQUAL        LIMIT OF 8 TIMES.\n         BCTR  R15,0              ADJUST POINTER BACK.\nGOTQUAL  DS    0H\n         SLR   R15,R1             FIND LENGTH.\n         EX    R15,MOVEQNAM       MOVE QNAME.\n         MVC   S2402ASL,=CL8' '   MOVE SLUNAME.\n         MVC   S2402AMJ,=CL8' '   INIT ACCESS METHOD JOBNAME.\n         USING IEDQRECB,R3\n         ICM   R1,7,RCBPEBAD      R1 = A(TCAM ASCB).\n         DROP  R3\n         L     R15,ASCBJBNI-ASCB(,R1) IF JOBNAME FOR JOB IS BLANK,\n         LTR   R15,R15                  TRY JOBNAME FOR STC/LOGON/\n         BNZ   MOVEJOBM                 MOUNT.\n         L     R15,ASCBJBNS-ASCB(,R1)\n         LTR   R15,R15\n         BZ    *+10\nMOVEJOBM MVC   S2402AMJ,0(R15)    MOVE IN ACCESS METHOD JOBNAME.\n         MVC   S2402AAJ,=CL8' '   BLANK APPL JOBNAME.\n         L     R1,PSAAOLD-P       R1 = A(CURRENT ASCB)\n         L     R15,ASCBJBNI-ASCB(,R1) SAME AS ABOVE.\n         LTR   R15,R15\n         BNZ   MOVEJOBA\n         L     R15,ASCBJBNS-ASCB(,R1)\n         LTR   R15,R15\n         BZ    *+10\nMOVEJOBA MVC   S2402AAJ,0(R15)    MOVE IN ACCESS METHOD JOBNAME.\n         DROP  R14\n         LA    R14,S2402ALN(,R14) BUMP SMF POINTER.\n         LA    R0,SM240ULN\n         LR    R1,R14             CALCULATE L'USER SECTION.\n         SLR   R1,R0\n         STH   R1,SM240ULN        STORE L'USER SECTION IN SMF REC.\n         LA    R1,S2402REC        R1 = A(SMF RECORD).\n         SVC   226                CALL USER SVC ROUTINE.\n         LTR   R15,R15            WTO IF BAD RC.\n         BNZ   BADSVC\n********************************************************************\n*                                                                  *\n*        R E T U R N                                               *\n*                                                                  *\n********************************************************************\nRETURN   DS    0H\n         FREEMAIN RU,LV=DYNLEN,A=(R4),SP=230\n         LR    R1,R3\n         USING FORCORE,RCORE\n         USING IEDQRECB,RRCB\n         MVC   DXCCW1+ONE(3),RCBOPECB\n         DROP  RCORE,RRCB\n         B     NOEU\n********************************************************************\n*                                                                  *\n*        E R R O R S                                               *\n*                                                                  *\n********************************************************************\nBADSVC   DS    0H\n*WTO 'IEDPRC6I NON-ZERO RC FROM PRC SMF SVC - NO ACCT RECORD WRITTEN.'2\n         B     RETURN\n********************************************************************\n*                                                                  *\n*        S T A T I C   A R E A                                     *\n*                                                                  *\n********************************************************************\nMOVEQNAM MVC   S2402APL(*-*),0(R1)     MOVE PLUNAME.\n         LTORG *\n*ZAP END\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   A R E A S                                 *\n*                                                                  *\n********************************************************************\nDYNAMIC  DSECT\n         PRINT GEN\nS2402REC SMF240 DSECT=NO,SUBTYPE=2     TYPE 240 RECORD.\nDYNLEN   EQU   *-DYNAMIC\n         PRINT NOGEN\n         IHAPSA\nP        EQU   PSA\n         IHAASCB\n         IKJTCB\nT        EQU   TCB\nTI       DSECT\n         IEFTIOT1\nJ        DSECT\n         IEFJFCBN\n         DCBD  DSORG=PS,DEVD=DA\nD        EQU   IHADCB\n         PRINT OFF\nR0       EQU   00\nR1       EQU   01\nR2       EQU   02\nR3       EQU   03\nR4       EQU   04\nR5       EQU   05\nR6       EQU   06\nR7       EQU   07\nR8       EQU   08\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11                 A(PLIST).\nR12      EQU   12                 PROGRAM BASE.\nR13      EQU   13                 A(SAVE AREA).\nR14      EQU   14\nR15      EQU   15\n         PRINT ON\n         END   &CSECT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LM04202": {"ttr": 6406, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00V\\x00V\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 86, "newlines": 86, "modlines": 0, "user": "FILE369"}, "text": "PRC      TITLE 'LM042 - ZAPS TO TAF TO SUPPORT LARGE SCREEN SIZE.'\n********************************************************************\n*                                                                  *\n* NAME - LM042                                                     *\n*                                                                  *\n* DESCRIPTION - WE MODIFY TAF TO SUPPORT MOD3 AND MOD4 3270        *\n*   TERMINALS. THE FIRST ZAPS CHANGE AN ERASE WRITE COMMAND TO AN  *\n*   ERASE WRITE ALTERNATE COMMAND. THE OTHER ZAP CHANGES THE MAX   *\n*   SEND BUFFER LENGTH TO ACCOMODATE MOD4 DATA. NOTE THAT NCCF/TAF *\n*   ONLY SUPPORTS THE MOD5 3270 (27X132) AS A MOD2 TERMINAL.       *\n*                                                                  *\n* LEVEL - THESE ZAPS HAVE BEEN TESTED WITH NCCF V2.2 WITH 3278     *\n*   MOD2 AND MOD4 TERMINALS.                                       *\n*                                                                  *\n* NOTE  - USE THE ASSEMBLER H \"BATCH\" OPTION - WE ARE ZAPPING      *L02\n*   THREE SEPERATE CSECTS.                                         *L02\n*                                                                  *\n* ACKNOWLEDGMENTS  - THANKS TO MARK ANDERSON OF BOEING COMPUTER    *\n*   SERVICES FOR POINTING ME IN THE RIGHT DIRECTION. HE HAD        *\n*   SIMILAR NCCF/TAF ZAPS WORKING YEARS BEFORE I CAME UP WITH THIS.*\n*                                                                  *\n* LOG -                                                            *\n*   12/17/87 PTW L01 IMPLEMENTED FOR NCCF V2.1.                    *L01\n*   02/02/88 PTW L02 IMPLEMENTED FOR NCCF V2.2.                    *L02\n*                                                                  *\n********************************************************************\n         LCLC  &CSECT\n*ZAP     CARD ++USERMOD(LM04202).                               /*L02*/\n*ZAP     CARD ++VER(Z038) FMID(HCS2202) PRE(UY08676).           /*L02*/\n*ZAP     CARD ++ZAP (DSILU2E).\n*ZAP     CARD    NAME DSILU2E\n* AP     CARD    NAME DSIBEG DSILU2E\n* NCCF V2.1: BASE FICHE CARD 0020, FRAME E12.\n&CSECT   SETC  'DSILU2E'\n&CSECT   CSECT\nI        EQU   &CSECT+X'59E'                                    /*L02*/\nWCMND    EQU   0\n@04      EQU   4\n         PRINT DATA\n         ORG   I\n*ZAP START VER\n         MVI   WCMND(@04),X'F5'   WCMND=FMW; INSERT ERASE WRITE\n*ZAP PAUSE\n         ORG   I\n*ZAP START REP\n         MVI   WCMND(@04),X'7E'   MAKE IT ERASE WRITE ALTERNATE\n*ZAP PAUSE\n         END   &CSECT\n*ZAP     CARD ++ZAP (DSILU2N).\n*ZAP     CARD    NAME DSILU2N\n* AP     CARD    NAME DSIBEG DSILU2N\n* NCCF V2.1: BASE FICHE CARD 0022, FRAME D19.\n&CSECT   SETC  'DSILU2N'\n&CSECT   CSECT\nI        EQU   &CSECT+X'2A8'                                    /*L02*/\nCMND     EQU   0\n@14      EQU   14\n         PRINT DATA\n         ORG   I\n*ZAP START VER\n         MVI   CMND(@14),X'F5'     CMND = FMW; INSERT ERASE WRITE\n*ZAP PAUSE\n         ORG   I\n*ZAP START REP\n         MVI   CMND(@14),X'7E'     MAKE IT ERASE WRITE ALTERNATE\n*ZAP PAUSE\n         END   &CSECT\n*ZAP     CARD ++ZAP (DSIBEGLB).\n*ZAP     CARD    NAME DSIBEGLB\n* AP     CARD    NAME DSIBEG DSIBEGLB\n* NCCF V2.1: BASE FICHE CARD 0003, FRAME B19.\n&CSECT   SETC  'DSIBEGLB'\n&CSECT   CSECT\nI        EQU   &CSECT+X'27A'                                    /*L02*/\n         PRINT DATA\n         ORG   I\n*ZAP START VER\n         LA    @09,3072           TDBSDBFL=SNDBL; ASSIGN SEND BUFL.\n*ZAP PAUSE\n         ORG   I\n*ZAP START REP\n         LA    @09,3840           LARGE ENOUGH FOR A MOD5+CHANGE\n*ZAP END\n@09      EQU   9\nCMND     EQU   0\n         END   &CSECT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOCUTIL": {"ttr": 6409, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00#\\x00#\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "FILE369"}, "text": "%-------------------------- LOCAL UTILITY OPTION MENU  -------------------------\n% OPTION ===>_ZCMD                                                            +\n%\n%   O +OMEGAMON - OMEGAMON in ISPF Mode                     +User ID  - &ZUSER\n%   S +SDSF     - Spool Display & Scroll Facility           +Time     - &ZTIME\n%   DS+DSPACE   - DASD freespace utility                    +PF Keys  - &ZKEYS\n%   P +PDS      - PDS Release 7.3                           +Appl ID  - &ZAPPLID\n%   1 +SAS      - SAS in full-screen mode                   +System   - &SID\n%                                                           +SYSRES   - &SYSRES\n%                                                           +ISPF V.R - &VERSION\n%                                                           +Proc     - &ZLOGON\n%                                                           +Date     - &ZDATE\n%                                                           +         - &ZJDATE\n%\n%\n%\n%\n)INIT\n  .HELP    = SYSUTILH\n)PROC\n  &ZSEL = TRANS( TRUNC (&ZCMD,'.')\n                O,'PANEL(OMSPF02) NEWAPPL(OM)'\n                B,'PANEL(BKUPSP1)'\n                P,'PANEL(P73pn@p)'\n                S,'PANEL(ZSDSFOPT)  NEWAPPL(ISF)'\n                D,'CMD(%FDSPACE)'\n                DS,'CMD(%FDSPACE)'\n                FS,'CMD(%FDSPACE)'\n                1,'CMD(%FSAS)  NEWAPPL(FSAS)  NEWPOOL'\n              ' ',' '\n                *,'?' )\n  IF (&ZCMD = 'S')\n     &ZSEL = 'PGM(ISFISP) NOCHECK NEWAPPL(ISF)'\n  &TRAIL = .TRAIL\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NONDESC": {"ttr": 6411, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00u\\x00u\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 117, "newlines": 117, "modlines": 0, "user": "FILE369"}, "text": "PRC      TITLE 'NONDESC - WTO EXIT TO MAKE ACTION MESSAGES ROLLABLE.'\n********************************************************************\n*                                                                  *\n* NAME - NONDESC - WTO EXIT TO MAKE ACTION MESSAGES ROLLABLE.      *\n*                                                                  *\n* DESCRIPTION - HERE WE TURN OFF DESC=1,2,3,5,11 UNCONDITIONALLY,  *\n*   MAKING THE MESSAGE ROLL OFF THE DISPLAY.  THIS EXIT WAS        *\n*   ORIGINALLY DESIGNED TO MAKE SELECTED TCAM MSGS ROLLABLE.       *\n*   THIS EXIT IS WELL DOCUMENTED IN THE USER EXITS SPL, GC28-1147. *\n*                                                                  *\n* NOTE - WE MUST BE IN AN APF-AUTHORIZED LINKLIST LIBRARY.         *\n*                                                                  *\n* TO USE -                                                         *\n*   SPECIFY IN AN MPFLSTXX MEMBER OF PARMLIB:                      *\n*      MSGID,SUP(NO),USEREXIT(NONDESC)                             *\n*                                                                  *\n* ON ENTRY -                                                       *\n*   R1 = A(CTXT - COMMTASK EXIT PARMLIST).                         *\n*   STD LINKAGE.                                                   *\n*                                                                  *\n* ON EXIT -                                                        *\n*   R15 = NOT USED.                                                *\n*                                                                  *\n* LOG -                                                            *\n*     DATE   WHO LV    CHANGE                                      *\n*   07/05/86 PTW L01 IMPLEMENTATION                                *L01\n*   11/06/86 PTW L02 UNCONDITIONALLY TURN OFF DESC=1,2,3,5,11.     *L02\n*                                                                  *\n********************************************************************\n         LCLC  &CSECT\n&CSECT   SETC  'NONDESC'\n&CSECT   CSECT ,\n&CSECT   AMODE 31\n&CSECT   RMODE ANY\n********************************************************************\n*                                                                  *\n*        I N I T I A L I Z E                                       *\n*                                                                  *\n********************************************************************\n         PRINT NOGEN\n         SAVE  (14,12),,&CSECT-&SYSDATE-&SYSTIME\n         LR    R12,R15            ESTABLISH BASE.\n         USING &CSECT,R12         TELL ASSEMBLER.\n         L     R11,0(,R1)         R11 = A(CTXT - PARMLIST).\n         USING CTXT,R11           TELL ASSEMBLER.\n         L     R10,CTXTTXPJ       R10 = A(CTXTATTR - TEXT).\n         USING CTXTATTR,R10       TELL ASSEMBLER.\n         L     R9,CTXTDCP         R10 = A(CTXTDESC - DESC CODES).\n         USING CTXTDESC,R9        TELL ASSEMBLER.\n         GETMAIN RU,LV=DYNLEN,SP=230 GET DYNAMIC AREA.\n         LR    R2,R13             SAVE AREA\n         LR    R13,R1             SAVE AREA\n         USING DYNAMIC,R13        TELL ASSEMBLER.\n         LA    R0,DYNAMIC         ZERO\n         LA    R1,DYNLEN            DYNAMIC\n         LR    R14,R0                 STORAGE.\n         SLR   R15,R15\n         MVCL  R0,R14             DO IT.\n         ST    R2,4(,R13)         BACK CHAIN.\n         ST    R13,8(,R2)         FORWARD CHAIN.\n         XC    RC,RC              ASSUME GOOD RC.\n********************************************************************\n*                                                                  *\n*        M A K E   M E S S A G E S   R O L L A B L E               *\n*                                                                  *\n********************************************************************\n         NI    CTXTDC1,255-(CTXTDC01+CTXTDC02+CTXTDC03+CTXTDC05)    L02\n         NI    CTXTDC2,255-(CTXTDC11) TURN OFF 1,2,3,5,11 DESCS.    L02\n         OI    CTXTRFB1,CTXTRCDC   REQUEST CHANGE OF DESC CODES.\n********************************************************************\n*                                                                  *\n*        R E T U R N (S)                                           *\n*                                                                  *\n********************************************************************\nRETURN   DS    0H\n         L     R2,RC                  R2 = RC.\n         LR    R1,R13              PREPARE\n         L     R13,4(,R13)         FOR FREEMAIN.\n         FREEMAIN RU,LV=DYNLEN,A=(1),SP=230\n         LR    R15,R2              AND RETURN\n         RETURN (14,12),RC=(15)      WITH R15 = RC.\n********************************************************************\n*                                                                  *\n*        S T A T I C   A R E A                                     *\n*                                                                  *\n********************************************************************\n         LTORG  *\n         DROP  R11,R10,R9\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   A R E A S                                 *\n*                                                                  *\n********************************************************************\nDYNAMIC  DSECT\nSAVE     DS    18F .\nRC       DS    F\nDYNLEN   EQU   *-DYNAMIC          LENGTH OF WORKAREA.\n         IEZVX100\n         PRINT OFF\nR0       EQU   00\nR1       EQU   01\nR2       EQU   02\nR3       EQU   03\nR4       EQU   04\nR5       EQU   05\nR6       EQU   06\nR7       EQU   07\nR8       EQU   08\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11                 A(PLIST).\nR12      EQU   12                 PROGRAM BASE.\nR13      EQU   13                 A(SAVE AREA).\nR14      EQU   14\nR15      EQU   15\n         PRINT ON\n         END   &CSECT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PRCJFCB": {"ttr": 6414, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x003\\x003\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "FILE369"}, "text": "         TITLE 'PRCJFCB -- READ JOB-FILE CONTROL BLOCK'\n*-------\n*-------  TITLE  : PRCJFCB\n*-------  AUTHOR : DICK SZIEDE, PRC, 1985\n*-------  PURPOSE: THIS SUBROUTINE MOVES THE JOB-FILE CONTROL\n*-------           BLOCK FOR A CALLER INTO AN ACCESSABLE AREA.\n*-------  ARGUMENTS:\n*-------           1.  ADDRESS OF AN  8-BYTE DDNAME, LEFT JUSTIFIED,\n*-------               AND RIGHT-FILLED WITH BLANKS.\n*-------           2.  ADDRESS OF A 176 CHARACTER AREA TO RECEIVE\n*-------               THE JFCB, FULLWORD ALIGNED.\n*-------           BOTH ARGUMENTS MUST BE BELOW THE 16-MEG LINE.\n*-------  EXAMPLE:\n*-------     77 DDNAME              PIC X(8) VALUE 'DDIN    '.\n*-------     01 JFCB.\n*-------        05 DSNAME           PIC X(44).\n*-------        05 FILLER           PIC X(74).\n*-------        05 VOLSER           PIC X(6) OCCURS 5 TIMES.\n*-------\n*-------     CALL 'PRCJFCB' USING(DDNAME,JFCB).\n*-------     IF  RETURN-CODE = 0 THEN\n*-------         DO NEAT STUFF...\n*-------     ELSE\n*-------         DEAL WITH ERROR...\n*-------  OUTPUT:\n*-------     RC=0...\n*-------     THE FULL JFCB IS RETURNED IN THE 176 BYTES INDICATED\n*-------     BY THE SECOND PARAMETER.\n*-------     RC=4...\n*-------     JFCB NOT RETURNED. SOME ERRORS PROVOKE A WTP FROM RDJFCB.\n*-------\nPRCJFCB  PRIME ID=DICK_SZIEDE_PRC_1985\n         REGS\nPRCJFCB  AMODE 24\nPRCJFCB  RMODE 24\n*\n         LM    R9,R10,0(R1)       GET POINTERS TO DDNAME AND\n         MVC   MYDCB+(DCBDDNAM-IHADCB)(8),0(R9)   JFCB.\n         O     R10,=A(0+X'07000000')\n         ST    R10,EXLIST\n         RDJFCB (MYDCB,(INPUT))\nSTOPHERE TERME RC=(15)\nEXLIST   DC    F'0'\nMYDCB    DCB   DSORG=PS,EXLST=EXLIST,MACRF=(E)\n         DS    D\nI        DC    CL8'I'\nJFCB     DS    XL176\n         PRINT ON,NOGEN\n         DCBD  DSORG=PS\n* SOURCE LEVEL PRCJFCB  V01.M06 85/10/25 12:16 PSYRRS\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PRCSMFDR": {"ttr": 6657, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00l\\x00l\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 108, "newlines": 108, "modlines": 0, "user": "FILE369"}, "text": "         TITLE 'PRCSMFDR -- NON-APF WRITE TO SMF'\n*-------\n*------- PURPOSE: PROVIDE FACILITY TO NON-APF AUTHORIZED PROGRAMS\n*-------          TO WRITE SMF RECORDS.\n*-------\n*------- AUTHOR:  DICK SZIEDE  PRC 1985.\n*-------\n*------- METHOD:  USE SVC 226 TO WRITE A USER SMF RECORD.  THIS\n*-------          EXTENDS THE USER SVC TO HIGH-LEVEL LANGUAGES THAT\n*-------          HAVE NO VERB TO ISSUE A SVC DIRECTLY.  PRCSMFDR WILL\n*-------          NOT VALIDITY-CHECK THE PROFFERED SMF RECORD, BECAUSE\n*-------          SVC 226 ALSO PERFORMS THAT FUNCTION.\n*-------\n*-------\n*------- OPTIONS:\n*-------     PL/I: DCL PRCSMFDR ENTRY(FIXED BIN(31),*)\n*-------               OPTIONS (ASM INTER RETCODE);\n*-------           DCL (TOKEN,RC) FIXED BIN(31);\n*-------           DCL 1 SMF240\n*-------               2 ....\n*-------               2 ....\n*-------           CALL PRCSMFDR (TOKEN,SMF240) RC=PLIRETV;\n*-------\n*-------    COBOL: 77 TOKEN PIC S9(9) USAGE IS COMP.\n*-------           77 RC    PIC S9(9) USAGE IS COMP.\n*-------           01 SMF240.\n*-------              05 ....\n*-------              05 ....\n*-------           CALL 'PRCSMFDR' USING(TOKEN,SMF240).\n*-------           MOVE RETURN-CODE TO RC.\n*-------\n*-------   ASSEMBLER: DON'T BE A SAP.  SKIP THE SUBROUTINE AND\n*-------           ISSUE SVC226 YOURSELF.\n*-------\n*-------               TOKEN  --- FULLWORD BINARY, CONTAINS NADA.\n*-------\n*-------               SMF240 --- UP TO 4096 CHARACTERS.  MAPPED BY\n*-------                          THE MACRO \"SMF240.\"  THE FIELDS\n*-------                          MARKED WITH ARROWS MUST BE FILLED\n*-------                          IN.\n*-------                          PROGRAMMERS' NOTE:  THE VIRTUAL\n*-------                          ADDRESS OF SMF240 MUST BE BELOW\n*-------                          16-MEG.\n*-------\n*-------                 SM240LEN DS H    RDW\n*-------                 SM240SEG DS H    RDW\n*-------                 SM240FLG DS XL1  SYSTEM INDICATOR\n*-------        ======>  SM240RTY DS XL1  RECORD TYPE-MUST BE 240\n*-------                 SM240TME DS XL4  TIME RECORD MOVED TO BUFFER\n*-------                 SM240DTE DS XL4  DATE IN PACKED DECIMAL\n*-------                 SM240SID DS CL4  SYSTEM ID\n*-------                 SM240RST DS XL4  TIME AND DATE READER RECOGNIZ\n*-------                 SM240RSD DS XL4      JOB CARD FOR THIS JOB\n*-------        ======>  SM240ULN DS H    USER RECORD LENGTH\n*-------        ======>  SM240TYP DS H    USER RECORD SUBTYPE\n*-------        ======>  SM240USE DS C    USER RECORD\n*-------\n*-------          VALID VALUES FOR:\n*-------                 SM240RTY - 240\n*-------                 SM240USE - 1 = USPTO SYSTEM MGMT SYBSYST.\n*-------                          - 2 = UNASSIGNED\n*-------                 SM240ULN < 4096\n*-------          VALIDITY CHECKING OF THESE FIELDS GIVES SMF A\n*-------          MODICUM OF PTOTECTION AGAINST A GARBAGE PARAMETER\n*-------          LIST.\n*-------\n*------- DETAIL:  SVC 226 WILL CALCULATE A CORRECT RDW FROM THE USER\n*-------          RECORD LENGTH.  THE OTHER FIELDS WILL BE FILLED BY\n*-------          THE SVC FROM SYSTEM SERVICES.\n*-------\n*-------          PROGRAMMERS' NOTE: THE USER SVC **WILL** ALTER THE\n*-------          SMF RECORD IN THE CALLING PROGRAM'S MEMORY.  TIME\n*-------          STAMPS, SYSTEM ID, AND RDW ARE ALL FILLED IN.  THE\n*-------          CALLING PROGRAM SHOULD NOT STASH DATA IN THE\n*-------          \"SYSTEM\" FIELDS.\n*-------\n*------- OUTPUT: POSSIBLE RETURN CODES ARE:\n*-------\n*-------       R15 = 0  SMF RECORD WRITTEN.\n*-------           = 4\n*-------           = 8  INVALID USER RECORD TYPE.\n*-------           =12  BAD RETURN FROM SMFWTM. \"TOKEN\" CONTAINS\n*-------                SMFRTM RETURN CODE.  CALLING PROGRAM SHOULD\n*-------                DISPLAY \"TOKEN,\" DEBUG PARAMETERS, AND QUIT.\n*-------           =16  INVALID CALLING PARAMETERS. (BAD SMF RECORD).\n*-------\n*-------     TOKEN \u00ac=0  WILL BE NON-ZERO RC FROM SMFWTM WHEN R15\n*-------                EQUALS 12.   OTHERWISE, IT WILL CONTAIN\n*-------                GARBAGE\n*-------\n         EJECT\nPRCSMFDR AMODE 31\nPRCSMFDR RMODE ANY\nPRCSMFDR PRIME BR=9,ID=DICK_SZIEDE_PRC_1985\n         REGS\n         LR    R11,R1          SAVE POINTER TO PARAMETER LIST\n         L     R1,4(,R11)      POINT TO SMF RECORD\n         L     R10,0(,R11)     POINT TO TOKEN\n         L     R2,0(,R1)       REFERENCE THE RECORD, SO WE TAKE THE 0C4\n*                              INSTEAD OF THE SVC\n         SVC   226\nSTOPHERE ST    R0,0(,R10)      RC=12...SAVE SMFWTM RC IN TOKEN\n         TERME RC=(15)         RC=SMFWTM'S RC.\nSRCLEVEL DC    C'PRCSMFDR V01.M04 85/09/26 18:00 PSYRRS  '\n*                MODULE   VER/MOD   DATE   TIME  USER NAME\nCOPYRIGT DC    C' COPYRIGHT (C) 1985 PLANNING RESEARCH CORPORATION '\nASMSTAMP DC    C'ASM &SYSDATE &SYSTIME'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PRC38DSN": {"ttr": 6660, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\x94\\x00\\x94\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 148, "newlines": 148, "modlines": 0, "user": "FILE369"}, "text": "PRC      TITLE 'STORE THE DSN FOR A DDNAME IN A DIALOG VARIABLE.'\n*********************************************************************\n*                                                                   *\n*   THIS ROUTINE RUNS UNDER CONTROL OF THE ISPF DIALOG MANAGER.     *\n*   GIVEN AN ALLOCATED DDNAME VIA THE PARM FIELD, WE RETURN THE     *\n*   DSN AND VOLSER IN DIALOG VARIABLES OUTDSN AND OUTVOL.  DESIGNED *\n*   FOR USE IN THE PRC 3.8 REPLACEMENT CLISTS SO WE CAN USE VIO     *\n*   FOR OUR TEMPORARY FILES.                                        *\n*                                                                   *\n*   TO USE -                                                        *\n*     ISPEXEC SELECT PGM(PRC38DSN) PARM(DDNAME)                     *\n*     ISPEXEC VGET (OUTDSN OUTVOL)                                  *\n*                                                                   *\n*   05/01/86 - L01 PTW IMPLEMENTED                                  *\n*                                                                   *\n*********************************************************************\n         LCLC  &CSECT\n&CSECT   SETC  'PRC38DSN'\n&CSECT   CSECT ,\n*********************************************************************\n*                                                                   *\n*        I N I T I A L I Z E   A N D   D E T E R M I N E            *\n*        T Y P E   O F   C A L L.                                   *\n*                                                                   *\n*********************************************************************\n         SAVE  (14,12),,&CSECT-&SYSDATE-&SYSTIME\n         LR    R12,R15            ESTABLISH BASE.\n         USING &CSECT,R12         TELL ASSEMBLER.\n         LR    R11,R1             ESTABLISH BASE.\n         GETMAIN RU,LV=DYNLEN     GET DYNAMIC AREA.\n         LR    R2,R13             SAVE AREA\n         LR    R13,R1             SAVE AREA\n         USING DYNAMIC,R13        TELL ASSEMBLER.\n         LA    R0,DYNAMIC         ZERO\n         LA    R1,DYNLEN            DYNAMIC\n         LR    R14,R0                 STORAGE.\n         SLR   R15,R15\n         MVCL  R0,R14             DO IT.\n         ST    R2,4(,R13)         BACK CHAIN.\n         ST    R13,8(,R2)         FORWARD CHAIN.\n         XC    RC,RC              ASSUME GOOD RC.\n         MVC   RDJFCB(RDJFCBL),XRDJFCB\n         MVC   DCB(DCBL),XDCB                MOVE DCB INTO WORK AREA\n         MVC   CALL(CALLL),XCALL               MOVE DCB INTO WORK AREA\n         MVC   (DCBDDNAM-D)+DCB,=CL8' '\n         L     R2,0(,R11)\n         LH    R3,0(,R2)                LOAD PARM LENGTH\n         LTR   R3,R3                   TEST PARM LENGTH\n         BZ    BADPARM\n         CH    R3,=H'8'                PARM LENGTH <= 8?\n         BH    BADPARM                 NO - BAD PARM\n         BCTR  R3,0                    DEDUCT 1 FOR EX\n         EX    R3,MVCDDNAM             MOVE PARM INTO DCB DDNAME\n         LA    R2,JFCB\n         ST    R2,EXLST                STORE JFCB ADDR INTO EXLST\n         MVI   EXLST,X'87'             SET INDICATOR BYTE\n         LA    R2,EXLST\n         ST    R2,(DCBEXLST-D)+DCB     STORE EXLST ADDR INTO DCB\n         LA    R2,DCB\n         ST    R2,RDJFCB               STORE DCB ADDR INTO RDJFCB LIST\n         MVI   RDJFCB,HIORDER         TURN ON HIGH-ORDER BIT\n         RDJFCB MF=(E,RDJFCB)\n         LTR   R15,R15\n         BNZ   BADPARM\n*        TPUT  JFCB,44\n         LOAD  EP=ISPLINK\n         ST    R0,ISPLINK\n         L     R15,ISPLINK\n         CALL  (15),(=CL8'VREPLACE',=CL8'OUTDSN',=A(L'OUTDSN),OUTDSN), X\n               VL,MF=(E,CALL)\n         LTR   R15,R15\n         BNZ   BADCALL\n         L     R15,ISPLINK\n         CALL  (15),(=CL8'VREPLACE',=CL8'OUTVOL',=A(L'OUTVOL),OUTVOL), X\n               VL,MF=(E,CALL)\n         LTR   R15,R15\n         BNZ   BADCALL\n         L     R15,ISPLINK\n         CALL  (15),(=CL8'VPUT',=C'(OUTDSN OUTVOL)',=CL8'SHARED'),     X\n               VL,MF=(E,CALL)\n         LTR   R15,R15\n         BNZ   BADCALL\n         DELETE EP=ISPLINK\nRETURN   DS    0H\n         LH    R2,RC                  R2 = RC.\n         LR    R1,R13              PREPARE\n         L     R13,4(,R13)         FOR FREEMAIN.\n         FREEMAIN RU,LV=DYNLEN,A=(1)\n         LR    R15,R2              AND RETURN\n         RETURN (14,12),RC=(15)      WITH R15 = RC.\nBADPARM  DS    0H\n         MVC   RC,=F'16'              R2 = RC.\n*        TPUT  =C'BADPARM',7\n         B     RETURN\nBADCALL  DS    0H\n         MVC   RC,=F'16'              R2 = RC.\n*        TPUT  =C'BADCALL',7\n         B     RETURN\nMVCDDNAM MVC   (DCBDDNAM-D)+DCB(*-*),2(R2)\nXRDJFCB  RDJFCB 0,MF=L\nRDJFCBL  EQU   *-XRDJFCB\nXDCB     DCB   DDNAME=DDNAME,MACRF=R,DSORG=PS\nDCBL     EQU   *-XDCB\nXCALL    CALL  ,(,,,,,,,,),VL,MF=L\nCALLL    EQU   *-XCALL\n         LTORG ,\n*********************************************************************\n*                                                                   *\n*        D Y N A M I C   A R E A S.                                 *\n*                                                                   *\n*********************************************************************\nDYNAMIC  DSECT\nSAVE     DS    18F                     SAVE AREA\nEXLST    DS    A\nRC       DS    F\nISPLINK  DS    A\nJFCB     DS    XL176\nOUTDSN   EQU   JFCB,44,C'C'\nOUTVOL   EQU   JFCB+118,6,C'C'\nDCB      DS    XL(DCBL)\nRDJFCB   DS    XL(RDJFCBL)\nCALL     DS    XL(CALLL)\nDYNLEN   EQU   *-DYNAMIC\n         PUSH  PRINT\n         PRINT NOGEN\n         IHADCB\nD        EQU   IHADCB\n         POP   PRINT\nBACK     EQU   X'04',4\nSAVR1    EQU   X'18',4\nHIORDER  EQU   X'80'\nR0       EQU   00\nR1       EQU   01\nR2       EQU   02\nR3       EQU   03\nR4       EQU   04\nR5       EQU   05\nR6       EQU   06\nR7       EQU   07\nR8       EQU   08\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11                 A(PLIST).\nR12      EQU   12                 PROGRAM BASE.\nR13      EQU   13                 A(SAVE AREA).\nR14      EQU   14\nR15      EQU   15\n         END   &CSECT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PRIME": {"ttr": 6664, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00g\\x00g\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 103, "newlines": 103, "modlines": 0, "user": "FILE369"}, "text": "         MACRO\n&LABLE   PRIME &SA=,&BR=12,&START=0,&ID=*,&LV=72,&BR2=,&BR3=\n* SOURCE LEVEL PRIME    V01.M02 85/09/26 18:07 PSYRRS\n         GBLA  &SIZE\n         GBLB  &SASW\n         GBLC  &OPSYS        GLOABAL SWITCH TO DEFINE OPERATING SYSTEM\n         LCLA  &NDW\n         LCLC  &X\n&OPSYS   SETC  'DOS'         OPERATING SYSTEM  'OS' OR 'DOS'\n&OPSYS   SETC   'OS'         'DOS' OR  'OS'\n&SIZE    SETA  &LV\n&SASW    SETB  0\n&X       SETC  '&SYSNDX'\n.*      GORDON M. JOHNSON\n         SPACE 1\n         AIF   (&SYSNDX EQ 1).START\n&LABLE   CSECT\n         AGO   .CONT1\n.START   ANOP\n&LABLE   START &START\n.CONT1   ANOP\n         AIF   ('&ID' EQ 'NO' OR '&OPSYS' EQ 'DOS').SETNOID\n         SAVE  (14,12),,&ID   SAVE REGISTERS AND FORM IDENTIFIER\n         AGO   .CONT2\n.SETNOID ANOP\n         SAVE  (14,12)        SAVE REGISTERS\n.CONT2   ANOP\n         BALR  &BR,0          CREATE BASE REGISTER\n         USING *,&BR\n         AIF   ('&BR' EQ '0').BADBR\n         AIF   ('&BR' EQ '1').BADBR\n         AIF   ('&BR' EQ '2').BADBR\n         AIF   ('&BR' EQ '13').BADBR\n         AIF   ('&BR' EQ '14').BADBR\n         AIF   ('&BR' EQ '15').BADBR\n         AGO   .GOODBR1\n.BADBR   MNOTE 1,'INVALID BASE REGISTER, 0,1,2,13,14,15 NOT ALLOWED BR'\n         SPACE 3\n.GOODBR1 ANOP\n         AIF   (T'&BR2 EQ 'O').NOXTRA\n         AIF   ('&BR' NE '&BR2').OKBR2\n         SPACE 1\n         MNOTE 1,'ERROR  BR AND BR2 EQUAL,  IGNORE BR2'\n* DEFAULT VALUE FOR BR=12\n         SPACE 2\n         AGO   .NOXTRA\n.OKBR2   ANOP\n         AIF   ('&BR2' EQ '0').BADBR2\n         AIF   ('&BR2' EQ '1').BADBR2\n         AIF   ('&BR2' EQ '2').BADBR2\n         AIF   ('&BR2' EQ '13').BADBR2\n         AIF   ('&BR2' EQ '14').BADBR2\n         AIF   ('&BR2' EQ '15').BADBR2\nHERE&X   L     &BR2,=A(HERE&X.+4096)   LOAD SECOND BSE\n         USING HERE&X.+4096,&BR2   SECOND BASE\n         AGO   .TRYBR3\n.BADBR2  MNOTE 1,'INVALID BASE REGISTER, 0,1,2,13,14,15 NOT ALLOWED BR2C\n                '\n         SPACE 1\n.TRYBR3  ANOP\n         AIF   (T'&BR3 EQ 'O').NOXTRA\n         AIF   ('&BR3' NE '&BR2' AND '&BR3' NE '&BR').GOOD3\n         MNOTE 1,'ERROR  BR3 EQUAL TO BR2 OR BR, BR3 IGNORED '\n* DEFAULT VALUE FOR BR=12\n         SPACE 1\n         AGO   .NOXTRA\n.GOOD3   ANOP\n         AIF   ('&BR3' EQ '0').BADBR3\n         AIF   ('&BR3' EQ '1').BADBR3\n         AIF   ('&BR3' EQ '2').BADBR3\n         AIF   ('&BR3' EQ '13').BADBR3\n         AIF   ('&BR3' EQ '14').BADBR3\n         AIF   ('&BR3' EQ '15').BADBR3\n         L     &BR3,=A(HERE&X+2*4096)  LOAD 3RD BASE REG\n         USING HERE&X.+2*4096,&BR3   THIRD BASE\n         AGO   .NOXTRA\n.BADBR3  MNOTE 1,'INVALID BASE REGISTER, 0,1,2,13,14,15 NOT ALLOWED BR3C\n                '\n         SPACE 2\n.NOXTRA  ANOP\n         LR    2,1            SAVE PARAMETER REGISTER\n         AIF   ('&SA' EQ '').DYNMC\n         L     1,=A(&SA)      GET ADDRESS OF SAVE AREA\n         AGO   .END\n.DYNMC   ANOP\n&SASW    SETB  1\n         AIF   ('&OPSYS' NE 'DOS').GETCORE\n&NDW     SETA  (&SIZE+7)/8   COMPUTE NUMBER OF DOUBLE WORDS NEEDED\n         LA    1,NDW&X        SAVEAREA IN DOUBLE WORDS\n         B     SKIP&X        BRANCH OVER SAVE AREA\nNDW&X    DS    &NDW.D        SAVEAREA\nSKIP&X   DS    0H\n         AGO   .END\n.GETCORE ANOP\n         GETMAIN R,LV=&SIZE\n         L     0,20(13)       RESTORE R0 AFTER GETMAIN\n.END     ANOP\n         ST    1,8(13)        STORE FORWARD POINTER\n         ST    13,4(1)        STORE BACKWARD POINTER\n         LR    13,1           SET UP REGISTER FOR SAVE AREA\n         LR    1,2            RESTORE PARAMETER REGISTER\n         SPACE 1\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PRINTOFF": {"ttr": 6667, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x07\\x7f\\x07\\x7f\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 1919, "newlines": 1919, "modlines": 0, "user": "FILE369"}, "text": "PRINTOFF TITLE 'IPO-SUPPLIED PRINT COMMAND                             C\n                        '\n*$DOC@*****************************************************************\n*                                                                     *\n*             MODULE NAME = PRINTOFF                                  *\n*                                                                     *\n*             DESCRIPTIVE NAME =  IPO SUPPLIED PRINT COMMAND FOR      *\n*                TSO FOREGROUND EXECUTION                             *\n*                                                                     *\n*             COPYRIGHT = NONE                                        *\n*                                                                     *\n*             STATUS = RELEASE 01.0 OF IPO                            *\n*                                                                     *\n*             FUNCTION =                                              *\n*                PRINTS A DATASET(S) WHICH IS SEQUENTIAL OR PARTIONED *\n*                ALLOWING THE USER TO SPECIFY OUTPUT CLASS, COPIES,   *\n*                DESTINATION AND HOLD/NOHOLD.  ALSO ALLOWS THE USER   *\n*                TO SPECIFY LIST/NOLIST, PRINT/NOPRINT, VOLUME,       *\n*                OR FOLD/NOFOLD.                                      *\n*                LIST IF PDS MEMBER NAMES ARE ONLY TO BE LISTED.      *\n*                PRINT IF PDS MEMBERS ARE ONLY TO BE PRINTED.         *\n*                                                                     *\n*                MODS=                                                *\n*                .  NEW KEYWORDS FORMS, TRAIN (OR UCS), FCB,      .GTE.\n*                   CAPS (ALIAS OF FOLD), ASIS (ALIAS OF NOFOLD), .GTE.\n*                   TEXT (ASIS,UCS(TN)), PROG, AND NOHEADING.     .GTE.\n*                .  NEW KEYWORDS ASA (FOR DATA SETS CONTAINING    .PRC.\n*                   ASA CONTROLS BUT NOT MARKED AS SUCH),         .PRC.\n*                   SNUM TO SUPPRESS SEQUENCE NUMBERS, AND        .PRC.\n*                   NOMSG TO SUPPRESS TERMINAL MESSAGES.          .PRC.\n*                .  CALL DEFAULT SERVICE ROUTINE.                 .GTE.\n*                .  FREE INPUT DATA SET.                          .GTE.\n*                .  REPLACE CVT MACRO WITH INLINE CODE SO         .PRC.\n*                   ASSEMBLER DOES NOT NEED AMODGEN LIBRARY.      .PRC.\n*                .  GTE MODS RE-TAGGED IN COLUMNS 67-71.          .PRC.\n*                .  GTE MODS FROM CBT TAPE VERSION 92, 23JUL78.   .PRC.\n*                   THIS WAS REPLACED ON  VERSION 128, 01OCT79    .PRC.\n*                   WITH FURTHER GTE MODS NOT INCLUDED HERE.      .PRC.\n*                .  PRC MODS BY BILL GODFREY,                     .PRC.\n*                   PRC COMPUTER CENTER INC, MCLEAN VA.           .PRC.\n*                .  SADSC MODS BY JIM MARSHALL, SAN ANTONIO DATA  .SAD.\n*                   SERVICES CENTER, 8630 BROADWAY, SAN ANTONIO,  .SAD.\n*                   TEXAS  78217    512-828-0201                  .SAD.\n*                   CHANGED THE DEST PARAMETER BECAUSE IF YOU TRY .SAD.\n*                   TO USE 8 CHARACTER DESTINATION ID YOU GET A   .SAD.\n*                   AN INVALID USERID MSG ????  CHANGED SUGGESTED .SAD.\n*                   BY JIM PETERSON                               .SAD.\n*                                                                     *\n*                OPERATION =                                          *\n*                   BUILD PARS, DAIR, AND PUTLINE PARAMETER LISTS.    *\n*                   CALL PARS TO PARSE COMMAND BUFFER.                *\n*                   ALLOCATE DATASET AND DETERMINE IF PDS OR          *\n*                      SEQUENTIAL.                                    *\n*                   DETERMINE WHAT FUNCTIONS WERE TO BE PERFORMED     *\n*                      FOR THIS DATASET IF PDS.                       *\n*                   ALLOCATE SYSOUT DATASETS WHEN SOMETHING IS        *\n*                      FOUND TO BE PRINTED.                           *\n*                   PROCESS NEXT DATASET IN LIST.                     *\n*                   AT END OF LIST CLOSE DATASETS AND FREE ANY        *\n*                      SYSOUT DATASETS.                               *\n*                   DATSETS WILL BE PRINTED AS EITHER VBA OR VBM.     *\n*                                                                     *\n*              NOTES =                                                *\n*                                                                     *\n*                 DEPENDENCIES = CHARACTER SET IS EBCDIC.  REASSEMBLE *\n*                    IF A DIFFERENT CHARACTER SET IS NEEDED.          *\n*                                                                     *\n*                 RESTRICTIONS = DATASETS MUST HAVE LRECL LESS THAN   *\n*                    255 AND MUST BE EITHER FIXED OR VARIABLE FORMAT. *\n*                                                                     *\n*                 REGISTER CONVENTIONS = STANDARD CONVENTIONS.        *\n*                    REGISTERS 0 TO 10 = WORK REGISTERS               *\n*                    REGISTER  11      = UNUSED                       *\n*                    REGISTER  12      = ADDRESSABILITY TO PRINTOFF   *\n*                                        CSECT                        *\n*                    REGISTER  13      = SAVE AREA REGISTER AND       *\n*                                        ADDRESSABILITY TO GETMAINED  *\n*                                        WORK AREA                    *\n*                    REGISTERS 14,15   = WORK REGISTERS               *\n*                                                                     *\n*                PATCH LABEL = PATCH (UNUSED AND INTIALIZED TO        *\n*                   'ZAP*'S)                                          *\n*                                                                     *\n*         TSO COMMAND SYNTAX = PRINTOFF (DATASET LIST)                *\n*             CLASS(SYSOUT CLASS) DEST(DESTID) COPIES(NUMBER)     .SAD.\n*             HOLD/NOHOLD LIST/NOLIST PRINT/NOPRINT FOLD/NOFOLD       *\n*                                                                     *\n*             MODULE TYPE = PROCEDURE                                 *\n*                                                                     *\n*                PROCESSOR = ASM                                      *\n*                                                                     *\n*                MODULE SIZE = 5K BYTES                               *\n*                                                                     *\n*                ATTRIBUTES = SCHEDULER KEY 8, REENTRANT,             *\n*                   PROBLEM PROGRAM STATE                             *\n*                                                                     *\n*             ENTRY POINTS = PRINTOFF (ONLY ENTRY POINT)              *\n*                                                                     *\n*                LINKAGE =                                            *\n*                   FROM TERMINAL MONITOR PROGRAM AS A COMMAND        *\n*                                                                     *\n*             INPUT = REGISTER 1 POINTS TO COMMAND PROCESSOR          *\n*                PARAMETER LIST MAPPED BY IKJCPPL MACRO               *\n*                                                                     *\n*             OUTPUT = NONE                                           *\n*                                                                     *\n*             EXIT - NORMAL = AT PROGRAM END VIA BRANCH REGISTER 14   *\n*                                                                     *\n*                OUTPUT = NONE                                        *\n*                                                                     *\n*                RETURN CODE = ZERO                                   *\n*                                                                     *\n*             EXIT - ERROR = NONE - PROGRAM WILL DISPLAY DECIMAL      *\n*                RETURN CODE AND RETURN VIA BRANCH REGISTER 14        *\n*                                                                     *\n*                OUTPUT = NONE                                        *\n*                                                                     *\n*                RETURN CODE = ZERO                                   *\n*                                                                     *\n*             EXTERNAL REFERENCES =                                   *\n*                                                                     *\n*                ROUTINES = IKJPARS, DAIRFAIL, GNRLFAIL, PUTLINE      *\n*                                                                     *\n*                DATA AREAS = NONE                                    *\n*                                                                     *\n*                CONTROL BLOCKS = CPPL, PPL, DAPL, DCB, DAPB, CVT,    *\n*                   S99RBP, S99RB, S99TUPL, S99TUNIT, S99TUFLD,       *\n*                   GFPARMS, DFPARMS, IOPL, IOPB                      *\n*                                                                     *\n*             TABLES = DATA AREA TO BE GETMAINED.  MAPPED BY DSECT    *\n*                BEGINNING AT LABEL RDATD.                            *\n*                                                                     *\n*             MACROS = SAVE, GETMAIN, CALLTSSR, LINK, TPUT, FREEMAIN, *\n*                   OPEN, PUT, GET, CLOSE, RDJFCB, IKJRLSA, DYNALLOC, *\n*                   DCB, IKJPARM, IKJPOSIT, IKJKEYWD, IKJNAME,        *\n*                   IKJSUBF, IKJIDENT, IKJENDP, IKJDAP08, IKJDAP18,   *\n*                   IKJDAPL, IKJCPPL, IKJPPL, CVT, IEFZB4D0, IKJIOPL, *\n*                   IEFZB4D2, DCBD, IKJEFFGF, IKJEFFDF, PUTLINE       *\n*                                                                     *\n*             CHANGE ACTIVITY = NONE                                  *\n*                                                                     *\n*             MESSAGES =                                              *\n*                                                                     *\n*                BOTH THE DARIFAIL AND GNRLFAIL SERVICE ROUTINES ARE  *\n*                USED TO ISSUE MESSAGES.                              *\n*                THOSE ISSUED BY THE COMMAND ARE FOUND FOLLOWING THE  *\n*                LABEL GNRLERR AND ARE ISSUED USING PUTLINE.          *\n*                                                                     *\n*             ABEND CODES = NONE                                      *\n*                                                                     *\n*$DOC$*****************************************************************\n*\nPRINTOFF CSECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SAVE  (14,12),,HARDCOPY.IPO.&SYSTIME_&SYSDATE SAVE REGISTERS\n         LR    R12,R15                 LOAD REGISTER 12 WITH ENTRY\n*                                      ADDRESS\n         USING PRINTOFF,R12            ESTABLISH ADDRESSABILITY TO\n*                                      PROGRAM CSECT\n         LA    R11,4095(R12)           LOAD REGISTER 11 WITH ENTRY\n*                                      ADDRESS 4095\n         USING PRINTOFF+4095,R11       ESTABLISH ADDRESSABILITY TO THE\n*                                      REST OF THE PROGRAM CSECT\n         LR    R8,R1                   LOAD REGISTER 8 TO PRESERVE\n*                                      POINTER TO COMMAND PROCESSOR\n*                                      PARAMETER LIST\n         GETMAIN R,LV=LDYNAMIC         GETMAIN DYNAMIC WORKAREA\n         LR    R10,R1                  LOAD REGISTER 10 TO PRESERVE\n*                                      POINTER TO WORKAREA\n         ST    R13,4(R10)              STORE ADDRESS OF PREVIOUS\n*                                      SAVEAREA\n         ST    R10,8(,R13)             STORE ADDRESS OF CURRENT\n*                                      SAVEAREA IN PREVIOUS SAVEAREA\n         LR    R13,R10                 LOAD REGISTER 13 WITH ADDRESS OF\n*                                      CURRENT SAVEAREA\n         USING WORKAREA,R13            ESTABLISH ADDRESSABILITY TO\n*                                      DYNAMIC WORKAREA\n*\n***********************************************************************\n*                                                                     *\n*        BUILD PARSE AND DAIR PARAMETER LISTS USING COMMAND           *\n*           PROCESSOR PARAMETER LIST                                  *\n*        INITIALIZE OUTPUT DATA CONTROL BLOCKS IN WORKAREA            *\n*                                                                     *\n***********************************************************************\n*\n         USING CPPL,R8                 ESTABLISH ADDRESSABILITY TO CPPL\n         LA    R4,PPLSECT              LOAD ADDRESS OF PARSE PARAMETER\n*                                      LIST\n         USING PPL,R4                  ESTABLISH ADDRESSABILITY TO PPL\n         LA    R6,DAPLSECT             LOAD ADDRESS OF DAIR PARAMETER\n*                                      LIST\n         USING DAPL,R6                 ESTABLISH ADDRESSABILITY TO DAPL\n         LA    R5,IOPLSECT             LOAD ADDRESS OF PUTLINE\n*                                      PARAMETER LIST\n         USING IOPL,R5                 ESTABLISH ADDRESSABILITY TO IOPL\n         L     R1,CPPLUPT              LOAD POINTER TO USER PROFILE\n*                                      TABLE FROM CPPL\n         L     R2,CPPLECT              LOAD POINTER TO ENVIRONMENT\n*                                      CONTROL TABLE FROM CPPL\n         SLR   R3,R3                   ZERO REGISTER 3\n         ST    R3,ECB                  STORE REGISTER AS ECB FOR PPL\n         LA    R3,ECB                  LOAD ADDRESS OF ECB\n         STM   R1,R3,DFPLSECT          STORE UPT,ECT,ECB IN DFPL  .GTE.\n         STM   R1,R3,PPLSECT           STORE ADDRESS OF UPT, ECT, AND\n*                                      ECB IN PPL\n         STM   R1,R3,DAPLSECT          STORE ADDRESS OF UPT, ECT, AND\n*                                      ECB IN DAPL\n         STM   R1,R3,IOPLSECT          STORE ADDRESS OF UPT, ECT, AND\n*                                      ECB IN IOPL\n         LA    R3,IOPB                 LOAD ADDRESS OF PUTLINE\n*                                      PARAMETER BLOCK\n         ST    R3,IOPLIOPB             STORE IOPB ADDRESS IN IOPL\n         LA    R3,DFPBSECT             GET ADDRESS OF DFPB        .GTE.\n         ST    R3,DFPLSECT+12          PUT IT IN THE DFPL         .GTE.\n         USING  DFPB,R3                                           .GTE.\n         LA     R2,DFPBDSL                                        .GTE.\n         ST     R2,DFPBDSN                                        .GTE.\n         LA     R2,DFPBQUA                                        .GTE.\n         ST     R2,DFPBQUAL                                       .GTE.\n         MVI    DFPBCODE,DFPB04                                   .GTE.\n         MVC    DFPBPSCB,CPPLPSCB                                 .GTE.\n         MVI    DFPBCNTL,DFPBRET                                  .GTE.\n         XC     DFPBCAT(8),DFPBCAT                                .GTE.\n         DROP    R3                                               .GTE.\n         MVC   PPLPCL,PCLADDR          MOVE POINTER TO PARAMETER\n*                                      CONTROL LIST INTO PPL\n         LA    R2,PARSBACK             LOAD ADDRESS OF FULLWORD TO\n*                                      CONTAIN ADDRESS OF PDE RETURNED\n*                                      BY PARS\n         ST    R2,PPLANS               STORE POINTER TO RETURN ADDRESS\n         MVC   PPLCBUF,CPPLCBUF        MOVE POINTER TO COMMAND BUFFER\n*                                      INTO PPL\n         LA    R2,PPLUWA               LOAD ADDRESS OF USER WORK AREA\n         ST    R2,PPLUWA               STORE ADDRESS IN PPL\n         MVC   DAPLPSCB,CPPLPSCB       MOVE POINTER TO PSCB INTO DAPL\n         DROP  R4,R5,R6,R8             DROP ADDRESSABILITY TO CPPL,\n*                                      IOPL, DAPL, AND PPL\n         MVC   OUTPUTA(OUTPUTAL),OUTPUTAC  MOVE ASA DCB CONSTANT INTO\n*                                      ASA DCB IN WORKAREA\n         MVC   OUTPUTM(OUTPUTML),OUTPUTMC  MOVE MACHINE DCB CONSTANT\n*                                      INTO MACHINE DCB IN WORKAREA\n*\n***********************************************************************\n*                                                                     *\n*        CALLTSSR TO PARSE (ENTRY NAME IKJPARS)                       *\n*        ON RETURN PARSBACK -> PDL                                    *\n*        HANDLE ALL ERROR CODES RETURNED BY PARS                      *\n*        IF NECESSARY CALL GENERAL FAIL SERVICE ROUTINE               *\n*                                                                     *\n***********************************************************************\n*\n         CALLTSSR  EP=IKJPARS,MF=(E,PPLSECT)\n*                                      CALL PARS TO PARSE COMMAND\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZ    GOODPARS                YES....GO TO GOOD PARS ROUTINE\n         C     R15,FULL4               SEE IF RETURN CODE IS FOUR\n         BE    RETURN                  YES....PARS ISSUED ERROR\n*                                      MESSAGE.  GO CLEANUP AND RETURN\n         C     R15,FULL20              SEE IF RETURN CODE IS TWENTY\n         BE    RETURN                  YES....VALIDITY CHECKING\n*                                      ROUTINE ISSUED ERROR MESSAGE.\n*                                      GO CLEANUP AND RETURN\n         XC    GFPARMS(GFLENGF),GFPARMS  INITIALIZE PARMLIST FOR\n*                                      GENERAL FAIL TO ZEROS\n         LA    R1,GFPARMS              LOAD ADDRESS OF PARMLIST\n         ST    R1,GFPARMP              STORE ADDRESS AS POINTER TO\n*                                      PARMLIST\n         ST    R15,GFRCODE             STORE RETURN CODE IN PARMLIST\n         LA    R1,GFPARSE              LOAD CALLER ID FOR PARS\n         STH   R1,GFCALLID             STORE CALLER ID IN PARMLIST\n         L     R1,SAVEAREA+4           LOAD ADDRESS OF PEVIOUS\n*                                      SAVEAREA\n         L     R1,24(R1)               LOAD POINTER TO CPPL\n         ST    R1,GFCPPLP              STORE POINTER TO CPPL IN\n*                                      PARMLIST\n         LA    R1,ECB                  LOAD ADDRESS OF OPTIONAL ECB\n         ST    R1,GFECBP               STORE POINTER TO ECB IN\n*                                      PARMLIST\n         SLR   R1,R1                   ZERO REGISTER 1\n         ST    R1,ECB                  SET OPTIONAL ECB TO ZERO\n         LINK  EP=IKJEFF19,MF=(E,GFPARMP)  LINK TO GENERAL FAIL SERVICE\n*                                      ROUTINE TO HANDLE RETURN CODE\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZ    RETURN                  YES....GO CLEANUP AND RETURN\n         LR    R8,R15                  LOAD REGISTER 8 WITH RETURN\n*                                      CODE\n         BAL   R14,SETCODE             GO CONVERT CODE TO DECIMAL\n         PUTLINE OUTPUT=(GNRLERR,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      GENERAL FAIL ERROR MESSAGE\n         PUTLINE OUTPUT=(RETNCD,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DECIMAL RETURN CODE\n         B     RETURN                  GO CLEANUP AND RETURN\n*\n***********************************************************************\n*                                                                     *\n*        SET UP ADDRESSABILITY TO PDL                                 *\n*           AND LOAD REGISTER 6 WITH ADDRESS OF DSNAME PDE            *\n*                                                                     *\n***********************************************************************\n*\nGOODPARS DS    0H\n         L     R9,PARSBACK             LOAD POINTER TO PARS ANSWER\n         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL\n         MVC   PRCKW+0(1),ASAKW+1      SAVE 'ASA'                 .PRC.\n         MVC   PRCKW+1(1),SNUMKW+1     SAVE 'SNUM'                .PRC.\n         MVC   PRCKW+2(1),MSGKW+1      SAVE 'NOMSG'               .PRC.\n         LA    R6,DSNAMES              LOAD POINTER TO DSNAME LIST\n         MVI   VOLBIT,BLANK            BLANK OUT THE VOLUME WORK AREA\n         MVC   VOLUME,VOLBIT           CONTINUE BLANKING THE VOLUME\n         CLC   PVOL(2),HALF1           SEE IF VOLUME SPECIFIED\n         BNE   CHKFOLD                 NO.....GO SEE IF FOLD IS DESIRED\n         L     R7,SVOL                 LOAD POINTER TO VOLUME\n         LH    R8,SVOL+4               LOAD LENGTH OF VOLUME\n         BCTR  R8,0                    DECREMENT LENGTH FOR EXECUTE OF\n*                                      MOVE\n         EX    R8,MOVEVOL              MOVE VOLUME INTO WORK AREA\n         OI    VOLBIT,HIGH             INDICATE VOLUME PRESENT\nCHKFOLD  DS    0H\n         CLC   PFOLD(2),HALF1          SEE IF FOLD SPECIFIED\n         BNE   CHKHEAD                 NO.....GO LOOP THROUGH DSNAMES\n         OI    VOLBIT,LOW              INDICATE FOLD PRESENT\nCHKHEAD  DS    0H\n         CLC   PHEAD(2),HALF1          SEE IF HEAD SPECIFIED\n         BNE   NEXT                    NO.....GO LOOP THROUGH DSNAMES\n         OI    VOLBIT,X'08'              INDICATE HEAD PRESENT\n         DROP  R9                      DROP ADDRESSABILITY TO PDL\n*\n***********************************************************************\n*                                                                     *\n*        LOOP THROUGH DSNAME LIST RETURNED BY PARS                    *\n*                                                                     *\n***********************************************************************\n*\nNEXT     DS    0H\n         LA    R1,PRINTI               LOAD POINTER TO DDNAME TO BE\n*                                      FREED\n         BAL   R2,FREEDD               BRANCH TO FREE ROUTINE\n         LTR   R8,R8                   SEE IF RETURN CODE FROM FREE IS\n*                                      ZERO\n         BNZ   CLOSDCBS                NO.....GO CLOSE DCBS AND RETURN\n         L     R5,0(R6)                LOAD POINTER TO DSNAME\n         LH    R4,4(R6)                LOAD LENGTH OF DSNAME\n         STH   R4,DFPBDSL                                         .GTE.\n         TM    6(R6),X'40'             IS DSNAME IN QUOTES        .GTE.\n         BO    GTENOQ                  YES, BYPASS DEFAULT        .GTE.\n         BCTR  R4,0                    LENGTH MINUS 1 FOR EX      .GTE.\n         MVC   DFPBNAME,BLANKS         PAD WITH BLANKS            .GTE.\n         EX    R4,DFPBMVE              COPY DSNAME                .GTE.\n         LA    R1,DFPLSECT                                        .GTE.\n         MVC   DFPBQUA,=CL8'   '                                  .GTE.\n         CALLTSSR  EP=IKJEHDEF                                    .GTE.\nGTEDEF   LTR    R15,R15                                           .GTE.\nGTEOK    LA     R5,DFPBNAME                                       .GTE.\n         LH     R4,DFPBDSL                                        .GTE.\nGTENOQ   DS    0H                                                 .GTE.\n         STCM  R4,3,DSNLEN             STORE LENGTH OF DSNAME\n         BCTR  R4,0                    DECREMENT LENGTH FOR EXECUTE OF\n*                                      MOVE\n         LA    R8,DAP08                LOAD ADDRESS OF DAPB FOR 08\n         USING DAPB08,R8               ESTABLISH ADDRESSABILITY TO DAPB\n         MVC   DAPB08(DAPB08L),DAPB08C MOVE CONSTANTS INTO DAPB\n         LA    R1,DSNLEN               LOAD POINTER TO DSN BUFFER\n         ST    R1,DA08PDSN             STORE POINTER TO DSN BUFFER IN\n*                                      DAPB\n         MVI   DSNBUF,BLANK            BLANK OUT THE DSNAME BUFFER\n         MVC   DSNBUF+1(43),DSNBUF     FINISH BLANKING OUT THE BUFFER\n         EX    R4,MOVEDSN              MOVE IN THE DSNAME\n         TM    14(R6),HIGH             SEE IF MEMBER NAME IS PRESENT\n         BNO   CHKPASS                 NO.....GO CHECK IF THERE IS A\n*                                      PASSWORD\n         L     R5,8(R6)                LOAD POINTER TO THE MEMBER NAME\n         LH    R4,12(R6)               LOAD LENGTH OF MEMBER NAME\n         BCTR  R4,0                    DECREMENT LENGTH FOR EXECUTE OF\n*                                      MOVE\n         EX    R4,MOVEMEM              MOVE IN THE MEMBER NAME\nCHKPASS  DS    0H\n         MVC   MEMNAME,DA08MNM         MOVE MEMBER NAME INTO HEADER 2\n         TM    22(R6),HIGH             SEE IF PASSWORD IS PRESENT\n         BNO   CHKVOL                  NO.....GO SEE IF VOLUME PRESENT\n         L     R5,16(R6)               LOAD POINTER TO THE PASSWORD\n         LH    R4,20(R6)               LOAD LENGTH OF PASSWORD\n         BCTR  R4,0                    DECREMENT LENGTH FOR EXECUTE OF\n*                                      MOVE\n         EX    R4,MOVEPASS             MOVE IN THE PASSWORD\nCHKVOL   DS    0H\n         TM    VOLBIT,HIGH             SEE IF VOLUME IS PRESENT\n         BNO   ALLOCDD                 NO.....GO ALLOCATE DATA SET\n         MVC   DA08SER,VOLUME          MOVE IN THE VOLUME SERIAL\nALLOCDD  DS    0H\n         SLR   R4,R4                   ZERO REGISTER 4\n         ST    R4,ECB                  STORE REGISTER 4 AS ECB\n         LA    R1,DAPLSECT             LOAD ADDRESS OF DAPL\n         USING DAPL,R1                 ESTABLISH ADDRESSABILITY TO DAPL\n         ST    R8,DAPLDAPB             STORE ADDRESS OF DAPB IN DAPL\n         DROP  R1                      DROP ADDRESSABILITY TO DAPL\n         CALLTSSR EP=IKJDAIR           CALL DAIR TO ALLOCATE DATASET\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZ    OUTPUT                  YES....GO PRINT DATASET\n         MVI   DFID+1,DFDAIR           SET DAIRFAIL ID TO INDICATE DAIR\n         BAL   R2,DAIRFAIL             GO TO DAIRFAIL ROUTINE TO HAVE\n*                                      ERROR MESSAGE PUT OUT\nNOTPMESS DS    0H\n         PUTLINE OUTPUT=(DSNNOTP,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET NOT PRINTED MESSAGE\n         B     EXITMSG                 GO PUT OUT DATASET AND MEMBER\n*                                      NAMES\n*\n***********************************************************************\n*                                                                     *\n*        DETERMINE DATASET TYPE AND CALL PRINT ROUTINE                *\n*                                                                     *\n***********************************************************************\n*\nOUTPUT   DS    0H\n         TM    DA08DSO,DSOPS           X'40' PHYSICAL SEQUENTIAL\n         BO    PRINTIT                 YES....GO PRINT DATASET\n         CLC   DA08MNM,BLANKS          SEE IF MEMBER NAME IS BLANK\n         BNE   PRINTIT                 NO.....GO TREAT AS SEQUENTIAL\n         TM    DA08DSO,DSOPO           X'02' PARTITIONED\n         BO    SCROLLIT                YES....GO SCROLL DIRECTORY\n         DROP  R8                      DROP ADDRESSABILITY TO DAPB\n         PUTLINE OUTPUT=(NOTPSPO,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      NOT PARTITIONED OR SEQUENTIAL\n*                                      MESSAGE\n         B     NOTPMESS                GO PUT NOT PRINTED MESSAGE\n*\n***********************************************************************\n*                                                                     *\n*        READS RECORDS USING GET MOVE                                 *\n*           AND ATTRIBUTES OF GIVEN DATASET                           *\n*        WRITES THESE SAME RECORDS USING PUT MOVE                     *\n*           AND THE INPUT DATASET ATTRIBUTES                          *\n*                                                                     *\n***********************************************************************\n*\nPRINTIT  DS    0H\n         LA    R8,INPUT                LOAD POINTER TO INPUT DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         MVC   INPUT(INPUTL),INPUTC    MOVE INPUT DCB CONSTANT INTO\n*                                      INPUT DCB IN WORKAREA\n         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO OPEN LIST IN WORKAREA\n         OPEN  ((R8),INPUT),MF=(E,OPENLST)  OPEN INPUT DCB\nPRINTS   DS    0H                      BRANCH ADDRESS FOR PRINTING\n*                                      MEMBERS\n         TM    DCBOFLGS,DCBOFOPN       SEE IF DCB OPENED SUCCESSFULLY\n         BNO   NOTPMESS                NO.....GO PUT OUT NOT PRINTED\n*                                      MESSAGE\n         TM    DCBRECFM,DCBRECU        SEE IF RECFM IS UNDEFINED\n         BO    ERRORU                  NO.....GO PUT OUT ERROR MESSAGE\n         BZ    ERRORU                  ZERO...NOT FIXED OR VARIABLE SO\n*                                      GO PUT OUT ERROR MESSAGE\n         CLC   DCBLRECL,HALF256        SEE IF LRECL IS GREATER THAN 256\n         BH    ERRORL                  YES....GO PUT OUT RECORD LENGTH\n*                                      MESSAGE\n         LA    R9,LINE                 LOAD ADDRESS FOR INPUT\n         SLR   R4,R4                   ZERO OUT REGISTER 4\n         ST    R4,LENGTH               STORE ZERO IN LENGTH (PLUS 2\n*                                      RESERVED BYTES) FIELD\n         TM    DCBRECFM,DCBRECV        SEE IF RECFM IS VARIABLE\n         BO    CHKCNTRL                YES....GO PUT OUT DSNAME\n*                                      NO.....RECFM MUST BE FIXED\n*                                      SO CONTINUE\n         A     R9,FULL4                SET TO HAVE FIXED LENGTH\n         LH    R4,DCBLRECL             LOAD LOGICAL RECORD LENGTH\n         A     R4,FULL4                ADD 4 FOR LENGTH FIELD PREFIX\n         CLI   PRCKW+1,1               'SNUM' FOR FIXED LENGTH    .PRC.\n         BNE   *+10                    NO, SKIP NEXT 2 INSTR      .PRC.\n         LA    R0,8                    LENGTH OF SEQUENCE NUMBERS .PRC.\n         SR    R4,R0                   REDUCE LENGTH BY 8         .PRC.\n         STH   R4,LENGTH               STORE IN LENGTH FIELD\nCHKCNTRL DS    0H\n         MVC   HEADER,HEADERC          MOVE HEADER INTO DATA AREA\n         TM    DCBRECFM,DCBRECCM       SEE IF CONTROL IS MACHINE\n         BNO   USEA                    NO.....GO TO USE ASA CONTROL\n         LA    R5,OUTPUTM              LOAD ADDRESS OF OUTPUT DCB FOR\n*                                      MACHINE CODE\n         LA    R4,EJECTM               LOAD ADDRESS OF EJECT DATA\n         MVI   HDRCNTL,SKIPM           MOVE INTO HEADER MACHINE CODE\n*                                      FOR SPACE\n         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN\n         BO    PUTDSN                  YES....GO PUT OUT HEADERS\n         LA    R3,PRINTM               LOAD POINTER TO PRINTM\n         LA    R14,PUTDSN              LOAD ADDRESS FROM RETURN FROM\n*                                      SYSOUT ALLOCATION\n         B     ALLOCOUT                GO TO ALLOCATE SYSOUT\nUSEA     DS    0H\n         TM    DCBRECFM,DCBRECCA       SEE IF CONTROL IS ASA\n         BO    GOODLENA                YES....GO SEE IF DCB IS OPEN\n         CLI   PRCKW+0,1               'ASA'                      .PRC.\n         BE    GOODLENA                YES, BRANCH                .PRC.\n         A     R9,FULL1                SET GET AREA TO ALLOW FOR NO\n*                                      CONTROL\n         A     R4,FULL1                ADD ONE FOR A CONTROL BYTE\n         STH   R4,LENGTH               STORE LENGTH IN PUT AREA\nGOODLENA DS    0H\n         LA    R5,OUTPUTA              LOAD ADDRESS OF OUTPUT DCB FOR\n*                                      ASA CODE\n         LA    R4,EJECTA               LOAD ADDRESS OF EJECT DATA\n         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN\n         BO    PUTDSN                  YES....GO PUT OUT HEADERS\n         LA    R3,PRINTA               LOAD POINTER TO PRINTA\n         BAL   R14,ALLOCOUT            LOAD ADDRESS FOR RETURN AND GO\n*                                      DO SYSOUT ALLOCATION\nPUTDSN   DS    0H\n         PUT   (R5),(R4)               PUT OUT PAGE EJECT\n         TM    VOLBIT,X'08'            TEST FOR NOHEAD            .GTE.\n         BO    GTEHEAD                 NOHEAD                     .GTE.\n         PUT   (R5),HEADER             PUT OUT PAGE 1 HEADER\n         MVC   HEADER2,LDSNAME         MOVE LENGTH AND 'DSNAME=' INTO\n*                                      INTO SECOND HEADER\n         MVC   HEADER2+4(1),HDRCNTL    MOVE IN CONTROL BYTE\n         CLI   MEMNAME,BLANK           SEE IF MEMBER NAME IS BLANK\n         BE    NOMEM                   YES....NO NEED TO PUT IN PARENS\n         MVI   OPENPRN,C'('            MOVE OPEN PAREN INTO DSNAME\n         MVI   CLOSEPRN,C')'           MOVE CLOSE PAREN INTO DSNAME\n         B     PUTHDR2                 GO PUT OUT HEADER 2\nNOMEM    DS    0H\n         MVI   OPENPRN,BLANK           MOVE BLANK INSTEAD OF OPEN AND\n         MVI   CLOSEPRN,BLANK          CLOSE PARENS\nPUTHDR2  DS    0H\n         PUT   (R5),HEADER2            PUT OUT PAGE 1 HEADER 2\n         MVC   HEADER2(4),SPACE        CHANGE HEADER 2 FOR PUT OF BLANK\n*                                      LINE\n         PUT   (R5),HEADER2            PUT OUT BLANK LINE\nGTEHEAD  EQU   * .GTE.\n         MVC   CNTLBYTE,HDRCNTL        MOVE IN SPACE AS CONTROL\n*                                      CHARACTER\n         TM    VOLBIT,LOW              SEE IF FOLD IS REQUESTED\n         BO    FOLDIT                  YES....GO FOLD OUTPUT\n         TM    DCBRECFM,DCBRECV        SEE IF RECFM IS VARIABLE\n         BNO   COPYF                   NO.....GO HANDLE FIXED INPUT\n         CLI   PRCKW+1,1               'SNUM'                     .PRC.\n         BE    COPYS                   YES, BRANCH                .PRC.\n         CLI   PRCKW+0,1               'ASA'                      .PRC.\n         BE    COPYV                   YES, BRANCH                .PRC.\n         TM    DCBRECFM,DCBRECCC       SEE IF THERE IS A CONTROL BYTE\n         BZ    COPYVNO                 NO.....GO TO ADD CONTROL FOR\n*                                      VARIABLE\nCOPYV    DS    0H\n         GET   INPUT,(R9)              GET INPUT RECORD\n         PUT   (R5),LINE               PUT OUT OUTPUT LINE\n         B     COPYV                   GO GET NEXT RECORD\n*\nCOPYVNO  DS    0H\n         GET   INPUT,(R9)              GET INPUT RECORD INTO LINE+1\n         SLR   R15,R15                 ZERO REGISTER 15 FOR INSERT\n         ICM   R15,7,LENGTH+1          INSERT LENGTH AND RESERVED BYTE\n         A     R15,FULL256             ADD 1 TO LENGTH\n         STCM  R15,7,LENGTH            STORE LENGTH AND RESERVED BYTE\n         MVC   CNTLBYTE,HDRCNTL        MOVE IN CONTROL SAVED IN HEADER\n         PUT   (R5),LINE               PUT OUT LINE\n         B     COPYVNO                 GO GET NEXT INPUT RECORD\n*\nCOPYS    CLI   PRCKW+0,1               'ASA' RECFM V              .PRC.\n         BE    COPYVS                  YES, BRANCH                .PRC.\n         TM    DCBRECFM,DCBRECCC       SEE IF THERE IS A CONTROL  .PRC.\n         BZ    COPYVNOS                NO.....GO TO ADD CONTROL   .PRC.\n*                                                                 .PRC.\nCOPYVS   DS    0H                                                 .PRC.\n         GET   INPUT,(R9)              GET INPUT RECORD           .PRC.\n         MVC   8(4,R9),0(R9)           SHIFT PREFIX RIGHT 8       .PRC.\n         LH    R15,8(,R7)              GET LENGTH                 .PRC.\n         LA    R0,8                    LENGTH OF SEQUENCE NUM     .PRC.\n         SLR   R15,R0                  REDUCE LENGTH BY 8         .PRC.\n         STH   R15,8(,R9)              STORE NEW LENGTH           .PRC.\n         PUT   (R5),LINE+8             PUT OUT OUTPUT LINE        .PRC.\n         B     COPYVS                  GO GET NEXT RECORD         .PRC.\n*                                                                 .PRC.\nCOPYVNOS DS    0H                                                 .PRC.\n         GET   INPUT,(R9)              GET INPUT RECORD , LINE+1  .PRC.\n         MVC   7(4,R9),0(R9)           LENGTH TO LINE+8           .PRC.\n         LH    R15,7(,R9)              GET LENGTH FROM LINE+8     .PRC.\n         LA    R0,7                    LENGTH OF SEQ NUM MINUS 1  .PRC.\n         SLR   R15,R0                  REDUCE LENGTH              .PRC.\n         STH   R15,7(,R9)              STORE NEW LENGTH           .PRC.\n         MVC   CNTLBYTE+8,HDRCNTL      MOVE IN CONTROL            .PRC.\n         PUT   (R5),LINE+8             PUT OUT LINE               .PRC.\n         B     COPYVNOS                GO GET NEXT INPUT RECORD   .PRC.\n*                                                                 .PRC.\nCOPYF    DS    0H\n         GET   INPUT,(R9)              GET INPUT RECORD\n         PUT   (R5),LINE               PUT OUT OUTPUT LINE\n         B     COPYF                   GO GET NEXT RECORD\n*\nFOLDIT   DS    0H\n         TM    DCBRECFM,DCBRECV        SEE IF RECFM IS VARIABLE\n         BNO   FOLDF                   NO.....GO HANDLE FIXED INPUT\n         CLI   PRCKW+1,1               'SNUM'                     .PRC.\n         BE    FOLDS                   YES, BRANCH                .PRC.\n         CLI   PRCKW+0,1               'ASA'                      .PRC.\n         BE    FOLDV                   YES, BRANCH                .PRC.\n         TM    DCBRECFM,DCBRECCC       SEE IF THERE IS A CONTROL BYTE\n         BZ    FOLDVNO                 NO.....GO TO ADD CONTROL FOR\n*                                      VARIABLE\nFOLDV    DS    0H\n         GET   INPUT,(R9)              GET INPUT RECORD\n         LH    R15,LENGTH              LOAD LENGTH OF LINE\n         SH    R15,HALF6               DECREMENT FOR EXECUTE\n         EX    R15,FOLDLINE            EXECUTE FOLD OF LINE\n         PUT   (R5),LINE               PUT OUT OUTPUT LINE\n         B     FOLDV                   GO GET NEXT RECORD\n*\nFOLDVNO  DS    0H\n         GET   INPUT,(R9)              GET INPUT RECORD INTO LINE+1\n         SLR   R15,R15                 ZERO REGISTER 15 FOR INSERT\n         ICM   R15,7,LENGTH+1          INSERT LENGTH AND RESERVED BYTE\n         A     R15,FULL256             ADD 1 TO LENGTH\n         STCM  R15,7,LENGTH            STORE LENGTH AND RESERVED BYTE\n         MVC   CNTLBYTE,HDRCNTL        MOVE IN CONTROL SAVED IN HEADER\n         LH    R15,LENGTH              LOAD LENGTH OF LINE\n         SH    R15,HALF6               DECREMENT FOR EXECUTE\n         EX    R15,FOLDLINE            EXECUTE FOLD OF LINE\n         PUT   (R5),LINE               PUT OUT LINE\n         B     FOLDVNO                 GO GET NEXT INPUT RECORD\n*\nFOLDS    CLI   PRCKW+0,1               'ASA' RECFM V              .PRC.\n         BE    FOLDVS                  YES, BRANCH                .PRC.\n         TM    DCBRECFM,DCBRECCC       SEE IF THERE IS A CONTROL  .PRC.\n         BZ    FOLDVNOS                NO.....GO TO ADD CONTROL   .PRC.\n*                                                                 .PRC.\nFOLDVS   DS    0H                                                 .PRC.\n         GET   INPUT,(R9)              GET INPUT RECORD           .PRC.\n         MVC   8(4,R9),0(R9)           SHIFT PREFIX RIGHT 8       .PRC.\n         LH    R15,8(,R7)              GET LENGTH                 .PRC.\n         LA    R0,8                    LENGTH OF SEQUENCE NUM     .PRC.\n         SLR   R15,R0                  REDUCE LENGTH BY 8         .PRC.\n         STH   R15,8(,R9)              STORE NEW LENGTH           .PRC.\n         SH    R15,HALF6               DECREMENT FOR EXECUTE      .PRC.\n         EX    R15,FOLDLINS            EXECUTE FOLD OF LINE       .PRC.\n         PUT   (R5),LINE+8             PUT OUT OUTPUT LINE        .PRC.\n         B     FOLDVS                  GO GET NEXT RECORD         .PRC.\n*                                                                 .PRC.\nFOLDVNOS DS    0H                                                 .PRC.\n         GET   INPUT,(R9)              GET INPUT RECORD , LINE+1  .PRC.\n         MVC   7(4,R9),0(R9)           LENGTH TO LINE+8           .PRC.\n         LH    R15,7(,R9)              GET LENGTH FROM LINE+8     .PRC.\n         LA    R0,7                    LENGTH OF SEQ NUM MINUS 1  .PRC.\n         SLR   R15,R0                  REDUCE LENGTH              .PRC.\n         STH   R15,7(,R9)              STORE NEW LENGTH           .PRC.\n         SH    R15,HALF6               DECREMENT FOR EXECUTE      .PRC.\n         EX    R15,FOLDLINS            EXECUTE FOLD OF LINE       .PRC.\n         MVC   CNTLBYTE+8,HDRCNTL      MOVE IN CONTROL            .PRC.\n         PUT   (R5),LINE+8             PUT OUT LINE               .PRC.\n         B     FOLDVNOS                GO GET NEXT INPUT RECORD   .PRC.\n*                                                                 .PRC.\nFOLDF    DS    0H\n         LH    R4,LENGTH               LOAD LENGTH INTO REGISTER 4\n         SH    R4,HALF6                SUBTRACT TO SET UP FOR EXECUTE\nFOLDFLP  DS    0H\n         GET   INPUT,(R9)              GET INPUT RECORD\n         EX    R4,FOLDLINE             FOLD DATA\n         PUT   (R5),LINE               PUT OUT OUTPUT LINE\n         B     FOLDFLP                 GO GET NEXT RECORD\nFOLDLINE OC    DATA(0),BLANKS          OC INSTRUCTION TO BE EXECUTED\nFOLDLINS OC    DATA+8(0),BLANKS        OC INSTRUCTION TO BE EX    .PRC.\n*\nEXIT     DS    0H\n         TM    DCBOFLGS,DCBOFOPN       SEE IF INPUT DCB IS OPEN\n         BNO   EXITMSG                 NO....GO PUT OUT DATASET AND\n*                                      MEMBER NAMES\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST IN WORKAREA\n         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB\nEXITMSG  DS    0H\n         CLI   PRCKW+2,1               'NOMSG'                    .PRC.\n         BE    CONTINUE                BYPASS MESSAGES IF 'NOMSG' .PRC.\n         PUTLINE OUTPUT=(DSNMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATA SET NAME MESSAGE\n*        LH    R4,4(,R6)               LOAD LENGTH OF DSNAME     *.GTE.\n         LH    R4,DFPBDSL              LOAD LENGTH OF DSNAME      .GTE.\n         A     R4,FULL4                INCREMENT LENGTH FOR PUTLINE\n         SLL   R4,16                   SHIFT LENGTH TO HIGH ORDER BYTES\n         STCM  R4,15,DSNLENP           STORE LENGTH OF PUTLINE\n         PUTLINE OUTPUT=(DSNLENP,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATA SET NAME MESSAGE\n         TM    14(R6),HIGH             SEE IF MEMBER NAME IS PRESENT\n         BNO   CONTINUE                NO.....GO CHECK FOR ANOTHER\n*                                      DATASET NAME\n         PUTLINE OUTPUT=(MEMMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATA SET NAME MESSAGE\n         LH    R4,12(R6)               LOAD LENGTH OF MEMBER NAME\n         A     R4,FULL4                INCREMENT LENGTH FOR PUTLINE\n         SLL   R4,16                   SHIFT LENGTH TO HIGH ORDER BYTES\n         STCM  R4,15,MEMNAMEL          STORE LENGTH OF PUTLINE\n         PUTLINE OUTPUT=(MEMNAMEL,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      MEMBER NAME\n         B     CONTINUE                GO CONTINUE WITH NEXT DATASET\n         DROP  R8                      DROP ADDRESSABILITY TO INPUT DCB\nERRORL   DS    0H\n         PUTLINE OUTPUT=(DSNISL,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET NOT PRINTED DUE TO\n*                                      RECORD LENGTH TOO LONG MESSAGE\n         B     EXIT                    GO SEE IF INPUT DCB IS OPEN\nERRORU   DS    0H\n         PUTLINE OUTPUT=(DSNISU,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET NOT PRINTED DUE TO\n*                                      UNDEFINED RECORD FORMAT MESSAGE\n         B     EXIT                    GO SEE IF INPUT DCB IS OPEN\nERRI     DS    0H\n         PUTLINE OUTPUT=(SYNADI,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET NOT PRINTED DUE TO SYNAD\n*                                      ERROR ON INPUT DATASET MESSAGE\n         B     EXIT                    GO SEE IF INPUT DCB IS OPEN\nERRO     DS    0H\n         PUTLINE OUTPUT=(SYNADO,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET NOT PRINTED DUE TO\n*                                      UNDEFINED RECORD FORMAT MESSAGE\n         B     CLOSDCBS                GO CLOSE OPEN DCBS AND RETURN\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        READ THE DIRECTORY OF A PDS                                  *\n*           THEN EITHER LIST MEMBER NAMES,                            *\n*           PRINT MEMBERS,                                            *\n*           OR LIST MEMBER NAMES AND PRINT MEMBERS                    *\n*                                                                     *\n***********************************************************************\n*\nSCROLLIT DS    0H\n         ST    R6,SAVER6               SAVE REGISTER 6\n         L     R9,PARSBACK             LOAD ADDRESS PARS ANSWER\n         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL\n         CLC   PLIST,HALF2             SEE IF NOLIST SPECIFIED\n         BL    CONTSCR                 LOW....CONTINUE WITH SCROLL\n         CLC   PPRINT,HALF2            SEE IF NOPRINT SPECIFIED\n         BE    CONTINUE                YES....SKIP SCROLL\n         DROP  R9                      DROP ADDRESSABILITY TO PDL\nCONTSCR  DS    0H\n         LA    R8,DIRECT               LOAD POINTER TO DIRECTORY DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         MVC   DIRECT(DIRECTL),DIRECTC MOVE DIRECTORY DCB CONSTANT INTO\n*                                      DIRECTORY DCB IN WORKAREA\n         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO OPEN LIST IN WORKAREA\n         OPEN  ((R8),INPUT),MF=(E,OPENLST)  OPEN DIRECTORY DCB\n         TM    DCBOFLGS,DCBOFOPN       SEE IF DCB OPENED SUCCESSFULLY\n         BNO   NOTPMESS                NO.....GO PUT OUT NOT PRINTED\n*                                      MESSAGE\n         DROP  R8                      DROP ADDRESSABILITY TO DCB\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        GETMAIN MEMBER TABLE FOR STORAGE OF DIRECTORY NAMES, ETC.    *\n*           INITIALIZE TABLE                                          *\n*                                                                     *\n***********************************************************************\n*\n         L     R0,MEMDATL              LOAD LENGTH OF GETMAIN FOR\n*                                      MEMBER TABLE\n         LR    R2,R0                   SAVE IN REGISTER 2\n         GETMAIN R,LV=(0)              GETMAIN MEMBER TABLE STORAGE\n         ST    R1,MEMTABLE             SAVE ADDRESS OF MEMBER TABLE\n         ST    R1,PRESENT              ALSO SAVE ADDRESS AS TABLE\n*                                      IN USE\n         LA    R3,0(R2,R1)             LOAD ADDRESS OF END OF TABLE\n         ST    R3,ENDTABLE             STORE ADDRESS OF TABLE END\n         SLR   R4,R4                   ZERO REGISTER 4\n         ST    R4,0(R1)                STORE AS FIRST WORD OF MEMBER\n*                                      TABLE\n         LA    R4,8(R1)                LOAD REGISTER 4 AS POINTER TO\n*                                      THE FIRST ENTRY\n         USING MEMDSECT,R4             ESTABLISH ADDRESSABILITY TO\n*                                      MEMBER TABLE DSECT\n         SLR   R5,R5                   INITIALIZE MEMBER COUNT TO ZERO\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        READ DIRECTORY AND BUILD MEMBER TABLE                        *\n*                                                                     *\n***********************************************************************\n*\nGETDIR   EQU   *\n         GET   (R8),DATA               GET A DIRECTORY BLOCK\n         CLC   DATA,HALF12             SEE IF BLOCK IS UNUSED\n         BL    FREEBLK                 YES....GO HANDLE DIRECTORY END\n         LA    R9,DATA+2               LOAD POINTER TO FIRST DIRECTORY\n*                                      ENTRY\n         SLR   R7,R7                   ZERO REGISTER 7 FOR INSERT\n         ICM   R7,3,DATA               INSERT LENGTH USED OF THIS BLOCK\n         LA    R7,DATA-1(R7)           LOAD LAST USED BYTE OF BLOCK\nUNBLOCK  DS    0H\n         MVC   MEMNTTR,0(R9)           PUT NAME AND TTR IN TABLE\n         MVC   CFIELD,11(R9)           PUT C FIELD IN TABLE\n         CLI   MEMBER,HEXFF            SEE IF LAST MEMBER\n         BE    FREEBLK                 YES....GO HANDLE DIRECTORY END\n         IC    R6,CFIELD               INSERT CFIELD INTO REGISTER 6\n         SLL   R6,27                   SHIFT OUT HIGH ORDER BITS\n         SRL   R6,26                   SHIFT RIGHT TO GET LENGTH OF\n*                                      USER DATA\n         LA    R6,12(R6)               ADD STANDARD ENTRY LENGTH\n         LA    R4,MEMSECTN             LOAD PINTER TO NEXT TABLE ENTRY\n         LA    R5,1(R5)                INCREMENT NUMBER OF MEMBERS IN\n*                                      TABLE\n         C     R4,ENDTABLE             SEE IF END OF TABLE\n         BL    NEXTNTRY                LOW.....GO PROCESS NEXT ENTRY\n         LR    R0,R2                   LOAD LENGTH OF TABLE FOR GETMAIN\n         GETMAIN R,LV=(0)              GET NEXT TABLE\n         L     R14,PRESENT             LOAD REGISTER 14 WITH ADDRESS OF\n*                                      LAST TABLE\n         ST    R1,0(R14)               CHAIN MEMBER TABLES TOGETHER\n         ST    R1,PRESENT              ALSO SAVE ADDRESS AS TABLE\n*                                      IN USE\n         LA    R3,0(R2,R1)             LOAD ADDRESS OF TABLE END\n         ST    R3,ENDTABLE             STORE ADDRESS OF TABLE END\n         SLR   R4,R4                   ZERO REGISTER 4\n         ST    R4,0(R1)                STORE AS FIRST WORD OF MEMBER\n*                                      TABLE\n         LA    R4,8(R1)                LOAD REGISTER 4 AS POINTER TO\n*                                      THE FIRST ENTRY\n         STH   R5,4(R14)               STORE MEMBER COUNT IN OLD TABLE\n         SLR   R5,R5                   INITIALIZE MEMBER COUNT TO ZERO\nNEXTNTRY DS    0H\n         BXLE  R9,R6,UNBLOCK           INCREMENT REGISTER 9 WITH\n*                                      REGISTER 6 AND BRANCH\n*                                      LESS THAN OR EQUAL TO\n*                                      REGISTER 7 TO UNBLOCK\n         B     GETDIR                  NO.....GO GET NEXT DIRECTORY\n*                                      BLOCK\n         DROP  R4                      DROP ADDRESSABILITY TO TABLE\n*\n***********************************************************************\n*                                                                     *\n*        LIST MEMBERS IF:                                             *\n*           LIST SPECIFIED OR                                         *\n*           BOTH PRINT AND NOLIST WERE NOT SPECIFIED                  *\n*                                                                     *\n***********************************************************************\n*\nFREEBLK  DS    0H\n         MVC   OPENLST,OPENCLOS        MOVE CONSTANT INTO CLOSE LIST\n         CLOSE ((R8),),MF=(E,OPENLST)  CLOSE DIRECTORY DCB\n         L     R2,PRESENT              LOAD POINTER TO LAST TABLE\n         STH   R5,4(R2)                STORE COUNT OF MEMBERS\n         L     R4,MEMTABLE             LOAD POINTER TO FIRST TABLE\n         CLC   4(2,R4),HALF0           SEE IF THERE WERE ANY MEMBERS\n         BE    ENDMEMB                 ZERO...GO FREE MEMBER TABLE\n         LA    R8,INPUT                LOAD POINTER TO INPUT DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         MVC   INPUT(INPUTL),INPUTC    MOVE INPUT DCB CONSTANT INTO\n*                                      INPUT DCB IN WORKAREA\n         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO OPEN LIST IN WORKAREA\n         LA    R1,XLIST                LOAD ADDRESS OF EXIT LIST\n         ST    R1,DCBEXLST             STORE ADDRESS OF EXIT LIST IN\n*                                      DCB\n         LA    R1,SEXIT                LOAD ADDRESS OF EODAD EXIT\n         ST    R1,DCBEODAD             STORE ADDRESS EODAD IN DCB\n         LA    R2,JFCBAREA             LOAD ADDRESS OF JFCBAREA\n         ST    R2,XLIST                STORE ADDRESS IN EXIT LIST\n         MVI   XLIST,X'87'             SET END OF LIST AND JFCB BYTE\n         MVC   RDJL,OPENCLOS           MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO READJFCB LIST IN\n*                                      WORKAREA\n         RDJFCB (INPUT,),MF=(E,RDJL)   READ JFCB INTO JFCBAREA\n         MVC   JFCBELNM,8(R4)          MOVE MEMBER NAME INTO JFCB\n         OI    JFCBIND1,JFCPDS         SET JFCB TO INDICATE PDS MEMBER\n         MVI   JFCDSRG1,HEX00          SET JFCB TO REMOVE OTHER DSORG\n*                                      INDICATORS\n         OPEN  ((R8),INPUT),TYPE=J,MF=(E,OPENLST)  OPEN INPUT DCB\n         L     R9,PARSBACK             LOAD ADDRESS PARS ANSWER\n         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL\n         CLC   PLIST,HALF2             SEE IF NOLIST SPECIFIED\n         BE    NOLIST                  YES....SKIP LISTING\n         CLC   PLIST,HALF1             SEE IF LIST SPECIFIED\n         BE    LISTIT                  YES....GO LISTIT\n         CLC   PPRINT,HALF1            SEE IF PRINT SPECIFIED\n         BE    NOLIST                  YES....SKIP LISTING\n         DROP  R9                      DROP ADDRESSABILITY TO PDL\nLISTIT   DS    0H\n         MVC   HEADER,HEADERM          MOVE HEADER INTO DATA AREA\n         TM    DCBRECFM,DCBRECCM       SEE IF CONTROL IS MACHINE\n         DROP  R8                      DROP ADDRESSABILITY TO DCB\n         BNO   SUSEA                   NO.....GO TO USE ASA CONTROL\n         LA    R5,OUTPUTM              LOAD ADDRESS OF OUTPUT DCB FOR\n*                                      MACHINE CODE\n         LA    R4,EJECTM               LOAD ADDRESS OF EJECT DATA\n         MVI   HDRCNTL,SKIPM           MOVE INTO HEADER MACHINE CODE\n*                                      FOR SPACE\n         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN\n         BO    SPUTDSN                 YES....GO PUT OUT HEADERS\n         LA    R3,PRINTM               LOAD POINTER TO PRINTM\n         LA    R14,SPUTDSN             LOAD ADDRESS FOR RETURN FROM\n*                                      SYSOUT ALLOCATION\n         B     ALLOCOUT                GO TO ALLOCATE SYSOUT\nSUSEA    DS    0H\n         LA    R5,OUTPUTA              LOAD ADDRESS OF OUTPUT DCB FOR\n*                                      ASA CODE\n         LA    R4,EJECTA               LOAD ADDRESS OF EJECT DATA\n         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN\n         BO    SPUTDSN                 YES....GO PUT OUT HEADERS\n         LA    R3,PRINTA               LOAD POINTER TO PRINTA\n         BAL   R14,ALLOCOUT            LOAD ADDRESS FOR RETURN AND GO\n*                                      DO SYSOUT ALLOCATION\nSPUTDSN  DS    0H\n         PUT   (R5),(R4)               PUT OUT PAGE EJECT\n         PUT   (R5),HEADER             PUT OUT PAGE 1 HEADER\n         MVC   HEADER2,LDSNAME         MOVE LENGTH AND 'DSNAME=' INTO\n*                                      INTO SECOND HEADER\n         MVC   HEADER2+4(1),HDRCNTL    MOVE IN CONTROL BYTE\n         MVI   OPENPRN,BLANK           BLANK OUT MEMBER NAME\n         MVC   MEMNAME(9),OPENPRN      FINISH BLANKING OUT MEMBER NAME\n         PUT   (R5),HEADER2            PUT OUT PAGE 1 HEADER 2\n         L     R2,MEMTABLE             LOAD ADDRESS OF FIRST TABLE\n         MVC   LENGTH,HALF85           SET LENGTH TO 85 BYTES\n         MVC   LENGTH+2,HALF0          ZERO RESERVED BYTES\n         MVC   CNTLBYTE,HDRCNTL        MOVE IN HEADER CONTROL BYTE\n*\n***********************************************************************\n*                                                                     *\n*        LIST MEMBER NAMES                                            *\n*                                                                     *\n***********************************************************************\n*\nSCROLLER DS    0H\n         LA    R10,50                  LOAD LINE COUNT\n         ST    R2,PRESENT              SAVE ADDRESS OF CURRENT TABLE\n         LH    R7,4(R2)                LOAD NUMBER OF MEMBERS IN TABLE\n         LTR   R7,R7                   SEE IF THERE ARE ENTRIES\n         BZ    NOLIST                  NO.....GO PRINT MEMBERS\n         LA    R2,8(R2)                LOAD ADDRESS OF FIRST MEMBER\n         USING MEMDSECT,R2             ESTABLISH ADDRESSABILITY TO\n*                                      MEMBER TABLE ENTRY\nLOOP1    DS    0H\n         LA    R6,DATA                 LOAD ADDRESS OF OUTPUT BUFFER\n         MVI   DATA,BLANK              BLANK OUT OUTPUT BUFFER\n         MVC   DATA+1(79),DATA         FINISH BLANKING BUFFER\n         TM    CFIELD,HIGH             SEE IF THIS IS AN ALIAS\n         BZ    NOTALIAS                NO.....CONTINUE WITH MAIN NAME\n         BAL   R14,LOOKLOOP            GO LOOK FOR MAIN NAME\nNOTALIAS DS    0H\n         MVC   2(8,R6),MEMBER          PUT MEMBER NAME IN OUTPUT BUFFER\n         ST    R2,SAVER2               SAVE REGISTER 2\n         LA    R3,2                    LOAD NUMBER OF COLUMNS LEFT\n         LA    R8,1                    LOAD ENTRY NUMBER\nLOOP2    LA    R8,50(R8)               LOAD POINTER TO NEXT COLUMN\n*                                      ENTRY\n         CR    R8,R7                   SEE IF VALID ENTRY\n         BH    END2                    NO.....GO PRINT LINE\n         LA    R2,600(R2)              LOAD POINTER TO MEMBER NAME\n         LA    R6,30(R6)               LOAD POINTER TO NEXT OUTPUT\n*                                      BUFFER LOCATION\n         TM    CFIELD,HIGH             SEE IF THIS IS AN ALIAS\n         BZ    NOTAL2                  NO.....CONTINUE WITH MAIN NAME\n         BAL   R14,LOOKLOOP            GO LOOK FOR MAIN NAME\nNOTAL2   DS    0H\n         MVC   2(8,R6),MEMBER          PUT MEMBER NAME IN OUTPUT BUFFER\n         BCT   R3,LOOP2                DECREMENT COLUMN COUNT\nEND2     DS    0H\n         PUT   (R5),LINE               PUT OUT OUTPUT LINE\n         L     R2,SAVER2               RELOAD REGISTER 2\n         LA    R2,MEMSECTN             LOAD POINTER TO NEXT MEMBER NAME\n         BCT   R10,MOREROW             DECREMENT ROW COUNT\n         PUT   (R5),(R4)               PUT OUT PAGE EJECT WHEN ZERO\n         B     LOOP3                   RESET COUNTERS\nMOREROW  DS    0H\n         BCT   R7,LOOP1                DECREMENT MEMBER COUNT FOR\n*                                      CURRENT TABLE\nLOOP3    L     R2,PRESENT              LOAD POINTER TO CURRENT TABLE\n         L     R2,0(R2)                LOAD POINTER TO NEXT TABLE\n         LTR   R2,R2                   SEE IF IT WAS THE LAST TABLE\n         BNZ   SCROLLER                NO.....GO LIST OUT NEXT TABLE\n*\n***********************************************************************\n*                                                                     *\n*        PRINT MEMBERS IF:                                            *\n*           PRINT SPECIFIED OR                                        *\n*           BOTH LIST AND NOPRINT WERE NOT SPECIFIED                  *\n*                                                                     *\n***********************************************************************\n*\nNOLIST   DS    0H\n         L     R9,PARSBACK             LOAD ADDRESS PARS ANSWER\n         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL\n         CLC   PPRINT,HALF2            SEE IF NOPRINT SPECIFIED\n         BE    ENDMEMB                 YES....GO SKIP PRINT\n         CLC   PPRINT,HALF1            SEE IF PRINT SPECIFIED\n         BE    CONTPRT                 YES....GO PRINT MEMBERS\n         CLC   PLIST,HALF1             SEE IF LIST SPECIFIED\n         BE    ENDMEMB                 YES....GO SKIP PRINT\n         DROP  R9                      DROP ADDRESSABILITY TO PDL\nCONTPRT  DS    0H\n         L     R6,SAVER6               RESTORE REGISTER 6\n         LA    R8,INPUT                LOAD ADDRESS OF INPUT DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         TM    DCBRECFM,DCBRECU        SEE IF RECFM IS UNDEFINED\n         BO    ERRORU                  NO.....GO PUT OUT ERROR MESSAGE\n         BZ    ERRORU                  ZERO...NOT FIXED OR VARIABLE SO\n*                                      GO PUT OUT ERROR MESSAGE\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST IN WORKAREA\n         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB\n         DROP  R8                      DROP ADDRESSABILITY TO INPUT DCB\n         CLI   PRCKW+2,1               'NOMSG'                    .PRC.\n         BE    PRCNOM                  BYPASS MESSAGE IF 'NOMSG'  .PRC.\n         PUTLINE OUTPUT=(PRTMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET PRINT MESSAGE\n         LH    R4,4(R6)                LOAD LENGTH OF DSNAME\n         A     R4,FULL4                INCREMENT LENGTH FOR PUTLINE\n         SLL   R4,16                   SHIFT LENGTH TO HIGH ORDER BYTES\n         STCM  R4,15,DSNLENP           STORE LENGTH OF PUTLINE\n         PUTLINE OUTPUT=(DSNLENP,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATA SET NAME MESSAGE\nPRCNOM   EQU   *                                                  .PRC.\n         L     R2,MEMTABLE             LOAD ADDRESS OF FIRST MEMBER\n*                                      TABLE\n         LH    R3,4(R2)                LOAD NUMBER OF MEMBERS IN TABLE\n         LTR   R3,R3                   SEE IF THERE ARE ANY MEMBERS\n         BZ    ENDMEMB                 NO.....GO TO END OF SCROLLER\n         ST    R2,PRESENT              SAVE ADDRESS OF CURRENT TABLE\n         LA    R2,8(R2)                LOAD POINTER TO MEMBER NAME\nNEXTMEMB DS    0H\n         TM    CFIELD,HIGH             SEE IF THIS IS AN ALIAS ENTRY\n         BO    AGAIN                   YES....DO NOT PRINT IT\nPRINTMEM DS    0H\n         MVC   MEMNAME,MEMBER          MOVE MEMBER NAME INTO HEADER\n         MVC   JFCBELNM,MEMBER         MOVE MEMBER NAME INTO JFCBAREA\n         MVC   OPENLST,OPENCLOS        MOVE CONSTANT INTO OPEN LIST\n         OPEN  ((R8),INPUT),TYPE=J,MF=(E,OPENLST)\n*                                      OPEN INPUT DCB\n         STM   R2,R3,SAVER2            SAVE REGISTERS 2 AND 3\n         B     PRINTS                  GO PRINT MEMBER\nSEXIT    DS    0H\n         LM    R2,R3,SAVER2            RESTORE REGISTERS 2 AND 3\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST IN WORKAREA\n         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB\nAGAIN    DS    0H\n         LA    R2,MEMSECTN             LOAD ADDRESS OF NEXT MEMBER\n         BCT   R3,NEXTMEMB             BRANCH TO HANDLE NEXT MEMBER\n         L     R14,PRESENT             ZERO...LOAD CURRENT TABLE\n*                                      ADDRESS\n         L     R2,0(R14)               LOAD ADDRESS OF NEXT TABLE\n         LTR   R2,R2                   SEE IF ZERO, LAST TABLE\n         BZ    ENDMEMB                 NO.....GO HANDLE END OF MEMBERS\n         ST    R2,PRESENT              SAVE ADDRESS OF CURRENT TABLE\n         LH    R3,4(R2)                LOAD NUMBER OF MEMBERS IN NEXT\n*                                      TABLE\n         LTR   R3,R3                   SEE IF ANY MEMBERS IN TABLE\n         BZ    ENDMEMB                 NO.....GO HANDLE END OF MEMBERS\n         LA    R2,8(R2)                LOAD POINTER TO MEMBER NAME\n         B     NEXTMEMB                GO GET NEXT MEMBER\nENDMEMB  DS    0H\n         L     R2,MEMTABLE             LOAD POINTER TO FIRST TABLE\nFREETABS DS    0H\n         LR    R1,R2                   LOAD AREA TO BE FREED\n         L     R2,0(R2)                LOAD POINTER TO NEXT TABLE\n         L     R0,MEMDATL              LOAD SIZE OF AREA TO BE FREED\n         FREEMAIN R,LV=(0),A=(1)       FREE STORAGE GETMAINED FOR TABLE\n         LTR   R2,R2                   SEE IF THERE WAS ANOTHER TABLE\n         BNZ   FREETABS                YES....GO FREE NEXT TABLE\n         L     R6,SAVER6               RESTORE REGISTER 6\n         LA    R8,INPUT                LOAD POINTER TO INPUT DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         TM    DCBOFLGS,DCBOFOPN       SEE IF INPUT DCB IS STILL OPEN\n         BNO   EXITMSG                 NO.....GO HANDLE NEXT DATASET\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST IN WORKAREA\n         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB\n         DROP  R8                      DROP ADDRESSABILITY TO DCB\n         B     EXITMSG                 GO HANDLE NEXT DATASET\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        PUT OUT SYNAD ERROR MESSAGE,                                 *\n*           GO FREE MEMBER TABLES, AND                                *\n*           CONTINUE WITH NEXT DATASET                                *\n*                                                                     *\n***********************************************************************\n*\nSERRI    DS    0H\n         PUTLINE OUTPUT=(SYNADI,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET NOT PRINTED DUE TO SYNAD\n*                                      ERROR ON INPUT DATASET MESSAGE\n         B     ENDMEMB                 GO FREE MEMBER TABLES\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        SEARCH FOR MAIN NAME,                                        *\n*           SAME TTR AND NOT AN ALIAS                                 *\n*                                                                     *\n***********************************************************************\n*\nLOOKLOOP DS    0H\n         STM   R3,R4,SAVER3            SAVE REGISTERS 3 AND 4\n         L     R3,MEMTABLE             LOAD ADDRESS OF FIRST TABLE\n         USING MEMDSECT,R3             ESTABLISH ADDRESSABILITY TO\n*                                      MEMBER ENTRY\nLOOP4    DS    0H\n         ST    R3,CURRENT              SAVE ADDRESS OF PRESENT TABLE\n         LH    R4,4(R3)                LOAD NUMBER OF ELEMENTS IN TABLE\n         LTR   R4,R4                   SEE IF THERE ARE ZERO ELEMENTS\n         BZ    NOMAIN                  YES....GO HANDLE MAIN NOT FOUND\n         LA    R3,8(R3)                LOAD ADDRESS OF FIRST MEMBER\nLOOP5    DS    0H\n         CLC   MEMTTR,8(R2)            SEE IF TTRS ARE THE SAME\n         BE    SAMETTR                 YES....GO SEE IF IT IS AN ALIAS\nENDLP5   DS    0H\n         LA    R3,MEMSECTN             LOAD ADDRESS OF NEXT MEMBER\n         BCT   R4,LOOP5                DECREMENT MEMBER COUNT\n         L     R3,CURRENT              LOAD ADDRESS OF THIS TABLE\n         L     R3,0(R3)                LOAD ADDRESS OF NEXT TABLE\n         LTR   R3,R3                   SEE IF IT WAS THE LAST TABLE\n         BNZ   LOOP4                   NO.....GO CHECK NEXT TABLE\n         B     NOMAIN                  GO HANDLE MAIN NOT FOUND\nSAMETTR  DS    0H\n         TM    CFIELD,HIGH             SEE IF THIS IS ALSO AN ALIAS\n         BO    ENDLP5                  YES....GO LOOK FOR ANOTHER TTR\n         MVC   11(8,R6),MEMBER         MOVE MEMBER NAME INTO OUTPUT\n         B     ENDLOOK                 GO TO RETURN TO CALLER\nNOMAIN   DS    0H\n         MVC   11(8,R6),ALIAS          INDICATE THIS IS AN ALIAS\nENDLOOK  DS    0H\n         LM    R3,R4,SAVER3            RESTORE REGISTERS 3 AND 4\n         BR    R14                     RETURN TO CALLER\n         DROP  R3                      DROP ADDRESSABILITY TO TABLE\n*\nCONTINUE DS    0H\n         L     R6,24(R6)               LOAD POINTER TO NEXT DSNAME ON\n*                                      CHAIN\n         C     R6,ENDCHAIN             SEE IF END OF CHAIN IS REACHED\n         BNE   NEXT                    NO.....GO DO NEXT DATASET NAME\nCLOSDCBS DS    0H\n         TM    INPUT+48,DCBOFOPN       SEE IF INPUT DCB IS STILL OPEN\n         BNO   CHKOUTA                 NO.....GO CHECK DCB FOR ASA CODE\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST WORKAREA\n         LA    R5,INPUT                LOAD POINTER TO INPUT DCB\n         CLOSE ((R5),),MF=(E,CLOSLST)  CLOSE INPUT DCB\nCHKOUTA  DS    0H\n         LA    R1,PRINTI               FREE INPUT DATASET         .GTE.\n         BAL   R2,FREEDD               FREE INPUT DATASET         .GTE.\n         TM    OUTPUTA+48,DCBOFOPN     SEE IF OUTPUT DCB FOR ASA WAS\n*                                      OPENED\n         BNO   CHKOUTM                 NO.....GO CHECK DCB FOR MACHINE\n*                                      CODE\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST WORKAREA\n         LA    R5,OUTPUTA              LOAD POINTER TO ASA CODE DCB\n         CLOSE ((R5),),MF=(E,CLOSLST)  CLOSE ASA CODE OUTPUT DCB\n         LA    R1,PRINTA               LOAD ADDRESS OF PRINT DDNAME\n         BAL   R2,FREEDD               GO FREE ASA CODE OUTPUT DDNAME\nCHKOUTM  DS    0H\n         TM    OUTPUTM+48,DCBOFOPN     SEE IF OUTPUT DCB FOR MACHINE\n*                                      CODE WAS OPENED\n         BNO   RETURN                  NO.....GO FREE GETMAINED AREAS\n*                                      AND RETURN\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST WORKAREA\n         LA    R5,OUTPUTM              LOAD POINTER TO MACHINE CODE DCB\n         CLOSE ((R5),),MF=(E,CLOSLST)  CLOSE MACHINE CODE OUTPUT DCB\n         LA    R1,PRINTM               LOAD ADDRESS OF PRINT DDNAME\n         BAL   R2,FREEDD               GO FREE MACHINE CODE OUTPUT\n*                                      DDNAME\n*\n***********************************************************************\n*                                                                     *\n*        CLEANUP AREAS GETMAINED BY PARS,                             *\n*           SET RETURN CODE, RESTORE REGISTERS AND                    *\n*           RETURN TO CALLER                                          *\n*                                                                     *\n***********************************************************************\n*\nRETURN   DS    0H\n         IKJRLSA PARSBACK              RELEASE AREAS GETMAINED BY PARS\n         LR    R1,R13                  LOAD ADDRESS OF GETMAINED AREA\n         L     R13,4(,R13)             RELOAD ADDRESS OF PREVIOUS SAVE\n*                                      AREA\n         LA    R0,LDYNAMIC             LOAD LENGTH OF GETMAINED AREA\n         FREEMAIN R,LV=(0),A=(1)       FREE GETMINED AREA\n         SLR   R15,R15                 ZERO REGISTER 15.  RETURN CODE\n*                                      CODE WILL ALWAYS BE ZERO\n         L     R14,12(,R13)            LOAD REGISTER 14 WITH RETURN\n*                                      ADDRESS\n         LM    R0,R12,20(R13)          RESTORE REGISTERS\n         BR    R14                     RETURN\n*\n***********************************************************************\n*                                                                     *\n*        ROUTINE TO CONVERT NONZERO RETURN CODES TO DECIMAL           *\n*           FOR DISPLAY                                               *\n*                                                                     *\n***********************************************************************\n*\nSETCODE  DS    0H\n         CVD   R8,DEC                  CONVERT RETURN CODE TO DECIMAL\n         UNPK  CONV(8),DEC(8)          UNPACK RETURN CODE\n         MVZ   CONV+1(7),CONV          MOVE ZONES IN CONVERTED RETURN\n*                                      CODE\n         MVC   RETNCD(2),HALF12        MOVE LENGTH OF DATA FOR PUTLINE\n         MVC   RETNCD+2(2),HALF0       MOVE IN ZEROES FOR PUTLINE\n         BR    R14                     RETURN\n*\n***********************************************************************\n*                                                                     *\n*        FREE AND REALOCATE PRINTX FILE AS SYSOUT                     *\n*                                                                     *\n***********************************************************************\n*\nALLOCOUT DS    0H\n         STM   14,9,ALCSAVE            SAVE WORK REGISTERS\n         LR    R1,R3                   LOAD POINTER TO DDNAME\n         BAL   R2,FREEDD               BRANCH TO FREE ROUTINE\n         LTR   R8,R8                   SEE IF RETURN CODE FROM FREE IS\n*                                      ZERO\n         BNZ   OPENFAIL                NO.....GO PUT OUT OPEN FAILED\n         LA    R8,REQBLK               LOAD POINTER TO REQUEST BLOCK\n         ST    R8,RBPTR                INITIALIZE REQUEST BLOCK POINTER\n         MVI   RBPTR,S99RBPND          INDICATE END OF PARAMETER LIST\n         USING S99RB,R8                ESTABLISH ADDRESSABILITY TO\n*                                      REQUEST BLOCK\n         MVC   S99RBLN(RBLEN),REQBLKC  INITALIZE RB\n         LA    R1,TEXTPTRS             LOAD POINTER TO TEXT POINTERS\n         ST    R1,S99TXTPP             STORE POINTER IN RB\n         DROP  R8                      DROP ADDRESSABILITY TO RB\n         USING S99TUPL,R1              ESTABLISH ADDRESSABILITY TO\n*                                      TEXT UNIT POINTER LIST\n         LA    R2,TEXTA                LOAD POINTER TO FIRST TEXT UNIT\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         USING S99TUNIT,R2             ESTABLISH ADDRESSABILITY TO\n*                                      TEXT UNIT\n         MVC   S99TUKEY(TEXTALEN),TEXTAC  INITIALIZE TEXT UNIT A\n         MVC   S99TUPAR(8),0(R3)       MOVE IN PARAMETER (DDNAME)\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTB                LOAD POINTER TO TEXT UNIT B\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVC   S99TUKEY(TEXTBLEN),TEXTBC  INITIALIZE TEXT UNIT B\n*\n***********************************************************************\n*                                                                     *\n*        SET UP ADDRESSABILITY TO PDL                                 *\n*           AND SEE IF SYSOUT CLASS/DEST ARE PRESENT                  *\n*           ALSO FORMS/TRAIN/FCB/PROG.                            .GTE.\n***********************************************************************\n*\n         L     R9,PARSBACK             LOAD ADDRESS PARS ANSWER\n         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL\n         CLC   PCLASS(2),HALF1         SEE IF CLASS SPECIFIED\n         BNE   NOCLASS                 NO.....GO CHECK FOR DESTINATION\n         L     R7,SCLASS               LOAD POINTER TO SYSOUT CLASS\n         MVC   S99TUPAR,0(R7)          MOVE CLASS INTO TEXT UNIT B\nNOCLASS  DS    0H\n         CLC   PDEST(2),HALF1          SEE IF DEST SPECIFIED\n         BNE   NODEST                  NO.....GO CHECK FOR HOLD\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTC                LOAD POINTER TO TEXT UNIT C\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVC   S99TUKEY(TEXTCLEN),TEXTCC  INITIALIZE TEXT UNIT C\n         L     R7,SDEST                LOAD POINTER TO DESTINATION\n         LH    R6,SDEST+4              LOAD LENGTH OF DESTINATION ID\n         STH   R6,S99TULNG             STORE LENGTH OF DEST IN TU\n         BCTR  R6,0                    DECREMENT LENGTH FOR EXECUTE OF\n*                                      MOVE\n         EX    R6,MOVEDEST             MOVE DEST INTO TU\nMOVEDEST MVC   S99TUPAR,0(R7)          MOVE TO BE EXECUTED\n*\nNODEST   DS    0H\n         CLC   PHOLD(2),HALF1          SEE IF HOLD SPECIFIED\n         BNE   NOHOLD                  NO.....GO CHECK FOR COPIES\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTDC               LOAD POINTER TO TEXT UNIT C\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\nNOHOLD   DS    0H\n         CLC   PCOPIES(2),HALF1        SEE IF COPY SPECIFIED\n         BNE   NOCOPY                  NO.....GO ZERO ECB\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTE                LOAD POINTER TO TEXT UNIT E\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVC   S99TUKEY(TEXTELEN),TEXTEC  INITIALIZE TEXT UNIT E\n         L     R7,SCOPIES              LOAD POINTER TO COPY FIELD\n         LH    R6,SCOPIES+4            LOAD LENGTH OF COPY FIELD\n         BCTR  R6,0                    DECREMENT REGISTER 6 FOR EXECUTE\n*                                      OF PACK INSTRUCTION\n         EX    R6,PACKCOPY             EXECUTE PACK TO CONVERT COPIES\n*                                      TO ZONED DECIMAL\n         CVB   R6,DEC                  CONVERT ZONED TO BINARY\n         STCM  R6,1,S99TUPAR           STORE NUMBER OF COPIES IN TU\nNOCOPY   DS    0H\n*********** START OF GTE MOD                                      .GTE.\n         CLC   PFORMS(2),HALF1         SEE IF FORMS SPECIFIED     .GTE.\n         BNE   NOFORMS                 NO.....GO CHECK TRAIN      .GTE.\n         LA    R1,4(R1)                LOAD POINTER TO NEXT       .GTE.\n*                                      TEXT UNIT POINTER          .GTE.\n         LA    R2,TEXTI                LOAD PTR TO TEXT UNIT I    .GTE.\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL      .GTE.\n         MVC   S99TUKEY(TEXTILEN),TEXTIC  INITIALIZE TEXT UNIT I  .GTE.\n         L     R7,RFORMS               LOAD PTR TO FORMS FIELD    .GTE.\n         LH    R6,RFORMS+4             LOAD LENGTH OF FORMS FIELD .GTE.\n         STH   R6,S99TULNG             STORE LENGTH IN TUE        .GTE.\n         BCTR  R6,0                    DECREMENT LENGTH           .GTE.\n         EX    R6,MOVEDEST             MOVE FORMS INTO FIELD      .GTE.\nNOFORMS  DS    0H                                                 .GTE.\n         CLC   PTRAIN(2),HALF1         SEE IF TRAIN SPECIFIED     .GTE.\n         BNE   NOTRAIN                 NO.....GO CHECK FCB        .GTE.\n         LA    R1,4(R1)                LOAD POINTER TO NEXT       .GTE.\n*                                      TEXT UNIT POINTER          .GTE.\n         LA    R2,TEXTH                LOAD PTR TO TEXT UNIT G    .GTE.\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL      .GTE.\n         MVC   S99TUKEY(TEXTHLEN),TEXTHC  INITIALIZE TEXT UNIT H  .GTE.\n         L     R7,RTRAIN               LOAD PTR TO TRAIN FIELD    .GTE.\n         LH    R6,RTRAIN+4             LOAD LENGTH OF TRAIN FIELD .GTE.\n         STH   R6,S99TULNG             SAVE LENGTH OF FCBE        .GTE.\n         BCTR  R6,0                    DECREMENT FOR EX           .GTE.\n         EX    R6,MOVEDEST             MOVE FCB INTO TU           .GTE.\nNOTRAIN  DS    0H                                                 .GTE.\n         CLC   PFCB(2),HALF1           SEE IF FCB  SPECIFIED      .GTE.\n         BNE   NOFCB                   NO.....GO ZERO ECB         .GTE.\n         LA    R1,4(R1)                LOAD POINTER TO NEXT       .GTE.\n*                                      TEXT UNIT POINTER          .GTE.\n         LA    R2,TEXTG                LOAD PTR TO TEXT UNIT G    .GTE.\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL      .GTE.\n         MVC   S99TUKEY(TEXTGLEN),TEXTGC  INITIALIZE TEXT UNIT G  .GTE.\n         L     R7,RFCB                 LOAD POINTER TO FCB FIELD  .GTE.\n         LH    R6,RFCB+4               LOAD LENGTH OF FCB FIELD   .GTE.\n         STH   R6,S99TULNG             SAVE LENGTH OF FCB IN TUE  .GTE.\n         BCTR  R6,0                    DECREMENT                  .GTE.\n         EX    R6,MOVEDEST             MOVE FCB TO TU             .GTE.\nNOFCB    DS    0H                                                 .GTE.\n         CLC   PPROG(2),HALF1          SEE IF PROG SPECIFIED      .GTE.\n         BNE   NOPROG                  NO.....GO ZERO ECB         .GTE.\n         LA    R1,4(R1)                LOAD POINTER TO NEXT       .GTE.\n*                                      TEXT UNIT POINTER          .GTE.\n         LA    R2,TEXTJ                LOAD PTR TO TEXT UNIT J    .GTE.\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL      .GTE.\n         MVC   S99TUKEY(TEXTJLEN),TEXTJC  INITIALIZE TEXT UNIT J  .GTE.\n         L     R7,RPROG                LOAD PTR TO PROG FIELD     .GTE.\n         LH    R6,RPROG+4              LOAD LENGTH OF PROG FIELD  .GTE.\n         STH   R6,S99TULNG             SAVE LENGTH OF PROG IN TUE .GTE.\n         BCTR  R6,0                    DECREMENT FOR MOVE         .GTE.\n         EX    R6,MOVEDEST             MOVE PROG TO TU            .GTE.\nNOPROG   DS    0H                                                 .GTE.\n********* END OF GTE MOD                                          .GTE.\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTFC               LOAD POINTER TO TEXT UNIT F\n*                                      PERMANENTLY ALLOCATED\n*                                      ATTRIBUTE\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVI   S99TUPTR,S99TUPLN       INDICATE END OF TEXT UNIT\n*                                      POINTER LIST\n         DROP  R1,R2,R9                DROP ADDRESSABILITY TO DSECTS\n         LA    R1,RBPTR                LOAD ADDRESS OF REQUEST BLOCK\n*                                      POINTER\n         DYNALLOC                      ISSUE DYNAMIC ALLOCATION SVC\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BNZ   ALCFAIL                 NO.....GO AND CALL DAIR FAIL\n         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO WORKAREA\n         OPEN  ((R5),(OUTPUT)),MF=(E,OPENLST)\n*                                      OPEN OUTPUT DCB\n         TM    48(R5),DCBOFOPN         SEE IF DCB OPENED SUCCESSFULLY\n         BNO   OPENFAIL                NO.....GO PUT OUT OUTPUT DCB\n*                                      NOT OPENED MESSAGE\n         LM    14,9,ALCSAVE            RESTORE REGISTERS\n         BR    R14                     RETURN TO CALLER\nALCFAIL  DS    0H\n         LA    R1,REQBLK               LOAD ADDRESS OF REQUEST\n*                                      BLOCK\n         MVI   DFID+1,DFSVC99          SET DAIR FAIL FOR SVC 99 ERROR\n         BAL   R2,DAIRFAIL             LOAD ADDRESS OF OPEN FAIL AND\n*                                      BRANCH TO DAIRFAIL ROUTINE\nOPENFAIL DS    0H\n         PUTLINE OUTPUT=(OPENMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      OUTPUT DCB NOT OPEND MESSAGE\n         S     R3,FULL4                GET POINTER TO PUTLINE DDNAME\n         PUTLINE OUTPUT=((R3),SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DDNAME\n         B     CLOSDCBS                GO CLOSE DCBS AND RETURN\n*\n***********************************************************************\n*                                                                     *\n*        INVOKE DAIR TO FREE FILENAME VIA CALLTSSR                    *\n*           AND CHECK FOR ZERO RETURN CODE                            *\n*                                                                     *\n***********************************************************************\n*\nFREEDD   DS    0H\n         SLR   R8,R8                   INITIALIZE REGISTER 8 TO ZERO\n*                                      RETURN CODE\n         MVC   DAP18(DAPB18L),DAPB18C  INITIALIZE DAIR PARAMETER BLOCK\n*                                      18 (FREE BY DATASET)\n         LA    R4,DAP18                LOAD ADDRESS OF DAPB\n         USING DAPB18,R4               ESTABLISH ADDRESSABILITY TO\n*                                      DAPB\n         MVC   DA18DDN,0(R1)           MOVE DDNAME INTO DAPB\n         SLR   R7,R7                   ZERO REGISTER 7\n         ST    R7,ECB                  STORE REGISTER 7 AS DUMMY ECB\n         LA    R1,DAPLSECT             LOAD ADDRESS OF DAPL\n         USING DAPL,R1                 ESTABLISH ADDRESSABILITY TO DAPL\n         ST    R4,DAPLDAPB             STORE ADDRESS OF DAPB IN DAPL\n         DROP  R1,R4                   DROP ADDRESSABILITY TO DAPL AND\n*                                      DAPB\n         CALLTSSR EP=IKJDAIR           CALL DAIR TO FREE DDNAME\n         C     R15,FULL28              SEE IF RETURN CODE IS 28\n*                                      (DDNAME NOT ALLOCATED)\n         BER   R2                      YES....GO CONTINUE PROCESSING\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZR   R2                      YES....GO CONTINUE PROCESSING\n         MVI   DFID+1,DFDAIR           SET DAIRFAIL ID TO INDICATE DAIR\n*\n***********************************************************************\n*                                                                     *\n*        INVOKE DAIRFAIL TO DISPLAY AN ERROR MESSAGE                  *\n*                                                                     *\n***********************************************************************\n*\nDAIRFAIL XC    DFPARMS(DFLEN),DFPARMS  INITIALIZE PARMLIST FOR DAIR\n*                                      FAIL TO ZEROS\n         ST    R1,DFDAPLP              STORE POINTER TO DAPL/RB IN\n*                                      PARAMETER LIST\n         ST    R15,RETCODE             STORE RETURN CODE\n         LA    R1,RETCODE              LOAD ADDRESS OF RETURN CODE\n         ST    R1,DFRCP                STORE POINTER TO RETURN CODE IN\n*                                      PARAMETER LIST\n         LA    R1,FULL0                LOAD ADDRESS OF FULLWORD OF\n*                                      ZEROS\n         ST    R1,DFJEFF02             STORE DUMMY POINTER TO IKJEFF02\n*                                      IN PARMLIST\n         LA    R1,DFID                 LOAD ADDRESS OF DAIR FAIL ID\n*                                      FIELD\n         ST    R1,DFIDP                STORE POINTER TO DFID IN\n*                                      PARMLIST\n         MVI   DFID,NOWTP              SET FOR NO WRITE TO PROGRAMMER\n         L     R1,SAVEAREA+4           LOAD ADDRESS OF PEVIOUS\n*                                      SAVEAREA\n         L     R1,24(R1)               LOAD POINTER TO CPPL\n         ST    R1,DFCPPLP              STORE POINTER TO CPPL IN\n*                                      PARMLIST\n         LINK  EP=IKJEFF18,MF=(E,DFPARMS)  LINK TO DAIR FAIL SERVICE\n*                                      ROUTINE TO HANDLE RETURN\n*                                      CODE\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZR   R2                      YES....GO RETURN TO CALLER\n         LR    R8,R15                  LOAD REGISTER 8 WITH RETURN CODE\n         BAL   R14,SETCODE             GO CONVERT CODE TO DECIMAL\n         PUTLINE OUTPUT=(DRFLERR,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DAIR FAIL ERROR MESSAGE\n         PUTLINE OUTPUT=(RETNCD,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DECIMAL RETURN CODE\n         BR    R2                      GO RETURN TO CALLER\n*\n******************** INSTRUCTIONS TO BE EXECUTED **********************\n*\nMOVEDSN  MVC   DSNBUF(0),0(R5)\nMOVEVOL  MVC   VOLUME(0),0(R7)\nPACKCOPY PACK  DEC(8),0(0,R7)\n         USING DAPB08,R8\nMOVEMEM  MVC   DA08MNM(0),0(R5)\nMOVEPASS MVC   DA08PSWD(0),0(R5)\n         DROP  R8\nDFPBMVE  MVC   DFPBNAME(0),0(R5)   EXECUTED                       .GTE.\n*\n***************************** CONSTANTS *******************************\n*\n******************** DAIR CONTROL BLOCK CONSTANTS *********************\nDAPB08C  DS    0F\n         DC    X'0008'                 DA08CD\n         DC    H'0'                    DA08FLG\n         DC    H'0'                    DA08DARC\n         DC    H'0'                    DA08CTRC\n         DC    A(0)                    DA08PDSN\n         DC    CL8'PRINTI  '           DA08DDN\n         DC    CL8' '                  DA08UNIT\n         DC    CL8' '                  DA08SER\n         DC    F'0'                    DA08BLK\n         DC    F'0'                    DA08PQTY\n         DC    F'0'                    DA08SQTY\n         DC    F'0'                    DA08DQTY\n         DC    CL8' '                  DA08MNM\n         DC    CL8' '                  DA08PSWD\n         DC    X'08'                   DA08DSP1      SHR\n         DC    X'08'                   DA08DSP2      KEEP\n         DC    X'08'                   DA08DSP3      KEEP\n         DC    X'08'                   DA08CTL       PERM\n         DC    F'0'                    DA08DSO\n         DC    CL8' '                  DA08ALN\nDAPB08L  EQU   *-DAPB08C               LENGTH\n         SPACE 2\nDAPB18C  DS    0F\n         DC    X'0018'                 DA18CD\n         DC    X'0000'                 DA18FLG\n         DC    H'0'                    DA18DARC\n         DC    H'0'                    DA18CTRC\n         DC    F'0'                    DA18PDSN\n         DC    CL8'PRINTI'             DA18DDN\n         DC    CL8' '                  DA18MNM\n         DC    CL2' '                  DA18SCLS\n         DC    X'08'                   DA18DPS2\n         DC    X'10'                   DA18CTL\n         DC    CL8' '                  DA18JBNM\nDAPB18L  EQU   *-DAPB18C               LENGTH\n         SPACE 2\nINPUTC   DCB   DSORG=PS,MACRF=(GM),EODAD=EXIT,SYNAD=ERRI,DDNAME=PRINTI\nINPUTL   EQU   *-INPUTC\n*\nOUTPUTAC DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTA,RECFM=VBA, X\n               LRECL=256,BLKSIZE=3120\nOUTPUTAL EQU   *-OUTPUTAC\n*\nOUTPUTMC DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTM,RECFM=VBM, X\n               LRECL=256,BLKSIZE=3120\nOUTPUTML EQU   *-OUTPUTMC\n*\nDIRECTC  DCB   DDNAME=PRINTI,DSORG=PS,MACRF=(GM),RECFM=U,BLKSIZE=256,  X\n               SYNAD=SERRI,EODAD=FREEBLK\nDIRECTL  EQU   *-DIRECTC\n*\nOPENCLOS OPEN  (,),MF=L\n         SPACE 2\nHEADERC  DS    0F\n         DC    H'48'\n         DC    H'0'\nHDRCNTLC DC    C' '\n         DC    CL43'**** TSO FOREGROUND HARDCOPY ****'\nHEADERM  DS    0F\n         DC    H'48'\n         DC    H'0'\n         DC    C' '\n         DC    CL43'*** TSO FOREGROUND MEMBER LIST **'\nLDSNAME  DS    0CL12\n         ORG   LDSNAME\n         DC    H'66'\n         DC    H'0'\n         DC    CL8' DSNAME='\nEJECTM   DS    0F\n         DC    H'5'\n         DC    H'0'\n         DC    X'8B'\nEJECTA   DS    0F\n         DC    H'5'\n         DC    H'0'\n         DC    C'1'\nSPACE    EQU   EJECTA\n         SPACE 2\nFULL0    DC    F'0'\nFULL1    DC    F'1'\nFULL4    DC    F'4'\nFULL20   DC    F'20'\nFULL28   DC    F'28'\nFULL256  DC    F'256'\nPRINTILN DC    H'12',H'0'\nPRINTI   DC    CL8'PRINTI'\nPRINTALN DC    H'12',H'0'\nPRINTA   DC    CL8'PRINTA'\nPRINTMLN DC    H'12',H'0'\nPRINTM   DC    CL8'PRINTM'\nBLANKS   DC    256CL1' '\nALIAS    DC    CL8' *ALIAS*'\nENDCHAIN DS    0F\n         DC    X'FF000000'\nMEMDATL  DC    X'00'                   SUBPOOL NUMBER\n         DC    AL3(1808)\nHALF0    DC    H'0'\nHALF1    DC    H'1'\nHALF2    DC    H'2'\nHALF6    DC    H'6'\nHALF12   DC    H'12'\nHALF85   DC    H'85'\nHALF256  DC    H'256'\nPATCH    DC    8CL4'ZAP*'\nHEXFF    EQU   X'FF'\nHIGH     EQU   X'80'\nBLANK    EQU   X'40'\nLOW      EQU   X'01'\nJFCPDS   EQU   X'01'\nHEX00    EQU   X'00'\nSCLSA    EQU   C'A'\nSKIPM    EQU   X'09'\nDSOPS    EQU   X'40'\nDSOPO    EQU   X'02'\nNOWTP    EQU   X'00'\n         SPACE 2\n****************** POINTER TO PARS PARAMETER CSECT ********************\nPCLADDR  DC    A(PARMTAB)\n         SPACE 2\n************************ PARS PARAMETER LIST **************************\n         PRINT NOGEN                                              .PRC.\nPARMTAB  IKJPARM  DSECT=IKJPARMD\nDSNAMES  IKJPOSIT  DSNAME,LIST,USID,                                   X\n               PROMPT='DSNAME',                                        X\n               HELP='DSNAME TO BE PRINTED'\nPCLASS   IKJKEYWD\n         IKJNAME 'CLASS',SUBFLD=CLASSUB\nPDEST    IKJKEYWD\n         IKJNAME 'DEST',SUBFLD=DESTSUB\nPHOLD    IKJKEYWD\n         IKJNAME 'HOLD'\n         IKJNAME 'NOHOLD'\nPCOPIES  IKJKEYWD\n         IKJNAME 'COPIES',SUBFLD=COPYSUB\nPPRINT   IKJKEYWD\n         IKJNAME 'PRINT'\n         IKJNAME 'NOPRINT'\nPLIST    IKJKEYWD\n         IKJNAME 'LIST'\n         IKJNAME 'NOLIST'\nPHEAD    IKJKEYWD\n         IKJNAME 'NOHEADING'                                      .GTE.\n         IKJNAME 'HEADING'                                        .GTE.\nPVOL     IKJKEYWD\n         IKJNAME 'VOLUME',SUBFLD=VOLSUB\nPFOLD    IKJKEYWD\n         IKJNAME 'FOLD',ALIAS=('CAPS')\n         IKJNAME 'NOFOLD',ALIAS=('ASIS')\nPFORMS   IKJKEYWD\n         IKJNAME  'FORMS',SUBFLD=SFORMS                          .GTE.\nPTRAIN   IKJKEYWD\n         IKJNAME  'TRAIN',SUBFLD=STRAIN,ALIAS=('UCS')            .GTE.\nPFCB     IKJKEYWD\n         IKJNAME    'FCB',SUBFLD=SFCB                            .GTE.\nPPROG    IKJKEYWD\n         IKJNAME    'PROG',SUBFLD=SPROG                          .GTE.\nPTEXT    IKJKEYWD\n         IKJNAME    'TEXT',INSERT='UCS(TN) ASIS'                 .GTE.\nASAKW    IKJKEYWD\n         IKJNAME 'ASA'                                           .PRC.\nSNUMKW   IKJKEYWD\n         IKJNAME 'SNUM'                                          .PRC.\nMSGKW    IKJKEYWD\n         IKJNAME 'NOMSG'                                         .PRC.\n*        B E G I N   S U B F I E L D S\nCLASSUB  IKJSUBF\nSCLASS   IKJIDENT 'CLASSNAME',LIST,FIRST=NONATNUM,MAXLNTH=1,           X\n               PROMPT='CLASS NAME'\nDESTSUB  IKJSUBF\n*-----------------------------------------------------------------.SAD.\n*      CHANGE THE DEST ID FROM YOUR TSO ID TO ANY VALUE. USERID   .SAD.\n*      IS A MAX OF 7 CHARACTERS AND DEST ID'S CAN BE 8 CHARACTERS .SAD.\n*-----------------------------------------------------------------.SAD.\nSDEST    IKJIDENT 'DESTINATION',MAXLNTH=8,                             X\n               FIRST=ALPHANUM,OTHER=ALPHANUM,                          X\n               PROMPT='REMOTE DESTINATION IDENTIFY FOR PRINTED FILE',  X\n               HELP=('DEST ID OF YOUR PRINTER ASSIGNED BY SADSC')\nCOPYSUB  IKJSUBF\nSCOPIES  IKJIDENT 'COPIES',MAXLNTH=3,                                  X\n               FIRST=NUMERIC,OTHER=NUMERIC,                            X\n               PROMPT='1-3 DIGITS - NUMBER OF COPIES OF OUTPUT',       X\n               HELP=('NUMBER OF COPIES OF PRINTOUT DESIRED')\nVOLSUB   IKJSUBF\nSVOL     IKJIDENT 'VOLUME',MAXLNTH=8,                                  X\n               FIRST=ALPHANUM,OTHER=ALPHANUM,                          X\n               PROMPT='VOLUME SERIAL FOR DATA SETS TO BE PRINTED',     X\n               HELP=('VOLUME SERIAL WILL BE ASSUMED FOR ALL DATA SETS')\nSFORMS   IKJSUBF\nRFORMS   IKJIDENT 'FORMS',MAXLNTH=4,FIRST=ALPHANUM,               .GTE.X\n               OTHER=ALPHANUM,                                    .GTE.X\n               PROMPT='FORMS DESIGNATION FOR PRINTED OUTPUT',     .GTE.X\n               HELP=('AN ALPANUMERIC STRING TO SPECIFY THE FORM') .GTE.\nSTRAIN   IKJSUBF\nRTRAIN   IKJIDENT   'UCS',MAXLNTH=4,FIRST=ALPHANUM,               .GTE.X\n               OTHER=ALPHANUM,                                    .GTE.X\n               PROMPT='UCS   DESIGNATION FOR PRINTED OUTPUT',     .GTE.X\n               HELP=('AN ALPANUMERIC STRING TO SPECIFY THE TRAIN') GTE.\nSFCB     IKJSUBF\nRFCB     IKJIDENT 'FCB',MAXLNTH=4,FIRST=ALPHANUM,                 .GTE.X\n               OTHER=ALPHANUM,                                    .GTE.X\n               PROMPT='FCB DESIGNATION FOR PRINTED OUTPUT',       .GTE.X\n               HELP=('AN ALPANUMERIC STRING TO SPECIFY THE FCB')  .GTE.\nSPROG    IKJSUBF\nRPROG    IKJIDENT 'PROG',MAXLNTH=8,FIRST=ALPHA,                   .GTE.X\n               OTHER=ALPHANUM,                                    .GTE.X\n               PROMPT='PROG DESIGNATION FOR PRINTED OUTPUT',      .GTE.X\n               HELP=('AN ALPANUMERIC STRING TO SPECIFY THE PROG') .GTE.\n         IKJENDP\n         PRINT GEN                                                .PRC.\n         SPACE 2\n****************************** MESSAGES *******************************\nGNRLERR  DC    AL2(GNRLERRL),AL2(0)\n         DC    C'AN ERROR WAS ENCOUNTERED IN THE GENERAL FAIL SERVICE RX\n               OUTINE.  THE RETURN CODE FROM GNRLFAIL IS: '\nGNRLERRL EQU   *-GNRLERR\n*\nDRFLERR  DC    AL2(DRFLERRL),AL2(0)\n         DC    C'AN ERROR WAS ENCOUNTERED IN THE DAIR FAIL SERVICE ROUTX\n               INE.  THE RETURN CODE FROM DAIR FAIL IS: '\nDRFLERRL EQU   *-DRFLERR\n*\nOPENMSG  DC    AL2(OPENMSGL),AL2(0)\n         DC    C'OUPUT PROCESSING IS BEING TERMINATED.  AN ERROR WAS ENX\n               COUNTERED ATTEMPTING TO OPEN THE OUTPUT DATASET ASSOCIATX\n               ED WITH DDNAME: '\nOPENMSGL EQU   *-OPENMSG\n*\nDSNNOTP  DC    AL2(DSNNOTPL),AL2(0)\n         DC    C'AN ERROR OCCURRED AND YOUR DATASET WAS NOT PRINTED'\nDSNNOTPL EQU   *-DSNNOTP\n*\nDSNMSG   DC    AL2(DSNMSGL),AL2(0)\n         DC    C'PROCESSING HAS BEEN COMPLETED FOR DATASET: '\nDSNMSGL  EQU   *-DSNMSG\n*\nMEMMSG   DC    AL2(MEMMSGL),AL2(0)\n         DC    C' MEMBER: '\nMEMMSGL  EQU   *-MEMMSG\n*\nPRTMSG   DC    AL2(PRTMSGL),AL2(0)\n         DC    C'MEMBERS WILL NOW BE PRINTED FOR DATASET: '\nPRTMSGL  EQU   *-PRTMSG\n*\nNOTPSPO  DC    AL2(NOTPSPOL),AL2(0)\n         DC    C'DATASET IS NOT SEQUENTIAL OR PARTITIONED AND WAS NOT PX\n               RINTED.'\nNOTPSPOL EQU   *-NOTPSPO\n*\nSYNADI   DC    AL2(SYNADIL),AL2(0)\n         DC    C'A SYNAD ERROR OCURRED READING YOU INPUT DATASET AND ONX\n               LY PART OF YOUR DATASET MAY HAVE BEEN PRINTED.'\nSYNADIL  EQU   *-SYNADI\n*\nSYNADO   DC    AL2(SYNADOL),AL2(0)\n         DC    C'A SYNAD ERROR OCURRED WRITING THE OUTPUT DATASET AND NX\n               O MORE DATASETS WILL BE PRINTED.'\nSYNADOL  EQU   *-SYNADO\n*\nDSNISU   DC    AL2(DSNISUL),AL2(0)\n         DC    C'DATASET HAS UNDEFINED RECORD LENGTH AND WILL NOT BE PRX\n               INTED.'\nDSNISUL  EQU   *-DSNISU\n*\nDSNISL   DC    AL2(DSNISLL),AL2(0)\n         DC    C'DATASET HAS RECORD LENGTH GREATER THAN 256.'\nDSNISLL  EQU   *-DSNISL\n         SPACE 2\n************************ DSECTS (MAPPING MACROS) **********************\nMEMDSECT DSECT\nMEMNTTR  DS    CL11\n         ORG   MEMNTTR\nMEMBER   DS    CL8\nMEMTTR   DS    CL3\nCFIELD   DS    CL1\nMEMSECTN EQU   *\n         IKJDAP08\nDAP08LEN EQU   *-DAPB08\n         IKJDAP18\nDAP18LEN EQU   *-DAPB18\n         IKJDAPL\nDAPLLEN  EQU   *-DAPL\n         IKJCPPL\nCPPLLEN  EQU   *-CPPL\n         IKJPPL\nPPLLEN   EQU   *-PPL\n         IKJIOPL\nIOPLLEN  EQU   *-IOPL\n         IHADSAB\nTIOEDDNM EQU   4           X'1C'(OFFSET) - X'18'(JOB STEP)\n*        CVT                                                     *.PRC.\nCVTPTR   EQU   16                                                 .PRC.\nCVT      DSECT                                                    .PRC.\nCVTMAP   EQU   *                                                  .PRC.\nCVTPARS  EQU   CVTMAP+X'20C'                                      .PRC.\nCVTDAIR  EQU   CVTMAP+X'2DC'                                      .PRC.\nCVTEHDEF EQU   CVTMAP+X'2E0'                                      .PRC.\n         IEFZB4D0\n         IEFZB4D2\n         IKJDFPL                                                  .GTE.\n         IKJDFPB                                                  .GTE.\nRBLEN    EQU   S99RBEND-S99RB\n         PRINT NOGEN\n         DCBD  DSORG=(PS,PO)\n         PRINT GEN\n         EJECT\n******************** CONSTANTS FOR DYNAMIC ALLOCATION *****************\nPRINTOFF CSECT\nREQBLKC  DC    AL1(S99RBEND-S99RB),AL1(S99VRBAL),18AL1(0)\nTEXTAC   DC    AL2(DALDDNAM),AL2(1),AL2(8),CL8'PRINT'  DDNAME\nTEXTALEN EQU   *-TEXTAC\nTEXTBC   DC    AL2(DALSYSOU),AL2(1),AL2(1),C'A'        SYSOUT CLASS\nTEXTBLEN EQU   *-TEXTBC\nTEXTCC   DC    AL2(DALSUSER),AL2(1),AL2(8),CL8'LOCAL'  DESTINATION\nTEXTCLEN EQU   *-TEXTCC\nTEXTDC   DC    AL2(DALSHOLD),AL2(0)              SYSOUT HOLD\nTEXTDLEN EQU   *-TEXTDC\nTEXTEC   DC    AL2(DALCOPYS),AL2(1),AL2(1),AL2(1)      SYSOUT COPIES\nTEXTELEN EQU   *-TEXTEC\nTEXTFC   DC    AL2(DALPERMA),AL2(0)              PERM ALLOCATION\nTEXTFLEN EQU   *-TEXTFC\nTEXTGC   DC    AL2(DALFCBIM),AL2(1),AL2(4),CL4'STD.'  FCB         .GTE.\nTEXTGLEN EQU   *-TEXTCC                                           .GTE.\nTEXTHC   DC    AL2(DALUCS),AL2(1),AL2(2),CL4'PN'      UCS         .GTE.\nTEXTHLEN EQU   *-TEXTDC                                           .GTE.\nTEXTIC   DC    AL2(DALSFMNO),AL2(1),AL2(2),CL4'STD.'  FORMS       .GTE.\nTEXTILEN EQU   *-TEXTEC                                           .GTE.\nTEXTJC   DC    AL2(DALSPGNM),AL2(1),AL2(8),CL8'PROG'  PROG        .GTE.\nTEXTJLEN EQU   *-TEXTFC                                           .GTE.\n*********************** DSECT FOR DYNAMIC WORKAREA ********************\nWORKAREA DSECT\nSAVEAREA DS    18F\nALCSAVE  DS    12F\n         DS    0D\nDEC      DS    2F\nRETNCD   DS    F\nCONV     DS    2F\nIOPB     PUTLINE MF=L\nDAP08    DS    0F\n         ORG   DAP08+DAP08LEN\nDAP18    DS    0F\n         ORG   DAP18+DAP18LEN\nDAPLSECT DS    0F\n         ORG   DAPLSECT+DAPLLEN\nPPLSECT  DS    0F\n         ORG   PPLSECT+PPLLEN\nIOPLSECT DS    0F\n         ORG   IOPLSECT+IOPLLEN\nDFPLSECT DS    4F                   SPACE FOR DFPL                .GTE.\nDFPBSECT DS    5F                   SPACE FOR DFPB                .GTE.\n         DS    H                    TO GET ALLIGNMENT             .GTE.\nDFPBDSL  DS    H                    DSNAME LENGTH                 .GTE.\nDFPBNAME DS    CL44                 DSNAME                        .GTE.\nDFPBQUA  DS    CL8\nECB      DS    F\nPARSBACK DS    F\nLINE     DS    0H\nLENGTH   DS    H\n         DS    H\nCNTLBYTE DS    CL1\nDATA     DS    CL256\nHEADER2  DS    CL12\nDSNAME   DS    CL44\nOPENPRN  DS    CL1\nMEMNAME  DS    CL8\nCLOSEPRN DS    CL1\n         ORG   DSNAME-4\nDSNLENP  DS    CL2\nDSNLEN   DS    CL2\nDSNBUF   DS    CL44\n         ORG   MEMNAME-4\nMEMNAMEL DS    CL2\n         ORG\nHEADER   DS    CL48\n         ORG   HEADER+4\nHDRCNTL  DS    CL1\nDFID     DS    CL2\n         ORG\nVOLBIT   DS    CL1\nVOLUME   DS    CL8\nMEMTABLE DS    F\nENDTABLE DS    F\nCURRENT  DS    F\nPRESENT  DS    F\nCOLUMN   DS    F\nXLIST    DS    F\nRDJL     RDJFCB (,),MF=L\nJFCBAREA DS    44F\n         ORG   JFCBAREA+44\nJFCBELNM DS    CL8\n         ORG   JFCBAREA+86\nJFCBIND1 DS    CL1\n         ORG   JFCBAREA+98\nJFCDSRG1 DS    CL1\n         ORG\nSAVER6   DS    F\nSAVER2   DS    2F\nSAVER3   DS    2F\nPRCKW    DS    F                                                  .PRC.\n*\n         PRINT NOGEN\n*\nINPUT    DCB   DSORG=PS,MACRF=(GM),EODAD=EXIT,SYNAD=ERRI,DDNAME=PRINTI\n*\nOUTPUTA  DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTA,RECFM=VBA, X\n               LRECL=256,BLKSIZE=3120\n*\nOUTPUTM  DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTM,RECFM=VBM, X\n               LRECL=256,BLKSIZE=3120\n*\nDIRECT   DCB   DDNAME=PRINTI,DSORG=PS,MACRF=(GM),RECFM=U,BLKSIZE=256,  X\n               SYNAD=SERRI,EODAD=FREEBLK\n*\nOPENLST  OPEN  (,),MF=L\n*\nCLOSLST  CLOSE (,),MF=L\n*\n         PRINT GEN\n*\nRETCODE  DS    F\nGFPARMP  DS    F\n         IKJEFFGF\n         IKJEFFDF\nRBPTR    DS    F\nREQBLK   DS    10F (WAS 5F)                                       .GTE.\nTEXTPTRS DS    10F (WAS 5F)                                       .GTE.\nTEXTA    DS    0F                                   DDNAME\n         ORG   TEXTA+TEXTALEN\nTEXTB    DS    0F                                   SYSOUT CLASS\n         ORG   TEXTB+TEXTBLEN\nTEXTC    DS    0F                                   DESTINATION\n         ORG   TEXTC+TEXTCLEN\nTEXTE    DS    0F                                   SYSOUT COPIES\n         ORG   TEXTE+TEXTELEN\nTEXTG    DS    0F                                   FCB           .GTE.\n         ORG   TEXTG+TEXTGLEN                                     .GTE.\nTEXTH    DS    0F                                   UCB           .GTE.\n         ORG   TEXTH+TEXTHLEN                                     .GTE.\nTEXTI    DS    0F                                   FORMS         .GTE.\n         ORG   TEXTI+TEXTILEN                                     .GTE.\nTEXTJ    DS    0F                                   PROG          .GTE.\n         ORG   TEXTJ+TEXTJLEN                                     .GTE.\nLDYNAMIC EQU   *-WORKAREA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PRINTSEP": {"ttr": 7433, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x04\\xce\\x04\\xce\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 1230, "newlines": 1230, "modlines": 0, "user": "FILE369"}, "text": "         TITLE 'APS JES2 EXITS: CUSTOM PRINTER BANNER SEPARATOR PAGE'\n***********************************************************************\n*  NAME                                                               *\n*        PRINTSEP                                                     *\n*                                                                     *\n*  FUNCTION                                                           *\n*        CUSTOM PRINT SEPARATOR EXIT ROUTINES                         *\n*                                                                     *\n*  ENTRY POINTS                                                       *\n*        SEPEX1                                                       *\n*                                                                     *\n*  MVS MACROS                                                         *\n*        FREEMAIN                                                     *\n*        GETMAIN                                                      *\n*        TIME                                                         *\n*                                                                     *\n*  JES2 MACROS                                                        *\n*        $ENTRY                                                       *\n*        $FREEBUF                                                     *\n*        $GETBUF                                                      *\n*        $HASPGBL                                                     *\n*        $MODEND                                                      *\n*        $MODULE                                                      *\n*        $PBLOCK                                                      *\n*        $PRPUT                                                       *\n*        $SEPPDIR                                                     *\n*        $RETURN                                                      *\n*        $SAVE                                                        *\n*        $WTO                                                         *\n*                                                                     *\n*  JES2 CONTROL BLOCKS                                                *\n*        BUFFER                                                       *\n*        DCT                                                          *\n*        JCT                                                          *\n*        JOE                                                          *\n*        PCE                                                          *\n*        RDT                                                          *\n*        SVT                                                          *\n*                                                                     *\n*  NOTES                                                              *\n*        1.  ENTRY SEPEX1 IS TO BE INVOKED AT STANDARD JES2           *\n*            EXIT 1.                                                  *\n*        2.  THE ACF2 LOGON ID IS PASSED IN JCTUSEID AS LONG AS ACF2  *\n*            OPTION STAMPSMF IS IN EFFECT. WATCH OUT -- SOME OTHER    *\n*            PRODUCT MAY STOMP ON THIS.                               *\n*        3.  THE LOGOS ARE IN LOWER CASE. TAKE CARE WITH THE          *\n*            EDITOR IF YOU MAKE CHANGES.                              *\n*                                                                     *\n*  AUTHOR                                                             *\n*        CHARLIE PITTS                                                *\n*                                                                     *\n*  MAINTENANCE                                                        *\n*    V1.0  5/23/86  CJP  ADDED PROVISIONS FOR TWO DIFFERENT LOGOS     *\n*                        DEPENDING ON PRINTER NODE.                   *\n*    V2.0  6/ 5/86  CJP  CORRECT BUG WITH LENGTH OF SITE NAME         *\n*                        TO TRIGGER ALTERNATE LOGO.                   *\n*    V3.0  4/27/87  CJP  ADDED SUPPORT FOR 'BLDG' INSTEAD OF 'ROOM'   *\n*                        BASED ON PRINTER NODE. ALSO ADDED 'DELIVER   *\n*                        TO REMOTE BLDG' BLOCK IN HEADER, PER LEN     *\n*                        BEECH.                                       *\n*    V3.1  5/20/87  CJP  CHANGED FORMAT OF 'DELIVER TO...' BLOCK,     *\n*                        PER LEN BEECH.                               *\n*    V3.2 12/22/87  CJP  ADDED DAY-OF-THE-WEEK TO HEADER.             *\n*    V4.0 12/23/87  CJP  UPDATED FOR JES2 R2.1.5. STILL AT ACF2 R4.0. *\n*                        NOTE ACF2 R4.0 CIRCUMVENTION JUST BEFORE     *\n*                        #ACFJCB INVOCATION. REMOVE FOR ACF2 R5.0.    *\n*    V4.1  1/19/88  CJP  REMOVED BUFDSECT ACF R4 CIRCUMVENTION.       *\n*                        REMOVED SEPEX222 ENTRY POINT AND LOGIC       *\n*                        BECAUSE ACF2 R5 ELIMINATED THE EXIT. WE'RE   *\n*                        GETTING THE USER'S LID FROM JCTUSEID AS      *\n*                        A RESULT OF ENABLING THE STAMPSMF GLOBAL     *\n*                        ACF2 OPTION. THERE IS NOW NO ACF2 CODE IN    *\n*                        THIS MODULE.                                 *\n*    V4.2  6/ 9/88  CJP  CORRECTED LOGIC FOR PRC LOGO FOR CPK2. PRC   *\n*                        LOGO IS USED ONLY AT APS1.                   *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         EJECT\n*        COPY  $HASPGBL\n         PRINT OFF\n         COPY  $HASPGBL\n         PRINT ON,NOGEN\nPRINTSEP $MODULE SYSP=(NOGEN,GEN,NODATA,NOGEN,NOGEN),                  X\n               $BUFFER,            I/O BUFFER DSECT                    X\n               $CAT,               CLASS ATTRIBUTE TABLE               X\n               $DCT,               DEVICE CONTROL TABLE                X\n               $HASPEQU,           REGISTER EQUATES, ETC               X\n               $HCT,               HASP COMMUNICATIONS TABLE           X\n               $JCT,               JOB CONTROL TABLE                   X\n               $JOE,               JOB OUTPUT ELEMENT                  X\n               $JQE,               JOB QUEUE ELEMENT                   X\n               $MIT,               MODULE INFORMATION TABLE            X\n               $PCE,               PROCESSOR CONTROL ELEMENT           X\n               $PDDB,              PERIPHERAL DATA DEFINITION BLOCK    X\n               $PPPWORK,           PRT/PUN PROCESSOR PCE WORKAREA      X\n               $RDT,               REMOTE DESTINATION TABLE            X\n               $SCAT,              SYSOUT CLASS ATTRIBUTE TABLE        X\n               $SVT,               JES2 SUBSYSTEM VECTOR TABLE         X\n               $XECB,              EXTENDED ECB                        X\n               RPL                 REQUEST PARAMETER LIST\n         SPACE 2\n         USING JCT,R10\n         SPACE\n         PRINT GEN\n         TITLE 'APS JES2 EXIT 1: CUSTOM PRINTER BANNER SEPARATOR PAGE'\n***********************************************************************\n*  FUNCTION                                                           *\n*        CUSTOM PRINT SEPARATOR EXIT ROUTINE                          *\n*                                                                     *\n*  ENTRY POINT                                                        *\n*        SEPEX1                                                       *\n*                                                                     *\n*  CALLED FROM                                                        *\n*        HASPPRPU VIA $EXIT                                           *\n*                                                                     *\n*  NOTES                                                              *\n*        1.  THERE IS SOME UNUSUAL CODE IN THE DETAIL                 *\n*            SUBROUTINE TO GET AROUND THE RESTRICTIVE EXPANSION OF    *\n*            THE $PRPUT MACRO. IF THAT MACRO CHANGES, SOMETHING       *\n*            MAY HAVE TO BE ADJUSTED.                                 *\n***********************************************************************\n*  REGISTERS AT ENTRY                                                 *\n*        R0    ENTRY CODE                                             *\n*                0  START OF JOB                                      *\n*                4  CONTINUATION OF JOB                               *\n*                8  END OF JOB                                        *\n*        R1    PRINTER/PUNCH DCT                                      *\n*        R10   JCT                                                    *\n*        R11   HCT                                                    *\n*        R13   PCE                                                    *\n*        R14   RETURN ADDRESS                                         *\n*        R15   ENTRY ADDRESS                                          *\n*                                                                     *\n*  REGISTERS USE DURING PROCESSING                                    *\n*        R4    WORKAREA                                               *\n*        R5    SUBROUTINE LINKAGE                                     *\n*        R7    BUFFER POINTER                                         *\n*        R8    SUBROUTINE LINKAGE                                     *\n*        R9    DCT                                                    *\n*        R10   JCT                                                    *\n*        R11   HCT                                                    *\n*        R12   PROGRAM BASE                                           *\n*        R13   PCE                                                    *\n*                                                                     *\n*  REGISTERS AT EXIT                                                  *\n*        R15   RETURN CODE                                            *\n*                0  CALL NEXT EXIT; PRODUCE STANDARD SEPARATOR        *\n*                     IF 'S=Y' IS IN EFFECT.                          *\n*                4  NO MORE EXITS; PRODUCE STANDARD SEPARATOR         *\n*                     IF 'S=Y' IS IN EFFECT.                          *\n*                8  CALL NEXT EXIT; SUPPRESS STANDARD SEPARATOR.      *\n*                C  CALL NEXT EXIT; PRODUCE STANDARD SEPARATOR.       *\n***********************************************************************\n         EJECT\n***********************************************************************\n*        JES ENTRY POINT                                              *\n***********************************************************************\n         SPACE 2\nSEPEX1   $ENTRY BASE=R12,CSECT=YES\n         SPACE\n         $SAVE\n         EJECT\n***********************************************************************\n* SEP0000:                                                            *\n*        SET BASE REGISTER;                                           *\n*        SAVE SEPARATOR TYPE ENTRY PARAMETER;                         *\n*        SET ADDRESSABILITY FOR DCT;                                  *\n*        CLEAR BUFFER REGISTER POINTER;                               *\n*        IF THIS IS NOT PRINT              - OR -                     *\n*                SEPARATORS ARE SUPPRESSED                            *\n*          THEN GO EXIT WITH RC=0;                                    *\n*        CALL INITWORK SUBROUTINE;                                    *\n*        CALL EXTRACT SUBROUTINE;                                     *\n*        ISSUE $GETBUF TO ACQUIRE FIXED HASP BUFFER;                  *\n*        ISSUE $SEPPDIR IN CASE DEVICE IS A REMOTE;                   *\n***********************************************************************\n         SPACE\nSEP0000  DS    0H\n         LR    R12,R15             SET BASE REGISTER\n         LR    R2,R0               SAVE SEPARATOR TYPE\n         LR    R9,R1               SAVE DCT ADDRESS\n         USING DCT,R9\n         SPACE\n         XR    R4,R4               CLEAR WORKAREA POINTER REGISTER\n         XR    R7,R7               CLEAR BUFFER POINTER REGISTER\n         SPACE\n         TM    PCEID,PCEPUSID      IS THIS A PUNCH?\n         BO    SEP9000             YEP...GO EXIT\n         TM    DCTPPSW,DCTPPSWS    SEPARATORS SUPRESSED?\n         BO    SEP9000             YEP...EXIT\n         SPACE\n         BAL   R8,INITWORK         INITIALIZE WORKAREA\n         USING WORKAREA,R4\n         BAL   R8,EXTRACT          GET JOB DATA FROM JES CONTROL BLOCKS\n         SPACE\n         $GETBUF TYPE=HASP,FIX=YES,WAIT=YES\n         LR    R7,R1               BUFFER ADDRESS\n         USING BFPDSECT,R7\n         SPACE\n         $SEPPDIR (R7)\n         EJECT\n***********************************************************************\n*                 /*  MAIN LINE LOGIC  */                             *\n*        DO COUNT=PAGES BY -1 UNTIL 0;                                *\n*          INITIALIZE LINE COUNTER;                                   *\n*          CALL HEADER SUBROUTINE;                                    *\n*          CALL BLOCK SUBROUTINE;                                     *\n*          CALL DETAIL SUBROUTINE;                                    *\n*          CALL ENDPAGE SUBROUTINE;                                   *\n*        END;                                                         *\n*        RETURN WITH RC=8;                                            *\n***********************************************************************\n         SPACE\n         LH    R0,PAGECNT          FOR INITIAL PASS THRU LOOP\nSEP4000  DS    0H\n         STH   R0,PAGECNT          SAVE COUNT\n         MVC   LINECNT,SEPLINES    INITIALIZE COUNTER\n         SPACE\n         BAL   R8,HEADER           FORMAT HEADER\n         BAL   R8,BLOCK            FORMAT BLOCK LINES\n         BAL   R8,DETAIL           FORMAT/PRINT DETAIL LINES\n         BAL   R8,ENDPAGE          FORMAT/PRINT END-OF-PAGE LINE\n         SPACE\n         LH    R0,PAGECNT          PAGES REMAINING\n         BCT   R0,SEP4000          LOOP IF MORE\n         SPACE\n         B     SEP9200             RETURN WITH RC=8\n         EJECT\n***********************************************************************\n* SEP9000:                                  /*  RETURN WITH RC=0  */  *\n*        SET RETURN CODE TO 0;                                        *\n*        ONWARD AT SEP9900;                                           *\n* SEP9200:                                  /*  RETURN WITH RC=8  */  *\n*        SET RETURN CODE TO 8;                                        *\n* SEP9900:                                                            *\n*        IF A WORKAREA WAS OBTAINED                                   *\n*          THEN ISSUE FREEMAIN;                                       *\n*        IF A BUFFER WAS OBTAINED                                     *\n*          THEN ISSUE $FREEBUF;                                       *\n*        $RETURN TO JES;                                              *\n***********************************************************************\n         SPACE\nSEP9000  DS    0H\n         LA    R2,X'00'            SET RETURN CODE 00\n         B     SEP9900             ONWARD\nSEP9200  DS    0H\n         LA    R2,X'08'            SET RETURN CODE 08\n         SPACE\nSEP9900  DS    0H\n         LTR   R1,R4               WAS A WORKAREA OBTAINED?\n         BZ    SEP9920             NOPE...ONWARD\n         LA    R0,WORKLEN          SPECIFY WORKAREA LENGTH & SP0\n         FREEMAIN R,LV=(0),A=(1)\nSEP9920  DS    0H\n         SPACE\n         LTR   R1,R7               WAS A BUFFER OBTAINED?\n         BZ    SEP9940             NOPE...ONWARD\n         $FREEBUF (1)\nSEP9940  DS    0H\n         SPACE\n         LR    R15,R2              RETURN CODE\n         $RETURN RC=(R15)\n         EJECT\n***********************************************************************\n* INITWORK:                              /*  INITIALIZE WORKAREA  */  *\n*        IF THIS IS A LOCAL DEVICE                                    *\n*          THEN USE $PRIDCT  FOR SEPARATOR LINE COUNT AND             *\n*               USE LCLPAGES FOR SEPARATOR PAGE COUNT;                *\n*          ELSE USE $TPIDCT  FOR SEPARATOR LINE COUNT AND             *\n*               USE REMPAGES FOR SEPARATOR PAGE COUNT;                *\n*        IF SEPARATOR LINE COUNT IS ZERO                              *\n*          THEN GO EXIT WITH RC=0;                                    *\n*        ISSUE GETMAIN TO ACQUIRE WORKAREA;                           *\n***********************************************************************\n         SPACE\nINITWORK DS    0H\n         SPACE\n         XR    R5,R5               CLEAR WORK REGISTER\n         IC    R5,$PRIDCT          LOCAL SEPARATOR LINE COUNT\n         L     R3,LCLPAGES         LOCAL PAGE COUNT\n         TM    DCTDEVID,DCTRMTID   IS IT A REMOTE?\n         BNO   IWRK0200            NOPE...ONWARD\n         L     R3,REMPAGES         REMOTE PAGE COUNT\n         IC    R5,$TPIDCT          REMOTE SEPARATOR LINE COUNT\nIWRK0200 DS    0H\n         SPACE\n         LTR   R5,R5               COUNT = 0?\n         BZ    SEP9000             YEP...EXIT\n         SPACE\n         LA    R0,WORKLEN          SPECIFY WORKAREA LENGTH & SP0\n         GETMAIN  R,LV=(0)\n         LR    R4,R1               SAVE WORKAREA POINTER\n         USING WORKAREA,R4\n         EJECT\n***********************************************************************\n*        SAVE ENTRY PARM, LINE COUNT AND PAGE COUNT IN WORKAREA;      *\n*        IF 'START' OR 'CONTINUE'                                     *\n*          THEN PAGES = HDRPAGES;                                     *\n*          ELSE PAGES = TLRPAGES;                                     *\n***********************************************************************\n         SPACE\n         STC   R2,SEPTYPE          SAVE SEPARATOR TYPE\n         ST    R3,SEPPAGES         SAVE HEADER/TRAILER PAGE COUNTS\n         STH   R5,SEPLINES         SAVE LINE COUNT\n         SPACE\n         LH    R0,TPAGES           END JOB PAGE COUNT\n         CLI   SEPTYPE,ENDJOB      TRAILER?\n         BE    IWRK1600            YEP...ONWARD\n         LH    R0,HPAGES           START/CONTINUE JOB PAGE COUNT\nIWRK1600 DS    0H\n         STH   R0,PAGECNT          PAGES REQUIRED\n         EJECT\n***********************************************************************\n*        ISSUE OS TIME SVC;                                           *\n*        FORMAT DATE AS 'DDMMMYY';                                    *\n***********************************************************************\n         SPACE\n         TIME  DEC\n         SPACE\n         LR    R5,R0               SAVE TIME - PACKED 'HHMMSSTH'\n         SPACE\n         STCM  R1,B'1111',PDATE    SAVE PACKED FORM\n         UNPK  $DOUBLE,PDATE       CONVERT DATE TO ZONED\n         MVC   DATEYR,$DOUBLE+3    THAT'S THE YEAR\n         ZAP   $DOUBLE,PDAY        EXTRACT AND EXPAND DAY OF YEAR\n         CVB   R0,$DOUBLE          CONVERT DAY PORTION TO BINARY\n         TM    DATEYR+1,X'03'      LEAP YEAR?\n         BZ    IWRK2200            YEP...ONWARD\n         CH    R0,LEAPYEAR         IS DATE > 28FEB?\n         BNH   IWRK2200            NOPE...ONWARD\n         AH    R0,=H'1'            MAKE IT LIKE A LEAP YEAR\nIWRK2200 DS    0H\n         SPACE\n         XR    R14,R14             LOOP INDEX\n         LA    R15,12              LOOP COUNTER\n         SPACE\nIWRK2400 DS    0H\n         CH    R0,MONTHLEN(R14)    IS THIS THE MONTH?\n         BNH   IWRK1800            YEP...ONWARD\n         SH    R0,MONTHLEN(R14)    DECREMENT DAY\n         LA    R14,L'MONTHLEN(,R14) BUMP\n         BCT   R15,IWRK2400         LOOP\n         SPACE\nIWRK1800 DS    0H\n         LA    R14,12              MAX MONTHS\n         SR    R14,R15             LESS LOOP INDEX\n         MH    R14,=Y(L'MONTHNAM)  GENERATE OFFSET\n         LA    R14,MONTHNAM(R14)   AND ADDRESS\n         MVC   DATEMON,0(R14)      MOVE MONTH NAME\n         CVD   R0,$DOUBLE                 DAY OF MONTH TO PACKED\n         MVC   $DOUBLE(L'EDIT3),EDIT3     EDIT PATTERN\n         ED    $DOUBLE(L'EDIT3),$DOUBLE+6 FORMAT DAY OF MONTH\n         MVC   DATEDAY,$DOUBLE+2   FINIALLY\n         EJECT\n***********************************************************************\n*        DETERMINE THE DAY-OF-THE-WEEK;                               *\n*        FORMAT TIME AS 'HH:MM:SS';                                   *\n*        FORMAT TIME AS 'HH:MM:SSAM' ALSO;                            *\n*        RETURN TO CALLER VIA R8;                                     *\n***********************************************************************\n         SPACE\n         MVI   PDAYS+L'PDAYS-1,X'0C' SET IN SIGN FOR YEAR\n         MVO   PDAYS,PYEAR         MAKE IT PROPER PACKED W/SIGN\n         MP    PDAYS,=P'36525'     100*(DAYS/YEAR)\n         AP    PDAYS,=P'99'        FORCE ROUNDING UP\n         SRP   PDAYS,X'1000'-2,0   CEIL(PDAYS/100)\n         AP    PDAYS,PDAY          FINIALLY - DAY NUMBER SINCE 1/1/1900\n         DP    PDAYS,=P'7'         DIVIDE BY DAYS/WEEK\n         SPACE\n         ZAP   $DOUBLE,DAYNO       EXPAND TO 8 BYTES\n         CVB   R15,$DOUBLE         CONVERT TO BINARY\n         MH    R15,=Y(L'DAYS)      INDEX TO DAYS TABLE\n         LA    R15,DAYS(R15)       ADDRESS OF PROPER DAY NAME\n         MVC   WEEKDAY,0(R15)      MOVE ANSWER\n         SPACE\n         ST    R5,$DOUBLE          PICK UP PACKED TIME\n         SPACE\n         MVC   TIME24-1(L'EDITTIME),EDITTIME   EDIT PATTERN\n         ED    TIME24-1(L'EDITTIME),$DOUBLE    FORMAT 24 HOUR TIME\n         MVC   TIME12+8(3),=C'AM ' PRIME 12 HOUR TIME\n         CLI   $DOUBLE,X'12'       SEE IF IT'S REALLY PM\n         BL    IWRK3000            NOPE...ONWARD\n         MVI   TIME12+8,C'P'       SET TO 'PM'\n         IC    R0,$DOUBLE          GET HOURS BYTE\n         SH    R0,=Y(X'12')        REDUCE HOURS\n         STC   R0,$DOUBLE          REPLACE IT\n         TM    $DOUBLE,X'08'       BINARY SUBTRACTION ERROR?\n         BNO   IWRK3000            NOPE\n         NI    $DOUBLE,X'09'       A LITTLE MAGIC TO FIX IT\nIWRK3000 DS    0H\n         SPACE\n         CLI   $DOUBLE,X'00'       IS IT NOON OR MIDNIGHT?\n         BNE   IWRK3200            NOPE...ONWARD\n         MVI   $DOUBLE,X'12'       SET TO 12\nIWRK3200 DS    0H\n         SPACE\n         MVC   TIME12-1(L'EDITTIME),EDITTIME   EDIT PATTERN\n         ED    TIME12-1(L'EDITTIME),$DOUBLE    FORMAT 12 HOUR TIME\n         SPACE\n         BR    R8                  RETURN TO CALLER\n         EJECT\n***********************************************************************\n* EXTRACT:                         /*  FORMAT DATA INTO WORKAREA  */  *\n*        SET ADDRESSABILITY FOR CURRENT JOE;                          *\n*        MOVE VALUES FROM JES CB'S TO WORKAREA;                       *\n***********************************************************************\n         SPACE\nEXTRACT  DS    0H\n         L     R6,PPPWKJOE         CURRENT JOE WORK JOE\n         USING JOE,R6\n         MVC   JOBNAME,JCTJNAME    JOB NAME\n         MVC   JESJOBID,JCTJOBID   JES JOBLOG ID\n         MVC   SYSOUTCL,JOECURCL   SYSOUT CLASS\n         MVC   PDEVICE,DCTDEVN     PRINTER DEVICE NAME\n         MVC   PSYSTEM,$SID        SYSTEM ID\n         MVC   ONODE,JCTNONDE      ORIGINAL NODE NAME\n         MVC   GROUP,JOENAME       JOE GROUP NAME\n         MVC   PGMRNAME,JCTPNAME   PROGRAMMER'S NAME\n         MVC   FORM,DCTFORMS       FORMS NAME\n         MVC   FCB,DCTFCB          FORMS CONTROL BUFFER\n         MVC   ROOM,JCTROOMN       ROOM NUMBER\n         SPACE\n         XR    R0,R0               CLEAR PARAMETER REGISTER\n         ICM   R0,B'1100',$OWNNODE CURRENT NODE NUMBER\n         LA    R1,PNODE            PRINTER NODE NAME\n         BAL   R5,ROUTEMAP         CONVERT NODE NUMBER\n         SPACE\n         MVC   ACF2NAME,$BLANKS    PRIME ACF2 USER ID NAME, IN CASE\n         CLI   JCTUSEID,C' '       IS IT PRESENT?\n         BNH   EXTR0040            NOPE...BLANKS\n         MVC   ACF2NAME,JCTUSEID   GET ACF2 USER ID\nEXTR0040 DS    0H\n         SPACE\n         L     R0,JOERECCT         TOTAL LINES\n         CLI   SEPTYPE,ENDJOB      TRAILER?\n         BNE   EXTR0070            NOPE...ONWARD\n         S     R0,PPPRECNM         CURRENT RECORD NUMBER\nEXTR0050 DS    0H\n         S     R0,JOEWRECN         ALREADY DONE\nEXTR0070 DS    0H\n         CVD   R0,$DOUBLE          TO PACKED FORMAT\n         MVC   LINESREM,EDIT7      EDIT PATTERN\n         ED    LINESREM,$DOUBLE+4  EDIT 7 SIGNIFICANT DIGITS\n         EJECT\n***********************************************************************\n*        CALL ROUTEMAP TO FORMAT JOE ROUTE/DESTINATION;               *\n*        FORMAT JOE NAME 1 & 2;                                       *\n*        IF FCB NAME IMPLIES 8 LINES PER INCH                         *\n*          THEN MULTIPLY LINE COUNT BY 1.3333;                        *\n*        IF PRINTING SITE REQUIRES 'BLDG' DESIGNATOR                  *\n*          THEN SET ROOMBLDG TO 'BLDG';                               *\n*          ELSE SET ROOMBLDG TO 'ROOM';                               *\n*        RETURN TO CALLER VIA R8;                                     *\n***********************************************************************\n         SPACE\n         L     R0,JOERECCT         TOTAL LINES\n         CVD   R0,$DOUBLE          TO PACKED FORMAT\n         MVC   LINESTOT,EDIT7      EDIT PATTERN\n         ED    LINESTOT,$DOUBLE+4  EDIT 7 SIGNIFICANT DIGITS\n         SPACE\n         L     R0,JOEROUT          WHOLE ROUTE WORD\n         LA    R1,PROUTE           PRINTER ROUTE CODE\n         BAL   R5,ROUTEMAP         FORMAT INTO 8 BYTES\n         SPACE\n         LH    R0,JOEID1           FIRST ID\n         MH    R0,=H'10000'        SHIFT LEFT 4 DECIMAL DIGITS\n         AH    R0,JOEID2           SECOND ID\n         CVD   R0,$DOUBLE          CONVERT TO PACKED\n         UNPK  JOEIDF,$DOUBLE+4(4) TO ZONED\n         OI    JOEIDF+6,X'F0'      FIX THE SIGN BYTE\n         MVI   JOEIDF+3,C'.'       INSERT PERIOD\n         SPACE\n         CLI   FCB,C'8'            FIRST CHAR=8 => 8LPI\n         BNE   EXTR1400            LET IT BE AT 6LPI\n         SPACE\n         LH    R1,SEPLINES         ---\n         BCTR  R1,0                -\n         MH    R1,=HS14'1.33333'   -  COMPUTE\n         AH    R1,=HS14'0.5'       -  SEPLINES =\n         SRA   R1,14               -    ROUNDED((SEPLINES-1)*1.3333)+1)\n         LA    R1,1(,R1)           -\n         STH   R1,SEPLINES         ---\nEXTR1400 DS    0H\n         SPACE\n         MVC   ROOMBLDG,=C'ROOM'   INITIALIZE\n         CLC   PNODE,PRCSITE       THIS SITE REQUIRE 'BLDG'?\n         BE    EXTR1800            NOPE...ONWARD\n         MVC   ROOMBLDG,=C'BLDG'   INITIALIZE\nEXTR1800 DS    0H\n         SPACE\n         BR    R8                  RETURN TO CALLER\n         SPACE\n         DROP  R6,R9               JOE,DCT\n         EJECT\n***********************************************************************\n* HEADER:                   /*  FORMAT & PRINT LOGO AND INFO      */  *\n*        IF THERE ARE NOT ENOUGH REMAINING LINES FOR LOGO             *\n*          THEN RETURN VIA R8;                                        *\n*        IF SITE REQUIRES APS LOGOS                                   *\n*          THEN DO;                                                   *\n*                 SET UP FOR APS LOGO AND TITLE LINE;                 *\n*                 IF ROOM INDICATES DELIVERY TO REMOTE BUILDING       *\n*                   THEN SET UP FOR 'DELIVER' BLOCK;                  *\n*               END;                                                  *\n*          ELSE SET UP FOR PRC LOGO AND TITLE LINE;                   *\n*        DECREMENT LINECNT FOR LOGO;                                  *\n*        DO FOR EACH DATA LINE;                                       *\n*          FORMAT TEXT AND VALUE FIELDS;                              *\n*          INSERT LOGO;                                               *\n*          CALL PRINTBUF SUBROUTINE;                                  *\n*        END:                                                         *\n*        CALL PRINTBLK FOR A BLANK LINE;                              *\n*        RETURN VIA R8;                                               *\n***********************************************************************\n         SPACE\nHEADER   DS    0H\n         LH    R0,LINECNT          REMAINING LINES\n         SH    R0,=H'17'           DECREMENT\n         BMR   R8                  NOT ENOUGH? GO BACK\n         STH   R0,LINECNT          UPDATE COUNT\n         SPACE\n         LA    R2,BUFSTART         DATA AREA IN BUFFER\n         USING INFOHEAD,R2\n         MVI   INFOHEAD,C' '       FILL CHARACTER\n         MVC   INFOHEAD+1(LINELEN),INFOHEAD\n         SPACE\n         LA    R6,DELIVERX         DEFAULT - NO REMOTE BLDG BLOCK\n         CLC   PNODE,PRCSITE       THIS SITE REQUIRE PRC LOGO?\n         BNE   HEAD1200            NOPE...ONWARD\n         SPACE\n         L     R3,=A(PRCLOGO)      SET LOGO ADDRESS\n         LA    R14,TH1PRC          SET TITLE HEADER LINE 1 ADDRESS\n         LA    R15,L'TH1PRC-1      SET LENGTH FOR EXECUTE\n         B     HEAD1900            ONWARD\n         SPACE\nHEAD1200 DS    0H\n         L     R3,=A(APSLOGO)      SET LOGO ADDRESS\n         LA    R14,TH1APS          SET TITLE HEADER LINE 1 ADDRESS\n         LA    R15,L'TH1APS-1      SET LENGTH FOR EXECUTE\n         CLI   ROOM,ROOMREM        DESIGNATED FOR REMOTE BLDG?\n         BNE   HEAD1900            NOPE...ONWARD\n         LA    R6,DELIVER          REMOTE BLDG BLOCK FIRST LINE\n         SPACE\nHEAD1900 DS    0H\n         SPACE\n*                                  LINE 1\n         SPACE\n         LA    R1,LINELEN-LOGOLEN-1          LENGTH FOR TITLE HEAD 1\n         SR    R1,R15                        SUBTRACT TEXT LENGTH\n         SRL   R1,1                          DIVIDE BLANK SPACE BY 2\n         LA    R1,INFOHEAD(R1)               CENTER HEAD1\n         EX    R15,HEAD9900                  FIRST HEAD LINE\n         MVC   INFOLOGO,0(R3)                LOGO LINE\n         BAL   R5,PRINTBUF                   PRINT IT\n         SPACE\n*                                  LINE 2\n         SPACE\n         LA    R3,LOGOLEN(,R3)               NEXT LINE OF LOGO\n         MVC   INFOLOGO,0(R3)                LOGO LINE\n         BAL   R5,PRINTBUF                   PRINT IT\n         SPACE\n*                                  LINE 3\n         SPACE\n         LA    R1,(LINELEN-LOGOLEN-L'TH2)/2\n         LA    R1,INFOHEAD(R1)               CENTER HEAD2\n         MVC   0(L'TH2,R1),TH2               SECOND HEAD LINE\n         LA    R3,LOGOLEN(,R3)               NEXT LINE OF LOGO\n         MVC   INFOLOGO,0(R3)                LOGO LINE\n         BAL   R5,PRINTBUF                   PRINT IT\n         SPACE\n*                                  LINE 4\n         SPACE\n         LA    R3,LOGOLEN(,R3)               NEXT LINE OF LOGO\n         MVC   INFOLOGO,0(R3)                LOGO LINE\n         BAL   R5,PRINTBUF                   PRINT IT\n         SPACE\n*                                  LINE 5\n         SPACE\n         MVC   INFOTXT1(L'TJN),TJN           JOBNAME\n         MVC   INFOVAL1(L'JOBNAME),JOBNAME   VALUE\n         MVC   INFOTXT2(L'TLN),TLN           LINES\n         CLI   SEPTYPE,ENDJOB                IS THIS A TRAILER?\n         BNE   HEAD2000                      NO...ONWARD\n         MVC   INFOTXT2(L'TLL),TLL           LINES LEFT\nHEAD2000 DS    0H\n         MVC   INFOVAL2(L'LINESREM),LINESREM REMAINING LINES\n         LA    R3,LOGOLEN(,R3)               NEXT LINE OF LOGO\n         MVC   INFOLOGO,0(R3)                LOGO LINE\n         BAL   R5,PRINTBUF                   PRINT IT\n         SPACE\n*                                  LINE 6\n         SPACE\n         MVC   INFOTXT1(L'TJI),TJI           JES JOB ID\n         MVC   INFOVAL1(L'JESJOBID),JESJOBID VALUE\n         MVC   INFOTXT2(L'TOF),TOF           OF\n         MVC   INFOVAL2(L'LINESTOT),LINESTOT TOTAL LINES\n         LA    R3,LOGOLEN(,R3)               NEXT LINE OF LOGO\n         MVC   INFOLOGO,0(R3)                LOGO LINE\n         BAL   R5,PRINTBUF                   PRINT IT\n         SPACE\n*                                  LINE 7\n         SPACE\n         LA    R3,LOGOLEN(,R3)               NEXT LINE OF LOGO\n         MVC   INFOLOGO,0(R3)                LOGO LINE\n         BAL   R5,PRINTBUF                   PRINT IT\n         SPACE\n*                                  LINE 8\n         SPACE\n         MVC   INFOTXT1(L'TON),TON           ORIGIN NODE\n         MVC   INFOVAL1(L'ONODE),ONODE       VALUE\n         MVC   INFOTXT2(L'TPO),TPO           PRINTED ON\n         MVC   INFOVAL2(L'PDEVICE),PDEVICE   VALUE\n         LA    R3,LOGOLEN(,R3)               NEXT LINE OF LOGO\n         MVC   INFOLOGO,0(R3)                LOGO LINE\n         BAL   R5,PRINTBUF                   PRINT IT\n         SPACE\n*                                  LINE 9\n         SPACE\n         MVC   INFOTXT2(L'TSY),TSY           SYSTEM\n         MVC   INFOVAL2(L'PSYSTEM),PSYSTEM   VALUE\n         LA    R3,LOGOLEN(,R3)               NEXT LINE OF LOGO\n         MVC   INFOLOGO,0(R3)                LOGO LINE\n         BAL   R5,PRINTBUF                   PRINT IT\n         SPACE\n*                                  LINE 10\n         SPACE\n         MVC   INFOTXT1(L'TGP),TGP           JOE GROUP NAME\n         MVC   INFOVAL1(L'GROUP),GROUP       VALUE\n         MVC   INFOTXT2(L'TPN),TPN           PRINTER NODE\n         MVC   INFOVAL2(L'PNODE),PNODE       VALUE\n         LA    R3,LOGOLEN(,R3)               NEXT LINE OF LOGO\n         MVC   INFOLOGO,0(R3)                LOGO LINE\n         BAL   R5,PRINTBUF                   PRINT IT\n         SPACE\n*                                  LINE 11\n         SPACE\n         MVC   INFOTXT1(L'TID),TID           JOE ID 1/2\n         MVC   INFOVAL1(L'JOEIDF),JOEIDF     VALUE\n         MVC   INFOTXT2(L'TRC),TRC           ROUTE CODE\n         MVC   INFOVAL2(L'PROUTE),PROUTE     VALUE\n         LA    R3,LOGOLEN(,R3)               NEXT LINE OF LOGO\n         MVC   INFOLOGO,0(R3)                LOGO LINE\n         BAL   R5,PRINTBUF                   PRINT IT\n         SPACE\n*                                  LINE 12\n         SPACE\n         LA    R3,LOGOLEN(,R3)               NEXT LINE OF LOGO\n         MVC   INFOLOGO,0(R3)                LOGO LINE\n         BAL   R5,PRINTBUF                   PRINT IT\n         SPACE\n*                                  LINE 13\n         SPACE\n         MVC   INFOTXT1(L'TTI),TTI           TIME\n         MVC   INFOVAL1(L'TIME24),TIME24     VALUE\n         MVC   INFOTXT2(L'TSC),TSC           SYSOUT CLASS\n         MVC   INFOVAL2(L'SYSOUTCL),SYSOUTCL VALUE\n         MVC   INFOVAL3(L'DELIVER),0(R6)     'DELIVER' BLOCK\n         LA    R3,LOGOLEN(,R3)               NEXT LINE OF LOGO\n         MVC   INFOLOGO,0(R3)                LOGO LINE\n         BAL   R5,PRINTBUF                   PRINT IT\n         SPACE\n*                                  LINE 14\n         SPACE\n         MVC   INFOTXT1(L'TDA),TDA           DATE\n         MVC   INFOVAL1+1(L'DATE),DATE       VALUE\n         MVC   INFOVAL1-L'WEEKDAY(L'WEEKDAY),WEEKDAY DAY-OF-WEEK\n         MVC   INFOTXT2(L'TFO),TFO           FORMS NAME\n         MVC   INFOVAL2(L'FORM),FORM         VALUE\n         LA    R6,L'DELIVER(,R6)             NEXT LINE OF BLOCK\n         MVC   INFOVAL3(L'DELIVER),0(R6)     'DELIVER' BLOCK\n         LA    R3,LOGOLEN(,R3)               NEXT LINE OF LOGO\n         MVC   INFOLOGO,0(R3)                LOGO LINE\n         BAL   R5,PRINTBUF                   PRINT IT\n         SPACE\n*                                  LINE 15\n         SPACE\n         MVC   INFOTXT2(L'TFC),TFC           FCB NAME\n         MVC   INFOVAL2(L'FCB),FCB           VALUE\n         LA    R6,L'DELIVER(,R6)             NEXT LINE OF BLOCK\n         MVC   INFOVAL3(L'DELIVER),0(R6)     'DELIVER' BLOCK\n         LA    R3,LOGOLEN(,R3)               NEXT LINE OF LOGO\n         MVC   INFOLOGO,0(R3)                LOGO LINE\n         BAL   R5,PRINTBUF                   PRINT IT\n         SPACE\n*                                  LINE 16\n         SPACE\n         MVC   INFOTXT1(L'TAL),TAL           ACF LOGON\n         MVC   INFOVAL1(L'ACF2NAME),ACF2NAME VALUE\n         LA    R6,L'DELIVER(,R6)             NEXT LINE OF BLOCK\n         MVC   INFOVAL3(L'DELIVER),0(R6)     'DELIVER' BLOCK\n         LA    R3,LOGOLEN(,R3)               NEXT LINE OF LOGO\n         MVC   INFOLOGO,0(R3)                LOGO LINE\n         BAL   R5,PRINTBUF                   PRINT IT\n         SPACE\n*                                  LINE 17\n         SPACE\n         MVC   INFOTXT1(L'TPG),TPG           PROGRAMMER\n         MVC   INFOVAL1(L'PGMRNAME),PGMRNAME VALUE\n         MVC   INFOVAL2-L'ROOMBLDG-1(L'ROOMBLDG),ROOMBLDG ROOM/BLDG\n         MVC   INFOVAL2(L'ROOM),ROOM         VALUE\n         LA    R6,L'DELIVER(,R6)             NEXT LINE OF BLOCK\n         MVC   INFOVAL3(L'DELIVER),0(R6)     'DELIVER' BLOCK\n         BAL   R5,PRINTBUF                   PRINT IT\n         SPACE\n         BAL   R5,PRINTBLK         PRINT BLANK LINE\n         SPACE\n         DROP  R2                  HEADER\n         BR    R8                  RETURN TO CALLER\n         SPACE\nHEAD9900 MVC   0(*-*,R1),0(R14)    EXECUTED -- MOVE TITLE HEADER LINE 1\n         EJECT\n***********************************************************************\n* BLOCK:                   /*  FORMAT & PRINT BLOCK LETTER LINES  */  *\n*        DO FOR ACF2NAME, JOBNAME, JOBID;                             *\n*          IF THERE ARE NOT ENOUGH REMAINING LINES FOR BLOCK LETTERS  *\n*              THEN RETURN VIA R5;                                    *\n*          DECREMENT LINE COUNT;                                      *\n*          ISSUE $PRBLOCK TO FORMAT AND PRINT;                        *\n*          CALL PRINTBLK SUBROUTINE FOR A BLANK LINE;                 *\n*        END;                                                         *\n*        RETURN VIA R8;                                               *\n***********************************************************************\n         SPACE\nBLOCK    DS    0H\n         LH    R0,LINECNT          REMAINING LINES\n         SH    R0,=Y(BLOCKLNS)     DECREMENT\n         BMR   R8                  NOT ENOUGH ROOM...RETURN\n         STH   R0,LINECNT          UPDATE COUNT\n         LA    R0,ACF2NAME         ACF2 LOGON ID\n         $PBLOCK DATA=(R0),BUFFER=(R7),SLANT=YES,CENTER=YES\n         BAL   R5,PRINTBLK         BLANK LINE\n         SPACE\n         LH    R0,LINECNT          REMAINING LINES\n         SH    R0,=Y(BLOCKLNS)     DECREMENT\n         BMR   R8                  NOT ENOUGH ROOM...RETURN\n         STH   R0,LINECNT          UPDATE COUNT\n         LA    R0,JOBNAME          JOBNAME\n         $PBLOCK DATA=(R0),BUFFER=(R7),SLANT=NO,CENTER=YES\n         BAL   R5,PRINTBLK         BLANK LINE\n         SPACE\n         LH    R0,LINECNT          REMAINING LINES\n         SH    R0,=Y(BLOCKLNS)     DECREMENT\n         BMR   R8                  NOT ENOUGH ROOM...RETURN\n         STH   R0,LINECNT          UPDATE COUNT\n         LA    R0,JESJOBID         JES JOBLOG ID\n         $PBLOCK DATA=(R0),BUFFER=(R7),SLANT=NO,CENTER=YES\n         BAL   R5,PRINTBLK         BLANK LINE\n         SPACE\n         BR    R8                  RETURN TO CALLER\n         EJECT\n***********************************************************************\n* DETAIL:       /*  FORMAT & PRINT DETAIL LINES TO EXHAUST COUNT  */  *\n*        IF NO MORE LINES TO PRINT                                    *\n*          THEN RETURN VIA R8;                                        *\n*        ADJUST LINECNT TO 0<LINECNT<X'100';                          *\n*        CLEAR PRINT AREA TO SPACES;                                  *\n*        SAVE LINECNT IN $PRPUT PARAMETER;                            *\n***********************************************************************\n         SPACE\nDETAIL   DS    0H\n         XR    R0,R0               CLEAR WORK REGISTER\n         ICM   R0,B'0011',LINECNT  GET LINECOUNT\n         BZR   R8                  NONE LEFT...RETURN\n         CH    R8,=Y(FF)           GREATER THAN X'FF'?\n         BNH   DET1000             NOPE...ONWARD\n         LH    R8,=Y(FF)           SET TO MAXIMUM\nDET1000  DS    0H\n         STC   R0,PRPUTPRM+1       SAVE IN $PRPUT PARM LIST\n         MVI   PRPUTPRM,PRPUTOPT   OTHER BYTE OF PARAMETER (OPTIONS)\n         SPACE\n         LA    R1,BUFSTART         AREA IN BUFFER FOR DATA\n         USING DETLINE,R1\n         SPACE\n         MVI   DETLINE,C' '        FILL CHARACTER\n         MVC   DETLINE+1(LINELEN),DETLINE\n         EJECT\n***********************************************************************\n*        FORMAT DETAIL LINE;                                          *\n***********************************************************************\n         SPACE\n         CLI   SEPTYPE,STARTJOB    START OF JOB?\n         BE    DET2100             YEP...GO SET\n         CLI   SEPTYPE,CONTJOB     CONTINUE?\n         BE    DET2200             YEP...GO SET\n         MVC   DETSTYPE,=C' END '  BEGINNING OF LINE\n         MVC   DETETYPE,=C' END '  END OF LINE\n         B     DET2400             ONWARD\nDET2100  DS    0H\n         MVC   DETSTYPE,=C'START'  BEGINNING OF LINE\n         MVC   DETETYPE,=C'START'  END OF LINE\n         B     DET2400             ONWARD\nDET2200  DS    0H\n         MVC   DETSTYPE,=C' CONT'  BEGINNING OF LINE\n         MVC   DETETYPE,=C'CONT '  END OF LINE\nDET2400  DS    0H\n         SPACE\n         MVI   DETSDLM,C'*'        FRAME DELIMETER CHARACTER\n         MVC   DETJNUM(1),JESJOBID     J/S/T CHARACTER ONLY\n         MVC   DETJNUM+1(4),JESJOBID+4 NUMBER PART\n         MVC   DETJNAME,JOBNAME    JOBNAME\n         MVC   DETONODE,ONODE      ORININATING DEVICE/NODE\n         MVC   DETACF2N,ACF2NAME   ACF2 USER ID\n         MVC   DETPNAME,PGMRNAME   PROGRAMMER NAME\n         MVC   DETRBTXT,ROOMBLDG   'ROOM' OR 'BLDG'\n         MVC   DETROOM,ROOM        ROOM\n         MVC   DETTIME,TIME12      TIME WITH AM/PM\n         MVC   DETDATE,DATE        DATE\n         MVC   DETPNODE,PNODE      PRINTER NODE\n         MVC   DETROUTE,PROUTE     JOE GROUP NAME\n         MVC   DETPSYS,PSYSTEM     SYSTEM ID\n         MVC   DETPDEV,PDEVICE     PRINTER DEVICE\n         MVC   DETCLASS,SYSOUTCL   SYSOUT CLASS\n         MVI   DETEDLM,C'*'        FRAME DELIMETER CHARACTER\n         EJECT\n***********************************************************************\n*        ISSUE $PRPUT WITH SPECIAL COUNT;                             *\n*        RETURN VIA R8;                                               *\n***********************************************************************\n         SPACE\n         LA    R0,LINELEN          LINE SIZE\n         $PRPUT DATA=(R1),LEN=(R0),WAIT=YES,COUNT=1\n         SPACE\n*              THE FOLLOWING CIRCUMVENTS A RESTRICTION\n*              PROHIBITING A VARIABLE NUMBER OF LINES\n*              TO BE PRINTED BY $PRPUT\n         SPACE\nDETFIX   ORG   *-X'E'              RESET TO WITHIN $PRPUT EXPANSION\nPRPUTOPT EQU   128                 FIRST BYTE OF $PRPUT PARM (OPTIONS)\n         ICM   R0,B'1100',PRPUTPRM NEW,IMPROVED PARM -- CORRECT COUNT\n         ORG   DETFIX              BACK TO NORMAL\n         SPACE\n*              END OF CIRCUMVENTION\n         SPACE\n         DROP  R1                  DETAIL LINE\n         BR    R8                  RETURN TO CALLER\n         EJECT\n***********************************************************************\n* ROUTEMAP:                            /*  DERIVED FROM HASPPRPU  */  *\n*        LOCATE FIRST AND LAST RDT;                                   *\n*        DO FOR EACH RDT;                                             *\n*          IF ROUTECODE = RDT ROUTE                                   *\n*            THEN IF THIS IS THE FIRST MATCH                          *\n*                   THEN SAVE DESTINATION;                            *\n*                   ELSE INDICATE MULTIPLE MATCHES FOUND;             *\n*        END;                                                         *\n***********************************************************************\n         SPACE\nROUTEMAP DS    0H\n         L     R15,$SVT            GET THE SSVT ADDRESS AND\n         USING SVT,R15\n         LM    R14,R15,SVTRDT      THEN FIRST/LAST DESTID\n         DROP  R15\n         USING RDT,R14\n         MVI   0(R1),X'00'         INDICATE NO DESTID YET\n         SPACE\nRMAP1000 DS    0H\n         CR    R14,R15             PAST THE END OF THE TABLE...\n         BH    RMAP4000            YES - BRANCH TO CONVERSION RTN\n         L     R2,RDTROUTE         LOAD COMPLETE ROUTE CODE\n         TM    RDTFLAG,RDTFLAGR    TEST FOR REMOTE\n         BNO   RMAP2000            BRANCH IF NOT REMOTE\n         TM    RDTFLAG,RDTFLAGN    IS NODE SPECIFIED\n         BO    RMAP2000            YES THEN BYPASS\n         ICM   R2,B'1100',$OWNNODE PROVIDE DEFAULT NODE\nRMAP2000 DS    0H\n         SPACE\n         CLR   R2,R0               A DESTID FOR THIS ROUTE?\n         BNE   RMAP3000            NO - GO CHECK THE NEXT ONE\n         CLI   0(R1),X'00'         HAVE DESTID FOR JOE YET ...\n         BNE   RMAP5000            YES, GO FORM JOE DEST\n         MVC   0(L'RDTNAME,R1),RDTNAME  NO, MOVE DESTID FROM RDT\nRMAP3000 DS    0H\n         LA    R14,RDTSIZ(,R14)    GET ADDR OF NEXT RDT\n         B     RMAP1000            BRANCH TO CONTINUE CHECKING\n         DROP  R14                 RDT\n         EJECT\n***********************************************************************\n*        IF NO MATCH WAS FOUND OR MULTIPLE MATCHES WERE FOUND         *     *\n*          THEN CONVERT ROUTECODE TO RNNNN|UNNNN|'LOCAL'              *\n*          ELSE USE DESTINATION FROM RDT;                             *\n*        RETURN VIA R5;                                               *\n***********************************************************************\n         SPACE\nRMAP4000 DS    0H\n         CLI   0(R1),X'00'         SINGLE DESTID FOR JOE ...\n         BNE   RMAP9000            YES, SKIP DEST FORMULATION\n         SPACE\nRMAP5000 DS    0H\n         CLM   R0,B'0011',$ZEROS   IS THIS A LOCAL JOE...\n         BE    RMAP7000            YES - BR TO LOCAL CONVERSION\n         SPACE\n         L     R15,=X'0000FFFF'    EXTRACTION MASK FOR REMOTE\n         NR    R15,R0              PLACE ROUTE INTO REGISTER\n         CVD   R15,0(R1)           CONVERT ROUTING TO DECIMAL\n         MVC   $DOUBLE(L'EDIT5),EDIT5   MOVE IN PATTERN\n         ED    $DOUBLE(L'EDIT5),5(R1)   AND EDIT ROUTING\n         MVC   0(5,R1),$DOUBLE+1   VALUE INTO\n         MVC   5(3,R1),$BLANKS     DESTINATION\n         CLM   R0,B'1100',$ZEROS   CHECK FOR UNIT SPECIFICATION\n         BE    RMAP6000            BR TO MOVE IN 'U' LABEL\n         MVI   0(R1),C'R'          INDICATE ROUTED TO REMOTE\n         B     RMAP9000            MOVE ROUTE INTO HDRLINE\nRMAP6000 DS    0H\n         MVI   0(R1),C'U'          INDICATE SPECIAL LOCAL ROUT\n         B     RMAP9000            MOVE ROUTE INTO HDRLINE\n         SPACE\nRMAP7000 DS    0H\n         MVC   0(8,R1),=CL8'LOCAL' MOVE LOCAL TO WORK AREA\n         SPACE\nRMAP9000 DS    0H\n         BR    R5                  RETURN TO CALLER\n         EJECT\n***********************************************************************\n* ENDPAGE:                 /*  FORMAT & PRINT END-OF-PAGE MARKER  */  *\n*        IF THIS IS NOT A TRAILER       - AND -                       *\n*           THIS IS THE LAST PAGE                                     *\n*          THEN RETURN VIA R8;                                        *\n*        FORMAT SKIP TO END-OF-PAGE;                                  *\n*        ISSUE $PRPUT TO SKIP TO END-OF-PAGE;                         *\n*        FORMAT ROW OF '*'S;                                          *\n*        ISSUE $PRPUT TO PRINT LINE;                                  *\n*        IF THIS IS THE LAST PAGE                                     *\n*          THEN RETURN VIA R8;                                        *\n*        ISSUE $PRPUT TO SKIP TO TOP-OF-PAGE;                         *\n*        RETURN VIA R8;                                               *\n***********************************************************************\n         SPACE\nENDPAGE  DS    0H\n         CLI   SEPTYPE,ENDJOB      TRAILER?\n         BE    ENDP1000            YEP...ALWAYS DO PAGE BREAK\n         CLC   PAGECNT,=H'1'       LAST PAGE?\n         BER   R8                  YEP...SKIP PAGE BREAK\nENDP1000 DS    0H\n         SPACE\n         LA    R1,BUFSTART         DATA AREA IN BUFFER\n         MVI   0(R1),SKIPCH9       SKIP TO CHANNEL 9 IMMEDIATE\n         LA    R0,1                DATA LENGTH\n         SPACE\n         $PRPUT DATA=(R1),LEN=(R0),WAIT=YES,COUNT=1,CC=M\n         SPACE\n         LA    R1,BUFSTART         DATA AREA IN BUFFER\n         MVI   0(R1),C'*'          BREAK CHARATCER\n         MVC   1(LINELEN-1,R1),0(R1)\n         LA    R0,LINELEN          DATA LENGTH\n         SPACE\n         $PRPUT DATA=(R1),LEN=(R0),WAIT=YES,COUNT=1\n         SPACE\n         CLC   PAGECNT,=H'1'       LAST PAGE?\n         BER   R8                  YEP...SKIP PAGE BREAK\n         LA    R1,BUFSTART         DATA AREA IN BUFFER\n         MVI   0(R1),SKIPCH1       SKIP TO CHANNEL 1 IMMEDIATE\n         LA    R0,1                DATA LENGTH\n         SPACE\n         $PRPUT DATA=(R1),LEN=(R0),WAIT=YES,COUNT=1,CC=M\n         SPACE\n         BR    R8                  RETURN TO CALLER\n         EJECT\n***********************************************************************\n* PRINTBUF:                    /*  PRINT A FORMATTED BUFFER LINE  */  *\n*        ISSUE $PRPUT FOR BUFFER;                                     *\n*        CLEAR BUFFER TO SPACES;                                      *\n*        RETURN VIA R5;                                               *\n***********************************************************************\n         SPACE\nPRINTBUF DS    0H\n         SPACE\n         LA    R1,BUFSTART         ADDRESS OF DATA PORTION OF BUFFER\n         LA    R0,LINELEN          MAX LINE LENGTH\n         $PRPUT LEN=(R0),DATA=(R1),WAIT=YES\n         SPACE\n         MVI   BUFSTART,C' '       FILL CHARACTER\n         MVC   BUFSTART+1(LINELEN-1),BUFSTART\n         SPACE\n         BR    R5                  RETURN\n         SPACE 2\n***********************************************************************\n* PRINTBLK:                                /*  PRINT BLANK LINES  */  *\n*        IF THERE ARE NOT ENOUGH REMAINING LINES                      *\n*          THEN RETURN VIA R5;                                        *\n*        DECREMENT LINE COUNTER;                                      *\n*        ISSUE $PRPUT FOR BUFFER;                                     *\n*        RETURN VIA R5;                                               *\n***********************************************************************\n         SPACE\nPRINTBLK DS    0H\n         LH    R0,LINECNT          REMAINING LINES\n         SH    R0,=H'1'            DECREMENT\n         BMR   R5                  NOT ENOUGH? GO BACK\n         STH   R0,LINECNT          UPDATE COUNT\n         SPACE\n         MVI   BUFSTART,C' '       BLANK\n         LA    R0,1                MAX LINE LENGTH\n         LA    R1,BUFSTART         ADDRESS OF DATA PORTION OF BUFFER\n         MVI   0(R1),SKIPLINE      SKIP 1 LINE IMMEDIATE\n         $PRPUT LEN=(R0),DATA=(R1),WAIT=YES,COUNT=1,CC=M\n         SPACE\n         BR    R5                  RETURN\n         SPACE\n         DROP  R4                  WORKAREA\n         DROP  R7                  BUFFER\n         EJECT\n***********************************************************************\n*        CONSTANTS AND LITERALS                                       *\n***********************************************************************\n         SPACE\nSTARTJOB EQU   0                   ---\nCONTJOB  EQU   4                   - SEPARATOR TYPE ENTRY PARM VALUES\nENDJOB   EQU   8                   ---\n         SPACE\nLCLHPAGE EQU   2                   NUMBER OF HEADER PAGES  --  LOCAL\nLCLTPAGE EQU   1                   NUMBER OF TRAILER PAGES --  LOCAL\nREMHPAGE EQU   1                   NUMBER OF HEADER PAGES  --  REMOTE\nREMTPAGE EQU   1                   NUMBER OF TRAILER PAGES --  REMOTE\n         SPACE\nBLOCKLNS EQU   12                  NUMBER OF LINES PRODUCED BY $PRBLOCK\nLINELEN  EQU   132                 PRINT LINE LENGTH\n         SPACE\n         DS    0F\nLCLPAGES DC    Y(LCLHPAGE,LCLTPAGE)\nREMPAGES DC    Y(REMHPAGE,REMTPAGE)\n         SPACE\nSKIPLINE EQU   X'09'               SKIP 1 LINE IMMEDIATE\nSKIPCH1  EQU   X'8B'               SKIP TO CH 1 IMMEDIATE -- TOP PAGE\nSKIPCH9  EQU   X'CB'               SKIP TO CH 9 IMMEDIATE -- END PAGE\n         SPACE\nLOGOLEN  EQU   64                  ALL LOGO LINES ARE 64 BYTES LONG\nLOGOLNES EQU   16                  ALL LOGOS HAVE 16 LINES\n         SPACE\nPRCSITE  DC    CL8'APS1'           SITE REQUIRING PRC LOGO\nROOMREM  EQU   C'C'                THIS FIRST CHAR OF ROOM => REM BLDG\n         SPACE\nTH1PRC DC C'P L A N N I N G  R E S E A R C H  C O R P O R A T I O N'\nTH1APS DC C'U. S.  P A T E N T  A N D  T R A D E M A R K   O F F I C E'\nTH2      DC    C'A U T O M A T E D  P A T E N T  S Y S T E M'\nTJN      DC    C'JOB NAME'\nTJI      DC    C'JES2 JOB ID'\nTON      DC    C'ORIGIN NODE'\nTGP      DC    C'GROUP NAME'\nTID      DC    C'JOE ID 1&&2'\nTTI      DC    C'TIME'\nTDA      DC    C'DATE'\nTAL      DC    C'ACF2 USER ID'\nTPG      DC    C'PROGRAMMER'\nTLN      DC    C'LINES'\nTLL      DC    C'LINES LEFT'\nTOF      DC    C'  OF'\nTPO      DC    C'PRINTED ON'\nTSY      DC    C'SYSTEM'\nTPN      DC    C'NODE'\nTRC      DC    C'ROUTE CODE'\nTSC      DC    C'SYSOUT CLASS'\nTFC      DC    C'FCB NAME'\nTFO      DC    C'FORMS'\n         SPACE\nDELIVER  DC    C'  ***********  '\n         DC    C' ************* '\n         DC    C'*** DELIVER ***'\n         DC    C' ************* '\n         DC    C'  ***********  '\nDELIVERL EQU   (*-DELIVER)/L'DELIVER\nDELIVERX DC    (DELIVERL)CL(L'DELIVER)' '\n         SPACE\nEDIT3    DC    X'40202120'           EDIT PATTERN -- BLANK + 3 DIGITS\nEDIT5    DC    X'402020202120'       EDIT PATTERN -- BLANK + 5 DIGITS\nEDIT7    DC    X'4020202020202120'   EDIT PATTERN -- BLANK + 7 DIGITS\n*                  H H : M M : S S\nEDITTIME DC    X'4021207A20207A2020' EDIT PATTERN -- TIME OF DAY\n         SPACE\n*                J  F  M  A  M  J  J  A  S  O  N  D\nMONTHLEN DC    H'31,29,31,30,31,30,31,31,30,31,30,31'\nLEAPYEAR DC    Y(31+28)            ADJUST DAY IF GREATER THAN THIS\nMONTHNAM DS    0CL3\n         DC    C'JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC???'\n         SPACE\nDAYS     DS    (0*7)CL9\n         DC    CL9' SATURDAY'\n         DC    CL9'   SUNDAY'      1/1/1900 (DAY 1) WAS SUNDAY\n         DC    CL9'   MONDAY'\n         DC    CL9'  TUESDAY'\n         DC    CL9'WEDNESDAY'\n         DC    CL9' THURSDAY'\n         DC    CL9'   FRIDAY'\n         SPACE 2\n         LTORG\n         EJECT\n***********************************************************************\n*        LOGO DEFINITIONS                                             *\n***********************************************************************\n         SPACE\n*              EACH LOGO DEFINITION IS 1K LONG. PUTTING THEM EARLIER\n*              IN THE CSECT CAUSES THE SINGLE BASE REGISTER\n*              ADDRESSING TO BE EXCEEDED. BY PLACING THEM LAST\n*              THE CSECT AND ADDRESSING VIA ACONS, LIFE GOES ON.\n*              NOTE THAT THE LOGOS ARE IN LOWER CASE.\n         SPACE\nPRCLOGO  EQU   *,LOGOLEN,C'C'\n DC C'      pppppppp              rrrrrrrr              cccccccc      '\n DC C'   pppppppppppppp        rrrrrrrrrrrrrr        cccccccccccccc   '\n DC C'  pppppppppppppppp      rrrrrrrrrrrrrrrr      cccccccccccccccc  '\n DC C' pppppp      pppppp    rrrrrr     rrrrrrr    cccccc      cccccc '\n DC C'pppppp        pppppp  rrrrrr       rrrrrrr  cccccc        cccccc'\n DC C'ppppp          ppppp  rrrrr         rrrrrr  ccccc               '\n DC C'ppppp          ppppp  rrrrr                 ccccc               '\n DC C'ppppp         pppppp  rrrrr                 cccccc        cccccc'\n DC C'ppppp p     ppppppp   rrrrr                  cccccc      cccccc '\n DC C'ppppp pppppppppppp    rrrrr                   cccccccccccccccc  '\n DC C'ppppp ppppppppppp     rrrrr                    cccccccccccccc   '\n DC C'ppppp  ppppppp        rrrrr                       cccccccc      '\n DC C'ppppp                                                           '\n DC C'ppppp                                                           '\n DC C'ppppp                                                           '\n DC C'ppppp                                                           '\nPRCLOGN  EQU   (*-PRCLOGO)/L'PRCLOGO  NUMBER OF LOGO LINES\n         SPACE\nAPSLOGO  EQU   *,LOGOLEN,C'C'\n DC C'      aaaaaaaa              pppppppp              ssssssss      '\n DC C'   aaaaaaaaaaaaa         pppppppppppppp        ssssssssssssss   '\n DC C'  aaaaaaaaaaaaaaaa      pppppppppppppppp      ssssssssssssssss  '\n DC C' aaaaaa      aaaaaa    pppppp      pppppp    ssssss      ssssss '\n DC C'aaaaaa        aaaaaa  pppppp        pppppp  sssssssssss   ssssss'\n DC C'aaaaa          aaaaa  ppppp          ppppp     sssssssssss      '\n DC C'aaaaa          aaaaa  ppppp          ppppp        sssssssssss   '\n DC C'aaaaaa        aaaaaa  ppppp         pppppp  ssssss   sssssssssss'\n DC C' aaaaaa      aaaaaaa  ppppp p     ppppppp    ssssss      ssssss '\n DC C'  aaaaaaaaaaaaaaaaaa  ppppp pppppppppppp      ssssssssssssssss  '\n DC C'   aaaaaaaaaaaaaaaaa  ppppp ppppppppppp        ssssssssssssss   '\n DC C'      aaaaaaaa aaaaa  ppppp  ppppppp              ssssssss      '\n DC C'                      ppppp                                     '\n DC C'                      ppppp                                     '\n DC C'                      ppppp                                     '\n DC C'                      ppppp                                     '\nAPSLOGN  EQU   (*-APSLOGO)/L'APSLOGO  NUMBER OF LOGO LINES\n         SPACE\n         EJECT\n***********************************************************************\n*        DSECTS                                                       *\n***********************************************************************\n         SPACE\nWORKAREA DSECT\n         SPACE\nJOBNAME  DS    CL8                 JOBNAME\nACF2NAME DS    CL8                 ACF2 LOGON ID\nJESJOBID DS    CL8                 JES JOBLOG ID\nPNODE    DS    CL8                 FORMATTED ROUTE/DESTINATION NODE\nPDEVICE  DS    CL8                 PRINTER DEVICE\nPROUTE   DS    CL8                 JOE ROUTE CODE\nGROUP    DS    CL8                 JOE GROUP NAME\nONODE    DS    CL8                 JOB ORIGIN DEVICE/NODE\nLINESTOT DS    CL8                 TOTAL LINES FOR JOE\nLINESREM DS    CL8                 REMAINING LINES FOR JOE\nPAGESTOT DS    CL8                 TOTAL PAGES FOR JOE\nPAGESREM DS    CL8                 REMAINING PAGES FOR JOE\nROOMBLDG DS    CL4                 'ROOM' OR 'BLDG'\nFORM     DS    CL8                 FORM NAME\nROOM     DS    CL4                 PROGRAMMER'S ROOM\nPSYSTEM  DS    CL4                 PRINTER SYSTEM ID\nFCB      DS    CL4                 FCB NAME\nPGMRNAME DS    CL20                PROGRAMMER'S NAME\nSYSOUTCL DS    CL1                 SYSOUT CLASS\n         DS    CL2                 SPACE FOR EXTRA EDIT BYTES\nJOEIDF   DS    CL7                 FORMATTED JOE ID1/ID2\nWEEKDAY  DS    CL(L'DAYS)          DAY OF THE WEEK\nDATE     DS    0CL7                ---\nDATEDAY  DS    CL2                 - FORMATTED DATE\nDATEMON  DS    CL3                 - LIKE DDMMMYY\nDATEYR   DS    CL2                 ---\n         DS    C                   SPACE FOR EDIT FILLER BYTE\nTIME24   DS    CL8                 FORMATTED TIME - 24 HOUR CLOCK\n         DS    C                   SPACE FOR EDIT FILLER BYTE\nTIME12   DS    CL10                FORMATTED TIME - 12 HOUR CLOCK\nPDATE    DS    0PL4                ---\n         DS    X                   - PACKED DATE\nPYEAR    DS    X                   - FROM TIME SVC\nPDAY     DS    PL2                 ---\nPDAYS    DS    0PL6                ACCUMULATOR\nWEEKNO   DS    PL5                 WEEK NUMBER SINCE 1/1/1900\nDAYNO    DS    PL1                 DAY-OF-THE-WEEK\nSEPPAGES DS    0F                  HEADER/TRAILER PAGE COUNTS\nHPAGES   DS    H                   HEADER PAGES\nTPAGES   DS    H                   TRAILER PAGES\nSEPLINES DS    H                   LINES PER SEPARATOR\nLINECNT  DS    H                   LINES OF HEADER REMAINING\nPAGECNT  DS    H                   PAGES OF HEADER REMAINING\nPRPUTPRM DS    XL2                 SPECIAL PARAMETER FOR $PRPUT\nSEPTYPE  DS    X                   START/CONT/END\n         SPACE\nWORKLEN  EQU   *-WORKAREA\n         EJECT\nINFOHEAD DSECT\n         SPACE\nINFOTXT1 DS    CL14                FIRST TEXT FIELD\nINFOVAL1 DS    CL13                FIRST VALUE & SPACES\nINFOTXT2 DS    CL14                SECOND TEXT\nINFOVAL2 DS    CL27                SECOND VALUE & SPACES\nINFOVAL3 EQU   INFOVAL2+6,L'DELIVER,C'C'  'REMOTE BLDG' BLOCK\nINFOLOGO DS    CL(LOGOLEN)         LOGO AREA\n         SPACE 3\nDETLINE  DSECT\n         SPACE\nDETSDLM  DS    CL1,C               FRAME DELIMETER, BLANK\nDETSTYPE DS    CL5,C               FORM TYPE START/CONT/END, BLANK\nDETJNUM  DS    CL5,C               JOB NUMBER(SHORT FORM), BLANK\nDETJNAME DS    CL8,C               JOB NAME, BLANK\nDETONODE DS    CL8,C               JOB ORIGIN, BLANK\nDETACF2N DS    CL8,C               ACF2 USER ID NAME, BLANK\nDETPNAME DS    CL20,C              PROGRAMMER, BLANK\nDETRBTXT DS    CL4,C               'ROOM', BLANK\nDETROOM  DS    CL4,C               ROOM NUMBER, BLANK\nDETTIME  DS    CL10,C              TIME AS HH:MM:SSAM, BLANK\nDETDATE  DS    CL7,C               DATE AS DDMMMYY\nDETPNODE DS    CL8,C               PRINTER NODE, BLANK\nDETROUTE DS    CL8,C               ROUTE CODE, BLANK\nDETPSYS  DS    CL4,C               PRINTER SYSTEM ID, BLANK\nDETPDEV  DS    CL8,C               DEVICE, BLANK\nDETCLASS DS    CL1,C               SYSOUT CLASS, BLANK\nDETETYPE DS    CL5,C               FORM TYPE START/CONT/END,BLANK\nDETEDLM  DS    CL1                 FRAME DELIMETER\n         SPACE\nDETLEN   EQU   *-DETLINE\n         SPACE 2\n***********************************************************************\n*        JES EPILOGUE                                                 *\n***********************************************************************\n         SPACE 2\nPRINTSEP CSECT\n         PRINT NOGEN\n         $MODEND\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RECEIVED": {"ttr": 7945, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00S\\x00S\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 83, "newlines": 83, "modlines": 0, "user": "FILE369"}, "text": "         TITLE 'RECEIVE NOTIFY EXIT'\n***********************************************************************\n*                                                                     *\n* NAME         RECEIVED                                               *\n*                                                                     *\n* COMPONENT    JES2 EXIT                                              *\n*                                                                     *\n* FUNCTION     PROVIDE NOTIFICATION OF RECEIVED MESSAGE.              *\n*                                                                     *\n* ENTRY        VIA $EXIT FROM HASPNET AS EXIT 13 AT RCVEX13.          *\n*                                                                     *\n* PARAMETERS   |                                                      *\n*                                                                     *\n* INPUT        |                                                      *\n*                                                                     *\n* OUTPUT       |                                                      *\n*                                                                     *\n* RETURN CODES |                                                      *\n*                                                                     *\n* FILES        |                                                      *\n*                                                                     *\n* EXT REF      |                                                      *\n*                                                                     *\n* EXITS        |                                                      *\n*                                                                     *\n* MESSAGES     |                                                      *\n*                                                                     *\n* MACROS       |                                                      *\n*                                                                     *\n* TABLES       |                                                      *\n*                                                                     *\n* OPERATION    SET RETURN CODE 8 TO CAUSE $HASP549 TO BE ISSUED.      *\n*                                                                     *\n* ATTRIBUTES   |                                                      *\n*                                                                     *\n* RESTRICTIONS |                                                      *\n*                                                                     *\n* NOTES        |                                                      *\n*                                                                     *\n* PROGRAMMER   C. J. PITTS                                            *\n*                                                                     *\n* MAINTENANCE  WHO    DATE     DESCRIPTION                            *\n*              PTW    01/19/89 IMPLEMENT JES2 2.1.5                L02*\n*                                                                     *\n**********************************************************************/\n*                                                                     *\n* REGISTERS AT ENTRY                                                  *\n*              R1    PARAMETER LIST                                   *\n*              R10   JCT                                              *\n*              R11   HCT                                              *\n*              R13   PCE                                              *\n*              R14   RETURN ADDRESS                                   *\n*              R15   ENTRY ADDRESS                                    *\n*                                                                     *\n* REGISTER USE IN PROGRAM                                             *\n*              R12   BASE REGISTER                                    *\n*                                                                     *\n* REGISTERS AT EXIT                                                   *\n*              R15   RETURN CODE                                      *\n*                                                                     *\n**********************************************************************/\n         EJECT\n         COPY $HASPGBL\n         SPACE\nRECEIVED $MODULE $BUFFER,                                              +\n               $CAT,                                                   +\n               $HCT,                                                   +\n               $JCT,                                                   +\n               $JQE,                                                   +\n               $MIT,                                                   +\n               $PCE,                                                   +\n               $HASPEQU,                                               +\n               RPL                                                  L02\n         SPACE\nRCVEX13  $ENTRY BASE=R12\n         SPACE\n         $SAVE\n         SPACE\n         $RETURN RC=8\n         SPACE\n         $MODEND\n         SPACE 3\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REGS": {"ttr": 7948, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\x1c\\x00\\x1c\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "FILE369"}, "text": "         MACRO\n         REGS\n         SPACE\n***********************************************************************\n*              REGISTER EQUATES                                       *\n*        R0-R15  GENERAL PURPOSE REGISTERS                            *\n*        F0-F6   FLOATING POINT REGISTERS                             *\n*        V0-V15  VECTOR REGISTERS                                     *\n*        C0-C15  CONTROL REGISTERS                                    *\n***********************************************************************\n         SPACE\n         PUSH  PRINT\n         PRINT NOGEN\n&I       SETA  0\n&F       SETB  1\n.LOOP    ANOP\n&F       SETB  (NOT &F)\nR&I      EQU   &I\nV&I      EQU   &I\nC&I      EQU   &I\n         AIF   (&I GT 6 OR &F).NOFLOAT\nF&I      EQU   &I\n.NOFLOAT ANOP\n&I       SETA  &I+1\n         AIF   (&I LE 15).LOOP\n         POP   PRINT\n         SPACE\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REPLYTO": {"ttr": 8193, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x98 ?\\x00\\x98\"o\\x15$\\x02\\xb7\\x02\\xab\\x00\\x18\\xc9\\xe2\\xc3\\xe2\\xc5\\xc2@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1998-07-22T00:00:00", "modifydate": "1998-08-14T15:24:00", "lines": 695, "newlines": 683, "modlines": 24, "user": "ISCSEB"}, "text": "PRC      TITLE 'REPLYTO - RESPOND TO AN OUTSTANDING WTOR.'\n********************************************************************\n*                                                                  *\n* NAME - REPLYTO.   LINK WITH AMODE=31, RMODE=24, AND AC=1         *\n*                                                                  *\n* DESCRIPTION -                                                    *\n*                                                                  *\n*   THIS PROGRAM WILL ISSUE A CANNED REPLY TO A SELECTED WTOR      *\n*   MESSAGE, THEREBY HELPING TO AUTOMATE OPERATIONS A BIT MORE.    *\n*   IT ACCEPTS AS INPUT THE WTOR MESSAGE TEXT, THE CANNED REPLY    *\n*   MESSAGE TEXT, AND OPTIONALLY THE JOBNAME OF THE WTOR ISSUER,   *\n*   ALONG WITH OTHER MISC. OPTIONS, AS DESCRIBED BELOW.            *\n*                                                                  *\n*   FOR EXAMPLE, THE FOLLOWING JOB STEP                            *\n*     //S1 EXEC PGM=REPLYTO,                                       *\n*     // PARM='J=ADA8|M=ADA040A|R=OK'                              *\n*     //STEPLIB DD  DSN=YOUR.APF.STEPLIB,DISP=SHR                  *\n*   WILL REPLY \"OK\" TO A WTOR MESSAGE BEGINNING \"ADA040A\" THAT     *\n*   IS ISSUED BY JOB ADA8.                                         *\n*                                                                  *\n* TO USE -                                                         *\n*                                                                  *\n*   EXEC PGM=REPLYTO,PARM='MSG=MMMMMMMM...|                        *\n*                          REPLY=RRRRRRRR...|                      *\n*                          ABEND=YES/NO|                           *\n*                          COLUMN=99|                              *\n*                          ERRMSG=YES/NO|                          *L02\n*                          JOB=JJJJJJJJ|                           *\n*                          TIME=999|                               *\n*                          WAIT=YES/NO'                            *\n*                                                                  *\n*           M(SG)    = THE WTOR MESSAGE TEXT TO BE REPLIED TO:     *\n*                      MMMMMMMM... = TEXT (1-72 CHARS).            *\n*           R(EPLY)  = THE REPLY MESSAGE TEXT:                     *\n*                      RRRRRRRR... = TEXT (1-72 CHARS).            *\n*           A(BEND)  = DO WE ABEND IMMEDIATELY IF WTOR TEXT ISN'T  *\n*                      LOCATED?                                    *\n*                      Y(ES): ABEND WITH U123.                     *\n*                      N(O):  DON'T ABEND, RETURN CC=4 (DEFAULT).  *L02\n*           C(OLUMN) = BEGINNING COLUMN OF WTOR MESSAGE TEXT TO    *\n*                      BEGIN COMPARE (LIKE A SUBSTRING):           *\n*                      NN = 1-72 (DEFAULT=1).                      *\n*           E(RRMSG) = DO WE PUT OUT AN ERROR MESSAGE WHEN WTOR    *L02\n*                      MESSAGE TEXT ISN'T FOUND?                   *L02\n*                      Y(ES): PUT OUT ERROR MESSAGE (DEFAULT).     *L02\n*                      N(O):  DON'T PUT OUT ERROR MESSAGE.         *L02\n*           J(OB)    = TEST FOR THIS JOBNAME ISSUING THE WTOR:     *\n*                      JJJJJJJJ = JOBNAME (1-8 CHARS).             *\n*                      NOTE: A MASK IS ALLOWED - JOB=ABC*.         *\n*           T(IME)   = FOR ACTION=WAIT, ELAPSED SECONDS TO WAIT    *\n*                      BEFORE GIVING UP SEARCH:                    *\n*                      NNNN = 1-9999 (DEFAULT=30).                 *\n*                      NOTE: ROUNDED UP TO NEXT 5 SECOND INTERVAL. *\n*           W(AIT)   = DO WE RETRY (STIMER WAIT AND LOOP) IF WE    *\n*                      DON'T FIND WTOR TEXT?                       *\n*                      Y(ES): WE WAIT (A TOTAL OF TIME= SECONDS).  *\n*                      N(O):  WE DON'T WAIT (DEFAULT). WE WILL     *\n*                             EITHER ABEND OR RETURN, CC=12.(DEF). *\n*                                                                  *\n*     NOTE: MSG= AND REPLY= ARE REQUIRED. PLEASE NOTE THAT \"|\"     *\n*           IS OUR PARAMETER DELIMITER RATHER THAN \",\".            *\n*     NOTE: THIS MODULE MUST RUN APF AUTHORIZED.                   *\n*                                                                  *\n* LOG -                                                            *\n*   04/01/87 L01 PTW IMPLEMENTED                                   *L01\n*   11/10/87 L02 PTW ADD ERRMSG= PARM, RC=4 WHEN ABEND=NO.         *L02\n*   08/13/98 L03 EKB REPLYIDS > 99 (TESTED AT OS/390 1.3)        . *L03\n*                    (FROM ALAN FIELD AT SUPER VALUE)            . *L03\n*                                                                  *\n********************************************************************\n         LCLC  &CSECT\n&CSECT   SETC  'REPLYTO'\n&CSECT   CSECT ,\n&CSECT   AMODE 31                                                   L03\n&CSECT   RMODE 24                                                   L03\n********************************************************************\n*                                                                  *\n*        I N I T I A L I Z E                                       *\n*                                                                  *\n********************************************************************\n         PRINT NOGEN\n         SAVE  (14,12),,&CSECT-&SYSDATE-&SYSTIME\n         LR    R12,R15            ESTABLISH BASE.\n         USING &CSECT,R12         TELL ASSEMBLER.\n         GETMAIN RU,LV=DYNLEN     GET DYNAMIC AREA.\n         LR    R2,R13             SAVE AREA\n         LR    R13,R1             SAVE AREA\n         USING DYNAMIC,R13        TELL ASSEMBLER.\n         LA    R0,DYNAMIC         ZERO\n         L     R1,=A(DYNLEN)        DYNAMIC\n         LR    R14,R0                 STORAGE.\n         SLR   R15,R15\n         MVCL  R0,R14              DO IT.\n         ST    R2,4(,R13)         BACK CHAIN.\n         ST    R13,8(,R2)         FORWARD CHAIN.\n         XC    RC,RC              ASSUME GOOD RC.\n         MVI   WTOFLG,0           RESET WTOFLG.\n         MVC   OURJOB,=CL8' '\n         L     R2,PSAAOLD-PSA     FIND OUR JOBNAME FROM ASCB.\n         USING ASCB,R2\n         L     R3,ASCBJBNI        NAME IS HERE IF WE'RE A JOB.\n         LTR   R3,R3\n         BNZ   *+8\n         L     R3,ASCBJBNS        NAME IS HERE IF AN STC OR TSU.\n         MVC   OURJOB,0(R3)\n         MVI   TSO,NO             ASSUME WE'RE NOT TSO.\n         L     R3,ASCBTSB         FIND OUT IF WE'RE TSO.\n         LTR   R3,R3\n         BZ    *+8\n         MVI   TSO,YES            WE ARE TSO - WE'LL DO TPUTS.\n         DROP  R2\n********************************************************************\n*                                                                  *\n*        P A R M   P R O C E S S I N G                             *\n*                                                                  *\n********************************************************************\n         MVI   PARM,0             INIT FLAGS.\n         MVI   MASK,0\n         MVI   ABEND,NO           ABEND=NO IS DEFAULT.\n         MVC   COLUMN,=H'1'       COLUMN=1 IS DEFAULT.\n         MVI   ERRMSG,YES         ERRMSG=YES IS DEFAULT.            L02\n         MVC   JOB,=CL8' '\n         MVC   MSG,C' '\n         MVC   MSG+1(L'MSG-1),MSG\n         MVC   REPLY,C' '\n         MVC   REPLY+1(L'REPLY-1),REPLY\n         MVC   TIME,=F'30'        TIME=30 IS DEFAULT.\n         MVI   WAIT,NO            WAIT=NO IS DEFAULT.\nDOPARM   DS    0H\n         L     R2,4(,R13)         DIG BACK THRU SAVEAREAS\n         L     R2,24(,R2)           FOR THE A(PARM).\n         L     R2,0(,R2)          R2 = A(PARM).\n         LH    R3,0(,R2)          R3 = L'PARM.\n         LTR   R3,R3              IF ZEROS +\n         BZ    BADPARM              THEN EXIT.\n         LA    R2,2(,R2)          R2 = A(START OF TEXT).\n         LA    R3,0(R3,R2)        R3 = A(END OF TEXT).\n         ST    R3,SAVE\n         LR    R3,R2\nTRYSTOPR DS    0H                 SCAN FOR THE '|'.\n         CLI   0(R3),C'|'         IF A '|',\n         BE    GOTSTOPR             THEN EXIT.\n         LA    R3,1(,R3)          ELSE, LOOP.\n         CL    R3,SAVE            IF STILL MORE TO GO,\n         BL    TRYSTOPR             KEEP SCANNING.\nGOTSTOPR DS    0H\n         LR    R4,R3\n         SR    R4,R2              R4 = L'KEYWORD +L'VALUE.\n         L     R11,=A(KWORDTAB)    DO A TABLE LOOKUP ON THE\n         USING KTABLE,R11\nTRYKWORD DS    0H\n         CLI   KTABKEY,X'FF'\n         BE    BADPARM\n         SLR   R5,R5\n         IC    R5,KTABKEYL        CHECK THAT THE LENGTH IS FEASIBLE.\n         CLR   R4,R5\n         BNH   NXTKWORD\n         BCTR  R5,0\n         EX    R5,CLCKWORD        DO THE COMPARE.\n         BE    GOTKWORD\nNXTKWORD DS    0H\n         LA    R11,KTABLEN(,R11)    IF NOT EQUAL, BUMP TO NEXT ENTRY.\n         B     TRYKWORD\nCLCKWORD CLC   KTABKEY(*-*),0(R2)\nNXTPARM  DS    0H\n         CL    R3,SAVE            CHECK FOR ANY MORE PARM FIELD.\n         BNL   DOCHECK\n         LA    R2,1(,R3)          IF YES, POSITION CURSOR.\n         LR    R3,R2\n         B     TRYSTOPR\nGOTKWORD DS    0H\n         XC    VALUELEN,VALUELEN  INITIALIZE WORKAREAS.\n         MVI   VALUE,C' '\n         MVC   VALUE+1(L'VALUE-1),VALUE\n         MVI   VALUEFLG,0\n         SLR   R4,R4\n         IC    R4,KTABKEYL\n         LA    R2,0(R4,R2)        BUMP CURSOR PAST KEYWORD.\n         LR    R4,R3              CALCULATE LENGTH OF VALUE.\n         SR    R4,R2\n         BNP   BADPARM\n         STH   R4,VALUELEN        SAVE L'VALUE.\n         BCTR  R4,0\n         EX    R4,MVCVALUE        AND VALUE.\n         CLI   KTABTYPE,KEY       IF TYPE IS KEY, PROCESS.\n         BE    DOKEY\n         CLI   KTABTYPE,NUM       IF TYPE IS NUM, PROCESS.\n         BE    DONUM\n         CLI   KTABTYPE,FLG       IF TYPE IS FLG, PROCESS.\n         BE    DOFLG\nDOCHR    DS    0H                 ASSUME TYPE IS CHR.\n         CLC   KTABMINW,VALUELEN+1  CHECK FOR MINIMUM WIDTH.\n         BH    BADPARM\n         CLC   KTABMAXW,VALUELEN+1  CHECK FOR MINIMUM WIDTH.\n         BL    BADPARM\nDOROUT   DS    0H\n         L     R14,KTABROUT        GO TO THE PROPER ROUTINE.\n         BR    R14\n         DROP  R11\nMVCVALUE MVC   VALUE(*-*),0(R2)\nDOKEY    DS    0H                 TYPE IS KEY.\n         USING KTABLE,R11\n         L     R11,KTABVTAB       R11 = A(VALUE TABLE).\n         DROP  R11\n         L     R14,0(,11)         R14 = A(ROUTINE).\n         LA    R11,4(,R11)        R11 = A(VALUES).\n         USING VTABLE,R11\nVALLOOP  DS    0H                 DO TABLE LOOKUP.\n         CLI   VTABKEY,X'FF'      IF AT END, UNKNOWN VALUE.\n         BE    BADPARM\n         CLC   VTABKEYL,VALUELEN+1 LENGTHS MUST MATCH.\n         BNE   NXTVALUE\n         LH    R4,VALUELEN\n         BCTR  R4,0\n         EX    R4,CLCVALUE        DO COMPARE.\n         BE    GOTVALUE\nNXTVALUE DS    0H\n         LA    R11,VTABLEN(,R11)  BUMP TO NEXT ENTRY.\n         B     VALLOOP\nGOTVALUE DS    0H\n         MVC   VALUEFLG,VTABVAL   GOT HIT: MOVE VALUE FLAG.\n         BR    R14\nCLCVALUE CLC   VTABKEY(*-*),0(R2)\n         DROP  R11\nDONUM    DS    0H                 TYPE IS NUM.\n         LA    R4,VALUE\n         LH    R5,VALUELEN\nNUMLOOP  DS    0H                 VERIFY NUMERIC.\n         CLI   0(R4),C'0'            SCAN\n         BL    BADPARM              FORWARD\n         CLI   0(R4),C'9'            SCAN\n         BH    BADPARM              FORWARD\n         LA    R4,1(,R4)              TO FIRST\n         BCT   R5,NUMLOOP\n         B     DOROUT             GO TO ROUTINE.\nDOFLG    DS    0H                 TYPE IS KEY.\n         USING KTABLE,R11\n         L     R14,KTABROUT       R14 = A(ROUTINE).\n         DROP  R11\n         L     R11,=A(FLGTAB)     R11 = A(VALUE TABLE).\n         USING VTABLE,R11\nFLGLOOP  DS    0H\n         CLI   VTABKEY,X'FF'      IF AT END, BAD PARM.\n         BE    BADPARM\n         CLC   VTABKEYL,VALUELEN+1 CHECK LENGTHS.\n         BNE   NXTFLVAL\n         LH    R4,VALUELEN\n         BCTR  R4,0\n         EX    R4,CLCVALUE        COMPARE VALUES.\n         BE    GOTFLG\nNXTFLVAL DS    0H\n         LA    R11,VTABLEN(,R11)  BUMP TO NEXT ENTRY.\n         B     FLGLOOP\nGOTFLG   DS    0H\n         MVC   VALUEFLG,VTABVAL   GOT HIT: MOVE IN FLAG VALUE.\n         BR    R14\nDOABEND  DS    0H                 THE ABEND= ROUTINE.\n         TM    PARM,GOTABEND      ALLOW ONLY ONE SPECIFICATION.\n         BO    BADPARM\n         MVC   ABEND,VALUEFLG\n         OI    PARM,GOTABEND      INDICATE WE HAVE A VALUE.\n         B     NXTPARM\nDOCOL    DS    0H                 THE COLUMN= ROUTINE.\n         TM    PARM,GOTCOL        ALLOW ONLY ONE SPECIFICATION.\n         BO    BADPARM\n         LH    R4,VALUELEN\n         BCTR  R4,0               MACHINE LENGTH.\n         EX    R4,PACKNUM         PACK SECONDS.\n         CVB   R5,DOUBLE          CONVERT TO BINARY.\n         CH    R5,=H'1'           TEST SECONDS\n         BL    BADPARM             FOR LIMITS.\n         CH    R5,=H'72'\n         BH    BADPARM\n         OI    PARM,GOTCOL        INDICATE WE HAVE A VALUE.\n         STH   R5,COLUMN           AND STORE.\n         B     NXTPARM\nPACKNUM  PACK  DOUBLE,VALUE(*-*)\nDOERRMSG DS    0H                 THE ERRMSG= ROUTINE.              L02\n         TM    PARM,GOTERRMS      ALLOW ONLY ONE SPECIFICATION.     L02\n         BO    BADPARM                                              L02\n         MVC   ERRMSG,VALUEFLG                                      L02\n         OI    PARM,GOTERRMS      INDICATE WE HAVE A VALUE.         L02\n         B     NXTPARM                                              L02\nDOJOB    DS    0H                 THE JOB= ROUTINE.\n         TM    PARM,GOTJOB        ALLOW ONLY ONE SPECIFICATION.\n         BO    BADPARM\n         MVC   JOBLEN,VALUELEN    MOVE VALUE.\n         MVC   JOB,VALUE\n         OI    PARM,GOTJOB        INDICATE WE HAVE A VALUE.\n         LH    R4,JOBLEN          CHECK FOR A MASK.\n         LA    R5,JOB-1(R4)\n         CLI   0(R5),C'*'\n         BNE   NOJOBMSK\n         BCTR  R4,0\n         STH   R4,JOBLEN          GOT MASK: INDICATE THUSLY.\n         OI    MASK,GOTJOB\nNOJOBMSK DS    0H\n         B     NXTPARM\nDOMSG    DS    0H                 THE MSG= ROUTINE.\n         TM    PARM,GOTMSG        ALLOW ONLY ONE SPECIFICATION.\n         BO    BADPARM\n         MVC   MSGLEN,VALUELEN    MOVE VALUE.\n         MVC   MSG,VALUE          MOVE VALUE.\n         OI    PARM,GOTMSG        INDICATE WE HAVE A VALUE.\n         B     NXTPARM\nDOREPLY  DS    0H                 THE REPLY= ROUTINE.\n         TM    PARM,GOTREPLY        ALLOW ONLY ONE SPECIFICATION.\n         BO    BADPARM\n         MVC   REPLYLEN,VALUELEN    MOVE VALUE.\n         MVC   REPLY,VALUE          MOVE VALUE.\n         OI    PARM,GOTREPLY      INDICATE WE HAVE A VALUE.\n         B     NXTPARM\nDOTIME   DS    0H                 THE TIME= ROUTINE.\n         TM    PARM,GOTTIME       ALLOW ONLY ONE SPECIFICATION.\n         BO    BADPARM\n         LH    R4,VALUELEN\n         BCTR  R4,0               MACHINE LENGTH.\n         EX    R4,PACKNUM         PACK SECONDS.\n         CVB   R5,DOUBLE          CONVERT TO BINARY.\n         CH    R5,=H'1'           TEST SECONDS\n         BL    BADPARM             FOR LIMITS.\n         CH    R5,=H'999'\n         BH    BADPARM\n         OI    PARM,GOTTIME       INDICATE WE HAVE A VALUE.\n         ST    R5,TIME             AND STORE.\n         B     NXTPARM\nDOWAIT   DS    0H                 THE WAIT= ROUTINE.\n         TM    PARM,GOTWAIT       ALLOW ONLY ONE SPECIFICATION.\n         BO    BADPARM\n         MVC   WAIT,VALUEFLG\n         OI    PARM,GOTWAIT       INDICATE WE HAVE A VALUE.\n         B     NXTPARM\nDOCHECK  DS    0H                 CONSISTENCY CHECKING.\n         TM    PARM,GOTMSG+GOTREPLY MSG AND REPLY ARE REQUIRED.\n         BNO   BADPARM\nENDPARM  DS    0H\n         MVC   TIMELIM,TIME       INIT ELAPSED TIME COUNTER.\n         DROP  R11\n********************************************************************\n*                                                                  *\n*        M A I N L I N E                                           *\n*                                                                  *\n********************************************************************\n* HERE WE SEARCH FOR THE WTOR MESSAGE TEXT. THE WQE'S ARE IN THE\n* CONSOLE ADDRESS SPACE PRIVATE MEMORY, SO WE MUST USE XMEM SERVICES.\nDOSCAN   DS    0H\n         L     R2,CVTPTR\n         L     R2,CVTCUCB-CVT(,R2) R2 = A(UCM).\n         USING UCM,R2\n         LH    R3,UCMCTID         CONSOLE ADDRESS SPACE\n         STH   R3,CONSASID        PUT AWAY\n         LR    R3,R2\n         SH    R3,=H'4'\n         L     R3,0(,R3)          R3 = A(UCM PREFIX).\n         USING UCMPRFX,R3\n         L     R4,UCMMCENT        R4 = A(MCON UCMENTRY).\n         USING UCMLIST,R4\n         SLR   R5,R5\n         IC    R5,UCMID           R5 = MCON ID.\n         STH   R5,MCONSID         SAVE.\n         DROP  R3,R4\n         MODESET MODE=SUP,KEY=ZERO\n         ESAR  R3 ,\n         STH   R3,SASID           SAVE CURRENT SECONDARY ASID.\n         AXSET AX==H'1'\n         LA    R7,30              LOOP VALUE.\n         L     R3,UCMRPYQ         R3 = A(1ST ORE).\n         USING OREF,R3\nORELOOP  DS    0H\n         LA    R3,0(,R3)\n         LTR   R3,R3              IF R3 = 0, EXHAUSTED CHAIN.\n         BZ    NOREPLY\n         L     R4,ORERWQE         R4 = A(ASSOCIATED WQE).\n         LH    R5,CONSASID        GET 'CONSOLE' ASID\n         SSAR  R5 ,               SET CONSOLE AS SECONDARY\n         LA    R5,L'MYWQE\n         SR    R15,R15            'FROM' KEY\n         MVCP  MYWQE(R5),0(R4),R15\n         LH    R5,SASID           RESTORE PREVIOUS SECONDARY -\n         SSAR  R5 ,               SHOULD BE SAME AS PRIMARY\n         LA    R4,MYWQE           R4 = A(COPY OF WQE).\n         USING WQE,R4\n         LH    R6,COLUMN          SET COLUMN= POINTER FOR COMPARE.\n         BCTR  R6,0\n         LA    R5,WQETXT+4(R6)\n         AH    R6,MSGLEN\n         C     R6,WQENBR\n         BH    NEXTORE            MAKE SURE LENGTHS ARE FEASABLE.\n         LH    R6,MSGLEN\n         BCTR  R6,0\n         EX    R6,CLCMSG          DO COMPARE.\n         BNE   NEXTORE\n         TM    PARM,GOTJOB        CHECK FOR MATCHING JOB= .\n         BZ    DOREP\n         MVC   WTORJOB,=CL8' '\n         LOCASCB ASID=OREASID     GET ASCB OF WTOR ISSUER.\n         LTR   R1,R1\n         USING ASCB,R1\n         BNP   BADASID\n         L     R5,ASCBJBNI        GET JOBNAME OF WTOR ISSUER.\n         LTR   R5,R5\n         BNZ   *+8\n         L     R5,ASCBJBNS\n         MVC   WTORJOB,0(R5)\n         DROP  R1\nBADASID  DS    0H\n         LA    R5,L'WTORJOB-1     DEFAULT LENGTH.\n         TM    MASK,GOTJOB        IF MASK, DO COMPARE AS IS.\n         BZ    *+10\n         LH    R5,JOBLEN          ELSE USE JOB= LENGTH.\n         BCTR  R5,0\n         EX    R5,CLCJOB          DO COMPARE.\n         BE    DOREP              OKEYDOKE, EXIT.\nNEXTORE  DS    0H\n         L     R3,ORELKP          NEXT ORE.\n         BCT   R7,ORELOOP         LOOP.\nNOREPLY  DS    0H\n         AXSET AX==H'0'           RESET AUTHORIZATION.\n         MODESET KEY=NZERO,MODE=PROB\n         CLI   WAIT,YES           NO HIT, DO WE WAIT.\n         BNE   BADREPLY           NOPE, EXIT.\n         STIMER WAIT,BINTVL==F'1000' WAIT FOR 5 SECONDS.\n         L     R2,TIMELIM         SUBTRACT 5 SECONDS.\n         SH    R2,=H'10'\n         BNP   BADREPLY           CHECK WAIT LIMIT.\n         ST    R2,TIMELIM\n         B     DOSCAN\nCLCMSG   CLC   MSG(*-*),0(R5)\nCLCJOB   CLC   JOB(*-*),WTORJOB\n********************************************************************\n*                                                                  *\n*        I S S U E   R E P L Y   C O M M A N D                     *\n*                                                                  *\n********************************************************************\nDOREP    DS    0H\n         AXSET AX==H'0'             RESET AUTHORIZATION.\n         MVC   REPLYID(4),=C'    '                                  L03\n         MVC   REPLYID+2(2),OREID   FORMAT \"99\" OF R 99,            L03\n         CLC   OREID(2),=X'0000'    IS REPLY > 99?                  L03\n         BNE   DOREP1               NO - WE'RE SET TO REPLY         L03\n         L     R2,ORERPIDB          GET BINARY REPLY ID             L03\n         CVD   R2,DOUBLE            MAKE IT DECIMAL                 L03\n         MVC   REPLYID(4),=X'40202021'                              L03\n         ED    REPLYID(4),DOUBLE+6                                  L03\nDOREP1   EQU   *                                                    L03\n         MODESET KEY=NZERO,MODE=PROB\n         MVI   MGCRLGTH,L'REPLY     MOVE IN REPLY TEXT.\n         MVC   COMMAND(2),=CL2'R '                                  L03\n         MVI   REPLYID+4,C',' L03\n         MODESET KEY=ZERO,MODE=SUP\n         LH    R0,MCONSID           R0 = MCONS ID.\n         MGCR  MGCRPL               SVC 34.\n         LR    R5,R15               SAVE RC.\n         MODESET KEY=NZERO,MODE=PROB\n         LTR   R5,R5                CHECK SVC 34 RC.\n         BNZ   BADSVC34\n         B     GOODREP\n         DROP  R2,R3,R4\n********************************************************************\n*                                                                  *\n*        R E T U R N                                               *\n*                                                                  *\n********************************************************************\nRETURN   DS    0H\n         L     R2,RC                  R2 = RC.\n         LR    R1,R13              PREPARE\n         L     R13,4(,R13)         FOR FREEMAIN.\n         FREEMAIN RU,LV=DYNLEN,A=(1)\n         LR    R15,R2              AND RETURN\n         RETURN (14,12),RC=(15)      WITH R15 = RC.\nDIE      DS    0H\n         ABEND 123\n********************************************************************\n*                                                                  *\n*        M E S S A G E S                                           *\n*                                                                  *\n********************************************************************\nBADPARM  DS    0H                 FORMAT THE BAD PARM MESSAGE.\n         MVC   RC,=F'12'\n         LA    R2,MSGPARM\n         LA    R3,L'MSGPARM\n         LA    R4,BADEND\n         B     DOMESSAG\nBADREPLY DS    0H                 FORMAT THE BAD REPLY MESSAGE.\n         MVC   RC,=F'4'\n         CLI   ERRMSG,YES                                           L02\n         BNE   BADEND                                               L02\n         MVI   MSGAREA,C' '\n         MVC   MSGAREA+1(L'MSGAREA-1),MSGAREA\n         MVC   MSGAREA(L'MSGREPLY),MSGREPLY\n         MVC   MSGJOB,OURJOB      DEFAULT TO TARGET JOBNAME.\n         LA    R2,MSGAREA\n         LA    R3,L'MSGREPLY\n         LA    R4,BADEND\n*        OI    WTOFLG,NONROLL    INDICATE NONROLL.\n         B     DOMESSAG\nBADSVC34 DS    0H                 FORMAT THE BAD SVC34 MESSAGE.\n         MVC   RC,=F'12'\n         LA    R2,MSGSVC34\n         LA    R3,L'MSGSVC34\n         LA    R4,BADEND\n         B     DOMESSAG\nGOODREP  DS    0H                 ISSUE THE GOOD REPLY MESSAGE.\n         MVI   MSGAREA,C' '\n         MVC   MSGAREA+1(L'MSGAREA-1),MSGAREA\n         MVC   MSGAREA(L'MSGROK),MSGROK\n         MVC   MSGJOB,OURJOB\n         MVC   MSGCOMM,COMMAND\n         LA    R2,MSGAREA\n         LA    R3,L'MSGAREA\n         LA    R4,RETURN\n         OI    WTOFLG,NOTPUT\n         B     DOMESSAG\nDOMESSAG DS    0H\n         CH    R3,=H'80'          MAX LENGTH IS 80 BYTES.\n         BL    *+8\n         LA    R3,80\n         TM    WTOFLG,NOTPUT\n         BO    DOWTO\n         CLI   TSO,YES            ISSUE TPUT FOR TSO.\n         BE    DOTPUT\nDOWTO    DS    0H\n         MVC   WTO(WTOLEN),XWTO     ELSE DO WTO.\n         BCTR  R3,0\n         EX    R3,MVCWTO\n         TM    WTOFLG,NONROLL\n         BZ    *+8\n         MVI   WTODESC,X'40'\n         WTO   MF=(E,WTO)\n         B     ENDMSG\nDOTPUT   DS    0H\n         MVC   TPUT(TPUTLEN),XTPUT\n         TPUT  (R2),(R3),MF=(E,TPUT)\n         NI    WTOFLG,255-(NONROLL+NOTPUT)\n         B     ENDMSG\nENDMSG   DS    0H\n         BR    R4\nMVCWTO   MVC   WTOMSG(*-*),0(R2)\nBADEND   DS    0H                 BADEND - DO WE ABEND OR CC=4?     L02\n         CLI   ABEND,NO\n         BE    RETURN\n         CLI   ERRMSG,YES                                           L02\n         BNE   DIE                                                  L02\n         LA    R2,MSGABEND\n         LA    R3,L'MSGABEND\n         LA    R4,DIE\n         B     DOMESSAG\n********************************************************************\n*                                                                  *\n*        S T A T I C   A R E A S.                                  *\n*                                                                  *\n********************************************************************\nXTPUT    TPUT  0,0,EDIT,WAIT,,BREAKIN,MF=L\nTPUTLEN  EQU   *-XTPUT\nXWTO     WTO   '                                                       X\n                                            ',ROUTCDE=11,MF=L\nWTOLEN   EQU   *-XWTO\nMSGPARM  DC    C'REP010E  THE PARM FIELD IS BAD. PGM IS TERMINATING.'\nMSGREPLY DC    C'REP020E          : WTOR NOT FOUND. NO REPLY ISSUED.'\nMSGSVC34 DC    C'REP030E  BAD RC FROM SVC34. PGM IS TERMINATING.'\nMSGABEND DC    C'REP040I  A U123 ABEND FOLLOWS.'\nMSGROK   DC    C'REP050I         :'\n         LTORG *\nSRCLEVEL DC    C'                                        '\nKWORDTAB CSECT ,                  PARAMETER KEYWORD TABLE.\n         DC    CL8'A=      ',AL1(2,FLG,0,0),A(DOABEND)\n         DC    CL8'ABEND=  ',AL1(6,FLG,0,0),A(DOABEND)\n         DC    CL8'C=      ',AL1(2,NUM,1,2),A(DOCOL)\n         DC    CL8'COL=    ',AL1(4,NUM,1,2),A(DOCOL)\n         DC    CL8'COLUMN= ',AL1(7,NUM,1,2),A(DOCOL)\n         DC    CL8'E=      ',AL1(2,FLG,0,0),A(DOERRMSG)             L02\n         DC    CL8'ERR=    ',AL1(4,FLG,0,0),A(DOERRMSG)             L02\n         DC    CL8'ERRMSG= ',AL1(7,FLG,0,0),A(DOERRMSG)             L02\n         DC    CL8'J=      ',AL1(2,CHR,1,8),A(DOJOB)\n         DC    CL8'JOB=    ',AL1(4,CHR,1,8),A(DOJOB)\n         DC    CL8'M=      ',AL1(2,CHR,1,72),A(DOMSG)\n         DC    CL8'MSG=    ',AL1(4,CHR,1,72),A(DOMSG)\n         DC    CL8'R=      ',AL1(2,CHR,1,72),A(DOREPLY)\n         DC    CL8'REP=    ',AL1(4,CHR,1,72),A(DOREPLY)\n         DC    CL8'REPLY=  ',AL1(6,CHR,1,72),A(DOREPLY)\n         DC    CL8'T=      ',AL1(2,NUM,1,3),A(DOTIME)\n         DC    CL8'TIME=   ',AL1(5,NUM,1,3),A(DOTIME)\n         DC    CL8'W=      ',AL1(2,FLG,0,0),A(DOWAIT)\n         DC    CL8'WAIT=   ',AL1(5,FLG,0,0),A(DOWAIT)\n         DC    X'FF'\nKTABLE   DSECT\nKTABKEY  DS    CL8\nKTABKEYL DS    AL1\nKTABTYPE DS    AL1\nKEY      EQU   X'01'\nCHR      EQU   X'02'\nNUM      EQU   X'04'\nFLG      EQU   X'08'\nKTABMINW DS    AL1\nKTABMAXW DS    AL1\nKTABROUT DS    A\n         ORG   KTABROUT\nKTABVTAB DS    A\nKTABLEN  EQU   *-KTABLE\nFLGTAB   CSECT ,                  FLAG TABLE.\n         DC    CL8'YES     ',AL1(3,YES)\n         DC    CL8'Y       ',AL1(1,YES)\n         DC    CL8'NO      ',AL1(2,NO)\n         DC    CL8'N       ',AL1(1,NO)\n         DC    X'FF'\nVTABLE   DSECT\nVTABKEY  DS    CL8\nVTABKEYL DS    AL1\nVTABVAL  DS    AL1\nVTABLEN  EQU   *-VTABLE\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   A R E A S.                                *\n*                                                                  *\n********************************************************************\nDYNAMIC  DSECT\nSAVE     DS    18F                     SAVE AREA.\nDOUBLE   DS    D                       SAVE AREA.\nRC       DS    F                       RETURN CODE.\nWTO      DS    0F,CL(WTOLEN)\nWTODESC  EQU   *-4,2\nWTOMSG   EQU   WTO+4,80\nMSGAREA  DS    CL80\nMSGJOB   EQU   MSGAREA+9,8\nMSGCOMM  EQU   MSGAREA+19,61\nTPUT     DS    0F,CL(TPUTLEN)\nMCONSID  DS    H\nCONSASID DS    H\nSASID    DS    H\nWTOFLG   DS    X\nNONROLL  EQU   X'80'\nNOTPUT   EQU   X'40'\nTSO      DS    X\nNO       EQU   1\nYES      EQU   2\nOURJOB   DS    CL8\nMYWQE    DS    CL(WQESIZE)\nWTORJOB  DS    CL8\nVALUELEN DS    H\nVALUE    DS    CL100\nCOLUMN   DS    H\nTIME     DS    F\nTIMELIM  DS    F\nMSGLEN   DS    H\nMSG      DS    CL72\nREPLYLEN DS    H\n         IEZMGCR DSECT=NO\n         ORG   MGCRTEXT\nCOMMAND  DS    CL2\nREPLYID  DS    CL4,CL1             'NNNN,'                          L03\nREPLY    DS    CL72\n         ORG\nJOBLEN   DS    H\nJOB      DS    CL8\nVALUEFLG DS    X\nPARM     DS    X\nGOTABEND EQU   X'01'\nGOTCOL   EQU   X'02'\nGOTJOB   EQU   X'04'\nGOTMSG   EQU   X'08'\nGOTREPLY EQU   X'10'\nGOTTIME  EQU   X'20'\nGOTWAIT  EQU   X'40'\nGOTERRMS EQU   X'80'                                                L02\nMASK     DS    X\nWAIT     DS    X\nABEND    DS    X\nERRMSG   DS    X                                                    L02\nDYNLEN   EQU   *-DYNAMIC               LENGTH.\n         PRINT OFF\nR0       EQU   00\nR1       EQU   01\nR2       EQU   02\nR3       EQU   03\nR4       EQU   04\nR5       EQU   05\nR6       EQU   06\nR7       EQU   07\nR8       EQU   08\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12                 PROGRAM BASE.\nR13      EQU   13                 A(SAVE AREA).\nR14      EQU   14\nR15      EQU   15\n         PRINT ON\n         IHAPSA ,                 PSA\n         CVT   DSECT=YES\n         IHAASCB ,                ASCB\nUCM      DSECT ,\n         IEECUCM ,\n         IHAORE ,\n         IHAWQE ,\n         END   &CSECT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REPLYTOO": {"ttr": 8451, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x02\\xab\\x02\\xab\\x00\\x00\\xd6\\xd3\\xc4\\xe5\\xc5\\xd9\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 683, "newlines": 683, "modlines": 0, "user": "OLDVERS"}, "text": "PRC      TITLE 'REPLYTO - RESPOND TO AN OUTSTANDING WTOR.'\n********************************************************************\n*                                                                  *\n* NAME - REPLYTO.                                                  *\n*                                                                  *\n* DESCRIPTION -                                                    *\n*                                                                  *\n*   THIS PROGRAM WILL ISSUE A CANNED REPLY TO A SELECTED WTOR      *\n*   MESSAGE, THEREBY HELPING TO AUTOMATE OPERATIONS A BIT MORE.    *\n*   IT ACCEPTS AS INPUT THE WTOR MESSAGE TEXT, THE CANNED REPLY    *\n*   MESSAGE TEXT, AND OPTIONALLY THE JOBNAME OF THE WTOR ISSUER,   *\n*   ALONG WITH OTHER MISC. OPTIONS, AS DESCRIBED BELOW.            *\n*                                                                  *\n*   FOR EXAMPLE, THE FOLLOWING JOB STEP                            *\n*     //S1 EXEC PGM=REPLYTO,                                       *\n*     // PARM='J=ADA8|M=ADA040A|R=OK'                              *\n*     //STEPLIB DD  DSN=YOUR.APF.STEPLIB,DISP=SHR                  *\n*   WILL REPLY \"OK\" TO A WTOR MESSAGE BEGINNING \"ADA040A\" THAT     *\n*   IS ISSUED BY JOB ADA8.                                         *\n*                                                                  *\n* TO USE -                                                         *\n*                                                                  *\n*   EXEC PGM=REPLYTO,PARM='MSG=MMMMMMMM...|                        *\n*                          REPLY=RRRRRRRR...|                      *\n*                          ABEND=YES/NO|                           *\n*                          COLUMN=99|                              *\n*                          ERRMSG=YES/NO|                          *L02\n*                          JOB=JJJJJJJJ|                           *\n*                          TIME=999|                               *\n*                          WAIT=YES/NO'                            *\n*                                                                  *\n*           M(SG)    = THE WTOR MESSAGE TEXT TO BE REPLIED TO:     *\n*                      MMMMMMMM... = TEXT (1-72 CHARS).            *\n*           R(EPLY)  = THE REPLY MESSAGE TEXT:                     *\n*                      RRRRRRRR... = TEXT (1-72 CHARS).            *\n*           A(BEND)  = DO WE ABEND IMMEDIATELY IF WTOR TEXT ISN'T  *\n*                      LOCATED?                                    *\n*                      Y(ES): ABEND WITH U123.                     *\n*                      N(O):  DON'T ABEND, RETURN CC=4 (DEFAULT).  *L02\n*           C(OLUMN) = BEGINNING COLUMN OF WTOR MESSAGE TEXT TO    *\n*                      BEGIN COMPARE (LIKE A SUBSTRING):           *\n*                      NN = 1-72 (DEFAULT=1).                      *\n*           E(RRMSG) = DO WE PUT OUT AN ERROR MESSAGE WHEN WTOR    *L02\n*                      MESSAGE TEXT ISN'T FOUND?                   *L02\n*                      Y(ES): PUT OUT ERROR MESSAGE (DEFAULT).     *L02\n*                      N(O):  DON'T PUT OUT ERROR MESSAGE.         *L02\n*           J(OB)    = TEST FOR THIS JOBNAME ISSUING THE WTOR:     *\n*                      JJJJJJJJ = JOBNAME (1-8 CHARS).             *\n*                      NOTE: A MASK IS ALLOWED - JOB=ABC*.         *\n*           T(IME)   = FOR ACTION=WAIT, ELAPSED SECONDS TO WAIT    *\n*                      BEFORE GIVING UP SEARCH:                    *\n*                      NNNN = 1-9999 (DEFAULT=30).                 *\n*                      NOTE: ROUNDED UP TO NEXT 5 SECOND INTERVAL. *\n*           W(AIT)   = DO WE RETRY (STIMER WAIT AND LOOP) IF WE    *\n*                      DON'T FIND WTOR TEXT?                       *\n*                      Y(ES): WE WAIT (A TOTAL OF TIME= SECONDS).  *\n*                      N(O):  WE DON'T WAIT (DEFAULT). WE WILL     *\n*                             EITHER ABEND OR RETURN, CC=12.(DEF). *\n*                                                                  *\n*     NOTE: MSG= AND REPLY= ARE REQUIRED. PLEASE NOTE THAT \"|\"     *\n*           IS OUR PARAMETER DELIMITER RATHER THAN \",\".            *\n*     NOTE: THIS MODULE MUST RUN APF AUTHORIZED.                   *\n*                                                                  *\n* LOG -                                                            *\n*   04/01/87 L01 PTW IMPLEMENTED                                   *L01\n*   11/10/87 L02 PTW ADD ERRMSG= PARM, RC=4 WHEN ABEND=NO.         *L02\n*                                                                  *\n********************************************************************\n         LCLC  &CSECT\n&CSECT   SETC  'REPLYTO'\n&CSECT   CSECT ,\n********************************************************************\n*                                                                  *\n*        I N I T I A L I Z E                                       *\n*                                                                  *\n********************************************************************\n         PRINT NOGEN\n         SAVE  (14,12),,&CSECT-&SYSDATE-&SYSTIME\n         LR    R12,R15            ESTABLISH BASE.\n         USING &CSECT,R12         TELL ASSEMBLER.\n         GETMAIN RU,LV=DYNLEN     GET DYNAMIC AREA.\n         LR    R2,R13             SAVE AREA\n         LR    R13,R1             SAVE AREA\n         USING DYNAMIC,R13        TELL ASSEMBLER.\n         LA    R0,DYNAMIC         ZERO\n         L     R1,=A(DYNLEN)        DYNAMIC\n         LR    R14,R0                 STORAGE.\n         SLR   R15,R15\n         MVCL  R0,R14              DO IT.\n         ST    R2,4(,R13)         BACK CHAIN.\n         ST    R13,8(,R2)         FORWARD CHAIN.\n         XC    RC,RC              ASSUME GOOD RC.\n         MVI   WTOFLG,0           RESET WTOFLG.\n         MVC   OURJOB,=CL8' '\n         L     R2,PSAAOLD-PSA     FIND OUR JOBNAME FROM ASCB.\n         USING ASCB,R2\n         L     R3,ASCBJBNI        NAME IS HERE IF WE'RE A JOB.\n         LTR   R3,R3\n         BNZ   *+8\n         L     R3,ASCBJBNS        NAME IS HERE IF AN STC OR TSU.\n         MVC   OURJOB,0(R3)\n         MVI   TSO,NO             ASSUME WE'RE NOT TSO.\n         L     R3,ASCBTSB         FIND OUT IF WE'RE TSO.\n         LTR   R3,R3\n         BZ    *+8\n         MVI   TSO,YES            WE ARE TSO - WE'LL DO TPUTS.\n         DROP  R2\n********************************************************************\n*                                                                  *\n*        P A R M   P R O C E S S I N G                             *\n*                                                                  *\n********************************************************************\n         MVI   PARM,0             INIT FLAGS.\n         MVI   MASK,0\n         MVI   ABEND,NO           ABEND=NO IS DEFAULT.\n         MVC   COLUMN,=H'1'       COLUMN=1 IS DEFAULT.\n         MVI   ERRMSG,YES         ERRMSG=YES IS DEFAULT.            L02\n         MVC   JOB,=CL8' '\n         MVC   MSG,C' '\n         MVC   MSG+1(L'MSG-1),MSG\n         MVC   REPLY,C' '\n         MVC   REPLY+1(L'REPLY-1),REPLY\n         MVC   TIME,=F'30'        TIME=30 IS DEFAULT.\n         MVI   WAIT,NO            WAIT=NO IS DEFAULT.\nDOPARM   DS    0H\n         L     R2,4(,R13)         DIG BACK THRU SAVEAREAS\n         L     R2,24(,R2)           FOR THE A(PARM).\n         L     R2,0(,R2)          R2 = A(PARM).\n         LH    R3,0(,R2)          R3 = L'PARM.\n         LTR   R3,R3              IF ZEROS +\n         BZ    BADPARM              THEN EXIT.\n         LA    R2,2(,R2)          R2 = A(START OF TEXT).\n         LA    R3,0(R3,R2)        R3 = A(END OF TEXT).\n         ST    R3,SAVE\n         LR    R3,R2\nTRYSTOPR DS    0H                 SCAN FOR THE '|'.\n         CLI   0(R3),C'|'         IF A '|',\n         BE    GOTSTOPR             THEN EXIT.\n         LA    R3,1(,R3)          ELSE, LOOP.\n         CL    R3,SAVE            IF STILL MORE TO GO,\n         BL    TRYSTOPR             KEEP SCANNING.\nGOTSTOPR DS    0H\n         LR    R4,R3\n         SR    R4,R2              R4 = L'KEYWORD +L'VALUE.\n         L     R11,=A(KWORDTAB)    DO A TABLE LOOKUP ON THE\n         USING KTABLE,R11\nTRYKWORD DS    0H\n         CLI   KTABKEY,X'FF'\n         BE    BADPARM\n         SLR   R5,R5\n         IC    R5,KTABKEYL        CHECK THAT THE LENGTH IS FEASIBLE.\n         CLR   R4,R5\n         BNH   NXTKWORD\n         BCTR  R5,0\n         EX    R5,CLCKWORD        DO THE COMPARE.\n         BE    GOTKWORD\nNXTKWORD DS    0H\n         LA    R11,KTABLEN(,R11)    IF NOT EQUAL, BUMP TO NEXT ENTRY.\n         B     TRYKWORD\nCLCKWORD CLC   KTABKEY(*-*),0(R2)\nNXTPARM  DS    0H\n         CL    R3,SAVE            CHECK FOR ANY MORE PARM FIELD.\n         BNL   DOCHECK\n         LA    R2,1(,R3)          IF YES, POSITION CURSOR.\n         LR    R3,R2\n         B     TRYSTOPR\nGOTKWORD DS    0H\n         XC    VALUELEN,VALUELEN  INITIALIZE WORKAREAS.\n         MVI   VALUE,C' '\n         MVC   VALUE+1(L'VALUE-1),VALUE\n         MVI   VALUEFLG,0\n         SLR   R4,R4\n         IC    R4,KTABKEYL\n         LA    R2,0(R4,R2)        BUMP CURSOR PAST KEYWORD.\n         LR    R4,R3              CALCULATE LENGTH OF VALUE.\n         SR    R4,R2\n         BNP   BADPARM\n         STH   R4,VALUELEN        SAVE L'VALUE.\n         BCTR  R4,0\n         EX    R4,MVCVALUE        AND VALUE.\n         CLI   KTABTYPE,KEY       IF TYPE IS KEY, PROCESS.\n         BE    DOKEY\n         CLI   KTABTYPE,NUM       IF TYPE IS NUM, PROCESS.\n         BE    DONUM\n         CLI   KTABTYPE,FLG       IF TYPE IS FLG, PROCESS.\n         BE    DOFLG\nDOCHR    DS    0H                 ASSUME TYPE IS CHR.\n         CLC   KTABMINW,VALUELEN+1  CHECK FOR MINIMUM WIDTH.\n         BH    BADPARM\n         CLC   KTABMAXW,VALUELEN+1  CHECK FOR MINIMUM WIDTH.\n         BL    BADPARM\nDOROUT   DS    0H\n         L     R14,KTABROUT        GO TO THE PROPER ROUTINE.\n         BR    R14\n         DROP  R11\nMVCVALUE MVC   VALUE(*-*),0(R2)\nDOKEY    DS    0H                 TYPE IS KEY.\n         USING KTABLE,R11\n         L     R11,KTABVTAB       R11 = A(VALUE TABLE).\n         DROP  R11\n         L     R14,0(,11)         R14 = A(ROUTINE).\n         LA    R11,4(,R11)        R11 = A(VALUES).\n         USING VTABLE,R11\nVALLOOP  DS    0H                 DO TABLE LOOKUP.\n         CLI   VTABKEY,X'FF'      IF AT END, UNKNOWN VALUE.\n         BE    BADPARM\n         CLC   VTABKEYL,VALUELEN+1 LENGTHS MUST MATCH.\n         BNE   NXTVALUE\n         LH    R4,VALUELEN\n         BCTR  R4,0\n         EX    R4,CLCVALUE        DO COMPARE.\n         BE    GOTVALUE\nNXTVALUE DS    0H\n         LA    R11,VTABLEN(,R11)  BUMP TO NEXT ENTRY.\n         B     VALLOOP\nGOTVALUE DS    0H\n         MVC   VALUEFLG,VTABVAL   GOT HIT: MOVE VALUE FLAG.\n         BR    R14\nCLCVALUE CLC   VTABKEY(*-*),0(R2)\n         DROP  R11\nDONUM    DS    0H                 TYPE IS NUM.\n         LA    R4,VALUE\n         LH    R5,VALUELEN\nNUMLOOP  DS    0H                 VERIFY NUMERIC.\n         CLI   0(R4),C'0'            SCAN\n         BL    BADPARM              FORWARD\n         CLI   0(R4),C'9'            SCAN\n         BH    BADPARM              FORWARD\n         LA    R4,1(,R4)              TO FIRST\n         BCT   R5,NUMLOOP\n         B     DOROUT             GO TO ROUTINE.\nDOFLG    DS    0H                 TYPE IS KEY.\n         USING KTABLE,R11\n         L     R14,KTABROUT       R14 = A(ROUTINE).\n         DROP  R11\n         L     R11,=A(FLGTAB)     R11 = A(VALUE TABLE).\n         USING VTABLE,R11\nFLGLOOP  DS    0H\n         CLI   VTABKEY,X'FF'      IF AT END, BAD PARM.\n         BE    BADPARM\n         CLC   VTABKEYL,VALUELEN+1 CHECK LENGTHS.\n         BNE   NXTFLVAL\n         LH    R4,VALUELEN\n         BCTR  R4,0\n         EX    R4,CLCVALUE        COMPARE VALUES.\n         BE    GOTFLG\nNXTFLVAL DS    0H\n         LA    R11,VTABLEN(,R11)  BUMP TO NEXT ENTRY.\n         B     FLGLOOP\nGOTFLG   DS    0H\n         MVC   VALUEFLG,VTABVAL   GOT HIT: MOVE IN FLAG VALUE.\n         BR    R14\nDOABEND  DS    0H                 THE ABEND= ROUTINE.\n         TM    PARM,GOTABEND      ALLOW ONLY ONE SPECIFICATION.\n         BO    BADPARM\n         MVC   ABEND,VALUEFLG\n         OI    PARM,GOTABEND      INDICATE WE HAVE A VALUE.\n         B     NXTPARM\nDOCOL    DS    0H                 THE COLUMN= ROUTINE.\n         TM    PARM,GOTCOL        ALLOW ONLY ONE SPECIFICATION.\n         BO    BADPARM\n         LH    R4,VALUELEN\n         BCTR  R4,0               MACHINE LENGTH.\n         EX    R4,PACKNUM         PACK SECONDS.\n         CVB   R5,DOUBLE          CONVERT TO BINARY.\n         CH    R5,=H'1'           TEST SECONDS\n         BL    BADPARM             FOR LIMITS.\n         CH    R5,=H'72'\n         BH    BADPARM\n         OI    PARM,GOTCOL        INDICATE WE HAVE A VALUE.\n         STH   R5,COLUMN           AND STORE.\n         B     NXTPARM\nPACKNUM  PACK  DOUBLE,VALUE(*-*)\nDOERRMSG DS    0H                 THE ERRMSG= ROUTINE.              L02\n         TM    PARM,GOTERRMS      ALLOW ONLY ONE SPECIFICATION.     L02\n         BO    BADPARM                                              L02\n         MVC   ERRMSG,VALUEFLG                                      L02\n         OI    PARM,GOTERRMS      INDICATE WE HAVE A VALUE.         L02\n         B     NXTPARM                                              L02\nDOJOB    DS    0H                 THE JOB= ROUTINE.\n         TM    PARM,GOTJOB        ALLOW ONLY ONE SPECIFICATION.\n         BO    BADPARM\n         MVC   JOBLEN,VALUELEN    MOVE VALUE.\n         MVC   JOB,VALUE\n         OI    PARM,GOTJOB        INDICATE WE HAVE A VALUE.\n         LH    R4,JOBLEN          CHECK FOR A MASK.\n         LA    R5,JOB-1(R4)\n         CLI   0(R5),C'*'\n         BNE   NOJOBMSK\n         BCTR  R4,0\n         STH   R4,JOBLEN          GOT MASK: INDICATE THUSLY.\n         OI    MASK,GOTJOB\nNOJOBMSK DS    0H\n         B     NXTPARM\nDOMSG    DS    0H                 THE MSG= ROUTINE.\n         TM    PARM,GOTMSG        ALLOW ONLY ONE SPECIFICATION.\n         BO    BADPARM\n         MVC   MSGLEN,VALUELEN    MOVE VALUE.\n         MVC   MSG,VALUE          MOVE VALUE.\n         OI    PARM,GOTMSG        INDICATE WE HAVE A VALUE.\n         B     NXTPARM\nDOREPLY  DS    0H                 THE REPLY= ROUTINE.\n         TM    PARM,GOTREPLY        ALLOW ONLY ONE SPECIFICATION.\n         BO    BADPARM\n         MVC   REPLYLEN,VALUELEN    MOVE VALUE.\n         MVC   REPLY,VALUE          MOVE VALUE.\n         OI    PARM,GOTREPLY      INDICATE WE HAVE A VALUE.\n         B     NXTPARM\nDOTIME   DS    0H                 THE TIME= ROUTINE.\n         TM    PARM,GOTTIME       ALLOW ONLY ONE SPECIFICATION.\n         BO    BADPARM\n         LH    R4,VALUELEN\n         BCTR  R4,0               MACHINE LENGTH.\n         EX    R4,PACKNUM         PACK SECONDS.\n         CVB   R5,DOUBLE          CONVERT TO BINARY.\n         CH    R5,=H'1'           TEST SECONDS\n         BL    BADPARM             FOR LIMITS.\n         CH    R5,=H'999'\n         BH    BADPARM\n         OI    PARM,GOTTIME       INDICATE WE HAVE A VALUE.\n         ST    R5,TIME             AND STORE.\n         B     NXTPARM\nDOWAIT   DS    0H                 THE WAIT= ROUTINE.\n         TM    PARM,GOTWAIT       ALLOW ONLY ONE SPECIFICATION.\n         BO    BADPARM\n         MVC   WAIT,VALUEFLG\n         OI    PARM,GOTWAIT       INDICATE WE HAVE A VALUE.\n         B     NXTPARM\nDOCHECK  DS    0H                 CONSISTENCY CHECKING.\n         TM    PARM,GOTMSG+GOTREPLY MSG AND REPLY ARE REQUIRED.\n         BNO   BADPARM\nENDPARM  DS    0H\n         MVC   TIMELIM,TIME       INIT ELAPSED TIME COUNTER.\n         DROP  R11\n********************************************************************\n*                                                                  *\n*        M A I N L I N E                                           *\n*                                                                  *\n********************************************************************\n* HERE WE SEARCH FOR THE WTOR MESSAGE TEXT. THE WQE'S ARE IN THE\n* CONSOLE ADDRESS SPACE PRIVATE MEMORY, SO WE MUST USE XMEM SERVICES.\nDOSCAN   DS    0H\n         L     R2,CVTPTR\n         L     R2,CVTCUCB-CVT(,R2) R2 = A(UCM).\n         USING UCM,R2\n         LH    R3,UCMCTID         CONSOLE ADDRESS SPACE\n         STH   R3,CONSASID        PUT AWAY\n         LR    R3,R2\n         SH    R3,=H'4'\n         L     R3,0(,R3)          R3 = A(UCM PREFIX).\n         USING UCMPRFX,R3\n         L     R4,UCMMCENT        R4 = A(MCON UCMENTRY).\n         USING UCMLIST,R4\n         SLR   R5,R5\n         IC    R5,UCMID           R5 = MCON ID.\n         STH   R5,MCONSID         SAVE.\n         DROP  R3,R4\n         MODESET MODE=SUP,KEY=ZERO\n         ESAR  R3 ,\n         STH   R3,SASID           SAVE CURRENT SECONDARY ASID.\n         AXSET AX==H'1'\n         LA    R7,30              LOOP VALUE.\n         L     R3,UCMRPYQ         R3 = A(1ST ORE).\n         USING OREF,R3\nORELOOP  DS    0H\n         LA    R3,0(,R3)\n         LTR   R3,R3              IF R3 = 0, EXHAUSTED CHAIN.\n         BZ    NOREPLY\n         L     R4,ORERWQE         R4 = A(ASSOCIATED WQE).\n         LH    R5,CONSASID        GET 'CONSOLE' ASID\n         SSAR  R5 ,               SET CONSOLE AS SECONDARY\n         LA    R5,L'MYWQE\n         SR    R15,R15            'FROM' KEY\n         MVCP  MYWQE(R5),0(R4),R15\n         LH    R5,SASID           RESTORE PREVIOUS SECONDARY -\n         SSAR  R5 ,               SHOULD BE SAME AS PRIMARY\n         LA    R4,MYWQE           R4 = A(COPY OF WQE).\n         USING WQE,R4\n         LH    R6,COLUMN          SET COLUMN= POINTER FOR COMPARE.\n         BCTR  R6,0\n         LA    R5,WQETXT+4(R6)\n         AH    R6,MSGLEN\n         C     R6,WQENBR\n         BH    NEXTORE            MAKE SURE LENGTHS ARE FEASABLE.\n         LH    R6,MSGLEN\n         BCTR  R6,0\n         EX    R6,CLCMSG          DO COMPARE.\n         BNE   NEXTORE\n         TM    PARM,GOTJOB        CHECK FOR MATCHING JOB= .\n         BZ    DOREP\n         MVC   WTORJOB,=CL8' '\n         LOCASCB ASID=OREASID     GET ASCB OF WTOR ISSUER.\n         LTR   R1,R1\n         USING ASCB,R1\n         BNP   BADASID\n         L     R5,ASCBJBNI        GET JOBNAME OF WTOR ISSUER.\n         LTR   R5,R5\n         BNZ   *+8\n         L     R5,ASCBJBNS\n         MVC   WTORJOB,0(R5)\n         DROP  R1\nBADASID  DS    0H\n         LA    R5,L'WTORJOB-1     DEFAULT LENGTH.\n         TM    MASK,GOTJOB        IF MASK, DO COMPARE AS IS.\n         BZ    *+10\n         LH    R5,JOBLEN          ELSE USE JOB= LENGTH.\n         BCTR  R5,0\n         EX    R5,CLCJOB          DO COMPARE.\n         BE    DOREP              OKEYDOKE, EXIT.\nNEXTORE  DS    0H\n         L     R3,ORELKP          NEXT ORE.\n         BCT   R7,ORELOOP         LOOP.\nNOREPLY  DS    0H\n         AXSET AX==H'0'           RESET AUTHORIZATION.\n         MODESET KEY=NZERO,MODE=PROB\n         CLI   WAIT,YES           NO HIT, DO WE WAIT.\n         BNE   BADREPLY           NOPE, EXIT.\n         STIMER WAIT,BINTVL==F'1000' WAIT FOR 5 SECONDS.\n         L     R2,TIMELIM         SUBTRACT 5 SECONDS.\n         SH    R2,=H'10'\n         BNP   BADREPLY           CHECK WAIT LIMIT.\n         ST    R2,TIMELIM\n         B     DOSCAN\nCLCMSG   CLC   MSG(*-*),0(R5)\nCLCJOB   CLC   JOB(*-*),WTORJOB\n********************************************************************\n*                                                                  *\n*        I S S U E   R E P L Y   C O M M A N D                     *\n*                                                                  *\n********************************************************************\nDOREP    DS    0H\n         AXSET AX==H'0'           RESET AUTHORIZATION.\n         MVC   REPLYID,OREID      FORMAT \"99\" OF R 99,\n         MODESET KEY=NZERO,MODE=PROB\n         MVI   MGCRLGTH,L'REPLY   MOVE IN REPLY TEXT.\n         MVC   COMMAND,=CL2'R '\n         MVI   REPLYID+2,C','\n         MODESET KEY=ZERO,MODE=SUP\n         LH    R0,MCONSID         R0 = MCONS ID.\n         MGCR  MGCRPL             SVC 34.\n         LR    R5,R15             SAVE RC.\n         MODESET KEY=NZERO,MODE=PROB\n         LTR   R5,R5              CHECK SVC 34 RC.\n         BNZ   BADSVC34\n         B     GOODREP\n         DROP  R2,R3,R4\n********************************************************************\n*                                                                  *\n*        R E T U R N                                               *\n*                                                                  *\n********************************************************************\nRETURN   DS    0H\n         L     R2,RC                  R2 = RC.\n         LR    R1,R13              PREPARE\n         L     R13,4(,R13)         FOR FREEMAIN.\n         FREEMAIN RU,LV=DYNLEN,A=(1)\n         LR    R15,R2              AND RETURN\n         RETURN (14,12),RC=(15)      WITH R15 = RC.\nDIE      DS    0H\n         ABEND 123\n********************************************************************\n*                                                                  *\n*        M E S S A G E S                                           *\n*                                                                  *\n********************************************************************\nBADPARM  DS    0H                 FORMAT THE BAD PARM MESSAGE.\n         MVC   RC,=F'12'\n         LA    R2,MSGPARM\n         LA    R3,L'MSGPARM\n         LA    R4,BADEND\n         B     DOMESSAG\nBADREPLY DS    0H                 FORMAT THE BAD REPLY MESSAGE.\n         MVC   RC,=F'4'\n         CLI   ERRMSG,YES                                           L02\n         BNE   BADEND                                               L02\n         MVI   MSGAREA,C' '\n         MVC   MSGAREA+1(L'MSGAREA-1),MSGAREA\n         MVC   MSGAREA(L'MSGREPLY),MSGREPLY\n         MVC   MSGJOB,OURJOB      DEFAULT TO TARGET JOBNAME.\n         LA    R2,MSGAREA\n         LA    R3,L'MSGREPLY\n         LA    R4,BADEND\n*        OI    WTOFLG,NONROLL    INDICATE NONROLL.\n         B     DOMESSAG\nBADSVC34 DS    0H                 FORMAT THE BAD SVC34 MESSAGE.\n         MVC   RC,=F'12'\n         LA    R2,MSGSVC34\n         LA    R3,L'MSGSVC34\n         LA    R4,BADEND\n         B     DOMESSAG\nGOODREP  DS    0H                 ISSUE THE GOOD REPLY MESSAGE.\n         MVI   MSGAREA,C' '\n         MVC   MSGAREA+1(L'MSGAREA-1),MSGAREA\n         MVC   MSGAREA(L'MSGROK),MSGROK\n         MVC   MSGJOB,OURJOB\n         MVC   MSGCOMM,COMMAND\n         LA    R2,MSGAREA\n         LA    R3,L'MSGAREA\n         LA    R4,RETURN\n         OI    WTOFLG,NOTPUT\n         B     DOMESSAG\nDOMESSAG DS    0H\n         CH    R3,=H'80'          MAX LENGTH IS 80 BYTES.\n         BL    *+8\n         LA    R3,80\n         TM    WTOFLG,NOTPUT\n         BO    DOWTO\n         CLI   TSO,YES            ISSUE TPUT FOR TSO.\n         BE    DOTPUT\nDOWTO    DS    0H\n         MVC   WTO(WTOLEN),XWTO     ELSE DO WTO.\n         BCTR  R3,0\n         EX    R3,MVCWTO\n         TM    WTOFLG,NONROLL\n         BZ    *+8\n         MVI   WTODESC,X'40'\n         WTO   MF=(E,WTO)\n         B     ENDMSG\nDOTPUT   DS    0H\n         MVC   TPUT(TPUTLEN),XTPUT\n         TPUT  (R2),(R3),MF=(E,TPUT)\n         NI    WTOFLG,255-(NONROLL+NOTPUT)\n         B     ENDMSG\nENDMSG   DS    0H\n         BR    R4\nMVCWTO   MVC   WTOMSG(*-*),0(R2)\nBADEND   DS    0H                 BADEND - DO WE ABEND OR CC=4?     L02\n         CLI   ABEND,NO\n         BE    RETURN\n         CLI   ERRMSG,YES                                           L02\n         BNE   DIE                                                  L02\n         LA    R2,MSGABEND\n         LA    R3,L'MSGABEND\n         LA    R4,DIE\n         B     DOMESSAG\n********************************************************************\n*                                                                  *\n*        S T A T I C   A R E A S.                                  *\n*                                                                  *\n********************************************************************\nXTPUT    TPUT  0,0,EDIT,WAIT,,BREAKIN,MF=L\nTPUTLEN  EQU   *-XTPUT\nXWTO     WTO   '                                                       X\n                                            ',ROUTCDE=11,MF=L\nWTOLEN   EQU   *-XWTO\nMSGPARM  DC    C'REP010E  THE PARM FIELD IS BAD. PGM IS TERMINATING.'\nMSGREPLY DC    C'REP020E          : WTOR NOT FOUND. NO REPLY ISSUED.'\nMSGSVC34 DC    C'REP030E  BAD RC FROM SVC34. PGM IS TERMINATING.'\nMSGABEND DC    C'REP040I  A U123 ABEND FOLLOWS.'\nMSGROK   DC    C'REP050I         :'\n         LTORG *\nSRCLEVEL DC    C'                                        '\nKWORDTAB CSECT ,                  PARAMETER KEYWORD TABLE.\n         DC    CL8'A=      ',AL1(2,FLG,0,0),A(DOABEND)\n         DC    CL8'ABEND=  ',AL1(6,FLG,0,0),A(DOABEND)\n         DC    CL8'C=      ',AL1(2,NUM,1,2),A(DOCOL)\n         DC    CL8'COL=    ',AL1(4,NUM,1,2),A(DOCOL)\n         DC    CL8'COLUMN= ',AL1(7,NUM,1,2),A(DOCOL)\n         DC    CL8'E=      ',AL1(2,FLG,0,0),A(DOERRMSG)             L02\n         DC    CL8'ERR=    ',AL1(4,FLG,0,0),A(DOERRMSG)             L02\n         DC    CL8'ERRMSG= ',AL1(7,FLG,0,0),A(DOERRMSG)             L02\n         DC    CL8'J=      ',AL1(2,CHR,1,8),A(DOJOB)\n         DC    CL8'JOB=    ',AL1(4,CHR,1,8),A(DOJOB)\n         DC    CL8'M=      ',AL1(2,CHR,1,72),A(DOMSG)\n         DC    CL8'MSG=    ',AL1(4,CHR,1,72),A(DOMSG)\n         DC    CL8'R=      ',AL1(2,CHR,1,72),A(DOREPLY)\n         DC    CL8'REP=    ',AL1(4,CHR,1,72),A(DOREPLY)\n         DC    CL8'REPLY=  ',AL1(6,CHR,1,72),A(DOREPLY)\n         DC    CL8'T=      ',AL1(2,NUM,1,3),A(DOTIME)\n         DC    CL8'TIME=   ',AL1(5,NUM,1,3),A(DOTIME)\n         DC    CL8'W=      ',AL1(2,FLG,0,0),A(DOWAIT)\n         DC    CL8'WAIT=   ',AL1(5,FLG,0,0),A(DOWAIT)\n         DC    X'FF'\nKTABLE   DSECT\nKTABKEY  DS    CL8\nKTABKEYL DS    AL1\nKTABTYPE DS    AL1\nKEY      EQU   X'01'\nCHR      EQU   X'02'\nNUM      EQU   X'04'\nFLG      EQU   X'08'\nKTABMINW DS    AL1\nKTABMAXW DS    AL1\nKTABROUT DS    A\n         ORG   KTABROUT\nKTABVTAB DS    A\nKTABLEN  EQU   *-KTABLE\nFLGTAB   CSECT ,                  FLAG TABLE.\n         DC    CL8'YES     ',AL1(3,YES)\n         DC    CL8'Y       ',AL1(1,YES)\n         DC    CL8'NO      ',AL1(2,NO)\n         DC    CL8'N       ',AL1(1,NO)\n         DC    X'FF'\nVTABLE   DSECT\nVTABKEY  DS    CL8\nVTABKEYL DS    AL1\nVTABVAL  DS    AL1\nVTABLEN  EQU   *-VTABLE\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   A R E A S.                                *\n*                                                                  *\n********************************************************************\nDYNAMIC  DSECT\nSAVE     DS    18F                     SAVE AREA.\nDOUBLE   DS    D                       SAVE AREA.\nRC       DS    F                       RETURN CODE.\nWTO      DS    0F,CL(WTOLEN)\nWTODESC  EQU   *-4,2\nWTOMSG   EQU   WTO+4,80\nMSGAREA  DS    CL80\nMSGJOB   EQU   MSGAREA+9,8\nMSGCOMM  EQU   MSGAREA+19,61\nTPUT     DS    0F,CL(TPUTLEN)\nMCONSID  DS    H\nCONSASID DS    H\nSASID    DS    H\nWTOFLG   DS    X\nNONROLL  EQU   X'80'\nNOTPUT   EQU   X'40'\nTSO      DS    X\nNO       EQU   1\nYES      EQU   2\nOURJOB   DS    CL8\nMYWQE    DS    CL(WQESIZE)\nWTORJOB  DS    CL8\nVALUELEN DS    H\nVALUE    DS    CL100\nCOLUMN   DS    H\nTIME     DS    F\nTIMELIM  DS    F\nMSGLEN   DS    H\nMSG      DS    CL72\nREPLYLEN DS    H\n         IEZMGCR DSECT=NO\n         ORG   MGCRTEXT\nCOMMAND  DS    CL2\nREPLYID  DS    CL2,C\nREPLY    DS    CL72\n         ORG\nJOBLEN   DS    H\nJOB      DS    CL8\nVALUEFLG DS    X\nPARM     DS    X\nGOTABEND EQU   X'01'\nGOTCOL   EQU   X'02'\nGOTJOB   EQU   X'04'\nGOTMSG   EQU   X'08'\nGOTREPLY EQU   X'10'\nGOTTIME  EQU   X'20'\nGOTWAIT  EQU   X'40'\nGOTERRMS EQU   X'80'                                                L02\nMASK     DS    X\nWAIT     DS    X\nABEND    DS    X\nERRMSG   DS    X                                                    L02\nDYNLEN   EQU   *-DYNAMIC               LENGTH.\n         PRINT OFF\nR0       EQU   00\nR1       EQU   01\nR2       EQU   02\nR3       EQU   03\nR4       EQU   04\nR5       EQU   05\nR6       EQU   06\nR7       EQU   07\nR8       EQU   08\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12                 PROGRAM BASE.\nR13      EQU   13                 A(SAVE AREA).\nR14      EQU   14\nR15      EQU   15\n         PRINT ON\n         IHAPSA ,                 PSA\n         CVT   DSECT=YES\n         IHAASCB ,                ASCB\nUCM      DSECT ,\n         IEECUCM ,\n         IHAORE ,\n         IHAWQE ,\n         END   &CSECT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SD": {"ttr": 8708, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x04B\\x04B\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 1090, "newlines": 1090, "modlines": 0, "user": "FILE369"}, "text": "*        G.E. VERSION IS VANILLA OMB WITH THESE CHANGES:\n*              1.  LIMIT GETMAIN TO SOMEWHAT LESS THAN REGION SIZE.\n*                  CHANGE FOR MVS DONE AT LCS, 1977 DICK SZIEDE.\n*              2.  FIX THE DAIR FREE (18) DAPL.  THIS WAS A BUG THAT\n*                  I GOT AWAY WITH IN MVT DAYS. G.E. 1983 DICK SZIEDE.\n*\n*        SEE TED SCHERTZER (PEPCO), FOR A VERSION WITH VOL AND UNIT\n*              PARAMETERS.\n*\nSHOWDIR  CSECT\n         REGS\n         SAVE  (14,12),,SHOWDIR_DICK_SZIEDE_CSC_1975\n         BALR  R12,0                  BASE ADDR\n         USING *,R12\n*\n         LR    R11,R13                SAVE BACKWARD POINTER\n         LR    R10,R1      PRESERVE CPPL POINTER\n*\n         GETMAIN VU,LA=GMREQ,A=GMANS  GET HALF THE WORLD\n         L     R13,GMANS                   AND MAKIT ADDRESSABLE\n         USING SAVEAREA,R13\n*\n         LA    R2,SAVEAREA            ADDR OF WKA IN R1\n         L     R3,GMANS+4             LENGTH OF WKA IN R1+1\n         LR    R4,R2                  SOURCE ADDR HAS NO MEANING\n         SR    R5,R5                  ZERO PADDING CHAR AND LENGTH\n         MVCL  R2,R4                      IN R2+1\n*\n*\n         ST    R11,SAVEAREA+4        BSCK CHAIN\n         ST    R13,8(R11)          FOREWARD CHAIN\n*\n        EJECT\n         USING CPPL,R10               CPPL ADDR WAS SAVED IN R10\n         MVC   IOPLUPT(4),CPPLUPT      PREPARE IOPL\n         MVC   IOPLECT(4),CPPLECT\n         LA    R2,ECB\n         ST    R2,IOPLECB\n         DROP  R10                    WE NO LONGER NEED THE CPPL\n*\n*\n         BAL   R3,PARSINPT                 PARSE INPUT BUFFER\n         BAL   R3,DSNFMT                   FORMAT DSNAME FOR DAIR\n         BAL   R3,PREALLOC                 IS DSNAME ALLOCATED?\n         BAL   R3,ALLOC                    ALLOCATE INPUT\n         BAL   R3,OPENER               OPEN DCB FOR INPUT\n*\n*\n         BAL   R3,ALIAS                SPECIAL FORMAT FOR ALIASES?\n         BAL   R3,PSTRING              SET UP MASKS FOR COMPARE\n         BAL   R3,LINESIZE             LINE SIZE SPECIFIED?\n         BAL   R3,PRINT                DO WE WANT DISK OP?\n         BAL   R3,PRNTALOC             ALLOCATE IF YES.\n         BAL   R3,PUTBL                 BLANK OUTPUT AREA\n*\n         LA    R5,CHANTOP\n         LR    R7,R5                    SET LIMIT TO NUMBER OF\n         A     R7,GMANS+4                    ENTRIES PER LINE\n         LA    R6,16                    LENGTH OF AN ENTRY\n*\n         LA    R10,DIRDATA+256          FORCE GETTER TO GET A DIRECTORY\n         LR    R9,R10                       BLOCK ON FIRST ACCESS\n*\n         OI    HITCOUNT+(L'HITCOUNT-1),X'0C'      MAKE A PACKED ZERO\n         OI    LINECNT+(L'LINECNT-1),X'0C'          FOR MSG & SEQ\n*\nMAINLOOP BAL   R3,GETTER                GET A MEMBER ENTRY\n         BAL   R3,CHAIN                 CHECK FOR ALIAS\n         B     MAINLOOP                 THE EXITS FROM THIS LOOP ARE\n*                                           END-OF-FILE (LOGICAL OR\n*                                            PHYSICAL) ON INPUT.\nEODAD    LR    R7,R5              SET UP THE HIGH-WATER MARK AS\n         LA    R5,CHANTOP             LIMIT FOR THE RUN-OUT\n         CR    R5,R7              CHECK FOR NO OUTPUT\n         BE    EODEDIT\n         LA    R6,16              SET INCREMENT\n         SR    R7,R6              BACK OFF FOR FLYING START\n*\n         LA    R9,PUTLINE-10      OUTPUTLINE LIMIT\n         AH    R9,LINELENG\n         LA    R8,10              OUTLINE INCREMENT\n         BAL   R3,PUTBL\n*\nPRNTLOOP BAL   R3,FORMAT          FORMAT OUTPUT FOR EACH MEMBER,\n         BXLE  R5,R6,PRNTLOOP        AND PRINT ON A FULL LINE.\n         BAL   R3,FLUSHER         PRINT LAST LINE\n*\nEODEDIT  ED    FINAL,HITCOUNT        MAKE HIT COUNT VISIBLE\n         BNZ   EODPUT                RC = 4 IF HITCOUNT=0\n         OI    RCDE+3,X'04'\n*\nEODPUT   MVC   PUTLINE(LFINAL),FINAL    MOVE TO OUT AREA\n         LA    R0,LFINAL            LENGTH FOR TPUT\n         BAL   R3,FORTPUTT              AND WRITE FINAL LINE\n*\n*\nQUIT     CLOSE ,MF=(E,CLOSEL)    CLOSE DCB OR DCBS\n*\nFREE     L     R15,DONTFREE              RETRIEVE SWITCH\n         B     FREETAB(R15)\nFREETAB  B     FREEMAIN                  FREE IT\n*\n         LA    R1,XDAPL                ADDR OF 'FREE' PARAMETER BLOCK\n         USING DAPL,R1\n         LA    R9,DA18AREA             ADDR OF DAIR WORKAREA\n         ST    R9,DAPLDAPB             ADDRESSABLE FOR \"FREE\"\n         DROP  R1\n         LINK  EP=IKJEFD00             FREE DATA SET\n*\n         LTR   R15,R15                 WHAT DOES DAIR SAY?\n         BZ    FREEMAIN                    IF NOTHING, WE PASS\n         BAL   R3,DAIRERR                  OTHERWISE, WE TALK IT OVER\n*\nFREEMAIN L     R15,RCDE             MAKE RC VISIBLE\n         BAL   R3,RESTOHEX\n         STCM  R5,B'0011',PUTLINE+3\n         MVC   PUTLINE(3),=C'RC='\n         LA    R5,5            LGTH FOR TPUT\n         BAL   R3,FORTPUT\n*\n         L     R2,SAVEAREA+4       RETRIVE BACKWARD CHAIN\n         L     R3,RCDE             RETRIVE MAX RC\n         FREEMAIN V,A=GMANS        RETURN WHAT WE GOT\n*\n         LR    R13,R2                   OLD SAVEAREA ADDRESSABLE\n         LR    R15,R3                   PRESERVE RC\n         RETURN (14,12),,RC=(15)\n         EJECT\n*\n*            * ERROR ROUTINES *\n*\nPARSERR  TPUT  PARSMSG,L'PARSMSG\n         OI    RCDE+3,X'10'                 NO OUTPUT\n         B     FREEMAIN\n*\n*\n*\nNOTPART  TPUT  PARTMSG,L'PARTMSG\n         OI    RCDE+3,X'10'                 NO OUTPUT\n         B     FREE\n*\n*\nOPENERR  TPUT  OPENMSG,L'OPENMSG\n         OI    RCDE+3,X'10'                 NO OUTPUT\n         B     FREE\n*\n*\nPRDAIRER ST    R3,PRSTR3\n         BAL   R3,DAIRERR\n         L     R3,PRSTR3\n         NI    PRINTSW,X'00'            IN THIS CASE, TURN OFF PRINT,\n         BR    R3                            BUT GIVE WHAT WE CAN.\n*\n*\nPROPNERR TPUT  PROPNMSG,L'PROPNMSG\n         NI    PRINTSW,X'00'\n         OI    RCDE+3,X'80'             NOT QUITE RIGHT OUTPUT\n         BR    R3\n         EJECT\n*\n*              * SET UP MASKS FOR MEMBER NAME COMPARE  *\n*\n*\n         USING IKJPARMD,R10\nPSTRING  TM    PARPFXD+6,B'10000000'    IS THE STRING PRESENT?\n         BCR   14,R3                       NO - TAKE DEFAULT\n         INITL PSAND,X'FF'             THE DEFAULT IS TO COMPARE ON ALL\n*\n*\n         L     R6,PARPFXD              POINTER TO STRING\n         LH    R5,PARPFXD+4            LENGTH OF STRING\n         CH    R5,=H'8'                VALIDATE STRING LENGTH, AND\n         BL    PSMASK                      TRUNCATE TO 8.\n         LA    R5,8\n*\nPSMASK   MVC   PSXC(8),=C'********'    DEFAULT TO ALL MASK CHARS\n         BCTR  R5,0                    DEC REGISTER FOR EXECUTE\n         EX    R5,PSORIN               MOVE INTO MASK, AND SHIFT TO\n*                                          UPPER CASE.\n*\n         SR    R4,R4                   CONSTANT ZERO\n         LA    R7,8                    LIMIT LOOP\n         LA    R8,C'*'                 COMPARANDS FOR MASK CHARS\n         SR    R15,R15                 IC REGISTER\n*\n         CLC   PSXC(3),PSALL0        SPECIAL CASE FOR COMPATIBILITY\n         BNE   PSLOOP                      WITH OPSDIR\n         XC    PSXC(8),PSXC\n         XC    PSAND,PSAND\n         BR    R3\n*\nPSLOOP   IC    R15,PSXC-1(R7)          GET CHARACTER\n         CR    R15,R8                  IS IT A MASK CHARACTER?\n         BNE   PSINCR                      IF SO, ZERO OUT\n*                                          THE CORRESPONDING POSITION\n         STC   R4,PSAND-1(R7)              IN THE AND & OR MASKS\n         STC   R4,PSXC-1(R7)\n         B     PSINCR\n*\nPSINCR   BCT   R7,PSLOOP               8 REPITITIONS\n         BR    R3                      AND GET OUT\n*\n*\nPSORIN   MVC   PSXC(0),0(R6)           MOVE INTO TEST POSITION\n         EJECT\n*\n*              *  DETERMINE OUTPUT LINE SIZE  *\n*\nLINESIZE LA    R15,70                  DEFAULT IS 7 ENTRIES/LINE\n         TM    PARLND+6,B'10000000'    IS LINE LENGTH SPECIFIED?\n         BNO   LINEQUIT                    NO - TAKE DEFAULT\n*\n         L     R4,PARLND               ADDRESS OF STRING\n         IC    R5,0(R4)               TAKE FIRST DIGIT OF STRING\n         LA    R4,15                   SET UP AN AND MASK\n         NR    R5,R4                   R5 SHOULD HAVE FOUR BITS LEFT\n         IC    R15,LINETAB(R5)         GET ACTUAL LINE LENGTH\n*\nLINEQUIT STH   R15,LINELENG\n         BR    R3\n         DROP  R10\n*\n*\n*               DECIDE UPON SPECIAL FORMAT FOR ALIASES\n*\n*\n         USING IKJPARMD,R10\nALIAS    ICM   R15,B'0011',PARALIAS   IF THE KEYWORD NUMBER IS ODD WE\n         BCR   8,R3                    WILL  SUPPRESS\n         SLL   R15,7                  THE SEARCH FOR EQUAL TTR\n         STC   R15,CHAND+1               AND THE PUTTING OF ALIAS\n         BR    R3                     NAMES IN PARENTHESIS\n         DROP  R10\n*\n         EJECT\n         USING CPPL,R10                    AND MAKE IT ADDRESSABLE\n         USING PPL,R8\nPARSINPT LA    R8,PPLAREA                MAKE PPL ADDRESSABLE\n         MVC   PPLUPT,CPPLUPT          SET UP IKJPARSE PARMS\n         MVC   PPLECT,CPPLECT\n         MVC   PPLCBUF,CPPLCBUF\n         LA    R9,ECB\n         ST    R9,PPLECB\n         MVC   PPLPCL(4),=A(PARMDSN)\n         LA    R9,ANS\n         ST    R9,PPLANS\n*\n*\n*\n         LA    R1,PPL                  MAKE PPL ADDRESSABLR\n         LINK  EP=IKJPARS              PARSE  THE INPUT BUFFER\n*\n         LTR   R15,R15                 CHECK FOR RETURN OTHER THAN ZERO\n         BNZ   PARSERR\n*\n         DROP  R10\n         ICM   R10,B'1111',PPLANS      TOP OF PDL CHAIN\n         BNP   PARSERR                 PARSE OF BUFFER UNSUCESSFUL\n         L     R10,0(R10)              PDL HEADER\n         BR    R3\n         DROP  R8\n         EJECT\n         USING IKJPARMD,R10\n*\nPREALLOC LA    R9,DA00AREA             MAKE DAIR WORK AREAS\n         USING DAPB00,R9\n*\n         LA    R1,XDAPL\n         USING DAPL,R1\n         ST    R9,DAPLDAPB                  POINT DAPL TO SRCH\n         DROP  R1\n         LINK  EP=IKJEFD00\n*\n         B     PRECONT(R15)                 CHECK FOR ERROR\nPRECONT  B     PRETM\n*\n         BAL   R3,DAIRERR                   ERROR DETECTED\n         B     FREEMAIN                     NO OUTPUT\n*\nPRETM    LA    R15,4                         4 MEANS FREE IT\n         TM    DA00FLG,B'00001010'          WAS IT ALLOCATED\n         BZ    PRETEND                         YES - DON'T FREE IT\n*\n         SR    R15,R15                       0 MEANS DON'T FREE\n         TM    DA00DSO,B'10'                 IS IT PARTITIONED?\n         BNO   NOTPART                            ERROR MSG IF NOT.\n*\nPRETEND  ST    R15,DONTFREE                  SAVE DON'T FREE SWITCH\n         BR    R3\n*\n         DROP  R9\n         DROP  R10\n         EJECT\n         USING IKJPARMD,R10\n*\nALLOC    LA    R8,DA08AREA             MAKE DAIR WORK AREAS\n         LA    R9,DA18AREA                 ADDRESSABLE\n         USING DAPB08,R8\n         USING DAPB18,R9\n*\nDAUNIT   MVI   DA08DDN,C' '\n         MVC   DA08DDN+1(23),DA08DDN BLANK UNIT AND SERIAL NUMBER\n         MVC   DA08MNM(16),DA08UNIT    BLANK MEMBER & PASSWORD\n*\n         OI    DA08DSP1,X'08'          DISP=(SHR,KEEP,KEEP)\n         OI    DA08DPS2,X'08'\n         OI    DA08DPS3,X'08'\n         OI    DA18DPS2,X'08'\n*\n         MVC   DA18MNM(10),DA08UNIT    BLANK MEMBER & SYSOUT CLASS\n*\n         LA    R1,XDAPL                POINTER FOR LINK\n         USING DAPL,R1\n         ST    R8,DAPLDAPB             ADDRESS OF DAIR WORK AREA IN\n*                                          DAIR PARAMETER BLOCK\n         DROP  R1\n         LINK  EP=IKJEFD00             CALL ALLOCATE\n*\n*\n         CH    R15,=H'8'               WE HAVE A SPECIAL MESSAGE\n         BNE   ALLOCONT                    FOR A DATA SET NOT IN THE\n         CH    R15,DA08CTRC                CATALOG.\n         BNE   ALLOCONT\n*\n         LH    R6,DSNBUF            GET LENGTH OF DSN\n         BCTR  R6,0                 AND DECREMENT FOR EXECUTE\n         EX    R6,DSNMOVE3          PUT NAME IN MESSAGE\n         LA    R6,MSGNOTCT+13(R6)    POINT PAST DSNAME\n         MVC   0(17,R6),=C'IS NOT CATALOGED.'\n*\n         TPUT  MSGNOTCT,L'MSGNOTCT\n         OI    RCDE+3,X'08'           NO OUTPUT RC\n         B     FREEMAIN\n*\nALLOCONT LTR   R15,R15              ARE WE ALLOCATED\n         BZ    ALLOCKPO                  YES - CHECK FOR PARTITIONED\n         BAL   R3,DAIRERR\n         B     FREEMAIN\n*\n*\nALLOCKPO LA    R7,DCB                  MAKE INPUT DCB ADDRESSABLE\n         USING IHADCB,R7\n         MVC   DCBDDNAM(8),DA08DDN     PUT DDNAME INTO DCB\n         MVC   DA18DDN(8),DA08DDN         AND FREE BLOCK\n*\n*            * CHECK FOR DSORG=PO, AND SET UP FOR OPEN\n         TM    DA08DSO,B'10'           IS IT PARTITIONED ?\n         BNO   NOTPART                     NO - DON'T REPORTIT\n*\n         BR    R3\n*\nDSNMOVE3 MVC   MSGNOTCT+10(0),DSNBUF+2    VARIABLE LENGTH MOVE\n*\n         DROP  R7\n         DROP  R8\n         DROP  R9\n         DROP  R10\n         EJECT\nOPENER   LA    R9,DCB                  MAKE INPUT DCB ADDRESSABLE\n         USING IHADCB,R9\n*\n         OPEN  (DCB,(INPUT))\n         TM    DCBOFLGS,B'10000'       ARE WE OPEN ?\n         BNO   OPENERR                     NOPE - TELL 'EM\n         DROP  R9\n         BR    R3\n*\n         EJECT\nGETTER   CR    R9,R10              ARE WE PAST LAST MEMBER ENTRY?\n         BL    GETINCR                 IF SO, GET A NEW DIRECTORY BLOCK\n*\nGETREAD  LA    R4,DIRDATA             GET THE OUTAREA IN A REG\n         READ  DECB1,SF,DCB,(R4),'S'  GET THE BLOCK\n         CHECK DECB1\n*\n         LA    R9,DIRDATA+2        POINTER TO CURRENT MEMBER\n         LA    R10,DIRDATA         SET UP LIMIT TO SEARCH FOR\n         AH    R10,DIRDATA              MEMBER NAMES\n         B     GETCOMPR\n*\nGETINCR  SR    R4,R4                GET NUMBER OF HALFWORDS OF\n         IC    R4,11(R9)               USER DATA,\n         LA    R8,31                   BUT LIMITED TO 5 BITS\n         NR    R4,R8\n         SLA   R4,1             CONVERT TO BYTES\n         LA    R9,12(R4,R9)       POINT TO NEXT MEMBER ENTRY\n*\n         CR    R9,R10             HAVE WE PASSED LAST MEMBER?\n         BNL   GETREAD                 YES - GET A NEW DIRECTORY BLOCK\n*\nGETCOMPR CLC   0(8,R9),=X'FFFFFFFFFFFFFFFF'  LAST ENTRY IN DIRECTORY?\n         BE    EODAD                   YES - QUIT\n*\n         MVC   PSARGU(8),0(R9)    MOVE MEMBER NAME TO WORK AREA\n         NC    PSARGU,PSAND            MASK OFF NON-COMPARE BYTES\n         XC    PSARGU,PSXC             DOES IT MATCH THE MASK?\n         BNZ   GETINCR                     NO - PASS IT BY\n*\n         AP    HITCOUNT,=P'1'               COUNT THE MEMBER\n         BR    R3\n*\n         EJECT\nCHAIN    MVC   0(12,R5),0(R9)        PUT MEMBER NAME IN TABLE\n         ST    R3,CHAINR3            SAVE FOR SUBROUTINE CALLS\n         ST    R5,CHAINR5            SAVE FOR ALIAS CHASING\nCHAND    NI    11(R5),X'80'          TURN OFF ALL INDICATORS BUT ALIAS\n         TM    CHAND+1,X'80'          IF NOALIAS WAS SPECIFIED, WE\n         BZ    CHANOGOT                SKIP THE SEARCH FOR EQUAL TTR\n*\n*\n         LA    R2,CHANTOP            START SEARCH FOR EQUAL TTR\n         L     R15,8(R9)\n         SRL   R15,8                 SHIFT THE N OFFA TTRN\n         BAL   R3,CHANSEEK\n         LTR   R2,R2                 WAS AN EQUAL TTR FOUND?\n         BZ    CHANOGOT                  NO - WHO CARES ?\n*\n         TM    11(R9),X'80'          IS THE CURRENT GUY AN ALIAS ?\n         BNO   CHASTKIT                  IF SO, WE'LL RUN THE CHAIN OF\n*                                        ALIASES, AND PUT THE NEW KID\n         BAL   R3,CHALIAS                AT THE TAIL.\n         OI    11(R5),X'01'              IF NOT, WE'LL PUT THE NEW ONE\n         ST    R5,12(R2)                 AT THE HEAD OF THE CHAIN.\n         B     CHANOGOT\n*\nCHASTKIT ST    R2,12(R5)             POINT TO FORMER CHAIN HEAD\n         OI    11(R2),X'01'          INDICATE THAT FORMER HEAD NOW\n*                                    HAS A PREDECESSOR\n*\nCHANOGOT BXH   R5,R6,CHNOCORE       INCREMENT & CHECK FOR OUT OF\n         L     R3,CHAINR3               STORAGE<H\n         BR    R3                   RETURN TO CALLER\n*\n*\nCHANSEEK CR    R2,R5                R2=0 MEANS THIS IS A UNIQUE TTR\n         BNL   CHANR0\n*\nCHANSEER LR    R4,R6                PUT INCREMENT IN R4\n         L     R14,8(R2)            TTRN FROM TABLE\n         SRL   R14,8                DROP N\n         CR    R14,R15\n         BE    CHANEQ               FOUND EQUAL TTR\n*\n         AR    R2,R4                R2=0 MEANS THIS IS A UNIQUE TTR\n         B     CHANSEEK\n*\n*\nCHANR0   SR    R2,R2\nCHANEQ   BR    R3\n*\nCHALIAS  ICM   R4,B'1111',12(R2)  LOAD AND TEST POINTER TO NEXT ALIAS\n         BZ    CHGOTIT\n         LR    R2,R4              FOLLOW THE ALIAS CHAIN 'TILL\n         B     CHALIAS                IT ENDS\n*\nCHGOTIT  BR    R3\n*\n*\nCHNOCORE TPUT  MSGNOCOR,L'MSGNOCOR\n         OI    RCDE+3,X'08'       BAT OUTPUT RC\n         B     EODAD\n         EJECT\nFORMAT   TM    11(R5),X'01'         DOES THIS ENTRY HAVE A\n         BO    FORMRET                   PREDECESSOR?\n*                                        YES - SKIP IT\n         ST    R3,FORMR3            SAVE OUR RETURN ADDR\n         ST    R5,FORMR5            SAVE OUR INPUT PTR\n*\n         TM    11(R5),X'80'         ARE WE AN ALIAS, HMMMM?\n         BNO   FORMCHAI                   IF NOT WE'RE AN ORPHAN\n*\n         MVC   1(8,R10),=C'*ORPHAN*'      SO MARK IT AS SUCH\n         BAL   R3,FORMINCR\n*\nFORMCHAI BAL   R3,FORMSTIK             PUT THIS GUY IN OUTPUT LINE\n         ICM   R5,B'1111',12(R5)      GET NEXT ALIAS\n         BNZ   FORMCHAI              AND CHAIN TO THE END\n*\n*\nFORMFLUS L     R3,FORMR3              RETRIEVE RETURN ADDR\n         L     R5,FORMR5              AND ORIGIONAL MEMBER\n         B     FORMRET\n*\n*\nFORMSTIK MVC   1(8,R10),0(R5)         PUT MEMBER NAME IN OUTPUT LINE\n         TM    11(R5),X'80'        IF WE ARE AN ALIAS, WE WILL\n         BNO   FORMINCR             PRINT IN PARENTHISIS\n         MVI   0(R10),C'('\n         LA    R15,8(R10)            WE'LL SCAN RIGHT TO LEFT TO PLACE\nFORMSCAN CLI   0(R15),C' '                  A RIGHT PARENTHESIS AFTER\n         BNE   FORMPARN                     THE LAST CHAR\n         BCT   R15,FORMSCAN\nFORMPARN MVI   1(R15),C')'\nFORMINCR BXLE  R10,R8,FORMSTR         INCREMENT OUTPUT POINTER AND\n*                                         CHECK LINE LENGTH\nFORMWRR  IC    R15,PRINTSW            SNAG CONTROL FOR DISK O/P\n         EX    R15,PUTBR\nFORTPUT  LH    R0,LINELENG            LENGTH FOR TPUT\nFORTPUTT TPUT  PUTLINE,(R0)\n*\nPUTBL    INITL PUTLINE,C' '            BLANK OUTPUT LINE\n         LA    R10,PUTLINE                  AND RESET POINTER\n         LA    R15,4                   R15=4 MEANS WE ARE WORKING\n         BR    R3                         ON A NEW LINE.\n*\nFORMSTR  SR    R15,R15                 R15=0 MEANS CONTINUE PRESENT\n         BR    R3                          LINE\n*\nFORMRET   BR    R3\n*\nFLUSHER  LA    R6,PUTLINE              WRITE THE LAST BUFFER,\n         SR    R10,R6                       IF NECESSARY\n         BCR   13,R3\n         B     FORMWRR\n*\n*\n*\n*\nPUTBR    BC    0,*+4                SNAG THE TPUT, AND MAKE IT A\n         AP    LINECNT,=P'10'           PUT. THEN INCREMENT EDIT LINE\n         UNPK  PUTLINE+73(8),LINECNT    COUNT AND PUT IN OUTPUT LINE.\n         OI    PUTLINE+80,X'F0'     MAKE POSITIVE\n         PUT   PRDCB,PUTLINE+1\n         B     PUTBL\n        EJECT\nPRINT    LA    R8,DA04AREA              MAKE DAIR WKA ADDRESSABLE\n         USING DAPB04,R8\n         USING IKJPARMD,R10\n*\n         TM    PARPND+6,X'80'           IS PRINT PARAMETER PRESENT?\n         BO    PRSWITST                     YES -SET SWITCH\n         OI    CLOSEL,X'80'                  NO  - TRUNCATE CLOSE LIST\n         BR    R3                            AND RETURN\n*\nPRSWITST OI    PRINTSW,X'F0'            SET SWITCH FOR DISK OUTPUT\n         MVI   DA04CD+1,X'04'           SET JUST LOOKIN' CODE\n         L     R6,PARPND                POINTER TO DSNAME\n         LH    R5,PARPND+4              LENGTH OF DSNAME\n         STH   R5,PRPNDSN              LENGTH IF QUOTED\n         BCTR  R5,0                     DECREMENT FOR INCREMENT\n         EX    R5,PRDSNMV               MOVE TO DAIR AREA\n*\n         TM    PARPND+6,B'01000000'     IS DSN IN QUOTES?\n         BO    PRUNIT                       YES - SKIP REST.\n*\n         OI    DA04CTL,B'100000'         USER ID NEEDED\n         SR    R14,R14         SCAN TABLE OF VALID QUALIFIERS\n         LA    R15,PRQALND       FOR DISK DSNAME\n         LA    R7,PRQALTB            TOP OF TABLE\n*\nPRQALOOP IC    R14,0(R7)      LENGTH OF TABLE ENTRY\n         LA    R6,PRPNDSN+2(R5) POINT AT LAST 2 CHARS OF DSN\n         SR    R6,R14           BACK UP BY LENGTH OF TABLE ENTRY\n         EX    R14,PRQACMP      COMPARE TO TABLE ENTRY, AND QUIT\n         BE    PRUNIT              IF A MATCH IS FOUND\n*\n         LA    R14,2(R14)        INCREMENT TO ACTUAL LENGTH\n         BXLE  R7,R14,PRQALOOP      SEARCH CONTINUES\n*\n         LA     R6,PRPNDSN+1(R5)    POINT PAST ENTERED NAME\n         MVC   2(5,R6),=C'.DATA'\n         LA    R5,6(R5)                         AND INCREMENT ACTUAL\nPRASMD   STH   R5,PRPNDSN                       LENGTH\n*\n*\nPRUNIT   LA    R5,PRPNDSN              ADDR OF DAIR DSN\n         ST    R5,DA04PDSN\n*\n         LA    R6,XDAPL                   WE EXPECT THE DAPL TO BE\n         USING DAPL,R6                         ALREADY FORMATTED\n         ST    R8,DAPLDAPB\n         DROP  R6\n*\n         LR    R1,R6                       DAPL ADDR INTO R1\n         LINK  EP=IKJEFD00                 ALLOCATE OR ELSE\n*\n         LA    R9,DA08AREA           MAKE ALLOCATE WKA ADDRESSABLE\n         USING DAPB08,R9\n*\n         MVC   DA08DSP1(3),=X'040204'  DEFAULT DISP=(NEW,CATLG,DELETE)\n         OI    DA08CTL,X'10'           DEFAULT SPACE IS RLSE\n         MVC    DA08CTL(1),DA04CTL       CARRY ACROSS USERID\n         MVC   DA08PDSN(4),DA04PDSN       CARRY ACROSS DSNAME\n*\n         B     *+4(R15)        INDEXED BY RC FROM DAIR\n         B     PROLD       RC=0 MEANS IT EXISTS\n         B     PRDAIRER    RC=4 MEANS OUR ERROR\n         CLC   DA04CTRC(2),=X'0008'  RC=8 AND CATALOG8 MEANS DISP=NEW\n         BE    PRRET3\n         B     PRDAIRER\n*\nPROLD    MVC   DA08DSP1(3),=X'010808'      DISP=(OLD,KEEP,KEEP) AND\n         NI    DA08CTL,B'00100000'           ONLY ALLOW USERID\n         TM    DA04FLG,X'02'               IS DSN IN DSE?          JFS\n         BZ    PRRET3                            NO  - OK          JFS\n         TM    DA04DSO,X'40'                 IS IT DSORG=PS\n         BO    PRRET3                            YES - OK\n         OI    RCDE+3,X'08'               WE'RE NOT PLEASED\n*\n         TPUT  MSGNOTPS,L'MSGNOTPS         TELL USER\n         MVI   PRINTSW,X'00'               AND TURN OFF PRINT\n*\n*\nPRRET3   BR    R3\n*\nPRQACMP  CLC   0(0,R6),1(R7)   VARIABLE LENGTH COMPARE FOR\n*                                    QUALIFIER\n         DROP  R8,R9,R10\n         EJECT\nPRNTALOC IC    R1,PRINTSW                  ARE WE NEEDED?\n         EX    R1,PRNTSNAG                     IF NOT, GO BACK\n         BR    R3\n*\nPRNTSNAG BC    0,*+4            CONTINUE IF NEEDED\n         LA    R8,DA08AREA      MAKE WORK AREAS ADDRESSABLE\n         USING DAPB08,R8\n*\n         MVI   DA08DDN,C' '               BLANK UNIT,SERIAL#, MEMBER\n         MVC   DA08DDN+1(23),DA08DDN      NAME, PASSWORD, AND\n         MVC   DA08MNM(16),DA08DDN        SYSOUT CLASS\n         MVI   DA08DSO,X'40'              DSORG=(PS)\n         MVC   DA08BLK(12),PRSPACE        SPACE=(1680,(20,10),RLSE)\n         OI    DA08CTL,X'40'              ALLOCATE IN BLOCKS\n*\n         LA    R6,XDAPL                   WE EXPECT THE DAPL TO BE\n         USING DAPL,R6                         ALREADY FORMATTED\n         ST    R8,DAPLDAPB\n         DROP  R6\n*\n         LR    R1,R6        DAPL INTO R1\n         LINK  EP=IKJEFD00\n         LTR   R15,R15\n         BNZ   PRDAIRER\n*\n         LA    R6,PRDCB              OUTPUT DCB\n         USING IHADCB,R6\n         MVC   DCBDDNAM(8),DA08DDN   PUT DDNAME INTO OUTPUT DCB\n         OPEN  (PRDCB,(OUTPUT))\n         TM    DCBOFLGS,B'10000'\n         BNO   PROPNERR\n*\n         LH    R6,LINELENG          LIMIT LINE LENGTH TO 70\n         LA    R7,70\n         CR    R6,R7\n         BNH   PRRET\n         STH   R7,LINELENG\n*\nPRRET    BR    R3\n*\nPRDSNMV  MVC   PRPNDSN+2(0),0(R6)   GET PRINT DSN INTO DAIR FORMAT\n         DROP  R6,R8\n         EJECT\nRESTOHEX LA    R6,4               PREPARE WORK REGISTERS\n*                                    R6 GETS A BIT FOR EACH SIGNIFICANT\n         LR    R9,R6                 DIGIT. R7 IS THE SOURCE OF BITS.\n         SR    R7,R7                 IT IS EITHER ALL F'S OR ALL 0'S.\n         LA    R10,1                 R10 IS A ONE-TIME SWITCH.\n*                                    R15 HAS THE ARGUMENT. R14 IS FOR\n*                                    WORK, R4, AND R5 GET RESULTS.\nRESLOOP  SLDL  R4,8              MOVE PREVIOUS RESULT OVER\n         SR    R14,R14\n         SLDL  R14,4             GET 4 BITS INTO R14\n         LTR   R14,R14           ARE WE SIGNIFICANT?\n         BZ    *+6                   NO  - LEAVE BITS ZERO\n         BCTR  R7,0                  YES - SET SOURCE BITS ON\n*\n         SLDL  R6,1              MOVE BIT OR ZERO, DEPENDING ON\n         IC    R5,ONETOF(R14)        SIGNIFICANCE, AND TRANSLATE\n*                                    THE BITS IN R14\n         BCT   R9,RESLOOP        AFTER 4 NIBBLES WE RESET THE\n         BCT   R10,RESOUT            SIGNIFICANCE SWITCH AND LOOP\n         SR    R7,R7             AFTER THE SECOND 4 NIBBLES, WE QUIT.\n         SLL   R6,4              R6 WILL CONTAIN BOTH A BIT MAP\n         LA    R6,5(R6)               AND THE REGISTER NUMBERS IN\n         LA    R9,4                   WHICH THE DIGITS ARE HELD.\n         B     RESLOOP\n*\nRESOUT   BR    R3\n*\n*\n*\nRESTODEC CVD   R15,RESDWD               PACK IT\n         L     R15,RESDWD+4             BACK INTO REGISTER\n         SRL   R15,4                    SHIFT OFF SIGN\n         B     RESTOHEX                 CONTINUE AS THOUGH IT WAS HEX\n*\n         EJECT\n         USING DAPL,R1\nDAIRERR  L     R8,DAPLDAPB          ASSUME R1 STILL POINTS TO DAPL\n         DROP  R1\n         USING DAPB08,R8            WE'LL USE THE '08 PARAMETER BLOCK\n*                                        DSECT, BUT ACTUALLY HANDLE\n*                                        MANY BLOCKS.\n         OI    RCDE+3,X'08'         INDICATE BAD OUTPUT\n         MVC   DAMSGWK(L'DAMSGMSK),DAMSGMSK  INITIALIZE ERROR MESSAGE\n*                                                   WORK AREA.\n         ST    R3,DAIRR3            SAVE RETURN REGISTER\n         ST    R15,DAIR15          SAVE INPUT ARGUMENT\n*\n         XC    ECB,ECB              ZERO THE EVENT CONTROL BLOCK\n         LA    R0,STKLEN            LENGTH OF SP78 AREA\n         ICM   R0,B'1000',=AL1(78)  INDICATE SUBPOOL\n         GETMAIN R,LV=(0)\n*\n         LR    R2,R1             WE SHARE SP78 WITH THE TERMINAL\n         USING LSD,R2                MONITOR, SO IT WON'T GO AWAY\n         XC    LSD(STKLEN),LSD       WHEN WE TERMINATE.\n*\n         LA    R4,INSTGLST       ADDR OF COMMANDS TO BE STACKED\n         LA    R5,32             LENGTH OF A COMMAND\n         SLL   R5,16                  IN LEFT HALFWORD\n         LR    R6,R4             ADDR OF FIRST COMMAND TO BE STACKED\n         STM   R4,R6,LSD         INITIALIZE LIST SOURCE DESCRIPTOR\n         MVC   INSTGLST(INSTGL),INSTGMSK    INITIALIZE IN-STORAGE LIST\n         ST    R2,IOPLIOPB       COMPLETE PARAMETER CHAIN FROM R1\n*\n*\n         L     R15,DAIR15              GET DAIR RC BACK\n         BAL   R3,RESTODEC              MAKE IT VISIBLE\n         LA    R7,DAIRR15             FOR EX\n         EX    R6,DAIRSTCM              PUT IT INTO MESSAGE\n         LA    R7,INSTGLST+L'INSTDAIR       AND INTO STACK COMMAND\n         EX    R6,DAIRSTCM\n         MVC   LSDTOTLN(2),=H'96'       LENGTH OF THREE ENTRIES\n*\n         L     R15,DA08CD               ENTRY CODE AND FLAGS\n         BAL   R3,RESTOHEX\n         STCM  R4,B'0011',DAIRNTRY      THEY GO INTO MESSAGE WITHOUT\n         STCM  R5,B'0011',DAIRFLG            ZERO SUPPRESS\n*\n         LH    R15,DA08DARC             DAIR RETURN CODE\n         BAL   R3,RESTOHEX\n         LA    R7,DAIRDARC\n         EX    R6,DAIRSTCM\n         LA    R7,INSTGLST+32+L'INSTDARC\n         EX    R6,DAIRSTCM\n*\n         LH    R15,DA08CTRC             CATALOG RETURN CODE\n         BAL   R3,RESTODEC              CONVERT TO DECIMAL\n         LA    R7,DAIRCTRC              CTLG RETURN CODE\n         EX    R6,DAIRSTCM                   INTO MESSAGE\n         LA    R7,INSTGLST+64+L'INSTCTRC     AND INTO STACK COMMAND\n         EX    R6,DAIRSTCM\n*\n         SR    R15,R15              CHECK TO SEE IF RC'S ARE THERE.\n         CH    R15,DA08DARC            IS THERE A DARC RETURN CODE?\n         BNE   DAIRCKCL                   YES - LET IT ALONE\n         MVC   INSTGLST+32(32),INSTGLST+64  NO  - SQUEEZE EMPTY ENTRY\n         MVC   LSDTOTLN(2),=H'64'              AND CUT TO LENGTH\n*\nDAIRCKCL CH    R15,DA08CTRC            IS THERE A CATALOG RC\n         BNE   DAIRSTK                    YES - LET IT ALONE\n         LH    R15,LSDTOTLN               NO  - CUT IT OFF\n         SH    R15,=H'32'\n         STH   R15,LSDTOTLN\n*\nDAIRSTK  STACK PARM=DAIRSTKL,ECB=ECB,STORAGE=(LSD,SOURCE),        MMMMMM\n               MF=(E,IOPL)\n*\n*\n         LA    R0,DAMSGLEN         LGTH OF MSG\n         LA    R1,DAMSGWK          ADDR OF MSG\n         TPUT  (R1),(R0),R\n*\n*\n         L     R3,DAIRR3               RETURN ADDRESS\n         BR    R3\n*\nDAIRSTCM STCM  R0,B'0',0(R7)\n         EJECT\n         USING IKJPARMD,R10\n*\nDSNFMT   LA    R8,DA08AREA             MAKE DAIR WORK AREAS\n         LA    R9,DA18AREA                 ADDRESSABLE\n         LA    R4,DA00AREA                 ADDRESSABLE\n         USING DAPB00,R4\n         USING DAPB08,R8\n         USING DAPB18,R9\n*\n         MVI   DA08CD+1,X'08'          FILLING OUT DAIR PARAMETER AREAS\n         MVI   DA18CD+1,X'18'          ENTRY CODES\n*\n         L     R7,PARDSN               POINTER TO DSN\n         LH    R6,PARDSN+4             LENGTH OF DSN\n         STH   R6,DSNBUF               PASS LENGTH TO DAIR\n         BCTR  R6,0                    DECREMENT FOR EXECUTE\n         EX    R6,DSNMOVE              MOVE DSN TO BUFFER\n         EX    R6,DSNMOVE2             PUT DSN IN FINAL MSG\n         B     DSNMOVE+6               JUMP EX 'ED MOVE\nDSNMOVE  MVC   DSNBUF+2(0),0(R7)     PUT DSN INTO DAIR FORMAT\nDSNMOVE2 MVC   FINDSN(0),0(R7)         DSN INTO FINAL MSG\n*\n         LA    R6,DSNBUF               ADDR OF DSN BUFFER FOR DAIR\n         ST    R6,DA00PDSN                 PASS TO FIND\n         ST    R6,DA08PDSN                 PASS TO ALLOCATE\n*\n         TM    PARDSN+6,B'01000000'    IS THE DSN IN QUOTES\n         BO    DSNDAPL                     YES - DON'T SET USERID FLAG\n         OI    DA00CTL,B'00100000'         NO  - DAIR MUST DO USERID\n         OI    DA08CTL,B'00100000'\n*\n*\n*              FORMAT DAIR PARMMETER BLOCK\n*\nDSNDAPL  LA    R6,XDAPL\n         USING DAPL,R6\n         MVC   DAPLUPT(12),PPLAREA    UPT, ECT, & ECB ARE FROM PARSE\n*                                          PARAMETER LIST\n         LA    R5,DAPLPSCB            TARGET FIELD\n         EXTRACT (R5),'S',FIELDS=(PSB)   PROTECTED STEP CONTROI BLOCK\n*\n         BR    R3\n         DROP  R4\n         DROP  R6\n         DROP  R8\n         DROP  R9\n         EJECT\n*\n*                            * * *  WORKING STORAGE * * *\n*\nWKPOINTR  DC   F'0'\n*\nPSALL0   DC    C'ALL',XL5'0'\n*\nLINETAB  DC    X'500A141E28323C46505A'\n*\nGMREQ    DC    F'4096',F'40960'\nGMANS    DC    2F'0'\n*\nPARSMSG  DC    C'I CAN''T MAKE SENSE FROM YOUR INPUT. FORGET IT!'\n*\nDAIRMSG  DC    C'DAIR ERROR. CONTACT SYSTEMS.'\n*\nPARTMSG  DC    C'JUST HOW, PRAY, DOES ONE READ THE DIRECTORY OF A DATA *\n               SET THAT IS NOT OF PARTITIONED ORGANIZATION?'\n*\nOPENMSG  DC    C'UNABLE TO OPEN TARGET DATA SET. CONTACT SYSTEMS.'\n*\nMSGNOCOR DC    C'INSUFFIECENT STORAGE TO SORT ALIASES. OUTPUT TRUNCATEDX\n               .'\nPROPNMSG DC    C'UNABLE TO OPEN OUTPUT DATA SET. CONTACT SYSTEMS.'\nMSGNOTCT DC    CL80'DATA SET'\n*\nMSGNOTPS DC    C'OUTPUT DATA SET IS NOT DSORG=PS. NOPRINT ASSUMED.'\n*\nFINAL    DC    X'402020202121'\n          DC    C'  MEMBERS FOUND IN DATA SET   '\nFINDSN   DC    CL44' '\nLFINAL   EQU   *-FINAL\n*\nPRSPACE  DC    A(1680)\n         DC    A(20)\n         DC    A(10)\n*\n*\n*\nCLOSEL   CLOSE (DCB,,PRDCB),MF=L\n*\nONETOF   DC    C'0123456789ABCDEF'\n*\nDAMSGMSK DC    C'DAIR R15=0    DAIR ENTRY=0    DAIR FLG=0    DAIRDARC=0X\n                   DAIRCTRC=0            '\n*\nINSTGMSK DS    0C\nINSTDAIR DC    C'HELP ERROR OP(DAIR'\n         DC    CL(32-L'INSTDAIR)' '\nINSTDARC DC    C'HELP ERROR OP('\n         DC    CL(32-L'INSTDARC)' '\nINSTCTRC DC    C'HELP ERROR OP(CATALOG'\n         DC    CL(32-L'INSTCTRC)' '\nINSTGL   EQU   *-INSTGMSK\nPRQALTB  DC    AL1(3),C'.ASM'\n         DC    AL1(3),C'.PLI'\n         DC    AL1(4),C'.DATA'\n         DC    AL1(4),C'.CNTL'\n         DC    AL1(4),C'.FORT'\n         DC    AL1(5),C'.CLIST'\nPRQALND  DC    AL1(5),C'.COBOL'\n*\n*\n         LTORG\n         EJECT\n         PUSH  PRINT\n         PRINT ON,NOGEN\nPARMDSN  IKJPARM\nPARDSN   IKJPOSIT DSNAME,PROMPT='DSNAME OF SUBJECT PDS'\nPARALIAS IKJKEYWD\n         IKJNAME   'ALIAS'\n         IKJNAME   'NOA'\n         IKJNAME   'A'\n         IKJNAME   'NOALIAS'\nPARPARM  IKJKEYWD\n         IKJNAME  'PREFIX',SUBFLD=PARPFX\n         IKJNAME  'PRE',SUBFLD=PARPFX\n         IKJNAME  'P',SUBFLD=PARPFX\nPARLINE  IKJKEYWD\n         IKJNAME  'LINE',SUBFLD=PARLN\n         IKJNAME  'L',SUBFLD=PARLN\nPARPNT   IKJKEYWD\n         IKJNAME  'PRINT',SUBFLD=PARPN\n         IKJNAME  'PR',SUBFLD=PARPN\nPARPFX   IKJSUBF\nPARPFXD  IKJIDENT  'STRING',MAXLNTH=8,FIRST=ANY,OTHER=ANY,             X\n               PROMPT='MASK'\nPARLN    IKJSUBF\nPARLND   IKJIDENT 'NUMBER',MAXLNTH=2,FIRST=NUMERIC,OTHER=NUMERIC,      X\n               PROMPT='LINESIZE'\nPARPN    IKJSUBF\nPARPND   IKJPOSIT  DSNAME,PROMPT='DSNAME YOU WISH TO RECIEVE OUTPUT'\n         IKJENDP\n*\nDCB      DCB   DSORG=PS,RECFM=U,BLKSIZE=256,MACRF=(R),EODAD=EODAD\n         SPACE\nPRDCB    DCB   DSORG=PS,RECFM=FB,BLKSIZE=1680,MACRF=(PM),              M\n               LRECL=80\n         POP   PRINT\n*\n         EJECT\n*        ADDITIONAL WORK AREAS\n*\nWKA      DSECT\nSAVEAREA DS    18F\n*\nRCDE     DS    F             RETURN CODE FOR PROGAM\nDONTFREE DS    F             SWITCH TO PREVENT FREEING A PREALLOCATED\n*                                 DATASET\nCHAINR3  DS    F\nCHAINR5  DS    F\nFORMR3   DS    F\nFORMR5   DS    F\n*\n*\n*\nXPPL     DS    7F            * RESERVE SEVEN WORDS FOR PARSE    *\n*                            *    PARAMETER  LIST               *\nCBUF     DS    CL80          * COMMAND BUFFER                   *\nECB      DS    F             * EVENT CONTROL BLOCK FOR PARSE    *\nANS      DS    F             * POINTER TO PARAMETER DESCRIPTOR  *\n*                            *    LIST                          *\nPPLAREA  DS    7F\nDA00AREA DS     5F\nDA04AREA DS     5F\n*\nDA08AREA DS    CL84\n         DS    0F\nDA18AREA DS    CL40\nDSNBUF   DS    H\n         DS    CL44\n*\nXDAPL    DS    5F                      RESERVE 5 WDS FOR DAIR PARMMETER\n*                                          BLOCK\n*\nPSAND    DS    CL8                     AND THE MEMBER NAME WITH PSAND,\nPSXC     DS    CL8                         SO IT WILL LOOK LIKE PSXC\nPSARGU   DS    CL8                         FOR AN EQUAL COMPARE\n*\nLINELENG DS    H\n*\nDIRDATA  DS    CL256\nPUTLINE  DS    CL100\n*\nHITCOUNT DS    PL3\nLINECNT  DS    PL5\n*\nPRINTSW  DS    XL1\n*\n         DS    0H\nPRPNDSN  DS    CL46\nPRSTR3   DS    F\n*\nIOPL     DS    0F\nIOPLUPT  DS    F\nIOPLECT  DS    F\nIOPLECB  DS    F\nIOPLIOPB DS    F\n*\nDAIRSTKL DS    D           SAME AS STACK MF=L\n*\n*\nDAIRR3   DS    F\nDAIR15   DS    F\n*\nDAMSGWK  DS    0C\n         DS    9C\nDAIRR15  DS    5C\n         DS    11C\nDAIRNTRY DS    5C\n         DS    9C\nDAIRFLG  DS    5C\n         DS    9C\nDAIRDARC DS    5C\n         DS    9C\nDAIRCTRC DS    5C\nDAMSGLEN EQU   *-DAMSGWK\n*\nRESDWD   DS    D\nWORKEND  EQU   *\nCHANTOP  EQU   *\nWKLGTH   EQU   WORKEND-SAVEAREA\n         EJECT\n*                            * * *  DSECTS  * * *\n*\n         PUSH  PRINT\n         PRINT ON,NOGEN\n         IKJPPL\n         SPACE\n         IKJDAP00        SEARCH\n         SPACE\n         IKJDAP04        SEARCH\n         SPACE\n         IKJDAP08        ALLOCATE\n         SPACE\n         IKJDAP18        DEALLOCATE\n         SPACE\n         IKJDAPL         DAIR PARAMETER BLOCK\n         SPACE\n         IKJCPPL\n         SPACE\n         DCBD\n         POP   PRINT\n         EJECT\n*\n*\n*        THIS IS THE LIST SOURCE DESCRIPTOR, AND THE IN-STORAGE\n*        LIST THAT ARE PASSED TO STACK. THEY GO INTO SP78, SO\n*        THEY ARE NOT FREED WHEN SHOWDIR ENDS.\n*\nLSD      DSECT\nLSDADATA DS    F\nLSDRCLEN DS    H\nLSDTOTLN DS    H\nLSDANEXT DS    F\nLSDRSVRD DS    F\n*\n*\n*\nINSTGLST DS    4CL32\n*\nSTKLEN   EQU   *-LSD\n         EJECT\n*./ ADD   NAME=SHOWDIR\n*./ NUMBER NEW1=10,INCR=10\n*./ ALIAS   NAME=SD\n*)F FUNCTION -\n*  THE SHOWDIR COMMAND IS USED TO PRINT OUT PART OR ALL OF\n*  THE DIRECTORY OF A PARTITIONED DATA SET.\n*  OPTIONALLY, IT WILL PRODUCE A DISK DATA SET SUTABLE\n*  FOR MANIPULATION WITH EDIT.\n*)X SYNTAX  -\n*         SHOWDIR  'DSNAME'   LINE('LINESIZE')    PREFIX('MASK')\n*                  PRINT('DSNAME')  'ALIAS'\n*  REQUIRED - DSNAME\n*  DEFAULTS - LINESIZE=7    MASK=ALL        ALIAS\n*)O OPERANDS -\n*   'DSNAME'         - THE PARTITIONED DATA SET FOR WHICH THE DIRECTORY\n*                      LISTING IS REQUIRED.\n*))LINE('LINESIZE') - THE NUMBER OF MEMBER NAMES TO BE DISPLAYED\n*                      ON A SINGLE LINE.\n*                      IF THE \"PRINT\" OPTION IS TAKEN, THE FIRST\n*                      MEMBER NAME ON EACH LINE WILL BEGIN IN\n*                      POSITION 1.\n*))PREFIX('MASK')   - AN OPTIONAL PREFIX  USED AS A SEARCH MASK.\n*               UP TO EIGHT CHARACTERS ON WHICH TO COMPARE\n*               FOR EQUAL BEFORE PRINTING. AN ASTERISK (*), IN ANY\n*               POSITION MAKES IT A NON-COMPARE POSITION.\n*               EXAMPLES:\n*\n*                    PREFIX(BPS)    WILL RETURN ANY MEMBER NAME\n*                                   THAT BEGINS WITH \"BPS\".\n*\n*                    PRE(*****XYS)  WILL RETURN ANY MEMBER NAME THAT\n*                                   ENDS IN \"XYZ\".\n*\n*                    PR(BPS****7)   WILL RETURN ANY MEMBER NAME THAT\n*                                   BEGINS \"BPS\" AND ENDS IN A \"7\".\n*\n*))PRINT('DSNAME')   WILL RETURN THE LIST OF MEMBER NAMES IN\n*               A SEQUENTIAL DATA SET NAMED, \"USERID.(DSNAME).DATA\".\n*               A DSNAME IN QUOTES WILL BE RESPECTED, AS WILL A VALID\n*               QUALIFIER.\n*               THE DATA SET WILL HAVE SEQUENCE NUMBERS IN EDIT FORMAT.\n*\n*))ALIAS        \"NOALIAS\" WILL SUPPRESS THE SPECIAL FORMATTING\n*               GIVEN TO ALIAS NAMES. \"ALIAS\" IS THE DEFAULT.\n*               NOTE -- AN \"*ORPHAN*\" IS AN ALIAS NAME THAT\n*               MATCHES NO MAIN MEMBER NAME.\n*               A SPURIOUS *ORPHAN* WILL BE GENERATED WHEN\n*               AN ALIAS MEMBER NAME MATCHES THE SEARCH MASK,\n*               BUT THE MAIN NAME DOES NOT.\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SELMEMBR": {"ttr": 9217, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\x82\\x00\\x82\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 130, "newlines": 130, "modlines": 0, "user": "FILE369"}, "text": "   PROC 0 LIST\n /********************************************************************/\n /*                                                                  */\n /* SOURCE LEVEL SELMEMBR V01.M16 85/11/27 07:51 PDVHEM              */\n /*                                                                  */\n /* NAME         SELMEMBR                                            */\n /*                                                                  */\n /* COMPONENT    UTILITY                                             */\n /*                                                                  */\n /* FUNCTION     DISPLAY A MEMBER LIST USING TABLE SERVICES          */\n /*              AND PERMIT A USER TO SELECT A MEMBER.               */\n /*                                                                  */\n /* ENTRY        VIA ISPEXEC SELECT OR CLIST INVOCATION.             */\n /*                                                                  */\n /* INPUT        DSNAME OF A PDS IN SHARED POOL VARIABLE DSNAME.     */\n /*                                                                  */\n /* OUTPUT       MEMBER NAME IN SHARED POOL VARIABLE MEMBER.         */\n /*              RETURN CODE.                                        */\n /*                                                                  */\n /* PARAMETERS   LIST - ENABLE DEBUGGING VIA CONTROL LIST.           */\n /*                                                                  */\n /* EXT REF      NONE.                                               */\n /*                                                                  */\n /* ISPF SERVICE CONTROL                                             */\n /*              LMCLOSE                                             */\n /*              LMFREE                                              */\n /*              LMINIT                                              */\n /*              LMMLIST                                             */\n /*              LMOPEN                                              */\n /*              TBADD                                               */\n /*              TBCREATE                                            */\n /*              TBDISPL                                             */\n /*              TBEND                                               */\n /*              TBTOP                                               */\n /*              VGET                                                */\n /*              VPUT                                                */\n /*                                                                  */\n /* MESSAGES     ISRM007                                             */\n /*                                                                  */\n /* PANELS       SELMEMP1 - TABLE DISPLAY                            */\n /*              SELMEMH0 - HELP                                     */\n /*              SELMEMH1 - HELP                                     */\n /*              SELMEMH2 - HELP                                     */\n /*                                                                  */\n /* PROGRAMS     NONE                                                */\n /*                                                                  */\n /* CLISTS       NONE                                                */\n /*                                                                  */\n /* OPERATION    THE PDS IS PREPARED BY ISSUING LMINIT AND LMOPEN.   */\n /*              THE TABLE 'MEMTABLE' IS INITIALIZED WITH TBCREATE.  */\n /*              LMMLIST AND TBADD ARE ISSUED TO ADD ONE ROW TO      */\n /*              THE TABLE FOR EACH MEMBER. THE PDS IS THEN CLOSED   */\n /*              WITH LMCLOSE AND LMFREE. TBDISPL IS USED TO SHOW    */\n /*              THE TABLE AND ACCEPT A SELECTED MEMBER. IF          */\n /*              END IS SIGNALED, THE CLIST RETURNS WITH NO MEMBER   */\n /*              AND RETURN CODE 8.                                  */\n /*                                                                  */\n /* RETURN CODE  0 MEMBER NAME RETURNED                              */\n /*              8 END COMMAND                                       */\n /*                                                                  */\n /* RESTRICTIONS NONE.                                               */\n /*                                                                  */\n /* NOTES        NONE.                                               */\n /*                                                                  */\n /* PROGRAMMER   C. J. PITTS                                         */\n /*                                                                  */\n /* SOURCE LEVEL |                                                   */\n /*                                                                  */\n /* MAINTENANCE  WHO  DATE   DESCRIPTION                             */\n /*                                                                  */\n /********************************************************************/\n\n  IF &LIST=LIST     +\n    THEN CONTROL LIST   MSG\n    ELSE CONTROL NOLIST MSG\n\n  ISPEXEC CONTROL ERRORS CANCEL\n\n  ISPEXEC VGET (DSNAME) SHARED\n\n  ISPEXEC LMINIT DATAID(DSID) DATASET(&DSNAME)\n  ISPEXEC LMOPEN DATAID(&DSID)\n  ISPEXEC TBCREATE MEMTABLE REPLACE NOWRITE KEYS(MEMBER) NAMES(STATS)\n\n  SET &LMLRC = 0\n  DO WHILE &LMLRC = 0\n    ISPEXEC LMMLIST DATAID(&DSID) MEMBER(MEMBER) +\n                    OPTION(LIST) STATS(YES)\n    SET &LMLRC = &LASTCC\n    IF &LMLRC = 0   +\n      THEN DO\n             SET &STATS = &STR(&ZLVERS..&ZLMOD  &ZLCDATE +\n                               &ZLMDATE &ZLMTIME &ZLCNORC +\n                               &ZLINORC &ZLMNORC &ZLUSER)\n             ISPEXEC TBADD MEMTABLE\n           END\n  END\n\n  ISPEXEC LMMLIST DATAID(&DSID) OPTION(FREE)\n  ISPEXEC LMCLOSE DATAID(&DSID)\n  ISPEXEC LMFREE  DATAID(&DSID)\n\n  ISPEXEC TBTOP  MEMTABLE\n  ISPEXEC TBDISPL MEMTABLE PANEL(SELMEMP1) POSITION(ROW)\n  SET &TBDRC = &LASTCC\n\n  SET &DONE = NO\n  DO WHILE &DONE = NO\n    IF      &TBDRC>4       +\n        THEN SET &DONE = YES\n      ELSE IF &S = S       +\n        THEN DO\n               SET &TBDRC = 0\n               SET &DONE  = YES\n             END\n      ELSE IF &S = &STR( )   +\n        THEN DO\n               ISPEXEC TBDISPL MEMTABLE POSITION(ROW)\n               SET &TBDRC = &LASTCC\n             END\n      ELSE DO\n             ISPEXEC TBDISPL MEMTABLE MSG(ISRM007) POSITION(ROW)  +\n                                      CSRROW(&ROW)\n             SET &TBDRC = &LASTCC\n           END\n  END\n\n  ISPEXEC TBEND  MEMTABLE\n  ISPEXEC VPUT (MEMBER) SHARED\n  EXIT CODE(&TBDRC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SELMEMP1": {"ttr": 9220, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "FILE369"}, "text": ")ATTR\n _ TYPE(INPUT)  INTENS(HIGH) CAPS(ON)\n @ TYPE(OUTPUT) INTENS(LOW)\n)BODY WIDTH(80)\n%SELECT MEMBER --- &DSNAME -----------------------------------------------------\n%COMMAND ===>_ZCMD                                            %SCROLL ===>_Z   +\n+   NAME                VV.MM   CREATED  LAST MODIFIED   SIZE  INIT   MOD   ID\n+===============================================================================\n)MODEL\n_S@MEMBER              @STATS\n)INIT\n .HELP = SELMEMH0\n .ZVARS = 'ZSCML'\n &S = ' '\n &ZCMD = ' '\n)REINIT\n &ZCMD = ' '\n IF (.MSG=' ')\n   &S = ' '\n   REFRESH(S)\n)PROC\n VER (&S,LIST,S,MSG=ISRM007)\n VPUT (ZSCML) PROFILE\n &ZCMD = ' '\n)END\n /* SOURCE LEVEL SELMEMP1 V01.M16 85/12/23 15:14 PSYCJP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SID": {"ttr": 9222, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\xae\\x00\\xae\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 174, "newlines": 174, "modlines": 0, "user": "FILE369"}, "text": "PRC      TITLE 'SID - THIS PGM RETURNS A SYSTEM ID INDICATOR IN R15'\n********************************************************************\n*                                                                  *\n* NAME - SID.                                                      *\n*                                                                  *\n* DESCRIPTION - THIS UTILITY PROGRAM RETURNS A CODE IN R15 THAT    *\n*   DENOTES THE SYSTEM IT IS RUNNING ON. THIS CAN BE USEFUL        *\n*   FOR SITE OR CPU-DEPENDENT JCL OR CLISTS.                       *\n*                                                                  *\n* TO USE -                                                         *\n*   // EXEC PGM=SID                                                *\n*                                                                  *\n*   FOR TESTING PURPOSES, THE SID CAN BE PASSED THRU THE PARM      *\n*   FIELD TO OVERRIDE THE LIVE SID:                                *\n*   // EXEC PGM=SID,PARM=APS2                                      *\n*                                                                  *\n* RETURN CODES -                                                   *\n*   R15 = 1-? - INDICATES THE SYSTEM ID AS DIRECTED IN TABLE       *\n*   R15 = 16  - SYSTEM ID NOT FOUND IN TABLE                       *\n*   R15 = 20  - PARM FIELD INVALID (NOT 4 BYTES LONG)              *\n*                                                                  *\n* NOTES -                                                          *\n*   THE SID TABLE (AT LABEL TABLE) IS INSTALLATION DEPENDENT.      *\n*   WE NEED MACLIB AND AMODGEN TO ASSEMBLE PROPERLY.               *\n*                                                                  *\n* LOG -                                                            *\n*   05/00/85 L01 PTW IMPLEMENTED                                   *L01\n*   09/21/88 L02 PTW REDONE, FIXED S0C4 W/PLI NO-PARM CALL.        *L02\n*                                                                  *\n********************************************************************\n         LCLC  &CSECT\n&CSECT   SETC  'SID'\n&CSECT   CSECT\n********************************************************************\n*                                                                  *\n*        I N I T I A L I Z E                                       *\n*                                                                  *\n********************************************************************\n         PRINT NOGEN\n         SAVE  (14,12),,&CSECT-&SYSDATE-&SYSTIME\n         LR    R12,R15            ESTABLISH BASE.\n         USING &CSECT,R12         TELL ASSEMBLER.\n         GETMAIN RU,LV=DYNLEN     GET DYNAMIC AREA.\n         LR    R2,R13             SAVE AREA\n         LR    R13,R1             SAVE AREA\n         USING DYNAMIC,R13        TELL ASSEMBLER.\n         LA    R0,DYNAMIC         ZERO\n         L     R1,=A(DYNLEN)        DYNAMIC\n         LR    R14,R0                 STORAGE.\n         SLR   R15,R15\n         MVCL  R0,R14             DO IT.\n         ST    R2,4(,R13)         BACK CHAIN.\n         ST    R13,8(,R2)         FORWARD CHAIN.\n         MVC   RC,=F'16'          ASSUME BAD RC.\n********************************************************************\n*                                                                  *\n*        P A R M   P R O C E S S I N G                             *\n*                                                                  *\n********************************************************************\n         MVI   GOTPARM,NO         DEFAULT TO NO PARM.\n         L     R2,4(,R13)         DIG FOR PARM.\n         L     R2,24(,R2)         R2 = A(PARMLIST).\n         LTR   R2,R2              WATCH OUT FOR NO PARM FROM\n         BZ    ENDPARM              HI-LEVEL LANGUAGE.\n         L     R2,0(,R2)          R2 = A(PARMLIST).\n         LH    R3,0(,R2)          R3 = L'PARMLIST.\n         LTR   R3,R3              IF PARM NOT THERE,\n         BZ    ENDPARM              OK, TAKE DEFAULT.\n         CH    R3,=H'4'          IF LENGTH \u00ac= 4,\n         BNE   BADPARM             BAD.\n         MVC   OURSID,2(R2)      SAVE SID.\n         MVI   GOTPARM,YES       INDICATE PARM PRESENT.\nENDPARM  DS    0H\n********************************************************************\n*                                                                  *\n*        D O   T A B L E   L O O K U P                             *\n*                                                                  *\n********************************************************************\n         CLI   GOTPARM,YES        IF PARM PRESENT,\n         BE    USEPARM              USE IT. BYPASS NEXT.\n         L     R2,CVTPTR          R2 = A(CVT).\n         L     R2,CVTSMCA-CVT(,R2) DIG INTO SMCA FOR SID.\n         MVC   OURSID,SMCASID-SMCABASE(R2)\nUSEPARM  DS    0H\n         LA    R2,TABLE           DO TABLE LOOKUP.\n         USING SIDTAB,R2\nLOOP     DS    0H\n         CLI   SIDNAME,X'FF'      IF WE HAVE STOPPER,\n         BE    RETURN               THEN SID NOT FOUND.\n         CLC   OURSID,SIDNAME     IF WE HAVE A MATCH,\n         BE    GOTSID               THEN USE IT.\n         LA    R2,SIDLEN(,R2)     ELSE BUMP TO NEXT ENTRY.\n         B     LOOP\nGOTSID   DS    0H\n         MVC   RC,SIDRC           USE THE RETURN CODE IN TABLE.\n         DROP  R2\n********************************************************************\n*                                                                  *\n*        R E T U R N                                               *\n*                                                                  *\n********************************************************************\nRETURN   DS    0H\n         L     R2,RC              R2 = RC.\n         LR    R1,R13             PREPARE\n         L     R13,4(,R13)          FOR FREEMAIN.\n         FREEMAIN RU,LV=DYNLEN,A=(1)\n         LR    R15,R2               AND RETURN\n         RETURN (14,12),RC=(15)      WITH R15 = RC.\n********************************************************************\n*                                                                  *\n*        E R R O R S                                               *\n*                                                                  *\n********************************************************************\nBADPARM  DS    0H                 BAD PARM VALUE PASSED TO US.\n         MVC   RC,=F'20'\n         B     RETURN\n********************************************************************\n*                                                                  *\n*        S T A T I C   A R E A S.                                  *\n*                                                                  *\n********************************************************************\n*\n*   ===> INSTALLATION DEPENDENT TABLE <===\n*\nTABLE    DC    CL4'APS1',F'1'    MAPPED BY SIDTAB DSECT\n         DC    CL4'APS2',F'2'\n         DC    CL4'APS3',F'3'\n         DC    CL4'APS4',F'4'\n         DC    CL4'    ',F'0'\n         DC    CL4'    ',F'0',X'FF'\n*\nSRCLEVEL DC    C'                                        '\n         LTORG *\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   A R E A S.                                *\n*                                                                  *\n********************************************************************\nDYNAMIC  DSECT\nSAVE     DS    18F                SAVE AREA.\nRC       DS    F                  RETURN CODE.\nOURSID   DS    CL4                OUR SYSTEM ID.\nGOTPARM  DS    X                  PARM PRESENT?\nYES      EQU   1\nNO       EQU   2\nDYNLEN   EQU   *-DYNAMIC\n*\nSIDTAB   DSECT                    DESCRIBES TABLE.\nSIDNAME  DS    CL4\nSIDRC    DS    F\nSIDLEN   EQU   *-SIDTAB\n*\n         CVT   DSECT=YES\n         IEESMCA\n*\n         PRINT OFF\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         PRINT ON,NOGEN\n         END   &CSECT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SITEID": {"ttr": 9226, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\xea\\x00\\xea\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 234, "newlines": 234, "modlines": 0, "user": "FILE369"}, "text": "         TITLE 'SITEID - SET RETURN CODE BASED ON JES2 SPOOL NODE NAME'\n***********************************************************************\n*                                                                     *\n* NAME         SITEID                                                 *\n*                                                                     *\n* COMPONENT    SYSTEM UTILITY                                         *\n*                                                                     *\n* FUNCTION     SET RETURN CODE TO INDICATE EXEC SITE                  *\n*                                                                     *\n* ENTRY        STANDARD LINKAGE                                       *\n*                                                                     *\n* PARAMETERS   NONE                                                   *\n*                                                                     *\n* INPUT        NONE                                                   *\n*                                                                     *\n* OUTPUT       NONE                                                   *\n*                                                                     *\n* RETURN CODES 1 TO 15   SPECIFIC SITE IDENTIFIED (SEE LABEL SITETBL) *\n*              16        UNABLE TO IDENTIFY SITE                      *\n*              20        UNABLE TO LOCATE JCT                         *\n*                                                                     *\n* FILES        NONE                                                   *\n*                                                                     *\n* EXT REF      NONE                                                   *\n*                                                                     *\n* EXITS        NONE                                                   *\n*                                                                     *\n* MESSAGES     NONE                                                   *\n*                                                                     *\n* MACROS       RETURN                                                 *\n*              SAVE                                                   *\n*                                                                     *\n* TABLES       JCT                                                    *\n*              JSCB                                                   *\n*              PSA                                                    *\n*              SJB                                                    *\n*              SSIB                                                   *\n*              TCB                                                    *\n*                                                                     *\n* OPERATION    |                                                      *\n*                                                                     *\n* ATTRIBUTES   REENTRANT                                              *\n*              REUSABLE                                               *\n*              PROBLEM PROGRAM STATE                                  *\n*              PROBLEM PROGRAM KEY                                    *\n*              NOT AUTHORIZED                                         *\n*              AMODE ANY                                              *\n*              RMODE ANY                                              *\n*                                                                     *\n* RESTRICTIONS |                                                      *\n*                                                                     *\n* NOTES        NO CALLS OR SVC'S ARE USED, SO THIS MODULE PROVIDES    *\n*              NO SAVE AREA. NO WORKAREA IS NEEDED SO IT IS ALSO      *\n*              REENTRANT ANAD RESUABLE.                               *\n*                                                                     *\n*              THE PROCEDURE FOR LOCATING THE JCT IS DOCUMENTED       *\n*              IN WSC FLASH 8118 AND UPDATED BY INFO/MVS UNIT         *\n*              Q364737.                                               *\n*                                                                     *\n*              THE TABLE OF SITE ID'S AT LABEL SITETBL HAS A FEW      *\n*              UNUSED ENTRIES FOR ZAPS OR OTHER FAST-AND-DIRTY        *\n*              MAINTENANCE.                                           *\n*                                                                     *\n*              A LOT OF EXTRA JES2 DSECTS ARE NEEDED TO ALLOW THE     *\n*              JCT TO ASSEMBLE WITHOUT ERRORS.                        *\n*                                                                     *\n* AUTHOR       C. J. PITTS                                            *\n*                                                                     *\n* MAINTENANCE  WHO    DATE     DESCRIPTION                            *\n*                                                                     *\n*                                                                     *\n**********************************************************************/\n*                                                                     *\n* REGISTERS AT ENTRY                                                  *\n*              R13   SAVE AREA                                        *\n*              R14   RETURN ADDRESS                                   *\n*              R15   ENTRY POINT                                      *\n*                                                                     *\n* REGISTER USE IN PROGRAM                                             *\n*              R9    JCT BASE REGISTER                                *\n*              R12   BASE REGISTER                                    *\n*              R15   RETURN CODE                                      *\n*                                                                     *\n* REGISTERS AT EXIT                                                   *\n*              R15   RETURN CODE                                      *\n*                                                                     *\n**********************************************************************/\n         SPACE 3\nSITEID   CSECT\n         SPACE\nSITEID   AMODE ANY\nSITEID   RMODE ANY\n         SPACE\n         USING SITEID,R15          TEMPORARY BASE\n         B     BEGIN               SKIP OVER DOCUMENTATION\n         DC    AL1(BEGIN-*)        LENGTH OF TEXT\nSRCLEVEL DC    C'SITEID   VNN.MNN YY/MM/DD HH:MM UUUUUUUU'\n*                MODULE   VER/MOD   DATE   TIME  USER NAME\nCOPYRIGT DC    C' COPYRIGHT (C) 1988 PLANNING RESEARCH CORPORATION '\nASMSTAMP DC    C'ASM &SYSDATE &SYSTIME'\n         DROP  R15                 DONE WITH TEMPORARY BASE\nBEGIN    DS    0H\n         EJECT\n***********************************************************************\n*                                                                     *\n* SITE1000:                                                           *\n*        SAVE CALLER'S REGISTERS;                                     *\n*        SET BASE REGISTER;                                           *\n*        SET DEFAULT RETURN CODE FOR JCT NOT LOCATED;                 *\n*        LOCATE SSIB: PSA->TCB->JSCB->SSIB;                           *\n*        IF SSIB INDICATES MASTER SCHEDULER                           *\n*          THEN RETURN WITH BAD RETURN CODE;                          *\n*        LOCATE FIRST AND SECOND SJB: SSIB->SJB->SJB;                 *\n*        IF SECOND SSIB DOES NOT EXIST (EG, FOR TSU)                  *\n*          THEN USE THE FIRST SJB;                                    *\n*        LOCATE JCT: SJB->JCT;                                        *\n*        IF JCT EYECATCHER IS NOT VALID                               *\n*          THEN RETURN WITH BAD RETURN CODE;                          *\n*                                                                     *\n***********************************************************************\n         SPACE\nSITE1000 DS    0H\n         SAVE  (14,12)\n         SPACE\n         LR    R12,R15             BASE REGISTER\n         USING SITEID,R12\n         SPACE\n         LA    R15,NOGOTJCT        SET DEFAULT RETURN CODE\n         USING PSA,0\n         L     R1,PSATOLD          CURRENT (OLD) TCB\n         USING TCB,R1\n         XR    R2,R2               CLEAR HIGH BYTE\n         ICM   R2,B'0111',TCBJSCBB JSCB (24 BIT)\n         USING IEZJSCB,R2\n         L     R1,JSCBSSIB         SSIB\n         USING SSIB,R1\n         SPACE\n         CLC   SSIBSSNM,=CL4'MSTR' RUNNING UNDER MASTER SCHEDULER?\n         BE    SITE9000            YEP...GO EXIT\n         SPACE\n         L     R1,SSIBSUSE         INIT, STC OR TSU SJB POINTER\n         USING SJB,R1\n         ICM   R0,B'1111',SJBSJB   NEXT SJB (JOB UNDER INIT)\n         BZ    SITE1900            NOT THERE...USE THE FIRST ONE\n         LR    R1,R0               USE THE SECOND ONE\nSITE1900 DS    0H\n         SPACE\n         L     R9,SJBJCT           JCT (FINIALLY)\n         USING JCT,R9\n         CLC   JCTID,=CL4'JCT'     EYECATCHER MATCH?\n         BNE   SITE9000            NOPE...GO EXIT\n         SPACE\n         DROP  R1,R2\n         EJECT\n***********************************************************************\n*                                                                     *\n* SITE3000:                            /* LOOK UP EXECUTION SITE  */  *\n*        SET DEFAULT RETURN CODE - UNKNOWN SITE;                      *\n*        LOOK UP EXECUTION SITE NAME IN TABLE;                        *\n*        IF FOUND                                                     *\n*          THEN SET RETURN CODE TO TABLE INDEX VALUE;                 *\n*                                                                     *\n***********************************************************************\n         SPACE\nSITE3000 DS    0H\n         LA    R15,NOGOTSIT        SET RETURN CODE - UNKNOWN SITE\n         SPACE\n         LA    R1,MAXSITES         LOOP COUNTER\n         LA    R2,SITETBL          FIRST ENTRY\n         SPACE\nSITE3200 DS    0H\n         CLC   =CL8' ',0(R2)       TABLE ENTRY USED?\n         BE    SITE3600            NOPE...NEXT ENTRY\n         CLC   JCTNXNDE,0(R2)      EXECUTION NODE TABLE ENTRY?\n         BE    SITE3800            YEP...GO SET RETURN CODE\n         SPACE\nSITE3600 DS    0H\n         LA    R2,L'SITETBL(,R2)   NEXT ENTRY\n         BCT   R1,SITE3200         LOOP\n         B     SITE3900            NOT FOUND IN TABLE...ONWARD\n         SPACE\nSITE3800 DS    0H\n         LA    R15,MAXSITES        LAST TABLE INDEX\n         SR    R15,R1              COMPUTE RETURN CODE\n         SPACE\nSITE3900 DS    0H\n         SPACE 2\n***********************************************************************\n*                                                                     *\n* SITE9000:                      /*  RETURN WITH R15 RETURN CODE  */  *\n*        RETURN TO CALLER WITH RETURN CODE;                           *\n*                                                                     *\n***********************************************************************\n         SPACE\nSITE9000 DS    0H\n         RETURN (14,12),RC=(15)\n         EJECT\n***********************************************************************\n*        CONSTANTS AND LITERALS                                       *\n***********************************************************************\n         SPACE\n         DS    0D\nSITETBL  DS    0CL8                LIST OF SITES\n         DC    CL8' '                0  -  UNUSED\n         DC    CL8'APS1'             1  -  DULLES SDL\n         DC    CL8' '                2  -  UNUSED\n         DC    CL8'CPK2'             3  -  CRYSTAL PARK 2  PTO\n         DC    CL8' '                4  -  UNUSED\n         DC    CL8' '                5  -  UNUSED\n         SPACE\nMAXSITES EQU   (*-SITETBL)/L'SITETBL\n         SPACE\nNOGOTSIT EQU   16                  RETURN CODE - UNIDENTIFIED SITE\nNOGOTJCT EQU   20                  RETURN CODE - UNABLE TO LOCATE JCT\n         SPACE\n         LTORG\n         SPACE 2\n***********************************************************************\n*        DSECTS                                                       *\n***********************************************************************\n         SPACE\n         PRINT NOGEN\n         $BUFFER\n         $HASPEQU\n         $JCT\n         $SJB\n         $TQE\n         IEFJSSIB\n         IEZJSCB\n         IFGRPL\n         IHAPSA\n         IKJTCB\n         SPACE 3\n         END   SITEID\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SMF240": {"ttr": 9473, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\xa2\\x00\\xa2\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 162, "newlines": 162, "modlines": 0, "user": "FILE369"}, "text": "         MACRO\n&SMF240N SMF240 &DSECT=YES,&SUBTYPE=\n.**********************************************************************\n.*                                                                    *\n.* NAME         SMF240                                                *\n.*                                                                    *\n.* COMPONENT    UTILITY                                               *\n.*                                                                    *\n.* FUNCTION     MAPS USER SMF RECORD AND SUBTYPES                     *\n.*                                                                    *\n.* PARAMETERS   DSECT=YES       CREATE DSECT CARD                     *\n.*              SUBTYPE=        EXPAND SELECTED SUBTYPE DEFINITION    *\n.*                                                                    *\n.* RESTRICTIONS NONE                                                  *\n.*                                                                    *\n.* NOTES        USED WITH LOCAL SVC 226                               *\n.*                                                                    *\n.*              SUBTYPE DESCRIPTION                                   *\n.*                 1    USPTO SYSTEM MANAGEMENT SUBSYSTEM             *\n.*                      (GENERALLY CREATED WITH A PL/I PROGRAM        *\n.*                       WHICH CONTAINS THE DETAILED DESCRIPTION)     *\n.*                 2    VTAM SESSION ACCOUNTING                       *\n.*                 3    USPTO MESSENGER ACCOUNTING                    *\n.*                 4    USPTO ACF2 SHARED LOGONID USE                 *\n.*                                                                    *\n.* SOURCE LEVEL                                                       *\n.*                                                                    *\n.* AUTHOR       DICK SZIEDE CSC  1972                                 *\n.*                                                                    *\n.* MAINTENANCE  WHO   DATE     DESCRIPTION                            *\n.*              RRS   1985     CHANGE RECORD TYPE FORM 230 TO 240     *\n.*              PTW   1986     ADDED SUBTYPES                         *\n.*              CJP    4/ 8/87 ADDED SUBTYPE 4, DOCUMENTED SUBTYPE 1  *\n.*              CJP    1/20/88 ADDED SYMBOL AT START OF AREA FOR      *\n.*                             DSECT=NO                               *\n.*                                                                    *\n.**********************************************************************\n.*\n         AIF   ('&DSECT' EQ 'NO').SM240A\nSM240BLK DSECT ,                   DESCRIBE SMF 240 HEADER AND SUBTYPE\n         AGO   .SM240C\n.SM240A  ANOP\nSM240BLK DS    0F\n.SM240C  ANOP\n.*\nSM240MLN EQU   4095                MAXIMUM LENGTH OF WHOLE RECORD\n&SMF240N DS    0H\nSM240LEN DS    H                   RDW\nSM240SEG DS    H                   RDW\nSM240FLG DS    XL1                 SYSTEM INDICATOR\nSM240RTY DS    XL1                 RECORD TYPE MUST BE 240\nSM240TME DS    XL4                 TIME RECORD MOVED TO BUFFER\nSM240DTE DS    XL4                 DATE IN PACKED DECIMAL\nSM240SID DS    CL4                 SYSTEM ID\nSM240RST DS    XL4                 TIME AND DATE READER RECOGNIZED\nSM240RSD DS    XL4                     JOB CARD FOR THIS JOB\nSM240ULN DS    H                   PRC USER RECORD LENGTH\nSM240TYP DS    H                   PRC USER RECORD SUBTYPE\nSM240USE DS    0X                  PRC USER RECORD AREA START\nSM240HLN EQU   *-SM240BLK          COMMON HEADER LENGTH\n.*\n         AIF   ('&SUBTYPE' EQ '1').DOSTYP1\n         AIF   ('&SUBTYPE' EQ '2').DOSTYP2\n         AIF   ('&SUBTYPE' EQ '3').DOSTYP3\n         AIF   ('&SUBTYPE' EQ '4').DOSTYP4\n         AGO   .MEND\n.*\n.*             TYPE 1 RECORDS (USPTO SMS)\n.*\n.DOSTYP1 ANOP\n         ORG   SM240USE\nS2401    DS    0F                 START OF SUBTYPE 1 RECORD\nS2401DLN EQU   SM240MLN-(*-SM240BLK)  MAXIMUM LENGTH OF VARIABLE DATA\nS2401DAT DS    XL(S2401DLN)       VARIABLE DATA\nS2401LEN EQU   *-SM240BLK         MAXIMUM LENGTH OF SUBTYPE 1\n         AGO   .MEND\n.*\n.*             TYPE 2 RECORDS (VTAM/TCAM SESSION)\n.*\n.DOSTYP2 ANOP\n         ORG   SM240USE\nS2402    DS    0F                  START OF SUBTYPE 2 RECORD\nS2402TRN DS    XL2                 NUMBER OF TRIPLETS THAT FOLLOW\nS2402TR# EQU   8\n         DS    XL2                 RESERVED\nS2402LVO DS    XL4                 OFFSET SOFTWARE LVL SECT (WITH RDW)\nS2402LVL DS    XL2                 LENGTH SOFTWARE\nS2402LV# DS    XL2                 NUMBER SOFTWARE\nS2402ACO DS    XL4                 OFFSET ACCOUNTING SECTION (WITH RDW)\nS2402ACL DS    XL2                 LENGTH ACCOUNTING\nS2402AC# DS    XL2                 NUMBER ACCOUNTING\n*              FOLLOWING TRIPLETS RESERVED FOR FUTURE USE\nS2402SEO DS    XL4                 OFFSET SESSION SECTION (WITH RDW)\nS2402SEL DS    XL2                 LENGTH SESSION\nS2402SE# DS    XL2                 NUMBER SESSION\nS2402EVO DS    XL4                 OFFSET EVL\nS2402EVL DS    XL2                 LENGTH EVL\nS2402EV# DS    XL2                 NUMBER EVL\nS2402PRO DS    XL4                 OFFSET PRV\nS2402PRL DS    XL2                 LENGTH PRV\nS2402PR# DS    XL2                 NUMBER PRV\nS2402SRO DS    XL4                 OFFSET SRV\nS2402SRL DS    XL2                 LENGTH SRV\nS2402SR# DS    XL2                 NUMBER SRV\nS2402OGO DS    XL4                 OFFSET OGV\nS2402OGL DS    XL2                 LENGTH OGV\nS2402OG# DS    XL2                 NUMBER OGV\nS2402DGO DS    XL4                 OFFSET DGV\nS2402DGL DS    XL2                 LENGTH DGV\nS2402DL# DS    XL2                 NUMBER DGV\nS2402TLN EQU   *-S2402TRN          LENGTH OF TRIPLET SECTION\nS2402DAT EQU   *                   VARIABLE DATA\n         SPACE\nS2402LEV EQU   *                   SOFTWARE LEVEL SECTION MAP\nS2402LAM DS    X                   ACCESS METHOD\nS2402LAV EQU   X'01'               VTAM\nS2402LAT EQU   X'02'               TCAM\nS2402LVR DS    X                   VERSION/RELEASE\nS2402LMD DS    X                   OUR RECORD LEVEL\n         DS    X                   RESERVED\nS2402LLN EQU   *-S2402LEV\n         SPACE\nS2402ACT EQU   *                   SOFTWARE LEVEL SECTION MAP\nS2402ATM DS    XL8                 TIME, DATE EXIT ENTERED\nS2402ATY DS    X                   TYPE OF RECORD (SESSION START/END)\nS2402ATS EQU   X'01'               START\nS2402ATE EQU   X'02'               END\n         DS    X                   RESERVED\nS2402APL DS    CL8                 PRIMARY LUNAME\nS2402ASL DS    CL8                 SECONDARY LUNAME (VTAM ONLY)\nS2402AMJ DS    CL8                 ACCESS METHOD JOBNAME\nS2402AAJ DS    CL8                 APPLICATION JOBNAME (TCAM ONLY)\nS2402ALN EQU   *-S2402ACT          LENGTH\nS2402LEN EQU   *-SM240BLK          LENGTH OF SUBTYPE 2 RECORD\n         AGO   .MEND\n.*\n.*             TYPE 3 RECORDS (MESSENGER STATS)\n.*\n.DOSTYP3 ANOP\n         ORG   SM240USE\nS2403    DS    0F                  START OF SUBTYPE 3 RECORD\nS2403TYP DS    FL4                 CAS SUBTYPE CODE\nS2403RS1 DS    FL4                 RESERVED - SET TO 0\nS2403DLN EQU   SM240MLN-(*-SM240BLK)  MAXIMUM LENGTH OF VARIABLE DATA\nS2403DAT DS    XL(S2403DLN)        VARIABLE ARBITRARY LENGTH DATA\nS2403LEN EQU   *-SM240BLK          LENGTH OF SUBTYPE 3 RECORD\n         AGO   .MEND\n.*\n.*             TYPE 4 RECORDS (ACF2 SHARED LOGON ID USE)\n.*\n.DOSTYP4 ANOP\n         ORG   SM240USE\nS2404    DS    0F                  START OF SUBTYPE 4 RECORD\nS2404SLI DS    CL8                 SHARED LOGON ID BEING USED\nS2404RLI DS    CL8                 REAL LOGON ID OF USER\nS2404TRM DS    CL8                 TERMINAL USED\nS2404DLN EQU   *-SM240USE          LENGTH OF SUBTYPE 4 FIELDS\nS2404LEN EQU   *-SM240BLK          LENGTH OF SUBTYPE 4 RECORD\n         AGO   .MEND\n.*\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SPY": {"ttr": 9477, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x05@\\x05@\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 1344, "newlines": 1344, "modlines": 0, "user": "FILE369"}, "text": "PRC      TITLE 'S P Y --  MVS CONSOLE SPY PROGRAM  --  VERSION 3.1'\n********************************************************************\n*                                                                  *\n*                              S P Y                               *\n*                                                                  *\n*                            02/26/82                              *\n*                                                                  *\n*                    OPERATOR CONSOLE MONITOR                      *\n*                                                                  *\n*  THIS PROGRAM DISPLAYS THE CONTENTS OF ALL ACTIVE GRAPHIC        *\n*  OPERATOR'S CONSOLES ON A TSO CRT. THE OPERATOR'S SCREEN CAN BE  *\n*  EITHER A 327X OR A 370-168 INTEGRATED CONSOLE WITH 35 LINES.    *\n*  THE TSO USER CAN USE ANY 327X TERMINAL.                         *\n*                                                                  *\n*  SPY MUST, ALAS, BE APF AUTHORIZED. THE OPERATOR CONSOLE BUFFERS *\n*  AND CONTROL BLOCKS ARE NOW IN FETCH PROTECTED STORAGE. BE       *\n*  SURE TO PLACE THE 'SPY' COMMAND IN IKJEFTE2 AND/OR IKJEFTE8     *\n*  SO THAT IT WILL RETAIN APF AUTHORIZATION FROM TSO.              *\n*                                                                  *\n*  SPY GIVES A TSO USER THE CAPABILITY TO ENTER ANY                *\n*  CONSOLE OPERATOR COMMAND. THIS FACILITY IN PROTECTED BY A       *\n*  SIMPLE 3 CHARACTER PASSWORD (IN VIPWORD) TO PREVENT YOU         *\n*  FROM ENTERING AN OPERATOR COMMAND BY ACCIDENT. THE SYNTAX IS    *\n*                                                                  *\n*  JES COMMAND:  $...  ANY JES COMMAND ...                         *\n*  OS COMMAND:   /...  ANY OS COMMAND ...  (THE / IS STRIPPED OFF) *\n*                                                                  *\n*  TYPING THE 3-LETTER VIP PASSWORD 'TOGGLES' THE VIP FLAG.        *\n*  THIS FACILITY WORKS BY PASSING THE COMMAND TO THE COMMAND       *\n*  PROGRAM AS A PARM, WHO IN TURN EXECUTES IT USING SVC 34.        *\n*  SPY,COMMAND AND LINK MUST ALL BE APF AUTHORIZED IF THEY ARE     *\n*  TO WORK PROPERLY IN CONCERT. NOTE THAT THE RESPONSE TO THE      *\n*  COMMAND APPEARS ONLY ON THE SCREEN YOU ARE WATCHING AT THE      *\n*  TIME. ALSO, YOUR COMMANDS HAVE THE SAME CONSOLE AUTHORITY       *\n*  AS THE SCREEN YOU ARE WATCHING, INCLUDING THE MASTER CONSOLE!   *\n*  THE MORAL BEING DON'T WATCH THE MASTER CONSOLE AND ACCIDENTALLY *\n*  ENTER '/Q' OR SOMETHING LIKE THAT...                            *\n*                                                                  *\n*  THIS PROGRAM WILL PROBABLY REQUIRE BOTH THE SYS1.AMODGEN AND    *\n*  SYS1.APVTMACS MACRO LIBRARIES TO ASSEMBLE PROPERLY.             *\n*  SPY WAS DEVELOPED ON A 370/168 MVS RELEASE 3.7; IT WILL WORK    *\n*  ON MVS 3.8 WITH OR WITHOUT SE/2.                                *\n*                                                                  *\n*                     STEVE LANGLEY                                *\n*                     SOUTHERN CALIF. EDISON                       *\n*                     ROSEMEAD, CALIF   91770                      *\n*                     213-572-3435                                 *\n*                                                                  *\n*                                                                  *\n********************************************************************\n********************************************************************\n*                                                                  *\n*                                                                  *\n*  COMMAND     DESCRIPTION                                         *\n*                                                                  *\n*     B        END SPY                                             *\n*     C        SWITCH MONITOR TO CONSOLE 1                         *\n*     CXX      SWITCH MONITOR TO CONSOLE XX                        *\n*     DXX      SET DELAY TO XX TENTHS SECONDS                      *\n*     E        END SPY                                             *\n*     F        FREEZE DISPLAY ON CURRENT PAGE                      *\n*     R        RELEASE DISPLAY                                     *\n*     S        STATUS OF ALL CONSOLES                              *\n*     W        START TIMER MODE FOR 30 SECONDS                     *\n*     WXX      START TIMER MODE FOR XX SECONDS                     *\n*     W0       START TIMER MODE UNTIL INTERRUPT                    *\n*     ?        DISPLAY THIS PAGE                                   *\n*     1        DISPLAY MODE 1                                      *\n*     2        DISPLAY MODE 2                                      *\n*                                                                  *\n*  HITTING INTERRUPT WILL STOP THE WAIT TIMER                      *\n*                                                                  *\n*     DISPLAY MODES 1 AND 2 ARE ONLY USEFUL WHEN WATCHING A LARGE  *\n*     35-LINE 3066 370-168 INTEGRATED CONSOLE FROM A 24-LINE 327X-2*\n*     TSO TERMINAL. THESE MODES ARE:                               *\n*                                                                  *\n*     DISPLAY MODE 1 - PAGE 1 = TOP 22 LINES                       *\n*                      PAGE 2 = BOTTOM 12 LINES                    *\n*     DISPLAY MODE 2 - PAGE 1 = TOP 22 LINES                       *\n*                      PAGE 2 = BOTTOM 22 LINES                    *\n*                                                                  *\n*  LOG -                                                           *\n*    05/00/85 PTW L01 IMPLEMENT AT PRC                             *L01\n*    02/01/88 PTW L02 FIX FOR MVS/SP2.1.7 CONASID SET TO 7         *L02\n*    09/28/88 PTW L03 MOD3 SUPPORT, DYNAMIC CONASID, ETC.          *L03\n*                                                                  *\n*                                                                  *\n********************************************************************\n         PRINT NOGEN                                                L03\nSPY      CSECT\n         USING SPY,R15                                              RGR\n         B     AROUND             BRANCH AROUND DATA AREAS\n         DC    CL9'SPY'           IDENTIFIER\n         DC    CL9'&SYSDATE'\n         DC    CL7'&SYSTIME'\n         DC    CL11'VERSION 3.1'\nSAVEADDR DC    A(SAVE)                                              RGR\nAROUND   STM   R14,R12,12(R13)    SAVE REGISTERS                    RGR\n         LR    R12,R15            R12 = ADDR OF ENTRY POINT\n         L     R11,SAVEADDR       R11 = ADDR OF OUR SAVE AREA       RGR\n         ST    R13,4(R11)         SAVE POINTER TO CALLERS SAVE AREA RGR\n         ST    R11,8(R13)         SAVE PTR TO OUR SAVE AREA IN CALLER'S\n         LR    R13,R11            R13 = ADDR OF OUR SAVE AREA\n         USING SAVE,R13           R13 = THIRD BASE REGISTER         RGR\n         LA    R11,4095(R12)      R11 WILL BE\n         LA    R11,1(R11)         SECOND BASE REGISTER\n         DROP  R15                                                  RGR\n         USING SPY,R12,R11        ADDRESABILITY TO CSECT            RGR\n         L     R1,8(R1)           ACCESS PSCB THROUGH CPPL          RGR\n         TM    X'10'(R1),X'80'    IS HE OPER PRIVILEGED?            RGR\n         BNO   DONE0                                                RGR\n********************************************************************\n*                                                                  *\n*                       PROGRAM INITIALIZATION                     *\n*                                                                  *\n********************************************************************\n         BAL   R14,INITSCAN       INITIALIZE IKJSCAN PARMLIST\n         L     R2,PSAAOLD-PSA     FIND THE JOBNAME.                 L03\n         L     R2,ASCBJBNS-ASCB(,R2)                                L03\n         MVC   WTOUSER,0(R2)                                        L03\n         L     R2,CVTPTR          FIND THE SYSTEM ID.               L03\n         L     R3,CVTSMCA-CVT(,R2)                                  L03\n         MVC   OURSID,SMCASID-SMCABASE(R3)                          L03\n         L     R3,CVTCUCB-CVT(,R2)                                  L03\n         MVC   CONASID,UCMCTID-UCM(R3)                              L03\n         GTSIZE ,                 GET SCREEN SIZE\n         LTR   R0,R0              R0 = NUMBER OF LINES PER SCREEN\n         BZ    HARDCOPY           IF NONZERO ASSUME A CRT IS IN USE\n********************************************************************\n*                                                                  *\n*                       THIS TERMINAL IS A CRT                     *\n*                                                                  *\n********************************************************************\nCRT      STH   R0,LPSCREEN        R0 = LINES PER SCREEN\n         STH   R1,CPLINE          R1 = CHARACTERS PER LINE\n         CH    R0,=H'43'          IS USER ON A 3277?                L02\n         BNE   FLSCREEN           YES, JUST CONTINUE                L02\n         MVI   MOD4FLG,X'FF'      SET 3278-4 FLAG ON\n         MVC   CMDCTRL(3),R41C1   ROW 41, COL 1\n         MVC   PHEADING(3),R42C1  ROW 42, COL 1\n         MVC   R24C1(3),R43C1     ROW 43, COL 1\nFLSCREEN DS    0H\n         STFSMODE ON,INITIAL=YES  TURN ON VTAM FULL SCREEN MODE\n         LA    R3,STAXLIST        R3 = ADDRESS OF STAX LIST MACRO\n         STAX  ATTNEXIT,MF=(E,(3)) ATTN EXIT TRAP\nSKPTST3  EQU   *\n         B     BLDUCMS\n********************************************************************\n*                                                                  *\n*                    THIS TERMINAL IS A HARDCOPY                   *\n*                                                                  *\n********************************************************************\nHARDCOPY STSIZE SIZE=80           OTHERWISE, HARDCOPY; SET LSIZE=80\n         MVI   CRTFLAG,X'00'      WE ARE USING A HARDCOPY\n         MVC   CMDCTRL(6),BLANKS  ZAP OUT 327X CNTRL CHARS\n         MVC   PHEADING(6),BLANKS ZAP OUT 327X CNTRL CHARS\n         MVC   HELP(14),BLANKS    ZAP OUT 327X CNTRL CHARS\n         MVC   HELP2(14),BLANKS   ZAP OUT 327X CNTRL CHARS          RGR\n********************************************************************\n*                                                                  *\n*          BUILD A TABLE OF UCM ADDRESSES (ONE PER CONSOLE)        *\n*                                                                  *\n********************************************************************\nBLDUCMS  L     R4,CVTPTR          R4 = ADDR OF CVT\n         USING CVT,R4\n         L     R4,CVTCUCB         R4 = ADDR OF 'CUCB' (UCM BASE)\n         DROP  R4\n         USING UCM,R4\n         LR    R2,R4              R2 = R4\n         S     R2,=F'4'           R2 = ADDR OF ADDR OF UCM PREFIX\n         L     R2,0(R2)           R2 = ADDR OF UCM PREFIX\n         USING UCMPRFX,R2\n         L     R5,UCMVEA          R5 = ADDR OF FIRST UCM ENTRY\n         L     R6,UCMVEZ          R6 = LENGTH OF EACH UCM ENTRY\n         L     R7,UCMVEL          R7 = ADDR OF LAST UCM ENTRY\n         LA    R8,UCMTAB+16       R8 = ADDR OF UCMTAB\n         L     R9,UCMTABE         R9 = ADDR OF END OF UCMTAB\n         XR    R10,R10            R10 = 0 (NUMBER OF VALID UCMS)\nUCMLOOP  ST    R5,0(R8)           SAVE UCM ADDRESS IN UCMTAB\n         LA    R10,1(R10)         R10 = R10 + 1  (ONE MORE UCM)\n         C     R5,UCMMCENT        IS THIS UCM THE MASTER CONSOLE UCM?\n         BNE   UCMNEXT            NO;  GO LOOK AT NEXT UCM ENTRY\n         ST    R10,CONSOLE        YES; LOOK AT THIS ONE FIRST\nUCMNEXT  LA    R8,16(R8)          R8 = ADDR OF NEXT UCMTAB ENTRY\n         CR    R8,R9              DOES R8 POINT PAST END OF UCMTAB?\n         BNL   UCMFULL            YES; LEAVE LOOP\n         AR    R5,R6              R5 = ADDR OF NEXT UCM ENTRY\n         CR    R5,R7              DOES R5 POINT PAST UCM ENTRIES?\n         BNH   UCMLOOP            NO; KEEP GOING                    L02\n         B     UCMDONE            YES; TABLE COMPLETE\nUCMFULL  MVC   ERROR(27),ERRMSG5  UCM TABLE TOO SMALL\n         MVI   EFLAG,X'FF'        SET ERROR FLAG                    RGR\nUCMDONE  STH   R10,NUMUCMS        SAVE NUMBER OF UCMS FOUND\n         DROP  R2,R4\n********************************************************************\n*                                                                  *\n*         HERE WE GO... USE MODESET TO PUT US IN KEY 0             *\n*                                                                  *\n********************************************************************\nSETAUTH  DS    0H                                                   SP3\n         MODESET MODE=SUP                                           SP3\n         ESAR  R5                   GET SEC ASID                    SP3\n         ST    R5,SASID             KEEP IT                         SP3\n         AXSET AX=ONE               SET AX TO ALLOW SSAR            SP3\n         GETMAIN R,LV=820           GETMAIN AREA FOR TDCM           SP3\n         ST    R1,LOCDCM            SAVE THE ADDRESS                SP3\nSKPTST4  EQU   *\n********************************************************************\n*                                                                  *\n*                            TOP OF LOOP                           *\n*              LOCATE SCREEN BUFFER AND PREPARE TO TPUT            *\n*                                                                  *\n********************************************************************\nNEXTPAGE CLI   ATTNFLG,X'00'      WAS ATTN HIT?\n         BE    NOATTN             NO\n*                                 ATTENTION KEY HIT; PROCESS IT\n         MVI   ATTNFLG,X'00'      YES, RESET FLAG\n         MVC   TIME(3),BLANKS     BLANK OUT TIMER FIELD\n         MVI   WAITFLG,X'00'      TURN OFF WAIT FLAG\n         XC    TIMER,TIMER        SET TIMER TO 0\nNOATTN   EQU   *\n         LA    R5,UCMTAB          R5 = ADDR OF UCMTAB\n         L     R4,CONSOLE         R4 = CONSOLE TO BE DISPLAYED\n         LTR   R4,R4              IS NUMBER = 0                     RGR\n         BZ    NOCONSOL           YES, NO GOOD                      RGR\n         CH    R4,NUMUCMS         IS NUMBER TOO HIGH?\n         BNH   GETUCM             NO, CONTINUE\nNOCONSOL MVC   ERROR(27),ERRMSG1  CONSOLE NUMBER INVALID            RGR\n         MVI   EFLAG,X'FF'        SET ERROR FLAG                    RGR\nRESETCN1 L     R4,OLDCONS         RESET TO OLD CONSOLE\n         ST    R4,CONSOLE         AND SAVE IT\n         B     NEXTPAGE           AND GO BACK THROUGH LOOP          RGR\nGETUCM   SLL   R4,4               MULTIPLY BY 16\n         LA    R5,0(R5,R4)        R5 = ADDR OF ADDR OF UCM\n         LR    R1,R5              R1 = ADDR OF UCMTAB ENTRY\n         L     R5,0(R5)           R5 = ADDR OF UCM\n         USING UCMLIST,R5\n         L     R6,UCMXB           R6 = ADDR OF RDCM\n         USING DCMTSRT,R6\n         LTR   R6,R6              IS THIS A GRAPHICS CONSOLE?\n         BP    GRAPHICS           YES\n********************************************************************\n*                                                                  *\n*       THIS IS NOT AN OPERATOR GRAPHIC CONSOLE - GIVE ERRMSG4     *\n*                                                                  *\n********************************************************************\n         LA    R5,UCMTAB          R5 = ADDR OF UCMTAB\n         MVC   ERROR(27),ERRMSG4  NON-GRAPHIC CONSOLE\n         MVI   EFLAG,X'FF'        SET ERROR FLAG                    RGR\n         B     RESETCN1           RESET THE CONSOLE NUMBER\n********************************************************************\n*                                                                  *\n*   THIS IS A GRAPHIC CONSOLE - BUILD TRAILER LINE WITH CONSDATA   *\n*                                                                  *\n********************************************************************\nGRAPHICS EQU   *\n         BAL   R14,CONSDATA       CALL CONSDATA RTN\n*       SETUP TO COPY PAGEABLE DCM TO OUR ADDRESS SPACE             SP3\n         L     R5,DCMADTRN        ADDR OF TDCM - 'FROM' FOR MVCP    SP3\n         LH    R7,CONASID         GET 'CONSOLE' ASID                L03\n         SSAR  R7                 SET CONSOLE AS SECONDARY          SP3\n         L     R7,LOCDCM          'TO' ADDR FOR MVCP                SP3\n         LA    R3,820             LENGTH TO MOVE                    SP3\n         SR    R15,R15            'FROM' KEY                        SP3\nMOVEDCM  MVCP  0(R3,R7),0(R5),R15  MOVE IT                          SP3\n         BZ    DCMMOVED                                             SP3\n         LA    R5,256(R5)         BUMP 'FROM' ADDR                  SP3\n         LA    R7,256(R7)         BUMP 'TO' ADDR                    SP3\n         SH    R3,=H'256'         DECREMENT TRUE LENGTH             SP3\n         B     MOVEDCM            GO GET THE REST                   SP3\nDCMMOVED L     R5,SASID           RESTORE PREVIOUS SECONDARY -      SP3\n         SSAR  R5                 SHOULD BE SAME AS PRIMARY         SP3\n         L     R7,LOCDCM          ADDR OF OUR COPY                  SP3\n         USING DCMSTRT,R7\n********************************************************************\n*                                                                  *\n*    FILLIN OPERATORS COMMAND INPUT BUFFER AND SET VIP FLAG INDICR *\n*                                                                  *\n********************************************************************\n         MVC   LASTLINE(79),DCMINPUT MOVE IN INPUT BUFFER LINE\n         MVI   MODE+1,C' '        BLANK OUT VIP INDICATOR\n         CLI   VIPFLG,X'FF'       IS THE VIP FLAG ON?\n         BNE   CHKINTEG           NOPE\n         MVI   MODE+1,C'*'        TURN ON VIP INDICATOR\n********************************************************************\n*                                                                  *\n*                         CHECK CONSOLE TYPE                       *\n*                                                                  *\n********************************************************************\nCHKINTEG MVI   INTEGFLG,X'FF'     TURN ON 3066 CONSOLE FLAG\n         CLC   DCMMSGAL(2),=H'30' IS THIS REALLY A 3066 CONSOLE?\n         BE    CHKMODEL           YES; CHK IF IT WILL FIT ON OUR TERM\n         MVI   INTEGFLG,X'00'     NO; TURN OFF 3066 CONSOLE FLAG\n*        CLC   DCMMSGAL(2),=H'20' IS THIS 327X-2 TYPE CONSOLE?      AEI\n*        BNE   NOTSUPRT           NO;  NOT SUPPORTED, SO ABEND      AEI\n         MVI   FREEZE,C'F'        YES; FREEZE DISPLAY\n         MVI   PAGE,C'1'               ON PAGE 1 OF USER'S CRT\n         MVC   TPUTLEN(4),MOD2TPUT\n         B     MOD2               AND TREAT USER AS MOD2 FOR NOW\n********************************************************************\n*                                                                  *\n*        THIS OPERATOR'S CONSOLE IS NEITHER A 24-LINE 327X-2 NOR   *\n*        A 35-LINE 3066 270-168 INTEGRATED CONSOLE, SO ABEND.      *\n*                                                                  *\n********************************************************************\nNOTSUPRT LA    R1,ERRMSG6         R1 = ADDR OF STRING TO TPUT\n         LA    R0,26              R0 = LENGTH OF TPUT\n         BAL   R14,TERMPUT        DO A TPUT\n         ABEND 999\n********************************************************************\n*                                                                  *\n*     THIS IS A 35-LINE 3066 OPERATORS CONSOLE. IF THE USER HAS A  *\n*     43-LINE 3278-4 THERE IS NO PROBLEM, THE WHOLE THING CAN BE   *\n*     DISPLAYED AT ONCE. HOWEVER, IF THE USER HAS A 24-LINE 327X-2 *\n*     WE WILL HAVE TO BREAK THE DISPLAY INTO 2 PAGES SO IT WILL FIT*\n*                                                                  *\n********************************************************************\nCHKMODEL CLI   MOD4FLG,X'FF'      IS THIS A 3278-4? (43 LINES)\n         BNE   MOD2               NO - MUST BE A MOD2 (24 LINES)\n********************************************************************\n*                                                                  *\n*                  USER HAS A 43-LINE 3278-4 CRT                   *\n*                                                                  *\n*        WE CAN JUST FREEZE HIS DISPLAY ON 'PAGE 1' AND CONTINUE   *\n*                                                                  *\n********************************************************************\n         MVI   FREEZE,C'F'        FREEZE DISPLAY\n         MVI   PAGE,C'1'          ON PAGE 1 INITIALLY\n         MVC   TPUTLEN(4),MOD4TPUT SET LENGTH FOR FULL 3278-4 SCREEN\n         L     R8,DCMASCRN        R8 = ADDR OF SCREEN BUFFER + 6    RGR\n         BCTR  R8,0\n         BCTR  R8,0\n         BCTR  R8,0\n         LA    R4,BUF             R4 = ADDR OF OUTPUT BUFFER\n         LA    R5,M4BUFLEN        R5 = 3278-4 BUFFER LEN (35 LINES)\n         LA    R9,M4BUFLEN        R9 = 3278-4 BUFFER LEN (35 LINES)\n         B     MOVEBUFF\n********************************************************************\n*                                                                  *\n*                  USER HAS A 24-LINE 327X-2 CRT                   *\n*                                                                  *\n*        THIS OPER CONSOLE WILL HAVE TO BE DISPLAYED IN TWO SEGMENT*\n*        OR 'PAGES' SINCE 35 LINES WON'T FIT IN THIS 24 LINE TUBE. *\n*                                                                  *\n********************************************************************\nMOD2     CLI   PAGE,C'1'          ARE WE ON PAGE 1?\n         BNE   ONTWO              NO, SO WE MUST BE ON 2\n         CLI   FREEZE,C'F'        ARE WE FROZEN ON PAGE 1?\n         BNE   PAGE2              NO, SO DISPLAY PAGE 2\n         B     PAGE1              YES, SO DISPLAY PAGE 1\nONTWO    CLI   FREEZE,C'F'        ARE WE FROZEN ON PAGE 2?\n         BE    PAGE2              YES, SO DISPLAY PAGE 2\nPAGE1    MVI   PAGE,C'1'          PAGE = 1\n         L     R8,DCMASCRN        R8 = ADDR OF SCREEN IMAGE + 6     RGR\n         BCTR  R8,0\n         BCTR  R8,0\n         BCTR  R8,0\n         LA    R4,BUF             R4 = ADDR OF OUTPUT BUFFER\n         LA    R5,M2BUFLEN        R5 = LENGTH OF OUTPUT BUF (21 LINES)\n         LA    R9,M2BUFLEN        R9 = CONSOLE BUFFER LEN   (21 LINES)\n         B     MVETRAIL           GO MOVE THE BUFFER\nPAGE2    MVI   PAGE,C'2'          PAGE = 2\n         L     R8,DCMASCRN        R8 = ADDR OF SCREEN IMAGE + 6     RGR\n         BCTR  R8,0\n         BCTR  R8,0\n         BCTR  R8,0\n         CLI   MODE,C'2'          ARE WE IN DISPLAY MODE 2?\n         BE    DMODE2             YES, BRANCH TO DMODE2\nDMODE1   LA    R8,LEN22(R8)       MOVE POINTER DOWN 23 LINES\n         LA    R9,LEN13           R9 = LENGTH OF LAST 12 LINES\n         B     CONTINUE           JUMP AROUND MODE 2 DISPLAY\nDMODE2   LA    R8,LEN9(R8)        MOVE POINTER DOWN 9 LINES\n         LA    R9,LEN21           R9 = LENGTH OF SOURCE BUFFER\nCONTINUE LA    R4,BUF             R4 = ADDR OF OUTPUT BUFFER\n         LA    R5,M2BUFLEN        R5 = LENGTH OF OUTPUT BUFFER\nMVETRAIL MVC   ENDMOD2(TRAILEN),CMDCTRL MOVE IN TRAILER\n********************************************************************\n*                                                                  *\n*               MOVE THE SCREEN IMAGE BUFFER INTO BUF              *\n*                                                                  *\n********************************************************************\nMOVEBUFF STM   R4,R9,MOVEBSAV     KEEP REGS                         SP3\n*        SETUP TO COPY CONSOLE BUFFER TO OUR ADDRESS SPACE.         SP3\n*        FIRST FILL AREA WITH SPACES                                SP3\n         L     R9,=X'40000000'    MAKE BLANK THE PAD, LENGTH =0     SP3\n         LA    R8,*               NOT THAT IT REALLY MATTERS        SP3\n         MVCL  R4,R8              PAD WITH SPACES                   SP3\n         LH    R4,CONASID         GET 'CONSOLE' ASID                L03\n         SSAR  R4                 SET 'CONSOLE' AS SECONDARY        SP3\n         LM    R4,R9,MOVEBSAV     GET BACK ADDRESSES, LENGTHS       SP3\n         SR    R15,R15            'FROM' KEY                        SP3\nMOVEBFR  MVCP  0(R9,R4),0(R8),R15 MOVE IT                           SP3\n         BZ    BFRMOVED           GET OUT WHEN ALL MOVED            SP3\n         LA    R8,256(R8)         BUMP FROM ADDR                    SP3\n         LA    R4,256(R4)         BUMP TO ADDR                      SP3\n         SH    R9,=H'256'         DECREMENT TRUE LENGTH             SP3\n         B     MOVEBFR            GET THE REST                      SP3\nBFRMOVED L     R4,SASID           RESTORE PREVIOUS SECONDARY -      SP3\n         SSAR  R4                 SHOULD BE SAME AS PRIMARY.        SP3\n         DROP  R5,R6,R7\nWCNTL    DS    0H\n         CLI   CRTFLAG,X'FF'      IS THIS A CRT?\n         BE    TPUTCRT            YES\n********************************************************************\n*                                                                  *\n*             USER HAS A LINE-AT-A-TIME HARDCOPY TERMINAL          *\n*                                                                  *\n********************************************************************\n         XR    R8,R8              R8 = COUNTER = 0\n         LA    R1,BUF             SET POINTER TO FIRST LINE OF BUFFER\n         ICM   R1,8,EDITFLG       EDIT MODE\n         L     R0,=F'78'          R0 LENGTH OF OUTPUT LINE\nNEXTL    LR    R3,R1              SAVE R1 SINCE TPUT ZAPS IT\n         BAL   R14,TERMPUT        PRINT ONE LINE ON HARDCOPY\n         LA    R8,1(R8)           ADD 1 TO COUNTER\n         C     R8,=F'21'          HAVE WE PRINTED LAST LINE?\n         BE    DOLAST2            YES, CONTINUE\n         LA    R1,80(R3)          NOPE, POINT TO NEXT LINE\n         CLI   INTEGFLG,X'FF'     IS THIS AN INTEGRATED CONSOLE?\n         BE    NOT3270            YES\n         MVC   0(5,R1),BLANKS     BLANK OUT 3270 CTRL CHARS\n         LA    R1,4(R1)           ADD 4 EXTRA BYTES TO SKIP CTRL CHARS\nNOT3270  L     R0,=F'78'          LOAD LENGTH OF LINE\n         ICM   R1,8,EDITFLG       EDIT MODE\n         B     NEXTL              PRINT NEXT LINE\nDOLAST2  LA    R1,LASTLINE        R1 = ADDR OF STRING TO TPUT\n         LA    R0,79              R0 = LENGTH OF TPUT\n         BAL   R14,TERMPUT        DO A TPUT\n         LA    R1,HEADING         R1 = ADDR OF STRING TO TPUT\n         LA    R0,79              R0 = LENGTH OF TPUT\n         BAL   R14,TERMPUT        DO A TPUT\n         LA    R1,USERLINE        R1 = ADDR OF STRING TO TPUT\n         LA    R0,79              R0 = LENGTH OF TPUT\n         BAL   R14,TERMPUT        DO A TPUT\n         B     CHKWAIT            GO CHECK THE WAIT TIMER\n********************************************************************\n*                                                                  *\n*               DISPLAY THE OPERATOR'S SCREEN ON A 327X            *\n*                                                                  *\n********************************************************************\nTPUTCRT  LA    R1,CLEAR           R1 = ADDR OF OUTPUT STREAM\n         L     R0,TPUTLEN         R0 = LENGTH OF TPUT\n         L     R7,LOCDCM          ADDR OF OUR COPY                  L02\n         USING DCMSTRT,R7                                           L02\n         CLC   DCMMSGAL(2),=H'16' IS THIS 4341 3278-2A?             L02\n         BH    NOT2A              NO; BYPASS NEXT                   L02\n         MVC   BUF+17*84(84),=CL84' '\n         MVC   BUF+18*84(84),=CL84' '\n         MVC   BUF+19*84(84),=CL84' '\n         MVC   BUF+20*84(84),=CL84' '\n         MVC   BUF+21*84(84),=CL84' '\n         MVC   BUF+17*84(3),=X'11D550'\nNOT2A    DS    0H                                                   L02\n         CLC   DCMMSGAL(2),=H'20' IS THIS 3278-2?                   L02\n         BNE   *+10                                                 L02\n         MVC   BUF+21*84(84),=CL84' ' CLEAN UP CMD INPUT AREA       L02\n         ICM   R1,8,FULLSCR       SET ASIS TYPE FOR TPUT\n         BAL   R14,TERMPUT        DO A TPUT; DISPLAY ENTIRE SCREEN\n         DROP  R7                                                   L02\n********************************************************************\n*                                                                  *\n*      IF WE ARE IN WAIT MODE SO A STIMER FOR THE NECESSARY LENGTH *\n*      OF TIME, THEN CALCULATE AND DISPLAY THE NEW TIMER COUNT.    *\n*      IF COUNT HAS HIT ZERO, TURN OFF WAIT FLAG.                  *\n*                                                                  *\n********************************************************************\nCHKWAIT  MVC   ERROR(66),BLANKS   BLANK OUT ERROR FIELD\n         CLI   WAITFLG,X'FF'      IS THE WAIT FLAG ON?\n         BNE   READCHAR           NO, SO GO GET A COMMAND\n         STIMER WAIT,BINTVL=DELAY WAIT FOR DELAY * .01 SECONDS\n         L     R2,TIMER           R2 = CURRENT VALUE OF TIMER\n         BCTR  R2,0               TIMER = TIMER - 1\n         ST    R2,TIMER           STORE NEW VALUE OF TIMER\n         CVD   R2,WORK            CONVERT TO DECIMAL.\n         MVC   SCRATCH(4),PATTERN MOVE IN EDIT PATTERN\n         ED    SCRATCH(4),WORK+6  EDIT IN CONSOLE NUMBER\n         MVC   TIME(3),SCRATCH+1  MOVE TIME LEFT INTO PLACE\n         LTR   R2,R2              HAS TIMER HIT ZERO?\n         BNZ   NEXTPAGE           NO, CONTINUE TO COUNT\n         MVC   TIME(3),BLANKS     CLEAR COUNTER FIELD\n         XI    WAITFLG,X'FF'      TOGGLE WAIT FLAG OFF\n         B     NEXTPAGE           AND GO ON AS IF NOTHING HAPPENED..\n********************************************************************\n*                                                                  *\n*                       READ COMMAND FROM USER                     *\n*                                                                  *\n********************************************************************\nREADCHAR DS    0H                                                   RGR\n         XC    REPLY0(06),REPLY0  CLEAR THE INPUT LINE              RGR\n         MVC   REPLY(79),BLANKS   CLEAR THE INPUT LINE              RGR\n         TGET  REPLY0,85,ASIS     GET 85 CHARACTERS FROM TERMINAL   RGR\n         CH    R15,=H'12'              MORE INPUT?                  RGR\n         BNE   NOCLEAR                    NO, SKIP CLEARQ           RGR\n         TCLEARQ INPUT                                              RGR\nNOCLEAR  DS    0H                                                   RGR\n         MVC   R24C1A(2),=X'1D40'      AND RESET MDT FLAG           RGR\n         MVC   USERLINE(79),NULLS      CLEAR USER LINE              L03\n         XR    R1,R1                   CLEAR REG.                   RGR\n         IC    R1,REPLY0               SET UP FOR PFK               RGR\n         N     R1,=XL4'0000000F'       OBTAIN NUMBER ONLY           RGR\n         CH    R1,=XL2'000C'           CHECK FOR ENTER              RGR\n         BH    ENTER                                                RGR\n         MVC   REPLY(79),BLANKS        CLEAR THE REPLY AREA         RGR\n         BCTR  R1,0                    KNOCK IT DOWN BY ONE         RGR\n         SLL   R1,5                    TABLE OF 32 BYTE ENTRIES     RGR\n         LA    R1,REPLYS(R1)           POINT TO ENTRY               RGR\n         CLI   0(R1),C'C'              IS IT A CONVERSATIONAL KEY?  RGR\n         BNE   NONCON                     NO, CONTINUE ON.          RGR\n         MVC   USERLINE(79),NULLS      YES, CLEAR USERLINE          L03\n         MVC   USERLINE(31),1(R1)         AND MOVE IN PFK REPLY     RGR\n         MVC   R24C1A(2),=X'1DC1'         AND SET MDT FLAG          RGR\n         B     NEXTPAGE           AND GO ON                         RGR\nNONCON   DS    0H                                                   RGR\n         MVC   REPLY(31),1(R1)         AND MOVE IT IN               RGR\nENTER    DS    0H                                                   RGR\n         CLI   REPLY0,X'6E'       IS THIS A RESHOW? (VTAM ONLY)     RGR\n         BE    WCNTL              YES; REDISPLAY SCREEN             RGR\n         CLI   REPLY,C' '         JUST A BLANK?                     RGR\n         BE    NEXTPAGE           YES, JUST GO REFRESH              RGR\n         CLI   REPLY+13,C':'      IS ERROR MESSAGE IN FIELD?        RGR\n         BNE   ENTER0                                               RGR\n         MVC   REPLY+13(67),BLANKS YES, CLEAR IT OUT.               RGR\nENTER0   DS    0H\n********************************************************************\n*                                                                  *\n*                       X  --  RESHOW PREVIOUS COMMAND             *\n*                                                                  *\n********************************************************************\nRESHOW   DS    0H                                                   RGR\n         CLI   REPLY,C'X'         IS IT RESHOW?                     RGR\n         BE    RESHOW0            YES, SET UP THE COMMAND           RGR\n         CLC   REPLY(3),VIPWORD   IS IT PASSWORD?                   RGR\n         BE    OPERCMDS           YES, DON'T RESET COMMAND          RGR\n         MVC   REPLYSAV(79),REPLY NO, SAVE FOR NEXT TIME.           RGR\n         B     OPERCMDS           AND CONTINUE                      RGR\nRESHOW0  DS    0H                                                   RGR\n         LA    R2,REPLYSAV+L'REPLYSAV-10                            L03\n         CLI   0(R2),C' '         MAKE SURE WE HAVE NULLS IN        L03\n         BNE   *+8                  USERLINE.                       L03\n         BCT   R2,*-8                                               L03\n         SL    R2,=A(REPLYSAV)                                      L03\n         EX    R2,MVCREP                                            L03\n         MVC   R24C1A(2),=X'1DC1' AND SET MDT FLAG                  RGR\n         B     NEXTPAGE           AND GO ON                         RGR\nMVCREP   MVC   USERLINE(*-*),REPLYSAV\n********************************************************************\n*                                                                  *\n*               CHECK FOR SYSTEM OPERATOR COMMANDS                 *\n*                                                                  *\n********************************************************************\nOPERCMDS DS    0H                                                   RGR\n         CLI   VIPFLG,X'FF'       ARE WE IN VIP MODE?\n         BNE   PARSECMD           NO, SO CONTINUE\n         CLI   REPLY,C'#'         IS IT A POUND COMMAND?            RGR\n         BNE   OPER               NO, CONTINUE                      RGR\n         MVC   OPERCMD(80),REPLY  YES; QUIT AND BLANK OUT REPLY     RGR\n         MVI   OPERCMD+79,C' '    BLANK OUT COLUMN 80               RGR\n         B     DOCMD              BRANCH TO COMMAND AND SVC34       RGR\nOPER     CLI   REPLY,C'/'         IS THIS AN OS OPERATOR COMMAND?\n         BNE   JES                NO, CHECK FOR JES CMD\n         MVC   OPERCMD(79),REPLY+1 YES; QUIT AND BLANK OUT REPLY FIELD\n         MVI   OPERCMD+79,C' '    BLANK OUT COLUMN 80\n         B     DOCMD              BRANCH TO COMMAND AND SVC34\nJES      CLI   REPLY,C'$'         IS THIS A JES COMMAND?\n         BNE   PARSECMD           NO, CONTINUE\n* CHECK FOR JES2 $T AND $VS COMMAND LINES DELETED                   RGR\n         MVC   OPERCMD(80),REPLY  MOVE CMD IN FROM REPLY FIELD      RGR\n         MVI   OPERCMD+79,C' '    BLANK OUT COLUMN 80               RGR\nDOCMD    DS    0H                                                   RGR\n         MVC   REPLY(80),BLANKS   BLANK OUT REPLY FIELD             RGR\n         LA    R3,OPERCMD+79      R3 = ADDR OF LAST COLUMN\n         LA    R1,OPERCMD         R1 = ADDR OF FIRST COLUMN\nNXTCHAR  CLI   0(R3),C' '         IS THIS A BLANK?\n         BNE   LASTCHAR           NO; THIS IS LAST CHAR IN CMD\n         BCTR  R3,0               R3 = R3 - 1\n         CR    R3,R1              IS WHOLE THING BLANK?\n         BL    NEXTPAGE           YES; SOMETHING WRONG, BUT CONT ANYWAY\n         B     NXTCHAR            NO;  GO LOOK AT NEXT CHAR\nLASTCHAR SR    R3,R1              R3 = R3- R1\n         LA    R3,1+4(,R3)        R3 = R3 + 5                       L03\n         STH   R3,OPERCMDL\n         MVC   WTOCMD,OPERCMD                                       L03\n         L     R2,SAVEUPT                                           L03\n         NI    UPTSWS-UPT(R2),255-UPTWTP                            L03\n         WTO   MF=(E,WTO)                                           L03\n         L     R2,CVTPTR           CVT ADDRESS                      L03\n         L     R2,CVTCUCB-CVT(,R2) UCM ADDRESS                      L03\n         SH    R2,=H'4'            POINT TO PREFIX POINTER          L03\n         L     R2,0(,R2)           POINT TO UCM PREFIX              L03\n         L     R2,UCMMCENT-UCMPRFX(,R2) MSTCONSOLE UCM ENTRY        L03\n         SLR   R3,R3                                                L03\n         IC    R3,UCMID-UCMLIST(,R2) MASTER UCM ENTRY NUMBER        L03\n         MODESET KEY=ZERO                                           L03\n         LR    R0,R3              SHOW MCON (CAN DO MOST CMDS).     L03\n         LA    R1,OPERCMDL                                          L03\n         MGCR  OPERCMDL           ISSUER OPERATOR COMMAND.          L03\n         MODESET KEY=NZERO                                          L03\n         L     R2,SAVEUPT                                           L03\n         OI    UPTSWS-UPT(R2),UPTWTP                                L03\n         B     NEXTPAGE                                             L03\n********************************************************************\n*                                                                  *\n*          CONVERT COMMAND TO UPPER CASE AND CALL IKJSCAN          *\n*                                                                  *\n*    THIS CALL TO IKJSCAN IS COMPLETELY UNNECESSARY TO THE OPERATIO*\n*    OF SPY. IT IS INCLUDED SOLELY TO ALLOW THE 'X' FEATURE OF     *\n*    PCF2 TO OPERATE. IF YOU DO NOT HAVE PCF2, THIS COULD BE REMOVE*\n*                                                                  *\n********************************************************************\nPARSECMD OC    REPLY(79),BLANKS   CONVERT CHARS TO UPPER CASE\n         XC    CBUF+2(2),CBUF+2   CLEAR OFFSET\n         MVC   CSPLBLOK(24),CSPLSAVE  COPY IN CSPL BLOK\n         XC    CSOABLOK(8),CSOABLOK\n         LA    R1,CSPLBLOK        R1 = ADDR OF CMD SCAN PARM LIST\n         L     R15,ADDRSCAN       R15 = ADDR OF IKJSCAN\n         BALR  R14,R15            INVOKE IKJSCAN\n         LA    R1,CSOABLOK        R1 = ADDR OF CMD SCAN OUTPUT AREA\n         USING CSOA,R1\n         TM    CSOAFLG,CSOANOC    IS THE BUFFER EMPTY?\n         BO    NEXTPAGE           YES; JUST GO REFRESH\n         DROP  R1\n********************************************************************\n*                                                                  *\n*                       W  --  ENTER WAIT MODE                     *\n*                                                                  *\n********************************************************************\nCWAIT    CLI   REPLY,C'W'         DO WE SHIFT TO WAIT MODE?\n         BNE   CDELAY             NO, SO CONTINUE\n         XI    WAITFLG,X'FF'      TURN ON WAIT FLAG\n         LA    R2,30              SET DEFAULT VALUE = 30\n         LA    R15,CONVBIN        BRANCH TO CONVERSION RTN\n         BALR  R14,R15            EBCDIC TO BINARY\n         MVC   SCRATCH(4),PATTERN MOVE IN EDIT PATTERN\n         ED    SCRATCH(4),WORK+6  EDIT IN CONSOLE NUMBER\n         MVC   TIME(3),SCRATCH+1  MOVE TIME LEFT INTO PLACE\n         ST    R2,TIMER           STORE STARTING TIMER VALUE\n         B     NEXTPAGE           ALL SET - GO DISPLAY NEXT PAGE\n********************************************************************\n*                                                                  *\n*            D  --  SET TIMER DELAY IN TENTHS OF A SECOND          *\n*                                                                  *\n********************************************************************\nCDELAY   CLI   REPLY,C'D'         ARE WE CHANGING THE TIME DELAY?\n         BNE   CCONSOLE           NO, SO CONTINUE\n         LA    R2,10              SET DEFAULT VALUE = 10 TENTHS SECOND\n         LA    R15,CONVBIN        BRANCH TO CONVERSION RTN\n         BALR  R14,R15            EBCDIC TO BINARY\n         C     R2,=F'10'          IS IT LESS THAN A SECOND          RGR\n         BH    NO10               ITS OK                            RGR\n         LA    R2,10              ELSE GIV THEM A TEN               RGR\n         MVC   WORK+6(2),=X'010C'      AND TELL THEM ABOUT IT       RGR\nNO10     MVC   SCRATCH(5),DPATTRN MOVE IN EDIT PATTERN              RGR\n         ED    SCRATCH(5),WORK+6  EDIT IN DELAY TIME\n         MVC   PAUSE(3),SCRATCH+2 MOVE TIME LEFT INTO PLACE\n         MH    R2,=H'10'          CONVERT TO 100THS OF A SECOND\n         ST    R2,DELAY           STORE WAIT DELAY VALUE\n         B     NEXTPAGE           ALL SET - GO DISPLAY NEXT PAGE\n********************************************************************\n*                                                                  *\n*                    C  --  SET CONSOLE NUMBER                     *\n*                                                                  *\n********************************************************************\nCCONSOLE CLI   REPLY,C'C'         DO WE CHANGE CONSOLES?\n         BNE   BYE                NO, SO CONTINUE\n         L     R2,CONSOLE         SET DEFAULT CONSOLE\n         ST    R2,OLDCONS         SAVE OLD CONSOLE #\n         LA    R15,CONVBIN        BRANCH TO\n         BALR  R14,R15            EBCDIC->BINARY CONVERTOR\n         ST    R2,CONSOLE         STORE R2 AWAY AS CONSOLE NUMBER\n         B     NEXTPAGE           CONTINUE\n********************************************************************\n*                                                                  *\n*                        B  --  TERMINATE SPY                      *\n*                                                                  *\n********************************************************************\nBYE      CLI   REPLY,C'B'         IS IT A 'B'?\n         BE    DONE               YES, SO QUIT\n********************************************************************\n*                                                                  *\n*                        E  --  TERMINATE SPY                      *\n*                                                                  *\n********************************************************************\nEND      CLI   REPLY,C'E'         IS IT AN 'E'?\n         BE    DONE               YES, SO QUIT\n********************************************************************\n*                                                                  *\n*               F  --  FREEZE DISPLAY ON CURRENT PAGE              *\n*                                                                  *\n********************************************************************\nF        CLI   REPLY,C'F'         IS IT AN 'F'?\n         BNE   R                  NO, SO CONTINUE ON\n         MVI   FREEZE,C'F'        TURN ON FREEZE INDICATOR\n         B     NEXTPAGE           CONTINUE\n********************************************************************\n*                                                                  *\n*           R  --  RELEASE FREEZE ON CURRENT PAGE DISPLAY          *\n*                                                                  *\n********************************************************************\nR        CLI   REPLY,C'R'         IS IT AN 'R'?\n         BNE   MODE1              NO, SO CONTINUE ON\n         MVI   FREEZE,C'R'        TURN OFF FREEZE INDICATOR\n         B     NEXTPAGE           CONTINUE\n********************************************************************\n*                                                                  *\n*                1  --  SHIFT TO MODE 1 TYPE DISPLAY               *\n*                                                                  *\n********************************************************************\nMODE1    CLI   REPLY,C'1'         DO WE SHIFT TO MODE 1 DISPLAY?\n         BNE   MODE2              NO, SO CONTINUE\n         MVI   MODE,C'1'          SET MODE INDICATOR\n         B     NEXTPAGE\n********************************************************************\n*                                                                  *\n*                2  --  SHIFT TO MODE 2 TYPE DISPLAY               *\n*                                                                  *\n********************************************************************\nMODE2    CLI   REPLY,C'2'         DO WE SHIFT TO MODE 2 DISPLAY?\n         BNE   GETHELP            NO, SO CONTINUE\n         MVI   MODE,C'2'          SET MODE INDICATOR\n         B     NEXTPAGE\n********************************************************************\n*                                                                  *\n*           ?  --  LIST HELP FOR SPY COMMANDS ON TERMINAL          *\n*                                                                  *\n********************************************************************\nGETHELP  CLI   REPLY,C'?'         IS HE ASKING FOR HELP?            RGR\n         BNE   GETSTAT            NO,SO CONTINUE                    RGR\n         LA    R1,HELP            R1 = ADDR OF HELP PAGE            RGR\n         LA    R0,HLENGTH         R0 = LENGTH OF HELP PAGE          RGR\n         ICM   R1,8,FULLSCR       INSERT ASIS CNTL CHARS            RGR\n         BAL   R14,TERMPUT        DO A TPUT; DISPLAY HELP           RGR\n         TGET  REPLY0,6,ASIS      GET  6 CHARACTERS FROM TERMINAL   RGR\n         CH    R15,=H'12'              MORE INPUT?                  RGR\n         BNE   NOCLEAR0                   NO, SKIP CLEARQ           RGR\n         TCLEARQ INPUT                                              RGR\nNOCLEAR0 DS    0H                                                   RGR\n         LA    R1,HELP2           R1 = ADDR OF HELP PAGE            RGR\n         LA    R0,HLENGTH2        R0 = LENGTH OF HELP PAGE          RGR\n         ICM   R1,8,FULLSCR       INSERT ASIS CNTL CHARS            RGR\n         BAL   R14,TERMPUT        DO A TPUT; DISPLAY HELP           RGR\n         B     READCHAR                                             RGR\n********************************************************************\n*                                                                  *\n*           S  --  LIST STATUS PAGE FOR ALL DEFINED CONSOLES       *\n*                                                                  *\n********************************************************************\nGETSTAT  CLI   REPLY,C'S'         IS HE ASKING FOR STATUS REPORT?\n         BNE   VIP                NO; CONTINUE                      L03\n         BAL   R14,CLRBUF         CLEAR BUFFER\n         LH    R10,NUMUCMS        R10 = NUMBER OF CONSOLES\n         LA    R2,UCMTAB+16       R2 = ADDR OF FIRST CONSOLE ENTRY\n         XR    R4,R4              CLEAR R4\n         LA    R4,BUF             R4 = ADDR OF TPUT BUFFER\n         LA    R3,23              R3 = NUMBER OF LINES ON SCREEN\nSTLOOP   LR    R1,R2              R1 = ADDR OF UCMTAB ENTRY\n         BAL   R14,CONSDATA       CALL CONSOLE DATA ROUTINE\n         MVC   0(45,R4),CONNUM    SAVE RESULTS IN BUFFER\n         LA    R4,80(R4)          R4 = ADDR OF NEXT LINE IN BUFFER\n         LA    R2,16(R2)          R2 = ADDR OF NEXT UCMTAB ENTRY\n         BCT   R3,NOTFULL         BRANCH IF THE SCREEN NOT FULL\nFULL     LA    R1,HEADER          R1 = ADDR OF TPUT BUF\n         LA    R0,STATLEN         R0 = LENGTH OF TPUT BUF\n         ICM   R1,8,FULLSCR       INSERT ASIS CNTL CHARS\n         BAL   R14,TERMPUT        DO A TPUT; DISPLAY STATUS PAGE\n         BAL   R14,CLRBUF         CLEAR BUFFER\n         LA    R4,BUF             R4 = ADDR OF TPUT BUFFER\n         LA    R3,23              R3 = NUMBER OF LINES ON SCREEN\n         BCT   R10,MORE           MORE ENTRIES?\n         B     NEXTPAGE           NO; CONTINUE\nMORE     TGET  REPLY0,6           PAUSE FOR ENTER                   RGR\n         B     STLOOP             AND LOOP\nNOTFULL  BCT   R10,STLOOP         LOOP IF MORE\n         LA    R1,HEADER          R1 = ADDR OF TPUT BUF\n         LA    R0,STATLEN         R0 = LENGTH OF TPUT BUF\n         ICM   R1,8,FULLSCR       INSERT ASIS CNTL CHARS\n         BAL   R14,TERMPUT        DO A TPUT; DISPLAY STATUS PAGE\n         TGET  REPLY0,6           PAUSE FOR ENTER                   RGR\n         B     NEXTPAGE\n********************************************************************\n*                                                                  *\n*                       CHECK FOR VIP PASSWORD                     *\n*                                                                  *\n********************************************************************\nVIP      CLC   REPLY(3),VIPWORD   WAS VIP PASSWORD ENTERED?\n         BNE   BADCMD             NO, CONTINUE\n         L     R1,SAVEPSCB        R1 = A(PSCB).                     L02\n         CLC   =C'PSY',PSCBUSER-PSCB(R1) ONLY PRC SYSTEMS           L02\n         BE    VIPOK                       SHOULD ENTER COMMANDS.   L02\n         MODESET MODE=PROB               BE SAFE                    L02\n         LR    R0,R12                    PREPARE TO                 L02\n         LR    R1,R0                       ZERO THIS                L02\n         LH    R14,=Y(16*1024)               LOAD                   L02\n         SR    R15,R15                         MODULE!              L02\n         MVCL  R0,R14                            BYE-BYE            L02\nVIPOK    DS    0H                                                   L02\n         MVI   VIPFLG,X'FF'       SET VIP FLAG                      L03\n*        MVC   ERROR(27),LIMMSG1  LIMIT THE USE MESSAGE             L03\n*        MVI   EFLAG,X'FF'        SET THE ERROR FLAG                L03\n         B     NEXTPAGE\n********************************************************************\n*                                                                  *\n*                      COMMAND WAS INVALID                         *\n*                                                                  *\n********************************************************************\nBADCMD   MVC   ERROR(27),ERRMSG3  COMMAND WAS INVALID\n         MVI   EFLAG,X'FF'        SET ERROR FLAG                    RGR\n         MVC   ERROR+27(39),REPLY PUT BAD CMD IN DISPLAY LINE\n         B     NEXTPAGE\n********************************************************************\n*                                                                  *\n*                     ALL DONE - PREPARE TO END                    *\n*                                                                  *\n********************************************************************\nDONE     DS    0H\n         CLI   CRTFLAG,X'00'      IS THIS A HARDCOPY?\n         BE    ALLDONE            YES\n         TPUT  CLR,CLRLEN,FULLSCR NO, LETS CLEAR THE SCREEN FIRST\n         STFSMODE OFF             AND TURN OFF FULLSCREEN MODE\nSKPTST6  EQU   *\nALLDONE  EQU   *\n         L     R1,LOCDCM          PREPARE TO FREEMAIN TDCM AREA     SP3\n         FREEMAIN R,LV=820,A=(1)  DO IT                             SP3\n         AXSET AX=ZERO            AUTH INDEX BACK TO 0              SP3\n         MODESET MODE=PROB        GO BACK TO PROBLEM STATE          SP3\nSKPTST7  EQU   *\nDONE0    DS    0H                                                   RGR\n         L     R13,SAVE+4         RESTORE POINTER TO CALLER'S SAVE AREA\n         LM    R14,R12,12(R13)    RESTORE REGISTERS\n         LA    R15,0              SET RC = 0\n         BR    R14                RETURN TO SYSTEM\n********************************************************************\n*                                                                  *\n*            CONVERT EBCDIC NUMBERS FROM USER INTO BINARY          *\n*                                                                  *\n********************************************************************\nCONVBIN  CVD   R2,WORK            CONVERT TO DECIMAL.\n         CLI   REPLY+1,C' '       DID HE ENTER A NUMBER?\n         BE    RTRN               NO, USE THE DEFAULT\n         CLI   REPLY+1,C'0'       IS THE HEX CODE < 'F0' ?\n         BL    BADCHAR            YES, ERROR\n         CLI   REPLY+1,C'9'       IS THE HEX CODE > 'F9' ?\n         BH    BADCHAR            YES, ERROR\n         PACK  WORK(8),REPLY+1(1) PACK EBCDIC (ASSUME 1 DIGIT)\n         CLI   REPLY+2,C' '       DID HE ENTER 2 DIGITS?\n         BE    CVB                NO, DONT DO THE 2 DIGIT PACK\n         CLI   REPLY+2,C'0'       IS THE HEX CODE < 'F0' ?\n         BL    BADCHAR            YES, ERROR\n         CLI   REPLY+2,C'9'       IS THE HEX CODE > 'F9' ?\n         BH    BADCHAR            YES, ERROR\n         PACK  WORK(8),REPLY+1(2) PACK AGAIN, WITH 2 DIGITS THIS TIME\nCVB      CVB   R2,WORK            GET BINARY\nRTRN     BR    R14                RETURN TO MAINLINE\nBADCHAR  MVC   ERROR(27),ERRMSG2  CONSOLE NUMBER ERROR\n         MVI   EFLAG,X'FF'        SET ERROR FLAG                    RGR\n         B     RTRN\n********************************************************************\n*                                                                  *\n*                            C L R B U F                           *\n*                                                                  *\n*               CLEAR THE ENTIRE BUF AREA TO HEX ZEROS             *\n*                                                                  *\n********************************************************************\nCLRBUF   STM   R2,R5,SAVE25       SAVE REGS 2 - 5\n         LA    R2,BUF             R2 = ADDR OF BUFFER\n         LA    R3,M4BUFLEN        R3 = LENGTH OF BUFFER (35 LINES)\n         LA    R4,BLANKS          R4 = ADDR OF BLANKS\n         LA    R5,1               R5 = LENGTH OF BLANK\n         ICM   R5,8,BLANKS        SETUP PAD CHAR = X'40'\n         MVCL  R2,R4\n         LM    R2,R5,SAVE25       RESTORE REGS\n         BR    R14                RETURN TO CALLER\nSAVE25   DS    4F\n********************************************************************\n*                                                                  *\n*                         T E R M P U T                            *\n*                                                                  *\n*          DO A TPUT TO THE TERMINAL; R0 AND R1 HOLD PARMS         *\n*                                                                  *\n********************************************************************\nTERMPUT  DS    0H\n         CLI   EFLAG,X'FF'        WERE THERE ANY ERRORS?            RGR\n         BNE   FULLPUT                                              RGR\n         MVI   CLEAR+2,X'C7'      YES, SOUND THE ALARM              RGR\n         MVI   EFLAG,X'00'        RESET ERROR FLAG                  RGR\nFULLPUT  TPUT  (1),(0),R          DISPLAY ENTIRE SCREEN             RGR\n         MVI   CLEAR+2,X'C3'      RESET THE ALARM                   RGR\n         BR    R14                RETURN TO CALLER\n********************************************************************\n*                                                                  *\n*          SETUP AND INITIALIZE PARAMETER LIST FOR IKJSCAN         *\n*                                                                  *\n********************************************************************\nINITSCAN STM   R15,R4,SAVE154     SAVE REGS\n         L     R3,CVTPTR          R3 = ADDR OF CVT\n         L     R3,0(R3)           R3 = ADDR OF ADDR OF TCB\n         L     R3,4(R3)           R3 = ADDR OF TCB\n         USING TCB,R3\n         ICM   R3,7,TCBJSCBB      R3 = ADDR OF JSCB\n         ST    R3,SAVEJSCB        SAVE ADDR OF JSCB\n         DROP  R3\n         USING IEZJSCB,R3\n         L     R4,JSCBPSCB        R4 = ADDR OF PSCB\n         ST    R4,SAVEPSCB        SAVE ADDR IF PSCB                 L02\n         DROP  R3\n         USING PSCB,R4\n         L     R3,PSCBUPT         R3 = ADDR OF UPT\n         ST    R3,SAVEUPT         SAVE ADDR OF UPT\n         LA    R2,CSPLSAVE        R2 = ADDR OF CMD SCAN PARM LIST\n         USING CSPL,R2\n         ST    R3,CSPLUPT         SAVE UPT ADDR\n         L     R3,PSCBRLGB        R3 = ADDR OF RELOGON BUFFER\n         L     R3,256(R3)         R3 = ADDR OF ECT\n         ST    R3,CSPLECT         SAVE ECT ADDR\n         LA    R3,CPECB           R3 = ADDR OF FAKE ECB FOR THIS CP\n         ST    R3,CSPLECB         SAVE ECB ADDR\n         LA    R3,FLAGWORD        R3 = ADDR OF CSPL FLAG WORD\n         ST    R3,CSPLFLG         SAVE FLAG ADDR\n         LA    R3,CSOABLOK        R3 = ADDR OF CMD SCAN OUTPUT AREA\n         ST    R3,CSPLOA          SAVE OUTPUT AREA ADDR\n         LA    R3,CBUF            R3 = ADDR OF 'CMD BUFFER'\n         ST    R3,CSPLCBUF        SAVE CBUF ADDR\n         DROP  R2,R4\n         LOAD  EP=IKJSCAN\n         ST    R0,ADDRSCAN\n         LM    R15,R4,SAVE154     RESTORE REGS 15 - 4\n         BR    R14\n         DS    0F\nSAVE154  DS    6F\nSAVEUPT  DS    F                   SAVE ADDR OF UPT\nSAVEJSCB DS    F                   SAVE ADDR OF JSCB\nSAVEPSCB DS    F                   SAVE ADDR OF PSCB                L02\nCSPLBLOK DS    6F                  CMD SCAN PARAMETER LIST\nCSPLSAVE DS    6F\nCPECB    DC    F'0'                FAKE ECB FOR THIS CP\nFLAGWORD DC    F'0'\nCSOABLOK DS    2F                  CMD SCAN OUTPUT AREA\nCBUF     DC    AL2(84),AL2(0)\nREPLY0   DC    CL6' '              SPACE FOR PFK NUMBER             RGR\nREPLY    DC    CL80' '             USERS COMMAND INPUT FIELD        RGR\nREPLYSAV DC    CL80' '             COMMAND SAVE FIELD FOR RESHOW    RGR\nADDRSCAN DS    A\nREPLYS   DC    CL32'N?                              '       PFK  1  RGR\n         DC    CL32'N%%%                            '       PFK  2  L02\n         DC    CL32'NEND                            '       PFK  3  RGR\n         DC    CL32'NW0                             '       PFK  4  RGR\n         DC    CL32'N                               '       PFK  5  RGR\n         DC    CL32'N                               '       PFK  6  RGR\n         DC    CL32'N                               '       PFK  7  RGR\n         DC    CL32'N                               '       PFK  8  RGR\n         DC    CL32'NX                              '       PFK  9  RGR\n         DC    CL32'N                               '       PFK 10  RGR\n         DC    CL32'N                               '       PFK 11  RGR\n         DC    CL32'N                               '       PFK 12  RGR\n********************************************************************\n*                                                                  *\n*                          C O N S D A T A                         *\n*                                                                  *\n*         FILLIN THE DATA LINE FOR A GIVEN CONSOLE                 *\n*                                                                  *\n********************************************************************\nCONSDATA STM   R0,R15,SAVECDAT    SAVE REGS\n         L     R5,0(R1)           R5 = ADDR OF UCM\n         USING UCMLIST,R5\n         L     R6,UCMXB           R6 = ADDR OF RDCM\n         USING DCMTSRT,R6\n         MVC   CONNUM(48),BLANKS   BLANK OUT CONSOLE TYPE FIELD\n         XR    R3,R3              CLEAR R3\n         ICM   R3,1,UCMID         LOAD THE CONSOLE NUMBER\n         CVD   R3,WORK            CONVERT TO DECIMAL IN WORK\n         MVC   SCRATCH(4),PATTERN    MOVE IN EDIT PATTERN\n         ED    SCRATCH(4),WORK+6     EDIT IN CONSOLE NUMBER\n         MVC   CONNUM(2),SCRATCH+2   MOVE CONSOLE NUMBER INTO PLACE\n         MVC   LOCATION(12),4(R1) MOVE IN CONSOLE LOCATION DESCRIPTION\n         MVC   LOCATION+1(3),=CL3'==>'                              L03\n         MVC   LOCATION+4(4),OURSID                                 L03\n         MVC   LOCATION+8(3),=CL3'<=='                              L03\n         MVI   SLASH,C'/'\n         MVC   STATUS(6),=CL6'INACTV' SET DEFAULT = 'INACTV'\n         TM    UCMATR,UCMUF       IS THIS DEVICE ACTIVE?\n         BNO   NOTACT             NO\n         MVC   STATUS(6),=CL6'ACTIVE' SET STATUS = 'ACTIVE'\nNOTACT   EQU   *\n         TM    UCMDISP1,UCMDISPA  IS THIS A MASTER CONSOLE?\n         BNO   AUTH               NO\n         MVC   STATUS(6),=CL6'MASTER' YES\nAUTH     TM    UCMAUTHA,UCMAUTH1  IS THIS CONSOLE SYSTEM AUTHORIZED?\n         BNO   AUTH1              NO\n         MVC   SYS(3),=CL3'SYS '  YES\nAUTH1    TM    UCMAUTHA,UCMAUTH2  IS IT I/O AUTHOZRIZED?\n         BNO   AUTH2              NO\n         MVC   IO(3),=CL3'I/O'    YES\nAUTH2    TM    UCMAUTHA,UCMAUTH3  IS IT CONS AUTHORIZED?\n         BNO   AUTHDONE           NO\n         MVC   CONS(3),=CL3'CON'  YES\nAUTHDONE EQU   *\n         LTR   R6,R6              IS THIS A GRAPHICS CONSOLE?\n         BP    NOTHARD            YES\n         MVC   STATUS(6),=CL6'HRDCPY'\nNOTHARD  EQU   *\n         L     R7,UCMUCB          R7 = ADDR OF UCB\n         MVC   UNIT(3),13(R7)     MOVE UNIT ADDR INTO LINE\n         L     R5,UCMALTEN        R5 = ADDR OF ALTERNATE UCM\n         L     R7,UCMUCB          R7 = ADDR OF UCB\n         MVC   ALTUNIT(3),13(R7)  MOVE UNIT ADDR INTO LINE\n         LM    R0,R15,SAVECDAT    RESTORE REGS\n         BR    R14\n         DROP  R5,R6\nSAVECDAT DS    16F\n         DROP  12\n********************************************************************\n*                                                                  *\n*                          A T T N E X I T                         *\n*                                                                  *\n*         TRAP USERS ATTENTION INTERRUPTS AND FLAG FOR RESET       *\n*                                                                  *\n********************************************************************\nATTNEXIT LR    R7,R15             ESTABLISH\n         USING ATTNEXIT,R7        ADDRESSABILITY.\n         MVI   ATTNFLG,X'FF'      SET ATTN FLAG\n         BR    R14                RETURN TO CALLER\n         DROP  R7\n********************************************************************\n*                                                                  *\n*                         C O N S T A N T S\n*                                                                  *\n********************************************************************\n         DS    0D\nWORK     DS    D                   WORK AREA FOR PACKS\nSCRATCH  DS    D                   SCRATCH AREA FOR CHAR. MANIP\nOLDCONS  DC    F'1'                PREVIOUS CONSOLE NUMBER\nCONSOLE  DC    F'1'                CONSOLE TO BE LOOKED AT\nTPUTLEN  DC    A(MOD2LEN)          LENGTH OF MOD 2 TPUT\nMOD4TPUT DC    A(MOD4LEN)          LENGTH OF MOD4 TPUT\nMOD2TPUT DC    A(MOD2LEN)          LENGTH OF MOD2 TPUT\nLPSCREEN DC    H'0'                LINES PER SCREEN\nCPLINE   DC    H'0'                CHARACTERS PER LINE\nTIMER    DC    F'30'               SECONDS LEFT ON TIMER\nDELAY    DC    F'400'              DELAY FOR 100 HUNDREDTHS OF A SECOND\n*\nMOD4FLG  DC    X'00'               X'FF' INDICATES 3278-4 IN USE\nATTNFLG  DC    X'00'               X'FF' INDICATES ATTN WAS TRAPPED\nCRTFLAG  DC    X'FF'               X'FF' INDICATES CRT IN USE\nWAITFLG  DC    X'00'               X'00' INDICATES NOT IN WAIT MODE\nVIPFLG   DC    X'00'               X'FF' INDICATES VIP MODE\nEFLAG    DC    X'00'               X'FF' INDICATES COMMAND ERROR\nINTEGFLG DC    X'00'               X'FF' INDICATES 35-LINE 3066 CONSOLE\n*\nFULLSCR  DC    X'03'               TPUT FULSCREEN FLAG\nEDITFLG  DC    X'00'               TPUT EDIT FLAG\nVIPWORD  DC    C'%%%'              VIP PASSWORD                     RGR\nNULLS    DC    80X'00'             JUST NULLS\nR41C1    DC    X'11F240'           3278-4  --  ROW 41, COL 1\nR42C1    DC    X'11F350'           3278-4  --  ROW 42, COL 1\nR43C1    DC    X'11F460'           3278-4  --  ROW 43, COL 1\nPATTERN  DC    X'40202020'         EDIT PATTERN FIELD\nDPATTRN  DC    X'4021204B20'       EDIT PATTERN FIELD\nPAD      DC    C' '                PAD CHARACTER FOR MOVEBUFF MVC\nSTAXLIST STAX  ATTNEXIT,MF=L       PARM LIST FOR ATTENTION TRAP\nBLANKS   DC    CL80' '\nCONASID  DS    H                                                    L03\nOURSID   DS    CL4                                                  L03\n         IEZMGCR DSECT=NO         SVC 34 PLIST.                     L03\n         ORG   MGCRPL                                               L03\nOPERCMDL DC    H'0,0'                                               L03\n         ORG   MGCRTEXT                                             L03\nOPERCMD  DC    CL80' '                                              L03\n         ORG   ,                                                    L03\nWTO      WTO   'SPY/       :                                           X\n                                                              ',       X\n               ROUTCDE=11,MF=L                                      L03\nWTOUSER  EQU   WTO+8,7                                              L03\nWTOCMD   EQU   WTO+17,80                                            L03\n********************************************************************\n*                                                                  *\n*               327X SCREEN CLEAR CONTROL CHARACTERS               *\n*                                                                  *\n********************************************************************\nCLR      DC    X'C1'              WCC - CLEAR SCREEN\n         DC    X'115D7E'          SBA TO ROW 24, COL 80 (FSE 5.0)\n         DC    X'114040'          SBA TO ROW 1, COL 1\n         DC    X'3C404000'        FILL SCREEN WITH NULLS\n         DC    X'114040'          SBA TO ROW 1, COL 1\n         DC    X'13'              INSERT CURSOR\nCLRLEN   EQU   *-CLR\nSASID    DS    F                  STORE FOR PREVIOUS SEC ASID       SP3\nLOCDCM   DS    F                  ADDR OF GETMAINED AREA FOR TDCM   SP3\nONE      DC    H'1'               TO SET AX 1                       SP3\nZERO     DC    H'0'               TO SET AX 0                       SP3\n         LTORG\n********************************************************************\n*                                                                  *\n*                     ERROR AND WARNING MESSAGES                   *\n*                                                                  *\n********************************************************************\nERRMSG1  DC    CL27':ERROR - CONSOLE NOT ACTIVE'                    RGR\nERRMSG2  DC    CL27':ERROR - NON-NUMERIC VALUE '                    RGR\nERRMSG3  DC    CL27':ERROR - INVALID COMMAND   '                    RGR\nERRMSG4  DC    CL27':ERROR - NON-CRT CONSOLE   '                    RGR\nERRMSG5  DC    CL27':WARNING - UCM TABLE FULL  '                    RGR\nERRMSG6  DC    CL27':ERROR - TERMINAL INVALID  '                    RGR\nLIMMSG1  DC    CL27':PLEASE LIMIT COMMAND USAGE'                    RGR\n********************************************************************\n*                                                                  *\n*                           USER HELP PAGE                         *\n*                                                                  *\n********************************************************************\nHELP     DC    X'C1'               WCC\n         DC    X'115D7F'           SBA TO ROW 24, COL 80 (FSE 5.0)\n         DC    X'114040'           SBA TO ROW 1, COL 1\n         DC    X'3C404000'         FILL SCREEN WITH NULLS\n         DC    X'114040',X'1DE8',C'S P Y   ---   VERSION 3.1'\n         DC    X'11C260',C'COMMAND  DESCRIPTION'\n         DC    X'11C3F0'\n         DC    X'11C540',C'  B     END SPY'\n         DC    X'11C650',C'  C     SWITCH MONITOR TO CONSOLE 1'\n         DC    X'11C760',C'  CXX   SWITCH MONITOR TO CONSOLE XX'\n         DC    X'11C8F0',C'  DXX   SET DELAY TO XX TENTHS SECONDS'\n         DC    X'114A40',C'  E     END SPY'\n         DC    X'114B50',C'  F     FREEZE DISPLAY ON CURRENT PAGE'\n         DC    X'114C60',C' '\n         DC    X'114DF0',C'  R     RELEASE DISPLAY'\n         DC    X'114F40',C'  S     STATUS OF ALL CONSOLES'\n         DC    X'115050',C'  W     START TIMER MODE FOR 30 SECONDS'\n         DC    X'11D160',C'  WXX   START TIMER MODE FOR XX SECONDS'\n         DC    X'11D2F0',C'  W0    START TIMER MODE UNTIL ATTN'\n         DC    X'11D440',C'  ?     DISPLAY THIS PAGE'\n         DC    X'11D550',C'  1     DISPLAY MODE 1 (TOP 22, BOTTOM 12)'\n         DC    X'11D660',C'  2     DISPLAY MODE 2 (TOP 22, BOTTOM 22)'\n         DC    X'11D7F0'\n         DC    X'11D940',C'HITTING INTERRUPT WILL STOP THE WAIT TIMER'\n         DC    X'115A50'\n         DC    X'115B60'\n         DC    X'115CF0'        ROW 24, COL 1\n         DC    C'HIT ENTER TO CONTINUE'\n         DC    X'115DC6'        ROW 24, COL 23\n         DC    X'1D40'\n         DC    X'1340'\n         DC    X'1DE8'\nMARKER1  EQU   *\nHLENGTH  EQU   MARKER1-HELP     LENGTH OF HELP TPUT\nHELP2    DC    X'C1'               WCC\n         DC    X'115D7F'           SBA TO ROW 24, COL 80 (FSE 5.0)\n         DC    X'114040'           SBA TO ROW 1, COL 1\n         DC    X'3C404000'         FILL SCREEN WITH NULLS\n         DC    X'114040',X'1DE8',C' PFK #   CONV?    COMMAND'\n         DC    X'11C150'\n         DC    X'11C260',C'   1   - NO   -   ?'\n         DC    X'11C3F0',C'   2   - NO   -   '\n         DC    X'11C540',C'   3   - NO   -   END'\n         DC    X'11C650',C'   4   - NO   -   W0'\n         DC    X'11C760',C'   5   - NO   -   '\n         DC    X'11C8F0',C'   6   - NO   -   '\n         DC    X'114A40',C'   7   - NO   -   '\n         DC    X'114B50',C'   8   - NO   -   '\n         DC    X'114C60',C'   9   - NO   -   **RESHOW KEY**'\n         DC    X'114DF0',C'  10   - NO   -   '\n         DC    X'114F40',C'  11   - NO   -   '\n         DC    X'115050',C'  12   - NO   -   '\n         DC    X'115CF0'        ROW 24, COL 1\n         DC    C'HIT ENTER TO CONTINUE'\n         DC    X'115DC6'        ROW 24, COL 23\n         DC    X'1D40'\n         DC    X'1340'\n         DC    X'1DE8'\nMARKER2  EQU   *\nHLENGTH2 EQU   MARKER2-HELP2    LENGTH OF HELP TPUT\nMOVEBSAV DS    6F                 REG SAVE AREA - R4:R9             SP3\n********************************************************************\n*                                                                  *\n*                            U C M T A B                           *\n*                                                                  *\n*        THE UCMTAB TABLE IS BUILT AT SPY INITIALIZATION TIME.     *\n*        ONE ENTRY IS FILLED IN FOR EACH CONSOLE THAT HAS BEEN     *\n*        IOGENED INTO THE SYSTEM. THE 12 BYTE DESCRIPTION FIELD    *\n*        ALLOWS YOU TO TAG EACH CONSOLE WITH SOME MNEMONIC THAT    *\n*        IS EASIER TO REMEMBER THAN CONSOLE NUMBERS. IF UCMTAB IS  *\n*        NOT DEFINED LARGE ENOUGH TO HOLD ALL THE CONSOLES, A      *\n*        WARNING IS ISSUED BUT SPY CONTINUES ANYWAY.               *\n*                                                                  *\n********************************************************************\n         DS    0F\nUCMTABE  DC    A(TABEND)\nNUMUCMS  DC    H'0'\n         DS    0F\nUCMTAB   DC    A(0),CL12' '\n         DC    A(0),CL12'            '    CONSOLE 1                 L03\n         DC    A(0),CL12'            '    CONSOLE 2                 L03\n         DC    A(0),CL12'            '    CONSOLE 3                 L03\n         DC    A(0),CL12'            '    CONSOLE 4                 L03\n         DC    A(0),CL12'            '    CONSOLE 5                 L03\n         DC    A(0),CL12'            '    CONSOLE 6\n         DC    A(0),CL12'            '    CONSOLE 7\n         DC    A(0),CL12'            '    CONSOLE 8\n         DC    A(0),CL12'            '    CONSOLE 9\n         DC    A(0),CL12'            '    CONSOLE 10\n         DC    A(0),CL12'            '    CONSOLE 11\n         DC    A(0),CL12'            '    CONSOLE 12\n         DC    A(0),CL12'            '    CONSOLE 13\n         DC    A(0),CL12'            '    CONSOLE 14\n         DC    A(0),CL12'            '    CONSOLE 15\n         DC    A(0),CL12'            '    CONSOLE 16\n         DC    A(0),CL12'            '    CONSOLE 17\n         DC    A(0),CL12'            '    CONSOLE 18\n         DC    A(0),CL12'            '    CONSOLE 19\n         DC    A(0),CL12'            '    CONSOLE 20\n         DC    A(0),CL12'            '    CONSOLE 21\n         DC    A(0),CL12'            '    CONSOLE 22\n         DC    A(0),CL12'            '    CONSOLE 23\n         DC    A(0),CL12'            '    CONSOLE 24\n         DC    A(0),CL12'            '    CONSOLE 25\nTABEND   EQU   *\nSAVE     DC    18F'0'             SAVE AREA\n********************************************************************\n*                                                                  *\n*                  DISPLAY SCREEN - HEADER SECTION                 *\n*                                                                  *\n********************************************************************\nHEADER   EQU   *\nCLEAR    DC    X'27F1C3'          ESC;ERASE/WRITE;WCC               L02\n         DC    X'115D7F'          SBA TO ROW 24, COL 80 (FSE 5.0)\n         DC    X'114040'          SBA TO ROW 1, COL 1\n         DC    X'3C404000'        FILL SCREEN WITH NULLS\n         DC    X'114040'          SBA TO ROW 1, COL 1 JUST IN CASE\n********************************************************************\n*                                                                  *\n*                 DISPLAY SCREEN IMAGE BUFFER SECTION              *\n*                                                                  *\n********************************************************************\nBUF      DC    21CL84' '          OPERATORS SCREEN BUFFER\n         DC    22CL84' '          PLUS EXTRA FOR 3278-4\n********************************************************************\n*                                                                  *\n*               DISPLAY SCREEN - TRAILER SECTION                   *\n*                                                                  *\n********************************************************************\nTRAILER  EQU   *\nCMDCTRL  DC    X'115A50'          SBA TO ROW 22, COL 1\n         DC    X'1DE8'            ATTR BYTE - PROTECTED, HIGH INTENSITY\nLASTLINE DC    CL79' '            OPERATORS COMMAND INPUT LINE\nPHEADING DC    X'115B60'          SBA TO ROW 23, COL 1\n         DC    X'1DE8'            ATTR BYTE - PROTECTED, HIGH INTENSITY\nHEADING  DC    CL8'CONSOLE '\nCONNUM   DC    CL2' 1'            CONSOLE NUMBER\n         DC    CL1' '\nLOCATION DC    CL12' '\n         DC    CL2' '\nUNIT     DC    CL3' '\nSLASH    DC    CL1'/'\nALTUNIT  DC    CL3' '\n         DC    CL2' '\nSTATUS   DC    CL6' '             MASTER CONSOLE\n         DC    CL2' '\nSYS      DC    CL4' '             SYS  AUTHORIZATION\nIO       DC    CL4' '             I/O  AUTHORIZATION\nCONS     DC    CL3' '             CONS AUTHORIZATION\n         DC    CL3' '\nTIME     DC    CL3' '             SECONDS REMAINING ON TIMER\n         DC    CL1'/'\nPAUSE    DC    CL3'1.0'           DELAY IN SECONDS\n         DC    CL2' '\nHEADING2 DC    CL5'MODE:'\nFREEZE   DC    C'F'               FREEZE/RELEASE MODE\nMODE     DC    CL1'2'             DISPLAY MODE 2/1\n         DC    CL1' '\n         DC    CL5'PAGE '\nPAGE     DC    CL1'2'             PAGE NUMBER\nR24C1    DC    X'115CF0'          SBA TO ROW 24, COL 1\nR24C1A   DC    X'1D40'            ATTR BYTE - UNPROTECTED, LOW INTENS.\n         DC    X'13'              INSERT CURSOR\nUSERLINE DC    XL13'00'           USERS COMMAND INPUT LINE          L03\nERROR    DC    XL66'00'           ERROR MSG FIELD                   L03\nENDTRAIL EQU   *\n********************************************************************\n*                                                                  *\n*                           E Q U A T E S                          *\n*                                                                  *\n*     NOTE THAT A 'LINE' IS DEFINED AS 84 BYTES; THIS IS BECAUSE   *\n*     DIDOCS BUILDS THE OPERATOR SCREEN BUFFER LINES AS 79 BYTES OF*\n*     TEXT + 5 CONTROL BYTES. THIS CONSISTS OF AN SBA (X'11XXYY')  *\n*     AND AN ATTRIBUTE BYTE (X'1DXX').                             *\n*                                                                  *\n********************************************************************\nLEN9     EQU   9*84               NUMBER OF BYTES IN  9 LINES\nLEN21    EQU   21*84              NUMBER OF BYTES IN 21 LINES\nLEN22    EQU   22*84              NUMBER OF BYTES IN 22 LINES\nLEN13    EQU   13*84              NUMBER OF BYTES IN 13 LINES\nM2BUFLEN EQU   21*84              LENGTH OF BUFFER 3278-2\nM4BUFLEN EQU   35*84              LENGTH OF BUFFER 3278-4\nSTATLEN  EQU   BUF-CLEAR+80*23    LENGTH OF 'STATUS' PAGE BUFFER\nHEADLEN  EQU   BUF-HEADER         LENGTH OF HEADER\nTRAILEN  EQU   ENDTRAIL-TRAILER   LENGTH OF TRAILER\nMOD4LEN  EQU   ENDTRAIL-HEADER    LENGTH OF TPUT FOR MOD4\nMOD2LEN  EQU   MOD4LEN-LEN22      LENGTH OF TPUT FOR MOD2\nENDMOD2  EQU   BUF+M2BUFLEN       ADDR OF TRAILER FOR 3278-2\n*        PRINT ON                                                   RGR\n********************************************************************\n*                                                                  *\n*                SYSTEM CONTROL BLOCK MAPPING DSECTS               *\n*                                                                  *\n*     ALL MACROS EXCEPT FOR IEERDCM AND IEETDCM CAN BE FOUND IN    *\n*     EITHER 'SYS1.MACLIB' OR 'SYS1.AMODGEN'. THE TWO EXCEPTIONS   *\n*     ARE IN 'SYS1.APVTMACS'; THEY ARE ALSO DISTRIBUTED WITH THE   *\n*     SOURCE TO 'SPY'.                                             *\n*                                                                  *\n********************************************************************\n         PRINT NOGEN                                                L02\n         IHAPSA ,                                                   L03\n         CVT   DSECT=YES          COMMUNICATIONS VECTOR TABLE\n         IEESMCA ,                                                  L03\n         IHAASCB ,                                                  L03\n         IEECUCM FORMAT=NEW,DSECT=YES,LIST=YES\n*        IEERDCM ,                RESIDENT DISPLAY CONTROL MODULE\nDCMTSRT  DSECT\nDCMADTRN EQU DCMTSRT+0,4\n*        IEETDCM ,                PAGEABLE DISPLAY CONTROL MODULE\nDCMSTRT  DSECT\nDCMINPUT EQU DCMSTRT+X'70'\nDCMMSGAL EQU DCMSTRT+X'FE'\nDCMASCRN EQU DCMSTRT+X'30'\n         IEZJSCB ,                JOB STEP CONTROL BLOCK\n         IKJCSOA ,                COMMAND SCAN OUTPUT AREA\n         IKJCSPL ,                COMMAND SCAN PARAMETER LIST\n         IKJPSCB ,                PROTECTED STEP CONTROL BLOCK\n         IKJTCB  ,                TASK CONTROL BLOCK\n         IKJUPT  ,                USER PROFILE TABLE\n         PRINT   OFF                                                L03\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         PRINT ON                                                   L02\n         END   SPY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SRCDOC": {"ttr": 9991, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x02Q\\x02Q\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 593, "newlines": 593, "modlines": 0, "user": "FILE369"}, "text": "*PROCESS OPTIMIZE(TIME);\n /*  ISPF/PDF LMF PROMOTION EXIT - DOCUMENT SOURCE                   */\n /********************************************************************/\n /*                                                                  */\n /* NAME         SRCDOC                                              */\n /*                                                                  */\n /* COMPONENT    ISPF/PDF LMF                                        */\n /*                                                                  */\n /* FUNCTION     ADD DOCUMENTATION TO LMF-MANAGED MEMBERS            */\n /*                                                                  */\n /* ENTRY        VIA CALL FROM LMFAPSEX EXIT CLIST                   */\n /*                                                                  */\n /* INPUT        SOURCE PROGRAM PDS MEMBER                           */\n /*              SHARED VARIABLE POOL                                */\n /*                                                                  */\n /* OUTPUT       UPDATED SOURCE                                      */\n /*              RETURN CODE                                         */\n /*              MESSAGE ID IN SHARED POOL VARIABLE MSG              */\n /*              ASSEMBLY INDICATOR IN SHARED VARIABLE POOL          */\n /*                                                                  */\n /* FILES        DDNAME SOURCE   -- LIBRARY PDS MEMBER               */\n /*              DDNAME SYSPRINT -- DEBUGGING/TRACE                  */\n /*                                                                  */\n /* EXT REF      ISPLINK                                             */\n /*                                                                  */\n /* ISPF SERVICE CONTROL                                             */\n /*              LMCLOSE                                             */\n /*              LMFREE                                              */\n /*              LMINIT                                              */\n /*              LMMFIND                                             */\n /*              LMOPEN                                              */\n /*              VDEFINE                                             */\n /*              VDELETE                                             */\n /*              VGET                                                */\n /*              VPUT                                                */\n /*                                                                  */\n /* MESSAGES     LMFX101E                                            */\n /*              LMFX102W                                            */\n /*              LMFX103E                                            */\n /*              LMFX104E                                            */\n /*                                                                  */\n /* OPERATION    THE SHARED POOL IS ACCESSED TO GET THE MEMBER NAME  */\n /*              AND LOW LEVEL QUALIFIER (LANGUAGE TYPE).            */\n /*              THE LM DIALOG SERVICES ARE THEN USED TO ACCESS      */\n /*              VERSION, MODIFICATION LEVEL, DATE, TIME,            */\n /*              AND TSO LOGON FROM THE PDS DIRECTORY.               */\n /*              THE INPUT MEMBER IS OPENED FOR UPDATE AND READ.     */\n /*              WHEN THE EXISTING TRGIGGER RECORD OR SEQUENCE       */\n /*              IS FOUND, THE RECORD IS UPDATED AND REWRITTEN.      */\n /*                                                                  */\n /*              SHARED VARIABLE MSG IS SET TO A MESSAGE ID FOR      */\n /*              NON-ZERO RETURN CODES.                              */\n /*                                                                  */\n /*              SHARED POOL VARIABLE NEEDASM IS SET TO 'YES' IF     */\n /*              THE MODULE HAS THE TYPE OF TRIGGER THAT IMPLIES     */\n /*              AN ASSEMBLY OR COMPILATION IS NEEDED.               */\n /*              OTHERWISE, IT IS SET TO  'NO'                       */\n /*                                                                  */\n /* RETURN CODE  0  MEMBER UPDATED OR ZERO LENGTH MEMBER             */\n /*              4  ERROR - PROMOTION MAY BE PERMITTED               */\n /*              8  ERROR - PROMOTION DENIED                         */\n /*                                                                  */\n /* ATTRIBUTES   UNAUTHORIZED                                        */\n /*              PROBLEM STATE                                       */\n /*              USER KEY                                            */\n /*                                                                  */\n /* RESTRICTIONS CURRENT SUPPORT FOR PL/I, CLIST, CNTL               */\n /*              AND SCRIPT TYPES ONLY.                              */\n /*                                                                  */\n /* NOTES        THIS UPDATE METHOD IS USED TO AVOID HAVING THE      */\n /*              ISPF/PDF STATISTICS IN THE PDS DIRECTORY            */\n /*              CHANGE AS THE RESULT OF THIS EXIT.                  */\n /*              THE SCRIPT SUPPORT TRIGGERS ARE IN LOWER CASE.      */\n /*              TAKE CARE WHEN EDITING CHANGES.                     */\n /*                                                                  */\n /* PROGRAMMER   C. J. PITTS                                         */\n /*                                                                  */\n /* MAINTENANCE  WHO  DATE    DESCRIPTION                            */\n /*              CJP  22JUL85 ADDED SUPPORT FOR NEEDASM.             */\n /*              CJP  23JUL85 ADDED SUPPORT FOR CLIST AND CNTL.      */\n /*              CJP  25JUL85 RELAXED CONSTRAINTS FOR CLIST AND      */\n /*                           CNTL TRIGGERS. ADDED SUPPORT FOR       */\n /*                           PLI INCLUDED MEMBERS (NON-COMPILE).    */\n /*              CJP  28JUL85 ADDED COBOL AND ASM SUPPORT.           */\n /*              CJP  29JUL85 ADDED SCRIPT SUPPORT.                  */\n /*              CJP  19DEC85 PERMIT RETURN CODE 0 FOR ZERO          */\n /*                           LENGTH MODULE.                         */\n /*              CJP  27MAR86 ADDED SUPPORT FOR NATURAL. USE         */\n /*                           SAME TRIGGERS AND LOGIC AS CLIST.      */\n /*              CJP  30JUN86 ADDED SUPPORT FOR SAS. USE SAME        */\n /*                           TRIGGERS AND LOGIC AS CLIST. ALSO      */\n /*                           CLEANED UP LRECL/RECFM CHECK LOGIC.    */\n /*                                                                  */\n /********************************************************************/\n %PAGE;\n SRCDOC: PROCEDURE OPTIONS(MAIN) REORDER;\n\n   DECLARE COPYRIGHT    CHARACTER(48) STATIC\n           INITIAL('COPYRIGHT (C) 1985 PLANNING RESEARCH CORPORATION');\n\n   DECLARE SOURCE       FILE RECORD UPDATE;\n   DECLARE SYSPRINT     FILE PRINT;\n\n   DECLARE INCARD       CHARACTER(80) BASED(IP);\n   DECLARE IP           POINTER;\n\n   DECLARE ISPLINK      ENTRY EXTERNAL OPTIONS(ASM INTER RETCODE);\n\n   DECLARE RC           PICTURE'99';\n   DECLARE MSG          CHARACTER(8);\n   DECLARE NEEDASM      CHARACTER(3) INITIAL('NO');\n\n   DECLARE DATAID       CHARACTER(8);    /*  DATA ID FROM LMINIT     */\n   DECLARE ZLVERS       CHARACTER(2),    /*  VERSION                 */\n           ZLMOD        CHARACTER(2),    /*  MODIFICATION LEVEL      */\n           ZLMDATE      CHARACTER(8),    /*  MODIFICATION DATE       */\n           ZLMTIME      CHARACTER(5),    /*  MODIFICATION TIME       */\n           ZLUSER       CHARACTER(8),    /*  MODIFICATION USER ID    */\n           ZLFPRJ       CHARACTER(8),    /*  'FROM' PROJECT          */\n           ZLFGRP       CHARACTER(8),    /*  'FROM' GROUP            */\n           ZLFTYP       CHARACTER(8),    /*  'FROM' TYPE             */\n           ZLFMEM       CHARACTER(8),    /*  'FROM' MEMBER           */\n           ZLTTYP       CHARACTER(8),    /*  'TO' TYPE               */\n           ZLTMEM       CHARACTER(8),    /*  'TO' MEMBER             */\n           LRECL        CHARACTER(8),    /*  LOGICAL RECORD LENGTH   */\n           RECFM        CHARACTER(8);    /*  RECORD FORMAT           */\n\n   DECLARE ID_STRING    CHARACTER(40);\n\n   DECLARE L            FIXED BINARY(31);\n\n   DECLARE EMPTY_MEMBER BIT(1) INITIAL('1'B);\n\n   DECLARE (INDEX,LENGTH,SUBSTR)\n                        BUILTIN;\n %PAGE;\n   ON ERROR SNAP\n     BEGIN;\n       ON ERROR SNAP SYSTEM;\n       PUT FILE(SYSPRINT) PAGE DATA;\n       CALL SET_RETURN_CODE(8,'LMFX101E');\n     END;\n\n   CALL ISPLINK('CONTROL','ERRORS','CANCEL');\n\n   CALL INITIALIZE_POOL_VARIABLES;\n\n   CALL SET_RETURN_CODE(0,'');\n   CALL ISPLINK('VPUT','NEEDASM ','SHARED');\n\n   IF LRECL\u00ac='00000080' | SUBSTR(RECFM,1,1)\u00ac='F'\n    THEN\n      DO;\n        CALL SET_RETURN_CODE(8,'LMFX103E');\n        RETURN;\n      END;\n\n   ID_STRING =  ZLTMEM  || ' V' || ZLVERS  || '.M' ||\n                ZLMOD   || ' '  || ZLMDATE || ' '  ||\n                ZLMTIME || ' '  || ZLUSER;\n\n   OPEN FILE(SOURCE);\n\n   SELECT(ZLTTYP);\n     WHEN('ASM')\n       CALL PROCESS_ASM;\n     WHEN('CLIST')\n       CALL PROCESS_CLIST;\n     WHEN('CNTL')\n       CALL PROCESS_CNTL;\n     WHEN('COBOL')\n       CALL PROCESS_COBOL;\n     WHEN('NATURAL')\n       CALL PROCESS_NATURAL;\n     WHEN('PLI')\n       CALL PROCESS_PLI;\n     WHEN('SAS')\n       CALL PROCESS_SAS;\n     WHEN('SCRIPT')\n       CALL PROCESS_SCRIPT;\n     OTHERWISE\n       CALL SET_RETURN_CODE(4,'LMFX102W');\n   END;\n\n   CALL ISPLINK('VPUT','NEEDASM ','SHARED');\n\n   CALL ISPLINK('VDELETE','*');\n\n   CLOSE FILE(SOURCE);\n %SKIP(2);\n /********************************************************************/\n /*     END OF MAIN PROCEDURE                                        */\n /********************************************************************/\n %PAGE;\n /********************************************************************/\n /*   PROCESS ASM MODULE                                             */\n /********************************************************************/\n\n PROCESS_ASM: PROCEDURE;\n\n /********************************************************************/\n /* SRCLEVEL DC   C'MMMMMMMM VNN.MNN YY/MM/DD HH:MM UUUUUUUU'        */\n /**   SOURCE LEVEL MMMMMMMM VNN.MNN YY/MM/DD HH:MM UUUUUUUU         */\n /*                 MODULE   VER/MOD   DATE   TIME  USER NAME        */\n /********************************************************************/\n\n   DECLARE TRIGGER_1    CHARACTER( 9) INITIAL('SRCLEVEL ');\n   DECLARE TRIGGER_2A   CHARACTER( 1) INITIAL('*'),\n           TRIGGER_2B   CHARACTER(13) INITIAL('SOURCE LEVEL ');\n   DECLARE (I,J)        FIXED BINARY(15);\n\n   ON ENDFILE(SOURCE)\n     GO TO SOURCE_ALL_IN;\n\n   DO WHILE('1'B);\n     READ FILE(SOURCE) SET(IP);\n     EMPTY_MEMBER = '0'B;\n     IF SUBSTR(INCARD,1,LENGTH(TRIGGER_1))=TRIGGER_1\n       THEN\n         DO;\n           SUBSTR(INCARD,1,72) = TRIGGER_1 || 'DC    C''' ||\n                                 ID_STRING || '''';\n           REWRITE FILE(SOURCE);\n           NEEDASM = 'YES';\n           RETURN;\n         END;\n     I = INDEX(INCARD,TRIGGER_2A);\n     J = INDEX(INCARD,TRIGGER_2B);\n     IF I>0 & J>LENGTH(TRIGGER_2A)\n       THEN\n         DO;\n           SUBSTR(INCARD,J+LENGTH(TRIGGER_2B),LENGTH(ID_STRING)) =\n                  ID_STRING;\n           REWRITE FILE(SOURCE);\n           RETURN;\n         END;\n   END;\n\n SOURCE_ALL_IN:\n   IF \u00acEMPTY_MEMBER\n     THEN\n       CALL SET_RETURN_CODE(8,'LMFX104E');\n\n END PROCESS_ASM;\n %PAGE;\n /********************************************************************/\n /*   PROCESS CLIST, NATURAL OR SAS MODULE                           */\n /********************************************************************/\n\n PROCESS_CLIST:\n PROCESS_NATURAL:\n PROCESS_SAS: PROCEDURE;\n\n /********************************************************************/\n /* /* SOURCE LEVEL MMMMMMMM VNN.MNN YY/MM/DD HH:MM UUUUUUUU         */\n /*                 MODULE   VER/MOD   DATE   TIME  USER NAME        */\n /********************************************************************/\n\n   DECLARE TRIGGER_1A   CHARACTER( 2) INITIAL('/*'),\n           TRIGGER_1B   CHARACTER(13) INITIAL('SOURCE LEVEL ');\n   DECLARE (I,J)        FIXED BINARY(15);\n\n   ON ENDFILE(SOURCE)\n     GO TO SOURCE_ALL_IN;\n\n   DO WHILE('1'B);\n     READ FILE(SOURCE) SET(IP);\n     EMPTY_MEMBER = '0'B;\n     I = INDEX(INCARD,TRIGGER_1A);\n     J = INDEX(INCARD,TRIGGER_1B);\n     IF I>0 & J>I\n       THEN\n         DO;\n           SUBSTR(INCARD,J+LENGTH(TRIGGER_1B),LENGTH(ID_STRING)) =\n               ID_STRING;\n           REWRITE FILE(SOURCE);\n           RETURN;\n         END;\n   END;\n\n SOURCE_ALL_IN:\n   IF \u00acEMPTY_MEMBER\n     THEN\n       CALL SET_RETURN_CODE(8,'LMFX104E');\n\n END PROCESS_CLIST;\n %PAGE;\n /********************************************************************/\n /*   PROCESS COBOL SOURCE MODULE                                    */\n /********************************************************************/\n\n PROCESS_COBOL: PROCEDURE;\n\n /********************************************************************/\n /*    77  SOURCE-LEVEL                  PIC X(40)                   */\n /*                 VALUE 'MMMMMMMM VNN.MNN YY/MM/DD HH:MM UUUUUUUU' */\n /*   *    SOURCE LEVEL    MMMMMMMM VNN.MNN YY/MM/DD HH:MM UUUUUUUU  */\n /*                        MODULE   VER/MOD   DATE   TIME  USER NAME */\n /********************************************************************/\n\n   DECLARE TRIGGER_1A   CHARACTER(4)  INITIAL('77  '),\n           TRIGGER_1B   CHARACTER(12) INITIAL('SOURCE-LEVEL'),\n           TRIGGER_1C   CHARACTER( 7) INITIAL(' VALUE ');\n   DECLARE TRIGGER_2A   CHARACTER( 1) INITIAL('*'),\n           TRIGGER_2B   CHARACTER(13) INITIAL('SOURCE LEVEL ');\n\n   DECLARE TRIGGERED_1A BIT(1) INITIAL('0'B);\n   DECLARE J            FIXED BINARY(15);\n\n   ON ENDFILE(SOURCE)\n     GO TO SOURCE_ALL_IN;\n\n COBOL_READ_LOOP:\n   DO WHILE('1'B);\n     READ FILE(SOURCE) SET(IP);\n     EMPTY_MEMBER = '0'B;\n     IF TRIGGERED_1A\n       THEN\n         DO;\n           J = INDEX(INCARD,TRIGGER_1C);\n           IF J\u00ac=0\n             THEN\n               DO;\n                 SUBSTR(INCARD,J+LENGTH(TRIGGER_1C),\n                        LENGTH(ID_STRING)+2) = '''' ||ID_STRING|| '''';\n                 REWRITE FILE(SOURCE);\n                 NEEDASM = 'YES';\n                 RETURN;\n               END;\n             ELSE\n               LEAVE COBOL_READ_LOOP;\n         END;\n     IF SUBSTR(INCARD,8,LENGTH(TRIGGER_1A))=TRIGGER_1A &\n        INDEX(INCARD,TRIGGER_1B)>=12\n       THEN\n         TRIGGERED_1A = '1'B;\n       ELSE\n         DO;\n           J = INDEX(INCARD,TRIGGER_2B);\n           IF SUBSTR(INCARD,7,LENGTH(TRIGGER_2A))=TRIGGER_2A & J>=8\n             THEN\n               DO;\n                 SUBSTR(INCARD,J+LENGTH(TRIGGER_2B),\n                        LENGTH(ID_STRING)) = ID_STRING;\n                 REWRITE FILE(SOURCE);\n                 RETURN;\n               END;\n         END;\n   END;\n\n SOURCE_ALL_IN:\n   IF \u00acEMPTY_MEMBER\n     THEN\n       CALL SET_RETURN_CODE(8,'LMFX104E');\n\n END PROCESS_COBOL;\n %PAGE;\n /********************************************************************/\n /*   PROCESS CNTL MODULE                                            */\n /********************************************************************/\n\n PROCESS_CNTL: PROCEDURE;\n\n /********************************************************************/\n /* //* SOURCE LEVEL MMMMMMMM VNN.MNN YY/MM/DD HH:MM UUUUUUUU        */\n /*                  MODULE   VER/MOD   DATE   TIME  USER NAME       */\n /********************************************************************/\n\n   DECLARE TRIGGER_1A   CHARACTER( 3) INITIAL('//*'),\n           TRIGGER_1B   CHARACTER(13) INITIAL('SOURCE LEVEL ');\n   DECLARE J            FIXED BINARY(15);\n\n   ON ENDFILE(SOURCE)\n     GO TO SOURCE_ALL_IN;\n\n   DO WHILE('1'B);\n     READ FILE(SOURCE) SET(IP);\n     EMPTY_MEMBER = '0'B;\n     J = INDEX(INCARD,TRIGGER_1B);\n     IF SUBSTR(INCARD,1,LENGTH(TRIGGER_1A))=TRIGGER_1A &\n        J>LENGTH(TRIGGER_1A)+1\n       THEN\n         DO;\n           SUBSTR(INCARD,J+LENGTH(TRIGGER_1B),LENGTH(ID_STRING)) =\n               ID_STRING;\n           REWRITE FILE(SOURCE);\n           RETURN;\n         END;\n   END;\n\n SOURCE_ALL_IN:\n   IF \u00acEMPTY_MEMBER\n     THEN\n       CALL SET_RETURN_CODE(8,'LMFX104E');\n\n END PROCESS_CNTL;\n %PAGE;\n /********************************************************************/\n /*   PROCESS PLI SOURCE MODULE                                      */\n /********************************************************************/\n\n PROCESS_PLI: PROCEDURE;\n\n /********************************************************************/\n /*DECLARE SOURCE_LEVEL CHARACTER(40) STATIC                         */\n /*        INITIAL('MMMMMMMM VNN.MNN YY/MM/DD HH:MM UUUUUUUU');      */\n /* /* SOURCE LEVEL MMMMMMMM VNN.MNN YY/MM/DD HH:MM UUUUUUUU         */\n /*                 MODULE   VER/MOD   DATE   TIME  USER NAME        */\n /********************************************************************/\n\n   DECLARE TRIGGER_1A   CHARACTER(21)\n                        INITIAL('DECLARE SOURCE_LEVEL '),\n           TRIGGER_1B   CHARACTER( 9) INITIAL('INITIAL(''');\n   DECLARE TRIGGER_2A   CHARACTER( 2) INITIAL('/*'),\n           TRIGGER_2B   CHARACTER(13) INITIAL('SOURCE LEVEL ');\n\n   DECLARE NEW_TRIGGER_1 CHARACTER(44)\n           INITIAL('   DECLARE SOURCE_LEVEL CHARACTER(40) STATIC');\n\n   DECLARE TRIGGERED_1A BIT(1) INITIAL('0'B);\n   DECLARE (I,J)        FIXED BINARY(15);\n\n   ON ENDFILE(SOURCE)\n     GO TO SOURCE_ALL_IN;\n\n PLI_READ_LOOP:\n   DO WHILE('1'B);\n     READ FILE(SOURCE) SET(IP);\n     EMPTY_MEMBER = '0'B;\n     IF TRIGGERED_1A\n       THEN\n         IF INDEX(INCARD,TRIGGER_1B)\u00ac=0\n           THEN\n             DO;\n               SUBSTR(INCARD,1,72) =\n                    '           INITIAL('''  || ID_STRING || ''');' ;\n               REWRITE FILE(SOURCE);\n               NEEDASM = 'YES';\n               RETURN;\n             END;\n           ELSE\n             LEAVE PLI_READ_LOOP;\n     IF INDEX(INCARD,TRIGGER_1A)\u00ac=0\n       THEN\n         DO;\n           TRIGGERED_1A = '1'B;\n           SUBSTR(INCARD,1,72) = NEW_TRIGGER_1;\n           REWRITE FILE(SOURCE);\n         END;\n       ELSE\n         DO;\n           I = INDEX(INCARD,TRIGGER_2A);\n           J = INDEX(INCARD,TRIGGER_2B);\n           IF I>0 & J>I\n             THEN\n               DO;\n                 SUBSTR(INCARD,J+LENGTH(TRIGGER_2B),LENGTH(ID_STRING)) =\n                     ID_STRING;\n                 REWRITE FILE(SOURCE);\n                 RETURN;\n               END;\n         END;\n   END;\n\n SOURCE_ALL_IN:\n   IF \u00acEMPTY_MEMBER\n     THEN\n       CALL SET_RETURN_CODE(8,'LMFX104E');\n\n END PROCESS_PLI;\n %PAGE;\n /********************************************************************/\n /*   PROCESS SCRIPT MODULE                                          */\n /********************************************************************/\n\n PROCESS_SCRIPT: PROCEDURE;\n\n /********************************************************************/\n /* .cm source level MMMMMMMM VNN.MNN YY/MM/DD HH:MM UUUUUUUU        */\n /*                  MODULE   VER/MOD   DATE   TIME  USER NAME       */\n /********************************************************************/\n\n   DECLARE TRIGGER_1A   CHARACTER( 3) INITIAL('.cm'),\n           TRIGGER_1B   CHARACTER(13) INITIAL('source level ');\n   DECLARE j            FIXED BINARY(15);\n\n   ON ENDFILE(SOURCE)\n     GO TO SOURCE_ALL_IN;\n\n   DO WHILE('1'B);\n     READ FILE(SOURCE) SET(IP);\n     EMPTY_MEMBER = '0'B;\n     J = INDEX(INCARD,TRIGGER_1B);\n     IF SUBSTR(INCARD,1,LENGTH(TRIGGER_1A))=TRIGGER_1A &\n        J>LENGTH(TRIGGER_1A)\n       THEN\n         DO;\n           SUBSTR(INCARD,J+LENGTH(TRIGGER_1B),LENGTH(ID_STRING)) =\n               ID_STRING;\n           REWRITE FILE(SOURCE);\n           RETURN;\n         END;\n   END;\n\n SOURCE_ALL_IN:\n   IF \u00acEMPTY_MEMBER\n     THEN\n       CALL SET_RETURN_CODE(8,'LMFX104E');\n\n END PROCESS_SCRIPT;\n %PAGE;\n /********************************************************************/\n /*   DEFINE AND INITIALIZE ISPF POOL VARIABLES                      */\n /********************************************************************/\n\n INITIALIZE_POOL_VARIABLES: PROCEDURE;\n\n   L = LENGTH(ZLFPRJ );\n   CALL ISPLINK('VDEFINE','ZLFPRJ  ',ZLFPRJ ,'CHAR',L,\n                '(COPY NOBSCAN)');\n   L = LENGTH(ZLFGRP );\n   CALL ISPLINK('VDEFINE','ZLFGRP  ',ZLFGRP ,'CHAR',L,\n                '(COPY NOBSCAN)');\n   L = LENGTH(ZLFTYP );\n   CALL ISPLINK('VDEFINE','ZLFTYP  ',ZLFTYP ,'CHAR',L,\n                '(COPY NOBSCAN)');\n   L = LENGTH(ZLFMEM );\n   CALL ISPLINK('VDEFINE','ZLFMEM  ',ZLFMEM ,'CHAR',L,\n                '(COPY NOBSCAN)');\n   L = LENGTH(ZLTTYP );\n   CALL ISPLINK('VDEFINE','ZLTTYP  ',ZLTTYP ,'CHAR',L,\n                '(COPY NOBSCAN)');\n   L = LENGTH(ZLTMEM );\n   CALL ISPLINK('VDEFINE','ZLTMEM  ',ZLTMEM ,'CHAR',L,\n                '(COPY NOBSCAN)');\n\n   L = LENGTH(DATAID );\n   CALL ISPLINK('VDEFINE','DATAID ',DATAID,'CHAR',L);\n   L = LENGTH(LRECL  );\n   CALL ISPLINK('VDEFINE','LRECL  ',LRECL ,'CHAR',L);\n   L = LENGTH(RECFM  );\n   CALL ISPLINK('VDEFINE','RECFM  ',RECFM ,'CHAR',L);\n   CALL ISPLINK('LMINIT','DATAID ',ZLFPRJ,ZLFGRP,' ',' ',' ',ZLFTYP);\n   CALL ISPLINK('LMOPEN',DATAID);\n   CALL ISPLINK('LMMFIND',DATAID,ZLFMEM,' ','LRECL ','RECFM ',\n                 ' ','YES');\n\n   L = LENGTH(ZLVERS );\n   CALL ISPLINK('VDEFINE','ZLVERS  ',ZLVERS ,'CHAR',L,\n                '(COPY NOBSCAN)');\n   L = LENGTH(ZLMOD  );\n   CALL ISPLINK('VDEFINE','ZLMOD   ',ZLMOD  ,'CHAR',L,\n                '(COPY NOBSCAN)');\n   L = LENGTH(ZLMDATE);\n   CALL ISPLINK('VDEFINE','ZLMDATE ',ZLMDATE,'CHAR',L,\n                '(COPY NOBSCAN)');\n   L = LENGTH(ZLMTIME);\n   CALL ISPLINK('VDEFINE','ZLMTIME ',ZLMTIME,'CHAR',L,\n                '(COPY NOBSCAN)');\n   L = LENGTH(ZLUSER );\n   CALL ISPLINK('VDEFINE','ZLUSER  ',ZLUSER ,'CHAR',L,\n                '(COPY NOBSCAN)');\n\n   CALL ISPLINK('LMCLOSE',DATAID);\n   CALL ISPLINK('LMFREE', DATAID);\n\n   L = LENGTH(RC);\n   CALL ISPLINK('VDEFINE','RC '     ,RC     ,'CHAR',L);\n   L = LENGTH(MSG);\n   CALL ISPLINK('VDEFINE','MSG '    ,MSG    ,'CHAR',L);\n   L = LENGTH(NEEDASM);\n   CALL ISPLINK('VDEFINE','NEEDASM ',NEEDASM,'CHAR',L);\n\n END INITIALIZE_POOL_VARIABLES;\n %PAGE;\n /********************************************************************/\n /*   SET RETURN CODE AND REASON TEXT STRING POOL VARIABLE           */\n /********************************************************************/\n\n SET_RETURN_CODE: PROCEDURE(RETURN_CODE,MESSAGE_ID);\n\n   DECLARE RETURN_CODE  FIXED BINARY(31),\n           MESSAGE_ID   CHARACTER(8);\n\n   RC  = RETURN_CODE;\n   MSG = MESSAGE_ID;\n\n   CALL ISPLINK('VPUT','MSG ','SHARED');\n   CALL ISPLINK('VPUT','RC ' ,'SHARED');\n\n END SET_RETURN_CODE;\n %SKIP(3);\n END SRCDOC;\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SUBAUTHX": {"ttr": 10247, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x01\\x05\\x01\\x05\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 261, "newlines": 261, "modlines": 0, "user": "FILE369"}, "text": "         TITLE 'SUBAUTHX - CHECK FOR AUTHORIZED JOB SUBMISSION PROGRAM'\n***********************************************************************\n*                                                                     *\n* NAME         SUBAUTHX                                               *\n*                                                                     *\n* COMPONENT    JES2 EXIT FOR ACF2                                     *\n*                                                                     *\n* FUNCTION     CHECK FOR AUTHORIZED JOB SUBMISSION PROGRAM            *\n*                                                                     *\n* ENTRY        AS EXIT 221 FROM HASPSSSM                              *\n*                                                                     *\n* PARAMETERS   DCT                                                    *\n*                                                                     *\n* INPUT        MVS AND JES CONTROL BLOCKS                             *\n*                                                                     *\n* OUTPUT       FLAG SET IN ACF2 DCT EXTENSION                         *\n*                                                                     *\n* RETURN CODES ZERO                                                   *\n*                                                                     *\n* FILES        NONE                                                   *\n*                                                                     *\n* EXT REF      NONE                                                   *\n*                                                                     *\n* MESSAGES     NONE                                                   *\n*                                                                     *\n* MACROS       $MODULE                                                *\n*              $ENTRY                                                 *\n*              $MODEND                                                *\n*              #ACFJES2                                               *\n*              MODESET                                                *\n*              RETURN                                                 *\n*              SAVE                                                   *\n*                                                                     *\n* ACF2 TABLES  ACFDCTX             DEVICE CONTROL TABLE EXTENSION     *\n*                                                                     *\n* JES2 TABLES  DCT                 DEVICE CONTROL TABLE               *\n*              SDB                 SUBSYSTEM DATASET BLOCK            *\n*                                                                     *\n* MVS  TABLES  CDE                 CONTENTS DATA ENTRY                *\n*              PSA                 PREFIX SAVE AREA                   *\n*              RB                  REQUEST BLOCK                      *\n*              TCB                 TASK CONTROL BLOCK                 *\n*                                                                     *\n* OPERATION    IF THE SUBMITTING PROGRAM IS REENTRANT AND COMES       *\n*              FROM AN APF-AUTHORIZED LIBRARY, THE BIT IN THE ACF2    *\n*              DCT EXTENSION IS SET TO ALLOW THE 'SUBAUTH'            *\n*              RESTRICTION TO BE MET.                                 *\n*                                                                     *\n* ATTRIBUTES   REENTRANT                                              *\n*              REUSABLE                                               *\n*              SUPERVISOR STATE                                       *\n*              PROBLEM PROGRAM KEY                                    *\n*              AUTHORIZED                                             *\n*              LPALIB                                                 *\n*              AMODE 24                                               *\n*              RMODE 24                                               *\n*                                                                     *\n* RESTRICTIONS MUST BE IN LPA SINCE IT IS INVOKED FROM HASPSSSM       *\n*              IN THE USER'S ADDRESS SPACE DURING INTRDR OPEN.        *\n*                                                                     *\n*              MUST BE INVOKED AT ACF2 EXIT POINT 221 AFTER ACF2XIRD. *\n*                                                                     *\n*              THE RBCDE POINTER MAY POINT TO EITHER A CDE OR A LPDE. *\n*              THE FIELDS CHECKED HERE ARE THE SAME IN BOTH,          *\n*              SO ONLY THE CDE NAMES ARE USED.                        *\n*                                                                     *\n* NOTES        THIS EXIT EXTENDS THE FUNCTIONS PROVIDED BY ACF2       *\n*              EXIT ACF2XIRD (INTERNAL READER OPEN) PACKAGED IN       *\n*              LOAD MODULE ACF2X1J2. THE EXIT POINT IS INSERTED IN    *\n*              HASPSSSM AS PART OF ACF2 INSTALLATION (RELEASE 4.0).   *\n*              THE ORIGINAL EXIT IS DESIGNED TO CAPTURE THE           *\n*              SUBMITTING ENVIRONMENT WHEN INTRDR IS OPENED. THE      *\n*              PROGRAM NAME AND IT'S APF AUTHORIZATION ARE AMONG      *\n*              THE DATA PRESERVED. THESE DATA ARE THEN USED DURING    *\n*              ACF2 ENTRY VALIDATION, USUALLY FOR A LID WITH THE      *\n*              RESTRICT ATTRIBUTE. THE PROGRAM NAME IS MATCHED WITH   *\n*              THE PROGRAM SPECIFIED IN THE LID, AND APF              *\n*              AUTHORIZATION IS REQUIRED IF THE LID ALSO HAS          *\n*              SUBAUTH SPECIFIED.                                     *\n*                                                                     *\n*              A PROBLEM COMES ABOUT WHEN USING ISPF V2R2M0. AN       *\n*              AUTHORIZED PROGRAM CANNOT ISSUE ISPF SERVICE CALLS.    *\n*              TO SUPPORT THE ACFFTSUB LOCAL UTILITY, WE RELAX THE    *\n*              SUBAUTH DEFINITION SO THAT THE PROGRAM NEED ONLY       *\n*              COME FROM AN APF AUTHORIZED LIBRARY. IT NEED NOT       *\n*              ACTUALLY BE EXECUTING AUTHORIZED, BUT THAT IS OKAY     *\n*              TOO.                                                   *\n*                                                                     *\n*              TO GUARD AGAINST SOMEONE MUCKING WITH THE EXECUTION    *\n*              ENVIRONMENT, WE ALSO REQUIRE THE PROGRAM BE            *\n*              REENTRANT. THIS SHOULD PRECLUDE SOMEONE LOADING        *\n*              A PROGRAM FROM AN AUTHORIZED LIBRARY AND MODIFYING     *\n*              IT WHILE IT IS IN MEMORY SINCE REENTRANT PROGRAMS ARE  *\n*              LOADED INTO KEY ZERO STORAGE. THERE IS A SIMILAR CHECK *\n*              OF A HANDY FLAG IN THE CDE TO MAKE SURE THE ENTRY      *\n*              POINT WAS NOT CREATED BY AN UNAUTHORIZED IDENTIFY.     *\n*                                                                     *\n*              THERE IS AN IMPLICIT PRESUMPTION HERE THAT ALL APF     *\n*              AUTHORIZED LIBRARIES HAVE GOOD UPDATE/ALLOCATE         *\n*              CONTROLS.                                              *\n*                                                                     *\n* PROGRAMMER   C. J. PITTS                                            *\n*                                                                     *\n* MAINTENANCE  WHO    DATE     DESCRIPTION                            *\n*                                                                     *\n**********************************************************************/\n*                                                                     *\n* REGISTERS AT ENTRY                                                  *\n*              R10   DCT OR SDB                                       *\n*              R11   SSVT                                             *\n*              R13   OS SAVE AREA                                     *\n*              R14   RETURN ADDRESS                                   *\n*              R15   ENTRY POINT                                      *\n*                                                                     *\n* REGISTER USE IN PROGRAM                                             *\n*              R10   ACF2 DCT EXTENSION                               *\n*              R11   SSVT                                             *\n*              R12   BASE REGISTER                                    *\n*              R13   OS SAVE AREA                                     *\n*                                                                     *\n* REGISTERS AT EXIT                                                   *\n*              R15   RETURN CODE                                      *\n*                                                                     *\n**********************************************************************/\n         SPACE 3\n*        COPY  $HASPGBL\n*        COPY  #ACFVAR\n         PRINT OFF\n         COPY  $HASPGBL\n         COPY  #ACFVAR\n         PRINT ON,NOGEN\n         #ACFJES2\n         SPACE\n         #ACFDCTX\n         PRINT GEN\n         SPACE\nSUBAUTHX $MODULE SYSP=(NOGEN,GEN,NODATA,NOGEN,NOGEN),                  X\n               TITLE='SUBAUTHX - CHECK FOR AUTHORIZED JOB SUBMISSION PRX\n               OGRAM',             LISTING TITLE                       X\n               ENVIRON=USER,       HASPSSSM EXIT ENVIRONMENT           X\n               $BUFFER,            IO BUFFER DSECT                     X\n               $CAT,               CLASS ATTRIBUTE TABLE               X\n               $DCT,               DEVICE CONTROL TABLE                X\n               $HASPEQU,           REGISTER EQUATES, ETC               X\n               $HCT,               HASP COMMUNICATIONS TABLE           X\n               $JCT,               JOB CONTROL TABLE                   X\n               $JQE,               JOB QUEUE ELEMENT                   X\n               $MIT,               MODULE INFORMATION TABLE            X\n               $PCE,               PROCESSOR CONTROL ELEMENT           X\n               $SDB,               SUBSYSTEM DATASET BLOCK             X\n               $TAB,               TRACK ALLOCATION BLOCK              X\n               $XECB,              EXTENDED ECB                        X\n               CDE,                CONTENTS DATA ENTRY                 X\n               PSA,                PREFIX SAVE AREA                    X\n               RB,                 REQUEST BLOCK                       X\n               TCB                 TASK CONTROL BLOCK\n         EJECT\n***********************************************************************\n* AUTHX221:                                  /*  JES ENTRY POINT  */  *\n*        SAVE REGISTERS;                                              *\n*        SET BASE REGISTER;                                           *\n*        IF DCT WAS NOT PASSED                                        *\n*          THEN GO RETURN TO CALLER;                /*  AUTH9000  */  *\n*        LOCATE ACF2 DCT EXTENSION;                                   *\n*        IF NOT AVAILABLE                                             *\n*          THEN GO RETURN TO CALLER;                /*  AUTH9000  */  *\n*        IF AUTHORIZATION FLAG IS ALREADY SET IN DCT EXTENSION        *\n*          THEN GO RETURN TO CALLER;                /*  AUTH9000  */  *\n***********************************************************************\n         SPACE\nAUTHX221 $ENTRY BASE=R12,CSECT=NO,ENTRY=YES\n         SPACE\n         SAVE (14,12)\n         SPACE\n         LR    R12,R15             SET BASE REGISTER\n         SPACE\n         USING SDBDSECT,R10\n         CLC   SDBID,=CL4'SDB'     WAS AN SDB PASSED?\n         BE    AUTH9000            YEP...GO EXIT\n         SPACE\n         USING DCTDSECT,R10\n         ICM   R10,B'1111',&ACF2DCT GET ACF2 DCT EXTENSION\n         BZ    AUTH9000            NOT THERE...GO EXIT\n         USING #ACFDCTX,R10\n         CLC   #ACFD,=CL4'ACFD'    CHECK EYECATCHER\n         BNE   AUTH9000            NO GOT...GO EXIT\n         SPACE\n         TM    #ACDFLAG,#ACDAUTH   ALREADY AUTHORIZED?\n         BO    AUTH9000            YEP...GO EXIT\n         EJECT\n***********************************************************************\n*        LOCATE TCB VIA PSATOLD;                                      *\n*        LOCATE TOP PRB ON TCB;                                       *\n*        IF TOP RB IS NOT A PRB                                       *\n*          THEN GO RETURN TO CALLER;                /*  AUTH9000  */  *\n*        LOCATE CDE/LPDE FROM PRB;                                    *\n*        IF CDE/LPDE DOES NOT EXIST                                   *\n*          THEN GO RETURN TO CALLER;                /*  AUTH9000  */  *\n*        IF PROGRAM IS REENTRANT                           -- AND --  *\n*           ENTRY POINT IS NOT FROM UNAUTHORIZED IDENTIFY  -- AND --  *\n*           PROGRAM NAME MATCHES THE DCT EXTENSION         -- AND --  *\n*           PROGRAM COMES FROM APF-AUTHORIZED LIBRARY                 *\n*          THEN SET AUTHORIZED SOURCE FLAG IN DCT EXTENSION;          *\n***********************************************************************\n         SPACE\n         USING PSA,R0\n         L     R9,PSATOLD          GET TCB ADDRESS\n         USING TCB,R9\n         L     R9,TCBRBP           CURRENT RB\n         USING RBBASIC,R9\n         SPACE\nAUTH2200 DS    0H\n         TM    RBSTAB2,RBTCBNXT    TOP RB?\n         BO    AUTH2400            YEP...ONWARD\n         L     R9,RBLINK           NEXT RB\n         B     AUTH2200            TRY AGAIN\n         SPACE\nAUTH2400 DS    0H\n         TM    RBSTAB1,RBFTP       IS THE TOP RB A PRB?\n         BNZ   AUTH9000            NOPE...GO EXIT\n         ICM   R8,B'0111',RBCDE1   CDE/LPDE\n         BZ    AUTH9000            NOT THERE...GO EXIT\n         USING CDENTRY,R8\n         SPACE\n         CLC   #ACDPROG,CDNAME     PROGRAM NAME MATCH?\n         BNE   AUTH3800            NOPE...NOT AUTHORIZED\n         TM    CDATTRB,CDIDENTY    UNAUTHORIZED IDENTIFY?\n         BO    AUTH3800            YEP...NOT AUTHORIZED\n         TM    CDATTR,CDREN        REENTRANT?\n         BNO   AUTH3800            NOPE...NOT AUTHORIZED\n         TM    CDATTR2,CDSYSLIB    APF-AUTHORIZED LIBRARY?\n         BNO   AUTH3800            NOPE...NOT AUTHORIZED\n         SPACE\n         MODESET EXTKEY=ZERO,SAVEKEY=(2)\n         SPACE\n         OI    #ACDFLAG,#ACDAUTH   SET FLAG TO ALLOW SUBAUTH\n         SPACE\n         MODESET KEYREG=2\n         SPACE\nAUTH3800 DS    0H\n         EJECT\n***********************************************************************\n* AUTH9000:                                      /*  MODULE EXIT  */  *\n*        SET RETURN CODE ZERO;                                        *\n*        RESTORE REGISTERS;                                           *\n*        RETURN TO CALLER;                                            *\n***********************************************************************\n         SPACE\nAUTH9000 DS    0H\n         RETURN (14,12),RC=0\n         SPACE 2\n         LTORG\n         SPACE 3\n***********************************************************************\n*        JES EPILOGUE                                                 *\n***********************************************************************\n         SPACE\n         PRINT NOGEN\n         $MODEND\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TCAMFIX": {"ttr": 10497, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\x89\\x00\\x89\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 137, "newlines": 137, "modlines": 0, "user": "FILE369"}, "text": "PRC TITLE 'TCAMFIX - RESET THE CVTAQAVB FIELD SO TCAM WILL INITIALIZE.'\n********************************************************************\n*                                                                  *\n* NAME - TCAMFIX                                                   *\n*                                                                  *\n* DESCRIPTION - THIS ROUTINE CLEANS UP THE CVTAQAVB FIELD SO TCAM  *\n*   WILL INITIALIZE.  THE CVT-BASED TCAM IS SUPPOSED TO DO THIS WHE*\n*   IT TERMINATES, BUT IT ISN'T ALWAYS SO OBLIGING.  IF THE OPERATO*\n*   RESPONDS \"Y\" TO OUR MESSAGE IEDPRC1D, THEN WE ZERO THIS FIELD. *\n*                                                                  *\n* NOTE - WE MUST RUN APF-AUTHORIZED, AND WE CAN RUN AS A SUBTASK OF*\n*   THE TCAM INITIATOR.                                            *\n*                                                                  *\n* LOG -                                                            *\n*     DATE   WHO LV    CHANGE                                      *\n*   02/14/86 PTW 01 IMPLEMENTATION                                 *L01\n*                                                                  *\n********************************************************************\n         LCLC  &CSECT\n&CSECT   SETC  'TCAMFIX'\n&CSECT   CSECT ,\n********************************************************************\n*                                                                  *\n*        I N I T I A L I Z E                                       *\n*                                                                  *\n********************************************************************\n         PRINT NOGEN\n         SAVE  (14,12),,&CSECT-&SYSDATE-&SYSTIME\n         LR    R12,R15            ESTABLISH BASE.\n         USING &CSECT,R12         TELL ASSEMBLER.\n         GETMAIN RU,LV=DYNLEN     GET DYNAMIC AREA.\n         LR    R2,R13             SAVE AREA\n         LR    R13,R1             SAVE AREA\n         USING DYNAMIC,R13        TELL ASSEMBLER.\n         LA    R0,DYNAMIC         ZERO\n         LA    R1,DYNLEN            DYNAMIC\n         LR    R14,R0                 STORAGE.\n         SLR   R15,R15\n         MVCL  R0,R14             DO IT.\n         ST    R2,4(,R13)         BACK CHAIN.\n         ST    R13,8(,R2)         FORWARD CHAIN.\n         XC    RC,RC              ASSUME GOOD RC.\n         XC    ECB,ECB\n         MVC   WTOR(WTORL),XWTOR  INITIALIZE VARIABLES.\n         MVI   REPLY,C' '\n         MVC   REPLY+1(L'REPLY-1),REPLY\n********************************************************************\n*                                                                  *\n*        M A I N L I N E                                           *\n*                                                                  *\n********************************************************************\n         L     R2,FLCCVT-P             R2 = A(CVT).\n         SLR   R3,R3\n         ICM   R3,B'0111',CVTAQAVB-C(R2) IF OUR FIELD IS ZERO,\n         BZ    ITSZERO                   NO RESET REQUIRED, EXIT.\n         WTOR  ,REPLY,L'REPLY,ECB,MF=(E,WTOR) ELSE WTOR.\n         WAIT  ECB=ECB\n         OI    REPLY,C' '              FOLD TO UPPER CASE.\n         CLI   REPLY,C'Y'              IF NOT \"Y\",\n         BNE   NOGO                      THEN EXIT.\n         SLR   R3,R3\n         MODESET KEY=ZERO              ELSE, GET PRIVILIGED.\n         STCM  R3,B'0111',CVTAQAVB-C(R2) ZERO CVT FIELD.\n         MODESET KEY=NZERO\n         WTO   'IEDPRC2I CVTAQAVB IS RESET.  TCAM SHOULD RESTART NOW.',X\n               ROUTCDE=2\n********************************************************************\n*                                                                  *\n*        R E T U R N                                               *\n*                                                                  *\n********************************************************************\nRETURN   DS    0H\n         L     R2,RC                  R2 = RC.\n         LR    R1,R13              PREPARE\n         L     R13,4(,R13)         FOR FREEMAIN.\n         FREEMAIN RU,LV=DYNLEN,A=(1)\n         LR    R15,R2              AND RETURN\n         RETURN (14,12),RC=(15)      WITH R15 = RC.\n********************************************************************\n*                                                                  *\n*        E R R O R S                                               *\n*                                                                  *\n********************************************************************\nITSZERO  DS    0H\n         WTO   'IEDPRC3I CVTAQAVB FIELD IS ALREADY ZERO, NO ACTION TAKEX\n               N.',ROUTCDE=2\n         MVC   RC,=F'4'              R2 = RC.\n         B     RETURN\nNOGO     DS    0H\n         WTO   'IEDPRC4I OPERATOR REQUESTED NO CVTAQAVB RESET, NO ACTIOX\n               N TAKEN.',ROUTCDE=2\n         MVC   RC,=F'8'              R2 = RC.\n         B     RETURN\n********************************************************************\n*                                                                  *\n*        S T A T I C   A R E A S.                                  *\n*                                                                  *\n********************************************************************\nXWTOR    WTOR 'IEDPRC1D REPLY Y TO ZAP CVTAQAVB, ANYTHING ELSE TERMINATX\n               ES.',ROUTCDE=2,MF=L\nWTORL    EQU   *-XWTOR\n         LTORG ,\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   A R E A S.                                *\n*                                                                  *\n********************************************************************\nDYNAMIC  DSECT\nSAVE     DS    18F                     SAVE AREA.\nRC       DS    F                       RETURN CODE.\nECB      DS    F                       ECB FOR WTOR.\nWTOR     DS    XL(WTORL)               WTOR LIST.\nREPLY    DS    CL10                    REPLY AREA.\nDYNLEN   EQU   *-DYNAMIC               LENGTH.\n         PRINT OFF\nR0       EQU   00\nR1       EQU   01\nR2       EQU   02\nR3       EQU   03\nR4       EQU   04\nR5       EQU   05\nR6       EQU   06\nR7       EQU   07\nR8       EQU   08\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12                 PROGRAM BASE.\nR13      EQU   13                 A(SAVE AREA).\nR14      EQU   14\nR15      EQU   15\n         PRINT ON\n         CVT   DSECT=YES\nC        EQU   CVTMAP\n         IHAPSA\nP        EQU   PSA\n         END   &CSECT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TERME": {"ttr": 10500, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\x19\\x00\\x19\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "FILE369"}, "text": "         MACRO\n&NAME    TERME &RC=0\n* SOURCE LEVEL TERME    V01.M02 85/09/26 18:11 PSYRRS\n         GBLA  &SIZE\n         GBLB  &SASW\n         GBLC  &OPSYS        GLOABAL SWITCH TO DEFINE OPERATING SYSTEM\n         SPACE 1\n         AIF   ('&SASW' EQ '1' AND '&OPSYS' NE 'DOS').DYNMC\n&NAME    L     13,4(13)\n         AGO   .RET\n.DYNMC   ANOP\n&NAME    LR    1,13\n         L     13,4(13)\n         LR    2,15\n         FREEMAIN R,LV=&SIZE,A=(1)\n         LR    15,2\n.RET     ANOP\n         AIF   ('&OPSYS' EQ 'DOS').DOSRET\n         RETURN (14,12),T,RC=&RC\n         AGO   .EXIT\n.DOSRET  ANOP\n         RETURN (14,12)      RETURN TO CALLER\n.EXIT    ANOP\n         SPACE 1\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TLBLABEL": {"ttr": 10502, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00=\\x00=\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 61, "newlines": 61, "modlines": 0, "user": "FILE369"}, "text": "         MACRO\n         TLBLABEL\n.*             COPYRIGHT (C) 1987 PLANNING RESEARCH CORPORATION\n         TITLE 'TLBLABEL -- TAPE LABEL WRITER REQUEST BLOCK'\n***********************************************************************\n*                                                                     *\n* NAME         TLBLABEL                                               *\n*                                                                     *\n* COMPONENT    TAPE LABEL WRITER                                      *\n*                                                                     *\n* FUNCTION     REQUEST BLOCK FOR TAPE LABEL WRITER                    *\n*                                                                     *\n* ATTRIBUTES   CSA SUBPOOL                                            *\n*              NOT FETCH PROTECTED                                    *\n*              KEY ZERO                                               *\n*              EXPLICITLY ALLOCATED AND FREED                         *\n*                                                                     *\n* NOTES        ANCHORED IN TLBLCVT.                                   *\n*              CREATED BY MESSAGE EXIT ROUTINE TLBLMXIT FROM IEC705I. *\n*              FREED BY TLBLMAIN AFTER WRITE.                         *\n*                                                                     *\n* PROGRAMMER   C. J. PITTS                                            *\n*                                                                     *\n* MAINTENANCE  WHO   DATE      DESCRIPTION                            *\n*              CJP   12/29/86  ADDED SUPPORT FOR JES JOB ID           *\n*              CJP    3/10/87  ADDED SPACE FOR REEL NUMBER AND SOME   *\n*                              RESERVED SPACE.                        *\n*                                                                     *\n**********************************************************************/\n         SPACE\nTLBLABEL DSECT\nLABELEYE DC    C'LABL'\n         SPACE\nLABELNXT DS    A                   POINTER TO NEXT TLBLABEL\n         SPACE\nLABELTIM DS    PL4                 TIME IN PACKED FORM\nLABELDAT DS    PL4                 DATE IN PACKED FORM\n         SPACE\nLABELCHR EQU   *                   START OF AREA TO INIT TO BLANKS\nLABELDEV DS    CL4                 DEVICE NUMBER\nLABELTYP DS    CL4                 LABEL TYPE\nLABELDEN DS    CL4                 TAPE DENSITY\nLABELJOB DS    CL8                 JOBNAME\nLABELJID DS    CL8                 JES JOB ID\nLABELSTP DS    CL8                 STEPNAME\nLABELDSN DS    CL44                DSNAME\nLABELLID DS    CL8                 ACF2 LID (USER)\nLABELSIT DS    CL4                 SITE NAME\nLABELSER DS    CL6                 VOLUME SERIAL\nLABELVNO DS    CL3                 VOLUME SEQUENCE NUMBER\n         DS    0F,CL16             RESERVED\nLABELCHL EQU   *-LABELCHR          LENGTH OF BLANK AREA\n         SPACE\nLABELADD DS    H                   ITERATION COUNTER FOR ADD TO CHAIN\nLABELDEL DS    H                   ITERATION COUNTER FOR DEL FROM CHAIN\n         DS    4F                  RESERVED\n         SPACE\nLABELLEN EQU   *-TLBLABEL          LENGTH OF TLBLABEL\nLABELSBP EQU   241                 SUBPOOL FOR TLBLABEL\n         SPACE\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TLBLCVT": {"ttr": 10504, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00.\\x00.\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "FILE369"}, "text": "         MACRO\n         TLBLCVT\n.*             COPYRIGHT (C) 1987 PLANNING RESEARCH CORPORATION\n         TITLE 'TLBLCVT -- VECTOR TABLE FOR LABEL WRITER'\n***********************************************************************\n*                                                                     *\n* NAME         TLBLCVT                                                *\n*                                                                     *\n* COMPONENT    TAPE LABEL WRITER                                      *\n*                                                                     *\n* FUNCTION     STORAGE ANCHORS FOR CROSS-MEMORY                       *\n*                                                                     *\n* ATTRIBUTES   CSA SUBPOOL                                            *\n*              NOT FETCH PROTECTED                                    *\n*              KEY ZERO                                               *\n*              EXPLICITLY ALLOCATED AND FREED                         *\n*                                                                     *\n* NOTES        ANCHORED BY SSCTSUSE IN SSCVT.                         *\n*              INITIALIZED ON FIRST START OF SUBSYSTEM.               *\n*              LOCATED AND RECLAIMED ON RESTART OF SUBSYSTEM.         *\n*              NEVER FREED.                                           *\n*                                                                     *\n* PROGRAMMER   C. J. PITTS                                            *\n*                                                                     *\n* MAINTENANCE  WHO    DATE     DESCRIPTION                            *\n*                                                                     *\n**********************************************************************/\n         SPACE\nTLBLCVT  DSECT\nTLBLEYE  DC    C'TLBL'\n         SPACE\nTLBLASCB DS    A                   ADDRESS SPACE CONTROL BLOCK - MAIN\nTLBLECB  DS    F                   WORK-TO-DO ECB\nTLBLEXEP DS    A                   MSG EXIT PGM ENTRY PT (DEBUGGING)\n         SPACE\nTLBLQNAM DS    CL8                 QNAME FOR ACTIVE ENQ LOCK\nTLBLRNAM DC    CL6'ACTIVE'         RNAME FOR ACTIVE ENQ LOCK\n         SPACE\nTLBLPTRS DS    0D                  ANCHORS FOR LABEL BLOCKS -- DW ALIGN\nTLBLHEAD DS    A                   FIRST BLOCK\nTLBLTAIL DS    A                   LAST BLOCK\n         SPACE\nTLBLLEN  EQU   *-TLBLCVT\nTLBLSUBP EQU   241                 SUBPOOL FOR TLBLCVT\n         SPACE\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TLBLMAIN": {"ttr": 10506, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x07\\x07\\x07\\x07\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 1799, "newlines": 1799, "modlines": 0, "user": "FILE369"}, "text": "         TITLE 'TLBLMAIN -- MAIN MODULE FOR TAPE LABEL WRITER'\n***********************************************************************\n*                                                                     *\n* NAME         TLBLMAIN                                               *\n*                                                                     *\n* COMPONENT    TAPE LABEL WRITER                                      *\n*                                                                     *\n* FUNCTION     PROCESS REQUESTS TO PRINT EXTERNAL TAPE LABELS         *\n*                                                                     *\n* ENTRY        JCL EXEC STATEMENT                                     *\n*                                                                     *\n* PARAMETERS   THE FOLLOWING PARAMETERS MAY BE PASSED THROUGH THE     *\n*              EXEC STATEMENT OR INTERNAL EQUIVALENT. THE PARAMETERS  *\n*              ARE POSITIONAL. SIGNIFY AN OMITTED PARAMETER WITH      *\n*              ','. UNNEEDED PARAMETERS AT THE END OF THE LIST        *\n*              NEED NOT BE CODED.                                     *\n*                                                                     *\n*              PRINTER VTAM LU       - <NAME>                         *\n*              START TYPE            - HOT  | WARM  | COLD            *\n*              INITIAL PRINTER STATE - STOP | START | VERIFY          *\n*              LOGON MODE SET NAME   - <NAME>                         *\n*                                                                     *\n*              THE DEFAULT STRING IS: ',HOT,VERIFY,DSILGMOD'          *\n*                                                                     *\n*              THE LU NAME MUST ALWAYS BE SPECIFIED.                  *\n*                                                                     *\n*              A HOT START WILL PRESERVE THE CONTENTS OF THE          *\n*              WORK QUEUE. A WARM START WILL DEQUEUE AND FREEMAIN     *\n*              ALL QUEUED WORK. A COLD START ZEROS OUT THE            *\n*              WORK QUEUE ANCHORS. COLD START SHOULD ONLY BE USED     *\n*              IN THE EVENT OF A PROBLEM WITH THE CHAINING OF QUEUE   *\n*              BLOCKS.                                                *\n*                                                                     *\n* INPUT        QUEUED REQUEST FOR A LABEL                             *\n*                                                                     *\n*              OPERATOR COMMANDS  - F <NAME>,DQ                       *\n*                                 - F <NAME>,PURGE                    *\n*                                 - F <NAME>,START                    *\n*                                 - F <NAME>,STATE  (S FOR SHORT)     *\n*                                 - F <NAME>,STOP                     *\n*                                 - F <NAME>,VERIFY (V FOR SHORT)     *\n*                                 - P <NAME>                          *\n*                                                                     *\n* OUTPUT       LABEL PRINTED ON 328X-TYPE PRINTER VIA VTAM            *\n*                                                                     *\n* RETURN CODES 0                                                      *\n*                                                                     *\n* FILES        NONE                                                   *\n*                                                                     *\n* EXT REF      NONE                                                   *\n*                                                                     *\n* MESSAGES     TAPE LABEL WRITER INITIALIZATION COMPLETE              *\n*              PARM LUNAME NOT SPECIFIED                              *\n*              PARM START TYPE INVALID - MUST BE HOT, WARM OR COLD    *\n*              PARM INITIAL STATE INVALID - MUST BE START,STOP OR VFY *\n*              LU NAME=<LU>  START TYPE=<TYPE>  INITIAL STATE=<STATE> *\n*              UNABLE TO GET ACTIVE LOCK                              *\n*              LU=<LU>  STATE=<STATE>                                 *\n*              ERROR OPENING VTAM ACB  R15=<R15>  ACBERFLG=<>         *\n*              VTAM RPL REQUEST ERROR  R15=<R15>  RPLREQ=<>           *\n*                         RPLRTNCD=<>  RPLFDB2=<> SENSE=<SENSE>       *\n*              INVALID OPERATOR COMMAND: <COMMAND>                    *\n*              OPERATOR COMMAND COMPLETED: <COMMAND>                  *\n*              STOP COMMAND ACCEPTED                                  *\n*              <CNT> TAPE LABELS CURRENTLY QUEUED                     *\n*              TLBL VTAM <EXIT> EXIT ENTERED -- REASON=<>             *\n*                                                                     *\n* ABENDS       U1001  -- UNABLE TO LOCATE SSCVT                       *\n*                                                                     *\n* MACROS       ABEND                                                  *\n*              CLOSE                                                  *\n*              CLSDEST                                                *\n*              DEQ                                                    *\n*              ENQ                                                    *\n*              EXTRACT                                                *\n*              EXLST                                                  *\n*              FREEMAIN                                               *\n*              GETMAIN                                                *\n*              MODESET                                                *\n*              OPEN                                                   *\n*              OPNDST                                                 *\n*              QEDIT                                                  *\n*              REGS                                                   *\n*              RETURN                                                 *\n*              SAVE                                                   *\n*              SIMLOGON                                               *\n*              SEND                                                   *\n*              SPOST                                                  *\n*              TIME                                                   *\n*              WAIT                                                   *\n*              WTO                                                    *\n*                                                                     *\n* TABLES       ACB        -- IFGACB                                   *\n*              ASCB       -- IHAASCB                                  *\n*              CIB        -- IEZCIB                                   *\n*              COMMD      -- IEZCOM                                   *\n*              CVT                                                    *\n*              ECB        -- IHAECB                                   *\n*              JESCT      -- IEFJESCT                                 *\n*              NIB        -- ISTDNIB                                  *\n*              RPL        -- IFGRPL                                   *\n*              SSCVT      -- IEFJSCVT                                 *\n*              TLBLABEL                                               *\n*              TLBLCVT                                                *\n*              PSA        -- IHAPSA                                   *\n*                                                                     *\n* OPERATION    |                                                      *\n*                                                                     *\n* ATTRIBUTES   NOT REENTRANT                                          *\n*              NOT REUSABLE                                           *\n*              AMODE 31                                               *\n*              RMODE 24                                               *\n*              AUTHORIZED                                             *\n*              PROBLEM PROGRAM KEY                                    *\n*              SUPERVISOR STATE                                       *\n*                                                                     *\n* RESTRICTIONS THE VTAM RELEASE 2 AVAILABLE AT THIS TIME DOES NOT     *\n*              SUPPORT 31 BIT AMODE. THE SUBROUTINES WHICH ISSUE      *\n*              VTAM MACROS (OPENPR, CLOSEPR, WRITEPR, RPLERR)         *\n*              GO INTO 24 BIT MODE AND RETURN BY USING A BSM.         *\n*              BE VERY CAREFUL TO CHECK THE PATHS THROUGH THESE       *\n*              ROUTINES IF ANY CHANGES ARE MADE.                      *\n*                                                                     *\n* NOTES        EXTERNAL LABEL FORMAT                                  *\n*                                                                     *\n*                      123456789012345678901234567890123              *\n*                    1               XXXXXX                           *\n*                    2                                                *\n*                    3 UNIT XXXX  REEL XXX  DEN XXXX                  *\n*                    4 ACF2 USER XXXXXXXX  LABEL XXXX                 *\n*                    5 TIME XX.XXX XX:XX:XX  SITE XXXX                *\n*                    6 JOB XXXXXXXX(XXXXX) STEP XXXXXXXX              *\n*                    7 DSNAME XXXXXXXXXXXXXXXXXXXXXXXXXX              *\n*                    8                XXXXXXXXXXXXXXXXXX              *\n*                                                                     *\n*              ALTHOUGH THERE IS LOGIC IN HERE WHICH REFERENCES       *\n*              SUBSYSTEM TABLES, THE TAPE LABEL WRITER IS NOT A       *\n*              FORMAL SUBSYSTEM; IT NEVER ACTIVATES A SSVT SO IT      *\n*              MAKES NO USE OF SUBSYSTEM REQUEST ROUTING. THE SSCT    *\n*              USER FIELD IS USED AS A CONVENIENT ANCHOR FOR CSA      *\n*              CONTROL BLOCKS.                                        *\n*                                                                     *\n*              IT IS BEST IF THE JOB NAME USED FOR THIS PROGRAM       *\n*              IS NOT THE SAME AS THE SUBSYSTEM NAME IN THE SSCT      *\n*              IF THEY ARE THE SAME, THE MASTER SCHEDULER WILL        *\n*              START IT AS A SUBSYSTEM, WHICH MEANS ALL DATASETS      *\n*              IN THE JCL MUST EITHER HAVE EXPLICIT UNIT AND VOLUME   *\n*              OR BE IN MASTER CATALOG, AND THERE CAN BE NO SYSOUT    *\n*              PRODUCED (SYSUDUMP, SYSMSG AND JOBLOG, FOR INSTANCE).  *\n*                                                                     *\n*              THE LOGIC IS ARRANGED TO GO THROUGH THE MAIN LOOP      *\n*              CONTROL AFTER EACH LABEL IS PRINTED TO ALLOW FOR       *\n*              PROCESSING OF OPERATOR COMMANDS BETWEEN LABELS.        *\n*                                                                     *\n*              THE VTAM APPLICATION NAME IS HARD-CODED AS             *\n*              'TAPELABL'. CHANGE IT IF NECESSARY AT LABEL            *\n*              APPLNAME.                                              *\n*                                                                     *\n*              SIMILARLY, THE SUBSYSTEM NAME CAN BE FOUND AT          *\n*              LABEL 'SSNAME'. THIS NAME IS ALSO USED FOR THE         *\n*              ENQ MAJOR NAME.                                        *\n*                                                                     *\n* PROGRAMMER   C. J. PITTS                                            *\n*                                                                     *\n* MAINTENANCE  WHO   DATE      DESCRIPTION                            *\n*              CJP   12/30/86  ADDED SUPPORT FOR JES JOBLOG ID        *\n*                              AND ADDED VTAM EXITS FOR ABNORMAL      *\n*                              TERMINATION CONDITIONS.                *\n*              CJP    3/10/87  ADDED SUPPORT FOR VOLUME SEQUENCE      *\n*                              NUMBER.                                *\n*                                                                     *\n**********************************************************************/\n*                                                                     *\n* REGISTERS AT ENTRY                                                  *\n*              R1    STANDARD PARM STRING POINTER                     *\n*              R13   SAVE AREA                                        *\n*              R14   RETURN ADDRESS                                   *\n*              R15   ENTRY POINT                                      *\n*                                                                     *\n* REGISTER USE IN PROGRAM                                             *\n*              R8    TLBLABEL                                         *\n*              R9    SUBROUTINE LINKAGE                               *\n*              R10   SUBROUTINE LINKAGE                               *\n*              R11   TLBLCVT                                          *\n*              R12   BASE REGISTER                                    *\n*              R13   SAVEAREA/EXTRA BASE                              *\n*                                                                     *\n**********************************************************************/\n         EJECT\n***********************************************************************\n* TLBLMAIN:                                      /*  ENTRY POINT  */  *\n*        BRANCH AROUND DOCUMENTATION HEADER;                          *\n***********************************************************************\n         SPACE\nTLBLMAIN CSECT\n         SPACE\nTLBLMAIN AMODE 31\nTLBLMAIN RMODE 24\n         SPACE\n         USING TLBLMAIN,R15        TEMPORARY BASE\n         B     BEGIN               SKIP OVER DOCUMENTATION\n         SPACE\n         DC    AL1(BEGIN-*)        LENGTH OF TEXT\nSRCLEVEL DC    C'TLBLMAIN VNN.MNN YY/MM/DD HH:MM UUUUUUUU'\n*                MODULE   VER/MOD   DATE   TIME  USER NAME\nCOPYRIGT DC    C' COPYRIGHT (C) 1987 PLANNING RESEARCH CORPORATION '\nASMSTAMP DC    C'ASM &SYSDATE &SYSTIME'\n         DROP  R15                 DONE WITH TEMPORARY BASE\n         SPACE\nBEGIN    DS    0H\n         EJECT\n***********************************************************************\n* MAIN0000:                                   /*  INITIALIZATION  */  *\n*        SAVE REGISTERS;                                              *\n*        SET PROGRAM BASE;                                            *\n*        CHAIN SAVE AREAS;                                            *\n*        GET SUPERVISOR STATE;                                        *\n*        CALL PARM STRING SUBROUTINE;               /*     PARMS  */  *\n*        IF (ERROR IN PARM STRING)                                    *\n*          THEN EXIT;                               /*  MAIN9000  */  *\n*        CALL OP COMM INITIALIZATION SUBROUTINE;    /*    INITOC  */  *\n***********************************************************************\n         SPACE\nMAIN0000 DS    0H\n         USING PSA,R0              ALWAYS\n         SPACE\n         SAVE  (14,12)             SAVE REGISTERS\n         SPACE\n         LR    R12,R15             SET BASE REGISTER\n         USING TLBLMAIN,R12\n         SPACE\n         LR    R15,R13             ---\n         LA    R13,SAVEAREA        - CHAIN SAVE\n         ST    R13,8(,R15)         - AREAS\n         ST    R15,4(,R13)         ---\n         SPACE\n         USING SAVEAREA,R13        SECOND BASE REGISTER\n         SPACE\n         ST    R1,SAVEPARM         SAVE PARM STRING POINTER\n         SPACE\n         MODESET MF=(E,GETSUP)\n         SPACE\n         BAL   R10,PARMS           PROCESS PARM STRING\n         TM    PARMOPTS,PARMBADP   ALL OKAY?\n         BO    MAIN9000            NOPE...TERMINATE\n         SPACE\n         BAL   R10,INITOC          INITIALIZE OPERATOR COMMUNICATIONS\n         EJECT\n***********************************************************************\n* MAIN1000:                              /*  MORE INITIALIZATION  */  *\n*        IF (ACTIVE LOCK NOT IS CURRENTLY HELD)                       *\n*          THEN CALL INITIALIZE TLBLCVT SUBROUTINE; /*    INITVT  */  *\n*        GET 'ACTIVE' ENQ LOCK;                                       *\n*        IF (ENQ FAILED)                                              *\n*          THEN DO;                                                   *\n*                 ISSUE 'LOCK UNAVAILABLE' MESSAGE;                   *\n*                 GO EXIT;                          /*  MAIN9000  */  *\n*               END;                                                  *\n*        ISSUE INITIALIZATION COMPLETE MESSAGE;                       *\n***********************************************************************\n         SPACE\nMAIN1000 DS    0H\n         ENQ   MF=(E,LOCKTEST)\n         SPACE\n         LTR   R15,R15             CHECK RETURN CODE\n         BNZ   MAIN1500            GO IF NOT OKAY\n         SPACE\n         BAL   R10,INITVT          INITIALIZE TLBLCVT\n         USING TLBLCVT,R11\n         SPACE\n         ENQ   MF=(E,LOCKUSE)\n         SPACE\n         LTR   R15,R15             CHECK RETURN CODE\n         BZ    MAIN1900            GO IF OKAY\n         SPACE\nMAIN1500 DS    0H\n         WTO   MF=(E,BADLOCK)\n         SPACE\n         B     MAIN9000            GO EXIT\n         SPACE\nMAIN1900 DS    0H\n         WTO   MF=(E,INITCPLT)\n         EJECT\n***********************************************************************\n* MAIN2000:                             /*  MAIN PROCESSING LOOP  */  *\n*        DO UNTIL (TERMINATION IS REQUESTED);                         *\n*          CALL PROCESSING STATE SUBROUTINE;        /*  SETSTATE  */  *\n*          CALL LABEL REGISTRATION SUBROUTINE;      /*    VERIFY  */  *\n*          CALL LABEL PROCESSING SUBROUTINE;        /*   PROCESS  */  *\n*          LONG WAIT ON ECB LIST: STOP/MODIFY, WORK-TO-DO;            *\n*          IF (OP COMM ECB IS POSTED)                                 *\n*            THEN CALL COMMAND PROCESSING SUBROUTINE;/*  COMMAND  */  *\n*        END;                                                         *\n***********************************************************************\n         SPACE\nMAIN2000 DS    0H\n         BAL   R10,SETSTATE        SET PROCESSING STATE\n         BAL   R10,VERIFY          LABEL REGISTRATION CHECK\n         BAL   R10,PROCESS         CHECK QUEUES AND PROCESS\n         SPACE\n         L     R1,SMECBA           STOP/MODIFY ECB ADDRESS\n         USING ECB,R1\n         TM    ECBCC,ECBPOST       POSTED?\n         BO    MAIN2200            YEP...ONWARD\n         L     R1,WTDECBA          WORK-TO-DO ECB ADDRESS\n         TM    ECBCC,ECBPOST       POSTED?\n         BO    MAIN2500            YEP...CHECK FOR STOP\n         DROP  R1\n         SPACE\n         MODESET EXTKEY=ZERO,SAVEKEY=(2)\n         SPACE\n         WAIT  ECBLIST=ECBLIST,LONG=YES\n         SPACE\n         MODESET KEYREG=2\n         SPACE\n         L     R1,SMECBA           STOP/MODIFY ECB ADDRESS\n         USING ECB,R1\n         TM    ECBCC,ECBPOST       MESSAGE WAITING?\n         BNO   MAIN2500            NOPE...ONWARD\nMAIN2200 DS    0H\n         BAL   R10,COMMAND         PROCESS COMMAND\nMAIN2500 DS    0H\n         SPACE\n         TM    STATUS,STATTERM     TERMINATION REQUSETED?\n         BNO   MAIN2000            NOPE...LOOP AGAIN\n         EJECT\n***********************************************************************\n* MAIN4000:                                      /*  TERMINATION  */  *\n*        RELEASE ACTIVE LOCK;                                         *\n*        CALL VTAM SESSION TERMINATION SUBROUTINE;   /*  CLOSEPR  */  *\n***********************************************************************\n         SPACE\nMAIN4000 DS    0H\n         DEQ   MF=(E,LOCKFREE)\n         SPACE\n         BAS   R9,CLOSEPR          TERMINATE VTAM SESSION\n         SPACE 3\n***********************************************************************\n* MAIN9000:                                /*  RETURN TO INVOKER  */  *\n*        ISSUE SPOST FOR PENDING XMEMORY POSTS;                       *\n*        RESUME PROBLEM PROGRAM STATE;                                *\n*        RESTORE REGISTERS;                                           *\n*        RETURN TO CALLER VIA R14;                                    *\n***********************************************************************\n         SPACE\nMAIN9000 DS    0H\n         SPOST\n         SPACE\n         MODESET MF=(E,GETPROB)\n         SPACE\n         L     R13,4(,R13)         HIGHER SAVE AREA\n         RETURN (14,12),RC=0\n         EJECT\n*SUB*******************************************************************\n* PARMS:                                  /*  DESTRING PARM TEXT  */  *\n*        DO UNTIL( (ALL PARM FIELDS ARE PROCESSED)  -- OR --          *\n*                  (PARM TEXT IS EXHAUSTED) )                         *\n*          FIND LENGTH OF NEXT FIELD IN MESSAGE;                      *\n*          IF (LENGTH > 0)                                            *\n*            THEN MOVE TEXT TO OUTPUT AREA;                           *\n*        END;                                                         *\n***********************************************************************\n         SPACE\nPARMS    DS    0H\n         L     R1,SAVEPARM         RECOVER PARM LIST POINTER\n         L     R1,0(,R1)           LENGTH AND PARM TEXT\n         LA    R6,2(,R1)           FIRST INTERESTING BYTE\n         LH    R7,0(,R1)           PARM LENGTH\n         BCTR  R7,0                DECREMENT FOR EXECUTES\n         LA    R14,PARMTBL         MOVE TABLE\n         LA    R15,PARMTBLC        LOOP COUNTER\n         SPACE\nPARMS200 DS    0H\n         LTR   R7,R7               ANY CHARACTERS LEFT?\n         BM    PARMS290            NOPE...DONE\n         SPACE\n         EX    R7,TRTDELIM         LOCATE NEXT DELIMITER\n         BNZ   PARMS220            GO IF DELIMITER FOUND\n         SPACE\n         LR    R4,R7               LENGTH FOR EXECUTED MOVE\n         LA    R1,1(R6,R7)         FAKE OUT R1 FOR LATER LOOP CALCS\n         B     PARMS240            GO FOR MOVE\n         SPACE\nPARMS220 DS    0H\n         LA    R4,0(,R1)           ADDRESS OF DELIMITER (CLEAR HI BYTE)\n         SR    R4,R6               COMPUTE LENGTH\n         BCTR  R4,0                DECREMENT FOR EXECUTE\n         SPACE\nPARMS240 DS    0H\n         LM    R2,R3,0(R14)        GET ADDRESS AND MAX LENGTH FOR MOVE\n         LR    R1,R4               COPY LENGTH OF DATA\n         CR    R3,R1               CHECK LENGTH\n         BNL   PARMS260            GO IF MAX LENGTH NOT EXCEEDED\n         LR    R1,R3               SET LENGTH TO MAXIMUM\nPARMS260 DS    0H\n         LTR   R1,R1               CHECK LENGTH FOR EXECUTE\n         BM    PARMS280            NULL FIELD...SKIP MOVE\n         EX    R3,CLRFIELD         BLANK IT OUT\n         EX    R1,MVCFIELD         MOVE SUITABLE LENGTH\n         SPACE\nPARMS280 DS    0H\n         LA    R4,2(,R4)           ACCOUNT FOR DELIMITER, EXECUTE\n         SR    R7,R4               DECREMENT REMAINING COUNT\n         AR    R6,R4               BUMP ADDRESS TO NEXT FIELD\n         LA    R14,L'PARMTBL(,R14) BUMP TABLE POINTER\n         BCT   R15,PARMS200        LOOP\n         SPACE\nPARMS290 DS    0H\n         EJECT\n***********************************************************************\n* PARMS400:                                                           *\n*        IF (START TYPE IS NOT HOT, WARM OR COLD)                     *\n*          THEN ISSUE MESSAGE - BAD START TYPE;                       *\n*          ELSE IF (START TYPE IS COLD)                               *\n*                 THEN CLEAR TLBLABEL QUEUE ANCHORS;                  *\n*                 ELSE SET START TYPE FLAGS;                          *\n***********************************************************************\n         SPACE\nPARMS400 DS    0H\n         CLC   STYPE,=CL8'HOT'     WARM START REQUESTED?\n         BE    PARMS490            YEP...ONWARD\n         CLC   STYPE,=CL8'WARM'    WARM START REQUESTED?\n         BE    PARMS420            YEP...GO SET PURGE FLAG\n         CLC   STYPE,=CL8'COLD'    COLD START REQUESTED?\n         BE    PARMS440            YEP...GO SET CLEAR FLAG\n         SPACE\n         WTO   MF=(E,BADSTYPE)\n         OI    PARMOPTS,PARMBADP   SET FLAG - BAD PARM\n         OI    STATUS,STATTERM     SET FLAG - REQUEST TERMINATION\n         B     PARMS490            ONWARD...CHECK OTHER FIELDS\n         SPACE\nPARMS420 DS    0H\n         OI    STATUS,STATPURG     SET FLAG\n         B     PARMS490\n         SPACE\nPARMS440 DS    0H\n         OI    PARMOPTS,PARMCLRQ   SET FLAG\n         SPACE\nPARMS490 DS    0H\n         EJECT\n***********************************************************************\n* PARMS500:                                                           *\n*        IF (INITIAL STATE IS NOT START, STOP OR VERIFY)              *\n*          THEN ISSUE MESSAGE - BAD INITIAL STATE AND SET BAD PARM;   *\n*          ELSE SET INITIAL STATE FLAGS;                              *\n*        IF (LU NAME WAS NOT SPECIFIED)                               *\n*          THEN ISSUE MESSAGE - NO LU NAME AND SET BAD PARM FLAG;     *\n***********************************************************************\n         SPACE\nPARMS500 DS    0H\n         CLC   ISTATE,=CL8'START'  INITIAL START REQUESTED?\n         BE    PARMS510            YEP...GO SET FLAG\n         CLC   ISTATE,=CL8'STOP'   INITIAL STOP REQUESTED?\n         BE    PARMS520            YEP...GO SET FLAGS\n         CLC   ISTATE,=CL8'VERIFY' INITIAL VERIFY REQUESTED?\n         BE    PARMS530            YEP...GO SET FLAGS\n         SPACE\n         WTO   MF=(E,BADISTAT)\n         SPACE\n         OI    PARMOPTS,PARMBADP   SET FLAG - BAD PARM\n         OI    STATUS,STATTERM     SET FLAG - REQUEST TERMINATION\n         B     PARMS560            ONWARD\n         SPACE\nPARMS510 DS    0H\n         OI    STATUS,STATSTOP+STATSTRT  INITIAL STOP, REQUEST START\n         B     PARMS560            ONWARD\n         SPACE\nPARMS520 DS    0H\n         OI    STATUS,STATSTOP     INITIAL STOP\n         B     PARMS560            ONWARD\n         SPACE\nPARMS530 DS    0H\n         OI    STATUS,STATSTOP+STATSTRT+STATVFY  STOP, REQ START, VFY\n         SPACE\nPARMS560 DS    0H\n         CLI   LUNAME,C' '         LUNAME SPECIFIED?\n         BNE   PARMS590            YEP...ONWARD\n         SPACE\n         WTO   MF=(E,NOLUNAME)\n         SPACE\n         OI    PARMOPTS,PARMBADP   SET FLAG - BAD PARM\n         OI    STATUS,STATTERM     SET FLAG - REQUEST TERMINATION\n         SPACE\nPARMS590 DS    0H\n         EJECT\n***********************************************************************\n* PARMS600:                                                           *\n*        FORMAT AND ISSUE STARTING PARAMETER MESSAGE;                 *\n*        RETURN TO CALLER VIA R10;                                    *\n***********************************************************************\n         SPACE\nPARMS600 DS    0H\n         MVC   PMSGLU,LUNAME       ---\n         MVC   PMSGSTRT,STYPE      -  COMPLETE\n         MVC   PMSGSTAT,ISTATE     -  MESSAGE\n         MVC   PMSGLMOD,LOGMODE    ---\n         SPACE\n         WTO   MF=(E,PARMMSG)\n         SPACE\nPARMS990 DS    0H\n         BR    R10                 RETURN TO CALLER\n         SPACE\nTRTDELIM TRT   0(*-*,R6),DELIMTBL  EXECUTED - FIND DELIMITER\nCLRFIELD MVC   0(*-*,R2),=CL8' '   EXECUTED - CLEAR FIELD\nMVCFIELD MVC   0(*-*,R2),0(R6)     EXECUTED - MOVE FIELD\n         EJECT\n*SUB*******************************************************************\n* INITOC:                  /* INITIALIZE OPERATOR COMMUNICATIONS  */  *\n*        EXTRACT COMM AREA;                                           *\n*        IF (START CIB EXISTS)                                        *\n*          THEN FREE IT;                                              *\n*        SET CIB COUNTER MAX TO 1;                                    *\n*        PUT STOP/MODIFY ECB ADDRESS INTO WAIT ECB LIST;              *\n*        RETURN TO CALLER VIA R10;                                    *\n***********************************************************************\n         SPACE\nINITOC   DS    0H\n         EXTRACT COMM,FIELDS=COMM\n         SPACE\n         L     R2,COMM             NOW I'VE GOT IT\n         USING COMLIST,R2\n         SPACE\n         ICM   R7,B'1111',COMCIBPT ADDRESS OF CIB\n         USING CIB,R7\n         BZ    INITOC20            NO CIB...ONWARD\n         CLI   CIBVERB,CIBSTART    START CIB EXIST?\n         BNE   INITOC20            NOPE...ONWARD\n         QEDIT ORIGIN=COMCIBPT,BLOCK=(R7)\nINITOC20 DS    0H\n         SPACE\n         QEDIT ORIGIN=COMCIBPT,CIBCTR=1\n         SPACE\n         MVC   SMECBA,COMECBPT     STOP/MODIFY ECB ADDRESS\n         OI    SMECBA,X'80'        SET END-OF-LIST FLAG\n         SPACE\n         BR    R10                 RETURN TO CALLER\n         SPACE\n         DROP  R2,R7\n         EJECT\n*SUB*******************************************************************\n* INITVT:                                 /*  INITIALIZE TLBLCVT  */  *\n*        LOCATE SELECTED SSCVT;                                       *\n*        SAVE SSCVT ADDRESS;                                          *\n*        IF (UNABLE TO FIND SSCVT)                                    *\n*          THEN ABEND U1001;                                          *\n***********************************************************************\n         SPACE\nINITVT   DS    0H\n         L     R1,FLCCVT           CVT ADDRESS\n         USING CVT,R1\n         L     R1,CVTJESCT         JESCT ADDRESS\n         USING JESCT,R1\n         L     R7,JESSSCT          FIRST SSCVT ADDRESS\n         USING SSCT,R7\n         DROP  R1\n         SPACE\nINITVT20 DS    0H\n         CLC   SSCTSNAM,SSNAME     IS THIS THE RIGHT SSCVT?\n         BE    INITVT30            YEP...ONWARD\n         ICM   R7,B'1111',SSCTSCTA NEXT SSCT\n         BNZ   INITVT20            LOOP IF IT EXISTS\n         SPACE\n         ABEND 1001,DUMP           NO GOT...ERROR\n         SPACE\nINITVT30 DS    0H\n         ST    R7,SSCVTA           SAVE SSVCT ADDRESS\n         EJECT\n***********************************************************************\n*        IF (SSCTSUSE=0)                /*  FIRST START THIS IPL  */  *\n*          THEN GETMAIN CSA AND INITIALIZE TLBLCVT;                   *\n***********************************************************************\n         SPACE\n         ICM   R11,B'1111',SSCTSUSE TLBLCVT POINTER\n         BNZ   INITVT40            ALREADY ALLOCATED...ONWARD\n         SPACE\n         MODESET EXTKEY=ZERO,SAVEKEY=(2)\n         SPACE\n         L     R0,GETMCVT          SUBPOOL AND LENGTH\n         GETMAIN R,LV=(0)\n         SPACE\n         LR    R11,R1              ADDRESS OF GOTTEN AREA\n         USING TLBLCVT,R11\n         SPACE\n         MVC   TLBLEYE,=C'TLBL'    EYECATCHER\n         XC    TLBLPTRS,TLBLPTRS   TLBLABEL ANCHORS\n         MVC   TLBLQNAM,QNAME      ENQ QNAME\n         MVC   TLBLRNAM,RNAME      ENQ RNAME\n         XC    TLBLEXEP,TLBLEXEP   CLEAR EXIT ENTRY POINT ADDRESS\n         SPACE\n         ST    R11,SSCTSUSE        SAVE ADDRESS OF TLBLCVT\n         SPACE\n         MODESET KEYREG=2\n         SPACE\nINITVT40 DS    0H\n         EJECT\n***********************************************************************\n*        PLACE WORK-TO-DO ECB ADDRESS IN ECB LIST;                    *\n*        PLACE ASCB ADDRESS IN TLBLCVT;                               *\n*        INITIALIZE WORK-TO-DO ECB TO POSTED (FORCE INITIAL PASS);    *\n*        IF (QUEUE CLEAR IS PENDING)                                  *\n*          THEN ZERO HEAD AND TAIL POINTERS TO TLBLABEL QUEUE;        *\n*        RETURN TO CALLER VIA R10;                                    *\n***********************************************************************\n         SPACE\n         ST    R11,TLBLCVTA        SAVE TLBLCVT ADDRESS\n         LA    R15,TLBLECB         WORK-TO-DO ECB ADDRESS\n         ST    R15,WTDECBA         INTO ECB LIST\n         SPACE\n         MODESET EXTKEY=ZERO,SAVEKEY=(2)\n         SPACE\n         MVC   TLBLASCB,PSAAOLD    ASCB ADDRESS\n         MVC   TLBLECB,=AL1(ECBPOST,0,0,0) INITIALIZE WORK-TO-DO ECB\n         SPACE\n         TM    PARMOPTS,PARMCLRQ   QUEUE CLEAR REQUESTED?\n         BNO   INITVT50            NOPE...ONWARD\n         SPACE\n         XC    TLBLPTRS,TLBLPTRS   CLEAR POINTERS\nINITVT50 DS    0H\n         SPACE\n         MODESET KEYREG=2\n         SPACE\n         BR    R10                 RETURN TO CALLER\n         SPACE\n         DROP  R7\n         EJECT\n*SUB*******************************************************************\n* SETSTATE:                 /*  SET PROCESSING AND OUTPUT STATES  */  *\n*        IF (QUEUE PURGE IS PENDING)                                  *\n*          THEN DO;                                                   *\n*                 CLEAR PURGE REQUEST FLAG;                           *\n*                 CALL PURGE QUEUE SUBROUTINE;        /*  PURGEQ  */  *\n*               END;                                                  *\n*        IF (STOPPED)                                                 *\n*          THEN (IF START IS REQUESTED)                               *\n*                 THEN DO;                                            *\n*                        CLEAR START REQUEST FLAG;                    *\n*                        CALL OPEN PRINTER SUBR;      /*  OPENPR  */  *\n*                      END;                                           *\n*          ELSE (IF STOP IS REQUESTED)                                *\n*                 THEN DO;                                            *\n*                        CLEAR STOP REQUEST FLAG;                     *\n*                        CALL CLOSE PRINTER SUBR;    /*  CLOSEPR  */  *\n*                      END;                                           *\n*        RETURN TO CALLER VIA R10;                                    *\n***********************************************************************\n         SPACE\nSETSTATE DS    0H\n         TM    STATUS,STATPURG     QUEUE PURGE REQUESTED?\n         BNO   STATE190            NOPE...ONWARD\n         BAL   R9,PURGEQ           REMOVE WORK FROM QUEUE\n         NI    STATUS,X'FF'-STATPURG CLEAR REQUEST FLAG\nSTATE190 DS    0H\n         SPACE\n         TM    STATUS,STATSTOP     CURRENTLY STOPPED?\n         BNO   STATE350            NOPE...ONWARD\n         SPACE\n         TM    STATUS,STATSTRT     START REQUESTED?\n         BNO   STATE390            NOPE...GO RETURN TO CALLER\n         SPACE\n         NI    STATUS,X'FF'-STATSTRT CLEAR START REQUEST\n         BAS   R9,OPENPR           START SESSION W/PRINTER\n         SPACE\nSTATE350 DS    0H\n         TM    STATUS,STATSTPR     STOP REQUESTED?\n         BNO   STATE390            NOPE...GO RETURN TO CALLER\n         SPACE\n         NI    STATUS,X'FF'-STATSTPR CLEAR STOP REQUEST\n         BAS   R9,CLOSEPR          CLOSE SESSION W/PRINTER\n         SPACE\nSTATE390 DS    0H\n         BR    R10                 RETURN TO CALLER\n         EJECT\n*SUB*******************************************************************\n* VERIFY:            /*  LABEL PRINTER REGISTRATION VERIFICATION  */  *\n*        IF (VERIFY IS NOT REQUESTED)   --  OR  --                    *\n*           (VERIFY IS IN PROGRESS)     --  OR  --                    *\n*           (OUTPUT IS STOPPED)                                       *\n*          THEN RETURN TO CALLER VIA R10;                             *\n*        CLEAR VERIFY REQUEST;                                        *\n*        SET VERIFY IN PROGRESS;                                      *\n*        SET TIME AND DATE INTO VERIFICATION PATTERN;                 *\n*        WRITE VERIFICATION PATTERN;                 /*  WRITEPR  */  *\n*        RETURN TO CALLER VIA R10;                                    *\n***********************************************************************\n         SPACE\nVERIFY   DS    0H\n         TM    STATUS,STATVFY      VERIFY REQUESTED?\n         BNOR  R10                 NOPE...RETURN TO CALLER\n         SPACE\n         TM    STATUS,STATVFYP+STATSTOP VERIFY IN PROGRESS OR STOPPED?\n         BNZR  R10                 YEP...RETURN TO CALLER\n         SPACE\n         NI    STATUS,X'FF'-STATVFY CLEAR VERIFY REQUEST\n         OI    STATUS,STATVFYP     SET VERIFY IN PROGRESS\n         SPACE\n         LA    R8,VFYPATRN         DUMMY TLBLABEL\n         USING TLBLABEL,R8\n         SPACE\n         TIME  DEC\n         SPACE\n         ST    R0,LABELTIM         SAVE TIME\n         ST    R1,LABELDAT         DITTO DATE\n         SPACE\n         BAS   R9,WRITEPR          GO FORMAT AND WRITE IT OUT\n         SPACE\n         BR    R10                 RETURN TO CALLER\n         EJECT\n*SUB*******************************************************************\n* PROCESS:                        /*  DEQUEUE REQUEST AND OUTPUT  */  *\n*        IF (STOPPED)                -- OR --                         *\n*           (VERIFY IS IN PROGRESS)                                   *\n*          THEN DO;                                                   *\n*                 CLEAR WORK-TO-DO ECB;                               *\n*                 RETURN TO CALLER VIA R10;                           *\n*               END;                                                  *\n***********************************************************************\n         SPACE\nPROCESS  DS    0H\n         TM    STATUS,STATSTOP+STATVFYP PROPER STATE?\n         BZ    PROCESS1            YEP...ONWARD\n         SPACE\n         MODESET EXTKEY=ZERO,SAVEKEY=(2)\n         SPACE\n         XC    TLBLECB,TLBLECB     CLEAR WORK-TO-DO ECB\n         SPACE\n         MODESET KEYREG=2\n         SPACE\n         BR    R10                 RETURN TO CALLER\n         SPACE\nPROCESS1 DS    0H\n         EJECT\n***********************************************************************\n*        GET NEXT REQUEST FROM HEAD OF QUEUE;                         *\n*        IF (REQUEST IS PRESENT AT HEAD OF QUEUE)                     *\n*          THEN DO;                                                   *\n*                 FORMAT AND OUTPUT LABEL;           /*  WRITEPR  */  *\n*                 IF (LABEL WRITE WAS SUCCESSFUL)                     *\n*                   THEN GET RID OF TLBLABEL BLOCK;  /*  DEQUEUE  */  *\n*               END;                                                  *\n*        IF (QUEUE IS STILL NOT EMPTY)                                *\n*          THEN SET POSTED BIT IN WORK-TO-DO ECB;                     *\n*          ELSE RESET WORK-TO-DO ECB;                                 *\n*        RETURN TO CALLER VIA R10;                                    *\n***********************************************************************\n         SPACE\n         ICM   R8,B'1111',TLBLHEAD CHECK FOR REQUEST ON QUEUE\n         BZ    PROCESS5            NOT THERE...RETURN TO CALLER\n         USING TLBLABEL,R8\n         SPACE\n         BAS   R9,WRITEPR          GO FORMAT AND WRITE IT OUT\n         LTR   R15,R15             WAS IT SUCCESSFUL?\n         BNZ   PROCESS5            NOPE...LEAVE IT ON QUEUE\n         SPACE\n         BAL   R9,DEQUEUE          REMOVE REQUEST\n         SPACE\nPROCESS5 DS    0H\n         MODESET EXTKEY=ZERO,SAVEKEY=(2)\n         SPACE\n         XC    TLBLECB,TLBLECB     CLEAR WORK-TO-DO ECB\n         SPACE\n         CLC   TLBLHEAD,=A(0)      MORE THERE?\n         BE    PROCESS7            NOPE...WRAP UP\n         SPACE\n         OI    TLBLECB,ECBPOST     INDICATE MORE WORK-TO-DO\n         SPACE\nPROCESS7 DS    0H\n         MODESET KEYREG=2\n         SPACE\n         BR    R10                 RETURN TO CALLER\n         EJECT\n*SUB*******************************************************************\n* DEQUEUE:                                    /* DEQUEUE REQUEST  */  *\n*        IF (QUEUE IS NOT EMPTY)                                      *\n*          THEN DO;                                                   *\n*                 DECHAIN NEXT REQUEST FROM QUEUE;                    *\n*                 FREEMAIN TAPLABEL REQUEST BLOCK;                    *\n*               END;                                                  *\n*        RETURN TO CALLER VIA R9;                                     *\n***********************************************************************\n         SPACE\nDEQUEUE  DS    0H\n         MODESET EXTKEY=ZERO,SAVEKEY=(2)\n         SPACE\nDEQUE10  DS    0H\n         LM    R4,R5,TLBLPTRS      HEAD AND TAIL OF CHAIN - NOW\n         LTR   R8,R4               ANYTHING THERE?\n         BZ    DEQUE90             NOPE...RETURN TO CALLER\n         USING TLBLABEL,R8\n         SPACE\n         CR    R4,R5               ONLY ONE BLOCK ON CHAIN?\n         BE    DEQUE20             YEP...ONWARD\n         SPACE\n         L     R6,LABELNXT         NEW HEAD OF CHAIN\n         LR    R7,R5               NEW TAIL OF CHAIN\n         B     DEQUE40             ONWARD\n         SPACE\nDEQUE20  DS    0H\n         XR    R6,R6               HEAD IS NOW NULL\n         XR    R7,R7               DITTO TAIL\n         SPACE\nDEQUE40  DS    0H\n         LA    R0,1                ---\n         AH    R0,LABELDEL         - INCREMENT COUNT\n         STH   R0,LABELDEL         ---\n         SPACE\n         CDS   R4,R6,TLBLPTRS      TRY DECHAIN\n         BNE   DEQUE10             LOOP UNTIL SUCCESSFUL\n         SPACE\n         L     R0,FREEBLOK         SUBPOOL AND LENGTH\n         FREEMAIN R,LV=(0),A=(R8)\n         SPACE\nDEQUE90  DS    0H\n         MODESET KEYREG=2\n         SPACE\n         BR    R9                  RETURN TO CALLER\n         EJECT\n*SUB*******************************************************************\n* PURGEQ:                     /*  PURGE TLBLABEL WORK FROM QUEUE  */  *\n*        DO UNTIL (QUEUE IS EMPTY);                                   *\n*          DEQUE LABEL REQUEST;                      /*  DEQUEUE  */  *\n*        END;                                                         *\n*        RETURN TO CALLER VIA R9;                                     *\n***********************************************************************\n         SPACE\nPURGEQ   DS    0H\n         ST    R9,SAVE9            SAVE RETURN ADDRESS\n         SPACE\nPURGEQ10 DS    0H\n         CLC   TLBLHEAD,=A(0)      ANYTHING ON QUEUE?\n         BE    PURGEQ90            NOPE...ONWARD\n         SPACE\n         BAL   R9,DEQUEUE          REMOVE LABEL REQUEST AT QUEUE HEAD\n         B     PURGEQ10\n         SPACE\nPURGEQ90 DS    0H\n         L     R9,SAVE9            RESTORE REGISTER\n         BR    R9                  RETURN TO CALLER\n         EJECT\n*SUB*******************************************************************\n* OPENPR:                    /*  START VTAM SESSION WITH PRINTER  */  *\n*        IF (NOT STOPPED)                                             *\n*          THEN RETURN TO CALLER VIA R9;                              *\n*        GET INTO 24-BIT MODE;                                        *\n*        MOVE LU NAME TO VTAM NIB;                                    *\n*        MOVE LOGMODE TO VTAM NIB;                                    *\n*        OPEN VTAM ACB;                                               *\n*        IF (OPEN FAILED)                                             *\n*          THEN DO;                                                   *\n*                 FORMAT AND ISSUE ERROR MESSAGE;                     *\n*                 GO TO CLOSEPR WITHOUT CHANGING R9; /*  CLOSEPR  */  *\n*               END;                                                  *\n***********************************************************************\n         SPACE\nOPENPR   DS    0H\n         TM    STATUS,STATSTOP     STOPPED?\n         BNOR  R9                  NOPE...RETURN TO CALLER\n         SPACE\n         LA    R1,*+6              GET 24 BIT MODE ADDRESS\n         BSM   0,R1                SET 24 BIT MODE\n         SPACE\n         LA    R1,PRNIB            ADDRESSABILITY\n         USING ISTDNIB,R1\n         MVC   NIBSYM,LUNAME       MOVE LU NAME TO NIB\n         MVC   NIBLMODE,LOGMODE    MOVE LOGMODE TO NIB\n         DROP  R1\n         SPACE\n         OPEN  MF=(E,OCACBL)\n         SPACE\n         LTR   R15,R15             CHECK RETURN CODE\n         BZ    OPENPR19            OKAY...ONWARD\n         SPACE\n         STCM  R15,B'0011',ERRACB15    ---\n         UNPK  HEXWORK(5),ERRACB15(3)  - CONVERT R15\n         TR    HEXWORK(4),HEXTABLE     - TO HEX\n         MVC   ERRACB15,HEXWORK        ---\n         SPACE\n         LA    R15,PRACB           ACB ADDRESS\n         USING IFGACB,R15\n         UNPK  HEXWORK(3),ACBERFLG(2)  ---\n         TR    HEXWORK(2),HEXTABLE     - ACBERFLG TO HEX\n         MVC   ERRACBFL,HEXWORK        ---\n         DROP  R15\n         SPACE\n         WTO   MF=(E,ERRACB)\n         SPACE\n*              THIS IS A LITTLE TRICKY. SEE COMMENTS IN RPLERR ROUTINE.\n         B     CLOSEPR             GO SHUT DOWN\n         SPACE\nOPENPR19 DS    0H\n         EJECT\n***********************************************************************\n*        ISSUE VTAM OPNDST ACQUIRE;                                   *\n*        IF (OPNDST FAILED)                                           *\n*          THEN GO PROCESS ERROR;                     /*  RPLERR  */  *\n*        COPY CID FROM NIB TO SEND RPL;                               *\n*        CLEAR STOPPED, STOP REQ, START REQ FLAGS;                    *\n*        RETURN TO CALLER VIA BSM 0,R9;                               *\n***********************************************************************\n         SPACE\n         LA    R2,PRNIB            NIB ADDRESSABILITY\n         USING ISTDNIB,R2\n         SPACE\n         OPNDST RPL=PRRPL1,OPTCD=(SYN,ACQUIRE),NIB=(R2)\n         SPACE\n         LTR   R15,R15             CHECK RETURN CODE\n         BNZ   RPLERR              PROCESS ERROR\n         SPACE\n         LA    R3,PRRPL2           SEND RPL\n         USING IFGRPL,R3\n         MVC   RPLARG,NIBCID       COPY CID TO SEND RPL\n         DROP  R2,R3\n         SPACE\n         NI    STATUS,X'FF'-(STATSTOP+STATSTPR+STATSTRT) CLEAR FLAGS\n         SPACE\n         BSM   0,R9                RETURN TO CALLER\n         EJECT\n*SUB*******************************************************************\n* CLOSEPR:                     /*  END VTAM SESSION WITH PRINTER  */  *\n*        SET STOPPED FLAG;                                            *\n*        CLEAR STOP REQ, START REQ, VERIFY FLAGS;                     *\n*        GET INTO 24-BIT MODE;                                        *\n*        ISSUE VTAM CLSDST;                                           *\n*        CLOSE VTAM ACB;                                              *\n*        SET R15 TO NON-ZERO;                                         *\n*        RETURN TO CALLER VIA BSM 0,R9;                               *\n***********************************************************************\n         SPACE\nCLOSEPR  DS    0H\n         OI    STATUS,STATSTOP     SET STOPPED FLAG\n         NI    STATUS,X'FF'-(STATSTPR+STATSTRT+STATVFY+STATVFYP)\n         SPACE\n         LA    R1,*+6              GET 24 BIT MODE ADDRESS\n         BSM   0,R1                SET 24 BIT MODE\n         SPACE\n         CLSDST RPL=PRRPL1,OPTCD=(SYN,RELEASE)\n         SPACE\n         CLOSE MF=(E,OCACBL)\n         SPACE\n         LA    R15,8               SET NON-ZERO IN CASE RPLERROR\n         SPACE\n         BSM   0,R9                RETURN TO CALLER\n         EJECT\n*SUB*******************************************************************\n* WRITEPR:                     /*  FORMAT AND WRITE A TAPE LABEL  */  *\n*        TRANSLATE NON-PRINTABLES TO DEFAULT CHARACTER (IE, X'79');   *\n*        COPY FIELDS REQUIRING LITTLE EDITING TO PRINTER DATA STREAM; *\n***********************************************************************\n         SPACE\nWRITEPR  DS    0H\n         USING TLBLABEL,R8\n         SPACE\n         MODESET EXTKEY=ZERO,SAVEKEY=(2)\n         SPACE\n         TR    LABELCHR(LABELCHL),PRNTABLE REMOVE NON-PRINTABLES\n         SPACE\n         MODESET KEYREG=2\n         SPACE\n         MVC   BUFVOL1,LABELSER    VOLUME SERIAL\n         MVC   BUFVOL2,LABELSER    VOLUME SERIAL\n         SPACE\n         MVC   BUFDEV1,LABELDEV    DEVICE NUMBER\n         MVC   BUFDEV2,LABELDEV    DEVICE NUMBER\n         SPACE\n         MVC   BUFVNO1,LABELVNO    VOLUME SEQUENCE REEL COUNT\n         MVC   BUFVNO2,LABELVNO    VOLUME SEQUENCE REEL COUNT\n         SPACE\n         MVC   BUFDEN1,LABELDEN    DENSITY\n         MVC   BUFDEN2,LABELDEN    DENSITY\n         SPACE\n         MVC   BUFLID1,LABELLID    ACF2 USER LOGON ID\n         MVC   BUFLID2,LABELLID    ACF2 USER LOGON ID\n         SPACE\n         MVC   BUFLAB1,LABELTYP    LABEL TYPE\n         MVC   BUFLAB2,LABELTYP    LABEL TYPE\n         SPACE\n         MVC   BUFSIT1,LABELSIT    SITE SMF ID\n         MVC   BUFSIT2,LABELSIT    SITE SMF ID\n         SPACE\n         MVC   BUFJOB1,LABELJOB    JOB NAME\n         MVC   BUFJOB2,LABELJOB    JOB NAME\n         SPACE\n         MVC   BUFJID1+0(1),LABELJID+0 JES JOBLOG TYPE\n         MVC   BUFJID1+1(4),LABELJID+4 JES JOBLOG NUMBER\n         MVC   BUFJID2,BUFJID1         JES JOBLOG ID\n         SPACE\n         MVC   BUFSTP1,LABELSTP    STEP NAME\n         MVC   BUFSTP2,LABELSTP    STEP NAME\n         EJECT\n***********************************************************************\n*        LOCATE POINT AT WHICH TO DIVIDE DSNAME ('.' IS BEST);        *\n*        FORMAT DSNAME TO TWO LINES, AS REQUIRED;                     *\n*        EDIT DATE AND TIME;                                          *\n***********************************************************************\n         SPACE\n         MVI   BUFDSN1A,C' '                     ---\n         MVC   BUFDSN1A+1(L'BUFDSN1A-1),BUFDSN1A - BLANK OUT\n         MVI   BUFDSN1B,C' '                     - DSNAME\n         MVC   BUFDSN1B+1(L'BUFDSN1B-1),BUFDSN1B ---\n         SPACE\n         LA    R1,LABELDSN+L'BUFDSN1A-1 LAST POSSIBLE BYTE, FIRST PART\n         LA    R14,BREAKRNG        LOOP COUNTER\n         CLI   1(R1),C' '          BLANK?\n         BE    WPR130              YEP...NO NEED TO LOOK FURTHER\nWPR120   DS    0H\n         CLI   0(R1),C'.'          BREAK POINT?\n         BE    WPR130              YEP...ONWARD\n         BCTR  R1,0                BACK UP A BYTE\n         BCT   R14,WPR120          LOOP FOR BREAK CHARACTER\n         LA    R14,BREAKRNG        NO BREAK CHARACTER FOUND\n         SPACE\nWPR130   DS    0H\n         LA    R14,L'BUFDSN1A-BREAKRNG(,R14) LENGTH\n         BCTR  R14,0               DECREMENT FOR EXECUTE\n         EX    R14,MVCDSN1A        MOVE FIRST PART OF DSNAME\n         SPACE\n         LA    R1,LABELDSN+1(R14)  NEXT CHARACTER OF REST OF DSNAME\n         LA    R15,L'LABELDSN-1    MAX LENGTH, WHOLE DSN - 1\n         SR    R15,R14             MAX REMAINING LENGTH\n         LA    R14,LABELDSN+L'LABELDSN-1  LAST BYTE OF DSNAME\n         SPACE\nWPR140   DS    0H\n         CLI   0(R14),C' '         TRAILING BLANK?\n         BNE   WPR160              NOPE...GO MOVE\n         BCTR  R14,0               BACK UP POINTER\n         BCT   R15,WPR140          LOOP FOR TRAILING BLANKS\n         B     WPR180              GO IF REMAINDER WAS ALL BLANKS\nWPR160   DS    0H\n         SPACE\n         LA    R2,BUFDSN1B+L'BUFDSN1B  LAST DESTINATION BYTE\n         SR    R2,R15              BACK UP BY CHARACTER COUNT\n         BCTR  R15,0               DECREMENT FOR EXECUTE\n         EX    R15,MVCDSN1B        RIGHT JUSTIFY REMAINDER OF DSNAME\n         SPACE\nWPR180   DS    0H\n         MVC   BUFDSN2A,BUFDSN1A   FIRST PART\n         MVC   BUFDSN2B,BUFDSN1B   REMAINDER\n         SPACE\n         MVC   BUFDAT1,EDITDATE    ---\n         ED    BUFDAT1,LABELDAT+1  - EDIT DATE\n         MVC   BUFDAT2,BUFDAT1     ---\n         MVC   BUFTIM1,EDITTIME    ---\n         ED    BUFTIM1,LABELTIM    - EDIT TIME\n         MVC   BUFTIM2,BUFTIM1     ---\n         EJECT\n***********************************************************************\n*        GET INTO 24-BIT MODE;                                        *\n*        ISSUE VTAM SEND TO PRINT LABEL;                              *\n*        IF (RETURN CODE IS NOT ZERO)                                 *\n*          THEN GO PROCESS ERROR;                     /*  RPLERR  */  *\n*        RETURN TO CALLER VIA BSM 0,R9;                               *\n***********************************************************************\n         SPACE\n         LA    R1,*+6              GET 24 BIT MODE ADDRESS\n         BSM   0,R1                SET 24 BIT MODE\n         SPACE\n         SEND  RPL=PRRPL2,OPTCD=(SYN,CA)\n         SPACE\n         LTR   R15,R15             CHECK RETURN CODE\n         BNZ   RPLERR              PROCESS ERROR\n         SPACE\n         BSM   0,R9                RETURN TO CALLER\n         SPACE\nMVCDSN1A MVC   BUFDSN1A(*-*),LABELDSN  EXECUTED\nMVCDSN1B MVC   0(*-*,R2),0(R1)         EXECUTED\n         EJECT\n*SUB*******************************************************************\n* RPLERR:              /*  PROCESS ERROR RETURN FROM RPL REQUEST  */  *\n*                                                                     *\n*  /***************************************************************/  *\n*  /*  THIS IS A LITTLE TRICKY. THIS ROUTINE IS NOT USUALLY       */  *\n*  /*  ENTERED LIKE A REGULAR SUBROUTINE (EG, BAL(R)). RATHER,    */  *\n*  /*  IT IS USED TO PROCESS A NON-ZERO RETURN CODE FROM A VTAM   */  *\n*  /*  RPL-BASED REQUEST ISSUED FROM A SUBROUTINE THAT WAS        */  *\n*  /*  ENTERED WITH A BAS R9,<> INSTRUCTION.  IT IS ENTERED       */  *\n*  /*  WITH A SIMPLE BRANCH WITH R9 POINTING TO AN EVENTUAL       */  *\n*  /*  RETURN ADDRESS. THIS ROUTINE DOES NOT RETURN VIA R9.       */  *\n*  /*  INSTEAD, IT BRANCHES DIRECTLY TO CLOSEPR FOR SESSION       */  *\n*  /*  SHUTDOWN AND STATUS FLAG SETTING. CLOSEPR WILL RETURN TO   */  *\n*  /*  THE CALLER OF THE ROUTINE THAT CALLED THIS ROUTINE VIA     */  *\n*  /*  BSM 0,R9. WELL, I SAID IT WAS A LITTLE TRICKY.             */  *\n*  /*  ON ENTRY: R15=RETURN CODE, R1=RPL ADDRESS.                 */  *\n*  /***************************************************************/  *\n*                                                                     *\n*        FORMAT AND ISSUE RPL ERROR MESSAGE;                          *\n*        GO TO CLOSEPR FOR SHUTDOWN SERVICES;        /*  CLOSEPR  */  *\n***********************************************************************\n         SPACE\nRPLERR   DS    0H\n         STCM  R15,B'0011',ERRRPL15    ---\n         UNPK  HEXWORK(5),ERRRPL15(3)  - CONVERT R15\n         TR    HEXWORK(4),HEXTABLE     - TO HEX\n         MVC   ERRRPL15,HEXWORK        ---\n         SPACE\n         USING IFGRPL,R1\n         UNPK  HEXWORK(3),RPLREQ(2)    ---\n         TR    HEXWORK(2),HEXTABLE     - RPLREQ   TO HEX\n         MVC   ERRRPLRQ,HEXWORK        ---\n         UNPK  HEXWORK(3),RPLRTNCD(2)  ---\n         TR    HEXWORK(2),HEXTABLE     - RPLRTNCD TO HEX\n         MVC   ERRRPLRC,HEXWORK        ---\n         UNPK  HEXWORK(3),RPLFDB2(2)   ---\n         TR    HEXWORK(2),HEXTABLE     - RPLFDB2  TO HEX\n         MVC   ERRRPLRS,HEXWORK        ---\n         UNPK  HEXWORK(9),RPLFDBK2(5)  ---\n         TR    HEXWORK(8),HEXTABLE     - RPLFDBK2 TO HEX\n         MVC   ERRRPLFB,HEXWORK        ---\n         DROP  R1\n         SPACE\n         WTO   MF=(E,ERRRPL)\n         SPACE\n         B     CLOSEPR             GO SET FLAGS AND SHUT DOWN SESSION\n         EJECT\n*EXIT******************************************************************\n*                                   /*  VTAM ERROR EXIT ROUTINES  */  *\n* VXLOSTRM:                                /*  VTAM LOSTERM EXIT  */  *\n*        ESTABLISH BASE REGISTERS AND ADDRESSABILITY;                 *\n*        POINT TO PROPER PARAMETERS FOR MESSAGE TEXT;                 *\n*        GO PROCESS;                                   /*  VXCOM  */  *\n*                                                                     *\n* VXTPEND:                                 /*  VTAM TPEND   EXIT  */  *\n*        ESTABLISH BASE REGISTERS AND ADDRESSABILITY;                 *\n*        POINT TO PROPER PARAMETERS FOR MESSAGE TEXT;                 *\n*        GO PROCESS;                                   /*  VXCOM  */  *\n***********************************************************************\n         SPACE\n         PUSH  USING\n         DROP  R8,R11,R13\n         SPACE\nVXLOSTRM DS    0H\n         USING VXLOSTRM,R15\n         L     R12,=A(TLBLMAIN)    REAL BASE\n         DROP  R15\n         LA    R2,=CL7'LOSTERM'    EXIT ID FOR MESSAGE\n         L     R3,X'04'(,R1)       REASON CODE PARAMETER FOR MESSAGE\n         B     VXCOM\n         SPACE\nVXTPEND  DS    0H\n         USING VXTPEND,R15\n         L     R12,=A(TLBLMAIN)    REAL BASE\n         DROP  R15\n         LA    R2,=CL7'TPEND'      EXIT ID FOR MESSAGE\n         L     R3,X'0C'(,R1)       REASON CODE PARAMETER FOR MESSAGE\n*        B     VXCOM\n         EJECT\n***********************************************************************\n* VXCOM:                    /*  COMMON PROCESSING FOR VTAM EXITS  */  *\n*        PRESERVE R14 FOR RETURN;                                     *\n*        ESTABLISH NEW SAVE AREA;                                     *\n*        FORMAT OPERATOR MESSAGE AND ISSUE WTO;                       *\n*        SET STOP REQUEST FLAG;                                       *\n*        GET KEY ZERO;                                                *\n*        POST WORK-TO-DO ECB;                                         *\n*        RESUME PROBLEM PROGRAM KEY;                                  *\n*        RETURN TO VTAM;                                              *\n***********************************************************************\n         SPACE\nVXCOM    DS    0H\n         LR    R9,R14              PRESERVE RETURN ADDRESS\n         LR    R4,R1               PRESERVE PARM LIST POINTER (IN CASE)\n         LA    R13,VXSAVE          PROVIDE SAVE AREA\n         USING VXSAVE,R13          POSSIBLE SECOND BASE REGISTER\n         SPACE\n         MVC   INTOEXNM,0(R2)      EXIT ID TO MESSAGE\n         STC   R3,HEXWORK+7            ---\n         UNPK  HEXWORK(3),HEXWORK+7(2) - REASON CODE\n         TR    HEXWORK(2),HEXTABLE     - TO MESSAGE\n         MVC   INTOEXRC,HEXWORK        ---\n         SPACE\n         WTO   MF=(E,INTOEXIT)\n         SPACE\n         OI    STATUS,STATSTPR     STOP REQUESTED\n         SPACE\n         L     R11,TLBLCVTA        TLBL CVT BASE\n         USING TLBLCVT,R11\n         SPACE\n         MODESET MF=(E,GETZERO)\n         SPACE\n         POST  TLBLECB             WORK-TO-DO\n         SPACE\n         MODESET MF=(E,GETNZERO)\n         SPACE\n         LR    R14,R9              RESTORE RETURN ADDRESS\n         BR    R14                 RETURN TO VTAM\n         SPACE\n         POP USING\n         EJECT\n*SUB*******************************************************************\n* COMMAND:                         /*  PROCESS OPERATOR COMMANDS  */  *\n*        COPY CONSOLE ID FROM CIB;                                    *\n*        IF (COMMAND VERB IS 'STOP')                                  *\n*          THEN DO;                                                   *\n*                 CALL PROCESSING SUBROUTINE;        /*  COMTERM  */  *\n*                 GO FREE CIB AND RETURN;            /*  COMM900  */  *\n*               END;                                                  *\n*        IF (COMMAND VERB IS NOT 'MODIFY')                            *\n*           THEN GO ISSUE ERROR MSG AND RETURN;     /*  COMM700  */  *\n***********************************************************************\n         SPACE\nCOMMAND  DS    0H\n         L     R7,COMM             GET COMM AREA ADDRESS\n         USING COMLIST,R7\n         L     R6,COMCIBPT         POINT TO CIB\n         USING CIB,R6\n         SPACE\n         MVC   CONID,CIBCONID      SAVE ID OF CONSOLE\n         SPACE\n         CLI   CIBVERB,CIBSTOP     STOP VERB?\n         BNE   COMM120             NOPE...ONWARD\n         BAL   R9,COMTERM          PROCESS TERMINATION REQUEST\n         B     COMM900             GO RETURN\nCOMM120  DS    0H\n         SPACE\n         CLI   CIBVERB,CIBMODFY    MODIFY VERB?\n         BNE   COMM700             NOPE...TILT\n         EJECT\n***********************************************************************\n* COMM300:                             /*  ROUTE MODIFY COMMAND   */  *\n*        LOOK UP COMMAND IN MODIFY TABLE;                             *\n*        IF (FOUND IN TABLE)                                          *\n*          THEN DO;                                                   *\n*                 CALL PROCESSING ROUTINE AS SPECIFIED IN TABLE;      *\n*                 GO ISSUE COMMAND ACCEPTED MESSAGE  /*  COMM800  */  *\n*                END;                                                 *\n***********************************************************************\n         SPACE\nCOMM300  DS    0H\n         LA    R15,MODFYTBC        LOOP COUNTER\n         LA    R14,MODFYTBL        COMMAND TABLE\n         USING CMDTABLE,R14\n         LH    R3,CIBDATLN         LENGTH OF ENTERED COMMAND\n         SPACE\nCOMM320  DS    0H\n         XR    R1,R1               CLEAR WORK REGISTER FOR LENGTH\n         IC    R1,CMDTLEN          MATCH LENGTH\n         IC    R2,CMDCOMPR         MASK FOR EXECUTED BRANCH\n         CR    R1,R3               COMPARE TO ACTUAL\n         EX    R2,BCTEXT           GO LOOP TO COMM380 IF WRONG LENGTH\n         SPACE\n         L     R2,CMDTEXT          ADDRESS OF COMPARE STRING\n         BCTR  R1,0                DECREMENT FOR EXECUTE\n         EX    R1,CLCTEXT          COMPARE TEXTS\n         BNE   COMM380             LOOP IF NOT EQUAL\n         SPACE\n         L     R1,CMDENTRY         PROCESSING ROUTINE ENTRY POINT\n         BALR  R9,R1               GO DO IT\n         B     COMM800             GO ISSUE ACCEPTED MESSAGE\n         SPACE\nCOMM380  DS    0H\n         LA    R14,CMDTBLL(,R14)   NEXT TABLE ENTRY\n         BCT   R15,COMM320         LOOP\n         SPACE\n         DROP  R14\n         EJECT\n***********************************************************************\n* COMM700:                /*  ISSUE GENERIC OPCOMM ERROR MESSAGE  */  *\n*        ISSUE INVALID OPERATOR COMMAND MESSAGE;                      *\n*        GO FREE CIB AND RETURN;                     /*  COMM900  */  *\n***********************************************************************\n         SPACE\nCOMM700  DS    0H\n         MVI   BADCMDTX,C' '       CLEAR MESSAGE BUFFER\n         MVC   BADCMDTX+1(L'BADCMDTX-1),BADCMDTX\n         LA    R1,L'BADCMDTX       MAXIMUM LENGTH\n         CR    R1,R3               COMPARE TO ACTUAL LENGTH\n         BNL   COMM710             GO IF OKAY\n         LR    R3,R1               SET TO MAXIMUM LENGTH\nCOMM710  DS    0H\n         BCTR  R3,0                DECREMENT FOR EXECUTE\n         EX    R3,MVCBADTX         MOVE IT\n         SPACE\n         L     R0,CONSOLE          GET CONSOLE ID\n         WTO   MF=(E,BADCMD)\n         SPACE\n         B     COMM900             ONWARD TO EXIT\n         SPACE 3\n***********************************************************************\n* COMM800:            /*  ISSUE GENERIC OPCOMM COMPLETED MESSAGE  */  *\n*        ISSUE COMMAND COMPLETED MESSAGE;                             *\n***********************************************************************\n         SPACE\nCOMM800  DS    0H\n         L     R7,COMM             REFRESH COMM AREA ADDRESS\n         L     R6,COMCIBPT         REFRESH POINTER TO CIB\n         LH    R3,CIBDATLN         REFRESH COMMAND LENGTH\n         SPACE\n         MVI   OKCMDTX,C' '        CLEAR MESSAGE BUFFER\n         MVC   OKCMDTX+1(L'OKCMDTX-1),OKCMDTX\n         LA    R1,L'OKCMDTX        MAXIMUM LENGTH\n         CR    R1,R3               COMPARE TO ACTUAL LENGTH\n         BNL   COMM810             GO IF OKAY\n         LR    R3,R1               SET TO MAXIMUM LENGTH\nCOMM810  DS    0H\n         BCTR  R3,0                DECREMENT FOR EXECUTE\n         EX    R3,MVCOKTX          MOVE IT\n         SPACE\n         L     R0,CONSOLE          GET CONSOLE ID\n         WTO   MF=(E,OKCMD)\n         EJECT\n***********************************************************************\n* COMM900:                          /*  COMMAND FINAL PROCESSING  */  *\n*        FREE THE CIB;                                                *\n*        RETURN TO CALLER VIA R10;                                    *\n***********************************************************************\n         SPACE\nCOMM900  DS    0H\n         QEDIT ORIGIN=COMCIBPT,BLOCK=(R6)\n         SPACE\n         BR    R10                 RETURN TO CALLER\n         SPACE\nBCTEXT   BC    *-*,COMM380           EXECUTED - AFTER CMD LEN COMPARE\nCLCTEXT  CLC   CIBDATA(*-*),0(R2)    EXECUTED - COMPARE COMMAND TEXT\nMVCOKTX  MVC   OKCMDTX(*-*),CIBDATA  EXECUTED - COMPLETE MESSAGE\nMVCBADTX MVC   BADCMDTX(*-*),CIBDATA EXECUTED - COMPLETE MESSAGE\n         SPACE\n         DROP  R6,R7\n         EJECT\n***********************************************************************\n* COMDQ:                  /*  PROCESS MODIFY DQ OPERATOR COMMAND  */  *\n*        DO UNTIL (END OF TLBLABEL QUEUE);                            *\n*          COUNT QUEUED ENTRY;                                        *\n*        END;                                                         *\n*        FORMAT AND ISSUE QUEUE CONTENTS COMMAND;                     *\n*        RETURN TO CALLER VIA R9;                                     *\n***********************************************************************\n         SPACE\nCOMDQ    DS    0H\n         XR    R15,R15             COUNTER\n         LM    R6,R7,TLBLPTRS      GET HEAD AND TAIL\n         LTR   R8,R6               ANYTHING THERE?\n         BZ    COMDQ80             NOPE...DONE\n         USING TLBLABEL,R8\n         SPACE\nCOMDQ20  DS    0H\n         LA    R15,1(,R15)         BUMP COUNTER\n         CR    R8,R7               ARE WE AT THE INITIAL TAIL?\n         BE    COMDQ80             YEP...DONE\n         L     R8,LABELNXT         NEXT ENTRY ON CHAIN\n         B     COMDQ20\n         SPACE\nCOMDQ80  DS    0H\n         CVD   R15,DWORK           CONVERT R15 TO PACKED\n         MVC   DQCNT,EDITCNT       EDIT PATTERN\n         ED    DQCNT,DWORK+6       UNPACK IT\n         SPACE\n         L     R0,CONSOLE          GET CONSOLE ID\n         WTO   MF=(E,DQMSG)\n         SPACE\n         BR    R9                  RETURN TO CALLER\n         EJECT\n***********************************************************************\n* COMSTART:            /*  PROCESS MODIFY START OPERATOR COMMAND  */  *\n*        SET START REQUEST FLAG;                                      *\n*        RESET VERIFY REQUEST, STOP REQUEST AND VERIFY IN PROGRESS;   *\n*        RETURN TO CALLER VIA R9;                                     *\n***********************************************************************\n         SPACE\nCOMSTART DS    0H\n         OI    STATUS,STATSTRT     START REQUEST\n         NI    STATUS,X'FF'-(STATSTPR+STATVFY+STATVFYP) CLEAR THESE\n         BR    R9                  RETURN TO CALLER\n         SPACE 3\n***********************************************************************\n* COMSTOP:              /*  PROCESS MODIFY STOP OPERATOR COMMAND  */  *\n*        SET STOP REQUEST FLAG;                                       *\n*        RESET VERIFY REQUEST, START REQUEST AND VERIFY IN PROGRESS;  *\n*        RETURN TO CALLER VIA R9;                                     *\n***********************************************************************\n         SPACE\nCOMSTOP  DS    0H\n         OI    STATUS,STATSTPR     STOP REQUEST\n         NI    STATUS,X'FF'-(STATSTRT+STATVFY+STATVFYP) CLEAR THESE\n         BR    R9                  RETURN TO CALLER\n         SPACE 3\n***********************************************************************\n* COMVERFY:           /*  PROCESS MODIFY VERIFY OPERATOR COMMAND  */  *\n*        SET START AND VERIFY REQUEST FLAGS;                          *\n*        RESET STOP REQUEST AND VERIFY IN PROGRESS;                   *\n*        RETURN TO CALLER VIA R9;                                     *\n***********************************************************************\n         SPACE\nCOMVERFY DS    0H\n         OI    STATUS,STATSTRT+STATVFY          START, VERIFY REQUEST\n         NI    STATUS,X'FF'-(STATSTPR+STATVFYP) CLEAR THESE\n         BR    R9                  RETURN TO CALLER\n         SPACE 3\n***********************************************************************\n* COMPURGE:            /*  PROCESS MODIFY PURGE OPERATOR COMMAND  */  *\n*        SET PURGE REQUEST FLAG;                                      *\n*        RETURN TO CALLER VIA R9;                                     *\n***********************************************************************\n         SPACE\nCOMPURGE DS    0H\n         OI    STATUS,STATPURG     PURGE REQUEST\n         BR    R9                  RETURN TO CALLER\n         EJECT\n***********************************************************************\n* COMSTATE:                   /*  PROCESS STATE OPERATOR COMMAND  */  *\n*        COMPLETE AND ISSUE STATE MESSAGE;                            *\n*        RETURN TO CALLER VIA R9;                                     *\n***********************************************************************\n         SPACE\nCOMSTATE DS    0H\n         MVC   STATEMLU,LUNAME     LU NAME TO MESSAGE\n         SPACE\n         TM    STATUS,STATVFY+STATVFYP  VERIFY IN PROGRESS?\n         BNZ   COMST100            YEP...SET TEXT\n         TM    STATUS,STATSTOP     STOPPED?\n         BO    COMST200            YEP...SET TEXT\n         SPACE\n         MVC   STATEMST,=CL20'STARTED'\n         B     COMST800            GO PRINT IT\n         SPACE\nCOMST100 DS    0H\n         MVC   STATEMST,=CL20'VERIFY IN PROGRESS'\n         B     COMST800            GO PRINT IT\n         SPACE\nCOMST200 DS    0H\n         MVC   STATEMST,=CL20'STOPPED'\n         SPACE\nCOMST800 DS    0H\n         L     R0,CONSOLE          GET CONSOLE ID\n         WTO   MF=(E,STATEMSG)\n         SPACE\n         BR    R9                  RETURN TO CALLER\n         SPACE 3\n***********************************************************************\n* COMTERM:                     /*  PROCESS STOP OPERATOR COMMAND  */  *\n*        SET TERMINATION REQUEST FLAG;                                *\n*        ISSUE 'STOP COMMAND ACCEPTED' MESSAGE;                       *\n*        RETURN TO CALLER VIA R9;                                     *\n***********************************************************************\n         SPACE\nCOMTERM  DS    0H\n         OI    STATUS,STATTERM     STOP (TERMINATE) REQUEST\n         SPACE\n         WTO   MF=(E,OKSTOP)\n         SPACE\n         BR    R9                  RETURN TO CALLER\n         EJECT\n***********************************************************************\n*        WORKAREAS                                                    *\n***********************************************************************\n         SPACE\nSAVEAREA DS    18F\nVXSAVE   DS    18F                 VTAM EXIT SAVE AREA\nSAVE9    DS    F                   INTERNAL SUBROUTINE LINKAGE\nSAVEPARM DS    A                   PARM LIST POINTER\nCOMM     DS    A                   COMMUNICATIONS AREA\nSSCVTA   DS    A                   SSCVT ADDRESS\nTLBLCVTA DS    A                   TLBLCVT ADDRESS\n         SPACE\nCONSOLE  DS    A(*-*)\nCONID    EQU   CONSOLE+3,1,C'X'\n         SPACE\nFLAGS    DS    0F\nSTATUS   DC    X'00'               GENERAL STATUS\nSTATTERM EQU   X'80'               TERMINATION REQUESTED\nSTATSTOP EQU   X'40'               OUTPUT STOPPED\nSTATSTPR EQU   X'20'               STOP REQUESTED\nSTATSTRT EQU   X'10'               START REQUESTED\nSTATVFY  EQU   X'08'               VERIFY REQUESTED\nSTATVFYP EQU   X'04'               VERIFY IN PROGRESS\nSTATPURG EQU   X'02'               PURGE QUEUE REQUESTED\nPARMOPTS DC    X'00'               RESERVED\nPARMCLRQ EQU   X'80'               COLD START - CLEAR QUEUE\nPARMBADP EQU   X'01'               BAD PARM FIELD\nFLAG3    DC    X'00'               RESERVED\nFLAG4    DC    X'00'               RESERVED\n         SPACE\nECBLIST  DS    (0*2)A\nWTDECBA  DS    A                   WORK-TO-DO ECB ADDRESS\nSMECBA   DS    A                   STOP/MODIFY ECB ADDRESS\n         SPACE\nLUNAME   DC    CL8' '              VTAM PRINTER LU NAME\nSTYPE    DC    CL8'WARM'           START TYPE\nISTATE   DC    CL8'VERIFY'         INITIAL STATE\nLOGMODE  DC    CL8'DSILGMOD'       LOGON MODE SET NAME\n         SPACE\nDWORK    DS    0D                  DECIMAL CONVERSION WORKAREA\nHEXWORK  DS    CL9                 HEX CONVERSION WORKAREA\n         EJECT\n***********************************************************************\n*        CONSTANTS AND LITERALS                                       *\n***********************************************************************\n         SPACE\nSSNAME   DS    0CL4                    SUBSYSTEM NAME FOR SSCVT LOOKUP\nQNAME    DC    CL8'TLBL'               QNAME FOR ACTIVE LOCK\nRNAME    DC    CL(L'TLBLRNAM)'ACTIVE'  RNAME FOR ACTIVE LOCK\nAPPLNAME DC    AL1(8),CL8'TAPELABL'    VTAM APPLICATION NAME\n         SPACE\nFREEBLOK DC    0A(*-*),AL1(LABELSBP),AL3(LABELLEN)\nGETMCVT  DC    0A(*-*),AL1(TLBLSUBP),AL3(TLBLLEN)\n         SPACE\nGETSUP   MODESET MODE=SUP,MF=L\nGETPROB  MODESET MODE=PROB,MF=L\nGETZERO  MODESET KEY=ZERO,MF=L\nGETNZERO MODESET KEY=NZERO,MF=L\n         SPACE\nLOCKTEST ENQ   (QNAME,RNAME,E,L'TLBLRNAM,SYSTEM),RET=TEST,MF=L\nLOCKUSE  ENQ   (QNAME,RNAME,E,L'TLBLRNAM,SYSTEM),RET=USE,MF=L\nLOCKFREE ENQ   (QNAME,RNAME,E,L'TLBLRNAM,SYSTEM),RET=NONE,MF=L\n         SPACE\nOCACBL   OPEN  PRACB,MF=L\n         SPACE\nEDITCNT  DC    X'40202120'           EDIT PATTERN - 3 DIGITS\nEDITDATE DC    X'21204B202020'       EDIT PATTERN - YY.DDD\nEDITTIME DC    X'4020217A20207A2020' EDIT PATTERN - HH:MM:SS\n         SPACE\nHEXTABLE EQU   *-C'0',256,C'X'\n         DC    C'0123456789ABCDEF'\n         SPACE\nPARMTBL  DS    0D                  LIKE A PARSE TABLE FOR THE PARM\n*                                  FIELD. THIS TABLE IS DEPENDENT ON\n*                                  THE ORDER IN THE PARM STRING.\n         DC    A(LUNAME,L'LUNAME-1)\n         DC    A(STYPE,L'STYPE-1)\n         DC    A(ISTATE,L'ISTATE-1)\n         DC    A(LOGMODE,L'LOGMODE-1)\nPARMTBLC EQU   (*-PARMTBL)/L'PARMTBL\n         SPACE\n         DS    0D\nDELIMTBL DS    XL256'00'           TRT TABLE TO LOCATE DELIMITERS\n         ORG   DELIMTBL+C','\n         DC    C','\n         ORG\n         SPACE\nPRNTABLE DS    0D\n*                 0 1 2 3 4 5 6 7 8 9 A B C D E F\n         DC    X'79797979797979797979797979797979'  0\n         DC    X'79797979797979797979797979797979'  1\n         DC    X'79797979797979797979797979797979'  2\n         DC    X'79797979797979797979797979797979'  3\n         DC    X'407979797979797979794A4B4C4D4E4F'  4\n         DC    X'507979797979797979795A5B5C5D5E5F'  5\n         DC    X'606179797979797979796A6B6C6D6E6F'  6\n         DC    X'797979797979797979797A7B7C7D7E7F'  7\n         DC    X'79818283848586878879797979797979'  8\n         DC    X'79919293949596979879797979797979'  9\n         DC    X'79A1A2A3A4A5A6A7A8A9797979797979'  A\n         DC    X'79797979797979797979797979797979'  B\n         DC    X'C0C1C2C3C4C5C6C7C8C9797979797979'  C\n         DC    X'D0D1D2D3D4D5D6D7D8D9797979797979'  D\n         DC    X'E0E1E2E3E4E5E6E7E8E9797979797979'  E\n         DC    X'F0F1F2F3F4F5F6F7F8F9797979797979'  F\n         SPACE\n         DS    0F\nVFYPATRN DC    XL(LABELLEN)'00'    DUMMY TLBLABEL FOR VERIFY\n         ORG   VFYPATRN-TLBLABEL+LABELCHR\n         DC    (LABELCHL)C'X'\n         ORG\n         SPACE\n         LTORG\n         EJECT\n***********************************************************************\n*        MESSAGES AND COMMAND ROUTING TABLES                          *\n***********************************************************************\n         SPACE\n         PRINT NOGEN\nNOLUNAME WTO   'PARAMETER LUNAME NOT SPECIFIED',                       +\n               ROUTCDE=(2,11),DESC=(4,7),MF=L\n         SPACE\nBADSTYPE WTO   'PARAMETER START TYPE INVALID - MUST BE HOT, WARM OR COL+\n               D',ROUTCDE=(2,11),DESC=(4,7),MF=L\n         SPACE\nBADISTAT WTO   'PARAMETER INITIAL STATE INVALID - MUST BE START, STOP O+\n               R VERIFY',ROUTCDE=(2,11),DESC=(4,7),MF=L\n         SPACE\nBADLOCK  WTO   'UNABLE TO GET ACTIVE LOCK',                            +\n               ROUTCDE=(2,11),DESC=(4,7),MF=L\n         SPACE\nINITCPLT WTO   'TAPE LABEL WRITER INITIALIZATION COMPLETE',            +\n               ROUTCDE=(2,11),DESC=(4,7),MF=L\n         SPACE\nBADCMD   WTO   'INVALID OPERATOR COMMAND: 12345678901234567890123456789+\n               012345678901234567890',                                 +\n               MCSFLAG=REG0,MF=L\nBADCMDTX EQU   BADCMD+2+2+26,50,C'C' VARIABLE PART OF MESSAGE\n         SPACE\nPARMMSG  WTO   'LU NAME=12345678 START TYPE=1234 INITIAL STATE=123456 L+\n               OGMODE=12345678',                                       +\n               ROUTCDE=(2,11),DESC=(4,7),MF=L\nPMSGLU   EQU   PARMMSG+2+2+08,8,C'C'\nPMSGSTRT EQU   PARMMSG+2+2+28,4,C'C'\nPMSGSTAT EQU   PARMMSG+2+2+47,6,C'C'\nPMSGLMOD EQU   PARMMSG+2+2+62,8,C'C'\n         SPACE\nOKCMD    WTO   'OPERATOR COMMAND COMPLETED: 123456789012345678901234567+\n               89012345678901234567890',                               +\n               MCSFLAG=REG0,MF=L\nOKCMDTX  EQU   OKCMD+2+2+28,50,C'C'  VARIABLE PART OF MESSAGE\n         SPACE\nOKSTOP   WTO   'STOP COMMAND ACCEPTED',                                +\n               MCSFLAG=REG0,MF=L\n         SPACE\nSTATEMSG WTO   'LU=12345678  STATE=12345678901234567890',              +\n               MCSFLAG=REG0,MF=L\nSTATEMLU EQU   STATEMSG+2+2+03,8,C'C'\nSTATEMST EQU   STATEMSG+2+2+19,20,C'C'\n         SPACE\nERRACB   WTO   'ERROR OPENING VTAM ACB  R15=1234  ACBERFLG=12',        +\n               ROUTCDE=(2,11),DESC=(4,7),MF=L\nERRACB15 EQU   ERRACB+2+2+28,4,C'C'\nERRACBFL EQU   ERRACB+2+2+43,2,C'C'\n         SPACE\nERRRPL   WTO   'VTAM RPL REQUEST ERROR  R15=1234  RPLREQ=12  RPLRTNCD=1+\n               2  RPLFDB2=12  SENSE=12345678',                         +\n               ROUTCDE=(2,11),DESC=(4,7),MF=L\nERRRPL15 EQU   ERRRPL+2+2+28,4,C'C'\nERRRPLRQ EQU   ERRRPL+2+2+41,2,C'C'\nERRRPLRC EQU   ERRRPL+2+2+54,2,C'C'\nERRRPLRS EQU   ERRRPL+2+2+66,2,C'C'\nERRRPLFB EQU   ERRRPL+2+2+76,8,C'C'\n         SPACE\nDQMSG    WTO   '1234 TAPE LABELS CURRENTLY QUEUED',                    +\n               MCSFLAG=REG0,MF=L\nDQCNT    EQU   DQMSG+2+2+00,4,C'C'\n         SPACE\nINTOEXIT WTO   'TLBL VTAM 1234567 EXIT ENTERED -- REASON=12',          +\n               ROUTCDE=(2,11),DESC=(4,7),MF=L\nINTOEXNM EQU   INTOEXIT+2+2+10,7,C'C'\nINTOEXRC EQU   INTOEXIT+2+2+41,2,C'C'\n         SPACE 3\nMODFYTBL DS    0F                  MODIFY COMMAND ROUTING TABLE.\n         DC    A(CDQ,COMDQ),AL1(CMDEXACT,L'CDQ,*-*,*-*)\n         DC    A(CPURGE,COMPURGE),AL1(CMDEXACT,L'CPURGE,*-*,*-*)\n         DC    A(CSTART,COMSTART),AL1(CMDEXACT,L'CSTART,*-*,*-*)\n         DC    A(CSTATE,COMSTATE),AL1(CMDEXACT,L'CS,*-*,*-*)\n         DC    A(CSTATE,COMSTATE),AL1(CMDEXACT,L'CSTATE,*-*,*-*)\n         DC    A(CSTOP,COMSTOP),AL1(CMDEXACT,L'CSTOP,*-*,*-*)\n         DC    A(CVERIFY,COMVERFY),AL1(CMDEXACT,L'CVERIFY,*-*,*-*)\n         DC    A(CVERIFY,COMVERFY),AL1(CMDEXACT,L'CV,*-*,*-*)\nMODFYTBC EQU   (*-MODFYTBL)/CMDTBLL NUMBER OF ENTRIES IN TABLE\n         SPACE\nCDQ      DC    C'DQ'\nCPURGE   DC    C'PURGE'\nCS       DC    C'S'\nCSTART   DC    C'START'\nCSTATE   DC    C'STATE'\nCSTOP    DC    C'STOP'\nCV       DC    C'V'\nCVERIFY  DC    C'VERIFY'\n         EJECT\n***********************************************************************\n*        VTAM CONTROL BLOCKS                                          *\n***********************************************************************\n         SPACE\nPRACB    ACB   AM=VTAM,APPLID=APPLNAME,EXLST=PREXLST\n         SPACE\nPREXLST  EXLST AM=VTAM,LOSTERM=VXLOSTRM,TPEND=VXTPEND\n         SPACE\nPRNIB    NIB   LISTEND=YES,MODE=RECORD\n         SPACE\nPRRPL1   RPL   AM=VTAM,ACB=PRACB\n         SPACE\nPRRPL2   RPL   AM=VTAM,ACB=PRACB,                                      +\n               AREA=BUFFER,AREALEN=BUFLEN,RECLEN=BUFLEN,               +\n               CONTROL=DATA,POST=RESP,STYPE=REQ,                       +\n               BRACKET=(BB,EB),RESPOND=(NEX,FME,NRRN),CHAIN=ONLY\n         SPACE 3\n***********************************************************************\n*        328X DATASTREAM CONTROL CHARACTERS                           *\n***********************************************************************\n         SPACE\nEW       EQU   X'F5'               ERASE WRITE COMMAND\nWCC      EQU   X'C8'               WCC - RESET, NOFMT, START PRINT\nFF       EQU   X'0C'               FORM FEED\nCR       EQU   X'0D'               CARRIAGE RETURN\nNL       EQU   X'15'               NEW LINE\nEM       EQU   X'19'               END MESSAGE\nSF       EQU   X'1D'               START FIELD\nFA       EQU   X'40'               FIELD ATTRIBUTE CHARACTER\n         EJECT\n***********************************************************************\n*        PRINTER OUTPUT AND FORMATTING BUFFER                         *\n***********************************************************************\n         SPACE\nBUFFER   DS    0D\n         SPACE\n*              LINE 1\n         SPACE\n         DC    AL1(EW,WCC,FF),CL13' ' NOTE ONE BYTE LESS SPACE ON LINE1\nBUFVOL1  DS    CL(L'LABELSER)\n         DC    AL1(CR),CL14' '\nBUFVOL2  DS    CL(L'LABELSER)\n         SPACE\n*              LINE 2\n         SPACE\n         DC    AL1(NL)\n         SPACE\n*              LINE 3\n         SPACE\n         DC    AL1(NL),CL5' '\nBUFDEV1  DS    CL(L'LABELDEV)\n         DC    CL7' '\nBUFVNO1  DS    CL(L'LABELVNO)\n         DC    CL6' '\nBUFDEN1  DS    CL(L'LABELDEN)\n         DC    AL1(CR),CL5'UNIT'\nBUFDEV2  DS    CL(L'LABELDEV)\n         DC    CL7'  REEL'\nBUFVNO2  DS    CL(L'LABELVNO)\n         DC    CL6'  DEN'\nBUFDEN2  DS    CL(L'LABELDEN)\n         SPACE\n*              LINE 4\n         SPACE\n         DC    AL1(NL),CL10' '\nBUFLID1  DS    CL(L'LABELLID)\n         DC    CL8' '\nBUFLAB1  DS    CL(L'LABELTYP)\n         DC    AL1(CR),CL10'ACF2 USER'\nBUFLID2  DS    CL(L'LABELLID)\n         DC    CL8'  LABEL'\nBUFLAB2  DS    CL(L'LABELTYP)\n         SPACE\n*              LINE 5\n         SPACE\n         DC    AL1(NL),CL5' '\nBUFDAT1  DS    CL(L'EDITDATE)\nBUFTIM1  DS    CL(L'EDITTIME)\n         DC    CL7' '\nBUFSIT1  DS    CL(L'LABELSIT)\n         DC    AL1(CR),CL5'TIME'\nBUFDAT2  DS    CL(L'EDITDATE)\nBUFTIM2  DS    CL(L'EDITTIME)\n         DC    CL7'  SITE '\nBUFSIT2  DS    CL(L'LABELSIT)\n         SPACE\n*              LINE 6\n         SPACE\n         DC    AL1(NL),CL4' '\nBUFJOB1  DS    CL(L'LABELJOB)\n         DC    CL1'('\nBUFJID1  DS    CL5\n         DC    CL7')'\nBUFSTP1  DS    CL(L'LABELSTP)\n         DC    AL1(CR),CL4'JOB'\nBUFJOB2  DS    CL(L'LABELJOB)\n         DC    CL1'('\nBUFJID2  DS    CL5\n         DC    CL7') STEP'\nBUFSTP2  DS    CL(L'LABELSTP)\n         SPACE\n*              LINE 7\n         SPACE\n         DC    AL1(NL),CL7' '\nBUFDSN1A DS    CL26\n         DC    AL1(CR),CL7'DSNAME'\nBUFDSN2A DS    CL(L'BUFDSN1A)\n         SPACE\n*              LINE 8\n         SPACE\nBREAKRNG EQU   8                   MAX LENGTH TO SEARCH FOR BREAK CHAR\n         DC    AL1(NL),CL((7+L'BUFDSN1A)-L'BUFDSN1B)' '\nBUFDSN1B DS    CL(L'LABELDSN-L'BUFDSN1A+BREAKRNG)\n         DC    AL1(CR),CL((7+L'BUFDSN1A)-L'BUFDSN1B)' '\nBUFDSN2B DS    CL(L'LABELDSN-L'BUFDSN1A+BREAKRNG)\n         SPACE\n         DC    AL1(NL,NL,C'.',EM)\n         SPACE\nBUFLEN   EQU   *-BUFFER\n         EJECT\n***********************************************************************\n*        DSECTS                                                       *\n***********************************************************************\n         SPACE\n         PRINT NOGEN\n         CVT   DSECT=YES\n         IEFJESCT\n         IEFJSCVT\nCIB      DSECT\n         IEZCIB\nCOMMD    DSECT\n         IEZCOM\n         IFGACB DSECT=YES,AM=VTAM\n         IFGRPL DSECT=YES,AM=VTAM\n         IHAASCB\n         IHAECB\n         IHAPSA\n         ISTDNIB\n         SPACE\n         PRINT GEN\n         REGS\n         SPACE 2\nCMDTABLE DSECT ,                   MODIFY COMMAND ROUTING\nCMDTEXT  DS    A                   ADDRESS OF MODIFY TEXT\nCMDENTRY DS    A                   PROCESSING ROUTINE ENTRY POINT\nCMDCOMPR DS    X                   MASK FOR BRANCH AFTER COMPARE\nCMDEXACT EQU   X'70'               LENGTHS MUST MATCH EXACTLY\nCMDOPERS EQU   X'20'               COMMAND CAN BE LONGER (OPERANDS)\nCMDTLEN  DS    X                   LENGTH THAT MUST MATCH\nCMDRESV  DS    XL2                 RESERVED\nCMDTBLL  EQU   *-CMDTABLE          LENGTH IN BYTES\n         SPACE 2\n         TLBLCVT\n         SPACE 2\n         TLBLABEL\n         SPACE 3\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TLBLMXIT": {"ttr": 11270, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x02F\\x02F\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 582, "newlines": 582, "modlines": 0, "user": "FILE369"}, "text": "         TITLE 'TLBLMXIT -- TAPE LABEL WRITER MESSAGE INTERCEPT EXIT'\n***********************************************************************\n*                                                                     *\n* NAME         TLBLMXIT                                               *\n*                                                                     *\n* COMPONENT    TAPE LABEL WRITER                                      *\n*                                                                     *\n* FUNCTION     QUEUE REQUESTS FOR EXTERNAL TAPE LABELS                *\n*                                                                     *\n* ENTRY        FROM WTO PROCESSOR VIA MPFLSTXX PARAMETER FOR IEC705I. *\n*                                                                     *\n* PARAMETERS   CTXT                                                   *\n*                                                                     *\n* INPUT        IEC705I MESSAGE TEXT                                   *\n*                                                                     *\n* OUTPUT       REQUEST QUEUED FOR TLBLMAIN                            *\n*                                                                     *\n* RETURN CODES NONE                                                   *\n*                                                                     *\n* FILES        NONE                                                   *\n*                                                                     *\n* EXT REF      NONE                                                   *\n*                                                                     *\n* MESSAGES     NONE                                                   *\n*                                                                     *\n* MACROS       ACFINCVT                                               *\n*              ACFGUCB                                                *\n*              FREEMAIN                                               *\n*              GETMAIN                                                *\n*              POST                                                   *\n*              REGS                                                   *\n*              RETURN                                                 *\n*              SAVE                                                   *\n*              TIME                                                   *\n*                                                                     *\n* TABLES       ASCB       -- IHAASCB                                  *\n*              ACFASVT                                                *\n*              ACCVT                                                  *\n*              ACUCB                                                  *\n*              CTXT       -- IEZVX100                                 *\n*              CVT                                                    *\n*              DEB        -- IEZDEB                                   *\n*              DCB        -- DCBD                                     *\n*              ECB        -- IHAECB                                   *\n*              JFCB       -- IEFJFCBN                                 *\n*              JSCB       -- IEZJSCB                                  *\n*              JESCT      -- IEFJESCT                                 *\n*              PSA        -- IHAPSA                                   *\n*              SSCVT      -- IEFJSCVT                                 *\n*              SSIB       -- IEFJSSIB                                 *\n*              TCB        -- IKJTCB                                   *\n*              TIOT       -- IEFTIOT1                                 *\n*              TLBLABEL                                               *\n*              TLBLCVT                                                *\n*              UCB        -- IEFUCBOB                                 *\n*                                                                     *\n* OPERATION    |                                                      *\n*                                                                     *\n* ATTRIBUTES   REENTRANT                                              *\n*              REUSABLE                                               *\n*              AMODE 31                                               *\n*              RMODE ANY                                              *\n*              AUTHORIZED                                             *\n*              LNKLSTXX LIBRARY                                       *\n*              KEY ZERO                                               *\n*              SUPERVISOR STATE                                       *\n*                                                                     *\n* RESTRICTIONS IN ORDER TO GET THE VOLUME SEQUENCE (REEL) NUMBER      *\n*              IT'S NECESSARY TO LOCATE THE JFCB FOR WHICH THE        *\n*              IEC705I MSG IS BEING ISSUED. USUALLY ONE GOES          *\n*              THROUGH THE TIOT, BUT WITHOUT A DDNAME (ONLY A         *\n*              DEVICE NUMBER) IT'S NOT POSSIBLE TO ALWAYS FIND THE    *\n*              RIGHT ENTRY, SINCE UNIT=AFF LETS THERE BE MANY         *\n*              DEVICE ENTRIES FOR A GIVEN DEVICE.  THERE CAN BE       *\n*              ONLY ONE OPEN DATASET PER TAPE UNIT, SO RUNNING THE    *\n*              DEB CHAIN CAN FIND THE OPEN DS ACCESSING THAT          *\n*              DEVICE. UNFORTUNATLY, THERE IS NO DEB AT THE TIME      *\n*              IEC705I IS ISSUED FOR THE FIRST VOLUME; IT'S THERE     *\n*              FOR ALL THE OTHERS.  ONE COULD DEFAULT TO A REEL       *\n*              NUMBER OF ONE IN THE ABSENCE OF A DEB, AND             *\n*              COMMENTED-OUT CODE TO DO THAT IS INCLUDED AROUND       *\n*              MXIT4000. A LOCAL FUNCTION (MANUAL CHECKOUT OF         *\n*              TAPES) WOULD PRODUCE MISLEADING RESULTS (ALL REELS     *\n*              OF A DS AS NUMBER 1) HERE AT APS SO LET'S NOT DO       *\n*              THAT.                                                  *\n*                                                                     *\n* NOTES        ALTHOUGH THERE IS LOGIC IN HERE WHICH REFERENCES       *\n*              SUBSYSTEM TABLES, THE TAPE LABEL WRITER IS NOT A       *\n*              FORMAL SUBSYSTEM; IT NEVER ACTIVATES A SSVT SO IT      *\n*              MAKES NO USE OF SUBSYSTEM REQUEST ROUTING. THE SSCT    *\n*              USER FIELD IS USED AS A CONVENIENT ANCHOR FOR CSA      *\n*              CONTROL BLOCKS.                                        *\n*                                                                     *\n* AUTHOR       C. J. PITTS                                            *\n*                                                                     *\n* MAINTENANCE  WHO   DATE      DESCRIPTION                            *\n*              CJP   12/31/86  ADDED SUPPORT FOR JES JOB ID           *\n*              CJP    3/10/87  ADDED SUPPORT FOR REEL NUMBER          *\n*              CJP    6/ 5/87  FIXED BUG IN DEB LOOKUP: ONLY          *\n*                              CHECK DEBS WITH EXCP OR SEQ ACCMETH.   *\n*                              (OTHERS CAN'T BE TAPE AND MAY NOT      *\n*                              HAVE A UCB.)                           *\n*                                                                     *\n**********************************************************************/\n*                                                                     *\n* REGISTERS AT ENTRY                                                  *\n*              R1    POINTER TO CTXT ADDRESS WORD                     *\n*              R13   SAVE AREA                                        *\n*              R14   RETURN ADDRESS                                   *\n*              R15   ENTRY POINT                                      *\n*                                                                     *\n* REGISTER USE IN PROGRAM                                             *\n*              R7    WORKAREA                                         *\n*              R8    TLBLABEL                                         *\n*              R9    CTXT                                             *\n*              R10   CTXTATTR                                         *\n*              R11   TLBLCVT                                          *\n*              R12   BASE REGISTER                                    *\n*              R13   SAVE AREA                                        *\n*                                                                     *\n**********************************************************************/\n         SPACE 3\n***********************************************************************\n* TLBLMXIT:                                      /*  ENTRY POINT  */  *\n*        BRANCH AROUND DOCUMENTATION HEADER;                          *\n***********************************************************************\n         SPACE\nTLBLMXIT CSECT\n         SPACE\nTLBLMXIT AMODE 31\nTLBLMXIT RMODE ANY\n         SPACE\n         USING TLBLMXIT,R15        TEMPORARY BASE\n         B     BEGIN               SKIP OVER DOCUMENTATION\n         SPACE\n         DC    AL1(BEGIN-*)        LENGTH OF TEXT\nSRCLEVEL DC    C'TLBLMXIT VNN.MNN YY/MM/DD HH:MM UUUUUUUU'\n*                MODULE   VER/MOD   DATE   TIME  USER NAME\nCOPYRIGT DC    C' COPYRIGHT (C) 1987 PLANNING RESEARCH CORPORATION '\nASMSTAMP DC    C'ASM &SYSDATE &SYSTIME'\n         DROP  R15                 DONE WITH TEMPORARY BASE\n         SPACE\nBEGIN    DS    0H\n         EJECT\n***********************************************************************\n* MXIT0000:                                   /*  INITIALIZATION  */  *\n*        SAVE REGISTERS;                                              *\n*        SET PROGRAM BASE;                                            *\n*        LOCATE SSCVT;                                                *\n*        IF (UNABLE TO FIND SSCVT)                                    *\n*          THEN RETURN TO CALLER;                   /*  MXIT9900  */  *\n*        GET TLBLCVT ADDRESS FROM SSCT;                               *\n*        IF (NOT THERE)                                               *\n*          THEN RETURN TO CALLER;                   /*  MXIT9900  */  *\n***********************************************************************\n         SPACE\nMXIT0000 DS    0H\n         USING PSA,R0              ALWAYS\n         SPACE\n         SAVE  (14,12)             SAVE REGISTERS\n         SPACE\n         LR    R12,R15             SET BASE REGISTER\n         USING TLBLMXIT,R12\n         SPACE\n         L     R9,0(,R1)           CTXT ADDRESS PARAMETER\n         USING CTXT,R9\n         L     R10,CTXTTXPJ        POINT TO TEXT ATTRIBUTE LIST\n         USING CTXTATTR,R10\n         SPACE\n         L     R1,FLCCVT           CVT ADDRESS\n         USING CVT,R1\n         L     R1,CVTJESCT         JESCT ADDRESS\n         USING JESCT,R1\n         L     R7,JESSSCT          FIRST SSCVT ADDRESS\n         USING SSCT,R7\n         DROP  R1\n         SPACE\nMXIT0200 DS    0H\n         CLC   SSCTSNAM,SSNAME     IS THIS THE RIGHT SSCVT?\n         BE    MXIT0500            YEP...ONWARD\n         ICM   R7,B'1111',SSCTSCTA NEXT SSCT\n         BNZ   MXIT0200            LOOP IF IT EXISTS\n         SPACE\n         B     MXIT9900            NO GOT...RETURN TO CALLER\n         SPACE\nMXIT0500 DS    0H\n         ICM   R11,B'1111',SSCTSUSE GET POINTER TO TLBLCVT\n         USING TLBLCVT,R11\n         DROP  R7\n         BZ    MXIT9900            NOT THERE...RETURN TO CALLER\n         SPACE\n         ST    R12,TLBLEXEP        SAVE EP ADDRESS FOR DEBUGGING\n         EJECT\n***********************************************************************\n* MXIT2000:                                                           *\n*        GETMAIN WORKAREA FROM SYSTEM SUBPOOL;                        *\n*        CHAIN SAVE AREAS;                                            *\n*        IF (ACTIVE LOCK IS NOT HELD)                                 *\n*           THEN GO RETURN TO CALLER;               /*  MXIT9000  */  *\n***********************************************************************\n         SPACE\nMXIT2000 DS    0H\n         L     R0,GETWORK          LENGTH AND SUBPOOL FOR GETMAIN\n         GETMAIN R,LV=(0)\n         SPACE\n         LR    R7,R1               GOTTEN AREA ADDRESS\n         USING WORKAREA,R7\n         SPACE\n         LR    R15,R13             ---\n         LA    R13,WORKSAVE        -  SAVE AREA\n         ST    R15,4(,R13)         -  CHAINING\n         ST    R13,8(,R15)         ---\n         SPACE\n         MVC   WORKENQ(WORKENQL),ENQL INITIALIZE LIST FORM OF ENQ\n         ENQ   (TLBLQNAM,TLBLRNAM),MF=(E,WORKENQ)\n         SPACE\n         LTR   R15,R15             TEST RETURN CODE\n         BZ    MXIT9000            LOCK AVAILABLE...RETURN TO CALLER\n         CLI   3(R15),X'04'        LOCK HELD?\n         BNE   MXIT9000            NOPE...RETURN TO CALLER\n         EJECT\n***********************************************************************\n*        GETMAIN TLBLABEL BLOCK FROM CSA;                             *\n*        INITIALIZE TLBLABEL BLOCK;                                   *\n*        PLACE TIME AND DATE IN TAPELABL BLOCK;                       *\n*        LOCATE LIFE-OF-JOB SSIB -- TCB->JSTCB->JSCB->SSIB ;          *\n*        MOVE JES JOBLOG ID TO TLBLABEL BLOCK;                        *\n***********************************************************************\n         SPACE\n         L     R0,GETLBLOK         LENGTH AND SUBPOOL FOR GETMAIN\n         GETMAIN R,LV=(0)\n         LR    R8,R1               GOTTEN AREA ADDRESS\n         USING TLBLABEL,R8\n         SPACE\n         MVC   LABELEYE,=C'LABL'   EYECATCHER\n         SPACE\n         XC    LABELNXT,LABELNXT   NEXT POINTER\n         XC    LABELADD,LABELADD   COMPARE/SWAP ITERATION COUNTER\n         XC    LABELDEL,LABELDEL   COMPARE/SWAP ITERATION COUNTER\n         SPACE\n         MVI   LABELCHR,C' '       BLANK OUT CHARACTER FIELDS\n         MVC   LABELCHR+1(LABELCHL-1),LABELCHR  FILL AREA\n         SPACE\n         TIME  DEC\n         SPACE\n         ST    R0,LABELTIM         SAVE TIME\n         ST    R1,LABELDAT         SAVE DATE\n         SPACE\n         L     R1,PSATOLD          CURRENT (OLD) TCB\n         USING TCB,R1\n         L     R1,TCBJSTCB         JOB STEP TCB\n         ICM   R1,B'1000',=X'00'   CLEAR HIGH BYTE\n         ICM   R1,B'0111',TCBJSCBB JOB STEP CONTROL BLOCK (JSCB)\n         USING IEZJSCB,R1\n         L     R1,JSCBSSIB         SSIB\n         USING SSIB,R1\n         SPACE\n         MVC   LABELJID,SSIBJBID   JOBLOG ID\n         SPACE\n         DROP  R1\n         EJECT\n***********************************************************************\n* MXIT3000:                                /*  DESTRING WTO TEXT  */  *\n*        DO UNTIL( (ALL MESSAGE FIELDS ARE PROCESSED)    -- OR --     *\n*                  (MESSAGE TEXT AFTER TRIGGER IS EXHAUSTED) )        *\n*          FIND LENGTH OF NEXT FIELD IN MESSAGE;                      *\n*          IF (LENGTH > 0)                                            *\n*            THEN MOVE TEXT TO TLBLABEL BLOCK FIELD;                  *\n*        END;                                                         *\n***********************************************************************\n         SPACE\nMXIT3000 DS    0H\n         LH    R5,CTXTTLEN         MESSAGE LENGTH INCLUDING TRIGGER\n         S     R5,=A(L'TRIGGER+1)  LENGTH LESS TRIGGER+1 FOR EXECUTE\n         LA    R6,CTXTTMSG+L'TRIGGER FIRST INTERESTING BYTE\n         SPACE\n         LA    R14,MOVETBL         MOVE TABLE\n         LA    R15,MOVETBLC        LOOP COUNTER\n         SPACE\nMXIT3500 DS    0H\n         LTR   R5,R5               ANY CHARACTERS LEFT?\n         BM    MXIT3900            NOPE...DONE\n         SPACE\n         EX    R5,TRTDELIM         LOCATE NEXT DELIMITER\n         BNZ   MXIT3550            GO IF DELIMITER FOUND\n         SPACE\n         LR    R4,R5               LENGTH FOR EXECUTED MOVE\n         LA    R1,1(R6,R5)         FAKE OUT R1 FOR LATER LOOP CALCS\n         B     MXIT3600            GO FOR MOVE\n         SPACE\nMXIT3550 DS    0H\n         LR    R4,R1               ADDRESS OF DELIMITER\n         SR    R4,R6               COMPUTE LENGTH\n         BCTR  R4,0                DECREMENT FOR EXECUTE\n         SPACE\nMXIT3600 DS    0H\n         LM    R2,R3,0(R14)        GET OFFSET AND MAX LENGTH FOR MOVE\n         LA    R2,TLBLABEL(R2)     DESTINATION ADDRESS\n         LR    R1,R4               COPY LENGTH OF DATA\n         CR    R3,R1               CHECK LENGTH\n         BNL   MXIT3650            GO IF MAX LENGTH NOT EXCEEDED\n         LR    R1,R3               SET LENGTH TO MAXIMUM\nMXIT3650 DS    0H\n         LTR   R1,R1               CHECK LENGTH FOR EXECUTE\n         BM    MXIT3700            NULL FIELD...SKIP MOVE\n         EX    R1,MVCFIELD         MOVE SUITABLE LENGTH\n         SPACE\nMXIT3700 DS    0H\n         LA    R4,2(,R4)           ACCOUNT FOR DELIMITER, EXECUTE\n         SR    R5,R4               DECREMENT REMAINING COUNT\n         AR    R6,R4               BUMP ADDRESS PAST PROCESSED DATA\n         LA    R14,L'MOVETBL(,R14) BUMP TABLE POINTER\n         BCT   R15,MXIT3500        LOOP\n         SPACE\nMXIT3900 DS    0H\n         EJECT\n***********************************************************************\n* MXIT4000:                    /*  LOCATE VOLUME SEQUENCE NUMBER  */  *\n*   /*   INITIALIZE LABELVNO TO 1;  DISABLED --- SEE RESTRICTIONS */  *\n*        DO FOR ALL DEB'S;                                            *\n*          IF (DEBAMTYP IS EXCP OR SEQUENTIAL)                        *\n*            THEN DO;                                                 *\n*                   LOCATE UCB FROM DEBSUCBB;                         *\n*                   IF (UCBNAME=LABELDEV)                             *\n*                     THEN DO;                                        *\n*                            LOCATE JFCB: DEB->DCB->TIOT->JFCB;       *\n*                            IF (JFCBNVOL=0)                          *\n*                              THEN ADD 1 AND USE FOR VOLUME COUNT;   *\n*                              ELSE USE AS IS FOR VOLUME COUNT;       *\n*                            FORMAT LABELVNO;                         *\n*                            LEAVE DEB SEARCH LOOP;                   *\n*                          END;                                       *\n*                 END;                                                *\n*         END;                                                        *\n***********************************************************************\n         SPACE\nMXIT4000 DS    0H\n*        MVC   LABELVNO,=C'  1'    DEFAULT VOLUME SEQUENCE NUMBER\n         SPACE\n         XR    R15,R15             WORK REGISTER\n         L     R14,PSATOLD         CURRENT TCB\n         USING TCB,R14\n         SPACE\n         ICM   R1,B'1111',TCBDEB   DEB ORIGIN\n         SPACE\nMXIT4200 DS    0H\n         BZ    MXIT4900            NO MORE DEB'S -- ONWARD\n         SPACE\n         A     R1,=A(DEBPREFX-DEBBASIC) BACK UP TO POINT TO PREFIX\n         USING DEBPREFX,R1\n         SPACE\n         CLI   DEBAMTYP,DEBAMSAM   SEQUENTIAL ACCESS?\n         BE    MXIT4300            YEP...ONWARD...UCB EXISTS\n         CLI   DEBAMTYP,DEBAMXCP   EXCP ACCESS?\n         BNE   MXIT4800            NOPE...LOOP WITH NEXT DEB\nMXIT4300 DS    0H\n         SPACE\n         ICM   R15,B'0111',DEBSUCBB UCB ADDRESS\n         USING UCBOB,R15\n         SPACE\n         CLC   UCBNAME,LABELDEV    IS THIS THE RIGHT DEB/UCB?\n         BNE   MXIT4800            NOPE...ONWARD AND LOOP\n         SPACE\n         ICM   R15,B'0111',DEBDCBB DCB ADDRESS\n         USING IHADCB,R15\n         SPACE\n         L     R14,TCBTIO          TCB ORIGIN\n         AH    R14,DCBTIOT         OFFSET TO TIOT ENTRY\n         USING TIOENTRY,R14\n         SPACE\n         ICM   R14,B'0111',TIOEJFCB JFCB JOBQ ADDRESS\n         LA    R14,JOBQHRDL(,R14)  BUMP PAST IN-CORE HEADER\n         USING JFCB,R14\n         SPACE\n         XR    R0,R0                          CLEAR REGISTER\n         ICM   R0,B'0001',JFCBNVOL            CURRENT VOLUME COUNT\n         BNZ   MXIT4400                       NON-ZERO...USE AS IS\n         LA    R0,1                           WAS ZERO...SET TO 1\nMXIT4400 DS    0H\n         CVD   R0,WORKCVD                     CONVERT TO PACKED\n         MVC   WORKCVD(L'EDITMVNO),EDITMVNO   EDIT PATTERN\n         ED    WORKCVD(L'EDITMVNO),WORKCVD+6  CONVERT TO ZONED\n         MVC   LABELVNO,WORKCVD+1             MOVE FORMATTED REEL NO\n         SPACE\n         B     MXIT4900            LEAVE LOOP\n         SPACE\nMXIT4800 DS    0H\n         ICM   R1,B'0111',DEBDEBB  NEXT DEB\n         B     MXIT4200            LOOP\n         SPACE\nMXIT4900 DS    0H\n         DROP  R1,R14,R15\n         EJECT\n***********************************************************************\n* MXIT5000:                        /*  GET ACF2 USER CONTROL BLOCK */ *\n*        LOCATE ACF2 ACVT VIA ACFINCVT;                               *\n*        LOCATE ACF2 UCB VIA ACFGUCB;                                 *\n*        MOVE LID TO TLBLABEL BLOCK FIELD;                            *\n*        MOVE SYSTEM SMF ID TO TLBLABEL BLOCK FIELD;                  *\n***********************************************************************\n         SPACE\n         ACFINCVT R2,NONE=MXIT5900\n         SPACE\n         USING ACCVT,R2\n         SPACE\n         ACFGUCB R3,INLINE=YES,SYS=AOS2,NONE=MXIT5900\n         SPACE\n         USING ACUCB,R3\n         SPACE\n         MVC   LABELLID,ACULID     MOVE LID TO TLBLABEL FIELD\n         MVC   LABELSIT,ACUSCPU    MOVE SMF ID TO TLBLABEL FIELD\n         SPACE\n         DROP  R2,R3\n         SPACE\nMXIT5900 DS    0H\n         EJECT\n***********************************************************************\n* MXIT6000:                     /* SEE IF LABEL IS TO BE PRINTED  */  *\n*        IF (DATASETNAME NOT PRESENT)     /*  NO KEEP DISP GIVEN  */  *\n*          THEN DO;                                                   *\n*                 FREEMAIN TLBLABEL;                                  *\n*                 RETURN TO CALLER;                 /*  MXIT9000  */  *\n*               END;                                                  *\n***********************************************************************\n         SPACE\nMXIT6000 DS    0H\n*======================================================================\n*        CLI   LABELDSN,C' '       DATASET NAME PRESENT? (DISP1 = KEEP)\n*        BNE   MXIT6200            YEP...ONWARD\n*        SPACE\n*        L     R0,GETLBLOK         LENGTH AND SUBPOOL\n*        FREEMAIN R,LV=(0),A=(R8)\n*        SPACE\n*        B     MXIT9000            RETURN TO CALLER\n*======================================================================\n         SPACE\nMXIT6200 DS    0H\n         EJECT\n***********************************************************************\n* MXIT7000:                                 /*  SCHEDULE TBLABEL  */  *\n*        ADD TBLABEL TO QUEUE ANCHORED IN TLBLCVT;                    *\n*        POST TLBLMAIN WORK-TO-DO ECB;                                *\n***********************************************************************\n         SPACE\nMXIT7000 DS    0H\n         LR    R5,R8               NEW TAIL OF LIST\n         SPACE\nMXIT7200 DS    0H\n         LM    R2,R3,TLBLPTRS      HEAD AND TAIL OF CHAIN\n         LTR   R4,R2               TEST HEAD OF CHAIN (HEAD REMAINS)\n         BZ    MXIT7400            ZERO => EMPTY CHAIN\n         SPACE\n         ST    R5,LABELNXT-TLBLABEL(,R3) POINT OLD TAIL TO NEW\n         B     MXIT7600            ONWARD\n         SPACE\nMXIT7400 DS    0H\n         LR    R4,R5               HEAD EQUALS TAIL - ONLY 1 BLOCK\n         SPACE\nMXIT7600 DS    0H\n         LA    R15,1               ---\n         AH    R15,LABELADD        - INCREMENT COUNTER\n         STH   R15,LABELADD        ---\n         SPACE\n         CDS   R2,R4,TLBLPTRS      UPDATE POINTERS\n         BNE   MXIT7200            RETRY IF ANCHORS HAVE CHAINED\n         SPACE\n         L     R1,=AL1(ECBPOST,0,0,0) POSTED ECB\n         XR    R15,R15             CURRENT ECB -- BE ZERO IF NOT WAIT\n         CS    R15,R1,TLBLECB      SET IN NEW ECB IF NOT WAITING\n         BE    MXIT7900            OKAY...ONWARD\n         SPACE\n         L     R14,FLCCVT          POINTER TO CVT FOR POST ERROR EXIT\n         USING CVT,R14\n         L     R2,TLBLASCB         ASCB FOR POST\n         POST  TLBLECB,ASCB=(R2),ERRET=CVTBRET,ECBKEY=0,MF=(E,WORKPOST)\n         DROP  R14\n         SPACE\nMXIT7900 DS    0H\n         EJECT\n***********************************************************************\n* MXIT9000:                                /*  RETURN TO INVOKER  */  *\n*        POINT TO HIGHER SAVE AREA;                                   *\n*        FREEMAIN WORKAREA;                                           *\n* MXIT9900:                                                           *\n*        RESTORE REGISTERS;                                           *\n*        RETURN TO CALLER VIA R14;                                    *\n***********************************************************************\n         SPACE\nMXIT9000 DS    0H\n         L     R13,4(,R13)         HIGHER SAVE AREA\n         L     R0,GETWORK          SUBPOOL AND LENGTH OF WORKAREA\n         FREEMAIN R,LV=(0),A=(R7)\n         SPACE\nMXIT9900 DS    0H\n         RETURN (14,12),RC=0\n         EJECT\n***********************************************************************\n*        CONSTANTS AND LITERALS                                       *\n***********************************************************************\n         SPACE\n         PRINT NOGEN\nSSNAME   DC    C'TLBL'             SUBSYSTEM NAME FOR SSCVT LOOKUP\n         SPACE\nTRIGGER  DC    C'IEC705I TAPE ON '\n         SPACE\nGETWORK  DC    0A(*-*),AL1(WORKSUBP),AL3(WORKLEN)\nGETLBLOK DC    0A(*-*),AL1(LABELSBP),AL3(LABELLEN)\n         SPACE\nENQL     ENQ   (*-*,*-*,E,L'TLBLRNAM,SYSTEM),RET=TEST,MF=L\n         SPACE\nJOBQHRDL EQU   X'10'               LENGTH OF IN-CORE JOBQ CB HEADER\n         SPACE\nEDITMVNO DC    X'40202021'         EDIT MASK - VOLUME SEQUENCE NUMBER\n         SPACE\nMOVETBL  DS    0D                  TABLE FOR DESTS OF MESSAGE FIELDS\n*                                  THESE ENTRIES MUST BE IN THE SAME\n*                                  ORDER AS THE FIELDS IN THE MESSAGE\n*                                  BEING DISASSEMBLED.\n         DC    A(LABELDEV-TLBLABEL,L'LABELDEV-1)\n         DC    A(LABELSER-TLBLABEL,L'LABELSER-1)\n         DC    A(LABELTYP-TLBLABEL,L'LABELTYP-1)\n         DC    A(LABELDEN-TLBLABEL,L'LABELDEN-1)\n         DC    A(LABELJOB-TLBLABEL,L'LABELJOB-1)\n         DC    A(LABELSTP-TLBLABEL,L'LABELSTP-1)\n         DC    A(LABELDSN-TLBLABEL,L'LABELDSN-1)\nMOVETBLC EQU   (*-MOVETBL)/L'MOVETBL\n         SPACE\nTRTDELIM TRT   0(*-*,R6),COMMATBL  EXECUTED - FIND COMMA\nMVCFIELD MVC   0(*-*,R2),0(R6)     EXECUTED - MOVE MESSAGE FIELD\n         SPACE\n         DS    0D\nCOMMATBL DC    XL256'00'           TRT TABLE TO LOCATE COMMA\n         ORG   COMMATBL+C','\n         DC    C','\n         ORG\n         SPACE\n         LTORG\n         EJECT\n***********************************************************************\n*        DSECTS                                                       *\n***********************************************************************\n         SPACE\n         PRINT NOGEN\n         ACFASVT DSECT=YES\n         ACCVT DSECT=YES\n         ACUCB DSECT=YES\n         CVT   DSECT=YES\n         DCBD  DSORG=PS,DEVD=DA\nTIOT     DSECT\n         IEFTIOT1\n         IEFJESCT\nJFCB     DSECT\n         IEFJFCBN\n         IEFJSCVT\nUCB      DSECT\n         IEFUCBOB\n         IEFJSSIB\n         IEZDEB\n         IEZJSCB\n         IEZVX100\n         IHAASCB\n         IHAECB\n         IHAPSA\n         IKJTCB DSECT=YES\n         EJECT\n         PRINT GEN\nWORKAREA DSECT\nWORKSUBP EQU   230\nWORKSAVE DS    18F\nWORKENQ  ENQ   (*-*,*-*,,*-*,),MF=L\nWORKENQL EQU   *-WORKENQ\nWORKPOST POST  *-*,ASCB=*-*,ERRET=*-*,ECBKEY=YES,MF=L\nWORKCVD  DS    D                   CVD RESULT WORKAREA\nWORKLEN  EQU   *-WORKAREA\n         SPACE\n         REGS\n         SPACE\n         TLBLCVT\n         SPACE 2\n         TLBLABEL\n         SPACE 3\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WAIT": {"ttr": 11526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\x97\\x00\\x97\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 151, "newlines": 151, "modlines": 0, "user": "FILE369"}, "text": "PRC      TITLE 'WAIT - WAIT A LITTLE BIT.'\n********************************************************************\n*                                                                  *\n* NAME - WAIT.                                                     *\n*                                                                  *\n* DESCRIPTION -                                                    *\n*                                                                  *\n*   THIS MODULE WILL WAIT THE REQUESTED NUMBER OF SECONDS.         *\n*                                                                  *\n* TO USE -                                                         *\n*                                                                  *\n*   PARM='NNNN', WHERE 0 < NNNN <= 9999, THE NUMBER OF SECONDS TO  *\n*     WAIT. DEFAULT IS 10 SECONDS.                                 *\n*                                                                  *\n* RETURN CODES -                                                   *\n*                                                                  *\n*   R15 = 20, BAD PARM FIELD.                                      *\n*                                                                  *\n* LOG -                                                            *\n*   05/30/86 L01 PTW IMPLEMENTED                                   *L01\n*   09/27/88 L02 PTW IMPLEMENTED                                   *L02\n*                                                                  *\n********************************************************************\n         LCLC  &CSECT\n&CSECT   SETC  'WAIT'\n&CSECT   CSECT\n********************************************************************\n*                                                                  *\n*        I N I T I A L I Z E                                       *\n*                                                                  *\n********************************************************************\n         PRINT NOGEN\n         SAVE  (14,12),,&CSECT-&SYSDATE-&SYSTIME\n         LR    R12,R15            ESTABLISH BASE.\n         USING &CSECT,R12\n         GETMAIN RU,LV=DYNLEN\n         LR    R2,R13\n         LR    R13,R1\n         USING DYNAMIC,R13\n         LR    R0,R1\n         LA    R14,DYNLEN\n         LA    R1,R1\n         SLR   R15,R15\n         MVCL  R0,R14             ZERO STORAGE.\n         ST    R2,4(,R13)         BACK CHAIN.\n         ST    R13,8(,R2)         FORWARD CHAIN.\n         XC    RC,RC\n********************************************************************\n*                                                                  *\n*        P A R M   P R O C E S S I N G                             *\n*                                                                  *\n********************************************************************\n         MVC   SECONDS,=F'10'     DEFAULT.\n         L     R2,4(,R13)         A(PREVIOUS SAVEAREA).\n         L     R2,24(,R2)         A(A(PARM)).\n         LTR   R2,R2              CHECK FOR NULL PARM.\n         BZ    DOTIME\n         L     R2,0(,R2)          A(PARM).\n         LH    R3,0(,R2)          L'PARM.\n         LTR   R3,R3              IF ZEROS +\n         BZ    DOTIME               THEN EXIT.\n         CH    R3,=H'4'           IF LENGTH NGT '4' +\n         BH    BADTIME            FORGET NEXT.\n         LA    R4,2(,R2)\nVERNUM   DS    0H\n         CLI   0(R4),C'0'         SCAN\n         BL    BADTIME             FORWARD\n         CLI   0(R4),C'9'         SCAN\n         BH    BADTIME             FORWARD\n         LA    R4,1(,R4)            TO FIRST\n         BCT   R3,VERNUM\n         LH    R3,0(,R2)\n         BCTR  R3,0               MACHINE LENGTH.\n         EX    R3,PACKSEC         PACK SECONDS.\n         CVB   R3,DOUBLE          CONVERT TO BINARY.\n         CH    R3,=H'1'           TEST SECONDS\n         BL    BADTIME             FOR LIMITS.\n         CH    R3,=H'9999'\n         BH    BADTIME\n         ST    R3,SECONDS          AND STORE.\nPACKSEC  PACK  DOUBLE,2(*-*,R2)\n********************************************************************\n*                                                                  *\n*        W A I T                                                   *\n*                                                                  *\n********************************************************************\nDOTIME   DS    0H\n         L     R2,SECONDS\n         MH    R2,=H'100'\n         ST    R2,SECONDS\n         STIMER WAIT,BINTVL=SECONDS\n         XC    RC,RC\n********************************************************************\n*                                                                  *\n*        R E T U R N                                               *\n*                                                                  *\n********************************************************************\nRETURN   DS    0H\n         L     R2,RC                  R2 = RC.\n         LR    R1,R13              PREPARE\n         L     R13,4(,R13)         FOR FREEMAIN.\n         FREEMAIN RU,LV=DYNLEN,A=(1)\n         LR    R15,R2              AND RETURN\n         RETURN (14,12),RC=(15)      WITH R15 = RC.\n********************************************************************\n*                                                                  *\n*        E R R O R S                                               *\n*                                                                  *\n********************************************************************\nBADTIME  DS    0H\n         WTO   'WAIT: BAD PARM - SPECIFY NNNN (1-9999 SECONDS).',      X\n               ROUTCDE=11,MCSFLAG=HRDCPY\n         MVC   RC,=F'20'\n         B     RETURN\n********************************************************************\n*                                                                  *\n*        S T A T I C   A R E A                                     *\n*                                                                  *\n********************************************************************\nSRCLEVEL DC    C'                                        '\n         LTORG *\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   A R E A                                   *\n*                                                                  *\n********************************************************************\nDYNAMIC  DSECT\nSAVE     DS    18F .\nDOUBLE   DS    D\nRC       DS    F\nSECONDS  DS    F\nDYNLEN   EQU   *-DYNAMIC\n         PRINT OFF\nR0       EQU   00\nR1       EQU   01\nR2       EQU   02\nR3       EQU   03\nR4       EQU   04\nR5       EQU   05\nR6       EQU   06\nR7       EQU   07\nR8       EQU   08\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12                 PROGRAM BASE.\nR13      EQU   13                 A(SAVE AREA).\nR14      EQU   14\nR15      EQU   15\n         PRINT ON\n         END   &CSECT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WTO": {"ttr": 11530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\xb4\\x00\\xb4\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 180, "newlines": 180, "modlines": 0, "user": "FILE369"}, "text": "         TITLE 'WTO    - OPERATIONS COMMUNICATION'\n*/* LIB: IPO1.SAMPLIB(WTO)\n*/* GDE: CBIPO MVS CUSTOMIZATION\n*/* DOC: THIS PROGRAM PROVIDES PROGRAMMER TO OPERATOR COMMUNICATION.\n***********************************************************************\n*                                                                     *\n*             MODULE NAME = WTO                                       *\n*                                                                     *\n*             DESCRIPTIVE NAME =  CBIPO-SUPPLIED PROGRAM FOR          *\n*                            PROGRAMMER TO COMMUNICATE WITH OPERATOR  *\n*                                                                     *\n*             FUNCTION =                                              *\n*                SERVICE THE COMMUNICATIONS NEEDS OF A PROGRAM TO THE *\n*                CONSOLE OPERATOR BY READING SYSIN AND ISSUING WTO'S  *\n*                TO DISPLAY THESE MESSAGES TO THE OPERATOR.  THE      *\n*                PROGRAM THEN ISSUES A WTOR:                          *\n*               'ENTER C TO CONINUE PROCESSING OR R TO REPEAT DISPLAY'*\n*\n*             OPERATION =                                             *\n*        WTO     READS CARD IMAGES FROM SYSIN AND THEN                *\n*        (1) DISPLAYS THEM TO THE OPERATOR USING WTO MACRO            *\n*        (2) WRITES THEM TO SYSPRINT USING PUT MACRO                  *\n*        (3) ISSUES A WTOR MACRO TO LET THE OPERATOR CONTINUE         *\n*            PROCESSING (REPLY C) OR TO REPEAT DISPLAY (REPLY R)      *\n*        NOTE THAT IF A PARM IS PASSED, IT IS USED AS FIRST MESSAGE   *\n*                                                                     *\n*              NOTES =                                                *\n*                                                                     *\n*                 DEPENDENCIES = CHARACTER IS EBCDIC.  REASSEMBLE     *\n*                    IF A DIFFERENT CHARACTER SET IS NEEDED.          *\n*                                                                     *\n*                 RESTRICTIONS = MAY SUPPLY BLKSIZE ON    CJP - 7AUG86*\n*                    SYSPRINT DD CARD, E.G.               CJP - 7AUG86*\n*                    DCB=(BLKSIZE=12800)                  CJP - 7AUG86*\n*                    SYSIN RECFM MUST BE F OR FB          CJP - 7AUG86*\n*                                                                     *\n*                PATCH LABEL = N/A                                    *\n*                                                                     *\n*             MODULE TYPE = PROCEDURE                                 *\n*                                                                     *\n*                PROCESSOR = ASM                                      *\n*                                                                     *\n*                MODULE SIZE = 1K                                     *\n*                                                                     *\n*                ATTRIBUTES = PROTECT KEY 8, NONREUSABLE              *\n*                                                                     *\n*             ENTRY POINTS = WTO      (ONLY ENTRY POINT)              *\n*                                                                     *\n*                LINKAGE =  // EXEC PGM=WTO                           *\n*                                                                     *\n*             INPUT = REGISTER 1 POINTS TO PARM FIELD ON EXEC CARD    *\n*                                                                     *\n*             OUTPUT = WTO OF PARM FIELD IF AVAILABLE                 *\n*                      WTO OF SYSIN CARD IMAGES                       *\n*                      WTOR TO OPERATOR ASKING FOR PERMISSION TO      *\n*                           CONTINUE PROCESSING OR REDISPLAY MSG.     *\n*                                                                     *\n*             EXIT - NORMAL = AT PROGRAM END VIA BRANCH REGISTER 14   *\n*                                                                     *\n*                OUTPUT = NONE                                        *\n*                                                                     *\n*                RETURN CODE = ZERO                                   *\n*                                                                     *\n*             EXIT - ERROR = NONE                                     *\n*                                                                     *\n*             EXTERNAL REFERENCES =  NONE                             *\n*                                                                     *\n*                ROUTINES = NONE                                      *\n*                                                                     *\n*                DATA AREAS = NONE                                    *\n*                                                                     *\n*                CONTROL BLOCKS = NONE                                *\n*                                                                     *\n*             TABLES = NONE                                           *\n*                                                                     *\n*             MACROS = WTO,WTOR                                       *\n*                                                                     *\n*             CHANGE ACTIVITY                                         *\n*                7AUG86  CJ PITTS   CHANGED ML EQUATE TO 128          *\n*                                   INCREASED SIZE OF IPOWTOL         *\n*                                   INCREASED SIZE OF IPOPAD          *\n*                                   ADDED SOME PRINT NOGEN/GEN        *\n*                                   ADDED SYSPRINT LRECL & RECFM      *\n*                                   ADDED SYSIN RECFM                 *\n*                                                                     *\n*             MESSAGES = NO ERROR MESSAGES ISSUED                     *\n*                                                                     *\n*             ABEND CODES = 013 IF DCB ATTRIBUTES NOT SUPPLIED ON     *\n*                           SYSPRINT DD CARD  >>RELAXED - CJP - 7AUG86*\n*                                                                     *\n***********************************************************************\n*        REGISTER USAGE FOLLOWS...                                    *\nR0       EQU   0                   WORK REG                           *\nR1       EQU   1                   PTR TO INPUT PARM                  *\nR2       EQU   2                   WORK REG                           *\nR11      EQU   11                  PTR TO FIRST MESSAGE IF NOZERO PARM*\nR12      EQU   12                  BASE REG                           *\nR13      EQU   13                  PTR TO IPOSAVE                     *\nR14      EQU   14                  LINKAGE REG                        *\nR15      EQU   15                  LINKAGE REG                        *\nML       EQU   128                 MSG LENGTH             CJP - 7AUG86*\n***********************************************************************\nWTO      CSECT                     BEGINING OF PROGRAM\n         USING *,R12               SET UP BASE REG\n         SAVE  (14,12),,IPO.WTO..&SYSDATE..&SYSTIME        CJP - 7AUG86\n         LR    R12,R15             SET UP ADDRESSABILITY\n         LR    R2,R13              SAVE ADDR OF PREVIOUS SAVEAREA\n         LA    R13,IPOSAVE         POINT TO CURRENT SAVEAREA\n         ST    R13,8(R2)           LINK PREVIOUS SAVEAREA TO IPOSAVE\n         ST    R2,4(R13)           LINK IPOSAVE TO PREVIOUS SAVEAREA\n         LR    R11,R1              PTR PARM ADDR - FIRST COMMAND\n         L     R11,0(R11)          SAVE ADDR OF PARM IN R11\nIPOPARM  LH    R2,0(R11)           LENGTH TO R2\n         C     R2,=F'0'            PARM LENGTH = 0?\n         BE    IPOGETIN            YES - GET RECORD FROM SYSIN\n         C     R2,=A(ML)           COMPARE LENGTH OF TO MAX LENGTH\n         BNH   IPOMOVE             LENGTH OF PARM OKAY\n         LA    R2,ML               RESET PARM LENGTH TO MAX\nIPOMOVE  MVC   IPOMSG,=CL(ML)' '   CLEAR OUT MSG AREA\n         BCTR  R2,0                LENGTH-1 FOR MVC\n         EX    R2,IPOMVC           MOVE PARM INTO MSGAREA\n         B     IPOGOTIN            PROCESS FIRST MSG\nIPOGETIN TM    INPUT+48,X'10'      INPUT FILE OPEN?\n         BO    IPOGET              BR IF SO\n         OPEN  (INPUT)             OPEN IT\n         TM    INPUT+48,X'10'      DID IT OPEN\n         BZ    IPOEND              NO - NO VERICATION (NO WTOR)\nIPOGET   GET   INPUT               READ RECORD FROM SYSIN\n         LH    R14,INPUT+82        DCBLRECL                CJP - 7AUG86\n         C     R14,=A(ML)          COMPARE TO MAX LENGTH   CJP - 7AUG86\n         BNH   IPOGLEN             GO IF NO LARGER         CJP - 7AUG86\n         L     R14,=A(ML)          SET TO MAX              CJP - 7AUG86\nIPOGLEN  DS    0H                                          CJP - 7AUG86\n         BCTR  R14,0               DECREMENT FOR EXECUTE   CJP - 7AUG86\n         MVI   IPOMSG,C' '         BLANK OUT MSG BUFFER    CJP - 7AUG86\n         MVC   IPOMSG(L'IPOMSG-1),IPOMSG                   CJP - 7AUG86\n         EX    R14,IPOMVC2         MOVE MESSAGE            CJP - 7AUG86\nIPOGOTIN CLC   IPOMSG,=CL(ML)' '   TEST FOR BLANK MESSAGE\n         BE    IPOGETIN            SKIP BLANK RECORD\n         MVC   IPOWTOL+4(ML),IPOMSG PLUG WTO MSG\n         WTO   MF=(E,IPOWTOL)      DISPLAY MSG\n         TM    OUTPUT+48,X'10'     OUTPUT FILE OPEN?\n         BO    IPOOUT              BR IF SO\n         OPEN  (OUTPUT,(OUTPUT))   OPEN IT\n         TM    OUTPUT+48,X'10'     DID OUTPUT OPEN\n         BZ    IPOOUTNO            NO - SKIP OUTPUT\nIPOOUT   PUT   OUTPUT,IPOMSG       SAME MSG TO OUTPUT FILE\nIPOOUTNO B     IPOGETIN            READ NEXT RECORD\nIPOEOD   MVI   IPORPECB,0          CLEAR OUT ECB FOR REPLY\n         WTOR  'REPLY C TO CONTINUE PROCESSING OR R TO REPEAT DISPLAY',X\n               IPOREPLY,1,IPORPECB,ROUTCDE=(1,5,11)\n         WAIT  1,ECB=IPORPECB      WAIT FOR OPERATOR TO REPLY\n         CLI   IPOREPLY,C'C'       IS IT CONTINUE?\n         BE    IPOEND              YES - CONTINUE PROCESSING\n         CLI   IPOREPLY,C'R'       IS IT REPEAT MESSAGE?\n         BNE   IPOEOD              NO - ASK OPERATOR AGAIN\n         CLOSE (INPUT)             YES - REPEAT MSG - CLOSE INPUT\n         B     IPOPARM             GO TO FIRST MSG\nIPOEND   L     R13,IPOSAVE+4       RESTORE R13\n         RETURN (14,12),T,RC=0     RETURN TO MVS\n         PRINT NOGEN                                       CJP - 7AUG86\nOUTPUT   DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=(PM),        CJP - 7AUG86X\n               LRECL=ML,RECFM=FB                           CJP - 7AUG86\nINPUT    DCB   DDNAME=SYSIN,DSORG=PS,MACRF=(GL),           CJP - 7AUG86X\n               EODAD=IPOEOD,RECFM=FB                       CJP - 7AUG86\nIPOMVC   MVC   IPOMSG(0),2(R11)    EXEC INSTRUCTION TO MOVE PARM\nIPOMVC2  MVC   IPOMSG(*-*),0(R1)   EXECUTED - MOVE FROM SYSIN  - 7AUG86\nIPOSAVE  DS    18F                 IPOSAVE AREA\nIPORPECB DC    F'0'                ECB FOR WTOR\nIPOAREA  DC    0F'0',AL2(ML+4,0)   LENGTH FOR OUTPUT IF RECFM=VB\nIPOMSG   DC    CL(ML)' '           STORAGE FOR ONE MSG\nIPOREPLY DS    CL1                 REPLY FOR WTO\n         PRINT GEN                                         CJP - 7AUG86\n*              MESSAGE OF IPOWTOL MUST BE SAME LEN AS ML   CJP - 7AUG86\nIPOWTOL  WTO   '1234567891123456789212345678931234567894123456789512345X\n               67896123456789712345678981234567899123456789012345678911X\n               23456789212345678',                         CJP - 7AUG86X\n               ROUTCDE=(1,5,11),DESC=(7),MF=L              CJP - 7AUG86\n         LTORG                   , LTORG NEEDED FOR ADDRESSABILITY\n         END                     , END OF PROGRAM\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WTONR": {"ttr": 11777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x1f\\x00\\x90\\x00\\x1f\\x12\\x00\\x00\\x88\\x00\\x88\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf6\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-01T00:00:00", "modifydate": "1990-01-01T12:00:00", "lines": 136, "newlines": 136, "modlines": 0, "user": "FILE369"}, "text": "PRC      TITLE 'WTONR - WRITE NON-ROLLABLE OPERATOR MESSAGES.'\n********************************************************************\n*                                                                  *\n* NAME - WTONR - WRITE NON-ROLLABLE MSGS TO OPERATOR CONSOLE.      *\n*                                                                  *\n* DESCRIPTION - WE READ SYSIN INPUT AND WTO CARD IMAGES TO THE     *\n*   OPERATOR CONSOLE THAT ARE NON-ROLLABLE.  ORGINALLY USED BY     *\n*   THE MESSENGER JOBS FOR AN OPERATOR RESTART.                    *\n*                                                                  *\n* NOTE - WE MUST BE APF-AUTHORIZED TO WRITE NON-ROLLABLE MESSAGES  *\n*                                                                  *\n* TO USE -                                                         *\n*  //S1 EXEC PGM=WTONR                                             *\n*  //STEPLIB DD DSN=AN.APF.LIBRARY,DISP=SHR                        *\n*  //SYSIN   DD *                                                  *\n*  * THIS IS A COMMENT                                             *\n*  ---> UP TO THREE LINES OF TEXT <---                             *\n*  ---> AFTER THREE LINES IGNORED <---                             *\n*  ---> COLS 1-72 ARE PROCESSED   <---                             *\n*  /*                                                              *\n*                                                                  *\n* LOG -                                                            *\n*     DATE   WHO LV    CHANGE                                      *\n*   06/16/86 PTW L01 IMPLEMENTATION                                *\n*                                                                  *\n********************************************************************\n         LCLC  &CSECT\n&CSECT   SETC  'WTONR'\n&CSECT   CSECT ,\n********************************************************************\n*                                                                  *\n*        I N I T I A L I Z E                                       *\n*                                                                  *\n********************************************************************\n         PRINT NOGEN\n         SAVE  (14,12),,&CSECT-&SYSDATE-&SYSTIME\n         LR    R12,R15            ESTABLISH BASE.\n         USING &CSECT,R12         TELL ASSEMBLER.\n         GETMAIN RU,LV=DYNLEN     GET DYNAMIC AREA.\n         LR    R2,R13             SAVE AREA\n         LR    R13,R1             SAVE AREA\n         USING DYNAMIC,R13        TELL ASSEMBLER.\n         LA    R0,DYNAMIC         ZERO\n         LA    R1,DYNLEN            DYNAMIC\n         LR    R14,R0                 STORAGE.\n         SLR   R15,R15\n         MVCL  R0,R14             DO IT.\n         ST    R2,4(,R13)         BACK CHAIN.\n         ST    R13,8(,R2)         FORWARD CHAIN.\n         XC    RC,RC              ASSUME GOOD RC.\n         MVC   INDCB(INDCBLEN),XINDCB INITIALIZE LISTS.\n         MVC   WTO(WTOLEN),XWTO\n         MVC   OPEN(OPENLEN),XOPEN\n********************************************************************\n*                                                                  *\n*        W T O   M E S S A G E S   F R O M   S Y S I N             *\n*                                                                  *\n********************************************************************\n         OPEN  (INDCB),MF=(E,OPEN)\n         TM    DCBOFLGS-IHADCB+INDCB,DCBOFOPN\n         BNO   BADOPEN            CHECK RESULT OF OPEN.\n         LA    R2,3               LIMIT OF 3 WTOS/EXECUTION.\nGET      GET   INDCB,INREC\n         CLI   INREC,C'*'         DON'T PROCESS COMMENTS.\n         BE    GET\n         MVC   WTOMSG,INREC       MOVE TEXT FOR WTO.\n         WTO   MF=(E,WTO)         WTO.\n         BCT   R2,GET\n         B     RETURN\n********************************************************************\n*                                                                  *\n*        E R R O R S                                               *\n*                                                                  *\n********************************************************************\nBADOPEN  DS    0H\n         MVC   RC,=F'12'          SET BAD RETURN CODE.\n         B     RETURN\n********************************************************************\n*                                                                  *\n*        R E T U R N                                               *\n*                                                                  *\n********************************************************************\nRETURN   DS    0H\n         L     R2,RC                  R2 = RC.\n         LR    R1,R13              PREPARE\n         L     R13,4(,R13)         FOR FREEMAIN.\n         FREEMAIN RU,LV=DYNLEN,A=(1)\n         LR    R15,R2              AND RETURN\n         RETURN (14,12),RC=(15)      WITH R15 = RC.\n********************************************************************\n*                                                                  *\n*        S T A T I C   A R E A                                     *\n*                                                                  *\n********************************************************************\nXINDCB   DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GM,EODAD=RETURN\nINDCBLEN EQU   *-XINDCB\nXOPEN    OPEN  0,MF=L\nOPENLEN  EQU   *-XOPEN\nXWTO     WTO   '                                                       X\n                                ',ROUTCDE=1,DESC=2,MF=L\nWTOLEN   EQU   *-XWTO\n         LTORG *\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   A R E A S                                 *\n*                                                                  *\n********************************************************************\nDYNAMIC  DSECT\nSAVE     DS    18F .\nRC       DS    F\nOPEN     DS    F\nINDCB    DS    0F,CL(INDCBLEN)\nWTO      DS    0F,CL(WTOLEN)\nWTOMSG   EQU   WTO+4,72,C'C'\nINREC    DS    CL80\nDYNLEN   EQU   *-DYNAMIC          LENGTH OF WORKAREA.\n         PRINT OFF\nR0       EQU   00\nR1       EQU   01\nR2       EQU   02\nR3       EQU   03\nR4       EQU   04\nR5       EQU   05\nR6       EQU   06\nR7       EQU   07\nR8       EQU   08\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11                 A(PLIST).\nR12      EQU   12                 PROGRAM BASE.\nR13      EQU   13                 A(SAVE AREA).\nR14      EQU   14\nR15      EQU   15\n         PRINT ON,NOGEN\n         DCBD  DSORG=PS,DEVD=DA\n         END   &CSECT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT369/FILE369.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT369", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}