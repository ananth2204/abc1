{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012141000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE482.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE482.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x03\\x0c'", "DS1TRBAL": "b'\\x03\\xda'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03\\x82\\x00\\x08\\x03\\x82\\x00\\x0b\\x00\\x04'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04O\\x00U\\x01\\x10\\x11\\x9f\\x01\\x10\\x11\\x9f\\x14\"\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf9@@@'", "ispf": {"version": "04.79", "flags": 0, "createdate": "2010-04-29T00:00:00", "modifydate": "2010-04-29T14:22:55", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-479"}, "text": "REGULAR CBT TAPE - VERSION 479    FILE:  482\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT479.FILE482\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 8 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,074 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   04/29/10    14:22:55    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE1": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x10\\x11\\x9f\\x01\\x10\\x11\\x9f\\x14\\x14\\x00!\\x00!\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-04-29T00:00:00", "modifydate": "2010-04-29T14:14:37", "lines": 33, "newlines": 33, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Update to GDGCOPY on file 482\nFrom:     \"Fisher, John\" <FISHERJ@ccf.org>\nDate:     Wed, 28 Apr 2010 12:36:28 -0400\nTo:       <sbgolob@cbttape.org>\n\nNote from Sam Golob:\n   John modified this code from what Eric Bielefeld submitted\n   to the CBT Tape, and which was in File 482.  Problem was that\n   if you had more than 100 GDGs, the program would go into a\n   loop.  Now (with this modification) it won't go into a loop\n   until you have 1000 GDGs in the concatenation, so that should\n   give you enough room.  John's comments deal with what he could\n   deduce, concerning the history and origins of this code.\n\nSam,\n\n  Attached is my source code with revisions.  I used the existing\nmacros.  The earliest version I had of this code was one I had\nbrought along from previous lives several times.  It had November,\n1977 at the top of the comments and had some revisions coded by\nHMD (Howard M. Dean) in 08/81.  It did not support unlabeled tapes\nand had all the macro code inline.  I also found here a source\ndeck that was closer to the CBT version which was last changed in\n1985.  The thing I liked least about it was it required running\nauthorized which I could find no good reason for.  My address\ninfo:\n\nJohn M. Fisher\nCleveland Clinic\n17325 Euclid Ave. - CL3-321\nCleveland, OH 44112\n(216)738-5324\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$EPILOG": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86\\x08\\x1f\\x00\\x86\\x08\\x7f\\x19\\x11\\x00&\\x00&\\x00\\x01\\xe3\\xd4\\xc4\\xe2\\xf0\\xf0\\xf0@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-03-22T00:00:00", "modifydate": "1986-03-28T19:11:00", "lines": 38, "newlines": 38, "modlines": 1, "user": "TMDS000"}, "text": "         MACRO\n&LABEL   $EPILOG &RETCODE,&LIST=NO\n.**********************************************************************\n.*                                                                    *\n.*                                  CHANEY SYSTEMS SUPPORT, INC.      *\n.*                                                                    *\n.*       THIS MACRO PROVIDES STANDARD DE-LINKAGE CONVENTIONS FOR      *\n.*       MOST CSS TOOL KIT MEMBERS.                                   *\n.*                                                                    *\n.**********************************************************************\n         GBLA  &EPILOG\n         GBLB  &LSAVE\n         AIF   ('&LIST' EQ 'YES').LIST1\n         PUSH  PRINT\n         PRINT OFF\n.LIST1   ANOP\n&LABEL   DS    0H\n         AIF   (&LSAVE).GO3\n         AIF   (&EPILOG EQ 0).GO1\n         LA    R0,&EPILOG          GET SAVEAREA LENGTH\n         AGO   .GO2\n.GO1     LA    R0,WORKEND-SAVEAREA GET SAVEAREA LENGTH\n.GO2     LR    R1,R13              GET SAVEAREA ADDRESS FOR FREEMAIN\n.GO3     ANOP\n         L     R13,4(R13)          GET BACK CHAIN POINTER\n         ST    R15,16(R13)         SAVE REGISTER 15 (RETCODE)\n         AIF   (&LSAVE).GO4\n         FREEMAIN RU,LV=(0),A=(1)  FREE SAVEAREA\n.GO4     ANOP\n         LM    R14,R12,12(R13)     RESTORE CALLERS REGS\n         AIF   (T'&RETCODE EQ 'O').GO5\n         LA    R15,&RETCODE        SET RETURN CODE\n.GO5     ANOP\n         BR    R14                 RETURN TO CALLER\n         AIF   ('&LIST' EQ 'YES').MEXIT\n         POP   PRINT\n.MEXIT   ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$PROLOG": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x08\\x7f\\x00\\x86\\x08\\x7f \\x08\\x00\\xc2\\x00\\xc1\\x00\\x11\\xe3\\xd4\\xc4\\xe2\\xf0\\xf0\\xf0@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-03-28T00:00:00", "modifydate": "1986-03-28T20:08:00", "lines": 194, "newlines": 193, "modlines": 17, "user": "TMDS000"}, "text": "         MACRO\n&LABEL   $PROLOG &LV=,&RENT=NO,&ERRCODE=,&C=,&SP=,&GM=,&LIST=NO\n.**********************************************************************\n.*                                                                    *\n.*                                  CHANEY SYSTEMS SUPPORT, INC.      *\n.*                                                                    *\n.*       THIS MACRO PROVIDES STANDARD LINKAGE AND BASE REGISTER       *\n.*       SPECIFICATIONS FOR MOST MEMBERS OF THE CSS TOOL KIT.         *\n.*                                                                    *\n.*       THE FIRST OPERERAND IS A POSITIONAL LIST OF REGISTERS        *\n.*       TO BE USED AS BASE(S) FOR THE CSECT BEING DEFINED AND        *\n.*       THE LABEL BECOMES THE CSECT NAME.                            *\n.*                                                                    *\n.*       LV=NNN    SPECIFIES AN ADDITIONAL AMOUNT OF STORAGE TO BE    *\n.*                 GOTTEN FOLLOWING THE DYNAMIC SAVE AREA.  THIS      *\n.*                 ADDITIONAL STORAGE IS ADDRESSED VIA REG 13         *\n.*                 (JUST FOLLOWING THE 18 FULLWORD SAVEAREA) AND      *\n.*                 IS LIMITED TO 4023.                                *\n.*                                                                    *\n.*       RENT=YES  IF USED, SPECIFIES THAT THE LENGTH OF ADDITIONAL   *\n.*                 STORAGE IS DETERMINED BASED UPON THE SIZE OF       *\n.*                 THE DYNAMIC STORAGE DEFINED BETWEEN TWO            *\n.*                 LABELS:  \"SAVEAREA\" AND \"WORKEND\".  THE WORK       *\n.*                 AREA IS ADDRESSABLE VIA REG 13 THE SAME AS THE     *\n.*                 LV= OPERAND.  THE USER DEFINED CONSTANTS THAT      *\n.*                 EXIST IN THE SOURCE ARE COPIED TO THE NEWLY        *\n.*                 AQUIRED STORAGE AND ARE DIRECTLY ADDRESSABLE.      *\n.*                 CAUTION: THE DYNAMIC AREA MUST BE DEFINED          *\n.*                          \"IMMEDIATELY PRIOR TO ANY DSECTS\" AND     *\n.*                          YOU MUST SPECIFY \"LTORG\" PRIOR TO THE     *\n.*                          DEFINITION OF \"SAVEAREA\".                 *\n.*                                                                    *\n.*                 NOTE: LV= AND RENT=YES ARE MUTUALLY EXCLUSIVE.     *\n.*                                                                    *\n.*       ERRCODE=  SPECIFIES THE RETURN CODE TO BE RETURNED TO        *\n.*                 THE CALLER IN THE EVENT THAT THE CONDITIONAL       *\n.*                 GETMAIN FAILS.  IF SPECIFIED, THE GETMAIN THAT     *\n.*                 IS ISSUED WILL BE CONDITIONAL AND IF IT DOES       *\n.*                 NOT COMPLETE NORMALLY, THIS ERROR CODE WILL        *\n.*                 BE RETURNED TO THE CALLER.  IF ERRCODE IS NOT      *\n.*                 SPECIFIED, THE GETMAIN THAT IS ISSUED WILL BE      *\n.*                 UNCONDITIONAL WITH A RELATED 80A ABEND IN THE      *\n.*                 EVENT OF FAILURE.                                  *\n.*                                                                    *\n.*       SP=       IS USED TO CAUSE AN MVS SPLEVEL MACRO TO BE        *\n.*                 EXECUTED AS PART OF THE ASSEMBLY.  POSSIBLE        *\n.*                 OPTIONS ARE \"1\" (370) OR \"2\" (XA).  IF NOT         *\n.*                 SPECIFIED, THE SPLEVEL MACRO IS NOT USED.          *\n.*                                                                    *\n.*       C=        IS A MEANS OF PROVIDING ADDITIONAL DATA IN THE     *\n.*                 EYECATCHER.  IF USED, THE DATA SPECIFIED MUST      *\n.*                 BE ENCLOSED WITHIN QUOTES AND IS LIMITED TO        *\n.*                 46 CHARACTERS.                                     *\n.*                                                                    *\n.*       GM=NO     IS NOT SUPPORTED BY THIS MACRO BUT IS ALLOWED      *\n.*                 FOR COMPATIBILITY OF OLDER VERSIONS.               *\n.*                                                                    *\n.*       LIST=NO   SUPPRESSES GENERATION OF LISTINGS FOR $PROLOG,     *\n.*                 $EPILOG AND $REGS WHEN EXPANSION IS ACTIVE         *\n.*                 (PRINT GEN).                                       *\n.*                                                                    *\n.*       EXAMPLES:                                                    *\n.*                                                                    *\n.*       SECTNAME $PROLOG ,        R12 IS BASE BY DEFAULT             *\n.*       SECTNAME $PROLOG R12,R11  R12 IS 1ST BASE AND R11 IS SECOND  *\n.*       SECTNAME $PROLOG R2,LV=8  R2 IS BASE AND AN ADDITIONAL       *\n.*                                 8 BYTES ARE ADDED TO THE STORAGE   *\n.*                                 GOTTEN FOR THE SAVEAREA.           *\n.*                                                                    *\n.*       SECTNAME $PROLOG RENT=YES R12 IS BASE AND THE ADDITIONAL     *\n.*                                 STORAGE TO BE GOTTEN IS DEFINED    *\n.*                                 BETWEEN \"SAVEAREA\" AND \"WORKEND\".  *\n.*       SAVEAREA DS    9D         (SAVE AREA FOR $PROLOG GENERATION) *\n.*       MYFIELD1 DC    CL8'DATA1' (PROGRAM CONSTANTS)                *\n.*       MYFIELD2 DC    CL8'DATA2' (PROGRAM CONSTANTS)                *\n.*       WORKEND  EQU   *          (END OF DYNAMIC WORK AREA)         *\n.*                                                                    *\n.**********************************************************************\n         GBLA  &EPILOG             DEFINE GLOBAL FOR $EPILOG\n         GBLB  &REGS,&LSAVE        DEFINE GLOBALS FOR $REGS/$EPILOG\n         LCLA  &AA,&AB,&BUMP,&X    DEFINE LOCAL VARIABLES\n         LCLC  &GMT,&BASE,&LISTOPT DEFINE LOCAL VARIABLES\n&X       SETA  &SYSNDX             SET LABEL CONSTANT\n&EPILOG  SETA  0                   RESET LV= GLOBAL\n&BUMP    SETA  4096                SET FOR BASE REG BUMP\n&LSAVE   SETB  0                   RESET RENT GLOBAL FOR $EPILOG\n&GMT     SETC  'RU'                SET UNCONDITIONAL GETMAIN\n         AIF   ('&LIST' EQ 'YES').LIST1\n         PUSH PRINT\n         PRINT OFF\n.LIST1   ANOP\n&LABEL   CSECT\n         AIF   (T'&SP EQ 'O').GO1  IF NO SPLEVEL REQUIRED\n         SPLEVEL SET=&SP           ISSUE USER REQUESTED SPLEVEL MACRO\n.GO1     ANOP\n         USING *,R15               TEMPORARY BASE\n         B     $&X.A               BRANCH AROUND CONSTANTS\n         DC    CL8'&LABEL'         PROVIDE EYECATCHER\n         AIF   (T'&C EQ 'O').GO2   COMMENTS ADDITION?\n         DC    CL46&C\n.GO2     ANOP\n         DC    C'&SYSDATE @ &SYSTIME' DATE/TIME STAMP OBJECT\n         AIF   (T'&LV   EQ 'O').GO3 IF LV= NOT SPECIFIED\n         AIF   ('&RENT' NE 'YES').GO3 RENT NOT ALSO SPECIFIED\n         MNOTE 12,'$PROLOG - RENT=YES AND LV=&LV MUTUALLY EXCLUSIVE'\n         MEXIT\n.GO3     AIF   ('&RENT' EQ 'YES').GO4   RENT=YES SPECIFIED\n         AIF   (T'&LV   NE 'O').GO4   LV= SPECIFIED\n&LSAVE   SETB  1                   SET NORENT GLOBAL FOR $EPILOG\n$AVE&X   DC    18F'0'              DEFINED SAVE AREA\n.GO4     ANOP\n         AIF   (T'&LABEL NE 'O').GO5 INSURE CSECT NAME PROVIDED\n         MNOTE 8,'$PROLOG - CSECT NAME NOT SUPPLIED'\n.GO5     ANOP\n$&X.A    STM   R14,R12,12(R13)     SAVE CALLERS REGISTERS\n&BASE    SETC  'R12'               ASSUME A BASE REGISTER\n         AIF   (N'&SYSLIST EQ 0).GO6 USE DEFAULT IF NOT SPECIFIED\n&BASE    SETC  '&SYSLIST(1)'       SET THE SPECIFIED BASE REGISTER\n.GO6     ANOP\n         LR    &BASE,R15           SET FIRST BASE REGISTER\n         DROP  R15                 FREE THE TEMPORARY BASE\n         USING &LABEL,&BASE        INFORM ASSEMBLER\n         AIF   (N'&SYSLIST EQ 0).GO7\n&AA      SETA  2                   NUMBER TO DEFINE +1\n.LOOP    ANOP\n         AIF   (&AA GT N'&SYSLIST).GO7\n&AB      SETA  &AA-1               NUMBER OF LAST BASE REG DEFINED\n         LA    &SYSLIST(&AA),2048(&SYSLIST(&AB)) SET NEXT BASE REG\n         LA    &SYSLIST(&AA),2048(&SYSLIST(&AA)) SET NEXT BASE REG\n         USING &LABEL+&BUMP,&SYSLIST(&AA) INFORM THE ASSEMBLER\n&BUMP    SETA  &BUMP+4096          BUMP INDEX\n&AA      SETA  &AA+1               BUMP CONTROL COUNT\n         AGO   .LOOP\n.GO7     AIF   (T'&ERRCODE EQ 'O').GO8 IF ERROR CODE NOT SPECIFIED\n&GMT     SETC  'RC'                ERROR CODE WAS SPECIFIED\n.GO8     AIF   (T'&LV   NE 'O').GO10 LV= SPECIFIED, DO GETMAIN\n         AIF   ('&RENT' EQ 'YES').GO12 RENT SPECIFIED, DO GETMAIN\n         AIF   (T'&ERRCODE EQ 'O').GO9 IF ERROR CODE NOT SPECIFIED\n      MNOTE 8,'$PROLOG - ERRCODE=&ERRCODE INVALID WITHOUT RENT=YES/LV='\n.GO9     ANOP\n$&X.B    LA    R2,$AVE&X           ADDRESS OF SAVE AREA\n         AGO   .COMMON\n.GO10    ANOP\n&EPILOG  SETA  &LV+72              SET SIZE FOR $EPILOG FREEMAIN\n         LA    R0,&LV+72           SET SIZE FOR GETMAIN\n         GETMAIN &GMT,LV=(0)       GET STORAGE\n         AIF   (T'&ERRCODE EQ 'O').GO11 IF UNCONDITIONAL\n         LTR   R15,R15             STORAGE GOTTEN?\n         BZ    $&X.C               YES, CONTINUE\n         LA    R15,&ERRCODE        SET SPECIFIED ERROR CODE\n         ST    R15,16(R13)         INTO SAVE AREA\n         LM    R14,R12,12(R13)     RESTORE CALLERS REGS\n         BR    R14                 AND RETURN\n$&X.C    DS    0H\n.GO11    ANOP\n         LR    R2,R1               SAVE THE GOTTEN STORAGE ADDRESS\n         LR    R14,R2               MVCL - TARGET ADDR\n         LA    R15,&LV+72           MVCL - TARGET SIZE\n         SR    R0,R0                MVCL - SOURCE ADDR (NONE)\n         SR    R1,R1                MVCL - SOURCE SIZE (NONE)\n         MVCL  R14,R0              ZERO GOTTEN STORAGE\n         AGO   .COMMON\n.GO12    ANOP\n$&X.B    GETMAIN &GMT,LV=WORKEND-SAVEAREA GET THE SAVE AREA STORAGE\n         AIF   (T'&ERRCODE EQ 'O').GO13 IF UNCONDITIONAL\n         LTR   R15,R15             STORAGE GOTTEN?\n         BZ    $&X.C               YES, CONTINUE\n         LA    R15,&ERRCODE        SET SPECIFIED ERROR CODE\n         ST    R15,16(R13)         INTO SAVE AREA\n         LM    R14,R12,12(R13)     RESTORE CALLERS REGS\n         BR    R14                 AND RETURN\n$&X.C    DS    0H\n.GO13    ANOP\n         LR    R2,R1               SAVE THE GOTTEN STORAGE ADDRESS\n         LR    R14,R2               MVCL - TARGET ADDR\n         LA    R15,WORKEND-SAVEAREA MVCL - TARGET SIZE\n         LA    R0,SAVEAREA          MVCL - SOURCE ADDR\n         LR    R1,R15               MVCL - SOURCE SIZE\n         MVCL  R14,R0              COPY TO WORKING STORAGE\n         USING SAVEAREA,R13        PROVIDE ADDRESSABILITY\n.COMMON  ANOP\n         LR    R14,R13             COPY OLD SAVE AREA ADDRESS\n         LR    R13,R2              SET NEW SAVEAREA ADDRESS\n         ST    R14,4(R13)          CHAIN SAVEAREA - BACKWARD\n         ST    R13,8(R14)          CHAIN SAVEAREA - FORWARD\n         LM    R15,R2,16(R14)      RESTORE ENTRY REGISTERS\n         SR    R14,R14             RESET RETURN ADDRESS\n         AIF   (&REGS).SKIPREG\n&LISTOPT SETC  'LIST=&LIST'\n         $REGS &LISTOPT            DEFINE STANDARD REG EQUATES\n.SKIPREG AIF   ('&LIST' EQ 'YES').MEXIT\n         POP  PRINT\n.MEXIT   ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$REGS": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86\\x08\\x1f\\x00\\x86\\x08\\x1f\\x17&\\x00%\\x00%\\x00\\x00\\xe3\\xc4\\xc3\\xe2\\xf0\\xf0\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-03-22T00:00:00", "modifydate": "1986-03-22T17:26:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "TDCS000"}, "text": "         MACRO\n         $REGS &LIST=NO\n.**********************************************************************\n.*                                                                    *\n.*                                  CHANEY SYSTEMS SUPPORT, INC.      *\n.*                                                                    *\n.*       THIS MACRO PROVIDES STANDARD BASE REGISTER EQUATES FOR       *\n.*       ALL \"CSS\" SUPPORT ROUTINES.                                  *\n.*                                                                    *\n.**********************************************************************\n         GBLB  &REGS\n         AIF   (&REGS).MEXIT\n&REGS    SETB  1\n         AIF   ('&LIST' NE 'YES').LIST1\n         PUSH  PRINT               SAVE CURRENT PRINT SETTINGS\n         PRINT OFF                 TEMPORARILY TURN OFF PRINT\n.LIST1   ANOP\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         AIF   ('&LIST' NE 'YES').MEXIT\n         POP   PRINT               RESTORE CURRENT PRINT SETTINGS\n.MEXIT   ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE482": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04O\\x008\\x01\\x10\\x11\\x9f\\x01\\x10\\x11\\x9f\\x14\"\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf9@@@'", "ispf": {"version": "04.79", "flags": 0, "createdate": "2010-04-29T00:00:00", "modifydate": "2010-04-29T14:22:38", "lines": 15, "newlines": 15, "modlines": 0, "user": "CBT-479"}, "text": "//***FILE 482 is from Eric Bielefeld of Milwaukee, Wisconsin, and   *   FILE 482\n//*           contains a program called GDGCOPY to copy GDG files,  *   FILE 482\n//*           in proper order, from one GDG to another.  The reason *   FILE 482\n//*           for putting this program on the CBT Tape was because  *   FILE 482\n//*           of a recent discussion thread on IBM-MAIN (circa      *   FILE 482\n//*           end of August 2000) about copying GDG datasets in the *   FILE 482\n//*           proper order.                                         *   FILE 482\n//*                                                                 *   FILE 482\n//*           Eric Bielefeld <eric-ibmmain@WI.RR.COM>               *   FILE 482\n//*                                                                 *   FILE 482\n//*           Fixed by John Fisher to allow concatenation of        *   FILE 482\n//*           more than 100 GDGs.  (Now, up to 999 are allowed.)    *   FILE 482\n//*                                                                 *   FILE 482\n//*           \"John Fisher\" <FISHERJ@ccf.org>                       *   FILE 482\n//*                                                                 *   FILE 482\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GDGCOPY": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x02\\x01\\x10\\x11\\x9f\\x01\\x10\\x11\\x9f\\x14\\x05\\x01\\x80\\x01\\x7f\\x00\\x00\\xd1\\xc6\\xc9\\xe2\\xc8\\xc5\\xd9@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2010-04-29T00:00:00", "modifydate": "2010-04-29T14:05:02", "lines": 384, "newlines": 383, "modlines": 0, "user": "JFISHER"}, "text": "***********************************************************************\n*                                                                     *\n*                                                                     *\n*        THIS PROGRAM COPIES INPUT GENERATION DATASETS                *\n*        IN REVERSE ORDER (OLDEST GDG FIRST) TO AN OUTPUT             *\n*        DATASET(SYSUT2) ALLOWING A USER TO MAINTAIN DATA             *\n*        IN CHRONOLOGICAL SEQUENCE.  THIS IS REQUIRED IF USING        *\n*        RMF OR OTHER POST PROCESSOR SYSTEMS THAT REQUIRE SMF         *\n*        DATA TO BE IN SEQUENCE (IT AVOIDS LARGE SORTS).              *\n*                                                                     *\n*        THE INPUT DATASET NAME (HIGH LEVEL OF THE GDG) IS PASSED     *\n*        AS PARM INFORMATION AND IS USED TO \"DYNAMICALLY\" ALLOCATE    *\n*        EACH GENERATION LEVEL OF THE GROUP.  ONCE THIS ROUTINE       *\n*        IS COMPLETE, THE USER MAY SCRATCH AND UNCATALOG THE          *\n*        GENERATION DATA SETS IF HE WISHES (THIS ROUTINE \"WILL NOT\"   *\n*        SCRATCH OR UNCATALOG ANY DATASET).                           *\n*                                                                     *\n*        SINCE THIS ROUTINE IS OF GENERAL PURPOSE, THE USER MUST      *\n*        PROVIDE ALL DCB INFORMATION INFORMATION FOR BOTH SYSUT1      *\n*        (IF NON-LABELED OR NSL) AND SYSUT2 BY CODING DCB ON THE      *\n*        DD CARD.  IF THE INPUT GDG (PARM INFO) IS STANDARD LABEL,    *\n*        IT NEED NOT BE DEFINED BY SYSUT1.  IN EITHER CASE, SYSUT1    *\n*        WILL BE DYNAMICALLY DEALLOCATED AND UNCHANGED (SINCE PARM    *\n*        INFO IS USED TO IDENTIFY THE INPUT FILE(GDG)).               *\n*                                                                     *\n*        NOTE THAT FOR VS/VBS FILES, \"BFTEK=A\" WILL AUTOMATICALLY     *\n*        BE ADDED TO THE SYSUT1 DCB VIA AN OPEN EXIT.  THIS IS        *\n*        DONE TO INSURE THAT A LOGICAL RECORD IS PASSED BY QSAM       *\n*        AND ALLOWS THE OUTPUT TO BE REBLOCKED (IF SPECIFIED).        *\n*                                                                     *\n*  REQUIRED JCL:                                                      *\n*                                                                     *\n*        <----------- STANDARD LABELED INPUT FILE ----------------->  *\n*         //GDGCOPY EXEC PGM=GDGCOPY,PARM='STD.LABELED.GDG.PREFIX'    *\n* (ccf)   //STEPLIB  DD DSN=IDMS.KP7.DBA.LOADLIB,DISP=SHR             *\n*         //SYSUT2   DD DSN=OUTPUT.DSN(+1)                            *\n*                                                                     *\n*        <-----------    NON-LABELED INPUT FILE   ----------------->  *\n*         //GDGCOPY  EXEC PGM=GDGCOPY,PARM='NON.LABELED.GDG.PREFIX'   *\n*         //SYSUT1   DD DCB=????                                      *\n*         //SYSUT2   DD DSN=OUTPUT.DSN(+1)                            *\n*                                                                     *\n*  LINKAGE EDITOR ATTRIBUTES AND CONSIDERATIONS                       *\n*  ENTRY POINT: GDGCOPY (NON-RENT)                                    *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n* This program was originally written in November, 1977 and distribted*\n* via SHARE.  A version of it was obtained by CCF and assembled and   *\n* linked into SYS4.LINKLIB on 1986/241.  Our best guess is the source *\n* used is in SYS4.SOURCE.LIB and was last changed on 85/12/17 by an   *\n* unknown contractor.  In the early 21st century we began to have     *\n* very infrequent \"loops\" and it seemed to occur when there were many *\n* disk GDGs to concatenate.  In April of 2010 it was discovered that  *\n* the problem stemmed from the coding in the ENTRY900 routine that was*\n* overlaying the highest order relative GDG digit with the minus sign *\n* when attempting to process more than 100 generations.  Source from  *\n* CBT file 482, with some more recent changes, was then used for a    *\n* starting point to correct the age-old coding problem.  This code was*\n* assembled and linked into IDMS.KP7.DBA.LOADLIB and tested.  To get  *\n* this version implemented a steplib was added to the applicable procs*\n* in order to select this version over the very old link-listed code. *\n* The source was moved into Librarian for the first time.  This code  *\n* is now capable of processing up to 1000 generations of a GDG which  *\n* should be more than adequate.  ESS Database Administration. 4/22/10 *\n* The listing of the assembly of this code is stored in a PDS member: *\n* IDMS.KP7.DBA.LISTINGS(GDGCOPY)         (John Fisher)                *\n*                                                                     *\n***********************************************************************\n         PRINT NOGEN\n         EJECT\n*----------------------------------------------------------------------\n*\n*        INITIALIZATION AND DCB/JFCB/DSCB MERGE\n*\n*----------------------------------------------------------------------\nGDGCOPY  $PROLOG R12              LINKAGE CONVENTIONS\nENTRY010 DS    0H\n         L     R1,0(R1)           GET PARM POINTER\n         LH    R2,0(R1)           GET PARM SIZE\n         CH    R2,=H'0'           ANY PARM?\n         BE    RETURN             NO, RETURN TO CALLER\n         CH    R2,=H'35'          VALID SIZE?\n         BH    RETURN             NO, RETURN TO CALLER\n         LA    R3,CAMDSN(R2)      GET OFFSET TO GDG SUFFIX\n         MVC   0(3,R3),=C'(0)'    START WITH CURRENT GENERATION\n         ST    R3,GDGADDR         SAVE ADDRESS OF GENERATION LEVEL\n         BCTR  R2,0               DECREMENT FOR EXECUTE\n         EX    R2,PARMMOVE        MOVE DSNAME TO CAMLIST\n         L     R1,16              GET CVT POINTER\n         L     R1,0(R1)           OLD/NEW TCB POINTER\n         L     R1,4(R1)           OUR TCB POINTER\n         L     R1,12(R1)          OUR TIOT POINTER\n         LA    R1,24(R1)          ADDRESS OF 1ST DD ENTRY\n         SR    R15,R15            CLEAR FOR ICM\nAAA010   ICM   R15,1,0(R1)        GET SIZE OF ENTRY\n         BZ    ENTRY020           NOT FOUND, CONTINUE\n         CLC   4(8,R1),=CL8'SYSUT1' IS THIS SYSUT1 DD NAME?\n         BE    BBB010             FOUND, OPEN DUMMY FILE\n         AR    R1,R15             BUMP TO NEXT DD ENTRY\n         B     AAA010             CHECK NEXT ENTRY\n*        OPEN TO ALLOW NORMAL MERGE (RDJFCB ONLY GETS JCL INFO)\n*        NOTE: SYSUT1 IS ONLY NEEDED IF INPUT IS NL\nBBB010   OI    FLAG,UT1           INDICATE SYSUT1 WAS FOUND\n         OPEN  (SYSUT1,(INPUT))   OPEN DUMMY INPUT FILE TO FILL DCB\n         LA    R6,SYSUT1          ADDRESSABILITY TO DCB\n         USING IHADCB,R6          INFORM ASSEMBLER\n         TM    DCBOFLGS,DCBOFOPN  WAS THE SYSUT1 CARD PROVIDED\n         BZ    ENTRY020           NO, SKIP THE MERGE\n         LH    R3,DCBBLKSI        GET BLKSIZE\n         LH    R4,DCBLRECL        GET LRECL\n         IC    R5,DCBRECFM        GET RECFM\n         CLOSE (SYSUT1)           CLOSE THE DUMMY INPUT FILE\n         STH   R3,DCBBLKSI        SET BLKSIZE\n         STH   R4,DCBLRECL        SET LRECL\n         STC   R5,DCBRECFM        SET RECFM\n         B     ENTRY020           BRANCH AROUND\nPARMMOVE MVC   CAMDSN(0),2(R1)    MOVE DSNAME TO LIST\n         EJECT\n*----------------------------------------------------------------------\n*\n*        FIND THE OLDEST GENERATION DATASET NAME VIA THE CATALOG\n*\n*----------------------------------------------------------------------\nENTRY020 DS    0H\n         LOCATE CAMLIST           IS THIS THERE A '0' GENERATION\n         LTR   R15,R15            ZERO RETURN CODE ?\n         BNZ   RETURN             NO - END OF THE LINE\nAAA020   AP    GDG#,=P'1'         ADD 1 TO RELATIVE GENERATION NUMBER\n         BAL   R14,ENTRY900       CONVERT GDG#\n         LOCATE CAMLIST           LOOK FOR OLDEST GENERATION\n         LTR   R15,R15            ZERO RETURN CODE ?\n         BZ    AAA020             YES, CHECK FOR NEXT\n         SP    GDG#,=P'1'         BUMP BACK TO PREVIOUS GDG#\n         BAL   R14,ENTRY900       CONVERT GDG#\n         LOCATE CAMLIST           CONVERT GDG NUMBER\n         LTR   R15,R15            ZERO RETURN CODE ?\n         BZ    BBB020             YES, CONTINUE\n         ABEND 0,DUMP             SHOULD NOT OCCUR\nBBB020   TM    FLAG,UT1           SHOULD WE DE-ALLOCATE SYSUT1\n         BZ    CCC020             NO, CONTINUE\n         BAL   R14,ENTRY920       DEALLOCATE THE DUMMY FILE\nCCC020   OPEN  (SYSUT2,(OUTPUT))  OPEN OUTPUT FILE\nEXIT020  EQU   *\n         EJECT\n*----------------------------------------------------------------------\n*\n*        COPY THE GDG TO THE OUTPUT FILE\n*\n*----------------------------------------------------------------------\nENTRY030 DS    0H\n         BAL   R14,ENTRY910       ALLOC THE INPUT GDG\n         MVC   STATUS+26(44),CAMDSN MODIFY WRITE TO PROGRAMMER\nSTATUS   WTO   'GDGCOPY  - ACTIVE=                                     X\n                      ',ROUTCDE=11 INFORM USER GENERATIONS COPIED\n         OPEN  SYSUT1             OPEN THE INPUT GDG\nAAA030   EQU   *\n         GET   SYSUT1             GET A RECORD\n         ST    R1,SAVE14          SAVE FOR DEBUGGING 002 ABENDS\n         LR    R0,R1              POINT TO RECORD FOR PUT\n         PUT   SYSUT2,(0)         WRITE RECORD\n         B     AAA030             GET NEXT RECORD\nBBB030   EQU   *\n         CLOSE SYSUT1             CLOSE THE INPUT DATA SET\n         BAL   R14,ENTRY920       DE-ALLOCATE THE GDG\n         B     ENTRY040           SKIP OVER OPEN EXIT CODE\n         SPACE 3\nCCC030   LA    R6,SYSUT1          GET ADDRESS OF INPUT DCB\n         TM    DCBRECFM,DCBRECF   CHECK FOR FIXED LENGTH\n         BOR   R14                YES, IGNORE IT\n         TM    DCBRECFM,DCBRECV   CHECK FOR VARIABLE LENGTH\n         BZR   R14                NO, IGNORE IT\n         TM    DCBRECFM,DCBRECSB  CHECK FOR SPANNED RECORDS\n         BZR   R14                NO, IGNORE IT\n         OI    DCBBFALN,DCBBFTA   OVER-RIDE TO BFTEK=A\n         BR    R14                RETURN TO OPEN\n*----------------------------------------------------------------------\n*\n*        UPDATE TO THE NEXT GENERATION IF ANY\n*\n*----------------------------------------------------------------------\nENTRY040 DS    0H\n         CP    GDG#,=P'0'         DID WE JUST PROCESS GDG(0)?\n         BE    EOJ                YES, ALL DONE\n         SP    GDG#,=P'1'         NO, DECREMENT TO NEXT GENERATION\n         BAL   R14,ENTRY900       CONVERT GDG#\n         LOCATE CAMLIST           CONVERT NAME FOR DYNALLOC\n         LTR   R15,R15            ZERO RETURN CODE ?\n         BZ    ENTRY030           YES, CONTINUE\n         ABEND 0,DUMP             SHOULD NOT OCCUR\n         SPACE 3\n*----------------------------------------------------------------------\n*\n*        CONVERT THE GDG NUMBER FOR ALLOCATE/LOCATE\n*\n*----------------------------------------------------------------------\nENTRY900 DS    0H\n         L     R15,GDGADDR        GET MOVE TO ADDRESS\n         MVC   0(9,R15),=CL9' '   CLEAR POSSIBLE REDUNDANT GDG#\n         UNPK  2(3,R15),GDG#      UNPACK TO CAMLIST\n         OI    4(R15),X'F0'       CHANGE SIGN\n         MVI   1(R15),C'-'        NEGATIVE GDG NUMBER\n         MVI   0(R15),C'('        MOVE LEFT PAREN\n         MVC   5(2,R15),=CL25') ' MOVE RIGHT PAREN AND BLANK\n         BR    R14                RETURN\n         EJECT\n*----------------------------------------------------------------------\n*\n*        ALLOCATE THE GENERATION DATA SET\n*\n*----------------------------------------------------------------------\nENTRY910 DS    0H\n         ST    R14,SAVE14         SAVE CALLED FROM ADDRESS\n         LA    R11,DAWORK         ADDRESS OF REQUEST BLOCK\n         USING S99RBP,R11         REQ BLK POINTER DSECT\n         LA    R10,S99RBP+4       ADDRESSABILITY OF RB DSECT\n         USING S99RB,R10          RB DSECT\n         ST    R10,S99RBPTR       MAKE RBPTR POINT TO RB\n         OI    S99RBPTR,S99RBPND  TURN ON HOB IN RBPTR\n         XC    S99RB(RBLEN),S99RB  CLEAR RB\n         MVI   S99RBLN,RBLEN      PUT LEN IN ITS LENGTH FIELD\n         MVI   S99VERB,S99VRBAL   SET VERB CODE TO ALLOCATE\n* SET BITS FOR \"WAIT FOR DEVICES\" & \"WAIT FOR VOLUMES\"\n         LA    R9,S99RB+RBLEN     POINT BEYOND RB (1ST TEXT PTR)\n         USING S99TUPL,R9         ADDRESSABILITY OF TEXT UNIT POINTERS\n         ST    R9,S99TXTPP        INIT TEXT PTR IN RB\n         LA    R8,S99TUPL+16      POINT BEYOND LAST TXT PTR\n*                                 (ROOM FOR 4 TEXT UNITS)\n         USING S99TUNIT,R8        ADDRESSABILITY OF TEXT UNITS\n* DDNAME\n         ST    R8,S99TUPTR        1ST PTR TO 1ST UNIT\n         LA    R1,DALDDNAM        KEY FOR DDNAME\n         STH   R1,S99TUKEY        PUT IN TEXT UNIT KEY FIELD\n         MVC   S99TUNUM,=H'1'     MOVE 1 TO TXT UNIT NUMBR FLD\n         MVC   S99TULNG,=H'6'     MOVE 6 TO TXT UNIT LNGTH FLD\n         MVC   S99TUPAR(6),=C'SYSUT1'  DDNAME\n         LA    R8,12(R8)          BUMP TO NEXT TXT UNIT\n         LA    R9,4(R9)           BUMP TO NEXT TXT UNIT PTR\n* DISP\n         ST    R8,S99TUPTR        2ND PTR TO 2ND UNIT\n         LA    R1,DALSTATS        KEY FOR DSN STATUS\n         STH   R1,S99TUKEY        PUT IN TEXT UNIT KEY FIELD\n         MVC   S99TUNUM,=H'1'     MOVE 1 TO TXT UNIT NUMBR FLD\n         MVC   S99TULNG,=H'1'     MOVE 1 TO TXT UNIT LNGTH FLD\n         MVI   S99TUPAR,X'08'     INDICATE SHR DATA SET\n         LA    R8,9(R8)           BUMP TO NEXT TXT UNIT\n         LA    R9,4(R9)           BUMP TO NEXT TXT UNIT PTR\n* DATA SET NAME\n         ST    R8,S99TUPTR        3RD PTR TO 3RD UNIT\n         OI    S99TUPTR,S99TUPLN  TURN ON HOB TO INIDICATE LAST PTR\n         LA    R1,DALDSNAM        KEY FOR DSNAME\n         STH   R1,S99TUKEY        PUT IN TEXT UNIT KEY FIELD\n         MVC   S99TUNUM,=H'1'     MOVE 1 TO TXT UNIT NUMBR FLD\n         MVC   S99TULNG,=H'44'    MOVE 44 TO TXT UNIT LNGTH FLD\n         MVC   S99TUPAR(44),CAMDSN  DSNAME\nRETRY    DS    0H\n         LR    R1,R11             ADDR OF REQUEST BLOCK\n         DYNALLOC\n         ST    R15,RC             SAVE RETURN CODE\n         LTR   R15,R15            RETURN CODE ZERO ?\n         BNZ   ERROR1             NO - DECODE ERROR\n         L     R14,SAVE14         GET CALLED FROM ADDRESS\n         BR    R14\n         EJECT\n*----------------------------------------------------------------------\n*\n*     DE-ALLOCATE THE GENERATION DATA SET\n*\n*----------------------------------------------------------------------\nENTRY920 DS    0H\n         ST    R14,SAVE14         SAVE CALLED FROM ADDRESS\n         LA    R11,DAWORK         ADDRESS OF REQUEST BLOCK\n         USING S99RBP,R11         REQ BLK POINTER DSECT\n         LA    R10,S99RBP+4       ADDRESSABILITY OF RB DSECT\n         USING S99RB,R10          RB DSECT\n         ST    R10,S99RBPTR       MAKE RBPTR POINT TO RB\n         OI    S99RBPTR,S99RBPND  TURN ON HOB IN RBPTR\n         XC    S99RB(RBLEN),S99RB  CLEAR RB\n         MVI   S99RBLN,RBLEN      PUT LEN IN ITS LENGTH FIELD\n         MVI   S99VERB,S99VRBUN   SET VERB CODE TO UN-ALLOCATE\n         LA    R9,S99RB+RBLEN     POINT BEYOND RB (1ST TEXT PTR)\n         USING S99TUPL,R9         ADDRESSABILITY OF TEXT UNIT POINTERS\n         ST    R9,S99TXTPP        INIT TEXT PTR IN RB\n         LA    R8,S99TUPL+16      POINT BEYOND LAST TXT PTR\n*                                 (ROOM FOR 4 TEXT UNITS)\n         USING S99TUNIT,R8        ADDRESSABILITY OF TEXT UNITS\n* DDNAME\n         ST    R8,S99TUPTR        1ST PTR TO 1ST UNIT\n         LA    R1,DALDDNAM        KEY FOR DDNAME\n         STH   R1,S99TUKEY        PUT IN TEXT UNIT KEY FIELD\n         MVC   S99TUNUM,=H'1'     MOVE 1 TO TXT UNIT NUMBR FLD\n         MVC   S99TULNG,=H'6'     MOVE 6 TO TXT UNIT LNGTH FLD\n         MVC   S99TUPAR(6),=C'SYSUT1'  DDNAME\n         LA    R8,12(R8)          BUMP TO NEXT TXT UNIT\n         LA    R9,4(R9)           BUMP TO NEXT TXT UNIT PTR\n* IN-USE ATTRIBUTE\n         ST    R8,S99TUPTR        2ND PTR TO 2ND UNIT\n         OI    S99TUPTR,S99TUPLN  TURN ON HOB TO INIDICATE LAST PTR\n         LA    R1,DUNUNALC        KEY FOR UNALLOC IF IN-USE\n         STH   R1,S99TUKEY        PUT IN TEXT UNIT KEY FIELD\n         MVC   S99TUNUM,=H'0'     MOVE 0 TO TXT UNIT NUMBR FLD\n         LR    R1,R11             ADDR OF REQUEST BLOCK\n         DYNALLOC\n         ST    R15,RC             SAVE RETURN CODE\n         LTR   R15,R15            RETURN CODE ZERO ?\n         BNZ   ERROR1             NO - DECODE ERROR\n         L     R14,SAVE14         GET CALLED FROM ADDRESS\n         BR    R14\n         EJECT\n*----------------------------------------------------------------------\n*\n*        END OF JOB\n*\n*----------------------------------------------------------------------\nEOJ      XC    RC,RC              CLEAR RETCODE\n         CLOSE (SYSUT2)           CLOSE OUTPUT FILE\n         WTO   'GDGCOPY  - NORMAL COMPLETION',ROUTCDE=11\nRETURN   L     R15,RC             PICK UP RETURN CODE\n         $EPILOG\n         SPACE 3\n*----------------------------------------------------------------------\n*\n*        ERROR ROUTINES\n*\n*----------------------------------------------------------------------\nERROR1   DS    0H\n         L     R1,RC              PICK UP RETURN CODE\n         CVD   R1,DBWRD\n         UNPK  MSG1+9(3),DBWRD+6(2)        RETURN CODE\n         OI    MSG1+11,X'F0'\n         UNPK  MSG1+15(5),S99ERROR(3)      DYNAMIC ERROR CODE\n         MVI   MSG1+19,X'40'\n         UNPK  MSG1+29(5),S99INFO(3)      DYNAMIC INFO CODE\n         MVI   MSG1+33,X'40'\nMSG1     WTO   ' XXX - XXXXX ERROR - XXXXX INFO (DYNAMIC ALLOC ERROR)',X\n               ROUTCDE=11\n         CLC   MSG1+9(10),=CL10'004 - 0214' NO DEVICES AVAILABLE?\n         BE    SLEEP                    YES, WAIT A MINUTE\n         CLC   MSG1+9(10),=CL10'004 - 0484' NO DEVICES AVAILABLE?\n         BNE   ABEND1                   NO, ABEND\nSLEEP    DS    0H\n         STIMER WAIT,DINTVL=WAITTIME    WAIT A WHILE\n         XC    RC,RC                    RESET D/A RETURN CODE\n         XC    S99ERROR,S99ERROR        RESET D/A ERROR CODE\n         XC    S99INFO,S99INFO          RESET D/A INFO CODE\n         B     RETRY                    AND RETRY THE REQUEST\nABEND1   DS    0H\n         ABEND 1,DUMP\nDBWRD    DC    D'0'\n         EJECT\n*----------------------------------------------------------------------\n*\n*        CAMLIST FOR LOCATING EACH GDG\n*\n*----------------------------------------------------------------------\nCAMLIST  CAMLST NAME,CAMDSN,,CAMWORK\nCAMDSN   DC    CL44' '\nCAMWORK  DS    0D\n         DC    265C' '\n*----------------------------------------------------------------------\n*\n*        STORAGE AREAS\n*\n*----------------------------------------------------------------------\nGDGADDR  DC    F'0'               ADDRESS OF '(NNN)' FIELD\nRC       DC    F'16'              RETURN CODE (PRIMED FOR ERROR)\nSAVE14   DC    F'0'               REG 14 SAVE AREA\nEXLST    DC    X'85',AL3(CCC030)  OPEN LIST FOR SYSUT1\nGDG#     DC    PL2'0'             CURRENT GDG NUMBER\nFLAG     DC    X'00'              OPTIONS SWITCHES\nUT1      EQU   X'01'              SYSUT1 WAS FOUND IN TIOT\nWAITTIME DC    C'00010000'        WAIT TIME FOR DYNALLOC\n         LTORG\nSYSUT1   DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=GL,EODAD=BBB030,           X\n               EXLST=EXLST\nSYSUT2   DCB   DDNAME=SYSUT2,DSORG=PS,MACRF=PM\nDAWORK   DC    XL256'00'\n         DCBD  DSORG=QS\n         IEFZB4D0\n         IEFZB4D2\nRBLEN    EQU   (S99RBEND-S99RB)\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GDGCOPYO": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00$_\\x01\\x00$_\\x11\\x14\\x01i\\x01i\\x00\\x00\\xc5\\xc2\\xc9\\xc5@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-01T00:00:00", "modifydate": "2000-09-01T11:14:00", "lines": 361, "newlines": 361, "modlines": 0, "user": "EBIE"}, "text": "***********************************************************************\n*                                                                     *\n*                         CHANEY SYSTEMS SUPPORT, INC.                *\n*                                                                     *\n*                                                                     *\n*        THIS PROGRAM COPIES INPUT GENERATION DATASETS                *\n*        IN REVERSE ORDER (OLDEST GDG FIRST) TO AN OUTPUT             *\n*        DATASET(SYSUT2) ALLOWING A USER TO MAINTAIN DATA             *\n*        IN CHRONOLOGICAL SEQUENCE.  THIS IS REQUIRED IF USING        *\n*        RMF OR OTHER POST PROCESSOR SYSTEMS THAT REQUIRE SMF         *\n*        DATA TO BE IN SEQUENCE (IT AVOIDS LARGE SORTS).              *\n*                                                                     *\n*        THE INPUT DATASET NAME (HIGH LEVEL OF THE GDG) IS PASSED     *\n*        AS PARM INFORMATION AND IS USED TO \"DYNAMICALLY\" ALLOCATE    *\n*        EACH GENERATION LEVEL OF THE GROUP.  ONCE THIS ROUTINE       *\n*        IS COMPLETE, THE USER MAY SCRATCH AND UNCATALOG THE          *\n*        GENERATION DATA SETS IF HE WISHES (THIS ROUTINE \"WILL NOT\"   *\n*        SCRATCH OR UNCATALOG ANY DATASET).                           *\n*                                                                     *\n*        SINCE THIS ROUTINE IS OF GENERAL PURPOSE, THE USER MUST      *\n*        PROVIDE ALL DCB INFORMATION INFORMATION FOR BOTH SYSUT1      *\n*        (IF NON-LABELED OR NSL) AND SYSUT2 BY CODING DCB ON THE      *\n*        DD CARD.  IF THE INPUT GDG (PARM INFO) IS STANDARD LABEL,    *\n*        IT NEED NOT BE DEFINED BY SYSUT1.  IN EITHER CASE, SYSUT1    *\n*        WILL BE DYNAMICALLY DEALLOCATED AND UNCHANGED (SINCE PARM    *\n*        INFO IS USED TO IDENTIFY THE INPUT FILE(GDG)).               *\n*                                                                     *\n*        NOTE THAT FOR VS/VBS FILES, \"BFTEK=A\" WILL AUTOMATICALLY     *\n*        BE ADDED TO THE SYSUT1 DCB VIA AN OPEN EXIT.  THIS IS        *\n*        DONE TO INSURE THAT A LOGICAL RECORD IS PASSED BY QSAM       *\n*        AND ALLOWS THE OUTPUT TO BE REBLOCKED (IF SPECIFIED).        *\n*                                                                     *\n*                                                                     *\n*  REQUIRED JCL:                                                      *\n*                                                                     *\n*        <----------- STANDARD LABELED INPUT FILE ----------------->  *\n*         //GDGCOPY  EXEC PGM=GDGCOPY,PARM='STD.LABELED.GDG.PREFIX'   *\n*         //SYSUT2   DD DSN=OUTPUT.DSN(+1)                            *\n*                                                                     *\n*        <-----------    NON-LABELED INPUT FILE   ----------------->  *\n*         //GDGCOPY  EXEC PGM=GDGCOPY,PARM='NON.LABELED.GDG.PREFIX'   *\n*         //SYSUT1   DD DCB=????                                      *\n*         //SYSUT2   DD DSN=OUTPUT.DSN(+1)                            *\n*                                                                     *\n*  LINKAGE EDITOR ATTRIBUTES AND CONSIDERATIONS                       *\n*  ENTRY POINT: GDGCOPY (NON-RENT)                                    *\n*                                                                     *\n***********************************************************************\n         PRINT NOGEN\n         EJECT\n*----------------------------------------------------------------------\n*\n*        INITIALIZATION AND DCB/JFCB/DSCB MERGE\n*\n*----------------------------------------------------------------------\nGDGCOPY  $PROLOG R12              LINKAGE CONVENTIONS\nENTRY010 DS    0H\n         L     R1,0(R1)           GET PARM POINTER\n         LH    R2,0(R1)           GET PARM SIZE\n         CH    R2,=H'0'           ANY PARM?\n         BE    RETURN             NO, RETURN TO CALLER\n         CH    R2,=H'35'          VALID SIZE?\n         BH    RETURN             NO, RETURN TO CALLER\n         LA    R3,CAMDSN(R2)      GET OFFSET TO GDG SUFFIX\n         MVC   0(3,R3),=C'(0)'    START WITH CURRENT GENERATION\n         ST    R3,GDGADDR         SAVE ADDRESS OF GENERATION LEVEL\n         BCTR  R2,0               DECREMENT FOR EXECUTE\n         EX    R2,PARMMOVE        MOVE DSNAME TO CAMLIST\n         L     R1,16              GET CVT POINTER\n         L     R1,0(R1)           OLD/NEW TCB POINTER\n         L     R1,4(R1)           OUR TCB POINTER\n         L     R1,12(R1)          OUR TIOT POINTER\n         LA    R1,24(R1)          ADDRESS OF 1ST DD ENTRY\n         SR    R15,R15            CLEAR FOR ICM\nAAA010   ICM   R15,1,0(R1)        GET SIZE OF ENTRY\n         BZ    ENTRY020           NOT FOUND, CONTINUE\n         CLC   4(8,R1),=CL8'SYSUT1' IS THIS SYSUT1 DD NAME?\n         BE    BBB010             FOUND, OPEN DUMMY FILE\n         AR    R1,R15             BUMP TO NEXT DD ENTRY\n         B     AAA010             CHECK NEXT ENTRY\n*        OPEN TO ALLOW NORMAL MERGE (RDJFCB ONLY GETS JCL INFO)\n*        NOTE: SYSUT1 IS ONLY NEEDED IF INPUT IS NL\nBBB010   OI    FLAG,UT1           INDICATE SYSUT1 WAS FOUND\n         OPEN  (SYSUT1,(INPUT))   OPEN DUMMY INPUT FILE TO FILL DCB\n         LA    R6,SYSUT1          ADDRESSABILITY TO DCB\n         USING IHADCB,R6          INFORM ASSEMBLER\n         TM    DCBOFLGS,DCBOFOPN  WAS THE SYSUT1 CARD PROVIDED\n         BZ    ENTRY020           NO, SKIP THE MERGE\n         LH    R3,DCBBLKSI        GET BLKSIZE\n         LH    R4,DCBLRECL        GET LRECL\n         IC    R5,DCBRECFM        GET RECFM\n         CLOSE (SYSUT1)           CLOSE THE DUMMY INPUT FILE\n         STH   R3,DCBBLKSI        SET BLKSIZE\n         STH   R4,DCBLRECL        SET LRECL\n         STC   R5,DCBRECFM        SET RECFM\n         B     ENTRY020           BRANCH AROUND\nPARMMOVE MVC   CAMDSN(0),2(R1)    MOVE DSNAME TO LIST\n         EJECT\n*----------------------------------------------------------------------\n*\n*        FIND THE OLDEST GENERATION DATASET NAME VIA THE CATALOG\n*\n*----------------------------------------------------------------------\nENTRY020 DS    0H\n         LOCATE CAMLIST           IS THIS THERE A '0' GENERATION\n         LTR   R15,R15            ZERO RETURN CODE ?\n         BNZ   RETURN             NO - END OF THE LINE\nAAA020   AP    GDG#,=P'1'         ADD 1 TO RELATIVE GENERATION NUMBER\n         BAL   R14,ENTRY900       CONVERT GDG#\n         LOCATE CAMLIST           LOOK FOR OLDEST GENERATION\n         LTR   R15,R15            ZERO RETURN CODE ?\n         BZ    AAA020             YES, CHECK FOR NEXT\n         SP    GDG#,=P'1'         BUMP BACK TO PREVIOUS GDG#\n         BAL   R14,ENTRY900       CONVERT GDG#\n         LOCATE CAMLIST           CONVERT GDG NUMBER\n         LTR   R15,R15            ZERO RETURN CODE ?\n         BZ    BBB020             YES, CONTINUE\n         ABEND 0,DUMP             SHOULD NOT OCCUR\nBBB020   TM    FLAG,UT1           SHOULD WE DE-ALLOCATE SYSUT1\n         BZ    CCC020             NO, CONTINUE\n         BAL   R14,ENTRY920       DEALLOCATE THE DUMMY FILE\nCCC020   OPEN  (SYSUT2,(OUTPUT))  OPEN OUTPUT FILE\nEXIT020  EQU   *\n         EJECT\n*----------------------------------------------------------------------\n*\n*        COPY THE GDG TO THE OUTPUT FILE\n*\n*----------------------------------------------------------------------\nENTRY030 DS    0H\n         BAL   R14,ENTRY910       ALLOC THE INPUT GDG\n         MVC   STATUS+26(44),CAMDSN MODIFY WRITE TO PROGRAMMER\nSTATUS   WTO   'GDGCOPY  - ACTIVE=                                     X\n                      ',ROUTCDE=11 INFORM USER GENERATIONS COPIED\n         OPEN  SYSUT1             OPEN THE INPUT GDG\nAAA030   EQU   *\n         GET   SYSUT1             GET A RECORD\n         ST    R1,SAVE14          SAVE FOR DEBUGGING 002 ABENDS\n         LR    R0,R1              POINT TO RECORD FOR PUT\n         PUT   SYSUT2,(0)         WRITE RECORD\n         B     AAA030             GET NEXT RECORD\nBBB030   EQU   *\n         CLOSE SYSUT1             CLOSE THE INPUT DATA SET\n         BAL   R14,ENTRY920       DE-ALLOCATE THE GDG\n         B     ENTRY040           SKIP OVER OPEN EXIT CODE\n         SPACE 3\nCCC030   LA    R6,SYSUT1          GET ADDRESS OF INPUT DCB\n         TM    DCBRECFM,DCBRECF   CHECK FOR FIXED LENGTH\n         BOR   R14                YES, IGNORE IT\n         TM    DCBRECFM,DCBRECV   CHECK FOR VARIABLE LENGTH\n         BZR   R14                NO, IGNORE IT\n         TM    DCBRECFM,DCBRECSB  CHECK FOR SPANNED RECORDS\n         BZR   R14                NO, IGNORE IT\n         OI    DCBBFALN,DCBBFTA   OVER-RIDE TO BFTEK=A\n         BR    R14                RETURN TO OPEN\n*----------------------------------------------------------------------\n*\n*        UPDATE TO THE NEXT GENERATION IF ANY\n*\n*----------------------------------------------------------------------\nENTRY040 DS    0H\n         CP    GDG#,=P'0'         DID WE JUST PROCESS GDG(0)?\n         BE    EOJ                YES, ALL DONE\n         SP    GDG#,=P'1'         NO, DECREMENT TO NEXT GENERATION\n         BAL   R14,ENTRY900       CONVERT GDG#\n         LOCATE CAMLIST           CONVERT NAME FOR DYNALLOC\n         LTR   R15,R15            ZERO RETURN CODE ?\n         BZ    ENTRY030           YES, CONTINUE\n         ABEND 0,DUMP             SHOULD NOT OCCUR\n         SPACE 3\n*----------------------------------------------------------------------\n*\n*        CONVERT THE GDG NUMBER FOR ALLOCATE/LOCATE\n*\n*----------------------------------------------------------------------\nENTRY900 DS    0H\n         L     R15,GDGADDR        GET MOVE TO ADDRESS\n         MVC   0(9,R15),=CL9' '   CLEAR POSSIBLE REDUNDANT GDG#\n         UNPK  1(3,R15),GDG#      UNPACK TO CAMLIST\n         OI    3(R15),X'F0'       CHANGE SIGN\n         MVI   1(R15),C'-'        NEGATIVE GDG NUMBER\n         MVI   0(R15),C'('        MOVE LEFT PAREN\n         MVC   4(2,R15),=CL25') ' MOVE RIGHT PAREN AND BLANK\n         BR    R14                RETURN\n         EJECT\n*----------------------------------------------------------------------\n*\n*        ALLOCATE THE GENERATION DATA SET\n*\n*----------------------------------------------------------------------\nENTRY910 DS    0H\n         ST    R14,SAVE14         SAVE CALLED FROM ADDRESS\n         LA    R11,DAWORK         ADDRESS OF REQUEST BLOCK\n         USING S99RBP,R11         REQ BLK POINTER DSECT\n         LA    R10,S99RBP+4       ADDRESSABILITY OF RB DSECT\n         USING S99RB,R10          RB DSECT\n         ST    R10,S99RBPTR       MAKE RBPTR POINT TO RB\n         OI    S99RBPTR,S99RBPND  TURN ON HOB IN RBPTR\n         XC    S99RB(RBLEN),S99RB  CLEAR RB\n         MVI   S99RBLN,RBLEN      PUT LEN IN ITS LENGTH FIELD\n         MVI   S99VERB,S99VRBAL   SET VERB CODE TO ALLOCATE\n* SET BITS FOR \"WAIT FOR DEVICES\" & \"WAIT FOR VOLUMES\"\n         LA    R9,S99RB+RBLEN     POINT BEYOND RB (1ST TEXT PTR)\n         USING S99TUPL,R9         ADDRESSABILITY OF TEXT UNIT POINTERS\n         ST    R9,S99TXTPP        INIT TEXT PTR IN RB\n         LA    R8,S99TUPL+16      POINT BEYOND LAST TXT PTR\n*                                 (ROOM FOR 4 TEXT UNITS)\n         USING S99TUNIT,R8        ADDRESSABILITY OF TEXT UNITS\n* DDNAME\n         ST    R8,S99TUPTR        1ST PTR TO 1ST UNIT\n         LA    R1,DALDDNAM        KEY FOR DDNAME\n         STH   R1,S99TUKEY        PUT IN TEXT UNIT KEY FIELD\n         MVC   S99TUNUM,=H'1'     MOVE 1 TO TXT UNIT NUMBR FLD\n         MVC   S99TULNG,=H'6'     MOVE 6 TO TXT UNIT LNGTH FLD\n         MVC   S99TUPAR(6),=C'SYSUT1'  DDNAME\n         LA    R8,12(R8)          BUMP TO NEXT TXT UNIT\n         LA    R9,4(R9)           BUMP TO NEXT TXT UNIT PTR\n* DISP\n         ST    R8,S99TUPTR        2ND PTR TO 2ND UNIT\n         LA    R1,DALSTATS        KEY FOR DSN STATUS\n         STH   R1,S99TUKEY        PUT IN TEXT UNIT KEY FIELD\n         MVC   S99TUNUM,=H'1'     MOVE 1 TO TXT UNIT NUMBR FLD\n         MVC   S99TULNG,=H'1'     MOVE 1 TO TXT UNIT LNGTH FLD\n         MVI   S99TUPAR,X'08'     INDICATE SHR DATA SET\n         LA    R8,9(R8)           BUMP TO NEXT TXT UNIT\n         LA    R9,4(R9)           BUMP TO NEXT TXT UNIT PTR\n* DATA SET NAME\n         ST    R8,S99TUPTR        3RD PTR TO 3RD UNIT\n         OI    S99TUPTR,S99TUPLN  TURN ON HOB TO INIDICATE LAST PTR\n         LA    R1,DALDSNAM        KEY FOR DSNAME\n         STH   R1,S99TUKEY        PUT IN TEXT UNIT KEY FIELD\n         MVC   S99TUNUM,=H'1'     MOVE 1 TO TXT UNIT NUMBR FLD\n         MVC   S99TULNG,=H'44'    MOVE 44 TO TXT UNIT LNGTH FLD\n         MVC   S99TUPAR(44),CAMDSN  DSNAME\nRETRY    DS    0H\n         LR    R1,R11             ADDR OF REQUEST BLOCK\n         DYNALLOC\n         ST    R15,RC             SAVE RETURN CODE\n         LTR   R15,R15            RETURN CODE ZERO ?\n         BNZ   ERROR1             NO - DECODE ERROR\n         L     R14,SAVE14         GET CALLED FROM ADDRESS\n         BR    R14\n         EJECT\n*----------------------------------------------------------------------\n*\n*     DE-ALLOCATE THE GENERATION DATA SET\n*\n*----------------------------------------------------------------------\nENTRY920 DS    0H\n         ST    R14,SAVE14         SAVE CALLED FROM ADDRESS\n         LA    R11,DAWORK         ADDRESS OF REQUEST BLOCK\n         USING S99RBP,R11         REQ BLK POINTER DSECT\n         LA    R10,S99RBP+4       ADDRESSABILITY OF RB DSECT\n         USING S99RB,R10          RB DSECT\n         ST    R10,S99RBPTR       MAKE RBPTR POINT TO RB\n         OI    S99RBPTR,S99RBPND  TURN ON HOB IN RBPTR\n         XC    S99RB(RBLEN),S99RB  CLEAR RB\n         MVI   S99RBLN,RBLEN      PUT LEN IN ITS LENGTH FIELD\n         MVI   S99VERB,S99VRBUN   SET VERB CODE TO UN-ALLOCATE\n         LA    R9,S99RB+RBLEN     POINT BEYOND RB (1ST TEXT PTR)\n         USING S99TUPL,R9         ADDRESSABILITY OF TEXT UNIT POINTERS\n         ST    R9,S99TXTPP        INIT TEXT PTR IN RB\n         LA    R8,S99TUPL+16      POINT BEYOND LAST TXT PTR\n*                                 (ROOM FOR 4 TEXT UNITS)\n         USING S99TUNIT,R8        ADDRESSABILITY OF TEXT UNITS\n* DDNAME\n         ST    R8,S99TUPTR        1ST PTR TO 1ST UNIT\n         LA    R1,DALDDNAM        KEY FOR DDNAME\n         STH   R1,S99TUKEY        PUT IN TEXT UNIT KEY FIELD\n         MVC   S99TUNUM,=H'1'     MOVE 1 TO TXT UNIT NUMBR FLD\n         MVC   S99TULNG,=H'6'     MOVE 6 TO TXT UNIT LNGTH FLD\n         MVC   S99TUPAR(6),=C'SYSUT1'  DDNAME\n         LA    R8,12(R8)          BUMP TO NEXT TXT UNIT\n         LA    R9,4(R9)           BUMP TO NEXT TXT UNIT PTR\n* IN-USE ATTRIBUTE\n         ST    R8,S99TUPTR        2ND PTR TO 2ND UNIT\n         OI    S99TUPTR,S99TUPLN  TURN ON HOB TO INIDICATE LAST PTR\n         LA    R1,DUNUNALC        KEY FOR UNALLOC IF IN-USE\n         STH   R1,S99TUKEY        PUT IN TEXT UNIT KEY FIELD\n         MVC   S99TUNUM,=H'0'     MOVE 0 TO TXT UNIT NUMBR FLD\n         LR    R1,R11             ADDR OF REQUEST BLOCK\n         DYNALLOC\n         ST    R15,RC             SAVE RETURN CODE\n         LTR   R15,R15            RETURN CODE ZERO ?\n         BNZ   ERROR1             NO - DECODE ERROR\n         L     R14,SAVE14         GET CALLED FROM ADDRESS\n         BR    R14\n         EJECT\n*----------------------------------------------------------------------\n*\n*        END OF JOB\n*\n*----------------------------------------------------------------------\nEOJ      XC    RC,RC              CLEAR RETCODE\n         CLOSE (SYSUT2)           CLOSE OUTPUT FILE\n         WTO   'GDGCOPY  - NORMAL COMPLETION',ROUTCDE=11\nRETURN   L     R15,RC             PICK UP RETURN CODE\n         $EPILOG\n         SPACE 3\n*----------------------------------------------------------------------\n*\n*        ERROR ROUTINES\n*\n*----------------------------------------------------------------------\nERROR1   DS    0H\n         L     R1,RC              PICK UP RETURN CODE\n         CVD   R1,DBWRD\n         UNPK  MSG1+9(3),DBWRD+6(2)        RETURN CODE\n         OI    MSG1+11,X'F0'\n         UNPK  MSG1+15(5),S99ERROR(3)      DYNAMIC ERROR CODE\n         MVI   MSG1+19,X'40'\n         UNPK  MSG1+29(5),S99INFO(3)      DYNAMIC INFO CODE\n         MVI   MSG1+33,X'40'\nMSG1     WTO   ' XXX - XXXXX ERROR - XXXXX INFO (DYNAMIC ALLOC ERROR)',X\n               ROUTCDE=11\n         CLC   MSG1+9(10),=CL10'004 - 0214' NO DEVICES AVAILABLE?\n         BE    SLEEP                    YES, WAIT A MINUTE\n         CLC   MSG1+9(10),=CL10'004 - 0484' NO DEVICES AVAILABLE?\n         BNE   ABEND1                   NO, ABEND\nSLEEP    DS    0H\n         STIMER WAIT,DINTVL=WAITTIME    WAIT A WHILE\n         XC    RC,RC                    RESET D/A RETURN CODE\n         XC    S99ERROR,S99ERROR        RESET D/A ERROR CODE\n         XC    S99INFO,S99INFO          RESET D/A INFO CODE\n         B     RETRY                    AND RETRY THE REQUEST\nABEND1   DS    0H\n         ABEND 1,DUMP\nDBWRD    DC    D'0'\n         EJECT\n*----------------------------------------------------------------------\n*\n*        CAMLIST FOR LOCATING EACH GDG\n*\n*----------------------------------------------------------------------\nCAMLIST  CAMLST NAME,CAMDSN,,CAMWORK\nCAMDSN   DC    CL44' '\nCAMWORK  DS    0D\n         DC    265C' '\n*----------------------------------------------------------------------\n*\n*        STORAGE AREAS\n*\n*----------------------------------------------------------------------\nGDGADDR  DC    F'0'               ADDRESS OF '(NNN)' FIELD\nRC       DC    F'16'              RETURN CODE (PRIMED FOR ERROR)\nSAVE14   DC    F'0'               REG 14 SAVE AREA\nEXLST    DC    X'85',AL3(CCC030)  OPEN LIST FOR SYSUT1\nGDG#     DC    PL2'0'             CURRENT GDG NUMBER\nFLAG     DC    X'00'              OPTIONS SWITCHES\nUT1      EQU   X'01'              SYSUT1 WAS FOUND IN TIOT\nWAITTIME DC    C'00010000'        WAIT TIME FOR DYNALLOC\n         LTORG\nSYSUT1   DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=GL,EODAD=BBB030,           X\n               EXLST=EXLST\nSYSUT2   DCB   DDNAME=SYSUT2,DSORG=PS,MACRF=PM\nDAWORK   DC    XL256'00'\n         DCBD  DSORG=QS\n         IEFZB4D0\n         IEFZB4D2\nRBLEN    EQU   (S99RBEND-S99RB)\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT482/FILE482.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT482", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}