{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011845000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 58786, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE367.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE367.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x02\\r'", "DS1TRBAL": "b'p~'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\xac\\x00\\x01\\x02\\xac\\x00\\x03\\x00\\x03'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x00G\\x01\\x194\\x0f\\x01\\x194\\x0f\\t(\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2019-12-06T00:00:00", "modifydate": "2019-12-06T09:28:47", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-499"}, "text": "REGULAR CBT TAPE - VERSION 499    FILE:  367\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT499.FILE367\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 4 MEMBERS COUNTED; CUMULATIVE SIZE IS 243 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   12/06/19    09:28:46    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE367": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x004\\x01\\x194\\x0f\\x01\\x194\\x0f\\t(\\x00\\x08\\x00\\x08\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2019-12-06T00:00:00", "modifydate": "2019-12-06T09:28:34", "lines": 8, "newlines": 8, "modlines": 0, "user": "CBT-499"}, "text": "//***FILE 367 contains two REXX execs from John Kalinich.           *   FILE 367\n//*                                                                 *   FILE 367\n//*     ASCBS    -  Show all active address spaces                  *   FILE 367\n//*                                                                 *   FILE 367\n//*     TSURXS   -  Display active TSO Users                        *   FILE 367\n//*                                                                 *   FILE 367\n//* >>   email address:  jkalinic@outlook.com                       *   FILE 367\n//*                                                                 *   FILE 367\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASCBS": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x12\\x7f\\x00\\x99\\x12\\x7f\\x16\\x00\\x00j\\x00j\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-05-07T00:00:00", "modifydate": "1999-05-07T16:00:00", "lines": 106, "newlines": 106, "modlines": 0, "user": "SBGOLOB"}, "text": "/* rexx **************************************************************\n *                                                                   *\n * This exec will show active address spaces and their current       *\n * storage frame counts.                                             *\n *                                                                   *\n * Matt Bressler                                                     *\n *********************************************************************/\n\nloc = @l(16)                         /* a(cvt) */\nasvt = @l(,22C,loc)                  /* a(asvt) */\nasvtmaxu = x2d(@l(,204,asvt))        /* asvtmaxu */\nasvt = @la(,210,asvt)                /* asvtenty */\n\nsay 'There are' asvtmaxu 'asids defined on this system'\n\nasidtab. = 0\nsorttab. = 0\ndo asid = 1 to asvtmaxu\n   sorttab.asid = asid\n   if bitand(storage(asvt,1),'80'x) <> '80'x then do\n      ascb = @l(,,asvt)\n      jobname = @l(,AC,ascb)\n      if jobname = 0 then\n         jobname = @l(,B0,ascb)\n      jobname = storage(jobname,8)\n      rax = @l(,16c,ascb)\n      raxfmct = x2d(@l(,2C,rax))\n      asidtab.asid = asid\n      jobntab.asid = jobname\n      fmcttab.asid = raxfmct\n      say 'ASID('format(asid,3)') NAME('||,\n          jobname') FMCT('raxfmct')'\n   end  /* if asid is in use */\n   asvt = @la(4,,asvt)   /* point to next asvtenty */\nend  /* do all asids */\n\n/* sort descending on frame count */\ndo outer = 1 to asvtmaxu-1\n   do inner = outer+1 to asvtmaxu\n      ptrinner = sorttab.inner\n      ptrouter = sorttab.outer\n      if fmcttab.ptrinner > fmcttab.ptrouter then do\n         holder = sorttab.outer\n         sorttab.outer = sorttab.inner\n         sorttab.inner = holder\n      end\n   end\nend\n\n/* display the sorted tables */\nsay ' '\nsay 'Table displayed in sorted order, descending by framecount'\ndo asid = 1 to asvtmaxu\n   ptr = sorttab.asid\n   if asidtab.ptr <> 0 then\n      say 'ASID('format(ptr,3)') NAME('||,\n          jobntab.ptr') FMCT('fmcttab.ptr')'\nend\nexit 0\n /* C O P Y  C O D E  - level 1.5 - Matt Bressler                     */\n /*********************************************************************\n  * This function mimics the assembler \"LA\" instruction by returning  *\n  * the sum of the three passed arguments:                            *\n  *    1) decimal \"displacement\"                                      *\n  *    2) hex \"index\"                                                 *\n  *    3) hex \"base\"                                                  *\n  * The sum is represented in hex format which can be used as input   *\n  * to the STORAGE function.                                          *\n  *********************************************************************/\n  @la: procedure\n    return right('00000000'||addemup(arg(1),arg(2),arg(3)),8)\n /*********************************************************************\n  * This function mimics the assmembler \"L\" instruction by returning  *\n  * the fullword of storage at the address represented by the three   *\n  * arguments.  See @la for a description.                            *\n  *********************************************************************/\n  @l: procedure\n    return c2x(storage(addemup(arg(1),arg(2),arg(3)),4))\n /*********************************************************************\n * This function mimics the assmembler \"LH\" instruction by returning *\n * the halfword of storage at the address represented by the three   *\n * arguments.  See @la for a description.                            *\n *********************************************************************/\n @lh: procedure\n   return c2x(storage(addemup(arg(1),arg(2),arg(3)),2))\n/*********************************************************************\n * This function mimics the assmembler \"IC\" instruction by returning *\n * the byte of storage at the address represented by the three       *\n * arguments.  See @la for a description.                            *\n *********************************************************************/\n @ic: procedure\n   return c2x(storage(addemup(arg(1),arg(2),arg(3)),1))\n/*********************************************************************\n * This routine adds the arguments for @la, @l, @lh, and @ic.        *\n *********************************************************************/\n addemup: procedure\n   numeric digits 10\n   arg disp,index,base\n   a = 0\n   if disp <> \"\" then\n      a = a + disp\n   if index <> \"\" then\n      a = a + x2d(index)\n   if base <> \"\" then\n      a = a + x2d(base)\n   return d2x(a)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSURXS": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x12\\x7f\\x00\\x99\\x12\\x7f\\x12Q\\x00u\\x00u\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-05-07T00:00:00", "modifydate": "1999-05-07T12:51:00", "lines": 117, "newlines": 117, "modlines": 0, "user": "SBGOLOB"}, "text": "/* REXX -\n +------------------------------------------------------------------+\n | Name:       TSURXS                                               |\n | Type:       REXX exec                                            |\n | Purpose:    Display TSO userid from the OUCB                     |\n | Release:    OS/390 2.4                                           |\n | Programmer: John Kalinich                                        |\n | Date:       04/28/99                                             |\n | Abstract:   Display all TSO userids in sorted order              |\n |                                                                  |\n | Call Format:  TSURX                                              |\n |                                                                  |\n | Logic: Extracts the CVT (at x'10')                               |\n |        Extracts the ASVT (CVT+x'22C')                            |\n |        Extracts first available ASVT entry (ASVT+x'20C')         |\n |  .---> Extracts the next ASCB in vector table                    |\n |  |     Extracts the OUCB (ASCB+x'90')                            |\n |  '---- Extracts OUCBUSRD                                         |\n +------------------------------------------------------------------+ */\nArg\nTrace\nNumeric Digits 10\n\ncvt_ptr   = Get_ptr(10,0)\nasvt_ptr  = Get_ptr(cvt_ptr,'22c')\nmax_users = X2d(Get_ptr(asvt_ptr,'204'))           /* Max ASID's     */\nasvt_frst_ptr = D2x(x2d(asvt_ptr) + x2d(20c))      /* ASVTFRST       */\n\n/*  Master Scheduler, ASID=1, ASVT+x'210'     */\n\ncount = 0\nuserid. = ''\nSay 'TSO Users:'\n\nDo max_users\n  asvt_frst_ptr = D2x(X2d(asvt_frst_ptr) + X2d(4)) /* Next ASID      */\n  ascb_ptr = Get_ptr(asvt_frst_ptr,0)\n\n  If Bitand(Left(X2c(ascb_ptr),1),'80'x) = '80'x   /* Available ASID */\n    Then\n      Iterate\n\n  ascb_jbns_ptr = Get_ptr(ascb_ptr,'b0')\n  If ascb_jbns_ptr = '00000000' Then               /* No jobname     */\n    Iterate\n\n  oucb_ptr = Get_ptr(ascb_ptr,'90')\n  oucb_yfl = Get_data(oucb_ptr,'12',1)\n  If Bitand(oucb_yfl,'20'x) <> '20'x Then          /* Not a Logon    */\n    Iterate\n\n  oucb_usrd = Get_data(oucb_ptr,'d0',8)\n  If Left(oucb_usrd,1) = '40'x Then                /* No userid      */\n    Iterate\n\n  count = count + 1\n  userid.count = oucb_usrd\nEnd\n\nCall Sort_Userids\nCall Print_Userids\n\nExit\n\nSort_Userids:  /* Bubble sort */\n  last = count - 1\n  Do x = 1 to last\n    Do y = x to last\n      z = y + 1\n      If userid.x > userid.z Then\n        Do\n          userid.hold = userid.x\n          userid.x = userid.z\n          userid.z = userid.hold\n        End\n    End\n  End\n  Return\n\nPrint_Userids:  /* 8 to a line */\n  line = ''\n  Do x = 1 to count\n    line = line || userid.x\n    If x // 8 = 0 Then\n      Do\n        Say line\n        line = ''\n      End\n  End\n  Say line\n  Return\n\nGet_ptr: Procedure\n  /* +-----------------------------------------+\n     3 returns a 4 byte pointer as hexadecimal 3\n     3 string at address addr+offset.          3\n     3 ADDR and OFFSET must be HEX strings.    3\n     +-----------------------------------------+ */\n  Arg addr, offset\n  temp = D2x(X2d(addr) + X2d(offset))\n  Return C2x(Storage(temp,4))\n  Exit\n\nGet_data: Procedure\n  /* +-----------------------------------------+\n     3 returns LENGTH bytes at ADDR+OFFSET as  3\n     3 an EBCDIC string.                       3\n     3 ADDR and OFFSET must be HEX strings.    3\n     3 LENGTH must be a decimal string.        3\n     +-----------------------------------------+ */\n  Arg addr, offset, length\n  temp = D2x(X2d(addr) + X2d(offset))\n  Return Storage(temp,length)\n  Exit\n\n/* J.Kalinich, x4521 */\n/* Exec to list TSO users (sorted by userid)                        */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT367/FILE367.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT367", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}