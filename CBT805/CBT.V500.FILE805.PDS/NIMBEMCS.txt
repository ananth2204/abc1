//SCHMUMAS JOB (,OSS),'SCHMUTZOK,MIKE',
//             CLASS=A,MSGCLASS=X,NOTIFY=SCHMUM
//OUT1     OUTPUT DEPT='TECH SUPPORT',JESDS=ALL,DEFAULT=YES,
//             TITLE='ASSEMBLE NIMBEMCS'
/*JOBPARM LINES=100
//ASMA     EXEC ASMACL,
//             PARM.C='XREF(SHORT),OBJECT',
//             PARM.L='LIST,XREF,AC=1' ,RENT,REUS'
//C.SYSLIB DD  DSN=SYS1.MACLIB,DISP=SHR
//         DD  DSN=SYS1.AMODGEN,DISP=SHR
//         DD  DSN=SCHMUM.NIMAGNT.MACLIB,DISP=SHR
//C.SYSIN  DD  *
*PROCESS  USING(NOWARN)
IEAEXMCS CSECT ,
IEAEXMCS AMODE ANY
IEAEXMCS RMODE 24
*---------------------------------------------------------------------*
*- Descriptive name: Application program for setting up an extended  -*
*-           MCS console interface so that SNMP traps can be sent to -*
*-           NimBUS for alerting purposes based on selected error    -*
*-           messages                                                -*
*-                                                                   -*
*- Function: An example showing how to use the extended console      -*
*-           programming interface to activate a console, deactivate -*
*-           a console, receive messages, process MDB objects, and   -*
*-           listen for console alerts.                              -*
*-                                                                   -*
*-           This example also illustrates use of some other MVS     -*
*-           operations facilities including:                        -*
*-           the MODIFY/STOP interface (using EXTRACT and QEDIT),    -*
*-           CONVCON to see if a console is active,                  -*
*-           MGCRE to issue system commands,                         -*
*-           WTO using the TEXT key,                                 -*
*-           and DOM to delete a held message.                       -*
*-                                                                   -*
*-         NIMBEMCS responds to the following MODIFY commands:       -*
*-                                                                   -*
*-              ACTIVATE <optional console name>                     -*
*-                 to activate its extended console                  -*
*-                                                                   -*
*-              DEACTIVATE                                           -*
*-                 to deactivate its extended console                -*
*-                                                                   -*
*-           Any other modify command will be reissued as an MVS     -*
*-           command via MGCRE.                                      -*
*-                                                                   -*
*-           Any messages that are received through the extended     -*
*-           console are reissued as single line WTOs to the last    -*
*-           console that issued a MODIFY command.                   -*
*-                                                                   -*
*-         NIMBEMCS is implemented as a reentrant program.  It must  -*
*-           be APF authorized.  Wherever possible it runs problem   -*
*-           state, key 8.                                           -*
*-                                                                   -*
*- Operation:                                                        -*
*-     initialization                                                -*
*-     main router loop                                              -*
*-       if done, exit                                               -*
*-       if message queued, process all messages                     -*
*-          process all MDBs in the message                          -*
*-            determine object type                                  -*
*-            call appropriate processing routine                    -*
*-              for this example, the processing routines establish  -*
*-              addressability to the object and return;  no actual  -*
*-              processing is really performed                       -*
*-       if alert posted, process the alert                          -*
*-          display any alert conditions                             -*
*-          this example doesn't try to recover from any alert       -*
*-           conditions, it just deactivates the console             -*
*-       if modify or stop queued, process the CIB                   -*
*-          when CIB is a modify, determine command                  -*
*-             when 'ACTIVATE' the console is activated              -*
*-             when 'DEACTIVATE' the console is deactivated          -*
*-             otherwise complain about invalid command              -*
*-          when CIB is a stop, set done flag                        -*
*-          delete the CIB                                           -*
*-                                                                   -*
*- NOTE: This is a re-entrant program, but should be assembled   @P1A-*
*-       without the PARM=RENT option. If PARM=RENT is used,     @P1A-*
*-       the assembler will issue warning messages saying        @P1A-*
*-       "RE-ENTRANT CHECK FAILED".                              @P1A-*
*-       Dynamic variables should be added between the labels    @P1A-*
*-       DYNMODEL and DYNL.                                      @P1A-*
*-                                                                   -*
*---------------------------------------------------------------------*
* The following console messages will cause an SNMP trap to be sent   *
* to NimBUS:                                                          *
*                                                                     *
* OPS001I xxxxxxxx  (any message - used for testing)                  *
* DSNJ110E x LAST COPY x ACTIVE LOG DATA SET IS x PERCENT FULL        *
* IGD17380I STORAGE GROUP (sgname) IS ESTIMATED AT xx% OF CAPACITY    *
* DFHSM0131 applid CICS is under stress (short on storage below 16MB) *
* DFHSM0133 applid CICS is under stress (short on storage above 16MB) *
* DFHSM0102 applid A storage violation has been detected by...        *
* DFHSM0103 applid A storage violation has been detected by...        *
* ARKE*****: (A6G0  ) TIF ABEND T*** IN PROGRAM pppppppp              *
*                                                                     *
* MAS 12/03/08   Added code to restrict processing of DSNJ110E        *
*                messages to those with a percentage equal to or      *
*                greater than 25%                                     *
*---------------------------------------------------------------------*
* begin AR mode linkage convention
       BAKR    R14,0              save regs
       SAC     512                set AR mode
       SYSSTATE ASCENV=AR         let macros know
       LAE     R12,0(R15,0)       base and address regs
       USING   IEAEXMCS,R12       addressability
       MODID   ,                  eye catcher and date
       STORAGE OBTAIN,LENGTH=DYNL,LOC=BELOW get dynamic storage
       LAE     R11,0(0,R1)        use R11 as dyn base
       LAE     R2,DYNMODEL        address of dynamic area model
       L       R3,=A(DYNL)        length of dynamic area
       LAE     R4,0(0,R11)        address of dynamic area
       LR      R5,R3              length of dynamic area
       MVCL    R4,R2              copy model to dynamic area
       USING   DYNMODEL,R11       map model over dynamic area
       LAE     R13,SV             put save area addr in R13
       MVC     4(4,R13),=C'F1SA'  set acro in save area
* end AR mode linkage convention
* begin initialization
       SAC     0                  set primary mode
       SYSSTATE ASCENV=P          let macros know
       LA      R9,COMADDR         get address for com area
       EXTRACT (R9),FIELDS=COMM,  extract the com area                 X
               MF=(E,EXTRACT)
       L       R9,COMADDR         get address of the area
       USING   COM,R9             use R9 as base address of comm area
       ICM     R7,15,COMCIBPT     get address of the CIB
       BZ      NOCIB              no start CIB
       BAL     R14,DOCIB          process the CIB
NOCIB  DS      0H
       QEDIT   ORIGIN=COMCIBPT,                                        X
               CIBCTR=1           set modify limit to 1
       L       R1,COMECBPT        get address of the com ecb
       O       R1,=X'80000000'    set high bit - last ecb in list
       ST      R1,MODECB          put addr of modify ecb in list
       LA      R1,ECB             get addr of message ecb
       ST      R1,MECB            put into ecb list
       LA      R1,ALERT           get addr of alert ecb
       ST      R1,AECB            put into ecb list
       MVC     WTOID,=C'WJS999I ' message id for echoed messages
       MVC     CMDRSP,STRTD       started task, init msg back to cons
       LA      R1,INITMSG         get initialization message
       BAL     R14,MESSR          display message
       MVI     CMDRSP,0           make sure command response reset
       WTO     TEXT=INITMS2,      display held initialization msg      X
               MF=(E,WTOHOLD)
       ST      R1,MSGID           keep held message id for DOM
       MVC     BUFLENA,=F'20'
       MVC     BUFFERA(20),=C'/cai/agent/ro/awtrap'
*                                 PGMNAME
       LA      R15,=F'6'            LENGTH
       ST      R15,ARGLLST+00       LENGTH PARM LIST
       LA      R15,PROGRAM          ARGUMENT
       ST      R15,ARGSLST+00       ARGUMENT ADDRESS PARM LIST
*                                 FIRST - PART 1 (-h)
       LA      R15,=F'2'            LENGTH
       ST      R15,ARGLLST+04       LENGTH PARM LIST
       LA      R15,HOST1            ARGUMENT
       ST      R15,ARGSLST+04       ARGUMENT ADDRESS PARM LIST
*                                 FIRST - PART 2 (gsm11)
       LA      R15,=F'13'           LENGTH
       ST      R15,ARGLLST+08       LENGTH PARM LIST
       LA      R15,DESTIP           ARGUMENT
       ST      R15,ARGSLST+08       ARGUMENT ADDRESS PARM LIST
*                                 SECOND - PART 1 (-c)
       LA      R15,=F'2'            LENGTH
       ST      R15,ARGLLST+12       LENGTH PARM LIST
       LA      R15,COMM1            ARGUMENT
       ST      R15,ARGSLST+12       ARGUMENT ADDRESS PARM LIST
*                                 SECOND - PART 2 (shandstss)
       LA      R15,=F'9'            LENGTH
       ST      R15,ARGLLST+16       LENGTH PARM LIST
       LA      R15,COMM2            ARGUMENT
       ST      R15,ARGSLST+16       ARGUMENT ADDRESS PARM LIST
*                                 THIRD (1.3.6.1.4.1.15037.6.3)
       LA      R15,=F'21'           LENGTH
       ST      R15,ARGLLST+20       LENGTH PARM LIST
       LA      R15,TRAPOID          ARGUMENT
       ST      R15,ARGSLST+20       ARGUMENT ADDRESS PARM LIST
*                                 FOURTH (type - 6)
       LA      R15,=F'1'            LENGTH
       ST      R15,ARGLLST+24       LENGTH PARM LIST
       LA      R15,TYPE             ARGUMENT
       ST      R15,ARGSLST+24       ARGUMENT ADDRESS PARM LIST
*                                 FIFTH - PART (subtype)
       LA      R15,=F'2'            LENGTH
       ST      R15,ARGLLST+28       LENGTH PARM LIST
       LA      R15,SUBTYPE          ARGUMENT
       ST      R15,ARGSLST+28       ARGUMENT ADDRESS PARM LIST
*                                 SIXTH - Part 1 - VAR NUMBER
       LA      R15,=F'23'           LENGTH
       ST      R15,ARGLLST+32       LENGTH PARM LIST
       LA      R15,VAR1OID          ARGUMENT
       ST      R15,ARGSLST+32       ARGUMENT ADDRESS PARM LIST
*                                 SIXTH - PART 2 - VAR TYPE
       LA      R15,=F'2'            LENGTH
       ST      R15,ARGLLST+36       LENGTH PARM LIST
       LA      R15,STRING           ARGUMENT
       ST      R15,ARGSLST+36       ARGUMENT ADDRESS PARM LIST
*                                 SIXTH - PART 3 - VAR VALUE
       LA      R15,VAR1VAL          ARGUMENT
       ST      R15,ARGSLST+40       ARGUMENT ADDRESS PARM LIST
*                                 SEVENTH - PART 1 - VAR NUMBER
       LA      R15,=F'23'           LENGTH
       ST      R15,ARGLLST+44       LENGTH PARM LIST
       LA      R15,VAR2OID          ARGUMENT
       ST      R15,ARGSLST+44       ARGUMENT ADDRESS PARM LIST
*                                 SEVENTH - PART 2 - VAR TYPE
       LA      R15,=F'2'            LENGTH
       ST      R15,ARGLLST+48       LENGTH PARM LIST
       LA      R15,STRING           ARGUMENT
       ST      R15,ARGSLST+48       ARGUMENT ADDRESS PARM LIST
*                                 SEVENTH - PART 3 - VAR VALUE
       LA      R15,=F'80'           LENGTH
       ST      R15,ARGLLST+52       LENGTH PARM LIST
       LA      R15,VAR2VAL          ARGUMENT
       ST      R15,ARGSLST+52       ARGUMENT ADDRESS PARM LIST
*                                 SEVENTH - PART 3 - VAR VALUE
       MVC     ARGCNT,=F'14'      ARG COUNT (INCLUDING PGMNAME)
* end initialization
*---------------------------------------------------------------------*
*-                                                                   -*
*- LOOP:     ASCMODE=PRIMARY, IN-LINE ENTRY                          -*
*- Function: Main processing loop; watch for done and posted ECBs    -*
*- Operation:                                                        -*
*-     if done then exit                                             -*
*-     wait for ecb post (message, alert, or modify/stop)            -*
*-     if message ecb posted, call GETMSGS                           -*
*-     if alert ecb posted, call DOALERT                             -*
*-     if modify/stop ecb posted, call DOCIB                         -*
*-     go back to top of loop                                        -*
*-                                                                   -*
*---------------------------------------------------------------------*
LOOP   DS      0H                 main processing loop
       CLI     DONE,0             check for termination
       BZ      WAIT               no, do wait
       STORAGE RELEASE,           free dynamic storage                 X
               LENGTH=DYNL,                                            X
               ADDR=(R11)
       PR                         exit program
WAIT   DS      0H
       WAIT    ECBLIST=ECBS       wait for a message/alert/modify/stop
       L       R1,ECB             get msg ecb
       N       R1,=X'40000000'    check for post
       BZ      CKALRT             not set, check alert
       XC      ECB,ECB            clear message ecb
       BAL     R14,GETMSGS        process the message
CKALRT DS      0H
       L       R1,ALERT           get alert ecb
       N       R1,=X'40000000'    check for post
       BZ      CKCIB              not posted, check modify
       XC      ALERT,ALERT        clear alert ecb
       BAL     R14,DOALERT        process alert
CKCIB  DS      0H
       ICM     R1,15,COMCIBPT     get CIB pointer
       BZ      LOOP               no CIB, back to main loop
       BAL     R14,DOCIB          process the CIB (QEDIT takes care of X
                                  the ECB)
       B       LOOP               back to main loop
*---------------------------------------------------------------------*
*-                                                                   -*
*- GETMSGS:  BRANCH ENTERED ASCMODE=PRIMARY, sets ASCMODE=AR         -*
*- Function: process all messages queued to this console             -*
*- Operation:                                                        -*
*-     invoke MCSOPMSG in supervisor state                           -*
*-     when a message is returned (GOTMDB)                           -*
*-        loop through the mdb objects                               -*
*-          when general object, call GOTMDBG                        -*
*-          when control prog object, call GOTMDBC                   -*
*-          when text object, call GOTMDBT                           -*
*-          otherwise unknown object type                            -*
*-     when an error occurs in MCSOPMSG (GOTERR)                     -*
*-        put out error message                                      -*
*-        set done flag to exit program                              -*
*-     return to caller                                              -*
*-                                                                   -*
*---------------------------------------------------------------------*
       SYSSTATE ASCENV=P          let macros know primary mode
GETMSGS DS     0H
       BAKR    R14,0              save caller environment
MSGLP  DS      0H
       L       R8,CNID            load the console id in reg 8     @P4A
       LTR     R8,R8              is the id = 0 (ie was it             X
                                           deactivated?            @P4A
       BZ      LVGETM             then leave this proc - no msgs       X
                                           to receive              @P4A
       SAC     0                  set primary mode for modeset
       MODESET MF=(E,SUP)         set sup state
       SAC     512                this procedure runs in AR mode
       SYSSTATE ASCENV=AR         let macros know
       MCSOPMSG REQUEST=GETMSG,   get a message                        X
               NAME=CNAME,        my console name                  @P5CX
               RTNCODE=RC,        save return code                     X
               RSNCODE=RSN,       save reason code                     X
               MF=(E,MCSOPMPL)
       LAE     R8,0(0,R1)         put mdb address in R8
       USING   MDB,R8             addressability to the mdb
       SAC     0                  set primary mode for modeset
       SYSSTATE ASCENV=P          let macro know
       MODESET MF=(E,PROB)        set problem state
       SAC     512                this procedure runs in AR mode
       SYSSTATE ASCENV=AR         let macros know
       MVI     MDBFLGS,0          clear processing flags
       MVI     CMDRSP,0           assume not issuing command response
       LA      R15,8              looking for message returned
       C       R15,RC             see if any messages
       BH      GOTMDB             process it (rc<8)
       BL      GOTERR             some kind of error (rc>8)
       PR                         no more messages (rc=8)
GOTERR DS      0H
       LA      R1,BADGET          get error message
       BAL     R14,MESSR          show it
       MVI     DONE,1             set done flag
LVGETM EQU     *                  Exit point of GETMSGS            @P4A
       PR                         return error message
*---------------------------------------------------------------------*
*-                                                                   -*
*- GOTMDB:   ENTRY VIA BRANCH (NOT A SUBROUTINE)                     -*
*- Function: Process the general object and control program object   -*
*-           for a message.  Assumptions must not be made that these -*
*-           objects will preceed any text objects.                  -*
*- Operation:                                                        -*
*-     find end of MDB                                               -*
*-     loop through objects                                          -*
*-         when general object                                       -*
*-           call GOTMDBG to process general object                  -*
*-         when control program object                               -*
*-           call GOTMDBC to process control program object          -*
*-         otherwise ignore object                                   -*
*-       if both objects found, go process text objects              -*
*-       skip to next object                                         -*
*-         add object length                                         -*
*-         if end of MDB, this MDB does not have proper objects      -*
*-           to process as a message; just ignore it                 -*
*-                                                                   -*
*---------------------------------------------------------------------*
GOTMDB DS      0H
       LR      R5,R8              calc end of mbd in R5
       AH      R5,MDBLEN          start+mdblen in header
       LR      R6,R8              remember start of MDB for pass 2
       LA      R8,MDBHLEN(R8)     bump to 1st object
OBJLP  DS      0H                 loop through the objects
       LH      R3,MDBTYPE         get type
       C       R3,=A(MDBGOBJ)     check for general object
       BNE     NOTG               not general object
       TM      MDBFLGS,MDBFGO     see if first general object
       BO      NXTOBJ             no, skip it
       BAL     R14,GOTMDBG        process general object
       B       NXTOBJ             bump to next object
NOTG   DS      0H
       C       R3,=A(MDBCOBJ)     check for control prog object
       BNE     NOTC               not control prog object
       TM      MDBFLGS,MDBFCO     see if first control prog object
       BO      NXTOBJ             no, skip it
       BAL     R14,GOTMDBC        process control prog object
       B       NXTOBJ             bump to next object
NOTC   DS      0H                 not control prog obj
NXTOBJ DS      0H                 find next object
       TM      MDBFLGS,MDBFGO+MDBFCO see if we found general and SCP
       BO      FNDTXT             got them, loop through text objs
       AH      R8,MDBLEN          bump to next object
       CR      R8,R5              see if this is the end
       BL      OBJLP              no, get another object
       B       MSGLP              missing necessary objects, skip it
*---------------------------------------------------------------------*
*-                                                                   -*
*- FNDTXT:   ENTRY VIA BRANCH (NOT A SUBROUTINE)                     -*
*- Function: Process all text objects in all MDBs for this message.  -*
*-           Text objects are always ordered, but it cannot be       -*
*-           assumed that they are contiguous.                       -*
*- Operation:                                                        -*
*-     find end of MDB                                               -*
*-     get pointer to next MDB in message                            -*
*-     loop through MDBs                                             -*
*-        loop through objects                                       -*
*-            when text object                                       -*
*-              call GOTMDBT to process text object                  -*
*-            otherwise ignore object                                -*
*-          skip to next object                                      -*
*-            add object length                                      -*
*-            if end of MDB, move to next MDB                        -*
*-                                                                   -*
*---------------------------------------------------------------------*
FNDTXT DS      0H
       LR      R8,R6              reset R8 to start of MDB
TXTLP  DS      0H
       LR      R5,R8              calc end of mbd in R5
       AH      R5,MDBLEN          start+mdblen in header
       LAE     R6,0(0,R8)         calc prefix address in R6
       SH      R6,=AL2(MDBPLNNO)  prefix=start-prefix length
       USING   MDBPRFX,R6         get addressability
       L       R6,MDBPNEXT        get forward pointer in R6
       DROP    R6                 R6 no longer base for prefix
       LA      R8,MDBHLEN(R8)     bump to 1st object
TOBJLP DS      0H                 loop through the objects
       LH      R3,MDBTYPE         get type
       C       R3,=A(MDBTOBJ)     check for text object
       BNE     NOTT               not text object
       BAL     R14,GOTMDBT        process text object
NOTT   DS      0H
       AH      R8,MDBLEN          bump to next object
       CR      R8,R5              see if this is the end
       BL      TOBJLP             no, get another object
       LTR     R6,R6              check for more MDBs for message
       BZ      MSGLP              done with message
       LR      R8,R6              next mdb
       B       TXTLP              process the mdb
       DROP    R8
*---------------------------------------------------------------------*
*-                                                                   -*
*- GOTMDBG:  BRANCH ENTERED, ASCMODE=AR, R8=ADDR(general object)     -*
*- Function: process MDB general object                              -*
*- Operation:                                                        -*
*-     establish addressability to the general object                -*
*-     indicate general object processed                             -*
*-                                                                   -*
*---------------------------------------------------------------------*
       SYSSTATE ASCENV=AR         let macros know AR mode
GOTMDBG DS     0H
       BAKR    R14,0              save caller environment
       USING   MDBG,R8            addressability to general object
       OI      MDBFLGS,MDBFGO     set processed general object
       PR
       DROP    R8
*---------------------------------------------------------------------*
*-                                                                   -*
*- GOTMDBC:  BRANCH ENTERED, ASCMODE=AR, R8=ADDR(control prog object)-*
*- Function: process MDB control program object                      -*
*- Operation:                                                        -*
*-     establish addressability to the control program object        -*
*-     if this is an MVS object                                      -*
*-        set flag indicating control prog object found for the msg  -*
*-        save message text offset for text processing               -*
*-        if this is a command response message                      -*
*-           save the CART                                           -*
*-           indicate that the text echo should be command response  -*
*-                                                                   -*
*---------------------------------------------------------------------*
       SYSSTATE ASCENV=AR         let macros know AR mode
GOTMDBC DS     0H
       BAKR    R14,0              save caller environment
       USING   MDBSCP,R8          addressability to control prog object
       CLC     MDBCPNAM,=C'MVS '  make sure it is an MVS object
       BNE     GOTC1              if not, just skip it
       OI      MDBFLGS,MDBFCO     set processed control prog object
       LH      R1,MDBCTOFF        get text offset
       ST      R1,TOFF            save it for text processing
       TM      MDBCATT1,MDBCMCSC  check if command response
       BZ      GOTC1              not command response
       MVC     MCART,MDBCCART     hold onto cart
       MVI     CMDRSP,1           issue any WTOs as cmd response
GOTC1  DS      0H
       PR
       DROP    R8
*---------------------------------------------------------------------*
*-                                                                   -*
*- GOTMDBT:  BRANCH ENTERED, ASCMODE=AR, R8=ADDR(text object)        -*
*- Function: process MDB text objects                                -*
*- Operation:                                                        -*
*-     establish addressability to the text object                   -*
*-     calculate the length of the text                              -*
*-     move it to a buffer                                           -*
*-     set the length                                                -*
*-     issue text as a single line WTO                               -*
*-                                                                   -*
*---------------------------------------------------------------------*
       SYSSTATE ASCENV=AR         let macros know AR mode
GOTMDBT DS     0H
       BAKR    R14,0              save caller environment
       USING   MDBT,R8            addressability to text object
       LH      R1,MDBTLEN         get text object length
       S       R1,=A(MDBTMSGT-MDBTLEN) subtract non-text size
       S       R1,TOFF            take off offset to text
       C       R1,=A(L'WTOTXT)    make sure its not too long for buf
       BNH     GOTT1              ok
       L       R1,=A(L'WTOTXT)    not ok, truncate at buf length
GOTT1  DS      0H
       S       R1,=F'1'           set up for MVC
       LAE     R2,MDBTMSGT        get address of text
       A       R2,TOFF            bump past prefix info
       CLC     WTOID,0(R2)        see if this message is my echo
       BE      GOTTX              don't redisplay my text echo
*****************************************
*      7 character messages             *
*****************************************
* OPS001I  Manual SNMP trap issued by operations
       LA      R15,=F'8'            LENGTH
       ST      R15,ARGLLST+40       LENGTH PARM LIST
       LA      R5,8               message offset
*      CLC     0(7,R2),=CL7'OPS001I'
       CLC     0(8,R2),=CL8'OPS001I '
       BE      GOTT2              Yes, go process it
*****************************************
*      8 character messages             *
*****************************************
* DSNJ110E x LAST COPY x ACTIVE LOG DATA SET IS x PERCENT FULL
       LA      R15,=F'8'            LENGTH
       ST      R15,ARGLLST+40       LENGTH PARM LIST
       LA      R5,10              message offset
       CLC     0(8,R2),=CL8'DSNJ110E'  Q. DB2 message?
       BNE     NXTCHK             A. yes, process it          MAS120308
       CLI     48(R2),C' '        Q. >9% ?                    MAS120308
       BE      NXTCHK             A. no, ignore message       MAS120308
       mvi     temp,c'<'
       mvc     temp+1(2),47(r2)
       mvi     temp+3,c'>'
       PACK    TEMPPK,47(2,R2)    convert to packed decimal   MAS120308
       CP      TEMPPK,=PL2'24'    Q. >= 25% ?                 MAS120308
       BH      GOTT2              A. Yes, process message     MAS120308
NXTCHK DS      0H                                             MAS120308
*****************************************
*      9 character messages             *
*****************************************
       LA      R15,=F'9'            LENGTH
       ST      R15,ARGLLST+40       LENGTH PARM LIST
       LA      R5,10              message offset
* IGD17380I STORAGE GROUP (sgname) IS ESTIMATED AT xx% OF CAPACITY
       CLC     0(9,R2),=CL9'IGD17380I'
       BE      GOTT2              yes, process it
* DFHSM0131 applid CICS is under stress (short on storage below 16MB)
       CLC     0(9,R2),=CL9'DFHSM0131'
       BE      GOTT2              yes, process it
       CLC     1(9,R2),=CL9'DFHSM0131'
       BE      GOTT2              yes, process it
* DFHSM0133 applid CICS is under stress (short on storage above 16MB)
       CLC     0(9,R2),=CL9'DFHSM0133'
       BE      GOTT2              yes, process it
       CLC     1(9,R2),=CL9'DFHSM0133'
       BE      GOTT2              yes, process it
* DFHSM0102 applid A storage violation has been detected by...
       CLC     0(9,R2),=CL9'DFHSM0102'
       BE      GOTT2              yes, process it
       CLC     1(9,R2),=CL9'DFHSM0102'
       BE      GOTT2              yes, process it
* DFHSM0103 applid A storage violation has been detected by...
       CLC     0(9,R2),=CL9'DFHSM0103'
       BE      GOTT2              yes, process it
       CLC     1(9,R2),=CL9'DFHSM0103'
       BE      GOTT2              yes, process it
* ARKE*****: (A6G0  ) TIF ABEND T*** IN PROGRAM pppppppp
         CLC     0(4,R2),=CL4'ARKE'
         BNE     GOTTX              none of the above - get out
         MVC     VAR1VAL(L'VAR1VAL),BLANKS
         MVC     VAR2VAL(L'VAR2VAL),BLANKS
         LR      R6,R2              save msg pointer
         SR      R1,R5              take off offset to msg
         AR      R2,R5              point to message body
         EX      R1,GOTTMVC2        move text to buffer
         LA      R6,VAR2VAL         point to message buffer
         LR      R2,R1              length of message
         SH      R2,=H'15'          minus length of string plus some
         CH      R2,=H'11'          length less than string?
         BH      TIFLOOP            no, go check
         B       GOTTX              yes, can't be tif abend msg
TIFLOOP  DS      0H
         SAC     0                  run in primary mode
         SYSSTATE ASCENV=P          tell macros primary mode
         CLC     0(11,R6),=CL11'TIF ABEND T'  TIF abend message?
         BE      GOTT3              tif abend found, continue
         LA      R6,1(R6)
         BCT     R2,TIFLOOP         Do until all of message checked
         B       GOTTX              tif abend not found, get out
GOTT2    DS      0H
         MVC     VAR1VAL(L'VAR1VAL),BLANKS
         MVC     VAR2VAL(L'VAR2VAL),BLANKS
         LR      R6,R2              save msg pointer
         SR      R1,R5              take off offset to msg
         AR      R2,R5              point to message body
         CLI     0(R6),C'+'         + in front of message?
         BNE     GOTT2A               no, continue
         AH      R2,=H'1'             yes, point past it
         SH      R1,=H'1'               subtract 1 from length
         LA      R6,1(R6)           Point to true msgid
GOTT2A   DS      0H
         EX      R1,GOTTMVC2        move text to buffer
GOTT3    DS      0H
         S       R5,=F'2'           set up for MVC
         EX      R5,GOTTMVC1        put msgid in var1val
         BAL     R14,SENDTRP        go issue trap
GOTTX    DS      0H
         PR
GOTTMVC1 MVC     VAR1VAL(0),0(R6)   put msgid in var1val
GOTTMVC2 MVC     VAR2VAL(0),0(R2)   put msg in var2val
         DROP    R8
*---------------------------------------------------------------------*
*-                                                                   -*
*- DOALERT:  BRANCH ENTERED ASCMODE=PRIMARY, sets ASCMODE=AR         -*
*- Function: process a console alert notification                    -*
*- Operation:                                                        -*
*-     establish addressability the the console status area          -*
*-     check each alert indicator                                    -*
*-       if set, put out a message                                   -*
*-     no error handling is performed this example, just             -*
*-      deactivate the console on any alert                          -*
*-                                                                   -*
*---------------------------------------------------------------------*
DOALERT DS     0H
       BAKR    R14,0              save caller environment
       SAC     512                get into AR mode
       SYSSTATE ASCENV=AR         let macros know
       L       R2,CSA             get address of the status area
       LAM     R2,R2,CSAALET      get ALET for status area
       USING   MCSCSA,R2          establish addressability
       CLI     MCSCMLIM,0         reached memory limit?
       BZ      ALRT1              no
       LA      R1,MSGMLIM         get error message
       BAL     R14,MESSR          display it
ALRT1  DS      0H
       CLI     MCSCDLIM,0         reached queue limit?
       BZ      ALRT2              no
       LA      R1,MSGDLIM         get error message
       BAL     R14,MESSR          display it
ALRT2  DS      0H
       CLI     MCSCINTR,0         internal error?
       BZ      ALRT3              no
       LA      R1,MSGINTR         get error message
       BAL     R14,MESSR          display it
ALRT3  DS      0H
       CLI     MCSCALRT,0         reached alert percent?
       BZ      ALRT4              no
       LA      R1,MSGALRT         get error message
       BAL     R14,MESSR          display it
ALRT4  DS      0H
       LA      R1,ALRMSG          get alert message
       BAL     R14,MESSR          display it
       BAL     R14,DEACT          deactivate console
       PR
*---------------------------------------------------------------------*
*-                                                                   -*
*- DOCIB:    BRANCH ENTERED ASCMODE=PRIMARY                          -*
*- Function: process all CIBs queued to this job                     -*
*- Operation:                                                        -*
*-     loop while there are CIBs                                     -*
*-        when modify CIB                                            -*
*-           save requesting console id                              -*
*-           when activate command                                   -*
*-              invoke MCSOPER to activate the console               -*
*-              display acknowledgement or error                     -*
*-           when deactivate command                                 -*
*-              invoke MCSOPER to deactivate the console             -*
*-              display acknowledgement or error                     -*
*-        when stop CIB                                              -*
*-           set done indicator                                      -*
*-        delete the CIB                                             -*
*-     return to caller                                              -*
*-                                                                   -*
*---------------------------------------------------------------------*
       SYSSTATE ASCENV=P          let macros know primary mode
DOCIB  DS      0H
       BAKR    R14,0              save caller environment
       MVI     CMDRSP,1           issue WTOs as command response
CIBLP  DS      0H
       ICM     R7,15,COMCIBPT     get address of the CIB
       BNZ     SVINFO             got one, check the CIB type
       MVI     CMDRSP,0           turn off cmd response flag
       PR                         no, return to caller
       USING   CIB,R7             CIB based on R7
SVINFO DS      0H
       LR      R1,R7              get consid and CART from CIBX
       AH      R1,CIBXOFF         CIBX=addr(CIB)+CIBXOFF
       USING   CIBX,R1            get addressability
       MVC     MYOPER,CIBXCNID    get console id that I will talk to
       MVC     MCART,CIBXCART     keep CART for a cmd response
       DROP    R1                 done with CIBX
       CLI     CIBVERB,CIBMODFY   check for modify
       BNE     CKSTOP             no, try stop
       CLC     MSGID,=F'0'        do I have a message to be DOMed
       BE      DOFCMD             no
       DOM     MSG=MSGID          DOM it
       XC      MSGID,MSGID        clear held message id
DOFCMD DS      0H
       LH      R3,CIBDATLN        get text length in R3
       C       R3,=A(L'CMDACT)    check cmd length
       BL      NOTACT             too short
       CLC     CMDACT(L'CMDACT),CIBDATA  check text
       BNE     NOTACT             not activate
       L       R1,CNID            see if I have a console active
       LTR     R1,R1              any id?
       BNZ     ISACT              yes, don't activate another
       MVC     CNAME,=C'NIMBUS  ' default name if none supplied
       LA      R2,L'CMDACT+1      R2-->past activate command
       SR      R3,R2              remaining chars in command
       BNP     CHKNM              no console name provided
       C       R3,=F'8'           no more than 8 chars in console name
       BH      CHKNM              too much text for name - ignore it
       MVC     CNAME,=CL8' '      start with a blank name field
       LA      R2,CIBDATA(R2)     get address of name in the cib
       S       R3,=F'1'           calc move length
       EX      R3,MOVECN          do the move
       B       CHKNM              see if it is already active
MOVECN DS      0H
       MVC     CNAME(0),0(R2)     this move instruction is EX'ed
CHKNM  DS      0H                 check if console active using convcon
       XC      CONV(CONVPLEN),CONV clear convcon parm list
       MVC     CONVACRO,=C'CONV'  set acronym
       MVI     CONVVRSN,CONVRID   set version
       OI      CONVFLGS,CONVPFLD  set name to id conversion
       MVC     CONVFLD,CNAME      set console name
       OI      CONVGFLG,CONVNPAR  set no area verification
       CONVCON CONV               call convcon
       LTR     R15,R15            check rc
       BNZ     DOACT              branch if not active
ISACT  DS      0H
       LA      R1,DIDACT          error, console already active
       BAL     R14,MESSR          show message
       B       DELCIB             delete CIB
DOACT  DS      0H
       LA      R1,OPERPRM         build operparm defaults
       USING   MCSOPPRM,R1        map area
       XC      OPERPRM(MCSOPLEN),OPERPRM clear operparm parm list
       MVI     MCSOAUTH,MCSOMSTR  set master authority
       MVI     MCSORCFL,MCSORCAL  all route codes
       MVC     MCSOKEY,=C'EXAMPLE ' set key
       MODESET MF=(E,SUP)         set sup state to activate console
       MCSOPER REQUEST=ACTIVATE,  activate the console                 X
               NAME=CNAME,        activate name found in CNAME         X
               TERMNAME=CNAME,    use CNAME for the termname audit     X
               OPERPARM=OPERPRM,  use my OPERPARMs if none in RACF     X
               MSGDLVRY=FIFO,     request fifo delivery                X
               MSGECB=ECB,        ecb to be posted when msg is queued  X
               ALERTECB=ALERT,    ecb to be posted when alert occurs   X
               MCSCSA=CSA,        returned status area address         X
               MCSCSAA=CSAALET,   returned status area alet            X
               CONSID=CNID,       returned console id                  X
               RTNCODE=RC,        save return code                     X
               RSNCODE=RSN,       save reason code                     X
               MF=(E,MCSOPPL)
       MODESET MF=(E,PROB)        back to problem state
       ICM     R15,15,RC          get return code
       BNZ     ACTERR             if non-zero, process error
       LA      R1,NOWACT          now active message
       BAL     R14,MESSR          display it
       B       DELCIB             done with CIB
ACTERR DS      0H
       LA      R1,BADINI          console initialization error
       BAL     R14,MESSR          display message
       B       DELCIB             done with CIB
NOTACT DS      0H
       C       R3,=A(L'CMDDACT)   check for deactivate command
       BL      NOTDACT            bad length
       CLC     CMDDACT(L'CMDDACT),CIBDATA check text
       BNE     NOTDACT            not deactivate command
       BAL     R14,DEACT          deactivate console
       B       DELCIB             done with CIB
NOTDACT DS     0H                 not my command, issue it as MGCRE
       MODESET MF=(E,SUP0)        sup state, key 0 for SVC34
       LA      R2,CIBDATLN        get address of length field
       MGCRE   TEXT=(R2),         point text to CIB data length field  X
               CONSID=CNID,       issue from my console                X
               CART=MCART,        use input CART to correlate response X
               MF=(E,MGCREPL)     list form in MGCREPL
       MODESET MF=(E,PROB)        back to problem state, key
       B       DELCIB             done with CIB
CKSTOP DS      0H
       CLI     CIBVERB,CIBSTOP    check for stop CIB
       BNE     CKSTRT             not stop either
       MVI     DONE,1             signal done
       ICM     R1,15,CNID         get console id
       BZ      DELCIB             the console is not active
       BAL     R14,DEACT          deactivate it
       B       DELCIB             done with CIB
CKSTRT DS      0H
       CLI     CIBVERB,CIBSTART   check for start CIB
       BNE     DELCIB             CIB not used by this prog
       MVI     STRTD,1            this is a started task
DELCIB DS      0H
       QEDIT   ORIGIN=COMCIBPT,                                        X
               BLOCK=(R7)         free the CIB
       B       CIBLP              go look for another
*---------------------------------------------------------------------*
*-                                                                   -*
*- DEACT:     BRANCH ENTERED, SETS ASCMODE=PRIMARY                   -*
*- Function:  deactivate the console                                 -*
*- Operation:                                                        -*
*-     save caller state                                             -*
*-     set sup state for MCSOPER deactivate                          -*
*-     if rc is 0 then                                               -*
*-        set current console id to 0 (CNID)                         -*
*-        display console deactivated message                        -*
*-      else                                                         -*
*-        display deactivation error message                         -*
*-                                                                   -*
*---------------------------------------------------------------------*
DEACT  DS      0H
       BAKR    R14,0              save caller state
       SAC     0                  runs in primary mode
       SYSSTATE ASCENV=P          tell macros
       MODESET MF=(E,SUP)         set sup state
       MCSOPER REQUEST=DEACTIVATE,                                     X
               NAME=CNAME,        deactivate the console           @P5CX
               RTNCODE=RC,        save return code                     X
               RSNCODE=RSN,       save reason code                     X
               MF=(E,MCSOPPL)
       MODESET MF=(E,PROB)        set problem state
       ICM     R15,15,RC          get return code
       BNZ     DACTERR            if non-zero, process error
       XC      CNID,CNID          zero console id to show not active
       LA      R1,NOWDACT         get not active message
       BAL     R14,MESSR          display it
       PR                         return
DACTERR DS     0H
       LA      R1,BADDACT         deactivate error
       BAL     R14,MESSR          display message
       PR                         return
*---------------------------------------------------------------------*
*-                                                                   -*
*- MESSR:     BRANCH ENTERED, R1=ADDR(message), SETS ASCMODE=PRIMARY -*
*- Function:  display a message                                      -*
*- Operation:                                                        -*
*-       does a WTO of the message passed as the parameter           -*
*-                                                                   -*
*---------------------------------------------------------------------*
MESSR  DS      0H
       BAKR    R14,0              save caller environment
       SAC     0                  run in primary mode
       SYSSTATE ASCENV=P          tell macros primary mode
       LR      R2,R1              use R2 for text in WTO
       CLI     CMDRSP,1           check for command response
       BE      MESSRC             yes, issue as cmd response
       WTO     TEXT=(R2),         display message                      X
               MF=(E,WTOPL)
       PR                         return to caller
MESSRC DS      0H
       WTO     TEXT=(R2),         display message                      X
               CONSID=MYOPER,                                          X
               CART=MCART,                                             X
               MF=(E,WTOPLCR)
       PR                         return to caller
*---------------------------------------------------------------------*
*-                                                                   -*
*- SENDTR:    BRANCH ENTERED, R1=ADDR(message), SETS ASCMODE=PRIMARY -*
*- Function:  Issue SNMP trap                                        -*
*- Operation:                                                        -*
*-       send an snmp trap with the msgid as variable 1 and the      -*
*-       message body as variable 2                                  -*
*-                                                                   -*
*---------------------------------------------------------------------*
SENDTRP DS      0H
       BAKR    R14,0             save caller environment
       SAC     0                 run in primary mode
       SYSSTATE ASCENV=P         tell macros primary mode
       MVC     WTOTXT(L'MSG14),MSG14 initialize wto message
       MVC     WTOTXT(7),=C'BPX1ATX' save function to error msg
       MVC     WTOID(8),=CL8'WJS014E' save msg id
       LA      R1,WTOLEN
       STH     R1,WTOBUF
       MVC     ENVCNT,=F'0'       NUMBER OF ENV. DATA ITEMS PASSED
       MVC     ENVLENS,=F'0'      ADDR OF ENV. DATA LENGTH LIST
       MVC     ENVPARMS,=F'0'     ADD OF ENV. DATA
       MVC     EXITRTNA,=F'0'     ->EXIT ROUTINE
       MVC     EXITPLA,=F'0'      ->EXIT PARAMETER LIST
       OI      RSNCODE,X'80'      Signal end of parameter list
BPX1ATX DS      0H
       CALL    BPX1ATX,                                                +
               (BUFLENA,          input: pathname length               +
               BUFFERA,           input: pathname                      +
               ARGCNT,            input: argument count                +
               ARGLLST,           input: argument length list          +
               ARGSLST,           input: argument addr LIST            +
               ENVCNT,            input: environment count             +
               ENVLENS,           input: environment length list       +
               ENVPARMS,          input: environment addr list         +
               EXITRTNA,          input: exit routine addr OR 0        +
               EXITPLA,           input: exit parm list addr OR 0      +
               RETVAL,            return value: child PID or -1        +
               RETCODE,           return code                          +
               RSNCODE),          reason code                          +
               VL,MF=(E,PLIST)    --------------------------------
       L       R15,RETVAL         Load return value
       C       R15,=F'-1'         test for -1 return
       BE      BADBPX             -1 is error
BPX1WAT  DS    0H
*                                 -waitpid------------------------
       LA      R15,WAST           resolve address of status
       ST      R15,WASTA          save address of status
       MVC     PROCID,RETVAL      wait for attached child
       MVC     WAITOPT,=F'0'      no options (just wait)
       SPACE   ,
       MVC     WTOTXT(7),=C'BPX1WAT' save function to error msg
       CALL    BPX1WAT,           wait for a child process to end      +
               (PROCID,           input: PID being waited on           +
               WAITOPT,           input: options       BPXYCONS        +
               WASTA,             ->exit status field, BPXTWAST        +
               RETVAL,            return value: -1, 0, child PID       +
               RETCODE,           return code                          +
               RSNCODE),          reason code                          +
               VL,MF=(E,PLIST)    --------------------------------
       L       R15,RETVAL         load return value
       C       R15,=F'-1'         test for -1 return
       BE      BADBPX             -1 is error
BPX1MPC DS      0H
*                                 -mvsprocclp---------------------
       XC      WAST(WAST#LENGTH),WAST clear
       MVI     WASTEXITCODE,57    user defined exit code
       SPACE   ,
       MVC     WTOTXT(7),=C'BPX1MPC' save function to error msg
       CALL    BPX1MPC,           mvs process cleanup                  +
               (WAST,             input: ending status code 0-255      +
               RETVAL,            return value: 0, -1 or 1             +
               RETCODE,           return code                          +
               RSNCODE),          reason code                          +
               VL,MF=(E,PLIST)    --------------------------------
       L       R15,RETVAL         load return value
       C       R15,=F'-1'         test for -1 return
       BE      BADBPX             if -1, then go complain
       SAC     512                run in primary mode
       SYSSTATE ASCENV=AR         tell macros primary mode
       PR                         return to caller
BADBPX DS    0H
       MVC     TEMP(4),RETVAL     save it
       UNPK    TEMP2(9),TEMP(5)   make it viewable
       TR      TEMP2(8),TABLE     all of it
       MVC     WTOTXT+ORETVAL(8),TEMP2
       MVC     TEMP(4),RETCODE    save it
       UNPK    TEMP2(9),TEMP(5)   make it viewable
       TR      TEMP2(8),TABLE     all of it
       MVC     WTOTXT+ORETCODE(8),TEMP2  move to wto
       MVC     TEMP(4),RSNCODE    save it
       UNPK    TEMP2(9),TEMP(5)   make it viewable
       TR      TEMP2(8),TABLE     all of it
       MVC     WTOTXT+ORSNCODE(8),TEMP2  MOVE TO WTO
       LA      R1,WTOBUF          UNIX sys srvc error
       SAC     512                run in primary mode
       SYSSTATE ASCENV=AR         tell macros primary mode
       BAL     R14,MESSR          display message
       PR                         return to caller
*---------------------------------------------------------------------*
*- messages                                                          -*
*---------------------------------------------------------------------*
BADINI  DC     AL2(L'MSG0)
MSG0    DC     C'WJS000I ERROR ACTIVATING CONSOLE'
BADGET  DC     AL2(L'MSG1)
MSG1    DC     C'WJS001I ERROR TRYING TO GET A MESSAGE'
DIDACT  DC     AL2(L'MSG2)
MSG2    DC     C'WJS002I CONSOLE IS ALREADY ACTIVE'
NOWACT  DC     AL2(L'MSG3)
MSG3    DC     C'WJS003I CONSOLE HAS BEEN ACTIVATED'
NOWDACT DC     AL2(L'MSG5)
MSG5    DC     C'WJS005I CONSOLE HAS BEEN DEACTIVATED'
BADDACT DC     AL2(L'MSG6)
MSG6    DC     C'WJS006I ERROR DEACTIVATING CONSOLE'
ALRMSG  DC     AL2(L'MSG7)
MSG7    DC     C'WJS007I ALERT DETECTED - DEACTIVATING CONSOLE'
INITMSG DC     AL2(L'MSG8)
MSG8    DC     C'WJS008I NOW ACCEPTING MODIFY COMMANDS'
MSGMLIM DC     AL2(L'MSG9)
MSG9    DC     C'WJS009I CONSOLE QUEUEING STOPPED DUE TO MEMORY LIMIT'
MSGDLIM DC     AL2(L'MSG10)
MSG10   DC     C'WJS010I CONSOLE QUEUEING STOPPED DUE TO DEPTH LIMIT'
MSGINTR DC     AL2(L'MSG11)
MSG11   DC     C'WJS011I INTERNAL SYSTEM ERROR ON CONSOLE'
MSGALRT DC     AL2(L'MSG12)
MSG12   DC     C'WJS012I RECEIVED QUEUE DEPTH ALERT'
INITMS2 DC     AL2(L'MSG13)
MSG13   DC     C'WJS013I WAITING FOR FIRST COMMAND'
MSG14   DC     C'        : RETVAL=        , RETCODE=        , RSNCODE= X
                      '
*---------------------------------------------------------------------*
*- static variables                                                  -*
*---------------------------------------------------------------------*
CMDACT   DC    C'ACTIVATE'        activate command
CMDDACT  DC    C'DEACTIVATE'      deactivate command
PROGRAM  DC    CL6'awtrap'
HOST1    DC    CL2'-h'
DESTIP   DC    CL13'159.178.31.55'
COMM1    DC    CL2'-c'
COMM2    DC    CL9'shandstss'
TRAPOID  DC    CL19'1.3.6.1.4.1.15037.6.3'
VAR1OID  DC    CL21'1.3.6.1.4.1.15037.1.2.6'
VAR2OID  DC    CL21'1.3.6.1.4.1.15037.1.2.7'
TYPE     DC    CL1'6'
SUBTYPE  DC    CL2'15'
STRING   DC    CL2'-s'
PLIST    CALL  ,(,,,,,,,,,,,,),VL,MF=L
ORETVAL  EQU   17
ORETCODE EQU   17+18
ORSNCODE EQU   17+18+18
BLANKS   DC    CL80' '
TABLE    EQU   *-240
         DC    C'0123456789ABCDEF'
        LTORG
*---------------------------------------------------------------------*
*- dynamic area model                                                -*
*---------------------------------------------------------------------*
DYNMODEL DS    0F
ECBS    DS     0CL12              ecb list for wait
MECB    DS     A                    addr(message ecb)
AECB    DS     A                    addr(alert ecb)
MODECB  DS     A                    addr(modify/stop ecb)
CNID    DC     F'0'               console id
CSA     DS     A                  addr(mcscsa)
CSAALET DS     F                  alet(mcscsa)
ECB     DC     F'0'               message ecb
ALERT   DC     F'0'               alert ecb
COMADDR DS     F                  addr(comarea) from extract
RC      DS     F                  return code from mcsoper/mcsopmsg
RSN     DS     F                  reason code from mcsoper/mcsopmsg
MYOPER  DS     F                  console id from last modify command
MSGID   DC     F'0'
OPERPRM DS     CL(MCSOPLEN)       OPERPARMs area
MCART   DS     CL8                CART from message or CIB
CNAME   DS     CL8                console name to activate
        DC     CL2'  '            space for area id on convcon
SV      DS     18F                save area
BUFLENA  DS    F
ARGCNT   DS    F
ARGLLST  DS    14A
ARGSLST  DS    14A
ENVCNT   DS    F
ENVLENS  DS    F
ENVPARMS DS    F
EXITRTNA DS    A
EXITPLA  DS    A
RETVAL   DS    F
RETCODE  DS    F
RSNCODE  DS    F
PROCID   DS    F                Process ID
WASTA    DS    A                ->BPXYWAST
WAITOPT  DS    A                WAIT OPTIONS
TOFF     DS    F                offset to message in text object
MOFF     DS    F                offset to msg body in text object
DONE     DC    FL1'0'           done flag
MDBFLGS  DC    FL1'0'           mdb flags
BUFFERA  DS    CL256
VAR1VAL  DS    CL9              VARIABLE1 VALUE (MSGID)
VAR2VAL  DS    CL80             VARIABLE2 VALUE (MSG)
TEMPPK   DS    PL2
TEMP     DS    CL5
TEMP2    DS    CL9
MDBFGO   EQU   X'01'            processed general object
MDBFCO   EQU   X'02'            processed control prog object
CMDRSP   DC    FL1'0'           command response flag
STRTD    DC    FL1'0'           indicator that this was started task
         DS    0H
WTOBUF   DS    FL2              length for dynamic messages
WTOID    DS    CL8              messge id for echoed messages
WTOTXT   DS    CL118            message text
WTOLEN   EQU   *-WTOBUF
         EJECT
WTOPL   WTO    TEXT=,             WTO parameter list                   X
               DESC=(7),                                               X
               MF=L
WTOPLCR WTO    TEXT=,             WTO parameter list for cmd response  X
               CONSID=,                                                X
               CART=,                                                  X
               DESC=(5,7),        descriptor code 5 is cmd response    X
               MF=L
WTOHOLD WTO    TEXT=,             WTO parameter list to hold msgs      X
               DESC=(3,7),                                             X
               MF=L
        EJECT
MGCREPL MGCRE  MF=(L)             MGCRE parameter list
        EJECT
SUP     MODESET MODE=SUP,MF=L     MODESET parm list for sup state
SUP0    MODESET MODE=SUP,                                              X
               KEY=ZERO,MF=L      MODESET parm list for sup, key 0
PROB    MODESET MODE=PROB,                                             X
               KEY=NZERO,MF=L MODESET parm list for problem state
EXTRACT EXTRACT MF=L              EXTRACT parameter list
        EJECT
        IEZVG200 DSECT=NO         CONVCON parameter list
        EJECT
        MCSOPER MF=(L,MCSOPPL)    MCSOPER parameter list
        EJECT
        MCSOPMSG MF=(L,MCSOPMPL),PLISTVER=2 MCSOPMSG Parm List     @P5C
        BPXYWAST DSECT=NO         Status word for wait
DYNL    EQU    *-DYNMODEL         dynamic area length
*---------------------------------------------------------------------*
*- required DSECTs                                                   -*
*---------------------------------------------------------------------*
        EJECT
        CVT DSECT=YES
        EJECT
        IEAVG132 ,                mdb prefix
        EJECT
        IEAVM105 ,                mdb
        EJECT
        IEAVG131 ,                console status area
        EJECT
        IEZVG111 ,                operparm parameter area
        EJECT
COM     DSECT
        IEZCOM   ,                COM area
        EJECT
CIB     DSECT
        IEZCIB   ,                CIB and CIBX
        IEZVX100
        BPXYCONS ,                OS/390 UNIX CONSTANTS
*---------------------------------------------------------------------*
*- register usage                                                    -*
*---------------------------------------------------------------------*
R1      EQU    1                  work and parm reg
R2      EQU    2                  work reg
R3      EQU    3                  work reg
R4      EQU    4                  work reg
R5      EQU    5                  pointer to end of the mdb
R6      EQU    6                  next mdb pointer
R7      EQU    7                  base for CIB
R8      EQU    8                  base for mdb and mdb objects
R9      EQU    9                  base for com area
R11     EQU    11                 dynamic storage base
R12     EQU    12                 module base
R13     EQU    13                 linkage
R14     EQU    14                 linkage
R15     EQU    15                 linkage
        END
//L.SYSLMOD DD DSN=OSS.PROD.ASM.LOAD,DISP=SHR
//L.SYSLIB DD  DSN=SYS1.CSSLIB,DISP=SHR
//L.SYSIN  DD  *
    NAME NIMBEMCS(R)
