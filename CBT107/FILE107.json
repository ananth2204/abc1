{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011240000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2057510, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 23, "INMDSNAM": "CBT.V500.FILE107.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2057510, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2057510, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE107.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00!\\x16'", "DS1TRBAL": "b'\\x02d'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x00\\xb3\\x00\\x05\\x00\\xb5\\x00\\x08\\x00\"'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$DOC": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\"O\\x01\\x00\"O\\x15 \\x00\\x12\\x00\\x12\\x00\\x00\\xc1\\xd9\\xd5\\xc9\\xc5@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-08-11T00:00:00", "modifydate": "2000-08-11T15:20:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "ARNIE"}, "text": "THIS MEMBER WAS ADDED BY CBT AND CONTAINS INFORMATION OF WHAT I\nRECEIVED FROM JIM BLALOCK OF CLEMSON UNIVERSITY\n\nTHESE TWO FILES CONTAIN THE CLEMSON UNIVERSITY STRUCTURED MACRO LIBRARY\nAND A SAMPLIB CONTAINING STRUCTURED MACRO EXAMPLES. THE MACRO LIBRARY\nCONTAINS TWO DOC MEMBERS $USERGDE AND $INTRNLS. IF THE USER HAS IBM'S\nDCB AND GML PRODUCTS, THESE WILL PRODUCE FULL-BLOWN MANUALS; OTHERWISE,\nSOME CREATIVE EDITING IS IN ORDER TO MAKE USABLE DOCUMENTATION.\n\nTHE SAMPLIB CONTAINS SAMPLE JCL PROCS, THE SOURCE FOR A 'PREPROCESSOR'\nTHAT VALIDITY-CHECKS YOUR SOURCE (TO INSURE THAT YOUR IF'S LINE UP WITH\nENDIF'S ETS) BEFORE RUNNING THE ASSEMBLER, AS WELL AS SEVERAL SAMPLE\nPROGRAMS THAT DEMONSTRATE THINGS THAT THE MACROS HELP YOU WITH (LIKE\nREENTRANCY AND AMODE SWITCHING). THERE'S ALSO A 'COMMENTS' CLIST THAT\nWILL CREATE COMMENT 'BOXES' FOR DIFFERENT TYPES OF CODE BLOCKS.\n\n               ARNOLD CASINGHINO\n               MARCH 27, 1989\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$README": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00\\x15\\x00\\x15\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "CLEMSON"}, "text": "\n                 Copyright Clemson University, 1989\n\n    The materials contained in this package are provided for general\n    use by Clemson University.  Although the package has been tested\n    to Clemson University's satisfaction for the purpose for which\n    it was intended, no warranty, expressed or implied, is made by\n    Clemson University as to the accuracy and functioning of the\n    program(s) and related materials.  Clemson University assumes no\n    liability for any damage that may be caused by any use of this\n    package.\n\n    The materials contained in this package are distributed on an\n    'as-is' basis.  Clemson University is under no obligation to\n    maintain or upgrade this package, nor is Clemson University\n    under any obligation to furnish assistance or additional\n    materials.\n\n    By use of this package, the organization agrees to acknowledge\n    Clemson University as the originator of the package.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$INTRNLS": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\"O\\x01\\x00\"O\\x15 \\x07~\\x07~\\x00\\x00\\xd6\\xd3\\xc4\\xc3\\xd3\\xc5\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-08-11T00:00:00", "modifydate": "2000-08-11T15:20:00", "lines": 1918, "newlines": 1918, "modlines": 0, "user": "OLDCLEM"}, "text": ".*\n.* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n.* <<<<<<<<<<<<<<<<<<<<<<<<<<  NOTE   >>>>>>>>>>>>>>>>>>>>>>>>>>>\n.*  This file is part of the PRINTDOC system.  If this file is\n.*   moved or if its formatting characteristics change, the PRINTDOC\n.*   systems will have to be updated.\n.*\n.*  If this file is updated, please change ACS.PRINTDOC.INDEX(MANUALS)\n.*   to reflect the new revision date.  This allows users to know\n.*   when they should print a new copy.\n.* <<<<<<<<<<<<<<<<<<<<<<<<<<  NOTE   >>>>>>>>>>>>>>>>>>>>>>>>>>>\n.* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n.*\n.*  This is the Structured Macros Internals Guide\n.*  coded to use GML tags.  It should be invoked with options\n.*  PASS(2) SYSVAR('D YES T CENTER H YES') SEC(32) LINES(16)\n.*\n:gdoc.\n:frontm.\n.ti ! 05\n.tr _ &\n.dh 0 spbf 4.5i\n.rc 1\n.rc 2 |\n.se @bodyhead1 = 'Chapter'\n.df figfont list (xmpfont)\n:titlep.\n:title stitle='Clemson Structured Macros'.\nClemson University Computer Center\n:title.Structured Programming Macros\n:title.Internals\n:date.\n:author.Last revision: October 1, 1987\n:etitlep.\n:toc.\n:preface.\n:p.\nThe Structured Programming Macros is a programming tool\ndeveloped at Clemson University for internal use by the\nstaff of the Computer Center.  However, after they were\nwritten, the decision was made to release them to the public\nsince they are very useful to anyone who is programming in\nSystem/370 Assembler language.\n:p.\nThe manual contains information about the internals of these\nmacros.  There is also some useful information on internals\ncontained in the appendixes of the :q.Clemson University\nComputer Center Structured Programming Macros User's Guide\nand Reference:eq. including the PWA layout, the SWA layout\nand information on macro register usage.\n:p.\n:body.\n.se @stitle 'Structured Macros Internals\n.*\n:h1 id=condexp.Conditional Expressions\n:p.\nConditional expressions can be coded on the\nELSEIF, ENDLOOP, ERREXIT, IF, LEAVE and LOOP macros.\nAll of these macros call internal macro ##COND to evaluate\nthe conditional expression.\n:p.\nMacro ##COND is described in :hdref refid=cond..  ##COND\nexpects a conditional expression, a tag to branch to if the\nexpression is false, a tag to branch to if the condition is true\nand a :q.logic flag:eq..\n:p.\nThis logic flag indicate whether the code following the ##COND\nmacro will be executed if the condition is true or if it is false.\nIf LOGIC=P is specified on ##COND, the :q.last branch:eq. generated\nby ##COND will be to the :q.success code:eq..  As an example, the\nERREXIT macro uses positive (P) logic because if the condition is true,\nyou want to branch to the error exit.  If LOGIC=N is specified (negative\nlogic), the :q.last branch:eq. generated will be to the :q.fail tag:eq..\nThe IF macro uses negative logic because it wants to :q.fall through:eq.\nto the success code if the condition is true.\n:figref refid=logicfg. illustrates the difference between positive and\nnegative logic.\n:fig id=logicfg frame=box place=inline.\n.fo off\n.sp 2\n    IF (CLC,A,EQ,B)               IF uses negative logic\n+           CLC   A,B\n+           BNE   (fail tag)      Branch to fail tag\n      ... instructions to execute if condition is true ...\n    ENDIF\n+(fail tag) DS    0H\n.sp 2\n    ERREXIT (CLC,A,EQ,B)          ERREXIT uses postive logic\n+            CLC   A,B\n+            BE    (errexit tag)  Branch to success tag\n.sp 2\n:figcap.Positive and negative logic\n:efig.\n:p.\n##COND must be supplied with both a fail and success tag no matter\nwhich type of logic is specified.  These fail and success tags are\nused when generating code for ORs and ANDs.\n:figref refid=orand. shows one simple example of when both tags are\nused.\n:fig id=orand frame=box place=inline.\n.fo off\n.sp 2\n    IF (CLC,A,EQ,B),OR,(CLC,C,EQ,D)\n+              CLC   A,B\n+              BE    (success tag)   Branch to success tag\n+              CLC   C,D\n+              BNE   (fail tag)      Branch to fail tag\n+(success tag) DS    0H\n      ... instructions to execute if condition is true ...\n    ENDIF\n+(fail tag)    DS    0H\n.sp 2\n:figcap.Using both a success and a fail tag\n:efig.\n:h1 id=proepi.Prolog and Epilog Macros\n:p.\nThe BLOCK, ENDBLK, PWA, ENDPWA, SWA and ENDSWA macros are\nstructured so that multiple environments can be supported.\nThese macros do a little housekeeping and call another\n:q.expansion macros:eq. to do the bulk of the work.  The\nnames of the expansion macros to be called can be supplied\nby the EXPMAC= keyword on each the above mentioned macros, or\nthey can be determined by a macro called ##$xxx where :q.xxx:eq. is the\nvalue of the ENVIRON= keyword on the program block macro.\n:p.\nThe ##$xxx macro is by far, the preferred way of supplying the\nexpansion macros name.  In fact, the EXPMAC= keyword is not\neven documented in the user's guide.\n:figref refid=expmac. contains a sample ##$xxx macro.\n:fig id=expmac frame=box place=inline.\n.fo off\n.sp 2\n         MACRO\n         ##$xxx\n         GBLC  _#PPMAC,_#PEMAC,_#EPMAC,_#EEMAC\n         GBLC  _#SPMAC,_#SEMAC,_#IPMAC,_#IEMAC\n         GBLC  _#WPMAC,_#WEMAC,_#UPMAC,_#UEMAC\n_#PPMAC  SETC  '##PPOS'          PROGRAM BLOCK PROLOG MACRO NAME\n_#PEMAC  SETC  '##PEOS'          PROGRAM BLOCK EPILOG MACRO NAME\n_#EPMAC  SETC  '##EPSTD'         ERREXIT BLOCK PROLOG MACRO NAME\n_#EEMAC  SETC  '##EESTD'         ERREXIT BLOCK EPILOG MACRO NAME\n_#SPMAC  SETC  '##SPSTD'         SUBROUTINE BLOCK PROLOG MACRO\n_#SEMAC  SETC  '##SESTD'         SUBROUTINE BLOCK EPILOG MACRO\n_#IPMAC  SETC  '##IPSTD'         INLINE BLOCK PROLOG MACRO NAME\n_#IEMAC  SETC  '##IESTD'         INLINE BLOCK EPILOG MACRO NAME\n_#WPMAC  SETC  '##WPOS'          PWA PROLOG MACRO NAME\n_#WEMAC  SETC  '##WESTD'         PWA EPILOG MACRO NAME\n_#UPMAC  SETC  '##UPSTD'         SWA PROLOG MACRO NAME\n_#UEMAC  SETC  '##UESTD'         SWA EPILOG MACRO NAME\n         MEND\n.sp 2\n:figcap.Sample ##$xxx macro\n:efig.\n:p.\nNew expansion macros can be written to support other\nenvironments.  For example, macros could be written to\nsupport the JES2 or CICS environments.  Writing these\nexpansion macros requires a thorough understanding of the\nStructured Macros.  The reference material in this manual\nwill be a great help in this understanding, but examining the\nStructured Macros themselves will also be required.  This is\n:hp2.NOT:ehp2. an OCO product.\n:p.\nProbably the best way to write an new expansion macro is to\nstart with an existing copy of a similar macro.\nBe sure to set all of the global variables that are needed by the\nother Structured Macros.\nIt will probably not be necessary to write a complete set of\nexpansion macros to support a new environment.  Some of the\nexisting macros that end with :q.STD:eq. are used to provide\npart of the support for the DC, OS and PLI environments.  It\nis possible that these :q.standard:eq. expansion macros will\nsupport other environments as well.\n.*\n:h2.Block Expansion Macros\nThe BLOCK and ENDBLK macros do some housekeeping and then call\nthe appropriate expansion macro.\n:p.\nThe BLOCK macro does the following processing before calling any\nexpansion macro:\n:ul compact.\n:li.Makes sure that block level will not exceed 20.\n:li.Increments _#BLVL, _#MLVL and _#MNDX.\n:li.Sets the new entries in _#BNAME, _#BNDX, _#BMLVL, _#BTYPE,\n_#BPL1 and _#BPL2 to their appropriate values.\n:eul.\nThe ENDBLK macro does the following processing before calling any\nexpansion macro:\n:ul compact.\n:li.Insures that _#BLVL, _#BMLVL(_#BLVL) and _#BNAME(_#BLVL) are\ncorrect.\n:li.Decrements _#MLVL.\n:li.Checks the syntax of the RC keyword's value.\n:eul.\nAfter calling the expansion macro, ENDBLK decrements _#BLVL.\n:h3 id=##pp.Program Block Prolog Macros\n:p.\nProgram block prolog macros are called by the BLOCK macro.\nBy convention, their names start with :q.##PP:eq..\n:p.\nThe BLOCK macro does the following additional processing before\ncalling this type of expansion macro:\n:ul compact.\n:li.Insures that the program block is at block level 1.\n:li.Increments _#PB#C.\n:li.Sets _#PBENC to true.\n:li.Calls internal macro ##DEFSUB to define program name.\n:li.Sets _#SB#C and _#SB#CPB to the  current block number.\n:li.Resets _#CSFT#N to 1.\n:li.Resets _#PBPLMX and _#PBWAMX to zero.\n:li.Sets _#PBNAME and _#PBNDX as appropriate.\n:li.Issues :q.ignored messages:eq. if keywords SWAREG, RECUR and\nSAVE are specified.\n:li.Calls the ##$xxx macro for the current environment.\n:eul.\nWhen the BLOCK macro calls a program block prolog macro, it\npasses the values of keywords NAME, OPTIONS, SDID, WAID,\nSUBOPTS, BASEREG, PWAREG, SVAREA, CPYRGHT, AMODE, RMODE,\nR1SAVE, SMWA, DYNSIZE, DYNERR and PWASP\nas positional parameters in the given order.\n:h3 id=##pe.Program Block Epilog Macros\n:p.\nProgram block epilog macros are called by the ENDBLK macro.\nBy convention, their names start with :q.##PE:eq..\n:p.\nWhen the ENDBLK macro calls a program block epilog macro, it\npasses the values of keywords RC, R0 and R1\nas positional parameters in the given order.\n:h3 id=##ip.Inline Block Prolog Macros\n:p.\nInline block prolog macros are called by the BLOCK macro.\nBy convention, their names\nstart with :q.##IP:eq..\n:p.\nThe BLOCK macro does the following additional processing before\ncalling this type of expansion macro:\n:ul compact.\n:li.Insures that the inline block is not at block level 1.\n:li.Issues :q.ignored messages:eq. if keywords\nSUBOPTS, BASEREG, PWAREG, SVAREA, CPYRGHT, RMODE, R1SAVE,\nSMWA, DYNSIZE, DYNERR, SWAREG, RECUR, PWASP or ENVIRON are\nspecified.\n:eul.\nWhen the BLOCK macro calls an inline block prolog macro, it\npasses the values of keywords NAME, OPTIONS, SDID, WAID,\nAMODE and SAVE as positional parameters in the given order.\n:h3 id=##ie.Inline Block Epilog Macros\n:p.\nInline block epilog macros are called by the ENDBLK macro.\nBy convention, their names start with :q.##IE:eq..\n:p.\nWhen the ENDBLK macro calls a inline block epilog macro, it\npasses the values of the RC keyword\nas a positional parameter.\n:h3 id=##sp.Subroutine Block Prolog Macros\n:p.\nSubroutine block prolog macros are called by the BLOCK macro.\nBy convention, their names\nstart with :q.##SP:eq..\n:p.\nThe BLOCK macro does the following additional processing before\ncalling this type of expansion macro:\n:ul compact.\n:li.Insures that the subroutine block is at block level 1.\n:li.Issues :q.ignored messages:eq. if keywords SUBOPTS,\nPWAREG, SVAREA, CPYRGHT, RMODE, R1SAVE, SMWA, DYNSIZE,\nDYNERR, PWASP or ENVIRON are specified.\n:eul.\nWhen the BLOCK macro calls a subroutine block prolog macro,\nit passes the values of keywords NAME, OPTIONS, SDID, WAID,\nBASEREG, AMODE, SMWA, SWAREG, RECUR and SAVE as positional\nparameters in the given order.\n:h3 id=##se.Subroutine Block Epilog Macros\n:p.\nSubroutine block epilog macros are called by the ENDBLK macro.\nBy convention, their names\nstart with :q.##SE:eq..\n:p.\nWhen the ENDBLK macro calls a subroutine block epilog macro, it\npasses the values of the RC keyword\nas a positional parameter.\n:h3 id=##ep.Error Exit Block Prolog Macros\n:p.\nError exit block prolog macros are called by the BLOCK macro.\nBy convention, their names\nstart with :q.##EP:eq..\n:p.\nThe BLOCK macro does the following additional processing before\ncalling this type of expansion macro:\n:ul compact.\n:li.Insures that the error exit block is at block level 1 and follows\na program block.\n:li.Issues :q.ignored messages:eq. if keywords SUBOPTS,\nBASEREG, PWAREG, SVAREA, CPYRGHT, RMODE, R1SAVE, SMWA,\nDYNSIZE, DYNERR, SWAREG, RECUR, PWASP and ENVIRON are\nspecified.\n:eul.\nWhen the BLOCK macro calls an error exit block prolog macro, it\npasses the values of keywords NAME, OPTIONS, SDID, WAID,\nBASEREG, AMODE and SAVE as positional parameters in the\ngiven order.\n:h3 id=##ee.Error Exit Block Epilog Macros\n:p.\nError exit block prolog macros are called by the ENDBLK macro.\nBy convention, their names\nstart with :q.##EE:eq..\n:p.\nWhen the ENDBLK macro calls a error exit block epilog macro, it\npasses the values of keywords RC, R0 and R1\nas positional parameters in the given order.\n:h2.Work Area Expansion Macros\nPWA, ENDPWA, SWA and ENDSWA call expansion macros.  They do not\ndo any housekeeping before calling.\n:h3 id=##wp.Program Work Area Prolog Macros\n:p.\nPWA prolog macros are called by the PWA macro.\nBy convention, their names\nstart with :q.##WP:eq..\n:p.\nThe PWA macro calls a PWA prolog macro with\nthe value of the TYPE keyword\nas a positional parameter.\n:h3 id=##we.Program Work Area Epilog Macros\n:p.\nPWA epilog macros are called by the ENDPWA macro.\nBy convention, their names\nstart with :q.##WE:eq..\n:p.\nThe ENDPWA macro calls a PWA epilog macro without any\nparameters.\n:h3 id=##up.Subroutine Work Area Prolog Macros\n:p.\nSWA prolog macros are called by the SWA macro.\nBy convention, their names\nstart with :q.##UP:eq..\n:p.\nThe SWA macro calls a SWA prolog macro with\nthe value of the TYPE keyword\nas positional parameter.\n:h3 id=##ue.Subroutine Work Area Epilog Macros\n:p.\nSWA epilog macros are called by the ENDSWA macro.\nBy convention, their names\nstart with :q.##UE:eq..\n:p.\nThe ENDSWA macro calls a SWA epilog macro without any\npositional parameters.\n:h1.Internal Macros\n:p.\nThis chapter contains all of the internal macros used by the Structured\nMacros.  All of these macros begin with :q.##:eq..  The error messages\nproduced by these macros are documented in :cit.Clemson University\nComputer Center Structured Programming Macros User's Guide and\nReference:ecit..\n.kp on\n:h2.Internal Macro ##$DC\n:dl.\n:dt.Macro:\n:dd.##$DC\n:dt.Abstract:\n:dd.##$DC is an internal macro used to set the expansion macro names\nfor the DC environment.\nRefer to :hdref refid=proepi. for more information on this type of\nmacro.\n:dt. Syntax:\n:dd.##$DC\n:dt.Operands:\n:dd.None\n:edl.\n.kp off\n.kp on\n:h2.Internal Macro ##$OS\n:dl.\n:dt.Macro:\n:dd.##$OS\n:dt.Abstract:\n:dd.##$OS is an internal macro used to set the expansion macro\nnames for the OS environemnt.\nRefer to :hdref refid=proepi. for more information on this type of\nmacro.\n:dt. Syntax:\n:dd.##$OS\n:dt.Operands:\n:dd.None\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##$PLI\n:dl.\n:dt.Macro:\n:dd.##$PLI\n:dt.Abstract:\n:dd.##$PLI is an internal macro used to set the expansion macro\nnames for the PL/I environemnt.\nRefer to :hdref refid=proepi. for more information on this type of\nmacro.\n:dt. Syntax:\n:dd.##$PLI\n:dt.Operands:\n:dd.None\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##ASMH\n:dl.\n:dt.Macro:\n:dd.##ASMH\n:dt.Abstract:\n:dd.##ASMH is an internal macro used to set the global binary variable\n##ASMH.  After the ##ASMH macro is invoked, the variable ##ASMH\nwill have the value 1 if the Level H Assembler is being used,\nand the value 0 if the Level H Assembler is not being used.\n:dt. Syntax:\n:dd.##ASMH ((a))&lbt.,PASS=FIRST|SECOND&rbt.\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.a\n:dd.This can be any value since the expression in parentheses\nis not actually used by ##ASMH.  The macro makes use of the\ndifferences in the way nested expressions are treated to determine\nthe assembler being used.  Therefore, the actual values passed\nto ##ASMH does not matter, but it must be enclosed in double\nparentheses.  Any macro or code that requires the Level H\nAssembler can use ##ASMH to verify that it is being used.\n:dt.PASS=\n:dd.This keyword should not be used by the caller of ##ASMH.\nIt is used by ##ASMH itself for internal use.\n:edl.\n:edl.\n.kp off\n.*\n.kp on\n:h2 id=cond.Internal Macro ##COND\n:dl.\n:dt.Macro:\n:dd.##COND\n:dt.Abstract:\n:dd.##COND is an internal recursive macro used by the IF, ELSEIF,\nLOOP, ENDLOOP, LEAVE, and ERREXIT macros to generate compare\nand branch instructions based on a boolean condition expression.\nRefer to :hdref refid=condexp. for more information.\n:p.\nThe following left recursive productions describe the syntax for\ncondition expressions.  Production A is a special production used\nonly by the IF and ELSEIF macros to allow a :hp2.,THEN:ehp2.\nto be placed\nafter the condition expression.  Productions B defines the form of a\ncondition expression.\n.kp off\n.kp on\n:dl tsize=8 termhi=0.\n.tp 23 51\n:dt.A\n:dd.::=!B:hp2.,THEN:ehp2. | B\n:dt.B\n:dd.::=!B:hp2.,OR,:ehp2.C | C\n:dt.C\n:dd.::=!C:hp2.,AND,:ehp2.D | D\n:dt.D\n:dd.::=!:hp2.NOT,:ehp2.E | E\n:dt.E\n:dd.::=!(B) | (COMP) | COND\n:dt.COMP\n:dd.::=!:hp2.CLC,:ehp2.OP1,COND,OP2!|\n!:hp2.CR,:ehp2.OP1,COND,OP2!|\n!:hp2.C,:ehp2.OP1,COND,OP2!|\n!:hp2.CP,:ehp2.OP1,COND,OP2!|\n!:hp2.CH,:ehp2.OP1,COND,OP2!|\n!:hp2.CLR,:ehp2.OP1,COND,OP2!|\n!:hp2.CL,:ehp2.OP1,COND,OP2!|\n!:hp2.CLI,:ehp2.OP1,COND,OP2!|\n!:hp2.CLCL,:ehp2.OP1,COND,OP2!|\n!:hp2.TM,:ehp2.OP1,COND,OP2!|\n!:hp2.CLM,:ehp2.OP1,MASK,COND,OP2!|\n!:hp2.TREG,:ehp2.OP1,COND!|\n!:hp2.TBIT,:ehp2.&lbt.OP1,&rbt.OP2:hp2.&lbt.,ON|OFF|ANY|MIXED:ehp2.&rbt.\ndefault ON\n!:hp2.#TEST,:ehp2.OP1:hp2.&lbt.,ON|OFF|ANY&rbt.:ehp2. default ON\n.kp off\n.kp on\n.tp 23 35 40\n:dt.COND\n:dd.::=!:hp2.EQ:ehp2.!|!&lbr.equal&rbr.\n!:hp2.E:ehp2.!|!&lbr.equal&rbr.\n!:hp2.NE:ehp2.!|!&lbr.not equal&rbr.\n!:hp2.LT:ehp2.!|!&lbr.less than&rbr.\n!:hp2.GT:ehp2.!|!&lbr.greater than&rbr.\n!:hp2.LE:ehp2.!|!&lbr.less than or equal&rbr.\n!:hp2.GE:ehp2.!|!&lbr.greater than or equal&rbr.\n!:hp2.Z:ehp2.!|!&lbr.zero&rbr.\n!:hp2.NZ:ehp2.!|!&lbr.not zero&rbr.\n!:hp2.M:ehp2.!|!&lbr.minus or mixed&rbr.\n!:hp2.NM:ehp2.!|!&lbr.not minus or not mixed&rbr.\n!:hp2.P:ehp2.!|!&lbr.positive&rbr.\n!:hp2.NP:ehp2.!|!&lbr.not positive&rbr.\n!:hp2.O:ehp2.!|!&lbr.ones&rbr.\n!:hp2.NO:ehp2.!|!&lbr.not ones&rbr.\n!:hp2.ON:ehp2.!|!&lbr.on&rbr.\n!:hp2.OFF:ehp2.!|!&lbr.off&rbr.\n!:hp2.ANY:ehp2.!|!&lbr.any on&rbr.\n!:hp2.MIXED:ehp2.!|!&lbr.mixed&rbr.\n!:hp2.CC1-CC14:ehp2.!!&lbr.condition codes 1 through 14&rbr.\n:dt.OP1\n:dd.::=!Anything that is valid for operand 1 of the associated opcode\n:dt.OP2\n:dd.::=!Anything that is valid for operand 2 of the associated opcode\n:dt.MASK\n:dd.::=!Anything that is valid as a mask for the associated opcode\n.tp\n:edl.\n.kp off\n.kp on\n:dt. Syntax:\n:dd.##COND\nexpr,S=s,F=f&lbt.,T=A|B|C|D|E&rbt.&lbt.,L=N|P&rbt.&lbt.,B=b&rbt.,E=e\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.expr\n:dd.Syslist entries.  These entries must be of a form\nthat can be parsed by the production specified on the T= keyword.\n:dt.s\n:dd.Tag to use for branch to success code\n:dt.f\n:dd.Tag to use for branch to fail code.\n:dt.T=\n:dd.Production (A|B|C|D|E) to start with.\n:dt.L=\n:dd.Logic (N|P).  :q.N:eq. indicates that the last branch generated\nshould be to fail tag.  :q.P:eq. indicates that the last branch\ngenerated should be to success tag.\n:dt.b\n:dd._SYSLIST entry to start with.  Default is 1.\n:dt.e\n:dd._SYSLIST entry to end with.\n:edl.\n:edl.\n.kp off\n.kp on\n.*\n:h2.Internal Macro ##CVREG\n:dl.\n:dt.Macro:\n:dd.##CVREG\n:dt.Abstract:\n:dd.##CVREG is an internal macro used to convert registers\nspecified as :q.Rn:eq. or :q.Rnn:eq. to the corresponding numeric value\nfor internal use.\n:dt. Syntax:\n:dd.##CVREG reg\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.reg\n:dd.Register specification of the form :q.Rn:eq. or :q.Rnn:eq.\n:edl.\n:edl.\n.kp off\n.kp on\n.*\n:h2.Internal Macro ##DEFSUB\n:dl.\n:dt.Macro:\n:dd.##DEFSUB\n:dt.Abstract:\n:dd.##DEFSUB is an internal macro used to maintain the subroutine\ntable.  When passed a subroutine name, it defines it to the table\nif it does not already exist, and returns the subroutine number\nin the global variable #SB#D.  This is used by the subroutine\nblock macro and by the CALLSUB macro.\n:dt. Syntax:\n:dd.##DEFSUB name\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.name\n:dd.Name of subroutine to be defined or queried\n:edl.\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##EESTD\n:dl.\n:dt.Macro:\n:dd.##EESTD\n:dt.Abstract:\n:dd.##EESTD is the standard error exit epilog expansion macro.\n:p.Refer to :hdref refid=##ee. for more information.\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##EPSTD\n:dl.\n:dt.Macro:\n:dd.##EPSTD\n:dt.Abstract:\n:dd.##EPSTD is the standard error exit prolog expansion macro.\n:p.Refer to :hdref refid=##ep. for more information.\n##EPSTD ignores keywords OPTIONS, BASEREG, SDID and WAID.\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##IESTD\n:dl.\n:dt.Macro:\n:dd.##IESTD\n:dt.Abstract:\n:dd.##IESTD is the standard inline block epilog expansion macro.\n:p.Refer to :hdref refid=##ie. for more information.\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##IGMSG\n:dl.\n:dt.Macro:\n:dd.##IGMSG\n:dt.Abstract:\n:dd.Macro ##IGMSG is used to display an operand ignored message.\nIt is used mostly by the prolog and epilog macros to indicate\nwhich keyword are not supported by the given expansion macro.\n:dt. Syntax:\n:dd.##IGMSG kwd,kwdname\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.kwd\n:dd.The value of the keyword being ignored.\n:dt.kwdname\n:dd.The name of the keyword being ignored.\n:edl.\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##IPSTD\n:dl.\n:dt.Macro:\n:dd.##IPSTD\n:dt.Abstract:\n:dd.##IPSTD is the standard inline block prolog expansion macro.\n:p.Refer to :hdref refid=##ip. for more information.\n##IPSTD ignores keywords OPTIONS, SDID and WAID.\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##LA\n:dl.\n:dt.Macro:\n:dd.##LA\n:dt.Abstract:\n:dd.##LA is an internal macro used by PLIST to load the address\nof fields that are not in standard assembler form.  It is this\nmacro that allows the specification of numeric and character\nconstants in parameter lists.\nIf the field is a decimal constant, a LA reg,=F'field' is done.\nIf the field is a character constant, a LA reg,=C'field' is done.\nOtherwise, a LA reg,field is performed.\n:dt. Syntax:\n:dd.##LA reg,field\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.reg\n:dd.Register to load\n:dt.field\n:dd.Field to load address of\n:edl.\n:edl.\n.kp off\n.kp on\n.*\n:h2.Internal Macro ##LDBS\n:dl.\n:dt.Macro:\n:dd.##LDBS\n:dt.Abstract:\n:dd.##LDBS is an internal macro used by the subroutine and program\nblock expansion macros\nto load base registers.\n##LDBS loads the selected base\nregisters with the appropriate values and establishes addressability.\n:dt. Syntax:\n:dd.##LDBS name,&lbt.reg|(reg,...)&rbt.&lbt.,defreg&rbt.&lbt.,\n.ct FRSTLD=YES|NO&rbt.\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.name\n:dd.Tag to establish addressability on.  ##LDBS will assume that\nregister 15 will point to this address.  If :hp1.name:ehp1. is\nspecified as an asterisk (*), ##LDBS will use a\nBALR :hp1.reg:ehp1.,0 to get the subroutine address.\n:dt.reg\n:dd.Register(s) to use as base registers for the subroutine.  These\nmay be any of the registers R3-R10 and no register may be repeated.\nIf this operand is missing the default base register will be used.\n:dt.defreg\n:dd.Register to use as the default base register.  This operand\nis only used if :hp1.reg:ehp1. operand is null.  However, if the\n:hp1.reg:ehp1. operand might be missing, :hp1.defreg:ehp1. must\nbe specified.\n:dt.frst\n:dd.Specifies whether the first base register should be loaded.\nIf NO is specified, the first base register is expected to be\npreloaded.  NO is the default.\nYES indicates that this macro should load the first base register.\n:edl.\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##MREG\n:dl.\n:dt.Macro:\n:dd.##MREG\n:dt.Abstract:\n:dd.##MREG is an internal macro that is used to keep up with which\nregisters are being used by the macros.\n:dt. Syntax:\n:dd.##MREG type,reg\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.type\n:dd.Type of function requested.  A type of RESET causes registers\n14 through 1 to be set as in use and the rest of the registers are\nmarked as not in use.\nA type of USE or RELEASE\ncauses a register to be marked in use or not in use, respectively.\n:dt.reg\n:dd.Register to be marked as in use or not in use.\n:edl.\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##ORGS\n:dl.\n:dt.Macro:\n:dd.##ORGS\n:dt.Abstract:\n:dd.##ORGS is an internal macro called from ENDPWA to calculate the\namount of SWA storage that must be reserved at the end of the PWA\nif Dynamic Storage Management is being used.  It is called recursively\nto trace the subroutine call structure and generate ORG statements\nto reserve storage.\n:dt. Syntax:\n:dd.##ORGS f,c\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.f\n:dd.Subroutine to generate ORGs for\n:dt.c\n:dd.Place subroutine was called from\n:edl.\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##PEDC\n:dl.\n:dt.Macro:\n:dd.##PEDC\n:dt.Abstract:\n:dd.##PEDC is the program block epilog expansion macro for the DC\nenvironment.\n:p.Refer to :hdref refid=##pe. for more information.\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##PEOS\n:dl.\n:dt.Macro:\n:dd.##PEOS\n:dt.Abstract:\n:dd.##PEOS is the program block epilog expansion macro for the OS\nenvironment.\n:p.Refer to :hdref refid=##pe. for more information.\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##PEPLI\n:dl.\n:dt.Macro:\n:dd.##PEPLI\n:dt.Abstract:\n:dd.##PEPLI is the program block epilog expansion macro for the PL/I\nenvironment.\n:p.Refer to :hdref refid=##pe. for more information.\n##PEPLI ignores keywords R0, R1 and RC.\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##PPDC\n:dl.\n:dt.Macro:\n:dd.##PPDC\n:dt.Abstract:\n:dd.##PPDC is the program block prolog expansion macro for the DC\nenvironment.\n:p.Refer to :hdref refid=##pp. for more information.\n##PPDC ignores keywords DYNSIZE, DYNERR, SVAREA, PWASP, SDID and WAID.\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##PPOS\n:dl.\n:dt.Macro:\n:dd.##PPOS\n:dt.Abstract:\n:dd.##PPOS is the program block prolog expansion macro for the OS\nenvironment.\n:p.Refer to :hdref refid=##pp. for more information.\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##PPPLI\n:dl.\n:dt.Macro:\n:dd.##PPPLI\n:dt.Abstract:\n:dd.##PPPLI is the program block prolog expansion macro for the PL/I\nenvironment.\n:p.Refer to :hdref refid=##pp. for more information.\n##PPPLI ignores keywords\nSVAREA, R1SAVE, SMWA, DYNSIZE, DYNERR, SWAREG, PWASP, WAID and SDID.\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##REGS\n:dl.\n:dt.Macro:\n:dd.##REGS\n:dt.Abstract:\n:dd.##REGS is an internal macro used by the BLOCK macro. It\nequates R0, R1, R2, ... ,R15 to 0, 1, 2, ... ,15.\n:dt. Syntax:\n:dd.##REGS\n:dt.Operands:\n:dd.None\n:edl.\n.kp off\n.kp on\n.*\n:h2.Internal Macro ##RST\n:dl.\n:dt.Macro:\n:dd.##RST\n:dt.Abstract:\n:dd.##RST is an internal macro used by the ENDBLK macro\nto restore registers.\n:dt. Syntax:\n:dd.##RST &lbt.level&rbt.,R15=YES|NO\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.level\n:dd.block level to restore registers from. Defaults to\ncurrent block level.\n:dt.R15=\n:dd.Specifies whether R15 should be restored or not.\n:edl.\n:edl.\n.kp off\n.kp on\n.*\n:h2.Internal Macro ##RTN\n:dl.\n:dt.Macro:\n:dd.##RTN\n:dt.Abstract:\n:dd.##RTN is an internal macro used by the ENDBLK macro\nto set return code, restore registers, and return.\n:dt. Syntax:\n:dd.##RTN &lbt.rc&rbt.,sv\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.rc\n:dd.symbol - symbol indicating return code\n:p.\n(reg)  - register number containing return code\n:dt.sv\n:dd.0 - registers should not be restored\n:p.\n1 - registers should be restored\n:edl.\n:edl.\n.kp off\n.kp on\n.*\n:h2.Internal Macro ##RWREG\n:dl.\n:dt.Macro:\n:dd.##RWREG\n:dt.Abstract:\n:dd.##RWREG restores the register requested from the current\nStructured Macro Work Area (SMWA).\n:dt. Syntax:\n:dd.##RWREG reg\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.reg\n:dd.register to restore from the current SMWA\n:edl.\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##SESTD\n:dl.\n:dt.Macro:\n:dd.##SESTD\n:dt.Abstract:\n:dd.##SESTD is the standard subroutine block epilog expansion macro.\n:p.Refer to :hdref refid=##se. for more information.\n##SESTD ignores keywords R0 and R1.\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##SPSTD\n:dl.\n:dt.Macro:\n:dd.##SPSTD\n:dt.Abstract:\n:dd.##SPSTD is the standard subroutine block prolog expansion macro.\n:p.Refer to :hdref refid=##sp. for more information.\n##SPSTD ignores keywords SDID and WAID.\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##SUBOPT\n:dl.\n:dt.Macro:\n:dd.##SUBOPT\n:dt.Abstract:\n:dd.##SUBOPT is used to set subroutine options.  It is called by\nprogram block prolog macros to set default subroutine options and\nby subroutine block prolog macros to set the current subroutine's\noptions.\n:dt. Syntax:\n:dd.##SUBOPT options&lbt.,DEFAULT=def&rbt.\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.option\n:dd.the options to be set.\n:dt.def\n:dd.\nYES - the options are taken as defaults\n.br\nNO  - the options are active for the current subroutine\n:edl.\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##SWREG\n:dl.\n:dt.Macro:\n:dd.##SWREG\n:dt.Abstract:\n:dd.##SWREG saves the register requested in the current\nStructured Macro Workarea (SMWA).\n:dt. Syntax:\n:dd.##SWREG reg\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.reg\n:dd.register to save in the current SMWA\n:edl.\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##UESTD\n:dl.\n:dt.Macro:\n:dd.##UESTD\n:dt.Abstract:\n:dd.##UESTD is the standard Subroutine Work Area (SWA)\nepilog expansion macro.\n:p.Refer to :hdref refid=##ue. for more information.\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##UPSTD\n:dl.\n:dt.Macro:\n:dd.##UPSTD\n:dt.Abstract:\n:dd.##UPSTD is the standard Subroutine Work Area (SWA)\nprolog expansion macro.\n:p.Refer to :hdref refid=##up. for more information.\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##WESTD\n:dl.\n:dt.Macro:\n:dd.##WESTD\n:dt.Abstract:\n:dd.##WESTD is the standard Program Work Area (PWA)\nepilog expansion macro.\n:p.Refer to :hdref refid=##we. for more information.\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##WPDC\n:dl.\n:dt.Macro:\n:dd.##WPDC\n:dt.Abstract:\n:dd.##WPDC is the prolog macro for a DC environment Program Work Area.\n:p.Refer to :hdref refid=##wp. for more information.\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##WPPLI\n:dl.\n:dt.Macro:\n:dd.##WPPLI\n:dt.Abstract:\n:dd.##WPPLI is the prolog macro for an PL/I\nenvironment Program Work Area.\n:p.Refer to :hdref refid=##wp. for more information.\n:edl.\n.kp off\n.*\n.kp on\n:h2.Internal Macro ##WPOS\n:dl.\n:dt.Macro:\n:dd.##WPOS\n:dt.Abstract:\n:dd.##WPOS is the prolog macro for an OS environment Program Work Area.\n:p.Refer to :hdref refid=##wp. for more information.\n:edl.\n.kp off\n.*\n:h1.Global Variables\n:p.\nThis chapter contains all of the global variables used by the\nStructured Macros.\nAll of the global variables used begin with\nwith :q._#:eq..\n:p.\nWhen :q.structural nesting level:eq. is used in these descriptions,\nit indicates the nesting level of all structures.\nThe other times when :q.nesting level:eq. is used, it refers\nto a particular type of structured.\n:p.\nFor example:\n:xmp.\nBLOCK TYPE=PROGRAM   &lbr.Structural nesting level 1&rbr.\n ...                 &lbr.Block nesting level 1     &rbr.\n LOOP                &lbr.Structural nesting level 2&rbr.\n  ...                &lbr.Loop nesting level 1      &rbr.\n  IF (CLC,A,EQ,B)    &lbr.Structural nesting level 3&rbr.\n   ...               &lbr.If nesting level 1        &rbr.\n   IF (CLC,C,EQ,D)   &lbr.Structural nesting level 4&rbr.\n    ...              &lbr.If nesting level 2        &rbr.\n    LOOP             &lbr.Structural nesting level 5&rbr.\n    ...              &lbr.Loop nesting level 2      &rbr.\n    ENDLOOP\n   ENDIF\n  ENDIF\n ENDLOOP\nENDBLK\n:exmp.\n:dl tsize=20.\n:dt._##ASMH\n:dd.Logical variable _##ASMH is set by macro ##ASMH.  ##ASMH will set\nthe variable to 1 if Assembler H is being used; otherwise, it is set to\n0.  Other macros use this variable to determine whether to do Assembler\nH dependent operations.  _##ASMH is used in macros ##ASMH, ##PPDC and\n##PPOS.\n:dt._#BAMODE(20)\n:dd.Character array _#BAMODE is used to contain the addressing modes for\nthe currently nested blocks.  The index to this array is the block\nnesting level.  Usually variable _BLVL is used as an index.  _#BAMODE is\nuse in macros ##EESTD, ##EPSTD, ##IESTD, ##IPSTD, ##PEDC, ##PPDC,\n##PPPLI, ##PPOS, ##SESTD, ##SPSTD, LEAVE and PLIST.\n:dt._#BLVL\n:dd.Arithmetic variable _#BLVL is used to hold the current block nesting\nlevel.  The block nesting level is always one except inside inline\nblocks.  _#BLVL is used in macros ##EESTD, ##EPSTD, ##IESTD, ##IPSTD,\n##PEDC, ##PPDC, ##PPPLI, ##PPOS, ##RST, ##SESTD, ##SPSTD, BLOCK,\nENDBLK, LEAVE and PLIST.\n:dt._#BMLVL(20)\n:dd.Arithmetic array _#BMLVL is used to hold the structural nesting\nlevel for each currently nested block.  The block nesting level is used\nas an index.  The variable is used to make sure that all structures\nwithin a block are terminated when the corresponding block's ENDBLK is\nencountered.  _#BMLVL is used in macros ##PEDC, ##PPDC, BLOCK, ENDBLK,\nLEAVE and PLIST.\n:dt._#BNAME(20)\n:dd.Character array _#BNAME holds the names of all of the currently\nnested blocks.  The block nesting level is used as an index.  _#BNAME is\nused in macros ##PEDC, ##PPDC, ##SPSTD, BLOCK, ENDBLK, LEAVE and PLIST.\n:dt._#BNDX(20)\n:dd.Arithmetic array _#BNDX is used to hold the index number used to\ngenerate tags for a block.  _#BNDX is set by the BLOCK macro using the\ncurrent _#MDX.  _#BNDX is used in macros ##EESTD, ##EPSTD, ##IESTD,\n##PEDC, ##PPDC, ##PPPLI, ##PPOS, BLOCK, ENDBLK, LEAVE and PLIST.\n:dt._#BPLn(20)\n:dd.Character array _#BPL1 and _#BPL2 are used to hold the first and\nsecond parameters from the PL keyword for each currently nested block.\n_#BPL1 and _#BPL2 are used in macros BLOCK and PLIST.\n:dt._#BSVn(20)\n:dd.Character arrays _#BSV1, _#BSV2, and _#BSV3 are used to hold the\nfirst, second and third parameters from the SAVE keyword for each\ncurrently nested block.  These variables are used in macros ##EPSTD,\n##IPSTD, ##PPDC, ##RST, ##SPSTD and LEAVE.\n:dt._#BTYPE(20)\n:dd.Character array _BTYPE holds the block type for all of the currently\nnested blocks.  _BTYPE is indexed by the block nesting level.  The way\nblocks are currently structured in the macros, the first block type is\nprogram, subroutine or errexit and all others are inline.  This may\nchange in the future.  _#BTYPE is used in macros ##IPSTD, ##PEDC,\n##PPDC, BLOCK, ENDBLK, EXI, LEAVE and PLIST.\n:dt._#CCAS(20)\n:dd.Logical array _#CCAS is used to keep an indicate as to whether a\nCASE macro has been encountered within one of the currently nested case\nblocks.  The case block nesting level is used as an index.  This\nindicator is used during code generation to determine if a branch to the\nend of the case block is need before the code for a new case starts.\n_#CCAS is used in macros CASE, CASEBLK and ENDCASE.\n:dt._#CLVL\n:dd.Arithmetic variable _#CLVL is used to hold the current case block\nnesting level.  _#CLVL is used in macros CASE, CASEBLK, ENDCASE and\nLEAVE.\n:dt._#CMAXC(20)\n:dd.Arithmetic array _#CMAXC is use to keep up with the maximum case\nnumber for the corresponding case block.  The case block nesting level\nis used as an index into this array.  _#CMAXC is used in macros CASE,\nCASEBLK and ENDCASE.\n:dt._#CMLVL(20)\n:dd.Arithmetic array _#CMLVL is used to hold the structural nesting\nlevel for each currently nested case block.  The case block nesting\nlevel is used as an index.  The variable is used to make sure that all\nstructures within a case block are terminated when the corresponding\ncase's ENDCASE is encountered.  _#CMLVL is used in macros CASE,\nCASEBLK, ENDCASE and LEAVE.\n:dt._#CMULT(20)\n:dd.Arithmetic array _#CMULT is used to hold the MULT= keyword for all\nof the currently nested case blocks.  The case block nesting level is\nused as an index.  _#CMULT is used by macro CASE, CASEBLK and ENDCASE.\n:dt._#CNAME(20)\n:dd.Character array _#CNAME is used to hold the names of all of the\ncurrently nested case blocks.  The case block nesting level is used as\nan index.  _#CNAME is used by macros CASE, CASEBLK, ENDCASE and LEAVE.\n:dt._#CNDX(20)\n:dd.Arithmetic array _#cNDX is used to hold the index number used to\ngenerate tags for a case block.  _#CNDX is set by the CASEBLK macro\nusing the current _#MDX.  _#CNDX is used in macros CASE, CASEBLK,\nENDCASE and LEAVE.\n:dt._#COTH(20)\n:dd.Logical array _#COTH is used to determine if a CASE OTHER has\nbeen encountered within a case block.  The case block nesting level\nis used as an index.  _#COTH is used in macros CASE, CASEBLK and\nENDCASE.\n:dt._#CSF(500)\n:dd.Arithmetic array _#CSF along with corresponding elements in array\n_#CST are used to hold a representation of which subroutines call which\nsubroutines.  _#CSF is set to the block number of the\n:q.from:eq.subroutine while _#CST is set to the block number of the\n:q.to:eq. subroutine.  This block number is the same number that is used\nas an index into the array _#BNAME.  Note that the program block name is\nalways in the first entry of _#BNAME.  Each paired entry in _#CSF and\n_#CST is unique.  Array _#CSFF and variable _#CSFT#N are very closely\nrelated to these arrays.  _#CSF and $#CST are used in macros ##ORGS,\n##WESTD and CALLSUB.\n:dt._#CSFF(99)\n:dd.Arithmetic array _#CSFF is used to hold the index of the first entry\nin the _#CSF array for a given subroutine.  The same index used to\naccess a given subroutines name in array _#BNAME is used to access\n_#CSFF.  _#CSFF is used in macros ##ORGS, ##WESTD and CALLSUB.\n:dt._#CSFT#N\n:dd.Arithmetic variable _#CSFT#N is used to hold the index for the next\nunused entry in array _#CSF.  _#CSFT#N is used in macros ##ORGS,\n##WESTD, BLOCK and CALLSUB.\n:dt._#CSSD\n:dd.Logical array _#CSSD indicates whether an adcon for an associated\nsubroutine has already been placed in the PSD when the LONG program\noption is in effect.  The same index used to access a given subroutines\nname in array _#BNAME is used to access _#CSSD.  _#CSSD(99) is used in\nmacro CALLSUB.\n:dt._#CST(500)\n:dd.Refer to array _#CSF for information on array _#CST.\n:dt._#CSVST\n:dd.Logical array _#CSVST is used by macro ##ORGS to determine which\nprograms it has already :q.visited:eq..  _#CSVST is only used by macro\n##ORGS.\n:dt._#CTAGS(2020)\n:dd.Arithmetic array _#CTAGS is used as a 20 by 101 matrix where the\nfirst index is the nesting level of a case block and the second index is\na case number.  The entries in this matrix contain the _#MNDX value\nassigned to the corresponding CASE macro.  These entries are used in\nformulating the names of tags associated with a give case.  _#CTAGS is\nused in macros CASE, CASEBLK and ENDCASE.\n:dt._DC#RET\n:dd.Logical variable _#DC#RET is used to communicate between ##PPDC\nand ##PEDC whether the user has requested the #RETURN option.\n_#DC#RET is used in macros ##PEDC and ##PPDC.\n:dt._#DCRTN\n:dd.Logical variable _#DC#RTN is used to communicate between ##PPDC\nand ##PEDC whether the user has requested the #RTN option.\n_#DC#RTN is used in macros ##PEDC and ##PPDC.\n:dt._#DCNTSK\n:dd.Character variable _#DCNTSK is used to contain the DC next-task\ncode for use when ##PEDC generates :q.#RETURN NXTTASK=:eq..\n_#DCNTSK is used in macros ##PEDC and ##PPDC.\n:dt._#DCPWAR\n:dd._#DCPWAR is a character variable that is used to contain the\nname of the first PWA register specified, so that ##PEDC can use\nit to issue a #FREESTG for the PWA.\n_#DCPWAR is used in macros ##PEDC and ##PPDC.\n:dt._#DCRENT\n:dd.Logical variable _#DCRENT is set by requesting the RENT option\nvia ##PPDC.\n_#DCRENT is used in macros ##PEDC and ##PPDC.\n:dt._#DCRINT\n:dd.Character variable _#DCRINT is used to contain the DC resource\ntimeout interval value\nif specified to ##PPDC. ##PEDC uses _#DCRINT in generating\n:q.#RETURN RESINT=:eq.\nif the #RETURN option was requested.\n_#DCRINT is used in macros ##PEDC and ##PPDC.\n:dt._#DCRPGM\n:dd.Character variable _#DCRPGM is used to contain the\nname of the resource interval timeout handler program\nif specified to ##PPDC. ##PEDC uses _#DCRPGM in generating\n:q.#RETURN RESPGM=:eq.\nif the #RETURN option was requested.\n_#DCRINT is used in macros ##PEDC and ##PPDC.\n_#DCRPGM is used in macros ##PEDC and ##PPDC.\n:dt._#DCRTYP\n:dd.Character variable _#DCRTYP is used to contain the\n#RETURN TYPE= value of NORMAL, ABORT or CONTINUE\nas specified to ##PPDC, and is used by ##PEDC to generate\n:q.#RETURN TYPE=:eq. if the #RETURN option was requested.\n_#DCRTYP is used in macros ##PEDC and ##PPDC.\n:dt._#DCSYS\n:dd.Logical variable _#DCSYS is set if the SYSTEM option was requested\nby ##PPDC. _#DCSYS determines whether the #START/#RTN options or the\n#RETURN option and the #RETURN-related options TYPE, RESINT, RESPGM\nand NXTTASK are valid, and also causes ENV= to be set to SYS or USER\non the internally-generated #MOPT macro.\n_#DCSYS is used in macros ##PEDC and ##PPDC.\n:dt._#DCGSTK\n:dd.Logical variable _#DCGSTK is set by ##PPDC if the GETSTK option\nwas requested. _#DCGSTK determines whether, if the PWA and SYSTEM\noptions were also specified, ##PPDC generates a #GETSTG or #GETSTK\nto acquire its Program Work Area. Also, ##PEDC uses _#DCGSTK to\ndetermine whether, if PWA and SYSTEM were specified,\nif a #FREESTG is necessary or not.\n:dt._#DLVL\n:dd.Arithmetic variable _#DLVL is used to hold the current loop\nnesting level.\n_#DLVL is used in macros ENDLOOP, LEAVE and LOOP.\n:dt._#DMLVL(20)\n:dd.Arithmetic array _#DMLVL is used to hold the structural\nnesting level for each currently nested loop.  The loop\nnesting level is used as an index.  The variable is used to\nmake sure that all structures within a loop are terminated\nwhen the corresponding loop's ENDLOOP is encountered.\n_#DMLVL is used by macros ENDLOOP, LEAVE and LOOP.\n:dt._#DNAME(20)\n:dd.Character array _#DNAME holds the names of all of the\ncurrently nested loops.  The loop nesting level is used as\nan index.  _#DNAME is used in macros ENDLOOP, LEAVE and\nLOOP.\n:dt._#DNDX(20)\n:dd.Arithmetic array _#DNDX is used to hold the index number used to\ngenerate tags for a loop.  _#DNDX is set by the LOOP macro using the\ncurrent _#MDX.  The loop nesting level is used as an index.  _#DNDX is\nused in macros ENDLOOP, LEAVE and LOOP.\n:dt._#DTYPE(20)\n:dd.Character array _#DTYPE is used to hold a loop type for the\ncurrently nested loops.  The loop nesting level is used as an index.\n_#DTYPE is used in macros ENDLOOP and LOOP.\n:dt._#EEMAC\n:dd.Character variable _#EEMAC is used to hold the default errexit\nepilog macro name.  It is set by a :q.##$xxx:eq. macro.  _#EEMAC is\nused in macros ##$DC, ##$PLI, ##$STD and ENDBLK.\n:dt._#EPMAC\n:dd.Character variable _#EPMAC is used to hold the default errexit\nprolog macro name.  It is set by a :q.##$xxx:eq. macro.  _#EPMAC\nis used in macros ##$DC, ##$PLI, ##$STD and BLOCK.\n:dt._#IELSE(20)\n:dd.Logical array _#IELSE is used to determine if an ELSE statement has\nbeen encountered within an IF structure.  _#IELSE is used in macros\nELSE, ELSEIF, ENDIF and IF.\n:dt._#IEMAC\n:dd.Character variable _#IEMAC is used to hold the default inline block\nepilog macro name.  It is set by a :q.##$xxx:eq. macro.  _#IEMAC\nis used in macros ##$DC, ##$PLI, ##$STD and ENDBLK.\n:dt._#ILVL\n:dd.Arithmetic variable _#ILVL is used to hold the current if nesting\nlevel.  _#ILVL is used in macros ELSE, ELSEIF, ENDIF, IF and LEAVE.\n:dt._#IMLVL(20)\n:dd.Arithmetic array _#IMLVL is used to hold the structural nesting\nlevel for each currently nested if statement.  The if nesting level\nis used as an index.  The variable is used to make sure that all\nstructures within an if are terminated when the corresponding if's\nENDIF is encountered.  _#IMLVL is used by macros ELSE, ELSEIF,\nENDIF, IF and LEAVE.\n:dt._#INAME(20)\n:dd.Character array _#INAME holds the names of all of the currently\nnested if statements.  The if nesting level is used as an index.\n_#INAME is used in macros ELSE, ELSEIF, ENDIF, IF and LEAVE.\n:dt._#INDX(20)\n:dd.Arithmetic array _#INDX is used to hold the index number used to\ngenerate tags for a if statement.  _#INDX is set by the IF macro using\nthe current _#MDX.  The IF nesting level is used as an index.  _#INDX is\nused in macros ELSE, ELSEIF, ENDIF, IF and LEAVE.\n:dt._#INDX2(20)\n:dd.Arithmetic array _#INDX is used to hold a second index number used\nto generate tags in an if structure.  _#INDX2 is set by the IF and\nELSEIF macros using the current _#MDX.  The IF nesting level is used as\nan index.  _#INDX2 is used in macros ELSE, ELSEIF, ENDIF and IF.\n:dt._#IPMAC\n:dd.Character variable _#IEMAC is used to hold the default inline block\nprolog macro name.  It is set by a :q.##$xxx:eq. macro.  _#IEMAC\nis used in macros ##$DC, ##$PLI, ##$STD and BLOCK.\n:dt._#MCVREG\n:dd.Arithmetic variable _#MCVREG is used by macro ##CVREG to pass back\nthe number of the register it converts.  _#MCVREG is used by macros\n##CVREG, ##LDBS, ##MREG, ##PPDC, ##RST, LCBA and STRSA.\n:dt._#MLVL\n:dd.Arithmetic variable _#MLVL is used to hold the current structural\nnesting level for all structures.  It is incremented by the start macro\nfor each structure and decremented by the end macro for each structure.\nThis variable is checked to insure the each end structure is paired up\nwith the correct type of begin structure.  _#MLVL is used by macros\n##PEDC, ##PPDC, BLOCK, CASE, CASEBLK, ELSE, ELSEIF, ENDBLK, ENDCASE,\nENDIF, ENDLOOP, ENDPSD, ENDSSD, EXI, IF, LEAVE, LOOP, PSD and SSD.\n:dt._#MNDX\n:dd.Arithmetic variable _#MNDX is used to generate a unique number that\ncan be used by each macro to generate unique tags.  The macros first add\none to this variable and then use that number as a suffix to tags.\n_#MNDX is used by variables ##COND, ##EPSTD, ##IPSTD, ##LDBS, ##PEDC,\n##PEOS, ##PPDC, ##PPPLI, ##PPOS, ##SPSTD, BLOCK, CALLX, CASE, CASEBLK,\nELSEIF, ENDBLK, ENDCASE, ENDLOOP, ERREXIT, IF, LCBA, LEAVE, LOOP and\nPLIST.\n:dt._#PB#C\n:dd.Arithmetic variable _#PB#C is set to the number of the current\n.rc 2 on\nprogram block.  _#PB#C is used by macros ##PEOS,\n##PPDC, ##PPPLI, ##PPOS,\n.rc 2 off\n##SPSTD, ##WESTD, ##WPPLI, ##WPOS, BLOCK, EXI, PLIST, PSD and SSD.\n:dt._#PBAMOD\n:dd.Character variable _#PBAMOD holds the amode of the current program\nblock.  _#PBAMODE is used by macros ##EESTD, ##PEDC, ##PPDC, ##PPPLI,\n##PPOS and PLIST.\n:dt._#PBBR14\n:dd.Logical variable _#PBBR14 is used to indicate whether the BR14\noption is specified on a program block.  _#PBBR14 is used by macros\n#PEOS and #PPOS.\n:dt._#PBDERR\n:dd.Character variable _#PBDERR is used to hold the _DYNERR keyword\nvalue specified on a program block.  _#PBDERR is used by macros ##PPOS\nand ##SPSTD.\n:dt._#PBDSWA\n:dd.Logical variable _#PBDSWA is set by a program block prolog macro to\nindicate to the PWA epilog macro that a define storage for the PWA is\nneeded.  _#PBDSWA is used by macros ##PPDC, ##PPPLI, ##PPOS and\n##WESTD.\n:dt._#PBDYN\n:dd.Logical variable _#PBDYN is set by a program block prolog macro to\nindicate whether the DYN option is in effect.  _#PBDYN is used by macros\n##PEOS, ##PPPLI, ##PPOS, ##SESTD, ##SPSTD, ##UESTD, ##UPSTD, ##WESTD,\n##WPOS and PLIST.\n:dt._#PBDYNS\n:dd.Character variable _#PBDYNS is set by a program block prolog macro\nto the value of the DYNSIZE keyword.  _#PBDYNS is used by macros\n##PPOS, ##SPSTD and ##WESTD.\n:dt._#PBENC\n:dd.Logical variable _#PBENC is set by the BLOCK macro to indicate that\na program block has been encountered.  _#PBENC is only used by the BLOCK\nmacro.\n.rc 2 on\n:dt._#PBERRA\n:dd.Logical variable _#PBERRA is set by the BLOCK macro to indicate that\nthe ERRADDR option is in effect.\n_#PBESV is used by the ##PPOS and ERREXIT\nmacros.\n:dt._#PBESV\n:dd.Logical variable _#PBESV is set by the BLOCK macro to indicate that\nthe ESV option is in effect.  _#PBESV is used by the ##PEOS and ##PPOS\nmacros.\n:dt._#PBESVP\n:dd.Arithmetic variable _#PBESVP is used to hold the parameter number\nthat contains the ESV pointer.  _#PBESVP\nis used by the ##PPOS macro.\n:dt._#PBFNCD\n:dd.Logical variable _#PBFNCD is set by the BLOCK macro to indicate that\nthe FNCODE option is in effect.  _#PBFNCD is only used by the BLOCK\nmacro.\n:dt._#PBFNCP\n:dd.Arithmetic variable _#PBFNCD is used to hold the parameter number\nthat contains the function code .  _#PBFNCD is used by the ##PPOS\nmacro.\n.rc 2 off\n:dt._#PBGTMN\n:dd.Logical variable _#PBGTMN is set by a program block prolog macro to\nindicate that a GETMAIN was done.  This tells the corresponding epilog\nmacro to do a FREEMAIN.  _#PBGTMN is used in macros ##PEOS and ##PPOS.\n:dt._#PBLOCR\n:dd.Logical variable _#PBLOCR is set by a program block prolog macro to\nindicate if the LOCTR option is in effect.  _#PBLOCR is used in macros\n##PEDC, ##PPDC, ##PPPLI, ##PPOS, ##SESTD, ##SPSTD, ##WESTD and EXI.\n:dt._#PBLONG\n:dd.Logical variable _#PBLONG is set by a program block prolog macro to\nindicate if the LONG option is in effect.  _#PBLONG is used by macros\n##PPDC, ##PPPLI, ##PPOS, ##SPSTD and CALLSUB.\n:dt._#PBMAIN\n:dd.Logical variable _#PBMAIN is set by a program block prolog macro to\nindicate if the MAIN option is in effect.  _#PBMAIN is used by macros\n##PEOS, ##PPPLI and ##PPOS.\n:dt._#PBNAME\n:dd.Character variable _#PBNAME is used to hold the program block CSECT\nname.  Macros can use the variable in the name field of a CSECT\nstatement to get back in the CSECT of the program.  _#PBNAME is used by\nmacros ##PEDC, ##PPDC, ##PPPLI, ##SESTD, ##UESTD, ##WESTD, BLOCK, ENDPSD\nand ENDSSD.\n:dt._#PBNDX\n:dd.Arithmetic variable _#PBNDX holds the value of _#MNDX used by the\ncurrent program block.  _#PBNDX is used by macros ##EESTD, ##EPSTD,\n##PEDC, ##PEPLI, ##PEOS, ##PPDC, ##PPOS, ##SPSTD, BLOCK and ERREXIT.\n:dt._#PBNRSV\n:dd.Logical variable _#PBNRSV is set by the standard program block\nprolog macro to inform the corresponding epilog macro that a\nnon-reentrant save area is in use.  _#PBNRSV is used by macros ##PEOS\nand ##PPOS.\n:dt._#PBOPTS\n:dd.Logical variable _#PBOPTS is used to indicate whether the OPTSTOR\noption is in effect.  _#PBOPTS is used by macros ##PPOS and ##SPSTD.\n:dt._#PBPLMX\n:dd.Arithmetic variable _#PBPLMX is used to keep up with the maximum\nnumber of words that needs to be generated by the PWA macro to hold\nparameter lists.  _#PBPLMX is used by macros ##PPPLI, ##PPOS, ##WPPLI,\n##WPOS, BLOCK and PLIST.\n:dt._#PBPPWA\n:dd.Logical variable _#PBPPWA is used to keep track of whether a partial\nPWA has been encountered.  _#PBPPWA is used by macros ##WESTD, ##WPPLI\nand ##WPOS.\n:dt._#PBPWA\n:dd.Logical variable _#PBPWA is used to indicate whether the program\nblock has an associated PWA.  _#PBPWA is used by macros ##PEDC, ##PEOS,\n##PPDC, ##PPPLI, ##PPOS, ##SESTD, ##SPSTD, ##WPPLI, ##WPOS and PLIST.\n.rc 2 on\n:dt._#PBPWAP\n:dd.Arithmetic variable _#PBPWAP is used to hold the parameter number\nthat contains the PWA anchor for reusable PWAs.\n_#PBPWAP is used by macros ##PEOS and ##POOS.\n.rc 2 off\n:dt._#PBRMOD\n:dd.Character variable _#PBRMOD holds the RMODE of the program block's\nCSECT.  _#PBRMOD is used in macros ##PPDC, ##PPPLI and ##PPOS.\n.rc 2 on\n:dt._#PBRPWA\n:dd.Logical variable _#PBRPWA is used to indicate whether the REUSPWA\noption is in effect.  _#PBRPWA is used by macros ##PEOS and ##PPOS.\n.rc 2 off\n:dt._#PBRTN0\n:dd.Logical variable _#PBRTN0 is used to indicate whether the RTNR0\noption is in effect.  _#PBRTN0 is used by macros ##EESTD, ##PEOS\nand ##PEDC.\n:dt._#PBRTN1\n:dd.Logical variable _#PBRTN1 is used to indicate whether the RTNR1\noption is in effect.  _#PBRTN1 is used by macros ##EESTD, ##PEOS\nand ##PEDC.\n:dt._#PBSAVE\n:dd.Logical variable _#PBSAVE is used to indicate whether the SAVE\noption is in effect for the program block.  _#PBSAVE is used by macros\n##PEOS and ##PPOS.\n:dt._#PBSDID\n:dd.Character variable _#PBSDID is used to hold the ID to be used in\ngenerating PSD fields.  _#PBSDID is use in macros ##PPDC, ##PPPLI and\n##PPOS.\n:dt._#PBSMWA\n:dd.Character variable _#PBSMWA is used to hold the tag that refers to\nthe program block's Structured Macro Work Area.  _#PBSMWA is used by\nmacros ##EESTD, ##IESTD, ##PEDC, ##PPDC, ##PPPLI, ##PPOS, ##RWREG,\n##SWREG, LEAVE and PLIST.\n:dt._#PBVL\n:dd.Logical variable _#PBVL is used to indicate whether the VL option is\nin effect for the program block.  _#PBVL is used by macros ##PPDC,\n##PPPLI, ##PPOS and PLIST.\n:dt._#PBWAID\n:dd.Character variable _#PBWAID is used to hold the ID to be used in\ngenerating PWA fields.  _#PBWAID is use in macros ##PPDC, ##PPPLI,\n##PPOS, ##WESTD, ##WPPLI and ##WPOS.\n:dt._#PBWAMX\n:dd.Arithmetic variable _#PBWAMX holds the number of words in the\nSMWA that is automatically generated by the PWA macro.\n_#PBMAMX is use by macros ##PPDC, ##PPPLI, ##PPOS, ##WPPLI, ##WPOS and\nBLOCK.\n:dt._#PBXA\n:dd.Logical variable _#PBXA indicates whether the XA option is in\neffect.  It is used by macros ##EESTD, ##EPSTD, ##IESTD, ##IPSTD,\n##LDBS, ##PEDC, ##PPDC, ##PPPLI, ##PPOS, ##SESTD, ##SPSTD, CALLSUB,\nCALLX, LEAVE and PLIST.\n:dt._#PB370\n:dd.Logical variable _#PB370 indicates whether the 370 option is in\neffect.  It is used by macros ##EESTD, ##EPSTD, ##IESTD, ##IPSTD,\n##LDBS, ##PEDC, ##PPDC, ##PPPLI, ##PPOS, ##SESTD, ##SPSTD, CALLSUB,\nCALLX, LEAVE and PLIST.\n:dt._#PEMAC\n:dd.Character variable _#PEMAC holds the default program block epilog\nmacro name.  _#PEMAC is used in macros ##$DC, ##$PLI, ##$STD and ENDBLK.\n:dt._#PPMAC\n:dd.Character variable _#PPMAC holds the default program block prolog\nmacro name.  _#PPMAC is used in macros ##$DC, ##$PLI, ##$STD and BLOCK.\n:dt._#REG(16)\n:dd.Logical array _#REG is used by macro ##MREG to keep up with which\nregisters are used.  _#REG is only used by macro ##MREG.\n:dt._#SB#C\n:dd.Arithmetic variable _#SB#C is used to hold the current subroutine\nblock number.  _#SB#C is used by macros ##PEDC, ##SESTD, ##SPSTD,\n##UESTD, ##UPSTD, BLOCK, CALLSUB, ENDPSD, ENDSSD, PLIST, SSD and STRSA.\n:dt._#SB#CPB\n:dd.Arithmetic variable _#SB#CPB is used to hold the\n:q.subroutine block number:eq. of the current program block.\n_#SB#CPB is used by macros ##WESTD, BLOCK and CALLSUB.\n:dt._#SB#D\n:dd.Arithmetic variable _#SB#D is passed back from ##DEFSUB to\nindicate the number of the block just defined.  _#SB#D is used by\nmacros ##DEFSUB, ##SPSTD, BLOCK and CALLSUB.\n:dt._#SB#M\n:dd.Arithmetic variable _#SB#M holds the maximum subroutine block\nnumber.  _#SB#M is used by macros ##DEFSUB and ##WESTD.\n:dt._#SBCSTM\n:dd.Logical variable _#SBCSTM indicates whether the CUSTOM subroutine\noption is in effect.  _#SBCSTM is used by macros ##EPSTD, ##PEDC,\n##SESTD, ##SPSTD, ##SUBOPT and ENDBLK.\n:dt._#SBLDBS\n:dd.Logical variable _#SBLDBS indicates whether the LOADBASE subroutine\noption is in effect.  _#SBLDBS is used by macros ##EPSTD, ##SPSTD,\n##SUBOPT and SSD.\n:dt._#SBNM(99)\n:dd.Character array _#SBNM is used to hold all of the subroutine names\nencountered in the assembly.  The subroutine number as returned by\n##DEFSUB is used as an index.  _#SBNM is used by macros ##DEFSUB,\n##ORGS, ##SPSTD and ##WESTD.\n:dt._#SBORGC\n:dd.Arithmetic variable _#SBORGC is an ORG counter.  _#SBORGC is only\nused by macro ##ORGS.\n:dt._#SBPLMX\n:dd.Arithmetic variable _#SBPLMX is used to keep up with the maximum\nnumber of words that needs to be generated by the SWA macro to hold\nparameter lists.  _#SBPLMX is used by ##PEDC, ##SESTD, ##SPSTD, ##UPSTD,\nBLOCK, ENDBLK and PLIST.\n:dt._#SBPSWA\n:dd.Logical variable _#SBPSWA is used to keep track of whether a partial\nSWA has been encountered.  _#SBPSWA is used by ##UESTD and ##UPSTD.\n:dt._#SBREC(99)\n:dd.Arithmetic array _#SBREC is used to hold the value from the RECUR\nkeyword for subroutines.  The subroutine number returned from ##DEFSUB\nis used as an index.  _#SBREC is used by macros ##ORGS and ##SPSTD.\n:dt._#SBSU\n:dd.Logical variable _#SBSU indicates whether the SAVEUSING subroutine\noption is in effect.  _#SBSU is used in macros ##EPSTD, ##PEDC, ##PPPLI,\n##PPOS, ##SESTD, ##SPSTD and ##SUBOPT.\n:dt._#SBSWA\n:dd.Logical variable _#SBSWA indicates whether the SWA subroutine option\nis in effect.  _#SBSWA is used in macros ##EPSTD, ##PEDC, ##SESTD,\n##SPSTD, ##SUBOPT, ##UPSTD, ##WPPLI, ##WPOS, PLIST and STRSA.\n:dt._#SBUSWA\n:dd.Logical variable _#SBUSWA indicates whether the USERSWA subroutine\noption is in effect.  _#SBSWA is used in macros ##EPSTD, ##PEDC,\n##PPOS, ##SESTD, ##SPSTD and ##SUBOPT.\n:dt._#SBWAMX\n:dd.Arithmetic variable _#SBWAMX is used to indicate how many\nfullwords are to be reserved in the SWA for use by the Structured\nMacros.  This ability is currently not being used.  _#SBWAMX is\nused by macro ##UPSTD.\n:dt._#SDCSTM\n:dd.Logical variable _#SDCSTM is used to hold the default state of the\nCUSTOM subroutine option.  _#SDCSTM is used by macros ##SUBOPT.\n:dt._#SDLDBS\n:dd.Logical variable _#SDLDBS is used to hold the default state of the\nLOADBASE subroutine option.  _#SDLDBS is used by macros ##SUBOPT.\n:dt._#SDLVL\n:dd.Arithmetic variable _#SDLVL is used to hold the structural level of\nstatic data.  _#SDLVL is used in macros ENDPSD, PSD and SSD.\n:dt._#SDPSD\n:dd.Logical variable _#SDPSD indicate whether a PSD macro has been\nencountered and an ENDPSD has not.  _#SDPSD is used in macros ENDPSD and\nPSD.\n:dt._#SDSSD\n:dd.Logical variable _#SDSSD indicate whether a SSD macro has been\nencountered and an ENDSSD has not.  _#SDSSD is used in macros ENDSSD and\nSSD.\n:dt._#SDSU\n:dd.Logical variable _#SDSU is used to hold the default state of the\nSAVEUSING subroutine option.  _#SDSU is used by macros ##SUBOPT.\n:dt._#SDSVLC\n:dd.Character variable _#SDSVLC is used to save the location counter.\n_#SDSVLC is used by macros ENDPSD, ENDSSD, PSD and SSD.\n:dt._#SDSWA\n:dd.Logical variable _#SDSWA is used to hold the default state of the\nSWA subroutine option.  _#SDSWA is used by macros ##SUBOPT.\n:dt._#SDUSWA\n:dd.Logical variable _#SDUSWA is used to hold the default state of the\nUSERSWA subroutine option.  _#SDUSWA is used by macros ##SUBOPT.\n:dt._#SEMAC\n:dd.Character variable _#SEMAC holds the default subroutine block epilog\nmacro name.  _#SEMAC is used in macros ##$DC, ##$PLI, ##$STD and ENDBLK.\n:dt._#SPMAC\n:dd.Character variable _#SPMAC holds the default subroutine block prolog\nmacro name.  _#SPMAC is used in macros ##$DC, ##$PLI, ##$STD and BLOCK.\n:dt._#UEMAC\n:dd.Character variable _#UEMAC holds the default Subroutine Work Area\nepilog macro name.  _#UEMAC is used in macros ##$DC, ##$PLI, ##$STD and\nENDSWA.\n:dt._#UPMAC\n:dd.Character variable _#UPMAC holds the default Subroutine Work Area\nprolog macro name.  _#UPMAC is used in macros ##$DC, ##$PLI, ##$STD and\nSWA.\n:dt._#WEMAC\n:dd.Character variable _#WEMAC holds the default Program Work Area\nepilog macro name.  _#WEMAC is used in macros ##$DC, ##$PLI, ##$STD and\nENDPWA.\n:dt._#WPMAC\n:dd.Character variable _#WPMAC holds the default Program Work Area\nprolog macro name.  _#WPMAC is used in macros ##$DC, ##$PLI, ##$STD and\nPWA.\n:dt._#XAWARN\n:dd.Logical variable _#XAWARN is used to indicate whether the warning\nmessage has been issued indicating that the XA option was not specified.\nThis flag is used so that this message can be issued only once.\n_#XAWARN is used by macros ##IPSTD, ##PPDC, ##SPSTD and PLIST.\n:edl.\n.*\n:h1.Labels\n:p.\nThis chapter contains all of the labels used by the Structured\nMacros.  Each label begin with a :q.#:eq. and contains\na symbolic variable.  The symbolic variable listed may not\nbe the actual variable used to create the label name, but it is\nrepresentative of the variable used in the macros.\n:dl tsize=25.\n:dt._#PBWAID\n:dd.The label contained in\n_#PBWAID is set to the name of the PWA DSECT and is used as\nthe prefix of some PWA field names.  _#PBWAID is used in macros\n##PPDC, ##PPPLI, ##PPOS, ##WESTD, ##WPDC, ##WPPLI, and ##WPPLI.\n:dt._#PBWAID.PLLEN\n:dd.Label _#PBWAID.PLLEN is used by macros ##PPDC, ##PPPLI, ##PPOS and\n##WESTD as a tag that have the length of the PWA as its value.\n:dt._#PBWID.X...\n:dd.Labels _#PBWAID.XALWS, _#PBWAID.XANAB, _#PBWAID.XANAB,\n_#PBWAID.XBCH, _#PBWAID.XBCH, _#PBWAID.XCEC, _#PBWAID.XCEC,\n_#PBWAID.XF1A, _#PBWAID.XF1B and _#PBWAID.XS1 are used by macros\n##PPPLI and ##WPPLI to refer to fields in a PLI style DSA.\n:dt.#BE_#BNDX(_#BLVL)\n:dd.Label #BE_#BNDX(_#BLVL) is generated by macro ENDBLK.  Macro LEAVE\ngenerates a branch to this tag for leaving a block.\n:dt.#BF_#PBNDX\n:dd.Label #BF_#PBNDX is used internal to macro ##PEOS for branching\naround freemain code if dynamic storage was used for the current PWA.\n.rc 2 on\n:dt.#BH_#PBNDX\n:dd.Label #BH_#PBNDX is used by macro ##PPOS for generating code\nto support reusable PWAs.\n.rc 2 off\n:dt.#BI_#PBNDX\n:dd.Label #BI_#PBNDX is used by macro ##PPOS to branch around some\nsubroutine prolog code when using option DYN and OPTSTORAGE.\n:dt.#BJ_#MNDX\n:dd.Label #BJ_#MNDX is used by macros ##PPDC, ##PPPLI and ##PPOS\nas the tag for a fullword that contains the address of the PWA.\n:dt.#BK_#PBNDX\n:dd.Label #BK_#PBNDX is generated by macro ##PPOS as the tag for\nthe dynamic storage subroutine prolog that is generated as a result\nof options DYN and OPTSTORAGE.  Macro ##SPSTD generates a BAL\ninstruction to this tag.\n.rc 2 on\n:dt.#BL_#PBNDX\n:dd.Label #BL_#PBNDX is used by macro ##PEOS to hop around code to\nfree the reusable PWA.\n:dt.#BM_#PBNDX\n:dd.Label #BM_#PBNDX is used by macro ##PPOS as the tag for\nthe DC for the start function.\n:dt.#BN_#PBNDX\n:dd.Label #BN_#PBNDX is used by macro ##PPOS for generating code\nto support reusable PWAs.\n.rc 2 off\n:dt.#BO_#MNDX\n:dd.Label #BO_#MNDX is used by macro ##PPOS as the tag for the default\ndynamic error routine if option DYN is in effect and keyword DYNERR\nis not specified.  The default error routine is a :q.DC H'0':eq. which\ncauses an abend S0C1.  If this default label is used, it is assigned\nto variable _#PBDERR which is used in macros ##PPOS and ##SPSTD.\n:dt.#BP_#MNDX\n:dd.Label #BP_#MNDX is used by macros ##PPDC, ##PPPLI and ##PPOS\nin the generation of\ncode to branch around constants generated at the top\nof a CSECT.\n:dt.#BQ_#PBNDX\n:dd.Label #BQ_#PBNDX is generated by macros ##PEDC, ##PEPLI, and\n##PEOS and is the tag that is branched to by ##EESTD to leave\nthe program.\n:dt.#BS_#MNDX\n:dd.Label #BS_#MNDX is used internally by macro ##PPPLI to skip the\ncall to the PLI storage overflow routine.\n:dt.#BU_#MNDX\n:dd.Label #BU_#MNDX is used internally by macro ##PPOS and is used\nas the tag for a fullword displacement of the first NAB from the\nstart of the PWA.\n:dt.#BV_#BNDX(_#BLVL)\n:dd.Label #BV_#BNDX(_#BLVL) is used internally by macros ##EESTD and\n##IESTD for branching around amode switching code when not running\nunder XA.\n:dt.#BW_#BNDX(_#BLVL)\n:dd.Label #BW_#BNDX(_#BLVL) is used internally by macros ##EESTD and\n##IESTD as a tag for a fullword used for switching to amode 31.\n:dt.#BW_#MNDX\n:dd.Label #BW_#MNDX is used by macro ##PPOS as the tag for a fullword\ncontaining the length of the PWA.\n:dt.#BX_#PBNDX\n:dd.Label #BX_#PBNDX is used as the name of the single possible\nunnamed error exit by macros ##EPSTD and ERREXIT.\n:dt.#BY_#MNDX\n:dd.Label #BY_#MNDX is used by macros ##EPSTD, ##IPSTD, ##PPDC, ##PPPLI,\n##PPOS and ##SPSTD for branching around amode setting code when not\nrunning on XA.\n:dt.#BZ_#MNDX\n:dd.Label #BZ_#MNDX is used internally by macros ##EPSTD, ##IPSTD and\n##SPSTD as a tag for a fullword used for switching to amode 31.\n:dt.#CC_#MNDX\n:dd.Label #CC_n is used as the tag for the start of a given case\nand is refered to by the displacement table generated by the\nENDCASE macro.\n:dt.#CE_#CNDX(_#CLVL)\n:dd.Label #CE_#CNDX(_#CLVL) is the tag used for the end of a case\nblock and is used by macros ENDCASE and LEAVE.\n:dt.#CM_#CNDX(_#CLVL)\n:dd.Label #CM_#CNDX(_#CLVL) is the tag of a halfword that contains\nthe size of the case displacement table.  Code for this label is\ngenerated by macros CASEBLK and ENDCASE.\n:dt.#CO_#CNDX(_#CLVL)\n:dd.Label #CO_#CNDX(_#CLVL) is the tag for case :q.other:eq..  Code\nwith this label is generated by macros CASE, CASEBLK, and ENDCASE.\n:dt.#CP_#MNDX\n:dd.Label #CP_#MNDX is used by macro CALLX for branching around a\n:q.BASR:eq. instruction when generating bimodal instructions.\n:dt.#CS_#CNDX(_#CLVL)\n:dd.Label #CS_#CNDX(_#CLVL) is used by macro CASEBLK as the tag on\nthe :q. B *(reg):eq. instruction it generates.\n:dt.#CT_#CNDX(_#CLVL)\n:dd.Label #CT_#CNDX(_#CLVL) is the label for the start of the case\ndisplacement table.  This label is used in macros CASEBLK and ENDCASE.\n:dt.#CX_#MNDX\n:dd.Label #CX_#MNDX is used internally to the CALLX macro for branching\naround amode switching code when not running under XA.\n:dt.#DB_#DNDX(_#DLVL)\n:dd.Label #DB_#DNDX(_#DLVL) is the loop begin tag.  It is used by macros\nLOOP and ENDLOOP.\n:dt.#DE_#DNDX(_#DLVL)\n:dd.Label #DE_#DNDX(_#DLVL) is the loop end tag.  It is used by macros\nLEAVE, LOOP and ENDLOOP.\n:dt.#DS_#MNDX\n:dd.Label #DS_#MNDX is used by the LOOP macro as the :q.success tag:eq.\nfor WHILE loops.\n:dt.#EX#_#MNDX\n:dd.Label #EX#_#MNDX is used as the tag of the executed instruction by\nthe EXI macro.\n:dt.#EXEND#_#MNDX\n:dd.Label #EXEND#_#MNDX is used by the EXI macro for branching around\n:q.executed:eq. instruction when the LOCTR option is not in effect.\n:dt.#ID_#PB#C\n:dd.Label #ID_#PB#C is used by the ##PPDC macro for branching around\nthe #GETSTG storage id.\n:dt.#IE_#INDX(_#ILVL)\n:dd.Label #IE_#INDX(_#ILVL) is the :q.end of if:eq. tag.  if is used\nby macros ENDIF, ELSE, ELSEIF and LEAVE.\n:dt.#IF_#INDX2(_#ILVL)\n:dd.Label #IF_#INDX2(_#ILVL) is the fail tag used on ##COND in the IF\nand ELSEIF macros.  This tag is used in ELSE, ELSEIF, ENDIF and IF.\n:dt.#IF_#MNDX\n:dd.Label #IF_#MNDX is used internally to ##COND as an :q.if fail:eq.\ntag.\n:dt.#IS_#MNDX\n:dd.Label #IS_#MNDX is used internally to ##COND, ELSEIF, and IF\nas an :q.if success:eq. tag.\n:dt.#LE_#MNDX\n:dd.Label #LE_#MNDX is used internally by macro LCBA for various\nbranching.\n:dt.#LF_#MNDX\n:dd.Label #LF_#MNDX is used internally by macro LCBA for various\nbranching and by ERREXIT and LEAVE as a :q.leave fail:eq. tag.\n:dt.#LL_#MNDX\n:dd.Label #LL_#MNDX is used internally by macro LCBA for various\nbranching.\n:dt.#LQ_#MNDX\n:dd.Label #LQ_#MNDX is used internally by ##LDBS.\n:dt.#LR_#MNDX\n:dd.Label #LR_#MNDX is used internally by ##LDBS.\n:dt.#LS_#MNDX\n:dd.Label #LS_#MNDX is used internally by ##LDBS and used as a :q.leave\nsuccess:eq. tag in LEAVE.\n:dt.#LV_#MNDX\n:dd.Label #LV_#MNDX is used internally by LEAVE to branch around\namode switching code when not running under XA.\n:dt.#LW_#MNDX\n:dd.Label #LW_#MNDX is used internally by the LEAVE macro when\nswitching to amode 31.\n:dt.#PBDL_#PB#C\n:dd.Label #PBDL_#PB#C is the LOCTR name of the programs static data\nand for a subroutines static data if subroutine option LOADBASE is\nnot in effect.\n:dt.#PBE_#PB#C\n:dd.Label #PBE_N is the tag for EOS-64 in the PWA when the DYN option\nis in effect.  This tag is used in macros ##WPDC, ##WPOS and ##PPOS.\n:dt.#PBG_#PB#C\n:dd.Label #PBG_#PB#C is used internally to macro ##PPOS for skipping\na getmain if options NOMAIN and DYN are in effect and there is already\nroom in dynamic storage for the new PWA.\n:dt.#PBJ_#PB#C\n:dd.Label #PBJ_#PB#C is the tag used on the DC instruction for a\nnon-reentrant PWA.  Macros ##PPOS, #PPDC and ##WPOS use this tag.\n:dt.#PBK_#PB#C\n:dd.Label #PBK_#PB#C is used internally to macro ##PPOS for skipping\na getmain if options NOMAIN and DYN are in effect and there is already\nroom in dynamic storage for the new PWA.\n.rc 2 on\n:dt.#PBL_#PB#C\n:dd.Label #PBK_#PB#C is used by ##PEOS and ##PPOS to reference the ESV.\n.rc 2 off\n:dt.#PBN_#PB#C\n:dd.Label #PBN_N is the tag of the NAB in the PWA.  This label is used\nby macros ##PPOS, ##WPDC and ##WPOS.\n:dt.#PBP_#PB#C\n:dd.Label #PBP_#PB#C is the tag used for parameter storage in the\nPWA.  This tag is used by macros PLIST, ##WPDC, ##WPPLI and ##WPOS.\n:dt.#PBR_#PB#C\n:dd.Label #PBR_N is the tag for a reserved field in the PWA.  This\ntag is generated by macros ##WPDC and ##WPOS.\n:dt.#PBS_#PB#C\n:dd.Label #PBS_#PB#C is used by macro #WPOS as the tag for the\nstandard OS save area in the PWA.\n:dt.#PBU_#PB#C\n:dd.Label #PBU_N is the :q.start of user storage:eq. tag in the PWA.\nThis label is used by macros ##WPDC, ##WPPLI and ##WPOS.\n:dt.#PBW_#PB#C\n:dd.Label #PBW_#PB#C is the tag used for the default SMWA in the PWA.\nIt is assigned to variable _#PBSMWA.  This label is used by macros\n##PPDC, ##PPPLI, ##PPOS, ##EESTD, ##IESTD, ##RWREG, ##SWREG ##WPDC,\n##WPPLI and ##WPOS.\n:dt.#PBX_#PB#C\n:dd.Label #PBX_#PB#C is the tag in the pwa that is at the start of\nthe extra storage reserved for SWAs and PWAs.  This label is used by\nmacros ##PPOS and ##WESTD.\n:dt.#SB$_#SBORGC\n:dd.Label #SB$_#SBORGC is used internally to the ##ORGS macro.\n:dt.#SBAD_#SB#D\n:dd.Label #SBAD_#SB#D is used internally to the CALLSUB macro as a\ntag for a DC instruction for the subroutine block being called.  This\ntag is only used if the LONG option is in effect.\n:dt.#SBD_#SB#C\n:dd.Label #SBD_#SB#C is the DSECT name of SWAs.  It is used by macros\n##SPSTD, ##UESTD and ##UPSTD.\n:dt.#SBDL_#SB#C\n:dd.Label #SBDL_#SB#C is the LOCTR name for a subroutine block's SSD.\nThis tag is used by macros ##SPSTD and SSD.\n:dt.#SBIL_#SB#C\n:dd.Label #SBIL_#SB#C is the LOCTR name for a subroutine block's\ninstructions.\nThis tag is used by macro ##SPSTD.\n:dt.#SBL_#CST(_CTR)\n:dd.Label #SBL_#CST(_CTR) is the :q.length of SWA:eq. tag.  It is used\nby macros ##ORGS, ##SESTD and ##UESTD.\n:dt.#SBLT_#SB#C\n:dd.Label #SBLT_#SB#C is tag for a halfword containing the length of\na subroutine's SWA.  This label is used internally to ##SPSTD.\n:dt.#SBN_#SB#C\n:dd.Label #SBN_#SB#C is the tag for the NAB in the SWA with the DYN\noption is in effect.  This label is used in ##UPSTD.\n:dt.#SBP_#SB#C\n:dd.Label #SBP_#SB#C is the tag for the parameter storage in an SWA.\nThis label is used in macros ##SESTD, ##UPSTD and PLIST.\n:dt.#SBS_#SB#C\n:dd.Label #SBS_#SB#C is the tag for the save area storage in an SWA.\nThis label is used in macros ##SESTD and ##UPSTD.  It is assigned to\nvariable _#BSV3(_#BLVL) which is used in macros ##SPSTD, ##EPSTD,\n##IPSTD, ##SPSTD and ##RST.\n:dt.#SBU_#SB#C\n:dd.Label #SBU_#SB#C is the tag for the start of user storage in an SWA.\nThis label is used in macro ##UPSTD.\n:dt.#SBW_#SB#C\n:dd.Label #SBW_#SB#C is the tag for the Structured Macro Work Area\nin an SWA.\nThis label is used in macro ##UPSTD.\n:dt.#ST_#PB#C\n:dd.Label #ST_#PB#C is used internally by ##PPDC as the tag for the\nDC for the EP name.\n:dt.#U_#PB#C\n:dd.Label #U_#PB#C is the default id for PSDs.  This label is assigned\nto _#PBSDID in macros ##PPPLI, ##PPOS and ##PPDC.\n:dt.#W_#PB#C\n:dd.Label #W_#PB#C is the default id for PWAs.  This label is assigned\nto _#PBWAID in macros ##PPPLI, ##PPOS and ##PPDC.\n:edl.\n:egdoc\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$USERGDE": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x17(\\x17(\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 5928, "newlines": 5928, "modlines": 0, "user": "CLEMSON"}, "text": ".*\n.* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n.* <<<<<<<<<<<<<<<<<<<<<<<<<<  NOTE   >>>>>>>>>>>>>>>>>>>>>>>>>>>\n.*  This file is part of the PRINTDOC system.  If this file is\n.*   moved or if its formatting characteristics change, the PRINTDOC\n.*   systems will have to be updated.\n.*\n.*  If this file is updated, please change ACS.PRINTDOC.INDEX(MANUALS)\n.*   to reflect the new revision date.  This allows users to know\n.*   when they should print a new copy.\n.* <<<<<<<<<<<<<<<<<<<<<<<<<<  NOTE   >>>>>>>>>>>>>>>>>>>>>>>>>>>\n.* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n.*\n.*  This is the Structured Macros Reference and User's Guide\n.*  coded to use GML tags.  It should be invoked with options\n.*  PASS(2) SYSVAR('D YES T CENTER H YES') SEC(32) PAGES(150)\n.*\n.df data type('data1' 8) codepage t1d0base\n.ll 6.5i\n:gdoc.\n:frontm.\n.ti ! 05\n.dh 0 spbf 4.5i\n.rc 1\n.rc 2\n.rc 3 |\n.rc 4 |\n.se @bodyhead1 = 'Chapter'\n.df figfont list (xmpfont)\n:titlep.\n:title stitle='Clemson Structured Macros'.\nClemson University Computer Center\n:title.Structured Programming Macros\n:title.User's Guide And Reference\n:date.\n:author.Last revision: November 6, 1989\n:etitlep.\n:preface.\n:p.\nThe Structured Programming Macros is a programming tool developed\nat Clemson University for internal use by the staff of the\nComputer Center.  However, after they were written, the decision\nwas made to release them to the public since they are very useful\nto anyone who is programming in System/370 Assembler language.\n:p.\nThe macros were designed to make the programmer's job easier by\nhandling the often confusing but necessary code needed in any\nprogram.  Things like program linkage, subroutines, parameter\nlists, loops, and conditional sections are handled\neasily by use of the macros.  This allows the user to concentrate\non the program instead of the details, and also helps make\nthe code much easier to read and debug.\n:p.\nThe Structured Programming Macros provide a means by which the\nAssembler programmer can use logical programming structures\nnormally available only in high-level languages.\nStructures like DO WHILE, DO UNTIL, IF-THEN-ELSE, and CASE\nare available directly through the macros.  More complex structures,\nsuch as SEARCH, may be coded simply through a combination of the\nmacros.\nIn addition, some useful macros that perform common\nfunctions (such as flipping bits and clearing storage) are provided\nas a convenience.\n:p.\nThe macros are packaged in a macro library which may be concatenated\nto SYSLIB for Assembler H.\n(There are catalogued procedures available at Clemson that concatenate\nthis macro library to SYS1.MACLIB.)\n:p.\nAmong other things, the Structured Programming Macros may be used\nto handle addressing mode switching and linkage\nunder MVS/XA.\nShould you wish to use the 31-bit addressing features, you should be\nfamiliar with the concepts described in\n:cit.MVS/XA SPL: 31-Bit Addressing,:ecit. GC28-1158.\nUsing the macros, it becomes very simple\nto change and restore addressing modes, both inline\nand for subroutine calls.\n:p.\nSince the Structured Programming Macros provide all of the needed\ncontrol structures, the user should not have to code any branch\ninstructions (and associated statement labels) in a program.\nThis makes the source code much neater and easier to read.\n:p.\nThis document will serve as an introduction to the Structured\nProgramming Macros, and assumes that the reader is already familiar\nwith the uses of common structured programming techniques.\nWhile the Structured Programming Macros\nserve as a programming aid,\nthey are not meant to be a substitute for\na working knowledge of System/370 Assembler language and System/370\narchitectures.\nWhen using these macros, the reader should not arbitrarily assume that\nwhat the macros generate is some kind of :q.magic code:eq.. It's not: in\nfact, the code generated by the macros\ntends to look a lot like what a competent programmer would\nwrite. When using the macros, look at the macro expansions\noccasionally. Knowing a little about how the macros work will help\nyou to make better use of them.\n.rc 3 on\n:note.\nIn order to achieve the desired level of functionality within the\nStructured Macros, they have been written in such a way as to\nrequire the use of the Level H Assembler.  Although some of the\nmacros might not currently require Assembler H,\nno guarantee is made that any of the features described here will\nwork with the Level F Assembler.\nUse of these macros with anything other than Assembler H\nis :hp2.not:ehp3. recommended.\n.rc 3 off\n.*\n:toc.\n.*\n:h1.Summary of Amendments\n.*\n.rc 4 on\n:h3.Update November 6, 1989\n:ol.\n:li.Two new macros (DEFUCOND and ##COND) are provided to allow the\nprogrammer to define new conditional tests that can be inserted into\nany conditional expression.\n:li.The COPYERROR and COUNT suboptions have been added to the\nPARMS option.\n:eol.\n.rc 4 off\n.*\n.rc 3 on\n:h3.Update April 19, 1989\n:ol.\n:li.The Structured Macros now require the Level H Assembler for\ncorrect operation.  Do not use them with the Level F Assembler.\n:li.Changes were made in the PLIST macro to allow more flexible\nspecification of parameters.  Most notably, indirect referencing\nis now supported.\n:li.Symbols have been provided to allow the program to locate the start\nof major structures such as the PWA, PSD, SWA, and SSD.\n:li.An automatic prefixing facility has been added to allow\nprogrammers to name storage tags in a subroutine without having to\nworry about what tags in other subroutines have been named.\n:li.A SMLIST macro has been added to control the output of the\nStructured Macros listing program.  Currently, the only option is\nto provide for automatic conversion of the program to uppercase\nbefore assembly.\n:eol.\n.rc 3 off\n.*\n.rc 2 on\n:h3.Update October 1, 1987\n:ol.\n:li.Support was added for writing Service Processors with the\nStructured Macros.  Service Processors are programs that are called\nrepeatedly to process one of a variety of functions, and that\nretain their workarea between calls.  To learn more about Service\nProcessors, see :cit.Clemson University Computer Center Service\nProcessor User's Guide and Reference:ecit..  The Service Processor\nsupport includes new options and keywords on the BLOCK macro and\na new super option.\n:li.The SMCTRL macro was added to set internal flags that affect\nthe operation of the Structured Macros.  Currently, this is only\nused for Service Processor support.\n:eol.\n.rc 2 off\n.*\n.rc 1 on\n:h3.Update March 11, 1987\n:ol.\n:li.An ENVIRON keyword was added to the BLOCK TYPE=PROGRAM macro to\nallow for the different linkage conventions in different program\nenvironments.  Currently, the supported environments are:  OS, DC, and\nPLI.\n:li.Support was added for PWAs in non-reentrant programs.\n:li.R0 and R1 keywords were added to the ENDBLK macro for programs\nto enable a program to pass back registers 0 and 1 to its caller.\n:li.The error messages issued by internal macros have been moved to\ntheir own section.\n:li.Minor editorial changes have been made.\n:eol.\n.rc 1 off\n.*\n.*\n:body.\n.* don't print running footing on next page.\n.rf odd sup\n:h0.I. Structured Macros User's Guide\n.* can print running footing after this page.\n.rf odd res\n.* set up new even page footing (change short title variable)\n.se @stitle 'Structured Macros Users's Guide\n.*\n.*\n:h1.Nesting Levels\n:p.\nThere are 4 major building blocks that\ncan be nested. These are the\n:hp1.block,:ehp1. the :hp1.if/elseif,:ehp1. the\n:hp1.loop,:ehp1. and the :hp1.case block.:ehp1.\nThe Structured Programming Macros support nesting to a depth of\n20 for each structure. The structures may be intermixed: for example,\na BLOCK can contain IF structures, and a LOOP may contain a CASE block,\nwhich may in turn contain more LOOPs.\nLevels of nesting are opened and closed by the use of complementary\nmacros, like BLOCK/ENDBLK, LOOP/ENDLOOP, IF/ENDIF and CASEBLK/ENDCASE.\n:p.\nThe user of these macros might find it helpful to start\nindenting source statements as nesting levels vary.\nSince no labels are required in the program code, the user can\ncode statement starting in column two and indent while\nstill leaving room for comments.\nConsider the\nfollowing examples: in the first, operands are coded\nin fixed columns, as is common practice.\n.tp 15 24 42\n:fig id=unind place=inline.\n.sk\n       BLOCK   NAME=TEST\n       IF  (condition1),THEN\n       LOOP      WHILE,(condition2)\n       LEAVE     (condition3,),IF=*\n       ENDLOOP  WHILE\n       ENDIF\n       ENDBLK\n:figcap.Unindented Assembler Source\n:efig.\n:p.\nIn :figref refid=indent., however,\nthe same instructions are indented based\non the nesting level of each.\nWhile the second example may look unusual to the hardened Assembler\nprogrammer, it's easier to follow\nthe nesting levels, and thus the logical structure, by sight alone.\n:fig id=indent place=inline.\n.sk\n BLOCK NAME=TEST\n  IF   (condition1),THEN\n   LOOP      WHILE,(condition2)\n    LEAVE    LOOP=*,(condition3)\n   ENDLOOP   WHILE\n  ENDIF\n ENDBLK\n:figcap.Indented Assembler Source\n:efig.\n:p.\nSince the macros require proper nesting of structures to generate\ntags for branches and the like,\ncorrect pairing of complementary macros is important.\nThe structured assembler cataloged procedures in use at Clemson\ninclude a pre-step that\nexamines your source for nesting problems and lists your program\nwith a nesting-level report. This pre-processor is described\nlater in :hdref refid=asmproc..\n:p.\nThe nesting of structures provides a very specific path for the\nprogram to follow.  This can be interrupted where necessary by\nthe use of the LEAVE macro.  This macro allows the program to\nleave a structure prematurely either conditionally or unconditionally.\nBy default, the LEAVE macro will leave the innermost structure\nof the type specified.  However, it can be used to exit a structure\nfrom any depth.  If you are leaving from a deeply nested\nseries of inline blocks, restoring registers and AMODEs properly\nis a complicated task.  The LEAVE macro can handle this task\nnicely.  The programmer should not have to worry about this.  You\ncan leave an arbitrarily complex structure and LEAVE will handle\nthe details.\n.*\n.*\n:h1 id=condch.Conditional Statements\n:p.\nUsing the Structured Macros, conditional expressions are defined in\nterms of the instruction(s) that will make the comparison.\nConditional expressions are mandatory on some macros (IF, ELSEIF, and\nsome forms of LOOP) and optional on others (LEAVE and ERREXIT).\nThe syntax of a conditional expression on each of these macros is\nidentical.\n:p.\n.rc 1 on\n.*\n:h2.Standard Conditions\nThe format of a single condition can be any of the following:\n:sl.\n:li.(:hp2.CLC,:ehp2.operand1,condition,operand2)\n:li.(:hp2.CR,:ehp2.operand1,condition,operand2)\n:li.(:hp2.C,:ehp2.operand1,condition,operand2)\n:li.(:hp2.CP,:ehp2.operand1,condition,operand2)\n:li.(:hp2.CH,:ehp2.operand1,condition,operand2)\n:li.(:hp2.CLR,:ehp2.operand1,condition,operand2)\n:li.(:hp2.CL,:ehp2.operand1,condition,operand2)\n:li.(:hp2.CLI,:ehp2.operand1,condition,operand2)\n:li.(:hp2.CLCL,:ehp2.operand1,condition,operand2)\n:li.(:hp2.TM,:ehp2.operand1,condition,operand2)\n:li.(:hp2.CLM,:ehp2.operand1,mask,condition,operand2)\n:li.(:hp2.TREG,:ehp2.operand1,condition)\n:li.(:hp2.TBIT,:ehp2.&lbt.operand1,&rbt.operand2&lbt.:hp2.\n.ct ,ON|OFF|ANY|MIXED:ehp2.&rbt.)  default ON\n:li.(:hp2.#TEST,:ehp2.operand1&lbt.:hp2.\n.ct ,ON|OFF|ANY:ehp2.&rbt.)  default ON\n:esl.\nwhere:\n:ul.\n:li.The first parameter is the machine or macro instruction\nthat is to be used to perform the comparison.\nCLC, CR, C, CP, CH, CLR, CL, CLI, CLCL,\nTM and CLM are all S/370 machine instructions.  TREG is a\nmacro that tests a register for zero, positive,\nor negative.  TBIT is another macro that is used\nfor testing bits.  As signified, the only conditions that\ncan be specified for TBIT are ON, OFF, ANY and MIXED.  #TEST\nsupports the IDMS/DC #TEST macro.  #TEST supports the\nconditions ON, OFF and ANY.\n:li.:hp2.operand1:ehp2. is the first operand of the\nspecified instruction or macro.  Any valid form of the operand\nfor the comparison being performed is allowed.\n:li.:hp2.operand2:ehp2. is the second operand of the\nspecified instruction or macro.  Any valid form of the operand\nfor the comparison being performed is allowed.\n:li.:hp2.mask:ehp2. is the mask operand of the CLM instruction and\ncan be any form that is valid in the instruction itself.\n:li.:hp2.condition:ehp2. may be coded as one of the following:\n:dl compact tsize=8.\n:dt.EQ\n:dd.Equal\n:dt.E\n:dd.Equal\n:dt.NE\n:dd.Not equal\n:dt.LT\n:dd.Less than\n:dt.GT\n:dd.Greater than\n:dt.LE\n:dd.Less than or equal\n:dt.GE\n:dd.Greater than or equal\n:dt.Z\n:dd.Zero\n:dt.NZ\n:dd.Not zero\n:dt.M\n:dd.Minus or mixed\n:dt.NM\n:dd.Not minus or not mixed\n:dt.P\n:dd.Positive\n:dt.NP\n:dd.Not positive\n:dt.O\n:dd.Ones or overflow\n:dt.NO\n:dd.Not ones or not overflow\n:dt.ON\n:dd.All flags on\n:dt.OFF\n:dd.All flags off\n:dt.ANY\n:dd.Any flags on\n:dt.MIXED\n:dd.Mixed\n:dt.CCnn\n:dd.Condition code, CC1 through CC14\n:edl.\n:eul.\n.rc 1 off\n:p.\nThe conditional expression coded will expand using the comparison\ninstruction(s) provided and appropriate conditional branches.\nFor example, instead of the expression :q.IF&rbl.A=B,THEN:eq., one\nwould code :q.IF&rbl.(CLC,A,EQ,B),THEN:eq., which would generate a\n:q.CLC&rbl.A,B:eq. and a BNE instruction to the appropriate ELSE,\nELSEIF or ENDIF macro.\n.*\n:h2.Coding Conditional Expressions\n:p.\nBoolean expressions and nested conditions are available\nwhen using the Structured Macros.\nUsing the Boolean operators AND, OR and NOT, conditional expressions\nmay be nested and/or concatenated on a single macro.\nUnder Assembler H (IEV90), the depth of nesting is\nlimited to 255 characters within the outer parentheses.\nMultiple conditions are evaluated\nfollowing the normal precedence rules with\nexpressions in parentheses taking precedence and\nNOT being\ndone before AND, and AND being done before OR.\n:p.\nFor example, one may code:\n:xmp.\n IF   NOT,(CLC,A,EQ,B)\n:exmp.\n:pc.\nwhich is equivalent to:\n:xmp.\n IF   (CLC,A,NE,B)\n:exmp.\n:pc.\nMultiple conditions may be coded together, as in this example:\n:xmp.\n IF   ((CLC,A,EQ,B),OR,(CLC,C,EQ,D),AND,(CLC,E,EQ,D))\n:exmp.\n:pc.\nwhich is equivalent to:\n:xmp.\n IF   ((CLC,A,EQ,B),OR,((CLC,C,EQ,D),AND,(CLC,E,EQ,D)))\n:exmp.\n:p.\nThe rules of Boolean algebra are followed by the Structured Macros.\nFor example, the Boolean expression :q.NOT (x AND y):eq. is equivalent\nto :q.NOT (x) OR NOT (y):eq..  Similarly, the IF statement\n:xmp.\n IF   (NOT,((CLC,A,EQ,B),AND,(CLC,C,EQ,D))),THEN\n:exmp.\n:pc.\nand the IF statement\n:xmp.\n IF   (NOT,(CLC,A,EQ,B),OR,NOT,(CLC,C,EQ,D)),THEN\n:exmp.\n:pc.\nand the IF statement\n:xmp.\n IF   ((CLC,A,NE,B),OR,(CLC,C,NE,D)),THEN\n:exmp.\n:pc.\nwill all generate identical code.\n:p.\nAlthough parentheses and the precedence rules affect the meaning\nof the expressions, the comparisons are always generated in the\norder that they are coded.  There are two cases where this is\nsignificant.  Consider the following example:\n:xmp.\n IF   ((CLI,A,EQ,C'Y'),AND,(C,R3,EQ,B))\n:exmp.\n:p.\nThe second comparison will only be done if the first one succeeds.\nThis can be very useful if you only have addressability for the\nsecond comparison if the first one is true.\nAnother case where coding order is important can be illustrated by\nthe following two IF statements:\n:xmp.\n IF   ((Z),OR,(CLC,A,EQ,B))\n IF   ((CLC,A,EQ,B),OR,(Z))\n:exmp.\n:p.\nIn the first example, the zero conditional test refers to the\ncondition code that exists from a previous instruction before\nthe IF is encountered.  In the second example, the zero conditional\ntest refers to the result of the compare that precedes it.\nBecause it is sometimes difficult to determine which comparisons\nwill actually be performed in a particular multiple condition IF\nstatement, it is usually a good practice to put a condition test\nwith no comparison only at the beginning of an IF.\n.rc 4 on\n.*\n:h2 id=ucond.User-Defined Conditions\n:p.\nAlthough the conditions supported by the Structured Macros cover most\nof the standard types of comparisions, there are occasionally\ninstances where they are not sufficient.  To avoid unpleasant\nside-effects, we have decided that our conditions will never modify\nstorage locations or registers.  Therefore, we do not have conditions\nfor things like TRT (Translate and Test) which modifies registers\none and two.  In addition, many programs will have tests involving more\nthan a simple compare that they do repeatedly.  It would be helpful to\nbe able to code these tests within a Structured Macros conditional\nexpression.\n:p.\nFortunately, there is a very easy way to get around both of these\nsituations.  The Structured Macros provide a facility to allow\nyou to define your own conditional tests that can be placed within\nany conditional expression.  User-defined conditions are identified\nby a percent sign (%) and may have any number of operands following\nthem.  For example, suppose you wanted to be able to code something\nlike this:\n:xmp.\nIF    ((TREG,R4,NZ),AND,(%TRT,0(8,R4),NE,PSDVALID))\n&invellip.\nENDIF\n:exmp.\nBefore you can use the %TRT condition, you need to do two things.\nFirst, you must define the condition name itself and identify the\nmacro that will process it.  This is done with the DEFUCOND macro.\nSecond, you must code the macro itself.  For our %TRT example, these\ntwo steps would look like this:\n:xmp.\n   DEFUCOND NAME=TRT,MACRO=TRT_UCOND   | Define the condition name.\n          MACRO\n &NAME    TRT_UCOND &EXPR,&S=,&F=,&L=  | Our TRT macro.\n          AIF (N'&EXPR NE 4).ERR0001   | Were we called wrong?\n &NAME    TRT   &EXPR(2),&EXPR(4)      | Do TRT instruction.\n          ##COND &EXPR(3),             | Test result and branch       +\n                S=&S,F=&F,L=&L         |   as appropriate.\n          MEXIT\n .ERR0001 MNOTE 8,'Too many parameters in %TRT expr'\n          MEND\n:exmp.\n:p.\nThere are several important requirements that all user-condition macros\nmust meet.  Once those are understood, writing these macros becomes\nquite simple.  First, the &NAME label is required and must identify\nthe first executable statement generated by your macro.  The Structured\nMacros will generate a unique label for &NAME so that they can branch\nto your condition when it is part of a compound conditional expression.\n:p.\nNext come the parameters that your macro will be called with.  The\nfirst parameter is positional and will be the entire condition that\ninvoked this macro including the condition name.  For our previous\nexample, this would be :hp2.(%TRT,0(8,R4),NE,PSDVALID):ehp2..\nThe individual fields within the condition can be extracted by\nsubscripting the expression.  For example &amp.EXPR(3) for the\nthird item in the expression (NE).\nThe next three keyword parameters (S=, F=, and L=) define the tag\nnames that the macro should branch to on success and failure and\nindicate the logic of this conditional (P for positive and N for\nnegative).\n:p.\nThe Logic keyword (L=) needs a little explaining.  Positive logic\nsays that the macro should branch to the success tag if the condition\nis true and fall through to the following code if the condition is\nfalse.  Positive logic is used for things like ERREXIT and LEAVE.\nNegative logic says to branch to the failure tag if the condition is\nfalse and fall through if it is true.  This is used in standard\nIF statements.\n:p.\nThe ##COND macro is an internal macro that should only be used\nwithin other macros.  Its purpose is to evaluate a conditional\nexpression and properly process the S=, F=, and L= keywords.\nThe expression passed to ##COND can be any valid conditional\nexpression including boolean expressions, nested conditions, and\nother user-defined conditions.  Most user-defined condition macros\nwill include a ##COND macro to perform the actual test and process\nthe S=, F=, and L= keywords.  This greatly simplifies the macro.\n:p.\nFor another example, what if you wanted to be able to check the\nstatus of ISPF like this?\n:xmp.\nIF    (%ISPFACT)\n&invellip.\nELSE\n&invellip.\nENDIF\n:exmp.\n:p.\nYou would need to define the %ISPFACT condition like this:\n:xmp.\n  DEFUCOND NAME=ISPFACT,MACRO=ISPF_UCOND\n          MACRO\n &NAME    ISPF_UCOND &EXPR,&S=,&F=,&L=\n          AIF (N'&EXPR NE 1).ERR0001   | Check number of parms.\n &NAME    LINK  EP=ISPQRY              | Call ISPF status routine.\n          ##COND (TREG,R15,Z),         | Check condition code.        +\n                S=&S,F=&F,L=&L\n          MEXIT\n .ERR0001 MNOTE 8,'Too many parameters in %ISPFACT expr'\n          MEND\n:exmp.\n:p.\nThere are several user-defined conditions provided in a copy member\ncalled SMPUCOND.  These should provide good examples of how to code\nuser conditions and may also be useful in programs.  You can include\nthem in your programs by placing a :hp2.COPY SMPUCOND:ehp2. statement\nat the start of your program.\n:note.\nBe careful when using conditions that modifiy registers or storage\nlocations.  When these conditions are used as part of a compound\nconditional expression, they can effect the other conditions in the\nexpression.  Be careful of your register usage in these cases and\nremember that although some conditions in an expression may be\nskipped because of the logic, conditions are always evaluated in the\norder they are coded.\n.rc 4 off\n.*\n.*\n:h1.Blocks\n:p.\nThere are 4 types of :hp1.blocks:ehp1. available\nwith the Structured Programming Macros. These are:\nthe :hp1.program:ehp1. block, the :hp1.inline:ehp1.\nblock, the :hp1.subroutine,:ehp1.\nblock, and the :hp1.errexit:ehp1. block.\nEach type of block may be named, and this name may be used as a\nreference on the associated ENDBLK macro, and also on the LEAVE\nmacro.\n.*\n:h2.The Program Block\n:p.\nThe :hp1.program block:ehp1.\nencloses the main body of a program and corresponds roughly to a\n:q.mainline:eq.. Program blocks may not be enclosed by any other\nstructure:  e.g. they must be used at :hp1.block level zero.:ehp1.  The\nprogram block should be the first block coded for a program.\n.rc 1 on\nOptions and the ENVIRON keyword\non the BLOCK TYPE=PROGRAM macro determine the type of linkage,\n.rc 1 off\ninitialization and other program attributes to be established. The\nassociated ENDBLK macro will reverse the linkage when it is executed.\nA LEAVE macro which either names the program block or is coded\nas :q.BLOCK=*:eq. at the\nprogram block's block level will cause a branch to the ENDBLK macro,\nthus terminating the program.\n:p.\n.rc 1 on\nWhen writing a program that uses both 24-bit and 31-bit\n.rc 1 off\naddressing under MVS/XA, a Structured Macro Workarea\n(SMWA) must be provided for the macros' use.  This is automatically\nprovided by the SWA and PWA services, or can be specified with a\nkeyword on the block macro.  The SMWA is a\ndoubleword of storage which is used to save work registers and\naddressing modes, thus allowing an AMODE change without\ndisturbing the registers.\n.*\n:h2.The Inline Block\n:p.\nInline blocks are generally used to set\noff a procedure from neighboring\ncode.\nInline blocks provide a structure which may\nbe exited with the LEAVE BLOCK=* macro.\nInline blocks are placed within the other types of blocks and\nmay be nested within themselves.\nIf desired, registers may be saved and restored when entering and\nleaving an inline block by use of the SAVE operand on the BLOCK macro.\n:p.\n.rc 1 on\nWhen writing programs that will be run on MVS/XA, the inline\n.rc 1 off\nblock may be used to switch addressing modes :q.on the fly:eq.. For\nexample, the program section in :figref refid=amode. is\nrunning AMODE 31\nand RMODE 24, but needs to issue a PUT, which requires AMODE 24.\nThese instructions will generate the correct sequence of\ninstructions to save the current addressing mode,\nswitch to AMODE 24,\nand then restore the saved addressing mode at the end of the block.\n:fig id=amode place=inline.\n.sk\n-- AMODE 31 code --\n   :\nBLOCK  AMODE=24\n PUT   SYSPRINT,RECORD\nENDBLK\n   :\n-- AMODE 31 code --\n:figcap.Switching AMODE\n:efig.\n.*\n:h2.The Subroutine Block\n:p.\nSubroutine blocks contain code that is reached via the CALLSUB macro.\nSubroutines coded in this manner must be at block level zero\n(i.e. cannot be contained within any other block).\nSubroutine blocks should be coded after the program block to which\nthey belong.\nSubroutine blocks are meant for :q.internal:eq. subroutines, not for\na called program that follows standard OS linkage conventions.\n:p.\nA subroutine block is called by CALLSUB using\n:hp1.:q.BAL   R14,routine:eq.:ehp1. or an equivalent sequence.\nBy using the SAVE operand, the subroutine may have some or\nall of its registers saved and restored, although its use is optional.\nIf Subroutine Work Areas (SWAs) are used, registers R0-R14 are\nautomatically saved in the SWA and restored when the subroutine\nis exited.  In this case, the SAVE operand is invalid.\nThe user can also specify that the USING environment should be\nsaved and restored around the subroutine.  This prevents any\nUSINGs within the subroutine from affecting the rest of the\nprogram.\nFurthermore, a subroutine may request that its AMODE be switched and\nrestored on entry and exit by using the AMODE operand.\n:p.\nThe CALLSUB macro uses register 14 to link to the subroutine, but\nall other registers will have the same value on entry to the subroutine\nthat they had in the calling program.  However, if Dynamic Storage\n.rc 1 on\nManagement or the LONG program option is\n.rc 1 off\nused, register 15 will also be destroyed by the CALLSUB linkage.\nSee :hdref refid=large. for more information on dynamic storage.\n.*\n:h2.The ErrExit Block\n:p.\nThe errexit block is executed whenever an ERREXIT macro that\nrefers to it is executed. Like the subroutine block, the errexit\nblock must be coded at block level zero.  Errexit blocks should\nbe coded with the subroutine blocks after the program block to\nwhich they belong.  The ENDBLK macro associated with an errexit\nblock generates a branch to the program block's ENDBLK expansion,\nand also allows you to specify a return code with\nwhich the program will terminate.  This return code overrides any\nreturn code that may appear on the program block's ENDBLK macro.\n.*\n.*\n.rc 1 on\n:h1.Program Environments\n:p.\nThere are several types of environments for which the\nStructured Macros contain explicit support.  These\nenvironments are selected with the ENVIRON keyword of the\nprogram block macro.  The environments are: the\n:q.OS:eq. program environment which supports standard\nOS linkages; the :q.DC:eq. program environment which\nsupports Cullinet IDMS/DC linkage; and the :q.PLI:eq.\nenvironment which supports the execution time environment of\nrelease 5 of the OS Optimizing Compiler.  Other types of\nenvironments can be accommodated by coding your own\nlinkage.\n.rc 1 off\n:p.\nThe options and keywords on the program and subroutine block\nmacros allow you to control virtually all phases\nof the program linkage as well as the Structured Macros\noptions.  All of the major initialization and termination\nfunctions are represented by their individual keywords.\nHowever, there are certain program types that occur\nfrequently.  To cut down on the number of options that need\nto be coded to represent these program types, the super\noptions can be used.  They contain the correct combination\nof options for the most common program types.\n.rc 1 on\nThe super options for each environment are discussed in their\ncorresponding sections below.\n.rc 1 off\n.*\n.rc 1 on\n:h2.DC Environment\n:p.\nSpecifying ENVIRON=DC generates support for programs to execute in the\nIDMS/DC run-time environment.\nThis support is relatively new and perhaps does not support all\nof the functions required by its users: however, a basic set of\noptions and super options should satisfy most IDMS/DC programmers'\nneeds.\n:h3.System Mode And User Mode\n:p.\nIDMS/DC programs generally are called in either :hp1.system mode:ehp1.\nor :hp1.user mode:ehp1.. As a rule, user-mode programs are called by a\n#LINK or #XCTL and use #RETURN to return to their caller, while\nsystem-mode programs are called by #CALL and return with #RTN, and also\nhave a slightly different set of register and linkage conventions.\nIDMS/DC applications whose program names are invoked by a task code or\ncalled by #LINK or #XCTL are almost always user-mode programs, while DC\nnumbered exits and map edit routines are usually system-mode programs.\nBoth types are supported by ENVIRON=DC.\n.*\n:h3.Reentrancy Under IDMS/DC\n:p.\nSince any IDMS/DC program may be in use\nby several users at any given time, reentrancy in application programs\nand DC system routines is much more valuable than under the standard\nMVS environment. The savings in execution time gained by avoiding a\n#GETSTG/#FREESTG and management of a reentrant program workarea are\nusually far outweighed by the program pool savings and avoidance of\nprogram management overhead gained by making a program truly\nreentrant. System-mode programs, where speed and efficiency are prime\nconsiderations, can take advantage of IDMS/DC's #GETSTK service for\n:q.fast storage:eq. if their PWA storage requirements are small.\n.*\n:h3.*NORENT\n:p.\nA non-reentrant user-mode program in IDMS/DC terms means basically\nthe same as a non-reentrant program under the OS environment: IDMS/DC\ndoes not allow users to share a copy of the program, but loads a new\ncopy each time a new user requests one. As a result, the program can\ncontain its variables within its CSECT without having to acquire\nstorage from IDMS/DC for them.\n.*\n:h3.*NORENTSYS\n:p.\nThis super option defines a non-reentrant system mode program for\nIDMS/DC. This option is provided for consistency: however, it is\nrecommended that any system mode program be assembled as reentrant,\nusing either the *RENTSYS or *PWASYS super option.\n.*\n:h3.*RENT\n:p.\nReentrancy in an IDMS/DC user mode program allows IDMS/DC to share\na single copy of the program among multiple users, and also allows\nthe program to be loaded into the IDMS/DC reentrant program pool.\nThe *RENT super option causes reentrant linkage to occur, but does\nnot acquire any variable storage for the program.\n.*\n:h3.*RENTSYS\n:p.\nThe *RENTSYS super option causes reentrant linkage to occur for an\nIDMS/DC system mode routine. Like *RENT, *RENTSYS does not acquire\nany variable storage for the program: thus, if local variable storage\nis not needed, the overhead of #GETSTG/#FREESTG can be avoided.\n.*\n:h3.*PWA\n:p.\nThe *PWA super option causes a #GETSTG and #FREESTG to be included\nin the linkage and delinkage for the program, thus allowing reentrancy\nand providing storage for variables. This process (except for actually\nacquiring the storage) is basically the same as described\nin the *PWA section under\n:hdref refid=ospwa..\n.*\n:h3.*PWASYS\n:p.\nThis is generally the option that system-mode programs would use if\nthey have any need for variable storage. If a small PWA (10 fullwords\nor less) is all that's needed, the option GETSTK can be coded among\nthe program block's OPTIONS: this causes #GETSTK to be used to acquire\nvariable storage from the task's TCE stack, which is much faster than\ncalling #GETSTG and #FREESTG.\n.*\n:h2.OS Environment\n:p.The OS environment is the default environment and supports\nstandard OS linkage.  By specifying different options, you can\nhave the Structured Macros do as little or as much of the\nlinkage as desired.  For most situations, there are super options\nthat will pick the correct set of options for you.\n:h3.*NORENT\n.rc 1 off\n:p.\nIf a program is non-reentrant, the system will load a fresh copy\nof it every time the program is invoked.  Because of this, the\nprogram is allowed to modify itself.  Data and work areas can\nbe stored in the load module itself.  Most user programs can be\nnon-reentrant.  The *NORENT super option will automatically define a\nsave area in the program ID section and perform non-reentrant linkage.\n.*\n:h3.*RENT\n:p.\nSince reentrant programs are not reloaded every time they are\ninvoked, they are not allowed to modify any fields within themselves.\nAny data that might be modified must be copied into working storage\nthat has been GETMAINed, and modified there.  This preserves the\nintegrity of the load module for other users.  The *RENT\nsuper option provides the reentrant linkage and will automatically\nGETMAIN storage for a save area.  No provision is made for a\nProgram Work Area (PWA).  Any storage (other than the save area)\nneeded by the program must be acquired by the user.\nBecause of this, the *RENT super option is not very useful for\nnew programs.  *PWA provides much better support for reentrant\nprograms. (see below)  *RENT was included to provide support for\nthose programs that already acquire their own storage or that for some\nreason could not use the storage provided by *PWA.\n.*\n:h3 id=ospwa.*PWA\n:p.\n*PWA provides all the functions of *RENT, plus it will automatically\nGETMAIN and FREE a Program Work Area (PWA) for the user.  The best\nway to illustrate this is with an example:\n:xmp.\n BLOCK NAME=MAINPROG,TYPE=PROGRAM,OPTIONS=(*PWA)\n        :\n        :\n ENDBLK BLOCK=MAINPROG\n PSD\n        :\n   Static Data\n        :\n ENDPSD\n PWA\n        :\n   Work Area\n        :\n ENDPWA\n:exmp.\n:p.\nIn the example above, the static data (constants and other data\nthat are not modified by the program) is placed at the end of the\n.rc 3 on\nprogram in an area called the PSD (Program Static Data)\n.rc 3 off\nand is included in the load module.\nThe PWA and ENDPWA macros define a DSECT for a block of storage\nthat will be acquired for the user by the BLOCK macro and freed\nat the end of the program.  Space for the save area is automatically\nreserved in the PWA, so the user does not need to worry about this.\nThe user simply needs to define any work area fields that the\nprogram needs\nbetween the PWA and ENDPWA macros.  After this storage is acquired\nby the BLOCK macro, it is cleared for the user and addressability\nis set up using register 13.  This super option makes writing\nreentrant programs almost as easy as writing non-reentrant ones.\nThe bothersome details of computing storage requirements,\nGETMAINing storage, keeping up with addresses, and FREEMAINing the\nacquired storage are handled by the Structured Programming Macros.\n:p.\nThe *PWA option and the PWA macro also provide a variety of\nother features that are described in more detail in\n:hdref refid=pwaswa..\n.*\n:h3.*MAIN\n:p.\nThe *MAIN super option provides all of the features of *PWA and\nadds the options DYN and MAIN.  This allows SWAs to be allocated\nfrom dynamic storage instead of being statically defined in the\nPWA.  See\n:hdref refid=large. for more information on dynamic storage.\nThe *MAIN super option should be used on the program\nblock for any main program that uses dynamic storage.\n.*\n:h3.*NOMAIN\n:p.\nThe *NOMAIN super option provides all of the features of *MAIN\nexcept that it specifies option NOMAIN instead of MAIN.\nThis super option should be used on a program block that\nrepresents an external subroutine that will be called from\nanother program that uses dynamic storage.\n.rc 2 on\n.*\n:h3 *SRVPRC\n:p.\nThe *SRVPRC super option is used by service processors.  Refer to\n:cit.Clemson University Computer Center Service Processor User's\nGuide and Reference:ecit. for more information on this super option.\n.rc 2 off\n.rc 1 on\n:h2.PL/I Environment\n:p.\nENVIRON=PLI supports the execution time environment of\nrelease 5 of the OS PL/I Optimizing Compiler.  At the\ncurrent time this support is minimal, but it should satisfy\nthe needs of most assembler programs that run as subroutines\nto PL/I programs and use the PL/I environment.\n:h3.*STDPLI\n:p.\nThis is the only PL/I environment super option and should\nalways be specified.  The Structured Macros' support of PL/I\nis not as fully developed as it is for the OS and DC\nenvironments.  Specifying this option will help insure\nfuture compatibility.\n:p.\nThis super option will provide the proper reentrant linkage\nfor a majority of assembler programs that run in an OS PL/I\nOptimizing Compiler execution time environment.  Storage is\nobtained for a PWA in the same manner as a PL/I program\nobtains storage for its DSA.  A DSA in PL/I contains an OS\nsave area, control information and program variables.\n.rc 1 off\n.*\n.rc 1 on\n:h2.Other Environments\n:p.\nIf you want to use the Structured Macros in other than one of\nthe explicitly supported environments, you can code your own\nlinkage or add support for the environment with prolog and\nepilog macros.\n:p.\nIf you want to code your own linkage, let the environment\ndefault to OS and do not code any linkage-related options.\nPut your own linkage before or after the program block macro\nand after the end block macro for the program.  If you\ndo your own linkage you will not be able to use PWAs, SWAs,\nPSDs, SSDs or anything related.\n:p.\nIf the Structured Macros will be used often in this\nenvironment or if you need to use PWAs, etc., it may be\nworth the time to add support for the environment.  Refer to\nthe internals manual for the Structured Macros for\ninformation on writing prolog and epilog macros if you would\nlike to take this approach.\n:p.\nTo add support for an environment requires a thorough\nunderstanding of the internals of the Structured Macros and\nthe support may have to be updated each time the Structured\nMacros themselves are updated.  If the environment needed is\nof general interest, you may want to request that it be added\nas a standard part of the Structured Macros and supported as\nsuch.\n.rc 1 off\n.*\n.rc 1 on\n:h2.Subroutine Block Super Options\n:p.\nCurrently, all environments use the same subroutine block options\nand super options.\n.rc 1 off\n:h3.*SWA\n:p.\nIn any program that uses the PWA option, the internal subroutines\nfor that program can each have an individual Subroutine Work\nArea (SWA).  The *SWA super option is specified on the\nsubroutine block (or the SUBOPTS= on the program block)\nto provide an SWA for a subroutine.  There are\nSWA and ENDSWA macros to delimit the SWA just as the PWA was\ndelimited.  The details about the functions of an SWA and its\nrelation to a PWA are described in :hdref refid=pwaswa..\n.*\n:h3.*NOSUBOPTS\n:p.\nThis super option clears all the subroutine options to their\n:q.no:eq. state.  If the program block has specified a default set\nof subroutine options with the SUBOPTS= keyword, this super\noption can be used on a subroutine block to create a subroutine\nwithout those default options.  For example, a *NOSUBOPTS,CUSTOM\nmight be coded to create a subroutine with just the CUSTOM\noption.\n.*\n.*\n:h2.Conclusion\n:p.\n.rc 1 on\nThe environment support and\nsuper options make programming much easier, since all of the\n.rc 1 off\ntedious initialization and termination details are taken care\nof with a minimum of effort.  This allows you to worry about\nprogram logic, and not the linkage.\nThey also do not lock you into only these combinations\nof options.  If you wish to override any of the options in a\nsuper option, simply code them after the super option on the\nOPTIONS= keyword.  For example:\n:xmp.\n BLOCK  TYPE=PROGRAM,NAME=PROG,OPTIONS=(*PWA,XA,NOREGEQU),ENVIRON=OS\n:exmp.\n.*\n.*\n:h1 id=pwaswa.Program and Subroutine Work Areas\n:p.\nThe Program and Subroutine Work Area (PWA and SWA)\nsupport built into the Structured\nProgramming Macros is a powerful tool that can be invaluable\nto someone writing a complex program, and also provides services\nthat can be useful in even a relatively small program.\n.rc 1 on\nAlthough PWAs and SWAs are normally used in reentrant programs,\neven non-reentrant programs can take advantage of the services\nthey provide.  If option NORENT is in effect,\nthe storage for the work areas will be defined\nin the load module instead of being dynamically obtained at\nexecution time.\n.rc 1 off\n.*\n:h2.Program Work Areas\n:p.\nThe PWA option and PWA macro provide many services besides just\n.rc 1 on\ndefining a block of storage to be obtained for the user.\n.rc 1 off\nBy specifying that the program will have a PWA, you\nallows the Structured Macros to automatically perform many functions.\nFor example, space for a SMWA for the main program and\none for each of the subroutines will be reserved in the\nPWA preventing you from having to code the SMWA= keyword\non the program block.  If you wish to override this\nand force the SMWA to a specific location, the\nSMWA= keyword can still be used.\n:p.\nAlso, you can have parameter lists placed in the\nPWA without having to explicitly define storage for them.\nThe Structured Macros can compute the largest parameter list\nin the program and reserve enough space in the PWA.  A separate\nparameter list area is reserved for the program and each subroutine.\nThis is required because the program parameter storage may be\nin use when a subroutine is called.  For more\ninformation on parameter lists, see :hdref refid=parms..\n:p.\nOption PWA allows you to define a Subroutine Work Area (SWA) for each\nsubroutine that contains any work area fields that are needed only\nwhile the subroutine is executing.  This SWA is analogous to the\nPWA for the program.\n.rc 3 on\n.*\n:h2.Reusable Program Work Areas\n:p.\nUnder normal circumstances, the PWA for a program will be allocated\nwhenever the program is called, and freed before the program\nterminates.  However, there are cases when a program is loaded into\nmemory once, and called repeatedly to perform a particular function.\nNot only would it be inefficient to repeatedly acquire and free\nstorage for this program, it may cause problems if the program is\nrequired to retain information between calls.\n:p.\nThis problem is solved by a mechanism known as :hp1.Reusable PWAs:ehp1..\nUsing this capabilility, the Structured Macros will only allocate a\nnew PWA when given a start-up call and will not free the storage when\nthe program terminates.  When the program detects that it is being\ncalled for the final time, it can issue a macro to instruct the\nStructured Macros to free the PWA storage at the termination of the\ncurrent invocation.\n:p.\nWhen reusable PWAs are being used, the caller of the program must\nkeep track of the PWA address and pass it in the parameter list on\nevery call.  The position of the PWA address in the parameter list is\ncustomizable.  If this address is binary zeros, the Structured\nMacros will allocate storage for a new PWA and store its address back\ninto the parameter list.  Otherwise, they will use the passed value.\n:p.\nAlternatively, you can specify a parameter position for\na function code that will be provided on every call and a value that\nmeans :q.Start:eq..  With this form, the Structured Macros will\nallocate a new PWA on the Start call, and use the passed PWA value\nin other cases.\n:p.\nWhen the program is in its final invocation (either because of an\nerror or when called to terminate), the SMCTRL macro is used to\nforce the Structured Macros to free the PWA at program termination.\n:p.\nThis concept is used heavily at Clemson by what we call :hp1.Service\nProcessors:ehp1..  These are programs that are started once and then\ncalled repeatedly to perform a particular type of service for their\ninvoker.  File handling, string manipulation, and symbol management\nare all examples of functions that may be handled by service processors.\nFor more information about the workings of Service Processors, see\n:cit.Clemson University Computer Center Service Processor User's\nGuide and Reference:ecit..\n.rc 3 off\n.*\n:h2.Subroutine Work Areas\n:p.\nAny subroutine that will be using an SWA should use the SWA and\nENDSWA macros to define its boundaries, just as the PWA and ENDPWA\nmacros are used for the program's PWA.  There are options\non the subroutine block to control SWA usage, and a super option\n(*SWA) that provides the correct combination of options for SWA\nusage.\n:p.\nSWAs provide useful functions for subroutines just as PWAs do for\nprograms.  SMWAs and parameter lists for the subroutines are\ncreated as part of the SWA instead of as PWA fields.  R0-R14 are\nautomatically saved and restored for any subroutine that has an\nSWA.  Space for this is reserved by the SWA macro, so you\ndo not have to code the SAVE keyword, or explicitly\nreserve the space.  The registers are saved as R0-R14 so that R15\nwill not be restored and the subroutine can pass a return code\nback in this register.\n:p.\nYou should be aware of the implications of saving and\nrestoring registers.  Because of this, a subroutine can not\npass back any values to its caller by way of the registers.  It\nwould have to use the PWA to pass back any information.  To get\naround this problem, the STRSA macro was created.  This macro\nstores the current value of a register in the SWA save area\nfor the current subroutine.  Then when the subroutine ends, the\nregister will be restored to the value it had when the STRSA macro\nwas issued, instead of the value it had when the subroutine was\ncalled.  You can use the STRSA macro to pass back any\nregisters that the calling routine needs, while allowing the\nother registers to be restored to their original values.\n:p.\nThere is a CLEARPWA option on program blocks that instructs\n.rc 1 on\nthe macros to clear the PWA after it has been obtained.  This\n.rc 1 off\noption is included in all of the super options that use PWAs\nso that you can count on the PWA being all zeros on entry.\nHowever, there is not a similar option on the subroutine block\nto clear the SWA.  You should never count on the SWA\ncontents anytime a subroutine is entered.  If the fields within the\nSWA need to be set to a specific value, the subroutine must include\ncode to initialize these fields.\n:p.\nThese functions of SWA usage can be a great help to the\nprogrammer, even the subroutine does not need to have any of its own\nfields defined in the SWA.  If you select the SWA option, the\nStructured Macros will generate an SWA for internal use in\nsaving registers, etc. even if you do not code the SWA and\nENDSWA macros at the end of your subroutine.\n.*\n:h2.SWA Placement\n:p.\nWith the *PWA option,\nthese SWAs will be included as part of the PWA for the program to\nwhich they belong.  They will be placed in the PWA's partial area\nand addressability will be off of the PWA register (R13).\n.rc 3 on\nThis configuration of PWAs and SWAs is changed in programs that use\nthe Structured Macros' dynamic storage management support.  For more\ninformation on this, see :hdref refid=dynpwa..\n.rc 3 off\n.*\n:h2.PSDs and SSDs\n:p.\nThe PSD and SSD macros (and their respective end macros) are used\nto define the Program and Subroutine Static Data areas, just as\nPWA and SWA are used to define the work areas.  These macros are\nused in conjunction with the LOCTR option on the program block to\ninsure proper placement of the program code and static data.\nThey also allow fields to be defined from within the program code\nthat will be placed with the static data when the program is\nassembled.  This facility is used by the EXI macro.\n.rc 1 on\nThese data areas are addressed off of the same base registers as\n.rc 3 on\nthe program and subroutine code.\n.rc 3 off\n.rc 1 off\n.*\n.*\n:h1 id=large.Large Program Management\n:p.\nAs a program becomes larger and contains more subroutines,\ncertain problems arise.  The PWA (which contains an SWA for each\nsubroutine) can grow to an unmanageable size.  Also, the program\ncode along with the subroutine code can become so long that it\nwould take several base registers to maintain addressability.\nThe Structured Macros provide two tools to help manage such large\nprograms.  They are Dynamic Storage Management and the LONG and\nLOADBASE options.\n.rc 1 on\nDynamic Storage Management is only available for program blocks\nwhich are using ENVIRON=OS.\n.rc 1 off\n.*\n:h2 id=dynpwa.PWAs and SWAs with Dynamic Storage Management\n:p.\nIf your program has a large number of internal subroutines that\nheavily use SWA storage, the size of the PWA can easily\ngrow to an unmanageable size.  If the fields defined in the\nSWA are really only necessary when the subroutine is active,\nit is not necessary to allocate enough space for all of the\nSWAs.  Only enough storage to contain the PWA itself, and the\nlargest combination of active SWAs is required.  If there were\nsome way to dynamically allocate and free SWA storage as\nsubroutines were entered and exited, a great savings in storage\ncould be realized.\n:p.\nTo solve this problem, the storage for an SWA could be GETMAINed as\nthe subroutine is entered and FREEd at the end, but this would\nslow down the operation of the program greatly.\n:p.\n.rc 1 on\nA much more efficient system is to obtain a large block of\n.rc 1 off\nstorage at the beginning of the program, allocate the first part\nto the PWA, and allocate the rest to SWAs as it is needed.\nThis block of storage can be much smaller than the size of the\nPWA plus all of the SWAs, since not all of the subroutines will\nbe active at once.  Also, since new SWA storage is allocated for\na subroutine each time it is entered, subroutines can be called\nrecursively.  With this system, a GETMAIN is never done more than\nonce for a single program.  Enough storage is allocated for all\nthe program and subroutines' needs at the beginning, and storage\nis assigned and taken back as subroutines are entered and exited.\n:p.\nThis is just what the Structured Macros' Dynamic Storage\nManagement does. The DYN option on the program block is used\nto turn on Dynamic Storage Management.\nDynamic Storage also allows subroutines to call\nthemselves, which adds more complexity.  Also, there is hidden\nrecursion, such as when subroutine A calls subroutine B, and\nsubroutine B in turn calls subroutine A.\n.*\n:h3.Recursive Subroutines with the DYN Option\n:p.\nRecursive subroutines cause another problem.  Since they are called\nagain without the previous invocation being ended, multiple copies\nof the subroutine's SWA need to be allocated from dynamic storage.\nSince the Structured Macros have no way of knowing how deep the\nrecursion might go, you need to supply this information.\nOn any subroutine that will be called recursively (this includes\nall the programs in a recursive loop such as the one described\nabove), you\nneed to use the RECUR keyword to tell the macros the maximum\nnumber of times the subroutine will be called recursively.\nThis keyword tells the macros how many copies of that subroutines\nSWA could be active at once, and therefore how much room to\nallocate.\nIf you miscalculate on the RECUR keyword, the Structured Macros\nwill miscalculate on the space required.  If you use too big a\nnumber, the macros will allocate more space than is needed.\nIf you use too small a number, the macros will allocate too little\nspace, and a dynamic storage error will result.  By default, the\nmacros will force an ABEND 0C1 when your program runs out of\ndynamic storage.  However, you can specify an error exit that will\nget control when this happens with the DYNERR keyword on the\nprogram block.\n.*\n:h3.Storage Calculations with the DYN Option\n:p.\nThe Structured Macros' algorithm is very comprehensive and will\nallocate enough space for all known cases.\nIt uses an internal macro called :hp1.##ORGS:ehp1.\nto trace the subroutine\ncall structure of the program.  From this, it determines the\nsubroutines that will be active together, and how big their SWAs are.\nUsing this information and the size of the PWA, the macros determine\nhow much space they will need to GETMAIN to accommodate your program.\nThis tracing of the subroutine structure is more difficult than it\nmay seem, since the main program and each subroutine may call many\nother subroutines forming a very complex tree.\nHowever, there are\ncertain very complicated and unlikely combinations of subroutines\nthat will trick them into allocating more space than they need.\nIf this ever becomes a problem, it can be adjusted with the\nDYNSIZE keyword on the program block.  The DYNSIZE keyword is used\nto replace or adjust the value for the amount of dynamic storage\ncalculated by the macros.  It can be used in certain cases to\nfine-tune the dynamic storage requirements.  However, in most cases\nthe macros themselves should calculate the correct amount, and\nthe DYNSIZE keyword should not be needed.\n.*\n:h3.SWA Addressability with the DYN Option\n:p.\nThese SWAs will be based off of register 11, while the\nsubroutine itself will be addressed off of the program base, and\nthe PWA base will remain with register 13.\nIt should be noted that register 11 will be in use in DYN programs\neven when a subroutine has not been invoked.\n.*\n:h3.Super Options Used with the DYN Option\n:p.\nThere are two program block super options for use\nwith Dynamic Storage Management.\nThey are *MAIN and *NOMAIN.  *MAIN contains all of the options in\n*PWA plus the options DYN and MAIN.  The MAIN option tells DYN that\nthis is a main program and that dynamic storage should always be\nobtained when this program is entered.\nBy contrast, *NOMAIN says that this program is an external subroutine\nthat will be called from a main program that uses DYN.  In a *NOMAIN\nprogram, the dynamic storage of its caller will be used if there is\nenough of it.  Otherwise, more storage will be GETMAINed to accommodate\nthe program and its subroutines.\nIt should be emphasized that a program compiled with option *NOMAIN\nshould :hp2.only:ehp2. be called from a program that uses\nDynamic Storage Management.  Even if the *NOMAIN program\nGETMAINs its own storage, it requires that registers and\nstorage areas be set up by the calling program.\n:p.\nAny *MAIN program that will be calling external subroutines with\n*NOMAIN might need to use the DYNSIZE keyword to adjust its\ndynamic storage to allow for what the *NOMAIN program will use.\nSince the *NOMAIN program will most likely be compiled separately,\nthere is no way for the Structured Macros to calculate its\nrequirements.  However, since the *NOMAIN will get more storage if\nit needs it, adjusting the storage on the *MAIN program will only\naffect performance by preventing an extra GETMAIN.\n.*\n:h3.Storage Optimization with the DYN Option\n:p.\nWhen using the DYN option, there is a short routine added to\nthe beginning of each internal subroutine to obtain the new\nSWA.  This is not a real problem, but if the program has a large\nnumber of small subroutines, this can significantly lengthen the\nload module.  If the size of the load module is critical, the\nOPTSTOR option can be used on the program block to help remedy\nthis.  The OPTSTOR option will create a single copy of the\nsubroutine linkage code and have each subroutine branch to it.\nThis makes subroutine calls slower, but will reduce the size of\nthe load module.  However, space is rarely this critical, so the\nOPTSTOR option should not be needed in most cases.\n.*\n:h2.LONG and LOADBASE\n:p.\nWhen a program gets to be very long with a lot of subroutines (such\nas a server routine or a command processor), the CSECT can become\nso large that it takes two, three, or even more base registers to\nmaintain addressability.  It would be nice if there was some way\nto allow a subroutine to have its own base register separate from\nthe program's base register.  The LOADBASE option on subroutine\nblocks and the LONG option on the program block provide this support.\n:p.\nThe LOADBASE option on the subroutine block instructs the subroutine\nlinkage routines to establish a separate addressability to that\nsubroutine using the subroutine base register.  This register\ndefaults to R10, but another register can be selected with the\nBASEREG= keyword.  Any subroutines coded in this manner will be\nlocated at the end of the CSECT, so that they will not interfere\nwith the program's addressability.\n:p.\nIf a program has any subroutines that use the LOADBASE option, the\nprogram block must have the LONG option coded.  This option causes\nCALLSUB to generate the correct linkage for LOADBASE subroutines.\nSince both of these options make use of partial PSDs, the LOCTR\noption is also required when using these.  However, LOCTR is\nincluded in all of the super options, so usually you\nwill not have to code it.\n:p.\nWith this scheme, the macros always keep a base to the program\nand to the current subroutine.  Therefore, the program will be\nable to address anything in the program and its PSD as well as\nthe current subroutine and its SSD.  However, one subroutine\ncannot address anything in another subroutine's SSD.  If you\nhave any static data that will be shared among subroutines, it\nshould be placed in the PSD.\n:p.\nSince a separate base register is kept for the program and the\ncurrent subroutine, this facility is only useful in programs that\nalready need two or more base registers.  However, with these\noptions the program base register only needs to address the main\nprogram code and its static data.  If even this can not be done\nwith a single base register, the main program code can be moved\nto an internal subroutine with only a single CALLSUB in the\nprogram block.\n.*\n:h2.Size Limitations\n:p.\nWith the techniques described here, a very large program can be\ncreated quite easily.  Although most programmers will never exceed\nthe Structured Macros' limits, it may be useful to know just how large\na program can become.\nThe only limitation on program length (and it's static data) is the\nnumber of base registers you are willing to use to address it.  But\nwith the LONG and LOADBASE options, this is not necessarily a problem.\nPWAs can be up to 16M in size, but again you must maintain\naddressibility on it.\n.rc 1 on\nSWAs can be up to a maximum of 32K in size\nif DYN is in effect.\n.rc 1 off\nIf the majority of one of your data or work areas is a single very\nlarge data area that you only need to address the start of, you\ncan place it at the end of the data area.  The user fields always\ngo after the fields generated by the Structured Macros.\n.*\n:h2.Conclusion\n:p.\nThe long program management routines provide very useful\nsupport for large or memory intensive programs.  A great\nsavings in GETMAINed storage can be achieved in programs\nwith large numbers of subroutines, and many of the tedious\ndetails of subroutine linkage and program storage can be\nautomated.  A savings in base registers can also be achieved\nin extremely long programs.  For more information on the\nactual layout of dynamic storage, see :hdref refid=dynform.,\nwhile a description of program code and static data layout\ncan be found in :hdref refid=codform. along with an example\nof how these options should be coded.\n.*\n.*\n:h1 id=if.The IF Structure\n:p.\nThere are four macros that are used\nto build IF structures: these are\n:hp2.IF, ELSEIF, ELSE:ehp2. and :hp2.ENDIF.:ehp2.\nOf these, conditions to govern\nstatements are coded on the IF and ELSEIF macros. Like the IF services\nin many higher-level languages,\nthere are Boolean operators available (AND, OR, NOT) for building\ncomplex expressions: however, the conditional statements themselves\nare coded using the actual assembler compare instructions. For\nexample,\n:xmp.\n IF    (CLC,TAG1(8),NE,6(R2)),THEN\n         :\n   -- success code --\n         :\n ELSE\n         :\n   -- fail code --\n         :\n ENDIF\n:exmp.\n:pc.\nwill generate:\n:xmp.\n.tp 15 20 40\n+!CLC!TAG1(8),6(R2)!generated by IF\n+!BE!failtag!generated by IF\n!         :\n!-- success code --\n!         :\n+!B!endiftag!generated by ELSE\n+failtag!DS!0H!generated by ELSE\n!         :\n!-- fail code --\n!         :\n+endiftag!DS!0H!generated by ENDIF\n.tp\n:exmp.\n:p.\nSimilarly,\n:xmp.\n IF    ((CH,R1,EQ,A),OR,(CH,R1,EQ,B)),THEN\n       :\n   -- success code --\n       :\n ENDIF\n:exmp.\n:pc.\nwill generate:\n:xmp.\n.tp 17 22 40\n+!CH!R1,A!first comparison\n+!BE!successtag!branch if test succeeds\n+!CH!R1,B!second comparison\n+!BNE!failtag!branch if test fails\n+successtag!DS!0H!generated by IF\n!         :\n!-- success code --\n!         :\n+failtag!DS!0H!generated by ENDIF\n+endiftag!DS!0H!generated by ENDIF\n.tp\n:exmp.\n:p.\nIn these examples, one thing that you may have noticed is that\nthe macro expansions will generate tags and branches to them as may\nbe appropriate. Although these tags are used only by the macros at\nassembly time, it is very handy to have them available under TSO TEST.\n:p.\nThe IF and ELSEIF macros allow you to specify :q.conditions:eq.\n.rc 1 on\nin a number of ways, which are fully described\nin :hdref refid=condch..\n.rc 1 off\nSimply stated, the :q.condition:eq. of the IF statement\nprovides the instruction that will be used for the actual comparison\nand the appropriate condition for the subsequent branch.\nFor example, the statement\n:xmp.\n IF   (CLC,A(6),NE,3(R1)),THEN\n:exmp.\n:pc.\nwill generate the instructions\n:xmp.\n.tp 15 20 40\n+!CLC!A(6),3(R1)\n+!BE!failtag\n.tp\n:exmp.\n:p.\nConditions may be combined on the IF statement using Boolean\nexpressions NOT, AND and OR.\nAlso, if a condition code is known to exist when an IF is executed,\nonly the desired conditional operator needs to be coded. For example,\n:xmp.\n TRT   TEXT,TABLE\n IF    Z,THEN\n  MVC   MESSAGE(15),=CL15'TEXT NOT FOUND'\n  PUT   SYSPRINT,MESSAGE\n ELSE\n    :\n    :\n ENDIF\n:exmp.\n:p.\nIn this example, the TRT instruction\nwill set a :q.zero:eq. condition code\nif the translate-and-test operation fails.\nThe subsequent IF statement is used to generate a conditional branch\nwithout a compare instruction.\nThis form of the IF statement is useful for non-comparison instructions\nthat set a condition code, such as arithmetic and logical\ninstructions. The user should avoid mixing this form of condition with\nconditions that generate compare instructions, though, because the\norder in which the instructions are generated may cause the condition\ncode to be changed prematurely.\n:p.\nThe ELSEIF macro is similar to an ELSE macro followed by an IF macro,\nexcept the IF nesting level is not changed.  This allows the\nuser to test for one condition out of a list of conditions.\nFor example:\n:xmp.\n IF      (CLC,FUNC,EQ,=C'READ'),THEN\n    :\n    :\n ELSEIF  (CLC,FUNC,EQ,=C'WRITE'),THEN\n    :\n    :\n ELSEIF  (CLC,FUNC,EQ,=C'CLOSE'),THEN\n    :\n    :\n ENDIF\n:exmp.\n:p.\nThis is similar to the CASE structure, except that the CASE macro\nis mainly used to select one out of a sequence of numerically ordered\nitems.  For more information on the CASE macro, See\n:hdref refid=case..\n.*\n.*\n:h1.Loops\n:p.\nVariations of the :hp1.LOOP:ehp1.\nand :hp1.ENDLOOP:ehp1. macros may be used to\ncreate the most commonly used loop structures. The types of loop\navailable are:\n:hp1.WHILE:ehp1. loops, where completion tests are performed at\nthe top of the loop;\n:hp1.UNTIL:ehp1. loops, where completion checking is done\nat the bottom of the loop;\n:hp1.BCT:ehp1. and :hp1.BXLE:ehp1. loops, where completion tests\nare performed at the end of the loop;\n:hp1.BXH:ehp1. loops, where completion\nchecks are made at the top of the loop;\nand :hp1.endless:ehp1. loops, where\ncompletion checks are made within the loop by the programmer's code.\n:p.\nThe WHILE and UNTIL loops provide the Assembly language programmer\nwith the standard loop structures available in any high-level\nlanguage and the ability to control the loops with any condition\nthat is legal in an IF statement.\nSee :hdref refid=condch. for a complete description of the\nconditions that can be specified with the Structured Macros.\nThe BCT, BXH, and BXLE loop provide support for the standard\nSystem/370 looping statements, while preserving the structured\nnature of the code.\n:p.\nAs in the other structures, the LEAVE macro may be used to exit a\nloop if desired. In the case of an endless loop, a LEAVE macro is\nusually the only way to exit the loop.\n:fig id=loop place=inline.\n.tp 10 40\n !LOOP      WHILE,condition!|   LOOP      BXH,r1,r2\n !     :!|            :\n !ENDLOOP   WHILE!|   ENDLOOP   BXH\n.sk\n !LOOP      UNTIL!|   LOOP      BXLE\n !     :!|            :\n !ENDLOOP   UNTIL,condition!|   ENDLOOP   BXLE,r1,r2\n.sk\n !LOOP      UNTIL!|   LOOP      BCT\n !     :!|            :\n !ENDLOOP   UNTIL,LEAVE!|   ENDLOOP   BCT,reg\n.tp\n:figcap.Types of LOOP macros\n:efig.\n.*\n.*\n:h1 id=case.CASEs and CASE Blocks\n:p.\nThe CASE structure may be used in place of the\n:q.jump-table:eq. or :q.go-to-depending-on:eq. structure\nand serves the same function as the Pascal CASE structure.\nThe macros used to create the CASE structure are CASEBLK, CASE\nand ENDCASE.\nThe CASEBLK macro opens a case block and generates code that selects\na handler routine based on the contents of a register.\nThe ENDCASE macro denotes the end of a CASE block, and will be\nbranched to at the end of each individual CASE.\nCASE macros within the CASE block frame code that will handle\nan individual case, or occurrence.\n:p.\nA common example of the use of a CASE block might appear after a\ncall to some routine which may return\none of several return codes, each of which\nmust be handled differently, as in :figref refid=case..\n:fig id=case place=inline.\nIF  (TREG,R15,NZ),THEN\n  CASEBLK REG=R15,MULT=4\n.sk\n    CASE 4\n    -- code handles return code 4\n.sk\n    CASE 12,16\n    -- code handles return codes 12 and 16\n.sk\n    CASE OTHER\n    -- code handles other return codes\n.sk\n  ENDCASE\n.sk\nENDIF\n:figcap.The CASE Block\n:efig.\n:p.\nPlease note that since the CASE and CASEBLK macros generate a\nseries of branches that are selected by the value in the CASEBLK\nregister, it should be used to select one value from a list\nof numerically ordered choices.\nFor comparing character data, or selecting from widely separated\nvalues, the IF - ELSEIF structure should be used.  For more\ninformation on ELSEIF, see its description in\n:hdref refid=if..\n.*\n.*\n.rc 3 on\n:h1 id=parms stitle='Standard Linkage'.\nParameter Lists and Standard Linkage\n:p.\nThe Structured Macros provide excellent support for the main program\nbeing called and for calling internal and external subroutines\nusing standard OS linkage conventions.\nA large part of this is handling standard OS parameter lists.\nThe standard form for these parameter lists is a sequence of fullwords,\neach the address of a particular data item.  If a data item is missing,\nthe address pointing to it is filled in with a fullword of zeros.\nUpon entry to the routine, register 1 should point to the first\nfullword in the parameter list.\n:p.\nThe handling of parameter lists consists of two pieces.  First, there\nmust be some way to reference :hp2.input parameter lists:ehp2..\nThese lists are processed by a program or subroutine block and were\ncreated by the invoking program.\nSecondly, support is needed for :hp2.generated parameter lists:ehp2..\nThese are parameter lists that are created by a program or\nsubroutine block and are then passed to an external routine or\nanother subroutine.  These functions are intertwined, since a\nprogram that calls an internal subroutine may create a generated\nparameter list that becomes the input parameter list of the subroutine\nbeing called.\n.*\n:h2.Referencing Input Parameter Lists\n:p.\nThe input parameter list for a program is referred to by the\nStructured Macros as the :hp2.Program Parameter List:ehp2. (or PPL).\nThe corresponding structure for subroutines is the :hp2.Subroutine\nParameter List:ehp2. (or SPL).\nThe Structured Macros provide a number of options to control the\nhandling of input parameter lists.  These options are specified as\nsub-options of the PARMS option.\n:p.\nThe VL|NOVL parameter option identifies the input parameter list\nas being either variable or fixed length.\n:p.\nThe COPY parameter option instructs the macros to copy the input\nparameter list into the current work area (PWA for programs and\nSWA for subroutines).  In this case, the PPL (or SPL for subroutines)\nis not the original input parameter list, but a copy of the original\nmade in working storage.\nThis has several uses.  First, it prevents\nthe program from modifying the original parameter list.  Modifying\nan input parameter list is not allowed by the standard linkage\nrules.  Second, by copying the parameter list, it is addressed\nwith the work area base register and a separate parameter list\nregister is not required.\n:p.\nLastly, the COPY option\nmakes it easier to determine which parameters were specified\non a variable length parameter list.  The work area storage is always\nlarge enough to hold the maximum length parameter list and is filled\nwith zeros before the input parameter list is copied there.  Because of\nthis, the program only needs to test any parameter address for zero to\nsee if it was specified in the original parameter list.  The COPY\noption requires that the PWA option has been specified for program\nblocks and that the SWA option has been specified on subroutine blocks.\n.rc 4 on\n:p.\nThe COPYERROR parameter option is required if the COPY option is used\nwith VL input parameter lists and is used to name the error exit that\nwill be invoked if the input parameter list is too large to fit in the\nspace reserved for it in working storage.  This will happen if the\nparameter list is larger than expected or if it is not a VL parameter\nlist, making it impossible for the Structured Macros to determine the\nlast parameter.  Any error exit in the program can be specified\nincluding the unnamed error exit and an exit code may be passed to the\nerror exit identifing the type of error to a multi-purpose exit.\n:p.\nThe COUNT parameter option specifies the location of a fullword into\nwhich the Structured Macros will place the number of parameters in\na VL input parameter list.  This can be used to verify that the\nprogram was called with the correct number of parameters.\n.rc 4 off\n:p.\nThe USING parameter option specifies a register that will be\nloaded with the starting address of the input parameter list.\nThis will either be the original input parameter list, or an\narea within the current work area (if COPY was also specified).\nOnce the register is loaded, a USING is done to provide\naddressibility on the parameter list.\n:p.\nThe PREFIX option instructs the macros to use a unique parameter\nlist ID when generating the tag names within the PPL or SPL.  For\nmore information about how this is used, see :hdref refid=scope..\n:p.\nIn order to make use of these options, a description of the\ninput parameter list must be provided.  There are two mutually\nexclusive keywords on the BLOCK macro provided for this purpose.\n:p.\nIf a mapping macro is already available for the input parameter list,\nthe PARMMAP keyword can be used to specify the Dsect name and length.\nThis provides a name for a USING on the parameter list, and defines\nthe size of the area that must be reserved for a COPY.\n:p.\nIf a mapping macro is not available, the PARMS keyword can be used\nto specify a list of tags that will be used to map the parameter\nlist.  These tag names will either be used to generate the\nparameter list Dsect, or will be mapped to the work area storage if\nCOPY is being used.\n:note.\nWhether a parameter list is mapped by a supplied Dsect or tags\ngenerated by the PARMS keyword, these tags will not refer to the\nparameters themselves, but rather to the addresses of the parameters.\nThis is not a deficiency in the Structured Macros; it is simply\nthe way that standard OS parameters work.\n.rc 3 off\n.*\n:h2.Generating Parameter Lists\n:p.\nMost external subroutines (and some internal ones)\nwill require some sort of parameter list\nto pass data between the calling program and the subroutine.\n:p.\nThe Structured Macros provide excellent support for building,\nmaintaining, and passing parameter lists.\nThe PLIST macro is used to create or modify a parameter list.\nIt also loads register one with the address of the completed list.\nThe following example illustrates some of the capabilities of the\nPLIST macro.\n.rc 3 on\n:xmp.\n PLIST  (DATA1,,*DATA3,*),PL=(PARMSTOR,4)\n:exmp.\n.rc 3 off\n:p.\nThis example will build a parameter list of four items at the\nlocation pointed to by PARMSTOR.\n.rc 3 on\nFirst is a simple data item that will have its address loaded into\nthe parameter list.\nThe second item in the list is\nmissing, so its address will be filled in with a full word of zeros.\nThe third item in the list will be filled in with the contents of\nDATA3 instead of a pointer to DATA3.  This form of indirect\naddressing is used when the referenced storage contains a pointer\nto the actual parameter.\n.rc 3 off\nThe asterisk in the fourth position tells the PLIST macro to skip\nover that position in the list and leave the value there unchanged.\nThis is useful if you are modifying a parameter list that was\ncreated earlier, and you only want to update certain fields.\nThe fields that are not to be changed can be marked with asterisks.\nOnce the parameter list has been built, PLIST will load register one\nwith the address of PARMSTOR.\n:p.\nThe PLIST macro allows the use of constants as well as labels when\ndefining parameter lists.  Observe the following example:\n:xmp.\n PLIST (0,,'HELLO?',=X'FF')\n:exmp.\n:pc.\nwhich is equivalent to:\n:xmp.\n PLIST (=F'0',,=C'HELLO?',=X'FF')\n:exmp.\nBoth examples generate literal constants, and then fill in the\nparameter list with the addresses of these constants.  Any\ndecimal self-defining constant will be treated as a full word\nliteral and any character string in quotes will be treated\nas a character literal.  Note that any other type of literal\n(such as hex or binary) has to be coded as a literal.\nSince decimal and character constants can be coded as constants\ninstead of as literals, the PLIST macro makes generating parameter\nlists even more painless.\n:p.\nPlease note in the examples above the distinction between the\nfirst and second parameter in each list.  The first parameter is\na decimal constant of zero.  The macros will generate a full word\nof zero and fill in the first position in the parameter list with\nthe address of it.  The second parameter is missing, so the macros\nwill put a full word of zeros into the parameter list itself.\nThis is an important distinction to remember.\n:p.\nThere are two main types of parameter lists: variable length (VL)\nand fixed length (NOVL).  In variable length parameter lists, the\nlast address in the list has its high bit set to one to mark it\nas the end of the list.  Since the length of fixed length parameter\nlists is known in advance, the end does not need to be marked.\nThe VL or NOVL option on the program block macro\nis used to set up the default for all\n.rc 3 on\nparameter lists generated by the program or any of its internal\nsubroutines.  Note that this is distinct from the VL parameter\noption (specified by the PARMS option).  The VL parameter option\ndescribes the input parameter list.\n.rc 3 off\nYou can specify a VL (or NOVL) keyword\non the PLIST macro to override this default.\nNote that all of the super options specify VL so that you will\nget variable length parameter lists by default.\nIf the PLIST macro is generating a VL parameter list (either\nbecause of the VL option on the program block or the VL keyword\non the PLIST macro), the last address in the parameter list will\nhave its high bit set to one.  This occurs even if the last\nparameter has been marked with an asterisk.\n.rc 3 on\n:p.\nYou have many choices as to where the parameter list\nitself gets built.  As you have already seen, you can use the\nPL= keyword to specify a tag and a number of parameters for the\nparameter list.  This number should represent the size of the\nstorage available for the parameter list.\nThe number is necessary because the PLIST macro verifies that\nthere is enough room to hold the parameter list.  This prevents\nPLIST from running over the parameter list storage into other\ndata fields.  If the tag has a self-defining length attribute,\nthe number field can be omitted.  However, because of the way\nthe assembler interprets lengths, you need to be careful.\nTo illustrate this:\n:xmp.\nPARMS1  DS  3F\nPARMS2  DS  XL(3*4)\n:exmp.\n:p.\nBoth of the definitions above reserve enough space for a parameter list\nat least three items long.  However, the assembler views the first\ntag as having a length of 4 since it is just a series of fullwords.\nTherefore, PLIST will assume that this storage location can hold\na parameter list of only one item.\nThe second example actually has a length of 12, which is what PLIST\nwill require if you try to build a parameter list of three items here.\n.rc 3 off\n.*\n:h2.Automatic Parameter Lists\n:p.\nIf your program has a PWA, you can have\n.rc 3 on\nstorage for your generated parameter lists\n.rc 3 off\nautomatically allocated within the PWA.  Any parameter lists\nthat do not include a PL= keyword in their definitions will be\nplaced in a special parameter list area in the PWA.  This area is\nonly big enough to contain the single largest parameter list in the\nprogram and is reused when a new parameter list is needed.  For\nthis reason, it is most useful for parameter lists that are created,\nimmediately used, and can then be discarded.\n:p.\nA separate parameter list area is also created for any internal\nsubroutines that generate parameter lists themselves.  This is\nbecause a subroutine that generates a parameter list may have been\ncalled with one and that one must remain even though the subroutine\nis generating new ones.\n.rc 3 on\nThe subroutine parameter list area is created within the SWA for the\nsubroutine.\n.rc 3 off\n:p.\nIf your program does not have a PWA, you can achieve the same\neffect with the PL= keyword on the block macro.  This keyword\nis identical to the PL= keyword on the PLIST, CALLSUB, and CALLX\nmacros and defines a default parameter list area for any parameter\nlists within that enclosing block.  This keyword can be used on\nany type block to create a unique parameter list area for each\nprogram section.\n.*\n:h2.Permanent Parameter Lists\n:p.\nThere are still cases where you would want to code PL=\nfor a parameter list.  If your program requires that a subroutine\nwill be called many times with the same parameter list it would\nhelp to be able to create it just once, then refer to it as often\nas necessary.  Also, it may be desirable to create a parameter list\nand then modify it conditionally before its use.  In either of these\ncases, you can use PLIST with the PL= keyword to create\nthe list in its own unique location.  This prevents the list\nfrom being overwritten by the next parameter list.  These lists\nmay be viewed as permanent since they remain until specifically\nwritten over, while the automatic parameter lists only remain until\nthe storage is needed for the next list.\n:p.\nIf a permanent parameter list is needed, you can\ncode a PLIST macro with the PL= keyword and define storage for\nthe parameter list, most likely in the PWA or SWA.  However, this\nrequires more upkeep than the other types of parameter lists.  You\nmust make sure that enough storage has been reserved\nto contain all the parameters in the list and if the number of\nparameters is changed later, the storage definition must be changed.\n:p.\nIt would be nice if there was a way to get the Structured\nMacros to generate the DS commands for you.  That way, if the\nsize of the parameter list changed, the storage area would\nchange with it.  This would give the advantages of the temporary\nlists while still allowing you to keep the list\naround and refer to it by name for subroutine calls or modifications\nto the list.  There is such a mechanism in the macros.  It is\ndone with the DS= keyword on the PLIST macro.  With the DS= keyword,\nyou can instruct the macros to set aside storage for\na particular parameter list in the PWA or in an SWA (of course\nyou can only specify SWA if the parameter list is being built\nin a subroutine that has one.)  For example:\n:xmp.\n PLIST  (DATA1,DATA2,DATA3),PL=PARM1,DS=PWA\n PLIST  (DATA4,DATA5),PL=(PARM2,3),DS=SWA\n:exmp.\n:p.\nWhen the DS= keyword is used, the PLIST macro counts the parameters\nin the list and sets aside just enough storage for them with a\nlabel supplied by the PL= keyword.  You can also force\nthe macro to allocate a specific amount of space by including\na number in the PL= keyword.  After a parameter list is created\nusing the DS= keyword, it can be referred to with just a PL=tag.\nOne caution on using this keyword:  Since the PLIST macro actually\ndefines the parameter list storage within a partial PWA, the DS=\nkeyword should appear on the first reference to the parameter list\nthat the assembler sees and no others.  All other references to the\nparameter list should just use PL= to specify the tag for that\nlist.\n.rc 3 on\n.*\n:h2.Calling Subroutines\n:p.\nTwo macros are provided for calling subroutines.  CALLSUB is used\nto call an internal subroutine that is included as part of the\nassembly of the main program.  CALLX is used to call external\nroutines that have been linked with the main program or that\nare dynamically loaded.  These external routines may be other\nprograms, or they may be IBM or vendor supplied service routines.\n:p.\nThe CALLSUB macro generates a BAL\ninstruction (or BAS if the XA option is being used) to jump\nto a subroutine that the program has direct addressability to.\nThe return address will be in register 14.  Otherwise, all registers\nhave the same value upon entry to the subroutine that they had\nin the main program.\nCALLSUB also provides the necessary linkage for Dynamic\nStorage Management if DYN is being used, and for subroutines that\nuse LOADBASE.  In either of these cases, the contents of register\n15 are also destroyed by the CALLSUB macro.\n:p.\nThe CALLX macro is for external subroutines and generates\na BALR instruction (or BASR) with the return address in register 14\nand the subroutine address in register 15.  This is the standard\nformat for external subroutines.\nRegisters 14 and 15 are the only ones destroyed by\nthe CALLX macro.  All others will have the same value in the\nsubroutine that they had in the calling program.\n:p.\nCALLX also differs from CALLSUB in the way that the subroutine\naddress is specified.  Since CALLSUB is used for internal\nsubroutines, the name of the subroutine is specified on the\nCALLSUB macro.  To call an external subroutine with CALLX,\nyou should specify the address in a register, or give the\nCALLX macro the address of a location that contains a pointer\nto the external routine.\n.rc 3 off\n.*\n:h2.Parameter Lists on CALLSUB and CALLX\n:p.\nIf you are going to build a parameter list and then immediately\nissue a CALLSUB or CALLX macro, you can combine these functions\nin a single macro.  The CALLSUB and CALLX macros can generate\nparameter lists just as PLIST does, so you can have\nthese macros build your parameter list for you.  For example:\n.rc 3 on\n:xmp.\n CALLSUB  SUBONE,(DATA1,*DATA2,100),PL=(PARMS1,3),NOVL\n CALLX    (R15),(DATA3,'ERROR')\n:exmp.\n.rc 3 off\n:p.\nThis method of calling subroutines is very simple.  However, it\nshould be noted that the parameter list will be recreated every\ntime the subroutine is called.  If you are going to make\nrepeated calls to a subroutine with the same parameter list,\nit would be better to create the parameter list once and\nsimply load the address of it before the subroutine call.\nThis can be done like this:\n:xmp.\n CALLX   (R15),PL=PARMSTOR\n:exmp.\n.*\n:h2.Recommendations\n:p.\nTo help you better understand the types of parameter lists and calls,\nhere are some general conventions\nto remember when using the Structured\nMacros for parameter lists.  These rules are not enforced by the\nmacros, but are good programming practice.\nWhen reading these rules, remember the distinction between permanent\nlists that use the PL= keyword to point to a specific location and\nautomatic lists that are defined in default parameter list storage.\n:ul.\n.rc 3 on\n:li.If the PARMS keyword was used to describe the input parameter\nlist, you will generally want a parameter option of either COPY\nor USING, but not both.\n:li.Since it frees a register that otherwise would be used to map the\nparameter list, COPY will probably be the most common option.\n:li.If the PARMMAP keyword was used to describe the input parameter\nlist, you will generally want the USING parameter option.  The\nCOPY option may be specified if you want the functions it provides.\n.rc 3 off\n:li.When using CALLSUB and CALLX, the PL= keyword is only really\nnecessary when referring to a permanent list created by a previous\nPLIST macro.\n:li.The PLIST macro is only needed for creating\nand modifying permanent parameter\nlists or when the call must be done without CALLSUB or CALLX\n(With LINK for example).\n:li.Permanent parameter lists should only be created with PLIST.\n:li.The * notation for modifying parameters should only be used in\npermanent parameter lists.\n:li.Temporary parameter lists should only be created with\n.rc 3 on\nCALLSUB or CALLX (Except when forced to use PLIST because\nthe call cannot be made with CALLSUB or CALLX).\n.rc 3 off\n:eul.\n.rc 3 on\n.*\n:h2.Example Source\n:p.\nHere is an example to show you some of the various ways in which\nparameter lists can be used:\n:xmp.\n BLOCK   TYPE=PROGRAM,NAME=PROG1,OPTIONS=(*PWA)\n*  Call external routine and pass a parameter list\n  LOAD   EP=PROG2\n  CALLX  (R0),(MYDATA,'OPEN',),NOVL\n ENDBLK  BLOCK=PROG1\n\n*  And under a separate assembly, you have\n BLOCK   TYPE=PROGRAM,NAME=PROG2,PARMS=(DATA,FUNCTION,OPT)             +\n               OPTIONS=(*PWA,(PARMS,COPY,NOVL))\n*  Copy actual parameter data to working storage\n  L      R1,DATA               Get address of 1st parameter\n  MVC    DATA1,0(R1)           Save data away\n*  Create a permanent list for later use.  Note that FUNCTION contains\n*  the address of the parameter we want to pass.\n  PLIST  (DATA1,*FUNCTION,53),PL=PARM1,DS=PWA\n*  Call subroutine using temporary list\n  CALLSUB SUBONE,(DATA3,,'INIT')\n*  Modify permanent list\n  PLIST  (*,DATA5,*),PL=PARM1\n*  Call subroutine using previous list\n  CALLX  =V(EXTRSUB),PL=PARM1\n ENDBLK  BLOCK=PROG2\n\n BLOCK   TYPE=SUBROUTINE,NAME=SUBONE,PARMMAP=(SUBPARM,SUBPARML),       +\n               OPTIONS=(*SWA,(PARMS,(USING,R9),VL))\n*  Call subroutine using temporary list\n*  This list will be created in SWA\n  CALLX  (R15),(155,'NAME',=X'FF')\n*  Create a permanent list within SWA\n  PLIST  (DATA4,DATA5),PL=SWAPARM,DS=SWA\n ENDBLK  BLOCK=SUBONE\n         SUBPARM DSECT=YES            Generate Dsect for input parms.\nSUBPARML EQU   *-SUBPARM\n:exmp.\n.rc 3 off\n.rc 3 on\n.*\n.*\n:h1 id=scope.Location and Scope of Data Structures\n:p.\nSince the Structured Macros handle all of the implementation details\nof PWAs, PSDs, SWAs, etc., a programmer should not have to reference\nany of these data areas directly.\nHowever, on the rare occasions that it is necessary, symbols are\ndefined by the Structured Macros that contain unique tags located\nat the beginning of these structures.  These symbols are listed below:\n:xmp.\n   &PWA - Program Work Area           &SWA - Subroutine Work Area\n   &PSD - Program Static Data         &SSD - Subroutine Static Data\n   &PPL - Program Parameter List      &SPL - Subroutine Parameter List\n:exmp.\n:p.\nIn order to have these symbols available to your program, you need\nto include an assembler COPY statement at the beginning of your\nprogram for the member SMSYMS.  This is necessary because of the\nAssembler H requirement that all global symbols be declared in\nopen code and not from within macros.\n:p.\nThese symbols can be used by any programs that needs to calculate\noffsets within any of these structures.  However, these symbols have\na much better use when used within subroutines.\n.*\n:h2.Local Scope within Subroutines\n:p.\nOne of the nicer concepts of high-level languages is local scope\nwithin subroutines.\nThis isolates the working storage of the subroutine from the main\nprogram, and helps to prevent the subroutine from affecting the\nprogram's storage in unforseen ways.  To some extent, Subroutine\nWork Area accomplish this goal for assembler programs.  By giving\neach subroutine its own work area instead having to share work areas\nwithin the PWA, the chance that two subroutines will overlay each\nother's storage is greatly reduced.\n:p.\nAnother very nice feature of local scope becomes evident when it\ncomes time to think up names for variables and work areas.  In a\nlanguage with local scoping, you can name variables within\na subroutine without any regard for what the variables in other\nsubroutines have been named.  This also makes it easier to copy\na subroutine from one program to another, since the new program does\nnot have to be checked for variable name conflicts.\n:p.\nUnfortunately, 370 assembler requires that every tag be unique and\ndoes not allow for local scoping of names.  However, the subroutine\ndata area symbols described above can be used to accomplish the same\neffect.  They contain the name of a tag at the beginning of a data\narea, but this can also be thought of as a unique id that can\nbe prefixed to tag names to distinguish them from identically named\ntags in other subroutines.  To facilitate this use of the symbols,\nabbreviated versions of them were created.  The short versions are:\n:xmp.\n   &SWA = &W\n   &SSD = &S\n   &SPL = &P\n:exmp.\nWith these tags, a subroutine like the following can be written.\nNote the use of the PREFIX parameter option to force the use of the\n&amp.P. symbol in the SPL.\n:xmp.\n       .\n  COPY    SMSYMS\n       .\n       .\n       .\n EDITDATA    TITLE 'SUBROUTINE TO EDIT PASSED FULLWORD'\n *---------------------------------------------------------------------*\n *  SUBROUTINE  EDITDATA\n *\n *  ABSTRACT    THIS SUBROUTINE WILL TAKE THE FULLWORD PASSED IN THE\n *              FIRST PARAMETER PASSED TO IT, EDIT IT INTO A WORK AREA,\n *              AND COPY THE RESULTS INTO THE AREA POINTED TO BY THE\n *              SECOND PARAMETER.\n *---------------------------------------------------------------------*\n          SPACE 3\n  BLOCK   NAME=EDITDATA,TYPE=SUBROUTINE,                               +\n                OPTIONS=(*SWA,(PARMS,(USING,R9),PREFIX)),              +\n                PARMS=(DATAPTR,RESULT)\n   L      R1,&P.DATAPTR                | GET ADDR OF FULL WORD.\n   L      R2,0(,R1)                    | LOAD FULL WORD TO CONVERT.\n   CVD    R2,&W.DOUBL                  | CONVERT TO DECIMAL.\n   MVC    &W.MASK,&S.MASK              | COPY EDIT MASK TO WORK AREA.\n   EDIT   &W.MASK,&W.DOUBL             | EDIT DECIMAL NUMBER TO EBCDIC.\n   L      R1,&P.RESULT                 | GET PTR TO RESULT STORAGE.\n   MVC    0(11,R1),&W.MASK             | COPY RESULT.\n  ENDBLK  BLOCK=EDITDATA\n          SSD\n &S.MASK  DC    CL'4020202020202020202120'\n          ENDSSD\n          SWA\n &W.MASK  DC    CL'4020202020202020202120'\n &W.DOUBL DS    D\n          ENDSWA\n:exmp.\n:p.\nAlthough this may seem strange at first, most programmers will find\nthat the advantages outweigh any inconveniences.\n.rc 3 off\n.*\n.*\n:h1.Miscellaneous Macros\n:p.\nThere are several macros packaged with the Structured Macros that,\nwhile they are not true structured programming aids, perform commonly\nused functions and relieve some coding effort.\n.*\n:h2.Bit Manipulation\n:p.\nThere are macros provided\nthat perform the 4 most common functions performed\non a bit:\n:hp1.setting (OI), resetting (NI), inverting (XI):ehp1.\nand :hp1.testing (TM).:ehp1.\nThe macros that perform these tasks are called\n:hp1.SBIT, RBIT, IBIT:ehp1. and :hp1.TBIT,:ehp1. respectively.\nEach macro uses the appropriate immediate instruction to operate\non a single byte; however, multiple bits within the target byte may\nbe changed at once.\nFor example, the macro\n:xmp.\n SBIT  FLAGBYTE,(BIT1,BIT2,BIT3)\n:exmp.\n:pc.\nwould generate:\n:xmp.\n.tp 15 20 40\n+!OI!FLAGBYTE,BIT1+BIT2+BIT3\n.tp\n:exmp.\n:p.\nThere is also a naming convention which is optional\nwhen using these macros. If the address of the target byte is not\nprovided, the macros assume that the target byte's tag is the first\n5 characters of the flag name. For example, the macro\n:xmp.\n IBIT  PWAF1OK\n:exmp.\n:pc.\nwould assume the flag was named :q.PWAF1:eq. and generate:\n:xmp.\n.tp 15 20 40\n+!XI!PWAF1,PWAF1OK\n.tp\n:exmp.\n:p.\n.rc 1 on\nThe TBIT macro is valid as a\n:q.compare:eq. instruction, allowing the\n.rc 1 off\nuse of TBIT in conditional expressions on IF, LEAVE, LOOP and ERREXIT.\n.*\n:h2.Testing A Register\n:p.\nThe TREG macro may be used in place of the :q.LTR:eq. instruction.\nTREG always issues a LTR that loads the target register from itself,\nthus setting the condition code without modifying any registers.\n.rc 1 on\nTREG is valid in a conditional expressions.\n.rc 1 off\n.kp on\n.*\n:h2.Initializing Storage\n:p.\nThe FILL macro may be used to set areas of storage to a byte value,\nsuch as spaces or low-values.\nThere are three types of FILL which may be done:\n:hp1.short,:ehp1. the default, for 1 to 256 bytes,\n:hp1.medium,:ehp1. for up to 4095 bytes, and\n:hp1.long,:ehp1. for up to 16 megabytes.\nMedium FILL may use any length constant which the LA instruction can\nhandle, while a long FILL must have its length in a register; otherwise,\nmedium and long FILL are identical.\nA short FILL will not destroy any registers, as it uses MVI and MVC\nto propagate its fill character, but medium and long FILL both use\nMVCL, and will destroy the contents of R14, R15, R0 and R1.\n.kp off\n.*\n:h2.Register Loading\n:p.\nOften it is necessary to load one, two, three, or four bytes of\ndata into a register from storage.  The L8, L16, L24, and L32\nmacros allow this to be easily accomplished.  For example,\nthe instruction\n:xmp.\n L16   R4,DATA1\n:exmp.\n:pc.\nwill load the low-order two bytes of register four with the two\nbytes at location DATA1 and clear the high-order two bytes of\nregister four.\nThese macros clear the specified register, and issue an\nappropriate ICM to load the required data.\n:p.\n:hp2.Important note::ehp2.  Since all of\nthese macros except L32 clear the register\nbefore doing the ICM, they should never be used to load\na register that is referred to in the address being loaded from.\nTo illustrate this:\n:xmp.\n L16   R2,10(R2)\n:exmp.\n:pc.\nwould generate the following code:\n:xmp.\n.tp 15 20 45\n+!SLR!R2,R2!CLEAR REGISTER\n+!ICM!R2,B'0011',10(R2)!LOAD 16 BITS\n.tp\n:exmp.\n:p.\nIn this example, register two is cleared to zero, then is\nloaded with the two bytes at the location pointed to by\nten off of the contents of register two.\nBut since register two has been zeroed, this loads from\n:hp1.absolute location ten:ehp1..  This type of problem can be very\ndifficult to debug because without looking at the macro\nexpansion, it is difficult to understand exactly what is going\non.\n.*\n.cp 20\n:h2.Executing Instructions\n:p.\nThe EX instruction is a very powerful tool in System/370\nassembly language.  There are many cases where it is the\nsimplest method to operate on a variable amount of data.\nHowever, there are problems with using the EX instruction.\nMost of these stem from the placement of the instruction to\nbe EXecuted.  The instruction can be placed inline, right\nnext to the EX instruction with a branch around it.  This\nis convenient, but wasteful because it requires unnecessary\nbranch instructions.  The instruction can be placed with\nthe static data, but this causes more problems.  First, the\nEX instruction is removed in the source from the instruction\nbeing EXecuted, making the program harder to read.  Second,\nthe USING environment of the EXecuted instruction may be\ncompletely different from that of the EX instruction, making the\ncoding of meaningful labels difficult or impossible.\n:p.\nPerhaps the best solution is to use the LOCTR assembler instruction.\nThis instruction establishes a new location counter for whatever\ndata follows.  Any data or instruction defined with a new location\ncounter will be collected and placed at the end of the load module.\nThis way, the EXecuted instruction can be defined inline with the\ncurrent USING environment, but will be placed at the end of the\nload module where no branch is needed to skip over it.\n:p.\nHowever, all of these methods have one problem in common when\nused with the Structured Macros.  They all require you\nto code tags in the body of the program.  Since the Structured\nMacros eliminate the need for tags in the rest of the program,\nthis can upset the indentation scheme and make the program look\n:q.messy:eq. and difficult to read.\n:p.\nA solution to all of these problems would be to provide a\nmacro to generate the EX instruction and its object and to\ngenerate the tags automatically.  This way, the source could\nstill be coded without the use of any tags.  The EXI macro\nis included with the Structured Macros to provide this function.\nIt can accept any register for the EX instruction, and allows\nthe user to specify any opcode and one to three operands.\nFor example:\n:xmp.\n EXI   R3,(MVC,DEST(0),0(R10))\n:exmp.\n:pc.\nThis will generate a MVC instruction with the operands specified\nand an EX instruction using register 3 and the MVC.\n:p.\nIf the LOCTR option was specified on the program block, the EXI\nmacro puts the EXecuted instruction in the PSD (or the SSD if it\nis within a subroutine).  If NOLOCTR was specified, EXI will generate\nthe instruction inline with a branch around it.\n.cp 20\n:h2.Loading control block addresses\n:p.\n.rc 1 on\nThere are certain system control blocks that programmers find\nthemselves accessing often.  The LCBA macro is provided to give\nyou a standard way of finding these control blocks.\nThe LCBA macro locates the address of the specified control block\nand places it in the specified register.  The mapping macros for\nany control blocks LCBA uses to find the desired control block\nare not required.\n.rc 1 off\nThe LCBA macro can be used to load the address of the:\n:sl compact.\n:li.current ACEE,\n:li.current ASCB,\n.rc 1 on\n:li.current ASXB,\n.rc 1 off\n:li.CVT,\n:li.current TCB,\n:li.UJT (Clemson dependent),\n:li.and UVT (Clemson dependent).\n:esl.\n.rc 1 on\n:p.\nFor example:\n:xmp.\n LCBA   R8,ACEE\n IF     (Z)\n    -- ACEE not found code --\n ENDIF\n USING  ACEE,R8\n    -- Now have ACEE --\n:exmp.\n.rc 1 off\n.*\n.cp 20\n.rc 3 on\n:h2.Controlling Structured Macro Operation\n:p.\nThere are times when a decision must be made in the middle of a\nprogram that needs to affect the operation of the Structured Macros\nat a later time.  To provide for this capability, the SMCTRL macro\nwas created to set flags that are checked by other macros.\n:p.\nOne example of this use is the reusable PWA support.  You\nuse SMCTRL to inform the macros that the PWA should be freed when\nthe current invocation of the program is terminated.\n.rc 3 off\n.*\n.*\n:h1.Miscellaneous Examples\nThis section will provide some examples for pieces of code that\nprogrammers find themselves writing often.\n.*\n:h2.A Search Loop\n:p.\nWhile search routines can be as\ndifferent as the data structures they are\naccessing, they are usually similar in their general structure.\nThis is an example of a\nsequential search routine that looks through a RACF access list.\n:xmp.\n  BLOCK NAME=SEARCH\n*\n*   Set up list pointer and count for search.\n*\n   LA   R2,ACL\n   LH   R3,ACLCNT\n*\n*   Now loop through the access list (ACLCNT) times.\n*\n   LOOP BCT\n    IF  (CLC,USERID(8),EQ,0(R2)),THEN\n*\n*   If compare succeeds, do success code and leave.\n*\n          :\n     -- success code --\n          :\n     LEAVE BLOCK=SEARCH\n    ENDIF\n*\n*  Point to next entry, try again.\n*\n    LA  R2,ACLLEN(,R2)\n   ENDLOOP BCT,R3\n*\n*  Entire ACL searched without a hit, do fail code.\n*\n          :\n    -- fail code --\n          :\n  ENDBLK BLOCK=SEARCH\n          :\n:exmp.\n.*\n:h2.Scanning Text\n:p.\nThis routine (lifted from the nesting level pre-processor)\nuses a BXLE and\na BXH loop to scan a line of assembler source for its opcode.\n:xmp.\n.tp 47\n*\n*   Set up for BXLE loop:\n*     R1 points to start of source code line\n*     R14 contains increment for R1\n*     R15 contains A(end of line) as limit for R1\n*\n  LA   R1,LINE!R1 -> start of line\n  LA   R14,1!Set increment to 1\n  LA   R15,LINE+L'LINE!R15 -> end of line\n.sk\n  LOOP  BXLE!Skip past any tags in col. 1\n   LEAVE LOOP=*,(CLI,0(R1),EQ,X'40')\n  ENDLOOP BXLE,R1,R14\n.sk\n*\n*   Now use remaining value in R1 as start for BXH loop.\n*\n  LOOP  BXH,R1,R14!Now scan for opcode\n.sk\n   IF   (CLI,0(R1),NE,X'40')\n.sk\n    IF  (CLC,0(6,R1),EQ,=C'BLOCK ')!If 'BLOCK'\n     IC R0,=C'B'!Set type to 'B'\n     CALLSUB NEST!Call NEST\n.sk\n    ELSEIF (CLC,0(7,R1),EQ,=C'ENDBLK ')!Elseif 'ENDBLK'\n     IC R0,=C'B'!Set type to 'B'\n     CALLSUB UNNEST!Call UNNEST\n.sk\n    ELSEIF!!( etc. )\n       :\n    ENDIF\n.sk\n*\n*   If outer IF succeeded, line is processed, so leave.\n*\n    LEAVE  LOOP=*\n   ENDIF\n.sk\n  ENDLOOP BXH!End of search loop.\n.tp\n:exmp.\n.pa\n.*\n:h2.A DCB EODAD Exit\n:p.\nOne way to use a DCB EODAD exit (or SYNAD, EOV and other DCB exits)\nwould be to :q.fake out:eq. the macros by coding a tag at the place your\nend-of-file code started and specifying EODAD=tag in the DCB.\nThis, however, becomes dangerous when running mixed-AMODE programs,\nsince the EODAD routine would have to be the same AMODE as the\nroutine where the GET was issued. To avoid this, one can take\nadvantage of the fact that R14 points to the instruction following the\nGET or READ macro whenever a DCB exit is called by using an\nimplied CALLSUB, as follows:\n:xmp.\n.tp 15 20 40\n  OPEN  DCB,INPUT\n.sk\n  LOOP  UNTIL!!!Do 'endless' loop\n.sk\n*\n*  PWAF1EOF gets set if end-of-file was found.\n*\n   GET      DCB,RECORD\n   LEAVE    LOOP=*,(TBIT,PWAF1EOF,ON)\n   CALLSUB  EATREC\n.sk\n  ENDLOOP   UNTIL,LEAVE\n.sk\n  CLOSE DCB\n         :\n         :\n.rc 1 on\n  BLOCK NAME=EOF,TYPE=SUBROUTINE,OPTIONS=*NOSUBOPTS\n.rc 1 off\n   SBIT  PWAF1EOF\n  ENDBLK BLOCK=EOF\n         :\n         :\nPWAF1!DC!X'00'\nPWAF1EOF!EQU!X'80'\n  :\nDCB!DCB!EODAD=EOF,  ...\n.tp\n:exmp.\n:p.\nIf this sample were bimodal, subroutine EOF would have to be the\nsame AMODE as the code that issued the GET macro.\n.pa\n.*\n:h2.Returning R0 and R1 with ENDBLK\n:p.\nThere are many programming situations where it is desirable to\nreturn values or pointers to a calling program using registers\nzero and one. Common examples are Sort exits, lookup routines\nand user SVC's.\n:p.\n.rc 1 on\nThe Structured Macros provide a method for passing back R0 and/or R1\nfrom a program block.  You can\nuse the RTNR0 and/or RTNR1 options on the program block macro\nand specify the R0= and/or R1= keyword on the ENDBLK for the program\nand all error exits.\n:xmp.\n.tp 40\n BLOCK NAME=TEST,TYPE=PROGRAM,OPTIONS=*PWA,RTNR0,RTNR1\n       :\n       :\n ENDBLK BLOCK=TEST,RC=0,R0=8,R1=PARMLIST\n       :\n BLOCK NAME=ERR1,TYPE=ERREXIT\n       :\n ENDBLK BLOCK=TEST,RC=8,R0=0,R1=0\n.tp\n:exmp.\n.rc 1 off\n.rc 1 on\n:p.\nIf you are using an internal\nsubroutine that has an SWA\nand would like to have the subroutine return a register\nto its caller, you can use the STRSA macro.\n.rc 1 off\n.rc 3 on\n.*\n.*\n:h1.Structured Macros Listing Program\n:p.\nTo aid the programmer, a listing program was written that will\nanalyze the nesting structure of a program and report on any problems.\nIt also provides a listing of the original program without the\nmacro expansions that tend to blur the structured nature of the\nprogram.  Once they have gotten used to it, many programmers use\nthis listing for most of their work, and only refer to the assembler\nlisting occasionally.\nJCL procedures have been provided that will run this listing program\nand then feed the assembler source into the Level H Assembler.\nSee :hdref refid=asmproc page=no. for more information.\n.*\n:h2.Output of the Listing Program\n:p.\nBelow is an example of the output of the listing program.  It displays\nthe original input source, along with the current nesting level\ndepth and a diagram of the nesting type (Block, Loop, or If).\n:xmp.\n.bf data\nLVL NESTING    SOURCE STATEMENT              MSC0150$ V1R4  15:43 89.117\n\n001  B    | BLOCK   NAME=TEST,TYPE=PROGRAM,OPTIONS=(*PWA) |\n001  B    |*                                              |\n002  BL   |  LOOP   WHILE,(CR,R4,LT,R5)                   |\n003  BLI  |   IF    (C,R3,GE,XYZ)                         |\n003  BLI  |    MVC  ABC,XYZ                               |\n002  BL   |   ENDIF                                       |\n001  B    |  ENDLOOP WHILE                                |\n001  B    |  CALLSUB SUB1                                 |\n001  B    |*                                              |\n000       | ENDBLK  BLOCK=TEST                            |\n000       |*                                              |\n001  B    | BLOCK   NAME=SUB1,TYPE=SUBROUTINE             |\n001  B    |  LR     R1,R2                                 |\n000       | ENDBLK  BLOCK=SUB1                            |\n000       |*                                              |\n000       |         PSD                                   |\n000       |         LTORG                                 |\n000       |XYZ      DC    F'9'                            |\n000       |ABC      DC    F'4'                            |\n000       |         ENDPSD                                |\n000       |*                                              |\n000       |         PWA                                   |\n000       |PWAFLAG  DS    18F                             |\n000       |         ENDPWA                                |\n000       |*                                              |\n000       |         END                                   |\n.pf\n:exmp.\n:p.\nThe Structured Macros Listing Program will also point out any\nirregularities in the nesting structure of the program.  Below is the\nlisting produced by feeding an incorrect program into it.\n:xmp.\n.bf data\nLVL NESTING    SOURCE STATEMENT              MSC0150$ V1R4  15:43 89.117\n\n001  B    | BLOCK   NAME=TEST,TYPE=PROGRAM,OPTIONS=(*PWA) |\n001  B    |*                                              |\n002  BI   |  IF     (C,R3,GE,XYZ)                         |\n002  BI   |*                                              |\n002  BI   | ENDBLK  BLOCK=TEST                            |\n.ct  >E-8 NESTING PROBLEM\n002  BI   |*                                              |\n002  BI   |         END                                   |\n\n>E-8 ENDING STRUCTURAL LEVEL IS NON-ZERO\n.pf\n:exmp.\n.*\n:h2.Controlling Listing Program Operation\n:p.\nTo control the operation of the Structured Macros Listing Program,\nthe SMLIST macro has been provided.  Parameters on this macro are\nprocessed by the listing program itself, before the source statements\nare sent to the assembler.\n:p.\nCurrently, the only parameter available is CONVERT=YES/NO.\nCONVERT=YES instructs the listing program to convert the input source\nto all uppercase before feeding it to the assembler.  This allows you\nto write programs in upper and lower case.\nMany people find mixed case programs and comments easier to read and\nthis parameter makes it easy to do.\n:p.\nAlthough the assembler requires that its input be in upper case,\nlower case letters are allowed in text strings.  To prevent the\nlisting program from converting your mixed case text strings to\nupper case, place them in double quotes (\") instead of single\nquotes (').  The listing programs will not convert the text\nbetween double quotes and will change the double quotes back to\nsingle quotes before passing the line to the assembler.\n:p.\nWith this facility, programmers can write programs like the one below.\n:xmp.\n TRYLOWER    TITLE 'Example program for Structured Macros'\n             SMLIST CONVERT=YES\n *---------------------------------------------------------------------*\n *  Program     TRYLOWER\n *\n *  Abstract    This illustrates the use of lower case in assembler\n *              source using the SMLIST CONVERT=YES function of the\n *              Structured Macros Listing Program.\n *---------------------------------------------------------------------*\n          space 3\n  block   name=trylower,type=program,options=(*pwa,xa),amode=any,\n                rmode=any,r1save=r9\n   l      r15,4(r9)                    | Get output routine address.\n   la     r1,psdtext                   | Get pointer to text.\n   balr   r14,r15                      | Call output routine.\n  endblk  block=trylower\n          psd\n psdtext  dc    cl80\"This is a test that is true.\"\n          endpsd\n          pwa\n          endpwa\n:exmp.\n.rc 3 off\n.*\n.*\n.* don't print running footing on next page.\n.rf odd sup\n:h0.II. Structured Macros Reference\n.* can print running footing after this page.\n.rf odd res\n.* set up new even page footing (change short title variable)\n.se @stitle 'Structured Macros Reference\n.*\n.*\n:h1.BLOCK\n.* stop chapter headings from starting on odd pages\n.* by redefining duplex mode and calling DSM#DUPL macro\n.* back from the library.\n.se SYSVARD = 'no'\n.dm dsm#dupl lib\n:dl.\n:dt.Macro:\n:dd.BLOCK\n:dt.Abstract:\n:dd.Structured macro used to start a block.\n:dt.Syntax:\n.rc 1 on\n:dd.BLOCK &lbt.NAME=name&rbt.&lbt.,TYPE=type&rbt.&lbt.,ENVIRON=environ\n.ct &rbt.&lbt.,keyword&lbt.,keyword,...&rbt.&rbt.\n.rc 1 off\n:dt.Operands:\n:dd.:dl termhi=1.\n:dt.name\n:dd.Name of block.  This operand is required for\nprogram and subroutine blocks.\n:dt.type\n:dd.Type of block.  This keyword specifies the type of block.\nIf this keyword is not specified, INLINE is assumed.\n:p.\nThe type of blocks are ERREXIT, INLINE, PROGRAM, and SUBROUTINE.\n:p.\nAn errexit block contains code to be executed when an ERREXIT\nmacro is executed.  This type of block must be coded at\nblock level zero.\n:p.\nInline blocks are used to group a section of code into a logical\nstructure.\n:p.\nSubroutine blocks contain code that is executed when a CALLSUB\nmacro specifying its name is executed.\nA subroutine block must be coded at\nblock level zero.\n:p.\nA program block is used to contain the\nmain code body of a program.  Program\nblocks can only be specified at block level zero.\n.rc 1 on\n:dt.environ\n:dd.Program environment.  This keyword specifies the type of\nenvironment the program will run in.  The currently supported\nenvironments are: OS for OS linkage, DC for IDMS/DC and\nPLI for the execution environment of the PL/I Optimizing Compiler.\nThis keyword defaults to OS.\n.rc 1 off\n:dt.keyword\n:dd.\nIndicates linkage and initialization to be done.  Using these\nkeywords will cause the associated ENDBLK to do the reverse linkage.\nThe keywords allowed depend on the type of block being defined.\n(See the sections on the individual block types for more information\non the keywords allowed.)\n:edl.\n.rc 1 on\n.cp 6\n:dt.Errors:\n:dd.:ul compact.\n:li.Too many parameters specified on PL keyword\n:li.INLINE BLOCK must be contained within PROGRAM, SUBROUTINE, or\nERREXIT BLOCK\n:li.PROGRAM BLOCK must be at block nesting level 1\n:li.PROGRAM BLOCK requires NAME keyword\n:li.SUBROUTINE BLOCK requires NAME keyword\n:li.ENVIRON must be less than 5 alphanumeric characters\n:li.SUBROUTINE BLOCK must follow ENDBLK for PROGRAM BLOCK\nand be at block level zero\n:li.ERREXIT BLOCK must follow ENDBLK for PROGRAM BLOCK\nand be at block level zero\n:li.Maximum nesting level for blocks is 20\n:li.Invalid BLOCK type <type>\n:eul.\n:edl.\n.rc 1 off\n.*\n.pa\n:h2.BLOCK TYPE=ERREXIT\n:p.\nThe errexit block surrounds code to be performed after a fatal\nerror is detected.  It is invoked by the ERREXIT macro.\nThe ENDBLK macro\nassociated with an errexit block generates a branch to the ENDBLK\ncode of the most recent\nprogram block, and allows you to specify a return code\nwith which the program will terminate.  This return code overrides\nany return code that may appear on the program block's ENDBLK macro.\nOne errexit block without a name keyword\ncan be associated with a program block, in which case, a generated\nname is used.\nTherefore, if you have only one errexit block, the NAME parameter\nmay be left off of the BLOCK and the ERREXIT macros and a name will\nbe automatically generated.\n:dl tsize=6 headhi=1 break.\n:dthd.Keywords for ERREXIT blocks:\n:dt.AMODE= 24 | 31 | ANY\n:dd.Specifies the addressing mode the block should run in.\nAmode switching code will be generated if required.\nThe default is AMODE=ANY which specifies that the errexit will\nrun in the amode in effect when it is invoked.\n:dt.PL= tag|(tag,num)\n:dd.Defines the default place to build parameter lists\n.rc 3 on\ngenerated within\n.rc 3 off\nthis block.\n:hp1.Tag:ehp1 defines the label for the start of parameter list\nstorage and :hp1.num:ehp1. is a self-defining term that represents\nthe maximum number of parameter list entries that the storage at\n:hp1.tag:ehp1. will hold.  This must be large\nenough to contain the largest parameter list in the block.  If num\nis not specified, the tag must have a length modifier that is a\nself-defining term.\n:dt.SAVE= (r1&lbt.,r2&rbt.,address)\n:dd.Requests that the register(s) named should be saved and\nrestored.  The :hp1.address:ehp1. operand provides the address of a\nplace to save the register(s).  If more than one register is\nspecified, a :q.STM:eq. instruction is generated: therefore,\nspecification of something like :q.R14,R12,address:eq. is valid.  The\nSAVE keyword may be used on errexit blocks to preserve some or\nall registers without requiring a standard OS save area.  The\nSAVE operand is not valid on program blocks, and should not be\nconfused with OPTIONS=SAVE.\n.rc 1 on\n:dt.Errors:\n:dd.Refer to :hdref refid=interr. for macros that start with\n:q.##EP:eq..\n.rc 1 off\n:edl.\n.*\n.pa\n:h2.BLOCK TYPE=INLINE\n:p.\nThe inline block is used to surround a section of code that should\nbe treated as a single unit.\nWith the inline block, AMODE can be changed at the beginning of the\nblock and restored at the end.  Registers can also be saved and\nrestored.  The inline block also allows the user to define a logical\ngroup of code that can be exited with the LEAVE macro.\n:dl tsize=6 headhi=1 break.\n:dthd.Keywords for INLINE blocks:\n:dt.AMODE= 24 | 31 | ANY\n:dd.Specifies the addressing mode the block should run in.\nAmode switching code will be generated if required.\nThe default is AMODE=ANY which specifies that the block will\nrun in the amode in effect when it is entered.\n:dt.PL= tag|(tag,num)\n:dd.Defines the default place to build parameter lists\n.rc 3 on\ngenerated within\n.rc 3 off\nthis block.\n:hp1.Tag:ehp1 defines the label for the start of parameter list\nstorage and :hp1.num:ehp1. is a self-defining term that represents\nthe maximum number of parameter list entries that the storage at\n:hp1.tag:ehp1. will hold.  This must be large\nenough to contain the largest parameter list in the block.  If num\nis not specified, the tag must have a length modifier that is a\nself-defining term.\n:dt.SAVE= (r1&lbt.,r2&rbt.,address)\n:dd.Requests that the register(s) named should be saved and\nrestored.  The :hp1.address:ehp1. operand provides the address of\na place to save the register(s). If more than one register is\nspecified, a :q.STM:eq. instruction is generated: therefore,\nspecification of something like :q.R14,R12,address:eq. is valid.  The\nSAVE keyword may be used on inline blocks to preserve some or all\nregisters without requiring a standard OS save area.  The SAVE\noperand is not valid on program blocks, and should not be\nconfused with OPTIONS=SAVE.\n.rc 1 on\n:dt.Errors:\n:dd.Refer to :hdref refid=interr. for macros that start with\n:q.##IP:eq..\n.rc 1 off\n:edl.\n.*\n.pa\n.rc 1 on\n:h2.BLOCK TYPE=PROGRAM,ENVIRON=DC\n:p.\nThe IDMS/DC program block, like the OS program block, surrounds the\nmain body of executable code. Options on the IDMS/DC program block\ndetermine what type of IDMS/DC linkage is to be used, how IDMS/DC\nmacros are to be expanded, and end-of-task information for application\nprograms (for example, NEXT TASK CODE), as well as reentrancy,\nregister equating, and PWA allocation.\n:dl tsize=6 headhi=1 break.\n.* --------------------------------------------------------------------*\n:dthd.Keywords for program blocks with ENVIRON=DC specified:\n:dt.OPTIONS= option | (option&lbt.,option&lbt.,...&rbt.&rbt.)\n:dd.\n:hp2.Regular options::ehp2.\nThese are the options for individually controlling each of the BLOCK\nmacro's functions.  The default value for each of these options is\nthe negative form (NOCSECT, NOREGEQU, etc.) but note that many of\nthe options are included in all of the super options.\n:gl termhi=1.\n:gt.CSECT|NOCSECT\n:gd.Indicates that a CSECT card should be generated with the name of\nthe block.  If NOCSECT is specified, you\nwill need to code a USING name,R15 before the BLOCK macro if the\nLOADBASE option is in affect.\n:gt.ID|NOID\n:gd.Specifies that a DC should be generated at the start of the\nprogram, containing the program block name, assembly date, and\nassembly time.  If the CPYRGHT keyword is specified, it will also be\nDC'ed.\n:gt.LOCTR|NOLOCTR\n:gd.Cause the macros to generate LOCTR instructions for the program,\nsubroutines, and static data areas to insure proper placement.\nThis option must be selected if the program is using PSDs and SSDs\nor LONG and LOADBASE.\n:gt.LONG|NOLONG\n:gd.Indicates that CALLSUBs should generate a BALR\n(or equivalent) instead of a\nBAL to allow subroutines to establish a base register.  This\noption is required if the program has any subroutines that use\nLOADBASE.  The LOCTR option is required if this option is specified.\n:gt.MODE|NOMODE\n:gd.Enables generation of AMODE and RMODE cards.\n:gt.PWA|NOPWA\n:gd.Specifies that this program will have a PWA.  The PWA will\nbe acquired using #GETSTG and freed using #FREESTG if option RENT\nis in effect.  If the NORENT option is in effect, the ENDPWA macro\nwill generate a DS instruction to reserve storage for the PWA within\nthe CSECT.\nThe PWA and ENDPWA macros should be used to define the limits of the\nPWA.  This option is required if the program has subroutines that use\nSWAs.\n:gt.REGEQU|NOREGEQU\n:gd.Specifies that register equates are to be generated.\n:gt.RENT|NORENT\n:gd.Specifies that the program is reentrant and that the macros\nshould generate reentrant code wherever necessary.\n:gt.RTNR0|NORTNR0\n:gd.Indicates that register zero should be passed back to\nthe caller.  Use the R0= keyword on the ENDBLK macro for the\nprogram block and error exits to specify the value to be\nreturned. This is only valid with OPTIONS=SYSTEM, unless the\nroutine is handling its own delinkage and needs a value in R0\nfrom within the program block.\n:gt.RTNR1|NORTNR1\n:gd.Indicates that register one should be passed back to\nthe caller.  Use the R1= keyword on the ENDBLK macro for the\nprogram block and error exits to specify the value to be\nreturned. This is only valid with OPTIONS=SYSTEM, unless the\nroutine is handling its own delinkage and needs a value in R1\nfrom within the program block.\n:gt.VL|NOVL\n:gd.Forces all generated parameter lists (PLIST, CALLSUB, CALLX) to\ndefault to VL unless overridden.\n:gt.XA|NOXA\n:gd.Generates support for linkage using XA instructions.  If neither\nXA or 370 is specified, 370 is the default.\n:gt.370|NO370\n:gd.Generates support for linkage using 370 instructions.  If\nOPTIONS=XA is also specified, OPTIONS=370 causes generation of code\nwhich determines whether the program is running under MVS/XA or not,\nand will cause branches around XA-dependent instructions generated by\nthe Structured Macros such as the amode switches.\n:gt.DCMACPRT/NODCMACPRT\n:gd.Provides support for the #MOPT MACPRNT=ON/OFF operand, for those\nIDMS/DC macros that make use of it.\n:gt.DCPRGPRT/NODCPRGPRT\n:gd.Provides support for the #MOPT PRGPRNT=ON/OFF operand, for those\nIDMS/DC macros that make use of it.\n:gt.SYSTEM or (SYSTEM,module#) / NOSYSTEM\n:gd.Presence of the SYSTEM keyword causes IDMS/DC system-mode linkage\nto be generated.\n:gt.#START/NO#START\n:gd.Causes a #START macro to be generated by the BLOCK macro. Valid\nonly with the SYSTEM option.\n:gt.#RTN/NO#RTN\n:gd.Causes a #RTN macro to be generated by the ENDBLK macro. Valid only\nwith the SYSTEM option.\n:gt.#RETURN/NO#RETURN\n:gd.Causes ENDBLK to generate a #RETURN macro. Valid only with\nNOSYSTEM option.\n:gt.GETSTK\n:gd.Causes BLOCK to generate a #GETSTK instead of #GETSTG. Valid only\nwith SYSTEM and PWA options.\n:gt.(NXTTASK,taskcode)\n:gd.Specifies the IDMS/DC task code which should be initiated next.\nValid only with #RETURN option.\n:gt.(TYPE,returntype)\n:gd.Specifies the type of program termination (NORMAL, ABORT or\nCONTINUE). This option is generally used only with IDMS/DC #STAE\nroutines. Valid only with #RETURN option.\n:gt.(RESINT,interval)\n:gd.Specifies the resource timeout interval for this task termination.\nValid only with #RETURN option.\n:gt.(RESPGM,pgmname)\n:gd.Specifies a resource timeout handler program, which will be called\nif the resource timeout interval was specified and reached.\nValid only with #RETURN option.\n:gt.(EP,entrypoint)\n:gd.Specifies an entry point name (other than the CSECT name) to be\nincluded on the #START macro. If this option is not coded, the entry\npoint name is assumed to be :q.#ST:eq. followed by the internal program\nblock number (usually 1).\nValid only with SYSTEM and #START options.\n:egl.\n.* --------------------------------------------------------------------*\n:p.\nIf a type of regular option is specified more than once, the last\noccurrence (ie. PWA or NOPWA) is used.\n:p.\n:hp2.Super options::ehp2.\nThese are provided as combinations\nof the most popular options. If one\nor more options is not needed, it should be specified as desired\nfollowing the super option's specification.\n:p.\n*NORENT - selects options CSECT, ID, LOCTR, MODE, REGEQU,\nVL and #RETURN.\n:p.\n*NORENTSYS - selects options CSECT, ID, LOCTR, MODE, REGEQU, VL,\n#START, #RTN and SYSTEM.\n:p.\n*RENT - selects options CSECT, ID, LOCTR, MODE, REGEQU, RENT, VL\nand #RETURN.\n:p.\n*RENTSYS - selects options CSECT, ID, LOCTR, MODE, REGEQU, RENT, VL,\n#START, #RTN and SYSTEM.\n:p.\n*PWA - selects options CSECT, ID, LOCTR, MODE, PWA, REGEQU, RENT, VL\nand #RETURN.\n:p.\n*PWASYS - selects options CSECT, ID, LOCTR, MODE, PWA, REGEQU, RENT, VL,\n#START, #RTN and SYSTEM.\n:p.\n:dt.AMODE= 24 | 31 | ANY\n:dd.Specifies the addressing mode.  This keyword causes an\nAMODE card to be generated by the assembler with the\nspecified amode.  If this keyword is not specified, no AMODE\ncard will be generated.\n:dt.BASEREG= reg | (reg&lbt.,reg&lbt.,...&rbt.&rbt.)\n:dd.Specifies the register or registers to be used\nfor program addressability.  The register can not be\nR0, R1, R14, or R15.\nBASEREG will default to R13 if the NORENT option is in\neffect and the SVAREA keyword is not specified;\notherwise, it will default to R12.\n:dt.CPYRGHT= notice\n:dd.Specifies a quoted string that\nwill be DC'ed if the ID option is in effect.\n:dt.PL= tag|(tag,num)\n:dd.Defines the default place to build parameter lists\n.rc 3 on\ngenerated within\n.rc 3 off\nthis block.\n:hp1.Tag:ehp1 defines the label for the start of parameter list\nstorage and :hp1.num:ehp1. is a self-defining term that represents\nthe maximum number of parameter list entries that the storage at\n:hp1.tag:ehp1. will hold.  This must be large\nenough to contain the largest parameter list in the block.  If num\nis not specified, the tag must have a length modifier that is a\nself-defining term.\n:dt.PWAREG= R11 | (R11,&lbt.reg&lbt.,...&rbt.&rbt.)\n:dd.Specifies the register or registers to be used\nfor PWA addressability.\n:dt.RMODE= 24 | ANY\n:dd.Specifies the residency mode.\n:dt.R1SAVE= register\n:dd.The number of the register that register 1 should be copied to.\nProgram linkage (notably the use of #GETSTG or #GETSTK)\nsometimes destroys the contents of register 1 from\nentry.  This keyword is useful for copying the contents of the\nparameter register to another register before it is destroyed.\n:dt.SMWA= address\n:dd.Provides the address of a Structured Macro Workarea (SMWA). The\nSMWA is a doubleword of storage which is used to preserve addressing\nmode and a work register while performing AMODE switching.\nThe SMWA keyword is valid only on a PROGRAM block, and is required\nwhen both the 370 and XA options are in effect, or when AMODE=ANY\nis specified. The SMWA may reside in the PWA.\nIf the program has a PWA, space for the SMWA is\nautomatically allocated in the PWA, and this keyword is not\nnecessary.\n:dt.SUBOPTS= (option,...)\n:dd.Can be used to specify a default set of options for all\nsubroutine blocks associated with this program.  Any options\nspecified on subsequent subroutine blocks will be in addition to\nthese options.  See :hdref refid=subblk page=no. for a description\nof the valid subroutine block options.\n.* --------------------------------------------------------------------*\n:dl tsize=6 headhi=1 break.\n:dt.Errors:\n:dd.Refer to ##PPDC in :hdref refid=interr..\n:edl.\n:edl.\n.rc 1 off\n.*\n.pa\n.rc 1 on\n:h2.BLOCK TYPE=PROGRAM,ENVIRON=OS\n.rc 1 off\n:p.\nThe program block surrounds the main body of executable code.\nIt can perform a wide variety of linkage types and initializations,\nincluding standard save area linkage,\nregister equates, automatic allocation of Program Work Area, and\nDynamic Storage Management.\nIf the program block keywords and options\nare not used to establish linkage,  the\nBLOCK macro call should follow linkage code and the associated\nENDBLK macro should be followed by the reverse linkage.\n:dl tsize=6 headhi=1 break.\n:dthd.Keywords for program blocks with ENVIRON=OS specified:\n:dt.OPTIONS= option | (option&lbt.,option&lbt.,...&rbt.&rbt.)\n:dd.\n:hp2.Regular options::ehp2.\nThese are the options for individually controlling each of the BLOCK\nmacro's functions.  The default value for each of these options is\nthe negative form (NOBR14, NOCSECT, etc.) but note that many of\nthe options are included in all of the super options.\n:gl termhi=1.\n:gt.BR14|NOBR14\n:gd.Determines whether a program block's ENDBLK macro should\ngenerate a BR 14 instruction or not. The default is NOBR14, but note\nthat BR14 is included in each super option.\n:gt.CLEARPWA|NOCLEARPWA\n:gd.Specifies whether the PWA should be cleared to zeros or not.\n.rc 2 on\n:gt.CLRDEBUG|NOCLRDEBUG\n:gd.Specifies whether the debug area in the ESV should be cleared at\nentry to this program block.  CLRDEBUG requires the ESV option.\n.rc 2 off\n:gt.CSECT|NOCSECT\n:gd.Indicates that a CSECT card should be generated with the name of\nthe block along with a USING name,R15.  If NOCSECT is specified, you\nwill need to code a USING name,R15 before the BLOCK macro if the\nLOADBASE option is in affect.\n:gt.DYN|NODYN\n:gd.Indicates that Dynamic Storage Management should be used.\nWith this option, PWA and SWA storage is allocated from the dynamic\nstorage area.\nWhen the DYN option is on, register 11 is used as a base for\nSWAs and can not be used by the programmer.\n.rc 2 on\n:gt.ERRADDR|NOERRADDR\n:gd.Indicates that the ERREXIT macro should use\na BAS instruction when branching to\nan errexit block.  If a code is specified,\nit will be defined in the halfword immediately following the BAS\ninstruction.  The effect of the ERRADDR option is that at entry to\nan errexit block, the CODEREG has the address of the invoking ERREXIT\nmacro.  If NOERRADDR is specified, a BCC instruction is generated\nby the ERREXIT macro to invoke an errexit block and the CODEREG\nis loaded with the code itself.\n.rc 2 off\n.rc 2 on\n:gt.(ESV,&lbt.parmnum&rbt.,&lbt.esvtag&rbt.)|NOESV\n:gd.Specifies that an Environment Support Vector is present.  The\nmacros will use the ESV to locate routines to do all environment\ndependent services.  Parameter :hp1.parmnum:ehp1. defaults to 3\nand is the number of the parameter at input to the program block\nthat contains a pointer to the ESV.  If the FNCODE option is in\neffect, this parameter is only referenced on the\n:q.startup:eq. call.  Parameter :hp1.esvtag:ehp1. defaults to\nPWAAESV and is the tag to be generated in the PWA for a word\ninto which the program block macro will store the address of the\nESV.  The ESV option requires the PWA and RENT options.\nThe NOESV option indicates that the macros should call OS\nservices directly.\n.rc 2 off\n.rc 2 on\n:gt.(FNCODE,&lbt.parmnum&rbt.,&lbt.startcode&rbt.)|NOFNCODE\n:gd.Specifies that a function code is passed as a parameter to\nthis program.  Parameter :hp1.parmnum:ehp1. defaults to 2 and is\nthe number of the parameter at input to the program block that\ncontains a pointer to the function code.  Parameter\n:hp1.startcode:ehp1. defaults to AL4(1) and is the value of the\nstartup function code.  This parameter can be any form that is\nvalid to the right of a DC instruction.  This option is ignored\nif option REUSPWA is not in effect.\n.rc 2 off\n:gt.ID|NOID\n:gd.Specifies that a DC should be generated at the start of the\nprogram, containing the program block name, assembly date, and\nassembly time.  If the CPYRGHT keyword is specified, it will also be\nDC'ed.\n:gt.LOADBASE|NOLOADBASE\n:gd.Specifies that program base registers are to be loaded. LOADBASE\nis assumed if the BASEREG= keyword is specified.\n:gt.LOCTR|NOLOCTR\n:gd.Cause the macros to generate LOCTR instructions for the program,\nsubroutines, and static data areas to insure proper placement.\nThis option must be selected if the program is using PSDs and SSDs\nor LONG and LOADBASE.\n:gt.LONG|NOLONG\n:gd.Indicates that CALLSUBs should generate a BALR\n(or equivalent) instead of a\nBAL to allow subroutines to establish a base register.  This\noption is required if the program has any subroutines that use\nLOADBASE.  The LOCTR option is required if this option is specified.\n:gt.MAIN|NOMAIN\n:gd.Indicates that this is a main program and dynamic storage should\nalways be obtained if Dynamic Storage Management is being used.\nIf NOMAIN is specified, the storage already allocated by the calling\nprogram will be used if it is sufficient, otherwise extra storage\nwill be obtained.\n:gt.MODE|NOMODE\n:gd.Enables generation of AMODE and RMODE cards.\n:gt.OPTSTOR|NOOPSTOR\n:gd.Turns on storage optimization to reduce the size of the load\nmodule.  If your program has a large number of internal subroutines,\nthis can save you a significant amount of storage, but will slow\ndown subroutine calls slightly.  This option in only valid for\nprograms with the DYN option.\n.rc 3 on\n:gt.(PARMS&lbt.,options...&rbt.)|NOPARMS\n:gd.Indicates that this program has an input parameter list\nand therefore register one should be preserved during program\nlinkage.  This option is also used to specify\noptions for handling the input parameter list.\nAny parameter option not specified will take on its default,\n:q.NO:eq. state.  The available parameter options are:\n:gl compact termhi=3.\n:gt.COPY|NOCOPY\n:gd.Specifies that the input parameter list should be copied to the\nPWA.  An area large enough to contain the entire list is reserved\nand the entire parameter list is copied here at the start of the\nprogram.  Any missing parameters (including those left off the end\nof a VL parameter list) will contain an address of zero.\nUse of this option requires the PWA option.\n.rc 4 on\n:gt.(COPYERROR,errexit&lbt.,exitcode&rbt.)|NOCOPYERROR\n:gd.Identifies an error exit and optionally an exit code that will\nbe invoked if the input parameter list overruns the space reserved\nfor it in the PWA during a (PARMS,COPY,VL) operation.  This suboption\nis required when (PARMS,COPY,VL) is specified.  If specified,\n:hp1.exitcode:ehp1. is passed in the default code register R14 and\nmust follow the same restrictions as CODE= on the ERREXIT macro.\nIf :hp1.errexit:ehp1. is specified as a null string, e.g.\n(COPYERROR,), the unnamed error exit for this program block will\nbe invoked in case of a copy failure.\n:gt.(COUNT,tag)|NOCOUNT\n:gd.Specifies that a count of the parameters actually specified in the\ninput parameter list be made and that the result be placed in the\nfullword at location :hp1.tag:ehp1..  The use of this option requires\nthe VL suboption of PARMS.\n.rc 4 off\n:gt.PREFIX|NOPREFIX\n:gd.Specifies that the tags listed in the PARMS keyword for this\nblock should be prefixed with the &amp.PPL symbol before placing\nthem within the PPL.  This give all the tags within the PPL a\nunique prefix so there will not be any collisions with tags within\nother structures.  If this option is specified, any references to\ntags within the PPL from the program will have to be coded as:\n&amp.PPL.:hp1.tag:ehp1.\n:gt.(USING,reg)|NOUSING\n:gd.Specifies that :hp1.reg:ehp1. should be used to establish\naddressibility on the input parameter list.  The specified register\nis loaded with the contents of register one unless the COPY option\nis also specified.  In this case, :hp1.reg:ehp1 will be loaded with\nthe address of the input parameter list storage in the PWA.\n:gt.VL|NOVL\n:gd.Specifies that the input parameter list is a variable length (VL)\nparameter list.  For VL parameter lists, the COPY option will\nloop through the parameters instead of doing a block copy.  If the\nCOPY option is being used, the high order bit in the last item of the\ncopied parameter list will be cleared.\n:egl.\n.rc 3 off\n:gt.PWA|NOPWA\n:gd.Specifies that this program will have a PWA.  The PWA will\nbe either GETMAINed or obtained from dynamic storage if option RENT\nis in effect.  If the NORENT option is in effect, the ENDPWA macro\nwill generate a DS instruction to reserve storage for the PWA within\nthe CSECT.\nThe PWA and ENDPWA macros should be used to define the limits of the\nPWA.  This option is required if the program has subroutines that use\nSWAs.\n:gt.REGEQU|NOREGEQU\n:gd.Specifies that register equates are to be generated.\n:gt.RENT|NORENT\n:gd.Specifies that the program is reentrant and that the macros\nshould generate reentrant code wherever necessary.\n.rc 2 on\n:gt.(REUSPWA,&lbt.parmnum&rbt.)|NOREUSPWA\n:gd.Specifies that the same PWA storage should be used on multiple\ncalls to the program block.\nParameter :hp1.parmnum:ehp1. defaults to 1 and is\nthe number of the parameter at input to the program block that\ncontains a pointer to the PWA anchor.\nIf the FNCODE option is in effect, the PWA is obtained and its address\nstored in the anchor on the :q.startup:eq. call.  If NOFNCODE is\nin effect, the PWA is obtained and its address\nstored when the anchor at entry\ncontains binary zeros.  The PWA is freed by the ENDBLK macro when\nthe SMCTRL macro with FREEPWA=YES specified has been executed.\nREUSPWA requires the PWA, RENT and SAVE\noptions.  NOREUSPWA indicates that the PWA should be obtained and\nfreed each time the program block is called.\n.rc 2 off\n.rc 1 on\n:gt.RTNR0|NORTNR0\n:gd.Indicates that register zero should be passed back to\nthe caller.  Use the R0= keyword on the ENDBLK macro for the\nprogram block and error exits to specify the value to be\nreturned.\n:gt.RTNR1|NORTNR1\n:gd.Indicates that register one should be passed back to the\ncaller.  Use the R1= keyword on the ENDBLK macro for the\nprogram block and error exits to specify the value to be\nreturned.\n.rc 1 off\n:gt.SAVE|NOSAVE\n:gd.Save R14-R12 in the standard save area pointed to by register 13.\n:gt.SAVEAREA|NOSAVEAREA\n:gd.Obtain a save area, do forward and backward linking, and point\nR13 to new save area.  If NORENT was specified, the save area will\nbe obtained inline.  If RENT was specified, it will be GETMAINed\nor obtained from the PWA.  SAVEAREA is assumed if the PWA option\nis specified.\n:gt.VL|NOVL\n:gd.Forces all generated parameter lists (PLIST, CALLSUB, CALLX) to\ndefault to VL unless overridden.\n:gt.XA|NOXA\n:gd.Generates support for linkage using XA instructions.  If neither\nXA or 370 is specified, 370 is the default.\n:gt.370|NO370\n:gd.Generates support for linkage using 370 instructions.  If\nOPTIONS=XA is also specified, OPTIONS=370 causes generation of code\nwhich determines whether the program is running under MVS/XA or not,\nand will cause branches around XA-dependent instructions generated by\nthe Structured Macros such as the amode switches.\n:egl.\n:p.\nIf a type of regular option is specified more than once, the last\noccurrence (ie. PWA or NOPWA) is used.\n:p.\n:hp2.Super options::ehp2.\nThese are provided as combinations of the most popular options.\nIf one or more options is not needed, it should be specified as\ndesired following the super option's specification.\n:p.\n*NORENT - selects options NOPWA, SAVE, BR14, SAVEAREA, NORENT, ID,\n.rc 2 on\nCSECT, REGEQU, LOADBASE, MODE, VL, NODYN, NOMAIN, NOLONG,\nLOCTR, NORTNR0, NORTNR1, NOREUSPWA, NOFNCODE, NOESV, NOERRADDR and\nNOCLRDEBUG.\n.rc 2 off\n:p.\n*RENT - selects options NOPWA, SAVE, BR14, SAVEAREA, RENT, ID,\n.rc 2 on\nCSECT, REGEQU, LOADBASE, MODE, VL, NODYN, NOMAIN, NOLONG,\nLOCTR, NORTNR0, NORTNR1, NOREUSPWA, NOFNCODE, NOESV, NOERRADDR and\nNOCLRDEBUG.\n.rc 2 off\n:p.\n*PWA - selects options PWA, CLEARPWA, SAVE, BR14, SAVEAREA, RENT, ID,\n.rc 2 on\nCSECT, REGEQU, LOADBASE, MODE, VL, NODYN, NOMAIN, NOLONG,\nLOCTR, NORTNR0, NORTNR1, NOREUSPWA, NOFNCODE, NOESV, NOERRADDR and\nNOCLRDEBUG.\n.rc 2 off\n:p.\n*MAIN - selects options PWA, CLEARPWA, SAVE, BR14, SAVEAREA, RENT, ID,\n.rc 2 on\nCSECT, REGEQU, LOADBASE, MODE, VL, DYN, MAIN, NOLONG,\nLOCTR, NORTNR0, NORTNR1, NOREUSPWA, NOFNCODE, NOESV, NOERRADDR and\nNOCLRDEBUG.\n.rc 2 off\n:p.\n*NOMAIN - selects options PWA, CLEARPWA, SAVE, BR14, SAVEAREA, RENT,\n.rc 2 on\nID, CSECT, REGEQU, LOADBASE, MODE, VL, DYN, NOMAIN, NOLONG,\nLOCTR, NORTNR0, NORTNR1, NOREUSPWA, NOFNCODE, NOESV, NOERRADDR and\nNOCLRDEBUG.\n:p.\n*SRVPRC - selects options PWA, CLEARPWA, SAVE, BR14, SAVEAREA, RENT,\nID, CSECT, REGEQU, LOADBASE, MODE, XA, NO370, VL, NODYN, NOMAIN,\nNOLONG, LOCTR, NORTNR0, NORTNR1, (REUSPWA,1), (FNCODE,2,AL4(1)),\n(ESV,3,PWAAESV), ERRADDR and CLRDEBUG.\n.rc 2 off\n:dt.AMODE= 24 | 31 | ANY\n:dd.Specifies the addressing mode.  This keyword causes an\nAMODE card to be generated by the assembler with the\nspecified amode.  If this keyword is not specified, no AMODE\ncard will be generated.\n:dt.BASEREG= reg | (reg&lbt.,reg&lbt.,...&rbt.&rbt.)\n:dd.Specifies the register or registers to be used\nfor program addressability.  The register can not be\nR0, R1, R14, or R15.\nBASEREG will default to R13 if the NORENT option is in\neffect and the SVAREA keyword is not specified;\notherwise, it will default to R12.\n:dt.CPYRGHT= notice\n:dd.Specifies a quoted string that\nwill be DC'ed if the ID option is in effect.\n:dt.DYNERR= name\n:dd.Specifies the name of the dynamic storage error exit name.\nIf DYNERR is not specified and a dynamic storage error occurs,\nan ABEND 0C1 will occur.\n:dt.DYNSIZE= &lbt.+|-&rbt.size\n:dd.Defines the amount of storage to be added to the PWA to be\nused for additional PWAs and SWAs.  A :q.+:eq. or :q.-:eq. can be\nspecified to indicate that the size should be added or subtracted\nfrom the size calculated by the macros.  If this keyword is not\nspecified, the size calculated by the macros is used.\n.rc 3 on\n:dt.PARMMAP=(dsect&lbt.,len&rbt.)\n:dd.Defines the Dsect to be used to map the input parameter list\nand its length.  This keyword can be used if the input parameter list\nis too complicated to describe with the PARMS keyword or if the\ninput parameter list is a standard form described by an existing\nDsect.  :hp1.len:ehp1. is only required if COPY is specified with\nthe PARMS option.\nThis keyword is mutually exclusive with the PARMS keyword.\n.rc 3 off\n.rc 3 on\n:dt.PARMS=(tag&lbt.,tag&lbt.,...&rbt.&rbt.)\n:dd.Defines the tags used to map the input parameter list.  These\nwill be used to generate the Program Parameter List (PPL) Dsect or\nto map the input parameter list storage in the PWA (if parameter\noption COPY was specified).  This also defines the size of the\ninput parameter list for the COPY option.\nThis keyword is mutually exclusive with the PARMMAP keyword.\n.rc 3 off\n:dt.PL= tag|(tag,num)\n:dd.Defines the default place to build parameter lists\n.rc 3 on\ngenerated within\n.rc 3 off\nthis block.\n:hp1.Tag:ehp1 defines the label for the start of parameter list\nstorage and :hp1.num:ehp1. is a self-defining term that represents\nthe maximum number of parameter list entries that the storage at\n:hp1.tag:ehp1. will hold.  This must be large\nenough to contain the largest parameter list in the block.  If num\nis not specified, the tag must have a length modifier that is a\nself-defining term.\n:dt.PWAREG= R13 | (R13,&lbt.reg&lbt.,...&rbt.&rbt.)\n:dd.Specifies the register or registers to be used\nfor PWA addressability.\n:dt.PWASP= number | symbol\n:dd.Specifies the number of the subpool in which the PWA is to be\nGETMAINed.  PWASP may only be specified on PROGRAM blocks with\nPWA included among the OPTIONS. The default subpool is zero.\n:dt.RMODE= 24 | ANY\n:dd.Specifies the residency mode.\n:dt.R1SAVE= register\n:dd.The number of the register that register 1 should be copied to.\nProgram linkage sometimes destroys the contents of register 1 from\nentry.  This keyword is useful for copying the contents of the\nparameter register to another register before it is destroyed.\n:dt.SMWA= address\n:dd.Provides the address of a Structured Macro Workarea (SMWA). The\nSMWA is a doubleword of storage which is used to preserve addressing\nmode and a work register while performing AMODE switching.\nThe SMWA keyword is valid only on a PROGRAM block, and is required\nwhen both the 370 and XA options are in effect, or when AMODE=ANY\nis specified. The SMWA may reside in the PWA.\nIf the program has a PWA, space for the SMWA is\nautomatically allocated in the PWA, and this keyword is not\nnecessary.\n:dt.SUBOPTS= (option,...)\n:dd.Can be used to specify a default set of options for all\nsubroutine blocks associated with this program.  Any options\nspecified on subsequent subroutine blocks will be in addition to\nthese options.  See :hdref refid=subblk page=no. for a description\nof the valid subroutine block options.\n:dt.SVAREA= tag\n:dd.Can be specified if the NORENT option is in effect and specifies\na relocatable tag that will be used to address the program save\narea.\n.rc 1 on\n:dt.Errors:\n:dd.Refer to ##PPOS in :hdref refid=interr..\n.rc 1 off\n:edl.\n.*\n.rc 1 on\n.pa\n:h2.BLOCK TYPE=PROGRAM,ENVIRON=PLI\n:p.\nThe program block surrounds the main body of executable\ncode.  If ENVIRON=PLI is specified, options can be specified\nto do various initialization and termination functions\nspecific to the OS PL/I Optimizing Compiler's execution time\nenvironment including obtaining and freeing a DSA, doing\nregister equates and automatically defining a DSA within the\nProgram Work Area.\n:dl tsize=6 headhi=1 break.\n:dthd.Keywords for program blocks with ENVIRON=PLI specified:\n:dt.OPTIONS= option | (option&lbt.,option&lbt.,...&rbt.&rbt.)\n:dd.\n:hp2.Regular options::ehp2.\nThese are the options for individually controlling each of the BLOCK\nmacro's functions.  The default value for each of these options is\nthe negative form (NOREGEQU, NOCSECT, etc.) but note that many of\nthe options are included in all of the super options.\n:gl termhi=1.\n:gt.CLEARPWA|NOCLEARPWA\n:gd.Specifies whether the PWA should be cleared to zeros or not.\n:gt.ID|NOID\n:gd.Specifies that a DC should be generated at the start of the\nprogram, containing the program block name, assembly date, and\nassembly time.  If the CPYRGHT keyword is specified, it will also be\nDC'ed.\n:gt.LOCTR|NOLOCTR\n:gd.Cause the macros to generate LOCTR instructions for the program,\nsubroutines, and static data areas to insure proper placement.\nThis option must be selected if the program is using PSDs and SSDs\nor LONG and LOADBASE.\n:gt.LONG|NOLONG\n:gd.Indicates that CALLSUBs should generate a BALR\n(or equivalent) instead of a\nBAL to allow subroutines to establish a base register.  This\noption is required if the program has any subroutines that use\nLOADBASE.  The LOCTR option is required if this option is specified.\n:gt.MODE|NOMODE\n:gd.Enables generation of AMODE and RMODE cards.\n:gt.PWA\n:gd.\nPWA can not be specified if ENVIRON=PLI is specified, but it\nis implied.  ENVIRON=PLI programs will have a PWA and can\ntake advantage of all of a PWA's features.  The PWA will be\nobtained in the same manner as and have the same format as a\nDynamic Storage Area that is obtained by PL/I.  The PWA and\nENDPWA macros should be used to define the limits of the\nPWA.\n:gt.REGEQU|NOREGEQU\n:gd.Specifies that register equates are to be generated.\n:gt.VL|NOVL\n:gd.Forces all generated parameter lists (PLIST, CALLSUB, CALLX) to\ndefault to VL unless overridden.\n:gt.XA|NOXA\n:gd.Generates support for linkage using XA instructions.  If neither\nXA or 370 is specified, 370 is the default.\n:gt.370|NO370\n:gd.Generates support for linkage using 370 instructions.  If\nOPTIONS=XA is also specified, OPTIONS=370 causes generation of code\nwhich determines whether the program is running under MVS/XA or not,\nand will cause branches around XA-dependent instructions generated by\nthe Structured Macros such as the amode switches.\n:egl.\n:p.\nIf a type of regular option is specified more than once, the last\noccurrence (ie. REGEQU or NOREGEQU) is used.\n:p.\n:hp2.Super options::ehp2.\nThese are provided as combinations\nof the most popular options. If one\nor more options is not needed, it should be specified as desired\nfollowing the super option's specification.\n:p.\n*STDPLI - selects options CLEARPWA, ID, REGEQU, MODE, NOXA, NO370,\nVL, LOCTR, NOLONG.\n:dt.BASEREG= R11 | (R11&lbt.,reg&lbt.,...&rbt.&rbt.)\n:dd.Specifies the register or registers to be used for\nprogram addressability.  The first register must be R11 and\nthe other registers can not be R0, R1, R12, R14, or R15.  BASEREG\ndefaults to R11.\n:dt.CPYRGHT= notice\n:dd.Specifies a quoted string that\nwill be DC'ed if the ID option is in effect.\n:dt.PL= tag|(tag,num)\n:dd.Defines the default place to build parameter lists\n.rc 3 on\ngenerated within\n.rc 3 off\nthis block.  If this keyword is not specified,\nthe correct amount of storage will automatically be reserved\nand used in the PWA.\n:hp1.Tag:ehp1 defines the label for the start of parameter list\nstorage and :hp1.num:ehp1. is a self-defining term that represents\nthe maximum number of parameter list entries that the storage at\n:hp1.tag:ehp1. will hold.  This must be large enough to\ncontain the largest parameter list in the block.  If num is\nnot specified, the tag must have a length modifier that is a\nself-defining term.\n:dt.PWAREG= R13 | (R13,&lbt.reg&lbt.,...&rbt.&rbt.)\n:dd.Specifies the register or registers to be used\nfor PWA addressability.\n:dt.RMODE= 24 | ANY\n:dd.Specifies the residency mode.\n:dt.SUBOPTS= (option,...)\n:dd.Can be used to specify a default set of options for all\nsubroutine blocks associated with this program.  Any options\nspecified on subsequent subroutine blocks will be in addition to\nthese options.  See :hdref refid=subblk page=no. for a description\nof the valid subroutine block options.\n:dt.Errors:\n:dd.Refer to ##PPPLI in :hdref refid=interr..\n.rc 1 off\n:edl.\n.*\n.pa\n:h2 id=subblk.BLOCK TYPE=SUBROUTINE\n:p.\nThe subroutine block contains code that is reached via the CALLSUB\nmacro.  This block must be at block level zero.  Subroutine blocks\nare meant for internal subroutines, not for a called program that\nfollows standard OS linkage conventions.\n:dl tsize=6 headhi=1 break.\n:dthd.Keywords for subroutine blocks:\n:dt.OPTIONS= option | (option&lbt.,option&lbt.,...&rbt.&rbt.)\n:dd.\n:hp2.Regular options::ehp2.\nThese are the options for individually controlling each of the BLOCK\nmacro's functions.  The default value for each of these options is\nthe negative form (NOSWA, NOCUSTOM, etc.).\n:gl termhi=1.\n:gt.CUSTOM|NOCUSTOM\n:gd.Specifies that the return instructions\nat the end of the subroutine block should not be generated.\nThis option should be used if you are going to handle\nall of the linkage details yourself.\nIf this option is specified, no other option or keywords\non the subroutine block can be specified.\n:gt.LOADBASE|NOLOADBASE\n:gd.Indicates that a base register (or registers) should be loaded\nto establish separate addressability to this subroutine.  The\nprogram base register is left intact providing addressability to\nthe program's static data.\n.rc 3 on\n:gt.(PARMS&lbt.,options...&rbt.)|NOPARMS\n:gd.Indicates that this subroutine has an input parameter list\nand therefore register one should be preserved during subroutine\nlinkage.  This option is also used to specify\noptions for handling the input parameter list.\nAny parameter option not specified will take on its default,\n:q.NO:eq. state.  The available parameter options are:\n:gl compact termhi=3.\n:gt.COPY|NOCOPY\n:gd.Specifies that the input parameter list should be copied to the\nSWA.  An area large enough to contain the entire list is reserved\nand the entire parameter list is copied here at the start of the\nsubroutine.  Any missing parameters (including those left off the end\nof a VL parameter list) will contain an address of zero.\nUse of this option requires the SWA option.\n:gt.PREFIX|NOPREFIX\n:gd.Specifies that the tags listed in the PARMS keyword for this\nblock should be prefixed with the &amp.SPL symbol before placing\nthem within the SPL.  This give all the tags within the SPL a\nunique prefix so there will not be any collisions with tags within\nother structures.  If this option is specified, any references to\ntags within the SPL from the subroutine will have to be coded as:\n&amp.SPL.:hp1.tag:ehp1. or &amp.P.:hp1.tag:ehp1..\n:gt.(USING,reg)|NOUSING\n:gd.Specifies that :hp1.reg:ehp1. should be used to establish\naddressibility on the input parameter list.  The specified register\nis loaded with the contents of register one unless the COPY option\nis also specified.  In this case, :hp1.reg:ehp1 will be loaded with\nthe address of the input parameter list storage in the SWA.\n:gt.VL|NOVL\n:gd.Specifies that the input parameter list is a variable length (VL)\nparameter list.  For VL parameter lists, the COPY option will\nloop through the parameters instead of doing a block copy.  If the\nCOPY option is being used, the high order bit in the last item of the\ncopied parameter list will be cleared.\n:egl.\n.rc 3 off\n:gt.SAVEUSING|NOSAVEUSING\n:gd.Specifies that a :q.PUSH USING:eq. should be done before the\nsubroutine and a :q.POP USING:eq. should be done after to save and\nrestore the USING environment around the subroutine.  This\nisolates any changes made to the USING environment in the\nsubroutine from the rest of the program.\n:gt.SWA|NOSWA\n:gd.Specifies that this subroutine has an SWA.  The PWA option\nmust be specified on the program block options to use this option.\nThe SWA will be obtained out of dynamic storage if the DYN option\nis being used, otherwise, it is allocated within the program's PWA.\nR0-R14 are automatically saved and restored if this option is\nspecified.  This option can not be used with the SAVE= keyword.\n:egl.\n:p.\n:hp2.Super options::ehp2.\nThese are provided as combinations\nof the most popular options. If one\nor more options is not needed, it should be specified as desired\nfollowing the super option's specification.\n:p.\n*SWA - selects options SWA, SAVEUSING\n:p.\n*NOSUBOPTS - selects options NOSWA, NOSAVEUSING, NOLOADBASE, NOCUSTOM,\n.rc 3 on\nNOPARMS\n.rc 3 off\n:dt.AMODE= 24 | 31 | ANY\n:dd.Specifies the addressing mode the block should run in.\nAmode switching code will be generated if required.\nThe default is AMODE=ANY which specifies that the subroutine will\nrun in the amode of its caller.\n:p.\n:hp2.Restriction::ehp2.\nAMODE 24 or 31 must be specified on a subroutine block if it\ncontains inline blocks with AMODE 24 or 31 specified.\n:dt.BASEREG= reg|(reg,...)\n:dd.Defines the base register(s) to be used to establish\naddressability to this subroutine.  If this keyword is not\nspecified, register 10 is used.\n.rc 1 on\nThe register(s) specified with this keyword are only used when\nLOADBASE is in effect.\n.rc 1 off\n.rc 3 on\n:dt.PARMMAP=(dsect&lbt.,len&rbt.)\n:dd.Defines the Dsect to be used to map the input parameter list\nand its length.  This keyword can be used if the input parameter list\nis too complicated to describe with the PARMS keyword or if the\ninput parameter list is a standard form described by an existing\nDsect.  :hp1.len:ehp1. is only required if COPY is specified with\nthe PARMS option.\nThis keyword is mutually exclusive with the PARMS keyword.\n.rc 3 off\n.rc 3 on\n:dt.PARMS=(tag&lbt.,tag&lbt.,...&rbt.&rbt.)\n:dd.Defines the tags used to map the input parameter list.  These\nwill be used to generate the Subroutine Parameter List (SPL) Dsect or\nto map the input parameter list storage in the SWA (if parameter\noption COPY was specified).  This also defines the size of the\ninput parameter list for the COPY option.\nThis keyword is mutually exclusive with the PARMMAP keyword.\n.rc 3 off\n:dt.PL= tag|(tag,num)\n:dd.Defines the default place to build parameter lists\n.rc 3 on\ngenerated within\n.rc 3 off\nthis block.\n:hp1.Tag:ehp1 defines the label for the start of parameter list\nstorage and :hp1.num:ehp1. is a self-defining term that represents\nthe maximum number of parameter list entries that the storage at\n:hp1.tag:ehp1. will hold.  This must be large\nenough to contain the largest parameter list in the block.  If num\nis not specified, the tag must have a length modifier that is a\nself-defining term.\n:dt.RECUR= number\n:dd.Specifies the maximum number of times the subroutine will be\ncalled recursively.  This is used in Dynamic Storage Management\nto calculate the amount of space needed for SWAs.  :hp1.Number:ehp1.\nshould be a self-defining term.\n:dt.SAVE= (r1&lbt.,r2&rbt.,address)\n:dd.Requests that the register(s) named should be saved and\nrestored.  The :hp1.address:ehp1. operand provides the address of a\nplace to save the register(s). If more than one register is\nspecified, a :q.STM:eq. instruction is generated: therefore,\nspecification of something like :q.R14,R12,address:eq. is valid.\nThe SAVE keyword may be used on subroutine blocks to\npreserve some or all registers without requiring a standard\nOS save area.  The SAVE operand is not valid on program\nblocks, and should not be confused with OPTIONS=SAVE.\n:dt.SWAREG= R11|(R11,reg...)\n:dd.Specifies the register or registers to be used for SWA\naddressability.\n.rc 1 on\nThe register(s) specified with this keyword are only used when\nDYN is in effect.\n:dt.Errors:\n:dd.Refer to :hdref refid=interr. for macros that start with\n:q.##SP:eq..\n.rc 1 off\n:edl.\n.*\n.*\n:h1.CALLSUB\n:dl.\n:dt.Macro:\n:dd.CALLSUB\n:dt.Abstract:\n:dd.Macro used to call an internal subroutine with linkage provided\nby the Structured Macros.\nA parameter list can be created for the call and its\naddress loaded into register one, or register one can be loaded\nwith the address of a previously created list.\n:dt.Syntax:\n:dd.CALLSUB\nname&lbt.,(parms)&rbt.&lbt.,VL|NOVL&rbt.&lbt.,PL=tag|(tag,num)&rbt.\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.name\n:dd.Specifies the name of the internal subroutine to be called.\nThe call is performed with a :q.BAL R14,:hp1.name:ehp1.:eq. or\nequivalent instruction.  If the program block option LONG has been\nselected, a :q.BAL R14,R15:eq. is generated destroying the contents of\nregister 15.\nThe contents of register 15 are also destroyed if DYN is used.\n:dt.parms\n:dd.A list of the parameters to be included in the parameter list\nthat the subroutine will be called with.\nA missing parameter causes zero to be filled in for the parameter\naddress.  An * will cause the macro to skip over that parameter,\nreserving the space in the parameter list but not modifying the\ndata there.\n.rc 3 on\nAn * before a tag will cause the macro to load the parameter list\nwith the contents of the storage referenced by the tag instead of\nthe address of the tag.  This provides a form of indirect addressing.\n.rc 3 off\nNumeric and character constants can be coded and will\nbe converted to fullword and character literals respectively.\nIf :hp1.parms:ehp1. is missing, the CALLSUB macro will simply\nload register one with the address specified by PL=.\n:dt.VL|NOVL\n:dd.VL specifies that this is a variable length parameter list\nand therefore the high bit of the last address in the list should\nbe set to one.  NOVL says to not set the bit.  NOVL is normally the\ndefault, but all of the super options establish VL as the default\nso that NOVL might be needed in certain cases.\n:dt.tag\n:dd.Specifies the address of the parameter list to used for the call\nto this subroutine.  Register one will be loaded with the address of\n:hp1.tag:ehp1. before the subroutine is entered.  If a parameter\nlist is being created for this subroutine, :hp1.tag:ehp1 also\nspecifies where to build it.\nIf the PL= keyword is not specified, the parameter\nlist will be created in the default parameter list storage established\nby an enclosing BLOCK macro, or in PWA or SWA storage if no other\ndefault was set up.\n:dt.num\n:dd.Specifies the maximum number of the parameters that the storage at\n:hp1.tag:ehp1. can accommodate.  If :hp1.tag:ehp1. has a length\nattribute that is a self-defining term, this operand is not necessary.\nThis is used to insure that the specified\nparameter list will fit into the storage at :hp1.tag:ehp1..\n:edl.\n.kp on\n:dt.Errors:\n:dd.:ul compact\n:li.Can not CALLSUB program block or subroutine in previous\nprogram block\n:eul.\n.kp off\n:edl.\n.*\n.*\n:h1.CALLX\n:dl.\n:dt.Macro:\n:dd.CALLX\n:dt.Abstract:\n:dd.Macro used to call an external subroutine with standard OS\nlinkage.  A parameter list can be created for the call and its\naddress loaded into register one, or register one can be loaded\nwith the address of a previously created list.\n:dt.Syntax:\n:dd.CALLX\naddr&lbt.,(parms)&rbt.&lbt.,VL|NOVL&rbt.&lbt.,PL=tag|(tag,num)&rbt.\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.addr\n:dd.Specifies the address of the external subroutine.  This\naddress can be of the form: :hp2.(R15)|=V(name)|tag:ehp2..\nIf the :hp1.tag:ehp1. form is used, :hp1.tag:ehp1. should be the\nlabel of the address of the external subroutine.\nThe call is performed with a BALR R14,R15 or equivalent\ninstruction.\n:dt.parms\n:dd.A list of the parameters to be included in the parameter list\nthat the subroutine will be called with.\nA missing parameter causes zero to be filled in for the parameter\naddress.  An * will cause the macro to skip over that parameter,\nreserving the space in the parameter list but not modifying the\ndata there.\n.rc 3 on\nAn * before a tag will cause the macro to load the parameter list\nwith the contents of the storage referenced by the tag instead of\nthe address of the tag.  This provides a form of indirect addressing.\n.rc 3 off\nNumeric and character constants can be coded and will\nbe converted to fullword and character literals respectively.\nIf :hp1.parms:ehp1. is missing, the CALLX macro will simply\nload register one with the address specified by PL=.\n:dt.VL|NOVL\n:dd.VL specifies that this is a variable length parameter list\nand therefore the high bit of the last address in the list should\nbe set to one.  NOVL says to not set the bit.  NOVL is normally the\ndefault, but all of the super options establish VL as the default\nso that NOVL might be needed in certain cases.\n:dt.tag\n:dd.Specifies the address of the parameter list to used for the call\nto this subroutine.  Register one will be loaded with the address of\n:hp1.tag:ehp1. before the subroutine is entered.  If a parameter\nlist is being created for this subroutine, :hp1.tag:ehp1 also\nspecifies where to build it.\nIf the PL= keyword is not specified, the parameter\nlist will be created in the default parameter list storage established\nby an enclosing BLOCK macro, or in PWA or SWA storage if no other\ndefault was set up.\n:dt.num\n:dd.Specifies the maximum number of parameters that the storage at\n:hp1.tag:ehp1. can accommodate.  If :hp1.tag:ehp1. has a length\nattribute that is a self-defining term, this operand is not necessary.\nThis is used to insure that the specified\nparameter list will fit in the storage at :hp1.tag:ehp1..\n:edl.\n:dt.Errors:\n:dd.None\n:edl.\n.*\n.*\n:h1.CASE\n:dl.\n:dt.Macro:\n:dd.CASE\n:dt.Abstract:\n:dd.Structured macro used to start the code for a particular\ncase within a case block.  This macro must be coded between a CASEBLK\nand ENDCASE macro.  The CASE macro is always associated with the\ninnermost CASEBLK.\n:dt.Syntax:\n:dd.CASE n&lbt.,n&lbt.,...&rbt.&rbt.|OTHER&lbt.,CASEBLK=name&rbt.\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.n\n:dd.Specifies the case number or numbers whose code follows\nthe case statement.  OTHER indicates all cases not associated\nwith a particular case.  The case number can not be larger than\nthe MULT= value on the associated CASEBLK macro times 100.\n:dt.name\n:dd.Name specified on the associated CASEBLK macro.\n:edl.\n:dt.Errors:\n:dd.:ul compact.\n:li.CASE <casenumber> already used\n:li.No operand was specified on CASE statement\n:li.OTHER has already been specified in this CASEBLK\n:li.CASE is not numeric\n:li.CASE number can not be larger then 'MULT' * 100\n:li.CASE number must be a multiple of 'MULT'\n:li.CASEBLK= does not match CASE name\n:li.CASE macro is not at same structural level as a CASEBLK macro\n:eul.\n:edl.\n.*\n.*\n:h1.CASEBLK\n:dl.\n:dt.Macro:\n:dd.CASEBLK\n:dt.Abstract:\n:dd.Structured macro used to start a case block.  Case blocks\ncan be nested up to twenty deep.\n:dt.Syntax:\n:dd.CASEBLK\nREG=reg&lbt.,WREG=wreg&rbt.&lbt.,MULT=1|2|4|8&rbt.&lbt.,NAME=name&rbt.\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.reg\n:dd.Specifies the register that contains the case number.\n:dt.wreg\n:dd.Specifies the register that CASEBLK can use internally as\na work register for address calculations.  If WREG= is not specified,\nthe REG= is used as a work register.  This destroys the contents of\nREG.\nThe work register can never\nbe register 0.\n:dt.mult\n:dd.This keyword specifies that all the case numbers on the\nassociated CASE macros are a multiple of 1, 2, 4, or 8.  1 is the\ndefault.\n:dt.name\n:dd.Specifies the name of the case block.\n:edl.\n:dt.Errors:\n:dd.:ul compact.\n:li.Invalid MULT= specified. Must be 1, 2, 4, or 8.\n:li.CASEBLK can not be nested more than 20 deep\n:li.REG= must be specified\n:eul.\n:edl.\n.rc 4 on\n.*\n.*\n:h1.DEFUCOND\n:dl.\n:dt.Macro:\n:dd.DEFUCOND\n:dt.Abstract:\n:dd.Structured macro used to define the name of a user condition and\nidentify the macro that will process it.  With DEFUCOND the programmer\ncan add special case conditions to the list of standard conditions\navailable in conditional expressions.  For information on writing\na user condition macro, see :hdref refid=ucond..\n:dt.Syntax:\n:dd.DEFUCOND NAME=name,MACRO=macro\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.name\n:dd.Name of the user condition being defined.  This name will be used\nin conditional expressions to invoke this condition.\n:dt.macro\n:dd.Name of the macro that will perform this user-defined conditional\ntest.  This macro will be invoked by the Structured Macros whenever\na conditional expression is encountered that contains the named\ncondition.\n:edl.\n:dt.Errors:\n:dd.:ul compact.\n:li.NAME= must be specified\n:li.MACRO= must be specified\n:eul.\n:edl.\n.rc 4 off\n.*\n.*\n:h1.ELSE\n:dl.\n:dt.Macro:\n:dd.ELSE\n:dt.Abstract:\n:dd.Structured macro used to start the else code for an associated\nIF or ELSEIF macro.  An ELSE macro is always associated\nwith the innermost IF structure.\n:dt.Syntax:\n:dd.ELSE &lbt.IF=name&rbt.\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.name\n:dd.Name of associated IF macro.\n:edl.\n:dt.Errors:\n:dd.:ul compact.\n:li.IF nesting level is zero\n:li.ELSE already encountered for this IF\n:li.NAME= does not match corresponding IF\n:li.ELSE structural level is not the same as the corresponding IF\n:eul.\n:edl.\n.*\n.*\n:h1.ELSEIF\n:dl.\n:dt.Macro:\n:dd.ELSEIF\n:dt.Abstract:\n:dd.Structured macro used to start the else code for an associated\nIF or ELSEIF macro.  An ELSEIF macro is always associated with the\ninnermost IF structure.  An ELSEIF is like an ELSE macro followed\nby an IF macro except that the IF nesting level stays the same.\n:dt.Syntax:\n:dd.ELSEIF cond&lbt.,THEN&rbt.&lbt.,IF=name&rbt.\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.cond\n:dd.Conditional expression. (See :hdref refid=condch..)\n:dt.name\n:dd.Name on associated IF macro.\n:edl.\n:dt.Errors:\n:dd.:ul compact.\n:li.ELSEIF must be contained in IF structure\n:li.ELSE for this IF precedes ELSEIF\n:li.IF= does not match corresponding IF\n:li.ELSEIF structural level is not the same as corresponding IF\n:li.Refer to :hdref refid=interr., for possible condition errors.\n:eul.\n:edl.\n.*\n.*\n:h1.ENDBLK\n:dl.\n:dt.Macro:\n:dd.ENDBLK\n:dt.Abstract:\n:dd.Structured macro used to end a block structure.  Refer to the\ndescription of the BLOCK macro for more information.\n:dt.Syntax:\n.rc 1 on\n:dd.ENDBLK &lbt.BLOCK=name&rbt.\n.ct &lbt.,RC=rc&rbt.\n.ct &lbt.,R0=r0&rbt.\n.ct &lbt.,R1=r1&rbt.\n.rc 1 off\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.name\n:dd.Name on associated BLOCK macro.\n:dt.rc\n:dd.Return code.\nThe return\ncode can be specified as a symbol or (Rn) where n is\nthe number of a register.\nThe default for RC is (R15).\n.rc 1 on\nRC= is ignored on the ENDBLK macro of a program block that is using\nthe PLI environment.\n:dt.r0\n:dd.Value to be returned in register zero.  This keyword\nrequires the RTNR0 option to be in effect and is only valid\non the ENDBLK for a program block and its error exits.  This\nvalue can be specified as a symbol or (Rn) where n is the\nnumber of a register.  The default for R0 is (R0).\n:dt.r1\n:dd.Value to be returned in register one.  This keyword\nrequires the RTNR1 option to be in effect and is only valid\non the ENDBLK for a program block and its error exits.  This\nvalue can be specified as a symbol or (Rn) where n is the\nnumber of a register.  The default for R1 is (R1).\n.rc 1 off\n:edl.\n:dt.Errors:\n:dd.:ul compact.\n:li.<RC> invalid on RC=\n:li.Block nesting level is already zero\n:li.BLOCK= does not match current block\n:li.Structural nesting level does not match level at entry to\ncorresponding block\n.rc 1 on\n:li.Refer to :hdref refid=interr. for macros that start with\n:q.##EE:eq.,\n:q.##IE:eq.,\n:q.##PE:eq. or\n:q.##SE:eq.\nfor other possible errors.\n.rc 1 off\n:eul.\n:edl.\n.*\n.*\n:h1.ENDCASE\n:dl.\n:dt.Macro:\n:dd.ENDCASE\n:dt.Abstract:\n:dd.Structured macro used to end a case block structure.\n:dt.Syntax:\n:dd.ENDCASE &lbt.CASEBLK=name&rbt.\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.name\n:dd.Name on associated CASEBLK macro.\n:edl.\n:dt.Errors:\n:dd.:ul compact.\n:li.CASEBLK nesting level is zero\n:li.CASEBLK= does not match CASE name\n:li.Structural nesting level of ENDCASE is different than corresponding\nCASEBLK macro\n:eul.\n:edl.\n.*\n.*\n:h1.ENDIF\n:dl.\n:dt.Macro:\n:dd.ENDIF\n:dt.Abstract:\n:dd.Structured macro used to end an IF structure.\n:dt.Syntax:\n:dd.ENDIF &lbt.IF=name&rbt.\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.name\n:dd.Name on associated IF macro.\n:edl.\n:dt.Errors:\n:dd.:ul compact.\n:li.IF nesting level is zero\n:li.IF= does not match corresponding IF\n:li.ENDIF is not at same structural level as corresponding IF\n:eul.\n:edl.\n.*\n.*\n:h1.ENDLOOP\n:dl.\n:dt.Macro:\n:dd.ENDLOOP\n:dt.Abstract:\n:dd.Structured macro used to end a LOOP structure.\nSee the LOOP macro for more information.\n:dt.Syntax:\n:dd.ENDLOOP &lbt.LOOP=name,&rbt.\n.tp 22 37\n!WHILE!|\n!UNTIL,cond!|\n!UNTIL,LEAVE!|\n!BCT,reg!|\n!BXH!|\n!BXLE,reg,reg\n.tp\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.name\n:dd.Name on associated LOOP macro.\n:dt.cond\n:dd.Conditional expression. (See :hdref refid=condch..)\n:dt.reg\n:dd.Register to be used on associated instruction.\n:edl.\n:dt.Errors:\n:dd.:ul compact.\n:li.Additional positional parameters can not be specified on ENDLOOP\n<type>\n:li.Nesting level for loops is 0\n:li.LOOP= does not match corresponding LOOP\n:li.<type> does not match type on corresponding LOOP\n:li.Incorrect number of parameters specified for ENDLOOP <type>\n:li.LOOP type <type> is invalid\n:li.Incorrect number of parameters specified on ENDLOOP UNTIL,LEAVE\n:li.ENDLOOP structural level is not the same as the corresponding LOOP\n:li.Refer to :hdref refid=interr., for possible condition errors.\n:eul.\n:edl.\n.*\n.*\n:h1.ENDPSD\n:dl.\n:dt.Macro:\n:dd.ENDPSD\n:dt.Abstract:\n:dd.Macro used to define the end of the Program Static\nData (PSD).  The ENDPSD macro is used to close either a partial\nPSD within the program code, or the last PSD at the end of the\nprogram.\n:dt.Syntax:\n:dd.ENDPSD\n:dt.Operands:\n:dd.None\n:dt.Errors:\n:dd.:ul compact.\n:li.ENDPSD does not correspond to a PSD\n:li.ENDPSD is not at the same nesting level as PSD\n:eul.\n:edl.\n.*\n.*\n:h1.ENDPWA\n:dl.\n:dt.Macro:\n:dd.ENDPWA\n:dt.Abstract:\n:dd.Macro used to define the end of the Program Work\nArea (PWA) or to close a partial PWA.\nThe ENDPWA macro will define the PWAPLLEN tag\nto establish the length of the PWA.  Also, if the DYN option\nis being used, ENDPWA will use the ##ORGS macro to reserve\nspace for the SWAs.\nIf option NORENT is in effect, a DS instruction is generated to\nreserve storage in the CSECT for the PWA.\n:dt.Syntax:\n:dd.ENDPWA\n:dt.Operands:\n:dd.None\n:dt.Errors:\n:dd.None\n:edl.\n.*\n.*\n:h1.ENDSSD\n:dl.\n:dt.Macro:\n:dd.ENDSSD\n:dt.Abstract:\n:dd.Macro used to define the end of the Subroutine Static\nData (SSD).  The ENDSSD macro is used to close either a partial\nSSD within the subroutine code, or the last SSD at the end of the\nsubroutine.\n:dt.Syntax:\n:dd.ENDSSD\n:dt.Operands:\n:dd.None\n:dt.Errors:\n:dd.:ul compact.\n:li.ENDSSD does not correspond to a SSD\n:li.ENDSSD is not at the same nesting level as SSD\n:eul.\n:edl.\n.*\n.*\n:h1.ENDSWA\n:dl.\n:dt.Macro:\n:dd.ENDSWA\n:dt.Abstract:\n:dd.Macro used to define the end of the Subroutine Work\nArea (SWA).  It is also used to end a partial SWA definition.\nThe ENDSWA macro will\nestablish the length of the SWA for Dynamic Storage calculations.\nENDSWA also insures double word alignment for anything that will\nfollow the SWA.\n:dt.Syntax:\n:dd.ENDSWA\n:dt.Operands:\n:dd.None\n:dt.Errors:\n:dd.None\n:edl.\n.*\n.*\n:h1.ERREXIT\n:dl.\n:dt.Macro:\n:dd.ERREXIT\n:dt.Abstract:\n:dd.Structured macro used to conditionally cause an errexit block\nto be executed.\n:dt.Syntax:\n:dd.ERREXIT &lbt.cond&rbt.&lbt.,CODE=code&rbt.\n.ct &lbt.,CODEREG=reg&rbt.&lbt.,NAME=name&rbt.\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.name\n:dd.Name of errexit block to execute.  If the name is omitted\nthe unnamed error exit block for the program is executed.\n:dt.code\n:dd.Symbol representing a value from 0 to 4095.  If specified, this\ncode will be passed to the error exit block in the CODEREG= register.\n:dt.reg\n:dd.Register used for passing error code.  The default is R14.\n:dt.cond\n:dd.Conditional expression. (See :hdref refid=condch..)\nIf the expression is true, the error exit is taken.  If an expression\nis not specified, the error exit is always taken.\n:edl.\n:dt.Errors:\n:dd.:ul compact.\n:li.Refer to :hdref refid=interr., for possible condition errors.\n:eul.\n:edl.\n.*\n.*\n:h1.EXI\n:dl.\n:dt.Macro:\n:dd.EXI\n:dt.Abstract:\n:dd.This is the EXecute Immediate macro.\nIt is used to generate an EX instruction and the instruction\nto be executed.  This allows the EXecuted statement to be defined\nat the same time the EX instruction is defined, minimizing confusion.\nIt also insures that the USING environment is the same as that of\nthe EX instruction.  The EXecuted instruction will be generated in\nthe PSD for the program (or SSD for a subroutine) if the program\nhas selected option LOCTR.  Otherwise, it will be generated inline\nwith a branch around it.\n:dt.Syntax:\n:dd.EXI reg,(opcode,op1&lbt.,op2&lbt.,op3&rbt.&rbt.)\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.reg\n:dd.Specifies the register to be used in the EX instruction.\n:dt.opcode\n:dd.Defines the opcode to be used for the EXecuted instruction.\n:dt.op1-3\n:dd.Defines the operands for the EXecuted instruction.  There can\nbe one, two, or three operands.\n:edl.\n:dt.Errors:\n:dd.None\n:edl.\n.*\n.*\n:h1.FILL\n:dl.\n:dt.Macro:\n:dd.FILL\n:dt.Abstract:\n:dd.Macro used to fill an area of storage with a character.\n:dt.Syntax:\n:dd.FILL op1&lbt.,op2&rbt.&lbt.,LENGTH=len|(len,type)&rbt.\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.op1\n:dd.Provides\nthe starting address of the storage to be cleared.\nMay be given as an RX-type address.\n:dt.op2\n:dd.Provides\na byte other than X'00' to propagate through the storage\nto be cleared.\nMay be specified in X'nn' or C'c' form (suitable for use by MVI).\nIf not specified, X'00' is assumed.\n:dt.len\n:dd.Provides\nthe length of the storage area to be cleared.\nMay be a numeric value, a constant value or a register specification.\nThe default is (L'op1,SHORT).\n:dt.type\n:dd.Specifies\nthe type of clearing operation to be performed: e.g.\n:q.short:eq., :q.medium:eq. or :q.long:eq..\n:edl.\n:dt.Errors:\n:dd.:ul compact.\n:li.FILL operation type invalid: Must be S)hort, M)edium, or L)ong\n:li.Long form FILL requires R-Form length\n:li.Length for FILL required but not specified\n:li.Unable to parse FILL destination\n:eul.\n:dt.Caution:\n:dd.If a tag is defined in a macro, FILL does not have L':hp1.tag:ehp1.\nresolved for it and gets an assembly error.  To correct this, you\ncan code:\n:xmp.\n FILL  tag,X'00',LENGTH=L'tag\n:exmp.\n:edl.\n.*\n.*\n:h1.IBIT\n:dl.\n:dt.Macro:\n:dd.IBIT\n:dt.Abstract:\n:dd.Macro used to invert bit flags in a byte.\n:dt.Syntax:\n:dd.IBIT &lbt.byte,&rbt.flag|(flag&lbt.,flag&lbt.,...&rbt.&rbt.)\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.byte\n:dd.Byte that contains bit(s) to be inverted.  If this\noperand is omitted,  the name of the byte is assumed to be the\nfirst five characters of the first flag name.\n:dt.flag\n:dd.Byte mask with a binary one in the bit position of the mask\nthat corresponds to the bit to be inverted in the byte.\n:edl.\n:dt.Errors:\n:dd.:ul compact.\n:li.No more than eight flags can be specified\n:li.IBIT macro can have no more than two operands\n:li.If byte is not specified, flag name must be at least six characters\nlong\n:li.If byte is not specified, the first five characters of all flags\nmust match\n:eul.\n:edl.\n.*\n.*\n:h1.IF\n:dl.\n:dt.Macro:\n:dd.IF\n:dt.Abstract:\n:dd.Structured macro used to start an IF structure.\n:dt.Syntax:\n:dd.IF cond&lbt.,THEN&rbt.&lbt.,NAME=name&rbt.\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.name\n:dd.Name to be associated with IF structure.\n:dt.cond\n:dd.Conditional expression. (See :hdref refid=condch..)\n:edl.\n:dt.Errors:\n:dd.:ul compact.\n:li.IFs can only be 20 deep\n:li.Refer to :hdref refid=interr., for possible condition errors.\n:eul\n:edl.\n.*\n.*\n:h1.LCBA\n:dl.\n:dt.Macro:\n:dd.LCBA\n:dt.Abstract:\n:dd.This macro loads the address of certain control blocks into a\nregister.  No registers are changed except for the register specified.\nA zero condition is set if the control block can not be located.\nIt is not necessary for the mapping macros for the control blocks\nused internally by this macros to be included in the source program.\n:dt.Syntax:\n:dd.LCBA reg,cb\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.reg\n:dd.This operand specifies the register to be loaded.\nThe register must be specified as R1 through R15.\n:dt.cb\n:dd.One of the following control blocks can be specified:\n:dl.\n:dt.ACEE\n:dd.The address of the current RACF Accessor Environment Element\nwill be loaded.  This address will be the contents of the TCBSENV field\nof the current TCB\nif non-zero and present; otherwise, the address will be the contents\nof the ASXBSENV field of the current ASXB.\n:dt.ASCB\n:dd.The address of the current Address Space Control Block will be\nloaded.  This address is loaded from PSAAOLD.\n:dt.ASXB\n:dd.The address of the current Address Space Extension Block will be\nloaded.  This address is loaded from ASCBASXB.\n:dt.CVT\n:dd.The address of the Communications Vector Table will be loaded.\nThis address is loaded from location decimal 16.\n:dt.TCB\n:dd.The address of the current Task Control Block will be loaded.\nThis address is loaded from PSATOLD.\n:dt.UJT\n:dd.The address of the User Job Table will be loaded.  This control\nblock is Clemson dependent.  TCBUSER of the current TCB and its parents\nTCBs are searched to find the address of the UJT.\n:dt.UVT\n:dd.The address of the User Communication Vector Table will be loaded.\nThis control block is Clemson dependent.  This address is loaded from\nthe three low order bytes of CVTUSER.\n:edl.\n:edl.\n:dt.Errors:\n:dd.:ul compact.\n:li.<reg> is invalid.  Register must be R1-R15.\n:li.<cb> is not a supported control block.\n:eul\n:edl.\n.*\n.*\n:h1.LEAVE\n:dl.\n:dt.Macro:\n:dd.LEAVE\n:dt.Abstract:\n:dd.Structured macro used to leave a structure.\n:dt.Syntax:\n:dd.LEAVE struc=name&lbt.,cond&rbt.\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.struc\n:dd.Type of structure to leave.  Can be IF, LOOP, BLOCK,\nor CASEBLK.\n:dt.name\n:dd.Name of the structure to leave.  An * can be coded to\nindicate the current (innermost) structure of the specified type.\n:dt.cond\n:dd.Conditional expression. (See :hdref refid=condch..)\nIf the expression is true, the structure is left.  If an expression is\nnot specified, the structure is left unconditionally.\n:edl.\n:dt.Errors:\n:dd.:ul compact.\n:li.SMWA= keyword needs to be specified on program block macro\n:li.Only one keyword can be specified on LEAVE\n:li.Nesting level for <structure> is zero\n:li.<name> is not an active <structure> name\n:li.One keyword must be specified on LEAVE\n:li.Refer to :hdref refid=interr., for possible condition errors.\n:eul.\n:edl.\n.*\n.*\n:h1.LOOP\n:dl.\n:dt.Macro:\n:dd.LOOP\n:dt.Abstract:\n:dd.Structured macro used to start a loop structure.\nFor LOOP WHILE loops, tests are done at the start of the loop.\nFor LOOP UNTIL loops, tests are done at the bottom of the loop.\nIf the ENDLOOP specifies UNTIL,LEAVE, the loop will continue\nuntil a LEAVE macro is used to leave the loop.  BCT, BXH, and\nBXLE loop use the assembler instruction by the same name.  BXH\ninstructions are generated at the top of the loop and BXLE and BCT\ninstructions are generated at the bottom of the loop.\n:dt.Syntax:\n:dd.LOOP &lbt.NAME=name,&rbt.\n.tp 19 34\n!WHILE,cond!|\n!UNTIL!|\n!BCT!|\n!BXH,reg,reg!|\n!BXLE\n.tp\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.name\n:dd.Name to be associated with loop structure.\n:dt.cond\n:dd.Conditional expression. (See :hdref refid=condch..)\n:dt.reg\n:dd.Register to be used on associated instruction.\n:edl.\n:dt.Errors:\n:dd.:ul compact.\n:li.Additional positional parameters can not be specified on LOOP\n<type>\n:li.LOOPs can only be nested 20 deep\n:li.Incorrect number of parameters specified for LOOP BXH\n:li.LOOP type <type> is invalid\n:li.Refer to :hdref refid=interr., for possible condition errors.\n:eul.\n:edl.\n.*\n.*\n:h1.L8, L16, L24, L32\n:dl.\n:dt.Macro:\n:dd.L8, L16, L24, L32\n:dt.Abstract:\n:dd.Macro used to load a register with one, two, three, or\nfour bytes of data from non-aligned storage.\nThis macro clears the register and issues the appropriate\nICM to accomplish this.\n:dt.Syntax:\n:dd.Ln  reg,addr\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.n\n:dd.Defines the size of the load operation in bits.  :hp1.n:ehp1.\nshould be either 8, 16, 24 or 32 for single byte, half word,\nthree byte, or full word load respectively.\n:dt.reg\n:dd.Specifies the register to load.  :hp2.Warning:  Since\nthis register is cleared before the load, it should not be used\n(directly or indirectly) to specify :hp1.addr:ehp1..:ehp2.\n:dt.addr\n:dd.Specifies the address that register :hp1.reg:ehp1. should be\nloaded from.\n:edl.\n:dt.Errors:\n:dd.:ul compact\n:li.Invalid number of operands on L<n> instruction\n:eul.\n:edl.\n.*\n.*\n:h1.PLIST\n:dl.\n:dt.Macro:\n:dd.PLIST\n:dt.Abstract:\n:dd.Macro used to generate or modify a parameter list.  The\nparameter list can be created in default parameter list storage\nor routed to a specific location.  Register one is also loaded\nwith the address of the completed list.\n:dt.Syntax:\n:dd.PLIST &lbt.(parms)&rbt.&lbt.,VL|NOVL&rbt.\n.ct &lbt.,PL=tag|(tag,num)&rbt.&lbt.,DS=PWA|SWA&rbt.\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.parms\n:dd.A list of the parameters to be included in the parameter list.\nA missing parameter causes zero to be filled in for the parameter\naddress.  An * will cause the macro to skip over that parameter,\nreserving the space in the parameter list but not modifying the\ndata there.\n.rc 3 on\nAn * before a tag will cause the macro to load the parameter list\nwith the contents of the storage referenced by the tag instead of\nthe address of the tag.  This provides a form of indirect addressing.\n.rc 3 off\nNumeric and character constants can be coded and will\nbe converted to fullword and character literals respectively.\nIf :hp1.parms:ehp1. is missing, the PLIST macro will simply\nload register one with the address specified by PL=.\n:dt.VL|NOVL\n:dd.VL specifies that this is a variable length parameter list\nand therefore the high bit of the last address in the list should\nbe set to one.  NOVL says to not set the bit.  NOVL is normally the\ndefault, but all of the super options establish VL as the default\nso that NOVL might be needed in certain cases.\n:dt.tag\n:dd.Specifies the address of the parameter list to be created\nor modified.  If the PL= keyword is not specified, the parameter\nlist will be created in the default parameter list storage established\nby an enclosing BLOCK macro, or in PWA or SWA storage if no other\ndefault was set up.\n:dt.num\n:dd.Specifies the maximum number of the parameters that the storage at\n:hp1.tag:ehp1. can accommodate.  If :hp1.tag:ehp1. has a length\nattribute that is a self-defining term, this operand is not necessary.\nThis is used to insure that the specified\nparameter list will fit into the storage at :hp1.tag:ehp1..\n:dt.DS=\n:dd.Specifies that space for this list should be created in the\nPWA or SWA with a label of :hp1.tag:ehp1..  The PL= keyword is\nrequired when using this operand.  The size of :hp1.parms:ehp1.\nis used to calculate the size of the storage created, unless\n:hp1.num:ehp1. was specified on the PL= keyword.  In this case,\nthe size specified by :hp1.num:ehp1. is used.\n:edl.\n.kp on\n:dt.Errors:\n:dd.:ul compact\n:li.First operand of PL keyword is required if DS keyword\nis specified\n:li.<ds> is not valid on the DS keyword\n:li.The PL keyword must be specified on this macro or on an\nenclosing BLOCK macro\n:li.<tag> is not large enough to contain parameter list\n:li.Invalid parameter <vl>\n:li.Too many parameters specified\n:li.Too many parameters on PL keyword\n:eul.\n.kp off\n:edl.\n.*\n.*\n:h1.PSD\n:dl.\n:dt.Macro:\n:dd.PSD\n:dt.Abstract:\n:dd.Macro used to define the beginning of the Program Static\nData (PSD).  The PSD macro uses LOCTR to locate the static data\nafter the instructions for the program.\nThe PSD should be defined just before the PWA for a particular\nprogram block if there is one.\n:dt.Syntax:\n:dd.PSD &lbt.TYPE=LAST|PARTIAL&rbt.\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.TYPE=\n:dd.Defines whether this is the PSD macro that defines the main\nbody of the PSD at the end of the program (LAST), or a PSD macro\nthat defines a portion of the PSD from within the body of the\nprogram (PARTIAL).  If TYPE= is not specified, TYPE=LAST is assumed.\nThe TYPE=PARTIAL option is included to allow macros within the\nbody of the program to define fields in the PSD and have them placed\nwith the static data.\n:edl.\n:dt.Errors:\n:dd.:ul compact\n:li.Nested PSD and SSD macros are not allowed\n:eul.\n:edl.\n.*\n.*\n:h1.PWA\n:dl.\n:dt.Macro:\n:dd.PWA\n:dt.Abstract:\n:dd.Macro used to define the beginning of the Program Work\nArea (PWA).  The PWA macro will automatically reserve space for\n.rc 1 on\na standard OS save area, the SMWA, and any parameter lists if\nit is appropriate for the current environment.\n.rc 1 off\nAlso, if the DYN option is being used,\nPWA will set up the dynamic storage pointers (NAB, EOS-64).\nThe PWA should be defined as the last thing associated with\na particular program block.\n:dt.Syntax:\n:dd.PWA &lbt.TYPE=LAST|PARTIAL&rbt.\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.TYPE=\n:dd.Defines whether this is the PWA macro that defines the main\nbody of the PWA at the end of the program (LAST), or a PWA macro\nthat defines a portion of the PWA from within the body of the\nprogram (PARTIAL).  If TYPE= is not specified, TYPE=LAST is assumed.\nThe TYPE=PARTIAL option is included to allow macros within the\nbody of the program to define fields in the PWA and also generate\nthe code to initialize them.  So far, this feature is only used\nby the PLIST macro, but can be used by any user macro.\n:edl.\n:dt.Errors:\n:dd.:ul compact\n:li.PWA option should be specified on the program block macro\n:li.Invalid TYPE <type> specified on PWA macro\n:eul.\n:edl.\n.*\n.*\n:h1.RBIT\n:dl.\n:dt.Macro:\n:dd.RBIT\n:dt.Abstract:\n:dd.Macro used to reset bit flags in a byte.\n:dt.Syntax:\n:dd.RBIT &lbt.byte,&rbt.flag|(flag&lbt.,flag&lbt.,...&rbt.&rbt.)\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.byte\n:dd.Byte that contains bit(s) to be reset.  If this\noperand is omitted,  the name of the byte is assumed to be the\nfirst five characters of the first flag name.\n:dt.flag\n:dd.Byte mask with a binary one in the bit position of the mask\nthat corresponds to the bit to be reset in the byte.\n:edl.\n:dt.Errors:\n:dd.:ul compact\n:li.No more than eight flags can be specified\n:li.RBIT macro can have no more than two operands\n:li.If byte is not specified, flag name must be at least six characters\nlong\n:li.If byte is not specified, the first five characters of all flags\nmust match\n:eul.\n:edl.\n.*\n.*\n:h1.SBIT\n:dl.\n:dt.Macro:\n:dd.SBIT\n:dt.Abstract:\n:dd.Macro used to set bit flags in a byte.\n:dt.Syntax:\n:dd.SBIT &lbt.byte,&rbt.flag|(flag&lbt.,flag&lbt.,...&rbt.&rbt.)\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.byte\n:dd.Byte that contains bit(s) to be set.  If this\noperand is omitted,  the name of the byte is assumed to be the\nfirst five characters of the first flag name.\n:dt.flag\n:dd.Byte mask with a binary one in the bit position of the mask\nthat corresponds to the bit to be set in the byte.\n:edl.\n:dt.Errors:\n:dd.:ul compact.\n:li.No more than eight flags can be specified\n:li.SBIT macro can have no more than two operands\n:li.If byte is not specified, flag name must be at least six characters\nlong\n:li.If byte is not specified, the first five characters of all flags\nmust match\n:eul.\n:edl.\n.*\n.*\n.rc 2 on\n:h1.SMCTRL\n:dl.\n:dt.Macro:\n:dd.SMCTRL\n:dt.Abstract:\n:dd.Macro used to set internal\nflags to affect the operation of the Structured Macros.\n:dt.Syntax:\n:dd.SMCTRL FREEPWA=yesno\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.yesno\n:dd.Can be YES or NO to set an internal free PWA flag on or off.\nWhen this flag is on, the ENDBLK macro for the program block\nwill free the PWA.  This\nparameter in only valid if the REUSPWA option is in effect.\n:edl.\n:dt.Errors:\n:dd.:ul compact.\n:li.The FREEPWA keyword is only valid if the REUSPWA option is in effect\n:li.FREEPWA=<value> is not valid\n:eul.\n:edl.\n.rc 2 off\n.*\n.*\n.rc 3 on\n:h1.SMLIST\n:dl.\n:dt.Macro:\n:dd.SMLIST\n:dt.Abstract:\n:dd.Macro used to set options for the operation of the Structured\nMacros Listing Program.  This macro is processed by the listing\nprogram and not the assembler.\n:dt.Syntax:\n:dd.SMLIST CONVERT=yesno\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.yesno\n:dd.Can be YES or NO to begin or end the automatic conversion of\nassembler source to upper case.  All non-comment lines will be\nconverted to upper case with the exception of text between double\nquotes.  This text will remain unconverted and the double quotes (\")\nwill be replaced with single quotes (') before passing the source\non to the assembler.\n:edl.\n:dt.Errors:\n:dd.:ul compact.\n:li.INVALID SMLIST STATEMENT\n:eul.\n:edl.\n.rc 3 off\n.*\n.*\n.rc 3 on\n:h1.SMSYMS\n:dl.\n:dt.Macro:\n:dd.SMSYMS\n:dt.Abstract:\n:dd.This is not a macro, but is a copy member that must be included\nat the beginning of any program that uses the structure location\nsymbols described in :hdref refid=scope..\n:dt.Syntax:\n:dd.COPY SMSYMS\n:dt.Operands:\n:dd.None.\n:dt.Errors:\n:dd.None.\n:edl.\n.rc 3 off\n.*\n.*\n:h1.SSD\n:dl.\n:dt.Macro:\n:dd.SSD\n:dt.Abstract:\n:dd.Macro used to define the beginning of the Subroutine Static\nData (SSD).  The SSD macro uses LOCTR to locate the static data.\nIf the subroutine has selected the LOADBASE option, the static\ndata is placed immediately after the subroutine code in\nthe object module.  If the\nsubroutine is not using LOADBASE, the subroutine static data is\nplaced with the program static data.\nThe SSD should be defined just before the SWA for a particular\nsubroutine block.\n:dt.Syntax:\n:dd.SSD &lbt.TYPE=LAST|PARTIAL&rbt.\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.TYPE=\n:dd.Defines whether this is the SSD macro that defines the\nmain body of the SSD at the end of the subroutine (LAST), or\nan SSD macro that defines a portion of the SSD from within\nthe body of the subroutine (PARTIAL).  If TYPE= is not\nspecified, TYPE=LAST is assumed.  The TYPE=PARTIAL option is\nincluded to allow macros within the body of the subroutine to\ndefine fields in the SSD and have them placed with the\nstatic data.\n:edl.\n:dt.Errors:\n:dd.:ul compact\n:li.Nested PSD and SSD macros are not allowed\n:eul.\n:edl.\n.*\n.*\n:h1.STRSA\n:dl.\n:dt.Macro:\n:dd.STRSA\n:dt.Abstract:\n:dd.Macro used to store a register's value in the Subroutine Work\nArea (SWA) save area.  If an internal subroutine contains an SWA,\nregisters are automatically restored when the subroutine is\nexited.  If the internal subroutine needs to pass back the value\nof a register, it can use this macro to save a register's current\nvalue in the subroutine save area, so that it will not be\nrestored to the original value when the subroutine returns.\n:dt.Syntax:\n:dd.STRSA reg\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.reg\n:dd.Defines the register that should be saved.  :hp1.Reg:ehp1.\nshould be one of the registers R0-R14.\n:edl.\n:dt.Errors:\n:dd.:ul compact\n:li.Invalid register specified - <reg>\n:li.This macro can only be used in subroutine blocks with the SWA\noption specified\n:eul.\n:edl.\n.*\n.*\n:h1.SWA\n:dl.\n:dt.Macro:\n:dd.SWA\n:dt.Abstract:\n:dd.Macro used to define the beginning of the Subroutine Work\nArea (SWA).  The SWA macro will automatically reserve space for\na subroutine save area, a SMWA, any parameter lists used by\nthe subroutine, and the Dynamic Storage Management pointers if needed.\nThe SWA for a subroutine should be defined immediately after\nthe ENDBLK for that subroutine.\nThe SWA macro insures that any fields specified within the SWA will\nbe aligned properly.\n:dt.Syntax:\n:dd.SWA &lbt.TYPE=LAST|PARTIAL&rbt.\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.TYPE=\n:dd.Defines whether this is the SWA macro that defines the main\nbody of the SWA at the end of the subroutine (LAST), or an SWA macro\nthat defines a portion of the SWA from within the body of the\nsubroutine (PARTIAL).  If TYPE= is not specified, TYPE=LAST is assumed.\nThe TYPE=PARTIAL option is included to allow macros within the\nbody of the subroutine to define fields in the SWA and also generate\nthe code to initialize them.  So far, this feature is only used\nby the PLIST macro, but can be used by any user macro.\n:edl.\n:dt.Errors:\n:dd.:ul compact\n:li.SWA option was not specified on the subroutine block macro\nor SWA already defined\n:li.Invalid TYPE <type> specified on SWA macro\n:eul.\n:edl.\n.*\n.*\n:h1.TBIT\n:dl.\n:dt.Macro:\n:dd.TBIT\n:dt.Abstract:\n:dd.Macro used to test bit flags in a byte.\n:dt.Syntax:\n:dd.TBIT &lbt.byte,&rbt.flag|(flag&lbt.,flag&lbt.,...&rbt.&rbt.)\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.byte\n:dd.Byte that contains bit(s) to be tested.  If this\noperand is omitted,  the name of the byte is assumed to be the\nfirst five characters of the first flag name.\n:dt.flag\n:dd.Byte mask with a binary one in the bit position of the mask\nthat corresponds to the bit to be tested in the byte.\n:edl.\n:dt.Errors:\n:dd.:ul compact\n:li.No more than eight flags can be specified\n:li.TBIT macro can have no more than two operands\n:li.If byte is not specified, flag name must be at least six characters\nlong\n:li.If byte is not specified, the first five characters of all flags\nmust match\n:li.This expression requires the Level H assembler\n:eul.\n:edl.\n.*\n.*\n:h1.TREG\n:dl.\n:dt.Macro:\n:dd.TREG\n:dt.Abstract:\n:dd.Macro used to test a register for zero, positive, or negative.\n:dt.Syntax:\n:dd.TREG reg\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.reg\n:dd.Register to be tested.\n:edl.\n:dt.Errors:\n:dd.:ul compact.\n:li.TREG macro can have one and only one operand\n:eul.\n:edl.\n.rc 4 on\n.*\n.*\n:h1.##COND\n:dl.\n:dt.Macro:\n:dd.##COND\n:dt.Abstract:\n:dd.This is an :q.internal:eq. macro for use within other macros and\nnot in open code.  The ##COND macro will test a conditional expression\nand branch to the appropriate success or failure tags.  This macro is\nintended for use in user condition macros.  For information on writing\na user condition macro, see :hdref refid=ucond..\n:dt.Syntax:\n:dd.##COND expr,S=stag,F=ftag,L=logic\n:dt.Operands:\n:dd.:dl termhi=1 tsize=6.\n:dt.expr\n:dd.The conditional expression to be evaluated.  This can be any valid\nconditional expression and can contain previously defined user\nconditions.\n:dt.stag\n:dd.The name of the tag that marks the beginning of the code to be\nexecuted if the condition is true.\n:dt.ftag\n:dd.The name of the tag that marks the beginning of the code to be\nexecuted if the condition is false.\n:dt.logic\n:dd.Either P for positive logic (branch to success if condition is\ntrue) or N for negative logic (branch to failure, skipping over\nsuccess code if condition is false).  These last three operands are\nusually passed unchanged from the operands passed in on the user\ncondition macro that is invoking ##COND.\n:edl.\n:dt.Errors:\n:dd.:ul compact.\n:li.Invalid option <cond> for #TEST condition\n:li.Invalid or missing condition expression\n:li.Invalid number of parms for <op>\n:li.This expression requires the Level H assembler\n:li.Invalid condition <cond>\n:li.No more than 51 positional parameters can be specified\nin a condition\n:eul.\n:edl.\n.rc 4 off\n.* make chapter headings start on odd pages again\n.* by redefining duplex mode and calling DSM#DUPL macro\n.* back from the library.\n.se SYSVARD = 'yes'\n.dm dsm#dupl lib\n:appendix.\n.*\n.*\n:h1 id=asmproc.Catalogued ASM Procedures At Clemson\n:p.\nThere are four catalogued procedures available at Clemson that will\nprovide access to the Structured Macros: these are ASMP, ASMPC,\nASMPCL, and ASMPCLG.\nThese procs will perform a preprocess; preprocess and assemble;\npreprocess, assemble, and link;\nor preprocess, assemble, link, and go respectively.\n:p.\nThe Structured Macro preprocessor (MSC0150$) does not change the\nsource input, but analyzes the use of the Structured Macros and\nproduces a nesting level report.  Once you have had some time\nto get used to it, the nesting level report becomes very useful.\nUse //P.SYSIN to provide it with your assembler source.\n:p.\nThe assembly step executes the Level H Assembler with the options\nXREF(SHORT), TERM and OBJECT. A //SYSTERM DD statement is included\nin the procs, since it appears to be one of the more popular assembler\noptions. //SYSLIB concatenates SYS1.MACLIB and SYS2.STRUC.MACLIB.\nNote that SYS2.MACLIB is not included, and must be included manually\nif desired.\n:p.\nThe link-edit step follows the same conventions as the other Clemson\ncompile-and-link procs, in that link-edit control cards may be\nprovided via //L.SYSIN. Parms LIST and MAP are provided by the proc.\n:p.\nThe three procs have the following keyword parameters available:\n.sk\n.tp 13 33 45\n Keyword:!In Procs:!Default:!Used For:\n.sk\n SYSOUT!All!   A!Listing SYSOUT class\n OBJECT!All but ASMP! DUMMY!ASM SYSPUNCH\n COPT!All but ASMP! <null>!ASM parameters\n LOPT!ASMPCL, ASMPCLG! <null>!Linkedit parameters\n PDS!ASMPCL! <null>!Loadlib for L.SYSLMOD\n NAME!ASMPCL! <null>!Load module name\n.tp\n.*\n.*\n:h1 id=interr.Internal Macros Error Messages\n.rc 1 on\n:p.The following is a list of error messages that can be\nproduced by internal macros used by the Structured Macros.\nThe character preceding the message indicates:\n*-informational, 4-warning and 8-error.  Words enclosed in\nangle brackets are replaced with the appropriate text when\nthe message is issued.\n:dl.\n:dt.##COND\n:dd.:ul compact.\n:li.8-Invalid option <cond> for #TEST condition\n:li.8-Invalid or missing condition expression\n:li.8-Invalid number of parms for <op>\n:li.8-This expression requires the Level H assembler\n:li.8-Invalid condition <cond>\n:li.8-Invalid T=\n:li.8-No more than 51 positional parameters can be specified\nin a condition\n:eul.\n:dt.##EESTD\n:dd.:ul compact.\n:li.8-R0 keyword can not be specified if option RTNR0 is not in effect\n:li.8-R1 keyword can not be specified if option RTNR1 is not in effect\n:li.8-SMWA= keyword needs to be specified on program block\n:eul.\n:dt.##EPSTD\n:dd.:ul compact.\n:li.8-AMODE=<amode> is invalid on <type> block, keyword ignored\n:li.*-AMODE ignored unless XA option specified for program block\n:li.8-Invalid number of parameters in SAVE= keyword\n:eul.\n:dt.##IESTD\n:dd.:ul compact.\n:li.8-SMWA= keyword needs to be specified on program block macro\n:eul.\n:dt.##IGMSG\n:dd.:ul compact.\n:li.4-<kwdname>=<kwd> ignored\n:eul.\n:dt.##IPSTD\n:dd.:ul compact.\n:li.8-AMODE=<amode> is invalid on <type> block, keyword ignored\n:li.*-AMODE ignored unless XA option specified for program block\n:li.8-AMODE 24 or 31 must be specified on containing subroutine\n:li.8-Invalid number of parameters in SAVE= keyword\n:eul.\n:dt.##L\n:dd.:ul compact.\n:li.8-Decimal self-defining terms are the only type of self-defining\nterms allowed\n:li.8-WREG is required if R0,*ADDR is used\n:eul.\n:dt.##LA\n:dd.:ul compact.\n:li.8-Decimal self-defining terms are the only type of self-defining\nterms allowed\n:eul.\n:dt.##MREG\n:dd.:ul compact.\n:li.8-Register specification <reg> is invalid\n:li.8-Register <reg> specified multiple times\n:li.8-Register <reg> was not used - internal error\n:li.8-Invalid type of <type> on ##MREG macro - internal error\n:eul.\n:dt.##ORGS\n:dd.:ul compact.\n:li.*-For subroutine <subname> when called from subroutine <subname>\n:eul.\n:dt.##PEDC\n:dd.:ul compact.\n:li.8-R0= invalid if option RTNR0 not specified\n:li.8-R1= invalid if option RTNR1 not specified\n:eul.\n:dt.##PEOS\n:dd.:ul compact.\n:li.8-R0 keyword can not be specified if option RTNR0 is not in effect\n:li.8-R1 keyword can not be specified if option RTNR1 is not in effect\n:eul.\n:dt.##PPDC\n:dd.:ul compact.\n:li.8-Invalid option <opt>\n:li.4-RMODE and AMODE ignored if MODE option not specified\n:li.4-RMODE and AMODE ignored if XA option not specified\n:li.*-SYSTEM-MODE GETSTG generated\n:li.*-#GETSTK generated: #GETSTK =(value)\n:li.8-#START option required if SYSTEM option specified\n:li.8-#RETURN-related operands not allowed with SYSTEM option\n:li.8-#START/#RTN options not allowed with NOSYSTEM option\n:li.8-#RETURN option not allowed with SYSTEM option\n:li.8-EP option not allowed with NOSYSTEM option\n:li.8-AMODE and RMODE requested are inconsistent\n:li.8-GETSTK option requires SYSTEM option\n:li.8-GETSTK option requires PWA option\n:li.8-MPMODE option requires SYSTEM and #START options\n:eul.\n:dt.##PPOS\n:dd.:ul compact.\n:li.8-Invalid option &OPT\n:li.4-Option DYN assumed because of option MAIN\n:li.4-Option PWA assumed because of option DYN\n:li.4-DYNSIZE can not be specified without option DYN\n:li.8-Name required on program block macro\n:li.4-RMODE and AMODE ignored if MODE option not specified\n:li.4-RMODE and AMODE ignored if XA option not specified\n:li.4-SVAREA= ignored when PWA option specified\n:li.8-First PWAREG must be R13\n:li.*-SAVEAREA option assumed because of PWA option\n:li.4-SVAREA= ignored when RENT and SAVEAREA option specified\n:li.*-SAVEAREA option assumed because of SVAREA= keyword\n:li.*-Assuming register 1 is saved\n.rc 2 on\n:li.8-Option REUSPWA requires the PWA, RENT and SAVE options\n:li.4-Option FNCODE is ignored when the REUSPWA option is not in effect\n:li.8-Option ESV requires the PWA and RENT options\n:li.8-Option CLRDEBUG requires the ESV option\n.rc 2 off\n:eul.\n:dt.##PPPLI\n:dd.:ul compact.\n:li.8-Invalid option <opt>\n:li.8-With ENVIRON=PLI, first BASEREG must be R11\n:li.8-With ENVIRON=PLI, first PWAREG must be R13\n:li.8-Name required on program block macro\n:li.4-RMODE and AMODE ignored if MODE option not specified\n:li.4-RMODE and AMODE ignored if XA option not specified\n:eul.\n:dt.##PRMOPT\n:dd.:ul compact.\n:li.8-USING option requires two parameters\n:li.8-COPYERROR option requires two or three parameters\n:li.8-<opt> is an invalid suboption of the PARMS option\n:li.8-PARMS and PARMMAP keywords require the PARMS option\n:li.8-PARMS and PARMMAP keywords are mutually exclusive\n:li.8-Too many parameters specified on PARMMAP keyword\n:li.8-Second parameter required on PARMMAP keyword if COPY PARMS option\nis specified\n:li.8-<type> is invalid\n:li.8-##PRMOPT does not support <opt> option\n:li.8-<process> is an invalid value for PROCESS keyword\n:li.8-The first parameter in PARM options must be PARMS\n:eul.\n:dt.##SPSTD\n:dd.:ul compact.\n:li.8-SAVE= invalid if SWA option specified\n:li.8-SWA option requires PWA option on program block\n:li.8-SWAREG= can not be specified unless OPTION=SWA is specified\n:li.8-AMODE= invalid for custom subroutine blocks\n:li.8-SAVE= invalid for custom subroutine blocks\n:li.8-CUSTOM must be specified alone\n:li.8-AMODE=<amode> is invalid on subroutine block, keyword ignored\n:li.*-LOADBASE assumed because BASEREG= specified\n:li.8-BLOCK TYPE=SUBROUTINE requires NAME=\n:li.8-LOADBASE option requires LONG option on program block\n:li.8-RECUR keyword requires DYN option on program block\n:li.8-R11 must be the first register specified on the SWAREG= keyword\n:li.*-AMODE ignored unless XA option specified on program block\n:li.8-Invalid number of parameters in SAVE= keyword\n:eul.\n:dt.##ST\n:dd.:ul compact.\n:li.8-*ADDR form of second operand requires WREG=\n:eul.\n:dt.##SUBOPT\n:dd.:ul compact.\n:li.8-<opt> is an invalid option for subroutine block\n:eul.\n:dt.##SWREG\n:dd.:ul compact.\n:li.8-SMWA= keyword is required on the program block macro to support\nthis function\n:eul.\n:dt.##UCOND\n:dd.:ul compact.\n:li.8-Invalid or undefined user condition name: <cond>\n:eul.\n:dt.##UPSTD\n:dd.:ul compact.\n:li.8-SWA option was not specified on the subroutine block macro\nor SWA already defined\n:li.8-Invalid type <type> specified on SWA macro\n:eul.\n:dt.##WESTD\n:dd.:ul compact.\n:li.*-<subname> first from index is <num>\n:li.*-<num> CALLSUB from <subname>(<num>) to <subname>(<num>)\n:eul.\n:dt.##WPDC\n:dd.:ul compact.\n:li.8-PWA option should be specified on the program block macro\n:li.8-Invalid type <type> specified on PWA macro\n:eul.\n:dt.##WPOS\n:dd.:ul compact.\n:li.8-PWA option should be specified on the program block macro\n:li.8-Invalid type <type> specified on PWA macro\n:eul.\n:dt.##WPPLI\n:dd.:ul compact.\n:li.8-PWA option should be specified on the program block macro\n:li.8-Invalid type <type> specified on PWA macro\n:eul.\n:edl.\n.rc 1 off\n.*\n:h1 id=dynform.Work Area Storage Layout\n.*\n.*  Define the up arrow symbol\n.*\n.if &E'&uar = 0\n.th .dv uar /|\n:p.\nIf you are using PWAs and SWAs (with or without the DYN option),\nthe Structured Macros automatically allocate many fields for you.\nSince the macros also manage these fields, you rarely\nneed to worry about them.  However, there may be some cases in\nwhich it would be useful to know the layout of PWA and SWA storage.\nThat is what this appendix describes.\n.*\n:h2.Work Area Layout with the DYN Option\n.rc 1 on\n:p.\nThe DYN option is only available for program blocks with ENVIRON=OS\nin effect.\n.rc 1 off\n:p.\nAs described in :hdref refid=pwaswa., the DYN option acquires a\nsingle large chunk of storage at the beginning of the program\nand partitions it as it is needed for internal subroutine SWAs.\nThe layout of the dynamic storage is shown below.\n:xmp.\n.bx 4 11 18 25 31 38 45 52 61 74\n.tp 5 12 19 26 32 39 46 53 62\n!PWA!SWA!SWA!- -!PWA!SWA!- -!Free!16 Words\n.bx off\n.tp 52 c 61 c 73 c\n!&uar.!&uar.!&uar.\n!NAB!EOS-64!EOS\n:exmp.\n:p.\nThe first thing in dynamic storage is the main program's PWA\nfollowed by any SWAs that happen to be active for that program.\nIf the main program invokes an external subroutine that uses\n*NOMAIN, another PWA will be generated for that program followed\nby its SWAs.  At the end is free storage waiting to be allocated.\nThe current NAB (Next Available Byte) will contain a pointer to\nthe beginning of free storage.  See below to see how to find\nthe current NAB.\n:p.\nWhile EOS (End Of Storage) actually marks the end of the block\nof storage that was GETMAINed, a pointer is kept to EOS-64\ninstead.  This provides a 16 word (64 byte) :q.safety zone:eq.\nfor use by the internal subroutine linkage routines.\nThese extra bytes insure that there will always be at least\n16 words left in dynamic storage when a subroutine is entered.\nBecause of this buffer, the subroutine can save its registers\nbefore it has to calculate remaining space and update the pointers.\n:p.\nWithin dynamic storage, all PWAs and SWAs start on a double word\nboundary.  This is to insure that any fields defined within\ntheir DSECTs as double word will actually have that alignment.\n:p.\nThe diagram above shows that dynamic storage is divided up into\nPWAs and SWAs.  The format of a single PWA is shown below.\n:xmp.\n.bx 4 16 25 36 42 52 59 64 77\n.tp 5 17 26 37 43 53 60 65\n!Save Area!EOS-64!Reserved!NAB!Partial!SMWA!PL!User - -\n!   (18F)!!!! PWA!(1)!(2)!Defined\n.bx off\n &uar.\nR13\n:exmp.\n:note.\n (1) The SMWA is variable in length.\n (2) The PL storage will be as large as required.\n:p.\nFirst is a 18 word, standard OS save area for this program.  It is\nused anytime the program calls an external subroutine.  This could\nbe either an IBM service or a separately compiled module.  By\nputting the save area at the beginning of the PWA and pointing\nregister 13 at it, we can use this register to keep up with both\nthe current save area and the beginning of PWA storage.\n:p.\nAfter the save area is a pointer to EOS-64.  This field defines the\nend of the block of dynamic storage that this PWA resides in.\nThis field is filled in even for a *NOMAIN PWA.  The EOS-64\npointer is used in subroutine linkages to determine if there\nis enough storage left for an SWA.  Following this pointer is\na fullword reserved for future use.\n:p.\nNext comes the NAB (Next Available Byte) for this PWA.  This\nNAB points to the first byte after this PWA.  If there are\nno active SWAs following this PWA, the NAB will point to the\nstart of free storage.  Otherwise, it will point to the first\nSWA following the PWA.\n:p.\nFollowing the NAB are any fields that were defined by a\nPWA TYPE=PARTIAL macro.  These fields may have been defined\nby user macros, or by the DS=PWA keyword on the PLIST macro.\nThese fields may be any length.\nAlso in the partial PWA are parameter list fields for any\ninternal subroutines that do not have SWAs.\n:p.\nFollowing the partial fields is the SMWA (Structured Macros\nWork Area).  Note that the SMWA can be variable in length\nor absent.  If you specify a relocatable address\nfor the SMWA, one will not be allocated automatically.\n:p.\nNext is any space reserved for dynamically defined parameter lists\nin the program block.\nThese lists are any that do not have a PL=tag coded on the PLIST\nmacro or any enclosing block.  Note that only enough space\nfor the largest such list is reserved instead of for all the lists.\nAll of these dynamic lists are created in the same place.  For more\ninformation on PLIST processing, see :hdref refid=parms..\nThis field may also be variable in length or missing.\n:p.\nFinally come any fields that you coded between the\nPWA and ENDPWA macros.  These continue until the end of the PWA.\n:p.\nA PWA remains in dynamic storage as long as its program is running.\nThe PWA is followed by any active SWAs for that program's internal\nsubroutines.  The SWAs are created and destroyed as the subroutines\nare entered and exited.  The format of a single SWA is shown below.\n:xmp.\n.bx 4 11 21 31 40 46 60\n.tp 5 12 22 32 41 47\n!NAB!R0-R14!Partial!SMWA!PL!User - -\n!! Save! SWA!(1)!(2)!Defined\n.bx off\n &uar.\nR11\n:exmp.\n:note.\n (1) The SMWA for subroutines is not used and is of zero length.\n (2) The PL storage will be as large as required.\n:p.\nThe SWA looks very much like a PWA with a few fields missing.\nThe only significant difference is the 15 word subroutine save\narea.  Note that this is an internal subroutine save area, and\nnot a standard OS save area.  The NAB for a subroutine points to\nthe first available byte after that subroutine's SWA.  If this\nis the last SWA currently in dynamic storage, this NAB will point\nto the beginning of free space.  Otherwise, it will contain the\naddress of the next SWA (or PWA) in dynamic storage.\n:p.\nR11 always points to the beginning (i.e. the NAB) of the currently\nactive subroutine.  If there is no subroutine active, R11 will\npoint to the NAB from the current PWA.  Therefore, R11 not only\nprovides us with a base for our SWA, it always points to the\nmost current NAB.\n:p.\nThis storage scheme is very easy to maintain and perform linkages on.\nWhen an internal subroutine is entered, it uses R15 (this is why\nR15 is destroyed with the DYN option) to calculate where its SWA\nwill go from the current NAB (pointed to by R11).  It then saves\nits registers in this new SWA and calculates a new NAB.  If there\nis enough room for this SWA, the subroutine will update R11 to\npoint to its NAB and the linkage is complete.  Adding a new PWA\nis a similar process.  The reverse linkage is even easier.  Since\nthe pointer to the current NAB is kept in a register, the act of\nrestoring registers at the end of a subroutine returns the\ndynamic storage environment to the state it was in before the\nsubroutine was entered.  The same holds true for eliminating a\nPWA when an *NOMAIN program is exited.\n.*\n.rc 1 on\n:h2.Work Area Layout with NODYN and ENVIRON=DC\n:p.\nThe work area layout for an ENVIRON=DC program is nearly identical\nwith that of an ENVIRON=OS program: the only differences are that the\nPWA does not contain an 18-word OS savearea,\nand the PWA in an ENVIRON=DC program is addressed by some register\nother than R13 (usually R11).\n.*\n:xmp.\n.bx 4 16 26 38 51\n.tp 5 17 27 39\n!Partial!SMWA!PL!User - -\n! PWA!(1)!(2)!Defined\n.bx off\n &uar.\nR11\n:exmp.\n:note.\n (1) The SMWA is variable in length.\n (2) The PL storage will be as large as required.\n.*\nAn SWA in a NODYN program is represented below.  It is identical to\nthe SWA for an ENVIRON=OS program with the NODYN option.\nfield.\n:xmp.\n.bx 4 14 24 33 39 53\n.tp 5 15 25 34 40\n!R0-R14!Partial!SMWA!PL!User - -\n! Save! SWA!(1)!(2)!Defined\n.bx off\n &uar.\n(3)\n:exmp.\n:note.\n (1) The SMWA for subroutines is not used and is of zero length.\n (2) The PL storage will be as large as required.\n (3) With NODYN, the SWA will be addressed off of the PWA base.\n:p.ENVIRON=DC does not currently support the DYN option.\n.rc 1 off\n.*\n:h2.Work Area Layout with NODYN and ENVIRON=OS\n:p.\nIf the DYN option is not being used, the program can still have\na PWA.  If this is the case, the PWA is of the following format:\n:xmp.\n.bx 4 16 26 33 38 51\n.tp 5 17 27 34 39\n!Save Area!Partial!SMWA!PL!User - -\n!  (18F)! PWA!(1)!(2)!Defined\n.bx off\n &uar.\nR13\n:exmp.\n:note.\n (1) The SMWA is variable in length.\n (2) The PL storage will be as large as required.\n:p.\nThe PWA for a NODYN program looks very much like the PWA created\nin dynamic storage, except that the pointers used to keep up\nwith dynamic storage are not there.  Also, any SWAs defined by\nthis program will reside in the partial PWA area.\n:p.\nAn SWA in a NODYN program is represented below.  Remember that this\nstorage is actually allocated within the PWA's :hp1.partial:ehp1.\nfield.\n:xmp.\n.bx 4 14 24 33 39 53\n.tp 5 15 25 34 40\n!R0-R14!Partial!SMWA!PL!User - -\n! Save! SWA!(1)!(2)!Defined\n.bx off\n &uar.\n(3)\n:exmp.\n:note.\n (1) The SMWA for subroutines is not used and is of zero length.\n (2) The PL storage will be as large as required.\n (3) With NODYN, the SWA will be addressed off of the PWA base.\n:p.\nThe SWA within a NODYN program is just like that for a DYN program,\nexcept that the NAB is absent.\n.*\n.rc 1 on\n:h2.Work Area Layout with NODYN and ENVIRON=PLI\n:p.\nThe work area layout for ENVIRON=PLI is the same as the\nlayout for ENVIRON=OS with option NODYN in effect with the\nexception that the save area is replace by a PL/I DSA.  A\nDSA starts with an OS save area with the first word used for\nPL/I housekeeping.  The forward link in the save area is not\nused.  The save area if followed by other PL/I housekeeping\nfields.  The format of the DSA is described in detail in the\nexecution time logic manual for the PL/I Optimizing\nCompiler.\n:xmp.\n.bx 4 16 26 33 38 51\n.tp 5 17 27 34 39\n!PL/I DSA!Partial!SMWA!PL!User - -\n!       ! PWA!(1)!(2)!Defined\n.bx off\n &uar.\nR13\n:exmp.\n:note.\n (1) The SMWA is variable in length.\n (2) The PL storage will be as large as required.\n.rc 1 off\n.*\n.*\n:h1 id=codform.Program Code and Static Data Layout\n:p.\nThe use of the LOCTR instruction in the Level H Assembler allows\nthe Structured Macros to gather code under different location counters\nand place them at the proper point in the load module.  To\npreserve the integrity of the structure that the macros produce,\na program should be coded in the manner shown below.\n:xmp.\n BLOCK  TYPE=PROGRAM,NAME=MAINPROG,OPTIONS=(*MAIN,LONG),\n               SUBOPTS=(*SWA,LOADBASE)\n       :\n  CALLSUB SUBONE\n       :\n ENDBLK BLOCK=MAINPROG\n\n BLOCK  TYPE=SUBROUTINE,NAME=SUBONE\n       :\n  CALLSUB SUBTWO\n       :\n ENDBLK BLOCK=SUBONE\n SWA\n  --- SWA Fields for SUBONE ---\n ENDSWA\n\n BLOCK  TYPE=SUBROUTINE,NAME=SUBTWO,RECUR=10\n       :\n  CALLSUB SUBTWO\n       :\n ENDBLK BLOCK=SUBTWO\n SSD\n  --- Subroutine Static Data for SUBTWO ---\n ENDSSD\n SWA\n  --- SWA Fields for SUBTWO ---\n ENDSWA\n\n BLOCK  TYPE=SUBROUTINE,NAME=SUBTHREE,OPTIONS=(NOLOADBASE)\n       :\n  CALLSUB SUBTHREE\n       :\n ENDBLK BLOCK=SUBTHREE\n SSD\n  --- Subroutine Static Data for SUBTHREE ---\n ENDSSD\n\n PSD\n  --- Program Static Data ---\n ENDPSD\n PWA\n  --- PWA FIELDS ---\n ENDPWA\n:exmp.\n:p.\nNote that not all programs will require all of these options.  If\nSUBTWO was not recursive, we would not need Dynamic Storage Management.\nHowever, it still may be of assistance in reducing storage needs.\nSWAs, SSDs, and the PSD only need to be coded if\nthere are fields to define there.  If these areas are needed by the\nmacros, they will create them if you have not.  However,\nthe PWA and ENDPWA macros must :hp2.always:ehp2. be coded if the\nprogram is going to use the PWA option.\n:note.\nIf the NOLOCTR option has been selected, the macros will not\ngenerate LOCTRs to arrange the code, and the CSECT will be arranged\nas it was coded.\n:p.\nWhen the load module is actually created by the Assembler, the\nlayout of a single CSECT looks like the figure below:\n:xmp.\n.bx 4 15 29 40 53 67 75\n.tp 5 16 30 41 54 68\n!Program!Subroutine!Partial!PSD User!Subroutine!SSD\n!Code (1)! Code (2)!PSD (3)!Fields (4)!Code (5)!(6)\n.bx off\n:exmp.\n:dl termhi=0 tsize=6.\n:dt.(1)\n:dd.First in the CSECT is the code from the program block itself.\n:dt.(2)\n:dd.Following the program code is the code for any subroutines\nthat did not specify LOADBASE.  This allows these subroutines to\nbe addressed off of the program's base register.\n:dt.(3)\n:dd.The partial PSD contains any PSD fields that were defined\nwithin the body of the program.  Also included here are the SSDs\nfrom the subroutines without LOADBASE.  The partial PSD along\nwith the PSD user fields are addressed off of the program's\nbase register.\n:dt.(4)\n:dd.The PSD user fields are any static data coded\nbetween the PSD and ENDPSD macros at the end of the program.\n:dt.(5)\n:dd.The subroutine code for any subroutines that use the LOADBASE\noption is placed after the PSD.  If there are no subroutines that\nuse LOADBASE, this area and the next one are missing.\n:dt.(6)\n:dd.Following the code for a LOADBASE subroutine is the static\ndata (SSD) for that subroutine.  This data is addressed off of\nthe subroutine's base register.  These last two areas can be repeated\nany number of times, once for each subroutine that uses the\nLOADBASE option.\n:edl.\n.*\n.*\n:h1.Register Usage\n:p.\n.rc 1 on\nWith so many things being done by the macros, you may\nnot be sure exactly what registers are available for general use.\nThis appendix describes the registers used by the Structured Macros.\n.rc 1 off\n.rc 1 on\n:h2.Register Usage for ENVIRON=DC\n:p.\n:h3.IDMS/DC User Mode Registers And Linkage\n:ul.\n:li.User mode programs are invoked by:\n:ul compact.\n:li.A #LINK from RHDCTSKC (task create)\n:li.A #LINK or #XCTL from another program\n:eul.\n:li.User mode registers are used as follows:\n:dl.\n:dt.R15\n:dd.Entry point address from caller; loaded into the specified program\nbase register by the BLOCK TYPE=PROGRAM macro. Also used for subroutine\nlinkage if the LONG option is used.\n:dt.R14\n:dd.This is used for returning from subroutine blocks.\n:dt.R13\n:dd.Not used.\n:dt.R12\n:dd.Default program base register.\n:dt.R11\n:dd.Default PWA base register.\n:dt.R10\n:dd.Address of the IDMS/DC CSA on entry, although this register may be\nused for other things by the program.\n:dt.R9\n:dd.Address of the IDMS/DC task's TCE on entry, although this register\nmay be used for other things by the program.\n:dt.R2-R8\n:dd.Not used.\n:dt.R1\n:dd.Address of parameter list from calling program, if any\n:dt.R0\n:dd.Not used.\n:edl.\n:li.Registers are always saved across requests for IDMS/DC services,\nexcept for R14, R15, R0 and R1.\n:li.The assembler program should include an interface, either by coding\na #BALI macro among your constants somewhere, or by specifying\nINCLUDE IDMSLIB(IDMSBALI) to the linkage editor.\n:li.User mode programs must return to IDMS/DC using the #RETURN macro.\nIf you use the NO#RETURN option, you must code a #RETURN yourself at\nsome point after the program block's ENDBLK macro.\n:eul.\n:h3.IDMS/DC System Mode Registers And Linkage\n:ul.\n:li.System mode programs are invoked by a #CALL from another\nsystem-mode program. Should you wish to call an external routine, you\nshould use #CALL instead of CALLX.\n:li.System mode registers are used as follows:\n:dl.\n:dt.R15\n:dd.Entry point address from caller; loaded into the specified program\nbase register by the BLOCK TYPE=PROGRAM macro. Also used for internal\nsubroutine linkage if the LONG option is used.\n:dt.R14\n:dd.This is used for returning from subroutine blocks.\n:dt.R13\n:dd.Not used.\n:dt.R12\n:dd.Program base register.\n:dt.R11\n:dd.Default PWA base register, for PWA's obtained by either #GETSTG\nor #GETSTK.\n:dt.R10\n:dd.Address of the IDMS/DC CSA. This should not be modified\nby the program.\n:dt.R9\n:dd.Address of the IDMS/DC task's TCE. This should not be modified\nby the program.\n:dt.R2-R8\n:dd.Not used.\n:dt.R1\n:dd.Address of parameter list from calling program, if any\n:dt.R0\n:dd.Not used.\n:edl.\n:li.Registers R13 and R15-R1 are never saved across #CALLs.\n:li.Registers R11, R12 and R14 are always saved in the current\nTCE's save area stack.\n:li.The caller of a routine is responsible for specifying which\nof the remaining registers (R2-R8) are to be saved. For example,\n.fo off\n      #CALL  pgmname,(R2-R8)\n.fo on\nwill cause R2 through R8 to be saved on the TCE stack, along with\nR11, R12 and R14.\n:eul.\n.rc 1 off\n:h2.Register Usage for ENVIRON=OS\n:p.\n:dl.\n:dt.R15\n:dd.This register is used for the address of the subroutine\nwhen CALLSUB is used with the LONG Program Block option.\n:dt.R14\n.rc 1 on\n:dd.This register holds the return address from any subroutine block\n.rc 1 off\ncalled by the macros.\n:dt.R13\n:dd.This is the base register for the PWA.  Although the PWA can\nhave multiple base registers,\n.rc 1 on\nthe first one must always be R13 since\nthe standard OS save area for the program is at the beginning of the\nPWA.\n.rc 1 off\nIf *NORENT is used and SVAREA= is not specified, R13 is the first\nprogram base as well as pointing to the OS save area.\n:dt.R12\n:dd.This is normally the base register for the program itself along\nwith any static data.\nIf the NORENT option is being used and the SVAREA=  keyword was\nnot specified, R13 is used for the base register instead of R12.\nThe BASEREG=  keyword on the Program Block can be used to specify\na different base register (or multiple base registers).\n:dt.R11\n:dd.If the DYN option was specified on the Program Block, R11 will\nbe used to establish addressibility on the SWA of the current\nsubroutine.  This register is in use even when no subroutine is\ncurrently active.  Although the Subroutine Block allows you to\nspecify multiple base registers for the SWA, R11 must always be\nthe first one.\n:dt.R10\n:dd.If the LOADBASE options was specified on the Subroutine Block,\nR10 will be used as the base register for the subroutine code.\nThis register is only in use while the LOADBASE subroutine is\ncurrently active.\nThe BASEREG=  keyword on the Subroutine Block can be used to specify\na different base register (or multiple base registers).\n:edl.\n.rc 1 on\n:h2.Register Usage for ENVIRON=PLI\n:p.\n:dl.\n:dt.R15\n:dd.This register is used for the address of the subroutine\nwhen CALLSUB is used with the LONG Program Block option.\n:dt.R14\n:dd.This register holds the return address from any subroutine block\ncalled by the macros.\n:dt.R13\n:dd.This is the base register for the PWA.  A PL/I DSA is\ncontained in the first part of the PWA; therefore, R13 is\nalso the base for the DSA.  Although the PWA can have\nmultiple base registers, the first one must always be R13\nbecause PL/I requires that R13 contain a pointer to the DSA.\n:dt.R12\n:dd.This is the pointer to PL/I's Task Communications Area (TCA) and\nshould never be modified by a program.\n:dt.R11\n:dd.This is the first program base register for the program\nitself along with any static data.\n:dt.R10\n:dd.If the LOADBASE options was specified on the Subroutine\nBlock, R10 will be used as the base register for the\nsubroutine code.  This register is only in use while the\nLOADBASE subroutine is currently active.  The BASEREG=\nkeyword on the Subroutine Block can be used to specify a\ndifferent base register (or multiple base registers).\n:edl.\n.rc 1 off\n:egdoc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "##$DC": {"ttr": 3593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16X\\x00'\\x00'\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:58:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##$DC\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1986.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##$DC\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##$DC\n.*\n.*  PURPOSE    INTERNAL MACRO USED AS SET DEFAULTS FOR BLOCK\n.*             START/END MACRO NAMES FOR IDMS/DC PROGRAMS\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   01/05/87 JCB - NEW\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &#PPMAC,&#PEMAC,&#EPMAC,&#EEMAC\n         GBLC  &#SPMAC,&#SEMAC,&#IPMAC,&#IEMAC\n         GBLC  &#WPMAC,&#WEMAC,&#UPMAC,&#UEMAC\n&#PPMAC  SETC  '##PPDC'               PROGRAM BLOCK PROLOG MACRO NAME\n&#PEMAC  SETC  '##PEDC'               PROGRAM BLOCK EPILOG MACRO NAME\n&#EPMAC  SETC  '##EPSTD'              ERREXIT BLOCK PROLOG MACRO NAME\n&#EEMAC  SETC  '##EESTD'              ERREXIT BLOCK EPILOG MACRO NAME\n&#SPMAC  SETC  '##SPSTD'              SUBROUTINE BLOCK PROLOG MACRO\n&#SEMAC  SETC  '##SESTD'              SUBROUTINE BLOCK EPILOG MACRO\n&#IPMAC  SETC  '##IPSTD'              INLINE BLOCK PROLOG MACRO NAME\n&#IEMAC  SETC  '##IESTD'              INLINE BLOCK EPILOG MACRO NAME\n&#WPMAC  SETC  '##WPDC'               PWA PROLOG MACRO NAME\n&#WEMAC  SETC  '##WESTD'              PWA EPILOG MACRO NAME\n&#UPMAC  SETC  '##UPSTD'              SWA PROLOG MACRO NAME\n&#UEMAC  SETC  '##UESTD'              SWA EPILOG MACRO NAME\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "##$OS": {"ttr": 3595, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16X\\x00'\\x00'\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:58:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##$OS\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1986.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##$OS\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##$OS\n.*\n.*  PURPOSE    INTERNAL MACRO USED AS SET DEFAULTS FOR BLOCK\n.*             START/END MACRO NAMES FOR OS ENVIRONMENT PROGRAMS\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   12/18/86 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &#PPMAC,&#PEMAC,&#EPMAC,&#EEMAC\n         GBLC  &#SPMAC,&#SEMAC,&#IPMAC,&#IEMAC\n         GBLC  &#WPMAC,&#WEMAC,&#UPMAC,&#UEMAC\n&#PPMAC  SETC  '##PPOS'               PROGRAM BLOCK PROLOG MACRO NAME\n&#PEMAC  SETC  '##PEOS'               PROGRAM BLOCK EPILOG MACRO NAME\n&#EPMAC  SETC  '##EPSTD'              ERREXIT BLOCK PROLOG MACRO NAME\n&#EEMAC  SETC  '##EESTD'              ERREXIT BLOCK EPILOG MACRO NAME\n&#SPMAC  SETC  '##SPSTD'              SUBROUTINE BLOCK PROLOG MACRO\n&#SEMAC  SETC  '##SESTD'              SUBROUTINE BLOCK EPILOG MACRO\n&#IPMAC  SETC  '##IPSTD'              INLINE BLOCK PROLOG MACRO NAME\n&#IEMAC  SETC  '##IESTD'              INLINE BLOCK EPILOG MACRO NAME\n&#WPMAC  SETC  '##WPOS'               PWA PROLOG MACRO NAME\n&#WEMAC  SETC  '##WESTD'              PWA EPILOG MACRO NAME\n&#UPMAC  SETC  '##UPSTD'              SWA PROLOG MACRO NAME\n&#UEMAC  SETC  '##UESTD'              SWA EPILOG MACRO NAME\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "##$PLI": {"ttr": 3597, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16X\\x00'\\x00'\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:58:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##$PLI\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1986.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##$PLI\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##$PLI\n.*\n.*  PURPOSE    INTERNAL MACRO USED AS SET DEFAULTS FOR BLOCK\n.*             START/END MACRO NAMES FOR PLI PROGRAMS\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   12/18/86 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &#PPMAC,&#PEMAC,&#EPMAC,&#EEMAC\n         GBLC  &#SPMAC,&#SEMAC,&#IPMAC,&#IEMAC\n         GBLC  &#WPMAC,&#WEMAC,&#UPMAC,&#UEMAC\n&#PPMAC  SETC  '##PPPLI'              PROGRAM BLOCK PROLOG MACRO NAME\n&#PEMAC  SETC  '##PEPLI'              PROGRAM BLOCK EPILOG MACRO NAME\n&#EPMAC  SETC  '##EPSTD'              ERREXIT BLOCK PROLOG MACRO NAME\n&#EEMAC  SETC  '##EESTD'              ERREXIT BLOCK EPILOG MACRO NAME\n&#SPMAC  SETC  '##SPSTD'              SUBROUTINE BLOCK PROLOG MACRO\n&#SEMAC  SETC  '##SESTD'              SUBROUTINE BLOCK EPILOG MACRO\n&#IPMAC  SETC  '##IPSTD'              INLINE BLOCK PROLOG MACRO NAME\n&#IEMAC  SETC  '##IESTD'              INLINE BLOCK EPILOG MACRO NAME\n&#WPMAC  SETC  '##WPPLI'              PWA PROLOG MACRO NAME\n&#WEMAC  SETC  '##WESTD'              PWA EPILOG MACRO NAME\n&#UPMAC  SETC  '##UPSTD'              SWA PROLOG MACRO NAME\n&#UEMAC  SETC  '##UESTD'              SWA EPILOG MACRO NAME\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "##ASMH": {"ttr": 3841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16X\\x00*\\x00*\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:58:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##ASMH  &PASS=FIRST            MACRO TO TEST ASSEMBLER.\n.*                                      SHOULD BE CALLED WITH FIELD\n.*                                      OF THE FORM ((A))\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1985.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##ASMH\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##ASMH\n.*\n.*  PURPOSE    INTERNAL MACRO USED BY PLIST AND EXECUTE MACRO TO\n.*             TEST TO SEE IF ASSEMBLER H IS ACTIVE.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    1/31/85 PLH - NEW\n.*\n.*--------------------------------------------------------------------*\n         GBLB  &##ASMH                  DECLARE GLOBAL VARIABLE.\n&##ASMH  SETB  0                        ASSUME NOT ASSEMBLER H.\n         AIF   ('&PASS' NE 'FIRST').X50\n.*  PASS THE FIRST ITEM IN THE FIRST LIST BACK TO ##ASMH.  IF THE\n.*  LEVEL H ASSEMBLER IS BEING USED, THIS WILL BE A LIST OF ONE\n.*  ITEM -->  (A)\n.*  IF THE F ASSEMBLER IS BEING USED, THIS WILL BE THE CHARACTER\n.*  STRING \"(A)\"\n         ##ASMH &SYSLIST(1,1),PASS=SECOND\n         MEXIT\n.*  IF THE FIRST CHARACTER IN THE FIRST ITEM OF THE FIRST LIST\n.*  IS A PARENTHESIS, THEN THE \"(A)\" WAS PASSED AS A CHARACTER\n.*  STRING AND NOT A LIST.  THEREFORE, THE F ASSEMBLER IS BEING\n.*  USED.\n.X50     AIF   ('&SYSLIST(1,1)'(1,1) EQ '(').X100\n&##ASMH  SETB  1                        IF IS ASSEMBLER H,\n.X100    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "##COND": {"ttr": 3843, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16X\\x01\\xae\\x01\\xae\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:58:00", "lines": 430, "newlines": 430, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n&NAME    ##COND &S=,&F=,&T=B,&L=N,&B=1,&E=\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##COND\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##COND\n.*\n.*  PURPOSE    INTERNAL MACRO USED TO GENERATE TESTS FOR CONDITIONAL\n.*             EXPRESSIONS.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 MGG - NEW\n.*              2/20/86 MGG - ADDED #TEST SUPPORT FOR DC PROGRAMS   @C1\n.*                            AND CONDITION ANY SUPPORT             @C1\n.*              9/13/89 MGG - ADDED SUPPORT FOR USER DEFINED        @C2\n.*                            CONDITIONS.                           @C2\n.*              9/15/89 MGG - CHANGED DEFAULT T= FROM A TO B AND    @C3\n.*                            MAKE E= DEFAULT TO N'SYSLIST.         @C3\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#MNDX                   TAG INDEX\n         LCLA  &CTR                     WORK COUNTER\n         LCLC  &COND,&TAG,&OP           WORK 'COND', TAG, AND OPCODE\n         LCLC  &WL,&WNAME,&WS,&WF       WORK L=, &NAME, S=, AND T=\n         LCLA  &WB,&WE                  WORK B= AND E=\n         LCLC  &WORK                    WORK CHARACTER FIELD\n&WL      SETC  '&L'                     SET WORK L=\n&WS      SETC  '&S'                     SET WORK S=\n&WF      SETC  '&F'                     SET WORK F=\n&WB      SETA  &B                       SET WORK B=\n         AIF   ('&E' EQ '').PRC0110                                 @C3\n&WE      SETA  &E                       SET WORK E=                 @C3\n         AGO   .PRC0120                                             @C3\n.PRC0110 ANOP                                                       @C3\n&WE      SETA  N'&SYSLIST               SET WORK E= TO N'&SYSLIST   @C3\n.PRC0120 ANOP                                                       @C3\n&WNAME   SETC  '&NAME'                  SET WORK NAME\n         AIF   (&WE LT &WB).ERR0001     ERROR IF <1 PARM\n         AIF   ('&T' EQ 'A').PRC1000    GO TO PRODUCTION A PROCESS\n         AIF   ('&T' EQ 'B').PRC2000    GO TO PRODUCTION B PROCESS\n         AIF   ('&T' EQ 'C').PRC3000    GO TO PRODUCTION C PROCESS\n         AIF   ('&T' EQ 'D').PRC4000    GO TO PRODUCTION D PROCESS\n         AIF   ('&T' EQ 'E').PRC5000    GO TO PRODUCTION E PROCESS\n         AGO   .ERR0004                 ERROR OTHERWISE\n.*--------------------------------------------------------------------*\n.*       A ::= B,THEN | B\n.*--------------------------------------------------------------------*\n.PRC1000 ANOP  ,                        PRODUCTION A PROCESS\n&CTR     SETA  &WE-&WB+1                SET CTR = NUMBER OF PARMS\n         AIF   (&CTR LT 1).ERR0001      ERROR IF LESS THAN 1 PARM\n         AIF   ('&SYSLIST(&WE)' NE 'THEN').PRC1100 IF 'THEN' ON END\n         AIF   (&CTR LT 2).ERR0001        ERROR IF LESS THAN 2 PARMS\n&WE      SETA  &WE-1                      BACK WORK E= TO BEFORE 'THEN'\n.PRC1100 AGO   .PRC2000                 TAKE SHORT CUT TO T=B\n.*--------------------------------------------------------------------*\n.*       B ::= B,OR,C | C\n.*--------------------------------------------------------------------*\n.PRC2000 AIF   (&WE GT 51).ERR0006\n&CTR     SETA  &WE                      SEARCH FROM END FOR 'OR'\n.PRC2100 AIF   (&CTR LT &WB).PRC3000    IF NO OR, TAKE SHORT CUT TO T=C\n         AIF   ('&SYSLIST(&CTR)' EQ 'OR').PRC2200 SUCCESSFUL IF 'OR'\n&CTR     SETA  &CTR-1                   DECREMENT COUNTER\n         AGO   .PRC2100                 LOOP SEARCHING FOR 'OR'\n.PRC2200 AIF   (&WE EQ &CTR).ERR0001    ERROR IF 'OR' ON END\n         AIF   (&WB EQ &CTR).ERR0001    ERROR IF 'OR' ON FRONT\n&#MNDX   SETA  &#MNDX+1                 INCREMENT MASTER TAG INDEX\n&TAG     SETC  '#IF&#MNDX'              SET TAG EQUAL TO NEW FAIL TAG\n&CTR     SETA  &CTR-1                   PROCESS THINGS TO LEFT OF 'OR'\n&WNAME   ##COND &SYSLIST(1),&SYSLIST(2),                               $\n               &SYSLIST(3),&SYSLIST(4),&SYSLIST(5),&SYSLIST(6),        $\n               &SYSLIST(7),&SYSLIST(8),&SYSLIST(9),&SYSLIST(10),       $\n               &SYSLIST(11),&SYSLIST(12),&SYSLIST(13),&SYSLIST(14),    $\n               &SYSLIST(15),&SYSLIST(16),&SYSLIST(17),&SYSLIST(18),    $\n               &SYSLIST(19),&SYSLIST(20),&SYSLIST(21),&SYSLIST(22),    $\n               &SYSLIST(23),&SYSLIST(24),&SYSLIST(25),&SYSLIST(26),    $\n               &SYSLIST(27),&SYSLIST(28),&SYSLIST(29),&SYSLIST(30),    $\n               &SYSLIST(31),&SYSLIST(32),&SYSLIST(33),                 $\n               &SYSLIST(34),&SYSLIST(35),&SYSLIST(36),                 $\n               &SYSLIST(37),&SYSLIST(38),&SYSLIST(39),                 $\n               &SYSLIST(40),&SYSLIST(41),&SYSLIST(42),                 $\n               &SYSLIST(43),&SYSLIST(44),&SYSLIST(45),                 $\n               &SYSLIST(46),&SYSLIST(47),&SYSLIST(48),                 $\n               &SYSLIST(49),&SYSLIST(50),&SYSLIST(51),                 $\n               F=&TAG,S=&WS,T=B,L=P,B=&WB,E=&CTR\n&WNAME   SETC  '&TAG'                   SET NEW WORK TAG\n&WB      SETA  &CTR+2                   SET NEW BEGINNING PAST OR\n         AGO   .PRC3000                 TAKE SHORT CUT TO T=C\n.*--------------------------------------------------------------------*\n.*       C ::= C,AND,D | D\n.*--------------------------------------------------------------------*\n.PRC3000 ANOP  ,                        PRODUCTION C PROCESSING\n&CTR     SETA  &WE                      SEARCH FROM END FOR 'AND'\n.PRC3100 AIF   (&CTR LT &WB).PRC4000    IF NO AND,TAKE SHORT CUT TO T=D\n         AIF   ('&SYSLIST(&CTR)' EQ 'AND').PRC3200 CHECK FOR 'AND'\n&CTR     SETA  &CTR-1                   DECREMENT COUNTER\n         AGO   .PRC3100                 LOOP SEARCHING FOR 'AND'\n.PRC3200 AIF   (&WE EQ &CTR).ERR0001    ERROR IF 'AND' ON END\n         AIF   (&WB EQ &CTR).ERR0001    ERROR IF 'AND\n&#MNDX   SETA  &#MNDX+1                 INCREMENT MASTER TAG INDEX\n&TAG     SETC  '#IS&#MNDX'              MAKE NEW SUCCESS TAG\n&CTR     SETA  &CTR-1                   PROCESS THINGS TO LEFT OF 'AND'\n&WNAME   ##COND &SYSLIST(1),&SYSLIST(2),                               $\n               &SYSLIST(3),&SYSLIST(4),&SYSLIST(5),&SYSLIST(6),        $\n               &SYSLIST(7),&SYSLIST(8),&SYSLIST(9),&SYSLIST(10),       $\n               &SYSLIST(11),&SYSLIST(12),&SYSLIST(13),&SYSLIST(14),    $\n               &SYSLIST(15),&SYSLIST(16),&SYSLIST(17),&SYSLIST(18),    $\n               &SYSLIST(19),&SYSLIST(20),&SYSLIST(21),&SYSLIST(22),    $\n               &SYSLIST(23),&SYSLIST(24),&SYSLIST(25),&SYSLIST(26),    $\n               &SYSLIST(27),&SYSLIST(28),&SYSLIST(29),&SYSLIST(30),    $\n               &SYSLIST(31),&SYSLIST(32),&SYSLIST(33),                 $\n               &SYSLIST(34),&SYSLIST(35),&SYSLIST(36),                 $\n               &SYSLIST(37),&SYSLIST(38),&SYSLIST(39),                 $\n               &SYSLIST(40),&SYSLIST(41),&SYSLIST(42),                 $\n               &SYSLIST(43),&SYSLIST(44),&SYSLIST(45),                 $\n               &SYSLIST(46),&SYSLIST(47),&SYSLIST(48),                 $\n               &SYSLIST(49),&SYSLIST(50),&SYSLIST(51),                 $\n               F=&WF,S=&TAG,T=C,L=N,B=&WB,E=&CTR\n&WNAME   SETC  '&TAG'                   SET NEW WORK TAG\n&WB      SETA  &CTR+2                   SET NEW BEGINNING PAST OR\n         AGO   .PRC4000                 TAKE SHORT CUT TO T=D\n.*--------------------------------------------------------------------*\n.*       D ::= NOT,E | E\n.*--------------------------------------------------------------------*\n.PRC4000 ANOP  ,                        PRODUCTION D PROCESS\n         AIF   ('&SYSLIST(&WB)' NE 'NOT').PRC5000 SHORT CUT TO T=E\n         AIF   (&WE-&WB NE 1).ERR0001   ERROR IF NOT 2 PARMS\n         AIF   ('&WL' EQ 'P').PRC4010   SWITCH LOGIC\n&WL      SETC  'P'                        'N' CHANGES TO 'P'\n         AGO   .PRC4020\n.PRC4010 ANOP\n&WL      SETC  'N'                        'P' CHANGES TO 'N'\n.PRC4020 ANOP\n&WB      SETA  &WB+1                    SET BEGINNING PAST NOT\n&TAG     SETC  '&WS'                    SWITCH SUCCESS\n&WS      SETC  '&WF'                      AND\n&WF      SETC  '&TAG'                     FAIL TAGS\n         AGO   .PRC5000                 TAKE SHORT CUT TO T=E\n.*--------------------------------------------------------------------*\n.*       E ::= (B) | (COMPARE) | COND\n.*--------------------------------------------------------------------*\n.PRC5000 ANOP  ,                        PRODUCTION E PROCESSING\n         AIF   (&WE NE &WB).ERR0001     ERROR IF NOT ONE PARM LEFT\n         AIF   ('&SYSLIST(&WB)' EQ '').ERR0001 ERROR IF PARM IS NULL\n         AIF   ('&SYSLIST(&WB)'(1,1) EQ '(').PRC5050 IF PARM DOES NOT\n&COND    SETC  '&SYSLIST(&WB)'          START WITH '(', MUST BE 'COND'\n         AGO   .PRC6000                 GO PROCESS 'COND'\n.PRC5050 ANOP  ,                        CHECK FOR OPCODE\n         AIF   ('&SYSLIST(&WB)' EQ '&SYSLIST(&WB,1)').ERR0005\n&OP      SETC  '&SYSLIST(&WB,1)'        GET POSSIBLE OPCODE\n         AIF   ('&OP' EQ 'CLC').PRC5200 IF IT IS ONE OF THE OPCODES\n         AIF   ('&OP' EQ 'CR').PRC5200    HERE THEN IT MUST BE OF\n         AIF   ('&OP' EQ 'C').PRC5200     THE FORM (COMPARE)\n         AIF   ('&OP' EQ 'CP').PRC5200  ELSE\n         AIF   ('&OP' EQ 'CH').PRC5200    ASSUME THE FROM (B)\n         AIF   ('&OP' EQ 'CLR').PRC5200\n         AIF   ('&OP' EQ 'CL').PRC5200\n         AIF   ('&OP' EQ 'CLI').PRC5200\n         AIF   ('&OP' EQ 'CLCL').PRC5200\n         AIF   ('&OP' EQ 'TM').PRC5200\n         AIF   ('&OP' EQ 'CLM').PRC5300\n         AIF   ('&OP' EQ 'TBIT').PRC5400\n         AIF   ('&OP' EQ 'TREG').PRC5500\n         AIF   ('&OP' EQ '#TEST').PRC5600                           @C1\n         AIF   ('&OP'(1,1) EQ '%').PRC5700                          @C2\n&CTR     SETA  N'&SYSLIST(&WB)          PROCESS THINGS INSIDE ()'S\n&WNAME   ##COND &SYSLIST(&WB,1),&SYSLIST(&WB,2),&SYSLIST(&WB,3),       $\n               &SYSLIST(&WB,4),&SYSLIST(&WB,5),&SYSLIST(&WB,6),        $\n               &SYSLIST(&WB,7),&SYSLIST(&WB,8),&SYSLIST(&WB,9),        $\n               &SYSLIST(&WB,10),&SYSLIST(&WB,11),&SYSLIST(&WB,12),     $\n               &SYSLIST(&WB,13),&SYSLIST(&WB,14),&SYSLIST(&WB,15),     $\n               &SYSLIST(&WB,16),&SYSLIST(&WB,17),&SYSLIST(&WB,18),     $\n               &SYSLIST(&WB,19),&SYSLIST(&WB,20),&SYSLIST(&WB,21),     $\n               &SYSLIST(&WB,22),&SYSLIST(&WB,23),&SYSLIST(&WB,24),     $\n               &SYSLIST(&WB,25),&SYSLIST(&WB,26),&SYSLIST(&WB,27),     $\n               &SYSLIST(&WB,28),&SYSLIST(&WB,29),&SYSLIST(&WB,30),     $\n               &SYSLIST(&WB,31),&SYSLIST(&WB,32),&SYSLIST(&WB,33),     $\n               &SYSLIST(&WB,34),&SYSLIST(&WB,35),&SYSLIST(&WB,36),     $\n               &SYSLIST(&WB,37),&SYSLIST(&WB,38),&SYSLIST(&WB,39),     $\n               &SYSLIST(&WB,40),&SYSLIST(&WB,41),&SYSLIST(&WB,42),     $\n               &SYSLIST(&WB,43),&SYSLIST(&WB,44),&SYSLIST(&WB,45),     $\n               &SYSLIST(&WB,46),&SYSLIST(&WB,47),&SYSLIST(&WB,48),     $\n               &SYSLIST(&WB,49),&SYSLIST(&WB,50),&SYSLIST(&WB,51),     $\n               F=&WF,S=&WS,T=B,L=&WL,E=&CTR,B=1\n         AGO   .EXIT                    EXIT\n.*       OF FORM (OPCODE,OP1,COND,OP2)\n.PRC5200 AIF   (N'&SYSLIST(&WB) NE 4).ERR0002\n&WNAME   &OP   &SYSLIST(&WB,2),&SYSLIST(&WB,4)\n&WNAME   SETC  ''\n&COND    SETC  '&SYSLIST(&WB,3)'\n         AGO   .PRC6000\n.*       OF FORM (OPCODE,OP1,MASK,COND,OP2)\n.PRC5300 AIF   (N'&SYSLIST(&WB) NE 5).ERR0002\n&WNAME   &OP   &SYSLIST(&WB,2),&SYSLIST(&WB,3),&SYSLIST(&WB,5)\n&WNAME   SETC  ''                       CLEAR WORK NAME\n&COND    SETC  '&SYSLIST(&WB,4)'        SET CONDITION\n         AGO   .PRC6000                 PROCESS 'COND'\n.*       OF FORM (TBIT,OP1,OP2,ON|OFF|MIXED|ANY) 'ON' IS DEFAULT    @C1\n.PRC5400 ANOP\n         AIF   (N'&SYSLIST(&WB) GT 4).ERR0002\n         AIF   (N'&SYSLIST(&WB) LT 2).ERR0002\n         AIF   (N'&SYSLIST(&WB) NE 2).PRC5410\n&COND    SETC  'ON'\n&WNAME   TBIT  &SYSLIST(&WB,2)\n         AGO   .PRC5450\n.PRC5410 AIF   (N'&SYSLIST(&WB) NE 3).PRC5440\n         AIF   ('&SYSLIST(&WB,3)' EQ 'ON').PRC5430\n         AIF   ('&SYSLIST(&WB,3)' EQ 'OFF').PRC5430\n         AIF   ('&SYSLIST(&WB,3)' EQ 'MIXED').PRC5430\n         AIF   ('&SYSLIST(&WB,3)' EQ 'ANY').PRC5430                 @C1\n&COND    SETC  'ON'\n&WNAME   TBIT  &SYSLIST(&WB,2),&SYSLIST(&WB,3)\n         AGO   .PRC5450\n.PRC5430 ANOP\n&COND    SETC  '&SYSLIST(&WB,3)'\n&WNAME   TBIT  &SYSLIST(&WB,2)\n         AGO   .PRC5450\n.PRC5440 ANOP\n&COND    SETC  '&SYSLIST(&WB,4)'\n         AIF   ('&COND' EQ 'ON').PRC5445\n         AIF   ('&COND' EQ 'OFF').PRC5445\n         AIF   ('&COND' EQ 'MIXED').PRC5445                         @C1\n         AIF   ('&COND' NE 'ANY').ERR0002                           @C1\n.PRC5445 ANOP\n&WNAME   TBIT  &SYSLIST(&WB,2),&SYSLIST(&WB,3)\n.PRC5450 ANOP\n&WNAME   SETC  ''\n         AGO   .PRC6000\n.*       OF FORM (TREG,OP1,COND)\n.PRC5500 AIF   (N'&SYSLIST(&WB) NE 3).ERR0002\n&WNAME   TREG  &SYSLIST(&WB,2)\n&WNAME   SETC  ''\n&COND    SETC  '&SYSLIST(&WB,3)'\n         AGO   .PRC6000\n.*       OF FORM (#TEST,OP1,ON|OFF|ANY) 'ON' IS DEFAULT             @C1\n.PRC5600 ANOP                                                       @C1\n         AIF   (N'&SYSLIST(&WB) EQ 3).PRC5610                       @C1\n         AIF   (N'&SYSLIST(&WB) NE 2).ERR0002                       @C1\n&COND    SETC  'ON'                                                 @C1\n         AGO   .PRC5620                                             @C1\n.PRC5610 ANOP                                                       @C1\n&COND    SETC  '&SYSLIST(&WB,3)'                                    @C1\n.PRC5620 AIF   ('&COND' EQ 'ON').PRC5630                            @C1\n         AIF   ('&COND' EQ 'OFF').PRC5630                           @C1\n         AIF   ('&COND' EQ 'ANY').PRC5630                           @C1\n         MNOTE 8,'Invalid option &COND for #TEST condition'         @C1\n         AGO   .EXIT                                                @C1\n.PRC5630 ANOP                                                       @C1\n&WNAME   TM    &SYSLIST(&WB,2).I,&SYSLIST(&WB,2).M                  @C1\n&WNAME   SETC  ''                                                   @C1\n         AGO   .PRC6000                                             @C1\n.*       OF FORM (%UCOND,.....) WHERE UCOND IS USER SUPPLIED COND.  @C2\n.PRC5700 ANOP                                                       @C2\n&WNAME   ##UCOND &SYSLIST(&WB),S=&WS,F=&WF,L=&WL                    @C2\n         AGO   .EXIT                                                @C2\n.*--------------------------------------------------------------------*\n.*       GENERATE BRANCH FOR NEGATIVE LOGIC\n.*--------------------------------------------------------------------*\n.PRC6000 AIF   ('&WL' EQ 'P').PRC7000   IF POSITIVE LOGIC, PROCESS IT\n         AIF   ('&COND' NE 'EQ').PRC6010\n&WNAME   BNE   &WF\n         AGO   .EXIT\n.PRC6010 AIF   ('&COND' NE 'NE').PRC6020\n&WNAME   BE    &WF\n         AGO   .EXIT\n.PRC6020 AIF   ('&COND' NE 'LT').PRC6030\n&WNAME   BNL   &WF\n         AGO   .EXIT\n.PRC6030 AIF   ('&COND' NE 'LE').PRC6040\n&WNAME   BH    &WF\n         AGO   .EXIT\n.PRC6040 AIF   ('&COND' NE 'GT').PRC6050\n&WNAME   BNH   &WF\n         AGO   .EXIT\n.PRC6050 AIF   ('&COND' NE 'GE').PRC6060\n&WNAME   BL    &WF\n         AGO   .EXIT\n.PRC6060 AIF   ('&COND' NE 'Z').PRC6070\n&WNAME   BNZ   &WF\n         AGO   .EXIT\n.PRC6070 AIF   ('&COND' NE 'NZ').PRC6080\n&WNAME   BZ    &WF\n         AGO   .EXIT\n.PRC6080 AIF   ('&COND' NE 'M').PRC6090\n&WNAME   BNM   &WF\n         AGO   .EXIT\n.PRC6090 AIF   ('&COND' NE 'NM').PRC6100\n&WNAME   BM    &WF\n         AGO   .EXIT\n.PRC6100 AIF   ('&COND' NE 'P').PRC6110\n&WNAME   BNP   &WF\n         AGO   .EXIT\n.PRC6110 AIF   ('&COND' NE 'NP').PRC6120\n&WNAME   BP    &WF\n         AGO   .EXIT\n.PRC6120 AIF   ('&COND' NE 'O').PRC6130\n&WNAME   BNO   &WF\n         AGO   .EXIT\n.PRC6130 AIF   ('&COND' NE 'NO').PRC6140\n&WNAME   BO    &WF\n         AGO   .EXIT\n.PRC6140 AIF   ('&COND' NE 'ON').PRC6150\n&WNAME   BNO   &WF\n         AGO   .EXIT\n.PRC6150 AIF   ('&COND' NE 'OFF').PRC6160\n&WNAME   BNZ   &WF\n         AGO   .EXIT\n.PRC6160 AIF   ('&COND' NE 'MIXED').PRC6170\n&WNAME   BNM   &WF\n         AGO   .EXIT\n.PRC6170 AIF   ('&COND' NE 'E').PRC6180\n&WNAME   BNE   &WF\n         AGO   .EXIT\n.PRC6180 AIF   ('&COND' NE 'ANY').PRC6190                           @C1\n&WNAME   BZ    &WF                                                  @C1\n         AGO   .EXIT                                                @C1\n.PRC6190 ANOP                                                       @C1\n.PRC6500 ANOP\n         AIF   (K'&COND GT 4).ERR0003\n         AIF   (K'&COND LT 3).ERR0003\n         AIF   ('&COND'(1,2) NE 'CC').ERR0003\n&WORK    SETC  '&COND'(3,1)\n         AIF   ('&WORK' LT '0' OR '&WORK' GT '9').ERR0003\n&CTR     SETA  &WORK\n         AIF   (K'&COND NE 4).PRC6510\n&WORK    SETC  '&COND'(4,1)\n         AIF   ('&WORK' LT '0' OR '&WORK' GT '9').ERR0003\n&CTR     SETA  10*&CTR+&WORK\n.PRC6510 AIF   (&CTR LT 1).ERR0003\n         AIF   (&CTR GT 14).ERR0003\n&WNAME   BC    15-&CTR,&WF\n         AGO   .EXIT\n.PRC7000 ANOP\n.*--------------------------------------------------------------------*\n.*       GENERATE BRANCH FOR POSITIVE LOGIC\n.*--------------------------------------------------------------------*\n         AIF   ('&COND' NE 'EQ').PRC7010\n&WNAME   BE    &WS\n         AGO   .EXIT\n.PRC7010 AIF   ('&COND' NE 'NE').PRC7020\n&WNAME   BNE   &WS\n         AGO   .EXIT\n.PRC7020 AIF   ('&COND' NE 'LT').PRC7030\n&WNAME   BL    &WS\n         AGO   .EXIT\n.PRC7030 AIF   ('&COND' NE 'LE').PRC7040\n&WNAME   BNH   &WS\n         AGO   .EXIT\n.PRC7040 AIF   ('&COND' NE 'GT').PRC7050\n&WNAME   BH    &WS\n         AGO   .EXIT\n.PRC7050 AIF   ('&COND' NE 'GE').PRC7060\n&WNAME   BNL   &WS\n         AGO   .EXIT\n.PRC7060 AIF   ('&COND' NE 'Z').PRC7070\n&WNAME   BZ    &WS\n         AGO   .EXIT\n.PRC7070 AIF   ('&COND' NE 'NZ').PRC7080\n&WNAME   BNZ   &WS\n         AGO   .EXIT\n.PRC7080 AIF   ('&COND' NE 'M').PRC7090\n&WNAME   BM    &WS\n         AGO   .EXIT\n.PRC7090 AIF   ('&COND' NE 'NM').PRC7100\n&WNAME   BNM   &WS\n         AGO   .EXIT\n.PRC7100 AIF   ('&COND' NE 'P').PRC7110\n&WNAME   BP    &WS\n         AGO   .EXIT\n.PRC7110 AIF   ('&COND' NE 'NP').PRC7120\n&WNAME   BNP   &WS\n         AGO   .EXIT\n.PRC7120 AIF   ('&COND' NE 'O').PRC7130\n&WNAME   BO    &WS\n         AGO   .EXIT\n.PRC7130 AIF   ('&COND' NE 'NO').PRC7140\n&WNAME   BNO   &WS\n         AGO   .EXIT\n.PRC7140 AIF   ('&COND' NE 'ON').PRC7150\n&WNAME   BO    &WS\n         AGO   .EXIT\n.PRC7150 AIF   ('&COND' NE 'OFF').PRC7160\n&WNAME   BZ    &WS\n         AGO   .EXIT\n.PRC7160 AIF   ('&COND' NE 'MIXED').PRC7170\n&WNAME   BM    &WS\n         AGO   .EXIT\n.PRC7170 AIF   ('&COND' NE 'E').PRC7180\n&WNAME   BE    &WS\n         AGO   .EXIT\n.PRC7180 AIF   ('&COND' NE 'ANY').PRC7190                           @C1\n&WNAME   BNZ   &WS                                                  @C1\n         AGO   .EXIT                                                @C1\n.PRC7190 ANOP                                                       @C1\n.PRC7500 ANOP\n         AIF   (K'&COND GT 4).ERR0003\n         AIF   (K'&COND LT 3).ERR0003\n         AIF   ('&COND'(1,2) NE 'CC').ERR0003\n&WORK    SETC  '&COND'(3,1)\n         AIF   ('&WORK' LT '0' OR '&WORK' GT '9').ERR0003\n&CTR     SETA  &WORK\n         AIF   (K'&COND NE 4).PRC7510\n&WORK    SETC  '&COND'(4,1)\n         AIF   ('&WORK' LT '0' OR '&WORK' GT '9').ERR0003\n&CTR     SETA  10*&CTR+&WORK\n.PRC7510 AIF   (&CTR LT 1).ERR0003\n         AIF   (&CTR GT 14).ERR0003\n&WNAME   BC    &CTR,&WS\n         AGO   .EXIT\n.ERR0001 MNOTE 8,'Invalid or missing condition expression'\n         AGO   .EXIT\n.ERR0002 MNOTE 8,'Invalid number of parms for &OP'\n         AGO   .EXIT\n.ERR0003 MNOTE 8,'Invalid condition &COND'\n         AGO   .EXIT\n.ERR0004 MNOTE 8,'Invalid T='\n         AGO   .EXIT\n.ERR0005 MNOTE 8,'This expression requires the Level H assembler'\n         AGO   .EXIT\n.ERR0006 MNOTE 8,'No more than 51 positional parameters can be specifie$\n               d in a condition'\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##CVREG": {"ttr": 3851, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16X\\x00=\\x00=\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:58:00", "lines": 61, "newlines": 61, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##CVREG &REG\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##CVREG\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##CVREG\n.*\n.*  PURPOSE    INTERNAL MACRO USED TO CONVERT AND TEST R FORM\n.*             REGISTER NOTATION.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 MGG - NEW\n.*              7/15/85 MGG - REPLACED WITH THIS VERSION.  THE OLD\n.*                            USED K' AND T' WHICH DID NOT WORK\n.*                            IN SOME CASES.\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#MCVREG                 CONVERTED REGISTER\n&#MCVREG SETA  0\n         AIF   ('&REG' EQ 'R0').EXIT\n&#MCVREG SETA  1\n         AIF   ('&REG' EQ 'R1').EXIT\n&#MCVREG SETA  2\n         AIF   ('&REG' EQ 'R2').EXIT\n&#MCVREG SETA  3\n         AIF   ('&REG' EQ 'R3').EXIT\n&#MCVREG SETA  4\n         AIF   ('&REG' EQ 'R4').EXIT\n&#MCVREG SETA  5\n         AIF   ('&REG' EQ 'R5').EXIT\n&#MCVREG SETA  6\n         AIF   ('&REG' EQ 'R6').EXIT\n&#MCVREG SETA  7\n         AIF   ('&REG' EQ 'R7').EXIT\n&#MCVREG SETA  8\n         AIF   ('&REG' EQ 'R8').EXIT\n&#MCVREG SETA  9\n         AIF   ('&REG' EQ 'R9').EXIT\n&#MCVREG SETA  10\n         AIF   ('&REG' EQ 'R10').EXIT\n&#MCVREG SETA  11\n         AIF   ('&REG' EQ 'R11').EXIT\n&#MCVREG SETA  12\n         AIF   ('&REG' EQ 'R12').EXIT\n&#MCVREG SETA  13\n         AIF   ('&REG' EQ 'R13').EXIT\n&#MCVREG SETA  14\n         AIF   ('&REG' EQ 'R14').EXIT\n&#MCVREG SETA  15\n         AIF   ('&REG' EQ 'R15').EXIT\n&#MCVREG SETA  99\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "##DEFSUB": {"ttr": 3853, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16X\\x00#\\x00#\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:58:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##DEFSUB &NAME\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1985.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##DEFSUB\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##DEFSUB\n.*\n.*  PURPOSE    INTERNAL MACRO USED MAINTAIN TABLE OF SUBROUTINE NAMES\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    7/14/85 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#SB#D                   SUBROUTINE NUMBER (RETURNED)\n         GBLA  &#SB#M                   MAX SUBROUTINE NUMBER\n         GBLC  &#SBNM(99)               SUBROUTINE NAMES\n&#SB#D   SETA  0\n.LOOP    AIF   (&#SB#D GE &#SB#M).NOTFND\n&#SB#D   SETA  &#SB#D+1\n         AIF   ('&#SBNM(&#SB#D)' EQ '&NAME').FND\n         AGO   .LOOP\n.NOTFND  ANOP\n&#SB#D   SETA  &#SB#D+1\n&#SBNM(&#SB#D) SETC '&NAME'\n&#SB#M   SETA  &#SB#D\n.FND     MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "##EESTD": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16X\\x00y\\x00y\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:58:00", "lines": 121, "newlines": 121, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##EESTD &RC,                 RETURN CODE KEYWORD              $\n               &R0,                   R0 KEYWORD                       $\n               &R1                    R1 KEYWORD\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##EESTD\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##EESTD\n.*\n.*  PURPOSE    DEFAULT EPILOG MACRO FOR ERREXIT BLOCKS.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   12/29/86 MGG - BROKEN APART FROM ENDBLK AND RESTRUCTURED\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &#BAMODE(20)             ADDRESSING MODE OF BLOCK\n         GBLA  &#BLVL                   BLOCK LEVEL\n         GBLA  &#BNDX(20)               BLOCK TAG INDEXS\n         GBLC  &#PBAMOD                 AMODE OF PROGRAM\n         GBLA  &#PBNDX                  PROGRAM BLOCK INDEX\n         GBLB  &#PBRTN0                 RETURN R0\n         GBLB  &#PBRTN1                 RETURN R1\n         GBLC  &#PBSMWA                 TAG OF SMWA\n         GBLB  &#PBXA                   XA OPTION\n         GBLB  &#PB370                  370 OPTION\n         LCLC  &TAG,&TAG2               WORK TAG\n.*--------------------------------------------------------------------*\n.*  ISSUE MESSAGE FOR IGNORED KEYWORDS.\n.*--------------------------------------------------------------------*\n.* NONE\n.*--------------------------------------------------------------------*\n.*  LOAD R0 WITH VALUE TO RETURN IN R0\n.*--------------------------------------------------------------------*\n         AIF   ('&R0' EQ '').PKW0030\n         AIF   (&#PBRTN0).PKW0021\n         MNOTE 8,'R0 keyword can not be specified if option RTNR0 is no$\n               t in effect'\n.PKW0021 AIF   ('&R0' EQ '(R0)').PKW0030\n         AIF   ('&R0'(1,1) NE '(').PKW0022\n         LR    R0,&R0(1)                LOAD R0\n         AGO   .PKW0030\n.PKW0022 AIF   ('&R0' NE '0').PKW0025\n         SLR   R0,R0                    SET R0 TO ZERO\n         AGO   .PKW0030\n.PKW0025 LA    R0,&R0                   LOAD R0\n.PKW0030 ANOP\n.*--------------------------------------------------------------------*\n.*  LOAD R1 WITH VALUE TO RETURN IN R1\n.*--------------------------------------------------------------------*\n         AIF   ('&R1' EQ '').PKW0040\n         AIF   (&#PBRTN1).PKW0031\n         MNOTE 8,'R1 keyword can not be specified if option RTNR1 is no$\n               t in effect'\n.PKW0031 AIF   ('&R1' EQ '(R1)').PKW0040\n         AIF   ('&R1'(1,1) NE '(').PKW0032\n         LR    R1,&R1(1)                LOAD R1\n         AGO   .PKW0040\n.PKW0032 AIF   ('&R1' NE '0').PKW0035\n         SLR   R1,R1                    SET R1 TO ZERO\n         AGO   .PKW0040\n.PKW0035 LA    R1,&R1                   LOAD R1\n.*--------------------------------------------------------------------*\n.PKW0040 ANOP\n.*--------------------------------------------------------------------*\n.*  GENERATE AMODE CHANGE CODE IF NECESSARY\n.*--------------------------------------------------------------------*\n&TAG     SETC  '#BV&#BNDX(&#BLVL)'\n         AIF   (NOT &#PBXA).PRC0210\n         AIF   ('&#PBAMOD' EQ 'ANY').PRC0010\n         AIF   ('&#PBAMOD' EQ '&#BAMODE(&#BLVL)').PRC0210\n.PRC0010 AIF   ('&RC' NE '(R15)' AND '&RC' NE '').PRC0020\n         ##SWREG R15                    SAVE WORK REGISTER\n.PRC0020 AIF   (NOT &#PB370).PRC0100\n         L     R15,16                   POINT R15 TO CVT\n         TM    X'74'(R15),X'80'         RUNNING UNDER XA?\n         BZ    &TAG                     NO, SKIP AMODE SETTING\n.PRC0100 AIF   ('&#PBAMOD' NE '31').PRC0110\n&TAG2    SETC  '#BW&#BNDX(&#BLVL)'\n         ICM   R15,B'1111',&TAG2        SWITCH TO\n         BSM   0,R15                     AMODE=31.\n&TAG2    DC    AL4(&TAG+X'80000000') AMODE 31\n         AGO   .PRC0200\n.PRC0110 AIF   ('&#PBAMOD' NE 'ANY' AND '&#PBAMOD' NE '').PRC0120\n         LA    R15,&TAG                 SWITCH TO\n         O     R15,&#PBSMWA+4            AMODE AT ENTRY\n         BSM   0,R15                     TO THE PROGRAM.\n         AGO   .PRC0200\n.PRC0120 AIF   ('&#PBAMOD' NE '24').PRC0130\n         LA    R15,&TAG                 SWITCH TO\n         BSM   0,R15                     AMODE=24.\n         AGO   .PRC0200\n.PRC0130 ANOP INVALID AMODE (A PREVIOUS MACRO WILL ISSUE THE MESSAGE)\n.PRC0200 AIF   ('&RC' NE '(R15)' AND '&RC' NE '').PRC0210\n&TAG     ##RST R15=YES                  RESTORE REGISTERS\n         ##RWREG R15                    RESTORE WORK REGISTER\n         AGO   .PRC0300\n.PRC0210 AIF   ('&RC' NE '(R15)' AND '&RC' NE '').PRC0220\n&TAG     ##RST R15=NO                   RESTORE REGISTERS\n         AGO   .PRC0300\n.PRC0220 AIF   ('&RC'(1,1) NE '(').PRC0230\n&TAG     LR    R15,&RC(1)               LOAD RETURN CODE\n         ##RST R15=NO                   RESTORE REGISTERS\n         AGO   .PRC0300\n.PRC0230 ANOP\n&TAG     ##RST R15=YES                  RESTORE REGISTERS\n         AIF   ('&RC' NE '0').PRC0240\n         SLR   R15,R15                  SET RETURN CODE TO 0\n         AGO   .PRC0300\n.PRC0240 LA    R15,&RC                  LOAD RETURN CODE\n.PRC0300 ANOP\n         B     #BQ&#PBNDX               LEAVE PROGRAM WITH RC IN R15\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##EPSTD": {"ttr": 4100, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16X\\x00\\x8f\\x00\\x8f\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:58:00", "lines": 143, "newlines": 143, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##EPSTD  &NAME,                NAME OF BLOCK                  $\n               &OPTIONS,                OPTIONS                        $\n               &BASEREG,                BASE REGS                      $\n               &AMODE,                  ADDRESSING MODE                $\n               &SAVE                    REGISTER TO SAVE\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1986.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##EPSTD\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##EPSTD\n.*\n.*  PURPOSE    INTERNAL MACRO USE FOR PROLOG FOR ERREXIT BLOCK.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   12/18/86 MGG - BROKE APART FOR BLOCK MACRO AND\n.*                            RESTRUCTURED.\n.*              5/08/89 MGG - REMOVED &SDID AND &WAID PARMS\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &#BAMODE(20)             ADDRESSING MODE OF BLOCK\n         GBLA  &#BLVL                   BLOCK LEVEL\n         GBLA  &#BNDX(20)               BLOCK TAG INDEXS\n         GBLC  &#BSV1(20)               BLOCK SAVE PARM 1\n         GBLC  &#BSV2(20)               BLOCK SAVE PARM 2\n         GBLC  &#BSV3(20)               BLOCK SAVE PARM 3\n         GBLA  &#MNDX                   LAST TAG INDEX USED\n         GBLA  &#PBNDX                  PROGRAM BLOCK INDEX\n         GBLB  &#PBXA                   XA OPTION\n         GBLB  &#PB370                  370 OPTION\n         GBLB  &#SBCSTM                 CUSTOM SUBROUTINE\n         GBLB  &#SBLDBS                 LOAD BASE OPTION\n         GBLB  &#SBSU                   SAVEUSING OPTION\n         GBLB  &#SBSWA                  SWA OPTION\n         GBLB  &#SBUSWA                 USERSWA OPTION\n         LCLC  &TAG,&TAG2               WORK FIELDS\n.*--------------------------------------------------------------------*\n.*  SUPPLY MISSING SWA.\n.*--------------------------------------------------------------------*\n.CLV0020 AIF   (NOT &#SBSWA).CLV0030\n         SWA   TYPE=LAST                SUPPLY MISSING SWA\n         ENDSWA\n.CLV0030 ANOP\n.*--------------------------------------------------------------------*\n.*  SET CHECK FOR IGNORED KEYWORDS.\n.*--------------------------------------------------------------------*\n         ##IGMSG &OPTIONS,OPTION\n         ##IGMSG &BASEREG,BASEREG\n.*------------------------------------------------------------------\n.*  RESET SUBROUTINE OPTIONS.\n.*------------------------------------------------------------------\n&#SBCSTM SETB  0                        SET CUSTOM OFF\n&#SBSWA  SETB  0                        SET SWA OFF\n&#SBSU   SETB  0                        SET SAVEUSING OFF\n&#SBUSWA SETB  0                        SET USERSWA OFF\n&#SBLDBS SETB  0                        SET LOADBASE OFF\n.*--------------------------------------------------------------------*\n.*  SET AND CHECK AMODE.\n.*--------------------------------------------------------------------*\n&#BAMODE(&#BLVL) SETC  '&AMODE'\n         AIF   ('&AMODE' EQ '' OR '&AMODE' EQ 'ANY').ANY0020\n         AIF   ('&AMODE' EQ '24' OR '&AMODE' EQ '31').ANY0020\n         MNOTE 8,'AMODE=&AMODE is invalid on &TYPE block, keyword ignor$\n               ed'\n&#BAMODE(&#BLVL) SETC   ''\n.ANY0020 ANOP\n.*--------------------------------------------------------------------*\n.*  GENERATE DS FOR ERREXIT NAME.\n.*--------------------------------------------------------------------*\n         AIF   ('&NAME' EQ '').ERX0020\n&NAME    DS    0H                       ERREXIT NAME\n         AGO   .ERX0990\n.ERX0020 ANOP\n&TAG     SETC  '#BX&#PBNDX'\n&TAG     DS    0H                       UNNAMED ERROR EXIT\n.ERX0990 ANOP\n.*--------------------------------------------------------------------*\n.*  WARN IF XA OPTION IS NOT SPECIFIED AND AMODE IS.  IF AMODE IS NOT\n.*  SPECIFIED OR \"ANY\" IS SPECIFIED, SKIP AMODE CHECKING CODE.\n.*--------------------------------------------------------------------*\n.AMO0000 ANOP\n&TAG     SETC  ''\n         AIF   ('&AMODE' EQ '').AMO0350\n         AIF   (&#PBXA).AMO0100\n         AIF   (&#XAWARN).AMO0350\n         MNOTE *,'AMODE ignored unless XA option specified for program $\n               block'\n&#XAWARN SETB  1                        ONLY ISSUE ONE TIME\n         AGO   .AMO0350\n.AMO0100 AIF   ('&#BAMODE(&#BLVL)' EQ 'ANY').AMO0350\n.AMO0200 ANOP\n.*--------------------------------------------------------------------*\n.*  IF OPTIONS XA AND 370, GENERATE TEST FOR XA\n.*--------------------------------------------------------------------*\n         ##SWREG R15                    SAVE WORK REGISTER\n&TAG     SETC  '#BY&#MNDX'\n         AIF   (NOT &#PBXA OR NOT &#PB370).AMO0300\n         LA    R15,16                   POINT R15 TO CVT\n         TM    X'74'(R15),X'80'         RUNNING UNDER XA?\n         BZ    &TAG                     SKIP AMODE SETTING\n.*--------------------------------------------------------------------*\n.*  GENERATE CHANGE AMODE CODE.\n.*--------------------------------------------------------------------*\n.AMO0300 ANOP\n         AIF   ('&#BAMODE(&#BLVL)' NE '31').AMO0310\n&TAG2    SETC  '#BZ&#MNDX'\n         ICM   R15,B'1111',&TAG2        LOAD ADDR OF INST AFTER BSM\n         BSM   R14,R15                  SAVE MODE IN R14 & SET NEW MODE\n&TAG2    DC    AL4(&TAG+X'80000000')    AMODE 31\n         AGO   .AMO0320\n.AMO0310 LA    R15,&TAG                 LOAD ADDR OF INST AFTER BSM\n         BSM   0,R15                    SET NEW MODE\n.AMO0320 ANOP\n&TAG     ##RWREG R15                    RESTORE WORK REG\n&TAG     SETC  ''\n.AMO0350 ANOP\n.*--------------------------------------------------------------------*\n.*  IF SAVE= KEYWORD SPECIFIED, SAVE REGISTERS.\n.*--------------------------------------------------------------------*\n&#BSV1(&#BLVL) SETC '&SAVE(1)'\n&#BSV2(&#BLVL) SETC '&SAVE(2)'\n&#BSV3(&#BLVL) SETC '&SAVE(3)'\n         AIF   ('&SAVE' EQ '').AMO0380\n         AIF   (N'&SAVE NE 2).AMO0360\n&TAG     ST    &SAVE(1),&SAVE(2)       SAVE REGISTER\n         AGO   .AMO0390\n.AMO0360 AIF   (N'&SAVE NE 3).AMO0370\n&TAG     STM   &SAVE(1),&SAVE(2),&SAVE(3) SAVE REGISTERS\n         AGO   .AMO0390\n.AMO0370 MNOTE 8,'Invalid number of parameters in SAVE= keyword'\n.AMO0380 AIF   ('&TAG' EQ '').AMO0390\n&TAG     DS    0H\n.AMO0390 ANOP\n.AMO9000 ANOP\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "##IESTD": {"ttr": 4104, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16X\\x00^\\x00^\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:58:00", "lines": 94, "newlines": 94, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##IESTD &RC,                 RETURN CODE KEYWORD              $\n               &R0,                   R0                               $\n               &R1                    R1\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##IESTD\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##IESTD\n.*\n.*  PURPOSE    DEFAULT EPILOG MACRO FOR INLINE BLOCKS.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   12/29/86 MGG - BROKEN APART FROM ENDBLK AND RESTRUCTURED\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &#BAMODE(20)             ADDRESSING MODE OF BLOCK\n         GBLA  &#BLVL                   BLOCK LEVEL\n         GBLA  &#BNDX(20)               BLOCK TAG INDEXS\n         GBLC  &#PBSMWA                 TAG OF SMWA\n         GBLB  &#PBXA                   XA OPTION\n         GBLB  &#PB370                  370 OPTION\n         LCLC  &TAG,&TAG2               WORK TAGS\n.*--------------------------------------------------------------------*\n.*  ISSUE MESSAGE FOR IGNORED KEYWORDS.\n.*--------------------------------------------------------------------*\n         ##IGMSG &R0,R0\n         ##IGMSG &R1,R1\n.*--------------------------------------------------------------------*\n.*  IF OPTIONS XA AND AMODE IS DIFFERENT THAN ENCLOSING BLOCK'S\n.*  AMODE, GENERATE CODE TO SET AMODE TO ENCLOSING BLOCK'S AMODE\n.*--------------------------------------------------------------------*\n         AIF   (NOT &#PBXA).PRC0800\n         AIF   ('&#BAMODE(&#BLVL)' EQ '&#BAMODE(&#BLVL-1)').PRC0800\n.*--------------------------------------------------------------------*\n.*  IF OPTIONS XA AND 370, GENERATE TEST FOR XA\n.*--------------------------------------------------------------------*\n         AIF   ('&RC' NE '(R15)' AND '&RC' NE '').PRC0190\n         ##SWREG R15                    SAVE WORK REGISTER\n.PRC0190 ANOP\n&TAG     SETC  '#BV&#BNDX(&#BLVL)'\n         AIF   (NOT &#PB370).PRC0200\n         L     R15,16                   POINT R15 TO CVT\n         TM    X'74'(R15),X'80'         RUNNING UNDER XA?\n         BZ    &TAG                     SKIP AMODE SETTING\n.*--------------------------------------------------------------------*\n.*  GENERATE CHANGE CODE\n.*--------------------------------------------------------------------*\n.PRC0200 ANOP\n         AIF   ('&#BAMODE(&#BLVL-1)' NE '31').PRC0210\n&TAG2    SETC  '#BW&#BNDX(&#BLVL)'\n         ICM   R15,B'1111',&TAG2        LOAD ADDR OF INST AFTER BSM\n         AGO   .PRC0220\n.PRC0210 LA    R15,#BV&#BNDX(&#BLVL)    LOAD ADDR OF INST AFTER BSM\n.PRC0220 AIF   ('&#BAMODE(&#BLVL-1)' NE 'ANY').PRC0240\n         AIF   ('&#PBSMWA' NE '').PRC0230\n         MNOTE 8,'SMWA= keyword needs to be specified on program block $\n               macro'\n         AGO   .PRC0240\n.PRC0230 O     R15,&#PBSMWA+4           SET HIGH BIT TO AMODE AT ENTRY\n.PRC0240 BSM   0,R15                    SET NEW MODE\n         AIF   ('&#BAMODE(&#BLVL-1)' NE '31').PRC0250\n&TAG2    DC    AL4(&TAG+X'80000000')    AMODE 31\n.PRC0250 ANOP\n         AIF   ('&RC' NE '(R15)' AND '&RC' NE '').PRC0810\n&TAG     ##RST R15=YES                  RESTORE REGISTERS\n         ##RWREG R15                    RESTORE WORK REGISTER\n         AGO   .PRC0900\n.PRC0800 AIF   ('&RC' NE '(R15)' AND '&RC' NE '').PRC0810\n&TAG     ##RST R15=NO                   RESTORE REGISTERS\n         AGO   .PRC0900\n.PRC0810 AIF   ('&RC'(1,1) NE '(').PRC0820\n&TAG     LR    R15,&RC(1)               LOAD RETURN CODE\n         ##RST R15=NO                   RESTORE REGISTERS\n         AGO   .PRC0900\n.PRC0820 ANOP\n&TAG     ##RST R15=YES                  RESTORE REGISTERS\n         AIF   ('&RC' NE '0').PRC0830\n         SLR   R15,R15                  SET RETURN CODE TO ZERO\n         AGO   .PRC0900\n.PRC0830 LA    R15,&RC                  LOAD RETURN CODE\n.PRC0900 ANOP\n.*--------------------------------------------------------------------*\n.*  DECREMENT BLOCK LEVEL AND CHECK FOR IGNORED KEYWORDS\n.*--------------------------------------------------------------------*\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##IGMSG": {"ttr": 4107, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16X\\x00\\x1b\\x00\\x1b\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:58:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##IGMSG &KWD,                  KEYWORD                        $\n               &KWDNAME                 KEYWORD NAME\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1986.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##IGMSG\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##IGMSG\n.*\n.*  PURPOSE    INTERNAL MACRO USED TO DISPLAY MESSAGE FOR IGNORED\n.*             KEYWORDS.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   12/18/86 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         AIF   ('&KWD' EQ '').EXIT\n         MNOTE 4,'&KWDNAME=&KWD ignored'\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##IPSTD": {"ttr": 4109, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16X\\x00\\x7f\\x00\\x7f\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:58:00", "lines": 127, "newlines": 127, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##IPSTD &NAME,                 NAME OF BLOCK                  $\n               &OPTIONS,                OPTIONS                        $\n               &AMODE,                  ADDRESSING MODE                $\n               &SAVE                    REGISTER TO SAVE\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1986.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##IPSTD\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##IPSTD\n.*\n.*  PURPOSE    INTERNAL MACRO USED AS DEFAULT FOR INLINE BLOCK PROLOG.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   12/18/86 MGG - BROKEN APART FROM THE BLOCK MACRO AND\n.*                            RESTRUCURED.\n.*              5/08/89 MGG - REMOVED &SDID AND &WAID TAGS\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &#BAMODE(20)             ADDRESSING MODE OF BLOCK\n         GBLA  &#BLVL                   BLOCK LEVEL\n         GBLC  &#BSV1(20)               BLOCK SAVE PARM 1\n         GBLC  &#BSV2(20)               BLOCK SAVE PARM 2\n         GBLC  &#BSV3(20)               BLOCK SAVE PARM 3\n         GBLC  &#BTYPE(20)              BLOCK TYPE\n         GBLA  &#MNDX                   LAST TAG INDEX USED\n         GBLB  &#PBXA                   XA OPTION\n         GBLB  &#PB370                  370 OPTION\n         GBLB  &#XAWARN                 XA WARNING MESSAGE ISSUED\n         LCLC  &TAG,&TAG2               WORK TAGS\n.*--------------------------------------------------------------------*\n.*  ISSUE WARNINGS FOR IGNORED KEYWORDS.\n.*--------------------------------------------------------------------*\n         ##IGMSG &OPTIONS,OPTION\n.*--------------------------------------------------------------------*\n.*  IF AMODE IS NOT SPECIFIED, IS \"ANY\", OR IS THE SAME AS THE\n.*  CONTAINING BLOCK, ASSUME THE AMODE OF THE CONTAINING BLOCK\n.*  AND SKIP THE GENERATION OF THE AMODE SWITCHING CODE.  IF THE\n.*  AMODE IS INVALID OR OPTION XA WAS NOT SPECIFIED ON THE PROGRAM\n.*  BLOCK, ISSUE AN MESSAGE AND DO THE SAME AS IF THE AMODE\n.*  WAS NOT SPECIFIED.\n.*--------------------------------------------------------------------*\n&#BAMODE(&#BLVL) SETC  '&AMODE'\n         AIF   ('&AMODE' EQ '').AMO0020\n         AIF   ('&AMODE' EQ 'ANY').AMO0020\n         AIF   ('&AMODE' EQ '&#BAMODE(&#BLVL-1)').AMO0020\n         AIF   ('&AMODE' EQ '24' OR '&AMODE' EQ '31').AMO0010\n         MNOTE 8,'AMODE=&AMODE is invalid on &TYPE block, keyword ignor$\n               ed'\n         AGO   .AMO0020\n.AMO0010 AIF   (&#PBXA).AMO0030\n         AIF   (&#XAWARN).AMO0020\n         MNOTE *,'AMODE ignored unless XA option specified for program $\n               block'\n&#XAWARN SETB  1                        ONLY ISSUE ONE TIME\n.AMO0020 ANOP\n&#BAMODE(&#BLVL) SETC  '&#BAMODE(&#BLVL-1)'\n         AGO   .AMO9000\n.AMO0030 ANOP\n.*------------------------------------------------------------------\n.*  IF THIS IS AN INLINE BLOCK WITH AMODE 24 OR 31 SPECIFIED AND\n.*  THE INLINE BLOCK IS WITHIN A SUBROUTINE BLOCK,  REQUIRE THAT\n.*  THE SUBROUTINE BLOCK HAS AMODE 24 OR 31 SPECIFIED.  THIS IS A\n.*  RESTRICTION THAT CAN BE REMOVED WHEN A WAY IS DEVELOPED TO SAVE\n.*  THE AMODE OF THE SUBROUTINE AT ENTRY.  THIS IS NEEDED BECAUSE\n.*  THE OUTERMOST INLINE BLOCK WITH AMODE 24 OR 31 MUST RETURN TO\n.*  THE AMODE OF THE SUBROUTINE ON EXIT.\n.*------------------------------------------------------------------\n         AIF   ('&#BTYPE(1)' NE 'SUBROUTINE').AMO0050\n         AIF   ('&#BAMODE(1)' EQ '31' OR '&#BAMODE(1)' EQ '24').AMO0050\n         MNOTE 8,'AMODE 24 or 31 must be specified on containing subrou$\n               tine block'\n.AMO0050 ANOP\n.*--------------------------------------------------------------------*\n.*  IF OPTIONS XA AND 370 ARE BOTH SPECIFIED FOR THE PROGRAM BLOCK,\n.*  GENERATE A TEST FOR XA.\n.*--------------------------------------------------------------------*\n&TAG     SETC  ''\n         ##SWREG R15                    SAVE WORK REGISTER\n&TAG     SETC  '#BY&#MNDX'\n         AIF   (NOT &#PBXA OR NOT &#PB370).AMO0300\n         L     R15,16                   POINT R15 TO CVT\n         TM    X'74'(R15),X'80'         RUNNING UNDER XA?\n         BZ    &TAG                     SKIP AMODE SETTING\n.*--------------------------------------------------------------------*\n.*  GENERATE CHANGE AMODE CODE.\n.*--------------------------------------------------------------------*\n.AMO0300 ANOP\n         AIF   ('&#BAMODE(&#BLVL)' NE '31').AMO0310\n&TAG2    SETC  '#BZ&#MNDX'\n         ICM   R15,B'1111',&TAG2        LOAD ADDR OF INST AFTER BSM\n         BSM   0,R15                    SET NEW MODE\n&TAG2    DC    AL4(&TAG+X'80000000')    AMODE 31\n         AGO   .AMO0340\n.AMO0310 LA    R15,&TAG                 LOAD ADDR OF INST AFTER BSM\n         BSM   0,R15                    SET NEW MODE\n.AMO0340 ANOP\n&TAG     ##RWREG R15                    RESTORE WORK REG\n&TAG     SETC  ''\n.AMO0350 ANOP\n.AMO9000 ANOP\n.*--------------------------------------------------------------------*\n.*  IF SAVE= KEYWORD SPECIFIED, SAVE REGISTERS.\n.*--------------------------------------------------------------------*\n&#BSV1(&#BLVL) SETC '&SAVE(1)'\n&#BSV2(&#BLVL) SETC '&SAVE(2)'\n&#BSV3(&#BLVL) SETC '&SAVE(3)'\n         AIF   ('&SAVE' EQ '').SAV0060\n         AIF   (N'&SAVE NE 2).SAV0020\n&TAG     ST    &SAVE(1),&SAVE(2)       SAVE REGISTER\n         AGO   .SAV0080\n.SAV0020 AIF   (N'&SAVE NE 3).SAV0040\n&TAG     STM   &SAVE(1),&SAVE(2),&SAVE(3) SAVE REGISTERS\n         AGO   .SAV0080\n.SAV0040 MNOTE 8,'Invalid number of parameters in SAVE= keyword'\n.SAV0060 AIF   ('&TAG' EQ '').SAV0080\n&TAG     DS    0H\n.SAV0080 ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "##L": {"ttr": 4112, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16X\\x00O\\x00O\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:58:00", "lines": 79, "newlines": 79, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##L   &REG,                    REGISTER TO LOAD               $\n               &FIELD,                  FIELD TO LOAD                  $\n               &WREG=                   WORK REGISTER\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1989.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##L\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##L\n.*\n.*  PURPOSE    INTERNAL MACRO TO LOAD A VALUE INTO A REGISTER.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    3/15/89 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         LCLC  &TAG                     WORK TAG\n         LCLC  &TREG                    WORK FIELD\n         AIF   ('&FIELD' NE '').X100\n         SLR   &REG,&REG                NO PARAMETER SPECIFIED\n         MEXIT\n.X100    AIF   (T'&FIELD NE 'N').X200\n         AIF   ('&FIELD'(1,1) LT '0' OR '&FIELD'(1,1) GT '9').ERR1\n         L     &REG,=F'&FIELD'          LOAD NUMERIC CONSTANT\n         MEXIT\n.X200    AIF   (K'&FIELD GT 4).X300\n         AIF   (K'&FIELD NE 4).X210\n         AIF   ('&FIELD'(1,2) NE '*R').X300\n         AIF   ('&FIELD'(3,1) NE '1').X300\n         AIF   ('&FIELD'(4,1) LT '0').X300\n         AIF   ('&FIELD'(4,1) GT '5').X300\n&TREG    SETC  '&FIELD'(2,3)\n         L     &REG,0(,&TREG)\n         MEXIT\n.X210    AIF   (K'&FIELD NE 3).X230\n         AIF   ('&FIELD'(1,2) NE '*R').X220\n         AIF   ('&FIELD'(3,1) LT '0').X300\n&TREG    SETC  '&FIELD'(2,2)\n         L     &REG,0(,&TREG)\n         MEXIT\n.X220    AIF   ('&FIELD'(1,1) NE 'R').X300\n         AIF   ('&FIELD'(2,1) NE '1').X300\n         AIF   ('&FIELD'(3,1) LT '0').X300\n         AIF   ('&FIELD'(3,1) GT '5').X300\n         AIF   ('&REG' EQ '&FIELD').MEXIT\n         LR    &REG,&FIELD\n         MEXIT\n.X230    AIF   (K'&FIELD NE 2).X300\n         AIF   ('&FIELD'(1,1) NE 'R').X300\n         AIF   ('&FIELD'(2,1) LT '0').X300\n         AIF   ('&REG' EQ '&FIELD').MEXIT\n         LR    &REG,&FIELD\n         MEXIT\n.X300    AIF   ('&FIELD'(1,1) NE '*').X400\n&TAG     SETC  '&FIELD'(2,K'&FIELD-1)\n         AIF   ('&REG' NE 'R0').X310\n         AIF   (T'&WREG EQ 'O').ERR2\n         L     &WREG,&TAG\n         L     &REG,0(,&WREG.)\n         MEXIT\n.X310    ANOP\n         L     &REG,&TAG\n         L     &REG,0(,&REG.)\n         MEXIT\n.X400    L     &REG,&FIELD              LOAD ADDR OF PARAMETER\n         MEXIT\n.ERR1    MNOTE 8,'Decimal self-defining terms are the only type of self$\n               -defining terms allowed'\n         MEXIT\n.ERR2    MNOTE 8,'WREG is required if R0,*ADDR is used'\n.MEXIT   MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##LA": {"ttr": 4355, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16X\\x00,\\x00,\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:58:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##LA  &REG,                    REGISTER TO LOAD               $\n               &FIELD                   FIELD TO LOAD\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1985.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##LA\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##LA\n.*\n.*  PURPOSE    INTERNAL MACRO USED BY PLIST AND CALLX MACRO.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    6/20/85 MGG - NEW\n.*              8/31/88 MGG - ADDED *ADDR SUPPORT                   @C1\n.*\n.*--------------------------------------------------------------------*\n         LCLC  &TAG                     WORK TAG\n         AIF   ('&FIELD' NE '').X100\n         SLR   &REG,&REG                NO PARAMETER SPECIFIED\n         MEXIT\n.X100    AIF   (T'&FIELD NE 'N').X200\n         AIF   ('&FIELD'(1,1) LT '0' OR '&FIELD'(1,1) GT '9').ERR1\n         LA    &REG,=F'&FIELD'          LOAD ADDR OF NUMERIC CONSTANT\n         MEXIT\n.X200    AIF   ('&FIELD'(1,1) NE '''').X300\n         LA    &REG,=C&FIELD            LOAD ADDR OF CHARACTER STRING\n         MEXIT\n.X300    AIF   ('&FIELD'(1,1) NE '*').X400                          @C1\n&TAG     SETC  '&FIELD'(2,K'&FIELD-1)                               @C1\n         L     &REG,&TAG                                            @C1\n         MEXIT                                                      @C1\n.X400    LA    &REG,&FIELD              LOAD ADDR OF PARAMETER      @C1\n         MEXIT\n.ERR1    MNOTE 8,'Decimal self-defining terms are the only type of self$\n               -defining terms allowed'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##LDBS": {"ttr": 4357, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16X\\x00_\\x00_\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:58:00", "lines": 95, "newlines": 95, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n&LABEL   ##LDBS &NAME,&BREGS,&DEFREG,&FRSTLD=NO\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1986.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##LDBS\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##LDBS\n.*\n.*  PURPOSE    INTERNAL MACRO USED TO LOAD BASE REGISTERS.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    2/14/86 - NEW  MGG\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#MCVREG\n         GBLA  &#MNDX                   MASTER TAG INDEX\n         GBLB  &#PBXA                   XA PROGRAM OPTION\n         GBLB  &#PB370                  370 PROGRAM OPTION\n         LCLC  &FRSTBS                  FIRST BASE REGISTER\n         LCLA  &NDX                     LOCAL TAG INDEX\n         LCLC  &TAG                     WORK TAG\n&#MNDX   SETA  &#MNDX+1                 INCREMENT MASTER TAG INDEX\n&NDX     SETA  &#MNDX                   SET MACROS LOCAL TAG INDEX\n         AIF   ('&FRSTLD' EQ 'NO').PRC0130\n         AIF   ('&NAME' EQ '*').PRC0200\n         AIF   ('&BREGS' EQ '').PRC0150\n&LABEL   LR    &BREGS(1),R15            LOAD SUBROUTINE BASE REGISTER\n         AGO   .PRC1000\n         MEXIT\n.PRC0130 AIF   ('&BREGS' NE '').PRC1000\n         USING &NAME,&DEFREG            ESTABLISH ADDRESSIBILITY\n         MEXIT\n.PRC0150 ANOP\n&LABEL   LR    &DEFREG,R15              LOAD SUBROUTINE BASE REGISTER\n         USING &NAME,&DEFREG            ESTABLISH SUBROUTINE BASE\n         MEXIT\n.PRC0200 AIF   ('&BREGS' EQ '').PRC0250\n         AIF   (NOT &#PB370 AND &#PBXA).PRC0210\n&LABEL   BALR  &BREGS(1),0              LOAD SUBROUTINE BASE REGISTER\n         AGO   .PRC1000\n.PRC0210 ANOP\n&LABEL   BASR  &BREGS(1),0              LOAD SUBROUTINE BASE REGISTER\n         AGO   .PRC1000\n.PRC0250 AIF   (NOT &#PB370 AND &#PBXA).PRC0260\n&LABEL   BALR  &DEFREG,0                LOAD SUBROUTINE BASE REGISTER\n         USING *,&DEFREG                ESTABLISH SUBROUTINE BASE\n&FRSTBS  SETC  '&DEFREG'\n         AGO   .PRC2000\n.PRC0260 ANOP\n&LABEL   BASR  &DEFREG,0                LOAD SUBROUTINE BASE REGISTER\n         USING *,&DEFREG                ESTABLISH SUBROUTINE BASE\n         MEXIT\n.PRC1000 ANOP\n&CTR     SETA  1\n&TAG     SETC  '&BREGS(1)'\n         AIF   ('&TAG' NE '').PRC1050\n&TAG     SETC  '&DEFREG'\n.PRC1050 ANOP\n&FRSTBS  SETC  '&BREGS(1)'\n         AIF   ('&FRSTLD' EQ 'NO').PRC1110\n.PRC1100 ##MREG USE,&BREGS(&CTR)\n.PRC1110 AIF   (N'&BREGS LE &CTR).PRC1200\n&TAG     SETC  '&TAG,&BREGS(&CTR+1)'\n&CTR     SETA  &CTR+1\n         AGO   .PRC1100\n.PRC1200 USING &NAME,&TAG               ESTABLISH SUBROUTINE BASE\n.PRC2000 AIF   (NOT &#PB370 OR NOT &#PBXA OR '&NAME' NE '*').PRC3000\n         AIF   ('&FRSTLD' EQ 'NO').PRC3000\n#LQ&NDX  ##SWREG R15\n         L     R15,X'10'                POINT R15 TO CVT\n         TM    X'74'(R15),X'80'         RUNNING ON XA?\n         BZ    #LR&NDX                  NO, SKIP NEXT 3 INSTRUCTIONS\n         BASR  &FRSTBS,0                LOAD FIRST BASE\n         LA    R15,*-#LQ&NDX            ADJUST TO SAME ADDRESS AS BALR\n         SLR   &FRSTBS,R15               INSTRUCTION PRODUCED\n#LR&NDX  ##RWREG R15\n.PRC3000 ANOP\n&CTR     SETA  1\n.PRC3100 AIF   (N'&BREGS LE &CTR).PRC3200\n&TAG     SETC  '&BREGS(&CTR+1),X''800''(,&BREGS(&CTR))'\n         LA    &TAG                     LOAD NEXT SUBROUTINE\n&TAG     SETC  '&BREGS(&CTR+1),X''800''(,&BREGS(&CTR+1))'\n         LA    &TAG                      BASE REGISTER\n&CTR     SETA  &CTR+1\n         AGO   .PRC3100\n.PRC3200 ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "##MODPFX": {"ttr": 4360, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16X\\x00\\x1e\\x00\\x1e\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:58:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##MODPFX &NAME,                NAME OF BLOCK                  $\n               &CPYRGHT                 COPYRIGHT NOTICE\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1990.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##MODPFX\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##MODPFX\n.*\n.*  PURPOSE    INTERNAL MACRO USED TO BUILD THE PREFIX OF A PROGRAM\n.*             BLOCK.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    2/04/90 MGG - NEW.\n.*\n.*--------------------------------------------------------------------*\n         DC    AL1(8+10+6)\n         DC    CL8'&NAME',CL10' &SYSDATE ',CL6'&SYSTIME'\n         AIF   ('&CPYRGHT' EQ '').BLD0010\n         DC    C&CPYRGHT\n.BLD0010 ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "##MREG": {"ttr": 4362, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16X\\x00L\\x00L\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:58:00", "lines": 76, "newlines": 76, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n&LABEL   ##MREG &TYPE,&REG\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1986.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##MREG\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##MREG\n.*\n.*  PURPOSE    INTERNAL MACRO USED TO KEEP UP WITH WHICH REGS ARE USED\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    2/14/86 - NEW  MGG\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#MCVREG\n         GBLB  &#REG(16)\n.*--------------------------------------------------------------------*\n.*  IF TYPE IS RESET,  INDICATE ALL BUT R13-R1 AS FREE.\n.*--------------------------------------------------------------------*\n         AIF   ('&TYPE' NE 'RESET').PRC1000\n&#REG(0+1)  SETB 1\n&#REG(1+1)  SETB 1\n&#REG(2+1)  SETB 0\n&#REG(3+1)  SETB 0\n&#REG(4+1)  SETB 0\n&#REG(5+1)  SETB 0\n&#REG(6+1)  SETB 0\n&#REG(7+1)  SETB 0\n&#REG(8+1)  SETB 0\n&#REG(9+1)  SETB 0\n&#REG(10+1) SETB 0\n&#REG(11+1) SETB 0\n&#REG(12+1) SETB 0\n&#REG(13+1) SETB 1\n&#REG(14+1) SETB 1\n&#REG(15+1) SETB 1\n            MEXIT\n.*--------------------------------------------------------------------*\n.*  IF TYPE IS USE, INDICATE REGISTER USED IF VALID AND NOT ALREADY\n.*  USED.\n.*--------------------------------------------------------------------*\n.PRC1000 AIF   ('&TYPE' NE 'USE').PRC2000\n         ##CVREG &REG\n         AIF   (&#MCVREG LE 15).PRC1020\n         MNOTE 8,'Register specification &REG is invalid'\n.PRC1020 AIF   (NOT &#REG(&#MCVREG+1)).PRC1040\n         MNOTE 8,'Register &REG specified multiple times'\n.PRC1040 ANOP\n&#REG(&#MCVREG+1) SETB 1                INDICATE REGISTER USED\n         MEXIT\n.*--------------------------------------------------------------------*\n.*  IF TYPE IS RELEASE,  INDICATE REGISTER IS NOT USED IF VALID.\n.*--------------------------------------------------------------------*\n.PRC2000 AIF   ('&TYPE' NE 'RELEASE').PRC3000\n         ##CVREG &REG\n         AIF   (&#MCVREG LE 15).PRC2020\n         MNOTE 8,'Register specification &REG is invalid'\n.PRC2020 AIF   (&#REG(&#MCVREG+1)).PRC2040\n         MNOTE 8,'Register &REG was not used - internal error'\n.PRC2040 ANOP\n&#REG(&#MCVREG+1) SETB 0                INDICATE REGISTER USED\n         MEXIT\n.*--------------------------------------------------------------------*\n.*  IF TYPE IS NOT ONE OF THE ABOVE, ISSUE ERROR MESSAGE.\n.*--------------------------------------------------------------------*\n.PRC3000 MNOTE 8,'Invalid type of &TYPE on ##MREG macro - internal erro$\n               r'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##ORGS": {"ttr": 4365, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16X\\x009\\x009\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:58:00", "lines": 57, "newlines": 57, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##ORGS &F,            ORGS FOR                                $\n               &C              WHEN CALLED FROM\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1985.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##ORGS\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##ORGS\n.*\n.*  PURPOSE    INTERNAL MACRO USED PRODUCE ORGS TO DETERMINE MAXIMUM\n.*             SWA STORAGE NEEDED\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    7/14/85 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#CSF(500)                CALLSUB FROM\n         GBLA  &#CSFF(99)                FIRST FOR SUBROUTINE FROM\n         GBLA  &#CSFT#N                  CALLSUB FROM/TO NEXT NUMBER\n         GBLA  &#CST(500)                CALLSUB TO\n         GBLA  &#CSVST(99)               SUBROUTINES VISITED\n         GBLC  &#SBNM(99)                SUBROUTINE NAMES\n         GBLA  &#SBORGC                  ORG COUNTER\n         GBLA  &#SBREC(99)               SUBROUTINE RECUR NUMBER\n         LCLA  &CTR                      LOCAL WORK VARIABLE\n         LCLC  &TAG                      LOCAL WORK TAG\n         MNOTE *,'For subroutine &#SBNM(&F)(&F) when called from subrou$\n               tine &#SBNM(&C)(&C)'\n&#CSVST(&F) SETA &#CSVST(&F)+1\n&CTR     SETA  &#CSFF(&F)\n         AIF   (&CTR EQ 0).FINISH\n&TAG     SETC  ''\n.LOOP    AIF   (&CTR GE &#CSFT#N).FINISH\n         AIF   (&#CSF(&CTR) NE &F).FINISH\n         AIF   (&#CST(&CTR) EQ &F).NEXT\n         AIF   (&#CSVST(&#CST(&CTR)) GT 1).NEXT\n         AIF   (&#CSVST(&#CST(&CTR)) EQ 1).PASTORG\n         AIF   ('&TAG' NE '').GENORG\n&TAG     SETC  '#SB$&#SBORGC'\n&#SBORGC SETA  &#SBORGC+1\n&TAG     EQU   *\n.GENORG  ORG   &TAG+#SBL&#CST(&CTR)*&#SBREC(&#CST(&CTR))\n.PASTORG ##ORGS &#CST(&CTR),&F\n.NEXT    ANOP\n&CTR     SETA  &CTR+1\n         AGO   .LOOP\n.FINISH  ANOP\n&#CSVST(&F) SETA &#CSVST(&F)-1\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##PEDC": {"ttr": 4367, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16X\\x00\\xaf\\x00\\xaf\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:58:00", "lines": 175, "newlines": 175, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##PEDC &RC,                  RETURN CODE KEYWORD              $\n               &R0,                   VALUE TO RETURN IN R0            $\n               &R1                    VALUE TO RETURN IN R1\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##PEDC\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##PEDC\n.*\n.*  PURPOSE    IDMS/DC EPILOG MACRO FOR PROGRAM BLOCKS.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   01/05/87 JCB - NEW\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#MNDX                   LAST TAG INDEX USED\n         GBLA  &#MLVL                   STRUCTURAL LEVEL\n         GBLA  &#BLVL                   BLOCK LEVEL\n         GBLA  &#BNDX(20)               BLOCK TAG INDEXS\n         GBLA  &#BMLVL(20)              BLOCK STRUCTURAL LEVEL\n         GBLC  &#BNAME(20)              BLOCK NAMES\n         GBLC  &#BTYPE(20)              BLOCK TYPE\n         GBLC  &#BAMODE(20)             ADDRESSING MODE OF BLOCK\n         GBLB  &#PBPWA                  PROGRAM BLOCK HAS PWA\n         GBLA  &#PBNDX                  PROGRAM BLOCK INDEX\n         GBLC  &#PBNAME                 PROGRAM BLOCK NAME\n         GBLB  &#PBXA                   XA OPTION\n         GBLB  &#PB370                  370 OPTION\n         GBLB  &#SBSWA                  SWA OPTION\n         GBLB  &#PBLOCR                 LOCTR OPTION\n         GBLB  &#SBSU                   SAVEUSING OPTION\n         GBLB  &#SBUSWA                 USERSWA OPTION\n         GBLA  &#SB#C                   CURRENT SUBROUTINE BLOCK NUM\n         GBLC  &#PBAMOD                 AMODE OF PROGRAM\n         GBLB  &#PBRTN0                 OPTION=RTNR0\n         GBLB  &#PBRTN1                 OPTION=RTNR1\n         GBLA  &#SBPLMX                 MAXIMUM PARMS IN SUBROUTINE\n         GBLB  &#SBCSTM                 CUSTOM SUBROUTINE BLOCK\n         GBLB  &#DC#RTN             DC: GENERATE A #RTN\n         GBLB  &#DC#RET             DC: GENERATE A #RETURN\n         GBLB  &#DCSYS              DC: SYSTEM MODE\n         GBLC  &#DCNTSK             DC: NXTTASK= FOR #RETURN\n         GBLC  &#DCRTYP             DC: RTNTYPE= FOR #RETURN\n         GBLC  &#DCRINT             DC: RESINT=  FOR #RETURN\n         GBLC  &#DCRPGM             DC: RESPGM=  FOR #RETURN\n         GBLC  &#DCPWAR             DC: FIRST REGISTER OF PWAREG=\n         GBLB  &#DCRENT             DC: RENT OPTION\n         GBLB  &#DCGSTK             DC: GETSTK OPTION\n         LCLC  &TAG,&TAG2,&TAG3         WORK TAGS\n         LCLC  &#RETOPS,&COMMA\n         LCLA  &CNT                     WORK COUNTER\n         LCLB  &SKIPRC\n         LCLB  &SKIPR0\n         LCLB  &SKIPR1\n&SKIPRC  SETB  0\n&SKIPR0  SETB  0\n&SKIPR1  SETB  0\n&TAG     SETC  ''\n&TAG2    SETC  ''\n&TAG3    SETC  ''\n.*--------------------------------------------------------------------*\n.*  ISSUE MESSAGE FOR IGNORED KEYWORD.\n.*--------------------------------------------------------------------*\n         AIF   (&#DC#RTN).PWA\n         ##IGMSG &RC,RC            IGNORE RC ONLY IF NO#RTN\n         ##IGMSG &R0,R0\n         ##IGMSG &R1,R1\n&SKIPRC  SETB  1\n.*====================================================================*\n.*  WORKING WITH PROGRAM WORK AREA.\n.*====================================================================*\n.PWA     ANOP\n&TAG     SETC  '#BQ&#PBNDX'\n&TAG2    SETC  '#BF&#PBNDX'\n.*\n.*  RTNR0 PROCESSING\n.*\n.RTNR000 AIF   (NOT &#DC#RTN).RCD0000\n         AIF   ('&R0' EQ '').RTNR100\n         AIF   (NOT &#PBRTN0).ERR0001\n         AIF   ('&R0'(1,1) NE '(').RTNR010\n&TAG3    SETC  'LR'\n         AGO   .RTNR020\n.RTNR010 ANOP\n&TAG3    SETC  'LA'\n.RTNR020 ANOP\n         &TAG3  R0,&R0\n.*\n.*  RTNR1 PROCESSING\n.*\n.RTNR100 AIF   ('&R1' EQ '').RCD0000\n         AIF   (NOT &#PBRTN1).ERR0002\n         AIF   ('&R1'(1,1) NE '(').RTNR110\n&TAG3    SETC  'LR'\n         AGO   .RTNR120\n.RTNR110 ANOP\n&TAG3    SETC  'LA'\n.RTNR120 ANOP\n         &TAG3  R1,&R1\n.*\n.RCD0000 ANOP\n         AIF   (&SKIPRC OR '&RC' EQ '').FRE0000\n         AIF   ('&RC' EQ '(R15)').FRE0000\n         AIF   ('&RC'(1,1) NE '(').RCD0010\n         LR    R15,&RC(1)               LOAD R15 WITH RETURN CODE\n         AGO   .FRE0000\n.RCD0010 AIF   ('&RC' NE '0').RCD0020\n         SLR   R15,R15                  SET RETURN CODE TO ZERO\n         AGO   .FRE0000\n.RCD0020 LA    R15,&RC                  LOAD RETURN CODE\n.FRE0000 ANOP\n&TAG     DS    0H\n         AIF   (NOT &#PBPWA OR NOT &#DCRENT).RET0000 IF NO PWA OBTAINED\n.*--------------------------------------------------------------------*\n.*  GENERATE CODE TO FREEMAIN PWA IF PWA WAS OBTAINED BY GETMAIN.\n.*--------------------------------------------------------------------*\n         AIF   (&SKIPRC OR '&RC' EQ '').FRE0010\n         LR    R2,R15                   SAVE RETURN CODE IN R2\n.FRE0010 ANOP\n         AIF   (&#DCGSTK).FRE0040       IF GETSTK USED, SKIP #FREESTG\n         AIF   ('&R0' EQ '' OR NOT &#DC#RTN).FRE0020\n         LR    R3,R0                    SAVE R0 VALUE\n.FRE0020 AIF   ('&R1' EQ '' OR NOT &#DC#RTN).FRE0030\n         LR    R4,R1                    SAVE R1 VALUE\n.FRE0030 ANOP\n         AIF   (&#DCSYS).FRE0035\n         #FREESTG ADDR=(&#DCPWAR)       FREEMAIN PWA\n         AGO   .FRE0040\n.FRE0035 ANOP\n         #FREESTG ADDR=(&#DCPWAR),RGSV=(R2-R8)   FREE PWA\n.FRE0040 ANOP\n         AIF   ('&R0' EQ '' OR NOT &#DC#RTN).FRE0050\n         LR    R0,R3                    RESTORE R0 VALUE\n.FRE0050 AIF   ('&R1' EQ '' OR NOT &#DC#RTN).FRE0060\n         LR    R4,R1                    RESTORE R1 VALUE\n.FRE0060 AIF   (&SKIPRC OR '&RC' EQ '').RET0000\n         LR    R15,R2                   RESTORE RETURN CODE\n.*--------------------------------------------------------------------*\n.*  #RETURN PROCESSING\n.*--------------------------------------------------------------------*\n.RET0000 ANOP\n         AIF   (NOT &#DC#RET).RTN0000\n         AIF   ('&#DCRTYP' NE '').RET0100\n&#DCRTYP SETC  'NORMAL'\n.RET0100 ANOP\n MNOTE *,'#RETURN NXTTASK=&#DCNTSK,TYPE=&#DCRTYP,RESINT=&#DCRINT,RESPGM*\n               =&#DCRPGM'\n         #RETURN NXTTASK=&#DCNTSK,TYPE=&#DCRTYP,RESINT=&#DCRINT,       *\n               RESPGM=&#DCRPGM\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.*  #RTN PROCESSING\n.*--------------------------------------------------------------------*\n.RTN0000 ANOP\n         AIF   (NOT &#DC#RTN).TAG0000\n&TAG2    DS    0H\n         #RTN\n         AGO   .EXIT\n.TAG0000 ANOP\n&TAG2    DS    0H\n.EXIT    MEXIT\n.ERR0001 MNOTE 8,'R0= invalid if option RTNR0 not specified'\n         AGO   .EXIT\n.ERR0002 MNOTE 8,'R1= invalid if option RTNR1 not specified'\n         AGO   .EXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##PEOS": {"ttr": 4371, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16X\\x00\\xff\\x00\\xff\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:58:00", "lines": 255, "newlines": 255, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##PEOS &RC,                  RETURN CODE KEYWORD              $\n               &R0,                   VALUE TO RETURN IN R0            $\n               &R1                    VALUE TO RETURN IN R1\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##PEOS\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##PEOS\n.*\n.*  PURPOSE    DEFAULT EPILOG MACRO FOR PROGRAM BLOCKS.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   12/29/86 MGG - BROKEN APART FROM ENDBLK AND RESTRUCTURED\n.*              4/23/86 MGG - ADDED REUSABLE PWA AND ESV SUPPORT    @C1\n.*              5/08/89 MGG - CHANGED &#PBWAID TAG TO &PWA          @C2\n.*              3/28/91 MGG - ADDED MANUALFREE OPTION SUPPORT       @C3\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#MNDX                   LAST TAG INDEX USED\n         GBLB  &#PBBR14                 BR14 OPTION FOR PROGRAM BLOCK\n         GBLB  &#PBDYN                  DYN OPTION\n         GBLB  &#PBGTMN                 SAVE AREA GETMAINED\n         GBLB  &#PBMAIN                 MAIN OPTION\n         GBLA  &#PBNDX                  PROGRAM BLOCK INDEX\n         GBLB  &#PBNRSV                 NORENT SAVE AREA IN PROGRAM BLK\n         GBLB  &#PBPWA                  PROGRAM BLOCK HAS PWA\n         GBLB  &#PBRTN0                 RETURN R0 OPTION\n         GBLB  &#PBRTN1                 RETURN R1 OPTION\n         GBLB  &#PBRPWA                 REUSABLE PWA OPTION         @C1\n         GBLB  &#PBMFRE                 REUSABLE PWA OPTION         @C3\n         GBLB  &#PBSAVE                 REGISTERS SAVED IN PROGRAM BLK\n         GBLB  &#PBESV                  ENVIRONMENT SUPPORT OPTION  @C1\n         GBLC  &PWA                     PROGRAM BLOCK WORK AREA ID  @C2\n         GBLA  &#PB#C                   NUMBER OF PROGRAM BLOCK     @C1\n         GBLA  &#PBPWAP                 REUSABLE PWA PARM NUMBER    @C1\n         LCLC  &TAG,&TAG2               WORK TAGS                   @C1\n.*--------------------------------------------------------------------*\n.*  ISSUE MESSAGE FOR IGNORED KEYWORD.\n.*--------------------------------------------------------------------*\n.* NONE\n.*--------------------------------------------------------------------*\n&TAG     SETC  '#BQ&#PBNDX'\n.*--------------------------------------------------------------------*\n.*  LOAD R15 WITH RETURN CODE.\n.*--------------------------------------------------------------------*\n         AIF   ('&RC' EQ '(R15)' OR '&RC' EQ '').PRC0020\n         AIF   ('&RC'(1,1) NE '(').PRC0012\n         LR    R15,&RC(1)               LOAD R15 WITH RETURN CODE\n         AGO   .PRC0020\n.PRC0012 AIF   ('&RC' NE '0').PRC0015\n         SLR   R15,R15                  SET RETURN CODE TO ZERO\n         AGO   .PRC0020\n.PRC0015 LA    R15,&RC                  LOAD RETURN CODE\n.PRC0020 ANOP\n.*--------------------------------------------------------------------*\n.*  LOAD R0 WITH VALUE TO RETURN IN R0\n.*--------------------------------------------------------------------*\n         AIF   ('&R0' EQ '').PRC0030\n         AIF   (&#PBRTN0).PRC0021\n         MNOTE 8,'R0 keyword can not be specified if option RTNR0 is no$\n               t in effect'\n.PRC0021 AIF   ('&R0' EQ '(R0)').PRC0030\n         AIF   ('&R0'(1,1) NE '(').PRC0022\n         LR    R0,&R0(1)                LOAD R0\n         AGO   .PRC0030\n.PRC0022 AIF   ('&R0' NE '0').PRC0025\n         SLR   R0,R0                    SET R0 TO ZERO\n         AGO   .PRC0030\n.PRC0025 LA    R0,&R0                   LOAD R0\n.PRC0030 ANOP\n.*--------------------------------------------------------------------*\n.*  LOAD R1 WITH VALUE TO RETURN IN R1\n.*--------------------------------------------------------------------*\n         AIF   ('&R1' EQ '').PRC0040\n         AIF   (&#PBRTN1).PRC0031\n         MNOTE 8,'R1 keyword can not be specified if option RTNR1 is no$\n               t in effect'\n.PRC0031 AIF   ('&R1' EQ '(R1)').PRC0040\n         AIF   ('&R1'(1,1) NE '(').PRC0032\n         LR    R1,&R1(1)                LOAD R1\n         AGO   .PRC0040\n.PRC0032 AIF   ('&R1' NE '0').PRC0035\n         SLR   R1,R1                    SET R1 TO ZERO\n         AGO   .PRC0040\n.PRC0035 LA    R1,&R1                   LOAD R1\n.*--------------------------------------------------------------------*\n.PRC0040 ANOP\n         AIF   (NOT &#PBPWA).PRC0100\n.*====================================================================*\n.*  WORKING WITH PROGRAM WORK AREA.\n.*====================================================================*\n.*--------------------------------------------------------------------*\n.*  IF NONREENTRENT PWA, JUST BACKLINK AND RESTORE REGISTERS.       @C1\n.*--------------------------------------------------------------------*\n         AIF   (NOT &#PBNRSV).PRC0045\n&TAG     L     R13,4(,R13)              BACKLINK\n&TAG     SETC  ''\n         AGO   .RST0000                 GO RESTORE REGISTERS\n.PRC0045 ANOP\n.*------------------------------------------------------------------@C1\n.*  IF THIS IS A REUSABLE PWA AND THE PWA IS NOT MARKED TO BE FREED,@C1\n.*  BACKLINK AND SKIP FREEMAIN CODE.  IF THIS IS A REUSABLE PWA THAT@C1\n.*  IS MARKED TO BE FREED, CLEAR THE ANCHOR AND DO NORMAL FREEMAIN  @C1\n.*  CODE.                                                           @C1\n.*------------------------------------------------------------------@C1\n&TAG2    SETC  ''                                                   @C1\n         AIF   (NOT &#PBRPWA).PRC0047                               @C3\n&TAG2    SETC  '#BF&#PBNDX'                                         @C1\n&TAG     L     R14,4(,R13)              LOAD R14 WITH BACKLINK      @C1\n         L     R14,24(,R14)             LOAD R14 WITH R1 AT ENTRY   @C1\n         L     R14,(&#PBPWAP-1)*4(,R14) POINT R14 TO PWA ANCHOR     @C1\n&TAG     SETC  '#BL&#PBNDX'                                         @C1\n         TM    0(R14),X'80'             IS PWA MARKED TO BE FREED?  @C1\n         BO    &TAG                     YES, CLEAR ANCHOR AND FREE  @C1\n         L     R13,4(,R13)              BACKLINK                    @C1\n         B     &TAG2                    SKIP FREEMAIN CODE          @C1\n&TAG     XC    0(4,R14),0(R14)          SET ANCHOR TO ZERO          @C1\n&TAG     SETC  ''                                                   @C1\n.PRC0047 AIF  (NOT &#PBMFRE).PRC0050    MANUALPWA OPTION            @C3\n&TAG2    SETC  '#BF&#PBNDX'                                         @C3\n&TAG     TM    &PWA.__F,&PWA.__F_FREEPWA                            @C3\n&TAG     SETC  '#BL&#PBNDX'                                         @C3\n         BO    &TAG                     YES, TIME TO FREE           @C3\n         L     R13,4(,R13)              BACKLINK                    @C3\n         B     &TAG2                    SKIP FREEMAIN CODE          @C3\n.PRC0050 ANOP                                                       @C3\n.*--------------------------------------------------------------------*\n.*  AS NEEDED, SAVE R0, R1, AND R15 IN OTHER REGISTERS.\n.*--------------------------------------------------------------------*\n&TAG     LR    R5,R15                   SAVE RETURN CODE IN R5      @C1\n&TAG     SETC  ''\n         AIF   (NOT &#PBRTN0).PRC0055\n         LR    R3,R0                    SAVE R0 IN R3\n.PRC0055 AIF   (NOT &#PBRTN1).PRC0056\n         LR    R4,R1                    SAVE R1 IN R4\n.PRC0056 ANOP\n.*--------------------------------------------------------------------*\n.*  GENERATE CODE TO FREEMAIN PWA IF PWA WAS OBTAINED BY GETMAIN.\n.*--------------------------------------------------------------------*\n         LR    R1,R13                   POINT R1 TO PWA\n         ICM   R0,B'1111',#BW&#PBNDX    LOAD R0 WITH LENGTH OF PWA\n         L     R13,4(,R13)              BACKLINK\n         AIF   (NOT &#PBDYN OR &#PBMAIN).PRC0070\n&TAG2    SETC  '#BF&#PBNDX'\n         TM    8(R13),X'80'             WAS DYNAMIC STORAGE USED?\n         BO    &TAG2                    YES, SKIP FREEMAIN\n.PRC0070 AIF   (&#PBESV).PRC0072                                    @C1\n         FREEMAIN R,LV=(0),A=(1)        FREEMAIN PWA\n         AGO   .PRC0074                                             @C1\n.PRC0072 ANOP                                                       @C1\n         L     R15,#PBL&#PB#C-&PWA.(,R1) POINT R15 TO ESV           @C2\n         L     R2,20(,R15)              LOAD USER PARM FOR FREEMAIN @C1\n         L     R15,16(,R15)             LOAD ADDRESS OF FREEMAIN    @C1\n         BALR  R14,R15                  DO FREEMAIN                 @C1\n.PRC0074 ANOP                                                       @C1\n.*--------------------------------------------------------------------*\n.*  AS NEEDED, RESTORE R0, R1, AND R15 FROM OTHER REGISTERS.\n.*--------------------------------------------------------------------*\n         LR    R15,R5                   RESTORE RETURN CODE         @C1\n         AIF   (NOT &#PBRTN0).PRC0075\n         LR    R0,R3                    RESTORE R0\n.PRC0075 AIF   (NOT &#PBRTN1).PRC0076\n         LR    R1,R4                    RESTORE R1\n.PRC0076 ANOP\n.*--------------------------------------------------------------------*\n.*  GO RESTORE REGISTERS.\n.*--------------------------------------------------------------------*\n         AIF   ('&TAG2' EQ '').RST0000\n&TAG2    DS    0H\n         AGO   .RST0000                 GO RESTORE REGISTERS\n.*--------------------------------------------------------------------*\n.PRC0100 AIF   (NOT &#PBGTMN).PRC0200\n.*====================================================================*\n.*  WORKING WITH A REENTRENT SAVE AREA THAT IS NOT A PWA.\n.*====================================================================*\n.*--------------------------------------------------------------------*\n.*  AS NEEDED, SAVE R0, R1, AND R15 IN OTHER REGISTERS.\n.*--------------------------------------------------------------------*\n&TAG     LR    R5,R15                   SAVE RETURN CODE IN R5      @C1\n         AIF   (NOT &#PBRTN0).PRC0155\n         LR    R3,R0                    SAVE R0 IN R3\n.PRC0155 AIF   (NOT &#PBRTN1).PRC0156\n         LR    R4,R1                    SAVE R1 IN R4\n.PRC0156 ANOP\n.*--------------------------------------------------------------------*\n.*  GENERATE CODE TO FREEMAIN SAVE AREA.\n.*--------------------------------------------------------------------*\n         LR    R1,R13                   POINT R1 TO SAVE AREA\n         LA    R0,18*4                  LOAD LENGTH OF SAVE AREA\n         L     R13,4(,R13)              BACKLINK\n         LR    R5,R15                   SAVE RETURN CODE IN R5      @C1\n         FREEMAIN R,LV=(0),A=(1)        FREEMAIN SAVE AREA\n.*--------------------------------------------------------------------*\n.*  AS NEEDED, RESTORE R0, R1, AND R15 FROM OTHER REGISTERS.\n.*--------------------------------------------------------------------*\n         LR    R15,R5                   RESTORE RETURN CODE         @C1\n         AIF   (NOT &#PBRTN0).PRC0175\n         LR    R0,R3                    RESTORE R0\n.PRC0175 AIF   (NOT &#PBRTN1).PRC0176\n         LR    R1,R4                    RESTORE R1\n.PRC0176 ANOP\n.*--------------------------------------------------------------------*\n         AGO   .RST0000                 GO RESTORE REGISTERS\n.*--------------------------------------------------------------------*\n.PRC0200 AIF   (NOT &#PBNRSV).PRC0300\n.*====================================================================*\n.*  WORKING WITH NONREENTRENT SAVE AREA.\n.*====================================================================*\n&TAG     L     R13,4(,R13)              BACKLINK\n         AGO   .RST0000                 GO RESTORE REGISTERS\n.PRC0300 ANOP\n.*====================================================================*\n.*  WORKING WITH NO SAVE AREA.\n.*====================================================================*\n&TAG     DS    0H\n         AGO   .RST0000\n.*====================================================================*\n.RST0000 ANOP\n.*--------------------------------------------------------------------*\n.* IF REGISTERS ARE SAVED, RESTORE REGISTERS.\n.*--------------------------------------------------------------------*\n         AIF   (NOT &#PBSAVE).RST9000\n         L     R14,12(,R13)             RESTORE R14\n         AIF   (&#PBRTN1).RST0100\n         AIF   (&#PBRTN0).RST0200\n         LM    R0,R12,20(R13)           RESTORE R0-R12\n         AGO   .RST9000\n.RST0100 AIF   (&#PBRTN0).RST0150\n         L     R0,20(,R13)              RESTORE R0\n         LM    R2,R12,28(R13)           RESTORE R2-R12\n         AGO   .RST9000\n.RST0150 LM    R2,R12,28(R13)           RESTORE R2-R12\n         AGO   .RST9000\n.RST0200 LM    R1,R12,24(R13)           RESTORE R1-R12\n.RST9000 ANOP\n.DBR0000 ANOP\n.*--------------------------------------------------------------------*\n.* DO BR14 IF REQUESTED.\n.*--------------------------------------------------------------------*\n         AIF   (NOT &#PBBR14).DBR0010\n         BR    R14                      RETURN TO CALLER\n.DBR0010 ANOP\n.*--------------------------------------------------------------------*\n.*  DECREMENT BLOCK LEVEL.\n.*--------------------------------------------------------------------*\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##PEPLI": {"ttr": 4613, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16X\\x00*\\x00*\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:58:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##PEPLI &RC,                 RETURN CODE KEYWORD              $\n               &R0,                   VALUE TO RETURN IN R0            $\n               &R1                    VALUE TO RETURN IN R1\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##PEPLI\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##PEPLI\n.*\n.*  PURPOSE    EPILOG MACRO FOR ASSEMBLER PROGRAMS THAT RUN IN THE\n.*             PL/I ENVIRONMENT.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    1/07/87 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#PBNDX                  PROGRAM BLOCK INDEX\n         LCLC  &TAG                     WORK TAG\n.*--------------------------------------------------------------------*\n.*  ISSUE MESSAGE FOR IGNORED KEYWORDS.\n.*--------------------------------------------------------------------*\n         ##IGMSG &R0,R0\n         ##IGMSG &R1,R1\n         ##IGMSG &RC,RC\n.*--------------------------------------------------------------------*\n.*  GENERATE CODE TO RETURN TO CALLER.\n.*--------------------------------------------------------------------*\n         SPACE\n&TAG     SETC  '#BQ&#PBNDX'\n&TAG     L     R13,4(,R13)              RELEASE CURRENT DSA\n         LM    R14,R12,12(R13)          RESTORE CALLER'S REGISTERS\n         BR    R14                      RETURN TO CALLER\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "##PLIST": {"ttr": 4615, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16X\\x00\\xfd\\x00\\xfd\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:58:00", "lines": 253, "newlines": 253, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##PLIST &PL=,&DS=              PARAMETER LIST\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1989.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##PLIST\n.*\n.*  TITLE      Clemson University Computer Center Structured\n.*             Programming Macros - ##PLIST\n.*\n.*  PURPOSE    Internal macro used to build parameter lists.\n.*\n.*  SYNTAX     ##PLIST START{,PL=TAG}{,DS=PWA|SWA|WA}\n.*             ##PLIST PARM,ADDR*\n.*             ##PLIST PLIST,(ADDR+)\n.*             ##PLIST END,VL|NOVL\n.*\n.*  NOTE       See the following document for more information on\n.*             this and other structured programming macros:\n.*\n.*             . Clemson University Computer Center Structured\n.*               Programming Macros User's Guide and Reference.\n.*\n.*  ACTIVITY    9/26/89 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &##PLIST__NUMBER_OF_PARAMETERS\n         GBLA  &#BLVL                   BLOCK LEVEL\n         GBLA  &#BMLVL(20)              BLOCK STRUCTURAL LEVEL\n         GBLA  &#BNDX(20)               BLOCK TAG INDEXS\n         GBLA  &#MNDX                   LAST TAG INDEX USED\n         GBLA  &#PB#C                   CURRENT PROGRAM BLOCK NUMBER\n         GBLA  &#PBPLMX                 MAXIMUM PL FOR PROGRAM\n         GBLA  &#SB#C                   CURRENT SUBROUTINE BLOCK NUMBER\n         GBLA  &#SBPLMX                 MAXIMUM PL FOR SUBROUTINE\n         GBLB  &##PLIST__STARTED\n         GBLB  &##PLIST__STD_PLIST\n         GBLC  &##PLIST__PL1            PL PARAMETER 1\n         GBLC  &##PLIST__PL2            PL PARAMETER 2\n         GBLC  &##PLIST__DS             DS PARAMETER\n         GBLB  &#PBDYN                  DYN OPTION FOR PROGRAM BLOCK\n         GBLB  &#PBPWA                  PWA OPTION FOR PROGRAM BLOCK\n         GBLB  &#PBVL                   VL OPTION\n         GBLB  &#PBXA                   XA OPTION\n         GBLB  &#PB370                  370 OPTION\n         GBLB  &#SBSWA                  SWA OPTION FOR SUBROUTINE BLOCK\n         GBLB  &#XAWARN                 XA WARNING MESSAGE ISSUED\n         GBLC  &#BAMODE(20)             ADDRESSING MODE OF BLOCK\n         GBLC  &#BNAME(20)              BLOCK NAMES\n         GBLC  &#BPL1(20)               BLOCK PL PARAMETER 1\n         GBLC  &#BPL2(20)               BLOCK PL PARAMETER 2\n         GBLC  &#BTYPE(20)              BLOCK TYPE\n         GBLC  &#PBAMOD                 AMODE OF PROGRAM\n         GBLC  &#PBSMWA                 TAG OF SMWA\n         LCLA  &CNT,&DISP               WORK VARIABLES\n.* Require at least type parameter.\n         AIF   (N'&SYSLIST GE 1).CHECK_10\n         MNOTE 8,'Missing TYPE parameter.'\n         MEXIT\n.CHECK_10 ANOP\n.*\n.* Process based on type.\n.*\n         AIF   ('&SYSLIST(1)' EQ 'START').START\n         AIF   ('&SYSLIST(1)' EQ 'PARM').PARM\n         AIF   ('&SYSLIST(1)' EQ 'PLIST').PLIST\n         AIF   ('&SYSLIST(1)' EQ 'END').END\n         MNOTE 8,'Invalid TYPE parameter - &SYSLIST(1)'\n         MEXIT\n.*\n.* Process type START.\n.*\n.START   ANOP\n&##PLIST__NUMBER_OF_PARAMETERS SETA 0\n&##PLIST__STD_PLIST            SETB 0\n         AIF   (N'&SYSLIST EQ 1).START_10\n         MNOTE 8,'Too many parameters for type START.'\n.START_10 AIF  (NOT &##PLIST__STARTED).START_20\n         MNOTE 8,'A parameter list build is already active.'\n         MEXIT\n.START_20 AIF  (N'&PL LE 2).START_30\n         MNOTE 8,'Too many parameters on PL keyword.'\n         MEXIT\n.START_30 ANOP\n&##PLIST__STARTED SETB 1\n&##PLIST__PL1 SETC '&PL(1)'\n&##PLIST__PL2 SETC '&PL(2)'\n&##PLIST__DS  SETC '&DS'\n.*   Process DS keyword.\n         AIF   ('&##PLIST__DS' EQ '').DS_OK\n.HAVE_DS AIF   ('&##PLIST__PL1' NE '').CHK_DS\n         MNOTE 8,'First operand of PL keyword is required if DS keyword$\n                is specified.'\n         MEXIT\n.CHK_DS  AIF   ('&##PLIST__DS' EQ 'PWA').DS_OK\n         AIF   ('&##PLIST__DS' EQ 'SWA').DS_OK\n         AIF   ('&##PLIST__DS' EQ 'WA').DS_OK\n         MNOTE 8,'&##PLIST__DS is not valid on the DS keyword.'\n         MEXIT\n.DS_OK   ANOP\n.*   Process PL keyword.\n         AIF   ('&PL' NE '').PL_LA\n&CNT     SETA  &#BLVL+1\n.PL_LOOP AIF   (&CNT LE 1).PL_STD\n&CNT     SETA  &CNT-1\n         AIF   ('&#BPL1(&CNT)' EQ '').PL_LOOP\n&##PLIST__PL1 SETC '&#BPL1(&CNT)'\n&##PLIST__PL2 SETC '&#BPL2(&CNT)'\n         AGO   .PL_LA\n.PL_STD  ANOP\n&##PLIST__STD_PLIST            SETB 1\n         AIF   (NOT &#PBPWA).PL_ERR\n         AIF   ('&#BTYPE(1)' EQ 'SUBROUTINE').PL_SUB\n         AIF   ('&#BTYPE(1)' EQ 'ERREXIT').PL_PROG\n         AIF   ('&#BTYPE(1)' EQ 'PROGRAM').PL_PROG\n.PL_ERR  MNOTE 8,'The PL keyword must be specified on this macro or on $\n               an enclosing BLOCK macro.'\n         MEXIT\n.PL_PROG ANOP\n&##PLIST__PL1 SETC '#PBP&#PB#C'\n         AGO   .PL_LA\n.PL_SUB  ANOP\n&##PLIST__PL1 SETC '#SBP&#SB#C'\n.PL_LA   LA    R1,&##PLIST__PL1         POINT R1 TO PARAMETER LIST\n         MEXIT\n.*\n.* Process type PARM.\n.*\n.PARM    AIF   (&##PLIST__STARTED).PARM_10\n         MNOTE 8,'A ##PLIST start must be specified first.'\n         MEXIT\n.PARM_10 ANOP\n&CTR     SETA  2\n&DISP    SETA  &##PLIST__NUMBER_OF_PARAMETERS*4\n.PRC2100 AIF   (&CTR GT N'&SYSLIST).PRC2900\n&##PLIST__NUMBER_OF_PARAMETERS SETA &##PLIST__NUMBER_OF_PARAMETERS+1\n         AIF   ('&SYSLIST(&CTR)' EQ '*').PRC2200\n         AIF   ('&SYSLIST(&CTR)' EQ '').PRC2150\n         AIF   ('&SYSLIST(&CTR)'(1,1) NE '(').PRC2150\n         ST    &SYSLIST(&CTR),&DISP.(,R1)\n         AGO   .PRC2200\n.PRC2150 ##LA  R14,&SYSLIST(&CTR)     LOAD ADDRESS OF PARAMETER.\n         ST    R14,&DISP.(,R1)        STORE ADDRESS IN PARAMETER LIST.\n.PRC2200 ANOP\n&DISP    SETA  &DISP+4\n&CTR     SETA  &CTR+1\n         AGO   .PRC2100\n.PRC2900 ANOP\n         MEXIT\n.*\n.* Process type PLIST.\n.*\n.PLIST   AIF   (&##PLIST__STARTED).PLIST_10\n         MNOTE 8,'A ##PLIST start must be specified first.'\n         MEXIT\n.PLIST_10 AIF  (N'&SYSLIST LE 2).PLIST_20\n         MNOTE 8,'Too many parameters for type PLIST.'\n.PLIST_20 ANOP\n&CTR     SETA  1\n&DISP    SETA  &##PLIST__NUMBER_OF_PARAMETERS*4\n.PRC3100 AIF   (&CTR GT N'&SYSLIST(2)).PRC3900\n&##PLIST__NUMBER_OF_PARAMETERS SETA &##PLIST__NUMBER_OF_PARAMETERS+1\n         AIF   ('&SYSLIST(2,&CTR)' EQ '*').PRC3200\n         AIF   ('&SYSLIST(2,&CTR)' EQ '').PRC3150\n         AIF   ('&SYSLIST(2,&CTR)'(1,1) NE '(').PRC3150\n         ST    &SYSLIST(2,&CTR),&DISP.(,R1)\n         AGO   .PRC3200\n.PRC3150 ##LA  R14,&SYSLIST(2,&CTR)   LOAD ADDRESS OF PARAMETER.\n         ST    R14,&DISP.(,R1)        STORE ADDRESS IN PARAMETER LIST.\n.PRC3200 ANOP\n&DISP    SETA  &DISP+4\n&CTR     SETA  &CTR+1\n         AGO   .PRC3100\n.PRC3900 ANOP\n         MEXIT\n.*\n.* Process type END.\n.*\n.END     AIF   (&##PLIST__STARTED).END_SOK\n         MNOTE 8,'A ##PLIST start must be specified first.'\n         MEXIT\n.END_SOK ANOP\n&##PLIST__STARTED SETB 0\n         AIF   (N'&SYSLIST EQ 1).DEFAULT_VL\n         AIF   (N'&SYSLIST EQ 2).END_NOK\n         MNOTE 8,'Too many parameters for type END.'\n.END_NOK AIF   ('&SYSLIST(2)' EQ 'VL').SET_VL\n         AIF   ('&SYSLIST(2)' EQ 'NOVL').PAST_VL\n         AIF   ('&SYSLIST(2)' EQ '').DEFAULT_VL\n         MNOTE 8,'Invalid VL parameter - &SYSLIST(2)..'\n.DEFAULT_VL AIF (NOT &#PBVL).PAST_VL\n.SET_VL  AIF   (&##PLIST__NUMBER_OF_PARAMETERS EQ 0).PAST_VL\n&DISP    SETA  &##PLIST__NUMBER_OF_PARAMETERS*4-4\n         OI    &DISP.(R1),X'80'       SET ON HIGH BIT.\n.PAST_VL ANOP\n         AIF   (&##PLIST__STD_PLIST).DS_STD\n         AIF   ('&##PLIST__DS' EQ 'WA').DS_WA\n         AIF   ('&##PLIST__DS' EQ 'PWA').DS_PWA\n         AIF   ('&##PLIST__DS' EQ 'SWA').DS_SWA\n         AIF   ('&##PLIST__DS' EQ '').DS_SPECIFIED\n         MNOTE 8,'Invalid DS value &DS.'\n         MEXIT\n.DS_STD  ANOP\n         AIF   ('&#BTYPE(1)' EQ 'SUBROUTINE').UPD_SWA_MX\n         AIF   (&#PBPLMX GE &##PLIST__NUMBER_OF_PARAMETERS).PAST_DS\n&#PBPLMX SETA   &##PLIST__NUMBER_OF_PARAMETERS\n         AGO   .PAST_DS\n.UPD_SWA_MX ANOP\n         AIF   (&#SBPLMX GE &##PLIST__NUMBER_OF_PARAMETERS).PAST_DS\n&#SBPLMX SETA  &##PLIST__NUMBER_OF_PARAMETERS\n         AGO   .PAST_DS\n.DS_WA   AIF   ('&#BTYPE(1)' EQ 'SUBROUTINE').DS_SWA\n.DS_PWA  AIF   ('&##PLIST__PL2' NE '').DS_PWA_20\n         PWA   TYPE=PARTIAL\n&##PLIST__PL1 DS (&##PLIST__NUMBER_OF_PARAMETERS.)F\n         ENDPWA\n         AGO   .PAST_DS\n.DS_PWA_20 AIF (&##PLIST__NUMBER_OF_PARAMETERS LE &##PLIST__PL2).DS_PWA+\n               _30\n         MNOTE 8,'There are more parameters than the number specified w+\n               ith the PL keyword.'\n.DS_PWA_30 ANOP\n         PWA   TYPE=PARTIAL\n&##PLIST__PL1 DS (&##PLIST__PL2.)F\n         ENDPWA\n         AGO   .PAST_DS\n.DS_SWA  AIF   ('&##PLIST__PL2' NE '').DS_SWA_20\n         SWA   TYPE=PARTIAL\n&##PLIST__PL1 DS (&##PLIST__NUMBER_OF_PARAMETERS.)F\n         ENDSWA\n         AGO   .PAST_DS\n.DS_SWA_20 AIF (&##PLIST__NUMBER_OF_PARAMETERS LE &##PLIST__PL2).DS_SWA+\n               _30\n         MNOTE 8,'There are more parameters than the number specified w+\n               ith the PL keyword.'\n.DS_SWA_30 ANOP\n         SWA   TYPE=PARTIAL\n&##PLIST__PL1 DS (&##PLIST__PL2.)F\n         ENDSWA\n         AGO   .PAST_DS\n.DS_SPECIFIED ANOP\n         AIF   ('&##PLIST__PL2' NE '').PL2_SPEC\n    AIF   (L'&##PLIST__PL1 GE &##PLIST__NUMBER_OF_PARAMETERS*4).PAST_DS\n         MNOTE 8,'&##PLIST__PL1 is not large enough for the number of p+\n               arameters specified.'\n         AGO   .PAST_DS\n.PL2_SPEC AIF  (&##PLIST__PL2 GE &##PLIST__NUMBER_OF_PARAMETERS).PAST_D+\n               S\n         MNOTE 8,'There are more parameters than the number specified w+\n               ith the PL keyword.'\n.PAST_DS ANOP\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##PPDC": {"ttr": 4620, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16X\\x02\\xb7\\x02\\xb7\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:58:00", "lines": 695, "newlines": 695, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##PPDC &NAME,                  NAME OF BLOCK                  $\n               &OPTIONS,                OPTIONS                        $\n               &SUBOPTS,                DEFAULT SUBROUTINE OPTIONS     $\n               &BASEREG,                BASE REGS                      $\n               &PWAREG,                 PWA REGS                       $\n               &SVAREA,                 SAVE AREA TAG NAME             $\n               &CPYRGHT,                COPYRIGHT NOTICE               $\n               &AMODE,                  ADDRESSING MODE                $\n               &RMODE,                  RESIDENCE MODE                 $\n               &R1SAVE,                 PARM SAVE REGISTER             $\n               &SMWA,                   STRUCTURED MACRO WORK AREA     $\n               &DYNSIZE,                SIZE OF DYNAMIC STORAGE        $\n               &DYNERR,                 DYNAMIC STORAGE ERROR EXIT     $\n               &SWAREG,                 SWA BASE REGS                  $\n               &PWASP                   PROGRAM WORK AREA SUB POOL\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1986.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##PPDC\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##PPDC\n.*\n.*  PURPOSE    INTERNAL MACRO USED AS THE DEFAULT FOR PROGRAM BLOCK\n.*             PROLOG.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   12/30/86 JCB - NEW, MODELED AFTER ##PPMAC\n.*             08/04/87 JCB - ADDED MISSING AIF FOR SMWA= CHECK    @C1\n.*             09/14/87 JCB - RELEASED R13 IF USER MODE PROGRAM    @C2\n.*             07/25/88 JCB - ADD (MPMODE,XXXXXX) OPTION FOR 10.2  @C3\n.*             05/08/89 MGG - REMOVED &SDID AND &WAID TAGS AND     @C4\n.*                            CHANGED &#PBWAID TAG TO &PWA.  ADDED @C4\n.*                            PSD TAG.                             @C4\n.*\n.*--------------------------------------------------------------------*\n.*  PROGRAM BLOCK OPTIONS SUPPORTED BY ##PPDC:\n.*      CSECT    - CAUSES CSECT TO BE GENERATED BY #MOPT\n.*      ID       - CAUSES ID TO BE GENERATED IN PROLOG\n.*      LOCTR    - STANDARD LOCTR OPTION\n.*      LONG     - STANDARD LONG OPTION\n.*      MODE     - STANDARD MODE OPTION\n.*      PWA      - ENABLES PWA GENERATION: WITH RENT, CAUSES #GETSTG\n.*      REGEQU   - CAUSES #REGEQU TO BE GENERATED BY #MOPT\n.*      RENT     - CAUSES REENTRANT LINKAGE (USED ONLY WITH PWA)\n.*      VL       - MAKES PLIST MACRO USE VL OPTION\n.*      XA       - USES XA INSTRUCTIONS FOR LINKAGE IF ASM'D ON XA\n.*      370      - USES 370 INSTRUCTIONS FOR LINKAGE IF ASM'D ON 370\n.* <DC> DCMACPRT - #MOPT MACPRNT=YES OR =NO\n.* <DC> DCPRGPRT - #MOPT PRGPRNT=YES OR =NO\n.* <DC> SYSTEM OR (SYSTEM,<MODULE#>) - #MOPT ENV=SYS AND OPT'L MODULE#\n.* <DC> #START   - GENERATE #START. ONLY VALID WITH SYSTEM\n.* <DC> #RTN     - GENERATE #RTN. ONLY VALID WITH SYSTEM\n.* <DC> #RETURN  - GENERATE #RETURN. ONLY VALID WITH NOSYSTEM\n.* <DC> GETSTK   - GENERATE #GETSTK INSTEAD OF #GETSTG. VALID ONLY\n.*                 WITH SYSTEM AND PWA OPTIONS\n.* <DC> (NXTTASK,<TASKCODE>) - #RETURN NXTTASK=. ONLY VALID W/NOSYSTEM\n.* <DC> (TYPE,<RTNTYPE>)     - #RETURN TYPE=.    ONLY VALID W/NOSYSTEM\n.* <DC> (RESINT,<INTERVAL>)  - #RETURN RESINT=.  ONLY VALID W/NOSYSTEM\n.* <DC> (RESPGM,<PGMNAME>)   - #RETURN RESPGM=.  ONLY VALID W/NOSYSTEM\n.* <DC> (EP,<ENTRYPOINT>)    - #START EP=.       ONLY VALID W/SYSTEM\n.* <DC> (MPMODE,<MPMODE>)    - #START MPMODE=    ONLY VALID W/SYSTEM.\n.*                                               NOTE THAT MPMODE WILL\n.*                                               NOT ASSEMBLE USING\n.*                                               IDMS RELEASE 10.0.\n.*\n.*  SUPER OPTIONS SUPPORTED BY ##PBDC:\n.*      *PWA     - CSECT,ID,LOCTR,MODE,PWA,REGEQU,RENT,VL,\n.*                 #RETURN\n.*      *PWASYS  - CSECT,ID,LOCTR,MODE,PWA,REGEQU,RENT,VL,\n.*                 #START,#RTN,SYSTEM\n.*      *RENT    - CSECT,ID,LOCTR,MODE,REGEQU,RENT,VL,#RETURN\n.*      *RENTSYS - CSECT,ID,LOCTR,MODE,REGEQU,RENT,VL,#START,#RTN,\n.*                 SYSTEM\n.*      *NORENT  - CSECT,ID,LOCTR,MODE,REGEQU,VL,#RETURN\n.*      *NORENTSYS - CSECT,ID,LOCTR,MODE,REGEQU,VL,#START,#RTN,\n.*                 SYSTEM\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#MNDX                   LAST TAG INDEX USED\n         GBLA  &#MLVL                   CURRENT STRUCTURAL LEVEL\n         GBLA  &#MCVREG                 CONVERTED REG (SEE ##CVREG)\n         GBLB  &##ASMH                  ##ASMH MACRO RETURN FLAG\n         GBLA  &#BLVL                   BLOCK LEVEL\n         GBLA  &#BNDX(20)               BLOCK TAG INDEXS\n         GBLA  &#BMLVL(20)              BLOCK STRUCTURAL LEVEL\n         GBLC  &#BNAME(20)              BLOCK NAMES\n         GBLC  &#BTYPE(20)              BLOCK TYPE\n         GBLC  &#BAMODE(20)             ADDRESSING MODE OF BLOCK\n         GBLC  &#BSV1(20)               BLOCK SAVE PARM 1\n         GBLC  &#BSV2(20)               BLOCK SAVE PARM 2\n         GBLC  &#BSV3(20)               BLOCK SAVE PARM 3\n         GBLA  &#PBNDX                  PROGRAM BLOCK INDEX\n         GBLC  &#PBNAME                 PROGRAM BLOCK NAME\n         GBLB  &#PBVL                   DEFAULT VL OPTION\n         GBLB  &#PBXA                   XA OPTION\n         GBLB  &#PB370                  370 OPTION\n         GBLC  &#PBRMOD                 RMODE OF PROGRAM\n         GBLC  &#PBAMOD                 AMODE OF PROGRAM\n         GBLC  &#PBSMWA                 TAG OF SMWA\n         GBLB  &#XAWARN                 XA WARNING MESSAGE ISSUED\n         GBLA  &#PB#C                   PROGRAM BLOCK NUMBER\n         GBLB  &#PBLONG                 LONG PROGRAM OPTION\n         GBLA  &#PBWAMX                 MAX SMWA IN PROGRAM\n         GBLB  &#PBLOCR                 DO LOCATR IN PROGRAM\n         GBLB  &#PBPWA                  PWA OPTION\n         GBLB  &#PBDSWA       ENDPWA SHOULD DEFINE STORAGE FOR PWA\n         GBLB  &#PBRTN0                 ENABLE RETURN_R0\n         GBLB  &#PBRTN1                 ENABLE RETURN_R1\n.*       GBLC  &#PBPWAT                 PWA TAG\n.*       GBLC  &#PBPWAL                 PWA LENGTH TAG\n         GBLC  &PWA                     GENERATED TAG OF PWA       @C4\n         GBLC  &PSD                     GENERATED TAG OF PSD       @C4\n         GBLB  &#DC#RTN             DC: #RTN SHOULD BE GEN'D\n         GBLB  &#DC#RET             DC: #RETURN SHOULD BE GEN'D\n         GBLB  &#DCSYS              DC: SYSTEM MODE REQUESTED\n         GBLC  &#DCNTSK             DC: NXTTASK= FOR #RETURN\n         GBLC  &#DCRTYP             DC: TYPE= FOR #RETURN\n         GBLC  &#DCRINT             DC: RESINT= FOR #RETURN\n         GBLC  &#DCRPGM             DC: RESPGM= FOR #RETURN\n         GBLB  &#DCRENT             DC: RENT OPTION\n         GBLC  &#DCPWAR             DC: 1ST PWA REGISTER (FOR #FREESTG)\n         GBLB  &#DCGSTK             DC: #GETSTK USED TO GET PWA\n         LCLB  &REGS(16)                REGISTERS USED\n         LCLB  &OID                     ID OPTION\n         LCLB  &OCSECT                  CSECT OPTION\n         LCLB  &OREGEQU                 REGEQU OPTION\n         LCLB  &OMODE                   MODE OPTION\n         LCLB  &ODCMACP                 #MOPT W/MACPRNT=YES\n         LCLB  &ODCPRGP                 #MOPT W/PRGPRNT=YES\n         LCLB  &#DC#STR             DC: #START SHOULD BE GENERATED\n         LCLA  &CTR                     WORK COUNTER\n         LCLA  &ZCTR\n         LCLC  &OPT,&TAG,&TAG1,&TAG2,&TAG3 WORK FIELDS\n         LCLC  &TAG4                    WORK TAG\n         LCLC  &ZENVIR\n         LCLC  &ZREGEQU\n         LCLC  &ZDCMACP\n         LCLC  &ZDCPRGP\n         LCLC  &ZMODNO\n         LCLC  &ZGINIT\n         LCLC  &ZGLOC\n         LCLA  &NDX                     #MNDX FOR BLOCK\n         LCLC  &EP\n         LCLC  &MPMODE                  MPMODE FROM OPTIONS         @C3\n.*====================================================================*\n&NDX     SETA  &#MNDX                   SET INDEX FOR BLOCK\n         ##MREG RESET                   RESET REGISTERS\n&#PBPWA  SETB  0                        CLEAR FLAGS\n&#PBXA   SETB  0\n&#PBDSWA SETB  0\n&#PB370  SETB  0\n&#PBVL   SETB  0\n&#PBLONG SETB  0\n&#PBLOCR SETB  0\n&#PBRMOD SETC  '&RMODE'\n&#PBAMOD SETC  '&AMODE'\n&#PBSMWA SETC  '&SMWA'\n&#BAMODE(1) SETC  '&AMODE'\n&#DC#STR SETB  0\n&#DC#RTN SETB  0\n&#DC#RET SETB  0\n&#DCSYS  SETB  0\n&#DCGSTK SETB  0\n&#DCNTSK SETC  ''\n&#DCRTYP SETC  ''\n&#DCRINT SETC  ''\n&#DCRPGM SETC  ''\n&EP      SETC  ''\n&MPMODE  SETC  ''                                                   @C3\n&ODCMACP SETB  0\n&ODCPRGP SETB  0\n.*--------------------------------------------------------------------*\n.*  CHECK FOR IGNORED KEYWORDS\n.*--------------------------------------------------------------------*\n         ##IGMSG &DYNSIZE,DYNSIZE\n         ##IGMSG &DYNERR,DYNERR\n         ##IGMSG &SVAREA,SVAREA\n         ##IGMSG &PWASP,PWASP\n.*--------------------------------------------------------------------*\n.*  SET OPTIONS FOR TYPE=PROGRAM\n.*--------------------------------------------------------------------*\n&CTR     SETA  1                        SET OPTIONS\n.SPO0010 AIF   (N'&OPTIONS LT &CTR).SPO9999\n&OPT     SETC  '&OPTIONS(&CTR)'\n.SPO0020 AIF   ('&OPT' NE 'PWA').SPO0030           PWA\n&#PBPWA  SETB  1\n         AGO   .SPO9000\n.SPO0030 AIF   ('&OPT' NE 'NOPWA').SPO0100         NOPWA\n&#PBPWA  SETB  0\n         AGO   .SPO9000\n.SPO0100 AIF   ('&OPT' NE 'RENT').SPO0110          RENT\n&#DCRENT SETB  1\n         AGO   .SPO9000\n.SPO0110 AIF   ('&OPT' NE 'NORENT').SPO0120        NORENT\n&#DCRENT SETB  0\n         AGO   .SPO9000\n.SPO0120 AIF   ('&OPT' NE 'ID').SPO0130            ID\n&OID     SETB  1\n         AGO   .SPO9000\n.SPO0130 AIF   ('&OPT' NE 'NOID').SPO0140          NOID\n&OID     SETB  0\n         AGO   .SPO9000\n.SPO0140 AIF   ('&OPT' NE 'REGEQU').SPO0150        REGEQU\n&OREGEQU SETB  1\n         AGO   .SPO9000\n.SPO0150 AIF   ('&OPT' NE 'NOREGEQU').SPO0160      NOREGEQU\n&OREGEQU SETB  0\n         AGO   .SPO9000\n.SPO0160 AIF   ('&OPT' NE 'CSECT').SPO0170         CSECT\n&OCSECT  SETB  1\n         AGO   .SPO9000\n.SPO0170 AIF   ('&OPT' NE 'NOCSECT').SPO0200       NOCSECT\n&OCSECT  SETB  0\n         AGO   .SPO9000\n.SPO0200 AIF   ('&OPT' NE '*RENT').SPO0205         SUPER *RENT\n&#PBPWA  SETB  0         NOPWA OPTION\n&#DC#RET SETB  1         #RETURN OPTION\n&#DCRENT SETB  1         RENT OPTION\n&OID     SETB  1         ID OPTION\n&OCSECT  SETB  1         CSECT OPTION\n&OREGEQU SETB  1         REGEQU OPTION\n&OMODE   SETB  1         MODE OPTION\n&#PBXA   SETB  0         NOXA OPTION\n&#PB370  SETB  0         NO370 OPTION\n&#PBVL   SETB  1         VL OPTION\n&#PBLOCR SETB  1         LOCTR OPTION\n&#PBLONG SETB  0         NOLONG OPTION\n         AGO   .SPO9000\n.SPO0205 AIF   ('&OPT' NE '*RENTSYS').SPO0210      SUPER *RENTSYS\n&#PBPWA  SETB  0         NOPWA OPTION\n&#DC#STR SETB  1         #START OPTION\n&#DC#RTN SETB  1         #RTN OPTION\n&#DCRENT SETB  1         RENT OPTION\n&OID     SETB  1         ID OPTION\n&OCSECT  SETB  1         CSECT OPTION\n&OREGEQU SETB  1         REGEQU OPTION\n&OMODE   SETB  1         MODE OPTION\n&#PBXA   SETB  0         NOXA OPTION\n&#PB370  SETB  0         NO370 OPTION\n&#PBVL   SETB  1         VL OPTION\n&#PBLOCR SETB  1         LOCTR OPTION\n&#PBLONG SETB  0         NOLONG OPTION\n&#DCSYS  SETB  1         SYSTEM OPTION\n         AGO   .SPO9000\n.SPO0210 AIF   ('&OPT' NE '*PWA').SPO0215          SUPER *PWA\n&#PBPWA  SETB  1         PWA OPTION\n&#DC#RET SETB  1         #RETURN OPTION\n&#DCRENT SETB  1         RENT OPTION\n&OID     SETB  1         ID OPTION\n&OCSECT  SETB  1         CSECT OPTION\n&OREGEQU SETB  1         REGEQU OPTION\n&OMODE   SETB  1         MODE OPTION\n&#PBXA   SETB  0         NOXA OPTION\n&#PB370  SETB  0         NO370 OPTION\n&#PBVL   SETB  1         VL OPTION\n&#PBLOCR SETB  1         LOCTR OPTION\n&#PBLONG SETB  0         NOLONG OPTION\n         AGO   .SPO9000\n.SPO0215 AIF   ('&OPT' NE '*PWASYS').SPO0220       SUPER *PWASYS\n&#PBPWA  SETB  1         PWA OPTION\n&#DC#STR SETB  1         #START OPTION\n&#DC#RTN SETB  1         #RTN OPTION\n&#DCRENT SETB  1         RENT OPTION\n&OID     SETB  1         ID OPTION\n&OCSECT  SETB  1         CSECT OPTION\n&OREGEQU SETB  1         REGEQU OPTION\n&OMODE   SETB  1         MODE OPTION\n&#PBXA   SETB  0         NOXA OPTION\n&#PB370  SETB  0         NO370 OPTION\n&#PBVL   SETB  1         VL OPTION\n&#PBLOCR SETB  1         LOCTR OPTION\n&#PBLONG SETB  0         NOLONG OPTION\n&#DCSYS  SETB  1         SYSTEM OPTION\n         AGO   .SPO9000\n.SPO0220 AIF   ('&OPT' NE '*NORENT').SPO0225       SUPER *NORENT\n&#PBPWA  SETB  0         NOPWA OPTION\n&#DC#RET SETB  1         #RETURN OPTION\n&#DCRENT SETB  0         NORENT OPTION\n&OID     SETB  1         ID OPTION\n&OCSECT  SETB  1         CSECT OPTION\n&OREGEQU SETB  1         REGEQU OPTION\n&OMODE   SETB  1         MODE OPTION\n&#PBXA   SETB  0         NOXA OPTION\n&#PB370  SETB  0         NO370 OPTION\n&#PBVL   SETB  1         VL OPTION\n&#PBLOCR SETB  1         LOCTR OPTION\n&#PBLONG SETB  0         NOLONG OPTION\n         AGO   .SPO9000\n.SPO0225 AIF   ('&OPT' NE '*NORENTSYS').SPO0230    SUPER *NORENTSYS\n&#PBPWA  SETB  0         NOPWA OPTION\n&#DC#STR SETB  1         #START OPTION\n&#DC#RTN SETB  1         #RTN OPTION\n&#DCRENT SETB  0         NORENT OPTION\n&OID     SETB  1         ID OPTION\n&OCSECT  SETB  1         CSECT OPTION\n&OREGEQU SETB  1         REGEQU OPTION\n&OMODE   SETB  1         MODE OPTION\n&#PBXA   SETB  0         NOXA OPTION\n&#PB370  SETB  0         NO370 OPTION\n&#PBVL   SETB  1         VL OPTION\n&#PBLOCR SETB  1         LOCTR OPTION\n&#PBLONG SETB  0         NOLONG OPTION\n&#DCSYS  SETB  1         SYSTEM OPTION\n         AGO   .SPO9000\n.SPO0230 AIF   ('&OPT' NE 'MODE').SPO0240          MODE\n&OMODE   SETB  1\n         AGO   .SPO9000\n.SPO0240 AIF   ('&OPT' NE 'NOMODE').SPO0250        NOMODE\n&OMODE   SETB  0\n         AGO   .SPO9000\n.SPO0250 AIF   ('&OPT' NE 'XA').SPO0260            XA\n&#PBXA   SETB  1\n         AGO   .SPO9000\n.SPO0260 AIF   ('&OPT' NE 'NOXA').SPO0270          NOXA\n&#PBXA   SETB  0\n         AGO   .SPO9000\n.SPO0270 AIF   ('&OPT' NE '370').SPO0280           370\n&#PB370  SETB  1\n         AGO   .SPO9000\n.SPO0280 AIF   ('&OPT' NE 'NO370').SPO0290         NO370\n&#PB370  SETB  0\n         AGO   .SPO9000\n.SPO0290 AIF   ('&OPT' NE 'VL').SPO0300            VL\n&#PBVL   SETB  1\n         AGO   .SPO9000\n.SPO0300 AIF   ('&OPT' NE 'NOVL').SPO0390          NOVL\n&#PBVL   SETB  0\n         AGO   .SPO9000\n.SPO0390 AIF   ('&OPT' NE 'LOCTR').SPO0400         LOCTR\n&#PBLOCR SETB  1\n         AGO   .SPO9000\n.SPO0400 AIF   ('&OPT' NE 'NOLOCTR').SPO0410       NOLOCTR\n&#PBLOCR SETB  0\n         AGO   .SPO9000\n.SPO0410 AIF   ('&OPT' NE 'LONG').SPO0420          LONG\n&#PBLONG SETB  1\n         AGO   .SPO9000\n.SPO0420 AIF   ('&OPT' NE 'NOLONG').SPO0490        NOLONG\n&#PBLONG SETB  0\n         AGO   .SPO9000\n.*------------------------------------------------------------------\n.*  IDMS/DC SPECIFIC OPTIONS\n.*------------------------------------------------------------------\n.SPO0490 AIF   ('&OPT' NE 'DCMACPRT').SPO0500      DCMACPRT\n&ODCMACP SETB  1\n         AGO   .SPO9000\n.SPO0500 AIF   ('&OPT' NE 'NODCMACPRT').SPO0510    NODCMACPRT\n&ODCMACP SETB  0\n         AGO   .SPO9000\n.SPO0510 AIF   ('&OPT' NE 'DCPRGPRT').SPO0520      DCPRGPRT\n&ODCPRGP SETB  1\n         AGO   .SPO9000\n.SPO0520 AIF   ('&OPT' NE 'NODCPRGPRT').SPO0530    NODCPRGPRT\n&ODCPRGP SETB  0\n         AGO   .SPO9000\n.SPO0530 AIF   ('&OPT' NE '#START').SPO0540        #START\n&#DC#STR SETB  1\n         AGO   .SPO9000\n.SPO0540 AIF   ('&OPT' NE 'NO#START').SPO0550      NO#START\n&#DC#STR SETB  0\n         AGO   .SPO9000\n.SPO0550 AIF   ('&OPT' NE '#RTN').SPO0560          #RTN\n&#DC#RTN SETB  1\n         AGO   .SPO9000\n.SPO0560 AIF   ('&OPT' NE 'NO#RTN').SPO0570        NO#RTN\n&#DC#RTN SETB  0\n         AGO   .SPO9000\n.SPO0570 AIF   ('&OPT' NE '#RETURN').SPO0580       #RETURN\n&#DC#RET SETB  1\n         AGO   .SPO9000\n.SPO0580 AIF   ('&OPT' NE 'NO#RETURN').SPO0590     NO#RETURN\n&#DC#RET SETB  0\n         AGO   .SPO9000\n.SPO0590 AIF   ('&OPT' NE 'SYSTEM').SPO0600        SYSTEM OR\n&#DCSYS  SETB  1                                     (SYSTEM,MODULE#)\n         AIF   (N'&OPT EQ 1).SPO0595\n&ZMODNO  SETC  '&OPT(2)'\n         AGO   .SPO9000\n.SPO0595 ANOP\n&ZMODNO  SETC   '0'\n         AGO   .SPO9000\n.SPO0600 AIF   ('&OPT' NE 'NOSYSTEM').SPO0610      NOSYSTEM\n&#DCSYS  SETB  0\n         AGO   .SPO9000\n.SPO0605 ANOP\n&ZMODNO  SETC   '0'\n         AGO   .SPO9000\n.SPO0610 AIF   ('&OPT' NE 'GETSTK').SPO0615       GETSTK\n&#DCGSTK SETB  1\n         AGO   .SPO9000\n.SPO0615 AIF   ('&OPT' NE 'NOGETSTK').SPO0620     NOGETSTK\n&#DCGSTK SETB  0\n         AGO   .SPO9000\n.SPO0620 AIF   ('&OPT' NE 'RTNR0').SPO0625        RTNR0\n&#PBRTN0 SETB  1\n         AGO   .SPO9000\n.SPO0625 AIF   ('&OPT' NE 'NORTNR0').SPO0630      NORTNR0\n&#PBRTN0 SETB  0\n         AGO   .SPO9000\n.SPO0630 AIF   ('&OPT' NE 'RTNR1').SPO0635        RTNR1\n&#PBRTN1 SETB  1\n         AGO   .SPO9000\n.SPO0635 AIF   ('&OPT' NE 'NORTNR1').SPO0800      NORTNR1\n&#PBRTN1 SETB  0\n         AGO   .SPO9000\n.*------------------------------------------------------------------\n.*  SUBSCRIPTED OPTIONS: FIRST, PARSE OPTION STRINGS\n.*------------------------------------------------------------------\n.SPO0800 AIF   ('&OPT'(1,1) NE '(').SPO1000\n&ZCTR    SETA  2                                 SET TO 2 TO SKIP '('\n&TAG     SETC  ''                                SET TO NULL TO START\n.SPO0810 AIF   ('&OPT'(&ZCTR,1) EQ ',').SPO0820  COMMA? GET 2ND OPERAND\n         AIF   ('&OPT'(&ZCTR,1) EQ ')').SPO5000  ')' - ERROR.\n&TAG3    SETC  '&OPT'(&ZCTR,1)                   GET OPERAND 1 BYTE\n&TAG     SETC  '&TAG&TAG3'                       CONCAT TO 'TAG'\n&ZCTR    SETA  &ZCTR+1                           NEXT BYTE\n         AGO   .SPO0810                           TIL WE HIT A DELIM.\n.SPO0820 ANOP  ,                                 GET 2ND OPERAND:\n&ZCTR    SETA  &ZCTR+1                           SKIP OVER COMMA\n&TAG2    SETC  ''                                SET TO NULL TO START\n.SPO0830 AIF   ('&OPT'(&ZCTR,1) EQ ')').SPO0900  ')' - WE'RE DONE.\n         AIF   ('&OPT'(&ZCTR,1) EQ ',').SPO5000  ',' - ERROR.\n&TAG3    SETC  '&OPT'(&ZCTR,1)                   GET OPERAND 2 BYTE\n&TAG2    SETC  '&TAG2&TAG3'                      CONCAT TO 'TAG2'\n&ZCTR    SETA  &ZCTR+1                           NEXT BYTE\n         AGO   .SPO0830                           TIL WE HIT A DELIM.\n.*------------------------------------------------------------------\n.*  PROCESS SUBSCRIPTED OPTIONS\n.*------------------------------------------------------------------\n.SPO0900 ANOP\n         AIF   ('&TAG' NE 'NXTTASK').SPO0910    (NXTTASK,ADDRESS)\n&#DCNTSK SETC  '&TAG2'\n         AGO   .SPO9000\n.SPO0910 AIF   ('&TAG' NE 'TYPE').SPO0920       (TYPE,RTNTYPE)\n&#DCRTYP SETC  '&TAG2'\n         AGO   .SPO9000\n.SPO0920 AIF   ('&TAG' NE 'RESINT').SPO0930     (RESINT,INTERVAL)\n&#DCRINT SETC  '&TAG2'\n         AGO   .SPO9000\n.SPO0930 AIF   ('&TAG' NE 'RESPGM').SPO0940     (RESPGM,PGMNAME)\n&#DCRPGM SETC  '&TAG2'\n         AGO   .SPO9000\n.SPO0940 AIF   ('&TAG' NE 'EP').SPO0950\n&EP      SETC  '&TAG2'\n         AGO   .SPO9000\n.SPO0950 AIF   ('&TAG' NE 'MPMODE').SPO1000                         @C3\n&MPMODE  SETC  '&TAG2'                                              @C3\n         AGO   .SPO9000                                             @C3\n.SPO1000 ANOP  ,                                ADD'L OPTIONS HERE\n.SPO5000 MNOTE 8,'Invalid option &OPT'\n.SPO9000 ANOP\n&CTR     SETA  &CTR+1\n         AGO   .SPO0010\n.SPO9999 ANOP\n.*------------------------------------------------------------------\n.*  SET DEFAULT SUBROUTINE OPTIONS BASED ON SUBOPT\n.*------------------------------------------------------------------\n         ##SUBOPT &SUBOPTS,DEFAULT=YES\n.*------------------------------------------------------------------\n.*  CHECK OPTIONS\n.*------------------------------------------------------------------\n         AIF   ('&#PBSMWA' NE '' OR NOT &#PBPWA).COP0050            @C1\n&#PBWAMX SETA  2\n&#PBSMWA SETC  '#PBW&#PB#C'\n.COP0050 AIF   (NOT &#PBLOCR).COP0060\n         ##ASMH ((A))\n         AIF   (&##ASMH).COP0060\n         MNOTE 8,'Assembler H required for LOCTR option'\n.* .COP0060 AIF   ('&#BNAME(&#BLVL)' EQ '').ERR0003\n.COP0060 AIF   (NOT &#DCSYS).NSYS000\n.*--------------------------------------------------------------------*\n.*  OPTIONS NOT ALLOWED WITH SYSTEM MODE\n.*--------------------------------------------------------------------*\n         AIF   (&#DC#RET).ERR0012\n         AIF   ('&#DCNTSK' NE '' OR '&#DCRTYP' NE '').ERR0010\n         AIF   ('&#DCRINT' NE '' OR '&#DCRPGM' NE '').ERR0010\n         AIF   ('&MPMODE' NE '' AND NOT &#DC#STR).ERR0017           @C3\n         AGO   .COP0070\n.*--------------------------------------------------------------------*\n.*  OPTIONS NOT ALLOWED WITH NOSYSTEM MODE\n.*--------------------------------------------------------------------*\n.NSYS000 AIF   (&#DC#STR OR &#DC#RTN).ERR0011\n         AIF   ('&EP' NE '').ERR0013\n         AIF   ('&MPMODE' NE '').ERR0017                            @C3\n         AIF   (&#DCGSTK).ERR0015\n.COP0070 AIF   (&#DCGSTK AND NOT &#PBPWA).ERR0016\n.*--------------------------------------------------------------------*\n.*  GENERATE CSECT, AMODE, AND RMODE CARDS\n.*--------------------------------------------------------------------*\n.CAR0100 AIF   ('&AMODE' EQ '' AND '&RMODE' EQ '').CAR0200\n         AIF   (&OMODE).CAR0110\n         MNOTE 4,'RMODE and AMODE ignored if MODE option not specified'\n         AGO   .CAR0200\n.CAR0110 AIF   (&#PBXA).CAR0120\n         MNOTE 4,'RMODE and AMODE ignored if XA option not specified'\n         AGO   .CAR0200\n.CAR0120 AIF   ('&AMODE' EQ '' AND '&RMODE' EQ '').CAR0200  DEFAULTS\n         AIF   ('&RMODE' EQ 'ANY' AND '&AMODE' EQ '24').ERR0014\n         AIF   ('&RMODE' EQ '').CAR0130\n&#PBRMOD SETC  '&RMODE'\n         AGO   .CAR0140\n.CAR0130 ANOP\n&#PBRMOD SETC  '24'\n.CAR0140 AIF   ('&AMODE' EQ '').CAR0150\n&#PBAMOD SETC  '&AMODE'\n         AGO   .CAR0900\n.CAR0150 ANOP\n&#PBAMOD SETC  '24'\n         AGO   .CAR0900\n.CAR0200 ANOP  ,             DEFAULT BOTH AMODE AND RMODE\n&#PBRMOD SETC  '24'\n&#PBAMOD SETC  '24'\n.CAR0900 ANOP\n.*--------------------------------------------------------------------*\n.*  GENERATE CSECT, REGEQU, ETC. AS REQUESTED\n.*--------------------------------------------------------------------*\n.MOP0000 ANOP\n&ZCSECT  SETC  '&NAME'\n         AIF   (NOT &#DCSYS).MOP0005     SET #MOPT ENVIR=\n&ZENVIR  SETC  'SYS'\n         AGO   .MOP0010\n.MOP0005 ANOP\n&ZENVIR  SETC  'USER'\n.MOP0010 ANOP                            SET #MOPT REGS=\n&ZREGEQU SETC  'NO'\n.MOP0020 AIF   (NOT &ODCMACP).MOP0025 SET #MOPT MACPRNT=\n&ZDCMACP SETC  'ON'\n         AGO   .MOP0030\n.MOP0025 ANOP\n&ZDCMACP SETC  'OFF'\n.MOP0030 AIF   (NOT &ODCPRGP).MOP0035 SET MOPT PRGPRNT=\n&ZDCPRGP SETC  'ON'\n         AGO   .MOP0040\n.MOP0035 ANOP\n&ZDCPRGP SETC  'OFF'\n.MOP0040 ANOP\n&ZREGEQU SETC  'NO'\n         AIF   (NOT &OCSECT).MOP0050\n&ZCSECT  CSECT ,\n.MOP0050 ANOP\n         AIF   (&#DCSYS).MOP0060                                   @C2\n         ##MREG RELEASE,R13                                        @C2\n.MOP0060 ANOP  ,                                                   @C2\n         #MOPT CSECT=,ENV=&ZENVIR,REGS=&ZREGEQU,                       X\n               MACPRNT=&ZDCMACP,PRGPRNT=&ZDCPRGP,                      X\n               AMODE=&#PBAMOD,RMODE=&#PBRMOD,MODNO=&ZMODNO\n         AIF   (NOT &OREGEQU).LOC0000\n         ##REGS\n.*--------------------------------------------------------------------*\n.* GENERATE LOCTR IF LOCTR OPTION SPECIFIED\n.*--------------------------------------------------------------------*\n.LOC0000 AIF   (NOT &#PBLOCR).CAR0105\n&NAME    LOCTR ,                        LOCTR FOR PROGRAM BLOCK INST\n         PSD   TYPE=PARTIAL\n&PSD     EQU   *                                                   &C4\n         ENDPSD ,\n.*--------------------------------------------------------------------*\n.*  GENERATE INITIAL CODE TO COPY R15 AND SET 1ST PROGRAM BASE\n.*--------------------------------------------------------------------*\n         AIF   (NOT &#DC#STR).STR0050\n         AIF   ('&EP' NE '').STR0010\n&TAG     SETC  '#ST&#PB#C'\n         AGO   .STR0020\n.STR0010 ANOP\n&TAG     SETC   '&EP'\n.STR0020 ANOP\n         AIF   ('&MPMODE' NE '').STR0025                            @C3\n&TAG     #START\n         AGO   .IDC0000\n.STR0025 ANOP  ,                                                    @C3\n&TAG     #START MPMODE=&MPMODE                                      @C3\n         AGO   .IDC0000                                             @C3\n.STR0050 AIF   (&#DCSYS).ERR0009\n         LR    R12,R15\n         ##LDBS &NAME,&BASEREG,R12\n.*--------------------------------------------------------------------*\n.*  GENERATE CONSTANTS AND SAVE REGISTERS\n.*--------------------------------------------------------------------*\n.IDC0000 AIF   (NOT &OID AND '&CPYRGHT' EQ '').CNS0190\n         B     #BP&NDX                  BRANCH PAST CONSTANTS\n         AIF   (NOT &OID).IDC0050             GENERATE ID\n         DC    C'&NAME &SYSDATE &SYSTIME '\n.IDC0050 AIF   ('&CPYRGHT' EQ '').CNS0190     GENERATE COPYRIGHT\n         DC    C&CPYRGHT\n.CNS0190 ANOP\n#BP&NDX  DS     0H\n.CNS0200 AIF   (NOT &#PBPWA).CNS0900\n         AIF   (&#DCRENT).CNS0900        GENERATE NORENT PWA?\n&TAG     SETC  '#BJ&NDX'\n&TAG2    SETC  '#PBJ&#PB#C'\n&TAG     DC    AL4(&TAG2)                ADDRESS OF PWA STORAGE\n.CNS0900 ANOP\n.*--------------------------------------------------------------------*\n.*  SAVE R1 IN REGISTER SPECIFIED ON R1SAVE=\n.*--------------------------------------------------------------------*\n         AIF   (NOT &#DCSYS).RPB0010    SYSTEM MODE RESERVED REGS?\n         ##MREG USE,R9                  INDICATE R9  USED FOR TCE\n         ##MREG USE,R10                 INDICATE R10 USED FOR CSA\n         USING CSA,R10                  SET CSA BASE FOR PROGRAM\n         ##MREG USE,R12                 INDICATE R12 USED FOR BASE\n.RPB0010 AIF   ('&R1SAVE' EQ '').PWA0000\n         ##MREG USE,&R1SAVE\n         LR    &R1SAVE,R1               SAVE R1\n.*--------------------------------------------------------------------*\n.*  ISSUE #GETSTG FOR PWA IF REQUIRED AND SET BASE(S) ON IT\n.*--------------------------------------------------------------------*\n.PWA0000 AIF   (NOT &#PBPWA).SAM0000\n&#DCPWAR SETC  '&PWAREG(1)'\n         AIF   ('&#DCPWAR' NE '').PWA0050\n&#DCPWAR SETC  'R11'\n.PWA0050 ##MREG USE,&#DCPWAR\n         AIF   (&#DCRENT).PWA0100\n         ICM   &#DCPWAR,B'1111',#BJ&NDX  LOAD ADDRESS OF DS'D PWA\n&#PBDSWA SETB  1\n         AGO   .PWA0600\n.PWA0100 ANOP\n&ZGLOC   SETC  'ANY'\n         AIF   ('&#PBAMOD' EQ '31' OR '&#PBAMOD' EQ 'ANY').PWA0200\n&ZGLOC   SETC  'BELOW'             GETS APP'D TO #GETSTG\n.PWA0200 ANOP\n.*       AIF   (NOT &OCLRPWA).PWA0300\n&ZGINIT  SETC  '00'\n.PWA0300 ANOP\n         ##CVREG &#DCPWAR\n         AIF   (&#DCGSTK).PWA0500\n         B     #ID&#PB#C.+4        SKIP #GETSTG STGID\n#ID&#PB#C DC   AL4(&NAME)\n         AIF   (&#DCSYS).PWA0400\n         #GETSTG TYPE=(USER,SHORT),PLIST=*,STGID=#ID&#PB#C.,           X\n               LEN=&PWA.PLLEN,ADDR=(&#MCVREG),INIT=&ZGINIT,        @C4 X\n               LOC=&ZGLOC\n         AGO   .PWA0600\n.PWA0400 ANOP\n         MNOTE *,'SYSTEM-MODE GETSTG generated'\n         #GETSTG TYPE=(SYSTCE,SHORT),PLIST=*,STGID=#ID&#PB#C.,         X\n               LEN=&PWA.PLLEN,ADDR=(&#MCVREG),INIT=&ZGINIT,        @C4 X\n               LOC=&ZGLOC,RGSV=(R2-R8)\n         AGO   .PWA0600\n.PWA0500 ANOP\n         MNOTE *,'#GETSTK generated: #GETSTK =(&PWA.PLLEN/4)'      @C4\n         #GETSTK =(&PWA.PLLEN/4)                                   @C4\n.PWA0600 ##LDBS &PWA,&PWAREG,R11                                   @C4\n.*--------------------------------------------------------------------*\n.*  GENERATE CODE TO SAVE ADDRESS MODE IF NEEDED\n.*--------------------------------------------------------------------*\n.SAM0000 AIF   ('&#PBSMWA' EQ '').SAM0999 SKIP IF NO SMWA\n&TAG     SETC  '#BY&#BNDX(&#BLVL)'      MAKE UP TAG\n         AIF   (NOT &#PBXA).SAM0200\n         AIF   (NOT &#PB370).SAM0100\n         L     R15,16                   POINT R15 TO CVT\n         TM    X'74'(R15),X'80'         RUNNING UNDER XA?\n         BZ    &TAG                     SKIP AMODE SETTING\n.SAM0100 ANOP\n         SLR   R15,R15                  CLEAR R15\n         AIF   (NOT &#PBXA).SAM0110\n         BSM   R15,0                    SET AMODE IN HIGH BIT\n.SAM0110 ST    R15,&#PBSMWA+4           SAVE ADDRESS MODE\n         AIF   (NOT &#PB370).SAM0200\n&TAG     DS    0H\n.SAM0200 ANOP\n.SAM0999 ANOP\n         AGO  .EXIT\n.*====================================================================*\n.*  ERRORS\n.*====================================================================*\n.* .ERR0003 MNOTE 8,'REGISTER USED FOR MULTIPLE REASONS'\n.*          AGO   .EXIT\n.ERR0009 MNOTE 8,'#START option required if SYSTEM option specified'\n         AGO   .EXIT\n.ERR0010 MNOTE 8,'#RETURN-related operands not allowed with SYSTEM opti*\n               on'\n         AGO   .EXIT\n.ERR0011 MNOTE 8,'#START/#RTN options not allowed with NOSYSTEM option'\n         AGO   .EXIT\n.ERR0012 MNOTE 8,'#RETURN option not allowed with SYSTEM option'\n         AGO   .EXIT\n.ERR0013 MNOTE 8,'EP option not allowed with NOSYSTEM option'\n         AGO   .EXIT\n.ERR0014 MNOTE 8,'AMODE and RMODE requested are inconsistent'\n         AGO   .EXIT\n.ERR0015 MNOTE 8,'GETSTK option requires SYSTEM option'\n         AGO   .EXIT\n.ERR0016 MNOTE 8,'GETSTK option requires PWA option'\n         AGO   .EXIT\n.ERR0017 MNOTE 8,'MPMODE option requires SYSTEM and #START options' @C3\n         AGO   .EXIT                                                @C3\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##PPOS": {"ttr": 5121, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x04\\x1c\\x04\\x1c\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 1052, "newlines": 1052, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##PPOS &NAME,                  NAME OF BLOCK                  $\n               &OPTIONS,                OPTIONS                        $\n               &SUBOPTS,                DEFAULT SUBROUTINE OPTIONS     $\n               &BASEREG,                BASE REGS                      $\n               &PWAREG,                 PWA REGS                       $\n               &SVAREA,                 SAVE AREA TAG NAME             $\n               &CPYRGHT,                COPYRIGHT NOTICE               $\n               &AMODE,                  ADDRESSING MODE                $\n               &RMODE,                  RESIDENCE MODE                 $\n               &R1SAVE,                 PARM SAVE REGISTER             $\n               &SMWA,                   STRUCTURED MACRO WORK AREA     $\n               &DYNSIZE,                SIZE OF DYNAMIC STORAGE        $\n               &DYNERR,                 DYNAMIC STORAGE ERROR EXIT     $\n               &PWASP,                  PROGRAM WORK AREA SUB POOL  @C2$\n               &PARMS,                  PARAMETER LIST              @C2$\n               &PARMMAP                 PARAMETER LIST MAP          @C2\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1986.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##PPOS\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##PPOS\n.*\n.*  PURPOSE    INTERNAL MACRO USED AS THE DEFAULT FOR PROGRAM BLOCK\n.*             PROLOG.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   12/18/86 MGG - BROKEN APART FROM BLOCK MACRO AND\n.*                            RESTRUCTURED\n.*              4/23/87 MGG - ADDED REUSABLE PWA, ESV, FUNCTION     @C1\n.*                            CODE AND ERROR ADDRESS SUPPORT.       @C1\n.*              5/08/89 MGG - ADDED PARAMETER SUPPORT AND MISC.     @C2\n.*                            RELATED CHANGES.                      @C2\n.*              2/04/90 MGG - ADDED support for ##MODPFX macro.     @C3\n.*              1/10/91 MJM - Added code to check a flag in the ESV @C4\n.*                            before resetting the debug stack.     @C4\n.*              2/13/91 MGG - Added XEFF option.                    @C5\n.*              3/28/91 MGG - Added MANUALFREE option.              @C6\n.*\n.*--------------------------------------------------------------------*\n         GBLB  &##ASMH                  ##ASMH MACRO RETURN FLAG\n         GBLC  &#BAMODE(20)             ADDRESSING MODE OF BLOCK\n         GBLA  &#BLVL                   BLOCK LEVEL\n         GBLA  &#BNDX(20)               BLOCK TAG INDEXS\n         GBLA  &#MNDX                   LAST TAG INDEX USED\n         GBLA  &#PB#C                   PROGRAM BLOCK NUMBER\n         GBLC  &#PBAMOD                 AMODE OF PROGRAM\n         GBLB  &#PBBR14                 ENDBLK SHOULD GENERATE 'BR 14'\n         GBLC  &#PBDERR                 DYNAMIC STORAGE ERROR TAG\n         GBLB  &#PBDSWA       ENDPWA SHOULD DEFINE STORAGE FOR PWA\n         GBLB  &#PBDYN                  DYNAMIC STORAGE OPTION\n         GBLC  &#PBDYNS                 VALUE FROM DYNSIZE PARAMETER\n         GBLB  &#PBGTMN                 SAVE AREA GETMAINED\n         GBLB  &#PBLOCR                 DO LOCATR IN PROGRAM\n         GBLB  &#PBLONG                 LONG PROGRAM OPTION\n         GBLB  &#PBMAIN                 MAIN OPTION\n         GBLA  &#PBNDX                  PROGRAM BLOCK INDEX\n         GBLB  &#PBNRSV                 NORENT SAVE AREA IN PROGRAM BLK\n         GBLB  &#PBOPTS                 OPTIMIZE STORAGE\n         GBLA  &#PBPLMX                 MAX PL ENTRIES IN PROGRAM\n         GBLB  &#PBPWA                  PWA OPTION\n         GBLC  &#PBRMOD                 RMODE OF PROGRAM\n         GBLB  &#PBRTN0                 RETURN_R0 OPTION\n         GBLB  &#PBRTN1                 RETURN_R1 OPTION\n         GBLB  &#PBRPWA                 REUSABLE PWA OPTION         @C1\n         GBLB  &#PBMFRE                 MANUALFREE OPTION           @C6\n         GBLB  &#PBFNCD                 FUNCTION CODE OPTION        @C1\n         GBLB  &#PBESV                  ENVIRONMENT SUPPORT OPTION  @C1\n         GBLB  &#PBERRA                 ERROR ADDRESS OPTION        @C1\n         GBLB  &#PBSAVE                 REGISTERS SAVED IN PROGRAM BLK\n         GBLC  &#PBSMWA                 TAG OF SMWA\n         GBLB  &#PBVL                   DEFAULT VL OPTION\n         GBLA  &#PBWAMX                 MAX SMWA IN PROGRAM\n         GBLB  &#PBXA                   XA OPTION\n         GBLB  &#PB370                  370 OPTION\n         GBLB  &#SBSU                   SAVEUSING OPTION\n         GBLB  &#SBUSWA                 USERSWA OPTION\n         GBLA  &#PBPWAP                 REUSABLE PWA PARM NUMBER    @C1\n         GBLA  &#PBESVP                 ESV PARM NUMBER             @C1\n         GBLA  &#PBFNCP                 FUNCTION PARM NUMBER        @C1\n         GBLB  &#POOPT                  PARM OPTION ACTIVE          @C2\n         GBLC  &PWA                     PWA GLOBAL SYMBOL           @C2\n         GBLC  &PSD                     PSD GLOBAL SYMBOL           @C2\n         GBLC  &PPL                     PARAMETER LIST TAG          @C2\n         LCLA  &CTR                     WORK COUNTER\n         LCLA  &NDX                     #MNDX VALUE AT START OF MACRO\n         LCLB  &OCLRPWA                 CLEARPWA OPTION\n         LCLB  &OCSECT                  CSECT OPTION\n         LCLB  &OID                     ID OPTION\n         LCLB  &OXEFF                   XEFF OPTION                 @C5\n         LCLB  &OLDBASE                 LOAD BASE OPTION\n         LCLB  &OMODE                   MODE OPTION\n         LCLC  &OPT                     OPTIONS WORK FIELD\n         LCLB  &OREGEQU                 REGEQU OPTION\n         LCLB  &ORENT                   RENT OPTION\n         LCLB  &OSAVE                   SAVE OPTION\n         LCLB  &OSAVEAR                 SAVEAREA OPTION\n         LCLB  &OCLRDBG                 CLEAR DEBUG OPTION          @C1\n         LCLC  &PGMN                    PROGRAM NAME\n         LCLC  &STRTFCD                 START FUNCTION CODE         @C1\n         LCLC  &ESVTAG                  ESV TAG                     @C1\n         LCLC  &TAG                     WORK TAG\n         LCLC  &TAG2                    WORK TAG\n         LCLC  &TAG3                    WORK TAG\n         LCLC  &TAG4                    WORK TAG                    @C1\n         LCLC  &TAG5                    WORK TAG                    @C1\n         LCLC  &TAG6                    WORK TAG                    @C1\n         LCLC  &TAG7                    WORK TAG                    @C1\n.*====================================================================*\n&NDX     SETA  &#MNDX                   SAVE INDEX VALUE TO USE\n         ##MREG RESET                   RESET REGISTERS USED\n&#PBPWA  SETB  0                        CLEAR FLAGS\n&#PBNRSV SETB  0\n&#PBOPTS SETB  0\n&#PBSAVE SETB  0\n&#PBBR14 SETB  0\n&#PBGTMN SETB  0\n&#PBXA   SETB  0\n&#PBDSWA SETB  0\n&#PBRTN0 SETB  0\n&#PBRTN1 SETB  0\n&#PB370  SETB  0\n&#PBVL   SETB  0\n&#PBDYN  SETB  0\n&#PBLONG SETB  0\n&#PBPLMX SETA  0\n&#PBLOCR SETB  0\n&#SBUSWA SETB  0\n&#SBSU   SETB  0\n&#PBRTN0 SETB  0         NORTNR0 OPTION                             @C1\n&#PBRTN1 SETB  0         NORTNR1 OPTION                             @C1\n&#PBRPWA SETB  0         NOREUSPWA OPTION                           @C1\n&#PBMFRE SETB  0         NOMANUALFREE OPTION                        @C6\n&#PBFNCD SETB  0         NOFNCODE OPTION                            @C1\n&#PBESV  SETB  0         ENVIRONMENT SUPPORT OPTION                 @C1\n&#PBERRA SETB  0         ERROR ADDRESS OPTION                       @C1\n&#PBPWAP SETA  0         NO PWA PARM                                @C1\n&#PBESVP SETA  0         NO ESV PARM                                @C1\n&#PBFNCP SETA  0         NO FNCODE PARM                             @C1\n&STRTFCD SETC  ''        NO START FUNCTION CODE                     @C1\n         ##PRMOPT PROCESS=RESET,TYPE=PROGRAM                        @C2\n&#PBRMOD SETC  '&RMODE'\n&#PBAMOD SETC  '&AMODE'\n&#PBSMWA SETC  '&SMWA'\n&#PBDYNS SETC  '&DYNSIZE'\n&#BAMODE(1) SETC  '&AMODE'\n.*--------------------------------------------------------------------*\n.*  CHECK FOR IGNORED KEYWORDS\n.*--------------------------------------------------------------------*\n.* NONE\n.*--------------------------------------------------------------------*\n.*  SET OPTIONS FOR TYPE=PROGRAM\n.*--------------------------------------------------------------------*\n&CTR     SETA  1                        SET OPTIONS\n.SPO0010 AIF   (N'&OPTIONS LT &CTR).SPO9999\n&OPT     SETC  '&OPTIONS(&CTR)'\n.SPO0020 AIF   ('&OPT' NE 'PWA').SPO0030\n&#PBPWA  SETB  1\n         AGO   .SPO9000\n.SPO0030 AIF   ('&OPT' NE 'NOPWA').SPO0040\n&#PBPWA  SETB  0\n         AGO   .SPO9000\n.SPO0040 AIF   ('&OPT' NE 'CLEARPWA').SPO0050\n&OCLRPWA SETB  1\n         AGO   .SPO9000\n.SPO0050 AIF   ('&OPT' NE 'NOCLEARPWA').SPO0060\n&OCLRPWA SETB  0\n         AGO   .SPO9000\n.SPO0060 AIF   ('&OPT' NE 'SAVE').SPO0070\n&OSAVE   SETB  1\n         AGO   .SPO9000\n.SPO0070 AIF   ('&OPT' NE 'NOSAVE').SPO0071\n&OSAVE   SETB  0\n         AGO   .SPO9000\n.SPO0071 AIF   ('&OPT' NE 'BR14').SPO0072\n&#PBBR14 SETB  1\n         AGO   .SPO9000\n.SPO0072 AIF   ('&OPT' NE 'NOBR14').SPO0080\n&#PBBR14 SETB  0\n         AGO   .SPO9000\n.SPO0080 AIF   ('&OPT' NE 'SAVEAREA').SPO0090\n&OSAVEAR SETB  1\n         AGO   .SPO9000\n.SPO0090 AIF   ('&OPT' NE 'NOSAVEAREA').SPO0100\n&OSAVEAR SETB  0\n         AGO   .SPO9000\n.SPO0100 AIF   ('&OPT' NE 'RENT').SPO0110\n&ORENT   SETB  1\n         AGO   .SPO9000\n.SPO0110 AIF   ('&OPT' NE 'NORENT').SPO0120\n&ORENT   SETB  0\n         AGO   .SPO9000\n.SPO0120 AIF   ('&OPT' NE 'ID').SPO0130\n&OID     SETB  1\n         AGO   .SPO9000\n.SPO0130 AIF   ('&OPT' NE 'NOID').SPO0140\n&OID     SETB  0\n         AGO   .SPO9000\n.SPO0140 AIF   ('&OPT' NE 'REGEQU').SPO0150\n&OREGEQU SETB  1\n         AGO   .SPO9000\n.SPO0150 AIF   ('&OPT' NE 'NOREGEQU').SPO0160\n&OREGEQU SETB  0\n         AGO   .SPO9000\n.SPO0160 AIF   ('&OPT' NE 'CSECT').SPO0170\n&OCSECT  SETB  1\n         AGO   .SPO9000\n.SPO0170 AIF   ('&OPT' NE 'NOCSECT').SPO0180\n&OCSECT  SETB  0\n         AGO   .SPO9000\n.SPO0180 AIF   ('&OPT' NE 'LOADBASE').SPO0190\n&OLDBASE SETB  1\n         AGO   .SPO9000\n.SPO0190 AIF   ('&OPT' NE 'NOLOADBASE').SPO0200\n&OLDBASE SETB  0\n         AGO   .SPO9000\n.SPO0200 AIF   ('&OPT' NE '*RENT').SPO0210\n&#PBPWA  SETB  0         NOPWA OPTION\n&OCLRPWA SETB  0         NOCLEARPWA OPTION\n&OSAVE   SETB  1         SAVE OPTION\n&#PBBR14 SETB  1         BR14 OPTION\n&OSAVEAR SETB  1         SAVEAREA OPTION\n&ORENT   SETB  1         RENT OPTION\n&OID     SETB  1         ID OPTION\n&OXEFF   SETB  0         NOXEFF OPTION                              @C5\n&OCSECT  SETB  1         CSECT OPTION\n&OREGEQU SETB  1         REGEQU OPTION\n&OLDBASE SETB  1         LOAD BASE OPTION\n&OMODE   SETB  1         MODE OPTION\n&#PBXA   SETB  0         NOXA OPTION\n&#PB370  SETB  0         NO370 OPTION\n&#PBVL   SETB  1         VL OPTION\n&#PBDYN  SETB  0         NODYN OPTION\n&#PBMAIN SETB  0         NOMAIN OPTION\n&#PBOPTS SETB  0         NOOPTSTOR OPTION\n&#PBLOCR SETB  1         LOCTR OPTION\n&#PBLONG SETB  0         NOLONG OPTION\n&#PBRTN0 SETB  0         NORTNR0 OPTION\n&#PBRTN1 SETB  0         NORTNR1 OPTION\n&#PBRPWA SETB  0         NOREUSPWA OPTION                           @C1\n&#PBMFRE SETB  0         NOMANUALFREE OPTION                        @C6\n&#PBFNCD SETB  0         NOFNCODE OPTION                            @C1\n&#PBESV  SETB  0         ENVIRONMENT SUPPORT OPTION                 @C1\n&#PBPWAP SETA  0         NO PWA PARM                                @C1\n&#PBESVP SETA  0         NO ESV PARM                                @C1\n&#PBERRA SETB  0         NO ERROR ADDRESS                           @C1\n&OCLRDBG SETB  0         NO CLEAR DEBUG                             @C1\n&#PBFNCP SETA  0         NO FNCODE PARM                             @C1\n         ##PRMOPT PROCESS=RESET,TYPE=PROGRAM                        @C2\n&STRTFCD SETC  ''        NO START FUNCTION CODE                     @C1\n         AGO   .SPO9000\n.SPO0210 AIF   ('&OPT' NE '*PWA').SPO0220\n&#PBPWA  SETB  1         PWA OPTION\n&OCLRPWA SETB  1         CLEARPWA OPTION\n&OSAVE   SETB  1         SAVE OPTION\n&#PBBR14 SETB  1         BR14 OPTION\n&OSAVEAR SETB  1         SAVEAREA OPTION\n&ORENT   SETB  1         RENT OPTION\n&OID     SETB  1         ID OPTION\n&OXEFF   SETB  0         NOXEFF OPTION                              @C5\n&OCSECT  SETB  1         CSECT OPTION\n&OREGEQU SETB  1         REGEQU OPTION\n&OLDBASE SETB  1         LOAD BASE OPTION\n&OMODE   SETB  1         MODE OPTION\n&#PBXA   SETB  0         NOXA OPTION\n&#PB370  SETB  0         NO370 OPTION\n&#PBVL   SETB  1         VL OPTION\n&#PBDYN  SETB  0         NODYN OPTION\n&#PBMAIN SETB  0         NOMAIN OPTION\n&#PBOPTS SETB  0         NOOPTSTOR OPTION\n&#PBLOCR SETB  1         LOCTR OPTION\n&#PBLONG SETB  0         NOLONG OPTION\n&#PBRTN0 SETB  0         NORTNR0 OPTION\n&#PBRTN1 SETB  0         NORTNR1 OPTION\n&#PBRPWA SETB  0         NOREUSPWA OPTION                           @C1\n&#PBMFRE SETB  0         NOMANUALFREE OPTION                        @C6\n&#PBFNCD SETB  0         NOFNCODE OPTION                            @C1\n&#PBESV  SETB  0         ENVIRONMENT SUPPORT OPTION                 @C1\n&#PBERRA SETB  0         NO ERROR ADDRESS                           @C1\n&OCLRDBG SETB  0         NO CLEAR DEBUG                             @C1\n&#PBPWAP SETA  0         NO PWA PARM                                @C1\n&#PBESVP SETA  0         NO ESV PARM                                @C1\n&#PBFNCP SETA  0         NO FNCODE PARM                             @C1\n&STRTFCD SETC  ''        NO START FUNCTION CODE                     @C1\n         ##PRMOPT PROCESS=RESET,TYPE=PROGRAM                        @C2\n         AGO   .SPO9000\n.SPO0220 AIF   ('&OPT' NE '*NORENT').SPO0230\n&#PBPWA  SETB  0         NOPWA OPTION\n&OCLRPWA SETB  0         NOCLEARPWA OPTION\n&OSAVE   SETB  1         SAVE OPTION\n&#PBBR14 SETB  1         BR14 OPTION\n&OSAVEAR SETB  1         SAVEAREA OPTION\n&ORENT   SETB  0         NORENT OPTION\n&OID     SETB  1         ID OPTION\n&OXEFF   SETB  0         NOXEFF OPTION                              @C5\n&OCSECT  SETB  1         CSECT OPTION\n&OREGEQU SETB  1         REGEQU OPTION\n&OLDBASE SETB  1         LOAD BASE OPTION\n&OMODE   SETB  1         MODE OPTION\n&#PBXA   SETB  0         NOXA OPTION\n&#PB370  SETB  0         NO370 OPTION\n&#PBVL   SETB  1         VL OPTION\n&#PBDYN  SETB  0         NODYN OPTION\n&#PBMAIN SETB  0         NOMAIN OPTION\n&#PBOPTS SETB  0         NOOPTSTOR OPTION\n&#PBLOCR SETB  1         LOCTR OPTION\n&#PBLONG SETB  0         NOLONG OPTION\n&#PBRTN0 SETB  0         NORTNR0 OPTION\n&#PBRTN1 SETB  0         NORTNR1 OPTION\n&#PBRPWA SETB  0         NOREUSPWA OPTION                           @C1\n&#PBMFRE SETB  0         NOMANUALFREE OPTION                        @C6\n&#PBFNCD SETB  0         NOFNCODE OPTION                            @C1\n&#PBESV  SETB  0         ENVIRONMENT SUPPORT OPTION                 @C1\n&#PBERRA SETB  0         NO ERROR ADDRESS                           @C1\n&OCLRDBG SETB  0         NO CLEAR DEBUG                             @C1\n&#PBPWAP SETA  0         NO PWA PARM                                @C1\n&#PBESVP SETA  0         NO ESV PARM                                @C1\n&#PBFNCP SETA  0         NO FNCODE PARM                             @C1\n&STRTFCD SETC  ''        NO START FUNCTION CODE                     @C1\n         ##PRMOPT PROCESS=RESET,TYPE=PROGRAM                        @C2\n         AGO   .SPO9000\n.SPO0230 AIF   ('&OPT' NE 'MODE').SPO0240\n&OMODE   SETB  1\n         AGO   .SPO9000\n.SPO0240 AIF   ('&OPT' NE 'NOMODE').SPO0250\n&OMODE   SETB  0\n         AGO   .SPO9000\n.SPO0250 AIF   ('&OPT' NE 'XA').SPO0260\n&#PBXA   SETB  1\n         AGO   .SPO9000\n.SPO0260 AIF   ('&OPT' NE 'NOXA').SPO0270\n&#PBXA   SETB  0\n         AGO   .SPO9000\n.SPO0270 AIF   ('&OPT' NE '370').SPO0280\n&#PB370  SETB  1\n         AGO   .SPO9000\n.SPO0280 AIF   ('&OPT' NE 'NO370').SPO0290\n&#PB370  SETB  0\n         AGO   .SPO9000\n.SPO0290 AIF   ('&OPT' NE 'VL').SPO0300\n&#PBVL   SETB  1\n         AGO   .SPO9000\n.SPO0300 AIF   ('&OPT' NE 'NOVL').SPO0310\n&#PBVL   SETB  0\n         AGO   .SPO9000\n.SPO0310 AIF   ('&OPT' NE 'DYN').SPO0320\n&#PBDYN  SETB  1\n         AGO   .SPO9000\n.SPO0320 AIF   ('&OPT' NE 'NODYN').SPO0330\n&#PBDYN  SETB  0\n         AGO   .SPO9000\n.SPO0330 AIF   ('&OPT' NE 'MAIN').SPO0340\n&#PBMAIN SETB  1\n         AGO   .SPO9000\n.SPO0340 AIF   ('&OPT' NE 'NOMAIN').SPO0350\n&#PBMAIN SETB  0\n         AGO   .SPO9000\n.SPO0350 AIF   ('&OPT' NE '*MAIN').SPO0360\n&#PBPWA  SETB  1         PWA OPTION\n&OCLRPWA SETB  1         CLEARPWA OPTION\n&OSAVE   SETB  1         SAVE OPTION\n&#PBBR14 SETB  1         BR14 OPTION\n&OSAVEAR SETB  1         SAVEAREA OPTION\n&ORENT   SETB  1         RENT OPTION\n&OID     SETB  1         ID OPTION\n&OXEFF   SETB  0         NOXEFF OPTION                              @C5\n&OCSECT  SETB  1         CSECT OPTION\n&OREGEQU SETB  1         REGEQU OPTION\n&OLDBASE SETB  1         LOAD BASE OPTION\n&OMODE   SETB  1         MODE OPTION\n&#PBXA   SETB  0         NOXA OPTION\n&#PB370  SETB  0         NO370 OPTION\n&#PBVL   SETB  1         VL OPTION\n&#PBDYN  SETB  1         DYN OPTION\n&#PBMAIN SETB  1         MAIN OPTION\n&#PBOPTS SETB  0         NOOPTSTOR OPTION\n&#PBLOCR SETB  1         LOCTR OPTION\n&#PBLONG SETB  0         NOLONG OPTION\n&#PBRTN0 SETB  0         NORTNR0 OPTION\n&#PBRTN1 SETB  0         NORTNR1 OPTION\n&#PBRPWA SETB  0         NOREUSPWA OPTION                           @C1\n&#PBMFRE SETB  0         NOMANUALFREE OPTION                        @C6\n&#PBFNCD SETB  0         NOFNCODE OPTION                            @C1\n&#PBESV  SETB  0         ENVIRONMENT SUPPORT OPTION                 @C1\n&#PBERRA SETB  0         NO ERROR ADDRESS                           @C1\n&#PBPWAP SETA  0         NO PWA PARM                                @C1\n&OCLRDBG SETB  0         NO CLEAR DEBUG                             @C1\n&#PBESVP SETA  0         NO ESV PARM                                @C1\n&#PBFNCP SETA  0         NO FNCODE PARM                             @C1\n&STRTFCD SETC  ''        NO START FUNCTION CODE                     @C1\n         ##PRMOPT PROCESS=RESET,TYPE=PROGRAM                        @C2\n         AGO   .SPO9000\n.SPO0360 AIF   ('&OPT' NE '*NOMAIN').SPO0370\n&#PBPWA  SETB  1         PWA OPTION\n&OCLRPWA SETB  1         CLEARPWA OPTION\n&OSAVE   SETB  1         SAVE OPTION\n&#PBBR14 SETB  1         BR14 OPTION\n&OSAVEAR SETB  1         SAVEAREA OPTION\n&ORENT   SETB  1         RENT OPTION\n&OID     SETB  1         ID OPTION\n&OXEFF   SETB  0         NOXEFF OPTION                              @C5\n&OCSECT  SETB  1         CSECT OPTION\n&OREGEQU SETB  1         REGEQU OPTION\n&OLDBASE SETB  1         LOAD BASE OPTION\n&OMODE   SETB  1         MODE OPTION\n&#PBXA   SETB  0         NOXA OPTION\n&#PB370  SETB  0         NO370 OPTION\n&#PBVL   SETB  1         VL OPTION\n&#PBDYN  SETB  1         DYN OPTION\n&#PBMAIN SETB  0         NOMAIN OPTION\n&#PBOPTS SETB  0         NOOPTSTOR OPTION\n&#PBLOCR SETB  1         LOCTR OPTION\n&#PBLONG SETB  0         NOLONG OPTION\n&#PBRTN0 SETB  0         NORTNR0 OPTION\n&#PBRTN1 SETB  0         NORTNR1 OPTION\n&#PBRPWA SETB  0         NOREUSPWA OPTION                           @C1\n&#PBMFRE SETB  0         NOMANUALFREE OPTION                        @C6\n&#PBFNCD SETB  0         NOFNCODE OPTION                            @C1\n&#PBESV  SETB  0         ENVIRONMENT SUPPORT OPTION                 @C1\n&#PBERRA SETB  0         NO ERROR ADDRESS                           @C1\n&OCLRDBG SETB  0         NO CLEAR DEBUG                             @C1\n&#PBPWAP SETA  0         NO PWA PARM                                @C1\n&#PBESVP SETA  0         NO ESV PARM                                @C1\n&#PBFNCP SETA  0         NO FNCODE PARM                             @C1\n&STRTFCD SETC  ''        NO START FUNCTION CODE                     @C1\n         ##PRMOPT PROCESS=RESET,TYPE=PROGRAM                        @C2\n         AGO   .SPO9000\n.SPO0370 AIF   ('&OPT' NE 'OPTSTOR').SPO0380\n&#PBOPTS SETB  1\n         AGO   .SPO9000\n.SPO0380 AIF   ('&OPT' NE 'NOOPTSTOR').SPO0390\n&#PBOPTS SETB  0\n         AGO   .SPO9000\n.SPO0390 AIF   ('&OPT' NE 'LOCTR').SPO0400\n&#PBLOCR SETB  1\n         AGO   .SPO9000\n.SPO0400 AIF   ('&OPT' NE 'NOLOCTR').SPO0410\n&#PBLOCR SETB  0\n         AGO   .SPO9000\n.SPO0410 AIF   ('&OPT' NE 'LONG').SPO0420\n&#PBLONG SETB  1\n         AGO   .SPO9000\n.SPO0420 AIF   ('&OPT' NE 'NOLONG').SPO0430\n&#PBLONG SETB  0\n         AGO   .SPO9000\n.SPO0430 AIF   ('&OPT' NE 'RTNR0').SPO0440\n&#PBRTN0 SETB  1\n         AGO   .SPO9000\n.SPO0440 AIF   ('&OPT' NE 'NORTNR0').SPO0450\n&#PBRTN0 SETB  0\n         AGO   .SPO9000\n.SPO0450 AIF   ('&OPT' NE 'RTNR1').SPO0460\n&#PBRTN1 SETB  1\n         AGO   .SPO9000\n.SPO0460 AIF   ('&OPT' NE 'NORTNR1').SPO0470\n&#PBRTN1 SETB  0\n         AGO   .SPO9000\n.SPO0470 AIF   ('&OPTIONS(&CTR,1)' NE 'REUSPWA').SPO0480            @C1\n&#PBRPWA SETB  1                                                    @C1\n&#PBPWAP SETA  1                                                    @C1\n         AIF   (N'&OPTIONS(&CTR) EQ 1).SPO9000                      @C1\n         AIF   (N'&OPTIONS(&CTR) NE 2).SPO8900                      @C1\n&#PBPWAP SETA  &OPTIONS(&CTR,2)                                     @C1\n         AGO   .SPO9000                                             @C1\n.SPO0480 AIF   ('&OPT' NE 'NOREUSPWA').SPO0490                      @C1\n&#PBRPWA SETB  0                                                    @C1\n&#PBPWAP SETA  0                                                    @C1\n         AGO   .SPO9000                                             @C1\n.SPO0490 AIF   ('&OPTIONS(&CTR,1)' NE 'FNCODE').SPO0500             @C1\n&#PBFNCD SETB  1                                                    @C1\n&#PBFNCP SETA  2                                                    @C1\n&STRTFCD SETC  'AL4(1)'                                             @C1\n         AIF   (N'&OPTIONS(&CTR) EQ 1).SPO9000                      @C1\n         AIF   ('&OPTIONS(&CTR,2)' EQ '').SPO0492                   @C1\n&#PBFNCP SETA  &OPTIONS(&CTR,2)                                     @C1\n.SPO0492 AIF   (N'&OPTIONS(&CTR) EQ 2).SPO9000                      @C1\n&STRTFCD SETC  '&OPTIONS(&CTR,3)'                                   @C1\n         AIF   (N'&OPTIONS(&CTR) NE 3).SPO8900                      @C1\n         AGO   .SPO9000                                             @C1\n.SPO0500 AIF   ('&OPT' NE 'NOFNCODE').SPO0510                       @C1\n&#PBFNCD SETB  0                                                    @C1\n&#PBFNCP SETA  0                                                    @C1\n         AGO   .SPO9000                                             @C1\n.SPO0510 AIF   ('&OPTIONS(&CTR,1)' NE 'ESV').SPO0520                @C1\n&#PBESV  SETB  1                                                    @C1\n&#PBESVP SETA  3                                                    @C1\n&ESVTAG  SETC  'PWAAESV'                                            @C1\n         AIF   (N'&OPTIONS(&CTR) EQ 1).SPO9000                      @C1\n         AIF   ('&OPTIONS(&CTR,2)' EQ '').SPO0512                   @C1\n&#PBESVP SETA  &OPTIONS(&CTR,2)                                     @C1\n.SPO0512 AIF   (N'&OPTIONS(&CTR) EQ 2).SPO9000                      @C1\n&ESVTAG  SETC  '&OPTIONS(&CTR,3)'                                   @C1\n         AIF   (N'&OPTIONS(&CTR) NE 3).SPO8900                      @C1\n         AGO   .SPO9000                                             @C1\n.SPO0520 AIF   ('&OPT' NE 'NOESV').SPO0530                          @C1\n&#PBESV  SETB  0                                                    @C1\n&#PBESVP SETA  0                                                    @C1\n         AGO   .SPO9000                                             @C1\n.SPO0530 AIF   ('&OPT' NE '*SRVPRC').SPO0540                        @C1\n&#PBPWA  SETB  1         PWA OPTION                                 @C1\n&OCLRPWA SETB  1         CLEARPWA OPTION                            @C1\n&OSAVE   SETB  1         SAVE OPTION                                @C1\n&#PBBR14 SETB  1         BR14 OPTION                                @C1\n&OSAVEAR SETB  1         SAVEAREA OPTION                            @C1\n&ORENT   SETB  1         RENT OPTION                                @C1\n&OID     SETB  1         ID OPTION                                  @C1\n&OXEFF   SETB  0         NOXEFF OPTION                              @C5\n&OCSECT  SETB  1         CSECT OPTION                               @C1\n&OREGEQU SETB  1         REGEQU OPTION                              @C1\n&OLDBASE SETB  1         LOAD BASE OPTION                           @C1\n&OMODE   SETB  1         MODE OPTION                                @C1\n&#PBXA   SETB  1         XA OPTION                                  @C1\n&#PB370  SETB  0         NO370 OPTION                               @C1\n&#PBVL   SETB  1         VL OPTION                                  @C1\n&#PBDYN  SETB  0         NODYN OPTION                               @C1\n&#PBMAIN SETB  0         NOMAIN OPTION                              @C1\n&#PBOPTS SETB  0         NOOPTSTOR OPTION                           @C1\n&#PBLOCR SETB  1         LOCTR OPTION                               @C1\n&#PBLONG SETB  0         NOLONG OPTION                              @C1\n&#PBRTN0 SETB  0         NORTNR0 OPTION                             @C1\n&#PBRTN1 SETB  0         NORTNR1 OPTION                             @C1\n&#PBRPWA SETB  1         REUSPWA OPTION                             @C6\n&#PBMFRE SETB  0         NOMANUALFREE OPTION                        @C6\n&#PBFNCD SETB  1         NOFNCODE OPTION                            @C1\n&#PBESV  SETB  1         ENVIRONMENT SUPPORT OPTION                 @C1\n&#PBERRA SETB  1         ERROR ADDRESS                              @C1\n&OCLRDBG SETB  1         NO CLEAR DEBUG                             @C1\n&#PBPWAP SETA  1         NO PWA PARM                                @C1\n&#PBESVP SETA  3         NO ESV PARM                                @C1\n&#PBFNCP SETA  2         NO FNCODE PARM                             @C1\n         ##PRMOPT PROCESS=RESET,TYPE=PROGRAM                        @C2\n&STRTFCD SETC  'AL4(1)'  START FUNCTION CODE IS A FULLWORD OF ONE   @C1\n&ESVTAG  SETC  'PWAAESV' ENVIRONMENT SUPPORT VECTOR TAG             @C1\n         AGO   .SPO9000                                             @C1\n.SPO0540 AIF   ('&OPT' NE 'ERRADDR').SPO0550                        @C1\n&#PBERRA SETB  1                                                    @C1\n         AGO   .SPO9000                                             @C1\n.SPO0550 AIF   ('&OPT' NE 'NOERRADDR').SPO0560                      @C1\n&#PBERRA SETB  0                                                    @C1\n         AGO   .SPO9000                                             @C1\n.SPO0560 AIF   ('&OPT' NE 'CLRDEBUG').SPO0570                       @C1\n&OCLRDBG SETB  1                                                    @C1\n         AGO   .SPO9000                                             @C1\n.SPO0570 AIF   ('&OPT' NE 'NOCLRDEBUG').SPO0580                     @C1\n&OCLRDBG SETB  0                                                    @C1\n         AGO   .SPO9000                                             @C1\n.SPO0580 AIF   ('&OPTIONS(&CTR,1)' NE 'PARMS').SPO0590              @C2\n         ##PRMOPT PROCESS=PARSE_OPTIONS,OPTIONS=&OPTIONS(&CTR),     @C2+\n               TYPE=PROGRAM\n         AGO   .SPO9000                                             @C2\n.SPO0590 AIF   ('&OPT' NE 'NOPARMS').SPO0600                        @C2\n         ##PRMOPT PROCESS=RESET,TYPE=PROGRAM                        @C2\n         AGO   .SPO9000                                             @C2\n.SPO0600 AIF   ('&OPT' NE 'XEFF').SPO0610                           @C5\n&OXEFF   SETB  1                                                    @C5\n         AGO   .SPO9000                                             @C5\n.SPO0610 AIF   ('&OPT' NE 'NOXEFF').SPO0620                         @C5\n&OXEFF   SETB  0                                                    @C5\n         AGO   .SPO9000                                             @C5\n.SPO0620 AIF   ('&OPT' NE 'MANUALFREE').SPO0630                     @C6\n&#PBMFRE SETB  1         MANUALFREE OPTION                          @C6\n         AGO   .SPO9000                                             @C6\n.SPO0630 AIF   ('&OPT' NE 'NOMANUALFREE').SPO0640                   @C6\n&#PBMFRE SETB  0         NOMANUALFREE OPTION                        @C6\n         AGO   .SPO9000                                             @C6\n.SPO0640 ANOP                                                       @C6\n.SPO8900 ANOP                                                       @C1\n         MNOTE 8,'Invalid option &OPT'\n.SPO9000 ANOP\n&CTR     SETA  &CTR+1\n         AGO   .SPO0010\n.SPO9999 ANOP\n.*------------------------------------------------------------------\n.*  CHECK OPTIONS\n.*------------------------------------------------------------------\n.COP0010 AIF   (NOT &#PBMAIN OR &#PBDYN).COP0020\n         MNOTE 4,'Option DYN assumed because of option MAIN'\n&#PBDYN  SETB  1\n.COP0020 AIF   (NOT &#PBDYN OR &#PBPWA).COP0030\n         MNOTE 4,'Option PWA assumed because of option DYN'\n&#PBPWA  SETB  1\n.COP0030 AIF   ('&DYNSIZE' EQ '' OR &#PBDYN).COP0040\n         MNOTE 4,'DYNSIZE can not be specified without option DYN'\n.COP0040 AIF   ('&#PBSMWA' NE '' OR NOT &#PBPWA).COP0050\n&#PBWAMX SETA  2\n&#PBSMWA SETC  '#PBW&#PB#C'\n.COP0050 AIF   (NOT &#PBLOCR).COP0060\n         ##ASMH ((A))\n         AIF   (&##ASMH).COP0060\n         MNOTE 8,'Assembler H required for LOCTR option'\n.COP0060 AIF   (NOT &#PBRPWA).COP0070                               @C1\n         AIF   (&#PBPWA AND &ORENT AND &OSAVE).COP0070              @C1\n         MNOTE 8,'Option REUSPWA requires the PWA, RENT and SAVE option$\n               s'                                                   @C1\n.COP0070 AIF   (NOT &#PBFNCD).COP0080                               @C1\n         AIF   (&#PBRPWA).COP0080                                   @C1\n         MNOTE 4,'Option FNCODE is ignored when the REUSPWA option is n$\n               ot in effect.'                                       @C1\n.COP0080 ANOP                                                       @C1\n.COP0090 AIF   (NOT &#PBESV).COP0100                                @C1\n         AIF   (&#PBPWA AND &ORENT).COP0110                         @C1\n         MNOTE 8,'Option ESV requires the PWA and RENT options'     @C1\n.COP0100 AIF   (NOT &OCLRDBG).COP0110                               @C1\n         MNOTE 8,'Option CLRDEBUG requires the ESV option'          @C1\n.COP0110 ANOP                                                       @C1\n         AIF   (NOT &OXEFF).COP0120                                 @C5\n         AIF   (&OID AND &OSAVE).COP0120                            @C5\n         MNOTE 8,'ID and SAVE option required if XEFF option specified.+\n               '                                                    @C5\n.COP0120 AIF   (NOT &#PBRPWA OR NOT &#PBMFRE).COP0130               @C6\n         MNOTE 8,'MANUALFREE and REUSPWA options are mutually exclusive+\n               '                                                    @C6\n.COP0130 AIF   (NOT &#PBMFRE).COP0140                               @C6\n         AIF   (&#PBPWA AND &ORENT AND &OSAVE).COP0140              @C6\n         MNOTE 8,'Option MANUALFREE requires the PWA, RENT and SAVE opt$\n               ions'                                                @C6\n.COP0140 ANOP                                                       @C6\n.*--------------------------------------------------------------------*\n.*  GET REQUIRED PROGRAM NAME.\n.*--------------------------------------------------------------------*\n&PGMN    SETC  '&NAME'\n         AIF   ('&NAME' NE '').CAR0090\n         MNOTE 8,'Name required on program block macro'\n&PGMN    SETC  'TEMPNAME'\n.CAR0090 ANOP\n.*--------------------------------------------------------------------*\n.*  GENERATE CSECT, AMODE, AND RMODE CARDS\n.*--------------------------------------------------------------------*\n         AIF   (NOT &OCSECT).CAR0100\n&PGMN    CSECT ,                        PROGRAM BLOCK\n         USING &PGMN,R15                TEMPORARY BASE\n.CAR0100 AIF   (NOT &#PBLOCR).CAR0105\n&PGMN    LOCTR ,                        LOCTR FOR PROGRAM BLOCK INST\n         PSD   TYPE=PARTIAL                                         @C2\n&PSD     EQU   *                        PSD TAG                     @C2\n         ENDPSD ,                                                   @C2\n.CAR0105 AIF   ('&AMODE' EQ '' AND '&RMODE' EQ '').CAR0200\n         AIF   (&OMODE).CAR0110\n         MNOTE 4,'RMODE and AMODE ignored if MODE option not specified'\n         AGO   .CAR0200\n.CAR0110 AIF   (&#PBXA).CAR0120\n         MNOTE 4,'RMODE and AMODE ignored if XA option not specified'\n         AGO   .CAR0200\n.CAR0120 AIF   ('&AMODE' EQ '').CAR0130\n&PGMN    AMODE &AMODE                   ADDRESSING MODE\n         AGO   .CAR0140                                             @C1\n.CAR0130 ANOP\n&#PBAMOD SETC  '24'\n         AIF   ('&RMODE' NE 'ANY').CAR0140                          @C1\n&#PBAMOD SETC  '31'\n.CAR0140 AIF   ('&RMODE' EQ '').CAR0150\n&PGMN    RMODE &RMODE                   RESIDENCE MODE\n         AGO   .CAR0180\n.CAR0150 ANOP\n&#PBRMOD SETC  '24'\n.CAR0180 AGO   .CAR0900\n.CAR0200 ANOP\n&#PBRMOD SETC  '24'\n&#PBAMOD SETC  '24'\n.CAR0900 ANOP\n.*--------------------------------------------------------------------*\n.*  GENERATE CONSTANTS AND SAVE REGISTERS\n.*--------------------------------------------------------------------*\n         AIF   ('&SVAREA' NE '' AND NOT &OID).CNS0800\n         AIF   (NOT &#PBPWA AND NOT &OSAVEAR AND NOT &OID).CNS0800\n.* REMOVED LINE\n         B     #BP&NDX                  BRANCH PAST CONSTANTS\n AIF (&ORENT OR &#PBPWA OR NOT &OSAVEAR OR '&SVAREA' NE '').CNS0100\n         DS    17F                      NONRENT SAVE AREA\n.CNS0100 AIF   (NOT &OID).CNS0200\n         ##MODPFX &PGMN,&CPYRGHT                                    @C3\n         DS    0H                                                   @C1\n.CNS0200 AIF   (NOT &#PBPWA).CNS0300\n         AIF   (NOT &#PBDYN).CNS0203\n&#PBDERR SETC  '&DYNERR'\n         AIF   ('&DYNERR' NE '').CNS0203\n&#PBDERR SETC  '#BO&NDX'\n&#PBDERR DC    H'0'                      DYNAMIC ERROR ROUTINE\n.CNS0203 AIF   (NOT &#PBFNCD).CNS0205                               @C1\n&TAG     SETC  '#BM&NDX'                                            @C1\n&TAG     DC    &STRTFCD                  START FUNCTION CODE        @C1\n.CNS0205 ANOP                                                       @C1\n&TAG     SETC  '#BW&NDX'\n&TAG2    SETC  '&PWA.PLLEN'                                         @C2\n         AIF   ('&PWASP' NE '').CNS0210\n&TAG     DC    AL1(0),AL3(&TAG2)         LENGTH OF PWA\n         AGO   .CNS0250\n.CNS0210 ANOP\n&TAG     DC    AL1(&PWASP),AL3(&TAG2)    LENGTH OF PWA\n.CNS0250 AIF   (&ORENT).CNS0300\n&TAG     SETC  '#BJ&NDX'\n&TAG2    SETC  '#PBJ&#PB#C'\n&TAG     DC    AL4(&TAG2)                ADDRESS OF PWA STORAGE\n.CNS0300 ANOP\n         AIF   (NOT &#PBDYN).CNS0400\n&TAG     SETC  '#BU&NDX'\n&TAG     DC    AL4(#PBX&#PB#C-&PWA)   DISPLACEMENT OF NAB           @C2\n.CNS0400 AIF   (NOT &OXEFF).CNS0500                                 @C5\n&#PBSAVE SETB  1                        INDICATE REGISTERS SAVED\n&TAG     SETC  '#BP&NDX'                                            @C5\n&TAG     ##XEFF &PGMN                   GENERATE XEFF CODE          @C5\n         AGO   .CNS0900                                             @C5\n.CNS0500 ANOP                                                       @C5\n&TAG     SETC  '#BP&NDX'\n&TAG     DS    0H                       END OF CONSTANTS\n.CNS0800 AIF   (NOT &OSAVE).CNS0900\n         STM   R14,R12,12(R13)          SAVE REGISTERS\n&#PBSAVE SETB  1                        INDICATE REGISTERS SAVED\n.CNS0900 ANOP\n.*--------------------------------------------------------------------*\n.*  SAVE R1 IN REGISTER SPECIFIED ON R1SAVE=\n.*--------------------------------------------------------------------*\n         AIF   (NOT &#PBDYN).RPB0010\n         ##MREG USE,R11                 INDICATE R11 USED\n.RPB0010 ANOP\n         AIF   ('&R1SAVE' EQ '').LDB0000\n         ##MREG USE,&R1SAVE\n         LR    &R1SAVE,R1               SAVE R1\n.*--------------------------------------------------------------------*\n.*  LOAD PROGRAM BASES\n.*--------------------------------------------------------------------*\n.LDB0000 AIF   (NOT &OLDBASE).OAC000                                @C1\n         AIF   ('&BASEREG' NE '').LDB0200\n         AIF   (&ORENT OR &#PBPWA OR '&SVAREA' NE '').LDB0110\n         AIF   (NOT &OSAVEAR).LDB0110\n.* THIS IS A NO RENT WITH SAVEAREA OPTION USING R13 FOR BASE REG\n         ST    R15,8(,R13)              BACK LINK\n         ST    R13,4(,R15)              FORWARD LINK\n         LR    R13,R15                  POINT R13 TO START OF PROGRAM\n         DROP  R15                      DROP TEMPORARY BASE\n         USING &PGMN,R13                PROGRAM BASE (DEFAULT)\n&#PBNRSV SETB  1                        SET NORENT SAVE AREA FLAG\n         AGO   .USG0000                 GO DO USINGS\n.LDB0110 ANOP\n         LR    R12,R15                  POINT R12 TO START OF PROGRAM\n         ##MREG USE,R12                 INDICATE R12 USED\n&TAG     SETC  'R12'                    DO USING OF R12\n         AGO   .LDB2000                 GO DO BASE USING\n.LDB0200 AIF   (&ORENT OR &#PBPWA OR '&SVAREA' NE '').LDB0300\n         AIF   (NOT &OSAVEAR).LDB0300\n         AIF   ('&BASEREG(1)' NE 'R13').LDB0300\n.* THIS IS A NO RENT WITH SAVEAREA OPTION USING R13 AS FIRST BASE REG\n         ST    R15,8(,R13)              BACK LINK\n         ST    R13,4(,R15)              FORWARD LINK\n         LR    R13,R15                  POINT R13 TO START OF PROGRAM\n&TAG     SETC  'R13'\n&#PBNRSV SETB  1                        SET NORENT SAVE AREA FLAG\n         AGO   .LDB2000\n.LDB0300 ANOP\n&TAG     SETC  '&BASEREG(1)'\n         ##MREG USE,&BASEREG(1)\n         LR    &BASEREG(1),R15          POINT FIRST BASE TO START\n.LDB2000 DROP  R15                      DROP TEMPORARY BASE\n         ##LDBS &PGMN,&BASEREG,&TAG\n.*--------------------------------------------------------------------*\n.*  OBTAIN AND CHAIN PWA\n.*--------------------------------------------------------------------*\n.OAC000  AIF    (NOT &#PBPWA).OAC1000                               @C1\n&TAG     SETC  '#BW&NDX'\n         AIF   ('&SVAREA' EQ '').OAC100                             @C1\n         MNOTE 4,'SVAREA= ignored when PWA option specified'\n.OAC100  ANOP                                                       @C1\n&TAG7    SETC  ''                                                   @C1\n&TAG6    SETC  ''                                                   @C1\n&TAG5    SETC  ''                                                   @C1\n&TAG4    SETC  ''                                                   @C1\n&TAG3    SETC  ''                                                   @C1\n&TAG2    SETC  ''\n         AIF   (NOT &#PBDYN OR &#PBMAIN).OAC200                     @C1\n&TAG2    SETC  '#PBG&#PB#C'\n         AIF   (&OCLRPWA).OAC120                                    @C1\n         L     R1,0(,R11)               POINT R1 TO NAB\n         SLR   R0,R0                    LOAD R0 WITH LENGTH OF\n         ICM   R0,B'0111',&TAG+1        .STORAGE NEEDED FOR NEW PWA\n         ALR   R0,R1                    CALCULATE NEW NAB\n         CL    R0,72(,R13)              HAVE WE OVERFLOWED?\n         BH    &TAG2                    YES, DO GETMAIN\n         ST    R1,8(,R13)               NO, USE DYNAMIC STORAGE\n         AGO   .OAC140                                              @C1\n.OAC120  L      R0,0(,R11)               POINT R1 TO NAB            @C1\n         LR    R15,R0                   POINT R15 TO NAB\n         SLR   R1,R1                    LOAD R1 WITH LENGTH OF\n         ICM   R1,B'0111',&TAG+1        .STORAGE NEEDED FOR NEW PWA\n         ALR   R15,R1                   CALCULATE NEW NAB\n         CL    R15,72(,R13)             HAVE WE OVERFLOWED?\n         BH    &TAG2                    YES, DO GETMAIN\n         ST    R0,8(,R13)               NO, USE DYNAMIC STORAGE\n         SLR   R14,R14                  CLEAR R14\n         SLR   R15,R15                  CLEAR R15\n         MVCL  R0,R14                   CLEAR PWA\n         L     R1,8(,R13)               POINT R1 TO NEW PWA\n.OAC140  OI     8(R13),X'80'             INDICATE DYNAMIC STORAGE USED\n         MVC   72(4,R1),72(R13)         MOVE EOS-64 FROM PREVIOUS PWA\n&TAG3    SETC  '#PBK&#PB#C'\n         B     &TAG3                    BRANCH PAST GETMAIN\n&TAG2    DS    0H\n.OAC200  ANOP                                                       @C1\n&#PBNRSV SETB  (NOT &ORENT)             SET NORENT SAVE FLAG\n.OAC210  ANOP                                                       @C1\n         AIF   (&ORENT).OAC215                                      @C1\n         ICM   R1,B'1111',#BJ&NDX       POINT R1 TO PWA\n&#PBDSWA SETB  1\n         AGO   .OAC217                                              @C1\n.OAC215  AIF    (NOT &#PBRPWA).OAC216                               @C1\n&TAG4    SETC  '#BG&NDX'                                            @C1\n&TAG7    SETC  '#BN&NDX'                                            @C1\n         AIF    (&#PBFNCD).OAC215F                                  @C1\n.* REUSABLE PWA WITH NOFNCODE OPTION                                @C1\n         L     R1,(&#PBPWAP-1)*4(,R1)   LOAD POINTER TO PWA ANCHOR  @C1\n         ICM   R1,B'1111',0(R1)         LOAD PWA ANCHOR             @C1\n         AIF   (&OCLRPWA).OAC215C                                   @C1\n         BNZ   &TAG4                    REUSE PWA IF IT EXIST       @C1\n         AGO   .OAC216                                              @C1\n.OAC215C BZ    &TAG7                    GETMAIN PWA IF ZERO         @C1\n         ST    R1,8(,R13)               BACKLINK                    @C1\n&TAG5    SETC  '#BH&NDX'                                            @C1\n         B     &TAG5                    BRANCH PAST CLEAR PWA       @C1\n&TAG7    DS    0H                                                   @C1\n&TAG7    SETC  ''                                                   @C1\n.*                                                                  @C1\n         AGO   .OAC216                                              @C1\n.OAC215F ANOP                                                       @C1\n.* REUSABLE PWA WITH FNCODE OPTION                                  @C1\n         L     R14,(&#PBFNCP-1)*4(,R1)  LOAD POINTER TO FUNCTION    @C1\n         CLC   #BM&NDX,0(R14)           CHECK FOR START FUNCTION    @C1\n         BE    &TAG7                    YES, DO GETMAIN             @C1\n         L     R1,(&#PBPWAP-1)*4(,R1)   LOAD POINTER TO PWA ANCHOR  @C1\n         L     R1,0(,R1)                LOAD PWA ANCHOR             @C1\n         AIF   (&OCLRPWA).OAC215L                                   @C1\n         B     &TAG4                    REUSE PWA                   @C1\n         AGO   .OAC215O                                             @C1\n.OAC215L ST    R1,8(,R13)               BACKLINK                    @C1\n&TAG5    SETC  '#BH&NDX'                                            @C1\n         B     &TAG5                    BRANCH PAST CLEAR PWA       @C1\n.OAC215O ANOP                                                       @C1\n&TAG7    DS    0H                                                   @C1\n&TAG7    SETC  ''                                                   @C1\n.*                                                                  @C1\n.OAC216  ANOP                                                       @C1\n         ICM   R0,B'1111',&TAG          LOAD LENGTH OF PWA          @C1\n         AIF   (NOT &#PBESV).OAC216M                                @C1\n         L     R15,24(,R13)             POINT R15 TO PARMS          @C1\n         L     R15,(&#PBESVP-1)*4(,R15) LOAD POINTER TO ESV POINTER @C1\n         L     R15,0(,R15)              LOAD POINTER TO ESV         @C1\n         ##MREG USE,R2                  HAVE TO USE R2              @C1\n         L     R2,12(,R15)              LOAD USER PARM FOR GETMAIN  @C1\n         L     R15,8(,R15)              LOAD ADDRESS OF GETMAIN     @C1\n         BALR  R14,R15                  DO GETMAIN                  @C1\n         AIF   (&OCLRPWA).OAC216N                                   @C1\n         L     R15,24(,R13)             POINT R14 TO PARMS          @C1\n         L     R15,(&#PBESVP-1)*4(,R15) LOAD POINTER TO ESV POINTER @C1\n         L     R15,0(,R15)              LOAD POINTER TO ESV         @C1\n&TAG6    SETC  '#PBL&#PB#C'                                         @C1\n         PWA   TYPE=PARTIAL                                         @C1\n&ESVTAG  DS    A                        ESV ADDRESS                 @C1\n&TAG6    EQU   &ESVTAG,4,C'A'           TAG FOR MACROS TO USE       @C1\n         ENDPWA                                                     @C1\n         ST    R15,&TAG6-&PWA.(,R1)   STORE ADDRESS OF ESV          @C2\n         AGO   .OAC216N                                             @C1\n.OAC216M GETMAIN R,LV=(0)               GETMAIN PWA                 @C1\n.OAC216N AIF   (NOT &#PBRPWA).OAC217                                @C1\n         L     R14,24(,R13)             POINT R14 TO PARMS          @C1\n         L     R14,(&#PBPWAP-1)*4(,R14) LOAD POINTER TO PWA ANCHOR  @C1\n         ST    R1,0(,R14)               STORE PWA ANCHOR            @C1\n.OAC217  ANOP                                                       @C1\n&TAG4    ST    R1,8(,R13)               BACKLINK                    @C1\n         AIF   (NOT &OCLRPWA).OAC220    IF OPTION SET, GEN CLEAR COD@C1\n         SLR   R14,R14                  CLEAR R14\n         SLR   R15,R15                  CLEAR R15\n         LR    R0,R1                    PUT ADDRESS OF PWA IN R0\n         ICM   R1,B'1111',&TAG          LOAD LENGTH OF PWA\n         MVCL  R0,R14                   CLEAR PWA\n         L     R1,8(,R13)               RESTORE R1\n         AIF   (NOT &#PBESV).OAC217N                                @C1\n         L     R15,24(,R13)             POINT R14 TO PARMS          @C1\n         L     R15,(&#PBESVP-1)*4(,R15) LOAD POINTER TO ESV POINTER @C1\n         L     R15,0(,R15)              LOAD POINTER TO ESV         @C1\n&TAG6    SETC  '#PBL&#PB#C'                                         @C1\n         PWA   TYPE=PARTIAL                                         @C1\n&ESVTAG  DS    A                        ESV ADDRESS                 @C1\n&TAG6    EQU   &ESVTAG,4,C'A'           TAG FOR MACROS TO USE       @C1\n         ENDPWA                                                     @C1\n         ST    R15,&TAG6-&PWA.(,R1)   STORE ADDRESS OF ESV          @C2\n.OAC217N AIF   (NOT &#PBRPWA).OAC220                                @C1\n&TAG5    DS    0H                       PAST CLEAR PWA              @C1\n.OAC220  AIF    (NOT &#PBDYN).OAC240                                @C1\n         LA    R0,16*4                  LOAD R0 WITH 64\n         SLR   R15,R15                  LOAD R15 WITH\n         ICM   R15,B'0111',&TAG+1       .LENGTH OF PWA\n         SR    R15,R0                   CALCULATE LENGTH - 64\n         ALR   R15,R1                   CALCULATE EOS - 64\n         ST    R15,72(,R1)              STORE EOS - 64\n.OAC240  ANOP                                                       @C1\n&TAG3    ST    R13,4(,R1)               FORWARD LINK\n         LR    R13,R1                   POINT R13 TO PWA\n.OAC280  ANOP                                                       @C1\n         AIF   ('&PWAREG' EQ '').OAC300                             @C1\n         AIF   ('&PWAREG(1)' EQ 'R13').OAC300                       @C1\n         MNOTE 8,'First PWAREG must be R13'\n.OAC300  ##LDBS &PWA,&PWAREG,R13                                    @C2\n         AIF   (NOT &OCLRDBG).OAC310                                @C1\n         L     R15,&ESVTAG              Load address of ESV.        @C1\n         CLI   44(R15),X'00'            Test: ClearDebug Inhibited? @C4\n         BNE   #BC&NDX                  Don't clear if inhibited.   @C4\n         MVC   36(4,R15),32(R15)        Reset debug stack.          @C1\n#BC&NDX  DS    0H                       Tag for skipping reset.     @C4\n.OAC310  ANOP                                                       @C1\n.OAC900  AIF    (NOT &#PBDYN).OAC910                                @C1\n         ICM   R11,B'1111',#BU&NDX      LOAD DISPLACEMENT OF NAB\n         ALR   R11,R13                  CALCULATE NAB ADDRESS\n         ST    R11,#PBN&#PB#C           STORE NAB ADDRESS IN PWA\n         LA    R11,#PBN&#PB#C           POINT R11 TO ADDRESS OF SWA\n*                                       .ADDRESS OF NAB\n.OAC910  AIF    (NOT &#PBOPTS OR NOT &#PBDYN).OAC920                @C1\n         AIF   (&#PBLOCR).OAC912                                    @C1\n         B     #BI&#PBNDX               BRANCH AROUND LINKAGE SUB\n         AGO   .OAC914                                              @C1\n.OAC912  PSD    TYPE=PARTIAL                                        @C2\n.OAC914  ANOP                                                       @C1\n#BK&#PBNDX DS  0H                       LINKAGE SUBROUTINE\n         ##SWREG R15\n         L     R15,0(,R11)              POINT R15 TO NAB (NEW SWA)\n         STM   R0,R14,4(R15)            SAVE R0 - R14\n         LR    R11,R15                  POINT R11 TO NEW SWA\n         LR    R14,R15                  POINT R14 TO NEW SWA\n         ##RWREG R15\n         AH    R14,0(,R15)              CALCULATE NEW NAB\n         CL    R14,#PBE&#PB#C           CHECK FOR OVERFLOW\n         BH    &#PBDERR                 BRANCH TO ERREXIT IF OVERFLO\n         ST    R14,0(,R11)              STORE NEW NAB\n         B     2(,R15)                  BRANCH BACK TO SUBROUTINE\n         AIF   (&#PBLOCR).OAC916                                    @C1\n#BI&#PBNDX DS  0H\n         AGO   .OAC920                                              @C1\n.OAC916  ENDPSD ,                                                   @C2\n.OAC920  ANOP                                                       @C2\n         AIF   (NOT &#POOPT).OAC930                                 @C2\n         L     R1,4(,R13)               RESTORE                     @C2\n         L     R1,24(,R1)                PARAMETER LIST BASE.       @C2\n.OAC930  ANOP                                                       @C2\n         AIF    (&OSAVEAR).USG0000      SKIP IF WARNING NOT NEEDED @C12\n         MNOTE *,'SAVEAREA option assumed because of PWA option'\n         AGO   .USG0000                 GO DO USINGS\n.*--------------------------------------------------------------------*\n.*  GETMAIN AND CHAIN SAVE AREA FOR RENT BUT NOT PWA\n.*--------------------------------------------------------------------*\n.OAC1000 AIF   (NOT &ORENT OR NOT &OSAVEAR).OAC2000\n         AIF   ('&SVAREA' EQ '').OAC1010\n         MNOTE 4,'SVAREA= ignored when RENT and SAVEAREA option specifi$\n               ed'\n.OAC1010 ANOP\n&#PBGTMN SETB  1                        SET GETMAINED SAVE AREA FLAG\n         LA    R0,18*4                  LOAD LENGTH OF SAVE AREA\n         GETMAIN R,LV=(0)               GET SAVE AREA\n         ST    R1,8(,R13)               BACK LINK\n         ST    R13,4(,R1)               FORWARD LINK\n         LR    R13,R1                   POINT R13 TO SAVE AREA\n&#PBGTMN SETB  1                        SET RENT SAVE AREA FLAG\n         AIF   (NOT &#POOPT).OAC1030                                @C2\n         AIF   (&OSAVE).OAC1020                                     @C2\n         MNOTE *,'Assuming register 1 is saved'                     @C2\n.OAC1020 ANOP                                                       @C2\n         L     R1,4(,R13)               RESTORE                     @C2\n         L     R1,24(,R1)                PARAMETER LIST BASE.       @C2\n.OAC1030 ANOP                                                       @C2\n         AGO   .USG0000                 GO DO USINGS\n.*--------------------------------------------------------------------*\n.*  CHAIN SAVE AREA FOR NORENT THAT SPECIFIES A SAVE AREA\n.*--------------------------------------------------------------------*\n.OAC2000 AIF   ('&SVAREA' EQ '' OR NOT &OSAVEAR).OAC3000\n         LA    R15,&SVAREA              LOAD ADDRESS OF SAVE AREA\n         ST    R15,8(,R13)              BACK LINK\n         ST    R13,4(,R15)              FORWARD LINK\n         LR    R13,R15                  POINT R13 TO SAVE AREA\n&#PBNRSV SETB  1                        SET NORENT SAVE AREA FLAG\n         AGO   .USG0000                 GO DO USINGS\n.*--------------------------------------------------------------------*\n.*  CHAIN SAVE AREA FOR NORENT THAT DID NOT SPECIFIES A SAVE AREA\n.*  AND THAT DID NOT USE 13 AS A PROGRAM BASE\n.*--------------------------------------------------------------------*\n.OAC3000 AIF   ('&SVAREA' NE '' OR NOT &OSAVEAR).OAC4000\n  AIF   ('&BASEREG' EQ '' OR '&BASEREG(1)' EQ 'R13').OAC4000\n         ST    R15,8(,R13)              BACK LINK\n         ST    R13,4(,R15)              FORWARD LINK\n         LR    R13,R15                  POINT R13 TO SAVE AREA\n&#PBNRSV SETB  1                        SET NORENT SAVE AREA FLAG\n         AGO   .USG0000                 GO DO USINGS\n.*--------------------------------------------------------------------*\n.*  CHAIN SAVE AREA FOR NORENT THAT DID SPECIFIES A SAVE AREA\n.*--------------------------------------------------------------------*\n.OAC4000 AIF   ('&SVAREA' EQ '').USG0000\n         AIF   (&OSAVEAR).OAC4010\n         MNOTE *,'SAVEAREA option assumed because of SVAREA= keyword'\n.OAC4010 LA    R15,&SVAREA              POINT R15 TO SAVE AREA\n         ST    R15,8(,R13)              BACK LINK\n         ST    R13,4(,R15)              FORWARD LINK\n         LR    R13,R15                  POINT R13 TO SAVE AREA\n&#PBNRSV SETB  1                        SET NORENT SAVE AREA FLAG\n         AGO   .USG0000                 GO DO USINGS\n.USG0000 ANOP\n.* NOT WRITTEN YET\n.PSU0000 ANOP                                                       @C6\n         AIF   (NOT &#PBMFRE OR NOT &#PBPWA).PSU0999                @C6\n         PWA   TYPE=PARTIAL                                         @C6\n&PWA.__F DS    BL1                         FLAGS                    @C6\n&PWA.__F_FREEPWA         EQU B'10000000'    FREE THE PWA            @C6\n         ENDPWA                                                     @C6\n.PSU0999 ANOP                                                       @C6\n.GPC0000 ANOP                                                       @C2\n.*------------------------------------------------------------------@C2\n.*  GENERATE PARMS CODE.                                            @C2\n.*------------------------------------------------------------------@C2\n         ##PRMOPT PROCESS=GENERATE,PARMS=&PARMS,PARMMAP=&PARMMAP,   @C2+\n               TYPE=PROGRAM\n.*------------------------------------------------------------------@C2\n.*  SET DEFAULT SUBROUTINE OPTIONS BASED ON SUBOPT                  @C2\n.*------------------------------------------------------------------@C2\n         ##SUBOPT &SUBOPTS,DEFAULT=YES                              @C2\n.*--------------------------------------------------------------------*\n.*  GENERATE CODE TO SAVE ADDRESS MODE IF NEEDED\n.*--------------------------------------------------------------------*\n         AIF   ('&#PBSMWA' EQ '').SAM0999 SKIP IF NO SMWA\n&TAG     SETC  '#BY&#BNDX(&#BLVL)'      MAKE UP TAG\n         AIF   (NOT &#PBXA).SAM0200\n         AIF   (NOT &#PB370).SAM0100\n         L     R15,16                   POINT R15 TO CVT\n         TM    X'74'(R15),X'80'         RUNNING UNDER XA?\n         BZ    &TAG                     SKIP AMODE SETTING\n.SAM0100 ANOP\n         SLR   R15,R15                  CLEAR R15\n         AIF   (NOT &#PBXA).SAM0110\n         BSM   R15,0                    SET AMODE IN HIGH BIT\n.SAM0110 ST    R15,&#PBSMWA+4           SAVE ADDRESS MODE\n         AIF   (NOT &#PB370).SAM0200\n&TAG     DS    0H\n.SAM0200 ANOP\n.SAM0999 ANOP\n.*--------------------------------------------------------------------*\n.*  GENERATE REGISTER EQUATES IF REQUESTED\n.*--------------------------------------------------------------------*\n.REQ0000 AIF   (NOT &OREGEQU).REQ0010\n         ##REGS\n.REQ0010 ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##PPPLI": {"ttr": 5385, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x01p\\x01p\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 368, "newlines": 368, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##PPPLI &NAME,                 NAME OF BLOCK                  $\n               &OPTIONS,                OPTIONS                        $\n               &SUBOPTS,                DEFAULT SUBROUTINE OPTIONS     $\n               &BASEREG,                BASE REGS                      $\n               &PWAREG,                 PWA REGS                       $\n               &SVAREA,                 SAVE AREA TAG NAME             $\n               &CPYRGHT,                COPYRIGHT NOTICE               $\n               &AMODE,                  ADDRESSING MODE                $\n               &RMODE,                  RESIDENCE MODE                 $\n               &R1SAVE,                 PARM SAVE REGISTER             $\n               &SMWA,                   STRUCTURED MACRO WORK AREA     $\n               &DYNSIZE,                SIZE OF DYNAMIC STORAGE        $\n               &DYNERR,                 DYNAMIC STORAGE ERROR EXIT     $\n               &SWAREG,                 SWA BASE REGS                  $\n               &PWASP                   PROGRAM WORK AREA SUB POOL\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1986.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##PPPLI\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##PPPLI\n.*\n.*  PURPOSE    INTERNAL MACRO USED AS THE DEFAULT FOR PROGRAM BLOCK\n.*             PROLOG.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   12/18/86 MGG - BROKEN APART FROM BLOCK MACRO AND\n.*                            RESTRUCTURED\n.*              5/08/89 MGG - REMOVED &WAID AND &SDID PARAMETERS    @C1\n.*                            AND CHANGED &PBWAID REFERENCES TO     @C1\n.*                            &PWA.  ADDED PSD TAG.                 @C1\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &#BAMODE(20)             ADDRESSING MODE OF BLOCK\n         GBLA  &#BLVL                   BLOCK LEVEL\n         GBLA  &#BNDX(20)               BLOCK TAG INDEXS\n         GBLA  &#MNDX                   LAST TAG INDEX USED\n         GBLA  &#PB#C                   PROGRAM BLOCK NUMBER\n         GBLC  &#PBAMOD                 AMODE OF PROGRAM\n         GBLB  &#PBDSWA       ENDPWA SHOULD DEFINE STORAGE FOR PWA\n         GBLB  &#PBDYN                  DYNAMIC STORAGE OPTION\n         GBLB  &#PBLOCR                 DO LOCATR IN PROGRAM\n         GBLB  &#PBLONG                 LONG PROGRAM OPTION\n         GBLB  &#PBMAIN                 MAIN OPTION\n         GBLC  &#PBNAME                 PROGRAM BLOCK CSECT NAME\n         GBLA  &#PBPLMX                 MAX PL ENTRIES IN PROGRAM\n         GBLB  &#PBPWA                  PWA OPTION\n         GBLC  &#PBRMOD                 RMODE OF PROGRAM\n         GBLC  &#PBSMWA                 TAG OF SMWA\n         GBLB  &#PBVL                   DEFAULT VL OPTION\n         GBLC  &PWA                     PWA ID                      @C1\n         GBLC  &PSD                     PSD ID                      @C1\n         GBLA  &#PBWAMX                 MAX SMWA IN PROGRAM\n         GBLB  &#PBXA                   XA OPTION\n         GBLB  &#PB370                  370 OPTION\n         GBLB  &#SBSU                   SAVEUSING OPTION\n         LCLA  &CTR                     WORK COUNTER\n         LCLA  &NDX                     #MNDX VALUE AT START OF MACRO\n         LCLB  &OCLRPWA                 CLEARPWA OPTION\n         LCLB  &OID                     ID OPTION\n         LCLB  &OMODE                   MODE OPTION\n         LCLC  &OPT                     OPTIONS WORK FIELD\n         LCLB  &OREGEQU                 REGEQU OPTION\n         LCLC  &PGMN                    PROGRAM NAME\n         LCLC  &PWAL                    TAG FOR DC FOR PWA LENGTH\n         LCLC  &TAG                     WORK TAG\n.*--------------------------------------------------------------------*\n&NDX     SETA  &#MNDX                   SAVE INDEX VALUE TO USE\n.*--------------------------------------------------------------------*\n.*  RESET REGISTERS USED.  R12-R1 ARE RESERVED.\n.*--------------------------------------------------------------------*\n         ##MREG RESET                   RESET REGISTERS USED\n         ##MREG USE,R12                 RESERVED FOR TCA\n.*--------------------------------------------------------------------*\n.*  SET FLAGS THAT ARE ALWAYS CONSTANT FOR ENVIRON=PLI\n.*--------------------------------------------------------------------*\n&#PBPWA  SETB  1  ALWAYS HAVE PWA\n&#PBDYN  SETB  0  ALWAYS OFF\n&#PBDSWA SETB  0  NEVER DS PROGRAM WORK AREA\n&#PBMAIN SETB  0  NEVER USER MAIN\n.*--------------------------------------------------------------------*\n.*  SET DEFAULTS FOR GLOBAL OPTIONS.\n.*--------------------------------------------------------------------*\n&#PBXA   SETB  0\n&#PB370  SETB  0\n&#PBVL   SETB  0\n&#PBLONG SETB  0\n&#PBLOCR SETB  0\n.*--------------------------------------------------------------------*\n.*  SET VARIOUS VARIABLES.\n.*--------------------------------------------------------------------*\n&#PBPLMX SETA  0  RESET MAXIMUM PARMS TO ZERO\n&#PBWAMX SETA  2\n&#PBSMWA SETC  '#PBW&#PB#C'\n&#SBUSWA SETB  0  RESET\n&#SBSU   SETB  0  RESET\n&#PBRMOD SETC  '&RMODE'\n&#PBAMOD SETC  '&AMODE'\n&#BAMODE(1) SETC '&AMODE'\n.*--------------------------------------------------------------------*\n.*  CHECK FOR IGNORED KEYWORDS\n.*--------------------------------------------------------------------*\n         ##IGMSG &SVAREA,SVAREA\n         ##IGMSG &R1SAVE,R1SAVE\n         ##IGMSG &SMWA,SMWA\n         ##IGMSG &DYNSIZE,DYNSIZE\n         ##IGMSG &DYNERR,DYNERR\n         ##IGMSG &SWAREG,SWAREG\n         ##IGMSG &PWASP,PWASP\n.*--------------------------------------------------------------------*\n.*  SET OPTIONS.\n.*--------------------------------------------------------------------*\n&CTR     SETA  1                        SET OPTIONS\n.SPO0010 AIF   (N'&OPTIONS LT &CTR).SPO9999\n&OPT     SETC  '&OPTIONS(&CTR)'\n.SPO0020 AIF   ('&OPT' NE 'REGEQU').SPO0030\n&OREGEQU SETB  1\n         AGO   .SPO9000\n.SPO0030 AIF   ('&OPT' NE 'NOREGEQU').SPO0040\n&OREGEQU SETB  0\n         AGO   .SPO9000\n.SPO0040 AIF   ('&OPT' NE 'CLEARPWA').SPO0050\n&OCLRPWA SETB  1\n         AGO   .SPO9000\n.SPO0050 AIF   ('&OPT' NE 'NOCLEARPWA').SPO0060\n&OCLRPWA SETB  0\n         AGO   .SPO9000\n.SPO0060 AIF   ('&OPT' NE 'ID').SPO0070\n&OID     SETB  1\n         AGO   .SPO9000\n.SPO0070 AIF   ('&OPT' NE 'NOID').SPO0100\n&OID     SETB  0\n         AGO   .SPO9000\n.SPO0100 AIF   ('&OPT' NE 'MODE').SPO0110\n&OMODE   SETB  1\n         AGO   .SPO9000\n.SPO0110 AIF   ('&OPT' NE 'NOMODE').SPO0120\n&OMODE   SETB  0\n         AGO   .SPO9000\n.SPO0120 AIF   ('&OPT' NE 'XA').SPO0130\n&#PBXA   SETB  1\n         AGO   .SPO9000\n.SPO0130 AIF   ('&OPT' NE 'NOXA').SPO0140\n&#PBXA   SETB  0\n         AGO   .SPO9000\n.SPO0140 AIF   ('&OPT' NE '370').SPO0150\n&#PB370  SETB  1\n         AGO   .SPO9000\n.SPO0150 AIF   ('&OPT' NE 'NO370').SPO0160\n&#PB370  SETB  0\n         AGO   .SPO9000\n.SPO0160 AIF   ('&OPT' NE 'VL').SPO0170\n&#PBVL   SETB  1\n         AGO   .SPO9000\n.SPO0170 AIF   ('&OPT' NE 'NOVL').SPO0180\n&#PBVL   SETB  0\n         AGO   .SPO9000\n.SPO0180 AIF   ('&OPT' NE 'LOCTR').SPO0190\n&#PBLOCR SETB  1\n         AGO   .SPO9000\n.SPO0190 AIF   ('&OPT' NE 'NOLOCTR').SPO0200\n&#PBLOCR SETB  0\n         AGO   .SPO9000\n.SPO0200 AIF   ('&OPT' NE 'LONG').SPO0210\n&#PBLONG SETB  1\n         AGO   .SPO9000\n.SPO0210 AIF   ('&OPT' NE 'NOLONG').SPO0220\n&#PBLONG SETB  0\n         AGO   .SPO9000\n.SPO0220 ANOP\n.SPO0500 AIF   ('&OPT' NE '*STDPLI').SPO0510\n&OCLRPWA SETB  1         CLEARPWA OPTION\n&OID     SETB  1         ID OPTION\n&OREGEQU SETB  1         REGEQU OPTION\n&OMODE   SETB  1         MODE OPTION\n&#PBXA   SETB  0         NOXA OPTION\n&#PB370  SETB  0         NO370 OPTION\n&#PBVL   SETB  1         VL OPTION\n&#PBLOCR SETB  1         LOCTR OPTION\n&#PBLONG SETB  0         NOLONG OPTION\n         AGO   .SPO9000\n.SPO0510 ANOP\n         MNOTE 8,'Invalid option &OPT'\n.SPO9000 ANOP\n&CTR     SETA  &CTR+1\n         AGO   .SPO0010\n.SPO9999 ANOP\n.*------------------------------------------------------------------\n.*  SET DEFAULT SUBROUTINE OPTIONS BASED ON SUBOPT\n.*------------------------------------------------------------------\n         ##SUBOPT &SUBOPTS,DEFAULT=YES\n.*------------------------------------------------------------------\n.*  CHECK OPTIONS AND KEYWORDS\n.*------------------------------------------------------------------\n         AIF   ('&BASEREG' EQ '').CHK0100\n         AIF   ('&BASEREG(1)' EQ 'R11').CHK0100\n         MNOTE 8,'With ENVIRON=PLI, first BASEREG must be R11'\n.CHK0100 ANOP\n         AIF   ('&BASEREG' EQ '').CHK0200\n         AIF   ('&BASEREG(1)' EQ 'R11').CHK0200\n         MNOTE 8,'With ENVIRON=PLI, first PWAREG must be R13'\n.CHK0200 ANOP\n&PGMN    SETC  '&NAME'\n         AIF   ('&NAME' NE '').CHK0300\n         MNOTE 8,'Name required on program block macro'\n&PGMN    SETC  'TEMPNAM'\n.CHK0300 ANOP\n.*--------------------------------------------------------------------*\n.*  GENERATE CSECT, AMODE, RMODE, AND LOCTR STATEMENTS.\n.*--------------------------------------------------------------------*\n.INT0000 ANOP\n&#PBNAME SETC  '&PGMN.1'                                            @C1\n&#PBNAME CSECT ,                        START OF CSECT\n.INT0100 AIF   (NOT &#PBLOCR).INT0105\n&#PBNAME LOCTR ,                        LOCTR FOR PROGRAM BLOCK INST\n         PSD   TYPE=PARTIAL\n&PSD     EQU   *                                                    @C1\n         ENDPSD ,\n.INT0105 AIF   ('&AMODE' EQ '' AND '&RMODE' EQ '').INT0200\n         AIF   (&OMODE).INT0110\n         MNOTE 4,'RMODE and AMODE ignored if MODE option not specified'\n         AGO   .INT0200\n.INT0110 AIF   (&#PBXA).INT0120\n         MNOTE 4,'RMODE and AMODE ignored if XA option not specified'\n         AGO   .INT0200\n.INT0120 AIF   ('&AMODE' EQ '').INT0130\n&PGMN    AMODE &AMODE                   ADDRESSING MODE\n.INT0130 ANOP\n&#PBAMOD SETC  '24'\n         AGO   .INT0140\n         AIF   ('&RMODE' EQ 'ANY').INT0140\n&#PBAMOD SETC  '31'\n.INT0140 AIF   ('&RMODE' EQ '').INT0150\n&PGMN    RMODE &RMODE                   RESIDENCE MODE\n         AGO   .INT0180\n.INT0150 ANOP\n&#PBRMOD SETC  '24'\n.INT0180 AGO   .INT0900\n.INT0200 ANOP\n&#PBRMOD SETC  '24'\n&#PBAMOD SETC  '24'\n.INT0900 ANOP\n*---------------------------------------------------------------------*\n*  PL/I TO ASSEMBLER INITIALIZATION                                   *\n*                                                                     *\n*  MORE INFORMATION ABOUT THIS INITIALIZATION CAN BE FOUND IN THE     *\n*  OS PL/I OPTIMIZING COMPILER: PROGRAMMER'S GUIDE AND                *\n*  OS PL/I OPTIMIZING COMPILER: EXECUTION LOGIC'.                     *\n*                                                                     *\n*  THIS INITIALIZATION FOLLOWS RECOMMENDATIONS STATED IN THE          *\n*  PROGRAMMER'S GUIDE.  THIS INITIALIZATION IS REENTRENT.             *\n*                                                                     *\n*---------------------------------------------------------------------*\n.*--------------------------------------------------------------------*\n.*  ENTRY POINT MUST BE PRECEEDED BY THE ENTRY POINT NAME.  THIS IS\n.*  SO THE ERROR MESSAGE AND PLIDUMP CAN USE THE NAME IN THEIR PRINT.\n.*--------------------------------------------------------------------*\n&LENNAME SETA  (K'&PGMN/2)*2+1          GET ODD LENGTH >= ACTUAL\n         DC    CL&LENNAME'&PGMN'        ENTRY NAME\n         DC    AL1(&LENNAME)\n.*--------------------------------------------------------------------*\n.*  THE FOLLOWING TAG REPRESENTS THE START OF EXECUTABLE INSTRUCTIONS.\n.*  IT IS THE REAL ENTRY TO CSECT.\n.*--------------------------------------------------------------------*\n         ENTRY &PGMN\n&PGMN    EQU   *                        FIRST EXECUTABLE INSTRUCTION\n         USING &PGMN,R15                ESTABLISH TEMPORARY PGM BASE\n.*--------------------------------------------------------------------*\n.* GENERATE ID AND CONSTANTS.\n.*--------------------------------------------------------------------*\n&TAG     SETC  '#BP&NDX'\n         B     &TAG\n         AIF   (NOT &OID).GID0010\n         DC    C'&SYSDATE &SYSTIME '\n         AIF   ('&CPYRGHT' EQ '').GID0010\n         DC    C&CPYRGHT\n.GID0010 ANOP\n&PWAL    SETC  '#BJ&NDX'\n&PWAL    DC    AL4(&PWA.PLLEN)                                      @C1\n&TAG     DS    0H\n.*--------------------------------------------------------------------*\n.*  SAVE REGISTERS AND LOAD PROGRAM BASE\n.*--------------------------------------------------------------------*\n         USING &PWA,R13                 ESTABLISH BASE FOR DSA      @C1\n         STM   R14,R12,12(R13)          SAVE REGS IN CALLER'S DSA\n         LR    R11,R15                  LOAD ENTRY ADDRESS\n         DROP  R15                      DROP TEMPORARY PROGRAM BASE\n         ##LDBS &PGMN,&BASEREG,R11      ESTABLISH PROGRAM BASE\n.*--------------------------------------------------------------------*\n.*  GET STORAGE FOR NEW DSA AND INITIALIZE IT\n.*--------------------------------------------------------------------*\n         ICM   R0,B'1111',&PWAL         LOAD LENGTH OF DSA\n         L     R1,&PWA.XANAB            LOAD ADDR OF NAB            @C1\n         ALR   R0,R1                    ADD LENGTH OF DSA TO NAB\n         CL    R0,12(,R12)              COMPARE TO ADDRESS OF LAST BYTE\n&TAG     SETC  '#BS&NDX'\n         BNH   &TAG                     SKIP CALL IF SPACE AVAILABLE\n         L     R15,116(,R12)            LOAD AND BRANCH TO PLI STORAGE\n         BALR  R14,R15                    OVERFLOW ROUTINE TO ATTEMPT\n*                                         TO OBTAIN MORE STORAGE\n         AIF   (NOT &OCLRPWA).PRC0200\n&TAG     ICM   R2,B'1111',&PWAL         LOAD R2 WITH LENGTH OF NEW DSA\n&TAG     SETC  ''\n         LR    R3,R1                    POINT R3 TO NEW DSA\n         SLR   R14,R14                  CLEAR R14\n         SLR   R15,R15                  CLEAR R15\n         MVCL  R2,R14                   CLEAR NEW DSA\n.PRC0200 ANOP\n&TAG     ST    R0,&PWA.XANAB-&PWA.(,R1) STORE NAB IN NEW DSA        @C1\n         ST    R13,&PWA.XBCH-&PWA.(,R1) BACKCHAIN                   @C1\n         MVC   &PWA.XALWS-&PWA.(4,R1),&PWA.XALWS COPY->LWS          @C1\n.*--------------------------------------------------------------------*\n.*  LOAD R13 WITH ADDRESS OF NEW DSA AND PRESERVE PL/I ERROR HANDLING.\n.*--------------------------------------------------------------------*\n         LR    R13,R1                   POINT R13 TO NEW DSA\n         ##LDBS &PWA,&PWAREG,R13        ESTABLISH BASE FOR DSA      @C1\n         MVI   &PWA.XF1A,X'80'          SET FLAGS IN DSA TO         @C1\n         MVI   &PWA.XF1B,X'00'            PRESERVE PL/I             @C1\n         MVI   &PWA.XCEC,X'91'            ERROR-HANDLEING           @C1\n         MVI   &PWA.XCEC+1,X'C0'          IN THE ASSEMBLER ROUTINE  @C1\n.SAM0000 ANOP\n.*--------------------------------------------------------------------*\n.*  GENERATE CODE TO SAVE ADDRESS MODE IF NEEDED\n.*--------------------------------------------------------------------*\n&TAG     SETC  '#BY&#BNDX(&#BLVL)'      MAKE UP TAG\n         AIF   (NOT &#PBXA).SAM0200\n         AIF   (NOT &#PB370).SAM0100\n         L     R15,16                   POINT R15 TO CVT\n         TM    X'74'(R15),X'80'         RUNNING UNDER XA?\n         BZ    &TAG                     SKIP AMODE SETTING\n.SAM0100 ANOP\n         SLR   R15,R15                  CLEAR R15\n         AIF   (NOT &#PBXA).SAM0110\n         BSM   R15,0                    SET AMODE IN HIGH BIT\n.SAM0110 ST    R15,&#PBSMWA+4           SAVE ADDRESS MODE\n         AIF   (NOT &#PB370).SAM0200\n&TAG     DS    0H\n.SAM0200 ANOP\n.SAM0999 ANOP\n.*--------------------------------------------------------------------*\n.*  RESTORE PARMAMETER LIST POINTER\n.*--------------------------------------------------------------------*\n         L     R1,&PWA.XBCH             POINT TO PREVIOUS DSA       @C1\n         L     R1,&PWA.XS1-&PWA.(,R1) RESTORE R1 ON ENTRY           @C1\n.*--------------------------------------------------------------------*\n.*  GENERATE REGISTER EQUATES IF REQUESTED\n.*--------------------------------------------------------------------*\n.REQ0000 AIF   (NOT &OREGEQU).REQ0010\n*---------------------------------------------------------------------*\n*                       W A R N I N G                                 *\n*                                                                     *\n*  REGISTER 12 POINT TO THE TASK COMMUNICATIONS AREA (TCA) AND        *\n*  SHOULD NEVER BE MODIFIED BY THE ASSEMBLER ROUTINE.                 *\n*                                                                     *\n*  REGISTER 13 POINT TO THE CURRENT DYNAMIC STORAGE AREA (DSA)        *\n*  AND SHOULD NEVER BE MODIFIED BY THE ASSEMBLER ROUTINE.             *\n*---------------------------------------------------------------------*\n         ##REGS\n.REQ0010 ANOP\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##PRMOPT": {"ttr": 5638, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x01M\\x01M\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 333, "newlines": 333, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##PRMOPT &OPTIONS=,            PARSE_OPTION PROCESS ONLY      $\n               &PARMS=,                 GENERATE_REST PROCESS ONLY     $\n               &PARMMAP=,               GENERATE_REST PROCESS ONLY     $\n               &TYPE=,                  PARMS TYPE                     $\n               &PROCESS=                SET OR GENERATE\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1989.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##PRMOPT\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##PRMOPT\n.*\n.*  PURPOSE    INTERNAL MACRO USED AS PARSE THE PARMS OPTIONS.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    4/28/89 MGG - NEW\n.*             10/18/89 MJM - Fixed a problem with the PARMMAP      @C1\n.*                            keyword and a problem with its effect @C1\n.*                            on the USING option.                  @C1\n.*             10/19/89 MJM - Added the COUNT suboption of PARMS.   @C2\n.*\n.*--------------------------------------------------------------------*\n         LCLC  &O                       OPTION PREFIX\n         LCLC  &D                       DEFAULT OPTION PREFIX\n&O       SETC  '&TYPE'(1,1)\n&D       SETC  '#&O.D'                  PREFIX FOR DEFAULT PARMS OPTS\n&O       SETC  '#&O.O'                  PREFIX FOR PARMS OPTIONS\n         GBLC  &(&O.BASE)               PARM BASE REGISTER\n         GBLB  &(&O.OPT)                PARM PARMS OPTION SPECIFIED\n         GBLB  &(&O.VL)                 PARM VL OPTION\n         GBLB  &(&O.COPY)               PARM COPY OPTION\n         GBLC  &(&O.COUNT)              PARM COUNT OPTION           @C2\n         GBLB  &(&O.PFX)                PARM PREFIX OPTION\n         GBLC  &(&O.CERX)               ERROR EXIT NAME\n         GBLC  &(&O.CERC)               ERROR EXIT CODE\n         GBLC  &(&D.BASE)               DEFAULT BASE REGISTER\n         GBLB  &(&D.OPT)                DEFAULT DEFAULTS OPTION\n         GBLB  &(&D.VL)                 DEFAULT VL OPTION\n         GBLB  &(&D.COPY)               DEFAULT COPY OPTION\n         GBLC  &(&D.COUNT)              DEFAULT COUNT OPTION        @C2\n         GBLB  &(&D.PFX)                DEFAULT PREFIX OPTION\n         GBLC  &(&D.CERX)               DEFAULT ERROR EXIT NAME\n         GBLC  &(&D.CERC)               DEFAULT ERROR EXIT CODE\n         GBLC  &#PBNAME                 PROGRAM BLOCK NAME\n         GBLA  &#BLVL                   BLOCK LEVEL\n         LCLC  &PREFIX                  PREFIX\n         LCLC  &TAG                     WORK TAG\n         LCLA  &CTR                     WORK COUNTER\n         AIF   ('&TYPE' NE 'PROGRAM').NOT_PROGRAM\n&WAOPT   SETC  '##PBPWA'\n&WA      SETC  'PWA'\n&PARMTAG SETC  'PPL'\n         AGO   .DSECT_GLOBALS\n.NOT_PROGRAM ANOP\n         AIF   ('&TYPE' NE 'SUBROUTINE').NOT_SUBROUTINE\n&WAOPT   SETC  '##SBSWA'\n&WA      SETC  'SWA'\n&PARMTAG SETC  'SPL'\n         AGO   .DSECT_GLOBALS\n.NOT_SUBROUTINE ANOP\n         AGO  .CEROR1\n.DSECT_GLOBALS ANOP\n         GBLB  &(&WAOPT)\n         GBLC  &(&WA)\n         GBLC  &(&PARMTAG)\n.*\n.*  Branch to the correct PROCESS= code.\n.*\n         AIF   ('&PROCESS' EQ 'RESET'                     ).RES0000\n         AIF   ('&PROCESS' EQ 'SET_TO_SUBROUTINE_DEFAULTS').STD0000\n         AIF   ('&PROCESS' EQ 'SET_SUBROUTINE_DEFAULTS'   ).SSD0000\n         AIF   ('&PROCESS' EQ 'PARSE_OPTIONS'             ).POP0000\n         AIF   ('&PROCESS' EQ 'GENERATE'                  ).RST0000\n         AGO  .CEROR3\n.*--------------------------------------------------------------------*\n.*  PROCESS=RESET.\n.*--------------------------------------------------------------------*\n.RES0000    ANOP                    Process=RESET:\n&(&O.OPT)   SETB 0                    Indicate PARMS option off.\n&(&O.VL)    SETB 0                    Indicate NOVL\n&(&O.COPY)  SETB 0                    Indicate NOCOPY\n&(&O.COUNT) SETC ''                   Indicate NOCOUNT              @C2\n&(&O.PFX)   SETB 0                    Indicate NOPREFIX\n&(&O.BASE)  SETC ''                   Indicate NOUSING\n&(&O.CERX)  SETC ''                   Indicate NOCOPYERROR name.\n&(&O.CERC)  SETC ''                   Indicate NOCOPYERROR code.\n            MEXIT                   End of process=RESET.\n.*--------------------------------------------------------------------*\n.*  PROCESS=SET_TO_SUBROUTINE_DEFAULTS\n.*--------------------------------------------------------------------*\n.STD0000    ANOP                    Process=SET_TO_SUBROUTINE_DEFAULTS\n&(&O.BASE)  SETC '&(&D.BASE)'         Parm default base register.\n&(&O.OPT)   SETB (&(&D.OPT))          Parm default PARMS option.\n&(&O.VL)    SETB (&(&D.VL))           Parm default VL option.\n&(&O.COPY)  SETB (&(&D.COPY))         Parm default COPY option.\n&(&O.COUNT) SETC '&(&D.COUNT)'        Parm default COUNT option.    @C2\n&(&O.PFX)   SETB (&(&D.PFX))          Parm default PREFIX option.\n&(&O.CERX)  SETC '&(&D.CERX)'         Parm default ERROR EXIT name.\n&(&O.CERC)  SETC '&(&D.CERC)'         Parm default ERROR EXIT code.\n            MEXIT                   End of SET_TO_SUBROUTINE_DEFAULTS.\n.*--------------------------------------------------------------------*\n.*  PROCESS=SET_SUBROUTINE_DEFAULTS\n.*--------------------------------------------------------------------*\n.SSD0000    ANOP                    Process=SET_SUBROUTINE_DEFAULTS\n&(&D.BASE)  SETC '&(&O.BASE)'         Parm default base register.\n&(&D.OPT)   SETB (&(&O.OPT))          Parm default PARMS option.\n&(&D.VL)    SETB (&(&O.VL))           Parm default VL option.\n&(&D.COPY)  SETB (&(&O.COPY))         Parm default COPY option.\n&(&D.COUNT) SETC '&(&O.COUNT)'        Parm default COUNT option.    @C2\n&(&D.PFX)   SETB (&(&O.PFX))          Parm default PREFIX option.\n&(&D.CERX)  SETC '&(&O.CERX)'         Parm default ERROR EXIT name.\n&(&D.CERC)  SETC '&(&O.CERC)'         Parm default ERROR EXIT code.\n            MEXIT                   End of SET_SUBROUTINE_DEFAULTS.\n.*--------------------------------------------------------------------*\n.*  PROCESS=PARSE_OPTIONS.\n.*--------------------------------------------------------------------*\n.POP0000   ANOP                    Process=PARSE_OPTIONS.\n           AIF   ('&OPTIONS(1)' NE 'PARMS').CEROR4\n&(&O.OPT)  SETB  1\n&CTR       SETA  2                        SET COUNTER TO 1\n.POP1000   AIF   (&CTR GT N'&OPTIONS).POP7000\n           AIF   ('&OPTIONS(&CTR)'   EQ 'VL'          ).POP1100\n           AIF   ('&OPTIONS(&CTR)'   EQ 'NOVL'        ).POP1110\n           AIF   ('&OPTIONS(&CTR)'   EQ 'COPY'        ).POP1120\n           AIF   ('&OPTIONS(&CTR)'   EQ 'NOCOPY'      ).POP1130\n           AIF   ('&OPTIONS(&CTR,1)' EQ 'COUNT'       ).POP1140     @C2\n           AIF   ('&OPTIONS(&CTR)'   EQ 'NOCOUNT'     ).POP1150     @C2\n           AIF   ('&OPTIONS(&CTR,1)' EQ 'USING'       ).POP1160\n           AIF   ('&OPTIONS(&CTR)'   EQ 'NOUSING'     ).POP1170\n           AIF   ('&OPTIONS(&CTR)'   EQ 'PREFIX'      ).POP1180\n           AIF   ('&OPTIONS(&CTR)'   EQ 'NOPREFIX'    ).POP1190\n           AIF   ('&OPTIONS(&CTR,1)' EQ 'COPYERROR'   ).POP1200\n           AIF   ('&OPTIONS(&CTR)'   EQ 'NOCOPYERROR' ).POP1210\n           MNOTE 8,'&OPTIONS(&CTR) is an invalid suboption of the PARMS$\n                option'\n           AGO   .POP1900               Check next option.\n.*\n.POP1100    ANOP                         VL Option:\n&(&O.VL)    SETB  1                        Indicate VL\n            AGO   .POP1900                 Check next option.\n.POP1110    ANOP                         NOVL Option:\n&(&O.VL)    SETB  0                        Indicate NOVL\n            AGO   .POP1900                 Check next option.\n.POP1120    ANOP                         COPY Option:\n&(&O.COPY)  SETB  1                        Indicate COPY\n            AGO   .POP1900                 Check next option.\n.POP1130    ANOP                         NOCOPY Option:\n&(&O.COPY)  SETB  0                        Indicate NOCOPY\n            AGO   .POP1900                 Check next option.\n.POP1140    ANOP                         COUNT Option:              @C2\n            AIF   (N'&OPTIONS(&CTR) EQ 2).POP1142                   @C2\n            MNOTE 8,'(COUNT,tag) option requires two parameters'    @C2\n            AGO   .POP1900                 Check next option.       @C2\n.POP1142    ANOP                           Count tag was specified. @C2\n&(&O.COUNT) SETC '&OPTIONS(&CTR,2)'        Indicate NOCOUNT.        @C2\n            AGO   .POP1900                 Check next option.       @C2\n.POP1150    ANOP                         NOCOUNT Option:            @C2\n&(&O.COUNT) SETC ''                        Indicate NOCOUNT.        @C2\n            AGO   .POP1900                 Check next option.       @C2\n.POP1160    ANOP                         USING Option:\n            AIF   (N'&OPTIONS(&CTR) EQ 2).POP1162\n            MNOTE 8,'USING option requires two parameters'\n            AGO   .POP1900                 Check next option.\n.POP1162    ANOP                           Base register was specified.\n&(&O.BASE)  SETC  '&OPTIONS(&CTR,2)'       Set parm base register.\n            AGO   .POP1900                 Check next option.\n.POP1170    ANOP                         NOUSING Option:\n&(&O.BASE)  SETC  ''                       Indicate NOUSING\n            AGO   .POP1900                 Check next option.\n.POP1180    ANOP                         PREFIX Option:\n&(&O.PFX)   SETB  1                        Indicate PREFIX\n            AGO   .POP1900                 Check next option.\n.POP1190    ANOP                         NOPREFIX Option:\n&(&O.PFX)   SETB  0                        Indicate NOPREFIX\n            AGO   .POP1900                 Check next option.\n.POP1200    ANOP                         COPYERROR Option:\n            AIF   (N'&OPTIONS(&CTR) GT 3).POP1202\n            AIF   (N'&OPTIONS(&CTR) GE 2).POP1204\n.POP1202    MNOTE 8,'COPYERROR option requires two or three parameters'\n            AGO   .POP1900                 Check next option.\n.POP1204    ANOP                           Right number of parameters.\n&(&O.CERX)  SETC '&OPTIONS(&CTR,2)'        Indicate exit name.\n&(&O.CERC)  SETC '&OPTIONS(&CTR,3)'        Indicate exit code.\n            AGO   .POP1900                 Check next option.\n.POP1210    ANOP                         NOCOPYERROR Option:\n&(&O.CERX)  SETC  ''                       Indicate no exit name.\n&(&O.CERC)  SETC  ''                       Indicate no exit code.\n            AGO   .POP1900                 Check next option.\n.*\n.POP1900    ANOP\n&CTR        SETA  &CTR+1                 Increment counter.\n            AGO   .POP1000               Return to top-of-loop.\n.POP7000    ANOP\n.POP9000    MEXIT                     End of PARSE_OPTIONS.\n.*--------------------------------------------------------------------*\n.*  PROCESS=GENERATE\n.*--------------------------------------------------------------------*\n.RST0000 ANOP                        Process=GENERATE.\n         AIF   (&(&O.OPT)).RST0010\n         AIF   ('&PARMS' EQ '' AND '&PARMMAP' EQ '').RST9000\n         MNOTE 8,'PARMS and PARMMAP keywords require the PARMS option'\n         AGO   .RST9000\n.RST0010 ANOP\n.**-----------------------------------------------------------------\n.**  LOAD PARAMETER LIST BASE AND ESTABLISH ADDRESSIBILITY AS\n.**  REQUESTED.\n.**-----------------------------------------------------------------\n         AIF   ('&(&O.BASE)' EQ '').RST0080\n         AIF   (&(&O.COPY)).RST0020\n         LR    &(&O.BASE),R1            LOAD PARM LIST BASE\n         AGO   .RST0030\n.RST0020 LA    &(&O.BASE),&(&PARMTAG)   POINT TO COPY OF PARM LIST\n.RST0030 AIF   ('&PARMMAP' NE '').RST0040                           @C1\n         USING &(&PARMTAG),&(&O.BASE)   ESTABLISH BASE FOR PARM LIST@C1\n         AGO   .RST0080                                             @C1\n.RST0040 USING &PARMMAP(1).,&(&O.BASE)  ESTABLISH BASE FOR PARMMAP  @C1\n.**-----------------------------------------------------------------\n.**  PROCESS THE PARMS KEYWORD, IF SPECIFIED.\n.**-----------------------------------------------------------------\n.RST0080 AIF   ('&PARMS' EQ '').RST1000\n         AIF   ('&PARMMAP' EQ '').RST0090\n         MNOTE 8,'PARMS and PARMMAP keywords are mutually exclusive'\n.RST0090 ANOP\n         AIF   (&(&O.COPY)).RST0100\n&(&PARMTAG)  DSECT ,                    PARAMETER LIST DSECT\n         AGO   .RST0190\n.RST0100 &WA   TYPE=PARTIAL             BUILD LIST IN WORK AREA\n         DS    0F                       INSURE FULLWORD ALIGNMENT\n&X       SETA  N'&PARMS*4\n&(&PARMTAG) EQU *,&X                    DEFINE TAG FOR PARAMETER LIST\n.RST0190 ANOP\n.* START OF LOOP\n&CTR     SETA  0\n&PREFIX  SETC  ''\n         AIF   (NOT &(&O.PFX)).RST0200\n&PREFIX  SETC  '&(&PARMTAG)'\n.RST0200 AGO   .RST0480\n.RST0400 ANOP\n&TAG     SETC  '&PREFIX.&PARMS(&CTR)'\n&TAG     DS    A                         PARAMETER ADDRESS\n.RST0480 ANOP\n&CTR     SETA  &CTR+1\n         AIF   (&CTR LE N'&PARMS).RST0400\n.* END OF LOOP\n         AIF   (&(&O.COPY)).RST0570\n&#PBNAME CSECT ,                        GET BACK IN PROGRAM CSECT\n         AGO   .RST0590\n.RST0570 END&WA ,                       GET OUT OF WORK AREA\n.RST0590 ANOP\n.RST1000 ANOP\n.**-----------------------------------------------------------------\n.**  PROCESS THE PARMMAP KEYWORD, IF SPECIFIED.\n.**-----------------------------------------------------------------\n         AIF   ('&PARMMAP' EQ '').RST1900\n         AIF   (N'&PARMMAP LE 2).RST1010\n         MNOTE 8,'Too many parameters specified on PARMMAP keyword'\n.RST1010 ANOP\n         AIF   (&(&O.COPY)).RST1020\n&(&PARMTAG) EQU &PARMMAP(1)\n         AGO   .RST1900\n.RST1020 ANOP\n         AIF   (N'&PARMMAP EQ 2).RST1030\n         MNOTE 8,'Second parameter required on PARMMAP keyword if COPY *\n               PARMS option is specified'\n         AGO   .RST1900\n.RST1030    &WA TYPE=PARTIAL             DEFINE FIELD IN WORK AREA\n            DS  0F                       INSURE FULLWORD ALIGNMENT\n&(&PARMTAG) DS  XL(&PARMMAP(2).)         DEFINE FIELD FOR COPY      @C1\n            END&WA ,                     GET OUT OF WORK AREA\n.RST1900 ANOP\n.RST2000 ANOP\n.**-----------------------------------------------------------------\n.**  Implement the COPY (VL or NOVL) and COUNT (VL only) options.   @C2\n.**-----------------------------------------------------------------\n&TAG     SETC  '##PRMOPT_PARMS_&SYSNDX._'\n         AIF   (&(&O.VL)).RST2100\n         AIF   ('&(&O.COUNT)' EQ '').RST2050                        @C2\n         MNOTE 8,'COUNT option requires the VL option.'             @C2\n.RST2050 AIF   (NOT &(&O.COPY)).RST2900\n         MVC   &(&PARMTAG).,0(R1)       | Move parms to copy area.\n         AGO   .RST2900\n.RST2100 AIF   (NOT &(&O.COPY)).RST2200\n         AIF   ('&(&O.CERX)' EQ '' AND '&(&O.CERC)' EQ '').CEROR5\n         XC    &(&PARMTAG).,&(&PARMTAG) | Clear parmlist area.\n         SLR   R15,R15                  | Clear index register.\n&TAG.000 DS    0H                       | Loop over parameters.\n         L     R0,0(R15,R1)             |   Load parameter from input.\n         ST    R0,&(&PARMTAG).(R15)     |   Store in copy area.\n         LTR   R0,R0                    |   Check for final parm.\n         BM    &TAG.100                 |   Finish up if last one.\n         LA    R15,4(R15)               |   Increment index register.\n         CH    R15,=Y(L'&(&PARMTAG.).)  |   Check for overflow.\n         BL    &TAG.000                 | Continue looping if okay.\n         ERREXIT NAME=&(&O.CERX),CODE=&(&O.CERC)  CopyError exit.\n&TAG.100 DS    0H                       | Finished with VL copying.\n         AIF   ('&(&O.COUNT)' EQ '').RST2170                        @C2\n         LA    R0,4(,R15)               | R0 := length of parmlist. @C2\n         SRL   R0,2                     | R0 := number of parms.    @C2\n         ST    R0,&(&O.COUNT)           | Store in COUNT tag.       @C2\n.RST2170 LA    R15,&(&PARMTAG).(R15)    | Get address of final parm.\n         NI    0(R15),X'7F'             | Turn off the VL bit.\n         AGO   .RST2900\n.RST2200 AIF   ('&(&O.COUNT)' EQ '').RST2900\n         LR    R15,R1                   | R15 -> Start of parmlist. @C2\n&TAG.000 TM    0(R15),X'80'             | Test for VL bit.          @C2\n         LA    R15,4(,R15)              | Point to next parameter.  @C2\n         BNO   &TAG.000                 | Loop if not past VL bit.  @C2\n         SLR   R15,R1                   | R15 := parmlist length.   @C2\n         SRL   R15,2                    | R15 := number of parms.   @C2\n         ST    R15,&(&O.COUNT)          | Store in COUNT tag.       @C2\n.RST2900 ANOP\n.*\n.RST9000 MEXIT                          End of Process=GENERATE.\n.*--------------------------------------------------------------------*\n.CEROR1  MNOTE 8,'&TYPE is invalid'\n         MEXIT\n.CEROR2  MNOTE 8,'##PRMOPT does not support &OPTIONS(1) option'\n         MEXIT\n.CEROR3  MNOTE 8,'&PROCESS is an invalid value for PROCESS keyword'\n         MEXIT\n.CEROR4  MNOTE 8,'The first parameter in PARM options must be PARMS'\n         MEXIT\n.CEROR5  MNOTE 8,'COPYERROR is required for (PARMS,COPY,VL) options.'\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##REGS": {"ttr": 5644, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00'\\x00'\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##REGS\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##REGS\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##REGS\n.*\n.*  PURPOSE    INTERNAL MACRO USED TO GENERATE REGISTER EQUATES.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - NEW  MGG\n.*\n.*--------------------------------------------------------------------*\nR0       EQU   0                        EQUATE FOR REGISTER 0\nR1       EQU   1                        EQUATE FOR REGISTER 1\nR2       EQU   2                        EQUATE FOR REGISTER 2\nR3       EQU   3                        EQUATE FOR REGISTER 3\nR4       EQU   4                        EQUATE FOR REGISTER 4\nR5       EQU   5                        EQUATE FOR REGISTER 5\nR6       EQU   6                        EQUATE FOR REGISTER 6\nR7       EQU   7                        EQUATE FOR REGISTER 7\nR8       EQU   8                        EQUATE FOR REGISTER 8\nR9       EQU   9                        EQUATE FOR REGISTER 9\nR10      EQU   10                       EQUATE FOR REGISTER 10\nR11      EQU   11                       EQUATE FOR REGISTER 11\nR12      EQU   12                       EQUATE FOR REGISTER 12\nR13      EQU   13                       EQUATE FOR REGISTER 13\nR14      EQU   14                       EQUATE FOR REGISTER 14\nR15      EQU   15                       EQUATE FOR REGISTER 15\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "##RST": {"ttr": 5889, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00^\\x00^\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 94, "newlines": 94, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n&NAME    ##RST &R15=YES,&LVL=\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##RST\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##RST\n.*\n.*  PURPOSE    INTERNAL MACRO USED TO RESTORE REGISTERS.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - NEW  MGG\n.*              7/14/84 MGG - DEFINED &CNT\n.*              7/15/85 MGG - MADE IT GENERATE L INSTEAD OF LM\n.*                            IF ONLY ONE REGISTER IS INVOLVED\n.*              1/08/87 MGG - SOME CLEANUP.  REMOVED @CN.\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#BLVL                   BLOCK LEVEL\n         GBLC  &#BSV1(20)               BLOCK SAVE PARM 1\n         GBLC  &#BSV2(20)               BLOCK SAVE PARM 2\n         GBLC  &#BSV3(20)               BLOCK SAVE PARM 3\n         GBLA  &#MCVREG                 CONVERTED REGISTER\n         LCLC  &WRK                     WORK FIELD\n         LCLC  &O1                      OPERAND 1 WORK FIELD\n         LCLC  &O2                      OPERAND 2 WORK FIELD\n         LCLC  &O3                      OPERAND 3 WORK FIELD\n         LCLA  &WKLVL                   WORK BLOCK LEVEL\n         LCLC  &TAG                     WORK TAG\n         LCLA  &CNT                     WORK COUNTER\n&TAG     SETC  '&NAME'                  SET TAG\n&WKLVL   SETA  &#BLVL\n         AIF   ('&LVL' EQ '').PRC0010\n&WKLVL   SETA  &LVL\n.PRC0010 ANOP\n         AIF   ('&#BSV1(&WKLVL)' EQ '').PRC2000\n         AIF   ('&#BSV3(&WKLVL)' EQ '').PRC1000\n         AIF   ('&R15' EQ 'YES').PRC0100\n         AIF   ('&#BSV1(&WKLVL)' EQ 'R15').PRC3000\n         AIF   ('&#BSV2(&WKLVL)' EQ 'R15').PRC4000\n         AIF   (K'&#BSV1(&WKLVL) GT K'&#BSV2(&WKLVL)).PRC5000\n         AIF   ('&#BSV1(&WKLVL)' GT '&#BSV2(&WKLVL)').PRC5000\n.PRC0100 ANOP\n&O1      SETC  '&#BSV1(&WKLVL)'\n&O2      SETC  '&#BSV2(&WKLVL)'\n&O3      SETC  '&#BSV3(&WKLVL)'\n         AGO   .LM\n.PRC1000 AIF   ('&R15' EQ 'NO' AND '&#BSV1(&WKLVL)' EQ 'R15').PRC2000\n&O1      SETC  '&#BSV1(&WKLVL)'\n&O2      SETC  '&#BSV1(&WKLVL)'\n&O3      SETC  '&#BSV2(&WKLVL)'\n         AGO   .LM\n.PRC2000 AIF   ('&TAG' EQ '').EXIT\n&TAG     DS    0H                       NO REGISTERS RESTORED\n         AGO   .EXIT\n.PRC3000 ANOP\n&O1      SETC  'R0'\n&O2      SETC  '&#BSV2(&WKLVL)'\n&O3      SETC  '4+&#BSV3(&WKLVL)'\n         AGO   .LM\n.PRC4000 ANOP\n&O1      SETC  '&#BSV1(&WKLVL)'\n&O2      SETC  'R14'\n&O3      SETC  '&#BSV3(&WKLVL)'\n         AGO   .LM\n.PRC5000 ANOP\n         AIF   ('&#BSV1(&WKLVL)' EQ 'R14').PRC5010\n&WRK     SETC  '&#BSV1(&WKLVL),R14,&#BSV3(&WKLVL)'\n&TAG     LM    &WRK                     RESTORE REGISTER(S)\n         AGO   .PRC5020\n.PRC5010 ANOP\n&TAG     L     R14,&#BSV3(&WKLVL)       RESTORE R14\n.PRC5020 ANOP\n&TAG     SETC  ''\n         ##CVREG &#BSV1(&WKLVL)\n&CNT     SETA  (16-&#MCVREG)*4\n&O1      SETC  'R0'\n&O2      SETC  '&#BSV2(&WKLVL)'\n&O3      SETC  '&CNT+&#BSV3(&WKLVL)'\n.LM      ANOP\n         AIF   ('&O1' EQ '&O2').L\n&TAG     LM    &O1,&O2,&O3              RESTORE REGISTERS\n         AGO   .EXIT\n.L       ANOP\n&TAG     L     &O1,&O3                  RESTORE REGISTER\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "##RWREG": {"ttr": 5892, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00\\x1e\\x00\\x1e\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n&NAME    ##RWREG &REG\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##RWREG\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##RWREG\n.*\n.*  PURPOSE    INTERNAL MACRO USED TO RESTORE A WORK REGISTER FROM\n.*             THE SMWA.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - NEW  MGG\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &#PBSMWA                 TAG OF SMWA\n         AIF   ('&#PBSMWA' NE '').PRC0100\n&NAME    DS    0H\n         MEXIT\n.PRC0100 ANOP\n&NAME    L     &REG,&#PBSMWA            RESTORE WORK REGISTER\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "##SESTD": {"ttr": 5894, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00t\\x00t\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 116, "newlines": 116, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##SESTD &RC,                 RETURN CODE KEYWORD              $\n               &R0,                     R0                             $\n               &R1                      R1\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##SESTD\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##SESTD\n.*\n.*  PURPOSE    DEFAULT EPILOG MACRO FOR SUBROUTINE BLOCKS.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   12/29/86 MGG - BROKEN APART FROM ENDBLK AND RESTRUCTURED\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#BLVL                   BLOCK LEVEL\n         GBLC  &#BAMODE(20)             ADDRESSING MODE OF BLOCK\n         GBLB  &#PBPWA                  PROGRAM BLOCK HAS PWA\n         GBLC  &#PBNAME                 PROGRAM BLOCK NAME\n         GBLB  &#PBXA                   XA OPTION\n         GBLB  &#PB370                  370 OPTION\n         GBLB  &#PBDYN                  DYN OPTION\n         GBLB  &#SBSWA                  SWA OPTION\n         GBLB  &#PBLOCR                 LOCTR OPTION\n         GBLB  &#SBSU                   SAVEUSING OPTION\n         GBLB  &#SBUSWA                 USERSWA OPTION\n         GBLA  &#SB#C                   CURRENT SUBROUTINE BLOCK NUM\n         GBLA  &#SBPLMX                 MAXIMUM PARMS IN SUBROUTINE\n         GBLB  &#SBCSTM                 CUSTOM SUBROUTINE BLOCK\n         LCLC  &TAG                     WORK TAG\n         LCLC  &TAG2                    WORK TAG\n         LCLA  &CNT                     WORK COUNTER\n.*--------------------------------------------------------------------*\n.*  ISSUE MESSAGE FOR IGNORED KEYWORDS.\n.*--------------------------------------------------------------------*\n         ##IGMSG &R0,R0\n         ##IGMSG &R1,R1\n.*--------------------------------------------------------------------*\n         AIF   (&#SBCSTM).PRC0700       GO DO CUSTOM STUFF\n         AIF   (NOT &#PBXA).PRC0210\n         AIF   ('&#BAMODE(&#BLVL)' EQ 'ANY').PRC0210\n         AIF   ('&#BAMODE(&#BLVL)' EQ '').PRC0210\n         AIF   (NOT &#PB370).PRC0210\n         AIF   ('&RC' NE '(R15)' AND '&RC' NE '').PRC0010\n         ##SWREG R15                    SAVE WORK REGISTER\n.PRC0010 L     R15,16                   POINT R15 TO CVT\n         TM    X'74'(R15),X'80'         RUNNING UNDER XA?\n.PRC0200 AIF   ('&RC' NE '(R15)' AND '&RC' NE '').PRC0210\n         ##RST R15=YES                  RESTORE REGISTERS\n         ##RWREG R15                    RESTORE WORK REGISTER\n         AGO   .PRC0300\n.PRC0210 AIF   ('&RC' NE '(R15)' AND '&RC' NE '').PRC0220\n&TAG     ##RST R15=NO                   RESTORE REGISTERS\n         AGO   .PRC0300\n.PRC0220 AIF   ('&RC'(1,1) NE '(').PRC0230\n&TAG     LR    R15,&RC(1)               LOAD RETURN CODE\n         ##RST R15=NO                   RESTORE REGISTERS\n         AGO   .PRC0300\n.PRC0230 ANOP\n&TAG     ##RST R15=YES                  RESTORE REGISTERS\n         AIF   ('&RC' NE '0').PRC0240\n         SLR   R15,R15                  SET RETURN CODE TO 0\n         AGO   .PRC0300\n.PRC0240 LA    R15,&RC                  LOAD RETURN CODE\n.PRC0300 AIF   (NOT &#PBXA).PRC0320\n         AIF   ('&#BAMODE(&#BLVL)' EQ 'ANY').PRC0320\n         AIF   ('&#BAMODE(&#BLVL)' EQ '').PRC0320\n         AIF   (NOT &#PB370).PRC0310\n         BZR   R14                      NO, RETURN WITH BR\n.PRC0310 ANOP\n         BSM   0,R14                    RETURN WITH PREVIOUS AMODE\n         AGO   .PRC0390\n.PRC0320 ANOP\n         BR    R14                      RETURN\n.PRC0390 ANOP\n         AGO   .PRC0900\n.PRC0700 AIF   ('&RC' EQ '(R15)').PRC0900\n         AIF   ('&RC' EQ '').PRC0900\n         AIF   ('&RC'(1,1) EQ '(').PRC0750\n         AIF   ('&RC' EQ '0').PRC0760\n         LA    R15,&RC                  LOAD RETURN CODE\n         AGO   .PRC0900\n.PRC0750 LR    R15,&RC(1)               LOAD RETURN CODE\n         AGO   .PRC0900\n.PRC0760 SLR   R15,R15                  SET ZERO RETURN CODE\n.PRC0900 ANOP\n         AIF   (NOT &#SBSU).PRC0950\n         POP   USING\n.PRC0950 AIF   (NOT &#PBPWA).PRC0965\n         AIF   (NOT &#SBSWA).PRC0955\n         AIF   (&#SBUSWA).PRC0965\n         SWA   ,\n         ENDSWA ,\n         AGO   .PRC0965\n.PRC0955 AIF   (NOT &#PBDYN).PRC0960\n#SBL&#SB#C EQU 0                        NO SWA FOR THIS SUBROUTINE\n.PRC0960 AIF   (&#SBPLMX EQ 0).PRC0965\n         PWA   TYPE=PARTIAL\n&TAG     SETC  '#SBP&#SB#C'\n&CNT     SETA  &#SBPLMX*4\n         DS    0F\n&TAG     DS    XL&CNT                   SUBROUTINE PARAMETER STORAGE\n         ENDPWA ,\n.PRC0965 AIF   (NOT &#PBLOCR).PRC0970\n&#PBNAME LOCTR ,\n.PRC0970 ANOP\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "##SPSTD": {"ttr": 5897, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x01\\x1d\\x01\\x1d\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 285, "newlines": 285, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##SPSTD &NAME,                 NAME OF BLOCK                  $\n               &OPTIONS,                OPTIONS                        $\n               &BASEREG,                BASE REGS                      $\n               &AMODE,                  ADDRESSING MODE                $\n               &SMWA,                   STRUCTURED MACRO WORK AREA     $\n               &SWAREG,                 SWA BASE REGS                  $\n               &RECUR,                  MAX RECURSIVE CALLS            $\n               &SAVE,                   REGISTER TO SAVE               $\n               &PARMS,                  INPUT PARM LIST                $\n               &PARMMAP                 INPUT MAP\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1986.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##SPSTD\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##SPSTD\n.*\n.*  PURPOSE    DEFAULT MACRO USED TO FOR SUBROUTINE BLOCK PROLOG.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   12/18/86 MGG - BROKE APART FROM BLOCK MACRO AND\n.*                            RESTRUCTURED.\n.*              9/01/88 MGG - ADDED &S AND &W GLOBAL TAGS           @C1\n.*              3/14/89 MGG - ADDED &P GLOBAL TAG                   @C2\n.*              5/08/89 MGG - &S, &W, AND &P GENERATION MOVED TO    @C3\n.*                            BLOCK MACRO.  ADDED EQU FOR &SSD.     @C3\n.*                            ADDED PARMS OPTION SUPPORT.           @C3\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &#BAMODE(20)             ADDRESSING MODE OF BLOCK\n         GBLA  &#BLVL                   BLOCK LEVEL\n         GBLC  &#BNAME(20)              BLOCK NAMES\n         GBLC  &#BSV1(20)               BLOCK SAVE PARM 1\n         GBLC  &#BSV2(20)               BLOCK SAVE PARM 2\n         GBLC  &#BSV3(20)               BLOCK SAVE PARM 3\n         GBLA  &#MNDX                   LAST TAG INDEX USED\n         GBLA  &#PB#C                   PROGRAM BLOCK NUMBER\n         GBLC  &#PBDERR                 DYNAMIC STORAGE ERROR TAG\n         GBLB  &#PBDYN                  DYNAMIC STORAGE OPTION\n         GBLC  &#PBDYNS                 VALUE FROM DYNSIZE PARAMETER\n         GBLB  &#PBLOCR                 DO LOCATR IN PROGRAM\n         GBLB  &#PBLONG                 LONG PROGRAM OPTION\n         GBLA  &#PBNDX                  PROGRAM BLOCK INDEX\n         GBLB  &#PBOPTS                 OPTIMIZE STORAGE\n         GBLB  &#PBPWA                  PWA OPTION\n         GBLB  &#PBXA                   XA OPTION\n         GBLB  &#PB370                  370 OPTION\n         GBLA  &#SB#C                   # OF CURRENT SUBROUTINE\n         GBLA  &#SB#D                   SUB BLOCK NMBR FROM ##DEFSUB\n         GBLB  &#SBCSTM                 CUSTOM SUBROUTINE\n         GBLB  &#SBLDBS                 LOAD BASE OPTION\n         GBLC  &#SBNM(99)               SUBROUTINE BLOCK NAMES\n         GBLA  &#SBPLMX                 MAX PL ENTRIES IN SUBROUTINE\n         GBLA  &#SBREC(99)              SUBROUTINE BLOCK RECUR + 1\n         GBLB  &#SBSU                   SAVEUSING OPTION\n         GBLB  &#SBSWA                  SWA OPTION\n         GBLB  &#SBUSWA                 USERSWA OPTION\n         GBLB  &#XAWARN                 XA WARNING MESSAGE ISSUED\n         GBLC  &SSD                     SUBROUTINE STATIC DATA TAG  @C3\n         LCLA  &CTR                     WORK COUNTER\n         LCLC  &TAG                     WORK TAGS\n         LCLC  &TAG2                    WORK TAGS\n         LCLC  &TAG3                    WORK TAGS\n.*------------------------------------------------------------------\n.*  GET OPTIONS FOR SUBROUTINE BLOCK\n.*------------------------------------------------------------------\n         ##SUBOPT &OPTIONS\n.*------------------------------------------------------------------\n.*  DO CHECKS FOR SWA\n.*------------------------------------------------------------------\n.CST7000 AIF   (NOT &#SBSWA).CST7100   SKIP IF NOSWA OPTION\n.CST7010 AIF   ('&SAVE' EQ '').CST7020\n         MNOTE 8,'SAVE= invalid if SWA option specified'\n.CST7020 AIF   (&#PBPWA).CST7030\n         MNOTE 8,'SWA option requires PWA option on program block'\n         AGO   .CST7200\n.CST7030 ANOP\n.CST7100 AIF   ('&SWAREG' EQ '').CST7110\n         MNOTE 8,'SWAREG= can not be specified unless OPTION=SWA is spe$\n               cified'\n.CST7110 ANOP\n.CST7200 ANOP\n.*------------------------------------------------------------------\n.*  DO CHECKS FOR CUSTOM SUBROUTINE BLOCK.\n.*------------------------------------------------------------------\n.CST8000 AIF   (NOT &#SBCSTM).CST9999   SKIP IF NOT CUSTOM SUBROUTIN\n.CST8010 AIF   ('&AMODE' EQ '').CST8020\n         MNOTE 8,'AMODE= invalid for custom subroutine blocks'\n.CST8020 AIF   ('&SAVE' EQ '').CST8030\n         MNOTE 8,'SAVE= invalid for custom subroutine blocks'\n.CST8030 AIF  (NOT &#SBUSWA AND NOT &#SBSU AND NOT &#SBSWA).CST8040\n         MNOTE 8,'CUSTOM must be specified alone'\n.CST8040 ANOP\n.CST9999 ANOP\n.*--------------------------------------------------------------------*\n.*  SET AND CHECK MODE\n.*--------------------------------------------------------------------*\n&#BAMODE(&#BLVL) SETC  '&AMODE'\n         AIF   ('&AMODE' EQ '' OR '&AMODE' EQ 'ANY').ANY0020\n         AIF   ('&AMODE' EQ '24' OR '&AMODE' EQ '31').ANY0020\n.ANY0010 MNOTE 8,'AMODE=&AMODE is invalid on subroutine block, keyword $\n               ignored'\n&#BAMODE(&#BLVL) SETC   ''\n.ANY0020 ANOP\n.*--------------------------------------------------------------------*\n.*  ASSUME LOADBASE OPTION IF BASEREG IS SPECIFIED.\n.*--------------------------------------------------------------------*\n&#SBPLMX SETA  0\n         AIF   ('&BASEREG' EQ '' OR &#SBLDBS).SUB0010\n         MNOTE *,'LOADBASE assumed because BASEREG= specified'\n&#SBLDBS SETB  1\n.*--------------------------------------------------------------------*\n.*  REQUIRE NAME= KEYWORD.\n.*--------------------------------------------------------------------*\n.SUB0010 AIF   ('&NAME' NE '').SUB0020\n         MNOTE 8,'BLOCK TYPE=SUBROUTINE requires NAME='\n&#BNAME(&#BLVL) SETC 'BADNAME'\n.*--------------------------------------------------------------------*\n.*  LOADBASE OPTION REQUIRES LONG OPTION ON PROGRAM BLOCK.\n.*--------------------------------------------------------------------*\n.SUB0020 AIF   (NOT &#SBLDBS OR &#PBLONG).SUB0030\n         MNOTE 8,'LOADBASE option requires LONG option on program block$\n               '\n.SUB0030 ANOP\n.*------------------------------------------------------------------\n.*  GENERATE SUBROUTINE DEPENDENT CODE\n.*------------------------------------------------------------------\n.SUB0100 ANOP\n         AIF   (NOT &#PBLOCR OR NOT &#SBLDBS).SUB0150\n&TAG3    SETC  '#SBIL&#SB#C'\n&TAG3    LOCTR ,                        SUBROUTINE BLOCK INST LOCTR\n&TAG3    SETC  '#SBDL&#SB#C'\n&TAG3    LOCTR ,                        SUBROUTINE BLOCK DATA LOCTR\n&SSD     EQU   *                        START OF SSD                @C3\n&TAG3    SETC  '#SBIL&#SB#C'\n&TAG3    LOCTR ,                        SUBROUTINE BLOCK INST LOCTR\n.SUB0150 ANOP\n&#SBREC(&#SB#C) SETA 1\n         AIF   ('&RECUR' EQ '').SUB0200\n         AIF   (&#PBDYN).SUB0205\n         MNOTE 8,'RECUR keyword requires DYN option on program block' 7\n.SUB0205 ANOP\n&#SBREC(&#SB#C) SETA &RECUR+1\n.SUB0200 ANOP\n         AIF   (NOT &#SBSU).SUB0210\n         PUSH  USING\n.SUB0210 ANOP\n         AIF   (&#SBSWA).SUB0220\n&NAME    DS    0H                       SUBROUTINE NAME\n         AGO   .SUB9000\n.SUB0220 AIF   (&#PBDYN).SUB0225\n&NAME    STM   R0,R14,#SBS&#SB#C        SAVE REGISTERS\n&#BSV1(&#BLVL) SETC 'R0'\n&#BSV2(&#BLVL) SETC 'R14'\n&#BSV3(&#BLVL) SETC '#SBS&#SB#C'\n         AIF   (NOT &#SBLDBS).SUB9000\n         ##LDBS &NAME,&BASEREG,R10,FRSTLD=YES\n         AGO   .SUB9000\n.SUB0225 AIF   (NOT &#PBOPTS).SUB0230\n&TAG2    SETC  '&#SBNM(&#SB#C)'\n&TAG2    BAL   R15,#BK&#PBNDX           DO LINKAGE\n         DC    Y(#SBL&#SB#C)            LENGTH OF SWA TO OBTAIN\n         AIF   (NOT &#SBLDBS).SUB0240\n         ##LDBS *,&BASEREG,R10,FRSTLD=YES\n         AGO   .SUB0240\n.SUB0230 ANOP\n&TAG     SETC  '#SBLT&#SB#C'\n         AIF   (NOT &#PBLOCR OR NOT &#SBLDBS).SUB0232\n&TAG3    SETC  '#SBDL&#SB#C'\n&TAG3    LOCTR ,                        SUBROUTINE BLOCK DATA LOCTR\n.SUB0232 ANOP\n&TAG     DC    Y(#SBL&#SB#C)\n         AIF   (NOT &#PBLOCR OR NOT &#SBLDBS).SUB0233\n&TAG3    SETC  '#SBIL&#SB#C'\n&TAG3    LOCTR ,                        SUBROUTINE BLOCK INST LOCTR\n.SUB0233 ANOP\n&TAG2    SETC  '&#SBNM(&#SB#C)'\n&TAG2    L     R15,0(,R11)              POINT R15 TO NAB (NEW SWA)\n         STM   R0,R14,4(R15)            SAVE R0 - R14\n         AIF   (NOT &#SBLDBS).SUB0235\n         ##LDBS *,&BASEREG,R10,FRSTLD=YES\n.SUB0235 LR    R11,R15                  POINT R11 TO NEW SWA\n         AH    R15,&TAG                 CALCULATE NEW NAB\n         CL    R15,#PBE&#PB#C           CHECK FOR OVERFLOW\n         BH    &#PBDERR                 BRANCH TO ERREXIT IF OVERFLO\n         ST    R15,0(,R11)              STORE NEW NAB\n.SUB0240 ANOP\n&#BSV1(&#BLVL) SETC 'R0'\n&#BSV2(&#BLVL) SETC 'R14'\n&#BSV3(&#BLVL) SETC '#SBS&#SB#C'\n&TAG2    SETC  '#SBD&#SB#C'\n         AIF   ('&SWAREG' EQ '').SUB0300\n         AIF   ('&SWAREG(1)' EQ 'R11').SUB0300\n         MNOTE 8,'R11 must be the first register specified on the SWARE$\n               G= keyword'\n.SUB0300 ##LDBS &TAG2,&SWAREG,R11\n.SUB9000 ANOP\n.*--------------------------------------------------------------------*\n.*  IF AMODE SPECIFIED\n.*    IF SUBROUTINE BLOCK OR ERREXIT BLOCK\n.*      OR INLINE BLOCK AND AMODE IS NOT THE SAME AS PREVIOUS BLOCK\n.*--------------------------------------------------------------------*\n.AMO0000 ANOP\n&TAG     SETC  ''\n         AIF   (&#SBCSTM).AMO0350       AMODE INVALID FOR CUSTOM\n         AIF   ('&AMODE' EQ '').AMO0350\n         AIF   (&#PBXA).AMO0100\n         AIF   (&#XAWARN).AMO0350\n         MNOTE *,'AMODE ignored unless XA option specified for program $\n               block'\n&#XAWARN SETB  1                        ONLY ISSUE ONE TIME\n         AGO   .AMO0350\n.AMO0100 AIF   ('&#BAMODE(&#BLVL)' EQ 'ANY').AMO0350\n.*--------------------------------------------------------------------*\n.*      IF OPTIONS XA AND 370, GENERATE TEST FOR XA\n.*--------------------------------------------------------------------*\n         AIF   (&#SBSWA).AMO0210\n         ##SWREG R15                    SAVE WORK REGISTER\n.AMO0210 ANOP\n&TAG     SETC  '#BY&#MNDX'\n         AIF   (NOT &#PBXA OR NOT &#PB370).AMO0300\n         L     R15,16                   POINT R15 TO CVT\n         TM    X'74'(R15),X'80'         RUNNING UNDER XA?\n         BZ    &TAG                     SKIP AMODE SETTING\n.*--------------------------------------------------------------------*\n.*      GENERATE CHANGE AMODE CODE\n.*--------------------------------------------------------------------*\n.AMO0300 ANOP\n         AIF   ('&#BAMODE(&#BLVL)' NE '31').AMO0310\n&TAG2    SETC  '#BZ&#MNDX'\n         ICM   R15,B'1111',&TAG2        LOAD ADDR OF INST AFTER BSM\n         BSM   R14,R15                  SAVE MODE IN R14 & SET NEW MODE\n&TAG2    DC    AL4(&TAG+X'80000000')    AMODE 31\n         AGO   .AMO0320\n.AMO0310 LA    R15,&TAG                 LOAD ADDR OF INST AFTER BSM\n         BSM   R14,R15                  SAVE MODE IN R14 & SET NEW MODE\n.AMO0320 ANOP\n         AIF   (&#SBSWA).AMO0350\n&TAG     ##RWREG R15                    RESTORE WORK REG\n&TAG     SETC  ''\n         AGO   .AMO0350\n.AMO0330 ANOP\n&TAG     DS    0H\n&TAG     SETC  ''\n.AMO0350 ANOP\n.*--------------------------------------------------------------------*\n.*      IF SAVE= KEYWORD SPECIFIED, SAVE REGISTERS\n.*--------------------------------------------------------------------*\n         AIF   (&#SBCSTM).AMO0380       SAVE NOT VALID FOR CUSTOM\n         AIF   (&#SBSWA).AMO0380        SAVE NOT VALID FOR CUSTOM\n&#BSV1(&#BLVL) SETC '&SAVE(1)'\n&#BSV2(&#BLVL) SETC '&SAVE(2)'\n&#BSV3(&#BLVL) SETC '&SAVE(3)'\n         AIF   ('&SAVE' EQ '').AMO0380\n         AIF   (N'&SAVE NE 2).AMO0360\n&TAG     ST    &SAVE(1),&SAVE(2)       SAVE REGISTER\n         AGO   .AMO0390\n.AMO0360 AIF   (N'&SAVE NE 3).AMO0370\n&TAG     STM   &SAVE(1),&SAVE(2),&SAVE(3) SAVE REGISTERS\n         AGO   .AMO0390\n.AMO0370 MNOTE 8,'Invalid number of parameters in SAVE= keyword'\n.AMO0380 AIF   ('&TAG' EQ '').AMO0390\n&TAG     DS    0H\n.AMO0390 ANOP\n.*------------------------------------------------------------------\n.*       IF SUBROUTINE AND NO SWA, LOAD BASE REGISTER IF OPTION\n.*       LOADBASE IS IN EFFECT\n.*------------------------------------------------------------------\n         AIF   (&#SBSWA OR NOT &#SBLDBS).AMO0400\n         ##LDBS &NAME,&BASEREG,R10,FRSTLD=YES\n.AMO0400 ANOP\n.*------------------------------------------------------------------@C3\n.*       GENERATE PARAMETER LIST CODE.                              @C3\n.*------------------------------------------------------------------@C3\n         ##PRMOPT PROCESS=GENERATE,PARMS=&PARMS,PARMMAP=&PARMMAP,   @C3+\n               TYPE=SUBROUTINE                                      @C3\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##ST": {"ttr": 6145, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00D\\x00D\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##ST  &REG,                    REGISTER TO LOAD               $\n               &FIELD,                  FIELD TO LOAD                  $\n               &WREG                    WORK REGISTER\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1989.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##ST\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##ST\n.*\n.*  PURPOSE    INTERNAL MACRO TO STORE A VALUE FROM A REGISTER.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    3/15/89 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         LCLC  &TAG                     WORK TAG\n         LCLC  &TREG                    WORK FIELD\n         AIF   ('&FIELD' NE '').X100\n         SLR   &REG,&REG                NO PARAMETER SPECIFIED\n         MEXIT\n.X100    ANOP\n.X200    AIF   (K'&FIELD GT 4).X300\n         AIF   (K'&FIELD NE 4).X210\n         AIF   ('&FIELD'(1,2) NE '*R').X300\n         AIF   ('&FIELD'(3,1) NE '1').X300\n         AIF   ('&FIELD'(4,1) LT '0').X300\n         AIF   ('&FIELD'(4,1) GT '5').X300\n&TREG    SETC  '&FIELD'(2,3)\n         ST    &REG,0(,&TREG)\n         MEXIT\n.X210    AIF   (K'&FIELD NE 3).X230\n         AIF   ('&FIELD'(1,2) NE '*R').X220\n         AIF   ('&FIELD'(3,1) LT '0').X300\n&TREG    SETC  '&FIELD'(2,2)\n         ST    &REG,0(,&TREG)\n         MEXIT\n.X220    AIF   ('&FIELD'(1,1) NE 'R').X300\n         AIF   ('&FIELD'(2,1) NE '1').X300\n         AIF   ('&FIELD'(3,1) LT '0').X300\n         AIF   ('&FIELD'(3,1) GT '5').X300\n         AIF   ('&REG' EQ '&FIELD').MEXIT\n         LR    &FIELD,&REG\n         MEXIT\n.X230    AIF   (K'&FIELD NE 2).X300\n         AIF   ('&FIELD'(1,1) NE 'R').X300\n         AIF   ('&FIELD'(2,1) LT '0').X300\n         AIF   ('&REG' EQ '&FIELD').MEXIT\n         LR    &FIELD,&REG\n         MEXIT\n.X300    AIF   ('&FIELD'(1,1) NE '*').X400\n         AIF   ('&WREG' EQ '').ERR1\n&TAG     SETC  '&FIELD'(2,K'&FIELD-1)\n         L     &WREG,&TAG\n         ST    &REG,0(,&WREG.)\n         MEXIT\n.X400    ST    &REG,&FIELD              LOAD ADDR OF PARAMETER\n         MEXIT\n.ERR1    MNOTE 8,'*ADDR form of second operand requires WREG='\n.MEXIT   MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##SUBOPT": {"ttr": 6147, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00\\x8e\\x00\\x8e\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 142, "newlines": 142, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##SUBOPT &OPTIONS,             OPTIONS                        $\n               &DEFAULT=NO              DO NOT SET DEFAULTS\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1986.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##SUBOPT\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##SUBOPT\n.*\n.*  PURPOSE    INTERNAL MACRO USED AS PARSE THE SUBROUTINE STANDARD\n.*             SUBROUTINE OPTIONS.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   12/18/86 MGG - BROKEN APART FROM THE BLOCK MACRO AND\n.*                            RESTRUCURED.\n.*              5/08/89 MGG - ADDED PARMS OPTION SUPPORT.           @C1\n.*\n.*--------------------------------------------------------------------*\n         GBLB  &#SBCSTM                 CUSTOM SUBROUTINE\n         GBLB  &#SBLDBS                 LOAD BASE OPTION\n         GBLB  &#SBSU                   SAVEUSING OPTION\n         GBLB  &#SBSWA                  SWA OPTION\n         GBLB  &#SBUSWA                 USERSWA OPTION\n         GBLB  &#SDCSTM                 DEFAULT CUSTOM OPTION\n         GBLB  &#SDLDBS                 DEFAULT LOAD BASE OPTION\n         GBLB  &#SDSU                   DEFAULT SAVEUSING OPTION\n         GBLB  &#SDSWA                  DEFAULT SWA OPTION\n         GBLB  &#SDUSWA                 DEFAULT USERSWA OPTION\n         LCLB  &CSTM                    CUSTOM SUBROUTINE\n         LCLB  &LDBS                    LOAD BASE OPTION\n         LCLB  &SU                      SAVEUSING OPTION\n         LCLB  &SWA                     SWA OPTION\n         LCLB  &USWA                    USERSWA OPTION\n.*------------------------------------------------------------------\n.*  IF NOT DEFAULT=YES, SET OPTIONS TO DEFAULT; OTHERWISE, RESET.   @C1\n.*------------------------------------------------------------------\n         AIF   ('&DEFAULT' EQ 'YES').SDO0050                        @C1\n&CSTM    SETB  (&#SDCSTM)               SET CUSTOM TO DEFAULT\n&SWA     SETB  (&#SDSWA)                SET SWA TO DEFAULT\n&SU      SETB  (&#SDSU)                 SET SAVEUSING TO DEFAULT\n&USWA    SETB  (&#SDUSWA)               SET USERSWA TO DEFAULT\n&LDBS    SETB  (&#SDLDBS)               SET LOADBASE TO DEFAULT\n         ##PRMOPT PROCESS=SET_TO_SUBROUTINE_DEFAULTS,               @C1+\n               TYPE=SUBROUTINE                                      @C1\n         AGO   .SDO0100                                             @C1\n.SDO0050 ANOP                                                       @C1\n&CSTM    SETB  0                        SET NOCUSTOM                @C1\n&SWA     SETB  0                        SET NOSWA                   @C1\n&SU      SETB  0                        SET NOSAVEUSING             @C1\n&USWA    SETB  0                        SET NOUSERSWA               @C1\n&LDBS    SETB  0                        SET NOLOADBASE              @C1\n         ##PRMOPT PROCESS=RESET,TYPE=SUBROUTINE SET NOPARMS         @C1\n.SDO0100 ANOP\n.*------------------------------------------------------------------\n.*  SET SUBROUTINE OPTIONS BASE ON SUBOPT\n.*------------------------------------------------------------------\n&CTR     SETA  1                        SET COUNTER TO 1\n.SDO1000 AIF   (&CTR GT N'&OPTIONS).SDO7000\n.SDO1100 AIF   ('&OPTIONS(&CTR)' NE 'CUSTOM').SDO1110\n&CSTM    SETB  1                        INDICATE CUSTOM SUBROUTINE\n         AGO   .SDO1900                 CHECK NEXT OPTION\n.SDO1110 AIF   ('&OPTIONS(&CTR)' NE 'NOCUSTOM').SDO1120\n&CSTM    SETB  0                        INDICATE NOT CUSTOM SUB\n         AGO   .SDO1900                 CHECK NEXT OPTION\n.SDO1120 AIF   ('&OPTIONS(&CTR)' NE 'SWA').SDO1130\n&SWA     SETB  1                        INDICATE SWA\n         AGO   .SDO1900                 CHECK NEXT OPTION\n.SDO1130 AIF   ('&OPTIONS(&CTR)' NE 'NOSWA').SDO1140\n&SWA     SETB  0                        INDICATE NOSWA\n         AGO   .SDO1900                 CHECK NEXT OPTION\n.SDO1140 AIF   ('&OPTIONS(&CTR)' NE 'SAVEUSING').SDO1150\n&SU      SETB  1                        INDICATE SAVEUSING\n         AGO   .SDO1900                 CHECK NEXT OPTION\n.SDO1150 AIF   ('&OPTIONS(&CTR)' NE 'NOSAVEUSING').SDO1160\n&SU      SETB  0                        INDICATE NOSAVEUSING\n         AGO   .SDO1900                 CHECK NEXT OPTION\n.SDO1160 AIF   ('&OPTIONS(&CTR)' NE 'USERSWA').SDO1170\n&USWA    SETB  1                        INDICATE USERSWA\n         AGO   .SDO1900                 CHECK NEXT OPTION\n.SDO1170 AIF   ('&OPTIONS(&CTR)' NE 'NOUSERSWA').SDO1180\n&USWA    SETB  0                        INDICATE NOUSERSWA\n         AGO   .SDO1900                 CHECK NEXT OPTION\n.SDO1180 AIF   ('&OPTIONS(&CTR)' NE '*SWA').SDO1190\n&SWA     SETB  1                        INDICATE SWA\n&SU      SETB  1                        INDICATE SAVEUSING\n&USWA    SETB  1                        INDICATE USERSWA\n         AGO   .SDO1900                 CHECK NEXT OPTION\n.SDO1190 AIF   ('&OPTIONS(&CTR)' NE '*NOSUBOPTS').SDO1200\n&SWA     SETB  0                        INDICATE NOSWA\n&SU      SETB  0                        INDICATE NOSAVEUSING\n&USWA    SETB  0                        INDICATE NOUSERSWA\n&LDBS    SETB  0                        INDICATE NOLOADBASE\n         ##PRMOPT PROCESS=RESET,TYPE=SUBROUTINE                     @C1\n         AGO   .SDO1900                 CHECK NEXT OPTION\n.SDO1200 AIF   ('&OPTIONS(&CTR)' NE 'LOADBASE').SDO1210\n&LDBS    SETB  1                        INDICATE LOADBASE\n         AGO   .SDO1900                 CHECK NEXT OPTION\n.SDO1210 AIF   ('&OPTIONS(&CTR)' NE 'NOLOADBASE').SDO1220\n&LDBS    SETB  0                        INDICATE NOLOADBASE\n         AGO   .SDO1900                 CHECK NEXT OPTION\n.SDO1220 AIF   ('&OPTIONS(&CTR,1)' NE 'PARMS').SDO1230              @C1\n         ##PRMOPT PROCESS=PARSE_OPTIONS,OPTIONS=&OPTIONS(&CTR),     @C1+\n               TYPE=SUBROUTINE                                      @C1\n         AGO   .SDO1900                 CHECK NEXT OPTION           @C1\n.SDO1230 AIF   ('&OPTIONS(&CTR)' NE 'NOPARMS').SDO1240              @C1\n         ##PRMOPT PROCESS=RESET,TYPE=SUBROUTINE                     @C1\n         AGO   .SDO1900                 CHECK NEXT OPTION           @C1\n.SDO1240 ANOP                                                       @C1\n         MNOTE 8,'&OPTIONS(&CTR) is an invalid option for subroutine bl$\n               ock'\n.SDO1900 ANOP\n&CTR     SETA  &CTR+1                   INCREMENT COUNTER\n         AGO   .SDO1000                 LOOP\n.SDO7000 ANOP\n.*--------------------------------------------------------------------*\n.*  IF DEFAULT=YES SET DEFAULTS; OTHERWISE, SET ACTUAL VALUES.\n.*--------------------------------------------------------------------*\n         AIF   ('&DEFAULT' NE 'YES').SDO7010\n&#SDCSTM SETB  (&CSTM)\n&#SDUSWA SETB  (&USWA)\n&#SDSU   SETB  (&SU)\n&#SDSWA  SETB  (&SWA)\n&#SDLDBS SETB  (&LDBS)\n         ##PRMOPT PROCESS=SET_SUBROUTINE_DEFAULTS,TYPE=SUBROUTINE   @C1\n         AGO   .SDO7020\n.SDO7010 ANOP\n&#SBCSTM SETB  (&CSTM)\n&#SBUSWA SETB  (&USWA)\n&#SBSU   SETB  (&SU)\n&#SBSWA  SETB  (&SWA)\n&#SBLDBS SETB  (&LDBS)\n.SDO7020 ANOP\n.*--------------------------------------------------------------------*\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##SWREG": {"ttr": 6151, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00 \\x00 \\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n&NAME    ##SWREG &REG\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##SWREG\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##SWREG\n.*\n.*  PURPOSE    INTERNAL MACRO USED TO GENERATE CODE TO SAVE A WORK\n.*             REGISTER IN THE SMWA.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - NEW  MGG\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &#PBSMWA                 TAG OF SMWA\n         AIF   ('&#PBSMWA' NE '').PRC0100\n         MNOTE 8,'SMWA= keyword if required on the program block macro $\n               to support this function'\n&NAME    DS    0H\n         MEXIT\n.PRC0100 ANOP\n&NAME    ST    &REG,&#PBSMWA            SAVE WORK REGISTER\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##UCOND": {"ttr": 6153, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00(\\x00(\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n&TAG     ##UCOND &EXPR,&S=,&F=,&L=\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1989.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##UCOND\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##UCOND\n.*\n.*  PURPOSE    INTERNAL MACRO USED TO CALL MACRO TO SUPPORT USER\n.*             DEFINED CONDITIONS.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    9/13/89 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         LCLC  &UCOND                   USER CONDITION NAME\n         LCLC  &UCOND_NAME\n         LCLC  &UCOND_MACRO\n         LCLA  &X                       WORK VARIABLE\n&X       SETA  K'&EXPR(1)-1\n         AIF   (&X LT 1).ERR0001\n&UCOND   SETC  '&EXPR(1)'(2,&X)\n&UCOND_DEFINED SETC '&UCOND.__DEFINED'\n&UCOND_MACRO   SETC '&UCOND.__MACRO'\n         GBLB  &(&UCOND_DEFINED)\n         GBLC  &(&UCOND_MACRO)\n         AIF   (NOT &(&UCOND_DEFINED)).ERR0001\n&TAG     &(&UCOND_MACRO) &EXPR,S=&S,F=&F,L=&L\n         MEXIT\n.ERR0001 MNOTE 8,'Invalid or undefined user condition name: &UCOND'\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##UESTD": {"ttr": 6155, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00/\\x00/\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##UESTD\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1986.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##UESTD\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##UESTD\n.*\n.*  PURPOSE    INTERNAL MACRO USED TO GENERATE EPILOG FOR A STANDARD\n.*             SWA.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    1/06/87 MGG - BROKE APART FROM ENDSWA MACRO AND\n.*                            REORGANIZED.\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#SB#C                   SUBROUTINE BLOCK NUMBER\n         GBLB  &#SBPSWA                 PARTIAL SWA ENCOUNTERED\n         GBLC  &#PBNAME                 CSECT NAME OF PROGRAM BLOCK\n         GBLB  &#PBDYN                  PROGRAM BLOCK DYN OPTION\n         LCLA  &N\n&N       SETA  &#SB#C\n.*--------------------------------------------------------------------*\n.*  IF THIS IS THE ENDSWA FOR A TYPE=LAST SWA THEN GENERATE DS FOR\n.*  ALIGNMENT AND GENERATE SWA LENGTH TAG.\n.*--------------------------------------------------------------------*\n         AIF   (&#SBPSWA).PRC0200\n         AIF   (&#PBDYN).PRC0110\n         DS    0F ONLY INSURE FULLWORD ALIGNMENT BECAUSE OF NODYN\n         AGO   .PRC0120\n.PRC0110 DS    0D INSURE DOUBLEWORD ALIGNMENT BECAUSE OF DYN OPTION\n.PRC0120 ANOP\n#SBL&N   EQU   *-#SBD&N                 LENGTH OF SWA\n.PRC0200 ANOP\n.*--------------------------------------------------------------------*\n.*  SWITCH BACK TO CSECT.\n.*--------------------------------------------------------------------*\n&#PBNAME CSECT ,\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "##UPSTD": {"ttr": 6157, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00i\\x00i\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 105, "newlines": 105, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##UPSTD &TYPE\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1986.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##UPSTD\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##UPSTD\n.*\n.*  PURPOSE    INTERNAL MACRO USED TO GENERATE PROLOG FOR A STANDARD\n.*             SWA.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    1/06/87 MGG - NEW\n.*              5/08/89 MGG - ADDED SWA TAG.                        @C1\n.*              6/26/93 MGG - ADDED tags for saved registers.       @C2\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#SB#C                   SUBROUTINE BLOCK NUMBER\n         GBLB  &#SBSWA                  SUBROUTINE BLOCK SWA OPTION\n         GBLB  &#SBPSWA                 PARTIAL SWA EXIST\n         GBLB  &#PBDYN                  PROGRAM BLOCK DYNAMIC OPTION\n         GBLA  &#SBPLMX                 MAX PARMS IN SUBROUTINE\n         GBLA  &#SBWAMX                 MAX WORDS OF SMWA NEEDED\n         GBLC  &SWA                     SWA TAG                     @C1\n         LCLA  &N\n.*--------------------------------------------------------------------*\n.*  REQUIRE THAT SWA OPTION BE IN EFFECT TO ISSUE THIS MACRO.\n.*--------------------------------------------------------------------*\n         AIF   (&#SBSWA).PRC0010\n         MNOTE 8,'SWA option was not specified on the subroutine block $\n               macro or SWA already defined'\n.PRC0010 ANOP\n&N       SETA  &#SB#C\n.*--------------------------------------------------------------------*\n.*  IF NOT USING DYN OPTION, PLACE STORAGE FOR SWA IN PWA.\n.*--------------------------------------------------------------------*\n         AIF   (&#PBDYN).PRC0020\n         PWA   TYPE=PARTIAL\n         AIF   (&#SBPSWA).PRC0030\n#SBD&N   DS    0F                       SWA STORAGE\n         AGO   .PRC0030\n.PRC0020 ANOP\n.*--------------------------------------------------------------------*\n.*  IF USING DYN OPTION, USE SEPERATE DSECT FOR SWA.\n.*--------------------------------------------------------------------*\n#SBD&N   DSECT                          SWA DSECT\n.PRC0030 ANOP\n.*--------------------------------------------------------------------*\n.*  IF THIS IS THE FIRST CALL FOR THIS SWA, GENERATE FIELDS THAT\n.*  GO AT START OF THE SWA.\n.*--------------------------------------------------------------------*\n         AIF   (&#SBPSWA).PRC0200\n&SWA     EQU   #SBD&N                                               @C1\n         AIF   (NOT &#PBDYN).PRC0040\n#SBN&N   DS    A                        NAB\n.PRC0040 ANOP\n#SBS&N   DS    0F                       SAVE AREA (R0-R14)\n&SWA.SWA_SAVE_AREA_R0 DS F\n&SWA.SWA_SAVE_AREA_R1 DS F\n&SWA.SWA_SAVE_AREA_R2 DS F\n&SWA.SWA_SAVE_AREA_R3 DS F\n&SWA.SWA_SAVE_AREA_R4 DS F\n&SWA.SWA_SAVE_AREA_R5 DS F\n&SWA.SWA_SAVE_AREA_R6 DS F\n&SWA.SWA_SAVE_AREA_R7 DS F\n&SWA.SWA_SAVE_AREA_R8 DS F\n&SWA.SWA_SAVE_AREA_R9 DS F\n&SWA.SWA_SAVE_AREA_R10 DS F\n&SWA.SWA_SAVE_AREA_R11 DS F\n&SWA.SWA_SAVE_AREA_R12 DS F\n&SWA.SWA_SAVE_AREA_R13 DS F\n&SWA.SWA_SAVE_AREA_R14 DS F\n&#SBPSWA SETB  1\n.PRC0200 ANOP\n.*--------------------------------------------------------------------*\n.*  IF TYPE=PARTIAL WAS SPECIFIED, EXIT.\n.*--------------------------------------------------------------------*\n         AIF   ('&TYPE' EQ 'PARTIAL').PRC0900\n.PRC0300 ANOP\n.*--------------------------------------------------------------------*\n.*  IF TYPE=LAST WAS SPECIFIED, GENERATE FIELDS THAT GO JUST BEFORE\n.*  USER FIELDS.\n.*--------------------------------------------------------------------*\n         AIF   ('&TYPE' NE 'LAST').PRC0400\n&#SBSWA  SETB  0\n&#SBPSWA SETB  0\n#SBW&N   DS    &#SBWAMX.A               SMWA\n#SBP&N   DS    &#SBPLMX.A               PARAMETER LIST STORAGE\n#SBU&N   DS    0X                       START OF USER STORAGE\n         AGO   .PRC0900\n.PRC0400 ANOP\n.*--------------------------------------------------------------------*\n.*  IT IS AN ERROR IF &TYPE IS OTHER THAN ONE OF THE ABOVE.\n.*--------------------------------------------------------------------*\n         MNOTE 8,'Invalid type &TYPE specified on SWA macro'\n.PRC0900 ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##VEDSCT": {"ttr": 6160, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00,\\x00,\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##VEDSCT\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1991.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##VEDSCT\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##VEDSCT\n.*\n.*  PURPOSE    INTERNAL MACRO USED TO PROCESS VDA GENTYPE=DSECT\n.*             EPILOG.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    8/06/91 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &VDA__START(20)\n         GBLC  &VDA__SIZE(20)\n         GBLC  &VDA__STORAGE(20)\n         GBLC  &VDA__END(20)\n         GBLC  &VDA__CSECT\n         GBLA  &VDA__LEVEL\n&START   SETC  '&VDA__START(&VDA__LEVEL)'\n&SIZE    SETC  '&VDA__SIZE(&VDA__LEVEL)'\n&STORAGE SETC  '&VDA__STORAGE(&VDA__LEVEL)'\n&END     SETC  '&VDA__END(&VDA__LEVEL)'\n         AIF   ('&END' EQ '').PRC010\n&END     EQU   *                       End of VDA.\n.PRC010  AIF   ('&SIZE' EQ '').PRC020\n&SIZE    EQU   *-&START                Size of VDA.\n.PRC020  AIF   ('&STORAGE' EQ '').PRC030\n&STORAGE EQU   &START,*-&START,C'X'    Storage of VDA.\n.PRC030  ANOP\n         AIF   (&VDA__LEVEL NE 1).PRC9010\n&VDA__CSECT CSECT ,\n.PRC9010 ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##VEINLN": {"ttr": 6162, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00(\\x00(\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##VEINLN\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1991.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##VEINLN\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##VEINLN\n.*\n.*  PURPOSE    INTERNAL MACRO USED TO PROCESS VDA GENTYPE=INLINE\n.*             EPILOG.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    8/06/91 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &VDA__START(20)\n         GBLC  &VDA__SIZE(20)\n         GBLC  &VDA__STORAGE(20)\n         GBLC  &VDA__END(20)\n         GBLA  &VDA__LEVEL\n&START   SETC  '&VDA__START(&VDA__LEVEL)'\n&SIZE    SETC  '&VDA__SIZE(&VDA__LEVEL)'\n&STORAGE SETC  '&VDA__STORAGE(&VDA__LEVEL)'\n&END     SETC  '&VDA__END(&VDA__LEVEL)'\n         AIF   ('&END' EQ '').PRC010\n&END     EQU   *                       End of VDA.\n.PRC010  AIF   ('&SIZE' EQ '').PRC020\n&SIZE    EQU   *-&START                Size of VDA.\n.PRC020  AIF   ('&STORAGE' EQ '').PRC030\n&STORAGE EQU   &START,*-&START,C'X'    Storage of VDA.\n.PRC030  ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##VOP": {"ttr": 6401, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00*\\x00*\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##VOP &TYPE,&OP\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1991.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##VOP\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##VOP\n.*\n.*  PURPOSE    INTERNAL MACRO USED TO OVERRIDE OPCODES.\n.*             PROLOG.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    8/08/91 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         AIF  ('&OP' EQ 'DC').GBLC\n         AIF  ('&OP' EQ 'DS').GBLC\n         AIF  ('&OP' EQ 'EQU').GBLC\n         MNOTE 8,'OP &OP IS NOT SUPPORTED.'\n         MEXIT\n.GBLC    GBLC  &(VDA__&OP)\n         AIF   ('&(VDA__&OP)' EQ '').MEND\n         AIF   ('&TYPE' EQ 'OVERRIDE').OVERRIDE\n         AIF   ('&TYPE' EQ 'NORMAL').NORMAL\n         MNOTE 8,'TYPE &TYPE IS NOT VALID.'\n         MEXIT\n.OVERRIDE ANOP\n##&OP    OPSYN &OP\n&OP      OPSYN\n         MEXIT\n.NORMAL  ANOP\n&OP      OPSYN ##&OP\n##&OP    OPSYN\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "##VPDSCT": {"ttr": 6403, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00\"\\x00\"\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##VPDSCT &GENTYPE=\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1991.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##VPDSCT\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##VPDSCT\n.*\n.*  PURPOSE    INTERNAL MACRO USED TO PROCESS VDA GENTYPE=DSECT\n.*             PROLOG.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    8/06/91 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &VDA__START(20)\n         GBLC  &VDA__ALIGN(20)\n         GBLA  &VDA__LEVEL\n&TAG     SETC  '&VDA__START(&VDA__LEVEL)'\n         AIF   (&VDA__LEVEL NE 1).PRC100\n&TAG     DSECT ,                       Start of VDA\n         AGO   .PRC200\n.PRC100  ANOP\n&TAG     DS    0&VDA__ALIGN(&VDA__LEVEL) Start of VDA\n.PRC200  ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##VPINLN": {"ttr": 6405, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00\\x1d\\x00\\x1d\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##VPINLN &GENTYPE=\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1991.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##VPINLN\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##VPINLN\n.*\n.*  PURPOSE    INTERNAL MACRO USED TO PROCESS VDA GENTYPE=INLINE\n.*             PROLOG.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    8/06/91 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &VDA__START(20)\n         GBLC  &VDA__ALIGN(20)\n         GBLA  &VDA__LEVEL\n&TAG     SETC  '&VDA__START(&VDA__LEVEL)'\n&TAG     DS    0&VDA__ALIGN(&VDA__LEVEL) Start of VDA\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##WESTD": {"ttr": 6407, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00b\\x00b\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 98, "newlines": 98, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##WESTD\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1986.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##WESTD\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##WESTD\n.*\n.*  PURPOSE    INTERNAL MACRO USED TO GENERATE EPILOG FOR A STANDARD\n.*             PWA.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    1/06/87 MGG - NEW\n.*              5/08/89 MGG - CHANGED &#PBWAID TO &PWA              @C1\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#CSF(500)               CALLSUB FROM\n         GBLA  &#CSFF(99)               FIRST FROM INDEX\n         GBLA  &#CSFT#N                 CALLSUB FROM/TO NEXT NUMBER\n         GBLA  &#CST(500)               CALLSUB TO\n         GBLA  &#PB#C                   PROGRAM BLOCK NUMBER\n         GBLB  &#PBDSWA                 ENDPWA SHOULD DO DS\n         GBLB  &#PBDYN                  PROGRAM BLOCK DYN OPTION\n         GBLC  &#PBDYNS                 DYNSIZE KEYWORD\n         GBLB  &#PBLOCR                 ENDPWA SHOULD DO DS\n         GBLC  &#PBNAME                 CSECT NAME OF PROGRAM BLOCK\n         GBLB  &#PBPPWA                 PARTIAL PWA ENCOUNTERED\n         GBLC  &PWA                     PWA ID                      @C1\n         GBLA  &#SB#CPB                 'SUB #' OF CURRENT PROG BLK\n         GBLA  &#SB#M                   MAX SUBROUTINE NUMBER\n         GBLC  &#SBNM(99)               SUBROUTINE NAMES\n         LCLA  &CTR\n         LCLA  &N\n         LCLC  &TAG\n&N       SETA  &#PB#C\n.*--------------------------------------------------------------------*\n.*  IF THIS IS A PARTIAL PWA, JUST SWITCH BACK TO CSECT.\n.*--------------------------------------------------------------------*\n.PRC0100 AIF   (&#PBPPWA).PRC1000\n.*--------------------------------------------------------------------*\n.*  IF DYN OPTION IN EFFECT, RESERVE ROOM FOR SUBROUTINE WORK AREAS.\n.*--------------------------------------------------------------------*\n         AIF   (NOT &#PBDYN).PRC0800\n#PBX&N   DS    0D                   EXTRA STORAGE FOR SWA'S AND PWA'S\n         AIF   ('&#PBDYNS' EQ '').PRC0300\n         AIF   ('&#PBDYNS'(1,1) EQ '-').PRC0300\n         AIF   ('&#PBDYNS'(1,1) EQ '+').PRC0300\n         DS    (&#PBDYNS)X\n         AGO   .PRC0800\n.PRC0300 ANOP\n&CTR     SETA  &#SB#CPB\n.PRC0310 AIF   (&CTR GT &#SB#M).PRC0315\n         MNOTE *,'&#SBNM(&CTR)(&CTR) first from indes is &#CSFF(&CTR)'\n&CTR     SETA  &CTR+1\n         AGO   .PRC0310\n.PRC0315 ANOP\n&CTR     SETA  &#SB#CPB\n.PRC0320 AIF   (&CTR GE &#CSFT#N).PRC0330\n         MNOTE *,'&CTR CALLSUB from &#SBNM(&#CSF(&CTR))(&#CSF(&CTR)) to$\n                &#SBNM(&#CST(&CTR))(&#CST(&CTR))'\n&CTR     SETA  &CTR+1\n         AGO   .PRC0320\n.PRC0330 ##ORGS &#SB#CPB,&#SB#CPB       DO ORGS\n         ORG   ,\n         AIF   ('&#PBDYNS' EQ '').PRC0700\n         ORG   *&#PBDYNS\n.PRC0700 DS    16F                      64 EXTRA BYTES\n.*--------------------------------------------------------------------*\n.*  GENERATE LENGTH TAG.\n.*--------------------------------------------------------------------*\n.PRC0800 DS    0D                       INSURE DOUBLEWORD ALIGNMENT\n&TAG     SETC  '&PWA.PLLEN'                                         @C1\n&TAG     EQU   *-&PWA                   LENGTH OF PWA               @C1\n.*--------------------------------------------------------------------*\n.*  GENERATE DS FOR PWA IF NEEDED.\n.*--------------------------------------------------------------------*\n         AIF   (NOT &#PBDSWA).PRC1000\n&#PBNAME CSECT ,\n         AIF   (NOT &#PBLOCR).PRC0820\n#PBDL&N  LOCTR ,                        PROGRAM STATIC DATA\n.PRC0820 ANOP\n#PBJ&N   DS    0D                       ALIGN ON DOUBLE WORD\n         DS    (&PWA.PLLEN)X            PWA STORAGE AREA            @C1\n         AIF   (NOT &#PBLOCR).PRC9000\n.PRC1000 ANOP\n.*--------------------------------------------------------------------*\n.*  SWITCH BACK TO CSECT.\n.*--------------------------------------------------------------------*\n&#PBNAME CSECT ,\n.PRC9000 MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##WPDC": {"ttr": 6410, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00Y\\x00Y\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 89, "newlines": 89, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##WPDC &TYPE\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1986.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##WPDC\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##WPDC\n.*\n.*  PURPOSE    INTERNAL MACRO USED TO GENERATE PROLOG FOR AN IDMS/DC\n.*             PWA.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    1/06/87 MGG - BROKE APART FROM PWA MACRO AND\n.*                            REORGANIZED.\n.*              5/08/89 MGG - CHANGED &#PBWAID TO &PWA.             @C1\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#PB#C                   PROGRAM BLOCK NUMBER\n         GBLB  &#PBDYN                  PROGRAM BLOCK DYN OPTION\n         GBLB  &#PBPWA                  PROGRAM BLOCK PWA OPTION\n         GBLB  &#PBPPWA                 PARTIAL PWA ENCOUNTERED\n         GBLB  &#SBSWA                  SWA OPTION ON SUBROUTINE BLOCK\n         GBLA  &#PBPLMX                 MAX PARMS IN PROGRAM\n         GBLA  &#PBWAMX                 MAX WORDS OF SMWA NEEDED\n         GBLC  &PWA                     PWA ID                      @C1\n         LCLA  &N\n         LCLC  &TAG\n.*--------------------------------------------------------------------*\n.*  IF TYPE=LAST, SUPPLY SWA FOR PREVIOUS SUBROUTINE IF MISSING.\n.*--------------------------------------------------------------------*\n         AIF   ('&TYPE' NE 'LAST').PRC0000\n         AIF   (NOT &#SBSWA).PRC0000\n         SWA   TYPE=LAST                FINISH LAST SWA\n         ENDSWA ,\n.PRC0000 ANOP\n.*--------------------------------------------------------------------*\n.*  REQUIRE THAT PWA OPTION BE SPECIFIED FOR PROGRAM.\n.*--------------------------------------------------------------------*\n         AIF   (&#PBPWA).PRC0010\n         MNOTE 8,'PWA option should be specified on the program block m$\n               acro'\n.PRC0010 ANOP\n.*--------------------------------------------------------------------*\n.*  GENERATE PWA DSECT CARD.\n.*--------------------------------------------------------------------*\n&N       SETA  &#PB#C\n&PWA     DSECT                          PWA DSECT                   @C1\n.*--------------------------------------------------------------------*\n.*  IF THIS IS THE FIRST CALL FOR THIS PWA, GENERATE DS'S FOR FIELDS\n.*  THAT GO AT THE START OF THE PWA.\n.*--------------------------------------------------------------------*\n.PRC0100 AIF   (&#PBPPWA).PRC0200\n         AIF   (NOT &#PBDYN).PRC0150\n#PBE&N   DS    A                        EOS - 64\n#PBR&N   DS    A                        RESERVED\n#PBN&N   DS    A                        NAB (FIRST SWA)\n.PRC0150 ANOP\n&#PBPPWA SETB  1\n.PRC0200 ANOP\n.*--------------------------------------------------------------------*\n.*  IF THIS IS TYPE=PARTIAL, ALL THAT NEEDS TO BE DONE HAS BEEN DONE.\n.*--------------------------------------------------------------------*\n         AIF   ('&TYPE' EQ 'PARTIAL').PRC0900\n.PRC0300 ANOP\n.*--------------------------------------------------------------------*\n.*  IF THIS IS TYPE=LAST, GENERATE FIELDS FOR SMWA AND PARAMETER LIST\n.*  STORAGE.\n.*--------------------------------------------------------------------*\n         AIF   ('&TYPE' NE 'LAST').PRC0400\n&#PBPPWA SETB  0\n#PBW&N   DS    &#PBWAMX.A               SMWA\n#PBP&N   DS    &#PBPLMX.A               PARAMETER LIST STORAGE\n#PBU&N   DS    0X                       START OF USER STORAGE\n         AGO   .PRC0900\n.PRC0400 ANOP\n.*--------------------------------------------------------------------*\n.*  IF TYPE IS NOT ONE OF THE ABOVE THEN IT IS INVALID.\n.*--------------------------------------------------------------------*\n         MNOTE 8,'Invalid type &TYPE specified on PWA macro'\n.PRC0900 ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##WPOS": {"ttr": 6413, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00Z\\x00Z\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 90, "newlines": 90, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##WPOS &TYPE\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1986.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##WPOS\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##WPOS\n.*\n.*  PURPOSE    INTERNAL MACRO USED TO GENERATE PROLOG FOR A STANDARD\n.*             PWA.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    1/06/87 MGG - BROKE APART FROM PWA MACRO AND\n.*                            REORGANIZED.\n.*              5/08/89 MGG - CHANGED &#PBWAID TO &PWA.             @C1\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#PB#C                   PROGRAM BLOCK NUMBER\n         GBLB  &#PBDYN                  PROGRAM BLOCK DYN OPTION\n         GBLB  &#PBPWA                  PROGRAM BLOCK PWA OPTION\n         GBLB  &#PBPPWA                 PARTIAL PWA ENCOUNTERED\n         GBLB  &#SBSWA                  SWA OPTION ON SUBROUTINE BLOCK\n         GBLA  &#PBPLMX                 MAX PARMS IN PROGRAM\n         GBLA  &#PBWAMX                 MAX WORDS OF SMWA NEEDED\n         GBLC  &PWA                     PWA ID                      @C1\n         LCLA  &N\n         LCLC  &TAG\n.*--------------------------------------------------------------------*\n.*  IF TYPE=LAST, SUPPLY SWA FOR PREVIOUS SUBROUTINE IF MISSING.\n.*--------------------------------------------------------------------*\n         AIF   ('&TYPE' NE 'LAST').PRC0000\n         AIF   (NOT &#SBSWA).PRC0000\n         SWA   TYPE=LAST                FINISH LAST SWA\n         ENDSWA ,\n.PRC0000 ANOP\n.*--------------------------------------------------------------------*\n.*  REQUIRE THAT PWA OPTION BE SPECIFIED FOR PROGRAM.\n.*--------------------------------------------------------------------*\n         AIF   (&#PBPWA).PRC0010\n         MNOTE 8,'PWA option should be specified on the program block m$\n               acro'\n.PRC0010 ANOP\n.*--------------------------------------------------------------------*\n.*  GENERATE PWA DSECT CARD.\n.*--------------------------------------------------------------------*\n&N       SETA  &#PB#C\n&PWA DSECT                              PWA DSECT                   @C1\n.*--------------------------------------------------------------------*\n.*  IF THIS IS THE FIRST CALL FOR THIS PWA, GENERATE DS'S FOR FIELDS\n.*  THAT GO AT THE START OF THE PWA.\n.*--------------------------------------------------------------------*\n.PRC0100 AIF   (&#PBPPWA).PRC0200\n#PBS&N   DS    18F                      STANDARD OS SAVE AREA\n         AIF   (NOT &#PBDYN).PRC0150\n#PBE&N   DS    A                        EOS - 64\n#PBR&N   DS    A                        RESERVED\n#PBN&N   DS    A                        NAB (FIRST SWA)\n.PRC0150 ANOP\n&#PBPPWA SETB  1\n.PRC0200 ANOP\n.*--------------------------------------------------------------------*\n.*  IF THIS IS TYPE=PARTIAL, ALL THAT NEEDS TO BE DONE HAS BEEN DONE.\n.*--------------------------------------------------------------------*\n         AIF   ('&TYPE' EQ 'PARTIAL').PRC0900\n.PRC0300 ANOP\n.*--------------------------------------------------------------------*\n.*  IF THIS IS TYPE=LAST, GENERATE FIELDS FOR SMWA AND PARAMETER LIST\n.*  STORAGE.\n.*--------------------------------------------------------------------*\n         AIF   ('&TYPE' NE 'LAST').PRC0400\n&#PBPPWA SETB  0\n#PBW&N   DS    &#PBWAMX.A               SMWA\n#PBP&N   DS    &#PBPLMX.A               PARAMETER LIST STORAGE\n#PBU&N   DS    0X                       START OF USER STORAGE\n         AGO   .PRC0900\n.PRC0400 ANOP\n.*--------------------------------------------------------------------*\n.*  IF TYPE IS NOT ONE OF THE ABOVE THEN IT IS INVALID.\n.*--------------------------------------------------------------------*\n         MNOTE 8,'Invalid type &TYPE specified on PWA macro'\n.PRC0900 ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##WPPLI": {"ttr": 6416, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00\\x80\\x00\\x80\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 128, "newlines": 128, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##WPPLI &TYPE\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1986.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##WPPLI\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##WPPLI\n.*\n.*  PURPOSE    INTERNAL MACRO USED TO GENERATE PROLOG FOR A PLI\n.*             PWA.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    1/06/87 MGG - NEW\n.*              5/08/89 MGG - CHANGED &#PBWAID TO &PWA.             @C1\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#PB#C                   PROGRAM BLOCK NUMBER\n         GBLA  &#PBPLMX                 MAX PARMS IN PROGRAM\n         GBLB  &#PBPPWA                 PARTIAL PWA ENCOUNTERED\n         GBLB  &#PBPWA                  PROGRAM BLOCK PWA OPTION\n         GBLC  &PWA                     PWA DSECT TAG               @C1\n         GBLA  &#PBWAMX                 MAX WORDS OF SMWA NEEDED\n         GBLB  &#SBSWA                  SWA OPTION ON SUBROUTINE BLOCK\n         LCLA  &N\n         LCLC  &TAG\n         LCLC  &D\n&D       SETC  '&PWA'                                               @C1\n.*--------------------------------------------------------------------*\n.*  IF TYPE=LAST, SUPPLY SWA FOR PREVIOUS SUBROUTINE IF MISSING.\n.*--------------------------------------------------------------------*\n         AIF   ('&TYPE' NE 'LAST').PRC0000\n         AIF   (NOT &#SBSWA).PRC0000\n         SWA   TYPE=LAST                FINISH LAST SWA\n         ENDSWA ,\n.PRC0000 ANOP\n.*--------------------------------------------------------------------*\n.*  REQUIRE THAT PWA OPTION BE SPECIFIED FOR PROGRAM.\n.*--------------------------------------------------------------------*\n         AIF   (&#PBPWA).PRC0010\n         MNOTE 8,'PWA option should be specified on the program block m$\n               acro'\n.PRC0010 ANOP\n.*--------------------------------------------------------------------*\n.*  GENERATE PWA DSECT CARD.\n.*--------------------------------------------------------------------*\n&N       SETA  &#PB#C\n&PWA DSECT                              PWA DSECT                   @C1\n.*--------------------------------------------------------------------*\n.*  IF THIS IS THE FIRST CALL FOR THIS PWA, GENERATE DS'S FOR FIELDS\n.*  THAT GO AT THE START OF THE PWA.\n.*--------------------------------------------------------------------*\n.PRC0100 AIF   (&#PBPPWA).PRC0200\n&#PBPPWA SETB  1\n*=====================================================================*\n*  PL/I DYNAMIC STORAGE AREA (PL/I OPTIMIZING COMPILER)               *\n*                                                                     *\n*  MORE INFORMATION ABOUT THIS CONTROL BLOCK IS CONTAINED IN THE      *\n*  OS PL/I OPTIMIZING COMPILER: EXECUTION LOGIC.                      *\n*                                                                     *\n*=====================================================================*\n         SPACE\n&D.XF1A  DS    B                        FLAGS (FIRST BYTE)\n&D.XF1B  DS    B                        FLAGS (SECOND BYTE)\n&D.XOF   DS    H                        OFFSET\n&D.XBCH  DS    A                        BACK CHAIN\n&D.XRS1  DS    A                        NOT USED\n&D.XS14  DS    F                        SAVE AREA R14\n&D.XS15  DS    F                        SAVE AREA R15\n&D.XS0   DS    F                        SAVE AREA R0\n&D.XS1   DS    F                        SAVE AREA R1\n&D.XS2   DS    F                        SAVE AREA R2\n&D.XS3   DS    F                        SAVE AREA R3\n&D.XS4   DS    F                        SAVE AREA R4\n&D.XS5   DS    F                        SAVE AREA R5\n&D.XS6   DS    F                        SAVE AREA R6\n&D.XS7   DS    F                        SAVE AREA R7\n&D.XS8   DS    F                        SAVE AREA R8\n&D.XS9   DS    F                        SAVE AREA R9\n&D.XS10  DS    F                        SAVE AREA R10\n&D.XS11  DS    F                        SAVE AREA R11\n&D.XS12  DS    F                        SAVE AREA R12\n&D.XALWS DS    A                        ADDRESS OF LWS\n&D.XANAB DS    A                        ADDRESS OF NAB\n&D.XEPNA DS    A                        END OF PROLOG NAB\n&D.XBEC  DS    H                        BLOCK-ENABLE CELL\n&D.XCEC  DS    H                        CURRENT-ENABLE CELL\n&D.XSB   DS    A                        STATIC BACK CHAIN\n&D.XFONC DS    A                        ADDRESS OF FIRST ONCB\n&D.XCONC DS    A                        ADDRESS OF MOST RESENT ONCB\n&D.XRSV2 DS    A                        RESERVED\n&D.XRSV3 DS    A                        RESERVED\n&D.XRSV4 DS    A                        RESERVED\n&D.XAONC DS    A                        ADDRESS OF ONCELLS\n&D.XCEXQ DS    X                        SAVE AREA FOR FIRST BYTE OF TCA\n&D.XRSV5 DS    X                        RESERVED\n&D.XF2   DS    B                        FLAGS\n&D.XCT   DS    B                        CT FLAGS\n.PRC0200 ANOP\n.*--------------------------------------------------------------------*\n.*  IF THIS IS TYPE=PARTIAL, ALL THAT NEEDS TO BE DONE HAS BEEN DONE.\n.*--------------------------------------------------------------------*\n         AIF   ('&TYPE' EQ 'PARTIAL').PRC0900\n.PRC0300 ANOP\n.*--------------------------------------------------------------------*\n.*  IF THIS IS TYPE=LAST, GENERATE FIELDS FOR SMWA AND PARAMETER LIST\n.*  STORAGE.\n.*--------------------------------------------------------------------*\n         AIF   ('&TYPE' NE 'LAST').PRC0400\n&#PBPPWA SETB  0\n#PBW&N   DS    &#PBWAMX.A               SMWA\n#PBP&N   DS    &#PBPLMX.A               PARAMETER LIST STORAGE\n#PBU&N   DS    0X                       START OF USER STORAGE\n         AGO   .PRC0900\n.PRC0400 ANOP\n.*--------------------------------------------------------------------*\n.*  IF TYPE IS NOT ONE OF THE ABOVE THEN IT IS INVALID.\n.*--------------------------------------------------------------------*\n         MNOTE 8,'Invalid type &TYPE specified on PWA macro'\n.PRC0900 ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##XEFF": {"ttr": 6419, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00.\\x00.\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n&TAG     ##XEFF &NAME\n.*--------------------------------------------------------------------*\n.*\n.*  (C) Copyright 1991.  Clemson University Computer Center.\n.*\n.*  Macro:     ##XEFF\n.*\n.*  Title:     Clemson University Computer Center Structured\n.*             Programming Macros - ##XEFF\n.*\n.*  Purpose:   Internal macro used to generate the code in a module\n.*             prolog for the XEFF option of ##PPOS.\n.*\n.*  Note:      See the following document for more information on\n.*             this and other Structured Programming macros:\n.*\n.*             . Clemson University Computer Center Structured\n.*               Programming Macros User's Guide And Reference.\n.*\n.*  Activity:   2/13/91 MGG - New.\n.*              4/19/91 JCB - Minor changes before installation.\n.*\n.*--------------------------------------------------------------------*\n.*       Exit Effector Control Block.  A mapping macro exists in\n.*       SYSTEMS.CXM.SOURCE(CXMMACS).\n.*--------------------------------------------------------------------*\n         DS    0H\n         DC    CL4'XEFF'                Sanity check ID\n         DC    CL8'&NAME'               Name of exit\n         DC    Y(##XEFF_STM_&SYSNDX-&TAG) Offset that is used by\n*                                         XEFF to calculate where\n*                                         it should branch to in\n*                                         either the original module\n*                                         or replacement.\n&TAG     STM   R14,R12,12(R13)          Save registers.\n         L     R1,16                    Point to CVT.\n         ICM   R1,B'0111',205(R1)       Point to UVT.\n         BZ    ##XEFF_RESTORE_&SYSNDX   Don't call XEFF if zero.\n         ICM   R1,B'1111',4(R1)         Load address of XEFF.\n.*       ICM   R1,B'1111',=V(CXMEXEFF)  << Testing >>\n         BNZR  R1                       Call XEFF if not zero.\n##XEFF_RESTORE_&SYSNDX DS 0H\n         L     R1,24(,R13)              Restore R1.\n##XEFF_STM_&SYSNDX     DS 0H            Place where XEFF returns.\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE107": {"ttr": 6658, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x99\\x08?\\x01\\x00\"o\\x15E\\x009\\x00 \\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1999-03-24T00:00:00", "modifydate": "2000-08-13T15:45:00", "lines": 57, "newlines": 32, "modlines": 0, "user": "WSBG"}, "text": "//***FILE 107 is the Clemson University Structured Macro Library    *   FILE 107\n//*           from Mr James C Blalock.  This file contains the      *   FILE 107\n//*           Macro Library and docmentation members on how to use  *   FILE 107\n//*           the system.  This file is in IEBUPDTE SYSIN format.   *   FILE 107\n//*           For additional information see the members called     *   FILE 107\n//*           $$README and $$DOC.  File 108 of this tape contains   *   FILE 107\n//*           the SAMPLIB Library for these structured macros.      *   FILE 107\n//*                                                                 *   FILE 107\n//*           email :   carey@clemson.edu                           *   FILE 107\n//*                                                                 *   FILE 107\n//*           The information in this file was downloaded from      *   FILE 107\n//*           Jim Blalock's home page at:                           *   FILE 107\n//*                                                                 *   FILE 107\n//*           http://people.clemson.edu/~carey                      *   FILE 107\n//*                                                                 *   FILE 107\n//*           The following explanations accompany the download     *   FILE 107\n//*           web page.                                             *   FILE 107\n//*                                                                 *   FILE 107\n//*           Note:  The Users Guide is written in DCF              *   FILE 107\n//*           (SCRIPT/VS) using GML.  If anyone needs it and        *   FILE 107\n//*           doesn't have access to GML, the samplib contains      *   FILE 107\n//*           an FBM IEBGENER-able version:  It isn't pretty        *   FILE 107\n//*           but you can read it.                                  *   FILE 107\n//*                                                                 *   FILE 107\n//*           Support (yeah right):  It's like this, folks:         *   FILE 107\n//*           We're all seasoned professionals here, and busy       *   FILE 107\n//*           people besides.  I'll answer questions if I have      *   FILE 107\n//*           time, but please take a shot at figuring a            *   FILE 107\n//*           problem out on your own first.  The SAMPLIB           *   FILE 107\n//*           should contain enough examples to get you past        *   FILE 107\n//*           the how-do-I questions.  I'll try to add some         *   FILE 107\n//*           more stuff like MPF exits later.                      *   FILE 107\n//*                                                                 *   FILE 107\n//*              COPYRIGHT CLEMSON UNIVERSITY, 1989, 1998           *   FILE 107\n//*                                                                 *   FILE 107\n//*           THE MATERIALS CONTAINED IN FILES 107 AND 108 OF       *   FILE 107\n//*           THIS TAPE ARE PROVIDED FOR GENERAL USE BY CLEMSON     *   FILE 107\n//*           UNIVERSITY.  ALTHOUGH THE PACKAGE HAS BEEN TESTED     *   FILE 107\n//*           TO CLEMSON UNIVERSITY'S SATISFACTION FOR THE          *   FILE 107\n//*           PURPOSE FOR WHICH IT WAS INTENDED, NO WARRANTY,       *   FILE 107\n//*           EXPRESSED OR IMPLIED, IS MADE BY CLEMSON UNIVERSITY   *   FILE 107\n//*           AS TO THE ACCURACY AND FUNCTIONING OF THE             *   FILE 107\n//*           PROGRAM(S) AND RELATED MATERIALS.  CLEMSON            *   FILE 107\n//*           UNIVERSITY ASSUMES NO LIABILITY FOR ANY DAMAGE THAT   *   FILE 107\n//*           MAY BE CAUSED BY ANY USE OF THIS PACKAGE.             *   FILE 107\n//*                                                                 *   FILE 107\n//*           THE MATERIALS CONTAINED IN THIS PACKAGE ARE           *   FILE 107\n//*           DISTRIBUTED ON AN 'AS-IS' BASIS.  CLEMSON             *   FILE 107\n//*           UNIVERSITY IS UNDER NO OBLIGATION TO MAINTAIN OR      *   FILE 107\n//*           UPGRADE THIS PACKAGE, NOR IS CLEMSON UNIVERSITY       *   FILE 107\n//*           UNDER ANY OBLIGATION TO FURNISH ASSISTANCE OR         *   FILE 107\n//*           ADDITIONAL MATERIALS.                                 *   FILE 107\n//*                                                                 *   FILE 107\n//*           BY USE OF THIS PACKAGE, THE ORGANIZATION AGREES TO    *   FILE 107\n//*           ACKNOWLEDGE CLEMSON UNIVERSITY AS THE ORIGINATOR OF   *   FILE 107\n//*           THE PACKAGE.                                          *   FILE 107\n//*                                                                 *   FILE 107\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BLOCK": {"ttr": 6660, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x01U\\x01U\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 341, "newlines": 341, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         BLOCK &NAME=,                  NAME OF BLOCK                  $\n               &AMODE=,                 ADDRESSING MODE                $\n               &BASEREG=,               BASE REGS                      $\n               &CPYRGHT=,               COPYRIGHT NOTICE               $\n               &DYNERR=,                DYNAMIC STORAGE ERROR EXIT     $\n               &DYNSIZE=,               SIZE OF DYNAMIC STORAGE        $\n               &EXPMAC=,                MACRO USED TO EXPAND THE BLOCK $\n               &OPTIONS=,               OPTIONS                        $\n               &ENVIRON=,               SETS DEFAULT EXPANSION MACROS  $\n               &PARMS=,                 INPUT PARAMETERS            @C1$\n               &PARMMAP=,               INPUT PARAMETER MAPPING     @C1$\n               &PL=,                    DEFAULT PL FOR PLIST        @C1$\n               &PWAREG=,                PWA REGS                       $\n               &PWASP=,                 PROGRAM WORK AREA SUB POOL     $\n               &RECUR=,                 MAX RECURSIVE CALLS            $\n               &RMODE=,                 RESIDENCE MODE                 $\n               &R1SAVE=,                PARM SAVE REGISTER             $\n               &SAVE=,                  REGISTER TO SAVE               $\n               &SMWA=,                  STRUCTURED MACRO WORK AREA     $\n               &SUBOPTS=,               DEFAULT SUBROUTINE OPTIONS     $\n               &SVAREA=,                SAVE AREA TAG NAME             $\n               &SWAREG=,                SWA BASE REGS                  $\n               &TYPE=INLINE             BLOCK TYPE\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      BLOCK\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - BLOCK\n.*\n.*  PURPOSE    STRUCTURED MACRO USED TO START A BLOCK STRUCTURE.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 MGG - NEW\n.*             11/10/83 MGG - ADDED BR14 OPTION TO PROGRAM BLOCK\n.*             04/26/84 MGG - ADDED CUSTOM SUBROUTINE SUPPORT\n.*             10/22/84 MGG - FIXED &CPYRGHT KEYWORD\n.*              4/30/85 MGG - PUT IN RESTRICTION THAT IF AN INLINE\n.*                            BLOCK CONTAINED WITHIN A SUBROUTINE\n.*                            BLOCK SPECIFIES AMODE 24 OR 31, THEN\n.*                            THE SUBROUTINE BLOCK MUST ALSO SPECIFY\n.*                            AMODE 24 OR 31.  THIS RESTRICTION\n.*                            SHOULD BE REMOVED WHEN A WAY TO SAVE\n.*                            THE AMODE AT ENTRY TO THE SUBROUTINE\n.*                            IS ESTABLISHED.\n.*              6/27/85 MGG - PUT IN SUPPORT FOR VL OPTION AND\n.*                            PL KEYWORD OPTION\n.*              7/13/85 MGG - PUT IN DYNAMIC STORAGE SUPPORT\n.*              1/22/86 MGG - ADDED OPTION LOCTR\n.*              2/14/86 MGG - ADDED LONG OPTION\n.*                            SUBOPTS KEYWORD\n.*                            LOADBASE SUBROUTINE OPTION\n.*                            BASEREG KEYWORD ON SUBROUTINE BLOCK\n.*                            AUTOMATIC CLOSE SWA SUPPORT\n.*              9/10/86 MGG - ADDED NORENT PWA SUPPORT\n.*             12/15/86 MGG - MAJOR REVISION AND RESTRUCTURE\n.*                            REMOVED @CN\n.*              4/28/89 MGG - ADDED PARMS AND PARMMAP KEYWORDS.     @C1\n.*              5/08/89 MGG - ADDED VARIOUS NEW GLOBAL VARIABLES.   @C2\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#BLVL                   BLOCK LEVEL\n         GBLA  &#BMLVL(20)              BLOCK STRUCTURAL LEVEL\n         GBLC  &#BNAME(20)              BLOCK NAMES\n         GBLA  &#BNDX(20)               BLOCK TAG INDEXS\n         GBLC  &#BPL1(20)               PL KEYWORD PARAMETER 1\n         GBLC  &#BPL2(20)               PL KEYWORD PARAMETER 2\n         GBLC  &#BTYPE(20)              BLOCK TYPE\n         GBLA  &#CSFT#N                 CALLSUB FROM/TO NEXT NUMBER\n         GBLC  &#EPMAC                  ERREXIT BLOCK PROLOG MACRO NAME\n         GBLC  &#IPMAC                  INLINE BLOCK PROLOG MACRO NAME\n         GBLA  &#MLVL                   CURRENT STRUCTURAL LEVEL\n         GBLA  &#MNDX                   LAST TAG INDEX USED\n         GBLA  &#PB#C                   # OF CURRENT PROGRAM BLOCK\n         GBLB  &#PBENC                  PROGRAM BLOCK ENCOUNTERED\n         GBLC  &#PBNAME                 PROGRAM BLOCK NAME\n         GBLA  &#PBNDX                  PROGRAM BLOCK INDEX\n         GBLA  &#PBPLMX                 MAX PL ENTRIES IN PROGRAM\n         GBLA  &#PBWAMX                 MAX SMWA IN PROGRAM\n         GBLC  &#PPMAC                  PROGRAM BLOCK PROLOG MACRO NAME\n         GBLA  &#SB#C                   # OF CURRENT SUBROUTINE\n         GBLA  &#SB#CPB                 'SUB #' OF CURRENT PROG BLK\n         GBLB  &#SBSWA                  SWA HAS NOT BEEN ENDED      @C2\n         GBLA  &#SB#D                   SUB BLOCK NMBR FROM ##DEFSUB\n         GBLA  &#SBPLMX                 MAX PL ENTRIES IN SUBROUTINE\n         GBLC  &#SPMAC                  SUBROUTINE PROLOG MACRO\n         GBLC  &PWA                     PWA ID                      @C2\n         GBLC  &PSD                     PSD ID                      @C2\n         GBLC  &PPL                     PPL ID                      @C2\n         GBLC  &SWA                     SWA ID                      @C2\n         GBLC  &SSD                     SSD ID                      @C2\n         GBLC  &SPL                     SPL ID                      @C2\n         GBLC  &W                       SWA ID                      @C2\n         GBLC  &S                       SSD ID                      @C2\n         GBLC  &P                       SPL ID                      @C2\n         LCLC  &MAC                     WORK FIELD\n.*--------------------------------------------------------------------*\n.*  DO HOUSEKEEPING THAT APPLIES TO ALL BLOCKS.\n.*--------------------------------------------------------------------*\n         AIF   (&#BLVL GE 20).ERR0001   CAN ONLY BE NESTED 20 LEVELS\n&#BLVL   SETA  &#BLVL+1                 ADD ONE TO BLOCK LEVEL\n&#MLVL   SETA  &#MLVL+1                 ADD ONE TO STRUCTURAL LEVEL\n&#MNDX   SETA  &#MNDX+1                 ADD ONE TO TAG INDEX\n&#BNAME(&#BLVL) SETC '&NAME'            SAVE NAME\n&#BNDX(&#BLVL)  SETA &#MNDX             SAVE TAG INDEX\n&#BMLVL(&#BLVL) SETA &#MLVL             SAVE STRUCTURAL LEVEL FOR BLOCK\n&#BTYPE(&#BLVL) SETC '&TYPE'            SET TYPE\n&#BPL1(&#BLVL)  SETC '&PL(1)'           SAVE PL PARAMETER 1\n&#BPL2(&#BLVL)  SETC '&PL(2)'           SAVE PL PARAMETER 2\n         AIF   (N'&PL LE 2).PRC0000\n         MNOTE 8,'Too many parameters specified on PL keyword'\n.*====================================================================*\n.*  TYPE=INLINE.\n.*====================================================================*\n.PRC0000 AIF   ('&TYPE' NE 'INLINE').PRC0100\n.*--------------------------------------------------------------------*\n.*  INLINE BLOCKS MUST NOT BE AT LEVEL 0.\n.*--------------------------------------------------------------------*\n         AIF   (&#BLVL NE 1).PRC0010\n         MNOTE 8,'INLINE BLOCK must be contained within PROGRAM, SUBROU$\n               TINE, or ERREXIT BLOCK'\n.PRC0010 ANOP\n.*--------------------------------------------------------------------*\n.*  DISPLAY ERRORS FOR IGNORED KEYWORDS.\n.*--------------------------------------------------------------------*\n         ##IGMSG &SUBOPTS,SUBOPTS         DEFAULT SUBROUTINE OPTIONS\n         ##IGMSG &BASEREG,BASEREG         BASE REGS\n         ##IGMSG &PWAREG,PWAREG           PWA REGS\n         ##IGMSG &SVAREA,SVAREA           SAVE AREA TAG NAME\n         ##IGMSG &CPYRGHT,CPYRGHT         COPYRIGHT NOTICE\n         ##IGMSG &RMODE,RMODE             RESIDENCE MODE\n         ##IGMSG &PARMS,PARMS             INPUT PARMS               @C1\n         ##IGMSG &PARMMAP,PARMMAP         INPUT PARAMETER MAPPING   @C1\n         ##IGMSG &R1SAVE,R1SAVE           PARM SAVE REGISTER\n         ##IGMSG &SMWA,SMWA               STRUCTURED MACRO WORK AREA\n         ##IGMSG &DYNSIZE,DYNSIZE         SIZE OF DYNAMIC STORAGE\n         ##IGMSG &DYNERR,DYNERR           DYNAMIC STORAGE ERROR EXIT\n         ##IGMSG &SWAREG,SWAREG           SWA BASE REGS\n         ##IGMSG &RECUR,RECUR             MAX RECURSIVE CALLS\n         ##IGMSG &PWASP,PWASP             PROGRAM WORK AREA SUB POOL\n         ##IGMSG &ENVIRON,ENVIRON         DEFAULT PROLOG/EPILOG MACROS\n.*--------------------------------------------------------------------*\n.*  ISSUE MACRO TO GENERATE CODE FOR BLOCK.\n.*--------------------------------------------------------------------*\n&MAC     SETC  '&#IPMAC'\n         AIF   ('&EXPMAC' EQ '').PRC0050\n&MAC     SETC  '&EXPMAC'\n.PRC0050 ANOP\n         &MAC  &NAME,                   NAME OF BLOCK                  $\n               &OPTIONS,                OPTIONS                        $\n               &AMODE,                  ADDRESSING MODE                $\n               &SAVE                    REGISTER TO SAVE\n         AGO   .EXIT\n.*====================================================================*\n.*  TYPE=PROGRAM.\n.*====================================================================*\n.PRC0100 AIF   ('&TYPE' NE 'PROGRAM').PRC0200\n.*--------------------------------------------------------------------*\n.*  PROGRAM BLOCKS MUST NOT BE AT LEVEL 0.\n.*--------------------------------------------------------------------*\n         AIF   (&#BLVL EQ 1).PRC0110    PROGRAM BLOCK MUST BE LVL=1\n         MNOTE 8,'PROGRAM BLOCK must be at block nesting level 1'\n.PRC0110 ANOP\n         AIF   ('&#BNAME(&#BLVL)' NE '').PRC0115                    @C2\n         MNOTE 8,'PROGRAM BLOCK requires NAME keyword'              @C2\n&#BNAME(&#BLVL) SETC '#1$&SYSNDX'                                   @C2\n.PRC0115 ANOP                                                       @C2\n.*--------------------------------------------------------------------*\n.*  DO HOUSEKEEPING.\n.*--------------------------------------------------------------------*\n&#PB#C   SETA  &#PB#C+1                 SET PROGRAM BLOCK NUMBER\n&#PBENC  SETB  1                        INDICATE PGM BLOCK ENCOUNTERED\n         ##DEFSUB &#BNAME(&#BLVL)       DEFINE PROGRAM BLOCK NAME\n&#SB#C   SETA  &#SB#D                   SET CURRENT BLOCK NUMBER\n&#SB#CPB SETA  &#SB#D                   SET BLOCK NUMBER OF CURRENT PGM\n&#CSFT#N SETA  1                        RESET FROM TO ARRAY INDEX\n&#PBPLMX SETA  0                        RESET MAXIMUM PARAMETER LIST\n&#PBNAME SETC  '&#BNAME(&#BLVL)'        SET PROGRAM BLOCK NAME\n&#PBNDX  SETA  &#MNDX                   SET PROGRAM BLOCK INDEX\n&#PBWAMX SETA  0                        RESET MAX SMWA IN PROGRAM\n&PWA     SETC  'PWA&#PB#C._'            SET PWA TAG                 @C2\n&PSD     SETC  'PSD&#PB#C._'            SET PSD TAG                 @C2\n&PPL     SETC  'PPL&#PB#C._'            SET PPL TAG                 @C2\n.*--------------------------------------------------------------------*\n.*  DISPLAY ERRORS FOR IGNORED KEYWORDS.\n.*--------------------------------------------------------------------*\n         ##IGMSG &SWAREG,SWAREG           SWA BASE REGS\n         ##IGMSG &RECUR,RECUR             MAX RECURSIVE CALLS\n         ##IGMSG &SAVE,SAVE               REGISTER TO SAVE\n.*--------------------------------------------------------------------*\n.*  SET EXPANSION MACRO NAMES.\n.*--------------------------------------------------------------------*\n.PRC0120 AIF   ('&ENVIRON' EQ '').PRC0130\n         AIF   (K'&ENVIRON LE 5).PRC0125\n         MNOTE 8,'ENVIRON must be less than 5 alphanumeric characters'\n         AGO   .PRC0130\n.PRC0125 ##$&ENVIRON ,\n         AGO   .PRC0140\n.PRC0130 ##$OS    ,\n.PRC0140 ANOP\n.*--------------------------------------------------------------------*\n.*  ISSUE MACRO TO GENERATE CODE FOR BLOCK.\n.*--------------------------------------------------------------------*\n&MAC     SETC  '&#PPMAC'\n         AIF   ('&EXPMAC' EQ '').PRC0150\n&MAC     SETC  '&EXPMAC'\n.PRC0150 ANOP\n         &MAC  &#BNAME(&#BLVL),         NAME OF BLOCK               @C2$\n               &OPTIONS,                OPTIONS                        $\n               &SUBOPTS,                DEFAULT SUBROUTINE OPTIONS     $\n               &BASEREG,                BASE REGS                      $\n               &PWAREG,                 PWA REGS                       $\n               &SVAREA,                 SAVE AREA TAG NAME             $\n               &CPYRGHT,                COPYRIGHT NOTICE               $\n               &AMODE,                  ADDRESSING MODE                $\n               &RMODE,                  RESIDENCE MODE                 $\n               &R1SAVE,                 PARM SAVE REGISTER             $\n               &SMWA,                   STRUCTURED MACRO WORK AREA     $\n               &DYNSIZE,                SIZE OF DYNAMIC STORAGE        $\n               &DYNERR,                 DYNAMIC STORAGE ERROR EXIT     $\n               &PWASP,                  PROGRAM WORK AREA SUB POOL  @C1$\n               &PARMS,                  INPUT PARAMETERS            @C1$\n               &PARMMAP                 INPUT PARAMETER MAPPING     @C1\n         AGO   .EXIT\n.*====================================================================*\n.*  TYPE=SUBROUTINE.\n.*====================================================================*\n.PRC0200 AIF   ('&TYPE' NE 'SUBROUTINE').PRC0300\n.*--------------------------------------------------------------------*\n.*  SUBROUTINE BLOCKS MUST BE AT BLOCK LEVEL 0.\n.*--------------------------------------------------------------------*\n         AIF   (&#BLVL EQ 1 AND &#PBENC).PRC0210\n         MNOTE 8,'SUBROUTINE BLOCK must follow ENDBLK for PROGRAM BLOCK$\n               and be at block level zero'\n.PRC0210 ANOP\n         AIF   ('&#BNAME(&#BLVL)' NE '').PRC0220                    @C2\n         MNOTE 8,'SUBROUTINE BLOCK requires NAME keyword'           @C2\n&#BNAME(&#BLVL) SETC '#1$&SYSNDX'                                   @C2\n.PRC0220 ANOP                                                       @C2\n         AIF   (NOT &#SBSWA).PRC0230                                @C2\n         SWA   TYPE=LAST                SUPPLY MISSING SWA          @C2\n         ENDSWA ,                                                   @C2\n.PRC0230 ANOP                                                       @C2\n         ##DEFSUB &#BNAME(&#BLVL)                                   @C2\n&#SB#C   SETA  &#SB#D                                               @C2\n&W       SETC  'SWA&#SB#C._'                                        @C2\n&S       SETC  'SSD&#SB#C._'                                        @C2\n&P       SETC  'SPL&#SB#C._'                                        @C2\n&SWA     SETC  '&W'                     SET SWA TAG                 @C2\n&SSD     SETC  '&S'                     SET SSD TAG                 @C2\n&SPL     SETC  '&P'                     SET SPL TAG                 @C2\n.*--------------------------------------------------------------------*\n.*  DISPLAY ERRORS FOR IGNORED KEYWORDS.\n.*--------------------------------------------------------------------*\n         ##IGMSG &SUBOPTS,SUBOPTS         DEFAULT SUBROUTINE OPTIONS\n         ##IGMSG &PWAREG,PWAREG           PWA REGS\n         ##IGMSG &SVAREA,SVAREA           SAVE AREA TAG NAME\n         ##IGMSG &CPYRGHT,CPYRGHT         COPYRIGHT NOTICE\n         ##IGMSG &RMODE,RMODE             RESIDENCE MODE\n         ##IGMSG &R1SAVE,R1SAVE           PARM SAVE REGISTER\n         ##IGMSG &SMWA,SMWA               STRUCTURED MACRO WORK AREA\n         ##IGMSG &DYNSIZE,DYNSIZE         SIZE OF DYNAMIC STORAGE\n         ##IGMSG &DYNERR,DYNERR           DYNAMIC STORAGE ERROR EXIT\n         ##IGMSG &PWASP,PWASP             PROGRAM WORK AREA SUB POOL\n         ##IGMSG &ENVIRON,ENVIRON         ENVIRONMENT\n.*--------------------------------------------------------------------*\n.*  ISSUE MACRO TO GENERATE CODE FOR BLOCK.\n.*--------------------------------------------------------------------*\n&MAC     SETC  '&#SPMAC'\n         AIF   ('&EXPMAC' EQ '').PRC0250\n&MAC     SETC  '&EXPMAC'\n.PRC0250 ANOP\n         &MAC  &#BNAME(&#BLVL),         NAME OF BLOCK               @C2$\n               &OPTIONS,                OPTIONS                        $\n               &BASEREG,                BASE REGS                      $\n               &AMODE,                  ADDRESSING MODE                $\n               &SMWA,                   STRUCTURED MACRO WORK AREA     $\n               &SWAREG,                 SWA BASE REGS                  $\n               &RECUR,                  MAX RECURSIVE CALLS            $\n               &SAVE,                   REGISTER TO SAVE            @C1$\n               &PARMS,                  INPUT PARAMETERS            @C1$\n               &PARMMAP                 INPUT PARAMETER MAPPING     @C1\n         AGO   .EXIT\n.*====================================================================*\n.*  TYPE=ERREXIT.\n.*====================================================================*\n.PRC0300 AIF   ('&TYPE' NE 'ERREXIT').ERR0002\n.*--------------------------------------------------------------------*\n.*  IF ERREXIT MUST BE AT BLOCK LEVEL 0\n.*--------------------------------------------------------------------*\n         AIF   (&#BLVL EQ 1 AND &#PBENC).PRC0310\n         MNOTE 8,'ERREXIT BLOCK must follow ENDBLK for PROGRAM BLOCK an$\n               d be at block level zero'\n.PRC0310 ANOP\n.*--------------------------------------------------------------------*\n.*  DISPLAY ERRORS FOR IGNORED KEYWORDS.\n.*--------------------------------------------------------------------*\n         ##IGMSG &SUBOPTS,SUBOPTS         DEFAULT SUBROUTINE OPTIONS\n         ##IGMSG &BASEREG,BASEREG         BASE REGS\n         ##IGMSG &PWAREG,PWAREG           PWA REGS\n         ##IGMSG &SVAREA,SVAREA           SAVE AREA TAG NAME\n         ##IGMSG &CPYRGHT,CPYRGHT         COPYRIGHT NOTICE\n         ##IGMSG &RMODE,RMODE             RESIDENCE MODE\n         ##IGMSG &R1SAVE,R1SAVE           PARM SAVE REGISTER\n         ##IGMSG &SMWA,SMWA               STRUCTURED MACRO WORK AREA\n         ##IGMSG &DYNSIZE,DYNSIZE         SIZE OF DYNAMIC STORAGE\n         ##IGMSG &DYNERR,DYNERR           DYNAMIC STORAGE ERROR EXIT\n         ##IGMSG &SWAREG,SWAREG           SWA BASE REGS\n         ##IGMSG &RECUR,RECUR             MAX RECURSIVE CALLS\n         ##IGMSG &PWASP,PWASP             PROGRAM WORK AREA SUB POOL\n         ##IGMSG &ENVIRON,ENVIRON         DEFAULT PROLOG/EPILOG MACROS\n         ##IGMSG &PARMS,PARMS             INPUT PARMS               @C1\n         ##IGMSG &PARMMAP,PARMMAP         INPUT PARAMETER MAPPING   @C1\n.*--------------------------------------------------------------------*\n.*  ISSUE MACRO TO GENERATE CODE FOR BLOCK.\n.*--------------------------------------------------------------------*\n&MAC     SETC  '&#EPMAC'\n         AIF   ('&EXPMAC' EQ '').PRC0350\n&MAC     SETC  '&EXPMAC'\n.PRC0350 ANOP\n         &MAC  &NAME,                   NAME OF BLOCK                  $\n               &OPTIONS,                OPTIONS                        $\n               &BASEREG,                BASE REGS                      $\n               &AMODE,                  ADDRESSING MODE                $\n               &SAVE                    REGISTER TO SAVE\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.*  ERRORS\n.*--------------------------------------------------------------------*\n.ERR0001 MNOTE 8,'Maximum nesting level for blocks is 20'\n         AGO   .EXIT\n.ERR0002 MNOTE 8,'Invalid BLOCK type &TYPE'\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CALLSUB": {"ttr": 6666, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00_\\x00_\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 95, "newlines": 95, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         CALLSUB &NAME,                 SUBROUTINE NAME             @C1$\n               &P,                      PARAMETER LIST              @C1$\n               &VL,                     VL                          @C1$\n               &PL=                     PARAMETER LIST STORAGE      @C1\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      CALLSUB\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - CALLSUB\n.*\n.*  PURPOSE    STRUCTURED MACRO USED TO CALL A SUBROUTINE BLOCK.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - NEW  MGG\n.*              6/27/85 - ADDED PARAMETER SUPPORT                   @C1\n.*              7/15/85 MGG - ADDED DYNAMIC SUPPORT                 @C2\n.*              2/18/86 MGG - ADDED LONG OPTION SUPPORT             @C3\n.*              3/23/87 MGG - FIXED ERROR WHEN LONG OPTION IS USED  @C4\n.*\n.*--------------------------------------------------------------------*\n         GBLB  &#PBXA                   XA OPTION\n         GBLB  &#PB370                  370 OPTION\n         GBLA  &#CSFF(99)                FIRST FOR SUBROUTINE FROM  @C2\n         GBLA  &#CSF(500)                CALLSUB FROM               @C2\n         GBLA  &#CST(500)                CALLSUB TO                 @C2\n         GBLA  &#CSFT#N                  CALLSUB FROM/TO NEXT NUMBER@C2\n         GBLB  &#CSSD(99)                ADCON ALREADY IN PSD       @C2\n         GBLA  &#SB#D                    SUBROUTINE NUMBER CALLED   @C2\n         GBLA  &#SB#C                    CURRENT SUBROUTINE NUMBER  @C2\n         GBLA  &#SB#CPB                  (SUB #) OF CURRENT PROG BLK@C2\n         GBLB  &#PBLONG                  LONG PROGRAM OPTION        @C3\n         LCLA  &CTR                      LOCAL WORK VARIABLE        @C2\n         LCLC  &TAG                      LOCAL WORK TAG             @C2\n         ##DEFSUB &NAME                                             @C2\n         AIF   (&#SB#D GT &#SB#CPB).X50                             @C2\n         MNOTE 8,'Can not CALLSUB program block or subroutine in previo$\n               us program block'                                    @C2\n.X50     ANOP                                                       @C1\n&CTR     SETA  &#CSFF(&#SB#C)                                       @C2\n         AIF   (&CTR NE 0).X100                                     @C2\n&#CSFF(&#SB#C) SETA &#CSFT#N                                        @C2\n         AGO   .X200                                                @C2\n.X100    AIF   (&CTR GE &#CSFT#N).X200                              @C2\n         AIF   (&#CSF(&CTR) NE &#SB#C).X200                         @C2\n         AIF   (&#CST(&CTR) EQ &#SB#D).X300                         @C2\n&CTR     SETA  &CTR+1                                               @C2\n         AGO   .X100                                                @C2\n.X200    ANOP                                                       @C2\n&#CSF(&#CSFT#N) SETA &#SB#C                                         @C2\n&#CST(&#CSFT#N) SETA &#SB#D                                         @C2\n&#CSFT#N SETA  &#CSFT#N+1                                           @C2\n.X300    ANOP                                                       @C2\n.*                                                                  @C2\n         PLIST &P,&VL,PL=&PL                                        @C1\n.X900    ANOP                                                       @C1\n         AIF   (NOT &#PBLONG).CSB0003   IF LONG OPTION              @C3\n&TAG     SETC  '#SBAD&#SB#D'                                        @C3\n         AIF   (&#CSSD(&#SB#D)).CSB0002 SKIP IF ADCON ALREADY DEFINEDC3\n         PSD   TYPE=PARTIAL                                         @C3\n&TAG     DC    A(&NAME)                 ADCON FOR SUBROUTINE BLOCK  @C3\n         ENDPSD ,                                                   @C3\n&#CSSD(&#SB#D) SETB  1                  INDICATE ADCON ALREADY DEFINED3\n.CSB0002 L     R15,&TAG                 LOAD ADDRESS OF SUBROUTINE  @C3\n.CSB0003 ANOP                                                       @C3\n         AIF   (&#PBXA).CSB0010         IF XA OPTION OFF, USE BAL INST\n         AIF   (&#PBLONG).CSB0005       IF LONG OPTION              @C3\n         BAL   R14,&NAME                CALL SUBROUTINE\n         AGO   .CSB0100                                             @C3\n.CSB0005 BALR  R14,R15                  CALL SUBROUTINE             @C3\n         AGO   .CSB0100                                             @C3\n.CSB0010 AIF   (&#PB370).CSB0020        IF XA OPTION ON AND 370 OPTION\n.*                                        OFF, USE BAS INST\n         AIF   (&#PBLONG).CSB0015       IF LONG OPTION              @C3\n         BAS   R14,&NAME                CALL SUBROUTINE\n         AGO   .CSB0100                                             @C3\n.CSB0015 BASR  R14,R15                  CALL SUBROUTINE             @C3\n         AGO   .CSB0100                                             @C3\n.CSB0020 ANOP                           IF XA AND 370 OPTION ON\n         AIF   (&#PBLONG).CSB0025       IF LONG OPTION              @C3\n         LA    R14,*+8               CALL SUBROUTINE WITH R14 VALID @C4\n         B     &NAME                      AS 31 BIT ADDRESS\n         AGO   .CSB0100                                             @C3\n.CSB0025 LA    R14,*+6               CALL SUBROUTINE WITH R14 VALID @C4\n         BR    R15                        AS 31 BIT ADDRESS         @C4\n         AGO   .CSB0100                                             @C3\n.CSB0100 MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CALLX": {"ttr": 6669, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x004\\x004\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         CALLX &PGM,                    PROGRAM ADDRESS                $\n               &P,                      PARAMETER LIST                 $\n               &VL,                     VL                             $\n               &PL=                     PARAMETER LIST STORAGE\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1985.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      CALLX\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - CALLX\n.*\n.*  PURPOSE    STRUCTURED MACRO USED TO CALL EXTERNAL PROGRAMS.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    6/27/85 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#MNDX                   LAST TAG INDEX USED\n         GBLB  &#PBXA                   XA OPTION\n         GBLB  &#PB370                  370 OPTION\n         LCLC  &TAG\n&#MNDX   SETA  &#MNDX+1                 ADD ONE TO TAG INDEX\n         PLIST &P,&VL,PL=&PL\n.X100    AIF   ('&PGM' EQ '(R15)' OR '&PGM' EQ '(15)').X200\n         L     R15,&PGM                 POINT R1 TO ROUTINE\n.X200    AIF   (&#PBXA).X300            IF XA OPTION OFF, USE BALR INST\n         BALR  R14,R15                  CALL EXTERNAL ROUTINE\n         MEXIT\n.X300    AIF   (&#PB370).X400           IF XA OPTION ON AND 370 OPTION\n.*                                        OFF, USE BAS INST\n         BASR  R14,R15                  CALL EXTERNAL ROUTINE\n         MEXIT\n.X400    ANOP                           IF XA AND 370 OPTION ON, USE\n.*                                       BALR ON 370 AND BASR ON XA\n         L     R14,16                   POINT R14 TO CVT\n         TM    X'74'(R14),X'80'         RUNNING UNDER XA?\n         BO    #CX&#MNDX                YES, DO BASR\n         BALR  R14,R15                  CALL EXTERNAL ROUTINE\n         B     #CP&#MNDX                BRANCH PAST BASR\n&TAG     SETC  '#CX&#MNDX'\n&TAG     BASR  R14,R15                  CALL EXTERNAL ROUTINE\n&TAG     SETC  '#CP&#MNDX'\n&TAG     DS    0H\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CASE": {"ttr": 6913, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00W\\x00W\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 87, "newlines": 87, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         CASE  &CASEBLK=\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      CASE\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - CASE\n.*\n.*  PURPOSE    INTERNAL MACRO USED TO START CODE FOR A CASE WITHIN\n.*             A CASEBLK.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - NEW  MGG\n.*              9/23/93 - mgg Allow case number up to 501*mult.\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#MNDX                   LAST TAG INDEX USED\n         GBLA  &#MLVL                   STRUCTURAL LEVEL\n         GBLA  &#CMLVL(20)              STRUCTURAL LEVEL CASEBLK\n         GBLA  &#CLVL                   CASEBLK LEVEL\n         GBLA  &#CNDX(20)               CASEBLK BLOCK TAG INDEX\n         GBLB  &#COTH(20)               CASEBLK OTHER ENCOUNTERED\n         GBLB  &#CCAS(20)               CASEBLK ENCOUNTERED\n         GBLC  &#CNAME(20)              CASEBLK NAMES\n         GBLA  &#CMULT(20)              CASEBLK MULT FACTOR\n         GBLA  &#CMAXC(20)              MAX CASE NUM IN THIS CASEBLK\n         GBLA  &#CTAGS(10020)  20*501   CASE TAGS\n         LCLA  &CTR,&NDX                WORK COUNTER & INDEX\n         LCLC  &TAG                     WORK TAG\n         AIF   ('&CASEBLK' EQ '').PRC0010\n         AIF   ('&CASEBLK' NE '&#CNAME(&#CLVL)').ERR0006\n.PRC0010 AIF   (&#CLVL EQ 0 OR &#CMLVL(&#CLVL) NE &#MLVL).ERR0007\n&CTR     SETA  N'&SYSLIST\n         AIF   (&CTR LE 0).ERR0001\n         AIF   (NOT &#CCAS(&#CLVL)).PRC0090\n         B     #CE&#CNDX(&#CLVL)        LEAVE CASE\n.PRC0090 ANOP\n&#CCAS(&#CLVL) SETB 1\n         AIF   (&CTR NE 1).PRC0100\n         AIF   ('&SYSLIST(1)' NE 'OTHER').PRC0100\n         AIF   (&#COTH(&#CLVL)).ERR0002\n&#COTH(&#CLVL) SETB  1\n&TAG     SETC  '#CO&#CNDX(&#CLVL)'\n&TAG     DS    0H                       OTHER CASES\n         AGO   .EXIT\n.PRC0100 ANOP\n&#MNDX   SETA  &#MNDX+1\n&TAG     SETC  '#CC&#MNDX'\n&TAG     DS    0H                       START OF CASE\n.PRC0110 ANOP\n         AIF   (T'&SYSLIST(&CTR) NE 'N').ERR0003\n         AIF   (&SYSLIST(&CTR) GT 500).ERR0004\n&NDX     SETA  &SYSLIST(&CTR)/&#CMULT(&#CLVL)\n         AIF   (&NDX*&#CMULT(&#CLVL) NE &SYSLIST(&CTR)).ERR0005\n         AIF   (&#CTAGS((&#CLVL-1)*501+1+&NDX) EQ 0).PRC0120\n         MNOTE 8,'CASE &SYSLIST(&CTR) already used'\n.PRC0120 ANOP\n&#CTAGS((&#CLVL-1)*501+1+&NDX) SETA &#MNDX\n         AIF   (&NDX LE &#CMAXC(&#CLVL)).PRC0130\n&#CMAXC(&#CLVL) SETA &NDX\n.PRC0130 ANOP\n&CTR     SETA  &CTR-1\n         AIF   (&CTR GT 0).PRC0110\n         AGO   .EXIT\n.ERR0001 MNOTE 8,'No operand was specified on CASE statement'\n         AGO   .EXIT\n.ERR0002 MNOTE 8,'OTHER has already been specified in this CASEBLK'\n         AGO   .EXIT\n.ERR0003 MNOTE 8,'CASE is not numeric'\n         AGO   .EXIT\n.ERR0004 MNOTE 8,'CASE number cannot be larger than ''MULT'' * 500'\n         AGO   .EXIT\n.ERR0005 MNOTE 8,'CASE number must be multiple of ''MULT'''\n         AGO   .EXIT\n.ERR0006 MNOTE 8,'CASEBLK= does not match CASE name'\n         AGO   .EXIT\n.ERR0007 MNOTE 8,'CASE macro is not at same structural level as a CASEB$\n               LK macro'\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CASEBLK": {"ttr": 6916, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00W\\x00W\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 87, "newlines": 87, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         CASEBLK &REG=,&MULT=1,&WREG=,&NAME=\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      CASEBLK\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - CASEBLK\n.*\n.*  PURPOSE    STRUCTURED MACRO USED TO START A CASE BLOCK.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - mgg New\n.*              9/23/93 - mgg Allow case number up to 501*mult.\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#MNDX                   LAST TAG INDEX USED\n         GBLA  &#MLVL                   STRUCTURAL LEVEL\n         GBLA  &#CMLVL(20)              STRUCTURAL LEVEL\n         GBLA  &#CLVL                   CASEBLK LEVEL\n         GBLA  &#CNDX(20)               CASEBLK BLOCK TAG INDEX\n         GBLB  &#COTH(20)               CASEBLK OTHER ENCOUNTERED\n         GBLB  &#CCAS(20)               CASEBLK ENCOUNTERED\n         GBLC  &#CNAME(20)              CASEBLK NAMES\n         GBLA  &#CMULT(20)              CASEBLK MULT FACTOR\n         GBLA  &#CMAXC(20)              MAX CASE NUM IN THIS CASEBLK\n         GBLA  &#CTAGS(10020)  20*501   CASE TAGS\n         LCLA  &CTR                     WORK COUNT\n         LCLC  &TAG                     WORK TAG\n         LCLC  &R                       REGISTER USED\n&#MNDX   SETA  &#MNDX+1                 ADD ONE TO TAG INDEX\n         AIF   (&#CLVL GE 20).ERR0001\n&#CLVL   SETA  &#CLVL+1                 ADD ONE TO CASEBLK LEVEL\n&#MLVL   SETA  &#MLVL+1                 ADD ONE TO STRUCTURAL LEVEL\n&#CMLVL(&#CLVL) SETA &#MLVL             SAVE LEVEL FOR THIS CASEBLK\n&#CNDX(&#CLVL)  SETA &#MNDX             SET BLOCK TAG INDEX\n&#COTH(&#CLVL) SETB  0                  CLEAR CASE OTHER FLAG\n&#CCAS(&#CLVL) SETB  0                  CLEAR CASE FLAG\n&#CNAME(&#CLVL) SETC '&NAME'            SAVE NAME\n&#CMULT(&#CLVL) SETA &MULT              SET MULT FACTOR\n&#CMAXC(&#CLVL) SETA 0                  SET MAX CASE TO 0\n&CTR     SETA  500                      CLEAR\n.PRC0010 ANOP                             CASE\n&#CTAGS((&#CLVL-1)*501+1+&CTR) SETA 0            TAGS\n&CTR     SETA  &CTR-1\n         AIF   (&CTR GE 0).PRC0010\n.PRC0050 ANOP\n&R       SETC  '&WREG'                  SET REGISTER\n         AIF   ('&R' NE '').PRC0060\n&R       SETC  '&REG'                   DEFAULT TO REG=\n         AIF   ('&R' EQ '').ERR0002\n         AGO   .PRC0070\n.PRC0060 LR    &R,&REG                  LOAD WORK REGISTER\n.PRC0070 ANOP\n.PRC0100 AIF   ('&MULT' NE '1').PRC0110\n         SLA   &R,1                     MULTIPLY CASE NUMBER BY 2\n         AGO   .PRC0200\n.PRC0110 AIF   ('&MULT' NE '2').PRC0120\n.*       NO SCALEING FOR MULT=2\n         AGO   .PRC0200\n.PRC0120 AIF   ('&MULT' NE '4').PRC0130\n         SRA   &R,1                     DIVIDE CASE BY 2\n         AGO   .PRC0200\n.PRC0130 AIF   ('&MULT' NE '8').PRC0140\n         SRA   &R,2                     DIVIDE CASE BY 4\n         AGO   .PRC0200\n.PRC0140 ANOP\n         MNOTE 8,'Invalid MULT= specified. Must be 1, 2, 4, or 8'\n.PRC0200 ANOP\n         CH    &R,#CM&#CNDX(&#CLVL)      CHECK FOR MAX\n         BH    #CO&#CNDX(&#CLVL)         GO TO CASE OTHER CODE IF HIGH\n         LH    &R,#CT&#CNDX(&#CLVL).(&R) LOAD DISPLACEMENT TO CASE\n&TAG     SETC  '#CS&#CNDX(&#CLVL)'\n&TAG     B     *(&R)                    BRANCH TO CASE\n         AGO   .EXIT\n.ERR0001 MNOTE 8,'CASEBLK can not be nested more than 20 deep'\n         AGO   .EXIT\n.ERR0002 MNOTE 8,'REG= must be specified'\n         AGO   .EXIT\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DC": {"ttr": 6919, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00'\\x00'\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n&NAME    DC\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1991.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      DC\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - DC\n.*\n.*  PURPOSE    MACRO USED TO REPLACE DC OPCODE WITH AN ASSOCIATED\n.*             MACRO.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    8/06/91 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &VDA__DC\n&CTR     SETA  N'&SYSLIST               GET NUMBER OF POSITIONAL PARMS\n&NAME    &VDA__DC &SYSLIST(1),&SYSLIST(2),&SYSLIST(3),&SYSLIST(4),     +\n               &SYSLIST(5),&SYSLIST(6),&SYSLIST(7),&SYSLIST(8),        +\n               &SYSLIST(9),&SYSLIST(10),&SYSLIST(11),&SYSLIST(12),     +\n               &SYSLIST(13),&SYSLIST(14),&SYSLIST(15),&SYSLIST(16),    +\n               &SYSLIST(17),&SYSLIST(18),&SYSLIST(19),&SYSLIST(20),    +\n               &SYSLIST(21),&SYSLIST(22),&SYSLIST(23),&SYSLIST(24),    +\n               &SYSLIST(25),&SYSLIST(26),&SYSLIST(27),&SYSLIST(28),    +\n               &SYSLIST(29),&SYSLIST(30),&SYSLIST(31),&SYSLIST(32),    +\n               &SYSLIST(33),&SYSLIST(34),&SYSLIST(35),&SYSLIST(36),    +\n               &SYSLIST(37),&SYSLIST(38),&SYSLIST(39),&SYSLIST(40),    +\n               &SYSLIST(41),&SYSLIST(42),&SYSLIST(43),&SYSLIST(44),    +\n               &SYSLIST(45),&SYSLIST(45),&SYSLIST(47),&SYSLIST(48),    +\n               &SYSLIST(49),&SYSLIST(50),N=&CTR\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DEFUCOND": {"ttr": 6921, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00&\\x00&\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         DEFUCOND &NAME=,&MACRO=\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1989.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      DEFUCOND\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - DEFUCOND\n.*\n.*  PURPOSE    STRUCTURED MACRO TO DEFINE USER DEFINED CONDITON NAMES.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    9/13/89 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         LCLC  &UCOND_DEFINED\n         LCLC  &UCOND_MACRO\n         AIF   ('&NAME' EQ '').ERR0001\n         AIF   ('&MACRO' EQ '').ERR0002\n&UCOND_DEFINED SETC '&NAME.__DEFINED'\n&UCOND_MACRO   SETC '&NAME.__MACRO'\n         GBLB  &(&UCOND_DEFINED)\n         GBLC  &(&UCOND_MACRO)\n&(&UCOND_DEFINED) SETB 1\n&(&UCOND_MACRO)   SETC '&MACRO'\n         MEXIT\n.ERR0001 MNOTE 8,'NAME= must be specified'\n         MEXIT\n.ERR0002 MNOTE 8,'MACRO= must be specified'\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DEFVGTYP": {"ttr": 6923, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00/\\x00/\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         DEFVGTYP &NAME=,&PROLOG=,&EPILOG=,&DS=,&DC=,&EQU=\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1991.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      DEFVGTYP\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - DEFVGTYP\n.*\n.*  PURPOSE    STRUCTURED MACRO TO DEFINE A VDA GENTYPE.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    8/05/91 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         LCLC  &VGTYP_DEFINED\n         LCLC  &VGTYP_MACRO\n         AIF   ('&NAME' EQ '').ERR0001\n&VGTYP_DEFINED SETC '&NAME.__DEFINED'\n&VGTYP_PROLOG  SETC '&NAME.__PROLOG'\n&VGTYP_EPILOG  SETC '&NAME.__EPILOG'\n&VGTYP_DC      SETC '&NAME.__DC'\n&VGTYP_DS      SETC '&NAME.__DS'\n&VGTYP_EQU     SETC '&NAME.__EQU'\n         GBLB  &(&VGTYP_DEFINED)\n         GBLC  &(&VGTYP_PROLOG)\n         GBLC  &(&VGTYP_EPILOG)\n         GBLC  &(&VGTYP_DC)\n         GBLC  &(&VGTYP_DS)\n         GBLC  &(&VGTYP_EQU)\n&(&VGTYP_DEFINED) SETB 1\n&(&VGTYP_PROLOG)  SETC '&PROLOG'\n&(&VGTYP_EPILOG)  SETC '&EPILOG'\n&(&VGTYP_DC)      SETC '&DC'\n&(&VGTYP_DS)      SETC '&DS'\n&(&VGTYP_EQU)     SETC '&EQU'\n         MEXIT\n.ERR0001 MNOTE 8,'NAME= must be specified'\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DS": {"ttr": 6925, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00'\\x00'\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n&NAME    DS\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1991.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      DS\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - DS\n.*\n.*  PURPOSE    MACRO USED TO REPLACE DS OPCODE WITH AN ASSOCIATED\n.*             MACRO.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    8/06/91 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &VDA__DS\n&CTR     SETA  N'&SYSLIST               GET NUMBER OF POSITIONAL PARMS\n&NAME    &VDA__DS &SYSLIST(1),&SYSLIST(2),&SYSLIST(3),&SYSLIST(4),     +\n               &SYSLIST(5),&SYSLIST(6),&SYSLIST(7),&SYSLIST(8),        +\n               &SYSLIST(9),&SYSLIST(10),&SYSLIST(11),&SYSLIST(12),     +\n               &SYSLIST(13),&SYSLIST(14),&SYSLIST(15),&SYSLIST(16),    +\n               &SYSLIST(17),&SYSLIST(18),&SYSLIST(19),&SYSLIST(20),    +\n               &SYSLIST(21),&SYSLIST(22),&SYSLIST(23),&SYSLIST(24),    +\n               &SYSLIST(25),&SYSLIST(26),&SYSLIST(27),&SYSLIST(28),    +\n               &SYSLIST(29),&SYSLIST(30),&SYSLIST(31),&SYSLIST(32),    +\n               &SYSLIST(33),&SYSLIST(34),&SYSLIST(35),&SYSLIST(36),    +\n               &SYSLIST(37),&SYSLIST(38),&SYSLIST(39),&SYSLIST(40),    +\n               &SYSLIST(41),&SYSLIST(42),&SYSLIST(43),&SYSLIST(44),    +\n               &SYSLIST(45),&SYSLIST(45),&SYSLIST(47),&SYSLIST(48),    +\n               &SYSLIST(49),&SYSLIST(50),N=&CTR\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ELSE": {"ttr": 6927, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x001\\x001\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 49, "newlines": 49, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ELSE  &IF=\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ELSE\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ELSE\n.*\n.*  PURPOSE    STRUCTURED MACRO USED TO START ELSE CODE.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - NEW  MGG\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#MLVL                   STRUCTURAL LEVEL\n         GBLA  &#IMLVL(20)              STRUCTURAL LEVEL OF IF\n         GBLA  &#ILVL                   IF NEXTING LEVEL\n         GBLA  &#INDX(20)               IF TAG INDEX\n         GBLA  &#INDX2(20)              IF TAG INDEX 2\n         GBLB  &#IELSE(20)              ELSE ENCOUNTERED\n         GBLC  &#INAME(20)              IF NAMES\n         LCLC  &TAG                     WORK TAG\n         AIF   (&#ILVL LT 1).ERR0001\n         AIF   (&#IELSE(&#ILVL)).ERR0002\n         AIF   ('&IF' EQ '').PRC0010\n         AIF   ('&IF' NE '&#INAME(&#ILVL)').ERR0003\n.PRC0010 AIF   (&#IMLVL(&#ILVL) NE &#MLVL).ERR0004\n         B     #IE&#INDX(&#ILVL)        GO TO ENDIF\n&TAG     SETC  '#IF&#INDX2(&#ILVL)'     SET TAG TO PREVIOUS FAIL TAG\n&TAG     DS    0H                       START OF ELSE CODE\n&#IELSE(&#ILVL) SETB 1\n         AGO   .EXIT\n.ERR0001 MNOTE 8,'IF nexting level is zero'\n         AGO   .EXIT\n.ERR0002 MNOTE 8,'ELSE already encountered for this IF'\n         AGO   .EXIT\n.ERR0003 MNOTE 8,'NAME= does not match corresponding IF'\n         AGO   .EXIT\n.ERR0004 MNOTE 8,'ELSE structural level is not the same as the correspo$\n               nding IF'\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ELSEIF": {"ttr": 6929, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00H\\x00H\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 72, "newlines": 72, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ELSEIF  &IF=\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ELSEIF\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ELSEIF\n.*\n.*  PURPOSE    STRUCTURED MACRO USED TO START ELSEIF CODE.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - NEW  MGG\n.*              9/15/89 MGG - ADDED T=A TO ##COND MACRO CALL.       @C1\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#MNDX                   LAST TAG INDEX USED\n         GBLA  &#MLVL                   STRUCTURAL LEVEL\n         GBLA  &#IMLVL(20)              STRUCTURAL LEVEL OF IF\n         GBLA  &#ILVL                   IF NEXTING LEVEL\n         GBLA  &#INDX(20)               IF TAG INDEX\n         GBLA  &#INDX2(20)              IF TAG INDEX 2\n         GBLB  &#IELSE(20)              ELSE ENCOUNTERED\n         GBLC  &#INAME(20)              IF NAMES\n         LCLA  &CTR                     WORK COUNT\n         LCLC  &FTAG,&STAG,&TAG         FAIL TAG AND SUCCESS TAG\n&#MNDX   SETA  &#MNDX+1                 ADD ONE TO TAG INDEX\n         AIF   (&#ILVL LT 1).ERR0001    ERROR IF NO IF ACTIVE\n         AIF   (&#IELSE(&#ILVL)).ERR0002 ERROR IF ELSE ENCOUNTERED\n         AIF   ('&IF' EQ '').PRC0010    ERROR IF IF= DOES NOT MATCH\n         AIF   ('&IF' NE '&#INAME(&#ILVL)').ERR0003\n.PRC0010 AIF   (&#IMLVL(&#ILVL) NE &#MLVL).ERR0004\n         B     #IE&#INDX(&#ILVL)        GO TO ENDIF\n&TAG     SETC  '#IF&#INDX2(&#ILVL)'     SET TAG TO PREVIOUS FAIL TAG\n&#INDX2(&#ILVL) SETA  &#MNDX            SET TAG INDEX 2\n&FTAG    SETC  '#IF&#MNDX'              FAIL TAG NAME\n&STAG    SETC  '#IS&#MNDX'              SUCCESS TAG NAME\n&CTR     SETA  N'&SYSLIST               GET NUMBER OF POSITIONAL PARMS\n&TAG     ##COND &SYSLIST(1),&SYSLIST(2),                               $\n               &SYSLIST(3),&SYSLIST(4),&SYSLIST(5),&SYSLIST(6),        $\n               &SYSLIST(7),&SYSLIST(8),&SYSLIST(9),&SYSLIST(10),       $\n               &SYSLIST(11),&SYSLIST(12),&SYSLIST(13),&SYSLIST(14),    $\n               &SYSLIST(15),&SYSLIST(16),&SYSLIST(17),&SYSLIST(18),    $\n               &SYSLIST(19),&SYSLIST(20),&SYSLIST(21),&SYSLIST(22),    $\n               &SYSLIST(23),&SYSLIST(24),&SYSLIST(25),&SYSLIST(26),    $\n               &SYSLIST(27),&SYSLIST(28),&SYSLIST(29),&SYSLIST(30),    $\n               &SYSLIST(31),&SYSLIST(32),&SYSLIST(33),                 $\n               &SYSLIST(34),&SYSLIST(35),&SYSLIST(36),                 $\n               &SYSLIST(37),&SYSLIST(38),&SYSLIST(39),                 $\n               &SYSLIST(40),&SYSLIST(41),&SYSLIST(42),                 $\n               &SYSLIST(43),&SYSLIST(44),&SYSLIST(45),                 $\n               &SYSLIST(46),&SYSLIST(47),&SYSLIST(48),                 $\n               &SYSLIST(49),&SYSLIST(50),&SYSLIST(51),                 $\n               F=&FTAG,S=&STAG,E=&CTR,B=1,T=A                       @C1\n&STAG    DS    0H                       START OF SUCCESSFUL ELSEIF CODE\n         AGO   .EXIT\n.ERR0001 MNOTE 8,'ELSEIF must be contained in IF structure'\n         AGO   .EXIT\n.ERR0002 MNOTE 8,'ELSE for this IF precedes ELSEIF'\n         AGO   .EXIT\n.ERR0003 MNOTE 8,'IF= does not match corresponding IF'\n         AGO   .EXIT\n.ERR0004 MNOTE 8,'ELSEIF structural level is not the same as correspond$\n               ing IF'\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ENDBLK": {"ttr": 6932, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00\\xa0\\x00\\xa0\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 160, "newlines": 160, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ENDBLK &BLOCK=,                NAME OF BLOCK                  $\n               &RC=,                    RETURN CODE                    $\n               &R0=,                    VALUE OF R0 TO RETURN          $\n               &R1=,                    VALUE OF R1 TO RETURN          $\n               &EXPMAC=                 BLOCK EPILOG MACRO\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ENDBLK\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ENDBLK\n.*\n.*  PURPOSE    STRUCTURED MACRO USED TO END A BLOCK.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 MGG - NEW\n.*             11/10/83 MGG - ADDED SUPPORT FOR BR14 OPTION\n.*             11/10/83 MGG - ADDED R-FORM REGISTER SUPPORT ON RC=\n.*             04/26/84 MGG - ADDED CUSTOM BLOCK SUPPORT\n.*             11/21/84 MGG - FIXED BUG IN RC CODE IF RENT SPECIFIED\n.*             07/15/85 MGG - PUT IN DYNAMIC STORAGE SUPPORT\n.*              1/22/86 MGG - PUT IN LOCTR OPTION SUPPORT\n.*              2/ 6/86 MGG - PUT IN AUTOMATIC PL STORAGE SUPPORT\n.*              9/10/86 MGG - PUT IN SUPPORT FOR NORENT PWA\n.*             12/29/86 MGG - MAJOR RESTRUCTURE.  @CN REMOVED.\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#MNDX                   LAST TAG INDEX USED\n         GBLA  &#MLVL                   STRUCTURAL LEVEL\n         GBLA  &#BLVL                   BLOCK LEVEL\n         GBLA  &#BNDX(20)               BLOCK TAG INDEXS\n         GBLA  &#BMLVL(20)              BLOCK STRUCTURAL LEVEL\n         GBLC  &#BNAME(20)              BLOCK NAMES\n         GBLC  &#BTYPE(20)              BLOCK TYPE\n         GBLA  &#SBPLMX                 MAXIMUM PARMS IN SUBROUTINE\n         GBLB  &#SBCSTM                 CUSTOM SUBROUTINE BLOCK\n         GBLC  &#EEMAC                  ERREXIT BLOCK EPILOG MACRO NAME\n         GBLC  &#IEMAC                  INLINE BLOCK EPILOG MACRO NAME\n         GBLC  &#PEMAC                  PROGRAM BLOCK EPILOG MACRO NAME\n         GBLC  &#SEMAC                  SUBROUTINE EPILOG MACRO NAME\n         LCLC  &TAG                     WORK TAG\n         LCLC  &MAC                     WORK FIELD\n.*--------------------------------------------------------------------*\n.*  ERROR CHECK STRUCTURAL LEVEL\n.*--------------------------------------------------------------------*\n         AIF   (&#BLVL LE 0).ERR0001\n         AIF   (&#BMLVL(&#BLVL) NE &#MLVL).ERR0004\n&#MLVL   SETA  &#MLVL-1\n         AIF   ('&BLOCK' EQ '').CRC0000\n         AIF   ('&BLOCK' NE '&#BNAME(&#BLVL)').ERR0002\n.CRC0000 ANOP\n.*--------------------------------------------------------------------*\n.*  CHECK RC=\n.*--------------------------------------------------------------------*\n&TAG     SETC  '#BE&#BNDX(&#BLVL)'\n&TAG     DS    0H                       END OF BLOCK\n&TAG     SETC  ''\n         AIF   ('&RC' EQ '').CRC0010\n         AIF   ('&RC'(1,1) NE '(').CRC0010\n         AIF   (N'&RC EQ 1).CRC0010\n         MNOTE 8,'&RC invalid on RC='\n.CRC0010 ANOP\n.*====================================================================*\n.*  TYPE=INLINE.\n.*====================================================================*\n.PRC0000 AIF   ('&#BTYPE(&#BLVL)' NE 'INLINE').PRC0100\n.*--------------------------------------------------------------------*\n.*  DISPLAY ERRORS FOR IGNORED KEYWORDS.\n.*--------------------------------------------------------------------*\n.*NONE\n.*--------------------------------------------------------------------*\n.*  ISSUE MACRO TO GENERATE CODE FOR BLOCK.\n.*--------------------------------------------------------------------*\n&MAC     SETC  '&#IEMAC'\n         AIF   ('&EXPMAC' EQ '').PRC0050\n&MAC     SETC  '&EXPMAC'\n.PRC0050 ANOP\n         &MAC  &RC                      RETURN CODE FOR BLOCK\n         AGO   .PRC9000\n.*====================================================================*\n.*  TYPE=ERREXIT.\n.*====================================================================*\n.PRC0100 AIF   ('&#BTYPE(&#BLVL)' NE 'ERREXIT').PRC0200\n.*--------------------------------------------------------------------*\n.*  DISPLAY ERRORS FOR IGNORED KEYWORDS.\n.*--------------------------------------------------------------------*\n.* NONE\n.*--------------------------------------------------------------------*\n.*  ISSUE MACRO TO GENERATE CODE FOR BLOCK.\n.*--------------------------------------------------------------------*\n&MAC     SETC  '&#EEMAC'\n         AIF   ('&EXPMAC' EQ '').PRC0150\n&MAC     SETC  '&EXPMAC'\n.PRC0150 ANOP\n         &MAC  &RC,                     RETURN CODE FOR BLOCK          $\n               &R0,                     R0 TO PASS BACK                $\n               &R1                      R1 TO PASS BACK\n         AGO   .PRC9000\n.*====================================================================*\n.*  TYPE=PROGRAM.\n.*====================================================================*\n.PRC0200 AIF   ('&#BTYPE(&#BLVL)' NE 'PROGRAM').PRC0300\n.*--------------------------------------------------------------------*\n.*  DISPLAY ERRORS FOR IGNORED KEYWORDS.\n.*--------------------------------------------------------------------*\n.* NONE\n.*--------------------------------------------------------------------*\n.*  ISSUE MACRO TO GENERATE CODE FOR BLOCK.\n.*--------------------------------------------------------------------*\n&MAC     SETC  '&#PEMAC'\n         AIF   ('&EXPMAC' EQ '').PRC0250\n&MAC     SETC  '&EXPMAC'\n.PRC0250 ANOP\n         &MAC  &RC,                     RETURN CODE FOR BLOCK          $\n               &R0,                     R0 KEYWORD                     $\n               &R1                      R1 KEYWORD\n         AGO   .PRC9000\n.*====================================================================*\n.*  TYPE=SUBROUTINE.\n.*====================================================================*\n.PRC0300 AIF   ('&#BTYPE(&#BLVL)' NE 'SUBROUTINE').PRC0400\n.*--------------------------------------------------------------------*\n.*  DISPLAY ERRORS FOR IGNORED KEYWORDS.\n.*--------------------------------------------------------------------*\n.*NONE\n.*--------------------------------------------------------------------*\n.*  ISSUE MACRO TO GENERATE CODE FOR BLOCK.\n.*--------------------------------------------------------------------*\n&MAC     SETC  '&#SEMAC'\n         AIF   ('&EXPMAC' EQ '').PRC0350\n&MAC     SETC  '&EXPMAC'\n.PRC0350 ANOP\n         &MAC  &RC                      RETURN CODE FOR BLOCK\n         AGO   .PRC9000\n.PRC0400 ANOP\n.*--------------------------------------------------------------------*\n.*  FIXUP FOR INVALID BLOCK TYPES.\n.*--------------------------------------------------------------------*\n&TAG     SETC  '#BE&#BNDX(&#BLVL)'\n&TAG     DS    0H                       INVALID BLOCK\n.*--------------------------------------------------------------------*\n.PRC9000 ANOP\n&#BLVL   SETA  &#BLVL-1                 BACKUP ONE LEVEL\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.ERR0001 MNOTE 8,'Block nesting level is already zero'\n         AGO   .EXIT\n.ERR0002 MNOTE 8,'BLOCK= does not match current block'\n         AGO   .EXIT\n.ERR0004 MNOTE 8,'Structural nesting level does not match level at entr$\n               y to corresponding block'\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ENDCASE": {"ttr": 7172, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00I\\x00I\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 73, "newlines": 73, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ENDCASE  &CASEBLK=\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ENDCASE\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ENDCASE\n.*\n.*  PURPOSE    STRUCTURED MACRO USED TO END A CASE BLOCK.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - mgg NEW\n.*              9/23/93 - mgg Allow case number up to 501*mult.\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#MNDX                   LAST TAG INDEX USED\n         GBLA  &#MLVL                   STRUCTURAL LEVEL\n         GBLA  &#CMLVL(20)              STRUCTURAL LEVEL FOR CASEBLK\n         GBLA  &#CLVL                   CASEBLK LEVEL\n         GBLA  &#CNDX(20)               CASEBLK BLOCK TAG INDEX\n         GBLB  &#COTH(20)               CASEBLK OTHER ENCOUNTERED\n         GBLB  &#CCAS(20)               CASEBLK ENCOUNTERED\n         GBLC  &#CNAME(20)              CASEBLK NAMES\n         GBLA  &#CMULT(20)              CASEBLK MULT FACTOR\n         GBLA  &#CMAXC(20)              MAX CASE NUM IN THIS CASEBLK\n         GBLA  &#CTAGS(10020)  20*501   CASE TAGS\n         LCLA  &CTR                     WORK COUNTER\n         LCLC  &TAG                     WORK TAG\n         AIF   (&#CLVL LE 0).ERR0002\n         AIF   (&#CMLVL(&#CLVL) NE &#MLVL).ERR0003\n&#MLVL   SETA  &#MLVL-1\n         AIF   ('&CASEBLK' EQ '').PRC0010\n         AIF   ('&CASEBLK' NE '&#CNAME(&#CLVL)').ERR0001\n.PRC0010 ANOP\n         B     #CE&#CNDX(&#CLVL)\n&TAG     SETC  '#CM&#CNDX(&#CLVL)'\n&TAG     DC    AL2(&#CMAXC(&#CLVL)*2)\n&TAG     SETC  '#CT&#CNDX(&#CLVL)'\n&CTR     SETA  0\n.PRC0100 AIF   (&CTR GT &#CMAXC(&#CLVL)).PRC0200\n         AIF   (&#CTAGS((&#CLVL-1)*501+1+&CTR) NE 0).PRC0120\n&TAG     DC    AL2(#CO&#CNDX(&#CLVL)-#CS&#CNDX(&#CLVL))\n         AGO   .PRC0140\n.PRC0120 ANOP\n&TAG     DC    AL2(#CC&#CTAGS((&#CLVL-1)*501+1+&CTR)-#CS&#CNDX(&#CLVL))\n.PRC0140 ANOP\n&TAG     SETC  ''\n&CTR     SETA  &CTR+1\n         AGO   .PRC0100\n.PRC0200 ANOP\n         AIF   (&#COTH(&#CLVL)).PRC0210\n&TAG     SETC  '#CO&#CNDX(&#CLVL)'\n&TAG     DS    0H                       NO CASE OTHER\n.PRC0210 ANOP\n&TAG     SETC  '#CE&#CNDX(&#CLVL)'\n&TAG     DS    0H                       END OF CASEBLK\n&#CLVL   SETA  &#CLVL-1\n         AGO   .EXIT\n.ERR0001 MNOTE 8,'CASEBLK= does not match CASE name'\n         MEXIT\n.ERR0002 MNOTE 8,'CASEBLK nesting level is zero'\n         MEXIT\n.ERR0003 MNOTE 8,'Structural nesting level of ENDCASE is different than$\n                corresponding CASEBLK macro'\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ENDIF": {"ttr": 7175, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x002\\x002\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ENDIF &IF=\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ENDIF\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ENDIF\n.*\n.*  PURPOSE    STRUCTURED MACRO TO END A IF STRUCTURE.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - NEW  MGG\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#MLVL                   STRUCTURAL LEVEL\n         GBLA  &#ILVL                   IF NEXTING LEVEL\n         GBLA  &#IMLVL(20)              IF STURCTURAL LEVEL\n         GBLA  &#INDX(20)               IF TAG INDEX\n         GBLA  &#INDX2(20)              IF TAG INDEX 2\n         GBLB  &#IELSE(20)              ELSE ENCOUNTERED\n         GBLC  &#INAME(20)              IF NAMES\n         LCLC  &TAG                     WORK TAG\n         AIF   (&#ILVL LT 1).ERR0001\n         AIF   ('&IF' EQ '').PRC0010\n         AIF   ('&IF' NE '&#INAME(&#ILVL)').ERR0002\n.PRC0010 AIF   (&#IMLVL(&#ILVL) NE &#MLVL).ERR0003\n&#MLVL   SETA  &#MLVL-1                 SUBTRACT 1 FORM STRUCTURAL LVL\n         AIF   (&#IELSE(&#ILVL)).PRC0020\n&TAG     SETC  '#IF&#INDX2(&#ILVL)'     SET TAG TO PREVIOUS FAIL TAG\n&TAG     DS    0H                       NO ELSE CODE\n.PRC0020 ANOP\n&TAG     SETC  '#IE&#INDX(&#ILVL)'      SET TAG TO END IF TAG\n&TAG     DS    0H                       END OF IF CODE\n&#ILVL   SETA  &#ILVL-1                 BUMP DOWN IF LEVEL\n         AGO   .EXIT\n.ERR0001 MNOTE 8,'IF nesting level is zero'\n         AGO   .EXIT\n.ERR0002 MNOTE 8,'IF= does not match corresponding IF'\n         AGO   .EXIT\n.ERR0003 MNOTE 8,'ENDIF is not at same structural level as correspondin$\n               g IF'\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ENDLOOP": {"ttr": 7177, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00p\\x00p\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 112, "newlines": 112, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ENDLOOP &LOOP=\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ENDLOOP\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ENDLOOP\n.*\n.*  PURPOSE    STRUCTURED MACRO TO END A LOOP STRUCTURE.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - NEW  MGG\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#MNDX                   LAST TAG INDEX USED\n         GBLA  &#MLVL                   STRUCTURAL LEVEL\n         GBLA  &#DMLVL(20)              STRUCTURAL LEVEL OF LOOP\n         GBLA  &#DLVL                   LOOP NEXTING LEVEL\n         GBLA  &#DNDX(20)               LOOP TAG INDEX\n         GBLC  &#DNAME(20)              LOOP NAMES\n         GBLC  &#DTYPE(20)              TYPE OF LOOP\n         LCLA  &CTR                     WORK COUNT\n         LCLC  &FTAG,&STAG,&TAG         FAIL TAG AND SUCCESS TAG\n         AIF   (&#DLVL LT 1).ERR0001    IF NOT INSIDE LOOP, ERROR\n         AIF   ('&LOOP' EQ '').PRC0010\n         AIF   ('&#DNAME(&#DLVL)' NE '&LOOP').ERR0002\n.PRC0010 AIF   (&#DMLVL(&#DLVL) NE &#MLVL).ERR0007\n&#MLVL   SETA  &#MLVL-1\n         AIF   ('&#DTYPE(&#DLVL)' NE '&SYSLIST(1)').ERR0003\n&TAG     SETC  '#DB&#DNDX(&#DLVL)'      BEGIN TAG\n&STAG    SETC  '#DE&#DNDX(&#DLVL)'      END TAG NAME\n         AIF   ('&SYSLIST(1)' NE 'UNTIL').PRC2000\n         AIF   ('&SYSLIST(2)' NE 'LEAVE').PRC2100\n         B     &TAG                     LOOP UNTIL,LEAVE\n&STAG    DS    0H                       END OF UNTIL,LEAVE LOOP\n&#DLVL   SETA  &#DLVL-1                 DECREMENT LOOP LEVEL\n         AIF   (N'&SYSLIST NE 2).ERR0006\n         AGO   .EXIT\n.PRC2100 ANOP\n&CTR     SETA  N'&SYSLIST-1             GET NUMBER OF POSITIONAL PARMS\n         ##COND &SYSLIST(2),                                           $\n               &SYSLIST(3),&SYSLIST(4),&SYSLIST(5),&SYSLIST(6),        $\n               &SYSLIST(7),&SYSLIST(8),&SYSLIST(9),&SYSLIST(10),       $\n               &SYSLIST(11),&SYSLIST(12),&SYSLIST(13),&SYSLIST(14),    $\n               &SYSLIST(15),&SYSLIST(16),&SYSLIST(17),&SYSLIST(18),    $\n               &SYSLIST(19),&SYSLIST(20),&SYSLIST(21),&SYSLIST(22),    $\n               &SYSLIST(23),&SYSLIST(24),&SYSLIST(25),&SYSLIST(26),    $\n               &SYSLIST(27),&SYSLIST(28),&SYSLIST(29),&SYSLIST(30),    $\n               &SYSLIST(31),&SYSLIST(32),&SYSLIST(33),                 $\n               &SYSLIST(34),&SYSLIST(35),&SYSLIST(36),                 $\n               &SYSLIST(37),&SYSLIST(38),&SYSLIST(39),                 $\n               &SYSLIST(40),&SYSLIST(41),&SYSLIST(42),                 $\n               &SYSLIST(43),&SYSLIST(44),&SYSLIST(45),                 $\n               &SYSLIST(46),&SYSLIST(47),&SYSLIST(48),                 $\n               &SYSLIST(49),&SYSLIST(50),&SYSLIST(51),&SYSLIST(52),    $\n               F=&TAG,S=&STAG,E=&CTR,B=1,T=B\n&STAG    DS    0H                       END OF UNTIL LOOP\n&#DLVL   SETA  &#DLVL-1                 DECREMENT LOOP LEVEL\n         AGO   .EXIT\n.PRC2000 AIF   ('&SYSLIST(1)' NE 'WHILE').PRC3000\n         B     &TAG                     LOOP WHILE\n&STAG    DS    0H                       END OF WHILE LOOP\n&#DLVL   SETA  &#DLVL-1                 DECREMENT LOOP LEVEL\n         AGO   .CHKONE\n.PRC3000 AIF   ('&SYSLIST(1)' NE 'BCT').PRC4000\n         BCT   &SYSLIST(2),&TAG         LOOP BCT\n&STAG    DS    0H                       END OF BCT LOOP\n&#DLVL   SETA  &#DLVL-1                 DECREMENT LOOP LEVEL\n         AIF   (N'&SYSLIST NE 2).ERR0004\n         AGO   .EXIT\n.PRC4000 AIF   ('&SYSLIST(1)' NE 'BXH').PRC5000\n         B     &TAG                     LOOP BXH\n&STAG    DS    0H                       END OF BXH LOOP\n&#DLVL   SETA  &#DLVL-1                 DECREMENT LOOP LEVEL\n         AGO   .CHKONE\n.PRC5000 AIF   ('&SYSLIST(1)' NE 'BXLE').ERR0005\n&FTAG    SETC  '&SYSLIST(2),&SYSLIST(3),&TAG'\n         BXLE  &FTAG                    LOOP BXLE\n&STAG    DS    0H                       END OF BXLE LOOP\n&#DLVL   SETA  &#DLVL-1                 DECREMENT LOOP LEVEL\n         AIF   (N'&SYSLIST NE 3).ERR0004\n         AGO   .EXIT\n.CHKONE  AIF   (N'&SYSLIST EQ 1).EXIT\n         MNOTE 8,'Additional positional parameters can not be specified$\n                on ENDLOOP &SYSLIST(1)'\n         AGO   .EXIT\n.ERR0001 MNOTE 8,'Nesting level for loops is 0'\n         AGO   .EXIT\n.ERR0002 MNOTE 8,'LOOP= does not match corresponding LOOP'\n         AGO   .EXIT\n.ERR0003 MNOTE 8,'&SYSLIST(1) does not match type on corresponding LOOP$\n               '\n         AGO   .EXIT\n.ERR0004 MNOTE 8,'Incorrect number of parameters specified for ENDLOOP $\n               &SYSLIST(1)'\n         AGO   .EXIT\n.ERR0005 MNOTE 8,'LOOP type &SYSLIST(1) is invalid'\n         AGO   .EXIT\n.ERR0006 MNOTE 8,'Incorrect number of parameters specified on ENDLOOP U$\n               NTIL,LEAVE'\n         AGO   .EXIT\n.ERR0007 MNOTE 8,'ENDLOOP structural level is not the same as the corre$\n               ponding LOOP'\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ENDPSD": {"ttr": 7180, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00)\\x00)\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ENDPSD\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1985.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ENDPSD\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ENDPSD\n.*\n.*  PURPOSE    STRUCTURED MACRO USED TO END A PSD\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    1/22/86 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &#PBNAME                 PROGRAM BLOCK NAME\n         GBLA  &#SB#C                   SUBROUTINE BLOCK NUMBER\n         GBLA  &#MLVL                   STRUCTURAL LEVEL\n         GBLA  &#SDLVL                  STRUCTURAL LEVEL OF STATIC DATA\n         GBLB  &#SDPSD                  INDICATES IN PSD\n         GBLC  &#SDSVLC                 SAVE LOCATION COUNTER\n         AIF   (&#SDPSD).SKIP1\n         MNOTE 8,'ENDPSD does not correspond to a PSD'\n         MEXIT\n.SKIP1   AIF   (&#SDLVL EQ &#MLVL).SKIP2\n         MNOTE 8,'ENDPSD is not at same nesting level as PSD'\n         AGO   .SKIP3\n.SKIP2   ANOP\n&#MLVL   SETA  &#MLVL-1                 ADD ONE TO STRUCTURAL LEVEL\n.SKIP3   ANOP\n&#SDLVL  SETA  0\n&#SDPSD  SETB  0\n&#SDSVLC LOCTR ,                        SET LOCATION COUNTER BACK\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ENDPWA": {"ttr": 7182, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00\\x1c\\x00\\x1c\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ENDPWA\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1985.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ENDPWA\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ENDPWA\n.*\n.*  PURPOSE    STRUCTURED MACRO USED TO END A PWA\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    7/14/85 MGG - NEW\n.*              1/23/86 MGG - ADDED TYPE=PARTIAL SUPPORT\n.*              9/10/86 MGG - ADDED SUPPORT FOR DEFINE STORAGE\n.*              1/06/87 MGG - MOVED CODE TO ##WESTD\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &#WEMAC                  EPILOG MACRO\n         &#WEMAC\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENDSSD": {"ttr": 7184, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00)\\x00)\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ENDSSD\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1985.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ENDSSD\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ENDSSD\n.*\n.*  PURPOSE    STRUCTURED MACRO USED TO END A SSD\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    1/22/86 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &#PBNAME                 PROGRAM BLOCK NAME\n         GBLA  &#SB#C                   SUBROUTINE BLOCK NUMBER\n         GBLA  &#MLVL                   STRUCTURAL LEVEL\n         GBLA  &#SDLVL                  STRUCTURAL LEVEL OF STATIC DATA\n         GBLB  &#SDSSD                  INDICATES IN SSD\n         GBLC  &#SDSVLC                 SAVE LOCATION COUNTER\n         AIF   (&#SDSSD).SKIP1\n         MNOTE 8,'ENDSSD does not correspond to a SSD'\n         MEXIT\n.SKIP1   AIF   (&#SDLVL EQ &#MLVL).SKIP2\n         MNOTE 8,'ENDSSD is not at the same nesting level as SSD'\n         AGO   .SKIP3\n.SKIP2   ANOP\n&#MLVL   SETA  &#MLVL-1                 ADD ONE TO STRUCTURAL LEVEL\n.SKIP3   ANOP\n&#SDLVL  SETA  0\n&#SDSSD  SETB  0\n&#SDSVLC LOCTR ,                        RESTORE LOCATION COUNTER\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ENDSWA": {"ttr": 7186, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00\\x1b\\x00\\x1b\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ENDSWA\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1985.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ENDSWA\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ENDSWA\n.*\n.*  PURPOSE    STRUCTURED MACRO USED TO END A SWA\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    7/14/85 MGG - NEW\n.*              1/23/86 MGG - ADDED PARTIAL SWA SUPPORT\n.*              1/06/87 MGG - MOVED CODE TO ##UESTD\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &#UEMAC                  EPILOG MACRO\n         &#UEMAC\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENDVDA": {"ttr": 7188, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00M\\x00M\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 77, "newlines": 77, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ENDVDA &SIZE=,&STORAGE=\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1991.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ENDVDA\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ENDVDA\n.*\n.*  PURPOSE    MACRO TO END A VARIABLE DEFINITION AREA.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    8/06/91 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &VDA__ID(20)\n         GBLC  &VDA__START(20)\n         GBLC  &VDA__SIZE(20)\n         GBLC  &VDA__STORAGE(20)\n         GBLC  &VDA__GENTYPE\n         GBLC  &VDA__CSECT\n         GBLC  &VDA__EPILOG\n         GBLC  &VDA__DC\n         GBLC  &VDA__DS\n         GBLC  &VDA__EQU\n         GBLA  &VDA__LEVEL\n         AIF   (&VDA__LEVEL GE 1).PRC010\n         MNOTE 8,'ENDVDA does not have a corresponding VDA macro.'\n         MEXIT\n.PRC010  ANOP\n&I       SETC  '&VDA__ID(&VDA__LEVEL)'\n.*\n.*  Determine tags for SIZE and storage\n.*\n&VDA__SIZE(&VDA__LEVEL) SETC ''\n         AIF   ('&SIZE' EQ 'NO').PRC020\n&VDA__SIZE(&VDA__LEVEL) SETC '&SIZE'\n         AIF   ('&SIZE' NE '').PRC020\n&VDA__SIZE(&VDA__LEVEL) SETC '&I.SIZE'\n.PRC020  ANOP\n&VDA__STORAGE(&VDA__LEVEL) SETC ''\n         AIF   ('&STORAGE' EQ 'NO').PRC030\n&VDA__STORAGE(&VDA__LEVEL) SETC '&STORAGE'\n         AIF   ('&STORAGE' NE '').PRC030\n&VDA__STORAGE(&VDA__LEVEL) SETC '&I.STORAGE'\n.PRC030  ANOP\n.*\n.*  If there is a epilog macro, call it.\n.*\n         AIF   ('&VDA__EPILOG' EQ '').PRC040\n         &VDA__EPILOG\n.PRC040  ANOP\n.*\n.*  Redefine opcodes as necessary and decrement VDA level.\n.*\n.FINISH  AIF   (&VDA__LEVEL NE 1).FIN900\n         AIF   ('&VDA__DC' EQ '').FIN010\nDC       OPSYN ##DC\n##DC     OPSYN\n.FIN010  AIF   ('&VDA__DS' EQ '').FIN020\nDS       OPSYN ##DS\n##DS     OPSYN\n.FIN020  AIF   ('&VDA__EQU' EQ '').FIN030\nEQU      OPSYN ##EQU\n##EQU    OPSYN\n.FIN030  ANOP\n.FIN900  AIF   (&VDA__LEVEL LT 1).FIN910\n&VDA__LEVEL SETA &VDA__LEVEL-1\n.FIN910  ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EQU": {"ttr": 7426, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00'\\x00'\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n&NAME    EQU\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1991.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      EQU\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - EQU\n.*\n.*  PURPOSE    MACRO USED TO REPLACE EQU OPCODE WITH AN ASSOCIATED\n.*             MACRO.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    8/06/91 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &VDA__EQU\n&CTR     SETA  N'&SYSLIST               GET NUMBER OF POSITIONAL PARMS\n&NAME    &VDA__EQU &SYSLIST(1),&SYSLIST(2),&SYSLIST(3),&SYSLIST(4),    +\n               &SYSLIST(5),&SYSLIST(6),&SYSLIST(7),&SYSLIST(8),        +\n               &SYSLIST(9),&SYSLIST(10),&SYSLIST(11),&SYSLIST(12),     +\n               &SYSLIST(13),&SYSLIST(14),&SYSLIST(15),&SYSLIST(16),    +\n               &SYSLIST(17),&SYSLIST(18),&SYSLIST(19),&SYSLIST(20),    +\n               &SYSLIST(21),&SYSLIST(22),&SYSLIST(23),&SYSLIST(24),    +\n               &SYSLIST(25),&SYSLIST(26),&SYSLIST(27),&SYSLIST(28),    +\n               &SYSLIST(29),&SYSLIST(30),&SYSLIST(31),&SYSLIST(32),    +\n               &SYSLIST(33),&SYSLIST(34),&SYSLIST(35),&SYSLIST(36),    +\n               &SYSLIST(37),&SYSLIST(38),&SYSLIST(39),&SYSLIST(40),    +\n               &SYSLIST(41),&SYSLIST(42),&SYSLIST(43),&SYSLIST(44),    +\n               &SYSLIST(45),&SYSLIST(45),&SYSLIST(47),&SYSLIST(48),    +\n               &SYSLIST(49),&SYSLIST(50),N=&CTR\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ERREXIT": {"ttr": 7428, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00u\\x00u\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 117, "newlines": 117, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ERREXIT &CODE=,&CODEREG=,&NAME=       ERROR EXIT\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ERREXIT\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ERREXIT\n.*\n.*  PURPOSE    STRUCTURED MACRO USED TO INVOKE AND ERREXIT BLOCK.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - NEW  MGG\n.*             03/20/84 MGG -  ALLOW '   ERREXIT , '\n.*              7/20/87 MGG -  REMOVED @CX, REORGANIZED AND ADDED\n.*                             ERRADDR SUPPORT.\n.*             10/18/89 MGG -  ERREXIT , FIX                        @C1\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#MNDX                   MASTER TAG INDEX\n         GBLA  &#PBNDX                  INDEX FOR PROGRAM BLOCK\n         GBLB  &#PBERRA                 ERROR ADDRESS OPTION\n         LCLC  &WNAME                   WORK NAME\n         LCLC  &WREG                    WORK CODE REGISTER\n         LCLC  &FTAG                    ERREXIT FAIL TAG\n         LCLC  &STAG                    ERREXIT SUCCESS TAG\n         LCLA  &CTR                     WORK COUNTER\n         LCLA  &NDX                     TAG INDEX FOR MACRO\n.*--------------------------------------------------------------------*\n.*  GET TAG INDEX, ERREXIT NAME AND CODE REGISTER INTO LOCAL VARIABLES.\n.*--------------------------------------------------------------------*\n&#MNDX   SETA  &#MNDX+1                 INCREMENT MASTER TAG INDEX\n&NDX     SETA  &#MNDX                   GET TAG INDEX\n&WREG    SETC  '&CODEREG'\n         AIF   ('&CODEREG' NE '').PRC0010\n&WREG    SETC  'R14'\n.PRC0010 ANOP\n&WNAME   SETC  '&NAME'                  SET WORK NAME\n         AIF   ('&NAME' NE '').PRC0020  IF NAME NOT SPECIFIED\n&WNAME   SETC  '#BX&#PBNDX'               USE DEFAULT NAME\n.PRC0020 ANOP\n.*--------------------------------------------------------------------*\n.*  IF THE NOERRADDR PROGRAM OPTION IS IN EFFECT, PLACE AN OPTIONAL\n.*  CODE IN THE CODE REGISETER AND BRANCH TO THE ERROR EXIT IF THE\n.*  CONDITION IS SUCCESSFUL.\n.*--------------------------------------------------------------------*\n.PRC0100 AIF   (&#PBERRA).PRC1000\n         AIF   ('&CODE' EQ '').PRC0200\n         LA    &WREG,&CODE              LOAD CODE (DEFAULT CODEREG)\n.PRC0200 AIF   (N'&SYSLIST GT 2).PRC0300                            @C1\n         AIF   ('&SYSLIST(1)' NE '' OR '&SYSLIST(2)' NE '').PRC0300 @C1\n         B     &WNAME                   BRANCH TO ERROR EXIT        @C1\n         MEXIT\n.PRC0300 ANOP\n&FTAG    SETC  '#LF&NDX'                FAIL TAG NAME\n&CTR     SETA  N'&SYSLIST               GET NUMBER OF POSITIONAL PARMS\n         ##COND &SYSLIST(1),&SYSLIST(2),                               $\n               &SYSLIST(3),&SYSLIST(4),&SYSLIST(5),&SYSLIST(6),        $\n               &SYSLIST(7),&SYSLIST(8),&SYSLIST(9),&SYSLIST(10),       $\n               &SYSLIST(11),&SYSLIST(12),&SYSLIST(13),&SYSLIST(14),    $\n               &SYSLIST(15),&SYSLIST(16),&SYSLIST(17),&SYSLIST(18),    $\n               &SYSLIST(19),&SYSLIST(20),&SYSLIST(21),&SYSLIST(22),    $\n               &SYSLIST(23),&SYSLIST(24),&SYSLIST(25),&SYSLIST(26),    $\n               &SYSLIST(27),&SYSLIST(28),&SYSLIST(29),&SYSLIST(30),    $\n               &SYSLIST(31),&SYSLIST(32),&SYSLIST(33),                 $\n               &SYSLIST(34),&SYSLIST(35),&SYSLIST(36),                 $\n               &SYSLIST(37),&SYSLIST(38),&SYSLIST(39),                 $\n               &SYSLIST(40),&SYSLIST(41),&SYSLIST(42),                 $\n               &SYSLIST(43),&SYSLIST(44),&SYSLIST(45),                 $\n               &SYSLIST(46),&SYSLIST(47),&SYSLIST(48),                 $\n               &SYSLIST(49),&SYSLIST(50),&SYSLIST(51),                 $\n               F=&FTAG,S=&WNAME,E=&CTR,B=1,L=P,T=B\n&FTAG    DS    0H                       LEAVE NOT EXECUTED TAG\n         MEXIT\n.PRC1000 ANOP\n.*--------------------------------------------------------------------*\n.*  IF THE ERRADDR PROGRAM OPTION IS IN EFFECT, USE A BAS INSTRUCTION\n.*  TO CALL THE ERROR EXIT IF THE CONDITION IS SATISFIED.  IF A CODE\n.*  IS SPECIFIED, GENERATE A DC FOR IT IMMEDIATELY AFTER THE BAS\n.*  INSTRUCTION.\n.*--------------------------------------------------------------------*\n&FTAG    SETC  '#LF&NDX'                FAIL TAG NAME\n&STAG    SETC  '#LS&NDX'                SUCCESS TAG NAME\n&CTR     SETA  N'&SYSLIST               GET NUMBER OF POSITIONAL PARMS\n         AIF   (N'&SYSLIST GT 2).PRC1020                            @C1\n         AIF   ('&SYSLIST(1)' NE '' OR '&SYSLIST(2)' NE '').PRC1020 @C1\n         AGO   .PRC1030                                             @C1\n.PRC1020 ##COND &SYSLIST(1),&SYSLIST(2),                            @C1$\n               &SYSLIST(3),&SYSLIST(4),&SYSLIST(5),&SYSLIST(6),        $\n               &SYSLIST(7),&SYSLIST(8),&SYSLIST(9),&SYSLIST(10),       $\n               &SYSLIST(11),&SYSLIST(12),&SYSLIST(13),&SYSLIST(14),    $\n               &SYSLIST(15),&SYSLIST(16),&SYSLIST(17),&SYSLIST(18),    $\n               &SYSLIST(19),&SYSLIST(20),&SYSLIST(21),&SYSLIST(22),    $\n               &SYSLIST(23),&SYSLIST(24),&SYSLIST(25),&SYSLIST(26),    $\n               &SYSLIST(27),&SYSLIST(28),&SYSLIST(29),&SYSLIST(30),    $\n               &SYSLIST(31),&SYSLIST(32),&SYSLIST(33),                 $\n               &SYSLIST(34),&SYSLIST(35),&SYSLIST(36),                 $\n               &SYSLIST(37),&SYSLIST(38),&SYSLIST(39),                 $\n               &SYSLIST(40),&SYSLIST(41),&SYSLIST(42),                 $\n               &SYSLIST(43),&SYSLIST(44),&SYSLIST(45),                 $\n               &SYSLIST(46),&SYSLIST(47),&SYSLIST(48),                 $\n               &SYSLIST(49),&SYSLIST(50),&SYSLIST(51),                 $\n               F=&FTAG,S=&STAG,E=&CTR,B=1,L=N,T=B\n.PRC1030 ANOP\n&STAG    BAS   &WREG,&WNAME             BRANCH TO ERREXIT\n         AIF   ('&CODE' EQ '').PRC1040\n         DC    AL2(&CODE)               ERREXIT CODE\n.PRC1040 ANOP\n&FTAG    DS    0H                       ERREXIT NOT TAKEN\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EXI": {"ttr": 7431, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00B\\x00B\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 66, "newlines": 66, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         EXI   &REG,                    REGISTER FOR EXECUTE.          +\n               &INSTR,                  INSTRUCTION TO EXECUTE.        +\n               &GEN=LOCTR               GENERATE WITH LOCTR (\u00acINLINE)\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1985.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      EXI\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - EXI\n.*\n.*  PURPOSE    MACRO TO GENERATE AN EX INSTRUCTION AND INSTRUCTION\n.*             THAT EX REFERS TO (EXECUTE IMMEDIATE).\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    1/31/85 PLH - NEW\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#MNDX                   LAST TAG INDEX USED\n         GBLA  &#PB#C                   NUMBER OF CURRENT PROGRAM BLOCK\n         GBLB  &#PBLOCR                 PROGRAM BLOCK LOCTR OPTION\n         GBLC  &#BTYPE(20)              BLOCK TYPE.\n         LCLA  &NDX                     TAG INDEX FOR THIS MACRO\n&#MNDX   SETA  &#MNDX+1                 CALCULATE NEW TAG INDEX.\n&NDX     SETA  &#MNDX                   SET INDEX TO USE IN THIS MACRO.\n         LCLC  &TAG1,&TAG2,&TAG3,&OPC\n&TAG1    SETC  '#EX#&NDX'               GENERATE TAGS FOR TARGET OF EX\n&TAG2    SETC  '#EXEND#&NDX'              BRANCH POINT FOR SKIP.\n&OPC     SETC  '&INSTR(1)'              EXTRACT OPCODE.\n         LCLC  &OPS                     WILL BUILD OPERAND STRING HERE.\n         AIF   (N'&INSTR LE 1).X100     DETERMINE NUMBER OF OPERANDS,\n&OPS     SETC  '&INSTR(2)'                  AND BUILD\n         AIF   (N'&INSTR LE 2).X100             OPERAND\n&OPS     SETC  '&OPS,&INSTR(3)'                   STRING.\n         AIF   (N'&INSTR LE 3).X100\n&OPS     SETC  '&OPS,&INSTR(4)'\n.X100    ANOP\n         EX    &REG,&TAG1               GENERATED EX INSTRUCTION.\n         AIF   (NOT &#PBLOCR).X300         CHECK FOR INLINE OR LOCTR.\n         AIF   ('&#BTYPE(1)' EQ 'SUBROUTINE').X200 IF SUBROUTINE BLOCK\n         PSD   TYPE=PARTIAL             LOCATION CTR FOR EX'ED INSTR.\n         AGO   .X400\n.X200    ANOP                           IF IN SUBROUTINE BLOCK,\n         SSD   TYPE=PARTIAL             LOCATION CTR FOR EX'ED INSTR.\n         AGO   .X400\n.X300    ANOP                           IF GENERATING INLINE,\n         B     &TAG2                      BRANCH OVER EX'ED INSTR.\n.X400    ANOP\n         DS    0H\n&TAG1    &OPC  &OPS\n         AIF   (NOT &#PBLOCR).X600      CHECK FOR INLINE OR LOCTR.\n         AIF   ('&#BTYPE(1)' EQ 'SUBROUTINE').X500 IF SUBROUTINE BLOCK\n         ENDPSD                         RESUME PREVIOUS LOCTR.\n         AGO   .X600\n.X500    ANOP\n         ENDSSD                         RESUME PREVIOUS LOCTR.\n.X600    ANOP\n&TAG2    DS    0H                       BRANCH HERE TO SKIP INSTR.\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FILL": {"ttr": 7433, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00\\xc6\\x00\\xc6\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 198, "newlines": 198, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n&TAG     FILL  &PLACE,&CHAR,&LENGTH=(,S)\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      FILL\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - FILL\n.*\n.*  PURPOSE    MACRO USED TO FILL AN AREA OF STORAGE WITH A CHARACTER.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - NEW  JCB\n.*              7/14/85 - DEFINE &LVALID\n.*              2/03/86 - CHANGED USE OF L',                        @C2\n.*                        ADDED 'XC' FOR SHORT FILLS FOR X'00'      @C3\n.*              1/18/88 - ADDED SUPPORT FOR SHORT 0(R1) FILLS       @C4\n.*              9/01/88 - MED AND LONG FILLS FOR X'00' USE SLR 1,1, @C5\n.*                        NOT LA 1,X'00'/SLL 1,24 SEQUENCE          @C5\n.*\n.*--------------------------------------------------------------------*\n.*\n.*   FILL MACRO FILLS A CHARACTER STRING WITH A CHARACTER.\n.*\n.*  SYM FILL TAG  ,LENGTH=((R)|EQUATE|NUMBER,S|M|L)   ,CHAR|X'00'\n.*        SMALL: 256 OR LESS\n.*        MEDIUM: 4095 OR LESS\n.*        LARGE: >4K\n.*      DEFAULTS: LENGTH=(L'TAG,S),CHAR=X'00'\n.*\n         LCLC  &C\n         LCLC  &REG\n         LCLC  &LEN\n         LCLB  &RFORM\n         LCLA  &L\n         LCLA  &I,&ISAVE                                            @C4\n         LCLC  &DEST1,&DEST2                                        @C4\n         LCLB  &LVALID                                              @C1\n         AIF   ('&TAG' EQ '').NOTAG\n&TAG     DS    0H\n.NOTAG   ANOP\n.*--------------------------------------------------------------------*\n.*  SET FILL CHARACTER OR DEFAULT IT TO X'00'\n.*--------------------------------------------------------------------*\n         AIF   ('&CHAR' EQ '').CHR0000\n&C       SETC  '&CHAR'                 SET FILL CHARACTER\n         AGO   .CHR0010\n.CHR0000 ANOP ,\n&C       SETC  'X''00'''               SET FILL CHARACTER\n.CHR0010 ANOP ,\n.*--------------------------------------------------------------------*\n.*  DETERMINE IF LENGTH SPECIFIED, AND IF IT'S A REGISTER\n.*--------------------------------------------------------------------*\n&RFORM   SETB  0                       SET REGFORM OFF\n&LVALID  SETB  0\n         AIF   ('&LENGTH(1)' NE '').LEN0000 NULL LENGTH? NO, .LEN0000\n&LEN     SETC  'L''&PLACE'             SET LCLC VAR. TO LENGTH\n&LVALID  SETB  1\n         AGO   .TYP0000                GO EXPAND 'SHORT'.\n.LEN0000 ANOP ,                        A 'LEN=' EXISTS.\n         AIF   ('&LENGTH(1)'(1,1) NE '(').NUM0000 (RNN) FORM, .REG0000\n.REG0000 ANOP\n&REG     SETC  '&LENGTH(1)'            SET 'REG' FOR INSTRUCTIONS\n&RFORM   SETB    1                    SET REG-FORM FLAG\n         AGO   .TYP0000             GO DETERMINE TYPE VALUE.\n.NUM0000 ANOP ,\n&LEN     SETC  '&LENGTH(1)'\n&LVALID  SETB  1\n.TYP0000 ANOP\n.*--------------------------------------------------------------------*\n.*  DETERMINE TYPE OF CALL: SHORT, MEDIUM OR LONG\n.*--------------------------------------------------------------------*\n         AIF   ('&LENGTH(2)' EQ '').SHO0000\n         AIF   ('&LENGTH(2)'(1,1) EQ 'L').LNG0000\n         AIF   ('&LENGTH(2)'(1,1) EQ 'M').MED0000\n         AIF   ('&LENGTH(2)'(1,1) NE 'S').LENERR\n.*--------------------------------------------------------------------*\n.*  SHORT FILL\n.*--------------------------------------------------------------------*\n.SHO0000 ANOP\n         AIF   (&RFORM).SHX0000\n.*--------------------------------------------------------------------*\n.*  DETERMINE IF LENGTH IS OF THE FORM: DISP(REG) (E.G 0(R1))\n.*--------------------------------------------------------------------*\n.SHO0010 ANOP  ,                                                    @C4\n&I       SETA  1                                                    @C4\n.SHO0020 AIF   ('&PLACE'(&I,1) EQ '(').SHO0030                      @C4\n&I       SETA  &I+1                                                 @C4\n         AIF   (&I LE K'&PLACE).SHO0020                             @C4\n         AGO   .SHO0100                                             @C4\n.*--------------------------------------------------------------------*\n.*  POINTER TO AREA TO FILL IS OF FORM: DISP(REG). MAKE SURE A LENGTH\n.*  WAS PROVIDED (L'TAG IS NO GOOD HERE), THEN PICK THE ADDRESS APART.\n.*--------------------------------------------------------------------*\n.SHO0030 AIF   ('&LENGTH(1)' NE '').SHO0040                         @C4\n         MNOTE 8,'Length for FILL required but not specified'       @C4\n         AGO   .FILLXIT                                             @C4\n.SHO0040 ANOP                                                       @C4\n&DEST1   SETC  '&PLACE'(1,&I-1)                                     @C4\n&ISAVE   SETA  &I+1                                                 @C4\n.SHO0050 AIF   ('&PLACE'(&I,1) EQ ')').SHO0060                      @C4\n&I       SETA  &I+1                                                 @C4\n         AIF   (&I LE K'&PLACE).SHO0050                             @C4\n         MNOTE 8,'Unable to parse FILL destination'                 @C4\n         AGO   .FILLXIT                                             @C4\n.SHO0060 ANOP  ,                                                    @C4\n&I       SETA  &I-&ISAVE                                            @C4\n&DEST2   SETC  '&PLACE'(&ISAVE,&I)                                  @C4\n&LEN     SETC  '&LENGTH(1)'                                         @C4\n         AIF   ('&LENGTH'(1,1) EQ '(').SRG0000\n         AIF   ('&C' EQ 'X''00''' OR '&C' EQ '0').SHO0080           @C5\n         MVI   &PLACE,&C            MOVE INITIAL FILL BYTE          @C4\n         MVC   1+&DEST1.(&LEN.-1,&DEST2.),&PLACE                    @C4\n         AGO   .FILLXIT                                             @C4\n.SHO0080 XC    &DEST1.(&LEN.,&DEST2.),&PLACE                        @C5\n         AGO   .FILLXIT                                             @C4\n.SRG0000 ANOP  ,\n&REG     SETC  '&LEN'\n         LCLC  &EXIOP1\n&EXIOP1  SETC  '&DEST1.(0,&DEST2.)'\n         BCTR  &REG.,0\n         AIF   ('&C' EQ 'X''00''' OR '&C' EQ '0').SRG0010\n         BCTR  &REG.,0\n         MVI   &PLACE.,&C.\n         EXI   &REG.,(MVC,1+&EXIOP1,&PLACE.)\n         AGO   .FILLXIT                                             @C4\n.SRG0010 ANOP  ,\n.*       MNOTE *,'EXI   &REG.,(XC,&EXIOP1,&PLACE.)'\n         EXI   &REG.,(XC,&EXIOP1,&PLACE.)\n         AGO   .FILLXIT                                             @C4\n.*--------------------------------------------------------------------*\n.*  STANDARD SHORT FILL\n.*--------------------------------------------------------------------*\n.SHO0100 AIF   ('&C' NE 'X''00''' AND '&C' NE '0').SHO0110          @C5\n         XC    &PLACE.(&LEN),&PLACE  USE XC TO ZERO OUT STRING      @C3\n         AGO   .FILLXIT                                             @C5\n.SHO0110 MVI   &PLACE.,&C.          MOVE INITIAL FILL BYTE          @C5\n         MVC   1+&PLACE.(&LEN.-1),&PLACE  COPY THROUGH FIELD\n         AGO   .FILLXIT\n.SHX0000 AIF   ('&PLACE'(1,1) EQ '(').SHXREG0\n         BCTR  &REG.,0              DECREMENT LENGTH REGISTER\n         AIF   ('&C' NE 'X''00''' AND '&C' NE '0').SHX0010\n         BCTR  &REG.,0                TWICE\n         MVI   &PLACE.,&C.          MOVE INITIAL FILL BYTE\n         EXI   &REG,(MVC,1+&PLACE.(0),&PLACE)\n         LA    &REG.,2(,&REG.)      RESTORE LENGTH REGISTER\n         AGO   .FILLXIT\n.SHX0010 EXI   &REG,(XC,&PLACE.(0),&PLACE)\n         LA    &REG.,1(,&REG.)      RESTORE LENGTH REGISTER\n         AGO   .FILLXIT\n.SHXREG0 ANOP\n         BCTR  &REG.,0              DECREMENT LENGTH REGISTER\n         AIF   ('&C' NE 'X''00''' AND '&C' NE '0').SHXREG1\n         BCTR  &REG.,0                TWICE\n         MVI   0&PLACE.,&C.         MOVE INITIAL FILL BYTE\n.*       EX    &REG.,*+8            EXECUTE THE MOVE\n.*       B     *+10                 SKIP EXECUTED MOVE\n.*       MVC   1(0,&PLACE.),0&PLACE ** EXECUTED **\n         EXI   &REG,(MVC,1(0,&PLACE),0(&PLACE))\n         LA    &REG.,2(,&REG.)      RESTORE LENGTH REGISTER\n         AGO   .FILLXIT\n.SHXREG1 EXI   &REG,(XC,0(0,&PLACE),0(&PLACE))\n         LA    &REG.,1(,&REG.)      RESTORE LENGTH REGISTER\n         AGO   .FILLXIT\n.MED0000 ANOP  ,                    GENERATE MEDIUM-LENGTH FILL\n         AIF   (&RFORM).LNG0000     LONGFORM, SAME DIFFERENCE\n         AIF   (&LVALID).MED0010\n         LA    15,&LENGTH(1)           GET LENGTH VALUE\n         AGO   .MVL0000             GO DO MOVE-LONG CODE\n.MED0010 ANOP ,\n         LA    15,&LEN              GET LENGTH VALUE                @C2\n         AGO   .MVL0000\n.LNG0000 ANOP ,\n         AIF   (&RFORM).LNG0010\n         MNOTE 8,'Long form FILL requires R-form length'\n         AGO   .FILLXIT\n.LNG0010 ANOP ,\n         LR    15,&REG.             GET LENGTH OF FILL AREA\n.MVL0000 ANOP ,\n         LA    14,&PLACE.           GET DESTINATION ADDRESS\n         SLR   0,0                  NO SOURCE ADDRESS\n         AIF   ('&C' EQ 'X''00''' OR '&C' EQ '0').MVL0010           @C5\n         LA    1,&C.                LOAD FILL CHARACTER\n         SLL   1,24                 SHIFT TO HIGH-ORDER BYTE\n         AGO   .MVL0020\n.MVL0010 SLR   1,1                  ZERO DEST LENGTH AND FILL BYTE  @C5\n.MVL0020 MVCL  14,0                 PROPAGATE FILL CHARACTER.\n.FILLXIT MEXIT\n.LENERR  MNOTE 8,'FILL operation type invalid: Must be S)hort, M)edium,*\n                or L)ong.'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IBIT": {"ttr": 7437, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00?\\x00?\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n&NAME    IBIT  ,                        INVERT BIT MACRO\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      IBIT\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - IBIT\n.*\n.*  PURPOSE    MACRO USED TO INVERT A BIT.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - NEW  MGG\n.*\n.*--------------------------------------------------------------------*\n         LCLA  &POSFLAG                 POSITION OF FLAG\n         LCLA  &CTR                     COUNTER\n         LCLC  &BYTE                    BYTE NAME\n         LCLC  &FLAGS                   CONCATINATION OF FLAGS\n         AIF   (N'&SYSLIST NE 1).PRC0100\n         AIF   (N'&SYSLIST(1) GT 8).ERR0001  ERROR IF MORE THEN 8 FLAGS\n         AIF   (K'&SYSLIST(1,1) LT 6).ERR0003  ERROR IF FLAG < 6 CHARS\n&BYTE    SETC  '&SYSLIST(1,1)'(1,5)     BYTE NAME IS FIRST FIVE CHARS\n&FLAGS   SETC  '&SYSLIST(1,1)'          MOVE IN FIRST FLAG\n&CTR     SETA  2                        LOOP CONCATINATING EACH FLAG\n.PRC0050 AIF   (&CTR GT N'&SYSLIST(1)).PRC0060   LEAVE LOOP IF FINISHED\n         AIF   (K'&SYSLIST(1,&CTR) LT 6).ERR0003    ERROR\n         AIF   ('&SYSLIST(1,&CTR)'(1,5) NE '&BYTE').ERR0004 ERROR\n&FLAGS   SETC  '&FLAGS+&SYSLIST(1,&CTR)' CONCATINATE\n&CTR     SETA  &CTR+1                   ADD 1 TO COUNTER\n         AGO   .PRC0050                 LOOP FOR ALL FLAGS\n.PRC0060 ANOP\n&NAME    XI    &BYTE,&FLAGS             INVERT FLAG(S)\n         MEXIT\n.PRC0100 AIF   (N'&SYSLIST NE 2).ERR0002     ERROR IF MORE THAN 2 PARMS\n         AIF   (N'&SYSLIST(2) GT 8).ERR0001  ERROR IF MORE THAN 8 FLAGS\n&BYTE    SETC  '&SYSLIST(1)'            SET BYTE NAME\n&FLAGS   SETC  '&SYSLIST(2,1)'          MOVE IN FIRST FLAG\n&CTR     SETA  2                        LOOP CONCATINATING EACH FLAG\n.PRC0150 AIF   (&CTR GT N'&SYSLIST(2)).PRC0160 LEAVE LOOP IF FINISHED\n&FLAGS   SETC  '&FLAGS+&SYSLIST(2,&CTR)' CONCATINATE\n&CTR     SETA  &CTR+1                   ADD 1 TO COUNTER\n         AGO   .PRC0150                 LOOP FOR ALL FLAGS\n.PRC0160 ANOP\n&NAME    XI    &BYTE,&FLAGS             INVERT FLAG(S)\n         MEXIT\n.ERR0001 MNOTE 8,'No more than eight flags can be specified'\n         MEXIT\n.ERR0002 MNOTE 8,'IBIT macro can have no more than two operands'\n         MEXIT\n.ERR0003 MNOTE 8,'If byte is not specified, flag name must be at least $\n               six characters long'\n         MEXIT\n.ERR0004 MNOTE 8,'If byte is not specified, the first five characters o$\n               f all flags must match'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IF": {"ttr": 7439, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00A\\x00A\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 65, "newlines": 65, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         IF    &NAME=\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      IF\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - IF\n.*\n.*  PURPOSE    STRUCTURED MACRO USED TO START AN IF STRUCTURE.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - NEW  MGG\n.*              9/15/89 MGG - ADDED T=A ON ##COND MACRO CALL.       @C1\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#MNDX                   LAST TAG INDEX USED\n         GBLA  &#MLVL                   STRUCTURAL LEVEL\n         GBLA  &#IMLVL(20)              STRUCTURAL LEVEL OF IF\n         GBLA  &#ILVL                   IF NEXTING LEVEL\n         GBLA  &#INDX(20)               IF TAG INDEX\n         GBLA  &#INDX2(20)              IF TAG INDEX 2\n         GBLB  &#IELSE(20)              ELSE ENCOUNTERED\n         GBLC  &#INAME(20)              IF NAMES\n         LCLA  &CTR                     WORK COUNT\n         LCLC  &FTAG,&STAG              FAIL TAG AND SUCCESS TAG\n&#MNDX   SETA  &#MNDX+1                 ADD ONE TO TAG INDEX\n         AIF   (&#ILVL GE 20).ERR0001\n&#ILVL   SETA  &#ILVL+1                 ADD ONE TO NESTING LEVEL\n&#MLVL   SETA  &#MLVL+1                 ADD ONE TO STRUCTURAL LEVEL\n&#IMLVL(&#ILVL) SETA  &#MLVL            SAVE STRUCTURAL LEVEL OF IF\n&#INDX(&#ILVL)  SETA  &#MNDX            SET BLOCK TAG INDEX\n&#INDX2(&#ILVL) SETA  &#MNDX            SET BLOCK TAG INDEX\n&#IELSE(&#ILVL) SETB  0                 ELSE ENCOUNTERED FLAG\n&#INAME(&#ILVL) SETC '&NAME'            SAVE NAME\n&FTAG    SETC  '#IF&#MNDX'              FAIL TAG NAME\n&STAG    SETC  '#IS&#MNDX'              SUCCESS TAG NAME\n&CTR     SETA  N'&SYSLIST               GET NUMBER OF POSITIONAL PARMS\n         ##COND &SYSLIST(1),&SYSLIST(2),&SYSLIST(3),                   $\n               &SYSLIST(4),&SYSLIST(5),&SYSLIST(6),                    $\n               &SYSLIST(7),&SYSLIST(8),&SYSLIST(9),&SYSLIST(10),       $\n               &SYSLIST(11),&SYSLIST(12),&SYSLIST(13),&SYSLIST(14),    $\n               &SYSLIST(15),&SYSLIST(16),&SYSLIST(17),&SYSLIST(18),    $\n               &SYSLIST(19),&SYSLIST(20),&SYSLIST(21),&SYSLIST(22),    $\n               &SYSLIST(23),&SYSLIST(24),&SYSLIST(25),&SYSLIST(26),    $\n               &SYSLIST(27),&SYSLIST(28),&SYSLIST(29),&SYSLIST(30),    $\n               &SYSLIST(31),&SYSLIST(32),&SYSLIST(33),                 $\n               &SYSLIST(34),&SYSLIST(35),&SYSLIST(36),                 $\n               &SYSLIST(37),&SYSLIST(38),&SYSLIST(39),                 $\n               &SYSLIST(40),&SYSLIST(41),&SYSLIST(42),                 $\n               &SYSLIST(43),&SYSLIST(44),&SYSLIST(45),                 $\n               &SYSLIST(46),&SYSLIST(47),&SYSLIST(48),                 $\n               &SYSLIST(49),&SYSLIST(50),&SYSLIST(51),                 $\n               F=&FTAG,S=&STAG,E=&CTR,B=1,T=A                       @C1\n&STAG    DS    0H                       START OF SUCCESSFUL IF CODE\n         AGO   .EXIT\n.ERR0001 MNOTE 8,'IFs can only be nested 20 deep'\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LCBA": {"ttr": 7681, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00n\\x00n\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 110, "newlines": 110, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         LCBA  &REG,&CB\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1986.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      LCBA\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - LCBA\n.*\n.*  PURPOSE    MACRO USED TO LOAD ADDRESS OF CONTROL BLOCK\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   05/06/86 - NEW  MGG\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#MNDX                   STRUCTURED MACRO TAG INDEX\n         GBLA  &#MCVREG                 CONVERTED REGISTER (##CVREG)\n         LCLC  &TAG1,&TAG2,&TAG3        WORK TAGS\n&#MNDX   SETA  &#MNDX+1                 INCREMENT TAG INDEX\n.*--------------------------------------------------------------------*\n.*  INSURE THAT REG IS R1-R15\n.*--------------------------------------------------------------------*\n         ##CVREG &REG\n         AIF   (&#MCVREG LE 15 AND &#MCVREG GT 0).CHK0100\n         MNOTE 8,'&REG is invalid.  Register must be R1-R15.'\n         MEXIT\n.CHK0100 ANOP\n.*--------------------------------------------------------------------*\n.*  LOAD ADDRESS OF CURRENT ACEE\n.*--------------------------------------------------------------------*\n         AIF   ('&CB' NE 'ACEE').ACE9999\n&TAG1    SETC  '#LE&#MNDX'\n&TAG2    SETC  '#LS&#MNDX'\n         L     &REG,540                POINT TO CURRENT TCB\n         TM    278(&REG),X'80'         TCB EXTENTION PRESENT?\n         BZ    &TAG2                   NO, SKIP LOAD FROM TCB\n         ICM   &REG,B'1111',340(&REG)  LOAD ACEE POINTER\n         BNZ   &TAG1                   BRANCH IF PRESENT\n&TAG2    L     &REG,548                POINT TO CURRENT ASCB\n         L     &REG,108(,&REG)         POINT TO CURRENT ASXB\n         ICM   &REG,B'1111',200(&REG)  POINT TO ACEE\n&TAG1    DS    0H                      END OF LOAD ACEE CODE\n         MEXIT\n.ACE9999 ANOP\n.*--------------------------------------------------------------------*\n.*  LOAD ADDRESS OF ASCB\n.*--------------------------------------------------------------------*\n         AIF   ('&CB' NE 'ASCB').ASC9999\n         ICM   &REG,B'1111',548         POINT TO CURRENT ASCB\n         MEXIT\n.ASC9999 ANOP\n.*--------------------------------------------------------------------*\n.*  LOAD ADDRESS OF ASXB\n.*--------------------------------------------------------------------*\n         AIF   ('&CB' NE 'ASXB').ASX9999\n         L     &REG,548                 POINT TO CURRENT ASCB\n         ICM   &REG,B'1111',108(&REG)   POINT TO CURRENT ASXB\n         MEXIT\n.ASX9999 ANOP\n.*--------------------------------------------------------------------*\n.*  LOAD ADDRESS OF CVT\n.*--------------------------------------------------------------------*\n         AIF   ('&CB' NE 'CVT').CVT9999\n         ICM   &REG,B'1111',16          POINT TO CVT\n         MEXIT\n.CVT9999 ANOP\n.*--------------------------------------------------------------------*\n.*  LOAD ADDRESS OF CURRENT TCB\n.*--------------------------------------------------------------------*\n         AIF   ('&CB' NE 'TCB').TCB9999\n         ICM   &REG,B'1111',540         POINT TO CURRENT TCB\n         MEXIT\n.TCB9999 ANOP\n.*--------------------------------------------------------------------*\n.*  LOAD ADDRESS OF UJT\n.*--------------------------------------------------------------------*\n         AIF   ('&CB' NE 'UJT').UJT9999\n&TAG1    SETC  '#LL&#MNDX'\n&TAG2    SETC  '#LF&#MNDX'\n&TAG3    SETC  '#LE&#MNDX'\n         L     &REG,540                 POINT TO CURRENT TCB\n&TAG1    TM    168(&REG),X'80'          DOES THIS TCB POINT TO UJT?\n         BO    &TAG2                    YES, FOUND\n         ICM   &REG,B'1111',132(&REG)   NO, POINT TO NEXT TCB\n         BNZ   &TAG1                    LOOP UNTIL END OF TCB CHAIN\n         B     &TAG3                    SKIP SUCCESS CODE\n&TAG2    L     &REG,168(,&REG)          POINT TO UVT\n         N     &REG,=A(X'00FFFFFF')     CLEAR HIGH BYTE AND SET CC\n&TAG3    DS    0H                       END OF LOAD UVT CODE\n         MEXIT\n.UJT9999 ANOP\n.*--------------------------------------------------------------------*\n.*  LOAD ADDRESS OF UVT\n.*--------------------------------------------------------------------*\n         AIF   ('&CB' NE 'UVT').UVT9999\n         L     &REG,16                  POINT TO CVT\n         L     &REG,204(,&REG)          LOAD UVT ADDRESS\n         N     &REG,=A(X'00FFFFFF')     CLEAR HIGH BYTE AND SET CC\n         MEXIT\n.UVT9999 ANOP\n.*--------------------------------------------------------------------*\n         MNOTE 8,'&CB is not a supported control block'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LEAVE": {"ttr": 7684, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x011\\x011\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 305, "newlines": 305, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         LEAVE &BLOCK=,                 LEAVE BLOCK                    $\n               &LOOP=,                  LEAVE LOOP                     $\n               &IF=,                    LEAVE IF                       $\n               &CASEBLK=                LEAVE CASEBLK\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      LEAVE\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - LEAVE\n.*\n.*  PURPOSE    STRUCTURED MACRO USED TO LEAVE A STRUCTURE.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 MGG - NEW\n.*             11/21/83 MGG - &ENBLK WAS UNDEFINED\n.*              7/14/85 MGG - &PBSMWA WAS UNDEFINED                 @C1\n.*\n.*--------------------------------------------------------------------*\n         GBLB  &#PBXA                   XA\n         GBLB  &#PB370                  370\n         GBLA  &#MNDX                   MASTER TAG INDEX\n         GBLA  &#MLVL                   STRUCTURAL LEVEL\n         GBLA  &#BMLVL(20)              STRUCTURAL LEVEL OF BLOCK\n         GBLC  &#BNAME(20)              BLOCK NAME\n         GBLA  &#BLVL                   BLOCK LEVEL\n         GBLA  &#BNDX(20)               BLOCK TAG INDEX\n         GBLC  &#BTYPE(20)              BLOCK TYPE\n         GBLC  &#BAMODE(20)             ADDRESSING MODE OF BLOCK\n         GBLC  &#BSV1(20)               BLOCK SAVE PARM 1\n         GBLC  &#BSV2(20)               BLOCK SAVE PARM 2\n         GBLC  &#BSV3(20)               BLOCK SAVE PARM 3\n         GBLA  &#DMLVL(20)              STRUCTURAL LEVEL OF LOOP\n         GBLC  &#DNAME(20)              LOOP NAME\n         GBLA  &#DLVL                   LOOP LEVEL\n         GBLA  &#DNDX(20)               LOOP TAG INDEX\n         GBLA  &#IMLVL(20)              STRUCTURAL LEVEL OF IF\n         GBLC  &#INAME(20)              IF NAME\n         GBLA  &#ILVL                   IF LEVEL\n         GBLA  &#INDX(20)               IF TAG INDEX\n         GBLA  &#CMLVL(20)              STRUCTURAL LEVEL OF CASEBLK\n         GBLC  &#CNAME(20)              CASEBLK NAME\n         GBLA  &#CLVL                   CASELBK LEVEL\n         GBLA  &#CNDX(20)               CASEBLK TAG INDEX\n         GBLC  &#PBSMWA                 STRUCTURED MACRO WA TAG     @C1\n         LCLA  &CTR                     WORK COUNTER\n         LCLA  &ENBLK                   WORK VARIABLE\n         LCLC  &NAME                    NAME OF THING LEAVING\n         LCLC  &STRUC                   TYPE OF STRUCTURE LEAVING\n         LCLC  &TAG                     LEAVE TAG NAME\n         LCLC  &TAG2,&TAG3              WORK TAGS\n         LCLC  &FTAG                    LEAVE FAIL TAG NAME\n         LCLC  &STAG                    LEAVE SUCCESS TAG NAME\n         LCLC  &LOGIC                   LOGIC FOR ##COND\n         LCLA  &SMLVL                   LEAVE TO THIS STRUCTURAL LEVEL\n&#MNDX   SETA  &#MNDX+1\n.PRC1000 AIF   ('&BLOCK' EQ '').PRC2000\n.*--------------------------------------------------------------------*\n.* LEAVE BLOCK.\n.*--------------------------------------------------------------------*\n         AIF   ('&LOOP' NE '').ERR0001\n         AIF   ('&IF' NE '').ERR0001\n         AIF   ('&CASEBLK' NE '').ERR0001\n&STRUC   SETC  'BLOCK'\n&NAME    SETC  '&BLOCK'\n         AIF   (&#BLVL LE 0).ERR0002\n         AIF   ('&NAME' NE '*').PRC1100\n&TAG     SETC  '#BE&#BNDX(&#BLVL)'\n&SMLVL   SETA  &#BMLVL(&#BLVL)\n         AGO   .PRC8000\n.PRC1100 ANOP\n&CTR     SETA  &#BLVL                   BLOCK LEVEL\n.PRC1110 AIF   ('&NAME' EQ '&#BNAME(&CTR)').PRC1200\n&CTR     SETA  &CTR-1\n         AIF   (&CTR GT 0).PRC1110      LOOP\n         AGO   .ERR0003\n.PRC1200 ANOP\n&TAG     SETC  '#BE&#BNDX(&CTR)'\n&SMLVL   SETA  &#BMLVL(&CTR)\n         AGO   .PRC8000\n.PRC2000 AIF   ('&IF' EQ '').PRC3000\n.*--------------------------------------------------------------------*\n.* LEAVE IF.\n.*--------------------------------------------------------------------*\n         AIF   ('&LOOP' NE '').ERR0001\n         AIF   ('&BLOCK' NE '').ERR0001\n         AIF   ('&CASEBLK' NE '').ERR0001\n&STRUC   SETC  'IF'\n&NAME    SETC  '&IF'\n         AIF   (&#BLVL LE 0).ERR0002\n         AIF   ('&NAME' NE '*').PRC2100\n&TAG     SETC  '#IE&#INDX(&#ILVL)'\n&SMLVL   SETA  &#IMLVL(&#ILVL)\n         AGO   .PRC8000\n.PRC2100 ANOP\n&CTR     SETA  &#ILVL                   IF LEVEL\n.PRC2110 AIF   ('&NAME' EQ '&#INAME(&CTR)').PRC2200\n&CTR     SETA  &CTR-1\n         AIF   (&CTR GT 0).PRC2110      LOOP\n         AGO   .ERR0003\n.PRC2200 ANOP\n&TAG     SETC  '#IE&#INDX(&CTR)'\n&SMLVL   SETA  &#IMLVL(&CTR)\n         AGO   .PRC8000\n.PRC3000 AIF   ('&LOOP' EQ '').PRC4000\n.*--------------------------------------------------------------------*\n.* LEAVE LOOP.\n.*--------------------------------------------------------------------*\n         AIF   ('&IF' NE '').ERR0001\n         AIF   ('&BLOCK' NE '').ERR0001\n         AIF   ('&CASEBLK' NE '').ERR0001\n&STRUC   SETC  'LOOP'\n&NAME    SETC  '&LOOP'\n         AIF   (&#DLVL LE 0).ERR0002\n         AIF   ('&NAME' NE '*').PRC3100\n&TAG     SETC  '#DE&#DNDX(&#DLVL)'\n&SMLVL   SETA  &#DMLVL(&#DLVL)\n         AGO   .PRC8000\n.PRC3100 ANOP\n&CTR     SETA  &#DLVL                   LOOP LEVEL\n.PRC3110 AIF   ('&NAME' EQ '&#DNAME(&CTR)').PRC3200\n&CTR     SETA  &CTR-1\n         AIF   (&CTR GT 0).PRC3110      LOOP\n         AGO   .ERR0003\n.PRC3200 ANOP\n&TAG     SETC  '#DE&#DNDX(&CTR)'\n&SMLVL   SETA  &#DMLVL(&CTR)\n         AGO   .PRC8000\n.PRC4000 AIF   ('&CASEBLK' EQ '').PRC5000\n.*--------------------------------------------------------------------*\n.* LEAVE CASEBLK.\n.*--------------------------------------------------------------------*\n         AIF   ('&BLOCK' NE '').ERR0001\n         AIF   ('&IF' NE '').ERR0001\n         AIF   ('&LOOP' NE '').ERR0001\n&STRUC   SETC  'CASEBLK'\n&NAME    SETC  '&CASEBLK'\n         AIF   (&#CLVL LE 0).ERR0002\n         AIF   ('&NAME' NE '*').PRC4100\n&TAG     SETC  '#CE&#CNDX(&#CLVL)'\n&SMLVL   SETA  &#CMLVL(&#CLVL)\n         AGO   .PRC8000\n.PRC4100 ANOP\n&CTR     SETA  &#CLVL                   CASEBLK LEVEL\n.PRC4110 AIF   ('&NAME' EQ '&#CNAME(&CTR)').PRC4200\n&CTR     SETA  &CTR-1\n         AIF   (&CTR GT 0).PRC4110      CASEBLK\n         AGO   .ERR0003\n.PRC4200 ANOP\n&TAG     SETC  '#CE&#CNDX(&CTR)'\n&SMLVL   SETA  &#CMLVL(&CTR)\n         AGO   .PRC8000\n.PRC5000 AGO   .ERR0004                 NO KEYWORD SPECIFIED\n.*--------------------------------------------------------------------*\n.* FIND LEVEL OF ENCLOSING BLOCK.\n.*--------------------------------------------------------------------*\n.PRC8000 ANOP\n&ENBLK   SETA  &#BLVL\n.PRC8100 AIF   (&#BMLVL(&ENBLK) LE &SMLVL).PRC8110\n&ENBLK   SETA  &ENBLK-1\n         AIF   (&ENBLK GT 0).PRC8100\n.*--------------------------------------------------------------------*\n.* IF (ENCLOSEING BLOCK IS NOT INNERMOST BLOCK AND\n.* (AMODE OF CONTAINING BLOCK IS NOT EQUATE TO INNERMOST BLOCK\n.* AND (STRUCTURE WE ARE LEAVING IS NOT BLOCK OR (STRUCTURE\n.* WE ARE LEAVING IS BLOCK AND IT'S ENCLOSING BLOCK IS SAME\n.* ADDRESSING MODE))) OR BLOCKS CONTAINED SAVE REGISTERS) THEN\n.* SPECIAL PROCESSING IS REQUIRED.\n.*--------------------------------------------------------------------*\n         AGO   .PRC8600                 OUTSIDE OF BLOCK\n.PRC8110 AIF   (&ENBLK GE &#BLVL).PRC8600\n         AIF   (&#BAMODE(&ENBLK) EQ &#BAMODE(&#BLVL)).PRC8190\n         AIF   ('&STRUC' NE 'BLOCK').PRC8500\n         AIF   (&#BLVL LE 1).PRC8500\n         AIF   (&#BAMODE(&ENBLK) EQ &#BAMODE(&ENBLK-1)).PRC8500\n.PRC8190 ANOP\n&CTR     SETA  &ENBLK+1\n.PRC8200 AIF   ('&#BSV1(&CTR)' NE '').PRC8500\n&CTR     SETA  &CTR+1\n         AIF   (&CTR LE &#BLVL).PRC8200\n         AGO   .PRC8600\n.*--------------------------------------------------------------------*\n.* SPECIAL RESTORES AND/OR AMODE CHANGES NEEDED IF HERE.\n.*--------------------------------------------------------------------*\n.PRC8500 AIF   (N'&SYSLIST EQ 0).PRC9000\n&STAG    SETC  '#LS&#MNDX'              SUCCESS TAG\n&FTAG    SETC  '#LF&#MNDX'              FAIL TAG\n&LOGIC   SETC  'N'                      NEGATIVE LOGIC\n         AGO   .PRC8700\n.*--------------------------------------------------------------------*\n.* NO SPECIAL RESTORES OR AMODE CHANGES NEEDED IF HERE.\n.*--------------------------------------------------------------------*\n.PRC8600 AIF   (N'&SYSLIST EQ 0).PRC9800\n&STAG    SETC  '&TAG'                   SUCCESS TAG NAME\n&FTAG    SETC  '#LF&#MNDX'              FAIL TAG NAME\n&LOGIC   SETC  'P'                      POSITIVE LOGIC\n.*--------------------------------------------------------------------*\n.* GENERATE CONDITION TESTS.\n.*--------------------------------------------------------------------*\n.PRC8700 ANOP\n&CTR     SETA  N'&SYSLIST               GET NUMBER OF POSITIONAL PARMS\n         ##COND &SYSLIST(1),&SYSLIST(2),                               $\n               &SYSLIST(3),&SYSLIST(4),&SYSLIST(5),&SYSLIST(6),        $\n               &SYSLIST(7),&SYSLIST(8),&SYSLIST(9),&SYSLIST(10),       $\n               &SYSLIST(11),&SYSLIST(12),&SYSLIST(13),&SYSLIST(14),    $\n               &SYSLIST(15),&SYSLIST(16),&SYSLIST(17),&SYSLIST(18),    $\n               &SYSLIST(19),&SYSLIST(20),&SYSLIST(21),&SYSLIST(22),    $\n               &SYSLIST(23),&SYSLIST(24),&SYSLIST(25),&SYSLIST(26),    $\n               &SYSLIST(27),&SYSLIST(28),&SYSLIST(29),&SYSLIST(30),    $\n               &SYSLIST(31),&SYSLIST(32),&SYSLIST(33),                 $\n               &SYSLIST(34),&SYSLIST(35),&SYSLIST(36),                 $\n               &SYSLIST(37),&SYSLIST(38),&SYSLIST(39),                 $\n               &SYSLIST(40),&SYSLIST(41),&SYSLIST(42),                 $\n               &SYSLIST(43),&SYSLIST(44),&SYSLIST(45),                 $\n               &SYSLIST(46),&SYSLIST(47),&SYSLIST(48),                 $\n               &SYSLIST(49),&SYSLIST(50),&SYSLIST(51),                 $\n               F=&FTAG,S=&STAG,E=&CTR,B=1,L=&LOGIC,T=B\n.*--------------------------------------------------------------------*\n.* IF NO SPECIAL RESTORES OR AMODE CHANGES ARE NEEDED THEN GENERATE\n.* LEAVE CONDITION FAIL TAG AND EXIT MACRO.\n.*--------------------------------------------------------------------*\n         AIF   ('&LOGIC' EQ 'P').PRC8800\n&STAG    DS    0H                       LEAVE CONDITIONS MET\n         AGO   .PRC9000\n.PRC8800 ANOP\n&FTAG    DS    0H                       LEAVE NOT DONE\n         MEXIT\n.*--------------------------------------------------------------------*\n.* GENERATE SPECIAL RESTORES AND AMODE CHANGES.\n.*--------------------------------------------------------------------*\n.PRC9000 ANOP\n&CTR     SETA  &#BLVL\n.PRC9100 AIF   (&CTR LE &ENBLK).PRC9200\n         AIF   ('&#BSV1(&CTR)' EQ '').PRC9190\n         ##RST R15=NO,LVL=&CTR\n.PRC9190 ANOP\n&CTR     SETA  &CTR-1\n         AGO   .PRC9100\n.*--------------------------------------------------------------------*\n.*  IF OPTIONS XA AND AMODE OF THE ENCLOSING BLOCK IS DIFFERENT FROM\n.*  THE AMODE OF THE INNERMOST BLOCK AND (STRUCTURE IS NOT BLOCK\n.*  STRUCTURE) OR (STRUCTURE IS BLOCK STRUCTURE AND BLOCK CONTAINING\n.*  ENCLOSING BLOCK HAS THE SAME ADDRESS MODE AS THE ENCLOSING BLOCK)\n.*  THEN GENERATE AMODE CHANGE.\n.*--------------------------------------------------------------------*\n.PRC9200 AIF   (NOT &#PBXA).PRC9300\n         AIF   ('&#BAMODE(&#BLVL)' EQ '&#BAMODE(&ENBLK)').PRC9300\n         AIF   ('&STRUC' NE 'BLOCK').PRC9205\n         AIF   (&ENBLK LE 0).PRC9205\n         AIF   ('&#BAMODE(&ENBLK-1)' NE '&#BAMODE(&ENBLK)').PRC9300\n.*--------------------------------------------------------------------*\n.*  IF OPTIONS XA AND 370, GENERATE TEST FOR XA\n.*--------------------------------------------------------------------*\n.PRC9205 ANOP\n&TAG3    SETC  '#LV&#MNDX'\n         ##SWREG R15                    SAVE WORK REGISTER\n         AIF   (NOT &#PB370).PRC9210\n         L     R15,16                   POINT R15 TO CVT\n         TM    X'74'(R15),X'80'         RUNNING UNDER XA?\n         BZ    &TAG3                    SKIP AMODE SETTING\n.*--------------------------------------------------------------------*\n.*  GENERATE CHANGE CODE.\n.*--------------------------------------------------------------------*\n.PRC9210 ANOP\n         AIF   ('&#BAMODE(&ENBLK)' NE '31').PRC9220\n&TAG2    SETC  '#LW&#MNDX'\n         ICM   R15,B'1111',&TAG2        LOAD ADDR OF END OF STRUCTURE\n         BSM   0,R15                    SET NEW MODE\n&TAG2    DC    AL4(&TAG3+X'80000000')   AMODE 31\n         AGO   .PRC9290\n.PRC9220 LA    R15,&TAG3                LOAD ADDR OF END OF STRUCTURE\n.PRC9230 AIF   ('&#BAMODE(&ENBLK)' NE 'ANY').PRC9250\n         AIF   ('&#PBSMWA' NE '').PRC9240\n         MNOTE 8,'SMWA= keyword needs to be specified on program block $\n               macro'\n         AGO   .PRC9250\n.PRC9240 O     R15,&#PBSMWA+4           SET HIGH BIT TO AMODE AT ENTRY\n.PRC9250 BSM   0,R15                    SET NEW MODE\n.PRC9290 ANOP\n&TAG3    ##RWREG R15\n.PRC9300 ANOP\n         B     &TAG                     LEAVE STRUCTURE\n&FTAG    DS    0H                       LEAVE NOT DONE\n         MEXIT\n.*\n.* BRANCH TO LEAVE TAG.\n.PRC9800 ANOP\n         B     &TAG                     LEAVE STRUCTURE\n         MEXIT\n.ERR0001 MNOTE 8,'Only one keyword can be specified on LEAVE'\n         MEXIT\n.ERR0002 MNOTE 8,'Nesting level for &STRUC is zero'\n         MEXIT\n.ERR0003 MNOTE 8,'&NAME is not an active &STRUC name'\n         MEXIT\n.ERR0004 MNOTE 8,'One keyword must be specified on LEAVE'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOOP": {"ttr": 7690, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00W\\x00W\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 87, "newlines": 87, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         LOOP  &NAME=\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      LOOP\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - LOOP\n.*\n.*  PURPOSE    STRUCTURED MACRO USED TO START A LOOP STRUCTURE.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - NEW  MGG\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#MNDX                   LAST TAG INDEX USED\n         GBLA  &#MLVL                   STRUCTURAL LEVEL\n         GBLA  &#DMLVL(20)              STRUCTURAL LEVEL OF LOOP\n         GBLA  &#DLVL                   LOOP NEXTING LEVEL\n         GBLA  &#DNDX(20)               LOOP TAG INDEX\n         GBLC  &#DNAME(20)              LOOP NAMES\n         GBLC  &#DTYPE(20)              TYPE OF LOOP\n         LCLA  &CTR                     WORK COUNT\n         LCLC  &FTAG,&STAG,&TAG         FAIL TAG AND SUCCESS TAG\n&#MNDX   SETA  &#MNDX+1                 ADD ONE TO TAG INDEX\n         AIF   (&#DLVL GE 20).ERR0001\n&#DLVL   SETA  &#DLVL+1                 ADD ONE TO NESTING LEVEL\n&#MLVL   SETA  &#MLVL+1                 ADD ONE TO STRUCTURAL LEVEL\n&#DMLVL(&#DLVL) SETA  &#MLVL            SAVE STRUCTURAL LEVEL\n&#DNDX(&#DLVL)  SETA  &#MNDX            SET BLOCK TAG INDEX\n&#DNAME(&#DLVL) SETC '&NAME'            SAVE NAME\n&#DTYPE(&#DLVL) SETC '&SYSLIST(1)'      SAVE TYPE\n&TAG     SETC  '#DB&#MNDX'              SUCCESS TAG NAME\n         AIF   ('&SYSLIST(1)' NE 'WHILE').PRC2000\n&FTAG    SETC  '#DE&#MNDX'              FAIL TAG NAME (END OF LOOP)\n&STAG    SETC  '#DS&#MNDX'              SUCCESS TAG NAME\n&CTR     SETA  N'&SYSLIST-1             GET NUMBER OF POSITIONAL PARMS\n&TAG     ##COND &SYSLIST(2),                                           $\n               &SYSLIST(3),&SYSLIST(4),&SYSLIST(5),&SYSLIST(6),        $\n               &SYSLIST(7),&SYSLIST(8),&SYSLIST(9),&SYSLIST(10),       $\n               &SYSLIST(11),&SYSLIST(12),&SYSLIST(13),&SYSLIST(14),    $\n               &SYSLIST(15),&SYSLIST(16),&SYSLIST(17),&SYSLIST(18),    $\n               &SYSLIST(19),&SYSLIST(20),&SYSLIST(21),&SYSLIST(22),    $\n               &SYSLIST(23),&SYSLIST(24),&SYSLIST(25),&SYSLIST(26),    $\n               &SYSLIST(27),&SYSLIST(28),&SYSLIST(29),&SYSLIST(30),    $\n               &SYSLIST(31),&SYSLIST(32),&SYSLIST(33),                 $\n               &SYSLIST(34),&SYSLIST(35),&SYSLIST(36),                 $\n               &SYSLIST(37),&SYSLIST(38),&SYSLIST(39),                 $\n               &SYSLIST(40),&SYSLIST(41),&SYSLIST(42),                 $\n               &SYSLIST(43),&SYSLIST(44),&SYSLIST(45),                 $\n               &SYSLIST(46),&SYSLIST(47),&SYSLIST(48),                 $\n               &SYSLIST(49),&SYSLIST(50),&SYSLIST(51),&SYSLIST(52),    $\n               F=&FTAG,S=&STAG,E=&CTR,B=1,T=B\n&STAG    DS    0H                       START OF LOOP WHILE CODE\n         AGO   .EXIT\n.PRC2000 AIF   ('&SYSLIST(1)' NE 'UNTIL').PRC3000\n&TAG     DS    0H                       START OF LOOP UNTIL\n         AGO   .CHKONE\n.PRC3000 AIF   ('&SYSLIST(1)' NE 'BCT').PRC4000\n&TAG     DS    0H                       START OF LOOP BCT\n         AGO   .CHKONE\n.PRC4000 AIF   ('&SYSLIST(1)' NE 'BXH').PRC5000\n&FTAG    SETC  '&SYSLIST(2),&SYSLIST(3),#DE&#MNDX'\n&TAG     BXH   &FTAG                    START OF LOOP BXH\n         AIF   (N'&SYSLIST NE 3).ERR0002\n         AGO   .EXIT\n.PRC5000 AIF   ('&SYSLIST(1)' NE 'BXLE').ERR0003\n&TAG     DS    0H                       START OF LOOP BXLE\n         AGO   .EXIT\n.CHKONE  AIF   (N'&SYSLIST EQ 1).EXIT\n         MNOTE 8,'Additional positional parameters can not be specified$\n                on LOOP &SYSLIST(1)'\n         AGO   .EXIT\n.ERR0001 MNOTE 8,'LOOPs can only be nested 20 deep'\n         AGO   .EXIT\n.ERR0002 MNOTE 8,'Incorrect number of parameters specified for LOOP BXH$\n               '\n         AGO   .EXIT\n.ERR0003 MNOTE 8,'LOOP type &SYSLIST(1) is invalid'\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "L16": {"ttr": 7693, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00\\x1d\\x00\\x1d\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n&TAG     L16   &OP1,&OP2\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      L16\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - L16\n.*\n.*  PURPOSE    LOAD 16 BITS INTO A REGISTER RIGHT JUSTIFIED WITH\n.*             LEADING ZEROS AND SET CONDITION CODE.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - NEW  MGG\n.*\n.*--------------------------------------------------------------------*\n         AIF   (N'&SYSLIST NE 2).ERR0001\n&TAG     SLR   &OP1,&OP1                CLEAR REGISTER\n         ICM   &OP1,B'0011',&OP2        LOAD 16 BITS\n         MEXIT\n.ERR0001 MNOTE 8,'Invalid number of operands on L16 instruction'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "L24": {"ttr": 7695, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00\\x1d\\x00\\x1d\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n&TAG     L24   &OP1,&OP2\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      L24\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - L24\n.*\n.*  PURPOSE    LOAD 24 BITS INTO A REGISTER RIGHT JUSTIFIED WITH\n.*             LEADING ZEROS AND SET CONDITION CODE.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - NEW  MGG\n.*\n.*--------------------------------------------------------------------*\n         AIF   (N'&SYSLIST NE 2).ERR0001\n&TAG     SLR   &OP1,&OP1                CLEAR REGISTER\n         ICM   &OP1,B'0111',&OP2        LOAD 24 BITS\n         MEXIT\n.ERR0001 MNOTE 8,'Invalid number of operands on L24 instruction'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "L32": {"ttr": 7937, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00\\x1c\\x00\\x1c\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n&TAG     L32   &OP1,&OP2\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      L32\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - L32\n.*\n.*  PURPOSE    LOAD 32 BITS INTO A REGISTER AND SET CONDITON\n.*             CODE.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - NEW  MGG\n.*\n.*--------------------------------------------------------------------*\n         AIF   (N'&SYSLIST NE 2).ERR0001\n&TAG     ICM   &OP1,B'1111',&OP2        LOAD 32 BITS\n         MEXIT\n.ERR0001 MNOTE 8,'Invalid number of operands on L32 instruction'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "L8": {"ttr": 7939, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00\\x1d\\x00\\x1d\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n&TAG     L8    &OP1,&OP2\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      L8\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - L8\n.*\n.*  PURPOSE    LOAD 8 BITS INTO A REGISTER RIGHT JUSTIFIED WITH\n.*             LEADING ZEROS AND SET CONDITION CODE.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - NEW  MGG\n.*\n.*--------------------------------------------------------------------*\n         AIF   (N'&SYSLIST NE 2).ERR0001\n&TAG     SLR   &OP1,&OP1                CLEAR REGISTER\n         ICM   &OP1,B'0001',&OP2        LOAD 8 BITS\n         MEXIT\n.ERR0001 MNOTE 8,'Invalid number of operands on L8 instruction'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "OLDFILL": {"ttr": 7941, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00\\xb2\\x00\\xb2\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 178, "newlines": 178, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n&TAG     FILL  &PLACE,&CHAR,&LENGTH=(,S)\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      FILL\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - FILL\n.*\n.*  PURPOSE    MACRO USED TO FILL AN AREA OF STORAGE WITH A CHARACTER.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - NEW  JCB\n.*              7/14/85 - DEFINE &LVALID\n.*              2/03/86 - CHANGED USE OF L',                        @C2\n.*                        ADDED 'XC' FOR SHORT FILLS FOR X'00'      @C3\n.*              1/18/88 - ADDED SUPPORT FOR SHORT 0(R1) FILLS       @C4\n.*\n.*--------------------------------------------------------------------*\n.*\n.*   FILL MACRO FILLS A CHARACTER STRING WITH A CHARACTER.\n.*\n.*  SYM FILL TAG \u00dd,LENGTH=((R)|EQUATE|NUMBER,S|M|L)\u00a8 \u00dd,CHAR|X'00'\u00a8\n.*        SMALL: 256 OR LESS\n.*        MEDIUM: 4095 OR LESS\n.*        LARGE: >4K\n.*      DEFAULTS: LENGTH=(L'TAG,S),CHAR=X'00'\n.*\n         LCLC  &C\n         LCLC  &REG\n         LCLC  &LEN\n         LCLB  &RFORM\n         LCLA  &L\n         LCLA  &I,&ISAVE                                            @C4\n         LCLC  &DEST1,&DEST2                                        @C4\n         LCLB  &LVALID                                              @C1\n         AIF   ('&TAG' EQ '').NOTAG\n&TAG     DS    0H\n.NOTAG   ANOP\n.*--------------------------------------------------------------------*\n.*  SET FILL CHARACTER OR DEFAULT IT TO X'00'\n.*--------------------------------------------------------------------*\n         AIF   ('&CHAR' EQ '').CHR0000\n&C       SETC  '&CHAR'                 SET FILL CHARACTER\n         AGO   .CHR0010\n.CHR0000 ANOP ,\n&C       SETC  'X''00'''               SET FILL CHARACTER\n.CHR0010 ANOP ,\n.*--------------------------------------------------------------------*\n.*  DETERMINE IF LENGTH SPECIFIED, AND IF IT'S A REGISTER\n.*--------------------------------------------------------------------*\n&RFORM   SETB  0                       SET REGFORM OFF\n&LVALID  SETB  0\n         AIF   ('&LENGTH(1)' NE '').LEN0000 NULL LENGTH? NO, .LEN0000\n&LEN     SETC  'L''&PLACE'             SET LCLC VAR. TO LENGTH\n&LVALID  SETB  1\n         AGO   .TYP0000                GO EXPAND 'SHORT'.\n.LEN0000 ANOP ,                        A 'LEN=' EXISTS.\n         AIF   ('&LENGTH(1)'(1,1) NE '(').NUM0000 (RNN) FORM, .REG0000\n.REG0000 ANOP\n&REG     SETC  '&LENGTH(1)'            SET 'REG' FOR INSTRUCTIONS\n&RFORM   SETB    1                    SET REG-FORM FLAG\n         AGO   .TYP0000             GO DETERMINE TYPE VALUE.\n.NUM0000 ANOP ,\n&LEN     SETC  '&LENGTH(1)'\n&LVALID  SETB  1\n.TYP0000 ANOP\n.*--------------------------------------------------------------------*\n.*  DETERMINE TYPE OF CALL: SHORT, MEDIUM OR LONG\n.*--------------------------------------------------------------------*\n         AIF   ('&LENGTH(2)' EQ '').SHO0000\n         AIF   ('&LENGTH(2)'(1,1) EQ 'L').LNG0000\n         AIF   ('&LENGTH(2)'(1,1) EQ 'M').MED0000\n         AIF   ('&LENGTH(2)'(1,1) NE 'S').LENERR\n.*--------------------------------------------------------------------*\n.*  SHORT FILL\n.*--------------------------------------------------------------------*\n.SHO0000 ANOP\n         AIF   (&RFORM).SHX0000\n         AIF   ('&C' NE 'X''00''' AND '&C' NE '0').SHO0010\n         XC    &PLACE.(&LEN),&PLACE  USE XC TO ZERO OUT STRING     @C3\n         AGO   .FILLXIT\n.*--------------------------------------------------------------------*\n.*  DETERMINE IF LENGTH IS OF THE FORM: DISP(REG) (E.G 0(R1))\n.*--------------------------------------------------------------------*\n.SHO0010 ANOP  ,                                                    @C4\n&I       SETA  1                                                    @C4\n.SHO0020 AIF   ('&PLACE'(&I,1) EQ '(').SHO0030                      @C4\n&I       SETA  &I+1                                                 @C4\n         AIF   (&I LE K'&PLACE).SHO0020                             @C4\n         AGO   .SHO0100                                             @C4\n.*--------------------------------------------------------------------*\n.*  POINTER TO AREA TO FILL IS OF FORM: DISP(REG). MAKE SURE A LENGTH\n.*  WAS PROVIDED (L'TAG IS NO GOOD HERE), THEN PICK THE ADDRESS APART.\n.*--------------------------------------------------------------------*\n.SHO0030 AIF   ('&LENGTH(1)' NE '').SHO0040                         @C4\n         MNOTE 8,'LENGTH FOR FILL REQUIRED BUT NOT SPECIFIED'       @C4\n         AGO   .FILLXIT                                             @C4\n.SHO0040 ANOP                                                       @C4\n&DEST1   SETC  '&PLACE'(1,&I-1)                                     @C4\n&ISAVE   SETA  &I+1                                                 @C4\n.SHO0050 AIF   ('&PLACE'(&I,1) EQ ')').SHO0060                      @C4\n&I       SETA  &I+1                                                 @C4\n         AIF   (&I LE K'&PLACE).SHO0050                             @C4\n         MNOTE 8,'UNABLE TO PARSE FILL DESTINATION'                 @C4\n         AGO   .FILLXIT                                             @C4\n.SHO0060 ANOP  ,                                                    @C4\n&I       SETA  &I-&ISAVE                                            @C4\n&DEST2   SETC  '&PLACE'(&ISAVE,&I)                                  @C4\n&LEN     SETC  '&LENGTH(1)'                                         @C4\n         MVI   &PLACE,&C            MOVE INITIAL FILL BYTE          @C4\n         MVC   1+&DEST1.(&LEN.-1,&DEST2.),&PLACE                    @C4\n         AGO   .FILLXIT                                             @C4\n.*--------------------------------------------------------------------*\n.*  STANDARD SHORT FILL\n.*--------------------------------------------------------------------*\n.SHO0100 MVI   &PLACE.,&C.          MOVE INITIAL FILL BYTE\n         MVC   1+&PLACE.(&LEN.-1),&PLACE  COPY THROUGH FIELD\n         AGO   .FILLXIT\n.SHX0000 AIF   ('&PLACE'(1,1) EQ '(').SHXREG0\n         BCTR  &REG.,0              DECREMENT LENGTH REGISTER\n         AIF   ('&C' NE 'X''00''' AND '&C' NE '0').SHX0010\n         BCTR  &REG.,0                TWICE\n         MVI   &PLACE.,&C.          MOVE INITIAL FILL BYTE\n.*       EX    &REG.,*+8            EXECUTE THE MOVE\n.*       B     *+10                 SKIP EXECUTED MOVE\n.*       MVC   1+&PLACE.(0),&PLACE. ** EXECUTED **\n         EXI   &REG,(MVC,1+&PLACE.(0),&PLACE)\n         LA    &REG.,2(,&REG.)      RESTORE LENGTH REGISTER\n         AGO   .FILLXIT\n.SHX0010 EXI   &REG,(XC,&PLACE.(0),&PLACE)\n         LA    &REG.,1(,&REG.)      RESTORE LENGTH REGISTER\n         AGO   .FILLXIT\n.SHXREG0 ANOP\n         BCTR  &REG.,0              DECREMENT LENGTH REGISTER\n         AIF   ('&C' NE 'X''00''' AND '&C' NE '0').SHXREG1\n         BCTR  &REG.,0                TWICE\n         MVI   0&PLACE.,&C.         MOVE INITIAL FILL BYTE\n.*       EX    &REG.,*+8            EXECUTE THE MOVE\n.*       B     *+10                 SKIP EXECUTED MOVE\n.*       MVC   1(0,&PLACE.),0&PLACE ** EXECUTED **\n         EXI   &REG,(MVC,1(0,&PLACE),0(&PLACE))\n         LA    &REG.,2(,&REG.)      RESTORE LENGTH REGISTER\n         AGO   .FILLXIT\n.SHXREG1 EXI   &REG,(XC,0(0,&PLACE),0(&PLACE))\n         LA    &REG.,1(,&REG.)      RESTORE LENGTH REGISTER\n         AGO   .FILLXIT\n.MED0000 ANOP  ,                    GENERATE MEDIUM-LENGTH FILL\n         AIF   (&RFORM).LNG0000     LONGFORM, SAME DIFFERENCE\n         AIF   (&LVALID).MED0010\n         LA    15,&LENGTH(1)           GET LENGTH VALUE\n         AGO   .MVL0000             GO DO MOVE-LONG CODE\n.MED0010 ANOP ,\n         LA    15,&LEN              GET LENGTH VALUE                @C2\n         AGO   .MVL0000\n.LNG0000 ANOP ,\n         AIF   (&RFORM).LNG0010\n         MNOTE 8,'LONG-FORM FILL REQUIRES R-FORM LENGTH'\n         AGO   .FILLXIT\n.LNG0010 ANOP ,\n         LR    15,&REG.             GET LENGTH OF FILL AREA\n.MVL0000 ANOP ,\n         LA    14,&PLACE.           GET DESTINATION ADDRESS\n         SLR   0,0                  NO SOURCE ADDRESS\n         LA    1,&C.                LOAD FILL CHARACTER\n         SLL   1,24                 SHIFT TO HIGH-ORDER BYTE\n         MVCL  14,0                 PROPAGATE FILL CHARACTER.\n.FILLXIT MEXIT\n.LENERR  MNOTE 8,'FILL OPERATION TYPE INVALID: MUST BE S)HORT, M)EDIUM,*\n                OR L)ONG.'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OLDPPDC": {"ttr": 7945, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x02\\xa6\\x02\\xa6\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 678, "newlines": 678, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         ##PPDC &NAME,                  NAME OF BLOCK                  $\n               &OPTIONS,                OPTIONS                        $\n               &SDID,                   STATIC GENERATED TAG PREFIX    $\n               &WAID,                   PWA GENERATED TAG PREFIX       $\n               &SUBOPTS,                DEFAULT SUBROUTINE OPTIONS     $\n               &BASEREG,                BASE REGS                      $\n               &PWAREG,                 PWA REGS                       $\n               &SVAREA,                 SAVE AREA TAG NAME             $\n               &CPYRGHT,                COPYRIGHT NOTICE               $\n               &AMODE,                  ADDRESSING MODE                $\n               &RMODE,                  RESIDENCE MODE                 $\n               &R1SAVE,                 PARM SAVE REGISTER             $\n               &SMWA,                   STRUCTURED MACRO WORK AREA     $\n               &DYNSIZE,                SIZE OF DYNAMIC STORAGE        $\n               &DYNERR,                 DYNAMIC STORAGE ERROR EXIT     $\n               &SWAREG,                 SWA BASE REGS                  $\n               &PWASP                   PROGRAM WORK AREA SUB POOL\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1986.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      ##PPDC\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - ##PPDC\n.*\n.*  PURPOSE    INTERNAL MACRO USED AS THE DEFAULT FOR PROGRAM BLOCK\n.*             PROLOG.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   12/30/86 JCB - NEW, MODELED AFTER ##PPMAC\n.*             08/04/87 JCB - ADDED MISSING AIF FOR SMWA= CHECK    @C1\n.*             09/14/87 JCB - RELEASED R13 IF USER MODE PROGRAM    @C2\n.*\n.*--------------------------------------------------------------------*\n.*  PROGRAM BLOCK OPTIONS SUPPORTED BY ##PPDC:\n.*      CSECT    - CAUSES CSECT TO BE GENERATED BY #MOPT\n.*      ID       - CAUSES ID TO BE GENERATED IN PROLOG\n.*      LOCTR    - STANDARD LOCTR OPTION\n.*      LONG     - STANDARD LONG OPTION\n.*      MODE     - STANDARD MODE OPTION\n.*      PWA      - ENABLES PWA GENERATION: WITH RENT, CAUSES #GETSTG\n.*      REGEQU   - CAUSES #REGEQU TO BE GENERATED BY #MOPT\n.*      RENT     - CAUSES REENTRANT LINKAGE (USED ONLY WITH PWA)\n.*      VL       - MAKES PLIST MACRO USE VL OPTION\n.*      XA       - USES XA INSTRUCTIONS FOR LINKAGE IF ASM'D ON XA\n.*      370      - USES 370 INSTRUCTIONS FOR LINKAGE IF ASM'D ON 370\n.* <DC> DCMACPRT - #MOPT MACPRNT=YES OR =NO\n.* <DC> DCPRGPRT - #MOPT PRGPRNT=YES OR =NO\n.* <DC> SYSTEM OR (SYSTEM,<MODULE#>) - #MOPT ENV=SYS AND OPT'L MODULE#\n.* <DC> #START   - GENERATE #START. ONLY VALID WITH SYSTEM\n.* <DC> #RTN     - GENERATE #RTN. ONLY VALID WITH SYSTEM\n.* <DC> #RETURN  - GENERATE #RETURN. ONLY VALID WITH NOSYSTEM\n.* <DC> GETSTK   - GENERATE #GETSTK INSTEAD OF #GETSTG. VALID ONLY\n.*                 WITH SYSTEM AND PWA OPTIONS\n.* <DC> (NXTTASK,<TASKCODE>) - #RETURN NXTTASK=. ONLY VALID W/NOSYSTEM\n.* <DC> (TYPE,<RTNTYPE>)     - #RETURN TYPE=.    ONLY VALID W/NOSYSTEM\n.* <DC> (RESINT,<INTERVAL>)  - #RETURN RESINT=.  ONLY VALID W/NOSYSTEM\n.* <DC> (RESPGM,<PGMNAME>)   - #RETURN RESPGM=.  ONLY VALID W/NOSYSTEM\n.* <DC> (EP,<ENTRYPOINT>)    - #START EP=.       ONLY VALID W/SYSTEM\n.*\n.*  SUPER OPTIONS SUPPORTED BY ##PBDC:\n.*      *PWA     - CSECT,ID,LOCTR,MODE,PWA,REGEQU,RENT,VL,\n.*                 #RETURN\n.*      *PWASYS  - CSECT,ID,LOCTR,MODE,PWA,REGEQU,RENT,VL,\n.*                 #START,#RTN,SYSTEM\n.*      *RENT    - CSECT,ID,LOCTR,MODE,REGEQU,RENT,VL,#RETURN\n.*      *RENTSYS - CSECT,ID,LOCTR,MODE,REGEQU,RENT,VL,#START,#RTN,\n.*                 SYSTEM\n.*      *NORENT  - CSECT,ID,LOCTR,MODE,REGEQU,VL,#RETURN\n.*      *NORENTSYS - CSECT,ID,LOCTR,MODE,REGEQU,VL,#START,#RTN,\n.*                 SYSTEM\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#MNDX                   LAST TAG INDEX USED\n         GBLA  &#MLVL                   CURRENT STRUCTURAL LEVEL\n         GBLA  &#MCVREG                 CONVERTED REG (SEE ##CVREG)\n         GBLB  &##ASMH                  ##ASMH MACRO RETURN FLAG\n         GBLA  &#BLVL                   BLOCK LEVEL\n         GBLA  &#BNDX(20)               BLOCK TAG INDEXS\n         GBLA  &#BMLVL(20)              BLOCK STRUCTURAL LEVEL\n         GBLC  &#BNAME(20)              BLOCK NAMES\n         GBLC  &#BTYPE(20)              BLOCK TYPE\n         GBLC  &#BAMODE(20)             ADDRESSING MODE OF BLOCK\n         GBLC  &#BSV1(20)               BLOCK SAVE PARM 1\n         GBLC  &#BSV2(20)               BLOCK SAVE PARM 2\n         GBLC  &#BSV3(20)               BLOCK SAVE PARM 3\n         GBLA  &#PBNDX                  PROGRAM BLOCK INDEX\n         GBLC  &#PBNAME                 PROGRAM BLOCK NAME\n         GBLB  &#PBVL                   DEFAULT VL OPTION\n         GBLB  &#PBXA                   XA OPTION\n         GBLB  &#PB370                  370 OPTION\n         GBLC  &#PBRMOD                 RMODE OF PROGRAM\n         GBLC  &#PBAMOD                 AMODE OF PROGRAM\n         GBLC  &#PBSMWA                 TAG OF SMWA\n         GBLB  &#XAWARN                 XA WARNING MESSAGE ISSUED\n         GBLA  &#PB#C                   PROGRAM BLOCK NUMBER\n         GBLB  &#PBLONG                 LONG PROGRAM OPTION\n         GBLA  &#PBWAMX                 MAX SMWA IN PROGRAM\n         GBLB  &#PBLOCR                 DO LOCATR IN PROGRAM\n         GBLB  &#PBPWA                  PWA OPTION\n         GBLB  &#PBDSWA       ENDPWA SHOULD DEFINE STORAGE FOR PWA\n         GBLB  &#PBRTN0                 ENABLE RETURN_R0\n         GBLB  &#PBRTN1                 ENABLE RETURN_R1\n.*       GBLC  &#PBPWAT                 PWA TAG\n.*       GBLC  &#PBPWAL                 PWA LENGTH TAG\n         GBLC  &#PBWAID                 GENERATED TAG OF PWA\n         GBLC  &#PBSDID                 GENERATED TAG OF PSD\n         GBLB  &#DC#RTN             DC: #RTN SHOULD BE GEN'D\n         GBLB  &#DC#RET             DC: #RETURN SHOULD BE GEN'D\n         GBLB  &#DCSYS              DC: SYSTEM MODE REQUESTED\n         GBLC  &#DCNTSK             DC: NXTTASK= FOR #RETURN\n         GBLC  &#DCRTYP             DC: TYPE= FOR #RETURN\n         GBLC  &#DCRINT             DC: RESINT= FOR #RETURN\n         GBLC  &#DCRPGM             DC: RESPGM= FOR #RETURN\n         GBLB  &#DCRENT             DC: RENT OPTION\n         GBLC  &#DCPWAR             DC: 1ST PWA REGISTER (FOR #FREESTG)\n         GBLB  &#DCGSTK             DC: #GETSTK USED TO GET PWA\n         LCLB  &REGS(16)                REGISTERS USED\n         LCLB  &OID                     ID OPTION\n         LCLB  &OCSECT                  CSECT OPTION\n         LCLB  &OREGEQU                 REGEQU OPTION\n         LCLB  &OMODE                   MODE OPTION\n         LCLB  &ODCMACP                 #MOPT W/MACPRNT=YES\n         LCLB  &ODCPRGP                 #MOPT W/PRGPRNT=YES\n         LCLB  &#DC#STR             DC: #START SHOULD BE GENERATED\n         LCLA  &CTR                     WORK COUNTER\n         LCLC  &OPT,&TAG,&TAG1,&TAG2,&TAG3 WORK FIELDS\n         LCLC  &TAG4                    WORK TAG\n         LCLC  &ZENVIR\n         LCLC  &ZREGEQU\n         LCLC  &ZDCMACP\n         LCLC  &ZDCPRGP\n         LCLC  &ZMODNO\n         LCLC  &ZGINIT\n         LCLC  &ZGLOC\n         LCLA  &NDX                     #MNDX FOR BLOCK\n         LCLC  &EP\n.*====================================================================*\n&NDX     SETA  &#MNDX                   SET INDEX FOR BLOCK\n         ##MREG RESET                   RESET REGISTERS\n&#PBPWA  SETB  0                        CLEAR FLAGS\n&#PBXA   SETB  0\n&#PBDSWA SETB  0\n&#PB370  SETB  0\n&#PBVL   SETB  0\n&#PBLONG SETB  0\n&#PBLOCR SETB  0\n&#PBRMOD SETC  '&RMODE'\n&#PBAMOD SETC  '&AMODE'\n&#PBSMWA SETC  '&SMWA'\n&#BAMODE(1) SETC  '&AMODE'\n&#DC#STR SETB  0\n&#DC#RTN SETB  0\n&#DC#RET SETB  0\n&#DCSYS  SETB  0\n&#DCGSTK SETB  0\n&#DCNTSK SETC  ''\n&#DCRTYP SETC  ''\n&#DCRINT SETC  ''\n&#DCRPGM SETC  ''\n&EP      SETC  ''\n&ODCMACP SETB  0\n&ODCPRGP SETB  0\n.*--------------------------------------------------------------------*\n.*  CHECK FOR IGNORED KEYWORDS\n.*--------------------------------------------------------------------*\n         ##IGMSG &DYNSIZE,DYNSIZE\n         ##IGMSG &DYNERR,DYNERR\n         ##IGMSG &SVAREA,SVAREA\n         ##IGMSG &PWASP,PWASP\n         ##IGMSG &SDID,SDID\n         ##IGMSG &WAID,WAID\n.*--------------------------------------------------------------------*\n.*  SET OPTIONS FOR TYPE=PROGRAM\n.*--------------------------------------------------------------------*\n&CTR     SETA  1                        SET OPTIONS\n.SPO0010 AIF   (N'&OPTIONS LT &CTR).SPO9999\n&OPT     SETC  '&OPTIONS(&CTR)'\n.SPO0020 AIF   ('&OPT' NE 'PWA').SPO0030           PWA\n&#PBPWA  SETB  1\n         AGO   .SPO9000\n.SPO0030 AIF   ('&OPT' NE 'NOPWA').SPO0100         NOPWA\n&#PBPWA  SETB  0\n         AGO   .SPO9000\n.SPO0100 AIF   ('&OPT' NE 'RENT').SPO0110          RENT\n&#DCRENT SETB  1\n         AGO   .SPO9000\n.SPO0110 AIF   ('&OPT' NE 'NORENT').SPO0120        NORENT\n&#DCRENT SETB  0\n         AGO   .SPO9000\n.SPO0120 AIF   ('&OPT' NE 'ID').SPO0130            ID\n&OID     SETB  1\n         AGO   .SPO9000\n.SPO0130 AIF   ('&OPT' NE 'NOID').SPO0140          NOID\n&OID     SETB  0\n         AGO   .SPO9000\n.SPO0140 AIF   ('&OPT' NE 'REGEQU').SPO0150        REGEQU\n&OREGEQU SETB  1\n         AGO   .SPO9000\n.SPO0150 AIF   ('&OPT' NE 'NOREGEQU').SPO0160      NOREGEQU\n&OREGEQU SETB  0\n         AGO   .SPO9000\n.SPO0160 AIF   ('&OPT' NE 'CSECT').SPO0170         CSECT\n&OCSECT  SETB  1\n         AGO   .SPO9000\n.SPO0170 AIF   ('&OPT' NE 'NOCSECT').SPO0200       NOCSECT\n&OCSECT  SETB  0\n         AGO   .SPO9000\n.SPO0200 AIF   ('&OPT' NE '*RENT').SPO0205         SUPER *RENT\n&#PBPWA  SETB  0         NOPWA OPTION\n&#DC#RET SETB  1         #RETURN OPTION\n&#DCRENT SETB  1         RENT OPTION\n&OID     SETB  1         ID OPTION\n&OCSECT  SETB  1         CSECT OPTION\n&OREGEQU SETB  1         REGEQU OPTION\n&OMODE   SETB  1         MODE OPTION\n&#PBXA   SETB  0         NOXA OPTION\n&#PB370  SETB  0         NO370 OPTION\n&#PBVL   SETB  1         VL OPTION\n&#PBLOCR SETB  1         LOCTR OPTION\n&#PBLONG SETB  0         NOLONG OPTION\n         AGO   .SPO9000\n.SPO0205 AIF   ('&OPT' NE '*RENTSYS').SPO0210      SUPER *RENTSYS\n&#PBPWA  SETB  0         NOPWA OPTION\n&#DC#STR SETB  1         #START OPTION\n&#DC#RTN SETB  1         #RTN OPTION\n&#DCRENT SETB  1         RENT OPTION\n&OID     SETB  1         ID OPTION\n&OCSECT  SETB  1         CSECT OPTION\n&OREGEQU SETB  1         REGEQU OPTION\n&OMODE   SETB  1         MODE OPTION\n&#PBXA   SETB  0         NOXA OPTION\n&#PB370  SETB  0         NO370 OPTION\n&#PBVL   SETB  1         VL OPTION\n&#PBLOCR SETB  1         LOCTR OPTION\n&#PBLONG SETB  0         NOLONG OPTION\n&#DCSYS  SETB  1         SYSTEM OPTION\n         AGO   .SPO9000\n.SPO0210 AIF   ('&OPT' NE '*PWA').SPO0215          SUPER *PWA\n&#PBPWA  SETB  1         PWA OPTION\n&#DC#RET SETB  1         #RETURN OPTION\n&#DCRENT SETB  1         RENT OPTION\n&OID     SETB  1         ID OPTION\n&OCSECT  SETB  1         CSECT OPTION\n&OREGEQU SETB  1         REGEQU OPTION\n&OMODE   SETB  1         MODE OPTION\n&#PBXA   SETB  0         NOXA OPTION\n&#PB370  SETB  0         NO370 OPTION\n&#PBVL   SETB  1         VL OPTION\n&#PBLOCR SETB  1         LOCTR OPTION\n&#PBLONG SETB  0         NOLONG OPTION\n         AGO   .SPO9000\n.SPO0215 AIF   ('&OPT' NE '*PWASYS').SPO0220       SUPER *PWASYS\n&#PBPWA  SETB  1         PWA OPTION\n&#DC#STR SETB  1         #START OPTION\n&#DC#RTN SETB  1         #RTN OPTION\n&#DCRENT SETB  1         RENT OPTION\n&OID     SETB  1         ID OPTION\n&OCSECT  SETB  1         CSECT OPTION\n&OREGEQU SETB  1         REGEQU OPTION\n&OMODE   SETB  1         MODE OPTION\n&#PBXA   SETB  0         NOXA OPTION\n&#PB370  SETB  0         NO370 OPTION\n&#PBVL   SETB  1         VL OPTION\n&#PBLOCR SETB  1         LOCTR OPTION\n&#PBLONG SETB  0         NOLONG OPTION\n&#DCSYS  SETB  1         SYSTEM OPTION\n         AGO   .SPO9000\n.SPO0220 AIF   ('&OPT' NE '*NORENT').SPO0225       SUPER *NORENT\n&#PBPWA  SETB  0         NOPWA OPTION\n&#DC#RET SETB  1         #RETURN OPTION\n&#DCRENT SETB  0         NORENT OPTION\n&OID     SETB  1         ID OPTION\n&OCSECT  SETB  1         CSECT OPTION\n&OREGEQU SETB  1         REGEQU OPTION\n&OMODE   SETB  1         MODE OPTION\n&#PBXA   SETB  0         NOXA OPTION\n&#PB370  SETB  0         NO370 OPTION\n&#PBVL   SETB  1         VL OPTION\n&#PBLOCR SETB  1         LOCTR OPTION\n&#PBLONG SETB  0         NOLONG OPTION\n         AGO   .SPO9000\n.SPO0225 AIF   ('&OPT' NE '*NORENTSYS').SPO0230    SUPER *NORENTSYS\n&#PBPWA  SETB  0         NOPWA OPTION\n&#DC#STR SETB  1         #START OPTION\n&#DC#RTN SETB  1         #RTN OPTION\n&#DCRENT SETB  0         NORENT OPTION\n&OID     SETB  1         ID OPTION\n&OCSECT  SETB  1         CSECT OPTION\n&OREGEQU SETB  1         REGEQU OPTION\n&OMODE   SETB  1         MODE OPTION\n&#PBXA   SETB  0         NOXA OPTION\n&#PB370  SETB  0         NO370 OPTION\n&#PBVL   SETB  1         VL OPTION\n&#PBLOCR SETB  1         LOCTR OPTION\n&#PBLONG SETB  0         NOLONG OPTION\n&#DCSYS  SETB  1         SYSTEM OPTION\n         AGO   .SPO9000\n.SPO0230 AIF   ('&OPT' NE 'MODE').SPO0240          MODE\n&OMODE   SETB  1\n         AGO   .SPO9000\n.SPO0240 AIF   ('&OPT' NE 'NOMODE').SPO0250        NOMODE\n&OMODE   SETB  0\n         AGO   .SPO9000\n.SPO0250 AIF   ('&OPT' NE 'XA').SPO0260            XA\n&#PBXA   SETB  1\n         AGO   .SPO9000\n.SPO0260 AIF   ('&OPT' NE 'NOXA').SPO0270          NOXA\n&#PBXA   SETB  0\n         AGO   .SPO9000\n.SPO0270 AIF   ('&OPT' NE '370').SPO0280           370\n&#PB370  SETB  1\n         AGO   .SPO9000\n.SPO0280 AIF   ('&OPT' NE 'NO370').SPO0290         NO370\n&#PB370  SETB  0\n         AGO   .SPO9000\n.SPO0290 AIF   ('&OPT' NE 'VL').SPO0300            VL\n&#PBVL   SETB  1\n         AGO   .SPO9000\n.SPO0300 AIF   ('&OPT' NE 'NOVL').SPO0390          NOVL\n&#PBVL   SETB  0\n         AGO   .SPO9000\n.SPO0390 AIF   ('&OPT' NE 'LOCTR').SPO0400         LOCTR\n&#PBLOCR SETB  1\n         AGO   .SPO9000\n.SPO0400 AIF   ('&OPT' NE 'NOLOCTR').SPO0410       NOLOCTR\n&#PBLOCR SETB  0\n         AGO   .SPO9000\n.SPO0410 AIF   ('&OPT' NE 'LONG').SPO0420          LONG\n&#PBLONG SETB  1\n         AGO   .SPO9000\n.SPO0420 AIF   ('&OPT' NE 'NOLONG').SPO0490        NOLONG\n&#PBLONG SETB  0\n         AGO   .SPO9000\n.*------------------------------------------------------------------\n.*  IDMS/DC SPECIFIC OPTIONS\n.*------------------------------------------------------------------\n.SPO0490 AIF   ('&OPT' NE 'DCMACPRT').SPO0500      DCMACPRT\n&ODCMACP SETB  1\n         AGO   .SPO9000\n.SPO0500 AIF   ('&OPT' NE 'NODCMACPRT').SPO0510    NODCMACPRT\n&ODCMACP SETB  0\n         AGO   .SPO9000\n.SPO0510 AIF   ('&OPT' NE 'DCPRGPRT').SPO0520      DCPRGPRT\n&ODCPRGP SETB  1\n         AGO   .SPO9000\n.SPO0520 AIF   ('&OPT' NE 'NODCPRGPRT').SPO0530    NODCPRGPRT\n&ODCPRGP SETB  0\n         AGO   .SPO9000\n.SPO0530 AIF   ('&OPT' NE '#START').SPO0540        #START\n&#DC#STR SETB  1\n         AGO   .SPO9000\n.SPO0540 AIF   ('&OPT' NE 'NO#START').SPO0550      NO#START\n&#DC#STR SETB  0\n         AGO   .SPO9000\n.SPO0550 AIF   ('&OPT' NE '#RTN').SPO0560          #RTN\n&#DC#RTN SETB  1\n         AGO   .SPO9000\n.SPO0560 AIF   ('&OPT' NE 'NO#RTN').SPO0570        NO#RTN\n&#DC#RTN SETB  0\n         AGO   .SPO9000\n.SPO0570 AIF   ('&OPT' NE '#RETURN').SPO0580       #RETURN\n&#DC#RET SETB  1\n         AGO   .SPO9000\n.SPO0580 AIF   ('&OPT' NE 'NO#RETURN').SPO0590     NO#RETURN\n&#DC#RET SETB  0\n         AGO   .SPO9000\n.SPO0590 AIF   ('&OPT' NE 'SYSTEM').SPO0600        SYSTEM OR\n&#DCSYS  SETB  1                                     (SYSTEM,MODULE#)\n         AIF   (N'&OPT EQ 1).SPO0595\n&ZMODNO  SETC  '&OPT(2)'\n         AGO   .SPO9000\n.SPO0595 ANOP\n&ZMODNO  SETC   '0'\n         AGO   .SPO9000\n.SPO0600 AIF   ('&OPT' NE 'NOSYSTEM').SPO0610      NOSYSTEM\n&#DCSYS  SETB  0\n         AGO   .SPO9000\n.SPO0605 ANOP\n&ZMODNO  SETC   '0'\n         AGO   .SPO9000\n.SPO0610 AIF   ('&OPT' NE 'GETSTK').SPO0615       GETSTK\n&#DCGSTK SETB  1\n         AGO   .SPO9000\n.SPO0615 AIF   ('&OPT' NE 'NOGETSTK').SPO0620     NOGETSTK\n&#DCGSTK SETB  0\n         AGO   .SPO9000\n.SPO0620 AIF   ('&OPT' NE 'RTNR0').SPO0625        RTNR0\n&#PBRTN0 SETB  1\n         AGO   .SPO9000\n.SPO0625 AIF   ('&OPT' NE 'NORTNR0').SPO0630      NORTNR0\n&#PBRTN0 SETB  0\n         AGO   .SPO9000\n.SPO0630 AIF   ('&OPT' NE 'RTNR1').SPO0635        RTNR1\n&#PBRTN1 SETB  1\n         AGO   .SPO9000\n.SPO0635 AIF   ('&OPT' NE 'NORTNR1').SPO0800      NORTNR1\n&#PBRTN1 SETB  0\n         AGO   .SPO9000\n.*------------------------------------------------------------------\n.*  SUBSCRIPTED OPTIONS: FIRST, PARSE OPTION STRINGS\n.*------------------------------------------------------------------\n.SPO0800 AIF   ('&OPT'(1,1) NE '(').SPO1000\n&CTR     SETA  2\n&TAG     SETC  ''\n.SPO0810 AIF   ('&OPT'(&CTR,1) EQ ',').SPO0820\n         AIF   ('&OPT'(&CTR,1) EQ ')').SPO5000\n&TAG3    SETC  '&OPT'(&CTR,1)\n&TAG     SETC  '&TAG&TAG3'\n&CTR     SETA  &CTR+1\n         AGO   .SPO0810\n.SPO0820 ANOP\n&CTR     SETA  &CTR+1\n&TAG2    SETC  ''\n.SPO0830 AIF   ('&OPT'(&CTR,1) EQ ')').SPO0900\n         AIF   ('&OPT'(&CTR,1) EQ ',').SPO5000\n&TAG3    SETC  '&OPT'(&CTR,1)\n&TAG2    SETC  '&TAG2&TAG3'\n&CTR     SETA  &CTR+1\n         AGO   .SPO0830\n.*------------------------------------------------------------------\n.*  PROCESS SUBSCRIPTED OPTIONS\n.*------------------------------------------------------------------\n.SPO0900 ANOP\n         AIF   ('&TAG' NE 'NXTTASK').SPO0910    (NXTTASK,ADDRESS)\n&#DCNTSK SETC  '&TAG2'\n         AGO   .SPO9000\n.SPO0910 AIF   ('&TAG' NE 'TYPE').SPO0920       (TYPE,RTNTYPE)\n&#DCRTYP SETC  '&TAG2'\n         AGO   .SPO9000\n.SPO0920 AIF   ('&TAG' NE 'RESINT').SPO0930     (RESINT,INTERVAL)\n&#DCRINT SETC  '&TAG2'\n         AGO   .SPO9000\n.SPO0930 AIF   ('&TAG' NE 'RESPGM').SPO0940     (RESPGM,PGMNAME)\n&#DCRPGM SETC  '&TAG2'\n         AGO   .SPO9000\n.SPO0940 AIF   ('&TAG' NE 'EP').SPO1000\n&EP      SETC   '&TAG2'\n         AGO   .SPO9000\n.SPO1000 ANOP  ,                                ADD'L OPTIONS HERE\n.SPO5000 MNOTE 8,'INVALID OPTION &OPT'\n.SPO9000 ANOP\n&CTR     SETA  &CTR+1\n         AGO   .SPO0010\n.SPO9999 ANOP\n.*------------------------------------------------------------------\n.*  SET DEFAULT SUBROUTINE OPTIONS BASED ON SUBOPT\n.*------------------------------------------------------------------\n         ##SUBOPT &SUBOPTS,DEFAULT=YES\n.*------------------------------------------------------------------\n.*  CHECK OPTIONS\n.*------------------------------------------------------------------\n&#PBSDID SETC  '#U&#PB#C'\n         AIF   ('&#PBSMWA' NE '' OR NOT &#PBPWA).COP0050            @C1\n&#PBWAMX SETA  2\n&#PBSMWA SETC  '#PBW&#PB#C'\n.COP0050 AIF   (NOT &#PBLOCR).COP0060\n         ##ASMH ((A))\n         AIF   (&##ASMH).COP0060\n         MNOTE 8,'ASSEMBLER H REQUIRED FOR LOCTR OPTION'\n.* .COP0060 AIF   ('&#BNAME(&#BLVL)' EQ '').ERR0003\n.COP0060 AIF   (NOT &#DCSYS).NSYS000\n.*--------------------------------------------------------------------*\n.*  OPTIONS NOT ALLOWED WITH SYSTEM MODE\n.*--------------------------------------------------------------------*\n         AIF   (&#DC#RET).ERR0012\n         AIF   ('&#DCNTSK' NE '' OR '&#DCRTYP' NE '').ERR0010\n         AIF   ('&#DCRINT' NE '' OR '&#DCRPGM' NE '').ERR0010\n         AGO   .COP0070\n.*--------------------------------------------------------------------*\n.*  OPTIONS NOT ALLOWED WITH NOSYSTEM MODE\n.*--------------------------------------------------------------------*\n.NSYS000 AIF   (&#DC#STR OR &#DC#RTN).ERR0011\n         AIF   ('&EP' NE '').ERR0013\n         AIF   (&#DCGSTK).ERR0015\n.COP0070 AIF   (&#DCGSTK AND NOT &#PBPWA).ERR0016\n.*--------------------------------------------------------------------*\n.*  GENERATE CSECT, AMODE, AND RMODE CARDS\n.*--------------------------------------------------------------------*\n.CAR0100 AIF   ('&AMODE' EQ '' AND '&RMODE' EQ '').CAR0200\n         AIF   (&OMODE).CAR0110\n         MNOTE 4,'RMODE AND AMODE IGNORED IF MODE OPTION NOT SPECIFIED'\n         AGO   .CAR0200\n.CAR0110 AIF   (&#PBXA).CAR0120\n         MNOTE 4,'RMODE AND AMODE IGNORED IF XA OPTION NOT SPECIFIED'\n         AGO   .CAR0200\n.CAR0120 AIF   ('&AMODE' EQ '' AND '&RMODE' EQ '').CAR0200  DEFAULTS\n         AIF   ('&RMODE' EQ 'ANY' AND '&AMODE' EQ '24').ERR0014\n         AIF   ('&RMODE' EQ '').CAR0130\n&#PBRMOD SETC  '&RMODE'\n         AGO   .CAR0140\n.CAR0130 ANOP\n&#PBRMOD SETC  '24'\n.CAR0140 AIF   ('&AMODE' EQ '').CAR0150\n&#PBAMOD SETC  '&AMODE'\n         AGO   .CAR0900\n.CAR0150 ANOP\n&#PBAMOD SETC  '24'\n         AGO   .CAR0900\n.CAR0200 ANOP  ,             DEFAULT BOTH AMODE AND RMODE\n&#PBRMOD SETC  '24'\n&#PBAMOD SETC  '24'\n.CAR0900 ANOP\n.*--------------------------------------------------------------------*\n.*  GENERATE CSECT, REGEQU, ETC. AS REQUESTED\n.*--------------------------------------------------------------------*\n.MOP0000 ANOP\n&ZCSECT  SETC  '&NAME'\n         AIF   (NOT &#DCSYS).MOP0005     SET #MOPT ENVIR=\n&ZENVIR  SETC  'SYS'\n         AGO   .MOP0010\n.MOP0005 ANOP\n&ZENVIR  SETC  'USER'\n.MOP0010 ANOP                            SET #MOPT REGS=\n&ZREGEQU SETC  'NO'\n.MOP0020 AIF   (NOT &ODCMACP).MOP0025 SET #MOPT MACPRNT=\n&ZDCMACP SETC  'ON'\n         AGO   .MOP0030\n.MOP0025 ANOP\n&ZDCMACP SETC  'OFF'\n.MOP0030 AIF   (NOT &ODCPRGP).MOP0035 SET MOPT PRGPRNT=\n&ZDCPRGP SETC  'ON'\n         AGO   .MOP0040\n.MOP0035 ANOP\n&ZDCPRGP SETC  'OFF'\n.MOP0040 ANOP\n&ZREGEQU SETC  'NO'\n         AIF   (NOT &OCSECT).MOP0050\n&ZCSECT  CSECT ,\n.MOP0050 ANOP\n         AIF   (&#DCSYS).MOP0060                                   @C2\n         ##MREG RELEASE,R13                                        @C2\n.MOP0060 ANOP  ,                                                   @C2\n         #MOPT CSECT=,ENV=&ZENVIR,REGS=&ZREGEQU,                       X\n               MACPRNT=&ZDCMACP,PRGPRNT=&ZDCPRGP,                      X\n               AMODE=&#PBAMOD,RMODE=&#PBRMOD,MODNO=&ZMODNO\n         AIF   (NOT &OREGEQU).LOC0000\n         ##REGS\n.*--------------------------------------------------------------------*\n.* GENERATE LOCTR IF LOCTR OPTION SPECIFIED\n.*--------------------------------------------------------------------*\n.LOC0000 AIF   (NOT &#PBLOCR).CAR0105\n&NAME    LOCTR ,                        LOCTR FOR PROGRAM BLOCK INST\n         PSD   TYPE=PARTIAL\n         ENDPSD ,\n.*--------------------------------------------------------------------*\n.*  GENERATE INITIAL CODE TO COPY R15 AND SET 1ST PROGRAM BASE\n.*--------------------------------------------------------------------*\n         AIF   (NOT &#DC#STR).STR0050\n         AIF   ('&EP' NE '').STR0010\n&TAG     SETC  '#ST&#PB#C'\n         AGO   .STR0020\n.STR0010 ANOP\n&TAG     SETC   '&EP'\n.STR0020 ANOP\n&TAG     #START\n         AGO   .IDC0000\n.STR0050 AIF   (&#DCSYS).ERR0009\n         LR    R12,R15\n         ##LDBS &NAME,&BASEREG,R12\n.*--------------------------------------------------------------------*\n.*  GENERATE CONSTANTS AND SAVE REGISTERS\n.*--------------------------------------------------------------------*\n.IDC0000 AIF   (NOT &OID AND '&CPYRGHT' EQ '').CNS0190\n         B     #BP&NDX                  BRANCH PAST CONSTANTS\n         AIF   (NOT &OID).IDC0050             GENERATE ID\n         DC    C'&NAME &SYSDATE &SYSTIME '\n.IDC0050 AIF   ('&CPYRGHT' EQ '').CNS0190     GENERATE COPYRIGHT\n         DC    C&CPYRGHT\n.CNS0190 ANOP\n#BP&NDX  DS     0H\n.CNS0200 AIF   (NOT &#PBPWA).CNS0900\n         AIF   (&#DCRENT).CNS0900        GENERATE NORENT PWA?\n&TAG     SETC  '#BJ&NDX'\n&TAG2    SETC  '#PBJ&#PB#C'\n&TAG     DC    AL4(&TAG2)                ADDRESS OF PWA STORAGE\n.CNS0900 ANOP\n.*--------------------------------------------------------------------*\n.*  SAVE R1 IN REGISTER SPECIFIED ON R1SAVE=\n.*--------------------------------------------------------------------*\n         AIF   (NOT &#DCSYS).RPB0010    SYSTEM MODE RESERVED REGS?\n         ##MREG USE,R9                  INDICATE R9  USED FOR TCE\n         ##MREG USE,R10                 INDICATE R10 USED FOR CSA\n         USING CSA,R10                  SET CSA BASE FOR PROGRAM\n         ##MREG USE,R12                 INDICATE R12 USED FOR BASE\n.RPB0010 AIF   ('&R1SAVE' EQ '').PWA0000\n         ##MREG USE,&R1SAVE\n         LR    &R1SAVE,R1               SAVE R1\n.*--------------------------------------------------------------------*\n.*  ISSUE #GETSTG FOR PWA IF REQUIRED AND SET BASE(S) ON IT\n.*--------------------------------------------------------------------*\n.PWA0000 AIF   (NOT &#PBPWA).SAM0000\n&#DCPWAR SETC  '&PWAREG(1)'\n         AIF   ('&#DCPWAR' NE '').PWA0050\n&#DCPWAR SETC  'R11'\n.PWA0050 ##MREG USE,&#DCPWAR\n         AIF   (&#DCRENT).PWA0100\n         ICM   &#DCPWAR,B'1111',#BJ&NDX  LOAD ADDRESS OF DS'D PWA\n&#PBDSWA SETB  1\n         AGO   .PWA0600\n.PWA0100 ANOP\n&ZGLOC   SETC  'ANY'\n         AIF   ('&#PBAMOD' EQ '31' OR '&#PBAMOD' EQ 'ANY').PWA0200\n&ZGLOC   SETC  'BELOW'             GETS APP'D TO #GETSTG\n.PWA0200 ANOP\n.*       AIF   (NOT &OCLRPWA).PWA0300\n&ZGINIT  SETC  '00'\n.PWA0300 ANOP\n&#PBWAID SETC  '#W&#PB#C'\n         ##CVREG &#DCPWAR\n         AIF   (&#DCGSTK).PWA0500\n         B     #ID&#PB#C.+4        SKIP #GETSTG STGID\n#ID&#PB#C DC   AL4(&NAME)\n         AIF   (&#DCSYS).PWA0400\n         #GETSTG TYPE=(USER,SHORT),PLIST=*,STGID=#ID&#PB#C.,           X\n               LEN=&#PBWAID.PLLEN,ADDR=(&#MCVREG),INIT=&ZGINIT,        X\n               LOC=&ZGLOC\n         AGO   .PWA0600\n.PWA0400 ANOP\n         MNOTE *,'SYSTEM-MODE GETSTG GENERATED'\n         #GETSTG TYPE=(SYSTCE,SHORT),PLIST=*,STGID=#ID&#PB#C.,         X\n               LEN=&#PBWAID.PLLEN,ADDR=(&#MCVREG),INIT=&ZGINIT,        X\n               LOC=&ZGLOC,RGSV=(R2-R8)\n         AGO   .PWA0600\n.PWA0500 ANOP\n         MNOTE *,'#GETSTK GENERATED: #GETSTK =(&#PBWAID.PLLEN/4)'\n         #GETSTK =(&#PBWAID.PLLEN/4)\n.PWA0600 ##LDBS &#PBWAID,&PWAREG,R11\n.*--------------------------------------------------------------------*\n.*  GENERATE CODE TO SAVE ADDRESS MODE IF NEEDED\n.*--------------------------------------------------------------------*\n.SAM0000 AIF   ('&#PBSMWA' EQ '').SAM0999 SKIP IF NO SMWA\n&TAG     SETC  '#BY&#BNDX(&#BLVL)'      MAKE UP TAG\n         AIF   (NOT &#PBXA).SAM0200\n         AIF   (NOT &#PB370).SAM0100\n         L     R15,16                   POINT R15 TO CVT\n         TM    X'74'(R15),X'80'         RUNNING UNDER XA?\n         BZ    &TAG                     SKIP AMODE SETTING\n.SAM0100 ANOP\n         SLR   R15,R15                  CLEAR R15\n         AIF   (NOT &#PBXA).SAM0110\n         BSM   R15,0                    SET AMODE IN HIGH BIT\n.SAM0110 ST    R15,&#PBSMWA+4           SAVE ADDRESS MODE\n         AIF   (NOT &#PB370).SAM0200\n&TAG     DS    0H\n.SAM0200 ANOP\n.SAM0999 ANOP\n         AGO  .EXIT\n.*====================================================================*\n.*  ERRORS\n.*====================================================================*\n.* .ERR0003 MNOTE 8,'REGISTER USED FOR MULTIPLE REASONS'\n.*          AGO   .EXIT\n.ERR0009 MNOTE 8,'#START OPTION REQUIRED IF SYSTEM OPTION SPECIFIED'\n         AGO   .EXIT\n.ERR0010 MNOTE 8,'#RETURN-RELATED OPERANDS NOT ALLOWED WITH SYSTEM OPTI*\n               ON'\n         AGO   .EXIT\n.ERR0011 MNOTE 8,'#START/#RTN OPTIONS NOT ALLOWED WITH NOSYSTEM OPTION'\n         AGO   .EXIT\n.ERR0012 MNOTE 8,'#RETURN OPTION NOT ALLOWED WITH SYSTEM OPTION'\n         AGO   .EXIT\n.ERR0013 MNOTE 8,'EP OPTION NOT ALLOWED WITH NOSYSTEM OPTION'\n         AGO   .EXIT\n.ERR0014 MNOTE 8,'AMODE AND RMODE REQUESTED ARE INCONSISTENT'\n         AGO   .EXIT\n.ERR0015 MNOTE 8,'GETSTK OPTION REQUIRES SYSTEM OPTION'\n         AGO   .EXIT\n.ERR0016 MNOTE 8,'GETSTK OPTION REQUIRES PWA OPTION'\n         AGO   .EXIT\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PLIST": {"ttr": 8199, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00'\\x00'\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         PLIST &P,                      PARAMETER LIST                 $\n               &VL,                     VL                             $\n               &DS=,                    DEFINE STORAGE              @C1$\n               &PL=                     PARAMETER LIST STORAGE\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1985.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      PLIST\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - PLIST\n.*\n.*  PURPOSE    STRUCTURED MACRO USED TO BUILD PARAMETER LIST.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    6/27/85 MGG - NEW                                   @C1\n.*              1/22/86 MGG - ADDED * SUPPORT                       @C1\n.*                            ADDED DL= KEYWORD                     @C1\n.*                            ADDED AUTOMATIC PL FOR PWA SUPPORT    @C1\n.*              2/03/87 MGG - EXTENDED AUTOMATIC PL SUPPORT TO      @C2\n.*                            ERREXIT                               @C2\n.*             11/16/89 MGG - Changed to used ##PLIST macro.        @C3\n.*\n.*--------------------------------------------------------------------*\n         AIF  (N'&SYSLIST LE 2).SYSLIST_OK                          @C3\n         MNOTE 8,'Too many parameters specified.'                   @C3\n.SYSLIST_OK ANOP                                                    @C3\n         AIF  ('&PL' EQ '' AND '&P' EQ '').EXIT                     @C3\n         ##PLIST START,PL=&PL,DS=&DS                                @C3\n         ##PLIST PLIST,&P                                           @C3\n         ##PLIST END,&VL                                            @C3\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PSD": {"ttr": 8201, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00&\\x00&\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         PSD &TYPE=\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1986.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      PSD\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - PSD\n.*\n.*  PURPOSE    STRUCTURED MACRO USED TO START A PSD\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    1/22/86 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#PB#C                   PROGRAM BLOCK NUMBER\n         GBLA  &#MLVL                   STRUCTURAL LEVEL\n         GBLA  &#SDLVL                  STRUCTURAL LEVEL OF STATIC DATA\n         GBLB  &#SDPSD                  INDICATES IN PSD\n         GBLC  &#SDSVLC                 SAVE LOCATION COUNTER\n         LCLC  &TAG                     WORK TAG\n         AIF   (&#SDLVL EQ 0).SKIP\n         MNOTE 8,'Nested PSD and SSD macros are not allowed'\n.SKIP    ANOP\n&#MLVL   SETA  &#MLVL+1                 ADD ONE TO STRUCTURAL LEVEL\n&#SDLVL  SETA  &#MLVL                   SAVE STRUCTURAL LEVEL FOR END\n&#SDPSD  SETB  1\n&#SDSVLC SETC  '&SYSLOC'                SAVE LOCATION COUNTER\n&TAG     SETC  '#PBDL&#PB#C'\n&TAG     LOCTR ,                        PROGRAM STATIC DATA\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PWA": {"ttr": 8203, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00\\x1e\\x00\\x1e\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         PWA   &TYPE=LAST\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1985.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      PWA\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - PWA\n.*\n.*  PURPOSE    STRUCTURED MACRO USED TO START A PWA\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    7/14/85 MGG - NEW\n.*              1/23/86 MGG - ADDED TYPE=PARTIAL SUPPORT\n.*              2/17/86 MGG - ADDED AUTOMATIC CLOSE OF SWA\n.*              1/05/86 MGG - SUPPORT PWA TAG GLOBAL VARIABLE AND\n.*                            TYPE FIRST.\n.*              1/06/87 MGG - MOVED CODE TO ##WPSTD MACRO\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &#WPMAC                  PWA PREFIX MACRO\n         &#WPMAC &TYPE\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RBIT": {"ttr": 8205, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00?\\x00?\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n&NAME    RBIT  ,                        RESET BIT MACRO\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      RBIT\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - RBIT\n.*\n.*  PURPOSE    MACRO USED TO RESET A BIT.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - NEW  MGG\n.*\n.*--------------------------------------------------------------------*\n         LCLA  &POSFLAG                 POSITION OF FLAG\n         LCLA  &CTR                     COUNTER\n         LCLC  &BYTE                    BYTE NAME\n         LCLC  &FLAGS                   CONCATINATION OF FLAGS\n         AIF   (N'&SYSLIST NE 1).PRC0100\n         AIF   (N'&SYSLIST(1) GT 8).ERR0001  ERROR IF MORE THEN 8 FLAGS\n         AIF   (K'&SYSLIST(1,1) LT 6).ERR0003  ERROR IF FLAG < 6 CHARS\n&BYTE    SETC  '&SYSLIST(1,1)'(1,5)     BYTE NAME IS FIRST FIVE CHARS\n&FLAGS   SETC  'X''FF''-&SYSLIST(1,1)'  MOVE IN FIRST FLAG\n&CTR     SETA  2                        LOOP CONCATINATING EACH FLAG\n.PRC0050 AIF   (&CTR GT N'&SYSLIST(1)).PRC0060   LEAVE LOOP IF FINISHED\n         AIF   (K'&SYSLIST(1,&CTR) LT 6).ERR0003    ERROR\n         AIF   ('&SYSLIST(1,&CTR)'(1,5) NE '&BYTE').ERR0004 ERROR\n&FLAGS   SETC  '&FLAGS-&SYSLIST(1,&CTR)' CONCATINATE\n&CTR     SETA  &CTR+1                   ADD 1 TO COUNTER\n         AGO   .PRC0050                 LOOP FOR ALL FLAGS\n.PRC0060 ANOP\n&NAME    NI    &BYTE,&FLAGS             RESET FLAG(S)\n         MEXIT\n.PRC0100 AIF   (N'&SYSLIST NE 2).ERR0002     ERROR IF MORE THAN 2 PARMS\n         AIF   (N'&SYSLIST(2) GT 8).ERR0001  ERROR IF MORE THAN 8 FLAGS\n&BYTE    SETC  '&SYSLIST(1)'            SET BYTE NAME\n&FLAGS   SETC  'X''FF''-&SYSLIST(2,1)'  MOVE IN FIRST FLAG\n&CTR     SETA  2                        LOOP CONCATINATING EACH FLAG\n.PRC0150 AIF   (&CTR GT N'&SYSLIST(2)).PRC0160 LEAVE LOOP IF FINISHED\n&FLAGS   SETC  '&FLAGS-&SYSLIST(2,&CTR)' CONCATINATE\n&CTR     SETA  &CTR+1                   ADD 1 TO COUNTER\n         AGO   .PRC0150                 LOOP FOR ALL FLAGS\n.PRC0160 ANOP\n&NAME    NI    &BYTE,&FLAGS             RESET FLAG(S)\n         MEXIT\n.ERR0001 MNOTE 8,'No more than eight flags can be specified'\n         MEXIT\n.ERR0002 MNOTE 8,'RBIT macro can have no more than two operands'\n         MEXIT\n.ERR0003 MNOTE 8,'IF byte is not specified, flag name must be at least $\n               six characters long'\n         MEXIT\n.ERR0004 MNOTE 8,'If byte is not specified, the first five characters o$\n               f all flags must match'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SBIT": {"ttr": 8207, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00?\\x00?\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n&NAME    SBIT  ,                        SET BIT MACRO\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      SBIT\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - SBIT\n.*\n.*  PURPOSE    MACRO USED TO SET A BIT.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - NEW  MGG\n.*\n.*--------------------------------------------------------------------*\n         LCLA  &POSFLAG                 POSITION OF FLAG\n         LCLA  &CTR                     COUNTER\n         LCLC  &BYTE                    BYTE NAME\n         LCLC  &FLAGS                   CONCATINATION OF FLAGS\n         AIF   (N'&SYSLIST NE 1).PRC0100\n         AIF   (N'&SYSLIST(1) GT 8).ERR0001  ERROR IF MORE THEN 8 FLAGS\n         AIF   (K'&SYSLIST(1,1) LT 6).ERR0003  ERROR IF FLAG < 6 CHARS\n&BYTE    SETC  '&SYSLIST(1,1)'(1,5)     BYTE NAME IS FIRST FIVE CHARS\n&FLAGS   SETC  '&SYSLIST(1,1)'          MOVE IN FIRST FLAG\n&CTR     SETA  2                        LOOP CONCATINATING EACH FLAG\n.PRC0050 AIF   (&CTR GT N'&SYSLIST(1)).PRC0060   LEAVE LOOP IF FINISHED\n         AIF   (K'&SYSLIST(1,&CTR) LT 6).ERR0003    ERROR\n         AIF   ('&SYSLIST(1,&CTR)'(1,5) NE '&BYTE').ERR0004 ERROR\n&FLAGS   SETC  '&FLAGS+&SYSLIST(1,&CTR)' CONCATINATE\n&CTR     SETA  &CTR+1                   ADD 1 TO COUNTER\n         AGO   .PRC0050                 LOOP FOR ALL FLAGS\n.PRC0060 ANOP\n&NAME    OI    &BYTE,&FLAGS             SET FLAG(S)\n         MEXIT\n.PRC0100 AIF   (N'&SYSLIST NE 2).ERR0002     ERROR IF MORE THAN 2 PARMS\n         AIF   (N'&SYSLIST(2) GT 8).ERR0001  ERROR IF MORE THAN 8 FLAGS\n&BYTE    SETC  '&SYSLIST(1)'            SET BYTE NAME\n&FLAGS   SETC  '&SYSLIST(2,1)'          MOVE IN FIRST FLAG\n&CTR     SETA  2                        LOOP CONCATINATING EACH FLAG\n.PRC0150 AIF   (&CTR GT N'&SYSLIST(2)).PRC0160 LEAVE LOOP IF FINISHED\n&FLAGS   SETC  '&FLAGS+&SYSLIST(2,&CTR)' CONCATINATE\n&CTR     SETA  &CTR+1                   ADD 1 TO COUNTER\n         AGO   .PRC0150                 LOOP FOR ALL FLAGS\n.PRC0160 ANOP\n&NAME    OI    &BYTE,&FLAGS             SET FLAG(S)\n         MEXIT\n.ERR0001 MNOTE 8,'No more than eight flags can be specified'\n         MEXIT\n.ERR0002 MNOTE 8,'SBIT macro can have no more than two operands'\n         MEXIT\n.ERR0003 MNOTE 8,'If byte is not specified, flag name must be at least $\n               six characters long'\n         MEXIT\n.ERR0004 MNOTE 8,'If byte is not specified, the first five characters o$\n               f all flags must match'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SMCTRL": {"ttr": 8449, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00<\\x00<\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 60, "newlines": 60, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n&NAME    SMCTRL &FREEPWA=               SET BIT MACRO\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      SMCTRL\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - SMCTRL\n.*\n.*  PURPOSE    MACRO USED TO SET CONTROL INFORMATION IN THE\n.*             STRUCTURED MACROS.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    4/23/87 - NEW  MGG\n.*              3/28/91 - Added support for MANUALFREE option.      @C1\n.*              2/19/92 - Fixed bug that ignored parm number for    @C2\n.*                        reusable PWA.                             @C2\n.*\n.*--------------------------------------------------------------------*\n         GBLB  &#PBRPWA                 REUSABLE PWA OPTION\n         GBLA  &#PBPWAP                 REUSABLE PWA PARM NUMBER    @C2\n         GBLB  &#PBMFRE                 MANUALFREE OPTION           @C1\n         GBLC  &PWA                     PWA TAG                     @C1\n.*====================================================================*\n.*   FREEPWA KEYWORD\n.*====================================================================*\n         AIF  ('&FREEPWA' EQ '').FPW9999\n         AIF  (&#PBRPWA OR &#PBMFRE).FPW0100                        @C1\n         MNOTE 8,'The FREEPWA keyword is only valid if the REUSPWA or M$\n               ANUALFREE option is in effect'                       @C1\n.FPW0100 AIF  (&#PBMFRE).FPW1000                                    @C1\n         ##SWREG R15\n         L     R15,4(,R13)              LOAD R15 WITH BACKLINK\n         L     R15,24(,R15)             LOAD R15 WITH R1 AT ENTRY\n         L     R15,(&#PBPWAP-1)*4(,R15) LOAD R15 WITH PTR TO ANCHOR @C2\n         AIF   ('&FREEPWA' NE 'YES').FPW0110\n         OI    0(R15),X'80'             INDICATE PWA SHOULD BE FREED\n         AGO   .FPW0200\n.FPW0110 AIF   ('&FREEPWA' EQ 'NO').FPW0120\n         MNOTE 8,'FREEPWA=&FREEPWA is not valid'\n.FPW0120 NI    0(R15),X'7F'             INDICATE PWA SHOULD BE KEPT\n.FPW0200 ##RWREG R15\n         AGO   .FPW9999                                             @C1\n.FPW1000 ANOP                                                       @C1\n         AIF   ('&FREEPWA' NE 'YES').FPW1110                        @C1\n         OI    &PWA.__F,&PWA.__F_FREEPWA                            @C1\n         AGO   .FPW9999                                             @C1\n.FPW1110 AIF   ('&FREEPWA' EQ 'NO').FPW1120                         @C1\n         MNOTE 8,'FREEPWA=&FREEPWA is not valid'                    @C1\n.FPW1120 NI    &PWA.__F,X'FF'-&PWA.__F_FREEPWA                      @C1\n.FPW9999 ANOP\n.*====================================================================*\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SMLIST": {"ttr": 8451, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         SMLIST &CONVERT=               SET BIT MACRO\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1988.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      SMLIST\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - SMLIST\n.*\n.*  PURPOSE    THIS MACRO WILL BE INTERPRETED BY THE STRUCTURED\n.*             MACRO LISTING PROGRAM TO TURN UPPER CASE CONVERSION\n.*             ON AND OFF.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    8/8/88 - NEW  MGG\n.*\n.*--------------------------------------------------------------------*\n         MNOTE *,'Processed by listing program.'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SMPUCOND": {"ttr": 8453, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00@\\x00@\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 64, "newlines": 64, "modlines": 0, "user": "CLEMSON"}, "text": "* *-------------------------------------------------------------------*\n* * Define TRT condition name.  Do a Translate and Test and check the\n* * result.\n* *     FORM: (%TRT,op1,cond,op2)\n* *       EX: (%TRT,PWAFIELD,NE,PSDVALID)\n* *-------------------------------------------------------------------*\n  DEFUCOND NAME=TRT,MACRO=TRT_UCOND   |\n         MACRO                        |\n&NAME    TRT_UCOND &EXPR,&S=,&F=,&L=  |\n         AIF (N'&EXPR NE 4).ERR0001   |\n&NAME    TRT   &EXPR(2),&EXPR(4)      | Do TRT instruction.\n         ##COND &EXPR(3),             |                                +\n               S=&S,F=&F,L=&L         |\n         MEXIT                        |\n.ERR0001 MNOTE 8,'Too many parameters in %TRT expr'\n         MEND                         |\n* *-------------------------------------------------------------------*\n* * Define EXI condition name.  EXecute an instruction and test the\n* * resulting condition code.\n* *     FORM: (%EXI,op1,op2,cond)\n* *       EX: (%EXI,R1,(CLC,PWASTUFF,0(R3)),EQ)\n* *-------------------------------------------------------------------*\n  DEFUCOND NAME=EXI,MACRO=EXI_UCOND   |\n         MACRO                        |\n&NAME    EXI_UCOND &EXPR,&S=,&F=,&L=  |\n         AIF (N'&EXPR NE 4).ERR0001   |\n&NAME    EXI   &EXPR(2),&EXPR(3)      | Call EXI macro.\n         ##COND &EXPR(4),             |                                +\n               S=&S,F=&F,L=&L         |\n         MEXIT                        |\n.ERR0001 MNOTE 8,'Too many parameters in %EXI expr'\n         MEND                         |\n* *-------------------------------------------------------------------*\n* * Define L32 user cond name.  Load a register with a full word value\n* * and check the result of the load.\n* *     FORM: (%L32,op1,op2,cond)\n* *       EX: (%L32,R1,XYZADDR,NZ)\n* *-------------------------------------------------------------------*\n  DEFUCOND NAME=L32,MACRO=L32_UCOND\n         MACRO\n&NAME    L32_UCOND &EXPR,&S=,&F=,&L=\n         AIF (N'&EXPR NE 4).ERR0001   |\n&NAME    L32   &EXPR(2),&EXPR(3)      | Load address of token value.\n         ##COND &EXPR(4),             |                                +\n               S=&S,F=&F,L=&L         |\n         MEXIT                        |\n.ERR0001 MNOTE 8,'Incorrect number of parameters in %L32 expr'\n         MEND                         |\n* *-------------------------------------------------------------------*\n* * Define L16 user cond name.  Load a register with a half-word value\n* * and check the result of the load.\n* *     FORM: (%L16,op1,op2,cond)\n* *       EX: (%L16,R1,XYZADDR,NZ)\n* *-------------------------------------------------------------------*\n  DEFUCOND NAME=L16,MACRO=L16_UCOND\n         MACRO\n&NAME    L16_UCOND &EXPR,&S=,&F=,&L=\n         AIF (N'&EXPR NE 4).ERR0001   |\n&NAME    L16   &EXPR(2),&EXPR(3)      | Load address of token value.\n         ##COND &EXPR(4),             |                                +\n               S=&S,F=&F,L=&L         |\n         MEXIT                        |\n.ERR0001 MNOTE 8,'Incorrect number of parameters in %L16 expr'\n         MEND                         |\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SMSYMS": {"ttr": 8455, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00#\\x00#\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*\n*   (C) COPYRIGHT 1988.  CLEMSON UNIVERSITY COMPUTER CENTER.\n*\n*   MEMBER     SMSYMS\n*\n*   TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n*              PROGRAMMING MACROS - SMSYMS\n*\n*   PURPOSE    THIS COPY MEMBER CONTAINS CODE THAT NEEDS TO BE\n*              COPIED INTO PROGRAMS THAT USE THE STRUCTURED\n*              MACROS.\n*\n*   NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n*              THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n*\n*              . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n*                PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n*\n*   ACTIVITY    9/1/88 - NEW  MGG\n*               3/14/89 MGG - ADDED &P SYMBOL\n*               3/23/89 MGG - ADDED &PWA AND &PSD SYMBOLS.\n*               5/02/89 MGG - ADDED &SWA, &SSD, &SPL AND &PPL SYMBOLS.\n*\n*---------------------------------------------------------------------*\n         GBLC  &PWA                PROGRAM WORK AREA ID\n         GBLC  &PSD                PROGRAM STATIC DATA ID\n         GBLC  &PPL                PROGRAM PARAMETER LIST\n         GBLC  &SWA                SUBROUTINE WORK AREA ID\n         GBLC  &W                  SHORTER NAME\n         GBLC  &SSD                SUBROUTINE STATIC DATA ID\n         GBLC  &S                  SHORTER NAME\n         GBLC  &SPL                SUBROUTINE PARAMETER LIST\n         GBLC  &P                  SHORTER NAME\n*-- END OF SMSYMS ----------------------------------------------------*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SSD": {"ttr": 8457, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00,\\x00,\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         SSD &TYPE=\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1986.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      SSD\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - SSD\n.*\n.*  PURPOSE    STRUCTURED MACRO USED TO START A SSD\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    1/22/86 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#SB#C                   SUBROUTINE BLOCK NUMBER\n         GBLA  &#PB#C                   PROGRAM BLOCK NUMBER\n         GBLA  &#MLVL                   STRUCTURAL LEVEL\n         GBLA  &#SDLVL                  STRUCTURAL LEVEL OF STATIC DATA\n         GBLB  &#SDSSD                  INDICATES IN SSD\n         GBLC  &#SDSVLC                 SAVE LOCATION COUNTER\n         GBLB  &#SBLDBS                 SUBROUTINE LOADBASE OPTION\n         AIF   (&#SDLVL EQ 0).SKIP\n         MNOTE 8,'Nested PSD and SSD macros are not allowed'\n.SKIP    ANOP\n&#MLVL   SETA  &#MLVL+1                 ADD ONE TO STRUCTURAL LEVEL\n&#SDLVL  SETA  &#MLVL                   SAVE STRUCTURAL LEVEL FOR END\n&#SDSSD  SETB  1\n&#SDSVLC SETC  '&SYSLOC'                SAVE LOCATION COUNTER\n         AIF   (&#SBLDBS).PRC0110\n&TAG     SETC  '#PBDL&#PB#C'\n         AGO   .PRC0120\n.PRC0110 ANOP\n&TAG     SETC  '#SBDL&#SB#C'\n.PRC0120 ANOP\n&TAG     LOCTR ,                        SUBROUTINE DATA\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STRSA": {"ttr": 8459, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00#\\x00#\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         STRSA &REG\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      STRSA\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - STRSA\n.*\n.*  PURPOSE    MACRO USED TO STORE REGISTER IS REGISTER SAVE AREA\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    7/16/85 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &#MCVREG                 CONVERTED REGISTER\n         GBLA  &#SB#C                   CURRENT SUBROUTINE NUMBER\n         GBLB  &#SBSWA                  SWA OPTION\n         ##CVREG &REG\n         AIF   (&#MCVREG GE 15).ERR1\n         AIF   (NOT &#SBSWA).ERR2\n         ST    &REG,#SBS&#SB#C+4*&#MCVREG SAVE REGISTER IN SAVE AREA\n         MEXIT\n.ERR1    MNOTE 8,'Invalid register specified - &REG'\n         MEXIT\n.ERR2    MNOTE 8,'This macro can only be used in subroutine blocks with$\n                the SWA option specified'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SWA": {"ttr": 8461, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00\\x1b\\x00\\x1b\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         SWA   &TYPE=LAST\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1985.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      SWA\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - SWA\n.*\n.*  PURPOSE    STRUCTURED MACRO USED TO START A SWA\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    7/14/85 MGG - NEW\n.*              1/23/86 MGG - ADDED TYPE=PARTIAL SUPPORT\n.*              1/06/87 MGG - MOVED CODE TO ##UPMAC\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &#UPMAC                  SWA PROLOG MACRO\n         &#UPMAC &TYPE\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TBIT": {"ttr": 8463, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00G\\x00G\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 71, "newlines": 71, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n&NAME    TBIT  ,                        TEST BIT MACRO\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      TBIT\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - TBIT\n.*\n.*  PURPOSE    MACRO USED TO TEST A BIT.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - NEW  MGG\n.*\n.*--------------------------------------------------------------------*\n         LCLA  &POSFLAG                 POSITION OF FLAG\n         LCLA  &CTR                     COUNTER\n         LCLC  &BYTE                    BYTE NAME\n         LCLC  &FLAGS                   CONCATINATION OF FLAGS\n         AIF   (N'&SYSLIST NE 1).PRC0100\n         AIF   (N'&SYSLIST(1) GT 8).ERR0001  ERROR IF MORE THEN 8 FLAGS\n         AIF   (K'&SYSLIST(1,1) LT 6).ERR0003  ERROR IF FLAG < 6 CHARS\n&BYTE    SETC  '&SYSLIST(1,1)'(1,5)     BYTE NAME IS FIRST FIVE CHARS\n&FLAGS   SETC  '&SYSLIST(1,1)'          MOVE IN FIRST FLAG\n&CTR     SETA  2                        LOOP CONCATINATING EACH FLAG\n.PRC0050 AIF   (&CTR GT N'&SYSLIST(1)).PRC0060   LEAVE LOOP IF FINISHED\n         AIF   (K'&SYSLIST(1,&CTR) LT 6).ERR0003    ERROR\n         AIF   ('&SYSLIST(1,&CTR)'(1,5) NE '&BYTE').ERR0004 ERROR\n&FLAGS   SETC  '&FLAGS+&SYSLIST(1,&CTR)' CONCATINATE\n&CTR     SETA  &CTR+1                   ADD 1 TO COUNTER\n         AGO   .PRC0050                 LOOP FOR ALL FLAGS\n.PRC0060 AIF   (N'&SYSLIST(1) NE 1).PRC0070        ASM H REQUIRED?\n         AIF   ('&SYSLIST(1)'(1,1) NE '(').PRC0070   YES, ERROR\n         AIF   ('&SYSLIST(1)' EQ '&SYSLIST(1,1)').ERR0005\n.PRC0070 ANOP\n&NAME    TM    &BYTE,&FLAGS             TEST FLAG(S)\n         MEXIT\n.PRC0100 AIF   (N'&SYSLIST NE 2).ERR0002     ERROR IF MORE THAN 2 PARMS\n         AIF   (N'&SYSLIST(2) GT 8).ERR0001  ERROR IF MORE THAN 8 FLAGS\n&BYTE    SETC  '&SYSLIST(1)'            SET BYTE NAME\n&FLAGS   SETC  '&SYSLIST(2,1)'          MOVE IN FIRST FLAG\n&CTR     SETA  2                        LOOP CONCATINATING EACH FLAG\n.PRC0150 AIF   (&CTR GT N'&SYSLIST(2)).PRC0160 LEAVE LOOP IF FINISHED\n&FLAGS   SETC  '&FLAGS+&SYSLIST(2,&CTR)' CONCATINATE\n&CTR     SETA  &CTR+1                   ADD 1 TO COUNTER\n         AGO   .PRC0150                 LOOP FOR ALL FLAGS\n.PRC0160 AIF   (N'&SYSLIST(2) NE 1).PRC0170        ASM H REQUIRED?\n         AIF   ('&SYSLIST(2)'(1,1) NE '(').PRC0170 YES, ERROR\n         AIF   ('&SYSLIST(2)' EQ '&SYSLIST(2,1)').ERR0005\n.PRC0170 ANOP\n&NAME    TM    &BYTE,&FLAGS             TEST FLAG(S)\n         MEXIT\n.ERR0001 MNOTE 8,'No more than eight flags can be specified'\n         MEXIT\n.ERR0002 MNOTE 8,'TBIT macro can have no more than two operands'\n         MEXIT\n.ERR0003 MNOTE 8,'If byte is not specified, flag name must be at least $\n               six characters long'\n         MEXIT\n.ERR0004 MNOTE 8,'If byte is not specified, the first five characters o$\n               f all flags must match'\n         MEXIT\n.ERR0005 MNOTE 8,'This expression requires the Level H assembler'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TREG": {"ttr": 8466, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00\\x1b\\x00\\x1b\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n&NAME    TREG  ,                        TEST REGISTER MACRO\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1983.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      TREG\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - TREG\n.*\n.*  PURPOSE    MACRO USED TO TEST A REGISTER.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY   11/01/83 - NEW  MGG\n.*\n.*--------------------------------------------------------------------*\n         AIF   (N'&SYSLIST NE 1).ERR0001\n&NAME    LTR   &SYSLIST(1),&SYSLIST(1)  TEST REGISTER\n         MEXIT\n.ERR0001 MNOTE 8,'TREG macro can have one and only one operand'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VDA": {"ttr": 8468, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x06O\\x00\\x98\\x06O\\x16Y\\x00\\x8b\\x00\\x8b\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "1998-03-05T16:59:00", "lines": 139, "newlines": 139, "modlines": 0, "user": "CLEMSON"}, "text": "         MACRO\n         VDA   &ID=,&GENTYPE=,&DSECT=,&START=,&TYPE=LAST,&ALIGN=F\n.*--------------------------------------------------------------------*\n.*\n.*  (C) COPYRIGHT 1991.  CLEMSON UNIVERSITY COMPUTER CENTER.\n.*\n.*  MACRO      VDA\n.*\n.*  TITLE      CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*             PROGRAMMING MACROS - VDA\n.*\n.*  PURPOSE    MACRO TO START A VARIABLE DEFINITION AREA.\n.*\n.*  NOTE       SEE THE FOLLOWING DOCUMENT FOR MORE INFORMATION ON\n.*             THIS AND OTHER STRUCTURED PROGRAMMING MACROS:\n.*\n.*             . CLEMSON UNIVERSITY COMPUTER CENTER STRUCTURED\n.*               PROGRAMMING MACROS USER'S GUIDE AND REFERENCE.\n.*\n.*  ACTIVITY    8/06/91 MGG - NEW\n.*\n.*--------------------------------------------------------------------*\n         GBLC  &VDA__ID(20)\n         GBLC  &VDA__START(20)\n         GBLC  &VDA__ALIGN(20)\n         GBLC  &VDA__GENTYPE\n         GBLC  &VDA__CSECT\n         GBLA  &VDA__LEVEL\n         GBLC  &VDA__PROLOG\n         GBLC  &VDA__EPILOG\n         GBLC  &VDA__DC\n         GBLC  &VDA__DS\n         GBLC  &VDA__EQU\n.*\n.*  Initialize variables.\n.*\n&VDA__LEVEL   SETA &VDA__LEVEL+1\n&VDA__ID(&VDA__LEVEL)    SETC  '&ID'\n.*\n&VDA__START(&VDA__LEVEL) SETC  '&START'\n&VDA__ALIGN(&VDA__LEVEL) SETC  '&ALIGN'\n         AIF   ('&START' NE '').PRC010\n&VDA__START(&VDA__LEVEL) SETC  '&ID.START'\n.PRC010  AIF   (&VDA__LEVEL EQ 1).PRC020\n         MNOTE *,'DSECT, GENTYPE and TYPE are ignored for nested VDAs.'\n         AGO   .PROLOG\n.PRC020  ANOP\n&VDA__CSECT   SETC '&SYSECT'\n&VDA__GENTYPE SETC ''\n&VDA__PROLOG  SETC ''\n&VDA__EPILOG  SETC ''\n&VDA__DC      SETC ''\n&VDA__DS      SETC ''\n&VDA__EQU     SETC ''\n.*\n.*  Process based on GENTYPE and DSECT.\n.*\n         AIF   ('&DSECT' EQ '').SEL100\n         AIF   ('&GENTYPE' EQ '').SEL050\n         MNOTE *,'DSECT=&DSECT ignored because was GENTYPE specified.'\n         AGO   .SEL100\n.SEL050  AIF   ('&DSECT' EQ 'YES').DSECT\n         AIF   ('&DSECT' EQ 'NO').INLINE\n         MNOTE 4,'DSECT=&DSECT is not valid.  DSECT=NO assumed.'\n         AGO   .INLINE\n.SEL100  AIF   ('&GENTYPE' EQ '').INLINE\n         AIF   ('&GENTYPE' EQ 'INLINE').INLINE\n         AIF   ('&GENTYPE' EQ 'GENERATE').INLINE\n         AIF   ('&GENTYPE' EQ 'DSECT').DSECT\n         AIF   ('&GENTYPE(1)'(1,1) EQ '%').VGTYPE\n         MNOTE 8,'GENTYPE=&GENTYPE is not valid.'\n         MEXIT\n.*\n.*  Process user defined GENTYPE.\n.*\n.VGTYPE  ANOP\n&X       SETA  K'&GENTYPE(1)-1\n         AIF   (&X GE 1).VGT050\n         MNOTE 8,'GENTYPE=&GENTYPE is not valid.'\n         MEXIT\n.VGT050  ANOP\n&NAME    SETC  '&GENTYPE(1)'(2,&X)\n&VGTYP_DEFINED SETC '&NAME.__DEFINED'\n&VGTYP_PROLOG  SETC '&NAME.__PROLOG'\n&VGTYP_EPILOG  SETC '&NAME.__EPILOG'\n&VGTYP_DC      SETC '&NAME.__DC'\n&VGTYP_DS      SETC '&NAME.__DS'\n&VGTYP_EQU     SETC '&NAME.__EQU'\n         GBLB  &(&VGTYP_DEFINED)\n         GBLC  &(&VGTYP_PROLOG)\n         GBLC  &(&VGTYP_EPILOG)\n         GBLC  &(&VGTYP_DC)\n         GBLC  &(&VGTYP_DS)\n         GBLC  &(&VGTYP_EQU)\n         AIF   (&(&VGTYP_DEFINED)).VGT100\n         MNOTE 8,'No DEFDGTYP macro exists for GENTYPE=&GENTYPE.'\n         MEXIT\n.VGT100  ANOP\n&VDA__PROLOG SETC '&(&VGTYP_PROLOG)'\n&VDA__EPILOG SETC '&(&VGTYP_EPILOG)'\n&VDA__DC     SETC '&(&VGTYP_DC)'\n&VDA__DS     SETC '&(&VGTYP_DS)'\n&VDA__EQU    SETC '&(&VGTYP_EQU)'\n         AGO   .PROLOG\n.*\n.*  Process GENTYPE=INLINE.\n.*\n.INLINE  ANOP\n&VDA__GENTYPE SETC 'INLINE'\n&VDA__PROLOG  SETC '##VPINLN'\n&VDA__EPILOG  SETC '##VEINLN'\n         AGO   .PROLOG\n.*\n.*  Process GENTYPE=DSECT.\n.*\n.DSECT   ANOP\n&VDA__GENTYPE SETC 'DSECT'\n&VDA__PROLOG  SETC '##VPDSCT'\n&VDA__EPILOG  SETC '##VEDSCT'\n         AGO   .PROLOG\n.*\n.*  Do OPSYNs as necessary and call prolog macro.\n.*\n.PROLOG  AIF   (&VDA__LEVEL NE 1).PRO500\n         AIF   ('&VDA__DC' EQ '').PRO110\n##DC     OPSYN DC\nDC       OPSYN\n.PRO110  AIF   ('&VDA__DS' EQ '').PRO120\n##DS     OPSYN DS\nDS       OPSYN\n.PRO120  AIF   ('&VDA__EQU' EQ '').PRO130\n##EQU    OPSYN EQU\nEQU      OPSYN\n.PRO130  ANOP\n.PRO500  AIF   ('&VDA__PROLOG' EQ '').PRO510\n         &VDA__PROLOG GENTYPE=&GENTYPE\n.PRO510  ANOP\n.*\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT107/FILE107.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT107", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}