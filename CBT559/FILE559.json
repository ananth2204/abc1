{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012340000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 3762304, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 33, "INMDSNAM": "CBT.V500.FILE559.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 3762304, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 3762304, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE559.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00=\\x17'", "DS1TRBAL": "b'\\x08\\xe6'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04$\\x00\\x01\\x04(\\x00\\x02\\x00>'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x12\\x9f\\x01\\x02\\x12\\x9f\\x01W\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc8\\xc9\\xd7\\xc4\\xc1\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-05-09T00:00:00", "modifydate": "2002-05-09T01:57:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SHIPDAT"}, "text": "REGULAR CBT TAPE - VERSION 446    FILE:  559\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT446.FILE559\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    8000    PO\n\n   PDS117I 167 MEMBERS COUNTED; CUMULATIVE SIZE IS 34,912 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   05/09/02    01:57:25    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$README": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00(\\x01\\x00)O\\x01\\x02\\x12\\x8f\\x17\\x10\\x01\\x0c\\x00\\x0c\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2000-10-20T00:00:00", "modifydate": "2002-05-08T17:10:28", "lines": 268, "newlines": 12, "modlines": 0, "user": "BC0THOR"}, "text": "************************************************************************\n* File 559 is primarily C language source programs. Many of these      *\n* programs were written for use on a PC and are of principal value in  *\n* demonstrating simple C language programs. Most of the programs can be*\n* compiled and run as-is on a mainframe in a TSO session by allocating *\n* SYSIN, SYSOUT, and SYSPRINT to DA(*) which is the terminal, so that  *\n* program data entry can be keyed in real-time, and the printf() output*\n* will be displayed on the terminal.                                   *\n*                                                                      *\n************************************************************************\n* Some notes on mainframe vs PC C language differences:                *\n* 1. Some escape sequences (\\n, \\/, etc) differ. For the mainframe,    *\n*    when the compiler complains about an escape sequence, it is       *\n*    usually correct to just remove the leading back-slash.            *\n*                                                                      *\n* 2. The mainframe C compiler likes source code in columns 1-72, and   *\n*    will issue warning messages \"CBC3389 SOME TEXT NOT SCANNED...\"    *\n*    when it finds code or comments beyond column 72.                  *\n*                                                                      *\n* 3. For some reason the mainframe compiler's header files contain     *\n*    many elements (function prototypes, data elements, etc) that are  *\n*    \"protected by a feature test macro.\" These are often noted in     *\n*    the IBM manual SC28-1663 \"OS/390 c/c++ Run-Time Library Reference\"*\n*    and the solution is to add the following line before any #includes*\n*        #define _ALL_SOURCE                                           *\n*                                                                      *\n* 4. Function names, whether external or contained within the program  *\n*    are considered to be external symbols by the mainframe compiler,  *\n*    and they will be truncated to 8 characters. It is probably safest *\n*    to change the names of any functions longer than 8 characters, or *\n*    that contain underscores so that they are 8 characters or less and*\n*    begin with an alphabetic character and contain only a-z and 0-9.  *\n*                                                                      *\n* 5. When a function prototype contains a reference to a structure,    *\n*    the mainframe compiler requires that the prototype follow the     *\n*    structure definition.                                             *\n*                                                                      *\n* 6. Square brackets are a major hassle on the mainframe, and the      *\n*    $README member contains a discussion and suggested solution or    *\n*    circumvention.                                                    *\n*                                                                      *\n* 7. For writing new mainframe C programs, you may find the SKELETON   *\n*    program to be a good starting point, as it contains a \"bare-bones\"*\n*    set of code.                                                      *\n*                                                                      *\n* 8. The mainframe C compiler requires specific #include statements for*\n*    header files that were found automatically by the PC C compiler I *\n*    used.                                                             *\n*                                                                      *\n* 9. OPEN statements for files differ on the mainframe from normal PC  *\n*    use. Some examples are:                                           *\n*      fopen(\"asa.file\", \"w,recfm=fba\");                               *\n*      fopen(\"test.file\",\"wb, recfm=f, lrecl=80\");                     *\n*      fopen(qual_pds,\"rb\");                                           *\n*      fopen(\"a.b(memnm)\",\"r\");                                        *\n*      fopen(\"mygdg(+1)\",\"a,recfm=f\");                                 *\n*      fopen(\"a.b\",\"w+\");                                              *\n*      fopen(\"dd:vsamesds\",\"rb,type=record\");                          *\n************************************************************************\n* The first line for each program listed below has a parenthesized,    *\n* abbreviated attribute field showing the type (text only, subroutine, *\n* main program, etc), main processing function (formatting, abend,     *\n*listing, dynamic allocation, copy, etc.)  and primary data type       *\n* processed (assembler source code, listing, vtoc qsam file, vsam file,*\n* catalog data, etc.). following the attribute field is a short        *\n* description of the program. There may be lines following the first   *\n* which identify members in other files that are related (JCL, etc).   *\n************************************************************************\n*   ====> (TYPE/FUNC/DATA) <====\n$$README  (TEXT/    /    ) . GENERAL INFORMATION ON C AND THIS LIBRARY\nABAL      (MAIN/FMT /QSAM) . SIMPLE C LANGUAGE SOURCE PROGRAM REFORMAT.\n+         JCL SAMPJCL(ABAL)\nBLDFUNCD  (MAIN/FMT /QSAM) . READS RECFM=V REFORMATS TO RECFM=F DATASETS\n+         JCL SAMPJCL(BLDFUNCD)\nCALLBIN   (MAIN/SRCH/QSAM) . DOES A BINARY SEARCH OF A SEQUENTIAL FILE\nCAPACITR  (MAIN/COMP/    ) . COMPUTE AND DISPLAY CAPACITANCE\n+         JCL SAMPJCL(CAPACITR)\nCBC3GDC4  (MAIN/SAMP/    ) . IBM SAMPLE USING THE DECIMAL DATA TYPE\n+         JCL SAMPJCL(CBC3GDC4)\nCFUNC     (SUBR/TEST/    ) . FOR TESTING CALLS FROM ASSEMBLER, COBOL\n+         CALLED BY PROGRAM CALLCPGM IN FILE 563.\n+         JCL SAMPJCL(CALLCPGM)\n+         DATA FOR EXECUTION FILE564.DATA(CALLCPGM)\nCIRCLE    (MAIN/COMP/    ) . DISPLAYS THE CIRCUMFERENCE, VOLUME, AND\n+                               AREA OF A CIRCLE, GIVEN THE RADIUS.\n+                               SHOWS PASSING PARAMETER IN EXEC PARM.\n+         JCL SAMPJCL(CIRCLE)\nCMPRFILE  (MAIN/CMPR/QSAM) . COMPARES TWO FILES BYTE-BY-BYTE REPORTING\n+                               DIFFERENCES AND STOPS AFTER 10TH DIFF-\n+                               ERENCE. DSNAMES ARE PASED AS PARMS ON\n+                               THE EXEC STATEMENT.\n+         JCL SAMPJCL(CMPRFILE)\nCONV      (MAIN/SAMP/    ) . USES THE ATOL() FUNCTION TO CONVERT A\n+                               STRING OF DECIMAL DIGITS TO A LONG.\nCOPYSOME  (MAIN/STRP/QSAM) . COPIES THE FIRST 100K BYTES AND LAST 100K\n+                               BYTES OF AN INPUT FILE TO CREATE A\n+                               SMALLER TEST FILE.\nCOPYSUBR  (MAIN/STRP/QSAM) . COPIES EVERY 50TH RECORD FROM AN INPUT FILE\n+                               TO BUILD A SMALLER FILE FOR TESTING.\nCOUNTBYT  (MAIN/SUM /QSAM) . COUNT ALL BYTES IN A FILE BY BYTE VALUE\n+                               (TOTAL OF ALL LETTER A'S, B'S, C'S, ETC)\n+                               AND PRINT TOTALS. (ALSO SEE COUNTBY0)\n+         JCL SAMPJCL(COUNTBYT)\nCOUNTBY0  (MAIN/SUM /QSAM) . COUNT ALL BYTES IN A FILE BY BYTE VALUE\n+                               (TOTAL OF ALL LETTER A'S, B'S, C'S, ETC)\n+                               AND PRINT TOTALS. (ALSO SEE COUNTBYT)\nCSECMCH2  (MAIN/MTCH/QSAM) . SAMPLE FILE MATCH-MERGE.\n+         JCL SAMPJCL(CSECMCH2)\nC2COMPCK  (MAIN/MTCH/QSAM) . COMPARES THREE INPUT FILES, PRINTS\n+                               DIFFERENCES.\n+         JCL SAMPJCL(C2COMPCK)\nDATECALC  (MAIN/DATE/    ) . GIVEN A TWO-DIGIT YEAR, PRINTS THE DAY OF\n+                               WEEK FOR JAN 1ST.\nDAYJAN1   (MAIN/DATE/    ) . GIVEN A 4-DIGIT YEAR > 1752, PRINTS THE\n+                               DAY OF WEEK FOR JAN 1ST.\nDAYWEEK   (MAIN/DATE/    ) . PRINTS DAY-OF-WEEK FOR ANY DATE MORE RECENT\n+                               THAN JAN 1, 1752. USER PROVIDES THE DATE\n+                               AS MM/DD/YYYY.\nDIVIDE    (MAIN/COMP/    ) . DIVIDE USING INTEGERS TOO LARGE FOR LONG\n+                               LONG INTEGERS WHERE THE REMAINDER IS\n+                               NEEDED AND/OR AN EXACT QUOTIENT IS\n+                               REQUIRED.\nDOWNLOAD  (MAIN/SAMP/    ) . DOWNLOAD A CHARACTER SET TO THE EPSON FX-85\n+                               PRINTER IN EPSON MODE.\nDROPCR    (MAIN/FMT /QSAM) . READS A STANDARD ASCII TEXT FILE HAVING\n+                               LINES ENDING IN CARRIAGE-RETURN AND LINE\n+                               FEED AND COPIES IT, DROPPING THE\n+                               CARRIAGE RETURN BYTES.\nDUMPHEX   (MAIN/DSPL/QSAM) . PRINTS A FILE IN HEX AND CHARACTER FORMAT.\n+                            (ALSO SEE HEXDUMP).\nEASTER    (MAIN/DATE/QSAM) . COMPUTES MONTH AND DAY OF EASTER FOR ANY\n+                               YEAR 1584-2900.\nEDGEFIND  (MAIN/GENL/QSAM) . SAMPLE PROGRAM THAT READS A FILE, WRITES A\n+                              REPORT.\n+         JCL SAMPJCL(EDGEFIND)\nEDGESTRP  (MAIN/STRP/QSAM) . SAMPLE PROGRAM THAT READS A FILE, STRIPS\n+                               SOME RECORDS, AND WRITES A REFORMATTED\n+                               VERSION OF THE SELECTED RECORDS.\n+         JCL SAMPJCL(EDGESTRP)\nEDGEVSCB  (MAIN/GENL/QSAM) . SAMPLE PROGRAM TO READ A FILE, WRITE A\n+                               REPORT.\n+         JCL SAMPJCL(EDGEVSCB)\nEDIT      (SUBR/FMT /    ) . A SUBRUTINE THAT PROVIDES NUMERIC DATA\n+                                EDITING FOR PRINTING INCLUDING LEADING\n+                                ZERO SUPPRESSION, AND COMMA AND DECIMAL\n+                                POINT INSERTION. SEE TESTEDIT.C FOR A\n+                                PROGRAM TO TEST THE FUNCTION.\nEDIT2     (MAIN/FMT /    ) . DEMONSTRATES NUMERIC DATA FORMATTING BY\n+                                OBTAINING A PATTERN AND A NUMBER FROM\n+                                THE USER, AND DISPLAYS THE RESULT.\nEMPEROR   (MAIN/SAMP/QSAM) . A GAME ADAPTED FROM ONE WRITTEN IN PL/I\n+                                FOR THE MAINFRAME.\nENDCKDUP  (MAIN/SAMP/QSAM) . SAMPLE PROGRAM THAT READS A FILE, CHECKS\n+                               FOR RECORDS HAVING DUPLICATE DATA IN\n+                               SELECTED FIELDS, WRITES FILE OF DUPS.\n+         JCL SAMPJCL(ENDCKDUP)\nENDVELMT  (MAIN/SAMP/QSAM) . SAMPLE FILE MATCH PROGRAM.\n+         JCL SAMPJCL(ENDVELMT)\nENDVPGLS  (MAIN/SAMP/QSAM) . SAMPLE FILE STRIP PROGRAM.\n+         JCL SAMPJCL(ENDVPGLS)\nENDVRTVL  (MAIN/SAMP/QSAM) . SAMPLE OF GENERAL FILE PROCESSING.\n+         JCL SAMPJCL(ENDVRTVL)\nENDVRTV2  (MAIN/SAMP/QSAM) . SAMPLE OF GENERAL FILE PROCESSING.\n+         JCL SAMPJCL(ENDVRTV2)\nENDVXPND  (MAIN/SAMP/QSAM) . SAMPLE PROGRAM TO EXPAND A COMPRESSED FILE.\n+         JCL SAMPJCL(ENDVXPND)\nENUM      (MAIN/SAMP/    ) . SAMPLE DEMONSTRATING USE OF ENUM.\nFAHRCENT  (MAIN/COMP/      . GIVEN A FAHRENHEIT TEMPERATURE, COMPUTES\n+                               AND DISPLAYS THE CELSIUS EQUIVALENT.\nFUNKEY    (MAIN/SAMP/QSAM) . ASSIGNS A FUNCTION KEY TO THE STRING TYPED\n+                               BY THE USER. USES ANY NUMBER OF COMMAND-\n+                               LINE ARGUMENTS.\nGENLDAT2  (SUBR/SAMP/QSAM) . GENERALIZED DATE SUBROUTINE THAT PROVIDES\n+                               Y2K SUPPORT WITH 4-DIGIT YEARS.\n+         LOADED BY FILE558(ALLDSNS, CALLGND2, CALLGND3)\n+         CALLED BY FILE558(MSASMRPT, MSMCHRPT)\n+         CALLED BY FILE563(DATEINFO, DATES)\nGETWORDS  (MAIN/EXTR/QSAM) . READS A TEXT FILE AND EXTRACTS ENGLISH\n+                               WORDS FOR USE IN CREATINGA LIST OF\n+                               COMMON ENGLISH WORDS.\nHELLO     (MAIN/SAMP/    ) . CLASSIC C HELLO PROGRAM\nHEXDUMP   (MAIN/SAMP/QSAM) . PRINT A FILE IN HEX AND CHARACTER FORMAT.\n+                            (ALSO SEE DUMPHEX).\nKBDTEST   (MAIN/CONV/    ) . CONVERTS THE VALUE FOR THE KEY PRESSED TO\n+                               DECIMAL AND DISPLAYS THE RESULT.\nMOFN      (MAIN/COMP/QSAM) . CALCULATES ALL POSSIBLE COMBINATIONS OF N\n+                               ITEMS TAKEN M AT A TIME AND WRITES THE\n+                               RESULTING DATA TO A FILE.\nMOFN2     (MAIN/SAMP/QSAM) . ANOTHER VERSION OF MOFN. THE FILE PRODUCED\n+                               IS READ BY PROGRAM SPLIT4.C.\nMOVSTRU   (MAIN/SAMP/    ) . SAMPLE SHOWING STRUCTURE DEFINITION,\n+                               MOVING DATA TO FIELDS WITHIN THE\n+                               STRUCTURES, MOVING ONE STRUCTURE\n+                               TO ANOTHER, PRINTING RESULTS.\nMSASMMOD  (MAIN/FMT /QSAM) . SAMPLE PROGRAM TO READ A FILE, SELECT SOME\n+                               RECORDS, REFORMAT THEM AND WRITE TO THE\n+                               OUTPUT FILE.\n+         JCL SAMPJCL(MSASMMOD)\nMSMCHMOD  (MAIN/FMT /QSAM) . ANOTHER SAMPLE FILE PROCESSING PROGRAM.\n+         JCL SAMPJCL(MSMCHMOD)\nMVSTRUC   (MAIN/SAMP/    ) . SAMPLE SHOWING STRUCTURE OPERATIONS.\nNETPAY    (MAIN/COMP/    ) . COMPUTES NET PAY USING HARD-CODED VALUES\n+                               FOR GROSS PAY, DEDUCTIONS, WITHHOLDING\n+                               PERCENTAGES, ETC.\nNOTRLBK   (MAIN/COPY/QSAM) . COPY A TEXT FILE, DROPPING ALL TRAILING\n+                               BLANKS ON EACH LINE.\nPRIME     (MAIN/COMP/    ) . FIND OUT IF A NUMBER IS PRIME.\nPRIMES    (MAIN/COMP/    ) . FIND OUT IF A NUMBER IS PRIME.\nPRINT     (MAIN/PRNT/QSAM) . PRINTS A TEXT FILE TO THE PRINTER.\nPRINTALL  (MAIN/COMP/    ) . DISPLAYS ALL HEX CHARACTERS 00-FF\nPRTEXACT  (MAIN/FMT /QSAM) . PRINT A FILE IN HEX AND CHARACTER.\nPRVINIT   (SUBR/SAMP/QSAM) . SAMPLE FUNCTION TO OPEN FILE\nPRVSEAR   (SUBR/SAMP/QSAM) . SAMPLE BINARY SEARCH OF A FILE\nPRVSERV   (HDR /SAMP/    ) . SAMPLE HEADER FILE FOR PRV... PGMS\nPRVTERM   (SUBR/SAMP/QSAM) . SAMPLE FILE CLOSE FUNCTION\nPTRARAY   (SUBR/SAMP/    ) . ARRAY CODING SAMPLE USING POINTER\nPUREBRE   (MAIN/STRP/QSAM) . SAMPLE FILE STRIP PROGRAM.\nRDVSMSEQ  (MAIN/SAMP/QSAM) . READS A VSAM KSDS, COUNTS RECORDS, PRINTS\n+                               RECORD TOTAL.\n+         JCL SAMPJCL(RDVSMSEQ)\nREADC     (MAIN/SAMP/QSAM) . READS AND PRINTS A TEXT FILE ONE BYTE AT\n+                               A TIME.\nREADDIR   (MAIN/SAMP/QSAM) . ATTEMPT TO READ A PDS DIRECTORY AS A FILE.\nREMOVE0A  (MAIN/COPY/QSAM) . COPY A FILE, REMOVING ALL NEWLINE'S (X'0A')\nRENGREG   (MAIN/SAMP/QSAM) . RENAMES A FILE.\nRUNTESTS  (MAIN/SAMP/QSAM) . SAMPLE PROGRAM READS FILES INTO MEMORY\n+                               ARRAYS AND COMPARES FOR DUPLICATES.\n+         JCL SAMPJCL(RUNTESTS)\nSETDIARY  (MAIN/SAMP/QSAM) . SAMPLE PROGRAM TO UPDATE A SIMPLE TEXT\n+                               FILE WITH ENTRIES FROM A \"SUSPENSE\" FILE\n+                               THAT CONTAINS RECURRING \"TO-DO\" ITEMS.\nSHFTRITE  (MAIN/SAMP/QSAM) . READS A TEXT FILE AND SHIFTS DATA RIGHT\n+                               AND EXPANDS TABS TO BLANKS USING VALUES\n+                               SUPPLIED BY THE CALLER.\nSKELETON  (MAIN/SAMP/QSAM) . GENERIC CODE TO USE IN WRITING A PROGRAM.\nSORTNUM   (MAIN/SAMP/QSAM) . BUBBLE SORT OF A NUMERIC ARRAY.\nSORTSTR   (MAIN/SAMP/QSAM) . SORTS A TYPED IN LIST OF NAMES INTO AN\n+                               ARRAY.\nSPLIT4    (MAIN/SPLT/QSAM) . SPLITS AN INPUT FILE INTO EIGHT OUTPUT\n+                               FILES. READS THE FILE CREATED BY\n+                               PROGRAM MOFN2().\nSTMENU2   (MAIN/RPRT/QSAM) . READS FILE, PRODUCES REPORT.\nSTRGINS   (SUBR/SAMP/    ) . INSERTS A CHARACTER IN A STRING.\nSUBRUPDT  (MAIN/SAMP/QSAM) . UPDATES A MASTER FILE WITH A TRANSACTION\n+                               FILE USING ADD/CHANGE/DELETE LOGIC.\nTABTOSP   (SUBR/XPND/    ) . EXPANDS TAB CHARACTERS TO EIGHT BLANKS.\nTESTBOX   (MAIN/SAMP/    ) . SAMPLE OF ENCLOSING A STRING IN A BOX.\nTESTHEX   (MAIN/DSPL/    ) . DISPLAYS DECIMAL EQUIVALENTS OF SELECTED\n+                               HEX VALUES.\nTRYEDIT   (MAIN/SAMP/QSAM) . TEST THE EDIT() SUBROUTINE (SEE EDIT.C)\nTRYFMOD   (MAIN/SAMP/    ) . DEMONSTRATE USE OF THE FMOD() FUNCTION.\nTYPE2     (MAIN/SAMP/QSAM) . READS STRINGS FROM A FILE.\nUNUCASE   (MAIN/CVRT/QSAM) . COPY UPPER-CASE-ONLY FILE CREATING AN UPPER\n+                               AND LOWER CASE FILE.\nUPPRCASE  (MAIN/CVRT/QSAM) . COPY FILE CHANGING ALL LOWER-CASE ALPHA\n+                               CHARACTERS TO UPPER-CASE.\nVALUES    (MAIN/SAMP/    ) . SAMPLE OF FUNCTION THAT ACCEPTS TWO INTEGER\n+                               ARGUMENTS.\nVENUS     (MAIN/SAMP/QSAM) . SAMPLE USING PRINTF() TO DISPLAY A STRING.\nVSAMCALC  (MAIN/COMP/    ) . COMPUTES PHYSICAL RECORDS-PER-TRACK ON A\n+                               3390 DISK FOR RECORDS SIZES IN\n+                               MULTIPLES OF 4096 BYTES.\nWAYNE     (MAIN/COMP/QSAM) . ASKS FOR AGE IN YEARS, CALCULATES, AND\n+                              DISPLAYS AGE IN DAYS.\nWLOOP     (MAIN/LOOP/QSAM) . SHOWS A WHILE LOOP USED TO CONTROL PRINTING\nWORDCNTF  (MAIN/CNTR/QSAM) . COUNTS WORDS IN A TEXT FILE.\nWRITE     (MAIN/FMT /QSAM) . WRITES FORMATTED DATA TO A FILE.\nWRITEC    (MAIN/SAMP/QSAM) . WRITES ONE CHARACTER AT A TIME TO A FILE.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$BRAKETS": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x12\\x1f\\x01\\x02\\x12\\x1f\\x14V\\x00\\x81\\x00\\x81\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-05-01T00:00:00", "modifydate": "2002-05-01T14:56:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "BC0THOR"}, "text": "Use of brackets to enclose subscript values in the C language causes\nproblems, since the compiler expects a left-bracket to be given by\nthe hex value AD, and the right bracket by the hex value BD. Another\nunusual character is the circumflex (upside-down v) which the compiler\nexpects to be represented by hex 5F.\n\nThe problem is that the terminals used for mainframe access may not\ndisplay the brackets when the keys showing them are pressed. Often\nyou get a cent-sign for a left bracket, a vertical bar (logical-or)\nfor the right bracket and a logical-not sign for the circumflex.\nAt first, the problem seems simple: just get used to reading cent-sign\nas left bracket and or-sign as right bracket. Unfortunately, though,\nthe hex values used for these characters are not those expected by\nthe C language compiler.\n\nOne thing you can do is to use the native key displays and get used to\nthinking a not-sign is a circumflex, a cent-sign is a left bracket, and\nan or-sign is a right bracket during editing. then, just before saving\nand compiling, change the values to those needed by the compiler. And\nof course you'd have to change them back when you next bring the program\nup for editing. a lot of the sting can be removed by use of edit macros\nin ISPF.\n\nAnother possibility would be to try to get used to seeing the y-umlaut\ncharacter as left bracket, and the double-quote as a right bracket, as\nthey appear that way on my screen when the true compiler values for the\nbrackets are used in the source code. One problem with this is that you\nhave to enter these values in hex, as there is no key for them (the\ndouble quote that displays is not really a double quote).\n\nAfter thinking it over, I decided I'd like my cake and eat it, too. I\ndecided I'd like to see real brackets while I was editing, and also\nhave the program compile properly with minimal side effects. My solution\nis:\n1) Adjust my TSO EDIT session so that I see brackets when I hit the\n   bracket keys. We use the IBM Reflection product here, and I had to\n   do the following for this:\n   a) Click Setup, then Terminal. In National Character Set, choose\n      US English (037) and click the Country Extended Graphics Code\n      box, then click OK.\n   b) Click Setup, then Keyboard. To set up a key, the top keyboard\n      represents your PC keyboard, and the bottom one a \"standard\"\n      terminal keyboard. When you click a key on the top keybaord,\n      the corresponding key on the terminal keyboard will be\n      highlighted, if there is a mapping set up for them. You can also\n      choose to transmit an ANSI value rather than a terminal keyboard\n      value, which is what needs to be done here, since the standard\n      terminal keyboard doesn't have brackets nor circumflex. Here is\n      the procedure:\n        1) Click left bracket on the top keyboard.\n        2) If the REMOVE box in the middle is highlighted, click it.\n        3) Click the radio buttons for COMMANDS and ALL COMMANDS.\n        4) Scroll the bottom window to the .TransmitANSI \"\" near the\n           bottom of the list and clisk it so it appears in the Script\n           window above.\n        5) Click on the right side of the Script window until the\n           highlighting goes away, then move the cursor between the\n           two double-quotes and press the left bracket key, which\n           will now appear between the quotes.\n        6) Click the Map button in the middle of the screen\n        7) Repeat the above for the right bracket key in 1) and 5).\n        8) Repeat the above for the circumflex. Note here, though,\n           that you also have to click the shift key, then the 6 key\n           for circumflex.\n2) At this point, when you press a bracket or circumflex key, that is\n   what will appear on your terminal screen, and the associated hex\n   value will be in that byte when the dataset is saved.\n   a) Downside: you no longer have the not-sign, cent-sign, or or-sign\n      unless you go back and re-map them to their original values\n\n3) Next, get in an edit session, type the circumflex and both brackets\n   and then type HEX on the command line to see the values. I get hex\n   B0 for the circumflex, hex BA for the left bracket, and hex BB for\n   the right bracket. If you get other values, you will have to modify\n   the assembler program CBRAKETS and the CLIST BKT.\n\n4) There is a CLIST in FILE561 called BKT that is an EDIT MACRO that\n   will convert all trigraphs and true compiler values for brackets\n   and circumflex to the values needed in ISPF EDIT so you can see\n   them properly while editing. This CLIST needs to be in a CLIST\n   library in your SYSPROC concatenation while you are editing. When\n   you bring in a C language program, use the BKT CLIST to make all the\n   brackets and circumflexes visible as such on the screen.\n\n5) For compiling the program, I built a solution that needs 2 CLISTs,\n   some JCL, and an assembler program:\n   a) CLIST CCMP is in FILE561. This CLIST saves the file being edited\n      and then submits a job that will convert/compile/linkedit the\n      program. This CLIST should be in a library in the SYSPROC\n      concatenation during the EDIT session. You will have to change the\n      last line to name the library that will contain the JCL EDCCB.\n   b) CLIST CEDIT is in FILE561, and is an EDIT MACRO invoked by the\n      CCMP CLIST above. It should need no changes, and should be in a\n      library in the SYSPROC concatenation during the edit session.\n      This edit macro accesses the JCL member EDCCB, changes all\n      occurrences of XXXXXXXX to the current program's member name,\n      then submits the JCL for execution.\n   c) Assembler program CBRAKETS is in FILE558. It must be assembled and\n      linked into a load library before executing the CCMP CLIST. It\n      reads in a C language source program and changes all occurrences\n      of the TSO EDIT values for brackets and circumflexes to the values\n      required by the C language compiler. When this program is executed\n      by the EDCCB JCL, it creates a temporary file that is fed into\n      the C language compiler.\n   d) JCL member EDCCB is in FILE560. It must be modified before use to\n      include a valid job card. Also change the DSNAMEs in the STEPLIB\n      and SYSIN DD statements in the CBRAKETS step, in the STEPLIB and\n      SYSLIB DD's in the COMPILE step, and in the STEPLIB, SYSLIB, and\n      SYSLMOD DD statements in the BIND step.\n\n6. Once in place, when you are ready to try a compile on the program\n   you are editing, invoke the CCMP CLIST which will:\n   a) Save the program source code you are editing (must be in a PDS\n      or PDSE).\n   b) Edit the EDCCB JCL and change all occurrences of XXXXXXXX to\n      the name of the member you were editing.\n   c) Submit the resulting EDCCB JCL which will:\n      1) Read in the saved C language source program and copy it to\n         a temporary file after changing all brackets and circumflexes\n         to the values the compiler likes.\n      2) Run a C language compile of the temporary file created above.\n      3) Bind (linkedit) the program to the load library you gave as\n         SYSLMOD using the same member name as the source program.\n\n7. Note: While this process takes care of the bracket and circumflex\n         in the source program itself, it cannot do so for any header\n         files or other things brought in at compile time. Therefore,\n         any header files must be in native form with the brackets and\n         circumflex characters set to the values needed by the compiler.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$SAMPJC$": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00(\\x00\\x97\\x11\\x0f\\x01\\x02\\x12\\x9f\\x01E\\x00\\x0c\\x00\\x08\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1997-04-20T00:00:00", "modifydate": "2002-05-09T01:45:28", "lines": 12, "newlines": 8, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBL JOB (ACCT#),PDSLOAD,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*\n//LOA1 EXEC PGM=PDSLOAD            /* FROM FILE 093 - LOAD ON FILE 035\n//STEPLIB  DD DISP=SHR,DSN=CBT.CBT445.FILE035.PDS\n//SYSUT1   DD DISP=SHR,DSN=SBGOLOB.CBT444.FILE559($SAMPJCL)\n//SYSPRINT DD SYSOUT=*\n//SYSUT2   DD DISP=(NEW,CATLG,DELETE),DSN=SBGOLOB.FILE559.SAMPJCL,\n//   DCB=(RECFM=FB,LRECL=80,BLKSIZE=8000),\n//   SPACE=(TRK,(45,30,89),RLSE),UNIT=SYSALLDA,VOL=SER=DATA04\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$SAMPJCL": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x12\\x9f\\x01\\x02\\x12\\x9f\\x01D\\x0ez\\x0ez\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-05-09T00:00:00", "modifydate": "2002-05-09T01:44:00", "lines": 3706, "newlines": 3706, "modlines": 0, "user": "BC0THOR"}, "text": "./ ADD NAME=$$README 0101-00277-02128-1556-00035-00038-00000-BC0THOR\n                  C LANGUAGE SAMPLE JCL NOTES\n\n1. The JCL in this library is set up to compile, linkedit (bind), and\n   execute the programs in the SAMPSRC library. These are mostly the C\n   programs (not C++ programs) in the CBC.SCBCSAM library supplied by\n   IBM, and are essentially the same as those in that library with minor\n   cosmetic changes. In a few cases, the code has been fixed where a\n   problem was found. On occasion the program is expanded to improve the\n   sample. JOB cards and DSNAMES will have to be changed, of course.\n2. Since the C Language compiler accepts values for the square brackets\n   and circumflex (hat) that do not display correctly in ISPF EDIT, I\n   assume the user has set up the keyboard to properly display these\n   characters. Therefore, in order for the compile to work, the source\n   must be converted to use compiler-expected values. The CBRAKETS\n   step does this. Only the main program is processed by CBRAKETS,\n   though, so header files must remain in compiler format.\n3. A clist called BKT can be used to convert brackets and circumflexes\n   in a file to the values that display properly in ISPF EDIT. When\n   working with the C language, you may want to copy that CLIST to\n   your personal CLIST library. In addition to simple conversion, it\n   also converts trigraphs to single character brackets. After the\n   conversion, it counts left and right brackets, braces, and paren-\n   theses and warns you if there are differences between the left and\n   right counts.\n4. The C language permits specifying a dataset by its DSNAME, or by\n   DDNAME. When the DSNAME is given in the fopen() function, code is\n   generated to allocate that dataset dynamically. If it is an output\n   file that does not exist, it will be created and allocated dynam-\n   ically. When fopen() provides a DDNAME, the DD statement is used if\n   included in the execution JCL. If the DD statement is missing, and\n   it is an output file, a temporary dataset is created that is\n   deleted at end of execution.\n5. SYSPRINT and SYSOUT are used by certain functions, such as fprint()\n   and perror(). If omitted from the execution JCL, they are dynamically\n   allocated.\n./ ADD NAME=ABAL     0100-02121-02121-1654-00020-00020-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//*******************************************************************\n//*                 BC0THOR.PDS.JCL(ABALC)                          *\n//* REFORMATS A C-LANGUAGE SOURCE PROGRAM.                          *\n//*******************************************************************\n//SCRATCH  EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n DELETE BC0THOR.DEL.ABALC\n//*\n//ABAL     EXEC  PGM=ABAL\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//INPUT1   DD    DSN=BC0THOR.PDS.C(ABAL),DISP=SHR\n//OUTPUT1  DD    DSN=BC0THOR.DEL.ABALC,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(10,5),RLSE),\n//         DSORG=PS,RECFM=FB,LRECL=80\n./ ADD NAME=BLDFUNCD 0103-00312-00313-1347-00024-00024-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//*******************************************************************\n//*                 BC0THOR.PDS.JCL(BLDFUNCD)                       *\n//* C PROGRAM TO BUILD C LANGUAGE FUNCTION CODE LIST FROM PORTIONS  *\n//* OF THE RUNTIME FUNCTION LIBRARY.                                *\n//*******************************************************************\n//SCRATCH  EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n DELETE BC0THOR.TST.FUNCTION.LIST\n/*\n//BLDFUNCD EXEC  PGM=BLDFUNCD\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSOUT   DD    SYSOUT=*\n//INPUT1   DD    DSN=BC0THOR.TST.FUNCTION.TXT,DISP=SHR\n//OUTPUT1  DD    DSN=BC0THOR.TST.FUNCTION.LIST,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(15,5),RLSE),\n//         DSORG=PS,RECFM=FB,LRECL=117\n./ ADD NAME=CALLCPGM 0102-01214-02113-1104-00014-00017-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//*******************************************************************\n//*                 BC0THOR.PDS.JCL(CALLCPGM)                       *\n//* TEST CALLS TO A C LANGUAGE SUB-PROGRAM.                         *\n//********************************************************************\n//CALLCPGM EXEC  PGM=CALLCPGM\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//INPUT1   DD    DSN=BC0THOR.PDS.DATA(CALLCPGM),DISP=SHR\n//PRINT1   DD    SYSOUT=*\n./ ADD NAME=CAPACITR 0102-02121-02121-1820-00021-00020-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//*******************************************************************\n//*                 BC0THOR.PDS.JCL(CAPACITR)                       *\n//* EXECUTES THE C-LANGUAGE CAPACITR PROGRAM WHICH ACCEPTS TWO      *\n//* NUMBERS REPRESENTING THE AREA OF ONE PLATE OF A SIMPLE CAPACITOR*\n//* IN SQUARE INCHES, AND A SECOND NUMBER THAT PROVIDES THE DISTANCE*\n//* BETWEEN THE PLATES IN INCHES. THE CAPACITANCE IS COMPUTED AND   *\n//* PRINTED.                                                        *\n//*******************************************************************\n//CAPACITR EXEC  PGM=CAPACITR\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSIN    DD    *\n2597.563 0.0125\n96.7 1.6325\n0\n./ ADD NAME=CBC3GAS1 0107-00224-00277-1842-00050-00013-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//********************************************************************\n//*                  CBC.TRIGON.SAMPJCL(CBC3GAS1)                    *\n//* THIS EXAMPLE SHOWS HOW TO WRITE TO AN ASA FILE. A FILE FOR OUTPUT*\n//* WITH RECFM=FBA IS OPENED AND SEVERAL RECORDS ARE WRITTEN TO IT:  *\n//*  1. ABCDEF WITH DOUBLESPACE BEFORE                               *\n//*  2. 345 WITH SKIP-TO-HEAD-OF-FORM BEFORE                         *\n//*  3. 9034 WITH FOUR SPACES BEFORE                                 *\n//* NOTES:                                                           *\n//*  1. WHEN FOPEN SUPPLIES A DSNAME, THE FILE IS OPENED IF IT IS AN *\n//*     EXISTING CATALOGED DATASET. IF NOT, IT IS DYNAMICALLY CREATED*\n//*  2. WHEN FOPEN SUPPLIES A DDNAME THE DD STATEMENT SUPPLIED IN THE*\n//*     EXECUTION TIME JCL IS USED, IF PRESENT. IF NOT PRESENT, A    *\n//*     TEMPORARY FILE IS ALLOCATED AND DELETED AT END OF JOB.       *\n//********************************************************************\n//* 1. COMPILE PROGRAM CBC3GAS1 AND BIND CALL AS CBC3GAS1            *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3GAS1. ENDS RC=0 WITH NO     *\n//*    OUTPUT CREATED.                                               *\n//********************************************************************\n//********************************************************************\n//* COMPILE AND BIND THE PROGRAM                                     *\n//********************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GAS1)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GAS1)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GAS1(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//DELETE   EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n DELETE BC0THOR.DEL.PRINT1\n//*\n//CBC3GAS1 EXEC  PGM=CBC3GAS1\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//STDERR01 DD    SYSOUT=*              <== DEFAULT ERROR FILE\n//STDOUT01 DD    SYSOUT=*              <== DEFAULT OUTPUT FILE\n//STDIN01  DD    *                     <== DEFAULT INPUT FILE\n//PRINT1   DD    DSN=BC0THOR.DEL.PRINT1,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(5,1),RLSE),\n//         DSORG=PS,RECFM=FBA,LRECL=80\n./ ADD NAME=CBC3GCL1 0103-00230-00277-1841-00029-00013-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//********************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GCL1)                     *\n//* THIS EXAMPLE SHOWS HOW TO GET THE LOCAL TIME FORMATTED BY THE    *\n//* CURRENT LOCALE.                                                  *\n//* 1. COMPILE PROGRAM CBC3GCL1 AND BIND CALL AS CBC3GCL1            *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3GCL1                        *\n//********************************************************************\n//********************************************************************\n//* COMPILE AND BIND THE PROGRAM                                     *\n//********************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GCL1)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GCL1)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GCL1(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3GCL1 EXEC  PGM=CBC3GCL1\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3GDC1 0102-00230-00277-1839-00035-00014-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GDC1)                    *\n//* THIS EXAMPLE DEMONSTRATES ARITHMETIC OPERATIONS ON DECIMAL      *\n//* VARIABLES. OUTPUT IS WRITTEN TO THE SYSPRINT FILE VIA THE PRINTF*\n//* FUNCTION.                                                       *\n//* ALL NECESSARY DD STATEMENTS/DATASETS ARE DYNAMICALLY ALLOCATED  *\n//* AS NEEDED BY THIS PROGRAM. HOWEVER, THE SYSPRINT DD STATEMENT   *\n//* IS PROVIDED TO CAUSE OUTPUT TO BE GENERATED WITHIN THE JOB UNDER*\n//* SDSF.                                                           *\n//*******************************************************************\n//* 1. COMPILE PROGRAM CBC3GDC1 AND BIND CALL AS CBC3GDC1            *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3GDC1                        *\n//********************************************************************\n//********************************************************************\n//* COMPILE AND BIND THE PROGRAM                                     *\n//********************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GDC1)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GDC1)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GDC1(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3GDC1 EXEC  PGM=CBC3GDC1\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3GDC2 0102-00249-00277-1838-00034-00018-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GDC2)                    *\n//* THIS EXAMPLE SHOWS HOW TO USE A RELATIONAL EXPRESSION WITH THE  *\n//* DECIMAL DATA TYPE                                               *\n//* ALL NECESSARY DD STATEMENTS/DATASETS ARE DYNAMICALLY ALLOCATED  *\n//* AS NEEDED BY THIS PROGRAM. HOWEVER, THE SYSPRINT DD STATEMENT   *\n//* IS PROVIDED TO CAUSE OUTPUT TO BE GENERATED WITHIN THE JOB UNDER*\n//* SDSF.                                                           *\n//*******************************************************************\n//* 1. COMPILE PROGRAM CBC3GDC2 AND BIND CALL AS CBC3GDC2            *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3GDC2                        *\n//********************************************************************\n//********************************************************************\n//* COMPILE AND BIND THE PROGRAM                                     *\n//********************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GDC2)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GDC2)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GDC2(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3GDC2 EXEC  PGM=CBC3GDC2\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3GDC3 0103-00249-00277-1837-00029-00018-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GDC3)                    *\n//* THIS EXAMPLE DEMONSTRATES THE USE OF THE DECIMAL DATA TYPE      *\n//*******************************************************************\n//* 1. COMPILE PROGRAM CBC3GDC3 AND BIND CALL AS CBC3GDC3            *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3GDC3                        *\n//********************************************************************\n//********************************************************************\n//* COMPILE AND BIND THE PROGRAM                                     *\n//********************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GDC3)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GDC3)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GDC3(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3GDC3 EXEC  PGM=CBC3GDC3\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3GDC4 0101-00355-00355-1250-00017-00028-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 BC0THOR.PDS.JCL(CBC3GC4)                        *\n//* THIS EXAMPLE DEMONSTRATES THE USE OF THE DECIMAL DATA TYPE      *\n//********************************************************************\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3GDC4 EXEC  PGM=CBC3GDC4\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3GDI1 0102-00249-00277-1834-00039-00017-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GDI1)                    *\n//* THIS EXAMPLE DEMONSTRATES HOW TO PRINT THE __AMRC STRUCTURE     *\n//*                                                                 *\n//* SINCE THE FOPEN() FUNCTION SPECIFIES DSNAME TEST.CBC3GDI1, IT   *\n//* WILL BE DYNAMICALLY ALLOCATED WITH TSO USERID AS THE HIGH LEVEL *\n//* QUALIFIER WHEN THE PROGRAM EXECUTES.                            *\n//*                                                                 *\n//* IF THE TEST.CBC3GDI1 DATASET EXISTS, IT IS ALLOCATED AS DISP=OLD*\n//* AND IS OVER-WRITTEN WITH NEW DATA.                              *\n//*                                                                 *\n//* THE PROGRAM TAKES A WHILE TO EXECUTE, AS IT WRITES UNTIL THE    *\n//* OUTPUT DATASET IS OUT OF EXTENTS (SB37 ABEND).                  *\n//*******************************************************************\n//* 1. COMPILE PROGRAM CBC3GDI1 AND BIND CALL AS CBC3GDI1            *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3GDI1                        *\n//********************************************************************\n//********************************************************************\n//* COMPILE AND BIND THE PROGRAM                                     *\n//********************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GDI1)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GDI1)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GDI1(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3GDI1 EXEC  PGM=CBC3GDI1\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3GDI2 0103-00249-00277-1832-00044-00023-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GDI2)                    *\n//* THIS EXAMPLE DEMONSTRATES HOW TO USE SIGIOERR                   *\n//*                                                                 *\n//* SINCE THE FOPEN() FUNCTION SPECIFIES DSNAME TEST.CBC3GDI2, IT   *\n//* WILL BE DYNAMICALLY ALLOCATED WITH TSO USERID AS THE HIGH LEVEL *\n//* QUALIFIER WHEN THE PROGRAM EXECUTES.                            *\n//*                                                                 *\n//* IF THE TEST.CBC3GDI2 DATASET EXISTS, IT IS ALLOCATED AS DISP=OLD *\n//* AND IS OVER-WRITTEN WITH NEW DATA.                              *\n//*                                                                 *\n//* THE PROGRAM TAKES A WHILE TO EXECUTE, AS IT WRITES UNTIL THE    *\n//* OUTPUT DATASET IS OUT OF EXTENTS.                               *\n//*                                                                 *\n//* SINCE SIGIOERR WRITES TO DDNAME SYSOUT, IT IS INCLUDED IN THE   *\n//* JCL SO THAT THE OUTPUT WILL BE GROUPED WITH THE JOB IN SDSF.    *\n//* LIKEWISE, SYSPRINT IS SUPPLIED FOR PRINTF().                    *\n//*******************************************************************\n//* 1. COMPILE PROGRAM CBC3GDI2 AND BIND CALL AS CBC3GDI2            *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3GDI2                        *\n//********************************************************************\n//********************************************************************\n//* COMPILE AND BIND THE PROGRAM                                     *\n//********************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GDI2)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GDI2)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GDI2(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3GDI2 EXEC  PGM=CBC3GDI2\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSOUT   DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3GDLI 0101-00249-00277-1828-00033-00017-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GDLI)                    *\n//* THIS EXAMPLE SHOWS HOW TO DETERMINE WHETHER THE SAA C OR POSIX  *\n//* LOCALE IS IN EFFECT                                             *\n//*                                                                 *\n//* THE SYSPRINT DD STATEMENT IS INCLUDED TO KEEP THE PRINTF() OUT- *\n//* PUT GROUPED WITH THE JOB OUTPUT IN SDSF.                        *\n//*******************************************************************\n//* 1. COMPILE PROGRAM CBC3GDLI AND BIND CALL AS CBC3GDLI            *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3GDLI                        *\n//********************************************************************\n//********************************************************************\n//* COMPILE AND BIND THE PROGRAM                                     *\n//********************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GDLI)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GDLI)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GDLI(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3GDLI EXEC  PGM=CBC3GDLI\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3GEV1 0101-00249-00277-1828-00034-00018-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GEV1)                    *\n//* THIS EXAMPLE SHOWS HOW ENVIRONMENT VARIABLES ARE PROPAGATED     *\n//* TWO PROGRAMS ARE INVOLVED, CBC3GEV1 AND CBC3GEV2                *\n//* ALL NECESSARY DD STATEMENTS/DATASETS ARE DYNAMICALLY ALLOCATED  *\n//* AS NEEDED BY THIS PROGRAM. HOWEVER, THE SYSPRINT DD STATEMENT   *\n//* IS PROVIDED TO CAUSE OUTPUT FROM PRINTF() TO BE GROUPED WITH THE*\n//* SDSF JOB OUTPUT.                                                *\n//*******************************************************************\n//* 1. COMPILE PROGRAM CBC3GEV1 AND BIND CALL AS CBC3GEV1            *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3GEV1                        *\n//********************************************************************\n//********************************************************************\n//* COMPILE AND BIND THE PROGRAM                                     *\n//********************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GEV1)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GEV1)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GEV1(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3GEV1 EXEC  PGM=CBC3GEV1\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3GHF1 0101-00249-00277-1826-00032-00017-00000-BC0THOR\n//BC0THORJ JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//********************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GHF1)                     *\n//* THIS EXAMPLE SHOWS HOW UNNAMED PIPES MAY BE USED                 *\n//* NOTE THAT THE OUTPUT FROM THE PRINTF FUNCTION IS WRITTEN TO THE  *\n//* SYSPRINT DD STATEMENT, IF IT IS SUPPLIED IN THE EXECUTION JCL. IF*\n//* NOT, THE PRINTF OUTPUT IS DYNAMICALLY ALLOCATED TO A SYSOUT=A    *\n//* FILE.                                                            *\n//* 1. COMPILE PROGRAM CBC3GHF1 AND BIND CALL AS CBC3GHF1            *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3GHF1. ENDS WITH RC=4        *\n//********************************************************************\n//********************************************************************\n//* COMPILE AND BIND THE PROGRAM                                     *\n//********************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GHF1)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GHF1)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GHF1(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3GHF1 EXEC  PGM=CBC3GHF1\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3GHF2 0102-00252-00277-1823-00029-00017-00000-BC0THOR\n//BC0THORJ JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//********************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GHF2)                     *\n//* THIS EXAMPLE SHOWS HOW NAMED PIPES MAY BE USED                   *\n//* 1. COMPILE PROGRAM CBC3GHF2 AND BIND CALL AS CBC3GHF2            *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3GHF2. OPEN FAILS FOR THE    *\n//*    NAMED PIPE, THOUGH THE PROGRAMS ENDS WITH RC=0.               *\n//********************************************************************\n//********************************************************************\n//* COMPILE AND BIND THE PROGRAM                                     *\n//********************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GHF2)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GHF2)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GHF2(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3GHF2 EXEC  PGM=CBC3GHF2\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3GHF3 0103-00250-00277-1819-00040-00023-00000-BC0THOR\n//BC0THORJ JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//********************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GHF3)                     *\n//* THIS EXAMPLE USES HFS STREAM I/O. IT DOES NOT EXECUTE PROPERLY   *\n//* AS CODED. ORIGINAL CODE DOES NO BETTER.                          *\n//* 1. COMPILE PROGRAM CBC3GHF3 AND BIND CALL AS CBC3GHF3            *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3GHF3                        *\n//* 3. DELETE THE FILES CREATED BY THE SAMPLE PROGRAM                *\n//********************************************************************\n//********************************************************************\n//* COMPILE AND BIND THE PROGRAM                                     *\n//********************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GHF3)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GHF3)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GHF3(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n/*\n//CBC3GHF3 EXEC  PGM=CBC3GHF3\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSOUT   DD    SYSOUT=*\n//*******************************************************************\n//* SCRATCH THE WORK FILES CREATED BY THE SAMPLE PROGRAM            *\n//*******************************************************************\n//SCRATCH  EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n DELETE TEST.CBC3GHF3.STREAM\n DELETE TEST.CBC3GHF3.DATA\n./ ADD NAME=CBC3GIP0 0101-00264-00277-1809-00042-00017-00000-BC0THOR\n//BC0THORJ JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//********************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GIP0)                     *\n//* SAMPLE PROGRAM TO LIST MEMBERS IN A PDS DIRECTORY                *\n//* NOTE THAT THE MAIN() CALLING PROGRAM WAS WRITTEN BY TRIGON, SINCE*\n//* THE SAMPLE PROGRAM IS ONLY A SUBROUTINE.                         *\n//* 1. COMPILE SUBPROGRAM CBC3GIP0 NCAL AS CBC3GIP1                  *\n//* 2. COMPILE MAIN PROGRAM CBC3GIP0 CALL AS CBC3GIP0                *\n//* 3. EXECUTE FINAL LOAD MODULE FOR CBC3GIP0                        *\n//********************************************************************\n//********************************************************************\n//* COMPILE AND BIND SUBPROGRAM CBC3GIP1 NCAL AS CBC3GIP1            *\n//********************************************************************\n//COMPBND1 EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GIP1)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GIP1)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GIP1(R)\n//********************************************************************\n//* COMPILE AND BIND MAIN PROGRAM CBC3GIP0 WITH CALL AS CBC3GIP0     *\n//********************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GIP0)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GIP0)'\n//BIND.SYSIN DD *\n INCLUDE MYLIB(CBC3GIP1)\n ENTRY CEESTART\n NAME CBC3GIP0(R)\n//MYLIB    DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3GIP0 EXEC  PGM=CBC3GIP0\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3GIP1 0101-00250-00277-1748-00037-00021-00000-BC0THOR\n//BC0THORJ JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//********************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GIP1)                     *\n//* THIS EXAMPLE SHOWS HOW TO CREATE A LIST OF MEMBERS OF A PDS UNDER*\n//* MVS. A HEADER FILE CBC3GIP2 IS USED.                             *\n//* THE PDS USED IS HARD-CODED IN THE OPEN STATEMENT IN THE PROGRAM  *\n//* AS PDS.C, WHICH IS DYNAMICALLY ALLOCATED, SINCE NO DDNAME IS     *\n//* PROVIDED IN THE OPEN.                                            *\n//* NOTE THAT THE OUTPUT FROM THE PRINTF FUNCTION IS WRITTEN TO THE  *\n//* SYSPRINT DD STATEMENT, IF IT IS SUPPLIED IN THE EXECUTION JCL. IF*\n//* NOT, THE PRINTF OUTPUT IS DYNAMICALLY ALLOCATED TO A SYSOUT=A    *\n//* FILE.                                                            *\n//********************************************************************\n//* 1. COMPILE PROGRAM CBC3GIP1 AND BIND CALL AS CBC3GIP1            *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3GIP1                        *\n//********************************************************************\n//********************************************************************\n//* COMPILE AND BIND THE PROGRAM                                     *\n//********************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GIP1)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GIP1)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GIP1(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3GIP1 EXEC  PGM=CBC3GIP1\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3GMF1 0106-00257-00277-1824-00033-00016-00000-BC0THOR\n//BC0THORJ JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//********************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GMF1)                     *\n//* THIS EXAMPLE SHOWS HOW TO REMOVE MEMBERS OF A PDS                *\n//* NOTE THAT THE OUTPUT FROM THE PRINTF FUNCTION IS WRITTEN TO THE  *\n//* SYSPRINT DD STATEMENT, IF IT IS SUPPLIED IN THE EXECUTION JCL. IF*\n//* NOT, THE PRINTF OUTPUT IS DYNAMICALLY ALLOCATED TO A SYSOUT=A    *\n//* FILE.                                                            *\n//* 1. COMPILE PROGRAM CBC3GMF1 AND BIND CALL AS CBC3GMF1            *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3GMF1                        *\n//********************************************************************\n//********************************************************************\n//* COMPILE AND BIND THE PROGRAM                                     *\n//********************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GMF1)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GMF1)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GMF1(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3GMF1 EXEC  PGM=CBC3GMF1\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSOUT   DD    SYSOUT=*              <== DEFAULT OUTPUT FILE\n./ ADD NAME=CBC3GMF2 0101-00257-00277-1743-00033-00018-00000-BC0THOR\n//BC0THORJ JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//********************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GMF2)                     *\n//* THIS EXAMPLE SHOWS HOW TO RENAME A PDS.                          *\n//* NOTE THAT THE OUTPUT FROM THE PRINTF FUNCTION IS WRITTEN TO THE  *\n//* SYSPRINT DD STATEMENT, IF IT IS SUPPLIED IN THE EXECUTION JCL. IF*\n//* NOT, THE PRINTF OUTPUT IS DYNAMICALLY ALLOCATED TO A SYSOUT=A    *\n//* FILE.                                                            *\n//* 1. COMPILE PROGRAM CBC3GMF2 AND BIND CALL AS CBC3GMF2            *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3GMF2                        *\n//********************************************************************\n//********************************************************************\n//* COMPILE AND BIND THE PROGRAM                                     *\n//********************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GMF2)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GMF2)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GMF2(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3GMF2 EXEC  PGM=CBC3GMF2\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSOUT   DD    SYSOUT=*              <== DEFAULT OUTPUT FILE\n./ ADD NAME=CBC3GMT1 0102-00258-00277-1741-00036-00017-00000-BC0THOR\n//BC0THORJ JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//********************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GMT1)                     *\n//* MULTI-TASKING FACILITY (MTF) SAMPLE PROGRAM 1.                   *\n//* !!! CREATE FILES A.INPUT, B.INPUT, C.INPUT, AND D.INPUT BEFORE   *\n//* !!! EXECUTING THIS PROGRAM. SEE COMMENTS IN THE BEGINNING OF THE *\n//* !!! SOURCE CODE FOR CBC3GMT1.                                    *\n//* NOTE THAT THE OUTPUT FROM THE PRINTF FUNCTION IS WRITTEN TO THE  *\n//* SYSPRINT DD STATEMENT, IF IT IS SUPPLIED IN THE EXECUTION JCL. IF*\n//* NOT, THE PRINTF OUTPUT IS DYNAMICALLY ALLOCATED TO A SYSOUT=A    *\n//* FILE.                                                            *\n//********************************************************************\n//* 1. COMPILE PROGRAM CBC3GMT1 AND BIND CALL AS CBC3GMT1            *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3GMT1                        *\n//********************************************************************\n//********************************************************************\n//* COMPILE AND BIND THE PROGRAM                                     *\n//********************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GMT1)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GMT1)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GMT1(R)\n//********************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                       *\n//********************************************************************\n//CBC3GMT1 EXEC  PGM=CBC3GMT1\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3GMT2 0102-00258-00277-1739-00029-00017-00000-BC0THOR\n//BC0THORJ JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//********************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GMT2)                     *\n//* MULTI-TASKING FACILITY (MTF) SAMPLE PROGRAM 2.                   *\n//* !!! PRODUCES NO OUTPUT. SEE COMMENTS IN CBC3GMT2 SOURCE.         *\n//* 1. COMPILE PROGRAM CBC3GMT2 AND BIND CALL AS CBC3GMT2            *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3GMT2                        *\n//********************************************************************\n//********************************************************************\n//* COMPILE AND BIND THE PROGRAM                                     *\n//********************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GMT2)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GMT2)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GMT2(R)\n//********************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                       *\n//********************************************************************\n//CBC3GMT2 EXEC  PGM=CBC3GMT2\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3GMV1 0103-00259-00277-1659-00055-00023-00000-BC0THOR\n//BC0THORJ JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//********************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GMV1)                     *\n//* DISPLAYS THE HEXADECIMAL VALUES FOR THE VARIANT CHARACTERS:      *\n//* BACKSLASH, RIGHT BRACKET, LEFT BRACKET, RIGHT BRACE, LEFT BRACE, *\n//* CIRCUMFLEX, TILDE, EXCLAMATION POINT, NUMBER SIGN, AND VERTICAL  *\n//* BAR.                                                             *\n//* BEFORE EXECUTION, A FILE NAMED TEST.MYFILE.DAT MUST BE AVAILABLE *\n//* THAT CONTAINS THE TEN CHARACTERS ABOVE, LEFT JUSTIFIED IN ITS    *\n//* FIRST RECORD. THIS IS BECAUSE THE SOURCE PROGRAM FOPEN() FUNCTION*\n//* SPECIFIES THE DATASET NAME, RATHER THAN THE DDNAME FOR THE FILE. *\n//* 1. COMPILE PROGRAM CBC3GMV1 AND BIND CALL AS CBC3GMV1            *\n//* 2. CREATE THE REQUIRED WORK FILE                                 *\n//* 3. EXECUTE FINAL LOAD MODULE FOR CBC3GMV1                        *\n//* 4. SCRATCH THE WORK FILE                                         *\n//********************************************************************\n//********************************************************************\n//* COMPILE AND BIND THE PROGRAM                                     *\n//********************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GMV1)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GMV1)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GMV1(R)\n//********************************************************************\n//* CREATE THE WORK FILE                                             *\n//********************************************************************\n//MAKEFILE EXEC  PGM=IEBGENER\n//SYSPRINT DD    SYSOUT=*\n//SYSIN    DD    DUMMY\n//SYSUT2   DD    DSN=TEST.MYFILE.DAT,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(1,1)),\n//         DSORG=PS,RECFM=F,LRECL=80,BLKSIZE=80\n//SYSUT1   DD    *\n\\][}{^~!#|\n//********************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                       *\n//********************************************************************\n//CBC3GMV1 EXEC  PGM=CBC3GMV1\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//********************************************************************\n//* SCRATCH THE WORK FILE                                            *\n//********************************************************************\n//SCRATCH  EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n DELETE TEST.MYFILE.DAT\n./ ADD NAME=CBC3GOF1 0102-00259-00277-1700-00033-00018-00000-BC0THOR\n//BC0THORJ JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//********************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GOF1)                     *\n//* SHOWS USE OF MEMORY FILES. USING THE TYPE=MEMORY PARAMETER OF    *\n//* THE FOPEN() FUNCTION.                                            *\n//* NOTE THAT THE OUTPUT FROM THE PRINTF FUNCTION IS WRITTEN TO THE  *\n//* SYSPRINT DD STATEMENT, IF IT IS SUPPLIED IN THE EXECUTION JCL. IF*\n//* NOT, THE PRINTF OUTPUT IS DYNAMICALLY ALLOCATED TO A SYSOUT=A    *\n//* FILE.                                                            *\n//* 1. COMPILE PROGRAM CBC3GOF1 AND BIND CALL AS CBC3GOF1            *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3GOF1                        *\n//********************************************************************\n//********************************************************************\n//* COMPILE AND BIND THE PROGRAM                                     *\n//********************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GOF1)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GOF1)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GOF1(R)\n//********************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                       *\n//********************************************************************\n//CBC3GOF1 EXEC  PGM=CBC3GOF1,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3GOP1 0103-00259-00277-1702-00030-00017-00000-BC0THOR\n//BC0THORJ JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//********************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GOP1)                     *\n//* SHOWS EFFECT OF OPTIMIZATION (SEE ALSO CBC3GOP2)                 *\n//* !!!! ==> SOURCE PROGRAM HAS A SYNTAX ERROR THAT PREVENTS <== !!!!*\n//* !!!! ==> SUCCESSFUL COMPILATION.                         <== !!!!*\n//* 1. COMPILE PROGRAM CBC3GOP1 AND BIND CALL AS CBC3GOP1            *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3GOP1                        *\n//********************************************************************\n//********************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                              *\n//********************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GOP1)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GOP1)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GOP1(R)\n//********************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                       *\n//********************************************************************\n//CBCGOP1 EXEC   PGM=CBCGOP1,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3GOP2 0102-00259-00277-1703-00032-00017-00000-BC0THOR\n//BC0THORJ JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//********************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GOP2)                     *\n//* SHOWS EFFECT OF OPTIMIZATION (SEE ALSO CBC3GOP1)                 *\n//* NOTE THAT THE OUTPUT FROM THE PRINTF FUNCTION IS WRITTEN TO THE  *\n//* SYSPRINT DD STATEMENT, IF IT IS SUPPLIED IN THE EXECUTION JCL. IF*\n//* NOT, THE PRINTF OUTPUT IS DYNAMICALLY ALLOCATED TO A SYSOUT=A    *\n//* FILE.                                                            *\n//* 1. COMPILE PROGRAM CBC3GOP2 AND BIND CALL AS CBC3GOP2           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3GOP2                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GOP2)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GOP2)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GOP2(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3GOP2 EXEC  PGM=CBC3GOP2\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3GOP3 0102-00259-00277-1704-00033-00017-00000-BC0THOR\n//BC0THORJ JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//********************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GOP3)                     *\n//* DEMONSTRATES HOW NUMERIC CONVERSIONS ARE DONE.                   *\n//* NOTE THAT THE OUTPUT FROM THE PRINTF FUNCTION IS WRITTEN TO THE  *\n//* SYSPRINT DD STATEMENT, IF IT IS SUPPLIED IN THE EXECUTION JCL. IF*\n//* NOT, THE PRINTF OUTPUT IS DYNAMICALLY ALLOCATED TO A SYSOUT=A    *\n//* FILE.                                                            *\n//* 1. COMPILE PROGRAM CBC3GOP3 AND BIND CALL AS CBC3GOP3            *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3GOP3. PRODUCES NO OUTPUT    *\n//*    BUT TERMINATES WITH RC=0.                                     *\n//********************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GOP3)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GOP3)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GOP3(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3GOP3 EXEC  PGM=CBC3GOP3\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3GOS3 0102-00259-00277-1705-00028-00017-00000-BC0THOR\n//BC0THORJ JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//********************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GOS3)                     *\n//* SHOWS HOW TO READ UPDATED RECORDS.                               *\n//* 1. COMPILE PROGRAM CBC3GOS3 AND BIND CALL AS CBC3GOS3           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3GOS3                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GOS3)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GOS3)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GOS3(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3GOS3 EXEC  PGM=CBC3GOS3\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3GRE1 0102-00259-00277-1706-00032-00017-00000-BC0THOR\n//BC0THORJ JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//********************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GRE1)                     *\n//* DISPLAYS \"HELLO WORLD\"                                           *\n//* NOTE THAT THE OUTPUT FROM THE PRINTF FUNCTION IS WRITTEN TO THE  *\n//* SYSPRINT DD STATEMENT, IF IT IS SUPPLIED IN THE EXECUTION JCL. IF*\n//* NOT, THE PRINTF OUTPUT IS DYNAMICALLY ALLOCATED TO A SYSOUT=A    *\n//* FILE.                                                            *\n//* 1. COMPILE PROGRAM CBC3GRE1 AND BIND CALL AS CBC3GRE1           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3GRE1                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GRE1)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GRE1)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GRE1(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3GRE1 EXEC  PGM=CBC3GRE1\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3GRE3 0106-00259-00277-1524-00036-00033-00000-BC0THOR\n//BC0THORH JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=100M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GRE3)                    *\n//* ASSEMBLE/LINK FOR C LANGUAGE SAMPLE ASSEMBLER PROGRAM CBC3GRE3  *\n//* !!!!! ==> MUST BE LINKED INTO A PDSE TO FUNCTION <== !!!!!      *\n//* !!!!! ==> PROPERLY WITH CBC3GRE4. CURRENTLY HAS  <== !!!!!      *\n//* !!!!! ==> A PROBLEM UNDER IBM INVESTIGATION.     <== !!!!!      *\n//*******************************************************************\n//*******************************************\n//*  ASSEMBLY                               *\n//*******************************************\n//ASM      EXEC PGM=ASMA90,\n//  PARM=(OBJECT,'XREF(FULL)',ESD,LIST,'FLAG(NORECORD)')\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=CEE.SCEEMAC,DISP=SHR\n//SYSUT1   DD DSN=&&SYSUT1,UNIT=DISK,SPACE=(CYL,(10,5))\n//SYSPRINT DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//SYSPUNCH DD DUMMY,DCB=BLKSIZE=80\n//SYSLIN   DD DSN=&&LOADSET,DISP=(,PASS),\n//         UNIT=DISK,SPACE=(CYL,(5,1),RLSE),\n//         BLKSIZE=400\n//SYSIN    DD DSN=CBC.TRIGON.SAMPSRC(CBC3GRE3),DISP=SHR\n//*******************************************\n//*  LINKEDIT                               *\n//*******************************************\n//LKED    EXEC PGM=IEWL,REGION=256K,COND=(8,LT,ASM),\n//  PARM='XREF,LET,LIST,NCAL,MAP,SIZE=(256K,96K)'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=&&LOADSET,DISP=(SHR,DELETE,DELETE)\n//SYSUT1   DD UNIT=DISK,SPACE=(CYL,(1,1))\n//SYSLIB   DD DSN=SYS1.LINKLIB,DISP=SHR\n//SYSLMOD  DD DSN=BC0THOR.PDSE.LOAD(CBC3GRE3),DISP=SHR\n./ ADD NAME=CBC3GRE4 0107-00263-00277-1709-00054-00051-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//********************************************************************\n//*                CBC.TRIGON.SAMPJCL(CBC3GRE4)                      *\n//* !!!!! ==> MUST BE LINKED INTO A PDSE TO FUNCTION <== !!!!!       *\n//* !!!!! ==> PROPERLY WITH CBC3GRE3. CURRENTLY HAS  <== !!!!!       *\n//* !!!!! ==> A PROBLEM UNDER IBM INVESTIGATION.     <== !!!!!       *\n//********************************************************************\n//********************************************************************\n//*  CONVERT SQUARE BRACKETS TO COMPILER EXPECTED VALUES             *\n//********************************************************************\n//CBRAKETS EXEC PGM=CBRAKETS\n//STEPLIB  DD   DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//SYSUDUMP DD   SYSOUT=*\n//SYSIN    DD   DSN=CBC.TRIGON.SAMPSRC(CBC3GRE4),DISP=SHR\n//SYSOUT   DD   DSN=&&CSOURCE,DISP=(,PASS),\n//         UNIT=DISK,SPACE=(CYL,(2,1),RLSE),\n//         DSORG=PS,RECFM=FB,LRECL=80\n//********************************************************************\n//*  COMPILE THE SAMPLE PROGRAM                                      *\n//********************************************************************\n//COMPILE EXEC PGM=CBCDRVR,\n//    PARM=('/AGG,EXP,LIS,OF,OPT,SO,XR,CHE(ALL)')\n//STEPLIB  DD  DSN=CEE.SCEERUN,DISP=SHR\n//         DD  DSN=CBC.SCBCCMP,DISP=SHR\n//SYSLIB   DD  DSN=CEE.SCEEH.H,DISP=SHR\n//         DD  DSN=CEE.SCEEH.SYS.H,DISP=SHR\n//         DD  DSN=CBC.SCBCSAM,DISP=SHR\n//SYSLIN   DD  DSN=&&LOADSET,DISP=(NEW,PASS),\n//         UNIT=DISK,SPACE=(TRK,(3,3)),\n//         RECFM=FB,LRECL=80,BLKSIZE=3200\n//SYSPRINT DD  SYSOUT=*\n//SYSOUT   DD  SYSOUT=*\n//SYSCPRT  DD  SYSOUT=*\n//SYSIN    DD  DSN=&&CSOURCE,DISP=(OLD,PASS,DELETE)\n//********************************************************************\n//*  BIND THE SAMPLE PROGRAM WITH CALL                               *\n//********************************************************************\n//BIND   EXEC PGM=IEWL,COND=(4,LT),\n//  PARM='XREF,LET,LIST,CALL,MAP,SIZE=(256K,96K)'\n//STEPLIB  DD  DSN=CEE.SCEERUN,DISP=SHR\n//SYSLIB   DD  DSN=CEE.SCEELKED,DISP=SHR\n//         DD  DSN=BC0THOR.PDSE.LOAD,DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSN=&&LOADSET,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSLMOD  DD  DSN=BC0THOR.PDSE.LOAD(CBC3GRE4),DISP=SHR\n//SYSDEFSD DD  DUMMY\n//SYSIN    DD  *\n INCLUDE SYSLIB(CBC3GRE3)\n ENTRY CEESTART\n NAME CBC3GRE4(R)\n./ ADD NAME=CBC3GTH1 0102-00266-00277-1709-00034-00018-00000-BC0THOR\n//BC0THORJ JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//********************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GTH1)                     *\n//* USES THREAD-SPECIFIC DATA TO INSURE THAT STORAGE ACQUIRED BY A   *\n//* SPECIFIC THREAD IS FREED WHEN THE THREAD ENDS.                   *\n//* NOTE THAT THE OUTPUT FROM THE PRINTF FUNCTION IS WRITTEN TO THE  *\n//* SYSPRINT DD STATEMENT, IF IT IS SUPPLIED IN THE EXECUTION JCL. IF*\n//* NOT, THE PRINTF OUTPUT IS DYNAMICALLY ALLOCATED TO A SYSOUT=A    *\n//* FILE.                                                            *\n//* 1. COMPILE PROGRAM CBC3GTH1 AND BIND CALL AS CBC3GTH1            *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3GTH1. PRODUCES NO OUTPUT,   *\n//*    BUT ENDS RC=0.                                                *\n//********************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GTH1)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GTH1)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GTH1(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3GTH1 EXEC  PGM=CBC3GTH1\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3GVS1 0104-00265-00277-1710-00095-00076-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=HDQTRSF2,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*               CBC.TRIGON.SAMPJCL(CBC3GVS1)                      *\n//* THIS EXAMPLE SHOWS HOW TO ACCESS THE __AMRC->__RBA FIELD.       *\n//* IT ASSUMES THAT AN ESDS HAS ALREADY BEEN DEFINED, AND HAS BEEN  *\n//* ASSIGNED THE DDNAME ESDSCLUS.                                   *\n//* 1. COMPILE PROGRAM CBC3GVS1 AND BIND CALL AS CBC3GVS1           *\n//* 2. DEFINE THE VSAM ESDS                                         *\n//* 3. REPRO DATA INTO THE VSAM ESDS                                *\n//* 4. EXECUTE FINAL LOAD MODULE FOR CBC3GVS1. PROGRAM RETURNS ERROR*\n//*    MESSAGES FOLLOWING FOPEN() CALL, BUT ENDS WITH RC=0.         *\n//* 5. PRINT THE VSAM ESDS                                          *\n//* 6. DELETE THE VSAM ESDS                                         *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GVS1)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GVS1)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GVS1(R)\n//*******************************************************************\n//* DEFINE ESDS                                                     *\n//*******************************************************************\n//DEFINE  EXEC PGM=IDCAMS\n//VOLUME    DD UNIT=DISK,DISP=SHR,VOL=SER=WORK01\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD *\n    DEFINE CLUSTER -\n        (NAME(TEST.TSTESDS) -\n         FILE(VOLUME) -\n         VOLUMES(WORK01) -\n         NONINDEXED -\n         CYLINDERS(5 1) -\n         RECORDSIZE(80 80) -\n         FREESPACE(10 10) -\n         CISZ(4096) -\n         SHR(3,3) -\n         SPEED -\n         UNIQUE -\n         NOERASE -\n         NOWRITECHECK -\n         UNORDERED -\n         NOREUSE -\n         NONSPANNED -\n        )  -\n      DATA -\n        (NAME(TEST.TSTESDS.DATA))\n//*******************************************************************\n//* REPRO DATA INTO ESDS                                            *\n//*******************************************************************\n//REPRO   EXEC PGM=IDCAMS\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD *\n   REPRO INDATASET(CBC.TRIGON.SAMPSRC(CBC3GVS1)) -\n      OUTDATASET(TEST.TSTESDS)\n//*******************************************************************\n//* EXECUTE THE TEST PROGRAM CBC3GVS1                               *\n//*******************************************************************\n//CBC3GVS1  EXEC PGM=CBC3GVS1,REGION=5M\n//STEPLIB  DD DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD DSN=CEE.SCEERUN,DISP=SHR\n//SYSPRINT  DD SYSOUT=*\n//SYSTERM   DD SYSOUT=*\n//SYSOUT    DD SYSOUT=*\n//PLIDUMP   DD SYSOUT=*\n//SYSABEND  DD SYSOUT=*\n//SYSUDUMP  DD SYSOUT=*\n//ESDSCLUS  DD DSN=TEST.TSTESDS,DISP=SHR\n//*******************************************************************\n//* PRINT OUT THE ESDS CLUSTER                                      *\n//*******************************************************************\n//PRINTF    EXEC PGM=IDCAMS\n//SYSPRINT   DD SYSOUT=*\n//SYSIN      DD *\n   PARM GRAPHICS(CHAIN(SN))\n   PRINT -\n       INDATASET(TEST.TSTESDS) CHAR\n//*******************************************************************\n//* DELETE THE ESDS CLUSTER                                         *\n//*******************************************************************\n//DELETEC EXEC PGM=IDCAMS\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD *\n    DELETE -\n        TEST.TSTESDS -\n        CLUSTER -\n        PURGE -\n        ERASE\n./ ADD NAME=CBC3GVS2 0106-00264-00277-1711-00135-00123-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=HDQTRSF2,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*               CBC.TRIGON.SAMPJCL(CBC3GVS2)                      *\n//* THIS EXAMPLE DEMONSTRATES THE USE OF A KSDS FILE.               *\n//* 1. COMPILE PROGRAM CBC3GVS2 AND BIND CALL AS CBC3GVS2           *\n//* 2. DEFINE THE VSAM KSDS                                         *\n//* 3. REPRO DATA INTO THE KSDS                                     *\n//* 4. DEFINE UNIQUE ALTERNATE INDEX AND BUILD PATH                 *\n//* 5. DEFINE NONUNIQUE ALTERNATE INDEX AND BUILD PATH              *\n//* 6. EXECUTE FINAL LOAD MODULE FOR CBC3GVS2                       *\n//* 7. PRINT THE VSAM KSDS                                          *\n//* 8. DELETE THE VSAM KSDS                                         *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GVS2)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GVS2)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GVS2(R)\n//*******************************************************************\n//* DEFINE KSDS                                             *\n//*******************************************************************\n//DEFINE  EXEC PGM=IDCAMS\n//VOLUME    DD UNIT=DISK,DISP=SHR,VOL=SER=WORK01\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD *\n    DEFINE CLUSTER -\n        (NAME(TEST.TSTKSDS) -\n        FILE(VOLUME) -\n        VOL(WORK01) -\n        TRK(4 4)  -\n        RECSZ(69 100) -\n        INDEXED -\n        NOREUSE -\n        KEYS(4 0) -\n        OWNER(TEST) ) -\n      DATA -\n        (NAME(TEST.TSTKSDS.DATA)) -\n      INDEX -\n        (NAME(TEST.TSTKSDS.INDEX))\n//*******************************************************************\n//* REPRO DATA INTO KSDS                                            *\n//*******************************************************************\n//REPRO   EXEC PGM=IDCAMS\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD *\n   REPRO INDATASET(CBC.TRIGON.SAMPSRC(CBC3GVS3)) -\n      OUTDATASET(TEST.TSTKSDS)\n//*******************************************************************\n//* DEFINE UNIQUE AIX, DEFINE AND BUILD PATH                        *\n//*******************************************************************\n//DEFAIX  EXEC PGM=IDCAMS\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD *\n    DEFINE AIX -\n        (NAME(TEST.TSTKSDS.UAIX) -\n        RECORDS(25)  -\n        KEYS(8,4)    -\n        VOL(WORK01)  -\n        UNIQUEKEY -\n        RELATE(TEST.TSTKSDS)) -\n      DATA -\n        (NAME(TEST.TSTKSDS.UAIXDA)) -\n      INDEX -\n        (NAME(TEST.TSTKSDS.UAIXIX))\n    DEFINE PATH -\n        (NAME(TEST.TSTKSDS.UPATH) -\n        PATHENTRY(TEST.TSTKSDS.UAIX))\n    BLDINDEX -\n        INDATASET(TEST.TSTKSDS) -\n        OUTDATASET(TEST.TSTKSDS.UAIX)\n//*******************************************************************\n//* DEFINE NONUNIQUE AIX, DEFINE AND BUILD PATH                     *\n//*******************************************************************\n//DEFAIX2 EXEC PGM=IDCAMS\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD *\n    DEFINE AIX -\n        (NAME(TEST.TSTKSDS.NUAIX) -\n        RECORDS(25)  -\n        KEYS(20, 12)    -\n        VOL(WORK01)  -\n        NONUNIQUEKEY -\n        RELATE(TEST.TSTKSDS)) -\n      DATA -\n        (NAME(TEST.TSTKSDS.NUAIXDA)) -\n      INDEX -\n        (NAME(TEST.TSTKSDS.NUAIXIX))\n    DEFINE PATH -\n        (NAME(TEST.TSTKSDS.NUPATH) -\n        PATHENTRY(TEST.TSTKSDS.NUAIX))\n    BLDINDEX -\n        INDATASET(TEST.TSTKSDS) -\n        OUTDATASET(TEST.TSTKSDS.NUAIX)\n//*******************************************************************\n//* RUN THE TESTCASE                                                *\n//*******************************************************************\n//GO        EXEC PGM=CBC3GVS2,REGION=5M\n//STEPLIB  DD DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD DSN=CEE.SCEERUN,DISP=SHR\n//SYSPRINT  DD SYSOUT=*\n//SYSTERM   DD SYSOUT=*\n//SYSOUT    DD SYSOUT=*\n//PLIDUMP   DD SYSOUT=*\n//SYSABEND  DD SYSOUT=*\n//SYSUDUMP  DD SYSOUT=*\n//CLUSTER   DD DSN=TEST.TSTKSDS,DISP=SHR\n//AIXUNIQ   DD DSN=TEST.TSTKSDS.UPATH,DISP=SHR\n//AIXNUNIQ  DD DSN=TEST.TSTKSDS.NUPATH,DISP=SHR\n//*******************************************************************\n//* PRINT OUT THE CLUSTER                                           *\n//*******************************************************************\n//PRINTF    EXEC PGM=IDCAMS\n//SYSPRINT   DD SYSOUT=*\n//SYSIN      DD *\n   PRINT -\n       INDATASET(TEST.TSTKSDS) CHAR\n//*******************************************************************\n//* DELETE CLUSTER, AND AIX AND PATH                                *\n//*******************************************************************\n//DELETEC EXEC PGM=IDCAMS\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD *\n    DELETE -\n        TEST.TSTKSDS -\n        CLUSTER -\n        PURGE -\n        ERASE\n./ ADD NAME=CBC3GVS4 0103-00265-00277-1328-00085-00068-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=HDQTRSF2,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*               CBC.TRIGON.SAMPJCL(CBC3GVS4)                      *\n//* THIS EXAMPLE ILLUSTRATES THE USE OF AN RRDS FILE.               *\n//* 1. COMPILE PROGRAM CBC3GVS4 AND BIND CALL AS CBC3GVS4           *\n//* 2. DEFINE THE RRDS CLUSTER                                      *\n//* 3. REPRO DATA INTO THE RRDS CLUSTER                             *\n//* 4. EXECUTE FINAL LOAD MODULE FOR CBC3GVS4                       *\n//* 5. PRINT THE RRDS CLUSTER                                       *\n//* 6. DELETE THE RRDS CLUSTER                                      *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND PROGRAM CBC3GVS4                               *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GVS4)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GVS4)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GVS4(R)\n//*******************************************************************\n//* DEFINE THE RRDS CLUSTER                                         *\n//*******************************************************************\n//DEFINE   EXEC PGM=IDCAMS\n//VOLUME   DD   UNIT=DISK,DISP=SHR,VOL=SER=WORK01\n//SYSPRINT DD   SYSOUT=*\n//SYSIN    DD   *\n    DEFINE CLUSTER -\n        (NAME(TEST.TSTRRDS.CLUSTER) -\n         FILE(VOLUME) -\n         VOL(WORK01) -\n         NUMBERED -\n         TRK(5 1)  -\n         RECSZ(80 80) -\n         REUSE -\n         FREESPACE(10 10) -\n         SHR(3,3) -\n         SPEED -\n        ) -\n      DATA -\n        (NAME(TEST.TSTRRDS.DA))\n//*******************************************************************\n//* REPRO DATA INTO THE RRDS CLUSTER                                *\n//*******************************************************************\n//REPRO    EXEC PGM=IDCAMS\n//SYSPRINT DD   SYSOUT=*\n//SYSIN    DD   *\n   REPRO INDATASET(CBC.TRIGON.SAMPSRC(CBC3GVS4)) -\n      OUTDATASET(TEST.TSTRRDS.CLUSTER)\n//*******************************************************************\n//* EXECUTE THE CBC3GVS4 TEST PROGRAM                               *\n//*******************************************************************\n//CBC3GVS4 EXEC PGM=CBC3GVS4,REGION=5M\n//STEPLIB  DD   DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD   DSN=CEE.SCEERUN,DISP=SHR\n//SYSPRINT DD   SYSOUT=*\n//SYSTERM  DD   SYSOUT=*\n//SYSOUT   DD   SYSOUT=*\n//PLIDUMP  DD   SYSOUT=*\n//SYSABEND DD   SYSOUT=*\n//SYSUDUMP DD   SYSOUT=*\n//RRDSFILE DD   DSN=TEST.TSTRRDS.CLUSTER,DISP=SHR\n//*******************************************************************\n//* PRINT OUT THE RRDS CLUSTER                                      *\n//*******************************************************************\n//PRINTF   EXEC PGM=IDCAMS\n//SYSPRINT DD   SYSOUT=*\n//SYSIN    DD   *\n   PARM GRAPHICS(CHAIN(SN))\n   PRINT INDATASET(TEST.TSTRRDS.CLUSTER) CHAR\n//*******************************************************************\n//* DELETE THE RRDS CLUSTER                                         *\n//*******************************************************************\n//DELETEC EXEC PGM=IDCAMS\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  *\n    DELETE -\n        TEST.TSTRRDS.CLUSTER -\n        CLUSTER -\n        PURGE -\n        ERASE\n./ ADD NAME=CBC3GWT2 0104-00266-00277-1713-00037-00030-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3GWT2)                    *\n//* CALLS AN ASSEMBLER SUBPROGRAM TO DISPLAY A MESSAGE VIA WTO.     *\n//* 1. ASSEMBLE SUBPROGRAM CBC3GWT1 AND BIND NCAL AS DYNWTO         *\n//* 2. COMPILE PROGRAM CBC3GWT2 AND BIND CALL AS CBC3GWT2           *\n//* 3. EXECUTE FINAL LOAD MODULE FOR CBC3GWT2                       *\n//*******************************************************************\n//*******************************************************************\n//* ASSEMBLE AND BIND THE SAMPLE ASSEMBLER SUBPROGRAM NCAL AS DYNWTO*\n//*******************************************************************\n//ASMACL   EXEC  ASMACL\n//C.SYSLIB DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=CEE.SCEEMAC,DISP=SHR\n//C.SYSIN DD   DSN=CBC.TRIGON.SAMPSRC(CBC3GWT1),DISP=SHR\n//L.SYSLMOD DD DSN=CBC.TRIGON.SAMPLOD(DYNWTO),DISP=SHR\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE C PROGRAM WITH CALL AS CBC3GWT2     *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3GWT2)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3GWT2)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3GWT2(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM, CBC3GWT2                            *\n//*******************************************************************\n//CBC3GWT2 EXEC  PGM=CBC3GWT2\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAA  0103-00269-00277-1714-00031-00017-00000-BC0THOR\n//BC0THORJ JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//********************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAA)                      *\n//* THIS EXAMPLE SHOWS HOW BREAK IS USED WITH THE SWITCH STATEMENT   *\n//* NOTE THAT THE OUTPUT FROM THE PRINTF FUNCTION IS WRITTEN TO THE  *\n//* SYSPRINT DD STATEMENT.                                           *\n//* 1. COMPILE PROGRAM CBC3RAA AND BIND CALL AS CBC3RAA              *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAA                         *\n//********************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAA)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAA)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAA(R)\n//BIND.MYLOAD DD DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAA EXEC   PGM=CBC3RAA\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAAA 0104-00269-00277-1715-00030-00018-00000-BC0THOR\n//BC0THORJ JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//********************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAAA)                     *\n//* SIMPLE C PROGRAM THAT CALLS THE COS() MATH FUNCTION AND DISPLAYS *\n//* THE RESULT USING PRINTF().                                       *\n//* 1. COMPILE PROGRAM CBC3RAAA AND BIND CALL AS CBC3RAAA            *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAAA                        *\n//********************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAAA)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAAA)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAAA(R)\n//BIND.MYLOAD DD DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAAA EXEC  PGM=CBC3RAAA\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAAB 0108-00269-00277-1717-00040-00031-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAAB)                    *\n//* SAMPLE PROGAMS TO SHOW ONE C PROGRAM CALLING ANOTHER AND PASSING*\n//* PARAMETERS BETWEEN THEM.                                        *\n//* 1. COMPILE PROGRAM CBC3RMAX AND BIND NCAL AS MAX                *\n//* 2. COMPILE MAIN PROGRAM CBC3RAAB AND BIND CALL AS CBC3RAAB      *\n//* 3. EXECUTE FINAL LOAD MODULE FOR CBC3RAAB. AS WRITTEN, ENDS WITH*\n//*    RC=8 AND PRODUCES NO OUTPUT.                                 *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE SUBPROGRAM NCAL AS MAX              *\n//*******************************************************************\n//COMPBND1 EXEC CCOMP,CALL=NCAL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RMAX)',\n//   LOAD='CBC.TRIGON.SAMPLOD(MAX)'\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM WITH CALL AS CBC3RAAB       *\n//*******************************************************************\n//COMPBND2 EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAAB)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAAB)'\n//BIND.SYSIN DD *\n INCLUDE MYLOAD(CBC3RAAB)\n INCLUDE MYLOAD(MAX)\n ENTRY CEESTART\n NAME CBC3RAAB(R)\n//BIND.MYLOAD DD DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAAB EXEC  PGM=CBC3RAAB,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAAD 0102-00269-00277-1717-00029-00025-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAAD)                    *\n//* SAMPLE PROGRAM SHOWING USE OF CHARACTER CONSTANTS.              *\n//* 1. COMPILE PROGRAM CBC3RAAD AND BIND CALL AS CBC3RAAD           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAAD                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAAD)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAAD)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAAD(R)\n//BIND.MYLOAD DD DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAAD EXEC  PGM=CBC3RAAD,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAAE 0103-00269-00277-1718-00030-00026-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAAE)                    *\n//* DEMONSTRATES USE OF STRING CONSTANTS WITH THE STRING FUNCTIONS  *\n//* STRCPY() AND STRCAT()                                           *\n//* 1. COMPILE PROGRAM CBC3RAAE AND BIND CALL AS CBC3RAAE           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAAE                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAAE)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAAE)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAAE(R)\n//BIND.MYLOAD DD DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAAE EXEC  PGM=CBC3RAAE,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAAF 0103-00269-00277-1718-00030-00026-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAAF)                    *\n//* ILLUSTRATES HOW AUTO VARIABLES ARE UNIQUE WITHIN THE BLOCKS IN  *\n//* WHICH THEY ARE DEFINED.                                         *\n//* 1. COMPILE PROGRAM CBC3RAAF AND BIND CALL AS CBC3RAAF           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAAF                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAAF)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAAF)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAAF(R)\n//BIND.MYLOAD DD DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAAF EXEC  PGM=CBC3RAAF,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAAG 0105-00269-00277-1719-00034-00025-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAAG)                    *\n//* SHOWS READING CHARACTERS FROM SYSIN, PUTTING THEM INTO AN ARRAY *\n//* AND PASSING THE REULT TO AN INCLUDED FUNCTION, WHERE THEY ARE   *\n//* SORTED. ON RETURN THE SORTED ARRAY IS PRINTED.                  *\n//* 1. COMPILE PROGRAM CBC3RAAG AND BIND CALL AS CBC3RAAG           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAAG. SYSIN IS USED TO     *\n//*    ENTER A STRING.                                              *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAAG)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAAG)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAAG(R)\n//BIND.MYLOAD DD DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAAG EXEC  PGM=CBC3RAAG,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSIN    DD    *\nDICK-THORNTON\n./ ADD NAME=CBC3RAAI 0102-00269-00277-1719-00032-00027-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAAI)                    *\n//* SHOWS HOW EXTERN VARIABLES ARE USED BETWEEN TSO FUNCTIONS.      *\n//* 1. COMPILE PROGRAM CBC3RAAI AND BIND CALL AS CBC3RAAI           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAAI. A STRING IS INPUT    *\n//*    VIA SYSIN.                                                   *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAAI)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAAI)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAAI(R)\n//BIND.MYLOAD DD DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAAI EXEC  PGM=CBC3RAAI,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSIN    DD    *\nDICK-THORNTON\n./ ADD NAME=CBC3RAAK 0101-00269-00277-1720-00029-00025-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAAK)                    *\n//* SHOWS USE OF BLOCK SCOPE STATIC VARIABLES.                      *\n//* 1. COMPILE PROGRAM CBC3RAAK AND BIND CALL AS CBC3RAAK           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAAK                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAAK)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAAK)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAAK(R)\n//BIND.MYLOAD DD DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAAK EXEC  PGM=CBC3RAAK,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAAM 0101-00269-00277-1720-00029-00025-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAAM)                    *\n//* THIS EXAMPLE USES THE VOID DATA TYPE.                           *\n//* 1. COMPILE PROGRAM CBC3RAAM AND BIND CALL AS CBC3RAAM           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAAM                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAAM)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAAM)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAAM(R)\n//BIND.MYLOAD DD DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAAM EXEC  PGM=CBC3RAAM,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAAN 0102-00269-00277-1721-00039-00011-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAAN)                    *\n//* THIS EXAMPLE DEMONSTRATES THE USE OF ENUM. A PROTOTYPE WAS ADDED*\n//* FOR THE FRENCH() FUNCTION, AND THE OLD-STYLE FUNCTION HEADER FOR*\n//* FRENCH() WAS UPDATED TO MODERN SYNTAX.                          *\n//* USER ENTERS A NUMBER INDICATING DAY OF WEEK AS 1-7.             *\n//* 1. COMPILE PROGRAM CBC3RAAN AND BIND CALL AS CBC3RAAN           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAAN. DAY OF WEEK IS INPUT *\n//*    VIA SYSIN.                                                   *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAAN)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAAN)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAAN(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAAN EXEC  PGM=CBC3RAAN,COND=(4,LT),PARM='NAME ADDRESS LUMP'\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//CBC3RAAN EXEC  PGM=CBC3RAAN,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSIN    DD    *\n3\n./ ADD NAME=CBC3RAAO 0101-00269-00277-1721-00029-00025-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAAO)                    *\n//* THIS EXAMPLE USES A ONE-DIMENSIONAL ARRAY.                      *\n//* 1. COMPILE PROGRAM CBC3RAAO AND BIND CALL AS CBC3RAAO           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAAO                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAAO)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAAO)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAAO(R)\n//BIND.MYLOAD DD DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAAO EXEC  PGM=CBC3RAAO,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAAP 0101-00269-00277-1722-00029-00025-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAAP)                    *\n//* THIS EXAMPLE USES A MULTI-DIMENSIONAL ARRAY.                    *\n//* 1. COMPILE PROGRAM CBC3RAAP AND BIND CALL AS CBC3RAAP           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAAP                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAAP)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAAP)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAAP(R)\n//BIND.MYLOAD DD DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAAP EXEC  PGM=CBC3RAAP,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAAQ 0103-00269-00277-1722-00032-00027-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAAQ)                    *\n//* This program searches for the first occurrence of a specified   *\n//* character string in an array of character strings.              *\n//* 1. COMPILE PROGRAM CBC3RAAQ AND BIND CALL AS CBC3RAAQ           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAAQ. NAME IS ENTERED VIA  *\n//*    SYSIN. RC=8 IS NORMAL.                                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAAQ)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAAQ)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAAQ(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAAQ EXEC  PGM=CBC3RAAQ,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSIN    DD    *\nAmy\n./ ADD NAME=CBC3RAAR 0102-00269-00277-1723-00029-00025-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAAR)                    *\n//* THIS EXAMPLE USES AN ABSTRACT DATA TYPE.                        *\n//* 1. COMPILE PROGRAM CBC3RAAR AND BIND CALL AS CBC3RAAR           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAAR. AS WRITTEN, PRODUCES *\n//*    NO OUTPUT.                                                   *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAAR)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAAR)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAAR(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAAR EXEC  PGM=CBC3RAAR,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAAS 0101-00269-00277-1723-00028-00025-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAAS)                    *\n//* THIS PROGRAM ILLUSTRATES LINKED LISTS.                          *\n//* 1. COMPILE PROGRAM CBC3RAAS AND BIND CALL AS CBC3RAAS           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAAS                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAAS)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAAS)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAAS(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAAS EXEC  PGM=CBC3RAAS,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAAT 0101-00270-00277-1724-00028-00025-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAAT)                    *\n//* THIS EXAMPLE USES AN ARRAY OF POINTERS TO FUNCTIONS.            *\n//* 1. COMPILE PROGRAM CBC3RAAT AND BIND CALL AS CBC3RAAT           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAAT                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAAT)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAAT)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAAT(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAAT EXEC  PGM=CBC3RAAT,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAAU 0101-00270-00277-1724-00028-00025-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAAU)                    *\n//* THIS EXAMPLE USES A PROTOTYPE FUNCTION DECLARATOR.\n//* 1. COMPILE PROGRAM CBC3RAAU AND BIND CALL AS CBC3RAAU           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAAU                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAAU)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAAU)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAAU(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAAU EXEC  PGM=CBC3RAAU,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAAV 0101-00270-00277-1724-00028-00025-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAAV)                    *\n/* THIS EXAMPLE SHOWS HOW A FUNCTION IS DECLARED AND DEFINED.        */\n//* 1. COMPILE PROGRAM CBC3RAAV AND BIND CALL AS CBC3RAAV           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAAV                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAAV)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAAV)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAAV(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAAV EXEC  PGM=CBC3RAAV,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAAX 0101-00271-00277-1725-00028-00025-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAAX)                    *\n//* THIS EXAMPLE SHOWS HOW A PARAMETER IS PASSED TO A FUNCTION.     *\n//* 1. COMPILE PROGRAM CBC3RAAX AND BIND CALL AS CBC3RAAX           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAAX                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAAX)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAAX)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAAX(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAAX EXEC  PGM=CBC3RAAX,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAAY 0101-00271-00277-1725-00028-00025-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAAY)                    *\n//* THIS EXAMPLE SHOWS HOW AN ADDRESS IS PASSED TO A FUNCTION.      *\n//* 1. COMPILE PROGRAM CBC3RAAY AND BIND CALL AS CBC3RAAY           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAAY                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAAY)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAAY)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAAY(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAAY EXEC  PGM=CBC3RAAY,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAAZ 0101-00271-00277-1725-00029-00026-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAAZ)                    *\n//* THIS EXAMPLE SHOWS HOW LOSS OF PRECISION OCCURS DURING TYPE     *\n//* CONVERSION.                                                     *\n//* 1. COMPILE PROGRAM CBC3RAAZ AND BIND CALL AS CBC3RAAZ           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAAZ                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAAZ)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAAZ)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAAZ(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAAZ EXEC  PGM=CBC3RAAZ,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAA1 0101-00271-00277-1726-00029-00026-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAA1)                    *\n//* THIS EXAMPLE SHOWS HOW THE VALUES OF DATA OBJECTS CHANGE IN     *\n//* NESTED BLOCKS.                                                  *\n//* 1. COMPILE PROGRAM CBC3RAA1 AND BIND CALL AS CBC3RAA1           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAA1                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAA1)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAA1)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAA1(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAA1 EXEC  PGM=CBC3RAA1,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAA2 0101-00271-00277-1726-00032-00028-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAA2)                    *\n//* THIS PROGRAM COUNTS THE CHARACTERS IN THE STRINGS THAT ARE      *\n//* PART OF AN ARRAY OF POINTERS TO CHARACTERS.                     *\n//* THE COUNT STOPS WHEN ONE OF THE DIGITS 0 THROUGH 9 IS           *\n//* ENCOUNTERED AND RESUMES AT THE BEGINNING OF THE NEXT STRING.    *\n//* 1. COMPILE PROGRAM CBC3RAA2 AND BIND CALL AS CBC3RAA2           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAA2                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAA2)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAA2)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAA2(R)\n//BIND.MYLOAD DD DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAA2 EXEC  PGM=CBC3RAA2,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAA3 0101-00271-00277-1727-00028-00025-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAA3)                    *\n//* THIS EXAMPLE SHOWS HOW THE CONTINUE STATEMENT CAN BE USED.      *\n//* 1. COMPILE PROGRAM CBC3RAA3 AND BIND CALL AS CBC3RAA3           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAA3                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAA3)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAA3)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAA3(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAA3 EXEC  PGM=CBC3RAA3,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAA4 0101-00271-00277-1727-00030-00027-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAA4)                    *\n//* THIS PROGRAM COUNTS THE CHARACTERS IN STRINGS THAT ARE PART OF  *\n//* AN ARRAY OF POINTERS TO CHARACTERS. THE COUNT EXCLUDES THE      *\n//* DIGITS 0 THROUGH 9.                                             *\n//* 1. COMPILE PROGRAM CBC3RAA4 AND BIND CALL AS CBC3RAA4           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAA4                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAA4)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAA4)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAA4(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAA4 EXEC  PGM=CBC3RAA4,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAA5 0103-00271-00277-1727-00031-00025-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAA5)                    *\n//* THIS EXAMPLE ILLUSTRATES THE DO STATEMENT.                      *\n//* 1. COMPILE PROGRAM CBC3RAA5 AND BIND CALL AS CBC3RAA5           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAA5. A SET OF NUMBERS IS  *\n//*    ENTERED VIA SYSIN.                                           *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAA5)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAA5)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAA5(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAA5 EXEC  PGM=CBC3RAA5,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSIN    DD    *\n9 8 7 6 5 4 3 2 1 0\n./ ADD NAME=CBC3RAA6 0102-00271-00277-1728-00028-00027-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAA6)                    *\n//* THIS EXAMPLE SHOWS HOW A GOTO STATEMENT MAY BE USED.            *\n//* 1. COMPILE PROGRAM CBC3RAA6 AND BIND CALL AS CBC3RAA6           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAA6                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAA6)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAA6)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAA6(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAA6 EXEC  PGM=CBC3RAA6,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAA7 0102-00271-00277-1728-00028-00027-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAA7)                    *\n//* THIS EXAMPLE SHOWS HOW A GOTO STATEMENT MAY BE USED.            *\n//* 1. COMPILE PROGRAM CBC3RAA7 AND BIND CALL AS CBC3RAA7           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAA7                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAA7)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAA7)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAA7(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAA7 EXEC  PGM=CBC3RAA7,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAA8 0102-00271-00277-1729-00028-00027-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAA8)                    *\n//* THIS EXAMPLE ILLUSTRATES THE USE OF A MACRO.                    *\n//* 1. COMPILE PROGRAM CBC3RAA8 AND BIND CALL AS CBC3RAA8           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAA8                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAA8)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAA8)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAA8(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAA8 EXEC  PGM=CBC3RAA8,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RAA9 0102-00271-00277-1729-00028-00027-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAA9)                    *\n//* THIS EXAMPLE IS EQUIVALENT TO CBC3RAA8.                         *\n//* 1. COMPILE PROGRAM CBC3RAA9 AND BIND CALL AS CBC3RAA9           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RAA9                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAA9)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAA9)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RAA9(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAA9 EXEC  PGM=CBC3RAA9,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RABA 0102-00271-00277-1729-00028-00027-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RABA)                    *\n//* THIS EXAMPLE SHOWS HOW PREDEFINED MACROS ARE USED.              *\n//* 1. COMPILE PROGRAM CBC3RABA AND BIND CALL AS CBC3RABA           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RABA                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RABA)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RABA)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RABA(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RABA EXEC  PGM=CBC3RABA,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RABB 0102-00271-00277-1729-00028-00027-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RABB)                    *\n//* THIS EXAMPLE SHOWS HOW PREDEFINED MACROS ARE USED.              *\n//* 1. COMPILE PROGRAM CBC3RABB AND BIND CALL AS CBC3RABB           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RABB                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RABB)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RABB)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RABB(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RABB EXEC  PGM=CBC3RABB,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RABC 0102-00271-00277-1730-00029-00025-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RABC)                    *\n//* THIS EXAMPLE USES CONDITIONAL COMPILATION DIRECTIVES.           *\n//* 1. COMPILE PROGRAM CBC3RABC AND BIND CALL AS CBC3RABC           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RABC. AS WRITTEN, PRODUCES *\n//*    NO OUTPUT.                                                   *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RABC)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RABC)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RABC(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RABC EXEC  PGM=CBC3RABC,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RABD 0101-00271-00277-1730-00028-00025-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RABD)                    *\n//* THIS EXAMPLE SHOWS HOW #LINE IS USED.                           *\n//* 1. COMPILE PROGRAM CBC3RABD AND BIND CALL AS CBC3RABD           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RABD                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RABD)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RABD)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RABD(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RABD EXEC  PGM=CBC3RABD,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RABE 0102-00271-00277-1731-00030-00025-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RABE)                    *\n//* THIS EXAMPLE SHOWS HOW #PRAGMA INLINE MAY BE USED.              *\n//* 1. COMPILE PROGRAM CBC3RABE AND BIND CALL AS CBC3RABE           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RABE                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RABE)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RABE)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RABE(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RABE EXEC  PGM=CBC3RABE,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSIN    DD    *\n1\n./ ADD NAME=CBC3RABF 0101-00271-00277-1731-00028-00025-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RABF)                    *\n//* THIS EXAMPLE ILLUSTRATES BLOCKS, NESTING, AND SCOPE.            *\n//* 1. COMPILE PROGRAM CBC3RABF AND BIND CALL AS CBC3RABF           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RABF                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RABF)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RABF)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RABF(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RABF EXEC  PGM=CBC3RABF,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RABG 0101-00271-00277-1731-00028-00025-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RABG)                    *\n//* THIS EXAMPLE PRINTS OUT CTEST CHARACTERS.                       *\n//* 1. COMPILE PROGRAM CBC3RABG AND BIND CALL AS CBC3RABG           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RABG                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RABG)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RABG)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RABG(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RABG EXEC  PGM=CBC3RABG,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3RABI 0103-00271-00277-1732-00031-00025-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RABI)                    *\n/* THIS EXAMPLE SHOWS HOW THE SWITCH STATEMENT MAY BE USED.         *\n//* 1. COMPILE PROGRAM CBC3RABI AND BIND CALL AS CBC3RABI           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RABI. MONTH NUMBER IS IN   *\n//*    IN THE SYSIN FILE.                                           *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RABI)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RABI)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RABI(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RABI EXEC  PGM=CBC3RABI,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSIN    DD    *\n1\n./ ADD NAME=CBC3RABQ 0103-00271-00277-1732-00032-00026-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RABQ)                    *\n//* THIS PROGRAM SEARCHES FOR THE FIRST OCCURRENCE OF A SPECIFIED   *\n//* CHARACTER STRING IN AN ARRAY OF CHARACTER STRINGS.              *\n//* 1. COMPILE PROGRAM CBC3RABQ AND BIND CALL AS CBC3RABQ           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3RABQ WITH NAME TO BE FOUND *\n//*    IN THE SYSIN FILE. RC=8 IS NORMAL.                           *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RABQ)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RABQ)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3RABQ(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RABQ EXEC  PGM=CBC3RABQ,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSIN    DD    *\nAmy\n./ ADD NAME=CBC3RAH1 0105-00271-00277-1734-00047-00030-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAH1)                    *\n//* THIS EXAMPLE SHOWS THE LINKAGE OF EXTERN OBJECTS/FUNCTIONS.     *\n//* 1. COMPILE SUB PROGRAM CBC3RAH3 AND BIND NCAL AS TOTAL          *\n//* 2. COMPILE SUB PROGRAM CBC3RAH2 AND BIND NCAL AS CBC3RAH2       *\n//* 3. COMPILE MAIN PROGRAM CBC3RAH1 AND BIND INCLUDING SUB-PROGRAMS*\n//*    CBC3RAH3, AND CBC3RAH2 WITH CALL AS CBC3RAH1.                *\n//* 4. EXECUTE PROGRAM CBC3RAH1 PROVIDING PRICE INPUT VIA SYSIN.    *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SUBPROGRAM NCAL AS TOTAL                   *\n//*******************************************************************\n//COMPBIN1 EXEC CCOMP,CALL=NCAL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAH3)',\n//   LOAD='CBC.TRIGON.SAMPLOD(TOTAL)'\n//*******************************************************************\n//* COMPILE AND BIND THE SUBRPOGRAM AS CBC3RAH2                     *\n//*******************************************************************\n//COMPBIN2 EXEC CCOMP,CALL=NCAL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAH2)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAH2)'\n//*******************************************************************\n//* COMPILE AND BIND THE MAIN PROGRAM CALL AS CBC3RAH1              *\n//*******************************************************************\n//COMPBND2 EXEC CCOMP,COND=(4,LT),CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAH1)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAH1)'\n//BIND.SYSIN DD *\n INCLUDE MYLOAD(CBC3RAH2)\n ENTRY CEESTART\n NAME CBC3RAH1(R)\n//BIND.MYLOAD DD DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAH1 EXEC  PGM=CBC3RAH1,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSIN    DD    *\n123.45\n./ ADD NAME=CBC3RAJ1 0101-00277-00277-1735-00037-00031-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3RAJ1)                    *\n//* THIS PROGRAM ILLUSTRATES THE USE OF FILE SCOPE STATIC VARIABLES.*\n//* 1. COMPILE SUB PROGRAM CBC3RAJ2 AND BIND NCAL AS CBC3RAJ2       *\n//* 2. COMPILE MAIN PROGRAM CBC3RAJ1 AND BIND INCLUDING SUB-PROGRAM *\n//*    CBC3RAJ2 WITH CALL AS CBC3RAJ1.                              *\n//* 3. EXECUTE PROGRAM CBC3RAJ1.                                    *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SUB PROGRAM NCAL AS CBC3RAJ2               *\n//*******************************************************************\n//COMPBIN1 EXEC CCOMP,CALL=NCAL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAJ2)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAJ2)'\n//*******************************************************************\n//* COMPILE AND BIND THE MAIN PROGRAM CALL AS CBC3RAJ1              *\n//*******************************************************************\n//COMPBND2 EXEC CCOMP,COND=(4,LT),CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3RAJ1)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3RAJ1)'\n//BIND.SYSIN DD *\n INCLUDE MYLOAD(CBC3RAJ2)\n ENTRY CEESTART\n NAME CBC3RAJ1(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3RAJ1 EXEC  PGM=CBC3RAJ1,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3UAAM 0102-00142-00277-1736-00030-00016-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3UAAM)                    *\n//* CONVERTS CELSIUS TEMPERATURES TO FAHRENHEIT.                    *\n//* 1. COMPILE PROGRAM CBC3UAAM AND BIND CALL AS CBC3UAAM           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3UAAM                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3UAAM)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3UAAM)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3UAAM(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3UAAM EXEC  PGM=CBC3UAAM,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSIN    DD    *\n19\n./ ADD NAME=CBC3X06C 0101-00271-00277-1736-00028-00025-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3X06C)                    *\n//* THIS EXAMPLE ILLUSTRATES FUNCTION CALLS.                        *\n//* 1. COMPILE PROGRAM CBC3X06C AND BIND CALL AS CBC3X06C           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3X06C                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3X06C)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3X06C)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3X06C(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3X06C EXEC  PGM=CBC3X06C,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3X08A 0101-00271-00277-1737-00029-00026-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3X08A)                    *\n//* THIS EXAMPLE ILLUSTRATES THE __FUNCTION__ PREDEFINED MACRO      *\n//* IN A C PROGRAM.                                                 *\n//* 1. COMPILE PROGRAM CBC3X08A AND BIND CALL AS CBC3X08A           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3X08A                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3X08A)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3X08A)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3X08A(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3X08A EXEC  PGM=CBC3X08A,COND=(4,LT)\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CBC3YIV1 0101-00271-00277-1737-00028-00025-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//MYPROCS JCLLIB ORDER=CBC.TRIGON.SAMPJCL\n//*******************************************************************\n//*                 CBC.TRIGON.SAMPJCL(CBC3YIV1)                    *\n//* ECHO ARGUMENTS TO STDOUT.                                       *\n//* 1. COMPILE PROGRAM CBC3YIV1 AND BIND CALL AS CBC3YIV1           *\n//* 2. EXECUTE FINAL LOAD MODULE FOR CBC3YIV1                       *\n//*******************************************************************\n//*******************************************************************\n//* COMPILE AND BIND THE SAMPLE PROGRAM                             *\n//*******************************************************************\n//COMPBIND EXEC CCOMP,CALL=CALL,\n//   SRC='CBC.TRIGON.SAMPSRC(CBC3YIV1)',\n//   LOAD='CBC.TRIGON.SAMPLOD(CBC3YIV1)'\n//BIND.SYSIN DD *\n ENTRY CEESTART\n NAME CBC3YIV1(R)\n//*******************************************************************\n//* EXECUTE THE SAMPLE PROGRAM                                      *\n//*******************************************************************\n//CBC3YIV1 EXEC  PGM=CBC3YIV1,COND=(4,LT),PARM='NAME ADDRESS LUMP'\n//STEPLIB  DD    DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CCOMP    0100-00277-00277-0951-00052-00052-00000-BC0THOR\n//********************************************************************\n//*                CBC.TRIGON.SAMPJCL(CCOMP)                         *\n//*  PROC TO COMPILE AND BIND A C PROGRAM                            *\n//*                                                                  *\n//*  1. CONVERT BRACKETS, CIRCUMFLEXES TO COMPILER EXPECTED VALUES.  *\n//*  2. COMPILE THE RESULTING C PROGRAM.                             *\n//*  3. BIND THE PROGRAM                                             *\n//********************************************************************\n//CCOMP    PROC CALL=CALL\n//*-------------------------------------------------------------------\n//*  CONVERT SQUARE BRACKETS TO COMPILER EXPECTED VALUES\n//*-------------------------------------------------------------------\n//CBRAKETS EXEC PGM=CBRAKETS\n//STEPLIB  DD   DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//SYSUDUMP DD   SYSOUT=*\n//SYSIN    DD   DSN=&SRC,DISP=SHR\n//SYSOUT   DD   DSN=&&CSOURCE,DISP=(,PASS),\n//         UNIT=DISK,SPACE=(CYL,(2,1),RLSE),\n//         DSORG=PS,RECFM=FB,LRECL=80\n//*-------------------------------------------------------------------\n//*  COMPILE STEP:\n//*-------------------------------------------------------------------\n//COMPILE EXEC PGM=CBCDRVR,\n//    PARM=('/AGG,EXP,LIS,OF,OPT,SO,XR,CHE(ALL)')\n//STEPLIB  DD  DSN=CEE.SCEERUN,DISP=SHR\n//         DD  DSN=CBC.SCBCCMP,DISP=SHR\n//SYSLIB   DD  DSN=CEE.SCEEH.H,DISP=SHR\n//         DD  DSN=CEE.SCEEH.SYS.H,DISP=SHR\n//         DD  DSN=CBC.SCBCSAM,DISP=SHR\n//SYSLIN   DD  DSN=&&LOADSET,DISP=(NEW,PASS),\n//         UNIT=DISK,SPACE=(TRK,(3,3)),\n//         RECFM=FB,LRECL=80,BLKSIZE=3200\n//SYSPRINT DD  SYSOUT=*\n//SYSOUT   DD  SYSOUT=*\n//SYSCPRT  DD  SYSOUT=*\n//SYSIN    DD  DSN=&&CSOURCE,DISP=(OLD,DELETE,DELETE)\n//*-------------------------------------------------------------------\n//*  BIND STEP:\n//*-------------------------------------------------------------------\n//BIND   EXEC PGM=IEWL,COND=(4,LT,COMPILE),\n//         PARM=(LIST,LET,MAP,XREF,&CALL)\n//STEPLIB  DD  DSN=CEE.SCEERUN,DISP=SHR\n//SYSLIB   DD  DSN=CEE.SCEELKEX,DISP=SHR\n//         DD  DSN=CEE.SCEELKED,DISP=SHR\n//         DD  DSN=SYS1.IMSVS.RESLIB,DISP=SHR\n//         DD  DSN=ISP.SISPLOAD,DISP=SHR\n//         DD  DSN=CBC.TRIGON.SAMPLOD,DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSN=&&LOADSET,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSLMOD  DD  DSN=&LOAD,DISP=SHR\n//SYSIN    DD  DUMMY\n./ ADD NAME=CIRCLE   0100-02122-02122-1006-00014-00014-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//*******************************************************************\n//*                 BC0THOR.PDS.JCL(CIRCLE )                        *\n//* COMPUTES AND DISPLAYS CIRCLE CIRCUMFERENCE, SPHERE VOLUME FOR A *\n//* GIVEN DIAMETER. DIAMETER IS PASSED IN THE PARM PARAMETER OF THE *\n//* JCL EXEC STATEMENT.                                             *\n//*******************************************************************\n//CIRCLE   EXEC  PGM=CIRCLE,PARM='15.5'\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=CMPRFILE 0104-02122-02122-1154-00017-00015-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//*******************************************************************\n//*                 BC0THOR.PDS.JCL(CMPRFILE )                      *\n//* READS TWO DATASETS WHOSE NAMES ARE PROVIDED AS PARMS ON THE EXEC*\n//* STATEMENT, COMPARING THEM BYTE-BY-BYTE AND REPORTS UP TO 10     *\n//* DIFFERENCES.                                                    *\n//* DISPLAYS THE PARMS FOUND ON ENTRY, SO THIS PROGRAM CAN BE USED  *\n//* TO EXPERIMENT WITH VARIOUS COMBINATIONS OF PARM VALUES, TOO.    *\n//*******************************************************************\n//CMPRFILE EXEC  PGM=CMPRFILE,\n// PARM='\"BC0THOR.DEL.FILE1\",\"BC0THOR.DEL.FILE2\"'\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n./ ADD NAME=COUNTBYT 0101-00256-00349-1403-00018-00018-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//********************************************************************\n//*                  BC0THOR.PDS.JCL(COUNTBYT)                       *\n//* READS THE INPUT1 FILE TALLYING EACH BYTE BY VALUE AND PRINTS THE *\n//* NUMBER OF EACH BYTE VALUE FOUND AT END OF FILE.                  *\n//********************************************************************\n//*\n//COUNTBYT EXEC  PGM=COUNTBYT\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//STDERR01 DD    SYSOUT=*              <== DEFAULT ERROR FILE\n//STDOUT01 DD    SYSOUT=*              <== DEFAULT OUTPUT FILE\n//STDIN01  DD    *                     <== DEFAULT INPUT FILE\n//INPUT1   DD    DSN=BC0THOR.TST.DFC7005P.PGMLIST,DISP=SHR\n./ ADD NAME=CSECMCH2 0103-00315-00318-1250-00066-00064-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//*******************************************************************\n//*                 BC0THOR.PDS.JCL(CSECMCH2)                       *\n//* FOLLOWS THE CSECTMCH PROGRAM TO CONTINUE TRYING TO MATCH THE    *\n//* ENDEVOR ELEMENTS TO LOAD LIBRARY MEMBERS.                       *\n//*TEST0: (UNMCHCS FILE ONLY) IF THERE ARE MULTIPLE MEMBER SEGMENTS *\n//*       THE RECORD IS WRITTEN WITH COMPARE CODE = 0 AND THE NEXT  *\n//*       RECORD IS READ.                                           *\n//*TEST1: ELEMENT NAME IN THE UNMCHEL RECORD IS COMPARED TO THE     *\n//*       RECORD HAVING THE LOWER VALUE IS WRITTEN WITH COMPARE     *\n//*       CODE SET TO 1 AND THE NEXT RECORD IN THAT FILE IS READ.   *\n//*TEST2: THE ELEMENT NAME IN THE UNMCHEL RECORD IS COMPARED BYTE-  *\n//*       BY BYTE WITH THE CSECT NAME IN THE UNMCHCS RECORD. IF THEY*\n//*       DIFFER MY ONE BYTE OR LESS, THE T2 INDICATOR IS SET TRUE. *\n//*TEST3: THE LANGUAGE FIELD IS COMPARED BETWEEN THE UNMCHEL AND    *\n//*       UNMCHCS RECORDS. IF EQUAL, THE T3 INDICATOR IS SET TRUE.  *\n//*ALL OUTPUT RECORDS WILL CONTAIN A COMPARE CODE IN POSITION 9,    *\n//*CONTAINING THE VALUE:                                            *\n//*0 = THIS CSECT RECORD CONTAINS MULTIPLE MEMBER SEGMENTS.         *\n//*1 = THIS RECORD FAILED TEST1. NO FURTHER TESTS WERE MADE.        *\n//*2 = THIS RECORD PASSED TEST1, BUT FAILED TESTS 2 AND 3.          *\n//*3 = THIS RECORD PASSED TEST1 AND TEST3, BUT FAILED TEST2.        *\n//*4 = THIS RECORD PASSED TEST1 AND TEST2, BUT FAILED TEST3.        *\n//*5 = THIS RECORD PASSED ALL THREE TESTS.                          *\n//*******************************************************************\n//SCRATCH  EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n DELETE BC0THOR.TST.ELEMENT\n DELETE BC0THOR.TST.CSECT\n//******************************************************************\n//* SORT THE CSECT FILE IN MEMBER NAME ORDER                       *\n//******************************************************************\n//SORT     EXEC PGM=SORT33,PARM='CORE=MAX,MSG=AP'\n//SYSUDUMP DD SYSOUT=(*,,DUMP)\n//SORTIN   DD DSN=BC0THOR.TST.UNMCHCS,DISP=SHR\n//SORTOUT  DD DSN=&&SORTCSCT,DISP=(,PASS),\n//         UNIT=DISK,SPACE=(TRK,(15,5),RLSE)\n//SORTWK01 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK02 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK03 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK04 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK05 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK06 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SYSOUT   DD SYSOUT=*\n//SYSIN    DD *\n SORT FIELDS=(19,8,CH,A)\n//******************************************************************\n//* WRITE FILES WITH MATCH INDICATORS IN POSITIONS 9:              *\n//******************************************************************\n//CSECMCH2 EXEC PGM=CSECMCH2\n//STEPLIB  DD DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//         DD DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*,RECFM=FB,LRECL=72,BLKSIZE=72\n//UNMCHCS  DD DSN=&&SORTCSCT,DISP=(OLD,PASS,DELETE)\n//UNMCHEL  DD DSN=BC0THOR.TST.UNMCHEL,DISP=SHR\n//ELEMENT  DD DSN=BC0THOR.TST.ELEMENT,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(15,5),RLSE),\n//         RECFM=FB,LRECL=80\n//CSECT    DD DSN=BC0THOR.TST.CSECT,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(15,5),RLSE),\n//         RECFM=VB,LRECL=27992,BLKSIZE=27996\n./ ADD NAME=C2COMPCK 0100-01016-01016-0843-00023-00023-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//*******************************************************************\n//*                 BC0THOR.PDS.JCL(C2COMPCK)                       *\n//* COMPARES THREE VERSIONS OF THE COBOL II COMPILER USING EDGE DATA*\n//*******************************************************************\n//SCRATCH  EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n DELETE BC0THOR.TST.C2COMPCK\n/*\n//C2COMPCK EXEC  PGM=C2COMPCK\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSOUT   DD    SYSOUT=*\n//EDGEMR   DD    DSN=BC0THOR.TSTEDGE.SORTMACH,DISP=SHR\n//OUTPUT1  DD    DSN=BC0THOR.TST.C2COMPCK,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(45,15),RLSE),\n//         DSORG=PS,RECFM=FB,LRECL=80\n./ ADD NAME=EDGEFIND 0101-01043-01191-1152-00027-00027-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//*******************************************************************\n//*                 BC0THOR.PDS.JCL(EDGEFIND)                       *\n//* STRIPS IN-HOUSE WRITTEN CSECT DATA FROM THE EDGE MACHINE        *\n//* FRIENDLY FILE FOR USE BY ENDVELMT AFTER SORTING IN MEMBER NAME  *\n//* AND CSECT NAME ORDER. MUST BE RESPECIALIZED FOR EACH USE.       *\n//*                                                                 *\n//* PRESENTLY REPORTS ALL CSECTS COMPILED WITH SSRANGE.             *\n//*******************************************************************\n//SCRATCH  EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n DELETE BC0THOR.TST.EDGEFIND\n/*\n//EDGEFIND EXEC  PGM=EDGEFIND\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSOUT   DD    SYSOUT=*\n//EDGEMR   DD    DSN=SPP.EDGE.ZZZEPA.REPORT.MACHINE,DISP=SHR\n//OUTPUT1  DD    DSN=BC0THOR.TST.EDGEFIND,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(45,15),RLSE),\n//         DSORG=PS,RECFM=FB,LRECL=80\n./ ADD NAME=EDGESTRP 0101-00362-00362-0815-00025-00025-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//*******************************************************************\n//*                 BC0THOR.PDS.JCL(EDGESTRP)                       *\n//* STRIPS IN-HOUSE WRITTEN CSECT DATA FROM THE EDGE MACHINE        *\n//* FRIENDLY FILE FOR USE BY ENDVELMT AFTER SORTING IN MEMBER NAME  *\n//* AND CSECT NAME ORDER.                                           *\n//*******************************************************************\n//SCRATCH  EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n DELETE BC0THOR.TST.EDGESTRP.INHOUSE\n/*\n//EDGESTRP EXEC  PGM=EDGESTRP\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSOUT   DD    SYSOUT=*\n//EDGEMR   DD    DSN=SPP.EDGE.TEST.EPA.MACHINE,DISP=SHR\n//OUTPUT1  DD    DSN=BC0THOR.TST.EDGESTRP.INHOUSE,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(45,15),RLSE),\n//         DSORG=PS,RECFM=FB,LRECL=80\n./ ADD NAME=EDGEVSCB 0101-01068-01068-1543-00024-00027-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//*******************************************************************\n//*                 BC0THOR.PDS.JCL(EDGEVSCB)                       *\n//* STRIPS CSECT RECORDS FOR CSECTS COMPILED USING EITHER THE VS    *\n//* COBOL R2.3 OR R2.4 COMPILER OR BY THE COBOL/390 COMPILER.       *\n//*******************************************************************\n//SCRATCH  EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n DELETE BC0THOR.TST.EDGEVSCB\n/*\n//EDGEVSCB EXEC  PGM=EDGEVSCB\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSOUT   DD    SYSOUT=*\n//EDGEMR   DD    DSN=SPP.EDGE.ZZZEPA.REPORT.MACHINE,DISP=SHR\n//OUTPUT1  DD    DSN=BC0THOR.TST.EDGEVSCB,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(45,15),RLSE),\n//         DSORG=PS,RECFM=FB,LRECL=80\n./ ADD NAME=ENDCKDUP 0105-00343-01010-1405-00040-00024-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//*******************************************************************\n//*                 BC0THOR.PDS.JCL(ENDCKDUP)                       *\n//* C PROGRAM TO REPORT ON DUPLICATE ELEMENT NAMES IN ENDEVOR. USES *\n//* FILES CREATED BY THE ENDVDATA (ASSEMBLER) PROGRAM AFTER SORTING *\n//* IN ELEMENT.ENVIRONMENT ORDER.                                   *\n//*******************************************************************\n//SCRATCH  EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n DELETE BC0THOR.TST.ENDCKDUP.DUPS\n//*\n//SORT2    EXEC PGM=SORT33,PARM='CORE=MAX,MSG=AP'\n//SYSUDUMP DD SYSOUT=(*,,DUMP)\n//SORTIN   DD DSN=BC0THOR.TST.UNSORT.ELEMENTS,DISP=SHR\n//SORTOUT  DD DSN=&&SORTED,DISP=(,PASS),\n//         UNIT=DISK,SPACE=(TRK,(15,5),RLSE)\n//SORTWK01 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK02 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK03 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK04 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK05 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK06 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SYSOUT   DD SYSOUT=*\n//SYSIN    DD *\n SORT FIELDS=(1,8,CH,A,22,8,CH,A)\n/*\n//ENDCKDUP EXEC  PGM=ENDCKDUP\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSOUT   DD    SYSOUT=*\n//ELEMENT  DD    DSN=&&SORTED,DISP=(OLD,PASS)\n//DUPS     DD    DSN=BC0THOR.TST.ENDCKDUP.DUPS,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(15,5),RLSE),\n//         DSORG=PS,RECFM=FB,LRECL=80\n./ ADD NAME=ENDVELMT 0105-00363-01010-1346-00069-00063-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//*******************************************************************\n//*                 BC0THOR.PDS.JCL(ENDVELMT)                       *\n//* MATCHES THE PRODUCTION LOAD MODULE FILE FROM EDGESTRP WITH THE  *\n//* ENDEVOR ELEMENT FILE FROM ENDVDATA. BOTH FILES ARE SORTED       *\n//* BEFORE USE. THREE OUTPUT FILES ARE WRITTEN: (1) THE MATCHED     *\n//* FILE, (2) UNMATCHED REMAINING ELEMENTS FILE, AND (3) UNMATCHED  *\n//* REMAINING LOAD MODULES FILE. THESE FILES WILL NEXT BE USED BY   *\n//* THE ENDVELM2 PROGRAM TO CONTINUE THE MATCH PROCESS.             *\n//*******************************************************************\n//SCRATCH  EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n DELETE BC0THOR.TSTSORT.ELEMENTS\n DELETE BC0THOR.TSTSORT.LMODS\n DELETE BC0THOR.TST.UNMATCH.ELEMENTS\n DELETE BC0THOR.TST.UNMATCH.LDMODS\n DELETE BC0THOR.TST.MATCHED.ELEMENTS\n//*\n//SORT1    EXEC PGM=SORT33,PARM='CORE=MAX,MSG=AP'\n//SYSUDUMP DD SYSOUT=(*,,DUMP)\n//SORTIN   DD DSN=BC0THOR.TST.EDGESTRP.INHOUSE,DISP=SHR\n//SORTOUT  DD DSN=BC0THOR.TSTSORT.LMODS,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(15,5),RLSE)\n//SORTWK01 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK02 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK03 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK04 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK05 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK06 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SYSOUT   DD SYSOUT=*\n//SYSIN    DD *\n SORT FIELDS=(1,16,CH,A)\n//*\n//SORT2    EXEC PGM=SORT33,PARM='CORE=MAX,MSG=AP'\n//SYSUDUMP DD SYSOUT=(*,,DUMP)\n//SORTIN   DD DSN=BC0THOR.TST.UNSORT.ELEMENTS,DISP=SHR\n//SORTOUT  DD DSN=BC0THOR.TSTSORT.ELEMENTS,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(15,5),RLSE)\n//SORTWK01 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK02 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK03 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK04 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK05 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK06 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SYSOUT   DD SYSOUT=*\n//SYSIN    DD *\n SORT FIELDS=(1,8,CH,A)\n/*\n//ENDVELMT EXEC  PGM=ENDVELMT\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSOUT   DD    SYSOUT=*\n//LMODS    DD    DSN=BC0THOR.TSTSORT.LMODS,DISP=SHR\n//ELEMENTS DD    DSN=BC0THOR.TSTSORT.ELEMENTS,DISP=SHR\n//MATCHED  DD    DSN=BC0THOR.TST.MATCHED.ELEMENTS,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(45,15),RLSE),\n//         DSORG=PS,RECFM=FB,LRECL=86\n//REMELMTS DD    DSN=BC0THOR.TST.UNMATCH.ELEMENTS,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(45,15),RLSE),\n//         DSORG=PS,RECFM=FB,LRECL=80\n//REMLDMDS DD    DSN=BC0THOR.TST.UNMATCH.LDMODS,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(45,15),RLSE),\n//         DSORG=PS,RECFM=FB,LRECL=80\n./ ADD NAME=ENDVPGLS 0101-01011-01011-0920-00031-00031-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//*******************************************************************\n//*                 BC0THOR.PDS.JCL(ENDVPGLS)                       *\n//* PRINT ENDEVOR ELEMENTS HAVING NO EMVSP.PGMLIST.* DATASET        *\n//*******************************************************************\n//SORT2    EXEC PGM=SORT33,PARM='CORE=MAX,MSG=AP'\n//SYSUDUMP DD SYSOUT=(*,,DUMP)\n//SORTIN   DD DSN=BC0THOR.TST.UNSORT.ELEMENTS,DISP=SHR\n//SORTOUT  DD DSN=&&SORTED,DISP=(,PASS),\n//         UNIT=DISK,SPACE=(TRK,(15,5),RLSE)\n//SORTWK01 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK02 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK03 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK04 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK05 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK06 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SYSOUT   DD SYSOUT=*\n//SYSIN    DD *\n SORT FIELDS=(1,8,CH,A,22,8,CH,A)\n/*\n//ENDVPGLS EXEC  PGM=ENDVPGLS\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSOUT   DD    SYSOUT=*\n//ELEMENT  DD    DSN=&&SORTED,DISP=(OLD,PASS)\n//PGMLIST  DD    DSN=BC0THOR.PDS.DATA(PGMLIST),DISP=SHR\n./ ADD NAME=ENDVRTVL 0101-01008-01008-1320-00024-00023-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//*******************************************************************\n//*                 BC0THOR.PDS.JCL(ENDVRTVL)                       *\n//* BUILD RETRIEVE CONTROL STATEMENTS FOR MASS BATCH RETRIEVE       *\n//* USING ENDVRTRV.                                                 *\n//*******************************************************************\n//SCRATCH  EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n DELETE BC0THOR.TST.ENDVRTVL.OUTPUT1\n/*\n//ENDVRTVL EXEC  PGM=ENDVRTVL\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSOUT   DD    SYSOUT=*\n//INPUT1   DD    DSN=BC0THOR.TST.PDSDIR,DISP=SHR\n//OUTPUT1  DD    DSN=BC0THOR.TST.ENDVRTVL.OUTPUT1,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(30,5),RLSE),\n//         DSORG=PS,RECFM=FB,LRECL=80\n./ ADD NAME=ENDVRTV2 0100-01254-01254-1453-00024-00024-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//*******************************************************************\n//*                 BC0THOR.PDS.JCL(ENDVRTV2)                       *\n//* BUILD RETRIEVE CONTROL STATEMENTS FOR MASS BATCH RETRIEVE       *\n//* USING ENDVRTRV WITH DATA FROM ENDVDATA.                         *\n//*******************************************************************\n//SCRATCH  EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n DELETE BC0THOR.TST.ENDVRTV2.OUTPUT1\n/*\n//ENDVRTV2 EXEC  PGM=ENDVRTV2\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSOUT   DD    SYSOUT=*\n//INPUT1   DD    DSN=BC0THOR.TST.UNSORT.ELEMENTS,DISP=SHR\n//OUTPUT1  DD    DSN=BC0THOR.TST.ENDVRTV2.OUTPUT1,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(30,5),RLSE),\n//         DSORG=PS,RECFM=FB,LRECL=80\n./ ADD NAME=ENDVXPND 0102-00350-01008-1100-00025-00023-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//*******************************************************************\n//*                 BC0THOR.PDS.JCL(ENDVXPND)                       *\n//* C PROGRAM TO EXPAND A COMPRESSED ENDEVOR FILE.                  *\n//*******************************************************************\n//SCRATCH  EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n DELETE BC0THOR.TST.ENDVXPND.OUTPUT1\n/*\n//ENDVXPND EXEC  PGM=ENDVXPND\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSOUT   DD    SYSOUT=*\n//*NPUT1   DD    DSN=BC0THOR.TST.DFC7005P.PGMLIST,DISP=SHR\n//INPUT1   DD    DSN=EADMIN.ENDEVOR.PRC2LIST(GCIICNL),DISP=SHR\n//*NPUT1   DD    DSN=EADMIN.HCS.PRCLIST.STAGE2,DISP=SHR\n//OUTPUT1  DD    DSN=BC0THOR.TST.ENDVXPND.OUTPUT1,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(30,5),RLSE),\n//         DSORG=PS,RECFM=VB,LRECL=28015\n./ ADD NAME=MSASMMOD 0101-01207-01207-1040-00105-00105-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//*********************************************************************\n//*                 BC0THOR.PDS.JCL(MSASMMOD)                         *\n//* 1. SCRATCH DATASETS CREATED WITHIN THE JOB                        *\n//* 2. MSASMMOD (C LANGUAGE PROGRAM) STRIPS LOCALLY WRITTEN ASSEMBLER *\n//*    CSECT RECORDS FROM THE EDGE MACHINE FRIENDLY FILE.             *\n//* 3. SORT THE MSASMMOD DATASET IN CSECT NAME, MEMBER NAME, AND      *\n//*    LOAD LIBRARY NAME ORDER.                                       *\n//* 4. MSMCHMST EXTRACT THE PROGRAM ELEMENT RECORDS FROM THE ENDEVOR  *\n//*    MASTER FILE.                                                   *\n//* 5. SORT THE ELEMENT FILE IN ELEMENT NAME ORDER.                   *\n//* 6. MSASMRPT (ASSEMBLER LANGUAGE PROGRAM) READS THE SORTED FILE    *\n//*    AND PRODUCES THE ASSEMBLER CSECT REPORT.                       *\n//*********************************************************************\n//*\n//*********************************************************************\n//* 1. SCRATCH FILES CREATED DURING THE RUN                           *\n//*********************************************************************\n//SCRATCH  EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n DELETE BC0THOR.DEL.MSASMMOD\n DELETE BC0THOR.DEL.MSASMMOD.SORTED\n DELETE BC0THOR.DEL.MSMCHMST\n DELETE BC0THOR.DEL.MSMCHMST.SORTED\n DELETE BC0THOR.DEL.MSASMRPT.REPORT\n DELETE BC0THOR.DEL.MSASMRPT.SUMMARY\n//*\n//*********************************************************************\n//* 2. STRIP OUT THE IN-HOUSE WRITTEN CSECT RECORDS FROM THE EDGE     *\n//*    MACHINE FRIENDLY FILE.                                         *\n//*********************************************************************\n//MSASMMOD EXEC  PGM=MSASMMOD\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSOUT   DD    SYSOUT=*\n//EDGEMR   DD    DSN=SPP.EDGE.ZZZEPA.REPORT.MACHINE,DISP=SHR\n//OUTPUT1  DD    DSN=BC0THOR.DEL.MSASMMOD,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(45,15),RLSE),\n//         DSORG=PS,RECFM=FB,LRECL=80\n//*********************************************************************\n//* 3. SORT IN CSECT,MEMBER, LIBRARY ORDER                            *\n//*********************************************************************\n//SORT1    EXEC PGM=SORT33,PARM='CORE=MAX,MSG=AP'\n//SYSUDUMP DD SYSOUT=(*,,DUMP)\n//SORTIN   DD DSN=BC0THOR.DEL.MSASMMOD,DISP=SHR\n//SORTOUT  DD    DSN=BC0THOR.DEL.MSASMMOD.SORTED,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(45,15),RLSE),\n//         DSORG=PS,RECFM=FB,LRECL=80\n//SORTWK01 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK02 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK03 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK04 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK05 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK06 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SYSOUT   DD SYSOUT=*\n//SYSIN    DD *\n SORT FIELDS=(1,8,CH,A,32,8,CH,A,41,4,CH,A)\n//*\n//*********************************************************************\n//* 4. STRIP PROGRAM ELEMENT RECORDS FROM THE ENDEVOR MASTER FILE.    *\n//*********************************************************************\n//MSMCHMST EXEC  PGM=MSMCHMST\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//ENDVMSTR DD    DSN=TEST.ENDEVOR.MASTER,DISP=SHR\n//ELEMENTS DD    DSN=BC0THOR.DEL.MSMCHMST,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(10,5),RLSE),\n//         DSORG=PS,RECFM=FB,LRECL=80\n//*********************************************************************\n//* 5. SORT ELEMENT FILE IN ELEMENT NAME ORDER                        *\n//*********************************************************************\n//SORT2    EXEC PGM=SORT33,PARM='CORE=MAX,MSG=AP'\n//SYSUDUMP DD SYSOUT=(*,,DUMP)\n//SORTIN   DD DSN=BC0THOR.DEL.MSMCHMST,DISP=SHR\n//SORTOUT  DD DSN=BC0THOR.DEL.MSMCHMST.SORTED,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(15,5),RLSE),\n//         DSORG=PS,RECFM=FB,LRECL=80\n//SORTWK01 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK02 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK03 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK04 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK05 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK06 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SYSOUT   DD SYSOUT=*\n//SYSIN    DD *\n SORT FIELDS=(1,8,CH,A)\n//*********************************************************************\n//* 6. WRITE THE ASSEMBLER CSECT REPORT                               *\n//*********************************************************************\n//MSASMRPT EXEC  PGM=MSASMRPT\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//ALLCSECT DD    DSN=BC0THOR.DEL.MSASMMOD.SORTED,DISP=SHR\n//ELEMENTS DD    DSN=BC0THOR.DEL.MSMCHMST.SORTED,DISP=SHR\n//REPORT   DD    DSN=BC0THOR.DEL.MSASMRPT.REPORT,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(100,10),RLSE),DSORG=PS\n//SUMMARY  DD    DSN=BC0THOR.DEL.MSASMRPT.SUMMARY,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(10,5),RLSE),\n//         DSORG=PS,RECFM=FB,LRECL=8\n./ ADD NAME=MSMCHMOD 0110-01200-01205-1103-00105-00025-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//*******************************************************************\n//*                 BC0THOR.PDS.JCL(MSMCHMOD)                       *\n//* 1. SCRATCH DATASETS CREATED WITHIN THE JOB                      *\n//* 2. MSMCHMOD (C LANGUAGE PROGRAM) STRIPS IN-HOUSE WRITTEN CSECT  *\n//*    DATA FROM THE EDGE MACHINE FRIENDLY FILE.                    *\n//* 3. SORT THE MSMCHMOD DATASET IN CSECT NAME, MEMBER NAME, AND    *\n//*    LOAD LIBRARY NAME ORDER.                                     *\n//* 4. MSMCHMST EXTRACT THE PROGRAM ELEMENT RECORDS FROM THE ENDEVOR*\n//*    MASTER FILE.                                                 *\n//* 5. SORT THE ELEMENT FILE IN ELEMENT NAME ORDER.                 *\n//* 6. MSMCHRPT (ASSEMBLER LANGUAGE PROGRAM) READS THE SORTED FILE  *\n//*    AND PRODUCES THE MISMATCHED CSECT REPORT.                    *\n//*******************************************************************\n//*\n//*******************************************************************\n//* 1. SCRATCH FILES CREATED DURING THE RUN                         *\n//*******************************************************************\n//SCRATCH  EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n DELETE BC0THOR.DEL.MSMCHMOD\n DELETE BC0THOR.DEL.MSMCHMOD.SORTED\n DELETE BC0THOR.DEL.MSMCHMST\n DELETE BC0THOR.DEL.MSMCHMST.SORTED\n DELETE BC0THOR.DEL.MSMCHRPT.REPORT\n DELETE BC0THOR.DEL.MSMCHRPT.SUMMARY\n//*\n//*******************************************************************\n//* 2. STRIP OUT THE IN-HOUSE WRITTEN CSECT RECORDS FROM THE EDGE   *\n//*    MACHINE FRIENDLY FILE.                                       *\n//*******************************************************************\n//MSMCHMOD EXEC  PGM=MSMCHMOD\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSOUT   DD    SYSOUT=*\n//EDGEMR   DD    DSN=SPP.EDGE.ZZZEPA.REPORT.MACHINE,DISP=SHR\n//OUTPUT1  DD    DSN=BC0THOR.DEL.MSMCHMOD,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(45,15),RLSE),\n//         DSORG=PS,RECFM=FB,LRECL=80\n//*******************************************************************\n//* 3. SORT IN CSECT,MEMBER, LIBRARY ORDER                          *\n//*******************************************************************\n//SORT1    EXEC PGM=SORT33,PARM='CORE=MAX,MSG=AP'\n//SYSUDUMP DD SYSOUT=(*,,DUMP)\n//SORTIN   DD DSN=BC0THOR.DEL.MSMCHMOD,DISP=SHR\n//SORTOUT  DD    DSN=BC0THOR.DEL.MSMCHMOD.SORTED,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(45,15),RLSE),\n//         DSORG=PS,RECFM=FB,LRECL=80\n//SORTWK01 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK02 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK03 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK04 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK05 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK06 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SYSOUT   DD SYSOUT=*\n//SYSIN    DD *\n SORT FIELDS=(1,8,CH,A,32,8,CH,A,41,4,CH,A)\n//*\n//*******************************************************************\n//* 4. STRIP PROGRAM ELEMENT RECORDS FROM THE ENDEVOR MASTER FILE.  *\n//*******************************************************************\n//MSMCHMST EXEC  PGM=MSMCHMST\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//ENDVMSTR DD    DSN=TEST.ENDEVOR.MASTER,DISP=SHR\n//ELEMENTS DD    DSN=BC0THOR.DEL.MSMCHMST,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(10,5),RLSE),\n//         DSORG=PS,RECFM=FB,LRECL=80\n//*******************************************************************\n//* 5. SORT ELEMENT FILE IN ELEMENT NAME ORDER                      *\n//*******************************************************************\n//SORT2    EXEC PGM=SORT33,PARM='CORE=MAX,MSG=AP'\n//SYSUDUMP DD SYSOUT=(*,,DUMP)\n//SORTIN   DD DSN=BC0THOR.DEL.MSMCHMST,DISP=SHR\n//SORTOUT  DD DSN=BC0THOR.DEL.MSMCHMST.SORTED,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(15,5),RLSE),\n//         DSORG=PS,RECFM=FB,LRECL=80\n//SORTWK01 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK02 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK03 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK04 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK05 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SORTWK06 DD UNIT=DISK,SPACE=(CYL,(5,5))\n//SYSOUT   DD SYSOUT=*\n//SYSIN    DD *\n SORT FIELDS=(1,8,CH,A)\n//*******************************************************************\n//* 6. WRITE THE CSECT MISMATCH REPORT                              *\n//*******************************************************************\n//MSMCHRPT EXEC  PGM=MSMCHRPT\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//ALLCSECT DD    DSN=BC0THOR.DEL.MSMCHMOD.SORTED,DISP=SHR\n//ELEMENTS DD    DSN=BC0THOR.DEL.MSMCHMST.SORTED,DISP=SHR\n//REPORT   DD    DSN=BC0THOR.DEL.MSMCHRPT.REPORT,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(100,10),RLSE),DSORG=PS\n//SUMMARY  DD    DSN=BC0THOR.DEL.MSMCHRPT.SUMMARY,DISP=(,CATLG),\n//         UNIT=DISK,SPACE=(TRK,(10,5),RLSE),\n//         DSORG=PS,RECFM=FB,LRECL=8\n./ ADD NAME=RDVSMSEQ 0101-00319-00319-1358-00014-00013-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//*******************************************************************\n//*                 BC0THOR.PDS.JCL(RDVSMSEQ)                       *\n//* COUNT RECORDS IN A KSDS AND PRINT THE TOTAL                     *\n//*******************************************************************\n//RDVSMSEQ EXEC  PGM=RDVSMSEQ\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//VSAMFILE DD    DSN=EADMIN.ENDEVOR.STAGE1,DISP=SHR\n./ ADD NAME=RUNTESTS 0100-00332-00332-1657-00020-00020-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//*******************************************************************\n//*                 BC0THOR.PDS.JCL(RUNTESTS)                       *\n//* C PROGRAM TO SPLIT THE OUTPUT FILE FROM PROGRAM MOFN2 INTO 8    *\n//* FILES, EACH CONTAINING RECORDS WHICH SOLVE A PARTICULAR FORMULA.*\n//*******************************************************************\n/*\n//RUNTESTS EXEC  PGM=RUNTESTS\n//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//         DD    DSN=CEE.SCEERUN,DISP=SHR\n//SYSUDUMP DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSOUT   DD    SYSOUT=*\n//INPUT1   DD    DSN=BC0THOR.DEL.SPLIT4.OUTPUT1,DISP=SHR\n//INPUT2   DD    DSN=BC0THOR.DEL.SPLIT4.OUTPUT1,DISP=SHR\n//INPUT3   DD    DSN=BC0THOR.DEL.SPLIT4.OUTPUT1,DISP=SHR\n//INPUT4   DD    DSN=BC0THOR.DEL.SPLIT4.OUTPUT1,DISP=SHR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$SAMPSR$": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00Q\\x00\\x97\\x11\\x0f\\x01\\x02\\x12\\x9f\\x01E\\x00\\x0c\\x00\\x08\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1997-04-20T00:00:00", "modifydate": "2002-05-09T01:45:51", "lines": 12, "newlines": 8, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBL JOB (ACCT#),PDSLOAD,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*\n//LOA1 EXEC PGM=PDSLOAD            /* FROM FILE 093 - LOAD ON FILE 035\n//STEPLIB  DD DISP=SHR,DSN=CBT.CBT445.FILE035.PDS\n//SYSUT1   DD DISP=SHR,DSN=SBGOLOB.CBT444.FILE559($SAMPSRC)\n//SYSPRINT DD SYSOUT=*\n//SYSUT2   DD DISP=(NEW,CATLG,DELETE),DSN=SBGOLOB.FILE559.SAMPSRC,\n//   DCB=(RECFM=FB,LRECL=80,BLKSIZE=8000),\n//   SPACE=(TRK,(45,30,89),RLSE),UNIT=SYSALLDA,VOL=SER=DATA04\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$SAMPSRC": {"ttr": 2059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x12\\x9f\\x01\\x02\\x12\\x9f\\x01A\\x14+\\x14+\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-05-09T00:00:00", "modifydate": "2002-05-09T01:41:00", "lines": 5163, "newlines": 5163, "modlines": 0, "user": "BC0THOR"}, "text": "./ ADD NAME=$$README 0104-00271-02128-1559-00283-00030-00255-BC0THOR\nThis PDS contains a number of members whose names begin with CBC3....\nthat are the C Language (not C++) sample programs contained in\nCBC.SCBCSAM. Some of these have been modified slightly for one reason\nor another - usually to correct minor errors.\n\nIBM provided set of mainframe C language programs to illustrate use of\nthe C language in the mainframe environment. Of particular value are\nthose showing how to access mainframe datasets, including QSAM and VSAM\nand also use of the decimal data type to process packed decimal data.\n\nSample JCL to execute these programs is contained in the SAMPJCL library\n\nMembers whose names do NOT begin with CBC3.... are utilities placed here\nto aid in the use of the C Language on the mainframe.\n\n1. CBRAKETS is a program that converts square brackets and circumflexes\n   to the values needed by the compiler. Unfortunately, there are\n   several different notions of what these characters should be. I have\n   done the following to aid in use of C on the mainframe:\n   a) In Reflection, I remap the square brackets and circumflex (the hat\n      character, shift-6) to display the ANSI value for these characters\n      rather than the vertical-bar, cent-sign, and not-sign that is the\n      default. This causes them to display properly on the screen in\n      TSO ISPF EDIT. However, the compiler does not recognize them in\n      this form.\n   b) There is a CLIST named BKT that I keep in my CLIST library when\n      doing C that converts several varieties of square brackets to the\n      value that is displayed properly in TSO ISPF EDIT. When beginning\n      an EDIT session with a new C program, I issue the BKT command to\n      convert so that brackets are displayed properly. (The compiler\n      uses values that display as a capital Y with a dot over it for\n      left bracket, and an umlaut - double dot that looks almost like\n      a double quote as a right bracket).\n   c) To make the compiler happy, I run the C source program through\n      the CBRAKETS program before compiling. The only downside to this\n      is that header files must be left in compiler form, as they do\n      not go through CBRAKETS.\n2. CCMP is a CLIST that can be used to compile and bind the program\n   currently in the ISPF EDIT window. It invokes edit macro CEDIT and\n   passes the name of the current source member. CEDIT applies the\n   member name to the JCL in EDCCB and submits the resulting job,\n   which converts brackets to compiler expected values, compiles the\n   resulting source, and binds (linkedits) the program into your load\n   library. To use, copy CCMP and CEDIT into your CLIST library, and\n   EDCCB into your JCL library. Edit all three to use your dataset\n   names before use.\n\n3. OPEN statements for files differ on the mainframe from normal PC\n   use. Some examples are:\n\n  fopen(\"asa.file\", \"w,recfm=fba\");\n  fopen(\"test.file\",\"wb, recfm=f, lrecl=80\");\n  fopen(qual_pds,\"rb\");\n  fopen(\"a.b(memnm)\",\"r\");\n  fopen(\"mygdg(+1)\",\"a,recfm=f\");\n  fopen(\"a.b\",\"w+\");\n  fopen(\"dd:vsamesds\",\"rb,type=record\");\n*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n*                 Sample Programs in this PDS                         *\n*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n\nCBC3GAS1 OK  Writes to an ASA file.\n\nCBC3GCL1 OK  Gets local time from current locale.\n\nCBC3GDC1 OK  Demonstrates arithmetic using decimal variables.\n\nCBC3GDC2 OK  Shows use of relational expression with decimal variables.\n\nCBC3GDC3 OK  Demonstrates use of decimal data type.\n\nCBC3GDC4 OK  Demonstrates use of decimal data type.\n\nCBC3GDI1 OK  Prints the __AMRC Structure. (Long run: writes until B37).\n\nCBC3GDI2 OK  Shows SIGIOERR use. (Long run: writes until B37).\n\nCBC3GDLI OK  Shows how to tell if SAA C or POSIX locale is in effect.\n\nCBC3GEV1 OK  Demonstrates how Environment Variables are propagated.\n\nCBC3GHF1 OK  Demonstrates use of unnamed pipes.\n\nCBC3GHF2 XX  Shows use of named pipes. Program needed a #define and\n             several #include statements to compile correctly. Gets\n             errno=134 in execution.\n\nCBC3GHF3 XX  Uses HFS Stream I/O. Gets error opening file: function not\n             implemented.\n\nCBC3GIP0 OK  This is a locally written main() which calls the subroutine\n             in CBC3GIP1 to read a PDS directory.\n\nCBC3GIP1 OK  This is a set of subroutines that can be used to obtain\n             a list of PDS member names. It requires a MAIN program\n\nCBC3GIS3 OK  Used to show ISPF panel use. Had to add #include for\n             string.h and prototype for ISPLINK to compile RC=0.\n             uses CLIST CBC3GIS1 in File 561 and panels CBC3GIS2,\n             CBC3GIS4, and CBC3GIS5 in File 562.\n\nCBC3GIS8 OK  Used to show ISPF panel use. Had to correct the #pragma\n             and #extern and prototype statements for ISPLINK to make\n             it compile with RC=0. uses CLIST CBC3GIS6 in File 561 and\n                            panels CBC3GIS7 and CBC3GIS4 in File 562.\n\nCBC3GMF1 OK  Illustrates creation of PDS dataset members (and the PDS\n             if it doesn't pre-exist), and deletion of a PDS member.\n             This sample is modified from the original.\n\n\nCBC3GMF2 OK  Shows how to rename a PDS (or any flat file). This is a\n             modification of the original program.\n\nCBC3GMT1 OK  Multi-tasking Facility Sample 1. This program produces\n             the sum of a series of products of numbers in its input\n             datasets, but does no MTA functions. It probably was\n             intended as a comparison to the true MTA sample, CBC3GMT2.\n\nCBC3GMT2 XX  Multi-Tasking Facility Sample 2. This program produces no\n             output, though compiles and execution are error free.\n\nCBC3GMV1 OK  Displays C Language variant characters in hex as they are\n             supplied in a dataset, and as the compiler expects them.\n\nCBC3GOF1 OK  Shows memory file usage with the type=memory operand of\n             the fopen() function.\n\nCBC3GOP1 XX  Show effects of optimization (?). Compile error on:\n                inline int which_group(int a) {\n                CBC3277 Syntax error: possible missing ';' or ','?\n                CBC3485 Parameter declarator list is incompatible with\n                        declarator for inline.\n\nCBC3GOP2 XX  Shows effects of optimization (?). Produces no output.\n\nCBC3GOP3 XX  Demonstrates how numeric conversions are done. Produces no\n             output.\n\nCBC3GOS1 OK  This example demonstrates GDG I/O. It contains JCL to\n             create a GDG. The C program is compiled and run in-line\n             and fails (deliberately) as it attempts to open the GDG\n             with incorrect file charactersitics.\n\nCBC3GOS3 OK  This example shows how updated records are read.\n\nCBC3GRE1 OK  Shows how to make strings constant. Displays \"Hello World\"\n\nCBC3GRE3 XX  Assembler subroutine part of CBC3GRE4 sample. Assembles\n             clean but gets binder errors when combined with CBC3GRE4.\n\nCBC3GRE4 XX  Shows how an assembler program can reference objects in\n             the writable static area. Compiles clean, but gets link\n             errors when combined with CBC3GRE3.\n\nCBC3GVS1 OK  Demonstrates VSAM ESDS use and how to access the\n             __amrc->__RBA field.\n\nCBC3GVS2 OK  Demonstrates VSAM KSDS use. Execution JCL is CBC3GVS3.\n\nCBC3GVS4 OK  Demonstrates VSAM RRDS use.\n\nCBC3GTH1 ??  Uses thread-specific data to insure that storage acquired\n             by a specific thread is freed when the thread ends.\n             Compiled, ran clean, but no output, so did it work?\n\nCBC3GWT2 OK  C program calls an assembler subroutine to display a\n             messge. The C program CBC3GWT2 had a coding error in the\n             #pargma statement, in which dynwto should have been DYNWTO.\n\nCBC3RAA  OK  Shows use of the switch statement with break. A fourth\n             value was added to the enum to permit testing the default\n             for the switch instruction.\n\nCBC3RAAA OK  A simple C program that calls the cos() function and\n             displays the result using printf().\n\nCBC3RAAB OK  Sample of a C program calling another C program, passing\n             and receiving parameters.\n\nCBC3RAAD OK  Show use of character constants.\n\nCBC3RAAE OK  Demonstrates use of string constants with the string\n             functions strcpy() and strcat().\n\nCBC3RAAF OK  Illustrates how auto variables are unique within the block\n             in which they are defined. Shows call to another function\n             defined in the same program.\n\nCBC3RAAG OK  Sample to show how to read data from SYSIN, build a char-\n             acter string, pass the string to an included function,\n             where it is sorted. On return the sorted string is printed.\n\nCBC3RAAI OK  Uses external variables (defined outside a program block)\n             for the same purpose as CBC3RAAG.\n\nCBC3RAAK OK  Shows use of block scope static variables.\n\nCBC3RAAM OK  This example uses the void data type.\n\nCBC3RAAN OK  Illustrates use of the enum type.\n\nCBC3RAAO OK  This example uses a one-dimensional array.\n\nCBC3RAAP OK  This example uses a multi-dimensional array.\n\nCBC3RAAQ OK  This program searches for the first occurrence of a\n             character string in an array of character strings.\n\nCBC3RAAR ??  This example uses an abstract data type and a header file\n             CBC3RAR1. Difficult to tell if ti worked properly, as there\n             is no output.\n\nCBC3RAAS OK  This program illustrates linked lists.\n\nCBC3RAAT OK  THIS EXAMPLE USES AN ARRAY OF POINTERS TO FUNCTIONS.\n\nCBC3RAAU OK  This example uses a prototype function declarator.\n\nCBC3RAAV OK  This example shows how a function is declared and defined.\n\nCBC3RAAX OK  This example shows how a parameter is passed to a function.\n\nCBC3RAAY OK  This example shows how an address is passed to a function.\n\nCBC3RAAZ OK  This example shows how loss of precision occurs during type\n             conversion.\n\nCBC3RAA1 OK  This example shows how the values of data objects change in\n             nested blocks.\n\nCBC3RAA2 OK  This program counts the characters in the strings that are\n             part of an array of pointers to characters.\n             The count stops when one of the digits 0 through 9 is\n             found and resumes at the beginning of the next string.\n\nCBC3RAA3 OK  This example shows how the continue statement can be used.\n\nCBC3RAA4 OK  This program counts the characters in strings that are part\n             of an array of pointers to characters. The count excludes\n             the digits 0 through 9.\n\nCBC3RAA5 OK  This example illustrates the do statement.\n\nCBC3RAA6 OK  This example shows how a goto statement may be used.\n\nCBC3RAA7 OK  This example shows how the while statement may be used.\n\nCBC3RAA8 OK  This example illustrates the use of a macro.\n\nCBC3RAA9 OK  This example is equivalent to CBC3RAA8.\n\nCBC3RABA OK  This example shows how predefined macros are used.\n\nCBC3RABB OK  This example shows how predefined macros are used.\n\nCBC3RABC OK  This example uses conditional compilation directives.\n\nCBC3RABD OK  This example shows how #line is used.\n\nCBC3RABE OK  This example shows how #pragma inline may be used.\n\nCBC3RABF OK  This example illustrates blocks, nesting, and scope.\n\nCBC3RABG OK  This example prints out ctest characters.\n\nCBC3RABI OK  This example shows how the switch statement may be used.\n\nCBC3RAH1 OK  This example shows the linkage of extern objects/functions.\n             In this file, the program receives the price of an item,\n             adds the tax, and prints the total cost of the item.\n\nCBC3RAJ1 OK  This program illustrates the use of file scope static\n             variables.\n\nCBC3UAAM OK  Converts celsius temperatures to fahrenheit.\n\nCBC3X06C OK  This example illustrates function calls.\n\nCBC3X08A ok  This example illustrates the __FUNCTION__ predefined macro\n             in a C program.\n\nCBC3YIV1 OK  Echo arguments to STDOUT.\n./ ADD NAME=BKT      0100-00271-00271-1533-00048-00048-00000-BC0THOR\n/*********************************************************************/\n/*   PURPOSE: CONVERTS BRACKETS FOR EDITING C LANGUAGE SOURCE AND    */\n/*            PROVIDES A COUNT OF THE LEFT AND RIGHT BRACKETS FOR    */\n/*            VALIDATION. FIRST, CONVERTS ALL TRIGRAPH AND TRUE HEX  */\n/*            BRACKET VALUES TO THOSE USABLE IN TSO/ISPF EDIT, THEN  */\n/*            COUNTS THE LEFT AND RIGHT BRACKETS AND REPORTS ANY     */\n/*            INEQUALITY. CIRCUMFLEX ALSO CONVERTED.                 */\n/*   AUTHOR:  BC0THOR BASED ON IBM MANUAL. CREATED: 08/14/2000       */\n/*   TYPICAL USER(S): BC0THOR                                        */\n/*   PARAMETERS PASSED: NONE                                         */\n/*   CDC COMPLIANCE: NO DATE DEPENDENCIES                            */\n/*********************************************************************/\n/*               MAINTENANCE RECORD: LAST 3 CHANGES                  */\n/*********************************************************************/\n/*   DATE    LOGONID REASON FOR CHANGE & WHAT WAS DONE               */\n/*-------------------------------------------------------------------*/\n/*                                                                   */\n/*********************************************************************/\nPROC 0 DEBUG(     )\nISREDIT MACRO\nCONTROL NOLIST NOSYMLIST NOCONLIST MSG\nIF &DEBUG = DEBUG THEN CONTROL LIST CONLIST SYMLIST\n/* CALL 'TEST.LOAD(CLISTMON)' 'BKT     '  */\nISREDIT CHANGE ALL C'??(' X'BA'    /*********************************/\nISREDIT CHANGE ALL C'??)' X'BB'    /* CONVERT TRIGRAPHS, X'AD' AND  */\nISREDIT CHANGE ALL X'AD' X'BA'     /* X'BD' TO THE ISPF EDIT VALUES */\nISREDIT CHANGE ALL X'BD' X'BB'     /* X'BA' AND X'BB'.              */\n                                   /*********************************/\nISREDIT CHANGE ALL X'5F' X'B0'     /* CIRCUMFLEX (HAT)              */\n\nISREDIT FIND C']' ALL NX\nISREDIT (N1) = FIND_COUNTS\nISREDIT FIND C'[' ALL NX\nISREDIT (N2) = FIND_COUNTS\nIF (&N1 \u00ac= &N2) THEN WRITE UNBALANCED BRACKETS: &N1 LEFT, &N2 RIGHT\n\nISREDIT FIND C'(' ALL NX\nISREDIT (N1) = FIND_COUNTS\nISREDIT FIND C')' ALL NX\nISREDIT (N2) = FIND_COUNTS\nIF (&N1 \u00ac= &N2) THEN WRITE UNBALANCED PARENTHESES: &N1 LEFT, &N2 RIGHT\n\nISREDIT FIND C'{'  ALL NX\nISREDIT (N1) = FIND_COUNTS\nISREDIT FIND C'}' ALL NX\nISREDIT (N2) = FIND_COUNTS\nIF (&N1 \u00ac= &N2) THEN WRITE UNBALANCED CURLY BRACES: &N1 LEFT, &N2 RIGHT\nEND\n./ ADD NAME=CBC3GAS1 0101-00223-00257-1008-00039-00025-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how to write to an ASA file. a file for output */\n/* with recfm=fba is opened and several records are written to it:   */\n/*  1. abcdef with doublespace before                                */\n/*  2. 345 with skip-to-head-of-form before                          */\n/*  3. 9034 with four spaces before                                  */\n/* Notes:                                                            */\n/*  1. When fopen supplies a dsname, the file is opened if is is an  */\n/*     existing, cataloged dataset. If not, it is dynamically created*/\n/*  2. When fopen supplies a ddnane, the dd statement supplied in the*/\n/*     execution time jcl is used, if present. if not present, a     */\n/*     temporary file is allocated and deleted at end of job.        */\n/*********************************************************************/\n\n#include <stdio.h>\n#define MAX_LEN 80\n\nint main(void) {\n   FILE *fp;\n   int i;\n   char s[MAX_LEN+1];\n\n/* fp = fopen(\"asa.file\", \"w, recfm=fba\"); /* open userid.asa.file   */\n   fp = fopen(\"dd:print1\", \"w, recfm=fba\"); /* open ddname print1    */\n   if (fp != NULL) {\n      fputs(\"\\n\\nabcdef\\f\\r345\\n\\n\", fp);\n      fputs(\"\\n\\n9034\\n\", fp);\n      fclose(fp);\n\n   return(0);\n   }\n\n/* fp = fopen(\"asa.file\", \"r\");             /* open userid.asa.file  */\n   fp = fopen(\"dd:print1\", \"r\");            /* open ddname print1    */\n   for (i = 0; i < 5; i++) {\n     fscanf(fp, \"%s\", &s[0]);\n     printf(\"string = %s\\n\",s);\n   }\n}\n./ ADD NAME=CBC3GCL1 0101-00223-00257-1011-00034-00028-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how to get the local time formatted by the     */\n/* current locale.                                                   */\n/* Note that the output from the printf function is written to the   */\n/* SYSPRINT dd statement, if it is supplied in the execution JCL. If */\n/* not, the printf output is dynamically allocated to a SYSOUT=A     */\n/* file.                                                             */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <time.h>\n#include <locale.h>\n\nint main(void){\n    char dest[80];\n    int ch;\n    time_t temp;\n    struct tm *timeptr;\n    temp = time(NULL);\n    timeptr = localtime(&temp);\n    /* Fetch default locale name */\n    printf(\"Default empty_str locale is %s\\n\",setlocale(LC_ALL,\"\"));\n    ch = strftime(dest,sizeof(dest)-1,\n      \"Local C datetime is %c\", timeptr);\n    printf(\"%s\\n\",  dest);\n\n    /* Set new Texan locale name */\n    printf(\"New locale is %s\\n\", setlocale(LC_ALL,\"Texan.IBM-1047\"));\n    ch = strftime(dest,sizeof(dest)-1,\n      \"Texan datetime is %c \", timeptr);\n    printf(\"%s\\n\", dest);\n\n    return(0);\n}\n./ ADD NAME=CBC3GDC1 0101-00223-00249-0942-00038-00034-00000-BC0THOR\n/*********************************************************************/\n/* This example demonstrates arithmetic operations on decimal        */\n/* variables. output is written to the SYSPRINT file via the printf  */\n/* function.                                                         */\n/*********************************************************************/\n\n#include <decimal.h>            /* decimal header file */\n#include <stdio.h>\n\nint main(void)\n{\n\ndecimal(10,2) op_1 = 12d;\ndecimal(5,5) op_2 = -.12345d;\ndecimal(24,12) op_3 = 12.34d;\ndecimal(20,5) op_4 = 11.01d;\n\ndecimal(14,5) res_add;\ndecimal(25,2) res_sub;\ndecimal(15,7) res_mul;\ndecimal(31,14) res_div;\n\nres_add = op_1 + op_2;\nres_sub = op_3 - op_1;\nres_mul = op_2 * op_1;\nres_div = op_3 / op_4;\n\nprintf(\"res_add =%D(*,*)\\n\",digitsof(res_add),\n       precisionof(res_add),res_add);\nprintf(\"res_sub =%D(*,*)\\n\",digitsof(res_sub),\n       precisionof(res_sub),res_sub);\nprintf(\"res_mul =%D(*,*)\\n\",digitsof(res_mul),\n       precisionof(res_mul),res_mul);\nprintf(\"res_div =%D(*,*)\\n\",digitsof(res_div),\n       precisionof(res_div), res_div);\n\nreturn(0);\n}\n./ ADD NAME=CBC3GDC2 0100-00223-00249-1311-00025-00025-00000-BC0THOR\n\n/* this example shows how to use a relational expression with the */\n/* decimal data type */\n\n#include <decimal.h>\n\ndecimal(10,3) pdval = 0000023.423d;    /* Decimal declaration*/\nint ival = 1233;                       /* Integer declaration*/\nfloat fval = 1234.34;                  /* Float declaration*/\ndouble dval = 251.5832;                /* Double declaration*/\nlong double lval = 37486.234;          /* Long double declaration*/\n\nint main(void)\n{\n  decimal(15,6) value = 000485860.085999d;\n/*Perform relational operation between other data types and decimal*/\n  if (pdval < ival) printf(\"pdval is the smallest !\\n\");\n  if (pdval < fval) printf(\"pdval is the smallest !\\n\");\n  if (pdval < dval) printf(\"pdval is the smallest !\\n\");\n  if (pdval < lval) printf(\"pdval is the smallest !\\n\");\n  if (pdval < value) printf(\"pdval is the smallest !\\n\");\n\n  return(0);\n}\n\n./ ADD NAME=CBC3GDC3 0100-00223-00249-1338-00085-00085-00000-BC0THOR\n/* this example demonstrates the use of the decimal data type */\n/* always include decimal.h when decimal data type is used */\n\n#include <decimal.h>\n\n/* Declares a decimal(10,2) variable */\ndecimal(10,2) pd01;\n\n/* Declares a decimal(15,4) variable and initializes it with the */\n/* value 1234.56d                                                */\ndecimal(15,4) pd02 = 1234.56d;\n\n/* Structure that has decimal related members */\nstruct pdec\n  {                             /* members' data types        */\n  int m;                        /* - integer                  */\n  decimal(23,10) pd03;          /* - decimal(23,10)           */\n  decimal(10,2) pd04[3];        /* - array of decimal(10,2)   */\n  decimal(10,2) *pd05;          /* - pointer to decimal(10,2) */\n  } pd06,\n   *pd07 = &pd06;              /* pd07 points to pd06        */\n\n/* Array of decimal(31,30) */\ndecimal(31,30) pd08[2];\n\n/* Prototype for function that accepts decimal(10,2) and int as */\n/* arguments and has return type decimal(25,5)                  */\ndecimal(25,5) product(decimal(10,2), int);\n\ndecimal(5,2) PdCnt;             /* decimal loop counter */\nint i;\n\nint main(void)\n{\n  pd01 = -789.45d;              /* simple assignment */\n  pd06.m = digitsof(pd06.pd03) + precisionof(pd02);  /* 23 + 4 */\n  pd06.pd03 = sizeof(pd01);\n  pd06.pd04[0] = pd02 + pd01;   /* decimal addition */\n  *(pd06.pd04 + 1) = (decimal(10,2)) product(pd07->pd04[0], pd07->m);\n  pd07->pd04[2] = product(pd07->pd04[0], pd07->pd04[1]);\n  pd07->pd05 = &pd01;           /* taking the address of a */\n                                /*   decimal variable      */\n  /* These two statements are different */\n  pd08[0] = 1 / 3d;\n  pd08[1] = 1d / 3d;\n\n  printf(\"pd01 = %D(10,2)\\n\", pd01);\n  printf(\"pd02 = %*.*D(*,*)\\n\",\n          20, 5, digitsof(pd02), precisionof(pd02), pd02);\n  printf(\"pd06.m = %d, pd07->m = %d\\n\", pd06.m, pd07->m);\n  printf(\"pd06.pd03 = %D(23,10), pd07->pd03 = %D(23,10)\\n\",\n          pd06.pd03, pd07->pd03);\n\n  /* You will get an infinite loop if floating type is  */\n  /* used instead of the decimal data types.            */\n  for (PdCnt = 0.0d; PdCnt != 3.6d; PdCnt += 1.2d)\n  {\n    i = PdCnt / 1.2d;\n    printf(\"pd06.pd04[%d] = %D(10,2), \\\n            pd07->pd04[%d] = %D(10,2)\\n\",\n            i, pd06.pd04[i], i, pd07->pd04[i]);\n  }\n\n  printf(\"*(pd06.pd05) = %D(10,2), *(pd07->pd05) = %D(10,2)\\n\",\n          *(pd06.pd05), *(pd07->pd05));\n\n  printf(\"pd08[0] = %D(31,30)\\n\", pd08[0]);\n  printf(\"pd08[1] = %D(31,30)\\n\", pd08[1]);\n\n  return(0);\n}\n\n/* Function definition for product() */\ndecimal(25,5) product(decimal(10,2) v1, int v2)\n{\n\n  /* The following happens in the return statement */\n  /* - v2 is converted to decimal(10,0)                          */\n  /* - after the multiplication, the expression has resulting    */\n  /*   type decimal(20,2) (i.e. (10,2) * (10,0) ==> (20,2))      */\n  /* - the result is then converted implicitly to decimal(25,5)  */\n  /*   before it is returned                                     */\n  return( v1 * v2 );\n\n}\n./ ADD NAME=CBC3GDC4 0100-00223-00355-1206-00023-00023-00000-BC0THOR\n/* this example demonstrates the use of the decimal data type */\n\n#include <decimal.h>\n\ndecimal(31,4) pd01 = 1234.5678d;\ndecimal(29,4) pd02 = 1234.5678d;\n\nint main(void)\n{\n  /* The results are different in the next two statements */\n  pd01 = pd01 + 1d;\n  pd02 = pd02 + 1d;\n\n  printf(\"pd01 = %D(31,4)\\n\", pd01);\n  printf(\"pd02 = %D(29,4)\\n\", pd02);\n\n  /* Warning: The decimal variable with size 31 should not be      */\n  /*          used in arithmetic operation.                        */\n  /*          In the above example: (31,4) + (1,0) ==> (31,3)      */\n  /*                                (29,4) + (1,0) ==> (30,4)      */\n\n  return(0);\n}\n./ ADD NAME=CBC3GDI1 0102-00223-00277-1834-00037-00037-00000-BC0THOR\n/* this example demonstrates how to print the __amrc structure */\n\n#include <stdio.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(void) {\n   FILE *fp;\n   __amrc_type save_amrc;\n   char buffer[80];\n   int i = 0;\n\n   /* open an MVS binary file */\n\n   fp = fopen(\"'test.cbc3gdi1'\",\"wb, recfm=F, lrecl=80\");\n   if (fp == NULL) exit(99);\n\n   memset(buffer, 'A', 80);\n\n   /* write to MVS file until it runs out of extents */\n\n   while (fwrite(buffer, 1, 80, fp) == 80)\n      ++i;\n\n   save_amrc = *__amrc;  /* need copy of __amrc structure */\n\n   printf(\"number of successful fwrites of 80 bytes = %d\\n\", i);\n\n   printf(\"last fwrite errno=%d lastop=%d syscode=%X rc=%d\\n\",\n           errno,\n           save_amrc.__last_op,\n           save_amrc.__code.__abend.__syscode,\n           save_amrc.__code.__abend.__rc);\n\n   return 0;\n}\n./ ADD NAME=CBC3GDI2 0102-00223-00277-1831-00063-00063-00000-BC0THOR\n/* this example demonstrates how to use SIGIOERR */\n\n#include <stdio.h>\n#include <signal.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef __cplusplus\n    extern \"C\" {\n#endif\n\nvoid iohdlr(int);\n\n#ifdef __cplusplus\n    }\n#endif\n\nint main(void) {\n   FILE *fp;\n   char buffer[80];\n   int i = 0;\n\n   signal(SIGIOERR, iohdlr);\n\n   /* open an MVS binary file */\n\n   fp = fopen(\"'test.cbc3gdi1'\",\"wb, recfm=F, lrecl=80\");\n   if (fp == NULL) exit(99);\n\n   memset(buffer, 'A', 80);\n\n   /* write to MVS file until it runs out of extents */\n\n   while (fwrite(buffer, 1, 80, fp) == 80)\n      ++i;\n\n   printf(\"number of successful fwrites of 80 bytes = %d\\n\", i);\n\n   return 0;\n}\nvoid iohdlr (int signum) {\n   __amrc_type save_amrc;\n   __amrc2_type save_amrc2;\n   char filename[FILENAME_MAX];\n   fldata_t info;\n\n   save_amrc = *__amrc;    /* need copy of __amrc structure  */\n   save_amrc2 = *__amrc2;  /* need copy of __amrc2 structure */\n\n   /* get name of file causing error from fldata */\n\n   if (fldata(save_amrc2.__fileptr, filename, &info) == 0)\n      printf(\"error on file %s\\n\",filename);\n\n   perror(\"io handler\");  /* give errno message */\n   printf(\"lastop=%d syscode=%X rc=%d\\n\",\n           save_amrc.__last_op,\n           save_amrc.__code.__abend.__syscode,\n           save_amrc.__code.__abend.__rc);\n\n   signal(SIGIOERR, iohdlr);\n}\n./ ADD NAME=CBC3GDLI 0100-00223-00249-1447-00019-00019-00000-BC0THOR\n/* this example shows how to determine whether the SAA C or POSIX */\n/* locale is in effect */\n\n#include <stdio.h>\n#include <ctype.h>\n\nint main(void)\n{\n    if (ispunct(0x4A)) {\n        printf(\" cent sign is punct\\n\");\n        printf(\" current locale is SAA- or S370-like\\n\");\n    }\n    else {\n        printf(\" cent sign is not punct\\n\");\n        printf(\" default locale is POSIX-like\\n\");\n    }\n\nreturn(0);\n}\n./ ADD NAME=CBC3GDW1 0100-00223-00249-1454-00025-00025-00000-BC0THOR\n/* this example shows how DWS may be used with C */\n\nint main(void)\n{\n  /* Set up the parameters that will be used by CSRIDAC.  */\n\n  char op_type[5]      = \"BEGIN\";\n  char object_type[9]  = \"TEMPSPACE\";\n  char object_name[45] = \"DWS.FILE \";\n  char scroll_area[3]  = \"YES\";\n  char object_state[3] = \"NEW\";\n  char access_mode[6]  = \"UPDATE\";\n  long int object_size = 8;\n  char object_id[8];\n  long int high_offset, return_code, reason_code;\n\n  /* Access a DWS TEMPSPACE data object.                  */\n\n  csridac(op_type, object_type, object_name, scroll_area, object_state,\n          access_mode,&object_size,&object_id,&high_offset,&return_code,\n          &reason_code);\n/* INSERT ADDITIONAL CODE HERE */\n\n  return(0);\n}\n./ ADD NAME=CBC3GEV1 0100-00223-00249-1456-00031-00031-00000-BC0THOR\n/* this example shows how environment variables are propagated */\n/* part 1 of 2-other file is CBC3GEV2 */\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(void) {\n\n   char *x;\n\n   /*   set the environment variable _EDC_ANSI_OPEN_DEFAULT   */\n   setenv(\"_EDC_ANSI_OPEN_DEFAULT\",\"Y\",1);\n\n   /*   set x to the current value of _EDC_ANSI_OPEN_DEFAULT   */\n   x = getenv(\"_EDC_ANSI_OPEN_DEFAULT\");\n\n   printf(\"cbc3gev1 _EDC_ANSI_OPEN_DEFAULT = %s\\n\",\n      (x != NULL) ? x : \"undefined\");\n\n   /*   call the child program   */\n   system(\"cbc3gev2\");\n\n   /*   set x to the current value of _EDC_ANSI_OPEN_DEFAULT   */\n   x = getenv(\"_EDC_ANSI_OPEN_DEFAULT\");\n\n   printf(\"cbc3gev1 _EDC_ANSI_OPEN_DEFAULT = %s\\n\",\n      (x != NULL) ? x : \"undefined\");\n\n   return(0);\n}\n\n./ ADD NAME=CBC3GEV2 0100-00223-00249-1455-00026-00026-00000-BC0THOR\n/* this example shows how environment variables are propagated */\n/* part 2 of 2-other file is CBC3GEV1 */\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(void) {\n\n   char *x;\n\n   /*   set x to the current value of _EDC_ANSI_OPEN_DEFAULT   */\n   x = getenv(\"_EDC_ANSI_OPEN_DEFAULT\");\n\n   printf(\"cbc3gev2 _EDC_ANSI_OPEN_DEFAULT = %s\\n\",\n      (x != NULL) ? x : \"undefined\");\n\n   /*   clear the Environment Variables Table   */\n   clearenv();\n\n   /*   set x to the current value of  _EDC_ANSI_OPEN_DEFAULT   */\n   x = getenv(\"_EDC_ANSI_OPEN_DEFAULT\");\n   printf(\"cbc3gev2 _EDC_ANSI_OPEN_DEFAULT = %s\\n\",\n      (x != NULL) ? x : \"undefined\");\n\n   return(0);\n}\n./ ADD NAME=CBC3GHC1 0100-00223-00223-1421-00432-00432-00000-BC0THOR\n/*\n * CBC3GHC1: Sample code to convert all C syntax from code page 1047\n *           to the coded character set the user specifies.\n *           Comments, string literals and character constants are\n *           left alone. The escape character in an escape sequence\n *           is changed, since it is variant.\n *\n * Usage: CBC3GHC1 <coded character set>\n *        The input file is read from stdin and the output is written\n *        to stdout.\n *\n * Example: If you want to convert all C syntax, written in coded\n *          character set 1047, in a file (test1047 c a) to coded\n *          character set 500, you can use CBC3GHC1 by issuing\n *          the following command.\n *\n *          cbc3ghc1 <test1047.c.a >test1047.gen.a IBM-500\n *\n *          The result will store in \"test500 gen a\" file.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <iconv.h>\n#include <errno.h>\n\nenum boolean   { false=0, False=0, FALSE=0, true=1, True=1, TRUE=1 };\n\n/*\n * CharState - state that the FSM is in. Initial State is CodeState\n */\nenum CharState { CodeState, SQuoteState, DQuoteState, CommentState,\n                 DBCSState, EscState, EOFState };\n\n/*\n * CharVal - characters that can change the state of the FSM\n */\nenum CharVal   { SlashChar='/',        SQuoteChar='\\'', DQuoteChar='\"',\n                 StarChar='*',    SOChar='\\x0E',       SIChar='\\x0F',\n                 BSlashChar='\\\\', EOFChar= -1 };\n\n/*\n * XlateTable - type of translation table\n */\ntypedef iconv_t  XlateTable;\n\nstatic char *Initialize(int argc, char *argv[]);\nstatic int Convert(char *codeset);\nstatic int InitConv(char **inBuff, char **outBuff, int *maxRecSize,\n                    char *codeSet, XlateTable *xlateTable);\nstatic void ConvBuff(int start, int end,\n                     char *buff, XlateTable xlateTable);\nstatic enum CharVal LookAhead(char *inBuff, char *outBuff,\n                              int *recSize, int *curPos,\n                              int maxRecSize, int *codeStartPos,\n                              enum CharState state,\n                              XlateTable xlateTable);\nstatic enum CharVal GetNextChar(char *inBuff, char *outBuff,\n                                int *recSize, int maxRecSize,\n                                int *curPos, int *codeStartPos,\n                                enum CharState state,\n                                XlateTable xlateTable);\nstatic int UpdateAndRead(char *inBuff, char *outBuff,\n                         int *recSize, int maxRecSize,\n                         int codeStartPos, enum CharState state,\n                         XlateTable xlateTable);\nstatic int ReadAndCopy(char *inBuff,char *outBuff, int maxRecSize);\n\n#pragma inline(LAST_POS)\n#pragma inline(NEXT_TO_LAST_POS)\n#pragma inline(LookAhead)\n#pragma inline(GetNextChar)\n#pragma inline(ConvBuff)\n\n/*\n * Initialize the environment, and if everything is ok, convert input\n */\nmain(int argc, char *argv[]) {\n  char *codeset = Initialize(argc, argv);\n  if (codeset == NULL) {\n    return(8);\n  }\n  return(Convert(codeset));\n}\n\n/*\n * Check that 1 parameter was specified - the coded character set to convert the\n * the syntax to.\n * Re-open stdin and stdout as binary files for record IO.\n * Return the code set if everything is ok, NULL otherwise\n */\nstatic char *Initialize(int argc, char *argv[]) {\n  if (argc != 2) {\n    fprintf(stderr, \"Expected %d argument but got %d\\n\",\n            1, argc-1);\n    return(NULL);\n  }\n  stdin = freopen(\"\", \"rb,type=record\", stdin);\n  stdout= freopen(\"\", \"wb,type=record\", stdout);\n  if (stdin == NULL || stdout == NULL) {\n    fprintf(stderr, \"Could not re-open standard streams\\n\");\n    return(NULL);\n  }\n\n  return(argv[1]);\n}\n\n/*\n * Return the last position in a record\n */\nstatic int LAST_POS(int recSize) {\n  return(recSize-1);\n}\n\n/*\n * Return the next to last position in a record\n */\nstatic int NEXT_TO_LAST_POS(int recSize) {\n  return(recSize-2);\n}\n\n/*\n * Convert the stdin file using codeset and write to stdout.\n * Set up the translation table.\n * Read the first record and copy it into the output buffer.\n * Go through the FSM, starting in the Code State and leaving\n * when EOFState is reached (End Of File).\n * Close the translation table.\n */\nstatic int Convert(char *codeset) {\n  enum CharVal   c;\n  int            recSize;\n  enum CharState prvState;\n  int            rc;\n\n  int            codeStartPos = 0;\n  int            curPos  = 0;\n  enum boolean   high    = FALSE;\n  enum CharState state   = CodeState;\n\n  char *         inBuff;\n  char *         outBuff;\n  int            maxRecSize;\n  XlateTable     xlateTable;\n\n  rc = InitConv(&inBuff, &outBuff, &maxRecSize, codeset, &xlateTable);\n  if (rc) {\n    if (inBuff)  free(inBuff);\n    if (outBuff) free(outBuff);\n    return(rc);\n  }\n\n  recSize = ReadAndCopy(inBuff, outBuff, maxRecSize);\n\n  while (state != EOFState) {\n    c = GetNextChar(inBuff, outBuff, &recSize, maxRecSize,\n                    &curPos, &codeStartPos, state, xlateTable);\n    if (c == EOFChar) {\n      state = EOFState;\n    }\n\n    switch(state) {\n      case CodeState:\n        switch (c) {\n          case BSlashChar:\n            curPos = LAST_POS(recSize);\n            break;\n          case SlashChar:\n            if (LookAhead(inBuff, outBuff, &recSize,\n                          &curPos, maxRecSize, &codeStartPos,\n                          state, xlateTable)\n                          == StarChar) {\n              state = CommentState;\n            }\n            break;\n          case SQuoteChar:\n            state = SQuoteState;\n            break;\n          case DQuoteChar:\n            state = DQuoteState;\n            break;\n        }\n        if (state != CodeState || curPos == NEXT_TO_LAST_POS(recSize)) {\n          if (curPos == NEXT_TO_LAST_POS(recSize)) {\n            ++curPos;\n          }\n          else {\n            ConvBuff(codeStartPos, curPos, outBuff, xlateTable);\n          }\n        }\n        break;\n\n      case CommentState:\n        switch(c) {\n          case BSlashChar:\n            curPos = LAST_POS(recSize);\n            break;\n          case StarChar:\n            if (LookAhead(inBuff, outBuff, &recSize,\n                          &curPos, maxRecSize, &codeStartPos,\n                          state, xlateTable)\n                          == SlashChar) {\n              state = CodeState;\n              codeStartPos = curPos;\n            }\n            break;\n        }\n        break;\n\n      case DQuoteState:\n        switch(c) {\n          case DQuoteChar:\n            state = CodeState;\n            codeStartPos = curPos;\n            break;\n          case SOChar:\n            prvState = state;\n            state    = DBCSState;\n            break;\n          case BSlashChar:\n            ConvBuff(curPos, curPos, outBuff, xlateTable);\n            if (curPos != LAST_POS(recSize)) {\n              prvState = state;\n              state = EscState;\n            }\n            break;\n        }\n        break;\n\n      case SQuoteState:\n        switch(c) {\n          case SQuoteChar:\n            state = CodeState;\n            codeStartPos = curPos;\n            break;\n          case SOChar:\n            prvState = state;\n            state    = DBCSState;\n            break;\n          case BSlashChar:\n            ConvBuff(curPos, curPos, outBuff, xlateTable);\n            if (curPos != LAST_POS(recSize)) {\n              prvState = state;\n              state = EscState;\n            }\n            break;\n        }\n        break;\n\n      case DBCSState:\n        high \u00ac= 1;  /* TRUE -> FALSE or FALSE -> TRUE */\n        if (high && (c == SIChar)) {\n          state = prvState;\n          high  = FALSE;\n        }\n        break;\n\n      case EscState:\n        state = prvState; /* really, this is ok */\n        break;\n\n      case EOFState:\n        break;\n\n      default:\n        fprintf(stderr, \"Internal error - ended up in state %d\\n\",\n                state);\n        return(16);\n\n    } /* end of switch statement */\n    ++curPos;\n  }\n  rc = TermConv(inBuff, outBuff, xlateTable);\n  return(0);\n}\n\n/*\n * Initialize the translation table and allocate the input and\n * output buffers to use.\n * Return 0 if successful.\n */\nstatic int InitConv(char **inBuff, char **outBuff, int *maxRecSize,\n                    char *codeset, XlateTable* xlateTable) {\n\n  static char fileNameBuff[FILENAME_MAX+1];\n  fldata_t info;\n  int rc;\n\n  *outBuff = *inBuff = NULL;\n\n  rc = fldata(stdin, fileNameBuff, &info);\n  if (rc) {\n    return(rc);\n  }\n\n  *maxRecSize = info.__maxreclen;\n  *inBuff     = malloc(*maxRecSize);\n  *outBuff    = malloc(*maxRecSize);\n\n if ((*xlateTable = iconv_open(\"IBM-1047\",codeset)) == (iconv_t)(-1)) {\n    fprintf(stderr,\"Cannot open convertor from %s to IBM-1047\",codeset);\n     return (8);\n  }\n\n  return(!inBuff || !outBuff);\n}\n\n/*\n * Convert the buffer from start to end using the translation table\n */\nstatic void ConvBuff(int start, int end,\n                     char *buff, XlateTable xlateTable) {\n   int rc;\n   size_t inleft, outleft, org;\n   char *inptr, *outptr;\n\n   outleft = inleft = end-start+1;\n   inptr = outptr = &buff[start];\n\n   while (1) {\n     rc = iconv(xlateTable,&inptr,&inleft,&outptr,&outleft);\n\n     if (rc == -1) {\n       switch (errno) {\n                       /* Skip the invalid character */\n        case EILSEQ:  if (--inleft == 0) return;\n                       ++inptr;\n                       ++outptr;\n                       --outleft;\n                       break;\n\n       default: fprintf(stderr,\"iconv() fails with errno = %d\\n\",errno);\n                 exit(8);\n         }\n     } else\n       return;\n   }\n}\n\n/*\n * Look ahead to the next character. If the current position\n * is the last character of the input record, write the current\n * output record and read in the next record.\n * Return the 'character' read, which may be EOF if the end of\n * the file was reached.\n */\nstatic enum CharVal LookAhead(char *inBuff, char *outBuff,\n                              int *recSize, int *curPos,\n                              int maxRecSize, int *codeStartPos,\n                              enum CharState state,\n                              XlateTable xlateTable) {\n\n  if (*curPos == LAST_POS(*recSize)) {\n    if (UpdateAndRead(inBuff, outBuff, recSize, maxRecSize,\n                      *codeStartPos, state, xlateTable)) {\n      return(EOFChar);\n    }\n    *curPos = 0;\n    *codeStartPos = 0;\n  }\n  else {\n    (*curPos)++;\n  }\n  return(inBuff[*curPos]);\n}\n\n/*\n * Similar to LookAhead(), but return the current character\n */\nstatic enum CharVal GetNextChar(char *inBuff, char *outBuff,\n                                int *recSize, int maxRecSize,\n                                int *curPos, int *codeStartPos,\n                                enum CharState state,\n                                XlateTable xlateTable) {\n\n  if (*curPos > LAST_POS(*recSize)) {\n    if (UpdateAndRead(inBuff, outBuff, recSize, maxRecSize,\n                      *codeStartPos, state, xlateTable)) {\n      return(EOFChar);\n    }\n    *curPos = 0;\n    *codeStartPos = 0;\n  }\n  return(inBuff[*curPos]);\n}\n\n/*\n * If the current state is the code state, translate the remaining\n * part of the record.\n * Write out the record to stdout\n * Read in the next record and copy it to the output buffer.\n */\nstatic int UpdateAndRead(char *inBuff, char *outBuff,\n                         int *recSize, int maxRecSize,\n                         int codeStartPos, enum CharState state,\n                         XlateTable xlateTable) {\n\n  if (state == CodeState) {\n    ConvBuff(codeStartPos, LAST_POS(*recSize), outBuff, xlateTable);\n  }\n  fwrite(outBuff, 1, *recSize, stdout);\n  *recSize = ReadAndCopy(inBuff, outBuff, maxRecSize);\n  return((*recSize == 0) ? 1 : 0);\n}\n\n/*\n * Read in a record from stdin and copy it to the output buffer.\n * Return the number of bytes read.\n */\nstatic int ReadAndCopy(char *inBuff, char *outBuff, int maxRecSize) {\n  int recSize;\n\n  recSize = fread(inBuff, 1, maxRecSize, stdin);\n  if (feof(stdin) && recSize == 0) {\n    return(0);\n  }\n  else {\n    memcpy(outBuff, inBuff, recSize);\n    return(recSize);\n  }\n}\n\n/*\n * Free allocated storage and close the translation table.\n */\nstatic int TermConv(char *inBuff,\n                    char *outBuff, XlateTable xlateTable) {\n  iconv_close(xlateTable);\n  free(inBuff);\n  free(outBuff);\n  return(0);\n}\n./ ADD NAME=CBC3GHF1 0100-00223-00249-1636-00041-00041-00000-BC0THOR\n/* this example shows how unnamed pipes may be used */\n\n#include <unistd.h>\n#include <stdio.h>\n#include <errno.h>\n\nint main() {\nint ret_val;\nint pfd[2];\nchar buff[32];\nchar string1[]=\"String for pipe I/O\";\n\nret_val = pipe(pfd);                 /* Create pipe */\nif (ret_val != 0) {             /* Test for success */\n  printf(\"Unable to create a pipe; errno=%d\\n\",errno);\n\n  exit(1);                         /* Print error message and exit */\n}\n\nif (fork() == 0) {\n   /* child program */\n   close(pfd[0]); /* close the read end */\n   ret_val = write(pfd[1],string1,strlen(string1)); /*Write to pipe*/\n   if (ret_val != strlen(string1)) {\n      printf(\"Write did not return expected value\\n\");\n      exit(2);                       /* Print error message and exit */\n   }\n}\nelse {\n   /* parent program */\n   close(pfd[1]); /* close the write end of pipe */\n   ret_val = read(pfd[0],buff,strlen(string1)); /* Read from pipe */\n   if (ret_val != strlen(string1)) {\n      printf(\"Read did not return expected value\\n\");\n      exit(3);                       /* Print error message and exit */\n   }\n   printf(\"parent read %s from the child program\\n\",buff);\n\n}\nexit(0);\n}\n./ ADD NAME=CBC3GHF2 0101-00223-00252-0901-00122-00118-00000-BC0THOR\n/* this example shows how named pipes may be used */\n\n #define _POSIX_SOURCE\n #include <sys/stat.h>\n #include <stdlib.h>\n #include <string.h>\n #include <stdio.h>\n #include <unistd.h>\n #include <errno.h>\n #include <fcntl.h>\n #include <wait.h>\n\n/*                                                                *\n *   Sample use of mkfifo()                                       *\n *                                                                */\n\nmain()\n\n{                                    /* start of program          */\n\n int     flags, ret_value, c_status;\n pid_t   pid;\n size_t  n_elements;\n char    char_ptr[32];\n char    str[] = \"string for fifo \";\n char    fifoname[] = \"temp.fifo\";\n FILE    *rd_stream,*wr_stream;\n\n if ((mkfifo(fifoname,S_IRWXU)) != 0) {\n   printf(\"Unable to create a fifo; errno=%d\\n\",errno);\n   exit(1);                     /* Print error message and return */\n }\n\n if ((pid = fork()) < 0) {\n    perror(\"fork failed\");\n    exit(2);\n }\n\n if (pid == (pid_t)0) {        /* CHILD process                  */\n    /* issue fopen for write end of the fifo                     */\n        wr_stream = fopen(fifoname,\"w\");\n           if (wr_stream == (FILE *) NULL)  {\n              printf(\"In child process\\n\");\n              printf(\"fopen returned a NULL, expected valid stream\\n\");\n              exit(100);\n           }\n\n        /* perform a write                                        */\n        n_elements = fwrite(str,1,strlen(str),wr_stream);\n           if (n_elements != (size_t) strlen(str)) {\n             printf(\"Fwrite returned %d, expected %d\\n\",\n                (int)n_elements,strlen(str));\n             exit(101);\n            }\n      exit(0);                 /* return success to parent        */\n    }\n    else  {                    /* PARENT  process                 */\n\n        /* issue fopen for read                                   */\n        rd_stream = fopen(fifoname,\"r\");\n        if (rd_stream == (FILE *) NULL)  {\n           printf(\"In parent process\\n\");\n           printf(\"fopen returned a NULL, expected valid pointer\\n\");\n           exit(2);\n        }\n\n        /* get current flag settings of file                      */\n        if ((flags = fcntl(fileno(rd_stream),F_GETFL)) == -1) {\n           printf(\"fcntl returned -1 for %s\\n\",fifoname);\n           exit(3);\n        }\n\n        /* clear O_NONBLOCK  and reset file flags                 */\n        flags &= ~(O_NONBLOCK);\n        if ((fcntl(fileno(rd_stream),F_SETFL,flags)) == -1) {\n           printf(\"\\nfcntl returned -1 for %s\",fifoname);\n           exit(4);\n        }\n\n             /* try to read the string                              */\n        ret_value = fread(char_ptr,sizeof(char),strlen(str),rd_stream);\n        if (ret_value != strlen(str)) {\n           printf(\"\\nFread did not read %d elements as expected \",\n              strlen(str));\n           printf(\"\\nret_value is %d \",ret_value);\n           exit(6);\n        }\n\n        if (strncmp(char_ptr,str,strlen(str))) {\n           printf(\"\\ncontents of char_ptr are %s \",\n              char_ptr);\n           printf(\"\\ncontents of str are %s \",\n              str);\n           printf(\"\\nThese should be equal\");\n           exit(7);\n        }\n\n        ret_value = fclose(rd_stream);\n        if (ret_value != 0)  {\n            printf(\"\\nFclose failed for %s\",fifoname);\n            printf(\"\\nerrno is %d\",errno);\n            exit(8);\n        }\n\n        ret_value = remove(fifoname);\n        if (ret_value != 0)  {\n            printf(\"\\nremove failed for %s\",fifoname);\n            printf(\"\\nerrno is %d\",errno);\n            exit(9);\n        }\n\n      pid = wait(&c_status);\n      if ((WIFEXITED(c_status) !=0) && (WEXITSTATUS(c_status) !=0)) {\n        printf(\"\\nchild exited with code %d\",WEXITSTATUS(c_status));\n        exit(10);\n      }\n    }   /* end of else clause                                       */\n    printf(\"About to issue exit(0),  \\\nprocessing completed successfully\\n\");\n    exit(0);\n\n}\n./ ADD NAME=CBC3GHF3 0102-00223-00277-1816-00111-00111-00000-BC0THOR\n/* this example uses HFS stream I/O */\n\n#define _OPEN_SYS\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#undef _OPEN_SYS\nFILE *stream;\n\nchar string1[] = \"A line of text.\";   /* NOTE: There are actually 16 */\nchar string2[] = \"Find this line.\";   /*   characters in each line of */\nchar string3[] = \"Another stream.\";   /*   text.  The 16th is a null  */\nchar string4[16];                     /*   terminator on each string. */\nlong position, strpos;                /*   Since the null character   */\nint i, result, fd;                    /*   is not being written to    */\nint rc;                               /*   the file, 15 is used as    */\n                                      /*   the data stream length.    */\nssize_t x;\nchar buffer[16];\n\nint main(void)\n{\n\n   /* Write continuous streams to file  */\n\n   if ((stream = fopen(\"./'test.cbc3ghf3.stream'\",\"wb\"))==NULL) {\n         perror(\"Error opening file\");\n         exit(0);\n   }\n\n   for(i=0; i<12;i++) {\n      int len1 = strlen(string1);\n      rc = fwrite(string1, 1, len1, stream);\n      if (rc != len1) {\n         perror(\"fwrite failed\");\n         printf(\"i = %d\\n\", i);\n         exit(99);\n      }\n   }\n   rc = fwrite(string2,1,sizeof(string2)-1,stream);\n\n   if (rc != sizeof(string2)-1) {\n      perror(\"fwrite failed\");\n      exit(99);\n   }\n\n   for(i=0;i<12;i++) {\n      rc = fwrite(string1,1,sizeof(string1)-1,stream);\n\n      if (rc != sizeof(string1)-1) {\n         perror(\"fwrite failed\");\n         printf(\"i = %d\\n\", i);\n         exit(99);\n      }\n   }\n   fclose(stream);\n\n   /* Read data stream and search for location of string2.        */\n   /* EOF is not set until an attempt is made to read past the    */\n   /* end-of-file, thus the fread is at the end of the while loop */\n\n   stream = fopen(\"./'test.cbc3ghf3.stream'\", \"rb\");\n\n   if ((position = ftell(stream)) == -1L)\n      perror(\"Error saving file position.\");\n\n   rc = fread(string4, 1, sizeof(string2)-1, stream);\n\n   while(!feof(stream)) {\n      if (rc != sizeof(string2)-1) {\n         perror(\"fread failed\");\n         exit(99);\n      }\n\n      if (strstr(string4,string2) != NULL)   /* If string2 is found */\n         strpos = position ;                 /* then save position. */\n\n      if ((position=ftell(stream)) == -1L)\n         perror(\"Error saving file position.\");\n\n      rc = fread(string4, 1, sizeof(string2)-1, stream);\n   }\n\n   fclose(stream);\n   /* Replace line containing string2 with string3 */\n\n   fd = open(\"'test.cbc3ghf3.data'\",O_RDWR);\n\n   if (fd < 0){\n     perror(\"open failed\\n\");\n   }\n\n   x = write(fd,\"a record\",8);\n\n   if (x < 8){\n     perror(\"write failed\\n\");\n   }\n\n   rc = lseek(fd,0,SEEK_SET);\n   x = read(fd,buffer,8);\n\n   if (x < 8){\n     perror(\"read failed\\n\");\n   }\n   printf(\"data read is %.8s\\n\",buffer);\n\n   close(fd);\n}\n./ ADD NAME=CBC3GIPX 0100-00264-00264-1045-00048-00048-00000-BC0THOR\n/*********************************************************************/\n/* This is a main program to call CBC3GIP1, which reads the          */\n/* directory of the PDS whose name is sent to it and returns a       */\n/* pointer to a linked list of member names.                         */\n/*                                                                   */\n/* The pds_mem() function called here is included in the source      */\n/* for CBC3GIP1. In addition, the header file CBC3GIP2 is required   */\n/* by both programs. To prepare the executable, first compile/link   */\n/* CBC3GIP0 and CBC3GIP1 into a load library, then add a bind step   */\n/* to build the executable that has a MYLIB DD statement for the     */\n/* library containing these load modules, and in the SYSLIN file:    */\n/*   INCLUDE MYLIB(CBC3GIP0)                                         */\n/*   INCLUDE MYLIB(CBC3GIP1)                                         */\n/*   ENTRY CEESTART                                                  */\n/*   NAME CBC3GIP0(R)                                                */\n/*                                                                   */\n/* Author R thornton Sep 2000                                        */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n/*  #include \"cbc3gip2.h\"   */\n#define NAMELEN 8\nstruct node {\n             struct node *next;\n             char name[NAMELEN+1];\n            } *el_ptr;\nstruct node* pds_mem(const char *pds);\n\n/*********************************************************************/\n/* main program calls the pds_mem sub program to get a list of       */\n/* member names for the pds, then prints them via printf()           */\n/*********************************************************************/\nint main(void) {\n\n  el_ptr = pds_mem(\"bc0thor.pds.jcl\");\n  if(el_ptr == NULL) {\n    printf(\"\\nNo data returned by pds_mem\");\n    exit(1);\n  }\n\n  while(el_ptr != NULL) {\n    printf(\"\\n%s\",el_ptr->name);     /* print a member name */\n    el_ptr = el_ptr->next;           /* step to next element */\n  }\n\n}\n./ ADD NAME=CBC3GIP0 0106-00263-00277-1808-00045-00227-00000-BC0THOR\n/*********************************************************************/\n/* This is a main program to call CBC3GIP1, which reads the          */\n/* directory of the PDS whose name is sent to it and returns a       */\n/* pointer to a linked list of member names.                         */\n/*                                                                   */\n/* As written, the dataset name for the PDS whose directory is read  */\n/* is given as CBC.TRIGON.SAMPSRC. If a different PDS is to be used, */\n/* change line 36 to show the desired dataset name.                  */\n/*                                                                   */\n/* The pds_mem() function called here is included in the source      */\n/* for CBC3GIP1. In addition, the header file CBC3GIP2 is required   */\n/* by both programs. To prepare the executable, first compile/link   */\n/* CBC3GIP1 with NCAL into a load library as CBC3GIP1, then compile  */\n/* and bind CBC3GIP0 with the following bind control statements:     */\n/*   INCLUDE MYLIB(CBC3GIP1)                                         */\n/*   ENTRY CEESTART                                                  */\n/*   NAME CBC3GIP0(R)                                                */\n/*                                                                   */\n/* Author R Thornton Sep 2000                                        */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"cbc3gip2.h\"\n\n/*********************************************************************/\n/* main program calls the pds_mem sub program to get a list of       */\n/* member names for the pds, then prints them via printf()           */\n/*********************************************************************/\nint main(void) {\n  struct node *ptr;\n\n  ptr = pds_mem(\"cbc.trigon.sampsrc\");\n  if(ptr == NULL) {\n    printf(\"\\nNo data returned by pds_mem\");\n    exit(1);\n  }\n\n  while(ptr != NULL) {\n    printf(\"\\n%s\",ptr->name);        /* print a member name */\n    ptr = ptr->next;                 /* step to next element */\n  }\n  exit(0);\n}\n./ ADD NAME=CBC3GIP1 0105-00223-00264-1035-00232-00220-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how to create a list of members of a PDS under */\n/* MVS.                                                              */\n/* part 1 of 2-other file is CBC3GIP2 (a header file in cbc.scbcsam) */\n/*                                                                   */\n/* NOTE: The main() function was not included in the original code   */\n/*       and was written separately as CBC3GIP0, which calls the     */\n/*       pds_mem() function here to obtain the linked list of        */\n/*       member names. See source for CBC3GIP0 for linkedit details. */\n/*                                                                   */\n/* NODE_PTR pds_mem(const char *pds):                                */\n/* pds must be a fully qualified pds name, eg ID.PDS.DATASET returns */\n/* a pointer to a linked list of nodes.  Each node contains a member */\n/* of the pds and a pointer to the next node.  If no members exist,  */\n/* the pointer is NULL.                                              */\n/*                                                                   */\n/* Note: Behavior is undefined if pds is the name of a sequential    */\n/*       file.                                                       */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"cbc3gip2.h\"\n\n/*********************************************************************/\n/* RECORD: each record of a pds will be read into one of these       */\n/*         structures. The first two bytes is the record length,     */\n/*         which is put into 'count', the remaining 254 bytes are    */\n/*         put into rest.  Each record is 256 bytes long.            */\n/*********************************************************************/\n\n#define RECLEN  254\n\ntypedef struct {\n                unsigned short int count;\n                char rest[RECLEN];\n               } RECORD;\n\n/*********************************************************************/\n/* Local function prototypes                                         */\n/*********************************************************************/\n\nstatic int gen_node(NODE_PTR *node, RECORD *rec, NODE_PTR *last_ptr);\nstatic char *add_name(NODE_PTR *node, char *name, NODE_PTR *last_ptr);\n\nNODE_PTR pds_mem(const char *pds) {\n\n  FILE *fp;\n  int bytes;\n  NODE_PTR node, last_ptr;\n  RECORD rec;\n  int list_end;\n  char *qual_pds;\n\n  node = NULL;\n  last_ptr = NULL;\n/*********************************************************************/\n/* Allocate a new variable, qual_pds, which will be the same as pds, */\n/* except with single quotes around it, i.e. ID.PDS.DATASET ==>      */\n/* 'ID.PDS.DATA SET'                                                 */\n/*********************************************************************/\n\n  qual_pds = (char *)malloc(strlen(pds) + 3);\n  if (qual_pds == NULL) {\n    fprintf(stderr,\"malloc failed for %d bytes\\n\",strlen(pds) + 3);\n    exit(-1);\n  }\n  sprintf(qual_pds,\"'%s'\",pds);\n\n/*********************************************************************/\n/* Open the pds in binary read mode.  The PDS directory will be read */\n/* one record at a time until either the end of the directory or     */\n/* end-of-file is detected.  Call up gen_node() with every record    */\n/* read, to add member names to the linked list.                     */\n/*********************************************************************/\n\n  fp = fopen(qual_pds,\"rb\");\n  if (fp == NULL)\n    return(NULL);\n\n  do {\n    bytes = fread(&rec, 1, sizeof(rec), fp);\n    if ((bytes != sizeof(rec)) && !feof(fp)) {\n      perror(\"FREAD:\");\n      fprintf(stderr,\"Failed in %s, line %d\\n\"\n             \"Expected to read %d bytes but read %d bytes\\n\",\n              __FILE__,__LINE__,sizeof(rec), bytes);\n      exit(-1);\n    }\n\n    list_end = gen_node(&node,&rec, &last_ptr);\n\n  } while (!feof(fp) && !list_end);\n  fclose(fp);\n  free(qual_pds);\n  return(node);\n}\n/*********************************************************************/\n/* GEN_NODE() processes the record passed.  The main loop scans thru */\n/* the record until it has read at least rec->count bytes, or a      */\n/* directory end marker is detected.                                 */\n/*                                                                   */\n/* Each record has the form:                                         */\n/*                                                                   */\n/* +------------+------+------+------+------+----------------+       */\n/* + # of bytes |Member|Member|......|Member|  Unused        +       */\n/* + in record  |  1   |  2   |      |  n   |                +       */\n/* +------------+------+------+------+------+----------------+       */\n/*  |--count---||-----------------rest-----------------------|       */\n/*  (Note that the number stored in count includes its own           */\n/*   two bytes)                                                      */\n/*                                                                   */\n/* And, each member has the form:                                    */\n/*                                                                   */\n/* +--------+-------+----+-----------------------------------+       */\n/* + Member |TTR    |info|                                   +       */\n/* + Name   |       |byte|  User Data TTRN's (halfwords)     +       */\n/* + 8 bytes|3 bytes|    |                                   +       */\n/* +--------+-------+----+-----------------------------------+       */\n/*********************************************************************/\n\n#define TTRLEN 3      /* The TTR's are 3 bytes long */\n/*********************************************************************/\n/* bit 0 of the info-byte is '1' if the member is an alias,          */\n/* 0 otherwise. ALIAS_MASK is used to extract this information       */\n/*********************************************************************/\n#define ALIAS_MASK ((unsigned int) 0x80)\n/*********************************************************************/\n/* The number of user data half-words is in bits 3-7 of the info     */\n/* byte. SKIP_MASK is used to extract this information.  Since this  */\n/* number is in half-words, it needs to be double to obtain the      */\n/* number of bytes.                                                  */\n/*********************************************************************/\n#define SKIP_MASK ((unsigned int) 0x1F)\n\n/*********************************************************************/\n/* 8 hex FF's mark the end of the directory.                         */\n/*********************************************************************/\nchar *endmark = \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\";\nstatic int gen_node(NODE_PTR *node, RECORD *rec, NODE_PTR *last_ptr) {\n\n   char *ptr, *name;\n   int skip, count = 2;\n   unsigned int info_byte, alias, ttrn;\n   char ttr[TTRLEN];\n   int list_end = 0;\n\n   ptr = rec->rest;\n\n   while(count < rec->count) {\n     if (!memcmp(ptr,endmark,NAMELEN)) {\n       list_end = 1;\n       break;\n     }\n\n     /* member name */\n     name = ptr;\n     ptr += NAMELEN;\n\n     /* ttr */\n     memcpy(ttr,ptr,TTRLEN);\n     ptr += TTRLEN;\n\n     /* info_byte */\n     info_byte = (unsigned int) (*ptr);\n     alias = info_byte & ALIAS_MASK;\n     if (!alias) add_name(node,name,last_ptr);\n     skip = (info_byte & SKIP_MASK) * 2 + 1;\n     ptr += skip;\n     count += (TTRLEN + NAMELEN + skip);\n   }\n   return(list_end);\n}\n/*********************************************************************/\n/* ADD_NAME: Add a new member name to the linked node. The new member*/\n/* is added to the end so that the original ordering is maintained.  */\n/*********************************************************************/\n\nstatic char *add_name(NODE_PTR *node, char *name, NODE_PTR *last_ptr) {\n\n  NODE_PTR newnode;\n\n/*********************************************************************/\n/* malloc space for the new node                                     */\n/*********************************************************************/\n\n  newnode = (NODE_PTR)malloc(sizeof(NODE));\n  if (newnode == NULL) {\n    fprintf(stderr,\"malloc failed for %d bytes\\n\",sizeof(NODE));\n    exit(-1);\n  }\n\n/*********************************************************************/\n/* copy the name into the node and NULL terminate it                 */\n/*********************************************************************/\n\n  memcpy(newnode->name,name,NAMELEN);\n  newnode->name[NAMELEN] = '\\0';\n  newnode->next = NULL;\n\n/*********************************************************************/\n/* add the new node to the linked list                               */\n/*********************************************************************/\n\n  if (*last_ptr != NULL) {\n    (*last_ptr)->next = newnode;\n    *last_ptr = newnode;\n  }\n  else {\n    *node = newnode;\n    *last_ptr = newnode;\n  }\n  return(newnode->name);\n}\n/*********************************************************************/\n/* FREE_MEM: This function is not used by pds_mem(), but it should be*/\n/* used as soon as you are finished using the linked list.  It frees */\n/* the storage allocated by the linked list.                         */\n/*********************************************************************/\n\nvoid free_mem(NODE_PTR node) {\n\n  NODE_PTR next_node=node;\n\n  while (next_node != NULL) {\n     next_node = node->next;\n     free(node);\n     node = next_node;\n  }\n  return;\n}\n./ ADD NAME=CBC3GIP2 0100-00263-00263-1436-00019-00019-00000-BC0THOR\n/* this example shows how to create a list of members of a PDS under */\n/* MVS */\n/* part 2 of 2-other file is CBC3GIP1 */\n/*\n * NODE: a pointer to this structure is returned from the call to pds_mem().\n * It is a linked list of character arrays - each array contains a member\n * name. Each next pointer points * to the next member, except the last\n * next member which points to NULL.\n*/\n\n#define NAMELEN 8      /* Length of a MVS member name */\n\ntypedef struct node {\n                      struct node *next;\n                      char name\u00ddNAMELEN+1\u00a8;\n                    } NODE, *NODE_PTR;\n\nNODE_PTR pds_mem(const char *pds);\nvoid free_mem(NODE_PTR list);\n./ ADD NAME=CBC3GIS3 0102-00223-00257-1400-00026-00020-00000-BC0THOR\n/*********************************************************************/\n/* This program shows how to use ISPF with C. It also uses a CLIST   */\n/* called CBC3GIS1 and panels CBC3GIS2 and CBC3GIS4. Note that the   */\n/* load library containing this program must be available either in  */\n/* the LNKLST or via STEPLIB at execution time.                      */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#pragma linkage(ISPLINK,OS)\n\nextern ISPLINK() ;\n\nint rc,buflen;\nchar buffer[20];\nint ISPLINK(char[], int, char[]);\nint main(void)\n{\n/* Retrieve the panel definition CBC3GIS4 and display it. */\n\n   strcpy(buffer,\"PANEL(CBC3GIS4)\");\n   buflen = strlen(buffer);\n   rc = ISPLINK(\"SELECT\", buflen, buffer);\n}\n./ ADD NAME=CBC3GIS8 0102-00223-00257-1413-00025-00021-00000-BC0THOR\n/*********************************************************************/\n/* This program shows how to use ISPF with &cxx., using ISPLINK      */\n/*********************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#pragma linkage(ISPLINK,OS)\nextern ISPLINK() ;\n\nint rc,buflen;\nchar buffer[20];\nint ISPLINK(char[], int, char[]);\n\nint main(void)\n{\n/*********************************************************************/\n/* Retrieve the panel definition CBC3GIS4 and display it.            */\n/*********************************************************************/\n\n   strcpy(buffer,\"PANEL(CBC3GIS4)\");\n   buflen = strlen(buffer);\n   rc = ISPLINK(\"SELECT\",buflen, buffer);\n}\n./ ADD NAME=CBC3GMF1 0103-00224-00257-1740-00068-00026-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how to remove members of a PDS                 */\n/* A number of changes were made to the original to provide a more   */\n/* meaningful sample:                                                */\n/* 1) type=memory was removed from the fopen() function calls so the */\n/*    PDS created could be viewed after job completion.              */\n/* 2) Code was rearranged so that the pds is only open for output for*/\n/*    one member at a time, as errors resulted when an attempt was   */\n/*    made to have the same PDS open for output for two members at   */\n/*    the same time.                                                 */\n/* 3) Tests were added for successful file open after each fopen()   */\n/*    function, and messages were supplied for success or failure    */\n/*    of each fopen().                                               */\n/* 4) The remove() function call was modified to remove only member  */\n/*    mb1, rather than the entire dataset, as was done in the        */\n/*    original program, contrary to the program title.               */\n/*********************************************************************/\n\n#include <stdio.h>\n\nint main(void)\n{\n   FILE * fp1, * fp2;\n   fp1=fopen(\"a.b(mbr1)\",\"w\");\n   if (fp1 == NULL) {\n      perror(\"fopen():\");\n      printf(\"\\nInitial fopen for mbr1 failed.\");\n   }\n   else {\n      printf(\"\\nInitial fopen for mbr1 successful.\");\n   }\n   fwrite(\"hello, world\\n\", 1, 13, fp1);\n   fclose(fp1);\n\n   fp2=fopen(\"a.b(mbr2)\",\"w\");\n   if (fp2 == NULL) {\n      perror(\"fopen():\");\n      printf(\"\\nInitial fopen for mbr2 failed.\");\n   }\n   else {\n      printf(\"\\nInitial fopen for mbr2 successful.\");\n   }\n   fwrite(\"hello, world\\n\", 1, 13, fp2);\n   fclose(fp2);\n\n   remove(\"a.b(mbr1)\");\n\n   fp1=fopen(\"a.b(mbr1)\",\"r\");\n   if (fp1 == NULL) {\n      perror(\"fopen():\");\n      printf(\"\\nSecond fopen for mbr1 failed as expected: \"\n             \"the file has been removed\\n\");\n   }\n   else {\n      printf(\"\\nSecond fopen for mbr1 should have failed.\");\n   }\n\n   fp2=fopen(\"a.b(mbr2)\",\"r\");\n   if (fp2 == NULL) {\n      perror(\"fopen():\");\n      printf(\"\\nSecond fopen for mbr2 failed - should have worked.\");\n   }\n   else {\n      printf(\"\\nSecond fopen for mbr2 was successful.\");\n   }\n\n   return(0);\n}\n./ ADD NAME=CBC3GMF2 0104-00224-00258-1018-00079-00038-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how to rename a PDS. it is modified from the   */\n/* modified from the original in several ways to provide a better    */\n/* example:                                                          */\n/* 1) type=memory is removed from the fopen() function calls.        */\n/* 2) fopen() and fclose() calls are done to insure the file is only */\n/*    opened for output for one member at a time.                    */\n/* 3) Tests were added following each open to determine whether or   */\n/*    not fopen() was successful, and messages are written either way*/\n/* 4) Any former versions of the BC0THOR.A.B and BC0THOR.C.D         */\n/*    datasets are deleted to eliminate conflicts.                   */\n/*********************************************************************/\n\n#include <stdio.h>\n\nint main(void)\n{\n   FILE * fp1, * fp2;\n\n   remove(\"a.b\");           /* pre-delete the PDS BC0THOR.A.B */\n   remove(\"c.d\");           /* pre-delete the PDS BC0THOR.C.D */\n\n   fp1=fopen(\"a.b(mbr1)\",\"w\"); /* Create PDS BC0THOR.A.B and null */\n                               /* member named MBR1 */\n   if (fp1 == NULL) {\n      perror(\"Open1:\");\n      printf(\"\\nOpen1 failed.\");\n   }\n   else {\n      printf(\"\\nOpen1 succeeded as expected.\");\n   }\n   fwrite(\"hello, world1\\n\", 1, 14, fp1); /* write to member MBR1 */\n   fclose(fp1);       /* Close it so we can create another member. */\n\n   fp2=fopen(\"a.b(mbr2)\",\"w\"); /* Open the PDS to create null */\n                               /* member named MBR2 */\n   if (fp2 == NULL) {\n      perror(\"Open2:\");\n      printf(\"\\nOpen2 failed.\");\n   }\n   else {\n      printf(\"\\nOpen2 succeeded as expected.\");\n   }\n   fwrite(\"hello, world2\\n\", 1, 14, fp2);  /* write to member MBR2 */\n   fclose(fp2);             /* Close the PDS so we can rename it. */\n\n/*********************************************************************/\n/* Rename the PDS from BC0THOR.A.B to BC0THOR.C.D.                   */\n/*********************************************************************/\n   rename(\"a.b\",\"c.d\");       /* Rename the PDS to BC0THOR.C.D */\n\n/*********************************************************************/\n/* After renaming, you must access the dataset by its new name.      */\n/*********************************************************************/\n\n   fp1=fopen(\"a.b(mbr1)\",\"r\"); /* Try to open BC0THOR.A.B which was */\n                               /* renamed to BC0THOR.C.D */\n   if (fp1 == NULL) {\n      perror(\"Open3:\");\n      printf(\"\\nOpen3 failed as expected, as the PDS was renamed.\");\n   }\n   else {\n      printf(\"\\nOpen3 succeeded, but should have failed, as the PDS \"\n             \"has been renamed.\");\n   }\n\n   fp2=fopen(\"c.d(mbr1)\",\"r\");  /* Now try to open the PDS with its */\n                               /* new name BC0THOR.C.D */\n   if (fp2 == NULL) {\n      perror(\"\\nOpen4:\");\n      printf(\"\\nOpen4 failed, but should have worked.\");\n   }\n   else {\n      printf(\"\\nOpen4 was successful, as expected after the PDS \"\n             \"was renamed.\");\n   }\n\n   return(0);\n}\n./ ADD NAME=CBC3GMI2 0105-00224-00264-1315-00438-00431-00000-BC0THOR\n/*********************************************************************/\n/* debuggable malloc()/calloc()/realloc()/free() example             */\n/* part 2 of 2-other file is CBC3GMI1.h                              */\n/*                                                                   */\n/* This is a set of functions which can be called from another       */\n/* program.                                                          */\n/*                                                                   */\n/* STORAGE:                                                          */\n/*                                                                   */\n/* EXTERNALS:                                                        */\n/*                                                                   */\n/*  This file contains code for the following functions:             */\n/*   -malloc......allocate storage from a Language Environment heap  */\n/*   -calloc......allocate storage from a Language Environement heap */\n/*                and initialize it to 0.                            */\n/*   -free........free storage previously allocated by malloc in this*/\n/*                file.                                              */\n/*   -realloc.....re-allocate storage previously allocated by malloc */\n/*             in this file. If a NULL pointer is passed instead of a*/\n/*                previously allocated pointer, malloc will be called*/\n/*                directly.                                          */\n/*                                                                   */\n/* USAGE:                                                            */\n/*                                                                   */\n/*  To use this code, compile with no special options (although the  */\n/*  TEST option is useful so that the trace back will give           */\n/*  additional information - line number information and the type and*/\n/*  values of variables will be dumped in a trace back for all       */\n/*  files compiled with TEST).                                       */\n/*  Prelink (or link) this text deck with your text decks (make sure */\n/*  you explicitly link this text deck - avoid using autocall since  */\n/*  you might get the C/370 version of malloc/free/realloc).         */\n/*                                                                   */\n/* INTERNALS:                                                        */\n/*                                                                   */\n/*  General Algorithm:                                               */\n/*                                                                   */\n/*  When storage is allocated, extra 'padding' is allocated at the   */\n/*  start and end of the actual storage allocated for the user.      */\n/*  This padding is then initialized to a special pad value. If the  */\n/*  user's code is functioning correctly, the padding should not     */\n/*  have been changed when it comes time to free the storage. If the */\n/*  free() routine finds that the padding does not have the correct  */\n/*  value, the storage about to be freed is dumped and a trace back  */\n/*  is issued, and then the storage is dumped, as usual.             */\n/*  The padding size and padding byte value can be modified to suit  */\n/*  your needs. Update the include file \"cbc3gmi1.h\" if you want     */\n/*  to modify these values.                                          */\n/*  Here is a diagram of how storage is allocated (assume that the   */\n/*  pad value is xFE, the padding size is 4 bytes and 8 bytes of     */\n/*  storage were requested):                                         */\n/*                                                                   */\n/*  Length of      Padding        Allocated storage          Padding */\n/*   storage          |            returned to user             |    */\n/*      |             |                     |                   |    */\n/* +----+------+ +----+------+ +------------+------------+ +----+----*/\n/* |           | |           | |                         | |         */\n/*+------------------------------------------------------------------*/\n/*| 00 00 00 10 | FE FE FE FE | xx xx xx xx | xx xx xx xx | FE FE FE */\n/*+------------------------------------------------------------------*/\n/*                                                                   */\n/*  (Values above shown in hexadecimal)                              */\n/*                                                                   */\n/*  This method is fairly effective in tracking down storage         */\n/*  allocation problems. Also, code does not have                    */\n/*  to be recompiled to use these routines - it just has to be       */\n/*  relinked. Note that it is not guaranteed to find all storage     */\n/*  allocation errors - if you overwrite the padding with the        */\n/*  same value it had before, or you overwrite more storage than     */\n/*  you had padding for, you will still have problems.               */\n/*                                                                   */\n/*  This code uses the LE/370 heap services to allocate, re-allocate */\n/*  and free storage. A User Heap is used instead of the library     */\n/*  heap so that if the heap gets corrupted, the standard library    */\n/*  services that themselves use the heap won't be affected (i.e.    */\n/*  if the user heap is damaged, a call to a library function        */\n/*  such as printf should still succeed).                            */\n/*                                                                   */\n/*  Notes of interest:                                               */\n/*   - The runtime option STORAGE is very useful for tracking down   */\n/*     random pointer problems - it initializes heap and/or stack    */\n/*     frame storage to a particular value.                          */\n/*   - The runtime option RPTSTG(ON) is useful for improving heap and*/\n/*     stack frame allocation - it generates a report indicating how */\n/*     stack and heap storage was managed for a given program.       */\n/*********************************************************************/\n#include \"cbc3gmi1.h\"\n#include <leawi.h>\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <ctest.h>\n\n/*********************************************************************/\n/* heapVerbose: external variable that controls whether heap         */\n/*              allocation and free messages are displayed.          */\n/*********************************************************************/\nint heapVerbose=1;\n\n/*********************************************************************/\n/* mallocHeapID: static variable that is the Heap ID used for allocat*/\n/*               storage via malloc(). On the first call to malloc(),*/\n/*               a Heap will be created and this Heap ID will be set.*/\n/*               All subsequent calls to malloc will use this Heap ID*/\n/*********************************************************************/\nstatic _INT4 mallocHeapID=0;\n\n/*********************************************************************/\n/* CHARS_PER_LINE/BYTES_PER_LINE: Used by dump() and DumpLine()      */\n/*         to control the width of a storage dump                    */\n/*********************************************************************/\n#define CHARS_PER_LINE           40\n#define BYTES_PER_LINE           16\n\n/*********************************************************************/\n/* align: Given a value and the alignment desired (in bits), round   */\n/*        the value to the next largest alignment, unless it is      */\n/*        already aligned, in which case, just return the value passe*/\n/*********************************************************************/\n#pragma inline(align)\nstatic int align(int value, int shift) {\n  int alignment = (0x1 << shift);\n\n  if (value % alignment) {\n    return(((value >> shift) << shift) + alignment);\n  }\n  else {\n    return(value);\n  }\n}\n\n/*********************************************************************/\n/* padding: given a buffer (address and length), return 1 if the     */\n/*          entire buffer consists of the pad character specified,   */\n/*          otherwise return 0.                                      */\n/*********************************************************************/\n#pragma inline(padding)\nstatic int padding(const char* buffer, long size, int pad) {\n  int i;\n  for (i=0;i<size;++i) {\n    if (buffer[i] != pad) return(0);\n  }\n  return(1);\n}\n\n/*********************************************************************/\n/* CEECmp: Given two feedback codes, return 0 if they have the same  */\n/*         message number and facility id, otherwise return 1.       */\n/*********************************************************************/\n#pragma inline(CEECmp)\nstatic int CEECmp(_FEEDBACK* fc1, _FEEDBACK* fc2) {\n\n  if (fc1->tok_msgno == fc2->tok_msgno &&\n      !memcmp(fc1->tok_facid, fc2->tok_facid,\n              sizeof(fc1->tok_facid))) {\n    return(0);\n  }\n  else {\n    return(1);\n  }\n}\n\n/*********************************************************************/\n/* CEEOk: Given a feedback code, return 1 if it compares the same to */\n/*        condition code CEE000.                                     */\n/*********************************************************************/\n#pragma inline(CEEOk)\nstatic int CEEOk(_FEEDBACK* fc) {\n  _FEEDBACK CEE000 = { 0, 0, 0, 0, 0, {0,0,0}, 0 };\n\n  return(CEECmp(fc, &CEE000) == 0);\n}\n\n/*********************************************************************/\n/* CEEErr: Given a title string and a feedback code, print the       */\n/*         title to stderr, then print the message associated        */\n/*         with the feedback code. If the feedback code message can't*/\n/*         be printed out, print out the message number and severity.*/\n/*********************************************************************/\nstatic void CEEErr(const char* title, _FEEDBACK* fc) {\n  _FEEDBACK msgFC;\n  _INT4 dest = 2;\n\n  fprintf(stderr, \"\\n%s\\n\", title);\n  CEEMSG(fc, &dest, &msgFC);\n  if (!CEEOk(&msgFC)) {\n    fprintf(stderr, \"Message number:%d with severity %d occurred\\n\",\n            fc->tok_msgno, fc->tok_sev);\n  }\n}\n\n/*********************************************************************/\n/* DumpLine: Dump out a buffer (address and length) to stderr.       */\n/*********************************************************************/\nstatic void DumpLine(char* address, int length) {\n  int i, c, charCount=0;\n\n  if (length % 4) length += 4;\n\n  fprintf(stderr, \"%8.8p: \", address);\n  for (i=0; i < length/4; ++i) {\n    fprintf(stderr, \"%8.8X \", ((int*)address)[i]);\n    charCount += 9;\n  }\n  for (i=charCount; i < CHARS_PER_LINE; ++i) {\n    putc(' ', stderr);\n  }\n  fprintf(stderr, \"| \");\n  for (i=0; i < length; ++i) {\n    c = address[i];\n    c = (isprint(c) ? c : '.');\n    fprintf(stderr, \"%c\", c);\n  }\n  fprintf(stderr, \"\\n\");\n}\n\n/*********************************************************************/\n/* dump: dump out a buffer (address and length) to stderr by dumping */\n/*    it a line at a time (DumpLine), until the buffer is written out*/\n/*********************************************************************/\nstatic void dump(void* generalAddress, int length) {\n  int curr = 0;\n  char* address = (char*) generalAddress;\n\n  while (&address[curr] < &address[length-BYTES_PER_LINE]) {\n    DumpLine(&address[curr], BYTES_PER_LINE);\n    curr += BYTES_PER_LINE;\n  }\n  if (curr < length) {\n    DumpLine(&address[curr], length-curr);\n  }\n}\n\n/*********************************************************************/\n/* malloc: Create a heap if necessary by calling CEECRHP. This only  */\n/*         needs to be done on the first call to malloc(). Verify    */\n/*         that the heap creation was ok. If it wasn't, issue an     */\n/*         error message and return a NULL pointer.                  */\n/*         Write a message to stderr indicating how many bytes       */\n/*         are about to be allocated.                                */\n/*         Call CEEGTST to allocate the storage requested plus       */\n/*         additional padding to be placed at the start and end      */\n/*         of the allocated storage. Verify that the storage allocati*/\n/*         was successful. If it wasn't, issue an error message and  */\n/*         return a NULL pointer.                                    */\n/*         Write a message to stderr indicating the address of the   */\n/*         allocated storage.                                        */\n/*         Initialize the padding to the value of PADDING_BYTE, so th*/\n/*         free() will be able to test that the padding was not chang*/\n/*         Return the address of the allocated storage (starting afte*/\n/*         the padding bytes).                                       */\n/*********************************************************************/\nvoid* malloc(long initSize) {\n  _FEEDBACK fc;\n  _POINTER address=0;\n  long totSize;\n  long* lenPtr;\n  char* msg;\n  char* start;\n  char* end;\n\n  if (!mallocHeapID) {\n    _INT4 heapSize = HEAP_INIT_SIZE;\n    _INT4 heapInc  = HEAP_INCR_SIZE;\n    _INT4 opts     = HEAP_OPTS;\n\n    CEECRHP(&mallocHeapID, &heapSize, &heapInc, &opts, &fc);\n    if (!CEEOk(&fc)) {\n      CEEErr(\"Heap creation failed\", &fc);\n      return(0);\n    }\n  }\n  if (heapVerbose) {\n    fprintf(stderr, \"Allocate %d bytes\", initSize);\n  }\n/*********************************************************************/\n/* Add the padding size to the total size, then round up to the      */\n/* nearest double word                                               */\n/*********************************************************************/\n  totSize  = initSize + (PADDING_SIZE*2) + sizeof(long);\n  totSize  = align(totSize, 3);\n\n  CEEGTST(&mallocHeapID, &totSize, &address, &fc);\n  if (!CEEOk(&fc)) {\n    msg = \"Storage request failed\";\n    CEEErr(msg, &fc);\n    __ctrace(msg);\n\n    return(0);\n  }\n\n  lenPtr = (long*) address;\n  *lenPtr= initSize;\n  start  = ((char*) address) + sizeof(long);\n  end    = start + initSize + PADDING_SIZE;\n\n  memset(start, PADDING_BYTE, PADDING_SIZE);\n  memset(end,   PADDING_BYTE, PADDING_SIZE);\n\n  if (heapVerbose) {\n    fprintf(stderr, \" starting at address %p\\n\", address);\n  }\n\n  return(start + PADDING_SIZE);\n}\n\n/*********************************************************************/\n/* calloc: Call malloc() to allocate the requested amount of storage.*/\n/*         If the allocation was successful, initialize the allocated*/\n/*         storage to 0.                                             */\n/*         Return the address of the allocated storage (or a NULL    */\n/*         pointer if malloc returned a NULL pointer).               */\n/*********************************************************************/\nvoid* calloc(long initSize) {\n  void* ptr;\n\n  ptr = malloc(initSize);\n  if (ptr) {\n    memset(ptr, 0, initSize);\n  }\n  return(ptr);\n}\n/*********************************************************************/\n/* realloc: If a NULL pointer is passed, call malloc() directly.     */\n/*          Call CEECZST to re-allocate the storage requested plus   */\n/*          additional padding to be placed at the start and end     */\n/*          of the allocated storage.                                */\n/*          Verify that the storage re-allocation was ok. If it      */\n/*          wasn't, issue an error message, dump the storage, and    */\n/*          return a NULL pointer.                                   */\n/*          Write a message to stderr indicating the address of the  */\n/*          re-allocated storage.                                    */\n/*          Initialize the padding to the value of PADDING_BYTE, so  */\n/*          that free() will be able to test that the padding was not*/\n/*          changed. Note that the padding at the start of the storag*/\n/*          does not need to be allocated, since it was already      */\n/*          initialized by an earlier call to malloc().              */\n/*          Return the address of the re-allocated storage (starting */\n/*          after the padding bytes).                                */\n/*********************************************************************/\nvoid* realloc(char* ptr, long initSize) {\n  _FEEDBACK fc;\n  _POINTER address = (ptr - sizeof(long) - PADDING_SIZE);\n  long oldSize;\n  long* lenPtr;\n  char* start;\n  char* end;\n  char* msg;\n  long newSize = initSize;\n\n  if (ptr == 0) {\n    return(malloc(newSize));\n  }\n\n  oldSize = *((long*) address);\n\n  if (heapVerbose) {\n    fprintf(stderr, \"Re-allocate %d bytes from address %p to \",\n            newSize, address);\n  }\n\n/*********************************************************************/\n/* Add the padding size to the total size, then round up to the      */\n/* nearest double word                                               */\n/*********************************************************************/\n  newSize += (PADDING_SIZE*2) + sizeof(long);\n  newSize  = align(newSize, 3);\n  CEECZST(&address, &newSize, &fc);\n  if (!CEEOk(&fc)) {\n    msg = \"Storage re-allocation failed\";\n\n    CEEErr(msg, &fc);\n    dump(address, oldSize + (PADDING_SIZE*2) + sizeof(long));\n    __ctrace(msg);\n    return(0);\n  }\n\n  lenPtr = (long*) address;\n  *lenPtr= initSize;\n  start  = ((char*) address) + sizeof(long);\n  end    = start + initSize + PADDING_SIZE;\n\n  memset(end, PADDING_BYTE, PADDING_SIZE);\n\n  if (heapVerbose) {\n    fprintf(stderr, \"address %p\\n\", address);\n  }\n\n  return(start + PADDING_SIZE);\n}\n/*********************************************************************/\n/* free: Calculate where the start and end of the originally         */\n/*       allocated storage was. The start will be different than the */\n/*       address passed in because the address passed in points after*/\n/*       the padding bytes added by malloc() or realloc().           */\n/*       Write a message to stderr indicating what address is about  */\n/*       to be freed.                                                */\n/*       Verify that the start and end padding bytes have the origina*/\n/*       padding value. If they don't, dump out the originally       */\n/*       allocated storage and issue a trace.                        */\n/*       Free the storage by calling CEEFRST. If the storage free    */\n/*       fails, dump out the storage and issue a trace.              */\n/*********************************************************************/\nvoid free(char* ptr) {\n  _FEEDBACK fc;\n  _POINTER address=(void*) (ptr - sizeof(long) - PADDING_SIZE);\n  char* start;\n  char* end;\n  long size;\n  long* lenPtr;\n  char* msg;\n\n  lenPtr = (long*) address;\n  size   = *lenPtr;\n  start  = ((char*) address) + sizeof(long);\n  end    = start + size + PADDING_SIZE;\n\n  if (heapVerbose) {\n    fprintf(stderr, \"Free address %p\\n\", address);\n  }\n  if (!padding(start, PADDING_SIZE, PADDING_BYTE) ||\n      !padding(end, PADDING_SIZE, PADDING_BYTE)) {\n\n    dump(address, size + (PADDING_SIZE*2) + sizeof(long));\n    msg = \"Padding overwritten\";\n    __ctrace(msg);\n  }\n  else {\n    CEEFRST(&address, &fc);\n    if (!CEEOk(&fc)) {\n      msg = \"Storage free failed\";\n\n      CEEErr(msg, &fc);\n      dump(address, size + (PADDING_SIZE*2) + sizeof(long));\n      __ctrace(msg);\n    }\n  }\n}\n./ ADD NAME=CBC3GMT1 0103-00224-00258-1651-00047-00035-00000-BC0THOR\n/*********************************************************************/\n/* MTF example 1 (MULTI-TASKING FACILITY)                            */\n/* prior to execution, create files a.input, b.input, c.input, and   */\n/* d.input that contain some numbers with decimal points separated   */\n/* by spaces. There should be the same quantity of numbers in files  */\n/* a.input and b.input and also in the c.input and d.input pair. The */\n/* output contains the sum of the products of the number pairs from  */\n/* each pair of files. for example, if a.input contains 4.5, 3.2,    */\n/* 1.5, and 7.4 while file b.input contains 1.1, 1.3, 7.2, and 9.0   */\n/* the first line of output will contain the number 86.51 which is   */\n/* the sum of (4.5 X 1.1) + (3.2 X 1.3) + (1.5 X 7.2) + (7.4 X 9.0)  */\n/* The second line of output shows a similarly derived number from   */\n/* the numbers in files c.input and d.input.                         */\n/*********************************************************************/\n\n#include <stdio.h>\n\nvoid fdotprod(char *fn1, char *fn2)\n{\n    int i, res1;\n    double result=0, val1, val2;\n    FILE *file1, *file2;\n\n    file1 = fopen(fn1, \"r\");\n    file2 = fopen(fn2, \"r\");\n\n    while (1)\n    {\n        res1  = fscanf(file1, \"%lf\", &val1);\n        res1 += fscanf(file2, \"%lf\", &val2);\n        if (res1 != 2)\n            break;\n        result += val1 * val2;\n    }\n    if (res1 == 1)\n        printf(\"Error: Files of unequal length\\n\");\n    else\n        printf(\"Result: %lf\\n\", result);\n}\n\nint main(void)\n{\n    fdotprod(\"a.input\", \"b.input\");\n    fdotprod(\"c.input\", \"d.input\");\n\n    return(0);\n}\n./ ADD NAME=CBC3GMT2 0102-00224-00258-1653-00021-00015-00000-BC0THOR\n/*********************************************************************/\n/* MTF example 2 (MULTI-TASKING FACILITY)                            */\n/* part 1 of 2-other file is CBC3GMT3                                */\n/* I was unable to get any output from this program, though it       */\n/* compiled and executed with no errors.                             */\n/* I assume that it somehow accesses the subroutine \"fdotprod\", which*/\n/* is included in CBC3GMT3 (or should).                              */\n/*********************************************************************/\n\n#include <mtf.h>\n\nint main(void)\n{\n    tinit(\"plmod\", 2);\n    tsched(MTF_ANY, \"fdotprod\", \"a.input\", \"b.input\");\n    tsched(MTF_ANY, \"fdotprod\", \"c.input\", \"d.input\");\n    tsyncro(MTF_ALL);\n    tterm();\n\n    return(0);\n}\n./ ADD NAME=CBC3GMT3 0102-00224-00258-1411-00029-00027-00000-BC0THOR\n/*********************************************************************/\n/* MTF example 2  (multi-tasking facility)                           */\n/* Part 2 of 2-other file is cbc3gmt2.                               */\n/*********************************************************************/\n#include <stdio.h>\n\nvoid fdotprod(char *fn1, char *fn2)\n{\n    int i, res1;\n    double result=0, val1, val2;\n    FILE *file1, *file2;\n\n\n    file1 = fopen(fn1, \"r\");\n    file2 = fopen(fn2, \"r\");\n\n    while(1)\n    {\n        res1  = fscanf(file1, \"%lf\", &val1);\n        res1 += fscanf(file2, \"%lf\", &val2);\n        if (res1 != 2)\n            break;\n        result += val1 * val2;\n    }\n    if (res1 == 1)\n        printf(\"Error: Files of unequal length\\n\");\n    else\n        printf(\"Result: %lf\\n\", result);\n}\n./ ADD NAME=CBC3GMV1 0102-00224-00277-1655-00086-00070-00000-BC0THOR\n/*********************************************************************/\n/* This example will display hexadecimal values for the variant      */\n/* characters.                                                       */\n/* The user must create a file called userid.MYFILE.DAT that contains*/\n/* a string of variant characters. These must be the same characters */\n/* and in the same order as the names in the char_names table. As    */\n/* coded below, that would be backslash, right bracket, left bracket,*/\n/* right brace, left brace, circumflex, tilde, exclamation point,    */\n/* number sign, and vertical line.                                   */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <locale.h>\n#include <variant.h>\n#include <stdlib.h>\n\nvoid read_user_data(char *, int);\n\nvoid main() {\n  char  *user_char, *compiler_char;\n\n  struct variant *compiler_var_char;\n  int num_var_char, index;\n  char *code_set;\n  char *char_names[]={\"backslash\",\n                      \"right bracket\",\n                      \"left bracket\",\n                      \"right brace\",\n                      \"left_brace\",\n                      \"circumflex\",\n                      \"tilde\",\n                      \"exclamation mark\",\n                      \"number sign\",\n                      \"vertical line\"};\n\n  num_var_char=sizeof(char_names)/sizeof(char *);\n  if ((user_char=(char*)calloc(num_var_char, 1)) == NULL)\n  {\n    printf(\"Error: Unable to allocate the storage\\n\");\n    exit(99);\n  }\n\n  read_user_data(user_char, num_var_char);\n/*********************************************************************/\n/* Managed to read the users' characters from the file.              */\n/*********************************************************************/\n\n  code_set=\"default IBM-1047\";\n  compiler_char=\"\\xe0\\xbd\\xad\\xd0\\xc0\\x5f\\xa1\\x5a\\x7b\\x4f\";\n/*********************************************************************/\n/* Standard compiler code page.                                      */\n/*********************************************************************/\n\n  printf(\"Compiler and library code page is : %s\\n\\n\", code_set);\n  printf(\"                           Variant character values:\\n\");\n  printf(\" %16s     expected by compiler    your current\\n\", \"\");\n  for (index=0; index<num_var_char; index++)\n    printf(\" %16s  :       %X                      %X\\n\",\n             char_names[index], compiler_char[index], user_char[index\u00a8);\n  exit(0);\n}\n\n/*********************************************************************/\n/* read_user_data() reads a set of variant characters from a file    */\n/* provided by the user.                                             */\n/*********************************************************************/\nvoid read_user_data(char* char_array, int num_var_char)\n{\n  FILE  *stream;\n  int num;\n\n  if (stream = fopen (\"'test.myfile.dat'\", \"rb\"))\n    if(!(num = fread(char_array, 1, num_var_char, stream)))\n    {\n      printf(\"Error: Unable to read from the file\\n\");\n      exit(99);\n    }\n    else { ;}\n  else\n  {\n    printf(\"Error: Unable to open the file\\n\");\n    exit(99);\n  }\n  fclose(stream);\n  return;\n}\n./ ADD NAME=CBC3GOF1 0101-00224-00259-1046-00022-00020-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how fopen() may be used with memory files.     */\n/*********************************************************************/\n\n#include <stdio.h>\nchar text[3], *result;\nFILE * fp;\n\nint main(void)\n   {\n   fp = fopen(\"a.b\", \"w, type=memory\");  /* Opens a memory file */\n   fprintf(fp, \"%d\\n\",10);               /* Writes to the file  */\n   fclose(fp);                           /* Closes the file     */\n   fp = fopen(\"a.b\", \"r\");               /* Reopens the same    */\n                                         /*  file (already      */\n                                         /*  a memory file)     */\n   if ((result=fgets(text,3,fp)) !=NULL) /* Retrieves results   */\n      printf(\"value retrieved is %s\\n\",result);\n   fclose(fp);                           /* Closes the file     */\n\n   return(0);\n   }\n./ ADD NAME=CBC3GOP1 0102-00224-00259-1401-00032-00026-00000-BC0THOR\n/*********************************************************************/\n/* This is used to show optimization with CBC3GOP2.                  */\n/* compile errors occur on line 9:                                   */\n/*   CBC3277 Syntax error: possible missing ';' or ','?              */\n/*   CBC3485 Parameter declaration list is incompatible with declar- */\n/*           ator for inline.                                        */\n/*********************************************************************/\n\n#include <stdio.h>\ninline int which_group (int a) {\n   if (a < 0) {\n      printf(\"first group\\n\");\n      return(99);\n   }\n   else if (a == 0) {\n      printf(\"second group\\n\");\n      return(88);\n   }\n   else {\n      printf(\"third group\\n\");\n      return(77);\n   }\n}\n\nint main (void) {\n\n   int j;\n\n   j = which_group (7);\n\n   return(0);\n}\n./ ADD NAME=CBC3GOP2 0102-00224-00259-1358-00015-00013-00000-BC0THOR\n/*********************************************************************/\n/* This example demonstrates optimization with CBC3GOP1.             */\n/*********************************************************************/\n\n#include <stdio.h>\n\nint main(void) {\n\n   int j;\n\n   printf(\"third group\\n\");   /* a lot less code generation */\n   j = 77;\n\n   return(0);\n}\n./ ADD NAME=CBC3GOP3 0101-00224-00259-1404-00020-00018-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how numeric conversions are done.              */\n/*********************************************************************/\n\nint main(void)\n{\n   int i;\n   float array[10];\n   float x = 1.0;\n   for (i = 0; i < 10; i++)\n      {\n       array[i] = array[i]*x;  /* No conversions needed */\n       x = x + 1.0;\n      }\n\n   for (i = 1; i <= 9; i++)\n      array[i] = array[i]*i;  /* Multiple conversions needed */\n\n   return(0);\n}\n./ ADD NAME=CBC3GOS1 0101-00224-00259-1434-00062-00055-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=HDQTRSF2,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//*******************************************************************\n//*               BC0THOR.PDS.C(CBC3GOS1)                           *\n//*******************************************************************\n//********************************************************************/\n//* CBC3GOS1 Example                                                 */\n//* This example demonstrates GDG I/O                                */\n//*                                                                  */\n//* Create GDG model MYGDG.MODEL and GDG name MYGDG                  */\n//********************************************************************/\n//MODEL     EXEC PGM=IDCAMS\n//DD1       DD DSN=BC0THOR.MYGDG.MODEL,DISP=(NEW,CATLG),\n//             UNIT=SYSDA,SPACE=(TRK,(0)),\n//             DCB=(LRECL=80,BLKSIZE=3120,RECFM=FB)\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD *\n DEFINE GDG -\n        (NAME(BC0THOR.MYGDG) -\n        EMPTY              -\n        SCRATCH            -\n        LIMIT(255))\n/*\n//*---------------------------------------------------------------------\n//* Create GDG data set MYGDG(+1)\n//*---------------------------------------------------------------------\n//DATASET   EXEC PGM=IEFBR14\n//DD1       DD DSN=BC0THOR.MYGDG(+1),DISP=(NEW,CATLG),\n//             SPACE=(CYL,(1,1)),UNIT=SYSDA,\n//             DCB=BC0THOR.MYGDG.MODEL\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DUMMY\n//*---------------------------------------------------------------------\n//* Compile, link, and run an inlined C program.\n//* This program attempts to open the GDG data set MYGDG(+1) but\n//* should fail as it is opening the data set with a RECFM that is\n//* different from that of the GDG model (F versus FB).\n//*---------------------------------------------------------------------\n//C        EXEC EDCCLG,\n//         CPARM='NOSEQ,NOMARGINS'\n//COMPILE.SYSIN DD DATA,DLM='/>'\n#include <stdio.h>\n#include <errno.h>\n\nint main(void)\n{\n    FILE *fp;\n\n    fp = fopen(\"MYGDG(+1)\", \"a,recfm=F\");\n\n    if (fp == NULL)\n    {\n        printf(\"Error...Unable to open file\\n\");\n        printf(\"errno ... %d\\n\",errno);\n        perror(\"perror ... \");\n    }\n\n    printf(\"Finished\\n\");\n}\n/>\n./ ADD NAME=CBC3GOS3 0101-00224-00259-1451-00047-00043-00000-BC0THOR\n/*********************************************************************/\n/* This example demonstrates how updated records are read.           */\n/*********************************************************************/\n\n#include <stdio.h>\n\nint main(void)\n{\n   FILE * fp, * fp2;\n   int rc, rc2, rc3, rc4;\n\n   fp = fopen(\"a.b\",\"w+\");\n\n   fprintf(fp,\"first record\");\n\n   fp2 = fopen(\"a.b\",\"r\");  /* Simultaneous Reader */\n\n/*********************************************************************/\n/* Following gets EOF since fp has not completed first line          */\n/* of output so nothing will be flushed to file yet.                 */\n/*********************************************************************/\n\n   rc = fgetc(fp2);\n   printf(\"return code is %i\\n\", rc);\n\n   fputc('\\n', fp);  /* this will complete first line */\n   fflush(fp);       /* ensures data is flushed to file */\n\n   rc2 = fgetc(fp2);  /* this gets 'f' from first record */\n   printf(\"value is now %c\\n\", rc2);\n\n   rewind(fp);\n\n   fprintf(fp, \"some updates\\n\");\n\n   rc3 = fgetc(fp2);  /* gets 'i' ..doesn't know about update */\n   printf(\"value is now %c\\n\", rc3);\n\n   fflush(fp);  /* ensure update makes it to file */\n\n   fflush(fp2); /* this updates reader's buffer */\n\n   rc4 = fgetc(fp2);  /* gets 'm', 3rd char of updated record */\n   printf(\"value is now %c\\n\", rc4);\n\n   return(0);\n}\n./ ADD NAME=CBC3GRE1 0100-00224-00259-1503-00011-00011-00000-BC0THOR\n/* this example demonstrates how to make strings constant */\n\n#pragma strings(readonly)\n#include <stdio.h>\n\nint main(void)\n{\n   printf(\"hello world\\n\");\n\n   return(0);\n}\n./ ADD NAME=CBC3GRE3 0104-00224-00265-1752-00023-00024-00000-BC0THOR\n*********************************************************************\n* CBC3GRE3 is an assembler subroutine statically called by C program*\n* CBC3GRE4. See CBC3GRE4 comments for details.                      *\n*                                                                   *\n* parameters:  none                                                 *\n* return:      none                                                 *\n* action:      store contents of register 13 ( callers dynamic      *\n*              storage area) in variable DSA which exists in        *\n*              the writable static area                             *\n*                                                                   *\n* Macros:    EDCPRLG, EDCEPIL, EDCDXD, EDCLA in CEE.SCEEMAC         *\n*********************************************************************\nXOBJHDR  EDCDPLNK            ; generate an XOBJ header\nGETDSA   CSECT\nGETDSA   AMODE ANY\nGETDSA   RMODE ANY\n         EDCPRLG             ;  prolog (save registers etc.)\n         EDCLA 1,DSA         ;  load register 1 with address of DSA\n         ST 13,0(,1)         ;  store contents of reg 13 in DSA\n         EDCEPIL             ;  epilog (restore registers etc.)\nDSA      EDCDXD 0F           ;  declaration of DSA in writable static\nTBLDSA   EDCDXD 20F          ;  definition of TBLDSA in writable static\n         END\n./ ADD NAME=CBC3GRE4 0103-00224-00265-1800-00047-00037-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how to reference objects in the writable       */\n/* static area, from assembler code.                                 */\n/* The assembler program CBC3GRE3 must be assembled and linked prior */\n/* to the compile and link for this program so that it can be linked */\n/* statically via linkedit autocall from the SYSLIB concatenation.   */\n/*********************************************************************/\n\n#include <stdio.h>\n#define SZ 20\n\n#ifdef __cplusplus\n    extern \"OS\" {\n#endif\nvoid GETDSA(void);               /* assembler routine modifies DSA */\n#ifdef __cplusplus\n    }\n#endif\n\nconst int sz = 20;               /* maximum call depth */\nextern void * TBLDSA[SZ];         /* defined in assembler program */\nvoid * DSA;                      /* define it here, source name */\n                                 /* same as assembler name */\n\n/*********************************************************************/\n/* Call yourself deeper and deeper.                                  */\n/* Save DSA pointers as you go.                                      */\n/*********************************************************************/\nvoid deeper( int i)\n{\n  if (i >= sz)     /* if deep enough just return */\n    return;\n  GETDSA();        /* assign value to DSA */\n  TBLDSA[i] = DSA;  /* save value in table */\n  deeper(i+1);     /* go deeper in call chain */\n}\n\n/*********************************************************************/\n/* Define the main() function.                                       */\n/*********************************************************************/\nint main(void) {\n  int i;\n  deeper(0);\n  for(i=0;i<sz; i++)\n    printf(\"depth %3d, DSA was at %p\\n\", i, TBLDSA[i]);\n  return 0;\n}\n./ ADD NAME=CBC3GTH1 0101-00266-00266-1201-00046-00045-00000-BC0THOR\n/* The following example uses thread-specific */\n/* data to insure that storage acquired by a specific thread is */\n/* freed when the thread ends. */\n\n #define _OPEN_THREADS\n #include <stdio.h>\n #include <stdlib.h>\n #include <pthread.h>\n pthread_key_t mykey;               /* A place to get the key */\n void mydestruct(void *value);      /* My destructor routine  */\n main()\n  {\n   char * thddataptr;\n  /*  Create a key, getting back the key from pthread_key_create(),\n      and associate a function to be executed at thread termination\n      for this key\n  */\n\n    (void)pthread_key_create(&mykey,&mydestruct);\n\n  /*\n    Obtain some storage which this thread will manage (remember,\n    the main is also a thread), which we want freed by our\n    destructor upon thread termination.  Associate the storage\n    pointer with the key using pthread_setspecific.\n */\n  thddataptr = (char *) malloc(100);\n  (void)pthread_setspecific(mykey,thddataptr);\n\n /* the body of the function\n\n /* now, the thread exits, causing the thread termination\n    key data destructor to be executed.\n */\n   pthread_exit((void *)0);\n }\n /*\n    The key data destructor function\n*/\n void mydestruct(void * value) {\n   /* value is the value in the key/value binding that is unique\n      to the thread being terminated.  Thus, in the example,\n      it represents the pointer to the storage needing freed.\n   */\n    free(value);\n }\n./ ADD NAME=CBC3GVS1 0101-00264-00265-1356-00037-00035-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how to access the __amrc->__RBA field.         */\n/* It assumes that an ESDS has already been defined, and has been    */\n/* assigned the ddname ESDSCLUS.                                     */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n\nmain() {\n   FILE *ESDSfile;\n   unsigned long myRBA;\n   char recbuff[100]=\"This is record one.\";\n   int w_retcd;\n   int l_retcd;\n   int r_retcd;\n\n   printf(\"calling fopen(\\\"dd:esdsclus\\\",\\\"rb+,type=record\\\");\\n\");\n   ESDSfile = fopen(\"dd:esdsclus\", \"rb+,type=record\");\n   printf(\"fopen() returned 0X%.8x\\n\",ESDSfile);\n   if (ESDSfile==NULL) exit;\n\n   w_retcd = fwrite(recbuff, 1, sizeof(recbuff), ESDSfile);\n   printf(\"fwrite() returned %d\\n\",w_retcd);\n   if (w_retcd != sizeof(recbuff)) exit;\n   myRBA = __amrc->__RBA;\n\n   l_retcd = flocate(ESDSfile, &myRBA, sizeof(myRBA), __RBA_EQ);\n   printf(\"flocate() returned %d\\n\",l_retcd);\n   if (l_retcd !=0) exit;\n\n   r_retcd = fread(recbuff, 1, sizeof(recbuff), ESDSfile);\n   printf(\"fread() returned %d\\n\",r_retcd);\n   if (l_retcd !=0) exit;\n\n   return(0);\n}\n./ ADD NAME=CBC3GVS2 0103-00264-00265-1411-00314-00263-00000-BC0THOR\n/*********************************************************************/\n/* This example demonstrates the use of a KSDS file.                 */\n/* Part 1 of 2-other file is CBC3GVS3 (the JCL to execute the sample)*/\n/*********************************************************************/\n\n#include <stdio.h>\n#include <string.h>\n\n/*********************************************************************/\n/* global definitions                                                */\n/*********************************************************************/\n\nstatic void print_amrc(void);\nstruct data_struct {\n              char   emp_number[4];\n              char   user_id[8];\n              char   name[20];\n              char   pers_info[37];\n};\n\n#define  REC_SIZE                69\n#define  CLUS_KEY_SIZE            4\n#define  AIX_UNIQUE_KEY_SIZE      8\n#define  AIX_NONUNIQUE_KEY_SIZE  20\n\nstatic void print_amrc() {\n    __amrc_type currErr = *__amrc; /* copy contents of __amrc     */\n                                   /* structure so that values    */\n                                   /* don't get jumbled by printf */\n    printf(\"R15 value   = %d\\n\", currErr.__code.__feedback.__rc);\n    printf(\"Reason code = %d\\n\", currErr.__code.__feedback.__fdbk);\n    printf(\"RBA         = %d\\n\", currErr.__RBA);\n    printf(\"Last op     = %d\\n\", currErr.__last_op);\n    return;\n}\n/*********************************************************************/\n/* update_emp_rec() function definition.                             */\n/*********************************************************************/\n\nint update_emp_rec (struct data_struct *data_ptr,\n                    struct data_struct *orig_data_ptr,\n                    FILE   *fp)\n{\n    int          rc;\n    char         buffer[REC_SIZE+1];\n\n/*********************************************************************/\n/*  Check to see if update will change primary key (emp_number).     */\n/*********************************************************************/\n    if (memcmp(data_ptr->emp_number,orig_data_ptr->emp_number,4) != 0) {\n/*********************************************************************/\n/* Check to see if changed primary key exists.                       */\n/*********************************************************************/\n       rc = flocate(fp,&(data_ptr->emp_number),CLUS_KEY_SIZE,__KEY_EQ);\n       if (rc == 0) {\n          print_amrc();\n          printf(\"Error: new employee number already exists\\n\");\n          return 10;\n       }\n\n       clearerr(fp);\n\n/*********************************************************************/\n/* Write out new record.                                             */\n/*********************************************************************/\n       rc = fwrite(data_ptr,1,REC_SIZE,fp);\n       if ((rc == REC_SIZE) || (ferror(fp))) {\n          print_amrc();\n          printf(\"Error: write with new employee number failed\\n\");\n          return 20;\n       }\n\n/*********************************************************************/\n/* Locate to old employee record so it can be deleted.               */\n/*********************************************************************/\n       rc = flocate(fp,&(orig_data_ptr->emp_number),CLUS_KEY_SIZE,\n                    __KEY_EQ);\n       if (rc != 0) {\n          print_amrc();\n          printf(\"Error: flocate to original employee number failed\\n\");\n          return 30;\n       }\n\n       rc = fread(buffer,1,REC_SIZE,fp);\n       if (rc != REC_SIZE || ferror(fp)) {\n          print_amrc();\n          printf(\"Error: reading old employee record failed\\n\");\n          return 40;\n       }\n\n       rc = fdelrec(fp);\n       if (rc != 0) {\n          print_amrc();\n          printf(\"Error: deleting old employee record failed\\n\");\n          return 50;\n       }\n\n   } /* end of checking for change in primary key                */\n    else { /* Locate to current employee record                  */\n       rc = flocate(fp,&(data_ptr->emp_number),CLUS_KEY_SIZE,__KEY_EQ);\n       if (rc == 0) {\n/*********************************************************************/\n/* Record exists, so update it.                                      */\n/*********************************************************************/\n          rc = fread(buffer,1,REC_SIZE,fp);\n          if (rc != REC_SIZE || ferror(fp)) {\n             print_amrc();\n             printf(\"Error: reading old employee record failed\\n\");\n             return 60;\n          }\n\n          rc = fupdate(data_ptr,REC_SIZE,fp);\n          if (rc == 0) {\n             print_amrc();\n             printf(\"Error: updating new employee record failed\\n\");\n             return 70;\n          }\n       }\n       else { /* record doesn't exist so write out new record  */\n          clearerr(fp);\n          printf(\"Warning: record previously displayed no longer\\n\");\n          printf(\"       : exists, new record being created\\n\");\n          rc = fwrite(data_ptr,1,REC_SIZE,fp);\n          if (rc != REC_SIZE || ferror(fp)) {\n             print_amrc();\n             printf(\"Error: write with new employee number failed\\n\");\n             return 80;\n          }\n       }\n    }\n    return 0;\n}\n\n/* display_emp_rec() function definition                              */\n\nint display_emp_rec (struct data_struct *data_ptr,\n                     struct data_struct *orig_data_ptr,\n                     FILE *clus_fp, FILE *aix_unique_fp,\n                     FILE *aix_non_unique_fp)\n{\n    int     rc = 0;\n    char    buffer[REC_SIZE+1];\n\n/*********************************************************************/\n/* Primary Key Search.                                               */\n/*********************************************************************/\n    if (memcmp(data_ptr->emp_number, \"\\0\\0\\0\\0\", 4) != 0) {\n       rc = flocate(clus_fp,&(data_ptr->emp_number),CLUS_KEY_SIZE,\n                    __KEY_EQ);\n       if (rc != 0) {\n          printf(\"Error: flocate with primary key failed\\n\");\n          return 10;\n       }\n\n/*********************************************************************/\n/* Read record for display.                                          */\n/*********************************************************************/\n       rc = fread(orig_data_ptr,1,REC_SIZE,clus_fp);\n       if (rc != REC_SIZE || ferror(clus_fp)) {\n          printf(\"Error: reading employee record failed\\n\");\n          return 15;\n       }\n    }\n/*********************************************************************/\n/* Unique Alternate Index Search.                                    */\n/*********************************************************************/\n    else if (data_ptr->user_id[0] != '\\0') {\n       rc = flocate(aix_unique_fp,data_ptr->user_id,AIX_UNIQUE_KEY_SIZE,\n                   __KEY_EQ);\n       if (rc != 0) {\n          printf(\"Error: flocate with user id failed\\n\");\n          return 20;\n       }\n\n/*********************************************************************/\n/* Read record for display.                                          */\n/*********************************************************************/\n       rc = fread(orig_data_ptr,1,REC_SIZE,aix_unique_fp);\n       if (rc != REC_SIZE || ferror(aix_unique_fp)) {\n          printf(\"Error: reading employee record failed\\n\");\n          return 25;\n       }\n    }\n/*********************************************************************/\n/* Non-unique Alternate Index Search.                                */\n/*********************************************************************/\n    else if (data_ptr->name[0] != '\\0') {\n       rc = flocate(aix_non_unique_fp,data_ptr->name,\n                    AIX_NONUNIQUE_KEY_SIZE,__KEY_GE);\n       if (rc != 0) {\n          printf(\"Error: flocate with name failed\\n\");\n          return 30;\n       }\n\n/*********************************************************************/\n/* Read record for display.                                          */\n/*********************************************************************/\n       rc = fread(orig_data_ptr,1,REC_SIZE,aix_non_unique_fp);\n       if (rc != REC_SIZE || ferror(aix_non_unique_fp)) {\n          printf(\"Error: reading employee record failed\\n\");\n          return 35;\n       }\n    }\n    else {\n       printf(\"Error: invalid search argument; valid search arguments\\n\"\n              \"     : are either employee number, user id, or name\\n\");\n       return 40;\n    }\n/*********************************************************************/\n/* Display record data.                                              */\n/*********************************************************************/\n    printf(\"Employee Number: %.4s\\n\", orig_data_ptr->emp_number);\n    printf(\"Employee Userid: %.8s\\n\", orig_data_ptr->user_id);\n    printf(\"Employee Name:   %.20s\\n\", orig_data_ptr->name);\n    printf(\"Employee Info:   %.37s\\n\", orig_data_ptr->pers_info);\n    return 0;\n}\n\n/*********************************************************************/\n/* main() function definition.                                       */\n/*********************************************************************/\n\nint main() {\n    FILE*               clus_fp;\n    FILE*               aix_ufp;\n    FILE*               aix_nufp;\n    int                 i;\n    struct data_struct  buf1, buf2;\n\n    char data[3][REC_SIZE+1] = {\n\"   1LARRY   LARRY               HI, I'M LARRY,                      \",\n\"   2DARRYL1 DARRYL              AND THIS IS MY BROTHER DARRYL,      \",\n\"   3DARRYL2 DARRYL                                                  \"\n    };\n\n/*********************************************************************/\n/* Open file three ways.                                             */\n/*********************************************************************/\n    clus_fp = fopen(\"dd:cluster\", \"rb+,type=record\");\n    if (clus_fp == NULL) {\n       print_amrc();\n       printf(\"Error: fopen(\\\"dd:cluster\\\"...) failed\\n\");\n       return 5;\n    }\n/*********************************************************************/\n/* Assume base cluster was loaded with at least one dummy record     */\n/* so aix could be defined.                                          */\n/*********************************************************************/\n    aix_ufp = fopen(\"dd:aixuniq\", \"rb,type=record\");\n    if (aix_ufp == NULL) {\n       print_amrc();\n       printf(\"Error: fopen(\\\"dd:aixuniq\\\"...) failed\\n\");\n       return 10;\n    }\n/*********************************************************************/\n/* Assume base cluster was loaded with at least one dummy record     */\n/* so aix could be defined.                                          */\n/*********************************************************************/\n    aix_nufp = fopen(\"dd:aixnuniq\", \"rb,type=record\");\n    if (aix_nufp == NULL) {\n       print_amrc();\n       printf(\"Error: fopen(\\\"dd:aixnuniq\\\"...) failed\\n\");\n       return 15;\n    }\n\n/*********************************************************************/\n/* Load sample records.                                              */\n/*********************************************************************/\n    for (i = 0; i < 3; ++i) {\n       if (fwrite(data[i],1,REC_SIZE,clus_fp) != REC_SIZE) {\n          print_amrc();\n          printf(\"Error: fwrite(data[%d]...) failed\\n\", i);\n          return 66+i;\n       }\n    }\n\n/*********************************************************************/\n/* Display sample record by primary key.                             */\n/*********************************************************************/\n    memcpy(buf1.emp_number, \"   1\", 4);\n    if (display_emp_rec(&buf1, &buf2, clus_fp, aix_ufp, aix_nufp) != 0)\n       return 69;\n\n/*********************************************************************/\n/* Display sample record by nonunique aix key.                       */\n/*********************************************************************/\n    memset(buf1.emp_number, '\\0', 4);\n    buf1.user_id[0] = '\\0';\n    memcpy(buf1.name, \"DARRYL                    \", 20);\n    if (display_emp_rec(&buf1, &buf2, clus_fp, aix_ufp, aix_nufp) != 0)\n       return 70;\n\n/*********************************************************************/\n/* Display sample record by unique aix key.                          */\n/*********************************************************************/\n    memcpy(buf1.user_id, \"DARRYL2 \", 8);\n    if (display_emp_rec(&buf1, &buf2, clus_fp, aix_ufp, aix_nufp) != 0)\n       return 71;\n\n/*********************************************************************/\n/* Update record just read with new personal info.                   */\n/*********************************************************************/\n    memcpy(&buf1, &buf2, REC_SIZE);\n    memcpy(buf1.pers_info, \"AND THIS IS MY OTHER BROTHER DARRYL. \", 37);\n    if (update_emp_rec(&buf1, &buf2, clus_fp) != 0) return 72;\n\n/*********************************************************************/\n/* Display sample record by unique aix key.                          */\n/*********************************************************************/\n    if (display_emp_rec(&buf1, &buf2, clus_fp, aix_ufp, aix_nufp) != 0)\n       return 73;\n\n    return 0;\n}\n./ ADD NAME=CBC3GVS3 0100-00277-00277-1419-00023-00023-00000-BC0THOR\n1804BC0THOR THORNTON, RICHARD   65 M ISD SYSTEM PROGRAMMER\n1937USERQ5  BLAKE, SARA         27 F COM CONSOLE OPERATOR\n2179H010736 TOMASINA, ERROL     43 M PRT PRINTER TECHNICIAN\n2448T8693   BOBNEY, DALE        60 M ISD ANALYST PROGRAMMER\n4779BC0NCAL CALLEY, NANCY       51 F ISD SUPERVISOR\n4783CB0GFIN FINNEY, GEORGE      38 M ISD CONTRACTOR\n6327B191662 CARROLL, LEWIS      19 M BLD ELECTRICIAN\n6328H010399 HOLMES, OLIVER      55 M LEG LAWYER\n6329BC0JJON JONES, JOHN P       48 M AUX SHIP CAPTAIN\n6330BC1KLAK LAKE, KAREN         39 F HR  HUMAN RESOURCES CLERK\n6339T5555   BOHR, NIELS         41 M SCI PHYSICIST\n6472USER01  WEST, RONALD        49 M ISD MANAGER, TECHNICAL SERVICES\n6478USER03  DEHNE, FERD         44 M ISD SUPERVISOR, TECHNICAL SERV.\n7001H013774 HOLDSWORTH, MEREDITH62 F OPS TIVOLI ADMINISTRATOR\n7092T4439   RUSSELL, JANIE      29 F OPS TIVOLI INSTALLER\n7168USERC4  QUADE, JEFF         37 M ISD SUPERVISOR, TECHNICAL SERV.\n8422BC0TWIT WITHEROW, THOMAS    23 M ISD SECURITY TECHNICIAN\n8579B010662 TEELE, WAYNE        44 M ISD CONTRACTOR\n8644T9364   WATERS, FRANCIS     38 F ISD PROGRAMMER\n8739T0249   KLIMECKI, FRANCK    63 M SEC SECURITY GUARD\n8956BC0SHAR HARBINGER, STEVEN   56 M SEC ADMINISTRATOR, SECURITY\n9099BC0BSIN SINCLAIR, BETSY     39 F FIN FINANCE CLERK\n9140BC0DWAT WATLEY, DEAN        44 M ISD FACILITIES LAYOUT TECH.\n./ ADD NAME=CBC3GVS4 0101-00265-00265-1619-00115-00107-00000-BC0THOR\n/*********************************************************************/\n/* This example illustrates the use of an RRDS file.                 */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <env.h>\n\nstruct rrds_struct {\n   __rrds_key_type   rrds_key;\n   char             *rrds_buf;\n};\n\ntypedef struct rrds_struct RRDS_STRUCT;\n\nmain() {\n\n   __amrc_type save_amrc;\nFILE              *fileptr;\nRRDS_STRUCT        RRDSstruct;\nRRDS_STRUCT       *rrds_rec = &RRDSstruct;\nchar               buffer1[80] =\n                      \"THIS IS THE FIRST RECORD IN THE FILE.  I\"\n                      \"T WILL BE WRITTEN AT RRN POSITION 2.   \";\nchar               buffer2[80] =\n                      \"THIS IS THE SECOND RECORD IN THE FILE. I\"\n                      \"T WILL BE WRITTEN AT RRN POSITION 10.  \";\nchar               buffer3[80] =\n                      \"THIS IS THE THIRD RECORD IN THE FILE.  I\"\n                      \"T WILL BE WRITTEN AT RRN POSITION 32.  \";\nchar               outputbuf[80];\nunsigned long      flocate_key = 0;\n\n\n/*********************************************************************/\n/*  Select RRDS record structure 2 by setting __fill to 1            */\n/*                                                                   */\n/*  1. open an RRDS file record mode  (the cluster must be defined)  */\n/*  2. write three records (RRN 2, RRN 10, RRN 32)                   */\n/*********************************************************************/\n    rrds_rec->rrds_key.__fill = 1;\n\n    fileptr = fopen(\"DD:RRDSFILE\", \"wb+,type=record\");\n    if (fileptr == NULL) {\n      save_amrc = *__amrc;  /* need copy of __amrc structure */\n      printf(\"fopen failed errno=%d lastop=%d syscode=%X rc=%d\\n\",\n      errno,\n      save_amrc.__last_op,\n      save_amrc.__code.__abend.__syscode,\n      save_amrc.__code.__abend.__rc);\n      perror(\"fopen\");\n      exit(99);\n    }\n    rrds_rec->rrds_key.__recnum = 2;\n    rrds_rec->rrds_buf = buffer1;\n    fwrite(rrds_rec,1,88, fileptr);\n\n    rrds_rec->rrds_key.__recnum = 10;\n    rrds_rec->rrds_buf = buffer2;\n    fwrite(rrds_rec,1,88, fileptr);\n\n    rrds_rec->rrds_key.__recnum = 32;\n    rrds_rec->rrds_buf = buffer3;\n    fwrite(rrds_rec,1,88, fileptr);\n\n/*********************************************************************/\n/*  3. set file position to the first record                         */\n/*  4. read the first record in the file                             */\n/*  5. delete it                                                     */\n/*********************************************************************/\n    flocate(fileptr, &flocate_key, sizeof(unsigned long), __KEY_FIRST);\n\n    memset(outputbuf,0x00,80);\n    rrds_rec->rrds_buf = outputbuf;\n\n    fread(rrds_rec,1, 88, fileptr);\n    printf(\"The first record in the file (this will be deleted):\\n\");\n    printf(\"RRN %d: %s\\n\\n\",rrds_rec->rrds_key.__recnum,outputbuf);\n\n    fdelrec(fileptr);\n\n/*********************************************************************/\n/*  6. locate last record in file and set access direction backwards */\n/*  7. read the record                                               */\n/*  8. update the record                                             */\n/*********************************************************************/\n    flocate(fileptr, &flocate_key, sizeof(unsigned long), __KEY_LAST);\n\n    memset(outputbuf,0x00,80);\n    rrds_rec->rrds_buf = outputbuf;\n\n    fread(rrds_rec,1, 88, fileptr);\n    printf(\"The last record in the file (this one will be updated):\\n\");\n    printf(\"RRN %d: %s\\n\\n\",rrds_rec->rrds_key.__recnum,outputbuf);\n\n    memset(outputbuf,0x00,80);\n    memcpy(outputbuf,\"THIS IS THE UPDATED STRING... \",30);\n    fupdate(rrds_rec,88,fileptr);\n\n/*********************************************************************/\n/*  9. set _EDC_RRDS_HIDE_KEY environment variable                   */\n/* 10. read the next record in sequence (ie. RRN 10) into a          */\n/*     + character string                                            */\n/*********************************************************************/\n\n    setenv(\"_EDC_RRDS_HIDE_KEY\",\"Y\",1);\n    memset(outputbuf,0x00,80);\n    fread(outputbuf, 1, 80, fileptr);\n    printf(\"The middle record in the file (read into char string):\\n\");\n    printf(\"%80s\\n\\n\",outputbuf);\n\n    fclose(fileptr);\n}\n./ ADD NAME=CBC3GWT1 0102-00269-00269-0951-00029-00025-00000-BC0THOR\n*********************************************************************\n* Write to operator example. This is an assembler subroutine that   *\n* is called by CBC3GWT2, a C program. The C program passes two      *\n* parameters, the length, and the text of the message to display.   *\n* This program issues the WTO to display the message.               *\n*********************************************************************\nDYNWTO   CSECT\nDYNWTO   AMODE 31\nDYNWTO   RMODE ANY\n         PRINT GEN\n         EDCPRLG                   ALWAYS INCLUDE C PROLOG\n         L     6,=A(ACTMSG)        SET SVC35.ACTMSG TO DYN MSG\n         LA    7,76                LEN(WTO MESSAGE)-SET MAX 76\n         L     5,0(,1)             PARM1 IS\n         L     5,0(,5)                 LENGTH OF DYN MESSAGE\n         O     5,=X'40000000'      1ST BYTE - PAD CHAR (' ')\n         L     4,4(,1)             PARM2 IS DYN MSG ADDR\n         MVCL  6,4                 COPY DYNMSG TO SVC35 STRUCT\n         CNOP  0,4\n         BAL   1,BARNDMSG          BRANCH AROUND SVC35 STRUCT\n         DC    AL2(80)             TEXT LENGTH (76+4)\n         DC    B'1000000000000000' MCSFLAGS\nACTMSG   DC    CL76' '             ARBITRARY SIZE OF 76\n         DC    B'0000000000000000' DESCRIPTOR CODES\n         DC    B'0100000000000000' ROUTING CODES\nBARNDMSG DS    0H\n         SVC   35                  ISSUE SVC 35\n         EDCEPIL\n         END\n./ ADD NAME=CBC3GWT2 0103-00266-00269-0949-00013-00008-00000-BC0THOR\n/*********************************************************************/\n/* Write to operator example. This C program calls an assembler sub- */\n/* routine called DYNWTO, passing it the length and text of a message*/\n/* to be displayed. Standard OS linkage conventions are forced by use*/\n/* of the #pragma linkage(DYNWTO,OS) directive. Source for the DYNWTO*/\n/* program is in CBC3GWT1.                                           */\n/*********************************************************************/\n #pragma linkage(DYNWTO,OS)     /* dynwto corrected to DYNWTO */\n void DYNWTO(int, char *);\n main()\n {\n  DYNWTO(9,\"something\");\n }\n./ ADD NAME=CBC3RAA  0100-00269-00269-1008-00025-00025-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how break is used with the switch statement.   */\n/* Added night to the enum to provide possibility for testing the    */\n/* default for the switch.                                           */\n/*********************************************************************/\n\n#include <stdio.h>\n\nenum { morning, afternoon, evening, night} timeofday = night;\n\nint main(void) {\n\n  switch (timeofday) {\n    case morning:\n      printf(\"Good Morning\\n\");\n      break;\n\n    case evening:\n      printf(\"Good Evening\\n\");\n      break;\n\n    default:\n      printf(\"Good Day, eh\\n\");\n  }\n}\n./ ADD NAME=CBC3RAAA 0100-00269-00269-1014-00035-00035-00000-BC0THOR\n/*********************************************************************/\n/* This is an example of a simple C program. It uses the cos() math  */\n/* function and displays the result using printf().                  */\n/*********************************************************************/\n\n#include <stdio.h>              /* standard library header that\n                                   contains I/O function declarations\n                                   such as printf used below          */\n\n#include <math.h>               /* standard library header that\n                                   contains math function declarations\n                                   such as cos used below             */\n\n#define NUM 46.0                /* Preprocessor directive             */\n\ndouble x = 45.0;                /* Global variable\n                                           definitions                */\n\ndouble y = NUM;\n\n\nint main(void)                  /* Function definition\n                                   for main function                  */\n{\n   double z;                    /* Internal variable                  */\n   double w;                    /*   definitions                      */\n\n   z = cos(x);                  /* cos is declared in math.h as\n                                         double cos(double arg)       */\n   w = cos(y);\n   printf (\"cosine of x is %f\\n\", z);  /* Print cosine of x           */\n   printf (\"cosine of y is %f\\n\", w);  /* Print cosine of y           */\n\n   return(0);\n}\n./ ADD NAME=CBC3RAAB 0100-00269-00269-1044-00026-00026-00000-BC0THOR\n/*********************************************************************/\n/* This sample program calls another C program, which is the function*/\n/* max(). The source code for max() is in CBC3RMAX.                  */\n/*********************************************************************/\n#include <stdio.h>\n\n#define ONE     1\n#define TWO     2\n#define THREE   3\nextern int max(int, int);           /* Function declaration */\n\nint main(int argc, char * argv[])  /* Function definition */\n{\n   int u, w, x, y, z;\n\n   u = 5;\n   z = 2;\n   w = max(u,ONE);\n   x = max(w,TWO);\n   y = max(x,THREE);\n   z = max(y,z);\n\n   printf(\"w is %d, x is %d, y is %d, z is %d\",w,x,y,z);\n\n   return(0);\n}\n./ ADD NAME=CBC3RAAD 0100-00269-00269-1134-00025-00025-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how character constants are used */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n\nchar ch1 = 'd';\nchar ch2 = 'abcd';\nchar ch3 = '\\204';\nchar ch4 = '\\x84';\nwchar_t wch1 = L'd';\nwchar_t wch2 = L'abcd';\nwchar_t wch3 = L'\\204';\nwchar_t wch4 = L'\\x84';\n\nint main(void)\n  {\n  printf(\"ch1  = %c, ch2  = %c\\n\", ch1, ch2);\n  printf(\"ch3  = %c, ch4  = %c\\n\", ch3, ch4);\n  printf(\"wch1 = %lc, wch2 = %lc\\n\", wch1, wch2);\n  printf(\"wch3 = %lc, wch4 = %lc\\n\", wch3, wch4);\n\n  return(0);\n  }\n./ ADD NAME=CBC3RAAE 0100-00269-00269-1147-00020-00020-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how string literals are used with the string   */\n/* functions strcpy() and strcat().                                  */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar ch1[20];\nchar ch2[20] = \"Example!!\";\n\nint main(void)\n  {\n  strcpy(ch1, \"My \");\n  strcat(ch1, ch2);\n  printf(\"ch1 = %s\\n\", ch1);\n\n  return(0);\n  }\n./ ADD NAME=CBC3RAAF 0100-00269-00269-1206-00027-00027-00000-BC0THOR\n/*********************************************************************/\n/* This example illustrates the use of auto variables.               */\n/*********************************************************************/\n\n    #include <stdio.h>\n\n    int main(void)\n    {\n       void call_func(int passed_var);\n       auto int auto_var = 1; /* first definition of auto_var  */\n\n       {\n          int auto_var = 2;   /* second definition of auto_var */\n          printf(\"inner auto_var = %d\\n\", auto_var);\n       }\n       call_func(auto_var);\n       printf(\"outer auto_var = %d\\n\", auto_var);\n\n       return(0);\n    }\n\n    void call_func(int passed_var)\n    {\n       printf(\"passed_var = %d\\n\", passed_var);\n       passed_var = 3;\n       printf(\"passed_var = %d\\n\", passed_var);\n    }\n./ ADD NAME=CBC3RAAG 0101-00269-00269-1215-00037-00034-00000-BC0THOR\n/*********************************************************************/\n/* This example passes an array name to a function. letters are read */\n/* from the default input file and are placed into an array that is  */\n/* passed to included function sort(), which sorts the letters in    */\n/* ascending order. on return, the sorted array is printed.          */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n   void sort(char *array, int n);\n   char string[75];\n   int length;\n   printf(\"Enter letters:\\n\");\n   scanf(\"%74s\", string);\n   length = strlen(string);\n   sort(string,length);\n   printf(\"The sorted string is: %s\\n\", string);\n\n   return(0);\n}\nvoid sort(char *array, int n)\n{\n   int gap, i, j, temp;\n\n   for (gap = n / 2; gap > 0; gap /= 2)\n      for (i = gap; i < n; i++)\n         for (j = i - gap; j >= 0 &&array[j] > array[j + gap];\n            j -= gap)\n         {\n            temp = array[j];\n            array[j] = array[j + gap];\n            array[j + gap] = temp;\n         }\n}\n./ ADD NAME=CBC3RAAI 0100-00269-00269-1222-00037-00037-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how extern variables are used by two functions */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <string.h>\n\nchar string[75];\nint length;\n\nint main(void)\n{\n   void sort(void);\n\n   printf(\"Enter letters:\\n\");\n   scanf(\"%s\", string);\n   length = strlen(string);\n   sort();\n   printf(\"The sorted string is: %s\\n\", string);\n\n   return(0);\n}\nvoid sort(void)\n{\n   int gap, i, j, temp;\n\n   for (gap = length / 2; gap > 0; gap /= 2)\n      for (i = gap; i < length; i++)\n         for (j = i - gap;\n              j >= 0 && string[j] > string[j + gap];\n              j -= gap)\n         {\n            temp = string[j];\n            string[j] = string[j + gap];\n            string[j + gap] = temp;\n         }\n}\n./ ADD NAME=CBC3RAAK 0100-00269-00269-1236-00023-00023-00000-BC0THOR\n/*********************************************************************/\n/* This program illustrates the use of block scope static variables. */\n/*********************************************************************/\n\n#include <stdio.h>\n\nint main(void)\n{\n   void test(void);\n   int counter;\n   for (counter = 1; counter <= 4; ++counter)\n      test();\n\n   return(0);\n}\nvoid test(void)\n{\n   static int stat_var = 0;\n   auto int auto_var = 0;\n   stat_var++;\n   auto_var++;\n   printf(\"stat_var = %d auto_var = %d\\n\", stat_var, auto_var);\n}\n./ ADD NAME=CBC3RAAM 0100-00269-00269-1243-00027-00027-00000-BC0THOR\n/*********************************************************************/\n/* This example uses the void data type.                             */\n/*********************************************************************/\n\n    #include <stdio.h>\n    /* declaration of function find_max */\n    extern void find_max(int x[ ], int j);\n\n    int main(void)\n    {\n       static int numbers[ ] = { 99, 54, -102, 89 };\n\n       find_max(numbers, (sizeof(numbers) / sizeof(numbers[0])));\n\n       return(0);\n    }\n    void find_max(int x[ ], int j)\n    { /* begin definition of function find_max */\n       int i, temp = x[0];\n\n       for (i = 1; i < j; i++)\n       {\n           if (x[i] > temp)\n              temp = x[i];\n       }\n       printf(\"max number = %d\\n\", temp);\n    } /* end definition of function find_max  */\n./ ADD NAME=CBC3RAAN 0101-00269-00269-1301-00055-00054-00000-BC0THOR\n/*********************************************************************/\n/* This example demonstrates the use of enum. a prototype was added  */\n/* for the french() function, and the old-style function header for  */\n/* french() was updated to modern syntax.                            */\n/* User enters a number indicating day of week as 1-7.               */\n/*********************************************************************/\n\n#include <stdio.h>\n\nenum days {\n            Monday=1, Tuesday, Wednesday,\n            Thursday, Friday, Saturday, Sunday\n          } weekday;\n\nvoid french(enum days);\n\nint main(void)\n{\n   int num;\n\n   printf(\"Enter an integer for the day of the week.  \"\n          \"Mon=1,...,Sun=7\\n\");\n   scanf(\"%d\", &num);\n   weekday=num;\n   french(weekday);\n   return(0);\n}\nvoid french(enum days weekday)  {\n   switch (weekday)\n   {\n      case Monday:\n         printf(\"Le jour de la semaine est lundi.\\n\");\n         break;\n      case Tuesday:\n         printf(\"Le jour de la semaine est mardi.\\n\");\n         break;\n      case Wednesday:\n         printf(\"Le jour de la semaine est mercredi.\\n\");\n         break;\n      case Thursday:\n         printf(\"Le jour de la semaine est jeudi.\\n\");\n         break;\n      case Friday:\n         printf(\"Le jour de la semaine est vendredi.\\n\");\n         break;\n      case Saturday:\n         printf(\"Le jour de la semaine est samedi.\\n\");\n         break;\n      case Sunday:\n         printf(\"Le jour de la semaine est dimanche.\\n\");\n         break;\n      default:\n         printf(\"C'est le mauvais jour.\\n\");\n   }\n}\n./ ADD NAME=CBC3RAAO 0100-00269-00269-1321-00030-00030-00000-BC0THOR\n/*********************************************************************/\n/* This example uses a one-dimensional array.                        */\n/*********************************************************************/\n\n#include <stdio.h>\n#define  ARR_SIZE  5\n\nint main(void)\n{\n  static float const prices[ARR_SIZE] = { 1.41, 1.50, 3.75,\n     5.00, .86 };\n  auto float total;\n  int i;\n\n  for (i = 0; i < ARR_SIZE; i++)\n  {\n    printf(\"price = $%.2f\\n\", prices[i]);\n  }\n\n  printf(\"\\n\");\n\n  for (i = 0; i < ARR_SIZE; i++)\n  {\n    total = prices[i] * 1.05;\n\n    printf(\"total = $%.2f\\n\", total);\n  }\n\n  return(0);\n}\n./ ADD NAME=CBC3RAAP 0100-00269-00269-1326-00027-00027-00000-BC0THOR\n/*********************************************************************/\n/* This example uses a multi-dimensional array.                      */\n/*********************************************************************/\n\n#include <stdio.h>\n#define  NUM_ROW     3\n#define  NUM_COLUMN  5\n\nint main(void)\n{\n  static int salary_tbl[NUM_ROW][NUM_COLUMN] =\n  {\n    {  500,  550,  600,  650,  700   },\n    {  600,  670,  740,  810,  880   },\n    {  740,  840,  940, 1040, 1140   }\n  };\n  int grade , step;\n\n  for (grade = 0; grade < NUM_ROW; ++grade)\n   for (step = 0; step < NUM_COLUMN; ++step)\n   {\n     printf(\"salary_tbl[%d] [%d] = %d\\n\", grade,\n        step, salary_tbl[grade][step]);\n   }\n\n   return(0);\n}\n./ ADD NAME=CBC3RAAQ 0100-00269-00269-1332-00042-00042-00000-BC0THOR\n/*********************************************************************/\n/* This program searches for the first occurrence of a specified     */\n/* character string in an array of character strings.                */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#define  SIZE  20\n\nint main(void)\n{\n   static char *names[] = { \"Jim\", \"Amy\", \"Mark\", \"Sue\", NULL };\n   char * find_name(char **, char *);\n   char new_name[SIZE], *name_pointer;\n\n   printf(\"Enter name to be searched.\\n\");\n   scanf(\"%s\", new_name);\n   name_pointer = find_name(names, new_name);\n   printf(\"name %s%sfound\\n\", new_name,\n          (name_pointer == NULL) ? \" not \" : \" \");\n   exit(EXIT_FAILURE);\n} /* End of main */\n\n/*******************************************************************/\n/* Function find_name-this function searches an array of           */\n/* names to see if a given name already exists in the array,       */\n/* returns a pointer to the name or NULL if the name is not found. */\n/*                                                                 */\n/* char **arry is a pointer to arrays of pointers (existing names) */\n/* char *strng is a pointer to character array entered (new name)  */\n/*******************************************************************/\n\nchar * find_name(char **arry, char *strng)\n{\n   for (; *arry != NULL; arry++)         /* for each name          */\n   {\n      if (strcmp(*arry, strng) == 0)     /* if strings match       */\n         return(*arry);                  /* found it!              */\n   }\n   return(*arry);                        /* return the pointer     */\n} /* End of find_name */\n./ ADD NAME=CBC3RAAR 0101-00269-00269-1350-00020-00022-00000-BC0THOR\n/*********************************************************************/\n/* This example uses an abstract data type.                          */\n/* part 1 of 2-other file is CBC3RAR1, a header file.                */\n/*********************************************************************/\n\n#include \"cbc3rar1.h\"\n\nint main()\n{\n  int ctl1, ctl2;\n  ControlBlock* ctl;\n\n  ctl = GetControlBlock();     /* allocate and return a control block */\n\n  ctl1 = UpdateControlBlock(ctl,27);/*update the control block with 27*/\n\n  ctl2 = UseControlBlock(ctl);       /* use the updated control block */\n\n  return(0);\n}\n./ ADD NAME=CBC3RAAS 0100-00269-00269-1357-00034-00034-00000-BC0THOR\n/*********************************************************************/\n/* This program illustrates linked lists.                            */\n/*********************************************************************/\n\n#include <stdio.h>\n\nstruct record {\n                int number;\n                struct record *next_num;\n              };\n\nint main(void)\n{\n   struct  record name1, name2, name3;\n   struct  record *recd_pointer = &name1;\n   int sum = 0;\n\n   name1.number = 144;\n   name2.number = 203;\n   name3.number = 488;\n\n   name1.next_num = &name2;\n   name2.next_num = &name3;\n   name3.next_num = NULL;\n\n   while (recd_pointer != NULL)\n   {\n      sum += recd_pointer->number;\n      recd_pointer = recd_pointer->next_num;\n   }\n   printf(\"Sum = %d\\n\", sum);\n\n   return(0);\n}\n./ ADD NAME=CBC3RAAT 0100-00270-00270-1527-00034-00034-00000-BC0THOR\n/*********************************************************************/\n/* This example uses an array of pointers to functions.              */\n/*********************************************************************/\n\n#include <stdio.h>\nint func1(void);\nvoid func2(double a);\n\nint main(void)\n{\n   double num;\n   int retnum;\n   void (*ary[2]) ();\n   ary[0] = ((void(*)())func1);\n   ary[1] = ((void(*)())func2);\n\n   retnum=((int (*)())ary[0])();      /*  calls func1  */\n   printf(\"number returned = %i\\n\", retnum);\n   ((void (*)(double))ary[1])(num);   /*  calls func2  */\n\n   return(0);\n}\n\nint func1(void)\n{\nint number=3;\nreturn number;\n}\n\nvoid func2(double a)\n{\na=333.3333;\nprintf(\"result of func2 = %f\\n\", a);\n}\n./ ADD NAME=CBC3RAAU 0100-00270-00270-1629-00031-00031-00000-BC0THOR\n/*********************************************************************/\n/* This example uses a prototype function declarator.                */\n/*********************************************************************/\n\n#include <stdio.h>\n\nvoid sort(int table[], int length);   /* sort function protoype */\n\nint main(void)\n{\n  int table[]={1,5,8,4};\n  int length=4;\n  printf(\"length is %d\\n\",length);\n  sort(table,length);\n}\n/*********************************************************************/\n/* This is the sort function definition                              */\n/*********************************************************************/\nvoid sort(int table[], int length)\n{\n  int i, j, temp;\n\n  for (i = 0; i < length -1; i++)\n    for (j = i + 1; j < length; j++)\n      if (table[i] > table[j])\n      {\n        temp = table[i];\n        table[i] = table[j];\n        table[j] = temp;\n      }\n}\n./ ADD NAME=CBC3RAAV 0100-00270-00270-1634-00023-00023-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how a function is declared and defined.        */\n/*********************************************************************/\n\n#include <stdio.h>\ndouble absolute(double);\n\nint main(void)\n{\n   double f = -3.0;\n\n   printf(\"absolute number = %f\\n\", absolute(f));\n\n   return(0);\n}\n\ndouble absolute(double number)\n{\n   if (number < 0.0)\n      number = -number;\n\n   return (number);\n}\n./ ADD NAME=CBC3RAAX 0100-00271-00271-0832-00023-00023-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how a parameter is passed to a function.       */\n/*********************************************************************/\n\n#include <stdio.h>\nvoid increment(int);\n\nint main(void)\n{\n  int count = 5;\n\n  /* value of count is passed to the function */\n  increment(count);\n  printf(\"count = %d\\n\", count);\n\n  return(0);\n}\n\nvoid increment(int x)\n{\n  ++x;\n  printf(\"x = %d\\n\", x);\n}\n./ ADD NAME=CBC3RAAY 0100-00271-00271-0837-00026-00026-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how an address is passed to a function.        */\n/*********************************************************************/\n\n#include <stdio.h>\n\nint main(void)\n{\n  void increment(int *x);\n  int count = 5;\n\n  /* address of count is passed to the function */\n  increment(&count);\n  printf(\"count = %d\\n\", count);\n\n  return(0);\n}\n/*********************************************************************/\n/* This is the increment() function.                                 */\n/*********************************************************************/\n\nvoid increment(int *x)\n{\n  ++*x;\n  printf(\"*x = %d\\n\", *x);\n}\n./ ADD NAME=CBC3RAAZ 0100-00271-00271-0842-00026-00026-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how loss of precision occurs during type       */\n/* conversion.                                                       */\n/*********************************************************************/\n\n#include <stdio.h>\n\nint main(void)\n{\n\n  int i;\n  float f;\n  double d;\n  long double ld;\n\n  i = 1234567890;\n  f = i;\n  d = i;\n  ld = i;\n  printf(\"i  = %d\\n\", i);\n  printf(\"f  = %20.10Lf\\n\", f);\n  printf(\"d  = %20.10Lf\\n\", d);\n  printf(\"ld = %20.10Lf\\n\", ld);\n\n  return(0);\n}\n./ ADD NAME=CBC3RAA1 0100-00271-00271-0850-00021-00021-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how the values of data objects change in       */\n/* nested blocks.                                                    */\n/*********************************************************************/\n\n    #include <stdio.h>\n\n    int main(void)\n    {\n       int x = 1;                     /* Initialize x to 1  */\n       int y = 3;\n\n       if (y > 0)\n       {\n          int x = 2;                  /* Initialize x to 2  */\n          printf(\"second x = %4d\\n\", x);\n       }\n       printf(\"first  x = %4d\\n\", x);\n\n       return(0);\n    }\n./ ADD NAME=CBC3RAA2 0100-00271-00271-0855-00028-00028-00000-BC0THOR\n/*********************************************************************/\n/* This program counts the characters in the strings that are        */\n/* part of an array of pointers to characters.                       */\n/* The count stops when one of the digits 0 through 9 is             */\n/* encountered and resumes at the beginning of the next string.      */\n/*********************************************************************/\n\n#include <stdio.h>\n#define  SIZE  3\n\nint main(void)\n{\n   static char *strings[SIZE] = { \"ab\", \"c5d\", \"e5\" };\n   int i;\n   int letter_count = 0;\n   char *pointer;\n\n   for (i = 0; i < SIZE; i++)        /* for each string    */\n      for (pointer = strings[i]; *pointer != '\\0'; ++pointer)\n      {\n         if (*pointer >= '0' && *pointer <= '9')\n            break;\n         letter_count++;\n      }\n   printf(\"letter count = %d\\n\", letter_count);\n\n   return(0);\n}\n./ ADD NAME=CBC3RAA3 0100-00271-00271-0859-00022-00022-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how the continue statement can be used.        */\n/*********************************************************************/\n\n#include <stdio.h>\n#define  SIZE  5\n\nint main(void)\n{\n   int i;\n   static float rates[SIZE] = { 1.45, 0.05, 1.88, 2.00, 0.75 };\n\n   printf(\"Rates over 1.00\\n\");\n   for (i = 0; i < SIZE; i++)\n   {\n      if (rates[i] <= 1.00)  /*  skip rates <= 1.00  */\n         continue;\n      printf(\"rate = %.2f\\n\", rates[i]);\n   }\n\n   return(0);\n}\n./ ADD NAME=CBC3RAA4 0100-00271-00271-0916-00027-00027-00000-BC0THOR\n/*********************************************************************/\n/* This program counts the characters in strings that are part of an */\n/* array of pointers to characters. The count excludes the digits    */\n/* 0 through 9.                                                      */\n/*********************************************************************/\n\n#include <stdio.h>\n#define  SIZE  3\n\nint main(void)\n{\n   static char *strings[SIZE] = { \"ab\", \"c5d\", \"e5\" };\n   int i;\n   int letter_count = 0;\n   char *pointer;\n   for (i = 0; i < SIZE; i++)            /* for each string         */\n                                         /* for each character      */\n      for (pointer = strings[i]; *pointer != '\\0'; ++pointer)\n      {                                  /* if a number             */\n         if (*pointer >= '0' && *pointer <= '9')\n            continue;\n         letter_count++;\n      }\n   printf(\"letter count = %d\\n\", letter_count);\n\n   return(0);\n}\n./ ADD NAME=CBC3RAA5 0100-00271-00271-0922-00018-00018-00000-BC0THOR\n/*********************************************************************/\n/* This example illustrates the do statement.                        */\n/*********************************************************************/\n\n#include <stdio.h>\n\nint main (void)\n{\n   int reply1;\n\n   do\n   {\n      printf(\"Enter a 1\\n\");\n      scanf(\"%d\", &reply1);\n   } while (reply1 != 1);\n\n   return(0);\n}\n./ ADD NAME=CBC3RAA6 0100-00271-00271-0928-00028-00028-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how a goto statement may be used.              */\n/*********************************************************************/\n\n#include <stdio.h>\nvoid display(int matrix[3][3]);\n\nint main(void)\n{\n   int matrix[3][3]={1,2,3,4,5,2,8,9,10};\n   display(matrix);\n   return(0);\n}\n\nvoid display(int matrix[3][3])\n{\n   int i, j;\n\n   for (i = 0; i < 3; i++)\n      for (j = 0; j < 3; j++)\n      {\n         if ( (matrix[i][j] < 1) || (matrix[i][j] > 6) )\n            goto out_of_bounds;\n         printf(\"matrix[%d][%d] = %d\\n\", i, j, matrix[i][j]);\n      }\n   return;\n   out_of_bounds: printf(\"number must be 1 through 6\\n\");\n}\n./ ADD NAME=CBC3RAA7 0100-00271-00271-0931-00021-00021-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how the while statement may be used.           */\n/*********************************************************************/\n\n#define MAX_INDEX  (sizeof(item) / sizeof(item[0]))\n#include <stdio.h>\n\nint main(void)\n{\n   static int item[ ] = { 12, 55, 62, 85, 102 };\n   int index = 0;\n\n   while (index < MAX_INDEX)\n   {\n      item[index] *= 3;\n      printf(\"item[%d] = %d\\n\", index, item[index]);\n      ++index;\n   }\n\n   return(0);\n}\n./ ADD NAME=CBC3RAA8 0100-00271-00271-0934-00020-00020-00000-BC0THOR\n/*********************************************************************/\n/* This example illustrates the use of a macro.                      */\n/*********************************************************************/\n\n#include <stdio.h>\n\n#define SQR(s)  ((s) * (s))\n#define PRNT(a,b) \\\n{ printf(\"value 1 = %d\\n\", a); \\\n  printf(\"value 2 = %d\\n\", b) ; }\n\nint main(void)\n{\n  int x = 2;\n  int y = 3;\n\n  PRNT(SQR(x),y);\n\n  return(0);\n}\n./ ADD NAME=CBC3RAA9 0100-00271-00271-0936-00017-00017-00000-BC0THOR\n/*********************************************************************/\n/* This example is equivalent to CBC3RAA8.                           */\n/*********************************************************************/\n\n#include <stdio.h>\n\nint main(void)\n{\n  int x = 2;\n  int y = 3;\n  {\n     printf(\"value 1 = %d\\n\", ( (x) * (x) ) );\n     printf(\"value 2 = %d\\n\", y);\n  }\n\n  return(0);\n}\n./ ADD NAME=CBC3RABA 0100-00271-00271-0941-00015-00015-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how predefined macros are used.                */\n/* part 1 of 2-other file is CBC3RAB1.H                              */\n/*********************************************************************/\n\n#include <stdio.h>\n#include \"cbc3rab1.h\"\n\nint main(void)\n{\n   printf(\"At line %d of file %s\\n\", __LINE__, __FILE__);\n   testsub();      /* Call to function defined in cbc3rab1.h */\n\n   return(0);\n}\n./ ADD NAME=CBC3RABB 0100-00271-00271-0945-00021-00021-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how predefined macros are used.                */\n/*********************************************************************/\n\n#pragma langlvl(ANSI)\n#include <stdio.h>\n\n#ifdef __STDC__\n   #define CONFORM    \"conforms\"\n#else\n   #define CONFORM    \"does not conform\"\n#endif\n\nint main(void)\n{\n  printf(\"Line %d of file %s has been executed\\n\", __LINE__,__FILE__);\n  printf(\"This file was compiled at %s on %s\\n\", __TIME__,__DATE__);\n  printf(\"This program %s to ANSI standards\\n\", CONFORM);\n\n  return(0);\n}\n./ ADD NAME=CBC3RABC 0100-00271-00271-0949-00021-00021-00000-BC0THOR\n/*********************************************************************/\n/* This example uses conditional compilation directives.             */\n/*********************************************************************/\n\nint main(void)\n{\n   static int array[ ] = { 1, 2, 3, 4, 5 };\n   int i;\n\n   for (i = 0; i <= 4; i++)\n   {\n      array[i] *= 2;\n\n      #if TEST >= 1\n         printf(\"i = %d\\n\", i);\n         printf(\"array[i]  = %d\\n\", array[i]);\n      #endif\n   }\n\n   return(0);\n}\n./ ADD NAME=CBC3RABD 0100-00271-00271-1018-00025-00025-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how #line is used.                             */\n/*********************************************************************/\n\n#include <stdio.h>\n#define LINE200 200\n\nint main(void)\n{\n   func_1();\n   func_2();\n   return(0);\n}\n\n#line 100\nfunc_1()\n{\n   printf(\"Func_1 - the current line number is %d\\n\",__LINE__);\n}\n\n#line LINE200\nfunc_2()\n{\n   printf(\"Func_2 - the current line number is %d\\n\",__LINE__);\n}\n./ ADD NAME=CBC3RABE 0100-00271-00271-1024-00061-00061-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how #pragma inline may be used.                */\n/*********************************************************************/\n#pragma csect(code,\"MYCFILE\")\n#pragma csect(static,\"MYSFILE\")\n#pragma options(INLINE)\n#include <stdio.h>\n#include <stdlib.h>\nstatic int (writerecord) (int, char *);\n#pragma inline (writerecord)\nint main()\n{\n   int chardigit;\n   int digit;\n   printf(\"Enter a digit\\n\");\n   chardigit = getchar();\n   digit = chardigit - '0';\n   if (digit < 0 || digit > 9)\n     {\n      printf(\"invalid digit\\n\");\n      exit(99);\n     }\n   switch(digit)\n     {\n      case 0:\n         writerecord(0, \"entered 0\");\n         break;\n      case 1:\n         writerecord(1, \"entered 1\");\n         break;\n      default:\n         writerecord(9, \"entered other\");\n     }\n}\nstatic int writerecord (int digit, char *phrase)\n{\n   switch (digit)\n     {\n      case 0:\n         printf(\"writerecord 0: \");\n         printf(\"%s\\n\", phrase);\n         break;\n      case 1:\n         printf(\"writerecord 1: \");\n         printf(\"%s\\n\", phrase);\n         break;\n      case 2:\n         printf(\"writerecord 2: \");\n         printf(\"%s\\n\", phrase);\n         break;\n      case 3:\n         printf(\"writerecord 3: \");\n         printf(\"%s\\n\", phrase);\n         break;\n      default:\n         printf(\"writerecord X: \");\n         printf(\"%s\\n\", phrase);\n      }\n\n    return 0;\n}\n./ ADD NAME=CBC3RABF 0100-00271-00271-1032-00031-00031-00000-BC0THOR\n/*********************************************************************/\n/* This example illustrates blocks, nesting, and scope.              */\n/*********************************************************************/\n\n #include <stdio.h>\n int i = 1;                         /* i defined at file scope */\n\n int main(int argc, char * argv[])\n {\n\n    printf(\"%d\\n\", i);                     /* Prints 1 */\n\n    {\n       int i = 2, j = 3;            /* i and j defined at\n                                       block scope */\n       printf(\"%d\\n%d\\n\", i, j);                  /* Prints 2, 3 */\n\n       {\n          int i = 0;                /* i is redefined in a nested block     */\n                                    /* previous definitions of i are hidden */\n          printf(\"%d\\n%d\\n\", i, j); /* Prints 0, 3 */\n       }\n\n       printf(\"%d\\n\", i);                  /* Prints 2 */\n\n    }\n\n    printf(\"%d\\n\", i);                     /* Prints 1 */\n\n    return(0);\n }\n./ ADD NAME=CBC3RABG 0100-00271-00271-1038-00030-00030-00000-BC0THOR\n/*********************************************************************/\n/* This example prints out ctest characters.                         */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <ctype.h>\n\nint main(void)\n{\n   int ch;\n\n   for (ch = 0; ch <= 0xff; ch++)\n      {\n      printf(\"%#04X \", ch);\n      printf(\"%3s \", isalnum(ch)  ? \"AN\" : \" \");\n      printf(\"%2s \", isalpha(ch)  ? \"A\"  : \" \");\n      printf(\"%2s\",  iscntrl(ch)  ? \"C\"  : \" \");\n      printf(\"%2s\",  isdigit(ch)  ? \"D\"  : \" \");\n      printf(\"%2s\",  isgraph(ch)  ? \"G\"  : \" \");\n      printf(\"%2s\",  islower(ch)  ? \"L\"  : \" \");\n      printf(\"%c\",  isprint(ch)  ? ch   : ' ');\n      printf(\"%3s\",  ispunct(ch)  ? \"PU\" : \" \");\n      printf(\"%2s\",  isspace(ch)  ? \"S\"  : \" \");\n      printf(\"%3s\",  isprint(ch)  ? \"PR\" : \" \");\n      printf(\"%2s\",  isupper(ch)  ? \"U\"  : \" \");\n      printf(\"%2s\",  isxdigit(ch) ? \"X\"  : \" \");\n\n      putchar('\\n');\n      }\n}\n./ ADD NAME=CBC3RABI 0100-00271-00271-1039-00049-00049-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how the switch statement may be used.          */\n/*********************************************************************/\n\n#include <stdio.h>\n\nint main(void)\n{\n  int month;\n\n  /* Read in a month value */\n  printf(\"Enter month: \");\n  scanf(\"%d\", &month);\n\n  /* Tell what season it falls into */\n  switch (month)\n  {\n     case 12:\n     case 1:\n     case 2:\n        printf(\"month %d is a winter month\\n\", month);\n        break;\n\n     case 3:\n     case 4:\n     case 5:\n        printf(\"month %d is a spring month\\n\", month);\n        break;\n\n     case 6:\n     case 7:\n     case 8:\n        printf(\"month %d is a summer month\\n\", month);\n        break;\n\n     case 9:\n     case 10:\n     case 11:\n        printf(\"month %d is a fall month\\n\", month);\n        break;\n\n     case 66:\n     case 99:\n     default:\n        printf(\"month %d is not a valid month\\n\", month);\n  }\n\n  return(0);\n}\n./ ADD NAME=CBC3RABQ 0100-00271-00271-1047-00041-00041-00000-BC0THOR\n/*********************************************************************/\n/* This program searches for the first occurrence of a specified     */\n/* character string in an array of character strings.                */\n/*********************************************************************/\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#define  SIZE  20\n\nint main(void)\n{\n   static char *names[] = { \"Jim\", \"Amy\", \"Mark\", \"Sue\", NULL };\n   char * find_name(char **, char *);\n   char new_name[SIZE], *name_pointer;\n\n   printf(\"Enter name to be searched.\\n\");\n   scanf(\"%s\", new_name);\n   name_pointer = find_name(names, new_name);\n   printf(\"name %s%sfound\\n\", new_name,\n          (name_pointer == NULL) ? \" not \" : \" \");\n   exit(EXIT_FAILURE);\n} /* End of main */\n\n/* function find_name-this function searches an array of           */\n/* names to see if a given name already exists in the array,       */\n/* returns a pointer to the name or NULL if the name is not found  */\n\n/* char **arry is a pointer to arrays of pointers (existing names) */\n/* char *strng is a pointer to character array entered (new name)  */\n\nchar * find_name(char **arry, char *strng)\n{\n   for (; *arry != NULL; arry++)         /* for each name          */\n   {\n      if (strcmp(*arry, strng) == 0)     /* if strings match       */\n         return(*arry);                  /* found it!              */\n   }\n   return(*arry);                        /* return the pointer     */\n} /* End of find_name */\n./ ADD NAME=CBC3RAB1 0100-00271-00271-1053-00012-00012-00000-BC0THOR\n/*********************************************************************/\n/* This example shows how predefined macros are used.                */\n/* part 2 of 2-other file is CBC3RABA                                */\n/*********************************************************************/\n\n#include <stdio.h>\n\ntestsub()\n{\n   printf(\"At line %d of file %s\\n\", __LINE__, __FILE__);\n   return;\n}\n./ ADD NAME=CBC3RAH1 0100-00271-00271-1104-00020-00020-00000-BC0THOR\n/*********************************************************************/\n/* This example shows the linkage of extern objects/functions.       */\n/* part 1 of 3-other files are CBC3RAH2, CBC3RAH3.                   */\n/* In this file, the program receives the price of an item,          */\n/* adds the tax, and prints the total cost of the item.              */\n/*********************************************************************/\n\n     #include <stdio.h>\n\n     int main(void)\n     {        /* begin main */\n        void tally(void);   /* declaration of function tally */\n        extern float total; /* first declaration of total    */\n\n        printf(\"Enter the purchase amount: \\n\");\n        tally();\n        printf(\"\\nWith tax, the total is:  %.2f\\n\", total);\n\n        return(0);\n     }        /* end main */\n./ ADD NAME=CBC3RAH2 0100-00271-00271-1107-00017-00017-00000-BC0THOR\n/*********************************************************************/\n/* This file defines the function tally.                             */\n/* Part 2 of 3-other files are CBC3RAH1, CBC3RAH3.                   */\n/*********************************************************************/\n\n     #include <stdio.h>\n     #define tax_rate 0.05\n\n     void tally(void)\n     {   /* begin tally */\n        float tax;\n        extern float total; /* second declaration of total       */\n\n        scanf(\"%f\", &total);\n        tax = tax_rate * total;\n        total += tax;\n     }   /* end tally */\n./ ADD NAME=CBC3RAH3 0100-00271-00271-1109-00006-00006-00000-BC0THOR\n/*********************************************************************/\n/* part 3 of 3-other files are CBC3RAH1, CBC3RAH2.                   */\n/*********************************************************************/\n\n     float total;\n\n./ ADD NAME=CBC3RAJ1 0100-00271-00271-1208-00017-00017-00000-BC0THOR\n/*********************************************************************/\n/* This program illustrates the use of file scope static variables.  */\n/* part 1 of 2-other file is CBC3RAJ2.                               */\n/*********************************************************************/\n\n#include <stdio.h>\nextern void var_print(void);\nstatic stat_var = 1;\n\nint main(void)\n{\n   printf(\"file1 stat_var = %d\\n\", stat_var);\n   var_print();\n   printf(\"FILE1 stat_var = %d\\n\", stat_var);\n\n   return(0);\n}\n./ ADD NAME=CBC3RAJ2 0100-00271-00271-1203-00012-00012-00000-BC0THOR\n/*********************************************************************/\n/* This example illustrates the use of file scope static variables.  */\n/* part 2 of 2-other file is CBC3RAJ1.                               */\n/*********************************************************************/\n\n#include <stdio.h>\nstatic int stat_var = 2;\n\nvoid var_print(void)\n{\n    printf(\"file2 stat_var = %d\\n\", stat_var);\n}\n./ ADD NAME=CBC3RAR1 0100-00269-00269-1345-00015-00015-00000-BC0THOR\n/*********************************************************************/\n/* This example uses an abstract data type.                          */\n/* part 2 of 2-other file is CBC3RAAR.                               */\n/*********************************************************************/\n\n#ifndef __INTERFACE__\n  #define __INTERFACE__\n\n  typedef struct ControlBlock_T ControlBlock;\n\n  ControlBlock* GetControlBlock(){};\n  int UpdateControlBlock(ControlBlock* value1, int value2){};\n  int UseControlBlock(ControlBlock* value3){};\n\n#endif\n./ ADD NAME=CBC3RMAX 0100-00269-00269-1044-00014-00014-00000-BC0THOR\n/*********************************************************************/\n/* This is an example of a C program called by another C program,    */\n/* CBC3RAAB. CBC3RAAB passes two numbers. This program compares them */\n/* and returns the larger of the two (or the second, if they are     */\n/* equal).                                                           */\n/*********************************************************************/\n\nint max (int a,int b)                 /* Function  definition */\n{\n   if ( a > b )\n       return (a);\n   else\n       return (b);\n}\n./ ADD NAME=CBC3UAAM 0100-00271-00271-1216-00042-00042-00000-BC0THOR\n/*********************************************************************/\n/* Converts celsius temperatures to fahrenheit.                      */\n/* Part 1 of 2-parts. Other part is cbc3uaan.h                       */\n/*********************************************************************/\n#include <stdio.h>\n\n#include \"cbc3uaan.h\"\n\nvoid convert(double);\n\nint main(int argc, char **argv)\n{\n    double c_temp;\n\n    if (argc == 1) {  /* get Celsius value from stdin */\n       int ch;\n\n       printf(\"Enter Celsius temperature: \\n\");\n\n       if (scanf(\"%f\", &c_temp) != 1) {\n          printf(\"You must enter a valid temperature\\n\");\n       }\n       else {\n          convert(c_temp);\n       }\n    }\n    else {  /* convert the command-line arguments to Fahrenheit */\n       int i;\n\n       for (i = 1; i < argc; ++i) {\n           if (sscanf(argv[i], \"%f\", &c_temp) != 1)\n              printf(\"%s is not a valid temperature\\n\",argv[i]);\n           else\n              convert(c_temp);\n       }\n    }\n}\n\nvoid convert(double c_temp) {\n   double f_temp = (c_temp * CONV + OFFSET);\n   printf(\"%5.2f Celsius is %5.2f Fahrenheit\\n\",c_temp, f_temp);\n}\n./ ADD NAME=CBC3UAAN 0100-00271-00271-1217-00008-00008-00000-BC0THOR\n/*********************************************************************/\n/*  User include file:  cbc3uaan.h                                   */\n/*  Part 2 of a 2-part sample. First part is cbc3uaam.               */\n/*********************************************************************/\n\n#define CONV   (9./5.)\n#define OFFSET 32\n\n./ ADD NAME=CBC3X06C 0100-00271-00271-1243-00020-00020-00000-BC0THOR\n/*********************************************************************/\n/* This example illustrates function calls.                          */\n/*********************************************************************/\n\n#include <stdio.h>\nvoid func (int a, int b);\n\nint main(void)\n{\n   int x = 5, y = 7;\n\n   func(x, y);\n   printf(\"In main, x = %d    y = %d\\n\", x, y);\n}\n\nvoid func (int a, int b)\n{\n   a += b;\n   printf(\"In func, a = %d    b = %d\\n\", a, b);\n}\n./ ADD NAME=CBC3X08A 0100-00271-00271-1248-00022-00022-00000-BC0THOR\n/*********************************************************************/\n/* This example illustrates the __FUNCTION__ predefined macro        */\n/* in a C program.                                                   */\n/*********************************************************************/\n#include <stdio.h>\n\nint foo(int);\n\nmain(int argc, char **argv) {\n   int k = 1;\n   printf (\" In function %s \\n\",__FUNCTION__);\n   foo(k);\n}\n\nint foo (int i) {\n   printf (\" In function %s \\n\",__FUNCTION__);\n}\n/**\n ** The output of this example is:\n **      In function main\n **      In function foo\n **/\n./ ADD NAME=CBC3YIV1 0100-00271-00271-1313-00024-00024-00000-BC0THOR\n/*********************************************************************/\n/* Echo arguments to STDOUT                                          */\n/*********************************************************************/\n#include <stdio.h>\n#define NUM_CHARS 36\nint i;\nint main(ac, av)\n    int  ac;\n    char *av[];\n    {\n    i= 0;\n    ++av, --ac;\n    for (; 0 < ac; ++av, --ac)\n        {\n        i= i + printf(\"%s\", *av);\n        if (1 < ac)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n        }\n    i= NUM_CHARS - i;\n    if (i < 0) i= -i;\n    exit(i);\n    }\n./ ADD NAME=CBRAKETS 0100-00277-00277-0952-00068-00068-00000-BC0THOR\n         TITLE '*****CBRAKETS: CONVERT C PROGRAM BRACKETS *****'\nCBRAKETS SVLNK R3\n         PRINT NOGEN\n***********************************************************************\n* CONVERT THE VARIANT CHARACTERS IN A C SOURCE PROGRAM TO THE VALUES  *\n* USED BY THE C COMPILER. AT PRESENT:                                 *\n*                                                                     *\n*               C COMPILER       REFLECTIONS                          *\n*               --------------   -------------------                  *\n* LEFT BRACKET  X'AD' Y-UMLAUT   X'BA' LEFT BRACKET                   *\n*                                                                     *\n* RIGHT BRACKET X'BD' QUOTE      X'BB' RIGHT BRACKET                  *\n*                                                                     *\n* CIRCUMFLEX    X'5F' CIRCUMFLEX X'B0' CIRCUMFLEX                     *\n*                                                                     *\n* TO SATISFY THE COMPILER, X'BA' IS CONVERTED TO X'AD' FOR THE LEFT   *\n* BRACKET, X'BB' IS CONVERTED TO X'BD' FOR THE RIGHT BRACKET, AND     *\n* X'B0' IS CONVERTED TO X'5F' FOR THE CIRCUMFLEX (HAT).               *\n*                                                                     *\n* AUTHOR R THORNTON AUG 2000                                          *\n***********************************************************************\n*\n***********************************************************************\n* INITIALIZATION: OPEN FILES                                          *\n***********************************************************************\n         OPEN  (SYSOUT,OUTPUT,SYSIN)   OPEN FILES\n***********************************************************************\n* MAINLINE PROCESSING: READ-TRANSLATE-WRITE THROUGH ENTIRE INPUT FILE.*\n***********************************************************************\nMAINLINE GET   SYSIN,RECORD            READ SYSIN RECORD\n         TR    RECORD,XLATE            TRANSLATE BRACKETS\n         PUT   SYSOUT,RECORD           WRITE TRANSLATED RECORD\n         B     MAINLINE                LOOP THRU SYSIN FILE.\n***********************************************************************\n*        END OF INPUT FILE AND END OF JOB                             *\n***********************************************************************\nEOJ      CLOSE (SYSIN,,SYSOUT)         CLOSE FILES\n         L     R13,4(R13)              GET CALLER'S SAVE ADDRESS\n         LM    R14,R12,12(R13)         RESTORE CALLER'S REGS\n         SR    R15,R15                 ZERO RETURN CODE\n         BR    R14                     RETURN TO CALLER\n***********************************************************************\n*        STORAGE AND FILE AREAS                                       *\n***********************************************************************\nRECORD   DS    CL80                    RECORD STORAGE AREA\nXLATE    DS    0D                      TRANSLATION TABLE\n         DC    XL16'000102030405060708090A0B0C0D0E0F' 00-0F\n         DC    XL16'101112131415161718191A1B1C1D1E1F' 10-1F\n         DC    XL16'202122232425262728292A2B2C2D2E2F' 20-2F\n         DC    XL16'303132333435363738393A3B3C3D3E3F' 30-3F\n         DC    XL16'404142434445464748494A4B4C4D4E4F' 40-4F\n         DC    XL16'505152535455565758595A5B5C5D5E5F' 50-5F\n         DC    XL16'606162636465666768696A6B6C6D6E6F' 60-6F\n         DC    XL16'707172737475767778797A7B7C7D7E7F' 70-7F\n         DC    XL16'808182838485868788898A8B8C8D8E8F' 80-8F\n         DC    XL16'909192939495969798999A9B9C9D9E9F' 90-9F\n         DC    XL16'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF' A0-AF\n         DC    XL16'5FB1B2B3B4B5B6B7B8B9ADBDBCBDBEBF' B0-BF B0, BA, BB\n         DC    XL16'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF' C0-CF\n         DC    XL16'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF' D0-DF\n         DC    XL16'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF' E0-EF\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF' F0-FF\nSYSIN    DCB   DSORG=PS,MACRF=GM,DDNAME=SYSIN,EODAD=EOJ,               X\n               RECFM=FB,LRECL=80\nSYSOUT   DCB   DSORG=PS,MACRF=PM,DDNAME=SYSOUT,                        X\n               RECFM=FB,LRECL=80\n         LTORG\n         END\n./ ADD NAME=CCMP     0100-00294-00294-1527-00028-00028-00000-BC0THOR\n/*********************************************************************/\n/*   PURPOSE: SUBMITS A C COMPILE/BIND FOR THE MEMBER BEING EDITED   */\n/*            USING THE JCL IN PDS.JCL(EDCCB) AS MODIFIED BY EDIT    */\n/*            MACRO CEDIT WHICH IS INVOKED BY THIS EDIT MACRO.       */\n/*   AUTHOR:  BC0THOR (DICK THORNTON) CREATION DATE: 08/17/2000      */\n/*   TYPICAL USER(S): BC0THOR                                        */\n/*   PARAMETERS PASSED: NONE                                         */\n/*   CDC COMPLIANCE: NO CDC DATE DEPENDENCIES                        */\n/*********************************************************************/\n/*   MAINTENANCE RECORD: LAST 3 CHANGES                              */\n/*********************************************************************/\n/*   DATE    LOGONID REASON FOR CHANGE & WHAT WAS DONE               */\n/*-------------------------------------------------------------------*/\n/*08/17/2000 BC0THOR INITIAL CREATION                                */\n/*                                                                   */\n/*********************************************************************/\nISREDIT MACRO\nCONTROL NOLIST NOSYMLIST NOCONLIST MSG\nISREDIT (CMBR) = MEMBER  /* GET NAME OF MEMBER BEING EDITED.         */\nIF &CMBR = &STR() THEN DO\n    SET &ZEDSMSG = &STR(NO MEMBER)\n    SET &ZEDLMSG = &STR(MEMBER VARIABLE FROM ISPF IS NULL)\n    ISPEXEC SETMSG MSG(ISRZ001)\n    EXIT CODE(12)\n    END\nISPEXEC VPUT (CMBR)        /* WRITE MEMBER NAME TO VARIABLE POOL     */\nISREDIT SAVE               /* SAVE MEMBER BEING EDITED               */\nISPEXEC EDIT DATASET(PDS.JCL(EDCCB)) MACRO(CEDIT)       /*EDIT,SUBMIT*/\n./ ADD NAME=CEDIT    0100-00294-00294-1528-00024-00024-00000-BC0THOR\n/*********************************************************************/\n/*   PURPOSE: THIS EDIT MACRO IS CALLED BY EDIT MACRO CCMP TO CHANGE */\n/*            THE JCL IN BC0THOR.PDS.ASM(EDCCB) SO THAT IT WILL      */\n/*            COMPILE THE PROGRAM JUST EDITED WHEN THE CCMP MACRO    */\n/*            WAS INVOKED. THE CCMP MACRO VPUTS THE MEMBER NAME IN   */\n/*            POOL VARIABLE CMBR BEFORE INVOKING THIS MACRO.         */\n/*   AUTHOR:  BC0THOR (DICK THORNTON) CREATION DATE: 08/17/2000      */\n/*   TYPICAL USER(S): BC0THOR                                        */\n/*   PARAMETERS PASSED: NONE                                         */\n/*   CDC COMPLIANCE: NO CDC DATE DEPENDENCIES                        */\n/*********************************************************************/\n/*   MAINTENANCE RECORD: LAST 3 CHANGES                              */\n/*********************************************************************/\n/*   DATE    LOGONID REASON FOR CHANGE & WHAT WAS DONE               */\n/*-------------------------------------------------------------------*/\n/*08/17/2000 BC0THOR INITIAL CREATION                                */\n/*                                                                   */\n/*********************************************************************/\nISREDIT MACRO\nCONTROL NOLIST NOSYMLIST NOCONLIST MSG\nISPEXEC VGET (CMBR)           /* GET MEMBER NAME SET BY CCMP MACRO   */\nISREDIT CHANGE ALL 'XXXXXXXX' '&CMBR'    /* CHANGE X'S TO MEMBER NAME*/\nISREDIT SUBMIT                /* SUBMIT RESULTING COMPILE/LKED JCL   */\nISREDIT CAN                   /* DON'T SAVE THE CHANGES TO EDCCB     */\n./ ADD NAME=EDCCB    0100-00294-00294-1528-00060-00060-00000-BC0THOR\n//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//********************************************************************\n//*                BC0THOR.PDS.JCL(EDCCB)                            *\n//********************************************************************\n//* DO NOT MODIFY THIS JCL: IT IS USED BY EDIT MACROS CCMP AND CEDIT *\n//********************************************************************\n//*  COMPILE AND BIND A C PROGRAM                                    *\n//*                                                                  *\n//*  SOURCE PROGRAM IS BC0THOR.PDS.C(XXXXXXXX)                       *\n//*  OUTPUT LOAD MODULE IS BC0THOR.LOAD.LOAD(XXXXXXXX)               *\n//*                                                                  *\n//*  OS/390 C/C++  V2R6M0  5647-A01                                  *\n//********************************************************************\n//*-------------------------------------------------------------------\n//*  CONVERT SQUARE BRACKETS TO COMPILER EXPECTED VALUES\n//*-------------------------------------------------------------------\n//CBRAKETS EXEC PGM=CBRAKETS\n//STEPLIB  DD   DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//SYSUDUMP DD   SYSOUT=*\n//SYSIN    DD   DSN=BC0THOR.PDS.C(XXXXXXXX),DISP=SHR\n//SYSOUT   DD   DSN=&&CSOURCE,DISP=(,PASS),\n//         UNIT=DISK,SPACE=(CYL,(2,1),RLSE),\n//         DSORG=PS,RECFM=FB,LRECL=80\n//*-------------------------------------------------------------------\n//*  COMPILE STEP:\n//*-------------------------------------------------------------------\n//COMPILE EXEC PGM=CBCDRVR,\n//    PARM=('/AGG,EXP,LIS,OF,OPT,SO,XR,CHE(ALL)')\n//STEPLIB  DD  DSN=CEE.SCEERUN,DISP=SHR\n//         DD  DSN=CBC.SCBCCMP,DISP=SHR\n//SYSLIB   DD  DSN=CEE.SCEEH.H,DISP=SHR\n//         DD  DSN=CEE.SCEEH.SYS.H,DISP=SHR\n//         DD  DSN=CBC.SCBCSAM,DISP=SHR\n//SYSLIN   DD  DSN=&&LOADSET,DISP=(NEW,PASS),\n//         UNIT=DISK,SPACE=(TRK,(3,3)),\n//         RECFM=FB,LRECL=80,BLKSIZE=3200\n//SYSPRINT DD  SYSOUT=*\n//SYSOUT   DD  SYSOUT=*\n//SYSCPRT  DD  SYSOUT=*\n//SYSIN    DD  DSN=&&CSOURCE,DISP=(OLD,PASS,DELETE)\n//*-------------------------------------------------------------------\n//*  BIND STEP:\n//*-------------------------------------------------------------------\n//BIND   EXEC PGM=IEWL,COND=(4,LT,COMPILE),\n//         PARM=(LIST,LET,MAP,XREF,CALL)\n//STEPLIB  DD  DSN=CEE.SCEERUN,DISP=SHR\n//SYSLIB   DD  DSN=CEE.SCEELKEX,DISP=SHR\n//         DD  DSN=CEE.SCEELKED,DISP=SHR\n//         DD  DSN=SYS1.IMSVS.RESLIB,DISP=SHR\n//         DD  DSN=ISP.SISPLOAD,DISP=SHR\n//         DD  DSN=BC0THOR.LOAD.LOAD,DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSN=&&LOADSET,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSLMOD  DD  DSN=BC0THOR.LOAD.LOAD(XXXXXXXX),DISP=SHR\n//SYSDEFSD DD  DUMMY\n//SYSIN    DD  DUMMY\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "@FILE559": {"ttr": 4355, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00U\\x01\\x01\\x02_\\x01\\x02\\x12\\x9f\\x01F\\x00\\x12\\x00\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2001-01-25T00:00:00", "modifydate": "2002-05-09T01:46:55", "lines": 18, "newlines": 2, "modlines": 0, "user": "SBGOLOB"}, "text": "//***FILE 559 is from Dick Thornton, who is the author of the       *   FILE 559\n//*           DISASSEMBLER program on File 217, and his new         *   FILE 559\n//*           DISASSEMBLER program on File 234.  This is a large    *   FILE 559\n//*           collection of his C-Language Code.                    *   FILE 559\n//*                                                                 *   FILE 559\n//*           emails:  (check to see which are relevant):           *   FILE 559\n//*               dickthor@hotmail.com                              *   FILE 559\n//*               cthornton@swva.net                                *   FILE 559\n//*               rthornton@trigon.com                              *   FILE 559\n//*                                                                 *   FILE 559\n//*           Many extra C-Language programs are also included      *   FILE 559\n//*           in the IEBUPDTE-unloaded pds, which is member         *   FILE 559\n//*           $SAMPSRC.                                             *   FILE 559\n//*                                                                 *   FILE 559\n//*           JCL to run the C-Language programs are also included  *   FILE 559\n//*           in the IEBUPDTE-unloaded pds, which is member         *   FILE 559\n//*           $SAMPJCL.                                             *   FILE 559\n//*                                                                 *   FILE 559\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ABAL": {"ttr": 4357, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x16\\x01\\x00\"?\\x01\\x02\\x12\\x1f\\x16H\\x00\\xe0\\x00\\xe9\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2000-08-10T00:00:00", "modifydate": "2002-05-01T16:48:16", "lines": 224, "newlines": 233, "modlines": 0, "user": "BC0THOR"}, "text": "/**********/\n/* abal.c */\n/******************************************************************/\n/* reads a C language source program and reformats it for the     */\n/* following 79-byte record format:                               */\n/*   col  1 - 9   (9)  blanks                                     */\n/*   col 10 - 48  (39) instruction text                           */\n/*   col 49       (1)  blank                                      */\n/*   col 50 - 77  (28) comment                                    */\n/*   col 78 - 79  (2)  carriage-return and line-feed              */\n/* Instruction text may exceed the 39 bytes reserved for it, and  */\n/* will be retained as-is, even if the resulting record exceeds 79*/\n/* bytes. If the instruction text ends before column 72, an       */\n/* attempt will be made to squeeze as much comment as possible    */\n/* following the text, while maintaining a 79-byte record.        */\n/* Comments will be stripped and squeezed into the space available*/\n/* following the text, but not before column 50. Squeezing will   */\n/* first be done by removing trailing blanks. If the result is too*/\n/* long, the entire comment text will be stripped of leading      */\n/* blanks and any multiple imbedded blanks. Finally, the excess   */\n/* text will be trimmed from the right side. Whenever comment text*/\n/* is shorter than the available space, blanks will be added so   */\n/* that the comment string ends in column 77.                     */\n/* Author R Thornton September 1994                               */\n/******************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\nvoid initialize(void);                  /* initialization func    */\nvoid mainline(void);                    /* mainline function      */\nvoid process(void);                     /* process function       */\nvoid terminate(void);                   /* termination function   */\nvoid readrec(void);                     /* read input file record */\nvoid writerec(void);                    /* write output record    */\nvoid strip_instruction(void);           /* strip instruction text */\nvoid strip_comment(void);               /* strip comment from recd*/\nvoid format_output_record(void);        /* format output record   */\nvoid format_comment_block(void);        /* format comment blocks  */\n\nFILE *infile, *outfile;                 /* file pointers          */\n\nchar innam[81];                         /* input file name        */\nchar outnam[81];                        /* output file name       */\n\nchar inrecord[256];                     /* input file record area */\nchar outrecord[256];                    /* output file record area*/\n\nint i,in,ic,sc;                         /* subscripts             */\nint morerecs = -1;                      /* input eof switch       */\nlong incount = 0;                       /* input record counter   */\nlong outcount = 0;                      /* output record counter  */\nchar c;                                 /* work character         */\nchar comment[256];                      /* hold area for comment  */\nchar instruction[256];                  /* hold area for instruct */\nint reclen,instlen,cmtlen;              /* lengths                */\nint quoted_string;                      /* quoted string indicator*/\nint within_comment;                     /* within comment indic   */\nint solid_text_found;                   /* solid text found       */\n\n/******************************************************************/\n/* executive routine: overall program control                     */\n/******************************************************************/\nvoid main(void) {\n   initialize();                        /* open files             */\n   while(morerecs)                      /* perform mainline until */\n      mainline();                       /* no more records        */\n   terminate();                         /* close files            */\n   exit(0);                             /* quit                   */\n}\n\n/******************************************************************/\n/* mainline function: process input file until no more records.   */\n/******************************************************************/\nvoid mainline(void) {\n  strip_instruction();                  /* strip instruction text */\n  strip_comment();                      /* strip comment from recd*/\n  format_output_record();               /* format output record   */\n  writerec();                           /* write an output record */\n  readrec();                            /* read next input record */\n}\n\n/******************************************************************/\n/* format the output record using the previously stripped comment */\n/* and instruction text fields.                                   */\n/******************************************************************/\nvoid format_output_record(void) {\n  if(within_comment) {\n    format_comment_block();             /* format comment blocks  */\n    goto for_exit;\n  }\n  for_exit:\n    return;\n}\n\n/******************************************************************/\n/* format_comment_block: performs formatting within comment blocks*/\n/* to retain all text using word-wrap techniques. The indicator   */\n/* within_comment is used to indicate that some piece of text is  */\n/* being held for concatenation with the next statement.          */\n/******************************************************************/\nvoid format_comment_block(void) {\n}\n\n/******************************************************************/\n/* strip_comment: extracts comment text from the input record and */\n/* stores it in the instruction field.                            */\n/******************************************************************/\nvoid strip_comment(void) {\n  cmtlen = 0;                           /* preset comment length  */\n  comment[0] = '\\0';                    /* null out comment       */\n  for(; i<reclen; i++)                  /* find comment start     */\n    if((inrecord[i] == '/') && (inrecord[i+1] == '*')) break;\n  if(i >= reclen) goto sc_exit;         /* if no comment, exit    */\n  sc = i;                               /* save comment start pos */\n  for(ic=0; i<reclen; i++,ic++) {       /* copy comment text      */\n    if((inrecord[i] == '*') && (inrecord[i+1] == '/')) break;\n    comment[ic] = inrecord[i];          /* copy comment character */\n  }\n  if(inrecord[i] != '*') {              /* if no comment end found*/\n    printf(\"\\n%s\",inrecord);            /*  display the input recd*/\n    printf(\"\\nAbove record missing ending */ on comment\");\n    printf(\"\\npress any key to continue\"); /* prompt for key entry*/\n    c = getchar();                      /* await key pressed.     */\n  }\n  ic--;                                 /* back up to last byte   */\n  while(ic && (comment[ic] == ' ')) /* back up to comment end */\n    ic--;\n  cmtlen = ic+1;                        /* set comment length     */\n  comment[cmtlen] = '\\0';               /* make it a valid string */\n  sc_exit:\n    return;\n}\n\n/******************************************************************/\n/* strip_instruction: extracts instruction text from the input    */\n/* record and stores it in the instruction field.                 */\n/******************************************************************/\nvoid strip_instruction(void) {          /* strip instruction text */\n  instlen = 0;                          /* preset lengths         */\n  comment[0] = '\\0';                    /* preset null comment    */\n  for(i=0;i<255;i++)\n    instruction[i] = '\\x02';\n  instruction[0] = '\\0';                /* preset null instruction*/\n  solid_text_found = 0;                 /* preset indicator       */\n  quoted_string = 0;                    /* preset indicator       */\n  for(i=0,in=0; i<reclen; i++) {        /* copy instruction text  */\n    c = inrecord[i];                    /* get current character  */\n    instruction[in++] = c;              /* move char to instruct  */\n    if(quoted_string) {                 /* if in a string:        */\n      if(c == '\\\\') {                   /* ignore escape seq's    */\n        instruction[in++] = inrecord[++i]; /* and following char */\n        continue;                       /* and continue for loop  */\n      }\n      else\n        if(c == '\"') {                  /* if end of string       */\n          quoted_string = 0;            /* reset indicator        */\n          continue;                     /* and continue for loop  */\n        }\n    }\n    else {                              /* if not in a string:    */\n      if(c == '\"') {                    /* starting a string?     */\n        quoted_string = -1;             /* set indicator          */\n        continue;                       /*  and continue the for  */\n      }\n      else {\n        if((c == '/') && (inrecord[i+1]    == '*')) { /*comment start*/\n          in--;                         /* step back to the slash */\n          i--;                          /* step back to slash     */\n          instruction[in] = ' ';        /* clear the slash        */\n          break;                        /* break out of the for   */\n        }\n        else {\n          if(c > ' ')                   /* solid character?       */\n            solid_text_found = -1;      /* yes, indicate found    */\n        }\n      }\n    }\n  }\n  while((in > 0) && (instruction[in] == ' '))\n    in--;                               /* find end of instruction*/\n  instlen = in;                         /* set instruction length */\n  instruction[instlen] = '\\0';          /* make it a valid string */\n}\n\n/******************************************************************/\n/* initialization: open files, read first input record.           */\n/******************************************************************/\nvoid initialize(void) {\n  if((infile=fopen(\"dd:input1\",\"rb\")) == NULL) { /* open input    */\n    printf(\"Can't open the input1 file\"); /* open failed message   */\n    exit(1);                            /* terminate              */\n  }\n  if((outfile=fopen(\"dd:output1\",\"wb\")) == NULL) { /* open output */\n    printf(\"Can't open the output1 file\");\n    exit(1);\n  }\n  readrec();                            /* read first input recd  */\n}\n\n/******************************************************************/\n/* read next input file record. at eof, set morerecs switch.      */\n/******************************************************************/\nvoid readrec() {\n  if(fgets(inrecord,255,infile) == NULL) /* read input until eof  */\n    morerecs = 0;                       /* set switch at eof      */\n  reclen = strlen(inrecord) - 2;        /* get input record length*/\n}\n\n/******************************************************************/\n/* write a record to the output file                              */\n/******************************************************************/\nvoid writerec() {\n  fputs(inrecord,outfile);            /* write output record    */\n}\n\n/******************************************************************/\n/* termination: close files                                       */\n/******************************************************************/\nvoid terminate() {\n  fclose(infile);                       /* close input file       */\n  fclose(outfile);                      /* close output file      */\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "BLDFUNCD": {"ttr": 4362, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x06\\x01\\x000\\x8f\\x01\\x02\\x12\\x1f\\x175\\x01\\x03\\x00\\xcb\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2000-11-03T00:00:00", "modifydate": "2002-05-01T17:35:06", "lines": 259, "newlines": 203, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* bldfuncd.c */\n/*********************************************************************/\n/* Reads the text file containing all of sections 3.7 and 4.1 of the */\n/* C Language Runtime Reference manual and extracts function data:   */\n/* for each function, writes the function name, manual reference     */\n/* location, and short description. In most cases, at least two more */\n/* lines will follow, which contain the #define needed and the proto-*/\n/* type statement.                                                   */\n/*                                                                   */\n/* The input file is created by saving the bookmanager file for the  */\n/* C/C++ Run-Time Library Reference (EDCLB010.BOO) to the PC hard    */\n/* drive as a .txt file, then deleting everything up to Section 3.7  */\n/* and everything following the end of section 4.1, and transferring */\n/* the remainder to the mainframe.                                   */\n/*                                                                   */\n/* Input file is RECFM=VB,LRECL=255                                  */\n/* Output file is RECFM=FB,LRECL=117                                 */\n/*                                                                   */\n/* Author R Thornton Nov 2000                                        */\n/*********************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n/*********************************************************************/\n/* Defines.                                                          */\n/*********************************************************************/\n#define InRecSize 256\n#define OutRecSize 117\n\n/*********************************************************************/\n/* Function prototypes.                                              */\n/*********************************************************************/\nvoid Initialize(void);        /* Initialization. */\nint  ReadInput1(void);        /* Read next Input1 record. */\nvoid WriteOutput1(void);      /* Write output1 record. */\nint  main(void);              /* Executive control routine. */\nvoid Process(void);           /* Main processing routine */\nvoid Terminate(void);         /* Termination routine */\nvoid FindFunction(void);      /* Find next function in INPUT1 */\nvoid FindStandard(void);      /* Find the Standards header */\nvoid FindFormat(void);        /* Find the Format header */\nvoid FindHeaders(void);       /* Find and write the header/prototype */\n\n/*********************************************************************/\n/* Global data areas.                                                */\n/*********************************************************************/\nFILE *Input1, *Output1;       /* Define the files. */\nint RecSize = 1;              /* Size of last input record read */\nint NoFunction = 1;           /* Set to 0 when function found. */\nint NoStandard = 1;           /* Set to 0 when Standards found. */\nint NoFormat = -1;            /* Set to 0 when Format found */\nint NoGeneral = -1;           /* Set to 0 when Genl Descript found */\nint RecNo;                    /* Sequential record nbr w/in function */\nint sub;                      /* Subscript to next output record byte*/\nchar ManRef[7];               /* Manual Reference field */\nchar FuncDesc[65];            /* Function Description field */\nchar InRec[InRecSize];        /* Input1 record area. */\nchar OutRec[OutRecSize];      /* Output1 record area */\n/*********************************************************************/\n/* Executive control routine: Overall process control.               */\n/*********************************************************************/\nint main(void) {\n  Initialize();               /* Initialize for processing */\n  while(RecSize)              /* Perform processing routine */\n    Process();                /* Until there are no more records. */\n  Terminate();                /* Then terminate processing */\n  return(0);                  /* Relinquish control */\n}\n/*********************************************************************/\n/* Initialize for processing: open files                             */\n/*********************************************************************/\nvoid Initialize(void) {\n  Input1 = fopen(\"dd:INPUT1\", \"rb,type=record,recfm=vb,lrecl=255\");\n  if (Input1 == NULL) {\n     perror(\"Could not open INPUT1 stream\");\n     exit(8);\n  }\n  Output1= fopen(\"dd:OUTPUT1\", \"wb,type=record,recfm=fb,lrecl=117\");\n  if (Output1 == NULL) {\n     perror(\"Could not open OUTPUT1 stream\");\n     exit(8);\n  }\n  memset(&OutRec, ' ', sizeof(OutRec)); /* clear output record */\n}\n/*********************************************************************/\n/* Process the Input1 file: locate each function and write its data  */\n/* to the Output1 file.                                              */\n/*********************************************************************/\nvoid Process(void) {\n  NoFunction = -1;               /* Indicate no function found (yet)*/\n  NoStandard = -1;               /* Indicate no Standards found (yet)*/\n  NoFormat = -1;                 /* Indicate no Format found (yet) */\n  NoGeneral = -1;                /* Indicate no General found (yet) */\n  while(NoFunction && RecSize)\n      FindFunction();            /* go find the next function */\n  if(RecSize == 0) goto Exit_pr; /* exit if end of file */\n  while(NoStandard && NoFormat)\n      FindStandard();            /* go find the standards */\n  if(RecSize == 0) goto Exit_pr; /* exit if end of file */\n  memcpy(&OutRec[sub], FuncDesc, 65); /* Function Descript to output */\n  memcpy(&OutRec[OutRecSize-10], ManRef, 7); /* Manual Ref to out */\n  RecNo = 0;                     /* Reset function record count */\n  memcpy(&OutRec[OutRecSize-2], \"00\", 2); /* record count for func */\n  WriteOutput1();                /* Write an output record */\n  while(NoFormat && NoGeneral && RecSize)\n   FindFormat();                 /* Go find the Format header  */\n  if(RecSize == 0) goto Exit_pr; /* exit if end of file */\n  while(NoGeneral && RecSize)    /* if more recs and genl not found */\n   FindHeaders();                /* find, output headers, prototypes */\n  Exit_pr: return;\n}\n/*********************************************************************/\n/* Find next function in INPUT1: reads a record from INPUT1 and      */\n/* searches for the next function description. when found, saves     */\n/* the function name and manual location.                            */\n/*********************************************************************/\nvoid FindFunction(void) {\n  char HoldRec[256];                     /* Record hold area */\n  int i,j;                               /* Work fields */\n  if(ReadInput1()) {                     /* read, continue if not eof*/\n    if((memcmp(InRec, \"   3.7.\", 7) == 0) || /* Found manual ref? */\n       (memcmp(InRec, \"   4.1.\", 7) == 0)) { /* If found... */\n      memcpy(HoldRec, InRec, RecSize); /* save the record */\n      memset(ManRef, ' ', 7);           /* clear manual ref field */\n      for(i=0;i<7;i++) {                /* move manual reference */\n          if(HoldRec[i+3] == ' ') break;\n        else\n          ManRef[i] = HoldRec[i+3];\n      }\n      if(HoldRec[i+3] == ' ' && HoldRec[i+4] != ' ') { /*1 blank b4?*/\n      for(sub=0;i<RecSize;i++, sub++) {\n        if(HoldRec[i+4] == ' ') break;\n        else                       /* Move function name() */\n          if(sub < 32)\n            OutRec[sub] = HoldRec[i+4];\n          else goto Exit_ff;\n      }\n      sub++;                       /* set sub for next outrec byte */\n      if(memcmp(HoldRec+i+2, \"() -- \", 6)) goto Exit_ff;\n      memset(FuncDesc, ' ', 65); /* Clear function descript*/\n      for (i+=8,j=0;j<65;i++,j++) {    /* Move description */\n        if(i < RecSize)\n          FuncDesc[j] = HoldRec[i];\n        else break;\n      }\n      NoFunction = 0;           /* show function def found */\n      }\n    }\n  }\nExit_ff: return;\n}\n/*********************************************************************/\n/* Find the Standards header. If the Format header is found, we      */\n/* missed the Standards header. Set the appropriate indicator.       */\n/* Once the Standards header is found, read forward to get the name  */\n/* of the highest standard supported and move it into the Standards  */\n/* field of the output record.                                       */\n/*********************************************************************/\nvoid FindStandard(void) {\n  if(ReadInput1()) {                   /* Read, continue if not eof */\n   if(!(memcmp(InRec, \"   Standards\", 12))) { /* Found Standards?*/\n      NoStandard = 0;                   /* Yes, set the indicator */\n     if(!ReadInput1()) goto Exit_fs; /* Read blank line */\n     if(!ReadInput1()) goto Exit_fs; /* Read +---- line */\n     if(!ReadInput1()) goto Exit_fs; /* Read | Standards line */\n     if(!ReadInput1()) goto Exit_fs; /* Read +---- line */\n     if(!ReadInput1()) goto Exit_fs; /* Read | xxxxxx line */\n     OutRec[sub++] = '<';            /* delimit standard name */\n     memcpy(&OutRec[sub], &InRec[5], 20); /* Move standard name */\n       for(sub+=19; OutRec[sub] == ' '; sub--) { /*Fnd lst non-blnk */\n     }\n     OutRec[sub+1] = '>';            /* delimit standard name */\n     sub += 3;                       /* set next output record sub */\n   }\n   else\n      if(!(memcmp(InRec, \"   Format\", 9))) /* Found Format header?*/\n        NoFormat = 0;                /* Yes, set the indicator */\n  }\nExit_fs: return;\n}\n/*********************************************************************/\n/* Find the Format header. If the General Description header is found*/\n/* we missed the Format header. Set the appropriate indicator.       */\n/*********************************************************************/\nvoid FindFormat(void) {\n  if(ReadInput1()) {                   /* Read, continue if not eof */\n   if(!(memcmp(InRec, \"   Format\", 9))) /* Found Format header?*/\n      NoFormat = 0;                     /* Yes, set the indicator */\n   else\n      if(!(memcmp(InRec, \"   General\", 10))) /* Found Gen'l Desc hdr?*/\n        NoGeneral = 0;               /* Yes, set the indicator */\n  }\n}\n/*********************************************************************/\n/* Find the header file and prototype lines and write them to the    */\n/* output file. Stop when the General Description header is found.   */\n/*********************************************************************/\nvoid FindHeaders(void) {\n  int i,j;                                    /* Work fields */\n  if(ReadInput1()) {                   /* Read, continue if not eof */\n   if(RecSize < 15) goto Exit_fh;          /* ignore non-headers */\n   if(!(memcmp(InRec, \"   General \", 11))) { /* Found Gen'l Desc hdr?*/\n      NoGeneral = 0;                    /* Yes, set the indicator */\n      return;                           /* and return */\n   }\n   if((memcmp(InRec, \"     \", 5) == 0) &&  /* strip non-headers */\n      (InRec[5] != ' '))                        /* strip... */\n      ;\n   else goto Exit_fh;                           /* strip... */\n   for(i=5,j=5;j<65;i++,j++)            /* move in data */\n      if(i < RecSize)\n        OutRec[j] = InRec[i];\n      else break;\n   RecNo++;                       /* add 1 to function record count */\n   sprintf(&OutRec[OutRecSize-2], \"%02d\", RecNo); /* func recd cnt */\n   WriteOutput1();                      /* write the line */\n }\nExit_fh: return;\n}\n/*********************************************************************/\n/* Read next record from the Input1 file into the InRec area.        */\n/*********************************************************************/\nint  ReadInput1(void) {\n  int rc;                                /* return value for fread() */\n  rc = fread(InRec, 1, InRecSize, Input1);  /* read Input1 record */\n  if(ferror(Input1)) {                  /* I/O error occurred? */\n     perror(\"Error reading Input1\");    /* display error message */\n     exit(8);                           /* terminate in error */\n  }\n  if(feof(Input1))                      /* if end of file, */\n     RecSize = 0;                       /* set record size to 0 */\n  else\n     RecSize = rc;                      /* else set record length */\n  InRec[RecSize] = '\\x0';               /* make InRec a true string */\n  if(InRec[1] == '|') InRec[1] = ' ';   /* clear | to blank in pos 2 */\n  return(RecSize);\n}\n/*********************************************************************/\n/* Write next Output1 record from the OutRec area.                   */\n/*********************************************************************/\nvoid WriteOutput1(void) {\n  fwrite(&OutRec, 1, sizeof(OutRec), Output1);\n  if(ferror(Output1)) {/* I/O error occurred? */\n     perror(\"fwrite failed for Output1\"); /* yes, write error msg */\n     exit(8);                    /* and terminate in error */\n  }\n  memset(&OutRec, ' ', sizeof(OutRec)); /* clear output record */\n}\n/*********************************************************************/\n/* Terminate processing: close files and return control.             */\n/*********************************************************************/\nvoid Terminate(void)  {\n  fclose(Input1);                /* Close the INPUT1 file. */\n  fclose(Output1);               /* Close the OUTPUT1 file. */\n  exit(0);                       /* Relinquish control. */\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "CALENDAR": {"ttr": 4609, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00Q\\x01\\x00\"?\\x01\\x01 \\x0f\\t$\\x01+\\x01+\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-08-10T00:00:00", "modifydate": "2001-07-19T09:24:51", "lines": 299, "newlines": 299, "modlines": 0, "user": "BC0THOR"}, "text": "/*********************************************************************/\n/* calendar: provides capability to create a monthly processing date */\n/*           for the MEDSCREEN A.I. Expert System. Processing is as  */\n/*           follows:                                                */\n/*           1. Display main menu: Create New Process File           */\n/*                                 Modify Current Process File       */\n/*                                 Save Process File and Quit        */\n/*                                 Quit Without Saving Process File  */\n/*           2. If choice is to create a new process file, prompt for*/\n/*              the month and year and develop calendar values for   */\n/*              this month, and processing continues at step 6.      */\n/*           3. If choice is to modify the current file, and a file  */\n/*              exists, it is read into memory, and processing       */\n/*              continues at step 6, otherwise an error message is   */\n/*              displayed with the main menu.                        */\n/*           4. If choice is to save and quit, and the file in memory*/\n/*              is valid, it is written to disk, and the program     */\n/*              terminates normally, otherwise an error message is   */\n/*              displayed with the main menu.                        */\n/*           5. If the choice is to quit without saving, the program */\n/*              terminates normally.                                 */\n/*           6. The calendar values are displayed on the screen, and */\n/*              the operator is given an opportunity to change dates */\n/*              from process to no-process or vice-versa. When all   */\n/*              changes are complete the main menu is displayed.     */\n/*                                                                   */\n/* Author R. Thornton 4/89                                           */\n/*********************************************************************/\n/*                        *** header files ***                       */\n#include <stdio.h>\n#include <dir.h>\n#include <alloc.h>\n#include <string.h>\n\n/*                        *** function prototypes ***                */\nint update();                 /* update calendar */\nvoid quit();                  /* quit: return to DOS */\nint save();                   /* save process date file to disk */\nint read();                   /* read process date file from disk */\nint getdate();                /* get process year and month */\nvoid clrscn();                /* clear screen area */\nvoid wrtscn();                /* write screen area to display */\n\n/*                   *** global data areas ***                        */\nchar screen\u00dd24\u00a8\u00dd80\u00a8; /* main menu area                */\nint  gotfile = 0;          /* -1 = got file in memory */\nint  err = 0;              /* -1 = error found        */\nchar errmsg\u00dd80\u00a8 = \" \"; /* error message               */\n\n/*                   *** process file area ***                        */\nFILE *procdate;\nstruct\n{\n int   pr_month;        /* month */\n    int   pr_year;         /* day   */\n    int   pr_first;        /* weekday of first day of month, 0=Sunday */\n    char  pr_day\u00dd31\u00a8;      /* day indicators, p=process, n=non-process*/\n} pr_record;               /*                 blank=invalid day of mth*/\n\n/*********************************************************************/\n/*1. Display main menu, get response, and process accordingly        */\n/*********************************************************************/\nmain()\n{\n int i;\n\n while(1)\n {\n  clrscn();                      /* clear screen area */\n  strcpy(screen\u00dd23\u00a8,errmsg); /* error message to screen */\n  strcpy(errmsg,\"   \");          /* clear error message */\n        err = 0;                       /* clear error indicator */\n  strcpy(screen\u00dd1\u00a8,\"        CALENDAR MAIN MENU          \");\n  strcpy(screen\u00dd4\u00a8,\"F1 CREATE NEW PROCESS FILE          \");\n  strcpy(screen\u00dd6\u00a8,\"F2 MODIFY CURRENT PROCESS FILE      \");\n  strcpy(screen\u00dd8\u00a8,\"F3 SAVE PROCESS FILE AND QUIT       \");\n  strcpy(screen\u00dd10\u00a8,\"F4 QUIT WITHOUT SAVING PROCESS FILE\");\n  wrtscn();                      /* display menu */\n  while(getch() != 0);\n  i = getch();\n  switch(i)\n  {\n   case 59:                   /* F1: create new process file */\n    err = getdate();\n    if(err)\n     break;\n    else\n    {\n     err = update();\n     break;\n    }\n   case 60:                   /* F2: modify current process file */\n    err = read();\n    if(err)\n     break;\n    else\n    {\n     err = update();\n     break;\n    }\n   case 61:                   /* F3: save and quit */\n    err = save();\n    break;\n   case 62:                   /* F4: quit without save */\n    quit(0);\n  }\n }\n}\n/*********************************************************************/\n/*2. Create a new process file. Operator is prompted for a month and */\n/*   year, then calendar data is created for the specified month.    */\n/*********************************************************************/\nint getdate()\n{\n char ch,moyr\u00dd81\u00a8;\n int i,j;\n char months\u00dd12\u00a8\u00dd10\u00a8        = {\"January \",\"February \",\"March \",\"April \",\n        \"May      \",\"June     \",\"July     \",\"August   \",\n        \"September\",\"October  \",\"November \",\"December \"};\n gotfile = 0;\n while(gotfile == 0)\n {\n  clrscn();\n  i=0;\n  pr_record.pr_month = 0;\n  while(pr_record.pr_month == 0)\n  {\n   while(1)\n   {\n    printf(\"\\x1B\u00dd6;0f\"); /* cursor to row 6 col 0 */\n    printf(\"Please type in process month as a number between 1 and 12:\n \");\n    printf(\"\\x1B\u00dd10D\"); /* back up 10 columns */\n    for(j=0;j<3;j++)\n    {\n     moyr\u00ddj\u00a8 = getche();\n     if(moyr\u00ddj\u00a8 == '\\r')\n      break;\n    }\n    moyr\u00ddj\u00a8 = '\\0';\n    i = atoi(moyr);       /* and make it numeric */\n    if((i > 0) && (i < 13))\n     break;\n   }\n   printf(\"\\x1B\u00dd8;0f\"); /* cursor to row 8, col 0 */\n   ch = ' ';\n   printf(\"Thank you. You have selected month %02d (%s)\",i,months\u00ddi-1\u00a8);\n   printf(\"\\x1B\u00dd10;0f\"); /* cursor to row 10, col 0 */\n   printf(\"Is this correct (y/n)?\");\n   while(1)\n   {\n    ch=getch();          /* read response */\n    if((ch == 'y') || (ch == 'Y'))\n    {\n     pr_record.pr_month = i;\n     break;\n    }\n    else if((ch == 'n') || (ch == 'N'))\n    {\n     clrscn();\n     break;\n    }\n   }\n  }\n  pr_record.pr_year = 100;\n  while(pr_record.pr_year == 100)\n  {\n   while(1)\n   {\n    printf(\"\\x1B\u00dd12;0f\"); /* cursor to row 12 col 0 */\n    printf(\"Please type in process year as a number between 0 and 99:\n\");\n    printf(\"\\x1B\u00dd10D\"); /* back up 10 columns */\n    for(j=0;j<3;j++)\n    {\n     moyr\u00ddj\u00a8 = getche();\n     if(moyr\u00ddj\u00a8 == '\\r')\n      break;\n    }\n    moyr\u00ddj\u00a8 = '\\0';\n    i = atoi(moyr);       /* and make it numeric */\n    if(i < 100)\n     break;\n   }\n   printf(\"\\x1B\u00dd14;0f\"); /* cursor to row 14, col 0 */\n   ch = ' ';\n   printf(\"Thank you. You have selected year %02d\",i);\n   printf(\"\\x1B\u00dd16;0f\"); /* cursor to row 16, col 0 */\n   printf(\"Is this correct (y/n)?\");\n   while(1)\n   {\n    ch=getch();          /* read response */\n    if((ch == 'y') || (ch == 'Y'))\n    {\n     pr_record.pr_year = i;\n     gotfile = -1;              /* process file here */\n     break;\n    }\n    else if((ch == 'n') || (ch == 'N'))\n    {\n     strcpy(screen\u00dd11\u00a8,\" \");\n     strcpy(screen\u00dd13\u00a8,\" \");\n     strcpy(screen\u00dd15\u00a8,\" \");\n     break;\n    }\n   }\n  }\n }\n\n}\n/*********************************************************************/\n/*3. Read current process file. If the file exists, it is read into  */\n/*   memory, otherwise an error indicator and error message are set. */\n/*********************************************************************/\nint read()\n{\n int status=0;\n\n if((procdate=fopen(\"c:\\process.dat\",\"rb\"))==NULL)         /* open */\n  {\n  strcpy(errmsg,\"UNABLE TO OPEN C:\\PROCESS.DAT FOR INPUT\");\n  return(-1);\n  }\n status = fread(&pr_record,sizeof(pr_record),1,procdate);  /* read */\n fclose(procdate);\n if(status == 1)\n  return(0);\n else\n  {\n  strcpy(errmsg,\"ERROR READING C:\\PROCESS.DAT\");\n  return(-1);\n  }\n}\n/*********************************************************************/\n/*4. Save file. The process file record is written to disk if it     */\n/*   exists in memory.                                               */\n/*********************************************************************/\nint save()\n{\n if(gotfile)\n {\n  if((procdate=fopen(\"c:\\process.dat\",\"wb\"))==NULL)         /* open */\n   {\n   strcpy(errmsg,\"UNABLE TO OPEN C:\\PROCESS.DAT FOR OUTPUT\");\n   return(-1);\n   }\n        else\n  {\n   fwrite(&pr_record,sizeof(pr_record),1,procdate);      /* write */\n   fclose(procdate);\n   return(0);\n  }\n }\n else\n {\n  strcpy(errmsg,\"NO VALID RECORD AVAILABLE TO WRITE, USE F1 OR F2\");\n  return(-1);\n }\n}\n/*********************************************************************/\n/*5. Quit without save. The program terminates normally.             */\n/*********************************************************************/\nvoid quit()\n{\n exit(0);\n}\n/*********************************************************************/\n/*6. Display and permit updates to the calendar data.                */\n/*********************************************************************/\nint update()\n{\n  strcpy(errmsg,\"GOT TO UPDATE FUNCTION\");\n  return(-1);\n}\n/*********************************************************************/\n/*clear screen to blanks                                             */\n/*********************************************************************/\nvoid clrscn()\n{\n int i;\n\n for(i=0;i<79;i++)\n     screen\u00dd0\u00a8\u00ddi\u00a8 = ' ';            /* blank line 0, pos 1-79 */\n screen\u00dd0\u00a8\u00dd79\u00a8 = '\\0';              /* end of string in 80    */\n for(i=0;i<23;i++)\n  strcpy(screen\u00ddi+1\u00a8,screen\u00ddi\u00a8); /* copy to lines 1-24 */\n printf(\"\\x1B\u00dd2J\");                 /* clear display screen   */\n}\n/*********************************************************************/\n/*write to screen from screen line area                              */\n/*********************************************************************/\nvoid wrtscn()\n{\n int i;\n\n printf(\"\\x1B\u00dd2J\");                /* clear screen */\n for(i=0;i<24;i++)\n  printf(\"%s\\n\",screen\u00ddi\u00a8);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "CALLBIN": {"ttr": 4615, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00E\\x01\\x00\"?\\x01\\x02\\x12\\x1f\\x175\\x00\\xba\\x00\\xb7\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2000-08-10T00:00:00", "modifydate": "2002-05-01T17:35:45", "lines": 186, "newlines": 183, "modlines": 0, "user": "BC0THOR"}, "text": "/*************/\n/* callbin.c */\n/****************************************/\n/* test calls to the binsrch() function */\n/* Author R Thornton, October, 1993     */\n/****************************************/\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint binsrch(FILE *rf,\n   char *argkey,\n   int recdleng,\n   int keyleng,\n   int keyloc,\n   char *record);\n\nint main(void) {\n  FILE *rf;                     /* pointer to file to be searched    */\n  FILE *in;                     /* read the same file sequentially   */\n  char file_name[80];           /* filename of file to be searched   */\n  char *recdptr, *inrecptr;     /* pointer to record areas           */\n  int  recdleng;                /* record length                     */\n  char argkey[257];             /* argument area                     */\n  int  keyleng;                 /* key length                        */\n  int  keyloc;                  /* key location in recd (0 relative) */\n  int  result;                  /* result of binsrch                 */\n  char work[16];                /* work string                       */\n  long int total_reads = 0;     /* total of all binary search reads  */\n  int  total_records = 0;       /* total of input records            */\n  int  i;                       /* work item                         */\n  int  max_reads = 0;           /* maximum binary reads for a record */\n  float avg_reads;              /* average reads */\n\n  printf(\"\\nEnter name of file to search: \");\n  gets(file_name);\n  if((rf = fopen(file_name,\"rb\")) == NULL) {\n printf(\"\\nUnable to open that file, terminating\");\n exit(1);\n  }\n  if((in = fopen(file_name,\"rb\")) == NULL) {\n printf(\"\\nUnable to open that file, terminating\");\n exit(1);\n  }\n  recdleng = 0;\n  printf(\"\\nEnter length of each file record in bytes: \");\n  gets(work);\n  recdleng = atoi(work);\n  if(recdleng == 0) {\n printf(\"\\nInvalid record length, terminating\");\n exit(1);\n  }\n  if((recdptr = (char *)malloc(recdleng)) == 0) {\n printf(\"\\nUnable to obtain storage for search record, terminating.\");\n exit(1);\n  }\n  if((inrecptr = (char *)malloc(recdleng)) == 0) {\n printf(\"\\nUnable to obtain storage for input record, terminating.\");\n exit(1);\n  }\n  keyleng = 0;\n  printf(\"\\nEnter length of key field in bytes: \");\n  gets(work);\n  keyleng = atoi(work);\n  if((keyleng == 0) || (keyleng > recdleng)) {\n printf(\"\\nInvalid key length, terminating.\");\n exit(1);\n  }\n  if(keyleng > 256) {\n printf(\"\\nMax key length is 256 bytes, terminating.\");\n exit(1);\n  }\n  printf(\"\\nEnter offset to key in record (0 = 1st byte): \");\n  gets(work);\n  keyloc = atoi(work);\n  if((keyloc + keyleng) > recdleng) {\n    printf(\"\\nInvalid key offset: key past end of record, \"\n           \"terminating.\");\n    exit(1);\n  }\n  while(1) {\n if((fread(inrecptr,recdleng,1,in) != 1)) {  /* read next record */\n   printf(\"\\nEnd of file, %d records read\",total_records);\n   printf(\"\\n             %ld total binary search reads\",total_reads);\n   avg_reads = (float) total_reads / (float) total_records;\n   printf(\"\\n             %f average reads per record\",avg_reads);\n   printf(\"\\n             %d maximum reads for one record\",max_reads);\n   exit(0);\n }\n total_records++;                   /* add 1 to total records read */\n for(i=0;i<keyleng;i++)\n   argkey[i] = inrecptr[keyloc + i];\n argkey[i] = '\\0';\n    result = 0;\n    result = binsrch(rf,\n            argkey,\n            recdleng,\n            keyleng,\n            keyloc,\n            recdptr);\n if(result > 0) {\n   total_reads += result;    /* accumulate total binary search reads */\n   if(result > max_reads)\n  max_reads = result;\n }\n    else\n      printf(\"\\nNo record found for key %s.\",argkey);\n  }\n}\n/****************************************************************/\n/*          binsrch.c, a binary search function                 */\n/* caller supplies:                                             */\n/*    (1) a pointer to the FILE to be searched (must be OPEN).  */\n/*    (2) a pointer to the key argument used for the search.    */\n/*    (3) length of each record in the file (int).              */\n/*    (4) length of the key in the records (int).               */\n/*    (5) relative position of the key in the record (int, 0+). */\n/*    (6) a pointer to the callers record return area.          */\n/* function returns:                                            */\n/*    (1) an int whose value is a count of the number of reads  */\n/*        required to locate the the record, positive if the    */\n/*        desired record was found, negative if it was not.     */\n/*    (2) the record found, if the search was successful.       */\n/*                                                              */\n/* Author R Thornton, October, 1993                             */\n/****************************************************************/\n\nint binsrch(FILE *rf,\n   char *arg_key,\n   int recdleng,\n   int keyleng,\n   int keyloc,\n   char *record)\n{\n\n  long int file_size;             /* file length in bytes */\n  long int max_slots;             /* number records in file */\n  long int curr_slot  = 0;        /* current record slot number */\n  long int curr_offset = 0;       /* current offset increment */\n  long int file_offset;           /* computed file offset */\n  int      compare = 0;           /* current compare indicator */\n  int      result = 0;            /* result indicator */\n\n  result = 0;                     /* set up for not found */\n  if(fseek(rf,0,SEEK_END) != 0)   /* set file pointer to end of file */\n return(result);               /* terminate if error */\n  if((file_size = ftell(rf)) == -1L) /* get file size in bytes */\n return(result);               /* terminate if error */\n  max_slots = file_size / recdleng; /* compute nbr records in file */\n  curr_slot = 0;                 /* set initial slot number */\n  curr_offset = max_slots - 1;   /* set initial offset increment */\n  compare = -1;                  /* set compare for low */\n  while(curr_offset != 1) {\n curr_offset ++;              /* add 1 to insure rounding high */\n curr_offset /= 2;            /* offset / 2 (rounded high) */\n if(compare < 0) {            /* if last key read was low */\n   curr_slot += curr_offset;     /* add offset increment */\n   if(curr_slot >= max_slots) {  /* if result past end of file */\n  compare = 1;                   /* set compare to high */\n  continue;                      /* and continue to while */\n   }\n   else ;\n }\n else {                       /* if last key read was high */\n   curr_slot -= curr_offset;     /* subtract offset increment */\n   if(curr_slot < 0) {           /* if result prior to 1st slot */\n  compare = -1;                  /* set compare to low */\n  continue;                      /* and continue to while */\n   }\n   else ;\n }\n file_offset = curr_slot * recdleng;   /* compute file offset */\n if((fseek(rf,file_offset,0)) != 0)    /* position in file */\n   break;                              /* terminate if error */\n fread(record,recdleng,1,rf);          /* read the record */\n result--;                             /* count the reads */\n if((compare=memcmp(record+keyloc,arg_key,keyleng)) == 0) { /* fnd? */\n   result = 0 - result;                /*          /* make cnt plus */\n   break;                                          /* yes, quit */\n }\n  }\n  return(result);\n}\n\n\n\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "CAPACITR": {"ttr": 4619, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00@\\x01\\x00\"?\\x01\\x02\\x12\\x1f\\x18\\x11\\x00\\x17\\x00\\x11\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-08-10T00:00:00", "modifydate": "2002-05-01T18:11:40", "lines": 23, "newlines": 17, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* capacitr.c */\n/*************************************************************/\n/* compute capacitance of two plate air dielectric capacitor */\n/*************************************************************/\nmain()\n{\n float C,A,d;\n\n while(1)\n {\n  printf(\"\\nEnter area of one plate in square inches (0 = quit): \");\n  scanf(\"%f\",&A);\n  if(!A)\n   exit();\n  printf(\"\\nYou entered %f square inches\",A);\n  printf(\"\\nEnter distance between plates in inches: \");\n  scanf(\"%f\",&d);\n  printf(\"\\nYou entered %f inches\",d);\n  C = A / (4.45 * d);\n  printf(\"\\nCapacitance is C= %f pF\",C);\n }\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "CBC3GDC4": {"ttr": 4621, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00$\\x01\\x005_\\x01\\x02\\x12/\\x07D\\x00#\\x00\\x17\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-12-20T00:00:00", "modifydate": "2002-05-02T07:44:24", "lines": 35, "newlines": 23, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* cbc3gdc4.c */\n/**************************************************************/\n/* this example demonstrates the use of the decimal data type */\n/**************************************************************/\n\n#include <stdio.h>\n#include <decimal.h>\n\ndecimal(31,4) pd01 = 1234.5678d;\ndecimal(29,4) pd02 = 1234.5678d;\ndecimal(9,3) pd03 = 9876.543d;\ndecimal(9,3) pd04;\nfloat one2 = 1.2;\n\nint main(void)\n{\n  /* The results are different in the next two statements */\n  pd01 = pd01 + 1.5d;\n  pd02 = pd02 + 1.5d;\n  pd03 = pd03 + one2;\n  pd04 = (decimal(9,3))one2;\n\n  printf(\"pd01 = %D(31,4)\\n\", pd01);\n  printf(\"pd02 = %D(29,4)\\n\", pd02);\n  printf(\"pd03 = %D(9,3)\\n\", pd03);\n  printf(\"pd04 = %D(9,3)\\n\", pd04);\n\n  /* Warning: The decimal variable with size 31 should not be      */\n  /*          used in arithmetic operation.                        */\n  /*          In the above example: (31,4) + (1,0) ==> (31,3)      */\n  /*                                (29,4) + (1,0) ==> (30,4)      */\n\n  return(0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "CFUNC": {"ttr": 4865, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00W\\x01\\x01!?\\x01\\x02\\x12/\\x07I\\x009\\x00\\x19\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2001-08-01T00:00:00", "modifydate": "2002-05-02T07:49:57", "lines": 57, "newlines": 25, "modlines": 0, "user": "BC0THOR"}, "text": "/***********/\n/* cfunc.c */\n/*********************************************************************/\n/* CFUNC is a small C language program designed to test calls from   */\n/* COBOL/390 programs passing various data types and values by       */\n/* reference, and returning an integer to the caller.                */\n/*                                                                   */\n/* Since COBOL's normal passing method is via pointers to the real   */\n/* data elements, this routine expects to receive a set of pointers  */\n/* to the parameters sent.                                           */\n/*                                                                   */\n/* At present this routine works properly when statically linked with*/\n/* the calling COBOL/390 program, but abends S0C7 when called        */\n/* dynamically. I have tried using extern statements, but without    */\n/* success. I asked IBM for help using an ETR via ibmlink, but       */\n/* learned nothing new; had already tried everything suggested.save; */\n/*                                                                   */\n/* Author R Thornton August 2001                                     */\n/*********************************************************************/\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <math.h>\n\n/********************************************************************/\n/*        function prototypes                                       */\n/********************************************************************/\nint CFUNC(char*, char**, short*, float*); /* prototype for function */\n\n/********************************************************************/\n/*        CFUNC function to process data passed from COBOL/390      */\n/********************************************************************/\nint CFUNC(char *in_char,\n          char **in_string,\n          short *in_int,\n          float *in_float) {\n\n  int return_value;\n  char rcv_string[7];\n\n  printf(\"\\n----------------------------------------------------\");\n  printf(\"\\nCFUNC received character %c\",*in_char);\n  memcpy(rcv_string, in_string, 6);    /* make a C type string */\n  rcv_string[6] = '\\0';                 /* add null terminator */\n  printf(\"\\nCFUNC received string %s\",rcv_string);\n  printf(\"\\nCFUNC received int %hd\",*in_int);\n  printf(\"\\nCFUNC received float %f\",*in_float);\n\n  *in_char = 'Z';\n  memcpy(in_string, \"RETSTG\", 6);\n  *in_int = 200;\n  *in_float = 300.400;\n\n  return_value = -8;\n\n  return return_value;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CHARCNTF": {"ttr": 4867, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00V\\x01\\x00\"?\\x01\\x01 \\x0f\\t#\\x001\\x001\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-08-10T00:00:00", "modifydate": "2001-07-19T09:23:56", "lines": 49, "newlines": 49, "modlines": 0, "user": "BC0THOR"}, "text": "/* cmprfile.c */\n/* compares two files of up to 32,767 bytes */\n/* stops after 10th difference              */\n\n#include <stdio.h>\n\nmain(int argc, char *argv\u00dd\u00a8) {\n  FILE *f1,f2;\n  unsigned char c1,c2;\n  int i,j=0;\n\n\n  if(argc != 3) {                               /* arg count must = 3 */\n    printf(\"\\nFormat: C>cmprfile file1 file2\");\n    exit(0); }\n  if((f1=fopen(argv\u00dd1\u00a8,\"rb\")) == NULL) {       /* open first file */\n    printf(\"\\nCan't open the %s file.\\n\",argv\u00dd1\u00a8);\n    exit(0); }\n  if((f2=fopen(argv\u00dd2\u00a8,\"rb\")) == NULL) {       /* open second file */\n    printf(\"\\nCan't open the %s file.\\n\",argv\u00dd2\u00a8);\n    exit(0); }\n  for(i=0;i<32767;i++) {\n    c1 = getc(f1); != EOF)                    /* get character from file 1 */\n    c2 = getc(f2);                            /* get character from file 2 */\n    if((c1 == EOF) && (c2 == EOF)) {\n       printf(\"\\nCompare ended with %d mismatches.\",j);\n       break;\n    }\n    if(c1 == EOF) {\n      printf(\"\\nFile 1 ended before file 2. %d mismatches found.\",j);\n      break;\n    }\n    if(c2 == EOF) {\n      printf(\"\\nFile 2 ended before file 1. %d mismatches found.\",j);\n      break;\n    }\n    if(c1 != c2) {\n      j++;\n      if(j > 10) {\n printf(\"\\nCompare stopped after 10 mismatches found\");\n break;\n      }\n      printf(\"\\nfound mismatch at byte number %d, press any key.\",i);\n      getch();\n    }\n  }\n  fclose(f1);                                 /* close the file */\n  fclose(f2);\n  exit(0);\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "CHARDEL": {"ttr": 4869, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00C\\x01\\x00\"?\\x01\\x01 \\x0f\\t#\\x00H\\x00H\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-08-10T00:00:00", "modifydate": "2001-07-19T09:23:43", "lines": 72, "newlines": 72, "modlines": 0, "user": "BC0THOR"}, "text": "/* Define print character for Epson FX-85 printer */\n/* Patterned after program on page 108 in manual */\n/* Defines a character to print when the \"<\" key is pressed, */\n/* prints the character for inspection, and then gives the */\n/* numbers used for definition in program DOWNLOAD. */\n\n#include <stdio.h>\n\nmain()\n{\n FILE *prtptr;\n unsigned int i=0,j=0,n=0,f\u00dd9\u00a8={0,0,0,0,0,0,0,0,0};\n unsigned char ch,num\u00dd5\u00a8={\" \"};\n\n if((prtptr=fopen(\"prn\",\"w\")) == NULL)\n {\n  printf(\"\\nCan't open the printer\");\n  exit();\n }\n while(1)\n {\n  for(i=0;i<9;i++)\n  {\n       printf(\"\\nWhich rows have dots in column %1d: \",i+1);\n   ch=' ';\n         while(((ch=getche()) != '\\x0D'))\n   {\n    j = ch - 48;\n    if ((j < 1) || (j > 8))\n     printf(\"\\nIncorrect column number, use 0-9: \");\n       else\n       {\n     printf(\" \");\n     n=1;\n              f\u00ddi\u00a8+=n<<(j-1);\n    }\n   }\n  }\n  fputs(\"\\x1B:\",prtptr);    /* Copy ROM to RAM (Epson mode only) */\n  fputc('\\0',prtptr);\n  fputc('\\0',prtptr);\n  fputc('\\0',prtptr);\n  fputs(\"\\x1B%\",prtptr);    /* Select user defined set for in/out*/\n  fputc('\\x01',prtptr);\n  fputc('\\0',prtptr);\n  fputs(\"\\x1B&\",prtptr);    /* Define a user character */\n  fputc('\\0',prtptr);\n  fputs(\"\\x3C\\x3C\\x80\",prtptr);  /* 3C = \"<\" (from-to), 80 = no descender */\n  for(i=0;i<9;i++)\n     fputc(f\u00ddi\u00a8,prtptr);            /* Send column 1-9 numbers */\n  fputc('\\0',prtptr);       /* Last 2 numbers always zero */\n  fputc('\\0',prtptr);\n  fputs(\"\\nYour character in pica: < < <\",prtptr);\n  fputs(\"\\nin expanded emphasized pica: \\x1B!*< < <\",prtptr);\n  fputs(\"\\x1B!\",prtptr);    /* Reset to PICA using master select */\n  fputc('\\0',prtptr);\n  fputs(\"\\nYour data numbers: \\n\",prtptr);\n  for(i=0;i<9;i++)\n  {\n      num\u00dd0\u00a8=((f\u00ddi\u00a8)/100)+48;\n      num\u00dd1\u00a8=(((f\u00ddi\u00a8)%100)/10)+48;\n      num\u00dd2\u00a8=(((f\u00ddi\u00a8)%100)%10)+48;\n   fputs(num,prtptr);\n  }\n  fputc('\\n',prtptr);\n  printf(\"\\nDo you want to define another character? (Y/N): \");\n  ch=getche();\n  if((ch == 'n') || (ch == 'N')) break;\n }\n fputc('\\n',prtptr);\n fclose(prtptr);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "CHECK2": {"ttr": 4872, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x00\"?\\x01\\x01 \\x0f\\t#\\x00Q\\x00Q\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-08-10T00:00:00", "modifydate": "2001-07-19T09:23:31", "lines": 81, "newlines": 81, "modlines": 0, "user": "BC0THOR"}, "text": "#include <stdio.h>\n#include <conio.h>\n#include <math.h>\n#define MAX 1000.00\nvoid print_a_check(int check);\n\nint check=1, sum;\nfloat amt;\nchar c, work\u00dd16\u00a8;\nchar name\u00dd25\u00a8;\n\nvoid main()\n{\n\n clrscr();\n printf(\"\\n\\nWelcome to the all NEW check generator!\");\n printf(\"\\n\\nEnter your first name and last name please: \");\n        scanf(\"%s\",name);\n        while(1) {\n          while(1) {\n            printf(\"\\nPlease enter the amount of the check: \");\n            gets(work);\n      amt=(float)atof(work);\n     if(amt <=0) {\n       printf(\"\\nI am sorry, That is invalid\");\n              continue;\n            }\n     if(amt >=MAX) {\n       printf(\"\\nAre you sure? Press y for yes: \");\n              scanf(\"%c\",&c);\n              if((c == 'y') || (c == 'Y'))\n                break;\n              else\n                continue;\n            }\n            else\n              break;\n          }\n        print_a_check(check);\n printf(\"\\nWould you like to make another check? (Y or N)? \");\n        scanf(\"%c\",&c);\n        if((c == 'y') || (c == 'Y'))\n          continue;\n        else {\n          check++;\n          break;\n        }\n  }\n}\nvoid print_a_check(int check) {\n        double dollars, cents;\n        clrscr();\n        printf(\"\\n\\n************************************************************\n*************\");\n printf(\"\\n*\\t\\t\\t\\t\\t\\t\\t\\t%d\\t*\", check);\n printf(\"\\n*\\tNational Corp\\t\\t\\t\\tMarch 3, 1995\\t\\t*\");\n printf(\"\\n*\\tWashington DC, 00000\\t\\t\\t\\t\\t\\t*\");\n printf(\"\\n*\\t\\t\\t\\t\\t\\t\\t\\t\\t*\");\n printf(\"\\n*\\tPay to the\\t\\t\\t\\t$\\t\\t\\t*\");\n printf(\"\\n*\\torder of:__________\\t\\t\\t\\t\\t\\t*\");\n printf(\"\\n*\\t\\t\\t\\t\\t\\t\\t\\t\\t*\");\n printf(\"\\n*\\t\\t\\t\\t\\t\\t\\t\\t\\t*\");\n printf(\"\\n\\n*\\tCentral Fidelity Bank\\t\\t\\t\\t\\t\\t*\");\n printf(\"\\n*\\tRichmond Va\\t\\t\\t\\t\\t\\t\\t*\");\n printf(\"\\n*\\t\\t\\t\\t\\t\\t\\t\\t\\t*\");\n printf(\"\\n*\\tMemo____________________     Sigature________________\\t\\t*\");\n printf(\"\\n*********************************************************************\n****\");\n   gotoxy(8,20);\n printf(\"%s\", name);\n gotoxy(8,50);\n printf(\"%5.2f\", amt);\n        cents = modf((double)amt, &dollars);\n   gotoxy(12,7);\n printf(\"%d\", (int)dollars);\n        printf(\" dollars and \");\n printf(\"%d\", (int)cents);\n        printf(\" cents\");\n        gotoxy(24,1);\n        return;\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "CHILD": {"ttr": 4875, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00\\x12\\x00\\x12\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "BC0THOR"}, "text": "/* This is CHILD.C -- The child process for SPAWNFAM.C */\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid main(int argc, char *argv[]) {\n int i;\n char *path, *dummy;\n\n path = getenv(\"PATH\");\n dummy = getenv(\"DUMMY\");\n for(i=0; i<argc; i++)\n  printf(\"\\nargv[%d] %s\",i, argv[i]);\n if(path)\n   printf(\"\\nPATH = %s\", path);\n if(dummy)\n  printf(\"\\nDUMMY = %s\", dummy);\n exit(0);        /* return to parent with error code zero */\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "CHKGRADE": {"ttr": 4877, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00\\x9b\\x00\\x9b\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 155, "newlines": 155, "modlines": 0, "user": "BC0THOR"}, "text": "/* checks exam grades and writes a file of them for later analysis */\n#include <stdio.h>\n\nmain(int argc, char *argv[])\n{\nFILE *infile, *outfile;\n char innam[81],outnam[81],buffer[126],model[126];\n unsigned int ch,i,nrecs=0;\n\n    printf(\"\\nUse this program to enter test answers for the mid-term\");\n    printf(\"\\nexam. First, any existing input file is copied to the\");\n    printf(\"\\noutput file. (If the input and output files are not given\");\n    printf(\"\\non the command line, you will be prompted). Next, new data\");\n    printf(\"\\nwill be added to the output file: for each student, you\");\n    printf(\"\\nwill be prompted for the name, then the grades. As each\");\n    printf(\"\\nis entered, you will hear a beep if it is incorrect, and\");\n    printf(\"\\nthe correct answer will be shown. When all grades have \");\n    printf(\"\\nbeen entered, an output file record is written. To correct\");\n    printf(\"\\nthe last grade entered, press the del key, otherwise only\");\n    printf(\"\\nthe letters A-D are valid during grade entry. To terminate\");\n    printf(\"\\nthe program at any time, press F5.\");\n    while(1)\n    {\n        printf(\"\\n\\n Press RETURN to continue, or F5 to abort.\");\n        ch=getch();\n\n\n  if(ch == 0)\n  {\n   ch=getch();    /* read second part of extended key code */\n   if(ch == 63)\n    exit();\n  }\n  else\n   if(ch == '\\r')      /* carriage return */\n    break;\n }\n if(argc == 3)\n {\n  strcpy(&innam,argv[1]);\n  strcpy(&outnam,argv[2]);\n }\n else\n {\n  printf(\"\\nEnter input file spec or \\\"new\\\" if first time: \");\n  scanf(\"%s\",innam);\n  printf(\"\\nEnter output file spec: \");\n  scanf(\"%s\",outnam);\n }\n if(strcmp(innam,\"new\"))\n  if((infile=fopen(innam,\"rb\")) == NULL)\n  {\n   printf(\"Can't open file %s.\",innam);\n   exit();\n  }\n if((outfile=fopen(outnam,\"wb\")) == NULL)\n {\n  printf(\"Can't open file %s.\",outnam);\n  exit();\n }\n if(strcmp(innam,\"new\"))\n {\n  while(fread(buffer,126,1,infile) == 1)\n  {\n   if(!nrecs++)\n    strcpy(model,buffer);\n  }\n  fclose(infile);\n }\n while(1)\n {\n  for(i=0;i<126;i++)\n   buffer[i]=' ';\n  printf(\"\\x1B[2J\");                 /* clear screen */\n        if(!nrecs)\n   printf(\"\\nEnter \\\"model\\\" to identify grade model: \");\n  else\n   printf(\"\\nEnter student's name: \");\n  printf(\", then RETURN\");\n  printf(\"\\x7\");                   /* bell */\n  i=0;\n     while(((ch=getch()) != 13) && (i < 25))\n     {\n   if(ch == 0)\n    if((ch=getch()) == 63)            /* F5 */\n     exit();\n    else\n     if((ch == 83) && (i > 0))     /* DEL */\n     {\n      i--;\n      printf(\"\\x1B[D \\x1B[D\"); /* erase byte on screen */\n     }\n   else\n   {\n          if((ch >= 'a') && (ch <= 'z'))\n     ch -= 32;\n    if(((ch >= 'A') && (ch <= 'Z')) || (ch == ' ') || (ch == ','))\n    {\n     printf(\"%c\",ch);\n              buffer[i++]=ch;\n    }\n   }\n  }\n  i=25;\n     while(i < 125)\n     {\n   printf(\"\\x1B[4;1f\");             /* cursor to row 4 col 1 */\n   printf(\"Enter A, B, C, or D as answer for question %2d: \",i-24);\n   printf(\"\\x7\");                   /* bell */\n   if((ch=getch()) == 0)\n    if((ch=getch()) == 63)            /* F5 */\n     exit();\n    else\n     if((ch == 83) && (i > 25))    /* DEL */\n     {\n      i--;\n      printf(\"\\x1B[D \\x1B[D\"); /* erase byte on screen */\n     }\n   else\n   {\n          if((ch >= 'a') && (ch <= 'd'))\n     ch -= 32;\n    if((ch >= 'A') && (ch <= 'D'))\n    {\n     printf(\"%c\",ch);\n     buffer[i]=ch;\n    }\n    else\n     printf(\"\\x7\");                   /* ring bell */\n    if(!nrecs)\n     i++;\n    else\n    {\n     if(model[i] == buffer[i])\n      i++;\n     else\n     {\n      printf(\"\\x1B[7;1f\");            /* to row 7 col 1 */\n      printf(\"\\x7\");                  /* ring bell */\n      printf(\"Correct answer is %c\",model[i]);\n      printf(\"Press RETURN to continue\");\n      while((ch=getch()) != '\\r');\n      printf(\"\\x1B[7;1f\");\n      printf(\"\\x1B[K\\n\\x1B[K\");        /* clear lines 7-8 */\n     }\n    }\n   }\n  }\n  buffer[i] = '\\r';\n  if(!nrecs++)\n   memmove(model,buffer,126);\n  fwrite(buffer,126,1,outfile);\n    }\n fclose(outfile);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "CHK50GRD": {"ttr": 4881, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00\\xa2\\x00\\xa2\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 162, "newlines": 162, "modlines": 0, "user": "BC0THOR"}, "text": "/* checks exam grades and writes a file of them for later analysis */\n#include <stdio.h>\n\nmain(int argc, char *argv[])\n{\nFILE *infile, *outfile;\n char innam[81],outnam[81],buffer[77],model[77];\n unsigned int ch,i,nrecs=0;\n\n    printf(\"\\nUse this program to enter test answers for the mid-term\");\n    printf(\"\\nexam. First, any existing input file is copied to the\");\n    printf(\"\\noutput file. (If the input and output files are not given\");\n    printf(\"\\non the command line, you will be prompted). Next, new data\");\n    printf(\"\\nwill be added to the output file: for each student, you\");\n    printf(\"\\nwill be prompted for the name, then the grades. As each\");\n    printf(\"\\nis entered, you will hear a beep if it is incorrect, and\");\n    printf(\"\\nthe correct answer will be shown. When all grades have \");\n    printf(\"\\nbeen entered, an output file record is written. To correct\");\n    printf(\"\\nthe last grade entered, press the del key, otherwise only\");\n    printf(\"\\nthe letters A-D are valid during grade entry. To terminate\");\n    printf(\"\\nthe program at any time, press F5.\");\n    while(1)\n    {\n        printf(\"\\n\\n Press RETURN to continue, or F5 to abort.\");\n        ch=getch();\n\n\n  if(ch == 0)\n  {\n   ch=getch();    /* read second part of extended key code */\n   if(ch == 63)\n    exit();\n  }\n  else\n   if(ch == '\\r')      /* carriage return */\n    break;\n }\n if(argc == 3)\n {\n  strcpy(&innam,argv[1]);\n  strcpy(&outnam,argv[2]);\n }\n else\n {\n  printf(\"\\nEnter input file spec or \\\"new\\\" if first time: \");\n  scanf(\"%s\",innam);\n  printf(\"\\nEnter output file spec: \");\n  scanf(\"%s\",outnam);\n }\n if(strcmp(innam,\"new\"))\n  if((infile=fopen(innam,\"rb\")) == NULL)\n  {\n   printf(\"Can't open file %s.\",innam);\n   exit();\n  }\n if((outfile=fopen(outnam,\"wb\")) == NULL)\n {\n  printf(\"Can't open file %s.\",outnam);\n  exit();\n }\n if(strcmp(innam,\"new\"))\n {\n  while(fread(buffer,77,1,infile) == 1)\n  {\n   if(!nrecs++)\n    strcpy(model,buffer);\n   fwrite(buffer,77,1,outfile);\n  }\n  fclose(infile);\n }\n while(1)\n {\n  for(i=0;i<77;i++)\n   buffer[i]=' ';\n  printf(\"\\x1B[2J\");                 /* clear screen */\n        if(!nrecs)\n   printf(\"\\nEnter \\\"MODEL\\\" to identify grade model: \");\n  else\n   printf(\"\\nEnter student's name, then RETURN (or F5 to quit): \");\n  printf(\"\\x7\");                   /* bell */\n  i=0;\n     while(((ch=getch()) != 13) && (i < 25))\n     {\n   if(ch == 0)\n    if((ch=getch()) == 63)            /* F5 */\n     exit();\n    else\n     if((ch == 83) && (i > 0))     /* DEL */\n     {\n      i--;\n      printf(\"\\x1B[D \\x1B[D\"); /* erase byte on screen */\n     }\n     else\n      ;\n   else\n   {\n          if((ch >= 'a') && (ch <= 'z'))\n     ch -= 32;\n    if(((ch >= 'A') && (ch <= 'Z')) || (ch == ' ') || (ch == ','))\n    {\n     printf(\"%c\",ch);\n              buffer[i++]=ch;\n    }\n   }\n  }\n  i=25;\n  while(i < 75)\n     {\n   printf(\"\\x1B[4;1f\");             /* cursor to row 4 col 1 */\n   printf(\"Enter A, B, C, or D as answer for question %2d: \",i-24);\n   if((ch=getch()) == 0)\n    if((ch=getch()) == 63)            /* F5 */\n     exit();\n    else\n     if((ch == 83) && (i > 25))    /* DEL */\n     {\n      i--;\n     }\n     else\n      ;\n   else\n   {\n          if((ch >= 'a') && (ch <= 'd'))\n     ch -= 32;\n    if(((ch >= 'A') && (ch <= 'D')) || (ch == ' '))\n    {\n     printf(\"%c\",ch);\n     buffer[i]=ch;\n    }\n    else\n    {\n     i--;\n     printf(\"\\x1B[D \\x1B[D\"); /* erase byte on screen */\n     printf(\"\\x7\");                   /* ring bell */\n    }\n    if(!nrecs)\n     i++;\n    else\n    {\n     if(model[i] == buffer[i])\n      i++;\n     else\n     {\n      printf(\"\\x1B[7;1f\");            /* to row 7 col 1 */\n      printf(\"\\x7\");                  /* ring bell */\n      printf(\"Correct answer is %c\",model[i++]);\n      printf(\"\\nPress RETURN to continue\");\n      while((ch=getch()) != '\\r');\n      printf(\"\\x1B[7;1f\");\n      printf(\"\\x1B[K\\n\\x1B[K\");        /* clear lines 7-8 */\n     }\n    }\n   }\n  }\n  buffer[i] = '\\r';\n  buffer[i] = '\\n';\n  if(!nrecs++)\n   memmove(model,buffer,77);\n  fwrite(buffer,77,1,outfile);\n    }\n fclose(outfile);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "CIRCLE": {"ttr": 5124, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00D\\x01\\x02\\x11\\x9f\\x01\\x02\\x12/\\x10\\x00\\x009\\x007\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-02T10:00:44", "lines": 57, "newlines": 55, "modlines": 0, "user": "BC0THOR"}, "text": "/************/\n/* circle.c */\n/*********************************************************************/\n/* displays the area, circumference, and volume of a circle when the */\n/* radius is supplied.                                               */\n/*********************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define PI 3.14159\n\nfloat area, crcmfrnc, volume;\n\nfloat calcarea(double radius);\nfloat calcircf(double diameter);\nfloat calcvol(double radius);\n\nmain(int argc, char *argv[]) {\n  double radius;\n\n  if(argc != 2) {\n printf(\"Usage is: circle radius\\n\");\n exit(1);\n  }\n  radius = atof(argv[1]);\n\n  area = calcarea(radius);\n  crcmfrnc = calcircf(2 * radius);\n  volume = calcvol(radius);\n\n  printf(\"The radius given is %f\\n\",radius);\n  printf(\"Area is %f\\n\",area);\n  printf(\"Circumference is %f\\n\",crcmfrnc);\n  printf(\"Volume is %f\\n\",volume);\n}\n\n/* function to calculate area of a circle given the radius */\nfloat calcarea(double rad) {\n  float answer;\n\n  answer = PI * rad * rad;\n  return(answer);\n}\n\n/*function to calculate circumference of a circle given the diameter */\nfloat calcircf(double diameter) {\n return(PI * diameter);\n}\n\n/* function to calculate volume of a sphere given the radius */\nfloat calcvol(double r) {\n  float rcubed, vol;\n\n  rcubed = r * r * r;\n  vol = (4 * rcubed) / 3;\n  return(vol);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "CMPRFILE": {"ttr": 5126, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00I\\x01\\x02\\x11\\x9f\\x01\\x02\\x12/\\x12\\x11\\x00N\\x006\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-02T12:11:49", "lines": 78, "newlines": 54, "modlines": 0, "user": "BC0THOR"}, "text": "/* cmprfile.c */\n/********************************************/\n/* Compares two simple sequential files.    */\n/* Stops after 10th difference              */\n/*                                          */\n/* Fully qualified dsnames are provided in  */\n/* the parm field of the JCL EXEC statement.*/\n/*                                          */\n/* Since the fopen() function works like the*/\n/* TSO dsname references, the dsname must be*/\n/* enclosed in apostrophes, else it is pre- */\n/* fixed with USERID as the high level node.*/\n/* I couldn't figure out how to pass the    */\n/* apostrophes via the PARM parameter, so   */\n/* included code to add the apostrophes.    */\n/********************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint  main(int argc, char *argv[]) {\n  FILE *f1,*f2;\n  int c1,c2;\n  int i,j=0,l;\n  char dsname1[47],dsname2[47];\n\n  printf(\"\\nEXEC statement PARM fields entered:\");\n  for(i=0;i<argc;i++) {\n    l = strlen(argv[i]);\n    printf(\"\\nParm %d (%d bytes): %s\",i,l,argv[i]);}\n  if(argc != 4) {                              /* arg count must = 4 */\n    printf(\"\\nExpected two dsnames enclosed in double quotes.\");\n    exit(8); }\n  dsname1[0] = dsname2[0] = 0;\n  strcat(dsname1,\"'\");           /*start dsname with apostrophe */\n  strcat(dsname1,argv[1]);       /*add dsname from parm on exec */\n  strcat(dsname1,\"'\");           /*and end with apostrophe      */\n  strcat(dsname2,\"'\");           /*start dsname with apostrophe */\n  strcat(dsname2,argv[3]);       /*add dsname from parm on exec */\n  strcat(dsname2,\"'\");           /*and end with apostrophe      */\n  if((f1=fopen(dsname1,\"rb\")) == NULL) {       /* open first file */\n    printf(\"\\nCan't open the %s file.\\n\",dsname1);\n    exit(8); }\n  if((f2=fopen(dsname2,\"rb\")) == NULL) {       /* open second file */\n    printf(\"\\nCan't open the %s file.\\n\",dsname2);\n    exit(8); }\n\n  for(i=0;i<32767;i++) {\n    c1 = getc(f1);                      /* get character from file 1 */\n    c2 = getc(f2);                      /* get character from file 2 */\n    if((c1 == EOF) && (c2 == EOF)) {\n       printf(\"\\nCompare ended with %d mismatches.\",j);\n       break;\n    }\n    if(c1 == EOF) {\n      printf(\"\\nFile 1 ended before file 2. %d mismatches found.\",j);\n      break;\n    }\n    if(c2 == EOF) {\n      printf(\"\\nFile 2 ended before file 1. %d mismatches found.\",j);\n      break;\n    }\n    if(c1 != c2) {\n      j++;\n      if(j > 10) {\n printf(\"\\nCompare stopped after 10 mismatches found\");\n break;\n      }\n      printf(\"\\nfound mismatch at byte number %d, press any key.\",i);\n      getchar();\n    }\n  }\n  printf(\"\\nCompare stopped after %d bytes with %d mismatches.\",i,j);\n  fclose(f1);                                 /* close the file */\n  fclose(f2);\n  exit(0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "COILIND": {"ttr": 5129, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "BC0THOR"}, "text": "/* Compute month and day of easter for any year 1584-2900 */\nmain()\n{\n int a,b,c,d,e,f,g,h,i,k,l,m,n,p,year,month,day;\n\n while(1)\n {\n  printf(\"\\nEnter four digit year > 1583 (0 = quit): \");\n  scanf(\"%d\",&year);\n  if(!year)\n   exit();\n  a = year % 19;\n  b = year / 100;\n  c = year % 100;\n  d = b / 4;\n  e = b % 4;\n  f = (b+8) / 25;\n  g = (b - f + 1) / 3;\n  h = (19 * a + b - d - g + 15) % 30;\n  i = c / 4;\n  k = c % 4;\n  l = (32 + 2 * e + 2 * i - h - k) % 7;\n  m = (a + 11 * h + 22 * l) / 451;\n  n = (h + l - 7 * m + 114) / 31;\n  p = (h + l - 7 * m + 114) % 31;\n  month = n;\n  day = p + 1;\n  printf(\"\\nEaster will fall on day %d of month %d in the year %d\",day,month,yea\nr);\n }\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "COMADLM": {"ttr": 5131, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x03/\\x03/\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 815, "newlines": 815, "modlines": 0, "user": "BC0THOR"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "COMPLEX": {"ttr": 5386, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00.\\x00.\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "BC0THOR"}, "text": "main() {\n  int i=2, j=3;\n  struct year_entry2 {\n char jan1_day;\n char leap_year_ind;\n struct {\n   char holiday_type;\n   char holiday_mmdd[5];\n } holiday_table[7];\n  };\n  static struct year_entry2 yeartbl2[14] = {\n {'6','0',{{'1',\"0102\"},{'4',\"0529\"},{'5',\"0704\"},{'6',\"0904\"},\n     {'7',\"1123\"},{'8',\"1124\"},{'9',\"1225\"}}},\n {'0','0',{{'1',\"0101\"},{'4',\"0528\"},{'5',\"0704\"},{'6',\"0903\"},\n     {'7',\"1122\"},{'8',\"1123\"},{'9',\"1225\"}}},\n {'1','0',{{'1',\"0101\"},{'4',\"0527\"},{'5',\"0704\"},{'6',\"0902\"},\n     {'7',\"1128\"},{'8',\"1129\"},{'9',\"1225\"}}},\n {'2','0',{{'1',\"0101\"},{'4',\"0526\"},{'5',\"0704\"},{'6',\"0901\"},\n     {'7',\"1127\"},{'8',\"1128\"},{'9',\"1225\"}}},\n {'3','0',{{'1',\"0101\"},{'4',\"0525\"},{'5',\"0703\"},{'6',\"0907\"},\n     {'7',\"1126\"},{'8',\"1127\"},{'9',\"1225\"}}},\n {'4','0',{{'1',\"0101\"},{'4',\"0531\"},{'5',\"0705\"},{'6',\"0906\"},\n     {'7',\"1125\"},{'8',\"1126\"},{'9',\"1224\"}}},\n {'5','0',{{'0',\"0000\"},{'4',\"0530\"},{'5',\"0704\"},{'6',\"0905\"},\n     {'7',\"1124\"},{'8',\"1125\"},{'9',\"1226\"}}},\n {'6','1',{{'1',\"0102\"},{'4',\"0528\"},{'5',\"0704\"},{'6',\"0903\"},\n     {'7',\"1122\"},{'8',\"1123\"},{'9',\"1225\"}}},\n {'0','1',{{'1',\"0101\"},{'4',\"0527\"},{'5',\"0704\"},{'6',\"0902\"},\n     {'7',\"1128\"},{'8',\"1129\"},{'9',\"1225\"}}},\n {'1','1',{{'1',\"0101\"},{'4',\"0526\"},{'5',\"0704\"},{'6',\"0901\"},\n     {'7',\"1127\"},{'8',\"1128\"},{'9',\"1225\"}}},\n {'2','1',{{'1',\"0101\"},{'4',\"0525\"},{'5',\"0703\"},{'6',\"0907\"},\n     {'7',\"1126\"},{'8',\"1127\"},{'9',\"1225\"}}},\n {'3','1',{{'1',\"0101\"},{'4',\"0531\"},{'5',\"0705\"},{'6',\"0906\"},\n     {'7',\"1125\"},{'8',\"1126\"},{'9',\"1224\"}}},\n {'4','1',{{'1',\"0101\"},{'4',\"0530\"},{'5',\"0704\"},{'6',\"0905\"},\n     {'7',\"1124\"},{'8',\"1125\"},{'9',\"1226\"}}},\n {'5','1',{{'1',\"0000\"},{'4',\"0529\"},{'5',\"0704\"},{'6',\"0904\"},\n     {'7',\"1123\"},{'8',\"1124\"},{'9',\"1225\"}}}\n };\n  printf(\"\\nFor year type %2d: jan1_day=%c, leap_year_ind=%c\",\n   i, yeartbl2[i].jan1_day, yeartbl2[i].leap_year_ind);\n  printf(\"\\nFor holiday number %1d: holiday_type=%c, holiday_mmdd=%s\",\n   j, yeartbl2[i].holiday_table[j].holiday_type,\n      yeartbl2[i].holiday_table[j].holiday_mmdd);\n} /* end main */\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "CONV": {"ttr": 5388, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x17\\x01\\x02\\x11\\x9f\\x01\\x02\\x12/\\x12&\\x00\\x13\\x00\\x16\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-02T12:26:17", "lines": 19, "newlines": 22, "modlines": 0, "user": "BC0THOR"}, "text": "/***********************************************************/\n/* uses the atol() function to convert a string of decimal */\n/* digits to a long.                                       */\n/***********************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n\nmain(int argc, char **argv) {\n  long value;\n  char con50k[7] = \"050000\";\n\n  if(argc<2)\n    printf(\"\\nUsage: conv string_of_decimal_digits\\n\");\n  else {\n    value = atol(argv[1]);\n    printf(\"\\nValue entered is: %ld\\n\",value);\n    value = atol(con50k);\n    printf(\"\\ncon50k is: %ld\\n\",value); }\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "COPYCNT": {"ttr": 5633, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x01f\\x01f\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 358, "newlines": 358, "modlines": 0, "user": "BC0THOR"}, "text": "/*******************************************************************/\n/*                      **** copysubr.c ****                       */\n/*                                                                 */\n/* copies every 50th record from the original subscriber file     */\n/* downloaded to the IVRUPROD machine from the mainframe in order  */\n/* to create a manageable file for use in testing (about 500       */\n/* k-bytes). The output file will contain at least the first input */\n/* record and the last two records (trailer record and \\f\\n record)*/\n/* and the trailer record will be modified to contain the correct  */\n/* record count for the test file.                                 */\n/*                                                                 */\n/* Author R Thornton February 1994                                 */\n/*******************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid initialize(int argc, char *argv[]]); /* initialization function */\nvoid mainline(void);                  /* mainline function */\nvoid terminate(void);                 /* termination function */\nvoid readrec(void);                   /* read next input file record */\nvoid writerec(void);                  /* write record to output file */\nvoid printline(void);                 /* print a line to report file */\nint edit(char output[], char pattern[], char number[]); /* edit func */\n\nFILE *infile, *outfile, *prtfile;     /* file handle pointers */\nchar innam[81];                       /* input file name */\nchar outnam[81];                      /* output file name */\nchar prtnam[81];                      /* print file name */\n\nchar prtline[135];                    /* print line buffer */\nchar inrecord[256];                   /* input file record area */\nchar outrecord[256];                  /* output file record area */\n\nint i;                                /* general purpose int */\nchar number[32];                      /* ascii numbers for edit() */\nint morerecs = -1;                    /* input end-of-file switch */\nlong incount = 0;                     /* input record counter */\nlong outcount = 0;                    /* output record counter */\nint fiftycnt = 0;                     /* used to count 50 records */\n\n\nvoid main(int argc, char *argv[])\n{\n initialize(argc, argv);       /* open files */\n while(morerecs)               /* perform mainline until */\n  mainline();               /* no more records */\n terminate();                  /* close files */\n exit(0);                      /* quit */\n}\n/**********************************************************************/\n/* mainline function: process input file until no more records.       */\n/**********************************************************************/\nvoid mainline(void)\n{\n strcpy(prtline,inrecord);     /* move input record to print */\n printline();                       /* and print it */\n strcpy(outrecord,inrecord);   /* move input record to output */\n writerec();                   /* write an output record */\n readrec();                    /* read next input record */\n}\n/**********************************************************************/\n/* initialization: open files, read first input record.               */\n/**********************************************************************/\nvoid initialize(int argc, char *argv[])\n{\n  if(argc == 4) {\n    strcpy(&innam,argv[1]);\n    strcpy(&outnam,argv[2]);\n strcpy(&prtnam,argv[3]);\n    }\n    else {\n   printf(\"\\nUsage:  \");\n      gets(innam);\n      printf(\"\\nEnter output file spec: \");\n      gets(outnam);\n      printf(\"\\nEnter output file spec (or prn): \");\n      gets(prtnam);\n    }\n  if((infile=fopen(innam,\"rb\")) == NULL) { /* open input */\n    printf(\"Can't open file %s.\",innam);\n    exit(1);\n  }\n  if((outfile=fopen(outnam,\"wb\")) == NULL) { /* open output */\n    printf(\"Can't open file %s.\",outnam);\n    exit(1);\n  }\n  if((prtfile=fopen(prtnam,\"w\"))==NULL) { /* open print file */\n    printf(\"\\nCan't open the printer file.\");\n    exit(1);\n  }\n  h1ptr = (char *)&header1;           /* point to header1 line */\n  for(i=0;i<133;i++)                  /* clear header line */\n h1ptr[i] = ' ';\n  header1.hdr_skip = '\\f';            /* form feed to header line */\n  memcpy(header1.title_line,\"SKELETON REPORT TITLE\",21);\n  timezone = 5 * 60 * 60;               /* set local time for e.s.t */\n  daylight = -1;                        /* indicate daylit sav time */\n  time(&seconds);                       /* time in secs */\n  t = localtime(&seconds);              /* local time to tm struct */\n  sprintf(header1.hdr_date,\"%2d\\/%2d\\/%2d\",t->tm_mon,t->tm_mday,t->tm_year);\n  header1.hdr_date[8] = ' ';             /* clear terminating null */\n  memcpy(header1.page_lit,\"PAGE \",5);    /* PAGE literal to header */\n  prtline[133] = '\\0';                   /* terminal null to prt line */\n  headings();            /* write first heading */\n  readrec();             /* read first input file record */\n}\n/**********************************************************************/\n/* read next input file record. at end of file, set morerecs switch.  */\n/**********************************************************************/\nvoid readrec() {\n  if(fgets(inrecord,255,infile) == NULL) /* read input until eof */\n    morerecs = 0;                        /* set switch at end of file */\n  if(morerecs)\n    incount++;                           /* add 1 to records read */\n}\n/**********************************************************************/\n/* write a record to the output file                                  */\n/**********************************************************************/\nvoid writerec() {\n  fputs(outrecord,outfile);        /* write output record */\n  outcount++;                      /* add 1 to records written */\n}\n/**********************************************************************/\n/* write a line to the printer                                        */\n/**********************************************************************/\nvoid printline() {\n  prtline[133] = '\\n';           /* terminal newline to print line */\n  prtline[134] = '\\0';           /* terminal null to print line */\n  fputs(prtline,prtfile);        /* write print line */\n  linecnt++;                     /* add 1 to line counter */\n  if(linecnt > 56)               /* check for end of page */\n    headings();                  /* if eop, write header */\n  else\n    for(i=0;i<133;i++)\n      prtline[i] = ' ';          /* clear print line to spaces. */\n}\n/**********************************************************************/\n/* write a report heading                                             */\n/**********************************************************************/\nvoid headings() {\n  linecnt = 0;                        /* clear line counter */\n  pagecnt++;                          /* add 1 to page counter */\n  sprintf(number,\"%d\",pagecnt);           /* convert to printable nbr */\n  edit(header1.page_nbr,\"zz,zz9\",number); /* page nbr to header line */\n  header1.newline = '\\n';                /* terminal newline to header */\n  header1.null_byte = '\\0';              /* terminal null to header */\n  fputs((char *)&header1,prtfile);        /* write header line */\n  for(i=0;i<133;i++)\n    prtline[i] = ' ';                 /* clear print line */\n  prtline[133] = '\\n';           /* terminal newline to print line */\n  prtline[134] = '\\0';           /* terminal null to print line */\n  fputs(prtline,prtfile);             /* blank line after heading */\n}\n/**********************************************************************/\n/* The edit function provides numeric report editing, including       */\n/* leading zero suppression, check protection, floating $, leading    */\n/* or trailing minus sign, insertion of commas, decimal points and    */\n/* other non-numeric fields. The first parameter is the address of    */\n/* the edited output, whose size will be the same as the pattern.     */\n/* The second parameter is the editing pattern, which must be a true  */\n/* null-terminated string containing the edit pattern. The third      */\n/* is the number to be edited, a null-terminated string containing    */\n/* only digits 0-9 except the first position, which is a -, if the    */\n/* number is negative. The pattern may be up to 64 characters, and    */\n/* the number to be edited may contain up to 32 characters. The       */\n/* number may not contain more significant digits than there are      */\n/* digit select characters in the pattern. If there are more digits   */\n/* selected by the pattern than there are in the number, leading      */\n/* zeros will be assumed. In the pattern, the first character may     */\n/* be:      $ (floating dollar sign)                                  */\n/*          * (check protection)                                      */\n/*          - (floating minus sign)                                   */\n/* The body of the edit pattern will be composed of digit select      */\n/* characters (z and 9) and other characters, handled as follows:     */\n/*          z (zero suppression output is a blank in this position    */\n/*             until significance is set by receipt of a significant  */\n/*             digit or a 9 in the pattern. After significance is     */\n/*             set, output is a digit from the number.)               */\n/*          9 (output is a digit from the number and significance     */\n/*             is set, even if the digit is a leading zero.)          */\n/*        other characters in the pattern will be output as-is after  */\n/*             significance is set, but will be output as blanks      */\n/*             before significance is set.                            */\n/* Characters in the pattern following the last digit select will     */\n/* be output as-is if the number is negative, otherwise output will   */\n/* be blanks for these pattern positions.                             */\n/*                                                                    */\n/* When * check protection is selected, output will be *, rather      */\n/* than blanks as mentioned above.                                    */\n/*                                                                    */\n/* An integer is returned to indicate success or errors:              */\n/*                 0 = successful edit                                */\n/*                 1 = pattern too long (over 64 characters)          */\n/*                 2 = too many digits selected (over 32)             */\n/*                 3 = no output digits selected in pattern           */\n/*                 4 = number contains non-numeric data               */\n/*                 5 = number has more digits than the pattern        */\n/*                                                                    */\n/* Examples:                            nbr=             outf=        */\n/*    err=edit(outf,\"zz,zz9.99-\",nbr);  0                     0.00    */\n/*                                      123                   1.23    */\n/*                                      562983            5,629.83    */\n/*                                      -4675                46.75-   */\n/*    err=edit(outf,\"$,$$$.$$\",nbr);    0                             */\n/*                                      123                  $1.23    */\n/*                                      562983           $5,629.83    */\n/*                                      -4675               $46.75    */\n/*    err=edit(outf,\"***.**\",nbr);      0                             */\n/*                                      123                 **1.23    */\n/*                                      562983   err = 5              */\n/*                                      -4675               *46.75    */\n/*    err=edit(outf,\"--,--9.99\",nbr);   0                     0.00    */\n/*                                      123                   1.23    */\n/*                                      562983            5,629.83    */\n/*                                      -46.75              -46.75    */\n/*                                                                    */\n/* Author R Thornton April 1989                                       */\n/**********************************************************************/\n/**/\nint edit(char output[], char pattern[], char number[]) {\n  char float_val = ' ';\n  char fill_val = ' ';\n  char sign_val = ' ';\n  int signif = 0;\n  int psize = 0;\n  int pdig = 0;\n  int plast = 0;\n  int ndig = 0;\n  char nbr[33];\n  char ch= ' ';\n  int po=0;\n  int n=0;\n\n/****************************************************************/\n/* examine pattern: set up float and fill, count size and digits*/\n/****************************************************************/\n  if(((ch=pattern[0]) == '$') || (ch == '*') || (ch == '-'))\n    float_val = ch;\n  if(ch == '*')\n    fill_val = '*';\n  while((ch=pattern[po]) != '\\0') {\n    if((ch == 'z') || (ch == '9')) {\n      pdig++;\n      plast = po;\n    }\n    psize++;\n    po++;\n  }\n  if(psize > 63)\n    return(1);\n  if(pdig > 32)\n    return(2);\n  if(!pdig)\n    return(3);\n/****************************************************************/\n/* examine number: set up sign, count digits, check numeric.    */\n/* set error if more digits than pattern, move right justified  */\n/****************************************************************/\n  if(number[0] == '-') {\n    sign_val = '-';\n    n = 1;\n  }\n  while((ch=number[n]) != '\\0') {\n    if((ch < '0') || (ch > '9'))\n      return(4);\n    ndig++;\n    n++;\n  }\n  if(ndig > pdig)\n    return(5);\n  for(po=0;po<(pdig-ndig);po++)\n    nbr[po] = '0';\n  if(sign_val == ' ')\n    n = 0;\n  else\n    n=1;\n  for(;po<pdig;po++,n++)\n    nbr[po] = number[n];\n/****************************************************************/\n/* scan across the pattern, setting the corresponding output    */\n/* byte from pattern, fill, or amt depending on the pattern     */\n/* character and state of significance.                         */\n/****************************************************************/\n  if(float_val != ' ') {\n    output[0] = ' ';\n    po = 1;\n  }\n  else\n    po = 0;\n  n = 0;\n  while((po <= plast)) {\n    ch = pattern[po];\n    if(ch == 'z') {\n      if(signif) {\n        output[po] = nbr[n];\n        n++;\n      }\n      else {\n        if(nbr[n] == '0') {\n          output[po] = fill_val;\n          n++;\n        }\n        else {\n          output[po] = nbr[n];\n          signif = -1;\n          n++;\n          if(float_val == ' ')\n            ;\n          else\n            if((float_val == '$') || (sign_val == '-'))\n              output[po-1] = float_val;\n        }\n      }\n    }\n    else if(ch == '9') {\n      output[po] = nbr[n];\n      if(!signif) {\n        signif = -1;\n        if(float_val == ' ')\n          ;\n        else\n          if((float_val == '$') || (sign_val == '-'))\n            output[po-1] = float_val;\n      }\n      n++;\n    }\n    else {\n      if(signif)\n        output[po] = pattern[po];\n      else\n        output[po] = fill_val;\n    }\n    po++;\n  }\n  while((ch=pattern[po]) != '\\0') {\n    if(sign_val == ' ')\n      output[po++] = fill_val;\n    else\n      output[po++] = pattern[po];\n  }\n  return(0);\n}\n/**********************************************************************/\n/* termination: close files                                           */\n/**********************************************************************/\nvoid terminate() {\n  sprintf(number,\"%ld\",incount);        /* convert input count to ascii */\n  edit(prtline, \"zz,zzz,zz9\", number);    /* edit number to prtline */\n  strcpy(prtline+10,\" input records read\"); /* message to prt */\n  printline();                              /* print count */\n  sprintf(number,\"%ld\",outcount);       /* convert input count to ascii */\n  edit(prtline, \"zz,zzz,zz9\", number);    /* edit number to prtline */\n  strcpy(prtline+10,\" output records written\"); /* message to prt */\n  printline();                              /* print count */\n  fclose(infile);                           /* close files */\n  fclose(outfile);\n  fclose(prtfile);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "COPYNEW": {"ttr": 5640, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00\\x98\\x00\\x98\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 152, "newlines": 152, "modlines": 0, "user": "BC0THOR"}, "text": "/*******************************************************************/\n/*                      **** copynew.c ****                        */\n/*                                                                 */\n/* copies files from a specified source path to a specified        */\n/* destination path. The source may include wildcards. Only files  */\n/* having a newer modification date are copied. When copied, the   */\n/* last modification date and time of the copied file are used for */\n/* the output file.                                                */\n/*                                                                 */\n/* Author R Thornton August 1996                                   */\n/*******************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <dir.h>\n#include <dos.h>\n#include <io.h>\n#include <fcntl.h>\n\nvoid initialize(int argc, char *argv[]]); /* initialization function */\nvoid mainline(void);                  /* mainline function */\n\nint infile, outfile;                  /* file handles */\nchar innam[81];                       /* input file name */\nchar outnam[81];                      /* output file name */\nchar inpath[65];                      /* path name for output file opens */\nchar outpath[65];                     /* path name for input file opens */\nint num_bytes;                        /* byte count for file copies */\nchar buffer[4096];                    /* buffer for file copies */\nunsigned int const BUF_SIZE = 4096;   /* buffer size constant */\nstruct ffblk ffin,ffout;              /* file directory areas */\nstruct ftime ftime;                   /* input file date/time */\n\nchar inrecord[256];                   /* input file record area */\n\nint i;                                /* general purpose int */\nint done=0;                           /* end of input indicator */\nint morerecs = -1;                    /* input end-of-file switch */\nint oldup = 0;                        /* older/duplicate files dropped */\nint overlay = 0;                      /* newer files overlaid */\nint adds = 0;                         /* files added */\nint new_output=0;                     /* new output file switch */\n\n\nvoid main(int argc, char *argv[]) {\n initialize(argc, argv);       /* initialize */\n while(!done)\n  mainline();               /* main processing */\n printf(\"\\n COPYNEW STATISTICS: \");\n printf(\"\\n %d Older/Duplicate input files ignored.\",oldup);\n printf(\"\\n %d Newer files replacing original files.\",overlay);\n printf(\"\\n %d New files added.\\n\",adds);\n exit(0);                      /* quit */\n}\n/**********************************************************************/\n/* mainline function: copy all newer files to destination.            */\n/**********************************************************************/\nvoid mainline(void) {\n\n strcpy(outpath, outnam);                     /* copy output path */\n strcat(outpath, ffin.ff_name);               /* concatenate input filename */\n new_output = findfirst(outpath,&ffout,0);    /* get output directory */\n if(new_output) {                             /* no directory, new file */\n  strcpy(inpath,innam);                     /* copy input path */\n  strcat(inpath, ffin.ff_name);             /* concatenate filename */\n  infile = open(inpath,O_RDONLY | O_BINARY); /* open the input file */\n  if(infile < 1) {                          /* opened o.k.? */\n  printf(\"Can't open input file %s.\",inpath); /* no, open failed */\n  exit(1);                                  /* kill the run */\n  }\n  outfile = open(outpath,O_CREAT | O_WRONLY | O_BINARY);\n  if(outfile < 1) {\n   printf(\"Can't create file %s. Open failed.\",outpath); /* open fail */\n   exit(1);                               /* kill the run */\n  }\n  printf(\"\\nAdding file %s\",outpath);       /* tell user */\n  while((num_bytes = read(infile, buffer, BUF_SIZE)) > 0) /* copy */\n   write(outfile, buffer, num_bytes);     /* input to output */\n  adds++;                                   /* incr files added count */\n  if((getftime(infile, &ftime)) == 0)       /* get in file date/time */\n   setftime(outfile, &ftime);             /* and put it on output */\n  close(infile);                            /* close input file */\n  close(outfile);                           /* close output file */\n }\n else {                                       /* file on input and output */\n if((ffin.ff_fdate > ffout.ff_fdate) ||       /* Input file is */\n  ((ffin.ff_fdate == ffout.ff_fdate) &&     /* newer than the */\n   (ffin.ff_ftime > ffout.ff_ftime))) {   /* output file? */\n    strcpy(inpath,innam);               /* copy input path */\n    strcat(inpath, ffin.ff_name);       /* concatenate filename */\n    infile = open(inpath,O_RDONLY | O_BINARY); /* open the input file */\n    if(infile < 1) {                    /* opened o.k.? */\n     printf(\"Can't open input file %s.\",inpath); /* no, open fail */\n     exit(1);                         /* kill the run */\n    }\n    outfile = open(outpath, O_WRONLY | O_BINARY); /* open to overlay */\n    if(outfile < 1) {                   /* open successful? */\n     printf(\"Can't overlay file %s. Open failed.\",outpath); /* no */\n     exit(1);                         /* kill the run */\n    }\n    printf(\"\\nReplacing file %s\",outpath); /* tell user */\n    while((num_bytes = read(infile, buffer, BUF_SIZE)) > 0) /* copy */\n     write(outfile, buffer, num_bytes); /* input to output */\n    overlay++;                         /* incr files overlaid count */\n    if((getftime(infile, &ftime)) == 0) /* get in file date/time */\n     setftime(outfile, &ftime);       /* and put it on output */\n    close(infile);                     /* close input file */\n    close(outfile);                    /* close output file */\n   }\n   else\n    oldup++;                           /* older or duplicate */\n }\n done = (findnext(&ffin));                   /* get next input directory */\n}\n/**********************************************************************/\n/* initialization: ask for source and destination paths, get first    */\n/* filename in source path.                                           */\n/**********************************************************************/\nvoid initialize(int argc, char *argv[]) {\n if(argc == 3) {             /* if filenames given on command line */\n  strcpy(innam,argv[1]);      /* first one is source */\n  strcpy(outnam,argv[2]); /* second is destination */\n }\n else {\n  if(argc == 2) {          /* if one filename on command line */\n   strcpy(innam,argv[1]); /* it is the source */\n   getcwd(outnam,80);       /* current working directory is dest */\n  }\n  else {\n   printf(\"\\nEnter FROM path (wildcards optional): \");  /* else ask */\n   gets(innam);                    /* read source file path */\n   printf(\"\\nEnter TO path (directory): \");\n   gets(outnam);                   /* read destination path */\n  }\n }\n i = findfirst(innam,&ffin,0);         /* get first input directory */\n if(i) {                               /* got directory entry?  */\n  printf(\"findfirst failed for input file %s.\",innam);  /* no, error */\n  exit(1);                           /* kill the run */\n }\n for(i=strlen(innam);i > 0; i--)       /* loop to find end of path */\n  if((innam[i] == '\\\\') || (innam[i] == ':')) { /* if \\ or : */\n   i++;                            /* step past it */\n   break;                          /* and break the loop */\n  }\n innam[i] = '\\0';                      /* terminate the path string */\n i = strlen(outnam) - 1;               /* end of output path -1 */\n if(outnam[i] != '\\\\') {               /* if path doesn't end with \\ */\n  outnam[1+i] = '\\\\';                /* put a \\ at the end */\n  outnam[2+i] = '\\0';                /* and add new termination */\n }\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "COPYSOME": {"ttr": 5644, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00T\\x01\\x02\\x11\\x9f\\x01\\x02\\x12/\\x135\\x01I\\x01H\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-02T13:35:54", "lines": 329, "newlines": 328, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* copysome.c */\n/*******************************************************************/\n/* Copies 1st 100,000 bytes and last 100,000 bytes of an input     */\n/* file to an output file for use in testing.                      */\n/*                                                                 */\n/* Author R Thornton January 1994                                  */\n/*******************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\nvoid initiate(int argc, char *argv[]); /* initialization function */\nvoid mainline(void);                  /* mainline function */\nvoid terminat(void);                  /* termination function */\nvoid readrec(void);                   /* read next input file record */\nvoid writerec(void);                  /* write record to output file */\nvoid prntline(void);                  /* print a line to report file */\nint edit(char output[], char pattern[], char number[]); /* edit func */\nvoid headings(void);                  /* print report heading */\n\nFILE *infile, *outfile, *prtfile;     /* file handle pointers */\nchar innam[81];                       /* input file name */\nchar outnam[81];                      /* output file name */\nchar prtnam[81] = \"stdout\";           /* print file name */\n\nchar prtline[80];                     /* print line buffer */\nchar inrecord[256];                   /* input file record area */\n\nint i;                                /* general purpose int */\nchar number[32];                      /* ascii numbers for edit() */\nint morerecs = -1;                    /* input end-of-file switch */\nlong incount = 0;                     /* input record counter */\nlong outcount = 0;                    /* output record counter */\nlong floffset = 0;                    /* file offset */\nlong outbytes = 0;                    /* output file byte counter */\n\n\nvoid main(int argc, char *argv[])\n{\n initiate(argc, argv);         /* initialize, open files */\n while(morerecs)\n  mainline();               /* main processing */\n terminat();                   /* terminate, close files */\n exit(0);                      /* quit */\n}\n/*********************************************************************/\n/* mainline function: process input file until no more records.      */\n/*********************************************************************/\nvoid mainline(void)\n{\n readrec();                    /* read next input record */\n if(morerecs) {\n  writerec();}              /* write an output record */\n if(floffset)\n  if(outbytes > 100000L) {\n    if(fseek(infile,floffset,SEEK_END) != 0) {\n     printf(\"\\nCan't reposition to end of file -100,000 bytes.\");\n     exit(1); }\n    readrec(); }            /* read past partial record */\n}\n/*********************************************************************/\n/* initialization: open files, read first input record.              */\n/*********************************************************************/\nvoid initiate(int argc, char *argv[])\n{\n  if(argc == 3) {\n    strcpy(innam,argv[1]);\n    strcpy(outnam,argv[2]);\n  }\n  else {\n printf(\"\\nEnter input file spec: \");\n gets(innam);\n printf(\"\\nEnter output file spec: \");\n gets(outnam); }\n  if((infile=fopen(innam,\"rb\")) == NULL) { /* open input */\n    printf(\"Can't open file %s.\",innam);\n    exit(1);\n  }\n  if((outfile=fopen(outnam,\"wb\")) == NULL) { /* open output */\n    printf(\"Can't open file %s.\",outnam);\n    exit(1);\n  }\n  if((prtfile=fopen(prtnam,\"w\"))==NULL) { /* open print file */\n    printf(\"\\nCan't open the printer file.\");\n    exit(1);\n  }\n  prtline[133] = '\\0';                  /* terminal null to prt line */\n  if(fseek(infile,0L,SEEK_END) != 0) {   /* position to end of file */\n printf(\"\\nCan't set to end of input file.\");\n exit(1); }\n  if((ftell(infile)) > 220000L)      /* if file size > 220,000 bytes */\n floffset = -100000L;                /* set file offset to -100,000 */\n  if(fseek(infile,0L,SEEK_SET) != 0) {  /* reposition to file start*/\n printf(\"\\nCan't reposition to beginning of file.\");\n exit(1); }\n}\n/*********************************************************************/\n/* read next input file record. at end of file, set morerecs switch. */\n/*********************************************************************/\nvoid readrec() {\n  if(fgets(inrecord,255,infile) == NULL) /* read input until eof */\n    morerecs = 0;                       /* set switch at end of file */\n  if(morerecs)\n    incount++;                           /* add 1 to records read */\n}\n/*********************************************************************/\n/* write a record to the output file                                 */\n/*********************************************************************/\nvoid writerec() {\n  fputs(inrecord,outfile);         /* write output record */\n  outcount++;                      /* add 1 to records written */\n  outbytes += strlen(inrecord);    /* add nbr bytes written */\n}\n/*********************************************************************/\n/* write a line to the printer                                       */\n/*********************************************************************/\nvoid prntline() {\n  prtline[133] = '\\n';           /* terminal newline to print line */\n  prtline[134] = '\\0';           /* terminal null to print line */\n  fputs(prtline,prtfile);        /* write print line */\n  prtline[0] = '\\0';             /* null out print line */\n}\n/*********************************************************************/\n/* The edit function provides numeric report editing, including      */\n/* leading zero suppression, check protection, floating $, leading   */\n/* or trailing minus sign, insertion of commas, decimal points and   */\n/* other non-numeric fields. The first parameter is the address of   */\n/* the edited output, whose size will be the same as the pattern.    */\n/* The second parameter is the editing pattern, which must be a true */\n/* null-terminated string containing the edit pattern. The third     */\n/* is the number to be edited, a null-terminated string containing   */\n/* only digits 0-9 except the first position, which is a -, if the   */\n/* number is negative. The pattern may be up to 64 characters, and   */\n/* the number to be edited may contain up to 32 characters. The      */\n/* number may not contain more significant digits than there are     */\n/* digit select characters in the pattern. If there are more digits  */\n/* selected by the pattern than there are in the number, leading     */\n/* zeros will be assumed. In the pattern, the first character may    */\n/* be:      $ (floating dollar sign)                                 */\n/*          * (check protection)                                     */\n/*          - (floating minus sign)                                  */\n/* The body of the edit pattern will be composed of digit select     */\n/* characters (z and 9) and other characters, handled as follows:    */\n/*          z (zero suppression output is a blank in this position   */\n/*             until significance is set by receipt of a significant */\n/*             digit or a 9 in the pattern. After significance is    */\n/*             set, output is a digit from the number.)              */\n/*          9 (output is a digit from the number and significance    */\n/*             is set, even if the digit is a leading zero.)         */\n/*        other characters in the pattern will be output as-is after */\n/*             significance is set, but will be output as blanks     */\n/*             before significance is set.                           */\n/* Characters in the pattern following the last digit select will    */\n/* be output as-is if the number is negative, otherwise output will  */\n/* be blanks for these pattern positions.                            */\n/*                                                                   */\n/* When * check protection is selected, output will be *, rather     */\n/* than blanks as mentioned above.                                   */\n/*                                                                   */\n/* An integer is returned to indicate success or errors:             */\n/*                 0 = successful edit                               */\n/*                 1 = pattern too long (over 64 characters)         */\n/*                 2 = too many digits selected (over 32)            */\n/*                 3 = no output digits selected in pattern          */\n/*                 4 = number contains non-numeric data              */\n/*                 5 = number has more digits than the pattern       */\n/*                                                                   */\n/* Examples:                            nbr=             outf=       */\n/*    err=edit(outf,\"zz,zz9.99-\",nbr);  0                     0.00   */\n/*                                      123                   1.23   */\n/*                                      562983            5,629.83   */\n/*                                      -4675                46.75-  */\n/*    err=edit(outf,\"$,$$$.$$\",nbr);    0                            */\n/*                                      123                  $1.23   */\n/*                                      562983           $5,629.83   */\n/*                                      -4675               $46.75   */\n/*    err=edit(outf,\"***.**\",nbr);      0                            */\n/*                                      123                 **1.23   */\n/*                                      562983   err = 5             */\n/*                                      -4675               *46.75   */\n/*    err=edit(outf,\"--,--9.99\",nbr);   0                     0.00   */\n/*                                      123                   1.23   */\n/*                                      562983            5,629.83   */\n/*                                      -46.75              -46.75   */\n/*                                                                   */\n/* Author R Thornton April 1989                                      */\n/*********************************************************************/\n/**/\nint edit(char output[], char pattern[], char number[]) {\n  char float_val = ' ';\n  char fill_val = ' ';\n  char sign_val = ' ';\n  int signif = 0;\n  int psize = 0;\n  int pdig = 0;\n  int plast = 0;\n  int ndig = 0;\n  char nbr[33];\n  char ch= ' ';\n  int po=0;\n  int n=0;\n\n/****************************************************************/\n/* examine pattern: set up float and fill, count size and digits*/\n/****************************************************************/\n  if(((ch=pattern[0]) == '$') || (ch == '*') || (ch == '-'))\n    float_val = ch;\n  if(ch == '*')\n    fill_val = '*';\n  while((ch=pattern[po]) != '\\0') {\n    if((ch == 'z') || (ch == '9')) {\n      pdig++;\n      plast = po;\n    }\n    psize++;\n    po++;\n  }\n  if(psize > 63)\n    return(1);\n  if(pdig > 32)\n    return(2);\n  if(!pdig)\n    return(3);\n/****************************************************************/\n/* examine number: set up sign, count digits, check numeric.    */\n/* set error if more digits than pattern, move right justified  */\n/****************************************************************/\n  if(number[0] == '-') {\n    sign_val = '-';\n    n = 1;\n  }\n  while((ch=number[n]) != '\\0') {\n    if((ch < '0') || (ch > '9'))\n      return(4);\n    ndig++;\n    n++;\n  }\n  if(ndig > pdig)\n    return(5);\n  for(po=0;po<(pdig-ndig);po++)\n    nbr[po] = '0';\n  if(sign_val == ' ')\n    n = 0;\n  else\n    n=1;\n  for(;po<pdig;po++,n++)\n    nbr[po] = number[n];\n/****************************************************************/\n/* scan across the pattern, setting the corresponding output    */\n/* byte from pattern, fill, or amt depending on the pattern     */\n/* character and state of significance.                         */\n/****************************************************************/\n  if(float_val != ' ') {\n    output[0] = ' ';\n    po = 1;\n  }\n  else\n    po = 0;\n  n = 0;\n  while((po <= plast)) {\n    ch = pattern[po];\n    if(ch == 'z') {\n      if(signif) {\n        output[po] = nbr[n];\n        n++;\n      }\n      else {\n        if(nbr[n] == '0') {\n          output[po] = fill_val;\n          n++;\n        }\n        else {\n          output[po] = nbr[n];\n          signif = -1;\n          n++;\n          if(float_val == ' ')\n            ;\n          else\n            if((float_val == '$') || (sign_val == '-'))\n              output[po-1] = float_val;\n        }\n      }\n    }\n    else if(ch == '9') {\n      output[po] = nbr[n];\n      if(!signif) {\n        signif = -1;\n        if(float_val == ' ')\n          ;\n        else\n          if((float_val == '$') || (sign_val == '-'))\n            output[po-1] = float_val;\n      }\n      n++;\n    }\n    else {\n      if(signif)\n        output[po] = pattern[po];\n      else\n        output[po] = fill_val;\n    }\n    po++;\n  }\n  while((ch=pattern[po]) != '\\0') {\n    if(sign_val == ' ')\n      output[po++] = fill_val;\n    else\n      output[po++] = pattern[po];\n  }\n  return(0);\n}\n/*********************************************************************/\n/* termination: close files                                          */\n/*********************************************************************/\nvoid terminat() {\n  sprintf(number,\"%ld\",incount);     /* convert input count to ascii */\n  edit(prtline, \"zz,zzz,zz9\", number);    /* edit number to prtline */\n  strcpy(prtline+10,\" input records read\"); /* message to prt */\n  prntline();                               /* print count */\n  sprintf(number,\"%ld\",outcount);    /* convert input count to ascii */\n  edit(prtline, \"zz,zzz,zz9\", number);    /* edit number to prtline */\n  strcpy(prtline+10,\" output records written\"); /* message to prt */\n  prntline();                               /* print count */\n  fclose(infile);                           /* close files */\n  fclose(outfile);\n  fclose(prtfile);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "COPYSUBR": {"ttr": 5894, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x000\\x01\\x02\\x11\\x9f\\x01\\x02\\x12/\\x13F\\x01T\\x01S\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-02T13:46:30", "lines": 340, "newlines": 339, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* copysubr.c */\n/*******************************************************************/\n/* copies every 50th record from the original subscriber file     */\n/* downloaded to the IVRUPROD machine from the mainframe in order  */\n/* to create a manageable file for use in testing (about 500       */\n/* k-bytes). The output file will contain at least the first input */\n/* record and the last two records (trailer record and \\f\\n record)*/\n/* and the trailer record will be modified to contain the correct  */\n/* record count for the test file.                                 */\n/*                                                                 */\n/* Author R Thornton February 1994                                 */\n/*******************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid initiate(int argc, char *argv[]); /* initialization function */\nvoid mainline(void);                  /* mainline function */\nvoid terminat(void);                  /* termination function */\nvoid readrec(void);                   /* read next input file record */\nvoid writerec(void);                  /* write record to output file */\nvoid trailrec(void);                  /* process TRAILER record */\nvoid prntline(void);                  /* print a line to report file */\nint edit(char output[], char pattern[], char number[]); /* edit func */\n\nFILE *infile, *outfile, *prtfile;     /* file handle pointers */\nchar innam[81];                       /* input file name */\nchar outnam[81];                      /* output file name */\nchar prtnam[81];                      /* print file name */\n\nchar prtline[135];                    /* print line buffer */\nchar inrecord[256];                   /* input file record area */\n\nint i;                                /* general purpose int */\nchar number[32];                      /* ascii numbers for edit() */\nint morerecs = -1;                    /* input end-of-file switch */\nlong incount = 0;                     /* input record counter */\nlong outcount = 0;                    /* output record counter */\nint fiftycnt = 50;                    /* used to count 50 records */\n\n\nint  main(int argc, char *argv[])\n{\n initiate(argc, argv);         /* open files */\n while(morerecs)               /* perform mainline until */\n  mainline();               /* no more records */\n terminat();                   /* close files */\n exit(0);                      /* quit */\n}\n/*********************************************************************/\n/* mainline function: process input file until no more records.      */\n/*********************************************************************/\nvoid mainline(void) {\n if(fiftycnt == 50)            /* each 50th record */\n   writerec();                 /* is written to output */\n else\n   if(memcmp(inrecord,\"TRAILER\",7) == 0) /* handle trailer record */\n  trailrec();               /* by separate function */\n readrec();                    /* read next input record */\n fiftycnt ++;                  /* increment counter */\n}\n/*********************************************************************/\n/* initialization: open files, read first input record.              */\n/*********************************************************************/\nvoid initiate(int argc, char *argv[])\n{\n  if(argc == 4) {\n    strcpy(innam,argv[1]);\n    strcpy(outnam,argv[2]);\n strcpy(prtnam,argv[3]);\n    }\n  else {\n printf(\"\\nUsage: copysubr infile outfile prtfile\");\n exit(1);\n  }\n  if((infile=fopen(innam,\"rb\")) == NULL) { /* open input */\n    printf(\"Can't open file %s.\",innam);\n    exit(1);\n  }\n  if((outfile=fopen(outnam,\"wb\")) == NULL) { /* open output */\n    printf(\"Can't open file %s.\",outnam);\n    exit(1);\n  }\n  if((prtfile=fopen(prtnam,\"w\"))==NULL) { /* open print file */\n    printf(\"\\nCan't open the printer file.\");\n    exit(1);\n  }\n  readrec();             /* read first input file record */\n}\n/*********************************************************************/\n/* read next input file record. at end of file, set morerecs switch. */\n/*********************************************************************/\nvoid readrec() {\n  if(fgets(inrecord,255,infile) == NULL) /* read input until eof */\n    morerecs = 0;                       /* set switch at end of file */\n  if(inrecord[20] == '\\f')       /* two records joined by form-feed? */\n incount++;                           /* yes, add 1 more to count */\n  if(morerecs)\n incount++;                           /* add 1 to records read */\n}\n/*********************************************************************/\n/* process TRAILER record and final \\f\\n record                      */\n/*********************************************************************/\nvoid trailrec() {\n  memcpy(inrecord,\"TRAILER\",7);       /* write identifier */\n  sprintf(inrecord+7,\"%5d\",outcount); /* put output count in TRAILER */\n  memcpy(inrecord+12,\"\\n\\f\\n\\0\",4);   /* add final record */\n  writerec();                        /* write TRAILER + final record */\n  if((outcount > 20000) && (outcount < 25000)) {\n printf(\"\\nError in copysubr: %d records written\",outcount);\n printf(\"\\nOutput file trailer record may be in error\");\n  }\n  morerecs = 0;                        /* set switch at end of file */\n}\n/*********************************************************************/\n/* write a record to the output file                                 */\n/*********************************************************************/\nvoid writerec() {\n  fputs(inrecord,outfile);        /* write output record */\n  outcount++;                      /* add 1 to records written */\n  if(inrecord[20] == '\\f')       /* two records joined by form-feed? */\n outcount++;                    /* yes, add 1 more to count */\n  fiftycnt = 0;                    /* reset 50 record counter */\n}\n/*********************************************************************/\n/* write a line to the printer                                       */\n/*********************************************************************/\nvoid prntline() {\n  prtline[133] = '\\n';           /* terminal newline to print line */\n  prtline[134] = '\\0';           /* terminal null to print line */\n  fputs(prtline,prtfile);        /* write print line */\n  for(i=0;i<133;i++)\n      prtline[i] = ' ';          /* clear print line to spaces. */\n}\n/*********************************************************************/\n/* The edit function provides numeric report editing, including      */\n/* leading zero suppression, check protection, floating $, leading   */\n/* or trailing minus sign, insertion of commas, decimal points and   */\n/* other non-numeric fields. The first parameter is the address of   */\n/* the edited output, whose size will be the same as the pattern.    */\n/* The second parameter is the editing pattern, which must be a true */\n/* null-terminated string containing the edit pattern. The third     */\n/* is the number to be edited, a null-terminated string containing   */\n/* only digits 0-9 except the first position, which is a -, if the   */\n/* number is negative. The pattern may be up to 64 characters, and   */\n/* the number to be edited may contain up to 32 characters. The      */\n/* number may not contain more significant digits than there are     */\n/* digit select characters in the pattern. If there are more digits  */\n/* selected by the pattern than there are in the number, leading     */\n/* zeros will be assumed. In the pattern, the first character may    */\n/* be:      $ (floating dollar sign)                                 */\n/*          * (check protection)                                     */\n/*          - (floating minus sign)                                  */\n/* The body of the edit pattern will be composed of digit select     */\n/* characters (z and 9) and other characters, handled as follows:    */\n/*          z (zero suppression output is a blank in this position   */\n/*             until significance is set by receipt of a significant */\n/*             digit or a 9 in the pattern. After significance is    */\n/*             set, output is a digit from the number.)              */\n/*          9 (output is a digit from the number and significance    */\n/*             is set, even if the digit is a leading zero.)         */\n/*        other characters in the pattern will be output as-is after */\n/*             significance is set, but will be output as blanks     */\n/*             before significance is set.                           */\n/* Characters in the pattern following the last digit select will    */\n/* be output as-is if the number is negative, otherwise output will  */\n/* be blanks for these pattern positions.                            */\n/*                                                                   */\n/* When * check protection is selected, output will be *, rather     */\n/* than blanks as mentioned above.                                   */\n/*                                                                   */\n/* An integer is returned to indicate success or errors:             */\n/*                 0 = successful edit                               */\n/*                 1 = pattern too long (over 64 characters)         */\n/*                 2 = too many digits selected (over 32)            */\n/*                 3 = no output digits selected in pattern          */\n/*                 4 = number contains non-numeric data              */\n/*                 5 = number has more digits than the pattern       */\n/*                                                                   */\n/* Examples:                            nbr=             outf=       */\n/*    err=edit(outf,\"zz,zz9.99-\",nbr);  0                     0.00   */\n/*                                      123                   1.23   */\n/*                                      562983            5,629.83   */\n/*                                      -4675                46.75-  */\n/*    err=edit(outf,\"$,$$$.$$\",nbr);    0                            */\n/*                                      123                  $1.23   */\n/*                                      562983           $5,629.83   */\n/*                                      -4675               $46.75   */\n/*    err=edit(outf,\"***.**\",nbr);      0                            */\n/*                                      123                 **1.23   */\n/*                                      562983   err = 5             */\n/*                                      -4675               *46.75   */\n/*    err=edit(outf,\"--,--9.99\",nbr);   0                     0.00   */\n/*                                      123                   1.23   */\n/*                                      562983            5,629.83   */\n/*                                      -46.75              -46.75   */\n/*                                                                   */\n/* Author R Thornton April 1989                                      */\n/*********************************************************************/\n/**/\nint edit(char output[], char pattern[], char number[]) {\n  char float_val = ' ';\n  char fill_val = ' ';\n  char sign_val = ' ';\n  int signif = 0;\n  int psize = 0;\n  int pdig = 0;\n  int plast = 0;\n  int ndig = 0;\n  char nbr[33];\n  char ch= ' ';\n  int po=0;\n  int n=0;\n\n/****************************************************************/\n/* examine pattern: set up float and fill, count size and digits*/\n/****************************************************************/\n  if(((ch=pattern[0]) == '$') || (ch == '*') || (ch == '-'))\n    float_val = ch;\n  if(ch == '*')\n    fill_val = '*';\n  while((ch=pattern[po]) != '\\0') {\n    if((ch == 'z') || (ch == '9')) {\n      pdig++;\n      plast = po;\n    }\n    psize++;\n    po++;\n  }\n  if(psize > 63)\n    return(1);\n  if(pdig > 32)\n    return(2);\n  if(!pdig)\n    return(3);\n/****************************************************************/\n/* examine number: set up sign, count digits, check numeric.    */\n/* set error if more digits than pattern, move right justified  */\n/****************************************************************/\n  if(number[0] == '-') {\n    sign_val = '-';\n    n = 1;\n  }\n  while((ch=number[n]) != '\\0') {\n    if((ch < '0') || (ch > '9'))\n      return(4);\n    ndig++;\n    n++;\n  }\n  if(ndig > pdig)\n    return(5);\n  for(po=0;po<(pdig-ndig);po++)\n    nbr[po] = '0';\n  if(sign_val == ' ')\n    n = 0;\n  else\n    n=1;\n  for(;po<pdig;po++,n++)\n    nbr[po] = number[n];\n/****************************************************************/\n/* scan across the pattern, setting the corresponding output    */\n/* byte from pattern, fill, or amt depending on the pattern     */\n/* character and state of significance.                         */\n/****************************************************************/\n  if(float_val != ' ') {\n    output[0] = ' ';\n    po = 1;\n  }\n  else\n    po = 0;\n  n = 0;\n  while((po <= plast)) {\n    ch = pattern[po];\n    if(ch == 'z') {\n      if(signif) {\n        output[po] = nbr[n];\n        n++;\n      }\n      else {\n        if(nbr[n] == '0') {\n          output[po] = fill_val;\n          n++;\n        }\n        else {\n          output[po] = nbr[n];\n          signif = -1;\n          n++;\n          if(float_val == ' ')\n            ;\n          else\n            if((float_val == '$') || (sign_val == '-'))\n              output[po-1] = float_val;\n        }\n      }\n    }\n    else if(ch == '9') {\n      output[po] = nbr[n];\n      if(!signif) {\n        signif = -1;\n        if(float_val == ' ')\n          ;\n        else\n          if((float_val == '$') || (sign_val == '-'))\n            output[po-1] = float_val;\n      }\n      n++;\n    }\n    else {\n      if(signif)\n        output[po] = pattern[po];\n      else\n        output[po] = fill_val;\n    }\n    po++;\n  }\n  while((ch=pattern[po]) != '\\0') {\n    if(sign_val == ' ')\n      output[po++] = fill_val;\n    else\n      output[po++] = pattern[po];\n  }\n  return(0);\n}\n/*********************************************************************/\n/* termination: close files                                          */\n/*********************************************************************/\nvoid terminat() {\n  sprintf(number,\"%ld\",incount);     /* convert input count to ascii */\n  edit(prtline, \"zz,zzz,zz9\", number);    /* edit number to prtline */\n  strcpy(prtline+10,\" input records read\"); /* message to prt */\n  prntline();                               /* print count */\n  sprintf(number,\"%ld\",outcount);    /* convert input count to ascii */\n  edit(prtline, \"zz,zzz,zz9\", number);    /* edit number to prtline */\n  strcpy(prtline+10,\" output records written\"); /* message to prt */\n  prntline();                               /* print count */\n  fclose(infile);                           /* close files */\n  fclose(outfile);\n  fclose(prtfile);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "COPYTO": {"ttr": 6145, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x01\\x11\\x01\\x11\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 273, "newlines": 273, "modlines": 0, "user": "BC0THOR"}, "text": "/* copyto.c */\n/**********************************************************************/\n/* copy files with multiple \"from\" wildcards. Asks before overwriting */\n/* existing files. Does not copy if name & size same.                 */\n/* Proper usage is: copyto <destination> <wildcard 1>...              */\n/*        destination is a path, such as a:\\\\files1                   */\n/*        wildcard selects zero or more generic filename groups       */\n/*            in the current directory,such as d*.* w*.* *.c ...      */\n/**********************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <dir.h>\n#include <errno.h>\n#include <conio.h>\n#include <io.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys\\stat.h>\n#include <dos.h>\n\n#define MAX_WILDCARD_LEN 31\n#define DYN_ARRAY_SIZE 50\n#define INC_ARRAY_SIZE 25\n\nstruct ffblk* fn_edir(char[][], int, struct ffblk*, int*);\nint fn_copyto(char*, char[][], int);\nint inx=0, outx=0;\n/*************************************************************************/\n/* This is the MAIN function which obtains the parameters from the user, */\n/* calls fn-edir() to build the a sorted list of programs that match the */\n/* wildcard source files, then calls function fn_copyto() which copies   */\n/* the selected files to the destination path.                           */\n/*************************************************************************/\nmain(int argc, char* argv[])\n{\n char wildcard[10][MAX_WILDCARD_LEN];\nunsigned int num_wildcard, num_files, i;\nchar ch, destination[65];\nclrscr();\ndirectvideo = 1;\nif(argc < 2)\n   {\n    printf(\"\\nProper usage is: copyto <destination> <wildcard 1>...\");\n    printf(\"  destination is a path, such as a:\\\\files1\");\n    printf(\"  wildcard selects zero or more generic filename groups\");\n    printf(\"           in the current directory,such as d*.* w*.* *.c ...\");\n printf(\"           Default is NOT *.* if nothing is specified.\");\n    printf(\"  No copy is done when both files have same names and sizes.\");\n    exit(0);\n   } /* end if */\n else\n   {\n    strcpy(destination, argv[1]);\n    strupr(destination);\n    num_wildcard = argc - 2;\n    for(i = 0; i < num_wildcard; i++)\n        strcpy(wildcard[i], argv[i+2]);\n   } /* end else */\n fn_copyto(destination, wildcard, num_wildcard);\n} /* end main */\n\n/****************************************************************************/\n/*The destination parameter is the pathname of the target directory. The   */\n/*wildcard parameter passes an array of strings that contain the wildcards.*/\n/*The num_wildcard parameter specifies the number of wildcards. The        */\n/*fn_dir() function is called to create an array of filenames from the     */\n/*current directory using the wildcards given. fn_copyto() returns a 1 if  */\n/*any file is found, or 0 if no matches are found.                         */\n/****************************************************************************/\n\n/* fn_copyto() */\nint fn_copyto(char* destination,\n       char wildcard[][MAX_WILDCARD_LEN],\n       int num_wildcard)\n{\n struct ffblk *files;\n int num_files, num_bytes, i;\n char ch, path[65];\n char buffer[4096];\n int infile, outfile;\n unsigned int const BUF_SIZE = 4096;\n int line_num;\n\n files = fn_edir(wildcard, num_wildcard, files, &num_files);\n if(num_files > 0)\n    {\n     for(i = 0; i < num_files; i++)\n {\n  strcpy(path, destination);\n  strcat(path, \"\\\\\");\n  strcat(path, (files+i)->ff_name);\n  if(inx == 0)\n  {\n   infile = 0;\n   infile = open((files+i)->ff_name, O_RDONLY | O_BINARY);\n  }\n  if(infile < 1)\n     {\n      printf(\"\\n%s:\",(files+i)->ff_name);\n   perror(\" open input 1 failed\");\n   exit(0);\n  } /* end if */\n  else\n   inx = 1;\n  if(outx  == 0)\n  {\n   outfile = 0;\n   outfile = open(path, O_WRONLY | O_BINARY);\n  }\n  if(outfile > 0)\n  {\n   outx = 1;\n      if(filelength(infile) == filelength(outfile))\n     {\n   printf(\"\\n%s was not copied (duplicate)\",(files+i)->ff_name);\n   close(outfile);\n   outfile = 0;\n   outx = 0;\n   close(infile);\n   infile = 0;\n   inx = 0;\n   continue;\n     } /* end */\n  } /* end if */\n  if(outfile > 0)\n     {\n      printf(\"\\nShall I overwrite %s? (Y/N): \",(files+i)->ff_name);\n   do\n   {\n    ch = getche();\n    if(ch >= 'a' && ch <= 'z')\n     ch += 'A' - 'a';\n   }\n   while(ch != 'Y' && ch != 'N');\n      if(ch == 'N')\n     {\n   close(infile);\n   infile = 0;\n   inx = 0;\n   close(outfile);\n   outfile = 0;\n   outx = 0;\n   continue;\n     } /* end if */\n     } /* end if */\n  close(outfile);\n  outfile = 0;\n  outx = 0;\n  /* reopen file handle to allow new file creation */\n  if(outx == 0)\n    {\n  outfile = 0;\n  outfile = open(path, O_CREAT | O_WRONLY | O_BINARY, S_IWRITE);\n    }\n  if(outfile < 1)\n     {\n      printf(\"\\n%s:\",path);\n      perror(\" open output 2 failed\");\n  } /* end if */\n  else\n   outx = 1;\n  /* check if both files are opened o.k. */\n  if((inx == 1) && (outx == 1))\n     {\n      while((num_bytes = read(infile, buffer, BUF_SIZE)) > 0)\n   write(outfile, buffer, num_bytes);\n   close(infile);\n   infile = 0;\n   inx = 0;\n   close(outfile);\n   outfile = 0;\n   outx = 0;\n      printf(\"\\n%s copied to: %s\", (files+i)->ff_name, path);\n     } /* end if */\n  else\n     {\n   if(inx == 1)\n   {\n    close(infile);\n    infile = 0;\n    inx = 0;\n   }\n   if(outfile > 0)\n   {\n    close(outfile);\n    outfile = 0;\n    outx = 0;\n   }\n     } /* end else */\n } /* end for */\n     free(files);\n     return 1;\n    } /* end if */\n else\n     return 0;\n} /* end fn_copyto) */\n\n/***************************************************************************/\n/* fn_edir() builds an ordered array of filenames which match any of the   */\n/* wildcards specified and insures that there are no duplicates in the     */\n/* list. fn_dir() returns a pointer to the ffblk structure. the result     */\n/* should be reassigned to the pointer-typed parameter, files, to update   */\n/* the address of the dynamic array. The invoker of fn_edir() must         */\n/* deallocate the dynamic array when its data is no longer needed.         */\n/***************************************************************************/\n/* function fn_edir */\nstruct ffblk* fn_edir(char wildcard[] [MAX_WILDCARD_LEN],\n        int num_wildcard,\n        struct ffblk *files,\n        int *num_files)\n{\n int n= DYN_ARRAY_SIZE;\n unsigned int blk_size = sizeof(struct ffblk);\n int i, j, k, nomatch, not_unique, found;\n struct ffblk *ptr;\n\n /* allocate new block for file structures */\n files = (struct ffblk *) calloc(n,blk_size);\n ptr = (struct ffblk*) calloc(n,blk_size);\n *num_files = 0;          /* initialize matching file count */\n /* loop to look for the specified wildcards */\n for(i=0;i<num_wildcard;i++)\n    {\n     /* search for the first matching entry */\n     nomatch = findfirst((wildcard+i),ptr,0);\n     /* while a match is found */\n     while(!nomatch)\n {\n  not_unique = 0;             /* assume filename is unique */\n  /* search in the available array of filenames */\n  if(*num_files > 0)\n      for(j=0;(j < *num_files) && (!not_unique); j++)\n   if(!strcmp(ptr->ff_name, (files+j) -> ff_name))\n       not_unique = 1;              /* found a match */\n  /* if filename is unique process it */\n  if(!not_unique)\n     {\n      (*num_files)++;                       /* increment file count */\n      /* need more dynamic memory? */\n      if(*num_files > n)\n  {\n   n += INC_ARRAY_SIZE;\n   files = (struct ffblk *) realloc(files, n * blk_size);\n  } /* end if */\n      /* insert inorder */\n      if(*num_files > 1)\n  {\n   found = 0;\n   k = *num_files - 1;\n   /* search for proper insertion location */\n   for(j=0; (j < k) && (!found); j++)\n      {\n       if(strcmp(ptr->ff_name, (files+j)->ff_name) < 0)\n   {\n    found = 1;\n    /* move rest of array upward */\n    memmove((files+j+1), (files+j), (k - j)*blk_size);\n    /* insert new element */\n    *(files+j) = *ptr;\n   } /* end if */\n      } /* end for */\n  if(!found)          /* insert as last array element */\n      *(files + k) = *ptr;\n        } /* end if */\n   else                    /* assign first entry */\n       *files = *ptr;\n  } /* end if */\n      /* search for the next matching entry */\n      nomatch = findnext(ptr);\n     } /* end while */\n   } /* end for */\n return files;    /* return pointer to dynamic array */\n} /* end fn_edir */\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "COPY2TO": {"ttr": 6150, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00\\xf8\\x00\\xf8\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 248, "newlines": 248, "modlines": 0, "user": "BC0THOR"}, "text": "/* copyto.c */\n/**********************************************************************/\n/* copy files with multiple \"from\" wildcards. Asks before overwriting */\n/* existing files. Does not copy if name & size same.                 */\n/* Proper usage is: copyto <destination> <wildcard 1>...              */\n/*        destination is a path, such as a:\\\\files1                   */\n/*        wildcard selects zero or more generic filename groups       */\n/*            in the current directory,such as d*.* w*.* *.c ...      */\n/**********************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <dir.h>\n#include <errno.h>\n#include <conio.h>\n#include <io.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys\\stat.h>\n#include <dos.h>\n\n#define MAX_WILDCARD_LEN 31\n#define DYN_ARRAY_SIZE 50\n#define INC_ARRAY_SIZE 25\n\nstruct ffblk* fn_edir(char[][], int, struct ffblk*, int*);\nint fn_copyto(char*, char[][], int);\nint inx=0, outx=0;\n/*************************************************************************/\n/* This is the MAIN function which obtains the parameters from the user, */\n/* calls fn-edir() to build the a sorted list of programs that match the */\n/* wildcard source files, then calls function fn_copyto() which copies   */\n/* the selected files to the destination path.                           */\n/*************************************************************************/\nint main(int argc, char* argv[]) {\n char wildcard[10][MAX_WILDCARD_LEN];\n unsigned int num_wildcard, num_files, i;\n char ch, destination[65];\n\n clrscr();\n directvideo = 1;\n if(argc < 2) {\n  printf(\"\\nProper usage is: copyto <destination> <wildcard 1>...\");\n  printf(\"  destination is a path, such as a:\\\\files1\");\n  printf(\"  wildcard selects zero or more generic filename groups\");\n  printf(\"           in the current directory,such as d*.* w*.* *.c ...\");\n  printf(\"           Default is NOT *.* if nothing is specified.\");\n  printf(\"  Copy is done only when there is no file by the same name in \");\n  printf(\"\\n the output file, or if the input file has a later modification\");\n  printf(\"\\n date than the present file.\");\n  exit(0);\n } /* end if */\n else {\n  strcpy(destination, argv[1]);\n  strupr(destination);\n  num_wildcard = argc - 2;\n  for(i = 0; i < num_wildcard; i++)\n   strcpy(wildcard[i], argv[i+2]);\n } /* end else */\n fn_copyto(destination, wildcard, num_wildcard);\n} /* end main */\n\n/***************************************************************************/\n/*The destination parameter is the pathname of the target directory. The   */\n/*wildcard parameter passes an array of strings that contain the wildcards.*/\n/*The num_wildcard parameter specifies the number of wildcards. The        */\n/*fn_dir() function is called to create an array of filenames from the     */\n/*current directory using the wildcards given. fn_copyto() returns a 1 if  */\n/*any file is found, or 0 if no matches are found.                         */\n/***************************************************************************/\n\n/* fn_copyto() */\nint fn_copyto(char* destination,\n char wildcard[][MAX_WILDCARD_LEN],\n int num_wildcard) {\n struct stat in, out;\n struct ffblk *files;\n int num_files, num_bytes, i;\n char ch, path[65];\n char buffer[4096];\n int infile, outfile;\n unsigned int const BUF_SIZE = 4096;\n int line_num, exists;\n\n files = fn_edir(wildcard, num_wildcard, files, &num_files);\n if(num_files > 0) {\n  for(i = 0; i < num_files; i++) {\n   strcpy(path, destination);\n   strcat(path, \"\\\\\");\n   strcat(path, (files+i)->ff_name);\n   exists = 0;        /* reset output file exists switch */\n   if(inx == 0) {\n    infile = 0;\n    infile = open((files+i)->ff_name, O_RDONLY | O_BINARY);\n   }\n   if(infile < 1) {\n    printf(\"\\n%s:\",(files+i)->ff_name);\n    perror(\" open input 1 failed\");\n    exit(0);\n   } /* end if */\n   else\n    inx = 1;\n   if(outx  == 0) {\n    outfile = 0;\n    outfile = open(path, O_WRONLY | O_BINARY);\n   }\n   if(outfile > 0) {\n    exists = -1;        /* show output file exists */\n    outx = 1;\n    if((fstat(infile, &in) == 0) && (fstat(outfile, &out) == 0)) {\n     if((in.st_atime <= out.st_atime)) {\n      printf(\"\\n%s was not copied (older)\",(files+i)->ff_name);\n      printf(\"\\n    in=%08X, out=%08X\",in.st_atime, out.st_atime);\n      close(outfile);\n      outfile = 0;\n      outx = 0;\n      close(infile);\n      infile = 0;\n      inx = 0;\n      continue;\n     } /* end */\n    } /* end if */\n    else {\n     printf(\"\\n%s was not copied, FSTAT error\",(files+i)->ff_name);\n    } /* end else */\n   } /* end if */\n   close(outfile);\n   outfile = 0;\n   outx = 0;\n   /* reopen file handle to allow new file creation */\n   if(outx == 0) {\n    outfile = 0;\n    outfile = open(path, O_CREAT | O_WRONLY | O_BINARY, S_IWRITE);\n   } /* end if */\n   if(outfile < 1) {\n    printf(\"\\n%s:\",path);\n    perror(\" open output 2 failed\");\n   } /* end if */\n   else\n    outx = 1;\n   /* check if both files are opened o.k. */\n   if((inx == 1) && (outx == 1)) {\n    while((num_bytes = read(infile, buffer, BUF_SIZE)) > 0)\n    write(outfile, buffer, num_bytes);\n    close(infile);\n    infile = 0;\n    inx = 0;\n    fstat(outfile, &out);\n    close(outfile);\n    outfile = 0;\n    outx = 0;\n    if(exists) {\n     printf(\"\\n%s replaced in: %s\", (files+i)->ff_name, path);\n     printf(\"\\n    in=%08X, out=%08X\",in.st_atime, out.st_atime);\n    } /* end if */\n    else {\n     printf(\"\\n%s copied to: %s\", (files+i)->ff_name, path);\n     printf(\"\\n    date=%08X\",out.st_atime);\n    } /* end else */\n   } /* end if */\n   else {\n    if(inx == 1) {\n     close(infile);\n     infile = 0;\n     inx = 0;\n    } /* end if */\n    if(outfile > 0) {\n     close(outfile);\n     outfile = 0;\n     outx = 0;\n    } /* end if */\n   } /* end else */\n  } /* end for */\n  free(files);\n  return 1;\n } /* end if */\n else\n  return 0;\n} /* end fn_copyto) */\n\n/***************************************************************************/\n/* fn_edir() builds an ordered array of filenames which match any of the   */\n/* wildcards specified and insures that there are no duplicates in the     */\n/* list. fn_dir() returns a pointer to the ffblk structure. the result     */\n/* should be reassigned to the pointer-typed parameter, files, to update   */\n/* the address of the dynamic array. The invoker of fn_edir() must         */\n/* deallocate the dynamic array when its data is no longer needed.         */\n/***************************************************************************/\n\n/* function fn_edir */\nstruct ffblk* fn_edir(char wildcard[] [MAX_WILDCARD_LEN],\n int num_wildcard,\n struct ffblk *files,\n int *num_files) {\n int n= DYN_ARRAY_SIZE;\n unsigned int blk_size = sizeof(struct ffblk);\n int i, j, k, nomatch, not_unique, found;\n struct ffblk *ptr;\n\n /* allocate new block for file structures */\n files = (struct ffblk *) calloc(n,blk_size);\n ptr = (struct ffblk*) calloc(n,blk_size);\n *num_files = 0;          /* initialize matching file count */\n /* loop to look for the specified wildcards */\n for(i=0;i<num_wildcard;i++) {\n  /* search for the first matching entry */\n  nomatch = findfirst((char *)(wildcard+i),ptr,0);\n  /* while a match is found */\n  while(!nomatch) {\n   not_unique = 0;             /* assume filename is unique */\n   /* search in the available array of filenames */\n   if(*num_files > 0)\n    for(j=0;(j < *num_files) && (!not_unique); j++)\n     if(!strcmp(ptr->ff_name, (files+j) -> ff_name))\n      not_unique = 1;              /* found a match */\n    /* if filename is unique process it */\n    if(!not_unique) {\n     (*num_files)++;           /* increment file count */\n     /* need more dynamic memory? */\n     if(*num_files > n) {\n      n += INC_ARRAY_SIZE;\n      files = (struct ffblk *) realloc(files, n * blk_size);\n     } /* end if */\n     /* insert inorder */\n     if(*num_files > 1) {\n      found = 0;\n      k = *num_files - 1;\n      /* search for proper insertion location */\n      for(j=0; (j < k) && (!found); j++) {\n       if(strcmp(ptr->ff_name, (files+j)->ff_name) < 0) {\n        found = 1;\n        /* move rest of array upward */\n        memmove((files+j+1), (files+j), (k - j)*blk_size);\n        /* insert new element */\n        *(files+j) = *ptr;\n       } /* end if */\n      } /* end for */\n      if(!found)          /* insert as last array element */\n       *(files + k) = *ptr;\n     } /* end if */\n     else                    /* assign first entry */\n      *files = *ptr;\n    } /* end if */\n    /* search for the next matching entry */\n    nomatch = findnext(ptr);\n  } /* end while */\n } /* end for */\n return files;    /* return pointer to dynamic array */\n} /* end fn_edir */\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "COUNTBYT": {"ttr": 6155, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x19\\x01\\x00%o\\x01\\x02\\x12/\\x14\\t\\x00[\\x00C\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2000-09-12T00:00:00", "modifydate": "2002-05-02T14:09:19", "lines": 91, "newlines": 67, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* countbyt.c */\n/*****************************************************************/\n/* Program to count all bytes in a file by byte value and print  */\n/* the total for each byte value.                                */\n/* Author R Thornton Dec 2000                                    */\n/*****************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n  char InRec[256];                   /* record from input1 file */\n  int j,k;\n  long bytcnt[256];                  /* byte value counters */\n  unsigned long tot=0;\n  char chv[256][4] = {\n      \"nul\",\"soh\",\"stx\",\"etx\",\"pf \",\"ht \",\"lc \",\"del\",\n      \"   \",\"   \",\"smm\",\"vt \",\"ff \",\"cr \",\"so \",\"si \",\n      \"dle\",\"dci\",\"dc2\",\"tm \",\"res\",\"nl \",\"bs \",\"il \",\n      \"can\",\"em \",\"cc \",\"cu1\",\"ifs\",\"igs\",\"irs\",\"ius\",\n      \"ds \",\"sos\",\"fs \",\"   \",\"byp\",\"lf \",\"etb\",\"esc\",\n      \"   \",\"   \",\"sm \",\"cu2\",\"   \",\"enq\",\"ack\",\"bel\",\n      \"   \",\"   \",\"syn\",\"   \",\"pn \",\"rs \",\"uc \",\"eot\",\n      \"   \",\"   \",\"   \",\"cu3\",\"dc4\",\"nak\",\"   \",\"sub\",\n      \"sp \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\n      \"   \",\"   \",\"cnt\",\".  \",\"<  \",\"(  \",\"+  \",\"\u00a6  \",\n      \"&  \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\n      \"   \",\"   \",\"!  \",\"$  \",\"*  \",\")  \",\";  \",\"^  \",\n      \"-  \",\"/  \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\n      \"   \",\"   \",\"   \",\",  \",\"%  \",\"_  \",\">  \",\"?  \",\n      \"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\n      \"   \",\"   \",\":  \",\"#  \",\"@  \",\"'  \",\"=  \",\"\\\"  \",\n      \"   \",\"a  \",\"b  \",\"c  \",\"d  \",\"e  \",\"f  \",\"g  \",\n      \"h  \",\"i  \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\n      \"   \",\"j  \",\"k  \",\"l  \",\"m  \",\"n  \",\"o  \",\"p  \" ,\n      \"q  \",\"r  \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\n      \"   \",\"~  \",\"s  \",\"t  \",\"u  \",\"v  \",\"w  \",\"x  \",\n      \"y  \",\"z  \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\n      \"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\n      \"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\n      \"   \",\"A  \",\"B  \",\"C  \",\"D  \",\"E  \",\"F  \",\"G  \",\n      \"H  \",\"I  \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\n      \"   \",\"J  \",\"K  \",\"L  \",\"M  \",\"N  \",\"O  \",\"P  \",\n      \"Q  \",\"R  \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\n      \"\\\\  \",\"   \",\"S  \",\"T  \",\"U  \",\"V  \",\"W  \",\"X  \",\n      \"Y  \",\"Z  \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\n      \"0  \",\"1  \",\"2  \",\"3  \",\"4  \",\"5  \",\"6  \",\"7  \",\n      \"8  \",\"9  \",\"|  \",\"   \",\"   \",\"   \",\"   \",\"   \"};\n\n\n  FILE *infil;\n\n  infil=fopen(\"dd:input1\",\"rb,type=record,recfm=vba,lrecl=255\");\n  if(infil == NULL) {\n    perror(\"\\nCan't open the INPUT1 file\");\n    exit(8);\n  }\n  printf(\"\\n\");\n  for(k=0;k<256;k++)\n    bytcnt[k] = 0;\n  j = -1;\n  while(j) {                          /* do until file is exhausted */\n    j=fread(InRec, 1,  255, infil);   /* read next input1 record */\n    if(ferror(infil)) {\n      perror(\"\\nError (ferror) reading INPUT1 file\");\n      exit(8);\n    }\n    if(feof(infil)) {\n      j = 0;\n      break;\n    }\n    if(j == 0) {\n      perror(\"\\nError (0 read) reading INPUT1 file\");\n      exit(8);\n    }\n    while(j > 0) {\n      k = InRec[--j];\n      bytcnt[k]++;                /* add 1 to appropriate counter */\n      tot+=1;                     /* add 1 to file total */\n    }\n    j = -1;\n  }\n  fclose(infil);\n  for(k=0;k<=255;k++) {\n    if(bytcnt[k]) {\n      printf(\"\\n%2X = %3d = %s:  %ld\",k,k,chv[k],bytcnt[k]);\n    }\n  }\n  printf(\"\\n%ld total bytes in file\",tot);\n  return(0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "COUNTBY0": {"ttr": 6402, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00R\\x01\\x00%o\\x01\\x02\\x12/\\x143\\x00L\\x00N\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2000-09-12T00:00:00", "modifydate": "2002-05-02T14:33:52", "lines": 76, "newlines": 78, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* countby0.c */\n/*****************************************************************/\n/* Program to count all bytes in a file by byte value and print  */\n/* the total for each byte value.                                */\n/*****************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n\nmain(int argc, char *argv[]) {\n  unsigned char ch;\n  int i,k;\n  long bytcnt[256];                  /* byte value counters */\n  unsigned long tot=0;\n  char chv[256][4] = {\n \"nul\",\"soh\",\"stx\",\"etx\",\"pf \",\"ht \",\"lc \",\"del\",\n \"   \",\"   \",\"smm\",\"vt \",\"ff \",\"cr \",\"so \",\"si \",\n \"dle\",\"dci\",\"dc2\",\"tm \",\"res\",\"nl \",\"bs \",\"il \",\n \"can\",\"em \",\"cc \",\"cu1\",\"ifs\",\"igs\",\"irs\",\"ius\",\n \"ds \",\"sos\",\"fs \",\"   \",\"byp\",\"lf \",\"etb\",\"esc\",\n \"   \",\"   \",\"sm \",\"cu2\",\"   \",\"enq\",\"ack\",\"bel\",\n \"   \",\"   \",\"syn\",\"   \",\"pn \",\"rs \",\"uc \",\"eot\",\n \"   \",\"   \",\"   \",\"cu3\",\"dc4\",\"nak\",\"   \",\"sub\",\n \"sp \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\n \"   \",\"   \",\"cnt\",\".  \",\"<  \",\"(  \",\"+  \",\"\u00a6  \",\n \"&  \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\n \"   \",\"   \",\"!  \",\"$  \",\"*  \",\")  \",\";  \",\"^  \",\n \"-  \",\"/  \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\n \"   \",\"   \",\"   \",\",  \",\"%  \",\"_  \",\">  \",\"?  \",\n \"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\n \"   \",\"   \",\":  \",\"#  \",\"@  \",\"'  \",\"=  \",\"\\\"  \",\n \"   \",\"a  \",\"b  \",\"c  \",\"d  \",\"e  \",\"f  \",\"g  \",\n \"h  \",\"i  \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\n \"   \",\"j  \",\"k  \",\"l  \",\"m  \",\"n  \",\"o  \",\"p  \",\n \"q  \",\"r  \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\n \"   \",\"~  \",\"s  \",\"t  \",\"u  \",\"v  \",\"w  \",\"x  \",\n \"y  \",\"z  \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\n \"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\n \"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\n \"   \",\"A  \",\"B  \",\"C  \",\"D  \",\"E  \",\"F  \",\"G  \",\n \"H  \",\"I  \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\n \"}  \",\"J  \",\"K  \",\"L  \",\"M  \",\"N  \",\"O  \",\"P  \",\n \"Q  \",\"R  \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\n \"\\\\  \",\"   \",\"S  \",\"T  \",\"U  \",\"V  \",\"W  \",\"X  \",\n \"Y  \",\"Z  \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\n \"0  \",\"1  \",\"2  \",\"3  \",\"4  \",\"5  \",\"6  \",\"7  \",\n \"8  \",\"9  \",\"|  \",\"   \",\"   \",\"   \",\"   \",\"   \"};\n\n\n  FILE *infil;\n\n  if(argc!=2){\n    printf(\"\\nSYNTAX: countbyt [d:][\\\\path\\\\]filename[.ext]\");\n    exit(0); }\n  if((infil=fopen(argv[1],\"rb\"))==NULL) {\n    printf(\"\\nCan't open the input file, %s\",argv[1]);\n    exit(0); }\n  printf(\"\\n\");\n  for(k=0;k<256;k++)\n    bytcnt[k] = 0;\n  while((k=getc(infil))!=EOF) {\n    bytcnt[k]++;                /* add 1 to appropriate counter */\n    tot+=1; }                   /* add 1 to file total */\n  fclose(infil);\n  k = 0;\n  while(1) {\n    for(i=0;i<23;k++) {\n      if(k > 255) break;\n      if(bytcnt[k]) {\n        printf(\"\\n%2X = %3d = %s:  %ld\",k,k,chv[k],bytcnt[k]);\n        i++; } }\n    if(k > 255) break;\n      printf(\"\\nPress ENTER to continue\");\n    i = getchar(); }\n  printf(\"\\n%ld total bytes in file\",tot);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "CPUTYPE": {"ttr": 6405, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00\\xa2\\x00\\xa2\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 162, "newlines": 162, "modlines": 0, "user": "BC0THOR"}, "text": "; CPUTYPE.INC Routines to determine CPU type for high level languages\n; (Pascal,C,C++,etc)\n; CPU: 8086/80186, 80286, 80386, 80486, 80586 Pentium, 80686 P6 and higher(!)\n; FPU: 8087, 80287, 80387, 80487, and higher (see 1. and 2. in CPU586P6.ASM)\n;\n; 1995 by XMAS coding (Dominik Freche, address see below)\n; ********************** NOTE **********************\n; For further pieces of information see CPU586P6.ASM\n; **************************************************\n;\n; !!!!! THIS SOURCECODE IS FREEWARE !!!!!\n; Including routines in high level languages (Pascal,C,C++,etc) :\n; First assemble this file (for TASM : TASM CPUTYPE.INC) to an Object-file\n; (*.OBJ). This file can be included in your high level language program.\n; Add these lines in your high level language main (!) program\n; (e.g. for Turbo-Pascal) :\n;  {$L CPUTYPE.OBJ}\n;  Function CPUType : Word; External;{1=86,2=286,3=386,4=486,5=586,etc.}\n;  Function FPUType : Word; External;{0=None,1=87,2=287,3=387,4=487,Internal}\n; For other languages use another syntax.\n;\n; If you have got any problems or if you want to contact me, do not hesitate,\n; please write to the following address :\n;   Dominik Freche\n;   Vondernstrasse 45\n;   45357 Essen\n;   Germany, Europe\n; or email to :\n;   heckenb@mi.uni-erlangen.de (Frank Heckenbach)\n;\n; Dominik Freche, Mar 26 1995\n; Inclusion routines :\n\n        LOCALS  @@\n\nCPUID   EQU     DB 0FH,0A2H     ;80586 Instruction to determine CPU type\n\nDSeg    SEGMENT\n  Temp       DW  0FFFFH\n  FEnv       DW  7 DUP (0)\nDSeg    ENDS\n\nCSeg    SEGMENT\n        ASSUME CS:CSeg,DS:DSeg\n\n        PUBLIC CPUType,FPUType\n\n        .8086\n\nCPUType PROC    ;>AX CpuType (1=86,2=286,3=386,4=486,5=586,6=686,etc.)\n        MOV     AX,1\n        PUSHF\n        POP     BX\n        AND     BH,0FH\n        PUSH    BX\n        POPF\n        PUSHF\n        POP     CX\n        AND     CH,0F0H\n        CMP     CH,0F0H\n        JE      @@1                     ;8086 or below 80286\n        INC     AX\n        OR      BH,0F0H\n        PUSH    BX\n        POPF\n        PUSHF\n        POP     CX\n        AND     CH,0F0H\n        JE      @@1                     ;80286\n        .386\n        INC     AX\n        MOV     EBX,ESP\n        AND     ESP,0FFFCH\n        PUSHFD\n        POP     EDX\n        MOV     ECX,EDX\n        XOR     EDX,000040000H\n        PUSH    EDX\n        POPFD\n        PUSHFD\n        POP     EDX\n        PUSH    ECX\n        POPFD\n        XOR     EDX,ECX\n        AND     EDX,000040000H          ;Test Alignment Check Bit\n        MOV     ESP,EBX\n        JZ      @@1                     ;80386\n        ;.486\n        INC     AX\n        PUSHFD\n        POP     EDX\n        MOV     ECX,EDX\n        XOR     EDX,000200000H\n        PUSH    EDX\n        POPFD\n        PUSHFD\n        POP     EDX\n        PUSH    ECX\n        POPFD\n        XOR     EDX,ECX                 ;Test ID Bit\n        JZ      @@1                     ;80486\n        MOV     EAX,1\n        ;.586 or higher, CPUID returns Cpu Generation Number in AX Bits 8-11\n        CPUID\n        AND     AH,0FH\n        SHR     AX,8\n        .8086\n        .8087\n@@1:    RET\nCPUType ENDP\n\nFPUType PROC    ;>AX FpuType (0=None (SX),1=87,2=287,3=387,\n                ;4=487,5=586 or higher (FPU always internal))\n        FNSTENV FEnv\n        FNINIT\n        FNSTSW  Temp\n        CMP     BYTE PTR Temp,0\n        JNE     @@1\n        FNSTCW  Temp\n        CMP     BYTE PTR [Temp+1],3\n        JNE     @@1\n        FLDENV  FEnv                    ;FPU exists\n        CALL    CPUType                 ;Determine CPU type\n        CMP     AX,4                    ;Test CPU(in AX)>=80486\n        JAE     @@2                     ;CPU=80486,FPU exists=80487(Internal)\n                                        ;CPU>=80586,FPU=Internal\n        MOV     AX,3\n        FLD1\n        FLDZ\n        FDIVP   ST(1),ST\n        FLD     ST(0)\n        FCHS\n        FCOMPP\n        FSTSW   Temp\n        FWAIT\n        TEST    Temp,100H\n        JNZ     @@2                     ;80387\n        DEC     AX\n        FLD1\n@@0:    FISTP   Temp\n        FSTENV  FEnv\n        MOV     BX,CS\n        SHL     BX,1\n        SHL     BX,1\n        SHL     BX,1\n        SHL     BX,1\n        ADD     BX,OFFSET @@0\n        INC     BX\n        FWAIT\n        CMP     BX,[FEnv+6]\n        JE      @@2                     ;80287\n        DEC     AX                      ;8087\n        RET\n@@1:    XOR     AX,AX                   ;None\n@@2:    RET\nFPUType ENDP\n\n  IDString   DB  \"1995 by XMAS coding (Dominik Freche)\"\n\nCSeg    ENDS\n\n        END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CREATEPR": {"ttr": 6409, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x005\\x005\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "BC0THOR"}, "text": "/* test version of the createprv program */\n#include <stdio.h>\n\nvoid read_a_record(void);\n\nFILE *infile, *outfile;\nchar inrecord[257];\nchar hold_record[257];\nint record_waiting = 0;\nint more_records = -1;\nint recd_len = 0;\nint incount = 0;\nint outcount = 0;\nint i;\n\nmain() {\n if((infile=fopen(\"testfile\",\"rb\")) == NULL) {\n  printf(\"Can't open input file.\");\n  exit(1); }\n if((outfile=fopen(\"test.out\",\"wb\")) == NULL) {\n  printf(\"Can't open output file.\");\n  exit(1); }\n while(more_records) {\n  recd_len = 0;\n  while(!recd_len && more_records)\n   read_a_record();\n  if(more_records) {\n   fputs(inrecord,outfile);\n   outcount++; } }\n fclose(infile);\n fclose(outfile);\n}\nvoid read_a_record(void) {\n if(record_waiting) {\n  record_waiting = 0;\n  strcpy(inrecord,hold_record); }\n else {\n  if((fgets(inrecord,256,infile)) == NULL) {\n   more_records = 0;\n   recd_len = 0; } }\n if(more_records) {\n  while((inrecord[0] == '\\n') || (inrecord[0] == '\\f'))\n   strcpy(inrecord,inrecord+1);\n  recd_len = strlen(inrecord);\n  if(recd_len > 8)\n   if(inrecord[7] == '\\f') {\n    record_waiting = -1;\n    strcpy(hold_record, inrecord+8);\n    inrecord[7] = '\\n';\n    inrecord[8] = '\\0';\n    recd_len = strlen(inrecord); } }\n if(recd_len > 0 )\n  incount++; }\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "CREATPRV": {"ttr": 6411, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x01\\xbd\\x01\\xbd\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 445, "newlines": 445, "modlines": 0, "user": "BC0THOR"}, "text": "          /*****************************************************************/\n          /*                     **** creatprv.c ****                      */\n          /*                                                               */\n          /* File purification program for the provider file as received   */\n          /* from the mainframe via JES2 RJE. Form feed characters (\\f) are*/\n          /* removed. Each data record is checked to insure it contains    */\n          /* only a 7-digit provider number followed by a new-line         */\n          /* character (\\n). The last record in the file is a trailer      */\n          /* record that begins with \\xFF followed by an uppercase \"T\" and */\n          /* the file record count. The trailer record is written to the   */\n          /* prvcnt file and the count is used to validate the number of   */\n          /* records read from the input file. All good provider records   */\n          /* are written to the new provider file, while error records are */\n          /* written to the error file.                                    */\n          /* Author R Thornton February 1994                               */\n          /*****************************************************************/\n          #include <stdio.h>\n          #include <stdlib.h>\n          #include <time.h>\n          #include <ctype.h>\n\n          void initialize(int argc, char *argv[])); /* initialization      */\n          void mainline(void);                  /* mainline function       */\n          void terminate(void);                 /* termination function    */\n          void read_a_record(void);             /* read next input file rec*/\n          void writerec(void);                  /* write record to output  */\n          void writecnt(void);                  /* write to the counts file*/\n          void writeerr(void);                  /* write error records     */\n          void trailrecd(void);                 /* process trailer record  */\n          int edit(char output[], char pattern[], char number[]); /* edit  */\n\n          FILE *infile, *outfile, *cntfile, *errfile; /* file pointers     */\n          char innam[81];                       /* input file name         */\n          char *inptr;                          /* input record pointer    */\n          char outnam[81];                      /* output file name        */\n          char cntnam[81];                      /* count file name         */\n          char errnam[81];                      /* error file name         */\n\n          char inrecord[256];                   /* input file record area  */\n          char outrecord[256];                  /* output file record area */\n          char cntline[256];                    /* count file buffer       */\n          char errline[256];                    /* error file buffer       */\n          char hold_record[256];\n\n          int i;                                /* general purpose int     */\n          char number[32];                      /* ascii numbers for edit()*/\n          int morerecs = -1;                    /* input end-of-file switch*/\n          int record_waiting = 0;               /* record waiting switch   */\n          long incount = 0;                     /* input record counter    */\n          long outcount = 0;                    /* output record counter   */\n          long errcnt = 0;                      /* error record counter    */\n          long tlrcnt = 0;                      /* number from trailer rec */\n          int recdlen;                          /* input record length     */\n          struct tm *t;                         /* pointer to time struct  */\n          time_t seconds;                       /* current timer value     */\n\n\n          void main(int argc, char *argv[]) {\n                  initialize(argc, argv);       /* open files              */\n                  while(morerecs)               /* perform mainline        */\n                          mainline();           /*   while more records    */\n                  terminate();                  /* close files             */\n                  exit(0);                      /* quit                    */\n          }\n          /*****************************************************************/\n          /* mainline function: process input file until no more records.  */\n          /*****************************************************************/\n          void mainline(void) {\n            if((*inptr) == '\\f')       /* if 1st byte of record is formfeed*/\n                  inptr++;                    /*   step past it            */\n            if((*inptr) == '\\xFF')     /* if this is a trailer record      */\n                  trailrecd();                /*   go process it\n     */\n            else {                     /* otherwise                        */\n                  recdlen = strlen(inptr);    /* measure input record leng */\n                  if((recdlen == 8) ||\n                      ((recdlen == 9) && (inptr[7] == '\\x0D'))) { /* good? */\n                    for(i=0; i<7; i++) { /* check for 7 decimal digits     */\n                          if(isdigit(inptr[i])) /* if digit found          */\n                            ;                    /*    keep checking       */\n                          else                   /* if non-numeric found   */\n                            break;                   /*   quit checking    */\n                    }\n                    if(i == 7)                /*   if all numerics         */\n                          writerec();                /*     write record   */\n                  }\n                  else                        /*    otherwise              */\n                          writeerr();                /* write to error file*/\n            }\n            recdlen = 0;               /* clear for next read              */\n            while(!recdlen && morerecs) /* read next input record          */\n                  read_a_record();\n          }\n          /*****************************************************************/\n          /* initialization: open files, read first input record.          */\n          /*****************************************************************/\n          void initialize(int argc, char *argv[]) {\n                  if(argc == 5) {              /* if 5 parameters entered  */\n                    strcpy(&innam,argv[1]); /*       1) input prov filename*/\n                    strcpy(&outnam,argv[2]); /*      2) output prov filenam*/\n                    strcpy(&cntnam,argv[3]); /*      3) count file name    */\n                    strcpy(&errnam,argv[4])); } /* 4) error file name      */\n              else {                       /* otherwise incorrect invocation\n  */\n                    printf(\"\\nUsage is: \");    /*   show usage example     */\n                    printf(\"\\ncreatprv old_prv_file new_prv_file counts_file err\nor_file\\n \");\n                    exit(1); }                 /*   and exit abnormally    */\n            if((infile=fopen(innam,\"rb\")) == NULL) { /* open old provider  */\n                  printf(\"Can't open file %s.\\n\",innam); /* tell user      */\n                  exit(1); }                   /* and exit abnormally      */\n            if((outfile=fopen(outnam,\"wb\")) == NULL) { /* open new pror    */\n                  printf(\"Can't open file %s.\\n\",outnam); /* tell user     */\n                  exit(1); }                            /* abnormal exit   */\n            if((cntfile=fopen(cntnam,\"w\"))==NULL) { /* open count file     */\n                  printf(\"\\nCan't open the counts file.\\n\"); /* tell user  */\n                  exit(1); }                               /* abnormal exit*/\n            if((errfile=fopen(errnam,\"w\"))==NULL) { /* open error file     */\n                  printf(\"\\nCan't open the error file.\\n\");  /* tell user  */\n                  exit(1); }                      /* anormal exit          */\n            timezone = 5 * 60 * 60;          /* set local time for e.s.t   */\n            daylight = -1;                   /* indicate daylit sav time   */\n            time(&seconds);                  /* time in secs               */\n            t = localtime(&seconds);         /* local time to tm struct    */\n            sprintf(cntline,\"%2d/%2d/%2d\",((t->tm_mon)+1),t->tm_mday,t->tm_year)\n;\n            cntline[8] = '\\n';               /* terminal nl to count line  */\n            cntline[9] = '\\0';               /* terminal null to count line*/\n            writecnt();                      /* write date to count file   */\n            strcpy(inrecord,cntline);        /* copy date for error log fil*/\n            writeerr();                      /* write date to log file     */\n            errcnt--;                        /* deduct for date header     */\n            while(!recdlen && morerecs)      /* read next input record     */\n                  read_a_record();\n          }\n          /*****************************************************************/\n          /* process the trailer record.                                   */\n          /*****************************************************************/\n          void trailrecd() {\n            inptr++;                      /* step past the initial \\xFF    */\n            if((*inptr) == 'T') {         /* if 2nd byte is \"T\"            */\n                  tlrcnt = atol(inptr+1); /* convert trailer count         */\n                  if(tlrcnt == 0)         /* trailer count invalid?        */\n                    writeerr();           /*   write to error file         */\n                  else                    /* otherwise                     */\n                    incount--;            /* deduct trailer from input cnt */\n            }\n            else                          /* else if 2nd byte not \"T\"      */\n                  writeerr();             /*   invalid trailer record      */\n          }\n          /*****************************************************************/\n          /* read next input file record. at eof file, set morerecs switch.*/\n          /*****************************************************************/\n          void read_a_record(void) {\n                  if(record_waiting) {\n                          record_waiting = 0;\n                          strcpy(inrecord,hold_record);\n                  }\n                  else {\n                          if((fgets(inrecord,256,infile)) == NULL) {\n                                  morerecs = 0;\n                                  recdlen = 0;\n                          }\n                  }\n                  if(morerecs) {\n                          while((inrecord[0] == '\\n') || (inrecord[0] == '\\f'))\n                                  strcpy(inrecord,inrecord+1);\n                          recdlen = strlen(inrecord);\n                          if(recdlen > 8)\n                                  if(inrecord[7] == '\\f') {\n                                          record_waiting = -1;\n                                          strcpy(hold_record, inrecord+8);\n                                          inrecord[7] = '\\n';\n                                          inrecord[8] = '\\0';\n                                          recdlen = strlen(inrecord);\n                                  }\n                  }\n                  if(recdlen > 0 ) {\n                          incount++;\n                          inptr = inrecord;\n                  }\n          }\n          /*****************************************************************/\n          /* write a record to the output file                             */\n          /*****************************************************************/\n          void writerec() {\n            inptr[7] = '\\n';                 /* insure ending newline      */\n            inptr[8] = '\\0';                 /* insure terminating null    */\n            fputs(inptr,outfile);            /* write output record        */\n            outcount++;                      /* add 1 to records written   */\n          }\n          /*****************************************************************/\n          /* write a line to the counter file                              */\n          /*****************************************************************/\n          void writecnt() {\n            fputs(cntline,cntfile);          /* write counter file line    */\n          }\n          /*****************************************************************/\n          /* write a record to the error file                              */\n          /*****************************************************************/\n          void writeerr() {\n            if(inrecord[0] == '\\x1A')        /* if end of file             */\n              incount--;                            /* don't count it      */\n            else {\n              i = strlen(inrecord);            /* get input record length  */\n              if(inrecord[i-1] == '\\n')        /* if nl present            */\n                    ;                                 /*   do nothing      */\n              else {                           /* otherwise                */\n                    inrecord[i] = '\\n';               /*   add nl to end   */\n                    inrecord[i+1] = '\\0'; }           /*   reset terminator*/\n              fputs(inrecord,errfile);         /* write output record      */\n              errcnt++;                        /* add 1 to error record cnt*/\n            }\n          }\n          /*****************************************************************/\n          /* The edit function provides numeric report editing, including  */\n          /* leading zero suppression, check protection, floating $,       */\n          /* leading or trailing minus sign, insertion of commas, decimal  */\n          /* points and other non-numeric fields. The first parameter is   */\n          /* the address of the edited output, whose size will be the same */\n          /* as the pattern. The second parameter is the editing pattern,  */\n          /* which must be a null-terminated string containing the edit    */\n          /* pattern. The third is the number to be edited, a null-        */\n          /* terminated string containing only digits 0-9 except the first */\n          /* position, which is a -, if the number is negative. The        */\n          /* pattern may be up to 64 characters, and the number to be      */\n          /* edited may contain up to 32 characters. The number may not    */\n          /* contain more significant digits than there are digit select   */\n          /* characters in the pattern. If there are more digits selected  */\n          /* by the pattern than there are in the number, leading zeros    */\n          /* will be assumed. In the pattern, the first character may be:  */\n          /*    $ (floating dollar sign)                                   */\n          /*    * (check protection)                                       */\n          /*    - (floating minus sign)                                    */\n          /* The body of the edit pattern will be composed of digit select */\n          /* characters (z and 9) and other characters, handled as follows:*/\n          /*    z (zero suppression output is a blank in this position     */\n          /*      until significance is set by receipt of a significant    */\n          /*      digit or a 9 in the pattern. After significance is       */\n          /*      set, output is a digit from the number.)                 */\n          /*    9 (output is a digit from the number and significance      */\n          /*      is set, even if the digit is a leading zero.)            */\n          /*      other characters in the pattern will be output as-is     */\n          /*      after significance is set, but will be output as blanks  */\n          /*      before significance is set.                              */\n          /* Characters in the pattern following the last digit select will*/\n          /* be output as-is if the number is negative, otherwise output   */\n          /* will be blanks for these pattern positions.                   */\n          /*                                                               */\n          /* When * check protection is selected, output will be *, rather */\n          /* than blanks as mentioned above.                               */\n          /*                                                               */\n          /* An integer is returned to indicate success or errors:         */\n          /*                 0 = successful edit                           */\n          /*                 1 = pattern too long (over 64 characters)     */\n          /*                 2 = too many digits selected (over 32)        */\n          /*                 3 = no output digits selected in pattern      */\n          /*                 4 = number contains non-numeric data          */\n          /*                 5 = number has more digits than the pattern   */\n          /*                                                               */\n          /* Examples:                            nbr=             outf=   */\n          /*    err=edit(outf,\"zz,zz9.99-\",nbr);  0                  0.00  */\n          /*                                      123                1.23  */\n          /*                                      562983         5,629.83  */\n          /*                                      -4675             46.75- */\n          /*    err=edit(outf,\"$,$$$.$$\",nbr);    0                        */\n          /*                                      123               $1.23  */\n          /*                                      562983        $5,629.83  */\n          /*                                      -4675            $46.75  */\n          /*    err=edit(outf,\"***.**\",nbr);      0                        */\n          /*                                      123              **1.23  */\n          /*                                      562983   err= 5          */\n          /*                                      -4675            *46.75  */\n          /*    err=edit(outf,\"--,--9.99\",nbr);   0                  0.00  */\n          /*                                      123                1.23  */\n          /*                                      562983         5,629.83  */\n          /*                                      -46.75           -46.75  */\n          /*                                                               */\n          /* Author R Thornton April 1989                                  */\n          /*****************************************************************/\n          /**/\n          int edit(char output[], char pattern[], char number[]]) {\n            char float_val = ' ';\n            char fill_val = ' ';\n            char sign_val = ' ';\n            int signif = 0;\n            int psize = 0;\n            int pdig = 0;\n            int plast = 0;\n            int ndig = 0;\n            char nbr[33];\n            char ch= ' ';\n            int po=0;\n            int n=0;\n\n          /*****************************************************************/\n          /* examine pattern: set up float and fill, count size and digits */\n          /*****************************************************************/\n            if(((ch=pattern[00]) == '$') || (ch == '*') || (ch == '-'))\n              float_val = ch;\n            if(ch == '*')\n              fill_val = '*';\n            while((ch=pattern[po]) != '\\0') {\n              if((ch == 'z') || (ch == '9')) {\n                pdig++;\n                plast = po;\n              }\n              psize++;\n              po++;\n            }\n            if(psize > 63)\n              return(1);\n            if(pdig > 32)\n              return(2);\n            if(!pdig)\n              return(3);\n          /*****************************************************************/\n          /* examine number: set up sign, count digits, check numeric.     */\n          /* set error if more digits than pattern, move right justified   */\n          /*****************************************************************/\n            if(number[0] == '-') {\n              sign_val = '-';\n              n = 1;\n            }\n            while((ch=number[n]) != '\\0') {\n              if((ch < '0') || (ch > '9'))\n                return(4);\n              ndig++;\n              n++;\n            }\n            if(ndig > pdig)\n              return(5);\n            for(po=0;po<(pdig-ndig);po++)\n              nbr[po] = '0';\n            if(sign_val == ' ')\n              n = 0;\n            else\n              n=1;\n            for(;po<pdig;po++,n++)\n              nbr[po] = number[n];\n          /*****************************************************************/\n          /* scan across the pattern, setting the corresponding output     */\n          /* byte from pattern, fill, or amt depending on the pattern      */\n          /* character and state of significance.                          */\n          /*****************************************************************/\n            if(float_val != ' ') {\n              output[0] = ' ';\n              po = 1;\n            }\n            else\n              po = 0;\n            n = 0;\n            while((po <= plast)) {\n              ch = pattern[po];\n              if(ch == 'z') {\n                if(signif) {\n                  output[po] = nbr[n];\n                  n++;\n                }\n                else {\n                  if(nbr[n] == '0') {\n                    output[po] = fill_val;\n                    n++;\n                  }\n                  else {\n                    output[po] = nbr[n];\n                    signif = -1;\n                    n++;\n                    if(float_val == ' ')\n                      ;\n                    else\n                      if((float_val == '$') || (sign_val == '-'))\n                        output[po-1] = float_val;\n                  }\n                }\n              }\n              else if(ch == '9') {\n                output[po] = nbr[n];\n                if(!signif) {\n                  signif = -1;\n                  if(float_val == ' ')\n                    ;\n                  else\n                    if((float_val == '$') || (sign_val == '-'))\n                      output[po-1] = float_val;\n                }\n                n++;\n              }\n              else {\n                if(signif)\n                  output[po] = pattern[po];\n                else\n                  output[po] = fill_val;\n              }\n              po++;\n            }\n            while((ch=pattern[po]) != '\\0') {\n              if(sign_val == ' ')\n                output[po++] = fill_val;\n              else\n                output[po++] = pattern[po];\n            }\n            return(0);\n          }\n          /*****************************************************************/\n          /* termination: close files                                      */\n          /*****************************************************************/\n          void terminate() {\n            sprintf(number,\"%ld\",incount); /* cnvrt input file cnt to ascii*/\n            edit(cntline, \"zz,zzz,zz9\", number); /* edit number to cntline */\n            strcpy(cntline+10,\" input records read\\n\"); /* msg to count lin*/\n            writecnt();                    /* write count line             */\n            sprintf(number,\"%ld\",tlrcnt);  /* convert trailer cnt to ascii */\n            edit(cntline, \"zz,zzz,zz9\", number); /* edit number to cntline */\n            strcpy(cntline+10,\" trailer record count\\n\"); /* msg to cnt lin*/\n            writecnt();                    /* write count line             */\n            sprintf(number,\"%ld\",outcount); /* cnvrt output count to ascii */\n            edit(cntline, \"zz,zzz,zz9\", number); /* edit number to cntline */\n            strcpy(cntline+10,\" output records written\\n\"); /* msg to  line*/\n            writecnt();                    /* write count line             */\n            sprintf(number,\"%ld\",errcnt);  /* cnvrt error record count     */\n            edit(cntline, \"zz,zzz,zz9\", number); /* edit number to cntline */\n            strcpy(cntline+10,\" error records written\\n\"); /* msg to line  */\n            writecnt();                    /* write count line             */\n            if(incount == tlrcnt)          /* if input count = trailer cnt */\n                  strcpy(cntline, \"Input and trailer counts match\\n\");\n            else                           /* if not,                      */\n                  strcpy(cntline,\"ERROR==> Input and trailer counts do not match\n!! <==ERROR\\n\");\n            writecnt();                    /* write count line             */\n            strcpy(errline,cntline);       /* copy message to errline      */\n            writeerr();                    /* and write to error log fi    */\n            errcnt--;                      /* don't count messages         */\n            if(incount != (outcount + errcnt)) {  /* if input = output cnts*/\n                     strcpy(cntline,\"ERROR==> Input and output counts do not bal\nance!<==ERROR\\n\");\n              writecnt();                    /* write count line           */\n              strcpy(errline,cntline);       /* copy message to errline    */\n              writeerr();                    /* and write to error log file*/\n            }\n            fclose(infile);                /* close input provider file    */\n            fclose(outfile);               /* close output provider file   */\n            fclose(cntfile);               /* close count file             */\n            fclose(errfile);               /* close error log file         */\n          }\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "CREATSUB": {"ttr": 6661, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x01\\xe6\\x01\\xe6\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 486, "newlines": 486, "modlines": 0, "user": "BC0THOR"}, "text": "                    /*******************************************************/\n                    /*                     **** creatsub.c ****            */\n                    /*                                                     */\n                    /* File purification program for the subscriber file as*/\n                    /* received from the mainframe via JES2 RJE. Form feed */\n                    /* characters are removed. Each data record is checked */\n                    /* to insure it contains a 9-digit subscriber number   */\n                    /* followed by 6 spaces, a 4-digit gate number, a      */\n                    /* single character A, and an ending new-line          */\n                    /* character. The last record in the file is a trailer */\n                    /* record that begins with uppercase TRAILER followed  */\n                    /* by the file record count. The trailer record is     */\n                    /* written to the subcnt file and the count is used to */\n                    /* validate the number of records read from the input  */\n                    /* file. All good subscriber records are written to the*/\n                    /* new subscriber file, while error records are written*/\n                    /* to the error file.                                  */\n                    /* Author R Thornton February 1994                     */\n                    /*******************************************************/\n                    #include <stdio.h>\n                    #include <stdlib.h>\n                    #include <time.h>\n                    #include <ctype.h>\n\n                                         /* function prototypes */\n\n                    void initialize(int argc, char *argv[]]); /* initialize*/\n                    void mainline(void);         /* mainline               */\n                    void terminate(void);        /* termination            */\n                    void read_a_record(void);    /* read next record       */\n                    void writerec(void);         /* write record to output */\n                    void writecnt(void);         /* write to counts file   */\n                    void writeerr(void);         /* write error records    */\n                    void trailrecd(void);        /* process trailer record */\n                    int edit(char output[], char pattern[], char number[]);\n\n                    FILE *infile, *outfile, *cntfile, *errfile; /*file ptrs*/\n                    char innam[81];              /* input file name        */\n                    char *inptr, *scan;          /* input record pointer   */\n                    char outnam[81];             /* output file name       */\n                    char cntnam[81];             /* count file name        */\n                    char errnam[81];             /* error file name        */\n\n                    char inrecord[256];          /* input file record area */\n                    char outrecord[256];         /* output file record area*/\n                    char cntline[256];           /* count file buffer      */\n                    char errline[256];           /* error file buffer      */\n                    char hold_record[256];       /* temporary hold area    */\n\n                    int i;                       /* general purpose int    */\n                    int goodrec;                 /* valid record indicator */\n                    char number[32];             /* ascii numbers for edit */\n                    int morerecs = -1;           /* end-of-file switch     */\n                    int record_waiting = 0;      /* record waiting switch  */\n                    long incount = 0;            /* input record counter   */\n                    long outcount = 0;           /* output record counter  */\n                    long errcnt = 0;             /* error record counter   */\n                    long tlrcnt = 0;             /* trailer record count   */\n                    int recdlen;                 /* input record length    */\n                    struct tm *t;                /* pointer to time struct */\n                    time_t seconds;              /* current timer value    */\n\n                    void main(int argc, char *argv[]) {\n                      initialize(argc, argv);    /* open files             */\n                      while(morerecs)            /* perform mainline until */\n                        mainline();              /* no more records        */\n                      terminate();               /* close files            */\n                      exit(0);                   /* quit                   */\n                    }\n                    /*******************************************************/\n                    /* mainline function: process input file until eof.    */\n                    /*******************************************************/\n                    void mainline(void) {\n                      goodrec = -1;              /* set invalid record sw  */\n                      if((*inptr) == '\\f')       /* 1st byte is formfeed?  */\n                      inptr++;                   /*   yes, step past it    */\n                      if((*inptr) == 'T')        /* this is trailer record?*/\n                        trailrecd();             /*   yes, go process it   */\n                      else {                     /* otherwise              */\n                        recdlen = strlen(inptr); /*   input record length  */\n                        if(recdlen == 21)        /*   if 21 bytes long     */\n                          goodrec = 0;           /*    indicate good record*/\n                        else\n                          if((recdlen == 22) && (inptr[20] == '\\r')) /*good*/\n                            goodrec = 0;         /* if 22 bytes with \\r\\n  */\n\n                        if(goodrec) {            /* if good record:        */\n                          scan = inptr;          /*   set scan ptr to start*/\n                          for(i=0; i<9; i++,scan++) { /* ck 9 dec digits   */\n                            if(isdigit(*scan))   /* if digit found:        */\n                              ;                  /*  keep checking         */\n                            else                 /* if non-numeric found:  */\n                              break;             /*      quit checking     */\n                          }\n                        }\n                        if(i != 9)               /* if all are not numerics*/\n                          goodrec = 0;           /*     indicate bad record*/\n                        if(goodrec) {\n                          for(i=0; i<6; i++,scan++) { /*   ck for 6 blanks */\n                            if((*scan) == ' ')   /*     if blank  found    */\n                              ;                  /*       keep checking    */\n                            else                 /*  but if non-blank found*/\n                              break;             /*       quit checking    */\n                          }\n                        }\n                        if(i != 6)               /*  if all were not blanks*/\n                          goodrec = 0;           /*     indicate bad record*/\n                        if(goodrec) {\n                          for(i=0; i<4; i++,scan++) { /*   check for 4 decimal d\nigits */\n                            if(isdigit(*scan))   /*     if digit found     */\n                              ;                  /*       keep checking    */\n                            else                 /*       non-numeric:     */\n                              break;             /*         quit checking  */\n                          }\n                        }\n                        if(i != 4)               /* if all are not numerics*/\n                          goodrec = 0;           /*     indicate bad record*/\n                        if((*scan) != 'A')       /* if final char not an A */\n                          goodrec = 0;           /*     indicate bad record*/\n                        if(goodrec)              /* if good record         */\n                          writerec();            /*   write good output    */\n                        else                     /*    otherwise           */\n                          writeerr();            /*      write to error    */\n                      }\n                      recdlen = 0;               /* clear for next read    */\n                      while(!recdlen && morerecs) /* read next input record*/\n                      read_a_record();\n                    }\n                    /*******************************************************/\n                    /* initialization: open files, read first input record.*/\n                    /*******************************************************/\n                    void initialize(int argc, char *argv[]) {\n                      if(argc == 5) {            /* if 5 parms on cmd line */\n                        strcpy(&innam,argv[1]); /* 1) input file na    me  */\n                        strcpy(&outnam,argv[2])); /* 2) output file n  ame */\n                        strcpy(&cntnam,argv[3])); /* 3) count file na  me  */\n                        strcpy(&errnam,argv[4]); } /* 4) error file    name*/\n                      else {                     /* otherwise error        */\n                        printf(\"\\nUsage is: \");  /*   show usage example   */\n                        printf(\"\\ncreatsub old_sub_file new_sub_file counts_file\n error_file\\n\");\n                        exit(1);                 /*   and exit abnormally  */\n                      }\n                      if((infile=fopen(innam,\"rb\")) == NULL) {   /* open in*/\n                        printf(\"Can't open file %s.\\n\",innam); /* error    */\n                        exit(1);                 /* and exit abnormally    */\n                      }\n                      if((outfile=fopen(outnam,\"wb\")) == NULL) { /*open out*/\n                        printf(\"Can't open file %s.\\n\",outnam); /* error   */\n                        exit(1);                 /* and exit abnormally    */\n                      }\n                      if((cntfile=fopen(cntnam,\"w\"))==NULL) { /* open count*/\n                        printf(\"\\nCan't open the counts file.\\n\"); /* error*/\n                        exit(1);                 /* exit abnormally        */\n                      }\n                      if((errfile=fopen(errnam,\"w\"))==NULL) { /* open error*/\n                          printf(\"\\nCan't open the error file.\\n\"); /*error*/\n                  exit(1); }                     /* and exit abnormally    */\n            timezone = 5 * 60 * 60;              /* set local e.s.t time   */\n            daylight = -1;                       /* indicate daylit sav tim*/\n            time(&seconds);                      /* time in secs           */\n            t = localtime(&seconds);             /* local time to tm struct*/\n            sprintf(cntline,\"%2d/%2d/%2d\",((t->tm_mon)+1),t->tm_mday,t->tm_year)\n;\n            cntline[8] = '\\n';                   /* ending nl to count line*/\n            cntline[9] = '\\0';                   /* count line ending null */\n            writecnt();                          /* date to count file     */\n            strcpy(inrecord,cntline);            /* date for error log file*/\n            writeerr();                          /* write date to log file */\n            errcnt--;                            /* -1 for date header     */\n            while(!recdlen && morerecs)          /* read next input record */\n                  read_a_record();\n          }\n          /*****************************************************************/\n          /* process the trailer record.                                   */\n          /*****************************************************************/\n          void trailrecd() {\n            if(memcmp(inptr,\"TRAILER\",7) == 0) {  /* if TRAILER record     */\n                  tlrcnt = atol(inptr+7);        /* convert trailer count  */\n                  if(tlrcnt == 0)                /* if invalid count       */\n                    writeerr();                  /*   write to error file  */\n                  else                           /* otherwise              */\n                    incount--;                   /*   -1 for trailer       */\n            }\n            else                                 /* else if invalid trailer*/\n                  writeerr();                    /*  invalid trailer record*/\n          }\n          /*****************************************************************/\n          /* read next input file record. at eof, set morerecs switch.     */\n          /*****************************************************************/\n          void read_a_record(void) {\n                  if(record_waiting) {\n                          record_waiting = 0;\n                          strcpy(inrecord,hold_record);\n                  }\n                  else {\n                          if((fgets(inrecord,256,infile)) == NULL) {\n                                  morerecs = 0;\n                                  recdlen = 0;\n                          }\n                  }\n                  if(morerecs) {\n                          while((inrecord[0] == '\\n') || (inrecord[0] == '\\f'))\n                                  strcpy(inrecord,inrecord+1);\n                          recdlen = strlen(inrecord);\n                          if(recdlen > 21)\n                                  if(inrecord[20] == '\\f') {\n                                          record_waiting = -1;\n                                          strcpy(hold_record, inrecord+21);\n                                          inrecord[20] = '\\n';\n                                          inrecord[21] = '\\0';\n                                          recdlen = strlen(inrecord);\n                                  }\n                  }\n                  if(recdlen > 0 ) {\n                          incount++;\n                          inptr = inrecord;\n                  }\n          }\n          /*****************************************************************/\n          /* write a record to the output file                             */\n          /*****************************************************************/\n          void writerec() {\n            memcpy(outrecord,inptr,9);           /* subscriber number out  */\n            memcpy(outrecord+9,inptr+15,4);      /* gate number to output  */\n            outrecord[13] = '\\n';                /* terminate with newline */\n            outrecord[14] = '\\0';                /* set end of record      */\n            fputs(outrecord,outfile);            /* write output record    */\n            outcount++;                          /* records written +1     */\n          }\n          /*****************************************************************/\n          /* write a line to the counter file                              */\n          /*****************************************************************/\n          void writecnt() {\n            fputs(cntline,cntfile);              /* write counter file line*/\n          }\n          /*****************************************************************/\n          /* write a record to the error file                              */\n          /*****************************************************************/\n          void writeerr() {\n            if(inrecord[0] == '\\x1A')            /* if eof record          */\n              incount--;                         /*  don't count it        */\n            else {\n              i = strlen(inrecord);              /* get input record length*/\n              if(inrecord[i-1] == '\\n')          /* if nl present          */\n                    ;                            /*   do nothing           */\n              else {                             /* otherwise              */\n                    inrecord[i] = '\\n';          /*   add nl to end        */\n                    inrecord[i+1] = '\\0';        /*   reset ending null    */\n              }\n              fputs(inrecord,errfile);           /* write output record    */\n              errcnt++;                          /* error record count + 1 */\n            }\n          }\n          /*****************************************************************/\n          /* The edit function provides numeric report editing, including  */\n          /* leading zero suppression, check protection, floating $,       */\n          /* leading or trailing minus sign, insertion of commas, decimal  */\n          /* points and other non-numeric fields. The first parameter is   */\n          /* the address of the edited output, whose size will be the same */\n          /* as the pattern. The second parameter is the editing pattern,  */\n          /* which must be a true null-terminated string containing the    */\n          /* edit pattern. The third is the number to be edited, a null-   */\n          /* terminated string containing only digits 0-9 except the first */\n          /* position, which is a -, if the number is negative. The pattern*/\n          /* may be up to 64 characters, and the number to be edited may   */\n          /* contain up to 32 characters. The number may not contain more  */\n          /* significant digits than there are digit select characters in  */\n          /* the pattern. If there are more digits selected by the pattern */\n          /* than there are in the number, leading zeros will be assumed.  */\n          /* In the pattern, the first character may be:                   */\n          /*     $ (floating dollar sign)                                  */\n          /*     * (check protection)                                      */\n          /*     - (floating minus sign)                                   */\n          /* The body of the edit pattern will be composed of digit select */\n          /* characters (z and 9) and other characters, handled as follows:*/\n          /*     z (zero suppression output is a blank in this position    */\n          /*        until significance is set by receipt of a significant  */\n          /*        digit or a 9 in the pattern. After significance is     */\n          /*        set, output is a digit from the number.)               */\n          /*     9 (output is a digit from the number and significance     */\n          /*        is set, even if the digit is a leading zero.)          */\n          /*   other characters in the pattern will be output as-is after  */\n          /*        significance is set, but will be output as blanks      */\n          /*        before significance is set.                            */\n          /* Characters in the pattern following the last digit select will*/\n          /* be output as-is if the number is negative, otherwise output   */\n          /* will be blanks for these pattern positions.                   */\n          /*                                                               */\n          /* When * check protection is selected, output will be *, rather */\n          /* than blanks as mentioned above.                               */\n          /*                                                               */\n          /* An integer is returned to indicate success or errors:         */\n          /*                 0 = successful edit                           */\n          /*                 1 = pattern too long (over 64 characters)     */\n          /*                 2 = too many digits selected (over 32)        */\n          /*                 3 = no output digits selected in pattern      */\n          /*                 4 = number contains non-numeric data          */\n          /*                 5 = number has more digits than the pattern   */\n          /*                                                               */\n          /* Examples:                            nbr=             outf=   */\n          /*    err=edit(outf,\"zz,zz9.99-\",nbr);  0                0.00    */\n          /*                                      123              1.23    */\n          /*                                      562983       5,629.83    */\n          /*                                      -4675           46.75-   */\n          /*    err=edit(outf,\"$,$$$.$$\",nbr);    0                        */\n          /*                                      123             $1.23    */\n          /*                                      562983      $5,629.83    */\n          /*                                      -4675          $46.75    */\n          /*    err=edit(outf,\"***.**\",nbr);      0                        */\n          /*                                      123            **1.23    */\n          /*                                      562983   err = 5         */\n          /*                                      -4675          *46.75    */\n          /*    err=edit(outf,\"--,--9.99\",nbr);   0                0.00    */\n          /*                                      123              1.23    */\n          /*                                      562983       5,629.83    */\n          /*                                      -46.75         -46.75    */\n          /*                                                               */\n          /* Author R Thornton April 1989                                  */\n          /*****************************************************************/\n          /**/\n          int edit(char output[], char pattern[], char number[]]) {\n            char float_val = ' ';\n            char fill_val = ' ';\n            char sign_val = ' ';\n            int signif = 0;\n            int psize = 0;\n            int pdig = 0;\n            int plast = 0;\n            int ndig = 0;\n            char nbr[33];\n            char ch= ' ';\n            int po=0;\n            int n=0;\n\n          /*****************************************************************/\n          /* examine pattern: set up float and fill, count size and digits */\n          /*****************************************************************/\n            if(((ch=pattern[00]) == '$') || (ch == '*') || (ch == '-'))\n              float_val = ch;\n            if(ch == '*')\n              fill_val = '*';\n            while((ch=pattern[po]) != '\\0') {\n              if((ch == 'z') || (ch == '9')) {\n                pdig++;\n                plast = po;\n              }\n              psize++;\n              po++;\n            }\n            if(psize > 63)\n              return(1);\n            if(pdig > 32)\n              return(2);\n            if(!pdig)\n              return(3);\n          /*****************************************************************/\n          /* examine number: set up sign, count digits, check numeric.     */\n          /* set error if more digits than pattern, move right justified   */\n          /*****************************************************************/\n            if(number[0] == '-') {\n              sign_val = '-';\n              n = 1;\n            }\n            while((ch=number[n]) != '\\0') {\n              if((ch < '0') || (ch > '9'))\n                return(4);\n              ndig++;\n              n++;\n            }\n            if(ndig > pdig)\n              return(5);\n            for(po=0;po<(pdig-ndig);po++)\n              nbr[po] = '0';\n            if(sign_val == ' ')\n              n = 0;\n            else\n              n=1;\n            for(;po<pdig;po++,n++)\n              nbr[po] = number[n];\n          /*****************************************************************/\n          /* scan across the pattern, setting the corresponding output     */\n          /* byte from pattern, fill, or amt depending on the pattern      */\n          /* character and state of significance.                          */\n          /*****************************************************************/\n            if(float_val != ' ') {\n              output[0] = ' ';\n              po = 1;\n            }\n            else\n              po = 0;\n            n = 0;\n            while((po <= plast)) {\n              ch = pattern[po];\n              if(ch == 'z') {\n                if(signif) {\n                  output[po] = nbr[n];\n                  n++;\n                }\n                else {\n                  if(nbr[n] == '0') {\n                    output[po] = fill_val;\n                    n++;\n                  }\n                  else {\n                    output[po] = nbr[n];\n                    signif = -1;\n                    n++;\n                    if(float_val == ' ')\n                      ;\n                    else\n                      if((float_val == '$') || (sign_val == '-'))\n                        output[po-1] = float_val;\n                  }\n                }\n              }\n              else if(ch == '9') {\n                output[po] = nbr[n];\n                if(!signif) {\n                  signif = -1;\n                  if(float_val == ' ')\n                    ;\n                  else\n                    if((float_val == '$') || (sign_val == '-'))\n                      output[po-1] = float_val;\n                }\n                n++;\n              }\n              else {\n                if(signif)\n                  output[po] = pattern[po];\n                else\n                  output[po] = fill_val;\n              }\n              po++;\n            }\n            while((ch=pattern[po]) != '\\0') {\n              if(sign_val == ' ')\n                output[po++] = fill_val;\n              else\n                output[po++] = pattern[po];\n            }\n            return(0);\n          }\n          /*****************************************************************/\n          /* termination: close files                                      */\n          /*****************************************************************/\n          void terminate() {\n            sprintf(number,\"%ld\",incount);       /* convert input count    */\n            edit(cntline, \"zz,zzz,zz9\", number); /* edit number to cntline */\n            strcpy(cntline+10,\" input records read\\n\"); /* message to line */\n            writecnt();                          /* write count line       */\n            sprintf(number,\"%ld\",tlrcnt);        /* convert trailer count  */\n            edit(cntline, \"zz,zzz,zz9\", number); /* edit number to cntline */\n            strcpy(cntline+10,\" trailer record count\\n\"); /* msg to line   */\n            writecnt();                          /* write count line       */\n            sprintf(number,\"%ld\",outcount);      /* cnvrt out file count   */\n            edit(cntline, \"zz,zzz,zz9\", number); /* edit number to cntline */\n            strcpy(cntline+10,\" output records written\\n\"); /* msg to line */\n            writecnt();                          /* write count line       */\n            sprintf(number,\"%ld\",errcnt);        /* cnvrt error recd count */\n            edit(cntline, \"zz,zzz,zz9\", number); /* edit number to cntline */\n            strcpy(cntline+10,\" error records written\\n\"); /* msg to line  */\n            writecnt();                          /* write count line       */\n            if(incount == tlrcnt)                /* input ct = trailer ct  */\n                  strcpy(cntline, \"Input and trailer counts match\\n\"); /*ok*/\n            else                                 /* if not,                */\n                  strcpy(cntline,\"ERROR==> Input and trailer counts do not match\n!! <==ERROR\\n\");\n            writecnt();                          /* write count line       */\n            strcpy(errline,cntline);             /* copy message to errline*/\n            writeerr();                          /* and write to error     */\n            errcnt--;                            /* don't count messages   */\n            if(incount != (outcount + errcnt)) { /* if input = output count*/\n                     strcpy(cntline,\"ERROR==> Input and output counts do not bal\nance!<==ERROR\\n\");\n              writecnt();                        /* write count line       */\n              strcpy(errline,cntline);           /* copy message to errline*/\n              writeerr();                        /* and write to error log */\n            }\n            fclose(infile);                      /* close input file       */\n            fclose(outfile);                     /* close output file      */\n            fclose(cntfile);                     /* close count file       */\n            fclose(errfile);                     /* close error log file   */\n          }\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "CSECMCH2": {"ttr": 6915, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00Q\\x01\\x001_\\x01\\x02\\x12/\\x15\\x12\\x01F\\x01\\x19\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2000-11-10T00:00:00", "modifydate": "2002-05-02T15:12:51", "lines": 326, "newlines": 281, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* csecmch2.c */\n/*********************************************************************/\n/* Reads the UNMCHEL and UNMCHCS files output from program CSECTMCH  */\n/* after sorting the UNMCHCS file in member name order. This program */\n/* attempts to match the unmatched endevor element names in the      */\n/* UNMCHEL file to the member names in the UNMCHCS file. Only those  */\n/* UNMCHCS records are considered which have only a single member per*/\n/* csect. all input records are written to the element and csect     */\n/* files, respectively. Several tests are made on each record pair:  */\n/*  test0: (UNMCHCS file only) if there are multiple member segments */\n/*         the record is written with compare code = 0 and the next  */\n/*         record is read.                                           */\n/*  test1: Element name in the UNMCHEL record is compared to the     */\n/*         record having the lower value is written with compare     */\n/*         code set to 1 and the next record in that file is read.   */\n/*  test2: The element name in the UNMCHEL record is compared byte-  */\n/*         by byte with the csect name in the UNMCHCS record. If they*/\n/*         differ my one byte or less, the t2 indicator is set true. */\n/*  test3: The language field is compared between the UNMCHEL and    */\n/*         UNMCHCS records. If equal, the t3 indicator is set true.  */\n/* All output records will contain a compare code in position 9,     */\n/* containing the value:                                             */\n/* 0 = This CSECT record contains multiple member segments.          */\n/* 1 = This record failed test1. No further tests were made.         */\n/* 2 = This record passed test1, but failed tests 2 and 3.           */\n/* 3 = This record passed test1 and test3, but failed test2.         */\n/* 4 = This record passed test1 and test2, but failed test3.         */\n/* 5 = This record passed all three tests.                           */\n/*                                                                   */\n/* Author R Thornton Nov 2000                                        */\n/*********************************************************************/\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n/*********************************************************************/\n/* Function Prototypes                                               */\n/*********************************************************************/\nint main(void);                /* Executive control routine */\nvoid Initialization(void);     /* Initialization routine */\nvoid Process(void);            /* Process control routine */\nvoid Test1(void);              /* Routine to apply test1 */\nvoid Test2(void);              /* Routine to apply test2 */\nvoid Test3(void);              /* Routine to apply test3 */\nchar SetCode(void);            /* Routine to set compare code */\nint  ReadElement(void);        /* Routine to read the UNMCHEL file */\nint  ReadCsect(void);          /* Routine to read the UNMCHCS file */\nvoid WriteElement(void);       /* Routine to write the ELEMENT file */\nvoid WriteCsect(void);         /* Routine to write the CSECT file */\nvoid Terminate(void);          /* Termination routine */\n/*********************************************************************/\n/* Global data areas and file descriptions                           */\n/*********************************************************************/\nFILE *Unmchel, *Unmchcs, *Element, *Csect; /* define the file ptrs */\n\nstruct {                     /* UNMCHCS/CSECT data record */\n  char CCsect[8];             /* csect name */\n  char CMatch;                /* match code */\n  char CLang[3];              /* language: COB, ASM, ??? */\n  char CDsnInd[3];            /* dsname indicator: OUT, IMS, CIC, HCS\n                                  to indicate the endevor load library\n                                  containing the member */\n  char CMember[8];            /* member name */\n  char CRest[27962];          /* remaining DsnInd/Member pairs */\n} CsectRecord;\n\nstruct {                     /* UNMCHEL/ELEMENT data record */\n  char EElement[8];           /* Element name */\n  char ECode;                 /* Compare code */\n  char ELang[11];             /* Language descriptor */\n  char EFiller2;\n  char EEnvironment[8];       /* Environment name */\n  char EFiller3;\n  char ESystem[8];            /* System name */\n  char EFiller4;\n  char ESSname[8];            /* SubSystem name */\n  char EFiller5;\n  char EType[5];              /* Endevor type name */\n  char EFiller6;\n  char EPrcGrpName[8];        /* Endevor processor group name */\n  char EFiller7;\n  char EPrcName[8];           /* Endevor Processor name */\n  char EFiller8[9];\n} ElementRecord;\n\nint t1, t2, t3;                /* test result indicators */\nint CsectLeng = 80;            /* LRECL for current CSECT file record*/\nint CsectMax = 27988;          /* max LRECL for CSECT file */\nint ElementLeng = 80;          /* LRECL for ELEMENT file */\n\n/*********************************************************************/\n/* main(): this is the executive control routine                     */\n/*********************************************************************/\nint main(void) {               /* Executive control routine */\n  Initialization();              /* initialize for processing */\n  while(CsectLeng || ElementLeng) {\n    Process();                   /* process the files */\n  }\n  Terminate();                   /* terminate processing */\n  exit(0);                       /* relinquish control */\n}\n/*********************************************************************/\n/*                                                                   */\n/*********************************************************************/\nvoid Initialization(void) {    /* Initialization routine */\n  Unmchcs =(fopen(\"dd:UNMCHCS\",\"rb,type=record,recfm=VB,lrecl=27988\"));\n  if(ferror(Unmchcs)) {\n    perror(\"Unable to open UNMCHCS\");\n    exit(8);\n  }\n  Unmchel =(fopen(\"dd:UNMCHEL\",\"rb,type=record,recfm=FB,lrecl=80\"));\n  if(ferror(Unmchel)) {\n    perror(\"Unable to open UNMCHCS\");\n    exit(8);\n  }\n  Csect =(fopen(\"dd:CSECT\",\"wb,type=record,recfm=VB,lrecl=27988\"));\n  if(ferror(Csect)) {\n    perror(\"Unable to open CSECT\");\n    exit(8);\n  }\n  Element =(fopen(\"dd:ELEMENT\",\"wb,type=record,recfm=FB,lrecl=80\"));\n  if(ferror(Element)) {\n    perror(\"Unable to open ELEMENT\");\n    exit(8);\n  }\n  ReadCsect();                /* Read first UNMCHCS record */\n  ReadElement();              /* Read first UNMCHEL record */\n}\n/*********************************************************************/\n/* Process: match records on element name vs member name and write   */\n/* output records with appropriate match codes in positions 9.       */\n/*********************************************************************/\nvoid Process(void) {           /* Process control routine */\n  if((CsectLeng == 0) && (ElementLeng == 0)) goto Exit_pr;\n  if(CsectLeng > 26) {\n    CsectRecord.CMatch = '0';    /* set multiple member indicator */\n    WriteCsect();                /* write the CSECT record */\n    ReadCsect();                 /* Read next CSECT record */\n    goto Exit_pr;                /* go return */\n  }\n  Test1();                       /* compare member to element */\n  if(t1 == 0)  {                 /* member = element? */\n    Test2();                     /* yes, go compare csect:element */\n    Test3();                     /* go compare languages */\n    ElementRecord.EElement[8] = SetCode(); /* set match code in rec */\n    CsectRecord.CMatch = ElementRecord.EElement[8]; /* copy code */\n    WriteCsect();                /* write the CSECT record */\n    WriteElement();              /* write the ELEMENT record */\n    ReadCsect();                 /* read UNMCHCS record */\n    ReadElement();               /* read UNMCHEL record */\n    goto Exit_pr;\n  }\n  else   {\n    if(t1 < 0) {                   /* is element name low? */\n      ElementRecord.EElement[8] = '1'; /* show member != element */\n      WriteElement();              /* write the ELEMENT record */\n      ReadElement();               /* read UNMCHEL record */\n    }\n    else {\n      CsectRecord.CMatch = '1';    /* show member != element */\n      WriteCsect();                /* write the CSECT record */\n      ReadCsect();                 /* read UNMCHCS record */\n    }\n  }\nExit_pr:\n  return;\n}\n/*********************************************************************/\n/* Apply test1: compare Element name to Member name;                 */\n/*********************************************************************/\nvoid Test1(void) {             /* Routine to apply test1 */\n  t1 = memcmp(ElementRecord.EElement, CsectRecord.CMember, 8);\n  return;                      /* return */\n}\n/*********************************************************************/\n/* Apply test2: compare csect name to element name. If they differ   */\n/* by only 1 byte, set t2 true, else false.                          */\n/*********************************************************************/\nvoid Test2(void) {             /* Routine to apply test2 */\nint i,j,k=0,lc,le;\n  t2 = -1;                     /* assume t2 true */\n  if(CsectRecord.CCsect[0] != ElementRecord.EElement[0]) {\n    t2 = 0;                    /* 1st chars differ, t2 false */\n    return;\n  }\n  for(lc=0;lc<8;lc++)          /* count Csect name size */\n    if(CsectRecord.CCsect[lc] == ' ')\n      break;\n  for(le=0;le<8;le++)          /* count Element name size */\n    if(ElementRecord.EElement[le] == ' ')\n      break;\n  i = le - lc;                 /* compute length difference */\n  if(i < 0)\n    i = lc - le;\n  if(i > 1)  {                 /* lengths differ > 1, t2 false */\n    t2 = 0;\n    return;\n  }\n  for(i=1,j=1;i<8;i++,j++) {\n    if(j > 7)  break;\n    if(CsectRecord.CCsect[i] == ElementRecord.EElement[j])\n      continue;\n    else {\n      k++;\n      if(k > 1) {\n        t2 = 0;\n        return;\n      }\n      if(le == lc) {\n        continue;\n      }\n      else {\n        if(le > lc) {\n          i--;\n          continue;\n        }\n        else {\n          j--;\n          continue;\n        }\n      }\n    }\n  }\n}\n/*********************************************************************/\n/* Test3 compares the languages between the records.                 */\n/*********************************************************************/\nvoid Test3(void) {             /* Routine to apply test3 */\n  if(CsectRecord.CLang[0] == ElementRecord.EType[0])\n    t3 = 1;                    /* Same language, set to true */\n  else\n    t3 = 0;                    /* Unequal, set false */\n}\n/*********************************************************************/\n/* Return the record match code based on the three test results.     */\n/*********************************************************************/\nchar SetCode(void) {           /* Routine to set compare code */\n  if(t1 == 0) {\n    if(t2 && t3)  {\n      return('5');             /* t1, t2, t3 all true */\n    }\n    else   {\n      if(t2) {\n        return('4');          /* t1 and t2 true */\n      }\n      else  {\n        if(t3)   {\n          return('3');        /* t1 and t3 true */\n        }\n        else {\n          return('2');        /* only t1 true */\n        }\n      }\n    }\n  }\n  else  {\n    return('1');              /* t1 false */\n  }\n}\n/*********************************************************************/\n/* Read next record from the ELEMENT file                            */\n/*********************************************************************/\nint  ReadElement(void) {       /* Routine to read the UNMCHEL file */\n  int rc;\n  rc = fread(&ElementRecord, 1, 80, Unmchel); /* Read */\n  if(ferror(Unmchel)) {\n    perror(\"Error reading UNMCHEL file\");\n    exit(8);\n  }\n  if(feof(Unmchel)) {             /* test for end of file */\n    rc = 0;\n    ElementRecord.EElement[0] = '\\xFF'; /* setelement name high */\n  }\n  ElementLeng = rc;                /* set Element record length */\n  return(rc);\n}\n/*********************************************************************/\n/* Read next record from the UNMCHCS file                            */\n/*********************************************************************/\nint  ReadCsect(void)  {        /* Routine to read the UNMCHCS file */\nint rc;\n  rc = fread(&CsectRecord, 1, CsectMax, Unmchcs); /* Read */\n  if(ferror(Unmchcs)) {\n    perror(\"Error reading UNMCHCS file\");\n    exit(8);\n  }\n  if(feof(Unmchcs)) {             /* test for end of file */\n    rc = 0;\n    CsectRecord.CCsect[0] = '\\xFF'; /* set csect name high */\n    CsectRecord.CMember[0] = '\\xFF'; /* set member name high */\n  }\n  CsectLeng = rc;                  /* set Csect record length */\n  return(rc);\n}\n/*********************************************************************/\n/* Write current record to the ELEMENT file                          */\n/*********************************************************************/\nvoid WriteElement(void) {      /* Routine to write the ELEMENT file */\n  fwrite(&ElementRecord, 1, ElementLeng, Element); /* Write element */\n  if(ferror(Element)) {\n    perror(\"Error writing to the ELEMENT file\");\n    exit(8);\n  }\n  return;\n}\n/*********************************************************************/\n/* Write currect record to the CSECT file                            */\n/*********************************************************************/\nvoid WriteCsect(void) {        /* Routine to write the CSECT file */\n  fwrite(&CsectRecord, 1, CsectLeng, Csect); /* write CSECT file rec */\n  if(ferror(Element)) {\n    perror(\"Error writing to the CSECT file\");\n    exit(8);\n  }\n  return;\n}\n/*********************************************************************/\n/* Termination routine: close files and prepare to relinquish control*/\n/*********************************************************************/\nvoid Terminate(void) {         /* Termination routine */\n  fclose(Unmchel);               /* Close UNMCHEL file */\n  fclose(Unmchcs);               /* Close UNMCHCS file */\n  fclose(Csect);                /* Close CSECT file */\n  fclose(Element);              /* Close ELEMENT file */\n  return;\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "C2COMPCK": {"ttr": 6921, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00Y\\x01\\x01\\x01_\\x01\\x02\\x12/\\x15\\x14\\x015\\x013\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2001-01-15T00:00:00", "modifydate": "2002-05-02T15:14:59", "lines": 309, "newlines": 307, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* c2compck.c */\n/*****************************************************************/\n/* This program reads the file of EDGE machine friendly records  */\n/* for three versions of the COBOL II compiler and writes a      */\n/* comparison listing showing the differences.                   */\n/*                                                               */\n/* Author R Thornton jan 2001                                    */\n/*****************************************************************/\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n/*****************************************************************/\n/* Global Data Areas                                             */\n/*****************************************************************/\n/*********************************************************************/\n/*                    Edge Product Record Description                */\n/*  Machine Friendly file - C language format record definition      */\n/*  based on the 05/06/1997 version                                  */\n/*********************************************************************/\n/*********************************************************************/\n/*                    Edge Product Record Description                */\n/*  Machine Friendly file - C language format record definition      */\n/*  based on the 05/06/1997 version                                  */\n/*********************************************************************/\nstruct {\n/*           *****>  csect-data  <*****                              */\nchar Member[8];               /* member name */\nchar AddrMode;                /* addressing mode 2=24, 3=31, a=any   */\nchar ResidMode;               /* residence mode 2=24, 3=31, a=any    */\nchar Csect[8];                /* csect name                          */\nchar Compiler[10];            /* translator id, eg 5734-pl1          */\nchar CompilerVM[4];           /* translator version/mod              */\nchar CompileDate[5];          /* translation date yyddd              */\nchar CsectAmode;              /* csect amode 2=24, 3=31, a=any       */\nchar CsectRmode;              /* csect rmode 2=24, a=any             */\nchar CompType[2];             /* compiler type. potential values:    */\n                              /*        ar = assembler               */\n                              /*        cc = CICS interface          */\n                              /*        ci = ibm c/370               */\n                              /*        cl = lattice c               */\n                              /*        cm = common block            */\n                              /*        cr = cobol runtime           */\n                              /*        cs = sas/c                   */\n                              /*        c2 = vs cobol ii             */\n                              /*        c3 = cobol 370               */\n                              /*        di = db2 interface           */\n                              /*        fg = fortran g / g1          */\n                              /*        fh = fortran h / h - extended*/\n                              /*        fr = fortran runtime         */\n                              /*        fv = vs fortran              */\n                              /*        ii = IMS interface           */\n                              /*        nr = not recognized          */\n                              /*        pm = PL/I for MVS and vm     */\n                              /*        pr = PL/I runtime            */\n                              /*        pv = vs pascal               */\n                              /*        p1 = PL/I optimizer v1       */\n                              /*        p2 = PL/I optimizer v2       */\n                              /*        ur = assembler - identified  */\n                              /*        vs = os/vs cobol             */\n                              /*        v4 = cobol version 4         */\n/*                     *****> extended base portion <*****           */\nchar TimeDate;                /*      1 = contains time svc pattern  */\n                              /*      2 = contains stck instruction  */\n                              /*      3 = contains both              */\n                              /*      4 = cobol accept from date...  */\n                              /*      9 = cobol accept ...other...   */\nchar LmodAttr;                /* load module attributes              */\nchar EPName[8];               /* ext symbol at primary e.p. or mrmem */\nchar CsectSize[8];            /* size of this csect in decimal       */\nchar LoadLib[4];              /* data from /u parm                   */\nchar DateLinked[5];           /* date of last linkedit of module     */\n/*    *****> start of third block of machine record <*****           */\n/*           *****> language dependent fields <*****                 */\n/*      *****> VS COBOL II and COBOL / 370 fields <*****             */\nchar C2Ver[6];                /* vs cobol ii compiler version        */\nchar C2Lvl[4];                /* vs cobol ii user lvl info           */\nchar C2Dat[8];                /* date compiles mm/dd/yy              */\nchar filler1;                 /*                                     */\nchar C2Tim[8];                /* time compiled hh:mm:ss              */\n/*        *****> COBOL II and COBOL 370 only fields <*****           */\nchar C2Adv;                   /* 0=noadv, 1=adv                      */\nchar C2Quot;                  /* 0=quote, 1=apost                    */\nchar C22431;                  /* 0=data24, 1=data31                  */\nchar C2Deck;                  /* 0=nodeck, 1=deck                    */\nchar C2Dump;                  /* 0=nodump, 1=dump                    */\nchar C2Dyna;                  /* 0=nodynam, 1=dynam                  */\nchar C2Fast;                  /* 0=nofastsrt, 1=fastsrt              */\nchar C2Fdum;                  /* 0=nofdump, 1=fdump                  */\nchar C2Lib;                   /* 0=nolib, 1=lib                      */\nchar C2List;                  /* 0=nolist, 1=list                    */\nchar C2Map;                   /* 0=nomap, 1=map                      */\nchar C2Num;                   /* 0=nonum, 1=num                      */\nchar C2Obj;                   /* 0=noobj, 1=obj                      */\nchar C2Offs;                  /* 0=nooffset, 1=offset                */\nchar C2Opt;                   /* 0=nooptimize, 1=optimiz             */\nchar C2Stdd;                  /* 0=nooutdd, 1=outdd                  */\nchar C2Pfd;                   /* rel 1-2: 0=nopfdsgn, 1=pfdsgn       */\n/*                            /* rel 3: 0=numnpfd, 1=numpfd, 2=nummig*/\nchar C2Rent;                  /* 0=norent, 1=rent                    */\nchar C2Res;                   /* 0=nores, 1=res                      */\nchar C2Seq;                   /* 0=noseq, 1=seq                      */\nchar C2Size;                  /* 0=size(n), 1=size(max)              */\nchar C2Sour;                  /* 0=nosource, 1=source                */\nchar C2Ssrn;                  /* 0=nossrange, 1=ssrange              */\nchar C2Term;                  /* 0=noterm, 1=term                    */\nchar C2Test;                  /* 0=notest, 1=test                    */\nchar C2Trun;                  /* rel 1-2: 0=notrunc, 1=trunc         */\n/*                            /* rel 3: 0=truncopt, 1=trunc(std),    */\n/*                            /* 2 = trunc(bin)                      */\nchar C2Rw;                    /* 0=default, 1=userspec word          */\nchar C2Vbre;                  /* 0=novbref, 1=vbref                  */\nchar C2Xref;                  /* 0=noxref, 1=xref                    */\nchar C2Zwb;                   /* 0=nozwb, 1=zwb                      */\n/*          *****> following are rel 3 + only <*****                 */\nchar C2Cmp2;                  /* 0=nocmpr2, 1=cmpr2                  */\nchar C2Name;                  /* 0=noname, 1=name                    */\nchar C2Nmcl;                  /* 0=nmclpri, 1=nmclalt                */\nchar C2Dbcs;                  /* 0=nodbcs, 1=dbcs                    */\nchar C2Awo;                   /* 0=noawo, 1=awo                      */\n/*   *****> the following fields apply only to COBOL/370 <*****      */\nchar C3Eve;                   /* 0=noevents, 1=events                */\nchar C3Cur;                   /* 0=nocurrency, 1=currency            */\nchar C3Rmod;                  /* 0=rmode24, 1=rmode(any)             */\nchar C3Rsv1;                  /* reserved                            */\nchar C3Rsv2;                  /* reserved                            */\nchar C3Rsv3;                  /* reserved                            */\nchar C3Rsv4;                  /* reserved                            */\n/* *****> following field applies to all supported COBOL's <*****    */\nchar CobSm;                   /* 0=no sort/merge found, 1=sort/merge */\nchar CobDc;                   /* cobol dynamic calls found switch:   */\n/*                            /* 0= no dynamic calls found in module */\n/*                      1= call literal forced dynamic found         */\n/*                      2= call dataname found                       */\n/*                      3= call literal forced + call dataname       */\n/*                      4= capex optimizer call adder really 5,6,7   */\n/*                      5= capex call literal forced dynamic found   */\n/*                      6= capex call dataname found                 */\n/*                      7= capex call literal forced + call dataname */\n/* *****> following fields relate to version 4 and OS/VS COBOL <**** */\nchar C4Symd;                  /* 0=nosymdmp, 1=symdmp                */\nchar C4Flow;                  /* 0=noflow, 1=flow                    */\nchar C4Stat;                  /* 0=nostate, 1=state                  */\nchar C4Test;                  /* 0=notest, 1=test                    */\nchar C4Res;                   /* 0=nores, 1=res                      */\nchar C4Endj;                  /* 0=noendjob, 1=endjob                */\nchar C4O370;                  /* 0=obj360, 1=obj370                  */\nchar C4Copt;                  /* 0=compiler not opt., 1=optimized    */\nchar C4Caop;                  /* 0=not capex opt., 1=capex optimized */\nchar C4Cdet;                  /* 0=no capex dtect, 1=capex dtect     */\n/*         *****> following are os/vs only options <*****            */\nchar C4Coun;                  /* 0=no count option, 1=count          */\nchar C4Trac;                  /* 0=no trace option, 1=trace option   */\nchar C4Llvl;                  /* 1=langlvl1, 2=langlvl2              */\nchar C4Syso;                  /* tail char of sysou display ddname   */\nchar C4Rsv1;                  /* reserved                            */\nchar C4Rsv2;                  /* reserved                            */\nchar C4Rsv3;                  /* reserved                            */\n/*             *****> PL/I options <*****                            */\nchar P2Main;                  /* 1=proc options(main), 0=not         */\nchar P2Orde;                  /* 0=noreorder, 1=reorder              */\nchar P2Exec;                  /* 0=noexecops, 1=execops              */\nchar P2Cmpa;                  /* 1=cmpat(v1), 2=cmpat(v2)            */\nchar P2Grap;                  /* 0=nographic, 1=graphic              */\nchar P2Opt;                   /* 0=nooptimize, 1=optimize            */\nchar P2Inte;                  /* 0=nointerupt, 1=interupt            */\nchar P2Flow;                  /* 0=noflow, 1=flow                    */\nchar P2Coun;                  /* 0=nocount, 1=count                  */\nchar P2Test;                  /* 0=notest, 1=test                    */\nchar P2Syst;                  /* 1=CMS, 2=CMSTP, 3=MVS, 4=TSO,       */\n                              /* 5=CICS, 6=IMS                       */\nchar P2Csty;                  /* csect type: 1=compiler generated    */\n                              /* runtime csect, 2=external data csect*/\n                              /* 3=static data csect, 4=code csect   */\nchar filler2[32];             /* reserved                            */\n} mr;                         /* instance of machine friendlt record */\n\nstruct {                      /* output record description           */\n  char Member[8];             /* member name                         */\n  char filler1;\n  char Csect[8];              /* csect name                          */\n  char filler2;\n  char Amode;                 /* csect amode                         */\n  char filler3;\n  char Rmode;                 /* csect rmode                         */\n  char filler4;\n  char CompType[2];           /* compiler type                       */\n  char filler5;\n  char LmodAttr;              /* load module attributes              */\n  char filler6;\n  char CsectSize[8];          /* csect size                          */\n  char filler7;\n  char LoadLib[4];            /* load library identifier             */\n  char filler8[39];\n  } out;                      /* output record instance              */\n\nint InputRecords = 0;         /* Number input records                */\nint OutputRecords =0;         /* Number output records               */\nint MoreEdgeRecords = -1;     /* 0 = eof edge machine friendly file  */\nchar LastMember[9] = \"        \"; /* last member name used            */\nchar LastCsect[9] = \"        \"; /* last csect name used             */\nFILE *edgemr,*output1;        /* file pointers                    */\n/*****************************************************************/\n/* function prototypes                                           */\n/*****************************************************************/\nint main(void);                      /* executive control routine */\nvoid Initialize(void);               /* initialization routine */\nvoid Process(void);                  /* Processing routine */\nvoid ReadEdgeMR(void);               /* reads the EDGEMR file */\nvoid WriteOutput1(void);             /* writes the output1 file */\nvoid Terminate(void);                /* termination routine */\n/*****************************************************************/\n/* main() function: executive control                            */\n/*****************************************************************/\nint main(void) {\n  Initialize();                      /* initialize for Processing */\n  while(MoreEdgeRecords)             /* until edgemr is exhausted, */\n    Process();                       /*    Process records. */\n  Terminate();                       /* Terminate Processing */\n  return(0);\n}\n/*****************************************************************/\n/* Initialize(): initialization routine. opens files.            */\n/*****************************************************************/\nvoid Initialize(void) {\n  edgemr=fopen(\"dd:EDGEMR\",\"rb,type=record,recfm=fb,lrecl=200\");\n  if(edgemr == NULL) {\n    perror(\"\\ncan't open the EDGEMR file\");\n    exit(8);\n  }\n  output1=fopen(\"dd:OUTPUT1\",\"wb,type=record,recfm=fb,lrecl=80\");\n  if(output1 == NULL) {\n    perror(\"\\ncan't open the OUTPUT1 file\");\n    exit(8);\n  }\n  memset(&out, ' ', sizeof(out));\n}\n/*****************************************************************/\n/* Process: for each record in the ELEMENTS file for an in-house */\n/* module, format and write an output record.                    */\n/*****************************************************************/\nvoid Process(void) {\n  memset(&out, ' ', sizeof(out)); /* clear output record to blanks */\n  ReadEdgeMR();                  /* Read next EDGEMR record */\n  if(!MoreEdgeRecords) return;   /* Return if end of file */\n  if((memcmp(LastMember, mr.Member, 8)  == 0) &&\n     (memcmp(LastCsect, mr.Csect, 8)  == 0))\n    ;\n  else {\n    WriteOutput1();               /* write blank separator line */\n    memcpy(LastMember, mr.Member, 8);  /* save member name      */\n    memcpy(LastCsect, mr.Csect, 8);  /* save csect name */\n  }\n  memcpy(out.Member, mr.Member, 8); /* format output record... */\n  memcpy(out.Csect, mr.Csect,8);\n  out.Amode = mr.CsectAmode;\n  out.Rmode = mr.CsectRmode;\n  memcpy(out.CompType, mr.CompType, 8);\n  out.LmodAttr = mr.LmodAttr;\n  memcpy(out.CsectSize, mr.CsectSize, 8);\n  memcpy(out.LoadLib, mr.LoadLib, 4);\n  WriteOutput1();            /* write OutRec to output1 file */\n}\n/*****************************************************************/\n/* ReadEdgeMR() reads the next record from the EDGEMR file into  */\n/* the mr area. At end of file, the MoreEdgeRecords field is set */\n/* to zero (false).                                              */\n/*****************************************************************/\nvoid ReadEdgeMR(void) {\n  size_t EdgeRecLen;\n\n  EdgeRecLen=fread(&mr, 1,  255, edgemr);\n  if(ferror(edgemr)) {\n    perror(\"\\nError (ferror) reading EDGEMr file\");\n    exit(8);\n  }\n  if(feof(edgemr)) {\n    MoreEdgeRecords = 0;\n    return;\n  }\n  if(EdgeRecLen == 0) {\n    perror(\"\\nError (0 read) reading EDGEMR file\");\n    exit(8);\n  }\n  InputRecords++;\n}\n/*****************************************************************/\n/* WriteOutput1 writes the record in the OutRec area for the     */\n/* length given by the OutRecLen field to the OUTPUT1 file.      */\n/*****************************************************************/\nvoid WriteOutput1(void) {\n  fwrite(&out, 1,  sizeof(out), output1);\n  if(ferror(output1)) {\n    perror(\"\\nError (ferror) writing OUTPUT1 file\");\n    exit(8);\n  }\n  OutputRecords++;\n  memset(&out, ' ', sizeof(out));\n}\n/*****************************************************************/\n/* Terminate() closes the files and prepares for termination.    */\n/*****************************************************************/\nvoid Terminate(void) {\n  printf(\"%d Input Records Read.\\n\",InputRecords);\n  printf(\"%d Output Records Written.\\n\",OutputRecords);\n  fclose(edgemr);\n  fclose(output1);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DATECALC": {"ttr": 7172, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x16\\x01\\x02\\x11\\x9f\\x01\\x02\\x12/\\x15\\x18\\x00\\x15\\x00\\x17\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-02T15:18:16", "lines": 21, "newlines": 23, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* datecalc.c */\n/************************************************************/\n/* given a 2-digit year, prints the day of week for Jan 1st */\n/************************************************************/\n#include <stdio.h>\nmain()\n{\n int da,yr,i;\n\n yr = 89;\n while(yr != 0) {\n  printf(\"\\nEnter year (zero to quit) \");\n  scanf(\"%d\",&yr);\n  if(yr > 88) {\n    da=(((yr-89)+((yr-89)/4))%7); }\n  else {\n    da=(((yr+6)+((yr-1)/4))%7); }\n  printf(\"\\nFirst day of year is %d\",da);\n }\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "DAYJAN1": {"ttr": 7174, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00 \\x01\\x02\\x11\\x9f\\x01\\x02\\x12/\\x15\"\\x00\\x1f\\x00\\x19\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-02T15:22:20", "lines": 31, "newlines": 25, "modlines": 0, "user": "BC0THOR"}, "text": "/*************/\n/* dayjan1.c */\n/*****************************************************************/\n/* Calculates the day of week for January 1st of any year > 1752 */\n/*****************************************************************/\n#include <stdlib.h>\n#include <stdio.h>\n\nmain() {\n  int year=1993, z, w;\n  float l, p, z1, z2, z3, z4;\n  char daywk[8][10] = { \" \", \"Sunday\", \"Monday\", \"Tuesday\",\n      \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n\n  while(year) {\n printf(\"\\nEnter any 4-digit year > 1752 (zeros to end): \");\n scanf(\"%4d\",&year);\n if(year < 1753) {\n   printf(\"\\n Year must be > 1752\");\n   exit(0);\n }\n l = year - 1;\n p = l / 100;\n z1 = (int)(p/4);\n z2 = (int)(p);\n z3 = (int)((5 * l) / 4);\n z = 36 + z3 - z2 + z1;\n w = z - (7 * (z / 7)) + 1;\n printf(\"\\nDay of week is %s\",daywk[w]);\n  }\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "DAYRPT": {"ttr": 7176, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x02\\xb3\\x02\\xb3\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 691, "newlines": 691, "modlines": 0, "user": "BC0THOR"}, "text": "/*************************************************************************/\n/*                      **** dayrpt.c ****                               */\n/*                                                                       */\n/* First, reads a parameter file describing the report to be created.    */\n/* The parameter file is composed of simple ASCII text records up to a   */\n/* maximum of 255 bytes in length. Each record begins in column 1 and    */\n/* contains no imbedded blanks except when a quoted string is used. Any  */\n/* characters following the first blank in a record are considered to    */\n/* be comments. In the following record descriptions, the records must   */\n/* occur in the order shown. All upper case values must be typed         */\n/* exactly as shown beginning in column1 and must include the following  */\n/* equal sign. The data following must begin immediately after the =     */\n/* sign and continue with no blanks (except for quoted strings) until    */\n/* the end of the data. Comments may follow after 1 or more blanks. A    */\n/* quoted string must begin and end with \" symbols. All parameter file   */\n/* records are required. Following are the parameter records:            */\n/* INFILE=iiiiiiii        input file path and filename (length varies)   */\n/* OUTFILE=oooooooo       output file path and filename (length varies)  */\n/* TITLE=\"tttttttt\"       report heading line (1 to 77 characters)       */\n/* DATE=yyyy.mm.dd        report date (see note 2)                       */\n/* START=hh:mm            start time hour and minute (see note 3)        */\n/* END=hh:mm              end hour and minute (see note 3)               */\n/* REC1=@@@@@@@@          record to be selected for column 1 (see note 4)*/\n/* COL1=\"ttttttt\"         title for report column 1 (22 characters max)  */\n/* REC2=@@@@@@@@          record to be selected for column 2 (see note 4)*/\n/* COL2=\"ttttttt\"         title for report column 2 (22 characters max)  */\n/* REC3=@@@@@@@@          record to be selected for column 3 (see note 4)*/\n/* COL3=\"ttttttt\"         title for report column 3 (22 characters max)  */\n/* Notes: 1) The records for REC3 and COL3 can be omitted for 1 and 2    */\n/*           column reports, and REC2 and COL2 can be omitted for 1      */\n/*           column reports.                                             */\n/*        2) If the report contains only one day the DATE record can be  */\n/*           omitted.                                                    */\n/*        3) The time parameters must be 5 characters long: a 2-digit    */\n/*           hour 00-23, a colon (:), and a two-digit minute, 00 or 30.  */\n/*        4) The REC records specify the exact literal in the records to */\n/*           be selected for the report, and must be exactly as recorded */\n/*           in the records. At this time, you may enter (all capitals): */\n/*           HMO_INTRO_HKP_P                                             */\n/*           HMO_INTRO_RICH_P                                            */\n/*           PRVDR_INTRO_P                                               */\n/*           VA_INTRO_SSBU                                               */\n/*        5) Any line beginning with an * is ignored and may contain any */\n/*           desired text: a comment line.                               */\n/*                                                                       */\n/* This program reads the daily DirectTalk statistics file containing    */\n/* call statistics at 30 minute intervals for DirectTalk applications.   */\n/* All records for the specified REC parameter records between the times */\n/* specified by the START and END parameters are used for the report.    */\n/* The report may contain call data for 1, 2, or 3 different applications*/\n/* and the data is collected in a table. After the file is exhausted, the*/\n/* report is written using information stored in the table.              */\n/*                                                                 */\n/* To execute the dayrpt program, the command line must contain the path */\n/* and name of the parameter file. The parameter file is a simple ASCII  */\n/* text file as described above. A command line example is:              */\n/*                                                                       */\n/*     dayrpt /home/devback/hold/va_report_parms                         */\n/*                                                                       */\n/* Author R Thornton March 1995                                          */\n/*************************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <string.h>\n\nvoid initialize(int argc, char *argv[]);  /* initialization function */\nvoid process_parms(void);             /* process parameter file */\nvoid readparm(void);                  /* read parameter file */\nvoid col_parms(void);                 /* process COLx= parameter records */\nvoid infile_parm(void);               /* process INFILE= parameter record */\nvoid outfile_parm(void);              /* process OUTFILE= parameter record */\nvoid title_parm(void);                /* process TITLE= parameter record */\nvoid date_parm(void);                 /* process DATE= parameter record */\nvoid time_parm(void);                 /* process START= and END= parm recs */\nvoid rec_parms(void);                 /* process RECx= parameter records */\nvoid mainline(void);                  /* mainline function */\nvoid readrec(void);                   /* read next input file record */\nvoid terminate(void);                 /* termination function */\n\nFILE *infile, *rptfile, *parmfile;    /* file pointers */\nchar innam[81];                       /* input file name */\nchar rptnam[81];                      /* report file name */\nchar parmnam[81];                     /* parameter file name */\n\nchar inrecord[256];                   /* input file record area */\nchar parmrec[256];                    /* parameter file record area */\n\nchar rec1_title[81];                  /* record type for report col 1 */\nint rec1_leng;                        /* length of rec1_title */\nchar rec2_title[81];                  /* record type for report col 2 */\nint rec2_leng;                        /* length of rec2_title */\nchar rec3_title[81];                  /* record type for report col 3 */\nint rec3_leng;                        /* length of rec3_title */\nchar report_date[11];                 /* report date from parm or 1st rec */\nint begin_sub;                        /* report begin subscript */\nint end_sub;                          /* report end subscript */\n\nint record_sub;                       /* input record subscript */\nint record_count;                     /* input record count */\n\nint col1,col2,col3;                   /* non-zero if report column present */\nint rec1,rec2,rec3;                   /* non-zero if column header present */\nint table_counter[3][48];             /* table of record counts */\n\nchar h1[80];                          /* header line 1 */\nchar h2[80];                          /* header line 2 */\nchar h3[80];                          /* header line 3 */\nchar h4[80];                          /* header line 4 */\nchar h5[80];                          /* header line 4 for graph */\nchar t1[80];                          /* total line 1 */\nchar t2[80];                          /* combined total line */\nchar rpt[80];                         /* detail report line */\n\nint hour,min;                         /* hour and minute work areas */\nlong c1_total,c2_total,c3_total;      /* column 1,2,3 total counters */\nint c1_max,c2_max,c3_max;             /* max value for each column */\nint i,j,k,l;                          /* general purpose ints */\nint parm_error;                       /* non-zero if parameter file error */\nchar work_string[16];                 /* g.p. work string */\nint morerecs = -1;                    /* input end-of-file switch */\nint moreparms = -1;                   /* parmfile end-of-file-switch */\n\nstruct tm *t;                         /* pointer to time structure */\ntime_t seconds;                       /* current timer value */\n\n\n/**********************************************************************/\n/* executive control function: overall program control                */\n/**********************************************************************/\nvoid main(int argc, char *argv[]) {\n initialize(argc, argv);       /* open files */\n while(morerecs)               /* perform mainline until */\n  mainline();               /* no more records */\n terminate();                  /* close files */\n exit(0);                      /* quit */\n}\n/**********************************************************************/\n/* mainline function: process input file until no more records.       */\n/**********************************************************************/\nvoid mainline(void) {\n  if(memcmp(inrecord+2,report_date,10)) {  /* compare dates */\n    readrec();                        /* wrong date, read again */\n    return;                           /* and continue */\n  }\n  if(col1 && !(memcmp(inrecord+22,rec1_title,rec1_leng))) { /* col1 record */\n    k = 0;                            /* set table subscript to 0 */\n    l = rec1_leng + 23;               /* offset to count field */\n  }\n  else if(col2 &&\n      !(memcmp(inrecord+22,rec2_title,rec2_leng))) { /* col2 record */\n    k = 1;                            /* set table subscript to 1 */\n    l = rec2_leng + 23;               /* offset to count field */\n  }\n  else if(col3 &&\n      !(memcmp(inrecord+22,rec3_title,rec3_leng))) { /* col3 record */\n    k = 2;                            /* set table subscript to 2 */\n    l = rec3_leng + 23;               /* offset to count field */\n  }\n  else {\n    readrec();                      /* none of the above, read again */\n    return;                         /* and continue */\n  }\n  memcpy(work_string,inrecord+13,2);  /* get record hour */\n  work_string[2] = '\\0';              /* terminate the string */\n  i = atoi(work_string);              /* make it an integer */\n  record_sub = i * 2;                 /* compute record subscript */\n  memcpy(work_string,inrecord+16,2);  /* get record minutes */\n  work_string[2] = '\\0';              /* terminate the string */\n  i = atoi(work_string);              /* convert it to integer */\n  if(i)                               /* if xx:30 time */\n  record_sub ++;                      /* add 1 to total */\n  if((record_sub < begin_sub) || (record_sub > end_sub)) {\n    readrec();                        /* read next record */\n    return;                           /* and continue */\n  }\n  record_count = 0;                   /* pre-clear count */\n\n  for(i=l;i<42;i++)                   /* locate end of counter */\n    if(inrecord[i] == ',') {          /* if at ending comma */\n      inrecord[i] = '\\0';                /* change it to null */\n      record_count = atoi(inrecord+l);   /* convert to integer */\n      break;                             /* and exit the loop */\n    }\n\n  table_counter[k][record_sub] = record_count; /* record count to table */\n  readrec();                          /* read next input record */\n}\n/**********************************************************************/\n/* initialization: initialize areas, process parameters, build headers*/\n/* open files, read 1st input record                                  */\n/**********************************************************************/\nvoid initialize(int argc, char *argv[]) {\n  innam[0] = '\\0';                     /* null input file name */\n  rptnam[0] = '\\0';                    /* null report file name */\n  rec1_title[0] = '\\0';                /* null 1st record type */\n  rec2_title[0] = '\\0';                /* null 2nd record type */\n  rec3_title[0] = '\\0';                /* null 3rd record type */\n  report_date[0] = '\\0';               /* null report date field */\n\n  memset(h1,' ',77); strcpy(h1+77,\"\\r\\n\"); /* clear heading line 1 */\n  h1[0] = '\\0';                            /* null out h1 */\n\n  memset(h2,' ',77); strcpy(h2+77,\"\\r\\n\"); /* clear heading line 2 */\n  memcpy(h2,\"Report Date:\",12);            /* literal to header line 2 */\n  memcpy(h2+57,\"Run Date:\",9);             /* literal to header line 2\n  timezone = 5 * 60 * 60;                  /* set local time for e.s.t */\n  daylight = -1;                           /* indicate daylit sav time */\n  time(&seconds);                          /* time in secs */\n  t = localtime(&seconds);                 /* local time to tm struct */\n  sprintf(&h2[67],\"%4d.%02d.%02d\",t->tm_year, t->tm_mon+1, t->tm_mday);\n  if(h2[69] == '9')                        /* if in the 1990's */\n    memcpy(h2+67,\"19\",2);                  /* set century to 19 */\n  else                                     /* otherwise */\n    memcpy(h2+67,\"20\",2);                  /* set century to 20 */\n  h2[77] = '\\r';                           /* reset trailing carr rtrn */\n\n  memset(h3,' ',77); strcpy(h3+77,\"\\r\\n\"); /* clear heading line 3 */\n  memcpy(h3,\"Inclusive Times:\",16);        /* literal to header 3 */\n  memcpy(h3+23,\"to\",2);                    /* literal to header 3 */\n\n  memset(h4,' ',77); strcpy(h4+77,\"\\r\\n\"); /* clear heading line 4 */\n  memcpy(h4+1,\"Time\",4);                   /* literal to header 4 */\n\n  memset(t1,' ',77); strcpy(t1+77,\"\\r\\n\"); /* clear total line 1 */\n  memcpy(t1+1,\"Totals\",6);                 /* literal to total line */\n\n  memset(t2,' ',77); strcpy(t2+77,\"\\r\\n\"); /* clear combined total line */\n  memcpy(t2+1,\"Combined Total\",14);       /* literal to combined total line */\n\n  memset(rpt,' ',77); strcpy(rpt+77,\"\\r\\n\"); /* clear detail report line */\n\n  if(argc == 2) {                        /* if only one command line arg */\n    strcpy(parmnam,argv[1]);             /* copy parameter file name */\n    if((parmfile=fopen(parmnam,\"rb\")) == NULL) { /* open parameter file */\n      printf(\"Can't open parameter file %s.\",parmnam); /* open failed */\n      exit(1);\n    }                                    /* terminate in error */\n  }\n  else {\n    printf(\"\\Command line must contain only parameter file name.\");\n    exit(1);\n  }\n\n  readparm();                            /* read first parameter record */\n  while(moreparms)                       /* process parameter file */\n  process_parms();                         /* process each parameter */\n  if(parm_error)                         /* if any parameter error found */\n    exit(1);                               /* just terminate */\n\n  if(begin_sub >= end_sub) {\n    printf(\"\\nBegin time must be before end time, correct parameter file\");\n    printf(\"\\nPossibly missing or incorrect START= or END= record.\");\n    parm_error = 1;\n  }\n  if(h1[0] == '\\0') {\n    printf(\"\\nMissing TITLE= parameter record. Add it to parameter file.\");\n    parm_error = 1;\n  }\n  if(innam[0] == '\\0') {\n    printf(\"\\nMissing INFILE= parameter record. Add it to parameter file.\");\n    parm_error = 1;\n  }\n  if(rptnam[0] == '\\0') {\n    printf(\"\\nMissing OUTFILE= parameter record. Add it to parameter file.\");\n    parm_error = 1;\n  }\n  if(!(rec1 || rec2 || rec3)) {\n    printf(\"\\nParameter file must contain at least 1 selection record: \");\n    printf(\"\\nAdd a REC1=, REC2=, and/or REC3= record to parameter file\");\n    parm_error = 1;\n  }\n  if(!(col1 || col2 || col3)) {\n    printf(\"\\nParameter file must contain at least 1 column header record.\");\n    printf(\"\\nAdd a COL1=, COL2=, and/or COL3= record to parameter file\");\n    parm_error = 1;\n  }\n  if(rec1 != col1) {\n    printf(\"\\nIf REC1= is used, COL1= must also given and vice-cersa.\");\n    printf(\"\\nCorrect the parameter file to include both or neither.\");\n    parm_error = 1;\n  }\n  if(rec2 != col2) {\n    printf(\"\\nIf REC2= is used, COL2= must also given and vice-cersa.\");\n    printf(\"\\nCorrect the parameter file to include both or neither.\");\n    parm_error = 1;\n  }\n  if(rec3 != col3) {\n    printf(\"\\nIf REC3= is used, COL3= must also given and vice-cersa.\");\n    printf(\"\\nCorrect the parameter file to include both or neither.\");\n    parm_error = 1;\n  }\n  if(parm_error)                        /* if any errors, quit */\n    exit(1);\n  if((infile=fopen(innam,\"rb\")) == NULL) { /* open input */\n printf(\"Can't open input file %s.\",innam);\n exit(1);                           /* terminate in error */\n  }\n  if((rptfile=fopen(rptnam,\"wb\"))==NULL) { /* open print file */\n    printf(\"\\nCan't open the printer file.\");\n exit(1);                          /* terminate in error */\n  }\n  memcpy(&h2[13],report_date,10); /* report date to header line */\n\n  readrec();             /* read first input file record */\n\n  if(report_date[0] == '\\0')              /* if no DATE= parm received */\n    memcpy(report_date,inrecord+2,10);       /* use date in 1st record */\n  memcpy(h2+13,report_date,10);           /* report date to header 2 */\n}\n/**********************************************************************/\n/* process parameter file records.                                    */\n/**********************************************************************/\nvoid process_parms(void) {\n  if(!(memcmp(parmrec,\"COL\",3)))          /* if COL1= or COL2= or COL3= */\n    col_parms();                          /* process COL records */\n  else if(!(memcmp(parmrec,\"INFILE=\",7))) /* if INFILE= */\n    infile_parm();                         /* process INFILE= record */\n  else if(!(memcmp(parmrec,\"OUTFILE=\",8))) /* if OUTFILE= */\n    outfile_parm();                       /* process OUTFILE= record */\n  else if(!(memcmp(parmrec,\"TITLE=\\\"\",7)))  /* if TITLE= */\n    title_parm();                         /* process TITLE= record */\n  else if(!(memcmp(parmrec,\"DATE=\",5)))   /* if DATE= */\n    date_parm();                          /* process DATE= record */\n  else if(!(memcmp(parmrec,\"START=\",6)))  /* if START= */\n    time_parm();                          /* process START= record */\n  else if(!(memcmp(parmrec,\"END=\",4)))    /* if END= */\n    time_parm();                          /* process END= record */\n  else if(!(memcmp(parmrec,\"REC\",3)))     /* if REC record */\n    rec_parms();                          /* process REC records */\n  else if(!((parmrec[0]=='*')||(parmrec[0]=='\\r')||(parmrec[0]=='\\n'))) {\n    printf(\"\\nThe following parameter file record is unidentifiable: \\n\");\n    printf(\"%s\",parmrec);\n    parm_error = 1;                       /* indicate error found in parms */\n  }\n  readparm();                             /* read next parmameter record */\n}\n/**********************************************************************/\n/* process the COL1=, COL2=, and COL3= parameter records              */\n/**********************************************************************/\nvoid col_parms(void) {\n  if((memcmp(parmrec+3,\"1=\\\"\",3)) &&\n     (memcmp(parmrec+3,\"2=\\\"\",3)) &&\n     (memcmp(parmrec+3,\"3=\\\"\",3))) {\n       printf(\"\\nThe following parameter file record is unidentifiable: \\n\");\n       printf(\"%s\",parmrec);\n       parm_error = 1;                    /* indicate error found in parms */\n  }\n  for(i=6;i<29;i++)                       /* find right end of literal */\n    if(parmrec[i] == '\\\"')                   /* if ending quote found */\n      break;                                    /* break out of loop */\n  if(i == 29) {\n    printf(\"\\nThe following column header exceeds 22 characters: \\n\");\n    printf(\"%s\",parmrec);\n    parm_error = 1;                       /* indicate error found in parms */\n    return;                               /* return */\n  }\n\n  if(parmrec[3] == '1') {                 /* if COL1= record */\n    j = 27;                                  /* column header ends at 27 */\n    col1 = 1;                                /* show COL1= received */\n  }\n  else if(parmrec[3] == '2') {            /* if COL2= record */\n    j = 51;                                  /* column header ends at 51 */\n    col2 = 1;                                /* show COL2= received */\n  }\n  else {                                  /* if COL3= record */\n    j = 76;                                  /* column header ends at 76 */\n    col3 = 1;                                /* show COL3= received */\n  }\n  i--;                                    /* back up before ending quote */\n  for(;i>5;i--,j--)                       /* move column header to h4 in */\n    h4[j] = parmrec[i];                      /* a right-to-left direction */\n}\n/**********************************************************************/\n/* process the INFILE= parameter record                               */\n/**********************************************************************/\nvoid infile_parm(void) {\n  for(i=7;i<87;i++) {\n    if(parmrec[i] <= ' ')                 /* found a blank or ctl char? */\n      parmrec[i] = '\\0';                  /* yes, make it a null */\n    if(parmrec[i] == '\\0')                /* found end of name? */\n      break;                              /* yes, break out of loop */\n  }\n  if(i == 87) {                           /* no end of name found */\n    printf(\"\\nThe following record has filename > 80 characters: \\n\");\n    printf(\"%s\",parmrec);\n    parm_error = 1;                       /* indicate error found in parms */\n    return;                               /* return */\n  }\n  strcpy(innam,parmrec+7);                /* move input file name */\n}\n/**********************************************************************/\n/* process the OUTFILE= parameter record                              */\n/**********************************************************************/\nvoid outfile_parm(void) {\n  for(i=8;i<88;i++) {\n    if(parmrec[i] <= ' ')                 /* found a blank or ctl char? */\n      parmrec[i] = '\\0';                  /* yes, make it a null */\n    if(parmrec[i] == '\\0')                /* found end of name? */\n      break;                              /* yes, break out of loop */\n  }\n  if(i == 88) {                           /* no end of name found */\n    printf(\"\\nThe following record has filename > 80 characters: \\n\");\n    printf(\"%s\",parmrec);\n    parm_error = 1;                       /* indicate error found in parms */\n    return;                               /* return */\n  }\n  strcpy(rptnam,parmrec+8);               /* move input file name */\n}\n/**********************************************************************/\n/* process the TITLE= parameter record                                */\n/**********************************************************************/\nvoid title_parm(void) {\n  for(i=7;i<83;i++)                       /* find right end of literal */\n    if(parmrec[i] == '\\\"')                   /* if ending quote found */\n      break;                                    /* break out of loop */\n  if(i == 83) {\n    printf(\"\\nThe following title line exceeds 76 characters: \\n\");\n    printf(\"%s\",parmrec);\n    parm_error = 1;                       /* indicate error found in parms */\n    return;                               /* return */\n  }\n  i -= 7;                                 /* actual title literal length */\n  j=(76 - i)/2;                           /* compute centering subscript */\n  h1[0] = ' ';                            /* un-null h1 */\n  memcpy(h1+j,parmrec+7,i);               /* move title to h1 header line */\n}\n/**********************************************************************/\n/* process the DATE= parameter record                                 */\n/**********************************************************************/\nvoid date_parm(void) {\n  char work[8];\n\n  int error = 0;\n  if(!((parmrec[9] != '.') || (parmrec[12] != '.') || (parmrec[15] <= ' ')))\n    error = 1;\n  if((memcmp(parmrec+5,\"199\",3)) && (memcmp(parmrec+5,\"20\",2)))\n    error = 1;\n  memcpy(work,parmrec+5,4);               /* move year yyyy to work */\n  memcpy(work+4,parmrec+10,2);            /* move month mm to work */\n  memcpy(work+6,parmrec+13,2);            /* move day dd to work */\n  for(i=0;i<8;i++)\n    if((work[i] < '0') || (work[i] > '9')) /* valid numeric digit? */\n      error = 1;                             /* no, set error */\n  if((memcmp(work+4,\"01\",2) < 0) || (memcmp(work+4,\"12\",2) > 0))\n    error = 1;\n  if((memcmp(work+6,\"01\",2) < 0) || (memcmp(work+6,\"31\",2) > 0))\n    error = 1;\n  if(error) {                             /* any error found? */\n    printf(\"\\nThe following parameter yyyy.mm.dd date is in error: \\n\");\n    printf(\"%s\",parmrec);\n    parm_error = 1;                       /* indicate error found in parms */\n  }\n  else {                                  /* if no error */\n    memcpy(report_date,parmrec+5,10);        /* copy date to report_date */\n    memcpy(h2+13,parmrec+5,10);              /* and to h2 header line */\n  }\n}\n/**********************************************************************/\n/* process START= and START= and END= parameter records               */\n/**********************************************************************/\nvoid time_parm(void) {\n  char work[4];\n  int error = 0;\n\n  if(parmrec[0] == 'S')                   /* if START= record */\n    i = 6;                                   /* begin at column 7 */\n  else                                    /* else */\n    i = 4;                                   /* at column 5 */\n  if(parmrec[i+2] != ':')                 /* valid hour:minute delimiter? */\n    error = 1;                               /* no, error */\n  memcpy(work,parmrec+i,2);               /* move hours hh to work */\n  memcpy(work+2,parmrec+i+3,2);           /* move minutes mm to work */\n  for(j=0;j<4;j++)\n    if((work[j] < '0') || (work[j] > '9')) /* test numeric */\n      error = 1;\n  if((memcmp(work,\"00\",2) < 0) || (memcmp(work,\"23\",2) > 0))\n    error = 1;\n  if((memcmp(work+2,\"00\",2)) && (memcmp(work+2,\"30\",2)))\n    error = 1;\n  if(error) {\n    printf(\"\\nThe following parameter file record is in error: \\n\");\n    printf(\"%s\",parmrec);\n    parm_error = 1;                       /* indicate error found in parms */\n  }\n  work[2] = '\\0';                          /* terminate hour string */\n  k = atoi(work);                         /* convert hours to integer */\n  k *= 2;                                 /* hours * 2 for subscript */\n  if(parmrec[i+3] == '3')                  /* if minutes = 30 */\n    k++;                                     /* increment subscript */\n  if(parmrec[0] == 'S') {                 /* if this is a START= record */\n    begin_sub = k;                           /* set begin_sub */\n    memcpy(h3+17,parmrec+i,5);               /* begin time to h3 header */\n  }\n  else {                                  /* else it's an END= record */\n    end_sub = k;                             /* so set end_sub */\n    memcpy(h3+26,parmrec+i,5);               /* and end time in h3 header */\n  }\n}\n/**********************************************************************/\n/* process REC1=, REC2=, and REC3= parameter records                  */\n/**********************************************************************/\nvoid rec_parms(void) {\n  int *lenptr;\n  char *recptr;\n\n  if((memcmp(parmrec+3,\"1=\",2)) &&\n     (memcmp(parmrec+3,\"2=\",2)) &&\n     (memcmp(parmrec+3,\"3=\",2))) {\n       printf(\"\\nThe following parameter file record is unidentifiable: \\n\");\n       printf(\"%s\",parmrec);\n       parm_error = 1;                    /* indicate error found in parms */\n       return;\n  }\n  if(parmrec[3] == '1') {\n    recptr = rec1_title;\n    lenptr = &rec1_leng;\n    rec1 = 1;                             /* show REC1= received */\n  }\n  else if(parmrec[3] == '2') {\n    recptr = rec2_title;\n    lenptr = &rec2_leng;\n    rec2 = 1;                             /* show REC2= received */\n  }\n  else {\n    recptr = rec3_title;\n    lenptr = &rec3_leng;\n    rec3 = 1;                             /* show REC3= received */\n  }\n  for(i=5;i<85;i++) {                     /* look for end of record name */\n    if(parmrec[i] <= ' ')                    /* if blank or ctl char found */\n      break;                                 /* end is found */\n    recptr[i-5] = parmrec[i];                /* move character to title */\n  }\n  if(i == 85) {\n    printf(\"\\nThe following parameter file record name is > 80 characters.\");\n    printf(\"%s\",parmrec);\n    parm_error = 1;                       /* indicate error in parms */\n    return;\n  }\n  else\n    *lenptr = i - 5;                      /* set title length */\n}\n /**********************************************************************/\n/* read next parameter record. at end of file, set moreparms switch.  */\n/**********************************************************************/\nvoid readparm() {\n  if(fgets(parmrec,255,parmfile) == NULL) /* read parmfile until eof */\n    moreparms = 0;                        /* set switch at end of file */\n}\n/**********************************************************************/\n/* read next input file record. at end of file, set morerecs switch.  */\n/**********************************************************************/\nvoid readrec() {\n  if(fgets(inrecord,255,infile) == NULL) /* read input until eof */\n    morerecs = 0;                        /* set switch at end of file */\n}\n/**********************************************************************/\n/* termination: write report from stored data, then close files       */\n/**********************************************************************/\nvoid terminate() {\n\n  memset(h5,' ',77);                       /* clear header5 line */\n  strcpy(h5+77,\"\\r\\n\");                    /* terminate properly */\n  fputs(h1,rptfile);                       /* write header line 1 */\n  memset(rpt,' ',77);                      /* clear print line */\n  strcpy(rpt+77,\"\\r\\n\");                   /* terminate properly */\n  fputs(rpt,rptfile);                      /* write blank line */\n  fputs(h2,rptfile);                       /* write header line 2 */\n  fputs(h3,rptfile);                       /* write header line 3 */\n  fputs(rpt,rptfile);                      /* write blank line */\n  fputs(h4,rptfile);                       /* write header line 4 */\n  for(i=begin_sub;i<=end_sub;i++) {        /* print all counters in table */\n    if((table_counter[0][i] == 0) && (table_counter[1][ii] == 0))\n      continue;\n    hour = i / 2;                          /* compute hour */\n    min = (i % 2) * 30;                    /* compute minute */\n    sprintf(rpt,\"%02d\",hour);              /* hour to print line */\n    rpt[2] = ':';                          /* delimit hour */\n    sprintf(rpt+3,\"%02d\",min);             /* minute to print line */\n    rpt[5] = ' ';                          /* clear trailing null */\n    if(col1) {                             /* if report has column 1 */\n      sprintf(rpt+23,\"%5d\",table_counter[00][i]); /* move col1 count */\n      rpt[28] = ' ';                       /* clear trailing null */\n    }\n    if(col2) {                             /* if report has column 2 */\n      sprintf(rpt+47,\"%5d\",table_counter[11][i]); /* move col2 count */\n      rpt[52] = ' ';                       /* clear trailing null */\n    }\n    if(col3)                               /* if report has column 3 */\n      sprintf(rpt+72,\"%5d\",table_counter[22][i]); /* move col3 count */\n    strcpy(rpt+77,\"\\r\\n\");                 /* terminate properly */\n    fputs(rpt,rptfile);                    /* write detail line */\n    c1_total += table_counter[0][i]; /* add to total */\n    c2_total += table_counter[1][i]; /* add to total */\n    c3_total += table_counter[2][i]; /* add to total */\n  }\n  if(col1) {                               /* if report has col 1 */\n    sprintf(t1+22,\"%6ld\",c1_total);        /* col1 total */\n    t1[28] = ' ';                          /* clear trailing null */\n  }\n  if(col2) {                               /* if report has col 2 */\n    sprintf(t1+46,\"%6ld\",c2_total);        /* col2 total */\n    t1[52] = ' ';                          /* clear trailing null */\n  }\n  if(col3) {                               /* if report has col 3 */\n    sprintf(t1+71,\"%6ld\",c3_total);        /* col3 total */\n    t1[77] = '\\r';                         /* restore trailing carr rtrn */\n  }\n  memset(rpt,' ',77);                      /* clear print line */\n  strcpy(rpt+77,\"\\r\\n\");                   /* terminate properly */\n  fputs(rpt,rptfile);                      /* write blank line */\n  fputs(t1,rptfile);                       /* write total line */\n  sprintf(t2+22,\"%6ld\",c1_total + c2_total + c3_total); /* combined total */\n  t2[28] = ' ';                            /* clear trailing null */\n  fputs(rpt,rptfile);                      /* write blank line */\n  fputs(t2,rptfile);                       /* print combined total */\n\n  c1_max=c2_max=c3_max=1;                  /* insure against divide by 0 */\n  for(i=begin_sub;i<=end_sub;i++) {        /* find column maximum values */\n    if(table_counter[0][i] > c1_max)\n      c1_max = table_counter[0][i];\n    if(table_counter[1][i] > c2_max)\n      c2_max = table_counter[1][i];\n    if(table_counter[2][i] > c3_max)\n      c3_max = table_counter[2][i];\n  }\n\n  for(i=begin_sub;i<=end_sub;i++) {        /* compute percentages */\n    table_counter[0][i] = (100 * table_counter[0][i]) / c1_max;\n    table_counter[1][i] = (100 * table_counter[1][i]) / c2_max;\n    table_counter[2][i] = (100 * table_counter[2][i]) / c3_max;\n  }\n\n  for(k=0;k<3;k++) {                       /* graph control */\n    if(col1 && (k == 0))                     /* graph 1 to be done? */\n      memcpy(h5+16,h4+6,22);                   /* yes, move col1 header */\n    else if(col2 && (k == 1))                /* graph 2 to be done? */\n      memcpy(h5+16,h4+30,22);                  /* yes, move col2 header */\n    else if(col3 && (k == 2))                /* graph 3 to be done? */\n      memcpy(h5+16,h4+55,22);                  /* yes, move col3 header */\n    else\n      continue;                              /* else skip this graph */\n    memset(rpt,' ',77);                      /* clear print line */\n    rpt[0] = '\\f';                           /* formfeed to print line */\n    strcpy(rpt+77,\"\\r\\n\");                   /* terminate properly */\n    fputs(rpt,rptfile);                      /* skip to top of page */\n    fputs(h1,rptfile);                       /* write header line 1 */\n    rpt[0] = ' ';                            /* clear formfeed */\n    fputs(rpt,rptfile);                      /* write blank line */\n    fputs(h2,rptfile);                       /* write header line 2 */\n    fputs(h3,rptfile);                       /* write header line 3 */\n    fputs(rpt,rptfile);                      /* write blank line */\n    fputs(h5,rptfile);                       /* write header line 5 */\n    fputs(rpt,rptfile);                      /* write blank line */\n    for(l=100;l>3;l-=6) {                    /* scan down the graph by 6% */\n      for(i=begin_sub,j=6;i<=end_sub;i++,j+=2) { /* scan across line */\n        if(j>76) break;                      /* stop at right side of page */\n        if(table_counter[k][i] >= l) { /* print bar here? */\n          memcpy(rpt+j,\"**\",2);              /* yes, build the bar */\n        }\n      }\n      rpt[j] = '|';                          /* right margin */\n      rpt[5] = '|';                          /* left margin */\n      fputs(rpt,rptfile);                     /* print graph line */\n      memset(rpt,' ',76);                     /* clear line to blanks */\n    }\n\n    for(i=begin_sub,j=6;i<=end_sub;i++,j+=2) { /* scan across line */\n      if(j>76) break;                      /* stop at right side of page */\n      hour = i / 2;                        /* get hour */\n      min = i % 2;                         /* min = 0 or 1 */\n      if(min) {                            /* if min non-zero */\n        rpt[j] = '.';                         /* at half-hour */\n        rpt[j+1] = '.';\n      }\n      else {                               /* else min = 0 */\n        sprintf(rpt+j,\"%02d\",hour);        /* and on the hour */\n        rpt[j+2] = ' ';                    /* clear trailing null */\n      }\n    }\n    memcpy(rpt+76,\"\\r\\n\",3);               /* terminate the line */\n    memcpy(rpt,\"Time\",4);                  /* identify baseline value */\n    fputs(rpt,rptfile);                    /* print bottom line */\n  }\n\n  fclose(infile);                          /* close files */\n  fclose(rptfile);\n  fclose(parmfile);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DAYWEEK": {"ttr": 7430, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00E\\x01\\x02\\x11\\x9f\\x01\\x02\\x12\\x1f\\x15C\\x00!\\x00\\x1e\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-01T15:43:45", "lines": 33, "newlines": 30, "modlines": 0, "user": "BC0THOR"}, "text": "/*************/\n/* dayweek.c */\n/**************************************************/\n/* calculates the day of week for any year > 1752 */\n/**************************************************/\nmain() {\n  int year, month=1, day, k, l, o, z1, z2, z3, z4, z, w;\n  float p;\n  char daywk[8][10] = { \" \", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n      \"Thursday\", \"Friday\", \"Saturday\"};\n\n  while(month) {\n printf(\"\\nEnter mm/dd/yyyy (zeros to end): \");\n scanf(\"%2d/%2d/%4d\",&month,&day,&year);\n if(year < 1753) {\n   printf(\"\\n Year must be > 1752\");\n   exit(0);\n }\n k = (.6 + (1 / month));\n l = year - k;\n o = month + (12 * k);\n p = (float) l / 100;\n z1 = p / 4;\n z2 = p;\n z3 = (5 * l) / 4;\n z4 = 13 * ((float)(o + 1) / 5);\n z = z4 + z3 - z2 + z1 + day - 1;\n w = z - (7 * (int)(z / 7)) + 1;\n printf(\"\\nDay of week is %s\",daywk[w]);\n printf(\"\\nk=%d, l=%d, o=%d, p=%f\",k, l, o, p);\n printf(\"\\nz1=%d, z2=%d, z3=%d, z4=%d, z=%d, w=%d\",z1, z2, z3, z4, z, w);\n  }\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "DDIR": {"ttr": 7432, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x000\\x000\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "BC0THOR"}, "text": "/* ddir.c */\n/* list sub-directories under a specified path, or under */\n/* the current directory path if none is specified. */\n#include <dir.h>\n#include <dos.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n\nmain(int argc, char *argv[]) {\n  struct ffblk ffblk, *ffptr;\n  int done, i;\n  char *curdir=NULL;            /* ptr to name of starting directory */\n  char dirstr[80];\n\n  if(argc == 2)\n curdir = argv[1];\n  else {\n curdir = getcwd(curdir,80);\n  }\n  if(curdir == NULL)\n if(errno == ENODEV)\n   printf(\"\\ngetcwd() returned ENODEV\\n\");\n else if(errno == ENOMEM)\n     printf(\"\\ngetcwd() returned ENOMEM\\n\");\n else if(errno == ERANGE)\n     printf(\"\\ngetcwd() returned ERANGE\\n\");\n   else\n     printf(\"\\ngetcwd() returned %d\\n\",errno);\n  strcpy(dirstr,curdir);\n  if(dirstr[strlen(dirstr) - 1] == '\\\\')\n strcat(dirstr,\"*.*\");\n  else\n strcat(dirstr,\"\\\\*.*\");\n  printf(\"\\nThe sub-directory list for %s is: %s\\n\",dirstr);\n  done = findfirst(dirstr,&ffblk,FA_DIREC);\n  i = 0;\n  while(!done) {\n   printf(\"  %s\\n\",ffblk.ff_name);   /* display sub-directory name */\n   i++;\n   if(i > 22) {\n  printf(\"\\n(Press any key to continue)\");\n  getch();\n  i = 0;\n   }\n done = findnext(&ffblk);\n  }\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "DEPRECPT": {"ttr": 7434, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00\\xa5\\x00\\xa5\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 165, "newlines": 165, "modlines": 0, "user": "BC0THOR"}, "text": "/************************************************************************/\n/* Attempt to match known receipts with known bank deposits             */\n/************************************************************************/\n#include <math.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n float receipts[32]={1.52,16.03,9.60,8.42,9.36,6.42,1.43,31.6,17.13,9.6,8.06,9.3\n6,6.42,35.6,1.43,8.06,6.42,9.36,1.43,8.06,9.36,6.42,1.43,3.93,8.06,6.42,9.36,1.4\n3,6.42,7.74,3.78,9.36};\n/* float deposits[88]={76.87,75.69,9.36,35.04,55.88,44.25,73.04,16.58};*/\n float deposit = 9.36;\n\n void try2(float,int);\n void try3(float,int,int);\n void try4(float,int,int,int);\n void try5(float,int,int,int,int);\n void try6(float,int,int,int,int,int);\n void try7(float,int,int,int,int,int,int);\n void sortout(int,int,int,int,int,int,int,int);\n\nvoid main(void) {\n float trial;\n int r1,d;\n\n for(d=0;d<25;d++) printf(\"\\n\");\n\n for(r1=0;r1<32;r1++) {\n  trial = receipts[r1];\n  if(trial == deposit) {\n   sortout(1,r1,0,0,0,0,0,0);\n  }\n  try2(trial,r1);\n }\n}\nvoid try2(float start,int r1) {\n float trial;\n int r2,d;\n\n for(r2=r1+1;r2<32;r2++) {\n  trial = start + receipts[r2];\n  if(trial == deposit) {\n   sortout(2,r1,r2,0,0,0,0,0);\n  }\n  try3(trial,r1,r2);\n }\n}\nvoid try3(float start,int r1,int r2) {\n float trial;\n int r3,d;\n\n for(r3=r2+1;r3<32;r3++) {\n  trial = start + receipts[r3];\n  if(trial == deposit) {\n   sortout(3,r1,r2,r3,0,0,0,0);\n  }\n  try4(trial,r1,r2,r3);\n }\n}\nvoid try4(float start,int r1,int r2,int r3) {\n float trial;\n int r4,d;\n\n for(r4=r3+1;r4<32;r4++) {\n  trial = start + receipts[r4];\n  if(trial == deposit) {\n   sortout(4,r1,r2,r3,r4,0,0,0);\n  }\n  try5(trial,r1,r2,r3,r4);\n }\n}\nvoid try5(float start,int r1,int r2,int r3,int r4) {\n float trial;\n int r5,d;\n\n for(r5=r4+1;r5<32;r5++) {\n  trial = start + receipts[r5];\n  if(trial == deposit) {\n   sortout(5,r1,r2,r3,r4,r5,0,0);\n  }\n  try6(trial,r1,r2,r3,r4,r5);\n }\n}\nvoid try6(float start,int r1,int r2,int r3,int r4,int r5) {\n float trial;\n int r6,d;\n\n for(r6=r5+1;r6<32;r6++) {\n  trial = start + receipts[r6];\n  if(trial == deposit) {\n   sortout(6,r1,r2,r3,r4,r5,r6,0);\n  }\n  try7(trial,r1,r2,r3,r4,r5,r6);\n }\n}\nvoid try7(float start,int r1,int r2,int r3,int r4,int r5,int r6) {\n float trial;\n int r7,d;\n\n for(r7=r6+1;r7<32;r7++) {\n  trial = start + receipts[r7];\n  if(trial == deposit) {\n   sortout(7,r1,r2,r3,r4,r5,r6,r7);\n  }\n/* try8(trial,r1,r2,r3,r4,r5,r6,r7);  */\n }\n}\nvoid sortout(int nbr,int r1,int r2,int r3,int r4,int r5,int r6,int r7) {\n static float comparay[7] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0};\n float array[7];\n int i,j;\n float k;\n\n array[0] = receipts[r1];\n array[1] = receipts[r2];\n array[2] = receipts[r3];\n array[3] = receipts[r4];\n array[4] = receipts[r5];\n array[5] = receipts[r6];\n array[6] = receipts[r7];\n\n for(i=6;i>=nbr;i--) {\n  array[i] = 999;\n }\n\n for(i=0;i<7;i++) {\n  for(j=i+1;j<7;j++) {\n   if(array[i] > array[j]) {\n    k = array[i];\n    array[i] = array[j];\n    array[j] = k;\n   }\n\n  }\n }\n\n for(i=0,j=0;i<7;i++) {\n  if(array[i] == comparay[i]) j++;\n  comparay[i] = array[i];\n    }\n\n    if(j == 7) nbr = 0;\n\n if(nbr == 1)\n  printf(\"\\ndeposit %3.2f = %3.2f\",deposit,array[0]);\n else if(nbr == 2)\n  printf(\"\\ndeposit %3.2f = %3.2f + %3.2f\",deposit,array[00],array[1]);\n else if(nbr == 3)\n  printf(\"\\ndeposit %3.2f = %3.2f + %3.2f + %3.2f\",deposit,array[0],array[1],arr\nay[2]);\n else if(nbr == 4)\n  printf(\"\\ndeposit %3.2f = %3.2f + %3.2f + %3.2f + %3.2f\",deposit,array[0],arra\ny[1],array[2],array[3]);\n else if(nbr == 5)\n  printf(\"\\ndeposit %3.2f = %3.2f + %3.2f + %3.2f + %3.2f + %3.2f\",deposit,array\n[0],array[1],array[2],array[3],array[4]);\n else if(nbr == 6)\n  printf(\"\\ndeposit %3.2f = %3.2f + %3.2f + %3.2f + %3.2f + %3.2f + %3.2f\",depos\nit,array[0],,array[1],array[2],array[3],array[4],array[5]);\n else if(nbr == 7)\n  printf(\"\\ndeposit %3.2f = %3.2f + %3.2f + %3.2f + %3.2f + %3.2f + %3.2f + %3.2\nf\",deposit,array[0],array[1],array[2],array[3],array[4],array[5],array[6]);\n if(nbr != 0)\n  getch();\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "DIRSEL": {"ttr": 7438, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x01\\x17\\x01\\x17\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 279, "newlines": 279, "modlines": 0, "user": "BC0THOR"}, "text": "/* directory selection list */\n#include <stdio.h>\n#include <dir.h>\n\nvoid dirsel(void);\n\nstruct ffblk dir_entry;\n\nstruct file_entry\n {\n char file_selected;\n long file_size;\n char file_name[13];\n };\n\nstruct file_entry file_table[256];\n\nint i,max,done,new_dir=-1;\nchar ch,dir_path[81],new_path[81];\n\nmain()\n{\n dirsel();\n}\n\n/***************** directory selection menu *****************/\nvoid dirsel(void)\n{\n void change_dir(void);\n    void select_dir(void);\n void read_dir(void);\n\n ch=' ';\n while(ch != 'Q')\n {\n  printf(\"\\x1B[2J\");           /* clear screen */\n  printf(\"\\x1B[%d;%df\",0,28);    /* cursor to col 0, row 28 */\n  printf(\"DIRECTORY SELECTION MENU\");\n  printf(\"\\x1B[%d;%df\",4,27);\n  printf(\"C = Change Directory Path\");\n  printf(\"\\x1B[%d;%df\",6,27);\n  printf(\"S = Select From Directory\");\n  printf(\"\\x1B[%d;%df\",8,27);\n  printf(\"A = Select ALL Files\");\n  printf(\"\\x1B[%d;%df\",10,27);\n  printf(\"U = Un-Select ALL Files\");\n  printf(\"\\x1B[%d;%df\",12,27);\n  printf(\"Q = Finished, Return to Main Menu\");\n  printf(\"\\x1B[%d;%df\",21,27);\n  getcwd(dir_path,81);\n  printf(\"Current Directory Path is: %s\",dir_path);\n  printf(\"\\x1B[%d;%df\",23,27);\n  printf(\"Enter Menu Selection: \");\n  ch=getche();\n  switch(ch)\n  {\n   case 'C':\n   case 'c':\n    change_dir();\n    break;\n   case 'S':\n   case 's':\n    if(new_dir)\n     read_dir();\n    select_dir();\n    break;\n   case 'A':\n   case 'a':\n    read_dir();\n    for(i=0;i<max;i++)\n     file_table[i].file_selected = 'S';\n    break;\n   case 'U':\n   case 'u':\n    read_dir();\n    for(i=0;i<max;i++)\n     file_table[i].file_selected = 'N';\n    break;\n   case 'q':\n    ch = 'Q';\n  }\n }\n}\n\n/********************* change directory path ***********************/\nvoid change_dir(void)\n{\n getcwd(dir_path,81);\n printf(\"\\x1B[2J\");           /* clear screen */\n while(1)\n {\n  printf(\"\\nCurrent directory is: %s\",dir_path);\n  printf(\"\\nEnter new directory or RETURN if no change: \");\n  gets(new_path);\n  if(new_path[0] == NULL)\n   break;\n  else\n  {\n   strcpy(dir_path,new_path);\n   i=chdir(dir_path);\n   if(i != 0)\n    printf(\"\\nInvalid directory path, respecify\");\n  }\n }\n new_dir = -1;\n}\n\n/******************** read directory entries into table ***************/\nvoid read_dir(void)\n{\n done=findfirst(\"*.*\",&dir_entry,0);\n max=0;\n while((!done) && (max < 255))\n {\n        file_table[max].file_selected = 'N';\n  strcpy(file_table[max].file_name,dir_entry.ff_name);\n  file_table[max++].file_size = dir_entry.ff_fsize;\n  done=findnext(&dir_entry);\n }\n new_dir = 0;\n}\n\n/********************** select directory entries ***********************/\nvoid select_dir(void)\n{\n int row,col,page,oldpage,i,maxrow,maxcol;\n void fillpage(int page);\n\n page=0;\n oldpage = page;\n row=2;\n col=1;\n fillpage(page);\n printf(\"\\x1B[%d;%df\",row,col);\n while((ch=getch()) != 0x1B)\n {\n  i = max - (100 * page);\n  if(i > 100)\n   i = 100;\n  maxrow = (i / 5) + 2;\n  maxcol = (((i % 5) * 15) +1);\n  if(maxcol == 1)\n  {\n   maxcol = 61;\n   maxrow -= 1;\n  }\n  else\n   maxcol -= 15;\n  if(ch == 0)\n  {\n   ch=getch();\n   switch(ch)\n   {\n    case 71:              /* Home */\n     row = 2;\n     col = 1;\n     break;\n    case 72:              /* Up Arrow */\n     if(row > 2)\n      row -= 1;\n     else\n      if(col > maxcol)\n       row = maxrow-1;\n      else\n       row = maxrow;\n     break;\n    case 73:              /* PgUp */\n     if(page > 0)\n      page -= 1;\n        row = 2;\n     col = 1;\n    break;\n    case 75:              /* Left Arrow */\n     if(col > 15)\n      col -= 15;\n     else\n      if(row == maxrow)\n       col = maxcol;\n      else\n       col = 61;\n     break;\n    case 77:              /* Right Arrow */\n     if(row == maxrow)\n      if(col < maxcol)\n       col += 15;\n      else\n       col = 1;\n     else\n      if(col < 61)\n       col += 15;\n      else\n       col = 1;\n     break;\n    case 79:              /* End */\n     row = maxrow;\n     col = maxcol;\n     break;\n    case 80:              /* Down Arrow */\n     row += 1;\n     if(row > maxrow)\n      row=2;\n     if((row == maxrow) && (col > maxcol))\n      row = 2;\n     break;\n    case 81:              /* PgDn */\n     if(page < max / 100)\n      page += 1;\n      row = 2;\n                        col = 1;\n   }\n  }\n  else\n   switch(ch)\n   {\n    case 13:              /* Return */\n     i = ((100 * page) + (5 * (row-2)) + (col / 15));\n     if(file_table[i].file_selected == 'N')\n      file_table[i].file_selected = 'S';\n     else\n      file_table[i].file_selected = 'N';\n     break;\n    case 27:              /* ESC */\n     break;\n   }\n  if(ch != 0x1B)\n  {\n   i = ((100 * page) + (5 * (row-2)) + (col / 15));\n   printf(\"\\x1B[%d;%df\",row,col);\n   if(file_table[i].file_selected == 'N')\n    printf(\"\\x1B[0m%s\",file_table[i].file_name);\n   else\n    printf(\"\\x1B[7m%s\\x1B[0m\",file_table[i].file_name);\n   if(oldpage != page)\n            {\n    fillpage(page);\n    row = 2;\n    col = 1;\n    oldpage = page;\n   }\n   printf(\"\\x1B[%d;%df\",row,col);\n  }\n }\n}\n/***************** fill a page with file names ************************/\nvoid fillpage(int page)\n{\n int row,col,i,j;\n printf(\"\\x1B[2J\");           /* clear screen */\n printf(\"\\x1B[%d;%df\",1,20);    /* cursor to row 1, col 28 */\n printf(\"FILE SELECTION MENU FOR %s\",dir_path);\n printf(\"\\x1B[%d;%df\",23,1);    /* cursor to row 23, col 1 */\n printf(\"Locate with arrows, PgUp and PgDn. Toggle select with RETURN. end with\nESC\");\n i = 100 * page;\n j = max - (100 * page);\n if(j > 100)\n  j = 100;\n if(j < 1) return;\n j += i;\n row = 2;\n col = 1;\n while(1)\n {\n  printf(\"\\x1B[%d;%df\",row,col);\n  if(file_table[i].file_selected == 'N')\n   printf(\"\\x1B[0m%s\",file_table[i].file_name);\n  else\n   printf(\"\\x1B[7m%s\\x1B[0m\",file_table[i].file_name);\n  i++;\n  if(i >= j) break;\n  col += 15;\n  if(col > 61)\n  {\n   row++;\n   col = 1;\n  }\n }\n printf(\"\\x1B[%d;%df\",2,1);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "DIRSIZE": {"ttr": 7685, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00\\xc5\\x00\\xc5\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 197, "newlines": 197, "modlines": 0, "user": "BC0THOR"}, "text": "/* find.c */\n/* experiment with the findfirst() and findnext() functions */\n#include <dir.h>\n#include <dos.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n\n  struct dirinfo {              /* directory information block */\n struct ffblk *dta_ptr;         /* ptr to the dta during searches */\n struct dirinfo *prevdir;       /* ptr to previous block */\n struct dirinfo *nextdir;       /* ptr to next block */\n int dir_level;                 /* directory level (lowest = 0) */\n char dir_name[12];             /* directory name */\n int path_len;                  /* total path name length */\n int nbr_files;                 /* nbr files in directory */\n float size_files;              /* total bytes in files */\n int nbr_subdirs;               /* nbr sub-directories */\n float size_subdirs;            /* total bytes in sub-directories */\n };\n\nmain(int argc, char *argv[]) {\n  struct ffblk *f;              /* pointer to ffblk */\n  int done;                     /* true when find functions complete */\n  int level = 0;                /* current subdirectory level */\n  char *curdir=NULL;            /* ptr to name of starting directory */\n  char dirstr[256];             /* starting directory name */\n  char number[9];               /* number to be edited */\n  char edited[11];              /* edited number */\n  int linect;                   /* line counter */\n  char detail_line[79];         /* detail print line */\n  char detail_header[79] = {      /* detail header line */\n\"NAME                              #FI ------FILES #SD ---SUB-DIRS ------TOTAL\"}\n;\n  char ch;                      /* utility string pointer */\n  int i, j;                     /* utility subscripts */\n  struct dirinfo nulldir = {NULL, NULL, NULL, 0, \" \", 0, 0, 0.0, 0, 0.0};\n  struct dirinfo firstdir = {NULL, NULL, NULL, 0, \" \", 0, 0, 0.0, 0, 0.0};\n  struct dirinfo *p, *r;        /* pointers to dirinfo */\n  struct ffblk first_dta;       /* initial ffblk */\n  /*******************************************************************/\n  /* Initialization: get the initial path to use, either typed in on */\n  /* the command line, or the current directory by default.          */\n  /*******************************************************************/\n  if(argc == 2)\n curdir = argv[1];\n  else {\n curdir = getcwd(curdir,80);     /* get current directory path */\n  }\n  if(curdir == NULL)\n if(errno == ENODEV)\n   printf(\"\\ngetcwd() returned ENODEV\\n\");\n else if(errno == ENOMEM)\n     printf(\"\\ngetcwd() returned ENOMEM\\n\");\n else if(errno == ERANGE)\n     printf(\"\\ngetcwd() returned ERANGE\\n\");\n   else\n     printf(\"\\ngetcwd() returned %d\\n\",errno);\n  strcpy(dirstr,curdir);\n  /*******************************************************************/\n  /* Build a dirinfo element for the initial directory: get storage  */\n  /* for a dta, set the dta_ptr and ODS's dta to this storage, and   */\n  /* point p to this element. Issue findfirst for the starting       */\n  /* directory.                                                      */\n  /*******************************************************************/\n  p = &firstdir;\n  f = &first_dta;\n  p->dta_ptr = f;\n  p->path_len = (strlen(dirstr)) + 1;\n  strcat(dirstr,\"\\\\*.*\");\n  setdta((char far *)f);\n  done = findfirst(dirstr,f,FA_DIREC+FA_RDONLY+FA_HIDDEN+FA_SYSTEM+FA_LABEL+FA_A\nRCH);\n  /*******************************************************************/\n  /* Collect directory information: search the current directory for */\n  /* all items. When a file is found, add 1 to the nbr_files and add */\n  /* its size to the size_files fields. When a directory is found,   */\n  /* build a dirinfo block for it, get storage for a dta and set it  */\n  /* as the DOS dta, then issue a findfirst() and search this new    */\n  /* subdirectory. When a subdirectory search finishes, return to    */\n  /* its mother and continue until the original directory finishes.  */\n  /*******************************************************************/\n  while(1) {\n while(!done) {\n   if(f->ff_attrib == FA_DIREC) {\n  if(f->ff_name[0] == '.');\n  else {\n    level++;         /* increment sub-directory level */\n    dirstr[p->path_len] = '\\0'; /* truncate pathname to mother's */\n    r = (struct dirinfo *)malloc(sizeof(struct dirinfo)); /* get dirinfo storage\n */\n    memcpy(r,&nulldir,sizeof(struct dirinfo)); /* initialize dirinfo */\n    strcpy(r->dir_name, f->ff_name); /* set sub-directory name */\n    f = (struct ffblk *)malloc(sizeof(struct ffblk)); /* get ffblk storage */\n    r->dta_ptr = f;    /* save ffblk ptr in dirinfo */\n    setdta((char far *)f);\n    while(p->nextdir)\n   p = p->nextdir;\n    p->nextdir = r;    /* chain dirinfo forward */\n    r->nextdir = NULL; /* clear new dirinfo's forward pointer */\n    r->prevdir = p;    /* chain new dirinfo backward */\n    p = r;             /* point to new dirinfo block */\n    p->dir_level = level; /* set sub-directory level */\n    strcat(dirstr,p->dir_name); /* build new path name for findfirst() */\n    p->path_len = (strlen(dirstr)) + 1; /* set path length */\n    strcat(dirstr,\"\\\\*.*\");    /* add all files request */\n    done = findfirst(dirstr,f,FA_DIREC+FA_RDONLY+FA_HIDDEN+FA_SYSTEM+FA_LABEL+FA\n_ARCH);\n  }\n   }\n   else {\n  p->nbr_files++;\n  p->size_files += (float)f->ff_fsize;\n   }\n   done = findnext(f);\n }\n if(level == 0)         /* all through if this was initial directory */\n   break;\n free(f);               /* free the dta area used for ffblk */\n level--;               /* back up 1 level */\n r = p;                 /* start at current block */\n do                     /* locate mother's dirinfo block */\n   r =  r->prevdir;     /* point to previous dirinfo block */\n while((r->dir_level) != level);\n r->nbr_subdirs++;      /* increment nbr sub-directories */\n r->size_subdirs += ((p->size_subdirs) + (p->size_files)); /* compute total of a\nll sizes */\n p = r;                 /* set directory pointer to mother */\n f = p->dta_ptr;        /* point to mother's dta (ffblk) */\n setdta((char far *)f);\n dirstr[p->path_len] = '\\0'; /* truncate pathname to mother's */\n done = findnext(f);\n  }\n  for(i=0;i<sizeof(dirstr);i++)\n  dirstr[i] = toupper(dirstr[i]);\n  printf(\"\\nThe directory evaluated is: %s\",dirstr);\n  sprintf(number,\"%d\",p->nbr_files);\n  edit(edited,\"zzz,zzz,zz9\",number);\n  printf(\"\\n   directory contains %s files\",edited);\n  sprintf(number,\"%.0f\",p->size_files);\n  edit(edited,\"zzz,zzz,zz9\",number);\n  printf(\"\\n   sum of filesizes is %s bytes\",edited);\n  sprintf(number,\"%d\",p->nbr_subdirs);\n  edit(edited,\"zzz,zzz,zz9\",number);\n  printf(\"\\n   directory contains %s sub-directories\",edited);\n  sprintf(number,\"%.0f\",p->size_subdirs);\n  edit(edited,\"zzz,zzz,zz9\",number);\n  printf(\"\\n   sum of sub-directory sizes is %s bytes\",edited);\n  sprintf(number,\"%.0f\",p->size_subdirs + p->size_files);\n  edit(edited,\"zzz,zzz,zz9\",number);\n  printf(\"\\n   total size of this directory is %s bytes\",edited);\n  printf(\"\\n\");\n  printf(\"\\nDo you want the detail (y/n)?\");\n  ch = getch();\n  if((ch == 'y') || (ch == 'Y')) {\n p = &firstdir;                    /* point to first directory */\n printf(\"\\n\\n\\n%s\",detail_header); /* print first header line */\n linect=7;\n while(p) {\n   printf(\"\\n\");\n   for(i=0;i<78;i++)\n  detail_line[i] = ' ';\n   detail_line[78] = '\\0';\n   linect++;\n   i = p->dir_level * 2;\n   if(i > 18)\n  i = 18;\n   if(p->dir_level == 0) {\n  j = strlen(dirstr);\n  memcpy(detail_line,dirstr,j);\n   }\n   else {\n  j = strlen(p->dir_name);\n  memcpy(&detail_line[i],p->dir_name,j);\n  }\n   sprintf(number,\"%d\",p->nbr_files);\n   edit(&detail_line[34],\"zzz\",number);\n   sprintf(number,\"%.0f\",p->size_files);\n   edit(&detail_line[38],\"zzz,zzz,zzz\",number);\n   sprintf(number,\"%d\",p->nbr_subdirs);\n   edit(&detail_line[50],\"zzz\",number);\n   sprintf(number,\"%.0f\",p->size_subdirs);\n   edit(&detail_line[54],\"zzz,zzz,zzz\",number);\n   sprintf(number,\"%.0f\",p->size_files + p->size_subdirs);\n   edit(&detail_line[66],\"zzz,zzz,zzz\",number);\n   printf(\"%s\",detail_line);\n   p = p->nextdir;\n   if(linect > 22) {\n  printf(\"\\n(Press any key to continue)\");\n  getch();\n  linect = 1;\n  printf(\"\\n%s\",detail_header);\n   }\n }\n  }\n  printf(\"\\n\");\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "DIVIDE": {"ttr": 7689, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x10\\x01\\x02\\x11\\x9f\\x01\\x02\\x12/\\x159\\x00[\\x00V\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-02T15:39:10", "lines": 91, "newlines": 86, "modlines": 0, "user": "BC0THOR"}, "text": "/************/\n/* divide.c */\n/**************************************************************/\n/* Divide using numbers too large for long integers where the */\n/* remainder is needed and/or an exact quotient is required   */\n/**************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid initialize(void);             /* initialization */\nvoid compute_quotient_place(void); /* compute next digit in quotient */\n\nchar dividend[81];          /* user entered dividend string */\nchar divisor[81];           /* user entered divisor string  */\nchar quotient[81];          /* computed quotient */\nchar remainder[81];         /* computed remainder */\nint i, j, k, q, r, w, x, y; /* work numbers */\nint done = -1;              /* completion indicator */\n\nmain() {\n  initialize();\n  while(!done)\n compute_quotient_place();\n  printf(\"Quotient is: %s\",quotient);\n  printf(\"Remainder is: %s\",remainder);\n}\n/*********************************************************/\n/* compute the next digit in the quotient. when the      */\n/* divisor will no longer fit in the remains of the      */\n/* original dividend, done is set to zero and the        */\n/* remainder is moved into the remainder string.         */\n/*********************************************************/\nvoid compute_quotient_place(void) {\n  k = y;\n  if((memcmp(dividend,divisor,k)) < 0) {\n k++;\n  }\n  else if(dividend[0] < divisor[0]) {\n\n  }\n}\n/*********************************************************/\n/* initialize: get dividend and divisor from caller.     */\n/* Verify their compositions, and sizes. Put initial     */\n/* values in various fields.                             */\n/*********************************************************/\nvoid initialize(void) {\n   printf(\"\\nEnter the whole number dividend: \");\n   gets(dividend);\n   k = strlen(dividend);\n   if(k > 80) {\n  printf(\"\\nToo many digits in dividend, 80 is max.\\n\");\n  exit(0);\n   }\n   for(i=0;i<k;i++) {\n  if(!(isdigit(dividend[i]))) {\n    printf(\"\\nDividend must be composed of decimal digits only.\\n\");\n    exit(0);\n  }\n   }\n   if(dividend[0] == '0') {\n  printf(\"\\nLeading digit of divident must be greater than zero.\\n\");\n  exit(0);\n   }\n   printf(\"\\nEnter the whole number divisor: \");\n   gets(divisor);\n   y = strlen(divisor);\n   if(y > 80) {\n  printf(\"\\nToo many digits in divisor, 80 is max.\\n\");\n  exit(0);\n   }\n   for(w=0;w<y;w++) {\n  if(!(isdigit(divisor[w]))) {\n    printf(\"\\nDivisor must be composed of decimal digits only.\\n\");\n    exit(0);\n  }\n   if(divisor[0] == '0') {\n  printf(\"\\nLeading digit of divisor must be greater than zero.\\n\");\n  exit(0);\n   }\n   if(k <= y) {\n  printf(\"\\nDividend must be longer than divisor.\\n\");\n  exit(0);\n   }\n   }\n   strcpy(quotient,\"0\");          /* clear quotient */\n   strcpy(remainder,\"0\");         /* clear remainder */\n   q = r = 0;                     /* initialize subscripts */\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "DOWNLOAD": {"ttr": 7692, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00R\\x01\\x02\\x11\\x9f\\x01\\x02\\x12/\\x16\\x10\\x00R\\x00V\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-02T16:10:52", "lines": 82, "newlines": 86, "modlines": 0, "user": "BC0THOR"}, "text": "/*****************\n/* download.c */\n/*********************************************************************/\n/* Download a character set to the Epson FX-85 printer in Epson mode */\n/* Patterned after program on page 110 in manual                     */\n/* First, the printer ROM is copied to its RAM, to provide the       */\n/* initial character set. Next, a file of character definitions      */\n/* is read, converted to printer commands, and is sent to the printer*/\n/*********************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n\nmain(int argc, char *argv[]) {\n  FILE *prtptr,*filptr;\n  unsigned int ret=0,chrdef=0;\n  unsigned int c1=0,c2=0,c3=0,c4=0,c5=0,c6=0,c7=0,c8=0,c9=0;\n  unsigned char ul=' ';\n\n  if(argc != 2) {\n    printf(\"\\nFormat: C>download download.chr\");\n    printf(\"\\nWhere download.chr is the name of a disk file\");\n    printf(\"\\ncontaining download character definitions for an Epson\");\n    printf(\"\\nFX-85. Format is one line per character, ending with\");\n    printf(\"\\ncarriage return:\");\n    printf(\"\\n            cc,ul,c1,c2,c3,c4,c5,c6,c7,c8,c9\");\n    printf(\"\\n where cc is the character (hex) between 21-7E or\");\n    printf(\"\\n A1-FE, ul is 'U' if upper 8 bits are defined, else\");\n    printf(\"\\n'L'. c1, c2, c3, c4, c5, c6, c7, c8,and c9 are two-\");\n    printf(\"\\ndigit hex values for each of the 9 columns. See\");\n    printf(\"\\n       the Epson printer manual: \");\n    printf(\"\\n       'USER-DEFINED CHARACTERS'\");\n    exit(0); }\n if((filptr=fopen(argv[1], \"r\")) == NULL) {\n    printf(\"\\nCan't open the download definition file %s\",argv[1]);\n    exit(8); }\n if((prtptr=fopen(\"prn\",\"w\")) == NULL) {\n    printf(\"\\nCan't open the printer\");\n    exit(8); }\n fputs(\"\\x1B:\",prtptr);    /* Copy ROM to RAM (Epson mode only) */\n fputc('\\x00',prtptr);\n fputc('\\x00',prtptr);\n fputc('\\x00',prtptr);\n fputs(\"\\x1B%\",prtptr);    /* Select user defined set for in/out */\n fputc('\\x01',prtptr);\n fputc('\\x00',prtptr);\n while((ret=fscanf(filptr,\"%x,%c,%x,%x,%x,%x,%x,%x,%x,%x,%x\",&chrdef,\n                    c2,&c3,&ul,&c1,&c4,&c5,&c6,&c7,&c8,&c9)) != EOF) {\n   if(ret != 11) {\n      printf(\"\\nIncorrect number of fields in definition for %X\",\n         chrdef);\n      exit(8); }\n   if((chrdef < 33) || ((chrdef > 126) &&\n         (chrdef < 161)) || (chrdef > 254)) {\n      printf(\"\\n%X is an invalid character value.\",chrdef);\n      printf(\"\\nUse 21-7E or A1-FE\");\n      exit(8); }\n   if(!((ul == 'U') || (ul == 'L'))) {\n      printf(\"\\n%c is an invalid ul value for character %x\",ul,chrdef);\n      exit(8); }\n   fputs(\"\\x1B&\",prtptr);    /* Define a user character */\n   fputc('\\x00',prtptr);\n   fputc(chrdef,prtptr);     /* character to define (from) */\n   fputc(chrdef,prtptr);     /* character to define (to) */\n   if(ul == 'L')\n      fputc('\\x00',prtptr); /* lower 8 bits */\n   else\n      fputc('\\x80',prtptr); /* upper 8 bits */\n   fputc(c1,prtptr);         /* column 1 value */\n   fputc(c2,prtptr);         /* column 2 value */\n   fputc(c3,prtptr);         /* column 3 value */\n   fputc(c4,prtptr);         /* column 4 value */\n   fputc(c5,prtptr);         /* column 5 value */\n   fputc(c6,prtptr);         /* column 6 value */\n   fputc(c7,prtptr);         /* column 7 value */\n   fputc(c8,prtptr);         /* column 8 value */\n   fputc(c9,prtptr);         /* column 9 value */\n   fputc('\\x00',prtptr);     /* Last 2 numbers always zero */\n   fputc('\\x00',prtptr); }\n fclose(filptr);\n fclose(prtptr);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "DROPCR": {"ttr": 7937, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x16\\x01\\x02\\x11\\x9f\\x01\\x02\\x12/\\x16\\x14\\x00f\\x00f\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-02T16:14:16", "lines": 102, "newlines": 102, "modlines": 0, "user": "BC0THOR"}, "text": "/************/\n/* dropcr.c */\n/******************************************************************/\n/* Reads a standard ascii file whose records end in carriage-     */\n/* return + line-feed and writes an identical file except that the*/\n/* carriage-returns are dropped. Also the ending control-Z        */\n/* (hex 1A) is also dropped.                                      */\n/* Author R Thornton September 1994                               */\n/******************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid initialize(int argc, char *argv[]); /* initialization func  */\nvoid mainline(void);                    /* mainline function      */\nvoid terminate(void);                   /* termination function   */\nvoid readrec(void);                     /* read input file record */\nvoid writerec(void);                    /* write output record    */\n\nFILE *infile, *outfile;                 /* file pointers          */\n\nchar innam[81];                         /* input file name        */\nchar outnam[81];                        /* output file name       */\n\nchar inrecord[256];                     /* input file record area */\n\nint i;                                  /* general purpose int    */\nint morerecs = -1;                      /* input eof switch       */\nlong incount = 0;                       /* input record counter   */\nlong outcount = 0;                      /* output record counter  */\n\n/******************************************************************/\n/* executive routine: overall program control                     */\n/******************************************************************/\nvoid main(int argc, char *argv[]) {\n   initialize(argc, argv);              /* open files             */\n   while(morerecs)                      /* perform mainline until */\n      mainline();                       /* no more records        */\n   terminate();                         /* close files            */\n   exit(0);                             /* quit                   */\n}\n/******************************************************************/\n/* mainline function: process input file until no more records.   */\n/******************************************************************/\nvoid mainline(void) {\n   writerec();                          /* write an output record */\n   readrec();                           /* read next input record */\n}\n/******************************************************************/\n/* initialization: open files, read first input record.           */\n/******************************************************************/\nvoid initialize(int argc, char *argv[]) {\n  if(argc == 3) {                       /* if two filenames given:*/\n    strcpy(innam,argv[1]);              /* 1st is input filename  */\n    strcpy(outnam,argv[2]);             /* 2nd is output filename */\n  }\n  else {                                /* if neither 2 nor 3     */\n    printf(\"\\nEnter input file spec: \"); /* ask for input filename*/\n    gets(innam);                        /* and read it in         */\n    printf(\"\\nEnter output file spec: \"); /* ask for output filenm*/\n    gets(outnam);                       /* and read it in         */\n    }\n  if((infile=fopen(innam,\"rb\")) == NULL) { /* open input          */\n    printf(\"Can't open file %s.\",innam); /* open failed message   */\n    exit(8);                            /* terminate              */\n  }\n  if((outfile=fopen(outnam,\"wb\")) == NULL) { /* open output       */\n    printf(\"Can't open file %s.\",outnam);\n    exit(8);\n  }\n  readrec();                            /* read first input recd  */\n}\n/******************************************************************/\n/* read next input file record. at eof, set morerecs switch.      */\n/******************************************************************/\nvoid readrec() {\n  if(fgets(inrecord,255,infile) == NULL) /* read input until eof  */\n    morerecs = 0;                       /* set switch at eof      */\n}\n/******************************************************************/\n/* write a record to the output file                              */\n/******************************************************************/\nvoid writerec() {\n  if(inrecord[0] == '\\x1A')             /* if this is an eof recd */\n    ;                                   /*   just drop it         */\n  else {\n    i = strlen(inrecord);               /* get input record length*/\n    if((strcmp(&inrecord[i-2],\"\\r\\n\"))== 0) { /* ends with \\r\\n? */\n      inrecord[i-2] = '\\n';             /* yes, delete            */\n      inrecord[i-1] = '\\0';             /*   the \\r               */\n    }\n    fputs(inrecord,outfile);            /* write output record    */\n  }\n}\n/******************************************************************/\n/* termination: close files                                       */\n/******************************************************************/\nvoid terminate() {\n  fclose(infile);                       /* close input file       */\n  fclose(outfile);                      /* close output file      */\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "DUMPHEX": {"ttr": 7940, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x04\\x01\\x02\\x11\\x9f\\x01\\x02\\x12/\\x16A\\x00V\\x00f\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-02T16:41:04", "lines": 86, "newlines": 102, "modlines": 0, "user": "BC0THOR"}, "text": "/****************\n/* dumphex.c */\n/************************************************/\n/* Program to print a file in hex and character */\n/************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n\nmain(int argc, char *argv[]) {\n  char prntlin[68];\n  unsigned char ch,prtsw='\\0';\n  unsigned int j,k,l,row=0;\n  int i;\n  unsigned long bytno=0,tot=0;\n  void atox(unsigned char, char[], char[]);\n\n  FILE *infil,*outfil;\n\n  prntlin[0]='\\n';\n  prntlin[67]='\\0';\n  if(argc!=2) {\n    printf(\"\\nSYNTAX: dumphex [d:][\\\\path\\\\]filename[.ext]\");\n    exit(0); }\n  if((infil=fopen(argv[1],\"rb\"))==NULL) {\n    printf(\"\\nCan't open the input file, %s\",argv[1]);\n    exit(8); }\n  printf(\"\\nDo you want to print the file (y/n): \");\n  while((prtsw!='y')&&(prtsw!='n'))\n    prtsw=getchar();\n  if(prtsw=='n')\n    prtsw='\\0';\n  if(prtsw)\n    if((outfil=fopen(\"prn\",\"w\"))==NULL) {\n      printf(\"\\nCan't open the printer file.\");\n      exit(8); }\n    else {\n      fputs(\"\\n     ***** Hex/Character Dump of: \",outfil);\n      fputs(argv[1],outfil);\n      fputs(\" *****\\n\",outfil); }\n  do {\n    for(i=1;i<67;i++)\n      prntlin[i]=' ';\n    ch=bytno/65536;\n    atox(ch,&prntlin[1],&prntlin[2]);\n    ch=(bytno%65536)/256;\n    atox(ch,&prntlin[3],&prntlin[4]);\n    ch=bytno%256;\n    atox(ch,&prntlin[5],&prntlin[6]);\n    bytno+=16;\n    i=51;\n    while((i<67)&&(k=getc(infil))!=EOF) {\n      prntlin[i++]=k;\n      tot+=1; }\n    for(j=51,l=9;j<i;j++) {\n      atox(prntlin[j],&prntlin[l],&prntlin[l+1]);\n      l+=2;\n      if(l==13||l==18||l==23||l==34||l==39||l==44)\n        l+=1;\n      if(l==28)\n        l+=2; }\n    for(j=51;j<i;j++)\n    if((prntlin[j]<' ')||(prntlin[j]>'z'))\n      prntlin[j]='.';\n    printf(\"%s\",prntlin);\n   if(prtsw)\n     fputs(prntlin,outfil);\n   row += 1;                       /* increment row counter */\n   if(row >= 22) {                 /* if end of screen: */\n     row = 0;                        /* reset row counter */\n     printf(\"\\nEnter Q to quit or press ENTER to continue: \");\n     ch = getchar();                 /* get response */\n     if((ch == 'q') || (ch == 'Q')) exit(0); }} /* quit if Q entered */\n  while(k!=EOF);\n  printf(\"\\n\\nTotal bytes in file = %d.\\n\",tot);\n  if(prtsw) {\n    fputs(\"\\n\\nTotal bytes in file = \",outfil);\n    fprintf(outfil,\"%d\",tot);\n    fputs(\"\\n\\n\\n\",outfil);\n    fclose(outfil); }\n  fclose(infil); }\nvoid atox(unsigned char ch,  char *hi, char *lo) {\n  char hextbl[]=\"0123456789ABCDEF\";\n\n  *hi=hextbl[ch/16];\n  *lo=hextbl[ch%16];\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "EASTER": {"ttr": 7943, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x001\\x01\\x02\\x11\\x9f\\x01\\x02\\x12?\\t\\x17\\x00&\\x00\\x1f\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-03T09:17:31", "lines": 38, "newlines": 31, "modlines": 0, "user": "BC0THOR"}, "text": "/************/\n/* easter.c */\n/**********************************************************/\n/* compute month and day of easter for any year 1584-2900 */\n/**********************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n\nmain()\n{\n int a,b,c,d,e,f,g,h,i,k,l,m,n,p,year=-1,month,day;\n\n while(year)\n {\n  printf(\"\\nEnter four digit year > 1583 (0 = quit): \");\n  scanf(\"%u\",&year);\n  if(!year)\n   exit(0);\n  a = year % 19;\n  b = year / 100;\n  c = year % 100;\n  d = b / 4;\n  e = b % 4;\n  f = (b+8) / 25;\n  g = (b - f + 1) / 3;\n  h = (19 * a + b - d - g + 15) % 30;\n  i = c / 4;\n  k = c % 4;\n  l = (32 + 2 * e + 2 * i - h - k) % 7;\n  m = (a + 11 * h + 22 * l) / 451;\n  n = (h + l - 7 * m + 114) / 31;\n  p = (h + l - 7 * m + 114) % 31;\n  month = n;\n  day = p + 1;\n  printf(\"\\nEaster will fall on day %d of month %d in the year %d\",\n      day,month,year);\n }\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "EDGEFIND": {"ttr": 7945, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x11\\x01\\x01\\x04?\\x01\\x02\\x12?\\t5\\x01J\\x01>\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2001-02-12T00:00:00", "modifydate": "2002-05-03T09:35:11", "lines": 330, "newlines": 318, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* edgefind.c */\n/*****************************************************************/\n/* This program reads the file of EDGE machine friendly records  */\n/* and writes a list of the csects that contain specific infor-  */\n/* mation. It must be re-specialized for each use.               */\n/*                                                               */\n/* Current code: List Member name and Csect name when Csect name */\n/* matches any entry in the FindName table.                      */\n/*                                                               */\n/* Author R Thornton Feb 2001                                    */\n/*****************************************************************/\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n/*****************************************************************/\n/* Global Data Areas                                             */\n/*****************************************************************/\n/*********************************************************************/\n/*                    Edge Product Record Description                */\n/*  Machine Friendly file - C language format record definition      */\n/*  based on the 05/06/1997 version                                  */\n/*********************************************************************/\n/*********************************************************************/\n/*                    Edge Product Record Description                */\n/*  Machine Friendly file - C language format record definition      */\n/*  based on the 05/06/1997 version                                  */\n/*********************************************************************/\nstruct {\n/*           *****>  csect-data  <*****                              */\nchar Member[8];               /* member name */\nchar AddrMode;                /* addressing mode 2=24, 3=31, a=any   */\nchar ResidMode;               /* residence mode 2=24, 3=31, a=any    */\nchar Csect[8];                /* csect name                          */\nchar Compiler[10];            /* translator id, eg 5734-pl1          */\nchar CompilerVM[4];           /* translator version/mod              */\nchar CompileDate[5];          /* translation date yyddd              */\nchar CsectAmode;              /* csect amode 2=24, 3=31, a=any       */\nchar CsectRmode;              /* csect rmode 2=24, a=any             */\nchar CompType[2];             /* compiler type. potential values:    */\n                              /*        ar = assembler               */\n                              /*        cc = CICS interface          */\n                              /*        ci = ibm c/370               */\n                              /*        cl = lattice c               */\n                              /*        cm = common block            */\n                              /*        cr = cobol runtime           */\n                              /*        cs = sas/c                   */\n                              /*        c2 = vs cobol ii             */\n                              /*        c3 = cobol 370               */\n                              /*        di = db2 interface           */\n                              /*        fg = fortran g / g1          */\n                              /*        fh = fortran h / h - extended*/\n                              /*        fr = fortran runtime         */\n                              /*        fv = vs fortran              */\n                              /*        ii = IMS interface           */\n                              /*        nr = not recognized          */\n                              /*        pm = PL/I for MVS and vm     */\n                              /*        pr = PL/I runtime            */\n                              /*        pv = vs pascal               */\n                              /*        p1 = PL/I optimizer v1       */\n                              /*        p2 = PL/I optimizer v2       */\n                              /*        ur = assembler - identified  */\n                              /*        vs = os/vs cobol             */\n                              /*        v4 = cobol version 4         */\n/*                     *****> extended base portion <*****           */\nchar TimeDate;                /*      1 = contains time svc pattern  */\n                              /*      2 = contains stck instruction  */\n                              /*      3 = contains both              */\n                              /*      4 = cobol accept from date...  */\n                              /*      9 = cobol accept ...other...   */\nchar LmodAttr;                /* load module attributes              */\nchar EPName[8];               /* ext symbol at primary e.p. or mrmem */\nchar CsectSize[8];            /* size of this csect in decimal       */\nchar LoadLib[4];              /* data from /u parm                   */\nchar DateLinked[5];           /* date of last linkedit of module     */\n/*    *****> start of third block of machine record <*****           */\n/*           *****> language dependent fields <*****                 */\n/*      *****> VS COBOL II and COBOL / 370 fields <*****             */\nchar C2Ver[6];                /* vs cobol ii compiler version        */\nchar C2Lvl[4];                /* vs cobol ii user lvl info           */\nchar C2Dat[8];                /* date compiles mm/dd/yy              */\nchar filler1;                 /*                                     */\nchar C2Tim[8];                /* time compiled hh:mm:ss              */\n/*        *****> COBOL II and COBOL 370 only fields <*****           */\nchar C2Adv;                   /* 0=noadv, 1=adv                      */\nchar C2Quot;                  /* 0=quote, 1=apost                    */\nchar C22431;                  /* 0=data24, 1=data31                  */\nchar C2Deck;                  /* 0=nodeck, 1=deck                    */\nchar C2Dump;                  /* 0=nodump, 1=dump                    */\nchar C2Dyna;                  /* 0=nodynam, 1=dynam                  */\nchar C2Fast;                  /* 0=nofastsrt, 1=fastsrt              */\nchar C2Fdum;                  /* 0=nofdump, 1=fdump                  */\nchar C2Lib;                   /* 0=nolib, 1=lib                      */\nchar C2List;                  /* 0=nolist, 1=list                    */\nchar C2Map;                   /* 0=nomap, 1=map                      */\nchar C2Num;                   /* 0=nonum, 1=num                      */\nchar C2Obj;                   /* 0=noobj, 1=obj                      */\nchar C2Offs;                  /* 0=nooffset, 1=offset                */\nchar C2Opt;                   /* 0=nooptimize, 1=optimiz             */\nchar C2Stdd;                  /* 0=nooutdd, 1=outdd                  */\nchar C2Pfd;                   /* rel 1-2: 0=nopfdsgn, 1=pfdsgn       */\n/*                            /* rel 3: 0=numnpfd, 1=numpfd, 2=nummig*/\nchar C2Rent;                  /* 0=norent, 1=rent                    */\nchar C2Res;                   /* 0=nores, 1=res                      */\nchar C2Seq;                   /* 0=noseq, 1=seq                      */\nchar C2Size;                  /* 0=size(n), 1=size(max)              */\nchar C2Sour;                  /* 0=nosource, 1=source                */\nchar C2Ssrn;                  /* 0=nossrange, 1=ssrange              */\nchar C2Term;                  /* 0=noterm, 1=term                    */\nchar C2Test;                  /* 0=notest, 1=test                    */\nchar C2Trun;                  /* rel 1-2: 0=notrunc, 1=trunc         */\n/*                            /* rel 3: 0=truncopt, 1=trunc(std),    */\n/*                            /* 2 = trunc(bin)                      */\nchar C2Rw;                    /* 0=default, 1=userspec word          */\nchar C2Vbre;                  /* 0=novbref, 1=vbref                  */\nchar C2Xref;                  /* 0=noxref, 1=xref                    */\nchar C2Zwb;                   /* 0=nozwb, 1=zwb                      */\n/*          *****> following are rel 3 + only <*****                 */\nchar C2Cmp2;                  /* 0=nocmpr2, 1=cmpr2                  */\nchar C2Name;                  /* 0=noname, 1=name                    */\nchar C2Nmcl;                  /* 0=nmclpri, 1=nmclalt                */\nchar C2Dbcs;                  /* 0=nodbcs, 1=dbcs                    */\nchar C2Awo;                   /* 0=noawo, 1=awo                      */\n/*   *****> the following fields apply only to COBOL/370 <*****      */\nchar C3Eve;                   /* 0=noevents, 1=events                */\nchar C3Cur;                   /* 0=nocurrency, 1=currency            */\nchar C3Rmod;                  /* 0=rmode24, 1=rmode(any)             */\nchar C3Rsv1;                  /* reserved                            */\nchar C3Rsv2;                  /* reserved                            */\nchar C3Rsv3;                  /* reserved                            */\nchar C3Rsv4;                  /* reserved                            */\n/* *****> following field applies to all supported COBOL's <*****    */\nchar CobSm;                   /* 0=no sort/merge found, 1=sort/merge */\nchar CobDc;                   /* cobol dynamic calls found switch:   */\n/*                            /* 0= no dynamic calls found in module */\n/*                      1= call literal forced dynamic found         */\n/*                      2= call dataname found                       */\n/*                      3= call literal forced + call dataname       */\n/*                      4= capex optimizer call adder really 5,6,7   */\n/*                      5= capex call literal forced dynamic found   */\n/*                      6= capex call dataname found                 */\n/*                      7= capex call literal forced + call dataname */\n/* *****> following fields relate to version 4 and OS/VS COBOL <**** */\nchar C4Symd;                  /* 0=nosymdmp, 1=symdmp                */\nchar C4Flow;                  /* 0=noflow, 1=flow                    */\nchar C4Stat;                  /* 0=nostate, 1=state                  */\nchar C4Test;                  /* 0=notest, 1=test                    */\nchar C4Res;                   /* 0=nores, 1=res                      */\nchar C4Endj;                  /* 0=noendjob, 1=endjob                */\nchar C4O370;                  /* 0=obj360, 1=obj370                  */\nchar C4Copt;                  /* 0=compiler not opt., 1=optimized    */\nchar C4Caop;                  /* 0=not capex opt., 1=capex optimized */\nchar C4Cdet;                  /* 0=no capex dtect, 1=capex dtect     */\n/*         *****> following are os/vs only options <*****            */\nchar C4Coun;                  /* 0=no count option, 1=count          */\nchar C4Trac;                  /* 0=no trace option, 1=trace option   */\nchar C4Llvl;                  /* 1=langlvl1, 2=langlvl2              */\nchar C4Syso;                  /* tail char of sysou display ddname   */\nchar C4Rsv1;                  /* reserved                            */\nchar C4Rsv2;                  /* reserved                            */\nchar C4Rsv3;                  /* reserved                            */\n/*             *****> PL/I options <*****                            */\nchar P2Main;                  /* 1=proc options(main), 0=not         */\nchar P2Orde;                  /* 0=noreorder, 1=reorder              */\nchar P2Exec;                  /* 0=noexecops, 1=execops              */\nchar P2Cmpa;                  /* 1=cmpat(v1), 2=cmpat(v2)            */\nchar P2Grap;                  /* 0=nographic, 1=graphic              */\nchar P2Opt;                   /* 0=nooptimize, 1=optimize            */\nchar P2Inte;                  /* 0=nointerupt, 1=interupt            */\nchar P2Flow;                  /* 0=noflow, 1=flow                    */\nchar P2Coun;                  /* 0=nocount, 1=count                  */\nchar P2Test;                  /* 0=notest, 1=test                    */\nchar P2Syst;                  /* 1=CMS, 2=CMSTP, 3=MVS, 4=TSO,       */\n                              /* 5=CICS, 6=IMS                       */\nchar P2Csty;                  /* csect type: 1=compiler generated    */\n                              /* runtime csect, 2=external data csect*/\n                              /* 3=static data csect, 4=code csect   */\nchar filler2[32];             /* reserved                            */\n} mr;                         /* instance of machine friendly record */\n\nstruct {                      /* output record description           */\nchar Member[8];               /* member name                         */\nchar filler1;\nchar Csect[8];                /* csect name                          */\nchar filler2;\nchar LoadLib[4];              /* load library abbreviation           */\nchar filler4;\nchar CompType[2];             /* Compiler type                       */\nchar filler[55];              /*                                     */\n} out;                        /* instance of output record           */\n\nint InputRecords = 0;         /* Number input records                */\nint OutputRecords =0;         /* Number output records               */\nint MoreEdgeRecords = -1;     /* 0 = eof edge machine friendly file  */\nFILE *edgemr,*output1;        /* file pointers                    */\nchar FindName[35][9] = {\"ALLOCDYN\",\n                        \"ALTSAR  \",\n                        \"BLOKHEAD\",\n                        \"CLOSALL \",\n                        \"COBABEND\",\n                        \"COPYREC \",\n                        \"DATEJUL \",\n                        \"DB2ABEND\",\n                        \"DELLIST \",\n                        \"DPKDYNAM\",\n                        \"DYNALLOC\",\n                        \"FILESTAT\",\n                        \"FIXBLK  \",\n                        \"GENLDAT2\",\n                        \"GETJOBN \",\n                        \"GETVOLUM\",\n                        \"ILBCHECK\",\n                        \"IL10STRP\",\n                        \"JOBINFO \",\n                        \"LOADATE \",\n                        \"NOTIME  \",\n                        \"PRTPCH  \",\n                        \"READASUB\",\n                        \"READDIR \",\n                        \"READMEM \",\n                        \"RETCODE \",\n                        \"RETURNCD\",\n                        \"RUX0045P\",\n                        \"RUX0053P\",\n                        \"SCANLIST\",\n                        \"SNAPDUMP\",\n                        \"SWAPPER \",\n                        \"WHEREAMI\",\n                        \"WTO     \",\n                        \"WTOHI   \"};\n/*****************************************************************/\n/* function prototypes                                           */\n/*****************************************************************/\nint main(void);                      /* executive control routine */\nvoid Initialize(void);               /* initialization routine */\nvoid Process(void);                  /* Processing routine */\nvoid ReadEdgeMR(void);               /* reads the EDGEMR file */\nvoid WriteOutput1(void);             /* writes the output1 file */\nvoid Terminate(void);                /* termination routine */\n/*****************************************************************/\n/* main() function: executive control                            */\n/*****************************************************************/\nint main(void) {\n  Initialize();                      /* initialize for Processing */\n  while(MoreEdgeRecords)             /* until edgemr is exhausted, */\n    Process();                       /*    Process records. */\n  Terminate();                       /* Terminate Processing */\n  return(0);\n}\n/*****************************************************************/\n/* Initialize(): initialization routine. opens files.            */\n/*****************************************************************/\nvoid Initialize(void) {\n  edgemr=fopen(\"dd:EDGEMR\",\"rb,type=record,recfm=fb,lrecl=200\");\n  if(edgemr == NULL) {\n    perror(\"\\ncan't open the EDGEMR file\");\n    exit(8);\n  }\n  output1=fopen(\"dd:OUTPUT1\",\"wb,type=record,recfm=fb,lrecl=80\");\n  if(output1 == NULL) {\n    perror(\"\\ncan't open the OUTPUT1 file\");\n    exit(8);\n  }\n  memset(&out, ' ', sizeof(out));\n}\n/*****************************************************************/\n/* Process: Print selected records.                              */\n/*****************************************************************/\nvoid Process(void) {\n  int totctr, i, j;\n\n  ReadEdgeMR();                  /* Read next EDGEMR record */\n  if(!MoreEdgeRecords) return;   /* Return if end of file */\n  for(i=0;i<35;i++) {\n     j = memcmp(FindName[i],mr.Csect,8);\n     if(!j) {\n        memcpy(out.Member, mr.Member, 8); /* format output */\n        memcpy(out.Csect, mr.Csect,8);\n        memcpy(out.LoadLib, mr.LoadLib, 4);\n        memcpy(out.CompType, mr.CompType, 2);\n        WriteOutput1();            /* write OutRec */\n     }\n  }\n}\n/*****************************************************************/\n/* ReadEdgeMR() reads the next record from the EDGEMR file into  */\n/* the mr area. At end of file, the MoreEdgeRecords field is set */\n/* to zero (false).                                              */\n/*****************************************************************/\nvoid ReadEdgeMR(void) {\n  size_t EdgeRecLen;\n\n  EdgeRecLen=fread(&mr, 1,  255, edgemr);\n  if(ferror(edgemr)) {\n    perror(\"\\nError (ferror) reading EDGEMr file\");\n    exit(8);\n  }\n  if(feof(edgemr)) {\n    MoreEdgeRecords = 0;\n    return;\n  }\n  if(EdgeRecLen == 0) {\n    perror(\"\\nError (0 read) reading EDGEMR file\");\n    exit(8);\n  }\n  InputRecords++;\n}\n/*****************************************************************/\n/* WriteOutput1 writes the record in the OutRec area for the     */\n/* length given by the OutRecLen field to the OUTPUT1 file.      */\n/*****************************************************************/\nvoid WriteOutput1(void) {\n  fwrite(&out, 1,  sizeof(out), output1);\n  if(ferror(output1)) {\n    perror(\"\\nError (ferror) writing OUTPUT1 file\");\n    exit(8);\n  }\n  OutputRecords++;\n  memset(&out, ' ', sizeof(out));\n}\n/*****************************************************************/\n/* Terminate() closes the files and prepares for termination.    */\n/*****************************************************************/\nvoid Terminate(void) {\n  printf(\"%d Input Records Read.\\n\",InputRecords);\n  printf(\"%d Output Records Written.\\n\",OutputRecords);\n  fclose(edgemr);\n  fclose(output1);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EDGESTRP": {"ttr": 8193, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00U\\x01\\x006\\x1f\\x01\\x02\\x12?\\t5\\x01@\\x011\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2000-12-26T00:00:00", "modifydate": "2002-05-03T09:35:55", "lines": 320, "newlines": 305, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* edgestrp.c */\n/*****************************************************************/\n/* This program reads the file of EDGE machine friendly records  */\n/* and writes a reformatted version of records for those csects  */\n/* likely to have been written in-house. All records for csects  */\n/* that can be identified as probable program product components,*/\n/* such as COBOL library subroutines, IMS and DB2 utilities, etc,*/\n/* are dropped.                                                  */\n/*                                                               */\n/* In addition, output records are created only for those records*/\n/* where the csect is the entry point for the member and the     */\n/* compiler is COBOL, Assembler, PL/I, C, or Pascal.             */\n/*                                                               */\n/* Author R Thornton dec 2000                                    */\n/*****************************************************************/\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n/*****************************************************************/\n/* Global Data Areas                                             */\n/*****************************************************************/\n/*********************************************************************/\n/*                    Edge Product Record Description                */\n/*  Machine Friendly file - C language format record definition      */\n/*  based on the 05/06/1997 version                                  */\n/*********************************************************************/\n/*********************************************************************/\n/*                    Edge Product Record Description                */\n/*  Machine Friendly file - C language format record definition      */\n/*  based on the 05/06/1997 version                                  */\n/*********************************************************************/\nstruct {\n/*           *****>  csect-data  <*****                              */\nchar Member[8];               /* member name */\nchar AddrMode;                /* addressing mode 2=24, 3=31, a=any   */\nchar ResidMode;               /* residence mode 2=24, 3=31, a=any    */\nchar Csect[8];                /* csect name                          */\nchar Compiler[10];            /* translator id, eg 5734-pl1          */\nchar CompilerVM[4];           /* translator version/mod              */\nchar CompileDate[5];          /* translation date yyddd              */\nchar CsectAmode;              /* csect amode 2=24, 3=31, a=any       */\nchar CsectRmode;              /* csect rmode 2=24, a=any             */\nchar CompType[2];             /* compiler type. potential values:    */\n                              /*        ar = assembler               */\n                              /*        cc = CICS interface          */\n                              /*        ci = ibm c/370               */\n                              /*        cl = lattice c               */\n                              /*        cm = common block            */\n                              /*        cr = cobol runtime           */\n                              /*        cs = sas/c                   */\n                              /*        c2 = vs cobol ii             */\n                              /*        c3 = cobol 370               */\n                              /*        di = db2 interface           */\n                              /*        fg = fortran g / g1          */\n                              /*        fh = fortran h / h - extended*/\n                              /*        fr = fortran runtime         */\n                              /*        fv = vs fortran              */\n                              /*        ii = IMS interface           */\n                              /*        nr = not recognized          */\n                              /*        pm = PL/I for MVS and vm     */\n                              /*        pr = PL/I runtime            */\n                              /*        pv = vs pascal               */\n                              /*        p1 = PL/I optimizer v1       */\n                              /*        p2 = PL/I optimizer v2       */\n                              /*        ur = assembler - identified  */\n                              /*        vs = os/vs cobol             */\n                              /*        v4 = cobol version 4         */\n/*                     *****> extended base portion <*****           */\nchar TimeDate;                /*      1 = contains time svc pattern  */\n                              /*      2 = contains stck instruction  */\n                              /*      3 = contains both              */\n                              /*      4 = cobol accept from date...  */\n                              /*      9 = cobol accept ...other...   */\nchar LmodAttr;                /* load module attributes              */\nchar EPName[8];               /* ext symbol at primary e.p. or mrmem */\nchar CsectSize[8];            /* size of this csect in decimal       */\nchar LoadLib[4];              /* data from /u parm                   */\nchar DateLinked[5];           /* date of last linkedit of module     */\n/*    *****> start of third block of machine record <*****           */\n/*           *****> language dependent fields <*****                 */\n/*      *****> VS COBOL II and COBOL / 370 fields <*****             */\nchar C2Ver[6];                /* vs cobol ii compiler version        */\nchar C2Lvl[4];                /* vs cobol ii user lvl info           */\nchar C2Dat[8];                /* date compiles mm/dd/yy              */\nchar filler1;                 /*                                     */\nchar C2Tim[8];                /* time compiled hh:mm:ss              */\n/*        *****> COBOL II and COBOL 370 only fields <*****           */\nchar C2Adv;                   /* 0=noadv, 1=adv                      */\nchar C2Quot;                  /* 0=quote, 1=apost                    */\nchar C22431;                  /* 0=data24, 1=data31                  */\nchar C2Deck;                  /* 0=nodeck, 1=deck                    */\nchar C2Dump;                  /* 0=nodump, 1=dump                    */\nchar C2Dyna;                  /* 0=nodynam, 1=dynam                  */\nchar C2Fast;                  /* 0=nofastsrt, 1=fastsrt              */\nchar C2Fdum;                  /* 0=nofdump, 1=fdump                  */\nchar C2Lib;                   /* 0=nolib, 1=lib                      */\nchar C2List;                  /* 0=nolist, 1=list                    */\nchar C2Map;                   /* 0=nomap, 1=map                      */\nchar C2Num;                   /* 0=nonum, 1=num                      */\nchar C2Obj;                   /* 0=noobj, 1=obj                      */\nchar C2Offs;                  /* 0=nooffset, 1=offset                */\nchar C2Opt;                   /* 0=nooptimize, 1=optimiz             */\nchar C2Stdd;                  /* 0=nooutdd, 1=outdd                  */\nchar C2Pfd;                   /* rel 1-2: 0=nopfdsgn, 1=pfdsgn       */\n/*                            /* rel 3: 0=numnpfd, 1=numpfd, 2=nummig*/\nchar C2Rent;                  /* 0=norent, 1=rent                    */\nchar C2Res;                   /* 0=nores, 1=res                      */\nchar C2Seq;                   /* 0=noseq, 1=seq                      */\nchar C2Size;                  /* 0=size(n), 1=size(max)              */\nchar C2Sour;                  /* 0=nosource, 1=source                */\nchar C2Ssrn;                  /* 0=nossrange, 1=ssrange              */\nchar C2Term;                  /* 0=noterm, 1=term                    */\nchar C2Test;                  /* 0=notest, 1=test                    */\nchar C2Trun;                  /* rel 1-2: 0=notrunc, 1=trunc         */\n/*                            /* rel 3: 0=truncopt, 1=trunc(std),    */\n/*                            /* 2 = trunc(bin)                      */\nchar C2Rw;                    /* 0=default, 1=userspec word          */\nchar C2Vbre;                  /* 0=novbref, 1=vbref                  */\nchar C2Xref;                  /* 0=noxref, 1=xref                    */\nchar C2Zwb;                   /* 0=nozwb, 1=zwb                      */\n/*          *****> following are rel 3 + only <*****                 */\nchar C2Cmp2;                  /* 0=nocmpr2, 1=cmpr2                  */\nchar C2Name;                  /* 0=noname, 1=name                    */\nchar C2Nmcl;                  /* 0=nmclpri, 1=nmclalt                */\nchar C2Dbcs;                  /* 0=nodbcs, 1=dbcs                    */\nchar C2Awo;                   /* 0=noawo, 1=awo                      */\n/*   *****> the following fields apply only to COBOL/370 <*****      */\nchar C3Eve;                   /* 0=noevents, 1=events                */\nchar C3Cur;                   /* 0=nocurrency, 1=currency            */\nchar C3Rmod;                  /* 0=rmode24, 1=rmode(any)             */\nchar C3Rsv1;                  /* reserved                            */\nchar C3Rsv2;                  /* reserved                            */\nchar C3Rsv3;                  /* reserved                            */\nchar C3Rsv4;                  /* reserved                            */\n/* *****> following field applies to all supported COBOL's <*****    */\nchar CobSm;                   /* 0=no sort/merge found, 1=sort/merge */\nchar CobDc;                   /* cobol dynamic calls found switch:   */\n/*                            /* 0= no dynamic calls found in module */\n/*                      1= call literal forced dynamic found         */\n/*                      2= call dataname found                       */\n/*                      3= call literal forced + call dataname       */\n/*                      4= capex optimizer call adder really 5,6,7   */\n/*                      5= capex call literal forced dynamic found   */\n/*                      6= capex call dataname found                 */\n/*                      7= capex call literal forced + call dataname */\n/* *****> following fields relate to version 4 and OS/VS COBOL <**** */\nchar C4Symd;                  /* 0=nosymdmp, 1=symdmp                */\nchar C4Flow;                  /* 0=noflow, 1=flow                    */\nchar C4Stat;                  /* 0=nostate, 1=state                  */\nchar C4Test;                  /* 0=notest, 1=test                    */\nchar C4Res;                   /* 0=nores, 1=res                      */\nchar C4Endj;                  /* 0=noendjob, 1=endjob                */\nchar C4O370;                  /* 0=obj360, 1=obj370                  */\nchar C4Copt;                  /* 0=compiler not opt., 1=optimized    */\nchar C4Caop;                  /* 0=not capex opt., 1=capex optimized */\nchar C4Cdet;                  /* 0=no capex dtect, 1=capex dtect     */\n/*         *****> following are os/vs only options <*****            */\nchar C4Coun;                  /* 0=no count option, 1=count          */\nchar C4Trac;                  /* 0=no trace option, 1=trace option   */\nchar C4Llvl;                  /* 1=langlvl1, 2=langlvl2              */\nchar C4Syso;                  /* tail char of sysou display ddname   */\nchar C4Rsv1;                  /* reserved                            */\nchar C4Rsv2;                  /* reserved                            */\nchar C4Rsv3;                  /* reserved                            */\n/*             *****> PL/I options <*****                            */\nchar P2Main;                  /* 1=proc options(main), 0=not         */\nchar P2Orde;                  /* 0=noreorder, 1=reorder              */\nchar P2Exec;                  /* 0=noexecops, 1=execops              */\nchar P2Cmpa;                  /* 1=cmpat(v1), 2=cmpat(v2)            */\nchar P2Grap;                  /* 0=nographic, 1=graphic              */\nchar P2Opt;                   /* 0=nooptimize, 1=optimize            */\nchar P2Inte;                  /* 0=nointerupt, 1=interupt            */\nchar P2Flow;                  /* 0=noflow, 1=flow                    */\nchar P2Coun;                  /* 0=nocount, 1=count                  */\nchar P2Test;                  /* 0=notest, 1=test                    */\nchar P2Syst;                  /* 1=CMS, 2=CMSTP, 3=MVS, 4=TSO,       */\n                              /* 5=CICS, 6=IMS                       */\nchar P2Csty;                  /* csect type: 1=compiler generated    */\n                              /* runtime csect, 2=external data csect*/\n                              /* 3=static data csect, 4=code csect   */\nchar filler2[32];             /* reserved                            */\n} mr;                         /* instance of machine friendly record */\n\nstruct {                      /* output record description           */\nchar Member[8];               /* member name                         */\nchar filler1;\nchar Csect[8];                /* csect name                          */\nchar filler2;\nchar LoadLib[4];              /* load library abbreviation           */\nchar filler4;\nchar CompType[2];             /* Compiler type                       */\nchar filler[55];              /*                                     */\n} out;                        /* instance of output record           */\n\nint InputRecords = 0;         /* Number input records                */\nint OutputRecords =0;         /* Number output records               */\nint MoreEdgeRecords = -1;     /* 0 = eof edge machine friendly file  */\nFILE *edgemr,*output1;        /* file pointers                    */\n/*****************************************************************/\n/* function prototypes                                           */\n/*****************************************************************/\nint main(void);                      /* executive control routine */\nvoid Initialize(void);               /* initialization routine */\nvoid Process(void);                  /* Processing routine */\nint  DropProgramProducts(void);      /* Drop Program Product csects */\nvoid ReadEdgeMR(void);               /* reads the EDGEMR file */\nvoid WriteOutput1(void);             /* writes the output1 file */\nvoid Terminate(void);                /* termination routine */\n/*****************************************************************/\n/* main() function: executive control                            */\n/*****************************************************************/\nint main(void) {\n  Initialize();                      /* initialize for Processing */\n  while(MoreEdgeRecords)             /* until edgemr is exhausted, */\n    Process();                       /*    Process records. */\n  Terminate();                       /* Terminate Processing */\n  return(0);\n}\n/*****************************************************************/\n/* Initialize(): initialization routine. opens files.            */\n/*****************************************************************/\nvoid Initialize(void) {\n  edgemr=fopen(\"dd:EDGEMR\",\"rb,type=record,recfm=fb,lrecl=200\");\n  if(edgemr == NULL) {\n    perror(\"\\ncan't open the EDGEMR file\");\n    exit(8);\n  }\n  output1=fopen(\"dd:OUTPUT1\",\"wb,type=record,recfm=fb,lrecl=80\");\n  if(output1 == NULL) {\n    perror(\"\\ncan't open the OUTPUT1 file\");\n    exit(8);\n  }\n  memset(&out, ' ', sizeof(out));\n}\n/*****************************************************************/\n/* Process: for each record in the ELEMENTS file for an in-house */\n/* module, format and write an output record.                    */\n/*****************************************************************/\nvoid Process(void) {\n  int totctr;\n\n  ReadEdgeMR();                  /* Read next EDGEMR record */\n  if(!MoreEdgeRecords) return;   /* Return if end of file */\n  if(DropProgramProducts()) return; /* drop program product stuff */\n  memcpy(out.Member, mr.Member, 8); /* format output record... */\n  memcpy(out.Csect, mr.Csect,8);\n  memcpy(out.LoadLib, mr.LoadLib, 4);\n  memcpy(out.CompType, mr.CompType, 2);\n  WriteOutput1();            /* write OutRec to output1 file */\n}\n/*****************************************************************/\n/* DropProgramProducts tests the EDGE machine record csect name  */\n/* to see if it is a component of a program product, such as the */\n/* COBOL compiler, LE, IMS, DB2, etc. If it is part of a program */\n/* product, return is 1. Return is also 1 when the csect is not  */\n/* the entry point for the member. Also, records are dropped when*/\n/* the compiler is not COBOL, Assembler, PL/I, C, or Pascal.     */\n/*****************************************************************/\nint DropProgramProducts(void) {\n  int i;\n  #define NUMCMPLRS 21\n  static char Compilers[NUMCMPLRS][3] = {\n     \"C2\",\"VS\",\"AR\",\"C3\",\"CI\",\"P1\",\"P2\",\"CP\",\"PL\",\"PM\",\"PV\",\"VO\",\"V4\",\n     \"BA\",\"CL\",\"CS\",\"EZ\",\"FG\",\"FH\",\"FV\",\"RE\"\n  };\n\n  if(memcmp(mr.Csect, mr.EPName, 8) != 0) /* only keep entry csects */\n    return(-1);\n  for(i=0; i < NUMCMPLRS; i++)\n    if(memcmp(mr.CompType, Compilers[i], 2) == 0)\n      return(0);\n  return(-1);\n}\n/*****************************************************************/\n/* ReadEdgeMR() reads the next record from the EDGEMR file into  */\n/* the mr area. At end of file, the MoreEdgeRecords field is set */\n/* to zero (false).                                              */\n/*****************************************************************/\nvoid ReadEdgeMR(void) {\n  size_t EdgeRecLen;\n\n  EdgeRecLen=fread(&mr, 1,  255, edgemr);\n  if(ferror(edgemr)) {\n    perror(\"\\nError (ferror) reading EDGEMr file\");\n    exit(8);\n  }\n  if(feof(edgemr)) {\n    MoreEdgeRecords = 0;\n    return;\n  }\n  if(EdgeRecLen == 0) {\n    perror(\"\\nError (0 read) reading EDGEMR file\");\n    exit(8);\n  }\n  InputRecords++;\n}\n/*****************************************************************/\n/* WriteOutput1 writes the record in the OutRec area for the     */\n/* length given by the OutRecLen field to the OUTPUT1 file.      */\n/*****************************************************************/\nvoid WriteOutput1(void) {\n  fwrite(&out, 1,  sizeof(out), output1);\n  if(ferror(output1)) {\n    perror(\"\\nError (ferror) writing OUTPUT1 file\");\n    exit(8);\n  }\n  OutputRecords++;\n  memset(&out, ' ', sizeof(out));\n}\n/*****************************************************************/\n/* Terminate() closes the files and prepares for termination.    */\n/*****************************************************************/\nvoid Terminate(void) {\n  printf(\"%d Input Records Read.\\n\",InputRecords);\n  printf(\"%d Output Records Written.\\n\",OutputRecords);\n  fclose(edgemr);\n  fclose(output1);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EDGEVSCB": {"ttr": 8199, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00I\\x01\\x01\\x06\\x8f\\x01\\x02\\x12?\\t6\\x01#\\x01$\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2001-03-09T00:00:00", "modifydate": "2002-05-03T09:36:49", "lines": 291, "newlines": 292, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* edgevscb.c */\n/*****************************************************************/\n/* This program reads the file of EDGE machine friendly records  */\n/* and writes a list of the csects that were compiled by the     */\n/* vs cobol compiler or by the cobol/390 compiler.               */\n/*                                                               */\n/* Author R Thornton Mar 2001                                    */\n/*****************************************************************/\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n/*****************************************************************/\n/* Global Data Areas                                             */\n/*****************************************************************/\n/*********************************************************************/\n/*                    Edge Product Record Description                */\n/*  Machine Friendly file - C language format record definition      */\n/*  based on the 05/06/1997 version                                  */\n/*********************************************************************/\n/*********************************************************************/\n/*                    Edge Product Record Description                */\n/*  Machine Friendly file - C language format record definition      */\n/*  based on the 05/06/1997 version                                  */\n/*********************************************************************/\nstruct {\n/*           *****>  csect-data  <*****                              */\nchar Member[8];               /* member name */\nchar AddrMode;                /* addressing mode 2=24, 3=31, a=any   */\nchar ResidMode;               /* residence mode 2=24, 3=31, a=any    */\nchar Csect[8];                /* csect name                          */\nchar Compiler[10];            /* translator id, eg 5734-pl1          */\nchar CompilerVM[4];           /* translator version/mod              */\nchar CompileDate[5];          /* translation date yyddd              */\nchar CsectAmode;              /* csect amode 2=24, 3=31, a=any       */\nchar CsectRmode;              /* csect rmode 2=24, a=any             */\nchar CompType[2];             /* compiler type. potential values:    */\n                              /*        ar = assembler               */\n                              /*        cc = CICS interface          */\n                              /*        ci = ibm c/370               */\n                              /*        cl = lattice c               */\n                              /*        cm = common block            */\n                              /*        cr = cobol runtime           */\n                              /*        cs = sas/c                   */\n                              /*        c2 = vs cobol ii             */\n                              /*        c3 = cobol 370               */\n                              /*        di = db2 interface           */\n                              /*        fg = fortran g / g1          */\n                              /*        fh = fortran h / h - extended*/\n                              /*        fr = fortran runtime         */\n                              /*        fv = vs fortran              */\n                              /*        ii = IMS interface           */\n                              /*        nr = not recognized          */\n                              /*        pm = PL/I for MVS and vm     */\n                              /*        pr = PL/I runtime            */\n                              /*        pv = vs pascal               */\n                              /*        p1 = PL/I optimizer v1       */\n                              /*        p2 = PL/I optimizer v2       */\n                              /*        ur = assembler - identified  */\n                              /*        vs = os/vs cobol             */\n                              /*        v4 = cobol version 4         */\n/*                     *****> extended base portion <*****           */\nchar TimeDate;                /*      1 = contains time svc pattern  */\n                              /*      2 = contains stck instruction  */\n                              /*      3 = contains both              */\n                              /*      4 = cobol accept from date...  */\n                              /*      9 = cobol accept ...other...   */\nchar LmodAttr;                /* load module attributes              */\nchar EPName[8];               /* ext symbol at primary e.p. or mrmem */\nchar CsectSize[8];            /* size of this csect in decimal       */\nchar LoadLib[4];              /* data from /u parm                   */\nchar DateLinked[5];           /* date of last linkedit of module     */\n/*    *****> start of third block of machine record <*****           */\n/*           *****> language dependent fields <*****                 */\n/*      *****> VS COBOL II and COBOL / 370 fields <*****             */\nchar C2Ver[6];                /* vs cobol ii compiler version        */\nchar C2Lvl[4];                /* vs cobol ii user lvl info           */\nchar C2Dat[8];                /* date compiles mm/dd/yy              */\nchar filler1;                 /*                                     */\nchar C2Tim[8];                /* time compiled hh:mm:ss              */\n/*        *****> COBOL II and COBOL 370 only fields <*****           */\nchar C2Adv;                   /* 0=noadv, 1=adv                      */\nchar C2Quot;                  /* 0=quote, 1=apost                    */\nchar C22431;                  /* 0=data24, 1=data31                  */\nchar C2Deck;                  /* 0=nodeck, 1=deck                    */\nchar C2Dump;                  /* 0=nodump, 1=dump                    */\nchar C2Dyna;                  /* 0=nodynam, 1=dynam                  */\nchar C2Fast;                  /* 0=nofastsrt, 1=fastsrt              */\nchar C2Fdum;                  /* 0=nofdump, 1=fdump                  */\nchar C2Lib;                   /* 0=nolib, 1=lib                      */\nchar C2List;                  /* 0=nolist, 1=list                    */\nchar C2Map;                   /* 0=nomap, 1=map                      */\nchar C2Num;                   /* 0=nonum, 1=num                      */\nchar C2Obj;                   /* 0=noobj, 1=obj                      */\nchar C2Offs;                  /* 0=nooffset, 1=offset                */\nchar C2Opt;                   /* 0=nooptimize, 1=optimiz             */\nchar C2Stdd;                  /* 0=nooutdd, 1=outdd                  */\nchar C2Pfd;                   /* rel 1-2: 0=nopfdsgn, 1=pfdsgn       */\n/*                            /* rel 3: 0=numnpfd, 1=numpfd, 2=nummig*/\nchar C2Rent;                  /* 0=norent, 1=rent                    */\nchar C2Res;                   /* 0=nores, 1=res                      */\nchar C2Seq;                   /* 0=noseq, 1=seq                      */\nchar C2Size;                  /* 0=size(n), 1=size(max)              */\nchar C2Sour;                  /* 0=nosource, 1=source                */\nchar C2Ssrn;                  /* 0=nossrange, 1=ssrange              */\nchar C2Term;                  /* 0=noterm, 1=term                    */\nchar C2Test;                  /* 0=notest, 1=test                    */\nchar C2Trun;                  /* rel 1-2: 0=notrunc, 1=trunc         */\n/*                            /* rel 3: 0=truncopt, 1=trunc(std),    */\n/*                            /* 2 = trunc(bin)                      */\nchar C2Rw;                    /* 0=default, 1=userspec word          */\nchar C2Vbre;                  /* 0=novbref, 1=vbref                  */\nchar C2Xref;                  /* 0=noxref, 1=xref                    */\nchar C2Zwb;                   /* 0=nozwb, 1=zwb                      */\n/*          *****> following are rel 3 + only <*****                 */\nchar C2Cmp2;                  /* 0=nocmpr2, 1=cmpr2                  */\nchar C2Name;                  /* 0=noname, 1=name                    */\nchar C2Nmcl;                  /* 0=nmclpri, 1=nmclalt                */\nchar C2Dbcs;                  /* 0=nodbcs, 1=dbcs                    */\nchar C2Awo;                   /* 0=noawo, 1=awo                      */\n/*   *****> the following fields apply only to COBOL/370 <*****      */\nchar C3Eve;                   /* 0=noevents, 1=events                */\nchar C3Cur;                   /* 0=nocurrency, 1=currency            */\nchar C3Rmod;                  /* 0=rmode24, 1=rmode(any)             */\nchar C3Rsv1;                  /* reserved                            */\nchar C3Rsv2;                  /* reserved                            */\nchar C3Rsv3;                  /* reserved                            */\nchar C3Rsv4;                  /* reserved                            */\n/* *****> following field applies to all supported COBOL's <*****    */\nchar CobSm;                   /* 0=no sort/merge found, 1=sort/merge */\nchar CobDc;                   /* cobol dynamic calls found switch:   */\n/*                            /* 0= no dynamic calls found in module */\n/*                      1= call literal forced dynamic found         */\n/*                      2= call dataname found                       */\n/*                      3= call literal forced + call dataname       */\n/*                      4= capex optimizer call adder really 5,6,7   */\n/*                      5= capex call literal forced dynamic found   */\n/*                      6= capex call dataname found                 */\n/*                      7= capex call literal forced + call dataname */\n/* *****> following fields relate to version 4 and OS/VS COBOL <**** */\nchar C4Symd;                  /* 0=nosymdmp, 1=symdmp                */\nchar C4Flow;                  /* 0=noflow, 1=flow                    */\nchar C4Stat;                  /* 0=nostate, 1=state                  */\nchar C4Test;                  /* 0=notest, 1=test                    */\nchar C4Res;                   /* 0=nores, 1=res                      */\nchar C4Endj;                  /* 0=noendjob, 1=endjob                */\nchar C4O370;                  /* 0=obj360, 1=obj370                  */\nchar C4Copt;                  /* 0=compiler not opt., 1=optimized    */\nchar C4Caop;                  /* 0=not capex opt., 1=capex optimized */\nchar C4Cdet;                  /* 0=no capex dtect, 1=capex dtect     */\n/*         *****> following are os/vs only options <*****            */\nchar C4Coun;                  /* 0=no count option, 1=count          */\nchar C4Trac;                  /* 0=no trace option, 1=trace option   */\nchar C4Llvl;                  /* 1=langlvl1, 2=langlvl2              */\nchar C4Syso;                  /* tail char of sysou display ddname   */\nchar C4Rsv1;                  /* reserved                            */\nchar C4Rsv2;                  /* reserved                            */\nchar C4Rsv3;                  /* reserved                            */\n/*             *****> PL/I options <*****                            */\nchar P2Main;                  /* 1=proc options(main), 0=not         */\nchar P2Orde;                  /* 0=noreorder, 1=reorder              */\nchar P2Exec;                  /* 0=noexecops, 1=execops              */\nchar P2Cmpa;                  /* 1=cmpat(v1), 2=cmpat(v2)            */\nchar P2Grap;                  /* 0=nographic, 1=graphic              */\nchar P2Opt;                   /* 0=nooptimize, 1=optimize            */\nchar P2Inte;                  /* 0=nointerupt, 1=interupt            */\nchar P2Flow;                  /* 0=noflow, 1=flow                    */\nchar P2Coun;                  /* 0=nocount, 1=count                  */\nchar P2Test;                  /* 0=notest, 1=test                    */\nchar P2Syst;                  /* 1=CMS, 2=CMSTP, 3=MVS, 4=TSO,       */\n                              /* 5=CICS, 6=IMS                       */\nchar P2Csty;                  /* csect type: 1=compiler generated    */\n                              /* runtime csect, 2=external data csect*/\n                              /* 3=static data csect, 4=code csect   */\nchar filler2[32];             /* reserved                            */\n} mr;                         /* instance of machine friendly record */\n\nstruct {                      /* output record description           */\nchar Member[8];               /* member name                         */\nchar filler1;\nchar Csect[8];                /* csect name                          */\nchar filler2;\nchar LoadLib[4];              /* load library abbreviation           */\nchar filler4;\nchar CompType[2];             /* Compiler type                       */\nchar filler[55];              /*                                     */\n} out;                        /* instance of output record           */\n\nint InputRecords = 0;         /* Number input records                */\nint OutputRecords =0;         /* Number output records               */\nint MoreEdgeRecords = -1;     /* 0 = eof edge machine friendly file  */\nFILE *edgemr,*output1;        /* file pointers                    */\n/*****************************************************************/\n/* function prototypes                                           */\n/*****************************************************************/\nint main(void);                      /* executive control routine */\nvoid Initialize(void);               /* initialization routine */\nvoid Process(void);                  /* Processing routine */\nvoid ReadEdgeMR(void);               /* reads the EDGEMR file */\nvoid WriteOutput1(void);             /* writes the output1 file */\nvoid Terminate(void);                /* termination routine */\n/*****************************************************************/\n/* main() function: executive control                            */\n/*****************************************************************/\nint main(void) {\n  Initialize();                      /* initialize for Processing */\n  while(MoreEdgeRecords)             /* until edgemr is exhausted, */\n    Process();                       /*    Process records. */\n  Terminate();                       /* Terminate Processing */\n  return(0);\n}\n/*****************************************************************/\n/* Initialize(): initialization routine. opens files.            */\n/*****************************************************************/\nvoid Initialize(void) {\n  edgemr=fopen(\"dd:EDGEMR\",\"rb,type=record,recfm=fb,lrecl=200\");\n  if(edgemr == NULL) {\n    perror(\"\\ncan't open the EDGEMR file\");\n    exit(8);\n  }\n  output1=fopen(\"dd:OUTPUT1\",\"wb,type=record,recfm=fb,lrecl=80\");\n  if(output1 == NULL) {\n    perror(\"\\ncan't open the OUTPUT1 file\");\n    exit(8);\n  }\n  memset(&out, ' ', sizeof(out));\n}\n/*****************************************************************/\n/* Process: Print selected records.                              */\n/*****************************************************************/\nvoid Process(void) {\n  int totctr;\n\n  ReadEdgeMR();                  /* Read next EDGEMR record */\n  if(!MoreEdgeRecords) return;   /* Return if end of file */\n  if((mr.CompType[0] == 'V') &&\n     ((mr.CompType[1] == 'S') || (mr.CompType[1] == '4')))\n        WriteOutput1();         /* write OutRec to output1 file */\n  if((mr.CompType[0] == 'C') &&  (mr.CompType[1] == '3'))\n     WriteOutput1();            /* write OutRec to output1 file */\n}\n/*****************************************************************/\n/* ReadEdgeMR() reads the next record from the EDGEMR file into  */\n/* the mr area. At end of file, the MoreEdgeRecords field is set */\n/* to zero (false).                                              */\n/*****************************************************************/\nvoid ReadEdgeMR(void) {\n  size_t EdgeRecLen;\n\n  EdgeRecLen=fread(&mr, 1,  255, edgemr);\n  if(ferror(edgemr)) {\n    perror(\"\\nError (ferror) reading EDGEMr file\");\n    exit(8);\n  }\n  if(feof(edgemr)) {\n    MoreEdgeRecords = 0;\n    return;\n  }\n  if(EdgeRecLen == 0) {\n    perror(\"\\nError (0 read) reading EDGEMR file\");\n    exit(8);\n  }\n  InputRecords++;\n}\n/*****************************************************************/\n/* WriteOutput1 writes the record in the OutRec area for the     */\n/* length given by the OutRecLen field to the OUTPUT1 file.      */\n/*****************************************************************/\nvoid WriteOutput1(void) {\n  memcpy(out.Member, mr.Member, 8); /* format output record... */\n  memcpy(out.Csect, mr.Csect,8);\n  memcpy(out.LoadLib, mr.LoadLib, 4);\n  memcpy(out.CompType, mr.CompType, 2);\n  fwrite(&out, 1,  sizeof(out), output1);\n  if(ferror(output1)) {\n    perror(\"\\nError (ferror) writing OUTPUT1 file\");\n    exit(8);\n  }\n  OutputRecords++;\n  memset(&out, ' ', sizeof(out));\n}\n/*****************************************************************/\n/* Terminate() closes the files and prepares for termination.    */\n/*****************************************************************/\nvoid Terminate(void) {\n  printf(\"%d Input Records Read.\\n\",InputRecords);\n  printf(\"%d Output Records Written.\\n\",OutputRecords);\n  fclose(edgemr);\n  fclose(output1);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EDIT": {"ttr": 8449, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00E\\x01\\x02\\x11\\x9f\\x01\\x02\\x12?\\t8\\x00\\xc0\\x00\\xc0\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-03T09:38:45", "lines": 192, "newlines": 192, "modlines": 0, "user": "BC0THOR"}, "text": "/**********/\n/* edit.c */\n/*********************************************************************/\n/*                     Generic edit subroutine                       */\n/* The edit function provides numeric report editing, including      */\n/* leading zero suppression, check protection, floating $, leading   */\n/* or trailing minus sign, insertion of commas, decimal points and   */\n/* other non-numeric fields. The first parameter is the address of   */\n/* the edited output, whose size will be the same as the pattern.    */\n/* The second parameter is the editing pattern, which must be a true */\n/* null-terminated string containing the edit pattern. The third     */\n/* is the number to be edited, a null-terminated string containing   */\n/* only digits 0-9 except the first position, which is a -, if the   */\n/* number is negative. The pattern may be up to 64 characters, and   */\n/* the number to be edited may contain up to 32 characters. The      */\n/* number may not contain more significant digits than there are     */\n/* digit select characters in the pattern. If there are more digits  */\n/* selected by the pattern than there are in the number, leading     */\n/* zeros will be assumed. In the pattern, the first character may    */\n/* be:      $ (floating dollar sign)                                 */\n/*          * (check protection)                                     */\n/*          - (floating minus sign)                                  */\n/* The body of the edit pattern will be composed of digit select     */\n/* characters (z and 9) and other characters, handled as follows:    */\n/*          z (zero suppression output is a blank in this position   */\n/*             until significance is set by receipt of a significant */\n/*             digit or a 9 in the pattern. After significance is    */\n/*             set, output is a digit from the number.)              */\n/*          9 (output is a digit from the number and significance    */\n/*             is set, even if the digit is a leading zero.)         */\n/*        other characters in the pattern will be output as-is after */\n/*             significance is set, but will be output as blanks     */\n/*             before significance is set.                           */\n/* Characters in the pattern following the last digit select will    */\n/* be output as-is if the number is negative, otherwise output will  */\n/* be blanks for these pattern positions.                            */\n/*                                                                   */\n/* When * check protection is selected, output will be *, rather     */\n/* than blanks as mentioned above.                                   */\n/*                                                                   */\n/* An integer is returned to indicate success or errors:             */\n/*                 0 = successful edit                               */\n/*                 1 = pattern too long (over 64 characters)         */\n/*                 2 = too many digits selected (over 32)            */\n/*                 3 = no output digits selected in pattern          */\n/*                 4 = number contains non-numeric data              */\n/*                 5 = number has more digits than the pattern       */\n/*                                                                   */\n/* Examples:                            nbr=             outf=       */\n/*    err=edit(outf,\"zz,zz9.99-\",nbr);  0                     0.00   */\n/*                                      123                   1.23   */\n/*                                      562983            5,629.83   */\n/*                                      -4675                46.75-  */\n/*    err=edit(outf,\"$,$$$.$$\",nbr);    0                            */\n/*                                      123                  $1.23   */\n/*                                      562983           $5,629.83   */\n/*                                      -4675               $46.75   */\n/*    err=edit(outf,\"***.**\",nbr);      0                            */\n/*                                      123                 **1.23   */\n/*                                      562983   err = 5             */\n/*                                      -4675               *46.75   */\n/*    err=edit(outf,\"--,--9.99\",nbr);   0                     0.00   */\n/*                                      123                   1.23   */\n/*                                      562983            5,629.83   */\n/*                                      -46.75              -46.75   */\n/*                                                                   */\n/* Author R Thornton April 1989                                      */\n/*********************************************************************/\n/**/\nint edit(char output[], char pattern[], char number[]) {\n  char float_val = ' ';\n  char fill_val = ' ';\n  char sign_val = ' ';\n  int signif = 0;\n  int psize = 0;\n  int pdig = 0;\n  int plast = 0;\n  int ndig = 0;\n  char nbr[33];\n  char ch= ' ';\n  int po=0;\n  int n=0;\n\n/****************************************************************/\n/* examine pattern: set up float and fill, count size and digits*/\n/****************************************************************/\n  if(((ch=pattern[0]) == '$') || (ch == '*') || (ch == '-'))\n    float_val = ch;\n  if(ch == '*')\n    fill_val = '*';\n  while((ch=pattern[po]) != '\\0') {\n    if((ch == 'z') || (ch == '9')) {\n      pdig++;\n      plast = po;\n    }\n    psize++;\n    po++;\n  }\n  if(psize > 63)\n    return(1);\n  if(pdig > 32)\n    return(2);\n  if(!pdig)\n    return(3);\n/****************************************************************/\n/* examine number: set up sign, count digits, check numeric.    */\n/* set error if more digits than pattern, move right justified  */\n/****************************************************************/\n  if(number[0] == '-') {\n    sign_val = '-';\n    n = 1;\n  }\n  while((ch=number[n]) != '\\0') {\n    if((ch < '0') || (ch > '9'))\n      return(4);\n    ndig++;\n    n++;\n  }\n  if(ndig > pdig)\n    return(5);\n  for(po=0;po<(pdig-ndig);po++)\n    nbr[po] = '0';\n  if(sign_val == ' ')\n    n = 0;\n  else\n    n=1;\n  for(;po<pdig;po++,n++)\n    nbr[po] = number[n];\n/****************************************************************/\n/* scan across the pattern, setting the corresponding output    */\n/* byte from pattern, fill, or amt depending on the pattern     */\n/* character and state of significance.                         */\n/****************************************************************/\n  if(float_val != ' ') {\n    output[0] = ' ';\n    po = 1;\n  }\n  else\n    po = 0;\n  n = 0;\n  while((po <= plast)) {\n    ch = pattern[po];\n    if(ch == 'z') {\n      if(signif) {\n        output[po] = nbr[n];\n        n++;\n      }\n      else {\n        if(nbr[n] == '0') {\n          output[po] = fill_val;\n          n++;\n        }\n        else {\n          output[po] = nbr[n];\n          signif = -1;\n          n++;\n          if(float_val == ' ')\n            ;\n          else\n            if((float_val == '$') || (sign_val == '-'))\n              output[po-1] = float_val;\n        }\n      }\n    }\n    else if(ch == '9') {\n      output[po] = nbr[n];\n      if(!signif) {\n        signif = -1;\n        if(float_val == ' ')\n          ;\n        else\n          if((float_val == '$') || (sign_val == '-'))\n            output[po-1] = float_val;\n      }\n      n++;\n    }\n    else {\n      if(signif)\n        output[po] = pattern[po];\n      else\n        output[po] = fill_val;\n    }\n    po++;\n  }\n  while((ch=pattern[po]) != '\\0') {\n    if(sign_val == ' ')\n      output[po++] = fill_val;\n    else\n      output[po++] = pattern[po];\n  }\n  return(0);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EDIT2": {"ttr": 8453, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x02\\x01\\x02\\x11\\x9f\\x01\\x02\\x12?\\x111\\x00\\xda\\x00\\xf2\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-03T11:31:02", "lines": 218, "newlines": 242, "modlines": 0, "user": "BC0THOR"}, "text": "/***********/\n/* edit2.c */\n/********************************/\n/* generic numeric edit program */\n/********************************/\n#include <stdio.lib>\n#include <stdlib.lib>\n\nint edit(char output[], char pattern[], char number[]);\n\nmain() {\n  char ofld[66];\n  char nbrstrg[40];\n  char edptrn[66];\n  int err,i;\n\n  while(1) {\n    for(i=0;i<66;i++)\n      ofld[i] = '\\0';\n    printf(\"\\nEnter edit pattern (RETURN to quit): \");\n    gets(edptrn);\n    if(edptrn[0] == '\\0')\n      exit(0);\n    printf(\"\\nEnter number to be edited (may be -): \");\n    gets(nbrstrg);\n    err = edit(ofld,edptrn,nbrstrg);\n    printf(\"\\nerr=%d, edited value=%s\",err,ofld);\n  }\n}\n/********************************************************************/\n/* The edit function provides numeric report editing, including     */\n/* leading zero suppression, check protection, floating $, leading  */\n/* or trailing minus sign, insertion of commas, decimal points and  */\n/* other non-numeric fields. The first parameter is the address of  */\n/* the edited output, whose size will be the same as the pattern.   */\n/* The second parameter is the editing pattern, which must be a true*/\n/* null-terminated string containing the edit pattern. The third    */\n/* is the number to be edited, a null-terminated string containing  */\n/* only digits 0-9 except the first position, which is a -, if the  */\n/* number is negative. The pattern may be up to 64 characters, and  */\n/* the number to be edited may contain up to 32 characters. The     */\n/* number may not contain more significant digits than there are    */\n/* digit select characters in the pattern. If there are more digits */\n/* selected by the pattern than there are in the number, leading    */\n/* zeros will be assumed. In the pattern, the first character may   */\n/* be:      $ (floating dollar sign)                                */\n/*          * (check protection)                                    */\n/*          - (floating minus sign)                                 */\n/* The body of the edit pattern will be composed of digit select    */\n/* characters (z and 9) and other characters, handled as follows:   */\n/*          z (zero suppression output is a blank in this position  */\n/*             until significance is set by receipt of a significant*/\n/*             digit or a 9 in the pattern. After significance is   */\n/*             set, output is a digit from the number.)             */\n/*          9 (output is a digit from the number and significance   */\n/*             is set, even if the digit is a leading zero.)        */\n/*        other characters in the pattern will be output as-is after*/\n/*             significance is set, but will be output as blanks    */\n/*             before significance is set.                          */\n/* Characters in the pattern following the last digit select will   */\n/* be output as-is if the number is negative, otherwise output will */\n/* be blanks for these pattern positions.                           */\n/*                                                                  */\n/* When * check protection is selected, output will be *, rather    */\n/* than blanks as mentioned above.                                  */\n/*                                                                  */\n/* An integer is returned to indicate success or errors:            */\n/*                 0 = successful edit                              */\n/*                 1 = pattern too long (over 64 characters)        */\n/*                 2 = too many digits selected (over 32)           */\n/*                 3 = no output digits selected in pattern         */\n/*                 4 = number contains non-numeric data             */\n/*                 5 = number has more digits than the pattern      */\n/*                                                                  */\n/* Examples:                            nbr=             outf=      */\n/*    err=edit(outf,\"zz,zz9.99-\",nbr);  0                     0.00  */\n/*                                      123                   1.23  */\n/*                                      562983            5,629.83  */\n/*                                      -4675                46.75- */\n/*    err=edit(outf,\"$,$$$.$$\",nbr);    0                           */\n/*                                      123                  $1.23  */\n/*                                      562983           $5,629.83  */\n/*                                      -4675               $46.75  */\n/*    err=edit(outf,\"***.**\",nbr);      0                           */\n/*                                      123                 **1.23  */\n/*                                      562983   err = 5            */\n/*                                      -4675               *46.75  */\n/*    err=edit(outf,\"--,--9.99\",nbr);   0                     0.00  */\n/*                                      123                   1.23  */\n/*                                      562983            5,629.83  */\n/*                                      -46.75              -46.75  */\n/*                                                                  */\n/* Author R Thornton April 1989                                     */\n/********************************************************************/\nint edit(char output[], char pattern[], char number[]) {\n  char float_val = ' ';\n  char fill_val = ' ';\n  char sign_val = ' ';\n  int signif = 0;\n  int psize = 0;\n  int pdig = 0;\n  int plast = 0;\n  int ndig = 0;\n  char nbr[33];\n  char ch= ' ';\n  int po=0;\n  int n=0;\n\n  /****************************************************************/\n  /* examine pattern: set up float and fill, count size and digits*/\n  /****************************************************************/\n  if(((ch=pattern[0]) == '$') || (ch == '*') || (ch == '-'))\n    float_val = ch;\n  if(ch == '*')\n    fill_val = '*';\n  while((ch=pattern[po]) != '\\0') {\n    if((ch == 'z') || (ch == '9')) {\n      pdig++;\n      plast = po;\n    }\n    psize++;\n    po++;\n  }\n  if(psize > 63)\n    return(1);\n  if(pdig > 32)\n    return(2);\n  if(!pdig)\n    return(3);\n  /****************************************************************/\n  /* examine number: set up sign, count digits, check numeric.    */\n  /* set error if more digits than pattern, move right justified  */\n  /****************************************************************/\n  if(number[0] == '-') {\n    sign_val = '-';\n    n = 1;\n  }\n  while((ch=number[n]) != '\\0') {\n    if((ch < '0') || (ch > '9'))\n      return(4);\n    ndig++;\n    n++;\n  }\n  if(ndig > pdig)\n    return(5);\n  for(po=0;po<(pdig-ndig);po++)\n    nbr[po] = '0';\n  if(sign_val == ' ')\n    n = 0;\n  else\n    n=1;\n  for(;po<pdig;po++,n++)\n    nbr[po] = number[n];\n  /****************************************************************/\n  /* scan across the pattern, setting the corresponding output    */\n  /* byte from pattern, fill, or amt depending on the pattern     */\n  /* character and state of significance.                         */\n  /****************************************************************/\n  if(float_val != ' ') {\n    output[0] = ' ';\n    po = 1;\n  }\n  else\n    po = 0;\n  n = 0;\n  while((po <= plast)) {\n    ch = pattern[po];\n    if(ch == 'z') {\n      if(signif) {\n        output[po] = nbr[n];\n        n++;\n      }\n      else {\n        if(nbr[n] == '0') {\n          output[po] = fill_val;\n          n++;\n        }\n        else {\n          output[po] = nbr[n];\n          signif = -1;\n          n++;\n          if(float_val == ' ')\n            ;\n          else\n            if((float_val == '$') || (sign_val == '-'))\n              output[po-1] = float_val;\n        }\n      }\n    }\n    else\n      if(ch == '9') {\n        output[po] = nbr[n];\n        if(!signif) {\n          signif = -1;\n          if(float_val == ' ')\n            ;\n          else\n            if((float_val == '$') || (sign_val == '-'))\n              output[po-1] = float_val;\n        }\n        n++;\n      }\n      else {\n        if(signif)\n          output[po] = pattern[po];\n        else\n          output[po] = fill_val;\n      }\n    po++;\n  }\n  while((ch=pattern[po]) != '\\0') {\n    if(sign_val == ' ')\n      output[po++] = fill_val;\n    else\n      output[po++] = pattern[po];\n  }\n  return(0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "EMPEROR": {"ttr": 8458, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00X\\x01\\x02\\x11\\x9f\\x01\\x02\\x12?\\x11C\\x02\\x85\\x02\\x80\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-03T11:43:58", "lines": 645, "newlines": 640, "modlines": 0, "user": "BC0THOR"}, "text": "/*************/\n/* emperor.c */\n/********************************************************************/\n/* EMPEROR: adapted from a PL/I game written for the IBM mainframe. */\n/********************************************************************/\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <time.h>\n\n  int people = 0;\n  long grain = 0;\n  long acres = 0;\n\nint  main(void) {\n\n  long gtusnmbr(void);\n     char gtusrply(void);\n     float get_random(int first_time);\n\n  char c;\n  int i;\n  int y_ars = 0;\n  int  immigrants = 0;\n  long rats = 0;\n  long farmland = 0;\n  float yield = 0;\n  float fert_amt = 0;\n  long food = 0;\n  int starved = 0;\n  int plague = 0;\n  char l[80];\n  int x = 0;\n  int first = 1;\n  int fert_sw = 0;\n  int plag_sw = 0;\n  float number = 0.0;\n  long diff = 0;\n  int value = 0;\n  long trade = 0;\n  int serum = 0;\n  char games[10][32] = {\n    \"ping pong for a year\",\n    \"bridge for a year\",\n    \"little sally saucer for a year\",\n    \"monoply for a year\",\n    \"marbles for a year\" ,\n    \"spin the bottle for a year\",\n    \"pinochle for a year\",\n    \"leap frog for a year\",\n    \"strip poker for a year\",\n    \"run-sheep-run for a year\"\n  };\n  long innoculated = 0;\n  long tot_imm = 0;\n  long tot_starved = 0;\n  long tot_plagued = 0;\n  long acres_bot = 0;\n  long acres_sold = 0;\n  long acres_start = 0;\n  long peopl_start = 0;\n  long tot_fert = 0;\n  long planted = 0;\n  long harvestd = 0;\n  long grain_plant = 0;\n  long harvest_lst = 0;\n  long grain_buy = 0;\n  long grain_sold = 0;\n  int grain_start = 0;\n  int last_shot = 0;\n  long totl_shot = 0;\n  int robbed = 0;\n  int this_shot = 0;\n\n  for(i=0;i<25;i++)\n    printf(\"\\n\");\n  printf(\"\\nF I S  Econometric Modeling System\");\n  printf(\"\\n==================================\");\n  printf(\"\\n\");\n  number = get_random(1);     /* initialize random seed */\n  acres = number * 1000;\n  acres_start = acres;\n  number = get_random(0);\n  people = number * 1000;\n  peopl_start = people;\n  number = get_random(0);\n  grain = number * 2000;\n  grain_start = grain;\n  printf(\"\\nDo you need instructions? y or n?: \");\n  c = gtusrply();\n\n  if(c == 'n') goto pop;\n  printf(\"\\nYou are the emperor of Somewhereia!!\");\n  printf(\"\\nYou will reign for a maximum of 25 years,\");\n  printf(\"\\nand will be given people, land, and grain.\");\n  printf(\"\\nYour goal is to increase your empire\");\n  printf(\"\\nby having your people farm your land\");\n  printf(\"\\nto produce grain for your use as food,\");\n  printf(\"\\nseed for planting, and the trade basis\");\n  printf(\"\\nthat may be used to buy more land to\");\n  printf(\"\\nproduce more grain to buy more land, etc.\");\n  printf(\"\\nSimple, right?  Then let's get started....\");\n  printf(\"\\n\");\n  goto pop;\n   status:\n  printf(\"\\n\");\n  if(y_ars > 1) {\n    if(food > (people * 1.3))\n   grain = grain + ((food - (people * 1.3))/2);\n    if(grain<0) printf(\"\\n!!!!!At 01 Grain=%d\",grain);\n    printf(\"\\nState of your empire after %d years\",y_ars);\n  }\n  else\n  printf(\"\\nState of your empire after one year.\");\n  printf(\"\\n-----------------------------------\");\n  if(!immigrants) goto starvout;\n  printf(\"\\nThere were %d immigrants.\",immigrants);\n  tot_imm = tot_imm + immigrants;\n   starvout:\n  if(first)\n    goto died;\n  if(starved >= (immigrants+people))\n    starved = people;\n  if(!starved)\n    goto died;\n     printf(\"\\n%d people starved to death.\",starved);\n     tot_starved = tot_starved + starved;\n   died:\n  if(!plague) goto pop;\n  if(plague >= (people + immigrants - starved)) {\n    printf(\"\\nbut the worst is yet to come. . .\");\n    printf(\"\\nThe plague wiped out your entire population!!\");\n    printf(\"\\nBetter fortune next time!\");\n    tot_plagued = tot_plagued + plague;\n    people = 0;\n    goto finis;\n  }\n     printf(\"\\n%d people were killed by the plague.\",plague);\n     tot_plagued = tot_plagued + plague;\n   pop:\n     people = people - (starved + plague) + immigrants;\n  if(starved | plague) {\n    printf(\"\\nSo, your current population is %d people\",people);\n  }\n  else {\n    printf(\"\\nYour current population is %d people\",people);\n  }\n  printf(\"\\nYou own %ld acres, and control %ld bushels of grain.\",\n    acres,grain);\n  if(first) goto grain_cnt;\n  if(acres > 1000000) goto mill_yun_air;\n  if(grain > 4000000) goto mill_yun_air;\n  if(!acres & !grain) {\n    printf(\"\\nYour situation is hopeless. The sounds you hear are\");\n    printf(\"\\nshouted curses as people leave your stinkin' empire\");\n    goto finis;\n  }\n   graincount:\n  if(y_ars > 24)\n    goto over_age;\n  printf(\"\\nDo you want to continue? y or n?: \");\n  c = gtusrply();\n  if(c == 'n') {\n    printf(\"\\nSo long, successful. . . . .\");\n    goto finis;\n  }\n   grain_cnt:\n     y_ars = y_ars + 1;\n     printf(\"\\nYou have %ld bushels of grain in storage.\",grain);\n   landtrade:\n  if(first)\n    goto eat;\n  number = get_random(0);\n  value =(86*number)+1;\n   retry:\n     printf(\"\\nLand is trading for %d bushels of grain per acre.\",\n            value);\n  if(value > grain) {\n    printf(\"\\nUnfortunately, you are in no position to buy!\");\n    goto sell;\n  }\n   buy:\n     trade = grain/value;\n     printf(\"\\nThe maximum you may buy is %ld acres.\",trade);\n     printf(\"\\nHow many acres would you like to buy?\");\n  trade = gtusnmbr();\n  if(!trade)\n    goto sell;\n  if((trade * value) > grain) {\n    printf(\"\\nYou don't have enough grain to buy that much land.\");\n    printf(\"\\nNice try there, Emperor baby.\");\n    goto retry;\n  }\n  acres_bot = acres_bot + trade;\n  grain = grain - (trade * value);\n  if(grain<0) printf(\"\\n!!!!!At 02 Grain=%d\",grain);\n  grain_buy = grain_buy + (trade * value);\n  acres = acres + trade;\n  if(acres<0) printf(\"\\n!!!!!At 12 Acres=%d\",acres);\n  printf(\"\\nYour land trading leaves %ld bushels of grain.\",grain);\n  goto eat_em;\n   sell:\n  if(!acres) {\n    printf(\"\\nYou have no land to sell!\");\n    goto eat;\n  }\n  printf(\"\\nYou have %ld acres of land.\",acres);\n  trade = acres * value;\n  printf(\"\\nAll your land would bring %ld bushels of grain.\",trade);\n   retryagain:\n     printf(\"\\nHow many acres would you like to sell?\");\n  trade = gtusnmbr();\n  if(!trade)\n    goto eat;\n  if(trade > acres) {\n    printf(\"\\nSorry, I don't buy on margin.\");\n       printf(\"\\nI will buy as much as you own,\");\n       printf(\"\\nbut no more than that!!\");\n    goto retryagain;\n  }\n  grain = grain + (trade * value);\n  if(grain<0) printf(\"\\n!!!!!At 03 Grain=%d\",grain);\n  acres_sold = acres_sold + trade;\n  grain_sold = grain_sold + (trade*value);\n  acres = acres - trade;\n  if(acres<0) printf(\"\\n!!!!!At 13 Acres=%d\",acres);\n   eat:\n  if(first)\n   goto pass;\n  printf(\"\\nYou have %ld bushels of grain.\",grain);\n   eat_em:\n     printf(\"\\nand %d people to feed.\",people);\n   pass:\n  if(!grain) {\n    printf(\"\\nThat sound you hear is the growling \");\n    printf(\"\\nof %d hungry stomachs!\",people);\n    printf(\"\\nYou have no grain to set aside for food!!\");\n    goto farm;\n  }\n  printf(\"\\nHow many bushels of grain should be set aside for food?:\");\n  food = gtusnmbr();\n  if(food > grain) {\n    printf(\"\\nYou can't set aside more grain than you have, Dummy!\");\n    printf(\"\\nI mean your Emporership (he mumbled humbly)\");\n    goto eat;\n  }\n  if(!food) {\n    printf(\"\\nThat's genocide, you swine!\");\n    printf(\"\\nBeware of the four horsemen of the apocalypse...\");\n  }\n  grain = grain - food;\n  if(grain<0) printf(\"\\n!!!!!At 04 Grain=%d\",grain);\n  printf(\"\\nThat leaves %ld in storage.\",grain);\n farm:\n  if(!acres) {\n    printf(\"\\nYou have no farmland! sorry about that!\");\n    farmland = 0;\n    goto doit;\n  }\n  printf(\"\\nYou have %ld acres of land, and %d people as farmers.\",\n   acres,people);\n  if(!grain) {\n    printf(\"\\nbut have no seed to plant!\");\n    farmland = 0;\n    goto doit;\n  }\n   retry1:\n  printf(\"\\nHow many acres do you want to farm?: \");\n  farmland = gtusnmbr();\n  if(farmland > acres) {\n    printf(\"\\nI don't think you quite understand, Emperor, sir...\");\n    printf(\"\\nYou cannot farm more land than you own!\");\n    goto retry1;\n  }\n  if((farmland * 1.8) > people) {\n    printf(\"\\nYou don't have enough people to farm that much land.\");\n    goto retry1;\n  }\n  if((farmland * .78) > grain) {\n    printf(\"\\nYou don't have enough seed to farm that much land.\");\n    goto retry1;\n  }\n  if(!farmland)\n    goto doit;\n  if(!grain)\n    goto doit;\n  grain = grain - (farmland * .78);\n  printf(\"\\n%.0f bushels were used for seed.\",(farmland * .78));\n  if(grain<0) printf(\"\\n!!!!!At 05 Grain=%d\",grain);\n  planted = planted + farmland;\n  grain_plant = grain_plant + (farmland * .78);\n  number = get_random(0);\n  if(number > .698765) {\n    fert_sw = 0;\n    goto doit;\n  }\n  number = get_random(0);\n  fert_amt = (10 * number) + 0.5;\n  printf(\"\\nFertilizer is selling for %3.1f bushels/acre.\",fert_amt);\n  printf(\"\\nDo you wish to enhance your crop yield? y or n?: \");\n  c = gtusrply();\n  if(c == 'y') {\n    fert_sw = 0;\n    goto doit;\n  }\n  fert_sw = 1;\n  value = farmland * fert_amt;\n  if(value > grain) {\n    printf(\"\\nNice try emp, but I don't sell the manure\");\n    printf(\"\\non credit!\");\n    fert_sw = 0;\n    goto doit;\n  }\n  grain = grain - value;\n  if(grain<0) printf(\"\\n!!!!!At 06 Grain=%d\",grain);\n  tot_fert = tot_fert + value;\n   doit:\n  if(grain > 22222) {\n    number = get_random(0);\n    if(number > .920000) {\n   printf(\"\\nA very rare grain rot attacks your grain in storage!\");\n   harvest_lst = harvest_lst + (grain/1.91);\n   grain = grain / 1.91;\n   if(grain<0) printf(\"\\n!!!!!At 07 Grain=%d\",grain);\n   printf(\"\\n Only %ld bushels could be saved.\",grain);\n    }\n  }\n  if(plag_sw) {\n    if(last_shot >= people) {\n   printf(\"\\nPlague innoculations are unnecessary this year,\");\n   printf(\"\\nall your empire is still immunized!\");\n   innoculated = last_shot / 2;\n   goto no_shots;\n    }\n    number = get_random(0);\n    serum=(13 * number) + 1;\n    if(grain > 2000000)\n   serum = serum + 128;\n    else\n   if(grain > 1500000)\n     serum = serum + 64;\n   else\n     if(grain > 1000000)\n    serum = serum + 32;\n     else\n    if(grain > 500000)\n      serum = serum + 16;\n    else\n      if(grain > 100000)\n     serum = serum + 8;\n      else\n     if(grain > 50000)\n       serum = serum + 4;\n     else\n       if(grain > 25000)\n      serum = serum + 2;\n    printf(\"\\nU.N. World Health is distributing black death\");\n    printf(\"\\ninnoculations for\");\n    printf(\"\\n@ %d bushels of grain per person\",serum);\n    if(serum > grain) {\n   printf(\"\\nUnfortunately, you can't afford it....tsk....tsk\");\n   innoculated = 0;\n   goto noshots;\n    }\n   peopleshots:\n     innoculated = grain/serum;\n  if(innoculated >= people)\n    innoculated = people;\n  printf(\"\\nYou can afford to innoculate %d people\",innoculated);\n  if(innoculated <= (people-last_shot))\n    goto shots;\n  if(!last_shot)\n    goto shots;\n  innoculated = people - last_shot;\n  printf(\"\\nHowever, %d of your people are still immunized,\",\n          last_shot);\n  printf(\"\\nand you need only %d more shots.\",innoculated);\n   shots:\n     printf(\"\\nHow many get the shot?\");\n  innoculated = gtusnmbr();\n  this_shot = innoculated;\n  if(innoculated > (grain/serum)) {\n    printf(\"\\nW h a a t ?\");\n    goto peopleshots;\n  }\n  if(!innoculated) {\n    printf(\"\\nIts easy to gamble with someone else's life,\");\n    printf(\"\\nisn't it?\");\n    goto noshots;\n  }\n  grain = grain - (innoculated * serum);\n  if(grain<0) printf(\"\\n!!!!!At 08 Grain=%d\",grain);\n  printf(\"\\nThat leaves %ld bushels stored.\",grain);\n   }\n   noshots:\n     totl_shot = totl_shot + innoculated;\n   no_shots:\n     first = 0;\n  if(!farmland) {\n    number = get_random(0);\n    x = number * 10;\n    printf(\"\\nWith no land being farmed, the people played %s\",\n             games[x]);\n    number = get_random(0);\n    rats = grain * number;\n       printf(\"\\nWhile the rats overran your graineries,\");\n       grain = grain - rats;\n    if(grain<0) printf(\"\\n!!!!!At 08 Grain=%d\",grain);\n    if(!grain)\n   printf(\"\\nand with nothing left to eat, the rats ate the cats.\");\n    else\n   printf(\"\\nleaving only %ld bushels of grain stored.\",grain);\n    goto passrats;\n  }\n  printf(\"\\nThe people are working under your prescribed conditions.\");\n  number = get_random(0);\n  if(number < .001111) {\n    printf(\"\\nA revolt of the peasantry has overthrown your reign!\");\n    printf(\"\\nreign. You were lucky to escape with your life...\");\n    goto revolt;\n  }\n  printf(\"\\nHere are the fruits of their labor. . . .\");\n  rats = 0;\n  number = get_random(0);\n  if(number < .002222) {\n    if(!fert_sw)\n   goto not_fert_ed;\n    printf(\"\\nYour over-fertilized land causes a crop burn-out!\");\n    printf(\"\\nYou were unable to save any of your crop.\");\n    goto passrats;\n  }\n   not_fert_ed:\n  if(!farmland)\n    yield = 0.0f;\n  else {\n    number = get_random(0);\n    yield = (17.0f * number) + 0.1f;\n  }\n  if(fert_sw) {\n    number = get_random(0);\n    yield = yield + (float)(fert_amt * (number + 1.0) + fert_amt);\n  }\n  if(farmland)\n    yield = yield + 0.8f;\n  printf(\"\\nYour yield per acre was %.2f bushels.\",yield);\n  diff = (long)(yield * (float)farmland);\n  if(!diff)\n    goto passrats;\n  diff = diff + 1;\n  harvestd = harvestd + diff;\n  printf(\"\\nFor a total harvest of %ld bushels.\",diff);\n  number = get_random(0);\n  if(number < .760000) {\n    grain = grain + diff;\n    if(grain<0) printf(\"\\n!!!!!At 09 Grain=%d\",grain);\n    goto passrats;\n  }\n  else\n    if(number > .960000)\n   rats = diff;\n    else\n   rats = (((number * number) * number) * diff) + 1;\n  if(!diff)\n    goto passrats;\n  if(rats >= diff) {\n    if(number > .860000)\n   printf(\"\\nA swarm of locusts devastated your harvest!\");\n    else\n         printf(\"\\nbut the rats ate it all. (those pigs)!\");\n  }\n  else {\n    if(fert_sw)\n   rats = rats / 2;\n    printf(\"\\nBut the rats ate %ld bushels.\",rats);\n    grain =(grain+diff)-rats;\n    if(grain<0) printf(\"\\n!!!!!At 10 Grain=%d\",grain);\n  }\n   passrats:\n     harvest_lst = harvest_lst + rats + robbed;\n     robbed = 0;\n  if(food > (people * 1.3))\n    starved = 0;\n  else\n    starved = people - (food / 1.3);\n  if(starved) {\n    printf(\"\\nYour underfed peasants are pilfering your graineries\");\n    if((starved * 1.11) >= grain) {\n   robbed = grain;\n   grain = 0;\n    }\n    else {\n   robbed = (starved * 1.11);\n   grain = grain - robbed;\n   if(grain<0) printf(\"\\n!!!!!At 11 Grain=%d\",grain);\n    }\n    if(!robbed)\n   printf(\"\\nWith no food available, the people ate their shoes.\");\n    else\n   printf(\"\\nThey stole %d bushels from you!\",robbed);\n  }\n  number = get_random(0);\n  immigrants = number * 100;\n  plague = 0;\n  number = get_random(0);\n  if(number > .499999) {\n    plag_sw = 1;\n    number = get_random(0);\n    plague = ((people-last_shot) / 2) - (number * 99);\n    if(plague < 0)\n   plague = plague * (-1);\n    if((innoculated + last_shot) >= plague)\n   plague =0;\n    else\n   plague=plague -(innoculated + last_shot);\n    last_shot = (this_shot/2);\n  }\n  else\n    last_shot = last_shot + (this_shot *0.7);\n  goto status;\n   mill_yun_air:\n     printf(\"\\nSince you now have more than 1,000,000 acres of land,\");\n     printf(\"\\nand more than 4,000,000 bushels of grain...\");\n     printf(\"\\nYou far surpassed all royal expectations!\");\n     printf(\"\\nAnd your immense empire is becoming too tyrannical.\");\n    goto happi_ness;\n     over_age:\n       printf(\"\\nAfter 25 years, you have exceeded your royal\");\n       printf(\"\\nusefulness\");\n     happi_ness:\n       printf(\"\\nIn an effort to maintain a happy population. . .\");\n     revolt:\n       printf(\"\\n you decide to abdicate in favor of the prime\");\n       printf(\"\\nminister. The king is dead! long live the king!\");\n     finis:\n       printf(\"\\n \");\n    printf(\"\\nYou began with %d people,\",peopl_start);\n       printf(\"\\nthere were %d immigrants,\",tot_imm);\n    printf(\"\\nbut %d starved to death,\",tot_starved);\n    printf(\"\\nand %d died of the \\\"crud\\\" even tho'\",tot_plagued);\n       printf(\"\\n%d had shots,\",totl_shot);\n    printf(\"\\nleaving %d alive at the end.\",people);\n       printf(\"\\nAs a result of your land trading enterprises....\");\n       printf(\"\\nYou started with %ld acres of land, and with\",\n                 acres_start);\n    printf(\"\\n%ld bushels of grain,\",grain_start);\n       printf(\"\\nYou bought %ld acres, paying %ld bushels\",\n         acres_bot,grain_buy);\n    printf(\"\\nand you sold %ld acres, receiving %ld bushels,\",\n    acres_sold,grain_sold);\n       printf(\"\\nending  up  with %ld acres, and with %ld\",\n                acres,grain);\n       printf(\"\\n bushels in storage.\");\n    printf(\"\\nOver the seasons of your imperial reign, of %d\",\n                 y_ars);\n       printf(\"\\nyears you planted %ld acres, with %ld bushels\",\n                 planted,grain_plant);\n       printf(\"\\n of seed,\");\n       printf(\"\\nyielding %ld bushels, with %ld bushels as fertilizer\",\n                 harvestd,tot_fert);\n       printf(\"\\nbut you lost %ld bushels to the rats, ET.AL.\",\n                 harvest_lst);\n    printf(\"\\n\");\n}\n/********************************************************************/\n/* gtusnmbr returns an integer value entered by the user            */\n/********************************************************************/\nlong  gtusnmbr(void) {\n  char s[256];\n  int numeric;\n  int nbr_digits;\n  int i;\n  long number;\n\n  numeric = 0;\n  do {\n  gets(s);\n  if(s[0] == '?') {\n    printf(\"\\nYour current population is %d people,\",people);\n    printf(\"\\nfarming %ld acres, and storing %ld bushels.\",\n    acres,grain);\n    continue;\n  }\n  nbr_digits = strlen(s);\n  if((nbr_digits > 0) && (nbr_digits < 11));\n  else {\n    printf(\"\\nPlease enter a number between 0 and 2147483647: \");\n    continue;\n  }\n  for(i = 0;i < nbr_digits; i++) {\n    if((s[i] < '0') || (s[i] > '9')) {\n   printf(\"\\nPlease enter ONLY digits 0-9 in your number: \");\n   continue;\n    }\n  }\n  number = atol(s);\n  if((number < 0) || (number > 2147483647))\n    printf(\"Please enter a number between 0 and 2147483647: \");\n  else\n    numeric = -1;\n  } while(!numeric);\n  return number;\n}\n/********************************************************************/\n/* gtusrply returns a 'y' or 'n' entered by the user                */\n/********************************************************************/\nchar  gtusrply(void) {\n     char c;\n  int bad_reply = 1;\n\n     do {\n    c = getchar();\n    while((getchar()) != '\\n');\n    if(c == '?') {\n   printf(\"\\nYour current population is %d people,\",people);\n   printf(\"\\nfarming %ld acres, and storing %ld bushels.\",\n     acres,grain);\n   printf(\"\\nPlease enter y (for yes) or n (for no): \");\n     continue;\n       }\n    if((c == 'y') || (c == 'n'))\n   bad_reply = 0;\n    else {\n   printf(\"\\nPlease enter either a y (for yes) or an n (for no): \");\n    }\n  } while(bad_reply);\n  return c;\n}\n/********************************************************************/\n/* get_random returns a random number between 0 and 1. When the     */\n/* first time switch is true, a new seed is obtained.               */\n/********************************************************************/\nfloat get_random(int first_time) {\n      int rand_nbr;\n      unsigned seed;\n      time_t tnow;\n\n      if(first_time) {\n  time(&tnow);\n  seed = (int) tnow;\n  srand(seed);\n      }\n      rand_nbr = (int)rand();\n      return ((float)rand_nbr / (float) 32767.0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "ENDCKDUP": {"ttr": 8714, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x003\\x01\\x004/\\x01\\x02\\x12o\\x07\\x04\\x00\\x8b\\x01D\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2000-12-07T00:00:00", "modifydate": "2002-05-06T07:04:33", "lines": 139, "newlines": 324, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* endckdup.c */\n/*********************************************************************/\n/* Purpose: Identify all duplicate element names for COBOL and ASSEM */\n/*          element types in Endevor.                                */\n/* Reads the element records file created by assembler program       */\n/* ENDVDATA after sorting the files for BCBS01, PRODSUP, HCS, and    */\n/* ITS together on element name and environment name.                */\n/* Author R Thornton Dec 2000                                        */\n/*********************************************************************/\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n/*********************************************************************/\n/* Function Prototypes                                               */\n/*********************************************************************/\nint main(void);                /* Executive control routine */\nvoid Initialization(void);     /* Initialization routine */\nvoid Process(void);            /* Process control routine */\nint  ReadElement(void);        /* Routine to read the ELEMENT file */\nvoid WriteDup(void);           /* Routine to write the DUPS file */\nvoid Terminate(void);          /* Termination routine */\n/*********************************************************************/\n/* Global data areas and file descriptions                           */\n/*********************************************************************/\nFILE *Element;               /* define the input file ptr */\nFILE *Dups;                  /* define the output file ptr */\n\nstruct ElementRecord {       /* ELEMENT data record */\n  char Element[8];           /* Element name */\n  char Filler1;\n  char Lang[11];             /* Language descriptor */\n  char Filler2;\n  char Environment[8];       /* Environment name */\n  char Filler3;\n  char System[8];            /* System name */\n  char Filler4;\n  char SSname[8];            /* SubSystem name */\n  char Filler5;\n  char Type[5];              /* Endevor type name */\n  char Filler6;\n  char PrcGrpName[8];        /* Endevor processor group name */\n  char Filler7;\n  char PrcName[8];           /* Endevor Processor name */\n  char Filler8[9];\n} LastRecord, CurrentRecord;\n\nint ElementLeng = 80;          /* LRECL for ELEMENT file */\n\n/*********************************************************************/\n/* main(): this is the executive control routine                     */\n/*********************************************************************/\nint main(void) {               /* Executive control routine */\n  Initialization();              /* initialize for processing */\n  while(ElementLeng) {\n    Process();                   /* process until end of file */\n  }\n  Terminate();                   /* terminate processing */\n  exit(0);                       /* relinquish control */\n}\n/*********************************************************************/\n/*                                                                   */\n/*********************************************************************/\nvoid Initialization(void) {    /* Initialization routine */\n\n  Dups =(fopen(\"dd:DUPS\",\"wb,type=record,recfm=FB,lrecl=80\"));\n  if(Dups == NULL) {\n    printf(\"Unable to open the DUPS file\\n\");\n    exit(8);\n  }\n  if(ferror(Dups)) {\n    perror(\"Error trying to open the DUPS file\");\n    exit(8);\n  }\n  Element =(fopen(\"dd:ELEMENT\",\"rb,type=record,recfm=FB,lrecl=80\"));\n  if(Element == NULL) {\n    printf(\"Unable to open the ELEMENT file\\n\");\n    exit(8);\n  }\n  if(ferror(Element)) {\n    perror(\"Unable trying to open the ELEMENT file\");\n    exit(8);\n  }\n  ReadElement();              /* Read first ELEMENT record */\n  memcpy(&LastRecord, &CurrentRecord, sizeof(LastRecord));\n}\n/*********************************************************************/\n/* Process: read the element file and write out all records which    */\n/* have duplicate element names.                                     */\n/*********************************************************************/\nvoid Process(void) {           /* Process control routine */\n  ReadElement();                 /* read ELEMENT record */\n  if(ElementLeng != 0) {         /* if more elements */\n    if(memcmp(LastRecord.Element, CurrentRecord.Element, 8) == 0) {\n      if(LastRecord.Lang[0] != '\\xFF')  /* dup, last rec written? */\n        WriteDup();              /* no, go write last record */\n      memcpy(&LastRecord, &CurrentRecord, sizeof(LastRecord));\n      WriteDup();                /* write current record\n      LastRecord.Lang[0] = '\\xFF'; /* show last written */\n    }\n    else\n      memcpy(&LastRecord, &CurrentRecord, sizeof(LastRecord));\n  }\n}\n/*********************************************************************/\n/* Read next record from the ELEMENT file                            */\n/*********************************************************************/\nint  ReadElement(void) {       /* Routine to read the ELEMENT file */\n  int rc;\n  rc = fread(&CurrentRecord, 1, 80, Element); /* Read */\n  if(ferror(Element)) {\n    perror(\"Error reading ELEMENT file\");\n    exit(8);\n  }\n  if(feof(Element)) {             /* test for end of file */\n    rc = 0;\n  }\n  ElementLeng = rc;                /* set EOF status indicator */\n  return(rc);\n}\n/*********************************************************************/\n/* Write last record to the DUPS file.                               */\n/*********************************************************************/\nvoid WriteDup(void) {          /* Routine to write the ELEMENT file */\n  fwrite(&LastRecord, 1, ElementLeng, Dups); /* Write element */\n  if(ferror(Dups)) {\n    perror(\"Error writing to the DUPS file\");\n    exit(8);\n  }\n  return;\n}\n/*********************************************************************/\n/* Termination routine: close files and prepare to relinquish control*/\n/*********************************************************************/\nvoid Terminate(void) {         /* Termination routine */\n  fclose(Dups);                 /* Close DUPS file */\n  fclose(Element);              /* Close ELEMENT file */\n  return;\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "ENDVELMT": {"ttr": 8963, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00V\\x01\\x006\\x1f\\x01\\x02\\x12o\\x072\\x01d\\x01a\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2000-12-26T00:00:00", "modifydate": "2002-05-06T07:32:56", "lines": 356, "newlines": 353, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* endvelmt.c */\n/*****************************************************************/\n/* This is the first of a series of programs intended to match   */\n/* Endevor elements with load library members. Here, the primary */\n/* input files are the element file created by the ENDVDATA      */\n/* program (asm), and the EDGE product machine friendly file     */\n/* after it is stripped and reformatted by EDGESTRP and then     */\n/* sorted in member name order. This file contains records for   */\n/* in-house written programs from all production libraries.      */\n/*                                                               */\n/* The element file contains elements from all Endevor environ-  */\n/* ments. it is sorted in element name order.                    */\n/*                                                               */\n/* Processing:                                                   */\n/* 1. Input files are matched on member name, csect name, element*/\n/*    name and compiler. When all these match, a MATCH record is */\n/*    written, but no record is written to the REMELMTS file nor */\n/*    to the REMLDMDS file.                                      */\n/* 2. Records from the Endevor elements input file that do not   */\n/*    match Load Module records are reformatted and written to   */\n/*    the REMELMTS file.                                         */\n/* 3. Records from the LDMODS file that are unmatched are written*/\n/*    to the REMLDMDS file.                                      */\n/*                                                               */\n/* Author R Thornton Dec 2000                                    */\n/*****************************************************************/\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n/*****************************************************************/\n/* Global Data Areas                                             */\n/*****************************************************************/\n\nstruct LmodRecd {             /* Load Module Record description      */\nchar Member[8];               /* member name                         */\nchar filler1;\nchar Csect[8];                /* csect name                          */\nchar filler2;\nchar LoadLib[4];              /* load library abbreviation           */\nchar filler4;\nchar CompType[2];             /* Compiler type                       */\nchar filler[55];              /*                                     */\n};\n\nstruct ElmtRecd {             /* element record description          */\nchar Element[8];              /* element name                        */\nchar fill1;                   /*                                     */\nchar Compiler[11];            /* compiler name                       */\nchar fill2;                   /*                                     */\nchar Envirnmt[8];             /* Endevor environment name            */\nchar fill3;                   /*                                     */\nchar System[8];               /* Endevor system name                 */\nchar fill4;                   /*                                     */\nchar SubSys[8];               /* Endevor sub-system name             */\nchar fill5;                   /*                                     */\nchar Type[5];                 /* Endevor type name                   */\nchar fill6;                   /*                                     */\nchar ProcGrp[8];              /* Endevor Processor group name        */\nchar fill7;                   /*                                     */\nchar Processr[8];             /* Endevor Processor name              */\nchar fill8[9];                /*                                     */\n};\n\nstruct {                      /* matching element/load module record */\nchar Element[8];              /* Endevor element name                */\nchar Envirnmt[8];             /* Endevor environment name            */\nchar System[8];               /* Endevor system name                 */\nchar SubSys[8];               /* Endevor subsystem name              */\nchar Type[5];                 /* Endevor type name                   */\nchar ProcGrp[8];              /* Endevor Processor group name        */\nchar Processr[8];             /* Endevor Processor name              */\nchar Compiler[11];            /* compiler name                       */\nchar Member[8];               /* Matching member name                */\nchar Csect[8];                /* Matching Csect name                 */\nchar CompType[2];             /* Matching compiler type              */\nchar LoadLib[4];              /* load library designator             */\n} mtch;                       /* instance of matching output record  */\n\nstruct LmodRecd inlm;         /* input load module record            */\nstruct ElmtRecd inel;         /* input Endevor element record        */\n\nint MoreLmod = -1;            /* 0 = eof load module file            */\nint MoreElem = -1;            /* 0 = eof endevor element file        */\nFILE *lmods,*elements,*matched,*remelmts,*remldmds; /* FILE pointers */\nint ElmtRead = 0;             /* total element records read          */\nint LmodRead = 0;             /* total Load module records read      */\nint MatchOut = 0;             /* total match records written         */\nint RemLMOut = 0;             /* total remaining load module records */\nint RemElOut = 0;             /* total remaining element records     */\nint DuplElmt = 0;             /* nbr duplicate element records       */\nint DuplLmod = 0;             /* nbr duplicate load module records   */\nchar ElCompTy[3] = \"??\";      /* Element record compiler type        */\nchar LmCompTy[3] = \"? \";      /* Load Module record compiler type    */\n/*****************************************************************/\n/* function prototypes                                           */\n/*****************************************************************/\nint main(void);                   /* executive control routine */\nvoid Initial(void);               /* initialization routine */\nvoid Process(void);               /* Processing routine */\nvoid ReadLM(void);                /* reads the LMODS file */\nvoid ReadEl(void);                /* reads the ELEMENTS file */\nvoid WrtMatch(void);              /* write matching output record */\nvoid WrtElRem(void);              /* write unmatched element record */\nvoid WrtLMRem(void);              /* write unmatched load mod record */\nvoid Terminat(void);              /* termination routine */\n/*****************************************************************/\n/* main() function: executive control                            */\n/*****************************************************************/\nint main(void) {\n  Initial();                         /* initialize for Processing */\n  while(MoreLmod || MoreElem) /*until exhausted, */\n    Process();                       /*    Process records. */\n  Terminat();                        /* Terminate Processing */\n  return(0);\n}\n/*****************************************************************/\n/* Initial(): initialization routine. opens files.               */\n/*****************************************************************/\nvoid Initial(void) {\n  lmods=fopen(\"dd:LMODS\",\"rb,type=record,recfm=fb,lrecl=80\");\n  if(lmods == NULL) {\n    perror(\"\\ncan't open the LMODS file\");\n    exit(8);\n  }\n  elements=fopen(\"dd:ELEMENTS\",\"rb,type=record,recfm=fb,lrecl=80\");\n  if(elements == NULL) {\n    perror(\"\\ncan't open the ELEMENTS file\");\n    exit(8);\n  }\n  remelmts=fopen(\"dd:REMELMTS\",\"wb,type=record,recfm=fb,lrecl=80\");\n  if(remelmts == NULL) {\n    perror(\"\\ncan't open the REMELMTS file\");\n    exit(8);\n  }\n  remldmds=fopen(\"dd:REMLDMDS\",\"wb,type=record,recfm=fb,lrecl=80\");\n  if(remldmds == NULL) {\n    perror(\"\\ncan't open the REMLDMDS file\");\n    exit(8);\n  }\n  matched=fopen(\"dd:MATCHED\",\"wb,type=record,recfm=fb,lrecl=86\");\n  if(matched == NULL) {\n    perror(\"\\ncan't open the MATCHED file\");\n    exit(8);\n  }\n  ReadLM();                      /* Read first LMODS record */\n  ReadEl();                      /* Read first ELEMENT record */\n}\n/*****************************************************************/\n/* Process: for each record in the ELEMENTS file, compare the    */\n/* endevor element name to the load module member name and csect */\n/* name. if these are identical, and the compiler used is the    */\n/* same for both files, a match record is written. All unmatched */\n/* records are written to the unmatched output files. It is      */\n/* possible that multiple load module records may be present for */\n/* a single element record, however element names should be      */\n/* unique.                                                       */\n/*****************************************************************/\nvoid Process(void) {\n  int cpr;                       /* compare result */\n\n  cpr = memcmp(inel.Element, inlm.Member, 8); /* member : element */\n  if(cpr < 0) {                  /* if element low... */\n    WrtElRem();                  /* write unmatched element record */\n    ReadEl();                    /* Read next ELEMENT record */\n    return;\n  }\n  else\n    if(cpr > 0) {                /* if element is high... */\n      WrtLMRem();                /* write unmatched load mod record */\n      ReadLM();                  /* Read next LMODS record */\n      return;\n    }\n  if(memcmp(ElCompTy, LmCompTy, 2) == 0)\n    WrtMatch();                   /* write matching output record */\n  else {\n    WrtElRem();                   /* write unmatched element record */\n    WrtLMRem();                   /* write unmatched load mod record */\n  }\n  ReadLM();                       /* Read next LMODS record */\n  ReadEl();                       /* Read next ELEMENT record */\n  return;\n}\n/*****************************************************************/\n/* ReadLM() reads the next record from the LMODS file into       */\n/* the inlm area. At end of file, the MoreLmod field is set */\n/* to zero (false).                                              */\n/*****************************************************************/\nvoid ReadLM(void) {\n  char HoldMem[9] = \"        \", HoldCsect[9] = \"        \";\n  char HoldCTyp[3] = \"   \";\n  memcpy(HoldMem, inlm.Member, 8);  /* save member name */\n  memcpy(HoldCsect, inlm.Csect, 8); /* save member name */\n  while(-1) {\n    if(MoreLmod) {\n      if(!fread(&inlm, 1,  80, lmods)) {\n        if(feof(lmods)) {\n          MoreLmod = 0;\n          inlm.Member[0] = '\\xFF';\n          return;\n        }\n        else\n          perror(\"\\nError (0 read) reading LMODS file\");\n          exit(8);\n      }\n      if(ferror(lmods)) {\n        perror(\"\\nError (ferror) reading LMODS file\");\n        exit(8);\n      }\n      LmodRead++;\n    }\n    else\n      return;\n    memcpy(LmCompTy, inlm.CompType, 2);\n    if((memcmp(LmCompTy, \"VO\", 2) == 0) ||\n       (memcmp(LmCompTy, \"V4\", 2) == 0))\n         memcpy(LmCompTy, \"VS\", 2);\n    if((memcmp(HoldMem, inlm.Member, 8) == 0) &&\n       (memcmp(HoldCsect, inlm.Csect, 8) == 0) &&\n       (memcmp(LmCompTy, HoldCTyp, 2))) {\n         printf(\"Multiple LMODS records for Member %s, Csect %s, \"\n            \"CompType %s\\n\",HoldMem, HoldCsect, LmCompTy);\n         WrtLMRem();\n         DuplLmod++;\n         continue;\n    }\n    else\n      break;\n  }\n}\n/*****************************************************************/\n/* ReadEl() reads the next record from the ELEMENTS file into    */\n/* the el area. At end of file, the MoreElem field is set to     */\n/* zero (false).                                                 */\n/*****************************************************************/\nvoid ReadEl(void) {\n  char HoldElem[9] = \"        \";\n  char HoldCTyp[3] = \"   \";\n\n  memcpy(HoldElem, inel.Element, 8); /* save the current element */\n  memcpy(HoldCTyp, ElCompTy, 2); /* save the current Compile type */\n  while(-1) {\n    if(MoreElem) {\n      if(!fread(&inel, 1,  80, elements)) {\n        if(feof(elements)) {\n          MoreElem = 0;\n          inel.Element[0] = '\\xFF';\n          return;\n        }\n        else\n          perror(\"\\nError (0 read) reading ELEMENTS file\");\n          exit(8);\n      }\n      if(ferror(elements)) {\n        perror(\"\\nError (ferror) reading ELEMENTS file\");\n        exit(8);\n      }\n      ElmtRead++;\n    }\n    else\n      return;\n    if(memcmp(inel.Compiler, \"390COB\", 6) == 0) /* COBOL390 element? */\n      memcpy(ElCompTy, \"C3\", 2);\n    else\n      if(memcmp(inel.Compiler, \"COBII\", 5) == 0) /* COBOL II Elemnt? */\n        memcpy(ElCompTy, \"C2\", 2);\n      else\n        if(memcmp(inel.Compiler, \"VSCOB\", 5) == 0) /* VS COBOL Elem? */\n          memcpy(ElCompTy, \"VS\", 2);\n        else\n          if(memcmp(inel.Compiler, \"ASM\", 3) == 0) /* Assem Elemnt? */\n            memcpy(ElCompTy, \"AR\", 2);\n          else\n            memcpy(ElCompTy, \"??\", 2);\n    if((memcmp(HoldElem, inel.Element, 8) == 0) &&\n       (memcmp(HoldCTyp, ElCompTy, 2) == 0)) {\n      printf(\"Multiple element records for element %s, CompType %s\\n\",\n              HoldElem, ElCompTy);\n      WrtElRem();\n      DuplElmt++;\n      continue;\n    }\n    else\n      break;\n  }\n}\n/*****************************************************************/\n/* WrtMatch() writes a record to the matched output file.        */\n/*****************************************************************/\nvoid WrtMatch(void) {         /* write matching output record */\n  if(inel.Element[0] == '\\xFF') return;\n  memcpy(mtch.Element, inel.Element, 8);\n  memcpy(mtch.Envirnmt, inel.Envirnmt, 8);\n  memcpy(mtch.System, inel.System, 8);\n  memcpy(mtch.SubSys, inel.SubSys, 8);\n  memcpy(mtch.Type, inel.Type, 5);\n  memcpy(mtch.ProcGrp, inel.ProcGrp, 8);\n  memcpy(mtch.Processr, inel.Processr, 8);\n  memcpy(mtch.Compiler, inel.Compiler, 11);\n  memcpy(mtch.Member, inlm.Member, 8);\n  memcpy(mtch.Csect, inlm.Csect, 8);\n  memcpy(mtch.CompType, inlm.CompType, 2);\n  memcpy(mtch.LoadLib, inlm.LoadLib, 4);\n  fwrite(&mtch, 1,  sizeof(mtch), matched);\n  if(ferror(matched)) {\n    perror(\"\\nError (ferror) writing MATCHED file\");\n    printf(\"\\nmatch file record length is %d\",sizeof(mtch));\n    exit(8);\n  }\n  MatchOut++;\n  memset(&mtch, ' ', sizeof(mtch));\n}\n/*****************************************************************/\n/* WrtElRem() writes a record to the REMELMTS file.              */\n/*****************************************************************/\nvoid WrtElRem(void) {         /* write unmatched element record */\n  if(inel.Element[0] == '\\xFF') return;\n  fwrite(&inel, 1,   sizeof(inel), remelmts);\n  if(ferror(remelmts)) {\n    perror(\"\\nError (ferror) writing REMELMTS file\");\n    exit(8);\n  }\n  RemElOut++;\n  memset(&inel, ' ', sizeof(inel));\n}\n/*****************************************************************/\n/* WrtLMRem() writes a record to the REMLDMDS file.              */\n/*****************************************************************/\nvoid WrtLMRem(void) {         /* write unmatched load mod record */\n  if(inlm.Member[0] == '\\xFF') return;\n  fwrite(&inlm, 1,  sizeof(inlm), remldmds);\n  if(ferror(remldmds)) {\n    perror(\"\\nError (ferror) writing REMLDMDS file\");\n    exit(8);\n  }\n  RemLMOut++;\n  memset(&inlm, ' ', sizeof(inlm));\n}\n/*****************************************************************/\n/* Terminat() closes the files and prepares for termination.     */\n/*****************************************************************/\nvoid Terminat(void) {\n  printf(\"%d Element Records read\\n\",ElmtRead);\n  printf(\"%d Load Module Records Read\\n\",LmodRead);\n  printf(\"%d Match Records Written\\n\",MatchOut);\n  printf(\"%d Remaining Load Module Records Written\\n\",RemLMOut);\n  printf(\"%d Remaining Element Records Written\\n\",RemElOut);\n  printf(\"%d Duplicate Element Records Found\\n\",DuplElmt);\n  printf(\"%d Duplicate Load Module Records\\n\",DuplLmod);\n  fclose(lmods);\n  fclose(elements);\n  fclose(matched);\n  fclose(remelmts);\n  fclose(remldmds);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "ENDVPGLS": {"ttr": 8970, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x06\\x01\\x01\\x01\\x0f\\x01\\x02\\x12o\\x074\\x00\\xa2\\x00\\x94\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2001-01-10T00:00:00", "modifydate": "2002-05-06T07:34:06", "lines": 162, "newlines": 148, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* endvpgls.c */\n/*********************************************************************/\n/* Purpose: Identify Endevor elements having no EMVSP.PGMLIST.*      */\n/*          dtatsets.                                                */\n/* Reads the element records file created by assembler program       */\n/* ENDVDATA after sorting the files for BCBS01, PRODSUP, HCS, and    */\n/* ITS together on element name and environment name and matches it  */\n/* against the list of datasets cataloged under node EMVSP.PGMLIST.* */\n/* Any element having no PGMLIST dataset is printed.                 */\n/*                                                                   */\n/* Author R Thornton Jan 2001                                        */\n/*********************************************************************/\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n/*********************************************************************/\n/* Function Prototypes                                               */\n/*********************************************************************/\nint main(void);                /* Executive control routine */\nvoid Initial(void);            /* Initialization routine */\nvoid Process(void);            /* Process control routine */\nint  ReadElem(void);           /* Routine to read the ELEMENT file */\nint  ReadPgml(void);           /* Routine to read the PGMLIST file */\nvoid Terminat(void);           /* Termination routine */\n/*********************************************************************/\n/* Global data areas and file descriptions                           */\n/*********************************************************************/\nFILE *Element;               /* define the ELEMENT file ptr */\nFILE *Pgmlist;               /* define the PGMLIST file ptr */\n\nstruct ElementRecord {       /* ELEMENT data record */\n  char Element[8];           /* Element name */\n  char Filler1;\n  char Lang[11];             /* Language descriptor */\n  char Filler2;\n  char Environment[8];       /* Environment name */\n  char Filler3;\n  char System[8];            /* System name */\n  char Filler4;\n  char SSName[8];            /* SubSystem name */\n  char Filler5;\n  char Type[5];              /* Endevor type name */\n  char Filler6;\n  char PrcGrpName[8];        /* Endevor processor group name */\n  char Filler7;\n  char PrcName[8];           /* Endevor Processor name */\n  char Filler8[9];\n} ElemRecd;\n\nint ElemLeng = 80;           /* LRECL for ELEMENT file */\nint PgmlLeng = 80;           /* LRECL for PGMLIST file */\n\nchar PgmlRecd[80];             /* record from PGMLIST file */\n/*********************************************************************/\n/* main(): this is the executive control routine                     */\n/*********************************************************************/\nint main(void) {               /* Executive control routine */\n  Initial();              /* initialize for processing */\n  while(ElemLeng) {\n    Process();                   /* process until end of file */\n  }\n  Terminat();                   /* terminate processing */\n  exit(0);                       /* relinquish control */\n}\n/*********************************************************************/\n/* Initialization: open files, read first record from both inputs.   */\n/*********************************************************************/\nvoid Initial(void) {    /* Initialization routine */\n\n  Pgmlist =(fopen(\"dd:PGMLIST\",\"rb,type=record,recfm=FB,lrecl=80\"));\n  if(Pgmlist == NULL) {\n    printf(\"Unable to open the PGMLIST file\\n\");\n    exit(8);\n  }\n  if(ferror(Pgmlist)) {\n    perror(\"Error trying to open the Pgmlist file\");\n    exit(8);\n  }\n  Element =(fopen(\"dd:ELEMENT\",\"rb,type=record,recfm=FB,lrecl=80\"));\n  if(Element == NULL) {\n    printf(\"Unable to open the ELEMENT file\\n\");\n    exit(8);\n  }\n  if(ferror(Element)) {\n    perror(\"Unable trying to open the ELEMENT file\");\n    exit(8);\n  }\n  ReadElem();              /* Read first ELEMENT record */\n  ReadPgml();              /* Read first PGMLIST record */\n}\n/*********************************************************************/\n/* Process: match the ELEMENT and PGMLIST files on element name and  */\n/* print any mismatches.                                             */\n/*********************************************************************/\nvoid Process(void) {           /* Process control routine */\n  int cpr;\n  ReadElem();                 /* read ELEMENT record */\n  if(ElemLeng != 0) {            /* if more elements */\n    cpr = memcmp(ElemRecd.Element, &PgmlRecd[14], 8);\n    if(cpr > 0) {\n      PgmlRecd[22] = '\\x00';     /* terminate string */\n      printf(\"%s has no Endevor Element\\n\",PgmlRecd);\n      ReadPgml();                /* read next PGMLIST record */\n    }\n    else\n      if(cpr < 0) {\n        ElemRecd.Filler1 = '\\x00';  /* terminate element name */\n        ElemRecd.Filler3 = '\\x00';  /* terminate environment name */\n        ElemRecd.Filler4 = '\\x00';  /* terminate system name */\n        ElemRecd.Filler5 = '\\x00';  /* terminate subsystem name */\n        printf(\"Element %s (%s %s %s) has no PGMLIST dataset\\n\",\n          ElemRecd.Element, ElemRecd.Environment, ElemRecd.System,\n          ElemRecd.SSName);\n        ReadElem();                /* read next ELEMENT record */\n      }\n      else {\n        ReadElem();                /* read next ELEMENT record */\n        ReadPgml();                /* read next PGMLIST record */\n      }\n  }\n}\n/*********************************************************************/\n/* Read next record from the ELEMENT file                            */\n/*********************************************************************/\nint  ReadElem(void) {       /* Routine to read the ELEMENT file */\n  int rc;\n  rc = fread(&ElemRecd, 1, 80, Element); /* Read */\n  if(ferror(Element)) {\n    perror(\"Error reading ELEMENT file\");\n    exit(8);\n  }\n  if(feof(Element)) {             /* test for end of file */\n    rc = 0;\n  }\n  ElemLeng = rc;                /* set EOF status indicator */\n  return(rc);\n}\n/*********************************************************************/\n/* Read next record from the PGMLIST file                            */\n/*********************************************************************/\nint  ReadPgml(void) {            /* Routine to read the PGMLIST file */\n  int rc;\n  rc = fread(PgmlRecd, 1, 80, Element); /* Read PGMLIST record */\n  if(ferror(Pgmlist)) {\n    perror(\"Error reading PGMLIST file\");\n    exit(8);\n  }\n  if(feof(Pgmlist)) {             /* test for end of file */\n    rc = 0;\n  }\n  PgmlLeng = rc;                  /* set EOF status indicator */\n  return(rc);\n}\n/*********************************************************************/\n/* Termination routine: close files and prepare to relinquish control*/\n/*********************************************************************/\nvoid Terminat(void) {           /* Termination routine */\n  fclose(Pgmlist);              /* Close PGMLIST file */\n  fclose(Element);              /* Close ELEMENT file */\n  return;\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "ENDVRTVL": {"ttr": 9217, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00H\\x01\\x01\\x00\\x8f\\x01\\x02\\x12o\\x074\\x00\\x8a\\x00\\x94\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2001-01-08T00:00:00", "modifydate": "2002-05-06T07:34:48", "lines": 138, "newlines": 148, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* endvrtvl.c */\n/*****************************************************************/\n/* Program to build a control statement stream for Endevor       */\n/* retrieves using a hard-coded model which is specialized by a  */\n/* set of member names read in from the input1 file. output is   */\n/* written to the output1 file. The output dataset can be read   */\n/* into an Endevor retrieve job to retrieve a number of elements */\n/* at one time via batch job execution.                          */\n/* The input1 file has member names in columns 1-8 of each record*/\n/* See ENDVRTV2 for a program that modifies environment, system, */\n/* subsystem, type, and element name.                            */\n/* Author R Thornton Jan 2001.                                   */\n/*****************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/*****************************************************************/\n/* Global data areas                                             */\n/*****************************************************************/\n  int MoreRecords = -1;              /* zero at EOF INPUT1 */\n  char InRec[80];                    /* record from input1 file */\n  char OutRec[6][80] = {\n       \"RETRIEVE ELEMENT 'XXXXXXXX'             \"\n                       \"                                        \",\n       \"  FROM ENVIRONMENT 'BCBS01' SYSTEM 'ADMI\"\n                       \"N' SUBSYSTEM 'PROCESS'                  \",\n       \"    TYPE 'PROCESS' STAGE 2              \"\n                       \"                                        \",\n       \"  TO DSNAME 'BC0THOR.TST.ENDEVOR.PROCS' \"\n                       \"                                        \",\n       \"  OPTIONS CCID 'OPSUPPORT' COMMENTS \\\"NEE\"\n                       \"D FOR DOCUMENTATION\\\"                   \",\n       \"    NO SIGNOUT NOSEARCH  .              \"\n                       \"                                        \"};\n  FILE *input1,*output1;             /* file pointers */\n\n/*****************************************************************/\n/* Function prototypes                                           */\n/*****************************************************************/\nint main(void);                      /* Executive control routine */\nvoid Initialize(void);               /* Initialization routine */\nvoid Process(void);                  /* Processing routine */\nvoid ReadInput1(void);               /* Reads the INPUT1 file */\nvoid WriteOutput1(void);             /* Writes the OUTPUT1 file */\nvoid Terminate(void);                /* Termination routine */\n\n/*****************************************************************/\n/* main() function: executive control                            */\n/*****************************************************************/\nint main() {\n  Initialize();                      /* Initialize for processing */\n  while(MoreRecords)                 /* Until INPUT1 is exhausted, */\n    Process();                       /*    process records. */\n  Terminate();                       /* Terminate processing */\n  return(0);\n}\n/*****************************************************************/\n/* Initialize(): Initialization routine. Opens files.            */\n/*****************************************************************/\nvoid Initialize(void) {\n  input1=fopen(\"dd:input1\",\"rb,type=record,recfm=fb,lrecl=80\");\n  if(input1 == NULL) {\n    perror(\"\\nCan't open the INPUT1 file\");\n    exit(8);\n  }\n  output1=fopen(\"dd:output1\",\"wb,type=record,recfm=fb,lrecl=80\");\n  if(output1 == NULL) {\n    perror(\"\\nCan't open the OUTPUT1 file\");\n    exit(8);\n  }\n}\n/*****************************************************************/\n/* Process: for each INPUT1 record, write a set of Endevor       */\n/* control statements that will cause retrieval of the member    */\n/* name given by the input1 file record.                         */\n/*****************************************************************/\nvoid Process(void) {\n  ReadInput1();              /* Read next INPUT1 record */\n  if(!MoreRecords) return;   /* Return if end of file */\n  WriteOutput1();            /* write OutRec to output1 file */\n}\n/*****************************************************************/\n/* ReadInput1() reads the next record from the INPUT1 file into  */\n/* the inrec area. At end of file, the MoreRecords field is set  */\n/* to zero (false).                                              */\n/*****************************************************************/\nvoid ReadInput1(void) {\n  int InRecLen;\n\n  InRecLen=fread(InRec, 1,  80, input1);\n  if(ferror(input1)) {\n    perror(\"\\nError (ferror) reading INPUT1 file\");\n    exit(8);\n  }\n  if(feof(input1)) {\n    MoreRecords = 0;\n    return;\n  }\n  if(InRecLen == 0) {\n    perror(\"\\nError (0 read) reading INPUT1 file\");\n    exit(8);\n  }\n}\n/*****************************************************************/\n/* WriteOutput1 moves the member name from the InRec record into */\n/* the OutRec1 area, then writes all 6 OutRecx records to the    */\n/* Output1 file.                                                 */\n/*****************************************************************/\nvoid WriteOutput1(void) {\n  int i;\n\n  memset(&OutRec[0][18], ' ', 9); /* clear member name */\n  for(i=0; i<8; i++) {\n    if(InRec[i] == ' ') break;\n    OutRec[0][i+18] = InRec[i];      /* move a byte of member name */\n  }\n  OutRec[0][i+18] = '\\'';\n  for(i=0; i<6; i++) {\n    fwrite(OutRec[i], 1,  80, output1);\n    if(ferror(output1)) {\n      perror(\"\\nError (ferror) writing OUTPUT1 file\");\n      InRec[8] = '\\x00';\n      printf(\"\\nMember at failure is %s, record contains: \",InRec);\n      OutRec[i][80] == '\\x00';\n      printf(\"\\n%s\",OutRec[i]);\n      exit(8);\n    }\n  }\n}\n/*****************************************************************/\n/* Terminate() closes the files and prepares for termination.    */\n/*****************************************************************/\nvoid Terminate(void) {\n  fclose(input1);\n  fclose(output1);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "ENDVRTV2": {"ttr": 9220, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00T\\x01\\x01%O\\x01\\x02\\x12o\\x075\\x00\\xad\\x00\\x86\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2001-09-11T00:00:00", "modifydate": "2002-05-06T07:35:54", "lines": 173, "newlines": 134, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* endvrtv2.c */\n/*****************************************************************/\n/* Program to build a control statement stream for Endevor       */\n/* retrieves using a hard-coded model which is specialized by a  */\n/* set of member names read in from the input1 file. output is   */\n/* written to the output1 file. The output dataset can be read   */\n/* into an Endevor retrieve job to retrieve a number of elements */\n/* at one time via batch job execution.                          */\n/* The input1 file is that created by the ENDVDATA program which */\n/* provides the environment, system, subsystem, type, and element*/\n/* names, which are all used. See program ENDVRTVL for a program */\n/* using only element name as input.                             */\n/* As written, the output dataset specified in the retrieve state*/\n/* ments is BC0THOR.TST.ENDEVOR.ASM. Also, STAGE 2 is hard-coded */\n/* and TYPE name is assumed to be 5-bytes long.                  */\n/* Author R Thornton Sep 2001.                                   */\n/*****************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/*****************************************************************/\n/* Global data areas                                             */\n/*****************************************************************/\n  int MoreRecords = -1;              /* zero at EOF INPUT1 */\n  char InRec[80];                    /* record from input1 file */\n  char OutRec[6][80] = {\n       \"RETRIEVE ELEMENT '12345678'             \"\n                       \"                                        \",\n       \"  FROM ENVIRONMENT '12345678' SYSTEM '12\"\n                       \"345678' SUBSYSTEM '12345678'            \",\n       \"    TYPE '12345' STAGE 2                \"\n                       \"                                        \",\n       \"  TO DSNAME 'BC0THOR.TST.ENDEVOR.ASM'   \"\n                       \"                                        \",\n       \"  OPTIONS CCID 'OPSUPPORT' COMMENTS \\\"NEE\"\n                       \"D FOR DOCUMENTATION\\\"                    \",\n       \"    NO SIGNOUT NOSEARCH  .              \"\n                       \"                                        \"};\n  FILE *input1,*output1;             /* file pointers */\n\n/*****************************************************************/\n/* Function prototypes                                           */\n/*****************************************************************/\nint main(void);                      /* Executive control routine */\nvoid Initialize(void);               /* Initialization routine */\nvoid Process(void);                  /* Processing routine */\nvoid ReadInput1(void);               /* Reads the INPUT1 file */\nvoid WriteOutput1(void);             /* Writes the OUTPUT1 file */\nvoid Terminate(void);                /* Termination routine */\n\n/*****************************************************************/\n/* main() function: executive control                            */\n/*****************************************************************/\nint main() {\n  Initialize();                      /* Initialize for processing */\n  while(MoreRecords)                 /* Until INPUT1 is exhausted, */\n    Process();                       /*    process records. */\n  Terminate();                       /* Terminate processing */\n  return(0);\n}\n/*****************************************************************/\n/* Initialize(): Initialization routine. Opens files.            */\n/*****************************************************************/\nvoid Initialize(void) {\n  input1=fopen(\"dd:input1\",\"rb,type=record,recfm=fb,lrecl=80\");\n  if(input1 == NULL) {\n    perror(\"\\nCan't open the INPUT1 file\");\n    exit(8);\n  }\n  output1=fopen(\"dd:output1\",\"wb,type=record,recfm=fb,lrecl=80\");\n  if(output1 == NULL) {\n    perror(\"\\nCan't open the OUTPUT1 file\");\n    exit(8);\n  }\n}\n/*****************************************************************/\n/* Process: for each INPUT1 record, write a set of Endevor       */\n/* control statements that will cause retrieval of the member    */\n/* name given by the input1 file record.                         */\n/*****************************************************************/\nvoid Process(void) {\n  ReadInput1();              /* Read next INPUT1 record */\n  if(!MoreRecords) return;   /* Return if end of file */\n  WriteOutput1();            /* write OutRec to output1 file */\n}\n/*****************************************************************/\n/* ReadInput1() reads the next record from the INPUT1 file into  */\n/* the inrec area. At end of file, the MoreRecords field is set  */\n/* to zero (false).                                              */\n/*****************************************************************/\nvoid ReadInput1(void) {\n  int InRecLen;\n\n  InRecLen=fread(InRec, 1,  80, input1);\n  if(ferror(input1)) {\n    perror(\"\\nError (ferror) reading INPUT1 file\");\n    exit(8);\n  }\n  if(feof(input1)) {\n    MoreRecords = 0;\n    return;\n  }\n  if(InRecLen == 0) {\n    perror(\"\\nError (0 read) reading INPUT1 file\");\n    exit(8);\n  }\n}\n/*****************************************************************/\n/* WriteOutput1 moves the element name from the InRec record into*/\n/* the OutRec[0] area, the environment, system, and subsystem to */\n/* the OutRec[1] area, and the type to the OutRec[2] area, then  */\n/* all 6 OutRec[] records are written to the Output1 file.       */\n/*****************************************************************/\nvoid WriteOutput1(void) {\n  int i;\n\n  memset(&OutRec[0][18], ' ', 9); /* clear member name */\n  memset(&OutRec[1][20], ' ', 9); /* clear environment name */\n  memset(&OutRec[1][38], ' ', 9); /* clear system name */\n  memset(&OutRec[1][59], ' ', 9); /* clear subsystem name */\n  memset(&OutRec[2][10], ' ', 6); /* clear type name */\n\n  for(i=0; i<8; i++) {\n    if(InRec[i] == ' ') break;\n    OutRec[0][i+18] = InRec[i];      /* move a byte of member name */\n  }\n  OutRec[0][i+18] = '\\'';\n\n  for(i=0; i<8; i++) {\n    if(InRec[i+21] == ' ') break;\n    OutRec[1][i+20] = InRec[i+21];   /* move a byte of environ. name */\n  }\n  OutRec[1][i+20] = '\\'';\n\n  for(i=0; i<8; i++) {\n    if(InRec[i+30] == ' ') break;\n    OutRec[1][i+38] = InRec[i+30];   /* move a byte of system name */\n  }\n  OutRec[1][i+38] = '\\'';\n\n  for(i=0; i<8; i++) {\n    if(InRec[i+39] == ' ') break;\n    OutRec[1][i+59] = InRec[i+39];   /* move a byte of subsys name */\n  }\n  OutRec[1][i+59] = '\\'';\n\n  for(i=0; i<8; i++) {\n    if(InRec[i+48] == ' ') break;\n    OutRec[2][i+10] = InRec[i+48];   /* move a byte of type name */\n  }\n  OutRec[2][i+10] = '\\'';\n\n  for(i=0; i<6; i++) {\n    fwrite(OutRec[i], 1,  80, output1);\n    if(ferror(output1)) {\n      perror(\"\\nError (ferror) writing OUTPUT1 file\");\n      InRec[8] = '\\x00';\n      printf(\"\\nMember at failure is %s, record contains: \",InRec);\n      OutRec[i][80] == '\\x00';\n      printf(\"\\n%s\",OutRec[i]);\n      exit(8);\n    }\n  }\n}\n/*****************************************************************/\n/* Terminate() closes the files and prepares for termination.    */\n/*****************************************************************/\nvoid Terminate(void) {\n  fclose(input1);\n  fclose(output1);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "ENDVXPND": {"ttr": 9224, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x002\\x01\\x004\\x9f\\x01\\x02\\x12o\\x076\\x00\\x99\\x00Y\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2000-12-14T00:00:00", "modifydate": "2002-05-06T07:36:32", "lines": 153, "newlines": 89, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* endvxpnd.c */\n/*****************************************************************/\n/* Program to expand a compressed Endevor file. Each compressed  */\n/* record read from the input1 file is scanned byte-by-byte. When*/\n/* the input byte is \\xFC, the next byte is a character count,   */\n/* the input byte is \\xFD, the next byte is the number of blanks */\n/* to follow. in all other cases, the input character is copied  */\n/* to the output file record.                                    */\n/* Author R Thornton Dec 2000                                    */\n/*****************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n\n/*****************************************************************/\n/* Global data areas                                             */\n/*****************************************************************/\n  char InRec[256];                   /* record from input1 file */\n  int InRecLen,OutRecLen;            /* record lengths */\n  int InByt;                         /* current InRec byte number */\n  int MaxSize = 0;                   /* maximum output1 record size */\n  int MinSize = 2000000;             /* Minimum output1 record size */\n  char OutRec[28011];                /* record to output1 file */\n  int MoreRecords = -1;              /* zero at EOF INPUT1 */\n  FILE *input1,*output1;             /* file pointers */\n\n/*****************************************************************/\n/* Function prototypes                                           */\n/*****************************************************************/\nint main(void);                      /* Executive control routine */\nvoid Initialize(void);               /* Initialization routine */\nvoid Process(void);                  /* Processing routine */\nvoid ReadInput1(void);               /* Reads the INPUT1 file */\nvoid WriteOutput1(void);             /* Writes the OUTPUT1 file */\nvoid RepeatBlanks(void);             /* Repeat blanks routine */\nvoid RepeatChars(void);              /* Repeat characters routine */\nvoid Terminate(void);                /* Termination routine */\n/*****************************************************************/\n/* main() function: executive control                            */\n/*****************************************************************/\nint main() {\n  Initialize();                      /* Initialize for processing */\n  while(MoreRecords)                 /* Until INPUT1 is exhausted, */\n    Process();                       /*    process records. */\n  Terminate();                       /* Terminate processing */\n  return(0);\n}\n/*****************************************************************/\n/* Initialize(): Initialization routine. Opens files.            */\n/*****************************************************************/\nvoid Initialize(void) {\n  input1=fopen(\"dd:input1\",\"rb,type=record,recfm=vba,lrecl=255\");\n  if(input1 == NULL) {\n    perror(\"\\nCan't open the INPUT1 file\");\n    exit(8);\n  }\n  output1=fopen(\"dd:output1\",\"wb,type=record,recfm=vba,lrecl=28011\");\n  if(output1 == NULL) {\n    perror(\"\\nCan't open the OUTPUT1 file\");\n    exit(8);\n  }\n}\n/*****************************************************************/\n/* Process: for each INPUT1 record, scan byte by byte. Copy all  */\n/* input bytes except \\xFC and \\xFD directly to the output       */\n/* record. \\xFD is followed by a blank byte count, so that many  */\n/* blanks are written to the output file. \\xFC is followed by a  */\n/* repeat count, then by the character to be repeated so that    */\n/* the character is repeated in the output file record that many */\n/* times.                                                        */\n/*****************************************************************/\nvoid Process(void) {\n  ReadInput1();              /* Read next INPUT1 record */\n  if(!MoreRecords) return;   /* Return if end of file */\n  for(InByt=0,OutRecLen=0;InByt<InRecLen;) {\n    if(InRec[InByt] == '\\xFC')\n      RepeatChars();\n    else\n      if(InRec[InByt] == '\\xFD')\n        RepeatBlanks();\n      else\n        OutRec[OutRecLen++] = InRec[InByt++];\n  }\n  WriteOutput1();            /* write OutRec to output1 file */\n}\n/*****************************************************************/\n/* RepeatChars() replicates characters to the OutRec area for the*/\n/* length specified in the byte following a \\xFC in InRec. The   */\n/* character to be replicated follows the length byte.           */\n/*****************************************************************/\nvoid RepeatChars(void) {\n  int i;\n  char k;\n\n  InByt++;                   /* step past the \\xFC */\n  i = InRec[InByt++];        /* pick up replicate count */\n  k = InRec[InByt++];        /* pick up replicate character */\n  for(;i;i--)\n    OutRec[OutRecLen++] = k; /* move character to OutRec */\n}\n/*****************************************************************/\n/* RepeatBlanks() replicates blanks to the OutRec area for the   */\n/* length specified in the byte following a \\xFD in InRec.       */\n/*****************************************************************/\nvoid RepeatBlanks(void) {\n  int i;\n\n  InByt++;                   /* step past the \\xFD */\n  for(i=InRec[InByt++];i;i--)\n    OutRec[OutRecLen++] = ' '; /* move a blank to OutRec */\n}\n/*****************************************************************/\n/* ReadInput1() reads the next record from the INPUT1 file into  */\n/* the inrec area. At end of file, the MoreRecords field is set  */\n/* to zero (false).                                              */\n/*****************************************************************/\nvoid ReadInput1(void) {\n  InRecLen=fread(InRec, 1,  255, input1);\n  if(ferror(input1)) {\n    perror(\"\\nError (ferror) reading INPUT1 file\");\n    exit(8);\n  }\n  if(feof(input1)) {\n    MoreRecords = 0;\n    return;\n  }\n  if(InRecLen == 0) {\n    perror(\"\\nError (0 read) reading INPUT1 file\");\n    exit(8);\n  }\n}\n/*****************************************************************/\n/* WriteOutput1 writes the record in the OutRec area for the     */\n/* length given by the OutRecLen field to the OUTPUT1 file.      */\n/*****************************************************************/\nvoid WriteOutput1(void) {\n  if(OutRecLen < MinSize) MinSize = OutRecLen;\n  if(OutRecLen > MaxSize) MaxSize = OutRecLen;\n  fwrite(OutRec, 1,  OutRecLen, output1);\n  if(ferror(output1)) {\n    perror(\"\\nError (ferror) writing OUTPUT1 file\");\n    exit(8);\n  }\n}\n/*****************************************************************/\n/* Terminate() closes the files and prepares for termination.    */\n/*****************************************************************/\nvoid Terminate(void) {\n  fclose(input1);\n  fclose(output1);\n  printf(\"\\nMaximum output record size was %d, minimum was %d.\",\n    MaxSize, MinSize);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "ENUM": {"ttr": 9228, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x05\\x01\\x02\\x11\\x9f\\x01\\x02\\x12o\\x077\\x00\\x15\\x00\\x10\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-06T07:37:05", "lines": 21, "newlines": 16, "modlines": 0, "user": "BC0THOR"}, "text": "/**********/\n/* enum.c */\n/*********************************************************/\n/* sample program to demonstrate use of enum.            */\n/*********************************************************/\n#include <stdio.h>\nmain() {\n enum day_of_week {Monday = '1',\n       Tuesday = '2',\n       Wednesday = '3',\n       Thursday = '4',\n       Friday = '5',\n       Saturday = '6',\n       Sunday = '7' } weekday;\n\n weekday = '3';\n if(weekday == Wednesday)\n   printf(\"It is Wednesday\\n\");\n if(weekday == Thursday)\n   printf(\"It is Thursday\\n\");\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "FAHRCENT": {"ttr": 9230, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x02\\x01\\x02\\x11\\x9f\\x01\\x02\\x12o\\x078\\x00\\x13\\x00\\x0f\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-06T07:38:02", "lines": 19, "newlines": 15, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* fahrcent.c */\n/**********************************/\n/* converts fahrenheit to celcius */\n/**********************************/\n#include <stdio.h>\n\nmain() {\n  float fahrenheit, celcius;\n\n  printf(\"\\nPlease enter fahrenheit temperature to convert: \");\n  while(1) {\n scanf(\"%f\",&fahrenheit);\n if(fahrenheit == 0) break;\n celcius = ((fahrenheit-32) *5) / 9;\n printf(\"\\n%4.2f fahrenheit = %4.2f celcius\",fahrenheit,celcius);\n printf(\"\\nPlease enter next fahrenheit temperature or zero to quit:\");\n  }\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "FIND": {"ttr": 9232, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00\\x99\\x00\\x99\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 153, "newlines": 153, "modlines": 0, "user": "BC0THOR"}, "text": "/* find.c */\n/* experiment with the findfirst() and findnext() functions */\n#include <dir.h>\n#include <dos.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n\n  struct dirinfo {              /* directory information block */\n struct ffblk *dta_ptr;         /* ptr to the dta during searches */\n struct dirinfo *prevdir;       /* ptr to previous block */\n struct dirinfo *nextdir;       /* ptr to next block */\n int dir_level;                 /* directory level (lowest = 0) */\n char dir_name[12];             /* directory name */\n int path_len;                  /* total path name length */\n int nbr_files;                 /* nbr files in directory */\n float size_files;              /* total bytes in files */\n int nbr_subdirs;               /* nbr sub-directories */\n float size_subdirs;            /* total bytes in sub-directories */\n };\n\nmain(int argc, char *argv[]) {\n  struct ffblk *f;              /* pointer to ffblk */\n  int done;                     /* true when find functions complete */\n  int level = 0;                /* current subdirectory level */\n  char *curdir=NULL;            /* ptr to name of starting directory */\n  char dirstr[256];             /* starting directory name */\n  char ch;                      /* utility string pointer */\n  int i;                        /* utility subscript */\n  struct dirinfo nulldir = {NULL, NULL, NULL, 0, \" \", 0, 0, 0.0, 0, 0.0};\n  struct dirinfo firstdir = {NULL, NULL, NULL, 0, \" \", 0, 0, 0.0, 0, 0.0};\n  struct dirinfo *p, *r;        /* pointers to dirinfo */\n  struct ffblk first_dta;       /* initial ffblk */\n  /*******************************************************************/\n  /* Initialization: get the initial path to use, either typed in on */\n  /* the command line, or the current directory by default.          */\n  /*******************************************************************/\n  if(argc == 2)\n curdir = argv[1];\n  else {\n curdir = getcwd(curdir,80);     /* get current directory path */\n  }\n  if(curdir == NULL)\n if(errno == ENODEV)\n   printf(\"\\ngetcwd() returned ENODEV\\n\");\n else if(errno == ENOMEM)\n     printf(\"\\ngetcwd() returned ENOMEM\\n\");\n else if(errno == ERANGE)\n     printf(\"\\ngetcwd() returned ERANGE\\n\");\n   else\n     printf(\"\\ngetcwd() returned %d\\n\",errno);\n  strcpy(dirstr,curdir);\n  /*******************************************************************/\n  /* Build a dirinfo element for the initial directory: get storage  */\n  /* for a dta, set the dta_ptr and ODS's dta to this storage, and   */\n  /* point p to this element. Issue findfirst for the starting       */\n  /* directory.                                                      */\n  /*******************************************************************/\n  p = &firstdir;\n  f = &first_dta;\n  p->dta_ptr = f;\n  p->path_len = (strlen(dirstr)) + 1;\n  strcat(dirstr,\"\\\\*.*\");\n  setdta((char far *)f);\n  done = findfirst(dirstr,f,FA_DIREC+FA_RDONLY+FA_HIDDEN+FA_SYSTEM+FA_LABEL+FA_A\nRCH);\n  /*******************************************************************/\n  /* Collect directory information: search the current directory for */\n  /* all items. When a file is found, add 1 to the nbr_files and add */\n  /* its size to the size_files fields. When a directory is found,   */\n  /* build a dirinfo block for it, get storage for a dta and set it  */\n  /* as the DOS dta, then issue a findfirst() and search this new    */\n  /* subdirectory. When a subdirectory search finishes, return to    */\n  /* its mother and continue until the original directory finishes.  */\n  /*******************************************************************/\n  while(1) {\n while(!done) {\n   if(f->ff_attrib == FA_DIREC) {\n  if(f->ff_name[0] == '.');\n  else {\n    level++;         /* increment sub-directory level */\n    dirstr[p->path_len] = '\\0'; /* truncate pathname to mother's */\n    r = (struct dirinfo *)malloc(sizeof(struct dirinfo)); /* get dirinfo storage\n */\n    memcpy(r,&nulldir,sizeof(struct dirinfo)); /* initialize dirinfo */\n    strcpy(r->dir_name, f->ff_name); /* set sub-directory name */\n    f = (struct ffblk *)malloc(sizeof(struct ffblk)); /* get ffblk storage */\n    r->dta_ptr = f;    /* save ffblk ptr in dirinfo */\n    setdta((char far *)f);\n    while(p->nextdir)\n   p = p->nextdir;\n    p->nextdir = r;    /* chain dirinfo forward */\n    r->nextdir = NULL; /* clear new dirinfo's forward pointer */\n    r->prevdir = p;    /* chain new dirinfo backward */\n    p = r;             /* point to new dirinfo block */\n    p->dir_level = level; /* set sub-directory level */\n    strcat(dirstr,p->dir_name); /* build new path name for findfirst() */\n    p->path_len = (strlen(dirstr)) + 1; /* set path length */\n    strcat(dirstr,\"\\\\*.*\");    /* add all files request */\n    done = findfirst(dirstr,f,FA_DIREC+FA_RDONLY+FA_HIDDEN+FA_SYSTEM+FA_LABEL+FA\n_ARCH);\n  }\n   }\n   else {\n  p->nbr_files++;\n  p->size_files += (float)f->ff_fsize;\n   }\n   done = findnext(f);\n }\n free(f);               /* free the dta area used for ffblk */\n if(level == 0)         /* all through if this was initial directory */\n   break;\n level--;               /* back up 1 level */\n r = p;                 /* start at current block */\n do                     /* locate mother's dirinfo block */\n   r =  r->prevdir;     /* point to previous dirinfo block */\n while((r->dir_level) != level);\n r->nbr_subdirs++;      /* increment nbr sub-directories */\n r->size_subdirs += ((p->size_subdirs) + (p->size_files)); /* compute total of a\nll sizes */\n p = r;                 /* set directory pointer to mother */\n f = p->dta_ptr;        /* point to mother's dta (ffblk) */\n setdta((char far *)f);\n dirstr[p->path_len] = '\\0'; /* truncate pathname to mother's */\n done = findnext(f);\n  }\n  printf(\"\\nThe directory evaluated is: %s\",dirstr);\n  printf(\"\\n   directory contains %d files\",p->nbr_files);\n  printf(\"\\n   sum of filesizes is %.0f bytes\",p->size_files);\n  printf(\"\\n   directory contains %d sub-directories\",p->nbr_subdirs);\n  printf(\"\\n   sum of sub-directory sizes is %.0f bytes\",p->size_subdirs);\n  printf(\"\\n   total size of this directory is %.0f bytes\",\n           (p->size_subdirs + p->size_files));\n  printf(\"\\n\");\n  printf(\"\\nDo you want the detail (y/n)?\");\n  ch = getche();\n  if((ch == 'y') || (ch == 'Y')) {\n p = &firstdir;                    /* point to first directory */\n while(p) {\n   printf(\"\\n\");\n   for(i=0;i<p->dir_level;i++)\n  printf(\"  \");\n   if(p->dir_level == 0)\n  printf(\"%s\",dirstr);\n   else\n  printf(\"%s\",p->dir_name);\n   printf(\" %d Files, %d Subdirs, %.0f Total bytes\",\n    p->nbr_files, p->nbr_subdirs, (p->size_files + p->size_subdirs));\n   p = p->nextdir;\n }\n  }\n  printf(\"\\n\");\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "FUNKEY": {"ttr": 9476, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x06\\x01\\x02\\x11\\x9f\\x01\\x02\\x12o\\x07C\\x00 \\x00\\x1d\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-06T07:43:06", "lines": 32, "newlines": 29, "modlines": 0, "user": "BC0THOR"}, "text": "/* funkey.c */\n/************************************************/\n/* Assigns function key to string typed by user */\n/* uses any number of command-line arguments    */\n/************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nmain(argc,argv)\nint argc;\nchar *argv[];\n{\n int key, j;\n char string[80];\n\n if(argc<3)\n   {\n    printf(\"\\nExample usage: A>funkey 2 dir *.c\");\n    exit(0);\n   }\n key = atoi(argv[1]);           /* function key number */\n strcpy(string,argv[2]);        /* first word past key number */\n for(j=3;j<argc;j++)\n   {\n    strcat(string,\" \");         /* concatenate a blank */\n    strcat(string,argv[j]); /*      and each additional word entered */\n   }\n if(strcmp(string,\"null\") == 0)\n    strcpy(string,\"\");       /* if \"null\" entered, build null string */\n printf(\"\\x1B[0;%d;\\\"%s\\\";13p\",key+58,string);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "GENLDATE": {"ttr": 9478, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x01\\xc1\\x01\\xc1\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 449, "newlines": 449, "modlines": 0, "user": "BC0THOR"}, "text": "/* genldate */\n\n#include <string.h>\n\n/***********************************************************************/\n/* This function provides the caller with a table of information       */\n/* concerning a specified date. The caller places the date of interest */\n/* in one of the Julian or Gregorian fields of the DATEGENL structure  */\n/* and and indicator of the type date sent in  the datyp field, then   */\n/* invokes genldate(), which fills in all the rmaining fields in the   */\n/* DATEGENL structure. DATEGENL must be defined globally.              */\n/***********************************************************************/\n\nstruct DATEGENL\n{\n enum\n {\n  julian_yyyyddd_sent = 'j',\n  gregorian_mmddyyyy_sent = 'g',\n  gregorian_yyyymmdd_sent = 'y'\n } datyp;                          /* date supplied type */\n enum\n {\n  successful_conversion = ' ',\n  error_in_data_supplied = 'e',\n } daterr;                         /* result indicator */\n enum\n {\n  Monday = '1',\n  Tuesday = '2',\n  Wednesday = '3',\n  Thursday = '4',\n  Friday = '5',\n  Saturday = '6',\n  Sunday = '7'\n } daywk;                          /* day of week indicator */\n enum\n {\n  not_a_holiday = ' ',\n  New_Years_Day = '1',\n  Christmas_Eve = '2',\n  Good_Friday = '3',\n  Memorial_Day = '4',\n  Independence_Day = '5',\n  Labor_Day = '6',\n  Thanksgiving_Day = '7',\n  Friday_After_Thanksgiving = '8',\n  Christmas_Day = '9',\n } holiday;                        /* holiday indicator */\n enum\n {\n  not_leap_year = '0',\n  leap_year = '1',\n } yeartyp;                        /* year type */\n char juldate[8];                     /* julian date yyyyddd */\n char gregmdy[9];                     /* gregorian date mmddyyyy */\n char gregymd[9];                     /* gregorian date yyyymmdd */\n char litdate[19];                    /* literal date, eg: May 9, 2002 */\n char julslash[9];                    /* julian date yy/ddd */\n char grgslash[11];                   /* gregorian date mm/dd/yyyy */\n char daylit[10];                     /* literal day of week, eg: Sunday */\n char monthlit[10];                   /* literal month, eg: July */\n} dategenl;\n\n/*************************************************************************/\n/* yeardata contains data about this year: day of week for January 1st,  */\n/* leap year indicator, and holiday dates. Format is:                    */\n/*   byte1: day of week for Jan 1: 0=Monday - 6=Sunday                   */\n/*   byte2: leap year indicator: 1 = leap year else 0                    */\n/*   remainder: holiday fields of 5 bytes each. Format of each field is: */\n/*          byte1: holiday type indicator (same as dategenl.holiday)     */\n/*          bytes 2-5: MMDD date of the holiday                          */\n/* tblukup() locates data for this year and initializes this area.       */\n/*************************************************************************/\n struct year_entry2 {\n   char jan1_day;\n   char leap_year_ind;\n   struct {\n  char holiday_type;\n  char holiday_mmdd[5];\n   } holiday_table[9];\n } yeardata;\n\nvoid genldate();                      /* genldate (uses struct dategenl) */\nvoid julian_sent(void);               /* process julian date sent */\nvoid mdy_date_sent(void);             /* process gregorian mdy date sent */\nvoid ymd_date_sent(void);             /* process gregorian ymd sent */\nvoid datcomn(void);                   /* common date processing */\nvoid tblukup(void);                   /* locate yeardata by table lookup */\n\nmain()\n{\n\n strcpy(dategenl.juldate,\"1992354\");     /* supply the julian date */\n dategenl.datyp = julian_yyyyddd_sent;   /* announce julian date sent */\n genldate(dategenl);\n\n printf(\"\\nGregorian date is %s\",dategenl.litdate);\n} /* end main */\n\n/***********************************************************************/\n/* This function provides the caller with a table of information       */\n/* concerning a specified date. The caller places the date of interest */\n/* in one of the Julian or Gregorian fields of the DATEGENL structure  */\n/* and and indicator of the type date sent in  the datyp field, then   */\n/* invokes genldate(), which fills in all the rmaining fields in the   */\n/* DATEGENL structure. DATEGENL must be defined globally.              */\n/***********************************************************************/\n\nvoid genldate() {\n  dategenl.juldate[8] = '\\0';             /* terminate string fields */\n  dategenl.gregmdy[9] = '\\0';\n  dategenl.gregymd[9] = '\\0';\n  dategenl.litdate[19] = '\\0';\n  dategenl.julslash[9] = '\\0';\n  dategenl.grgslash[11] = '\\0';\n  dategenl.daylit[10] = '\\0';\n  dategenl.monthlit[10] = '\\0';\n  dategenl.daterr = ' ';                  /* clear error indicator */\n  dategenl.holiday = ' ';                 /* clear holiday indicator */\n  setmem(dategenl.litdate,18,' ');        /* clear literal date area */\n  if(dategenl.datyp == julian_yyyyddd_sent) {   /* julian date sent */\n julian_sent();\n return;\n  } /* end if */\n  else if(dategenl.datyp == gregorian_mmddyyyy_sent) { /* greg mdy sent */\n mdy_date_sent();\n return;\n  } /* end else */\n  else if(dategenl.datyp == gregorian_yyyymmdd_sent) { /* greg ymd sent */\n ymd_date_sent();\n return;\n  } /* end else */\n  else {                                  /* invalid date type specified */\n dategenl.daterr = 'e';\n return;\n  } /* end else */\n} /* end genldate */\n\n/**************************************************************************/\n/* The gregcv1[] table is used in converting between julian and gregorian */\n/* dates. It contains the day numbers corresponding to the first day of   */\n/* each month.                                                            */\n/**************************************************************************/\nstatic int gregcv1[113] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273,304,\n                          334, 999};\n\n/*************************************************************************/\n/* julian_sent(): main function to handle julian date sent               */\n/*************************************************************************/\nvoid julian_sent(void) {\n  int i, julday;\n\n  if(strlen(dategenl.juldate) != 7) {\n dategenl.daterr = 'e';\n return;\n  } /* end if */\n  if(((dategenl.juldate[00] == '1') && (dategenl.juldate[1] == '9')) ||\n     ((dategenl.juldate[0] == '2') && (dategenl.juldate[11] == '0')))\n    ;\n  else {\n dategenl.daterr = 'e';\n return;\n  } /* end else */\n  for(i=2; i<7; i++)\n  if((dategenl.juldate[i]    < '1') || (dategenl.juldate[i] > '9')) {\n dategenl.daterr = 'e';\n return;\n  } /* end if */\n  for(i = 0; i < 4; i++) {\n dategenl.gregmdy[i+4] = dategenl.juldate[ii]; /* year to greg mdy */\n dategenl.gregymd[i]    = dategenl.juldate[i]; /* year to greg ymd */\n  } /* end for */\n  julday = atoi(&dategenl.juldate[4]);      /* get julian day to integer */\n  if((julday < 1) || (julday > 366)) {\n dategenl.daterr = 'e';\n return;\n  } /* end if */\n  tblukup();                            /* go get yeardata */\n  if(julday == 366)\n    if(dategenl.yeartyp == leap_year)\n      ;\n    else {\n dategenl.daterr = 'e';\n return;\n  } /* end else */\n  if(dategenl.yeartyp == leap_year)         /* set date if Feb 29th */\n    if(julday == 60) {\n      strcpy(&dategenl.gregmdy[0],\"0229\");\n      strcpy(&dategenl.gregymd[4],\"0229\");\n   datcomn();                          /* finish processing date */\n    } /* end if */\n    else if(julday > 60)                  /* -1 if leap year & past 2/29 */\n      julday -= 1;\n  i = 0;\n  while(gregcv1[i] < julday)              /* look up  for month and day */\n    i++;\n  julday -= gregcv1[i - 1];               /* deduct days to start of month */\n  dategenl.gregymd[4] = (i / 10) | '0'; /* build gregorian month */\n  dategenl.gregymd[5] = (i % 10) | '0';\n  dategenl.gregymd[66] = (julday / 10) | '0'; /* build gregorian day ofmth */\n  dategenl.gregymd[7] = (julday % 10) | '0';\n  memcpy(&dategenl.gregmdy[00], &dategenl.gregymd[4], 4); /*copy month,day */\n  datcomn();                              /* finish processing date */\n  return;\n} /* end julian_sent */\n\n/*********************************************************************/\n/* mdy_date_sent(): main function to handle gregorian mdy date sent  */\n/*********************************************************************/\nvoid mdy_date_sent(void) {\n  int i;\n\n  if(strlen(dategenl.gregmdy) != 8) {\n dategenl.daterr = 'e';\n return;\n  } /* end if */\n  for(i = 0; i < 8; i++)\n if((dategenl.gregmdy[i] < '0') || (dategenl.gregmdy[i] > '9')) {\n   dategenl.daterr = 'e';\n   return;\n } /* end if */\n\n  return;\n} /* end mdy_date_sent */\n\n/*********************************************************************/\n/* ymd_date_sent(): main function to handle gregorian ymd date sent  */\n/*********************************************************************/\nvoid ymd_date_sent(void) {\n  int i;\n\n  if(strlen(dategenl.gregymd) != 8) {\n dategenl.daterr = 'e';\n return;\n  } /* end if */\n  for(i = 0; i < 8; i++)\n if((dategenl.gregymd[i] < '0') || (dategenl.gregymd[i] > '9')) {\n   dategenl.daterr = 'e';\n   return;\n } /* end for */\n\n  return;\n} /* end ymd_date_sent */\nstatic char julmo[12][10] = {\n  {\"January\"},{\"February\"},{\"March\"},{\"April\"},{\"May\"},{\"June\"},\n  {\"July\"},{\"August\"},{\"September\"},{\"October\"},{\"November\"},{\"December\"}\n};\n\nstatic char dwktbl[7][10] = {\n  {\"Monday\"},{\"Tuesday\"},{\"Wednesday\"},{\"Thursday\"},{\"Friday\"},\n  {\"Saturday\"},{\"Sunday\"}\n};\n\n/*********************************************************************/\n/* datcomn(): common date processing.                                */\n/*********************************************************************/\nvoid datcomn(void) {\n  int i, j;\n  char *p;\n\n  memmove(&dategenl.julslash[0], &dategenl.juldate[0], 4); /* format julslash */\n  dategenl.julslash[4] = '/';\n  strcpy(&dategenl.julslash[5], &dategenl.juldate[4]);\n  memmove(&dategenl.grgslash[0], &dategenl.gregmdy[0], 2); /* format grgslash */\n  dategenl.grgslash[2] = '/';\n  memmove(&dategenl.grgslash[3], &dategenl.gregmdy[2], 2);\n  dategenl.grgslash[5] = '/';\n  strcpy(&dategenl.grgslash[6], &dategenl.gregmdy[4]);\n  for(i = 0; i < 9; i++)\n if(! strcmp(yeardata.holiday_table[i].holiday_mmdd,\n    &dategenl.gregymd[4])) {\n      dategenl.holiday = yeardata.holiday_table[i].holiday_type;\n      break;\n } /* end if */\n  i = ((atoi(&dategenl.gregymd[4])) + (yeardata.jan1_day & '0')) % 7;\n  if(i == 0)\n i = 7;\n  dategenl.daywk = i | '0';               /* move day of week number */\n  strcpy(dategenl.daylit, dwktbl[i-1]); /* move day of week literal *  /\n  i = (((dategenl.gregmdy[0]) & '0') * 10) + ((dategenl.gregmdy[1]) & '0');\n  strcpy(dategenl.monthlit, julmo[i - 1]); /* move month name */\n  strcpy(dategenl.litdate, dategenl.monthlit); /* copy month name */\n  for(i = 3; i < 11; i++)\n if(!(dategenl.litdate[i])) {\n   dategenl.litdate[i++] = ' ';\n   break;\n } /* end if */\n  if(dategenl.gregmdy[0] != '0')\n dategenl.litdate[i++] = dategenl.gregmdy[0];\n  dategenl.litdate[i++] = dategenl.gregmdy[1];            /* day */\n  dategenl.litdate[i++] = ',';                          /* comma */\n  memcpy(&dategenl.litdate[i + 1], dategenl.gregymd, 4); /* year */\n\n} /* end datcomn */\n\n/*********************************************************************/\n/* yeartbl1 contains subscript values (0-13) to yeartbl2. When the   */\n/* next is 6 or 13, January 1st next year falls on Saturday, and will*/\n/* be observed on December 31st of this year (the preceding Friday). */\n/*********************************************************************/\nstatic int yeartbl1[201] = {\n  8,2,3,4,12,0,1,2,10,5,          /* 1900-1909 */\n  6,0,8,3,4,5,13,1,2,3,           /* 1910-1919 */\n  11,6,0,1,9,4,5,6,7,2,           /* 1920-1929 */\n  3,4,12,0,1,2,10,5,6,0,          /* 1930-1939 */\n  8,3,4,5,13,1,2,3,11,6,          /* 1940-1949 */\n  0,1,9,4,5,6,7,2,3,4,            /* 1950-1959 */\n  12,0,1,2,10,5,6,0,8,3,          /* 1960-1969 */\n  4,5,13,1,2,3,11,6,0,1,          /* 1970-1979 */\n  9,4,5,6,7,2,3,4,12,0,           /* 1980-1989 */\n  1,2,10,5,6,0,8,3,4,5,           /* 1990-1999 */\n  13,0,1,2,10,5,6,0,8,3,          /* 2000-2009 */\n  4,5,13,1,2,3,11,6,0,1,          /* 2010-2019 */\n  9,4,5,6,7,2,3,4,12,0,           /* 2020-2029 */\n  1,2,10,5,6,0,8,3,4,5,           /* 2030-2039 */\n  13,1,2,3,11,6,0,1,9,4,          /* 2040-2049 */\n  5,6,7,2,3,4,12,0,1,2,           /* 2050-2059 */\n  10,5,6,0,8,3,4,5,13,1,          /* 2060-2069 */\n  2,3,11,6,0,1,9,4,5,6,           /* 2070-2079 */\n  7,2,3,4,12,0,1,2,10,5,          /* 2080-2089 */\n  6,0,8,3,4,5,6,0,1,2,            /* 2090-2099 */\n  3 };                            /* 2100 */\n\n/*************************************************************************/\n/* yeartbl2 contains data about the year: day of week for January 1st,   */\n/* leap year indicator, and holiday dates. Format is:                    */\n/*   byte1: day of week for Jan 1: 0=Monday - 6=Sunday                   */\n/*   byte2: leap year indicator: 1 = leap year else 0                    */\n/*   bytes 3-42: holiday fields of 5 bytes each. Format of each field is:*/\n/*          byte1: holiday type indicator (same as dategenl.holiday)     */\n/*          bytes 2-5: MMDD date of the holiday                          */\n/* entry 7 type is pre-set for Good Friday, and entry 8 is pre-set for   */\n/* a possible New Year's Day observed when Jan1 of next year is Saturday */\n/*************************************************************************/\n  static struct year_entry2 yeartbl2[14] = {\n {'6','0',{{'1',\"0102\"},{'4',\"0529\"},{'5',\"0704\"},{'6',\"0904\"},\n     {'7',\"1123\"},{'8',\"1124\"},{'9',\"1225\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'0','0',{{'1',\"0101\"},{'4',\"0528\"},{'5',\"0704\"},{'6',\"0903\"},\n     {'7',\"1122\"},{'8',\"1123\"},{'9',\"1225\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'1','0',{{'1',\"0101\"},{'4',\"0527\"},{'5',\"0704\"},{'6',\"0902\"},\n     {'7',\"1128\"},{'8',\"1129\"},{'9',\"1225\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'2','0',{{'1',\"0101\"},{'4',\"0526\"},{'5',\"0704\"},{'6',\"0901\"},\n     {'7',\"1127\"},{'8',\"1128\"},{'9',\"1225\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'3','0',{{'1',\"0101\"},{'4',\"0525\"},{'5',\"0703\"},{'6',\"0907\"},\n     {'7',\"1126\"},{'8',\"1127\"},{'9',\"1225\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'4','0',{{'1',\"0101\"},{'4',\"0531\"},{'5',\"0705\"},{'6',\"0906\"},\n     {'7',\"1125\"},{'8',\"1126\"},{'9',\"1224\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'5','0',{{'0',\"0000\"},{'4',\"0530\"},{'5',\"0704\"},{'6',\"0905\"},\n     {'7',\"1124\"},{'8',\"1125\"},{'9',\"1226\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'6','1',{{'1',\"0102\"},{'4',\"0528\"},{'5',\"0704\"},{'6',\"0903\"},\n     {'7',\"1122\"},{'8',\"1123\"},{'9',\"1225\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'0','1',{{'1',\"0101\"},{'4',\"0527\"},{'5',\"0704\"},{'6',\"0902\"},\n     {'7',\"1128\"},{'8',\"1129\"},{'9',\"1225\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'1','1',{{'1',\"0101\"},{'4',\"0526\"},{'5',\"0704\"},{'6',\"0901\"},\n     {'7',\"1127\"},{'8',\"1128\"},{'9',\"1225\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'2','1',{{'1',\"0101\"},{'4',\"0525\"},{'5',\"0703\"},{'6',\"0907\"},\n     {'7',\"1126\"},{'8',\"1127\"},{'9',\"1225\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'3','1',{{'1',\"0101\"},{'4',\"0531\"},{'5',\"0705\"},{'6',\"0906\"},\n     {'7',\"1125\"},{'8',\"1126\"},{'9',\"1224\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'4','1',{{'1',\"0101\"},{'4',\"0530\"},{'5',\"0704\"},{'6',\"0905\"},\n     {'7',\"1124\"},{'8',\"1125\"},{'9',\"1226\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'5','1',{{'1',\"0000\"},{'4',\"0529\"},{'5',\"0704\"},{'6',\"0904\"},\n     {'7',\"1123\"},{'8',\"1124\"},{'9',\"1225\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n };\n\n/***********************************************************************/\n/* The goodfri[]] table contains the dates of Good Friday for each year*/\n/* from 1900 to 2099. An index to the table can be computed as:        */\n/* year - 1900.                                                        */\n/***********************************************************************/\nstatic struct {\n  char good_friday_mmdd[5];       /* month-day date of Good Friday */\n} goodfri[200] = {\n  {\"0413\"},{\"0405\"},{\"0328\"},{\"0410\"},{\"0401\"},  /* 1900-1904 dates */\n {\"0421\"},{\"0413\"},{\"0329\"},{\"0417\"},{\"0409\"},   /* 1905-1909 dates */\n  {\"0325\"},{\"0414\"},{\"0405\"},{\"0321\"},{\"0410\"},  /* 1910-1914 dates */\n {\"0402\"},{\"0421\"},{\"0406\"},{\"0329\"},{\"0418\"},   /* 1915-1919 dates */\n  {\"0402\"},{\"0325\"},{\"0414\"},{\"0330\"},{\"0418\"},  /* 1920-1924 dates */\n {\"0410\"},{\"0402\"},{\"0415\"},{\"0406\"},{\"0329\"},   /* 1925-1929 dates */\n  {\"0418\"},{\"0403\"},{\"0325\"},{\"0414\"},{\"0330\"},  /* 1930-1934 dates */\n {\"0419\"},{\"0410\"},{\"0326\"},{\"0415\"},{\"0407\"},   /* 1935-1939 dates */\n  {\"0322\"},{\"0411\"},{\"0403\"},{\"0423\"},{\"0407\"},  /* 1940-1944 dates */\n {\"0330\"},{\"0419\"},{\"0404\"},{\"0326\"},{\"0415\"},   /* 1945-1949 dates */\n  {\"0407\"},{\"0323\"},{\"0411\"},{\"0403\"},{\"0416\"},  /* 1950-1954 dates */\n {\"0408\"},{\"0330\"},{\"0419\"},{\"0404\"},{\"0327\"},   /* 1955-1959 dates */\n  {\"0415\"},{\"0331\"},{\"0420\"},{\"0412\"},{\"0327\"},  /* 1960-1964 dates */\n {\"0416\"},{\"0408\"},{\"0324\"},{\"0412\"},{\"0404\"},   /* 1965-1969 dates */\n  {\"0327\"},{\"0409\"},{\"0331\"},{\"0420\"},{\"0412\"},  /* 1970-1974 dates */\n {\"0328\"},{\"0416\"},{\"0408\"},{\"0324\"},{\"0413\"},   /* 1975-1979 dates */\n  {\"0404\"},{\"0417\"},{\"0409\"},{\"0401\"},{\"0420\"},  /* 1980-1984 dates */\n {\"0405\"},{\"0328\"},{\"0417\"},{\"0401\"},{\"0324\"},   /* 1985-1989 dates */\n  {\"0413\"},{\"0329\"},{\"0417\"},{\"0409\"},{\"0401\"},  /* 1990-1994 dates */\n {\"0414\"},{\"0405\"},{\"0328\"},{\"0410\"},{\"0402\"},   /* 1995-1999 dates */\n  {\"0421\"},{\"0413\"},{\"0329\"},{\"0418\"},{\"0409\"},  /* 2000-2004 dates */\n {\"0325\"},{\"0414\"},{\"0406\"},{\"0321\"},{\"0410\"},   /* 2005-2009 dates */\n  {\"0402\"},{\"0422\"},{\"0406\"},{\"0329\"},{\"0418\"},  /* 2010-2014 dates */\n {\"0403\"},{\"0325\"},{\"0414\"},{\"0330\"},{\"0419\"},   /* 2015-2019 dates */\n  {\"0410\"},{\"0402\"},{\"0415\"},{\"0407\"},{\"0329\"},  /* 2020-2024 dates */\n {\"0418\"},{\"0403\"},{\"0326\"},{\"0414\"},{\"0330\"},   /* 2025-2029 dates */\n  {\"0419\"},{\"0411\"},{\"0326\"},{\"0415\"},{\"0407\"},  /* 2030-2034 dates */\n {\"0323\"},{\"0411\"},{\"0403\"},{\"0423\"},{\"0408\"},   /* 2035-2039 dates */\n  {\"0330\"},{\"0419\"},{\"0404\"},{\"0327\"},{\"0415\"},  /* 2040-2044 dates */\n {\"0407\"},{\"0323\"},{\"0412\"},{\"0403\"},{\"0416\"},   /* 2045-2049 dates */\n  {\"0408\"},{\"0331\"},{\"0419\"},{\"0404\"},{\"0327\"},  /* 2050-2054 dates */\n {\"0416\"},{\"0331\"},{\"0420\"},{\"0412\"},{\"0328\"},   /* 2055-2059 dates */\n  {\"0416\"},{\"0408\"},{\"0324\"},{\"0413\"},{\"0404\"},  /* 2060-2064 dates */\n {\"0327\"},{\"0409\"},{\"0401\"},{\"0420\"},{\"0412\"},   /* 2065-2069 dates */\n  {\"0328\"},{\"0417\"},{\"0408\"},{\"0324\"},{\"0413\"}, /* 2070-2074 dates */\n {\"0405\"},{\"0417\"},{\"0409\"},{\"0401\"},{\"0421\"},   /* 2075-2079 dates */\n  {\"0405\"},{\"0328\"},{\"0417\"},{\"0402\"},{\"0324\"}, /* 2080-2084 dates */\n {\"0413\"},{\"0329\"},{\"0418\"},{\"0409\"},{\"0401\"},   /* 2085-2089 dates */\n  {\"0414\"},{\"0406\"},{\"0328\"},{\"0410\"},{\"0402\"}, /* 2090-2094 dates */\n {\"0422\"},{\"0413\"},{\"0329\"},{\"0418\"},{\"0410\"},   /* 2095-2099 dates */\n};\n/*********************************************************************/\n/* tblukup(): performs year table lookups using the gregmdy year. The*/\n/* data entry found is moved to the yeardata area.                   */\n/*********************************************************************/\nvoid tblukup(void) {\n int i, j;\n  char char_year[5];\n\n  memcpy(char_year, dategenl.gregymd, 4);\n  char_year[4] = '\\0';\n  i = atoi(char_year);                /* convert year to int */\n  i -= 1900;                         /* deduct 1900 for index value */\n  j = yeartbl1[i];                   /* get index to second year table */\n  yeardata = yeartbl2[j];            /* copy data for the year */\n  strcpy(yeardata.holiday_table[7].holiday_mmdd, goodfri[i].good_friday_mmdd);\n  if((yeartbl1[i+1] == 6) || (yeartbl1[i+1] == 13)) {\n yeardata.holiday_table[8].holiday_type = '1'; /* 12/31 also New Year's */\n  } /* end if */\n  dategenl.yeartyp = yeardata.leap_year_ind; /* set year type in dategenl */\n} /* end tblukup */\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "GENLDAT0": {"ttr": 9729, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x02\\x05\\x02\\x05\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 517, "newlines": 517, "modlines": 0, "user": "BC0THOR"}, "text": "/* genldate */\n\n#include <string.h>\n\n/***********************************************************************/\n/* This function provides the caller with a table of information       */\n/* concerning a specified date. The caller places the date of interest */\n/* in one of the Julian or Gregorian fields of the DATEGENL structure  */\n/* and and indicator of the type date sent in  the datyp field, then   */\n/* invokes genldate(), which fills in all the rmaining fields in the   */\n/* DATEGENL structure. DATEGENL must be defined globally.              */\n/***********************************************************************/\n\nstruct DATEGENL\n{\n enum\n {\n  julian_yyyyddd_sent = 'j',\n  gregorian_mmddyyyy_sent = 'g',\n  gregorian_yyyymmdd_sent = 'y'\n } datyp;                          /* date supplied type */\n enum\n {\n  successful_conversion = ' ',\n  error_in_data_supplied = 'e',\n } daterr;                         /* result indicator */\n enum\n {\n  Monday = '1',\n  Tuesday = '2',\n  Wednesday = '3',\n  Thursday = '4',\n  Friday = '5',\n  Saturday = '6',\n  Sunday = '7'\n } daywk;                          /* day of week indicator */\n enum\n {\n  not_a_holiday = ' ',\n  New_Years_Day = '1',\n  Christmas_Eve = '2',\n  Good_Friday = '3',\n  Memorial_Day = '4',\n  Independence_Day = '5',\n  Labor_Day = '6',\n  Thanksgiving_Day = '7',\n  Friday_After_Thanksgiving = '8',\n  Christmas_Day = '9',\n } holiday;                        /* holiday indicator */\n enum\n {\n  not_leap_year = '0',\n  leap_year = '1',\n } yeartyp;                        /* year type */\n char juldate[8];                     /* julian date yyyyddd */\n char gregmdy[9];                     /* gregorian date mmddyyyy */\n char gregymd[9];                     /* gregorian date yyyymmdd */\n char litdate[19];                    /* literal date, eg: May 9, 2002 */\n char julslash[9];                    /* julian date yy/ddd */\n char grgslash[11];                   /* gregorian date mm/dd/yyyy */\n char daylit[10];                     /* literal day of week, eg: Sunday */\n char monthlit[10];                   /* literal month, eg: July */\n} dategenl;\n\n/*************************************************************************/\n/* yeardata contains data about this year: day of week for January 1st,  */\n/* leap year indicator, and holiday dates. Format is:                    */\n/*   byte1: day of week for Jan 1: 0=Monday - 6=Sunday                   */\n/*   byte2: leap year indicator: 1 = leap year else 0                    */\n/*   remainder: holiday fields of 5 bytes each. Format of each field is: */\n/*          byte1: holiday type indicator (same as dategenl.holiday)     */\n/*          bytes 2-5: MMDD date of the holiday                          */\n/* tblukup() locates data for this year and initializes this area.       */\n/*************************************************************************/\n struct year_entry2 {\n   char jan1_day;\n   char leap_year_ind;\n   struct {\n  char holiday_type;\n  char holiday_mmdd[5];\n   } holiday_table[9];\n } yeardata;\n\nvoid genldate();                      /* genldate (uses struct dategenl) */\nvoid julian_sent(void);               /* process julian date sent */\nvoid gregorian_sent(void);            /* process gregorian date sent */\nvoid datcomn(void);                   /* common date processing */\nvoid tblukup(void);                   /* locate yeardata by table lookup */\n\n\nvoid genldate() {\n  dategenl.daterr = ' ';                  /* clear error indicator */\n  dategenl.holiday = ' ';                 /* clear holiday indicator */\n  if(dategenl.datyp == julian_yyyyddd_sent) {   /* julian date sent */\n julian_sent();\n return;\n  } /* end if */\n  else\n if((dategenl.datyp == gregorian_mmddyyyy_sent) || /* gregorian sent */\n    (dategenl.datyp == gregorian_yyyymmdd_sent)) {\n   gregorian_sent();\n   return;\n } /* end if */\n  else {                             /* invalid date type specified */\n dategenl.daterr = 'e';\n return;\n  } /* end else */\n} /* end genldate */\n\n/**************************************************************************/\n/* The gregcvrt[] table is used in converting between julian and gregorian*/\n/* dates. It contains the day numbers corresponding to the first day of   */\n/* each month. The gregcv1 table contains leap year values, while the     */\n/* gregcv0 table contains normal year values. the appropriate values are  */\n/* moved to gregcvrt[] by the tblukup() function.                         */\n/**************************************************************************/\nint gregcvrt[13];\nstatic int gregcv0[113] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273,304,\n                          334, 999};\nstatic int gregcv1[113] = {0, 31, 60, 91, 121, 152, 182, 213, 244, 274,305,\n        335, 999};\n\n/*************************************************************************/\n/* julian_sent(): main function to handle julian date sent               */\n/*************************************************************************/\nvoid julian_sent(void) {\n  int i, julday;\n\n/* ----- julian date must be 7 bytes long ----- */\n  if(strlen(dategenl.juldate) != 7) {\n dategenl.daterr = 'e';\n return;\n  } /* end if */\n\n/* ----- century must be 19 or 20 ----- */\n  if(((dategenl.juldate[00] == '1') && (dategenl.juldate[1] == '9')) ||\n     ((dategenl.juldate[0] == '2') && (dategenl.juldate[11] == '0')))\n    ;\n  else {\n dategenl.daterr = 'e';\n return;\n  } /* end else */\n\n/* ----- julian date must consist entirely of decimal digits ----- */\n  for(i=2; i<7; i++)\n  if((dategenl.juldate[i]    < '0') || (dategenl.juldate[i] > '9')) {\n dategenl.daterr = 'e';\n return;\n  } /* end if */\n\n/* ----- move julian year to gregorian year fields ----- */\n  for(i = 0; i < 4; i++) {\n dategenl.gregmdy[i+4] = dategenl.juldate[ii]; /* year to greg mdy */\n dategenl.gregymd[i]    = dategenl.juldate[i]; /* year to greg ymd */\n  } /* end for */\n\n/* ----- go get year table data ----- */\n  tblukup();\n\n/* ----- julian day must be 1 - 366 ----- */\n  julday = atoi(&dategenl.juldate[4]);      /* get julian day to integer */\n  if((julday > 0 ) && (julday < 366))\n    ;\n  else\n    if((julday == 366) && (dategenl.yeartyp == leap_year))\n        ;\n    else {\n      dategenl.daterr = 'e';\n   return;\n    } /* end else */\n/* ----- build gregorian mmdd fields ----- */\n  i = 0;\n  while(gregcvrt[i] < julday)             /* look up  for month and day */\n    i++;\n  julday -= gregcvrt[i - 1];              /* deduct days to start of month */\n  dategenl.gregymd[4] = (i / 10) | '0'; /* build gregorian month */\n  dategenl.gregymd[5] = (i % 10) | '0';\n  dategenl.gregymd[66] = (julday / 10) | '0'; /* build gregorian day ofmth */\n  dategenl.gregymd[7] = (julday % 10) | '0';\n  memcpy(&dategenl.gregmdy[00], &dategenl.gregymd[4], 4); /*copy month,day */\n  datcomn();                              /* finish processing date */\n  return;\n} /* end julian_sent */\n\n\n/*********************************************************************/\n/* The grgvldy[] table contains the number of days in each month. It */\n/* is used in validating the gregorian date.                         */\n/*********************************************************************/\nstatic int grgvldy[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n/*********************************************************************/\n/* gregorian_sent(): main function to handle gregorian date sent.    */\n/*********************************************************************/\nvoid gregorian_sent(void) {\n  int i, day, mth;\n\n/* ----- make both gregorian dates the same date ---- */\n  if(dategenl.datyp == gregorian_mmddyyyy_sent) {\n memcpy(&dategenl.gregymd[0], &dategenl.gregmdy[4], 4); /* copy year */\n memcpy(&dategenl.gregymd[4], &dategenl.gregmdy[0], 4); /* copy mmdd */\n dategenl.gregymd[8] = '\\0';\n  } /* end if */\n  else {\n memcpy(&dategenl.gregmdy[0], &dategenl.gregymd[4], 4); /* copy mmdd */\n memcpy(&dategenl.gregmdy[4], &dategenl.gregymd[0], 4); /* copy year */\n dategenl.gregmdy[8] = '\\0';\n  } /* end else */\n\n/* ----- gregorian date must be 8 bytes long ----- */\n  if((strlen(dategenl.gregmdy) == 8) && (strlen(dategenl.gregymd) == 8))\n ;\n  else {\n dategenl.daterr = 'e';\n return;\n  } /* end else */\n\n/* ----- century must be 19 or 20 ----- */\n  if(((dategenl.gregmdy[44] == '1') && (dategenl.gregmdy[5] == '9')) ||\n  ((dategenl.gregmdy[4] == '2') && (dategenl.gregmdy[5] == '0')))\n    ;\n  else {\n dategenl.daterr = 'e';\n return;\n  } /* end else */\n\n/* ----- all 8 bytes must be decimal digits ----- */\n  for(i=0; i<8; i++)\n  if((dategenl.gregmdy[i]    < '0') || (dategenl.gregmdy[i] > '9')) {\n dategenl.daterr = 'e';\n return;\n  } /* end if */\n\n/* ----- day must be > 0 ----- */\n  day = ((dategenl.gregmdy[2] - '0') * 10) + (dategenl.gregmdy[3] - '0');\n  if(day)\n    ;\n  else {\n dategenl.daterr = 'e';\n return;\n  } /* end else */\n\n/* ----- month must be 01 to 12 ----- */\n  mth = ((dategenl.gregmdy[0] - '0') * 10) + (dategenl.gregmdy[1] - '0');\n  if((mth) && (mth < 13))\n    ;\n  else {\n dategenl.daterr = 'e';\n return;\n  } /* end else */\n\n/* ----- perform year table lookup function ----- */\n  tblukup();\n\n/* ----- check for valid day within the month ----- */\n  i = grgvldy[mth - 1];\n  if(day > i)\n    if(dategenl.yeartyp == leap_year)\n      if(day == 29)\n        ;\n      else {\n     dategenl.daterr = 'e';\n     return;\n      } /* end else */\n    else {\n      dategenl.daterr = 'e';\n   return;\n    } /* end else */\n\n/* ----- build julian date from gregorian ----- */\n  memcpy(&dategenl.juldate[0], & dategenl.gregymd[0], 4);\n  i = (gregcvrt[mth - 1]) + day;\n  dategenl.juldate[4] = ((i / 100) + '0');\n  i %= 100;\n  dategenl.juldate[5] = ((i / 10) + '0');\n  i %= 10;\n  dategenl.juldate[6] = i + '0';\n  dategenl.juldate[7] = '\\0';\n\n/* ----- go finish date processing ----- */\n  datcomn();\n  return;\n} /* end mdy_date_sent */\n\n/*********************************************************************/\n/* The julmo[] table contains the literal month names.               */\n/*********************************************************************/\nstatic char julmo[12][10] = {\n  {\"January\"},{\"February\"},{\"March\"},{\"April\"},{\"May\"},{\"June\"},\n  {\"July\"},{\"August\"},{\"September\"},{\"October\"},{\"November\"},{\"December\"}\n};\n\n/*********************************************************************/\n/* The dwktbl[] table contains the literal day of week names.        */\n/*********************************************************************/\nstatic char dwktbl[7][10] = {\n  {\"Monday\"},{\"Tuesday\"},{\"Wednesday\"},{\"Thursday\"},{\"Friday\"},\n  {\"Saturday\"},{\"Sunday\"}\n};\n\n/*********************************************************************/\n/* datcomn(): common date processing.                                */\n/*********************************************************************/\nvoid datcomn(void) {\n  int i, j;\n  char *p;\n\n/* ----- build the julslash date field ----- */\n  memmove(&dategenl.julslash[0], &dategenl.juldate[0], 4);\n  dategenl.julslash[4] = '/';\n  strcpy(&dategenl.julslash[5], &dategenl.juldate[4]);\n\n/* ----- build the grgslash date field ----- */\n  memmove(&dategenl.grgslash[0], &dategenl.gregmdy[0], 2);\n  dategenl.grgslash[2] = '/';\n  memmove(&dategenl.grgslash[3], &dategenl.gregmdy[2], 2);\n  dategenl.grgslash[5] = '/';\n  strcpy(&dategenl.grgslash[6], &dategenl.gregmdy[4]);\n\n/* ----- determine whether this date is a holiday and set indicator ----- */\n  for(i = 0; i < 9; i++)\n if(! strcmp(yeardata.holiday_table[i].holiday_mmdd,\n    &dategenl.gregymd[4])) {\n      dategenl.holiday = yeardata.holiday_table[i].holiday_type;\n      break;\n } /* end if */\n\n/* ----- build the litdate field ----- */\n  i = ((atoi(&dategenl.juldate[4])) + (yeardata.jan1_day - '0')) % 7;\n  if(i == 0)\n i = 7;\n  dategenl.daywk = i | '0';               /* move day of week number */\n  strcpy(dategenl.daylit, dwktbl[i-1]); /* move day of week literal *  /\n  i = (((dategenl.gregmdy[0]) - '0') * 10) + ((dategenl.gregmdy[1]) - '0');\n  strcpy(dategenl.monthlit, julmo[i - 1]); /* move month name */\n  strcpy(dategenl.litdate, dategenl.monthlit);            /* month name */\n  i = 2;\n  while(dategenl.litdate[++i]);\n  dategenl.litdate[i++] = ' ';\n  if(dategenl.gregmdy[2] != '0')\n dategenl.litdate[i++] = dategenl.gregmdy[2];\n  dategenl.litdate[i++] = dategenl.gregmdy[3];            /* day */\n  dategenl.litdate[i++] = ',';                            /* comma */\n  dategenl.litdate[i++] = ' ';                            /* blank */\n  memcpy(&dategenl.litdate[i], dategenl.gregymd, 4);      /* year */\n  dategenl.litdate[i + 4] = '\\0';\n} /* end datcomn */\n\n/*********************************************************************/\n/* yeartbl1 contains subscript values (0-13) to yeartbl2. When the   */\n/* next is 6 or 13, January 1st next year falls on Saturday, and will*/\n/* be observed on December 31st of this year (the preceding Friday). */\n/*********************************************************************/\nstatic int yeartbl1[201] = {\n  1,2,3,4,12,0,1,2,10,5,          /* 1900-1909 */\n  6,0,8,3,4,5,13,1,2,3,           /* 1910-1919 */\n  11,6,0,1,9,4,5,6,7,2,           /* 1920-1929 */\n  3,4,12,0,1,2,10,5,6,0,          /* 1930-1939 */\n  8,3,4,5,13,1,2,3,11,6,          /* 1940-1949 */\n  0,1,9,4,5,6,7,2,3,4,            /* 1950-1959 */\n  12,0,1,2,10,5,6,0,8,3,          /* 1960-1969 */\n  4,5,13,1,2,3,11,6,0,1,          /* 1970-1979 */\n  9,4,5,6,7,2,3,4,12,0,           /* 1980-1989 */\n  1,2,10,5,6,0,8,3,4,5,           /* 1990-1999 */\n  13,0,1,2,10,5,6,0,8,3,          /* 2000-2009 */\n  4,5,13,1,2,3,11,6,0,1,          /* 2010-2019 */\n  9,4,5,6,7,2,3,4,12,0,           /* 2020-2029 */\n  1,2,10,5,6,0,8,3,4,5,           /* 2030-2039 */\n  13,1,2,3,11,6,0,1,9,4,          /* 2040-2049 */\n  5,6,7,2,3,4,12,0,1,2,           /* 2050-2059 */\n  10,5,6,0,8,3,4,5,13,1,          /* 2060-2069 */\n  2,3,11,6,0,1,9,4,5,6,           /* 2070-2079 */\n  7,2,3,4,12,0,1,2,10,5,          /* 2080-2089 */\n  6,0,8,3,4,5,6,0,1,2,            /* 2090-2099 */\n  3 };                            /* 2100 */\n\n/*************************************************************************/\n/* yeartbl2 contains data about the year: day of week for January 1st,   */\n/* leap year indicator, and holiday dates. Format is:                    */\n/*   byte1: day of week for Jan 1: 0=Monday - 6=Sunday                   */\n/*   byte2: leap year indicator: 1 = leap year else 0                    */\n/*   bytes 3-42: holiday fields of 5 bytes each. Format of each field is:*/\n/*          byte1: holiday type indicator (same as dategenl.holiday)     */\n/*          bytes 2-5: MMDD date of the holiday                          */\n/* entry 7 type is pre-set for Good Friday, and entry 8 is pre-set for   */\n/* a possible New Year's Day observed when Jan1 of next year is Saturday */\n/*************************************************************************/\n  static struct year_entry2 yeartbl2[14] = {\n {'6','0',{{'1',\"0102\"},{'4',\"0529\"},{'5',\"0704\"},{'6',\"0904\"},\n     {'7',\"1123\"},{'8',\"1124\"},{'9',\"1225\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'0','0',{{'1',\"0101\"},{'4',\"0528\"},{'5',\"0704\"},{'6',\"0903\"},\n     {'7',\"1122\"},{'8',\"1123\"},{'9',\"1225\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'1','0',{{'1',\"0101\"},{'4',\"0527\"},{'5',\"0704\"},{'6',\"0902\"},\n     {'7',\"1128\"},{'8',\"1129\"},{'9',\"1225\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'2','0',{{'1',\"0101\"},{'4',\"0526\"},{'5',\"0704\"},{'6',\"0901\"},\n     {'7',\"1127\"},{'8',\"1128\"},{'9',\"1225\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'3','0',{{'1',\"0101\"},{'4',\"0525\"},{'5',\"0703\"},{'6',\"0907\"},\n     {'7',\"1126\"},{'8',\"1127\"},{'9',\"1225\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'4','0',{{'1',\"0101\"},{'4',\"0531\"},{'5',\"0705\"},{'6',\"0906\"},\n     {'7',\"1125\"},{'8',\"1126\"},{'9',\"1224\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'5','0',{{'0',\"0000\"},{'4',\"0530\"},{'5',\"0704\"},{'6',\"0905\"},\n     {'7',\"1124\"},{'8',\"1125\"},{'9',\"1226\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'6','1',{{'1',\"0102\"},{'4',\"0528\"},{'5',\"0704\"},{'6',\"0903\"},\n     {'7',\"1122\"},{'8',\"1123\"},{'9',\"1225\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'0','1',{{'1',\"0101\"},{'4',\"0527\"},{'5',\"0704\"},{'6',\"0902\"},\n     {'7',\"1128\"},{'8',\"1129\"},{'9',\"1225\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'1','1',{{'1',\"0101\"},{'4',\"0526\"},{'5',\"0704\"},{'6',\"0901\"},\n     {'7',\"1127\"},{'8',\"1128\"},{'9',\"1225\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'2','1',{{'1',\"0101\"},{'4',\"0525\"},{'5',\"0703\"},{'6',\"0907\"},\n     {'7',\"1126\"},{'8',\"1127\"},{'9',\"1225\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'3','1',{{'1',\"0101\"},{'4',\"0531\"},{'5',\"0705\"},{'6',\"0906\"},\n     {'7',\"1125\"},{'8',\"1126\"},{'9',\"1224\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'4','1',{{'1',\"0101\"},{'4',\"0530\"},{'5',\"0704\"},{'6',\"0905\"},\n     {'7',\"1124\"},{'8',\"1125\"},{'9',\"1226\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n {'5','1',{{'1',\"0000\"},{'4',\"0529\"},{'5',\"0704\"},{'6',\"0904\"},\n     {'7',\"1123\"},{'8',\"1124\"},{'9',\"1225\"},{'3',\"0000\"},\n     {'0',\"1231\"}}},\n };\n\n/***********************************************************************/\n/* The goodfri[]] table contains the dates of Good Friday for each year*/\n/* from 1900 to 2099. An index to the table can be computed as:        */\n/* year - 1900.                                                        */\n/***********************************************************************/\nstatic struct {\n  char good_friday_mmdd[5];       /* month-day date of Good Friday */\n} goodfri[200] = {\n  {\"0413\"},{\"0405\"},{\"0328\"},{\"0410\"},{\"0401\"},  /* 1900-1904 dates */\n {\"0421\"},{\"0413\"},{\"0329\"},{\"0417\"},{\"0409\"},   /* 1905-1909 dates */\n  {\"0325\"},{\"0414\"},{\"0405\"},{\"0321\"},{\"0410\"},  /* 1910-1914 dates */\n {\"0402\"},{\"0421\"},{\"0406\"},{\"0329\"},{\"0418\"},   /* 1915-1919 dates */\n  {\"0402\"},{\"0325\"},{\"0414\"},{\"0330\"},{\"0418\"},  /* 1920-1924 dates */\n {\"0410\"},{\"0402\"},{\"0415\"},{\"0406\"},{\"0329\"},   /* 1925-1929 dates */\n  {\"0418\"},{\"0403\"},{\"0325\"},{\"0414\"},{\"0330\"},  /* 1930-1934 dates */\n {\"0419\"},{\"0410\"},{\"0326\"},{\"0415\"},{\"0407\"},   /* 1935-1939 dates */\n  {\"0322\"},{\"0411\"},{\"0403\"},{\"0423\"},{\"0407\"},  /* 1940-1944 dates */\n {\"0330\"},{\"0419\"},{\"0404\"},{\"0326\"},{\"0415\"},   /* 1945-1949 dates */\n  {\"0407\"},{\"0323\"},{\"0411\"},{\"0403\"},{\"0416\"},  /* 1950-1954 dates */\n {\"0408\"},{\"0330\"},{\"0419\"},{\"0404\"},{\"0327\"},   /* 1955-1959 dates */\n  {\"0415\"},{\"0331\"},{\"0420\"},{\"0412\"},{\"0327\"},  /* 1960-1964 dates */\n {\"0416\"},{\"0408\"},{\"0324\"},{\"0412\"},{\"0404\"},   /* 1965-1969 dates */\n  {\"0327\"},{\"0409\"},{\"0331\"},{\"0420\"},{\"0412\"},  /* 1970-1974 dates */\n {\"0328\"},{\"0416\"},{\"0408\"},{\"0324\"},{\"0413\"},   /* 1975-1979 dates */\n  {\"0404\"},{\"0417\"},{\"0409\"},{\"0401\"},{\"0420\"},  /* 1980-1984 dates */\n {\"0405\"},{\"0328\"},{\"0417\"},{\"0401\"},{\"0324\"},   /* 1985-1989 dates */\n  {\"0413\"},{\"0329\"},{\"0417\"},{\"0409\"},{\"0401\"},  /* 1990-1994 dates */\n {\"0414\"},{\"0405\"},{\"0328\"},{\"0410\"},{\"0402\"},   /* 1995-1999 dates */\n  {\"0421\"},{\"0413\"},{\"0329\"},{\"0418\"},{\"0409\"},  /* 2000-2004 dates */\n {\"0325\"},{\"0414\"},{\"0406\"},{\"0321\"},{\"0410\"},   /* 2005-2009 dates */\n  {\"0402\"},{\"0422\"},{\"0406\"},{\"0329\"},{\"0418\"},  /* 2010-2014 dates */\n {\"0403\"},{\"0325\"},{\"0414\"},{\"0330\"},{\"0419\"},   /* 2015-2019 dates */\n  {\"0410\"},{\"0402\"},{\"0415\"},{\"0407\"},{\"0329\"},  /* 2020-2024 dates */\n {\"0418\"},{\"0403\"},{\"0326\"},{\"0414\"},{\"0330\"},   /* 2025-2029 dates */\n  {\"0419\"},{\"0411\"},{\"0326\"},{\"0415\"},{\"0407\"},  /* 2030-2034 dates */\n {\"0323\"},{\"0411\"},{\"0403\"},{\"0423\"},{\"0408\"},   /* 2035-2039 dates */\n  {\"0330\"},{\"0419\"},{\"0404\"},{\"0327\"},{\"0415\"},  /* 2040-2044 dates */\n {\"0407\"},{\"0323\"},{\"0412\"},{\"0403\"},{\"0416\"},   /* 2045-2049 dates */\n  {\"0408\"},{\"0331\"},{\"0419\"},{\"0404\"},{\"0327\"},  /* 2050-2054 dates */\n {\"0416\"},{\"0331\"},{\"0420\"},{\"0412\"},{\"0328\"},   /* 2055-2059 dates */\n  {\"0416\"},{\"0408\"},{\"0324\"},{\"0413\"},{\"0404\"},  /* 2060-2064 dates */\n {\"0327\"},{\"0409\"},{\"0401\"},{\"0420\"},{\"0412\"},   /* 2065-2069 dates */\n  {\"0328\"},{\"0417\"},{\"0408\"},{\"0324\"},{\"0413\"}, /* 2070-2074 dates */\n {\"0405\"},{\"0417\"},{\"0409\"},{\"0401\"},{\"0421\"},   /* 2075-2079 dates */\n  {\"0405\"},{\"0328\"},{\"0417\"},{\"0402\"},{\"0324\"}, /* 2080-2084 dates */\n {\"0413\"},{\"0329\"},{\"0418\"},{\"0409\"},{\"0401\"},   /* 2085-2089 dates */\n  {\"0414\"},{\"0406\"},{\"0328\"},{\"0410\"},{\"0402\"}, /* 2090-2094 dates */\n {\"0422\"},{\"0413\"},{\"0329\"},{\"0418\"},{\"0410\"},   /* 2095-2099 dates */\n};\n/*********************************************************************/\n/* tblukup(): performs year table lookups using the gregmdy year. The*/\n/* data entry found is moved to the yeardata area.                   */\n/*********************************************************************/\nvoid tblukup(void) {\n int i, j, *p;\n  char char_year[5];\n\n/* ----- compute the year table index = year - 1900 ----- */\n  memcpy(char_year, dategenl.gregymd, 4);\n  char_year[4] = '\\0';\n  i = atoi(char_year);                /* convert year to int */\n  i -= 1900;                         /* deduct 1900 for index value */\n  j = yeartbl1[i];                   /* get index to second year table */\n\n/* ----- move entry for the specified year to the yeardata field ----- */\n  yeardata = yeartbl2[j];            /* copy data for the year */\n\n/* ----- move the Good Friday date to the yeardata holiday table ----- */\n  strcpy(yeardata.holiday_table[7].holiday_mmdd, goodfri[i].good_friday_mmdd);\n\n/* ----- if next year begins on Saturday, make December 31 a holiday ----- */\n  if((yeartbl1[i+1] == 6) || (yeartbl1[i+1] == 13)) {\n yeardata.holiday_table[8].holiday_type = '1'; /* 12/31 also New Year's */\n  } /* end if */\n\n/* ----- set year type in dategenl structure ----- */\n  dategenl.yeartyp = yeardata.leap_year_ind; /* set year type in dategenl */\n\n/* ----- set correct values in the gregcvrt() table ----- */\n  p = gregcv0;\n  if(dategenl.yeartyp == leap_year)\n p = gregcv1;\n for(i = 0; i < 13; i++)\n   gregcvrt[i] = *p++;\n} /* end tblukup */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GENLDAT2": {"ttr": 9738, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x009\\x01\\x02\\x11\\x9f\\x01\\x02\\x12o\\tT\\x02\\x04\\x01\\xee\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-06T09:54:39", "lines": 516, "newlines": 494, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* genldat2.c */\n/*****************************************************************/\n/* This function provides the caller with a table of information */\n/* concerning a specified date. The caller places a date in one  */\n/* of the Julian or Gregorian fields of the DATEGENL structure   */\n/* and an indicator of the type date sent in the datyp field, and*/\n/* invokes genldat2(), which fills in all the remaining fields in*/\n/* the DATEGENL structure. A pointer to DATEGENL is passed to    */\n/* this function by the caller.                                  */\n/*****************************************************************/\n#include <stdlib.h>\n#include <string.h>\n\nstruct DATEGENL {\n  enum {\n    julian_yyyyddd_sent = 'j',\n    gregorian_mmddyyyy_sent = 'g',\n    gregorian_yyyymmdd_sent = 'y'\n  } datyp;                          /* date supplied type */\n  enum {\n    successful_conversion = ' ',\n    error_in_data_supplied = 'e'\n  } daterr;                         /* result indicator */\n  enum {\n    Monday = '1',\n    Tuesday = '2',\n    Wednesday = '3',\n    Thursday = '4',\n    Friday = '5',\n    Saturday = '6',\n    Sunday = '7'\n  } daywk;                          /* day of week indicator */\n  enum {\n    not_a_holiday = ' ',\n    New_Years_Day = '1',\n    Christmas_Eve = '2',\n    Good_Friday = '3',\n    Memorial_Day = '4',\n    Independence_Day = '5',\n    Labor_Day = '6',\n    Thanksgiving_Day = '7',\n    Friday_After_Thanksgiving = '8',\n    Christmas_Day = '9'\n  } holiday;                        /* holiday indicator */\n  enum {\n    not_leap_year = '0',\n    leap_year = '1'\n  } yeartyp;                        /* year type */\n  char juldate[8];                     /* julian date yyyyddd */\n  char gregmdy[9];                     /* gregorian date mmddyyyy */\n  char gregymd[9];                     /* gregorian date yyyymmdd */\n  char litdate[19];                 /* literal date, eg: May 9, 2002 */\n  char julslash[9];                    /* julian date yy/ddd */\n  char grgslash[11];                   /* gregorian date mm/dd/yyyy */\n  char daylit[10];                /* literal day of week, eg: Sunday */\n  char monthlit[10];                   /* literal month, eg: July */\n};\n\n/*********************************************************************/\n/* yeardata contains data about this year: day of week for January 1 */\n/* leap year indicator, and holiday dates. Format is:                */\n/*   byte1: day of week for Jan 1: 0=Monday - 6=Sunday               */\n/*   byte2: leap year indicator: 1 = leap year else 0                */\n/*   remainder: holiday fields of 5 bytes each. Format of each field:*/\n/*          byte1: holiday type indicator (same as p->holiday)       */\n/*          bytes 2-5: MMDD date of the holiday                      */\n/* tblukup() locates data for this year and initializes this area.   */\n/*********************************************************************/\n struct year_entry2 {\n   char jan1_day;\n   char leap_year_ind;\n   struct {\n     char holiday_type;\n     char holiday_mmdd[5];\n   } holiday_table[9];\n } yeardata;\n\nvoid genldat2(struct DATEGENL *p);       /* genldat2 */\nvoid julian_sent(struct DATEGENL *p);    /* process julian date sent */\nvoid gregorian_sent(struct DATEGENL *p); /* process greg date sent */\nvoid datcomn(struct DATEGENL *p);        /* common date processing */\nvoid tblukup(struct DATEGENL *p);        /* lookup yeardata in table */\n\n/*********************************************************************/\n/* The genldat2() function:                                          */\n/*********************************************************************/\nvoid genldat2(struct DATEGENL *p) {\n  p->daterr = ' ';                        /* clear error indicator */\n  p->holiday = ' ';                       /* clear holiday indicator */\n  if(p->datyp == julian_yyyyddd_sent) {   /* julian date sent */\n    julian_sent(p);\n    return;\n  }\n  else\n    if((p->datyp == gregorian_mmddyyyy_sent) || /* gregorian sent */\n      (p->datyp == gregorian_yyyymmdd_sent)) {\n        gregorian_sent(p);\n        return;\n    }\n  else {                             /* invalid date type specified */\n    p->daterr = 'e';\n    return;\n  }\n} /* end genldat2 */\n\n/*********************************************************************/\n/* The gregcvrt[] table is used in converting between julian and     */\n/* gregorian dates. It contains the day numbers corresponding to the */\n/* first day of each month. the gregcv1 table contains leap year     */\n/* values, while the gregcv0 table contains non-leap-year values. The*/\n/* appropriate values are moved to gregcvrt[] by the tblukup finction*/\n/*********************************************************************/\nint gregcvrt[13];\nstatic int gregcv0[113] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273,\n                      304,334, 999};\nstatic int gregcv1[113] = {0, 31, 60, 91, 121, 152, 182, 213, 244, 274,\n                      305,335, 999};\n\n/*********************************************************************/\n/* julian_sent(): main function to handle julian date sent           */\n/*********************************************************************/\nvoid julian_sent(struct DATEGENL *p) {\n  int i, julday;\n\n/* ----- julian date must be 7 bytes long ----- */\n  if(strlen(p->juldate) != 7) {\n    p->daterr = 'e';\n    return;\n  }\n\n/* ----- century must be 19 or 20 ----- */\n  if(((p->juldate[0] == '1') && (p->juldate[1] == '9')) ||\n     ((p->juldate[0] == '2') && (p->juldate[1] == '0')))\n    ;\n  else {\n    p->daterr = 'e';\n    return;\n  }\n\n/* ----- julian date must consist entirely of decimal digits ----- */\n  for(i=2; i<7; i++)\n    if((p->juldate[i] < '0') || (p->juldate[i] > '9')) {\n      p->daterr = 'e';\n      return;\n    }\n\n/* ----- move julian year to gregorian year fields ----- */\n  for(i = 0; i < 4; i++) {\n    p->gregmdy[i+4] = p->juldate[i]; /* year to greg mdy */\n    p->gregymd[i] = p->juldate[i];   /* year to greg ymd */\n  }\n\n/* ----- go get year table data ----- */\n  tblukup(p);\n\n/* ----- julian day must be 1 - 366 ----- */\n  julday = atoi(&p->juldate[4]);      /* get julian day to integer */\n  if((julday > 0 ) && (julday < 366))\n    ;\n  else\n    if((julday == 366) && (p->yeartyp == leap_year))\n        ;\n    else {\n      p->daterr = 'e';\n      return;\n   }\n\n/* ----- build gregorian mmdd fields ----- */\n  i = 0;\n  while(gregcvrt[i] < julday)          /* look up  for month and day */\n    i++;\n  julday -= gregcvrt[i - 1];        /* deduct days to start of month */\n  p->gregymd[4] = (i / 10) | '0';       /* build gregorian month */\n  p->gregymd[5] = (i % 10) | '0';\n  p->gregymd[66] = (julday / 10) | '0'; /* build greg day of mth */\n  p->gregymd[7] = (julday % 10) | '0';\n  memcpy(&p->gregmdy[0], &p->gregymd[4], 4); /*copy month, day */\n  datcomn(p);                           /* finish processing date */\n  return;\n} /* end julian_sent */\n\n/*********************************************************************/\n/* The grgvldy[] table contains the number of days in each month. It */\n/* is used in validating the gregorian date.                         */\n/*********************************************************************/\nstatic int grgvldy[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30,\n                          31};\n\n/*********************************************************************/\n/* gregorian_sent(): main function to handle gregorian date sent.    */\n/*********************************************************************/\nvoid gregorian_sent(struct DATEGENL *p) {\n  int i, day, mth;\n\n/* ----- make both gregorian dates the same date ---- */\n  if(p->datyp == gregorian_mmddyyyy_sent) {\n    memcpy(&p->gregymd[0], &p->gregmdy[4], 4); /* copy year */\n    memcpy(&p->gregymd[4], &p->gregmdy[0], 4); /* copy mmdd */\n    p->gregymd[8] = '\\0';\n  }\n  else {\n    memcpy(&p->gregmdy[0], &p->gregymd[4], 4); /* copy mmdd */\n    memcpy(&p->gregmdy[4], &p->gregymd[0], 4); /* copy year */\n    p->gregmdy[8] = '\\0';\n  }\n\n/* ----- gregorian date must be 8 bytes long ----- */\n  if((strlen(p->gregmdy) == 8) && (strlen(p->gregymd) == 8))\n    ;\n  else {\n    p->daterr = 'e';\n    return;\n  }\n\n/* ----- century must be 19 or 20 ----- */\n  if(((p->gregmdy[4] == '1') && (p->gregmdy[5] == '9')) ||\n    ((p->gregmdy[4] == '2') && (p->gregmdy[5] == '0')))\n      ;\n  else {\n    p->daterr = 'e';\n    return;\n  }\n\n/* ----- all 8 bytes must be decimal digits ----- */\n  for(i=0; i<8; i++)\n    if((p->gregmdy[i] < '0') || (p->gregmdy[i] > '9')) {\n      p->daterr = 'e';\n      return;\n    }\n\n/* ----- day must be > 0 ----- */\n  day = ((p->gregmdy[2] - '0') * 10) + (p->gregmdy[3] - '0');\n  if(day)\n    ;\n  else {\n    p->daterr = 'e';\n    return;\n  }\n\n/* ----- month must be 01 to 12 ----- */\n  mth = ((p->gregmdy[0] - '0') * 10) + (p->gregmdy[1] - '0');\n  if((mth) && (mth < 13))\n    ;\n  else {\n    p->daterr = 'e';\n    return;\n  }\n\n/* ----- perform year table lookup function ----- */\n  tblukup(p);\n\n/* ----- check for valid day within the month ----- */\n  i = grgvldy[mth - 1];\n  if(day > i)\n    if(p->yeartyp == leap_year)\n      if(day == 29)\n        ;\n      else {\n        p->daterr = 'e';\n        return;\n      }\n    else {\n      p->daterr = 'e';\n      return;\n    }\n\n/* ----- build julian date from gregorian ----- */\n  memcpy(&p->juldate[0], & p->gregymd[0], 4);\n  i = (gregcvrt[mth - 1]) + day;\n  p->juldate[4] = ((i / 100) + '0');\n  i %= 100;\n  p->juldate[5] = ((i / 10) + '0');\n  i %= 10;\n  p->juldate[6] = i + '0';\n  p->juldate[7] = '\\0';\n\n/* ----- go finish date processing ----- */\n  datcomn(p);\n  return;\n} /* end gregorian_sent */\n\n/*********************************************************************/\n/* The julmo[] table contains the literal month names.               */\n/*********************************************************************/\nstatic char julmo[12][10] = {\n  {\"January\"},{\"February\"},{\"March\"},{\"April\"},{\"May\"},{\"June\"},\n  {\"July\"},{\"August\"},{\"September\"},{\"October\"},{\"November\"},\n  {\"December\"}\n};\n\n/*********************************************************************/\n/* The dwktbl[] table contains the literal day of week names.        */\n/*********************************************************************/\nstatic char dwktbl[7][10] = {\n  {\"Monday\"},{\"Tuesday\"},{\"Wednesday\"},{\"Thursday\"},{\"Friday\"},\n  {\"Saturday\"},{\"Sunday\"}\n};\n\n/*********************************************************************/\n/* datcomn(): common date processing.                                */\n/*********************************************************************/\nvoid datcomn(struct DATEGENL *p) {\n  int i, j;\n\n/* ----- build the julslash date field ----- */\n  memmove(&p->julslash[0], &p->juldate[0], 4);\n  p->julslash[4] = '/';\n  strcpy(&p->julslash[5], &p->juldate[4]);\n\n/* ----- build the grgslash date field ----- */\n  memmove(&p->grgslash[0], &p->gregmdy[0], 2);\n  p->grgslash[2] = '/';\n  memmove(&p->grgslash[3], &p->gregmdy[2], 2);\n  p->grgslash[5] = '/';\n  strcpy(&p->grgslash[6], &p->gregmdy[4]);\n\n/* ----- determine whether date is a holiday and set indicator ----- */\n  for(i = 0; i < 9; i++)\n   if(!strcmp(yeardata.holiday_table[i].holiday_mmdd,&p->gregymd[4])) {\n     p->holiday = yeardata.holiday_table[i].holiday_type;\n     break;\n   }\n\n/* ----- build the litdate field ----- */\n  i = ((atoi(&p->juldate[4])) + (yeardata.jan1_day - '0')) % 7;\n  if(i == 0) i = 7;\n  p->daywk = i | '0';                   /* move day of week number */\n  strcpy(p->daylit, dwktbl[i-1]);       /* move day of week literal */\n  i = (((p->gregmdy[0]) - '0') * 10) + ((p->gregmdy[1]) - '0');\n  strcpy(p->monthlit, julmo[i - 1]); /* move month name */\n  strcpy(p->litdate, p->monthlit);      /* month name */\n  i = 2;\n  while(p->litdate[++i]);\n  p->litdate[i++] = ' ';\n  if(p->gregmdy[2] != '0')\n    p->litdate[i++] = p->gregmdy[2];\n  p->litdate[i++] = p->gregmdy[3]; /* day */\n  p->litdate[i++] = ',';                 /* comma */\n  p->litdate[i++] = ' ';                 /* blank */\n  memcpy(&p->litdate[i], p->gregymd, 4); /* year */\n  p->litdate[i + 4] = '\\0';\n} /* end datcomn */\n\n/*********************************************************************/\n/* yeartbl1 contains subscript values (0-13) to yeartbl2. When the   */\n/* next is 6 or 13, January 1st next year falls on Saturday, and will*/\n/* be observed on December 31st of this year (the preceding Friday). */\n/*********************************************************************/\nstatic int yeartbl1[201] = {\n  1,2,3,4,12,0,1,2,10,5,          /* 1900-1909 */\n  6,0,8,3,4,5,13,1,2,3,           /* 1910-1919 */\n  11,6,0,1,9,4,5,6,7,2,           /* 1920-1929 */\n  3,4,12,0,1,2,10,5,6,0,          /* 1930-1939 */\n  8,3,4,5,13,1,2,3,11,6,          /* 1940-1949 */\n  0,1,9,4,5,6,7,2,3,4,            /* 1950-1959 */\n  12,0,1,2,10,5,6,0,8,3,          /* 1960-1969 */\n  4,5,13,1,2,3,11,6,0,1,          /* 1970-1979 */\n  9,4,5,6,7,2,3,4,12,0,           /* 1980-1989 */\n  1,2,10,5,6,0,8,3,4,5,           /* 1990-1999 */\n  13,0,1,2,10,5,6,0,8,3,          /* 2000-2009 */\n  4,5,13,1,2,3,11,6,0,1,          /* 2010-2019 */\n  9,4,5,6,7,2,3,4,12,0,           /* 2020-2029 */\n  1,2,10,5,6,0,8,3,4,5,           /* 2030-2039 */\n  13,1,2,3,11,6,0,1,9,4,          /* 2040-2049 */\n  5,6,7,2,3,4,12,0,1,2,           /* 2050-2059 */\n  10,5,6,0,8,3,4,5,13,1,          /* 2060-2069 */\n  2,3,11,6,0,1,9,4,5,6,           /* 2070-2079 */\n  7,2,3,4,12,0,1,2,10,5,          /* 2080-2089 */\n  6,0,8,3,4,5,6,0,1,2,            /* 2090-2099 */\n  3                               /* 2100 */\n};\n\n/*********************************************************************/\n/* yeartbl2 contains data about the year: day of week for January 1st*/\n/* leap year indicator, and holiday dates. Format is:                */\n/*   byte1: day of week for Jan 1: 0=Monday - 6=Sunday               */\n/*   byte2: leap year indicator: 1 = leap year else 0                */\n/*   bytes 3-42: holiday fields of 5 bytes each. Format of each field*/\n/*          byte1: holiday type indicator (same as p->holiday)       */\n/*          bytes 2-5: MMDD date of the holiday                      */\n/* entry 7 type is preset for Good Friday, and entry 8 is pre-set for*/\n/* a possible New Year's Day observed when Jan1 of next year is Sat. */\n/*********************************************************************/\nstatic struct year_entry2 yeartbl2[14] = {\n {'6','0',{{'1',\"0102\"},{'4',\"0529\"},{'5',\"0704\"},{'6',\"0904\"},\n     {'7',\"1123\"},{'8',\"1124\"},{'9',\"1225\"},{'3',\"0000\"},\n     {' ',\"1231\"}}},\n {'0','0',{{'1',\"0101\"},{'4',\"0528\"},{'5',\"0704\"},{'6',\"0903\"},\n     {'7',\"1122\"},{'8',\"1123\"},{'9',\"1225\"},{'3',\"0000\"},\n     {' ',\"1231\"}}},\n {'1','0',{{'1',\"0101\"},{'4',\"0527\"},{'5',\"0704\"},{'6',\"0902\"},\n     {'7',\"1128\"},{'8',\"1129\"},{'9',\"1225\"},{'3',\"0000\"},\n     {' ',\"1231\"}}},\n {'2','0',{{'1',\"0101\"},{'4',\"0526\"},{'5',\"0704\"},{'6',\"0901\"},\n     {'7',\"1127\"},{'8',\"1128\"},{'9',\"1225\"},{'3',\"0000\"},\n     {' ',\"1231\"}}},\n {'3','0',{{'1',\"0101\"},{'4',\"0525\"},{'5',\"0703\"},{'6',\"0907\"},\n     {'7',\"1126\"},{'8',\"1127\"},{'9',\"1225\"},{'3',\"0000\"},\n     {' ',\"1231\"}}},\n {'4','0',{{'1',\"0101\"},{'4',\"0531\"},{'5',\"0705\"},{'6',\"0906\"},\n     {'7',\"1125\"},{'8',\"1126\"},{'9',\"1224\"},{'3',\"0000\"},\n     {' ',\"1231\"}}},\n {'5','0',{{' ',\"0000\"},{'4',\"0530\"},{'5',\"0704\"},{'6',\"0905\"},\n     {'7',\"1124\"},{'8',\"1125\"},{'9',\"1226\"},{'3',\"0000\"},\n     {' ',\"1231\"}}},\n {'6','1',{{'1',\"0102\"},{'4',\"0528\"},{'5',\"0704\"},{'6',\"0903\"},\n     {'7',\"1122\"},{'8',\"1123\"},{'9',\"1225\"},{'3',\"0000\"},\n     {' ',\"1231\"}}},\n {'0','1',{{'1',\"0101\"},{'4',\"0527\"},{'5',\"0704\"},{'6',\"0902\"},\n     {'7',\"1128\"},{'8',\"1129\"},{'9',\"1225\"},{'3',\"0000\"},\n     {' ',\"1231\"}}},\n {'1','1',{{'1',\"0101\"},{'4',\"0526\"},{'5',\"0704\"},{'6',\"0901\"},\n     {'7',\"1127\"},{'8',\"1128\"},{'9',\"1225\"},{'3',\"0000\"},\n     {' ',\"1231\"}}},\n {'2','1',{{'1',\"0101\"},{'4',\"0525\"},{'5',\"0703\"},{'6',\"0907\"},\n     {'7',\"1126\"},{'8',\"1127\"},{'9',\"1225\"},{'3',\"0000\"},\n     {' ',\"1231\"}}},\n {'3','1',{{'1',\"0101\"},{'4',\"0531\"},{'5',\"0705\"},{'6',\"0906\"},\n     {'7',\"1125\"},{'8',\"1126\"},{'9',\"1224\"},{'3',\"0000\"},\n     {' ',\"1231\"}}},\n {'4','1',{{'1',\"0101\"},{'4',\"0530\"},{'5',\"0704\"},{'6',\"0905\"},\n     {'7',\"1124\"},{'8',\"1125\"},{'9',\"1226\"},{'3',\"0000\"},\n     {' ',\"1231\"}}},\n {'5','1',{{'1',\"0000\"},{'4',\"0529\"},{'5',\"0704\"},{'6',\"0904\"},\n     {'7',\"1123\"},{'8',\"1124\"},{'9',\"1225\"},{'3',\"0000\"},\n     {' ',\"1231\"}}}\n};\n\n/*********************************************************************/\n/* The goodfri[] table contains the dates of Good Friday for each    */\n/* year from 1900 to 2099. An index to the table can be computed as: */\n/* year - 1900.                                                      */\n/*********************************************************************/\nstatic struct {\n  char good_friday_mmdd[5];       /* month-day date of Good Friday */\n} goodfri[200] = {\n   {\"0413\"},{\"0405\"},{\"0328\"},{\"0410\"},{\"0401\"}, /*1900-1904 dates*/\n   {\"0421\"},{\"0413\"},{\"0329\"},{\"0417\"},{\"0409\"},   /*1905-1909 dates*/\n   {\"0325\"},{\"0414\"},{\"0405\"},{\"0321\"},{\"0410\"},   /*1910-1914 dates*/\n   {\"0402\"},{\"0421\"},{\"0406\"},{\"0329\"},{\"0418\"},   /*1915-1919 dates*/\n   {\"0402\"},{\"0325\"},{\"0414\"},{\"0330\"},{\"0418\"},   /*1920-1924 dates*/\n   {\"0410\"},{\"0402\"},{\"0415\"},{\"0406\"},{\"0329\"},   /*1925-1929 dates*/\n   {\"0418\"},{\"0403\"},{\"0325\"},{\"0414\"},{\"0330\"},   /*1930-1934 dates*/\n   {\"0419\"},{\"0410\"},{\"0326\"},{\"0415\"},{\"0407\"},   /*1935-1939 dates*/\n   {\"0322\"},{\"0411\"},{\"0403\"},{\"0423\"},{\"0407\"},   /*1940-1944 dates*/\n   {\"0330\"},{\"0419\"},{\"0404\"},{\"0326\"},{\"0415\"},   /*1945-1949 dates*/\n   {\"0407\"},{\"0323\"},{\"0411\"},{\"0403\"},{\"0416\"},   /*1950-1954 dates*/\n   {\"0408\"},{\"0330\"},{\"0419\"},{\"0404\"},{\"0327\"},   /*1955-1959 dates*/\n   {\"0415\"},{\"0331\"},{\"0420\"},{\"0412\"},{\"0327\"},   /*1960-1964 dates*/\n   {\"0416\"},{\"0408\"},{\"0324\"},{\"0412\"},{\"0404\"},   /*1965-1969 dates*/\n   {\"0327\"},{\"0409\"},{\"0331\"},{\"0420\"},{\"0412\"},   /*1970-1974 dates*/\n   {\"0328\"},{\"0416\"},{\"0408\"},{\"0324\"},{\"0413\"},   /*1975-1979 dates*/\n   {\"0404\"},{\"0417\"},{\"0409\"},{\"0401\"},{\"0420\"},   /*1980-1984 dates*/\n   {\"0405\"},{\"0328\"},{\"0417\"},{\"0401\"},{\"0324\"},   /*1985-1989 dates*/\n   {\"0413\"},{\"0329\"},{\"0417\"},{\"0409\"},{\"0401\"},   /*1990-1994 dates*/\n   {\"0414\"},{\"0405\"},{\"0328\"},{\"0410\"},{\"0402\"},   /*1995-1999 dates*/\n   {\"0421\"},{\"0413\"},{\"0329\"},{\"0418\"},{\"0409\"},   /*2000-2004 dates*/\n   {\"0325\"},{\"0414\"},{\"0406\"},{\"0321\"},{\"0410\"},   /*2005-2009 dates*/\n   {\"0402\"},{\"0422\"},{\"0406\"},{\"0329\"},{\"0418\"},   /*2010-2014 dates*/\n   {\"0403\"},{\"0325\"},{\"0414\"},{\"0330\"},{\"0419\"},   /*2015-2019 dates*/\n   {\"0410\"},{\"0402\"},{\"0415\"},{\"0407\"},{\"0329\"},   /*2020-2024 dates*/\n   {\"0418\"},{\"0403\"},{\"0326\"},{\"0414\"},{\"0330\"},   /*2025-2029 dates*/\n   {\"0419\"},{\"0411\"},{\"0326\"},{\"0415\"},{\"0407\"},   /*2030-2034 dates*/\n   {\"0323\"},{\"0411\"},{\"0403\"},{\"0423\"},{\"0408\"},   /*2035-2039 dates*/\n   {\"0330\"},{\"0419\"},{\"0404\"},{\"0327\"},{\"0415\"},   /*2040-2044 dates*/\n   {\"0407\"},{\"0323\"},{\"0412\"},{\"0403\"},{\"0416\"},   /*2045-2049 dates*/\n   {\"0408\"},{\"0331\"},{\"0419\"},{\"0404\"},{\"0327\"},   /*2050-2054 dates*/\n   {\"0416\"},{\"0331\"},{\"0420\"},{\"0412\"},{\"0328\"},   /*2055-2059 dates*/\n   {\"0416\"},{\"0408\"},{\"0324\"},{\"0413\"},{\"0404\"},   /*2060-2064 dates*/\n   {\"0327\"},{\"0409\"},{\"0401\"},{\"0420\"},{\"0412\"},   /*2065-2069 dates*/\n   {\"0328\"},{\"0417\"},{\"0408\"},{\"0324\"},{\"0413\"},   /*2070-2074 dates*/\n   {\"0405\"},{\"0417\"},{\"0409\"},{\"0401\"},{\"0421\"},   /*2075-2079 dates*/\n   {\"0405\"},{\"0328\"},{\"0417\"},{\"0402\"},{\"0324\"},   /*2080-2084 dates*/\n   {\"0413\"},{\"0329\"},{\"0418\"},{\"0409\"},{\"0401\"},   /*2085-2089 dates*/\n   {\"0414\"},{\"0406\"},{\"0328\"},{\"0410\"},{\"0402\"},   /*2090-2094 dates*/\n   {\"0422\"},{\"0413\"},{\"0329\"},{\"0418\"},{\"0410\"}    /*2095-2099 dates*/\n};\n\n/*********************************************************************/\n/* tblukup(): performs year table lookups using the gregmdy year. The*/\n/* data entry found is moved to the yeardata area.                   */\n/*********************************************************************/\nvoid tblukup(struct DATEGENL *p) {\n  int i, j, *q;\n  char char_year[5];\n\n/* ----- compute the year table index = year - 1900 ----- */\n  memcpy(char_year, p->gregymd, 4);\n  char_year[4] = '\\0';\n  i = atoi(char_year);               /* convert year to int */\n  i -= 1900;                         /* deduct 1900 for index value */\n  j = yeartbl1[i];                 /* get index to second year table */\n\n/* ----- move entry for specified year to the yeardata field ----- */\n  yeardata = yeartbl2[j];            /* copy data for the year */\n\n/* ----- move the Good Friday date to yeardata holiday table ----- */\n  strcpy(yeardata.holiday_table[7].holiday_mmdd,\n         goodfri[i].good_friday_mmdd);\n\n/* -- if next year begins on Saturday, make December 31 a holiday -- */\n  if((yeartbl1[i+1] == 6) || (yeartbl1[i+1] == 13)) {\n    yeardata.holiday_table[8].holiday_type = '1'; /* 12/31=New Years */\n  }\n\n/* ----- set year type in dategenl structure ----- */\n  p->yeartyp = yeardata.leap_year_ind; /* set year type in dategenl */\n\n/* ----- set correct values in the gregcvrt() table ----- */\n  q = gregcv0;\n  if(p->yeartyp == leap_year)\n    q = gregcv1;\n  for(i = 0; i < 13; i++)\n    gregcvrt[i] = *q++;\n} /* end tblukup */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETENTR": {"ttr": 9993, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00_\\x00_\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 95, "newlines": 95, "modlines": 0, "user": "BC0THOR"}, "text": "/****************************************************************/\n/* Reads characters into buffer, echoing the input starting     */\n/* at row and column using video attribute attr. characters are */\n/* read until an exit key (CR, Esc, or arrow) is encountered, or*/\n/* until the number read is one less than the specified buffer  */\n/* size, length. If the first key pressed is an exit key, the   */\n/* buffer is unaltered. Otherwise, the buffer is initially      */\n/* filled with blanks and terminated with a null; therefore, the*/\n/* resulting string will be blank-padded on the right. The      */\n/* terminating exit key is not placed into the buffer. The      */\n/* length parameter should equal the sizeof the receiving buffer*/\n/* The mode parameter can specify one or more of the following  */\n/* features (constants defined in scr.h):                       */\n/*      NOFEAT:   No mode features specified                    */\n/*      AUTOEXIT: Exit field automatically when buffer is full  */\n/*      UPPER:    Convert all letters to upper case             */\n/* The function returns one of the following codes indicating   */\n/* the field exit key pressed by the user:                      */\n/*     -1     <Esc>                                             */\n/*      0     <CR>                                              */\n/*      1     <Left arrow>                                      */\n/*      2     <Right arrow>                                     */\n/*      3     <Up arrow>                                        */\n/*      4     <Down arrow>                                      */\n/*      5     Automatic exit (last character entered and        */\n/*            AUTOEXIT was selected).                           */\n/****************************************************************/\nint scr_gets(char *buffer, int attr, int row, int col, int length, int mode) {\n register int cur_col, i;  /* current column / loop index */\n int video_seg;     /* Segment of video memory */\n int far *video;     /* far pointer to video memory */\n int key;      /* Stores input key value */\n int first_char = 1;    /* Flag to indicate the 1st character */\n char *chpt;      /* For filling buffer with blanks */\n int far *intfp;     /* For filling buffer with blanks */\n\n cur_col = col;     /* Initialize current column */\n if(*(char far *)0x00400049 == 7) /* Test Video mode */\n  video_seg = 0xB000;    /* monochrome */\n else\n  video_seg = 0xB800;    /* color */\n /* Initialize far pointer to video memory */\n video = MK_FP(video_seg, row * 160 + col * 2);\n /* Place cursor at first position */\n set_cur(row, cur_col, 0);\n for(;;)                      /* Keyboard read loop */\n  switch (key = kbd_getc()) {\n   case 0x011B:   /* Esc */\n    return(-1);\n   case 0x4B00:   /* Left arrow */\n    return(1);\n   case 0x4D00:   /* Right arrow */\n    return(2);\n   case 0x4800:   /* Up arrow */\n    return(3);\n   case 0x5000:   /* Down arrow */\n    return(4);\n   case 0x1C0D:   /* Return */\n    return(0);\n   case 0x0E08:   /* Backspace */\n    if(cur_col > col) {\n     set_cur(row, --cur_col, 0);\n     *--video = (attr << 8) | ' ';\n     *--buffer = ' ';\n    }\n    break;\n   default:\n    if(cur_col >= col + length - 1)    /* Test end of buffer */\n     break;\n    if(key & 0x00FF == 0)   /* Test for non-ASCII character */\n     break;\n    if(mode & UPPER)        /* Uppercase conversion */\n     key = toupper(key & 0x00FF);\n    else\n     key &= 0x00FF;      /* Remove extended code */\n    /* Place key in video memory and buffer */\n    *video++ = (attr << 8) | key;\n    *buffer++ = key;\n    set_cur(row, ++cur_col, 0);   /* Update cursor position */\n    if(first_char) {       /* Blank fill buffer on first char */\n     first_char = 0;\n     chpt = buffer;\n     intfp = video;\n     for(i = 1; i <= length-2; ++i) {\n      *chpt++ = ' ';\n      *intfp++ = (attr << 8) | ' ';\n     }\n     *chpt = '\\0';\n    }\n    /* Test for AUTOEXIT */\n    if((cur_col >= col + length - 1) && (mode & AUTOEXIT))\n     return(5);            /* Code for AUTOEXIT */\n     break;\n   }\n}\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETWORDS": {"ttr": 9996, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00#\\x01\\x02\\x11\\x9f\\x01\\x02\\x12o\\x10\\x11\\x00\\x9b\\x00\\x9c\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-06T10:11:23", "lines": 155, "newlines": 156, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* getwords.c */\n/*******************************************************************/\n/* reads a text file and extracts English words for use in creating*/\n/* a list of English words.                                        */\n/*                                                                 */\n/* Author R Thornton January 1995                                  */\n/*******************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid initialize(int argc, char *argv[]); /* initialization function */\nvoid mainline(void);                  /* mainline function */\nvoid getaword(void);               /* extract word from input record */\nvoid process_word(void);              /* process the word */\nvoid validate_word(void);             /* apply validity checks */\nvoid add_word_to_table(void);         /* add word to table */\nvoid write_table_to_file(void);    /* write the word table to a file */\nvoid terminate(void);                 /* termination function */\nvoid readrec(void);                   /* read next input file record */\nvoid writerec(void);                  /* write record to output file */\n\nFILE *infile, *outfile;               /* file handle pointers */\nchar innam[81];                       /* input file name */\nchar outnam[81];                      /* output file name */\n\nchar inrecord[256];                   /* input file record area */\n\nint i,j,k,l,m;                        /* general purpose int */\nint valid_word = 0;                   /* valid word indicator */\nint morerecs = -1;                    /* input end-of-file switch */\nint morewords = -1;                   /* more words in record */\nint table_full = 0;                   /* word table full indicator */\nint wordleng;                         /* word length */\nint nbr_vowels;                       /* number vowels in word */\n\n\nchar word[80];                        /* a word */\nstruct {\n  int word_length;                    /* length of word in entry */\n  char word_entry[15];                /* word in entry */\n} word_table[1000];                   /* table of words */\nint w1,w2,wcurr,whigh=0;              /* table subscripts */\n\nchar trans[256] = {\n '\\0',' ',' ',' ',' ',' ',' ',' ',' ',' ','\\0',' ',' ','\\0',' ',' ',\n ' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ', /*1*/\n ' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ', /*2*/\n ' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ', /*3*/\n ' ','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o', /*4*/\n 'p','q','r','s','t','u','v','w','x','y','z',' ',' ',' ',' ',' ', /*5*/\n ' ','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o', /*6*/\n 'p','q','r','s','t','u','v','w','x','y','z',' ',' ',' ',' ',' ', /*7*/\n ' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ', /*8*/\n ' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ', /*9*/\n ' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ', /*a*/\n ' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ', /*b*/\n ' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ', /*c*/\n ' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ', /*d*/\n ' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ', /*e*/\n ' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '  /*f*/\n};\n\nint  main(int argc, char *argv[]) {\n initialize(argc, argv);       /* open files */\n while(morerecs)               /* perform mainline until */\n  mainline();               /* no more records */\n terminate();                  /* close files */\n exit(0);                      /* quit */\n}\n/*********************************************************************/\n/* mainline function: process input file until no more records.      */\n/*********************************************************************/\nvoid mainline(void) {\n  while(morewords)\n process_word();\n  readrec();\n}\n/*********************************************************************/\n/* process the word                                                  */\n/*********************************************************************/\nvoid process_word() {\n  validate_word();\n  if(valid_word)\n add_word_to_table();\n  if(table_full)\n write_table_to_file();\n  getaword();\n}\n/*********************************************************************/\n/* validate the word: apply validity tests                           */\n/*********************************************************************/\nvoid validate_word() {\n  valid_word = 0;                      /* assume it is invalid */\n}\n/*********************************************************************/\n/* add the current word to the word table.                           */\n/*********************************************************************/\nvoid add_word_to_table() {\n  table_full = 1;                      /* indicate table is full */\n}\n/*********************************************************************/\n/* extract next word from input record                               */\n/*********************************************************************/\nvoid getaword() {\n}\n/*********************************************************************/\n/* initialization: open files, read first input record.              */\n/*********************************************************************/\nvoid initialize(int argc, char *argv[]) {\n  if(argc == 3) {\n    strcpy(innam,argv[1]);\n    strcpy(outnam,argv[2]);\n  }\n  else {\n    printf(\"\\nEnter input file spec: \");\n    gets(innam);\n    printf(\"\\nEnter output file spec: \");\n    gets(outnam);\n  }\n  if((infile=fopen(innam,\"rb\")) == NULL) { /* open input */\n    printf(\"Can't open file %s.\",innam);\n    exit(1);\n  }\n  if((outfile=fopen(outnam,\"wb\")) == NULL) { /* open output */\n    printf(\"Can't open file %s.\",outnam);\n    exit(1);\n  }\n  readrec();             /* read first input file record */\n  getaword();            /* extract first word in record */\n}\n/*********************************************************************/\n/* read next input file record. at end of file, set morerecs switch. */\n/*********************************************************************/\nvoid readrec() {\n  if(fgets(inrecord,255,infile) == NULL) /* read input until eof */\n    morerecs = 0;                       /* set switch at end of file */\n  if(morerecs)\n    for(l=strlen(inrecord),i=0;i<l;i++)  /* scan record, translate */\n      inrecord[i] = trans[inrecord[i]];  /*to lowercase alphabet only*/\n}\n/*********************************************************************/\n/* write the table of words to a disk file and clear it              */\n/*********************************************************************/\nvoid write_table_to_file() {\n  fputs(inrecord,outfile);         /* write output record */\n}\n/*********************************************************************/\n/* termination: close files                                          */\n/*********************************************************************/\nvoid terminate() {\n  fclose(infile);                           /* close files */\n  fclose(outfile);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "HANGMAN": {"ttr": 10244, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x01\\x94\\x01\\x94\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 404, "newlines": 404, "modlines": 0, "user": "BC0THOR"}, "text": "// Filename :  Hangman1.cpp\n// Programmer: Linda Hopkins\n// Student ID: 230-80-9819\n//Instructor:  Samah Senbel\n// Date:       October 25, 1995\n// Description : This program plays the hangman game.\n\n// header file for graphics functions\n#include <graphics.h>\n// header file containing the getch() function\n#include <conio.h>\n// header file containing the exit function\n#include <stdlib.h>\n// header file for the cout function\n#include <iostream.h>\n//header file for filestream functions\n#include <fstream.h>\n//header file for sleep functions\n#include <dos.h>\n#include <stdio.h>\n\n#define inp_file \"dict.dat\"\n\n//Function prototypes\nvoid instruct();\nvoid noose();\nvoid head();\nvoid body();\nvoid lleg();\nvoid rleg();\nvoid larm();\nvoid rarm();\nvoid lfoot();\nvoid rfoot();\nvoid DisplayChar( int x , int y , char c );\nint Pick_random();\nvoid Get_word(int secret, char& let1, char& let2, char& let3, char& let4);\nvoid Guess(char [], int, char&);\nint CheckGuess(char, char [], int ); // changed to return int RNT\nvoid Decide_guess(char [],, int, int&, int&, char, char, char, char);\nvoid wrongg(int& );\nvoid Exit(int, int);\nvoid Display_guess(char [], int);\n\n\nvoid main()\n{\n  int secret;\n  int z;\n  int k=0;\n  int r=0;\n  char guess;\n  char let1;\n  char let2;\n  char let3;\n  char let4;\n  char guess_array[13] ={0,0,0,0,0,0,0,0,0,0,0,0,0};\n\n  int gdriver = DETECT, gmode;     // Graphics driver & mode, auto detection\n  int errorcode;                   // type of error found , if any\n\n  instruct();\n  getch();\n  clrscr();\n  secret = Pick_random();          //Pick a random number to select mystery word\n  Get_word(secret, let1, let2, let3, let4);\n\n  cout<<\"The secret word is \"<<let1<<let2<<let3<<let4;   //Print out used in tes\nting\n  getch();\n\n  initgraph(&gdriver, &gmode, \"\");  // Start graphics mode\n  errorcode = graphresult();        // Show type of error, if any\n  if (errorcode != grOk)            // an error occurred\n    {\n      cout << \"Graphics error: %s\\n\", grapherrormsg(errorcode);\n      cout << \"Press any key to halt:\";\n      getch();\n      exit(1);                      //terminate with an error code\n    }\n   setcolor(YELLOW);\n\n   noose();\n\n//Play the Game!!\n\n     for (z=0; z<11; z++)                   //total guesses max 11\n       { if ( ! ((r==4) || (k==8)) )        //max 4 right guesses; 8 wrong guess\nes\n    { Guess(guess_array, z, guess);\n      Decide_guess(guess_array, z, k, r, let1, let2, let3, let4);\n      Exit(r,k);\n     }\n      }\n//End the Game!!\n\n      closegraph();\n      Display_guess(guess_array, z);\n\nreturn ;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n//Function: Head\n   void head()                      /* Draw head, Circle with  */\n   {\n   circle( 320,100,20);            /* center (320,100) and radius 20 */\n   }\n\n\n/////////////////////////////////////////////////////////////////////////////\n\n//Function: Body\n   void body()\n   {\n   line( 320,120,320,200);         /* Draw body,line from (320,140) to (320,300)\n */\n   }\n/////////////////////////////////////////////////////////////////////////////\n\n\n//Function:left leg\n   void lleg()\n   {\n   line( 320, 200, 250, 275 );      /* Draw left leg,line from (320,300) to (220\n,420) */\n   }\n/////////////////////////////////////////////////////////////////////////////\n\n\n//Function: left foot\n   void lfoot()\n   {\n   line(250, 275, 225, 265);         /* left foot, line from (220,420) to (200,4\n20) */\n   }\n/////////////////////////////////////////////////////////////////////////////\n\n\n//Function: right leg\n   void rleg()\n   {\n   line( 320 , 200 , 390, 275 );   /* Draw Right leg, line from (320,300) to (42\n0,420) */\n   }\n/////////////////////////////////////////////////////////////////////////////\n\n\n//Function: right foot\n   void rfoot()\n   {\n    line( 390, 275, 415, 265);        /* right foot, line from (420,420) to (440\n,420) */\n   }\n////////////////////////////////////////////////////////////////////////////////\n/\n\n//Function: left arm\n   void larm()\n   {\n   line( 320 , 150, 260, 175);     /* Draw left arm, line from (320,160) to ( 22\n0,220) */\n   }\n//////////////////////////////////////////////////////////////////////////////\n\n//Function: right arm\n   void rarm()\n   {\n   line( 320 , 150 , 380 , 175 );  /* Draw right arm, line from (320,160) to (42\n0,220) */\n   }\n/////////////////////////////////////////////////////////////////////////////\n\n//Function: noose\n   void noose()\n  {\n   line(0,380,640,380);            /* Draw ground line */\n   line(320,80,320,30);            /* Draw hangman's noose */\n   line(320,30,200,30);\n   line(200,30,200,380);\n\n   rectangle(5, 475, 40, 425);     /*Boxes for correct letter*/\n   rectangle(70,475,105,425);\n   rectangle(135,475,170,425);\n   rectangle(200,475,235,425);\n  }\n///////////////////////////////////////////////////////////////////////////////\n\n//Function: instructions\n  void instruct()\n  {\n  cout<<\"Are you ready to play hangman?\"<< endl;\n  cout<<\"You will be prompted to enter letters to guess a four letter word.\"<<en\ndl;\n  cout<<\"If you are successful, the letter will appear in one of the boxes.\"<<en\ndl;\n  cout<<\"If you are unsuccessful, another part of the hanged man's body will app\near.\"<<endl;\n  cout<<\"Good luck.  Press enter to begin the game.\"<<endl;\n  }\n/////////////////////////////////////////////////////////////////////////////\n\n// Function   : DisplayChar\n// Parameters : location (x,y) and the character c to be displayed\n// Purpose    : Converts the character into a string containing this\n//              character & the null character. Then, displays the\n//              string in Graphics mode at location (x,y)\n\n\nvoid DisplayChar( int x , int y , char c )\n{\n  char s[2];\n  s[0] = c ;\n  s[1]= '\\0';             // 2nd char of the string is the null char.\n  outtextxy( x , y , s );\n\nreturn;\n}\n\n//////////////////////////////////////////////////////////////////////////////Fu\nnction:  Pick_random\n//Purpose:   To select a random number in preparation for selecting a word\n//           from the input file.\n\nint Pick_random()\n{\n  int secret;\n  randomize();\n  secret = random(10);\n  cout<<endl<<endl;\n  cout<<\"We picked word number \"<<secret<<endl;\n\nreturn secret;\n}\n\n//////////////////////////////////////////////////////////////////////////////Fu\nnction:  Get_word\n//Purpose:   To read in a word from a 10 word input file.\n\nvoid Get_word(int secret, char& let1, char& let2, char& let3, char& let4)\n{\n  int i;\n  ifstream cinf;\n  cinf.open(inp_file);\n\n  for (i=0; i<=secret; i++)\n    cinf>>let1>>let2>>let3>>let4;\n\n  cinf.close();\n\nreturn;\n}\n//////////////////////////////////////////////////////////////////////////////\n//Function:  Guess\n//Purpose:   Allows the user to enter guesses while a 0 is returned from\n//           CheckGuess.  This enables the user to guess duplicate letters\n//           without penalty.\n\nvoid Guess(char guess_array[], int z, char& guess)\n{\n   int ret=0;                      // return value from CheckGuess RNT\n\n\n   while(ret == 0)\n    {               // call CheckGuess until no dupl RNT\n      guess=getch();\n      ret = CheckGuess(guess, guess_array, z); // get return value RNT\n     }\n  return ;\n}\n/////////////////////////////////////////////////////////////////////////////\n//Function:  CheckGuess\n//Purpose:   Enters the guess into a guess array; checks to see if the letter\n//           has been guessed previously.  Duplicate guesses do not penalize\n//           the guesser.\n\nint CheckGuess(char guess, char guess_array[], int z)\n{                                                // returns int RNT\n   int i;\n\n   for (i=0; i<11; i++)\n    {\n      if (guess_array[i] == 0)\n       {\n  guess_array[z] = guess;\n  return(1);                  // return(1) = o.k. guess RNT\n       }\n      else\n  if (guess == guess_array[i])\n  {\n    outtextxy(300,20,\"Duplicate guess, Try again.\");\n    sleep(5);\n    setcolor(BLACK);;\n    outtextxy(300,20,\"Duplicate guess, Try again.\");\n    setcolor(YELLOW);\n     return(0);            // return(0) = duplicate guess RNT\n  }\n    }\n   return(1);                   // should never get here RNT\n}\n/////////////////////////////////////////////////////////////////////////////\n//Function:  Decide_guess\n//Purpose:   If the guess is a correct one, the letters will be displayed in the\n//           letter boxes. If there is not a correct guess, the wrong guess func\ntion\n//           will be invoked, which will draw the hanged man in increments accor\nding\n//           to the number of wrong guesses.\n\nvoid Decide_guess(char guess_array[], int z, int& k, int& r, char let1, char let\n2, char let3, char let4)\n\n{\n       if     (let1 == guess_array[z])\n     {\n        DisplayChar(22,450,guess_array[z]);\n        r++;\n     }\n   else if (let2 == guess_array[z])\n     {\n     DisplayChar(87,450,guess_array[z]);\n     r++;\n     }\n   else if (let3 == guess_array[z])\n     {\n      DisplayChar(152,450,guess_array[z]);\n      r++;\n     }\n   else if  (let4 == guess_array[z])\n     {\n      DisplayChar(217,450,guess_array[z]);\n      r++;\n     }\n   else wrongg(k);\n\n}\n\n//////////////////////////////////////////////////////////////////////////////Fu\nnction: wrongg\n//Purpose : To assign body parts to wrong guesses\n\nvoid wrongg(int& k)\n{\n   k=k+1;\n   switch(k)\n   {\n    case 1 : head();\n    break;\n    case 2 : body();\n    break;\n    case 3 : rarm();\n    break;\n    case 4 : larm();\n    break;\n    case 5  : lleg();\n    break;\n    case 6  : rleg();\n    break;\n    case 7  : rfoot();\n    break;\n    case 8  : lfoot();\n    break;\n   }                       //end switch\nreturn;\n}\n//////////////////////////////////////////////////////////////////////////////Fu\nnction:  Exit\n//Purpose:   Prints a lose or win message.  Returns the guesser to the main\n//           function, where the graphics driver is closed.\n\nvoid Exit(int r, int k)\n\n{\n  if (r==4)\n   {\n   outtextxy(400,450,\"You Win, press enter to exit.\");\n   getch();\n   return;\n   }\n  if (k==8)\n  {\n   outtextxy(400,450, \"You Lose, press enter to exit.\");\n   getch();\n   return;\n  }\nreturn;\n}\n\n//////////////////////////////////////////////////////////////////////////////Fu\nnction:  Display_guess\n//Purpose:   After the hangman game is over, total guesses (excluding duplicates\n)\n//           are displayed in text mode.\n\nvoid Display_guess(char guess_array[13], int z)\n{\n  cout<<\"Your guesses were as follows:\"<<endl;\n      for (z=0; z<12; z++)\n {\n cout<<\"Guess_array [\"<<z<<\"] is: \"<<guess_array[z]<<endl;\n }\nreturn;\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "HELLO": {"ttr": 10251, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00Q\\x01\\x02\\x11\\x9f\\x01\\x02\\x12o\\x10\\x13\\x00\\t\\x00\\x05\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-06T10:13:51", "lines": 9, "newlines": 5, "modlines": 0, "user": "BC0THOR"}, "text": "/***********/\n/* hello.c */\n/**************************************/\n/* The traditional \"hello.c\" program. */\n/**************************************/\n#include <stdio.h>\nint  main() {\n  printf(\"Hello, World!\\n\");\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "HEXDUMP": {"ttr": 10253, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00R\\x01\\x02\\x11\\x9f\\x01\\x02\\x12o\\x10 \\x004\\x008\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-06T10:20:52", "lines": 52, "newlines": 56, "modlines": 0, "user": "BC0THOR"}, "text": "/*************/\n/* hexdump.c */\n/**********************************************/\n/* hexdump: Print a file in hex and character */\n/**********************************************/\n#include <stdio.h>\n#include <stdlib.h>\n\nmain(int argc, char *argv[]) {\n  FILE *fptr;\n  unsigned int ch,i,sub,bytno=0,tot=0;\n  char j,k,line[33],hexcvt[]=\"0123456789ABCDEF\";\n  line[32]='\\0';\n\n  if(argc!=2) {\n    printf(\"\\nSYNTAX: hexdump [d:][path]filename[.ext]\");\n    exit(0);\n  }\n  if((fptr=fopen(argv[1],\"rb\"))==NULL) {\n    printf(\"\\nUnable to open file %s.\",argv[1]);\n    exit(8);\n  }\n  do {\n    sub=0;\n    while((sub<32)&&((ch=getc(fptr))!=EOF)) {\n      tot+=1;\n      line[sub]=ch;\n    }\n    printf(\"\\n%6X  \",bytno);\n    for(i=0;i<=sub;i++) {\n      k=line[i];\n      if(k<0)\n        k=-k;\n      j=k/16;\n      k=k%16;\n      printf(\"%c%c\",hexcvt[j],hexcvt[k]);\n      if(!(i % 4))\n        printf(\" \");\n      if(i==16)\n        printf(\"  \");\n    }\n    for(i=0;i<32;i++) {\n      if((line[i]<' ')||(line[i]>'z'))\n        line[i]='.';\n    }\n    printf(\"  %s\",line);\n    bytno+=32;\n  }\n  while(ch!=EOF);\n  printf(\"\\n\\nTotal bytes in file: %d.\\n\",tot);\n  fclose(fptr);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "HOPKINS": {"ttr": 10497, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00h\\x00h\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 104, "newlines": 104, "modlines": 0, "user": "BC0THOR"}, "text": "\n// lab8e4.cpp\n// Programmer: Linda Hopkins\n//\n//\n\n#include <iostream.h>\n#include <conio.h>             // for clrscr\n#include <ctype.h>             // for toupper and tolower\n#include <string.h>\n#define MAX_SIZE 99\nvoid shiftm();\nvoid shiftp();\nvoid map(void);\nchar str1[38];\nchar str2[38];\nchar input[MAX_SIZE];\nchar output[MAX_SIZE];\nint i;\nint k;\nint j;\nint t;\n\nvoid main()\n{\nchar c;\ncout<<\"\\nEnter a string: \";\ncin.get(input,MAX_SIZE);\ncout<<\"You entered: \"<<input<<endl;\n\n//Convert string to lower case.\nfor(i=0; i<MAX_SIZE; i++)\n{input[i] = tolower(input[i]);}\n\nstrcpy(str1,\"abcd 012345efghijklmnopqrstuvwxyz6789\");\nstrcpy(str2,\"phkanbr cfqgdstzjoyuxelvmiw9470628153\");\n\ncout<<\"lower case:\"<<input<<endl;\ncout<<str1<<endl;\ncout<<str2<<endl;\n\n//Translate input string to output string using str1 to str2 coding only\nfor (k=0; k<MAX_SIZE; k++)\n{\n   for (t=0; t<2; t++)\n   {                                                  //start of shift loop\n if (t==0)\n       {\n  shiftp();\n       }\n else\n {\n  shiftm();\n\n }\n\n\n   }                                              //end for shift loop\n}                                                 //end for K count loop\n\n\n\n\n\ncout<<\"\\nThis is the output string:\";\ncout<<output;\n\n\nreturn;\n}\n\n////////////////////////////////////////////////////////////////////////////\n\nvoid shiftm()\n{\n  for (i=0; i>-7; i--)\n    {\n       map();\n    }\n}\n\n\n////////////////////////////////////////////////////////////////////////////\nvoid shiftp()\n{\n  for(i=0; i<=7; i++)\n  {\n     map();\n  }\n}\n////////////////////////////////////////////////////////////////////////////\nvoid map()\n{\n     for (j=0; j<37; j++)\n       {\n    if ( (!(input[k] >= '0') && (input[k] <= '9')) ||\n  (!(input[k] >= 'a') && (input[k] <= 'z'))\n       )\n       output[k] = input[k];\n\n       else if (input[k] == str1[j])\n       output[k] = str2[j];\n      }\n}                                                  //end for inner loop\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "IBMDUMP": {"ttr": 10500, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00&\\x01\\x01\\x17\\x1f\\x01\\x01\\x17o\\x11\\x10\\x00\\xac\\x00\\xa9\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2001-06-20T00:00:00", "modifydate": "2001-06-25T11:10:26", "lines": 172, "newlines": 169, "modlines": 0, "user": "BC0THOR"}, "text": "/*********************************************************************/\n/* Reads an IBM SYSUDUMP that is created by a //SYSUDUMP DD or by    */\n/* issuing PRINT DATASET - PRINT - PRINT CLOSE from an SDSF job      */\n/* that contains an IBM dump.                                        */\n/* 1. Read through the input file until the ASCB: literal is found.  */\n/*    If not found, abend with a message.                            */\n/*                                                                   */\n/* Author R Thornton June, 2001                                      */\n/*********************************************************************/\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n/*********************************************************************/\n/* Global data areas                                                 */\n/*********************************************************************/\nFILE *input1, *output1;  /*file pointers*/\nchar Record \u00dd121\u00a8;\nint n1=1, n2=0, n3=0, n4=0, n5=0, n6=0, n7=0, n8=0; /* output counts */\nint count=0;                 /* input1 record count */\n/*********************************************************************/\n/* Function prototypes                                               */\n/*********************************************************************/\nint  main(void);             /* executive control routine */\nvoid AnalyzeDump(void);      /* analyze the dump data */\nvoid PrintResult(void);      /* print results of analysis */\nvoid Initialize(void);       /* Initialize for porcessing */\nvoid Terminate(void);        /* termination routine */\n/*********************************************************************/\n/* Executive control routine                                         */\n/*********************************************************************/\nint  main(void) {            /* executive control routine */\n  int more_records = 1;      /* =0 at eof input1 */\n  Initialize();              /* Initialize for processing */\n  while(more_records)        /* Analyze the dump data until */\n    AnalyzeDump();           /*  the dump file is exhausted. */\n  PrintResult();             /* Print results of analysis. */\n  Terminate();               /* Finished, terminate processing */\n  return(0);                 /* Return control to caller */\n}\n/*********************************************************************/\n/* Analyze content of the dump file                                  */\n/*********************************************************************/\nvoid AnalyzeDump(void) {\n    more_records = fread(&record, 15, 1, input1); /* read record */\n    if(ferror(input1)) {\n      printf(\"\\nAt record number %d \",count);\n      perror(\"Read error on input1\");\n      exit(8);\n    }\n    if(!more_records) break;   /* quit at end of file */\n    count++;                   /* count input records */\n    memcpy(&work, record.digit[0], 2); /* copy 1st field */\n    work[2] = '\\x0';           /* make it a string */\n    d1 = atoi(work);           /* convert it to int */\n    memcpy(&work, record.digit[1], 2); /* copy 2nd field */\n    work[2] = '\\x0';           /* make it a string */\n    d2 = atoi(work);           /* convert it to int */\n    memcpy(&work, record.digit[2], 2); /* copy 3rd field */\n    work[2] = '\\x0';           /* make it a string */\n    d3 = atoi(work);           /* convert it to int */\n    memcpy(&work, record.digit[3], 2); /* copy 4th field */\n    work[2] = '\\x0';           /* make it a string */\n    d4 = atoi(work);           /* convert it to int */\n    if(((d2 * d4) % d3) == 0)  /* formula 1 division ok? */\n      if((d1 - d2 / d3 * d4) == 7) {  /* try formula1, if true: */\n        fwrite(&record, 1, sizeof(record), output1); /* write record */\n        n1++;                      /* count combinations */\n      }\n    if((d3 % d4) == 0)          /* formula 2 division ok? */\n      if((d1 - d2 - d3 / d4) == 4) {  /* try formula2, if true: */\n        fwrite(&record, 1, sizeof(record), output2); /* write record */\n        n2++;                      /* count combinations */\n    }\n    if((d1 + d2 + d3 * d4) == 174) {  /* try formula3, if true: */\n      fwrite(&record, 1, sizeof(record), output3); /* write record */\n      n3++;                      /* count combinations */\n    }\n    if((d1 + d2 + d3 + d4) == 28) {  /* try formula4, if true: */\n      fwrite(&record, 1, sizeof(record), output4); /* write record */\n      n4++;                      /* count combinations */\n    }\n    if((d1 - d2 + d3 * d4) == 2) {  /* try formula5, if true: */\n      fwrite(&record, 1, sizeof(record), output5); /* write record */\n      n5++;                      /* count combinations */\n    }\n    if((d1 - d2 + d3 * d4) == 181) {  /* try formula6, if true: */\n      fwrite(&record, 1, sizeof(record), output6); /* write record */\n      n6++;                      /* count combinations */\n    }\n    if((d1 + d2 * d3 - d4) == 105) {  /* try formula7, if true: */\n      fwrite(&record, 1, sizeof(record), output7); /* write record */\n      n7++;                      /* count combinations */\n    }\n    if((d1 + d2 + d3 * d4) == 89) {  /* try formula8, if true: */\n      fwrite(&record, 1, sizeof(record), output8); /* write record */\n      n8++;                      /* count combinations */\n    }\n  }\n}\n/*********************************************************************/\n/* Terminate processing: print final output counts and close files.  */\n/*********************************************************************/\nvoid Terminate(void) {\n  printf(\"%d output1 combinations found.\\n\",n1);\n  printf(\"%d output2 combinations found.\\n\",n2);\n  printf(\"%d output3 combinations found.\\n\",n3);\n  printf(\"%d output4 combinations found.\\n\",n4);\n  printf(\"%d output5 combinations found.\\n\",n5);\n  printf(\"%d output6 combinations found.\\n\",n6);\n  printf(\"%d output7 combinations found.\\n\",n7);\n  printf(\"%d output8 combinations found.\\n\",n8);\n  fclose(output1);\n  fclose(output1);\n  fclose(output2);\n  fclose(output3);\n  fclose(output4);\n  fclose(output5);\n  fclose(output6);\n  fclose(output7);\n  fclose(output8);\n  exit(0);\n}\n/*********************************************************************/\n/*  Initialize for processing: Open output file.                     */\n/*********************************************************************/\nvoid Initialize(void) {\n  input1 = (fopen(\"dd:INPUT1\",\"rb,type=record,recfm=FB,lrecl=15\"));\n  if(input1 == NULL) {\n    perror(\"Error opening file INPUT1: \");\n    exit(8);\n  }\n  output1 = (fopen(\"dd:OUTPUT1\",\"wb,type=record,recfm=FB,lrecl=15\"));\n  if(output1 == NULL) {\n    perror(\"Error opening file OUTPUT1: \");\n    exit(8);\n  }\n  output2 = (fopen(\"dd:OUTPUT2\",\"wb,type=record,recfm=FB,lrecl=15\"));\n  if(output2 == NULL) {\n    perror(\"Error opening file OUTPUT2: \");\n    exit(8);\n  }\n  output3 = (fopen(\"dd:OUTPUT3\",\"wb,type=record,recfm=FB,lrecl=15\"));\n  if(output3 == NULL) {\n    perror(\"Error opening file OUTPUT3: \");\n    exit(8);\n  }\n  output4 = (fopen(\"dd:OUTPUT4\",\"wb,type=record,recfm=FB,lrecl=15\"));\n  if(output4 == NULL) {\n    perror(\"Error opening file OUTPUT4: \");\n    exit(8);\n  }\n  output5 = (fopen(\"dd:OUTPUT5\",\"wb,type=record,recfm=FB,lrecl=15\"));\n  if(output5 == NULL) {\n    perror(\"Error opening file OUTPUT5: \");\n    exit(8);\n  }\n  output6 = (fopen(\"dd:OUTPUT6\",\"wb,type=record,recfm=FB,lrecl=15\"));\n  if(output6 == NULL) {\n    perror(\"Error opening file OUTPUT6: \");\n    exit(8);\n  }\n  output7 = (fopen(\"dd:OUTPUT7\",\"wb,type=record,recfm=FB,lrecl=15\"));\n  if(output7 == NULL) {\n    perror(\"Error opening file OUTPUT7: \");\n    exit(8);\n  }\n  output8 = (fopen(\"dd:OUTPUT8\",\"wb,type=record,recfm=FB,lrecl=15\"));\n  if(output8 == NULL) {\n    perror(\"Error opening file OUTPUT8: \");\n    exit(8);\n  }\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "JUMPTAB": {"ttr": 10504, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00$\\x00$\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "BC0THOR"}, "text": "/***********************************************************************/\n/* file: jumptab.c                                                     */\n/* purpose: linkage between natural and the user defined functions     */\n/***********************************************************************/\n\n/***********************************************************************/\n/*                section 1: define structure of a jump tabe entry     */\n/***********************************************************************/\n#include \"nattab.h\"\n#include \"natuser.h\"\n\n/***********************************************************************/\n/*                section 2: define external example routines          */\n/***********************************************************************/\nextern NATFCT MYCADD NATARGDCL(pcnt, pdat, pinf);\nextern NATFCT MYCEDIT NATARGDCL(pcnt, pdat, pinf);\nextern NATFCT MYC3GL NATARGDCL(pcnt, pdat, pinf);\nextern NATFCT SCALE NATARGDCL(pcnt, pdat, pinf);\n\n/***********************************************************************/\n/*                section 3: initialize the jumptable                  */\n/* The function name visible to NATURAL must be not longer than 8      */\n/* uppercase characters. They must contain only uppercase letters. The */\n/* entries in the array must be alphabetically sorted by the function  */\n/* names.                                                              */\n/***********************************************************************/\nTAB_STRUCT n_call_table[] = {{\"MYC3GL\", MYC3GL}, {\"MYCADD\", MYCADD},\n        {\"MYCEDIT\", MYCEDIT}, {\"SCALE\", SCALE}};\n\n/***********************************************************************/\n/*                section 4: make number of elements in the jump table */\n/*                           available to NATURAL.                     */\n/***********************************************************************/\nTAB_SIZE n_call_tab = sizeof(n_call_table) / sizeof(n_call_table[0]);\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JUMPTAB2": {"ttr": 10506, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00E\\x00E\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 69, "newlines": 69, "modlines": 0, "user": "BC0THOR"}, "text": "/***********************************************************************/\n/* file: jumptab.c                                                     */\n/* purpose: linkage between natural and the user defined functions     */\n/***********************************************************************/\n\n/***********************************************************************/\n/* purpose: NATURAL link interface to user supplied C functions        */\n/***********************************************************************/\n\n/**************************************************************/\n/* Define structure for user exit call table                  */\n/**************************************************************/\ntypedef struct nc_tab_struct {\n   char fctn_name[9];            /* NATURAL name of function */\n   long (*proc_ptr)();           /* Pointer to function entry */\n} TAB_STRUCT;\n\n/*********************************************************/\n/* NATURAL parameter field information                   */\n/*********************************************************/\ntypedef struct {\n   char typevar;      /* type of variable                */\n   unsigned char pb2;          /* if type == (N or P) then total  */\n        /*    number of digits else unused */\n   union {\n      unsigned char pb[2];      /* if type == (N or P) then        */\n      unsigned short lfield;     /*    pb[00] = #dig before dec point*/\n   } flen;             /*    pb[1] = #dig after dec point */\n         /* else lfield = length of field   */\n   } FINFO;\n\n/*****************************************************************/\n/* defines for UNIX platform user exits                          */\n/*****************************************************************/\nextern int ncxr_callnat();\n\n/***********************************************************************/\n/*                section 2: define external example routines          */\n/***********************************************************************/\n\n/***********************************************************************/\n/*                   Start of code to be changed by the user           */\n/***********************************************************************/\nextern long MYCADD();\nextern long MYCEDIT();\nextern long MYC3GL();\nextern long SCALE();\n\n/***********************************************************************/\n/*                section 3: initialize the jumptable                  */\n/* The function name visible to NATURAL must be not longer than 8      */\n/* uppercase characters. They must contain only uppercase letters. The */\n/* entries in the array must be alphabetically sorted by the function  */\n/* names.                                                              */\n/***********************************************************************/\nTAB_STRUCT n_call_table[]    = {{\"MYC3GL\", MYC3GL}, {\"MYCADD\", MYCADD},\n        {\"MYCEDIT\", MYCEDIT}, {\"SCALE\", SCALE}};\n\n/***********************************************************************/\n/*                   End of code to be changed by the user             */\n/***********************************************************************/\n\n/***********************************************************************/\n/*                section 4: make number of elements in the jump table */\n/*                           available to NATURAL.                     */\n/***********************************************************************/\nint n_call_tab = sizeof(n_call_table) / sizeof(n_call_table[0]);\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "KBDTEST": {"ttr": 10508, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x002\\x01\\x02\\x11\\x9f\\x01\\x02\\x12o\\x103\\x00\\x10\\x00\\x10\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-06T10:33:32", "lines": 16, "newlines": 16, "modlines": 0, "user": "BC0THOR"}, "text": "/* kbdtest.c */\n/*******************************/\n/* prints code of keyboard key */\n/*******************************/\n#include <stdio.h>\nint  main() {\n  char key,key2;\n\n  while((key=getchar()) != 'X')\n  if(key == 0) {\n    key2=getchar();\n    printf(\"%3d %3d\\n\",key,key2);\n  }\n  else\n    printf(\"%3d\\n\",key);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "LITRLS": {"ttr": 10510, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x03\\xa5\\x03\\xa5\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 933, "newlines": 933, "modlines": 0, "user": "BC0THOR"}, "text": "Checking Users...\nWelcome back, Dick, !\nEnter Password (dots WILL echo)? ......\nYour Access Level is 60\nLogging DICK THORNTON onto the Blue Ridge Express of Richmond, VA.\nRBBS-PC Version CPC17.3C with Modifications throught 01-01-95\nYou are currently on Node 4,  Operating at  2400 BAUD,N,8,1\nTimes on: 15  Last visit was on : 01-15-95 18:25\nPress any key to continue\nthose individuals who may be using or are interested in personal computers.\nPress any key to continue\nDick, at least 20 NEW Files have been\n added since your last visit on 01-15-95 .\nReview new files added to BRE : [Y]es=[ENTER] ,No)? n\nChecking for new bulletins.\n 0 New Bulletin(s) since last call\nChecking messages in MAIN....\nSorry Dick, but there is No NEW Mail Found..\nRBBS-PC CPC17.3C with Modifications throught 01-01-95 Node 4\nCaller # 1673735  Active Msgs: 183  Next Msg # 4563  Last Msg Read: 2703\n                  ------*>>>   BRE's Main Menu   <<<*------\n   ----- Mail ---------- System ---------- Utilities ------ Elsewhere ---\n                      [B]ulletins         [H]elp (or ?)      [F]iiles\n    [R]ead Mail       [C]omment to Sysop [J]oin Sub-Board [G]oodbye\n    [P]ersonal Mail [I]nitial Welcome [V]iew User Statu [Q]uit To\n                      [W]ho's on With You [X]pert on/off [U]tilitie    s\n                      [N]ew Sub-Board Mail\n                       * = unavailable\n   ----------------------------------------------------------------------\n      Current time:  7:49 PM  Minutes remaining: 70     Security: 60\n   ----------------------------------------------------------------------\nMAIN: 70 min left\nMAIN command <?,B,C,F,G,H,I,J,K,M,N,P,Q,R,U,V,W,X>? j 196\nNo such option 196\n* Ctrl-K(^K) / ^X aborts. ^S suspends ^Q resumes *\nMore [Y]es,N)o,C)ont,A)bort?                              What sub-board,  L)ist\n, M)ain ([ENTER] quits)? jaycees\nChecking Users...\nMEMBER privileges granted in JAYCEES\nWelcome to JAYCEES Subboard\n                  Welcome to the Blue Ridge Express\n                          Sub-Board System\n  The purpose of this and all other Sub-Boards on the BRE is to share infor-\nmation. To do this means that there will be no \"private\" messages left on the\nsub-board. If you wish to leave a \"private\" message to another users, please\ndo it at the mail system level.\n  From any sub-board, you may return to the main system level by using either\nthe command of J M ( Join Main ) or simply M .\n                  Welcome to the Blue Ridge Express\n                          Sub-Board System\n  The purpose of this and all other Sub-Boards on the BRE is to share infor-\nmation. To do this means that there will be no \"private\" messages left on the\nsub-board. If you wish to leave a \"private\" message to another users, please\ndo it at the mail system level.\n  From any sub-board, you may return to the main system level by using either\nthe command of J M ( Join Main ) or simply M .\nChecking messages in JAYCEES.\nSorry Dick, but there is No Mail Found..\nRBBS-PC CPC17.3C with Modifications throught 01-01-95 Node 4\nActive Msgs: 20  Next Msg # 69\n                ------*>>>   BRE's Sub-Board Main Menu   <<<*------\n   ----- Mail ---------- System ---------- Utilities ------ Elsewhere ---\n    [E]nter Messages [I]nitial Welcome [H]elp (or ?)\n    [K]ill Messages                       [J]oin Sub-Board [GG]oodbye\n    [P]ersonal Mail                       [V]iew User Statu [Q]uit To\n    [R]ead Messages                       [X]pert on/off [U]tilitie    s\n    [S]can Messages [N]ew Sub-Board Mail                     [M]ain Exit To\n    [T]opic of Msgs * = unavailable\n   ----------------------------------------------------------------------\n      Current time:  7:51 PM  Minutes remaining: 68     Security: 60\n   ----------------------------------------------------------------------\nJAYCEES Subboard: 68 min left\nMAIN command <?,E,G,H,I,J,K,M,N,P,Q,R,S,T,U,V,X>? q\nQUIT S)ub-board, G)oodBye or to section FM]ain, U)tili? m\n                ------*>>>   BRE's Sub-Board Main Menu   <<<*------\n   ----- Mail ---------- System ---------- Utilities ------ Elsewhere ---\n    [E]nter Messages [I]nitial Welcome [H]elp (or ?)\n    [K]ill Messages                       [J]oin Sub-Board [GG]oodbye\n    [P]ersonal Mail                       [V]iew User Statu [Q]uit To\n    [R]ead Messages                       [X]pert on/off [U]tilitie    s\n    [S]can Messages [N]ew Sub-Board Mail                     [M]ain Exit To\n    [T]opic of Msgs * = unavailable\n   ----------------------------------------------------------------------\n      Current time:  7:52 PM  Minutes remaining: 67     Security: 60\n   ----------------------------------------------------------------------\nJAYCEES Subboard: 67 min left\nMAIN command <?,E,G,H,I,J,K,M,N,P,Q,R,S,T,U,V,X>? j dd\nChecking Users...\nMEMBER privileges granted in DD\nWelcome to DD Subboard\n                  Welcome to the Blue Ridge Express\n                          Sub-Board System\n  The purpose of this and all other Sub-Boards on the BRE is to share infor-\nmation. To do this means that there will be no \"private\" messages left on the\nsub-board. If you wish to leave a \"private\" message to another users, please\ndo it at the mail system level.\n  From any sub-board, you may return to the main system level by using either\nthe command of J M ( Join Main ) or simply M .\nPress any key to continue                                              Welcome t\no the Blue Ridge Express\n                          Sub-Board System\n  The purpose of this and all other Sub-Boards on the BRE is to share infor-\nmation. To do this means that there will be no \"private\" messages left on the\nsub-board. If you wish to leave a \"private\" message to another users, please\ndo it at the mail system level.\n  From any sub-board, you may return to the main system level by using either\nthe command of J M ( Join Main ) or simply M .\nChecking messages in DD.\nSorry Dick, but there is No Mail Found..\nRBBS-PC CPC17.3C with Modifications throught 01-01-95 Node 4\nActive Msgs: 59  Next Msg # 221\n               ------*>>>   Direct Data's  Main Menu   <<<*------\n   ----- Mail ------------ Files  --------- Utilities ------- Elsewhere --\n    [E]nter a Message [D]ownload a File [C]hange Graphics [G]oodbye\n     R S = Read Since  [L]ist files       [M]ain Return to [H]elp (or   ?)\n    [R]ead a Message [P]rotocol Change [II]nitial Screen [X] Expert    /Novice\n   ----------------------------------------------------------------------\n      Current time:  7:53 PM                            Security: 60\n   ----------------------------------------------------------------------\nDD Subboard: 66 min left\nYour command? r 221-\nDD Subboard Message Base\nMsg #:  188                       DD Subboard\n From:  DAVID WELLS               Sent: 09-06-94 05:13\n   To:  DOUG FORD                 Rcvd: 11-09-94 13:29\n   Re:  HARD DRIVES\nDoug,\n    Check out my pricing on the Dealer sub-board for one of\nthose drives. If you are looking for more, just leave me mail.\nMore [Y]es,N)o,C)ont,A)bort,H)lp,R)eply,T)hread,=,+,-?\n                              Msg #:  187                       DD Subboard\n From:  DAVID WELLS               Sent: 09-06-94 05:13\n   To:  DAVID BAILEY              Rcvd: 12-17-94 11:02\n   Re:  (R)MOTHERBOARD PRICES....\nDAvid,\n    Lemme check ou tthe new mb pricing and I'll get with ya...\nLeave me e-mail to your phone # and I'll call Wednesday\nMore [Y]es,N)o,C)ont,A)bort,H)lp,R)eply,T)hread,=,+,-?\n                              Msg #:  186                       DD Subboard\n From:  DAVID BAILEY              Sent: 09-05-94 22:05\n   To:  SYSOP                     Rcvd: 09-05-94 23:09\n   Re:  MOTHERBOARD PRICES.....\nDavid,\nI have dealt with you in the past (I bought my current system components\nfrom you), and I was wondering if you could tell me what the current\ngoing rate is for 486's (No Cyrix chips please...I prefer AMD, Intel,\nand possibly IBM). I am interested in the DX variety from 33-100Mhz. I\nwill be looking to replace my trusty old 386DX-40 sometime in the near\nfuture.\nThanks,\n--David\nMore [Y]es,N)o,C)ont,A)bort,H)lp,R)eply,T)hread,=,+,-?\n                              Msg #:  181                       DD Subboard\n From:  DAVID WELLS               Sent: 07-07-94 20:28\n   To:  ROBERT HOOPER             Rcvd: 07-08-94 09:55\n   Re:  (R)24 PIN PRINTER\nRobert\nI wil lget with you as soon as I get back for the weekend....\nLeave your message up here and I'll talk to you on Monday....\nMore [Y]es,N)o,C)ont,A)bort,H)lp,R)eply,T)hread,=,+,-?\n                              Msg #:  177                       DD Subboard\n From:  DAVID WELLS               Sent: 05-14-94 06:50\n   To:  ALL                       Rcvd: 01-14-95 10:24\n   Re:  428HD/CONTROLLER\nHeres a package deal for people new to IDE and want to upgrade\nfast and cheap...\nSeagate 428MB HD with VL-Bus IDE Controller\n              $339\n452-0810      748-0410\nMore [Y]es,N)o,C)ont,A)bort,H)lp,R)eply,T)hread,=,+,-?\n                              Msg #:  176                       DD Subboard\n From:  DAVID WELLS               Sent: 05-14-94 06:48\n   To:  ALL                       Rcvd: 01-14-95 10:24\n   Re:  .28 DOT PITCH MONITORS\nWhy strain your eyes?\n    That old Packard Bell monitor is pushing you toward\nbi-focals...\nGet a new Magitronic .28 dotpitch monitor (14\")\n    Interlaced......    $230\n    Non-Interlaced..    $250\nor go big\n    17\" Non-Interlaced (1280X1024 @60 Mhz)\n                        $710\nor in the middle\n    15\" Non-Interlaced  $365\nMore [Y]es,N)o,C)ont,A)bort?\nCall Direct Data at 452-0810 or 748-0410\nMore [Y]es,N)o,C)ont,A)bort,H)lp,R)eply,T)hread,=,+,-?\n                              Msg #:  175                       DD Subboard\n From:  DAVID WELLS               Sent: 05-14-94 06:39\n   To:  ALL                       Rcvd: 01-14-95 10:24\n   Re:  PENTIUM MBS\nWo would have thought prices would drop this fast?\n    Pentium 60 MB with integrated IDE/Flop/Ser/Parr\n              $1299\n    P5/66Mhz version    ..................$1499\n452-0810      748-0410\nMore [Y]es,N)o,C)ont,A)bort,H)lp,R)eply,T)hread,=,+,-?\n                              Msg #:  174                       DD Subboard\n From:  DAVID WELLS               Sent: 05-14-94 06:36\n   To:  ALL                       Rcvd: 01-14-95 10:24\n   Re:  28.8 MODEMS\nWe all know the day will be coming when 28.8 will be the\nstandard (It's quickly approaching)\nWell jump out on the cutting edge without having to pay cutting\nedge prices.....\nBoca 28.8 internal with 16c550 on board     $199\nExternal version of above\n    w/ free serial and 16c550 on it         $249\n14,400 internal is just                     $119\n14,400 w/ fax and voice mail                $159\nMore [Y]es,N)o,C)ont,A)bort,H)lp,R)eply,T)hread,=,+,-?\n                              Msg #:  173                       DD Subboard\n From:  DAVID WELLS               Sent: 05-14-94 06:30\n   To:  ALL                       Rcvd: 01-14-95 10:24\n   Re:  VIPER AND VIPER PCI\nGee wouldn't I love to drive around in a Viper, but what the\nheck, why not go for the next best thing....\nDiamond Tech's VIPER Video (VLB) w/ 2MB VRAM.....     $339\n              or\nGet the PCI version for a little more speed.....      $359\nJust call Direct Data at 452-0810 or 748-0410\nMore [Y]es,N)o,C)ont,A)bort,H)lp,R)eply,T)hread,=,+,-?\n                              Msg #:  172                       DD Subboard\n From:  DAVID WELLS               Sent: 05-14-94 06:27\n   To:  ALL                       Rcvd: 01-14-95 10:24\n   Re:  486SLC2-66 MOTHERBOARD\nEveryone advertises 'em so I thought I'd see what kind of deal\nI could get the BRE users on 'em.....\n IBM Opal 486SLC2-66 Motherboard ...   $269\n         add coprocessor               add  $30  just $299\nor go faster\n IBM Cobalt 75 Mhz Vesa board          $499\nCall Direct Data at 452-0810 or   748-0410\nMore [Y]es,N)o,C)ont,A)bort,H)lp,R)eply,T)hread,=,+,-? c\n                                Msg #:  3                         DD Subboard\n From:  DAVID WELLS               Sent: 11-14-93 09:08\n   To:  ALL                       Rcvd: 01-14-95 10:24\n   Re:  MOTHERBOARDS\nLooking to make an old 286 into a \"Windows Enhanced\" machine?\n386 Motherboard prices have feel off the cliff and they will\nprobably not be available soon.\n    386SX-40 Motherboard           $89\n    386DX-40 Motherboard          $119\nCall and ask about availability and current pricing......\n 452-0810          Direct Data         748-0410\nMsg #:  1                         DD Subboard\n From:  DAVID WELLS               Sent: 11-14-93 08:57\n   To:  ALL                       Rcvd: 01-14-95 10:24\n   Re:  WELCOME....\nWelcome to Direct Data's sub-board.......\nLooking for a computer part?\n         Don't want to risk buying at a show?\n                   Look no further.\nDirect Data carries a 1 year warranty on all components and will\nmeet or beat most prices seen in places such as shows or value\nPC magazines (i.e. Computer Shopper)\nGive us a try by just asking for a quote on something and then\nyou will see.\nDirect Data        452-0810       748-0410\n\"Mail order prices with local service\"\nMsg # 1-220 (H)elp,S)ince,L)ast, T)o,F)rom,M)ine, text, [Q]uit)? q\n               ------*>>>   Direct Data's  Main Menu   <<<*------\n   ----- Mail ------------ Files  --------- Utilities ------- Elsewhere --\n    [E]nter a Message [D]ownload a File [C]hange Graphics [G]oodbye\n     R S = Read Since  [L]ist files       [M]ain Return to [H]elp (or   ?)\n    [R]ead a Message [P]rotocol Change [II]nitial Screen [X] Expert    /Novice\n   ----------------------------------------------------------------------\n      Current time:  7:56 PM                            Security: 60\n   ----------------------------------------------------------------------\nDD Subboard: 63 min left\nYour command? m\nRejoining MAIN\nChecking Users...\nTimes on: 15  Last visit was on : 01-16-95 19:48\nChecking messages in MAIN....\nSorry Dick, but there is No NEW Mail Found..\nRBBS-PC CPC17.3C with Modifications throught 01-01-95 Node 4\nCaller # 1673744  Active Msgs: 183  Next Msg # 4563  Last Msg Read: 2703\n                  ------*>>>   BRE's Main Menu   <<<*------\n   ----- Mail ---------- System ---------- Utilities ------ Elsewhere ---\n                      [B]ulletins         [H]elp (or ?)      [F]iiles\n    [R]ead Mail       [C]omment to Sysop [J]oin Sub-Board [G]oodbye\n    [P]ersonal Mail [I]nitial Welcome [V]iew User Statu [Q]uit To\n                      [W]ho's on With You [X]pert on/off [U]tilitie    s\n                      [N]ew Sub-Board Mail\n                       * = unavailable\n   ----------------------------------------------------------------------\n      Current time:  7:57 PM  Minutes remaining: 63     Security: 60\n   ----------------------------------------------------------------------\nMAIN: 62 min left\nMAIN command <?,B,C,F,G,H,I,J,K,M,N,P,Q,R,U,V,W,X>? j sci-fi\nChecking Users...\nMEMBER privileges granted in SCI-FI\nWelcome to SCI-FI Subboard\n                  Welcome to the Blue Ridge Express\n                          Sub-Board System\n  The purpose of this and all other Sub-Boards on the BRE is to share infor-\nmation. To do this means that there will be no \"private\" messages left on the\nsub-board. If you wish to leave a \"private\" message to another users, please\ndo it at the mail system level.\n  From any sub-board, you may return to the main system level by using either\nthe command of J M ( Join Main ) or simply M .\nPress any key to continue                                              Welcome t\no the Blue Ridge Express\n                          Sub-Board System\n  The purpose of this and all other Sub-Boards on the BRE is to share infor-\nmation. To do this means that there will be no \"private\" messages left on the\nsub-board. If you wish to leave a \"private\" message to another users, please\ndo it at the mail system level.\n  From any sub-board, you may return to the main system level by using either\nthe command of J M ( Join Main ) or simply M .\nChecking messages in SCI-FI...\nSorry Dick, but there is No Mail Found..\nRBBS-PC CPC17.3C with Modifications throught 01-01-95 Node 4\nActive Msgs: 114  Next Msg # 243\n                ------*>>>   BRE's Sub-Board Main Menu   <<<*------\n   ----- Mail ---------- System ---------- Utilities ------ Elsewhere ---\n    [E]nter Messages [I]nitial Welcome [H]elp (or ?)\n    [K]ill Messages                       [J]oin Sub-Board [GG]oodbye\n    [P]ersonal Mail                       [V]iew User Statu [Q]uit To\n    [R]ead Messages                       [X]pert on/off [U]tilitie    s\n    [S]can Messages [N]ew Sub-Board Mail                     [M]ain Exit To\n    [T]opic of Msgs * = unavailable\n   ----------------------------------------------------------------------\n      Current time:  7:57 PM  Minutes remaining: 62     Security: 60\n   ----------------------------------------------------------------------\nSCI-FI Subboard: 62 min left\nMAIN command <?,E,G,H,I,J,K,M,N,P,Q,R,S,T,U,V,X>? r 243-\nSCI-FI Subboard Message Base\nMsg #:  242                       SCI-FI Subboard\n From:  LISHA MILLETT             Sent: 01-09-95 19:26\n   To:  BRIAN GEYER               Rcvd: -No-\n   Re:  (R)VOYAGER\nBrian, the first Voyager show will air on January 22, 1995 I'm not sure\nabout the time but I guess we can check our local listings\n                                                 -Lisha-\nMore [Y]es,N)o,C)ont,A)bort,H)lp,R)eply,T)hread,=,+,-? c\n                                Msg #:  241                       SCI-FI Subboar\nd\n From:  STEVE WISER               Sent: 01-06-95 11:33\n   To:  ALL                       Rcvd: 01-15-95 14:43\n   Re:  B5 INTERNET CONVERSATION\nHello All B5 Fans:\nOn the Internet is a group that is frequented by one of the\nexecutive producers and writers of the show.  Richmond Connection\n provides access to this group.  The initials of the guy is JMS.  Many\nquesitons are raised and answered by him this way.  Apparently over\n next few new shows many things are going to go up in smoke.  Also\napparenly a few of the shows characters will be turned upside down\nor inside out so to speak.  So don't miss them...\nSteve Wiser\nMsg #:  239                       SCI-FI Subboard\n From:  MICHAEL LEWIS             Sent: 01-05-95 17:31\n   To:  ALL                       Rcvd: 01-14-95 17:01\n   Re:  STARFLEET\nD/l the file SFLEET.ZIP.  It is a WP(5.1) file which contains\ninformation on two local Star Trek Fan Club, STARFLEET, chapters.\nMsg #:  238                       SCI-FI Subboard\n From:  BRIAN GEYER               Sent: 01-04-95 22:59\n   To:  ALL                       Rcvd: 01-14-95 17:01\n   Re:  VOYAGER\nHas anyone heard when the first \"Voyager\" will show in the Richmond\narea?  If you have let us know.\nMsg #:  237                       SCI-FI Subboard\n From:  BRIAN GEYER               Sent: 01-02-95 17:22\n   To:  ALL                       Rcvd: 01-14-95 17:01\n   Re:  METEOR SHOWER\nIs anyone going to watch the Meteor Shower tonight? Based on current\nweather conditions, the sky should be great for star gazing. Does anyone\nhave a guess as to the best hour(s) to watch for the event???\nBG...\nMsg #:  236                       SCI-FI Subboard\n From:  BRENT HIPPS               Sent: 12-30-94 16:39\n   To:  ALL                       Rcvd: 01-15-95 14:45\n   Re:  TIE DOE\nTIE Defender Of The Empire: Similar to B-wing it adds at least\nten NEW ships, rebel TIE and lots of civilian ships... AND\nif youve flown the TIE Advanced, have you seen the TIE Defender?\n4 lasers 2 ion cannons 220 RTU sheilds and 240 hull.. top speed\nof 250kbps and the advanced BEAM weapon.. Anyhow.. IT RULZ! BUT\nBUT in the DOE addon there is a new ship to counter the TIE\nDefender because some were stollen by Adm. Zarin... THE MISSLE\nBOAT... 80 Advanced Missles 1 laser 180 sheild 180 hull.. Top\nSpeed 180 BUT also has SLAM which transfers energy from the guns\nand boosts speed to over 320kbps!!!!!\nYES!!!!\nMsg #:  235                       SCI-FI Subboard\n From:  MARK H. JONES             Sent: 12-27-94 11:24\n   To:  DAN MCMULLIN              Rcvd: 12-29-94 08:41\n   Re:  (R)X-FILES\nDM>Personally, I haven't see any aliens lately (as far as I know).  But,\nDM>remember what Father Guido Sarducci said on an old segment of SNL's\nDM>Weekend Update.  He said that the aliens have this ray that they zap\nDM>you with that makes you forget that ever saw them.  So, if you've\nDM>never seen a UFO, you probably see them all the time.  Hard to argue\nDM>with logic like that.  Conspirators abound, especially out here in\nDM>Cyberspace, so be careful what you discuss, or the MIB will show up at\nDM>your door at three in the morning...\n.\nWell it seems to me that I haven't seen Guido in a long time... maybe\nthe aliens have abducted him for telling their secrets..\nLet the MIB come! As long as they don't send the Alien Retreival Team\nafter me....\nI hope they haven't found out about me...\nDid you catch Friday night's repeat? It's definitely my favorite episode\n(maybe with the exception of the vampire one. The girl who wanted to\nbecome a vampire is Duvonchy's real-life girlfriend. Nice, huh?)\nMsg #:  230                       SCI-FI Subboard\n From:  OZZY MANDIAS              Sent: 12-19-94 21:58\n   To:  GARY BRASWELL             Rcvd: -No-\n   Re:  (R)X-FILES\nThey did insinuate(sp?) an attraction. Fox did concurr that he thought\nScully was Hot.\nInteresting how now Scully seems to be more of a believer than fox!\nOzzy\nMsg #:  229                       SCI-FI Subboard\n From:  GARY BRASWELL             Sent: 12-19-94 01:00\n   To:  OZZY MANDIAS              Rcvd: 12-19-94 21:59\n   Re:  (R)X-FILES\nOM>X-Files is great! Well, at least last season. This year seems to\nOM>be a rehash of some stories from last year. Still, I its good.\nOM>\nYeah, this year has been a bit slow so far, but its still young.\nOM>Do you think Scully and Fox will ever get together?\nI don't know, probably not. They don't seem to be anything but friends,\nbut it would be interesting to see it happen once.<g>\nMsg #:  228                       SCI-FI Subboard\n From:  OZZY MANDIAS              Sent: 12-18-94 13:39\n   To:  ALL                       Rcvd: 01-11-95 21:33\n   Re:  B5\nI had heard the Paramount copied DS9 after B5. The story goes that\nBennett presented the B5 story to Paramount and the company said \"A\nstation that goes nowhere? Never work!\" So he took it to another\nproducer.\nWell a few months later, guess what? DS9 is born. Very strange.....\nAnyway, that's what I heard.\nOzzy\nMsg #:  227                       SCI-FI Subboard\n From:  OZZY MANDIAS              Sent: 12-18-94 13:36\n   To:  GARY BRASWELL             Rcvd: 12-19-94 01:00\n   Re:  (R)X-FILES\nX-Files is great! Well, at least last season. This year seems to\nbe a rehash of some stories from last year. Still, I its good.\nDo you think Scully and Fox will ever get together?\nOzzy\nMsg #:  226                       SCI-FI Subboard\n From:  BRENT HIPPS               Sent: 12-17-94 09:31\n   To:  ALL                       Rcvd: 01-11-95 21:33\n   Re:  B5\ni dont understand the hype about b5.. they never have any\nspacecombat... ST never had enuff but B5 has had about one shot\noutside of the station every time i ever saw it.. you are of\ncourse, entitled to your own opinion, but i think b5 is\npitiful.. although i dont think it much worse than DS9 cuz its\nalso horrrrrible...\nMsg #:  224                       SCI-FI Subboard\n From:  SAM LANTER                Sent: 12-14-94 17:23\n   To:  STEVE WISER               Rcvd: 12-15-94 06:33\n   Re:  I\nI am a fan\nof ST,ST-TNG and DS9, but right now B5 is blowing them out of the\nwater\nAs to Sheridan's wife, it does appear that she died out at the \"Rim\"\nwhere the Shadows are gathering.\nMsg #:  222                       SCI-FI Subboard\n From:  GARY BRASWELL             Sent: 12-13-94 16:06\n   To:  MIKE MAGEE                Rcvd: 12-14-94 12:25\n   Re:  (R)GENERATIONS\nMM>Come on now,\nMM>\nMM>    DS9 you have to admit has to be much better this season, than any\nMM>of the previous seasons. No it's not as good as ST-TNG, but you would\nMM>have to admit that the show is getting better. I just thought I would\nMM>put my 2 cents in, just in case you have blown the series off from\nMM>last season.\nI generally like DS9 better than TNG. The characters are not all well\nadjusted, politically correct and just plain namby-pamby nice as they\nare in TNG.\nMsg #:  221                       SCI-FI Subboard\n From:  GARY BRASWELL             Sent: 12-13-94 16:04\n   To:  SHELTON HARLOW            Rcvd: 12-17-94 21:15\n   Re:  (R)GODZILLA\nSH>    Sorry  for rambling on so, but in the end I am a true Godzilla and\nSH>BAD SF movie fan.  If you have a copy of \"Son of Godzilla\" (I want it\nSH>DESPERATELY!) let me know.  Otherwise, let's trade notes.\nSH>         Shelton\nEver see DESTROY ALL MONSTERS? I saw that in the theatre. It endeared\nJapanese monster movies to me.<g>\nMsg #:  220                       SCI-FI Subboard\n From:  JON HARDISON              Sent: 12-12-94 20:50\n   To:  BRENT HIPPS               Rcvd: 12-17-94 09:29\n   Re:  (R)TIE\nTell ya what. You give mine a try, I will give yours a try. (I'll\nprobably give it a try anyway.) I have not gotten any feedback about my\nTOD. It's here on the BRE as IMPBECN1.ZIP. Try it out. I used XMB302 so\nI could edit the briefing maps and it looks like LucasArts put it out\n(just because all the map symbols and labels are now there.) The file is\nnot actually new. I wrote and uploaded it here as IMPBECN.ZIP last may\nand I just now re-uploaded it with the improved briefing files. The\nstory line has to do with the Rebels discovering a technology that\nallows them to cloak Rebel ships as Imperial ships. The Empire also\nforms its own technology and soon you are up against your own type of\nstarfighters. One of the missions even has you up against a Calamari\nCruiser in an X-Wing. Mine has hex edited everything as well. The yellow\nscrolling text, the mission descriptions at the tour desk, and the green\nhistorical combat mission descriptions. Let me know what you think.\n                                 Jon\nMsg #:  219                       SCI-FI Subboard\n From:  BRENT HIPPS               Sent: 12-12-94 20:39\n   To:  JON HARDISON              Rcvd: 12-12-94 23:13\n   Re:  TIE\nWell im VERY familiar with XMB100.zip the original X-wing tour\neditor... i made a tour along time ago... the plot was that the\nrebels started to Capture Star Destroyers and use them against\nthe empire. the scrolling text at the begining of the tour and\nthe breifings were all done, some of which had to be done in\nHEX editing.. one of my favorite things... well you can Download\nREBEL.zip here on the BRE... the name wasnt very imaginitive but\nthats not too important... all the missions work, after creating\none i flew it to test it.. BTW these are ALL NEW none are just\n'fixed' versions of the original tour 1 like the NIP mobs set.\nAlso it replaces tour 1 and is reliant on the modified .doc's\nand .bat files from the heir to the empire set. its pretty\nneat.. someone try it and let me know... BTW it backs up your\nold .brf and .xwi and has an UN-install .bat\nhave Phun\n\u00e1\u00e2\u00ee\u00efT\nMsg #:  214                       SCI-FI Subboard\n From:  JON HARDISON              Sent: 12-06-94 18:28\n   To:  BRENT HIPPS               Rcvd: 12-12-94 20:39\n   Re:  (R)TIE\nBTW, to ammend my last message, there IS an editor which will allow you\nto fly any ship in any of the missions, but this is as far as they have\ncome. (I forget who wrote it but it wasn't Mr. Westfall) If you can FTP\nyou can find it at ftp.wpi.edu under the directory starwars/TIE_Fighter.\nThe filename is TME2.ZIP. If you don't know how to FTP, write me back.\nIf you don't have internet access or FTP access, I'll ask Webb to upload\nit here at the BRE.\n          Jon\nMsg #:  213                       SCI-FI Subboard\n From:  JON HARDISON              Sent: 12-06-94 18:22\n   To:  BRENT HIPPS               Rcvd: 12-12-94 20:40\n   Re:  (R)TIE\nBH>Was there ever a TIE editor that really edited the missions?\nNo, but I have been in touch with Neal Westfall, the creator of the\ngreat X-Wing editor, XMB, and he is in the midst of it right now. Since\nhe is still working, he can't give me a projected release date, but I\nwould guess it will be finished around March. If his TIE editor is as\ngood as his X-Wing editor, this will really be something to look forward\nto. In the meantime, if you haven't learned his X-Wing editor, download\nit and play with it a while. LucasArts fashioned the TIE missions in\nmuch the same way they did the X-Wing missions (I wouldn't be surprised\nif LucasArts used the same mission-construction code.) and things will\nbe a lot easier to understand when the TIE editor rolls around. I had a\ngreat time with his last XMB editor, XMB302.ZIP (here on the BRE) and I\ncreated a Tour of Duty for X-Wing which I just finished a couple of days\nago. It will be on the BRE soon as IMPBECN1.ZIP. Give it a try if you're\ninterested.\n      Waiting patiently,\n                 Jon\nMsg #:  212                       SCI-FI Subboard\n From:  BRENT HIPPS               Sent: 12-06-94 14:46\n   To:  ALL                       Rcvd: 01-11-95 21:34\n   Re:  TIE\nWas there ever a TIE editor that really edited the missions?\nMsg #:  209                       SCI-FI Subboard\n From:  BRENT HIPPS               Sent: 12-03-94 14:35\n   To:  ALL                       Rcvd: 01-11-95 21:34\n   Re:  DS9 2NITE\nThis will be one of the better DS9's... maybe even worth\nwatching to some sickies... its DS9's Naked Now, Naked Time,\nGet it? every star Trek has had one.. voyager will probably also\nhave one its tradition... im going to break from the usual and\nwatch it 2nite just to see if they screw it up.\nL8tr!\nMsg #:  208                       SCI-FI Subboard\n From:  BRENT HIPPS               Sent: 12-03-94 14:33\n   To:  ALL                       Rcvd: 01-11-95 21:34\n   Re:  NCC1701E\nWell the design specs for a NOVA class 1701-E are VERY OLD!\nthe idea came up a long time ago to replace the 1701-D.. the\nNOVA will be either used in the next movie, hopefully pushed up\nto 95, or will not appear OR if Were VERY LUCKY, Star Trek\nVoyager Will Be something like The USS Intrepid-A and be NOVA\nclass! that would be great... BTW the shapes and things i\ndescribed were from (the best looking) of 4 models which could\nhave been NOVA... starfleet just cant decide...\nLAter\nMsg #:  206                       SCI-FI Subboard\n From:  WALT GAY                  Sent: 12-02-94 23:09\n   To:  ALL                       Rcvd: 01-11-95 21:34\n   Re:  NCC1701E\nI think someone is jumping the gun on this. I'm sure they havn't given\na thought to a new Enterprise. The next movie is scheduled for 1996 for\ncats sake! As for \"Deep crud 9\" I'm not even going to watch this weeks\nfarce. Who writes this stuff?\nMsg #:  203                       SCI-FI Subboard\n From:  SHELTON HARLOW            Sent: 12-01-94 23:39\n   To:  BRANDEN BECK              Rcvd: 12-06-94 13:56\n   Re:  (R)GODZILLA\nBB>I have a little library of Godzilla tapes too.I only have three,but I\nBB>am aiming on collecting a lot more tapes.Personally,I don't like\nBB>Godzilla vs. The Smog Monster,my favorite is Godzilla vs.\nBB>Mechagodzilla.\n    G'zilla vs the S'Monster is only good because it's so BAD (I mean\nAWFUL, as in TERRIBLE, not as in 'boss' or 'fab')  It was a post-60's\nEnvironmentalist movie al a' Nippon (make you want to gag, eh!)  Enjoy\nthe flik for what it isn't...\n    shelton ]\nMsg #:  202                       SCI-FI Subboard\n From:  MARK H. JONES             Sent: 12-01-94 08:59\n   To:  ALL                       Rcvd: 01-11-95 21:35\n   Re:  X-FILES\nHello. I am an \"X-Files\" enthusiast interested in dialogue with others\nabout the show and related phenomena. Please,send me some mail here abn\nand we can discuss most anyhthing.\nMsg #:  201                       SCI-FI Subboard\n From:  BRANDEN BECK              Sent: 11-28-94 17:20\n   To:  SHELTON HARLOW            Rcvd: 12-01-94 23:39\n   Re:  (R)GODZILLA\nI have a little library of Godzilla tapes too.I only have three,but I\nam aiming on collecting a lot more tapes.Personally,I don't like\nGodzilla vs. The Smog Monster,my favorite is Godzilla vs. Mechagodzilla.\nMsg #:  200                       SCI-FI Subboard\n From:  BRENT HIPPS               Sent: 11-23-94 16:53\n   To:  ALL                       Rcvd: 01-11-95 21:35\n   Re:  1701-E NOT SQUARE\nIts NOT square exactly but the sides are flat and the edged are\nangles its still VERY round looking but its got more WAR looking\nfeatures to it. The Green torpedoes are Klingons.\nlater\nMsg #:  199                       SCI-FI Subboard\n From:  CLIFF ANDREWS             Sent: 11-23-94 16:31\n   To:  ALL                       Rcvd: 01-11-95 21:35\n   Re:  GENERATIONS\nHey yall, ok Finally saw it also. I thought it was a ok movie probley\non par with undiscovered country, but no match for Wrath of Kahn. WAs it\njust me or the Enterpise-E really ugly, was it E? I cant remember, I got\nall confused with the lettering, I saw somewhere where in undiscovered\nit was B. I dont know. Someone clear this up for me! Anyway, I think teh\nbest ship design inside and out was the enterpise ncc-1701, the one from\nstar trek II. Coooool. I agree that the enterprise was really dark on\nthe inside, it did look kinda wierd. A Green Photon Torpedo? Never seen\nthem before. Oh, yea, the special effects were really good. Ya know why?\nCause ILM did them. When the saucer section did its frisbe thing, some\nof the shots looked kinda goofy. Also, was I the only one who laughed\nwhen kirk was on the broken bridge near the end and it broke and he was\nstill hangin on it and it was flipping around!? That was crazy!\nMsg #:  198                       SCI-FI Subboard\n From:  CLIFF ANDREWS             Sent: 11-23-94 16:17\n   To:  BRENT HIPPS               Rcvd: 11-23-94 16:51\n   Re:  (R)NCC-1701-E\nBH>The Enterprise E is in the TEch BOok. its going to be an all new\nBH>design, with a squared off soucer section. and the warp naceles\nBH>are swept forward like a fighter jet. its a WAR machine and its\nBH>REAL FAST. it could blow up the 1701-d and C at the same time.\nBH>its gonna rule. Later!\nThe SAucer Is Gonna be square!? YUCK!\nMsg #:  197                       SCI-FI Subboard\n From:  JON HARDISON              Sent: 11-22-94 22:10\n   To:  ALL                       Rcvd: 01-11-95 21:36\n   Re:  GENERATIONS\nIs it just me or is no one else bothered about what they did to Data? I\nmean, this just destroyes the whole character, does it not? I'm not all\nthat knowledgeable about ST:TNG (I only started paying attention in the\nlast season) but I have seen enough to know that the whole driving force\nbehind this character is that he is trying to come to grips with human\nemotion. I think giving him an emotion chip really kills the whole idea.\nIt's too easy. If they are smart they will rip it out of his head for\nthe next movie and leave him with the memory of emotion so he can try to\nwork up from there like he was doing in ST:TNG. Just my $0.02. Otherwise\nthis is a great movie.\n               Jon\nMsg #:  196                       SCI-FI Subboard\n From:  SHELTON HARLOW            Sent: 11-22-94 20:56\n   To:  MICHAEL CONDON            Rcvd: 11-23-94 18:41\n   Re:  (R)GODZILLA\nMC>I Wish they made more. Im a godzey freek.\n    Well, they did actually...\"Godzilla 1985\" a truly dismal rehashing\nof Raymond Burr's role in the 1st movie.  In all the other \"Gojira's\"\n(the Japanese pron.) the Big Guy had some kind of (limited) personality\ndevelopment.  Heck, sometimes it was just downright Funny!  But in \"\n'85\" he was just a backdrop.\n   Shelton\nMsg #:  195                       SCI-FI Subboard\n From:  BRENT HIPPS               Sent: 11-22-94 19:45\n   To:  ALL                       Rcvd: 01-10-95 21:54\n   Re:  NCC-1701-E\nThe Enterprise E is in the TEch BOok. its going to be an all new\ndesign, with a squared off soucer section. and the warp naceles\nare swept forward like a fighter jet. its a WAR machine and its\nREAL FAST. it could blow up the 1701-d and C at the same time.\nits gonna rule. Later!\nMsg #:  193                       SCI-FI Subboard\n From:  MIKE MAGEE                Sent: 11-21-94 17:07\n   To:  WALT GAY                  Rcvd: 12-02-94 23:01\n   Re:  (R)GENERATIONS\nCome on now,\n    DS9 you have to admit has to be much better this season, than any of\nthe previous seasons. No it's not as good as ST-TNG, but you would have\nto admit that the show is getting better. I just thought I would put my\n2 cents in, just in case you have blown the series off from last season.\nMsg #:  192                       SCI-FI Subboard\n From:  WALT GAY                  Sent: 11-21-94 16:54\n   To:  BRENT HIPPS               Rcvd: 11-22-94 19:43\n   Re:  GENERATIONS\nI thought Gen. was great! The special affects were the best I've seen.\nWhere did you hear about the class of the new ship? They said that the\nstory line of the last episode was only one possible future for the\n1701D.\n After seeing the movie it reminds me how bad DS9 is, really a poor\nsubstitute for Star Trek!!!!\n\nMsg #:  1                         SCI-FI Subboard\n From:  JOHN CSOMAY               Sent: 07-30-94 15:18\n   To:  ALL                       Rcvd: 01-10-95 18:35\n   Re:  NEW BOARD\n\n\nIt looks as if this is the first message on the Sci-Fi Board! Good\nquality material so far. :>\n                                            John\n\n\nMsg # 1-242 (H)elp,S)ince,L)ast, T)o,F)rom,M)ine, text, [Q]uit)? q\n\n                ------*>>>   BRE's Sub-Board Main Menu   <<<*------\n   ----- Mail ---------- System ---------- Utilities ------ Elsewhere ---\n    [E]nter Messages [I]nitial Welcome [H]elp (or ?)\n    [K]ill Messages                       [J]oin Sub-Board [GG]oodbye\n    [P]ersonal Mail                       [V]iew User Statu [Q]uit To\n    [R]ead Messages                       [X]pert on/off [U]tilitie    s\n    [S]can Messages [N]ew Sub-Board Mail                     [M]ain Exit To\n    [T]opic of Msgs * = unavailable\n   ----------------------------------------------------------------------\n      Current time:  8:03 PM  Minutes remaining: 57     Security: 60\n   ----------------------------------------------------------------------\nSCI-FI Subboard: 57 min left\nMAIN command <?,E,G,H,I,J,K,M,N,P,Q,R,S,T,U,V,X>? j outdoor\nChecking Users...\nMEMBER privileges granted in OUTDOOR\nWelcome to OUTDOOR Subboard\n                  Welcome to the Blue Ridge Express\n                          Sub-Board System\n\n  The purpose of this and all other Sub-Boards on the BRE is to share infor-\nmation. To do this means that there will be no \"private\" messages left on the\nsub-board. If you wish to leave a \"private\" message to another users, please\ndo it at the mail system level.\n  From any sub-board, you may return to the main system level by using either\nthe command of J M ( Join Main ) or simply M .\n\nPress any key to continue                                    \u00ba This Sub-Board is\n for those users who share an interest \u00ba\n                  Welcome to the Blue Ridge Express\n                          Sub-Board System\n\n  The purpose of this and all other Sub-Boards on the BRE is to share infor-\nmation. To do this means that there will be no \"private\" messages left on the\nsub-board. If you wish to leave a \"private\" message to another users, please\ndo it at the mail system level.\n  From any sub-board, you may return to the main system level by using either\nthe command of J M ( Join Main ) or simply M .\n\nChecking messages in OUTDOOR.\nSorry Dick, but there is No Mail Found..\n\n\nRBBS-PC CPC17.3C with Modifications throught 01-01-95 Node 4\n\nActive Msgs: 41  Next Msg # 187\n\n                ------*>>>   BRE's Sub-Board Main Menu   <<<*------\n   ----- Mail ---------- System ---------- Utilities ------ Elsewhere ---\n    [E]nter Messages [I]nitial Welcome [H]elp (or ?)\n    [K]ill Messages                       [J]oin Sub-Board [GG]oodbye\n    [P]ersonal Mail                       [V]iew User Statu [Q]uit To\n    [R]ead Messages                       [X]pert on/off [U]tilitie    s\n    [S]can Messages [N]ew Sub-Board Mail                     [M]ain Exit To\n    [T]opic of Msgs * = unavailable\n   ----------------------------------------------------------------------\n      Current time:  8:03 PM  Minutes remaining: 56     Security: 60\n   ----------------------------------------------------------------------\nOUTDOOR Subboard: 56 min left\nMAIN command <?,E,G,H,I,J,K,M,N,P,Q,R,S,T,U,V,X>? r 187-\nOUTDOOR Subboard Message Base\n\nMsg #:  186                       OUTDOOR Subboard\n From:  ETHAN SELTZER             Sent: 01-15-95 17:43\n   To:  THOMAS WEST               Rcvd: 01-16-95 14:12\n   Re:  (R)JON BOAT\n\nTW>There is one in a yard for sale up the road from where I work. From\nTW>Seven Pines take Route 60 East to Route 156, right on 156 to the house\nTW>on the right just before the Blue VDOT sign. Boat should be in the\nTW>yard. This guy sell alot of junk but did not know about the price he\nTW>asks for the junk.\nThomas:\nAppreciate the reply. I'll look into it.\n\nEthan\n\nMore [Y]es,N)o,C)ont,A)bort,H)lp,R)eply,T)hread,=,+,-? c\n                                Msg #:  185                       OUTDOOR Subboa\nrd\n From:  THOMAS WEST               Sent: 01-15-95 13:53\n   To:  ETHAN SELTZER             Rcvd: 01-15-95 17:43\n   Re:  (R)JON BOAT\n\nES>Looking for a reasonably priced Jon Boat. Probably a 14foot with motor\nES>and trailer. If you have one or know of someone who is selling onw,\nES>leave me a message here or in E-Mail.\nES>Ethan\nThere is one in a yard for sale up the road from where I work. From\nSeven Pines take Route 60 East to Route 156, right on 156 to the house\non the right just before the Blue VDOT sign. Boat should be in the yard.\nThis guy sell alot of junk but did not know about the price he asks for\nthe junk.\n\nMsg #:  184                       OUTDOOR Subboard\n From:  ETHAN SELTZER             Sent: 01-14-95 14:15\n   To:  ALL                       Rcvd: 01-16-95 11:54\n   Re:  JON BOAT\n\nLooking for a reasonably priced Jon Boat. Probably a 14foot with motor\nand trailer. If you have one or know of someone who is selling onw,\nleave me a message here or in E-Mail.\nEthan\n\n\nMsg #:  1                         OUTDOOR Subboard\n From:  MARK SMILEY               Sent: 06-01-94 22:56\n   To:  ALL                       Rcvd: 12-10-94 15:59\n   Re:  OUTDOORS\n\nWell, I,m glad to see that this sub-board was finally created.  First\nI'd like to thank Webb for creating it for us to enjoy.  Second, summer\nis almost here and that means it's fishing season.  So is there anyone\nout there who enjoys fishing as much as I do.  Let's chat!  What's your\nfavorite place to go fishing and what for.  A lot of ideas can be\ndiscussed on this sub-board if there are real outdoorsmen who like to\ntalk to others and share their ideas too.  So if anyone out there knows\nof some good fishin' holes, share them.  Also how about hikers and\ncampers, please all of you share your thoughts with others and let's\nmake this sub-board one that people can truely enjoy.  Thank you all!\n\n                                             Mark \"Squirrel\" Smiley\n\nMsg # 1-186 (H)elp,S)ince,L)ast, T)o,F)rom,M)ine, text, [Q]uit)? q\n\n                ------*>>>   BRE's Sub-Board Main Menu   <<<*------\n   ----- Mail ---------- System ---------- Utilities ------ Elsewhere ---\n    [E]nter Messages [I]nitial Welcome [H]elp (or ?)\n    [K]ill Messages                       [J]oin Sub-Board [GG]oodbye\n    [P]ersonal Mail                       [V]iew User Statu [Q]uit To\n    [R]ead Messages                       [X]pert on/off [U]tilitie    s\n    [S]can Messages [N]ew Sub-Board Mail                     [M]ain Exit To\n    [T]opic of Msgs * = unavailable\n   ----------------------------------------------------------------------\n      Current time:  8:05 PM  Minutes remaining: 54     Security: 60\n   ----------------------------------------------------------------------\nOUTDOOR Subboard: 54 min left\nMAIN command <?,E,G,H,I,J,K,M,N,P,Q,R,S,T,U,V,X>? j jobmark\nChecking Users...\nMEMBER privileges granted in JOBMARK\nWelcome to JOBMARK Subboard\n                  Welcome to the Blue Ridge Express\n                          Sub-Board System\n\n  The purpose of this and all other Sub-Boards on the BRE is to share infor-\nmation. To do this means that there will be no \"private\" messages left on the\nsub-board. If you wish to leave a \"private\" message to another users, please\ndo it at the mail system level.\n  From any sub-board, you may return to the main system level by using either\nthe command of J M ( Join Main ) or simply M .\n\n                  Welcome to the Blue Ridge Express\n                          Sub-Board System\n\n  The purpose of this and all other Sub-Boards on the BRE is to share infor-\nmation. To do this means that there will be no \"private\" messages left on the\nsub-board. If you wish to leave a \"private\" message to another users, please\ndo it at the mail system level.\n  From any sub-board, you may return to the main system level by using either\nthe command of J M ( Join Main ) or simply M .\nPress any key to continue\nChecking messages in JOBMARK.\nSorry Dick, but there is No Mail Found..\n\n\nRBBS-PC CPC17.3C with Modifications throught 01-01-95 Node 4\n\nActive Msgs: 11  Next Msg # 35\n\n                ------*>>>   BRE's Sub-Board Main Menu   <<<*------\n   ----- Mail ---------- System ---------- Utilities ------ Elsewhere ---\n    [E]nter Messages [I]nitial Welcome [H]elp (or ?)\n    [K]ill Messages                       [J]oin Sub-Board [GG]oodbye\n    [P]ersonal Mail                       [V]iew User Statu [Q]uit To\n    [R]ead Messages                       [X]pert on/off [U]tilitie    s\n    [S]can Messages [N]ew Sub-Board Mail                     [M]ain Exit To\n    [T]opic of Msgs * = unavailable\n   ----------------------------------------------------------------------\n      Current time:  8:06 PM  Minutes remaining: 54     Security: 60\n   ----------------------------------------------------------------------\nJOBMARK Subboard: 54 min left\nMAIN command <?,E,G,H,I,J,K,M,N,P,Q,R,S,T,U,V,X>? r 35-\nJOBMARK Subboard Message Base\n\nMsg #:  34                        JOBMARK Subboard\n From:  BRUCE WOOD                Sent: 01-08-95 20:10\n   To:  ALL                       Rcvd: 01-15-95 17:18\n   Re:  WANT PROGRAMMER POSITION\n\nI have been looking for a programming position for about 8-10 months.\nExperienced with Progress(4GL) and have since finished classes on C and\nDBase III+. Education continuing at ECPI. Next is RPG or COBOL. Need\nentry/intermediate level position. Most familiar with DOS and some work\ndone with Unix. Any questions call (h)804-222-6306 or (w)804-730-4469.\n                              Bruce Wood\n\nMore [Y]es,N)o,C)ont,A)bort,H)lp,R)eply,T)hread,=,+,-? c\n                                Msg #:  33                        JOBMARK Subboa\nrd\n From:  VICKIE HERNDON            Sent: 12-18-94 21:54\n   To:  STEVE SEIDEN              Rcvd: -No-\n   Re:  (R)SALES OPENING\n\nHi Steve. You used to date my daughter, Kim Hartley.  Do you remember\nher?\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAKETST": {"ttr": 11013, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00L\\x00L\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 76, "newlines": 76, "modlines": 0, "user": "BC0THOR"}, "text": "/* maketst: Read a master test file containing questions and multiple */\n/* choice answers. Ask the user how many test questions for the output */\n/* and randomly select this number of questions from the master input */\n/* The first answer in the master is assumed to be the correct answer, */\n/* and is written as the 1st, 2nd, 3rd, or 4th answer. All questions begin*/\n/* with the question number followed by a right parenthesis. The four */\n/* answers follow, each beginning with A), B), C), or D). All lines must */\n/* end with CR/LF. An output report shows the source of the question, */\n/* and itscorrect answers, and its correct answer in the output test. */\n/* 1. Initialize */\n/* 2. Read in the Master Test File */\n/* 3. Ask user for number of output test questions */\n/* 4. Develop a random list of that many questions from the master test */\n/* 5. Write the output test file:\n/*    .Locate each selected question in the Master Test */\n/*    .Randomly decide which answer will be the correct one */\n/*    .Write the question to the output test */\n/*    .Write the answers to the output test */\n/*    .Save source and answer data for the answer sheet */\n/* 6. Write the answer sheet */\n#include <stdio.h>\n#include <dir.h>\n#include <alloc.h>\n\n#define MAX 100\n\nmain(int argc, char *argv[])\n{\n FILE *mastfile,*testfile;\n    struct ffblk dir_entry;\n int ch,i;\n long bytes=0;\n    char far *mastdata, far *curmast;\n    char far *outques[MAX]; /* an array of pointers to char */\n/* First, check the command line parameters for input and output file names */\n/* If not entered, show syntax and exit. If given, open both files, and */\n/* read the master file directory to get input file size. */\n if(argc!=3)\n  {\n  printf(\"\\nSYNTAX: maketst [d:][path]master[.ext] [d:][path]outtest[.ext]\");\n  exit();\n  }\n if((mastfile=fopen(argv[1],\"r\"))==NULL)\n  {\n  printf(\"\\nUnable to open master test file %s.\",argv[1]);\n  exit();\n  }\n if((testfile=fopen(argv[2],\"w\"))==NULL)\n  {\n  printf(\"\\nUnable to open output test file %s.\",argv[2]);\n  exit();\n  }\n i=findfirst(argv[1],&dir_entry,0);\n if(i != 0)\n {\n  printf(\"\\nUnable to read directory for master file %s.\",argv[1]);\n  exit();\n }\n/* Get storage for the master file and read it into memory. */\n    mastdata = (char far *)farmalloc(dir_entry.ff_fsize);\n if(mastdata == (char far *) NULL)\n {\n  printf(\"\\nUnable to get %ld bytes of storage to load %s\",dir_entry.ff_fsize,ar\ngv[2]);\n  exit();\n }\n curmast = mastdata;\n while((ch=getc(mastfile)) != EOF)\n {\n  *(curmast++)= ch;\n        bytes++;\n }\n printf(\"\\nLoaded %ld bytes into memory from %s.\",bytes,argv[1]);\n fclose(mastfile);\n fclose(testfile);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "MEASURE": {"ttr": 11016, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00:\\x00:\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 58, "newlines": 58, "modlines": 0, "user": "BC0THOR"}, "text": "/**************************************************************************/\n/* measures the time taken to perform a process a specified (count) number*/\n/* of times. total time required as well as single pass time are printed  */\n/**************************************************************************/\n#include <stdio.h>\n#include <sys\\timeb.h>\n\nmain() {\n  unsigned i;\n  unsigned count=1000;\n  FILE *fil,*thou;\n  struct timeb tmb;\n  long begin_secs;\n  short begin_msecs;\n  double tused, tcurr, tcurrs, tcurrm, tbgn;\n  char buffer[100];\n\n  if((thou = fopen(\"c:\\\\thousand.rcd\",\"rb\")) == NULL) {\n printf(\"\\nCan't open thousand.rcd file\");\n abort();\n  }\n\n  /**************************************************/\n  /* get time before entering timed area of program */\n  /**************************************************/\n  ftime(&tmb);\n  begin_secs = tmb.time;\n  begin_msecs = tmb.millitm;\n\n  /**************************************************/\n  /* following is the timed area of program         */\n  /**************************************************/\n  for(i=0;i<count;i++) {\n if((fil = fopen(\"c:\\\\autoexec.bat\",\"rb\")) == NULL) {\n   printf(\"\\nCan't open file\");\n   abort();\n }\n else {\n   fseek(thou,250L,SEEK_SET);\n   fread(buffer,80,1,thou);\n   fseek(thou,750L,SEEK_SET);\n   fread(buffer,80,1,thou);\n   fclose(fil);\n }\n  }\n\n  /**************************************************/\n  /* get time on exit from timed area of program    */\n  /**************************************************/\n  ftime(&tmb);\n\n  /* now use the ftime() values to report time */\n  tcurr = ((double)tmb.time * 1000.0) + (double)tmb.millitm;\n  tbgn = ((double)begin_secs * 1000.0) + (double)begin_msecs;\n  tused = (tcurr - tbgn) / 1000.0;\n  printf(\"\\nTotal ftime for %d loops = %f seconds\",count, tused);\n  printf(\"\\nOne loop ran for %f seconds\",tused /(double)count);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "MEMSIZE": {"ttr": 11018, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "BC0THOR"}, "text": "/* memsize.c */\n/* prints memory size */\n\n#include \"dos.h\"                  /* WORDREGS, BYTEREGS, REGS, etc. */\n#define MEM 0x12                  /* interrupt number for memory size */\n\nmain()\n{\n union REGS regs;                 /* regs to be type union REGS */\n unsigned int size;\n\n int86(MEM, &regs, &regs);         /* invoke BIOS memory size routine */\n size = regs.x.ax;                /* get memory size from register AX */\n printf(\"\\nMemory size is %d Kbytes.\",size);\n} /* end main */\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "MEMSIZE0": {"ttr": 11020, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00'\\x00'\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "BC0THOR"}, "text": "/* memsize0.c */\n/* prints memory size */\n\n#define MEM 0x12                    /* BIOS interrupt number */\n\nmain()\n{\n struct WORDREGS                    /* Registers as 16-bit words */\n {\n  unsigned int ax;\n  unsigned int bx;\n  unsigned int cx;\n  unsigned int dx;\n  unsigned int si;\n  unsigned int di;\n  unsigned int flags;\n }; /* end struct WORDREGS */\n\n struct BYTEREGS                   /* Registers as 8-bit bytes */\n {\n  unsigned int al, ah;\n  unsigned int bl, bh;\n  unsigned int cl, ch;\n  unsigned int dl, dh;\n }; /* end struct BYTEREGS */\n\n union REGS                        /* Registers as either bytes or words */\n {\n  struct WORDREGS x;\n  struct BYTEREGS h;\n }; /* end of union REGS */\n\n union REGS regs;\n unsigned int size;\n\n int86(MEM, &regs, &regs);          /* call memory size interrupt */\n size = regs.x.ax;                 /* get memory size from AX register */\n printf(\"\\nMemory size is %d Kbytes\",size);\n} /* end main */\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "MOFN": {"ttr": 11022, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x18\\x01\\x002\\x7f\\x01\\x02\\x12o\\x11\\x16\\x00-\\x00+\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2000-11-22T00:00:00", "modifydate": "2002-05-06T11:16:18", "lines": 45, "newlines": 43, "modlines": 0, "user": "BC0THOR"}, "text": "/**********/\n/* mofn.c */\n/*********************************************************************/\n/* Calculates all the possible combinations on N items taken M at a  */\n/* time and writes the resulting data to a file.                     */\n/*                                                                   */\n/* Author R Thornton November, 2000                                  */\n/*********************************************************************/\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#define N 16\n#define M 4\n/*********************************************************************/\n/* Global data areas                                                 */\n/*********************************************************************/\nint n[N] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};\nint m[M] = {1, 2, 3, 4};\nint i, j, k;                 /* work fields */\nFILE *output1;               /* output file pointer */\nstruct {\n  char digit[4][3];\n  char filler1[68];\n} record;\n/*********************************************************************/\n/* Function prototypes                                               */\n/*********************************************************************/\nint  main(void);             /* executive control routine */\n/*********************************************************************/\n/* executive control routine                                         */\n/*********************************************************************/\nint  main(void) {            /* executive control routine */\n  output1 = (fopen(\"dd:OUTPUT1\",\"wb,type=record,recfm=FB,lrecl=80\"));\n  if(output1 == NULL) {\n    perror(\"Error opening file OUTPUT1: \");\n    exit(8);\n  }\n  while(1) {\n    memset(&record,' ',80);         /* clear record to blanks */\n    for(i=0;i<4;i++)\n      sprintf(record.digit[i], \"%02d\", m[i]); /* digits to record */\n    fwrite(&record, 1, sizeof(record), output1); /* write record */\n    break;\n  }\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "MOFN2": {"ttr": 11024, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x06\\x00'\\x01\\x003/\\x01\\x02\\x12o\\x11\\x17\\x00\\x96\\x00\\x94\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@\"", "ispf": {"version": "01.06", "flags": 0, "createdate": "2000-11-27T00:00:00", "modifydate": "2002-05-06T11:17:27", "lines": 150, "newlines": 148, "modlines": 0, "user": "BC0THOR"}, "text": "/***********/\n/* mofn2.c */\n/*********************************************************************/\n/* Calculates all the possible combinations on N items taken M at a  */\n/* time and writes the resulting data to a file.                     */\n/*                                                                   */\n/* Author R Thornton November, 2000                                  */\n/*********************************************************************/\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#define N 16\n#define M 4\n/*********************************************************************/\n/* Global data areas                                                 */\n/*********************************************************************/\nchar n[N][2] = {{'0','1'}, {'0','2'}, {'0','3'}, {'0','4'}, {'0','5'},\n        {'0','6'}, {'0','7'}, {'0','8'}, {'0','9'}, {'1','0'},\n        {'1','1'}, {'1','2'}, {'1','3'}, {'1','4'}, {'1','5'},\n        {'1','6'}};\nchar m[M][2] = {{'0','1'}, {'0','2'}, {'0','3'}, {'0','4'}};\nFILE *output1;               /* output file pointer */\nstruct {\n  char digit[4][3];\n char filler1[3];\n} record;\nlong count = 0;               /* output record count */\nint more_combos = -1;         /* process switch */\n/*********************************************************************/\n/* Function prototypes                                               */\n/*********************************************************************/\nint  main(void);             /* executive control routine */\nvoid Initialize(void);       /* Initialize for porcessing */\nint  Locate_Msubi_In_N(int); /* locate m[i] in n */\nint  Locate_Next_Unused_In_N(int, int); /* find next unused in n */\nint  Check_Duplicate_In_M(int, int);    /* check for dup in m */\nvoid Write_Combination(void);  /* write combination to output file */\nvoid Terminate(void);        /* termination routine */\nvoid Develop_Next_Combination(void); /* build the next combination */\n/*********************************************************************/\n/* executive control routine                                         */\n/*********************************************************************/\nint  main(void) {            /* executive control routine */\n Initialize();              /* Initialize for processing */\n while(more_combos) {\n  Write_Combination();     /* go write combination in m[] to output */\n  Develop_Next_Combination(); /* go develop next combination */\n }\n Terminate();               /* terminate processing normally */\n return(0);\n}\n/*********************************************************************/\n/* Build the next combination in the m[] array;                      */\n/*********************************************************************/\nvoid Develop_Next_Combination(void) {\n int i, j, p;               /* work fields */\n i = M - 1;                       /* start at right end of combo */\n Locate_In_Full:\n  p = Locate_Msubi_In_N(i);      /* locate m[i] in n */\n Get_Next_Unused:\n  p = Locate_Next_Unused_In_N(i, p); /* locate next unused char in n */\n  if((p >= N) || (p < 0)) {\n    if(i == 0) {\n     more_combos = 0;             /* all thru, signal complete */\n     return;\n    }\n    else {\n     i--;\n     goto Locate_In_Full;\n    }\n  }\n  else {\n    memcpy(m[i], n[p],2);\n    i++;\n    p = -1;\n    if(i < M)\n     goto Get_Next_Unused;\n    else\n     return;\n }\n}\n/*********************************************************************/\n/* Terminate processing: write final output count and close file.    */\n/*********************************************************************/\nvoid Terminate(void) {\n printf(\"%ld combinations found.\\n\",count);\n fclose(output1);\n exit(0);\n}\n/*********************************************************************/\n/* Write the combination in the m[] array to the output file.        */\n/*********************************************************************/\nvoid Write_Combination(void) {\n int k;\n memset(&record,' ',sizeof(record));       /* clear record to blanks */\n for(k=0;k<4;k++)\n  memcpy(record.digit[k], m[k], 2); /* move digits to record */\n  record.filler1[0] = '\\r';\n  record.filler1[1] = '\\n';\n  record.filler1[2] = '\\x0';\n fwrite(&record, 1, sizeof(record), output1); /* write record */\n count++;                      /* count combinations */\n}\n/*********************************************************************/\n/*  Initialize for processing: Open output file.                     */\n/*********************************************************************/\nvoid Initialize(void) {\n output1 = (fopen(\"dd:OUTPUT1\",\"wb,type=record,recfm=FB,lrecl=15\"));\n if(output1 == NULL) {\n  perror(\"Error opening file OUTPUT1: \");\n  exit(8);\n }\n}\n/*********************************************************************/\n/* Locates the character at m[i] in n[] and returns its index value. */\n/*********************************************************************/\nint Locate_Msubi_In_N(int i) {\n int p;\n for(p=0; p<N; p++)\n  if(!memcmp(m[i], n[p], 2))\n   break;\n if((p >= N) || (p < 0)) {\n  printf(\"Error: couldn't find m[i] in n.\\n\");\n  exit(8);\n }\n return(p);\n}\n/*********************************************************************/\n/* search forward in n[] beginning with n[p] until a field is found  */\n/* that is not already used in m[]. If no field is found, p=N on     */\n/* return, else p contains the subscript to the field found.         */\n/*********************************************************************/\nint  Locate_Next_Unused_In_N(int i, int p) {\n int j;\n while(++p < N)\n  if(Check_Duplicate_In_M(i, p))    /* if n[p] has no dup in m[] */\n   return(p);                          /* return p to caller */\n return(N);                          /* when all n[p]'s are dups */\n}\n/*********************************************************************/\n/* Check current trial field at n[p] for a duplicate at any position */\n/* in m. If a duplicate is found, return 0, else non-zero.           */\n/*********************************************************************/\nint Check_Duplicate_In_M(int i, int p) {\n int j;\n for(j = i-1; j>=0; j--)               /* start scan at m[i-1] */\n  if((memcmp(m[j], n[p], 2) == 0))    /* if an equal is found */\n   return(0);                            /* return 0 */\n return(-1);                           /* return -1 if no equal found*/\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "MOVSTRU": {"ttr": 11265, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00&\\x01\\x02\\x11\\x9f\\x01\\x02\\x12o\\x11 \\x00#\\x00\\x1e\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-06T11:20:26", "lines": 35, "newlines": 30, "modlines": 0, "user": "BC0THOR"}, "text": "/*************/\n/* movstru.c */\n/***********************************************************/\n/* example showing definition of structures, moving data to*/\n/* fields within the structures, moving one structure to   */\n/* another, printing results.                              */\n/***********************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nmain() {\n struct manrec {\n   int manno;\n   int age;\n   char name[10];\n };\n struct manrec *p,*q,*r;\n\n p = (struct manrec *)malloc(5 * (sizeof(struct manrec)));\n q = p+1;\n r = q+1;\n p->manno = 1;\n p->age = 13;\n strcpy(p->name,\"paula\");\n q->manno = 2;\n q->age = 9;\n strcpy(q->name,\"willie\");\n printf(\"\\n(p): manno=%d, age=%d, name=%s\",p->manno, p->age, p->name);\n printf(\"\\n(q): manno=%d, age=%d, name=%s\",q->manno, q->age, q->name);\n *r = *p;\n printf(\"\\n(r): manno=%d, age=%d, name=%s\",r->manno, r->age, r->name);\n\n\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "MRECC": {"ttr": 11267, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x15\\x01\\x005?\\x01\\x01 \\x0f\\t\\x18\\x00\\x9c\\x01D\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2000-12-18T00:00:00", "modifydate": "2001-07-19T09:18:15", "lines": 156, "newlines": 324, "modlines": 0, "user": "BC0THOR"}, "text": "/*********************************************************************/\n/*                    Edge Product Record Description                */\n/*  Machine Friendly file - C language format record definition      */\n/*  based on the 05/06/1997 version                                  */\n/*********************************************************************/\nstruct {\n/*           *****>  csect-data  <*****                              */\nchar Member\u00dd8\u00a8;               /* member name */\nchar AddrMode;                /* addressing mode 2=24, 3=31, a=any   */\nchar ResidMode;               /* residence mode 2=24, 3=31, a=any    */\nchar Csect\u00dd8\u00a8;                /* csect name                          */\nchar Compiler\u00dd10\u00a8;            /* translator id, eg 5734-pl1          */\nchar CompilerVM\u00dd4\u00a8;           /* translator version/mod              */\nchar CompileDate\u00dd5\u00a8;          /* translation date yyddd              */\nchar CsectAmode;              /* csect amode 2=24, 3=31, a=any       */\nchar CsectRmode;              /* csect rmode 2=24, a=any             */\nchar CompType\u00dd2\u00a8;             /* compiler type. potential values:    */\n                              /*        ar = assembler               */\n                              /*        cc = CICS interface          */\n                              /*        ci = ibm c/370               */\n                              /*        cl = lattice c               */\n                              /*        cm = common block            */\n                              /*        cr = cobol runtime           */\n                              /*        cs = sas/c                   */\n                              /*        c2 = vs cobol ii             */\n                              /*        c3 = cobol 370               */\n                              /*        di = db2 interface           */\n                              /*        fg = fortran g / g1          */\n                              /*        fh = fortran h / h - extended*/\n                              /*        fr = fortran runtime         */\n                              /*        fv = vs fortran              */\n                              /*        ii = IMS interface           */\n                              /*        nr = not recognized          */\n                              /*        pm = PL/I for MVS and vm     */\n                              /*        pr = PL/I runtime            */\n                              /*        pv = vs pascal               */\n                              /*        p1 = PL/I optimizer v1       */\n                              /*        p2 = PL/I optimizer v2       */\n                              /*        ur = assembler - identified  */\n                              /*        vs = os/vs cobol             */\n                              /*        v4 = cobol version 4         */\n/*                     *****> extended base portion <*****           */\nchar TimeDate;                /*      1 = contains time svc pattern  */\n                              /*      2 = contains stck instruction  */\n                              /*      3 = contains both              */\n                              /*      4 = cobol accept from date...  */\n                              /*      9 = cobol accept ...other...   */\nchar LmodAttr;                /* load module attributes              */\nchar EPName\u00dd8\u00a8;               /* ext symbol at primary e.p. or mrmem */\nchar CsectSize\u00dd8\u00a8;            /* size of this csect in decimal       */\nchar LoadLib\u00dd4\u00a8;              /* data from /u parm                   */\nchar DateLinked\u00dd5\u00a8;           /* date of last linkedit of module     */\n/*    *****> start of third block of machine record <*****           */\n/*           *****> language dependent fields <*****                 */\n/*      *****> VS COBOL II and COBOL / 370 fields <*****             */\nchar C2Ver\u00dd6\u00a8;                /* vs cobol ii compiler version        */\nchar C2Lvl\u00dd4\u00a8;                /* vs cobol ii user lvl info           */\nchar C2Dat\u00dd8\u00a8;                /* date compiles mm/dd/yy              */\nchar filler1;                 /*                                     */\nchar C2Tim\u00dd8\u00a8;                /* time compiled hh:mm:ss              */\n/*        *****> COBOL II and COBOL 370 only fields <*****           */\nchar C2Adv;                   /* 0=noadv, 1=adv                      */\nchar C2Quot;                  /* 0=quote, 1=apost                    */\nchar C22431;                  /* 0=data24, 1=data31                  */\nchar C2Deck;                  /* 0=nodeck, 1=deck                    */\nchar C2Dump;                  /* 0=nodump, 1=dump                    */\nchar C2Dyna;                  /* 0=nodynam, 1=dynam                  */\nchar C2Fast;                  /* 0=nofastsrt, 1=fastsrt              */\nchar C2Fdum;                  /* 0=nofdump, 1=fdump                  */\nchar C2Lib;                   /* 0=nolib, 1=lib                      */\nchar C2List;                  /* 0=nolist, 1=list                    */\nchar C2Map;                   /* 0=nomap, 1=map                      */\nchar C2Num;                   /* 0=nonum, 1=num                      */\nchar C2Obj;                   /* 0=noobj, 1=obj                      */\nchar C2Offs;                  /* 0=nooffset, 1=offset                */\nchar C2Opt;                   /* 0=nooptimize, 1=optimiz             */\nchar C2Stdd;                  /* 0=nooutdd, 1=outdd                  */\nchar C2Pfd;                   /* rel 1-2: 0=nopfdsgn, 1=pfdsgn       */\n/*                            /* rel 3: 0=numnpfd, 1=numpfd, 2=nummig*/\nchar C2Rent;                  /* 0=norent, 1=rent                    */\nchar C2Res;                   /* 0=nores, 1=res                      */\nchar C2Seq;                   /* 0=noseq, 1=seq                      */\nchar C2Size;                  /* 0=size(n), 1=size(max)              */\nchar C2Sour;                  /* 0=nosource, 1=source                */\nchar C2Ssrn;                  /* 0=nossrange, 1=ssrange              */\nchar C2Term;                  /* 0=noterm, 1=term                    */\nchar C2Test;                  /* 0=notest, 1=test                    */\nchar C2Trun;                  /* rel 1-2: 0=notrunc, 1=trunc         */\n/*                            /* rel 3: 0=truncopt, 1=trunc(std),    */\n/*                            /* 2 = trunc(bin)                      */\nchar C2Rw;                    /* 0=default, 1=userspec word          */\nchar C2Vbre;                  /* 0=novbref, 1=vbref                  */\nchar C2Xref;                  /* 0=noxref, 1=xref                    */\nchar C2Zwb;                   /* 0=nozwb, 1=zwb                      */\n/*          *****> following are rel 3 + only <*****                 */\nchar C2Cmp2;                  /* 0=nocmpr2, 1=cmpr2                  */\nchar C2Name;                  /* 0=noname, 1=name                    */\nchar C2Nmcl;                  /* 0=nmclpri, 1=nmclalt                */\nchar C2Dbcs;                  /* 0=nodbcs, 1=dbcs                    */\nchar C2Awo;                   /* 0=noawo, 1=awo                      */\n/*   *****> the following fields apply only to COBOL/370 <*****      */\nchar C3Eve;                   /* 0=noevents, 1=events                */\nchar C3Cur;                   /* 0=nocurrency, 1=currency            */\nchar C3Rmod;                  /* 0=rmode24, 1=rmode(any)             */\nchar C3Rsv1;                  /* reserved                            */\nchar C3Rsv2;                  /* reserved                            */\nchar C3Rsv3;                  /* reserved                            */\nchar C3Rsv4;                  /* reserved                            */\n/* *****> following field applies to all supported COBOL's <*****    */\nchar CobSm;                   /* 0=no sort/merge found, 1=sort/merge */\nchar CobDc;                   /* cobol dynamic calls found switch:   */\n/*                            /* 0= no dynamic calls found in module */\n/*                      1= call literal forced dynamic found         */\n/*                      2= call dataname found                       */\n/*                      3= call literal forced + call dataname       */\n/*                      4= capex optimizer call adder really 5,6,7   */\n/*                      5= capex call literal forced dynamic found   */\n/*                      6= capex call dataname found                 */\n/*                      7= capex call literal forced + call dataname */\n/* *****> following fields relate to version 4 and OS/VS COBOL <**** */\nchar C4Symd;                  /* 0=nosymdmp, 1=symdmp                */\nchar C4Flow;                  /* 0=noflow, 1=flow                    */\nchar C4Stat;                  /* 0=nostate, 1=state                  */\nchar C4Test;                  /* 0=notest, 1=test                    */\nchar C4Res;                   /* 0=nores, 1=res                      */\nchar C4Endj;                  /* 0=noendjob, 1=endjob                */\nchar C4O370;                  /* 0=obj360, 1=obj370                  */\nchar C4Copt;                  /* 0=compiler not opt., 1=optimized    */\nchar C4Caop;                  /* 0=not capex opt., 1=capex optimized */\nchar C4Cdet;                  /* 0=no capex dtect, 1=capex dtect     */\n/*         *****> following are os/vs only options <*****            */\nchar C4Coun;                  /* 0=no count option, 1=count          */\nchar C4Trac;                  /* 0=no trace option, 1=trace option   */\nchar C4Llvl;                  /* 1=langlvl1, 2=langlvl2              */\nchar C4Syso;                  /* tail char of sysou display ddname   */\nchar C4Rsv1;                  /* reserved                            */\nchar C4Rsv2;                  /* reserved                            */\nchar C4Rsv3;                  /* reserved                            */\n/*             *****> PL/I options <*****                            */\nchar P2Main;                  /* 1=proc options(main), 0=not         */\nchar P2Orde;                  /* 0=noreorder, 1=reorder              */\nchar P2Exec;                  /* 0=noexecops, 1=execops              */\nchar P2Cmpa;                  /* 1=cmpat(v1), 2=cmpat(v2)            */\nchar P2Grap;                  /* 0=nographic, 1=graphic              */\nchar P2Opt;                   /* 0=nooptimize, 1=optimize            */\nchar P2Inte;                  /* 0=nointerupt, 1=interupt            */\nchar P2Flow;                  /* 0=noflow, 1=flow                    */\nchar P2Coun;                  /* 0=nocount, 1=count                  */\nchar P2Test;                  /* 0=notest, 1=test                    */\nchar P2Syst;                  /* 1=CMS, 2=CMSTP, 3=MVS, 4=TSO,       */\n                              /* 5=CICS, 6=IMS                       */\nchar P2Csty;                  /* csect type: 1=compiler generated    */\n                              /* runtime csect, 2=external data csect*/\n                              /* 3=static data csect, 4=code csect   */\nchar filler2\u00dd32\u00a8;             /* reserved                            */\n} ;                           /* end of machine friendly record      */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MSASMMOD": {"ttr": 11271, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x18\\x01\\x01 \\x7f\\x01\\x02\\x12o\\x11!\\x01H\\x01D\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2001-07-26T00:00:00", "modifydate": "2002-05-06T11:21:18", "lines": 328, "newlines": 324, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* msasmmod.c */\n/*********************************************************************/\n/* This program reads the file of EDGE machine friendly records      */\n/* and writes a reformatted version of records for the assembler     */\n/* csects likely to have been written in-house. All records for      */\n/* csects that can be identified as probable program product         */\n/* components, such as COBOL library subroutines, IMS and DB2        */\n/* utilities, etc, are dropped.                                      */\n/*                                                                   */\n/* The output file is sorted, then read by assembler language        */\n/* program MSASMRPT which produces the Assembler Csect Report.       */\n/* Author R Thornton July 2001                                       */\n/*********************************************************************/\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n/*********************************************************************/\n/* Global Data Areas                                                 */\n/*********************************************************************/\n/*********************************************************************/\n/*                    Edge Product Record Description                */\n/*  Machine Friendly file - C language format record definition      */\n/*  based on the 05/06/1997 version                                  */\n/*********************************************************************/\n/*********************************************************************/\n/*                    Edge Product Record Description                */\n/*  Machine Friendly file - C language format record definition      */\n/*  based on the 05/06/1997 version                                  */\n/*********************************************************************/\nstruct {\n/*           *****>  csect-data  <*****                              */\nchar Member[8];               /* member name */\nchar AddrMode;                /* addressing mode 2=24, 3=31, a=any   */\nchar ResidMode;               /* residence mode 2=24, 3=31, a=any    */\nchar Csect[8];                /* csect name                          */\nchar Compiler[10];            /* translator id, eg 5734-pl1          */\nchar CompilerVM[4];           /* translator version/mod              */\nchar CompileDate[5];          /* translation date yyddd              */\nchar CsectAmode;              /* csect amode 2=24, 3=31, a=any       */\nchar CsectRmode;              /* csect rmode 2=24, a=any             */\nchar CompType[2];             /* compiler type. potential values:    */\n                              /*        ar = assembler               */\n                              /*        cc = CICS interface          */\n                              /*        ci = ibm c/370               */\n                              /*        cl = lattice c               */\n                              /*        cm = common block            */\n                              /*        cr = cobol runtime           */\n                              /*        cs = sas/c                   */\n                              /*        c2 = vs cobol ii             */\n                              /*        c3 = cobol 370               */\n                              /*        di = db2 interface           */\n                              /*        fg = fortran g / g1          */\n                              /*        fh = fortran h / h - extended*/\n                              /*        fr = fortran runtime         */\n                              /*        fv = vs fortran              */\n                              /*        ii = IMS interface           */\n                              /*        nr = not recognized          */\n                              /*        pm = PL/I for MVS and vm     */\n                              /*        pr = PL/I runtime            */\n                              /*        pv = vs pascal               */\n                              /*        p1 = PL/I optimizer v1       */\n                              /*        p2 = PL/I optimizer v2       */\n                              /*        ur = assembler - identified  */\n                              /*        vs = os/vs cobol             */\n                              /*        v4 = cobol version 4         */\n/*                     *****> extended base portion <*****           */\nchar TimeDate;                /*      1 = contains time svc pattern  */\n                              /*      2 = contains stck instruction  */\n                              /*      3 = contains both              */\n                              /*      4 = cobol accept from date...  */\n                              /*      9 = cobol accept ...other...   */\nchar LmodAttr;                /* load module attributes              */\nchar EPName[8];               /* ext symbol at primary e.p. or mrmem */\nchar CsectSize[8];            /* size of this csect in decimal       */\nchar LoadLib[4];              /* data from /u parm                   */\nchar DateLinked[5];           /* date of last linkedit of module     */\n/*    *****> start of third block of machine record <*****           */\n/*           *****> language dependent fields <*****                 */\n/*      *****> VS COBOL II and COBOL / 370 fields <*****             */\nchar C2Ver[6];                /* vs cobol ii compiler version        */\nchar C2Lvl[4];                /* vs cobol ii user lvl info           */\nchar C2Dat[8];                /* date compiles mm/dd/yy              */\nchar filler1;                 /*                                     */\nchar C2Tim[8];                /* time compiled hh:mm:ss              */\n/*        *****> COBOL II and COBOL 370 only fields <*****           */\nchar C2Adv;                   /* 0=noadv, 1=adv                      */\nchar C2Quot;                  /* 0=quote, 1=apost                    */\nchar C22431;                  /* 0=data24, 1=data31                  */\nchar C2Deck;                  /* 0=nodeck, 1=deck                    */\nchar C2Dump;                  /* 0=nodump, 1=dump                    */\nchar C2Dyna;                  /* 0=nodynam, 1=dynam                  */\nchar C2Fast;                  /* 0=nofastsrt, 1=fastsrt              */\nchar C2Fdum;                  /* 0=nofdump, 1=fdump                  */\nchar C2Lib;                   /* 0=nolib, 1=lib                      */\nchar C2List;                  /* 0=nolist, 1=list                    */\nchar C2Map;                   /* 0=nomap, 1=map                      */\nchar C2Num;                   /* 0=nonum, 1=num                      */\nchar C2Obj;                   /* 0=noobj, 1=obj                      */\nchar C2Offs;                  /* 0=nooffset, 1=offset                */\nchar C2Opt;                   /* 0=nooptimize, 1=optimiz             */\nchar C2Stdd;                  /* 0=nooutdd, 1=outdd                  */\nchar C2Pfd;                   /* rel 1-2: 0=nopfdsgn, 1=pfdsgn       */\n/*                            /* rel 3: 0=numnpfd, 1=numpfd, 2=nummig*/\nchar C2Rent;                  /* 0=norent, 1=rent                    */\nchar C2Res;                   /* 0=nores, 1=res                      */\nchar C2Seq;                   /* 0=noseq, 1=seq                      */\nchar C2Size;                  /* 0=size(n), 1=size(max)              */\nchar C2Sour;                  /* 0=nosource, 1=source                */\nchar C2Ssrn;                  /* 0=nossrange, 1=ssrange              */\nchar C2Term;                  /* 0=noterm, 1=term                    */\nchar C2Test;                  /* 0=notest, 1=test                    */\nchar C2Trun;                  /* rel 1-2: 0=notrunc, 1=trunc         */\n/*                            /* rel 3: 0=truncopt, 1=trunc(std),    */\n/*                            /* 2 = trunc(bin)                      */\nchar C2Rw;                    /* 0=default, 1=userspec word          */\nchar C2Vbre;                  /* 0=novbref, 1=vbref                  */\nchar C2Xref;                  /* 0=noxref, 1=xref                    */\nchar C2Zwb;                   /* 0=nozwb, 1=zwb                      */\n/*          *****> following are rel 3 + only <*****                 */\nchar C2Cmp2;                  /* 0=nocmpr2, 1=cmpr2                  */\nchar C2Name;                  /* 0=noname, 1=name                    */\nchar C2Nmcl;                  /* 0=nmclpri, 1=nmclalt                */\nchar C2Dbcs;                  /* 0=nodbcs, 1=dbcs                    */\nchar C2Awo;                   /* 0=noawo, 1=awo                      */\n/*   *****> the following fields apply only to COBOL/370 <*****      */\nchar C3Eve;                   /* 0=noevents, 1=events                */\nchar C3Cur;                   /* 0=nocurrency, 1=currency            */\nchar C3Rmod;                  /* 0=rmode24, 1=rmode(any)             */\nchar C3Rsv1;                  /* reserved                            */\nchar C3Rsv2;                  /* reserved                            */\nchar C3Rsv3;                  /* reserved                            */\nchar C3Rsv4;                  /* reserved                            */\n/* *****> following field applies to all supported COBOL's <*****    */\nchar CobSm;                   /* 0=no sort/merge found, 1=sort/merge */\nchar CobDc;                   /* cobol dynamic calls found switch:   */\n/*                            /* 0= no dynamic calls found in module */\n/*                      1= call literal forced dynamic found         */\n/*                      2= call dataname found                       */\n/*                      3= call literal forced + call dataname       */\n/*                      4= capex optimizer call adder really 5,6,7   */\n/*                      5= capex call literal forced dynamic found   */\n/*                      6= capex call dataname found                 */\n/*                      7= capex call literal forced + call dataname */\n/* *****> following fields relate to version 4 and OS/VS COBOL <**** */\nchar C4Symd;                  /* 0=nosymdmp, 1=symdmp                */\nchar C4Flow;                  /* 0=noflow, 1=flow                    */\nchar C4Stat;                  /* 0=nostate, 1=state                  */\nchar C4Test;                  /* 0=notest, 1=test                    */\nchar C4Res;                   /* 0=nores, 1=res                      */\nchar C4Endj;                  /* 0=noendjob, 1=endjob                */\nchar C4O370;                  /* 0=obj360, 1=obj370                  */\nchar C4Copt;                  /* 0=compiler not opt., 1=optimized    */\nchar C4Caop;                  /* 0=not capex opt., 1=capex optimized */\nchar C4Cdet;                  /* 0=no capex dtect, 1=capex dtect     */\n/*         *****> following are os/vs only options <*****            */\nchar C4Coun;                  /* 0=no count option, 1=count          */\nchar C4Trac;                  /* 0=no trace option, 1=trace option   */\nchar C4Llvl;                  /* 1=langlvl1, 2=langlvl2              */\nchar C4Syso;                  /* tail char of sysou display ddname   */\nchar C4Rsv1;                  /* reserved                            */\nchar C4Rsv2;                  /* reserved                            */\nchar C4Rsv3;                  /* reserved                            */\n/*             *****> PL/I options <*****                            */\nchar P2Main;                  /* 1=proc options(main), 0=not         */\nchar P2Orde;                  /* 0=noreorder, 1=reorder              */\nchar P2Exec;                  /* 0=noexecops, 1=execops              */\nchar P2Cmpa;                  /* 1=cmpat(v1), 2=cmpat(v2)            */\nchar P2Grap;                  /* 0=nographic, 1=graphic              */\nchar P2Opt;                   /* 0=nooptimize, 1=optimize            */\nchar P2Inte;                  /* 0=nointerupt, 1=interupt            */\nchar P2Flow;                  /* 0=noflow, 1=flow                    */\nchar P2Coun;                  /* 0=nocount, 1=count                  */\nchar P2Test;                  /* 0=notest, 1=test                    */\nchar P2Syst;                  /* 1=CMS, 2=CMSTP, 3=MVS, 4=TSO,       */\n                              /* 5=CICS, 6=IMS                       */\nchar P2Csty;                  /* csect type: 1=compiler generated    */\n                              /* runtime csect, 2=external data csect*/\n                              /* 3=static data csect, 4=code csect   */\nchar filler2[32];             /* reserved                            */\n} mr;                         /* instance of machine friendly record */\n\nstruct {                      /* output record description           */\nchar Csect[8];                /* csect name                          */\nchar filler1;\nchar CompType[2];             /* Compiler type                       */\nchar filler2;\nchar CsectAmode;              /* Csect Amode                         */\nchar filler3;\nchar CsectRmode;              /* Csect Amode                         */\nchar filler4;\nchar CsectSize[8];            /* Csect size                          */\nchar filler5;\nchar CompileDate[5];          /* Date last compiled                  */\nchar filler6;\nchar Member[8];               /* member name                         */\nchar filler7;\nchar LoadLib[4];              /* load library abbreviation           */\nchar filler[36];              /*                                     */\n} out;                        /* instance of output record           */\n\nint InputRecords = 0;         /* Number input records                */\nint OutputRecords =0;         /* Number output records               */\nint MoreEdgeRecords = -1;     /* 0 = eof edge machine friendly file  */\nFILE *edgemr,*output1;        /* file pointers                       */\n/*********************************************************************/\n/* function prototypes                                               */\n/*********************************************************************/\nint main(void);                      /* executive control routine    */\nvoid Initialize(void);               /* initialization routine       */\nvoid Process(void);                  /* Processing routine           */\nvoid ReadEdgeMR(void);               /* reads the EDGEMR file        */\nvoid WriteOutput1(void);             /* writes the output1 file      */\nvoid Terminate(void);                /* termination routine          */\n/*********************************************************************/\n/* main() function: executive control                                */\n/*********************************************************************/\nint main(void) {\n  Initialize();                      /* initialize for Processing    */\n  while(MoreEdgeRecords)             /* until edgemr is exhausted,   */\n    Process();                       /*    Process records.          */\n  Terminate();                       /* Terminate Processing         */\n  return(0);\n}\n/*********************************************************************/\n/* Initialize(): initialization routine. opens files.                */\n/*********************************************************************/\nvoid Initialize(void) {\n  edgemr=fopen(\"dd:EDGEMR\",\"rb,type=record,recfm=fb,lrecl=200\");\n  if(edgemr == NULL) {\n    perror(\"\\ncan't open the EDGEMR file\");\n    exit(8);\n  }\n  output1=fopen(\"dd:OUTPUT1\",\"wb,type=record,recfm=fb,lrecl=80\");\n  if(output1 == NULL) {\n    perror(\"\\ncan't open the OUTPUT1 file\");\n    exit(8);\n  }\n  memset(&out, ' ', sizeof(out));\n}\n/********************************************************************/\n/* Process: for each record in the ELEMENTS file for an in-house    */\n/* assembler csect, format and write an output record.              */\n/********************************************************************/\nvoid Process(void) {\n  int totctr, good, i;\n  #define NUMCMPLRS 2\n  static char Compilers[NUMCMPLRS][3] = {\n     \"AR\", \"UR\"\n  };\n  #define NUMLIBS 3\n  static char Libraries[NUMLIBS][5] = {\n     \"EOLL\",\"IMS1\",\"KX01\"\n  };\n\n  ReadEdgeMR();                  /* Read next EDGEMR record         */\n  if(!MoreEdgeRecords) return;   /* Return if end of file           */\n  good = 0;                      /* reset good module flag          */\n  for(i=0; i < NUMCMPLRS; i++) /* test program type                 */\n    if(memcmp(mr.CompType, Compilers[i], 2) == 0) {\n      good = -1;\n      break;\n    }\n  if(!good) return;\n  good = 0;                      /* reset good module flag          */\n  for(i=0; i < NUMCMPLRS; i++) /* test containing library           */\n    if(memcmp(mr.LoadLib, Libraries[i], 4) == 0) {\n      good = -1;\n      break;\n    }\n  if(!good) return;\n  if(memcmp(mr.Csect, \"$PRIVATE\", 8) == 0) return; /* drop $PRIVATE */\n  memcpy(out.Member, mr.Member, 8); /* format output record...      */\n  memcpy(out.Csect, mr.Csect,8);\n  memcpy(out.LoadLib, mr.LoadLib, 4);\n  memcpy(out.CompType, mr.CompType, 2);\n  out.CsectAmode = mr.CsectAmode;\n  out.CsectRmode = mr.CsectRmode;\n  memcpy(out.CsectSize, mr.CsectSize, 8);\n  memcpy(out.CompileDate, mr.CompileDate, 5);\n  WriteOutput1();            /* write OutRec to output1 file        */\n}\n/********************************************************************/\n/* ReadEdgeMR() reads the next record from the EDGEMR file into     */\n/* the mr area. At end of file, the MoreEdgeRecords field is set    */\n/* to zero (false).                                                 */\n/********************************************************************/\nvoid ReadEdgeMR(void) {\n  size_t EdgeRecLen;\n\n  EdgeRecLen=fread(&mr, 1,  255, edgemr);\n  if(ferror(edgemr)) {\n    perror(\"\\nError (ferror) reading EDGEMr file\");\n    exit(8);\n  }\n  if(feof(edgemr)) {\n    MoreEdgeRecords = 0;\n    return;\n  }\n  if(EdgeRecLen == 0) {\n    perror(\"\\nError (0 read) reading EDGEMR file\");\n    exit(8);\n  }\n  InputRecords++;\n}\n/********************************************************************/\n/* WriteOutput1 writes the record in the OutRec area for the        */\n/* length given by the OutRecLen field to the OUTPUT1 file.         */\n/********************************************************************/\nvoid WriteOutput1(void) {\n  fwrite(&out, 1,  sizeof(out), output1);\n  if(ferror(output1)) {\n    perror(\"\\nError (ferror) writing OUTPUT1 file\");\n    exit(8);\n  }\n  OutputRecords++;\n  memset(&out, ' ', sizeof(out));\n}\n/********************************************************************/\n/* Terminate() closes the files and prepares for termination.       */\n/********************************************************************/\nvoid Terminate(void) {\n  printf(\"%d Input Records Read.\\n\",InputRecords);\n  printf(\"%d Output Records Written.\\n\",OutputRecords);\n  fclose(edgemr);\n  fclose(output1);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSMCHMOD": {"ttr": 11277, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00A\\x01\\x01 \\x0f\\x01\\x02\\x12o\\x11\"\\x01M\\x01J\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2001-07-19T00:00:00", "modifydate": "2002-05-06T11:22:41", "lines": 333, "newlines": 330, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* msmchmod.c */\n/*****************************************************************/\n/* This program reads the file of EDGE machine friendly records  */\n/* and writes a reformatted version of records for those csects  */\n/* likely to have been written in-house. All records for csects  */\n/* that can be identified as probable program product components,*/\n/* such as COBOL library subroutines, IMS and DB2 utilities, etc,*/\n/* are dropped.                                                  */\n/*                                                               */\n/* In addition, output records are created only for those records*/\n/* where the csect is the entry point for the member and the     */\n/* compiler is COBOL, Assembler, PL/I, C, or Pascal.             */\n/*                                                               */\n/* The output file is sorted, then read by assembler language    */\n/* program MSMCHRPT which produces the Mismatching Csect Report. */\n/*                                                               */\n/* Author R Thornton dec 2000                                    */\n/*****************************************************************/\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n/*****************************************************************/\n/* Global Data Areas                                             */\n/*****************************************************************/\n/*********************************************************************/\n/*                    Edge Product Record Description                */\n/*  Machine Friendly file - C language format record definition      */\n/*  based on the 05/06/1997 version                                  */\n/*********************************************************************/\n/*********************************************************************/\n/*                    Edge Product Record Description                */\n/*  Machine Friendly file - C language format record definition      */\n/*  based on the 05/06/1997 version                                  */\n/*********************************************************************/\nstruct {\n/*           *****>  csect-data  <*****                              */\nchar Member[8];               /* member name */\nchar AddrMode;                /* addressing mode 2=24, 3=31, a=any   */\nchar ResidMode;               /* residence mode 2=24, 3=31, a=any    */\nchar Csect[8];                /* csect name                          */\nchar Compiler[10];            /* translator id, eg 5734-pl1          */\nchar CompilerVM[4];           /* translator version/mod              */\nchar CompileDate[5];          /* translation date yyddd              */\nchar CsectAmode;              /* csect amode 2=24, 3=31, a=any       */\nchar CsectRmode;              /* csect rmode 2=24, a=any             */\nchar CompType[2];             /* compiler type. potential values:    */\n                              /*        ar = assembler               */\n                              /*        cc = CICS interface          */\n                              /*        ci = ibm c/370               */\n                              /*        cl = lattice c               */\n                              /*        cm = common block            */\n                              /*        cr = cobol runtime           */\n                              /*        cs = sas/c                   */\n                              /*        c2 = vs cobol ii             */\n                              /*        c3 = cobol 370               */\n                              /*        di = db2 interface           */\n                              /*        fg = fortran g / g1          */\n                              /*        fh = fortran h / h - extended*/\n                              /*        fr = fortran runtime         */\n                              /*        fv = vs fortran              */\n                              /*        ii = IMS interface           */\n                              /*        nr = not recognized          */\n                              /*        pm = PL/I for MVS and vm     */\n                              /*        pr = PL/I runtime            */\n                              /*        pv = vs pascal               */\n                              /*        p1 = PL/I optimizer v1       */\n                              /*        p2 = PL/I optimizer v2       */\n                              /*        ur = assembler - identified  */\n                              /*        vs = os/vs cobol             */\n                              /*        v4 = cobol version 4         */\n/*                     *****> extended base portion <*****           */\nchar TimeDate;                /*      1 = contains time svc pattern  */\n                              /*      2 = contains stck instruction  */\n                              /*      3 = contains both              */\n                              /*      4 = cobol accept from date...  */\n                              /*      9 = cobol accept ...other...   */\nchar LmodAttr;                /* load module attributes              */\nchar EPName[8];               /* ext symbol at primary e.p. or mrmem */\nchar CsectSize[8];            /* size of this csect in decimal       */\nchar LoadLib[4];              /* data from /u parm                   */\nchar DateLinked[5];           /* date of last linkedit of module     */\n/*    *****> start of third block of machine record <*****           */\n/*           *****> language dependent fields <*****                 */\n/*      *****> VS COBOL II and COBOL / 370 fields <*****             */\nchar C2Ver[6];                /* vs cobol ii compiler version        */\nchar C2Lvl[4];                /* vs cobol ii user lvl info           */\nchar C2Dat[8];                /* date compiles mm/dd/yy              */\nchar filler1;                 /*                                     */\nchar C2Tim[8];                /* time compiled hh:mm:ss              */\n/*        *****> COBOL II and COBOL 370 only fields <*****           */\nchar C2Adv;                   /* 0=noadv, 1=adv                      */\nchar C2Quot;                  /* 0=quote, 1=apost                    */\nchar C22431;                  /* 0=data24, 1=data31                  */\nchar C2Deck;                  /* 0=nodeck, 1=deck                    */\nchar C2Dump;                  /* 0=nodump, 1=dump                    */\nchar C2Dyna;                  /* 0=nodynam, 1=dynam                  */\nchar C2Fast;                  /* 0=nofastsrt, 1=fastsrt              */\nchar C2Fdum;                  /* 0=nofdump, 1=fdump                  */\nchar C2Lib;                   /* 0=nolib, 1=lib                      */\nchar C2List;                  /* 0=nolist, 1=list                    */\nchar C2Map;                   /* 0=nomap, 1=map                      */\nchar C2Num;                   /* 0=nonum, 1=num                      */\nchar C2Obj;                   /* 0=noobj, 1=obj                      */\nchar C2Offs;                  /* 0=nooffset, 1=offset                */\nchar C2Opt;                   /* 0=nooptimize, 1=optimiz             */\nchar C2Stdd;                  /* 0=nooutdd, 1=outdd                  */\nchar C2Pfd;                   /* rel 1-2: 0=nopfdsgn, 1=pfdsgn       */\n/*                            /* rel 3: 0=numnpfd, 1=numpfd, 2=nummig*/\nchar C2Rent;                  /* 0=norent, 1=rent                    */\nchar C2Res;                   /* 0=nores, 1=res                      */\nchar C2Seq;                   /* 0=noseq, 1=seq                      */\nchar C2Size;                  /* 0=size(n), 1=size(max)              */\nchar C2Sour;                  /* 0=nosource, 1=source                */\nchar C2Ssrn;                  /* 0=nossrange, 1=ssrange              */\nchar C2Term;                  /* 0=noterm, 1=term                    */\nchar C2Test;                  /* 0=notest, 1=test                    */\nchar C2Trun;                  /* rel 1-2: 0=notrunc, 1=trunc         */\n/*                            /* rel 3: 0=truncopt, 1=trunc(std),    */\n/*                            /* 2 = trunc(bin)                      */\nchar C2Rw;                    /* 0=default, 1=userspec word          */\nchar C2Vbre;                  /* 0=novbref, 1=vbref                  */\nchar C2Xref;                  /* 0=noxref, 1=xref                    */\nchar C2Zwb;                   /* 0=nozwb, 1=zwb                      */\n/*          *****> following are rel 3 + only <*****                 */\nchar C2Cmp2;                  /* 0=nocmpr2, 1=cmpr2                  */\nchar C2Name;                  /* 0=noname, 1=name                    */\nchar C2Nmcl;                  /* 0=nmclpri, 1=nmclalt                */\nchar C2Dbcs;                  /* 0=nodbcs, 1=dbcs                    */\nchar C2Awo;                   /* 0=noawo, 1=awo                      */\n/*   *****> the following fields apply only to COBOL/370 <*****      */\nchar C3Eve;                   /* 0=noevents, 1=events                */\nchar C3Cur;                   /* 0=nocurrency, 1=currency            */\nchar C3Rmod;                  /* 0=rmode24, 1=rmode(any)             */\nchar C3Rsv1;                  /* reserved                            */\nchar C3Rsv2;                  /* reserved                            */\nchar C3Rsv3;                  /* reserved                            */\nchar C3Rsv4;                  /* reserved                            */\n/* *****> following field applies to all supported COBOL's <*****    */\nchar CobSm;                   /* 0=no sort/merge found, 1=sort/merge */\nchar CobDc;                   /* cobol dynamic calls found switch:   */\n/*                            /* 0= no dynamic calls found in module */\n/*                      1= call literal forced dynamic found         */\n/*                      2= call dataname found                       */\n/*                      3= call literal forced + call dataname       */\n/*                      4= capex optimizer call adder really 5,6,7   */\n/*                      5= capex call literal forced dynamic found   */\n/*                      6= capex call dataname found                 */\n/*                      7= capex call literal forced + call dataname */\n/* *****> following fields relate to version 4 and OS/VS COBOL <**** */\nchar C4Symd;                  /* 0=nosymdmp, 1=symdmp                */\nchar C4Flow;                  /* 0=noflow, 1=flow                    */\nchar C4Stat;                  /* 0=nostate, 1=state                  */\nchar C4Test;                  /* 0=notest, 1=test                    */\nchar C4Res;                   /* 0=nores, 1=res                      */\nchar C4Endj;                  /* 0=noendjob, 1=endjob                */\nchar C4O370;                  /* 0=obj360, 1=obj370                  */\nchar C4Copt;                  /* 0=compiler not opt., 1=optimized    */\nchar C4Caop;                  /* 0=not capex opt., 1=capex optimized */\nchar C4Cdet;                  /* 0=no capex dtect, 1=capex dtect     */\n/*         *****> following are os/vs only options <*****            */\nchar C4Coun;                  /* 0=no count option, 1=count          */\nchar C4Trac;                  /* 0=no trace option, 1=trace option   */\nchar C4Llvl;                  /* 1=langlvl1, 2=langlvl2              */\nchar C4Syso;                  /* tail char of sysou display ddname   */\nchar C4Rsv1;                  /* reserved                            */\nchar C4Rsv2;                  /* reserved                            */\nchar C4Rsv3;                  /* reserved                            */\n/*             *****> PL/I options <*****                            */\nchar P2Main;                  /* 1=proc options(main), 0=not         */\nchar P2Orde;                  /* 0=noreorder, 1=reorder              */\nchar P2Exec;                  /* 0=noexecops, 1=execops              */\nchar P2Cmpa;                  /* 1=cmpat(v1), 2=cmpat(v2)            */\nchar P2Grap;                  /* 0=nographic, 1=graphic              */\nchar P2Opt;                   /* 0=nooptimize, 1=optimize            */\nchar P2Inte;                  /* 0=nointerupt, 1=interupt            */\nchar P2Flow;                  /* 0=noflow, 1=flow                    */\nchar P2Coun;                  /* 0=nocount, 1=count                  */\nchar P2Test;                  /* 0=notest, 1=test                    */\nchar P2Syst;                  /* 1=CMS, 2=CMSTP, 3=MVS, 4=TSO,       */\n                              /* 5=CICS, 6=IMS                       */\nchar P2Csty;                  /* csect type: 1=compiler generated    */\n                              /* runtime csect, 2=external data csect*/\n                              /* 3=static data csect, 4=code csect   */\nchar filler2[32];             /* reserved                            */\n} mr;                         /* instance of machine friendly record */\n\nstruct {                      /* output record description           */\nchar Csect[8];                /* csect name                          */\nchar filler1;\nchar CompType[2];             /* Compiler type                       */\nchar filler2;\nchar CsectAmode;              /* Csect Amode                         */\nchar filler3;\nchar CsectRmode;              /* Csect Amode                         */\nchar filler4;\nchar CsectSize[8];            /* Csect size                          */\nchar filler5;\nchar CompileDate[5];          /* Date last compiled                  */\nchar filler6;\nchar Member[8];               /* member name                         */\nchar filler7;\nchar LoadLib[4];              /* load library abbreviation           */\nchar filler[36];              /*                                     */\n} out;                        /* instance of output record           */\n\nint InputRecords = 0;         /* Number input records                */\nint OutputRecords =0;         /* Number output records               */\nint MoreEdgeRecords = -1;     /* 0 = eof edge machine friendly file  */\nFILE *edgemr,*output1;        /* file pointers                    */\n/*****************************************************************/\n/* function prototypes                                           */\n/*****************************************************************/\nint main(void);                      /* executive control routine */\nvoid Initialize(void);               /* initialization routine */\nvoid Process(void);                  /* Processing routine */\nvoid ReadEdgeMR(void);               /* reads the EDGEMR file */\nvoid WriteOutput1(void);             /* writes the output1 file */\nvoid Terminate(void);                /* termination routine */\n/*****************************************************************/\n/* main() function: executive control                            */\n/*****************************************************************/\nint main(void) {\n  Initialize();                      /* initialize for Processing */\n  while(MoreEdgeRecords)             /* until edgemr is exhausted, */\n    Process();                       /*    Process records. */\n  Terminate();                       /* Terminate Processing */\n  return(0);\n}\n/*****************************************************************/\n/* Initialize(): initialization routine. opens files.            */\n/*****************************************************************/\nvoid Initialize(void) {\n  edgemr=fopen(\"dd:EDGEMR\",\"rb,type=record,recfm=fb,lrecl=200\");\n  if(edgemr == NULL) {\n    perror(\"\\ncan't open the EDGEMR file\");\n    exit(8);\n  }\n  output1=fopen(\"dd:OUTPUT1\",\"wb,type=record,recfm=fb,lrecl=80\");\n  if(output1 == NULL) {\n    perror(\"\\ncan't open the OUTPUT1 file\");\n    exit(8);\n  }\n  memset(&out, ' ', sizeof(out));\n}\n/*****************************************************************/\n/* Process: for each record in the ELEMENTS file for an in-house */\n/* module, format and write an output record.                    */\n/*****************************************************************/\nvoid Process(void) {\n  int totctr, good, i;\n  #define NUMCMPLRS 6\n  static char Compilers[NUMCMPLRS][3] = {\n     \"C2\",\"VS\",\"AR\",\"C3\",\"UR\",\"V4\"\n  };\n  #define NUMLIBS 3\n  static char Libraries[NUMLIBS][5] = {\n     \"EOLL\",\"IMS1\",\"KX01\"\n  };\n\n  ReadEdgeMR();                  /* Read next EDGEMR record */\n  if(!MoreEdgeRecords) return;   /* Return if end of file */\n  good = 0;                      /* reset good module flag */\n  for(i=0; i < NUMCMPLRS; i++) /* test program type */\n    if(memcmp(mr.CompType, Compilers[i], 2) == 0) {\n      good = -1;\n      break;\n    }\n  if(!good) return;\n  good = 0;                      /* reset good module flag */\n  for(i=0; i < NUMCMPLRS; i++) /* test containing library */\n    if(memcmp(mr.LoadLib, Libraries[i], 4) == 0) {\n      good = -1;\n      break;\n    }\n  if(!good) return;\n  if(memcmp(mr.Csect, \"$PRIVATE\", 8) == 0) return; /* drop $PRIVATE */\n  memcpy(out.Member, mr.Member, 8); /* format output record... */\n  memcpy(out.Csect, mr.Csect,8);\n  memcpy(out.LoadLib, mr.LoadLib, 4);\n  memcpy(out.CompType, mr.CompType, 2);\n  out.CsectAmode = mr.CsectAmode;\n  out.CsectRmode = mr.CsectRmode;\n  memcpy(out.CsectSize, mr.CsectSize, 8);\n  memcpy(out.CompileDate, mr.CompileDate, 5);\n  WriteOutput1();            /* write OutRec to output1 file */\n}\n/*****************************************************************/\n/* ReadEdgeMR() reads the next record from the EDGEMR file into  */\n/* the mr area. At end of file, the MoreEdgeRecords field is set */\n/* to zero (false).                                              */\n/*****************************************************************/\nvoid ReadEdgeMR(void) {\n  size_t EdgeRecLen;\n\n  EdgeRecLen=fread(&mr, 1,  255, edgemr);\n  if(ferror(edgemr)) {\n    perror(\"\\nError (ferror) reading EDGEMr file\");\n    exit(8);\n  }\n  if(feof(edgemr)) {\n    MoreEdgeRecords = 0;\n    return;\n  }\n  if(EdgeRecLen == 0) {\n    perror(\"\\nError (0 read) reading EDGEMR file\");\n    exit(8);\n  }\n  InputRecords++;\n}\n/*****************************************************************/\n/* WriteOutput1 writes the record in the OutRec area for the     */\n/* length given by the OutRecLen field to the OUTPUT1 file.      */\n/*****************************************************************/\nvoid WriteOutput1(void) {\n  fwrite(&out, 1,  sizeof(out), output1);\n  if(ferror(output1)) {\n    perror(\"\\nError (ferror) writing OUTPUT1 file\");\n    exit(8);\n  }\n  OutputRecords++;\n  memset(&out, ' ', sizeof(out));\n}\n/*****************************************************************/\n/* Terminate() closes the files and prepares for termination.    */\n/*****************************************************************/\nvoid Terminate(void) {\n  printf(\"%d Input Records Read.\\n\",InputRecords);\n  printf(\"%d Output Records Written.\\n\",OutputRecords);\n  fclose(edgemr);\n  fclose(output1);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVSTRUC": {"ttr": 11526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00U\\x01\\x02\\x11\\x9f\\x01\\x02\\x12o\\x11%\\x00 \\x00\\x1a\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-06T11:25:55", "lines": 32, "newlines": 26, "modlines": 0, "user": "BC0THOR"}, "text": "/*************/\n/* mvstruc.c */\n/****************************************************/\n/* sample showing structure operations              */\n/****************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n  struct aaa {\n char str1;\n char str2[5];\n char str3[5];\n char null;\n  } stru1;\n\n  struct bbb {\n char str4;\n char str5[5];\n char str6[5];\n char null;\n  } stru2;\n\n  stru1.str1 = 'A';\n  strcpy(stru1.str2,\"FOUR\");\n  strcpy(stru1.str3,\"FIVE\");\n  stru1.null = '\\0';\n  printf(\"\\n%c %s %s\",stru1.str1,stru1.str2,stru1.str3);\n  memcpy(&stru2,&stru1,sizeof(stru2));\n  printf(\"\\n%c %s %s\",stru2.str4,stru2.str5,stru2.str6);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "NETPAY": {"ttr": 11528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00I\\x01\\x02\\x11\\x9f\\x01\\x02\\x12o\\x11'\\x00N\\x00J\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-06T11:27:49", "lines": 78, "newlines": 74, "modlines": 0, "user": "BC0THOR"}, "text": "/************/\n/* netpay.c */\n/***************************************************/\n/* compute and print net pay gusing hard-coded     */\n/* values for salary, deductions.                  */\n/***************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid main(int argc, char *argv[]) {\n double salary = 30000.00;\n float fed_std_ded = 6050.00;   /* head of household */\n float nbr_exemptions = 3;\n float fed_exemption_each = 2650.00;\n float va_std_ded = 3000.00;    /* single */\n float va_exemption_each = 800.00;\n float socsec_medicare_pct = .078;  /*7.8% social security + medicare*/\n float fed_taxable_income, va_taxable_income;\n float fed_exemption_amount, va_exemption_amount;\n float fed_income_tax, va_income_tax, socsec_medicare_amount, net_pay;\n\n if (argc != 2) {\n  printf(\"\\n Program requires salary parameter only. Argc = %i\", argc);\n  exit(0);\n }\n salary = atof(argv[1]);\n fed_exemption_amount = nbr_exemptions * fed_exemption_each;\n fed_taxable_income = salary - fed_std_ded - fed_exemption_amount;\n if (fed_taxable_income < 33050.00f)\n  fed_income_tax = 0.15f * fed_taxable_income;\n else\n  if (fed_taxable_income < 85350.00f)\n   fed_income_tax = 4957.50f +\n    (0.28f * (fed_taxable_income - 33050.00f));\n  else\n   if (fed_taxable_income < 138200.00f)\n    fed_income_tax = 19601.50f +\n     (0.31f * (fed_taxable_income - 85350.00f));\n   else\n    fed_income_tax = 35985.00f +\n     (0.36f * (fed_taxable_income - 138200.00f));\n va_exemption_amount = nbr_exemptions * va_exemption_each;\n va_taxable_income = salary - va_std_ded - va_exemption_amount;\n if (va_taxable_income < 3000.00f)\n  va_income_tax = 0.00f;\n else\n  if (va_taxable_income < 5000.00f)\n   va_income_tax = 60.00f + (0.03f * (va_taxable_income - 3000.00f));\n  else\n   if (va_taxable_income < 17000.00f)\n    va_income_tax = 120.00f +\n     (0.05f * (va_taxable_income - 5000.00f));\n   else\n    va_income_tax = 720.00f +\n     (0.0575f * (va_taxable_income - 17000.00f));\n socsec_medicare_amount = socsec_medicare_pct * salary;\n net_pay = salary - fed_income_tax - va_income_tax -\n           socsec_medicare_amount;\n\n printf(\"\\n\\n\");\n printf(\"\\nSalary =                   %10.2f\", salary);\n printf(\"\\n   Number Exemptions =     %10.2f\", nbr_exemptions);\n printf(\"\\n   Fed Std HofH Ded =      %10.2f\", fed_std_ded);\n printf(\"\\n   Fed Exemption Each =    %10.2f\", fed_exemption_each);\n printf(\"\\n   Fed Exemption Amt =     %10.2f\", fed_exemption_amount);\n printf(\"\\n   Fed Taxable Income =    %10.2f\", fed_taxable_income);\n printf(\"\\n   Fed Income Tax =        %10.2f\", fed_income_tax);\n printf(\"\\n   Va Std Single Ded =     %10.2f\", va_std_ded);\n printf(\"\\n   Va Exemption Each =     %10.2f\", va_exemption_each);\n printf(\"\\n   Va Exemption Amount =   %10.2f\", va_exemption_amount);\n printf(\"\\n   Va Taxable Income =     %10.2f\", va_taxable_income);\n printf(\"\\n   Va Income Tax =         %10.2f\", va_income_tax);\n printf(\"\\n   SocSec + Medicare Pct = %10.4f\", socsec_medicare_pct);\n printf(\"\\n   SocSec + Medicare =     %10.2f\", socsec_medicare_amount);\n printf(\"\\n   Net Pay =               %10.2f\", net_pay);\n printf(\"\\n\\n\");\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "NOTRLBK": {"ttr": 11531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00(\\x01\\x02\\x11\\x9f\\x01\\x02\\x12o\\x116\\x007\\x00<\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-06T11:36:28", "lines": 55, "newlines": 60, "modlines": 0, "user": "BC0THOR"}, "text": "/*************/\n/* notrlbk.c */\n/*******************************************************/\n/* copy text file dropping trailing blanks in all lines*/\n/*******************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint  main(int argc, char *argv[]) {\n  FILE *infile, *outfile;\n  char innam[81],outnam[81];\n  int ch, nbr_blanks;\n  if(argc == 3) {\n    strcpy(innam,argv[1]);\n    strcpy(outnam,argv[2]);\n  }\n  else {\n    printf(\"\\nEnter input file spec: \");\n    scanf(\"%s\",innam);\n    printf(\"\\nEnter output file spec: \");\n    scanf(\"%s\",outnam);\n  }\n  if((infile=fopen(innam,\"rb\")) == NULL) {\n    printf(\"Can't open file %s.\",innam);\n    exit(8);\n  }\n  if((outfile=fopen(outnam,\"wb\")) == NULL) {\n    printf(\"Can't open file %s.\",outnam);\n    exit(8);\n  }\n  nbr_blanks = 0;\n  while(1) {\n    ch=fgetc(infile);\n    if((ch == EOF) || (ch == 0x1A))\n      break;\n    if(ch == ' ') {\n      nbr_blanks += 1;\n    }\n    else if(ch == 0x0D) {\n      nbr_blanks = 0;\n      fputc(ch,outfile);\n    }\n    else if(nbr_blanks) {\n      for(;nbr_blanks>0;nbr_blanks--)\n      fputc(' ',outfile);\n      fputc(ch,outfile);\n      nbr_blanks = 0;\n    }\n    else\n      fputc(ch,outfile);\n  }\n  fclose(infile);\n  fclose(outfile);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "PASSADDR": {"ttr": 11533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00\\x12\\x00\\x12\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "BC0THOR"}, "text": "#include <iostream.h>\nvoid main() {\n  void intfrac(float, float&, float&);    //prototype\n  float number, intpart, fracpart;        //float variables\n\n  do {\n    cout << \"\\nEnter a real number: \";    //get number from user\n    cin >> number;\n    intfrac(number, intpart, fracpart);   //find int and frac\n    cout << \"Integer part is \" << intpart  //print them\n  << \", fraction part is \" << fracpart;\n  }\n  while(number != 0);\n}\nvoid intfrac(float n, float& intp, float& fracp) {\n  intp = (long(n));  //convert to int, back to float\n  fracp = n - intp;\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "PRIME": {"ttr": 11535, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00B\\x01\\x02\\x11\\x9f\\x01\\x02\\x12o\\x11C\\x00\\x17\\x00\\x15\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-06T11:43:42", "lines": 23, "newlines": 21, "modlines": 0, "user": "BC0THOR"}, "text": "/***********/\n/* prime.c */\n/*********************************/\n/* find out if a number is prime */\n/*********************************/\n#include <stdio.h>\n#include <stdlib.h>\n\nmain() {\n long f = 999999977;          /* number to be evaluated */\n long d;                        /* divisor */\n long r;                        /* remainder */\n long max = f / 2;              /* maximum trial divisor */\n\n for(d=2;d<max;d++) {\n   r = f % d;\n   if(r = 0) {\n  printf(\"\\nOne factor is %ld\\n\",d);\n  exit(0);\n   }\n }\n printf(\"\\nThere is no prime factor for the number.\\n\");\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "PRIMES": {"ttr": 11537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00G\\x01\\x02\\x11\\x9f\\x01\\x02\\x12o\\x11E\\x00\\x17\\x00\\x16\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-06T11:45:47", "lines": 23, "newlines": 22, "modlines": 0, "user": "BC0THOR"}, "text": "/************/\n/* primes.c */\n/*********************************/\n/* find out if a number is prime */\n/*********************************/\n#include <stdio.h>\n\nint main() {\n long f = 999999977;          /* number to be evaluated */\n long d;                        /* divisor */\n long r;                        /* remainder */\n long max = f / 2;              /* maximum trial divisor */\n\n for(d=2;d<max;d++) {\n   r = f % d;\n   if(r == 0) {\n     printf(\"\\nOne factor is %ld\",d);\n     getchar();\n   }\n   printf(\"\\njust divided by %ld\",d);\n }\n printf(\"\\nThere are no more prime factors for the number.\\n\");\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "PRINT": {"ttr": 11539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\t\\x01\\x02\\x11\\x9f\\x01\\x02\\x12o\\x11H\\x00\\x1e\\x00\\x18\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-06T11:48:09", "lines": 30, "newlines": 24, "modlines": 0, "user": "BC0THOR"}, "text": " /***********/\n /* print.c */\n /**************************/\n /* prints file on printer */\n /**************************/\n #include <stdio.h>\n #include <stdlib.h>\n\n int main(int argc, char *argv[]) {\n   FILE *input, *print;\n   char string[81];\n\n   if(argc != 2) {        /* should have 2 args */\n     printf(\"\\nFormat is: C>print filename.\\n\");\n     exit(0);\n   }\n   if((input=fopen(argv[1],\"r\")) == NULL) { /* open input file */\n     printf(\"\\nCan't open file %s.\\n\",argv[1]);\n     exit(0);\n   }\n   if((print=fopen(\"prn\",\"w\")) == NULL) {   /* open print file */\n     printf(\"\\nUnable to open the standard printer file, PRN.\\n\");\n     exit(0);\n   }\n   while(fgets(string,80,input) != NULL)    /* read next string */\n     fputs(string,print);\n   printf(\"\\n\");\n   fclose(input);\n   fclose(print);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "PRINTALL": {"ttr": 11541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x01\\x01\\x02\\x11\\x9f\\x01\\x02\\x12o\\x11U\\x00\\x0e\\x00\\x0c\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-29T00:00:00", "modifydate": "2002-05-06T11:55:01", "lines": 14, "newlines": 12, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* printall.c */\n/******************************************************************/\n/* displays all possible hex characters, 0-255                    */\n/* author r thornton September 1994                               */\n/******************************************************************/\n#include <stdio.h>\nvoid main(void) {\n  unsigned char c;\n  for(c=0; c<=255; c++) {\n    printf(\"\\nchar=%c, hex=%02X, decimal=%03d\",c,c,c);\n    getchar();\n  }\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "PRNFIL": {"ttr": 11778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x01\\\\\\x01\\\\\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 348, "newlines": 348, "modlines": 0, "user": "BC0THOR"}, "text": "           ID\n          JWL Lacy, John            0001 47386 DEL 586 90  32 0540\n   ????MMO N (5th Trng Rm) 0002/ ????  DEL4 6   186 6 0 40\nC01                 MMON 16  0540\nC01COMMON (5th  Trn  Rm)  004 /86 ??? ?  EL46                  16 5/? ???? DEL46\n6  16 0540\nC01 OMMON (5t h86  Tr g  m) 0         OS2-N ( 6/??th  Trng Rm) 0007/????? D EL46\n   16  540 \r86\nDA Es ep,                  vid(0   ????/????? ??????  ??  ???  ???\r CNC C86 amp\nel , Ca                 erin03D istrib.(SLE->CNC)   0 009/ 7098  BM3 286 0   8\n???\nSFIBM 320  06 0120  ????/?? ???  ?????  ??  86 ???  ? ?\nP                 Harv6   16 0332  ????/????? ? ????   ??  ???  86 ???\nM MMil                 r, M 05 40  ????/????? ??????   ?? ????  ??\n86 FEN ew on,                  oyd   ? ???/????? ??????  ??  ???? ???\n TPP a86 rke ,  ary                      ?/? ???? ??????  ?? ????  ???\r JCPPe ra\nm ,86  Ca te (cc:                 )001??  ??????  ?? ???? ???\n MKRR sback  Mi c86 hae      00                 /478??? ?  ?? ???? ???\nLJRRu ssel , Let y    86     00 8/47                 6 DE ??  ???? ???\nMIWWade, M arjo ie        086 019 37 33 I                 320 ???  ???\nNDWWoodson, Nat han      0 20/ 386 711  I M3??                 16 ???\nTABBass, Tab(cc:er)       021/? ???  86 IBM 20  01                  14\n5 D EL466  16 ????  ????/ ????  ???? ?   ?86 ? ? ?? ???\r                 03Di433\n   12 0192\nC03Di stri .(CKF >WH W86 )   00 4/37                 7 IBFF)    0025/49880 IBM45\n0   12  192\n SGG u86 ill t, June                     ?/? ???? IBM433  12 0192\nJEH emenw y,  J86 ame       0                 7/??ane t        0028/37929 I BM32\n   12  120  86  ?? ?/ ????                 ????        0029/49810 DEL433   08 01\n70  002 486 /37 17 IBM3                   1630/ 41200 IBM450  16 0308   ?? ?/???\n ? ? ?86 ???    ? ??                  ???147  IBM320  10 0120\nRWN Neis , Ric ard  86        032/                 883 5   ?? ???? W3.1\nGEBBarw ick, Earl       86   0 33 4714                 DEL4? ? ??? ???\nMJBBurstein,  Mat hew    00 386 4/4 90  IBM                 0  0? ? ??\nARCCerrone, Alexa nder   003 /49 486 76  BM 20                    012\nC 03Distrib.(CAF->EET)    00 6/370 5 I B86 M32    8 01\nSEDEL 466  16 0332  ????/?? ???  ?????  ??  86 ???  ? ?\nS                 Este6   16 0385  0009/37098 I BM32   08  ???  86 ???\nA JJoh                 ton, 01 52  ????/????? ??????   ?? ????  ??\n86 GLM cF rlan                  Gil  ? ???/????? ??????  ??  ???? ???\n POO b86 erg  W llia                     ?/? ???? ??????  ?? ????  ???\r KBSSc ul\nt z86 e,  at leen                  00481  IBM320  08 ???? ???\n JPSS alsky  Jo e86          00                 /371??? ?  ?? ???? ???\nJSSSt rawn  Judi h    86     00 4/37                 1 IB ??  ???? ???\nC03Distrib .(MB ->CLP     086 045 37 07 I                 320  00 46/37922 IBM32\n0  08 0 120  ????/ ??? ?86  ?? ??   ??                 ??? /50 696 DEL466  16 03\n32   ???? ????? ??? ?86 ??  ?? ????                 ??\n7 I BM320  16 0120  ????/ ????  ???? ?   ?86 ? ? ?? O2.1                 CCBBM45\n 0  16 0385  ????/???? ? ?? ???   ? ? ?86 ??  2.\nJE                 avis  0 1 0090  ????/????? ?? ????  ?? ? ??  W86 3.1\nL EEdm                 ds,  01 20\nWWGGoldsborough,  Warr n 005 /49 086 20  BM 20                    009\nS JGGreene, Susan         00 3/471 1 D E86 L46    6 04                   ??LLo n\ngest, Debbie      00 54/3 128 I M32 086   1  0 05\n                 3Dis20   12 0120\nLDOOliver,  Lind         0 086 57/ 71 9 IB                 20  ??  O2.1\nCHSSwecker, Car ol       0 58/ 486 713  D L466                 16 0           ID\n                                                                             ??\n\nEETThompson, Elizabe th   059/3 705  86 AST 10  01                  32\n3 I BM320  ?? ????  ????/ ????  ???? ?   ?86 ? ? ?? ???\r                 03Di320\n   08 0120\nC03Distrib .(CP ->CLP )   086 062 37 71 I                 320  00 63/41703 IBM32\n0  08 0 151  ????/ ??? ?86  ?? ??   ??                 ??? /37 131 IBM320  08 ??\n??\n JDGG odman  Jo h86 n        00                 /498??? ?  ?? ???? ???\nC03Di stri .(GMK >EL S86 )   00 6/37                 7 IB       0067/37149 IBM32\n0   08  120   ??? /86 ??? ?  ????                  ??  00 68/41780 IBM320  08 0\n120\nC03D str i86 b.( WP >WAW                   00dea u, Marc        0070/4 1704 IBM3\n2   0 886  01 0  ????                 ????fre d         0071/41996  IBM3 0  08 0\n12 086   ? ?? ????                 ????>AP G)   0072/37081 IBM32 0  0  ????\nDT S86 Sei z, Debb                     ??? /????? ??????  ?? ??? ? ??\nC03 ist r86 ib. DX ->J9                    0aoi li, Brian      0075/4 1609 IBM45\n   1 686  ?? ?  ????                 ????tep hanie     0076/34480  IBM3 0  01 00\n6 086   ? ?? ????                 ????eb' s)   0077/47948 DEL46 6  1  0325  ?? ?\n86 ?/? ??  ???                 ?  ?    0078/49809 DEL433  08  ???   ??? /?? ?86\n??  ?? ??                    ???79/ 37122 IBM320  08 ????   ?? ?/??? ? ? ?86 ???\n    ? ??                  ???133  DEL466  16 ????  ??? ?/?? ?? ?? ???  86  ?? ??\n ? ??\nAPGBM2 10  01 0030  ????/??? ?? ? ????  ??  ?86 ??? ??\nBC                 ones  0 2 0060  ????/????? ?? ????  ?? ? ??  ?86 ??\r RE Litk\n                t, R012 0  ????/????? ??????   ??  ??? ? ?\n P86 SRR il y, P                      ?? ??/????? ??????  ?? ? ???  2.1\n HSS c86 hro de , Ma                     War d, Bill           008 6/31 25 IB 21\n0  86  01 00 0  ?         WIN-ell ?/??, C heryl        0087/371 04 I M320  08  0\n86 120  ? ??/?                 ?? ?Gle nda     0089/47147 DE L466  16 0 40   86\n006 /3 157                  M320       0090/41374 IBM450   16  153   090 /86 413\n 4  BM45                  16  00 92/50479 DEL466  ?? ? ???  ????/ ??? ?86  ?? ??\n   ??                 ??? /41 377 IBM450  16 0310   0093 41377 IBM 486 50  16 03\n10                 ??\n9 I BM210  ?? ????\nWMGGr een, Wilma      86     00 5/48                 4 IB       0096/51762 DEL57\n5   ??  ???   096 /86 517 2  EL57                  ??  00 97/49756 IBM450  16 0\n153  ????/ ??? ?86  ?? ??   ??                 ??? /10 014 IBM210  ?? ????\n C03D strib (JM G86 ->J 9)   00                 /379Ama nda     0100/????? IB M3\n20  04 ? ??\n86 JMG ah n, J                 n     0 099/37931 IBM320  08  0120 ???\n BRR i86 ce, Ki berl                     ?/? ???? ??????  ?? ????  ???\r DJRRo er\nt s86 , D vi                       01078  DEL466  16 0340 ???\n C03D strib (VS S86 ->J 9)   01                 /371her yl      0105/37119 IB M3\n20  08 0 20\n86 JPW es fall                 Paig  ? ???/????? ??????  ??  ???? O2.1\r CMB B86\nair ,  arol                 e   60/ 37153 IBM320  ?? ????  ???\nSHBB sh,  86 San ra                        01???  ??????  ?? ???? ???\nJAD aniel , J e86 rry       0                 9/41??? ??  ?? ???? ???\nJADD anie s, Je ry  (86 HOM )0 10/5                 09 D        0111/47848 DEL46\n6   16 0332  016 186 /37 41 IBM3                   14     0112/37069 IBM320  ? ?\n ?? ?  00 8/1 086 014 IB 210                  ? ??113 /49832 DEL466  16 033 2  ?\n ??/?? ??  ?86 ??? ?  ?? ?                 ? O3498 30 DEL466  16 0332  0 074/ 17\n01  BM3 286 0   4  083                  ?   982 7 DEL466  16 0340  00 45/3 207 I\n M32 086   0  0 20 O                 0\nJ DE L466  16 0332  0061/3 7215 IBM32   0 886  01 0  ??\n                 PPow           ID\n                               90   16 1024  ????/?????  ???? ?  ?? ??? ?86  ??\n \r GFEE                 onds16  0332  0112/37069 IBM3 20   8 012  O2 .86 1\n MS haia                 Rose024   ????/????? ??????   ?? ? ?? ??\nJ S86 CCa h, Jami                     006 4/37131 IBM320  08 ?? ?? ? ?\nJA Gre e86 ne, Ju y                        ??? ?? ??????  ?? ???? ?? ?\nL HHair ton ,86  La ry                      125/ ?? ????  ?? ???? ???\nKY TTer y, Ka hle e86 n      0126                 9477??   ?? ???? ???\nDLKKenn edy, Dale       86   0 27 5070                 DEL4     0128/47950 DEL46\n6  1 6 03 5\nSA Pur y86 ear  S eila                 ome)owd en, Rob         0130/ 5070  DEL4\n6   186 6 0 32  013                 5070ncy        0131/50697 DEL 466  16 03 2\n ?86 ??? ?? ?? ?                 ???        0132/47132 DEL466   08  440\n FTT h86 oma ,  rend                 (HP1?/? ???? ??????  ?? ????  ???\r BFTTh ma\ns ,86  Br nd  (Ma         WIN-ate )013s,  Anne         0136/478 43 D L466  16  0\n86 332  0 48/?                 ?? ILH- >J99)   0137/37209 IB M320  08 0 20  \r86\nRI Hu t, R                 h   4   ????/????? ??????  ??  ???  ???\r CAF F86 luc\nig r, C                 ryl 36/ 37075 IBM320  08 0120  ???\nPAKK lly ,86  Pa  ( ones                   01218  DEL590  16 1024 ???\nDSG arret , D e86 bbi       0                 1/47BM4 50  12 0080 ???\nDTMM cLan , Dia e    86      0 42/4                 73 I  ? ? ???? ???\nLLMMontro se,  aura       86 014 /5 219                  L590033 2 ???\nETMMerritt, Th omas       144 /86 478 2  EL46                  16 ???\nMLSStumpf, Marcia        0145/ 177 786  DE 59   16                 024 DWB Bayse\n, Donald         0146 41610 IBM 486 50  08 0308                 0166\n\n CPBB bber, Chr i86 sto he   01                 /412M32 0  08 0120 ???\nC03Di stri .(AMW >AJ P86 )   01 8/??                 ? IB       0150/37108 IBM32\n0   14  120   ??? /86 ??? ?  ????                  ??  01 51/37151 IBM320  08 0\n120  ????/ ??? ?86  ?? ??   ??                 ??? /41 019 IBM320  12 0153   ???\n? ????? ??? ?86 ??  ?? ????                 ??\n4 I BM320  10 0060  ????/ ????  ???? ?   ?86 ? ? ?? ???\r                 RHHa320\n   08 0120  ????/?????  ??? ??  ?  ?? ?86 ? ? ?\r SRHH                 ges,06  ??\n??  ????/????? ???? ??   ? ???  W3 .86 1\n AJ acks                 , Ch120   ????/????? ??????   ?? ? ?? ??\nC A86 JJa ks n, C                 rly(WHM Mand, Willa           0158 31143 IBM 3\n86 20  12 0120                 ????str ib.(KAM->J99)   0159/ 4160  IBM4 0   186\n6 0 08\nJAP                 rks, 10  0120  ????/????? ??? ???  ?? ?? ? ? ?86 ?\n XS hort                 , Sa120   ????/????? ??????   ?? ? ?? ??\nB S86 TTh ma , Ba                 ara ??? ?/????? ??????  ?? ?? ?? ? ?\nRD Tho r86 nto ,  ick                      ??? ?? ??????  ?? ???? ?? ?\nP WWrig t,  P86 atr ci                      164/ ?? ????  ?? ???? O1.3\nS JBBa ley,  ara h86         016                 3721???   ?? ???? ???\nC03Dis trib (DWB- JGP )86     16 /379                  IBMell y 0167/49750 IBM32\n0   12 ? ??  ? ??/ ?86 ???  ? ????                 ?? ?016 8/37221 IBM320  14 01\n 20\n MDDod , S c86 arl t                       0169? ? ?????  ?? ???? ???\nA MGGr gory, Ali c86 ia      017                 3721???   ?? ???? ???\nEJGGut hrie  Eliz bet h86     17 /417                  IBM      0172/37095 IBM32\n0   08 0 20\nR HHo l86 gat ,  icha                     ohn son, James       0174 /371 5 IBM 2\n0   86 08  12\nRL                 ontg  1 6 ????\nJXPPalmer, Ja mes        017 686 /41 84 DEL4                   ??77/ ????? IBM32\n0  08 0120\nDW Stein  De l86 ber                         78/3           ID\n                                                           al,  Russell  0179/41\n923  DEL4 0  ?? 033 286\nL AA ent,                 yle ??\nPACCrowder, Philip        181/3 034  86 IBM 10  01                  ??  HKK lak,\n Karen          0 182/ 3900  OM3 286 0   ?  ???\r                 JCCa320   ?? ??\n??  ????/?????  ??? ??  ?  ?? ?86 ? ? ?\r REDD                 ge, 08  0120  ????\n/????? ???? ??   ? ???  ?? ?86\nW DD nahu                  Wad50   ????/????? ??????  ? ? ?? ? ???\nSK D86 DuB eu l, S                 ron ??? /????? ??????  ?? ??? ? ??\nC02 OMM O86 N ( S/ G)                      0??? ? ??????  ?? ???? O2. 1\nR GGres am,  86 Ren ta                      189/ ?? ????  ?? ???? ???\nCM DDra er, M rri t86 t      0192                 1611          0194/41206 IBM4\n50   6 033   ? ?86 ??/ ?? ? ??                 ??       0197/47145 DEL466  1 6 0\n3 5  ?? ?/? ?86 ??? ?? ???                  ? ??203 /34514 IBM320  01 009 0  ? ?\n?/?? ??  ?86 ??? ?  ?? ?                 ? ??792 0 IBM320  01 0090  ?? ??/? ???\n? ??? ?86   ?  ? ?? ?\nC0IBM 210  01 0090\n   Myer s, H rold       86   0 07 3722                 IBM3? ? ??? ???\nCHDDavis, Ch arli  (Con )02 086 8/3 00  IBM                 0  0? ? ??\n   ??by Deb Johns on     020 /37 986 32  BM 20                    009\nC 02COMMON (NS/JG)        02 0/??? ? I B86 M45    1 00\nCBIBM 450  16 0302  0055/49 475  BM320  12  86 012  ? ?\nC                 COMM0   01 0060  ????/????? ? ????   ??  ???  86 ???\nD AAtk                 son, ?? ??  ????/????? ??????   ?? ????  ??\n86 JXK av nagh                 Jenn  ? ???/????? ??????  ??  ???? ???\n EBB a86 rwi k, Earl                     ?/? ???? ??????  ?? ????  ???\r ACHHi so\nn -86 Har el , Am                  02110  DEL466  16 0360 O2.1  WFW\r SWBBa ker ,\n86  Sc tt                       02183  DEL466  16 0240 O2.1  WFW\r SLSSa nde r86\ns,  he ri                    02244  DEL466  16 0330 O2.1  WFW\r CWGGo gaw a86 re,\n Ch isto                 e02243  DEL466  16 0332 ???\n REWW mble, Ric h86 ard      02                 /517L46 6  16 0340 ???\nPLPPo well  Pam       86     02 3/50                 4 DE ??  ???? ???\nTCHHeisdor ffer  Tris     086 224 51 20 D                 590 ???  ???\nAMSStewart, And i        0 25/ 386 713  I M320                 01 0??\nDTMMcLane, Diane          226/5 752  86 DEL 90  ??                  ??    B aker\n, Fran (Cont)   0 227/ 1757  EL5 786 5   ?  ???                  ???/th,  Patric\nia      0228/5 2349 DEL59   1 686  10 4  0144                 7842odo\n0229/51215  DEL5 0  16 102 486   ? ?? ????                 ????n         0230/52\n350 DEL5 90   6 102   0 186 94/ 12 6 IB                 50        0231/41606 IBM\n450   ?? ? ??  0 37/ 386 720  I M320                 08 0 02 32/52373 DEL590  16\n 1 024  0139/ 785 086  DE 46   16                 340 3/5 1776 DEL590  ?? ????\n 010 /4982  DE L86 466  1  033                 O2.1756  DEL590  ?? ????  ??? ?/?\n? ?? ?? ???  86  ?? ?? ? ??\nRNJEL5 90  16 1024  0115/498 30 D L466  16  086 332 ??\nMT                 onni  ? ? ????  0111/47848 DE L466  16 0 32  ?86 ??\r    Cast\n                os (??? ?  ????/????? ??????   ??  ??? ? ?\n S86 ASS lv a, S                 ron  01 46/41610 IBM450  08 0 308  ??\nS FFu t86 rel ,  aman                 a   /?? ??? ??????  ?? ???? ? ??\n MTThr sto n86 , D ni e                    0240? ? ?????  ?? ???? ???\nD TBBl ck, D n    86         024                 ???????   ?? ???? ???\nLBSSer vais  Lind      86     24 /371                  IBM??  ???? ???\nLBSServais,  Lin a       0 286 43/ ?? ? IB                 ??  ??  ???\nKAMMorse, Karen          02 4/4 786 126 DE 466                  ? ??           I\nD                                                                             ?\n MDVVik, Marty            0 45/47 87  D86 EL5 0  ?? ?                 ?  ?VVa ss\n, Dennis         02 46/5 379 D L59 086   ?  ? ??                   ??/?tle , Jim\n          0247/5 2378 DEL59   ? ?86  ?? ?  ????                 ????(5t h #1)\n   0248/49562  IBM 50  ?  ?? ?86 ?   ?? /???                  ???#1)       0249/\n49559 IBM4 50   ? ???   ? ?86 ??/ ?? ? ??                 ??       0250/37949 IB\nM320  0 1 01 0  ?? ?/? ?86 ??? ?? ???                  ? ??251 /49561 IBM450  ??\n ??? ?  ? ??/?? ??  ?86 ??? ?  ?? ?                 ? ??234 8 DEL590  16 1024  0\n1 47/4 201 I M45 086   1  0 08 O                 1\nJ DE L590  16 1024  0107/4 9828 DEL46   1 686  03 2  3.0\r                   vo46\n6   ?? ????  ????/?????  ??? ??  ?  ?? ?86 ? ? ?\r    W                 tese??  ?\n???  ????/????? ???? ??   ? ???  W3 .86 1\n HJ eter                 Hatc???   ????/????? ??????   ?? ? ?? O2 1 W F86 W\n XR oger                  Wil???   ????/????? ??????   ?? ? ?? ??\nW X86 RRo er , Wi                     ??? ?/????? ??????  ?? ?? ?? ? ?\nKJ Hyn e86 s,  en                          ??? ?? ??????  ?? ???? O?  W?\r    Sm\nth,  86 Sam                          026??  ??????  ?? ???? ???\n MMBB ooks, Mar g86 are      02                 /372??? ?  ?? ???? O2.1\nCFWW hite  Cloy      86      0 62/4                 37 D  ? ? ???? O2.1\nWJCCraps er,  ill        86  02 3/ 1791                 EL59 ?? ?? O2.1\nCAKKlisz, Ca rol( c:6U)  02 686 4/5 20  DEL                 0  2? ? ??\nKCMMorgan, Kim           026 /47 186 27  EL 66                    ???\nM BSSorrell, Mary         02 6/400 7 I B86 M32    1 01                   ??CCa l\nhoun, Mike        02 67/5 325 D L59 086   ?  ? ??                   ??/?ton , Br\nenda       0268/4 8731 IBM32   ? ?86  ?? ?  ????                 ???? Di ana\n    0269/47117  DEL 33  ?  ?? ?86 ?   ?? /???                  ???, V irginia\n   0270/498 15 D L466  ??  ?86 ???  ? ??/? WIN-Wit         ?? ? Ri ck       0271\n/37964 I BM32   ??  ???  86  ?? ?/ ????                 ????        0272/33999 I\nBM320   ?? ????  ??? ?86 /?? ?? ????                   ??  0 273/50561 DEL466  ?\n?  ????  ???? ??? ?86 ? ? ?? ?  ?                 ????    0274/49865 IBM4??  ??\n ???   ??? /?? ?86 ??  ?? ??                    ???75/ 47952 DEL590  ?? ????   ?\n? ?/??? ? ? ?86 ???    ? ??                  O2.76/ 47898 DEL466  ?? ????   ?? ?\n/??? ? ? ?86 ???    ? ??                  WFW366  DEL466  ?? ????  ??? ?/?? ?? ?\n? ???  86  ?? ?? ? O2                  WFW715  DEL466  ?? ????  ??? ?/?? ?? ?? ?\n??  86  ?? ?? ? ??\nJETEL4 33  ?? ????  ????/??? ?? ? ????  ??  ?86 ??? ??\nLP                 nyde  ? ? ????  ????/????? ?? ????  ?? ? ??  O86 3.0 WF\nRB                 ulli  ? ? ????  ????/????? ?? ????  ?? ? ??  W86 NT\r CS Bail\n                , Ch??? ?  ????/????? ??????   ??  ??? O .1  W86 NT\r CD Ford\n             Corl??? ?  ????/????? ??????   ??  ??? O .1  W86 NT\r WH Tren\n           Wil??? ?  ????/????? ??????   ??  ??? ? ?\n W86 HTT en , Wi                 iam  ?? ??/????? ??????  ?? ? ???  ??\nC 7CO M86 MON (5 h DE                  CTR/?? ??? ??????  ?? ???? ? ??\n 07COM ON  (86 5th DE O CT                 0287? ? ?????  ?? ???? ???\nC 07CO MON ( th  D86 EMO CT )028                 5100???   ?? ???? ???\nC07COM MON  5TH D MO  C86 TR) 28 /???                  DEL CT R)0290/38963 IBM32\n0   ?? ? ??  ? ??/ ?86 ???  ? ????                 ?? ?029 1/????? DEL5??  ?? ??\n ??\n 07COM ON  (86 5th DE O CT                 0292? ? ?????  ?? ???? ???\nC 07CO MON ( th  D86 EMO CT )029                 4735???   ?? ???? ???\nSWCCla rke, Steve      86     29 /479                  DEL           ID\n                                                                    ??  ???? O2.\n1 WFW\nBSAArr ingt n, Br ce   86     29 /496                  DEL??  ???? ???\nBSAArringto n, B uce     0 286 96/ 89 2 IB                 20  ??  ???\nBSAArrington, Br uce     02 7/? ?86 ??? DE 5133                 ? ???\n BSAArrington, Bruce      0 98/?? ??  D86 EL5 5  ?? ?                 ?  ?AAr ri\nngton, Bruce     02 99/? ??? D L43 386   ?  ? ??                   ??/?ngt on, B\nruce     0300/?? ???  EL590  ??  86 ???    ???/                 ??? ric\n 0301/41868 D EL43   ??  ???  86  ?? ?/ ????                 ????        0302/??\n??? DEL510 0 ?? ????  ??? ?86 /?? ?? ????                   ??  0 303/????? DEL5\n75  ??  ????  ???? ??? ?86 ? ? ?? ?  ?                 ????4/? ???? DEL575  ?? ?\n???   ??? /????  ?? ?86 ???  ?  ???                 ???\r??  IBM4??  ?? ????  ???\n? /??? ? ??? ??   86 ??  ??  ???                 GSMML59 0  ?? ????  ????/???? ?\n ?? ???   ? ? ?86 ??  3.\nWD                 rayl  ? ? ????  ????/????? ?? ????  ?? ? ??  ?86 ??\r PJ Bowe\n                , Pa??? ?  ????/????? ??????   ??  ??? ? ?\n T86 XDD vi , Ta                 y    ?? ??/????? ??????  ?? ? ???  ??\nB KKi n86 g,  ar ara                      /?? ??? ??????  ?? ???? ? ??\n BFFir she e86 ts, Ja k                    0313? ? ?????  ?? ???? ???\nD DMMo ton,  ebb i86 e       031                 5234466   16 0332 ???\nTDKKin g, T eresa      86     31 /523                  DEL16  0332 ???\n   Henninge r, D ug      0 386 16/ 05 0 DE                 66  ??  W3.1\n   Henninger, D oug      0 17/ 186 020  I M210                 01 0??\n   Hechler, Al            318/5 541  86 DEL 66  ??                  ??      Manl\ny, Derek          0319 47239 DEL 486 66  ?? ???? OS2-2.1         ????urr er, Dia\nne        0320 /415 6 IBM 50   86 ??  ??   ??                 /???t,  Martha\n  0321/4192 0 DE 466   ? ? ?86 ??  ?? ?/??                 ? ??ill        0322/4\n1922 DEL L466  ?? ? ??   86 ??? /? ???                  ????Kar en       0323/52\n323 D EL59   ??  ???  86  ?? ?/ ????                 ????e        0324/48732 IBM\n32 0  0  0090  ?? ?86 ?/? ??  ???                 ?  ?     0325/51778 DEL590  1\n6 10 4  02 1/4 186 210 IB 450                  6 03      0326/51775 DEL590   ??\n? ??  0 19/ 486 983  D L466                 16 0 03 27/41018 IBM450  ?? ? ???  ?\n???/ ??? ?86  ?? ??   ??                 ??? /52 324 DEL590  ?? ????   ???? ????\n? ??? ?86 ??  ?? ????                 2.1\r85  DEL466  ?? ????  ???? /??? ? ??? ?\n?   86 ??  ??  O3.\nQWMEL5 90  ?? ????  ????/??? ?? ? ????  ??  ?86 ??? ??\nQW                 oon,  0 1 0090  ????/????? ?? ????  ?? ? ??  O86 1.3\nD WWhi                 , De 10 24  0113/49832 DEL466   16 0305  ??\n86 PFT ur er,                  tric  0 122/47849 DEL466  16  0332 ???\n PFF r86 y,  an ra                       3/4 9832 DEL466  16 0332  ???\r RWPPo l,\n  R86 ob                           03317  IBM320  14 0120 ???\n VSSS ith,  tev e86          03                 /???M32 0  08 0120 ???\nAMPPe rry, Alan       86     03 9/41                 5 IB 08  0120 ???\nGMJJungles , Gr gory      086 340 ?? ?? D                 590 340  ???\nSMMMelvin, Shar en(C NT) ? ??/ 086 000  0 0000                 00 0/00 000 00000\n0  00 0000\n JXMM ssina  Jo e86          ??                 /000rol (CONT)  ????/00000 00 00\n00  00 0 00\n86 ELS ow er,                  izab\nA JPPowers, Alice(CONT)   ?? ?/000 0 0 086 000    0 00\nBF000 000  00 0000\n JHHa mpto , Jim      86     ?? ?/00                 0 00 10  0120\nC02COMMON (NS/ JG)        ??? /86 372 5  BM2?                  ?? ???\nC08COMMON (near Al  Ross ????/ 187 186  DE 43   ??                 ???\n  ID\n 97  DEL466  ?? ????\n   C hild ess,  ell a86      ? ??/4                 47 D  ? ? ???? ???\n   Empty  room (PC2)      86 ??? /5 750                  L575  ? ???/????? ?????\n?  ??  ????  0079 371 286 2 I M3 0  0                 ?????/? ???? ??????  ?? ??\n??   ??? /????  ?? ?86 ???  ?  ???                 ???\r??  ??????  ?? ????  ????\n /??? ? ??? ??   86 ??  ??  ???                    ?L46 6  ?? ????  ????/???? ?\n?? ???   ? ? ?86 ??  ??\nC07                 MMON ??  ????  ????/????? ??? ???  ?? ?? ? ? ?86 ?\n    ext                  pty ???\n   Leake, Scott (Co nt)  ????/ ??? ?86  DE 57   ??                 ???     ??nea\nr M Donnini      ???? ????? DEL 586 90  ?? ????                 ????nio n, Jeff\n        ????/ ????  DEL5 0   ?86 ? ? ??  ???                 ????Deb  Amrhein\n????/?????  DEL 90  ?  ?? ?86 ?   ?? /???                  ???          ????/???\n?? IBM2 ??   ? ???\nC 086 4CO MO  (6t                 #2) ??? ?/????? ??????  ?? ?? ?? ? ?\nC0 COM M86 ON  by Cale                     ??? ?? ??????  ?? ???? ?? ?\nB HHanc ck,  86 Bre t                       ???/and ra         ????/?????  IBM ?\n?  1  03 086 8\n    ann,                 oyce\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PRTEXACT": {"ttr": 11784, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00W\\x01\\x02\\x12\\x0f\\x01\\x02\\x12o\\x13\\x15\\x00!\\x00$\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-06T13:15:57", "lines": 33, "newlines": 36, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* prtexact.c */\n/************************************************/\n/* program to print a file in hex and character */\n/************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n  unsigned int ch,ct;\n  FILE *infil,*outfil;\n  ct=0;\n  if(argc!=2) {\n    printf(\"\\nSYNTAX: prtexact [d:][\\\\path\\\\]filename[.ext]\");\n    exit(0);\n  }\n  if((infil=fopen(argv[1],\"rb\"))==NULL) {\n    printf(\"\\nCan't open the input file, $s\",argv[1]);\n    exit(0);\n  }\n  if((outfil=fopen(\"prn\",\"w\"))==NULL) {\n    printf(\"\\nCan't open the printer file.\",argv[1]);\n    exit(0);\n  }\n  while(((ch=fgetc(infil))!=EOF) && (ct<24)) {\n    fputc(ch,outfil);\n    if(ch=='\\x0D')\n      ct++;\n  }\n  fputs(\"\\n\\n\\n\",outfil);\n  fclose(outfil);\n  fclose(infil);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "PRVINIT": {"ttr": 11786, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00'\\x01\\x02\\x12\\x0f\\x01\\x02\\x12o\\x14\\x16\\x004\\x00.\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-06T14:16:27", "lines": 52, "newlines": 46, "modlines": 0, "user": "BC0THOR"}, "text": "/*************/\n/* prvinit.c */\n/*********************************************************************/\n/* prvinit() is the initialization function for the prv_server       */\n/*********************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n\n/*********************************************************************/\n/*     Global variables defined in the main() function               */\n/*********************************************************************/\nextern FILE    *prvfile;              /* provider file pointer       */\nextern char     prvname[80];          /* provider file name          */\nextern int      prvrecln;             /* provider file record length */\nextern int      prvkeyln;             /* length of provider number   */\nextern long int prvflsiz;             /* provider file size in bytes */\nextern long int prvrecds;             /* total records in provider fi*/\nextern long int curpvrec;             /* current provider file record*/\nextern long int curpvoff;             /* shrinking work offset       */\nextern long int prvseek;              /* current provider seek offset*/\n\n/*********************************************************************/\n/*    Function prototypes                                            */\n/*********************************************************************/\nvoid prvinit(void);                   /* initialization function */\nint  prv_search(char * prv_key);      /* binary search function */\nvoid prv_term(void);                  /* termination function */\n\n/*********************************************************************/\n/* Open the provider file, obtain its length in bytes and set up file*/\n/* variables.                                                        */\n/*********************************************************************/\n\nvoid prvinit(void) {\n  if((prvfile = fopen(prvname,\"rb\")) == NULL) {\n    printf(\"\\nUnable to open the provider file, \"\n           \"prvinit() terminating\");\n    exit(1);\n  }\n  if(fseek(prvfile,0,SEEK_END) != 0) {   /* set file pointer to eof */\n    printf(\"\\nUnable to locate end of provider file, \"\n                          \"prvinit() terminating\");\n    exit(1);\n  }\n  if((prvflsiz = ftell(prvfile)) == -1L) { /* get file size */\n    printf(\"\\nUnable to obtain size of provider file,\"\n                            \" prvinit() terminating\");\n    exit(1);\n  }\n  prvrecds = prvflsiz / prvrecln; /*nbr recds*/\n  return;\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "PRVSEAR": {"ttr": 11788, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00&\\x01\\x02\\x12\\x0f\\x01\\x02\\x12o\\x14)\\x00J\\x00I\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-06T14:29:26", "lines": 74, "newlines": 73, "modlines": 0, "user": "BC0THOR"}, "text": "/*************/\n/* prvsear.c */\n/*********************************************************************/\n/* prv_search() is the binary search function for the prv_server     */\n/*********************************************************************/\n#include <stdio.h>\n#include <string.h>\n\n/*********************************************************************/\n/*     Global variables defined in the main() function               */\n/*********************************************************************/\nextern FILE    *prvfile;              /* provider file pointer       */\nextern char     prvname[80];          /* provider file name          */\nextern int      prvrecln;             /* provider file record length */\nextern int      prvkeyln;             /* length of provider number   */\nextern long int prvflsiz;             /* provider file size in bytes */\nextern long int prvrecds;             /* total records in provider   */\nextern long int currecrd;             /* current provider file recnbr*/\nextern long int curofst;              /* shrinking work offset       */\nextern long int prvseek; /* current provider seek offset*/\n\n/*********************************************************************/\n/*    Function prototypes                                            */\n/*********************************************************************/\nvoid prv_init(void);                  /* initialization function */\nint  prv_search(char * prv_key);      /* binary search function */\nvoid prv_term(void);                  /* termination function */\n\n/*********************************************************************/\n/* caller supplies a provider number. pvr_search() performs a binary */\n/* binary search of the provider file. If a record is found for the  */\n/* specified provider number, the number of reads required to locate */\n/* record will be returned. if the provider is not found, 0 is retur */\n/*********************************************************************/\nint prv_search(char * prv_key) {\n\n  int      compare = 0;                /* current compare indicator */\n  int      result = 0;                 /* result indicator */\n  char     record[256];                /* input record area */\n\n  currecrd = 0;                        /* set initial record number */\n  curofst = prvrecds - 1; /* initial work offset */\n  compare = -1;                        /* set compare for low */\n  while(curofst != 1) {\n    curofst ++;                     /* add 1 to insure rounding high */\n    curofst /= 2;                      /* offset / 2 (rounded high) */\n    if(compare < 0) {                  /* if last key read was low */\n      currecrd += curofst; /* add offset incr */\n      if(currecrd >= prvrecds) {                     /* if past end */\n        compare = 1;                   /* set compare to high */\n        continue;                      /* and continue to while */\n      }\n      else ;\n    }\n    else {                             /* if last key read was high */\n      currecrd -= curofst; /* subtract offset*/\n      if(currecrd < 0) {               /* if result prior to 1st slot*/\n        compare = -1;                  /* set compare to low */\n        continue;                      /* and continue to while */\n      }\n      else ;\n    }\n   prvseek = currecrd * prvrecln;\n    if((fseek(prvfile,prvseek,0)) != 0)                /* file pos. */\n      break;                           /* terminate if error */\n    fread(record,prvrecln,1,prvfile); /* read the record */\n    result++;                          /* count the reads */\n    if((compare=memcmp(record,prv_key,prvkeyln)) == 0) {\n      result = 0 - result;             /*         /* make count plus */\n      break;                           /* yes, quit */\n    }\n  }\n  return(result);\n}\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PRVSERV": {"ttr": 11791, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x008\\x01\\x02\\x12\\x0f\\x01\\x02\\x12o\\x149\\x00\\x1a\\x00\\x17\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-06T14:39:38", "lines": 26, "newlines": 23, "modlines": 0, "user": "BC0THOR"}, "text": "/*************/\n/* prvserv.c */\n/*********************************************************************/\n/* Header file for the provider file custom server, prv_server       */\n/*********************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n/*********************************************************************/\n/*     Global variables defined in the main() function               */\n/*********************************************************************/\nextern FILE    *prvfile;              /* provider file pointer       */\nextern char     prvname[80];          /* provider file name          */\nextern int      prvrecln;             /* provider file record length */\nextern int      prvkeyln;             /* length of provider number   */\nextern long int prvflsiz;             /* provider file size in bytes */\nextern long int prvrecds;             /* total records in provider f */\nextern long int currecd;              /* current provider file recor */\nextern long int currofst;             /* shrinking work offset       */\nextern long int prvseek; /* current provider seek offse */\n\n/*********************************************************************/\n/*    Function prototypes                                            */\n/*********************************************************************/\nvoid prv_init(void);                  /* initialization function */\nint  prv_search(char *prv_key);       /* binary search function */\nvoid prv_term(void);                  /* termination function */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PRVTERM": {"ttr": 11793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00 \\x01\\x02\\x12\\x0f\\x01\\x02\\x12o\\x14E\\x00\"\\x00 \\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-06T14:45:20", "lines": 34, "newlines": 32, "modlines": 0, "user": "BC0THOR"}, "text": "/*************/\n/* prvterm.c */\n/*********************************************************************/\n/* prv_term() is the termination function for the prv_server         */\n/*********************************************************************/\n#include <stdio.h>\n\n/*********************************************************************/\n/*     Global variables defined in the main() function               */\n/*********************************************************************/\nextern FILE    *prvfile;              /* provider file pointer       */\nextern char     prvname[80];          /* provider file name          */\nextern int      prvrecln;             /* provider file record length */\nextern int      prvkeyln;             /* length of provider number   */\nextern long int prvflsiz;             /* provider file size in bytes */\nextern long int prvrecds;             /* total records in provider fi*/\nextern long int currecd;              /* current provider file record*/\nextern long int currofst;             /* shrinking work offset       */\nextern long int prvseek; /* current provider seek offset*/\n\n/*********************************************************************/\n/*    Function prototypes                                            */\n/*********************************************************************/\nvoid prv_init(void);                  /* initialization function */\nint  prv_search(char *prv_key);       /* binary search function */\nvoid prv_term(void);                  /* termination function */\n\n/*********************************************************************/\n/* close the provider file.                                          */\n/*********************************************************************/\nvoid prv_term(void) {\n  fclose(prvfile);                     /* close provider file */\n  return;\n}\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PTRARAY": {"ttr": 12033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00V\\x01\\x00\"?\\x01\\x02\\x12\\x7f\\x089\\x00\\x10\\x00\\x0c\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2000-08-10T00:00:00", "modifydate": "2002-05-07T08:39:56", "lines": 16, "newlines": 12, "modlines": 0, "user": "BC0THOR"}, "text": "/*************/\n/* ptraray.c */\n/***********************************************************/\n/* sample code demonstrating definition of array and use of*/\n/* a pointer to access the array.                          */\n/***********************************************************/\n#include <stdio.h>\n\nint  main() {\n  char strgaray[7][12] = {\"Dick\",\"Mary\",\"Norman\",\"Mike\",\"Wayne\",\n                                 \"Paula\",\"Willie\"};\n  int i;\n\n  for(i=0;i<7;i++)\n  printf(\"\\nString %d is: %s\",i+1,strgaray+i);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "PUREBRE": {"ttr": 12035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00Y\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x7f\\x08S\\x00t\\x00w\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-07T08:53:59", "lines": 116, "newlines": 119, "modlines": 0, "user": "BC0THOR"}, "text": "/*************/\n/* purebre.c */\n/*******************************************************************/\n/* reads a pcplus log file and removes the Blue Ridge Express (BRE)*/\n/* data, leaving only the text of messages.                        */\n/*                                                                 */\n/* Author R Thornton January 1995                                  */\n/*******************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid initialize(int argc, char *argv[]); /* initialization function */\nvoid mainline(void);                  /* mainline function */\nvoid process(void);                   /* process input records */\nvoid terminate(void);                 /* termination function */\nvoid readrec(void);                   /* read next input file record */\nvoid writerec(void);                  /* write record to output file */\n\nFILE *infile, *outfile;               /* file handle pointers */\nchar innam[81];                       /* input file name */\nchar outnam[81];                      /* output file name */\n\nchar inrecord[256];                   /* input file record area */\nchar outrecord[256];                  /* output file record area */\n\n\nint i,j,k;                            /* general purpose int */\nint goodrec = 0;                      /* good record indicator */\nint morerecs = -1;                    /* input end-of-file switch */\nlong incount = 0;                     /* input record counter */\nlong outcount = 0;                    /* output record counter */\n\n\nvoid main(int argc, char *argv[]) {\n  initialize(argc, argv);       /* open files */\n  while(morerecs)               /* perform mainline until */\n    mainline();                 /* no more records */\n  terminate();                  /* close files */\n  exit(0);                      /* quit */\n}\n/*********************************************************************/\n/* mainline function: process input file until no more records.      */\n/*********************************************************************/\nvoid mainline(void) {\n  process();                 /* move input record to print */\n  if(goodrec)                /* if it is a good message text record*/\n    writerec();              /* write an output record */\n  readrec();                 /* read next input record */\n}\n/*********************************************************************/\n/* initialization: open files, read first input record.              */\n/*********************************************************************/\nvoid initialize(int argc, char *argv[]) {\n  if(argc == 3) {\n    strcpy(innam,argv[1]);\n    strcpy(outnam,argv[2]);\n  }\n  else {\n    printf(\"\\nEnter input file spec: \");\n    gets(innam);\n    printf(\"\\nEnter output file spec: \");\n    gets(outnam);\n  }\n  if((infile=fopen(innam,\"rb\")) == NULL) { /* open input */\n    printf(\"Can't open file %s.\",innam);\n    exit(1);\n  }\n  if((outfile=fopen(outnam,\"wb\")) == NULL) { /* open output */\n    printf(\"Can't open file %s.\",outnam);\n    exit(1);\n  }\n  readrec();             /* read first input file record */\n}\n/*********************************************************************/\n/* read next input file record. at end of file, set morerecs switch. */\n/*********************************************************************/\nvoid readrec() {\n  if(fgets(inrecord,255,infile) == NULL) /* read input until eof */\n    morerecs = 0;                        /* set switch at end of file*/\n  if(morerecs)\n    incount++;                           /* add 1 to records read */\n}\n/*********************************************************************/\n/* process input records: throw away those not part of message text  */\n/*********************************************************************/\nvoid process() {\n  goodrec = 0;                  /* presume record to be discarded */\n  i = strlen(inrecord);         /* get record length */\n  for(k=0,j=0; j<i; j++) {\n    if((inrecord[j] == '\\r') || (inrecord[j] == '\\n')) {\n      goodrec = 1;              /* end of record, all o.k. */\n      break;\n    }\n   if((inrecord[j] < '\\x20') || (inrecord[j] > '\\x7e'))\n     return;                    /* invalid character found */\n   if(inrecord[j] == ' ')\n     k++;\n  }\n  if(k == i)                     /* all blanks? */\n    return;                      /* yes, drop it */\n}\n/*********************************************************************/\n/* write a record to the output file                                 */\n/*********************************************************************/\nvoid writerec() {\n  fputs(outrecord,outfile);        /* write output record */\n  outcount++;                      /* add 1 to records written */\n}\n/*********************************************************************/\n/* termination: close files                                          */\n/*********************************************************************/\nvoid terminate() {\n  fclose(infile);                           /* close files */\n  fclose(outfile);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "RDVSMSEQ": {"ttr": 12038, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x10\\x01\\x001\\x9f\\x01\\x02\\x12\\x7f\\x08U\\x00<\\x009\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2000-11-14T00:00:00", "modifydate": "2002-05-07T08:55:10", "lines": 60, "newlines": 57, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* rdvsmseq.c */\n/*********************************************************************/\n/* Counts the records in a KSDS dataset and prints the total at      */\n/* end of job.                                                       */\n/*********************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define  REC_SIZE 1017\n/*********************************************************************/\n/* Function prototypes                                               */\n/*********************************************************************/\nstatic void print_amrc(void);\nvoid main(void);\n/*********************************************************************/\n/* Global data areas                                                 */\n/*********************************************************************/\nstruct {\n  char data[1017];\n} buffer;\nFILE* vsamfile;\nlong RecordCount=0;\nint rc=-1;\n/*********************************************************************/\n/* main() function definition.                                       */\n/*********************************************************************/\nvoid main(void) {\n  vsamfile = fopen(\"dd:vsamfile\",\"rb+,type=record\");\n  if (vsamfile == NULL) {\n    print_amrc();\n    printf(\"Error: fopen(\\\"dd:cluster\\\"...) failed\\n\");\n    exit(8);\n  }\n  while(rc) {\n    rc = fread(&buffer,1,REC_SIZE,vsamfile);\n    if((rc < 0) || (rc > REC_SIZE) || ferror(vsamfile)) {\n      printf(\"Error: reading vsam file\\n\");\n      printf(\"rc from fread = %d\",rc);\n      exit(8);\n    }\n    if(rc > 0)\n      RecordCount++;\n  }\n  printf(\"Total records in file = %ld\",RecordCount);\n  exit(0);\n}\n/*********************************************************************/\n/* Routine to print file errors                                      */\n/*********************************************************************/\nstatic void print_amrc(void) {\n    __amrc_type currErr = *__amrc; /* copy contents of __amrc     */\n                                   /* structure so that values    */\n                                   /* don't get jumbled by printf */\n    printf(\"R15 value   = %d\\n\", currErr.__code.__feedback.__rc);\n    printf(\"Reason code = %d\\n\", currErr.__code.__feedback.__fdbk);\n    printf(\"RBA         = %d\\n\", currErr.__RBA);\n    printf(\"Last op     = %d\\n\", currErr.__last_op);\n    return;\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "READC": {"ttr": 12040, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x001\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x7f\\t\\x05\\x00\\x10\\x00\\x0b\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-07T09:05:31", "lines": 16, "newlines": 11, "modlines": 0, "user": "BC0THOR"}, "text": "/***********/                                                                  \\\n/* readc.c */\n/*********************************************/\n/* reads one character at a time from a file */\n/*********************************************/\n#include <stdio.h>\n\nmain() {\n  FILE *fptr;\n  int ch;\n\n  fptr = fopen(\"textfile.txt\",\"r\");   /* open input file, text mode */\n  while((ch=getc(fptr)) != EOF)       /* read next character */\n    printf(\"%c\",ch);                  /* print it */\n  fclose(fptr);                       /* close the file */\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "READDIR": {"ttr": 12042, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x05\\x00'\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x7f\\x11G\\x00\\x1f\\x00\\x19\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@\"", "ispf": {"version": "01.05", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-07T11:47:27", "lines": 31, "newlines": 25, "modlines": 0, "user": "BC0THOR"}, "text": "/*************/\n/* readdir.c */\n/*****************************************/\n/* attempt to read a directory as a file */\n/*****************************************/\n#define _ALL_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n\nchar buffer[512];\nint inhandle;\nint bytes;\nint j;\n\nmain(int argc, char *argv[]) {\n  if(argc != 2) {\n    printf(\"syntax is: readdir directory_path\\n\");\n    exit(1);\n  }\n  printf(\"Input directory is %s\\n\",argv[1]);\n  if((inhandle = open(argv[1], O_RDONLY)) < 0) {\n    perror(\"Can't open file \\n\");\n    exit(1);\n  }\n  while((bytes = read(inhandle, buffer, 512)) > 0)\n    for(j=0; j<bytes; j++)\n      putchar(buffer[j]);\n  close(inhandle);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "REMOVE0A": {"ttr": 12044, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00P\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x7f\\x10D\\x00*\\x00+\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-07T10:44:50", "lines": 42, "newlines": 43, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* remove0a.c */\n/*****************************************************/\n/* copy file, removing all x'0A' new line characters */\n/*****************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nmain(int argc, char *argv[]) {\n  FILE *infile, *outfile;\n  char innam[81],outnam[81];\n  int ch;\n\n  if(argc == 3) {\n    strcpy(innam,argv[1]);\n    strcpy(outnam,argv[2]);\n  }\n  else {\n    printf(\"\\nEnter input file spec: \");\n    scanf(\"%s\",innam);\n    printf(\"\\nEnter output file spec: \");\n    scanf(\"%s\",outnam);\n  }\n  if((infile=fopen(innam,\"rb\")) == NULL) {\n    printf(\"Can't open file %s.\",innam);\n    exit(8);\n  }\n  if((outfile=fopen(outnam,\"wb\")) == NULL) {\n    printf(\"Can't open file %s.\",outnam);\n    exit(8);\n  }\n  while(1) {\n    ch=fgetc(infile);\n    if((ch == EOF) || (ch == 0x1A))\n      break;\n    if(ch != 0x0A)\n      fputc(ch,outfile);\n  }\n  fclose(infile);\n  fclose(outfile);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "RENDIR": {"ttr": 12046, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00W\\x00W\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 87, "newlines": 87, "modlines": 0, "user": "BC0THOR"}, "text": "/* rendir.c */\n/* Program to rename a directory. From the FilRenameDir program in */\n/* Systems Programming in Turbo C by Michael J. Young, pages 140, 133 */\n\n#include <stdio.h>\n#include <process.h>\n\n#define NOERROR    0       /* no error */\n#define NODIR      1       /* directory not found or other error */\n\nint FilRenameDir(char *OldDir,char *NewDir);\n\nint FilError;\nmain(int argc,char *argv[])\n{\n if (argc != 3)\n {\n  printf(\"\\nUsage: RENDIR [drive:]olddir newdir\\n\");\n  exit(1);\n } /* end if */\n switch (FilRenameDir(argv[1], argv[2]))\n {\n  case NOERROR:\n    printf(\"\\nRename successful\\n\");\n    exit(0);\n  case NODIR:\n    printf(\"\\nFilRenameDir error\\n\");\n    exit(1);\n } /* end switch */\n} /* end main */\n\n#include <dos.h>\n\nstatic struct           /* Extended File Control Block structure */\n   {\n unsigned char ExtCode;      /* Flag indicating extended FCB */\n char Res1[5];               /* Reserved field */\n unsigned char Code;         /* File attribute code */\n unsigned char OldDrive;     /* Drive for old name */\n char OldName[11];           /* Old directory name */\n char Res2[5];               /* Reserved field */\n char NewName[11];           /* New directory name */\n char Res3[9];               /* Reserved field */\n   } DirFcb={'\\xff',\" \",'\\x10'};\n\n/* This function renames the directory 'OldDir' to the name 'NewDir' */\nint FilRenameDir(char *OldDir, char *NewDir)\n{\n register int i;\n int ErrorCode;\n\n if(OldDir[1] == ':')            /* Drive identifier with OldDir? */\n {\n  DirFcb.OldDrive = toupper(OldDir[0]) - 64;\n  OldDir += 2;\n } /* end if */\n else\n  DirFcb.OldDrive = 0;\n for(i=0;i<11;++i)              /* Copy names to DirFcb with blank padding */\n    {\n     if(*OldDir == '\\0')\n         DirFcb.OldName[i] = ' ';\n     else\n         DirFcb.OldName[i] = *OldDir++;\n     if(*NewDir == '\\0')\n         DirFcb.NewName[i] = ' ';\n     else\n         DirFcb.NewName[i] = *NewDir++;\n    } /* end for */\n _DX = (unsigned int)&DirFcb;     /* Pass address of File Control Block */\n _AH = 0x17;                      /* DOS Rename File Service */\n geninterrupt(0x21);              /* DOS Service Interrupt */\n ErrorCode = _AL;                 /* Error code returned in AL. */\n if (ErrorCode == 0)\n    {\n     FilError = NOERROR;\n     return(NOERROR);\n    } /* end if */\n else\n    {\n     FilError = NODIR;\n     return(NODIR);\n    } /* end else */\n} /* end FilRenameDir */\n\n\n\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "RENGREG": {"ttr": 12049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x008\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x7f\\x11E\\x005\\x000\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-07T11:45:38", "lines": 53, "newlines": 48, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* rengreg.c */\n/*********************************************************************/\n/* rename using current date: the file CUSTSHPT.D10 is renamed to be */\n/* yyyymmdd.CUS, where yyyymmdd is the current gregorian date.       */\n/*                                                                   */\n/* If rename is successful, exit(0) is done, else exit(1) which can b*/\n/* tested in a batch file using the errorlevel command. For example: */\n/*                                                                   */\n/*     echo off                                                      */\n/*     if errorlevel 1 goto badrenam                                 */\n/*     nextpgm                                                       */\n/*     exit                                                          */\n/*     :badrenam                                                     */\n/*     echo RENAME FAILED, JOB TERMINATED IN ERROR                   */\n/*                                                                   */\n/* Author: R Thornton   Sep 1995                                     */\n/*********************************************************************/\n#define _ALL_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\ntime_t seconds;                         /* current timer value */\nstruct tm *t;                           /* pointer to time structure */\n\nchar oldname[13] = \"CUSTSHPT.D10\";      /* current file name */\nchar newname[13] = \"yyyymmdd.CUS\";      /* new file name */\nint century;                            /* century */\nchar gregdate[9] = \"19950907\";          /* today's gregorian date */\n\nint  main() {\n\n  timezone = 5 * 60 * 60;           /* set for eastern standard time */\n  daylight = -1;                     /* set for daylight saving time */\n  time(&seconds);                       /* get current timer value */\n  t = localtime(&seconds);          /* get localtime in tm structure */\n\n  if(t->tm_year < 50)                   /* develop century for today */\n    century = 20;                       /* if 00-49 assume 20 */\n  else\n    century = 19;                       /* if 50-99 assume 19 */\n\n  sprintf(gregdate,\"%2d%02d%02d%02d\",   /* build gregorian date */\n   century,t->tm_year,(t->tm_mon)+1,t->tm_mday);\n  memcpy(newname,gregdate,8);           /* date to new file name */\n\n  if(rename(oldname,newname) != 0) {    /* rename the file */\n    perror(\"rename failed\");\n    exit(1);\n  }\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "RUNTESTS": {"ttr": 12051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x002\\x01\\x003/\\x01\\x02\\x12\\x7f\\x11X\\x00\\xa2\\x00\\x9f\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2000-11-27T00:00:00", "modifydate": "2002-05-07T11:58:32", "lines": 162, "newlines": 159, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* runtests.c */\n/*********************************************************************/\n/* Reads the first four files created by split4.c and stores them in */\n/* arrays in memory. All combinations of one record from each file   */\n/* are built. For each set of records, the fields are tested for     */\n/* duplicates, and the combination is rejected, if there is any      */\n/* duplicate. If no duplicate is found, the combination is tested for*/\n/* four formulas. If all four are true, a solution is displayed.     */\n/*                                                                   */\n/* Author R Thornton November, 2000                                  */\n/*********************************************************************/\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n/*********************************************************************/\n/* Global data areas                                                 */\n/*********************************************************************/\nFILE *infiles[4];              /* file pointers */\nstruct {\n  char digit[4][3];\n char filler1[3];\n} record;\nint data[2000][4];           /* data from files 1-4 */\nint start[4];                /* starting indexes for file data */\nint end[4];                  /* ending indexes for file data */\n/*********************************************************************/\n/* Function prototypes                                               */\n/*********************************************************************/\nint  main(void);             /* executive control routine */\nvoid Initialize(void);       /* Initialize for porcessing */\nvoid Terminate(void);        /* termination routine */\nint  Check_Duplicates(int []); /* check for duplication in trial */\nint  Check_Formulas(int []); /* check formulas against trial */\nvoid Display_Solution(int []); /* display a solution */\n/*********************************************************************/\n/* executive control routine                                         */\n/*********************************************************************/\nint  main(void) {            /* executive control routine */\n  int i, j, k, l, t;\n  int trial[16];             /* trial number set */\n  long count=0;              /* iteration count */\n\n  Initialize();              /* Initialize for processing */\n  for(i=start[0]; i<=end[0]; i++)\n  for(j=start[1]; j<=end[1]; j++)\n  for(k=start[2]; k<=end[2]; k++)\n  for(l=start[3]; l<=end[3]; l++) {\n    for(t=0; t<4; t++) trial[t] = data[i][t]; /* copy numbers 1-4 */\n    for(; t<8; t++) trial[t] = data[j][t-4];  /* copy numbers 5-8 */\n    for(; t<12; t++) trial[t] = data[k][t-8]; /* copy numbers 9-12 */\n    for(; t<16; t++) trial[t] = data[l][t-12]; /* copy nbrs 13-16 */\n    count++;                        /* increment interval counter */\n    if(count > 1000000) {\n      count = 0;                    /* reset counter */\n      printf(\"At 10K: i=%d, j=%d, k=%d, l=%d\\n\",i,j,k,l);\n    }\n    if(Check_Duplicates(trial)) continue;\n    if(Check_Formulas(trial)) continue;\n    Display_Solution(trial);\n  }\n  Terminate();                   /* Finished, terminate processing */\n  return(0);\n}\n/*********************************************************************/\n/* Check_Duplicates: checks the numbers in the trial array for any   */\n/* duplicated values. Returns 0 if no duplicates found, else non-zero*/\n/*********************************************************************/\nint  Check_Duplicates(int trial[16]) {\n  int i, j;\n  int chk[16] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                 16};\n  for(i=0; i<16; i++) {\n    j = trial[i];              /* get number from trial */\n    if(chk[j] == 0)            /* check for number already used */\n      return(-1);                /* return -1 if duplicate found */\n    else\n      chk[j] = 0;                /* show number used if not a dup */\n  }\n  return(0);                    /* no duplicates, return zero */\n}\n/*********************************************************************/\n/* Check_formulas: checks the numbers in the trial array against four*/\n/* formulas. Returns 0 if trial satisfies all formulas, else non-zero*/\n/*********************************************************************/\nint  Check_Formulas(int trial[16]) {\n  int i;\n  if(!((trial[0] - trial[4] + trial[8] * trial[12]) == 2))\n    return(-1); /* formula failed, return -1 */\n  if(!((trial[1] - trial[5] + trial[9] * trial[13]) == 181))\n    return(-1); /* formula failed, return -1 */\n  if(!((trial[2] + trial[6] * trial[10] - trial[14]) == 105))\n    return(-1); /* formula failed, return -1 */\n  if(!((trial[3] + trial[7] + trial[11] * trial[15]) == 89))\n    return(-1); /* formula failed, return -1 */\n  return(0);               /* all formulas valid, return 0 */\n}\n/*********************************************************************/\n/* Display_solution: displays number values found for a solution.    */\n/*********************************************************************/\nvoid Display_Solution(int trial[16]) {\n  printf(\"Solution found: %02d %02d %02d %02d %02d %02d %02d %02d \"\n       \"%02d %02d %02d %02d %02d %02d %02d %02d\\n\",\n        trial[0], trial[1], trial[2], trial[3],\n        trial[4], trial[5], trial[6], trial[7],\n        trial[8], trial[9], trial[10], trial[11],\n        trial[12], trial[13], trial[14], trial[15]);\n}\n/*********************************************************************/\n/* Termination routine.                                              */\n/*********************************************************************/\nvoid Terminate(void) {\n  exit(0);\n}\n/*********************************************************************/\n/*  Initialize for processing: Open input files and load them into   */\n/*  arrays.                                                          */\n/*********************************************************************/\nvoid Initialize(void) {\n  int i;\n  char filename[] = \"dd:input1\";  /* file name prototype */\n  int j, k;                 /* work int's */\n  int count=0;              /* input record count */\n  int indx=0;               /* index to data array */\n  int more_records = 1;     /* =0 at eof input1 */\n  char work[3];             /* conversion work area */\n\n  for(i=0; i<4; i++) {\n    sprintf(&filename[8], \"%1d\", i+1);  /* specialize filename */\n    infiles[i] = (fopen(filename,\"rb,type=record,recfm=FB,lrecl=15\"));\n    if(infiles[i] == NULL) {\n      printf(\"Error opening file %s\\n\", filename);\n      perror(\" \");\n      exit(8);\n    }\n    more_records = 1;       /* indicate more records available */\n    count = 0;              /* reset record count for file */\n    start[i] = indx;        /* set starting index for file */\n    while(more_records) {\n      more_records = fread(&record, 15, 1, infiles[i]); /* read */\n      if(ferror(infiles[i])) {\n        printf(\"\\nAt file INPUT%c, record number %d: \",i+1, count);\n        perror(\"Read error occurred.\");\n        printf(\"\\n\");\n        exit(8);\n      }\n      if(!more_records) { /* when at end of file: */\n        end[i] = indx-1;    /* set ending index value */\n        fclose(infiles[i]); /* close this file */\n        break;            /* break out of while loop */\n      }\n      count++;                   /* count input records */\n      for(j=0; j<4; j++) {\n        memcpy(&work, record.digit[j], 2); /* copy character field */\n        work[2] = '\\x0';           /* make it a string */\n        k = atoi(work);            /* convert it to int */\n        data[indx][j] = k;         /* copy number to data array */\n      }\n      indx++;                      /* advance to next data element */\n    }\n  }\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "SCR": {"ttr": 12292, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x01\\xd9\\x01\\xd9\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 473, "newlines": 473, "modlines": 0, "user": "BC0THOR"}, "text": "/***************************************************************/\n/*                     scr.c                                   */\n/* A set of video management functions from the book           */\n/* Systems Programming in C by Michael J. Young                */\n/***************************************************************/\n#include <dos.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <mem.h>\n#include <ctype.h>\n#include <sys/stat.h> */\n#include <scr.h>\n\n/***************************************************************/\n/* gets the current video mode, number of display columns, and */\n/* video page.                                                 */\n/***************************************************************/\nvoid get_mode(struct mode *mode_ptr) {\n unsigned char ah_hold;\n\n _AH = 15;                   /* BIOS get video mode service */\n geninterrupt(0x10);         /* BIOS video services */\n ah_hold = _AH;               /* AH returns columns */\n mode_ptr->video_mode = _AL; /* AL returns mode */\n mode_ptr->columns = ah_hold;\n mode_ptr->video_page = _BH; /* BH returns active page */\n}\n\n/***************************************************************/\n/* sets the video mode and display page. note that the columns */\n/* field is not used and will not be set, since this value is  */\n/* implicit in the mode.                                       */\n/***************************************************************/\nvoid set_mode(struct mode *mode_ptr) {\n _AH = 0;     /* BIOS set mode service */\n _AL = mode_ptr->video_mode;\n geninterrupt(0x10);       /* BIOS video services */\n _AH = 5;     /* BIOS set active page service */\n _AL = mode_ptr->video_page;\n geninterrupt(0x10);   /* BIOS video services */\n}\n\n/***************************************************************/\n/* assigns the current cursor position to the variables pointed*/\n/* to by row and col for video page page.                      */\n/***************************************************************/\nvoid get_cur(int *row, int *col, int page) {\n _BH = (unsigned char)page;\n _AH = 3;\n geninterrupt(0x10);\n *row = _DH;\n *col = _DL;\n }\n\n/***************************************************************/\n/* positions the cursor as specified by row and col for the    */\n/* video page page.                                            */\n/***************************************************************/\nvoid set_cur(int row, int col, int page) {\n _BH = (unsigned char)page;\n _DH = row;\n _DL = col;\n _AH = 2;     /* BIOS set cursor position service */\n geninterrupt(0x10);         /* BIOS video service */\n}\n\n/***************************************************************/\n/* assigns the current cursor atarting and stopping lines to   */\n/* the variables pointed to by start_line and stop_line. These */\n/* parameters determine the shape of the cursor.               */\n/***************************************************************/\nvoid get_style(int *start_line, int *stop_line) {\n _BH = 0;                    /* get it for page 0, as all are same */\n _AH = 3;     /* BIOS read cursor position service */\n geninterrupt(0x10);         /* BIOS video service */\n *start_line = _CH;\n *stop_line = _CL;\n}\n\n/***************************************************************/\n/* sets the cursor shape according to the values passed in     */\n/* start_line and stop_line.                                   */\n/***************************************************************/\nvoid set_style(int start_line, int stop_line) {\n _CH = start_line;\n _CL = stop_line;\n _AH = 1;     /* BIOS set cursor type service */\n geninterrupt(0x10);         /* BIOS video service */\n}\n\n/***************************************************************/\n/*                  data for the push and pop functions        */\n/***************************************************************/\n#define MAXSCREENS 10\n\nstatic char *bufptar[MAXSCREENS]; /* Elements of this array point to */\n         /* the screen storage buffers on   */\n         /* the screen stack. */\nstatic int bufidx = -1;    /* Index to bufptar  */\n\n/***************************************************************/\n/* save content of current screen on the screen stack          */\n/***************************************************************/\nint scr_push(void) {\n int video_seg;\n\n if(++bufidx >= MAXSCREENS)  /* test if max exceeded */\n  return(MAXTOOSMALL);\n if((bufptar[bufidx] = malloc(4000)) == NULL) {\n  --bufidx;\n  return(NOHEAP);\n }\n if(*(char far *)0x00400049 == 7) /* test video mode */\n  video_seg = 0xB000;    /* monochrome */\n else\n  video_seg = 0xB800;    /* color */\n movedata(video_seg, 0, FP_SEG((char far *)bufptar[bufidx]),\n    FP_OFF((char far *)bufptar[bufidx]),4000);\n return(NOERROR);\n}\n\n/***************************************************************/\n/* restores the most recently saved screen on the screen stack */\n/* and removes it from the stack if remove is non-zero;        */\n/***************************************************************/\nint scr_pop(int remove) {\n int video_seg;\n\n if(bufidx < 0)            /* no screens to restore */\n  return(STACKEMPTY);\n if(*(char far *)0x00400049 == 7) /* test video mode */\n  video_seg = 0xB000;    /* monochrome */\n else\n  video_seg = 0xB800;    /* color */\n movedata(FP_SEG((char far *)bufptar[bufidx]),\n    FP_OFF((char far *)bufptar[bufidx]),video_seg,0,4000);\n if(remove)\n  free(bufptar[bufidx--]);\n return(NOERROR);\n}\n\n/******************************************************************/\n/* reads the 4000-byte screen image file specified by filename    */\n/* (may contain a full path) into the buffer pointed to by buffer */\n/******************************************************************/\n#include <fcntl.h>\n#include <io.h>\n\nint read_window(char *buffer, char *filename) {\n int file_handle;\n\n if((file_handle = open(filename,O_RDONLY | O_BINARY)) == -1)\n  return(OPENERR);\n if(read(file_handle, buffer, 4000) != 4000)\n  return(READERR);\n if(close(file_handle) == -1)\n  return(CLOSERR);\n return(NOERROR);\n}\n\n/********************************************************************/\n/* displays the rectangular area of the screen data buffer buffer   */\n/* specified by source_start_row, source_start_col, source_end_row, */\n/* and source_end_col at the beginning position on the screen given */\n/* by target_row and target_col.                                    */\n/********************************************************************/\nvoid put_window(char *buffer, int source_start_row, int source_start_col,\n    int source_end_row, int source_end_col, int target_row,\n    int target_col) {\n register int row, source_off, video_off;\n int bytes_per_row, video_seg;\n\n /* calculate offset of 1st character in buffer */\n source_off = FP_OFF((char far *)buffer) + source_start_row * 160\n     + source_start_col * 2;\n if(*(char far *)0x00400049 == 7)  /* test video mode */\n  video_seg = 0xB000;    /* monochrome */\n else\n  video_seg = 0xB800;    /* color */\n /* calculate offset of 1st character in video memory */\n video_off = target_row * 160 + target_col * 2;\n /* calculate number of bytes per row */\n bytes_per_row = (source_end_col - source_start_col + 1) * 2;\n /* move data to video memory row by row. */\n for(row=1; row <= source_end_row - source_start_row + 1; ++row) {\n  movedata(FP_SEG((char far *)buffer),source_off, video_seg,\n     video_off, bytes_per_row);\n  source_off += 160;    /* increment offset in buffer */\n  video_off += 160;    /* increment offset in video memory */\n }\n}\n\n/***************************************************************/\n/* displays null-terminated string with video attribute attr   */\n/* beginning at the position specified by row and col          */\n/***************************************************************/\nvoid scr_puts(char *string, int attr, int row, int col) {\n register int a;      /* fast register storage for attr */\n char far *video;     /* far pointer to video memory */\n int video_seg, video_off;   /* Store video memory address */\n\n a = attr;\n if(*(char far *)0x00400049 == 7) /* Test video mode */\n  video_seg = 0xB000;    /* monochrome */\n else\n  video_seg = 0xB800;    /* color */\n video_off = row * 160 + col * 2; /* Beginning video memory offset */\n video = MK_FP(video_seg, video_off); /* Initialize video memory pointer */\n while(*string) {            /* write characters from string until null */\n  *video++ = *string++;\n  *video++ = a;\n }\n}\n\n/***************************************************************/\n/* displays a box on the screen starting at row and column ULR */\n/* and ULC and ending at row and column LRR and LRC. Style     */\n/* selects the line style, and may be between 0 and 3.         */\n/***************************************************************/\nvoid put_box(int ULR, int ULC, int LRR, int LRC, int style) {\n register int i;\n int delta1, delta2;\n /* Store the box characters for each style */\n static char ulc[] = {218,201,213,214};\n static char urc[] = {191,187,184,183};\n static char llc[] = {192,200,212,211};\n static char lrc[] = {217,188,190,189};\n static char hl[] = {196,205,205,196};\n static char vl[] = {179,186,179,186};\n int video_seg;     /* Segment address of video memory */\n char far *video;    /* far pointer to video memory */\n\n delta1 = (LRC - ULC) * 2;  /* bytes between 2 vertical lines */\n delta2 = 160 - delta1;    /* bytes between right vertical   */\n         /* line and left vertical line of */\n         /* next row. */\n if(*(char far *)0x00400049 == 7)  /* test video mode */\n  video_seg = 0xB000;             /* monochrome */\n else\n  video_seg = 0xB800;    /* color */\n video = MK_FP(video_seg, ULR * 160 + ULC * 2); /* Initialize far pointer*/\n               /* to upper left corner  */\n               /* of box. */\n *video = ulc[style]; /* Upper left corner of box */\n video += 2;     /* Draw upper left corner */\n for(i=1; i <= LRC - ULC - 1; ++i) { /* Draw top horizontal line */\n  *video = hl[style];\n  video += 2;\n }\n *video = urc[style]; /* Draw upper right corner */\n video += delta2;\n for(i=1; i <= LRR - ULR - 1; ++i) {  /* Draw both vertical lines */\n  *video = vl[style]; /* left vertical line */\n  video += delta1;\n  *video = vl[style]; /* Right vertical line */\n  video += delta2;\n }\n *video = llc[style];        /* Draw lower left corner */\n video += 2;\n for(i=1; i <= LRC - ULC - 1; ++i) {  /* Draw bottom horizontal line */\n  *video = hl[style];\n  video += 2;\n }\n *video = lrc[style]; /* Draw lower right corner */\n}\n\n/***************************************************************/\n/* clears the rectangular section of the screen specified by   */\n/* the four parameters.                                        */\n/***************************************************************/\nvoid scr_clear(int start_row, int start_col, int stop_row, int stop_col) {\n _BH = 0x07;     /* Use normal, white on black video attrib */\n _CH = start_row;\n _CL = start_col;\n _DH = stop_row;\n _DL = stop_col;\n _AX = 0x600;    /* BIOS scroll page up function */\n geninterrupt(0x10);   /* BIOS video services */\n}\n\n/****************************************************************/\n/* Reads characters into buffer, echoing the input starting     */\n/* at row and column using video attribute attr. characters are */\n/* read until an exit key (CR, Esc, or arrow) is encountered, or*/\n/* until the number read is one less than the specified buffer  */\n/* size, length. If the first key pressed is an exit key, the   */\n/* buffer is unaltered. Otherwise, the buffer is initially      */\n/* filled with blanks and terminated with a null; therefore, the*/\n/* resulting string will be blank-padded on the right. The      */\n/* terminating exit key is not placed into the buffer. The      */\n/* length parameter should equal the sizeof the receiving buffer*/\n/* The mode parameter can specify one or more of the following  */\n/* features (constants defined in scr.h):                       */\n/*      NOFEAT:   No mode features specified                    */\n/*      AUTOEXIT: Exit field automatically when buffer is full  */\n/*      UPPER:    Convert all letters to upper case             */\n/* The function returns one of the following codes indicating   */\n/* the field exit key pressed by the user:                      */\n/*     -1     <Esc>                                             */\n/*      0     <CR>                                              */\n/*      1     <Left arrow>                                      */\n/*      2     <Right arrow>                                     */\n/*      3     <Up arrow>                                        */\n/*      4     <Down arrow>                                      */\n/*      5     Automatic exit (last character entered and        */\n/*            AUTOEXIT was selected).                           */\n/****************************************************************/\nint scr_gets(char *buffer, int attr, int row, int col, int length, int mode) {\n register int cur_col, i;  /* current column / loop index */\n int video_seg;     /* Segment of video memory */\n int far *video;     /* far pointer to video memory */\n int key;      /* Stores input key value */\n int first_char = 1;    /* Flag to indicate the 1st character */\n char *chpt;      /* For filling buffer with blanks */\n int far *intfp;     /* For filling buffer with blanks */\n\n cur_col = col;     /* Initialize current column */\n if(*(char far *)0x00400049 == 7) /* Test Video mode */\n  video_seg = 0xB000;    /* monochrome */\n else\n  video_seg = 0xB800;    /* color */\n /* Initialize far pointer to video memory */\n video = MK_FP(video_seg, row * 160 + col * 2);\n /* Place cursor at first position */\n set_cur(row, cur_col, 0);\n for(;;)                      /* Keyboard read loop */\n  switch (key = kbd_getc()) {\n   case 0x011B:   /* Esc */\n    return(-1);\n   case 0x4B00:   /* Left arrow */\n    return(1);\n   case 0x4D00:   /* Right arrow */\n    return(2);\n   case 0x4800:   /* Up arrow */\n    return(3);\n   case 0x5000:   /* Down arrow */\n    return(4);\n   case 0x1C0D:   /* Return */\n    return(0);\n   case 0x0E08:   /* Backspace */\n    if(cur_col > col) {\n     set_cur(row, --cur_col, 0);\n     *--video = (attr << 8) | ' ';\n     *--buffer = ' ';\n    }\n    break;\n   default:\n    if(cur_col >= col + length - 1)    /* Test end of buffer */\n     break;\n    if(key & 0x00FF == 0)   /* Test for non-ASCII character */\n     break;\n    if(mode & UPPER)        /* Uppercase conversion */\n     key = toupper(key & 0x00FF);\n    else\n     key &= 0x00FF;      /* Remove extended code */\n    /* Place key in video memory and buffer */\n    *video++ = (attr << 8) | key;\n    *buffer++ = key;\n    set_cur(row, ++cur_col, 0);   /* Update cursor position */\n    if(first_char) {       /* Blank fill buffer on first char */\n     first_char = 0;\n     chpt = buffer;\n     intfp = video;\n     for(i = 1; i <= length-2; ++i) {\n      *chpt++ = ' ';\n      *intfp++ = (attr << 8) | ' ';\n     }\n     *chpt = '\\0';\n    }\n    /* Test for AUTOEXIT */\n    if((cur_col >= col + length - 1) && (mode & AUTOEXIT))\n     return(5);            /* Code for AUTOEXIT */\n     break;\n   }\n}\n\n\n\n\n/****************************************************************/\n/* Displays the video attribute attr on the rectangular area    */\n/* of the screen specified by the last four parameters, without */\n/* altering existing screen data.                               */\n/****************************************************************/\nvoid put_attr(int attr, int start_row, int start_col,\n     int stop_row, int stop_col) {\n register int row, col;\n int video_seg, char_per_row, delta;\n char far *video;    /* Far pointer to video memory */\n if(*(char far *)0x00400049 == 7) /* test video mode */\n  video_seg = 0xB000;             /* monochrome */\n else\n  video_seg = 0xB800;    /* color */\n /* Initialize pointer to first attribute in video memory. */\n video = MK_FP(video_seg, (start_row * 160 + start_col * 2) +1);\n /* Calculate characters per row */\n char_per_row = stop_col - start_col + 1;\n /* Calculate increment value between rows */\n delta = 160 - (stop_col - start_col +1) * 2;\n for(row = 1; row <= stop_row - start_row +1; ++row) {\n  for(col = 1; col <= char_per_row; ++col) {        /* Display a row */\n   *video = attr;    /* write the attribute */\n   video += 2;     /* Increment to next attribute */\n  }\n  video += delta;      /* Increment to next row */\n }\n}\n\n/****************************************************************/\n/* Reads a key using the BIOS. the return value contains:    */\n/*    High-order byte: extended code                            */\n/*    Low-order byte:  ASCII value                              */\n/****************************************************************/\nint kbd_getc() {\n _AH = 0;     /* BIOS service 0: read keyboard */\n geninterrupt(0x16);         /* BIOS keyboard services */\n return(_AX);                /* Extended code/ASCII value returned in AH/AL */\n}\n\n/*****************************************************************/\n/* Writes the currently displayed screen image into the file     */\n/* specified by filename.                                        */\n/*****************************************************************/\nint write_window(char *filename) {\n int filehandle, code = 0;\n\n scr_push();                 /* save the screen on the stack */\n if((filehandle = open(filename,O_RDWR|O_BINARY)) != -1) {\n  put_box(2,0,4,79,1);\n  scr_clear(3,1,3,78);\n  scr_puts(\"File already exists; overwrite? (y/n): \",0x8F,3,17);\n  set_cur(3,57,0);\n  switch(kbd_getc()&0x00FF) {\n   case 'y':\n   case 'Y':\n    code = 0;\n    break;\n   default:\n    close(filehandle);\n    code = 1;\n    break;\n  }\n }\n else if((filehandle = open(filename,O_RDWR|O_BINARY|O_CREAT,\n    S_IREAD|S_IWRITE)) == -1) {\n    scr_puts(\"Error creating file\",0x8F,3,28);\n    code = 1;\n   }\n if(!code) {\n  write(filehandle, (char *)bufptar[bufidx], 4000);\n  close(filehandle);\n return(code);\n }\n scr_pop(-1);                        /* pop current screen off stack */\n}\n\n/***************************************************************/\n/* Writes a character the screen at the specified location and */\n/* with the attribute given. Cursor location is unchanged;     */\n/***************************************************************/\nvoid scr_putc(char key, int row, int col, int attr) {\n char far *video;     /* far pointer to video memory */\n int video_seg, video_off;   /* Store video memory address */\n\n if(*(char far *)0x00400049 == 7) /* Test video mode */\n  video_seg = 0xB000;    /* monochrome */\n else\n  video_seg = 0xB800;    /* color */\n video_off = row * 160 + col * 2; /* Beginning video memory offset */\n video = MK_FP(video_seg, video_off); /* Initialize video memory pointer */\n *video++ = key;\n *video = attr;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCRGEN": {"ttr": 12545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x01\\xff\\x01\\xff\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 511, "newlines": 511, "modlines": 0, "user": "BC0THOR"}, "text": "/* screen generation program */\n#include \"scr.h\"\n\nint ulrow=0, ulcol=0, lrrow=24, lrcol=79;        /* Default area 0,0,24,79 */\nint c_row=0, c_col=0;                             /* Cursor row and column */\nint attr=0x0F;                                        /* Default attribute */\nint style=1;                                           /* Defaul box style */\nint boxed=0;                                       /* Area boxed indicator */\nint box_attr=0x0F;                                  /* Box color attribute */\nint line_attr;                                   /* Current line attribute */\nunsigned int k;                              /* Extended Value of key read */\nunsigned char c;                                       /* ASCII key value */\n\n\n      /* function prototypes */\nvoid show_help(void);                                                /* F1 */\nvoid define_area(void);                                              /* F2 */\nvoid cycle_bg_color();                                           /* Alt-F2 */\nvoid cycle_fg_color();                                           /* Ctl-F2 */\nvoid clear_current_area();                                           /* F3 */\nvoid draw_box(void);                                                 /* F4 */\nvoid cycle_box_color();                                          /* Alt-F4 */\nvoid cycle_box_style();                                          /* Ctl-F4 */\nvoid cycle_line_color();                                             /* F5 */\nvoid load_screen();                                                  /* F9 */\nvoid save_screen(void);                                             /* F10 */\nvoid ascii_chars(void);\nvoid cursor_up_1_row(void);\nvoid cursor_down_1_row(void);\nvoid cursor_left_1_column(void);\nvoid cursor_right_1_column(void);\n\n\n/**************************************************************************/\n/* Executive routine: Initialize for processing, permit user to draw on   */\n/* the screen, and call appropriate functions to handle function keys.    */\n/**************************************************************************/\nvoid main() {\n scr_clear(0,0,24,79);                              /* clear the screen */\n show_help();                                    /* display help screen */\n set_cur(c_row, c_col,0);                          /* Set cursor to 0,0 */\n\n while(-1) {\n  k = kbd_getc();                                   /* Read keyboard */\n  c = 0x00FF & k;                    /* Get the ASCII portion into c */\n  k >>= 8;                          /* Shift extended key value right */\n  if(c)                            /* If key pressed is normal ASCII */\n   ascii_chars();                       /* Write it to the screen */\n  else\n   switch(k) {\n    case 0x3B:                               /* F1 key pressed */\n     show_help();                    /* Display HELP screen */\n     break;\n    case 0x3C:                               /* F2 key pressed */\n     define_area();                   /* Define screen area */\n     break;\n    case 0x69:                           /* Alt-F2 key pressed */\n     cycle_bg_color();       /* Cycle area background color */\n     break;\n    case 0x5F:                           /* Ctl-F2 key pressed */\n     cycle_fg_color();       /* cycle area foreground color */\n     break;\n    case 0x3D:                               /* F3 key pressed */\n     clear_current_area();     /* Clear current screen area */\n     break;\n    case 0x3E:                               /* F4 key pressed */\n     draw_box();                    /* Draw box around area */\n     break;\n    case 0x6B:                           /* Alt-F4 key pressed */\n     cycle_box_color();          /* Cycle box outline color */\n     break;\n    case 0x61:                           /* Ctl-F4 key pressed */\n     cycle_box_style();                  /* Cycle box style */\n     break;\n    case 0x3F:                               /* F5 key pressed */\n     cycle_line_color();        /* cycle current line color */\n     break;\n    case 0x43:                               /* F9 key pressed */\n     load_screen();             /* Load a saved screen file */\n     break;\n    case 0x44:                              /* F10 key pressed */\n     save_screen();        /* save current screen to a file */\n     break;\n    case 0x71:                          /* Alt-F10 key pressed */\n     exit(0);                       /* termnate the program */\n    case 0x48:                           /* Up arrow */\n     cursor_up_1_row();\n     break;\n    case 0x50:                         /* Down arrow */\n     cursor_down_1_row();\n     break;\n    case 0x4B:                         /* Left arrow */\n     cursor_left_1_column();\n     break;\n    case 0x4D:                        /* Right arrow */\n     cursor_right_1_column();\n     break;\n    default:                        /* Any other non-ASCII key */\n     break;                               /* just ignore it */\n   }\n }\n}\n\n/*************************************************************************/\n/* First push the current screen onto the stack. Display the help screen,*/\n/* and wait for any key press, then restore the current screen from the  */\n/* stack and return to caller.                                           */\n/*************************************************************************/\nvoid show_help(void) {                                             /* F1 */\n int ulr=0, ulc=0, lrr=15, lrc=38;                /* HELP Box corners */\n int style=1;                                       /* HELP Box style */\n int attr=0x0F;                                /* HELP Box attributes */\n int i, j;                                                 /* Indexes */\n\n scr_push();                        /* Push current screen onto stack */\n put_box(ulr, ulc, lrr, lrc, style);                      /* Draw box */\n scr_clear(ulr+1,ulc+1, lrr-1, lrc-1);              /* Clear interior */\n put_attr(0x0F, ulr, ulc, lrr, lrc);                /* Set attributes */\n scr_puts(\"F1  -  HELP (This screen)          \", attr, ulr+1, ulc+2);\n scr_puts(\"F2  -  Define Screen Area          \", attr, ulr+2, ulc+2);\n scr_puts(\"Alt-F2  -  Cycle Background Color  \", attr, ulr+3, ulc+2);\n scr_puts(\"Ctl-F2  -  Cycle Foreground Color  \", attr, ulr+4, ulc+2);\n scr_puts(\"F3  -  Clear Current Area          \", attr, ulr+5, ulc+2);\n scr_puts(\"F4  -  Draw Box in Area            \", attr, ulr+6, ulc+2);\n scr_puts(\"Alt-F4  -  Cycle Box Color         \", attr, ulr+7, ulc+2);\n scr_puts(\"Ctl-F4  -  Cycle Box Style         \", attr, ulr+8, ulc+2);\n scr_puts(\"F5  -  Cycle Current Line Color    \", attr, ulr+9, ulc+2);\n scr_puts(\"F9  -  Load Screen File            \", attr, ulr+10, ulc+2);\n scr_puts(\"F10  - Save and End                \", attr, ulr+11, ulc+2);\n scr_puts(\"Alt-F10 - End Without Save         \", attr, ulr+12, ulc+2);\n scr_puts(\"Press any key to continue          \", attr, ulr+14, ulc+2);\n kbd_getc();                                         /* Read keyboard */\n scr_pop(-1);                         /* Restore saved screen to view */\n return;                                          /* Return to caller */\n}\n\n/***************************************************************************/\n/* Ask user to define the area by positioning the cursor at the upper left */\n/* and pressing Enter, then at the lower right and pressing Enter. If the  */\n/* Esc key is pressed at any time, the routine exits without change. Only  */\n/* the Esc, Enter, and arrow keys are recognized by this function. On      */\n/* successful completion, the area corner values are set and boxed is off. */\n/***************************************************************************/\nvoid define_area(void) {                                             /* F2 */\n int sav_ulr, sav_ulc, sav_lrr, sav_lrc, sav_box;\n char string[80];\n\n sav_ulr = ulrow;     /* save current stuff */\n sav_ulc = ulcol;\n sav_lrr = lrrow;\n sav_lrc = lrcol;\n sav_box = boxed;\n scr_push();\n scr_clear(11,1,11,78);          /* ask for upper left location */\n put_box(10,0,12,79,1);\n scr_puts(\"Position cursor in box upper left using arrow keys, then press enter\"\n,0x0F,11,2);\n get_cur(&ulrow, &ulcol,0);    /* set box ul to current cursor position */\n c_row = ulrow;\n c_col = ulcol;\n while(-1) {\n  k = kbd_getc();\n  switch(k) {\n   case 0x1C0D:           /* Enter key */\n    break;\n   case 0x4800:           /* Up arrow */\n    ulrow--;\n    if(ulrow < 0)\n     ulrow = 24;\n    set_cur(ulrow, ulcol, 0);\n    break;\n   case 0x5000:           /* Down arrow */\n    ulrow++;\n    if(ulrow > 24)\n     ulrow = 0;\n    set_cur(ulrow, ulcol, 0);\n    break;\n   case 0x4B00:          /* Left arrow */\n    ulcol--;\n    if(ulcol < 0)\n     ulcol = 79;\n    set_cur(ulrow, ulcol, 0);\n    break;\n   case 0x4D00:          /* Right arrow */\n    ulcol++;\n    if(ulcol > 79)\n     ulcol = 0;\n    set_cur(ulrow, ulcol, 0);\n    break;\n   case 0x011B:         /* Esc key */\n    ulrow = sav_ulr;\n    ulcol = sav_ulc;\n    lrrow = sav_lrr;\n    lrcol = sav_lrc;\n    boxed = sav_box;\n    scr_pop(-1);\n    return;\n   default:\n    break;\n  }\n  if(k == 0x1C0D)\n   break;\n }\n\n scr_clear(11,1,11,78);          /* ask for lower right location */\n put_box(10,0,12,79,1);\n scr_puts(\"Position cursor in box lower right using arrow keys, then press enter\n\",0x0F,11,2);\n get_cur(&lrrow, &lrcol,0);    /* set box lr to current cursor position */\n c_row = lrrow;\n c_col = lrcol;\n while(-1) {\n  k = kbd_getc();\n  switch(k) {\n   case 0x1C0D:           /* Enter key */\n    break;\n   case 0x4800:           /* Up arrow */\n    lrrow--;\n    if(lrrow < 0)\n     lrrow = 24;\n    set_cur(lrrow, lrcol, 0);\n    break;\n   case 0x5000:           /* Down arrow */\n    lrrow++;\n    if(lrrow > 24)\n     lrrow = 0;\n    set_cur(lrrow, lrcol, 0);\n    break;\n   case 0x4B00:          /* Left arrow */\n    lrcol--;\n    if(lrcol < 0)\n     lrcol = 79;\n    set_cur(lrrow, lrcol, 0);\n    break;\n   case 0x4D00:          /* Right arrow */\n    lrcol++;\n    if(lrcol > 79)\n     lrcol = 0;\n    set_cur(lrrow, lrcol, 0);\n    break;\n   case 0x011B:         /* Esc key */\n    ulrow = sav_ulr;\n    ulcol = sav_ulc;\n    lrrow = sav_lrr;\n    lrcol = sav_lrc;\n    boxed = sav_box;\n    scr_pop(-1);\n    return;\n   default:\n    break;\n  }\n  if(k == 0x1C0D)\n   break;\n }\n if((ulrow+1 < lrrow) && (ulcol+1 < lrcol)) {\n  scr_clear(11,1,11,78);                            /* Error message */\n  put_box(10,0,12,79,1);\n  sprintf(string,\"Box corners are %2d,%2d,%2d,%2d\",ulrow,ulcol,lrrow,lrcol);\n  scr_puts(string,0x0F,11,2);\n  k = kbd_getc();                                /* Wait for any key */\n  scr_pop(-1);\n  put_attr(attr, ulrow, ulcol, lrrow, lrcol);\n  c_row = ulrow;\n  c_col = ulcol;\n  set_cur(c_row, c_col, 0);\n  boxed = 0;\n }\n else {\n  scr_clear(11,1,11,78);                            /* Error message */\n  put_box(10,0,12,79,1);\n  scr_puts(\"Box lower right is not below and right of upper left.\",0x0F,11,2);\n  k = kbd_getc();                                /* Wait for any key */\n  get_cur(&c_row, &c_col,0);                  /* Set cursor position */\n  ulrow = sav_ulr;\n  ulcol = sav_ulc;\n  lrrow = sav_lrr;\n  lrcol = sav_lrc;\n  boxed = sav_box;\n  scr_pop(-1);\n }\n}\n\n/***************************************************************************/\n/*  Cycle through background colors as user presses Alt-F2                 */\n/***************************************************************************/\nvoid cycle_bg_color() {              /* Alt-F2 */\n int bga;\n attr += 16;                   /* high-order nibble controls background */\n attr &= 0x007F;                               /* don't permit flashing */\n if(boxed) {\n  box_attr &= 0x000F;    /* Turn off bg attribute in boxed attribute */\n  bga = attr & 0x00F0; /* Capture bg attribute only from area attrib */\n  box_attr |= bga;                   /* Make bg same in area and box */\n  put_attr(box_attr, ulrow, ulcol, lrrow, lrcol);\n  put_attr(attr, ulrow+1, ulcol+1, lrrow-1, lrcol-1);\n }\n else\n  put_attr(attr, ulrow, ulcol, lrrow, lrcol);\n}\n\n/***************************************************************************/\n/* Cycle through foreground colors as user presses Ctl-F2                  */\n/***************************************************************************/\nvoid cycle_fg_color() {                                          /* Ctl-F2 */\n if((attr & 0x000F) == 0x000F)\n  attr &= 0xFFF0;\n else\n  attr += 1;           /* Low order nibble controls foreground color */\n if(boxed)\n  put_attr(attr, ulrow+1, ulcol+1, lrrow-1, lrcol-1);\n else\n  put_attr(attr, ulrow, ulcol, lrrow, lrcol);\n}\n\n/***************************************************************************/\n/* Clear the currently defined screen area.                                */\n/***************************************************************************/\nvoid clear_current_area() {                                          /* F3 */\n if(boxed) {\n  scr_clear(ulrow+1, ulcol+1, lrrow-1, lrcol-1);\n  put_attr(attr, ulrow+1, ulcol+1, lrrow-1, lrcol-1);\n }\n else {\n  scr_clear(ulrow, ulcol, lrrow, lrcol);\n  put_attr(attr, ulrow, ulcol, lrrow, lrcol);\n }\n}\n\n/***************************************************************************/\n/* Draw a box around the current area. Indicate area is boxed.  Use the    */\n/* box style currently set.                                                */\n/***************************************************************************/\nvoid draw_box(void) {                                                /* F4 */\n int bga;\n\n boxed = -1;\n bga = (attr & 0x00F0);                  /* Copy bg from area attribute */\n box_attr &= 0xFF0F;\n box_attr |= bga;\n put_box(ulrow, ulcol, lrrow, lrcol, style);\n put_attr(box_attr, ulrow, ulcol, lrrow, lrcol);\n put_attr(attr, ulrow+1, ulcol+1, lrrow-1, lrcol-1);\n}\n\n/***************************************************************************/\n/* Cycle the color of the box outlining the current area.                  */\n/***************************************************************************/\nvoid cycle_box_color() {                                         /* Alt-F4 */\n int bga;\n\n if((box_attr & 0x000F) == 0x000F)\n  box_attr &= 0xFFF0;\n else\n  box_attr += 1;\n box_attr &= 0x000F;        /* Turn off bg attribute in boxed attribute */\n bga = attr & 0x00F0;     /* Capture bg attribute only from area attrib */\n box_attr |= bga;                       /* Make bg same in area and box */\n put_attr(box_attr, ulrow, ulcol, lrrow, lrcol);\n put_attr(attr, ulrow+1, ulcol+1, lrrow-1, lrcol-1);\n}\n\n/***************************************************************************/\n/* Cycle through the four box styles as the user presses Ctl-F4            */\n/***************************************************************************/\nvoid cycle_box_style() {                                         /* Ctl-F4 */\n style += 1;\n if(style > 3)\n  style = 0;\n draw_box();\n}\n\n/***************************************************************************/\n/* Cycle through text colors for the current line only.                    */\n/***************************************************************************/\nvoid cycle_line_color() {                                            /* F5 */\n if((line_attr & 0x000F) == 0x000F)\n  line_attr &= 0xFFF0;\n else\n  line_attr += 1;\n if(boxed)\n  put_attr(line_attr, c_row, ulcol+1, c_row, lrcol-1);\n else\n  put_attr(line_attr, c_row, ulcol, c_row, lrcol);\n}\n\n/***************************************************************************/\n/* Ask user for name of screen file to load, read it into a buffer and     */\n/* make it the current screen.                                             */\n/***************************************************************************/\nvoid load_screen() {                                                 /* F9 */\n char filename[80];\n char buffer[4000];\n\n scr_push();\n scr_clear(11,1,12,78);          /* Ask for filename */\n put_box(10,0,13,79,1);\n scr_puts(\"Enter name of filename containing the screen image:\",0x0F,11,2);\n filename[0] = 0x00;\n scr_gets(filename, 0x0F, 12,2,78,UPPER);\n\n if(filename[0] == 0x00) {\n  scr_pop(-1);\n  return;\n }\n if(!(read_window(buffer, filename)) == NOERROR) {\n  put_window(buffer,0,0,24,79,0,0);\n  ulrow = ulcol = boxed = c_row = c_col = 0;\n  lrrow = 24;\n  lrcol = 79;\n  attr = 0x0F;\n  set_cur(c_row, c_col, 0);\n }\n else\n  scr_pop(-1);\n}\n\n/***************************************************************************/\n/* Move cursor up 1 row within current area.                               */\n/***************************************************************************/\nvoid cursor_up_1_row(void) {\n c_row--;\n if(boxed)\n  if(c_row < ulrow+1)\n   c_row = lrrow-1;\n  else ;\n else\n  if(c_row < ulrow)\n   c_row = lrrow;\n set_cur(c_row, c_col, 0);\n}\n\n/***************************************************************************/\n/* Move cursor down 1 row within current area.                             */\n/***************************************************************************/\nvoid cursor_down_1_row(void) {\n c_row++;\n if(boxed)\n  if(c_row > lrrow-1)\n   c_row = ulrow+1;\n  else ;\n else\n  if(c_row > lrrow)\n   c_row = ulrow;\n set_cur(c_row, c_col, 0);\n}\n\n/***************************************************************************/\n/* Move cursor left 1 column within current area.                          */\n/***************************************************************************/\nvoid cursor_left_1_column(void) {\n c_col--;\n if(boxed)\n  if(c_col < ulcol+1)\n   c_col = lrcol-1;\n  else ;\n else\n  if(c_col < ulcol)\n   c_col = lrcol;\n set_cur(c_row, c_col, 0);\n}\n\n/***************************************************************************/\n/* Move cursor right one column within current area.                       */\n/***************************************************************************/\nvoid cursor_right_1_column(void) {\n c_col++;\n if(boxed)\n  if(c_col > lrcol-1)\n   c_col = ulcol+1;\n  else ;\n else\n  if(c_col > lrcol)\n   c_col = ulcol;\n set_cur(c_row, c_col, 0);\n}\n\n/***************************************************************************/\n/*  Display ascii characters on screen.                                    */\n/***************************************************************************/\nvoid ascii_chars(void) {\n if(c >= ' ') {\n  scr_putc(c, c_row, c_col, attr);\n  cursor_right_1_column();\n }\n}\n\n/*************************************************************************/\n/* First push the current screen onto the screen stack. Ask the user for */\n/* a filename. Open the file. If it exists, ask permission to write over */\n/* it. If o.k., write stacked screen image to the file. Pop current      */\n/* off the stack and return to caller.                                   */\n/*************************************************************************/\nvoid save_screen(void) {\n char filename[80];\n int remove=-1;\n\n scr_push();                 /* push current screen onto screen stack */\n scr_clear(10,0,13,79);      /* clear area for box */\n\n put_box(10,0,13,79,1);                      /* get filename for save */\n scr_puts(\"Enter filename for the screen save:\",0x0F,11,23);\n filename[0] = '\\0';\n scr_gets(filename,0x0F,12,2,79,UPPER);\n\n scr_pop(remove);         /* pop current screen back off screen stack */\n\n if(filename[0] == '\\0')                   /* Return if no name given */\n  return;\n else\n  write_window(filename);     /* else write current screen to file */\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "SCRNEDIT": {"ttr": 12554, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x03\\n\\x03\\n\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 778, "newlines": 778, "modlines": 0, "user": "BC0THOR"}, "text": "/******************************************************************/\n/* A screen editor Subsystem                                      */\n/* From \"Born to Code in C\" by Herbert Schildt                    */\n/* Modified to remove non-portable references to <dos.h>,         */\n/*          <bios.h>, and union REGS, etc. Instead, the <conio.h> */\n/*          text windowing routines are used, which have AIX      */\n/*          equivalents in the curses library.                    */\n/******************************************************************/\n\n#include <stdio.h>\n#include <string.h>\n#include <conio.h>     /* <===== remove for AIX */\n\n#define BUF_SIZE 32000\n#define KILL_BUF_SIZE 4*80\n\nchar buf[BUF_SIZE];\nchar fname[80];\nchar *curloc, *endloc;\nint scrnx, scrny;\nchar killbuf[KILL_BUF_SIZE];\nchar *helpline =\n  \"F1: Save  F2: Load  F3: Find  F4: Replace\\\n   ^K: Kill line  ^Y: Yank  ^Z: Quit\";\n\nvoid edit();\nvoid help(void);\nvoid clrline(int y);\nvoid edit_clr_eol(int x, int y);\nvoid printline(char *p);\nvoid delete_char(void);\nvoid search(void);\nvoid kill_line(void);\nvoid upline(void);\nvoid downline(void);\nvoid left(void);\nvoid right(void);\nvoid scrolldn(int x, int y);\nvoid scrollup(int topx, int topy);\nvoid display_scrn(int x, int y, char *p);\nvoid pagedown(void);\nvoid pageup(void);\nvoid replace(void);\nvoid home(void);\nvoid gotoend(void);\nvoid yank(void);\nint load();\nint save();\nvoid edit_gets(char *str);\n\nmain(int argc, char *argv[])\n{\n window(1, 1, 80, 25);        /* Text window is entire screen */\n if(argc == 2)\n  strcpy(fname,argv[1]);\n else\n  fname[0] = '\\0';\n edit();\n clrscr();\n} /* end main */\n\n/********************************************************/\n/* This is the editor's entry function and main loop.   */\n/* It is called with the name of the file to be edited. */\n/********************************************************/\nvoid edit() {\n unsigned int key;\n char name[80];\n\n if(!load(fname))             /* Try to load the file */\n  curloc = endloc = buf;\n strcpy(name, fname);\n clrscr();\n scrnx = scrny = 1;\n display_scrn(1, 1, curloc);  /* Display a screen full of text */\n help();                      /* Display help line             */\n gotoxy(1, 1);\n do                           /******* editor main loop *******/\n {\n  key = getch();         /* Read 8-bit key code */\n  if(!key)              /* This is an extended key? */\n  {\n   key = getch();         /* Read extended key code */\n   switch(key)\n   {\n    case 59:            /* F1: Save file        */\n     save();\n     break;\n    case 60:            /* F2: Load file        */\n     load();\n     break;\n    case 61:            /* F3: Search           */\n     search();\n     break;\n    case 62:            /* F4: Replace          */\n     replace();\n     break;\n    case 71:            /* HOME                 */\n     home();\n     break;\n    case 79:            /* END                  */\n     gotoend();\n     break;\n    case 75:            /* LEFT                 */\n     left();\n     break;\n    case 77:            /* RIGHT                */\n     right();\n     break;\n    case 72:            /* UP                   */\n     upline();\n     break;\n    case 80:            /* DOWN                 */\n     downline();\n     break;\n    case 73:            /* PgUp                 */\n     pageup();\n     break;\n    case 81:            /* PgDn                 */\n     pagedown();\n     break;\n    case 83:            /* Del                  */\n     if(curloc < endloc)\n       delete_char();\n     break;\n   } /* end switch */\n   if(curloc < buf)\n   {\n    scrnx = scrny = 1;\n    curloc = buf;\n   } /* end if */\n   gotoxy(scrnx, scrny);   /* position cursor      */\n  } /* end if */\n else                         /***** enter keystroke into file *****/\n  {\n   switch(key)\n   {\n    case '\\r':              /* Carriage return      */\n     if(endloc == buf + BUF_SIZE - 2)\n     break;\n     memmove(curloc+1, curloc, endloc-curloc+1); /* move down 1 */\n     *curloc = key; /* Put the CR in the file */\n     curloc++;\n     edit_clr_eol(scrnx, scrny); /* clear to eol */\n     scrnx = 1;\n     scrny++;\n     if(scrny == 25)      /* At bottom of page? */\n     {\n      scrny = 24;\n      scrollup(1, 1);\n     } /* end if */\n     else\n      scrolldn(scrnx, scrny);\n     gotoxy(scrnx, scrny);\n     printline(curloc);           /* Display the line */\n     endloc++;                    /* Advance eof pointer */\n     break;\n    case '\\b':              /* backspace */\n     if(curloc == buf)\n      break;\n     left();\n     delete_char();\n     break;\n    case 11:                /* ^K: Kill line */\n     kill_line();\n     break;\n    case 25:                /* ^Y: Yank kill buffer */\n     yank();\n     break;\n    default:                /* ordinary text character */\n     if(endloc == buf + BUF_SIZE - 2)\n     break;   /* If end of line */\n     if(scrnx == 80)\n     break;          /* Can't type past end of line */\n     memmove(curloc+1, curloc, endloc-curloc+1); /* move down 1 */\n     *curloc = key; /* Put keystroke in file */\n     putch(*curloc);      /* Display key on screen */\n     scrnx++;             /* Advance X */\n     gotoxy(scrnx, scrny);\n     printline(curloc + 1);  /* Display the line */\n     curloc++;            /* Advance the current location */\n     endloc++;            /* Advance eof pointer */\n   } /* end switch */\n  gotoxy(scrnx, scrny);\n    } /* end else */\n } /* end do */\n while(key != 26);              /* ^Z: Quit the editor */\n} /* end edit */\n\n/**********************************************************************/\n/* printline() displays a line pointed to by p. This function stops   */\n/* when it hits a carriage return or the end of the file.             */\n/**********************************************************************/\n\nvoid printline(register char *p)\n{\n register int i;\n\n i = scrnx;\n while(*p != '\\r' && *p && i < 80)\n {\n  putch(*p);\n  p++;\n  i++;\n } /* end while */\n} /* end printline */\n\n/**********************************************************************/\n/* yank() inserts a previously killed line.                           */\n/**********************************************************************/\n\nvoid yank(void)\n{\n char *p;\n\n p = killbuf;\n while(*p)\n {\n  memmove(curloc+1, curloc, endloc - curloc + 1);\n  *curloc = *p;              /* put keystroke in file */\n  if(scrnx < 80)\n  {\n   putch(*curloc);        /* display the key on the screen */\n   scrnx++;\n  } /* end if */\n  curloc++;\n  endloc++;\n  p++;\n } /* end while */\n printline(curloc);\n} /* end yank */\n\n/*********************************************************************/\n/* kill_line() deletes the line at the current location.             */\n/*********************************************************************/\n\nvoid kill_line(void)\n{\n register int i;\n char *p, *killbufptr;\n\n if(*curloc == 'r')\n {\n  delete_char();\n  return;\n } /* end if */\n edit_clr_eol(scrnx, scrny);     /* clear to CR */\n p = curloc;\n i = 0;\n killbufptr = killbuf;\n while(*p != '\\r' && p < endloc)\n {\n  i++;\n  *killbufptr = *p;           /* put in kill buffer */\n  p++;\n  if(killbufptr < killbuf + KILL_BUF_SIZE - 2)\n   killbufptr ++;\n } /* end while */\n *killbufptr = '\\0';\n memmove(curloc, curloc+1, endloc-curloc);\n endloc -= i;\n} /* end kill_line */\n\n/*******************************************************************/\n/* replace() performs global search and replace.                   */\n/*******************************************************************/\n\nvoid replace(void)\n{\n register int len1;\n char str1[80], str2[80];\n char *p, *p2;\n\n clrline(25);\n gotoxy(1, 25);\n printf(\"\\nEnter string to replace: \");\n edit_gets(str1);\n clrline(25);\n gotoxy(1,25);\n printf(\"\\nEnter replacement: \");\n edit_gets(str2);\n p = curloc;\n len1 = strlen(str1);\n while(*str1)\n {\n  while(*p && strncmp(str1, p, len1))\n   p++;\n  if(! *p)\n   break;            /* not found */\n  memmove(p, p+len1, endloc - p);    /* remove old string */\n  endloc -= len1;\n  p2 = str2;                         /* insert new string */\n  while(*p2)\n  {\n   memmove(p+1, p, endloc - p + 1);\n   *p = *p2;\n   p++;\n   endloc++;\n   p2++;\n  } /* end while */\n } /* end while */\n clrscr();\n p = curloc;                  /* find location of top of screen */\n for(len1 = scrny; len1 >= 1 && p > buf;)\n {\n  p--;\n  if(*p == '\\r')\n   len1--;\n } /* end for */\n if(*p == '\\r')\n  p++;\n display_scrn(1, 1, p);\n help();\n} /* end replace */\n\n/*********************************************************************/\n/* delete_char() deletes the character at the current location       */\n/*********************************************************************/\n\nvoid delete_char(void)\n{\n gotoxy(scrnx, scrny);\n if(*curloc == '\\r')           /* CR, scroll display */\n {\n  scrollup(1, scrny + 1);\n  memmove(curloc, curloc+1, endloc - curloc);\n  endloc--;\n  display_scrn(scrnx, scrny, curloc);\n  help();\n } /* end if */\n else\n {\n  memmove(curloc, curloc+1, endloc - curloc);\n  endloc--;\n  printline(curloc);\n  printf(\" \");\n } /* end else */\n} /* end delete_char */\n\n/*******************************************************************/\n/* help() displays the help line.                                  */\n/*******************************************************************/\n\nvoid help(void)\n{\n gotoxy(1, 25);\n printf(helpline);\n} /* end help */\n\n/********************************************************************/\n/* left() moves the current location left.                          */\n/********************************************************************/\n\nvoid left(void)\n{\n if(curloc == buf)\n  return;                /* can't go left */\n scrnx--;\n if(scrnx < 1)              /* at beginning of line */\n {\n  scrnx = 1;\n  upline();             /* go up to next line */\n  while(*curloc != '\\r')\n  {\n   curloc++;\n   scrnx++;\n  } /* end while */\n } /* end if */\n else\n  curloc--;\n} /* end left */\n\n/**********************************************************************/\n/* right() moves the current position right.                          */\n/**********************************************************************/\n\nvoid right(void)\n{\n if(curloc + 1 > endloc)\n  return;                 /* can't move right */\n scrnx++;\n if(scrnx > 80 || *curloc == '\\r')  /* at end of line? */\n {\n  scrnx = 1;\n  scrny++;\n  if(scrny == 25)  /* at end of screen? */\n  {\n   scrny = 24;\n   downline();     /* get next line */\n   curloc--;       /* move cursor and current loc to start of new line */\n   while(*curloc != '\\r')\n   curloc--;\n   curloc++;\n   scrnx = 1;\n  } /* end if */\n  else curloc++;\n } /* end if */\n else curloc++;\n} /* end right */\n\n/**********************************************************************/\n/* search() finds a string.                                           */\n/**********************************************************************/\n\nvoid search(void)\n{\n char str[80];\n register char *p;\n int len, i;\n\n clrline(25);    /* clear message line */\n gotoxy(1, 25);\n printf(\"\\nSearch string: \");\n edit_gets(str);\n if(! *str)\n  return;\n p = curloc;\n len = strlen(str);\n while(*p && strncmp(str, p, len))  /* search for the string */\n  p++;\n if(! *p) {            /* not found */\n  help();\n  return;\n }\n i = 0;      /* back up to start of line */\n while(p > buf && *p != '\\r')\n {\n  p--;\n  i++;\n } /* end while */\n p++;\n i--;\n curloc = p + i;    /* reposition current loc to start of match */\n scrnx = i + 1;\n scrny = 1;\n clrscr();    /* display screen of text at location of match */\n display_scrn(1, 1, p);\n help();\n} /* end search */\n\n/*********************************************************************/\n/* upline() moves up one line. If possible, do not change scrnx.     */\n/*********************************************************************/\n\nvoid upline(void)\n{\n register int i;\n char *p;\n\n if(curloc == buf)          /* at 1st byte in buffer? */\n  return;\n p = curloc;\n if(*p == '\\r')             /* if at end of line, back up */\n  p--;\n for(; *p != '\\r' && p > buf; p--);\n if(*p != '\\r')            /* at first line, cannot go up */\n  return;\n curloc = p;\n curloc--;                 /* skip past CR */\n i = scrnx - 1;            /* save X coordinate */\n while(*curloc != '\\r' && curloc >= buf)\n  curloc--;\n curloc++;                 /* advance past the \\r */\n scrny--;\n scrnx = 1;\n if(scrny < 1)\n {\n  scrolldn(1, 1);\n  scrny = 1;\n  gotoxy(1, 1);\n  printline(curloc);\n } /* end if */\n while(i && *curloc != '\\r') /* position t same scrnx as prev line, if poss */\n {\n  curloc++;\n  scrnx++;\n  i--;\n } /* end while */\n} /* end upline */\n\n/*********************************************************************/\n/* downline() moves down one line, trying to  keep scrnx at the same */\n/* place, if possible.                                               */\n/*********************************************************************/\n\nvoid downline(void)\n{\n register int i;\n char *p;\n i = scrnx - 1;\n p = curloc;\n while(*p != '\\r' && p < endloc)   /* advance current to next line */\n  p++;\n if(p == endloc)                   /* can't go down */\n  return;\n p++;                              /* skip past CR */\n curloc = p;\n scrny++;\n scrnx = 1;\n if(scrny == 25)\n {\n  scrny = 24;\n  scrollup(1, 1);\n  gotoxy(scrnx, scrny);\n  printline(curloc);\n } /* end if */\n while(i && *curloc != '\\r' && curloc < endloc)\n {\n  curloc++;\n  scrnx++;\n  i--;\n } /* end while */\n} /* end downline */\n\n/*******************************************************************/\n/* display_scrn() displays a screen full of text (up to 25 lines)  */\n/* starting at the specified location.                             */\n/*******************************************************************/\n\nvoid display_scrn(int x, int y, char *p)\n{\n register int i;\n\n gotoxy(x, y);\n i = 1;\n while(y < 25 && *p)\n {\n  switch(*p)\n  {\n   case '\\r':\n    printf(\"\\n\");\n    y++;\n    i = 1;\n    break;\n   default:\n    if(i < 80)\n     putch(*p);\n    i++;\n  } /* end switch */\n  p++;\n } /* end while */\n} /* end display_scrn */\n\n/********************************************************************/\n/* pagedown() will page down 25 lines.                       */\n/********************************************************************/\n\nvoid pagedown(void)\n{\n register int i;\n clrscr();\n for(i = 1; i < 25 && curloc < endloc; )\n {\n  if(*curloc == '\\r')\n   i++;\n   curloc++;\n } /* end for */\n help();\n scrnx = 1;\n scrny = 1;\n display_scrn(1, 1, curloc);\n} /* end pagedown */\n\n/******************************************************************/\n/* pageup() pages up 25 lines.                             */\n/******************************************************************/\n\nvoid pageup(void)\n{\n register int i;\n\n clrscr();\n if(*curloc == '\\r' && curloc > buf)  /* if currloc -> CR, move back 1 */\n  curloc--;\n for(i = 1; i < 26 && curloc > buf; ) /* go back 25 */\n {\n  if(*curloc == '\\r')\n   i++;\n  curloc--;\n } /* end for */\n if(i == 26)   /* if not at top line step past the CR */\n  curloc += 2;\n help();\n scrnx = 1;\n scrny = 1;\n display_scrn(1, 1, curloc);\n} /* end pageup */\n\n/********************************************************************/\n/* home() goes to the top of the file.                              */\n/********************************************************************/\n\nvoid home(void)\n{\n clrscr();\n curloc = buf;\n scrnx = scrny = 1;\n display_scrn(1, 1, curloc);\n help();\n} /* end home */\n/********************************************************************/\n/* gotoend() goes to the end of the file.                           */\n/********************************************************************/\n\nvoid gotoend(void)\n{\n clrscr();\n curloc = endloc;\n pageup();\n} /* end gotoend */\n\n/********************************************************************/\n/* load() loads a file.                                             */\n/********************************************************************/\n\nint load(char *fname)\n{\n FILE *fp;\n char ch, *p;\n\n clrline(25);\n gotoxy(1, 25);\n printf(\"\\nEnter filename: \");\n edit_gets(fname);\n\n\n if((fp = fopen(fname, \"rb\")) == NULL) {\n  help();\n  return 0;\n }\n p = buf;\n while(! feof(fp) && p != buf + BUF_SIZE - 2)\n {\n  ch = getc(fp);\n  if(ch != '\\n' && ch != EOF)\n  {\n   *p = ch;\n   p++;\n  } /* end if */\n } /* end while */\n *p = '\\0';\n fclose(fp);\n clrscr();\n curloc = buf;\n endloc = p;\n\n help();\n display_scrn(1, 1, curloc);\n scrnx = scrny = 1;\n return 1;\n} /* end load */\n\n/**********************************************************************/\n/* save() saves a file.                                               */\n/**********************************************************************/\n\nint save() {\n FILE *fp;\n char *p;\n\n clrline(25);\n gotoxy(1, 25);\n printf(\"\\nEnter filename: \");\n edit_gets(fname);\n\n if((fp = fopen(fname, \"wb\")) == NULL) {\n  help();\n  return 0;\n }\n p = buf;\n while(p != endloc)\n {\n  if(*p != '\\r')\n   putc(*p, fp);\n  else\n  {\n   putc('\\r', fp);\n   putc('\\n', fp);\n  } /* end else */\n   p++;\n } /* end while */\n fclose(fp);\n help();\n return 1;\n} /* end save */\n\n/**********************************************************************/\n/* edit_gets() read a string from the keyboard, but do not scoll the  */\n/* display when a RETURN is entered.                                  */\n/**********************************************************************/\n\nvoid edit_gets(char *str)\n{\n char *p;\n\n p = str;\n for(;;)\n {\n  *str = getch();\n  if(*str == '\\r')\n  {\n   *str = '\\0';         /*NULL terminate after CR */\n   return;\n  } /* end if */\n  if(*str == '\\b')         /* backspace */\n  {\n   if(str > p)\n   {\n    str--;\n    putch('\\b');\n    putch(' ');\n    putch('\\b');\n   } /* end if */\n  } /* end if */\n  else\n  {\n   putch(*str);\n   str++;\n  } /* end else */\n } /* end for */\n} /* end edit_gets */\n\n/**********************************************************************/\n/* clrline() clears the entire line given its Y coordinate.           */\n/**********************************************************************/\nvoid clrline(int y)\n{\n register int i;\n\n gotoxy(1,y);\n for(i = 1; i < 80; i++)\n  putch(' ');\n} /* end clrline */\n/**********************************************************************/\n/* edit_clr_eol() clears to the end of the specified line. This       */\n/* function is for the editor only because it clears a line up to a   */\n/* carriage return.                                                   */\n/**********************************************************************/\n\nvoid edit_clr_eol(int x, int y)\n{\n char *p;\n\n p = curloc;\n gotoxy(x, y);\n for(; x < 80 && *p != '\\r' && *p; x++, p++)\n {\n  printf(\" \");\n } /* end for */\n} /* end edit_clr_eol */\n\n/*********************************************************************/\n/* scrolldn() scrolls down the screen. This function scrolls all but */\n/* the bottom line.                                                  */\n/*********************************************************************/\n\nvoid scrolldn(int topx, int topy)\n{\n gotoxy(1, 24);               /* Position cursor */\n delline();                   /* Delete line 24 */\n gotoxy(topx, topy);          /* Position cursor */\n insline();                   /* Insert blank line at cursor */\n} /* end scrolldn */\n\n/*********************************************************************/\n/* scrollup() scrolls up the screen using the specified coordinates. */\n/* Scrolls all but the bottom line.                                  */\n/*********************************************************************/\n\nvoid scrollup(int topx, int topy)\n{\n gotoxy(topx, topy);          /* Position cursor */\n delline();                   /* Move lines below up 1 row */\n gotoxy(1, 24);               /* Position cursor */\n insline();                   /* Insert blank line at bottom */\n gotoxy(topx, topy);          /* Reset cursor */\n} /* end scrollup */\n\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "SCRNEDT1": {"ttr": 13060, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x03=\\x03=\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 829, "newlines": 829, "modlines": 0, "user": "BC0THOR"}, "text": "/******************************************************************/\n/* A screen editor Subsystem                                      */\n/* From \"Born to Code in C\" by Herbert Schildt                    */\n/******************************************************************/\n\n#include <stdio.h>\n#include <dos.h>\n#include <string.h>\n#include <bios.h>\n#include <conio.h>\n\n#define BUF_SIZE 32000\n#define LINE_LEN 79\n#define MAX_LINES 24\n#define KILL_BUF_SIZE 4*LINE_LEN\n\nchar buf[BUF_SIZE];\nchar *curloc, *endloc;\nint scrnx, scrny;\nchar killbuf[KILL_BUF_SIZE];\nchar *helpline =\n  \"F1: Save  F2: Load  F3: Find  F4: Replace\\\n   ^K: Kill line  ^Y: Yank  ^Z: Quit\";\n\nvoid edit(char *fname);\nvoid help(void);\nvoid gotoxy(int x, int y);\nvoid clrline(int y);\nvoid edit_clr_eol(int x, int y);\nvoid clrscr(void);\nvoid printline(char *p);\nvoid delete_char(void);\nvoid search(void);\nvoid kill_line(void);\nvoid upline(void);\nvoid downline(void);\nvoid left(void);\nvoid right(void);\nvoid scrolldn(int x, int y);\nvoid scrollup(int topx, int topy, int endx, int endy);\nvoid display_scrn(int x, int y, char *p);\nvoid pagedown(void);\nvoid pageup(void);\nvoid replace(void);\nvoid home(void);\nvoid gotoend(void);\nvoid yank(void);\nint load(char *fname);\nint save(char *fname);\nvoid edit_gets(char *str);\n\nmain(int argc, char *argv[])\n{\n if(argc == 2)\n  edit(argv[1]);\n clrscr();\n} /* end main */\n\n/********************************************************/\n/* This is the editor's entry function and main loop.   */\n/* It is called with the name of the file to be edited. */\n/********************************************************/\nvoid edit(char *fname)\n{\n union k\n {\n  char ch[2];\n  unsigned i;\n } key;\n char name[80];\n\n if(!load(fname))             /* Try to load the file */\n  curloc = endloc = buf;\n strcpy(name, fname);\n clrscr();\n scrnx = scrny = 0;\n display_scrn(0, 0, curloc);  /* Display a screen full of text */\n help();                      /* Display help line             */\n gotoxy(0, 0);\n do                           /******* editor main loop *******/\n {\n  key.i = bioskey(0);         /* Read 16-bit key code */\n  if(!key.ch[0])              /* This is a command    */\n  {\n   switch(key.ch[1])\n   {\n    case 59:            /* F1: Save file        */\n     save(name);\n     break;\n    case 60:            /* F2: Load file        */\n     clrline(MAX_LINES);\n     gotoxy(0, MAX_LINES);\n     printf(\"\\nEnter filename: \");\n     edit_gets(name);\n     if(*name)\n     load(name);\n     help();\n     display_scrn(0, 0, curloc);\n     scrnx = scrny = 0;\n     break;\n    case 61:            /* F3: Search           */\n     search();\n     break;\n    case 62:            /* F4: Replace          */\n     replace();\n     break;\n    case 71:            /* HOME                 */\n     home();\n     break;\n    case 79:            /* END                  */\n     gotoend();\n     break;\n    case 75:            /* LEFT                 */\n     left();\n     break;\n    case 77:            /* RIGHT                */\n     right();\n     break;\n    case 72:            /* UP                   */\n     upline();\n     break;\n    case 80:            /* DOWN                 */\n     downline();\n     break;\n    case 73:            /* PgUp                 */\n     pageup();\n     break;\n    case 81:            /* PgDn                 */\n     pagedown();\n     break;\n    case 83:            /* Del                  */\n     if(curloc < endloc)\n       delete_char();\n     break;\n   } /* end switch */\n   if(curloc < buf)\n   {\n    scrnx = scrny = 0;\n    curloc = buf;\n   } /* end if */\n   gotoxy(scrnx, scrny);   /* position cursor      */\n  } /* end if */\n else                         /***** enter keystroke into file *****/\n  {\n   switch(key.ch[0])\n   {\n    case '\\r':              /* Carriage return      */\n     if(endloc == buf + BUF_SIZE - 2)\n     break;\n     memmove(curloc+1, curloc, endloc-curloc+1); /* move down 1 */\n     *curloc = key.ch[0]; /* Put the CR in the file */\n     curloc++;\n     edit_clr_eol(scrnx, scrny); /* clear to eol */\n     scrnx = 0;\n     scrny++;\n     if(scrny == MAX_LINES)      /* At bottom of page? */\n     {\n      scrny = MAX_LINES - 1;\n      scrollup(0, 0, LINE_LEN, scrny);\n     } /* end if */\n     else\n      scrolldn(scrnx, scrny);\n     gotoxy(scrnx, scrny);\n     printline(curloc);           /* Display the line */\n     endloc++;                    /* Advance eof pointer */\n     break;\n    case '\\b':              /* backspace */\n     if(curloc == buf)\n      break;\n     left();\n     delete_char();\n     break;\n    case 11:                /* ^K: Kill line */\n     kill_line();\n     break;\n    case 25:                /* ^Y: Yank kill buffer */\n     yank();\n     break;\n    default:                /* ordinary text character */\n     if(endloc == buf + BUF_SIZE - 2)\n     break;   /* If end of line */\n     if(scrnx == LINE_LEN)\n     break;          /* Can't type past end of line */\n     memmove(curloc+1, curloc, endloc-curloc+1); /* move down 1 */\n     *curloc = key.ch[0]; /* Put keystroke in file */\n     putch(*curloc);      /* Display key on screen */\n     scrnx++;             /* Advance X */\n     gotoxy(scrnx, scrny);\n     printline(curloc + 1);  /* Display the line */\n     curloc++;            /* Advance the current location */\n     endloc++;            /* Advance eof pointer */\n   } /* end switch */\n  gotoxy(scrnx, scrny);\n    } /* end else */\n } /* end do */\n while(key.ch[0] != 26);              /* ^Z: Quit the editor */\n} /* end edit */\n\n/**********************************************************************/\n/* printline() displays a line pointed to by p. This function stops   */\n/* when it hits a carriage return or the end of the file.             */\n/**********************************************************************/\n\nvoid printline(register char *p)\n{\n register int i;\n\n i = scrnx;\n while(*p != '\\r' && *p && i < LINE_LEN)\n {\n  putch(*p);\n  p++;\n  i++;\n } /* end while */\n} /* end printline */\n\n/**********************************************************************/\n/* yank() inserts a previously killed line.                           */\n/**********************************************************************/\n\nvoid yank(void)\n{\n char *p;\n\n p = killbuf;\n while(*p)\n {\n  memmove(curloc+1, curloc, endloc - curloc + 1);\n  *curloc = *p;              /* put keystroke in file */\n  if(scrnx < LINE_LEN)\n  {\n   putch(*curloc);        /* display the key on the screen */\n   scrnx++;\n  } /* end if */\n  curloc++;\n  endloc++;\n  p++;\n } /* end while */\n printline(curloc);\n} /* end yank */\n\n/*********************************************************************/\n/* kill_line() deletes the line at the current location.             */\n/*********************************************************************/\n\nvoid kill_line(void)\n{\n register int i;\n char *p, *killbufptr;\n\n if(*curloc == 'r')\n {\n  delete_char();\n  return;\n } /* end if */\n edit_clr_eol(scrnx, scrny);     /* clear to CR */\n p = curloc;\n i = 0;\n killbufptr = killbuf;\n while(*p != '\\r' && p < endloc)\n {\n  i++;\n  *killbufptr = *p;           /* put in kill buffer */\n  p++;\n  if(killbufptr < killbuf + KILL_BUF_SIZE - 2)\n   killbufptr ++;\n } /* end while */\n *killbufptr = '\\0';\n memmove(curloc, curloc+1, endloc-curloc);\n endloc -= i;\n} /* end kill_line */\n\n/*******************************************************************/\n/* replace() performs global search and replace.                   */\n/*******************************************************************/\n\nvoid replace(void)\n{\n register int len1;\n char str1[80], str2[80];\n char *p, *p2;\n\n clrline(MAX_LINES);\n gotoxy(0, MAX_LINES);\n printf(\"\\nEnter string to replace: \");\n edit_gets(str1);\n clrline(MAX_LINES);\n gotoxy(0,MAX_LINES);\n printf(\"\\nEnter replacement: \");\n edit_gets(str2);\n p = curloc;\n len1 = strlen(str1);\n while(*str1)\n {\n  while(*p && strncmp(str1, p, len1))\n   p++;\n  if(! *p)\n   break;            /* not found */\n  memmove(p, p+len1, endloc - p);    /* remove old string */\n  endloc -= len1;\n  p2 = str2;                         /* insert new string */\n  while(*p2)\n  {\n   memmove(p+1, p, endloc - p + 1);\n   *p = *p2;\n   p++;\n   endloc++;\n   p2++;\n  } /* end while */\n } /* end while */\n clrscr();\n p = curloc;                  /* find location of top of screen */\n for(len1 = scrny; len1 >= 0 && p > buf;)\n {\n  p--;\n  if(*p == '\\r')\n   len1--;\n } /* end for */\n if(*p == '\\r')\n  p++;\n display_scrn(0, 0, p);\n help();\n} /* end replace */\n\n/*********************************************************************/\n/* delete_char() deletes the character at the current location       */\n/*********************************************************************/\n\nvoid delete_char(void)\n{\n gotoxy(scrnx, scrny);\n if(*curloc == '\\r')           /* CR, scroll display */\n {\n  scrollup(0, scrny + 1, LINE_LEN, MAX_LINES - 1);\n  memmove(curloc, curloc+1, endloc - curloc);\n  endloc--;\n  display_scrn(scrnx, scrny, curloc);\n  help();\n } /* end if */\n else\n {\n  memmove(curloc, curloc+1, endloc - curloc);\n  endloc--;\n  printline(curloc);\n  printf(\" \");\n } /* end else */\n} /* end delete_char */\n\n/*******************************************************************/\n/* help() displays the help line.                                  */\n/*******************************************************************/\n\nvoid help(void)\n{\n gotoxy(0, MAX_LINES);\n printf(helpline);\n} /* end help */\n\n/********************************************************************/\n/* left() moves the current location left.                          */\n/********************************************************************/\n\nvoid left(void)\n{\n if(curloc == buf)\n  return;                /* can't go left */\n scrnx--;\n if(scrnx < 0)              /* at beginning of line */\n {\n  scrnx = 0;\n  upline();             /* go up to next line */\n  while(*curloc != '\\r')\n  {\n   curloc++;\n   scrnx++;\n  } /* end while */\n } /* end if */\n else\n  curloc--;\n} /* end left */\n\n/**********************************************************************/\n/* right() moves the current position right.                          */\n/**********************************************************************/\n\nvoid right(void)\n{\n if(curloc + 1 > endloc)\n  return;                 /* can't move right */\n scrnx++;\n if(scrnx > LINE_LEN || *curloc == '\\r')  /* at end of line? */\n {\n  scrnx = 0;\n  scrny++;\n  if(scrny == MAX_LINES)  /* at end of screen? */\n  {\n   scrny = MAX_LINES - 1;\n   downline();     /* get next line */\n   curloc--;       /* move cursor and current loc to start of new line */\n   while(*curloc != '\\r')\n   curloc--;\n   curloc++;\n   scrnx = 0;\n  } /* end if */\n  else curloc++;\n } /* end if */\n else curloc++;\n} /* end right */\n\n/**********************************************************************/\n/* search() finds a string.                                           */\n/**********************************************************************/\n\nvoid search(void)\n{\n char str[80];\n register char *p;\n int len, i;\n\n clrline(MAX_LINES);    /* clear message line */\n gotoxy(0, MAX_LINES);\n printf(\"\\nSearch string: \");\n edit_gets(str);\n if(! *str)\n  return;\n p = curloc;\n len = strlen(str);\n while(*p && strncmp(str, p, len))  /* search for the string */\n  p++;\n if(! *p)            /* not found */\n  return;\n i = 0;      /* back up to start of line */\n while(p > buf && *p != '\\r')\n {\n  p--;\n  i++;\n } /* end while */\n p++;\n i--;\n curloc = p + i;    /* reposition current loc to start of match */\n scrnx = i;\n scrny = 0;\n clrscr();    /* display screen of text at location of match */\n display_scrn(0, 0, p);\n help();\n} /* end search */\n\n/*********************************************************************/\n/* upline() moves up one line. If possible, do not change scrnx.     */\n/*********************************************************************/\n\nvoid upline(void)\n{\n register int i;\n char *p;\n\n if(curloc == buf)          /* at 1st byte in buffer? */\n  return;\n p = curloc;\n if(*p == '\\r')             /* if at end of line, back up */\n  p--;\n for(; *p != '\\r' && p > buf; p--);\n if(*p != '\\r')            /* at first line, cannot go up */\n  return;\n curloc = p;\n curloc--;                 /* skip past CR */\n i = scrnx;                /* save X coordinate */\n while(*curloc != '\\r' && curloc >= buf)\n  curloc--;\n scrny--;\n scrnx = 0;\n curloc++;\n if(scrny < 0)\n {\n  scrolldn(0, 0);\n  scrny = 0;\n  gotoxy(0, 0);\n  printline(curloc);\n } /* end if */\n while(i && *curloc != '\\r') /* position t same scrnx as prev line, if poss */\n {\n  curloc++;\n  scrnx++;\n  i--;\n } /* end while */\n} /* end upline */\n\n/*********************************************************************/\n/* downline() moves down one line, trying to  keep scrnx at the same */\n/* place, if possible.                                               */\n/*********************************************************************/\n\nvoid downline(void)\n{\n register int i;\n char *p;\n i = scrnx;\n p = curloc;\n while(*p != '\\r' && p < endloc)   /* advance current to next line */\n  p++;\n if(p == endloc)                   /* can't go down */\n  return;\n p++;                              /* skip past CR */\n curloc = p;\n scrny++;\n scrnx = 0;\n if(scrny == MAX_LINES)\n {\n  scrny = MAX_LINES - 1;\n  scrollup(0, 0, LINE_LEN, MAX_LINES - 1);\n  gotoxy(scrnx, scrny);\n  printline(curloc);\n } /* end if */\n curloc++;         /* advance to same position in next line */\n while(i && *curloc != '\\r' && curloc < endloc)\n {\n  curloc++;\n  scrnx++;\n  i--;\n } /* end while */\n} /* end downline */\n\n/*******************************************************************/\n/* display_scrn() displays a screen full of text (up to 24 lines)  */\n/* starting at the specified location.                             */\n/*******************************************************************/\n\nvoid display_scrn(int x, int y, char *p)\n{\n register int i;\n\n gotoxy(x, y);\n i = 0;\n while(y < MAX_LINES && *p)\n {\n  switch(*p)\n  {\n   case '\\r':\n    printf(\"\\n\");\n    y++;\n    i = 0;\n    break;\n   default:\n    if(i < LINE_LEN)\n     putch(*p);\n    i++;\n  } /* end switch */\n  p++;\n } /* end while */\n} /* end display_scrn */\n\n/********************************************************************/\n/* pagedown() will page down MAX_LINES lines.                       */\n/********************************************************************/\n\nvoid pagedown(void)\n{\n register int i;\n clrscr();\n for(i = 0; i < MAX_LINES && curloc < endloc; )\n {\n  if(*curloc == '\\r')\n   i++;\n   curloc++;\n } /* end for */\n help();\n scrnx = 0;\n scrny = 0;\n display_scrn(0, 0, curloc);\n} /* end pagedown */\n\n/******************************************************************/\n/* pageup() pages up MAX_LINES lines.                             */\n/******************************************************************/\n\nvoid pageup(void)\n{\n register int i;\n\n clrscr();\n if(*curloc == '\\r' && curloc > buf)  /* if currloc -> CR, move back 1 */\n  curloc--;\n for(i = 0; i < MAX_LINES + 1 && curloc > buf; ) /* go back MAX_LINES */\n {\n  if(*curloc == '\\r')\n   i++;\n  curloc--;\n } /* end for */\n if(i == MAX_LINES + 1)   /* if not at top line step past the CR */\n  curloc += 2;\n help();\n scrnx = 0;\n scrny = 0;\n display_scrn(0, 0, curloc);\n} /* end pageup */\n\n/********************************************************************/\n/* home() goes to the top of the file.                              */\n/********************************************************************/\n\nvoid home(void)\n{\n clrscr();\n curloc = buf;\n scrnx = scrny = 0;\n display_scrn(0, 0, curloc);\n help();\n} /* end home */\n/********************************************************************/\n/* gotoend() goes to the end of the file.                           */\n/********************************************************************/\n\nvoid gotoend(void)\n{\n clrscr();\n curloc = endloc;\n pageup();\n} /* end gotoend */\n\n/********************************************************************/\n/* load() loads a file.                                             */\n/********************************************************************/\n\nint load(char *fname)\n{\n FILE *fp;\n char ch, *p;\n\n if((fp = fopen(fname, \"rb\")) == NULL)\n  return 0;\n p = buf;\n while(! feof(fp) && p != buf + BUF_SIZE - 2)\n {\n  ch = getc(fp);\n  if(ch != '\\n' && ch != EOF)\n  {\n   *p = ch;\n   p++;\n  } /* end if */\n } /* end while */\n *p = '\\0';\n fclose(fp);\n curloc = buf;\n endloc = p;\n return 1;\n} /* end load */\n\n/**********************************************************************/\n/* save() saves a file.                                               */\n/**********************************************************************/\n\nint save(char *fname)\n{\n FILE *fp;\n char *p, name[80];\n\n if (! *fname)\n {\n  printf(\"\\nFilename: \");\n  gets(name);\n } /* end if */\n else\n  strcpy(name, fname);\n if((fp = fopen(name, \"wb\")) == NULL)\n  return 0;\n p = buf;\n while(p != endloc)\n {\n  if(*p != '\\r')\n   putc(*p, fp);\n  else\n  {\n   putc('\\r', fp);\n   putc('\\n', fp);\n  } /* end else */\n   p++;\n } /* end while */\n fclose(fp);\n return 1;\n} /* end save */\n\n/**********************************************************************/\n/* edit_gets() read a string from the keyboard, but do not scoll the  */\n/* display when a RETURN is entered.                                  */\n/**********************************************************************/\n\nvoid edit_gets(char *str)\n{\n char *p;\n\n p = str;\n for(;;)\n {\n  *str = getch();\n  if(*str == '\\r')\n  {\n   *str = '\\0';         /*NULL terminate after CR */\n   return;\n  } /* end if */\n  if(*str == '\\b')         /* backspace */\n  {\n   if(str > p)\n   {\n    str--;\n    putch('\\b');\n    putch(' ');\n    putch('\\b');\n   } /* end if */\n  } /* end if */\n  else\n  {\n   putch(*str);\n   str++;\n  } /* end else */\n } /* end for */\n} /* end edit_gets */\n\n/**********************************************************************/\n/* cursor_pos() reads and saves the cursor coordinates.               */\n/**********************************************************************/\n\nvoid cursor_pos(void)\n{\n union REGS i, o;\n\n i.h.bh = 0;\n i.h.ah = 3;\n int86(16, &i, &o);\n} /* end cursor_pos */\n\n/**********************************************************************/\n/* gotoxy() sends cursor to specified x,y location (0,0 is upper left.*/\n/**********************************************************************/\n\nvoid gotoxy(int x, int y)\n{\n union REGS i;\n\n i.h.dh = y;\n i.h.dl = x;\n i.h.ah = 2;\n i.h.bh = 0;\n int86(16, &i, &i);\n} /* end gotoxy */\n\n/**********************************************************************/\n/* clrline() clears the entire line given its Y coordinate.           */\n/**********************************************************************/\nvoid clrline(int y)\n{\n register int i;\n\n gotoxy(0,y);\n for(i = 0; i < LINE_LEN; i++)\n  putch(' ');\n} /* end clrline */\n/**********************************************************************/\n/* edit_clr_eol() clears to the end of the specified line. This       */\n/* function is for the editor only because it clears a line up to a   */\n/* carriage return.                                                   */\n/**********************************************************************/\n\nvoid edit_clr_eol(int x, int y)\n{\n char *p;\n\n p = curloc;\n gotoxy(x, y);\n for(; x < LINE_LEN && *p != '\\r' && *p; x++, p++)\n {\n  printf(\" \");\n } /* end for */\n} /* end edit_clr_eol */\n\n/**********************************************************************/\n/* clrscr() clears the screen.                                        */\n/**********************************************************************/\n\nvoid clrscn(void)\n{\n union REGS r;\n\n r.h.ah = 6;\n r.h.al = 0;\n r.h.ch = 0;\n r.h.cl = 0;\n r.h.dh = MAX_LINES;\n r.h.dl = LINE_LEN;\n r.h.bh = 7;\n int86(0x10, &r, &r);\n} /* end clrscn */\n\n/*********************************************************************/\n/* scrolldn() scrolls down the screen. This function scrolls all but */\n/* the bottom line.                                                  */\n/*********************************************************************/\n\nvoid scrolldn(int x, int y)\n{\n union REGS r;\n\n r.h.ah = 7;\n r.h.al = 1;\n r.h.ch = y;\n r.h.cl = x;\n r.h.dh = MAX_LINES - 1;\n r.h.dl = LINE_LEN;\n r.h.bh = 7;\n int86(0x10, &r, &r);\n} /* end scrolldn */\n\n/*********************************************************************/\n/* scrollup() scrolls up the screen using the specified coordinates  */\n/*********************************************************************/\n\nvoid scrollup(int topx, int topy, int endx, int endy)\n{\n union REGS r;\n\n r.h.ah = 6;\n r.h.al = 1;\n r.h.ch = topy;\n r.h.cl = topx;\n r.h.dh = endy;\n r.h.dl = endx;\n r.h.bh = 7;\n int86(0x10, &r, &r);\n} /* end scrollup */\n\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "SETDIARY": {"ttr": 13319, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x7f\\x13G\\x02;\\x02<\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-07T13:47:00", "lines": 571, "newlines": 572, "modlines": 0, "user": "BC0THOR"}, "text": "/************/\n/* setdiary */\n/*********************************************************************/\n/* This program adds a month of new entries to an existing diary file*/\n/* and produces a new diary file as output. The user is asked for the*/\n/* month to be added, and the names of the files to be used. Any data*/\n/* for earlier or later months is copied to the new diary file as-is.*/\n/* When entries are found in the old diary for dates within the month*/\n/* being added, the data is retained in the new diary file. For all  */\n/* dates in the new month, data from the tickler file for the day-of-*/\n/* week is added to the entry created in the new diary output file.  */\n/*********************************************************************/\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n\n/*********************************************************************/\n/*               *** function prototypes ***                         */\n/*********************************************************************/\nvoid getadate(void);                /* get the year/month to process */\nvoid initiate(void);               /* initialization control routine */\nvoid opnfiles(void);                /* open the files for processing */\nvoid ldsusdta(void);               /* read suspense data into memory */\nvoid ldsusdow(void);                 /* read/store dow suspense data */\nvoid ldsusdom(void);                 /* read/store dom suspense data */\nvoid rdsusfil(void);                 /* read a line of suspense data */\nvoid rdoldfl(void);                 /* read a line of old diary file */\nvoid cmpdates(void);               /* compare old diary, today dates */\nvoid wtoldfl(void);               /* write a line into the new diary */\nvoid susdayhd(void);             /* process suspense day header line */\nvoid susdaydt(void);               /* process suspense day data line */\nvoid susmthhd(void);                  /* process day-of-month header */\nvoid susmthdt(void);                  /* process day-of-month data */\nvoid mainline(void);                  /* mainline processing control */\nvoid terminate(void);                 /* termination processing */\nvoid gtnxdaym(void);                  /* get next day in month */\nvoid cpydryln(void);             /* copy old diary line to new diary */\nvoid stnewday(void);             /* copy suspense day lines to diary */\n\n/*********************************************************************/\n/*               *** global structure definitions ***                */\n/*********************************************************************/\nstruct DATEGENL\n{\n enum {\n  julian_yyyyddd_sent = 'j',\n  gregorian_mmddyyyy_sent = 'g',\n  gregorian_yyyymmdd_sent = 'y'\n } datyp;                          /* date supplied type */\n enum {\n  successful_conversion = ' ',\n  error_in_data_supplied = 'e'\n } daterr;                         /* result indicator */\n enum {\n  Monday = '1',\n  Tuesday = '2',\n  Wednesday = '3',\n  Thursday = '4',\n  Friday = '5',\n  Saturday = '6',\n  Sunday = '7'\n } daywk;                          /* day of week indicator */\n enum {\n  not_a_holiday = ' ',\n  New_Years_Day = '1',\n  Christmas_Eve = '2',\n  Good_Friday = '3',\n  Memorial_Day = '4',\n  Independence_Day = '5',\n  Labor_Day = '6',\n  Thanksgiving_Day = '7',\n  Friday_After_Thanksgiving = '8',\n  Christmas_Day = '9'\n } holiday;                        /* holiday indicator */\n enum {\n  not_leap_year = '0',\n  leap_year = '1'\n } yeartyp;                        /* year type */\n char juldate[8];                     /* julian date yyyyddd */\n char gregmdy[9];                     /* gregorian date mmddyyyy */\n char gregymd[9];                     /* gregorian date yyyymmdd */\n char litdate[19];                  /* literal date, eg: May 9, 2002 */\n char julslash[9];                    /* julian date yy/ddd */\n char grgslash[11];                   /* gregorian date mm/dd/yyyy */\n char daylit[10];                 /* literal day of week, eg: Sunday */\n char monthlit[10];                   /* literal month, eg: July */\n};\n\nstruct DATEGENL dategenl, *p = &dategenl; /* date info */\nstruct sus_entry {                    /* define suspense table entry */\n struct sus_entry *nexline;         /* pointer to next line */\n char sus_line[81];                 /* suspense line */\n} *daywkptr[7], *daymoptr[33], *lastptr, *susptr1, *susptr2; /*pnters*/\nvoid genldat2(struct DATEGENL *p); /* genldat2 */\n\n/*********************************************************************/\n/*               *** global data definitions ***                     */\n/*********************************************************************/\nint  more_suspense_lines = 1;      /* eof for suspense file */\nint  more_old_diary_lines = 1;     /* eof for old diary file */\nint  more_days_in_month = 1;     /* end of generated month indicator */\nint  table_header = 0;             /* table header found indicator */\nint  comment_card = 0;             /* comment card found indicator */\nchar old_date;                /* buffer date : next month date indic */\nchar test_date[9];                 /* date test field */\nchar txt_buff[121];                /* file buffer */\nchar save_old_diary_line[121]; /* save area for txt_buff line */\nFILE *oldfile;                     /* pointer to old diary file */\nFILE *newfile;                     /* pointer to new diary file */\nFILE *susfile;                     /* pointer to suspense data file */\nint day_sub;                       /* day of week subscript */\nint daymth_sub;                    /* day of month subscript */\nint this_day;               /* suspense day of month being processed */\nint this_month;                    /* this month */\nint this_year;                     /* this year */\nchar first_pay[11];            /* date of a payday prior to this mth */\n\n\n/***************************************************************/\n/* Executive control routine                                   */\n/***************************************************************/\nvoid main() {\n initiate();                        /* initialize */\n mainline();                        /* process data */\n terminate();                       /* terminate processing */\n}\n/***************************************************************/\n/* Initialization control routine                              */\n/***************************************************************/\nvoid initiate(void) { /*initialization control routine */\n int i;\n\n for(i=0;i<33;i++) daymoptr[i] = NULL; /* clear pointer table */\n for(i=0;i<7;i++) daywkptr[i] = NULL; /* clear pointer table */\n getadate();                        /* get the year/month to process */\n opnfiles();                        /* open the files for processing */\n rdsusfil();                     /* read first line of suspense data */\n ldsusdta();                       /* read suspense data into memory */\n rdoldfl();                          /* read first old diary line */\n cmpdates();                       /* compare old diary, today dates */\n}\n/***************************************************************/\n/* Get the year and month to be processed.                     */\n/***************************************************************/\nvoid getadate(void) {               /* get the year/month to process */\n int i;                             /* subscript, etc */\n char string[80];                   /* utility string field */\n char cyear[5], cmonth[3]; /* character date fields */\n int error_flag = 1;\n while(error_flag) {              /* get year and month to be added */\n  printf(\"\\nEnter year and month as yyyymm (0 quits): \"); /*get date */\n  gets(string);                         /* read entered yyyymm date */\n  if(string[0] == '0')\n  exit(0);\n  if(strlen(string) != 6)\n   continue;\n  error_flag = 0;\n  strcpy(&string[6],\"01\");\n  strcpy(dategenl.gregymd,string);      /* send yyyymm01 to genldat2 */\n  dategenl.datyp = gregorian_yyyymmdd_sent;\n  genldat2(p);                          /* go check valid date */\n  if(dategenl.daterr == error_in_data_supplied)\n  error_flag = 1;\n }\n memcpy(cmonth, string+4, 2);        /* copy string value of month */\n cmonth[2] = '\\0';                   /* make string valid */\n this_month = atoi(cmonth);           /* save int value of month */\n memcpy(cyear, string, 4);        /* copy string value of year */\n cyear[4] = '\\0';                 /* make valid string */\n this_year = atoi(cyear);           /* save int value of year */\n}\n/***************************************************************/\n/* Open the files for processing                               */\n/***************************************************************/\nvoid opnfiles(void) {               /* open the files for processing */\n int error_flag = 1;\n char string[80];                   /* utility string */\n char old_diary[80];                /* old diary file name */\n char new_diary[80];                /* new diary file name */\n char sus_file[80];                 /* suspense file name */\n\n while(error_flag) {\n  printf(\"\\nEnter the suspense data file name or blank to quit: \");\n  gets(sus_file);               /* read in suspense file name */\n  if(strlen(sus_file) == 0)\n   exit(0);\n  if(sus_file[0] == ' ')\n   exit(0);\n  if((susfile = fopen(sus_file,\"rb\")) == NULL) {\n   printf(\"Can't open %s\",sus_file);\n   exit(0);\n  }\n  else\n  error_flag = 0;\n }\n error_flag = 1;\n while(error_flag) {\n  printf(\"\\nEnter the old diary file name or blank to quit: \");\n  gets(old_diary);          /* read in old diary file name */\n  if(strlen(old_diary) == 0)\n   exit(0);\n  if(old_diary[0] == ' ')\n   exit(0);\n  if((oldfile = fopen(old_diary,\"rb\")) == NULL) {\n   printf(\"Can't open %s\",old_diary);\n   exit(0);\n  }\n  else\n   error_flag = 0;\n }\n error_flag = 1;\n while(error_flag) {\n  printf(\"\\nEnter the new diary file name or blank to quit: \");\n  gets(new_diary);              /* read in new diary file name */\n  if(strlen(new_diary) == 0)\n   exit(0);\n  if(new_diary[0] == ' ')\n   exit(0);\n  if((newfile = fopen(new_diary,\"wb\")) == NULL) {\n   printf(\"Can't open %s\",new_diary);\n   exit(0);\n  }\n  else\n   error_flag = 0;\n }\n}\n/***************************************************************/\n/* Control routine for reading and storing suspense data       */\n/***************************************************************/\nvoid ldsusdta(void) {\n\n while(more_suspense_lines) {\n   if(table_header) {\n  if(memcmp(txt_buff+3, \"DOW\", 3) == 0)\n    ldsusdow();\n  else\n    if(memcmp(txt_buff+3, \"DOM\", 3) == 0)\n   ldsusdom();\n    else {\n   printf(\"\\nInvalid Suspense Data header:\");\n   printf(\"\\n%s\",txt_buff);  /* display the suspense line */\n   exit(0);\n    }\n   }\n   else {\n  printf(\"\\nSkipping until next valid header line:\");\n  printf(\"\\n%s\",txt_buff);  /* display the suspense line */\n  exit(0);\n   }\n }\n}\n/***************************************************************/\n/* Read and store the day-of-week suspense data                */\n/***************************************************************/\nvoid ldsusdow(void) {              /* read suspense data into memory */\n int i;                                /* subscript, etc */\n do {\n  rdsusfil();                       /* read a line of suspense data */\n  if(more_suspense_lines)\n   if(!(table_header))\n    if(txt_buff[0] == ' ')\n     susdaydt();                /* process suspense day data line */\n    else\n     susdayhd();                /* process suspense day header line */\n }\n while(more_suspense_lines && !table_header);\n}\n/***************************************************************/\n/* Process the suspense file day-of-week header lines          */\n/***************************************************************/\nvoid susdayhd(void) { /* process suspense day header line */\n int i;                             /* subscript, etc */\n static char day_name[7][3] = { {\"Mon\"}, {\"Tue\"}, {\"Wed\"}, {\"Thu\"},\n            {\"Fri\"}, {\"Sat\"}, {\"Sun\"} };\n\n day_sub = -1;                           /* initialize day subscript */\n for(i=0;i<7;i++)\n  if(!memcmp(txt_buff,day_name[i],3)) /* search day name table */\n   day_sub = i;\n if(day_sub == -1) {\n  printf(\"\\nInvalid day header in suspense file\\n\");\n  printf(\"\\n%s\\n\",txt_buff);\n  exit(0);\n }\n}\n/***************************************************************/\n/* Process the suspense file day-of-week data lines            */\n/***************************************************************/\nvoid susdaydt(void) {              /* process suspense day data line */\n int i, len;                         /* subscript, length, etc */\n len = strlen(txt_buff);\n len += 8;\n susptr1 = (struct sus_entry *) malloc(len); /* get memory */\n susptr1->nexline = NULL;            /* set its nexline ptr to NULL */\n strcpy(susptr1->sus_line, txt_buff); /*move txt_buff to data line*/\n if(daywkptr[day_sub] == NULL)      /* if this is the first line for */\n  daywkptr[day_sub] = susptr1;        /* a day, set the daywkptr   */\n else {\n  susptr2 = daywkptr[day_sub];          /* else locate the last */\n  while(susptr2->nexline)             /* pointer to point to  */\n   susptr2 = susptr2->nexline;     /* and set its nexline  */\n  susptr2->nexline = susptr1;         /* to this new line.    */\n }\n}\n/***************************************************************/\n/* Read and store the specific day of month suspense data      */\n/***************************************************************/\nvoid ldsusdom(void) {           /* read suspense data into memory */\n int i;                            /* subscript, etc. */\n do {\n  rdsusfil();                   /* read next line from suspense */\n  if(more_suspense_lines)\n   if(!(table_header))\n    if(txt_buff[0] == ' ')\n     susmthdt();                /* process suspense month data line */\n    else\n     susmthhd();               /* process suspense month header line */\n }\n while(more_suspense_lines && !table_header);\n}\n/***************************************************************/\n/* Process the suspense file day-of-month header lines         */\n/***************************************************************/\nvoid susmthhd(void) { /* process suspense day header line */\n int i;                             /* subscript, etc */\n int error;                         /* error indicator */\n int hdr_month, hdr_day;            /* integer values for month, day */\n char char_month[3];                     /* month of header */\n char char_day[3];                       /* day of header */\n\n memcpy(char_month, txt_buff, 2);   /* copy month value */\n char_month[2] = '\\0';              /* make valid string */\n memcpy(char_day, txt_buff+3, 2);   /* copy day value */\n char_day[2] = '\\0';                /* make string valid */\n error = 0;                         /* clear error indicator */\n if(memcmp(txt_buff, \"**\", 2) == 0) /* any month? */\n  hdr_month = this_month;           /* if \"**\" use this month */\n else\n  hdr_month = atoi(char_month);  /* convert char month to int */\n hdr_day = atoi(char_day);          /* convert char day to int */\n if(txt_buff[2] != '/') error = -1; /* slash must separate mth, day */\n if(hdr_month < 1) error = -1;      /* month must be > 0 */\n if(hdr_month > 12) error = -1;     /* month must be < 13 */\n if(memcmp(txt_buff+3 , \"LAST\", 4) == 0)   /* last day of month? */\n  hdr_day = 32;                               /* yes, set to day 32 */\n else {\n  if(hdr_day < 1) error = -1;        /* day must be > 0 */\n  if(hdr_day > 31) error = -1;       /* day must be < 32 */\n  if(hdr_day == 31)\n   if((hdr_month == 2) || (hdr_month == 4) || (hdr_month == 6) ||\n    (hdr_month == 9) || (hdr_month == 11)) error = -1;\n  if((hdr_day > 29) && (hdr_month == 2)) error = -1;\n  if(error) {\n   printf(\"\\nInvalid day-of-month header in suspense file\\n\");\n   printf(\"\\n%s\\n\",txt_buff);\n   exit(0);\n  }\n }\n if(hdr_month == this_month)\n  this_day = hdr_day;\n else\n  this_day = 0;\n}\n/***************************************************************/\n/* Process the suspense file day-of-month data lines           */\n/***************************************************************/\nvoid susmthdt(void) {              /* process suspense day data line */\n int i, len;                         /* subscript, length, etc */\n\n len = strlen(txt_buff);\n len += 8;\n if(this_day) {                    /* if processing a day-of-month */\n  susptr1 = (struct sus_entry *) malloc(len); /* get memory */\n  susptr1->nexline = NULL;            /* set its nexline ptr to NULL */\n  strcpy(susptr1->sus_line, txt_buff); /*move txt_buff to data line */\n  if(daymoptr[this_day] == NULL)    /* if this is the first line for */\n   daymoptr[this_day] = susptr1;        /* a day, set 1st daymoptr */\n  else {\n   susptr2 = daymoptr[this_day]; /* else locate the last */\n   while(susptr2->nexline)             /* pointer to point to  */\n    susptr2 = susptr2->nexline;     /* and set its nexline  */\n   susptr2->nexline = susptr1;         /* to this new line.    */\n  }\n }\n}\n/***************************************************************/\n/* Read next line of suspense data and flag end-of-file        */\n/***************************************************************/\nvoid rdsusfil(void) {               /* read a line of suspense data */\n int i;                                /* work field */\n\n table_header = 0;                  /* clear flag */\n comment_card = -1;                 /* clear flag */\n while(more_suspense_lines && comment_card) {\n  if((fgets(txt_buff,120,susfile)) == NULL)\n   if(ferror(susfile)) {\n    perror(\"\\nError reading the suspense file: \");\n    terminate();\n    exit(0);\n   }\n   else\n    more_suspense_lines = 0; /* indicate no more suspense data */\n  else {\n   i = (strlen(txt_buff)) - 2;      /* point to ending CR, NL */\n   if((txt_buff[i]) != '\\r') {\n    txt_buff[i+2] = '\\r';\n    txt_buff[i+3] = '\\n';\n    txt_buff[i+4] = '\\0';\n   }\n  if(memcmp(txt_buff, \"$$$\", 3) == 0)\n   table_header = -1;          /* indicate table header */\n  if(memcmp(txt_buff, \"/*\", 2) == 0) /* check for comments */\n   comment_card = -1;\n  else\n   comment_card = 0;\n  }\n }\n}\n/***************************************************************/\n/* Mainline processing                                         */\n/***************************************************************/\nvoid mainline(void) {                 /* mainline processing control */\n while((more_old_diary_lines) || (more_days_in_month)) {\n  if(more_days_in_month) {\n   if(more_old_diary_lines) {\n    cmpdates(); /* compare old diary, today */\n    if(old_date == '<') {\n     wtoldfl(); /* write buffer to diary */\n     rdoldfl(); /* read next old diary */\n    }\n    else {\n     strcpy(save_old_diary_line, txt_buff);\n     stnewday();            /* copy lines for this day */\n     gtnxdaym(); /* get next month date */\n     if(old_date == '>')\n      strcpy(txt_buff, save_old_diary_line);\n     else\n      rdoldfl();\n    }\n   }\n   else {\n    stnewday();               /* copy day-of-week lines */\n    gtnxdaym();                /* compute next date in month */\n   }\n  }\n  else\n   if(more_old_diary_lines) {\n    wtoldfl();               /* write buffer to new diary */\n    rdoldfl();               /* read next old diary record */\n   }\n }\n}\n/******************************************************************/\n/* Read next line of old_diary data and flag end-of-file          */\n/******************************************************************/\nvoid rdoldfl(void) {              /* read next line of old diary file*/\n if((fgets(txt_buff,120,oldfile)) == NULL)\n  if(ferror(oldfile)) {\n   perror(\"\\nError occurred reading old diary file: \");\n   terminate();\n   exit(0);\n  }\n  else\n   more_old_diary_lines = 0;\n}\n/******************************************************************/\n/* Check to see if the line read is a date header. if not, set    */\n/* the old_date indicator to '<'. If it is a date header, compare */\n/* to the next day of month in the dategenl struct. Set the       */\n/* old_date indicator to '<', '=', or '>' to show the relation.   */\n/******************************************************************/\nvoid cmpdates(void) { /*compare old diary date to current date */\n old_date = '<';               /* assume not date header or low date */\n\n if((txt_buff[2] == '/') && (txt_buff[5] == '/')) {\n  strcpy(test_date,&txt_buff[6]);        /* move year to test field */\n  memcpy(&test_date[4],txt_buff,2);      /* move month to test field */\n  memcpy(&test_date[6],&txt_buff[33],2); /* move day to test field */\n  if((memcmp(test_date,dategenl.gregymd,8)) == 0)\n   old_date = '=';\n  else if((memcmp(test_date,dategenl.gregymd,8)) > 0)\n   old_date = '>';\n }\n}\n/***************************************************************/\n/* copy suspense lines for current day of week to the new      */\n/* diary file. First, write the date header line. Next, if it  */\n/* is a holiday, write a holiday name line. Finally, write all */\n/* stored suspense lines for this day-of-week.                 */\n/***************************************************************/\nvoid stnewday(void) {       /* copy day lines for this day of week */\n int today;                  /* today numeric*/\n char this_day[3];           /* today char */\n static char holiday_name[9][445] = { {\" .New Years Day Holiday\\r\\n\"},\n       {\"    . Christmas Eve Holiday\\r\\n\"},\n       {\"    . Good Friday Holiday\\r\\n\"},\n       {\"    . Memorial Day Holiday\\r\\n\"},\n       {\"    . Independence Day Holiday\\r\\n\"},\n       {\"    . Labor Day Holiday\\r\\n\"},\n       {\"    . Thanksgiving Day Holiday\\r\\n\"},\n       {\"    . Friday After Thanksgiving Holiday\\r\\n\"},\n       {\"    . Christmas Day Holiday\\r\\n\"} };\n strcpy(txt_buff,dategenl.grgslash);      /*    new date */\n strcat(txt_buff,\" \");                    /*        header */\n strcat(txt_buff,dategenl.daylit);        /*            line */\n strcat(txt_buff,\"\\r\\n\");                 /*                   */\n wtoldfl();                            /* write new date header line */\n if(dategenl.holiday == not_a_holiday);\n else {                                   /* write holiday name line */\n  strcpy(txt_buff,holiday_name[dategenl.holiday-'1']);\n  wtoldfl();\n }\n susptr1 = daywkptr[dategenl.daywk - '1']; /* point to 1st day entry */\n while(susptr1) {\n  strcpy(txt_buff,susptr1->sus_line);   /* copy suspense line */\n  wtoldfl();                            /* write to new diary */\n  susptr1 = susptr1->nexline;           /* point to next line */\n }\n memcpy(this_day, dategenl.gregmdy+2, 2);  /* extract day of month */\n this_day[2] = '\\0';                       /* make valid string */\n today = atoi(this_day);                   /* convert it to numeric */\n susptr1 = daymoptr[today];              /* point to first day entry */\n while(susptr1) {\n  strcpy(txt_buff,susptr1->sus_line);   /* copy suspense line */\n  wtoldfl();                            /* write to new diary */\n  susptr1 = susptr1->nexline;           /* point to next line */\n }\n}\n/***************************************************************/\n/* get next day in the month being processed. if no more days  */\n/* clear the more_days_in_month flag.                          */\n/***************************************************************/\nvoid gtnxdaym(void) {               /* get next day of month */\n\n dategenl.datyp = gregorian_yyyymmdd_sent;\n dategenl.gregymd[7] ++;\n if(dategenl.gregymd[7] == '\\x3A') {\n  dategenl.gregymd[7] = '0';\n  dategenl.gregymd[6] ++;\n }\n genldat2(p);\n if(dategenl.daterr == error_in_data_supplied) { /* last day of mth?*/\n  more_days_in_month = 0;\n  susptr1 = daymoptr[32];                /* point to LAST day entry */\n  while(susptr1) {\n   strcpy(txt_buff,susptr1->sus_line);   /* copy suspense line */\n   wtoldfl();                            /* write to new diary */\n   susptr1 = susptr1->nexline;           /* point to next line */\n  }\n }\n}\n/***************************************************************/\n/* write a line to the new diary file                          */\n/***************************************************************/\nvoid wtoldfl(void) { /*write next line of new diary file*/\n\n if((fputs(txt_buff,newfile)) == EOF) {\n  perror(\"\\nError occurred writing new diary file: \");\n  terminate();\n  exit(0);\n }\n}\n/***************************************************************/\n/* Termination processing: close files                         */\n/***************************************************************/\nvoid terminate(void) {                /* termination processing */\n fclose(oldfile);                    /* close suspense file    */\n fclose(oldfile);                    /* close old diary file   */\n fclose(newfile);                    /* close new diary file   */\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SETMODE": {"ttr": 13575, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00'\\x00'\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "BC0THOR"}, "text": "/* setmode.c */\n/* sets the graphics mode to the value supplied */\n\n#include <dos.h>                     /* declares REGS */\n#define SETMODE 0                    /* \"set video mode\" service */\n#define VIDEO 0x19                   /* video BIOS interrupt number */\n#define MASK 0xCF                    /* mask for video bits in equip word */\n\nmain(argc,argv)\n\nint argc;\nchar *argv[];\n\n{\n union REGS regs;\n int mode;\n unsigned char far *farptr;          /* pointer to equip flag */\n unsigned char ch;\n unsigned char vidbits;              /* code for video card */\n\n if(argc != 2)\n    {\n     printf(\"Example usage: C>setmode 7\");\n     exit(0);\n\n    } /* end if */\n mode = atoi(argv[1]);              /* string to integer */\n if(mode == 7)                      /* if mono display */\n     vidbits = 0x30;                /* 00110000 mono card */\n else\n     vidbits = 0x10;                /* 00010000 color, 40 columns */\n farptr = (int far *) 0x410;        /* set pointer to address */\n ch = *(farptr);                    /* get byte at address */\n ch = ch & MASK;                    /* mask off video bits 11001111 */\n *(farptr) = ch | vidbits;          /* OR vidbits to equal flag */\n regs.h.al = (char) mode;           /* mode number in AL register */\n regs.h.ah = SETMODE;               /* service # in AH register */\n int86(VIDEO,&regs,&regs);          /* call video interrupt */\n} /* end main */\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "SHFTRITE": {"ttr": 13577, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00$\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x7f\\x16\\x16\\x00s\\x00s\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-07T16:16:24", "lines": 115, "newlines": 115, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* shftrite.c */\n/******************************************************************/\n/* Shifts an input ascii file right by the number of spaces       */\n/* specified by the user. Also expands tab characters to the numbe*/\n/* of spaces specified by the user. The user is prompted for the  */\n/* names of the input and output files and shift and tab amounts. */\n/* Author R Thornton September 1994                               */\n/******************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid initialize(void);                 /* initialization function */\nvoid mainline(void);                         /* mainline function */\nvoid terminate(void);                     /* termination function */\nvoid readrec(void);                   /* read next input file rec */\nvoid writerec(void);                  /* write record to out file */\n\nFILE *infile, *outfile;                   /* file handle pointers */\n\nchar innam[81];                                /* input file name */\nchar outnam[81];                              /* output file name */\n\nchar string[80];                                   /* work string */\nchar inrecord[256];                     /* input file record area */\nchar outrecord[256];                   /* output file record area */\n\n\nint i,j,k;                               /* general purpose int's */\nint morerecs = -1;                    /* input end-of-file switch */\nint shift;                                  /* right shift amount */\nint expand;                              /* amount to expand tabs */\n\n/******************************************************************/\n/* executive routine: overall program control                     */\n/******************************************************************/\nint  main() {\n  initialize();                                     /* open files */\n  while(morerecs)                       /* perform mainline until */\n    mainline();                                /* no more records */\n  terminate();                                     /* close files */\n  exit(0);                                                /* quit */\n}\n/******************************************************************/\n/* mainline function: process input file until no more records.   */\n/******************************************************************/\nvoid mainline(void) {\n  i = 0;                                /* input record subscript */\n  for(j=0;j<shift;j++)                    /* output record prefix */\n    outrecord[j] = ' ';\n  while(1) {\n    if(inrecord[i] == '\\0') {          /* terminating null found? */\n      outrecord[j] = '\\0';               /* yes, terminate output */\n      break;                                /* and the while loop */\n    }\n    if(expand) {                               /* expanding tabs? */\n      if(inrecord[i] == '\\t') {            /* yes, is this a tab? */\n        for(k=0;k<expand;k++)            /* yes, expand to spaces */\n          outrecord[j++] = ' ';\n          i++;                         /* step past the input tab */\n      }\n      else\n        outrecord[j++] = inrecord[i++];     /* not tab, just copy */\n    }\n    else\n      outrecord[j++] = inrecord[i++]; /* not expanding, just copy */\n  }\n  writerec();                           /* write an output record */\n  readrec();                            /* read next input record */\n}\n/******************************************************************/\n/* initialization: open files, read first input record.           */\n/******************************************************************/\nvoid initialize() {\n  printf(\"\\nEnter input file spec: \");  /* ask for input filename */\n    gets(innam);                                /* and read it in */\n  printf(\"\\nEnter output file spec: \"); /* ask for output filename*/\n    gets(outnam);                               /* and read it in */\n  if((infile=fopen(innam,\"rb\")) == NULL) {          /* open input */\n    printf(\"Can't open file %s.\",innam);   /* open failed message */\n    exit(1);                                         /* terminate */\n  }\n  if((outfile=fopen(outnam,\"wb\")) == NULL) {       /* open output */\n    printf(\"Can't open file %s.\",outnam);\n    exit(1);\n  }\n  printf(\"\\nEnter number spaces to shift records right: \");\n  gets(string);                               /* get shift number */\n  shift = atoi(string);                /* convert ascii to binary */\n  printf(\"\\nEnter number spaces to substitute for tabs: \");\n  gets(string);                                 /* get tab amount */\n  expand = atoi(string);               /* convert ascii to binary */\n  readrec();                      /* read first input file record */\n}\n/******************************************************************/\n/* read next input file record. at end of file, set morerecs switc*/\n/******************************************************************/\nvoid readrec() {\n  if(fgets(inrecord,255,infile) == NULL)  /* read input until eof */\n    morerecs = 0;                    /* set switch at end of file */\n}\n/******************************************************************/\n/* write a record to the output file                              */\n/******************************************************************/\nvoid writerec() {\n  fputs(outrecord,outfile);                /* write output record */\n}\n/******************************************************************/\n/* termination: close files                                       */\n/******************************************************************/\nvoid terminate() {\n  fclose(infile);                             /* close input file */\n  fclose(outfile);                           /* close output file */\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "SKELETON": {"ttr": 13580, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x10\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x7f\\x16D\\x01w\\x01x\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-07T16:44:10", "lines": 375, "newlines": 376, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* skeleton.c */\n/*******************************************************************/\n/* Generic c program that includes an input file, output file,     */\n/* print file, edit subroutine,                                    */\n/*                                                                 */\n/* Author R Thornton September 1993                                */\n/*******************************************************************/\n#define _ALL_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\nvoid initiate(int argc, char *argv[]);  /* initialization function */\nvoid mainline(void);                          /* mainline function */\nvoid terminat(void);                       /* termination function */\nvoid readrec(void);                 /* read next input file record */\nvoid writerec(void);                /* write record to output file */\nvoid printline(void);               /* print a line to report file */\nint edit(char output[], char pattern[], char number[]);    /* edit */\nvoid headings(void);                       /* print report heading */\n\nFILE *infile, *outfile, *prtfile;          /* file handle pointers */\nchar innam[81];                                 /* input file name */\nchar outnam[81];                               /* output file name */\nchar prtnam[81] = \"prn\";                        /* print file name */\n\nchar prtline[135];                            /* print line buffer */\nchar inrecord[256];                      /* input file record area */\nchar outrecord[256];                    /* output file record area */\n\nchar *h1ptr;                             /* heading line 1 pointer */\nstruct {                                     /* first heading line */\n  char hdr_skip;                                      /* form feed */\n  char hdr_date[10];                                /* report date */\n  char ctr1[45];                               /* centering blanks */\n  char title_line[21];                    /* centered report title */\n  char ctr2[45];                               /* centering blanks */\n  char page_lit[5];                                /* page literal */\n  char page_nbr[6];                                 /* page number */\n  char newline;                               /* newline character */\n  char null_byte;                              /* terminating null */\n} header1;\n\nint i;                                      /* general purpose int */\nchar number[32];                       /* ascii numbers for edit() */\nint morerecs = -1;                     /* input end-of-file switch */\nlong incount = 0;                          /* input record counter */\nlong outcount = 0;                        /* output record counter */\nint linecnt = 0;                             /* print line counter */\nint pagecnt = 0;                             /* print page counter */\nstruct tm *t;                         /* pointer to time structure */\ntime_t seconds;                             /* current timer value */\n\n\nvoid main(int argc, char *argv[]) {\n  initiate(argc, argv);                              /* open files */\n  while(morerecs)                        /* perform mainline until */\n  mainline();                                   /* no more records */\n  terminat();                                       /* close files */\n  exit(0);                                                 /* quit */\n}\n/*******************************************************************/\n/* mainline function: process input file until no more records.    */\n/*******************************************************************/\nvoid mainline(void) {\n  strcpy(prtline,inrecord);          /* move input record to print */\n  printline();                                     /* and print it */\n  strcpy(outrecord,inrecord);       /* move input record to output */\n  writerec();                            /* write an output record */\n  readrec();                             /* read next input record */\n}\n/*******************************************************************/\n/* initialization: open files, read first input record.            */\n/*******************************************************************/\nvoid initiate(int argc, char *argv[]) {\n  if(argc == 3) {\n    strcpy(innam,argv[1]);\n    strcpy(outnam,argv[2]);\n  }\n  else\n    if(argc == 4) {\n      strcpy(innam,argv[1]);\n      strcpy(outnam,argv[2]);\n      strcpy(prtnam,argv[3]);\n    }\n    else {\n      printf(\"\\nEnter input file spec: \");\n      gets(innam);\n      printf(\"\\nEnter output file spec: \");\n      gets(outnam);\n      printf(\"\\nEnter output file spec (or prn): \");\n      gets(prtnam);\n    }\n  if((infile=fopen(innam,\"rb\")) == NULL) {           /* open input */\n    printf(\"Can't open file %s.\",innam);\n    exit(1);\n  }\n  if((outfile=fopen(outnam,\"wb\")) == NULL) {        /* open output */\n    printf(\"Can't open file %s.\",outnam);\n    exit(1);\n  }\n  if((prtfile=fopen(prtnam,\"w\"))==NULL) {       /* open print file */\n    printf(\"\\nCan't open the printer file.\");\n    exit(1);\n  }\n  h1ptr = (char *)&header1;               /* point to header1 line */\n  for(i=0;i<133;i++)                          /* clear header line */\n  h1ptr[i] = ' ';\n  header1.hdr_skip = '\\f';             /* form feed to header line */\n  memcpy(header1.title_line,\"SKELETON REPORT TITLE\",21);\n  timezone = 5 * 60 * 60;              /* set local time for e.s.t */\n  daylight = -1;                       /* indicate daylit sav time */\n  time(&seconds);                                  /* time in secs */\n  t = localtime(&seconds);              /* local time to tm struct */\n  sprintf(header1.hdr_date,\"%2d/%2d/%2d\",\n           t->tm_mon,t->tm_mday,t->tm_year);\n  header1.hdr_date[8] = ' ';             /* clear terminating null */\n  memcpy(header1.page_lit,\"PAGE \",5);    /* PAGE literal to header */\n  prtline[133] = '\\0';                /* terminal null to prt line */\n  headings();                               /* write first heading */\n  readrec();                       /* read first input file record */\n}\n/*******************************************************************/\n/* read next input file record. at end of file, set morerecs switch*/\n/*******************************************************************/\nvoid readrec() {\n  if(fgets(inrecord,255,infile) == NULL)   /* read input until eof */\n    morerecs = 0;                     /* set switch at end of file */\n  if(morerecs)\n    incount++;                            /* add 1 to records read */\n}\n/*******************************************************************/\n/* write a record to the output file                               */\n/*******************************************************************/\nvoid writerec() {\n  fputs(outrecord,outfile);                 /* write output record */\n  outcount++;                          /* add 1 to records written */\n}\n/*******************************************************************/\n/* write a line to the printer                                     */\n/*******************************************************************/\nvoid printline() {\n  prtline[133] = '\\n';           /* terminal newline to print line */\n  prtline[134] = '\\0';              /* terminal null to print line */\n  fputs(prtline,prtfile);                      /* write print line */\n  linecnt++;                              /* add 1 to line counter */\n  if(linecnt > 56)                        /* check for end of page */\n    headings();                            /* if eop, write header */\n  else\n    for(i=0;i<133;i++)\n      prtline[i] = ' ';             /* clear print line to spaces. */\n}\n/*******************************************************************/\n/* write a report heading                                          */\n/*******************************************************************/\nvoid headings() {\n  linecnt = 0;                               /* clear line counter */\n  pagecnt++;                              /* add 1 to page counter */\n  sprintf(number,\"%d\",pagecnt);        /* convert to printable nbr */\n  edit(header1.page_nbr,\"zz,zz9\",number);  /* page nbr to hdr line */\n  header1.newline = '\\n';            /* terminal newline to header */\n  header1.null_byte = '\\0';             /* terminal null to header */\n  fputs((char *)&header1,prtfile);            /* write header line */\n  for(i=0;i<133;i++)\n    prtline[i] = ' ';                          /* clear print line */\n  prtline[133] = '\\n';           /* terminal newline to print line */\n  prtline[134] = '\\0';              /* terminal null to print line */\n  fputs(prtline,prtfile);              /* blank line after heading */\n}\n/*******************************************************************/\n/* The edit function provides numeric report editing, including    */\n/* leading zero suppression, check protection, floating $, leading */\n/* or trailing minus sign, insertion of commas, decimal points and */\n/* other non-numeric fields. The first parameter is the address of */\n/* the edited output, whose size will be the same as the pattern.  */\n/* The second parameter is the editing pattern, which must be a tru*/\n/* null-terminated string containing the edit pattern. The third   */\n/* is the number to be edited, a null-terminated string containing */\n/* only digits 0-9 except the first position, which is a -, if the */\n/* number is negative. The pattern may be up to 64 characters, and */\n/* the number to be edited may contain up to 32 characters. The    */\n/* number may not contain more significant digits than there are   */\n/* digit select characters in the pattern. If there are more digits*/\n/* selected by the pattern than there are in the number, leading   */\n/* zeros will be assumed. In the pattern, the first character may  */\n/* be:      $ (floating dollar sign)                               */\n/*          * (check protection)                                   */\n/*          - (floating minus sign)                                */\n/* The body of the edit pattern will be composed of digit select   */\n/* characters (z and 9) and other characters, handled as follows:  */\n/*          z (zero suppression output is a blank in this position */\n/*             until significance is set by receipt of a significan*/\n/*             digit or a 9 in the pattern. After significance is  */\n/*             set, output is a digit from the number.)            */\n/*          9 (output is a digit from the number and significance  */\n/*             is set, even if the digit is a leading zero.)       */\n/*        other characters in the pattern will be output as-is afte*/\n/*             significance is set, but will be output as blanks   */\n/*             before significance is set.                         */\n/* Characters in the pattern following the last digit select will  */\n/* be output as-is if the number is negative, otherwise output will*/\n/* be blanks for these pattern positions.                          */\n/*                                                                 */\n/* When * check protection is selected, output will be *, rather   */\n/* than blanks as mentioned above.                                 */\n/*                                                                 */\n/* An integer is returned to indicate success or errors:           */\n/*                 0 = successful edit                             */\n/*                 1 = pattern too long (over 64 characters)       */\n/*                 2 = too many digits selected (over 32)          */\n/*                 3 = no output digits selected in pattern        */\n/*                 4 = number contains non-numeric data            */\n/*                 5 = number has more digits than the pattern     */\n/*                                                                 */\n/* Examples:                            nbr=             outf=     */\n/*    err=edit(outf,\"zz,zz9.99-\",nbr);  0                     0.00 */\n/*                                      123                   1.23 */\n/*                                      562983            5,629.83 */\n/*                                      -4675                46.75-*/\n/*    err=edit(outf,\"$,$$$.$$\",nbr);    0                          */\n/*                                      123                  $1.23 */\n/*                                      562983           $5,629.83 */\n/*                                      -4675               $46.75 */\n/*    err=edit(outf,\"***.**\",nbr);      0                          */\n/*                                      123                 **1.23 */\n/*                                      562983   err = 5           */\n/*                                      -4675               *46.75 */\n/*    err=edit(outf,\"--,--9.99\",nbr);   0                     0.00 */\n/*                                      123                   1.23 */\n/*                                      562983            5,629.83 */\n/*                                      -46.75              -46.75 */\n/*                                                                 */\n/* Author R Thornton April 1989                                    */\n/*******************************************************************/\nint edit(char output[], char pattern[], char number[]) {\n  char float_val = ' ';\n  char fill_val = ' ';\n  char sign_val = ' ';\n  int signif = 0;\n  int psize = 0;\n  int pdig = 0;\n  int plast = 0;\n  int ndig = 0;\n  char nbr[33];\n  char ch= ' ';\n  int po=0;\n  int n=0;\n\n/*******************************************************************/\n/* examine pattern: set up float and fill, count size and digits   */\n/*******************************************************************/\n  if(((ch=pattern[0]) == '$') || (ch == '*') || (ch == '-'))\n    float_val = ch;\n  if(ch == '*')\n    fill_val = '*';\n  while((ch=pattern[po]) != '\\0') {\n    if((ch == 'z') || (ch == '9')) {\n      pdig++;\n      plast = po;\n    }\n    psize++;\n    po++;\n  }\n  if(psize > 63)\n    return(1);\n  if(pdig > 32)\n    return(2);\n  if(!pdig)\n    return(3);\n/*******************************************************************/\n/* examine number: set up sign, count digits, check numeric.       */\n/* set error if more digits than pattern, move right justified     */\n/*******************************************************************/\n  if(number[0] == '-') {\n    sign_val = '-';\n    n = 1;\n  }\n  while((ch=number[n]) != '\\0') {\n    if((ch < '0') || (ch > '9'))\n      return(4);\n    ndig++;\n    n++;\n  }\n  if(ndig > pdig)\n    return(5);\n  for(po=0;po<(pdig-ndig);po++)\n    nbr[po] = '0';\n  if(sign_val == ' ')\n    n = 0;\n  else\n    n=1;\n  for(;po<pdig;po++,n++)\n    nbr[po] = number[n];\n/*******************************************************************/\n/* scan across the pattern, setting the corresponding output       */\n/* byte from pattern, fill, or amt depending on the pattern        */\n/* character and state of significance.                            */\n/*******************************************************************/\n  if(float_val != ' ') {\n    output[0] = ' ';\n    po = 1;\n  }\n  else\n    po = 0;\n  n = 0;\n  while((po <= plast)) {\n    ch = pattern[po];\n    if(ch == 'z') {\n      if(signif) {\n        output[po] = nbr[n];\n        n++;\n      }\n      else {\n        if(nbr[n] == '0') {\n          output[po] = fill_val;\n          n++;\n        }\n        else {\n          output[po] = nbr[n];\n          signif = -1;\n          n++;\n          if(float_val == ' ')\n            ;\n          else\n            if((float_val == '$') || (sign_val == '-'))\n              output[po-1] = float_val;\n        }\n      }\n    }\n    else if(ch == '9') {\n      output[po] = nbr[n];\n      if(!signif) {\n        signif = -1;\n        if(float_val == ' ')\n          ;\n        else\n          if((float_val == '$') || (sign_val == '-'))\n            output[po-1] = float_val;\n      }\n      n++;\n    }\n    else {\n      if(signif)\n        output[po] = pattern[po];\n      else\n        output[po] = fill_val;\n    }\n    po++;\n  }\n  while((ch=pattern[po]) != '\\0') {\n    if(sign_val == ' ')\n      output[po++] = fill_val;\n    else\n      output[po++] = pattern[po];\n  }\n  return(0);\n}\n/*******************************************************************/\n/* termination: close files                                        */\n/*******************************************************************/\nvoid terminat() {\n  sprintf(number,\"%ld\",incount);   /* convert input count to ascii */\n  edit(prtline, \"zz,zzz,zz9\", number);   /* edit number to prtline */\n  strcpy(prtline+10,\" input records read\");      /* message to prt */\n  printline();                                      /* print count */\n  sprintf(number,\"%ld\",outcount);  /* convert input count to ascii */\n  edit(prtline, \"zz,zzz,zz9\", number);   /* edit number to prtline */\n  strcpy(prtline+10,\" output records written\");  /* message to prt */\n  printline();                                      /* print count */\n  fclose(infile);                                   /* close files */\n  fclose(outfile);\n  fclose(prtfile);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "SMLINT": {"ttr": 13830, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00X\\x00X\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 88, "newlines": 88, "modlines": 0, "user": "BC0THOR"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "SORT": {"ttr": 13833, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x01\\x19\\x01\\x19\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 281, "newlines": 281, "modlines": 0, "user": "BC0THOR"}, "text": "/* PROGRAM-ID:  SORT\n          */\n/* AUTHOR:  JEFF KEELING\n          */\n/* DATE WRITTEN: APRIL 1989\n          */\n/* REMARKS:  The first function, sort_logfile(), reads in a file and sorts the r\necords    */\n/*           on two designated fields.  It gives the record number and the sort\nfields    */\n/*           to a temporary structure that is dynamically created to contain onl\ny as      */\n/*           many records as the input file contains.  This program sorts first\non        */\n/*           pend_code and then by claim number.  We need only store a record nu\nmber      */\n/*           and two sort fields (for each record in the input file) in temporar\ny memory. */\n/*           We then use the values in the temporary structure to read the corre\nsponding  */\n/*           record in the input file and print this record out to a new sorted\nfile.     */\n/*           We perform these two actions for each record in the temporary struc\nture.     */\n/*           The final product is a new file that contains the sorted records of\n the      */\n/*           input file.  This function is called by the Approve/Deny/Pend - Exe\ncution    */\n/*           program.\n          */\n/*                The sort_summfile() function is the second function and sorts\nthe       */\n/*           summary file on pend code only.  This function is called by the Sta\ntistical  */\n/*           program.\n          */\n\n#include <stdio.h>\n         /* library include files */\n#include <stdlib.h>\n#include <search.h>\n#include <memory.h>\n#include <string.h>\n#include <io.h>\n\nstatic char logfile_name[] = \"c:\\\\c\\\\data\\\\logfile.dat\";\n         /* exterior file association */\nstatic char sorted_logfile_name[] = \"c:\\\\c\\\\data\\\\sort_log.dat\";\n\nFILE  *logfile_ptr=NULL, *sorted_logfile_ptr=NULL;\n         /* pointers to files */\n\n   struct log_structure\n         /* structure for input log file */\n   {\n      char claim_number[9];\n      char subscriber_ID[15];\n      char log_year[2];\n      char log_month[2];\n      char log_day[2];\n      char pend_code[2];\n      char pend_text[25];\n      char MedScreen_status_code[1];\n      char MedScreen_reason_code[2];\n      char MedScreen_reason_text[25];\n      char filler[15];\n      char new_line_ch[1];\n      char carriage_return[1];\n   } logfile;\n\n   struct log_sort_structure\n         /* temporary sorting structure */\n   {\n      int  record_number;\n      char pend_code[2];\n      char claim_number[9];\n   } *log_ptr, *first_log_ptr;\n\n   int zero = 0;\n\n\ncompare(struct log_sort_structure *arg1, struct log_sort_structure *arg2);\n         /* prototype of compare() */\n\nFILE * sort_logfile(void)\n{\nint i;\nlong number_of_records;\nlong file_size;\nlong offset;\n\n   if ( (logfile_ptr = fopen(logfile_name,\"rb\")) == NULL)\n         /* open input log file */\n      {\n      printf(\"\\nThe log file cannot be opened.  The program is exiting.\");\n      exit(zero);\n      }\n\n   file_size = filelength(fileno(logfile_ptr));\n         /* allocate size of temporary structure */\n   number_of_records = file_size/sizeof(logfile);\n   log_ptr = calloc(number_of_records,sizeof(struct log_sort_structure));\n   first_log_ptr = log_ptr;\n         /* set pointer to beginning of */\n            /* temporary memory buffer */\n   for (i=zero; i<number_of_records; i++)\n         /* move sort fields from logfile record */\n      {\n         /* to temporary structure record */\n      fread(&logfile,sizeof(logfile),1,logfile_ptr);\n      memcpy(log_ptr->pend_code,logfile.pend_code,2);\n      memcpy(log_ptr->claim_number,logfile.claim_number,9);\n      log_ptr->record_number = i;\n      log_ptr++;\n      }\n\n   fclose(logfile_ptr);\n            /* call sort routine */\n   qsort(first_log_ptr,number_of_records,sizeof(struct log_sort_structure),compa\nre);\n\n   log_ptr = first_log_ptr;\n         /* set pointer to first record of */\n            /* temporary structure */\n   if ( (logfile_ptr = fopen(logfile_name,\"rb\")) == NULL)\n         /* open input log file */\n      {\n      printf(\"\\nThe log file cannot be opened.  The program is exiting.\");\n      exit(zero);\n      }\n   if ( (sorted_logfile_ptr = fopen(sorted_logfile_name,\"w+b\")) == NULL)\n         /* open new file for sorted records */\n      {\n      printf(\"\\nThe sorted log file cannot be opened.  The program is exiting.\")\n;\n      exit(zero);\n      }\n   for (i=zero; i<number_of_records; i++,log_ptr++)\n      {\n         /* load sorted records to new file */\n      offset = log_ptr->record_number * sizeof(logfile);\n      if (fseek(logfile_ptr,offset,zero) != zero)\n\n  {\n  printf(\"\\nCan't move pointer to specified record.\\nThe program is exiting.\");\n  exit(zero);\n  }\n      fread(&logfile,sizeof(logfile),1,logfile_ptr);\n\n      fwrite(&logfile,sizeof(logfile),1,sorted_logfile_ptr);\n      }\nfclose(logfile_ptr);\nfclose(sorted_logfile_ptr);\n\nreturn(sorted_logfile_ptr);\n}\n\ncompare(struct log_sort_structure *arg1, struct log_sort_structure *arg2)\n/* This function compares pend codes first then claim numbers */\n/* from two records and returns a code to qsort.              */\n{\n      return (memicmp(arg1->pend_code,arg2->pend_code,11));\n}\n\n\n\n\n\n\n\n\n/******************** Statistical Sorting ********************************/\n\nstatic char summfile_name[] = \"c:\\\\c\\\\data\\\\summfile.dat\";\nstatic char sorted_summfile_name[] = \"c:\\\\c\\\\data\\\\sort_sum.dat\";\n\nFILE  *summfile_ptr=NULL, *sorted_summfile_ptr=NULL;\n         /* pointers to files */\n\n   struct summ_structure\n         /* stucture for output summary file */\n   {\n      char log_year[2];\n      char log_month[2];\n      char log_day[2];\n      char pend_code[2];\n      char pend_text[25];\n      char approve_totals[7];\n      char deny_totals[7];\n      char pend_totals[7];\n      char new_line_ch[1];\n   } summfile;\n\n   struct summ_sort_structure\n         /* temporary sorting structure */\n   {\n      int  record_number;\n      char pend_code[2];\n   } *summ_ptr, *first_summ_ptr;\n\n\ncompare2(struct summ_sort_structure *arg1, struct summ_sort_structure *arg2);\n         /* prototype of copare() */\n\nFILE * sort_summfile(void)\n{\nint i;\nlong number_of_records;\nlong file_size;\nlong offset;\n\n   if ( (summfile_ptr = fopen(summfile_name,\"rt\")) == NULL)\n         /* open input summary file */\n      {\n      printf(\"\\nThe summary file cannot be opened.  The program is exiting.\");\n      exit(zero);\n      }\n   file_size = filelength(fileno(summfile_ptr));\n         /* allocate size of temporary structure */\n   number_of_records = file_size/sizeof(summfile);\n   summ_ptr = calloc(number_of_records,sizeof(struct summ_sort_structure));\n   first_summ_ptr = summ_ptr;\n         /* set pointer to beginning of temporary */\n            /* memory buffer */\n   for (i=zero; i<number_of_records; i++)\n         /* move sort fields from summary file record */\n      {\n         /* to temporary structure record */\n      fread(&summfile,sizeof(summfile),1,summfile_ptr);\n      memcpy(summ_ptr->pend_code,summfile.pend_code,2);\n      summ_ptr->record_number = i;\n      summ_ptr++;\n      }\n\n   fclose(summfile_ptr);\n            /* call sort routine */\n   qsort(first_summ_ptr,number_of_records,sizeof(struct summ_sort_structure),com\npare2);\n\n   summ_ptr = first_summ_ptr;\n         /* set pointer to first recrd of temporary */\n            /* structure */\n   if ( (summfile_ptr = fopen(summfile_name,\"rt\")) == NULL)\n         /* open input summary file */\n      {\n      printf(\"\\nThe summary file cannot be opened.  The program is exiting.\");\n      exit(zero);\n      }\n   if ( (sorted_summfile_ptr = fopen(sorted_summfile_name,\"w+t\")) == NULL)\n         /* open new file for sorted records */\n      {\n      printf(\"\\nThe file for the sorted summary records cannot be opened.\");\n      printf(\"\\nThe program is exiting.\");\n      exit(zero);\n      }\n   for (i=zero; i<number_of_records; i++,summ_ptr++)\n      {\n         /* load sorted records to new file */\n      offset = summ_ptr->record_number * sizeof(summfile);\n      if (fseek(summfile_ptr,offset,zero) != zero)\n  {\n  printf(\"\\nCan't move pointer to specified record.\\nThe program is exiting.\");\n  exit(zero);\n  }\n      fread(&summfile,sizeof(summfile),1,summfile_ptr);\n\n      fwrite(&summfile,sizeof(summfile),1,sorted_summfile_ptr);\n      }\nfclose(summfile_ptr);\nfclose(sorted_summfile_ptr);\n\nreturn(sorted_summfile_ptr);\n}\n\n\ncompare2(struct summ_sort_structure *arg1, struct summ_sort_structure *arg2)\n/* This function compares pend codes first then claim numbers */\n/* from two records and returns a code to qsort.              */\n{\n      return (memicmp(arg1->pend_code,arg2->pend_code,2));\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SORTNUM": {"ttr": 14082, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x08\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x8f\\x08E\\x00'\\x00(\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-08T08:45:08", "lines": 39, "newlines": 40, "modlines": 0, "user": "BC0THOR"}, "text": "/*************/\n/* sortnum.c */\n/**********************************/\n/* bubble sort of a numeric array */\n/**********************************/\n#define MAXSIZE 20\n#include <stdio.h>\nmain() {\n  static int list[MAXSIZE];\n  unsigned int size=0,i;\n  void sort(unsigned int, int[]);\n\n  do {\n    printf(\"Enter a number for the sort (minus number at end): \");\n    scanf(\"%d\",&list[size]);\n  }\n  while(list[size++]>=0);\n    size--;\n  sort(size,list);\n\n  printf(\"\\nThe sorted list is: \");\n  for(i=0;i<size;i++)\n    printf(\"\\n%d\",list[i]);\n\n  printf(\"\\n\");\n}\n\nvoid sort(unsigned int size, int list[MAXSIZE]) {\n  unsigned int outer,inner;\n  int hold;\n\n  for(outer=0;outer<size;outer++)\n    for(inner=(outer+1);inner<size;inner++)\n      if(list[outer]>list[inner]) {\n        hold=list[outer];\n        list[outer]=list[inner];\n        list[inner]=hold;\n    }\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "SORTSTR": {"ttr": 14084, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x16\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x8f\\x08H\\x00$\\x00#\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-08T08:48:16", "lines": 36, "newlines": 35, "modlines": 0, "user": "BC0THOR"}, "text": "/*************/\n/* sortstr.c */\n/*****************************************/\n/* sorts list of names typed in to array */\n/*****************************************/\n#define MAXNUM 30\n#define MAXLEN 81\n#include <stdio.h>\n#include <string.h>\n\nmain() {\n  static char name[MAXNUM][MAXLEN];\n  char *ptr[MAXNUM];\n  char *temp;\n  int count=0;\n  int in,out;\n\n  while(count < MAXNUM) {\n    printf(\"Name %d: \",count+1);\n    gets(name[count]);\n    if(strlen(name[count])==0)\n    break;\n    ptr[count++]=name[count];\n  }\n\n  for(out=0;out<count-1;out++)\n    for(in=out+1;in<count;in++)\n      if(strcmp(ptr[out],ptr[in])>0) {\n        temp=ptr[in];\n        ptr[in]=ptr[out];\n        ptr[out]=temp;\n      }\n  printf(\"\\nSorted list: \\n\");\n  for(out=0;out<count;out++)\n    printf(\"Name %d: %s\\n\",out+1,ptr[out]);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "SPAWN": {"ttr": 14086, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00-\\x00-\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "BC0THOR"}, "text": "spawnl\n/* spawnl example */\n\n/* spawnl() and spawnle() example */\n\n#include <process.h>\n#include <stdio.h>\n#include <conio.h>\n\nvoid spawnl_example(void)\n{\n   int result;\n\n   clrscr();\n   result = spawnl(P_WAIT, \"bcc.exe\", NULL);\n   if (result == -1)\n   {\n      perror(\"Error from spawnl\");\n      exit(1);\n   }\n}\n\n\nvoid spawnle_example(void)\n{\n   int result;\n\n   clrscr();\n   result = spawnle(P_WAIT, \"bcc.exe\", NULL,\nNULL);\n   if (result == -1)\n   {\n      perror(\"Error from spawnle\");\n      exit(1);\n   }\n}\n\nint main(void)\n{\n  spawnl_example();\n  spawnle_example();\n  return 0;\n}\n\n\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "SPAWNFAM": {"ttr": 14088, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00\\x1b\\x00\\x1b\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "BC0THOR"}, "text": "/* This program is SPAWNFAM.C */\n#include <stdio.h>\n#include <process.h>\n\nvoid status(int val) {\n if(val == -1)\n  printf(\"\\nFailed to start child process.\");\n else\n  if(val > 0)\n   printf(\"\\nChild terminated abnormally.\");\n}\n\nvoid main() {\n char *envp[] = {\"PATH=C:\\\\\",\"DUMMY=YES\"}; /* environment string */\n char *pathname = \"C:\\\\TC\\\\OUTPUT\\\\CHILD.EXE\"; /* pathname */\n char *args[] = {\"CHILD.EXE\",\"1st\",\"2nd\",NULL}; /* arguments */\n printf(\"\\nSPAWNL:\");\n status(spawnl(P_WAIT, pathname, args[0], args[1], NULL));\n printf(\"\\nSPAWNV:\");\n status(spawnv(P_WAIT, pathname, args));\n printf(\"\\nSPAWNLE:\");\n status(spawnle(P_WAIT, pathname, args[0], args[1], NULL, envp));\n printf(\"\\nSPAWNVPE:\");\n status(spawnvpe(P_WAIT, pathname, args, envp));\n\n\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "SPLIT4": {"ttr": 14090, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00W\\x01\\x003/\\x01\\x02\\x12\\x8f\\x08I\\x00\\xab\\x00\\xa9\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2000-11-27T00:00:00", "modifydate": "2002-05-08T08:49:57", "lines": 171, "newlines": 169, "modlines": 0, "user": "BC0THOR"}, "text": "/************/\n/* split4.c */\n/*********************************************************************/\n/* Reads the file of combinations created by mofn2.c and creates     */\n/* eight output files. each input record is tested against eight     */\n/* formulas. when the values in the record yield a correct solution  */\n/* to a formula, the record is written to that output file. Output   */\n/* record counts are maintained and printed at end of job.           */\n/*                                                                   */\n/* Author R Thornton November, 2000                                  */\n/*********************************************************************/\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n/*********************************************************************/\n/* Global data areas                                                 */\n/*********************************************************************/\nFILE *input1, *output1, *output2, *output3, *output4; /*file pointers*/\nFILE *output5, *output6, *output7, *output8; /* file pointers */\nstruct {\n  char digit[4][3];\n char filler1[3];\n} record;\nint n1=1, n2=0, n3=0, n4=0, n5=0, n6=0, n7=0, n8=0; /* output counts */\nint count=0;                 /* input1 record count */\n/*********************************************************************/\n/* Function prototypes                                               */\n/*********************************************************************/\nint  main(void);             /* executive control routine */\nvoid Initialize(void);       /* Initialize for porcessing */\nvoid Terminate(void);        /* termination routine */\n/*********************************************************************/\n/* executive control routine                                         */\n/*********************************************************************/\nint  main(void) {            /* executive control routine */\n  int more_records = 1;     /* =0 at eof input1 */\n  int d1, d2, d3, d4;        /* numbers used in formulae */\n  char work[3];              /* number conversion area */\n  Initialize();              /* Initialize for processing */\n  while(more_records) {\n    more_records = fread(&record, 15, 1, input1); /* read record */\n    if(ferror(input1)) {\n      printf(\"\\nAt record number %d \",count);\n      perror(\"Read error on input1\");\n      exit(8);\n    }\n    if(!more_records) break;   /* quit at end of file */\n    count++;                   /* count input records */\n    memcpy(&work, record.digit[0], 2); /* copy 1st field */\n    work[2] = '\\x0';           /* make it a string */\n    d1 = atoi(work);           /* convert it to int */\n    memcpy(&work, record.digit[1], 2); /* copy 2nd field */\n    work[2] = '\\x0';           /* make it a string */\n    d2 = atoi(work);           /* convert it to int */\n    memcpy(&work, record.digit[2], 2); /* copy 3rd field */\n    work[2] = '\\x0';           /* make it a string */\n    d3 = atoi(work);           /* convert it to int */\n    memcpy(&work, record.digit[3], 2); /* copy 4th field */\n    work[2] = '\\x0';           /* make it a string */\n    d4 = atoi(work);           /* convert it to int */\n    if(((d2 * d4) % d3) == 0)  /* formula 1 division ok? */\n      if((d1 - d2 / d3 * d4) == 7) {  /* try formula1, if true: */\n        fwrite(&record, 1, sizeof(record), output1); /* write record */\n        n1++;                      /* count combinations */\n      }\n    if((d3 % d4) == 0)          /* formula 2 division ok? */\n      if((d1 - d2 - d3 / d4) == 4) {  /* try formula2, if true: */\n        fwrite(&record, 1, sizeof(record), output2); /* write record */\n        n2++;                      /* count combinations */\n    }\n    if((d1 + d2 + d3 * d4) == 174) {  /* try formula3, if true: */\n      fwrite(&record, 1, sizeof(record), output3); /* write record */\n      n3++;                      /* count combinations */\n    }\n    if((d1 + d2 + d3 + d4) == 28) {  /* try formula4, if true: */\n      fwrite(&record, 1, sizeof(record), output4); /* write record */\n      n4++;                      /* count combinations */\n    }\n    if((d1 - d2 + d3 * d4) == 2) {  /* try formula5, if true: */\n      fwrite(&record, 1, sizeof(record), output5); /* write record */\n      n5++;                      /* count combinations */\n    }\n    if((d1 - d2 + d3 * d4) == 181) {  /* try formula6, if true: */\n      fwrite(&record, 1, sizeof(record), output6); /* write record */\n      n6++;                      /* count combinations */\n    }\n    if((d1 + d2 * d3 - d4) == 105) {  /* try formula7, if true: */\n      fwrite(&record, 1, sizeof(record), output7); /* write record */\n      n7++;                      /* count combinations */\n    }\n    if((d1 + d2 + d3 * d4) == 89) {  /* try formula8, if true: */\n      fwrite(&record, 1, sizeof(record), output8); /* write record */\n      n8++;                      /* count combinations */\n    }\n  }\n  Terminate();                   /* Finished, terminate processing */\n  return(0);\n}\n/*********************************************************************/\n/* Terminate processing: print final output counts and close files.  */\n/*********************************************************************/\nvoid Terminate(void) {\n  printf(\"%d output1 combinations found.\\n\",n1);\n  printf(\"%d output2 combinations found.\\n\",n2);\n  printf(\"%d output3 combinations found.\\n\",n3);\n  printf(\"%d output4 combinations found.\\n\",n4);\n  printf(\"%d output5 combinations found.\\n\",n5);\n  printf(\"%d output6 combinations found.\\n\",n6);\n  printf(\"%d output7 combinations found.\\n\",n7);\n  printf(\"%d output8 combinations found.\\n\",n8);\n  fclose(output1);\n  fclose(output1);\n  fclose(output2);\n  fclose(output3);\n  fclose(output4);\n  fclose(output5);\n  fclose(output6);\n  fclose(output7);\n  fclose(output8);\n  exit(0);\n}\n/*********************************************************************/\n/*  Initialize for processing: Open output file.                     */\n/*********************************************************************/\nvoid Initialize(void) {\n  input1 = (fopen(\"dd:INPUT1\",\"rb,type=record,recfm=FB,lrecl=15\"));\n  if(input1 == NULL) {\n    perror(\"Error opening file INPUT1: \");\n    exit(8);\n  }\n  output1 = (fopen(\"dd:OUTPUT1\",\"wb,type=record,recfm=FB,lrecl=15\"));\n  if(output1 == NULL) {\n    perror(\"Error opening file OUTPUT1: \");\n    exit(8);\n  }\n  output2 = (fopen(\"dd:OUTPUT2\",\"wb,type=record,recfm=FB,lrecl=15\"));\n  if(output2 == NULL) {\n    perror(\"Error opening file OUTPUT2: \");\n    exit(8);\n  }\n  output3 = (fopen(\"dd:OUTPUT3\",\"wb,type=record,recfm=FB,lrecl=15\"));\n  if(output3 == NULL) {\n    perror(\"Error opening file OUTPUT3: \");\n    exit(8);\n  }\n  output4 = (fopen(\"dd:OUTPUT4\",\"wb,type=record,recfm=FB,lrecl=15\"));\n  if(output4 == NULL) {\n    perror(\"Error opening file OUTPUT4: \");\n    exit(8);\n  }\n  output5 = (fopen(\"dd:OUTPUT5\",\"wb,type=record,recfm=FB,lrecl=15\"));\n  if(output5 == NULL) {\n    perror(\"Error opening file OUTPUT5: \");\n    exit(8);\n  }\n  output6 = (fopen(\"dd:OUTPUT6\",\"wb,type=record,recfm=FB,lrecl=15\"));\n  if(output6 == NULL) {\n    perror(\"Error opening file OUTPUT6: \");\n    exit(8);\n  }\n  output7 = (fopen(\"dd:OUTPUT7\",\"wb,type=record,recfm=FB,lrecl=15\"));\n  if(output7 == NULL) {\n    perror(\"Error opening file OUTPUT7: \");\n    exit(8);\n  }\n  output8 = (fopen(\"dd:OUTPUT8\",\"wb,type=record,recfm=FB,lrecl=15\"));\n  if(output8 == NULL) {\n    perror(\"Error opening file OUTPUT8: \");\n    exit(8);\n  }\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "STAT": {"ttr": 14094, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x02\\x8d\\x02\\x8d\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 653, "newlines": 653, "modlines": 0, "user": "BC0THOR"}, "text": "/*\n    */\n/* PROGRAM-ID:  MEDSCREEN STATISTICAL REPORT\n    */\n/* AUTHOR:  JEFF KEELING\n    */\n/* DATE-WRITTEN: APRIL 1989\n    */\n/* REMARKS:  This program reports summary results of Expert System processing.\nIt  */\n/*           shows the number of claims reviewed by MedScreen and how many of th\nose */\n/*           were approved or denied or which remained unresolved.  The report i\ns   */\n/*           sorted by pend code and totals are reported in numbers and percenta\nges.*/\n/*           The user will enter boundary period dates.  The program will only\n    */\n/*           process records from the master summary file that are between these\n    */\n/*           dates.\n    */\n/*              The program calls two exterior functions, 1) sort_summfile() and\n    */\n/*           2) edit.  Sort_summfile() is called to sort the input summary file\nby  */\n/*           pend code.  Edit() is called to format particular print lines for t\nhe  */\n/*           report.  The program will be run on the PC.\n    */\n/*\n    */\n\n#include <stdio.h>\n         /* library include files */\n#include <stdlib.h>\n#include <memory.h>\n#include <string.h>\n#include <time.h>\n\nstatic char summfile_name[] = \"c:\\\\c\\\\data\\\\sort_sum.dat\";\n         /* exterior file associations */\n\nFILE *summfile_ptr, *outfile_ptr=NULL;\n         /* pointers to files */\n\n\n   struct summ_structure\n         /* stucture for output summary file */\n   {\n      char log_year[2];\n      char log_month[2];\n      char log_day[2];\n      char pend_code[2];\n      char pend_text[25];\n      char approve_totals[7];\n      char deny_totals[7];\n      char pend_totals[7];\n      char carriage_return[1];\n      char new_line_ch[1];\n   } prev_summfile, summfile;\n\n   struct print_summfile\n         /* structure for output line of report */\n   {\n      char pend_code[2];\n      char filler1[5];\n      char pend_text[25];\n      char filler2[6];\n      char quantity_reviewed[7];\n      char filler3[6];\n      char quantity_approved[7];\n      char filler4[6];\n      char quantity_denied[7];\n      char filler5[7];\n      char quantity_unresolved[7];\n   } print_summfile;\n\n   struct start_date_structure\n          /* date compare structures */\n   {\n      char start_year[2];\n      char start_month[2];\n      char start_day[2];\n   } start_date;\n\n   struct stop_date_structure\n   {\n      char stop_year[2];\n      char stop_month[2];\n      char stop_day[2];\n   } stop_date;\n\n   struct summ_date_structure\n         /* structure for summary file date */\n   {\n      char summ_year[2];\n      char summ_month[2];\n      char summ_day[2];\n   } summ_date;\n\n   struct date_structure\n         /* structure for user input date */\n   {\n      char month[2];\n      char filler1;\n      char day[2];\n      char filler2;\n      char year[2];\n      char newline;\n   }  date = {\"  \",'/',\"  \",'/',\"  \"};\n\n   char header_line[133];\n         /* output print lines */\n   char print_line[133];\n   char total_line[133];\n\n   char workstring[32];\n         /* working buffers */\n   char run_date[9];\n   char datebuffer[9];\n   char future_date;\n   char quantity_buffer[8];\n\n   int pagectr = 1;\n         /* counters */\n   int linectr = 90;\n\n   long total_claims = 0;\n         /* accumulators */\n   long quantity_reviewed = 0;\n   long quantity_approved = 0;\n   long quantity_denied = 0;\n   long quantity_unresolved = 0;\n\n   long total_quantity_reviewed = 0;\n   long total_quantity_approved = 0;\n   long total_quantity_denied = 0;\n   long total_quantity_unresolved = 0;\n\n   static int compare_ok = 0;\n         /* numeric constants */\n   static int zero = 0;\n   static int line_size = 134;\n   static int no_records = 0;\n   static stat_lines_per_page = 48;\n\n   char end_string = '\\0';\n         /* character constants */\n   char forward_slash = '/';\n   char carriage_return = '\\r';\n   char new_line_ch = '\\n';\n\nFILE * sort_summfile(void);\n         /* prototype of sort_file() */\nvoid start_program();\n         /* prototype of start_program() */\nvoid process();\n         /* prototype of process() */\nvoid end_program();\n         /* prototype of end_program() */\nint edit(char output[], char pattern[], char number[]);\n         /* prototype of edit() */\n\n\n\n\n\nmain()\n/* This function is the controlling function of the         */\n/* program.  After, the print lines are initialized, the    */\n/* call is made to sort_summfile() in order to sort the     */\n/* summary file.  Then functions begin_program(), process(),*/\n/* and end_program(), are then called.                      */\n{\nint i;\n     for (i=zero; i<line_size; i++)\n         /* initialize print lines */\n {\n print_line[i] = ' ';\n total_line[i] = ' ';\n header_line[i] = ' ';\n }\n\n     summfile_ptr = sort_summfile();\n         /* call sort program */\n\n     start_program();\n     process();\n     end_program();\n     exit(zero);\n\n}\n/*  End of main() */\n\n\n\n\n\nvoid enter_date();\n\nvoid start_program()\n/* This function is called by main() and is used to open   */\n/* the summary file and read the first record.  It sets the*/\n/* previous summfile to the first summfile record if the   */\n/* date is between the start and stop date entered by the  */\n/* user.                                                   */\n{\n   if ( (summfile_ptr = fopen(summfile_name,\"rb\")) == NULL)\n      {\n      printf(\"\\nThe sorted summary file cannot be opened.\");\n      printf(\"\\nThe program is exiting.\");\n      printf(\"\\nPress any key to continue.\");\n      getch();\n      exit(zero);\n      }\n   if ( (outfile_ptr = fopen(\"prn\",\"w\")) == NULL)\n      {\n      printf(\"\\nThe printer file cannot be opened.\");\n      printf(\"\\nThe program is exiting.\");\n      printf(\"\\nPress any key to continue.\");\n      getch();\n      exit(zero);\n      }\n    if (fread(&summfile,sizeof(summfile),1,summfile_ptr) == no_records)\n         /* read first summary file record */\n      {\n       printf(\"\\nThere are no records in the summary file.\");\n       printf(\"\\nThe program is exiting.\");\n       printf(\"\\nPress any key to continue.\");\n       getch();\n       exit(zero);\n      }\n\n   memcpy(summ_date.summ_year,summfile.log_year,2);\n         /* set date to date of first record in */\n   memcpy(summ_date.summ_month,summfile.log_month,2);\n         /* summary file */\n   memcpy(summ_date.summ_day,summfile.log_day,2);\n\n   prev_summfile.pend_code[0] = 'Z';\n         /* initialize previous summary file pend code */\n   prev_summfile.pend_code[1] = 'Z';\n            /* set previous summary file record to */\n            /* first summary file record if the record */\n   if ( (memicmp(&summ_date,&start_date,6) >= zero) && (memicmp(&summ_date,&stop\n_date,6) <= zero) )  /* is within the date limits */\n      prev_summfile = summfile;\n\n   do\n         /* allow user to enter boundary date fields */\n      {\n      printf(\"\\nOnly records between the start and stop dates\");\n      printf(\"\\nwill be processed.\");\n      printf(\"\\nYou will need to enter the start date first.\");\n      enter_date();\n      memcpy(start_date.start_year,date.year,2);\n      memcpy(start_date.start_month,date.month,2);\n      memcpy(start_date.start_day,date.day,2);\n\n      printf(\"\\nYou will need to enter the stop date next.\");\n      enter_date();\n      memcpy(stop_date.stop_year,date.year,2);\n      memcpy(stop_date.stop_month,date.month,2);\n      memcpy(stop_date.stop_day,date.day,2);\n\n      if (memcmp(&start_date,&stop_date,6) > zero)\n  {\n  printf(\"\\n\\nThe stop date is not after the start date.\");\n  printf(\"\\nYou must reenter both dates.\");\n  }\n\n      } while (memcmp(&start_date,&stop_date,6) > zero);\n\n}\n/* end start_program() */\n\n\n\n\n\nvoid header(int pagectr);\n         /* prototype of header() */\nvoid print_record();\n         /* prototype of print_record() */\n\nvoid process()\n/* This function is called by main() and is used to  */\n/* process all records from the summary file. The    */\n/* function header() will be called for a new page.  */\n/* The function print_record()is called in order to  */\n/* print the record.  If a record is not within the  */\n/* date limits, it will not be processed.            */\n{\n\nint eof_indicator = 1;\nint i;\n     summfile.carriage_return[0] = carriage_return;\n         /* set end of record characters */\n     summfile.new_line_ch[0] = new_line_ch;\n\n     do\n     {\n if (  (memicmp(&summ_date,&start_date,6) >= zero) && (memicmp(&summ_date,&stop_\ndate,6) <= zero)  )\n    {\n       if (  (memicmp(summfile.pend_code,prev_summfile.pend_code,2) != compare_o\nk )    /* if record is between start and */\n       && (strcmp(prev_summfile.pend_code,\"ZZ\") != zero)  )\n       /* stop dates and different from  */\n    print_record();\n/* previous record then print record */\n\n       memcpy(quantity_buffer,summfile.approve_totals,7);\n  /* summ totals for identical pend codes */\n       quantity_reviewed += atol(quantity_buffer);\n       memcpy(quantity_buffer,summfile.deny_totals,7);\n       quantity_reviewed += atol(quantity_buffer);\n       memcpy(quantity_buffer,summfile.pend_totals,7);\n       quantity_reviewed += atol(quantity_buffer);\n\n       memcpy(quantity_buffer,summfile.approve_totals,7);\n       quantity_approved += atol(quantity_buffer);\n       memcpy(quantity_buffer,summfile.deny_totals,7);\n       quantity_denied += atol(quantity_buffer);\n       memcpy(quantity_buffer,summfile.pend_totals,7);\n       quantity_unresolved += atol(quantity_buffer);\n\n       prev_summfile = summfile;\n  /* set previous summary file record to */\n            /* current summary record */\n    }\n    eof_indicator = fread(&summfile,sizeof(summfile),1,summfile_ptr);\n  /* read next summary file record */\n\n    memcpy(summ_date.summ_year,summfile.log_year,2);\n  /* set date to date of current summary record */\n    memcpy(summ_date.summ_month,summfile.log_month,2);\n    memcpy(summ_date.summ_day,summfile.log_day,2);\n     } while (eof_indicator == 1);\n         /* check for end of file */\n\n     if (quantity_reviewed != zero)\n print_record();\n  /* print last record in memory */\n}\n/* end of process() */\n\n\n\n\n\nvoid print_record()\n/* This function is called by process() to print a record */\n/* on the report.                                         */\n{\n\n   if (linectr > stat_lines_per_page)\n                          /* page break logic */\n      {\n      header(pagectr++);\n      linectr = zero;\n      }\n      memcpy(print_summfile.pend_code,prev_summfile.pend_code,2);\n         /* print record */\n      memcpy(print_summfile.filler1,\"     \",5);\n      memcpy(print_summfile.pend_text,prev_summfile.pend_text,25);\n      memcpy(print_summfile.filler2,\"      \",6);\n      edit(print_summfile.quantity_reviewed,\"zzz,zz9\",ltoa(quantity_reviewed,wor\nkstring,10));\n      memcpy(print_summfile.filler3,\"      \",6);\n      edit(print_summfile.quantity_approved,\"zzz,zz9\",ltoa(quantity_approved,wor\nkstring,10));\n      memcpy(print_summfile.filler4,\"      \",6);\n      edit(print_summfile.quantity_denied,\"zzz,zz9\",ltoa(quantity_denied,workstr\ning,10));\n      memcpy(print_summfile.filler5,\"       \",7);\n      edit(print_summfile.quantity_unresolved,\"zzz,zz9\",ltoa(quantity_unresolved\n,workstring,10));\n      fwrite(&print_summfile,sizeof(print_summfile),1,outfile_ptr);\n      fprintf(outfile_ptr,\"\\n\");\n         /* advance printer line */\n\n      linectr++;\n\n      total_quantity_reviewed += quantity_reviewed;\n         /* increment total accumulators */\n      total_quantity_approved += quantity_approved;\n      total_quantity_denied += quantity_denied;\n      total_quantity_unresolved += quantity_unresolved;\n\n      quantity_reviewed = zero;\n         /* reset counters */\n      quantity_approved = zero;\n      quantity_denied = zero;\n      quantity_unresolved = zero;\n\n      prev_summfile = summfile;\n         /* set previous summary file record  to */\n}\n         /* new record value */\n/* end of print_record() */\n\n\n\n\n\nvoid header(pagectr)\n/* This function is called by both process() and print   */\n/* record() in order to print the header on each new     */\n/* page of the report.                                   */\n{\n   fprintf(outfile_ptr,\"\\f\");\n   memcpy(header_line,\" PROCESS DATE:   /  /\n          PAGE:     \",87);\n   memcpy(header_line+15,stop_date.stop_month,2);\n   memcpy(header_line+18,stop_date.stop_day,2);\n   memcpy(header_line+21,stop_date.stop_year,2);\n   memcpy(header_line+74,itoa(pagectr,workstring,10),3);\n   fputs(header_line,outfile_ptr);\n   fprintf(outfile_ptr,\"\\n\");\n   _strdate(run_date);\n   sprintf(header_line,\"     RUN DATE: %8s\\n\",run_date,outfile_ptr);\n   fputs(header_line,outfile_ptr);\n   fputs(\"                        BLUE CROSS AND BLUE SHIELD OF VIRGINIA\\n\",outf\nile_ptr);\n   fputs(\"                          MEDSCREEN MONTHLY STATISTICAL REPORT\\n\",outf\nile_ptr);\n   memcpy(header_line,\"                            FOR PERIOD   /  /   TO   /  /\n  \",61);\n   memcpy(header_line+39,start_date.start_month,2);\n   memcpy(header_line+42,start_date.start_day,2);\n   memcpy(header_line+45,start_date.start_year,2);\n   memcpy(header_line+51,stop_date.stop_month,2);\n   memcpy(header_line+54,stop_date.stop_day,2);\n   memcpy(header_line+57,stop_date.stop_year,2);\n   memcpy(header_line+61,\"                                       \",40);\n   fputs(header_line,outfile_ptr);\n   fprintf(outfile_ptr,\"\\n\");\n   fputs(\" \\n\",outfile_ptr);\n   fputs(\" \\n\",outfile_ptr);\n   {\n      fputs(\"PEND                                 QUANTITY     QUANTITY     QUAN\nTITY     QUANTITY\\n\",outfile_ptr);\n      fputs(\"CODE          PEND REASON            REVIEWED     APPROVED      DEN\nIED     UNRESOLVED\\n\",outfile_ptr);\n      fputs(\"----   --------------------------    --------     --------     ----\n----    ----------\\n\",outfile_ptr);\n      }\n}\n/* end of header() */\n\n\n\n\n\nvoid end_program()\n/* This function is called by main() to print the total */\n/* line.                                                */\n{\nstatic int ten_thousand = 10000;\n\n   if (total_quantity_reviewed == zero)\n      {\n       fputs(\"\\nThere were no records in the summary file that were\",outfile_ptr\n);\n       fputs(\"\\nbetween the 'start' and 'stop' dates entered.\",outfile_ptr);\n       fprintf(outfile_ptr,\"\\f\");\n       }\n   else\n      {\n      fputs(\"                                      =======      =======      ===\n====       =======\\n\",outfile_ptr);\n      memcpy(total_line,\"DECISION GRAND TOTALS:\",22);\n      edit(total_line+36,\"z,zzz,zz9\",ltoa(total_quantity_reviewed,workstring,10)\n);\n      edit(total_line+49,\"z,zzz,zz9\",ltoa(total_quantity_approved,workstring,10)\n);\n      edit(total_line+62,\"z,zzz,zz9\",ltoa(total_quantity_denied,workstring,10));\n      edit(total_line+76,\"z,zzz,zz9\\n\",ltoa(total_quantity_unresolved,workstring\n,10));\n      memcpy(total_line+86,\"                                                  \",\n51);\n      fputs(total_line,outfile_ptr);\n      fprintf(outfile_ptr,\"\\n\");\n            /* write percentage line */\n      memcpy(total_line,\"IN PERCENTAGES:                             %\n  %            %             %\",86);\n      edit(total_line+38,\"zz9.z9\",ltoa(((total_quantity_reviewed*ten_thousand)/t\notal_quantity_reviewed),workstring,10));\n      edit(total_line+51,\"zz9.z9\",ltoa(((total_quantity_approved*ten_thousand)/t\notal_quantity_reviewed),workstring,10));\n      edit(total_line+64,\"zz9.z9\",ltoa(((total_quantity_denied*ten_thousand)/tot\nal_quantity_reviewed),workstring,10));\n      edit(total_line+78,\"zz9.z9\",ltoa(((total_quantity_unresolved*ten_thousand)\n/total_quantity_reviewed),workstring,10));\n      memcpy(total_line+85,\"                                                   \"\n,52);\n      fputs(total_line,outfile_ptr);\n         /* write total line */\n      fprintf(outfile_ptr,\"\\f\");\n      }\n\n      fclose(summfile_ptr);\n         /* close all files */\n      fclose(outfile_ptr);\n}\n/* end of end_program() */\n\n\n\n\n\nvoid enter_date()\n/* This function is called by start_program() to enter and */\n/* verify the start and stop dates.                        */\n{\n   do\n      {\n      _strdate(datebuffer);\n      printf(\"\\nType the date in MM/DD/YY format and press [Enter]. \");\n      gets(&date);\n\n      if (memcmp(&date,&datebuffer,8) > zero)\n  {\n  printf(\"\\n\\nThe date entered is after today's date.\");\n  printf(\"\\nType a 'Y' and press [Enter] if you still want this to be the date.\"\n);\n  printf(\"\\nOtherwise, type an 'N' and press [Enter]. \");\n  future_date = getche();\n  }\n      } while ( (future_date != 'Y') && (future_date != 'y') &&\n  (memcmp(&date,&datebuffer,8) > zero) );\n\n\n   if ( (date.filler1 != forward_slash) || (date.filler2 != forward_slash) )\n         /* check for proper entry of forward */\n      {\n         /* slash characters */\n      printf(\"\\nThe date was entered incorrectly.\");\n      enter_date();\n      }\n\n   if ( (memcmp(date.month,\"  \",2) == zero) || (memcmp(date.day,\"  \",2) == zero)\n         /* check for blanks or end string characters */\n      || (memcmp(date.year,\"  \",2) == zero) || (date.month[0] == end_string)\n      || (date.month[11] == end_string) || (date.year[0] == end_string) || (date\n.year[1] == end_string)\n      || (date.day[0] == end_string) || (date.day[1] == end_string) )\n      {\n      printf(\"\\nA date field(s) was left blank or entered incorrectly.\");\n      enter_date();\n      }\n\n   if ( memcmp(date.year,\"89\",2) < zero )\n         /* year validation */\n       {\n       printf(\"\\nThe year entered is too small.\");\n       enter_date();\n       }\n   else\n      if (memcmp(date.year,\"99\",2) > zero)\n  {\n  printf(\"\\nThe year entered is too large.\");\n  enter_date();\n  }\n\n   if (memcmp(date.month,\"01\",2) < zero)\n         /* month validation */\n      {\n      printf(\"\\nThe month entered is too small.\");\n      enter_date();\n      }\n   else\n      if (memcmp(date.month,\"12\",2) > zero)\n  {\n  printf(\"\\nThe month entered is too large.\");\n  enter_date();\n  }\n\n   if (memcmp(date.month,\"02\",2) == compare_ok)\n         /* day validation for February */\n      {\n  if ( (memcmp(date.year,\"92\",2) == compare_ok)\n  /* February validation on leap year */\n     || (memcmp(date.year,\"96\",2) == compare_ok) )\n     {\n     if (memcmp(date.day,\"01\",2) < zero)\n        {\n        printf(\"\\nThe day entered is too small.\");\n        enter_date();\n        }\n     else\n        if (memcmp(date.day,\"29\",2) > zero)\n    {\n    printf(\"\\nThe day entered is too large.\");\n    enter_date();\n    }\n     }\n  else\n     {\n     if (memcmp(date.day,\"01\",2) < zero)\n        {\n        printf(\"\\nThe day entered is too small.\");\n        enter_date();\n        }\n     else\n        if (memcmp(date.day,\"28\",2) > zero)\n    {\n    printf(\"\\nThe day entered is too large.\");\n    enter_date();\n    }\n     }\n      }\n      else\n         /* day validation for April, June */\n  if ( (memcmp(date.month,\"04\",2) == compare_ok)\n  /* September, or November         */\n       || (memcmp(date.month,\"06\",2) == compare_ok)\n       || (memcmp(date.month,\"09\",2) == compare_ok)\n       || (memcmp(date.month,\"11\",2) == compare_ok) )\n     {\n     if (memcmp(date.day,\"01\",2) < zero)\n        {\n        printf(\"\\nThe day entered is too small.\");\n        enter_date();\n        }\n     else\n        if (memcmp(date.day,\"30\",2) > zero)\n    {\n    printf(\"\\nThe day entered is too large.\");\n    enter_date();\n    }\n     }\n      else\n         /* day validation for January, March,   */\n  {\n  if (memcmp(date.day,\"01\",2) < zero)\n     {\n     printf(\"\\nThe day entered is too small.\");\n     enter_date();\n     }\n  else\n     if (memcmp(date.day,\"31\",2) > zero)\n        {\n        printf(\"\\nThe day entered is too large.\");\n        enter_date();\n        }\n  }\n}\n/* end enter_date() */\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STMENU2": {"ttr": 14345, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00U\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x8f\\t4\\x03\\r\\x03\\x07\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-08T09:34:55", "lines": 781, "newlines": 775, "modlines": 0, "user": "BC0THOR"}, "text": "/*************/\n/* stmenu2.c */\n/*******************************************************************/\n/* Program that creates printed report from IVR statistics file:   */\n/*                            Event.arc                            */\n/*  Output files:  printed report, Event.rpt.[date of .arc file]   */\n/*                 (online copy of printed report),                */\n/*                 Event.err.[date of .arc file]                   */\n/*  11-4-93                                                        */\n/* from skeleton.c generic program                                 */\n/* Author R Thornton September 1993                                */\n/* Revised by:  N Rowe     12-15-93                                */\n/*******************************************************************/\n#define _ALL_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <string.h>\n#include <ctype.h>\n#define LINELEN 131\n#define MAX_ENTRIES 47          /* number of entries in event table */\n#define LIM 5                   /* loop limit for M-F dates array */\n\nvoid initialize(int argc, char *argv[]); /* initialization function */\nvoid mainline(void);                  /* mainline function */\nvoid terminate(void);                 /* termination function */\nvoid readrec(void);        /* read next input file record */\nvoid procrec(void);               /* process input file record */\nvoid exceptn(void);                   /* write record to error file */\nvoid writerec(void);                  /* write record to output file */\nvoid printline(void);                 /* print a line to report file */\nint edit(char output[], char pattern[], char number[]); /* edit func */\nvoid headings(void);                  /* print report heading */\nvoid headout(void);                   /* headings to outfile.txt */\nvoid back1day(void);                  /* back one date function */\nvoid errdate(void);                   /* date error function    */\n\nFILE *infile, *outfile, *prtfile,\n   *errfile;     /* file handle pointers */\nchar innam[81];                       /* input file name */\nchar outnam[81];                      /* output file name */\nchar prtnam[81];                      /* print file name */\nchar errnam[81];                      /* error file name */\n\nchar dates[5][10];                    /* dates table for M - F */\n\nstruct {                              /* first heading line */\n  char hdr_skip;                      /* form feed */\n  char fill1[4];\n  char hdr_date[10];                  /* report date */\n  char ctr1[8];                       /* centering blanks */\n  char title_line[38];                /* centered report title */\n  char ctr2[8];                       /* centering blanks */\n  char page_lit[5];                   /* page literal */\n  char page_nbr[3];                   /* page number */\n  char line_nl;\n  char carr_rt;\n  char page_null;                     /* terminating null */\n} header1;\n\nstruct {                              /* second heading line */\n  char hdr_skip;                      /* form feed */\n  char ctr1[21];                      /* centering blanks */\n  char titl2_line[39];                /* centered report title */\n  char ctr2[16];                      /* centering blanks */\n  char line_nl;\n  char carr_rt;\n  char page_null;                     /* terminating null */\n} header2;\n\nstruct {                              /* third heading line */\n  char hdr_skip;                      /* form feed */\n  char ctr1[32];                      /* centering blanks */\n  char hdr_for[4];        /* literal FOR      */\n  char hdr_date[10];                  /* date of data reported */\n  char ctr2[30];                      /* centering blanks */\n  char line_nl;\n  char carr_rt;\n  char page_null;                     /* terminating null */\n} header3;\n\nstruct {                              /* summary page header2 */\n  char hdr_skip;                      /* form feed */\n  char ctr1[22];                      /* centering blanks */\n  char titl2_line[38];                /* centered report title */\n  char ctr2[16];                      /* centering blanks */\n  char line_nl;\n  char carr_rt;\n  char page_null;                     /* terminating null */\n} header4;\n\nstruct {                              /* summary page header3 */\n  char hdr_skip;                      /* form feed */\n  char ctr1[26];                      /* centering blanks */\n  char hdr_for[4];        /* literal FOR      */\n  char hdr_date[23];                  /* date of data reported */\n  char ctr2[23];                      /* centering blanks */\n  char line_nl;\n  char carr_rt;\n  char page_null;                     /* terminating null */\n} header5;\n\nstruct {                              /* error rpt header2 */\n  char hdr_skip;                      /* form feed */\n  char ctr1[22];                      /* centering blanks */\n  char titl2_line[38];                /* centered report title */\n  char ctr2[16];                      /* centering blanks */\n  char line_nl;\n  char carr_rt;\n  char page_null;                     /* terminating null */\n} errhead;\n\nstruct {                 /* footer line  */\n  char fill1[4];\n  char rpt_nm[12];        /* report name */\n  char fill2[61];\n  char line_nl;\n  char carr_rt;\n  char page_null;\n} footer1;\n\nunion{\nstruct {            /* inrecord structure  */\n  char sysno;                /* system number  */\n  char comma1;                        /* comma          */\n  char recdate[10];                   /* date of record yyyy.mm.dd */\n  char blank;                         /* blank btw date and time   */\n  char time[8];                       /* time in 00:00:00 format   */\n  char comma2;                        /* comma           */\n  char appname[8];                    /* appl name VA_INTRO        */\n  char comma3;                        /* comma           */\n  char eventdat[33];            /* combined event name and event cnt */\n}infields;\nchar inrec[64];                       /* array of entire record     */\n} inrecord;\n\nunion{\nstruct {                              /* print line structure */\n  char new_line;                      /* new line character  */\n  char fill1[4];\n  char daytot[5];                     /* event total for day */\n  char fill2[5];                      /* column spacing blanks */\n  char text_nm[62];                   /* long description of event */\n  char line_nl;                       /* new line char  */\n  char carr_rt;\n  char line_null;                     /* terminating null */\n} detail;\nchar line[LINELEN+1];                 /* print line in array form */\n}prt,out;\n\n/* from genldat2.c, R Thornton  */\n/*****************************************************************/\n/* This function provides the caller with a table of information */\n/* concerning a specified date. The caller places a date in one  */\n/* of the Julian or Gregorian fields of the DATEGENL structure   */\n/* and an indicator of the type date sent in the datyp field, and*/\n/* invokes genldat2(), which fills in all the remaining fields in*/\n/* the DATEGENL structure. A pointer to DATEGENL is passed to    */\n/* this function by the caller.                                  */\n/*****************************************************************/\n\nstruct\n{\n enum\n {\n  julian_yyyyddd_sent = 'j',\n  gregorian_mmddyyyy_sent = 'g',\n  gregorian_yyyymmdd_sent = 'y'\n } datyp;                          /* date supplied type */\n enum\n {\n  successful_conversion = ' ',\n  error_in_data_supplied = 'e'\n } daterr;                         /* result indicator */\n enum\n {\n  Monday = '1',\n  Tuesday = '2',\n  Wednesday = '3',\n  Thursday = '4',\n  Friday = '5',\n  Saturday = '6',\n  Sunday = '7'\n } daywk;                          /* day of week indicator */\n enum\n {\n  not_a_holiday = ' ',\n  New_Years_Day = '1',\n  Christmas_Eve = '2',\n  Good_Friday = '3',\n  Memorial_Day = '4',\n  Independence_Day = '5',\n  Labor_Day = '6',\n  Thanksgiving_Day = '7',\n  Friday_After_Thanksgiving = '8',\n  Christmas_Day = '9'\n } holiday;                        /* holiday indicator */\n enum\n {\n  not_leap_year = '0',\n  leap_year = '1'\n } yeartyp;                        /* year type */\n char juldate[8];                         /* julian date yyyyddd */\n char gregmdy[9];                         /* gregorian date mmddyyyy */\n char gregymd[9];                         /* gregorian date yyyymmdd */\n char litdate[19];                  /* literal date, eg: May 9, 2002 */\n char julslash[9];                        /* julian date yy/ddd */\n char grgslash[11];                     /* gregorian date mm/dd/yyyy */\n char daylit[10];                 /* literal day of week, eg: Sunday */\n char monthlit[10];                       /* literal month, eg: July */\n}DATEGENL, *p;\n\n\nint i;                                /* general purpose int */\nint j;\nint k;\nchar *chptr;                          /* general purpose pointer */\nchar number[32];                      /* ascii numbers for edit() */\nint morerecs = -1;                    /* input end-of-file switch */\nlong incount = 0;                     /* input record counter */\nlong outcount = 0;                    /* output record counter */\nlong errcount = 0;                    /* error record counter */\nint linecnt = 0;                      /* print line counter */\nint pagecnt = 0;                      /* print page counter */\nint pagecnt2 = 0;                     /* page counter for outfile */\nchar eventnm[33];                     /* event name field save area */\nint eventcnt;                         /* event count field save area */\nstruct tm *t;                         /* pointer to time structure */\ntime_t seconds;                       /* current timer value */\nint dex;                          /* for loop counter to walk dates[]*/\nint sch;                        /* for loop cntr to walk event_table */\nchar rptdate[10];\n\nstruct event_entry{              /* structure format for event_table */\n   int daytot[5];                 /* integer array of counts M - F   */\n   char event_nm[17];             /* event name in data file (abbrv) */\n   char text_nm[75];              /* full event name for printing    */\n};\n\n/*  Following is the table of events + count for each event M - F */\n\nstruct event_entry event_table[MAX_ENTRIES] = {\n {{0,0,0,0,0},\"hangups_at_intro\",\n     \"Number of hangups during the Introduction\"},\n {{0,0,0,0,0},\"tot_subscr_calls\",\n     \"Selections of 1 -subscriber- at Introduction\"},\n {{0,0,0,0,0},\"tot_prov_calls\",\n     \"Selections of 2 -provider- at Introduction\"},\n {{0,0,0,0,0},\"rotary_calls\",\n     \"No selection made at the Introduction, call routed to Default\"},\n {{0,0,0,0,0},\"subscr_id_routed\",\n     \"Number of calls routed after input of subscriber ID\"},\n {{0,0,0,0,0},\"subscr_defaults\",\n     \"Number of sub ID wrong entries going to Default Gate\"},\n {{0,0,0,0,0},\"subr_zeroout\",\n     \"Selections of 1, then 0 to get to a rep\"},\n {{0,0,0,0,0},\"prv_zeroout\",\n     \"Selections of 2 -Provider Inq Sys- then 0 for a rep\"},\n {{0,0,0,0,0},\"prv_ebc_select\",\n     \"Eligibility, Benefits, and Claims selected at Step 14\"},\n {{0,0,0,0,0},\"prv_select_fep\",\n     \"Number of times FEP Claims Status selected at Step 14\"},\n {{0,0,0,0,0},\"prv_fep_wrngchrg\",\n     \"FEP Claims Status: calls routed to step 525 - invalid charge\"},\n {{0,0,0,0,0},\"prv_fep_2rep\",\n     \"Number of times calls reach Step 33 from Step 525\"},\n {{0,0,0,0,0},\"prv_select_elig\",\n     \"Eligibility selected at Step 31\"},\n {{0,0,0,0,0},\"prv_select_bene\",\n     \"Benefits selected at Step 31\"},\n {{0,0,0,0,0},\"prv_select_claim\",\n     \"Claims Status selected at Step 31\"},\n {{0,0,0,0,0},\"policy_medextnd\",\n     \"1 -Medicare Extended- selected at Step 33\"},\n {{0,0,0,0,0},\"policy_phc_vas\",\n     \"2 -PHC VS- selected at Step 33\"},\n {{0,0,0,0,0},\"policy_student\",\n     \"3 -Student- selected at Step 33\"},\n {{0,0,0,0,0},\"policy_nasco\",\n     \"4 -NASCO- selected at Step 33\"},\n {{0,0,0,0,0},\"policy_cp\",\n     \"5 -C&P- selected at Step 33\"},\n {{0,0,0,0,0},\"policy_group\",\n     \"6 -Group- selected at Step 33\"},\n {{0,0,0,0,0},\"policiy_fep\",\n     \"7 -FEP- selected at Step 33\"},\n {{0,0,0,0,0},\"prv_elig_0_200\",\n     \"Zeroout to a CSR is selected at Eligibility Step 200\"},\n {{0,0,0,0,0},\"prv_elig_0_202\",\n     \"Zeroout to a CSR is selected at Eligibility Step 202\"},\n {{0,0,0,0,0},\"prv_elig_0_204\",\n     \"Zeroout to a CSR is selected at Eligibility Step 204\"},\n {{0,0,0,0,0},\"prv_elig_0_208\",\n     \"Zeroout to a CSR is selected at Eligibility Step 208\"},\n {{0,0,0,0,0},\"prv_elig_0_210\",\n     \"Zeroout to a CSR is selected at Eligibility Step 210\"},\n {{0,0,0,0,0},\"prv_elig_0_213\",\n     \"Zeroout to a CSR is selected at Eligibility Step 213\"},\n {{0,0,0,0,0},\"prv_bene_0_300a\",\n     \"Zeroout to a CSR is selected at Benefits Step 300a\"},\n {{0,0,0,0,0},\"prv_bene_0_300b\",\n     \"Zeroout to a CSR is selected at Benefits Step 300b\"},\n {{0,0,0,0,0},\"prv_bene_0_303\",\n     \"Zeroout to a CSR is selected at Benefits Step 303\"},\n {{0,0,0,0,0},\"prv_bene_0_306\",\n     \"Zeroout to a CSR is selected at Benefits Step 306\"},\n {{0,0,0,0,0},\"prv_bene_0_309\",\n     \"Zeroout to a CSR is selected at Benefits Step 309\"},\n {{0,0,0,0,0},\"prv_bene_0_312\",\n     \"Zeroout to a CSR is selected at Benefits Step 312\"},\n {{0,0,0,0,0},\"prv_bene_0_bc\",\n     \"Zeroout to a CSR is selected at Company Benefits 1\"},\n {{0,0,0,0,0},\"prv_bene_0_bs\",\n     \"Zeroout to a CSR is selected at Company Benefits 2\"},\n {{0,0,0,0,0},\"prv_bene_0_mm\",\n     \"Zeroout to a CSR is selected at Company Benefits 3\"},\n {{0,0,0,0,0},\"prv_bene_0_de\",\n     \"Zeroout to a CSR is selected at Company Benefits 4\"},\n {{0,0,0,0,0},\"prv_claim_0_407\",\n     \"Zeroout to a CSR is selected at Claims Status Step 407\"},\n {{0,0,0,0,0},\"prv_claim_0_416\",\n     \"Zeroout to a CSR is selected at Claims Status Step 416\"},\n {{0,0,0,0,0},\"prv_claim_0_417\",\n     \"Zeroout to a CSR is selected at Claims Status Step 417\"},\n {{0,0,0,0,0},\"prv_claim_0_emp\",\n     \"Number of calls routed to PIU for Claims Status for employee\"},\n {{0,0,0,0,0},\"fep_claim_0\",\n     \"Zeroout to a CSR is selected at FEP Claims Intro\"},\n {{0,0,0,0,0},\"fep_claim_rep33\",\n     \"Calls routed to Step 33 from the FEP Claims module\"},\n {{0,0,0,0,0},\"fep_prv_zeroout\",\n     \"Zeroout to a CSR from FEP Claims after prv ID entered\"},\n {{0,0,0,0,0},\"fep_subr_default\",\n     \"Number of times subscr ID is reentered in FEP Claims\"},\n {{0,0,0,0,0},\"fep_zeroout\",\n     \"Zeroout to a CSR is selected after FEP Claims Intro\"},\n\n};\n\nvoid genldat2(struct DATEGENL *p);       /* genldat2 prototype */\n\nvoid main(int argc, char *argv[])\n{\n initialize(argc, argv);       /* open files */\n while(morerecs)               /* perform mainline until */\n  mainline();           /* no more records */\n terminate();                  /* close files */\n exit(0);                      /* quit */\n}\n/*********************************************************************/\n/* mainline function: process input file until no more records.      */\n/*********************************************************************/\nvoid mainline(void)\n{\n procrec();                    /* process record      */\n readrec();                    /* read next record    */\n}\n/*********************************************************************/\n/* initialization: open files, read first input record.              */\n/*********************************************************************/\nvoid initialize(int argc, char *argv[])\n{\n  if(argc == 3) {\n    strcpy(innam,argv[1]);\n    strcpy(outnam,argv[2]);\n  }\n  else\n    if(argc == 4) {\n      strcpy(innam,argv[1]);\n      strcpy(outnam,argv[2]);\n      strcpy(prtnam,argv[3]);\n    }\n  else\n    if(argc == 5) {\n      strcpy(innam,argv[1]);\n      strcpy(outnam,argv[2]);\n      strcpy(prtnam,argv[3]);\n      strcpy(errnam,argv[4]);\n    }\n    else {\n      printf(\"\\nEnter input file spec: \");\n      gets(innam);\n      printf(\"\\nEnter output file spec: \");\n      gets(outnam);\n      printf(\"\\nEnter output file spec (or prn): \");\n      gets(prtnam);\n      printf(\"\\nEnter error file spec: \");\n      gets(errnam);\n    }\n  if((infile=fopen(innam,\"rb\")) == NULL) {      /* open input */\n    printf(\"Can't open file %s.\",innam);\n    exit(1);\n  }\n  if((outfile=fopen(outnam,\"wb\")) == NULL) {    /* open output */\n    printf(\"Can't open file %s.\",outnam);\n    exit(1);\n  }\n  if((errfile=fopen(errnam,\"wb\")) == NULL) {    /* open error file */\n    printf(\"\\nCan't open the error file.\");\n    exit(1);\n  }\n  if((prtfile=fopen(\"prn\",\"w\")) == NULL) {    /* open print file */\n    printf(\"\\nCan't open the printer file.\");\n    exit(1);\n  }\n\n/*  set up headings       */\n\n  chptr = (char *)&header1;           /* point to header1 line */\n  for(i=0;i<sizeof(header1);i++)      /* clear header line */\n    chptr[i] = ' ';\n  header1.hdr_skip = ' ';             /* form feed to header line */\n  memcpy(header1.title_line,\"COMPANY IVR REPORT\",\n                             38);\n  timezone = 5 * 60 * 60;             /* set local time for e.s.t */\n  daylight = -1;                      /* indicate daylit sav time */\n  time(&seconds);                     /* time in secs */\n  t = localtime(&seconds);            /* local time to tm struct */\n  if(t->tm_year > 50)                 /* convert year from 2 digits */\n    t->tm_year += 1900;               /* to 4 digits             */\n    else\n      t->tm_year += 2000;\n  sprintf(header1.hdr_date,\"%02d/%02d/%4d\",\n ((t->tm_mon)+1),t->tm_mday,t->tm_year);   /* date to header */\n  k = strlen(header1.hdr_date);\n  header1.hdr_date[k] = ' ';\n  memcpy(header1.page_lit,\"PAGE \",5); /* PAGE literal to header */\n  header1.line_nl = '\\n';\n  header1.carr_rt = '\\r';\n  header1.page_null = '\\0';           /* terminal null to header */\n\n  chptr = (char *)&header2;           /* point to header2 line */\n  for(i=0;i<sizeof(header2);i++)      /* clear header2 line */\n    chptr[i] = ' ';\n  memcpy(header2.titl2_line,\"DAILY DIRECTTALK MENU SELECTIONS REPORT\",\n                             39);\n  header2.line_nl = '\\n';\n  header2.carr_rt = '\\r';\n  header2.page_null = '\\0';           /* terminal null to header */\n\n  chptr = (char *)&header3;           /* point to header3 line */\n  for(i=0;i<sizeof(header3);i++)      /* clear header3 line */\n    chptr[i] = ' ';\n  memcpy(header3.hdr_for,\"FOR \",4);   /* literal FOR to header3 */\n  header3.line_nl = '\\n';\n  header3.carr_rt = '\\r';\n  header3.page_null = '\\0';           /* terminal null to header */\n\n  chptr = (char *)&header4;           /* point to header4 line */\n  for(i=0;i<sizeof(header4);i++)      /* clear header4 line */\n    chptr[i] = ' ';\n  memcpy(header4.titl2_line,\"WEEKLY DIRECTTALK MENU SUMMARY REPORT\",\n                             38);\n  header4.line_nl = '\\n';\n  header4.carr_rt = '\\r';\n  header4.page_null = '\\0';           /* terminal null to header */\n\n  chptr = (char *)&header5;           /* point to header5 line */\n  for(i=0;i<sizeof(header5);i++)      /* clear header5 line */\n    chptr[i] = ' ';\n  memcpy(header5.hdr_for,\"FOR \",4);   /* literal FOR to header5 */\n  header5.line_nl = '\\n';\n  header5.carr_rt = '\\r';\n  header5.page_null = '\\0';           /* terminal null to header */\n\n  chptr = (char *)&errhead;           /* point to errhead line */\n  for(i=0;i<sizeof(errhead);i++)      /* clear errhead line */\n    chptr[i] = ' ';\n  memcpy(errhead.titl2_line,\"ERROR REPORT FOR EVENT.ARC (STMENU2.C)\",\n                             38);\n  errhead.line_nl = '\\n';\n  errhead.carr_rt = '\\r';\n  errhead.page_null = '\\0';           /* terminal null to errhead */\n\n  fputs((char*)&errhead,errfile);    /* write errhead for error rpt */\n  prt.detail.carr_rt = '\\r';\n  prt.detail.line_nl = '\\n';\n  prt.detail.line_null = '\\0';\n  for(i=0;i<sizeof(prt.detail)-3;i++)\n prt.line[i] = ' ';\n  fputs(prt.line,errfile);           /* write blank line */\n\n  chptr = (char *)&footer1;           /* point to footer1 line */\n  for(i=0;i<sizeof(footer1);i++)      /* clear footer1 line */\n    chptr[i] = ' ';\n  memcpy(footer1.rpt_nm,\"RPT: stmenu2\",12);    /* literal to footer1 */\n  footer1.line_nl = '\\n';\n  footer1.carr_rt = '\\r';\n  footer1.page_null = '\\0';           /* terminal null to footer */\n\n/* pass current date to genldat2, then back up to previous Friday  */\n\n  sprintf(DATEGENL.gregmdy,\"%02d%02d%4d\",\n  ((t->tm_mon)+1),t->tm_mday,t->tm_year);    /* date to DATEGENL */\n  DATEGENL.datyp = 'g';               /* date type to DATEGENL */\n  p = &DATEGENL;\n  genldat2((struct DATEGENL *)p);  /* pointer to DATEGENL  */\n  while(DATEGENL.daywk != '5')        /* while day of week is not */\n    back1day();                       /* Friday back up one day   */\n  for(dex=LIM-1;dex>=0;dex--)  {\n edit(dates[dex],\"9999.99.99\",DATEGENL.gregymd); /* reformat, */\n back1day();                   /* save M - F dates of report */\n  }                                   /* week                       */\n  readrec();                        /* read first input file record */\n}\n/*********************************************************************/\n/*  back1day: back up one date function                              */\n/*********************************************************************/\nvoid back1day()  {\n long newdate = 0;             /* field to hold converted date */\n\n newdate = atol(DATEGENL.juldate);   /* convert date for arithmetic */\n newdate += -1;                /* subtract 1 day  */\n\n sprintf(DATEGENL.juldate,\"%7ld\",newdate);\n DATEGENL.datyp = 'j';         /* send new date back to   */\n p = &DATEGENL;                /* genldat2 and fill structure */\n genldat2(p);\n if(DATEGENL.daterr == 'e')  {     /* send year-crossing or leap  */\n  errdate();                /* year date to errdate       */\n  sprintf(DATEGENL.juldate,\"%7d\",newdate);\n  DATEGENL.datyp = 'j';\n  p = &DATEGENL;\n  genldat2(p);\n }\n}\n/*********************************************************************/\n/*  errdate:  date error function                                    */\n/*********************************************************************/\nvoid errdate()  {               /* handles backing up across a year */\n int yr;                       /* and accounts for leap year       */\n int dy;\n char jday[4];\n char jyear[5];\n int dex;\n\n sprintf(jyear,\"%s\",&DATEGENL.juldate[4]);\n for(dex=0;dex>3 && dex<8;dex++)\n  sprintf(jday,\"%s\",&DATEGENL.juldate[dex]);\n yr = atoi(jyear);\n dy = atoi(jday);\n\n if(dy == 0) {\n  dy = 366;\n  yr += -1;\n }\n if(dy == 366)\n  dy += -1;\n else\n  printf(\"Date Error Function ABEND ... stmenu2.c aborted\");\n  exit(2);\n}\n/*********************************************************************/\n/* procrec:  determine valid record, send to exceptn() or writerec() */\n/*********************************************************************/\nvoid procrec()  {\n int error = 0;\n int i;\n int sch;\n\n\n if(inrecord.infields.comma1 == ',');   /* tests for good file  */\n if(inrecord.infields.blank == ' ');    /* by looking for the   */\n if(inrecord.infields.comma2 == ',');   /* comma delimiters and */\n if(inrecord.infields.comma3 == ',');   /* blanks in the inrecord */\n else                                   /* structure             */\n    error = 1;\n\n error = 2;                            /*  assume date not found  */\n for(dex=0;dex<LIM;dex++)  {\n   if ((memcmp(inrecord.infields.recdate, dates[dex], 10)) == 0) {\n     error = 0;                        /* compares the first 10   */\n     break;                            /* chars of recdate to the  */\n   }                                  /* dates[] for the week wanted */\n }\n if(error)\n   exceptn();\n else  {\n   i = strlen(eventnm);                 /* get length of eventnm */\n   for(;i>0;i--)  {                     /* set up loop to drop   */\n     if((eventnm[i] == 0) || (eventnm[i] == ' ')); /* blanks */\n     else  {          /* at end of eventnm so   */\n       eventnm[i+1] = 0;                /* it will match event_nm */\n   break;                        /* in the event_table     */\n     }\n    }\n   for(sch=0;sch<MAX_ENTRIES;sch++)\n     if(strcmp(event_table[sch].event_nm,eventnm) == 0)\n        break;                          /* compares eventnm in data */\n   if(sch == MAX_ENTRIES)               /* to event_nm in table to  */\n        error = 3;                      /* get a hit                */\n   if(error)\n        exceptn();\n   else  {\n  event_table[sch].daytot[dex] = eventcnt; /* puts eventcnt */\n   }                                    /* in data into table array */\n }\n}\n\n/*********************************************************************/\n/* exceptn:  write a record to the exception file                    */\n/*********************************************************************/\nvoid exceptn()  {\n/*  linecnt = 0;\n    if(linecnt == 0 || linecnt > 56)\n linecnt++;       */\n    chptr = (char *)&inrecord;         /* point to the inrecord  */\n    fputs(inrecord.inrec,errfile);     /* write inrecord to errfile */\n    errcount++;\n}\n/*********************************************************************/\n/* read next input file record. at end of file, set morerecs switch. */\n/*********************************************************************/\nvoid readrec() {\n  if(fgets(inrecord.inrec,64,infile) == NULL) /* read input to eof */\n    morerecs = 0;                       /* set switch at end of file */\n  if(morerecs)\n    incount++;                           /* add 1 to records read */\n  strcpy(eventnm,inrecord.infields.eventdat); /* copy eventdat */\n  chptr = strtok(eventnm,\",\");         /* parse the event in eventnm */\n  chptr = strtok(0,\"\\n\");              /* parse the count in eventnm */\n  eventcnt = atoi(chptr);               /* convert count to integer  */\n}\n/*********************************************************************/\n/* write a record to the output file                                 */\n/*********************************************************************/\nvoid writerec() {\n  fputs(out.line,outfile);            /* write output record */\n  outcount++;                         /* add 1 to records written */\n}\n/*********************************************************************/\n/* write a line to the printer                                       */\n/*********************************************************************/\nvoid printline() {\n  prt.detail.line_null = '\\0';\n  prt.detail.line_nl = '\\n';\n  prt.detail.carr_rt = '\\r';\n  fputs(prt.line,prtfile);            /* write print line */\n  out = prt;\n  fputs(out.line,outfile);\n/*  headout();  */\n  linecnt++;                          /* add 1 to line counter */\n  if(linecnt >= MAX_ENTRIES)\n  {\n for(i=0;i<sizeof(prt.detail)-3;i++)\n   prt.line[i] = ' ';       /* clear prt line to blanks */\n for(j=0;j<10;j++)\n    fputs(prt.line,prtfile);   /* write blank lines */\n fputs((char*)&footer1,prtfile);  /* write footer line */\n  }\n  else  {\n    for(i=0;i<sizeof(prt.detail)-3;i++)\n prt.line[i] = ' ';\n    for(i=0;i<sizeof(out.detail)-3;i++)\n out.line[i] = ' ';\n  }\n}\n/*********************************************************************/\n/* headings() - write a heading for printed report                   */\n/*********************************************************************/\nvoid headings() {\n  linecnt = 0;                         /* clear line counter */\n  pagecnt++;                           /* add 1 to page counter */\n  sprintf(number,\"%3d\",pagecnt);       /* convert to printable nbr */\n  memcpy(header1.page_nbr,number,3);\n  edit(header1.page_nbr,\"zz9\",number);  /* page nbr to header line */\n  fputs((char*)&header1,prtfile);      /* write header1 line */\n  prt.detail.line_null = '\\0';\n  prt.detail.line_nl = '\\n';\n  prt.detail.carr_rt = '\\r';\n  for(i=0;i<sizeof(prt.detail)-3;i++)\n    prt.line[i] = ' ';                 /* clear print line */\n  fputs(prt.line,prtfile);             /* blank line after heading */\n\n  if(pagecnt != 6)\n  {\n    fputs((char*)&header2,prtfile);    /* write header2 line */\n    fputs((char*)&header3,prtfile);    /* write header3 line */\n    fputs(prt.line,prtfile);           /* blank line after heading */\n    fputs(prt.line,prtfile);           /* second blank line  */\n  }\n  else\n    {\n    fputs((char*)&header4,prtfile);    /* write summary header4 line */\n    fputs(prt.line,prtfile);\n    fputs((char*)&header5,prtfile);    /* write summary header5 line */\n    fputs(prt.line,prtfile);           /* blank line after heading */\n    fputs(prt.line,prtfile);           /* second blank line  */\n    }\n}\n/*********************************************************************/\n/* headout() - write a report heading for outfile.txt                */\n/*********************************************************************/\nvoid headout() {\n  linecnt = 0;                         /* clear line counter */\n  pagecnt2++;                           /* add 1 to page counter */\n  sprintf(number,\"%3d\",pagecnt2);       /* convert to printable nbr */\n  memcpy(header1.page_nbr,number,3);\n  edit(header1.page_nbr,\"zz9\",number);  /* page nbr to header line */\n  fputs((char*)&header1,outfile);      /* write header1 line */\n  out.detail.line_null = '\\0';\n  out.detail.line_nl = '\\n';\n  out.detail.carr_rt = '\\r';\n  for(i=0;i<sizeof(out.detail)-3;i++)\n    out.line[i] = ' ';                 /* clear print line */\n  fputs(out.line,outfile);             /* blank line after heading */\n\n  if(pagecnt != 6)\n  {\n    fputs((char*)&header2,outfile);    /* write header2 line */\n    fputs((char*)&header3,outfile);    /* write header3 line */\n    fputs(out.line,outfile);           /* blank line after heading */\n    fputs(out.line,outfile);           /* second blank line  */\n  }\n  else\n    {\n    fputs((char*)&header4,outfile);    /* write summary header4 line */\n    fputs(out.line,outfile);\n    fputs((char*)&header5,outfile);    /* write summary header5 line */\n    fputs(out.line,outfile);           /* blank line after heading */\n    fputs(out.line,outfile);           /* second blank line  */\n    }\n}\n\n/*********************************************************************/\n/* termination: close files                                          */\n/*********************************************************************/\nvoid terminate() {\n\n  for(dex=0;dex<LIM;dex++)            /* 1st for loop that walks the */\n  {                                    /* dates array  */\n    memcpy(header3.hdr_date,&dates[dex][5],2); /* date of data in */\n    header3.hdr_date[2] = '/';                    /* header3     */\n    memcpy(&header3.hdr_date[3],&dates[dex][8],2);\n    header3.hdr_date[5] = '/';\n    memcpy(&header3.hdr_date[6],dates[dex],4);\n    headings();\n    headout();\n    header1.hdr_skip = '\\f';\n      for(sch=0;sch<MAX_ENTRIES;sch++)  /* 2nd for loop that walks */\n      {                                 /* the event_table array */\n sprintf(prt.detail.daytot,\"%5u\",event_table[sch].daytot[dex]);\n prt.detail.daytot[5] = ' '; /* blank out null at end of daytot */\n strcpy(prt.detail.text_nm,event_table[sch].text_nm);\n j = strlen(prt.detail.text_nm);\n prt.detail.text_nm[j]    = ' '; /* blank out null at end of text_nm */\n printline();                    /* execute printline function   */\n      }\n  }\n    memcpy(header5.hdr_date,&dates[0][5],2); /* copy dates to header */\n    header5.hdr_date[2] = '/';              /* for the summary page */\n    memcpy(&header5.hdr_date[3],&dates[0][8],2);\n    header5.hdr_date[5] = '/';\n    memcpy(&header5.hdr_date[6],dates[0],4);\n    header5.hdr_date[10] = ' ';\n    header5.hdr_date[11] = '-';\n    header5.hdr_date[12] = ' ';\n    memcpy(&header5.hdr_date[13],&dates[4][5],2);\n    header5.hdr_date[15] = '/';\n    memcpy(&header5.hdr_date[16],&dates[4][8],2);\n    header5.hdr_date[18] = '/';\n    memcpy(&header5.hdr_date[19],dates[4],4);\n\n  headings();\n  headout();\n  for(sch=0;sch<MAX_ENTRIES;sch++)  /* for loop that walks the event */\n    {                               /* table for summary of eventcnt */\n for(i=0,dex=0;dex<LIM;dex++)              /* for loop that does the*/\n   i += event_table[sch].daytot[dex]; /* sum                        */\n sprintf(prt.detail.daytot,\"%5u\",i);       /* put the sum in daytot */\n prt.detail.daytot[5] = ' ';               /* get rid of null       */\n strcpy(prt.detail.text_nm,event_table[sch].text_nm);\n j = strlen(prt.detail.text_nm);           /* get rid of null at end*/\n prt.detail.text_nm[j] = ' ';              /* of text_nm            */\n printline();\n      }\n  fclose(infile);                           /* close files */\n  fclose(outfile);\n  fclose(prtfile);\n  fclose(errfile);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STRGINS": {"ttr": 14851, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00@\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x8f\\x10\\x11\\x00#\\x00'\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-08T10:11:40", "lines": 35, "newlines": 39, "modlines": 0, "user": "BC0THOR"}, "text": "/*************/\n/* strgins.c */\n/*******************************************************/\n/* subroutine strins to insert a character in a string */\n/*******************************************************/\n#define MAX 81\n#include <stdio.h>\n#include <string.h>\n\nvoid strins(char *,char,unsigned int);\n\nmain() {\n  char strng[MAX],ch;\n  unsigned int pos,size;\n\n  puts(\"Enter string to be modified:\");\n  gets(strng);\n  size=strlen(strng);\n  pos=size+1;\n  while((pos>=size)||pos==0) {\n    printf(\"Enter position in string and char to insert (1-%d,c): \",\n            size);\n    scanf(\"%u,%c\",&pos,&ch);\n  }\n  strins(strng,ch,pos);\n  printf(\"\\nThe resulting string is:\\n%s\",strng);\n}\n\nvoid strins(char *strng, char ch, unsigned int pos) {\n  char work[MAX];\n\n  strcpy(work,&strng[pos]);\n  strng[pos]=ch;\n  strcpy(&strng[pos+1],work);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "STRPUTS": {"ttr": 14853, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00r\\x00r\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 114, "newlines": 114, "modlines": 0, "user": "BC0THOR"}, "text": "/* program to print an input file using the fputs function */\n/* and using the sscanf function to build the print line   */\n/* structure from the input record structure               */\n/* author R Thornton  04/89 */\n\n#include <stdio.h>\n#include <string.h>\n\nmain(int argc, char *argv[])\n{\n    struct\n    {\n char claim_no[9];\n char last_name[15];\n char first_name[10];\n char soc_sec[9];\n char type_ins;\n char proc_code[5];\n char place;\n char amount[7];\n char clmcr;\n char clmnl;\n    } clmrec;\n\n    struct\n    {\n char pclaim[9];\n char fill1;\n char pfirst[8];\n char fill2;\n char plast[12];\n char fill3;\n char psocsec[11];\n char fill4;\n char ptype[4];\n char fill5;\n char pproc[5];\n char fill6[2];\n char pplace[4];\n char fill7;\n char pamount[9];\n char pcr;\n char pnl;\n char pterm;\n    } prtline;\n\n    FILE *infil,*prtfil;\n\n    int i;\n    long amt;\n    char amtasc[8];\n    char *pptr;\n\n    if(argc!=2)\n    {\n printf(\"\\nSYNTAX: dumphex [d:][\\path\\]filename[.ext]\");\n exit(0);\n    }\n    if((infil=fopen(argv[1],\"rb\"))==NULL)\n    {\n printf(\"\\nCan't open the input file, $s\",argv[1]);\n exit(0);\n    }\n    if((prtfil=fopen(\"prn\",\"w\"))==NULL)\n    {\n printf(\"\\nCan't open the printer file.\",argv[1]);\n exit(0);\n    }\n    pptr=&prtline;\n    for(i=0;i<sizeof(prtline);i++)\n *(pptr+i)=' ';\n    prtline.pterm = '\\0';\n\n    fputs(\"CLAIM-NO  PATIENT NAME          SOC-SEC-NBR TYPE PROC   PLACE AMOUNT\\\nr\\n\",prtfil);\n\n    while(fread(&clmrec,sizeof(clmrec),1,infil)==1)\n    {\n memcpy(prtline.pclaim,clmrec.claim_no,9);\n memcpy(prtline.plast,clmrec.last_name,12);\n memcpy(prtline.pfirst,clmrec.first_name,8);\n memcpy(prtline.psocsec,clmrec.soc_sec,3);\n *(prtline.psocsec+3) = '-';\n memcpy(prtline.psocsec+4,clmrec.soc_sec+3,2);\n *(prtline.psocsec+6) = '-';\n memcpy(prtline.psocsec+7,clmrec.soc_sec+5,4);\n if(clmrec.type_ins == 'F')\n     memcpy(prtline.ptype,\"FAM\",3);\n else if(clmrec.type_ins == 'S')\n     memcpy(prtline.ptype,\"SGL\",3);\n else if(clmrec.type_ins == 'M')\n     memcpy(prtline.ptype,\"1MIN\",3);\n else\n     memcpy(prtline.ptype,\"???\",3);\n memcpy(prtline.pproc,clmrec.proc_code,5);\n if(clmrec.place == 'D')\n     memcpy(prtline.pplace,\"OFFC\",4);\n else if(clmrec.place == 'H')\n     memcpy(prtline.pplace,\"HOSP\",4);\n else\n     memcpy(prtline.pplace,\"????\",4);\n memcpy(prtline.pamount,clmrec.amount,7);\n prtline.pcr = '\\r';\n prtline.pnl = '\\n';\n prtline.pterm = '\\0';\n fputs(&prtline,prtfil);\n for(i=0;i<sizeof(prtline);i++)\n     *(pptr+i) = ' ';\n    }\n\n\n    fclose(prtfil);\n    fclose(infil);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "SUBRUPDT": {"ttr": 14856, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00B\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x8f\\x103\\x01\\xd0\\x01\\xd0\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-08T10:33:42", "lines": 464, "newlines": 464, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* subrupdt.c */\n/*******************************************************************/\n/* This program runs daily to apply the daily subscriber update    */\n/* file from the mainframe to the current subscriber file. The     */\n/* update file contains an A, C, or D code to identify the record  */\n/* as an add, change, or delete. All records contain the subscriber*/\n/* number and gate (pilot) number. Update file records are sorted  */\n/* in ascending order by subscriber number. Add records are merged */\n/* into the new subscriber file at the correct point. Change       */\n/* records replace the former record for the subscriber, and delete*/\n/* records drop the former subscriber record.                      */\n/*                                                                 */\n/* Author R Thornton September 1993                                */\n/*******************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid initiate(int argc, char *argv[]); /* initialization function */\nvoid mainline(void);              /* mainline function */\nvoid terminat(void);              /* termination function */\nvoid readold(void);               /* read old subscriber file */\nvoid updtequl(void);              /* process update = old subscriber */\nvoid updatlow(void);              /* process update < old subscriber */\nvoid updthigh(void);              /* process update > old subscriber */\nvoid readupd(void);               /* read update file */\nvoid writenew(void);              /* write new subscriber file */\nvoid printlin(void);              /* print a line to prn */\nint edit(char output[], char pattern[], char number[]); /* edit nbr */\n\ntypedef struct {                      /* subscriber file record */\n  char subr_id[9];                      /* subscriber id */\n  char gate_no[4];                      /* gate number */\n  char nl_byte;                         /* newline character */\n  char null_byte;                       /* null for fgets()-fputs() */\n} subrecd;\n\ntypedef struct {                      /* update file record */\n  char upd_subr_id[9];                  /* subscriber id */\n  char upd_filler[6];                   /* unused */\n  char upd_gate_no[4];                  /* date number */\n  char upd_type;                        /* type: A, C, D */\n  char upd_nl;                          /* newline character */\n  char upd_null;                        /* null for fgets() */\n} updrecd;\n\nFILE *oldfile, *updfile, *newfile, *prtfile; /* file handle pointers */\nchar oldnam[81];                      /* old subscriber file name */\nchar updnam[81];                      /* update file name */\nchar newnam[81];                      /* new subscriber file name */\nchar prtnam[81];                      /* print file name */\n\nchar prtline[132];                    /* print line buffer */\nsubrecd oldrec;                       /* old subscriber record */\nupdrecd updrec;                       /* update record */\nsubrecd newrec;                       /* new subscriber record */\n\nint more_subrs = -1;                  /* old subscriber file eof sw */\nint more_updates = -1;                /* update file eof switch */\nint read_old_subr = -1;               /* read old subscriber switch */\nint read_updt_file = -1;              /* read update file switch */\nint compare;                          /* <0:low, =:equal, >0:high */\nlong old_subr_count = 0;              /* old subscriber records read */\nlong upd_count = 0;                   /* update records read */\nlong new_subr_count = 0;             /* new subscriber recds written */\nlong error_updates = 0;               /* update records in error */\nlong added_subr_count = 0;            /* subscriber records added */\nlong deleted_subr_count = 0;          /* deleted subscriber records */\nlong changed_subr_count = 0;          /* changed subscriber records */\nchar number[32];                      /* ascii number field */\n\nint subr_size;                  /* size of subscriber file records */\nint updt_size;                  /* size of update file records */\nint prnt_size;                  /* size of print records */\n\nvoid main(int argc, char *argv[]) {\n  initiate(argc, argv);               /* open files */\n  while(more_subrs || more_updates)   /* perform mainline until */\n    mainline();                         /* no more records */\n  terminat();                         /* close files */\n  exit(0);                            /* quit */\n}\n/********************************************************************/\n/* mainline function: process the update file against the old       */\n/* subscriber master file until there are no more records in either */\n/* file.\n/********************************************************************/\nvoid mainline(void) {\n  if(read_old_subr)          /* if needed, read old subscriber file */\n    readold();\n  if(read_updt_file)         /* if needed, read update file */\n    readupd();\n  while(more_subrs || more_updates) {\n    compare = memcmp(updrec.upd_subr_id, oldrec.subr_id, 9);\n    if(compare == 0)\n      updtequl();            /* update = old subscriber */\n    else\n      if(compare < 0)\n        updatlow();          /* update < old subscriber */\n      else\n        updthigh();          /* update > old subscriber */\n  }\n}\n/*******************************************************************/\n/* initialization: open files, read first input record.            */\n/*******************************************************************/\nvoid initiate(int argc, char *argv[]) {\n  if(argc == 5) {\n    strcpy(oldnam,argv[1]);        /* copy file names */\n    strcpy(updnam,argv[2]);\n    strcpy(newnam,argv[3]);\n    strcpy(prtnam,argv[4]);\n  }\n  else {\n    printf(\"\\nsubrupdt syntax: subrupdt oldsubr updtfile \\\n              newsubr, prntfil\\n\");\n    exit(1);\n  }\n  if((oldfile=fopen(oldnam,\"rb\")) == NULL) {  /* open old subr */\n    printf(\"\\nCan't open old subscriber file %s.\\n\",oldnam);\n    exit(1);\n  }\n  if((updfile=fopen(updnam,\"rb\")) == NULL) { /* open update file */\n    printf(\"\\nCan't open update file %s.\\n\",updnam);\n    exit(1);\n  }\n  if((newfile=fopen(newnam,\"wb\")) == NULL) { /* open new subr */\n    printf(\"\\nCan't open new subscriber file %s.\\n\",newnam);\n    exit(1);\n  }\n  if((prtfile=fopen(prtnam,\"w\"))==NULL) { /* open printer file */\n    printf(\"\\nCan't open the printer file %s.\\n\",prtnam);\n    exit(1);\n  }\n  subr_size = sizeof(subrecd);\n  updt_size = sizeof(updrecd);\n  prnt_size = sizeof(prtline);\n  readold();                             /* read first record    */\n  newrec.null_byte = '\\0';               /* insure end of string */\n  oldrec.null_byte = '\\0';\n  updrec.upd_null = '\\0';\n}\n/********************************************************************/\n/* subscriber id in the update record is equal to that in the old   */\n/* subscriber file: o.k. if the update is a delete or change, but   */\n/* an error otherwise. For a delete, set up to read another old     */\n/* subscriber file record. For a change, copy the update record to  */\n/* the new subscriber file and set up to read both files.           */\n/********************************************************************/\nvoid updtequl(void) {\n  if(updrec.upd_type == 'D') {          /* if delete record */\n    read_old_subr = -1;                 /* set up to read old subr */\n    deleted_subr_count++;               /* add 1 to deleted subrs */\n  }\n  else\n    if(updrec.upd_type == 'C') {        /* if change record */\n      memcpy(newrec.subr_id, updrec.upd_subr_id, 9);\n      memcpy(newrec.gate_no, updrec.upd_gate_no, 4);\n      writenew();                       /* write new subr record */\n      read_old_subr = read_updt_file = -1; /* set up to read both */\n      changed_subr_count++;             /* add 1 to changed subrs */\n    }\n    else {                    /* neither delete nor change */\n      strcpy(prtline,\"Invalid update record, subscriber on file: \");\n      printlin();                 /* print reason */\n      strcpy(prtline,(char *)&updrec);\n      printlin();                 /* print error update */\n      error_updates++;            /* add 1 to error update records */\n    }\n}\n/********************************************************************/\n/* subscriber id in the update record is lower than that in the old */\n/* subscriber file: o.k. if the update is an add, bute an error.    */\n/* if o.k., add the update record to the new subscriber file and set*/\n/* up to read another update file record.\n/********************************************************************/\nvoid updatlow(void) {\n  if(updrec.upd_type == 'A') {\n    memcpy(newrec.subr_id, updrec.upd_subr_id, 9); /* moce subr id */\n    memcpy(newrec.gate_no, updrec.upd_gate_no, 4); /* move gate nbr */\n    writenew();                     /* write new subr record */\n    read_updt_file = -1;            /* set to read update record */\n    added_subr_count++;             /* add 1 to added subrs */\n  }\n  else {\n    strcpy(prtline,\"Invalid update record: subscriber not on file: \");\n    printlin();                     /* print error reason */\n    strcpy(prtline,(char *)&updrec);\n    printlin();                     /* print the error update recd */\n    error_updates++;                /* add 1 to error update records */\n  }\n}\n/********************************************************************/\n/* subscriber id in the update record is higher than that in the old*/\n/* subscriber file: copy the current subscriber record to the new   */\n/* subscriber file and read another old subscriber record.          */\n/********************************************************************/\nvoid updthigh(void) {\n  memcpy(&newrec, &oldrec, subr_size); /* copy old record to new */\n  writenew();                          /* write to new subr file */\n  read_old_subr = -1;                  /* set up to read old subr */\n}\n/********************************************************************/\n/* read next old subscriber file record into the oldrec area. at    */\n/* end of file, set the more_subs switch to false.                  */\n/********************************************************************/\nvoid readold() {\n  if(fgets((char *)&oldrec,subr_size-1,oldfile) == NULL) /* readold  */\n    more_subrs = 0;                    /* set switch at end of file */\n  read_old_subr = 0;                   /* reset read subr switch */\n  if(more_subrs)\n    old_subr_count++;                  /* add 1 to old subrs read */\n}\n/********************************************************************/\n/* read update file record into the updrec area. at end of file set */\n/* the more_updates switch to false.                                */\n/********************************************************************/\nvoid readupd() {\n  if(fgets((char *)&updrec,updt_size-1,updfile) == NULL) /* read updt*/\n    more_updates = 0;                 /* set switch at end of file */\n  read_updt_file = 0;                 /* reset read updt switch */\n  if(more_updates)\n    upd_count++;                     /* add 1 to update record count */\n}\n/********************************************************************/\n/* write a record to the new subscriber file.                       */\n/********************************************************************/\nvoid writenew() {\n  fputs((char *)&newrec,newfile);        /* write output record */\n  new_subr_count++;              /* add 1 to new subrs written */\n}\n/********************************************************************/\n/* write a line to the report file                                  */\n/********************************************************************/\nvoid printlin() {\n  fputs(prtline,prtfile);        /* write print line */\n}\n/********************************************************************/\n/* The edit function provides numeric report editing, including     */\n/* leading zero suppression, check protection, floating $, leading  */\n/* or trailing minus sign, insertion of commas, decimal points and  */\n/* other non-numeric fields. The first parameter is the address of  */\n/* the edited output, whose size will be the same as the pattern.   */\n/* The second parameter is the editing pattern, which must be a true*/\n/* null-terminated string containing the edit pattern. The third    */\n/* is the number to be edited, a null-terminated string containing  */\n/* only digits 0-9 except the first position, which is a -, if the  */\n/* number is negative. The pattern may be up to 64 characters, and  */\n/* the number to be edited may contain up to 32 characters. The     */\n/* number may not contain more significant digits than there are    */\n/* digit select characters in the pattern. If there are more digits */\n/* selected by the pattern than there are in the number, leading    */\n/* zeros will be assumed. In the pattern, the first character may   */\n/* be:      $ (floating dollar sign)                                */\n/*          * (check protection)                                    */\n/*          - (floating minus sign)                                 */\n/* The body of the edit pattern will be composed of digit select    */\n/* characters (z and 9) and other characters, handled as follows:   */\n/*          z (zero suppression output is a blank in this position  */\n/*             until significance is set by receipt of a significant*/\n/*             digit or a 9 in the pattern. After significance is   */\n/*             set, output is a digit from the number.)             */\n/*          9 (output is a digit from the number and significance   */\n/*             is set, even if the digit is a leading zero.)        */\n/*        other characters in the pattern will be output as-is after*/\n/*             significance is set, but will be output as blanks    */\n/*             before significance is set.                          */\n/* Characters in the pattern following the last digit select will   */\n/* be output as-is if the number is negative, otherwise output will */\n/* be blanks for these pattern positions.                           */\n/*                                                                  */\n/* When * check protection is selected, output will be *, rather    */\n/* than blanks as mentioned above.                                  */\n/*                                                                  */\n/* An integer is returned to indicate success or errors:            */\n/*                 0 = successful edit                              */\n/*                 1 = pattern too long (over 64 characters)        */\n/*                 2 = too many digits selected (over 32)           */\n/*                 3 = no output digits selected in pattern         */\n/*                 4 = number contains non-numeric data             */\n/*                 5 = number has more digits than the pattern      */\n/*                                                                  */\n/* Examples:                            nbr=             outf=      */\n/*    err=edit(outf,\"zz,zz9.99-\",nbr);  0                     0.00  */\n/*                                      123                   1.23  */\n/*                                      562983            5,629.83  */\n/*                                      -4675                46.75- */\n/*    err=edit(outf,\"$,$$$.$$\",nbr);    0                           */\n/*                                      123                  $1.23  */\n/*                                      562983           $5,629.83  */\n/*                                      -4675               $46.75  */\n/*    err=edit(outf,\"***.**\",nbr);      0                           */\n/*                                      123                 **1.23  */\n/*                                      562983   err = 5            */\n/*                                      -4675               *46.75  */\n/*    err=edit(outf,\"--,--9.99\",nbr);   0                     0.00  */\n/*                                      123                   1.23  */\n/*                                      562983            5,629.83  */\n/*                                      -46.75              -46.75  */\n/*                                                                  */\n/* Author R Thornton April 1989                                     */\n/********************************************************************/\n/**/\nint edit(char output[], char pattern[], char number[]) {\n  char float_val = ' ';\n  char fill_val = ' ';\n  char sign_val = ' ';\n  int signif = 0;\n  int psize = 0;\n  int pdig = 0;\n  int plast = 0;\n  int ndig = 0;\n  char nbr[33];\n  char ch= ' ';\n  int po=0;\n  int n=0;\n\n/****************************************************************/\n/* examine pattern: set up float and fill, count size and digits*/\n/****************************************************************/\n  if(((ch=pattern[0]) == '$') || (ch == '*') || (ch == '-'))\n    float_val = ch;\n  if(ch == '*')\n    fill_val = '*';\n  while((ch=pattern[po]) != '\\0') {\n    if((ch == 'z') || (ch == '9')) {\n      pdig++;\n      plast = po;\n    }\n    psize++;\n    po++;\n  }\n  if(psize > 63)\n    return(1);\n  if(pdig > 32)\n    return(2);\n  if(!pdig)\n    return(3);\n/****************************************************************/\n/* examine number: set up sign, count digits, check numeric.    */\n/* set error if more digits than pattern, move right justified  */\n/****************************************************************/\n  if(number[0] == '-') {\n    sign_val = '-';\n    n = 1;\n  }\n  while((ch=number[n]) != '\\0') {\n    if((ch < '0') || (ch > '9'))\n      return(4);\n    ndig++;\n    n++;\n  }\n  if(ndig > pdig)\n    return(5);\n  for(po=0;po<(pdig-ndig);po++)\n    nbr[po] = '0';\n  if(sign_val == ' ')\n    n = 0;\n  else\n    n=1;\n  for(;po<pdig;po++,n++)\n    nbr[po] = number[n];\n/****************************************************************/\n/* scan across the pattern, setting the corresponding output    */\n/* byte from pattern, fill, or amt depending on the pattern     */\n/* character and state of significance.                         */\n/****************************************************************/\n  if(float_val != ' ') {\n    output[0] = ' ';\n    po = 1;\n  }\n  else\n    po = 0;\n  n = 0;\n  while((po <= plast)) {\n    ch = pattern[po];\n    if(ch == 'z') {\n      if(signif) {\n        output[po] = nbr[n];\n        n++;\n      }\n      else {\n        if(nbr[n] == '0') {\n          output[po] = fill_val;\n          n++;\n        }\n        else {\n          output[po] = nbr[n];\n          signif = -1;\n          n++;\n          if(float_val == ' ')\n            ;\n          else\n            if((float_val == '$') || (sign_val == '-'))\n              output[po-1] = float_val;\n        }\n      }\n    }\n    else if(ch == '9') {\n      output[po] = nbr[n];\n      if(!signif) {\n        signif = -1;\n        if(float_val == ' ')\n          ;\n        else\n          if((float_val == '$') || (sign_val == '-'))\n            output[po-1] = float_val;\n      }\n      n++;\n    }\n    else {\n      if(signif)\n        output[po] = pattern[po];\n      else\n        output[po] = fill_val;\n    }\n    po++;\n  }\n  while((ch=pattern[po]) != '\\0') {\n    if(sign_val == ' ')\n      output[po++] = fill_val;\n    else\n      output[po++] = pattern[po];\n  }\n  return(0);\n}\n/********************************************************************/\n/* termination: write total counts, close files.                    */\n/********************************************************************/\nvoid terminat() {\n  sscanf(number, \"%D\", &old_subr_count);\n  edit(prtline,\"zz,zzz,zz9\", number);\n  strcpy(prtline+11,\" old subscriber records read\");\n  printlin();                   /* write old subscriber count */\n  sscanf(number, \"%D\", &upd_count);\n  edit(prtline,\"zz,zzz,zz9\", number);\n  strcpy(prtline+11,\" update records read\");\n  printlin();                   /* write update record count */\n  sscanf(number, \"%D\", &new_subr_count);\n  edit(prtline,\"zz,zzz,zz9\", number);\n  strcpy(prtline+11,\" new subscriber records written\");\n  printlin();                   /* write new subscriber count */\n  sscanf(number, \"%D\", &error_updates);\n  edit(prtline,\"zz,zzz,zz9\", number);\n  strcpy(prtline+11,\" error update records dropped\");\n  printlin();                   /* write error update count */\n  sscanf(number, \"%D\", &added_subr_count);\n  edit(prtline,\"zz,zzz,zz9\", number);\n  strcpy(prtline+11,\" new subscriber records added\");\n  printlin();                   /* write old added subscriber count */\n  sscanf(number, \"%D\", &deleted_subr_count);\n  edit(prtline,\"zz,zzz,zz9\", number);\n  strcpy(prtline+11,\" old subscriber records deleted\");\n  printlin();                   /* write deleted subscriber count */\n  sscanf(number, \"%D\", &changed_subr_count);\n  edit(prtline,\"zz,zzz,zz9\", number);\n  strcpy(prtline+11,\" old subscriber records changed\");\n  printlin();                   /* write changed subscriber count */\n  fclose(prtfile);\n  fclose(oldfile);\n  fclose(updfile);\n  fclose(newfile);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "TABTOSP": {"ttr": 15107, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00T\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x8f\\x11\\x04\\x00\\x18\\x00\\x1a\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-08T11:04:54", "lines": 24, "newlines": 26, "modlines": 0, "user": "BC0THOR"}, "text": "/*************/\n/* tabtosp.c */\n/*****************************************************************/\n/* receives two string pointers from the caller. scans the first */\n/* and copies it to the second string byte-by-byte except tab    */\n/* characters, which are replaced by a string of 8 blanks in the */\n/* second string.                                                */\n/*****************************************************************/\nchar *tabtosp(char *fsource,char *fdestin) {\n  int w;\n\n  w = 0;\n  while (*fsource) {\n    if (*fsource == 9)\n      do\n        fdestin[w] = ' ';\n      while (++w % 8);\n    else\n      fdestin[w++] = *fsource;\n    fsource++;\n  }\n  fdestin[w] = 0;\n  return(fdestin);\n}\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TESTBOX": {"ttr": 15109, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x15\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x8f\\x11\\t\\x00\\x16\\x00\\x14\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-08T11:09:15", "lines": 22, "newlines": 20, "modlines": 0, "user": "BC0THOR"}, "text": "/*************/\n/* testbox.c */\n/***************************************/\n/* puts box around text using function */\n/***************************************/\n#include <stdio.h>\n\nvoid line(void);\n\nmain() {\n  line();\n  printf(\"\\n\\xDB Titus Andronicus \\xDB\");\n  line();\n}\n\nvoid line(void) {\n  int cnt;\n\n  putchar('\\n');\n  for(cnt=0;cnt<20;cnt++)\n    putchar('\\xDB');\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "TESTFILE": {"ttr": 15111, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00\\x1b\\x00\\x1b\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "BC0THOR"}, "text": "/* create a test file for the createprv program */\n#include <stdio.h>\n\nchar records[][11] = {\"\\f1234567\\n\",\n       \"2345678\\n\",\n       \"3456789\\n\",\n       \"4567890\\n\",\n       \"5678901\\n\",\n       \"6789012\\f\",\n       \"7890123\\n\",\n       \"8901234\\n\",\n       \"9012345\\n\",\n       \"\\xFFT01234\\n\",\n       \"\\f\\n\" };\nFILE *outfile;\nchar outnam[9];\nint i;\n\nmain()\n{\n if((outfile=fopen(\"testfile\",\"wb\")) == NULL) {\n  printf(\"Can't open output file.\");\n  exit(1); }\n for(i=0;i<11;i++)\n  fputs(records[i],outfile);\n fclose(outfile);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "TESTHEX": {"ttr": 15113, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x14\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x8f\\x11\\x11\\x00%\\x00#\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-08T11:11:14", "lines": 37, "newlines": 35, "modlines": 0, "user": "BC0THOR"}, "text": "/*************/\n/* testhex.c */\n/*****************************************************/\n/* prints decimal equivalents of selected hex values */\n/*****************************************************/\n#include <stdio.h>\n\nint  main(void) {\n  int i;\n\n  i = 0;\n  i = 0x1;\n  printf(\"\\ni = 0x1 ---> %d\",i);\n  i = 0;\n  i = 0x01;\n  printf(\"\\ni = 0x01 ---> %d\",i);\n  i = 0;\n  i = 0x001;\n  printf(\"\\ni = 0x001 ---> %d\",i);\n  i = 0;\n  i = 0x0001;\n  printf(\"\\ni = 0x0001 ---> %d\",i);\n\n  printf(\"\\n\");\n  i = 0;\n  i = 0x1000;\n  printf(\"\\ni = 0x1000 ---> %d\",i);\n  i = 0;\n  i = 0x100;\n  printf(\"\\ni = 0x100 ---> %d\",i);\n  i = 0;\n  i = 0x10;\n  printf(\"\\ni = 0x10 ---> %d\",i);\n  i = 0;\n  i = 0x1;\n  printf(\"\\ni = 0x1 ---> %d\",i);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "TESTSCR": {"ttr": 15115, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00J\\x00J\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 74, "newlines": 74, "modlines": 0, "user": "BC0THOR"}, "text": "/**********************************************************************/\n/* tests use of the scr... functions provided in the book \"System     */\n/* Programming in Turbo C\" by Michael J. Young                        */\n/**********************************************************************/\n#include <stdio.h>\n#include <scr.h>\n\nvoid main() {\n struct mode mymode, *modeptr = &mymode;\n int row, col, page, i;\n int start_line, stop_line;\n char getstrg[80];\n\n get_mode(modeptr);\n printf(\"\\nFrom the get_mode() function:\");\n printf(\"\\n   video_mode is: %d\",modeptr->video_mode);\n printf(\"\\n   columns is: %d\",modeptr->columns);\n printf(\"\\n   video_page is %d\",modeptr->video_page);\n printf(\"\\n\");\n\n page = 0;\n get_cur(&row, &col, page);\n printf(\"\\nFrom the get_cur() function:\");\n printf(\"\\n   row is: %d\",row);\n printf(\"\\n   col is: %d\",col);\n printf(\"\\n   page is %d\",page);\n printf(\"\\n\");\n\n get_style(&start_line, &stop_line);\n printf(\"\\nFrom the get_style() function:\");\n printf(\"\\n   start_line is: %d\",start_line);\n printf(\"\\n   stop_line is: %d\",stop_line);\n printf(\"\\n\");\n\n printf(\"\\n\");\n for(row=1; row<25; row++)\n  for(col=1; col<81; col++) {\n   page = col % 10;\n   printf(\"%1d\",page);\n  }\n\n put_box(0,0,5,6,0);\n put_box(19,0,23,5,1);\n put_box(0,70,5,79,2);\n put_box(19,70,23,79,3);\n\n\n scr_clear(10,20,18,60);\n\n scr_puts(\"Hello\",0x0F,1,1);\n scr_puts(\"Hello\",0xF0,2,1);\n scr_puts(\"Hello\",0x63,3,1);\n\n put_attr(0x34,4,1,4,5);\n put_attr(0x70,20,1,22,4);\n\n scr_gets(getstrg,0x34,20,1,4,UPPER);\n scr_puts(getstrg,0x34,20,71);\n\n if((i = scr_push()) != NOERROR)\n  printf(\"\\nscr_push returned %d\",i);\n\n scr_clear(0,0,24,79);\n put_box(10,5,14,65,1);\n getstrg[0] = '\\0';\n scr_puts(\"Type yes to recall last screen:\",0x0F,12,6);\n while(strcmp(getstrg,\"YES\"))\n  scr_gets(getstrg,0x34,12,37,4,UPPER);\n\n if((i = scr_pop(-1)) != NOERROR)\n  printf(\"\\nscr_pop returned %d\",i);\n\n\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "TIMEOUT": {"ttr": 15118, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00Y\\x00Y\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 89, "newlines": 89, "modlines": 0, "user": "BC0THOR"}, "text": "/**************************************************************************/\n/*                         polling using O_NDELAY                         */\n/* fcntl() can be used to set O_NDELAY on a file descriptor associated    */\n/* with a terminal. This allows read() to return immediately if no data   */\n/* has been typed in on the terminal. This type of input is referred to as*/\n/* polling and is often used in programs that must regularly perform some */\n/* actions regardless of user input. Note that polling cannot be done by  */\n/* setting MIN and TIME to zero as a value of zero disables them.         */\n/*                                                                        */\n/* From \"Topics in C Programming\" by Stephen G. Kochan and Patrick H. Wood*/\n/*      Chapter 6: The UNIX System Interface, pages 274-277               */\n/**************************************************************************/\n\n#include <errno.h>\n#include <stdio.h>\n#include <termio.h>\n#include <fcntl.h>\n#include <stdlib.h>\n\nmain() {\n struct termio save, term;\n char          in, outbuf[20];\n int           nchar, savefcntl;\n void          do_things(void);\n\n /* turn on O_NDELAY to allow polling */\n\n savefcntl = fcntl(0, F_GETFL, 0);  /* get status flags associated */\n                                     /* with standard input */\n\n fcntl(0, F_SETFL, savefcntl | O_NDELAY); /* turn on \"no delay\" mode */\n                                           /* on standard input */\n\n if(ioctl(0, TCGETA, &term) == -1) {   /* set up to allow each character */\n                    /* to be read as it is typed in.  */\n                    /* Now, when read is called, it will */\n                    /* read a single character if one */\n                    /* was typed since the last read, */\n                    /* and it will return without */\n                    /* waiting if nothing has been typed */\n  fprintf(stderr, \"standard input not a tty\\n\");\n  exit(errno);\n }\n\n /* save old tty state */\n\n save = term;\n\n /* turn off canonical processing */\n\n term.c_lflag &= ~ICANON;  /* if canonical processing is left on, read */\n              /* will return without reading anything until */\n              /* a RETURN is entered, then the entire line */\n              /* will be available.\n\n /*\n ** set MIN to one and TIME to zero\n ** can read each character as it is typed\n */\n\n term.c_cc[VMIN] = 1;\n term.c_cc[VTIME] = 0;\n\n /* SET NEW TERMINAL STATE */\n\n ioctl (0, TCSETA, &term);\n\n /* input characters until q is typed */\n\n do {\n  write(1, \": \", 2);\n  do_things();\n  nchar = read(0, &in, 1);\n\n  if(nchar != 0)\n   sprintf((outbuf, \" got a '%c'\\n\", in);\n  } while(in != 'q');\n\n  /* reset old tty state */\n\n  ioctl(0, TCSETA, &save);\n  fcntl(0, F_SETFL, savefcntl);\n\n  exit(EXIT_SUCCESS);\n{\n\nvoid do_things(void) {\n sleep(1);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "TRYEDIT": {"ttr": 15121, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00C\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x8f\\x13Q\\x00\\x19\\x00\\x16\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-08T13:51:43", "lines": 25, "newlines": 22, "modlines": 0, "user": "BC0THOR"}, "text": "/*************/\n/* tryedit.c */\n/******************************************************************/\n/* test use of the edit function to produce edited numeric fields */\n/******************************************************************/\n#include <stdio.h>\n#include <string.h>\n\nvoid edit(char *output, char *pattern, char *number);\n\nmain() {\n  int i;\n  long l;\n  float f;\n  char pattern[15];\n  char output[15];\n  char number[15];\n\n  i = 6350;                      /* set up number */\n  sprintf(number,\"%d\",i);     /* convert it to an ascii digit string */\n  strcpy(pattern,\"z,zzz,zzz\");   /* build the edit pattern */\n  edit(output, pattern,number);  /* edit the number into output */\n  output[9] = '\\0';              /* terminate the string */\n  printf(\"%s\",output);           /* display the result */\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "TRYFMOD": {"ttr": 15123, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x05\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x8f\\x13S\\x00\\x11\\x00\\x11\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-08T13:53:05", "lines": 17, "newlines": 17, "modlines": 0, "user": "BC0THOR"}, "text": "/*************/\n/* tryfmod.c */\n/*************************************************************/\n/* sample program to demonstrate use of the fmod() function. */\n/*************************************************************/\n#include <stdio.h>\n#include <math.h>\n\nvoid main(void) {\n int year=93,birth=35;\n int i,tot_day;\n\n for(i = tot_day = 0; year > birth; ++i)\n  if(fmod((double)(year-birth++), 4.0))\n   tot_day++;\n printf(\"\\ntot_day = %d\",tot_day);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "TWINKLE": {"ttr": 15125, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00\\x91\\x00\\x91\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 145, "newlines": 145, "modlines": 0, "user": "BC0THOR"}, "text": "/* following example program for AIX uses the extended curses library */\n/* (libcur.a) to create a series of displays on the screen            */\n#include <cur00.h>\n#include <signal.h>\n\n#define NCOLS 80\n#define NLINES 24\n#define MAXPATTERNS 11\n\nstruct locs {\n char y, x;\n}\n\ntypedef struct locs LOCS;\n\nLOCS layout[NCOLS * NLINES]; /* current board layout */\n\nint pattern,                   /* current pattern number */\n numstars;                  /* number of stars in ptern */\n\nmain() {\n\n char *getenv();\n int die();\n\n srand(getpid());          /* initialize random sequence */\n initscr();\n signal(SIGINT,die);\n noecho();\n leaveok(stdscr,TRUE);\n scrollok(stdscr,FALSE);\n\n for(;;) {\n  makeboard();           /* make the board setup */\n  puton('*');            /* put on '*'s */\n  system(\"sleep 2\");\n  erase();\n  refresh();\n }\n}\n/*********************************************************************/\n/* On program exit, move the cursor to the lower left corner by      */\n/* direct addressing, since current location is not certain.         */\n/* We say we used to be at the upper right corner to obtain absolute */\n/* addressing.                                                       */\n/*********************************************************************/\ndie() {\n signal(SIGINT,SIG_IGN);\n mvcur(LINES/2, COLS/2, 0, 0);\n wclear(curscr);\n wrefresh(curscr);\n endwin();\n exit(0);\n}\n/*********************************************************************/\n/* Make the current board setup. It picks a random pattern and calls */\n/* ison() to determine if the character is on that pattern or not.   */\n/*********************************************************************/\nmakeboard() {\n register int y, x;\n register LOCS *lp;\n\n pattern = rand() % MAXPATTERNS;\n lp = layout;\n for(y=0; y<NLINES; y++) {\n  for(x=0; x<NCOLS; x++) {\n   if(ison(y, x)) {\n    lp->y = y;\n    lp++->x = x;\n   }\n  }\n }\n numstars = lp - layout;\n}\n\n/*********************************************************************/\n/* Return TRUE if (y, x) is on the current pattern.                  */\n/*********************************************************************/\nison(y, x)\n register int y, x;\n{\n switch(pattern) {\n  case 0:        /* Alternating lines */\n   return !(y & 01);\n  case 1:        /* Box */\n   if(y<3 || y >= NLINES - 3)\n    return TRUE;\n   return(x<4 || x >= NCOLS - 4);\n  case 2:        /* Cross */\n   return((x + y) & 01);\n  case 3:        /* Bar across center */\n   return(y >= 9 && y <= 15);\n  case 4:        /* Alternating columns */\n   return !(x & 02);\n  case 5:        /* Bar down center */\n   return(x >= 36 && x <= 44);\n  case 6:        /* Bar across and down center */\n   return((y >= 9 && y <= 15) || (x >= 37 && x <= 43));\n  case 7:        /* Bar across and down center, in a box */\n   if(y < 3 || y >= NLINES - 3)\n    return TRUE;\n   if(x < 4 || x >= NCOLS - 4)\n    return TRUE;\n   return((y >= 10 && y <= 14) || (x >= 36 && x <= 44));\n  case 8:        /* Asterisk */\n   if(abs(x - y) <= 2 || abs(NLINES - (x + y)) <= 2)\n    return TRUE;\n   if(abs((NLINES/2) - x) <= 2)\n    return TRUE;\n   return(abs((NLINES/2) - y) <= 1 && x <= NLINES);\n  case 9:        /* Ellipse */\n   return((\n     ((float)((x-40) * (x-40))) / 1521 +\n     ((float) ((y-12) * (y-12))) / 121\n       ) <= 1\n      );\n  case 10:      /* Circle */\n   return ((\n      ((float)((x-28) * (x-28))) / 729 +\n      ((float) ((y-12) * (y-12))) / 121\n     ) <= 1\n       );\n }\n}\n\nputon(ch)\nregister char ch;\n{\n register LOCS *lp;\n register LOCS *end;\n LOCS temp;\n register int r;\n\n end = &layout[numstars];\n for(lp = layout; lp < end; lp++) {\n  r = rand() % numstars;\n  temp = *lp;\n  *lp = layout[r];\n  layout[r] = temp;\n }\n for(lp = layout; lp < end; lp++) {\n  mvaddch(lp->y, lp->x, ch);\n  refresh();\n }\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "TXSTK": {"ttr": 15361, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00W\\x00W\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 87, "newlines": 87, "modlines": 0, "user": "BC0THOR"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TXSTK2": {"ttr": 15364, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00Z\\x00Z\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 90, "newlines": 90, "modlines": 0, "user": "BC0THOR"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TYPE2": {"ttr": 15367, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00)\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x8f\\x13V\\x00\\x19\\x00\\x15\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-08T13:56:29", "lines": 25, "newlines": 21, "modlines": 0, "user": "BC0THOR"}, "text": "/***********/\n/* type2.c */\n/***************************/\n/* reads strings from file */\n/***************************/\n#include <stdio.h>\n#include <stdlib.h>\n\nmain(int argc, char *argv[]) {\n  FILE *fptr;\n  char string[81];\n\n  if(argc != 2) {       /* Expect 2 agruments */\n    printf(\"\\nFormat is: C>type2 filename\\n\");\n    exit(0);\n  }\n  if((fptr=fopen(argv[1],\"r\")) == NULL) { /* open the file */\n    printf(\"\\nCan't open the file %s.\\n\",argv[1]);\n    exit(0);\n  }\n  while(fgets(string,80,fptr) != NULL)     /* read a string */\n    printf(\"%s\",string);                   /* print string */\n  printf(\"\\n\");\n  fclose(fptr);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "TZBIGLTR": {"ttr": 15369, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00!\\x00!\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "BC0THOR"}, "text": "main()\n{\n char wchar,fchr,fch;\n int frow,fcol,wrow,wcol,i;\n char far *wtable;\n\n wchar=fchr=fch=' ';\n frow=fcol=wrow=wcol=0;\n wtable=(char far *)0xF000FA6E;\n\n printf(\"\\nEnter letter, row, column, fill: \");\n scanf(\"%c %d %d %c\",&fchr,&frow,&fcol,&fch);\n    printf(\"\\x1B[2J\");\n\n wtable+=(fchr*8);\n\n for(wrow=0;wrow<8;wrow++)\n  {\n  wchar=*(wtable+wrow);\n     for(wcol=7;wcol>=0;wcol--)\n   {\n      if(wchar&1)\n    printf(\"\\x1B[%d;%df%c\",frow+wrow,fcol+wcol,fch);\n   else\n    printf(\"\\x1B[%d;%df\\xB0\",frow+wrow,fcol+wcol);\n      wchar >>= 1;\n   for(i=0;i<29999;i++);\n   }\n  }\n printf(\"\\nPress any key to continue: \");\n getche();\n}\n\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "UNUCASE": {"ttr": 15371, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00 \\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x8f\\x14\\x03\\x00A\\x00F\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-08T14:03:20", "lines": 65, "newlines": 70, "modlines": 0, "user": "BC0THOR"}, "text": "/*************/\n/* unucase.c */\n/**********************************************************/\n/* copy upper case only file, making upper and lower case */\n/**********************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n  FILE *infile, *outfile;\n  char innam[81],outnam[81];\n  int ch, new_sentence, good_char;\n  char last_char;\n\n  if(argc == 3) {\n    strcpy(innam,argv[1]);\n    strcpy(outnam,argv[2]);\n  }\n  else {\n    printf(\"\\nEnter input file spec: \");\n    scanf(\"%s\",innam);\n    printf(\"\\nEnter output file spec: \");\n    scanf(\"%s\",outnam);\n  }\n  if((infile=fopen(innam,\"rb\")) == NULL) {\n    printf(\"Can't open file %s.\",innam);\n    exit(8);\n  }\n  if((outfile=fopen(outnam,\"wb\")) == NULL) {\n    printf(\"Can't open file %s.\",outnam);\n    exit(8);\n  }\n  last_char = ' ';\n  new_sentence = 1;\n  while(1) {\n    ch=fgetc(infile);\n    good_char = -1;\n    if((ch == EOF) || (ch == 0x1A))\n      break;\n    if(ch > 128)\n    ch -= 128;\n    if ((ch >= 'A') && (ch <= 'Z'))\n      if(new_sentence)\n        new_sentence = 0;\n      else\n        ch += 32;\n    else {\n      new_sentence = 0;\n      if(ch == ' ') {\n        if((last_char == '.') || (last_char == ' '))\n        new_sentence = -1;\n      }\n      else if((ch == 0x0A) && (last_char == 0x0A))\n        good_char = 0;\n    }\n  last_char = ch;\n  if(good_char)\n    fputc(ch,outfile);\n  if(ch == 0x0D)\n    fputc(0x0A,outfile);\n }\n fclose(infile);\n fclose(outfile);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "UPPRCASE": {"ttr": 15373, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00 \\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x8f\\x14\\x12\\x00,\\x00/\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-08T14:12:20", "lines": 44, "newlines": 47, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* upprcase.c */\n/**************/\n/******************************************************/\n/* copy file, changing lower case alpha to upper case */\n/******************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nmain(int argc, char *argv[]) {\n  FILE *infile, *outfile;\n  char innam[81],outnam[81];\n  unsigned int ch;\n\n  if(argc == 3) {\n    strcpy(innam,argv[1]);\n    strcpy(outnam,argv[2]);\n  }\n  else {\n    printf(\"\\nEnter input file spec: \");\n    scanf(\"%s\",innam);\n    printf(\"\\nEnter output file spec: \");\n    scanf(\"%s\",outnam);\n  }\n  if((infile=fopen(innam,\"rb\")) == NULL) {\n    printf(\"Can't open file %s.\",innam);\n    exit(8);\n  }\n  if((outfile=fopen(outnam,\"wb\")) == NULL) {\n    printf(\"Can't open file %s.\",outnam);\n    exit(8);\n  }\n  while(1) {\n    ch=fgetc(infile);\n    if((ch == EOF) || (ch == 0x1A))\n      break;\n    if((ch >= 'a') && (ch <= 'z'))\n      ch -= 32;\n    fputc(ch,outfile);\n  }\n  fclose(infile);\n  fclose(outfile);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "VALUES": {"ttr": 15375, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x16\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x8f\\x14\\x16\\x00\\x12\\x00\\x10\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-08T14:16:16", "lines": 18, "newlines": 16, "modlines": 0, "user": "BC0THOR"}, "text": "/************/\n/* values.c */\n/*******************************************/\n/* tests function which accepts two values */\n/*******************************************/\n#include <stdio.h>\n\nvoid gets2(int,int);\n\nint main() {\n  int x=4,y=7;\n\n  gets2(x,y);\n}\n\nvoid gets2(int xx,int yy) {\n  printf(\"First is %d, second is %d\",xx,yy);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "VENUS": {"ttr": 15377, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00F\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x8f\\x14\\x17\\x00\\n\\x00\\t\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-08T14:17:46", "lines": 10, "newlines": 9, "modlines": 0, "user": "BC0THOR"}, "text": "/***********/\n/* venus.c */\n/*******************************************************************/\n/* sample showing use of the printf() function to display a string */\n/*******************************************************************/\n#include <stdio.h>\n\nmain() {\n printf(\"%s is %d million miles\\nfrom the sun.\",\"Venus\",67);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "VOICEMOD": {"ttr": 15379, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00\\x10\\x00\\x10\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "BC0THOR"}, "text": "main()\n{\n    int voice,group,voice_mod;\n\n    for(group=1;group<3;group++)\n  for(voice=1;voice<7;voice++)\n  {\n   voice_mod = group + (((voice - 1) % 3) << 10);\n         getport(0x02F0 | voice_mod,group,voice);\n  }\n}\n\ngetport(int port, int group, int voice)\n{\n printf(\"\\nfor group %d, voice %1d, port is %04X\",group,voice,port);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "VSAMCALC": {"ttr": 15381, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x004\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x8f\\x14!\\x00$\\x00(\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-08T14:21:34", "lines": 36, "newlines": 40, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* vsamcalc.c */\n/*********************************************************************/\n/* calculate physical records per track for multiples of 4096 on 3390*/\n/*********************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid main() {\n  long prpt, sp, d, prsz, dn, rem;\n  float dtur;\n  char c;\n\n  for(prsz=2048; prsz < 32768; prsz+=2048) {\n    dn = (prsz + 6) / 232;\n    rem = (prsz + 6) % 232;\n    if(rem)\n      dn++;\n    d = 9 + ((prsz + (6 * dn) + 6) / 34);\n    rem = (prsz + (6 * dn) + 6) / 34;\n    if(rem) d++;\n      sp = 10 + d;\n    prpt = 1729 / sp;     /* physical records per track */\n    dtur = (100 * (prsz * prpt)) / 56664.0; /* disk track util. rate */\n    printf(\"for a physical record size (CI size) of %ld:\\n\", prsz);\n    printf(\"     dn=%ld\\n\",dn);\n    printf(\"     d=%ld\\n\",d);\n    printf(\"     sp=%ld\\n\",sp);\n    printf(\"     physical records per track = %ld\\n\",prpt);\n    printf(\"     3390 disk track utilization rate = %.2f\\n\",dtur);\n    printf(\"\\n press Enter to continue or q to quit\\n\");\n    c=getchar();\n    if(c == 'q') exit(0);\n  }\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "WAYNE": {"ttr": 15383, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\t\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x8f\\x14%\\x00\\x17\\x00\\x16\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-08T14:25:09", "lines": 23, "newlines": 22, "modlines": 0, "user": "BC0THOR"}, "text": "/***********/\n/* wayne.c */\n/**************************************************/\n/* ask for age in years, respond with age in days */\n/**************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n\nmain() {\n  float years=50, days;\n  char chyrs[80];\n  char msg[] = \"Please type your age in years: \";\n\n  while(years != 0.0) {\n    printf(\"%s\",msg);\n    gets(chyrs);\n    years = atof(chyrs);\n    if(years != 0.0) {\n      days = years * 365;\n      printf(\"You are %12.3f days old.\\n\",days);\n    }\n  }\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "WINDOW1": {"ttr": 15385, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x008\\x008\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 56, "newlines": 56, "modlines": 0, "user": "BC0THOR"}, "text": "#include <dos.h>\n#include <conio.h>\n\nstruct\n{\n int wleft;\n int wtop;\n int wright;\n int wbottom;\n int lastques;\n} *wptr, wndo[5] = {{1,2,15,21,19},\n     {17,2,31,21,39},\n     {33,2,47,21,59},\n     {49,2,63,21,79},\n     {65,2,79,21,99}};\n\nmain()\n{\n char student_name[26];\n int ques,i;\n\n  textbackground(BLACK);\n  textcolor(WHITE);\n  clrscr();\n  textmode(C80);\n\n  wptr = wndo;\n  for(ques=0;ques<100;)\n  {\n   window(wptr->wleft,wptr->wtop,wptr->wright,wptr->wbottom);\n   textbackground(BLUE);\n   textcolor(YELLOW);\n   clrscr();\n   for(;ques<=(wptr->lastques);ques++)\n   {\n    if(ques==(wptr->lastques))\n     cprintf(\" %02d (A) = A\",ques+1);\n    else\n     cprintf(\" %02d (A) = A\\r\\n\",ques+1);\n   }\n   wptr++;\n  }\n  window(1,22,79,25);\n  textbackground(RED);\n  textcolor(LIGHTGRAY);\n  clrscr();\n  window(1,1,79,1);\n  textbackground(RED);\n  textcolor(LIGHTGRAY);\n  clrscr();\n  cputs(\"Student's name (last, first): \");\n  cgets(student_name);\n\n  textbackground(BLACK);\n  textcolor(WHITE);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "WINTEST": {"ttr": 15618, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00\\x12\\x00\\x12\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "BC0THOR"}, "text": "/* make use of text window functions */\n#include <stdio.h>\n#include <conio.h>\n\nvoid main() {\n  int wleft=6,wtop=2,wright=25,wbottom=11;\n  int x=6,y=2,i;\n  char wlines[10][21];\n\n  window(wleft,wtop,wright,wbottom);\n  clrscr();\n  for(i=0;i<10;i++) {\n gotoxy(x,y++);\n   gets(wlines[i]);\n  }\n\n  movetext(wleft,wtop,wright,wbottom,36,9);\n}\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WLOOP": {"ttr": 15620, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00R\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x8f\\x14)\\x00\\x10\\x00\\x0f\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-08T14:29:52", "lines": 16, "newlines": 15, "modlines": 0, "user": "BC0THOR"}, "text": "/***********/\n/* wloop.c */\n/*******************************************************/\n/* uses while loop to print numbers with running total */\n/*******************************************************/\n#include <stdio.h>\n\nmain() {\n  int count=0;\n  int total=0;\n\n  while(count < 10 ) {\n    total+=count;\n    printf(\"count=%d, total=%d\\n\",count++,total);\n  }\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "WORDCNTF": {"ttr": 15622, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x002\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x8f\\x143\\x00%\\x00\\x1e\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-08T14:33:32", "lines": 37, "newlines": 30, "modlines": 0, "user": "BC0THOR"}, "text": "/**************/\n/* wordcntf.c */\n/*******************************/\n/* counts words in a text file */\n/*******************************/\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n  FILE *fptr;\n  int ch, string[81];\n  int white = 1;                   /* whitespace flag*/\n  int count=0;                     /*word count */\n\n  if(argc != 2) {                 /* should be 2 args */\n    printf(\"\\nFormat: C>wordcntf filename\");\n    exit(0);\n  }\n  if((fptr=fopen(argv[1],\"r\")) == NULL) { /* open file */\n    printf(\"\\nCan't open file named %s \\n\",argv[1]);\n    exit(0);\n  }\n  while((ch=getc(fptr)) != EOF)     /* get character from file */\n    switch(ch) {\n      case ' ':                 /* if space, tab, or newline */\n      case '\\t':\n      case '\\n': white++;\n      break;\n      default:\n        if(white) {\n          white= 0;\n          count++;\n        }\n    }\n  fclose(fptr);                 /* close the file */\n  printf(\"\\nFile %s contains %d words.\\n\",argv[1], count);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "WPRINTF": {"ttr": 15624, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x01\"\\x01\"\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 290, "newlines": 290, "modlines": 0, "user": "BC0THOR"}, "text": "/*\n * KPRINTF -- \"kernel\" formatted print routines for DeSmet C\n *\n * Copyright 1985 by John McNamee.\n * This software may be freely copied for non-commercial use.\n * Commercial use requires the written permission of the author.\n *\n *  John McNamee\n *  7560 McLaren Ave.\n *  Canoga Park, CA 91307\n *\n *  CompuServe: 70235,1345\n *  Usenet: decvax!philabs!sbcs!bnl!jpm\n *  Internet: jpm@BNL.ARPA\n */\n\n/*\n *   Overview of this package:\n *\n * kprintf() and ksprintf() should act exactly like printf and sprintf, except\n * they don't do floating point. The idea is to avoid bringing in the floating\n * point and file handling library routines that get loaded every time the\n * normal printf or sprintf are called. My routines add less than 2K to\n * program size, while normal printf adds over 6K. Of course, if you are going\n * to do file I/O or floating point you mind as well use the normal routines.\n * These functions are for writing programs programs that wouldn't otherwise\n * bring in all that code.\n *\n * I'm sure this code could be made smaller and faster. This was done \"quick\n * and dirty\" and I don't want to hear from anybody about bad coding style.\n * This really should be written in assembly language, but who has the time?\n */\n\n/*\n * Notes on converting to something other than DeSmet C:\n *\n * It shouldn't be too hard to move these routines to another C compiler.\n * The main thing you will have to do is check if calling putchar() brings\n * in the whole file I/O library of your compiler. It doesn't on DeSmet.\n * If yours does, write something that does tha same thing (its just a simple\n * call to MSDOS), and use it instead of putchar in the kprintf() function.\n */\n\n/* \"FAST\" is the type that produces the fastest local variables. */\n/* It is normally \"register\", but Intel chips are very braindamaged and */\n/* don't have enough registers, so you must use \"static\". */\n#define FAST register\n\nstatic int left_flag, do_padding, num1, num2;\nstatic char outbuf[32], *sp_ptr, pad_character;\nstatic int wrow,wcol,wstart,wend;\n\n/*\n * Print on terminal\n */\n\nextern int _row1,_row2,_col1,_col2,_attr,g_row,g_col,g_fore,g_back;\n#include <ctype.h>\nwprintf(ctrl, args)\nchar *ctrl, *args;\n{\n int putachar();\n\n jzgetcur(&wrow,&wcol,&wstart,&wend);\n doprint(putachar, ctrl, &args);\n}\n\nstore_chr(ch)\nint ch;\n{\n *sp_ptr++ = ch;\n}\n\n/*\n * Generalized routine\n */\n\nstatic doprint(outfunc, ctrl, argp)\nint (*outfunc)();\nchar *ctrl, *argp;\n{\n FAST int long_flag;\n FAST char *cp, ch;\n FAST int dot_flag;\n\n for (;*ctrl;ctrl++) {\n  if (*ctrl!='%') {\n   (*outfunc)(*ctrl);\n   continue;\n  }\n  dot_flag=long_flag=left_flag=do_padding=0;\n  num2=32767;\n  pad_character=' ';\n\ntry_next: ch = *(++ctrl);\n\n  if (isdigit(ch)) {\n   if (dot_flag)\n    num2=getnum(&ctrl);\n   else {\n    if (ch=='0')\n     pad_character='0';\n    num1=getnum(&ctrl);\n    do_padding=1;\n   }\n   ctrl--;\n   goto try_next;\n  }\n\n  switch (tolower(ch)) {\n  case 0:\n   return;\n  case '%':\n   (*outfunc)('%');\n   continue;\n  case '-':\n   left_flag=1;\n   break;\n  case '.':\n   dot_flag=1;\n   break;\n  case 'l':\n   long_flag=1;\n   break;\n  case 'd':\n   if (long_flag || ch=='D') {\n    outnum(outfunc, *((long *)argp), 10L);\n    argp+=sizeof(long);\n    continue;\n   } else {\n    outnum(outfunc, (long)(*((int *)argp)), 10L);\n    argp+=sizeof(int);\n    continue;\n   }\n  case 'x':\n   if (long_flag || ch=='X') {\n    outnum(outfunc, *((long *)argp), 16L);\n    argp+=sizeof(long);\n    continue;\n   } else {\n    outnum(outfunc, (long)(*((int *)argp)), 16L);\n    argp+=sizeof(int);\n    continue;\n   }\n  case 'o':\n   if (long_flag || ch=='X') {\n    outnum(outfunc, *((long *)argp), 8L);\n    argp+=sizeof(long);\n    continue;\n   } else {\n    outnum(outfunc, (long)(*((int *)argp)), 8L);\n    argp+=sizeof(int);\n    continue;\n   }\n  case 's':\n   outs(outfunc, *((char **)argp));\n   argp+=sizeof(char *);\n   continue;\n  case 'c':\n   (*outfunc)(*((int *)argp));\n   argp+=sizeof(int);\n   continue;\n  case 'f':\n  case 'e':\n  case 'g':\n   do_padding=0;\n   num2=32767;\n   outs(outfunc, \"*No floating point in kprintf!*\");\n   continue;\n  default:\n   continue;\n  }\n  goto try_next;\n }\n}\n\n/*\n * Function used to output a line\n */\n\nstatic outs(outfunc, lp)\nint (*outfunc)();\nchar *lp;\n{\n FAST int i, len;\n\n /* Blank pad on left if needed */\n if (do_padding && !left_flag && (len=strlen(lp))<num1)\n  for (i=len; i<num1; i++)\n   (*outfunc)(pad_character);\n\n /* Now output string */\n while (*lp && num2--)\n  (*outfunc)(*lp++);\n\n /* Blank pad on right if needed */\n if (do_padding && left_flag && (len=strlen(lp))<num1)\n  for (i=len; i<num1; i++)\n   (*outfunc)(pad_character);\n}\n\n/*\n * Output a number\n */\n\nstatic outnum(outfunc, num, base)\nint (*outfunc)();\nlong num, base;\n{\n FAST char *cp;\n FAST int i, len, negative;\n static char digits[]=\"0123456789ABCDEF\";\n\n /* Build number (backwards) in outbuf */\n if (num<0L) {\n  negative = 1;\n  num = -num;\n } else\n  negative = 0;\n\n cp=outbuf;\n do {\n  *cp++ = digits[num%base];\n } while ((num/=base) > 0);\n if (negative)\n  *cp++ = '-';\n *cp-- = 0;\n len=strlen(outbuf);\n\n /* Blank pad on left if needed */\n if (do_padding && !left_flag && len<num1)\n  for (i=len; i<num1; i++)\n   (*outfunc)(pad_character);\n\n /* Now output the buffer in reverse order */\n while (cp>=outbuf)\n  (*outfunc)(*cp--);\n\n /* Blank pad on right if needed */\n if (do_padding && left_flag && len<num1)\n  for (i=len; i<num1; i++)\n   (*outfunc)(pad_character);\n}\n\n/*\n * Get a number from the control string.\n *\n * This function takes a pointer to a character pointer (which it\n * updates to point to the character after the end of the number)\n * and returns an integer result.\n */\n\nstatic getnum(linep)\nchar **linep;\n{\n FAST int n;\n FAST char *cp;\n\n cp = *linep;\n n = 0;\n\n while (isdigit(*cp))\n  n = n*10 + ((*cp++)-'0');\n\n *linep = cp;\n return(n);\n}\n\nstatic putachar(fch)\nchar fch;\n{\n\n  if (wcol > _col2) {\n    wcol = _col1;\n    if (wrow == _row2)\n      jzscrlup(_row1 << 8 | _col1,_row2 << 8 | _col2,1,_attr);\n    else\n      ++ wrow;\n  }\n\n  if (fch) {\n    jzwrtchr(fch,_attr,1);\n    ++ wcol;\n  }\n\n  g_row=wrow;\n  g_col=wcol;\n\n  jzloccur(wrow,wcol);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WRITE": {"ttr": 15630, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x8f\\x148\\x00\\x18\\x00\\x15\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-08T14:38:40", "lines": 24, "newlines": 21, "modlines": 0, "user": "BC0THOR"}, "text": "/************/\n/* write.c */\n/*********************************/\n/* writes formatted data to file */\n/*********************************/\n#include <stdio.h>\n#include <string.h>\n\nmain() {\n  FILE *fptr;\n  char name[40];\n  int code;\n  float height;\n\n  fptr = fopen(\"textfil2.txt\",\"w\");   /* open output file */\n  do {\n    printf(\"\\nType name, code number, and height: \");\n    scanf(\"%s %d %f\", name,&code,&height);\n    fprintf(fptr,\"%s %d %f\", name, code, height);\n  }\n  while(strlen(name) > 1);          /* continue if name given */\n  printf(\"\\n\");\n  fclose(fptr);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "WRITEC": {"ttr": 15632, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\"\\x01\\x02\\x12\\x0f\\x01\\x02\\x12\\x8f\\x14A\\x00\\x10\\x00\\x0e\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-04-30T00:00:00", "modifydate": "2002-05-08T14:41:22", "lines": 16, "newlines": 14, "modlines": 0, "user": "BC0THOR"}, "text": "/************/\n/* writec.c */\n/********************************************/\n/* writes one character at a time to a file */\n/********************************************/\n#include <stdio.h>\n\nint main() {\n  FILE *fptr;\n  char ch;\n\n  fptr = fopen(\"textfile.txt\",\"w\");  /* open file for write, text */\n  while((ch=getchar()) != '\\r')       /* get char from kybd */\n    putc(ch,fptr);                   /* write it to file */\n  fclose(fptr);                       /* close output file */\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "WRTBLOCK": {"ttr": 15634, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00B\\x00B\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 66, "newlines": 66, "modlines": 0, "user": "BC0THOR"}, "text": "/********************************************************************/\n/* The edit function provides numeric report editing, including     */\n/* leading zero suppression, check protection, floating $, leading  */\n/* or trailing minus sign, insertion of commas, decimal points and  */\n/* other non-numeric fields. The first parameter is the address of  */\n/* the edited output, whose size will be the same as the pattern.   */\n/* The second parameter is the editing pattern, which must be a true*/\n/* null-terminated string containing the edit pattern. The third    */\n/* is the number to be edited, a null-terminated string containing  */\n/* only digits 0-9 except the first position, which is a -, if the  */\n/* number is negative. The pattern may be up to 64 characters, and  */\n/* the number to be edited may contain up to 32 characters. The     */\n/* number may not contain more significant digits than there are    */\n/* digit select characters in the pattern. If there are more digits */\n/* selected by the pattern than there are in the number, leading    */\n/* zeros will be assumed. In the pattern, the first character may   */\n/* be:      $ (floating dollar sign)                                */\n/*          * (check protection)                                    */\n/*          - (floating minus sign)                                 */\n/* The body of the edit pattern will be composed of digit select    */\n/* characters (z and 9) and other characters, handled as follows:   */\n/*          z (zero suppression output is a blank in this position  */\n/*             until significance is set by receipt of a significant*/\n/*             digit or a 9 in the pattern. After significance is   */\n/*             set, output is a digit from the number.)             */\n/*          9 (output is a digit from the number and significance   */\n/*             is set, even if the digit is a leading zero.)        */\n/*        other characters in the pattern will be output as-is after*/\n/*             significance is set, but will be output as blanks    */\n/*             before significance is set.                          */\n/* Characters in the pattern following the last digit select will   */\n/* be output as-is if the number is negative, otherwise output will */\n/* be blanks for these pattern positions.                           */\n/*                                                                  */\n/* When * check protection is selected, output will be *, rather    */\n/* than blanks as mentioned above.                                  */\n/*                                                                  */\n/* An integer is returned to indicate success or errors:            */\n/*                 0 = successful edit                              */\n/*                 1 = pattern too long (over 64 characters)        */\n/*                 2 = too many digits selected (over 32)           */\n/*                 3 = no output digits selected in pattern         */\n/*                 4 = number contains non-numeric data             */\n/*                 5 = number has more digits than the pattern      */\n/*                                                                  */\n/* Examples:                            nbr=             outf=      */\n/*    err=edit(outf,\"zz,zz9.99-\",nbr);  0                     0.00  */\n/*                                      123                   1.23  */\n/*                                      562983            5,629.83  */\n/*                                      -4675                46.75- */\n/*    err=edit(outf,\"$,$$$.$$\",nbr);    0                           */\n/*                                      123                  $1.23  */\n/*                                      562983           $5,629.83  */\n/*                                      -4675               $46.75  */\n/*    err=edit(outf,\"***.**\",nbr);      0                           */\n/*                                      123                 **1.23  */\n/*                                      562983   err = 5            */\n/*                                      -4675               *46.75  */\n/*    err=edit(outf,\"--,--9.99\",nbr);   0                     0.00  */\n/*                                      123                   1.23  */\n/*                                      562983            5,629.83  */\n/*                                      -46.75              -46.75  */\n/*                                                                  */\n/* Author R Thornton April 1989                                     */\n/********************************************************************/\n/**/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WSEARCH": {"ttr": 15636, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00\\x11\\x00\\x11\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "BC0THOR"}, "text": "/* return a pointer to a window number or nil */\n#include <jzscreen.h>\nextern THEADER g_header;\nTWINDOW *wsearch(fnum)\nint fnum;\n{\n  THEADER wptr;\n\n  wptr = g_header;\n\n  while (wptr.first)\n    if (wptr.first->number == (char) fnum) return(wptr.first);\n    else wptr.first = wptr.first->next;\n\n  return(0);\n}\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZERO3": {"ttr": 15638, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x12\\x00\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T12:00:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "BC0THOR"}, "text": "/* move zeros to each of three variables passed to a function */\nmain()\n{\nstatic int *a[]={6,7,8};\nvoid movzro(int *);\nprintf(\"a=%d, b=%d, c=%d\",*a,*(a+1),*(a+2));\nmovzro(a);\nprintf(\"\\na=%d, b=%d, c=%d\",*a,*(a+1),*(a+2));\n}\nvoid movzro(int *a)\n{\n*(*a)=0;\n*(*(a+1))=0;\n*(*(a+2))=0;\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT559/FILE559.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT559", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}