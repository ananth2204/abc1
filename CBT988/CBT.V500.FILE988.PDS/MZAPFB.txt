./ ADD NAME=ATTN     0100-19106-19106-2244-00047-00047-00000-MZAPFB  16
III. Attention/MODIFY messages
.in 5
.sp 1
The following attention messages are allowed;
they may be in lower case since MZAP translates to upper case:
.sp 2
.in 10
.hi 12
$HELP ¬¬¬¬¬¬
display list of valid nonpriveleged attention messages.
This function is forced if an invalid attention message is entered.
.sp 1
CON ¬¬¬¬¬¬¬¬
set console input mode
.sp 1
STOP ¬¬¬¬¬¬¬
terminate dump or HELP
.sp 1
$HOLD ¬¬¬¬¬¬
enter attention state after every write
.sp 1
.br
$AUTO ¬¬¬¬¬¬
restore normal mode after $HOLD
.sp 1
$SLOW ¬¬¬¬¬¬
do 12 writes/2260 screen, 24/3270.
A write will occur for each output line.
.sp 1
$HALFAST ¬¬¬
do 6 writes/screen.
a write will occur for every 2 output lines(2260)
or every 4 lines(3270)
.sp 1
$FAST ¬¬¬¬¬¬
do 3 writes/screen.
A write will occur for every 4 output lines(2260)
or every 8 output lines(3270).
.sp 1
$PAGE ¬¬¬¬¬¬
do 1 write/screen.
If a dump is in progress,
one line is reserved for the dump header.
One line is reserved as the entry line.
A write will occur for every 10 or 11 output lines
(3270: 22 or 23 output lines).
.in 0
./ ADD NAME=COMPARE  0100-19106-19106-2244-00074-00074-00000-MZAPFB  16
VII. ¬MZAP/CZAP Comparision
.sp 1
.in 4
.nj
MZAP____                          CZAP____
CONSOLE                       No equivalent
.sp 1
*                             *
.sp 1
NAME .                        NAME NUCLEUS
.sp 1
NAME .csect                   NAME NUCLEUS
                              INDEX csectdisp
.sp 1
NAME name                     NAME name
.sp 1
NAME name csect               NAME name
                              INDEX csectdisp
.sp 1
CVT                           NAME NUCLEUS
                              INDEX cvtloc
.sp 1
UCB=cuu                       NAME NUCLEUS
                              INDEX ucbloc
UCB cuu                       NAME NUCLEUS
                              INDEX ucbloc
.sp 1
BASE hexbase                  BASE hexbase
.sp 1
INDEX=hexix                   INDEX hexix
.sp 1
INDEX esdname                 INDEX csectdisp
                              BASE  esdindex
.sp 1
VERIFY  xx                    VERIFY  xx
VER     00 'a'                VER     00 c1
V       00 'a'C2              VER     00 c1C2
V       00 C3'D'              VER     00 c3C4
V       00 C6'GH'C9           VER     00 c6C7C8C9
.sp 1
REPLACE xx                    REPLACE xx
REP     00 'a'                REP     00 c1
R       00 'a'C2              REP     00 c1C2
R       00 C3'D'              REP     00 c3C4
R       00 C6'GH'C9           REP     00 c6C7C8C9
.sp 1
RESET                         RESET
.sp 1
RESET   EOD                   No equivalent
.sp 1
DUMP    name                  NAME    name
                              DUMP    0  modulelen
.sp 1
DUMP    name  csect           NAME    name
                              DUMP    csectdisp  csectlen
.sp 1
DUMP    .                     NAME    NUCLEUS
                              DUMP    0          nuclen
.sp 1
DUMP    .     csect           NAME    NUCLEUS
                              DUMP    csectdisp  csectlen
.sp 1
DUMPA   (see DUMP)            DUMPA   (see DUMP)
.sp 1
DUMPT   (see DUMP)            No equivalent
.sp 1
$ABEND  (attn)                ABEND
.sp 1
DEBUG   (Not truly equiv)     TRACE   (not truly equiv)
DEBUG   (Not truly equiv)     LOGOUT  (not truly equiv)
.sp 1
RESET   (Not truly equiv)     TRACEOFF(not truly equiv)
.fi
.in 0
./ ADD NAME=INDEX    0100-19106-19106-2244-00024-00024-00000-MZAPFB  16
VIII. ¬Index to Input Statements
.sp 2
.nf
Statement_________      Page____     Statement____
AVT               9     MSER                  10
BASE             12     NAME                   8
BLDL              9     POINT                 17
CONSOLE          14     QMRES                 10
CVT               9     R                     13
DEBUG             8     REP                   13
DUMP             14     REPLACE               13
DUMPA            15     RESET                  8
DUMPB            14     SCVT                  10
DUMPT            15     SETPTR                16
END               8     SMCA                  10
GO                8     TACT                  10
GOVRFLB           9     TCB                   10
HCT               9     TSCVT                 11
HELP             16     UCB                   11
IBMORG            9     UCM                   11
INDEX            12     USERORG               11
JOB               8     V                     13
KEY               7     VER                   13
LIB              13     VERIFY                13
./ ADD NAME=INITDOC  0100-19106-19106-2244-00103-00103-00000-MZAPFB  16
.ti
.if '&1' ne '';.se escape '&1.'
.ur .if '&escape' eq '';.sr escape '¬'
.ur .if '&adjust' eq '';.sr adjust 15
.ur .if '&trace' eq 'yes'
.su traceon
.ur .if '&trace' eq 'YES'
.su traceon
.sr lcfn='no'
.ur .if '&train.' = 'SN'
.sr lcfn='1'
.ur .if '&train.' = 'TN'
.sr lcfn='1'
.ur .if '&train.' = 'UN'
.sr lcfn='1'
.rm *
.tt 1 //Metz's Own Reliable Extended Zap/%/
.rm
.rm $resetdoc SAVE NOSAVE
.tt 2 ////
.tt 3 ////
.tt 4 //COPYRIGHT 1975 SHMUEL METZ//
.ti ( ( ) ) . * 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9
.ti t 05 b * s ff
.ur .if '&lcfn' = '1'
.ti ( 8d ) 9d . af 0 b0 1 b1 2 b2 3 b3 4 b4 5 b5 6 b6 7 b7 8 b8 9 b9
.ti l ( L ( r ) R ) < < > >
.ur .if '&lcfn' = '1'
.ti l ad L 8b r bd R 9b < 8c > ae # 9c
.ur .if '&lcfn' = '1'
.ti b af
.tr ff 40
.ur .ti set &escape
.cm Note that .tt 1 to 6 shares buffers with .bt 6 to 1.
.bt 1 ////
.ur .if &syspage > 1;.bt 1 //- % -//
.bt 2 ////
.tm 5+4
.hm 1
.hs 4
.bm 3+2
.ur .ad &adjust
.ll 65
.in 0
.pi 0
.fo
.tb
.sr item=0
.$resetfn
.rm
.rm $resetfn SAVE NOSAVE
.sr n0=0
.sr n1=0
.sr n2=0
.sr sig0=0
.sr sig1=0
.rm
.$resetdoc
.rm $fn save nosave
.cm Increment footnote digits and propagate the carry.
.se n2=&n2+1
.se carry=&n2/10
.se sig1=&sig1+&carry
.se n1=&n1+&carry
.se carry=&n1/10
.se sig2=&sig2+&carry
.se n0=&n0+&carry
.ur .if &n2 > 9;.sr n2=0
.ur .if &n1 > 9;.sr n1=0
.cm rfn is Reference to Foot Note: (n)
.cm lfn is Label of Foot Note: (N)
.se rfn='&escape.('
.sr lfn='('
.ur .if &sig0 > 0;.se rfn='&rfn.&escape.&n0'
.ur .if &sig0 > 0;.se lfn='&lfn.&n0'
.ur .if &sig1 > 0;.se rfn='&rfn.&escape.&n1'
.ur .if &sig1 > 0;.se lfn='&lfn.&n1'
.se rfn='&rfn.&escape.&n2.&escape.)'
.se lfn='&lfn.&n2)'
.se nfn=0+&n0.&n1.&n2
.rm
.rm $fnbeg save nosave
.fn begin
.in 5
.un 5
.rm
.rm $item SAVE NOSAVE
.se item=&item+1
.se itemrf='&item.¬t'
.rm
.rm $itemrf save nosave
.$item
.ur &item.¬t&1 &2 &3 &4 &5 &6 &7 &8 &9
.sr 1 ''
.sr 2 ''
.sr 3 ''
.sr 4 ''
.sr 5 ''
.sr 6 ''
.sr 7 ''
.sr 8 ''
.sr 9 ''
.rm
./ ADD NAME=INPUT    0100-19106-19106-2244-00729-00729-00000-MZAPFB  16
IV. INPUT STATEMENTS
.sp 1
.in 5
Input statements are of three types:
.in 8
.sp 1
.un 4
1.)
A statement with an asterisk (*) in column 1 is a column 1 is a comment.
.sp 1
.un 4
2.)
A blank card is a comment.
.sp 1
.un 4
3.)
Any other statement contains an opcode in the first non-blank column
(normally column 1).
.in 5
.sp 1
For the remainder of this section,
the term "statement" will be understood to apply only to non-comments.
.sp 2
Each opcode may require or permit operands;
the opcode must be followed by a blank unless the operand
begins with a period (.), hyphen (-), or equal sign (=).
.sp 2
A hex (hexadecimal) number is expressed as an even number
of hexadecimal digits(0-9, A-F),
optionally preceeded by an equal sign or hyphen.
An equal sign indicates that the value which follows
is a number rather than a name;
a hyphen indicates a negative number and is only valid when
specifying a relative address;
an equal sign may preceed any hex data.
.sp 2
A character string is expressed by enclosing the desired characters
in apostrophes (');
an apostrophe is represented by two consequtive apostrophes('').
Apostrophe is the only character which is doubled;
in particular, an ampersand (&) is represented by a single______ a
Character strings may be used wherever hex numbers are valid,
and may be concatenated with hex data:
=C1C2C3, C1C2'C', C1'B'C3 and ='ABC' all represent the same value.
.sp 2
The following statements are accepted:
.in 22
.sp 1
.un 13
.se key='&sysppage'
KEY ¬t
This statement is required if any REP statements are used.
The operand requirements may change for every release;
this is intended to prevent unauthorized use of MZAP.
It is recommended that each installation modify the
requirements for this opcode,
to prevent unauthorized alteration of their system.
The operand requirements have been deliberately omitted
from the writeup;
they will be made available only to a single
individual at each installation and he may select,
at his own discretion,
who is authorized to modify resident code.
.sp 2
.un 13
.se debug='&sysppage'
DEBUG ¬t
The switches and table entries used for communicating between
phases of MZAP will be displayed after each phase completes processing.
.in 22
.sp 2
.se end='&sysppage'
END ¬t
Console input mode will be terminated if a valid SYSIN data set
.un 13
was specified;
otherwise END is an invalid opcode.
.sp 2
GO ¬¬¬¬¬¬¬¬¬¬
Turns off the NOGO switch if from CRT/terminal/console;
GO is invalid from SYSIN.
.sp 2
RESET ¬¬¬¬¬¬¬
Causes all control cards previously read to be processed.
If an operand of EOD is specified,
no further input will be read;
otherwise NOGO and DEBUG will be reset and MZAP will
continue reading input.
.sp 2
JOB ¬¬¬¬¬¬¬¬¬jobname
.br
JOB ¬¬¬¬¬¬¬¬¬jobname.jobstepname
.br
JOB ¬¬¬¬¬¬¬¬¬taskid
.br
JOB ¬¬¬¬¬¬¬¬¬procname.taskid
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement defines the job whose JPAQ is
to be searched, prior to the TSLPA, RERP, RSVC, or RAM list queues.
A related set of ZAPs must lie within a single job;
once a JOB card is accepted, it is invalid to supply
a new one without first supplying a RESET card.
This restriction was imposed to maintain compatability with
the planned OS/VS2 release 2 (MVS) support.
.sp 2
.ce data
THIS DESCRIPTION IS FOR PLANNING PURPOSES ONLY.
THE WRITEUP WILL BE AMENDED WHEN JOB IS AVAILABLE.
.sp 2
NAME ¬¬¬¬¬¬¬¬.
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬.csectname
 ¬¬¬¬¬¬¬¬¬¬¬¬¬name csectname
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement defines the module or CSECT for
the VERIFYs, REPLACEs, and DUMPs which follow.
The name may be a load module name, a period (.),
or either one followed by a CSECT name.
If the load module was scatter loaded,
a CSECT name is required.
A period represents the nucleus specified as a member of
the dsname on SYSNUC,
and is considered to be block loaded.
The load address will be added to the relative address
on each applicable statement (VER, DUMP, etc.)
in the SCOPE of the NAME statement;
the length will be used to check that each relative address
is within bounds.
.sp 2
AVT ¬¬¬¬¬¬¬¬¬
This statement defines the module and CSECT for the
statements which follow.
The AVT address is obtained from the CVT;
the opcode is invalid if TCAM is not active.
.sp 2
BLDL ¬¬¬¬¬¬¬¬ name
This statement defines the module and CSECT for
the statements which follow.
It is invalid if the designated name does not
occur in the resident BLDL list.
The length is set to include only the specified
BLDL entry.
.sp 2
CVT ¬¬¬¬¬¬¬¬¬
This statement defines the module,CSECT, and INDEX
for the statements which follow.
Any location in the CSECT containing the CVT may be patched:
the locations should be given relative to the CVT.
It is equivalent, in MVT, to:
.hi 0
.in 25
.nj
NAME      .IEAQBK00
INDEX     IEACVT
.fi l
.in 9
.hi 13
.sp 2
GOVRFLB ¬¬¬¬¬
This statement, valid only for OS/MVT and OS/VS2,
defines the module, CSECT, and INDEX for the statements which follow.
Any location in the CSECT containing the main storage supervisor
may be patched;
the locations given should be relative to GOVRFLB.
It is equivalent to:
.hi 0
.in 25
.br
NAME ¬¬¬¬¬.IEAQBK00
.br
INDEX ¬¬¬¬GOVRFLB
.in 9
.hi 13
.sp 2
HCT ¬¬¬¬¬¬¬¬¬
This statement defines the module and CSECT for the HASP Control Table.
It is invalid if HASP is not active,
or if there is no local modification to the HASP SVC to return
the HCT address in register 15.
.sp 2
IBMORG ¬¬¬¬¬¬
This statement, valid only for OS/MVT and OS/VS2,
defines the module and CSECT for the statements which follow.
Any location in the SVC table may be patched;
the location given should be relative to the IBM portion of the table.
It is equivalent to:
.hi 0
.in 25
Name ¬¬¬¬.IBMORG
.in 9
.hi 13
.sp 2
MSER ¬¬¬¬¬¬¬¬
This statement defines the module and CSECT for
the statements which follow.
Any location in the Master Scheduler Resident Data Area
and in the Master Common Area may be patched.
It is equivalent to:
.hi 0
.in 25
NAME ¬¬¬¬¬.IEEMSER
.in 9
.hi 13
.sp 2
QMRES ¬¬¬¬¬¬¬
This statement defines the module and CSECT for
the statements which follow.
Any location in the Queue Manager Resident Data Area may be patched.
It is equivalent to:
.hi 0
.in 25
NAME ¬¬¬¬IEFJOB
.in 9
.hi 13
.sp 2
SCVT ¬¬¬¬¬¬¬¬
This statement, valid only in OS/MVT and OS/VS2, defines the module, CSE
for the statements which follow.
It is equivalent to:
.hi 0
.in 25
NAME ¬¬¬¬¬.IGC003
.br
INDEX ¬¬¬¬IEABEND
.in 9
.hi 13
.sp 2
SMCA ¬¬¬¬¬¬¬¬
This statement, valid only if the system was generated with the SMF opti
is used to define the module and CSECT for the statements which follow.
While it is not actually a CSECT, nor is it in the nucleus,
it may be patched as if it were.
.in 9
.hi 13
.sp 2
 TACT ¬¬¬¬¬¬¬¬
This statement, valid only in OS/MVT, defines the module, CSECT, and IND
for the statements which follow.
Any location in the CSECT containing the permanent TCBs,
transient areas, and CVT amy be patched;
the location given should be relative to the
Transient Area Control Table.
It is equivalent to:
.hi 0
.in 25
NAME ¬¬¬¬¬.IEAQBK00
.br
INDEX ¬¬¬¬IEAQTAQ
.in 9
.hi 13
.sp 2
TCB ¬¬¬¬¬¬¬¬¬job
.br
TCB ¬¬¬¬¬¬¬¬¬job.step
.br
TCB ¬¬¬¬¬¬¬¬¬id
.br
TCB ¬¬¬¬¬¬¬¬¬proc.id
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement defines the module, CSECT,
and INDEX for the statements which follow.
Any location in the jobstep tcb of the specified job or
started task may be patched:
addresses shhould be given relative to the TCB.
Note that floating-point registers are stored at a negative
displacement.
.sp 1
¬¬¬¬¬¬¬¬¬¬¬¬¬THE TCB OPCODE IS DESCRIBED FOR PLANNING PURPOSES ONLY.
THE WRITEUP WILL BE AMENDED WHEN IT IS AVAILABLE.
.sp 2
TSCVT ¬¬¬¬¬¬¬
This statement, valid onlin with OS/MVT and OS/VS2,
is used to define the module and CSECT for the statements which follow.
It is an invalid statement if TSO is not active.
Any location in the Time Shareing Communications Vector Table
may be patched;
locations should be given relative to the TSCVT.
.sp 2
UCB=cuu
.br
UCB cuu ¬¬¬¬¬
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement defines the module, CSECT, and INDEX for th
statements which follow.
Any location in the I/O Supervisor may be patched;
the location given should be relative to the specified UCB.
It is equivalent, in MVT, to:
.hi 0
.in 25
NAME ¬¬¬¬.IEAQFX00
.br
INDEX ¬¬¬ucbloc
.in 9
.hi 13
.sp 2
UCM ¬¬¬¬¬¬¬¬¬BASE
.br
UCM ¬¬¬¬¬¬¬¬¬HARDCOPY
.br
UCM ¬¬¬¬¬¬¬¬¬MASTER
.br
UCM ¬¬¬¬¬¬¬¬¬MCS
.br
UCM ¬¬¬¬¬¬¬¬¬PREFIX
.br
UCM ¬¬¬¬¬¬¬¬¬ID=xx
.br
UCM ¬¬¬¬¬¬¬¬¬UNIT=cuu
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement defines the module, CSECT, and INDEX
for the statements which follow.
Except for UCM BASE, the INDEX is set as an absolute address
rather than an entrypoint name or relative address.
HARDCOPY, MASTER, and MCS are only valid if the system was
generated with the Multiple Console Support option.
BASE, MCS, and PREFIX refer to UCM areas not related to
a specific console;
UCM MASTER and HARDCOPY refer to the UCME for the console assigned to
the designated function;
UCM ID=xx refers to the UCME whose ID (in decimal) is xx;
and UCM UNIT=cuu refers to the UCME for the designated device.
They are equivalent to:
.hi 0
.in 25
NAME ¬¬¬¬¬.IEEUCMC
.br
INDEX ¬¬¬¬IEECUCB (for BASE)
.br
 ¬¬¬¬¬¬¬¬¬¬forced absolute address
.br
 ¬¬¬¬¬¬¬¬¬¬(for other than BASE)
.in 9
.hi 13
.sp 2
USERORG ¬¬¬¬¬
This statement, valid only for OS/MVT and OS/VS2,
defines the module, CSECT, and INDEX
for the statements which follow.
Any location in the SVC table may be patched;
the location given should be relative to the user portion
of the table.
It is equivalent to:
.hi 0
.in 25
NAME ¬¬¬¬¬.IBMORG
.br
INDEX ¬¬¬¬USERORG
.in 9
.hi 13
.sp 2
BASE=xx ¬¬¬¬¬
.br
BASE xx ¬¬¬¬¬
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement is used to give a value to be subtracted
from the address given in a VER or REP.
It is normally the relative address of the CSECT,
as printed in the assembly listing.
The effect of this statement is retained until
the next statement containing or implying a name
(DUMP, NAME, INDEX, CVT, UCB, ...).
If a previous BASE is in effect,
the statement has a cummulative effect:
the amount subtracted is the sum of the BASEs.
.sp 2
INDEX=xx ¬¬¬¬
.br
INDEX xx ¬¬¬¬
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement is used to give a value to be added to
the address given in a VER, REP, DUMP, etc.
It is normally the relative address of a CSECT from a
link-edit listing.
The effect of this statement is retained until the next statement
containing or implying a name
(CVT, DUMP, INDEX, NAME, etc.);
all previous BASE or INDEX specifications remain in effect.
.sp 2
INDEX ¬¬¬¬¬¬¬name
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement is used to give a value to be added to the
address given in a VER, REP, DUMP, etc.
It resets all previous BASE and INDEX specifications.
The value used is the address of the CSECT or entry point specified,
adjusted by the CSECT or module address of the preceeding name statement
.sp 2
LIB ¬¬¬¬¬¬¬¬¬AUTO
.br
LIB ¬¬¬¬¬¬¬¬¬ddname
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement is used to specify the ddname of the
data set to be used to resolve CSECT names (other than nucleus CSECTs)
in statements which follow.
If AUTO is specified, modules found in TSLPA are assumed to be on CMDLIB
modules whose names begin with IFG or IG are assumed to be on SVCLIB;
all other modules are assumed to be on LINKLIB.
AUTO is initially in effect,
and remains in effect untill overrriden by an LIB statement.
.sp 2
VERIFY ¬¬¬¬¬¬rr dd
.br
VER ¬¬¬¬¬¬¬¬¬rr dd
.br
V ¬¬¬¬¬¬¬¬¬¬¬rr dr
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement is used to prevent inadvertently
altering the wrong location.
The data at the specified relative address, r, adjusted by
the address from the NAME statement and any BASE or INDEX in effect,
is compared to the specified data,
and, if a match does not occur,
a switch (called the NOGO switch) is set,
causing all REPs between the preceeding RESET (or beginning of input)
and the following RESET (or end of data) to be suppressed.
.sp 1
 ¬¬¬¬¬¬¬¬¬¬¬¬¬The location must be specified as 2, 4, or 6 hex digits,
preceeded (if negative) by a hyphen (-).
The data may be specified as:
.in 25
.hi 5
.sp 1
1). an even number of hex digits
.sp 1
2). a character string enclosed in apostrophes (');
an apostrophe is represented by 2 apostrophes
(i.e., "CAN'T" is entered as "CAN''T").
.sp 1
3). any combination of 1). and 2).
.sp 1
4). any of the above,
separated by commas (,).
.in 9
.hi 13
.sp 2
REPLACE ¬¬¬¬¬rr dd
.br
REP ¬¬¬¬¬¬¬¬¬rr dd
.br
R ¬¬¬¬¬¬¬¬¬¬¬rr dd
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement is used to replace data
at the specified relative location, r, as adjusted by the NAME,
BASE, and INDEX statements in effect.
See VER for a description of formats.
The effect of a REP is suppressed if the NOGO switch is set,
either because of a REP failure (see REP) or by an invalid
control statement (however, see GO and RESET).
.sp 2
CONSOLE
.br
CONSOLE ¬¬¬¬¬ID=cc
.br
CONSOLE ¬¬¬¬¬ID=cca
.br
CONSOLE ¬¬¬¬¬UNIT=ccu
.br
CONSOLE ¬¬¬¬¬DSRT=ddddrrrr
.br
CON
.br
CON ¬¬¬¬¬¬¬¬¬ID=cc
.br
CON ¬¬¬¬¬¬¬¬¬ID=cca
.br
CON ¬¬¬¬¬¬¬¬¬UNIT=ccu
.br
CON ¬¬¬¬¬¬¬¬¬DSRT=ddddrrrr
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement is used to cause subsequent input
to be from the CRT (if a local 2260 or 3270 is assigned),
the terminal (if TSO),
or the operators console (via WTO/WTOR and REPLY/MODIFY).
A specific console may be assigned by a two hex digit UCMID
(with an optional area identifier from A-Z) or
by a unit address.
Routing codes and descriptors may be specified in the form
ddddrrrr, where d is a 16 bit descriptor mask and
r is a 16 bit routing code mask.
.sp 2
DUMP ¬¬¬¬¬¬¬¬.
.br
DUMP ¬¬¬¬¬¬¬¬.csectname
.br
DUMP ¬¬¬¬¬¬¬¬name
.br
DUMP ¬¬¬¬¬¬¬¬name csectname
.br
DUMPB ¬¬¬¬¬¬¬.
.br
DUMPB ¬¬¬¬¬¬¬.csectname
.br
DUMPB ¬¬¬¬¬¬¬name
.br
DUMPB ¬¬¬¬¬¬¬name csectname
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement is used to print a dump of the specified
module or CSECT,
prior to applying any REPs.
The dump will contain a display of 16 bytes/line, in the format:
.ll 120
.nj
.hi 0
.in 0
.sp 2
R:b/rrrrrrb/A:b/aaaaaab/b/xxxxxxxxb/xxxxxxxxb/b/b/xxxxxxxxb/xx
.ll 70
.fi l
.hi 5
.in 22
.sp 2
  Where r is the relative address in hex
.in 28
.br
  a is the absolute address in hex
.br
  x is the data in hex
.br
  e is the data the data in EBCDIC, with unprintable characters
displayed as periods (.) or quotes (").
.br
 b/ is a blank
.in 9
.hi 13
.sp 1
 ¬¬¬¬¬¬¬¬¬¬¬¬¬A character is considered unprintable if it
does not appear on the CRT;
if called from a non-CRT TSO terminal or run in batch
without a CRT,
a character is unprintable if it does not appear un the PN train.
A cent sign (¢) is considered unprintable on the 2260
since it is used as an SMI (>|).
A quote rather than a period will be substituted for each
unprintable character only for the 2260;
quotes appear on the 2260 as an error symbol (_<>¬).
.sp 2
DUMP ¬¬¬¬¬¬¬¬=rr ss
.br
DUMPB ¬¬¬¬¬¬¬=rr ss
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement is used to print a partial dump of the
CSECT or module identified in the preceeding NAME statement.
r is 2, 4, or 6 hex digits,
preceeded by a hyphen if negative;
s is 2, 4, or 6 hex digits.
.sp 1
 ¬¬¬¬¬¬¬¬¬¬¬¬¬The data beginning at r,
adjusted by the preceeding NAME, INDEX, and BASE statements,
is displayed in the format shown above.
The number of bytes dumped will be given by s,
however the dump will always begin and end on a quadword
(16 byte) boundary.
.sp 2
DUMPA ¬¬¬¬¬¬¬.
.br
DUMPA ¬¬¬¬¬¬¬.csectname
.br
DUMPA ¬¬¬¬¬¬¬name
.br
DUMPA ¬¬¬¬¬¬¬name csectname
.br
DUMPA ¬¬¬¬¬¬¬=rr ss
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement has the same effect as DUMP,
except that VERs and REPs will be processed prior
to printing the dump.
.sp 2
DUMPT ¬¬¬¬¬¬¬.
.br
DUMPT ¬¬¬¬¬¬¬.csectname
.br
DUMPT ¬¬¬¬¬¬¬name
.br
DUMPT ¬¬¬¬¬¬¬name csectname
.br
DUMPT ¬¬¬¬¬¬¬=rr ss
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement has the same effect as DUMP,
except that VERs and REPs will be processed will be processed
prior to printing the dump and that the format of the dump is different.
Each halfword will be treated as the beginning of an instruction
for the purpose of printing an opcode under the hex value.
The dump will contain a display of 16 bytes/line, in the format:
.ll 120
.hi 0
.in 0
.nj
rrrrrrb/aaaaaab/b/xxxxb/xxxxb/b/xxxxb/xxxxb/b/b/xxxxb/xxxxb/
b/b/b/b/b/b/b/b/b/b/b/b/b/b/b/oooob/oooob/b/oooob/ooo
.fi l
.ll 70
.in 22
.hi 5
.sp 1
 Where r is the hex relative address
.in 28
a is the hex absolute address
.br
x is the hex data
.br
e is the EBCDIC data
.br
o is the opcode for the above data,
truncated to 5 characters
.br
b/ is a blank.
.in 9
.hi 13
.sp 2
HELP ¬¬¬¬¬¬¬¬This statement is used to obtain a list
of valid command names.
If a CRT is assigned,
or if MZAP is being run from a TSO terminal,
attention mode is forced and a $HELP is simulated
to enable the user to set the speed or hold options;
the list of commands will begin when a null line is entered.
The list can be terminated by entering an attention message
of "STOP" from the terminal/CRT or by the operator command:
"P id", where id is the jobname or START id.
.sp 2
HELP cmd ¬¬¬¬
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement is used to obtain a list of valid operands
for the designated input statement.
If a CRT is assigned or MZAP was invoked via TSO,
attention mode is forced and a $HELP is simulated
to enable the user to set the speed or hold options;
the list of operands will begin when a null line is entered.
The list can be terminated by entering an attention message
of "STOP" form the terminal/CRT or by the operator command:
"P id,STOP", where id is the jobname or START id.
.sp 2
SETPTR ¬¬¬¬¬¬refdigit *
.br
<- ¬¬¬¬¬¬¬¬¬¬refdigit *
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement, during dump processing or VERIFY/REP
processing;
causes the limits (address,length) and index currently in effect
to be saved in one of 16 MZAP "reference pointers";
refdigit, which may be any hex digit from 0 to F,
is used to identify this information for subsequent use
(see POINT).
.sp 2
SETPTR ¬¬¬¬¬¬refdigit ptr len
.br
<- ¬¬¬¬¬¬¬¬¬¬refdigit ptr len
.br
SETPTR ¬¬¬¬¬¬refdigit ptr len-pfx
.br
<- ¬¬¬¬¬¬¬¬¬¬refdigit ptr len-pfx
.br
SETPTR,plen ¬refdigit ptr len
.br
<-,plen ¬¬¬¬¬refdigit ptr len
.br
SETPTR,plen ¬refdigit ptr len-pfx
.br
<-,plen ¬¬¬¬¬refdigit ptr len-pfx
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement,
during dump or VERIFY/REPLACE processing,
saves the limits (address, length) and index of a control block
as described below;
refdigit, which may be any hex digit from 0 to F,
is used to identify this information for subsequent use
(see POINT).
.sp 1
 ¬¬¬¬¬¬¬¬¬¬¬¬¬plen, if present, defines the type of pointer;
it may have the values 15, 16, 24, or 32 (the default);
in addition, Y, H, AL3, and A are synonymous to 15, 16, 24, and 32.
(Only the last 24 bits of a 32 bit pointer are used.)
.sp 1
 ¬¬¬¬¬¬¬¬¬¬¬¬¬ptr must be an even number of hex digits,
giving the relative address of a pointer.
In what follows, "(ptr)" denotes the contents of the designated location
.sp 1
 ¬¬¬¬¬¬¬¬¬¬¬¬¬len must be an even number of hex digits,
giving the size of the control block pointed to
(excluding prefix, if any).
.sp 1
 ¬¬¬¬¬¬¬¬¬¬¬¬¬pfx, if specified, must be an even number of hex digits,
giving the length in bytes of the control block prefix.
The hyphen separating len and pfx may be preceeded by blanks,
but may not be succeeded by blanks.
pfx is assumed to be 0 if not specified.
.sp 1
 ¬¬¬¬¬¬¬¬¬¬¬¬¬When the specified pointer, (ptr),
is accessed, the following are computed:
.nj
.in 25
.hi 0
address    is    (ptr)-pfx
length     is    len + pfx
index      is    (ptr)
relative
 index     is    index - address = pfx
.fi l
.in 10
.hi 12
 ¬¬¬¬¬¬¬¬¬¬¬¬The address, length, and relative index are then
saved in the requested reference pointer.
.sp 2
POINT ¬¬¬¬¬¬REF refdigit
.br
-> ¬¬¬¬¬¬¬¬¬REF refdigit
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬The address, length, and relative index last set into
the designated reference pointer are made current;
the index may be modified by a subsequent BASE or INDEX (hex only)
statement.
.sp 2
POINT ¬¬¬¬¬¬ptr len
.br
-> ¬¬¬¬¬¬¬¬¬ptr len
.br
POINT ¬¬¬¬¬¬ptr len-pfx
.br
-> ¬¬¬¬¬¬¬¬¬ptr len-pfx
.br
POINT,plen ¬ptr len
.br
->,plen ¬¬¬¬ptr len
.br
POINT,plen ¬ptr len-pfx
.br
->,plen ¬¬¬¬ptr len-pfx
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬The address, length, and relative index for a control block
are made current.
See SETPTR for an explanation of the operands.
.in 0
.hi 0
./ ADD NAME=INTRO    0100-19106-19106-2244-00019-00019-00000-MZAPFB  16
I.¬tINTRODUCTION
.sp 1
.ur .sr intro &sysppage
.in 5
.fi l
This program is intendended to provide, for OS/360 (MVT) and OS/VS2,
the same function as the IBM service aid COREZAP0 (360S-01114-00),
referred to here as CZAP;
that is, to apply patches to programs in main storage.
Several of the control cards have an altered syntax in order
to permit names to be specified without framing characters.
There is a chart at the end of this writeup which illustrates
the known differences.
.sp 1
MZAP is organized as an overlay structure.
Information is passed between overlays through a set of switches
and through a chain of control of control blocks constructed
as a result of the input statements read.
.in 0
./ ADD NAME=JCL      0100-19106-19106-2244-00109-00109-00000-MZAPFB  17
V. ¬JCL
.in 5
.sp 1
MZAP requires the following JCL statements:
.nj
.sp 1
 1)  //       EXEC  PGM=MOREZAP,REGION=100K
 2)  //STEPLIB  DD  ...
 3)  //SYSNUC   DD  DSN=SYS1.NUCLEUS(IEANUC0x),DISP=SHR
 4)  //SVCLIB   DD  DSN=SYS1.SVCLIB,DISP=SHR
 5)  //CMDLIB   DD  DSN=SYS1.CMDLIB,DISP=SHR
 6)  //LINKLIB  DD  DSN=SYS1.LINKLIB,DISP=SHR
 7)  //         DD  ...
 8)  //ddn      DD  ...
 9)  //IEFRDER  DD  UNIT=cuu
10)  //SYSPRINT DD  SYSOUT=A
11)  //SYSIN    DD  *
.fi
.in 9
.sp 1
1.) The REGION size required will vary depending on the
size of the CESD for the nucleus and on the number of DD
statements.
.sp 1
2) This statement is not required if MOREZAP is located in
a JOBLIB or in the system link libraries.
.sp 1
3) This statement is required;
it must specify the nucleus currently loaded.
.sp 1
4) This statement is required if any module in SVCLIB is referenced
in a NAME or DUMP statement.
.sp
5) This statement is required if any module in the TSLPA is referenced
in a NAME or DUMP statement.
.sp
6) This statement is required if any module in the system
LINK library is referenced in a NAME or DUMP statement.
If SYS1.PARMLIB(LNKLST00) specified data sets concatemated to SYS1.LINKL
then these data sets must be specified on concatenated DD statements,
in the same order as in LNKLST00.
.sp 1
7) See 6.
.sp 1
8) Optional additional libraries may be specified;
the ddname should be the same as the operand of the LIB
statement which specifies the data set.
.sp 1
9) Optional 2260 (960 byte screen, local mode) or
3277 (1920 byte screen, local mode, EBCDIC) for
control statement and attention input.
Any ddname desired may be used,
however IEFRDER is suggested if MZAP is
to be invoked via a START command.
.sp 1
10) Printed output.
If no BLKSIZE is specified, 141 will be used for unit record
and 685 for tape or disk.
The user should specify the largest blocksize acceptable to
the system output writer at his installation.
If the installation is using ASP,
the blocksize should not exceed the ASP buffer size.
.sp 1
11) Control statement input.
Additional input may be requested from the operator with
a CONSOLE statement.
.in 5
.sp 2
The required JCL may be preceeded by a JOB card and submitted
through the input stream, or by SUBMIT.
Alternatively, the user may add the JCL to SYS1.PROCLIB,
and invoke MZAP with a START command.
See the Operators Reference and JCL Reference for more
information on catalogued procedures and START commands.
.in 8
.cp 19
.se ex1='&sysppage'
.nf
.sp 2
//        EXEC   PGM=IEBUPDTE,PARM=NEW
//SYSUT2    DD   DSN=SYS1.PROCLIB,DISP=MOD
//SYSPRINT  DD   SYSOUT=A
//SYSIN     DD   DATA
.li
><         ADD   NAME=MZAP,LIST=ALL
.li
><      NUMBER   NEW1=1000,INCR=1000
//MZAP    PROC   NUC=1
//IEFPROC EXEC   PGM=MZAP
//STEPLIB   DD   DSN=SYS2.ASM.XEQ,DISP=SHR
//SYSNUC    DD   DSN=SYS1.NUCLEUS(IEANUC0&NUC),DISP=SHR
//IEFRDER   DD   UNIT=290
//SVCLIB    DD   DSN=SYS1.SVCLIB,DISP=SHR
//LINKLIB   DD   DSN=SYS1.LINKLIB,DISP=SHR
//          DD   DSN=SYS2.linklib,disp=SHR
//CMDLIB    DD   DSN=SYS1.CMDLIB,DISP=SHR
/*
.sp 1
       Adding PROC to PROCLIB
              (Example 1)
.sp 4
.cp 4
.se ex2 '&sysppage'
           S  MZAP.KENT,046,NUC=2
.sp 1
       Starting MZAP using sample PROC
              (Example 2)
.hi 0
.in 0
./ ADD NAME=MANUAL   0100-19106-19106-2244-00097-00097-00000-MZAPFB  17
.cm COPYRIGHT 1975 Shmuel (Seymour J.)  Metz
.im initdoc
.ro
.ce data
MOREZAP

- TABLE OF CONTENTS -
.sp 1
.ur tm=&systm hm=&syshm hs=&syshs
.end
.nf
.sp 2
.tb 55
.oc _/1
 ¬tPage
.tb ./55
.sp 1
.ur    I.  INTRODUCTION ¬t&intro
.sp 1
.ur   II.  SYSTEM and INPUT/OUTPUT REQUIREMENTS ¬t&system
.sp 1
.ur  III.  Attention/MODIFY Messages ¬t&attn
.sp 1
.ur   IV.  INPUT Statements ¬t&input
.sp 1
.ur    V.  JCL ¬t&jcl
.ur         Example 1 ¬t&ex1
.ur         Example 2 ¬t&ex2
.sp 1
.ur   VI.  MESSAGES
.ur         General ¬t&msgeneral
.ur         Common Messages ¬t&msgcommon
.ur         Initialization Messages ¬t&msginit
.ur         Input Messages          ¬t&msginput
.ur         HELP Messages           ¬t&msghelp
.ur         DEBUG Messages          ¬t&msgdebug
.ur         ESD Messages            ¬t&msgesd
.ur         DUMP Messages           ¬t&msgdump
.ur         VER/REP Messages        ¬t&msgverep
.ur         Final Housekeeping and
.ur          Reinitialization Messages ¬t&msgfinal
.sp 1
.ur  VII.  MZAP/CZAP Comparison    ¬t&compare
.sp 1
.ur VIII.  Index to Input Statements. ¬t&index
.sp 1
       Sample Output                  ¬tA-1
.tb 5 10 15 20 25 30 35 40 45 50 55 60 65
.pa
.rm * NOSAVE NOSAVE
.se intro &sysppage
.rm
.im intro
.$resetdoc
.pa
.rm * NOSAVE NOSAVE
.se system &sysppage
.rm
.im system
.$resetdoc
.pa
.ar
.rm * NOSAVE NOSAVE
.se attn &sysppage
.rm
.im attn
.$resetdoc
.pa
.rm * NOSAVE NOSAVE
.se input &sysppage
.rm
.im input
.$resetdoc
.pa
.rm * NOSAVE NOSAVE
.se jcl &sysppage
.rm
.im jcl
.$resetdoc
.pa
.rm * NOSAVE NOSAVE
.se messages &sysppage
.rm
.im messages
.$resetdoc
.pa
.rm * NOSAVE NOSAVE
.se comparison &sysppage
.rm
.im compare
.$resetdoc
.pa
.rm * NOSAVE NOSAVE
.se index &sysppage
.rm
.im index
.sr sample 'A-1'
./ ADD NAME=MESSAGES 0100-19106-19106-2244-01015-01015-00000-MZAPFB  17
VI. ¬MESSAGES
.in 5
.fo all l
.sp 1
Except for prompting, listing of input,
module/csect/control block dumps, and debug output,
all messages produced by MZAP have a common format:
.in 15
.sp 2
MZPfnnabtext
.in 5
.sp 1
Where f identifies the functional area:
.in 18
.hi 3
.sp 1
0 ¬common
.br
1 ¬initialization
.br
2 ¬control card scan
.br
H ¬HELP
.br
D ¬DEBUG
.br
3 ¬CDE search
.br
4 ¬ESD processing and module/csect/location listing
.br
5 ¬dump processing
.br
6 ¬VER/REP processing
.br
7 ¬final housekeeping, reinitialization, and termination
.hi 0
.sp 1
.in 10
nn is a decimal message number within function
.sp 1
a ¬is an action indicator:
A if action required, I otherwise.
.in 5
.sp 2
When a message relates to a specific input statement and
does not immediately follow the statement,
the message text will normally begin with the
5 digit sequence number assigned when that statement was read.
.in 0
.hi 0
.pa
.ce on
Common Messages_______________
.ce off
.hi 6
.sp 3
>|
.br
sssss>
.br
sssss>|
.br
sssss
 ¬¬¬¬¬¬Input required from the terminal, 2260, or 3270.
.sp 2
EH?>
.br
EH?>|
.br
 ¬¬¬¬¬¬Attention mode is in effect.
Key in attention input or terminated attention mode
with a null line.
.sp 2
MZP001I I/O ERROR ON 2260 - USE CONSOLE
.br
MZP001I I/O ERROR ON 3270 - USE CONSOLE
.in 10
ROUTCDE: 1,10,11
.br
DESC: ¬¬¬1
.in 0
.sp 1
 ¬¬¬¬¬¬Unrecoverable I/O error on the CRT.
Interactive I/O will be done via the WTO/WTOR/MODIFY interface.
.sp 2
MZP0002I $HELP: $HOLD|$AUTO CON STOP $PAGE|$HALFAST|$FAST|$SLOW
.br
.sp 1
 ¬¬¬¬¬¬Either HELP, $HELP or an invalid attention was entered.
The valid attention messages are listed,
with mutually exclusive messages separated by logical OR (|).
.sp 2
MZP0003A
.br
.in 10
ROUTCDE: 9,10
.br
DESC: ¬¬¬2
.br
.in 0
.sp 1
 ¬¬¬¬¬Input required via REPLY.
.sp 2
sssss text
.in 10
ROUTCDE: 9,10
.br
DESC: ¬¬¬7
.sp 1
 ¬¬¬¬¬¬Listing of user's input.
.sp 1
 ¬¬¬¬¬¬The designated text was read and assigned the sequence number
sssss.
The output is to SYSPRINT, terminal (if TSO CRT), or CRT (if assigned).
If the CONSOLE option is in effect, no CRT is assigned,
and MZAP is in batch, a WTO is used.
.pa
.ce on
Initialization Messages_______________________
.ce off
.sp 2
.in 0
.hi 6
.sp 2
MZP100I MOREZAP VERSION mm/dd/yy hh.mm STARTING
.in 10
ROUTCDE: 9,10
.br
DESC: ¬¬¬6
.in 0
.sp 1
 ¬¬¬¬¬¬MZAP has been invoked.
Initialization status and error messages may follow.
.sp 2
MZP101I UNAUTHORIZED CPU FOR MZAP
.in 10
ROUTCDE: 1,9,11
.br
DESC: ¬¬¬1
.in 0
.sp 1
 ¬¬¬¬¬¬MZAP is not running on the machine it was destributed for;
if you wish to use MZAP, order a separate copy for each CPU
on which it is to be used.
.sp 2
MZP102I SYSPRINT CARD MISSING - OUTPUT ON CONSOLE
.br
MZP102I SYSPRINT CARD MISSING - OUTPUT ON TERMINAL
.in 10
ROUTCDE: 9,10
.br
DESC: ¬¬¬7
.in 0
.sp 1
 ¬¬¬¬¬¬No SYSPRINT DD card is present, or, if TSO,
no suitable ALLOC was done for SYSPRINT.
Output will be via TPUT, if TSO,
to the CRT in batch,
and to the console via WTO if there is no CRT
assigned in batch.
.sp 2
MZP103I SYSIN DD CARD MISSING - INPUT FROM CONSOLE
.br
MZP103I SYSIN DD CARD MISSING - INPUT FROM KEYBOARD
MZP103I SYSIN DD CARD MISSING - INPUT FROM TERMINAL
.in 10
ROUTCDE: 9,10
.br
DESC: ¬¬¬7
.in 0
.sp 1
 ¬¬¬¬¬¬No appropriate ALLOC(TSO) or DD card for SYSIN.
Input will be via TPUT for TSO;
for batch, input will be from the keyboard of the
CRT, if one is assigned;
otherwise, input will be via REPLY to WTOR.
.sp 2
MZP104I SYSNUC MISSING OR INVALID
.in 10
ROUTCDE: 9,10,11
.br
DESC: ¬¬¬6
.in 0
.sp 1
 ¬¬¬¬¬¬Either there is no appropriate ALLOC(TSO) or DD card
for SYSNUC, or the DSNAME is not SYS1.NUCLEUS,
or it is not located on the IPL volume,
or the member name, IEANUC0x, is missing or is not the
nucleus most recently IPLed.
.sp 2
MZP105E UNSUPPORTED GRAPHICS DEVICE IGNORED
.in 10
ROUTCDE: 10,11
.br
DESC: ¬¬¬7,8,9
.in 0
.sp 1
 ¬¬¬¬¬¬An  ALLOC(TSO) or DD card exists for a graphics device
other than a 960 byte local 2260 or a 1980 byte local 3277.
2250, 2280, etc., are all unsupported, as are all remote CRTs.
Sorry 'bout that!
.in 0
.hi 0
.pa
.ce on
Input Messages______________

NOTE: NOGO____ switch will be set for all MZP2 messages.
.ce off
.sp 2
.in 0
.hi 6
MZP201I STATEMENT MISPLACED
.sp 1
 ¬¬¬¬¬¬VERIFY, REPLACE, POINT, etc. statement not
in the range of NAME statement.
.in 0
.sp 2
MZP202I INVALID OPCODE
.sp 1
 ¬¬¬¬¬¬The first non-blank column of the input statement
does not contain a valid MZAP opcode, or the opcode is
invalid but has restrictions on its use.
For example, this message is produced if a GO statement
is present in SYSIN.
.sp 2
MZP203I DEVICE NOT FOUND
.sp 1
 ¬¬¬¬¬¬An input statement, such a UCB, specified as
device address which was not present in any UCB.
.sp 2
MZP204I INVALID STATEMENT
.sp 1
 ¬¬¬¬¬¬A syntax error is present in an input statement.
A logical OR (|) will be displaYED BELOW THE COLUMN
AT WHICH THE ERROR WAS DETECTED.
For an omitted operand, this will bee the end of the statement.
For an invalid negative hex operand,
this will be the end of the operand,
not___ under the hyphen.
.sp 2
MZP205I NOT A VALID CONSOLE
.sp 1
 ¬¬¬¬¬¬The user specified a UCMID higher than the number of consoles
specified in the system,
he specified a unit (cuu) which is not defined as
an operators' console.
.sp 2
MZP206I NOT MCS
.sp 1
 ¬¬¬¬¬¬An operand was specified on a UCM statement
which is only valid for a system with the MCS
(Multiple Console Support) option.
.sp 2
MZP207I HARDCPY=SYSLOG - NO UCM
.sp 1
 ¬¬¬¬¬¬The statement UCM HARDCOPY is only valid if
a console device, rather than SYSLOG, is assigned the
SYSLOG function.
.sp 2
MZP208I CONSOLE NOT ACTIVE
.sp 1
 ¬¬¬¬¬¬The user specified a console which is ONLINE or
OFFLINE, rather than in CONSOLE status.
.sp 2
MZP209I NOT SMF
.sp 1
 ¬¬¬¬¬¬The user gave an input statement, such as SMCA,
which is only valid if the system is defined with
the SMF (System Management Facility) option.
.sp 2
MZP210I KEY xxxxxxxx?
.sp 1
 ¬¬¬¬¬¬The user gave a KEY statement with an invalid or
omitted operand.
He must reply with a valid key,
consisting of a scrambled version
of the displayed hexadecimal number.
If you don't know the magic number,
see your installation systems programmer for an explanation of why
you are not allowed to use this program!
.sp 2
MZP211I INVALID KEY
.sp 1
 ¬¬¬¬¬¬The user gave an invalid reply to MZP210I,
or supplied an invalid operand on a KEY statement.
This message will be followed by MZP210I.
.sp 2
MZP212I TCAM IS NOT ACTIVE
.sp 1
 ¬¬¬¬¬¬The user has requested a function,
such as AVT, which is only valid while TCAM is active.
.sp 2
MZP213I TSO IS NOT ACTIVE
.sp 1
 ¬¬¬¬¬¬The user has requested a function,
such as TSCVT, which is only valid while TSO is active.
.sp 2
MZP214I HASP IS NOT ACTIVE
.sp 1
 ¬¬¬¬¬¬The user has requested a function,
such as HCT, which is only valid while HASP is active.
.sp 2
MZP215I NAME NOT IN BLDL LIST
.sp 1
 ¬¬¬¬¬¬ IThe user has supplied a BLDL statement which
specifies a module not found in the BLDL list(s)
used in the current IPL.
An alternative explanation is that, since the latest IPL,
the appropriate BLDL entry has been REPed to another name.
.hi 0
.in 0
.pa
.ce on
HELP Messages_____________
.ce off
.hi 6
.sp 2
MZPH01I ALL
.sp 1
 ¬¬¬¬¬¬A display of all command names is in effect.
This message will remain on line 0 of the CRT
until the display is complete;
it will not appear on the console or SYSPRINT.
.sp 2
MZPH01I cmd
.sp 1
 ¬¬¬¬¬¬A display of the operands of the designated command
is in effect.
See MZPH01I ALL.
.sp 2
MZPH02I USE HELP <cmd> FOR OPERANDS OF <cmd>
.sp 1
 ¬¬¬¬¬¬This is the first line of output for HELP ALL.
If a supported CRT is assigned (960 byte local 2260,
1920 byte 3277),
or if MZAP is being called from TSO,
this  will be followed by an MZP002I message;
enter any desired attention messages and then
terminate attention mode with a null line.
.sp 2
MZPH03I OPCODE cmd
.sp 1
 ¬¬¬¬¬¬The designated opcode may be used in input statements.
.sp 2
MZPH04I INVALID OPCODE - HELP ALL FORCED
.sp 1
 ¬¬¬¬¬¬The operand used for HELP was invalid,
and will be ignored.
A list of valid opcodes will be displayed.
.sp 2
MZPH05I OPERAND text
.sp 1
 ¬¬¬¬¬¬The text listed is part of a description of
the operands of the command for which HELP was requested.
.hi 0
.in 0
.pa
.ce on
DEBUG Messages______________
.ce off
.sp 2
.li 1
MZPD01I VER/REP SNAP. SW=xx,xx,xx,xx
.sp 1
.in 10
A phase of MOREZAP has completed processing.
SW1-SW4 had the values, in hex, indicated in the message.
A set of messages, described below,
will be written for each of the MZAP control blocks
which have been constructed;
following this, the next phase will be called.
These messages are at least two lines, and include the following:
.in 0
.sp 2
.nf
.li 2
aaaaaa TYPE=xx: tttttttt NXT: nnnnnn LINE: ##### text
                                      FLG: ff
.fi l
.sp 1
.in 20
.hi 8
 Where a is the 6 hex digit virtual address of the control block
displayed.
.in 26
.hi 2
.sp 1
 x is the two hex digit type.
.sp 1
 t is a descrition of the type.
.sp 1
 n is the 6 hex digit address
of the next MZAP control block.
.sp 1
 # is the sequence number aSSIGNED TO THE INPUT STATEMENT
which generated the control block.
.sp 1
 f is the two hex digit flag field.
.hi 0
.in 0
.sp 2
.nf
.li 3
aaaaaa TYPE=00: VER      NXT: nnnnnn LINE: ##### LOC: @@@@@@ DATLN: mm(d
                                      FLG: ff,ff ABS: xxxxxx
                                      vvvv,vvvv,vvvv,vvvvv,vvvv,vvvv,vvv
.fi l
.sp 1
.in 20
.hi 8
 Where @ is the 6 hex digit relative address of the data to be verified.
.in 26
.hi 2
.sp 1
 m is the hex length-1 (i.e., as it would be used in a CLC).
.sp 1
 d is the decimal data length.
.sp 1
 x is the 6 digit absolute virtual address of the data to be  verified,
or is 0 if not yet known.
.sp 1
 v is the data to be used for verification,
or the data which failed to pass verification.
.sp 2
.hi 0
.in 0
.nf
.li 3
aaaaaa TYPE=01: REP      NXT: nnnnnn LINE: ##### LOC: @@@@@@ DATLN: mm(d
                                      FLG: ff,ff ABS: xxxxxx
                                      rrrr,rrrr,rrrr,rrrrr,rrrr,rrrr,rrr
.fi l
.in 20
.hi 8
.sp 1
 Where @ is the 6 hex digit relative address of the data to be replaced.
.in 26
.hi 2
.sp 1
 m is the hex length-1 (i.e., as it would be used in a MVC).
.sp 1
 d is the decimal data length.
.sp 1
 x is the 6 digit absolute virtual address of the data to be  replaced,
or is 0 if not yet known.
.sp 1
 r is the data to replace the data at @,
as relocated.
.sp 2
.hi 0
.in 0
.nf
.li 2
aaaaaa TYPE=02: BASE     NXT: nnnnnn LINE: ##### LOC: bbbbbb
                                      FLG: ff
.sp 1
.fi l
.in 20
.hi 8
 Where b is the 6 hex digit hex number to be subtraacted from
the relative address of each statement within
the scope of this BASE.
.hi 0
.in 0
.sp 2
.nf
.li 2
aaaaaa TYPE=03: INDEX    NXT: nnnnnn LINE: ##### LOC: xxxxxx IXNAME: eee
                                      FLG: ff
.fi l
.sp 1
.in 20
.hi 8
 Where x is the 6 hex digit hex number,
as far as currently resolved,
to be used as a relocation factor for each
statement within the scope of this INDEX.
.in 26
.hi 2
.sp 1
 e is the csect or entry point within the module
whose address is resolved as x.
.in 0
.hi 0
.sp 2
.nf
.li 2
aaaaaa TYPE=04: HINDEX   NXT: nnnnnn LINE: ##### LOC: xxxxxx
                                      FLG: ff
.fi l
.sp 1
.in 20
.hi 8
 Where x is the 6 hex digit number to be added to
the relative address of each statement within the scope
of this INDEX.
.in 0
.hi 0
.sp 2
.nf
.li 3
aaaaaa TYPE=05: NAME     NXT: nnnnnn LINE: ##### BEG: xxxxxx   NAME: mmm
                         CDE: rrrrrr  FLG: ff    SIZ: ssssss  CSECT: ccc
                         DCB: yyyyyy  dddddddd                  SSI: zzz
.fi l
.in 20
.hi 8
.sp 1
 Where x is the module or csect location,
as currently resolved.
.sp 1
.in 26
.hi 2
 m is the module name.
.sp 1
 r is the CDE (OS/MVT, OS/VS2) or RB (OS/MFT, OS/VS1) address,
if known, else 0.
This field is always 0 for the nucleus.
.sp 1
 s is the module or csect size, as currently resolved.
The module size for the nucleus is taken from  CVTNUCB.
.sp 1
 c is the csect name, if specified.
.sp 1
 y is the 6 hex digit address of the DCB for the library
containg the load module.
.sp 1
 d is the ddname of the library.
.sp 1
 z is the 8 hex digit System Status Information
(See the SRL for Services Aids).
.in 0
.hi 0
.sp 2
.nf
.li 2
aaaaaa TYPE=06: DUMP     NXT: nnnnnn LINE: ##### BEG: xxxxxx   NAME: mmm
                         CDE: rrrrrr  FLG: ff    SIZ: ssssss  CSECT: ccc
                         DCB: yyyyyy  dddddddd                  SSI: zzz
.fi l
.in 20
.hi 8
.sp 1
Where all fields are as explained for 05 (NAME).
.in 0
.hi 0
.sp 2
.nf
.li 2
aaaaaa TYPE=07: DUMPA    NXT: nnnnnn LINE: ##### BEG: xxxxxx   NAME: mmm
                         CDE: rrrrrr  FLG: ff    SIZ: ssssss  CSECT: ccc
                         DCB: yyyyyy  dddddddd                  SSI: zzz
.fi l
.in 20
.hi 8
.sp 1
Where all fields are as explained for 05 (NAME).
.in 0
.hi 0
.sp 2
.nf
.li 2
aaaaaa TYPE=08: DUMPT    NXT: nnnnnn LINE: ##### BEG: xxxxxx   NAME: mmm
                         CDE: rrrrrr  FLG: ff    SIZ: ssssss  CSECT: ccc
                         DCB: yyyyyy  dddddddd                  SSI: zzz
.fi l
.in 20
.hi 8
.sp 1
Where all fields are as explained for 05 (NAME).
.in 0
.hi 0
.sp 2
.nf
.li 2
aaaaaa TYPE=09: HDUMP    NXT: nnnnnn LINE: ##### LOC: @@@@@@ LEN: ssssss
                                      FLG: ff,ff ABS: xxxxxx
.fi l
.in 20
.hi 8
.sp 1
 Where @ is the 6 hex digit relative address of the
data to be dumped.
.in 26
.hi 2
.sp 1
 s is the 6 hex digit length of the area to be dumped.
.sp 1
 x is the 6 hex digit absolute virtual address of the data to be dumped,
or is 0 if not yet know.
.in 0
.hi 0
.sp 2
.nf
.li 2
aaaaaa TYPE=0A: HDUMPA   NXT: nnnnnn LINE: ##### LOC: @@@@@@ LEN: ssssss
                                      FLG: ff,ff ABS: xxxxxx
.fi l
.in 20
.hi 8
.sp 1
 Where @ is the 6 hex digit relative address of the
data to be dumped.
.in 26
.hi 2
.sp 1
 s is the 6 hex digit length of the area to be dumped.
.sp 1
 x is the 6 hex digit absolute virtual address of the data to be dumped,
or is 0 if not yet know.
.in 0
.hi 0
.sp 2
.nf
.li 2
aaaaaa TYPE=0B: HDUMPT   NXT: nnnnnn LINE: ##### LOC: @@@@@@ LEN: ssssss
                                      FLG: ff,ff ABS: xxxxxx
.fi l
.in 20
.hi 8
.sp 1
 Where @ is the 6 hex digit relative address of the
data to be dumped.
.in 26
.hi 2
.sp 1
 s is the 6 hex digit length of the area to be dumped.
.sp 1
 x is the 6 hex digit absolute virtual address of the data to be dumped,
or is 0 if not yet know.
.in 0
.hi 0
.sp 2
.nf
.li 2
aaaaaa TYPE=0C: LIB      NXT: nnnnnn LINE: ##### DCB: xxxxxx DDNAME: ddd
                                      FLG: ff
.fi l
.in 20
.hi 8
 Where x is the 6 hex digit absolute virtual address of the DCB,
or is 0 if LIB AUTO is in effect.
.in 26
.hi 2
.sp 1
 d is the ddname specified.
.in 0
.hi 0
.nf
.sp 2
.li 2
aaaaaa TYPE=0D: <- N *   NXT: nnnnnn LINE: ##### NDX: @@@@@@   LENB: sss
                         PTR: pppppp  FLG: ff,ff ABS: xxxxxx    IXB: iii
.fi l
.sp 1
.in 20
.hi 8
 Where @ is the absolute virtual index in effect at the time
the address, length, and index were saved.
.in 26
.hi 2
.sp 1
 s is the length of the module, csect, or control block.
.sp 1
 p is the address of the 8 byte area in which the address,
length, and relative index are to be stored.
.sp 1
 x is the absolute virtual address of the module, csect,
or control block.
.sp 1
 i is the relative index which was saved.
.in 0
.hi 0
.nf
.sp 2
.li 2
aaaaaa TYPE=0E: MVC      NXT: nnnnnn LINE: ##### LOC: @@@@@@ DATLN: (mm(
                         DST: pppppp  FLG: ff,ff ABS: xxxxxx
.fi l
.in 20
.hi 8
.sp 1
 Where @ is the relative address of the data to be saved.
.in 26
.hi 2
.sp 1
 m is the hex length-1 (i.e., as it would be used in an MVC).
.sp 1
 d is the decimal length.
.sp 1
 p is the address of the area in which the data is to be saved.
.sp 1
 x is the absolute virtual address of the data to be saved,
or 0 if not known.
.in 0
.hi 0
.nf
.sp 2
.li 2
aaaaaa TYPE=0F: <- N PTR NXT: nnnnnn LINE: ##### LOC: @@@@@@  LENB: ssss
                         PTR: pppppp  FLG: ff,ff ABS: xxxxxx   IXB: ssss
.fi l
.in 20
.hi 8
.sp 1
 Where @ is the relative address of the pointer to
the desired control block.
.in 26
.hi 2
.sp 1
 s is the length of the control block pointed to.
.sp 1
 p is the address of the 8 byte area where
the address, length, and relative index are to be stored.
.sp 1
 x is the absolute virtual address of the desired control block,
or 0 if not known.
.sp 1
 i is the relative index.
.in 0
.hi 0
.nf
.sp 2
.li 2
aaaaaa TYPE=10: -> PTR   NXT: nnnnnn LINE: ##### LOC: @@@@@@  LENB: ssss
                         PTR: pppppp  FLG: ff,ff ABS: xxxxxx   IXB: ssss
.fi l
.in 20
.hi 8
.sp 1
 Where @ is the relative address of the pointer to
the desired control block.
.in 26
.hi 2
.sp 1
 s is the length of the control block pointed to.
.sp 1
 p is the absolute virtual address of the pointer to
the desired control block.
.sp 1
 x is the absolute virtual address of the desired control block,
or 0 if not known.
.sp 1
 i is the relative index.
.in 0
.hi 0
.nf
.sp 2
.li 2
aaaaaa TYPE=11: -> REF N NXT: nnnnnn LINE: ##### NDX: @@@@@@  LENB: ssss
                         PTR: pppppp  FLG: ff,ff ABS: xxxxxx   IXB: ssss
.fi l
.in 20
.hi 8
.sp 1
 Where @ is the absolute virtual INDEX in effect when
the address, size, and index were restored.
.in 26
.hi 2
.sp 1
 s is the length of the module, csect, or control block.
.sp 1
 p is the address of the 8 byte area from which
the address, size, and relative index were or are
to be restored.
.sp 1
 x is the absolute virtual adress of the module, csect,
or control block.
.sp 1
 i is the relative index.
.in 0
.hi 0
.pa
.ce on
ESD Messages____________
.ce off
.sp 2
MZP401I mmmmmmmm DIRECTORY I/O ERROR
.sp 1
.in 6
A return code of 8 was received from the BLDL macro,
indicating an I/O error in the directory
while trying to locate module m.
.in 0
.sp 2
MZP402I mmmmmmmm NOT FOUND
.sp 1
.in 6
A return code of 4 was received from the BLDL macro,
indicating that module m was not found
in the directory of any of the relevant libraries.
Add a DD card for the necessary library,
and if required, add a LIB statement.
.in 0
.sp 2
MZP403I mmmmmmmm NOT SCTR
.in 6
.sp 1
A load module was found to be in block load format
when scatter format was expected.
Either the specified module was the nucleus,
or it was loaded with more than one extent;
in either case, the module found in the library
cannot be the proper member, since it does not
have the SCTR attribute.
.in 0
.sp 2
MZP404I mmmmmmmm NO ESD
.in 6
.sp 1
The first record in load module m, or the first
record following the SYM records,
is not a CESD record.
Run IMBLIST (LISTLOAD) on the module,
and call your friendly neighbor IBM CE
- the linkage editor has just awarded you third prize,
and there are only two contestants.
.in 0
.sp 2
MZP405I mmmmmmmm NO CON
.in 6
.sp 1
A reccord follows a CESD record which is not a control,
IDR, SCTR, or CESD record.
Call (but keep it clean) your friendly, neighborhood CE,
as for MZP404I.
.in 0
.sp 2
MZP406I mmmmmmmm MISSING CESD
.in 6
.sp 1
A SCTR format record has fewer CESD records than expected;
the BLDL entry may have an incorrect table length or
there may be a missing or incorrect CESD record.
.sp 1
Before complaining to IBM, list the module with IMBLIST and
verify that the problem is in the load module;
this message could conceivably be caused by an error
in MZAP, in which case the complaint should come to me
rather than IBM.
If you received MZAP as an IUP from IBM,
rather than directly from me,
then they get the complaint regardless
- but no doubt I'll hear from them.
.in 0
.sp 2
MZP407I mmmmmmmm MISSING SC/TR
.in 6
.sp 1
A record type other than hex 10 was found while
reading in the scatter/translate table.
See the remarks for MZP404I and MZP406I.
.in 0
.sp 2
MZP410I sssss NAME: mmmmmmmm NOT LOADED
.sp 1
.in 6
Module m was not found in the RERP, RAM, RSVC,
or TSLPA linkpack queues, nor in the or selected JPAQ.
.in 0
.sp 2
MZP411I sssss NAME: mmmmmmmm NOT IN DIRECTORY
.in 6
.sp 1
 Module m was not found in the proper library.
Usually accompanied by message MZP401I or MZP402I.
.in 0
.sp 2
MZP412I sssss NAME: mmmmmmmm cccccccc NOT FOUND
.in 6
.sp 1
Csect c does not exist in module m,
or an error exists in the format of load module m.
.in 0
.sp 2
MZP413I sssss NAME: mmmmmmmm cccccccc ABS:  aaaaaa:aaaaaa
.in 6
.sp 1
The designated module or csect exists and was loaded at
the listed absolute virtual addresses.
.in 0
.sp 2
MZP414I sssss ENTRY eeeeeeee NOT FOUND
.in 6
.sp 1
Entry point e was either specified in an INDEX statement
or implied by a control block statement:
CVT, UCB, etc.;
it could not be found in the load module's CESD.
.in 0
.sp 2
MZP415I sssss ENTRY eeeeeeee ABS: aaaaaa
.in 6
.sp 1
Entry point e is at the specified absolute virtual address.
.in 0
.sp 2
MZP416I sssss REL: rrrrrr:rrrrrr ABS: aaaaaa:aaaaaa OUT OF RANGE
.in 6
.sp 1
Statement number s specified either:
a relative address beyond the module or csect;
a negative displacement beyond the control block prefix;
or an excessive length for a VER, REP, or DUMP.
The range of addresses given is listed as both relative and
absolute virtual addresses.
.in 0
.sp 2
MZP420I sssss INVALID POINTER AT aaaaaa
.in 6
.sp 1
A POINT or SETPTR statement refers to a halfword which is negative.
Since the pointer type was specified as Y (15),
this is invalid.
.in 0
.sp 2
MZP421I sssss REF NOT - POINT INVALID
.in 6
.sp 1
A POINT REF statement refers to a ref digit for which either:
.hi 3
.in 8
 1. There is no preceeding SETPTR.
 2. The last preceeding SETPTR was not successfully processed.
.hi 0
.in 0
.sp 2
MZP422I sssss INDEX: iiiiii LIMITS: aaaaaa:aaaaaa
.in 6
.sp 1
A POINT statement refers to the designated absolute virtual address, i.
The limits are for the entire area pointed to,
including the prefix, if any.
.in 0
.pa
.ce on
DUMP Messages_____________
.ce off
.sp 2
.fi l
MZP501I sssss ÝACCESSED VIA¨ m Ýc¨
ÝINDEX: e¨ HEX/EBCDICÝ/OPCODE¨ DUMP
.in 6
.sp 1
This message is used as a subtile for all dumps.
The clause "INDEX: eeeeeeee" is present if an entry point
within the containing csect is specified,
either explicitly or implicitly.
The clause "ACCESSED VIA" is present if the limits
of the dump are relative to a location
found with a POINT statement;
any "INDEX" clause which would otherwise be supplied is suppressed,
in order not to exceed the line size of the 2260 or 3270.
.in 0
.hi 0
.pa
.ce daTA
VER/REP Messages________________
.ce off
.sp 2
MZP601I sssss NAME mmmmmmmm cccccccc
.in 6
One or more errors have been found relating to the specified module.
Addition messages will be displayed to diagnose the exact errors.
.in 0
.sp 2
MZP602I sssss rrrrrr:rrrrrr ABS: aaaaaa:aaaaaa OUT OF RANGE
.in 6
.sp 1
The start or end address of the verify or replace is outside the
bounds of the module or csect.
.in 0
.sp 2
MZP603I sssss VERIFY FAILURE AT: rrrrrr ABS :aaaaaa
.in 6
.sp 1
The data in storage did not match the VERIFY data.
This message is always accompanied by MZP604I.
.in 0
.sp 2
MZP604I sssss ACTUAL CONTENT IS xxxx,xxxx,...
.in 6
.sp 1
This message immediately follows MZP603I.
.in 0
.sp 2
MZP698I VERIFY/REPLACE PROCESSING SUCCESSFUL
.in 6
.sp 1
No errors were detected.
All REP operations, if any, were performed.
.in 0
.sp 2
MZP699I NOGO SWITCH SET - ALL REPS SUPPRESSED
.in 6
.sp 1
An error was detected.
No REP operation is performed.
The user should correct the errors indicated
in the preceeding error messages.
.in 0
.pa
.in 12
.nf
Final Housekeeping and Reinitialization Messages
.fo
.sp 2
MZP701I EOD
.in 6
.sp 1
Either an end-of-file occurred on SYSIN or a RESET EOD
statement was read.
All input read prior to that point has been processed.
.in 0
./ ADD NAME=MZAP     0100-19106-19106-2244-02246-02246-00000-MZAPFB  17
.ss
.ll 70
.pl 60
.tt //METZ'S OWN RELIABLE EXTENDED ZAP (MOREZAP)//
.bt //- % -//
.ce data
MOREZAP

- TABLE OF CONTENTS -
.end
.nj
.sp 2
 ¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬Page____
.sp 1
 ¬¬I.  INTRODUCTION ¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬2
.sp 1
 ¬II.  SYSTEM and INPUT/OUTPUT REQUIREMENTS ¬¬3
.sp 1
 III.  Attention/MODIFY Messages ¬¬¬¬¬¬¬¬¬¬¬¬¬6
.sp 1
 ¬IV.  INPUT Statements ¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬7
.sp 1
 ¬¬V.  JCL ¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬19
 ¬¬¬¬¬¬¬Example 1 ¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬20
 ¬¬¬¬¬¬¬Example 2 ¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬20
.sp 1
 ¬VI. ¬MESSAGES
 ¬¬¬¬¬¬¬General ¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬21
 ¬¬¬¬¬¬¬Common Messages ¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬22
 ¬¬¬¬¬¬¬Initialization Messages ¬¬¬¬¬¬¬¬¬¬¬¬¬23
 ¬¬¬¬¬¬¬Input Messages ¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬25
 ¬¬¬¬¬¬¬HELP Messages ¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬28
 ¬¬¬¬¬¬¬DEBUG Messages ¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬29
 ¬¬¬¬¬¬¬ESD Messages ¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬35
 ¬¬¬¬¬¬¬DUMP Messages ¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬38
 ¬¬¬¬¬¬¬VER/REP Messages ¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬39
 ¬¬¬¬¬¬¬Final Housekeeping and
 ¬¬¬¬¬¬¬¬Reinitialization Messages ¬¬¬¬¬¬¬¬¬¬40
.sp 1
 VII. ¬MZAP/CZAP Comparison ¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬41
.sp 1
VIII. ¬Index to Input Statements. ¬¬¬¬¬¬¬¬¬¬¬43
.sp 1
 ¬¬¬¬¬¬Sample Output ¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬A-1
.pa
I. ¬¬INTRODUCTION
.sp
.in 5
.fi l
This program is intendended to provide, for MVT,
the same function as the IBM service aid COREZAP0 (360S-01114-00),
referred to here as CZAP;
that is, to apply patches to programs in main storage.
Several of the control cards have an altered syntax in order
to permit names to be specified without framing characters.
There is a chart at the end of this writeup which illustrates
the known differences.
.sp 1
MZAP is organized as an overlay structure.
Information is passed between overlays through a set of switches
and through a chain of control of control blocks constructed
as a result of the input statements read.
.pa
.in 0
II. SYSTEM and INPUT/OUTPUT REQUIREMENTS
.sp 1
.in 5
MZAP requires that the control program be OS/MVT or OS/65MP;
OS/VS2 Release 1.6 support is planned in the near future;
and provision has been made for easily adding MFT or VS1 support
with only minor modifications.
No optional OS facilities need be generated,
other than normal device support (for the 2260,
this must be explicitly requested via the GRAPHICS macro;
for the 3270, this must be requested via the BTAM option
of the DATAMGT macro; for all sequential and DA devices
this support is automatic).
In particular, MZAP does not use SVC 54 to get into key 0,
and hence ISAM is not required.
When VS support is available,
MZAP will be required to run only from an authorized library.
.sp 1
MZAP is intended to obtain input from multiple sources:
a data set called SYSIN,
a TSO terminal,
a local crt, or an operator's console.
If MZAP is invoked from a TSO terminal,
input can be supplied only form SYSIN or the terminal;
otherwise a DD statement may be supplied allocating a
960 byte (12*80) local 2260 with line addressing and
non-destructive cursor
or a 1920 byte (24*80) EBCDIC local 3270,
which may be used for both input and output.
Input, output, and attention from an operators
console are performed via REPLY,
WTO/WTOR, and MODIFY;
they are normally inactive if a CRT is assigned,
but an uncorrectable I/O error on the CRT will
force transfer of these functions (the operator may
perform a MODIFY even when the CRT is operational).
.sp 1
Input is normally from a sequential data set,
SYSIN. If SYSIN is not defined or is a DD DUMMY,
"console input mode" is set.
This mode is also set by a CONSOLE statement read
from SYSIN or by a MODIFY or attention with the text CONSOLE.
Input is always translated to upper case.
Console mode is terminated, and control reverted to SYSIN,
by an END statement;
this is permitted only when SYSIN is assigned.
.sp 1
Output is normally to SYSPRINT.
If a 2260 or 3270 is assigned,
all output except page headings will be displayed on the CRT;
if in console input mode with no CRT assigned,
this output will be displayed via WTO/TPUT.
.sp 1
When a TSO terminal or a CRT is used,
it is in one of two states: normal and attention.
In normal state, input is solicited in a device-dependent fashion:
.in 10
.sp 1
.hi 12
2260 local:
Blanking the entry line and displaying an SMI;
the user keys in a command and depresses SHIFT and ENTER simultaneously.
.sp 1
3270 local:
writing a statement number, Blanking an entry line,
and positioning the cursor;
the user enters a command and depresses ENTER.
.sp 1
2260 TSO: ¬
Writing a statement number followed by an SMI;
the user enters a command and SHIFT/ENTER.
.sp 1
3270 TSO: ¬
writing a statement number and positioning the cursor;
the user enters a command and ENTER.
.sp 1
TSO: ¬¬¬¬¬¬¬
Writing a statement number;
the user enters a command and depresses RETURN, EOB, etc.,
according to the type of terminal.
.sp 2
.hi 0
.in 5
Attention state is entered in a device-dependent fashion:
.in 10
.hi 12
.sp 1
Local 2260:
SHIFT/ENTER within 1.5 seconds after
line 11(bottom line) is updated;
.sp 1
Local 3270:
ENTER or PA1 any time the keyboard is
unlocked;
.sp 1
TSO: ¬¬¬¬¬¬¬
the technique depends on type of terminal,
TSO/TCAM generation,
and the users last TERM command - it may be BREAK or
may be a simulated attention.
Attention state is also entered automatically when in HOLD mode
(see below).
.sp 1
.hi 0
.in 5
When in attention state,
the user will be prompted to key in an attention message by
blanking an entry line and displaying "EH ? " followed by an SMI (>|)
- a greater than sign (>) will be used on other than a 2260.
The prompt will be repeated after each attention message,
allowing the user to key in as many messages as he wishes;
attention state will be reset when he enters a null line
(SHIFT/ENTER, SHIFT, CR, etc. with no preceeding text).
.sp 2
.hi 0
.in 5
.sp 2
Output to the CRT/terminal may be done in two modes:
AUTO and HOLD;
output may be at any of four speeds:
SLOW, HALFAST, FAST, or PAGE.
In AUTO mode, output occurs continously until input is
required or the user enters attention state;
in HOLD mode attention state is entered after each write
and the user must enter a null line to continue.
.sp 2
Output to a CRT will always be in full screen mode;
the oldest line on the screen will be indicated by a logical or
(|).
The write will take place every time one, two, four, or twelve lines
(1,4,8, or 24 for 3270) have been written,
depending on the speed option.
In PAGE mode, one line (two if a dump is in progress)
will be reserved on the screen,
resulting in a net display of 11 (10 if a dump) lines per 2260 screen
and 23 (22 if a dump) per 3270 screen.
Regardless of the speed,
the current contents of the buffer will be written prior to
soliciting input or additional attention messages.
.sp 2
When a CRT is not assigned,
operator input in batch (non-TSO) will be solicited by a WTOR;
attention messages must be entered by giving the command
"MODIFY id,msg" where id is the jobname or START id and
msg is the text of the attention message.
See section V for a description of START requirements.
.pa
.in 0
III. Attention/MODIFY messages
.in 5
.sp 1
The following attention messages are allowed;
they may be in lower case since MZAP translates to upper case:
.sp 2
.in 10
.hi 12
$HELP ¬¬¬¬¬¬
display list of valid nonpriveleged attention messages.
This function is forced if an invalid attention message is entered.
.sp 1
CON ¬¬¬¬¬¬¬¬
set console input mode
.sp 1
STOP ¬¬¬¬¬¬¬
terminate dump or HELP
.sp 1
$HOLD ¬¬¬¬¬¬
enter attention state after every write
.sp 1
.br
$AUTO ¬¬¬¬¬¬
restore normal mode after $HOLD
.sp 1
$SLOW ¬¬¬¬¬¬
do 12 writes/2260 screen, 24/3270.
A write will occur for each output line.
.sp 1
$HALFAST ¬¬¬
do 6 writes/screen.
a write will occur for every 2 output lines(2260)
or every 4 lines(3270)
.sp 1
$FAST ¬¬¬¬¬¬
do 3 writes/screen.
A write will occur for every 4 output lines(2260)
or every 8 output lines(3270).
.sp 1
$PAGE ¬¬¬¬¬¬
do 1 write/screen.
If a dump is in progress,
one line is reserved for the dump header.
One line is reserved as the entry line.
A write will occur for every 10 or 11 output lines
(3270: 22 or 23 output lines).
.pa
.hi 0
.in 0
IV. INPUT STATEMENTS
.sp 1
.in 5
Input statements are of three types:
.in 8
.hi 4
.sp 1
1.)
A statement with an asterisk (*) in column 1 is a column 1 is a comment.
.sp 1
2.)
A blank card is a comment.
.sp 1
3.)
Any other statement contains an opcode in the first non-blank column
(normally column 1).
.hi 0
.in 5
.sp 1
For the remainder of this section,
the term "statement" will be understood to apply only to non-comments.
.sp 2
Each opcode may require or permit operands;
the opcode must be followed by a blank unless the operand
begins with a period (.), hyphen (-), or equal sign (=).
.sp 2
A hex (hexadecimal) number is expressed as an even number
of hexadecimal digits(0-9, A-F),
optionally preceeded by an equal sign or hyphen.
An equal sign indicates that the value which follows
is a number rather than a name;
a hyphen indicates a negative number and is only valid when
specifying a relative address;
an equal sign may preceed any hex data.
.sp 2
A character string is expressed by enclosing the desired characters
in apostrophes (');
an apostrophe is represented by two consequtive apostrophes('').
Apostrophe is the only character which is doubled;
in particular, an ampersand (&) is represented by a single______ a
Character strings may be used wherever hex numbers are valid,
and may be concatenated with hex data:
=C1C2C3, C1C2'C', C1'B'C3 and ='ABC' all represent the same value.
.sp 2
The following statements are accepted:
.in 9
.hi 13
.sp 1
KEY ¬¬¬¬¬¬¬¬¬
This statement is required if any REP statements are used.
The operand requirements may change for every release;
this is intended to prevent unauthorized use of MZAP.
It is recommended that each installation modify the
requirements for this opcode,
to prevent unauthorized alteration of their system.
The operand requirements have been deliberately omitted
from the writeup;
they will be made available only to a single
individual at each installation and he may select,
at his own discretion,
who is authorized to modify resident code.
.sp 2
DEBUG ¬¬¬¬¬¬¬
The switches and table entries used for communicating between
phases of MZAP will be displayed after each phase completes processing.
.in 9
.hi 13
.br
.sp 2
END ¬¬¬¬¬¬¬¬
Console input mode will be terminated if a valid SYSIN data set
was specified;
otherwise END is an invalid opcode.
.sp 2
GO ¬¬¬¬¬¬¬¬¬¬
Turns off the NOGO switch if from CRT/terminal/console;
GO is invalid from SYSIN.
.sp 2
RESET ¬¬¬¬¬¬¬
Causes all control cards previously read to be processed.
If an operand of EOD is specified,
no further input will be read;
otherwise NOGO and DEBUG will be reset and MZAP will
continue reading input.
.sp 2
JOB ¬¬¬¬¬¬¬¬¬jobname
.br
JOB ¬¬¬¬¬¬¬¬¬jobname.jobstepname
.br
JOB ¬¬¬¬¬¬¬¬¬taskid
.br
JOB ¬¬¬¬¬¬¬¬¬procname.taskid
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement defines the job whose JPAQ is
to be searched, prior to the TSLPA, RERP, RSVC, or RAM list queues.
A related set of ZAPs must lie within a single job;
once a JOB card is accepted, it is invalid to supply
a new one without first supplying a RESET card.
This restriction was imposed to maintain compatability with
the planned OS/VS2 release 2 (MVS) support.
.sp 2
.ce data
THIS DESCRIPTION IS FOR PLANNING PURPOSES ONLY.
THE WRITEUP WILL BE AMENDED WHEN JOB IS AVAILABLE.
.sp 2
NAME ¬¬¬¬¬¬¬¬.
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬.csectname
 ¬¬¬¬¬¬¬¬¬¬¬¬¬name csectname
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement defines the module or CSECT for
the VERIFYs, REPLACEs, and DUMPs which follow.
The name may be a load module name, a period (.),
or either one followed by a CSECT name.
If the load module was scatter loaded,
a CSECT name is required.
A period represents the nucleus specified as a member of
the dsname on SYSNUC,
and is considered to be block loaded.
The load address will be added to the relative address
on each applicable statement (VER, DUMP, etc.)
in the SCOPE of the NAME statement;
the length will be used to check that each relative address
is within bounds.
.sp 2
AVT ¬¬¬¬¬¬¬¬¬
This statement defines the module and CSECT for the
statements which follow.
The AVT address is obtained from the CVT;
the opcode is invalid if TCAM is not active.
.sp 2
BLDL ¬¬¬¬¬¬¬¬ name
This statement defines the module and CSECT for
the statements which follow.
It is invalid if the designated name does not
occur in the resident BLDL list.
The length is set to include only the specified
BLDL entry.
.sp 2
CVT ¬¬¬¬¬¬¬¬¬
This statement defines the module,CSECT, and INDEX
for the statements which follow.
Any location in the CSECT containing the CVT may be patched:
the locations should be given relative to the CVT.
It is equivalent, in MVT, to:
.hi 0
.in 25
.nj
NAME      .IEAQBK00
INDEX     IEACVT
.fi l
.in 9
.hi 13
.sp 2
GOVRFLB ¬¬¬¬¬
This statement, valid only for OS/MVT and OS/VS2,
defines the module, CSECT, and INDEX for the statements which follow.
Any location in the CSECT containing the main storage supervisor
may be patched;
the locations given should be relative to GOVRFLB.
It is equivalent to:
.hi 0
.in 25
.br
NAME ¬¬¬¬¬.IEAQBK00
.br
INDEX ¬¬¬¬GOVRFLB
.in 9
.hi 13
.sp 2
HCT ¬¬¬¬¬¬¬¬¬
This statement defines the module and CSECT for the HASP Control Table.
It is invalid if HASP is not active,
or if there is no local modification to the HASP SVC to return
the HCT address in register 15.
.sp 2
IBMORG ¬¬¬¬¬¬
This statement, valid only for OS/MVT and OS/VS2,
defines the module and CSECT for the statements which follow.
Any location in the SVC table may be patched;
the location given should be relative to the IBM portion of the table.
It is equivalent to:
.hi 0
.in 25
Name ¬¬¬¬.IBMORG
.in 9
.hi 13
.sp 2
MSER ¬¬¬¬¬¬¬¬
This statement defines the module and CSECT for
the statements which follow.
Any location in the Master Scheduler Resident Data Area
and in the Master Common Area may be patched.
It is equivalent to:
.hi 0
.in 25
NAME ¬¬¬¬¬.IEEMSER
.in 9
.hi 13
.sp 2
QMRES ¬¬¬¬¬¬¬
This statement defines the module and CSECT for
the statements which follow.
Any location in the Queue Manager Resident Data Area may be patched.
It is equivalent to:
.hi 0
.in 25
NAME ¬¬¬¬IEFJOB
.in 9
.hi 13
.sp 2
SCVT ¬¬¬¬¬¬¬¬
This statement, valid only in OS/MVT and OS/VS2, defines the module, CSE
for the statements which follow.
It is equivalent to:
.hi 0
.in 25
NAME ¬¬¬¬¬.IGC003
.br
INDEX ¬¬¬¬IEABEND
.in 9
.hi 13
.sp 2
SMCA ¬¬¬¬¬¬¬¬
This statement, valid only if the system was generated with the SMF opti
is used to define the module and CSECT for the statements which follow.
While it is not actually a CSECT, nor is it in the nucleus,
it may be patched as if it were.
.in 9
.hi 13
.sp 2
 TACT ¬¬¬¬¬¬¬¬
This statement, valid only in OS/MVT, defines the module, CSECT, and IND
for the statements which follow.
Any location in the CSECT containing the permanent TCBs,
transient areas, and CVT amy be patched;
the location given should be relative to the
Transient Area Control Table.
It is equivalent to:
.hi 0
.in 25
NAME ¬¬¬¬¬.IEAQBK00
.br
INDEX ¬¬¬¬IEAQTAQ
.in 9
.hi 13
.sp 2
TCB ¬¬¬¬¬¬¬¬¬job
.br
TCB ¬¬¬¬¬¬¬¬¬job.step
.br
TCB ¬¬¬¬¬¬¬¬¬id
.br
TCB ¬¬¬¬¬¬¬¬¬proc.id
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement defines the module, CSECT,
and INDEX for the statements which follow.
Any location in the jobstep tcb of the specified job or
started task may be patched:
addresses shhould be given relative to the TCB.
Note that floating-point registers are stored at a negative
displacement.
.sp 1
¬¬¬¬¬¬¬¬¬¬¬¬¬THE TCB OPCODE IS DESCRIBED FOR PLANNING PURPOSES ONLY.
THE WRITEUP WILL BE AMENDED WHEN IT IS AVAILABLE.
.sp 2
TSCVT ¬¬¬¬¬¬¬
This statement, valid onlin with OS/MVT and OS/VS2,
is used to define the module and CSECT for the statements which follow.
It is an invalid statement if TSO is not active.
Any location in the Time Shareing Communications Vector Table
may be patched;
locations should be given relative to the TSCVT.
.sp 2
UCB=cuu
.br
UCB cuu ¬¬¬¬¬
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement defines the module, CSECT, and INDEX for th
statements which follow.
Any location in the I/O Supervisor may be patched;
the location given should be relative to the specified UCB.
It is equivalent, in MVT, to:
.hi 0
.in 25
NAME ¬¬¬¬.IEAQFX00
.br
INDEX ¬¬¬ucbloc
.in 9
.hi 13
.sp 2
UCM ¬¬¬¬¬¬¬¬¬BASE
.br
UCM ¬¬¬¬¬¬¬¬¬HARDCOPY
.br
UCM ¬¬¬¬¬¬¬¬¬MASTER
.br
UCM ¬¬¬¬¬¬¬¬¬MCS
.br
UCM ¬¬¬¬¬¬¬¬¬PREFIX
.br
UCM ¬¬¬¬¬¬¬¬¬ID=xx
.br
UCM ¬¬¬¬¬¬¬¬¬UNIT=cuu
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement defines the module, CSECT, and INDEX
for the statements which follow.
Except for UCM BASE, the INDEX is set as an absolute address
rather than an entrypoint name or relative address.
HARDCOPY, MASTER, and MCS are only valid if the system was
generated with the Multiple Console Support option.
BASE, MCS, and PREFIX refer to UCM areas not related to
a specific console;
UCM MASTER and HARDCOPY refer to the UCME for the console assigned to
the designated function;
UCM ID=xx refers to the UCME whose ID (in decimal) is xx;
and UCM UNIT=cuu refers to the UCME for the designated device.
They are equivalent to:
.hi 0
.in 25
NAME ¬¬¬¬¬.IEEUCMC
.br
INDEX ¬¬¬¬IEECUCB (for BASE)
.br
 ¬¬¬¬¬¬¬¬¬¬forced absolute address
.br
 ¬¬¬¬¬¬¬¬¬¬(for other than BASE)
.in 9
.hi 13
.sp 2
USERORG ¬¬¬¬¬
This statement, valid only for OS/MVT and OS/VS2,
defines the module, CSECT, and INDEX
for the statements which follow.
Any location in the SVC table may be patched;
the location given should be relative to the user portion
of the table.
It is equivalent to:
.hi 0
.in 25
NAME ¬¬¬¬¬.IBMORG
.br
INDEX ¬¬¬¬USERORG
.in 9
.hi 13
.sp 2
BASE=xx ¬¬¬¬¬
.br
BASE xx ¬¬¬¬¬
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement is used to give a value to be subtracted
from the address given in a VER or REP.
It is normally the relative address of the CSECT,
as printed in the assembly listing.
The effect of this statement is retained until
the next statement containing or implying a name
(DUMP, NAME, INDEX, CVT, UCB, ...).
If a previous BASE is in effect,
the statement has a cummulative effect:
the amount subtracted is the sum of the BASEs.
.sp 2
INDEX=xx ¬¬¬¬
.br
INDEX xx ¬¬¬¬
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement is used to give a value to be added to
the address given in a VER, REP, DUMP, etc.
It is normally the relative address of a CSECT from a
link-edit listing.
The effect of this statement is retained until the next statement
containing or implying a name
(CVT, DUMP, INDEX, NAME, etc.);
all previous BASE or INDEX specifications remain in effect.
.sp 2
INDEX ¬¬¬¬¬¬¬name
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement is used to give a value to be added to the
address given in a VER, REP, DUMP, etc.
It resets all previous BASE and INDEX specifications.
The value used is the address of the CSECT or entry point specified,
adjusted by the CSECT or module address of the preceeding name statement
.sp 2
LIB ¬¬¬¬¬¬¬¬¬AUTO
.br
LIB ¬¬¬¬¬¬¬¬¬ddname
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement is used to specify the ddname of the
data set to be used to resolve CSECT names (other than nucleus CSECTs)
in statements which follow.
If AUTO is specified, modules found in TSLPA are assumed to be on CMDLIB
modules whose names begin with IFG or IG are assumed to be on SVCLIB;
all other modules are assumed to be on LINKLIB.
AUTO is initially in effect,
and remains in effect untill overrriden by an LIB statement.
.sp 2
VERIFY ¬¬¬¬¬¬rr dd
.br
VER ¬¬¬¬¬¬¬¬¬rr dd
.br
V ¬¬¬¬¬¬¬¬¬¬¬rr dr
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement is used to prevent inadvertently
altering the wrong location.
The data at the specified relative address, r, adjusted by
the address from the NAME statement and any BASE or INDEX in effect,
is compared to the specified data,
and, if a match does not occur,
a switch (called the NOGO switch) is set,
causing all REPs between the preceeding RESET (or beginning of input)
and the following RESET (or end of data) to be suppressed.
.sp 1
 ¬¬¬¬¬¬¬¬¬¬¬¬¬The location must be specified as 2, 4, or 6 hex digits,
preceeded (if negative) by a hyphen (-).
The data may be specified as:
.in 25
.hi 5
.sp 1
1). an even number of hex digits
.sp 1
2). a character string enclosed in apostrophes (');
an apostrophe is represented by 2 apostrophes
(i.e., "CAN'T" is entered as "CAN''T").
.sp 1
3). any combination of 1). and 2).
.sp 1
4). any of the above,
separated by commas (,).
.in 9
.hi 13
.sp 2
REPLACE ¬¬¬¬¬rr dd
.br
REP ¬¬¬¬¬¬¬¬¬rr dd
.br
R ¬¬¬¬¬¬¬¬¬¬¬rr dd
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement is used to replace data
at the specified relative location, r, as adjusted by the NAME,
BASE, and INDEX statements in effect.
See VER for a description of formats.
The effect of a REP is suppressed if the NOGO switch is set,
either because of a REP failure (see REP) or by an invalid
control statement (however, see GO and RESET).
.sp 2
CONSOLE
.br
CONSOLE ¬¬¬¬¬ID=cc
.br
CONSOLE ¬¬¬¬¬ID=cca
.br
CONSOLE ¬¬¬¬¬UNIT=ccu
.br
CONSOLE ¬¬¬¬¬DSRT=ddddrrrr
.br
CON
.br
CON ¬¬¬¬¬¬¬¬¬ID=cc
.br
CON ¬¬¬¬¬¬¬¬¬ID=cca
.br
CON ¬¬¬¬¬¬¬¬¬UNIT=ccu
.br
CON ¬¬¬¬¬¬¬¬¬DSRT=ddddrrrr
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement is used to cause subsequent input
to be from the CRT (if a local 2260 or 3270 is assigned),
the terminal (if TSO),
or the operators console (via WTO/WTOR and REPLY/MODIFY).
A specific console may be assigned by a two hex digit UCMID
(with an optional area identifier from A-Z) or
by a unit address.
Routing codes and descriptors may be specified in the form
ddddrrrr, where d is a 16 bit descriptor mask and
r is a 16 bit routing code mask.
.sp 2
DUMP ¬¬¬¬¬¬¬¬.
.br
DUMP ¬¬¬¬¬¬¬¬.csectname
.br
DUMP ¬¬¬¬¬¬¬¬name
.br
DUMP ¬¬¬¬¬¬¬¬name csectname
.br
DUMPB ¬¬¬¬¬¬¬.
.br
DUMPB ¬¬¬¬¬¬¬.csectname
.br
DUMPB ¬¬¬¬¬¬¬name
.br
DUMPB ¬¬¬¬¬¬¬name csectname
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement is used to print a dump of the specified
module or CSECT,
prior to applying any REPs.
The dump will contain a display of 16 bytes/line, in the format:
.ll 120
.nj
.hi 0
.in 0
.sp 2
R:b/rrrrrrb/A:b/aaaaaab/b/xxxxxxxxb/xxxxxxxxb/b/b/xxxxxxxxb/xx
.ll 70
.fi l
.hi 5
.in 22
.sp 2
  Where r is the relative address in hex
.in 28
.br
  a is the absolute address in hex
.br
  x is the data in hex
.br
  e is the data the data in EBCDIC, with unprintable characters
displayed as periods (.) or quotes (").
.br
 b/ is a blank
.in 9
.hi 13
.sp 1
 ¬¬¬¬¬¬¬¬¬¬¬¬¬A character is considered unprintable if it
does not appear on the CRT;
if called from a non-CRT TSO terminal or run in batch
without a CRT,
a character is unprintable if it does not appear un the PN train.
A cent sign (¢) is considered unprintable on the 2260
since it is used as an SMI (>|).
A quote rather than a period will be substituted for each
unprintable character only for the 2260;
quotes appear on the 2260 as an error symbol (_<>¬).
.sp 2
DUMP ¬¬¬¬¬¬¬¬=rr ss
.br
DUMPB ¬¬¬¬¬¬¬=rr ss
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement is used to print a partial dump of the
CSECT or module identified in the preceeding NAME statement.
r is 2, 4, or 6 hex digits,
preceeded by a hyphen if negative;
s is 2, 4, or 6 hex digits.
.sp 1
 ¬¬¬¬¬¬¬¬¬¬¬¬¬The data beginning at r,
adjusted by the preceeding NAME, INDEX, and BASE statements,
is displayed in the format shown above.
The number of bytes dumped will be given by s,
however the dump will always begin and end on a quadword
(16 byte) boundary.
.sp 2
DUMPA ¬¬¬¬¬¬¬.
.br
DUMPA ¬¬¬¬¬¬¬.csectname
.br
DUMPA ¬¬¬¬¬¬¬name
.br
DUMPA ¬¬¬¬¬¬¬name csectname
.br
DUMPA ¬¬¬¬¬¬¬=rr ss
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement has the same effect as DUMP,
except that VERs and REPs will be processed prior
to printing the dump.
.sp 2
DUMPT ¬¬¬¬¬¬¬.
.br
DUMPT ¬¬¬¬¬¬¬.csectname
.br
DUMPT ¬¬¬¬¬¬¬name
.br
DUMPT ¬¬¬¬¬¬¬name csectname
.br
DUMPT ¬¬¬¬¬¬¬=rr ss
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement has the same effect as DUMP,
except that VERs and REPs will be processed will be processed
prior to printing the dump and that the format of the dump is different.
Each halfword will be treated as the beginning of an instruction
for the purpose of printing an opcode under the hex value.
The dump will contain a display of 16 bytes/line, in the format:
.ll 120
.hi 0
.in 0
.nj
rrrrrrb/aaaaaab/b/xxxxb/xxxxb/b/xxxxb/xxxxb/b/b/xxxxb/xxxxb/
b/b/b/b/b/b/b/b/b/b/b/b/b/b/b/oooob/oooob/b/oooob/ooo
.fi l
.ll 70
.in 22
.hi 5
.sp 1
 Where r is the hex relative address
.in 28
a is the hex absolute address
.br
x is the hex data
.br
e is the EBCDIC data
.br
o is the opcode for the above data,
truncated to 5 characters
.br
b/ is a blank.
.in 9
.hi 13
.sp 2
HELP ¬¬¬¬¬¬¬¬This statement is used to obtain a list
of valid command names.
If a CRT is assigned,
or if MZAP is being run from a TSO terminal,
attention mode is forced and a $HELP is simulated
to enable the user to set the speed or hold options;
the list of commands will begin when a null line is entered.
The list can be terminated by entering an attention message
of "STOP" from the terminal/CRT or by the operator command:
"P id", where id is the jobname or START id.
.sp 2
HELP cmd ¬¬¬¬
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement is used to obtain a list of valid operands
for the designated input statement.
If a CRT is assigned or MZAP was invoked via TSO,
attention mode is forced and a $HELP is simulated
to enable the user to set the speed or hold options;
the list of operands will begin when a null line is entered.
The list can be terminated by entering an attention message
of "STOP" form the terminal/CRT or by the operator command:
"P id,STOP", where id is the jobname or START id.
.sp 2
SETPTR ¬¬¬¬¬¬refdigit *
.br
<- ¬¬¬¬¬¬¬¬¬¬refdigit *
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement, during dump processing or VERIFY/REP
processing;
causes the limits (address,length) and index currently in effect
to be saved in one of 16 MZAP "reference pointers";
refdigit, which may be any hex digit from 0 to F,
is used to identify this information for subsequent use
(see POINT).
.sp 2
SETPTR ¬¬¬¬¬¬refdigit ptr len
.br
<- ¬¬¬¬¬¬¬¬¬¬refdigit ptr len
.br
SETPTR ¬¬¬¬¬¬refdigit ptr len-pfx
.br
<- ¬¬¬¬¬¬¬¬¬¬refdigit ptr len-pfx
.br
SETPTR,plen ¬refdigit ptr len
.br
<-,plen ¬¬¬¬¬refdigit ptr len
.br
SETPTR,plen ¬refdigit ptr len-pfx
.br
<-,plen ¬¬¬¬¬refdigit ptr len-pfx
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬¬This statement,
during dump or VERIFY/REPLACE processing,
saves the limits (address, length) and index of a control block
as described below;
refdigit, which may be any hex digit from 0 to F,
is used to identify this information for subsequent use
(see POINT).
.sp 1
 ¬¬¬¬¬¬¬¬¬¬¬¬¬plen, if present, defines the type of pointer;
it may have the values 15, 16, 24, or 32 (the default);
in addition, Y, H, AL3, and A are synonymous to 15, 16, 24, and 32.
(Only the last 24 bits of a 32 bit pointer are used.)
.sp 1
 ¬¬¬¬¬¬¬¬¬¬¬¬¬ptr must be an even number of hex digits,
giving the relative address of a pointer.
In what follows, "(ptr)" denotes the contents of the designated location
.sp 1
 ¬¬¬¬¬¬¬¬¬¬¬¬¬len must be an even number of hex digits,
giving the size of the control block pointed to
(excluding prefix, if any).
.sp 1
 ¬¬¬¬¬¬¬¬¬¬¬¬¬pfx, if specified, must be an even number of hex digits,
giving the length in bytes of the control block prefix.
The hyphen separating len and pfx may be preceeded by blanks,
but may not be succeeded by blanks.
pfx is assumed to be 0 if not specified.
.sp 1
 ¬¬¬¬¬¬¬¬¬¬¬¬¬When the specified pointer, (ptr),
is accessed, the following are computed:
.nj
.in 25
.hi 0
address    is    (ptr)-pfx
length     is    len + pfx
index      is    (ptr)
relative
 index     is    index - address = pfx
.fi l
.in 10
.hi 12
 ¬¬¬¬¬¬¬¬¬¬¬¬The address, length, and relative index are then
saved in the requested reference pointer.
.sp 2
POINT ¬¬¬¬¬¬REF refdigit
.br
-> ¬¬¬¬¬¬¬¬¬REF refdigit
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬The address, length, and relative index last set into
the designated reference pointer are made current;
the index may be modified by a subsequent BASE or INDEX (hex only)
statement.
.sp 2
POINT ¬¬¬¬¬¬ptr len
.br
-> ¬¬¬¬¬¬¬¬¬ptr len
.br
POINT ¬¬¬¬¬¬ptr len-pfx
.br
-> ¬¬¬¬¬¬¬¬¬ptr len-pfx
.br
POINT,plen ¬ptr len
.br
->,plen ¬¬¬¬ptr len
.br
POINT,plen ¬ptr len-pfx
.br
->,plen ¬¬¬¬ptr len-pfx
.br
 ¬¬¬¬¬¬¬¬¬¬¬¬The address, length, and relative index for a control block
are made current.
See SETPTR for an explanation of the operands.
.pa
.in 0
.hi 0
V. ¬JCL
.in 5
.sp 1
MZAP requires the following JCL statements:
.nj
.sp 1
 1)  //       EXEC  PGM=MOREZAP,REGION=100K
 2)  //STEPLIB  DD  ...
 3)  //SYSNUC   DD  DSN=SYS1.NUCLEUS(IEANUC0x),DISP=SHR
 4)  //SVCLIB   DD  DSN=SYS1.SVCLIB,DISP=SHR
 5)  //CMDLIB   DD  DSN=SYS1.CMDLIB,DISP=SHR
 6)  //LINKLIB  DD  DSN=SYS1.LINKLIB,DISP=SHR
 7)  //         DD  ...
 8)  //ddn      DD  ...
 9)  //IEFRDER  DD  UNIT=cuu
10)  //SYSPRINT DD  SYSOUT=A
11)  //SYSIN    DD  *
.fi
.in 9
.sp 1
1.) The REGION size required will vary depending on the
size of the CESD for the nucleus and on the number of DD
statements.
.sp 1
2) This statement is not required if MOREZAP is located in
a JOBLIB or in the system link libraries.
.sp 1
3) This statement is required;
it must specify the nucleus currently loaded.
.sp 1
4) This statement is required if any module in SVCLIB is referenced
in a NAME or DUMP statement.
.sp
5) This statement is required if any module in the TSLPA is referenced
in a NAME or DUMP statement.
.sp
6) This statement is required if any module in the system
LINK library is referenced in a NAME or DUMP statement.
If SYS1.PARMLIB(LNKLST00) specified data sets concatemated to SYS1.LINKL
then these data sets must be specified on concatenated DD statements,
in the same order as in LNKLST00.
.sp 1
7) See 6.
.sp 1
8) Optional additional libraries may be specified;
the ddname should be the same as the operand of the LIB
statement which specifies the data set.
.sp 1
9) Optional 2260 (960 byte screen, local mode) or
3277 (1920 byte screen, local mode, EBCDIC) for
control statement and attention input.
Any ddname desired may be used,
however IEFRDER is suggested if MZAP is
to be invoked via a START command.
.sp 1
10) Printed output.
If no BLKSIZE is specified, 141 will be used for unit record
and 685 for tape or disk.
The user should specify the largest blocksize acceptable to
the system output writer at his installation.
If the installation is using ASP,
the blocksize should not exceed the ASP buffer size.
.sp 1
11) Control statement input.
Additional input may be requested from the operator with
a CONSOLE statement.
.in 5
.sp 2
The required JCL may be preceeded by a JOB card and submitted
through the input stream, or by SUBMIT.
Alternatively, the user may add the JCL to SYS1.PROCLIB,
and invoke MZAP with a START command.
See the Operators Reference and JCL Reference for more
information on catalogued procedures and START commands.
.in 8
.nj
.sp 2
//        EXEC   PGM=IEBUPDTE,PARM=NEW
//SYSUT2    dd   DSN=SYS1.PROCLIB,DISP=MOD
//SYSPRINT  DD   SYSOUT=A
//SYSIN     DD   DATA
.li
><         ADD   NAME=MZAP,LIST=ALL
.li
><      NUMBER   NEW1=1000,INCR=1000
//MZAP    PROC   NUC=1
//IEFPROC EXEC   PGM=MZAP
//STEPLIB   DD   DSN=SYS2.ASM.XEQ,DISP=SHR
//SYSNUC    DD   DSN=SYS1.NUCLEUS(IEANUC0&NUC),DISP=SHR
//IEFRDER   DD   UNIT=290
//SVCLIB    DD   DSN=SYS1.SVCLIB,DISP=SHR
//LINKLIB   DD   DSN=SYS1.LINKLIB,DISP=SHR
//          DD   DSN=SYS2.linklib,disp=SHR
//CMDLIB    DD   DSN=SYS1.CMDLIB,DISP=SHR
/*
.sp 1
       Adding PROC to PROCLIB
              (Example 1)
.sp 4
           S  MZAP.KENT,046,NUC=2
.sp 1
       Starting MZAP using sample PROC
              (Example 2)
.hi 0
.in 0
.pa
VI. ¬MESSAGES
.in 5
.fi l
.sp 1
Except for prompting, listing of input,
module/csect/control block dumps, and debug output,
all messages produced by MZAP have a common format:
.in 15
.sp 2
MZPfnnabtext
.in 5
.sp 1
Where f identifies the functional area:
.in 18
.hi 3
.sp 1
0 ¬common
.br
1 ¬initialization
.br
2 ¬control card scan
.br
H ¬HELP
.br
D ¬DEBUG
.br
3 ¬CDE search
.br
4 ¬ESD processing and module/csect/location listing
.br
5 ¬dump processing
.br
6 ¬VER/REP processing
.br
7 ¬final housekeeping, reinitialization, and termination
.hi 0
.sp 1
.in 10
nn is a decimal message number within function
.sp 1
a ¬is an action indicator:
A if action required, I otherwise.
.in 5
.sp 2
When a message relates to a specific input statement and
does not immediately follow the statement,
the message text will normally begin with the
5 digit sequence number assigned when that statement was read.
.in 0
.hi 0
.pa
.ce data
Common Messages_______________
.end
.hi 6
.sp 3
>|
.br
sssss>
.br
sssss>|
.br
sssss
 ¬¬¬¬¬¬Input required from the terminal, 2260, or 3270.
.sp 2
EH?>
.br
EH?>|
.br
 ¬¬¬¬¬¬Attention mode is in effect.
Key in attention input or terminated attention mode
with a null line.
.sp 2
MZP001I I/O ERROR ON 2260 - USE CONSOLE
.br
MZP001I I/O ERROR ON 3270 - USE CONSOLE
.in 10
ROUTCDE: 1,10,11
.br
DESC: ¬¬¬1
.in 0
.sp 1
 ¬¬¬¬¬¬Unrecoverable I/O error on the CRT.
Interactive I/O will be done via the WTO/WTOR/MODIFY interface.
.sp 2
MZP0002I $HELP: $HOLD|$AUTO CON STOP $PAGE|$HALFAST|$FAST|$SLOW
.br
.sp 1
 ¬¬¬¬¬¬Either HELP, $HELP or an invalid attention was entered.
The valid attention messages are listed,
with mutually exclusive messages separated by logical OR (|).
.sp 2
MZP0003A
.br
.in 10
ROUTCDE: 9,10
.br
DESC: ¬¬¬2
.br
.in 0
.sp 1
 ¬¬¬¬¬Input required via REPLY.
.sp 2
sssss text
.in 10
ROUTCDE: 9,10
.br
DESC: ¬¬¬7
.sp 1
 ¬¬¬¬¬¬Listing of user's input.
.sp 1
 ¬¬¬¬¬¬The designated text was read and assigned the sequence number
sssss.
The output is to SYSPRINT, terminal (if TSO CRT), or CRT (if assigned).
If the CONSOLE option is in effect, no CRT is assigned,
and MZAP is in batch, a WTO is used.
.pa
.ll 100
.ce data
Initialization Messages_______________________
.end
.ll 70
.sp 2
.in 0
.hi 6
.sp 2
MZP100I MOREZAP VERSION mm/dd/yy hh.mm STARTING
.in 10
ROUTCDE: 9,10
.br
DESC: ¬¬¬6
.in 0
.sp 1
 ¬¬¬¬¬¬MZAP has been invoked.
Initialization status and error messages may follow.
.sp 2
MZP101I UNAUTHORIZED CPU FOR MZAP
.in 10
ROUTCDE: 1,9,11
.br
DESC: ¬¬¬1
.in 0
.sp 1
 ¬¬¬¬¬¬MZAP is not running on the machine it was destributed for;
if you wish to use MZAP, order a separate copy for each CPU
on which it is to be used.
.sp 2
MZP102I SYSPRINT CARD MISSING - OUTPUT ON CONSOLE
.br
MZP102I SYSPRINT CARD MISSING - OUTPUT ON TERMINAL
.in 10
ROUTCDE: 9,10
.br
DESC: ¬¬¬7
.in 0
.sp 1
 ¬¬¬¬¬¬No SYSPRINT DD card is present, or, if TSO,
no suitable ALLOC was done for SYSPRINT.
Output will be via TPUT, if TSO,
to the CRT in batch,
and to the console via WTO if there is no CRT
assigned in batch.
.sp 2
MZP103I SYSIN DD CARD MISSING - INPUT FROM CONSOLE
.br
MZP103I SYSIN DD CARD MISSING - INPUT FROM KEYBOARD
MZP103I SYSIN DD CARD MISSING - INPUT FROM TERMINAL
.in 10
ROUTCDE: 9,10
.br
DESC: ¬¬¬7
.in 0
.sp 1
 ¬¬¬¬¬¬No appropriate ALLOC(TSO) or DD card for SYSIN.
Input will be via TPUT for TSO;
for batch, input will be from the keyboard of the
CRT, if one is assigned;
otherwise, input will be via REPLY to WTOR.
.sp 2
MZP104I SYSNUC MISSING OR INVALID
.in 10
ROUTCDE: 9,10,11
.br
DESC: ¬¬¬6
.in 0
.sp 1
 ¬¬¬¬¬¬Either there is no appropriate ALLOC(TSO) or DD card
for SYSNUC, or the DSNAME is not SYS1.NUCLEUS,
or it is not located on the IPL volume,
or the member name, IEANUC0x, is missing or is not the
nucleus most recently IPLed.
.sp 2
MZP105E UNSUPPORTED GRAPHICS DEVICE IGNORED
.in 10
ROUTCDE: 10,11
.br
DESC: ¬¬¬7,8,9
.in 0
.sp 1
 ¬¬¬¬¬¬An  ALLOC(TSO) or DD card exists for a graphics device
other than a 960 byte local 2260 or a 1980 byte local 3277.
2250, 2280, etc., are all unsupported, as are all remote CRTs.
Sorry 'bout that!
.in 0
.hi 0
.pa
.ll 100
.ce data
Input Messages______________

NOTE: NOGO____ switch will be set for all MZP2 messages.
.end
.ll 70
.sp 2
.in 0
.hi 6
MZP201I STATEMENT MISPLACED
.sp 1
 ¬¬¬¬¬¬VERIFY, REPLACE, POINT, etc. statement not
in the range of NAME statement.
.in 0
.sp 2
MZP202I INVALID OPCODE
.sp 1
 ¬¬¬¬¬¬The first non-blank column of the input statement
does not contain a valid MZAP opcode, or the opcode is
invalid but has restrictions on its use.
For example, this message is produced if a GO statement
is present in SYSIN.
.sp 2
MZP203I DEVICE NOT FOUND
.sp 1
 ¬¬¬¬¬¬An input statement, such a UCB, specified as
device address which was not present in any UCB.
.sp 2
MZP204I INVALID STATEMENT
.sp 1
 ¬¬¬¬¬¬A syntax error is present in an input statement.
A logical OR (|) will be displaYED BELOW THE COLUMN
AT WHICH THE ERROR WAS DETECTED.
For an omitted operand, this will bee the end of the statement.
For an invalid negative hex operand,
this will be the end of the operand,
not___ under the hyphen.
.sp 2
MZP205I NOT A VALID CONSOLE
.sp 1
 ¬¬¬¬¬¬The user specified a UCMID higher than the number of consoles
specified in the system,
he specified a unit (cuu) which is not defined as
an operators' console.
.sp 2
MZP206I NOT MCS
.sp 1
 ¬¬¬¬¬¬An operand was specified on a UCM statement
which is only valid for a system with the MCS
(Multiple Console Support) option.
.sp 2
MZP207I HARDCPY=SYSLOG - NO UCM
.sp 1
 ¬¬¬¬¬¬The statement UCM HARDCOPY is only valid if
a console device, rather than SYSLOG, is assigned the
SYSLOG function.
.sp 2
MZP208I CONSOLE NOT ACTIVE
.sp 1
 ¬¬¬¬¬¬The user specified a console which is ONLINE or
OFFLINE, rather than in CONSOLE status.
.sp 2
MZP209I NOT SMF
.sp 1
 ¬¬¬¬¬¬The user gave an input statement, such as SMCA,
which is only valid if the system is defined with
the SMF (System Management Facility) option.
.sp 2
MZP210I KEY xxxxxxxx?
.sp 1
 ¬¬¬¬¬¬The user gave a KEY statement with an invalid or
omitted operand.
He must reply with a valid key,
consisting of a scrambled version
of the displayed hexadecimal number.
If you don't know the magic number,
see your installation systems programmer for an explanation of why
you are not allowed to use this program!
.sp 2
MZP211I INVALID KEY
.sp 1
 ¬¬¬¬¬¬The user gave an invalid reply to MZP210I,
or supplied an invalid operand on a KEY statement.
This message will be followed by MZP210I.
.sp 2
MZP212I TCAM IS NOT ACTIVE
.sp 1
 ¬¬¬¬¬¬The user has requested a function,
such as AVT, which is only valid while TCAM is active.
.sp 2
MZP213I TSO IS NOT ACTIVE
.sp 1
 ¬¬¬¬¬¬The user has requested a function,
such as TSCVT, which is only valid while TSO is active.
.sp 2
MZP214I HASP IS NOT ACTIVE
.sp 1
 ¬¬¬¬¬¬The user has requested a function,
such as HCT, which is only valid while HASP is active.
.sp 2
MZP215I NAME NOT IN BLDL LIST
.sp 1
 ¬¬¬¬¬¬ IThe user has supplied a BLDL statement which
specifies a module not found in the BLDL list(s)
used in the current IPL.
An alternative explanation is that, since the latest IPL,
the appropriate BLDL entry has been REPed to another name.
.hi 0
.in 0
.pa
.ce data
HELP Messages_____________
.end
.hi 6
.sp 2
MZPH01I ALL
.sp 1
 ¬¬¬¬¬¬A display of all command names is in effect.
This message will remain on line 0 of the CRT
until the display is complete;
it will not appear on the console or SYSPRINT.
.sp 2
MZPH01I cmd
.sp 1
 ¬¬¬¬¬¬A display of the operands of the designated command
is in effect.
See MZPH01I ALL.
.sp 2
MZPH02I USE HELP <cmd> FOR OPERANDS OF <cmd>
.sp 1
 ¬¬¬¬¬¬This is the first line of output for HELP ALL.
If a supported CRT is assigned (960 byte local 2260,
1920 byte 3277),
or if MZAP is being called from TSO,
this  will be followed by an MZP002I message;
enter any desired attention messages and then
terminate attention mode with a null line.
.sp 2
MZPH03I OPCODE cmd
.sp 1
 ¬¬¬¬¬¬The designated opcode may be used in input statements.
.sp 2
MZPH04I INVALID OPCODE - HELP ALL FORCED
.sp 1
 ¬¬¬¬¬¬The operand used for HELP was invalid,
and will be ignored.
A list of valid opcodes will be displayed.
.sp 2
MZPH05I OPERAND text
.sp 1
 ¬¬¬¬¬¬The text listed is part of a description of
the operands of the command for which HELP was requested.
.hi 0
.in 0
.pa
.ce data
DEBUG Messages______________
.end
.sp 2
.li 1
MZPD01I VER/REP SNAP. SW=xx,xx,xx,xx
.sp 1
.in 10
A phase of MOREZAP has completed processing.
SW1-SW4 had the values, in hex, indicated in the message.
A set of messages, described below,
will be written for each of the MZAP control blocks
which have been constructed;
following this, the next phase will be called.
These messages are at least two lines, and include the following:
.in 0
.sp 2
.nj
.li 2
aaaaaa TYPE=xx: tttttttt NXT: nnnnnn LINE: ##### text
                                      FLG: ff
.fi l
.sp 1
.in 20
.hi 8
 Where a is the 6 hex digit virtual address of the control block
displayed.
.in 26
.hi 2
.sp 1
 x is the two hex digit type.
.sp 1
 t is a descrition of the type.
.sp 1
 n is the 6 hex digit address
of the next MZAP control block.
.sp 1
 # is the sequence number aSSIGNED TO THE INPUT STATEMENT
which generated the control block.
.sp 1
 f is the two hex digit flag field.
.hi 0
.in 0
.sp 2
.nj
.ll 100
.li 3
aaaaaa TYPE=00: VER      NXT: nnnnnn LINE: ##### LOC: @@@@@@ DATLN: mm(d
                                      FLG: ff,ff ABS: xxxxxx
                                      vvvv,vvvv,vvvv,vvvvv,vvvv,vvvv,vvv
.fi l
.ll 70
.sp 1
.in 20
.hi 8
 Where @ is the 6 hex digit relative address of the data to be verified.
.in 26
.hi 2
.sp 1
 m is the hex length-1 (i.e., as it would be used in a CLC).
.sp 1
 d is the decimal data length.
.sp 1
 x is the 6 digit absolute virtual address of the data to be  verified,
or is 0 if not yet known.
.sp 1
 v is the data to be used for verification,
or the data which failed to pass verification.
.sp 2
.hi 0
.in 0
.ll 100
.nj
.li 3
aaaaaa TYPE=01: REP      NXT: nnnnnn LINE: ##### LOC: @@@@@@ DATLN: mm(d
                                      FLG: ff,ff ABS: xxxxxx
                                      rrrr,rrrr,rrrr,rrrrr,rrrr,rrrr,rrr
.fi l
.ll 70
.in 20
.hi 8
.sp 1
 Where @ is the 6 hex digit relative address of the data to be replaced.
.in 26
.hi 2
.sp 1
 m is the hex length-1 (i.e., as it would be used in a MVC).
.sp 1
 d is the decimal data length.
.sp 1
 x is the 6 digit absolute virtual address of the data to be  replaced,
or is 0 if not yet known.
.sp 1
 r is the data to replace the data at @,
as relocated.
.sp 2
.hi 0
.in 0
.nj
.li 2
aaaaaa TYPE=02: BASE     NXT: nnnnnn LINE: ##### LOC: bbbbbb
                                      FLG: ff
.sp 1
.fi l
.in 20
.hi 8
 Where b is the 6 hex digit hex number to be subtraacted from
the relative address of each statement within
the scope of this BASE.
.hi 0
.in 0
.sp 2
.nj
.li 2
aaaaaa TYPE=03: INDEX    NXT: nnnnnn LINE: ##### LOC: xxxxxx IXNAME: eee
                                      FLG: ff
.fi l
.sp 1
.in 20
.hi 8
 Where x is the 6 hex digit hex number,
as far as currently resolved,
to be used as a relocation factor for each
statement within the scope of this INDEX.
.in 26
.hi 2
.sp 1
 e is the csect or entry point within the module
whose address is resolved as x.
.in 0
.hi 0
.sp 2
.nj
.li 2
aaaaaa TYPE=04: HINDEX   NXT: nnnnnn LINE: ##### LOC: xxxxxx
                                      FLG: ff
.fi l
.sp 1
.in 20
.hi 8
 Where x is the 6 hex digit number to be added to
the relative address of each statement within the scope
of this INDEX.
.in 0
.hi 0
.sp 2
.nj
.li 3
aaaaaa TYPE=05: NAME     NXT: nnnnnn LINE: ##### BEG: xxxxxx   NAME: mmm
                         CDE: rrrrrr  FLG: ff    SIZ: ssssss  CSECT: ccc
                         DCB: yyyyyy  dddddddd                  SSI: zzz
.fi l
.in 20
.hi 8
.sp 1
 Where x is the module or csect location,
as currently resolved.
.sp 1
.in 26
.hi 2
 m is the module name.
.sp 1
 r is the CDE (OS/MVT, OS/VS2) or RB (OS/MFT, OS/VS1) address,
if known, else 0.
This field is always 0 for the nucleus.
.sp 1
 s is the module or csect size, as currently resolved.
The module size for the nucleus is taken from  CVTNUCB.
.sp 1
 c is the csect name, if specified.
.sp 1
 y is the 6 hex digit address of the DCB for the library
containg the load module.
.sp 1
 d is the ddname of the library.
.sp 1
 z is the 8 hex digit System Status Information
(See the SRL for Services Aids).
.in 0
.hi 0
.sp 2
.nj
.ll 100
.li 2
aaaaaa TYPE=06: DUMP     NXT: nnnnnn LINE: ##### BEG: xxxxxx   NAME: mmm
                         CDE: rrrrrr  FLG: ff    SIZ: ssssss  CSECT: ccc
                         DCB: yyyyyy  dddddddd                  SSI: zzz
.fi l
.ll 70
.in 20
.hi 8
.sp 1
Where all fields are as explained for 05 (NAME).
.in 0
.hi 0
.sp 2
.nj
.ll 100
.li 2
aaaaaa TYPE=07: DUMPA    NXT: nnnnnn LINE: ##### BEG: xxxxxx   NAME: mmm
                         CDE: rrrrrr  FLG: ff    SIZ: ssssss  CSECT: ccc
                         DCB: yyyyyy  dddddddd                  SSI: zzz
.fi l
.ll 70
.in 20
.hi 8
.sp 1
Where all fields are as explained for 05 (NAME).
.in 0
.hi 0
.sp 2
.nj
.ll 100
.li 2
aaaaaa TYPE=08: DUMPT    NXT: nnnnnn LINE: ##### BEG: xxxxxx   NAME: mmm
                         CDE: rrrrrr  FLG: ff    SIZ: ssssss  CSECT: ccc
                         DCB: yyyyyy  dddddddd                  SSI: zzz
.fi l
.ll 70
.in 20
.hi 8
.sp 1
Where all fields are as explained for 05 (NAME).
.in 0
.hi 0
.sp 2
.nj
.ll 100
.li 2
aaaaaa TYPE=09: HDUMP    NXT: nnnnnn LINE: ##### LOC: @@@@@@ LEN: ssssss
                                      FLG: ff,ff ABS: xxxxxx
.fi l
.ll 70
.in 20
.hi 8
.sp 1
 Where @ is the 6 hex digit relative address of the
data to be dumped.
.in 26
.hi 2
.sp 1
 s is the 6 hex digit length of the area to be dumped.
.sp 1
 x is the 6 hex digit absolute virtual address of the data to be dumped,
or is 0 if not yet know.
.in 0
.hi 0
.sp 2
.nj
.ll 100
.li 2
aaaaaa TYPE=0A: HDUMPA   NXT: nnnnnn LINE: ##### LOC: @@@@@@ LEN: ssssss
                                      FLG: ff,ff ABS: xxxxxx
.fi l
.ll 70
.in 20
.hi 8
.sp 1
 Where @ is the 6 hex digit relative address of the
data to be dumped.
.in 26
.hi 2
.sp 1
 s is the 6 hex digit length of the area to be dumped.
.sp 1
 x is the 6 hex digit absolute virtual address of the data to be dumped,
or is 0 if not yet know.
.in 0
.hi 0
.sp 2
.nj
.ll 100
.li 2
aaaaaa TYPE=0B: HDUMPT   NXT: nnnnnn LINE: ##### LOC: @@@@@@ LEN: ssssss
                                      FLG: ff,ff ABS: xxxxxx
.fi l
.ll 70
.in 20
.hi 8
.sp 1
 Where @ is the 6 hex digit relative address of the
data to be dumped.
.in 26
.hi 2
.sp 1
 s is the 6 hex digit length of the area to be dumped.
.sp 1
 x is the 6 hex digit absolute virtual address of the data to be dumped,
or is 0 if not yet know.
.in 0
.hi 0
.sp 2
.nj
.ll 100
.li 2
aaaaaa TYPE=0C: LIB      NXT: nnnnnn LINE: ##### DCB: xxxxxx DDNAME: ddd
                                      FLG: ff
.fi l
.ll 70
.in 20
.hi 8
 Where x is the 6 hex digit absolute virtual address of the DCB,
or is 0 if LIB AUTO is in effect.
.in 26
.hi 2
.sp 1
 d is the ddname specified.
.in 0
.hi 0
.nj
.sp 2
.ll 100
.li 2
aaaaaa TYPE=0D: <- N *   NXT: nnnnnn LINE: ##### NDX: @@@@@@   LENB: sss
                         PTR: pppppp  FLG: ff,ff ABS: xxxxxx    IXB: iii
.fi l
.sp 1
.ll 70
.in 20
.hi 8
 Where @ is the absolute virtual index in effect at the time
the address, length, and index were saved.
.in 26
.hi 2
.sp 1
 s is the length of the module, csect, or control block.
.sp 1
 p is the address of the 8 byte area in which the address,
length, and relative index are to be stored.
.sp 1
 x is the absolute virtual address of the module, csect,
or control block.
.sp 1
 i is the relative index which was saved.
.in 0
.hi 0
.nj
.sp 2
.ll 100
.li 2
aaaaaa TYPE=0E: MVC      NXT: nnnnnn LINE: ##### LOC: @@@@@@ DATLN: (mm(
                         DST: pppppp  FLG: ff,ff ABS: xxxxxx
.fi l
.ll 70
.in 20
.hi 8
.sp 1
 Where @ is the relative address of the data to be saved.
.in 26
.hi 2
.sp 1
 m is the hex length-1 (i.e., as it would be used in an MVC).
.sp 1
 d is the decimal length.
.sp 1
 p is the address of the area in which the data is to be saved.
.sp 1
 x is the absolute virtual address of the data to be saved,
or 0 if not known.
.in 0
.hi 0
.nj
.sp 2
.ll 100
.li 2
aaaaaa TYPE=0F: <- N PTR NXT: nnnnnn LINE: ##### LOC: @@@@@@  LENB: ssss
                         PTR: pppppp  FLG: ff,ff ABS: xxxxxx   IXB: ssss
.fi l
.ll 70
.in 20
.hi 8
.sp 1
 Where @ is the relative address of the pointer to
the desired control block.
.in 26
.hi 2
.sp 1
 s is the length of the control block pointed to.
.sp 1
 p is the address of the 8 byte area where
the address, length, and relative index are to be stored.
.sp 1
 x is the absolute virtual address of the desired control block,
or 0 if not known.
.sp 1
 i is the relative index.
.in 0
.hi 0
.nj
.sp 2
.ll 100
.li 2
aaaaaa TYPE=10: -> PTR   NXT: nnnnnn LINE: ##### LOC: @@@@@@  LENB: ssss
                         PTR: pppppp  FLG: ff,ff ABS: xxxxxx   IXB: ssss
.fi l
.ll 70
.in 20
.hi 8
.sp 1
 Where @ is the relative address of the pointer to
the desired control block.
.in 26
.hi 2
.sp 1
 s is the length of the control block pointed to.
.sp 1
 p is the absolute virtual address of the pointer to
the desired control block.
.sp 1
 x is the absolute virtual address of the desired control block,
or 0 if not known.
.sp 1
 i is the relative index.
.in 0
.hi 0
.nj
.sp 2
.ll 100
.li 2
aaaaaa TYPE=11: -> REF N NXT: nnnnnn LINE: ##### NDX: @@@@@@  LENB: ssss
                         PTR: pppppp  FLG: ff,ff ABS: xxxxxx   IXB: ssss
.fi l
.ll 70
.in 20
.hi 8
.sp 1
 Where @ is the absolute virtual INDEX in effect when
the address, size, and index were restored.
.in 26
.hi 2
.sp 1
 s is the length of the module, csect, or control block.
.sp 1
 p is the address of the 8 byte area from which
the address, size, and relative index were or are
to be restored.
.sp 1
 x is the absolute virtual adress of the module, csect,
or control block.
.sp 1
 i is the relative index.
.in 0
.hi 0
.pa
.ce data
ESD Messages____________
.end
.sp 2
MZP401I mmmmmmmm DIRECTORY I/O ERROR
.sp 1
.in 6
A return code of 8 was received from the BLDL macro,
indicating an I/O error in the directory
while trying to locate module m.
.in 0
.sp 2
MZP402I mmmmmmmm NOT FOUND
.sp 1
.in 6
A return code of 4 was received from the BLDL macro,
indicating that module m was not found
in the directory of any of the relevant libraries.
Add a DD card for the necessary library,
and if required, add a LIB statement.
.in 0
.sp 2
MZP403I mmmmmmmm NOT SCTR
.in 6
.sp 1
A load module was found to be in block load format
when scatter format was expected.
Either the specified module was the nucleus,
or it was loaded with more than one extent;
in either case, the module found in the library
cannot be the proper member, since it does not
have the SCTR attribute.
.in 0
.sp 2
MZP404I mmmmmmmm NO ESD
.in 6
.sp 1
The first record in load module m, or the first
record following the SYM records,
is not a CESD record.
Run IMBLIST (LISTLOAD) on the module,
and call your friendly neighbor IBM CE
- the linkage editor has just awarded you third prize,
and there are only two contestants.
.in 0
.sp 2
MZP405I mmmmmmmm NO CON
.in 6
.sp 1
A reccord follows a CESD record which is not a control,
IDR, SCTR, or CESD record.
Call (but keep it clean) your friendly, neighborhood CE,
as for MZP404I.
.in 0
.sp 2
MZP406I mmmmmmmm MISSING CESD
.in 6
.sp 1
A SCTR format record has fewer CESD records than expected;
the BLDL entry may have an incorrect table length or
there may be a missing or incorrect CESD record.
.sp 1
Before complaining to IBM, list the module with IMBLIST and
verify that the problem is in the load module;
this message could conceivably be caused by an error
in MZAP, in which case the complaint should come to me
rather than IBM.
If you received MZAP as an IUP from IBM,
rather than directly from me,
then they get the complaint regardless
- but no doubt I'll hear from them.
.in 0
.sp 2
MZP407I mmmmmmmm MISSING SC/TR
.in 6
.sp 1
A record type other than hex 10 was found while
reading in the scatter/translate table.
See the remarks for MZP404I and MZP406I.
.in 0
.sp 2
MZP410I sssss NAME: mmmmmmmm NOT LOADED
.sp 1
.in 6
Module m was not found in the RERP, RAM, RSVC,
or TSLPA linkpack queues, nor in the or selected JPAQ.
.in 0
.sp 2
MZP411I sssss NAME: mmmmmmmm NOT IN DIRECTORY
.in 6
.sp 1
 Module m was not found in the proper library.
Usually accompanied by message MZP401I or MZP402I.
.in 0
.sp 2
MZP412I sssss NAME: mmmmmmmm cccccccc NOT FOUND
.in 6
.sp 1
Csect c does not exist in module m,
or an error exists in the format of load module m.
.in 0
.sp 2
MZP413I sssss NAME: mmmmmmmm cccccccc ABS:  aaaaaa:aaaaaa
.in 6
.sp 1
The designated module or csect exists and was loaded at
the listed absolute virtual addresses.
.in 0
.sp 2
MZP414I sssss ENTRY eeeeeeee NOT FOUND
.in 6
.sp 1
Entry point e was either specified in an INDEX statement
or implied by a control block statement:
CVT, UCB, etc.;
it could not be found in the load module's CESD.
.in 0
.sp 2
MZP415I sssss ENTRY eeeeeeee ABS: aaaaaa
.in 6
.sp 1
Entry point e is at the specified absolute virtual address.
.in 0
.sp 2
MZP416I sssss REL: rrrrrr:rrrrrr ABS: aaaaaa:aaaaaa OUT OF RANGE
.in 6
.sp 1
Statement number s specified either:
a relative address beyond the module or csect;
a negative displacement beyond the control block prefix;
or an excessive length for a VER, REP, or DUMP.
The range of addresses given is listed as both relative and
absolute virtual addresses.
.in 0
.sp 2
MZP420I sssss INVALID POINTER AT aaaaaa
.in 6
.sp 1
A POINT or SETPTR statement refers to a halfword which is negative.
Since the pointer type was specified as Y (15),
this is invalid.
.in 0
.sp 2
MZP421I sssss REF NOT - POINT INVALID
.in 6
.sp 1
A POINT REF statement refers to a ref digit for which either:
.hi 3
.in 8
 1. There is no preceeding SETPTR.
 2. The last preceeding SETPTR was not successfully processed.
.hi 0
.in 0
.sp 2
MZP422I sssss INDEX: iiiiii LIMITS: aaaaaa:aaaaaa
.in 6
.sp 1
A POINT statement refers to the designated absolute virtual address, i.
The limits are for the entire area pointed to,
including the prefix, if any.
.in 0
.pa
.ce data
DUMP Messages_____________
.end
.sp 2
.fi l
.ll 100
MZP501I sssss ÝACCESSED VIA¨ m Ýc¨
ÝINDEX: e¨ HEX/EBCDICÝ/OPCODE¨ DUMP
.ll 70
.in 6
.sp 1
This message is used as a subtile for all dumps.
The clause "INDEX: eeeeeeee" is present if an entry point
within the containing csect is specified,
either explicitly or implicitly.
The clause "ACCESSED VIA" is present if the limits
of the dump are relative to a location
found with a POINT statement;
any "INDEX" clause which would otherwise be supplied is suppressed,
in order not to exceed the line size of the 2260 or 3270.
.in 0
.hi 0
.pa
.ce daTA
VER/REP Messages________________
.end
.sp 2
MZP601I sssss NAME mmmmmmmm cccccccc
.in 6
One or more errors have been found relating to the specified module.
Addition messages will be displayed to diagnose the exact errors.
.in 0
.sp 2
MZP602I sssss rrrrrr:rrrrrr ABS: aaaaaa:aaaaaa OUT OF RANGE
.in 6
.sp 1
The start or end address of the verify or replace is outside the
bounds of the module or csect.
.in 0
.sp 2
MZP603I sssss VERIFY FAILURE AT: rrrrrr ABS :aaaaaa
.in 6
.sp 1
The data in storage did not match the VERIFY data.
This message is always accompanied by MZP604I.
.in 0
.sp 2
MZP604I sssss ACTUAL CONTENT IS xxxx,xxxx,...
.in 6
.sp 1
This message immediately follows MZP603I.
.in 0
.sp 2
MZP698I VERIFY/REPLACE PROCESSING SUCCESSFUL
.in 6
.sp 1
No errors were detected.
All REP operations, if any, were performed.
.in 0
.sp 2
MZP699I NOGO SWITCH SET - ALL REPS SUPPRESSED
.in 6
.sp 1
An error was detected.
No REP operation is performed.
The user should correct the errors indicated
in the preceeding error messages.
.in 0
.pa
.ll 158
.in 12
.nj
Final Housekeeping and Reinitialization Messages
.fi
.ll 70
.sp 2
MZP701I EOD
.in 6
.sp 1
Either an end-of-file occurred on SYSIN or a RESET EOD
statement was read.
All input read prior to that point has been processed.
.in 0
.pa
VII. ¬MZAP/CZAP Comparision
.sp 1
.in 4
.nj
MZAP____                          CZAP____
CONSOLE                       No equivalent
.sp 1
*                             *
.sp 1
NAME .                        NAME NUCLEUS
.sp 1
NAME .csect                   NAME NUCLEUS
                              INDEX csectdisp
.sp 1
NAME name                     NAME name
.sp 1
NAME name csect               NAME name
                              INDEX csectdisp
.sp 1
CVT                           NAME NUCLEUS
                              INDEX cvtloc
.sp 1
UCB=cuu                       NAME NUCLEUS
                              INDEX ucbloc
UCB cuu                       NAME NUCLEUS
                              INDEX ucbloc
.sp 1
BASE hexbase                  BASE hexbase
.sp 1
INDEX=hexix                   INDEX hexix
.sp 1
INDEX esdname                 INDEX csectdisp
                              BASE  esdindex
.sp 1
VERIFY  xx                    VERIFY  xx
VER     00 'a'                VER     00 c1
V       00 'a'C2              VER     00 c1C2
V       00 C3'D'              VER     00 c3C4
V       00 C6'GH'C9           VER     00 c6C7C8C9
.sp 1
REPLACE xx                    REPLACE xx
REP     00 'a'                REP     00 c1
R       00 'a'C2              REP     00 c1C2
R       00 C3'D'              REP     00 c3C4
R       00 C6'GH'C9           REP     00 c6C7C8C9
.sp 1
RESET                         RESET
.sp 1
RESET   EOD                   No equivalent
.sp 1
DUMP    name                  NAME    name
                              DUMP    0  modulelen
.sp 1
DUMP    name  csect           NAME    name
                              DUMP    csectdisp  csectlen
.sp 1
DUMP    .                     NAME    NUCLEUS
                              DUMP    0          nuclen
.sp 1
DUMP    .     csect           NAME    NUCLEUS
                              DUMP    csectdisp  csectlen
.sp 1
DUMPA   (see DUMP)            DUMPA   (see DUMP)
.sp 1
DUMPT   (see DUMP)            No equivalent
.sp 1
$ABEND  (attn)                ABEND
.sp 1
DEBUG   (Not truly equiv)     TRACE   (not truly equiv)
DEBUG   (Not truly equiv)     LOGOUT  (not truly equiv)
.sp 1
RESET   (Not truly equiv)     TRACEOFF(not truly equiv)
.fi
.in 0
.pa
VIII. ¬Index to Input Statements
.sp 2
.nj
.ll 140
Statement_________      Page____     Statement____
.ll 70
AVT               9     MSER                  10
BASE             12     NAME                   8
BLDL              9     POINT                 17
CONSOLE          14     QMRES                 10
CVT               9     R                     13
DEBUG             8     REP                   13
DUMP             14     REPLACE               13
DUMPA            15     RESET                  8
DUMPB            14     SCVT                  10
DUMPT            15     SETPTR                16
END               8     SMCA                  10
GO                8     TACT                  10
GOVRFLB           9     TCB                   10
HCT               9     TSCVT                 11
HELP             16     UCB                   11
IBMORG            9     UCM                   11
INDEX            12     USERORG               11
JOB               8     V                     13
KEY               7     VER                   13
LIB              13     VERIFY                13
./ ADD NAME=MZAPINST 0100-19106-19106-2244-00217-00217-00000-MZAPFB  17
.tt ///
.ti t 05
.ti set ¬
.he             MZAP Installation
.ce on
MOREZAP

INSTALLATION INSTRUCTIONS
______________________________
.ce off
.fo on
.sp 3
¬tMZAP is intended to be individually assembled for each
combination of operating system, system level, and CPU;
it will not function properly if run on the wrong system or CPU.
Any installation with multiple CPUs must order MZAP separately
for each CPU; any violation of this is construed as theft and
appropriate action will be taken.
.sp 1
¬tMZAP is intended to protect itself against theft,
by whatever means are considered appropriate.
Use at an unauthorized installation may crash the system,
destroy online disks,
or anything else which may strike my fancy:
furthermore, if such theft is discovered, legal action may be taken,
over and above whatever steps occur automatically.
.sp 1
¬tMZAP source consists of a set of macros,
a set of subroutines,
and a main module.
All of these have names beginning with MZ;
those subroutines which are link-edited together
with the main module have names beginning with MZAP.
.sp 1
¬tTo generate a copy of MZAP, certain important variables must
be ascertained.
They are as follows:
.ju no
.in 24
.sp 1
.un 14
1).  CPU ¬t- either 360___ or 370___.
.sp 1
.un 14
2).  CPUID ¬t- Must be the six digit IBM serial number of the
Central Processing Unit.
While the number is normally found on the front of the system console,
in certain models (such as 168) the console may be considered to be
a separate unit, and, as such, assigned a separate number;
it is safest to obtain the number from the CE, or in the case of 370s,
by performing a STIDP instruction while in supervisor mode.
.sp 1
3). MDL ¬t- 40__, 50__, 65__, 67__, 75__, 91__, 95__,
135___, 145___, 155___, 158___, 165___, 168___, or 195
.sp 1
.un 14
4). SYS ¬t- OS/MFT______, OS/MVT, VS1___, or VS2.___.
.un 14
4). SYS ¬t-
.oc _
OS/MFT, OS/MVT, VS1,
.oc
or
.oc _
VS2.
.oc
MP/65 is considered to be MVT.
.sp 1
.un 14
5).  RELEASE
.sp 1
.un 14
6). HASPSVC - For those unfortunate enough to be using HASP II
VERSION 3.0 or 3.1, this parameter should be specified as
the three decimal digit SVC number assigned to HASP.
HASP I is totally unsupported, support is planned for HASP II versions
4 and JES2(HASP II Version 5).
If you think you are using HASP 3, 4, or 5,
take another look at the book; or see an optometrist:
from 1968 to 1974, the only HASP releases have been HASP 2 (would you
believe an MFT/1 HASP 1 site in beautiful downtown Burbank?) -
any other number you may have heard is due to illiteracy.
This parameter is ignored for versions 4 and 5.
.sp 1
.un 14
7).  For 370 only, the emulators for which DUMPT support is desired.
.in 0
.fo on
.in 0
.sp 2
¬tIn addition to the MZAP macros,
OS macros from SYS1.MACLIB, SYS1.MODGEN, and SYS1.PVTMACS are used.
If the system was generated without TSO,
certain of the macros will be missing from SYS1.MACLIB
and may be found in SYS1.TSOMAC and SYS1.TCAMMAC.
For VS, some of the name have changes (for instance,
SYS1.MODGEN is now SYS1.AMODGEN),
but it should be clear from a listing of the VTOC what
the proper names are.
.sp 1
¬tThese OS macros come from two sources,
the DLIB disks and the optional source material.
While those macros not in SYS1.MACLIB will be supplied
as part of MZAP,
it is recommended that the installation replace them
with the macros at the proper release level.
.sp 2
¬tTo install MZAP, all modules must be reassembled
after two members are updated:
.pi 0
.in 14
.ju off
.sp 1
.un 4
1. MZSET contains SETx statements,
which must be modified to reflect the customer's configuration;
the spellings underlined must be adhered to.
.sp 1
.un 4
2. MZAP5 contains SETA and SETC statements specifying emulators
whose opcodes are to be recognized during DUMPT Processing.
360 is mandatory;
370 is strongly recommended;
any of the others may be included if the customer wishes.
.in 0
.fo on
.sp 2
The MZAP modules which must be reassembled are:
.in 23
.ju off
.un 13
MZAP1 ¬t¬tInitialization
.sp 1
.un 13
MZAP2 ¬t¬tControl Cards
.sp 1
.un 13
MZAPDBUG ¬t¬tDEBUG Snapshots of Control Blocks
.sp 1
.un 13
MZAP3 ¬t¬tCDE/LPRB lookup
.sp 1
.un 13
MZAP4 ¬t¬tESD Lookup
.sp 1
.un 13
MZAP5 ¬t¬tDump Processing
.sp 1
.un 13
MZAP6 ¬t¬tVER/REP Processing
.sp 1
.un 13
MZAP7 ¬t¬tFinal housekeeping and reinitialization
.sp 1
.un 13
MZPRINT ¬t¬tSYSPRINT Access Method
.sp 1
.un 13
MZWTO ¬t¬tOperator's console access method
.sp 1
.un 13
MZ2260 ¬t¬t2260 local CRT access method
.sp 1
.un 13
MZ3270 ¬t¬t3270 local CRT access method
.sp 1
.un 13
MZTSO ¬t¬tTSO non-CRT access method
.sp 1
.un 13
MZTS2260 ¬¬¬¬TSO 2260 CRT access method
.sp 1
.un 13
MZTS3270 ¬¬¬¬TSO 3270 CRT access method
.in 0
.fo on
.sp 2
¬tWhen MZAP has been assembled,
remove any ALIAS card from the beginning of each object
deck except MZAP1,
leave the OVERLAY and INSERT cards in front of the MZAP1
object deck, and remove any cardspunched by the separator,
including blank cards.
Place the statement NAME MZAP(R) at the end of the last object deck.
The object deck, or a copy on tape,
may now be shipped to the customer site.
.sp 1
¬tThe OS customer should link-edit MZAP with the OVLY attribute;
the VS customer may prefer not to use the overlay supervisor.
If the assemblies are done at the customer's site,
then an assemble-and-link may be done
and no object decks need be punched.
.sp 2
¬tNote that it is imperative that a separate copy of MZAP
be ordered for each cpu-system combination:
.pi 0
.in 10
.hi 4
.fi l
.sp 1
1. Some functions are logically different for each of the five
OS systems (MFT, VS1, MVT, SVS, MVS).
.sp 1
2. Special processing may be done on specific models to
avoid causing problems to MCH.
This may be necessary as a precaution against storage failures
in modules which were copied or checksummed into SYS1.ASRLIB,
or which reside in the PLPA.
.sp 1
.un 14
3. If the CPU type, CPU model, or CPUID are not as expected,
this is interpreted as being due to an unauthorized use of
a stolen copy of MZAP and appropriate measures are taken;
a system crash is the least that could result.
.in 0
.hi 0
.fi
./ ADD NAME=SYSTEM   0100-19106-19106-2244-00195-00195-00000-MZAPFB  17
II. SYSTEM and INPUT/OUTPUT REQUIREMENTS
.sp 1
.in 5
MZAP requires that the control program be OS/MVT or OS/65MP;
OS/VS2 Release 1.6 support is planned in the near future;
and provision has been made for easily adding MFT or VS1 support
with only minor modifications.
No optional OS facilities need be generated,
other than normal device support (for the 2260,
this must be explicitly requested via the GRAPHICS macro;
for the 3270, this must be requested via the BTAM option
of the DATAMGT macro; for all sequential and DA devices
this support is automatic).
In particular, MZAP does not use SVC 54 to get into key 0,
and hence ISAM is not required.
When VS support is available,
MZAP will be required to run only from an authorized library.
.sp 1
MZAP is intended to obtain input from multiple sources:
a data set called SYSIN,
a TSO terminal,
a local crt, or an operator's console.
If MZAP is invoked from a TSO terminal,
input can be supplied only form SYSIN or the terminal;
otherwise a DD statement may be supplied allocating a
960 byte (12*80) local 2260 with line addressing and
non-destructive cursor
or a 1920 byte (24*80) EBCDIC local 3270,
which may be used for both input and output.
Input, output, and attention from an operators
console are performed via REPLY,
WTO/WTOR, and MODIFY;
they are normally inactive if a CRT is assigned,
but an uncorrectable I/O error on the CRT will
force transfer of these functions (the operator may
perform a MODIFY even when the CRT is operational).
.sp 1
Input is normally from a sequential data set,
SYSIN. If SYSIN is not defined or is a DD DUMMY,
"console input mode" is set.
This mode is also set by a CONSOLE statement read
from SYSIN or by a MODIFY or attention with the text CONSOLE.
Input is always translated to upper case.
Console mode is terminated, and control reverted to SYSIN,
by an END statement;
this is permitted only when SYSIN is assigned.
.sp 1
Output is normally to SYSPRINT.
If a 2260 or 3270 is assigned,
all output except page headings will be displayed on the CRT;
if in console input mode with no CRT assigned,
this output will be displayed via WTO/TPUT.
.sp 1
When a TSO terminal or a CRT is used,
it is in one of two states: normal and attention.
In normal state, input is solicited in a device-dependent fashion:
.in 10
.sp 1
.hi 12
2260 local:
Blanking the entry line and displaying an SMI;
the user keys in a command and depresses SHIFT and ENTER simultaneously.
.sp 1
3270 local:
writing a statement number, Blanking an entry line,
and positioning the cursor;
the user enters a command and depresses ENTER.
.sp 1
2260 TSO: ¬
Writing a statement number followed by an SMI;
the user enters a command and SHIFT/ENTER.
.sp 1
3270 TSO: ¬
writing a statement number and positioning the cursor;
the user enters a command and ENTER.
.sp 1
TSO: ¬¬¬¬¬¬¬
Writing a statement number;
the user enters a command and depresses RETURN, EOB, etc.,
according to the type of terminal.
.sp 2
.hi 0
.in 5
Attention state is entered in a device-dependent fashion:
.in 10
.hi 12
.sp 1
Local 2260:
SHIFT/ENTER within 1.5 seconds after
line 11(bottom line) is updated;
.sp 1
Local 3270:
ENTER or PA1 any time the keyboard is
unlocked;
.sp 1
TSO: ¬¬¬¬¬¬¬
the technique depends on type of terminal,
TSO/TCAM generation,
and the users last TERM command - it may be BREAK or
may be a simulated attention.
Attention state is also entered automatically when in HOLD mode
(see below).
.sp 1
.hi 0
.in 5
When in attention state,
the user will be prompted to key in an attention message by
blanking an entry line and displaying "EH ? " followed by an SMI (>|)
- a greater than sign (>) will be used on other than a 2260.
The prompt will be repeated after each attention message,
allowing the user to key in as many messages as he wishes;
attention state will be reset when he enters a null line
(SHIFT/ENTER, SHIFT, CR, etc. with no preceeding text).
.sp 2
.hi 0
.in 5
.sp 2
Output to the CRT/terminal may be done in two modes:
AUTO and HOLD;
output may be at any of four speeds:
SLOW, HALFAST, FAST, or PAGE.
In AUTO mode, output occurs continously until input is
required or the user enters attention state;
in HOLD mode attention state is entered after each write
and the user must enter a null line to continue.
.sp 2
Output to a CRT will always be in full screen mode;
the oldest line on the screen will be indicated by a logical or
(|).
The write will take place every time one, two, four, or twelve lines
(1,4,8, or 24 for 3270) have been written,
depending on the speed option.
In PAGE mode, one line (two if a dump is in progress)
will be reserved on the screen,
resulting in a net display of 11 (10 if a dump) lines per 2260 screen
and 23 (22 if a dump) per 3270 screen.
Regardless of the speed,
the current contents of the buffer will be written prior to
soliciting input or additional attention messages.
.sp 2
When a CRT is not assigned,
operator input in batch (non-TSO) will be solicited by a WTOR;
attention messages must be entered by giving the command
"MODIFY id,msg" where id is the jobname or START id and
msg is the text of the attention message.
See section V for a description of START requirements.
.pa
.in 0
III. Attention/MODIFY messages
.in 5
.sp 1
The following attention messages are allowed;
they may be in lower case since MZAP translates to upper case:
.sp 2
.in 10
.hi 12
$HELP ¬¬¬¬¬¬
display list of valid nonpriveleged attention messages.
This function is forced if an invalid attention message is entered.
.sp 1
CON ¬¬¬¬¬¬¬¬
set console input mode
.sp 1
STOP ¬¬¬¬¬¬¬
terminate dump or HELP
.sp 1
$HOLD ¬¬¬¬¬¬
enter attention state after every write
.sp 1
.br
$AUTO ¬¬¬¬¬¬
restore normal mode after $HOLD
.sp 1
$SLOW ¬¬¬¬¬¬
do 12 writes/2260 screen, 24/3270.
A write will occur for each output line.
.sp 1
$HALFAST ¬¬¬
do 6 writes/screen.
a write will occur for every 2 output lines(2260)
or every 4 lines(3270)
.sp 1
$FAST ¬¬¬¬¬¬
do 3 writes/screen.
A write will occur for every 4 output lines(2260)
or every 8 output lines(3270).
.sp 1
$PAGE ¬¬¬¬¬¬
do 1 write/screen.
If a dump is in progress,
one line is reserved for the dump header.
One line is reserved as the entry line.
A write will occur for every 10 or 11 output lines
(3270: 22 or 23 output lines).
.in 0
