{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012326000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE548.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE548.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x03\\t'", "DS1TRBAL": "b'h\\xca'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\x10\\x00\\x03\\x04\\x10\\x00\\x06\\x00\\x04'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x04o\\x01\\x02\\x04o\\t5\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc8\\xc9\\xd7\\xc4\\xc1\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-02-15T00:00:00", "modifydate": "2002-02-15T09:35:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SHIPDAT"}, "text": "REGULAR CBT TAPE - VERSION 443    FILE:  548\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT443.FILE548\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 8 MEMBERS COUNTED; CUMULATIVE SIZE IS 852 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   02/15/02    09:35:08    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$INDEX": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x04o\\x01\\x02\\x04o\\t\"\\x00\\x1b\\x00\\x1b\\x00\\x00\\xd5\\xc9\\xd2\\xd6\\xd3\\xe8\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-02-15T00:00:00", "modifydate": "2002-02-15T09:22:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "NIKOLYN"}, "text": "These REXX functions were written as supplements for managing PPRC\nvolume pairs. They will be useful for HDS ShadowImage environments.\n\nContact Alfred Nykolyn   apn@istar.ca for any problems\n\n\nRXSIQRY  Returns the state of a PPRC pair\n         status = RXSIQRY(devN)\n         States are SIMPLEX, PENDING, DUPLEX, SUSPEND\n\nRXV2DEV  Returns the device number of a specified volume\n         devN   = RXV2DEV(VolSer)\n\nRXSLEEP  Sleeps for a specified time\n            y   = RXSLEEP(wait)\n         Antoher sleep routine using STIMERM.\n         Contrary to popular belief, it is impossible to\n         escape from the wait by trapping the attention with\n         a STAX. The attention exit gains control after the\n         wait time has expired. This could be done by using\n         multiple TCB's and some tricky logic. But this is\n         just too complicated.\n\nRXWTO    Issue a message to the operator\n            y   = RXWTO('Your message')\n\n$ASMCL   JCL to build these functions\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$ASMCL": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x04o\\x01\\x02\\x04o\\t\"\\x00\\x15\\x00\\x15\\x00\\x00\\xd5\\xc9\\xd2\\xd6\\xd3\\xe8\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-02-15T00:00:00", "modifydate": "2002-02-15T09:22:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "NIKOLYN"}, "text": "//NYKOLYNA JOB  (X),NYKOLYN,MSGCLASS=X,CLASS=A,\n// NOTIFY=&SYSUID\n//**Asm\n//ASMCL    PROC M=\n//A    EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.AMODGEN\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSLIN   DD UNIT=VIO,SPACE=(CYL,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DSN=NYKOLYN.RXQUERY.CNTL(&M),DISP=SHR\n//*\n//L       EXEC PGM=IEWL,PARM='RENT,REFR,REUS',COND=(4,LT,A)\n//SYSLIN   DD DSN=*.A.SYSLIN,DISP=(OLD,PASS)\n//SYSPRINT DD SYSOUT=*\n//SYSLMOD  DD DSN=NYKOLYN.A.LOAD(&M),DISP=SHR\n//        PEND\n//SLEEP   EXEC ASMCL,M=RXSLEEP\n//WTO     EXEC ASMCL,M=RXWTO\n//V2DEV   EXEC ASMCL,M=RXV2DEV\n//SIQUERY EXEC ASMCL,M=RXSIQRY\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE548": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x008\\x01\\x01\\x02_\\x01\\x02\\x04o\\t1\\x00!\\x00\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2001-01-25T00:00:00", "modifydate": "2002-02-15T09:31:38", "lines": 33, "newlines": 2, "modlines": 0, "user": "SBGOLOB"}, "text": "//***FILE 548 is from Alfred Nikolyn and contains some REXX         *   FILE 548\n//*           functions, which are especially useful in disk        *   FILE 548\n//*           shadowing environments, but which are useful in       *   FILE 548\n//*           general.                                              *   FILE 548\n//*                                                                 *   FILE 548\n//*      These REXX functions were written as supplements for       *   FILE 548\n//*      managing PPRC volume pairs.  They will be useful for HDS   *   FILE 548\n//*      ShadowImage environments.                                  *   FILE 548\n//*                                                                 *   FILE 548\n//*      Contact Alfred Nykolyn   apn@istar.ca for any problems     *   FILE 548\n//*                                                                 *   FILE 548\n//*      RXSIQRY  Returns the state of a PPRC pair                  *   FILE 548\n//*               status = RXSIQRY(devN)                            *   FILE 548\n//*               States are SIMPLEX, PENDING, DUPLEX, SUSPEND      *   FILE 548\n//*                                                                 *   FILE 548\n//*      RXV2DEV  Returns the device number of a specified volume   *   FILE 548\n//*               devN   = RXV2DEV(VolSer)                          *   FILE 548\n//*                                                                 *   FILE 548\n//*      RXSLEEP  Sleeps for a specified time                       *   FILE 548\n//*                  y   = RXSLEEP(wait)                            *   FILE 548\n//*               Another sleep routine using STIMERM.              *   FILE 548\n//*               Contrary to popular belief, it is impossible to   *   FILE 548\n//*               escape from the wait by trapping the attention    *   FILE 548\n//*               with a STAX. The attention exit gains control     *   FILE 548\n//*               after the wait time has expired.  This could be   *   FILE 548\n//*               done by using multiple TCB's and some tricky      *   FILE 548\n//*               logic.  But this is just too complicated.         *   FILE 548\n//*                                                                 *   FILE 548\n//*      RXWTO    Issue a message to the operator                   *   FILE 548\n//*                  y   = RXWTO('Your message')                    *   FILE 548\n//*                                                                 *   FILE 548\n//*      $ASMCL   JCL to build these functions                      *   FILE 548\n//*                                                                 *   FILE 548\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXSIQRY": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x04o\\x01\\x02\\x04o\\t\"\\x010\\x010\\x00\\x00\\xd5\\xc9\\xd2\\xd6\\xd3\\xe8\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-02-15T00:00:00", "modifydate": "2002-02-15T09:22:00", "lines": 304, "newlines": 304, "modlines": 0, "user": "NIKOLYN"}, "text": "RXSIQRY   TITLE 'Query PPRC Status with ANTRQST'\n*--------------------------------------------------------------------*\n* Program Name  : RXSIQRY\n*\n* Language      : Assembler\n* Attributes    : RENT REUS REFR AC(0)\n* AMODE         : 31\n* RMODE         : ANY\n*\n*--------------------------------------------------------------------*\n* Program Function\n*\n* External REXX function to query PPRC volumes.\n*\n* Invocation\n*\n*    rcode = rxsiqry(DevN)\n*\n*  Returns:\n*    SIMPLEX   DevN is SIMPLEX\n*    DUPLEX    DevN is part of a DUPLEX pair\n*    PENDING   DevN is PENDING\n*    SUSPEND   DevN is SUSPENDed\n*    ERROR     ANTRQRST or parameter error\n*\n*  Problems:\n*    Contact Alfred Nykolyn  apn@istar.ca\n*\n*--------------------------------------------------------------------*\n*\n*  ANTRQST PQUERY Data Area (See ANTP025I for layout)\n*\nPqueryD  dsect\nPdevN    ds   cl4                 * Device Number\n         ds   cl1\nPLevel   ds   cl9                 * Level  (PRIMARY/SECONDARY)\n         ds   cl1\nPState   ds   cl10                * Pair State\n*  Pair states are: SIMPLEX, DUPLEX, COPYING, SUSPENDED\n*\n         ds   cl1\nPathStat ds   cl8                 * Path Status (ACTIVE/INACTIVE)\n         ds   cl1\nPrSSID   ds   cl4                 * Primarry SSID\n         ds   cl1\nPrCCA    ds   cl2                 * Primary CCA\n         ds   cl1\nPSerial  ds   cl12                * Primary Serial #\n         ds   cl1\nSSSID    ds   cl4                 * Secondary SSID\n         ds   cl1\nSCCA     ds   cl2                 * Secondary CCA\n         ds   cl1\nSSerial  ds   cl12                * Secondary Serial #\nPqueryln equ  *-PqueryD\n\nrxsiqury csect\nrxsiqury amode 31\nrxsiqury rmode any\n         save  (14,12)\n         lr    r12,r15\n         using rxsiqury,r12\n\n         lr    r2,r1\n         using efpl,r2            * addr REXX func parms\n\n         la    r0,$antrqdln\n         getmain RU,lv=(0),loc=ANY\n\n         st    r1,forward(,r13)\n         st    r13,backward(,r1)\n         lr    r13,r1\n         using antrqd,r13\n\n         l     r3,efpleval        * addr of pointer to eval block\n         l     r3,0(,r3)          * REXX eval block addr\n         using evalblock,r3\n\n         l     r4,efplarg         * REXX arg list\n         using argtable_entry,r4  * address arg table\n\n         la    r0,l'error         * Assume the worst\n         st    r0,evalblock_evlen\n         mvc   evalblock_evdata(l'error),error\n         icm   r5,b'1111',argtable_argstring_ptr\n         bnp   badparm            * No args\n\n         icm   r6,b'1111',argtable_argstring_length\n         bnp   badparm            * No args\n\n         la    r0,4\n         cr    r6,r0\n         bh    badparm            * Max length 4\n\n         la    r0,3\n         cr    r6,r0\n         bl    badparm            * Min length 3\n\n         mvc   parms,0(r5)        * Save parms\n         tr    parms,trtab        * Translate a-fA-F to  x'FA...FF'\n         lr    r10,r6\n         la    r9,parms\n\ncheck_hex    equ  *\n         cli   0(r9),x'00'\n         be    badparm\n         la    r9,1(,r9)\n         bct   r10,check_hex\n\n         ex    r6,packit          * pack devc(3),parms(*-*)\n         drop  r2,r4\n*\n*  Build ANTRQST Parameters\n*\n         la    r0,l'qryinfo\n         sth   r0,qrylen\n*\n*  Issue ANTRQST QUERY\n*\n         antrqst ilk=PPRC,                                             +\n               request=PQUERY,                                         +\n               devn=devc,                                              +\n               qrysize=qrylen,                                         +\n               qryinfo=qryinfo,                                        +\n               retinfo=qretinfo,                                       +\n               mf=(E,antqpl)\n\n         ltr   r15,r15            * ANTRQST parm error?\n         bnz   antrq_parmerr\n\n         l     r15,rtc\n         l     r0,rsn\n         c     r15,qryok          * query field large enough?\n         bne   antrq_error\n\n         la    r11,qryinfo\n         using PqueryD,r11\n\n         mvc   evalblock_evdata(l'Pstate),Pstate\n         la    r10,l'Pstate\n         la    r9,Pstate\n         la    r8,Pstate\n         mvi   Pstate+l'Pstate,c' '    * End mark\n\nfind_blank     equ *\n         cli   0(r9),c' '         * Scan for 1st blank\n         be    found_blank\n         la    r9,1(,r9)\n         bct   r10,find_blank\n\nfound_blank    equ  *\n         sr    r9,r8              * State length\n         clc   Pstate(l'suspend),suspend\n         bne   *+4+4\n         la    r9,l'suspend\n         st    r9,evalblock_evlen\n\ndone     equ   *\n         la    r0,$antrqdln\n         lr    r11,r13\n         l     r13,backward(,r13)\n         freemain RU,lv=(0),a=(r11)\n\n         return (14,12),rc=0\n         drop   r11\n*\n*   Errors\n*\nbadparm  equ  *\n         wto   mf=(E,badpmsg)\n\n         b     done\n*\n*  ANTRQST Parameter Error\n*\nantrq_parmerr  equ  *\n         cvd   r15,wa             * R15 = rc\n         mvc   wtos(msg1ln),msg1\n         mvc   wtos+$i1(l'edmaskt),edmaskt\n         mvc   wtos+$i2(l'edmaskt),edmaskt\n         ed    wtos+$i1(l'edmaskt),wa+5\n\n         cvd   r0,wa              * R0 = rsn\n         ed    wtos+$i2(l'edmaskt),wa+5\n         wto   mf=(E,wtos)        * Message 1\n\n         b     done\n*\n*  ANTRQST Query     Error\n*\nantrq_qryerr   equ  *\n         cvd   r15,wa             * R15 = rc\n         mvc   wtos(msg2ln),msg2\n         mvc   wtos+$i1(l'edmaskt),edmaskt\n         mvc   wtos+$i2(l'edmaskt),edmaskt\n         ed    wtos+$i1(l'edmaskt),wa+5\n\n         cvd   r0,wa              * R0 = rsn\n         ed    wtos+$i2(l'edmaskt),wa+5\n         wto   mf=(E,wtos)        * Message 2\n\n         b     done\n*\n*  ANTRQST Other     Error\n*\nantrq_error    equ  *\n         c     r15,sdmerr         * SDM error 7240?\n         bne   antrq_qryerr       * Else other error\n\n         icm   r9,b'1111',antmsgl\n         srl   r9,24\n         ltr   r9,r9              * R9 = message length\n         bz    done\n\n         bctr  r9,0\n         mvc   wtos(msgaln),wtoant\n         la    r8,wtos+$i3\n         ex    r9,mvcant          * mvc 0(*-*,r8),antmsg\n         wto   mf=(E,wtos)\n\n         b     done\n*\n*   Constants\n*\n         ds    0d\nqryok    dc    al4(RQST_PQUERY_QRYSIZE_BIG_ENOUGH)\nsdmerr   dc    al4(RQST_PQUERY_ERROR)\n\npackit   pack  devc(3),parms(*-*)\nmvcant   mvc   0(*-*,r8),antmsg\nedmaskt  dc    x'402020202120'\n\nerror    dc    c'ERROR'\nsuspend  dc    c'SUSPEND'\n\n$i1      equ   28\n$i2      equ   39\n$i3      equ   8\n$i4      equ   4\n*                     1111111111222222222223333333334444444444555555555\n*               4567890123456789012345678901234567890123456789012345678\nmsg1     wto   'ANTRQST  Parm error: RC=012345 RSN=012345',            *\n               routcde=11,mf=L\nmsg1ln   equ   *-msg1\nmsg2     wto   'ANTRQST Query error: RC=012345 RSN=012345',            *\n               routcde=11,mf=L\nmsg2ln   equ   *-msg2\nwtoant   wto   'ANT0                                                   *\n                                                                     ',*\n               routcde=11,mf=L\nmsgaln   equ   *-wtoant\nbadpmsg  wto   'RXSIQRY Bad parameter',                                *\n               routcde=11,mf=L\n\n         ds    0d\ntrtab    dc    xl256'00'\n         org   trtab+x'81'\n         dc    x'fafbfcfdfeff'\n         org   trtab+c'A'\n         dc    x'fafbfcfdfeff'\n         org   trtab+c'0'\n         dc    c'0123456789'\n         org\n         eject\n         ds    0d\n         ltorg\n*\n*  ANTRQST Workarea and Parameter List\n*\nantrqd   dsect\nsavearea ds    18f\nforward  equ   8\nbackward equ   4\n\nwa       ds    d\nparms    ds    cl4\ndevc     ds    xl2\n         ds    xl2\n\nrtncd    ds    f\nrsncd    ds    f\nqrylen   ds    h\n         ds    0f\nqretinfo ds    cl100\n         org   qretinfo\nrtc      ds    f\nrsn      ds    f\nantmsgl  ds    xl1\nantmsg   ds    0x\n         org   qretinfo+l'qretinfo\n\n         antrqstl name=antqpl,base=0D\nqryinfo  ds    cl512\n         ds    0d\nwtos     ds    xl128\n$antrqdln  equ *-antrqd\n*\n*  REXX Interfaces\n*\n         irxefpl\n         irxevalb\n         irxargtb\n         yregs\n         end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXSLEEP": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x04o\\x01\\x02\\x04o\\t\"\\x00\\x93\\x00\\x93\\x00\\x00\\xd5\\xc9\\xd2\\xd6\\xd3\\xe8\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-02-15T00:00:00", "modifydate": "2002-02-15T09:22:00", "lines": 147, "newlines": 147, "modlines": 0, "user": "NIKOLYN"}, "text": "RXSLEEP  title 'REXX function to wait for a specified time'\n*--------------------------------------------------------------------*\n* Program Name  : RXSLEEP\n*\n* Language      : Assembler\n* LinkEdit Attr : RENT REUS REFR AC(0)\n* AMODE         : 31\n* RMODE         : ANY\n*\n*--------------------------------------------------------------------*\n* Program Function\n*\n* External REXX function to wait for a specified time.\n*\n* The program will wait for a specified amount of seconds. The number\n* of seconds to wait for is passed as a parameter to the function\n* by the invoking REXX Exec. If no parameter is passed, a default of\n* 10 seconds is used. The maximum is 999 seconds.\n* Contrary to popular belief, an attention exit cannot be used\n* to interrupt the wait. The exit gains control after the wait\n* has expired. It is possible to do something with multiple tasks\n* but that is much too complicated.\n*\n* Syntax\n*\n* rcode = sleep(secs)\n*\n* Keywords\n*\n* RCODE   The return code from sleep  :  0  Success\n*                                     : -1  Parameter error\n* SECS    The number of seconds to wait for (1 - 999)\n*\n* Problems:\n*  Contact Alfred Nykolyn  apn@istar.ca\n*\n*--------------------------------------------------------------------*\n$default equ    10*100                default wait time\nrxsleep  csect\nrxsleep  amode 31\nrxsleep  rmode any\n         save  (14,12)\n         lr    r12,r15\n         using rxsleep,r12\n\n         lr    r2,r1\n         using efpl,r2                addr REXX func parms\n\n         la    r0,$worklen\n         getmain RU,lv=(0),loc=ANY\n\n         st    r1,forward(,r13)\n         st    r13,backward(,r1)\n         lr    r13,r1\n         using workarea,r13\n\n         la    r0,$default            Set default wait time\n         st    r0,interval\n         l     r3,efpleval            addr of pointer to eval block\n         l     r3,0(,r3)              REXX eval block addr\n         using evalblock,r3\n\n         l     r4,efplarg             REXX arg list\n         using argtable_entry,r4      address arg table\n\n         icm   r5,b'1111',argtable_argstring_ptr\n         bnp   waitfor                any args?\n\n         icm   r6,b'1111',argtable_argstring_length\n         bnp   waitfor                If no parm, use default\n\n         la    r15,3\n         cr    r6,r15                 Larger than 999 seconds?\n         bh    parmerr                Yes - error\n\n         bctr  r6,0\n         mvc   packtime,zeros\n         ex    r6,valmvn              mvn packtime(*-*),0(r5)\n         ex    r6,valclc              clc packtime(*-*),0(r5)\n         bne   parmerr                Non-numeric argument\n\n         ex    r6,pack                pack packtime,0(*-*,r5)\n         la    r0,100\n         cvb   r9,packtime\n\n         mr    r8,r0                  x 100 for BINTVL\n         st    r9,interval            and store for STIMERM\n         drop  r2,r4\n\nwaitfor  equ   *\n         la    r9,interval\n         stimerm SET,wait=YES,        Wait for the specified time      +\n               bintvl=(r9),                                            +\n               id=(r9),               A convenient constant            +\n               mf=(E,stimerml)\n\n         la    r0,1\n         st    r0,evalblock_evlen     Return 0 (REXX function!!)\n         mvi   evalblock_evdata,c'0'\n\ndone     equ   *\n         lr    r11,r13\n         l     r13,backward(,r13)     R13 -> old savearea\n         la    r0,$worklen\n         freemain RU,lv=(0),a=(r11)\n\n         return (14,12),rc=0\n\nparmerr  equ   *\n         la    r0,2\n         st    r0,evalblock_evlen\n         mvc   evalblock_evdata(2),=c'-1'\n         b     done\n*\n*-------------------------------------------------------------------*\n* Execlted Instructions                                             *\n*-------------------------------------------------------------------*\n         ds    0d\nvalmvn   mvn   packtime(*-*),0(r5)\nvalclc   clc   packtime(*-*),0(r5)\npack     pack  packtime,0(*-*,r5)\n*\n*-------------------------------------------------------------------*\n* Constants, Variables and DSECTs                                   *\n*-------------------------------------------------------------------*\n         ds    0d\nzeros    dc    cl8'00000000'\n\n         ltorg\n\nworkarea dsect\nsavearea ds    18f                    Savearea\nforward  equ   8\nbackward equ   4\n\npacktime ds    d\ninterval ds    f                      Time interval\n\nstimerml stimerm SET,mf=L\n$worklen equ   *-workarea\n\n         irxefpl                      REXX mapping macros\n         irxevalb\n         irxargtb\n\n         yregs\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXV2DEV": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x04o\\x01\\x02\\x04o\\t\"\\x00\\xc6\\x00\\xc6\\x00\\x00\\xd5\\xc9\\xd2\\xd6\\xd3\\xe8\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-02-15T00:00:00", "modifydate": "2002-02-15T09:22:00", "lines": 198, "newlines": 198, "modlines": 0, "user": "NIKOLYN"}, "text": "         Title 'RXV2Dev - Return Device Number from VolSer'\n*\n*  This Rexx function returns the device number (DevN) that contains\n*  the specified VolSer.\n*\n*  Invocation (from Rexx):\n*    devn = RXV2Dev(volser)\n*\n*  where volser is a 6 character volume label\n*\n*  Returns:\n*     0  Everything OK\n*    -1  Parameter error\n*    -2  UCBScan error\n*    -3  VolSer not found\n*\n*  Attributes:\n*    Amode 31\n*    Rmode any\n*    Reentrant, Refreshable, Reusable, AC(0)\n*\n* Problems:\n*    Contact Alfred Nykolyn  apn@istar.ca\n*\nRXV2Dev  csect\nRXV2Dev  amode 31\nRXV2Dev  rmode any\nRXV2Dev  csect\n         save (14,12)\n         lr   r12,r15\n         using RXV2Dev,r12\n\n         la    r0,$vol2devln\n         lr    r10,r1\n         getmain RU,lv=(0),loc=ANY\n\n         st    r1,forward(,r13)\n         st    r13,backward(,r1)\n         lr    r13,r1\n         using vol2devd,r13\n*\n*   Get VolSer\n*\n         lr    r2,r10             * R2 -> EFPL\n         using efpl,r2\n\n         l     r3,efpleval\n         l     r3,0(,r3)          * R3 -> Evalblock\n         using evalblock,r3\n\n         l     r4,efplarg         * R4 -> arg list\n         using argtable_entry,r4\n\n         ltr   r4,r4              * Any parms?\n         bz    badparm\n\n         icm   r5,b'1111',argtable_argstring_ptr\n         bnp   badparm\n\n         la    r6,6\n         l     r7,argtable_argstring_length\n         cr    r7,r6              * Wrong length?\n         bne   badparm\n\n         mvc   VolSer,0(r5)       * Save VolSer\n         oc    VolSer,blanks      * To upper case\n         drop  r2,r4\n*\n*  Build UCBSCAN Parameters\n*\n         la    r9,ucbscnwk        * r9  -> UCBScan workarea\n         xc    ucbscnwk,ucbscnwk\n         la    r8,ucbarea         * r8  -> UCB area\n*\n*  Issue UCBSCAN\n*\n         ucbscan COPY,                                                 +\n               volser=VolSer,                                          +\n               workarea=(r9),                                          +\n               ucbarea=(r8),                                           +\n               range=ALL,                                              +\n               dynamic=YES,                                            +\n               devclass=DASD,                                          +\n               mf=(E,ucbscanl)\n\n         ltr   r10,r15\n         bnz   badscan            * OK?\n\n         lh    r0,4(,r8)          * r0 = DevN (Should use mapping)\n         sth   r0,devc\n         unpk  wa(5),devc(3)\n         tr    wa(4),hextab-c'0'\n         mvc   evalblock_evdata(4),wa       * Insert DevN\n         la    r0,4\n         st    r0,evalblock_evlen           * Save DevN length\n\ndone     equ   *\n         la    r0,$vol2devln\n         lr    r11,r13\n         l     r13,backward(,r13)\n         freemain RU,lv=(0),a=(r11)\n\n         return (14,12),rc=0\n*\n*   Errors\n*\nbadparm  equ  *\n         mvc   evalblock_evdata(2),=c'-1'\n         la    r0,2\n         st    r0,evalblock_evlen\n         wto   mf=(E,badpmsg)\n\n         b     done\n\nbadscan  equ   *\n         sll   r10,8\n         or    r10,r0             * R10 = RC+RSN\n         cl    r10,NotFound\n         bne   ucbscan_err\n\n         mvc   wtos(msg2ln),msg2\n         mvc   wtos+$i1(l'VolSer),VolSer\n         wto   mf=(E,wtos)\n\n         mvc   evalblock_evdata(2),=c'-3'\n         la    r0,2\n         st    r0,evalblock_evlen\n         b     done\n\nucbscan_err     equ  *\n         cvd   r15,wa             * R15 = RC\n         mvc   wtos(msg1ln),msg1\n         mvc   wtos+$i1(l'VolSer),VolSer\n         mvc   wtos+$i2(l'edmaskt),edmaskt\n         mvc   wtos+$i3(l'edmaskt),edmaskt\n         ed    wtos+$i2(l'edmaskt),wa+6\n\n         cvd   r0,wa              * R0 = rsn\n         ed    wtos+$i3(l'edmaskt),wa+6\n         wto   mf=(E,wtos)        * Message 1\n\n         mvc   evalblock_evdata(2),=c'-2'\n         la    r0,2\n         st    r0,evalblock_evlen\n         b     done\n*\n*   Constants\n*\n         ds    0d\nblanks   dc    cl8' '\nNotFound dc    al4(4*256+1)       * RC+RSN volser not found\nhextab   dc    c'0123456789abcdef'\nedmaskt  dc    x'40202120'\n\n$i1      equ   13\n$i2      equ   38\n$i3      equ   47\n*                     1111111111222222222223333333334444444444555555555\n*               4567890123456789012345678901234567890123456789012345678\nmsg1     wto   'RXV2Dev: 012345 UCBSCAN error: RC=0123 RSN=0123',      *\n               routcde=11,mf=L\nmsg1ln   equ   *-msg1\n\nmsg2     wto   'RXV2Dev: 012345 Volume not found!!',                   *\n               routcde=11,mf=L\nmsg2ln   equ   *-msg2\n\nbadpmsg  wto   'RXV2Dev: Invalid paramter',                            *\n               routcde=11,mf=L\n\n         ds    0d\n         ltorg\n*\n*  UCBSCAN Workarea and Parameter List\n*\nvol2devd dsect\nsavearea ds    18f\nforward  equ   8\nbackward equ   4\n\nwa       ds    d\nVolSer   ds    cl6\ndevc     ds    xl2\n         ds    0f\nucbarea  ds    xl48\nucbscnwk ds    xl100\n\n         ucbscan  mf=(L,ucbscanl,0D)\n\n         ds    0d\nwtos     ds    xl128\n$vol2devln     equ  *-vol2devd\n\n         irxefpl dsect=YES\n         irxevalb\n         irxargtb\n         yregs\n         end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXWTO": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x04o\\x01\\x02\\x04o\\t\"\\x00n\\x00n\\x00\\x00\\xd5\\xc9\\xd2\\xd6\\xd3\\xe8\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-02-15T00:00:00", "modifydate": "2002-02-15T09:22:00", "lines": 110, "newlines": 110, "modlines": 0, "user": "NIKOLYN"}, "text": "RXWTO    title 'REXX function to write a message to the console'\n*--------------------------------------------------------------------*\n* Program Name  : RXWTO\n*\n* Language      : Assembler\n* LinkEdit Attr : RENT REUS REFR AC(0)\n* AMODE         : 31\n* RMODE         : ANY\n*\n*--------------------------------------------------------------------*\n* Program Function\n*\n* External REXX function to write a message on the console\n*\n* Syntax\n*\n* y = rxwto('Your message')\n*\n* Problems\n*  Contact Alfred Nykolyn  apn@istar.ca\n*\n*--------------------------------------------------------------------*\n*\nrxwto    csect\nrxwto    amode 31\nrxwto    rmode any\n         save  (14,12)\n         lr    r12,r15\n         using rxwto,r12\n\n         lr    r2,r1\n         using efpl,r2                addr REXX func parms\n\n         la    r0,$worklen\n         getmain RU,lv=(0),loc=ANY\n\n         st    r1,forward(,r13)\n         st    r13,backward(,r1)\n         lr    r13,r1\n         using workarea,r13\n\n         l     r3,efpleval            addr of pointer to eval block\n         l     r3,0(,r3)              REXX eval block addr\n         using evalblock,r3\n\n         l     r4,efplarg             REXX arg list\n         using argtable_entry,r4      address arg table\n\n         icm   r5,b'1111',argtable_argstring_ptr\n         bnp   done                   no args\n\n         icm   r6,b'1111',argtable_argstring_length\n         bnp   done\n\n         la    r15,125\n         cr    r6,r15                 longer than 125?\n         bnh   *+4+2\n         lr    r6,r15                 truncate\n         sth   r6,messageln           save length\n         bctr  r6,0\n         ex    r6,movemsg             mvc message(*-*),0(r5)\n         la    r7,messageln\n         mvc   wtom($wtoplen),wtop\n         xr    r0,r0\n         wto   text=(r7),mf=(E,wtom)\n\ndone     equ   *\n         la    r0,1\n         st    r0,evalblock_evlen     Return 0 (REXX function!!)\n         mvi   evalblock_evdata,c'0'\n         lr    r11,r13\n         l     r13,backward(,r13)     R13 -> old savearea\n         la    r0,$worklen\n         freemain RU,lv=(0),a=(r11)\n\n         return (14,12),rc=0\n*\n*-------------------------------------------------------------------*\n* Executed Instructions                                             *\n*-------------------------------------------------------------------*\n         ds    0d\nmovemsg  mvc   message(*-*),0(r5)\n*\n*-------------------------------------------------------------------*\n* Constants, Variables and DSECTs                                   *\n*-------------------------------------------------------------------*\n         ds    0d\nnoresult dc    x'80000000'\n\nwtop     wto   text=,routcde=(2),desc=(6),mf=L\n$wtoplen equ   *-wtop\n\n         ltorg\n\nworkarea dsect\nsavearea ds    18f                    Savearea\nforward  equ   8\nbackward equ   4\n\nwtom       ds    xl($wtoplen)\nmessageln  ds    h\nmessage    ds    cl125                Message\n$worklen   equ   *-workarea\n\n         irxefpl                      REXX mapping macros\n         irxevalb\n         irxargtb\n\n         yregs\n         end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT548/FILE548.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT548", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}