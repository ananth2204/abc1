{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011438000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 6172530, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 28, "INMDSNAM": "CBT.V500.FILE183.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 6172530, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 6172530, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE183.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00a\\x0e'", "DS1TRBAL": "b'\\x0c\\x9e'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01h\\x00\\x07\\x01n\\x00\\x0e\\x00b'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$$NOTE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x16\\x01\\x11)_\\x01\\x12%\\x7f\\x100\\x00\\x10\\x00\\n\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2011-10-22T00:00:00", "modifydate": "2012-09-13T10:30:16", "lines": 16, "newlines": 10, "modlines": 0, "user": "SBGOLOB"}, "text": "Gilbert Saint-flour has unfortunately passed on.  His \"for sale\"\nvendor products are being managed by a group of his friends for\nthe benefit of his family.  His free products (for example his\nstuff on this file (File 183) of the CBT Tape collection) are being\nmanaged by Sam Golob (sbgolob@cbttape.org or sbgolob@att.net).\n\nInquiries should now be directed to Sam Golob.\n\n   email:  sbgolob@cbttape.org   or   sbgolob@att.net\n\nInquiries for Gilbert's \"pay\" products should be directed to:\n\n   www.gsf-soft.com     (Carlos Aguilera, Sr.)\n\n   email:  carlos@gsf-soft.com\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$#DATE": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x004\\x01 5\\x0f\\x01 5\\x0f\\x14F\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-12-15T00:00:00", "modifydate": "2020-12-15T14:46:34", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-500"}, "text": "REGULAR CBT TAPE - VERSION 500    FILE:  183\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT500.FILE183\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 139 MEMBERS COUNTED; CUMULATIVE SIZE IS 57,534 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   12/15/20    14:46:33    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$COGSF": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00'\\x00\\x89\\x19_\\x01\\x12%o#C\\x00#\\x00\\x1e\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1989-07-14T00:00:00", "modifydate": "2012-09-12T23:43:27", "lines": 35, "newlines": 30, "modlines": 0, "user": "SBGOLOB"}, "text": "\n                         COPYRIGHT\n\n     These programs are Freeware and may be freely copied.\n     They may be freely distributed to any other party on condition\n     that no inducement beyond reasonable handling costs is offered\n     or accepted by either side for such distribution.\n\n                         DISCLAIMER\n\n     Gilbert Saint-Flour neither expresses nor implies any warranty\n     as to the fitness of these computer programs for any function.\n     The use of these programs or the results therefrom is entirely\n     at the risk of the user.  Consequently, the user may modify\n     these programs in any way he/she thinks fit.\n\n                     CONTACT INFORMATION\n\n     Unfortunately, Gilbert has passed on.\n\n     Gilbert's free sofware work is being continued by Sam Golob.\n     Gilbert's \"pay\" software is being managed by a group of his\n       friends.  www.gsf-soft.com.   (Carlos Aguilera, Sr)\n\n     We would be interested to hear of comments and/or proposed\n     enhancements.  Please e-Mail to Sam Golob  at:\n\n              Sam Golob <sbgolob@cbttape.org>\n\n        or    Carlos Aguilera <carlos@gsf-soft.com>\n\n     or visit the Web Site at http://gsf-soft.com/Freeware\n\n     For Gilbert's \"pay\" products, visit http://gsf-soft.com\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$INDEX": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x04Q\\x00'\\x00\\x885\\x0f\\x01\\x143o\\x12P\\x03\\t\\x00\\x00\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "04.81", "flags": 0, "createdate": "1988-12-15T00:00:00", "modifydate": "2014-12-02T12:50:27", "lines": 777, "newlines": 0, "modlines": 0, "user": "SBGOLOB"}, "text": "\n                .--------------------------------.\n                |  CBT TAPE - Index of file 183  |\n                '--------------------------------'\n\n                   http://gsf-soft.com/Freeware\n\n     ----------------- TSO and ISPF commands -------------------\n\n     ADDTRK    The ADDTRK EDIT macro (written in REXX) that\n               invokes PDS86 to add a new extent to the PDS\n               being edited.\n\n     BR        TSO command - Browse most data sets under\n               ISPF/PDF, using BRIF.  Supports VSAM, BDAM,\n               multi-volume, RECFM=VBS, BLKSIZE=0, etc.\n\n               To use it, just enter BR instead of B on the\n               Data Set List utility screen.  BR has its own\n               point-and-shoot capability and can grab a dsname\n               on the screen, wherever the cursor is located.\n\n     CLS       A 5-line \"clear screen\" command for TSO\n\n     COMPRCMD  TSO Command Processor written in Assembler\n\n               Compress a PDS with DISP=SHR using standard ISPF\n               and LINK-EDIT protection.  Uses the TSO/E service\n               routine to invoke IEBCOPY and, therefore, does not\n               require any authorization of its own.  Accepts\n               generic dsnames (such as GSFSOFT.*) and offers a\n               few other options.\n\n     COMPRESS  The COMPRESS EDIT macro (written in REXX) that\n               allows you to compress the PDS you're editing\n               just by typing \"COMPRESS\" on the command line.\n\n     CONCAT    A REXX exec to add a data set to a concatenation.\n\n     CUT       REXX EDIT Macro - CUT & PASTE package\n     PASTE     REXX EDIT Macro - CUT & PASTE package\n     CUTPGM    Assembler program used in CUT & PASTE.\n     CUTHLP1   Help screen for CUT\n     CUTHLP2   Help screen for PASTE\n\n               My own version of a classic.\n               Requires MVS/ESA 4.2.2 or above.\n               Uses data spaces, name/token pairs and compression.\n               Supports multiple clip-boards and the APPEND option.\n\n     DAHANDBK  Program which converts assembly listings of mapping\n               macros into a handy handbook that displays field\n               displacements and their meanings in a readable way.\n\n     DAHANDJ   A sample jobstream to create a handbook from assembly\n               listings, for any macros you want to include.\n\n     DSLIST    REXX exec - Point-and-shoot Dataset List Utility\n\n               This REXX program allows you to invoke the data\n               set list function of ISPF/PDF (option 3.4) with\n               the DSNAME LEVEL field preset to the data set name\n               under which the cursor is currently positionned.\n\n               DSLIST may be invoked from any ISPF screen simply\n               by typing:\n\n                  TSO %DSLIST\n\n               on the command line, then by moving the cursor\n               under a data set name on your screen and pressing\n               \"enter\".  You may also define it as a command in\n               the ISPF command table, or set it up as a PFK.\n\n     DSNLIST   TSO command - returns in &var the dsnames\n                             allocated to &ddn\n               Example:\n\n                 ALLOC DD(SYSPROC) SHR -\n                       DS('IPO1.CMDPROC' 'GSFSOFT.CLIST')\n                 DSNLIST DDNAME(SYSPROC) SETVAR(VAR2)\n\n                 is equivalent to:\n\n                 SET VAR2 = 'IPO1.CMDPROC' 'GSFSOFT.CLIST'\n\n     EXECPGM   TSO command - invoke a utility program or compiler\n               with an alternate ddname list, as follows:\n                  EXECPGM IEV90           +\n                    PARM(NOOBJECT,NODECK,NOXREF,NORLD) +\n                    SYSIN(TEMPWK2)        +\n                    SYSUT1(TEMPWK1)       +\n                    SYSLIB(ASMLIB)        +\n                    SYSPRINT(ASMH$PRT)    +\n                    STEPLIB(LINKLIST)\n\n     EXECUTE   REXX EXEC - Run an in-stream EXEC or CLIST in a TSO\n               batch job, or execute EDIT data as a CLIST or EXEC.\n\n     FASTPATH  This assembler program allows the use of fast-path\n               commands without requiring customization of the\n               ISPF environment.\n               Fastpath provides two types of functions:\n\n               1. Initialization\n                 a. add 20 fast-path commands to the user's\n                    in-storage copy of ISPCMDS\n                 b. pre-load specific modules to enhance\n                    performance and allow access from a private\n                    LOAD library\n                 c. issue STIMER to prevent S522 time-out abends\n               2. Processing\n                 a. invoke EDIT, BROWSE, VIEW, WorkPlace and SDSF\n                    with the appropriate NEWAPPL parameter\n                 b. store and retrieve parameters associated\n                    with user-specified tags\n                 c. retrieve a dsname under which the cursor\n                    is positionned and invoke EDIT, BROWSE,\n                    VIEW or the Workplace\n                 d. Edit your ISPCTLn or SPFTEMPn.CNTL data set\n                 e. View a member in SYS1.MACLIB or SYS1.MODGEN\n                 f. TSO Full-screen\n                 g. misc others\n\n     FASTNOTE  Note from Sam Golob about invoking FASTPATH\n\n     FASTPDOC  Documentation for the FASTPATH utility\n               http://gsf-soft.com/Freeware/FASTPATH.shtml\n\n     FASTP149  Previous version of FASTPATH utility\n\n     FILE183   CLIST to provide an easy access to REXX execs and\n               programs distributed in this library\n               http://gsf-soft.com/Freeware/FILE183.shtml\n\n     FREEDIR   The FREEDIR EDIT macro (written in REXX) invokes\n               PDS86 to add or delete directory blocks to change\n               the size of the directory of the PDS being edited.\n\n     FSHELP    REXX EXEC - Full-screen TSO HELP which uses STEMVIEW\n               to display the output produced by the TSO HELP cmd.\n\n     FULLDSN   REXX Function - return the real dsname of an alias\n               or the fully-qualified dsname from a relative\n               generation.\n\n     FTP       REXX EDIT Macro - Transmit the data being edited\n               using text-mode FTP\n\n     IKJEFLN2  TSO/E Logon Exit - enable the Reconnect option\n               in the TN3270 environment.\n\n     INITKSDS  Initialize a KSDS after it's been DEFINE'd\n\n               This program prevents OPEN from failing when\n               opening with MACRF=(IN,OUT) or STRNO=2 a KSDS\n               that has just been defined.  Can be invoked as\n               a batch program, a TSO command, or a sub-routine.\n\n     IPADDR    REXX exec - retrieve the IP address associated with\n               a VTAM terminal using NETSTAT TELNET.\n\n     IRXEHCIR  Interface to IKJEHCIR for REXX and COBOL\n\n               This small assembler program allows a REXX EXEC\n               or a COBOL program to invoke IKJEHCIR, the TSO/E\n               Catalog Information Routine.\n\n     ISPTASK   Program - prevent S522 abends while in ISPF\n\n               Just link it into your ISPLLIB or STEPLIB, then\n               re-enter ISPF, and you won't time out any more.\n\n               Also preloads some ISRxxxx modules for\n               performance, even if they're in PLPA (YES,\n               in ESA 4.3, you can pre-load PLPA modules!!)\n\n     ISREDIT2  Program - speed up EDIT macros\n\n               Executed once at the beginning of an EDIT macro.\n\n     LC        REXX EXEC - Full-screen IDCAMS LISTCAT\n\n               This TSO/ISPF REXX EXEC invokes IDCAMS then\n               invokes STEMVIEW to display the output.\n\n               To use it, just enter LC as a line command on the\n               Data Set List (3.4) or the WorkPlace (11) Utility\n               screens\n\n     LCAT      TSO command - Full-screen IDCAMS LISTCAT\n\n               This TSO/ISPF command invokes IDCAMS then\n               uses BRIF to display the output.\n\n               To use it, just enter LCAT as a line command\n               on the Data Set List Utility screen.\n\n     LCAT92    TSO command - Full-screen IDCAMS LISTCAT\n               1992 version of LCAT for OS/390 R2 and older\n\n     LLIBDEF1  Prevent some S806-4 abends when using LIBDEF with\n               ISPLLIB\n\n               This program allows you to pre-load a REUS or\n               RENT module from a LOAD library defined via\n               LIBDEF.  This can prevent S806-4 abends that\n               occur when a program that is not LIBDEF-aware\n               tries to access another program via LOAD or LINK.\n\n     LISTDSI   REXX EXEC - Display output of LISTDSI function\n\n               This EXEC helps the REXX programmer implement\n               the LISTDSI function by displaying the value of\n               all of the variables returned by LISTDSI for the\n               specified data set, as well as providing the\n               syntax, return codes and reason codes in the\n               form of comments at the end of the source.\n\n     LOCKTERM  TSO command written in assembler.\n               Lock TSO terminal, enter LOGON password to unlock.\n\n     LPA24     REXX EXEC - Display PLPA usage below the 16MB line\n\n     LPR       REXX EDIT Macro - Print the data being edited\n               using TCP/IP's LPR command\n\n     LVL       REXX EDIT macro - Compress Level Numbers for\n               FB-80 PDS members with STATS ON and NUMBER STD.\n\n               LVL reuses \"gas levels\", i.e. levels which\n               are not used in any record in the member,\n               and adjusts pos 79-80 of the records accordingly.\n\n               If the macro invocation includes a number,\n               then levels up to the specified number are\n               reset to zero.\n\n     NEWAPPL   REXX EXEC - Start a new ISPF application using\n               LIBDEF and ALTLIB.\n\n     OBEYFILE  EDIT Macro written in REXX - Allows the TCP/IP\n               administrator to use the data being edited as\n               input to the TCP/IP OBEYFILE command without\n               having to SAVE it.\n\n     RESET5    Initial EDIT macro that issues a \"RESET\" command\n\n               Type \"IMACRO !RESET\" once, and you won't be\n               bothered by these annoying messages anymore.\n\n     REXXTRY   TSO command processor written in assembler.\n\n               REXXTRY can be used in a CLIST or in ISPF to\n               execute a one-line REXX exec as a sub-routine.\n               The REXX exec can be a single REXX instruction or\n               multiple instructions separated by semi-colons.\n\n               REXXTRY can also be invoked in batch mode, in which\n               case the REXX code is not specified as an argument\n               to the command, but consists on all the input lines\n               present after the REXXTRY command in SYSTSIN.\n\n     ROUTE     REXX EDIT Macro - Print the data being edited.\n     ROUTEPGM  Assembler program used in ROUTE to speed things up\n     ROUTEHLP  Help screen\n\n               This edit macro writes the data you're editing to\n               a SYSOUT data set, with the CLASS and DEST you\n               specify, a title line and 60 lines per page.\n               Works with EDIF because what gets printed is the\n               data being edited, NOT the data stored on disk.\n\n     RXSMS     Assembler program; can be invoked in a REXX exec\n               to retrieve information from the SMS sub-system\n               or from a volume's VTOC.\n\n     SFE       REXX program to invoke the Search-For Extended\n               utility.  Can be invoked from the Data Set List\n               panel or as an EDIT macro.\n\n     SHOWDASD  ISPF Dialog to display on-line DASD devices.\n     SHOWDPNL  Requires the RXSMS program.\n     SHOWVTOC  Panel for option V\n\n     SHOWJPAQ  TSO command - Display contents of Job Pack Area Queue (JPAQ)\n\n     SHOWTIOT  REXX exec - Display contents of Task Input-Output Table (TIOT)\n\n     STEMEDIT  REXX sub-routine written in assembler.\n               Browse, View or Edit stem variables using BRIF,\n               VIIF or EDIF.  A nice addition to OUTTRAP.\n               View data from the stack also. ISPF V5 only.\n\n     STEMVIEW  REXX sub-routine written in assembler.\n               Browse or View stem variables using BRIF or EDIF.\n               View data from the stack also. ISPF V2, V3, V4.\n\n     SWAREQ    REXX exec - Convert an SVA to a 31-bit address\n\n     TALLY     REXX exec for ISPF 3.4 - Display the total number of\n               tracks used up by the data sets on the DSLIST panel.\n\n     TLMS      Display a VMF record under PDF 3.4\n\n               This program reads the VMF record for the\n               first volume of a tape data set, formats it\n               pretty much like the CATLTSO command, then\n               invokes BRIF to display the result.  May only\n               be used as a line command on the Data Set\n               List panel (Option 3.4 of ISPF/PDF).\n\n     TMS       Display a TMC record under PDF 3.4\n               Same as TLMS, but for CA1/TMS 5.0\n\n     VALLOC    Generate ALLOCATE commands for data set list\n\n               EDIT macro written in REXX.  Reads a list of data\n               set names starting in pos 1 of each line and\n               generates a set of corresponding ALLOCATE commands.\n\n     VARS      TSO/ISPF command written in REXX.\n               Display in-storage ISPF vars.\n\n     VDL       TSO/ISPF command written in REXX.  VIEW Data set\n               List: makes the list of data set created by DSLIST\n               available as data in a VIEW session.\n\n     VML       TSO/ISPF command - Read the directory of the\n               specified PDS and VIEW the Member List\n\n     VSAMVIEW  TSO/ISPF command - View a VSAM data set using VIIF\n\n     VSAMVW95  1995 version of VSAMVIEW for ISPF V2, V3 and V4.\n\n     VSAVE     ISPF EDIT macro - Save a member in VIEW mode\n\n     WHEREIS   REXX EXEC - Look for all occurences of a member in\n               the libraries currently allocated to your TSO\n               session.  If multiple versions of the member are\n               present in a concatenation, they are all shown,\n               along with their ISPF stats, when present.\n\n     WHOAMI    REXX EXEC - Displays the user-ID and system-ID\n               in large letters, plus a few other things\n\n     WP        REXX exec - Invoke the Work-place from DSLIST.\n\n     XDELETE   REXX exec - Delete data sets \"en masse\" using a\n               generic filter such as \"ABC*.D%.**.E%F*GH.*.TEMP\".\n\n     XRENAME   REXX exec - Rename data sets \"en masse\"\n\n     XDEL      REXX EDIT macro - Delete current member\n\n     XREN      REXX EDIT macro - Rename current member\n\n     ------------------ Batch Programs --------------------------\n\n     BLKSIZE2  Scan a PDS and print the size of each block and\n               the track balance\n\n               This is a batch program, for people interested\n               in what a PDS looks like, from the inside.\n\n     BYPASSNQ  Assembler program.  Scratch or Rename a Data Set\n               without SYSDSN ENQ\n\n               BYPASSNQ is a driver that allows you to run any\n               utility program (such as IEHPROGM or IDCAMS) and\n               bypass dsname ENQ that is normally performed by\n               the DYNALLOC, SCRATCH and RENAME SVCs.\n               This technique allows data sets to be deleted or\n               renamed using standard MVS services and is fully\n               compatible with indexed VTOCs and SMS.\n\n     CANMSGCL  Purge current job's held output after a few hours.\n               Useful for those jobs that work OK 99% of the time\n               (must be authorized)\n\n               Example:\n\n                 //MYJOB    JOB ACCT#,CLASS=A,MSGCLASS=H\n                 //COPY1   EXEC PGM=IEBCOPY\n                 //...      DD   ...\n                 //CONDPURG EXEC PGM=CANMSGCL,PARM=2,\n                 //              COND=(0,NE,COPY1)\n\n                 The number in the parm is a number of hours.\n                 If the 'COPY1' step ends at 10:28 with a\n                 return code equal to zero, the 'CONDPURG' step\n                 executes and issues the following command:\n\n                   $TA,T=12.28,'$OJ01234,Q=X,CANCEL'\n\n     COB2JOB   Retrieve Job-related information in COBOL\n\n     COB2SYS   Retrieve System-related information in COBOL\n\n     COB2TSO   Issue TSO commands in COBOL\n\n     CLEANUP   Assembler program.  Automatically searches the MVS\n               catalog for non-GDG data sets that will be created\n               in subsequent steps of your job and deletes them.\n               HSM-migrated data sets are deleted with HDELETE.\n\n                     //MYJOB   JOB  acct#\n                     //*\n                     //CLEANUP EXEC PGM=CLEANUP\n                     //*\n                     //STEP1   EXEC PGM=MYPROG1\n                     //OUTDD    DD  DSN=MY.FILE1,DISP=(,CATLG)\n                     //STEP2   EXEC PGM=MYPROG2\n                     //OUTDD    DD  DSN=MY.FILE2,DISP=(,CATLG)\n\n               Can also be executed as the LAST step of a job to\n               delete non-GDG data sets that were created during\n               job execution.\n\n     CMDJ      Send a JES2 command with the current job's number\n               (must be authorized)\n\n               Example:\n\n                  //PURGEJOB EXEC PGM=CMDJES2,PARM=P\n\n               If the current job's number is JOB01234,\n               then the following command is issued:\n\n                     $PJ  01234\n\n     DCODADDR  Assembler module to convert an address passed by\n               its invoker into a character string that indicates\n               what module, CSECT within the module, and offset\n               within the CSECT the address points to.\n                 DCODADDR uses the Binder API and can be invoked\n               by recovery routines or any other modules.\n\n     DONTFAIL  Prevent job failure caused by uncataloged data\n               sets (ESA only, must be authorized)\n\n     GSFLKED   Front-end to the linkage editor to recover\n               from SD37 on SYSLMOD (must be authorized)\n\n               This program may be invoked instead of the DFP\n               linkage editor. It calls the linkage editor and,\n               if an SD37 abend occurs, calls IEBCOPY to compress\n               the SYSLMOD PDS, then calls the linkage editor\n               again.\n\n               Another feature of this program is to\n               conditionally append a PDS member to SYSLIN, if\n               that member exists.\n\n     ISGECMON  Assemble and Link Job for SYS1.SAMPLIB(ISGECMON)\n\n               The ISGECMON program runs as a never ending task\n               that checks dataset contention at periodic\n               intervals and sends messages to TSO users asking\n               them to free datasets that are causing contention.\n\n     JOBRLSE   Release a job by number (must be authorized)\n\n               This program issues a $A command to release a job\n               previously submitted to JES2 with \"TYPRUN=HOLD\".\n\n               To prevent \"multiple jobs found\" conditions,\n               this program uses the sub-system interface\n               to inquire about the status of homonym jobs.\n               Then, it issues a $A command with the job\n               number of the first job found in the input\n               queue in held status (for example: $A J1234).\n\n               Sample execution JCL:\n\n                 //RLSENEXT EXEC PGM=JOBRLSE,PARM=PAYROL22\n\n     LINKLLA   Link-edit and refresh LLA in a single step\n               (MVS/ESA only, must be authorized)\n\n               Invokes the linkage-editor, then issues LLACOPY\n               for the member specified on the //SYSLMOD DD.\n               If there is no //SYSLIN DD in the step's JCL,\n               issues LLACOPY for the member on //SYSLMOD,\n               or for all of the members in the //SYSLMOD\n               library if no member name has been specified.\n\n     LOADMLPA  Load a reentrant module into the MLPA\n               (must be authorized)\n\n               This program allows you to load a RENT module\n               from an authorized library into the MLPA.\n               Also supports the DELETE function to undo\n               LOAD.  Invoker must have update authority to\n               SYS1.PARMLIB.\n\n               This program has been designed to prevent jobs\n               that accept multiple inputs from failing in the\n               middle of the night because of a \"typo\" in a data\n               set name.  When DONTFAIL detects that an input\n               data set is not cataloged, it converts it to a\n               null data set and allows the job to run with\n               partial input.\n\n     PACKOFF   Unpack a file packed by ISPF/PDF or XEDIT\n\n               This is a sample program that reads\n               fixed-length records and unpacks them.\n\n     PLI2JOB   Retrieve Job-related information in PL/I\n\n     PLI2TSO   Issue TSO commands in PL/I\n\n     RECALL    Batch program - Issues HRECALL commands for every\n               migrated data sets used in subsequent steps of the\n               JOB in which it is executed.  Pre-staging data\n               sets in this manner reduces HSM tape mount\n               activity.\n\n     SCANMODL  This assembler module loads a control-block map\n               from SYS1.MIGLIB and returns the offset & length\n               of a field.  It is used to write programs that\n               access JES2 control blocks without using HASPSRC\n               and consequently, are release-independent.\n\n     SVCUPDTE  Install a type-3 SVC routine (must be authorized)\n\n               This program installs an SVC routine from PLPA,\n               MLPA, or from an authorized library.\n               The installation can be permanent or temporary.\n               If the installation is temporary, SVCUPDTE waits\n               until a STOP or CANCEL command is issued, then\n               restores the old SVC entry and terminates.\n\n               PARM=(nnn,mmmmmmm,hhmm,userid)\n\n                 nnn is the SVC number you want to install;\n                 you must specify a 3-digit number\n\n                 mmmmmmmm is the name of a load module (or alias)\n                 that you want to install as SVC nnn;  it MUST\n                 come from an authorized library (STEPLIB or\n                 link-list)\n\n                 hhmm is the optional automatic shut-down time,\n                 in 24-hour clock format.  When the specified\n                 time is reached, SVCUPDTE automatically stops.\n\n                 userid is the optional userid that will be given\n                 access to the new SVC.  Jobs submitted by other\n                 users will keep on using the old SVC.\n\n     SYSMOVE   Unload a PDS to a sequential data set in\n               IEHMOVE format.  Compatible with SMS.\n\n     UNITAFF   Dynamically sets UNIT=AFF for input tape files\n               (must be authorized)\n\n               This program was originally designed to reduce\n               the number of tape drives used by user-submitted\n               SAS steps.  It scans the SWA for the next step\n               and changes some of the SIOT's fields to force\n               all input tape data sets to the same drive.\n\n               It must be executed immediately before the\n               step to process (SAS, SORT, or any other\n               program that reads a variable number of tape\n               files, one at a time).\n\n               Sample jcl:\n\n                 //UNITAFF EXEC PGM=UNITAFF\n                 //STEPLIB  DD  DSN=SYS2.AUTHLIB,DISP=SHR\n                 //*\n                 //STEP53  EXEC PGM=SAS\n                 //OSIN     DD DSN=USER1.X,DISP=SHR\n                 //         DD DSN=UPQE.DQE40530(-1),DISP=SHR\n                 //OSIN2    DD DSN=UPQR.DQR02150(0),DISP=SHR\n                 //OSIN3    DD DSN=USER1.X,DISP=SHR\n                 //         DD DSN=UPBG.DBGA0240(-1),DISP=SHR\n                 //OSIN4    DD DSN=USER1.X,DISP=SHR\n                 //         DD DSN=USER1.YY,DISP=SHR\n                 //         DD DSN=UPQR.DQR02140(-1),DISP=SHR\n\n               The program only supports cataloged data sets;\n               relative generation numbers are handled\n               correctly via the GDGNT.\n\n               Restriction: No distinction is made between 3420,\n               3480 or 3490 device types; this will cause\n               problems if the input to a step is mixed.\n\n\n     ------------------ Assembler Macros ------------------------\n\n     BUILDCDE  Make storage allocated with GETMAIN appear as a\n               load-module in a dump.\n\n               BUILDCDE uses the \"loader\" form of IDENTIFY to\n               create a major CDE and corresponding XL, then\n               issues a LOAD SVC to create an LLE and associate\n               the CDE with the current TCB.  Don't worry, you\n               don't have to understand how it works to use it.\n\n               EXAMPLE:\n\n                     GETMAIN RU,LV=20000\n                     BUILDCDE LENGTH=(0),ADDR=(1),EP=DYNAM20\n\n               The 20K storage area will appear in a dump\n               as a load-module called \"DYNAM20\".\n\n     EASYSORT  Invoke an internal SORT with OPEN/PUT/GET logic\n\n               Allows you to do internal sorts without any\n               knowledge of parameter lists or exit routine\n               linkage conventions.\n\n               Example:\n\n                         EASYSORT OPEN,\n                               FIELDS=(1,22,CH,A),\n                               TYPE=F,LENGTH=64,\n                               OPTION='EQUALS,RESINV=500K'\n                         .     .\n                 READ    GET   FILEIN\n                         EASYSORT PUT,(1)   pass record to SORT\n                         B     READ\n                         .     .\n                 REWRITE EASYSORT GET,      get sorted record\n                               SET=(R3),\n                               EODAD=ENDSORT\n                         PUT   FILEOUT,(R3)\n                         B     REWRITE\n                         .     .\n                 ENDSORT EASYSORT CLOSE\n\n     GETDIR    Read a directory sequentially with a BPAM DCB\n\n               This macro offers a simple way to read directory\n               entries and members with a single BPAM DCB.\n\n     GETPUT31  Issue GET, PUT or PUTX while in AMODE31\n\n               This member contains GET31, PUT31 and PUTX31,\n               which are modified versions of GET, PUT and\n               PUTX.  They allow a program running with\n               RMODE24 and AMODE31 to issue QSAM GET, PUT and\n               PUTX without having to switch to AMODE24.\n               GET31 allows specification of an end-of-file\n               routine (EODAD).\n\n     STRING    Provides functions similar to PL/I's\n               PUT EDIT or COBOL's STRING.\n\n               This is the only non-IBM macro you need to\n               assemble the programs in this file.\n\n               This member contains the macro, a test job,\n               and the documentation.\n\n\n     ---------------------- Miscellaneous -----------------------\n\n     DEFGDGSR  Sub-routine - invokes SVC 26 to define a GDG base\n\n               May be invoked from a COBOL program, like this:\n\n                     05  DSNAME   PIC X(44) VALUE 'MY.DSNAME'.\n                     05  GDGLIMIT PIC   999 VALUE 027.\n\n                         CALL 'DEFGDGSR' USING DSNAME,\n                                               GDGLIMIT.\n\n     FILLDASD  Asm pgm to fill free DASD space with binary zeroes\n\n     HANDBOOK  Job - Creates an on-line copy of the DATA AREAS\n               (aka Debugging Handbook) manuals\n\n               This job assembles macros from SYS1.MACLIB and\n               SYS1.MODGEN and stores the assembly listings\n               into PDS members.  It is set up for over 60\n               commonly used MVS control blocks (such as CVT,\n               TCB, JFCB, etc) and may be easily modified to\n               support other ones.\n\n               The assembly listing for each macro is stored\n               into the output PDS under the control block\n               name.  For example, the assembly listing for\n               \"IKJTCB\" is stored into the \"TCB\" member.\n\n               To conserve dasd space, the LMCOPY service of\n               ISPF/PDF is used to pack the output of the\n               assembler.\n\n     IEC149I   MPF Exit.  Display the dsname from the HDR1 label\n               after a 813-04 or 237-08 abend.\n\n     SYSDEBUG  General Purpose ESTAE Routine.  Simplifies abend\n               resolution by formatting and writing out important\n               MVS control blocks in an easy-to-read fashion.\n\n     TCTDCTR   Sub-routine - Prints the EXCP count for each DD\n               in the job step\n\n               May be invoked at the end of a program for\n               debugging or tuning purposes.\n\n     TRIMMAC   Job - Creates a reduced-size MACLIB that may be\n               used instead of the SYS1.MACLIB/SYS1.MODGEN\n               concatenation to improve the performance of the\n               assembler.\n\n               The \"TRIMMAC\" library is built as follows:\n\n               1. selected macros are read from ddname \"SYSLIB\",\n                  trimmed from PL/AS code and other comment\n                  lines, then written to a temporary data set.\n\n               2. the SORT utility is invoked to sort the macros\n                  in ascending sequence of their size.\n\n               3. the sorted macros are written to SYSPUNCH\n                  as an IEBUPDTE sysin stream.\n\n               4. IEBUPDTE is executed in the last step to\n                  load the macros into the \"TRIMMAC\" library,\n                  the smallest macros being loaded first.\n\n               You may customize the member list and the input\n               concatenation to add other macros and/or macro\n               libraries, as needed.\n\n               Use the \"TRIMMAC\" library instead of the\n               MACLIB/AMODGEN concatenation to assemble a\n               program and compare the before/after values for\n               the elapsed time, excp count and I/O connect\n               time.  Expect savings of 30 to 60 percent when\n               \"TRIMMAC\" is used.\n\n               My \"TRIMMAC\" PDS is currently allocated as\n               follows:\n\n                   UNIT=3390,SPACE=(CYL,(9,,18)),\n                   DCB=(RECFM=FB,LRECL=80,BLKSIZE=29720)\n\n     USERCMDS  Job - Update USERCMDS in batch\n\n               This is a TMP job that uses an in-line REXX exec\n               and ISPF table services to append a set of in-line\n               commands to the original USERCMDS table.\n\n               The resulting USERCMDS table may be given any\n               name and go to any library you choose.\n\n     ZAPONTR0  Patch job - Bypass STEPLIB for ILBOxxx routines\n\n               This patch to ILBONTR0 eliminates\n               JOBLIB/STEPLIB directory searches for OS/VS\n               COBOL ILBOxxx modules when SYS1.VSCLLIB is in\n               the linklist.  If you compile your COBOL\n               modules with 'resident' and have large JOBLIBs\n               or STEPLIBs, you want to try this.\n\n               The job contains 2 different versions of the\n               patch in AMASPZAP format.  Each version\n               corresponds to a different PTF level, use the\n               one that works for you.  The patch is packaged\n               with its own validation program.\n\n     ZAPXMIT   Patch job - Remove BLKSIZE(3120) from XMIT OUTDA() cmd\n\n               This patch to the TRANSMIT command sets the BLKSIZE\n               of the output data set to zero when TRANSMIT/XMIT\n               is invoked with the OUTDA or OUTDS parameter.\n               This version of the ZAP works on TSO/E 2.6.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE01": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00S\\x01\\x13#\\x0f\\x01\\x13#\\x0f\\x14P\\x00%\\x00#\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-08-18T00:00:00", "modifydate": "2013-08-18T14:50:53", "lines": 37, "newlines": 35, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  CBT Tape File 183\nFrom:     \"Rainer Nowak\" <rainer_nowak@gmx.de>\nDate:     8/17/2013 4:08 PM\nTo:       sbgolob@cbttape.org\n\nPLEASE REFERENCE MEMBER STEMEDI# IN THIS PDS !!!!!\n\nHello Mr. Golob,\n\nFor many years the CBT tape has been a great help for me. Usually\nI used the programs 'as is', but now a colleague wants a way to\nshow him all the stem variables in a REXX exec.  OK, there's\nSTEMEDIT in CBT tape file 183, but this can only be used for stem\nvariables like a.1, a.2 and so on.  One big advantage of REXX is,\nthat you can use stem variables in the way like a. =0;do i=1 to\nwords(text);j=WORD(text,i);a.j=a.j+1;end . So you can count how\nmany times a word is used in a text.  For such stem variables you\ncan't use STEMEDIT.  So I changed STEMEDIT to VIEW and EDIT all\nvariables in a REXX exec.  You'll find the changed source in the\nzip file I attached to this eMail.\n\nThere are also two edit macros to be used with STEMEDIT.  Call\nSTEMEMCB at the beginning of the edit session to change all '00'x\nin blanks and shift the '=' to the left.  At the end of the edit\nsession STEMEMCE should be called to end up the lines with '00'x.\nI've also changed TALLY to work under z/OS 1.13.  I know you don't\nneed TALLY anymore, because DSLIST now can do this for you.  But\nthe idea behind TALLY is, to find the ISPF table used by DSLIST\nand use it for your own needs.  So I wrote DSL as an example, how\nto use this table.  In DSL you can exclude Datasets from the list,\nflip between excluded and visible and do HSM RECALL for all\nvisible Datasets.  I hope these programs will be a help for someone.\n\nThank you for your help and work for so many years.\n\nRainer Nowak\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE02": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x002\\x01\\x15'_\\x01\\x15'_\\x14!\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2015-10-02T00:00:00", "modifydate": "2015-10-02T14:21:32", "lines": 18, "newlines": 18, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  FILE183 - SWAREQ update for z/OS 2.2\nFrom:     Don Poitras <sasdtp@sas.com>\nDate:     10/1/2015 3:05 PM\nTo:       <sbgolob@cbttape.org>\n\nSam,\n  IBM broke Gilbert's SWAREQ exec at z/OS 2.2 by moving a control\n  block above the bar. We use this as a basis for an IPCS REXX\n  exec we use, so I researched what would be needed to fix it.\n  Here's what I came up with:  (see member SWAREQ22 for the REXX)\n\n\nI tested this on our 2.2 system. Of course, no guarantees as the\nQMAT is OCO.\n\n--\nDon Poitras - zSeries R & D  -  SAS Institute Inc. -  SAS Campus Drive\nmailto:sasdtp@sas.com   (919)531-5637  Fax:677-4444     Cary, NC 27513\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$CHANGES": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x00H\\x00\\x885\\x0f\\x01\\x16\\x10\\x8f\\x136\\x03\\x19\\x00\\x00\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "1988-12-15T00:00:00", "modifydate": "2016-04-17T13:36:48", "lines": 793, "newlines": 0, "modlines": 0, "user": "SBGOLOB"}, "text": "                 .--------------------------------.\n                 | CBT Tape - File 183 Change Log |\n                 '--------------------------------'\n\n                    http://gsf-soft.com/Freeware\n\nCBT491  17 Apr 2016   (fix to LOCKTERM from Garry Green)\n\n  LOCKTERM      ASCBTOFF bit to not allow S522 abends was\n                turned off after the password was entered\n                correctly.  Previously it had been erroneously\n                turned on.  (OI done, instead of NI 255-.)\n\nCBT490  08 Oct 2015   (from Sam Golob - from Gilbert's libraries)\n\n  DAHANDBK      Program to create a \"handbook\" of control block\n                displacements from the assembly of mapping macros.\n  DAHANDJ       Sample job to create a handbook.\n\n  SHOWDASD      Fixed for z/OS 2.2 with 64-bit ULUT address\n                (ULUT Type 3).  Also good on older systems too.\n                Same fix applies to z/OS 1.13 and 2.1 with PTFs\n                (UA90741,0,2) applied.  (from Anthony Cieri)\n\n  SWAREQ22      Fix from Don Poitras to adjust to z/OS 2.2 putting\n                a control block above the 64-bit bar.\n\nCBT486  26 Dec 2012   (from Sam Golob - from Gilbert's libraries)\n\n  FASTPATH R150 Discovered on Gilbert's system  (SBG)\n  FASTNOTE      Added to FASTPDOC member and made it\n                into a separate member as well.\n  FASTP149 R149 Previous version of FASTPATH.\n  ISPCMDL       REXX exec to list your ISPF command table\n                entries (from Willy Jensen)\n  ISPCMDU       REXX exec to update your ISPF command table\n                entries (from Willy Jensen)\n  ISPCOMND      Sample data for ISPCMDU to use, to update\n                the command table with.  You should copy\n                this member into your ISPF profile dataset.\n                There is an entry in here, to invoke FASTPATH.\n\nCBT483  31 Jan 2011      (last changes done by Gilbert himself)\n\n  COMPRCMD R323 Convert PARM to CPPL when invoked as a program\n  EXECUTE  R205 Remove \"ADDRESS ISPEXEC\"\n  STEMEDIT R207 VIIF only supported in ISPF V5 and above\n  VDL      R102 Stop using DTB in ISPF 5.9 and above\n\nCBT479  31 May 2010\n\n  BR       R231 Add RBA Command to display RBA in pos 1\n                Add commands to init msg: V, LC, RBA\n                FSTSO replaces TSOFS\n  FASTPATH R149 DSInfo/ISRUDA+ISRDDNPI\n                Add #@ to CURSOR table\n                TSOFS is now called FSTSO\n  STEMEDIT R206 Check for empty records in RDRTN84\n  STRING   R518 %TIME hh:mm:ss.hh instead of hh:mm:ss:hh\n                (%TIME,5) or (%TIME,8) or (%TIME,11) or (%TIME,12)\n                Fix another bug near GENL2D\n  VSAMVIEW R106 Add \"(LDS)\" to error message when needed\n  ZAPXMIT  R102 Support XMIT in z/OS R11\n\nCBT478  31 Dec 2009\n\n  +LOAD183      New File: FILE183.LOAD in TSO/TRANSMIT format\n  ADDTRK   R200 New version\n  BR       R226 Allocate 64kb BUFFER on page boundary\n           R227 Update for z/OS R10\n           R228 Invoke VSAMVIEW when user enters V command\n                Support ISPF/PDF V3-V5\n           R229 Invoke LISTCAT when user enters LC command\n           R230 Fix VSAM error - was RPLFDBWD=2B080020 OPTCD=C440 RRN=1\n  CLEANUP  R407 Update for z/OS R10\n  COMPRCMD R322 Add vol(volser) to final message when VOL was supplied\n  CONCAT   R402 No dsname & PREFIX='' -> dsname=userid.EXEC\n  FASTPATH R145 Make TRUNC=0 a default value in ISPCMDS macro\n                Pre-load more programs from FILE183.LOAD\n           R146 TSOFS - Check for null command\n                Add SHOWDasd, FSHelp and SHOWJpaq commands\n           R147 Add FSPRINT command\n           R148 Add Timezone: E.02.00.00 (from CVTTZ/CLOCKxx)\n  FILE183  R100 New CLIST - Connect FILE183 libraries to ISPF environment\n  FREEDIR  R200 New version\n  FSHELP   R200 New REXX exec - TSO HELP with full-screen display\n  IRXEHCIR R102 Add PARM='/STACK(,,BELOW)' to COBOL step\n  LC       R100 New REXX exec - TSO LISTCAT with full-screen display\n  PLI2JOB  R100 New Program - PL/I Job Info\n  REXXTRY  R102 Can be invoked via a TSO CALL command\n           R103 CALL *(REXXTRY) can read from SYSTSIN\n           R104 Quit if there is no cmd and we're not in TSO/Batch\n  SHOWDASD R103 If SHOWDPNL is not in ISPPLIB, look in SYSEXEC\n                REFRESH command is now active\n  SHOWJPAQ R201 New program\n           R202 CDATTR3\n  SHOWTIOT R100 New REXX EXEC - Current Data Set Allocations\n  STEMEDIT R203 Fix several bugs\n           R204 Change X'40' to X'41' (NBSP) in TITLE\n           R205 Support ISPF/PDF V3-V5\n                Replace LINK macro with ISPLINK\n  STRING   R516 May be present in multiple CSECTs in same assembly\n                One of the CSECTs that use STRING may have no name\n           R517 Fix addressability error in CSECT23/CSECT28\n  SYSDEBUG R255 Change HH.MM.SS to HH:MM:SS in title line\n                Change STRING GENERATE to STRING (GENERATE,,LOCTR)\n           R256 Use CSVQUERY instead of CDX\n                Needs changes to assemble before z/OS\n           R257 Change time format from 12H34M56 to 12:34:56\n                Can assemble in OS/390 R3 and above\n  USERCMDS R505 Batch job to load ISPF commands into USERCMDS table\n           R506 Add FSPRINT command\n  VML      R106 Change YYYY/MM/DD to YYYY-MM-DD\n           R107 BROWSE option\n  VSAMVIEW R104 Support ISPF/PDF V3-V5\n           R105 Display ISRZ001 at start-up\n  VSAVE    R403 ISRE017\n           R404 Issue error msg when zdsn=''\n  WHOAMI   R103 YY.DDD instead of YYDDD - JDATE\n  XDELETE  R205 execute=TRANSLATE(STRIP(execute))\n  XRENAME  R101 execute=TRANSLATE(STRIP(execute))\n\nCBT477  31 Dec 2008\n\n  ADDTRK   R100 New EDIT macro\n  CLEANUP  R406 Check that GDG base is DEFINE'd\n  FASTPATH R142 Ignore SYMBOLIC/RESOLVED in LISTCAT\n  FREEDIR  R100 New EDIT macro\n  PLI2TSO  R100 New Program\n  TALLY    R102 Stop using DTB to support ISPF 5.9\n  XDELETE  R204 Display creation date (DSCRDT2) on DELETE commands\n\nCBT475  30 Nov 2007\n\n  NOTCTLG3 R201 Program deleted\n  STRING   R515 Display negative values\n  SHOWDASD R102 Support for z/OS 1.7\n  VALLOC   R101 sysunits='BLOCK'\n\nCBT472  31 Jul 2006\n\n  COB2JOB  R102 Fix TCBTTIME/micro-seconds computation\n  COMPRCMD R321 LLAREFRESH\n           R320 Re-read F1-DSCB in case ENQ had to wait\n  FASTPATH R141 Fix NETSTAT for CS IP stack\n  FILLDASD R201 Use SYNAD to trap I/O Errors\n  IGX00GSF R202 Source code no longer distributed\n  LVL      R200 New EDIT Macro\n  STEMEDIT R202 Change version number\n  SYSDEBUG R254 Display BFTEK=A in QSAM DCB\n                Display LBI BLKSIZE from DCBEBLKSI\n\nCBT469  31 Aug 2005\n\n  BR       R225 Remove support for MVS/XA, MVS/ESA and ISPF V3\n                Support ALIAS Entries when calling ISPF BROWSE\n                Process a VRDS like an RRDS\n                Support extended-addressability VSAM data sets\n                Improve EOF detection for open data sets\n  COMPRCMD R319 Data Set List\n  EXECUTE  R204 Change PULL to PARSE PULL\n  FASTPATH R139 Misc changes\n           R140 Support ALIAS Entries when calling BR\n  SCANMODL R100 Update Test Program\n  STRING   R514 '&&'(1,1) at .LIT11C\n  SYSMOVE  R405 Zero DS1REFD\n  SYSDEBUG R253 Fix bug - EXCP count for last DD was always zero\n                Display SYSOUT record in JES2 buffer on z/OS 1.2\n  TCTDCTR  R108 Fix bug - EXCP count for last DD was always zero\n  TMS      R508 Blocked TMC\n  VML      R105 Minor change\n  VSAMVIEW R103 Process a VRDS like an RRDS\n  XRENAME  R100 New REXX exec to rename data sets \"en masse\"\n  ZAPXMIT  R101 Updated for HTE7708 offsets\n\nCBT465  31 Mar 2004\n\n  COMPRCMD R318 Force RECFM=FB,LRECL=80 in SYSIN DCB (PDSMAN/PM74127)\n  COMPRESS R305 Check for recursive calls\n  EXECUTE  R203 Add ISPF option\n  ISREDIT2 R100 New program\n  ROUTE    R622 END stmt missing in line 306\n  SHOWDASD R101 Trap invalid commands\n  SHOWDPNL R101 Change vertical spacing\n  SHOWVTOC R100 New ISPF panel for the ShowDASD Dialog\n  STRING   R513 Local base not needed for (GENERATE,,LOCTR)\n  SVCUPDTE R309 Wait for one second before final FREEMAIN\n  SVC11Y2K R100 Source code no longer distributed\n  SYSDEBUG R252 Do not print current save area twice\n\nCBT455  30 Sep 2003\n\n  DCODADDR R101 New Assembler Program\n  IGX00GSF R202 RC=40 when caller is in AMODE=64\n  ROUTE    R619 Line length may be longer than 255 characters\n           R620 Replace XEROX 3700 with HP LaserJet\n           R621 Display WSCON Panel when needed\n  ROUTEPGM R606 Line can be 512 bytes long\n  SFE      R100 New REXX exec\n  STEMEDIT R111 Set default LRECL to 255\n  STRING   R511 Minor ACTR change\n           R512 Packed fields no longer ignored when R0=0\n  SWAREQ   R200 New REXX exec\n  TLMS     R202 Unblocked VMF in TLMS II 5.5\n  VALLOC   R100 New REXX exec\n  VSAMVIEW R102 Prevent S806-04 ISRCONFG MODULE NOT FOUND\n  VSAVE    R402 Add support for sequential data sets\n  WHOAMI   R102 Get OS name and level from ECVT\n  XDEL     R300 New REXX exec\n  XREN     R200 New REXX exec\n\nCBT451  31 Aug 2002\n\n  BR       R149 Use panel ISRBROBA on OS/390 R10\n  FASTPATH R138 Invoke VIIF instead of EDIF on OS/390 R10 (FSPASTE)\n                Strip off ALIAS--- in LISTCAT function\n                Expand WSA address to 64 characters\n  IGX00GSF R201 CDATTR,CDREN\n  LCAT     R101 Prevent S0B0 in sub-task after link-list switch\n  LCAT92   R100 1992 version of LCAT for OS/390 R2 and older\n  SHOWDASD R100 New REXX exec.\n  SHOWDPNL R100 ISPF panel for ShowDASD exec.\n  SHOWMACS R626 Source code replaced with link to CBT file 492\n  STRING   R510 Minor changes\n  SYSDEBUG R250 ENQ and HH.MM.SS\n           R251 4-digit DEVN\n  STEMEDIT R110 New version of STEMVIEW for ISPF V5 only\n  TALLY    R101 Minor change for ISPF 5.0\n  VSAMVIEW R101 Use the VIEW Interface (VIIF) on ISPF V5\n  VSAMVW95 R100 1995 version of VSAMVIEW for ISPF V2, V3 and V4\n  ZAPXMIT  R100 New Patch - Remove BLKSIZE(3120) in XMIT OUTDA() cmd\n\nCBT434  30 Apr 2001\n\n  FASTPATH R137 Minor technical changes\n  FULLDSN  R100 New program\n  ROUTE    R618 Fix \"0 Lines Written\" message when Routepgm=NO\n  ShowMVS  R625 Source code replaced with link to CBT file 492\n  STRING   R509 Length of parm-list entries can vary between 2 and 6 bytes\n                Short Literals (one to five bytes) are generated in parm list\n                Hex string can contain commas, e.g. X'12,3456,7890'\n  SYSDEBUG R249 Fix S0C7 on OS/390 R3 when JCTJMRJD=0 and JCTSSD=0\n  TMS      R507 Various changes to make it look more like CA1\n  XDELETE  R203 Check type for VSAM entries\n\nCBT430  30 Nov 2000\n\n  FASTPATH R136 Blank out (*) at end of dsname (B/E/V)\n                Do not call BR if dsname(member) is too long\n                Issue error message after BROWSE failure\n  FILLDASD R200 New program\n  IKJEFLN2 R100 New TSO/E Logon exit\n  IPADDR   R300 New REXX exec\n  RECALL   R209 Use QNAME outside of the DCB to prevent ENQ errors\n  REXXTRY  R101 New TSO command processor\n  ROUTE    R616 Set up PRN and LPT1-4 as PC printer destination\n  RXSMS    R100 New assembler program\n  STRING   R508 Compatibility with HLASM R3 and FLAG(PAGE0)\n                Compatibility with pre-XA version of the SAVE macro\n  SYSMOVE  R404 Change date format to yyyy-mm-dd\n\nCBT424  30 June 2000\n\n  CONCAT   R401 Add the REMOVE function\n  DEFGDGSR R301 Use ALTER instead of DELETE+DEFINE\n  DONTFAIL R106 Change STRING GENERATE to STRING 507 format\n  FASTPATH R135 Use PGM(ISRDSLST) PARM(PL1 REFLIST) instead of RL1 in ISPF 4.8\n                Check for migrated data sets in all situations\n                Support ALIAS names on non SMS-managed volumes\n  SHOWMVS  R625 Prevent RC=4 messages when assembling with HLASM 1.3.0\n  SYSDEBUG R248 Add support for HLASM R3 and JES2 OS 1.3.0\n  TMS      R506 Fix two errors in LINE14\n  TLMS     R201 Rewrite for TLMS II 5.5 (VMF records can be blocked)\n  VDL      R101 Misc changes\n\nCBT423  15 March 2000\n\n  COB2JOB  R101 Retrieve acct info\n  FASTPATH R134 A + sign at the end of a command starts a new logical screen\n                Prompt user before creating a new Tag entry\n                Do not issue RACROUTE with ACF2 or Top-Secret\n                Remove LOCTR option in STRING GENERATE instruction\n                Replace LINK EP=IEANTxx with BALR to prevent S406-04\n                Init ZREFTYPE and ZWRKVOL variables to X'40'\n                Drop trailing blank lines in FSPASTE\n  HANDBOOK R148 Minor additions\n  SHOWMVS  R624 Minimal support for OS/390 R7 & R8\n                Add support for dynamic link-list in DOBLDL\n                ShowMVS now requires STRING R507\n  STEMVIEW R108 Set ZVMODET='VIEW' to show VIEW instead of EDIT on ISREDDEx\n                Add recfm and profile parameters for VIEW\n                Display error message after BRIF/EDIF failure\n                Display STEMVIEW Arguments Syntax if not invoked from REXX\n  STRING   R507 Merge XA and ESA codes, change format of GENERATE call\n  STRINGXA R404 Deleted, replaced with STRING R507\n  XDELETE  R202 Minor changes\n\nCBT422  30 November 1999\n\n  COB2JOB  R100 New Program\n  COB2SYS  R100 New Program\n  COB2TSO  R100 New Program\n  FASTPATH R133 Reorganize initialization code and add SELECT function\n                Detect migrated data sets and allow user to prevent HRECALL\n                Replace relative generation number with .G*V%%\n                Allow volser in direct ED/BR/VI/WP: ED ISP.SISPPENU/OS39R7\n                Do not prefix &ZPREFIX if the unqualified name is cataloged\n                Add profile on MAClib/PARMLib functions\n                Add VIEW/EDIT option to PARMLib function\n                Fix BEGIN_PROC macro for HLASM R3 (requires STRING R506)\n  FASTPDOC R110 Update doc to match R133 of FASTPATH\n  STEMVIEW R107 E or V command switches from BROWSE to VIEW\n  STRING   R506 Compatibility with HLASM R3\n  STRINGXA R404 Compatibility with HLASM R3\n  TALLY    R100 This is a new REXX exec\n  XDELETE  R201 Fix coding error in VALUE()\n\nCBT421  31 July 1999\n\n  CUT      R402 Use LIBDEF ISPLLIB when Loadlib='load.lib.dsname'\n  FASTPATH R132 Check for * and % in EDBR\n                Add LIBRARY(ISPSPROF) to TBCLOSE service\n  INITKSDS R105 RESET/NORESET can now be specified in the JCL PARM\n  LOADMLPA R302 Fix bad branch to EXIT20 label\n\nCBT420  31 March 1999\n\n  CONCAT   R400 New REXX exec\n  EXECUTE  R202 Add TRACE option\n           R201 Can be invoked as an EDIT macro\n  FASTPATH R131 Add OPENCMDS and FSPASTE functions\n                LOAD function supports LIBDEF ISPLLIB\n                Enhance TSOFS and UNLOAD functions\n                Add LC command\n                Issue RACROUTE to prevent S913 abends in BR/ED/VI\n                Close ISRxLIST tables before a crash\n                Use VARLISTW for WP variables to prevent corruption\n                Restructure the code to work around addressability problems\n  FASTPDOC R109 Document changes in the FASTPATH code\n  LINKLLA  R301 RENT,RMODE=ANY\n  LOCKTERM R201 LOGOFF now alias of CANCEL\n                STCOM only issued on OS390R4\n  PVTMACS  R404 Member renamed, new name is SHOWMACS\n           R403 Compatibility with OS/390 V2R6\n  ROUTE    R615 Destination can be workstation file name\n  ROUTEHLP R615 Document changes in the ROUTE code\n  SHOWMACS R404 New member (was PVTMACS)\n  ShowMVS  R623 Compatibility with OS/390 V2R6\n                External Time Reference (ETR)\n                Path Information\n                Coupling Facility Data\n  STEMVIEW R106 Truncate title\n  SVCUPDTE R308 More doc, small technical changes\n  SYSDEBUG R247 Title shows date in YYYY-MM-DD format\n  VML      R104 Exit main loop after 8X'FF' member\n  VSAVE    R401 Prevent LMMSTATS failure when zlvers=00\n\nCBT419  31 OCT 1998\n\n  COMPRESS R303 EDIT macro renamed (was COMPREXX)\n                Add BATCH option\n  COMPRCMD R316 Command Processor renamed (was COMPRESS)\n  DEBUG    R246 Renamed, now called SYSDEBUG\n  DSLIST   R213 New dsname extraction routine\n  FASTPATH R130 New functions: CALENDAR, CONNECT, LOAD, NETSTAT,\n                  REXXTRY, UNLOAD, VERASE and ZDEL\n                Enhanced ED/VI/BR/WP:\n                  data set referral list\n                  work-station files\n                  compat. with CNAEBROW/CNAEEDIT\n                STOP522 code generated if assembled w/ SYSPARM(STOP522)\n                Delete dupl entries from SITE and USER command tables\n                Change SYSID function to use ZDEL instead of \";\".\n  FASTPDOC R108 Document all FASTPATH commands and built-in functions\n  IEC149I  R101 Replace STRING macro with MVC instructions\n  ISFSVC   R201 Document deleted\n  LASTCLPA R400 Program deleted\n  LISTDSI  R200 New REXX exec\n  LOCKTERM R200 New TSO command\n  LPA24    R100 New REXX exec\n  NOTCATLG R111 Program deleted\n  OBEYFILE R100 New REXX exec\n  PVTMACS  R401 Misc. additions and corrections\n  ShowMVS  R622 Run-time Library Services (RTLS)\n                Resource Recovery Manager (RRS)\n                Automatic Restart Manager (ARM)\n                Misc. additions and corrections\n  STEMVIEW R105 PULL data from the stack when no variable name specified\n                Display prompt panel when user issues END or SAVE\n                Lrecl can be specified in 7th argument\n                Replace STRING macro with in-line code\n  STRING   R505 Allow for 128K-offsets\n  SVCUPDTE R307 Parm option for LOCAL and CMS locks\n  SYSDEBUG R246 Renamed, was called DEBUG\n  TRIMMAC  R309 Misc. additions and corrections\n  VARS     R100 New REXX exec\n  VDL      R100 New REXX exec\n  VML      R101 Allow invocation as an EDIT macro\n           R102 Display SPF stats\n           R103 Can be invoked outside ISPF\n  XDELETE  R200 Rewrite much of the code to make it more generic\n\nCBT418  30 APR 1998\n\n  BYPASSNQ R102 New program\n  COMPRESS R316 Retrieve &ZDLVOL when invoked from DSLIST\n  FASTPATH R129 New dsname extraction routine\n           R128 Add READY option to CRASH command\n           R127 New function: EXECPGM\n  LPR      R100 New EDIT macro\n  FTP      R102 Replace EXECIO with ROUTEPGM\n  ROUTEPGM R605 Now supports RECFM=V and RECFM=U\n  ShowMVS  R621 Enhance support of OS/390 R4\n  STEPLIB  R220 Member deleted\n  VML      R100 New REXX exec\n  WP       R100 New REXX exec\n  XDELETE  R101 Set RC=12 when DELETE cmd fails\n\nCBT416  31 DEC 1997\n\n  FTP      R100 New EDIT Macro\n  IEC149I  R100 New MPF Exit\n  ShowMVS  R620 More support for OS/390 R3\n                Name/Token (System and Address-space)\n                Added Subpool definition and attributes\n                Cell Pools (Global and Local)\n                Enhanced SVC-Table Display\n                Product Registration info in table format\n                LNKLST set information (OS/390 R3)\n                Work Load Manager definitions\n\nCBT415  30 SEP 1997\n\n  BR       R148 Prevent FREEMAIN errors in SO5\n           R147 Ignore all extended-format data sets\n  CLS      R300 TSO \"CLEAR SCREEN\" Command\n  CUTPGM   R402 Fix padding bug when compress=1\n  DSLIST   R212 Add PROFILE option on WorkPlace VPUT\n           R211 Compatibility with ISPSTRT\n  EXECUTE  R200 New REXX exec (replaces RUNEXEC)\n  FASTPATH R126 Add PROFILE option on WorkPlace VPUT\n           R125 Support ZEDITWS and ZVIEWWS variables\n           R124 Compatibility with ISPSTRT\n           R123 PARMLIB function for OS/390 R2\n           R122 Enhance CRASH function, remove LOGON/LOGOFF\n           R121 Technical changes\n           R120 CRASH/LOGON/LOGOFF/D Functions\n  IRXEHCIR R101 Technical changes\n  ROUTE    R614 Move doc to ROUTEHLP panel\n  ROUTEHLP R614 Now a scrollable panel with 120 lines of text\n  ShowMVS  R619 Initialization Parameter Area (OS/390 R2)\n                Product Enable/Disable (OS/390 R1)\n                Resource Manager List (IEAVTRML)\n                Display ranges in SMF NOTYPE, SSI codes, ROUTCDE\n                Fix ddname identification error in RTE display\n                Sysplex-Environment (auth)\n                Enhanced Command Prefix Table (CPFT)\n                TCP/IP Version\n                Support for UCBs above the 16M line\n  STEMVIEW R104 STEMDISP has been renamed to STEMVIEW\n                CONTROL DISPLAY REFRESH, ENVBLK\n  STRING   R504 Minor fix\n  STRINGXA R403 Minor fix\n  TMS      R505 New screen layout\n  UNITAFF  R118 Fix SWA=BELOW bug\n  VSAVE    R400 New EDIT macro\n\nCBT411 07 DEC 1996\n\n  BR       R146 Use ISRBROBA panel in ISPF V4\n  DEBUG    R246 Correct RECFM=U record length\n  FASTPATH R118 Add TSOFS, CNTL and TIME functions\n                Remove FSHELP function\n           R119 Add PVTMACS to MACLIB/MODGEN if cataloged\n  FASTPDOC R102 Numerous changes\n  IGX00GSF R200 New SVC routine\n  IRXEHCIR R100 New program\n  PVTMACS  R300 New member: Create PVTMACS Library\n  RUNEXEC  R100 New REXX exec\n  ShowMVS  R618 MAJOR CHANGES:\n                  Move in-line DSECTS to the PVTMACS library\n                  ShowMVS must now be assembled with PVTMACS\n                  Use IGX00GSF instead of ISFSVC if available.\n                Implement enhancements contributed by DL\n                  SYS1.DUMP Support for dynamic allocation\n                  WLM Workload Manager information (auth)\n                  DYNEXIT Dynamic Exit Facility information (auth)\n                  SYMBOLS Show static symbols\n                New Displays:\n                  Run-time Environments (Cobol, PL/I, LE, etc)\n                  Primary Sub-system\n                  Date and time of last CLPA if IPL'd with CLPA=NO\n                  Date, time and title of SYS1.DUMP data sets\n                  TSO Exits and Tables\n                  Device Allocation Defaults (ALLOCxx)\n                  DAE Parameters (ADYSETxx)\n                  Message Processing Facility (MPF)\n                  Command Prefix Table\n                Miscellaneous enhancements:\n                  Restructure the initialization code\n                  Show dates in ISO-recommended format (yyyy-mm-dd)\n                  Reactivate ISFSVC support for MVS/XA and REXX\n                  VMDATA now shows correct CPU id\n                  Version codes for more AMDAHL CPUs\n                  Adjust size of IGDBCD if SSSA1RSN=5001\n                  Issue DIAG 204 to obtain PR/SM Config data\n                  Replace CDX scan with CSVQUERY macro\n                  Make Virtual Storage Usage display dynamic\n                  Improve CPU Usage display\n  STEMDISP R103 Convert variable name to uppercase\n                Support 3rd & 4th arguments\n  STEPLIB  R220 Source code no longer supplied\n  STRING   R503 Date conversion to yyyy-mm-dd format (ISO standard)\n  STRINGXA R402 Date conversion to yyyy-mm-dd format (ISO standard)\n  XDELETE  R100 New REXX exec\n\nCBT409 31 AUG 1996\n\n  DEBUG    R245 Concat MACLIB in ASMH step for STRING macro\n  GETDIR   R101 Fix JCL error that caused unpredictable results\n  GETPUT31 R101 Fix JCL error that caused unpredictable results\n  FASTPATH R117 FTINCL function\n                If cursor-driven BROWSE fails, invoke PGM(BR)\n  ShowMVS  R617 Use protected work areas when authorized by SDSF SVC\n                Recovery routines and timers\n  STEMDISP R102 EDIT support\n           R101 Add two lines deleted by mistake (caused S0C4)\n  SVC11Y2K R100 New SVC routine\n  WHEREIS  R200 New REXX exec\n\nCBT408 24 AUG 1996\n\n  COMPRESS R315 Move STTMPMD macros around IEBCOPY invocation\n  FASTPATH R116 New functions, new parm format\n           R115 FSHELP function added (full-screen HELP)\n  HANDBOOK R160 Old member, new name (was MAC)\n  ShowMVS  R616 Display CPC ND and CPC ID from HID\n  STEMDISP R100 New program\n  WHOAMI   R101 New REXX exec (replaces WHEREAMI)\n\nCBT407 31 JUL 1996\n\n  CLEARSCR R200 Fix addressability problem\n  DONTFAIL R105 Several small enhancements\n  EXECPGM  1805 Fix conflict between ESTAE and XCTL\n  FASTPATH R114 Add MACLIB function to VIEW MACLIB/MODGEN member\n           R113 Simulate WP with %DSLIST in ISPF V3/V4R1\n           R110 Implement own \"point-and-shoot\" capability\n  PASTE    R403 Clip-board name may be enclosed in quotes\n  ShowMVS  R615 Support for OS/390 R1 and DFSMS/MVS 1.3\n                New output modes: EDIT, PUTLINE and SHORT_PUTLINE\n                Default mode at TSO READY changed to SHORT_PUTLINE\n                Implement enhancements contributed by JWM:\n                  SYSPLEX name, OpenMVS Status, ACF2, DB2+,\n                  SMF exits, ETR status, Dump options, Console name\n                  More TSO/E Tables, CDA date & time\n                  Linkage Index (LX) Table (if authorized)\n                Implement enhancements suggested by MXT:\n                  CPU model for 308x,4381,3090,5995,9x21,9672\n                  Service units per second (using RMCTADJC)\n                  Remove % sign from LPAR weights (can exceed 100)\n                  Status of the Automatic Cartridge Loader (ACL)\n                  2-char names in TSO tables no longer missing\n                  JES2 Initiators (refreshed when you press ENTER)\n                New Displays:\n                  LLA parameters and dsnames (thanks to MSCH)\n                  GRS Configuration\n                  VM Data: Real CPU Id, User ID, CP level\n                  GTF Status\n                  I/O Appendage Table (IEAAPPxx)\n                  TSO Attention Exits\n                  Addresses of some local & global control blocks\n                Miscellaneous enhancements:\n                  ICKDSF level (from ICKRELVL) and CICS level (DFHCSVC)\n                  Primary sub-system name and type\n                  Time Zone (from CLOCKxx)\n                  Use DS1LSTAR to determine status of SYS1.DUMP data set\n                  Version Information from sub-systems that supply it\n                  Enlarge YYMMDD field in preparation for 4-digit years\n                  Message displayed on 3480 screen (e.g. K 020436)\n                  Address-space type: Batch/TSO-batch/TSO-on-line\n                  Initial LOGON command (from TSO/E LOGON screen)\n  STEPLIB  R220 Prevent certain S106 abends\n  STRING   R502 New version for ESA only (supports AR mode)\n  STRINGXA R401 Last XA version of STRING\n  WHEREAMI R100 New REXX exec\n  WRITENR       Deleted; Steve Bacher's XWRITENR is a lot better.\n\nCBT404 29 FEB 1996\n\n  BR       R145 Remove all authorized functions\n  DSLIST   R209 Invoke Work Place Utility under ISPF 4.2\n  FASTPATH R108 New Program\n  INITKSDS R104 Complete FREE=CLOSE enhancement, fix others errors.\n  ISPTASK  R305 Fix day-of-the-week calc routine for year 2000\n  NEWAPPL  R100 New REXX exec\n  PASTE    R402 Implement OUTTRAP feature\n           R401 Remove EXIT stmt before last SETMSG\n  ShowMVS  R514 Implement the JUL2DAYS date calculation routine.\n                Prevent S0C4 when ICHRIN03 hdr has wrong # of entries\n  RECALL   R208 Replace ARCHRCAL macro with LOCATE\n           R207 Process referback dsnames (VOL=REF, DCB, LIKE)\n                Process generation data sets (GDS)\n  ROUTE    R612 Add support for the HOLD operand.\n           R611 Accept operands from outer macro.\n                Right parenthesis at end of command is optional.\n  SCANMODL R100 New module\n  SVCUPDTE R232 Restrict access to new SVC to a given user-ID\n           R231 Fix \"good-night\" routine\n           R230 Restore address of OLD SVC after temporary install\n  VSAMVIEW R100 New command\n\nCBT403 24 NOV 1995\n\n  BR       R144 Improve dsname extraction from a window\n           R143 Work around ISPF V4 bug (ZDLDSORG='' for VSAM cluster)\n  COMPRESS R314 Replace IKJTSMSG macros with STRING\n           R313 Add SETMSG option to display stats under ISPF\n           R312 Prevent DYNALLOC failures for SYSIN/SYSPRINT\n  COMPREXX R300 This is the REXX version of the COMPRESS EDIT macro\n                that used to be at the end of the COMPRESS command\n  CUT      R401 Fix errors when user enters D/DD line commands\n  DEBUG    R245 Initialisation routine rewritten to no longer\n                require caller to provide addr of save area in R13.\n           R244 Can be invoked with KEY=NZERO,MODE=SUP\n                Minor changes to JOB card formatting routine\n                Locate DDname for JPAQ modules loaded from a PDSE\n  DONTFAIL R101 Ignore DD with VOL=REF to a DISP=NEW data set\n  INITKSDS R103 Some support for FREE=CLOSE\n  ISPTASK  R304 Issue BLDL against every active tasklib until JSTCB\n  RECALL   R206 Write out messages to //$$RECALL DD\n           R205 Create sub-tasks and use WAIT=YES on ARCHRCAL macros\n  ROUTE    R610 Add support for the WRITER operand.\n                Change LINECT and HDR operands to PAGELEN and TITLE.\n           R609 Fix errors when user enters D/DD line commands.\n                Replace ASA with CCHAR to support machine ctl chars.\n           R608 Split ROTATE option into PORTRAIT and LANDSCAPE\n           R607 Enhanced table format (node, FCB)\n  ROUTEPGM R604 Convert JESJCL from RECFM=M to RECFM=A for SDSF 1.4\n  ShowMVS  R513 Detect Top-secret's presence in pseudo RCVT\n                Minor changes to JOB card formatting routine\n                Locate DDname for JPAQ modules loaded from a PDSE\n                Split MIPS table into bipolar & CMOS using IBM numbers\n  STEPLIB  R219 Remove references to IKJTSOxx which doesn't work\n  STRING   R401 GENERATE @STRHEXT WHEN ((REG),,X) ONLY HEX FIELD\n  SYSMOVE  R403 Allow the selection of a member on the SYSUT1 DD\n           R402 Print number of records and bytes written to SYSUT2\n\nCBT400 31 JUL 1995\n\n  BR         R142 Remove VVDS read capability\n             R141 Retry with BUFSP=0 after FDBK=0C0004 error\n  BUILDCDE   R200 New program\n  CLEANUP    R401 New release number\n  COMPRESS   R311 Small changes to support ISPF 4.1\n  CUT/PASTE  R400 New EDIT macros, asm pgm, help panels\n  DEBUG      R243 Produce report when invoked with R0=12 (no SDWA)\n             R242 Enhanced functions for authorized users\n             R241 Minor Enhancements and bug fixes\n             R240 Do not print lines with identical contents (PDUMP)\n                  Print PLH/RPL seq# when STRNO>1\n             R239 Enhance display of JOB/STEP information\n                  Hash-code pgm name to access CDX\n                  Print all active PLHs if STRNO>1\n                  Print contents of COM_REG area\n                  Prevent S0C4 when IOBECBAD is bad\n                  Provide support for QSAM buffers above the line\n  DEFGDGSR   R200 Set GDG's owner ID to current RACF USER\n  DL         R208 DL has been renamed, it is now called DSLIST\n             R207 New DSN extraction algorithm for dynamic panels\n             R206 Fix DEBUG option, add \"_\" to list of dsn delimiters\n  DSLIST     R208 DL has been renamed, it is now called DSLIST\n  DSNLIST    R200 New program\n  DONTFAIL   R100 New program\n  INITKSDS   R102 May be invoked as a sub-routine\n  ISGECMON   R100 New program\n  ISPTASK    R303 Allow ISPF's ISPTASK to be in STEPLIB\n             R302 Do not prevent S522 abends on week-ends\n  LASTCLPA   R400 New program\n  RECALL     R203 New program\n  ROUTE      R604 New EDIT macro, ASM PGM, HELP screen\n  ShowMVS    R512 Add support for MVS SP 5.1.0 and RACF 2.1.0\n                  Change format of JOB stmt, add RACF GROUP\n                  Display IPLPARM & HSA data from SCCB\n                  Expand BCD to support DFSMS/MVS 1.2\n             R411 Enhance JOB/STEP information\n                  Display Master JCL (IEEMSJCL)\n                  Hash-code pgm name to access CDX\n                  Display PR/SM config if ESA 4.3 with RMF active\n  SYSMOVE    R401 Add support for ALIAS entries\n  BASEREGS  macro No longer supplied, wasn't worth much.\n  EASYSORT  macro Old macro, new name (was EZSORT).\n  STRING     R400 Reorg the code to simplify feature selection\n             R308 Use L'RBCDE as implicit length in (PRB.RBCDE,,X)\n             R307 Add NOCSECT and LOCTR options to GENERATE call\n                  FINAL_CALL changed to GENERATE\n             R306 Tailor @STRING CSECT to program's requirements\n             R305 Literals can be coded as 'ABC' or C'ABC' or X'C1C2C3'\n                  Use L'PSATOLD as implicit length for (PSATOLD-PSA,,X)\n  WRITENR    R100 New program\n  ZAPONTR0   R103 New program\n\nCBT379 31 JUL 1994\n\n  BR       R140 Display VSAM statistics at end of pgm\n  CLEANUP  R100 New program\n  ShowMVS  R410 Some information from JOB and EXEC JCL statements\n                Storage Allocation Table (using TCTCORE and LDA)\n           R409 SMS Configuration Data from BCD\n                PR/SM partition number (ESA 4.3)\n                I/O Configuration from CDA (ESA 4.1)\n                Opening msg with pgm assembly info and auth\n                Space allocated in common area (ESA 4.3)\n           R408 REXX environments, host cmd tbl, func pkg dir\n                Library dsn for JPAQ entries (via CDEX)\n           R407 Enhance JOB/STEP information display\n           R406 Incorporate some enhancements from CBT375.FILE453\n           R405 Add support for Dynamic UCBs (ESA V4)\n           R404 Sort TSU/JOB names, support 4-digit device numbers\n           R403 Minor changes\n  DEBUG    R237 Storage Allocation Table (using TCTCORE and LDA)\n                Some information from JOB and EXEC JCL statements\n           R236 Library dsn for JPAQ entries (via CDEX)\n  STEPLIB  R218 Check for JSCBAUTH=ON, expand documentation\n           R217 Option \"QUIET\" added\n  STRING   R303 Minor changes\n  SYSMOVE  R400 New program\n\nCBT371 30 APR 1994\n\n  BR       R138 Implement full LDS support\n           R137 simplify processing of first record, fix bug\n           R136 display program level on first screen\n           R135 switch to NEWAPPL(ISR) if invoked under SDSF\n           -    can browse a VVDS or a data set allocated by\n                other users with DISP=OLD if authorized\n           -    Implement SDSF SVC for authorized functions\n           -    switch to NEWAPPL(ISR) if invoked under SDSF\n           -    Enhance processing of non-VSAM empty data sets\n           -    Issue ISRB603 message for VSAM empty data sets\n  COMPRESS R267 Data set usage refreshed if invoked from PDF 3.4\n           R266 PDSEs are identified as such and by-passed\n  DL       R205 do not use the vertical bar (ASCII conversion error)\n           R204 The VOLSER is set to spaces on the ISRUDLP panel\n  INITKSDS R100 This is a new program\n  ISFSVC   R100 This is a new Documentation file.  Please\n                read it if you intend to use the authorized\n                functions of ShowMVS, BR and STEPLIB.\n  ISPTASK  R300 This is a new program (it replaces ISPTASK2)\n  LLIBDEF1 R100 This is a new program\n  LOADMLPA R301 This is a new program\n  ShowMVS  R402 Support *SMS* and *MCAT* in APFTABLE entries\n           R401 Switch to APPL(ISR) if invoked with APPL(ISF)\n                Display 3390 device type\n           R400 Code reorganization, documentation\n                Implement SDSF SVC for authorized functions\n                Support 3390-9, fix MVS/XA, ESA 4.3 & JES2 bugs\n                Hard-copy DCB changed to LRECL=121\n                Display PPT if authorized\n           R386 Support MVS/ESA 4.3, JES2 4.3 and DFSMS/MVS\n  SVCUPDTE R227 Invoker must have update access to SYS1.PARMLIB\n           R226 Use ENQ to prevent multiple installations of the same SVC\n\nCBT343 06 JUN 1993\n\n  DL         R1   This is a new REXX exec\n  DEBUG    V2R2M1 Minor corrections and enhancements\n  ShowMVS  V3R8M4 Display TSO PARMLIB added, minor corrections\n  BR       V1R2M0 Added limited support for Linear Data sets and VBS data sets.\n                  Minor corrections.\n  PACKOFF    R105 New program\n  RESET5     R100 New program\n\nCBT341 13 FEB 1993\n\n  STRING   930130 Added $FARRTNE LOCTR for BR\n  DEBUG    V2R2M0 Miscellaneous enhancements\n  ShowMVS  V3R8M1 New device status, consoles, RACF & TSO profiles, TCAS\n  BR       V1R1M0 This is version 1, the previous ones were just\n                  a pair of quick-and-dirties glued together\n  SVCUPDTE V1R1M0 This is a new module\n\nCBT339 17 JAN 1993\n\n  ISPTASK2 Documentation and 7pm limit added\n  ShowMVS  device class table, linklist extents\n  GETDIR   this is a new macro\n  DEBUG    this is a new module\n\nCBT338 16 DEC 1992\n\n  STRING   DATE Conversion functions\n  ShowMVS  fixed some bugs, added a few functions\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$LOAD183": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00P\\x01\\x18\\x12\\x1f\\x01\\x18\\x12\\x1f\\x08P\\x07\\x8a\\x07\\x8a\\x00\\x00\\xd3\\xd6\\xc1\\xc4\\xf1\\xf8\\xf3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-01T00:00:00", "modifydate": "2018-05-01T08:50:50", "lines": 1930, "newlines": 1930, "modlines": 0, "user": "LOAD183"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "@FILE183": {"ttr": 2051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00(\\x01 5\\x0f\\x01 5\\x0f\\x14F\\x032\\x032\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-12-15T00:00:00", "modifydate": "2020-12-15T14:46:28", "lines": 818, "newlines": 818, "modlines": 0, "user": "CBT-500"}, "text": "//***FILE 183 is from Gilbert Saint-flour.  This is a collection    *   FILE 183\n//*           of utilities and other highly useful things for       *   FILE 183\n//*           system programmers to have.  The following is a       *   FILE 183\n//*           summary of this file's contents.                      *   FILE 183\n//*                                                                 *   FILE 183\n//*           We are hoping to add to this file from time to time   *   FILE 183\n//*           from Gilbert's personal libraries, to perpetuate his  *   FILE 183\n//*           memory, and to show our enormous gratefulness to him  *   FILE 183\n//*           for his devoted and skilled work.                     *   FILE 183\n//*                                                                 *   FILE 183\n//*           Sam Golob is working on Gilbert's free programs.      *   FILE 183\n//*           Carlos Aguilera is working on Gilbert's programs      *   FILE 183\n//*           written for pay.  See www.gsf-soft.com for both.      *   FILE 183\n//*                                                                 *   FILE 183\n//*           Please address all questions and inquiries to         *   FILE 183\n//*           Sam Golob.  Thanks.                                   *   FILE 183\n//*                                                                 *   FILE 183\n//*           email:  sbgolob@cbttape.org                           *   FILE 183\n//*                                                                 *   FILE 183\n//*           or to Carlos Aguilera....                             *   FILE 183\n//*                                                                 *   FILE 183\n//*           email:  carlos@gsf-soft.com                           *   FILE 183\n//*                                                                 *   FILE 183\n//*              --> LAST UPDATE: 15Dec20 (for CBT500)              *   FILE 183\n//*                                                                 *   FILE 183\n//*                .--------------------------------.               *   FILE 183\n//*                |  CBT TAPE - Index of file 183  |               *   FILE 183\n//*                '--------------------------------'               *   FILE 183\n//*                                                                 *   FILE 183\n//*        website:  http://gsf-soft.com/Freeware                   *   FILE 183\n//*                                                                 *   FILE 183\n//*  ----------------- TSO and ISPF commands -------------------    *   FILE 183\n//*                                                                 *   FILE 183\n//*  ADDTRK    The ADDTRK EDIT macro (written in REXX) that         *   FILE 183\n//*            invokes PDS86 to add a new extent to the PDS         *   FILE 183\n//*            being edited.                                        *   FILE 183\n//*                                                                 *   FILE 183\n//*  BR        TSO command - Browse most data sets under            *   FILE 183\n//*            ISPF/PDF, using BRIF.  Supports VSAM, BDAM,          *   FILE 183\n//*            multi-volume, RECFM=VBS, BLKSIZE=0, etc.             *   FILE 183\n//*                                                                 *   FILE 183\n//*            To use it, just enter BR instead of B on the         *   FILE 183\n//*            Data Set List utility screen.  BR has its own        *   FILE 183\n//*            point-and-shoot capability and can grab a dsname     *   FILE 183\n//*            on the screen, wherever the cursor is located.       *   FILE 183\n//*                                                                 *   FILE 183\n//*  CLS       A 5-line \"clear screen\" command for TSO              *   FILE 183\n//*                                                                 *   FILE 183\n//*  COMPRCMD  TSO Command Processor written in Assembler           *   FILE 183\n//*                                                                 *   FILE 183\n//*            Compress a PDS with DISP=SHR using standard ISPF     *   FILE 183\n//*            and LINK-EDIT protection.  Uses the TSO/E service    *   FILE 183\n//*            routine to invoke IEBCOPY and, therefore, does not   *   FILE 183\n//*            require any authorization of its own.  Accepts       *   FILE 183\n//*            generic dsnames (such as GSFSOFT.*) and offers a     *   FILE 183\n//*            few other options.                                   *   FILE 183\n//*                                                                 *   FILE 183\n//*  COMPRESS  The COMPRESS EDIT macro (written in REXX) that       *   FILE 183\n//*            allows you to compress the PDS you're editing        *   FILE 183\n//*            just by typing \"COMPRESS\" on the command line.       *   FILE 183\n//*                                                                 *   FILE 183\n//*  CONCAT    A REXX exec to add a data set to a concatenation.    *   FILE 183\n//*                                                                 *   FILE 183\n//*  CUT       REXX EDIT Macro - CUT & PASTE package                *   FILE 183\n//*  PASTE     REXX EDIT Macro - CUT & PASTE package                *   FILE 183\n//*  CUTPGM    Assembler program used in CUT & PASTE.               *   FILE 183\n//*  CUTHLP1   Help screen for CUT                                  *   FILE 183\n//*  CUTHLP2   Help screen for PASTE                                *   FILE 183\n//*                                                                 *   FILE 183\n//*            My own version of a classic.                         *   FILE 183\n//*            Requires MVS/ESA 4.2.2 or above.                     *   FILE 183\n//*            Uses data spaces, name/token pairs and compression.  *   FILE 183\n//*            Supports multiple clip-boards and the APPEND option. *   FILE 183\n//*                                                                 *   FILE 183\n//*  DAHANDBK  Program to create a \"handbook\" of control block      *   FILE 183\n//*            displacements from the assembly of mapping           *   FILE 183\n//*            macros.                                              *   FILE 183\n//*  DAHANDJ   Sample job to create a handbook.                     *   FILE 183\n//*                                                                 *   FILE 183\n//*  DSLIST    REXX exec - Point-and-shoot Dataset List Utility     *   FILE 183\n//*                                                                 *   FILE 183\n//*            This REXX program allows you to invoke the data      *   FILE 183\n//*            set list function of ISPF/PDF (option 3.4) with      *   FILE 183\n//*            the DSNAME LEVEL field preset to the data set name   *   FILE 183\n//*            under which the cursor is currently positionned.     *   FILE 183\n//*                                                                 *   FILE 183\n//*            DSLIST may be invoked from any ISPF screen simply    *   FILE 183\n//*            by typing:                                           *   FILE 183\n//*                                                                 *   FILE 183\n//*               TSO %DSLIST                                       *   FILE 183\n//*                                                                 *   FILE 183\n//*            on the command line, then by moving the cursor       *   FILE 183\n//*            under a data set name on your screen and pressing    *   FILE 183\n//*            \"enter\".  You may also define it as a command in     *   FILE 183\n//*            the ISPF command table, or set it up as a PFK.       *   FILE 183\n//*                                                                 *   FILE 183\n//*  DSNLIST   TSO command - returns in &var the dsnames            *   FILE 183\n//*                          allocated to &ddn                      *   FILE 183\n//*            Example:                                             *   FILE 183\n//*                                                                 *   FILE 183\n//*              ALLOC DD(SYSPROC) SHR -                            *   FILE 183\n//*                    DS('IPO1.CMDPROC' 'GSFSOFT.CLIST')           *   FILE 183\n//*              DSNLIST DDNAME(SYSPROC) SETVAR(VAR2)               *   FILE 183\n//*                                                                 *   FILE 183\n//*              is equivalent to:                                  *   FILE 183\n//*                                                                 *   FILE 183\n//*              SET VAR2 = 'IPO1.CMDPROC' 'GSFSOFT.CLIST'          *   FILE 183\n//*                                                                 *   FILE 183\n//*  EXECPGM   TSO command - invoke a utility program or compiler   *   FILE 183\n//*            with an alternate ddname list, as follows:           *   FILE 183\n//*               EXECPGM IEV90           +                         *   FILE 183\n//*                 PARM(NOOBJECT,NODECK,NOXREF,NORLD) +            *   FILE 183\n//*                 SYSIN(TEMPWK2)        +                         *   FILE 183\n//*                 SYSUT1(TEMPWK1)       +                         *   FILE 183\n//*                 SYSLIB(ASMLIB)        +                         *   FILE 183\n//*                 SYSPRINT(ASMH$PRT)    +                         *   FILE 183\n//*                 STEPLIB(LINKLIST)                               *   FILE 183\n//*                                                                 *   FILE 183\n//*  EXECUTE   REXX EXEC - Run an in-stream EXEC or CLIST in a TSO  *   FILE 183\n//*            batch job, or execute EDIT data as a CLIST or EXEC.  *   FILE 183\n//*                                                                 *   FILE 183\n//*  FASTPATH  This assembler program allows the use of fast-path   *   FILE 183\n//*            commands without requiring customization of the      *   FILE 183\n//*            ISPF environment.                                    *   FILE 183\n//*            Fastpath provides two types of functions:            *   FILE 183\n//*            (Correct mistake in SHOWzOS ISPF table invocation)   *   FILE 183\n//*                                                                 *   FILE 183\n//*            1. Initialization                                    *   FILE 183\n//*              a. add 20 fast-path commands to the user's         *   FILE 183\n//*                 in-storage copy of ISPCMDS                      *   FILE 183\n//*              b. pre-load specific modules to enhance            *   FILE 183\n//*                 performance and allow access from a private     *   FILE 183\n//*                 LOAD library                                    *   FILE 183\n//*              c. issue STIMER to prevent S522 time-out abends    *   FILE 183\n//*            2. Processing                                        *   FILE 183\n//*              a. invoke EDIT, BROWSE, VIEW, WorkPlace and SDSF   *   FILE 183\n//*                 with the appropriate NEWAPPL parameter          *   FILE 183\n//*              b. store and retrieve parameters associated        *   FILE 183\n//*                 with user-specified tags                        *   FILE 183\n//*              c. retrieve a dsname under which the cursor        *   FILE 183\n//*                 is positioned and invoke EDIT, BROWSE,          *   FILE 183\n//*                 VIEW or the Workplace                           *   FILE 183\n//*              d. Edit your ISPCTLn or SPFTEMPn.CNTL data set     *   FILE 183\n//*              e. View a member in SYS1.MACLIB or SYS1.MODGEN     *   FILE 183\n//*              f. TSO Full-screen                                 *   FILE 183\n//*              g. misc others                                     *   FILE 183\n//*                                                                 *   FILE 183\n//*  FASTPDOC  Documentation for the FASTPATH utility               *   FILE 183\n//*            http://gsf-soft.com/Freeware/FASTPATH.shtml          *   FILE 183\n//*                                                                 *   FILE 183\n//*  FASTNOTE  Note from Sam Golob about invoking FASTPATH          *   FILE 183\n//*                                                                 *   FILE 183\n//*  FASTP149  Previous version of FASTPATH utility                 *   FILE 183\n//*                                                                 *   FILE 183\n//*  FILE183   CLIST to provide an easy access to REXX execs and    *   FILE 183\n//*            programs distributed in this library                 *   FILE 183\n//*            http://gsf-soft.com/Freeware/FILE183.shtml           *   FILE 183\n//*                                                                 *   FILE 183\n//*  FREEDIR   The FREEDIR EDIT macro (written in REXX) invokes     *   FILE 183\n//*            PDS86 to add or delete directory blocks to change    *   FILE 183\n//*            the size of the directory of the PDS being edited.   *   FILE 183\n//*                                                                 *   FILE 183\n//*  FSHELP    REXX EXEC - Full-screen TSO HELP which uses STEMVIEW *   FILE 183\n//*            to display the output produced by the TSO HELP cmd.  *   FILE 183\n//*                                                                 *   FILE 183\n//*  FULLDSN   REXX Function - return the real dsname of an alias   *   FILE 183\n//*            or the fully-qualified dsname from a relative        *   FILE 183\n//*            generation.                                          *   FILE 183\n//*                                                                 *   FILE 183\n//*  FTP       REXX EDIT Macro - Transmit the data being edited     *   FILE 183\n//*            using text-mode FTP                                  *   FILE 183\n//*                                                                 *   FILE 183\n//*  IKJEFLN2  TSO/E Logon Exit - enable the Reconnect option       *   FILE 183\n//*            in the TN3270 environment.                           *   FILE 183\n//*                                                                 *   FILE 183\n//*  INITKSDS  Initialize a KSDS after it's been DEFINE'd           *   FILE 183\n//*                                                                 *   FILE 183\n//*            This program prevents OPEN from failing when         *   FILE 183\n//*            opening with MACRF=(IN,OUT) or STRNO=2 a KSDS        *   FILE 183\n//*            that has just been defined.  Can be invoked as       *   FILE 183\n//*            a batch program, a TSO command, or a sub-routine.    *   FILE 183\n//*                                                                 *   FILE 183\n//*  IPADDR    REXX exec - retrieve the IP address associated with  *   FILE 183\n//*            a VTAM terminal using NETSTAT TELNET.                *   FILE 183\n//*                                                                 *   FILE 183\n//*  IRXEHCIR  Interface to IKJEHCIR for REXX and COBOL             *   FILE 183\n//*                                                                 *   FILE 183\n//*            This small assembler program allows a REXX EXEC      *   FILE 183\n//*            or a COBOL program to invoke IKJEHCIR, the TSO/E     *   FILE 183\n//*            Catalog Information Routine.                         *   FILE 183\n//*                                                                 *   FILE 183\n//*  ISPTASK   Program - prevent S522 abends while in ISPF          *   FILE 183\n//*                                                                 *   FILE 183\n//*            Just link it into your ISPLLIB or STEPLIB, then      *   FILE 183\n//*            re-enter ISPF, and you won't time out any more.      *   FILE 183\n//*                                                                 *   FILE 183\n//*            Also preloads some ISRxxxx modules for               *   FILE 183\n//*            performance, even if they're in PLPA (YES,           *   FILE 183\n//*            in ESA 4.3, you can pre-load PLPA modules!!)         *   FILE 183\n//*                                                                 *   FILE 183\n//*  ISREDIT2  Program - speed up EDIT macros                       *   FILE 183\n//*                                                                 *   FILE 183\n//*            Executed once at the beginning of an EDIT macro.     *   FILE 183\n//*                                                                 *   FILE 183\n//*  LC        REXX EXEC - Full-screen IDCAMS LISTCAT               *   FILE 183\n//*                                                                 *   FILE 183\n//*            This TSO/ISPF REXX EXEC invokes IDCAMS then          *   FILE 183\n//*            invokes STEMVIEW to display the output.              *   FILE 183\n//*                                                                 *   FILE 183\n//*            To use it, just enter LC as a line command on the    *   FILE 183\n//*            Data Set List (3.4) or the WorkPlace (11) Utility    *   FILE 183\n//*            screens                                              *   FILE 183\n//*                                                                 *   FILE 183\n//*  LCAT      TSO command - Full-screen IDCAMS LISTCAT             *   FILE 183\n//*                                                                 *   FILE 183\n//*            This TSO/ISPF command invokes IDCAMS then            *   FILE 183\n//*            uses BRIF to display the output.                     *   FILE 183\n//*                                                                 *   FILE 183\n//*            To use it, just enter LCAT as a line command         *   FILE 183\n//*            on the Data Set List Utility screen.                 *   FILE 183\n//*                                                                 *   FILE 183\n//*  LCAT92    TSO command - Full-screen IDCAMS LISTCAT             *   FILE 183\n//*            1992 version of LCAT for OS/390 R2 and older         *   FILE 183\n//*                                                                 *   FILE 183\n//*  LLIBDEF1  Prevent some S806-4 abends when using LIBDEF with    *   FILE 183\n//*            ISPLLIB                                              *   FILE 183\n//*                                                                 *   FILE 183\n//*            This program allows you to pre-load a REUS or        *   FILE 183\n//*            RENT module from a LOAD library defined via          *   FILE 183\n//*            LIBDEF.  This can prevent S806-4 abends that         *   FILE 183\n//*            occur when a program that is not LIBDEF-aware        *   FILE 183\n//*            tries to access another program via LOAD or LINK.    *   FILE 183\n//*                                                                 *   FILE 183\n//*  LISTDSI   REXX EXEC - Display output of LISTDSI function       *   FILE 183\n//*                                                                 *   FILE 183\n//*            This EXEC helps the REXX programmer implement        *   FILE 183\n//*            the LISTDSI function by displaying the value of      *   FILE 183\n//*            all of the variables returned by LISTDSI for the     *   FILE 183\n//*            specified data set, as well as providing the         *   FILE 183\n//*            syntax, return codes and reason codes in the         *   FILE 183\n//*            form of comments at the end of the source.           *   FILE 183\n//*                                                                 *   FILE 183\n//*  LOCKTERM  TSO command written in assembler.                    *   FILE 183\n//*            Lock TSO terminal, enter LOGON password to unlock.   *   FILE 183\n//*            (Fixed April 2016 by Garry Green.)                   *   FILE 183\n//*            (Adjusted to show 8-character userids.)              *   FILE 183\n//*                                                                 *   FILE 183\n//*  LPA24     REXX EXEC - Display PLPA usage below the 16MB line   *   FILE 183\n//*                                                                 *   FILE 183\n//*  LPR       REXX EDIT Macro - Print the data being edited        *   FILE 183\n//*            using TCP/IP's LPR command                           *   FILE 183\n//*                                                                 *   FILE 183\n//*  LVL       REXX EDIT macro - Compress Level Numbers for         *   FILE 183\n//*            FB-80 PDS members with STATS ON and NUMBER STD.      *   FILE 183\n//*                                                                 *   FILE 183\n//*            LVL reuses \"gas levels\", i.e. levels which           *   FILE 183\n//*            are not used in any record in the member,            *   FILE 183\n//*            and adjusts pos 79-80 of the records accordingly.    *   FILE 183\n//*                                                                 *   FILE 183\n//*            If the macro invocation includes a number,           *   FILE 183\n//*            then levels up to the specified number are           *   FILE 183\n//*            reset to zero.                                       *   FILE 183\n//*                                                                 *   FILE 183\n//*  NEWAPPL   REXX EXEC - Start a new ISPF application using       *   FILE 183\n//*            LIBDEF and ALTLIB.                                   *   FILE 183\n//*                                                                 *   FILE 183\n//*  OBEYFILE  EDIT Macro written in REXX - Allows the TCP/IP       *   FILE 183\n//*            administrator to use the data being edited as        *   FILE 183\n//*            input to the TCP/IP OBEYFILE command without         *   FILE 183\n//*            having to SAVE it.                                   *   FILE 183\n//*                                                                 *   FILE 183\n//*  RESET5    Initial EDIT macro that issues a \"RESET\" command     *   FILE 183\n//*                                                                 *   FILE 183\n//*            Type \"IMACRO !RESET\" once, and you won't be          *   FILE 183\n//*            bothered by these annoying messages anymore.         *   FILE 183\n//*                                                                 *   FILE 183\n//*  REXXTRY   TSO command processor written in assembler.          *   FILE 183\n//*                                                                 *   FILE 183\n//*            REXXTRY can be used in a CLIST or in ISPF to         *   FILE 183\n//*            execute a one-line REXX exec as a sub-routine.       *   FILE 183\n//*            The REXX exec can be a single REXX instruction or    *   FILE 183\n//*            multiple instructions separated by semi-colons.      *   FILE 183\n//*                                                                 *   FILE 183\n//*            REXXTRY can also be invoked in batch mode, in which  *   FILE 183\n//*            case the REXX code is not specified as an argument   *   FILE 183\n//*            to the command, but consists on all the input lines  *   FILE 183\n//*            present after the REXXTRY command in SYSTSIN.        *   FILE 183\n//*                                                                 *   FILE 183\n//*  ROUTE     REXX EDIT Macro - Print the data being edited.       *   FILE 183\n//*  ROUTEPGM  Assembler program used in ROUTE to speed things up   *   FILE 183\n//*  ROUTEHLP  Help screen                                          *   FILE 183\n//*                                                                 *   FILE 183\n//*            This edit macro writes the data you're editing to    *   FILE 183\n//*            a SYSOUT data set, with the CLASS and DEST you       *   FILE 183\n//*            specify, a title line and 60 lines per page.         *   FILE 183\n//*            Works with EDIF because what gets printed is the     *   FILE 183\n//*            data being edited, NOT the data stored on disk.      *   FILE 183\n//*                                                                 *   FILE 183\n//*  RXSMS     Assembler program; can be invoked in a REXX exec     *   FILE 183\n//*            to retrieve information from the SMS sub-system      *   FILE 183\n//*            or from a volume's VTOC.                             *   FILE 183\n//*                                                                 *   FILE 183\n//*  SFE       REXX program to invoke the Search-For Extended       *   FILE 183\n//*            utility.  Can be invoked from the Data Set List      *   FILE 183\n//*            panel or as an EDIT macro.                           *   FILE 183\n//*                                                                 *   FILE 183\n//*  SHOWDASD  ISPF Dialog to display on-line DASD devices.         *   FILE 183\n//*            (fixed for 64-bit ULUT - ULUT Type 3)                *   FILE 183\n//*            (also works on older systems, so it supersedes       *   FILE 183\n//*            the older version - member SHOWDAS1)                 *   FILE 183\n//*                                                                 *   FILE 183\n//*  SHOWDPNL  Requires the RXSMS program.                          *   FILE 183\n//*                                                                 *   FILE 183\n//*  SHOWVTOC  Panel for option V                                   *   FILE 183\n//*                                                                 *   FILE 183\n//*  SHOWJPAQ  TSO command - Display contents of Job Pack Area      *   FILE 183\n//*            Queue (JPAQ)                                         *   FILE 183\n//*                                                                 *   FILE 183\n//*  SHOWTIOT  REXX exec - Display contents of Task Input-Output    *   FILE 183\n//*            Table (TIOT)                                         *   FILE 183\n//*                                                                 *   FILE 183\n//*  STEMEDIT  REXX sub-routine written in assembler.               *   FILE 183\n//*            Browse, View or Edit stem variables using BRIF,      *   FILE 183\n//*            VIIF or EDIF.  A nice addition to OUTTRAP.           *   FILE 183\n//*            View data from the stack also. ISPF V5 only.         *   FILE 183\n//*                                                                 *   FILE 183\n//*     Note:  An update to STEMEDIT, and some other modificatons,  *   FILE 183\n//*            was written by Rainer Nowak, and is included in      *   FILE 183\n//*            this pds, as member STEMEDI#.  This member was also  *   FILE 183\n//*            repeated on the CBT Tape, as File 895.               *   FILE 183\n//*                                                                 *   FILE 183\n//*  STEMVIEW  REXX sub-routine written in assembler.               *   FILE 183\n//*            Browse or View stem variables using BRIF or EDIF.    *   FILE 183\n//*            View data from the stack also. ISPF V2, V3, V4.      *   FILE 183\n//*                                                                 *   FILE 183\n//*  SWAREQ    REXX exec - Convert an SVA to a 31-bit address       *   FILE 183\n//*                                                                 *   FILE 183\n//*  SWAREQ22  REXX exec - Convert an SVA to a 31-bit address on    *   FILE 183\n//*            a z/OS 2.2 system or higher.  (from Don Poitras)     *   FILE 183\n//*                                                                 *   FILE 183\n//*  TALLY     REXX exec for ISPF 3.4 - Display the total number of *   FILE 183\n//*            tracks used up by the data sets on the DSLIST panel. *   FILE 183\n//*                                                                 *   FILE 183\n//*  TLMS      Display a VMF record under PDF 3.4                   *   FILE 183\n//*                                                                 *   FILE 183\n//*            This program reads the VMF record for the            *   FILE 183\n//*            first volume of a tape data set, formats it          *   FILE 183\n//*            pretty much like the CATLTSO command, then           *   FILE 183\n//*            invokes BRIF to display the result.  May only        *   FILE 183\n//*            be used as a line command on the Data Set            *   FILE 183\n//*            List panel (Option 3.4 of ISPF/PDF).                 *   FILE 183\n//*                                                                 *   FILE 183\n//*  TMS       Display a TMC record under PDF 3.4                   *   FILE 183\n//*            Same as TLMS, but for CA1/TMS 5.0                    *   FILE 183\n//*                                                                 *   FILE 183\n//*  VALLOC    Generate ALLOCATE commands for data set list         *   FILE 183\n//*                                                                 *   FILE 183\n//*            EDIT macro written in REXX.  Reads a list of data    *   FILE 183\n//*            set names starting in pos 1 of each line and         *   FILE 183\n//*            generates a set of corresponding ALLOCATE commands.  *   FILE 183\n//*                                                                 *   FILE 183\n//*  VARS      TSO/ISPF command written in REXX.                    *   FILE 183\n//*            Display in-storage ISPF vars.                        *   FILE 183\n//*                                                                 *   FILE 183\n//*  VDL       TSO/ISPF command written in REXX.  VIEW Data set     *   FILE 183\n//*            List: makes the list of data set created by DSLIST   *   FILE 183\n//*            available as data in a VIEW session.                 *   FILE 183\n//*                                                                 *   FILE 183\n//*  VML       TSO/ISPF command - Read the directory of the         *   FILE 183\n//*            specified PDS and VIEW the Member List               *   FILE 183\n//*                                                                 *   FILE 183\n//*  VSAMVIEW  TSO/ISPF command - View a VSAM data set using VIIF   *   FILE 183\n//*                                                                 *   FILE 183\n//*  VSAMVW95  1995 version of VSAMVIEW for ISPF V2, V3 and V4.     *   FILE 183\n//*                                                                 *   FILE 183\n//*  VSAVE     ISPF EDIT macro - Save a member in VIEW mode         *   FILE 183\n//*                                                                 *   FILE 183\n//*  WHEREIS   REXX EXEC - Look for all occurences of a member in   *   FILE 183\n//*            the libraries currently allocated to your TSO        *   FILE 183\n//*            session.  If multiple versions of the member are     *   FILE 183\n//*            present in a concatenation, they are all shown,      *   FILE 183\n//*            along with their ISPF stats, when present.           *   FILE 183\n//*                                                                 *   FILE 183\n//*  WHOAMI    REXX EXEC - Displays the user-ID and system-ID       *   FILE 183\n//*            in large letters, plus a few other things            *   FILE 183\n//*                                                                 *   FILE 183\n//*  WP        REXX exec - Invoke the Work-place from DSLIST.       *   FILE 183\n//*                                                                 *   FILE 183\n//*  XDELETE   REXX exec - Delete data sets \"en masse\" using a      *   FILE 183\n//*            generic filter such as \"ABC*.D%.**.E%F*GH.*.TEMP\".   *   FILE 183\n//*                                                                 *   FILE 183\n//*  XRENAME   REXX exec - Rename data sets \"en masse\"              *   FILE 183\n//*                                                                 *   FILE 183\n//*  XDEL      REXX EDIT macro - Delete current member              *   FILE 183\n//*                                                                 *   FILE 183\n//*  XREN      REXX EDIT macro - Rename current member              *   FILE 183\n//*                                                                 *   FILE 183\n//*  ------------------ Batch Programs --------------------------   *   FILE 183\n//*                                                                 *   FILE 183\n//*  BLKSIZE2  Scan a PDS and print the size of each block and      *   FILE 183\n//*            the track balance                                    *   FILE 183\n//*                                                                 *   FILE 183\n//*            This is a batch program, for people interested       *   FILE 183\n//*            in what a PDS looks like, from the inside.           *   FILE 183\n//*                                                                 *   FILE 183\n//*  BYPASSNQ  Assembler program.  Scratch or Rename a Data Set     *   FILE 183\n//*            without SYSDSN ENQ                                   *   FILE 183\n//*                                                                 *   FILE 183\n//*            BYPASSNQ is a driver that allows you to run any      *   FILE 183\n//*            utility program (such as IEHPROGM or IDCAMS) and     *   FILE 183\n//*            bypass dsname ENQ that is normally performed by      *   FILE 183\n//*            the DYNALLOC, SCRATCH and RENAME SVCs.               *   FILE 183\n//*            This technique allows data sets to be deleted or     *   FILE 183\n//*            renamed using standard MVS services and is fully     *   FILE 183\n//*            compatible with indexed VTOCs and SMS.               *   FILE 183\n//*                                                                 *   FILE 183\n//*  CANMSGCL  Purge current job's held output after a few hours.   *   FILE 183\n//*            Useful for those jobs that work OK 99% of the time   *   FILE 183\n//*            (must be authorized)                                 *   FILE 183\n//*                                                                 *   FILE 183\n//*            Example:                                             *   FILE 183\n//*                                                                 *   FILE 183\n//*              //MYJOB    JOB ACCT#,CLASS=A,MSGCLASS=X            *   FILE 183\n//*              //COPY1   EXEC PGM=IEBCOPY                         *   FILE 183\n//*              //...      DD   ...                                *   FILE 183\n//*              //CONDPURG EXEC PGM=CANMSGCL,PARM=2,               *   FILE 183\n//*              //              COND=(0,NE,COPY1)                  *   FILE 183\n//*                                                                 *   FILE 183\n//*              The number in the parm is a number of hours.       *   FILE 183\n//*              If the 'COPY1' step ends at 10:28 with a           *   FILE 183\n//*              return code equal to zero, the 'CONDPURG' step     *   FILE 183\n//*              executes and issues the following command:         *   FILE 183\n//*                                                                 *   FILE 183\n//*                $TA,T=12.28,'$OJ01234,Q=X,CANCEL'                *   FILE 183\n//*                                                                 *   FILE 183\n//*  COB2JOB   Retrieve Job-related information in COBOL            *   FILE 183\n//*                                                                 *   FILE 183\n//*  COB2SYS   Retrieve System-related information in COBOL         *   FILE 183\n//*                                                                 *   FILE 183\n//*  COB2TSO   Issue TSO commands in COBOL                          *   FILE 183\n//*                                                                 *   FILE 183\n//*  CLEANUP   Assembler program.  Automatically searches the MVS   *   FILE 183\n//*            catalog for non-GDG data sets that will be created   *   FILE 183\n//*            in subsequent steps of your job and deletes them.    *   FILE 183\n//*            HSM-migrated data sets are deleted with HDELETE.     *   FILE 183\n//*                                                                 *   FILE 183\n//*                  //MYJOB   JOB  acct#                           *   FILE 183\n//*                  //*                                            *   FILE 183\n//*                  //CLEANUP EXEC PGM=CLEANUP                     *   FILE 183\n//*                  //*                                            *   FILE 183\n//*                  //STEP1   EXEC PGM=MYPROG1                     *   FILE 183\n//*                  //OUTDD    DD  DSN=MY.FILE1,DISP=(,CATLG)      *   FILE 183\n//*                  //STEP2   EXEC PGM=MYPROG2                     *   FILE 183\n//*                  //OUTDD    DD  DSN=MY.FILE2,DISP=(,CATLG)      *   FILE 183\n//*                                                                 *   FILE 183\n//*            Can also be executed as the LAST step of a job to    *   FILE 183\n//*            delete non-GDG data sets that were created during    *   FILE 183\n//*            job execution.                                       *   FILE 183\n//*                                                                 *   FILE 183\n//*  CMDJ      Send a JES2 command with the current job's number    *   FILE 183\n//*            (must be authorized)                                 *   FILE 183\n//*                                                                 *   FILE 183\n//*            Example:                                             *   FILE 183\n//*                                                                 *   FILE 183\n//*               //PURGEJOB EXEC PGM=CMDJES2,PARM=P                *   FILE 183\n//*                                                                 *   FILE 183\n//*            If the current job's number is JOB01234,             *   FILE 183\n//*            then the following command is issued:                *   FILE 183\n//*                                                                 *   FILE 183\n//*                  $PJ  01234                                     *   FILE 183\n//*                                                                 *   FILE 183\n//*  DCODADDR  Assembler module to convert an address passed by     *   FILE 183\n//*            its invoker into a character string that indicates   *   FILE 183\n//*            what module, CSECT within the module, and offset     *   FILE 183\n//*            within the CSECT the address points to.              *   FILE 183\n//*              DCODADDR uses the Binder API and can be invoked    *   FILE 183\n//*            by recovery routines or any other modules.           *   FILE 183\n//*                                                                 *   FILE 183\n//*  DONTFAIL  Prevent job failure caused by uncataloged data       *   FILE 183\n//*            sets (ESA only, must be authorized)                  *   FILE 183\n//*                                                                 *   FILE 183\n//*  GSFLKED   Front-end to the linkage editor to recover           *   FILE 183\n//*            from SD37 on SYSLMOD (must be authorized)            *   FILE 183\n//*                                                                 *   FILE 183\n//*            This program may be invoked instead of the DFP       *   FILE 183\n//*            linkage editor. It calls the linkage editor and,     *   FILE 183\n//*            if an SD37 abend occurs, calls IEBCOPY to compress   *   FILE 183\n//*            the SYSLMOD PDS, then calls the linkage editor       *   FILE 183\n//*            again.                                               *   FILE 183\n//*                                                                 *   FILE 183\n//*            Another feature of this program is to                *   FILE 183\n//*            conditionally append a PDS member to SYSLIN, if      *   FILE 183\n//*            that member exists.                                  *   FILE 183\n//*                                                                 *   FILE 183\n//*  ISGECMON  Assemble and Link Job for SYS1.SAMPLIB(ISGECMON)     *   FILE 183\n//*                                                                 *   FILE 183\n//*            The ISGECMON program runs as a never ending task     *   FILE 183\n//*            that checks dataset contention at periodic           *   FILE 183\n//*            intervals and sends messages to TSO users asking     *   FILE 183\n//*            them to free datasets that are causing contention.   *   FILE 183\n//*                                                                 *   FILE 183\n//*  JOBRLSE   Release a job by number (must be authorized)         *   FILE 183\n//*                                                                 *   FILE 183\n//*            This program issues a $A command to release a job    *   FILE 183\n//*            previously submitted to JES2 with \"TYPRUN=HOLD\".     *   FILE 183\n//*                                                                 *   FILE 183\n//*            To prevent \"multiple jobs found\" conditions,         *   FILE 183\n//*            this program uses the sub-system interface           *   FILE 183\n//*            to inquire about the status of homonym jobs.         *   FILE 183\n//*            Then, it issues a $A command with the job            *   FILE 183\n//*            number of the first job found in the input           *   FILE 183\n//*            queue in held status (for example: $A J1234).        *   FILE 183\n//*                                                                 *   FILE 183\n//*            Sample execution JCL:                                *   FILE 183\n//*                                                                 *   FILE 183\n//*              //RLSENEXT EXEC PGM=JOBRLSE,PARM=PAYROL22          *   FILE 183\n//*                                                                 *   FILE 183\n//*  LINKLLA   Link-edit and refresh LLA in a single step           *   FILE 183\n//*            (MVS/ESA only, must be authorized)                   *   FILE 183\n//*                                                                 *   FILE 183\n//*            Invokes the linkage-editor, then issues LLACOPY      *   FILE 183\n//*            for the member specified on the //SYSLMOD DD.        *   FILE 183\n//*            If there is no //SYSLIN DD in the step's JCL,        *   FILE 183\n//*            issues LLACOPY for the member on //SYSLMOD,          *   FILE 183\n//*            or for all of the members in the //SYSLMOD           *   FILE 183\n//*            library if no member name has been specified.        *   FILE 183\n//*                                                                 *   FILE 183\n//*  LOADMLPA  Load a reentrant module into the MLPA                *   FILE 183\n//*            (must be authorized)                                 *   FILE 183\n//*                                                                 *   FILE 183\n//*            This program allows you to load a RENT module        *   FILE 183\n//*            from an authorized library into the MLPA.            *   FILE 183\n//*            Also supports the DELETE function to undo            *   FILE 183\n//*            LOAD.  Invoker must have update authority to         *   FILE 183\n//*            SYS1.PARMLIB.                                        *   FILE 183\n//*                                                                 *   FILE 183\n//*            This program has been designed to prevent jobs       *   FILE 183\n//*            that accept multiple inputs from failing in the      *   FILE 183\n//*            middle of the night because of a \"typo\" in a data    *   FILE 183\n//*            set name.  When DONTFAIL detects that an input       *   FILE 183\n//*            data set is not cataloged, it converts it to a       *   FILE 183\n//*            null data set and allows the job to run with         *   FILE 183\n//*            partial input.                                       *   FILE 183\n//*                                                                 *   FILE 183\n//*  PACKOFF   Unpack a file packed by ISPF/PDF or XEDIT            *   FILE 183\n//*                                                                 *   FILE 183\n//*            This is a sample program that reads                  *   FILE 183\n//*            fixed-length records and unpacks them.               *   FILE 183\n//*                                                                 *   FILE 183\n//*  PLI2JOB   Retrieve Job-related information in PL/I             *   FILE 183\n//*                                                                 *   FILE 183\n//*  PLI2TSO   Issue TSO commands in PL/I                           *   FILE 183\n//*                                                                 *   FILE 183\n//*  RECALL    Batch program - Issues HRECALL commands for every    *   FILE 183\n//*            migrated data sets used in subsequent steps of the   *   FILE 183\n//*            JOB in which it is executed.  Pre-staging data       *   FILE 183\n//*            sets in this manner reduces HSM tape mount           *   FILE 183\n//*            activity.                                            *   FILE 183\n//*                                                                 *   FILE 183\n//*  SCANMODL  This assembler module loads a control-block map      *   FILE 183\n//*            from SYS1.MIGLIB and returns the offset & length     *   FILE 183\n//*            of a field.  It is used to write programs that       *   FILE 183\n//*            access JES2 control blocks without using HASPSRC     *   FILE 183\n//*            and consequently, are release-independent.           *   FILE 183\n//*                                                                 *   FILE 183\n//*  SVCUPDTE  Install a type-3 SVC routine (must be authorized)    *   FILE 183\n//*                                                                 *   FILE 183\n//*            This program installs an SVC routine from PLPA,      *   FILE 183\n//*            MLPA, or from an authorized library.                 *   FILE 183\n//*            The installation can be permanent or temporary.      *   FILE 183\n//*            If the installation is temporary, SVCUPDTE waits     *   FILE 183\n//*            until a STOP or CANCEL command is issued, then       *   FILE 183\n//*            restores the old SVC entry and terminates.           *   FILE 183\n//*                                                                 *   FILE 183\n//*            PARM=(nnn,mmmmmmm,hhmm,userid)                       *   FILE 183\n//*                                                                 *   FILE 183\n//*              nnn is the SVC number you want to install;         *   FILE 183\n//*              you must specify a 3-digit number                  *   FILE 183\n//*                                                                 *   FILE 183\n//*              mmmmmmmm is the name of a load module (or alias)   *   FILE 183\n//*              that you want to install as SVC nnn;  it MUST      *   FILE 183\n//*              come from an authorized library (STEPLIB or        *   FILE 183\n//*              link-list)                                         *   FILE 183\n//*                                                                 *   FILE 183\n//*              hhmm is the optional automatic shut-down time,     *   FILE 183\n//*              in 24-hour clock format.  When the specified       *   FILE 183\n//*              time is reached, SVCUPDTE automatically stops.     *   FILE 183\n//*                                                                 *   FILE 183\n//*              userid is the optional userid that will be given   *   FILE 183\n//*              access to the new SVC.  Jobs submitted by other    *   FILE 183\n//*              users will keep on using the old SVC.              *   FILE 183\n//*                                                                 *   FILE 183\n//*  SYSMOVE   Unload a PDS to a sequential data set in             *   FILE 183\n//*            IEHMOVE format.  Compatible with SMS.                *   FILE 183\n//*                                                                 *   FILE 183\n//*  UNITAFF   Dynamically sets UNIT=AFF for input tape files       *   FILE 183\n//*            (must be authorized)                                 *   FILE 183\n//*                                                                 *   FILE 183\n//*            This program was originally designed to reduce       *   FILE 183\n//*            the number of tape drives used by user-submitted     *   FILE 183\n//*            SAS steps.  It scans the SWA for the next step       *   FILE 183\n//*            and changes some of the SIOT's fields to force       *   FILE 183\n//*            all input tape data sets to the same drive.          *   FILE 183\n//*                                                                 *   FILE 183\n//*            It must be executed immediately before the           *   FILE 183\n//*            step to process (SAS, SORT, or any other             *   FILE 183\n//*            program that reads a variable number of tape         *   FILE 183\n//*            files, one at a time).                               *   FILE 183\n//*                                                                 *   FILE 183\n//*            Sample jcl:                                          *   FILE 183\n//*                                                                 *   FILE 183\n//*              //UNITAFF EXEC PGM=UNITAFF                         *   FILE 183\n//*              //STEPLIB  DD  DSN=SYS2.AUTHLIB,DISP=SHR           *   FILE 183\n//*              //*                                                *   FILE 183\n//*              //STEP53  EXEC PGM=SAS                             *   FILE 183\n//*              //OSIN     DD DSN=USER1.X,DISP=SHR                 *   FILE 183\n//*              //         DD DSN=UPQE.DQE40530(-1),DISP=SHR       *   FILE 183\n//*              //OSIN2    DD DSN=UPQR.DQR02150(0),DISP=SHR        *   FILE 183\n//*              //OSIN3    DD DSN=USER1.X,DISP=SHR                 *   FILE 183\n//*              //         DD DSN=UPBG.DBGA0240(-1),DISP=SHR       *   FILE 183\n//*              //OSIN4    DD DSN=USER1.X,DISP=SHR                 *   FILE 183\n//*              //         DD DSN=USER1.YY,DISP=SHR                *   FILE 183\n//*              //         DD DSN=UPQR.DQR02140(-1),DISP=SHR       *   FILE 183\n//*                                                                 *   FILE 183\n//*            The program only supports cataloged data sets;       *   FILE 183\n//*            relative generation numbers are handled              *   FILE 183\n//*            correctly via the GDGNT.                             *   FILE 183\n//*                                                                 *   FILE 183\n//*            Restriction: No distinction is made between 3420,    *   FILE 183\n//*            3480 or 3490 device types; this will cause           *   FILE 183\n//*            problems if the input to a step is mixed.            *   FILE 183\n//*                                                                 *   FILE 183\n//*                                                                 *   FILE 183\n//*  ------------------ Assembler Macros ------------------------   *   FILE 183\n//*                                                                 *   FILE 183\n//*  BUILDCDE  Make storage allocated with GETMAIN appear as a      *   FILE 183\n//*            load-module in a dump.                               *   FILE 183\n//*                                                                 *   FILE 183\n//*            BUILDCDE uses the \"loader\" form of IDENTIFY to       *   FILE 183\n//*            create a major CDE and corresponding XL, then        *   FILE 183\n//*            issues a LOAD SVC to create an LLE and associate     *   FILE 183\n//*            the CDE with the current TCB.  Don't worry, you      *   FILE 183\n//*            don't have to understand how it works to use it.     *   FILE 183\n//*                                                                 *   FILE 183\n//*            EXAMPLE:                                             *   FILE 183\n//*                                                                 *   FILE 183\n//*                  GETMAIN RU,LV=20000                            *   FILE 183\n//*                  BUILDCDE LENGTH=(0),ADDR=(1),EP=DYNAM20        *   FILE 183\n//*                                                                 *   FILE 183\n//*            The 20K storage area will appear in a dump           *   FILE 183\n//*            as a load-module called \"DYNAM20\".                   *   FILE 183\n//*                                                                 *   FILE 183\n//*  EASYSORT  Invoke an internal SORT with OPEN/PUT/GET logic      *   FILE 183\n//*                                                                 *   FILE 183\n//*            Allows you to do internal sorts without any          *   FILE 183\n//*            knowledge of parameter lists or exit routine         *   FILE 183\n//*            linkage conventions.                                 *   FILE 183\n//*                                                                 *   FILE 183\n//*            Example:                                             *   FILE 183\n//*                                                                 *   FILE 183\n//*                      EASYSORT OPEN,                             *   FILE 183\n//*                            FIELDS=(1,22,CH,A),                  *   FILE 183\n//*                            TYPE=F,LENGTH=64,                    *   FILE 183\n//*                            OPTION='EQUALS,RESINV=500K'          *   FILE 183\n//*                      .     .                                    *   FILE 183\n//*              READ    GET   FILEIN                               *   FILE 183\n//*                      EASYSORT PUT,(1)   pass record to SORT     *   FILE 183\n//*                      B     READ                                 *   FILE 183\n//*                      .     .                                    *   FILE 183\n//*              REWRITE EASYSORT GET,      get sorted record       *   FILE 183\n//*                            SET=(R3),                            *   FILE 183\n//*                            EODAD=ENDSORT                        *   FILE 183\n//*                      PUT   FILEOUT,(R3)                         *   FILE 183\n//*                      B     REWRITE                              *   FILE 183\n//*                      .     .                                    *   FILE 183\n//*              ENDSORT EASYSORT CLOSE                             *   FILE 183\n//*                                                                 *   FILE 183\n//*  GETDIR    Read a directory sequentially with a BPAM DCB        *   FILE 183\n//*                                                                 *   FILE 183\n//*            This macro offers a simple way to read directory     *   FILE 183\n//*            entries and members with a single BPAM DCB.          *   FILE 183\n//*                                                                 *   FILE 183\n//*  GETPUT31  Issue GET, PUT or PUTX while in AMODE31              *   FILE 183\n//*                                                                 *   FILE 183\n//*            This member contains GET31, PUT31 and PUTX31,        *   FILE 183\n//*            which are modified versions of GET, PUT and          *   FILE 183\n//*            PUTX.  They allow a program running with             *   FILE 183\n//*            RMODE24 and AMODE31 to issue QSAM GET, PUT and       *   FILE 183\n//*            PUTX without having to switch to AMODE24.            *   FILE 183\n//*            GET31 allows specification of an end-of-file         *   FILE 183\n//*            routine (EODAD).                                     *   FILE 183\n//*                                                                 *   FILE 183\n//*  STRING    Provides functions similar to PL/I's                 *   FILE 183\n//*            PUT EDIT or COBOL's STRING.                          *   FILE 183\n//*                                                                 *   FILE 183\n//*            This is the only non-IBM macro you need to           *   FILE 183\n//*            assemble the programs in this file.                  *   FILE 183\n//*                                                                 *   FILE 183\n//*            This member contains the macro, a test job,          *   FILE 183\n//*            and the documentation.                               *   FILE 183\n//*                                                                 *   FILE 183\n//*                                                                 *   FILE 183\n//*  ---------------------- Miscellaneous -----------------------   *   FILE 183\n//*                                                                 *   FILE 183\n//*  DEFGDGSR  Sub-routine - invokes SVC 26 to define a GDG base    *   FILE 183\n//*                                                                 *   FILE 183\n//*            May be invoked from a COBOL program, like this:      *   FILE 183\n//*                                                                 *   FILE 183\n//*                  05  DSNAME   PIC X(44) VALUE 'MY.DSNAME'.      *   FILE 183\n//*                  05  GDGLIMIT PIC   999 VALUE 027.              *   FILE 183\n//*                                                                 *   FILE 183\n//*                      CALL 'DEFGDGSR' USING DSNAME,              *   FILE 183\n//*                                            GDGLIMIT.            *   FILE 183\n//*                                                                 *   FILE 183\n//*  FILLDASD  Asm pgm to fill free DASD space with binary zeroes   *   FILE 183\n//*                                                                 *   FILE 183\n//*  HANDBOOK  Job - Creates an on-line copy of the DATA AREAS      *   FILE 183\n//*            (aka Debugging Handbook) manuals                     *   FILE 183\n//*                                                                 *   FILE 183\n//*            This job assembles macros from SYS1.MACLIB and       *   FILE 183\n//*            SYS1.MODGEN and stores the assembly listings         *   FILE 183\n//*            into PDS members.  It is set up for over 60          *   FILE 183\n//*            commonly used MVS control blocks (such as CVT,       *   FILE 183\n//*            TCB, JFCB, etc) and may be easily modified to        *   FILE 183\n//*            support other ones.                                  *   FILE 183\n//*                                                                 *   FILE 183\n//*            The assembly listing for each macro is stored        *   FILE 183\n//*            into the output PDS under the control block          *   FILE 183\n//*            name.  For example, the assembly listing for         *   FILE 183\n//*            \"IKJTCB\" is stored into the \"TCB\" member.            *   FILE 183\n//*                                                                 *   FILE 183\n//*            To conserve dasd space, the LMCOPY service of        *   FILE 183\n//*            ISPF/PDF is used to pack the output of the           *   FILE 183\n//*            assembler.                                           *   FILE 183\n//*                                                                 *   FILE 183\n//*  IEC149I   MPF Exit.  Display the dsname from the HDR1 label    *   FILE 183\n//*            after a 813-04 or 237-08 abend.                      *   FILE 183\n//*                                                                 *   FILE 183\n//*  SYSDEBUG  General Purpose ESTAE Routine.  Simplifies abend     *   FILE 183\n//*            resolution by formatting and writing out important   *   FILE 183\n//*            MVS control blocks in an easy-to-read fashion.       *   FILE 183\n//*                                                                 *   FILE 183\n//*  TCTDCTR   Sub-routine - Prints the EXCP count for each DD      *   FILE 183\n//*            in the job step                                      *   FILE 183\n//*                                                                 *   FILE 183\n//*            May be invoked at the end of a program for           *   FILE 183\n//*            debugging or tuning purposes.                        *   FILE 183\n//*                                                                 *   FILE 183\n//*  TRIMMAC   Job - Creates a reduced-size MACLIB that may be      *   FILE 183\n//*            used instead of the SYS1.MACLIB/SYS1.MODGEN          *   FILE 183\n//*            concatenation to improve the performance of the      *   FILE 183\n//*            assembler.                                           *   FILE 183\n//*                                                                 *   FILE 183\n//*            The \"TRIMMAC\" library is built as follows:           *   FILE 183\n//*                                                                 *   FILE 183\n//*            1. selected macros are read from ddname \"SYSLIB\",    *   FILE 183\n//*               trimmed from PL/AS code and other comment         *   FILE 183\n//*               lines, then written to a temporary data set.      *   FILE 183\n//*                                                                 *   FILE 183\n//*            2. the SORT utility is invoked to sort the macros    *   FILE 183\n//*               in ascending sequence of their size.              *   FILE 183\n//*                                                                 *   FILE 183\n//*            3. the sorted macros are written to SYSPUNCH         *   FILE 183\n//*               as an IEBUPDTE sysin stream.                      *   FILE 183\n//*                                                                 *   FILE 183\n//*            4. IEBUPDTE is executed in the last step to          *   FILE 183\n//*               load the macros into the \"TRIMMAC\" library,       *   FILE 183\n//*               the smallest macros being loaded first.           *   FILE 183\n//*                                                                 *   FILE 183\n//*            You may customize the member list and the input      *   FILE 183\n//*            concatenation to add other macros and/or macro       *   FILE 183\n//*            libraries, as needed.                                *   FILE 183\n//*                                                                 *   FILE 183\n//*            Use the \"TRIMMAC\" library instead of the             *   FILE 183\n//*            MACLIB/AMODGEN concatenation to assemble a           *   FILE 183\n//*            program and compare the before/after values for      *   FILE 183\n//*            the elapsed time, excp count and I/O connect         *   FILE 183\n//*            time.  Expect savings of 30 to 60 percent when       *   FILE 183\n//*            \"TRIMMAC\" is used.                                   *   FILE 183\n//*                                                                 *   FILE 183\n//*            My \"TRIMMAC\" PDS is currently allocated as           *   FILE 183\n//*            follows:                                             *   FILE 183\n//*                                                                 *   FILE 183\n//*                UNIT=3390,SPACE=(CYL,(9,,18)),                   *   FILE 183\n//*                DCB=(RECFM=FB,LRECL=80,BLKSIZE=29720)            *   FILE 183\n//*                                                                 *   FILE 183\n//*  USERCMDS  Job - Update USERCMDS in batch                       *   FILE 183\n//*                                                                 *   FILE 183\n//*            This is a TMP job that uses an in-line REXX exec     *   FILE 183\n//*            and ISPF table services to append a set of in-line   *   FILE 183\n//*            commands to the original USERCMDS table.             *   FILE 183\n//*                                                                 *   FILE 183\n//*            The resulting USERCMDS table may be given any        *   FILE 183\n//*            name and go to any library you choose.               *   FILE 183\n//*                                                                 *   FILE 183\n//*  ZAPONTR0  Patch job - Bypass STEPLIB for ILBOxxx routines      *   FILE 183\n//*                                                                 *   FILE 183\n//*            This patch to ILBONTR0 eliminates                    *   FILE 183\n//*            JOBLIB/STEPLIB directory searches for OS/VS          *   FILE 183\n//*            COBOL ILBOxxx modules when SYS1.VSCLLIB is in        *   FILE 183\n//*            the linklist.  If you compile your COBOL             *   FILE 183\n//*            modules with 'resident' and have large JOBLIBs       *   FILE 183\n//*            or STEPLIBs, you want to try this.                   *   FILE 183\n//*                                                                 *   FILE 183\n//*            The job contains 2 different versions of the         *   FILE 183\n//*            patch in AMASPZAP format.  Each version              *   FILE 183\n//*            corresponds to a different PTF level, use the        *   FILE 183\n//*            one that works for you.  The patch is packaged       *   FILE 183\n//*            with its own validation program.                     *   FILE 183\n//*                                                                 *   FILE 183\n//*  ZAPXMIT   Patch job - Remove BLKSIZE(3120) from XMIT OUTDA()   *   FILE 183\n//*            cmd                                                  *   FILE 183\n//*                                                                 *   FILE 183\n//*            This patch to the TRANSMIT command sets the BLKSIZE  *   FILE 183\n//*            of the output data set to zero when TRANSMIT/XMIT    *   FILE 183\n//*            is invoked with the OUTDA or OUTDS parameter.        *   FILE 183\n//*            This version of the ZAP works on TSO/E 2.6.          *   FILE 183\n//*                                                                 *   FILE 183\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ADDTRK": {"ttr": 2310, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00I\\x00\\x91\\x14_\\x01\\x08\\x08/\\tH\\x004\\x00\\x13\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf8@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1991-05-25T00:00:00", "modifydate": "2008-03-22T09:48:49", "lines": 52, "newlines": 19, "modlines": 0, "user": "CBT478"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* MODULE NAME = ADDTRK                                               */\n/*                                                                    */\n/*        Invoke PDS86 to add tracks to the current data set          */\n/*                                                                    */\n/*        http://www.cbttape.org/ftp/updates/CBT035.zip               */\n/*                                                                    */\n/* STATUS = R200                                                      */\n/*                                                                    */\n/* FUNCTION = ADDTRK is an ISPF EDIT macro which invokes PDS86        */\n/*            to allocate a new extent for the PDS being edited.      */\n/*            The size of the new extent is specified in tracks.      */\n/*                                                                    */\n/* AUTHOR   =  Gilbert Saint-Flour <carlos@gsf-soft.com>              */\n/*             http://gsf-soft.com/Freeware/                          */\n/*                                                                    */\n/* DEPENDENCIES = ISPF V2R3                                           */\n/*                PDS 8.6                                             */\n/*                                                                    */\n/* SYNTAX   =  ADDTRK               ISPF MACRO                        */\n/*                nnnn              number of tracks added            */\n/*                                                                    */\n/*             ADDTRK               TSO Command                       */\n/*                dsn               data set name                     */\n/*                nnnn              number of tracks added            */\n/*                                                                    */\n/* INSTALLATION = ADDTRK must be installed in a REXX library          */\n/*                which is accessible in ISPF/PDF.                    */\n/*                                                                    */\n/**********************************************************************/\nADDRESS ISPEXEC\nARG dsn numtrk\nvol=''\nIF dsn='' THEN DO\n  'ISREDIT MACRO (NUMTRK)'\n  IF rc>0 THEN DO; SAY 'ISREDIT_RC='rc; EXIT(rc);END\n  'ISREDIT (dsn) = DATASET'\n  IF rc=0 THEN DO\n    'ISREDIT (vol) = VOLUME'\n    VOL = 'VOLUME('vol')'\n    END\n  END\nELSE DO\n  'VGET (ZDLDSN ZDLVOL)'\n  IF rc=0 THEN\n    VOL = 'VOLUME('zdlvol')'\n  END\n /* say zdlvol dsn vol rc */\nIF LEFT(dsn,1) <> \"'\" THEN dsn=\"'\" || dsn || \"'\"\nIF numtrk='' THEN DO; SAY 'NUMTRK Missing'; EXIT(12);END\n\"SELECT CMD(PDS86\" dsn vol \"FIX ADDTRK(\"numtrk\")) MODE(FSCR)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BLKSIZE2": {"ttr": 2312, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x19\\x0f\\x00\\x92\\x18\\x0f\\x11T\\x00\\x8d\\x00d\\x00I\\xc3\\xc2\\xe3\\xf3\\xf7\\xf1@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-07-09T00:00:00", "modifydate": "1992-06-28T11:54:00", "lines": 141, "newlines": 100, "modlines": 73, "user": "CBT371"}, "text": "//GILBERTB JOB (ACCT#),DISPLAY.BLKSIZE,\n// CLASS=A,MSGCLASS=H,COND=(0,NE),\n// NOTIFY=&SYSUID\n//*\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n*PROCESS USING(WARN(8))\n***********************************************************************\n**                                                                   **\n**       THIS PROGRAM SCANS A PDS AND PRINTS THE SIZE                **\n**       OF EACH DATA BLOCK, AS WELL AS THE NUMBER OF                **\n**       BYTES REMAINING AT THE END OF EACH TRACK.                   **\n**                                                                   **\n**       THIS PROGRAM WAS INITIALLY DESIGNED TO STUDY HOW            **\n**       CHANGING THE BLKSIZE OF A PDS AFFECTS SPACE USAGE.          **\n**                                                                   **\n***********************************************************************\nBLKSIZE2 START X'0FC010'\n         SAVE  (14,12),,BLKSIZE2.&SYSDATE\n         LR    R12,R15\n         USING BLKSIZE2,R12\n         ST    R13,SAVEAREA+4\n         LA    R13,SAVEAREA\n         OPEN  MF=(E,OPENLIST)         OPEN SYSUT1/SYSPRINT\n         LTR   R15,R15\n         BNZ   ABEND16\n         LA    R8,SYSUT1\n         USING IHADCB,R8\n***********************************************************************\n******   READ A TRACK                                            ******\n***********************************************************************\n*LOOP\nLOOP21   L     R0,DCBRELAD             GET TTRN\n         L     R1,DCBDEBAD             DEB ADDRESS\n         LA    R2,MBBCCHHR             MBBCCHHR FIELD\n         STM   R8,R13,20(R13)          SAVE R8-R13\n         LR    R8,R13                  SAVE R8-R13\n         L     R15,16                  CVTPTR\n         L     R15,28(,R15)            CVTPCNVT\n         BALR  R14,R15                 COMPUTE MBBCCHHR\n         LM    R8,R13,20(R8)           RESTORE R8-R13\n         LTR   R15,R15                 SUCCESSFUL?\n         BNZ   CLOSEUT1                END OF EXTENT, CLOSE\n         EXCP  IOB1                    FULL TRACK READ\n         WAIT  1,ECB=ECB1\n***********************************************************************\n******   SCAN TRACK                                              ******\n***********************************************************************\n         LM    R3,R4,CCW4              FIRST BUFFER\n         USING COUNT,R3\n         LA    R3,0(,R3)               START OF BUFFER\n         LA    R5,0(R3,R4)             END OF BUFFER\n         SLR   R0,R0\n         ICM   R0,B'0011',IOB1+14      RESIDUAL COUNT\n         SLR   R5,R0\n         BCTR  R5,0                    LAST BYTE XFERED FROM TRACK\n         MVI   PRTAREA+43,C'T'         NEW TRACK\n         SLR   R6,R6                   CUMULATIVE LENGTH\n*--LOOP\nLOOP36C  TRKCALC FUNCTN=TRKBAL,DEVTAB=DCBDVTBL,RKDD=COUNTR,BALANCE=*\n         CVD   R0,DWD                  TRKBAL\n         OI    DWD+7,15\n         UNPK  PRTAREA+13(5),DWD\n         LH    R4,COUNTDL              DATA LENGTH\n         CVD   R4,DWD\n         OI    DWD+7,15\n         UNPK  PRTAREA+03(5),DWD\n         AR    R6,R4                   CUMULATIVE LENGTH\n         CVD   R6,DWD\n         OI    DWD+7,15\n         UNPK  PRTAREA+33(5),DWD\n*\n         UNPK  PRTAREA+50(9),COUNT(5)    SHOW CCHHRKDD IN HEX\n         TR    PRTAREA+50(9),TABHEX-240  SHOW CCHHRKDD IN HEX\n         UNPK  PRTAREA+58(9),COUNT+4(5)  SHOW CCHHRKDD IN HEX\n         TR    PRTAREA+58(9),TABHEX-240  SHOW CCHHRKDD IN HEX\n         MVI   PRTAREA+66,C' '           SHOW CCHHRKDD IN HEX\n*\n         PUT   SYSPRINT,PRTAREA        WRITE RECORD\n         MVI   PRTAREA+43,C' '         RESET \"START OF TRACK\" FLAG\n*\n         SLR   R1,R1\n         IC    R1,COUNTKL              KEY LENGTH\n         LA    R4,8(R1,R4)             8+KL+DL\n         BXLE  R3,R4,LOOP36C           PROCESS NEXT BLOCK\n*--ENDLOOP\n         MVC   PRTAREA+1(79),PRTAREA\n         PUT   SYSPRINT,PRTAREA\n         LA    R0,X'0001'              NEXT TRACK\n         AH    R0,DCBRELAD             TTRN NEXT TRACK\n         STH   R0,DCBRELAD             TTRN NEXT TRACK\n         B     LOOP21                  PROCESS NEXT TRACK\n*ENDLOOP\nCLOSEUT1 CLOSE MF=(E,OPENLIST)         CLOSE SYSUT1 & SYSPRINT\n         L     13,4(,13)\n         RETURN (14,12),RC=00\nABEND16  ABEND 0016\nTABHEX   DC    C'0123456789ABCDEF'\nOPENLIST OPEN  (SYSUT1,,SYSPRINT,OUTPUT),MF=L\nSYSUT1   DCB   MACRF=E,DDNAME=SYSUT1,IOBAD=IOB1\nSYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,RECFM=FB,LRECL=80\n         CNOP  0,8 -------------------- IOB1 ---------------------\n         DC    CL4'IOB1'\nECB1     DC    A(0)                    ECB\nIOB1     DC    XL4'42000000'           FLAG1/2 SENSE1/2\n         DC    A(ECB1)                 ECBPTR\n         DC    X'00',XL7'00'           FLAG3 CSW\n         DC    A(CCW2)                 CCW ADDR\n         DC    A(SYSUT1)               DCBPTR\n         DC    2A(0)                   RESTR INCAM ERRCT\nMBBCCHHR DC    XL8'01'\n*                   ------------------ CCW'S -------------------\nCCW2     CCW   X'31',MBBCCHHR+3,X'40',5      SEARCH ID EQUAL\nCCW3     CCW   X'08',*-8,0,0                 TIC\nCCW4     CCW   X'5E',COUNT,X'20',65535       READ MULTIPLE, SLI\n*\nSAVEAREA DS    9D\nDWD      DS    1D\nPRTAREA  DC    CL80' '\n*\nCOUNT    DS    0D                      COUNT\nCOUNTCC  DS    H\nCOUNTHH  DS    H\nCOUNTR   DS    X\nCOUNTKL  DS    X\nCOUNTDL  DS    H\nKEY      DS    XL8                     KEY\nDATA     DS    65535X                  DATA\n         PRINT NOGEN\n         DCBD  DSORG=PS,DEVD=DA\n         YREGS\n         END\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//GO      EXEC PGM=LOADER,PARM=NOPRINT\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,DELETE)\n//SYSUT1   DD DSN=GILBERT.TRIMMAC,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BR": {"ttr": 2316, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x1f\\x00R\\x00\\x88%_\\x01\\x10\\x13O\\x15\\x02\\x08\\x01\\x02\\x86\\x02\\xb5\\xc3\\xc2\\xe3\\xf4\\xf8\\xf3@@@@'", "ispf": {"version": "02.31", "flags": 0, "createdate": "1988-09-11T00:00:00", "modifydate": "2010-05-14T15:02:52", "lines": 2049, "newlines": 646, "modlines": 693, "user": "CBT483"}, "text": "//GILBERTB JOB (ACCT#),VSBROWSE,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(NODECK,OBJECT,NOESD,NORLD,NOXREF)\n*process flag(nopage0)\n***********************************************************************\n*                                                                     *\n*            COPYRIGHT (C) 1988-2010 GILBERT SAINT-FLOUR              *\n*                       ALL RIGHTS RESERVED                           *\n*                                                                     *\n* MODULE NAME = BR                                                    *\n*                                                                     *\n* DESCRIPTIVE NAME = VSAM/BDAM Browse Command for ISPF/PDF            *\n*                                                                     *\n* FUNCTION = This ISPF/PDF program allows you to browse most VSAM and *\n*            BDAM data sets.  It may be invoked as a TSO command,     *\n*            as a program, or as an EDIT macro.                       *\n*                                                                     *\n* STATUS = R231                                                       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*          http://gsf-soft.com/Freeware/                              *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = OS/390 or z/OS                                    *\n*                   ISPF V4 or V5                                     *\n*                   STRING macro R510                                 *\n*                                                                     *\n*    AUTHORIZATION = NONE                                             *\n*                                                                     *\n*    RESTRICTIONS = NONE                                              *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (TSO Command Processor)                    *\n*                                                                     *\n*    PROCESSOR = IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 8K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE 24, AMODE 31,                    *\n*                 PROBLEM STATE, KEY 8                                *\n*                                                                     *\n* SYNTAX = See Below                                                  *\n*                                                                     *\n*        BR may be invoked as a TSO command, as a program,            *\n*        or as an edit macro.                                         *\n*                                                                     *\n*        1. TSO command                                               *\n*                                                                     *\n*          Syntax:                                                    *\n*                                                                     *\n*            BR dsname                  data set name                 *\n*               VOL(volser)             volume serial (optional)      *\n*                                                                     *\n*        2. EDIT macro                                                *\n*                                                                     *\n*          Syntax:                                                    *\n*                                                                     *\n*            !BR dsname                                               *\n*                                                                     *\n*        3. Program                                                   *\n*                                                                     *\n*            BR may be invoked via the ISPF SELECT service, the       *\n*            TSO CALL command, or a LINK macro.  A fully-qualified    *\n*            dsname and a volser may be specified in the parm.        *\n*                                                                     *\n*          Syntax:                                                    *\n*                                                                     *\n*            SELECT PGM(BR) <PARM(dsname<,volser>)>                   *\n*                                                                     *\n* OPERATION = See Below                                               *\n*                                                                     *\n*        BR first determines if the specified data set is             *\n*        NOT supported by ISPF/PDF's BROWSE service, i.e. one         *\n*        of the following:                                            *\n*                                                                     *\n*          1.  VSAM (ESDS, KSDS, RRDS, VRDS, LDS)                     *\n*          2.  BDAM                                                   *\n*          3.  BLKSIZE=0 or DSORG=0 or KEYLEN>0 or DS1LSTAR=0         *\n*              or RECFM=VBS                                           *\n*                                                                     *\n*        Based on previous determination, BR will:                    *\n*                                                                     *\n*          a. Invoke the BROWSE service to process the data set,      *\n*             if BROWSE supports it.                                  *\n*                                                                     *\n*          b. allocate the data set, process it using VSAM or EXCP,   *\n*             and display the data via BRIF (the BROWSE interface),   *\n*             if BROWSE does not support it.                          *\n*                                                                     *\n*    NOTES:                                                           *\n*                                                                     *\n*      a.  The dsname is optional.  When no dsname is specified,      *\n*          BR tries to find a dsname on the screen (at the cursor     *\n*          position).  If this fails, then BR prompts the user to     *\n*          enter the dsname.                                          *\n*                                                                     *\n*      b.  If BR is invoked as a command or an edit macro             *\n*          with a dsname that is not enclosed in quotes,              *\n*          BR prefixes it with the userid.                            *\n*                                                                     *\n*      c.  A volume serial is optional.  BR assumes that the          *\n*          data set is cataloged if no volser is specified.           *\n*          If the data set is not cataloged, BR uses the ZDLVOL       *\n*          variable (set when a command is invoked on the Data Set    *\n*          List panel) to determine the volume serial.                *\n*                                                                     *\n*    Point-and-shoot Capabilities                                     *\n*                                                                     *\n*      If the user invokes BR without specifying a dsname,            *\n*      BR tries to find a dsname on the screen, at the cursor         *\n*      position; this technique, called \"point-and-shoot\",            *\n*      is implemented here in two flavors:                            *\n*                                                                     *\n*      1. When it is invoked as an edit macro, BR uses standard       *\n*         ISREDIT calls to retrieve the text under which the cursor   *\n*         is currently located, scans the text for specific           *\n*         delimiters, then extracts the data set name.                *\n*                                                                     *\n*      2. When it is invoked as a program or as a command,            *\n*         BR extracts the screen image and cursor position            *\n*         from the TLD, an ISPF control block that is not             *\n*         part of the standard programming interface (this            *\n*         technique may not work in future releases of ISPF).         *\n*                                                                     *\n*         Note that for this to work, it is imperative that BR        *\n*         be invoked with MODE(FSCR).  Unfortunately, if you invoke   *\n*         BR via the TSO command, the SELECT service invokes BR as    *\n*         a command and uses MODE(LINE) as a default, which           *\n*         prevents BR from retrieving the data set name.              *\n*                                                                     *\n*         So if you want use BR's point-and-shoot capabilities        *\n*         outside of an EDIT session, you must use one of the         *\n*         following options:                                          *\n*                                                                     *\n*           1. Instead of just TSO BR, type the following,            *\n*              exactly as shown (no closing parenthesis)              *\n*                                                                     *\n*                TSO BR) MODE(FSCR                                    *\n*                                                                     *\n*              not something you want to type too often, but if       *\n*              you set it up as a PFK, it's allright.                 *\n*                                                                     *\n*           2. Define BR as a command in the ISPF command table,      *\n*              for example like this:                                 *\n*                                                                     *\n*                BR     0 SELECT PGM(BR) MODE(FSCR)                   *\n*                                                                     *\n*              then you can access BR just by typing BR on the        *\n*              command line, on any screen.                           *\n*                                                                     *\n*           3. Write a simple REXX exec (or a CLIST) to invoke BR     *\n*              with MODE(FSCR):                                       *\n*                                                                     *\n*                ARG dsn                                              *\n*                \"ISPEXEC SELECT CMD(BR\" dsn \") MODE(FSCR)\"           *\n*                                                                     *\n*              then you can access BR just by typing TSO %BR          *\n*                                                                     *\n*           4. Modify ISPCMDS to add MODE(FSCR) to the definition     *\n*              of the TSO command                                     *\n*                                                                     *\n*                SELECT SUSPEND CMD(&ZPARM) MODE(FSCR)                *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n* 099 First version of XBRVS in ISPF/PDS V2R3                     1988*\n*     First version of XBRDA                                      1990*\n*     XBRVS and XBRDA are merged to build the BR command          1991*\n*     BR may now be invoked as a PGM or EDIT macro                    *\n*     Fixed a couple of bugs, added comments & TRACE macro            *\n* 110 Program made re-entrant, uses EXCP instead of BDAM          1993*\n* 120 Add limited support for Linear data sets (first 64 K only)      *\n* 121 Process RECFM=VS/VBS like RECFM=U                               *\n* 122 Process data sets with null DSORG                               *\n* 130 Prevent loop if track is empty                                  *\n* 131 Issue ISRB603 message when VSAM data set is empty               *\n* 132 Do not ignore the member name, pass it to BROWSE                *\n* 133 Simplify processing of first record (ESDS/KSDS)                 *\n* 134 Use standard BROWSE to process PDSEs                            *\n* 134 Use the SDSF SVC to open VVDS's and bypass ENQ                  *\n* 135 Change APPLID to ISR if invoked under SDSF                      *\n* 136 Display program level on first screen                           *\n* 137 Finally figured out what was wrong with VSAM record #1 !!!      *\n* 138 Implement full support for linear data sets                 1994*\n* 138 Init message enhanced to help debugging                         *\n* 139 Add 8 to MAXLRECL if RECFM=U                                    *\n* 140 Display statistics at end of program                            *\n* 141 Retry with BUFSP=0 after FDBK=0C0004 error                  1995*\n* 142 Remove VVDS browse capability (it disables RACF protection)     *\n* 143 Work around ISPF V4 bug (ZDLDSORG='' for VSAM cluster)          *\n* 144 Improve dsname extraction from a window by using the            *\n*     buffer address in TLDCLSP instead of TLD+128                    *\n* 145 Remove all authorized functions                             1996*\n* 146 Use PANEL(ISRBROBA) in ISPF V4                                  *\n* 147 Use standard BROWSE to process HFS, extended format,        1997*\n*     and multi-volume (in ISPF V4)                                   *\n* 148 Re-invoke myself as a PGM when invoked as a CMD;                *\n*     this should fix the FREEMAIN problems in SO5                    *\n* 149 Use PANEL(ISRBROBA) in ISPF V5 also                         2002*\n*                                                                     *\n* 225 Remove support for MVS/XA, MVS/ESA and ISPF V3              2005*\n*     Support ALIAS Entries when calling ISPF BROWSE                  *\n*     Process a VRDS like an RRDS                                     *\n*     Support extended-addressability VSAM data sets                  *\n*     Improve EOF detection for open data sets                        *\n* 226 Allocate BUFFER on page boundary                            2008*\n* 227 Change 5X to 7X after IECSDSL1 for z/OS R10                 2009*\n* 228 Invoke VSAMVIEW when user enters V command                      *\n*     Support ISPF/PDF V3                                             *\n* 229 Invoke LISTCAT when user enters LC command                      *\n* 230 Fix VSAM error - was RPLFDBWD=2B080020 OPTCD=C440 RRN=1         *\n* 231 Add RBA Command to display RBA in pos 1                     2010*\n*     Add commands to init msg: V, LC, RBA                            *\n*     FSTSO replaces TSOFS                                            *\n*                                                                     *\n&REL     SETC  '231'                                                  *\n***********************************************************************\nVSBROWSE CSECT\nVSBROWSE AMODE 31\n&YYMMDD  SETC  '&SYSDATE'(7,2)'-'.'&SYSDATE'(1,2)'-'.'&SYSDATE'(4,2)\n&XXX     SETC  '- 20&YYMMDD &SYSTIME '\n         SAVE  (14,12),,'GSF Utilities - VSAM/BDAM Browse R&REL &XXX'\n         LR    R10,R15                 1st base reg\n         USING VSBROWSE,R10\n         LA    R11,VSBROWSE+4095       2nd base reg\n         USING VSBROWSE+4095,R11\n         LA    R0,DYNAML               length of dynamic storage area\n         GETMAIN RU,LV=(0),BNDRY=PAGE  ALLOCATE DYNAMIC STORAGE AREA\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LM    R13,R1,8(R13)           SET R13, RELOAD R14-R1\n         USING DYNAM,R13\n         LR    R9,R1                   save PARM/CPPL address\n         STM   R10,R11,BASEREGS        for read routines\n*\n         L     R1,540(,0)              PSATOLD (my TCB)\n         L     R1,0(,R1)               TCBRBP (my PRB)\n         ICM   R1,B'0111',13(R1)       RBCDE1 (my CDE)\n         ST    R1,OWNCDE               keep the address of my CDE\n         USING CDENTRY,R1\n         TM    CDATTR,CDMIN            is this a minor CDE?\n         BZ    *+8                     no, jump\n         L     R1,CDXLMJP              yes, point to major CDE\n         MVC   OWNNAME,CDNAME          save my true name\n         DROP  R1\n*----------------------------------------------------------------------\n         MACRO                                                    macro\n&NAME    ISPLINK &OPRNDS,&ERRET=                                  macro\n         GBLB  &IHBSWA                                            macro\n&IHBSWA  SETB  1                       VL=1                       macro\n&NAME    LA    R1,TENWORDS             parm list                  macro\n         IHBOPLST ,&OPRNDS,MF=(E,(1))                             macro\n         L     R15,ISPLINK@            ISPLINK bootstrap\n         BALR  R14,R15                 invoke ISPLINK\n         AIF   (T'&ERRET EQ 'O').MEND                             macro\n         LTR   R15,R15                 Any error?\n         BNZ   &ERRET                  yes, jump\n.MEND    MEND                                                     macro\n*----------------------------------------------------------------------\n         LOAD  EP=ISPLINK\n         ST    R0,ISPLINK@             save ISPLINK address\n         LOAD  EP=ISPEXEC\n         ST    R0,ISPEXEC@             save ISPEXEC address\n         STRING 'CONTROL ERRORS RETURN',INTO=MESSAGE\n         BAL   R14,ISPEXEC             execute command\n         LTR   R15,R15                 ISPF active?\n         BNZ   QUIT16                  no, quit\n*\n         LA    R0,L'ZAPPLID            max length of APPLID\n         ST    R0,DWD                  max length of APPLID\n         ISPLINK (=C'VCOPY ',=C'(ZAPPLID)',DWD,ZAPPLID,=C'MOVE '),     X\n               ERRET=QUIT16\n*\n         GETMAIN R,LV=BUFFERL          ALLOCATE 64KB Buffer (A24)\n         ST    R1,BUFFERP              Address\n         LR    R12,R1                  Address\n         USING BUFFER,R12\n*\n         LA    R0,L'ZENVIR             max length of ZENVIR\n         ST    R0,DWD                  max length of ZENVIR\n         ISPLINK (=C'VCOPY ',=C'(ZENVIR)',DWD,ZENVIR,=C'MOVE ')\n*\n         MVC   PANEL,=C'ISRBROBA'      ISPF V4 panel (with action bar)\n         CLI   ZENVIR+5,C'4'           ISPF V4 or above ?\n         BNL   *+10                    yes, use ISRBROBA panel\n         STRING 1X,INTO=PANEL          default panel name (ISPF V3)\nINIT6    EQU   *\n*\n         ICM   R3,B'1111',0(R9)        INVOKED AS A PGM?\n         BM    PGM000                  Yes, jump\n         OI    SWITCH1,SW1CMD          invoked as a command\n         USING CPPL,R9                 SET UP ADDRESSABILITY TO CPPL\n*\n*        If no dsname has been specified, scan the screen buffer\n*        at the cursor position to find a dsname\n*\n         L     R1,CPPLECT              ENVIRONMENT CONTROL TABLE\n         TM    ECTSWS-ECT(R1),ECTNOPD  any operand specified?\n         BZ    CALLPARS                yes, scan buffer\n         BAL   R14,CURSOR           <- scan screen buffer for a dsname\n         LTR   R0,R0                   dsname found?\n         BNZ   MOVEDSN                 yes, used it\n***********************************************************************\n*                                                                     *\n*        BUILD PARSE PARM LIST, CALL IKJPARS                          *\n*                                                                     *\n***********************************************************************\nCALLPARS LA    R1,TENWORDS             POINT TO PPL\n         USING PPL,R1                  SET UP ADDRESSABILITY TO PPL\n         L     R0,CPPLUPT              USER PROFILE TABLE\n         ST    R0,PPLUPT               STORE UPT ADDRESS IN PPL\n         L     R0,CPPLECT              ENVIRONMENT CONTROL TABLE\n         ST    R0,PPLECT               STORE ECT IN PPL\n         LA    R0,ECB1                 EVENT CONTROL BLOCK\n         ST    R0,PPLECB               STORE ECB IN PPL\n         MVC   PPLPCL,=A(PCLCSECT)     STORE PCL ADDR INTO PPL\n         LA    R0,DYNANSWR             ANSWER AREA\n         ST    R0,PPLANS               STORE ANSWER ADDRESS IN PPL\n         L     R0,CPPLCBUF             COMMAND BUFFER\n         ST    R0,PPLCBUF              STORE BUFFER ADDRESS IN PPL\n         LA    R14,=C'IKJPARS '        NAME OF PARSE ROUTINE\n         L     R15,16(,0)              CVTPTR\n         L     R15,008(,R15)           CVTLINK\n         STM   R14,R15,DWD             BUILD LINK PARMLIST\n         LINK  SF=(E,DWD)              CALL THE PARSE ROUTINE\n         LTR   R7,R15                  CHECK FOR ZERO PARSE RETURN\n         BNZ   QUIT16                  GO AWAY UPSET\n         DROP  R1                      PPL\n***********************************************************************\n*                                                                     *\n*        PROCESS PARSED PARAMETERS                                    *\n*                                                                     *\n***********************************************************************\nPARSE100 L     R2,DYNANSWR             LOAD PDL ADDRESS\n         USING IKJPARMD,R2             SET UP ADDRESSABILITY TO PDL\n         L     R0,DSNPCE               GET ADDRESS\n         LH    R1,DSNPCE+4             ACTUAL LENGTH OF DSN\n         STRING ((R0),(R1)),INTO=DSNAME MOVE DATA SET NAME\n         L     R0,DSNPCE+8             GET ADDRESS\n         LH    R1,DSNPCE+8+4           ACTUAL LENGTH OF MEMBER NAME\n         STRING ((R0),(R1)),INTO=MEMBER MOVE MEMBER NAME\n         TM    VOLPCE2+6,X'80'         CHECK VOLSER SUBPARAMETER\n         BZ    PARSE300                JUMP IF NO SUBPARAM SPECIFIED\n         L     R1,VOLPCE2+00           GET SUBPARAM ADDRESS\n         MVC   VOLSER,0(R1)            MOVE 6-BYTE VOLUME SERIAL\n         OI    SWITCH1,SW1UVOL         VOLSER given by user\n         B     PARSE999                exit\n         DROP  R2\n*\n*        retrieve the volser from PDF 3.4 panel\n*\nPARSE300 LA    R0,L'FULLDSN            length\n         ST    R0,DWD\n         ISPLINK (=C'VCOPY ',=C'ZDLDSN ',DWD,FULLDSN,=C'MOVE '),       X\n               ERRET=PARSE999          VCOPY FAILED, QUIT\n         CLC   DSNAME,FULLDSN          same data set name?\n         BNE   PARSE999                no, exit\n         LA    R0,L'ZDLDSORG           length\n         ST    R0,DWD\n         ISPLINK (=C'VCOPY ',=C'ZDLDSORG ',DWD,ZDLDSORG,=C'MOVE '),    X\n               ERRET=PARSE999          VCOPY FAILED, QUIT\n         CLC   =C'VS',ZDLDSORG         vsam data set?\n         BE    PARSE999                yes, exit\n         CLI   ZDLDSORG,C' '           vsam data set?    (OW14454)\n         BE    PARSE999                yes, exit         (OW14454)\n         LA    R0,L'VOLSER             length\n         ST    R0,DWD\n         ISPLINK (=C'VCOPY ',=C'ZDLVOL ',DWD,VOLSER,=C'MOVE '),        X\n               ERRET=PARSE999          VCOPY FAILED, QUIT\n         OI    SWITCH1,SW1UVOL         VOLSER given by user (faked)\n*\nPARSE999 IKJRLSA DYNANSWR              FREE PDL\n         B     ALLOCATE\n*----------------------------------------------------------------------\n         MACRO\n&LABEL   TRACE\n&LABEL   LA    R1,=C'&LABEL'\n&L       SETA  K'&LABEL\n         LA    R0,&L                   length of literal\n         SVC   93                      issue TPUT SVC\n         MEND\n         MACRO\n&LABEL   TRACE ,                       (dummy macro)\n         AIF   (T'&LABEL EQ 'O').MEND\n&LABEL   DS    0H                      define label\n.MEND    MEND\n***********************************************************************\n*                                                                     *\n*        I've been invoked as a pgm, check if it is an edit macro     *\n*                                                                     *\n***********************************************************************\nPGM000   TRACE\n         LH    R0,0(,R3)               dsn length\n         LA    R1,2(,R3)               dsn address\n         LTR   R0,R0                   DO WE HAVE A PARM\"\n         BH    SCANPARM                yes, jump\n         STRING 'ISREDIT MACRO (VAR)',INTO=MESSAGE\n         BAL   R14,ISPEXEC             execute command\n         LTR   R15,R15                 OK?\n         BNZ   PGM500                  no, jump\n*\n*        BR has been invoked as an edit macro.  The first\n*        parameter is used as dsname if a parm has been specified;\n*        else, the dsname is picked up at the current cursor\n*        location using standard edit macro calls.\n*\nPGM100   LA    R0,L'MESSAGE            max length of dsname\n         ST    R0,DWD                  max length of dsname\n         ISPLINK (=C'VCOPY ',=C'(VAR)',DWD,MESSAGE,=C'MOVE '),         X\n               ERRET=PGM500\n         ICM   R0,B'1111',DWD          Actual length of dsname\n         BZ    PGM110                  no dsname, jump\n         BCTR  R0,0\n         BCTR  R0,0\n         STRING (MESSAGE+1,(R0)),INTO=DSNAME\n         CLI   MESSAGE,C''''           quoted dsn?\n         BE    ALLOCATE                yes, jump\n         MVC   DSNAME,MESSAGE          COPY DSNAME\n         L     R1,CPPLUPT              USER PROFILE TABLE\n         USING UPT,R1\n         SLR   R0,R0\n         ICM   R0,B'0001',UPTPREFL     PREFIX LENGTH\n         BZ    ALLOCATE                yes, jump\n         STRING (UPTPREFX,(R0)),'.',MESSAGE,INTO=DSNAME\n         B     ALLOCATE                There is a dsname, use it\n         DROP  R1                      UPT\n*\n*        get the dsname at cursor location\n*\nPGM110   TRACE\n         STRING 'ISREDIT (LINE,COL) = CURSOR',INTO=MESSAGE\n         BAL   R14,ISPEXEC             execute command\n         LTR   R15,R15                 OK?\n         BNZ   PGM500                  no, jump\nPGM110T  TRACE\n         LA    R0,3                    max length of variable\n         ST    R0,DWD                  max length of variable\n         ISPLINK (=C'VCOPY ',=C'(COL)',DWD,MESSAGE,=C'MOVE '),         X\n               ERRET=PGM500\nPGM120T  TRACE\n         PACK  DWD,MESSAGE(3)          pack cursor position\n         CVB   R5,DWD                  cursor position\n         LTR   R5,R5                   cursor in command line?\n         BZ    PGM500                  yes, jump\n         STRING 'ISREDIT (VAR) = LINE .ZCSR',INTO=MESSAGE\n         BAL   R14,ISPEXEC             execute command\n         LTR   R15,R15                 OK?\n         BNZ   PGM500                  no, jump\nPGM125T  TRACE\n         LA    R0,255                  max length of line\n         ST    R0,DWD                  max length of line\n         LA    R4,BUFFER               work area\n         ISPLINK (=C'VCOPY ',=C'(VAR)',DWD,(R4),=C'MOVE '),ERRET=PGM500\n*\n         BCTR  R5,0                    R5=0 if cursor is in pos 1\n         BAL   R14,CURSOR21            scan line to extract dsname\n         LTR   R0,R0                   dsname found?\n         BP    MOVEDSN                 yes, process it\n*\n*        This is not an edit macro or no dsname has been found\n*        at the cursor position; scan the screen buffer for a dsn\n*\nPGM500   BAL   R14,CURSOR           <- scan screen buffer for a dsname\n         LTR   R0,R0                   dsname found?\n         BNZ   MOVEDSN                 yes, used it\n*\n*        No dsname is available, re-invoke BR as a command,\n*        which will prompt the user for the dsname\n*\nPGM600   STRING 'CMD(',OWNNAME,') MODE(FSCR) NEWAPPL(',ZAPPLID,')',    X\n               INTO=MESSAGE\n         B     SELECT\nS99T15   DC    X'0015,0001,0008',C'SYSALLDA'\n***********************************************************************\n*                                                                     *\n*        Allocate the data set                                        *\n*                                                                     *\n***********************************************************************\nSCANPARM LR    R4,R1                   parm address\n         LR    R5,R0                   parm length\n         L     R15,=A(PARSE_PARM)      parse rtne addr\n         BALR  R14,R15                 parse parm into DSNAME,VOLSER\n         DC    S(L'DSNAME,DSNAME)      first operand\n         DC    S(L'VOLSER,VOLSER)      second operand\n         CLI   VOLSER,C' '             VOLSER given by user ?\n         BNH   ALLOCATE                no, jump\n         OI    SWITCH1,SW1UVOL         yes, remember it\n         B     ALLOCATE\n*\nMOVEDSN  STRING ((R1),(R0)),INTO=DSNAME  move dsname\n*\nALLOCATE TRACE\n         LA    R0,L'DSNAME             Convert to uppercase\n         LA    R1,DSNAME               Convert to uppercase\nCAPSON   OI    0(R1),C' '              Convert to uppercase\n         LA    R1,1(,R1)               Convert to uppercase\n         BCT   R0,CAPSON               Convert to uppercase\n*\n         STRING DSNAME,INTO=FULLDSN\n         CLI   MEMBER,C' '             do we have a member name?\n         BNH   ALLOC100                no, jump\n         STRING (DSNAME,,T),'(',(MEMBER,,T),')',INTO=FULLDSN\n*---------------------------------------------------------------------*\n*                                                                     *\n*        If I've been invoked as a TSO command or if ZAPPLID<>ISR,    *\n*        re-invoke myself as a program with NEWAPPL(ISR) for the      *\n*        following reasons:                                           *\n*                                                                     *\n*        1. prevent FREEMAIN errors when OPEN/GET/CLOSE are issued    *\n*           under different TCBs (LDS, IAM, SO5)                      *\n*                                                                     *\n*        2. ensure PFK consistency when invoked under applications    *\n*           (such as SDSF) that redefine the RFIND key                *\n*                                                                     *\n*---------------------------------------------------------------------*\nALLOC100 STRING 'PGM(',(OWNNAME,,T),') PARM(',(FULLDSN,,T),',',        X\n               (VOLSER,,T),')',INTO=MESSAGE\n         CLC   =C'ISR ',ZAPPLID        APPLID=ISR?\n         BNE   ALLOC105                no, jump\n         TM    CPPL,X'80'              INVOKED AS A PGM?\n         BO    ALLOC200                Yes, jump\n         B     SELECT\nALLOC105 EQU   *\n         STRING (MESSAGE,,T),' NEWAPPL(ISR)',INTO=MESSAGE\n         B     SELECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Allocate the data set                                        *\n*                                                                     *\n*---------------------------------------------------------------------*\nALLOC200 LA    R14,ACB1_M              point to ACB, RPL, DCB models\n         LA    R15,MODELS_L            length for move\n         LA    R0,IFGACB               dynamic storage area\n         LR    R1,R15                  length\n         MVCL  R0,R14                  move models to dynamic storage\n*\n         IHBOPLST ,(S99T1,             return ddname                   X\n               S99T2,                  dsname                          X\n               =X'0004,0001,0001,08',  DISP=SHR                        X\n               S99T15,                 UNIT=SYSALLDA                   X\n               S99T56,                 return true dsname              X\n               S99T57,                 return dsorg                    X\n               S99T5D),                return volser                   X\n               MF=(E,S99TUPTR)\n         ST    R1,S99RB+8              Text unit pointers\n         MVC   S99RB,=X'14,01,2000'\n         MVC   S99T1(6),=X'0055,0001,0008'    return ddname\n         MVC   S99T2(6),=X'0002,0001,002C'    dsname\n         MVC   S99T56(6),=X'0056,0001,002C'   return true dsname\n         MVC   S99T57(6),=X'0057,0001,0002'   return dsorg\n         MVC   S99T5D(6),=X'005D,0001,0006'   RETURN VOLSER\n         TM    SWITCH1,SW1UVOL         VOLSER given by user ?\n         BZ    ALLOC600                no, jump\n         MVI   S99T5D+1,X'10'          yes, use volser\n*\n*        Allocate the data set\n*\nALLOC600 LA    R1,S99RB                build SVC99 parm list\n         ST    R1,S99RBPTR             build SVC99 parm list\n         OI    S99RBPTR,X'80'          build SVC99 parm list\n         LA    R1,S99RBPTR\n         DYNALLOC ,                    ALLOCATE THE DATA SET\n         LTR   R15,R15                 SVC99 went OK?\n         BNZ   BROWSE                  no, quit\n*\n*        allocation is successful\n*\nALLOC900 CLC   DSORG,=AL2(DS1ORGAM)    DSORG=VSAM?\n         BNE   OPENDA                  NO, JUMP\n*---------------------------------------------------------------------*\n*                                                                     *\n*        INITIALIZE VSAM DATA SET                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nOPENVS   MVC   ACBDDNM,DDNAME          MOVE DDNAME\n         LA    R2,IFGACB               point to ACB\n         ST    R2,OPENLIST             build open list\n         MVI   OPENLIST,X'80'          build open list\n*\n         OPEN  MF=(E,OPENLIST)         OPEN VSAM data set\n         CH    R15,=H'4'               OPEN OK?\n         BH    OPENVS7                 NO, QUIT\n*\n         SHOWCB ACB=(R2),AREA=(S,MAXRECNO),LENGTH=12,                  X\n               FIELDS=(NLOGR,LRECL,ENDRBA),MF=(G,BUFFER)\n         ICM   R0,B'1111',MAXLRECL     LRECL=0 (LDS)\n         BZ    OPENVS3                 yes, jump\n*\n         ST    R2,RPLDACB-IFGRPL+RPL1  STORE ACB ADDRESS INTO RPL\n         ST    R2,RPLDACB-IFGRPL+RPL2  STORE ACB ADDRESS INTO RPL\n         LA    R0,RECAD                THE RIGHT WORD\n         ST    R0,RPLAREA-IFGRPL+RPL1  STORE AREA ADDRESS INTO RPL\n         ST    R0,RPLAREA-IFGRPL+RPL2  STORE AREA ADDRESS INTO RPL\n         LA    R0,L'RECAD              LENGTH\n         ST    R0,RPLBUFL-IFGRPL+RPL1  STORE AREA LENGTH INTO RPL\n         ST    R0,RPLBUFL-IFGRPL+RPL2  STORE AREA LENGTH INTO RPL\n         LA    R0,LOWRBA               ARGUMENT FOR POINT\n         ST    R0,RPLARG-IFGRPL+RPL2   STORE ARG ADDR INTO RPL\n*\n         TESTCB ACB=(R2),ATRB=XADDR,MF=(G,BUFFER) extended format?\n         BNE   OPENVS19                no, jump\n         MVI   XADDR,C'Y'              extended-addressability format\n         OI    RPLOPT4-IFGRPL+RPL1,RPLXRBA SET OPTCD=(XRBA)\n         OI    RPLOPT4-IFGRPL+RPL2,RPLXRBA SET OPTCD=(XRBA)\n         NI    RPLOPT1-IFGRPL+RPL1,255-RPLLOC OPTCD=MVE\n         NI    RPLOPT1-IFGRPL+RPL2,255-RPLLOC OPTCD=MVE\n         LA    R0,BUFFER               THE RIGHT WORD\n         ST    R0,RPLAREA-IFGRPL+RPL1  STORE AREA ADDRESS INTO RPL1\n         ST    R0,RPLAREA-IFGRPL+RPL2  STORE AREA ADDRESS INTO RPL2\n         L     R0,=F'65536'            AREALEN=65536\n         ST    R0,RPLBUFL-IFGRPL+RPL1  AREALEN=65536 INTO RPL1\n         ST    R0,RPLBUFL-IFGRPL+RPL2  AREALEN=65536 INTO RPL2\nOPENVS19 EQU   *\n*\n         TESTCB ACB=(R2),ATRB=RRDS,MF=(G,BUFFER)  is this an RRDS?\n         BE    OPENVS4                 YES, JUMP\n*\n         TESTCB ACB=(R2),ATRB=VRRDS,MF=(G,BUFFER)  is this a VRDS?\n         BE    OPENVS4                 YES, JUMP\n*\n         ICM   R1,B'1111',MAXRECNO     MAX NUMBER OF RECORDS\n         BNZ   OPENVS2                 NOT ZERO, JUMP\n         L     R1,=F'1000000'          file open, use 1 million\n*\nOPENVS2  SLL   R1,2                    MULT BY 4\n         CLI   XADDR,C'Y'              EXTENDED-ADDRESSABILITY FORMAT?\n         BNE   OPENVS2B                NO, JUMP\n         ALR   R1,R1                   8-BYTE RBA\nOPENVS2B EQU   *\n         LA    R0,0(,R1)               31-bit only\n         L     R1,=F'1000000'          minimum value\n         CLR   R0,R1                   more than 1 million ?\n         BL    OPENVS2G                yes, jump\n*\n*        file has more than 256K rec, get between 1meg and nrec*4 bytes\n*\n         GETMAIN VRU,LV=((R0),(R1)),LOC=ANY,BNDRY=PAGE\n         LR    R14,R0                  actual length gotten\n         SRL   R14,2                   convert to RECNO\n         CLI   XADDR,C'Y'              EXTENDED-ADDRESSABILITY FORMAT?\n         BNE   OPENVS2D                NO, JUMP\n         SRL   R14,1                   HALVE (XADDR=Y)\nOPENVS2D EQU   *\n         ST    R14,MAXRECNO            remember MAXRECNO\n         B     OPENVS2S\n*\nOPENVS2G GETMAIN RU,LV=(R0),LOC=ANY,BNDRY=PAGE\n*\nOPENVS2S STM   R0,R1,RBATABLE          STORE LENGTH, ORIGIN\n*\n*        set up RPL for ESDS/KSDS\n*\nOPENVS2K EQU   *\n         TESTCB ACB=(R2),ATRB=KSDS,MF=(G,BUFFER)  is this a KSDS?\n         BE    OPENVS5                 YES, JUMP\n         MVI   VS_TYPE,C'E'            Cluster is an ESDS\n         MVI   RPLOPT2-IFGRPL+RPL1,RPLADR OPTCD=ADR\n         B     OPENVS6\n*\n*        If LRECL=0, the data set is a linear data set (LDS).\n*        Use the screen width as the record length.\n*\nOPENVS3  MVI   VS_TYPE,C'L'            Cluster is an LDS\n         CLOSE MF=(E,OPENLIST)         close the ACB, we don't need it\n*\n         LA    R0,L'MAXLRECL           length for VCOPY\n         ST    R0,DWD                  length for VCOPY\n         ISPLINK (=C'VCOPY ',=C'(ZSCREENW)',DWD,MAXLRECL,=C'MOVE ')\n         PACK  DWD,MAXLRECL            convert to binary\n         CVB   R0,DWD                  convert to binary\n         ST    R0,MAXLRECL             screen width (80 or 132)\n         DIV   IDENTIFY,               identify                        X\n               ID=DIV_TOKN,            identifier                      X\n               TYPE=DA,                data set                        X\n               DDNAME=DDNAME-1,        X'08',C'ddname  '               X\n               MF=(E,DIV_LIST)\n         LTR   R15,R15                 OK?\n         BNE   X'800'                  no, quit\n         DIV   ACCESS,                 access                          X\n               MODE=READ,              read-only                       X\n               SIZE=MAXRECNO,          size in pages                   X\n               MF=(E,DIV_LIST)\n         CH    R15,=H'4'               OK?\n         BH    X'804'                  no, quit\n*\n*        calculate the number of records (display lines)\n*\n         SLR   R0,R0\n         L     R1,MAXRECNO             number of pages\n         SLDL  R0,12                   number of bytes\n         AL    R1,MAXLRECL             round up\n         BCTR  R1,0                    round up\n         D     R0,MAXLRECL             round up\n         ST    R1,MAXRECNO             number of display lines\n         MVI   LOWRBA,X'7F'            first-time switch\n         B     OPENVS6\n*\nOPENVS4  MVI   VS_TYPE,C'R'            Cluster is an RRDS\n         B     OPENVS6\n*\nOPENVS5  MVI   VS_TYPE,C'K'            Cluster is a KSDS\n*\nOPENVS6  LA    R1,READVS00             read routine\n         MVI   RECFM,C'V'              dummy RECFM for message\n         B     BRIF\n*\n*        VSAM OPEN error\n*\nOPENVS7  CLI   ACBERFLG,160            empty data set?\n         BNE   QUIT16                  no, quit\n         MVC   ZERRMSG,=C'ISRB603 '    \"no data to browse\"\n         LA    R7,4                    RC=4\n         B     SETMSG8                 issue message\n***********************************************************************\n*                                                                     *\n*        INITIALIZE BDAM DATA SET                                     *\n*                                                                     *\n***********************************************************************\nOPENDA   L     R14,=X'C1,00,00,00'     CAMLST SEARCH\n         LA    R15,DSNAME              GET WORK AREA ADDRESS\n         LA    R0,VOLSER               GET WORK AREA ADDRESS\n         LA    R1,DS1FMTID             GET WORK AREA ADDRESS\n         STM   R14,R1,TENWORDS         STORE UPDATED CAMLST\n         OBTAIN TENWORDS               GET F1-DSCB\n         LTR   R15,R15                 OK?\n         BNZ   BROWSE                  NO, QUIT\n*\n         TM    DS1SMSFG,DS1PDSE+DS1STRP+DS1PDSEX+DS1DSAE PDSE/HFS ?\n         BNZ   BROWSE                  YES, USE STANDARD BROWSE\n         TM    DS1DSORG,DS1DSGPO       DSORG=PO?\n         BO    BROWSE                  YES, USE STANDARD BROWSE\n         TM    DS1DSORG,DS1DSGDA       DSORG=DA?\n         BO    OPENDA2                 YES, USE BDAM\n         OC    DS1DSORG,DS1DSORG       DSORG=0?\n         BZ    OPENDA2                 YES, USE BDAM\n         OC    DS1BLKL,DS1BLKL         BLKSIZE=0?\n         BZ    OPENDA2                 YES, USE BDAM\n         CLI   DS1KEYL,0               KEYLEN>0\n         BH    OPENDA2                 YES, USE BDAM\n         TM    DS1RECFM,DS1RECFV+DS1RECFS   VS/VBS?\n         BO    OPENDA2                 YES, USE BDAM\n         OC    DS1LSTAR,DS1LSTAR       EOF=0 ?\n         BNZ   BROWSE                  NO, USE STANDARD BROWSE\n*\n*        determine the maximum lrecl\n*\nOPENDA2  DEVTYPE DDNAME,DVAREA,DEVTAB  get device type & track size\n         LTR   R15,R15                 OK?\n         BNZ   BROWSE                  NO, QUIT\n*\n         LA    R2,DCB1                 DCB address\n         MVC   DCBDDNAM,DDNAME         MOVE DDNAME\n         ST    R2,OPENLIST             build open list\n         MVI   OPENLIST,X'80'          build open list\n*\n         TM    DS1RECFM,DS1RECFB       RECFM=.B?\n         BZ    OPENDA2B                no, jump\n         LH    R0,DS1LRECL             GET LRECL\n         LTR   R0,R0                   LRECL=0?\n         BNZ   OPENDA2C                no, jump\n*\nOPENDA2B ICM   R0,B'0011',DS1BLKL      GET BLKSIZE\n         BNZ   OPENDA2C\n         L     R0,DVAMAXRC             defaule blksize/lrecl\n         STH   R0,DCBBLKSI             force BLKSIZE=32760 in DCB\n*\nOPENDA2C ST    R0,MAXLRECL             PASS IT TO BRIF\n*\nOPENDA2E CLI   DS1DSORG,DS1DSGPO       DSORG=PO?\n         BNE   OPENDA2O                no, jump\n         MVI   DCBDSORG,DS1DSGPO       yes, prevent S013-14 in ESA\n*\nOPENDA2O OPEN  MF=(E,OPENLIST)         OPEN DCB1\n         LTR   R15,R15                 OK?\n         BNZ   BROWSE                  NO, QUIT\n*\n*        determine record format\n*\nOPENDA3  TM    DCBRECFM,DCBRECU        RECFM=U?\n         BO    OPENDA3U                yes, jump\n         MVI   RECFM,C'F'              set RECFM=F\n         TM    DCBRECFM,DCBRECF        RECFM=F?\n         BO    OPENDA4                 yes, jump\n         MVI   RECFM,C'V'              set RECFM=V\n         TM    DCBRECFM,DCBRECV        RECFM=V?\n         BO    OPENDA4                 yes, jump\nOPENDA3U MVI   RECFM,C'U'              RECFM=U or no RECFM\n         LA    R0,8                    add 8 to recsize\n         AL    R0,MAXLRECL             add 8 to recsize\n         ST    R0,MAXLRECL             add 8 to recsize\n*\n*        build IOB\n*\nOPENDA4  MVI   IOBFLAG1,IOBCMDCH+IOBSPSVC\n         LA    R0,IOBNECB              ECB ADDRESS\n         ST    R0,IOBECBPT             STORE ADDRESS\n         LA    R0,CCW1                 FIRST CCW IN CHAIN\n         ST    R0,IOBSTART             STORE ADDRESS\n         ST    R2,IOBDCBPT             DCB ADDRESS\n         LA    R15,SECTORNO            SECTOR NUMBER X'00'\n         LA    R0,L'SECTORNO           LENGTH IS ONE BYTE\n         STM   R15,R0,CCW1             SET SECTOR CCW\n         MVI   CCW1+0,X'23'            COMMAND: SET SECTOR\n         MVI   CCW1+4,CC               FLAGS: COMMAND CHAINING\n*\n         LA    R15,IOBCC               CCHHR ADDRESS\n         LA    R0,5                    LENGTH IS FIVE BYTES\n         STM   R15,R0,CCW2             SET SECTOR CCW\n         MVI   CCW2+0,X'31'            COMMAND: SEARCH ID EQUAL\n         MVI   CCW2+4,CC               FLAGS: COMMAND CHAINING\n         LA    R15,CCW2                SEARCH CCW\n         SLR   R0,R0                   2ND WORD\n         STM   R15,R0,CCW3             TIC CCW\n         MVI   CCW3+0,X'08'            COMMAND: TIC\n*\n         LA    R15,BUFFER              FIRST BLOCK\n         SLR   R0,R0\n         ICM   R0,B'0011',DVATRKLN     track length\n         STM   R15,R0,CCW4             READ CCW\n         MVI   CCW4,X'5E'              COMMAND CODE: READ MULTIPLE TRK\n         OI    CCW4+4,SLI              FLAGS: SLI\n*\n*        Calculate the number of blocks per track\n*\n         TRKCALC FUNCTN=TRKCAP,                                        X\n               TYPE=DVAUNIT,                                           X\n               R=1,K=DCBKEYLE,DD=DCBBLKSI,                             X\n               REGSAVE=YES,                                            X\n               MF=(E,BUFFER)\n         LTR   R15,R15\n         BNZ   BROWSE                  TRKCALC ERROR\n         ST    R0,BLKPTRK              NUMBER OF BLOCKS PER TRACK\n         CLI   RECFM,C'F'              RECFM=F?\n         BE    OPENDA8                 yes, jump\n*\n*        allocate RRNtable if RECFM=V or RECFM=U\n*\nOPENDA7  SLR   R0,R0\n         ICM   R0,B'0111',DCBREL       number of tracks in data set\n         SLL   R0,2                    mult by 4 (size of a word)\n         GETMAIN RU,LV=(R0),LOC=ANY,BNDRY=PAGE\n         STM   R0,R1,RBATABLE          STORE LENGTH, ORIGIN\n         MVI   0(R1),X'7F'             end of table\n         MVI   MAXRECNO,X'7F'          maximum record number\n         B     OPENDA9\n*\n*        Calculate MAXRECNO for RECFM=F data sets\n*\nOPENDA8  SLR   R1,R1\n         ICM   R1,B'0111',DCBREL       number of tracks in data set\n         M     R0,BLKPTRK              number of blocks in data set\n         LH    R14,DCBBLKSI            get blksize\n         MR    R0,R14                  number of bytes  in data set\n*PDUMP DCB1,ENDRBA+3\n         D     R0,MAXLRECL             NUMBER OF RECORDS\n         ST    R1,MAXRECNO             number of records in data set\n*\nOPENDA9  MVI   TTTR,X'FF'              force first read\n         LA    R1,READDA00             read routine\n         MVI   VS_TYPE,C'*'            dummy type for message\n         B     BRIF\n***********************************************************************\n*                                                                     *\n*        Invoke ISPF/PDF BROWSE                                       *\n*                                                                     *\n*        The BROWSE function is invoked in two situations:            *\n*                                                                     *\n*          1. the data set appears to be supported by BROWSE          *\n*                                                                     *\n*          or                                                         *\n*                                                                     *\n*          2. dynamic allocation failed, BROWSE will try to allocate  *\n*             it also, will (probably) fail and issue an appropriate  *\n*             message.                                                *\n*                                                                     *\n***********************************************************************\nBROWSE   STRING '''',(FULLDSN,,T),'''',INTO=MESSAGE\n         TM    SWITCH1,SW1UVOL         VOLSER given by user?\n         BO    BROWSE2                 yes, jump\n         ISPLINK (=C'BROWSE ',MESSAGE)\n         LR    R7,R15                  save return-code from BROWSE\n         B     SETMSG\nBROWSE2  ISPLINK (=C'BROWSE ',MESSAGE,VOLSER)\n         LR    R7,R15                  save return-code from BROWSE\n         B     SETMSG\n***********************************************************************\n*                                                                     *\n*        Invoke ISPF/PDF BRIF Service                                 *\n*                                                                     *\n***********************************************************************\nBRIF     ST    R1,READRTNE             read routine\n         LA    R0,SAVERRTN             DDATA FOR BRIF\n         ST    R0,DDATA                DDATA FOR BRIF\n*\n         CLC   MAXLRECL,=F'32760'      IS RECSIZE TOO BIG?\n         BNH   *+10                    NO, JUMP\n         MVC   MAXLRECL,=F'32760'      YES, TRUNCATE IT\n         MVC   VS_LRECL,=F'32760'      prime work area\n*\n         STRING 'DSORG=',(DSORG,,X),                                   X\n               ' VS_TYPE=',VS_TYPE,                                    X\n               ' RECFM=',RECFM,                                        X\n               ' MAXLRECL=',(MAXLRECL,F,L),                            X\n               ' MAXRECNO=',(MAXRECNO,F,L),                            X\n               ' VOLSER=',VOLSER,                                      X\n               ' Commands:\u00a0V\u00a0(VIEW)\u00a0LC\u00a0(LISTCAT)\u00a0RBA\u00a0(RBA)',           X\n               INTO=MESSAGE\n         BAL   R2,SETMSG44             issue opening message\n*\n         ISPLINK (=C'BRIF',                                            X\n               DSNAME,                                                 X\n               =C'V ',                                                 X\n               MAXLRECL,                                               X\n               READRTNE,                                               X\n               =A(CMDRTNE),            process user commands           X\n               DDATA,                                                  X\n               PANEL)\n         LR    R7,R15                  SAVE RETURN CODE FROM BRIF\n*\n*        Display min/max record sizes for KSDS/ESDS\n*\nBRIF70   CLI   VS_TYPE,C'K'            KSDS?\n         BE    BRIF72                  yes, jump\n         CLI   VS_TYPE,C'E'            ESDS?\n         BNE   SETMSG                  NO, JUMP\nBRIF72   STRING VS_TYPE,'SDS',                                         X\n               ' MAXRECNO=',(MAXRECNO,F,L),                            X\n               ' Records_processed=',(VS_RECNO,F,L),                   X\n               ' MINLRECL=',(VS_LRECL,F,L),                            X\n               ' MAXLRECL=',(VS_LRECL+4,F,L),                          X\n               INTO=MESSAGE\n         BAL   R2,SETMSG44             issue VSAM statistics\n***********************************************************************\n*                                                                     *\n*        PROGRAM EXIT                                                 *\n*                                                                     *\n*           1. issue error message                                    *\n*           2. clean up                                               *\n*           3. goback to caller                                       *\n*                                                                     *\n***********************************************************************\nSETMSG   LTR   R7,R7                   CHECK RC FROM BRIF/BROWSE\n         BZ    QUIT50                  OK, exit\nSETMSG4  TRACE\n         LA    R0,L'ZERRMSG\n         ST    R0,DWD\n         ISPLINK (=C'VCOPY ',=C'ZERRMSG ',DWD,ZERRMSG,=C'MOVE ')\n         LTR   R15,R15                 CHECK RC\n         BNZ   QUIT50                  bad, exit\n*\nSETMSG8  ISPLINK (=C'SETMSG ',ZERRMSG)\n         B     QUIT50\n*\nSETMSG44 LR    R0,R15                  save length of long message\n         STRING '    BR R&REL',INTO=SHORTMSG\n         STM   R15,R0,DWD              lengths of short & long msgs\n         ISPLINK (=C'VREPLACE',=C'ZEDSMSG ',DWD,SHORTMSG)\n         ISPLINK (=C'VREPLACE',=C'ZEDLMSG ',DWD+4,MESSAGE)\n         ISPLINK (=C'SETMSG ',=C'ISRZ000 ')\n         BR    R2\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Re-invoke myself via the SELECT service                      *\n*                                                                     *\n*---------------------------------------------------------------------*\nSELECT   ST    R15,DWD                 length\n         BAL   R14,FREEBUFF         <- Free 64KB Buffer\n         ISPLINK (=C'SELECT ',DWD,MESSAGE)\n         LR    R7,R15                  SAVE RETURN CODE FROM ISPLINK\n         B     QUIT50\n*\nQUIT16   LA    R7,16                   RC=16\n*---------------------------------------------------------------------*\n*                                                                     *\n*        free work area and goback to ISPF                            *\n*                                                                     *\n*---------------------------------------------------------------------*\nQUIT50   TM    OPENLIST,X'80'          OPEN list OK?\n         BZ    QUIT53                  no, jump\n         CLOSE MF=(E,OPENLIST)         CLOSE ACB/DCB\n*\nQUIT53   LM    R0,R1,RBATABLE          GET LENGTH, ORIGIN\n         LTR   R0,R0\n         BZ    QUIT55\n         FREEMAIN RU,LV=(0),A=(1)      FREE TABLE OF POINTERS\n*\nQUIT55   TM    S99RBPTR,X'80'          SVC 99 req blk OK?\n         BNO   QUIT60                  no, jump\n         MVI   S99RB+1,2               VERB=FREE\n         OI    S99TUPTR,X'80'          ONLY 1 T.U.\n         MVI   S99T1+1,1               X'55' -> X'01'\n         LA    R1,S99RBPTR\n         DYNALLOC ,                    FREE THE DATA SET\n*\nQUIT60   CLI   DIV_LIST,0              DIV in progress?\n         BE    QUIT90                  no, jump\n         XC    DIV_LIST(4),DIV_LIST    clear flags to prevent S08B-0005\n         DIV   UNIDENTIFY,             remove access                   X\n               MF=(E,DIV_LIST)\n*\nQUIT90   BAL   R14,FREEBUFF         <- Free 64KB Buffer\n*\nQUIT91   LR    R1,R13                  Work area\n         L     R13,4(,R13)\n         LA    R0,DYNAML               length of dynamic storage area\n         FREEMAIN RU,LV=(0),A=(1)      free dynamic storage area\n         LR    R15,R7                  Return code\n         RETURN (14,12),RC=(15)\n         DROP  R9                      CPPL\n*\nFREEBUFF ICM   R1,B'1111',BUFFERP      Address of 64KB Buffer\n         BZR   R14                     zero, jump\n         FREEMAIN R,LV=BUFFERL,A=(1)   Free 64KB Buffer (A24)\n         XC    BUFFERP,BUFFERP         Set Address to zero\n         BR    R14\n         DROP  R12                     A(BUFFER)\n*---------------------------------------------------------------------*\n*        Invoke ISPEXEC service                                       *\n*---------------------------------------------------------------------*\nISPEXEC  ST    R15,DWD                 LENGTH\n         LA    R0,DWD                  LENGTH\n         LA    R1,MESSAGE              text\n         STM   R0,R1,TENWORDS          build parm list\n         OI    TENWORDS+4,X'80'        build parm list\n         L     R15,ISPEXEC@            addr of ISPEXEC\n         LA    R1,TENWORDS             parm list\n         BR    R15                     invoke ISPEXEC service\n***********************************************************************\n*                                                                     *\n*        Scan data at the cursor position for a dsname                *\n*                                                                     *\n*        Some of this code has been lifted from ISPCDSN,              *\n*        (file 270 of the CBT tape), I hope they don't mind.          *\n*                                                                     *\n*        The TLD address is retrieved from ISPTASK's register 1,      *\n*        as done by ISPEXEC and ISPLINK.  If BR is invoked as a       *\n*        program, ISPF passes the TLD address in the second word      *\n*        of the parameter list built by the SELECT service; when      *\n*        BR is invoked as a command, no TLD address is passed, as     *\n*        far as I know.                                               *\n*                                                                     *\n***********************************************************************\nCURSOR   L     R1,X'21C'(,0)           PSATOLD (MY TCB)\n*LOOP\nCURSOR11 L     R2,112(,R1)             TCBFSA\n         CLI   40(R2),C'I'             R5 SLOT CONTAINS 'ISPF'\n         BNE   CURSOR14                NO, JUMP\n         CLI   24(R2),X'00'            IS R1 A 24-BIT ADDR?\n         BNE   CURSOR14                NO, JUMP\n         ICM   R2,B'1111',24(R2)       R1 SLOT (ADDR OF TLD PTR)\n         BZ    CURSOR14                NO, JUMP\n         CLI   0(R2),X'00'             IS IT A CLEAN 24-BIT ADDR?\n         BNE   CURSOR14                NO, JUMP\n         L     R2,0(,R2)               R2->TLD\n         CLC   =C'TLD',0(R2)           IS THIS REALLY A TLD?\n         BE    CURSOR19                YES, EXIT LOOP\nCURSOR14 L     R1,132(,R1)             TCBOTC (MOTHER TASK)\n         CL    R1,124(,R1)             IS IT THE JSTCB?\n         BNE   CURSOR11                NO, CHECK FOR A TLD\n*ENDLOOP\n         B     CURSOR98                exit with \"no-dsname\" rc\n*\n*        TLD located, now get the line address and cursor\n*        position.\n*\nCURSOR19 SLR   R0,R0\n         LH    R1,166(,R2)             get cursor offset (TLDCSR)\n         L     R3,192(,R2)             screen width (TLDCLSWD)\n         DR    R0,R3                   get line # (R0) and offset (R1)\n         LR    R5,R0                   cursor offset in line\n         MR    R0,R3                   get offset to current line\n         AL    R1,096(,R2)             change offset to addr (TLDCLSP)\n         LR    R4,R1                   Current line in screen image\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Scan current line at cursor position for a dsname            *\n*                                                                     *\n*              R4: current line                                       *\n*              R5: cursor position                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\nCURSOR21 MVI   TRNTBL,255\n         MVC   TRNTBL+1(255),TRNTBL    init table\n         SLR   R15,R15\n         SLR   R0,R0\n         BAL   R1,CURSOR22             branch around table, set R1\n         DC    C'$',AL1(1)\n         DC    C'.',AL1(1)\n         DC    C'(',AL1(1)\n         DC    C')',AL1(1)\n         DC    C'#',AL1(2)             #@\n         DC    C'a',AL1(9)\n         DC    C'j',AL1(9)\n         DC    C's',AL1(8)\n         DC    C'{',AL1(1)             C0\n         DC    C'-',AL1(1)             60\n         DC    C'A',AL1(9)\n         DC    C'J',AL1(9)\n         DC    C'S',AL1(8)\n         DC    C'0',AL1(10)\n         DC    X'00',0H'0'             end of table\n*LOOP\nCURSOR22 IC    R15,0(,R1)              FIRST BYTE\n         IC    R0,1(,R1)               ITERATIONS\n*--LOOP\nCURSOR23 LA    R2,TRNTBL(R15)          point to TRNTBL+X'4A'\n         MVI   0(R2),0                 STORE X'00' INTO TRNTBL+X'4A'\n         LA    R15,1(,R15)             BUMP INDEX\n         BCT   R0,CURSOR23             NEXT CHARACTER\n*--ENDLOOP\n         LA    R1,2(,R1)               NEXT ENTRY IN TABLE\n         CLI   0(R1),0                 END OF TABLE?\n         BNE   CURSOR22                NEXT STRING\n*ENDLOOP\n*\n*        scan current line at cursor position to extract the dsn\n*\n         LA    R3,0(R5,R4)             R3-> cursor location\n         CLI   0(R3),C'('              Is it left paren?\n         BZ    CURSOR71                Yes, extract within parens\n         TRT   0(1,R3),TRNTBL          Are we on data set name?\n         BZ    CURSOR60                Yes, begin scanning for start\n         CLI   0(R3),C''''             Is it a quote?\n         BNZ   CURSOR98                No, cursor invalid\n         MVI   QFLAG,X'80'             Yes, indicate left quote\n         TRT   1(1,R3),TRNTBL          Is dsn to right of quote?\n         BZ    CURSOR80                Yes, prepare to extract it\n         LTR   R5,R5                   Cursor in pos 1?\n         BZ    CURSOR98                yes, this is bad\n         BCTR  R3,0                    No,  check left of quote\n         TRT   0(1,R3),TRNTBL          Was it there?\n         BNZ   CURSOR98                No,  cursor invalid\n         MVI   QFLAG,X'01'             Yes, indicate right quote\n*\n*        scan backwards to locate beginning of dsname\n*\nCURSOR60 LTR   R5,R5                   Cursor in pos 1?\n         BZ    CURSOR81                yes, dsn starts in pos 1\n         LR    R0,R3                   current position\n         SR    R0,R4                   subtract addr of pos 1\n         BNP   CURSOR98                bad, quit\n*loop\nCURSOR62 BCTR  R3,0                    R3-> cursor location\n         TRT   0(1,R3),TRNTBL          Byte in table?\n         BNZ   CURSOR70                No,  found left delimiter\n         BCT   R0,CURSOR62             Yes, decr offset; check next\n*endloop\n         B     CURSOR81                dsname starts in pos 1\n*\n*        R3 now points to start of dsname\n*\nCURSOR70 CLI   0(R3),C'('              Was delimiter left paren?\n         BNE   CURSOR75                No, include parens in dsn\nCURSOR71 MVI   TRNTBL+C')',C')'        Make right paren a delimiter\n         MVI   TRNTBL+C'(',0           Include parens in dsn if present\n         B     CURSOR80                Extract withing parens\nCURSOR75 MVI   TRNTBL+C'(',0           Include parens in dsn if present\n         CLI   0(R3),C''''             Was delimiter a quote?\n         BNE   CURSOR80                No,  leave bits unchanged\n         OI    QFLAG,X'80'             Yes, indicate left quote\n*\n*        scan dsname to locate its right boundary\n*\nCURSOR80 LA    R3,1(,R3)               R3-> left position of dsname\n*\nCURSOR81 TRT   0(56,R3),TRNTBL         Scan until not in table\n         BZ    CURSOR98                end dlm not found, exit\n         LR    R2,R1                   R2-> right delimiter\n         CLI   0(R2),C''''             Was delimiter a quote?\n         BNE   CURSOR90                No,  leave bits unchanged\n         OI    QFLAG,X'01'             Yes, indicate right quote\n*\nCURSOR90 TM    QFLAG,X'81'             Quotes surrounding dsname ?\n         BM    CURSOR98                no matching quotes\n         LR    R0,R2                   R0 = first byte after dsname\n         LR    R1,R3                   R1 = first byte of dsname\n         SLR   R0,R1                   R0 = length\n         BR    R14                     exit\n*\nCURSOR98 SLR   R0,R0                   no dsname\n         SLR   R1,R1                   no dsname\n*\nCURSOR99 BR    R14                     GOBACK\n***********************************************************************\n*                                                                     *\n*        PARSE A COMMA-DELIMITED JCL PARM                             *\n*                                                                     *\n*        LA    R4,PARM                 PARM VALUE                     *\n*        LH    R5,LENGTH               PARM LENGTH                    *\n*        L     R15,=A(PARSE_PARM)                                     *\n*        BALR  R14,R15                                                *\n*        DC    S(L'PARM1,PARM1)        LENGTH,ADDR                    *\n*        DC    S(L'PARM2,PARM2)        LENGTH,ADDR                    *\n*                                                                     *\n***********************************************************************\nPARSE_PARM SAVE (14,12),,*\n         BCTR  R4,0                    START OF PARM - 1\n         ALR   R5,R4                   LAST BYTE OF PARM\n*LOOP\nPARSE_PARM1 SLR R0,R0                  R0 = 00000000\n         ICM   R0,B'0011',2(R14)       R0 = 0000BDDD\n         SRDL  R0,12(0)                R0 = 0000000B, R1= BBB.....\n         SRL   R1,20(0)                R1 = 00000DDD DISPLACEMENT\n         ALR   R1,R13                  ADD CALLER'S SAVE AREA ADDR\n         LR    R6,R1                   ADDR OF TARGET FIELD\n         LH    R7,0(,R14)              LENGTH OF TARGET FIELD\n*\n         LA    R2,1(,R4)               FIRST BYTE OF CURRENT PARAMETER\n*--LOOP\nPARSE_PARM2 LA R4,1(,R4)               BUMP POINTER\n         CLR   R4,R5                   END OF PARM REACHED?\n         BH    PARSE_PARM4             YES, EXIT LOOP\n         CLI   0(R4),C','              DELIMITER?\n         BNE   PARSE_PARM2             NO, KEEP LOOPIN'\n*--ENDLOOP\nPARSE_PARM4 LR R3,R4                   POSITION OF ','\n         SR    R3,R2                   LENGTH OF SOURCE PARAM\n         ICM   R3,B'1000',=C' '        PADDING\n         MVCL  R6,R2                   MOVE SOURCE TO TARGET\n         LA    R14,2+2(,R14)           NEXT TARGET\n         CLI   0(R14),0                IS THIS A FIELD DESCRIPTOR?\n         BE    PARSE_PARM1             YES, PROCESS IT\n*ENDLOOP\n         RETURN (0,12),T\n***********************************************************************\n*                                                                     *\n*        VSAM READ ROUTINE                                            *\n*                                                                     *\n***********************************************************************\n$FARRTNE LOCTR\nREADVS00 SAVE  (14,12),,'VSBROWSE - VSAM READ RTNE'\n         LM    R4,R7,0(R1)             INPUT PARMS\n         L     R7,0(,R7)               A(SAVERRTN)\n         ST    R13,4(,R7)\n         ST    R7,8(,R13)\n         LR    R13,R7\n         USING SAVERRTN,R13\n         LM    R10,R11,BASEREGS\n         L     R12,BUFFERP             A(BUFFER)\n         USING BUFFER,R12\n*\nREADVS10 TRACE\n         L     R3,0(,R6)               RECORD NUMBER (FROM BROWSE)\n         C     R3,MAXRECNO             BEYOND END OF FILE?\n         BH    READVS80                YES, EXIT\n*\n         LA    R7,RPL1                 OPTCD=SEQ\n         USING IFGRPL,R7\n         CLI   VS_TYPE,C'R'            is this an RRDS?\n         BE    RRDS00                  YES, JUMP\n         CLI   VS_TYPE,C'L'            is this an LDS?\n         BE    LDS000                  YES, JUMP\n*\n*        check rbatable if record has already been read\n*\nREADVS30 LR    R2,R3                   RRN\n         BCT   R2,READVS3B             RELATIVE TO ZERO\n         ICM   R2,B'1111',HIGH_RRN     first time through?\n         BZ    READVS3L                yes, issue seq read\n         XC    LOWRBA,LOWRBA           RRN=1, set RBA to zero\n         B     READVS51                no, issue seq read\nREADVS3B EQU   *                       XADDR=Y\n         SLL   R2,2                    MAKE IT AN INDEX IN RBA TABLE\n         CLI   XADDR,C'Y'              extended-addressability format?\n         BE    READVS3D                no, jump\n         AL    R2,RBATABLE+4           CHANGE OFFSET TO ADDRESS\n         ICM   R2,B'1111',0(R2)        GET RBA OF RECORD\n         BZ    READVS3L                not read, issue GET\n         ST    R2,LOWRBA               store RBA into ARG\n         B     READVS51                ALREADY READ, JUMP\n*\nREADVS3D EQU   *                       XADDR=Y\n         ALR   R2,R2                   8-byte XRBAs\n         AL    R2,RBATABLE+4           CHANGE OFFSET TO ADDRESS\n         LM    R0,R1,0(R2)             XRBA\n         LTR   R1,R1                   Record read already?\n         BZ    READVS3L                not read, issue GET\n         STM   R0,R1,LOWRBA            store XRBA into ARG\n         B     READVS51                ALREADY READ, JUMP\n*\n*        the record requested has never been read; read the file\n*        sequentially until the desired record is reached.\n*\nREADVS3L EQU   *\n         L     R8,HIGH_RRN             LAST RECORD READ SEQUENTIALLY\n*LOOP\nREADVS31 TRACE\n         GET   RPL=RPL1                GET NEXT RECORD\n         LTR   R15,R15                 OK?\n         BZ    READVS45                YES, JUMP\n*\n*        actual end of data (should only occur when SHOWCB\n*        returned MAXRECNO=0)\n*\n         CLI   RPLRTNCD,X'08'          IS THIS A LOGICAL ERROR?\n         BNE   READVS38                NO, JUMP\n         CLI   RPLFDB3,X'04'           end of data?\n         BE    READVS81                YES, exit\n ORG *-4 AXB 226C\n         BNE   READVS34                NO, CHECK OTHER CONDITIONS\n         CL    R8,MAXRECNO             BEYOND MAXRECNO?\n         BNL   READVS81                YES, EXIT\n         ST    R8,MAXRECNO             NO, ADJUST MAXRECNO\n         B     READVS80                RETURN MAXRECNO TO BRIF\n*\n*        The first time a spanned record is read (FDBK=X'84'),\n*        switch RPL1 and RPL2 from OPTCD=LOC to OPTCD=MVE.\n*        From that point on, all GETs will be move mode.\n*        Note that a cluster defined with the SPANNED attribute\n*        does not necessarily contain spanned records (ie records\n*        made up of more than one segment).\n*\nREADVS34 CLI   RPLFDB3,X'48'           OPTCD=KEY with DATA component?\n         BE    READVS35                YES, JUMP\n*\n         CLI   RPLFDB3,X'84'           OPTCD=LOC WITH SPANNED RECORDS?\n         BNE   READVS90                no, error\n*\n         NI    RPLOPT1,255-RPLLOC      OPTCD=MVE\n         NI    RPLOPT1-IFGRPL+RPL2,255-RPLLOC  OPTCD=MVE\n         LA    R0,BUFFER               THE RIGHT WORD\n         ST    R0,RPLAREA              STORE AREA ADDRESS INTO RPL\n         ST    R0,RPLAREA-IFGRPL+RPL2  STORE AREA ADDRESS INTO RPL2\n         L     R0,=F'65536'            AREALEN=65536\n         ST    R0,RPLBUFL              AREALEN=65536\n         ST    R0,RPLBUFL-IFGRPL+RPL2  AREALEN=65536 INTO RPL2\n         B     READVS40\n*\nREADVS35 MVI   VS_TYPE,C'E'            Cluster is an ESDS\n         MVI   RPLOPT2-IFGRPL+RPL1,RPLADR    OPTCD=ADR\n         B     READVS40\n*\n*        Physical error (R15=0C)\n*\nREADVS38 CLC   RPLFDBK,=X'0C0004'      R15=0C,ERRCD=04 ?\n         BNE   READVS90                NO, exit\n         TM    SWITCH1,SW1CMD          invoked as a command ?\n         BO    READVS90                yes, exit to prevent S30A-18\n         CLOSE MF=(E,OPENLIST)         close the ACB\n         XC    ACBBUFSP,ACBBUFSP       BUFSP=0\n         OPEN  MF=(E,OPENLIST)         re-open the ACB\n*\n*        re-read a record after X'48' or X'84'\n*\nREADVS40 TRACE\n         GET   RPL=RPL1                RE-READ RECORD AFTER 48 OR 84\n         LTR   R15,R15                 OK?\n         BNZ   READVS90                NO, QUIT\n*\n*        store RBA into RBATABLE for the next time this record is read\n*\nREADVS45 LR    R2,R8                   RRN\n         SLL   R2,2                    MAKE IT AN INDEX IN RBA TABLE\n         CLI   XADDR,C'Y'              extended-addressability format?\n         BE    READVS46                no, continue\n         AL    R2,RBATABLE+4           CHANGE OFFSET TO ADDRESS\n         MVC   0(4,R2),RPLDDDD         SAVE RBA OF RECORD\n         B     READVS47\nREADVS46 EQU   *\n         ALR   R2,R2                   8-byte XRBAs\n         AL    R2,RBATABLE+4           CHANGE OFFSET TO ADDRESS\n         MVC   0(8,R2),RPLRBAR         SAVE XRBA OF RECORD\nREADVS47 EQU   *\n         LA    R0,1                    count records actually read\n         AL    R0,VS_RECNO             count records actually read\n         ST    R0,VS_RECNO             count records actually read\n         CH    R0,=H'1'                1st record?\n         BNE   READVS48                no, jump\n         MVC   LOWRBA,RPLRBAR          yes, copy RBA of 1st record\nREADVS48 EQU   *\n         LA    R8,1(,R8)               BUMP CURRENT RRN\n         CR    R8,R3                   Was it the record needed?\n         BL    READVS31                no, get next\n*ENDLOOP\n         ST    R3,HIGH_RRN             SAVE RRN OF RECORD\n         L     R1,RBATABLE+4           point to rbatable\n         MVI   0(R1),X'7F'             dummy RBA for record 1\n         B     READVS70\n*\n*        re-read a record already read, using the RBA kept in the table\n*\nREADVS51 LA    R7,RPL2                 OPTCD=DIR\n         LA    R0,LOWRBA               specify search argument\n         ST    R0,RPLARG               store ARG addr into RPL2\n         NI    RPLOPT1,255-RPLSEQ      clean up OPTCD=SEQ\n         OI    RPLOPT1,RPLDIR          set OPTCD=(ADR,DIR,KGE)\n         MVI   RPLOPT2,RPLADR          set OPTCD=(ADR,DIR,KGE)\n         GET   RPL=RPL2                re-read record\n         LTR   R15,R15                 OK?\n         BZ    READVS70                yes, jump\n*\n*        When 1st record is deleted, 1st good record is an error:\n*        RPLFDBWD=2B080020 REQ=00 OPTCD=C440 RRN=1 RBA=0000000000000000\n*\n         CH    R15,=H'8'               R15=8 ?\n         BNE   READVS70                yes, jump\n         CLI   RPLERRCD,X'20'          BAD RBA ?\n         BNE   READVS57                no, jump\n         CH    R3,=H'1'                RRN=1 ?\n         BNE   READVS57                no, jump\n         CLOSE MF=(E,OPENLIST)         CLOSE VSAM data set\n         OPEN  MF=(E,OPENLIST)         OPEN VSAM data set\n         LTR   R15,R15                 OK?\n         BNZ   READVS57                no, jump\n         LA    R7,RPL1                 OPTCD=SEQ\n         GET   RPL=RPL1                re-read 1st record\n         LTR   R15,R15                 OK?\n         BNZ   READVS57                no, jump\n         LA    R1,1                    RRN=1\n         ST    R1,HIGH_RRN             RRN=1\n         B     READVS70                ok, jump\n*\nREADVS57 EQU   *\n         STRING '** ERROR ** RPLFDBWD=',(RPLFDBWD,,X),                 X\n               ' REQ=',(RPLREQ,,X),' OPTCD=',(RPLOPTCD,2,X),           X\n               ' RRN=',((R3),,L),' RBA=',(LOWRBA,,X),                  X\n               INTO=MESSAGE\n         SLR   R15,R15                 RC=00\n         B     READVS95                ISSUE MESSAGE\n*\n*        KEYED ACCESS (RRDS)\n*\nRRDS00   ST    R3,LOWRBA               RRN\n         LA    R7,RPL2                 OPTCD=DIR\n         MVI   RPLOPT1,RPLLOC+RPLDIR   OPTCD=(DIR,KEQ,LOC,KEY)\n         MVI   RPLOPT2,RPLKEY          OPTCD=(DIR,KEQ,LOC,KEY)\n         GET   RPL=RPL2                GET RECORD (RRDS)\n         LTR   R15,R15                 OK?\n         BZ    READVS70                YES, JUMP\n         STRING '** ERROR ** RPLFDBWD=',(RPLFDBWD,,X),                 X\n               ' REQ=',(RPLREQ,,X),' OPTCD=',(RPLOPTCD,2,X),           X\n               ' RRN=',((R3),,L),INTO=MESSAGE\n         SLR   R15,R15                 RC=00\n         B     READVS95                ISSUE MESSAGE\n*\n*        Linear data set\n*\nLDS000   BCTR  R3,0                    RRN relative to zero\n         MH    R3,MAXLRECL+2           make it an RBA\n         ST    R3,TTTR                 save RBA\n         CL    R3,LOWRBA               this page in storage?\n         BL    LDS020                  no, jump\n         L     R1,=F'65536'            window size\n         AL    R1,LOWRBA               first RBA after end of window\n         SL    R1,MAXLRECL             end address\n         CLR   R3,R1                   this page in storage?\n         BL    LDS050                  yes, jump\n*\n*        un-stage previous pages\n*\nLDS020   CLI   LOWRBA,X'7F'            first time?\n         BE    LDS022                  yes, jump\n         XC    DIV_LIST(4),DIV_LIST    prevent S08B-0005\n         DIV   UNMAP,                  unmap previous window           X\n               AREA=BUFFERP,           pointer to my window            X\n               MF=(E,DIV_LIST)\n*\n*        stage 16 pages\n*\nLDS022   LR    R14,R3                  current RBA\n         SRL   R14,12                  convert RBA to block number\n         LA    R15,16                  number of pages in window\n         STM   R14,R15,TENWORDS        store pointers\n         XC    DIV_LIST(4),DIV_LIST    prevent S08B-0005\n         DIV   MAP,                    access                          X\n               OFFSET=TENWORDS+0,      offset to 1st page              X\n               SPAN=TENWORDS+4,        number of pages                 X\n               AREA=BUFFERP,           pointer to my window            X\n               MF=(E,DIV_LIST)\n         LTR   R15,R15                 OK?\n         BNE   X'808'                  no, quit\n*\n         ST    R3,LOWRBA               window offset\n         NC    LOWRBA,=F'-4096'        beginning of page\n*\nLDS050   LA    R2,BUFFER(R3)           CHANGE OFFSET TO ADDRESS\n         SL    R2,LOWRBA               RBA relative to begin of window\n*STRING (LOWRBA,,X),1X,((R3),,X),1X,((R2),,X),INTO=(80-26(R2),26)\n         MVC   RPLRLEN,MAXLRECL        RECORD LENGTH\n         B     READVS74                goback to BRIF\n*\n*        return record just read to BRIF\n*\nREADVS70 L     R2,RPLAREA              NO, GET RECORD ADDR (OPTCD=MVE)\n         TM    RPLOPTCD,RPLLOC         OPTCD=MVE?\n         BZ    READVS74                YES, JUMP\n         L     R2,0(,R2)               GET RECORD ADDR (OPTCD=LOC)\nREADVS74 ST    R2,0(,R4)               PASS RECORD ADDRESS TO BRIF\n         L     R0,RPLRLEN              pick up record length\n         ST    R0,0(,R5)               PASS RECORD LENGTH TO BRIF\n         CL    R0,VS_LRECL             smaller than minimum?\n         BH    *+8                     no, jump\n         ST    R0,VS_LRECL             keep smallest length\n         CL    R0,VS_LRECL+4           larger than maximum?\n         BL    *+8                     no, jump\n         ST    R0,VS_LRECL+4           keep largest length\n*\n         CLI   SHOWRBA,C'Y'            display RBA in pos 1 ?\n         BNE   READVS79                no, continue\n         STRING (RPLDDDD,F,Z),1X,((R2),(R0)),INTO=TSOCMD\n         LA    R14,TSOCMD\n         ST    R14,0(,R4)              addr of data line\n         CLI   XADDR,C'Y'              extended-addressability format?\n         BNE   READVS78                no, continue\n         STRING (RPLRBAR,,X),1X,((R2),(R0)),INTO=TSOCMD\nREADVS78 EQU   *\n         ST    R15,0(,R5)              length of data line\nREADVS79 EQU   *\n         L     R13,4(,R13)\n         RETURN (14,12),RC=00\n*\n*        record number too high, return number of highest rcd to BRIF\n*\nREADVS80 MVC   0(4,R6),MAXRECNO        RETURN MAX RECORD NUMBER\nREADVS81 L     R13,4(,R13)\n         RETURN (14,12),RC=8\n*\n*        error in GET macro, show feedback code\n*\nREADVS90 STRING '** ERROR ** RPLFDBWD=',(RPLFDBWD,,X),                 X\n               ' REQ=',(RPLREQ,,X),' OPTCD=',(RPLOPTCD,2,X),           X\n               ' RRN=',((R3),,L),' HIGH_RRN=',((R8),,L),               X\n               INTO=MESSAGE\n         ST    R3,0(,R6)               END OF FILE\n         ST    R3,MAXRECNO             END OF FILE\n         LA    R15,008                 RC=8 (EOF)\n.@TEST2 SR 15,15\n*\n*        return error message to BRIF\n*\nREADVS95 LA    R0,MESSAGE              MESSAGE\n         ST    R0,0(,R4)               PASS ADDRESS\n         LA    R0,L'MESSAGE            LENGTH\n         ST    R0,0(,R5)               PASS LENGTH\n         L     R13,4(,R13)\n         RETURN (14,12),RC=(15)\n***********************************************************************\n*                                                                     *\n*        NON-VSAM READ ROUTINE                                        *\n*                                                                     *\n*        This routine reads records from a non-vsam data-set          *\n*        by issuing EXCP macros against a BDAM DCB.                   *\n*                                                                     *\n*        This method (EXCP+BDAM DCB) offers the following advantages: *\n*                                                                     *\n*        a. the program has access to all of the volumes of a         *\n*           multi-volume data set at the same time, with a single     *\n*           OPEN, a single DCB, and no need to go through EOV         *\n*                                                                     *\n*        b. full tracks may be read, which speeds up access           *\n*           to un-blocked or poorly-blocked data sets                 *\n*                                                                     *\n***********************************************************************\nREADDA00 SAVE  (14,12),,'DABROWSE - BDAM READ RTNE'\n         LM    R4,R7,0(R1)             parameters from BRIF\n         STM   R4,R7,TENWORDS          save them\n         L     R7,0(,R7)               A(SAVERRTN)\n         ST    R13,4(,R7)\n         ST    R7,8(,R13)\n         LR    R13,R7\n         USING SAVERRTN,R13\n         LM    R10,R11,BASEREGS\n         L     R12,BUFFERP             A(BUFFER)\n         USING BUFFER,R12\n*\n         L     R3,0(,R6)               RECORD NUMBER (FROM BROWSE)\n         CL    R3,MAXRECNO             beyond end of file?\n         BH    READDA80                yes, exit\n         CLI   RECFM,C'F'              RECFM=F?\n         BE    READDA30                yes, jump\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Process RECFM=V/VB/U records                                 *\n*                                                                     *\n*        This routine reads the data set sequentially and             *\n*        builds a table of high RRN (relative record number)          *\n*        for each track.  This table is used to remember which        *\n*        track holds a particular record.                             *\n*                                                                     *\n*---------------------------------------------------------------------*\nREADDA20 L     R1,RBATABLE+4           point to table\n         BAL   R15,*+8                 set R15, skip LA first time\n*--loop\n         LA    R1,4(,R1)               bump index\n         CL    R3,0(,R1)               record on this track?\n         BHR   R15                     no, try next one\n*--endloop\n*PDUMP BUFFER,BUFFER+256\n         LR    R3,R1                   address of table entry\n         SH    R1,=H'4'                previous entry\n         ST    R1,ENDRBA               save address of prev table entry\n*\n         SL    R3,RBATABLE+4           offset\n         SRL   R3,2                    track number\n         SLL   R3,8                    TTT0\n         BAL   R14,EXCP00          <-- read a track\n         LTR   R15,R15                 EOF?\n         BZ    READDA21                no, jump\n*\n*        out-of-extents condition\n*\n         L     R1,ENDRBA               load address of prev table entry\n         MVC   MAXRECNO,0(R1)          last RRN on last track\n         B     READDA80                exit with RC=8\n*\n*        scan track buffer to count records\n*\nREADDA21 L     R1,ENDRBA               load address of table entry\n         CLI   4(R1),X'7F'             end-of-table flag?\n         BNE   READDA24                no, skip buffer scan\n         SLR   R1,R1                   start of track\n         SLR   R2,R2                   record number on this track\n*--loop\nREADDA22 BAL   R14,GETREC              scan buffer\n         LA    R2,1(,R2)               count records on this track\n         LTR   R1,R1                   end of buffer reached?\n         BNZ   READDA22                no, get next record\n*--endloop\n         BCTR  R2,0                    ignore last call\n         STC   R2,TTTR+3               save number of records\n*\n*        store current track's RRN into rbatable\n*\n         L     R1,ENDRBA               load address of prev table entry\n         CL    R1,RBATABLE+4           first track?\n         BL    READDA23                yes, jump\n         AL    R2,0(,R1)               no, add previous track's RRN\nREADDA23 ST    R2,4(,R1)               fill in table entry\n         MVI   8(R1),X'7F'             set table stop\n         L     R3,0(,R6)               RRN from BRIF\n         B     READDA20                keep on reading sequentially\n*endloop\n*\nREADDA24 L     R3,0(,R6)               RRN from BRIF\n         L     R1,ENDRBA               load address of prev table entry\n         CL    R1,RBATABLE+4           first track?\n         BL    READDA25                yes, jump\n         SL    R3,0(,R1)               no, subtract RRN of prev trk\n*\nREADDA25 SLR   R1,R1                   start of track\n*loop\nREADDA26 BAL   R14,GETREC              scan buffer\n         BCT   R3,READDA26             until my record is reached\n*endloop\n         B     READDA70                goback\n*---------------------------------------------------------------------*\n*                                                                     *\n*        process RECFM=F/FB records                                   *\n*                                                                     *\n*        This routine assumes that the data set is RECFM=FS or FBS,   *\n*        i.e. that it does not contain truncated records.             *\n*        This assumption allows the track address of a particular     *\n*        record to be calculated without reading the preceding        *\n*        records.  For example, to access record # 1111 in a          *\n*        data set that has 10 blocks per track and 10 records per     *\n*        block, track 11 is read, then record # 1 of the block # 2    *\n*        is returned to BRIF (1111 = 11*100 + 10 + 1)                 *\n*                                                                     *\n*---------------------------------------------------------------------*\nREADDA30 BCTR  R3,0                    first record is R0\n         M     R2,MAXLRECL             OFFSET IN BYTES\n         LH    R14,DCBBLKSI            PICK UP BLKSIZE\n         DR    R2,R14                  BLOCK NUMBER IN R3, OFFSET IN R2\n         ST    R2,0(,R4)               save offset\n*\n*        R3 = relative block address (first block is zero)\n*\n         SLR   R2,R2\n         D     R2,BLKPTRK              get relative track number\n         LA    R2,1(,R2)               first record on track is R1\n         SLL   R3,8                    R3 = TTTTTT00\n         OR    R3,R2                   R3 = TTTTTTRR\n         BAL   R14,EXCP00          <-- read a track\n         LTR   R15,R15\n         BNZ   READDA80                out-of-extents\n*\n*        scan the buffer for the right block (R3 contains record #)\n*\n         SLR   R1,R1                   start of track\n*loop\nREADDA32 BAL   R14,GETREC              scan buffer\n         LTR   R1,R1                   end of buffer reached?\n         BZ    READDA55                yes, error\n         CLM   R3,B'0001',4(R1)        is this my record number?\n         BNE   READDA32                no, try next block\n*endloop\n         ICM   R0,B'0111',5(R1)        is this an EOF?\n         BZ    READDA51                yes, exit\n         L     R0,MAXLRECL             maximum record length\n         LA    R1,8(,R1)               point to the first record\n         AL    R1,0(,R4)               add record offset\n         B     READDA70                return record to BRIF\n*\nREADDA51 L     R0,0(,R4)               load record offset\n         LTR   R0,R0                   first record?\n         BNZ   READDA55                no, jump\n         LA    R0,L'READDA52           message length\n         BAL   R1,READDA70             branch around message\nREADDA52 DC    C'**EOF**',0H'0'\n*\nREADDA55 LA    R0,L'READDA56           message length\n         BAL   R1,READDA70             branch around message\nREADDA56 DC    C'**NO RECORD FOUND**',0H'0'\n*\nREADDA70 ST    R1,0(,R4)               PASS RECORD ADDRESS TO BRIF\nREADDA71 ST    R0,0(,R5)               PASS RECORD LENGTH TO BRIF\n         L     R13,4(,R13)\n         RETURN (14,12),RC=00\n*\n*        return to BRIF with RC=8 (high RRN)\n*\nREADDA80 MVC   0(4,R6),MAXRECNO        RETURN MAX RECORD NUMBER\n         L     R13,4(,R13)\n         RETURN (14,12),RC=8        <- RC=8   (return highest rrn)\n*---------------------------------------------------------------------*\n*        read a track                                                 *\n*---------------------------------------------------------------------*\nEXCP00   STM   R2,R14,12(R13)\n         CLM   R3,B'1110',TTTR         track in buffer already?\n         BE    EXCP80                  YES, JUMP\n         ST    R3,TTTR                 STORE TRACK ADDRESS\n*\n*        convert TTRN to IOBSEEK (MBBCCHHR)\n*\n         L     R0,TTTR                 load TTTR\n         SRL   R0,8                    make it 0TTT\n         SLL   R0,16                   make it TT00\n         L     R1,DCBDEBAD             DCBDEBAD\n         LA    R2,IOBSEEK              MBBCCHHR FIELD\n         LR    R6,R13                  SAVE R13\n         L     R15,16(,0)              CVTPTR\n         L     R15,28(,R15)            CVTPCNVT\n         BALR  R14,R15                 CONVERT TTRN TO MBBCCHHR\n         LM    R6,R13,28(R6)           RESTORE R6-R13\n         LTR   R15,R15                 OK?\n         BNZ   EXCP90                  no, eof\n         EXCP  IOBSTDRD             <- read a track\n         WAIT  1,ECB=IOBNECB           wait for completion\n*PDUMP BUFFER,BUFFER+400\nEXCP80   SLR   R15,R15                 RC=00\n         CLC   BUFFER(4),IOBSEEK+3     CHECK CCHH\n         BE    EXCP90                  OK, exit with r15=0\n         LA    R15,4                   no, eof\n*\nEXCP90   LM    R2,R14,12(R13)          restore registers\n         BR    R14\n*---------------------------------------------------------------------*\n*                                                                     *\n*        scan read buffer                                             *\n*                                                                     *\n*---------------------------------------------------------------------*\nGETREC   CLI   RECFM,C'V'              RECFM=V?\n         BE    GETRECV1                yes, jump\n*\n*        RECFM=U\n*\n         LTR   R1,R1                   First time?\n         BZ    GETREC8                 yes, jump\n         SLR   R15,R15\n         ICM   R15,B'0011',6(R1)       get record length\n         SLR   R0,R0\n         IC    R0,5(,R1)               get key length\n         LA    R1,8(R15,R1)            l'count+l'data\n         ALR   R1,R0                   add l'key\n         CLC   0(4,R1),IOBSEEK+3       is this my CCHH?\n         BE    GETREC9                 yes, process it\n         SLR   R1,R1                   no, end-of-track\n         BR    R14\nGETREC8  LA    R1,BUFFER               start-of-track\nGETREC9  SLR   R0,R0\n         ICM   R0,B'0011',6(R1)        block size (from count+6)\n         AH    R0,=H'8'                add l'count\n         CL    R0,MAXLRECL             too big?\n         BNHR  R14                     no, goback\n         L     R0,MAXLRECL             yes, truncate\n         BR    R14\n*\n*        RECFM=V\n*\nGETRECV1 LTR   R1,R1                   First time?\n         BZ    GETRECV5                yes, jump\n         CLC   MAXLRECL+2(2),0(R1)     RDW length OK?              @133\n         BL    GETRECV2                no, EOF                     @133\n         AH    R1,0(,R1)               add length from RDW\n         CL    R1,RECAD                end of block?\n         BL    GETRECV9                not yet, process this record\n         CLC   0(4,R1),IOBSEEK+3       is this my CCHH?\n         BE    GETRECV8                yes, process it\nGETRECV2 SLR   R1,R1                   no, end-of-track\n         BR    R14\nGETRECV5 SLR   R0,R0                                               @133\n         SLR   R1,R1                                               @133\n         ICM   R0,B'1100',BUFFER+6     get DD from CCHHRKDD        @133\n         CL    R0,BUFFER+8             is this a BDW?              @133\n         BNER  R14                     no, EOF                     @133\n         LA    R1,BUFFER               start-of-track\nGETRECV8 SLR   R15,R15\n         ICM   R15,B'0011',6(R1)       block size (from count+6)\n         LA    R0,7(R15,R1)            last byte of current block\n         ST    R0,RECAD                save end of block address\n         LA    R1,8(,R1)               skip count, point to BDW\n         LA    R1,4(,R1)               first record in this block\nGETRECV9 LH    R0,0(,R1)               length of the record from RDW\n         BR    R14\n         DROP\n***********************************************************************\n*                                                                     *\n*        BRIF Command Routine                                         *\n*                                                                     *\n*        This routine is invoked by BRIF each time a command is       *\n*        entered on the BROWSE screen.  If the user enters the V      *\n*        command, then BR invokes VV to VIEW the VSAM file.           *\n*                                                                     *\n***********************************************************************\nCMDRTNE  SAVE  (14,12),,*\n         L     R1,04(,R1)              PTR TO DIALOG DATA AREA (DDATA)\n         L     R1,0(,R1)               A(SAVERRTN)\n         LA    R1,SAVE2-SAVERRTN(,R1)  A(SAVE2)\n         ST    R1,8(,R13)              CHAIN SAVE AREAS\n         ST    R13,4(,R1)              CHAIN SAVE AREAS\n         LM    R13,R1,8(R13)           CALLER'S SAVE AREA\n         USING SAVE2,R13\n         LM    R10,R11,BASEREGS\n         USING VSBROWSE,R10\n         USING VSBROWSE+4095,R11\n         L     R6,00(,R1)              Function Code\n*-       L     R9,LINE_LEN_ADDR+4      A(LINE)\n*-       USING LINE_DSECT,R9\n         CLC   =F'20',0(R6)            UNKNOWN COMMAND?\n         BNE   CMDRTNE4                NO, EXIT\n         LA    R0,L'MESSAGE            max length of variable\n         ST    R0,DWD                  max length of variable\n         ISPLINK (=C'VCOPY ',=C'ZCMD ',DWD,MESSAGE,=C'MOVE ')\n         OI    MESSAGE+0,C' '          upper-case\n         OI    MESSAGE+1,C' '          upper-case\n         OI    MESSAGE+2,C' '          upper-case\n         OI    MESSAGE+4,C' '          upper-case\n         CLC   DSORG,=AL2(DS1ORGAM)    DSORG=VSAM?\n         BNE   CMDRTNE4                NO, EXIT\n         CLC   =C'V ',MESSAGE          ZCMD=\"V\" ?\n         BE    CMDRTNE5                yes, do it\n         CLC   =C'LC ',MESSAGE         ZCMD=\"LC\" ?\n         BE    CMDRTNE6                yes, do it\n         CLC   =C'RBA ',MESSAGE        ZCMD=\"RBA\" ?\n         BE    CMDRTNE7                yes, do it\nCMDRTNE4 L     R13,4(,R13)             BRIF SAVE AREA\n         RETURN (14,12),RC=4           ISPF will process the command\n*\n*        Invoke VSAMVIEW when user enters V during BROWSE display\n*\nCMDRTNE5 STRING 'VSAMVIEW ''',(FULLDSN,,T),'''',INTO=TSOCMD\n         STRING 'SELECT CMD(',(TSOCMD,,T),') MODE(FSCR)',INTO=MESSAGE\n         ST    R15,DWD                 LENGTH\n         B     CMDRTNE9                exec cmd\n*\n*        Invoke LISTCAT when user enters LC during BROWSE display\n*\n*        If the FASTPATH and STEMDISP programs are available,\n*        FASTPATH/FSTSO is invoked to display the LISTCAT output\n*        in ISPF/PDF BROWSE format.\n*        If FASTPATH and/or STEMDISP are not available, the LISTCAT\n*        output is displayed in TSO PUTLINE mode.\n*\n*        If LC is already an ISPF command in one of the xxxxCMDS\n*        tables, then enter >LC instead of LC\n*\nCMDRTNE6 STRING 'LISTCAT ENT(''',(FULLDSN,,T),''') ALL',INTO=TSOCMD\n         STRING 'SELECT CMD(',(TSOCMD,,T),') MODE(FSCR)',INTO=MESSAGE\n         ST    R15,DWD                 LENGTH\n         LOAD  EP=FASTPATH,ERRET=CMDRTNE9\n         LOAD  EP=STEMDISP,ERRET=CMDRTNE9\n         STRING 'SELECT PGM(FASTPATH) PARM(FSTSO,',(TSOCMD,,T),')',    X\n               INTO=MESSAGE\n         ST    R15,DWD                 LENGTH\n         B     CMDRTNE9                exec cmd\n*\n*        RBA Command ON/OFF\n*\nCMDRTNE7 EQU   *\n         CLI   SHOWRBA,C'Y'            display RBA already ?\n         BNE   CMDRTNE7#               no, turn it ON\n         MVI   SHOWRBA,C'N'            yes, turn it OFF\n         B     CMDRTNE9\nCMDRTNE7# EQU   *\n         MVI   SHOWRBA,C'Y'            display RBA\n*\nCMDRTNE9 EQU   *\n         ISPLINK (=C'CONTROL ',=C'DISPLAY ',=C'SAVE ')\n         LA    R0,DWD                  LENGTH\n         LA    R1,MESSAGE              text\n         STM   R0,R1,TENWORDS          build parm list\n         OI    TENWORDS+4,X'80'        build parm list\n         L     R15,ISPEXEC@            addr of ISPEXEC\n         LA    R1,TENWORDS             parm list\n         SYNCH (R15)                <- execute command via ISPEXEC\n         LR    R2,R15                  Save RC\n         ISPLINK (=C'CONTROL ',=C'DISPLAY ',=C'RESTORE ')\n         L     R13,4(,R13)             BRIF SAVE AREA\n         RETURN (14,12),RC=0           command processed\n         DROP\n*---------------------------------------------------------------------*\n*        MODEL DCB, ACB, RPL                                          *\n*---------------------------------------------------------------------*\n*        PRINT NOGEN\nACB1_M   ACB   MACRF=(ADR,KEY,SEQ,DIR,IN),STRNO=2,RMODE31=ALL,         X\n               BUFSP=200000\nRPL1_M   RPL   ACB=*-*,OPTCD=(KEY,SEQ,LOC,NSP),AREA=*-*,AREALEN=4\nRPL2_M   RPL   ACB=*-*,OPTCD=(ADR,DIR,LOC,KGE),AREA=0,AREALEN=4,ARG=0\nDCB1_M   DCB   DSORG=DA,MACRF=RIC,DDNAME=SYSUT1\nMODELS_L EQU   *-ACB1_M\n*---------------------------------------------------------------------*\n*        DEFINE INPUT PARAMETERS FOR IKJPARS                          *\n*---------------------------------------------------------------------*\nPCLCSECT IKJPARM\nDSNPCE   IKJPOSIT DSNAME,USID,PROMPT='DATA SET NAME',                  X\n               HELP='NAME OF THE DATA SET TO BE BROWSED'\nVOLPCE   IKJKEYWD\n         IKJNAME 'VOLUME',SUBFLD=VOLSUBF,ALIAS='VOLSER'\nVOLSUBF  IKJSUBF\nVOLPCE2  IKJIDENT 'VOLUME',MAXLNTH=6,FIRST=ALPHANUM,OTHER=ALPHANUM\n         IKJENDP\n***********************************************************************\n*                                                                     *\n*        Dynamic Storage           <-- R13                            *\n*                                                                     *\n***********************************************************************\nDYNAM    DSECT\n         DS    18F                     SAVE AREA (MAIN LINE)\nSAVERRTN DS    18F                     SAVE AREA (READ ROUTINE)\nSAVE2    DS    18F                     SAVE AREA (CMD ROUTINE)\nBASEREGS DS    A(R10,R11)\nTENWORDS DS    10F                     LEN/ADDR OF BDAM BUFFER\nDWD      DS    D                       VCOPY\nDIV_TOKN DS    D                       DIV token\nDIV_LIST DIV   IDENTIFY,MF=L           DIV parm list\nZAPPLID  DS    C'ISR     '             current ISPF application ID\nZDLDSORG DS    C'VS      '             data set org from PDF 3.4 panel\nZERRMSG  DS    C'12345678'             ERROR MESSAGE\nBRDATAID DS    C'ISR12345'             DATA ID from LMINIT\nDDATA    DS    A(SAVERRTN)             data addr for BRIF\nBUFFERP  DS    A(BUFFER)               Address of 64KB Buffer\nPANEL    DS    C'ISRBROBF'             panel name\nREADRTNE DS    A(READDA00)             read routine\nISPLINK@ DS    V(ISPLINK)              ISPF interface\nISPEXEC@ DS    V(ISPEXEC)              ISPF interface\nRBATABLE DS    A(0,0)                  RBA TABLE\nHIGH_RRN DS    F                       RRN OF LAST RECORD\nDYNANSWR DS    F                       LEN/ADDR OF BDAM BUFFER\nECB1     DS    F                       LEN/ADDR OF BDAM BUFFER\nOWNCDE   DS    A(CDENTRY)              my own CDE\nOWNNAME  DS    CL8                     my true name\nMEMBER   DS    CL8                     MEMBER NAME\nSWITCH1  DS    B'00000000'             switches (1)\nSW1CMD   EQU   B'10000000'             invoked as a command\nSW1UVOL  EQU   B'01000000'             VOLSER given by user\nVS_TYPE  DS    C'K'                    VSAM type: K E R\nXADDR    DS    C'N'                    extended-addressability format\nRECFM    DS    C'F'                    RECFM: F/V/U\nSHOWRBA  DS    C'Y'                    display RBA in pos 1\nQFLAG    DS    X                       Quote/Apost\nOPENLIST OPEN  IFGACB,MF=L\n         IFGACB DSECT=NO\nRPL1     RPL   ACB=IFGACB,OPTCD=(KEY,SEQ,LOC)\nRPL2     RPL   ACB=IFGACB,OPTCD=(ADR,DIR,LOC)\nDCB1     DCB   DSORG=DA,MACRF=RIC,OPTCD=R,DDNAME=SYSUT1\nDCBKEYLE EQU   DCB1+16,1,C'F'          key length\nDCBREL   EQU   DCB1+17,3,C'F'          number of tracks in data set\nDCBDSORG EQU   DCB1+26,2,C'X'          data set org\nDCBDDNAM EQU   DCB1+40,8,C'C'          ddname\nDCBDEBAD EQU   DCB1+44,4,C'A'          DEB pointer\nDCBBLKSI EQU   DCB1+62,2,C'H'          BLKSIZE\nDCBRECFM EQU   DCB1+36,1,C'X'          RECFM\nDCBRECU  EQU   X'C0'\nDCBRECF  EQU   X'80'\nDCBRECV  EQU   X'40'\n*\n         IEZIOB DSECT=NO\nCCW1     CCW   X'23',SECTORNO,CC,1     SET SECTOR\nCCW2     CCW   X'31',IOBCC,CC,5        SEARCH ID EQUAL\nCCW3     CCW   X'08',CCW2,0,1          TIC\nCCW4     CCW   X'1E',BUFFER,SLI,8+256  READ KEY+DATA\nCC       EQU   X'40'                   COMMAND CHAINING\nSLI      EQU   X'20'                   SUPPRESS LENGTH ERROR\nSECTORNO DS    FL1'0'                  Sector number for RPS devices\n*\n         IHADVA DSECT=NO               work area for DEVTYPE macro\nRECAD    DS    A                       BLOCK NUMBER\nLOWRBA   DS    D                       used for POINT and RRDS GET\nTTTR     DS    F                       USED FOR BDAM\nBLKPTRK  DS    F                       Number of blocks per track\nMAXRECNO DS    F'12345678'          +0 MAX RECORD NUMBER\nMAXLRECL DS    F'32760'             +4 MAX LRECL\nENDRBA   DS    F'32760'             +8 ENDRBA FOR RRDS\n*\nVS_LRECL DS    F'32760',F'0'           VSAM minimum, maximum\nVS_RECNO DS    F'1'                    VSAM records actually read\n*\nS99RBPTR DS    A(S99RB+X'80000000')\nS99RB    DS    A(X'14012000',0,S99TUPTR,0,0)\nS99TUPTR DS    10A\nS99T1    DS    AL2(X'0055',1,L'DDNAME) RETURN DDNAME\nDDNAME   DS    CL8       '\nS99T2    DS    AL2(X'0002',1,L'DSNAME) DSNAME\nDSNAME   DS    CL44,C                       data set name\nS99T56   DS    AL2(X'0056',1,L'DSNAME2) RETURN TRUE DSNAME\nDSNAME2  DS    CL44\nS99T57   DS    AL2(X'0057',1,L'DSORG)  RETURN DSORG\nDSORG    DS    X'0000'\nS99T5D   DS    AL2(X'005D',1,L'VOLSER) RETURN VOLSER\nVOLSER   DS    C'VOLSER'\n*----------------------------------------------------------------------\n         DS    0D\n         IECSDSL1 1                    F1-DSCB\n         DS    5X,2X                   CCHHR,#DSCBs - z/OS R10\n*\nZENVIR   DS    CL32'ISPF 3.2'          CURRENT ISPF LEVEL\nFULLDSN  DS    CL56                    'data.set(member)'\nMESSAGE  DS    CL256\nTSOCMD   DS    CL256\nSHORTMSG DS    CL32\nTRNTBL   DS    CL256                   dsname scan\nDYNAML   EQU   *-DYNAM\n*\nBUFFER   DSECT\n         DS    64CL1024                64KB\nBUFFERL  EQU   *-BUFFER\n*----------------------------------------------------------------------\n         IKJCPPL                       Command Buffer Parm List\n         IKJPPL                        Parse Parm List (IKJPARS)\n         IKJECT                        Environment Control Table\n         IKJUPT                        User Profile Table\nIFGRPLVS OPSYN ANOP\n         IFGRPL DSECT=YES\n         IHACDE ,                      Contents Directory Entry\n         STRING (GENERATE,,LOCTR)\n         YREGS\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR            DIV\n//         DD DSN=SYS1.MODGEN,DISP=SHR            OBTAIN/IECSDSL1\n//         DD DSN=GILBERT.FILE183.PDS,DISP=SHR    STRING\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*-------------------------------------------------------------------\n//LKED    EXEC PGM=HEWL,PARM='LIST,MAP,RENT,REFR'\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=GILBERT.FILE183.LOAD(BR),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BUILDCDE": {"ttr": 3331, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x00\\x852_\\x00\\x95\\x14/\\x171\\x00\\xd1\\x00\\xe7\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf0\\xf0@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1985-11-21T00:00:00", "modifydate": "1995-05-22T17:31:00", "lines": 209, "newlines": 231, "modlines": 0, "user": "CBT400"}, "text": "//GILBERTL JOB (ACCT#),BUILDCDE,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//ASMH EXEC PGM=IEV90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n* MACRO NAME = BUILDCDE                                               *\n*                                                                     *\n* DESCRIPTIVE NAME = BUILD A MAJOR CDE TO IDENTIFY A STORAGE AREA     *\n*                                                                     *\n* FUNCTION = MAKES A STORAGE AREA EASIER TO LOCATE IN A               *\n*            DUMP BY MAKING IT APPEAR AS A LOAD_MODULE.               *\n*                                                                     *\n* STATUS = R200                                                       *\n*                                                                     *\n* AUTHOR = GILBERT SAINT-FLOUR <carlos@gsf-soft.com>                  *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*     AMODE = ANY                                                     *\n*     SCP   = MVS/XA OR MVS/ESA                                       *\n*     KEY   = USER                                                    *\n*     MODE  = PROBLEM                                                 *\n*     APF   = OFF                                                     *\n*                                                                     *\n* OPERATION = BUILDCDE USES THE \"LOADER\" FORM OF IDENTIFY TO CREATE   *\n*             A MAJOR CDE AND CORRESPONDING XL, THEN ISSUES A LOAD    *\n*             SVC TO CREATE AN LLE AND ASSOCIATE THE CDE WITH THE     *\n*             CURRENT TCB.                                            *\n*                                                                     *\n* INVOCATION = SEE BELOW                                              *\n*                                                                     *\n*          (BEFORE)     GETMAIN RU,LV=20000                           *\n*                                                                     *\n*          (AFTER)      GETMAIN RU,LV=20000                           *\n*                       BUILDCDE LENGTH=(0),ADDR=(1),EP=DYNAM         *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*        BUILDCDE MAY BE ISSUED MORE THAN ONCE, PROVIDED THE EP       *\n*        KEY-WORD HAS A DIFFERENT VALUE EACH TIME.                    *\n*                                                                     *\n*        IF STORAGE WAS ALLOCATED IN SUB-POOL ZERO (SP=0 IS           *\n*        SPECIFIED OR DEFAULTED TO IN THE GETMAIN MACRO),             *\n*        THE DELETE MACRO MAY BE ISSUED AGAINST THE SPECIFIED EP      *\n*        TO DELETE THE CDE AND FREE UP THE STORAGE.                   *\n*                                                                     *\n*        IF GETMAIN SPECIFIES A NON-ZERO SUBPOOL, THE DELETE MACRO    *\n*        DELETES THE CDE BUT DOES NOT FREE UP THE STORAGE:  YOU       *\n*        MUST ISSUE FREEMAIN YOURSELF.                                *\n*                                                                     *\n*        IN A MAJOR CDE CREATED BY THE \"LOADER\" FORM OF IDENTIFY,     *\n*        THE \"RENT\" AND \"REUS\" ATTRIBUTES ARE OFF.  THIS MEANS        *\n*        THAT YOU MAY NOT ISSUE LOAD AGAINST THE EP NAME (BUILDCDE    *\n*        HAS ALREADY ISSUED LOAD), BUT YOU MAY ISSUE LINK, ATTACH     *\n*        OR XCTL IF YOU WANT TO (ONCE ONLY).  YOU MAY ALSO ISSUE      *\n*        THE STANDARD FORM OF IDENTIFY TO DEFINE SECONDARY ENTRY      *\n*        POINTS WHICH HAVE THE \"RENT\" ATTRIBUTE.                      *\n*                                                                     *\n*        IF THIS MACRO IS USED BY AN AUTHORIZED PROGRAM, THEN         *\n*        A S306 ABEND WILL OCCUR (THE CDE CREATED HAS ITS CDSYSLIB    *\n*        BIT OFF).  LOOK FOR A SECOND VERSION OF THE MACRO THAT MAY   *\n*        BE USED IN AN AUTHORIZED PROGRAM AT THE END OF THIS JOB.     *\n*                                                                     *\n*        THE IDENTIFY MACRO SUPPLIED IN SYS1.MACLIB SUPPORTS THE      *\n*        \"LOADER\" FORM, BUT THE FORMAT OF THE PARAMETER LIST IS       *\n*        NOT DOCUMENTED, AS FAR AS I KNOW.  THE RETURN CODES X'18'    *\n*        OR X'1C' MAY BE RETURNED IN R15 WHEN THE PARAMETER LIST      *\n*        IS INVALID.  THESE RETURN CODES ARE DOCUMENTED ALONG WITH    *\n*        THE IDENTIFY MACRO.                                          *\n*                                                                     *\n*        WHEN THE LOAD-LIST IS EMPTY (I.E. NO LOAD HAS BEEN ISSUED    *\n*        FOR THIS TCB YET), IDENTIFY FAILS WITH A RETURN CODE 12.     *\n*        THIS CAN BE CIRCUMVENTED BY ISSUING THE FOLLOWING SEQUENCE:  *\n*                                                                     *\n*                       LOAD    EP=IEFBR14                            *\n*                       GETMAIN RU,LV=20000                           *\n*                       BUILDCDE LENGTH=(0),ADDR=(1),EP=DYNAM         *\n*                       DELETE  EP=IEFBR14                            *\n*                                                                     *\n*        I'VE NOTICED THAT ON MVS SYSTEMS PRIOR TO MVS/ESA 4.3, THE   *\n*        \"LOADER\" FORM OF IDENTIFY RETURNS THE ADDRESS OF THE CDE IT  *\n*        CREATED IN REG1.  IN MVS/ESA 4.3 THIS IS NO LONGER TRUE.     *\n*                                                                     *\n***********************************************************************\n         MACRO\n&REF     BUILDCDE &LENGTH=,&ADDR=,&EP=\n         LCLC   &EP8                   XF\n&EP8     SETC  '&EP          '(1,8)\n&REF     IHBINNRA &ADDR,&LENGTH        SET R0,R1\n         ST    R1,0(,R1)               STORE ENTRY-POINT ADDRESS\n         MVC   4(8,R1),=C'&EP8'        CDNAME\n         XC    12(4,R1),12(R1)         CLEAR BYTES 12-15\n         LA    R14,16                  LENGTH OF PSEUDO XL\n         LA    R15,1                   NUMBER OF RELOCATION FACTORS\n         STM   R14,R1,16(R1)           FORMAT BYTES 16-31\n         MVI   24(R1),X'80'            END OF LIST\n         MNOTE *,'       IDENTIFY MF=(E,(R1))'\n         SLR   R0,R0                   LOADER-TYPE IDENTIFY\n         SVC   41                      ISSUE IDENTIFY SVC\n         LR    R14,R1                  PASS CDE ADDRESS\n         MNOTE *,'       LOAD EP=&EP,DCB=0'\n         LA    R0,=C'&EP8'             POINT TO EP NAME\n         SLR   R1,R1                   NO DCB FOR LOAD\n         SVC   8                       ISSUE LOAD SVC\n         LR    R1,R0                   EP ADDRESS IN R1\n         SLR   R0,R0\n         ICM   R0,B'0111',25(R1)       LENGTH IN R0\n         MEND\n***********************************************************************\n********* TEST PROGRAM ************************************************\n***********************************************************************\nTEMPNAME CSECT\nTEMPNAME AMODE 31\n         BALR  R3,0\n         USING *,R3\n         OPEN  (SNAPDD,OUTPUT)\n*\n         GETMAIN R,LV=3333\n         BUILDCDE LENGTH=(0),ADDR=(1),EP=DYNAM/24\n         LR    R4,R14\n         LR    R5,R15\n         LR    R6,R0\n         LR    R7,R1\n*\n         GETMAIN RU,LV=5678,LOC=ANY\n         BUILDCDE LENGTH=(0),ADDR=(1),EP=DYNAM/31\n         LR    R8,R14\n         LR    R9,R15\n         LR    R10,R0\n         LR    R11,R1\n*\n         SNAP  DCB=SNAPDD,SDATA=CB,PDATA=(REGS,JPA)\n*\n         MVC   0(8,R7),=X'0A23,0A03'   SVC 35 (WTO) AND SVC 3 (EXIT)\n         LA    R1,WTOL                 POINT TO WTO PARM LIST\n         LINK  EP=DYNAM/24             GO EXECUTE SVC35\n*\n         SNAP  DCB=SNAPDD,SDATA=CB     SHOW UPDATED CDE\n*\n         SVC   3                       EXIT\n*\nWTOL     WTO   'BUILDCDE - LINK WORKED!',ROUTCDE=11,MF=L\n*\nSNAPDD   DCB   DSORG=PS,MACRF=W,DDNAME=SNAPDD,                         X\n               RECFM=VBA,LRECL=125,BLKSIZE=882\n         YREGS\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSPRINT DD SYSOUT=*\n//*\n//GO      EXEC PGM=LOADER,PARM=NOPRINT\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//SNAPDD   DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n***********************************************************************\n********* AUTHORIZED VERSION OF THE BUILDCDE MACRO ********************\n***********************************************************************\n         MACRO (AUTHORIZED VERSION)\n&REF     BUILDCDE &RU,&LENGTH=,&SP=0,&WORKREG=,                        X\n               &BNDRY=DBLWD,&EP=BUILDCDE,&LOC=\n      MNOTE *,'       GETMAIN &RU,LV=&LENGTH,SP=&SP,BNDRY=&BNDRY,&LOC='\n&REF     GETMAIN &RU,LV=&LENGTH,SP=&SP,BNDRY=&BNDRY,&LOC=\n         ST    R1,0(,R1)               ENTRY POINT\n         MVC   4(8,R1),=CL8'&EP'       CDNAME\n         XC    12(4,R1),12(R1)         CLEAR BYTES 12-15\n         LA    R14,016                 LENGTH OF PSEUDO XL\n         LA    R15,001                 NUMBER OF RELOCATION FACTORS\n         STM   R14,R1,16(R1)           FORMAT SVC41 PARM\n         MVI   24(R1),X'80'            END OF LIST\n         LR    R14,R1                  SAVE ADDRESS ACROSS SVC 41\n         MNOTE *,'       IDENTIFY EPLOC=0,ENTRY=(R1)'\n         SLR   R0,R0                   LOADER-TYPE IDENTIFY\n         SVC   41                      ISSUE IDENTIFY SVC\n&LABEL   SETC  'IHB&SYSNDX'\n&R       SETC  '&WORKREG(1)'           SHORT FORM\n         AIF   (T'&WORKREG NE 'O').WKREG2\n         MNOTE 4,'WORKREG OPERAND OMITTED, WORKREG=(R2) ASSUMED'\n&R       SETC  'R2'\n.WKREG2  L     &R,540(,0)              PSATOLD (MY TCB)\n         L     &R,TCBJSCB-TCB(,&R)     MY JSCB\n         USING IEZJSCB,&R\n         TM    JSCBOPTS,JSCBAUTH       CHECK AUTHORIZATION\n         BZ    &LABEL.N                JUMP IF NOT AUTHORIZED\n         MODESET KEY=ZERO              SWITCH TO KEY ZERO\n         NI    JSCBOPTS,255-JSCBAUTH   TURN APF FLAG OFF\n         SYNCH &LABEL.L                EXECUTE ROUTINE WITH TCB KEY\n         OI    JSCBOPTS,JSCBAUTH       TURN APF FLAG BACK ON\n         DROP  &R\n         LR    &R,R0                   SAVE EP ADDRESS\n         MODESET KEY=NZERO             SWITCH TO TCB KEY\n         LR    R0,&R                   EP ADDRESS\n         B     &LABEL.X\n&LABEL.I EQU   &R-2                    WORKREG MUST BE R2-R13\n&LABEL.J EQU   13-&R                   WORKREG MUST BE R2-R13\n&LABEL.N LA    R14,&LABEL.X            RETURN ADDRESS\n         MNOTE *,'       LOAD EP=&EP,DCB=0'\n&LABEL.L LA    R0,=CL8'&EP'            POINT TO EP NAME\n         SLR   R1,R1                   NO DCB FOR LOAD\n         SVC   8                       ISSUE LOAD SVC\n         BR    R14\n&LABEL.X LR    R1,R0                   ADDRESS IN R1\n         SLR   R0,R0\n         ICM   R0,B'0111',25(R1)       LENGTH IN R0\n         MEND\n         IEZJSCB\n         IKJTCB\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BYPASSNQ": {"ttr": 3335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00W\\x00\\x87$\\x7f\\x00\\x970\\x9f\\t'\\x01_\\x00\\x19\\x00G\\xc3\\xc2\\xe3\\xf4\\xf7\\xf6@@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-09-04T00:00:00", "modifydate": "1997-11-05T09:27:57", "lines": 351, "newlines": 25, "modlines": 71, "user": "CBT476"}, "text": "//GILBERTQ JOB (ACCT#),BYPASSNQ,\n// NOTIFY=&SYSUID,\n//*RESTART=CREATE,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF,BATCH)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = BYPASSNQ                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = SCRATCH/RENAME A DATA SET WITHOUT ENQ            *\n*                                                                     *\n* STATUS = R102                                                       *\n*                                                                     *\n* FUNCTION = This program was designed for systems programmers        *\n*            who install a new version of MVS or another software     *\n*            product.  They sometimes face a situation where they     *\n*            have to delete or rename a data set not currently        *\n*            allocated to anyone but which they can't delete          *\n*            because it has the same name as another data set         *\n*            which (1) exists on a different disk volume and          *\n*            (2) is currently allocated to a long-running task.       *\n*                                                                     *\n*            BYPASSNQ is a driver that allows you to run any          *\n*            utility program (such as IEHPROGM or IDCAMS) and         *\n*            bypass dsname ENQ that is normally performed by          *\n*            the DYNALLOC, SCRATCH and RENAME SVCs.                   *\n*            This technique allows data sets to be deleted or         *\n*            renamed using standard MVS services and is fully         *\n*            compatible with indexed VTOCs and SMS.                   *\n*                                                                     *\n*            The invoker of BYPASSNQ must have Update authority       *\n*            to SYS1.PARMLIB                                          *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*          http://gsf-soft.com/Freeware/                              *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*    DEPENDENCIES: MVS/ESA OR OS/390                                  *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (CSECT TYPE)                               *\n*                                                                     *\n*    PROCESSOR = Assembler H Version 2 or                             *\n*                High Level Assembler/MVS                             *\n*                                                                     *\n*    MODULE SIZE = 2K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE ANY, AMODE 31                    *\n*                 SUPERVISOR STATE, KEY 8                             *\n*                 APF AUTHORIZATION: YES                              *\n*                 Invoker must have Update authority to SYS1.PARMLIB  *\n*                                                                     *\n* SYNTAX = SEE BELOW                                                  *\n*                                                                     *\n*          The name of the utility program is passed in the PARM      *\n*                                                                     *\n*          Examples:                                                  *\n*                                                                     *\n*               //SCRATCH EXEC PGM=BYPASSNQ,PARM=IEHPROGM             *\n*               //DD1      DD UNIT=3390,VOL=SER=OS39R3,DISP=OLD       *\n*               //SYSPRINT DD SYSOUT=*                                *\n*                 RENAME DSNAME=GILBERT.TEST29,VOL=3390=OS39R3,      X*\n*                              NEWNAME=GILBERT.TEST29B                *\n*                SCRATCH DSNAME=GILBERT.TEST29B,VOL=3390=OS39R3       *\n*                                                                     *\n*               //ALTER   EXEC PGM=BYPASSNQ,PARM=IDCAMS               *\n*               //SYSPRINT DD SYSOUT=*                                *\n*                 ALTER IBMUSER.TEST29 NEWNAME(IBMUSER.TEST29B)       *\n*                 DELETE IBMUSER.TEST29B                              *\n*                                                                     *\n* OPERATION = SEE BELOW                                               *\n*                                                                     *\n*            1. Retrieve the name of the utility program              *\n*               from the PARM field.                                  *\n*            2. Fix myself in memory                                  *\n*            3. Set up an SVC screening environment to intercept      *\n*               ENQ and DEQ SVC requests                              *\n*            4. Issue XCTL to pass control to the utility program     *\n*\n*         Note: Each time it is invoked, the SVC screening routine    *\n*               checks the first QNAME in the ENQ/DEQ parm list.      *\n*               If it is equal to SYSDSN, it changes it to SYSNOENQ.  *\n*                                                                     *\n*         Credits: The idea of using SVC screening to bypass          *\n*                  DSN ENQ was borrowed from the SYSIEH               *\n*                  utility (author unknown).                          *\n*                                                                     *\n* ABENDS = See below                                                  *\n*                                                                     *\n*            U1001  Invalid Parm                                      *\n*                                                                     *\n*            U1002  User is not authorized                            *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n* 100 Initial release                                                 *\n* 101 Use ASMH and ISGPEL macro                                       *\n* 102 Issue PGFIX before setting TCBSVCS                              *\n*                                                                     *\n***********************************************************************\nBYPASSNQ RSECT\nBYPASSNQ RMODE ANY\n         DC    C'GSF UTILITIES - BYPASSNQ R102 '\nBEGIN    LR    R10,R15\n         USING BEGIN,R10\n         LR    R11,R1                  SAVE PARM ADDRESS\n         USING FSA,R13\n         MODESET MODE=SUP              SUPERVISOR MODE\n*\n*        Check that the user has update authority to SYS1.PARMLIB\n*\n         L     R15,=V(RACHECK)         addr of RACHECK routine\n         SYNCH (15),STATE=SUPV,RESTORE=YES Issue RACHECK\n         LTR   R15,R15                 USER AUTHORIZED?\n         BNZ   ABEND2                  no, abend\n*\n*        Retrieve the name of the utility program from the parm\n*\n         L     R2,0(,R11)              addr of the PARM\n         LH    R3,0(,R2)               parm length\n         LTR   R3,R3                   parm missing?\n         BNP   ABEND1                  yes, abend\n         CH    R3,=H'8'                parm too long?\n         BH    ABEND1                  yes, abend\n         LA    R14,PGMNAME             \"to\" addr\n         LA    R15,L'PGMNAME           \"to\" length\n         LA    R2,2(,R2)               \"from\" address\n         ICM   R3,B'1000',=C' '        padding\n         MVCL  R14,R2                  move pgm name\n*\n*        Make sure I don't disappear\n*\n         PGSER R,FIX,                  PREVENT S07C ABEND              X\n               A=SVCA2,                FROM                            X\n               EA=SVCARRAY+255,        TO                              X\n               LONG=Y,                                                 X\n               ECB=0\n         LOAD  EP=BYPASSNQ             bump my own use count for XCTL\n*\n*        Set up the SVC screening environment\n*\n         MODESET EXTKEY=ZERO\n         L     R4,X'21C'               A(TCB) from PSATOLD\n         USING TCB,R4\n         LA    R0,SVCA2                ADDR OF SVC SCREENING ROUTINE\n         ST    R0,TCBSVCA2\n         OI    TCBFLGS7,TCBSVCS        SVC SCREENING ON\n         MODESET KEY=NZERO,MODE=PROB\n*\n*        XCTL to utility program with PARM=''\n*\n         LR    R1,R11                  restore R1\n         L     R2,0(,R1)               addr of the PARM\n         MVI   1(R2),0                 zero parm length\n         XCTL  EPLOC=PGMNAME,SF=(E,XCTLL)\n*\nABEND1   ABEND 1001,REASON=(R3)        bad parm\n*\nABEND2   ABEND 1002,REASON=(R15)       RACHECK failed\n***********************************************************************\n*                                                                     *\n*        SVC SCREENING ARRAY                                          *\n*                                                                     *\n***********************************************************************\n         DC    0D'0'\n         EXTRN SCREEN\nSVCA2    DC    A(SCREEN+X'80000000')\n         DC    X'80,00',X'0000'        SVC TYPE, LOCKS\nSVCARRAY DC    256X'80'                SVC ARRAY\n         ORG   SVCARRAY+48\n         DC    X'00'                   DEQ\n         ORG   SVCARRAY+56\n         DC    X'00'                   ENQ\n         ORG\n***********************************************************************\n*        Work area (First Save Area)                                  *\n***********************************************************************\nFSA      DSECT\n         DS    3F                      first 3 words of FSA\nPGMNAME  DS    CL8                     name of utility program\nXCTLL    XCTL  EPLOC=PGMNAME,SF=L\n*\n         IKJTCB DSECT=YES\n         YREGS\n         END   BEGIN\n***********************************************************************\n*                                                                     *\n*        SVC SCREENING ROUTINE                                        *\n*                                                                     *\n*        This routine is invoked as a T3-SVC each time                *\n*        the ENQ or DEQ SVCs are issued.                              *\n*                                                                     *\n***********************************************************************\nSCREEN   RSECT\nSCREEN   RMODE ANY\n         USING CVTMAP,R3               CVT\n         USING TCB,R4                  TCB\n         USING RBBASIC,R5              SVRB\n         USING SCREEN,R6               Local Base\n**       USING ASCB,R7                 ASCB\n         LR    R9,R1                   point to ENQ/DEQ parm list\n         USING PELBASIC,R9\n*---------------------------------------------------------------------*\n*                                                                     *\n*        If the first QNAME in the ENQ/DEQ parm list is \"SYSDSN\",     *\n*        change it to \"SYSNOENQ\".                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MODESET EXTKEY=RBT234,WORKREG=2 SWITCH TO CALLER'S KEY\n         L     R2,PELMAJA              ADDR OF THE QNAME\n         CLC   OLDQNAME,0(R2)          QNAME=SYSDSN?\n         BNE   SCREEN45                NO, IGNORE\n         LA    R2,NEWQNAME             NEW QNAME\n         ST    R2,PELMAJA              UPDATE ADDR OF THE QNAME\nSCREEN45 EQU   *\n*---------------------------------------------------------------------*\n*                                                                     *\n*        XCTL TO SVC ROUTINE                                          *\n*                                                                     *\n*              1. LOCATE SVC ENTRY IN SVC TABLE                       *\n*              2. RESTORE R15,R0,R1                                   *\n*              3. BRANCH TO SVC ROUTINE                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         L     R8,CVTABEND             SECONDARY CVT\n         USING SCVTSECT,R8\n         LA    R2,RBBASIC-RBINTCOD     offset to interrupt code\n         LNR   R2,R2                   make it negative\n         AL    R2,RBLINK               point at RBINTCOD in the PRB\n         LH    R9,0(,R2)               Interrupt code (SVC num: 48,56)\n         SLL   R9,3                    MULT BY 8\n         AL    R9,SCVTSVCT             ADD ORIGIN OF SVC TABLE\n         USING SVCENTRY,R9\n*\n         L     R6,SVCEP                GET EP ADDR OF SVC RTNE\n         DROP  R6                      MAIN BASE REG\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Exit to the ENQ/DEQ SVC Routine                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MODESET EXTKEY=ZERO           switch back to key=zero\n         L     R14,CVTEXP1             ADDR OF EXIT PROLOGUE\n         L     R15,RBGRS15             Restore R15 from SVRB\n         LM    R0,R1,RBGRS0            Restore R0,R1 from SVRB\n         BSM   0,R6                    GO TO THE SVC ROUTINE\n*\nOLDQNAME DC    CL8'SYSDSN'             OLD QNAME\nNEWQNAME DC    CL8'SYSNOENQ'           NEW QNAME\n         PRINT NOGEN\nPRINT    OPSYN ANOP\n         CVT   DSECT=YES\n         IHASCVT DSECT=YES,LIST=NO     SECONDARY CVT\n         IHASVC                        SVC TABLE ENTRY\n         IKJTCB DSECT=YES\n         IKJRB DSECT=YES\n         ISGPEL                        Parameter Element List\n         YREGS\n         END\n***********************************************************************\n*                                                                     *\n*        RACHECK Sub-routine                                          *\n*                                                                     *\n*        Check that the user has UPDATE authority to SYS1.PARMLIB.    *\n*                                                                     *\n*        R15 on exit contains the return code:                        *\n*                                                                     *\n*              R15=0   the user is authorized                         *\n*              R15>0   the user is not authorized                     *\n*                                                                     *\n*        Must be invoked via  SYNCH (15),STATE=SUPV,RESTORE=YES       *\n*                                                                     *\n***********************************************************************\nRACHECK  RSECT\nRACHECK  RMODE ANY\n         LR    R12,R15                 local base\n         USING RACHECK,R12\n         STORAGE OBTAIN,LENGTH=RACDYNL,SP=230,KEY=1\n         LR    R13,R1                  A(DYN)\n         USING RACDYNAM,R13\n         MODESET EXTKEY=SCHED          switch to KEY=1\n*\n         L     R14,RACCAML             CAMLST 1ST WORD\n         LA    R15,RACDSN              DATA SET NAME\n         SLR   R0,R0\n         LA    R1,RACWK512             WORK AREA\n         STM   R14,R1,RACWK512+400     STORE RELOCATED CAMLST\n         LOCATE RACWK512+400           GET VOLSER AND DEVICE TYPE\n         LTR   R15,R15                 CHECK FOR SUCCESSFUL COMPLETION\n         BNZ   RACEXIT                 LOCATE FAILED, EXIT\n         MVC   RACVOL,RACWK512+6       VOLSER\n*\n         MVC   RACPLIST,RACMODL        move model to dynamic\n         RACROUTE REQUEST=AUTH,                                        X\n               WORKA=RACWK512,         512-byte work area              X\n               VOLSER=RACVOL,          VOLSER                          X\n               MF=(E,RACPLIST)\n*\nRACEXIT  LR    R2,R15                  save return code\n         STORAGE RELEASE,LENGTH=RACDYNL,ADDR=(R13),SP=230,KEY=1\n         LR    R15,R2                  restore return code\n         SVC   3                       goback to caller\n*\nRACCAML  CAMLST NAME,*-*,,*-*          CAMLST FOR LOCATE\nRACMODL  RACROUTE REQUEST=AUTH,        CHECK AUTHORIZATION             X\n               LOG=NONE,               DO NOT LOG FAILURES             X\n               CLASS='DATASET',        CHECK FOR DATASET AUTHORITY     X\n               ENTITY=RACDSN,          DATA SET NAME                   X\n               VOLSER=*-*,             volser                          X\n               ATTR=UPDATE,            MUST BE ALLOWED TO UPDATE       X\n               MF=L\nRACMODLL EQU   *-RACMODL\nRACDSN   DC    CL44'SYS1.PARMLIB'\n*\nRACDYNAM DSECT\n         DS    18F\nRACPLIST DS    XL(RACMODLL)            RACROUTE parm list\nRACVOL   DS    CL6\nRACWK512 DS    64D                     512 bytes\nRACDYNL  EQU   *-RACDYNAM\n*\n         PRINT NOGEN\nPRINT    OPSYN ANOP\n         YREGS\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//LKED    EXEC PGM=HEWLKED,PARM='MAP,RENT,AC=1'\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=SYS1.P390.LINKLIB(BYPASSNQ),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//*\n//CREATE EXEC PGM=IEHMOVE\n//SYSUT1 DD DISP=OLD,UNIT=SYSALLDA,VOL=SER=OS39R3\n//DD1    DD DSN=GILBERT.X80,DISP=SHR\n//DD2    DD DISP=OLD,UNIT=SYSALLDA,VOL=SER=OS39R3\n//SYSPRINT DD SYSOUT=*\n     COPY      DSNAME=GILBERT.X80,                                     X\n               TO=3390=OS39R3,                                         X\n               RENAME=GILBERT.TEST29\n//*\n//GO      EXEC PGM=BYPASSNQ,PARM=IEHPROGM\n//STEPLIB  DD DSN=SYS1.P390.LINKLIB,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n  RENAME DSNAME=IBMUSER.TEST29,VOL=3390=OS39R3,NEWNAME=GILBERT.TEST29B\n SCRATCH DSNAME=IBMUSER.TEST29B,VOL=3390=OS39R3\n//DD1      DD UNIT=3390,VOL=SER=OS39R3,DISP=OLD\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CANMSGCL": {"ttr": 3585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x88$/\\x00\\x89\\x00\\x7f\\x14\\x17\\x00t\\x00P\\x00\\x1e\\xc3\\xc2\\xe3\\xf3\\xf3\\xf8@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-08-29T00:00:00", "modifydate": "1989-01-07T14:17:00", "lines": 116, "newlines": 80, "modlines": 30, "user": "CBT338"}, "text": "//GILBERTC JOB (ACCT#),CANMSGCL,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//ASMH EXEC PGM=IEV90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n*              CANCEL JOB'S MSGCLASS AFTER NN HOURS                   *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        THIS PROGRAM ALLOWS YOU TO PURGE THE OUTPUT ASSOCIATED       *\n*        WITH THE MSGCLASS OF THE JOB AFTER A CERTAIN NUMBER OF       *\n*        HOURS THAT YOU SPECIFY IN THE PARM FIELD OF THE EXEC         *\n*        STATEMENT.                                                   *\n*                                                                     *\n*        EXAMPLE:                                                     *\n*                                                                     *\n*            //MYJOB    JOB ACCT#,CLASS=A,MSGCLASS=H                  *\n*            //COPY1   EXEC PGM=IEBCOPY                               *\n*            //...      DD   ...                                      *\n*            //CONDPURG EXEC PGM=CANMSGCL,PARM=2,COND=(0,NE,COPY1)    *\n*                                                                     *\n*        IF THE 'COPY1' STEP ENDS AT 10:28 AM WITH A RETURN CODE      *\n*        EQUAL TO ZERO, THE 'CONDPURG' STEP EXECUTES AND ISSUES       *\n*        THE FOLLOWING COMMAND:                                       *\n*                                                                     *\n*               $TA,T=12.28,'$OJ01234,Q=X,CANCEL'                     *\n*                                                                     *\n*        NOTES:                                                       *\n*                                                                     *\n*           1. THE PROGRAM MUST BE APF-AUTHORIZED.                    *\n*                                                                     *\n*           2. THE MSGCLASS MUST BE HELD.                             *\n*                                                                     *\n*           3. THE NUMBER OF OUTSTANDING AUTOMATIC COMMANDS IS        *\n*              LIMITED BY THE 'AUTOCMD' PARAMETER IN JES2PARM.        *\n*              IF EXCEEDED, THE COMMAND IS IGNORED.                   *\n*                                                                     *\n*           4. THE PROGRAM WORKS WITH 5-DIGIT JOB NUMBERS.            *\n*                                                                     *\n***********************************************************************\nCANMSGCL CSECT\n         SAVE  (14,12),,'GSF UTILITIES - CANMSGCL R103'\n         LR    R12,R15\n         USING CANMSGCL,R12\n         L     R2,0(,R1)               PARM ADDRESS\n         LH    R14,0(,R2)              PARM LENGTH\n         BCTR  R14,0\n         PACK  DELAY,2(*-*,R2)         PACK NUMBER OF HOURS\n         EX    R14,*-6                 EXECUTE PACK INSTRUCTION\n*\n*        GET JOB NUMBER FROM SSIB\n*\n         L     R4,540(,0)              PSATOLD\n         L     R5,TCBJSCB-TCB(,R4)     PTR TO JSCB\n         USING IEZJSCB,R5\n         L     R6,JSCBSSIB             PTR TO SSIB\n         USING SSIB,R6\n         MVC   JOBID+0(1),SSIBJBID+0   J\n         MVC   JOBID+1(5),SSIBJBID+3    01234\n         L     R8,JSCBJCT              PTR TO JCT\n         USING JCT,R8\n         MVC   MSGCLASS,JCTJMGPO       MSGCLASS\n         DROP  R5,R6,R8                JSCB, SSIB, JCT\n*\n*        GET CURRENT TIME, MOVE IT TO \"HHMM\" FIELD\n*\n         TIME  DEC                     HHMMSS00\n         SRL   R0,12(0)                000HHMM0\n         ST    R0,SYSTIME              000HHMM0\n         OI    SYSTIME+3,15            000HHMMF\n         UNPK  HHMM+3(2),SYSTIME+2(2)  MOVE MM\n         OI    SYSTIME+2,15            000HHF??\n         AP    SYSTIME+1(2),DELAY      ADD HOURS FROM PARM\n         OI    SYSTIME+2,15            000HHF??\n         UNPK  HHMM+0(2),SYSTIME+1(2)  MOVE HH\n         MVI   HHMM+2,C'.'             HH.MM\n         MODESET KEY=ZERO,MODE=SUP\n         SLR   R0,R0                   DUMMY CONSOLE ID\n         MGCR  MGCR1L                  ISSUE COMMAND\n         RETURN  (14,12),RC=00         GO BACK TO SYSTEM\n*\nMGCR1L   WTO   '$TA,T=HH.MM,''$OJ01234,Q=$,CANCEL''',MF=L\nHHMM     EQU   MGCR1L+10               HH.MM\nJOBID    EQU   MGCR1L+19,6             JOB ID\nMSGCLASS EQU   MGCR1L+28,1             MESSAGE CLASS\nDELAY    DS    P'24'                   NUMBER OF HOURS, FROM PARM\nSYSTIME  DS    F                       CURRENT SYSTEM TIME\n*\n         YREGS\n*\n         IKJTCB LIST=NO                TCB DSECT\n*\n         IEZJSCB                       JSCB DSECT\n*\nJCT      DSECT\n         DS    4F                      JCT PREFIX\n         IEFAJCTB                      JCT DSECT\n*\n         IEFJSSIB                      SSIB DSECT\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//LKED    EXEC PGM=HEWL,PARM='MAP,REUS,AC=1'\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,DELETE)\n//SYSPRINT DD SYSOUT=*\n//SYSLMOD  DD DSN=SYS2.AUTHLIB(CANMSGCL),DISP=SHR\n//*\n//GO      EXEC PGM=CANMSGCL,PARM=2\n//STEPLIB  DD DSN=SYS2.AUTHLIB,DISP=SHR\n//SYSUDUMP DD SYSOUT=*\n//ABNLNODP DD DUMMY\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLEANUP": {"ttr": 3588, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x04\\x07\\x00'\\x00\\x81\\x03\\x7f\\x01\\t\\x05\\x0f\\x104\\x02\\x0c\\x00\\xdf\\x00\\xd6\\xc3\\xc2\\xe3\\xf4\\xf7\\xf8@@@@\"", "ispf": {"version": "04.07", "flags": 0, "createdate": "1981-02-06T00:00:00", "modifydate": "2009-02-19T10:34:27", "lines": 524, "newlines": 223, "modlines": 214, "user": "CBT478"}, "text": "//GILBERTC JOB (ACCT#),CLEANUP,\n//*RESTART=HMIG,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(1,LT)\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = CLEANUP                                               *\n*                                                                     *\n* DESCRIPTIVE NAME = Data Set Clean-up Utility                        *\n*                                                                     *\n* FUNCTION = The \"CLEANUP\" program deletes existing data sets         *\n*            created and/or used in your job.  It has three modes     *\n*            of operation:  Job restart, Job Clean-up, Never-open.    *\n*                                                                     *\n* STATUS = R407                                                       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*          http://gsf-soft.com/Freeware/                              *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = MVS/XA, MVS/ESA, DFHSM                            *\n*                                                                     *\n*    AUTHORIZATION = NONE                                             *\n*                                                                     *\n*    RESTRICTIONS = NONE                                              *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (BATCH PROGRAM)                            *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 4K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REUSABLE, RMODE 24, AMODE 31,                       *\n*                 PROBLEM STATE, KEY 8                                *\n*                                                                     *\n* OPERATION = See Below                                               *\n*                                                                     *\n*        1. Job restart                                               *\n*                                                                     *\n*            When executed at the beginning of the job you're         *\n*            re-starting or re-running, CLEANUP deletes non-gdg       *\n*            data sets that were created by a previous run of the     *\n*            same job.  This prevents Job failures that would         *\n*            result from \"NOT CATLG 2\" and IGD17001I messages.        *\n*                                                                     *\n*            Sample JCL :                                             *\n*                                                                     *\n*              //MYJOB   JOB (ACCT#),'JOHN DOE', . . .                *\n*              //*                                                    *\n*              //CLEANUP EXEC PGM=CLEANUP                             *\n*              //*                                                    *\n*              //STEP1   EXEC PROC=MYPROC, . . .                      *\n*                                                                     *\n*            Notes:                                                   *\n*                                                                     *\n*              o  no DD statements, control cards or PARM are         *\n*                 necessary.  CLEANUP automatically retrieves data    *\n*                 set names from in-storage images of the job's JCL.  *\n*                                                                     *\n*              o  CLEANUP may be executed more than once in a job.    *\n*                 Each execution will consider data sets created      *\n*                 in subsequent steps.                                *\n*                                                                     *\n*              o  If PARM=RECALL is specified, CLEANUP invokes        *\n*                 the RECALL utility after it has completed its       *\n*                 clean-up work.                                      *\n*                                                                     *\n*        2. Job clean-up                                              *\n*                                                                     *\n*            When executed as the very last step of a job,            *\n*            CLEANUP deletes non-gdg data sets that were created      *\n*            during the job's execution.                              *\n*                                                                     *\n*            Sample JCL :                                             *\n*                                                                     *\n*              //MYJOB   JOB (ACCT#),'JOHN DOE', . . .                *\n*              //*                                                    *\n*              //STEP1   EXEC PROC=MYPROC, . . .                      *\n*              //*                                                    *\n*              //CLEANUP EXEC PGM=CLEANUP                             *\n*              //                                                     *\n*                                                                     *\n*        3. Never-OPEN                                                *\n*                                                                     *\n*            When executed with PARM=NEVEROPEN, CLEANUP deletes       *\n*            data sets that have been allocated but have not been     *\n*            opened for output by any program.  DD statements must    *\n*            be explicitely specified in CLEANUP's step for the       *\n*            data sets to delete.                                     *\n*                                                                     *\n*            Sample JCL :                                             *\n*                                                                     *\n*              //MYJOB   JOB (ACCT#),'JOHN DOE', . . .                *\n*              //*                                                    *\n*              //STEP1   EXEC PGM=MYPROG1, . . .                      *\n*              //OUTDD    DD  DSN=SELDOM.OPEN1(+1),DISP=(,CATLG)      *\n*              //*                                                    *\n*              //STEP2   EXEC PGM=MYPROG2, . . .                      *\n*              //OUTDD    DD  DSN=SELDOM.OPEN2,DISP=(,CATLG)          *\n*              //*                                                    *\n*              //CLEANUP EXEC PGM=CLEANUP,PARM=NEVEROPEN              *\n*              //DD1      DD  DSN=SELDOM.OPEN1(+1),DISP=OLD           *\n*              //DD2      DD  DSN=SELDOM.OPEN2,DISP=OLD               *\n*                                                                     *\n* Method of Operation (functions 1 & 2)                               *\n*                                                                     *\n*         o  CLEANUP scans the SWA control blocks of every step       *\n*            of your job for non-GDG data sets that will be           *\n*            (function 1) or have been (function 2) created           *\n*            with DISP=(NEW,CATLG) or DISP=(MOD,CATLG).               *\n*                                                                     *\n*         o  Any of these data sets currently catalogued are          *\n*            dynamically allocated and deleted.                       *\n*                                                                     *\n*         o  Data sets migrated by HSM are deleted                    *\n*            with an HDELETE command.                                 *\n*                                                                     *\n* PARAMETERS = PARM=NEVEROPEN indicates that CLEANUP should only      *\n*              delete those data sets that are allocated in its own   *\n*              step and have a null BLKSIZE (i.e. have never been     *\n*              OPEN'd for output).                                    *\n*                                                                     *\n*              PARM=RECALL indicates that CLEANUP should invoke       *\n*              the RECALL utility at the end of its own processing.   *\n*                                                                     *\n* Return codes = See below                                            *\n*                                                                     *\n*            00     Normal end                                        *\n*            16     Parm is invalid                                   *\n*                                                                     *\n* Messages = See below                                                *\n*                                                                     *\n*            PARM FIELD IS INVALID, when the PARM specifies           *\n*              something other than NEVEROPEN.                        *\n*                                                                     *\n*            CLEANUP - data-set-name DELETED (volser)                 *\n*              for each data set deleted                              *\n*                                                                     *\n*            CLEANUP - data-set-name DELETED (MIGRAT)                 *\n*              for each migrated data set deleted with HDELETE        *\n*                                                                     *\n* Change Activity                                                     *\n*                                                                     *\n*402 XCTL to PGM=RECALL at EOJ if PARM=RECALL                         *\n*403 IGNORE DISP=(MOD,DELETE) DATA SETS WITH PARM=NEVEROPEN           *\n*404 Increase message length to 80 characters.                        *\n*405 Pass PARM='' to RECALL program                              1996 *\n*406 Check that GDG base is DEFINE'd                             2008 *\n*407 Change 5X to 7X for z/OS R10                                2009 *\n***********************************************************************\nCLEANUP  CSECT\nCLEANUP  AMODE 31                      SWAUP\nCLEANUP  RMODE 24                      HDEL\n         SAVE  (14,12),,'GSF Utilities - CLEANUP R407'\n         LR    R12,R15\n         USING CLEANUP,R12\n         GETMAIN R,LV=DYNAML\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LM    R13,R1,8(R13)\n         USING DYNAM,R13\n         L     R9,0(,R1)               SAVE THE PARM ADDR\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Set up SWA scan from first step after our own.               *\n*                                                                     *\n*        If we're the last step of the job, set up scan               *\n*        from beginning of job.                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\nINIT50   L     R3,540(,0)              MY TCB (PSATOLD-PSA)\n         L     R4,TCBJSCB-TCB(,R3)     MY JSCB\n         USING IEZJSCB,R4\n         L     R5,JSCSCT               CURRENT STEP'S SCT PREFIX\n         USING SCT,R5\n         MVI   MODE,C'F'               processing mode is \"FIRST\"\n         ICM   R1,B'0111',SCTANSCT     last step of this job?\n         BNZ   INIT59                  no, jump\n         L     R1,JSCBJCT              yes, point to JCT\n         ICM   R5,B'0111',JCTSDKAD-JCT(R1) SCT of first step to be run\n         MVI   MODE,C'L'               processing mode is \"LAST\"\n*\nINIT59   SLR   R10,R10                 SET RC=00 (NOTHING DELETED)\n         MVI   DO_RECALL,C'N'          No XCTL to PGM=RECALL at EOJ\n*---------------------------------------------------------------------*\n*                                                                     *\n*        FIND RESTART STEP, IF SPECIFIED IN THE PARM                  *\n*                                                                     *\n*---------------------------------------------------------------------*\nINIT60   LTR   R9,R9                   PARM FROM JCL OR CPPL\n         BNM   LOOPSCT                 no parm or TMP-INVOKED\n         CLI   1(R9),0                 PARM=\"\"\n         BE    LOOPSCT                 yes, jump\nINIT63   CLI   1(R9),6                 PARM=RECALL   ?\n         BNE   INIT64                  no, jump\n         CLC   =C'RECALL',2(R9)        PARM=RECALL   ?\n         BNE   BADPARM                 no, parm is invalid\n         MVI   DO_RECALL,C'Y'          XCTL to PGM=RECALL at EOJ\n         B     LOOPSCT\nINIT64   CLI   1(R9),9                 PARM=NEVEROPEN?\n         BNE   BADPARM                 no, parm is invalid\n         CLC   =C'NEVEROPEN',2(R9)     PARM=NEVEROPEN?\n         BNE   BADPARM                 no, parm is invalid\n         MVI   MODE,C'O'               processing mode is \"OPEN\"\n         L     R5,JSCSCT               CURRENT STEP'S SCT PREFIX\n         B     LOOPSCT\n*\nBADPARM  WTO   'CLEANUP - Parm Field is invalid',ROUTCDE=(2,11)\n         LA    R10,16                  RC=16\n         B     GOBACK\n***********************************************************************\n*                                                                     *\n*        SCAN SCT/SIOT CHAINS                                         *\n*                                                                     *\n*           1. SELECT NON-GDG DATA SETS THAT HAVE DISP=(NEW,CATLG)    *\n*              OR DISP=(MOD,CATLG)                                    *\n*                                                                     *\n*           2. ALLOCATE SELECTED DATA SETS WITH DISP=(OLD,DELETE)     *\n*                                                                     *\n*           3. UNALLOCATE DATA SETS THAT WERE SUCCESSFULLY ALLOCATED  *\n*              TO DELETE THEM                                         *\n*                                                                     *\n***********************************************************************\n*LOOP\nLOOPSCT  ICM   R1,B'0111',SCTFSIOT     SVA OF 1ST SIOT\n         BZ    NEXTSTEP                NO DD STATEMENTS, TRY NEXT SCT\n*--LOOP\nLOOPSIOT BAL   R9,SWAREQ               CONVERT SVA TO 31-BIT ADDRESS\n         LR    R6,R1                   PASS SIOT ADDRESS\n         USING INDMSIOT,R6\n         ICM   R1,B'0111',SCTPJFCB     SVA OF JFCB\n         BAL   R9,SWAREQ               CONVERT SVA TO 31-BIT ADDRESS\n         LR    R7,R1                   LOAD JFCB ADDRESS\n         USING INFMJFCB,R7\n*\n*        Set-up message\n*\nSETUPMSG MVC   DSNAME,JFCBDSNM         MOVE DSN TO UNPROTECTED STORAGE\n         MVC   WTO1TEXT,WTO1TEXT-1     clear work area\n         MVC   WTO1TEXT(L'DSNAME),DSNAME move dsname\n         LA    R2,WTO1TEXT             start of dsname\n         LA    R2,1(,R2)             - BUMP POINTER\n         CLI   0(R2),C' '            - END OF MSG?\n         BNE   *-8                   - NOT YET, TRY NEXT CHARACTER\n         MVC   1(7,R2),=C'deleted'     action taken\n         CLI   MODE,C'O'               PARM=NEVEROPEN?\n         BE    NO_OPEN                 yes, bypass filters\n*\n*        Filter data sets: DSN=A.B.C(+1),DISP=(,CATLG)\n*\nFILTER   TM    SCTSDISP,SIOTCTLG       DISP=(,CATLG) ?\n         BNO   NEXTSIOT                NO, JUMP\n         TM    SCTSBYT3,SCTSNEW+SCTSMOD   DISP=NEW/MOD ?\n         BZ    NEXTSIOT                NO, JUMP\n         TM    JFCBIND1,JFCGDG         CHECK FOR (+1)\n         BO    GDG1                    JUMP, THIS IS A GDG\n         CLI   MODE,C'L'               MODE=LAST?\n         BE    ALLOC                   yes, bypass catalog search\n*\n*        Look-up data set name in the catalog\n*\nLOCATE   LM    R14,R1,CAMLST26         MODEL CAMLST\n         SLR   R0,R0                   no CVOL ptr\n         LA    R1,WORK265              WORK AREA\n         STM   R14,R1,CAMLST2          UPDATE CAMLST IN DYNAMIC STRGE\n         LOCATE CAMLST2                GET VOLSER\n         LTR   R15,R15                 IS IT CATALOGED?\n         BNZ   NEXTSIOT                NO, IGNORE\n         MVI   09(R2),C'('             surround volser with parentheses\n         MVC   10(6,R2),WORK265+6      yes, move volser\n         MVI   16(R2),C')'             surround volser with parentheses\n*\n*        If the data set has been migrated by HSM,\n*        issue an HDELETE command.\n*\nHDELETE  CLC   =C'MIGRAT',WORK265+6    cataloged on MIGRAT ?\n         BNE   ALLOC                   no, jump\n         ARCHDEL DSN=DSNAME,WKAREA=WORK265,WAIT=YES\n         LTR   R15,R15                 HDELETE OK?\n         BNZ   ALLOC                   no, jump\n         B     WTO1                    yes, issue WTO\n*\n*        PARM=NEVEROPEN\n*\nNO_OPEN  TM    SCTSDISP,SIOTDLET       DISP=(,DELETE)?\n         BO    NEXTSIOT                YES, JUMP\n         LM    R14,R1,CAMLST28         MODEL CAMLST\n         LA    R0,JFCBVOLS             volser\n         LA    R1,DS1FMTID             WORK AREA\n         STM   R14,R1,CAMLST2          UPDATE CAMLST IN DYNAMIC STRGE\n         OBTAIN CAMLST2                GET F1-DSCB\n         LTR   R15,R15                 found on disk?\n         BNZ   NEXTSIOT                NO, IGNORE\n         OC    DS1BLKL,DS1BLKL         BLKSIZE=0?\n         BNZ   NEXTSIOT                NO, IGNORE\n         MVC   09(12,R2),=C'(Never OPEN)'\n*\n*        ALLOCATE\n*\nALLOC    MVI   S99RB+1,1               FUNCTION=ALLOC\n         NI    S99TUPTR,255-X'80'      USE ALL OF THE KEYS\n         LA    1,=A(S99RB+VL)          SVC99 REQUEST BLOCK\n         SVC   99                      ALLOCATE THE DATA SET\n         LTR   R15,R15                 ALLOC OK?\n         BNZ   NEXTSIOT                NO, JUMP\n*\n*        UNALLOCATE\n*\n         MVI   S99RB+1,2               FUNCTION=UNALLOC\n         OI    S99TUPTR,X'80'          KEEP ONLY THE DDNAME KEY\n         LA    1,=A(S99RB+VL)          SVC99 REQUEST BLOCK\n         SVC   99                      ALLOCATE THE DATA SET\n*\nWTO1     EQU   *\n         WTO   MF=(E,WTO1L)            CLEANUP - data.set (Never OPEN)\n         B     NEXTSIOT\n*\n*        Check GDG BASE defined\n*\nGDG1     EQU   *\n         XC    CTGPL(CTGPLLEN),CTGPL   CLEAR OPTION BYTES\n         LA    R0,DSNAME               ENTRY NAME OR CI NUMBER\n         ST    R0,CTGENT               POINTER TO ENTRY NAME OR CI#\n         OI    CTGOPTN1,CTGNAME        CTGENT POINTS TO ENTRY NAME\n**       LA    R0,CATNAME              CATALOG NAME OR ACB ADDRESS\n**       ST    R0,CTGCAT               POINTER TO CATALOG NAME/ACB\n**       OI    CTGOPTN1,CTGCNAME       CTGCAT POINTS TO CATALOG NAME\n         MVI   CTGOPTN3,CTGAM0         OS/VS2 CATALOG MGMT REQUEST\n         MVI   CTGOPTNS,CTGLTCAT       LISTCAT\n         OI    CTGOPTN3,CTGCMS         CATALOG MGMT SERVICE\n         MVI   CTGNOFLD,1              NUMBER OF FIELDS\n         LA    R15,CTGFL               CTGFLD\n         MVI   0(R15),X'01'            CTGFLDNO\n         ST    R15,CTGFIELD+0          STORE CTGFL ADDRESS\n         LA    R0,=C'ENTTYPE '         ENTTYPE=B IF GDG BASE\n         ST    R0,CTGFLDNM             CTGFLDNM\n         LA    R14,WORK265             WORK AREA FOR SVC 26\n         ST    R14,CTGWKA              WORK AREA FOR SVC 26\n         MVC   0(4,R14),=Y(256,0)      AREA LENGTH\n         LA    R1,CTGPL                LOAD R1 WITH CTGPL ADDRESS\n         SVC   26                      REQUEST CATALOG MGMT SERVICES\n         LTR   R15,R15                 LISTCAT ERROR ?\n         BNZ   GDG7                    YES, QUIT\n         L     R2,CTGFLPT              POINT TO RETURNED VALUE\n         CLI   0(R2),C'B'              CHECK ENTRY TYPE\n         BE    NEXTSIOT                IT'S A GDG BASE, CONTINUE\nGDG7     EQU   *\n         LA    R2,WTO1TEXT             start of dsname\n         LA    R2,1(,R2)             - BUMP POINTER\n         CLI   0(R2),C' '            - END OF MSG?\n         BNE   *-8                   - NOT YET, TRY NEXT CHARACTER\n         MVC   09(13,R2),=C'(No GDG Base)'\n         WTO   MF=(E,WTO1L)            '--> GDG-BASE NOT DEFINED <--'\n*\nNEXTSIOT ICM   R1,B'0111',SCTPSIOT     NEXT SIOT'S PREFIX\n         BNZ   LOOPSIOT                PROCESS NEXT DD CARD IN STEP\n*--ENDLOOP\nNEXTSTEP CLI   MODE,C'O'               PARM=NEVEROPEN?\n         BE    GOBACK                  yes, we're done\n         ICM   R5,B'0111',SCTANSCT     NEXT SCT PREFIX\n         BNZ   LOOPSCT                 PROCESS NEXT STEP\n*ENDLOOP\n         DROP  R5,R6,R7                SCT, SIOT, JFCB\n*\nGOBACK   CLI   DO_RECALL,C'Y'          PARM=RECALL ?\n         BE    XCTLRCAL                yes, jump\n         L     R13,4(,R13)             CALLER'S SAVE AREA\n         LR    R15,R10                 RETURN CODE\n         RETURN (14,12),RC=(15)\n*\nXCTLRCAL L     R13,4(,R13)             CALLER'S SAVE AREA\n         L     R1,24(,R13)             R1=parm_addr\n         L     R14,0(,R1)              R14=>AL2(L'PARM)\n         MVI   1(R14),0                L'PARM=0\n         XCTL  (2,12),EP=RECALL        invoke RECALL program\n*---------------------------------------------------------------------*\n*                                                                     *\n*        SUB-ROUTINE USED TO ACCESS THE SWA MANAGER                   *\n*                                                                     *\n*---------------------------------------------------------------------*\nSWAREQ   LA    R2,DSNAME               WORK AREA\n         ST    R2,EPAPTR               STORE POINTER\n         USING ZB505,R2\n         XC    SWAEPAX,SWAEPAX         CLEAR 32 BYTES\n         STCM  R1,B'0111',SWVA         STORE 3-BYTE SVA\n         SWAREQ FCODE=RL,EPA=EPAPTR,MF=(E,SWAREQL1),UNAUTH=YES\n         L     R1,SWBLKPTR             LOAD SWA CONTROL BLOCK ADDRESS\n         BR    R9\n         DROP  R2                      ZB505\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DATA, WORK AREAS                                             *\n*                                                                     *\n*---------------------------------------------------------------------*\nVL       EQU   X'80000000'\nS99RB    DC    A(X'14010000',0,S99TUPTR,0,0)\nS99TUPTR DC    A(S99TU01,S99TU02,S99TU04,S99TU05,S99TU6C+VL)\nS99TU01  DC    AL2(X'01',1,L'DDNAME)   DDNAME KEY\nDDNAME   DC    C'$CLEANUP'\nS99TU02  DC    AL2(X'02',1,L'DSNAME)   DSNAME KEY\nDSNAME   DS    CL44\nS99TU04  DC    AL2(X'04',1,1),X'01'    STATUS=OLD\nS99TU05  DC    AL2(X'05',1,1),X'04'    DISP=DELETE\nS99TU6C  DC    AL2(X'6C',0)            UNIT=(,,DEFER)\nCAMLST26 CAMLST NAME,DSNAME,,*-*       CAMLST FOR LOCATE MACRO\nCAMLST28 CAMLST SEARCH,DSNAME,*-*,*-*  CAMLST FOR OBTAIN MACRO\n*\n&STR     SETC  (80)' '\nWTO1L    WTO   'CLEANUP - &STR',ROUTCDE=11,MF=L\nWTO1TEXT EQU   WTO1L+14,80\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Dynamic storage                                              *\n*                                                                     *\n*---------------------------------------------------------------------*\nDYNAM    DSECT\n         DS    18F\nMODE     DS    C'F'                    FIRST/LAST/OPEN\nDO_RECALL DS   C'N'                    PARM=RECALL\nCAMLST2  CAMLST NAME,DSNAME,,WORK265   CAMLST FOR LOCATE MACRO\nSWAREQL1 SWAREQ MF=L                   PARM LIST FOR SWAREQ\nEPAPTR   DS    F                       POINTER TO EPA (ZB505)\nWORK265  DS    CL265                   LOCATE macro\n         IECSDSL1 1                    F1-DSCB\n         DS    5X,2X                   CCHHR + more in z/OS R10\n*@@      IEZCTGPL DSECT=NO             CATALOG PARAMETER LIST\nCTGPL    DS    0F\nCTGOPTN1 DC    AL1(CTGNAME+CTGCNAME)   FIRST OPTION BYTE:\nCTGNAME  EQU   X'04'                     CTGENT POINTS TO ENTRY NAME\nCTGCNAME EQU   X'02'                     CTGCAT POINTS TO CATALOG NAME\nCTGOPTN2 DS    B              SECOND OPTION BYTE\nCTGOPTN3 DS    B              THIRD OPTION BYTE\nCTGCMS   EQU   X'80'                     REQUEST IS IN CTGOPTNS\nCTGAM0   EQU   X'01'                     OS/VS2 CTGPL, NOT A CAMLST\n         DC    B'0'\nCTGENT   DC    A(*-*)                  ADDRESS OF ENTRY NAME\nCTGCAT   DC    A(*-*)                  ADDRESS OF CATALOG DSNAME\nCTGWKA   DC    A(*-*)                  ADDRESS OF CALLER'S WORK AREA\nCTGOPTNS DC    AL1(CTGLTCAT)           REQUEST:\nCTGLTCAT EQU   X'20' 0010 0...           LISTCAT\n         DC    B'0'\nCTGTYPE  DC    C'B'                    TYPE OF CAT. RECORD (GDG BASE)\nCTGNOFLD DC    FL1'1'                  NUMBER OF POINTERS IN CTGFIELD\nCTGFDBK  DC    XL2'0'                  FEEDBACK AREA\nCTGFBFLG DC    B'0'\n         DC    X'00'                   ERROR CODE\nCTGPSWD  DC    A(0)                    PASSWORD ADDRESS\nCTGFIELD DC    A(CTGFL)                POINTER(S) TO CTGFL(S)\n         DS    2A             UNUSED HERE\n*\nCTGFL    DS    0F                   +0 FIELD DESCRIPTOR\nCTGFLDNO DS    FL1'1',5X'00'        +0 NUMBER OF FIELDS\nCTGFLDNM DS    V(FLDNM),A(0)        +8 PTR TO FIELD NAME\nCTGFLNG  DS    F'0'                +16 LENGTH OF RETURNED DATA\nCTGFLPT  DS    A(*-*)              +20 ADDRESS OF RETURNED DATA\nCTGPLLEN EQU   *-CTGPL\n*\nDYNAML   EQU   *-DYNAM\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DSECTS FOR VARIOUS MVS CONTROL BLOCKS                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         PRINT NOGEN\nPRINT    OPSYN ANOP\n         IKJTCB LIST=NO                SYS1.MODGEN\n         IEZJSCB ,                     SYS1.MODGEN\nJCT      DSECT                         Job Control Table\n         DS    4F                      Prefix\n         IEFAJCTB ,                    SYS1.MODGEN\nSCT      DSECT                         Step Control Table\n         DS    4F                      Prefix\n         IEFASCTB ,                    SYS1.MODGEN\nSIOT     DSECT                         Step I/O Table\n         DS    4F                      Prefix\n         IEFASIOT ,                    SYS1.MODGEN\nJFCB     DSECT                         Job File Control Block\n         DS    4F                      Prefix\n         IEFJFCBN ,                    SYS1.MODGEN\n         CVT   LIST=NO,DSECT=YES       COMMUNICATION VECTOR TABLE\n         IEFJESCT TYPE=DSECT           JES CONTROL TABLE\n         IEFZB505 LOCEPAX=YES          EPA MAPPING FOR SWAREQ\n         YREGS                         SYS1.MACLIB\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR         IECSDSL1 IEFASIOT OBTAIN\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,4)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//LKED    EXEC PGM=IEWL,PARM=(MAP,REUS)\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=CBTTAPE.FILE183.LOAD(CLEANUP),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//*\n//NEVROPEN EXEC PGM=CLEANUP,PARM=NEVEROPEN\n//STEPLIB  DD DSN=CBTTAPE.FILE183.LOAD(CLEANUP),DISP=SHR\n//NODSORG  DD DSN=GILBERT.CLEANUP2,DISP=(,CATLG),\n// UNIT=VIO,SPACE=(TRK,1)\n//*SORGPS  DD DSN=GILBERT.CLEANUP,DISP=(,CATLG),\n//*UNIT=VIO,SPACE=(TRK,1),DSORG=PS\n//SYSDEBUG DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//*\n//GO      EXEC PGM=CLEANUP\n//STEPLIB  DD DSN=CBTTAPE.FILE183.LOAD(CLEANUP),DISP=SHR\n//SYSDEBUG DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//*\n//STEP1   EXEC PGM=IEFBR14\n//TAPEOUT  DD DSN=GILBERT.CLEANUP,DISP=(,CATLG),\n// UNIT=VIO,SPACE=(TRK,1)\n//BADGDG   DD DSN=GILBERT.BADGDG(+1),DISP=(,CATLG)\n//*TEP2   EXEC PGM=IEFBR14\n//*APEOUT  DD DSN=GILBERT.CLEANUP,DISP=(OLD,DELETE)\n//*\n//HMIG    EXEC PGM=IKJEFT01\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\nHMIG 'IBMUSER.CLEANUP' WAIT\n//*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLS": {"ttr": 3843, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x03\\x00\\x00\\x00\\x00\\x90\\x07\\x9f\\x00\\x97\\x15\\x1f\\tH\\x00\\x15\\x00\\x03\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf1\\xf5@@@@'", "ispf": {"version": "03.00", "flags": 0, "createdate": "1990-03-20T00:00:00", "modifydate": "1997-05-31T09:48:00", "lines": 21, "newlines": 3, "modlines": 0, "user": "CBT415"}, "text": "//GILBERTK JOB (ACCT#),CLS,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n*---------------------------------------------------------------------*\n*        TSO \"CLEAR SCREEN\" COMMAND                                   *\n*---------------------------------------------------------------------*\nCLEARSCR CSECT\nCLEARSCR RMODE ANY\n         STLINENO LINE=1,CLEAR=YES     TOP OF SCREEN\n         BR    14                      GOBACK\n         DC    C'GSF UTILITIES - CLS R300'\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//LKED    EXEC PGM=HEWL,PARM=(MAP,RENT)\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=CBTTAPE.FILE183.LOAD(CLS),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CMDJ": {"ttr": 3845, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x81\\x01o\\x00\\x91\\x10/\\x13!\\x00<\\x00\"\\x00\\x00\\xc3\\xc2\\xe3\\xf3\\xf3\\xf8@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1981-01-16T00:00:00", "modifydate": "1991-04-12T13:21:00", "lines": 60, "newlines": 34, "modlines": 0, "user": "CBT338"}, "text": "//GILBERTC JOB (ACCT#),CMDJ,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//ASMH EXEC PGM=IEV90,PARM='NODECK,OBJECT,NOESD,NORLD,NOXREF'\n***********************************************************************\n*                                                                     *\n*        SEND A JES2 COMMAND FOR CURRENT JOB                          *\n*                                                                     *\n*        EXAMPLE:                                                     *\n*                                                                     *\n*           //PURGE   EXEC PGM=CMDJES2,PARM=P       PURGE THE JOB     *\n*                                                                     *\n*           SENDS A $PJ##### COMMAND TO JES2, WHERE ##### IS THE      *\n*           JOB'S OWN JOB NUMBER.                                     *\n*                                                                     *\n*        WARNING !!! THIS PROGRAM MUST BE APF-AUTHORIZED.             *\n*                                                                     *\n***********************************************************************\nCMDJES2  CSECT\nCMDJES2  RMODE ANY\n         SAVE  (14,12),,'GSF UTILITIES - CMDJ R100'\n         LR    R12,R15\n         USING CMDJES2,R12\n         L     R10,0(,R1)           PARM ADDRESS\n         LH    R14,0(,R10)          PARM LENGTH\n         CH    R14,=Y(L'CMD1CMD)    TOO LONG?\n         BH    RC12                 YES, QUIT\n         BCTR  R14,0\n         EX    R14,*+4\n         MVC   CMD1CMD(*-*),2(R10)  MOVE COMMAND\n         L     R3,X'21C'            PSATOLD (CURRENT TCB)\n         L     R4,X'0B4'(,R3)       JSCB\n         L     R5,X'13C'(,R4)       SSIB\n         MVC   CMD1JOBI,X'00C'(R5)  SSIBJBID=JOB01234\n         MVI   CMD1JOBI+1,C' '      O\n         MVI   CMD1JOBI+2,C' '      B\n         MODESET KEY=ZERO,MODE=SUP\n         SLR   R0,R0\n         MGCR  CMD1\n         MODESET KEY=NZERO,MODE=PROB\n         STIMER WAIT,BINTVL==A(500) WAIT 5 SECONDS\n         RETURN (14,12),RC=0\nRC12     RETURN (14,12),RC=12       PARM IS TOO LONG\nCMD1     WTO   '$                                     ',MF=L\nCMD1CMD  EQU   CMD1+5,24   P\nCMD1JOBI EQU   CMD1+6,8    JOB03210\n         YREGS\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSPRINT DD SYSOUT=*\n//*\n//LKED    EXEC PGM=IEWL,PARM='MAP,AC=1'\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,DELETE)\n//SYSPRINT DD SYSOUT=*\n//SYSLMOD  DD DSN=SYS1.P390.LINKLIB(CMDJES2),DISP=SHR\n//*\n//GO      EXEC PGM=CMDJES2,PARM=P                     PURGE THE JOB\n//STEPLIB  DD DSN=SYS1.P390.LINKLIB,DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COB2JOB": {"ttr": 3847, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x93\\x03\\x8f\\x01\\x06\\x14\\x8f 9\\x00\\x86\\x00B\\x00\\x0f\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1993-02-07T00:00:00", "modifydate": "2006-05-28T20:39:00", "lines": 134, "newlines": 66, "modlines": 15, "user": "CBT472"}, "text": "//GILBERTJ JOB (ACCT#),COB2JOB,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//*\n//COB2 EXEC PGM=IGYCRCTL\n CBL NOLIB,APOST,NODECK,OBJECT,NOSEQ,BUF(10000),NONAME\n CBL NOMAP,NOLIST,NOOFFSET,NOXREF\n       Identification Division.\n         Program-ID. Cob2Job.\n         Author. Gilbert Saint-Flour <carlos@gsf-soft.com>.\n      *----------------------------------------------------------------*\n      *                                                                *\n      *    This program retrieves specific job-related data from MVS   *\n      *    control blocks and moves it to Working-storage.             *\n      *                                                                *\n      *    The name of the control-block is indicated in pos 1-6 of    *\n      *    the Procedure Division lines.                               *\n      *    The layout of the MVS control blocks is described in the    *\n      *    MVS Data Areas manuals, which can be found on any MVS or    *\n      *    OS/390 CD collection or viewed on-line by going to:         *\n      *        http://www.s390.ibm.com/bookmgr-cgi/bookmgr.cmd/library *\n      *    and searching for:                                          *\n      *        MVS DATA AREAS                                          *\n      *                                                                *\n      *    Origin = http://gsf-soft.com/Freeware/                      *\n      *                                                                *\n      *----------------------------------------------------------------*\n       Data Division.\n        Working-Storage Section.\n         01 Results.\n           05 job-name Pic x(8).\n           05 proc-step Pic x(8).\n           05 step-name Pic x(8).\n           05 program-name Pic x(8).\n           05 program-name2 Pic x(8).\n           05 job-number Pic x(8).\n           05 job-class Pic x.\n           05 msg-class Pic x.\n           05 programmer-name Pic x(20).\n           05 acct1 Pic x(32).\n           05 user-id Pic x(8).\n           05 group-name Pic x(8).\n           05 user-name Pic x(20).\n           05 batch-or-cics Pic x(5).\n              88 Batch Value 'BATCH'.\n              88 CICS  Value 'CICS '.\n           05 micro-seconds Pic S9(15) COMP-3.\n         01 four-bytes.\n           05 full-word Pic s9(8) Binary.\n           05 ptr4      Redefines full-word Pointer.\n         01 eight-bytes.\n           05 double-word Pic s9(18) Binary.\n        Linkage Section.\n         01 cb1.  05 ptr1 Pointer Occurs 256.\n         01 cb2.  05 ptr2 Pointer Occurs 256.\n\n       Procedure Division.\n PSA       SET Address of cb1 to NULL\n TCB       SET Address of cb1 to ptr1(136)\n           MOVE cb1(317:8) to eight-bytes\n           COMPUTE micro-seconds = double-word / 4096\n TIOT      SET Address of cb2 to ptr1(4)\n           MOVE cb2(1:8) to job-name\n           MOVE cb2(9:8) to proc-step\n           MOVE cb2(17:8) to step-name\n JSCB      SET Address of cb2 to ptr1(46)\n           MOVE cb2(361:8) to program-name\n SSIB      SET Address of cb2 to ptr2(80)\n           MOVE cb2(13:8) to job-number\n PRB       SET Address of cb2 to ptr1(1)\n           MOVE cb2(97:8) to program-name2\n JSCB      SET Address of cb2 to ptr1(46)\n JCT       SET Address of cb2 to ptr2(66)\n           MOVE cb2(48:1) to job-class\n           MOVE cb2(23:1) to msg-class\n ACT       MOVE zero to full-word\n           MOVE cb2(57:3) to four-bytes(2:3)\n           SET Address of cb2 to ptr4\n           MOVE cb2(25:20) to programmer-name\n           MOVE zero to full-word\n           MOVE cb2(49:1) to four-bytes(4:1)\n           MOVE cb2(50:full-word) to acct1\n EXT2      SET Address of cb2 to ptr1(53)\n CAUF      IF cb2(21:4) = low-values THEN\n             SET Batch to TRUE\n           ELSE\n             SET CICS to TRUE\n           END-IF\n PSA       SET Address of cb1 to NULL\n ASCB      SET Address of cb1 to ptr1(138)\n ASXB      SET Address of cb2 to ptr1(28)\n           MOVE cb2(193:8) to user-id\n ACEE      SET Address of cb2 to ptr2(51)\n           MOVE cb2(31:8) to group-name\n UNAM      SET Address of cb1 to ptr2(26)\n           MOVE zero to full-word\n           MOVE cb1(1:1) to four-bytes(4:1)\n           MOVE cb1(2:full-word) to user-name\n           DISPLAY job-name ' '\n                   proc-step ' '\n                   step-name ' '\n                   program-name ' '\n                   program-name2 ' '\n                   job-number ' '\n                   job-class ' '\n                   msg-class ' '\n                   micro-seconds ' '\n           DISPLAY quote programmer-name quote ' '\n                   quote acct1 quote ' '\n                   batch-or-cics ' '\n                   user-id ' '\n                   group-name ' '\n                   quote user-name quote ' '\n           GOBACK.\n/*\n//SYSPRINT DD SYSOUT=*\n//SYSUT1 DD UNIT=VIO,SPACE=(TRK,1)\n//SYSUT2 DD UNIT=VIO,SPACE=(TRK,1)\n//SYSUT3 DD UNIT=VIO,SPACE=(TRK,1)\n//SYSUT4 DD UNIT=VIO,SPACE=(TRK,1)\n//SYSUT5 DD UNIT=VIO,SPACE=(TRK,1)\n//SYSUT6 DD UNIT=VIO,SPACE=(TRK,1)\n//SYSUT7 DD UNIT=VIO,SPACE=(TRK,1)\n//SYSLIN DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//GOPROC PROC\n//GO    EXEC PGM=LOADER,PARM=PRINT\n//SYSLIN DD DSN=*.COB2.SYSLIN,DISP=(OLD,PASS)\n//SYSLIB DD DSN=CEE.SCEELKED,DISP=SHR\n//SYSLOUT DD SYSOUT=*\n//SYSOUT DD SYSOUT=*\n//GOPROC PEND\n//*\n//GOPROC EXEC GOPROC\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "COB2SYS": {"ttr": 3850, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//GILBERTS JOB (ACCT#),COB2SYS,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//*\n//COB2 EXEC PGM=IGYCRCTL\n CBL NOLIB,APOST,NODECK,OBJECT,NOSEQ,BUF(10000),NONAME\n CBL NOMAP,NOLIST,NOOFFSET,NOXREF\n       Identification Division.\n         Program-ID. Cob2Sys.\n         Author. Gilbert Saint-Flour <carlos@gsf-soft.com>.\n      *----------------------------------------------------------------*\n      *                                                                *\n      *    This program retrieves specific system-related data from    *\n      *    MVS control blocks and moves it to Working-storage.         *\n      *                                                                *\n      *    The name of the control-block is indicated in pos 1-6 of    *\n      *    the Procedure Division lines.                               *\n      *    The layout of the MVS control blocks is described in the    *\n      *    MVS Data Areas manuals, which can be found on any MVS or    *\n      *    OS/390 CD collection or viewed on-line by going to:         *\n      *        http://www.s390.ibm.com/bookmgr-cgi/bookmgr.cmd/library *\n      *    and searching for:                                          *\n      *        MVS DATA AREAS                                          *\n      *                                                                *\n      *    Origin = http://gsf-soft.com/Freeware/                      *\n      *                                                                *\n      *----------------------------------------------------------------*\n       Data Division.\n        Working-Storage Section.\n         01 Results.\n           05 sys-name Pic x(8).\n           05 real-storage-m Pic s9(6) comp.\n           05 prodi Pic x(8).\n           05 prodn Pic x(8).\n           05 mdl Pic 9999.\n           05 smf-name Pic x(4).\n           05 ipl-jdate Pic 9(7) comp-3.\n           05 SU-sec Pic s9(6) comp.\n           05 cpu-type Pic x(6).\n           05 cpu-model Pic x(3).\n           05 sysplex-name  Pic x(8).\n           05 OS-name    Pic X(16).\n           05 OS-release Pic X(6).\n           05 hardware-name Pic x(8).\n           05 lpar-name Pic x(8).\n           05 VM-userid Pic x(8).\n         01 four-bytes.\n           05 full-word Pic s9(8) Comp.\n           05 ptr4      Redefines full-word Pointer.\n           05 pl4       Redefines full-word Pic 9(7) comp-3.\n        Linkage Section.\n         01 cb1.  05 ptr1 Pointer Occurs 512.\n         01 cvt.  05 cvt1 Pointer Occurs 512.\n       Procedure Division.\n PSA       SET ADDRESS OF cb1 TO NULL\n CVT       SET ADDRESS OF cvt TO ptr1(5)\n           MOVE cvt(341:8) TO sys-name\n           MOVE cvt(857:4) TO four-bytes\n           COMPUTE real-storage-m = (full-word + 1023) / 1024\n           DISPLAY ' SYSNAME='  sys-name\n           DISPLAY ' STOR='     real-storage-m 'M'\nCVTFIX     SET ptr4 to ADDRESS OF cvt\n           SUBTRACT 256 FROM full-word\n           SET ADDRESS OF cb1 TO ptr4\n           MOVE cb1(217:8) TO prodi\n           MOVE cb1(225:8) TO prodn\n           MOVE ZERO to pl4\n           MOVE cb1(251:2) TO four-bytes(1:2)\n           COMPUTE mdl = pl4 / 1000\n           DISPLAY ' PRODI=' prodi\n           DISPLAY ' PRODN=' prodn\n           DISPLAY ' MODEL=' mdl\n SMCA      SET ADDRESS OF cb1 TO cvt1(50)\n           MOVE cb1(17:4) TO smf-name\n           MOVE cb1(341:4) TO four-bytes\n           COMPUTE ipl-jdate = pl4 + 1900000\n           DISPLAY ' SMFSID='   smf-name\n           DISPLAY ' IPL='      ipl-jdate\n RMCT      SET ADDRESS OF cb1 TO cvt1(152)\n           MOVE cb1(65:4) TO four-bytes\n           COMPUTE SU-sec = 16000000 / full-word\n           DISPLAY ' Speed='   SU-sec ' SU/s'\n HID       SET ADDRESS OF cb1 TO cvt1(268)\n           MOVE cb1(27:6) TO cpu-type\n           MOVE cb1(33:3) TO cpu-model\n           DISPLAY ' CPU='     cpu-type '-' cpu-model\n ECVT      SET ADDRESS OF cb1 TO cvt1(36)\n           MOVE cb1(9:8) TO sysplex-name\n           MOVE cb1(337:8) TO hardware-name\n           MOVE cb1(345:8) TO lpar-name\n           MOVE cb1(353:8) TO VM-userid\n           MOVE cb1(497:16) TO OS-name\n           MOVE cb1(513:6) TO OS-release\n           DISPLAY ' SYSPLEX=' sysplex-name\n           DISPLAY ' HWNAME='  hardware-name\n           DISPLAY ' LPAR='    lpar-name\n           DISPLAY ' VM='      VM-userid\n           DISPLAY ' OS_Name=' OS-name\n           DISPLAY ' Release=' OS-release\n           GOBACK.\n/*\n//SYSUT1 DD UNIT=VIO,SPACE=(TRK,1)\n//SYSUT2 DD UNIT=VIO,SPACE=(TRK,1)\n//SYSUT3 DD UNIT=VIO,SPACE=(TRK,1)\n//SYSUT4 DD UNIT=VIO,SPACE=(TRK,1)\n//SYSUT5 DD UNIT=VIO,SPACE=(TRK,1)\n//SYSUT6 DD UNIT=VIO,SPACE=(TRK,1)\n//SYSUT7 DD UNIT=VIO,SPACE=(TRK,1)\n//SYSLIN DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//SYSPRINT DD SYSOUT=*\n//*\n//GO    EXEC PGM=LOADER,PARM=PRINT\n//SYSLIN DD DSN=*.COB2.SYSLIN,DISP=(OLD,PASS)\n//SYSLIB DD DSN=CEE.SCEELKED,DISP=SHR\n//SYSLOUT DD SYSOUT=*\n//SYSOUT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "COB2TSO": {"ttr": 3853, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//GILBERTJ JOB (ACCT#),COB2TSO,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//COB2 EXEC PGM=IGYCRCTL\n CBL NOLIB,APOST,NODECK,OBJECT,NOSEQ,BUF(10000),DYNAM\n CBL NOMAP,NOLIST,NOOFFSET,NOXREF\n       Identification Division.\n         Program-ID. CB2TSOEV.\n         Author. Gilbert Saint-Flour <carlos@gsf-soft.com>\n      ******************************************************************\n      *                                                                *\n      *   MODULE NAME = COB2TSO                                        *\n      *                                                                *\n      *   DESCRIPTIVE NAME = Issue TSO commands from a COBOL program.  *\n      *                                                                *\n      *   FUNCTION = This sample program demonstrates how to invoke    *\n      *              TSO commands from a COBOL program using           *\n      *              standard TSO services as documented in the        *\n      *              TSO/E Programming Services manual.                *\n      *                                                                *\n      *              Most TSO commands, including CLISTs and REXX      *\n      *              execs can be executed using this technique.       *\n      *              TSO commands which require authorization          *\n      *              (such as OUTPUT, SEND, TRANSMIT and RECEIVE)      *\n      *              will not work.                                    *\n      *                                                                *\n      *    Origin = http://gsf-soft.com/Freeware/                      *\n      *                                                                *\n      ******************************************************************\n\n       Data Division.\n        Working-Storage Section.\n         01 Filler.\n           05 ws-dummy        Pic s9(8) Comp.\n           05 ws-return-code  Pic s9(8) Comp.\n           05 ws-reason-code  Pic s9(8) Comp.\n           05 ws-info-code    Pic s9(8) Comp.\n           05 ws-cppl-address Pic s9(8) Comp.\n           05 ws-flags        Pic X(4) Value X'00010001'.\n           05 ws-buffer       Pic X(256).\n           05 ws-length       Pic s9(8) Comp Value 256.\n\n       Procedure Division.\n      *----------------------------------------------------------------*\n      *          Call IKJTSOEV to create the TSO/E environment         *\n      *----------------------------------------------------------------*\n           CALL 'IKJTSOEV' Using ws-dummy\n                                 ws-return-code\n                                 ws-reason-code\n                                 ws-info-code\n                                 ws-cppl-address.\n           IF ws-return-code > zero\n             DISPLAY 'IKJTSOEV Failed, Return-code=' ws-return-code\n                                     ' Reason-code=' ws-reason-code\n                                     'Info-code='    ws-info-code\n             MOVE ws-return-code to Return-code\n             STOP RUN.\n      *----------------------------------------------------------------*\n      *          Build the TSO/E command in ws-buffer                  *\n      *----------------------------------------------------------------*\n\n           MOVE 'ALLOCATE DD(SYSPUNCH) SYSOUT HOLD' to ws-buffer.\n\n      *----------------------------------------------------------------*\n      *   Call the TSO/E Service Routine to execute the TSO/E command  *\n      *----------------------------------------------------------------*\n           CALL 'IKJEFTSR' Using ws-flags\n                                 ws-buffer\n                                 ws-length\n                                 ws-return-code\n                                 ws-reason-code\n                                 ws-dummy.\n           IF ws-return-code > zero\n             DISPLAY 'IKJEFTSR Failed, Return-code=' ws-return-code\n                                     ' Reason-code=' ws-reason-code\n             MOVE ws-return-code to Return-code\n             STOP RUN.\n\n      *----------------------------------------------------------------*\n      *          Check that the ALLOCATE command worked                *\n      *----------------------------------------------------------------*\n           DISPLAY 'ALLOCATE Worked ! ' Upon Syspunch.\n\n           STOP RUN.\n/*\n//SYSPRINT DD SYSOUT=*\n//SYSUT1 DD UNIT=VIO,SPACE=(TRK,1)\n//SYSUT2 DD UNIT=VIO,SPACE=(TRK,1)\n//SYSUT3 DD UNIT=VIO,SPACE=(TRK,1)\n//SYSUT4 DD UNIT=VIO,SPACE=(TRK,1)\n//SYSUT5 DD UNIT=VIO,SPACE=(TRK,1)\n//SYSUT6 DD UNIT=VIO,SPACE=(TRK,1)\n//SYSUT7 DD UNIT=VIO,SPACE=(TRK,1)\n//SYSLIN DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//GO    EXEC PGM=LOADER,PARM=NOPRINT\n//SYSLIN DD DSN=*.COB2.SYSLIN,DISP=(OLD,PASS)\n//SYSLIB DD DSN=CEE.SCEELKED,DISP=SHR\n//SYSOUT DD SYSOUT=*\n//SYSTSPRT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "COMPRCMD": {"ttr": 3856, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x03\\x17\\x00\\x10\\x00\\x841O\\x01\\x10$\\x1f\\x11\\x14\\x05U\\x02\\\\\\x03\\xbc\\xc3\\xc2\\xe3\\xf4\\xf8\\xf3@@@@'", "ispf": {"version": "03.23", "flags": 0, "createdate": "1984-11-09T00:00:00", "modifydate": "2010-08-29T11:14:10", "lines": 1365, "newlines": 604, "modlines": 956, "user": "CBT483"}, "text": "//GILBERTK JOB (ACCT#),COMPRESS,\n//*RESTART=GO,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = COMPRESS                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = COMPRESS a PDS with DISP=SHR                     *\n*                                                                     *\n* STATUS = R323                                                       *\n*                                                                     *\n* FUNCTION = This TSO/E command allows you to compress a partitionned *\n*            data set with DISP=SHR using a protection scheme         *\n*            compatible with ISPF and the linkage-editor.             *\n*            It also allows you to compress several data sets with a  *\n*            single command by specifying a generic data set name     *\n*            such as 'SYS2.*'.  Together with the command itself,     *\n*            there is an edit macro particularly handy when abend     *\n*            SD37 strikes the PDS you're editing.                     *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*          http://gsf-soft.com/Freeware/                              *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = MVS/ESA 4.3                                       *\n*                   DFSMS/MVS                                         *\n*                   TSO/E 1.3                                         *\n*                   STRING macro R400                                 *\n*                                                                     *\n*    AUTHORIZATION = NONE                                             *\n*                                                                     *\n*    RESTRICTIONS = NONE                                              *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (TSO Command Processor)                    *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 4K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE 24, AMODE 31,                    *\n*                 PROBLEM STATE, KEY 8                                *\n*                                                                     *\n* SYNTAX = See Below                                                  *\n*                                                                     *\n*            COMPRESS 'data-set-name'                                 *\n*                      VOLUME('volser')                               *\n*                      CHECK/NOCHECK                                  *\n*                      SHR/OLD/LLAREFRESH                             *\n*                      CHANGED/NOCHANGED                              *\n*                      SETMSG                                         *\n*                                                                     *\n*            'data-set-name' is the dsname of the data set or         *\n*            a generic dsname like 'ISP.V2R3M0.*'.                    *\n*            If you specify a generic name, \"COMPRESS\" retrieves      *\n*            the full data sets names from the catalog.               *\n*            If the dsname is not enclosed in apostrophes,            *\n*            it is prefixed with your userid.                         *\n*            A list of data set names enclosed in parentheses         *\n*            can also be specified.                                   *\n*                                                                     *\n*            'volser' is the volume serial number of the data set     *\n*            when the data set is not cataloged or is cataloged on    *\n*            another volume.                                          *\n*                                                                     *\n*            'OLD' specifies that the data-set(s) should be allo-     *\n*            cated with DISP=OLD instead of SHR, which is the         *\n*            default.  During a generic compress, 'OLD' allows you    *\n*            to make sure that the data sets currently allocated      *\n*            by other jobs are not compressed.                        *\n*                                                                     *\n*            'LLAREFRESH' instructs COMPRESS to issue LLACOPY for     *\n*            each member in the compressed PDS to refresh LLA         *\n*            directory pointers. To satisfy LLACOPY authorisation     *\n*            requirements, COMPRESS must be specified in the          *\n*            AUTHTSF section of the IKJTSOxx member.                  *\n*                                                                     *\n*            CHECK/NOCHECK are key-words that only apply to           *\n*            MVS systems with ASM2 installed.                         *\n*            'CHECK' is the default and indicates that during a       *\n*            generic compress operation, a data set should not        *\n*            be compressed if its asm2id (ds1syscd+8 in the           *\n*            f1-dscb) is identical to the job name; in other          *\n*            words, if the PDS hasn't been updated since the last     *\n*            time your job processed it, there's no need to           *\n*            compress it again.                                       *\n*            'NOCHECK' indicates that the PDS should be               *\n*            compressed regardless of what ASM2ID contains.           *\n*                                                                     *\n*            'CHANGED' indicates that during a generic compress       *\n*            operation, a data set should not be compressed if its    *\n*            DS1DSCHA bit is off, in other words, if the PDS          *\n*            hasn't been updated since the last time it's been        *\n*            backed up.  This is the default.                         *\n*            'NOCHANGED' indicates that the PDS should be             *\n*            compressed regardless of the setting of the changed bit. *\n*                                                                     *\n*            'SETMSG' is an option used by the COMPRESS edit macro.   *\n*                                                                     *\n* OPERATION = See Below                                               *\n*                                                                     *\n*           1. The \"COMPRESS\" command requires no APF authorization   *\n*              and can be executed out of any load library.           *\n*              \"COMPRESS\" uses the TSO/E service routine (IKJEFTSR)   *\n*              to create the authorized environment required to       *\n*              execute IEBCOPY.  The default IKJEFTAP table           *\n*              is set up for this purpose (and so is the IKJTSOxx     *\n*              parmlib member if your system supports it).            *\n*                                                                     *\n*           2. The protection scheme used by \"COMPRESS\" is            *\n*              similar to the one implemented by ISPF/PDF V2 and      *\n*              protects against simultaneous updates by ISPF and      *\n*              the linkage editor.  However, when you compress a      *\n*              PDS with DISP=SHR you don't have any read              *\n*              integrity.  This is particularly critical for          *\n*              load libraries and compressing one while it is         *\n*              used may cause S106 abends.                            *\n*                                                                     *\n*           3. If you specify a volser together with a generic        *\n*              data set name, \"COMPRESS\" looks in the catalog for     *\n*              the full data set names, skipping the data sets that   *\n*              are cataloged on other disk packs.  \"COMPRESS\"         *\n*              does not read the VTOC: if uncataloged data sets that  *\n*              satisfy the generic name requirement exist on the      *\n*              pack, they are not processed.                          *\n*                                                                     *\n*           4. If you intend to use the \"COMPRESS\" edit macro,        *\n*              copy it to a clist library such as IPO1.CMDPROC        *\n*              or ISR.V2R3M0.ISRCLIB.  That's all you need to be      *\n*              able to invoke it as an edit primary commands like     *\n*              'CANCEL' or 'RESET'.                                   *\n*              At any moment while you're editing a member, you       *\n*              may enter 'COMPRESS' to compress the PDS.  When        *\n*              it is compressed, the edit macro returns an ISPF       *\n*              message that indicates how full the PDS now is.        *\n*                                                                     *\n*           5. The TSO/E service routine creates a parallel TMP       *\n*              to invoke IEBCOPY.                                     *\n*              This is what the TCB structure looks like while        *\n*              IEBCOPY is executing:                                  *\n*                                                                     *\n*                IKJEFT01           TMP INIT (JSTCB)                  *\n*                  IKJEFT02         TMP MAINLINE                      *\n*                    IKJEFT09       TMP SECOND LEVEL                  *\n*                      COMPRESS     COMMAND PROCESSOR                 *\n*                  IKJEFT02         TMP MAINLINE (PARALLEL TMP)       *\n*                    IKJEFT09       TMP SECOND LEVEL (PARALLEL TMP)   *\n*                      IEBCOPY      IEBCOPY                           *\n*                                                                     *\n*           6. The STTMPMD (set TMP mode) macro is used to disable    *\n*              the attention and PA1 keys.  This prevents users       *\n*              from destroying their PDS which can so easily happen   *\n*              when they use ISPF compress services.                  *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n*260 MODIFIED FOR TSO/E VERSION 2 (AMODE=31)                     1992 *\n*261 SHR/OLD, Statistics                                              *\n*262 Ignore migrated data sets                                        *\n*263 STOP Command                                                     *\n*264 CHANGED/NOCHANGED                                                *\n*266 Check for PDSEs and do not compress them                    1993 *\n*267 Refresh display if invoked from PDF 3.4 panel - ZDLREF           *\n*310 Change numbering scheme                                     1994 *\n*311 Goback with non-zero return-code after PARSE failure        1995 *\n*    Small changes to the REXX EXEC for ISPF 4.1                      *\n*312 Add SPACE=(TRK,10) to SYSIN/SYSPRINT allocation and              *\n*    invoke DAIRFAIL if it fails.                                     *\n*313 Add SETMSG option which sets ZMSG000S and ZMSG000L and issues    *\n*    SETMSG(ISPZ000) instead of the normal completion message;        *\n*    the COMPRESS EDIT macro no longer needs to use OUTTRAP.          *\n*314 Replace IKJTSMSG macros with STRING; issue statistics in long    *\n*    message when SETMSG option is used.                              *\n*315 Move STTMPMD macros around IEBCOPY invocation to make sure  1996 *\n*    that STTMPMD OFF is executed.                                    *\n*316 Retrieve volser from ZDLVOL when invoked from PDF 3.4       1998 *\n*    Minor technical changes                                          *\n*317 Copy DYNALLOC Return Code to MAXCC                          2003 *\n*    Replace PUT24 with GET/PUT                                       *\n*318 Force RECFM=FB,LRECL=80 in SYSIN DCB (PDSMAN/PM74127).           *\n*    Add VOLSER to MSG28                                         2004 *\n*319 Data Set List                                               2005 *\n*320 Re-read F1-DSCB in case ENQ had to wait                     2006 *\n*321 LLAREFRESH                                                       *\n*322 Add vol(volser) to final message when VOL was supplied      2009 *\n*323 Convert PARM to CPPL when invoked as a program              2010 *\n&REL     SETC  'R323'                                                 *\n***********************************************************************\n&DATE    SETC  '&SYSDATE'(7,2)'-'.'&SYSDATE'(1,2)'-'.'&SYSDATE'(4,2)\nCOMPRESS CSECT\nCOMPRESS AMODE 31\n         SAVE (14,12),,'GSF Utilities - COMPRESS &REL 20&DATE &SYSTIME'\n         LR    R12,R15                 BASE REGISTER\n         USING COMPRESS,R12\n***********************************************************************\n*        ALLOCATE DYNAMIC STORAGE AREA                                *\n***********************************************************************\n         LA    R0,DYNAML               SIZE OF DYNAMIC AREA\n         GETMAIN R,LV=(0)              ACQUIRE DYNAMIC STORAGE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LM    R13,R1,8(R13)           load R13, reload R1\n         USING DYNAM,R13\n         LR    R11,R1                  A(CPPL)\n         USING CPPL,R11\n         LA    R14,DYNAM+72            CLEAR DYNAMIC STORAGE AREA\n         LA    R15,DYNAML-72           CLEAR DYNAMIC STORAGE AREA\n         SLR   R3,R3                   CLEAR DYNAMIC STORAGE AREA\n         MVCL  R14,R2                  CLEAR DYNAMIC STORAGE AREA\n***********************************************************************\n*        Check for re-entry via AUTHTSF(COMPRESS)                     *\n***********************************************************************\nCHKAUTH  EQU   *\n         L     R2,540(,0)              PSATOLD (own TCB)\n         L     R2,0(,R2)               TCBRBP (own PRB)\n         ICM   R2,B'0111',RBCDE1-RBBASIC(R2) (own CDE)\n         MVC   OWNNAME,CDNAME-CDENTRY(R2) own name\n*\n         MVI   DYNENQL,X'80'           EOL\n         ENQ  (OWNNAME,OWNNAME,E,L'OWNNAME,STEP),MF=(E,DYNENQL),RET=USE\n         LTR   R15,R15                 first time?\n         BNZ   LLACOPY                 no, must be auth call from TSR\n         EXTRACT ADDRTIOT,FIELDS=TIOT,MF=(E,EXTRACTL)\n         EXTRACT ADDRCOMM,FIELDS=COMM,MF=(E,EXTRACTL)\n***********************************************************************\n*        Convert PARM to CPPL when invoked as a program               *\n***********************************************************************\n         TM    CPPL+0,X'80'            CPPL or PARM ?\n         BZ    BLDCPPLX                CPPL, jump\nBLDCPPL  EQU   *\n         L     R1,CPPL+0               A(PARM)\n         LH    R2,0(,R1)               R2: length of PARM field\n         STRING X'0100,0009',OWNNAME,1X,(2(R1),(R2)),                  X\n               INTO=PGM_CBUF\n         STH   R15,PGM_CBUF+0          4+length\n         LA    R11,DYN_CPPL            point at CPPL\n         LA    R1,PGM_CBUF             command buffer\n         ST    R1,CPPLCBUF             command buffer\n         L     R1,X'0224'(0,0)         PSAAOLD   A(ASCB)\n         L     R1,X'006C'(,R1)         ASCBASXB  A(ASXB)\n         L     R1,X'0014'(,R1)         ASXBLWA   A(LWA)\n         L     R2,X'0020'(,R1)         LWAPECT   A(ECT)\n         ST    R2,CPPLECT              Store ECT address\n         L     R1,X'0018'(,R1)         LWAPSCB   A(PSCB)\n         ST    R1,CPPLPSCB             A(PSCB)\n         MVC   CPPLUPT,X'0034'(R1)     PSCBUPT   A(UPT)\nBLDCPPLX EQU   *\n***********************************************************************\n*        BUILD PARAMETER LIST FOR IKJEFF02                            *\n***********************************************************************\n         ST    R11,MTCPPLP             STORE CPPL ADDRESS IN MTPL\n         LA    R0,MTCSECTP             MESSAGE SECTION\n         ST    R0,MTPLPTR              STORE ADDR IN MTPL\n         LA    R0,DYNECB               EVENT CONTROL BLOCK\n         ST    R0,MTECBP               STORE ECB IN MTPL\n         L     R0,=A(MSGCSECT)         MESSAGE CSECT\n         ST    R0,MTCSECTP             STORE ECT IN PPL\n         OI    MTSW1,MTPUTLSW          PUTLINE IS NEEDED\n         OI    MTSW2,MTFMT             31-BIT PARM LIST\n         USING PPL,DYNPPL              SET UP ADDRESSABILITY TO PPL\n***********************************************************************\n*        BUILD PARSE PARM LIST, CALL IKJPARS                          *\n***********************************************************************\nPARSE000 EQU   *\n         L     R0,CPPLUPT              USER PROFILE TABLE\n         ST    R0,PPLUPT               STORE UPT ADDRESS IN PPL\n         L     R0,CPPLECT              ENVIRONMENT CONTROL TABLE\n         ST    R0,PPLECT               STORE ECT IN PPL\n         LA    R0,DYNECB               EVENT CONTROL BLOCK\n         ST    R0,PPLECB               STORE ECB IN PPL\n         MVC   PPLPCL,=A(PCLCSECT)     STORE PCL ADDR INTO PPL\n         LA    R0,DYNANSWR             ANSWER AREA\n         ST    R0,PPLANS               STORE ANSWER ADDRESS IN PPL\n         L     R0,CPPLCBUF             COMMAND BUFFER\n         ST    R0,PPLCBUF              STORE BUFFER ADDRESS IN PPL\n         L     R15,CVTPTR(,0)          ADDR OF CVT\n         L     R15,CVTPARS-CVTMAP(,R15) ADDR OF IKJPARS\n         LA    R1,PPL                  ADDR OF PPL\n         SYNCH (R15)                <- CALL THE TSO PARSE ROUTINE\n         ST    R15,MAXCC               SAVE RETURN CODE\n         LTR   R15,R15                 CHECK FOR ZERO PARSE RETURN\n         BNZ   FINISH                  GO AWAY UPSET\n***********************************************************************\n*        PROCESS PARSED PARAMETERS                                    *\n***********************************************************************\n         L     R7,DYNANSWR             LOAD PDL ADDRESS\n         USING IKJPARMD,R7             SET UP ADDRESSABILITY TO PDL\nPARSE200 MVI   CHECK,C'C'              DEFAULT IS 'CHECK'\n         CLI   CHKPCE+1,2              CHECK FOR 2ND IKJPNAME\n         BNE   PARSE220                JUMP IF NOT THE 2ND\n         MVI   CHECK,C'N'              2ND IS 'NOCHECK'\nPARSE220 MVI   CHANGED,C'C'            DEFAULT IS 'CHANGED'\n         CLI   CHNGPCE+1,2             CHECK FOR 2ND IKJPNAME\n         BNE   PARSE230                JUMP IF NOT THE 2ND\n         MVI   CHANGED,C'N'            2ND IS 'NOCHANGED'\nPARSE230 CLI   SETMPCE+1,1             SETMSG option specified?\n         BNE   PARSE300                no, jump\n         MVI   SETMSG,C'Y'             yes, remember it\n*\nPARSE300 LA    R0,=AL2(DALSTATS,1,1,X'0800') DISP=SHR KEY\n         CLI   STATPCE+1,2             CHECK FOR 2ND IKJPNAME\n         BNE   PARSE310                JUMP IF NOT THE 2ND\n         LA    R0,=AL2(DALSTATS,1,1,X'0100') DISP=OLD KEY\nPARSE310 ST    R0,STATUS               STORE ADDRESS OF STATUS FIELD\n*\nPARSE500 TM    VOLPCE2+6,X'80'         CHECK VOLSER SUBPARAMETER\n         BZ    PARSE599                JUMP IF NO SUBPARAM SPECIFIED\n         L     R1,VOLPCE2+00           GET SUBPARAM ADDRESS\n         MVC   VOLSER,0(R1)            MOVE 6-BYTE VOLUME SERIAL\n         MVI   VOLGIVEN,C'Y'           SHOW VOL HAS BEEN GIVEN L\nPARSE599 EQU   *\n         LA    R7,DSNPCE               FIRST DSNAME\n         USING PCE7,R7\n***********************************************************************\n*                                                                     *\n*        PROCESS DATA SET LIST                                        *\n*                                                                     *\n***********************************************************************\n*LOOP\nGETDSN   EQU   *\n         L     R0,PCE7ADDR             GET ADDRESS OF DSNAME\n         LH    R1,PCE7LEN              ACTUAL LENGTH OF DSNAME\n         STRING ((R0),(R1)),INTO=DSNAME COPY DSNAME INTO 44-CHAR FLD\n         MVI   MODE,C'S'               DEFAULT IS MODE=SINGLE\n*\n*        EXTRACT DATA SET NAMES FROM CATALOG\n*\n         LA    R15,DSNAME-1(R1)        point R15 at last character\n         CLI   0(R15),C'*'             generic dsname?\n         BNE   PROCESS2                NO, USE MODE=SINGLE\n         BCTR  R1,0                    length(dsname)-1 for LISTCAT\n         STC   R1,WK265                STORE LENGTH\n         MVC   WK265+1(44),DSNAME      MOVE PARTIAL NAME\n         LA    R0,WK265                ENTRY NAME\n         ST    R0,CTGENT               ENTRY ADDRESS\n         MVI   CTGOPTN1,CTGNAME        CTGENT POINTS TO ENTRY NAME\n         OI    CTGOPTN1,CTGGENLD       GENERIC LOCATE REQUEST\n         MVI   CTGOPTN3,CTGAM0         OS/VS2 CATALOG MGMT REQUEST\n         OI    CTGOPTN3,CTGSUPLT       SUPER LOCATE REQUEST\n         MVI   CTGTYPE,CTGTALIN        ENTRY TYPE IS NONVSAM\n         OI    CTGOPTNS,CTGF2WKA       FORMAT-2 WORK AREA\n         ICM   R1,B'1111',CTGWKA       FIRST TIME?\n         BNZ   GETWKA2                 NO, SKIP GETMAIN\n         GETMAIN RC,LV=45*10000        WORK AREA FOR GENERIC LOCATE\n         LTR   R15,R15                 CHECK COMPLETION\n         BNZ   MSGGETM                 GETMAIN FAILED, EXIT\n         ST    R1,CTGWKA               STORE ADDRESS INTO CTGPL\n         ST    R0,0(,R1)               FORMAT WORK AREA HEADER\nGETWKA2  EQU   *\n         XC    4(4,R1),4(R1)           FORMAT WORK AREA HEADER\n         LOCATE CTGPL                  REQUEST CATALOG MGMT SERVICES\n         LTR   R15,R15                 CHECK COMPLETION\n         BNZ   NEXTDSN                 GENERIC LOCATE FAILED, IGNORE\n         MVI   MODE,C'C'               MODE IS \"CATALOG\"\n         L     R8,CTGWKA               SVC 26 WORK AREA ADDRESS\n         LM    R0,R1,0(R8)             SVC 26 WORK AREA HEADER\n         LA    R1,7(,R1)               USED LENGTH\n         SRL   R1,3                     ROUNDED UP\n         SLL   R1,3                      TO A MULTIPLE OF 8\n         SR    R0,R1                   COMPUTE UNUSED LENGTH\n         LA    R1,0(R1,R8)             ADDRESS OF UNUSED PORTION\n         FREEMAIN RU,LV=(0),A=(1)      FREE UNUSED PORTION\n         LNR   R0,R0                   GET NEGATIVE LENGTH\n         A     R0,0(,R8)               ADD INITIAL LENGTH\n         ST    R0,0(,R8)               STORE CURRENT LENGTH\n         LA    R8,8(,R8)               FIRST DATA SET NAME\n***********************************************************************\n*        OBTAIN VOLUME AND DSCB INFORMATION                           *\n***********************************************************************\n*--LOOP\nPROCESS  CLI   0(R8),C'A'              NVSAM ENTRY?\n         BNE   NEXTDSN4                NO, SKIP IT\n         MVC   DSNAME,1(R8)            MOVE DATA SET NAME\nPROCESS2 MVI   PRINTMSG,C'N'           RESET INDICATOR\n         L     R0,=A(1000000)          ONE MEG\n         GETMAIN RC,LV=(0),LOC=(BELOW,ANY) GET ONE MEG FOR IEBCOPY\n         LTR   R15,R15                 CHECK COMPLETION\n         BNZ   MSGGETM                 GETMAIN FAILED, EXIT\n         FREEMAIN RU,LV=(0),A=(1)      FREE ONE MEG FOR IEBCOPY\n         CLI   VOLGIVEN,C'Y'           CHECK IF VOLSER WAS SUPPLIED\n         BE    OBTAIN00                JUMP IF IT WAS\n***********************************************************************\n*        retrieve DSLIST volser                                       *\n***********************************************************************\n         ICM   R15,B'1111',=A(ISPQRY)  ISPQRY AVAILABLE?\n         BZ    ZDLVOL9                 NO, QUIT\n         BALR  R14,R15              <- CALL ISPQRY\n         LTR   R15,R15                 ISPF SERVICES AVAILABLE?\n         BNZ   ZDLVOL9                 NO, QUIT\n         WXTRN ISPQRY,ISPLINK          THEY ARE OPTIONAL\n         CLI   MODE,C'S'               MODE=SINGLE?\n         BNE   ZDLVOL9                 NO, QUIT\n*VCOPY (ZDLDSN,ZDLVOL)\n         LA    R14,L'ZDLDSN            max length\n         LA    R15,L'ZDLVOL            max length\n         STM   R14,R15,DEVT1           length array\n*******  ISPLINK ($VCOPY,=C'(ZENVIR ZAPPLID ZUSER ZSCREEN)',           X\n               SIXWORDS,ZENVIR,$MOVE)\n         LA    R14,=C'VCOPY '          FUNCTION\n         LA    R15,=C'(ZDLDSN ZDLVOL)' VARIABLE NAME\n         LA    R0,DEVT1                length array\n         LA    R1,ZDLDSN               value array\n         LA    R2,=C'MOVE '            mode\n         STM   R14,R2,EFTPARM          STORE PARM LIST\n         OI    EFTPARM+16,X'80'        MARK END OF LIST\n         L     R15,=A(ISPLINK)         ISPF SERVICES\n         LA    R1,EFTPARM              PARM LIST ADDRESS\n         BALR  R14,R15              <- ISSUE VCOPY\n         LTR   R15,R15                 WENT OK?\n         BNZ   ZDLVOL9                 NO, QUIT\n         CLC   DSNAME,ZDLDSN           same dsname?\n         BNE   ZDLVOL9                 NO, QUIT\n         CLI   ZDLVOL,C'*'             ALIAS?\n         BE    ZDLVOL9                 YES, QUIT\n         MVC   VOLSER,ZDLVOL           yes, keep volser\n         MVI   VOLGIVEN,C'Y'           VOLSER was supplied by DSLIST\n         B     OBTAIN00                skip LOCATE\nZDLVOL9  EQU   *\n*\n*        Retrieve volser from the catalog and ignore migrated data sets\n*\n         L     R14,CAML26              CAMLST 1ST WORD\n         LA    R15,DSNAME              DATA SET NAME\n         SLR   R0,R0\n         LA    R1,WK265                WORK AREA\n         STM   R14,R1,EFTPARM          STORE RELOCATED CAMLST\n         LOCATE EFTPARM                GET VOLSER AND DEVICE TYPE\n         LTR   R15,R15                 CHECK FOR SUCCESSFUL COMPLETION\n         BNZ   MSG26                   LOCATE FAILED, EXIT\n         CLI   WK265+2+2,UCB3DACC      CHECK DEVICE CLASS\n         BNE   MSG26B                  NOT DASD, EXIT\n         MVC   VOLSER,WK265+2+4        KEEP VOLSER\n         CLC   =C'MIGRAT',VOLSER       CHECK VOLSER\n         BE    MSG26C                  MIGRATED BY HSM, EXIT\n*\n*        Read the F1-DSCB\n*\nOBTAIN00 L     R14,CAML28F1            CAMLST 1ST WORD\n         LA    R15,DSNAME              DATA SET NAME\n         LA    R0,VOLSER               VOL SERIAL\n         LA    R1,DS1FMTID             FORMAT-1\n         STM   R14,R1,EFTPARM          STORE RELOCATED CAMLST\n         OBTAIN EFTPARM                READ F1-DSCB\n         LTR   R15,R15                 CHECK FOR SUCCESSFUL COMPLETION\n         BNZ   MSG28                   OBTAIN FAILED, EXIT\n*\n*        Skip data set if not a 100% pure PDS\n*\n         TM    DS1DSORG+0,DS1DSGPO     CHECK THAT DSORG=PO\n         BNO   MSG28B                  EXIT IF DSORG IS NOT PO\n         TM    DS1SMSFG,DS1PDSE        IS THIS A PDSE?            @PDSE\n         BO    MSG28E                  YES, DO NOT PROCESS        @PDSE\n         MVC   RECFM,DS1RECFM          KEEP RECFM FOR LATER USE\n         CLI   MODE,C'S'               CHECK MODE\n         BE    ALLOC000                JUMP IF MODE=SINGLE\n         OC    DS1EXPDT,DS1EXPDT       CHECK NON-ZERO EXPDT\n         BNZ   MSG28C                  NON ZERO EXPDT, JUMP\n*\n*        Skip data set if option \"CHANGED\" is specified\n*        and the \"data set changed\" indicator is off\n*\n         CLI   CHANGED,C'N'            LOOK FOR \"NOCHANGED\" OPTION\n         BE    OBTAIN45                BRANCH IF \"NOCHANGED\"\n         TM    DS1DSIND,DS1DSCHA       CHECK FOR CHANGED BIT\n         BNO   MSG28F                  JUMP IF CHANGED FLAG IS OFF\n*\n*        Skip data set if option \"CHECK\" is specified and the\n*        job name stored by ASM2 is the same as my job's\n*\nOBTAIN45 CLI   CHECK,C'N'              LOOK FOR \"NOCHECK\" OPTION\n         BE    ALLOC000                BRANCH IF \"NOCHECK\"\n         CLI   DS1SYSCD+8,X'FF'        CHECK FOR ASM2 SIGNATURE\n         BNE   ALLOC000                JUMP IF NO ASM2\n         L     R14,ADDRTIOT            GET TIOT ADDRESS\n         CLC   DS1SYSCD(8),0(R14)      CHECK JOB NAME\n         BE    MSG28D                  JUMP IF SAME JOBNAME\n***********************************************************************\n*                                                                     *\n*        ALLOCATE DATA SET TO BE COMPRESSED                           *\n*                                                                     *\n***********************************************************************\nALLOC000 BAL   R14,INIT99RB         <- INITIALIZE SVC99 RB\n         USING S99RB,R3\n         OI    S99FLG11,S99NOCNV       DO NOT USE EXISTING DD\n         OI    S99FLG11,S99NOMNT       DO NOT MOUNT VOLUMES\n         LA    R14,TU55DDN             DDNAME TEXT UNIT\n         MVC   0(6,R14),=AL2(DALRTDDN,1,8)  RETURN DDNAME KEY\n         LA    R15,TU02DSN             DSNAME TEXT UNIT\n         MVC   0(6,R15),=AL2(DALDSNAM,1,44) DSNAME KEY\n         L     R0,STATUS               ADDRESS OF STATUS KEY\n         STM   R14,R0,S99RBEND+00      FIRST TO THIRD TEXT UNIT PTRS\n         LA    R14,TU10VOL             VOLSER TEXT UNIT\n         MVC   0(6,R14),=AL2(DALVLSER,1,6)  VOL SER KEY\n         BAL   R15,ALLOC110         <-\n         DC    AL2(DALUNIT,1,L'ALLOC109)\nALLOC109 DC    C'SYSALLDA',0H'0'\nALLOC110 STM   R14,R15,S99RBEND+12     4TH, 5TH TEXT UNIT PTRS\n         OI    S99RBEND+16,X'80'       END OF LIST\n         LA    R1,DFS99RBP             S99RBPTR\n         DYNALLOC ,                    ISSUE SVC 99 (ALLOCATE)\n         LTR   R15,R15\n         BNZ   MSG99                   ALLOCATION FAILED, EXIT\n         DROP  R3                      WAS S99RB\n         MVC   DDNAME,TU55DDN+6        SAVE RETURNED DDNAME\n         DEVTYPE DDNAME,DEVT1,DEVTAB   GET DEVICE CHARACTERISTICS\n***********************************************************************\n*                                                                     *\n*        ALLOCATE SYSIN AND SYSPRINT DATA SETS.                       *\n*                                                                     *\n***********************************************************************\nALLOC200 CLI   TEMPALL,C'Y'            CHECK DDNAME ALREADY ALLOCATED\n         BE    SYSINOK                 DD ALREADY ALLOCATED, OPEN IT\n         MVI   TEMPALL,C'Y'            SHOW DDNAME ALREADY ALLOCATED\n         BAL   R14,INIT99RB         <- INITIALIZE SVC99 RB\n         USING S99RB,R3\n         LA    R14,ALLOC215            DSNAME=&&SYSIN\n         LA    R15,TU55DDN             DDNAME TEXT UNIT (ALREADY OK)\n         LA    R0,=AL2(DALTRK,0)       SPACE=TRK\n         LA    R1,ALLOC217             SPACE=(TRK,10)\n         BAL   R2,ALLOC210          <-\n         DC    AL2(DALUNIT,1,8),CL8'SYSDA'\nALLOC210 STM   R14,R2,S99RBEND+00      STORE TEXT UNIT PTRS\n         LA    R1,DFS99RBP             S99RBPTR\n         DYNALLOC ,                    ISSUE SVC 99 (ALLOCATE SYSIN)\n         LTR   R15,R15\n         BNZ   ALLOC255                ALLOCATION FAILED, EXIT\n         MVC   IEBDDIN,TU55DDN+6       MOVE SYSIN DDNAME\n         LA    R14,ALLOC216            DSNAME=&&SYSPRINT\n         ST    R14,S99RBEND+00         STORE TEXT UNIT PTR\n         LA    R1,DFS99RBP             S99RBPTR\n         DYNALLOC ,                    ISSUE SVC 99 (ALLOCATE SYSPRINT)\n         LTR   R15,R15\n         BNZ   ALLOC255                ALLOCATION FAILED, EXIT\n         MVC   IEBDDPRT,TU55DDN+6      MOVE SYSPRINT DDNAME\n         B     SYSINOK\nALLOC215 DC    AL2(DALDSNAM,1,6),C'&&SYSIN'\nALLOC216 DC    AL2(DALDSNAM,1,9),C'&&SYSPRINT'\nALLOC217 DC    AL2(DALPRIME,1,3),AL3(10)           SPACE=(TRK,10)\n         DROP  R3                      WAS S99RB\nALLOC255 ST    R15,MAXCC               RC=8\n         BAL   R14,DAIRFAIL         <- Issue dynalloc error message\n         B     FINISH                  exit\n***********************************************************************\n*                                                                     *\n*        WRITE SYSIN FILE AND BUILD PARAMETER LIST FOR IEBCOPY.       *\n*                                                                     *\n***********************************************************************\nSYSINOK  EQU   *\n         USING IHADCB,DYNAMDCB\n         MVC   IHADCB(DCBLEN),MODELDCB MOVE MODEL DCB\n         MVC   DCBDDNAM,IEBDDIN        MOVE SYSIN DDNAME\n         MVI   DCBRECFM,DCBRECF        RECFM=F\n ORG *-4                                                 PDSMAN/PM74127\n         MVI   DCBRECFM,DCBRECF+DCBRECBR RECFM=FB        PDSMAN/PM74127\n         MVC   DCBLRECL,=H'80'         LRECL=80          PDSMAN/PM74127\n         MVC   DCBBLKSI,=H'80'         BLKSIZE=80\n         MVI   DCBBUFNO,01             BUFNO=1\n         LA    R0,IHADCB               BUILD OPEN LIST\n         ST    R0,OPENLIST             BUILD OPEN LIST\n         MVI   OPENLIST,X'8F'          OPEN MODE IS OUTPUT\n         OPEN  MF=(E,OPENLIST)         OPEN IEBSYSIN\n         LTR   R15,R15                 CHECK OPEN OK\n         BNZ   FINISH                  OPEN FAILED, EXIT\n         PUT   IHADCB                  LOCATE OUTPUT RECORD\n         STRING ' COPY I=',(DDNAME,,T),',O=',(DDNAME,,T),',LIST=NO',   X\n               INTO=((R1),80)\n         CLOSE MF=(E,OPENLIST)         CLOSE IEBSYSIN\n         FREEPOOL IHADCB               FREE BUFFERS\n***********************************************************************\n*                                                                     *\n*        SCAN TIOT TO GET UCB ADDRESS.                                *\n*                                                                     *\n***********************************************************************\nENQ      SLR   R0,R0                   WORK REGISTER\n         L     R1,ADDRTIOT             GET TIOT ADDRESS\n         USING TIOT1,R1\nENQ015   AR    R1,R0                   BUMP UP TO NEXT ENTRY\n         IC    R0,TIOELNGH             LENGTH OF CURRENT ENTRY\n         CLC   DDNAME,TIOEDDNM         SAME DDNAME?\n         BNE   ENQ015                  LOOP THROUGH TIOT\n         ICM   R0,B'0111',TIOEFSRT     GET 24-BIT UCB ADDRESS\n         ST    R0,ADDRUCB              STORE UCB ADDRESS FOR RESERVE\n         DROP  R1                      WAS TIOT1\n***********************************************************************\n*        ENQ/RESERVE WITH ISPF/HEWL CONVENTIONS                       *\n***********************************************************************\n         MVC   DYNENQL(16),ENQMODEL    MOVE PATTERN ENQ LIST\n         TM    RECFM,DS1RECFU          CHECK RECFM\n         BO    ENQLKED                 RECFM=U, ASSUME LOAD LIBRARY\n         RESERVE (SPFEDIT,DSNAME,E,44,SYSTEMS),UCB=ADDRUCB,            X\n               MF=(E,DYNENQL)\n         B     ENQDONE                 ENQ DONE FOR RECFM=F/V\nSPFEDIT  DC    C'SPFEDIT '             QNAME FOR ISPF V2 ENQUEUES\nSYSLMOD  DC    C'SYSIEWLP'             QNAME FOR LINK-EDIT\nENQLKED  L     R1,ADDRUCB              LOAD UCB ADDRESS\n         TM    UCBTBYT2-UCBOB(R1),UCBRR SHARED DASD?\n         BO    ENQLKEDR                IF SHARED, DO A RESERVE\n         ENQ   (SYSLMOD,DSNAME,E,44,SYSTEM),MF=(E,DYNENQL)\n         B     ENQDONE\nENQLKEDR RESERVE (SYSLMOD,DSNAME,E,44,SYSTEMS),UCB=ADDRUCB,            X\n               MF=(E,DYNENQL)\nENQDONE  EQU   *\n*\n*        Re-read the F1-DSCB in case ENQ/RESERVE had to wait\n*\n         L     R14,CAML28F1            CAMLST 1ST WORD\n         LA    R15,DSNAME              DATA SET NAME\n         LA    R0,VOLSER               VOL SERIAL\n         LA    R1,DS1FMTID             FORMAT-1\n         STM   R14,R1,EFTPARM          STORE RELOCATED CAMLST\n         OBTAIN EFTPARM                RE-READ F1-DSCB\n***********************************************************************\n*                                                                     *\n*        CALL IEBCOPY VIA IKJEFTSR                                    *\n*                                                                     *\n*        If RECFM=U and LLAREFRESH is specified, COMPRCMD does NOT    *\n*        invoke IEBCOPY; instead, it re-invokes itself via the TSR to *\n*        execute the LLACOPY section, from which IEBCOPY is executed. *\n*                                                                     *\n***********************************************************************\nTSR11    EQU   *\n         MVI   IEBDD+1,IEBDDLEN        DDNAME LIST LENGTH\n         LA    R0,=H'0'                IEBCOPY PARM\n         LA    R1,IEBDD                DDN LIST\n         STM   R0,R1,IEBPARM           BUILD PARAMETER LIST\n         OI    IEBPARM+04,X'80'        MARK END OF LIST\n*\n*        BUILD PARM LIST FOR THE TSO/E SERVICE ROUTINE (IKJEFTSR)\n*\n         LA    R14,=X'0000,0102'       FLAGS\n         LA    R15,IEBCOPY             PGM=IEBCOPY\n         TM    RECFM,DS1RECFU          RECFM=U ?\n         BNO   TSR23                   no, call IEBCOPY\n         L     R1,DYNANSWR             LOAD PDL ADDRESS\n         CLI   STATPCE+1-IKJPARMD(R1),3 LLAREFRESH option specified?\n         BNE   TSR23                   no, call IEBCOPY\n         LA    R15,OWNNAME             PGM=COMPRESS\nTSR23    EQU   *\n         LA    R0,=F'8'                LENGTH OF COMMAND BUFFER\n         LA    R1,RETCODE              RETURN CODE\n         LA    R2,RSNCODE              REASON CODE\n         LA    R3,ABNDCODE             ABEND CODE\n         LA    R4,IEBPARM              IEBCOPY PARM\n         STM   R14,R4,EFTPARM          build parm list\n         OI    EFTPARM+24,X'80'        END OF LIST\n*\n         STTMPMD ON,KEYS=ALL           TRAP CLEAR AND PA1 KEYS\n         LA    R1,EFTPARM              PARM FOR IKFEFTSR\n         L     R15,CVTPTR(,0)          ADDR OF CVT\n         L     R15,CVTTVT-CVTMAP(,R15) ADDR OF TSVT\n         L     R15,TSVTASF-TSVT(,R15)  ADDR OF IKJEFTSR/TSOLNK\n         SYNCH (R15)                <- CALL THE TSO SERVICE ROUTINE\n         LTR   R15,R15                 CHECK RETURN CODE\n         BZ    DEQUEUE                 NOT HIGHER, JUMP\n         MVI   PRINTMSG,C'Y'           PRINT IEBCOPY MESSAGES\n         CLC   MAXCC,RETCODE           HIGHEST SO FAR?\n         BH    DEQUEUE                 MAXCC HIGHER, JUMP\n         MVC   MAXCC,RETCODE           KEEP MAXCC\nDEQUEUE  DEQ   MF=(E,DYNENQL)          DEQ/RELEASE\n         STTMPMD OFF                   ALLOW CLEAR AND PA1 KEYS AGAIN\n         ICM   R15,B'1111',RETCODE     RC=0 from TSR ?\n         BZ    TSR99                   YES, JUMP\n**        STRING 'MSG009 COMPRESS is not authorised, option LLAREFRESH X\n               is ignored.',INTO=MESSAGE\n         STRING  'MSG009 Error during processing of LLAREFRESH option, X\n               RC=',(RETCODE,F,L),', RSN=',(RSNCODE,,X),               X\n               INTO=MESSAGE\n         L     R1,DYNANSWR             LOAD PDL ADDRESS\n         MVI   STATPCE+1-IKJPARMD(R1),1 Change LLAREFRESH to SHR\n         BAL   R14,PUTLINE          <- write message\nTSR99    EQU   *\n***********************************************************************\n*        Free the PDS that has just been compressed                   *\n***********************************************************************\n         BAL   R14,INIT99RB         <- INITIALIZE SVC99 RB\n         USING S99RB,R3\n         MVI   S99VERB,S99VRBUN        VERB IS \"UNALLOCATE\"\n         LA    R14,TU55DDN             DDNAME TEXT UNIT\n         MVC   0(6,R14),=AL2(DUNDDNAM,1,8)  DDNAME KEY\n         MVC   6(8,R14),DDNAME         DDNAME\n         ST    R14,S99RBEND+00         1ST & ONLY TEXT UNIT PTR\n         OI    S99RBEND+00,X'80'       END OF LIST\n         LA    R1,DFS99RBP             S99RBPTR\n         DYNALLOC ,                    ISSUE SVC 99 (FREE PDS)\n         DROP  R3                      WAS S99RB\n***********************************************************************\n*        COMPUTE PERCENTAGE OF SPACE USED AFTER COMPRESSION           *\n***********************************************************************\n         OC    RETCODE,RETCODE         CHECK IEBCOPY RETURN CODE\n         BNZ   MSG08                   JUMP IF RC=00\n         SLR   R1,R1                   make it relative to zero\n         ICM   R1,B'0011',DS1LSTAR     last track used (relative to 0)\n         LA    R2,1(,R1)               number of tracks used (before)\nUSED00   L     R14,CAML28F1            CAMLST 1ST WORD\n         LA    R15,DSNAME              DATA SET NAME\n         LA    R0,VOLSER               VOL SERIAL\n         LA    R1,DS1FMTID             FORMAT-1\n         STM   R14,R1,EFTPARM          STORE RELOCATED CAMLST\n         OBTAIN EFTPARM                READ F1-DSCB\n         LTR   R15,R15                 CHECK FOR SUCCESSFUL COMPLETION\n         BNZ   USED99                  OBTAIN FAILED, EXIT\n         SLR   R1,R1                   make it relative to zero\n         ICM   R1,B'0011',DS1LSTAR     last track used (relative to 0)\n         LA    R1,1(,R1)               number of tracks used\n         STM   R1,R2,TRKSUSED          tracks used (after,before)\n         SLR   R3,R3                   PREPARE IC\n         IC    R3,DS1NOEPV             NUMBER OF EXTENTS\n         LA    R4,DS1EXT1              ADDR OF 1ST EXTENT DESCRIPTOR\n         SLR   R5,R5                   TRACK COUNTER\nUSED20   LA    R0,DS1EXT3+L'DS1EXT3    ADDR OF 3RD EXTENT DESCRIPTOR\n         CR    R4,R0\n         BNE   USED40                  JUMP IF NOT END OF F1-DSCB\nUSED30   L     R14,CAML28F3            CAMLST 1ST WORD\n         LA    R15,DS1PTRDS            PTR TO F3-DSCB\n         LA    R0,VOLSER               VOL SERIAL\n         LA    R1,IECSDSL3             FORMAT-3\n         STM   R14,R1,EFTPARM          STORE RELOCATED CAMLST\n         OBTAIN EFTPARM                READ F1-DSCB\n         LTR   R15,R15                 CHECK FOR SUCCESSFUL COMPLETION\n         BNZ   USED99                  OBTAIN FAILED, EXIT\n         LA    R4,DS3EXTNT             FIRST 4 EXTENTS OF F3-DSCB\n         B     USED50                  GO PROCESS IT\nUSED40   LA    R0,DS3FMTID             1ST EXTENT DESC IN F3-DSCB\n         CR    R4,R0\n         BNE   USED50                  JUMP IF FIRST 4 DESC PROC'D\n         LA    R4,DS3ADEXT             9 ADDITIONAL EXTENTS OF F3-DSCB\nUSED50   SLR   R0,R0\n         ICM   R0,B'0011',2(R4)        GET START CYL\n         MH    R0,DEVT1+10             NUMBER OF TRKS PER CYL\n         AH    R0,4(,R4)               ADD START TRACK\n         SLR   R1,R1\n         ICM   R1,B'0011',6(R4)        GET END CYL\n         MH    R1,DEVT1+10             NUMBER OF TRKS PER CYL\n         AH    R1,8(,R4)               END TRACK\n         LA    R1,1(,R1)               END TRK +1\n         SLR   R1,R0                   number of tracks in this extent\n         LR    R0,R5                   save first track number\n         ALR   R5,R1                   tally allocated tracks\n         CL    R0,TRKSUSED             EOF IN THIS EXTENT?\n         BNL   USED57                  NO, JUMP\n         CL    R5,TRKSUSED             EOF IN THIS EXTENT?\n         BL    USED57                  NO, JUMP\n         LA    R0,1                    increment\n         AH    R0,0(,R4)               current extent number\n         STC   R0,XTNTUSED             SAVE NUMBER OF LAST EXTENT USED\nUSED57   LA    R4,L'DS1EXT1(,R4)       NEXT EXTENT DESC\n         BCT   R3,USED20               LOOP UNTIL ALL EXTENTS PROCESSED\nUSED90   SLR   R0,R0                   PREPARE DR\n         LA    R1,1                    PREPARE AH\n         AH    R1,DS1LSTAR+0           LAST TT USED\n         MH    R1,=H'100'              PREPARE PERCENTAGE CALC\n         DR    R0,R5                   PCT=(USED*100)/TOTAL\n         LTR   R1,R1                   0% ==> 1%\n         BNZ   *+8                     0% ==> 1%\n         LA    R1,1                    0% ==> 1%\n         ST    R1,RETCODE              PERCENTAGE FOR MSG00\nUSED99   STRING 'MSG000 COMPRESS successful for ',(DSNAME,,T),         X\n               ', now ',(RETCODE,F,L),'% full.',INTO=MESSAGE\n***********************************************************************\n*        check if we're running under ISPF in \"single\" mode           *\n***********************************************************************\n         ICM   R15,B'1111',=A(ISPQRY)  ISPQRY AVAILABLE?\n         BZ    ISSUEMSG                NO, QUIT\n         BALR  R14,R15              <- CALL ISPQRY\n         LTR   R15,R15                 ISPF SERVICES AVAILABLE?\n         BNZ   ISSUEMSG                NO, QUIT\n         CLI   MODE,C'S'               MODE=SINGLE?\n         BNE   ISSUEMSG                NO, QUIT\n***********************************************************************\n*        REFRESH DISPLAY WHEN INVOKED FROM PDF 3.4 PANEL              *\n***********************************************************************\n*        ISPLINK VREPLACE ZDLREF Y\nZDLREF10 LA    R14,=C'VREPLACE'        SERVICE\n         LA    R15,=C'ZDLREF  '        VARIABLE NAME\n         LA    R0,=F'1'                VALUE LENGTH\n         LA    R1,=C'Y'                ADDR OF VARIABLE VALUE\n         STM   R14,R1,EFTPARM          STORE PARM LIST\n         OI    EFTPARM+12,X'80'        MARK END OF LIST\n         L     R15,=A(ISPLINK)         ISPF SERVICES\n         LA    R1,EFTPARM              PARM LIST ADDRESS\n         BALR  R14,R15              <- ISSUE VREPLACE\n         LTR   R15,R15                 WENT OK?\n         BNZ   ZDLREF99                NO, QUIT\n*        ISPLINK VPUT (ZDLREF)\nZDLREF20 LA    R14,=C'VPUT'            SERVICE\n         LA    R15,=C'ZDLREF  '        VARIABLE NAME\n         STM   R14,R15,EFTPARM         STORE PARM LIST\n         OI    EFTPARM+04,X'80'        MARK END OF LIST\n         L     R15,=A(ISPLINK)         ISPF SERVICES\n         LA    R1,EFTPARM              PARM LIST ADDRESS\n         BALR  R14,R15              <- ISSUE VPUT\nZDLREF99 EQU   *\n***********************************************************************\n*        SETMSG function                                              *\n***********************************************************************\nSETMSG00 CLI   SETMSG,C'Y'             SETMSG option specified?\n         BNE   SETMSG99                no, exit\n*        ISPLINK VREPLACE ZMSG000S\nSETMSG10 STRING 'Now ',(RETCODE,F,L),'% full',INTO=MESSAGE\n         ST    R15,LENGTH              no, exit\n         LA    R14,=C'VREPLACE'        SERVICE\n         LA    R15,=C'ZMSG000S'        VARIABLE NAME\n         LA    R0,LENGTH               VALUE LENGTH\n         LA    R1,MESSAGE              VALUE\n         STM   R14,R1,EFTPARM          STORE PARM LIST\n         OI    EFTPARM+12,X'80'        MARK END OF LIST\n         L     R15,=A(ISPLINK)         ISPF SERVICES\n         LA    R1,EFTPARM              PARM LIST ADDRESS\n         BALR  R14,R15              <- ISSUE VREPLACE\n         LTR   R15,R15                 WENT OK?\n         BNZ   SETMSG99                NO, QUIT\n*        ISPLINK VREPLACE ZMSG000S\nSETMSG20 LM    R1,R2,TRKSUSED          tracks used (after,before)\n         SLR   R2,R1                   R2=tracks recovered by IEBCOPY\n         STRING (DSNAME,,T),' successfully compressed',                X\n               ', tracks_recovered=',((R2),,L),'.',                    X\n               ' Total_tracks=',((R5),,L),                             X\n               ',Tracks_used=',(TRKSUSED,F,L),                         X\n               ',Total_extents=',(DS1NOEPV,FL1,L),                     X\n               ',Extents_used=',(XTNTUSED,FL1,L),                      X\n               INTO=WK265\n         CLI   VOLGIVEN,C'Y'           CHECK IF VOLSER WAS SUPPLIED\n         BNE   SETMSG25                NO, JUMP\n         STRING (DSNAME,,T),' successfully compressed',                X\n               ' on vol(',VOLSER,')',                                  X\n               ', tracks_recovered=',((R2),,L),'.',                    X\n               ' Total_tracks=',((R5),,L),                             X\n               ',Tracks_used=',(TRKSUSED,F,L),                         X\n               ',Total_extents=',(DS1NOEPV,FL1,L),                     X\n               ',Extents_used=',(XTNTUSED,FL1,L),                      X\n               INTO=WK265\nSETMSG25 EQU   *\n         ST    R15,LENGTH              no, exit\n         LA    R14,=C'VREPLACE'        SERVICE\n         LA    R15,=C'ZMSG000L'        VARIABLE NAME\n         LA    R0,LENGTH               VALUE LENGTH\n         LA    R1,WK265                VALUE\n         STM   R14,R1,EFTPARM          STORE PARM LIST\n         OI    EFTPARM+12,X'80'        MARK END OF LIST\n         L     R15,=A(ISPLINK)         ISPF SERVICES\n         LA    R1,EFTPARM              PARM LIST ADDRESS\n         BALR  R14,R15              <- ISSUE VREPLACE\n         LTR   R15,R15                 WENT OK?\n         BNZ   SETMSG99                NO, QUIT\n*        ISPLINK SETMSG(ISPZ000)\nSETMSG80 LA    R14,=C'SETMSG'          SERVICE\n         LA    R15,=C'ISPZ000 '        VARIABLE NAME\n         STM   R14,R1,EFTPARM          STORE PARM LIST\n         OI    EFTPARM+04,X'80'        MARK END OF LIST\n         L     R15,=A(ISPLINK)         ISPF SERVICES\n         LA    R1,EFTPARM              PARM LIST ADDRESS\n         BALR  R14,R15              <- ISSUE VREPLACE\n         LTR   R15,R15                 WENT OK?\n         BZ    FINISH                  YES, EXIT\nSETMSG99 EQU   *\n         B     ISSUEMSG                VREPLACE/SETMSG failed\n***********************************************************************\n*        ISSUE MESSAGES                                               *\n***********************************************************************\nMSG08    STRING 'MSG008 COMPRESS failed for ',(DSNAME,,T),             X\n               ', IEBCOPY return code is ',(RETCODE,F,L),'.',          X\n               INTO=MESSAGE\n         B     ISSUEMSG                ISSUE MESSAGE\nMSG26    ST    R15,RETCODE             RETURN CODE\n         STRING 'MSG26 LOCATE failed for ',(DSNAME,,T),                X\n               ', return code is ',(RETCODE,F,L),'.',                  X\n               INTO=MESSAGE\n         B     CHECKSNG                ISSUE MESSAGE IF MODE=SINGLE\nMSG26B   STRING 'MSG26B ',(DSNAME,,T),' is not a disk data set.',      X\n               INTO=MESSAGE\n         B     CHECKSNG                ISSUE MESSAGE IF MODE=SINGLE\nMSG26C   STRING 'MSG26C ',(DSNAME,,T),' is a migrated data set.',      X\n               INTO=MESSAGE\n         B     CHECKSNG                ISSUE MESSAGE IF MODE=SINGLE\nMSG28    ST    R15,RETCODE             RETURN CODE\n         STRING 'MSG28 OBTAIN failed for ',(DSNAME,,T),' on volume(',  X\n               VOLSER,'), return code is ',(RETCODE,F,L),'.',          X\n               INTO=MESSAGE\n         B     CHECKSNG                ISSUE MESSAGE IF MODE=SINGLE\nMSG28B  STRING 'MSG28B ',(DSNAME,,T),' is not a partitioned data set.',X\n               INTO=MESSAGE\n         B     CHECKSNG                ISSUE MESSAGE IF MODE=SINGLE\nMSG28C   STRING 'MSG28C COMPRESS bypassed for ',(DSNAME,,T),           X\n               ', EXPDT is non-zero.',INTO=MESSAGE\n         B     ISSUEMSG                ISSUE MESSAGE\nMSG28D   STRING 'MSG28D COMPRESS bypassed for ',(DSNAME,,T),           X\n               ', same ASM2ID.',INTO=MESSAGE\n         B     ISSUEMSG                ISSUE MESSAGE\nMSG28E   STRING 'MSG28E ',(DSNAME,,T),' is a PDSE.',INTO=MESSAGE\n         B     ISSUEMSG                ISSUE MESSAGE              @PDSE\nMSG28F   STRING 'MSG28F COMPRESS bypassed for ',(DSNAME,,T),           X\n               ', data set changed indicator off.',                    X\n               INTO=MESSAGE\n         B     ISSUEMSG                ISSUE MESSAGE\nMSG99    ST    R15,MAXCC               DYNALLOC Return Code\n         BAL   R14,DAIRFAIL         <- issue dynalloc error message\n****     STRING 'MSG99 DYNALLOC FAILED FOR ',(DSNAME,,T),              X\n               ', return code is ',(RETCODE,F,L),'.',                  X\n               INTO=MESSAGE\n****     B     ISSUEMSG                ISSUE MESSAGE\n         B     FINISH                  EXIT (DAIRFAIL issued message)\nCHECKSNG CLI   MODE,C'S'               CHECK MODE\n         BNE   PRINT000                JUMP IF MODE \u00ac= SINGLE\n         MVI   MAXCC+L'MAXCC-1,08      RETURN CODE = 08\nISSUEMSG BAL   R14,PUTLINE          <- write message\n***********************************************************************\n*        READ IEBCOPY SYSPRINT IF THERE IS AN ERROR                   *\n***********************************************************************\nPRINT000 CLI   PRINTMSG,C'Y'           CHECK IEBCOPY ERRORS\n         BNE   NEXTDSN                 JUMP IF RETCODE IS ZERO\n         MVC   IHADCB(DCBLEN),MODELDCB MOVE MODEL DCB\n         MVC   DCBDDNAM,IEBDDPRT       MOVE SYSPRINT DDNAME\n         LA    R0,PRINT090             EODAD ROUTINE\n         ST    R0,DCBEODAD             STORE IT INTO DCB\n         MVI   OPENLIST,X'80'          OPEN MODE IS INPUT\n         OPEN  MF=(E,OPENLIST)         OPEN SYSPRINT\n         LTR   R15,R15                 CHECK OPEN OK\n         BNZ   FINISH                  OPEN FAILED, EXIT\nPRINT040 GET   IHADCB                  LOCATE INPUT RECORD\n         CLI   0(R1),C'1'              CHECK CONTROL CHARACTER\n         BE    PRINT040                IGNORE TITLE LINE\n         STRING 'MSG062 ',(1(R1),120),INTO=MESSAGE\n         BAL   R14,PUTLINE          <- write message\n         B     PRINT040                LOOP UNTIL EODAD IS REACHED\nPRINT090 CLOSE MF=(E,OPENLIST)         CLOSE SYSPRINT\n         FREEPOOL IHADCB               FREE BUFFERS\n***********************************************************************\n*        GET READY TO PROCESS NEXT DSNAME IN TABLE.                   *\n***********************************************************************\nNEXTDSN  EQU   *\n         CLI   ATTNFLAG,C'Y'           ATTENTION RECEIVED?\n         BE    FINISH                  EXIT IF ATTENTION RECEIVED\n         L     R2,ADDRCOMM             ECB/CIB POINTERS\n         LM    R1,R2,0(R2)             PICK UP ECB/CIB ADDRESSES\n         TM    0(R1),X'40'             COMM ECB POSTED?\n         BNO   NEXTDSN4                NO, CONTINUE\n         CLI   CIBVERB-CIB(R2),CIBSTOP STOP COMMAND ENTERED?\n         BNE   NEXTDSN4                NO, CONTINUE\n         STRING 'MSG60 COMPRESS terminated, STOP command received.',   X\n               INTO=MESSAGE\n         BAL   R14,PUTLINE          <- write message\n         LA    R15,20                  RETURN CODE\n         ST    R15,RETCODE             RETURN CODE\n         B     FINISH                  EXIT IF STOP RECEIVED\n*\n*        next dsname in catalog work area\n*\nNEXTDSN4 EQU   *\n         CLI   MODE,C'S'               MODE=SINGLE?\n         BE    NEXTDSN5                YES, JUMP\n         LA    R14,45                  LENGTH OF AN ENTRY\n         L     R15,CTGWKA              WORK AREA ADDRESS\n         A     R15,4(,R15)             POINT TO END OF WORK AREA\n         BCTR  R15,0\n         BXLE  R8,R14,PROCESS          PROCESS ANOTHER DATA SET\n*--ENDLOOP\n*\n*        next dsname in command\n*\nNEXTDSN5 EQU   *\n         ICM   R7,B'1111',PCE7NEXT     GET ADDRESS OF NEXT DSNAME\n         BP    GETDSN                  NEXT DSNAME IN LIST\n*ENDLOOP\n         B     FINISH                  CLEAN-UP, RETURN\n         DROP  R7                      PCE7\n*\nATTNEXIT MVI   ATTNFLAG,C'1'           SHOW ATTENTION KEY PRESSED\n         BR    R14\n***********************************************************************\n*                                                                     *\n*        LLACOPY - re-entry from the TSR with AC=1                    *\n*                                                                     *\n***********************************************************************\nLLACOPY  EQU   *\n         TESTAUTH FCTN=1               CHECK AUTHORISATION\n         LTR   R15,R15                 Am I authorised?\n         BNZ   LLACOPY9                no, error\n*\n         MVC   IHADCB(DCBLEN),MODELDCB MOVE MODEL DCB\n         MVI   DCBDSORG,DCBDSGPO       DSORG=PO\n         MVI   DCBMACR1,DCBMRRD        MACRF=R\n         MVI   DCBMACR2,0              MACRF=R\n         L     R1,CPPL+4               A(IEBDD)\n         MVC   DCBDDNAM,DDNAME-IEBDD(R1) move DDNAME to DCB\n         MVI   DCBRECFM,DCBRECU        RECFM=U\n         MVC   DCBBLKSI,=H'256'        BLKSIZE=256\n*\n         LA    R1,CPPL                 A(IEBPARM,IEBDD)\n         LINK  EPLOC=IEBCOPY        <- call IEBCOPY (PARM in R1)\n         LTR   R15,R15                 IEBCOPY OK?\n***      BNZ   LLACOPY899              IEBCOPY OK?\n*\n         LA    R1,IHADCB               DCB ADDR\n         ST    R1,OPENLIST             Build OPEN List\n         MVI   OPENLIST,X'80'          OPEN INPUT\n         OPEN  MF=(E,OPENLIST)         OPEN DIRECTORY\n         LTR   R15,R15                 CHECK OPEN OK\n         BNZ   LLACOPY9                OPEN FAILED, EXIT\n         MODESET MODE=SUP              MODE=SUP for LLACOPY\n*LOOP\nLLACOPY2 READ  DECB1,SF,IHADCB,WK265,'S',MF=E\n         CHECK DECB1\n         LA    R3,WK265+2              1ST ENTRY\n*--LOOP\nLLACOPY4 CLI   0(R3),X'FF'             END OF DIRECTORY?\n         BE    LLACOPY7                YES, LEAVE\n         MVC   BLDLAREA(4),=Y(1,62)    number,length\n         MVC   BLDLAREA+4(8),0(R3)     MEMBER NAME\n         LLACOPY DCB=IHADCB,                                           X\n               BLDLLIST=BLDLAREA,                                      X\n               MF=(E,LLACOPYL)\n***      LR    R3,R15                  SAVE RETURN CODE\n         IC    R14,11(,R3)             \"C\" BYTE\n         N     R14,=F'31'              NUMBER OF HALFWORDS\n         LA    R14,12(R14,R14)         ENTRY LENGTH IN R14\n         LH    R15,WK265               LENGTH USED IN DIR BLOCK\n         LA    R15,WK265-1(R15)        END OF DIR BLOCK\n         BXLE  R3,R14,LLACOPY4\n*--ENDLOOP\n         B     LLACOPY2                next directory block\n*ENDLOOP\nLLACOPY7 EQU   *\n         MODESET MODE=PROB             Back to MODE=PROB\n         CLOSE MF=(E,OPENLIST)         CLOSE DIRECTORY\n         FREEPOOL IHADCB               FREE BUFFERS\n         B     FINISH2                 Goback to TSR\nLLACOPY9 EQU   *\n**        STRING 'MSG009 COMPRESS is not authorised in AUTHTSR, option X\n               LLAREFRESH is ignored.',INTO=MESSAGE\n**       BAL   R14,PUTLINE          <- write message\n         MVI   MAXCC+L'MAXCC-1,16      RETURN CODE = 16\n         B     FINISH2                 Goback to TSR\nIEBCOPY  DC    CL8'IEBCOPY'            PGM NAME\n***********************************************************************\n*        CLEAN UP, RETURN.                                            *\n***********************************************************************\nMSGGETM  STRING 'MSG63 GETMAIN failed, increase region.',INTO=MESSAGE\n         BAL   R14,PUTLINE          <- write message\n         MVI   MAXCC+L'MAXCC-1,20      RETURN CODE = 20\nFINISH   EQU   *\n         IKJRLSA DYNANSWR              RELEASE PDL\n         ICM   R1,B'1111',CTGWKA       WORK AREA ADDRESS\n         BZ    FINISH2                 JUMP IF NOT ALREADY GOTTEN\n         L     R0,0(,R1)               WORK AREA LENGTH\n         FREEMAIN RU,LV=(0),A=(1)      FREE GENERIC LOCATE WORK AREA\nFINISH2  EQU   *\n         LA    R0,DYNAML               GET LENGTH OF DYNAMIC AREA\n         LR    R1,R13                  ADDRESS OF DYNAMIC AREA\n         L     R2,MAXCC                HIGHEST IEBCOPY RETURN CODE\n         L     R13,4(,R13)             CALLER'S SAVE AREA\n         FREEMAIN RU,LV=(0),A=(1)      FREE DYNAMIC STORAGE AREA\n         LR    R15,R2                  PASS RETURN CODE\n         RETURN (14,12),RC=(15)        GOBACK TO CALLER\n***********************************************************************\n*        Write a message using IKJEFF02                               *\n***********************************************************************\nPUTLINE  LA    R0,L'MESSAGE            LENGTH OF INSERT\n         ST    R0,MTLEN+00             LENGTH OF INSERT\n         LA    R0,MESSAGE              RETURN CODE\n         ST    R0,MTADDR+00            ADDRESS OF INSERT\n         MVC   MTMSGID,=C'PRT '        MESSAGE ID\n         L     R15,CVTPTR(,0)          ADDR OF CVT\n         L     R15,CVTEFF02-CVTMAP(,R15) ADDR OF IKJEFF02\n         LA    R1,MTPARML              POINT TO PPL\n         BR    R15                     XCTL to IKJEFF02\n***********************************************************************\n*        INITIALIZE A DYNALLOC REQUEST BLOCK                          *\n***********************************************************************\nINIT99RB LA    R3,WK265                S99RB\n         XC    0(S99RBEND-S99RB,R3),0(R3)  CLEAR DYNALLOC WORK SPACE\n         USING S99RB,R3\n         MVI   S99RBLN,S99RBEND-S99RB  RB LENGTH\n         MVI   S99VERB,S99VRBAL        VERB IS \"ALLOCATE\"\n         LA    R0,S99RBEND             END OF RB, START OF T.U. PTRS\n         ST    R0,S99TXTPP             TEXT UNIT POINTERS\n         ST    R3,DFS99RBP             S99RBPTR\n         OI    DFS99RBP,X'80'          S99RBPND\n         LA    R0,=AL1(0,DFSVC99)      PUTLINE ONLY, SVC99\n         ST    R0,DFIDP                BUILD PARML FOR DAIRFAIL\n         ST    R11,DFCPPLP             ADDR OF CPPL\n         BR    R14\n         DROP  R3                      S99RB\n***********************************************************************\n*        Invoke the DAIRFAIL routine\n***********************************************************************\nDAIRFAIL ST    R15,RETCODE             RETURN CODE\n         LA    R0,RETCODE              RETURN CODE\n         ST    R0,DFRCP                RETURN CODE\n         LA    R0,=A(0)                NO ADDR FOR IKJEFF02\n         ST    R0,DFJEFF02             RETURN CODE\n         LOAD  EP=IKJEFF18             CALL DAIRFAIL\n         LR    R15,R0                  pass EP addr\n         LA    R1,DFPARMS              DAIRFAIL PARM LIST\n         BR    R15                     CALL DAIRFAIL\n***********************************************************************\n*        MODEL CONTROL BLOCKS, MOVED TO DYNAMIC STORAGE               *\n***********************************************************************\nCAML26   CAMLST NAME,*-*,,*-*          CAMLST FOR LOCATE\nCAML28F1 CAMLST SEARCH,*-*,*-*,*-*     CAMLST FOR OBTAIN - F1-DSCB\nCAML28F3 CAMLST SEEK,*-*,*-*,*-*       CAMLST FOR OBTAIN - F3-DSCB\nENQMODEL RESERVE (*-*,*-*,E,44,SYSTEMS),UCB=*-*,MF=L\nMODELDCB DCB   DSORG=PS,MACRF=(GL,PL)\nDCBLEN   EQU   *-MODELDCB\n***********************************************************************\n*        DEFINE MESSAGES TO BE ISSUED VIA IKJEFF02                    *\n***********************************************************************\nMSGCSECT IKJTSMSG (,),PRT\n         IKJTSMSG\n***********************************************************************\n*        DEFINE INPUT PARAMETERS FOR IKJPARS                          *\n***********************************************************************\nPCLCSECT IKJPARM\nDSNPCE   IKJPOSIT DSTHING,USID,LIST,PROMPT='DATA SET NAME'\nCHKPCE   IKJKEYWD\n         IKJNAME 'CHECK'\n         IKJNAME 'NOCHECK'\nCHNGPCE  IKJKEYWD\n         IKJNAME 'CHANGED'\n         IKJNAME 'NOCHANGED'\nSTATPCE  IKJKEYWD DEFAULT='SHR'\n         IKJNAME 'SHR'                 1\n         IKJNAME 'OLD'                 2\n         IKJNAME 'LLAREFRESH'          3\nSETMPCE  IKJKEYWD\n         IKJNAME 'SETMSG'\nVOLPCE   IKJKEYWD\n         IKJNAME 'VOLUME',SUBFLD=VOLSUBF,ALIAS='VOLSER'\nVOLSUBF  IKJSUBF\nVOLPCE2  IKJIDENT 'VOLUME',MAXLNTH=6,FIRST=ALPHANUM,OTHER=ALPHANUM\n         IKJENDP\n***********************************************************************\n*        DYNAMIC STORAGE AREA                                         *\n***********************************************************************\nDYNAM    DSECT\n         DS    18F                     SAVE AREA\nDYN_CPPL DS    4F                      CPPL\nOWNNAME  DS    CL8'COMPRESS'           own name from CDNAME\nMAXCC    DS    F                       MAX RETURN CODE FROM IKJEFTSR\nATTNFLAG DS    C                       ATTENTION KEY PRESSED\nRECFM    DS    C                       RECFM F/V/U\nTEMPALL  DS    C                       TEMPORARY FILES ALLOCATED\nMODE     DS    C                       SINGLE, CATALOG, VTOC\nVOLGIVEN DS    C                       'Y' IF VOL PARAM SPECIFIED\nCHECK    DS    C                       Y/N MEANS CHECK/NOCHECK\nCHANGED  DS    C                       Y/N MEANS CHANGED/NOCHANGED\nSETMSG   DS    C                       Y/N MEANS SETMSG\nPRINTMSG DS    C                       'Y' TO PRINT IEBCOPY MESSAGES\nRETCODE  DS    F                       RETURN CODE FROM IKJEFTSR\nRSNCODE  DS    F                       REASON CODE FROM IKJEFTSR\nABNDCODE DS    F                       ABEND CODE FROM IKJEFTSR\nIEBPARM  DS    A(*-*,IEBDD)            PARM LIST FOR IEBCOPY\nIEBDD    DS    Y(IEBDDLEN)\n         DS    C'SYSLIN  '           1 SYSLIN\n         DS    XL8'00'               2 N/A\n         DS    XL8'00'               3 N/A\n         DS    C'SYSLIB  '           4 SYSLIB\nIEBDDIN  DS    C'SYSIN   '           5 SYSIN\nIEBDDPRT DS    C'SYSPRINT'           6 SYSPRINT\n         DS    C'SYSPUNCH'           7 SYSPUNCH\nIEBDDUT1 DS    C'SYSUT1  '           8 SYSUT1\nIEBDDUT2 DS    C'SYSUT2  '           9 SYSUT2\n         DS    C'SYSUT3  '          10 SYSUT3\n         DS    C'SYSUT4  '          11 SYSUT4\nIEBDDLEN EQU   *-(IEBDD+2)\nDYNENQL  RESERVE (SYSLMOD,DSNAME,E,44,SYSTEMS),UCB=0,MF=L\nDYNANSWR DS    F                       ANSWER AREA FOR PARSE\nDYNUWA   DS    4F                      USER WORK AREA FOR PARSE\nDYNPPL   DS    8F                      PPL FOR USE WITH PARSE\nDYNECB   DS    F                       ECB FOR USE WITH PARSE\nSTATUS   DS    A                       STATUS KEY, SHR OR OLD\nDSNPCE7  DS    A(PCE7)                 CURRENT DSNAME PCE\nOPENLIST OPEN  IHADCB,MF=L             OPEN LIST\nDYNAMDCB DCB   DSORG=PS,MACRF=(GL,PL)\n         READ  DECB1,SF,MF=L\nEXTRACTL EXTRACT ADDRTIOT,FIELDS=TIOT,MF=L\nADDRTIOT DS    A(TIOT)                 TIOT ADDRESS\nADDRCOMM DS    A                       COMM AREA ADDRESS\nADDRUCB  DS    A(UCBOB)                UCB ADDRESS FOR RESERVE\nDEVT1    DS    5F                      DEVICE CHARACTERISTICS\nEFTPARM  DS    8A                      PARM LIST FOR IKJEFTSR\nDDNAME   DS    CL8                     DD NAME\nTU02DSN  DS    AL2(DALDSNAM,1,44)   +0 DATA SET NAME KEY\nDSNAME   DS    CL44                 +6 DATA SET NAME\nTU10VOL  DS    AL2(DALVLSER,1,6)    +0 VOLSER KEY\nVOLSER   DS    CL6                  +6 VOLUME SERIAL\nTU55DDN  DS    AL2(DALRTDDN,1,8),CL8   RETURN DDNAME\nLENGTH   DS    F                       message length\nTRKSUSED DS    F,F                     tracks used (after,before)\nXTNTUSED DS    FL1                     number of extents used\nZDLDSN   DS    CL44                    DSLIST dsname\nZDLVOL   DS    CL6                     DSLIST volser\n*\n         LLACOPY MF=(L,LLACOPYL)\nBLDLAREA DS    Y(1,62),62X             LLACOPY\n*\n         IKJEFFMT MTDSECT=NO,MTFORMAT=NEW\n         IKJEFFDF DFDSECT=NO,DFDSEC2=NO\n*@@      IEZCTGPL DSECT=NO             CATALOG PARAMETER LIST\nCTGPL    DS    0F\nCTGOPTN1 DS    B              FIRST OPTION BYTE:\nCTGNAME  EQU   X'04' .... .1..  CTGENT CONTAINS DSNAME\nCTGGENLD EQU   X'01' .... ...1  GENERIC LOCATE REQUEST\nCTGOPTN2 DS    B              SECOND OPTION BYTE\nCTGOPTN3 DS    B              THIRD OPTION BYTE\nCTGSUPLT EQU   X'10' ...1 ....  SUPERLOCATE FUNCTION\nCTGAM0   EQU   X'01' .... ...1  OS/VS2 CATALOG MANAGMENT REQUEST\nCTGOPTN4 DS    B              FOURTH OPTION BYTE\nCTGENT   DS    A              ADDRESS OF CATALOG RECORD IDENTIFIER\nCTGCAT   DS    A              ADDRESS OF CATALOG DSNAME OR ACB\nCTGWKA   DS    A              ADDRESS OF CALLER'S WORK AREA\nCTGOPTNS DS    B              CATALOG MANAGMENT SERVICES REQUEST OPTION\nCTGF2WKA EQU   X'04' 0000 01..  FORMAT-2 WORK AREA\n         DS    B\nCTGTYPE  DS    C              TYPE OF CATALOG RECORD:\nCTGTALIN EQU   C'A'             NON-VSAM DATA SET\nCTGNOFLD DS    FL1            NUMBER OF ENTRIES IN CTGFIELD\nCTGFDBK  DS    XL2            FEEDBACK AREA\nCTGFBFLG DS    B,B            FLAGS (SUPERLOCATE)\n         DS    2A             UNUSED HERE\nCTGPLLEN EQU   *-CTGPL\nWK265    DS    XL265                   WORK AREA FOR LOCATE\nMESSAGE  DS    CL100                   WORK AREA IKJEFF02\n         ORG   DYNAM+(((*+15-DYNAM)/16)*16)\n         IECSDSL1 (1,3)                FORMAT-1 AND FORMAT-3 DSCB MAPS\n         AIF   (D'DS1SMSFG).SMS2                                  @PDSE\n         ORG   IECSDSL1+X'4E'                                     @PDSE\nDS1SMSFG DS    XL1                 SYSTEM MANAGED STORAGE INDICATORS\nDS1SMSDS EQU   X'80'  1... ....    SYSTEM MANAGED DATA SET\nDS1PDSE  EQU   X'08'  .... 1...    DATA SET IS A PDSE\n         ORG   ,                                                  @PDSE\n.SMS2    ANOP                                                     @PDSE\n         DS    0F\nPGM_CBUF DS    CL256                   CBUF built when called as a pgm\nDYNAML   EQU   *-DYNAM                 LENGTH OF WORK AREA\n*\n*              MACROS FROM SYS1.MACLIB\n*\n         IKJPPL                        PARSE PARAMETER LIST\n         IKJCPPL                       COMMAND PROCESSOR PARM LIST\n         IEFZB4D0                      DYNALLOC REQUEST BLOCK\n         IEFZB4D2                      DYNALLOC TEXT UNIT KEYS\n         DCBD  DSORG=PS,DEVD=DA        DCB DSECT\n         YREGS                         REGISTER EQUATES\n*\n*        PCE7 DSECT (dsname)\n*\nPCE7     DSECT\nPCE7ADDR DS    A                       STRING ADDRESS\nPCE7LEN  DS    H                       STRING LENGTH\n         DS    X                       IKJPARSE FLAGS\nPCE7LEN2 DS    FL1                     len of non-generic part of name\n         ORG   PCE7+24\nPCE7NEXT DS    A(PCE7)                 next PCE7 or zero\n*\n*              MACROS FROM SYS1.MODGEN\n*\nTIOT     DSECT\n         IEFTIOT1                      TIOT DSECT\n*@@@     IEFUCBOB                      UCB DSECT\nUCBOB    DSECT\nUCBTBYT2 EQU   *+17,1                  UCB TYPE BYTE 2\nUCBRR    EQU   X'20'                   RESERVE/RELEASE (SHARED DASD)\nUCBTBYT3 EQU   *+18,1                  UCB TYPE BYTE 3\nUCB3DACC EQU   X'20'                   DASD DEVICE CLASS\nCIB      DSECT\n         IEZCIB                        COMMAND INPUT BUFFER\n         CVT   DSECT=YES,LIST=NO       CVT\n         IKJTSVT                       TSO VECTOR TABLE\n         IKJRB                         PRB\n         IHACDE                        CDE\n         STRING (GENERATE,,LOCTR)\n         END   COMPRESS\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DSN=GILBERT.FILE183.PDS(STRING),DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,5)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//LKED    EXEC PGM=HEWL,PARM=(LIST,MAP,RENT)\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//         DD *\n INCLUDE ISPLOAD(ISPLINK)\n//ISPLOAD  DD DSN=ISP.SISPLOAD,DISP=SHR\n//SYSLMOD  DD DSN=GILBERT.FILE183.LOAD(COMPRESS),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//*\n//GO      EXEC PGM=IKJEFT1B,REGION=2M\n//STEPLIB  DD DSN=*.LKED.SYSLMOD,DISP=SHR\n//SYSTSPRT DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//SYSDEBUG DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//SYSTSIN  DD *\nCALL *(COMPRESS) '''GILBERT.EXEC'''\nCOMPRESS ('GILBERT.EXEC' 'GILBERT.CLIST') NOCHECK\n//\n\n\n/*\n/*        THIS IS THE \"COMPRESS\" EDIT MACRO.   21JAN89\n/*\nISREDIT MACRO (DSN BATCH)\nIF &STR(&DSN) = &STR() OR &STR(&DSN) = BATCH THEN -\n  DO\n    SET BATCH = &STR(&DSN)                   /* SAVE POSSIBLE BATCH OPT\n    ISREDIT (ID1) = DATAID\n    ISPEXEC LMQUERY DATAID(&ID1) DATASET(DSN) VOLUME(VOL) -\n                    PROJECT(PROJECT) GROUP1(GROUP1) TYPE(TYPE)\n    SET DSN     = &DSN                       /* TRUNCATE TRAILING SPACES\n    SET PROJECT = &PROJECT                   /* TRUNCATE TRAILING SPACES\n    SET GROUP1  = &GROUP1                    /* TRUNCATE TRAILING SPACES\n    IF &STR(&DSN) = &STR() THEN -\n      SET DSN   = &PROJECT..&GROUP1..&TYPE\n    ELSE -\n      DO\n        IF &SUBSTR(1:1,&DSN) NE &STR(') THEN -\n          IF &SYSPREF NE &STR() THEN SET DSN = '&SYSPREF..&DSN'\n        IF  &VOL \u00ac= &STR() THEN SET &VOL = VOLUME(&VOL)\n      END\n  IF &BATCH \u00ac= BATCH THEN -\n    DO\n      SET ZEDSMSG = COMPRESS IN PROGRESS\n      ISPEXEC CONTROL DISPLAY LOCK\n      ISPEXEC DISPLAY MSG(ISRZ001)\n      SET &SYSOUTTRAP = 1\n      COMPRESS &DSN &VOL              /* INVOKE THE \"COMPRESS\" COMMAND\n      IF &LASTCC = 0 THEN -\n        DO\n          SET &ZEDLMSG = &SYSOUTLINE1\n          SET &I = &SYSINDEX(NOW,&STR(&ZEDLMSG))\n          SET ZEDSMSG = &SUBSTR(&I:&LENGTH(&ZEDLMSG)-1,&ZEDLMSG)\n          ISPEXEC SETMSG MSG(ISRZ001)\n        END\n      ELSE -\n        WRITE &SYSOUTLINE1            /* ERROR MESSAGE\n    END\n  END\nIF &BATCH = BATCH THEN -\n  DO\n    SETVAR1                        /* RETRIEVE ACCT, NAME  */\n    SET JOBNM = &SUBSTR(1:8,&SYSUID.CPR   )\n    SUBMIT * END(ZZ)\n    //&JOBNM JOB &ACCOUNT,'&PRGNM',\n    // NOTIFY=&SYSUID,CLASS=Z,MSGCLASS=H,COND=(4,LT)\n    &STR(//*) COMPRESS DSN=&DSN\n    &STR(//*) SUBMITTED &SYSDATE &SYSTIME\n    //COMPRESS EXEC PGM=IKJEFT01,REGION=2M\n    //SYSTSPRT DD  SYSOUT=*\n    //SYSTSIN  DD  *\n    COMPRESS &DSN &VOL\n    //COND99  EXEC PGM=CANMSGCL,PARM=1 PURGE THE JOB AFTER 1 HOUR\n    //STEPLIB  DD  DSN=SYS2.LINKLIB,DISP=SHR    APF LIB\n    ZZ\n  END\nELSE -\n  COMPRESS &DSN                     /* USER SPECIFIED A DATA SET NAME\n\n\n\n   >>>>>>>>> The REXX EDIT macro is in the COMPRESS member <<<<<<<<<\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMPRESS": {"ttr": 4611, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x03\\x05\\x00\\x06\\x00\\x89\\x02\\x9f\\x01\\x031\\x1f\\x11\\x04\\x00\\x87\\x00&\\x00m\\xc3\\xc2\\xe3\\xf4\\xf5\\xf5@@@@'", "ispf": {"version": "03.05", "flags": 0, "createdate": "1989-01-29T00:00:00", "modifydate": "2003-11-07T11:04:06", "lines": 135, "newlines": 38, "modlines": 109, "user": "CBT455"}, "text": "/*REXX*****************************************************************/\n/*                                                                    */\n/* MODULE NAME = COMPRESS                                             */\n/*                                                                    */\n/* DESCRIPTIVE NAME = COMPRESS EDIT Macro for ISPF/PDF                */\n/*                                                                    */\n/* STATUS = R305                                                      */\n/*                                                                    */\n/* FUNCTION = The COMPRESS EDIT macro invokes the COMPRESS command    */\n/*            for the current data set or for another data set,       */\n/*            if a dsname is specified in the command.                */\n/*                                                                    */\n/* Author   =  Gilbert Saint-Flour <carlos@gsf-soft.com>              */\n/*             http://gsf-soft.com/Freeware/                          */\n/*                                                                    */\n/* Dependencies = COMPRESS Command Processor R313 (COMPRCMD)          */\n/*                STEMVIEW Program R105 (BATCH option only)           */\n/*                                                                    */\n/* Syntax   =  COMPRESS                                               */\n/*                 dsname|*              data set name                */\n/*                 BATCH|JCL             generate batch job           */\n/*                                                                    */\n/*        Note: the default dsname is the name of the current data    */\n/*              set.  The * is only required when the BATCH option    */\n/*              is specified for the current data set.  JCL is        */\n/*              equivalent to BATCH.                                  */\n/*                                                                    */\n/* Change Activity                                                    */\n/*                                                                    */\n/* 300 New version, uses SETMSG option instead of OUTTRAP             */\n/* 301 Simplify dsname retrieval                                      */\n/* 302 Issue a long message instead of a short one                    */\n/* 303 Add BATCH parm for background execution (requires STEMVIEW)    */\n/* 304 Add optional HBACKDS capability through a switch               */\n/*     Slash (/) means the same as asterisk.                          */\n/*     Use LRECL(80) RECFM(F) PROFILE(CNTL) for STEMVIEW              */\n/* 305 Issue error message when COMPRESS command is missing           */\n/*                                                                    */\n/**********************************************************************/\nADDRESS 'ISPEXEC'\nARG parms\nIF parms /= '' THEN DO\n  ZEDSMSG = 'Not an EDIT Macro'\n  ZEDLMSG = 'COMPRESS is not invoked as an EDIT macro.'\n      /* May occur when the COMPRESS command is missing\n         and the COMPRESS EDIT macro re-invokes itself */\n  \"DISPLAY MSG(ISRZ001)\"\n  EXIT 20\n  END\n\"ISREDIT MACRO (DSN BATCH)\"\nIF RC>0 THEN EXIT 20\n\nUPPER dsn batch                        /* convert to upper-case      */\n  /*----------------------------------------------------------------*\\\n  |*                Validate BATCH/JCL option                       *|\n  \\*----------------------------------------------------------------*/\njcl = ABBREV('BATCH',batch,1) | ABBREV('JCL',batch,1)\nIF jcl=0 & batch/='' THEN DO\n  ZEDSMSG = 'Invalid parameter'\n  ZEDLMSG = 'Second parameter must be BATCH or JCL'\n  \"SETMSG MSG(ISRZ001)\"\n  EXIT 20\n  END\n  /*----------------------------------------------------------------*\\\n  |*                 Set HBACKDS switch                             *|\n  \\*----------------------------------------------------------------*/\nhbackds = (SYSVAR(SYSHSM) /= '')       /* hbackds=1 if HSM active    */\nhbackds = 0                           /* turn off HBACKDS capability */\n  /*----------------------------------------------------------------*\\\n  |*                 Retrieve dsname and volser                     *|\n  \\*----------------------------------------------------------------*/\nIF dsn='' | dsn='*' | dsn='/' THEN DO  /* Current Data Set           */\n  \"CONTROL ERRORS RETURN\"              /* trap ISPEXEC error         */\n  \"ISREDIT (DSN) = DATASET\"            /* retrieve dsname            */\n  dsn=\"'\" || dsn || \"'\"                /* Enclose dsname in quotes   */\n  \"ISREDIT (ID1) = DATAID\"\n  IF rc>4 THEN SIGNAL SETMSG\n  \"LMQUERY DATAID(\"ID1\") VOLUME(vol) DATASET(dsn2)\"\n  IF rc>4 THEN SIGNAL SETMSG\n  IF dsn2 /= '' THEN                   /* non-null                   */\n    dsn=STRIP(dsn2)                    /* no trailing spaces         */\n  IF vol /= '' THEN\n    vol = 'VOLUME('vol')'\n  END\nELSE                                   /* USER SPECIFIED A DSNAME    */\n  vol=''\n  /*----------------------------------------------------------------*\\\n  |*      Prefix TSO prefix if dsname is not fully qualified        *|\n  \\*----------------------------------------------------------------*/\nIF LEFT(dsn,1)/=\"'\" THEN DO\n  \"VGET ZPREFIX\"                       /* get dsname prefix          */\n  dsn= \"'\" || zprefix || '.' || dsn || \"'\"\n  END\n  /*----------------------------------------------------------------*\\\n  |*                Generate JCL for batch processing               *|\n  \\*----------------------------------------------------------------*/\nIF jcl THEN DO\n  \"VGET ZACCTNUM\"                             /* Accounting info   */\n  jobname=LEFT(USERID()||'CPR',8)             /* JOB name          */\n  acct=zacctnum                               /* Accounting info   */\n  pgmr=USERID()                               /* Programmer's name */\n  QUEUE '//' || jobname 'JOB' acct || \",'\" || pgmr || \"',\"\n  QUEUE '// NOTIFY=&SYSUID,COND=(0,NE),'\n  QUEUE '// CLASS=A,MSGCLASS=H'\n  QUEUE '//COMPRESS EXEC PGM=IKJEFT01,REGION=2M'\n  QUEUE '//SYSTSPRT DD SYSOUT=*'\n  QUEUE '//SYSTSIN DD *'\n  IF hbackds THEN\n    QUEUE 'HBACKDS' dsn 'WAIT'\n  QUEUE 'COMPRESS' dsn 'SHR' vol\n  CALL STEMVIEW 'VIEW',,,,'COMPRESS' dsn vol,,80,'F','CNTL'\n  END\n  /*----------------------------------------------------------------*\\\n  |*                     Foreground Compress                        *|\n  \\*----------------------------------------------------------------*/\nELSE DO                                /* BATCH was not specified */\n  ZEDSMSG = ''\n  IF hbackds THEN DO\n    ZEDLMSG = 'Data Set' dsn 'is being backed up.'\n    IF vol/='' THEN\n      ZEDLMSG = 'Data Set' dsn 'is being backed up from' vol\n    \"CONTROL DISPLAY LOCK\"\n    \"DISPLAY MSG(ISRZ001)\"\n    \"SELECT CMD(HBACKDS\" dsn vol \"WAIT) MODE(FSCR)\"\n    END\n  ZEDLMSG = 'Data Set' dsn 'is being compressed.'\n  IF vol/='' THEN\n    ZEDLMSG = 'Data Set' dsn 'is being compressed on' vol\n  \"CONTROL DISPLAY LOCK\"\n  \"DISPLAY MSG(ISRZ001)\"\n  \"SELECT CMD(COMPRESS\" dsn vol \"SHR SETMSG) MODE(FSCR)\"\n  END\nEXIT\n\nSETMSG:  IF zerrmsg/='' THEN 'SETMSG MSG('zerrmsg')' ; EXIT 20\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CONCAT": {"ttr": 4614, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04\\x02\\x005\\x00\\x88\\x13O\\x01\\t&/\\x11\\x08\\x01\\x1c\\x007\\x00 \\xc3\\xc2\\xe3\\xf4\\xf7\\xf8@@@@'", "ispf": {"version": "04.02", "flags": 0, "createdate": "1988-05-13T00:00:00", "modifydate": "2009-09-19T11:08:35", "lines": 284, "newlines": 55, "modlines": 32, "user": "CBT478"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* MODULE NAME = CONCAT                                               */\n/*                                                                    */\n/* DESCRIPTIVE NAME = Concatenate a data set to an existing DD        */\n/*                                                                    */\n/* STATUS = R402                                                      */\n/*                                                                    */\n/* FUNCTION = This REXX exec allows a TSO user to add a data set      */\n/*            at the beginning or the end of a concatenation          */\n/*            without having to know what libraries are currently     */\n/*            allocated to the specified ddname.                      */\n/*                                                                    */\n/* AUTHOR   =  Gilbert Saint-Flour <carlos@gsf-soft.com>              */\n/*             http://gsf-soft.com/Freeware/                          */\n/*                                                                    */\n/* DEPENDENCIES = TSO/E V2                                            */\n/*                                                                    */\n/* SYNTAX = See below                                                 */\n/*                                                                    */\n/*      CONCAT  DDNAME(ddname)                                        */\n/*              DSNAME(dsname)                                        */\n/*              BEFORE|AFTER|REMOVE                                   */\n/*              DEBUG                                                 */\n/*                                                                    */\n/*   Default:   BEFORE                                                */\n/*              DDNAME(SYSEXEC) DSNAME('userid.EXEC')                 */\n/*                                                                    */\n/*   Examples:                                                        */\n/*                                                                    */\n/*     Add the IBMUSER.CLIST data set at the beginning of the         */\n/*     SYSPROC concatenation:                                         */\n/*                                                                    */\n/*       %CONCAT DD(SYSPROC) DS('IBMUSER.CLIST')                      */\n/*                                                                    */\n/*     Add the ISP.SISPEXEC data set at the end of the                */\n/*     SYSEXEC concatenation:                                         */\n/*                                                                    */\n/*       %CONCAT DD(SYSEXEC) DS('ISP.SISPEXEC') AFTER                 */\n/*                                                                    */\n/*     Execute CONCAT from the SYS2.EXEC library and add SYS2.EXEC    */\n/*     to the end of the SYSEXEC concatenation:                       */\n/*                                                                    */\n/*       EXEC 'SYS2.EXEC(CONCAT)' 'AFTER'                             */\n/*                                                                    */\n/* OPERATION = See below                                              */\n/*                                                                    */\n/*     If CONCAT is invoked without ddname and dsname parameters,     */\n/*     defaults values are used as follows:                           */\n/*                                                                    */\n/*     o if CONCAT is invoked implicitely (from SYSEXEC or            */\n/*       SYSPROC), the dsname defaults to prefix.EXEC and             */\n/*       the ddname defaults to SYSEXEC.                              */\n/*                                                                    */\n/*     o if CONCAT is invoked via the EXEC command, the               */\n/*       default dsname is the name of the library specified          */\n/*       in the EXEC command and the default ddname is                */\n/*       SYSEXEC if the dsname's low-level qualifier is EXEC;         */\n/*       otherwise, the default ddname is SYSPROC.                    */\n/*                                                                    */\n/*     If the specified ddname is already allocated, CONCAT traps     */\n/*     the output of the LISTALC command to retrieve the data set     */\n/*     names currently allocated to the specified DD, builds an       */\n/*     ALLOCATE command with the new dsname and the old dsnames,      */\n/*     and executes it.  If CONCAT detects that the new data set      */\n/*     is already allocated in the specified position, then a         */\n/*     message is issued and no re-allocation takes place.            */\n/*                                                                    */\n/*     If the specified ddname is not currently allocated,            */\n/*     CONCAT simply issues an ALLOCATE command.  If the ddname       */\n/*     is SYSEXEC, CONCAT also issues an EXECUTIL SEARCHDD(YES)       */\n/*     command to activate it.                                        */\n/*                                                                    */\n/*     CONCAT detects a situation where it is implicitely executed    */\n/*     out of the SYSEXEC concatenation and the specified ddname is   */\n/*     SYSEXEC; in this case, CONCAT uses the QUEUE command to add    */\n/*     the ALLOCATE command to the TSO stack and prevent it from      */\n/*     failing because SYSEXEC is open.  This technique works         */\n/*     correctly if CONCAT is invoked at the READY prompt or under    */\n/*     ISPF.  If CONCAT is invoked from a CLIST or REXX exec, the     */\n/*     QUEUE'd ALLOCATE command will not execute until after the      */\n/*     invoking CLIST or exec ends.  In practical terms, this means   */\n/*     that if you intend to invoke CONCAT from a CLIST or REXX       */\n/*     exec to add data sets to SYSEXEC, then consider placing        */\n/*     CONCAT in the SYSPROC (rather than SYSEXEC) concatenation.     */\n/*                                                                    */\n/* CHANGES = See below                                                */\n/*                                                                    */\n/* 400 New packaging for the CBT tape                                 */\n/* 401 Add the REMOVE function                                        */\n/* 402 No dsname & PREFIX='' -> dsname=userid.EXEC                    */\n/*                                                                    */\n/**********************************************************************/\nARG parm\n /*----------------------------------------------------------------*/\n /*                Check parm for DEBUG mode                       */\n /*----------------------------------------------------------------*/\nPARSE SOURCE . . . ownddn owndsn  .     /* retrieve my own dsname */\ni=WORDPOS('DEBUG',parm)                 /* search for DEBUG option */\nIF i=0 THEN\n  Debug=''                              /* debug mode is OFF */\nELSE\n  parm=DELWORD(parm,i,1)                /* delete word DEBUG */\nIF debug='DEBUG' THEN\n  SAY 'ownddn='ownddn 'owndsn='owndsn debug,\n      SYSVAR(SYSICMD) SYSVAR(SYSSCMD) SYSVAR(SYSPCMD)\n /*----------------------------------------------------------------*/\n /*            Add closing parenthesis at end of string            */\n /*----------------------------------------------------------------*/\nIF parm\\='' THEN DO\n  p=WORD(Parm,WORDS(Parm))\n  IF RIGHT(p,1)\\=')' & POS('(',p)>1 THEN\n    Parm=STRIP(Parm) || ')'\n  END\n /*----------------------------------------------------------------*/\n /*               Process input parameters                         */\n /*----------------------------------------------------------------*/\nDdname='';Dsname='';Place=''\nDO i=1 to WORDS(parm)\n  p=TRANSLATE(WORD(parm,i))\n  IF Debug='DEBUG' THEN SAY 'p='p 'parm='parm\n  kwd=''\n  IF RIGHT(p,1)=')' & POS('(',p)>1 THEN DO\n    value=LEFT(p,LENGTH(p)-1)               /* remove right paren */\n    PARSE VAR value kwd '(' value           /* extract key-word   */\n    END\n  SELECT\n    WHEN ABBREV('DDNAME',kwd,2) THEN DO\n      IF ddname\\='' THEN SIGNAL Duplicate_keyword\n      IF value='' | LENGTH(value)>8 THEN SIGNAL Invalid_value\n      ddname=value\n      END\n    WHEN ABBREV('DSNAME',kwd,2) THEN DO\n      IF dsname\\='' THEN SIGNAL Duplicate_keyword\n      IF value='' | LENGTH(value)>46 THEN SIGNAL Invalid_value\n      dsname=value\n      END\n    WHEN ABBREV('BEFORE',p,1) | ABBREV('AFTER',p,1) | ,\n         ABBREV('REMOVE',p,1)                       THEN DO\n      IF Place\\='' THEN SIGNAL Duplicate_keyword\n      Place=LEFT(p,1)           /* B(efore) or A(fter) or R(emove) */\n      END\n    OTHERWISE\n      Say \"Invalid argument:\" kwd\n  END\nEND\n /*----------------------------------------------------------------*/\n /*        Provide defaults when invoked with no arguments         */\n /*----------------------------------------------------------------*/\nIF dsname='' & ddname='' THEN DO\n  ddname='SYSEXEC'                /* default ddname */\n  IF owndsn='?' THEN DO           /* implicit invocation */\n    dsname=\"EXEC\"                 /* prefix.EXEC */\n    rc=LISTDSI(dsname)\n    IF rc>0 THEN DO\n      dsname=USERID() || \".EXEC\"  /* userid.EXEC */\n      END\n    END\n  ELSE DO\n    dsname=\"'\"owndsn\"'\"           /* default dsname */\n    IF RIGHT(owndsn,5)\\='.EXEC' THEN\n      ddname='SYSPROC'           /* default ddname */\n    END\n  END\nIF dsname='' THEN SIGNAL Missing_dsname\nIF ddname='' THEN SIGNAL Missing_ddname\nIF place='' THEN place='B'\n /*----------------------------------------------------------------*/\n /*            Check that specified DSname is cataloged            */\n /*----------------------------------------------------------------*/\nrc=LISTDSI(dsname)\nIF rc>0 THEN SIGNAL Uncataloged_dsname\ndsname=\"'\"sysdsname\"'\"                 /* fully-qualified dsname */\n /*----------------------------------------------------------------*/\n /*     Issue ALLOCATE if this is a new ddname and not a REMOVE    */\n /*----------------------------------------------------------------*/\nrc=LISTDSI(ddname 'FILE')\nIF rc>0 & place\\='R' THEN DO\n  CALL TSO_command \"ALLOCATE DD(\"ddname\") DS(\"dsname\") SHR\"\n  IF ddname='SYSEXEC' THEN\n    CALL TSO_command \"EXECUTIL SEARCHDD(YES)\"\n  EXIT rc\n  END\n /*----------------------------------------------------------------*/\n /*            Retrieve current allocations                        */\n /*----------------------------------------------------------------*/\nrc=OUTTRAP('LINE.')                          /* TRAP PUTLINE        */\n\"LISTALC STATUS\"\nrc=OUTTRAP('OFF')                            /* TRAP OFF            */\n /*----------------------------------------------------------------*/\n /*        Retrieve data sets currently allocated to &ddname       */\n /*----------------------------------------------------------------*/\nOlddsn=''\nDO I = 2 TO line.0\n  dsn = LINE.I\n  IF LEFT(dsn,9) = 'TERMFILE ' THEN ITERATE\n  IF LEFT(dsn,9) = 'NULLFILE ' THEN ITERATE\n  I = I+1                                /* skip one line          */\n  tdd=STRIP(SUBSTR(Line.I,3,8))          /* extract ddname         */\n  IF tdd \\= '' THEN\n    ddn = tdd                            /* save DDNAME            */\n  IF ddn = ddname THEN DO\n    olddsn = olddsn \"'\"dsn\"'\"\n    IF debug='DEBUG' THEN\n      SAY 'ddn='ddn 'dsn='dsn 'dsname='dsname 'olddsn='olddsn\n    END\nEND /* WHILE I <= line.0 */\n /*----------------------------------------------------------------*/\n /*        Check if new dsname is already in the right place       */\n /*----------------------------------------------------------------*/\nIF dsname=olddsn & place\\='R' THEN\n  CALL Already_inplace\ni=WORDPOS(dsname,olddsn)                /* search for new dsname */\nIF debug='DEBUG' THEN\n  SAY 'i='i 'dsname='dsname 'olddsn='olddsn place\nIF i>0 THEN DO\n  IF (i=1 & place='B') | (i=WORDS(olddsn) & place='A') THEN\n    CALL Already_inplace\n  olddsn=DELWORD(olddsn,i,1)            /* remove dsname from list */\n  END\nELSE\n  IF place='R' THEN\n    CALL Cannot_remove\nIF debug='DEBUG' THEN\n  SAY 'i='i 'dsname='dsname 'olddsn='olddsn place\n /*----------------------------------------------------------------*/\n /*        Issue new ALLOCATE command                              */\n /*----------------------------------------------------------------*/\nCALL TSO_command \"FREE DD(\"ddname\")\"   /* Free current allocation */\nIF place='A' THEN\n  dsn=STRIP(olddsn) dsname             /* place=AFTER            */\nELSE\n  IF place='B' THEN\n    dsn=dsname STRIP(olddsn)           /* place=BEFORE           */\n  ELSE\n    dsn=STRIP(olddsn)                  /* place=REMOVE           */\n\nIF dsn\\='' THEN DO\n  cmd=\"ALLOCATE DD(\"ddname\") DS(\"dsn\") SHR REUSE\"\n  CALL TSO_command cmd                 /* issue ALLOCATE command */\n  END\nEXIT\n\n /*----------------------------------------------------------------*/\n /*           Error Routines                                       */\n /*----------------------------------------------------------------*/\nDuplicate_keyword:\n  IF kwd='' THEN kwd=p\n  SAY 'Key-word' kwd 'has been specified more than once.'\n  EXIT 8\nInvalid_value:\n  IF Value='' THEN\n    SAY 'A null value is invalid for key-word' kwd\n  ELSE\n    SAY 'Value' value 'is invalid for key-word' kwd\n  EXIT 8\nMissing_dsname:\n  SAY 'DSname missing or invalid.'\n  EXIT 8\nMissing_ddname:\n  SAY 'DDname missing or invalid.'\n  EXIT 8\nUncataloged_dsname:\n  SAY 'Data set' dsname 'is not cataloged.'\n  EXIT 8\nAlready_inplace:\n  SAY 'Data set' dsname 'is already concatenated in the right position.'\n  EXIT 4\nCannot_remove:\n  SAY 'Data set' dsname 'cannot be removed, is not concatenated.'\n  EXIT 8\nTSO_command:\n  ARG cmd\n  IF ownddn='SYSEXEC' & ddname='SYSEXEC' THEN DO\n    SAY 'STACK=>' cmd                  /* display command */\n    QUEUE cmd                          /* place command on the stack */\n    END\n  ELSE DO\n    SAY cmd                            /* display command */\n    cmd                                /* execute command */\n    IF debug='DEBUG' & rc>0 THEN\n      SAY 'RC='rc 'Reason='sysreason sysmsglvl1 sysmsglvl2\n    END\n  RETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CUT": {"ttr": 4620, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04\\x02\\x00\\x00\\x00\\x93\\x03\\x8f\\x00\\x99\\x11\\x9f\\x10\\x00\\x01-\\x00\\x02\\x00;\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "04.02", "flags": 0, "createdate": "1993-02-07T00:00:00", "modifydate": "1999-04-29T10:00:00", "lines": 301, "newlines": 2, "modlines": 59, "user": "CBT472"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* MODULE NAME = CUT                                                  */\n/*                                                                    */\n/* DESCRIPTIVE NAME = CUT EDIT Macro for ISPF/PDF                     */\n/*                                                                    */\n/* STATUS   =  R402                                                   */\n/*                                                                    */\n/* FUNCTION =  Copy the data being edited (or part of it) to a        */\n/*             clip-board for later retrieval by the PASTE command.   */\n/*                                                                    */\n/*             CUT is functionally similar to a CREATE command.       */\n/*             It is used in conjunction with the PASTE macro.        */\n/*                                                                    */\n/* AUTHOR   =  Gilbert Saint-Flour <carlos@gsf-soft.com>              */\n/*                                                                    */\n/* SYNTAX   =  CUT                                                    */\n/*                 clipboard             name of the clip board       */\n/*                 first                 First line       .A          */\n/*                 last                  Last line        .B          */\n/*                                                                    */\n/*             The clip-board is an optional name, identical in       */\n/*             syntax to a PDS member name.  Each name refers to a    */\n/*             different clip-board into which the data is stored.    */\n/*             Clip-boards are managed by the CUTPGM program; they    */\n/*             are deleted at the end of the TSO session.  If no      */\n/*             clip-board name is specified, the default clip-board   */\n/*             is used.                                               */\n/*                                                                    */\n/*             When data lines are cut, they replace the previous     */\n/*             content of the clip-board, except when a + sign is     */\n/*             specified instead of the name of a clip-board, in      */\n/*             which case the lines are appended to the data already  */\n/*             in the default clip-board.                             */\n/*                                                                    */\n/*             A range may be specified to limit the amount of data   */\n/*             stored by the CUT macro.  The range may be specified   */\n/*             in the command (e.g. CUT .X .Y) or as a line command   */\n/*             (e.g C, Cn, CC/CC or M, Mn or MM/MM).  If no range is  */\n/*             specified, the entire data set is copied to the        */\n/*             clip-board.                                            */\n/*                                                                    */\n/*             The number of lines that can be CUT is limited by the  */\n/*             size of the clip-board, as set in the variable \"blocks\"*/\n/*             below; a block can hold 4K of data.                    */\n/*                                                                    */\n/*             The variable \"compress\" controls how the data is       */\n/*             stored in a clip-board.  If compress=0, no compression */\n/*             is performed and an 80-byte line takes up 82 bytes of  */\n/*             storage.  If compress=1, trailing blanks are removed   */\n/*             before the data is moved to the clip-board.            */\n/*             If compress=2, the MVS compression-expansion services  */\n/*             are used to compress strings of redundant characters;  */\n/*             this reduces paging but consumes extra CPU time,       */\n/*             particularily when the hardware compression feature    */\n/*             is not available on the system.                        */\n/*                                                                    */\n/*             The CUT macro requires the CUTPGM program to be        */\n/*             available to the ISPF SELECT service.  If CUTPGM is    */\n/*             not present in the normal search sequence (ISPLLIB,    */\n/*             TSOLIB, STEPLIB, system libraries), then the \"loadlib\" */\n/*             variable can be set to the dsname of a load-library    */\n/*             from which ISPF can load the program using the LIBDEF  */\n/*             service. If CUTPGM is present in the normal search     */\n/*             sequence, the \"loadlib\" variable should be set to      */\n/*             a null string.                                         */\n/*                                                                    */\n/* DEPENDENCIES =  MVS/ESA 4.2.2                                      */\n/*                 TSO/E V2                                           */\n/*                 ISPF and ISPF/PDF V3                               */\n/*                 CUTPGM utility program R400                        */\n/*                                                                    */\n/* CHANGE ACTIVITY                                                    */\n/*                                                                    */\n/*  $401  Correct various errors when user enters D/DD line commands  */\n/*  $402  Use LIBDEF ISPLLIB when Loadlib='load.lib.dsname'           */\n/*                                                                    */\n/**********************************************************************/\nLoadlib='userid.CUTPGM.LOAD'           /* Use LIBDEF ISPLLIB        */\nLoadlib=''                             /* Do not use LIBDEF ISPLLIB */\n\nADDRESS ISPEXEC; 'CONTROL ERRORS RETURN';ZERRMSG=''\n'ISREDIT MACRO (PARM) NOPROCESS'\nIF rc>0 THEN\n  SIGNAL Not_an_EDIT_macro\n\nIF parm='?' THEN\n  SIGNAL HELP_panel                           /* User requested HELP */\n\n'ISREDIT (LINE2) = LINENUM .ZLAST'            /* Last Line           */\nIF rc>0 | line2=0 THEN\n  SIGNAL Empty_dataset                        /* No lines to cut     */\n\n  /*-----------------------------------------------------------------*/\n  /*   Define Default Parameters                                     */\n  /*-----------------------------------------------------------------*/\n\ncompress=0                               /* No compression           */\ncompress=2                               /* Use MVS compression svcs */\ncompress=1                               /* Truncate trailing spaces */\nCut_Line_Numbers='NO'                    /* Do NOT cut line numbers  */\nCut_Line_Numbers='YES'                   /* Cut line numbers         */\nblocks=4096                              /* clipboard size (4K units)*/\n\n  /*-----------------------------------------------------------------*/\n  /*   Define variables                                              */\n  /*-----------------------------------------------------------------*/\n\nclipboard=''                              /*  clip-board name        */\nappend=''                                 /*  append/replace         */\nrange1=''                                 /*  first line             */\nrange2=''                                 /*  last line              */\n'ISREDIT (LRECL) = LRECL'\n\nCALL Parse_parm                           /*  Analyse the command    */\n\n  /*-----------------------------------------------------------------*/\n  /*   Build the parm for the CUTPGM program, as follows:            */\n  /*                                                                 */\n  /*     parm=Ccccccccc111111aklllll222222bbbbbb                     */\n  /*                                                                 */\n  /*         C          function=CUT                                 */\n  /*         cccccccc   8-character clipboard name (or blanks)       */\n  /*         111111     first line                                   */\n  /*         a          + or blank (append flag)                     */\n  /*         k          compression level: 0 1 2                     */\n  /*         lllll      data set's LRECL                             */\n  /*         222222     last line                                    */\n  /*         bbbbbb     clipboard size in units of 4K blocks         */\n  /*-----------------------------------------------------------------*/\n\nparm='C'||LEFT(clipboard,8)||RIGHT(line1,6,'0')\nparm=parm||RIGHT(append,1)||compress\nparm=parm||RIGHT(lrecl,5,'0')||RIGHT(line2,6,'0')||RIGHT(blocks,6,'0')\n\n  /*-----------------------------------------------------------------*/\n  /*   Invoke the CUTPGM program; check the return code              */\n  /*-----------------------------------------------------------------*/\n\n'ISREDIT (NUMMODE,NUMTYPE) = NUMBER'   /* Query number mode info    */\nIF Nummode='ON' & Cut_Line_Numbers='YES' THEN\n  'ISREDIT NUMBER = OFF'               /* Turn OFF number mode      */\n\nIF Loadlib\\='' THEN DO\n  p7=Loadlib                             /* for ISPD014 message   */\n  \"LIBDEF ISPLLIB DATASET ID('\"Loadlib\"') STACK\"\n  IF rc>0 THEN                           /* ISPLLIB error         */\n    SIGNAL SETMSG\n  END\n\n'SELECT PGM(CUTPGM) PARM('parm')'; Pgmrc=rc\n\nIF Loadlib\\='' THEN \"LIBDEF ISPLLIB\"\n\n'ISREDIT NUMBER =' Nummode              /* Turn number mode back ON */\n\nIF Pgmrc>0 THEN SIGNAL SETMSG\n\n  /*-----------------------------------------------------------------*/\n  /*   Delete the lines just cut if user request MOVE                */\n  /*-----------------------------------------------------------------*/\n\nIF CMD='M' THEN                                /* user requested MOVE */\n  'ISREDIT DELETE' line1 line2                 /* delete lines copied */\n\n  /*-----------------------------------------------------------------*/\n  /*   Issue completion message and exit                             */\n  /*-----------------------------------------------------------------*/\n\ni=line2-line1+1                                /* count lines copied  */\nzedsmsg=i 'lines cut'\nIF clipboard='' THEN\n  zedlmsg=i 'lines have been copied to the default clipboard '\nELSE\n  zedlmsg=i 'lines have been copied to clipboard' clipboard\n'SETMSG MSG(ISRZ000)'\nEXIT 0\n/**********************************************************************/\n/*            Parse Input Parm, process line commands.                */\n/**********************************************************************/\nParse_parm:\n  UPPER parm\n  DO i=1 to WORDS(parm)\n    p=WORD(parm,i)                            /* Extract current word */\n    IF LEFT(p,1)='.' THEN DO\n      IF range1='' THEN\n        range1=p                              /* First label          */\n      ELSE DO\n        IF range2\\='' THEN SIGNAL Bad_clip_board\n        range2=p                              /* Second label         */\n        END\n      END\n    ELSE DO\n      IF clipboard\\='' THEN SIGNAL Invalid_label\n      IF append\\=''    THEN SIGNAL Invalid_label\n      IF p='+' THEN\n        append=p\n      ELSE DO\n        /*    Check the clip-board name for correct syntax.       */\n        /*    A clip-board name must be 1 to 8 characters;        */\n        /*    each character can be numeric (0-9),                */\n        /*    alphabetic (A-Z), or national (@#$).                */\n        /*    Clip-board names are not case-sensitive.            */\n        IF LENGTH(p)>8 THEN                  /*  name is too long    */\n          SIGNAL Bad_clip_board\n        IF VERIFY(p,'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$ ') > 0 THEN\n          SIGNAL Bad_clip_board              /*  invalid character   */\n        clipboard=p\n        END\n      END\n  END\n\n  IF range1\\='' & range2='' THEN\n    SIGNAL Invalid_line_range\n\n  /*    Check if the user selected a range by entering a line        */\n  /*    command such as C, Cnn, CC/CC or M, Mnn, MM/MM. If it is     */\n  /*    the case, set line1 and line2 to the first and last line     */\n  /*    numbers, respectively.  If the user selected a range both    */\n  /*    in the CUT command (such as CUT .X .Y) and in a line         */\n  /*    command, issue an error message.                             */\n\n  'ISREDIT PROCESS RANGE C M'\n  SELECT\n    WHEN rc=0 THEN DO\n      'ISREDIT (CMD)   = RANGE_CMD'                /* get C or M  */\n      IF range1\\='' THEN SIGNAL Command_conflict\n      \"ISREDIT (LINE1) = LINENUM .ZFRANGE\"         /* First line  */\n      \"ISREDIT (LINE2) = LINENUM .ZLRANGE\"         /* Last line   */\n      END\n    WHEN rc=4 THEN DO\n      CMD='C'\n      IF Range1\\='' THEN DO                       /* CUT .X .Y       */\n        p=Range1\n        \"ISREDIT (LINE1) = LINENUM\" Range1        /* LINENUM .X      */\n        IF rc>0 THEN SIGNAL Invalid_label\n        IF Range2='' THEN Range2='.ZLAST'          /*   DEFAULTS  */\n        p=Range2\n        \"ISREDIT (LINE2) = LINENUM\" Range2        /* LINENUM .Y      */\n        IF rc>0 THEN SIGNAL Invalid_label\n        IF Line2<Line1 THEN DO\n          x=Line1; Line1=Line2; Line2=x           /* Swap labels     */\n          END\n        END\n      ELSE DO\n        Line1=1                                    /*   DEFAULTS  */\n        \"ISREDIT (LINE2) = LINENUM .ZLAST\"         /*   DEFAULTS  */\n        END\n      END\n    WHEN rc=20 THEN                       /* All lines deleted        */\n      SIGNAL Empty_dataset                /* No lines to cut          */\n    OTHERWISE DO                          /* Line command conflict    */\n      Pgmrc=RC                            /* Save ISREDIT Return code */\n      IF zerrmsg\\='' THEN\n        'SETMSG MSG('zerrmsg')'           /* Edit has created message */\n      EXIT Pgmrc\n      END\n  END\n  RETURN\n/**********************************************************************/\n/*            Exception Routines                                      */\n/**********************************************************************/\nNot_an_EDIT_macro:\n  Zedsmsg = \"EDIT Macro Only\"                  /* Short message    */\n  Zedlmsg = \"CUT may only be invoked as an EDIT macro\"\n  \"SETMSG MSG(ISRZ001)\"                        /* send the message */\n  EXIT 8\nHELP_panel:\n  'DISPLAY PANEL(CUTHLP1)'               /* Display HELP panel        */\n  IF rc>8 THEN\n    'SETMSG MSG('zerrmsg')'              /* HELP panel is missing     */\n  EXIT RC\nEmpty_dataset:\n  zedsmsg='No lines to cut'\n  zedlmsg='There are no lines to cut'\n  'SETMSG MSG(ISRZ001)'\n  EXIT 12\nInvalid_label:\n  zerrsm='Probable label error'\n  zerrlm=p 'recognized as invalid or undefined label.'\n  SIGNAL Beep_msg\nCommand_conflict:\n  zerrsm='Command Conflict'\n  zerrlm='\"'cmd'\" conflicts with range specification; blank it out.'\n  SIGNAL Beep_msg\nBad_clip_board:\n  zerrsm='Invalid clip-board'\n  zerrlm='The clip-board name must be a valid member name.'\n  SIGNAL Beep_msg\nInvalid_line_range:\n  zerrsm='Invalid line range'\n  zerrlm='Only one label was specified, CUT requires two for range.'\n  SIGNAL Beep_msg\nBeep_msg:\n  zerralrm='YES'                  /*   ALARM=YES                      */\n  zerrhm='CUTHLP1'                /*   HELP Panel                     */\n  'SETMSG MSG(ISRZ002)'           /*   Issue error message            */\n  EXIT 20\nSETMSG:\n  IF zerrmsg\\='' THEN 'SETMSG MSG('zerrmsg')'\n  EXIT 20\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CUTHLP1": {"ttr": 4869, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04\\x00\\x00\\x00\\x00\\x91\\x11_\\x00\\x95\\x13_\\x11\\x05\\x00\\x19\\x00\\x1a\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf5\\xf1@@@@'", "ispf": {"version": "04.00", "flags": 0, "createdate": "1991-04-25T00:00:00", "modifydate": "1995-05-15T11:05:00", "lines": 25, "newlines": 26, "modlines": 0, "user": "CBT451"}, "text": ")BODY DEFAULT(%@_)\n%TUTORIAL -------------------- EDIT - 'CUT' COMMAND ------------------- TUTORIAL\n%COMMAND ===>_ZCMD                                                             @\n\n@  The%CUT@command is used to copy one or more lines of the data being edited\n   to a clip-board from which it can later be retrieved using the%PASTE@\n   command.  The clip-boards are erased when you logoff.\n\n   To specify the lines to be put into the clip-board, use line commands%C@or\n  %CC@to copy line(s), or%M@or%MM@to move lines, or use%labels@.  If you do\n   not specify a line command or labels, then%ALL@of the lines are copied to\n   the clip-board.\n\n   If you specify a%clip-board@name as part of the command, you can use multiple\n   clip-boards, each of which you can later refer to with the%PASTE@ command.\n   A clip-board names has the same format as a PDS member name.  If you specify\n   a + sign instead of a clip-board name, the data is appended to the default\n   clip-board.\n\n        %COMMAND ===> cut                   @cuts the lines specified by line\n                                            @commands to default clip-board.\n\n        %COMMAND ===> cut 2 .zf .zl         @cuts all lines to clip-board 2\n\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CUTHLP2": {"ttr": 4871, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04\\x00\\x00\\x00\\x00\\x91\\x11_\\x00\\x95\\x13_\\x11\\x05\\x00\\x14\\x00\\x19\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf5\\xf1@@@@'", "ispf": {"version": "04.00", "flags": 0, "createdate": "1991-04-25T00:00:00", "modifydate": "1995-05-15T11:05:00", "lines": 20, "newlines": 25, "modlines": 0, "user": "CBT451"}, "text": "%TUTORIAL ------------------ EDIT - 'PASTE' COMMAND ------------------- TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n+  The%PASTE+command is used to copy one or more lines of data from a clip-board\n   created by the%CUT+command to the data being edited.\n\n   To specify where the data is to be copied, use the%A+(after) or%B+(before)\n   line commands or specify%AFTER+or%BEFORE+as a parameter, followed by a%label+\n   name. %AFTER+and%BEFORE+can be abbreviated%AFT+and%BEF+.\n\n   If you specify a clip-board name as part of the command, you can refer to any\n   one of the clip-boards that have been created by the%CUT+command.\n\n        %COMMAND ===> paste                 +copies the lines from the default\n                                            +clip-board to a location specified\n                                            +by a line command.\n\n        %COMMAND ===> paste 2 before .zf    +copies the lines from clip-board 2\n                                            +to the line before the first line.\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CUTPGM": {"ttr": 4873, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04\\x02\\x00\\x00\\x00\\x92\\x12?\\x00\\x97\\x12\\x9f\\x17S\\x02J\\x013\\x00\\x14\\xc3\\xc2\\xe3\\xf4\\xf1\\xf5@@@@'", "ispf": {"version": "04.02", "flags": 0, "createdate": "1992-05-02T00:00:00", "modifydate": "1997-05-09T17:53:00", "lines": 586, "newlines": 307, "modlines": 20, "user": "CBT415"}, "text": "//GILBERTC JOB (ACCT#),CUTPGM,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = CUTPGM                                                *\n*                                                                     *\n* DESCRIPTIVE NAME = UTILITY PROGRAM FOR THE CUT & PASTE EDIT MACROS  *\n*                                                                     *\n* FUNCTION = THIS PGM IS INVOKED BY THE CUT AND PASTE EDIT MACROS     *\n*            TO CREATE AND MAINTAIN CLIP-BOARDS USING DATA SPACES,    *\n*            NAME/TOKEN PAIRS AND COMPRESSION/EXPANSION SERVICES.     *\n*                                                                     *\n* STATUS = R402                                                       *\n*                                                                     *\n* AUTHOR = GILBERT SAINT-FLOUR <carlos@gsf-soft.com>                  *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*    DEPENDENCIES: MVS/ESA 4.2.2                                      *\n*                  ISPF/PDF V3                                        *\n*                  CUT & PASTE EDIT MACROS R300                       *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (CSECT TYPE)                               *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 2K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE ANY, AMODE 31,                   *\n*                 PROBLEM STATE, KEY 8                                *\n*                 APF AUTHORIZATION: NONE                             *\n*                                                                     *\n* OPERATION = SEE BELOW                                               *\n*                                                                     *\n*   CUTPGM IS INVOKED BY THE CUT AND PASTE EDIT MACROS AND,           *\n*   DEPENDING ON THE PARM PASSED BY THE INVOKER, PROVIDES THE         *\n*   \"CUT\", \"PASTE\" AND \"DUMP\" FUNCTIONS.                              *\n*                                                                     *\n*   1. \"CUT\" DEFINES A CLIP-BOARD AND COPIES DATA FROM THE EDIT       *\n*      SESSION TO THE CLIP-BOARD.  DATA MAY OR MAY NOT BE             *\n*      COMPRESSED DURING THE COPY PROCESS, BASED ON A PARM OPTION.    *\n*                                                                     *\n*   2. \"PASTE\" RETRIEVES DATA FROM THE CLIP-BOARD AND INSERTS IT      *\n*      INTO THE CURRENT EDIT DATA.                                    *\n*                                                                     *\n*   3. \"DUMP\" DISPLAYS THE CONTENTS OF A CLIP-BOARD USING THE         *\n*      \"BRIF\" SERVICE.  THIS FUNCTION IS INTENDED FOR DEBUGGING       *\n*      PURPOSES ONLY.                                                 *\n*                                                                     *\n*   THE PARM FIELD IS USED TO PASS PARAMETERS TO THE PROGRAM.         *\n*   PLEASE REFER TO THE \"PARM\" DSECT FOR THE FORMAT OF THE            *\n*   PARM FIELD.                                                       *\n*                                                                     *\n*   CLIP-BOARD NAMES HAVE THE SAME FORMAT AS PDS MEMBER NAMES.        *\n*   THE NUMBER OF CLIP-BOARDS IN USE AT A GIVEN TIME IS ONLY          *\n*   LIMITED BY THE SYSTEM.  CLIP-BOARDS GET DELETED AT THE END        *\n*   OF THE TSO SESSION (I.E. AT LOGOFF TIME).                         *\n*                                                                     *\n*   EACH CLIP-BOARD IS ACTUALLY A DATA SPACE NAMED 'NNNNNCUT',        *\n*   WHERE NNNNN IS A SEQUENCE NUMBER GENERATED BY THE SYSTEM          *\n*   WHEN THE DSPSERV MACRO IS ISSUED TO CREATE A DATA SPACE.          *\n*                                                                     *\n*   THIS PROGRAM USES NAME/TOKEN PAIRS TO RETRIEVE THE STOKEN AND     *\n*   ALET OF THE DATA SPACES IT CREATES.  NAME/TOKEN PAIRS IS A        *\n*   FEATURE INTRODUCED IN MVS/ESA 4.2.2.  CONSEQUENTLY, THIS          *\n*   PROGRAM WON'T LINK NOR EXECUTE ON MVS SYSTEMS PRIOR TO 4.2.2.     *\n*                                                                     *\n*   TO REDUCE PAGING, DATA CAN BE STORED IN COMPRESSED FORMAT,        *\n*   DEPENDING ON A PARM OPTION.  THREE LEVELS ARE AVAILABLE:          *\n*                                                                     *\n*   1. WHEN COMPRESS=0, DATA IS NOT COMPRESSED AND EACH RECORD        *\n*      USES UP TO LRECL+2 BYTES OF STORAGE.                           *\n*                                                                     *\n*   2. WHEN COMPRESS=1, TRAILING BLANKS ARE REMOVED.                  *\n*                                                                     *\n*   3. WHEN COMPRESS=2, MVS COMPRESSION/EXPANSION SERVICES            *\n*      (CSECRSRV MACRO) ARE USED TO COMPRESS STRINGS OF               *\n*      REDUNDANT CHARACTERS.                                          *\n*                                                                     *\n* RETURN-CODES = SEE BELOW                                            *\n*                                                                     *\n*          0                    OK                                    *\n*         12                    UNDEFINED CLIP-BOARD          (PASTE) *\n*         20                    INVALID FUNCTION                      *\n*        1NN                    VDEFINE        FAILED WITH RC=NN      *\n*        2NN                    ISREDIT        FAILED WITH RC=NN      *\n*        5NN                    CSECRSRV       FAILED WITH RC=NN      *\n*        6NN                    OPEN           FAILED WITH RC=NN      *\n*        7NN                    BRIF           FAILED WITH RC=NN      *\n*       1NNN                    TCBTOKEN MACRO FAILED WITH RC=NNN     *\n*       2NNN                    DSPSERV CREATE FAILED WITH RC=NNN     *\n*       3NNN                    ALESERV ADD    FAILED WITH RC=NNN     *\n*       4NNN                    IEANTCR CALL   FAILED WITH RC=NNN     *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n*  $400 COMPLETE REWRITE FOR ESA 4.2.2                                *\n*  $401 ISSUE LOAD TO MAKE MYSELF RESIDENT IN MEMORY                  *\n*  $402 FIX PADDING ERROR IN PASTE ROUTINE                            *\n*                                                                     *\n&REL     SETC  'R402'                                                 *\n***********************************************************************\nCUTPGM   CSECT\nCUTPGM   RMODE ANY\n         SAVE  (14,12),,'GSF UTILITIES - CUTPGM &REL'\n         LR    R12,R15                 BASE REG\n         USING CUTPGM,R12\n         L     R11,0(,R1)              A(PARM)\n         USING PARM,R11\n*---------------------------------------------------------------------*\n*                                                                     *\n*        INITIALISATION                                               *\n*                                                                     *\n*        1. ALLOCATE WORKING-STORAGE                                  *\n*        2. RETRIEVE THE STOKEN/ALET OF THE DATA SPACE                *\n*        3. CHECK PARAMETERS COMMON TO CUT AND PASTE FUNCTIONS        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         STORAGE OBTAIN,               GET DYNAMIC STORAGE             X\n               LENGTH=DYNAML,          LENGTH                          X\n               LOC=BELOW,              SNAPDCB                         X\n               BNDRY=PAGE              INITIALIZE WITH X'00'\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LM    R13,R1,8(R13)           A(DYNAM)\n         USING DYNAM,R13\n*\n         LOAD  EP=CUTPGM               MAKE MYSELF RESIDENT\n*\n         LOAD  EP=ISPLINK              ISPF INTERFACE\n         ST    R0,ISPLINK@             SAVE THE ADDRESS\n*\n         MVC   CLIPNAME,=C'CUTPASTE'   NAME OF MY DATA SPACE\n         MVC   CLIPNAME+8(8),CLIPBOARD BUFFER ID\n*\n*        RETRIEVE THE STOKEN/ALET OF THE DATA SPACE\n*\n         CALL  IEANTRT,                RETRIEVE                        X\n               (=A(IEANT_HOME_LEVEL),  SCOPE                           X\n               CLIPNAME,DSPCSTKN,      NAME/TOKEN                      X\n               DWD),                   RETURN CODE                     X\n               MF=(E,TENWORDS)\n         LTR   R15,R15                 DATA SPACE EXISTS ALREADY?\n         BNZ   INIT30                  NO, JUMP\n         L     R2,DSPCORG              ORIGIN\n         LAM   R2,R2,DSPCALET          POINT TO THE DATA SPACE\n         SAC   512                     MODE=AR\n         MVC   HEADER,0(R2)            MOVE HEADER FROM \"CUT\"\n         SAC   0                       MODE=PRIMARY\n*\nINIT30   CLI   FUNCTION,C'D'           FUNCTION=DUMP?\n         BE    DUMP00                  YES, GO THERE\n*\n         PACK  LINE1,LINE1             FIRST LINE\n*\n         CLI   FUNCTION,C'C'           FUNCTION=CUT?\n         BE    CUT00                   YES, GO THERE\n         CLI   FUNCTION,C'P'           FUNCTION=PASTE?\n         BE    PASTE00                 YES, GO THERE\n         LA    R15,20                  RC=20 (INVALID FUNCTION)\n         B     EXIT15                  QUIT\n***********************************************************************\n*                                                                     *\n*        \"DUMP\" FUNCTION: DISPLAY THE CONTENTS OF THE DATA SPACE      *\n*                         USING THE ISPF/PDF BROWSE INTERFACE (BRIF). *\n*                                                                     *\n***********************************************************************\nDUMP00   LA    R15,12                  DATA SPACE NOT FOUND\n         OC    HDRTCB,HDRTCB           DATA SPACE LOCATED?\n         BZ    EXIT15                  NO, QUIT\n         LA    R0,DYNAM                DIALOG DATA ADDR\n         ST    R0,DWD                  DIALOG DATA PTR\n         LA    R14,=C'BRIF'            ISPF FUNCTION\n         LA    R15,CLIPNAME            DSNAME\n         LA    R0,=C'F '               RECFM\n         LA    R1,=F'80'               LRECL\n         LA    R2,=A(DUMP500)          READ ROUTINE\n         SLR   R3,R3                   COMMAND RTNE ADDR\n         LA    R4,DWD                  PARM FOR READ ROUTINE\n         STM   R14,R4,TENWORDS         PARAMETER LIST\n         OI    TENWORDS+24,X'80'       END OF PARAMETER LIST\n         LA    R1,TENWORDS             PARAMETER LIST\n         L     R15,ISPLINK@            ISPF INTERFACE\n         BALR  R14,R15              <- BRIF\n         LTR   R15,R15                 BRIF OK?\n         BZ    EXIT00                  YES, EXIT\n         LA    R15,700(,R15)           ERROR: BRIF FAILED\n         B     EXIT15                  NO, QUIT\n*\n*        BRIF READ ROUTINE\n*\n         PUSH  USING\nDUMP500  BAKR  R14,0                   SAVE REGS\n         LR    R11,R15                 BASE REG\n         USING DUMP500,R11\n         LM    R2,R5,0(R1)             LOAD PARM ADDR\n         L     R13,0(,R5)              POINT TO DYNAMIC STORAGE AREA\n         L     R7,0(,R4)               LINE NUMBER REQUESTED BY BRIF\n         BCTR  R7,0                    RELATIVE TO ZERO\n         M     R6,=F'80'               MULT BY LINE LENGTH\n*L R0,DSPCALET\n         LAM   R7,R7,DSPCALET          POINT TO THE DATA SPACE\n         SAC   512                     MODE=AR\n         MVC   LINE(80),0(R7)          MOVE LINE TO ADDRESS SPACE\n         SAC   0                       MODE=PRIMARY\n         LA    R0,LINE                 ADDRESS OF CURRENT RECORD\n         ST    R0,0(,R2)               PASS ADDR BACK TO BRIF\n*STM R2,R7,LINE\nDUMP590  SLR   R15,R15                 GOBACK WITH RC=00\n         PR\n         POP   USING\n***********************************************************************\n*                                                                     *\n*        \"CUT\" FUNCTION                                               *\n*                                                                     *\n*        1. PROCESS PARM                                              *\n*        2. DEFINE THE DATA SPACE                                     *\n*        3. RETRIEVE DATA LINES AND STORE THEM INTO THE DATA SPACE    *\n*        4. UPDATE DATA SPACE HEADER                                  *\n*                                                                     *\n***********************************************************************\nCUT00    PACK  LINE2,LINE2             LAST LINE\n*\n         BAL   R14,DEFSPC              DEFINE DATA SPACE\n         LTR   R15,R15                 OK?\n         BNZ   EXIT15                  NO, QUIT\n*\n         CLI   APPEND,C'+'             APPEND OPTION ?\n         BE    CUT40                   YES, DO NOT RESET POINTERS\n         MVC   HDRCOMPR,COMPRESS       SAVE COMPRESSION LEVEL\n         XC    HDRLINES,HDRLINES       RESET LINE COUNTER\n*\n         L     R4,DSPCORG              ORIGIN\n         LA    R4,L'HEADER(,R4)        SKIP HEADER\n         ST    R4,HDRNEXTB             FIRST BYTE OF DATA\n*\n         PACK  DWD,LRECL               MAX RECORD SIZE\n         CVB   R0,DWD                  LENGTH\n         ST    R0,HDRLRECL             LENGTH\n*\nCUT40    BAL   R14,VDEFLINE            VDEFINE LINE\n         LTR   R15,R15                 CHECK RETURN CODE\n         BNZ   ERROR100                ISPLINK FAILED\n*\nCUT50    L     R4,HDRNEXTB             FIRST BYTE OF DATA\n         LAM   R4,R4,DSPCALET          POINT TO THE DATA SPACE\n*\n         L     R5,HDRBLKS              SIZE OF THE DATA SPACE (PAGES)\n         SLL   R5,12                   SIZE OF THE DATA SPACE (BYTES)\n         SL    R5,DSPCORG              MINUS ORIGIN\n         SLR   R5,R4                   SIZE OF THE DATA PORTION\n*\n         MVC   COMMAND(20),=C'(LINE) = LINE 123456'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        \"CUT\" FUNCTION: COPY DATA TO THE BUFFER                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n*LOOP\nCUT80    OI    LINE1+L'LINE1-1,15      SUPPRESS SIGN\n         UNPK  COMMAND+14(6),LINE1     123456\n         LA    R0,20                   LENGTH OF COMMAND\n         BAL   R14,ISREDIT\n         LTR   R15,R15                 CHECK RETURN CODE\n         BNZ   ERROR200                ISREDIT FAILED\n*\n*        MOVE LINE TO BUFFER\n*\nCUT81    LAE   R2,LINE                 SOURCE TEXT\n         L     R3,HDRLRECL             LENGTH OF SOURCE TEXT\n         SAC   512                     MODE=AR\n         CLI   HDRCOMPR,C'0'           COMPRESS=NONE ?\n         BE    CUT84                   YES, JUMP\n         CLI   HDRCOMPR,C'2'           COMPRESS=CSRCE ?\n         BE    CUT85                   YES, JUMP\n*\n*        TRUNCATE TRAILING BLANKS      (COMPRESS=1)\n*\n         LA    R1,LINE(R3)             FIRST BYTE AFTER LINE\nCUT82    BCTR  R1,0\n         CLI   0(R1),C' '              IS IT A SPACE ?\n         BNE   CUT84                   NO, EXIT\n         BCT   R3,CUT82\n         LA    R3,1                    LENGTH=1\n*\nCUT84    STH   R3,0(,R4)               STORE LENGTH\n         LA    R4,2(,R4)               SKIP LENGTH COUNTER\n         LR    R5,R3                   RECORD SIZE\n         MVCL  R4,R2                   MOVE DATA\n         SAC   0                       MODE=PRIMARY\n         B     CUT88                   NEXT LINE\n*\n*        COMPRESS DATA USING MVS COMPRESSION/EXPANSION SERVICES\n*\nCUT85    SLR   R1,R1                   NO WORK AREA\n         LAE   R6,0(,R4)               SAVE ADDRESS\n         LA    R4,2(,R4)               SKIP COUNT\n         BCTR  R5,0\n         BCTR  R5,0\n.OW10890 LAE   14,0                    PREVENT S0C4 IN CSRCE\n         CSRCESRV SERVICE=COMPRESS     BUFFER<=LINE\n         LR    R1,R4                   CALC LENGTH OF COMPRESSED TEXT\n         SR    R1,R6                   CALC LENGTH OF COMPRESSED TEXT\n         BCTR  R1,0                    CALC LENGTH OF COMPRESSED TEXT\n         BCTR  R1,0                    CALC LENGTH OF COMPRESSED TEXT\n         STH   R1,0(,R6)               SAVE LENGTH OF COMPRESSED TEXT\n****     MVI   0(R4),X'FF'             END OF FILE MARK\n         SAC   0                       MODE=PRIMARY\n         LTR   R15,R15                 OK?\n         BNZ   ERROR500                NO, EXIT\n*\nCUT88    LA    R0,1                    NUMBER OF LINES IN BUFFER\n         AL    R0,HDRLINES             NUMBER OF LINES IN BUFFER\n         ST    R0,HDRLINES             NUMBER OF LINES IN BUFFER\n*\n         AP    LINE1,=P'1'             INCREMENT LINE NUMBER\n         CP    LINE1,LINE2             LAST LINE REACHED?\n         BNH   CUT80                   NOT YET, PROCESS NEXT LINE\n*ENDLOOP\n         ST    R4,HDRNEXTB             SAVE ADDR OF NEXT BYTE\n         L     R4,DSPCORG              POINT TO HEADER\n         SAC   512                     MODE=AR\n         MVC   0(L'HEADER,R4),HEADER   MOVE HEADER FOR \"PASTE\"\n         SAC   0                       MODE=PRIMARY\n         B     EXIT00\n***********************************************************************\n*                                                                     *\n*        \"PASTE\" FUNCTION                                             *\n*                                                                     *\n*        RETRIEVE DATA LINES FROM THE DATA SPACE AND INSERT THEM      *\n*        AFTER &LINE1                                                 *\n*                                                                     *\n***********************************************************************\nPASTE00  LA    R15,12                  DATA SPACE NOT FOUND\n         OC    HDRTCB,HDRTCB           DATA SPACE LOCATED?\n         BZ    EXIT15                  NO, QUIT\n         BAL   R14,VDEFLINE            VDEFINE LINE\n         LA    R2,L'HEADER(,R2)        POINT AT COMPRESSED TEXT\n         L     R8,HDRLINES             NUMBER OF LINES IN BUFFER\n         MVC   COMMAND(35),=C'LINE_AFTER 123456 = DATALINE (LINE)'\n*\n*        GET LINES FROM THE DATA SPACE AND PASS THEM TO ISPF EDIT\n*LOOP\nPASTE50  SAC   512                     MODE=AR\n         LH    R3,0(,R2)               SIZE OF RECORD STORED IN BUFFER\n         LA    R2,2(,R2)               SKIP RCD LEN\n         LAE   R4,LINE                 SOURCE TEXT\n         L     R5,HDRLRECL             LENGTH OF SOURCE TEXT\n         CLI   HDRCOMPR,C'2'           COMPRESS=CSRCE ?\n         BE    PASTE55                 YES, JUMP\n*\n         ICM   R3,B'1000',=C' '        PADDING\n         MVCL  R4,R2                   MOVE FROM BUFFER\n         SAC   0                       MODE=PRIMARY\n         B     PASTE57                 NEXT LINE\n*\n*        EXPAND DATA USING MVS COMPRESSION/EXPANSION SERVICES\n*\nPASTE55  SLR   R1,R1                   NO WORK AREA\n         CSRCESRV SERVICE=EXPAND       BUFFER=>LINE\n         SAC   0                       MODE=PRIMARY\n         LTR   R15,R15                 OK?\n         BNZ   ERROR500                NO, EXIT\n*\n*        INSERT A LINE AFTER CURRENT\n*\nPASTE57  OI    LINE1+L'LINE1-1,15      SUPPRESS SIGN\n         UNPK  COMMAND+11(6),LINE1     123456\n         LA    R0,35                   LENGTH OF THE ISREDIT COMMAND\n         BAL   R14,ISREDIT\n         CH    R15,=H'4'               LINE TRUNCATED?\n         BH    ERROR200                BAD, QUIT\n*\n         AP    LINE1,=P'1'             NEXT LINE NUMBER\n         BCT   R8,PASTE50              KEEP ON DOING IT\n*ENDLOOP\n***********************************************************************\n*                                                                     *\n*        RETURN TO CALLER                                             *\n*                                                                     *\n***********************************************************************\nEXIT00   SLR   R15,R15                 RC=00\n         B     EXIT15\n*\nERROR100 LA    R15,100(,R15)           ISPLINK FAILED (VDEFINE)\n         B     EXIT15\n*\nERROR200 LA    R15,200(,R15)           ISPLINK FAILED (ISREDIT)\n         B     EXIT15\n*\nERROR500 LA    R15,500(,R15)           CSRCESRV FAILED\n         B     EXIT15\n*\nEXIT15   LR    R2,R15                  SAVE RETURN CODE\n         LR    R1,R13                  A(DYNAM)\n         L     R13,4(,R13)\n         STORAGE RELEASE,LENGTH=DYNAML,ADDR=(1) FREE DYNAMIC STORAGE\n         LR    R15,R2                  PASS RETURN CODE\n         RETURN (14,12),RC=(15)        GOBACK TO CALLER WITH RC IN R15\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ISPLINK VDEFINE (LINE) CHAR                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\nVDEFLINE BAKR  R14,0\n         LA    R14,=C'VDEFINE'         FUNCTION\n         LA    R15,=C'LINE '           NAME\n         LA    R0,LINE                 ADDRESS\n         LA    R1,=C'CHAR'             TYPE\n         LA    R2,HDRLRECL             LENGTH\n         STM   R14,R2,TENWORDS         BUILD PARM LIST\n         OI    TENWORDS+16,X'80'       MARK END OF LIST\n         L     R15,ISPLINK@            PICK UP ISPF INTERFACE ADDRESS\n         LA    R1,TENWORDS             PARAM\n         BALR  R14,R15                 GOTO ISPLINK\n         PR\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DEFINE THE DATA SPACE (FUNCTION=CUT)                         *\n*                                                                     *\n*---------------------------------------------------------------------*\nDEFSPC   BAKR  R14,0\n         OC    HDRTCB,HDRTCB           DATA SPACE CREATED ALREADY?\n         BNZ   DEFSPC7                 YES, JUMP\n*\n         PACK  DWD,BLOCKS              SIZE OF DATA SPACE IN BLOCKS\n         CVB   R0,DWD                  SIZE OF DATA SPACE IN BLOCKS\n         ST    R0,HDRBLKS              SIZE OF DATA SPACE IN BLOCKS\n*\n*        RETRIEVE THE TCBTOKEN OF MY JOB-STEP TCB\n*\n         TCBTOKEN TTOKEN=STEPTOKN,     TCBTOKEN OF MY JS TCB           X\n               TYPE=JOBSTEP,                                           X\n               MF=(E,TCBTOKN1)\n         LTR   R15,R15                 OK?\n         LA    R15,1000(,R15)          RC=10NN        TCBTOKEN\n         BNZ   DEFSPC9                 NO, EXIT\n*\n*        DEFINE A DATA SPACE AND ASSIGN OWNERSHIP TO MY JOB-STEP TCB\n*\n         DSPSERV CREATE,                                               X\n               NAME=CLIPNAME,          C'CUTPASTE'                     X\n               GENNAME=YES,            DSPSERV GENERATES A NAME        X\n               OUTNAME=DSPCNAME,       NAME OF DATA SPACE              X\n               BLOCKS=HDRBLKS,         16 MEGS                         X\n               STOKEN=DSPCSTKN,                                        X\n               TTOKEN=STEPTOKN,        TCBTOKEN OF MY JS TCB           X\n               ORIGIN=DSPCORG,                                         X\n               MF=(E,DSPSERV1)\n         LTR   R15,R15                 OK?\n         LA    R15,2000(,R15)          RC=20NN         DSPSERV\n         BNZ   DEFSPC9                 NO, EXIT\n         MVC   HDRTCB,PSATOLD-PSA      OWNER OF THE DATA SPACE\n         MVI   APPEND,C'-'             APPEND OPTION OFF\n*\n*        ADD THE DATA SPACE TO THE PASN-AL TO ALLOW ACESS FROM\n*        ANY TASK IN MY ADDRESS SPACE.\n*\n         ALESERV ADD,                                                  X\n               STOKEN=DSPCSTKN,                                        X\n               ALET=DSPCALET,                                          X\n               AL=PASN,                MAKE IT PUBLIC                  X\n               MF=(E,ALESERV1)\n         LTR   R15,R15                 OK?\n         LA    R15,3000(,R15)          RC=30NN         ALESERV\n         BNZ   DEFSPC9                 NO, EXIT\n*\n*        CREATE A NAME/TOKEN PAIR TO BE ABLE TO RETRIEVE\n*        THE DATA SPACE LATER ON.\n*\n         CALL  IEANTCR,                CREATE A NAME/TOKEN PAIR        X\n               (=A(IEANT_HOME_LEVEL),                                  X\n               CLIPNAME,DSPCSTKN,      NAME/TOKEN                      X\n               =F'0',                  PERSIST OPTION                  X\n               DWD),                                                   X\n               MF=(E,TENWORDS)\n         LTR   R15,R15                 OK?\n         BZ    DEFSPC8                 YES, JUMP\n         LA    R15,4000(,R15)          RC=40NN         IEANTCR\n         B     DEFSPC9                 NO, EXIT\n*\n*        IF THE DATA SPACE EXISTS ALREADY AND I OWN IT,\n*        ISSUE DSPSERV RELEASE TO PREVENT UNNECESSARY PAGING.\n*\nDEFSPC7  CLI   APPEND,C'+'             APPEND OPTION ?\n         BE    DEFSPC8                 YES, DO NOT ISSUE RELEASE\n         CLC   HDRTCB,PSATOLD-PSA      DO I OWN THIS DATA SPACE?\n         BNE   DEFSPC8                 NO, DO NOT ISSUE RELEASE\n         DSPSERV RELEASE,              FREE PAGING SPACE               X\n               STOKEN=DSPCSTKN,                                        X\n               BLOCKS=HDRBLKS,         SIZE                            X\n               START=DSPCORG,          ORIGIN                          X\n               MF=(E,DSPSERV1)\n*\nDEFSPC8  SLR   R15,R15                 RC=0\nDEFSPC9  PR\n*---------------------------------------------------------------------*\n*                                                                     *\n*        EXECUTE ISREDIT FUNCTION                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nISREDIT  ST    R0,TENWORDS+16          LENGTH OF THE COMMAND\n         LA    R15,=C'ISREDIT '        COMMAND\n         LA    R0,TENWORDS+16          LENGTH\n         LA    R1,COMMAND              COMMAND\n         STM   R15,R1,TENWORDS         BUILD PARM LIST\n         OI    TENWORDS+8,X'80'        MARK END OF LIST\n         L     R15,ISPLINK@            ISPF INTERFACE\n         LA    R1,TENWORDS             PARAM\n         BR    R15                     GOTO ISPLINK\n*---------------------------------------------------------------------*\n*                                                                     *\n*        INPUT PARAMETERS                                             *\n*                                                                     *\n*---------------------------------------------------------------------*\nPARM     DSECT\n         DS    H                       LENGTH\nFUNCTION DS    C'C'                    FUNCTION: C/P/D\nCLIPBOARD DS   C'12345678'             CLIP BOARD\nLINE1    DS    Z'123456'               FIRST LINE (.ZF)\nAPPEND   DS    C'+'                    APPEND/REPLACE     (CUT ONLY)\nCOMPRESS DS    C'0'                    COMPRESSION LEVEL  (CUT ONLY)\nLRECL    DS    Z'32767'                MAX RECORD SIZE    (CUT ONLY)\nLINE2    DS    Z'123456'               LAST LINE (.ZL)    (CUT ONLY)\nBLOCKS   DS    Z'123456'               SIZE OF DATA SPACE (CUT ONLY)\n*---------------------------------------------------------------------*\n*                                                                     *\n*        WORKING-STORAGE AREA                                         *\n*                                                                     *\n*---------------------------------------------------------------------*\nDYNAM    DSECT\n         DS    18F\nISPLINK@ DS    V(ISPLINK)\nTENWORDS DS    10F\nTCBTOKN1 TCBTOKEN MF=L\n         DSPSERV MF=(L,DSPSERV1)\nALESERV1 ALESERV MF=L\n*\nSTEPTOKN DS    XL16                    TCBTOKEN OF MY JS TCB\nDWD      DS    D\nCOMMAND  DS    CL40                    ISREDIT COMMAND\n*\n*        NAME/TOKEN PAIR\n*\n         DS    0F\nCLIPNAME DS    C'CUTPASTE',XL8'00'     NAME OF THE CLIP-BOARD\nDSPCSTKN DS    XL8                  0  AS TOKEN\nDSPCALET DS    F                    8  ALET\nDSPCORG  DS    F                   12  ORIGIN\n*\n*        DATA SPACE HEADER\n*\n         DS    0F\nHEADER   DS    0CL32                   DATA SPACE HEADER\nHDRBLKS  DS    F                       NUMBER OF BLOCKS\nHDRTCB   DS    A                       TCB THAT OWNS THE DATA SPACE\nHDRLRECL DS    F                       RECORD LENGTH\nHDRLINES DS    F                       NUMBER OF LINES\nHDRNEXTB DS    A                       NEXT AVAILABLE BYTE\nHDRCOMPR DS    C                       COMPRESSION LEVEL\n         DS    3X                      RESERVED\nDSPCNAME DS    C'12345CUT'             NAME OF DATA SPACE\n*\n         DS    0D\nLINE     DS    CL32767                 RECORD AREA\nDYNAML   EQU   *-DYNAM\n*430     IEANTASM                      NAME/TOKEN EQUATES\nIEANT_HOME_LEVEL EQU 2\n*        IHAPSA\nPSA      DSECT\nPSATOLD  EQU   *+X'021C'               A(TCB)\n         YREGS\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//LKED    EXEC PGM=HEWL,PARM='MAP,RENT'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,DELETE)\n//SYSLIB   DD DSN=SYS1.CSSLIB,DISP=SHR\n//SYSLMOD  DD DSN=CBTTAPE.FILE183.LOAD(CUTPGM),DISP=SHR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DAHANDBK": {"ttr": 5126, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x12\\x00\\x946\\x1f\\x01\\x143o\\x124\\x05z\\x05]\\x00.\\xc3\\xc2\\xe3\\xf4\\xf9\\xf0@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1994-12-27T00:00:00", "modifydate": "2014-12-02T12:34:12", "lines": 1402, "newlines": 1373, "modlines": 46, "user": "CBT490"}, "text": "//SBGOLOBH JOB (ACCT#),DATA-HANDBOOK,\n// CLASS=A,MSGCLASS=X,COND=(0,NE),\n// NOTIFY=&SYSUID\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\nDAHB     TITLE 'DATA AREA HANDBOOK GENERATION PROGRAM - V3.1'\nDAHANDBK START 0\n         SPACE 1\n*---------------------------------------------------------------------*\n* NAME :       DAHANDBK                                               *\n*---------------------------------------------------------------------*\n* DESCRIPTIVE NAME : DATA AREA HANDBOOK GENERATOR                     *\n*---------------------------------------------------------------------*\n* FUNCTION :   THIS PROGRAM IS DESIGNED TO GENERATE A DATA AREA       *\n*              HANDBOOK SIMILIAR TO THE MVS DEBUGGING HANDBOOK.       *\n*              IT DOES THIS BY :                                      *\n*              1) READING THE OUTPUT OF AN ASSEMBLY OF ALL MAPPING    *\n*                 MACROS DESIRED TO BE INCLUDED IN THE HANDBOOK.      *\n*              2) DETERMINING IF IT HAS A MACRO, COMMENT, DATA        *\n*                 EQUATE OR 'CALLED' MACRO.                           *\n*              3) DETERMINE IF THERE IS A LABEL, IF SO THEN THAT IS   *\n*                 USED FOR THE TABLE OF CONTENTS. IF NOT THEN THE     *\n*                 MACRO ITSELF BECOMES THE NAME FOR THE TOC.          *\n*              4) SAVES  OFFSET, SYMBOL AND EQU VALUE.                *\n*                 NOTE : THE EQU VALUE PRINTED IS EDITED FOR ONLY     *\n*                        THE SIGNIFICANT BYTE.                        *\n*              5) AT END OF MACRO DEFINITION - SORT THE SAVED         *\n*                 ENTRIES TO GENERATE A CROSS-REFERENCE USING         *\n*                 A SLICK BUBBLE SORT.                                *\n*---------------------------------------------------------------------*\n* NOTE 1 :     'CALLED' MACROS ARE DETERMINED BY A GENERATED          *\n*              COMMENT IDENTIFYING THEM WITH 'IATY' IN COL 50         *\n*              (THIS IS A JES3 CONVENTION ONLY)                       *\n* NOTE 2 :     ALL CODE IS ASSUMED TO BE PROPERLY ALIGNED             *\n*---------------------------------------------------------------------*\n* PARM :       'L=XX,TITLE'                                           *\n*              WHERE L=XX IS THE PAGE SIZE AND IS OPTIONAL, AND       *\n*              IF SPECIFIED MUST BE FIRST.                            *\n*              ACCEPTED XX VALUE IS FROM 20 UP TO 99 INCLUDED.        *\n*              THE TITLE CONSISTS OF UP TO 45 CHARACTERS TO BE        *\n*              PRINTED ON THE TOP AND BOTTOM OF EVERY PAGE.           *\n*              DEFAULTS : 'L=54,DATA AREA HANDBOOK'                   *\n*---------------------------------------------------------------------*\n* JCL :        EXEC PGM=DAHANDBK,PARM='L=XX,TITLE INFORMATION'        *\n*              INPUT  DD : OUTPUT OF ASSEMBLER                        *\n*              TITLE  DD : GENERATED TABLE OF CONTENTS                *\n*              OUTPUT DD : GENERATED HANDBOOK                         *\n*---------------------------------------------------------------------*\n         EJECT\n*---------------------------------------------------------------------*\n* AUTHOR :     LIONEL DYCK                                            *\n*              ROCKWELL INTERNATIONAL                                 *\n*              P.O. BOX 2515                                          *\n*              SEAL BEACH, CALIF 90740                                *\n*              (213) 594-1125                                         *\n*---------------------------------------------------------------------*\n*              THIS PROGRAM IS A QUICK AND DIRTY ATTEMPT TO REMEDY    *\n*              WHAT IBM DOES NOT SEE AS A PROBLEM. THIS PROGRAM       *\n*              COMES WITH NO GUARENTEE ALTHOUGH THE AUTHOR WILL BE    *\n*              HAPPY TO ACCEPT ANY IMPROVEMENTS THAT YOU MAKE.        *\n*       NOTE : THIS PROGRAM HAS BEEN TESTED WITH THE JES3 1.3.1       *\n*              MACROS ASSEMBLED USING THE ASSEMBLER H.                *\n*---------------------------------------------------------------------*\n         SPACE 1\n*---------------------------------------------------------------------*\n* ORIGIN :     EXTRACTED FROM CBT 92 MAR TAPE,                        *\n*              FILES 437 - SOURCE ASM                                 *\n*                    435 - MACROS ASM                                 *\n*---------------------------------------------------------------------*\n* MODIFIED :   MOINIL P.A.                                            *\n*              COMPUTING CENTRE                                       *\n*              J.R.C. ISPRA ESTABLISHMENT                             *\n*              21020 ISPRA (VA), ITALY                                *\n*---------------------------------------------------------------------*\n* NOTES :   1. ALL CODE RELATIVE TO JES3 IS NOW REMOVED (WE DON'T     *\n*              HAVE IT AT OUR INSTALLATION).                          *\n*           2. MACROS CODING NEEDS NO MORE TO BE PROPERLY ALIGNED.    *\n*---------------------------------------------------------------------*\n* RETURN CODES :                                                      *\n*         0 - OK, NORMAL TERMINATION                                  *\n*         4 - \"GFDATE\" ERROR CODE                                     *\n*         8 - \"GFDATE\" ERROR CODE                                     *\n*        12 - INVALID LENGTH PARM                                     *\n*             (DROP PARM SIZE BACK TO 45 OR LESS CHARACTERS)          *\n*        16 - EXCEEDED 4000 ENTRIES TABLE FOR SYMBOLS                 *\n*             (CHANGE AT LABEL \"NETS\")                                *\n*---------------------------------------------------------------------*\n         EJECT\n         YREGS\n*=====================================================================*\n*        GENERAL REGISTERS USE :                                      *\n*        -----------------------                                      *\n*        R0  = WORK REGISTER                                          *\n*        R1  = CALL PARM POINTER / WORK REGISTER                      *\n*        R2  = WORK REGISTER                                          *\n*        R3  = WORK REGISTER                                          *\n*        R4  = INPUT LINE POINTER                                     *\n*        R5  = CURRENT TABLE ENTRY POINTER (BXLE)                     *\n*        R6  = TABLE ENTRY LENGTH (BXLE)                              *\n*        R7  = LAST TABLE ENTRY POINTER (BXLE)                        *\n*        R8  = 1) LINK REGISTER (TO PRINT OUTPUT : DATA AREA)         *\n*              2) COMPARE ENTRY TABLE POINTER (SORT SYMBOLS)          *\n*              3) 2ND COLUMN ENTRY TABLE POINTER (PRINT SYMBOLS)      *\n*        R9  = TABLE ENTRIES COUNTER                                  *\n*        R10 = UNUSED (FREE FOR 3RD BASE REGISTER IF NEEDED)          *\n*        R11 = 1ST BASE REGISTER                                      *\n*        R12 = 2ND BASE REGISTER                                      *\n*        R13 = SAVE AREA POINTER                                      *\n*        R14 = CALL LINK / WORK REGISTER                              *\n*        R15 = CALL ENTRY / WORK REGISTER                             *\n*=====================================================================*\n         EJECT\nNETS     EQU   10000               NUMBER ENTRIES TABLE FOR SYMBOLS\n         SPACE 1\n         SAVE  (14,12),,'DATA HANDBOOK V3.1'\n         LR    R11,R15\n         USING DAHANDBK,R11\n         LA    R12,4095(,R11)\n         USING DAHANDBK+4095,R12\n         LR    R14,R13\n         LA    R13,=9C'SAVEAREA'\n         ST    R14,4(,R13)\n         ST    R13,8(,R14)\n         EJECT\n*=====================================================================*\n*        PROCESS THE PARM : THE PARM CAN CONTAIN ANY COMMENT TO BE\n*        PLACED ON THE TOP AND BOTTOM OF EACH PAGE WITH THE DATE\n         SPACE 1\n         L     R1,0(R1)            LOAD ADDR OF PARM\n         LH    R2,0(R1)            LOAD LENGTH OF PARM\n         LTR   R2,R2               LENGTH OF ZERO\n         BNP   NOPARM              NO, BYPASS MOVE\n         LA    R3,2(R1)\n         CLC   2(2,R1),=CL2'L='    LINES PER PAGE SPECIFIED ?\n         BNE   CKLEN\n         CH    R2,=H'4'\n         BL    NOPARM\n         TM    4(R1),C'0'\n         BNO   BADPARM\n         TM    5(R1),C'0'\n         BNO   BADPARM\n         PACK  LINEPPG,4(2,R1)\n         SH    R2,=H'5'            REDUCE LENGTH FOR TITLE MOVE\n         BNP   NOPARM\n         CLI   6(R1),C','\n         BNE   BADPARM\n         LA    R3,5(R1)\nCKLEN    CH    R2,=H'45'           CHECK MAX LENGTH\n         BH    BADPARM             INVALID LENGTH PARM\n         BCTR  R2,0                SUBTRACT LENGTH BY 1\n         LTR   R2,R2\n         BNP   NOPARM\n         EX    R2,*+L'*+4          EXECUTE THE MOVE\n         B     CKLPPG\n         MVC   PARM(*-*),0(R3)     <<EXECUTED>>\nMVPARM   MVC   0(*-*,R1),PARM      <<EXECUTED>>\nNOPARM   LA    R2,17\n         MVC   PARM(18),=CL18'DATA AREA HANDBOOK'\nCKLPPG   CP    LINEPPG,=PL2'+20'\n         BL    BADPARM             INVALID NUMBER OF LINES PER PAGE\n         EJECT\n*=====================================================================*\n*        INITIALIZATION\n         SPACE 1\n         MVC   BPARM,PARM\n         MVC   TPARM,PARM\n         LA    R1,L'PARM-1\n         SR    R1,R2\n         SRL   R1,1\n         LA    R1,COVPARM(R1)\n         EX    R2,MVPARM\n         SP    LINEPPG,=PL1'+2'    REDUCE BY 2 FOR BOTTOM OF PAGE\n         ZAP   COLWK,LINEPPG\n         CVB   R5,COLWK            CONVERT TO BINARY\n         SH    R5,=H'5'            REDUCE BY 5 LINES\n         ST    R5,COL#             SET COLUMN'S LINES PER PAGE\n         XR    R4,R4\n         M     R4,=A(SYML)         MULTIPLY BY ENTRY LENGTH\n         ST    R5,COL2PD           SET 2ND COLUMN POINTER DISPLACEMENT\n         TIME  DEC,PRVLINE,DATETYPE=MMDDYYYY,LINKAGE=SYSTEM\n         UNPK  TLDATE+0(5),PRVLINE+10(3)  YYYY%\n         MVI   TLDATE+4,C'/'              YYYY/\n         UNPK  TLDATE+5(3),PRVLINE+8(2)   YYYY/MM%\n         MVI   TLDATE+7,C'/'              YYYY/MM/\n         UNPK  TLDATE+8(3),PRVLINE+9(2)   YYYY/MM/DD%\n         MVI   TLDATE+10,C' '             YYYY/MM/DD\n         MVC   DATE,TLDATE\n         MVC   COVDATE,TLDATE\n        OPEN   (MAPIN,,BOOKOUT,OUTPUT,TITLE,OUTPUT)\n         ZAP   COVWK,LINEPPG\n         CVB   R3,COVWK\n         XR    R2,R2\n         LA    R1,3\n         DR    R2,R1\n         AR    R2,R3\n         BCTR  R3,0\n         STM   R2,R3,CV#2\n         LA    R3,2                PRINT TWICE THE COVER PAGE\nPT1     PUT    TITLE,COV1\n         L     R2,CV#1\nPT2     PUT    TITLE,BLANKS\n         BCT   R2,PT2\n        PUT    TITLE,COV2\n         L     R2,CV#2\nPT3     PUT    TITLE,BLANKS\n         BCT   R2,PT3\n        PUT    TITLE,COV3\n         BCT   R3,PT1\n         L     R2,GFTSIZ\n        GETMAIN R,LV=(R2)\n         ST    R1,TABSTA           SAVE TABLE ADDRESS\n         A     R1,TABSIZ\n         L     R2,=A(SYML)         LOAD ENTRY LENGTH\n         ST    R2,TABENT           SAVE\n         SR    R1,R2\n         ST    R1,TABEND           SAVE END OF TABLE ADDRESS\n         USING TBD,R5\n         LM    R5,R7,TABLM         R5-R6-R7 = TABLE POINTERS (BXLE)\n         XC    SYM(SYML),SYM       CLEAR TABLE\n         BXLE  R5,R6,*-6\n         LM    R5,R7,TABLM         LOAD IT\n         XR    R9,R9               R9 = TABLE ENTRIES COUNTER\n         LA    R4,PRVLINE\n         EJECT\n*=====================================================================*\n*        PROCESS INPUT (ASSEMBLY OUTPUT LISTING)\n         SPACE 1\n         USING ASSLNE,R4\nREAD     MVC   PRVLINE(ASSLEN),ASSLNE\n        GET    MAPIN\n         LR    R4,R1               SAVE -> INPUT RECORD\n         TM    ASSSTN+4,C'0'       ANYTHING HERE\n         BO    *+L'*+14            YES\n         CLC   ASSFLG(2),=CL2'+ '  NO, MAY BE A GENERATED COMMENT ?\n         BE    GENED               YES\n         B     READ                NO, KEEP LOOKING\n         CLI   ASSFLG,C'*'         COMMENT ?\n         BE    READ\n         CLI   ASSFLG,C'+'         GENERATED CARD ?\n         BE    GENED               YES\n         CLI   ASSFLG,C' '         POSSIBLE MACRO CARD ?\n         BNE   READ                NO, IGNORE IT\n*--------------------------------- GET MACRO NAME --------------------*\n         BAS   R14,GTPTR           GO GET POINTERS\n         ICM   R1,B'1111',PTROPE\n         BZ    READ                NO MACRO NAME\n         CLC   0(4,R1),=CL4'END '  IS THIS THE END ?\n         BE    EOF                 YES, WE CAN STOP HERE\n         CLC   0(5,R1),=CL5'COPY ' IS THIS A COPY ?\n         BE    READ                YES, IGNORE IS\n         CLC   0(3,R1),=CL3'DS '   IS THIS A DS ?\n         BE    READ                YES, IGNORE IS\n         CLC   0(3,R1),=CL3'DC '   IS THIS A DC ?\n         BE    READ                YES, IGNORE IS\n         CLC   0(4,R1),=CL4'EQU '  IS THIS AN EQU ?\n         BE    READ                YES, IGNORE IS\n         CLC   0(6,R1),=CL6'DSECT ' IS THIS A DSECT CARD ?\n         BE    READ                YES, IGNORE IT\n         CLC   0(6,R1),=CL6'PRINT ' IS THIS A PRINT CARD ?\n         BE    READ                YES, IGNORE IT\n         CLC   0(5,R1),=CL5'PUSH ' IS THIS A PUSH CARD ?\n         BE    READ                YES, IGNORE IT\n         TM    SW1,SWHMC\n         BO    DOSORT\n         USING DLDSECT,R8\nDOIT     MVC   SOFF,BLANKS\n         MVC   TITLEMCL(L'TITLEMAC),BLANKS\n         L     R2,PTROPE           MACRO NAME\n         OI    SW1,SWHMC\n         XR    R1,R1\n         IC    R1,LGHOPE\n         LA    R0,L'TITLEMCO\n         CLR   R1,R0\n         BNH   *+L'*+2\n         LR    R1,R0\n         BCT   R1,*+L'*+6\n         MVC   TITLEMCO(*-*),0(R2) <<EXECUTED>>\n         EX    R1,*-6\n         ICM   R2,B'1111',PTRLAB   LABEL PRESENT ?\n         BZ    MVVL                NO\n         XR    R1,R1\n         IC    R1,LGHLAB\n         LA    R0,L'TITLEMCL\n         CLR   R1,R0\n         BNH   *+L'*+2\n         LR    R1,R0\n         BCT   R1,*+L'*+6\n         MVC   TITLEMCL(*-*),0(R2) <<EXECUTED>>\n         EX    R1,*-6\nMVVL     ICM   R2,B'1111',PTRVAL   ARGUMENT(S) PRESENT ?\n         BZ    NOVL                NO\n         XR    R1,R1\n         IC    R1,LGHVAL\n         LA    R0,L'TITLEMCV\n         CLR   R1,R0\n         BNH   *+L'*+2\n         LR    R1,R0\n         BCT   R1,*+L'*+6\n         MVC   TITLEMCV(*-*),0(R2) <<EXECUTED>>\n         EX    R1,*-6\nNOVL     MVC   TLMAC,TITLEMCO\n         MVC   TLMAC2,BLANKS\n         LA    R1,TLMAC2+L'TLMAC2-1\n         LA    R2,TLMAC+L'TLMAC-1\n         LA    R3,L'TLMAC\nMBLM     CLI   0(R2),C' '\n         BE    MINC\n         MVC   0(1,R1),0(R2)\n         BCTR  R1,0\nMINC     BCTR  R2,0\n         BCT   R3,MBLM\n         LA    R8,OLINE\n         MVC   DLSYM,TLMAC\n         BAS   R14,MVDEF           GO MOVE DEFINITION\n         NOP   0                   NONE, CONTINUE\n         OI    SW1,SWTPG\n         ST    R4,CURPTR           SAVE\n         LA    R4,PRVLINE          CHECK IF PRECEEDED BY A DSECT\n         BAS   R14,GTPTR           GO GET POINTERS\n         ICM   R1,B'1111',PTROPE\n         BZ    *+L'*+10            NO OPERATION NAME\n         CLC   0(6,R1),=CL6'DSECT ' IS THIS A DSECT CARD ?\n         BE    PRVDS               YES\n         L     R4,CURPTR           NO, NONE, RESTORE\n         LA    R3,OLINE\n         BAS   R8,PRTPAGE          GO TO PRINT ON A NEW PAGE\n         B     READ\nPRVDS    LA    R8,ALINE\n         MVC   DLDEF(6),=CL6'DSECT ' SAY DSECT\n         BAS   R14,MVLAB           GO MOVE LABEL IF ANY\n         LTR   R2,R2               ANY LABEL ?\n         BNZ   *+L'*+6             YES\n         MVC   SYM,BLANKS          NO, FORCE DUMMY DSECT\n         MVC   VAL,BLANKS\n         MVC   VAL+1(5),=CL6'DSECT '\n         MVI   VAL,C'-'\n         MVI   VAL+6,C'-'\n         MVC   OFF,ASSLOC+2        MOVE OFFSET OF LABEL\n         MVC   DLSYM,SYM           MOVE TO OUTPUT LINE\n         MVC   TITLENMD,DLSYM\n         LA    R3,DLDEF+5\n         BAS   R14,MVCOM           GO SET COMMENT IF ANY\n         B     DSCMPL              +0 - OK, COMMENT SET\n         LA    R3,ALINE            +4 - \"WLINE\" ALSO SET\n         BAS   R8,PRTPAGE          GO TO PRINT ON A NEW PAGE\n         OI    SW1,SWDPG\n         LA    R3,WLINE\n         BAS   R8,PRTDATA          GO TO PRINT\n         B     DSTERM\nDSCMPL   LA    R3,ALINE\n         BAS   R8,PRTPAGE          GO TO PRINT ON A NEW PAGE\n         OI    SW1,SWDPG\nDSTERM   L     R4,CURPTR           RESTORE\n         LA    R3,OLINE\n         BAS   R8,PRTDATA          GO TO PRINT\n         BAS   R14,INCRSYM         GO ADJUST TABLE\n         B     READ\n*--------------------------------- MACRO GENERATED LINE --------------*\nGENED    CLI   ASSGEN,C'*'         GENERATED COMMENT ?\n         BE    CKGCM               YES\n         BAS   R14,GTPTR           GO GET POINTERS\n         ICM   R1,B'1111',PTROPE   PSEUDO PRESENT ?\n         BZ    READ                NO, SKIP THIS RECORD\n         CLC   0(5,R1),=CL5'PUSH ' IS THIS A PUSH ?\n         BE    READ                YES, SKIP\n         CLC   0(4,R1),=CL4'POP '  IS THIS A POP ?\n         BE    READ                YES, SKIP\n         LA    R8,OLINE\n         CLC   0(4,R1),=CL4'EQU '  IS THIS AN EQUATE ?\n         BE    ISEQU               YES\n         CLC   0(6,R1),=CL6'DSECT ' IS THIS A DSECT ?\n         BE    ISDSECT             YES\n         CLC   0(4,R1),=CL4'ORG '  IS THIS AN ORG ?\n         BE    ISORG               YES\n         CLC   0(3,R1),=CL3'DS '   A DS ?\n         BE    ISDSDC              YES\n         CLC   0(3,R1),=CL3'DC '   A DC ?\n         BE    ISDSDC              YES\n         BAS   R14,MVLAB           GO MOVE LABEL IF ANY\n         LTR   R2,R2               LABEL PRESENT ?\n         BNZ   INST1L              YES\n         ST    R4,CURPTR           SAVE\n         LA    R4,PRVLINE          CHECK PREVIOUS\n         CLI   ASSCNT,C' '         WAS CONTINUATION INDICATED ?\n         BNE   *+L'*+8             YES, THIS IS A COMMENT CONTINUATION\n         L     R4,CURPTR           NO, RESTORE\n         B     INST2L\n*- - - - COMMENT CONTINUATION LINE - - - - - - - - - - - - - - - - - -*\n         L     R4,CURPTR           RESTORE\n         LA    R1,ASSGEN+L'ASSGEN-1\n         CLI   0(R1),C' '          SEARCH END OF COMMENT\n         BNE   *+L'*+4\n         BCT   R1,*-8\n         L     R2,PTROPE           GET START OF COMMENT\n         ST    R2,PTRCOM           SET IT\n         SR    R1,R2\n         LA    R1,1(R1)\n         STC   R1,LGHCOM           SET LENGTH OF COMMENT\n         CLI   LGHCOM,L'DLCOMM\n         BH    MVCM2               NOT IN NORMAL TARGET\nMVCM1    LA    R3,DLCOMM\n         BCT   R1,*+L'*+6\n         MVC   0(*-*,R3),0(R2)     <<EXECUTED>>\n         EX    R1,*-6\n         LA    R3,OLINE\n         BAS   R8,PRTDATA          GO TO PRINT\n         B     READ\nMVCM2    BAS   R15,CMPRSS          TRY TO COMPRESS COMMENT\n         CLI   ZCMPL,L'DLCOMM\n         BH    MVCM3               ALSO NOT IN NORMAL TARGET\n         XR    R1,R1\n         IC    R1,ZCMPL\n         LA    R2,ZCMPR\n         B     MVCM1\nMVCM3    CLI   LGHCOM,L'DLCOMM+6\n         BH    MVCM5               NOT IN ALTERNATE TARGET\n         XR    R1,R1\n         IC    R1,LGHCOM\nMVCM4    LA    R3,DLCOMM-6\n         B     MVCM1+L'MVCM1\nMVCM5    CLI   ZCMPL,L'DLCOMM+6\n         BH    MVCM6               AGAIN NOT IN ALTERNATE TARGET\n         XR    R1,R1\n         IC    R1,ZCMPL\n         LA    R2,ZCMPR\n         B     MVCM4\nMVCM6    XR    R1,R1               WHAT'S THAT ? MOVE IT COMPRESSED\n         IC    R1,ZCMPL\n         LA    R3,DLCOMM+L'DLCOMM-1\n         SR    R3,R1\n         LA    R2,ZCMPR\n         B     MVCM4\n*- - - - INSTRUCTION LINE  - - - - - - - - - - - - - - - - - - - - - -*\nINST1L   MVC   DLSYM,SYM           MOVE TO OUTPUT LINE\n         MVC   OFF,ASSLOC+2        MOVE OFFSET OF LABEL\nINST2L   MVC   DLOFF,ASSLOC+2      MOVE OFFSET TO OUTPUT LINE\n         MVC   SOFF,ASSLOC+2       MOVE OFFSET TO SAVE\n         LA    R3,DLDEF            -> OUTPUT DEFINITION\n         L     R2,PTROPE\n         XR    R1,R1\n         IC    R1,LGHOPE\n         BCT   R1,*+L'*+6\n         MVC   0(*-*,R3),0(R2)     <<EXECUTED>>\n         EX    R1,*-6\n         LA    R3,2(R1,R3)\n         ICM   R2,B'1111',PTRVAL\n         BZ    INST3L              NONE, SKIP\n         XR    R1,R1\n         IC    R1,LGHVAL\n         BCT   R1,*+L'*+6\n         MVC   0(*-*,R3),0(R2)     <<EXECUTED>>\n         EX    R1,*-6\n         LA    R3,2(R1,R3)\nINST3L   LA    R0,DLCOMM+L'DLCOMM-1\n         LA    R1,2+L'ASSOBJ(R3)\n         CLR   R1,R0\n         BNH   INST4L\n         LA    R3,OLINE\n         BAS   R8,PRTDATA          GO TO PRINT\n         LA    R8,OLINE\n         LA    R3,DLDEF-2          -> OUTPUT DEFINITION\n         B     INST4L+L'INST4L\nINST4L   MVI   0(R3),C':'\n         MVC   2(L'ASSOBJ,R3),ASSOBJ\n         LA    R3,2+L'ASSOBJ(R3)\n         CLI   0(R3),C' '\n         BNE   *+L'*+4\n         BCT   R3,*-8\n         LA    R1,2(R3)\n         CLR   R1,R0\n         BH    *+L'*+8\n         MVI   2(R3),C'/'\n         LA    R3,2(R3)\n         BAS   R14,MVCOM           GO SET COMMENT IF ANY\n         B     INCMPL              +0 - OK, COMMENT SET\n         LA    R3,OLINE            +4 - \"WLINE\" ALSO SET\n         BAS   R8,PRTDATA          GO TO PRINT\n         LA    R3,WLINE\n         B     INCMPL+L'INCMPL\nINCMPL   LA    R3,OLINE\n         BAS   R8,PRTDATA          GO TO PRINT\n         BAS   R14,INCRSYM         GO ADJUST TABLE\n         B     READ\n*- - - - EQU LINE - - - - - - - -  - - - - - - - - - - - - - - - - - -*\nISEQU    BAS   R14,MVLAB           GO MOVE LABEL IF ANY\n         LTR   R2,R2               LABEL PRESENT ?\n         BZ    READ                NO, WHAT'S THAT, SKIP\n         MVC   DLSYM,SYM           MOVE TO OUTPUT LINE\n         BAS   R14,MVDEF           GO MOVE DEFINITION\n         B     READ                NONE, WHAT'S THAT, SKIP\n         LA    R3,DLDEF+2(R1)\n         CLC   DLDEF(2),=CL2'* '\n         BNE   NOTSELF\n         MVC   OFF,ASSAD2+1        MOVE OFFSET OF LABEL (= VALUE)\n         MVC   DLOFF,OFF           MOVE OFFSET TO OUTPUT LINE\n         MVC   SOFF,OFF            MOVE OFFSET TO SAVE\n         B     SETEQU\nNOTSELF  MVC   OFF,SOFF\n         OC    VAL,BLANKS          INITIALIZE VAL AS BLANKS\n         CLI   ASSAD1+3,C'A'\n         BL    NOTFEQU\n         MVC   VAL(8),ASSAD1+3\n         MVI   VAL+8,C''''\n         LA    R1,8\n         B     GOTEQU\nNOTFEQU  CLC   ASSAD2-1(2),=CL2' 0' 3 BYTE EQU ?\n         BE    NOT3EQU\n         MVC   VAL(6),ASSAD2-1\n         MVI   VAL+6,C''''\n         LA    R1,6\n         CLI   VAL,C' '            BLANK FOR FIRST ?\n         BNE   GOTEQU              NO\n         OI    VAL,C'0'            YES, MAKE ZERO\n         B     GOTEQU\nNOT3EQU  CLC   ASSAD2+1(2),=CL2'00' HALF WORD EQU ?\n         BE    NOTHEQU\n         MVC   VAL(4),ASSAD2+1\n         MVI   VAL+4,C''''\n         LA    R1,4\n         B     GOTEQU\nNOTHEQU  MVC   VAL(2),ASSAD2+3     ASSUME 1 BYTE EQU\n         MVI   VAL+2,C''''\n         LA    R1,2\nGOTEQU   EX    R1,CMPRVL\n         BE    SETEQU\n         LA    R0,DLCOMM+L'DLCOMM-1\n         LA    R2,4(R1,R3)\n         CLR   R2,R0\n         BNH   CPLEQU\n         LA    R3,OLINE\n         BAS   R8,PRTDATA          GO TO PRINT\n         LA    R8,OLINE\n         LA    R3,DLDEF-2          -> OUTPUT DEFINITION\n         B     CPLEQU+L'CPLEQU\nCPLEQU   MVI   0(R3),C':'\n         MVC   2(2,R3),=CL2'X'''\n         EX    R1,MOVEVL           MOVE EQU VALUE\n         LA    R3,5(R1,R3)\nSETEQU   BAS   R14,MVCOM           GO SET COMMENT IF ANY\n         B     EQCMPL              +0 - OK, COMMENT SET\n         LA    R3,OLINE            +4 - \"WLINE\" ALSO SET\n         BAS   R8,PRTDATA          GO TO PRINT\n         LA    R8,WLINE\n         B     EQCMPL+L'EQCMPL\nEQCMPL   LA    R3,OLINE\n         BAS   R8,PRTDATA          GO TO PRINT\n         BAS   R14,INCRSYM         GO ADJUST TABLE\n         B     READ\nCMPRVL   CLC   DLVAL(*-*),VAL      <<EXECUTED>>\nMOVEVL   MVC   4(*-*,R3),VAL       <<EXECUTED>>\n*- - - - DSECT LINE - - - - - - -  - - - - - - - - - - - - - - - - - -*\nISDSECT  BAS   R14,MVLAB           GO MOVE LABEL IF ANY\n         LTR   R2,R2               LABEL PRESENT ?\n         BNZ   *+L'*+6             YES\n         MVC   SYM,BLANKS          NO, FORCE DUMMY DSECT\n         MVC   DLSYM,SYM           MOVE TO OUTPUT LINE\n         MVC   DLDEF(6),=CL6'DSECT ' SAY DSECT\n         MVC   VAL,BLANKS\n         MVC   VAL+1(5),=CL6'DSECT '\n         MVI   VAL,C'-'\n         MVI   VAL+6,C'-'\n         MVC   OFF,ASSLOC+2        MOVE OFFSET OF LABEL\n         MVC   DLOFF,OFF           MOVE OFFSET TO OUTPUT LINE\n         MVC   SOFF,OFF            MOVE OFFSET TO SAVE\n         MVC   TITLENMD,DLSYM\n         LA    R3,DLDEF+5\n         OI    SW1,SWDSH+SWABL+SWDPG\n         BAS   R14,MVCOM           GO SET COMMENT IF ANY\n         B     IDCMPL              +0 - OK, COMMENT SET\n         LA    R3,OLINE            +4 - \"WLINE\" ALSO SET\n         BAS   R8,PRTDATA          GO TO PRINT\n         LA    R3,WLINE\n         B     IDCMPL+L'IDCMPL\nIDCMPL   LA    R3,OLINE\n         BAS   R8,PRTDATA          GO TO PRINT\n         BAS   R14,INCRSYM         GO ADJUST TABLE\n         B     READ\n*- - - - ORG LINE - - - - - - - -  - - - - - - - - - - - - - - - - - -*\nISORG    MVC   DLDEF(4),=CL4'ORG ' SAY ORG\n         MVC   DLOFF,ASSAD2+1      MOVE OFFSET TO OUTPUT LINE\n         ICM   R2,B'1111',PTRVAL   -> INPUT DEFINITION\n         BZ    ISORGN              NONE, SKIP\n         XR    R1,R1\n         IC    R1,LGHVAL\n         BCT   R1,*+L'*+6\n         MVC   DLDEF+4(*-*),0(R2)  <<EXECUTED>>\n         EX    R1,*-6\nISORGN   OI    SW1,SWDSH\n         LA    R3,OLINE\n         BAS   R8,PRTDATA          GO TO PRINT\n         B     READ\n*- - - - DS-DC LINE - - - - - - -  - - - - - - - - - - - - - - - - - -*\nISDSDC   BAS   R14,MVDEF           GO MOVE DEFINITION\n         B     READ                NONE, WHAT'S THAT, SKIP\n         LA    R3,DLDEF+2(R1)\n         BAS   R14,MVLAB           GO MOVE LABEL IF ANY\n         LTR   R2,R2               LABEL PRESENT ?\n         BZ    *+L'*+12            NO, SKIP\n         MVC   DLSYM,SYM           MOVE TO OUTPUT LINE\n         MVC   OFF,ASSLOC+2        MOVE OFFSET OF LABEL\n         MVC   DLOFF,ASSLOC+2      MOVE OFFSET TO OUTPUT LINE\n         MVC   SOFF,ASSLOC+2       MOVE OFFSET TO SAVE\n         BAS   R14,MVCOM           GO SET COMMENT IF ANY\n         B     ISCMPL              +0 - OK, COMMENT SET\n         LA    R3,OLINE            +4 - \"WLINE\" ALSO SET\n         BAS   R8,PRTDATA          GO TO PRINT\n         LA    R8,WLINE\n         B     ISCMPL+L'ISCMPL\nISCMPL   LA    R3,OLINE\n         BAS   R8,PRTDATA          GO TO PRINT\n         BAS   R14,INCRSYM         GO ADJUST TABLE\n         B     READ\n*- - - - COMMENT LINE - - - - - -  - - - - - - - - - - - - - - - - - -*\nCKGCM    CLI   ASSGEN+1,C' '       PROCESS CONTINUATION IF ANY\n         BNE   READ                NOT FOR ME, IGNORE\n         CLC   ASSGEN+1(50),BLANKS\n         BE    READ                PROBABLY BLANKS, IGNORE\n         CLC   ASSGEN+1(20),BLANKS\n         BNE   READ                NOT FOR ME, IGNORE\n         BAS   R14,GTPTR           GO GET POINTERS\n         LA    R8,OLINE\n         BAS   R14,MVCOMS          GO SET COMMENT IF ANY\n         LA    R3,OLINE\n         BAS   R8,PRTDATA          GO TO PRINT\n         B     READ\n         DROP  R8\n         DROP  R4\n         EJECT\n*=====================================================================*\n*        PRINT CROSS REFERENCE LIST\n         SPACE 1\n*------- SORT THE SYMBOLS TABLE\n         SPACE 1\nEOF      OI    SW2,SWEOF\n         SPACE 1\nDOSORT   NI    SW1,255-SWHMC\n         LTR   R9,R9               ANY TO SORT\n         BNP   OFFCROS             NO, SKIP IT\n        PUT    BOOKOUT,DASHLINE\n         BAS   R8,PRTBOTT          GO TO PRINT BOTTOM\n         LM    R5,R6,TABSTA        -> TABLE\nSORTL1   BCT   R9,*+L'*+4          COUNT OF ENTRIES TO SORT\n         B     ENDSORT\n         LR    R7,R9\n         LA    R8,0(R5,R6)\n         USING TBDBIS,R8\nSORTL2   CLC   SYM,SYMB\n         BL    BUMPIT\n         BH    *+L'*+10\n         CLC   PGE,PGEB\n         BNH   BUMPIT\n         XC    SYM(SYML),SYMB      SWAP\n         XC    SYMB(SYML),SYM      ENTRIES\n         XC    SYM(SYML),SYMB      QUICKLY\nBUMPIT   AR    R8,R6\n         BCT   R7,SORTL2\n         AR    R5,R6\n         B     SORTL1\n         DROP  R8\n         SPACE 1\n*------- PRINT THE SYMBOLS TABLE\n         SPACE 1\nENDSORT  LM    R5,R7,TABLM\n         LR    R8,R5               -> TO FIRST COLUMN\nPSTRT    L     R3,COL#             ENTRIES PER COLUMN VALUE\n         CLR   R5,R7               END OF TABLE ?\n         BH    OFFCROS             YES\n         CLI   SYM,0               NO, NULL ENTRY ?\n         BE    OFFCROS             ALL DONE\n         A     R8,COL2PD           AND POINT TO 2ND COLUMN\n         USING TBDBIS,R8\n         AP    PAGECTR,=PL1'+1'\n         UNPK  PAGE(5),PAGECTR\n         OI    PAGE+4,C'0'\n        PUT    BOOKOUT,TL1\n        PUT    BOOKOUT,TLCR\n        PUT    BOOKOUT,BLANKS\n        PUT    BOOKOUT,CTITLE\n        PUT    BOOKOUT,CTD\nPLOOP    CLR   R5,R7               END OF TABLE ?\n         BH    ENDTBL              YES\n         CLI   SYM,0               NO, NULL ENTRY ?\n         BE    ENDTBL              YES, ALL DONE\n         MVC   COLSYM,SYM\n         MVC   COLOFF,OFF\n         MVC   COLPGE,PGE\n         CLI   VAL,C'-'\n         BNE   *+L'*+10\n         MVC   COLX1(L'VAL),VAL\n         B     NOVALA\n         CLI   VAL,C'A'\n         BL    NOVALA\n         MVC   COLX1,=CL2'X'''\n         MVC   COLVAL,VAL\n         OC    COLOFF,BLANKS       INSURE REAL CHARACTERS\nNOVALA   TM    SW2,SWLCB\n         BO    NOVALB\n         CLR   R8,R7               END OF TABLE ?\n         BH    *+L'*+8             YES\n         CLI   SYMB,0              NO, NULL ENTRY ?\n         BNE   *+L'*+8             NO\n         OI    SW2,SWLCB           YES\n         B     NOVALB\n         MVC   COLSYMB,SYMB\n         MVC   COLOFFB,OFFB\n         MVC   COLPGEB,PGEB\n         CLI   VALB,C'-'\n         BNE   *+L'*+10\n         MVC   COLX1B(L'VALB),VALB\n         B     NOVALB\n         CLI   VALB,C'A'\n         BL    NOVALB\n         MVC   COLX1B,=CL2'X'''\n         MVC   COLVALB,VALB\n         OC    COLOFFB,BLANKS      INSURE REAL CHARACTERS\n         DROP  R8\nNOVALB  PUT    BOOKOUT,OLINE\n         MVC   OLINE,BLANKS        CLEAR OUTPUT LINE\n         AR    R5,R6\n         AR    R8,R6\n         BCT   R3,PLOOP\n         TM    SW2,SWLCB\n         BZ    *+L'*+8\nENDTBL   NI    SW2,255-SWLCB\n         OI    SW2,SWECR\n         MVC   BPAGE1,PAGE\n         MVC   BPAGE2,PAGE\n         MVC   BOTMAC1,TLMAC\n         MVC   BOTMAC2,TLMAC2\n         LTR   R3,R3\n         BNP   DLSTSX\nCKLSTS   PUT   BOOKOUT,BLANKS\n         BCT   R3,CKLSTS\nDLSTSX  PUT    BOOKOUT,BOTTEMTL\n        PUT    BOOKOUT,BOTTEMTO\n         TM    SW2,SWECR\n         BO    OFFCROS\n         LR    R5,R8               -> TO NEXT FIRST COLUMN\n         B     PSTRT\n         SPACE 1\n*------- RESET THE SYMBOLS TABLE (BACK TO THE NEXT)\n         SPACE 1\nOFFCROS  TM    SW2,SWEOF\n         BO    STOPALL\n         NI    SW2,255-SWECR-SWLCB\n         LM    R5,R7,TABLM\n         XC    SYM(SYML),SYM       CLEAR TABLE\n         BXLE  R5,R6,*-6\n         LM    R5,R7,TABLM\n         XR    R9,R9               INITIALIAZE COUNTER\n         B     DOIT\n         EJECT\n*=====================================================================*\n*        R O U T I N E S\n         SPACE 1\n         USING ASSLNE,R4\n         SPACE 1\n*- - - - - - - - - - - - - - - - - GET POINTERS ROUTINE - - - - - - - -\n*              R0-R1-R2-R3 = WORK REGISTERS\n*              R4 = INPUT LINE POINTER\n*              R14 = LINK REGISTER\n*              AT END : POINTERS TO LABEL/OPERATION/VALUE/COMMENT SET\nGTPTR    LA    R0,L'ASSGEN\n         LA    R1,ASSGEN\n         XC    SCANS(SCANL),SCANS\n         CLI   0(R1),C'*'          COMMENT LINE ?\n         BE    GTPTRC1             YES\n         CLI   0(R1),C' '          NO, LABEL PRESENT ?\n         BE    GTPTRO1             NO\n         ST    R1,PTRLAB           YES, SET LABEL START POINTER\n         LR    R3,R1\nGTPTRL1  LA    R1,1(R1)\n         BCT   R0,*+L'*+4\n         B     *+L'*+8\n         CLI   0(R1),C' '\n         BNE   GTPTRL1\n         LR    R2,R1\n         SR    R2,R3\n         STC   R2,LGHLAB           SET LABEL LENGTH\n         LTR   R0,R0\n         BZR   R14\nGTPTRO1  LA    R1,1(R1)            SEARCH NEXT\n         BCT   R0,*+L'*+2\n         BR    R14\n         CLI   0(R1),C' '\n         BE    GTPTRO1\n         ST    R1,PTROPE           SET OPERATION POINTER\n         LR    R3,R1\nGTPTRO2  LA    R1,1(R1)\n         BCT   R0,*+L'*+4\n         B     *+L'*+8\n         CLI   0(R1),C' '\n         BNE   GTPTRO2\n         LR    R2,R1\n         SR    R2,R3\n         STC   R2,LGHOPE           SET OPERATION LENGTH\n         LTR   R0,R0\n         BZR   R14\n         CLC   0(6,R3),=CL6'DSECT ' IS THIS A DSECT ?\n         BE    GTPTRC1             YES\nGTPTRV1  LA    R1,1(R1)            SEARCH NEXT\n         BCT   R0,*+L'*+2\n         BR    R14\n         CLI   0(R1),C' '\n         BE    GTPTRV1\n         ST    R1,PTRVAL           SET VALUE POINTER\n         LR    R3,R1\n         NI    SW2,255-SWQUO\nGTPTRV2  LA    R1,1(R1)\n         BCT   R0,*+L'*+4\n         B     GTPTRV5\n         TM    SW2,SWQUO\n         BO    GTPTRV3\n         CLI   0(R1),C''''         QUOTE ?\n         BNE   GTPTRV4             NO\n         OI    SW2,SWQUO\n         B     GTPTRV2\nGTPTRV3  CLI   0(R1),C''''         QUOTE ?\n         BNE   GTPTRV2             NO\n         NI    SW2,255-SWQUO\n         B     GTPTRV2\nGTPTRV4  CLI   0(R1),C' '\n         BNE   GTPTRV2\nGTPTRV5  LR    R2,R1\n         SR    R2,R3\n         STC   R2,LGHVAL           SET VALUE LENGTH\n         LTR   R0,R0\n         BZR   R14\nGTPTRC1  LA    R1,1(R1)            SEARCH NEXT\n         BCT   R0,*+L'*+2\n         BR    R14\n         CLI   0(R1),C' '\n         BE    GTPTRC1\n         CLI   0(R1),C'-'          COMMENT ALIGNMENT ?\n         BE    GTPTRC1             YES\n         CLI   0(R1),C'.'\n         BE    GTPTRC1             YES\n         CLI   0(R1),C','\n         BE    GTPTRC1             YES\n         ST    R1,PTRCOM           SET COMMENT POINTER\n         LA    R1,ASSGEN+L'ASSGEN-1\n         CLI   0(R1),C' '\n         BNE   *+L'*+6\n         BCTR  R1,0\n         BCT   R0,*-10\n         STC   R0,LGHCOM           SET COMMENT LENGTH\n         BR    R14\n*- - - - - - - - - - - - - - - - - MOVE LABEL ROUTINE - - - - - - - - -\n*              R0-R1 = WORK REGISTERS\n*              R2 = LABEL POINTER (AT EXIT)\n*              R5 = CURRENT ENTRY TABLE POINTER\n*              R14 = LINK REGISTER\n*              AT END : SYMBOL (LABEL) SET IN TABLE\nMVLAB    ICM   R2,B'1111',PTRLAB   LABEL PRESENT ?\n         BZR   R14                 NO\n         MVC   SYM,BLANKS          YES, MOVE LABEL\n         LA    R0,L'SYM\n         XR    R1,R1\n         IC    R1,LGHLAB\n         CLR   R1,R0\n         BNH   *+L'*+2\n         LR    R1,R0               TRUNCATE LABEL\n         BCT   R1,*+L'*+6\n         MVC   SYM(*-*),0(R2)      <<EXECUTED>>\n         EX    R1,*-6\n         BR    R14\n*- - - - - - - - - - - - - - - - - MOVE DEFINITION ROUTINE  - - - - - -\n*              R1 = DEFINITION LENGTH - 1 (AT EXIT + 4)\n*              R2 = DEFINITION POINTER (AT EXIT + 4)\n*              R8 = OUTPUT LINE POINTER\n*              R14 = LINK REGISTER\n*                    RETURN : +0 - NONE\n*                             +4 - DEFINITION SET IN CURRENT LINE\n         USING DLDSECT,R8\nMVDEF    ICM   R2,B'1111',PTRVAL   -> INPUT DEFINITION\n         BZR   R14                 NONE, BACK\n         XR    R1,R1\n         IC    R1,LGHVAL\n         BCT   R1,*+L'*+6\n         MVC   DLDEF(*-*),0(R2)    <<EXECUTED>>\n         EX    R1,*-6\n         B     4(R14)\n*- - - - - - - - - - - - - - - - - MOVE COMMENT ROUTINE - - - - - - - -\n*              R0-R1-R2 = WORK REGISTERS\n*              R3 = CURRENT LINE CHECK POINTER\n*              R8 = OUTPUT LINE POINTER\n*              R14 = LINK REGISTER\n*              R15 = WORK REGISTER\n*                    RETURN : +0 - OK, COMMENT SET IN CURRENT LINE\n*                             +4 - COMMENT SET IN \"WLINE\"\nMVCOM    OC    PTRCOM,PTRCOM\n         BZR   R14                 NONE\n         CLI   0(R3),C' '\n         BNE   *+L'*+4\n         BCT   R3,*-8\n         LA    R3,3(R3)            ADDRESS WHERE SET COMMENT\n         LA    R0,DLCOMM+L'DLCOMM\n         SR    R0,R3\n         STC   R0,LAVSP            LENGTH OF AVAILABLE SPACE\n         CLC   LGHCOM,LAVSP\n         BH    MVCOM5              AVAILABLE SPACE TOO SHORT\n         CLI   LGHCOM,L'DLCOMM\n         BH    MVCOM3              NOT IN NORMAL TARGET\n         XR    R1,R1\n         IC    R1,LGHCOM\n         L     R2,PTRCOM\nMVCOM1   LA    R0,DLCOMM\n         CLR   R3,R0\n         BNL   MVCOM2\n         LR    R3,R0\nMVCOM2   BCT   R1,*+L'*+6\n         MVC   0(*-*,R3),0(R2)     <<EXECUTED>>\n         EX    R1,*-6\n         BR    R14\nMVCOM3   BAS   R15,CMPRSS          TRY TO COMPRESS COMMENT\n         CLI   ZCMPL,L'DLCOMM\n         BH    MVCOM4              ALSO NOT IN NORMAL TARGET\n         XR    R1,R1\n         IC    R1,ZCMPL\n         LA    R2,ZCMPR\n         B     MVCOM1\nMVCOM4   XR    R1,R1\n         IC    R1,LGHCOM\n         L     R2,PTRCOM\n         B     MVCOM2\nMVCOM5   BAS   R15,CMPRSS          TRY TO COMPRESS COMMENT\n         CLC   ZCMPL,LAVSP\n         BH    MVCOM6              AGAIN AVAILABLE SPACE TOO SHORT\n         XR    R1,R1\n         IC    R1,ZCMPL\n         LA    R2,ZCMPR\n         B     MVCOM2\nMVCOM6   MVC   WLINE,BLANKS\n         CLI   LGHCOM,L'DLCOMM\n         BH    MVCOM7              NOT IN NORMAL TARGET\n         XR    R1,R1\n         IC    R1,LGHCOM\n         L     R2,PTRCOM\n         LA    R3,WLINE+(DLCOMM-DLDSECT)\n         B     MVCOM2\nMVCOM7   CLI   ZCMPL,L'DLCOMM\n         BH    MVCOM11             AGAIN NOT IN NORMAL TARGET\n         LA    R3,WLINE+(DLCOMM-DLDSECT)\nMVCOM8   XR    R1,R1\n         IC    R1,ZCMPL\nMVCOM9   LA    R2,ZCMPR\nMVCOM10  BCT   R1,*+L'*+6\n         MVC   0(*-*,R3),0(R2)     <<EXECUTED>>\n         EX    R1,*-6\n         B     4(R14)\nMVCOM11  CLI   LGHCOM,L'DLCOMM+6\n         BH    MVCOM12             NOT IN ALTERNATE TARGET\n         LA    R3,WLINE+(DLCOMM-6-DLDSECT)\n         XR    R1,R1\n         IC    R1,LGHCOM\n         L     R2,PTRCOM\n         B     MVCOM10\nMVCOM12  CLI   ZCMPL,L'DLCOMM+6\n         BH    MVCOM13             AGAIN NOT IN ALTERNATE TARGET\n         LA    R3,WLINE+(DLCOMM-6-DLDSECT)\n         B     MVCOM8\nMVCOM13  XR    R1,R1               WHAT'S THAT ? MOVE IT COMPRESSED\n         IC    R1,ZCMPL\n         LA    R3,WLINE+(DLCOMM+L'DLCOMM-1-DLDSECT)\n         SR    R3,R1\n         B     MVCOM9\n*------------- \"MVCOMS\" : SPECIAL PROCESS FOR GENERATED COMMENT\nMVCOMS   OC    PTRCOM,PTRCOM\n         BZR   R14                 NONE\n         CLI   LGHCOM,L'DLCOMM\n         BH    MVCOMS2             NOT IN NORMAL TARGET\n         XR    R1,R1\n         IC    R1,LGHCOM\n         L     R2,PTRCOM\nMVCOMS1  BCT   R1,*+L'*+6\n         MVC   DLCOMM(*-*),0(R2)   <<EXECUTED>>\n         EX    R1,*-6\n         BR    R14\nMVCOMS2  BAS   R15,CMPRSS          TRY TO COMPRESS COMMENT\n         CLI   ZCMPL,L'DLCOMM\n         BH    MVCOMS3             ALSO NOT IN NORMAL TARGET\n         LA    R2,ZCMPR\n         XR    R1,R1\n         IC    R1,ZCMPL\n         B     MVCOMS1\nMVCOMS3  CLI   ZCMPL,L'DLCOMM+6\n         BH    MVCOMS4             AGAIN NOT IN ALTERNATE TARGET\n         XR    R1,R1\n         IC    R1,ZCMPL\n         LA    R2,ZCMPR\n         BCT   R1,*+L'*+6\n         MVC   DLCOMM-6(*-*),0(R2) <<EXECUTED>>\n         EX    R1,*-6\n         BR    R14\nMVCOMS4  XR    R1,R1               WHAT'S THAT ? MOVE IT COMPRESSED\n         IC    R1,ZCMPL\n         LA    R2,ZCMPR\n         LA    R3,DLCOMM+L'DLCOMM-1\n         SR    R3,R1\n         BCT   R1,*+L'*+6\n         MVC   0(*-*,R3),0(R2)     <<EXECUTED>>\n         EX    R1,*-6\n         BR    R14\n*------------- \"CMPRSS\" : LOCAL COMPRESS SUBROUTINE\nCMPRSS   MVC   ZCMPR,BLANKS        R15 = LOCAL LINK REGISTER\n         MVI   ZCMPL,0             R0-R1-R2 = WORK REGISTERS\n         XR    R0,R0\n         IC    R0,LGHCOM\n         LA    R1,ZCMPR\n         L     R2,PTRCOM\nCMPRSS1  MVC   0(1,R1),0(R2)\n         LA    R1,1(R1)\n         CLI   0(R2),C' '\n         BE    CMPRSS2\n         LA    R2,1(R2)\n         BCT   R0,CMPRSS1\n         B     CMPRSS3\nCMPRSS2  LA    R2,1(R2)\n         BCT   R0,*+L'*+4\n         B     CMPRSS3\n         CLI   0(R2),C' '\n         BE    CMPRSS2\n         B     CMPRSS1\nCMPRSS3  LA    R2,ZCMPR\n         SR    R1,R2\n         STC   R1,ZCMPL\n         BR    R15\n         DROP  R8\n*- - - - - - - - - - - - - - - - - BUMP TABLE ROUTINE - - - - - - - - -\n*              R4-R5-R6 = TABLE POINTERS (BXLE)\n*              R9 = TABLE ENTRIES COUNTER\n*              R14 = LINK REGISTER\n*              AT END : TABLE ENTRY POINTER SET\nINCRSYM  CLI   SYM,0               IS ENTRY USED ?\n         BER   R14                 NO, RE-USE IT\n         MVC   PGE,PAGE            YES, SET CURRENT PAGE\n         LA    R9,1(R9)            THEN INCREMENT COUNTER\n         BXLE  R5,R6,0(R14)        BRANCH IF NEXT ENTRY AVAILABLE\n         B     TBOVFL              NO MORE, END OF TABLE\n*- - - - - - - - - - - - - - - - - PRINT DATA AREA ROUTINE  - - - - - -\n*              R0-R1 = WORK REGISTERS\n*              R3 = LINE DATA AREA POINTER\n*              R8 = LINK REGISTER\n*              R14-R15 = WORK REGISTERS\n*              AT END : LINE PRINTED AND CLEARED\n         USING DLDSECT,R3\nPRTDATA  CLC   DLOFF,BLANKS        <- NORMAL PRINT ENTRY\n         BE    PRTNDSL\n        PUT    BOOKOUT,DASHLINE\nPRTNDSL  TM    SW1,SWABL+SWDSH     END OF PAGE CHECK\n         BZ    *+L'*+16\n         BM    *+L'*+6\n         AP    LINECTR,=PL1'+1'\n         AP    LINECTR,=PL1'+1'\n         AP    LINECTR,=PL1'+1'\n         CP    LINECTR,LINEPPG\n         BL    PRTPUTO\n         TM    SW1,SWABL+SWDSH\n         BZ    *+L'*+16\n         BM    *+L'*+6\n         SP    LINECTR,=PL1'+1'\n         SP    LINECTR,=PL1'+1'\n         SP    LINECTR,=PL1'+1'\n         ST    R8,SVRET\n         BAS   R8,PRTBOTT          GO TO PRINT BOTTOM\n         L     R8,SVRET\nPRTPAGE  ZAP   LINECTR,=PL1'+4'    <- NEW PAGE PRINT ENTRY\n         TM    SW1,SWABL+SWDSH\n         BZ    *+L'*+16\n         BM    *+L'*+6\n         AP    LINECTR,=PL1'+1'\n         AP    LINECTR,=PL1'+1'\n         AP    PAGECTR,=PL1'+1'\n         UNPK  PAGE(5),PAGECTR\n         OI    PAGE+4,C'0'\n        PUT    BOOKOUT,TL1\n        PUT    BOOKOUT,BLANKS\n        PUT    BOOKOUT,BLANKS\n         CLC   DLOFF,BLANKS\n         BE    PRTPUTO\n        PUT    BOOKOUT,DASHLINE\nPRTPUTO  TM    SW1,SWABL\n         BZ    PRTNABL\n        PUT    BOOKOUT,BLANKS\n         NI    SW1,255-SWABL\nPRTNABL  TM    SW1,SWDSH\n         BZ    PRTNDSH\n        PUT    BOOKOUT,BLANKS\n         NI    SW1,255-SWDSH\nPRTNDSH PUT    BOOKOUT,DLLNE\n         MVC   DLLNE,BLANKS        CLEAR OUTPUT LINE\n         TM    SW1,SWTPG\n         BZ    *+L'*+10\n         MVC   TITLEPAG,PAGE\n         B     *+L'*+12\n         TM    SW1,SWDPG\n         BZR   R8\n         MVC   TITLEPGD,PAGE\n         AP    TITLCTR,=PL1'+1'\n         CP    TITLCTR,LINEPPG\n         BNH   PRTNTPT\n        PUT    TITLE,TITLETL\n        PUT    TITLE,BLANKS\n        PUT    TITLE,TITLE1\n        PUT    TITLE,TITLE2\n        PUT    TITLE,BLANKS\n         ZAP   TITLCTR,=PL1'+3'\nPRTNTPT  TM    SW1,SWTPG\n         BZ    PRTNDPT\n        PUT    TITLE,TITLEL\n         NI    SW1,255-SWTPG\n         BR    R8\nPRTNDPT PUT    TITLE,TITLED\n         NI    SW1,255-SWDPG\n         BR    R8\n         DROP  R3\n*------- \"PRTBOTT\" : PRINT BOTTOM OF PAGE (SUBROUTINE)\n*              R0-R1 = WORK REGISTERS\n*              R8 = LINK REGISTER\n*              R14-R15 = WORK REGISTERS\nPRTBOTT  MVC   BOTMAC1,TLMAC\n         MVC   BOTMAC2,TLMAC2\nPRTFILL  AP    LINECTR,=PL1'+1'    FILL PAGE\n         CP    LINECTR,LINEPPG\n         BNL   PRTLAST\n        PUT  BOOKOUT,BLANKS\n         B     PRTFILL\nPRTLAST  MVC   BPAGE1,PAGE         PRINT BOTTOM\n         MVC   BPAGE2,PAGE\n        PUT    BOOKOUT,BOTTEMTL\n        PUT    BOOKOUT,BOTTEMTO\n         BR    R8\n         SPACE 1\n         DROP  R4\n         EJECT\n*=====================================================================*\n*        TERMINATION - EXIT\n         SPACE 1\n         DROP  R5\nSTOPALL CLOSE  (MAPIN,,BOOKOUT)\n         L     R2,GFTSIZ\n         L     R3,TABSTA\n        FREEMAIN R,LV=(R2),A=(R3)\nLEAVE    L     R15,RCBACK\n         L     R13,4(,R13)\n         RETURN (14,12),RC=(15)\n         SPACE 1\nGFDERR   STC   R15,RCBACK+3        GFDATE RC (4/8)\n         LA    R15,X'F0'(R15)\n         STC   R15,GFDWTO+(8+24)\nGFDWTO  WTO    '-> \"GFDATE\" RETURN CODE 0 (CALL SYSTEM PROGRAMMER)',   1\n               ROUTCDE=11,DESC=7\n         B     LEAVE\nBADPARM  MVI   RCBACK+3,12         INVALID LENGTH PARM\n        WTO    '-> INVALID L=XX, OR TITLE LENGTH ERROR IN PARM.FIELD', 1\n               ROUTCDE=11,DESC=7\n         B     LEAVE\nTBOVFL   MVI   RCBACK+3,16         END OF TABLE (OVERFLOW)\n        WTO    '-> OVERFLOW : EXCEEDED 4000 ENTRIES TABLE FOR SYMBOLS',1\n               ROUTCDE=11,DESC=7\n         B     STOPALL\n         EJECT\n*=====================================================================*\n*        DCB'S - LITERAL POOL\n         SPACE 1\n         PRINT NOGEN\nMAPIN    DCB   DSORG=PS,MACRF=GL,DDNAME=INPUT,EODAD=EOF\nBOOKOUT  DCB   DSORG=PS,MACRF=PM,DDNAME=OUTPUT,LRECL=80,RECFM=FBA\nTITLE    DCB   DSORG=PS,MACRF=PM,DDNAME=TITLE,LRECL=80,RECFM=FBA\n         PRINT GEN\n         SPACE 1\n        LTORG\n         EJECT\n*=====================================================================*\n*        CONSTANTS AND WORK-AREAS\n         SPACE 1\nCOLWK    DC    D'0'\nCOL#     EQU   COLWK,4\nCOL2PD   EQU   COLWK+4,4\nCOVWK    DC    D'0'\nCV#1     EQU   COVWK+4,4\nCV#2     EQU   COVWK,4\n         SPACE 1\nTABLM    DS    0F\nTABSTA   DS    F                   START OF TABLE\nTABENT   DS    F                   ENTRY SIZE\nTABEND   DS    F                   END OF TABLE\nSZTB     EQU   SYML*NETS           SIZE OF TABLE\nTABSIZ   DC    A(SZTB)\nSZGF     EQU   ((SZTB+7)/8)*8      SIZE FOR GET-FREEMAIN\nGFTSIZ   DC    A(SYML*NETS)\n         SPACE 1\nRCBACK   DC    F'0'\nSVRET    DC    F'0'\nCURPTR   DC    F'0'\nSCANS    DS    0F =================---> KEEP TOGETHER\nPTRLAB   DC    F'0'               =\nPTROPE   DC    F'0'               =\nPTRVAL   DC    F'0'               =\nPTRCOM   DC    F'0'               =\nLGHLAB   DC    XL1'0'             =\nLGHOPE   DC    XL1'0'             =\nLGHVAL   DC    XL1'0'             =\nLGHCOM   DC    XL1'0'             =\nSCANL    EQU   *-SCANS ============\nSOFF     DC    CL4' '              SAVE FOR OFFSET\nPAGECTR  DC    PL3'0'\nLINECTR  DC    PL2'+99'\nTITLCTR  DC    PL2'+99'\nLINEPPG  DC    PL2'+54'            LINES PER PAGE\nTLMAC    DC    CL8' '\nTLMAC2   DC    CL8' '\nPAGE     DC    CL5' '\nZCMPR    DC    CL78' '\nZCMPL    DC    XL1'0'\nLAVSP    DC    XL1'0'\n         SPACE 1\nSW1      DC    XL1'0'\nSWHMC    EQU   X'80'               HEAD MACRO PROCESSED (READY)\nSWDSH    EQU   X'40'               DO DASH LINE AFTER\nSWTPG    EQU   X'08'               DO TITLE LINE/PAGE\nSWDPG    EQU   X'04'               DO DSECT LINE/PAGE\nSWABL    EQU   X'02'               ADDITIONAL BLANK LINE\nSW2      DC    XL1'0'\nSWEOF    EQU   X'80'               INPUT EOF DETECTED\nSWECR    EQU   X'40'               END OF CROSS REFERENCE\nSWLCB    EQU   X'20'               END DETECTED ON 2ND COLUMN\nSWQUO    EQU   X'01'               QUOTE PROCESSING USE\n         SPACE 1\nBLANKS   DS    0CL80\n         DC    CL80' '\n         SPACE 1\nOLINE    DS    0CL80\n         DC    CL80' '\n         SPACE 1\n*- - - - - - - - - - - - - - - --> CROSS REF LINE\nCOLSYM   EQU   OLINE+2,8           SYMBOL\nCOLOFF   EQU   OLINE+12,4          OFFSET\nCOLX1    EQU   OLINE+17,2          VALUE\nCOLVAL   EQU   OLINE+19,9\nCOLPGE   EQU   OLINE+30,5          PAGE\nCOLSYMB  EQU   OLINE+45,8          SYMBOL\nCOLOFFB  EQU   OLINE+55,4          OFFSET\nCOLX1B   EQU   OLINE+60,2          VALUE\nCOLVALB  EQU   OLINE+62,9\nCOLPGEB  EQU   OLINE+73,5          PAGE\n         SPACE 1\nDASHLINE DS    0CL80\n         DC    CL2'+',76C'_',CL2' '\n         SPACE 1\nTITLETL  DS    0CL80\n         DC    CL2'1',CL11'CONTENTS :'\nTPARM    DC    CL45' ',CL10' '\nDATE     DC    CL10' ',CL2' '\n         SPACE 1\nTITLE1   DS    0CL80\n         DC    CL2' ',CL56'MACRO'\n         DC    CL14'(DSECT   PAGE)',CL1' '\n         DC    CL5'PAGE',CL2' '\n         SPACE 1\nTITLE2   DS    0CL80\n         DC    CL2'+',70C'_',CL1' '\n         DC    5C'_',CL2' '\n         SPACE 1\nTITLEL   DS    0CL80\n         DC    CL2' '\nTITLEMAC DS    0CL71\nTITLEMCL DC    CL8' ',CL1' '\nTITLEMCO DC    CL8' ',CL1' '\nTITLEMCV DC    CL52' ',CL1' '\nTITLEPAG DC    CL5' ',CL2' '\n         SPACE 1\nTITLED   DS    0CL80\n         DC    CL58' '\nTITLENMD DC    CL8' ',CL1' '\nTITLEPGD DC    CL5' ',CL8' '\n         SPACE 1\nBOTTEMTL DS    0CL80\n         DC    CL2'0'\nBOTMAC1  DC    CL8' ',CL60' '\nBOTMAC2  DC    CL8' ',CL2' '\n         SPACE 1\nBOTTEMTO DS    0CL80\n         DC    CL2' '\nBPAGE1   DC    CL5' ',CL11' '\nBPARM    DC    CL45' ',CL10' '\nBPAGE2   DC    CL5' ',CL2' '\n         SPACE 1\nCTITLE   DS    0CL80\n         DC    CL2' ',CL8'SYMBOL'\n         DC    CL2' ',CL16'OFFSET-VALUE'\n         DC    CL2' ',CL5'PAGE',CL5' '\n         DC    CL5' ',CL8'SYMBOL'\n         DC    CL2' ',CL16'OFFSET-VALUE'\n         DC    CL2' ',CL5'PAGE',CL2' '\n         SPACE 1\nCTD      DS    0CL80               UNDERLINE FOR CTITLE\n         DC    CL2'+',8C'_',CL2' ',16C'_',CL2' ',5C'_',CL5' '\n         DC    CL5' ',8C'_',CL2' ',16C'_',CL2' ',5C'_',CL2' '\n         SPACE 1\nTLCR     DS    0CL80\n         DC    CL2' ',CL78'CROSS REFERENCE'\n         SPACE 1\nTL1      DS    0CL80\n         DC    CL2'1'\nPARM     DC    CL45' ',CL14' ',CL7'DATE :'\nTLDATE   DC    CL10' ',CL2' '\n         SPACE 1\nCOV1     DS    0CL80\n         DC    CL80'1'\n         SPACE 1\nCOV2     DS    0CL80\n         DC    CL5' ',CL15' '\nCOVPARM  DC    CL45' ',CL15' '\n         SPACE 1\nCOV3     DS    0CL80\n         DC    CL5' ',CL29' ',CL7'DATE :'\nCOVDATE  DC    CL10' ',CL29' '\n         SPACE 1\nWLINE    DS    0CL80               WORK LINE FOR COMMENT\n         DC    CL80' '\n         SPACE 1\nALINE    DS    0CL80               ALTERNATE DATA LINE\n         DC    CL80' '\n         SPACE 1\nPRVLINE  DC    CL(ASSLEN)' '       PREVIOUS LINE CONTENTS\n         EJECT\n*=====================================================================*\n*        DATA DESCRIPTIONS (DSECT'S)\n         SPACE 1\nASSLNE   DSECT ,                   INPUT ASSEMBLY LINE POINTERS\n         DS    CL1                      POSITIONS :\nASSLOC   DS    CL6,1C                      2 -   7\nASSOBJ   DS    CL14,1C                     9 -  16\nASSAD1   DS    CL5,1C                     24 -  28\nASSAD2   DS    CL5,1C                     30 -  34\nASSSTN   DS    CL5                        36 -  40\nASSFLG   DS    CL1                        41\nASSGEN   DS    CL71                       42 - 112\nASSCNT   DS    CL1                       113\n         DS    CL8                       114 - 121\nASSLEN   EQU   *-ASSLNE\n         SPACE 1\nDLDSECT  DSECT ,                   OUTPUT DATA-LINE POINTERS\nDLLNE    DS    0CL80               LINE START / LINE LENGTH\n         DS    CL2                         POSITIONS :  1 -  2\nDLOFF    DS    CL4                 OFFSET               3 -  6\n         DS    CL2                                      7 -  8\nDLSYM    DS    CL8                 LABEL                9 - 16\n         DS    CL2                                     17 - 18\nDLDEF    DS    0CL1                DEFINITION\n         DS    CL2                                     19 - 20\nDLVAL    DS    CL9                 EQUATE VALUE        21 - 29\n         DS    CL6                                     30 - 35\nDLCOMM   DS    CL42                COMMENTS            36 - 77\n         DS    CL3                                     78 - 80\n         SPACE 1\nTBD      DSECT\nSYM      DS    CL8\nOFF      DS    CL4\nVAL      DS    CL9\nPGE      DS    CL5\nSYML     EQU   *-SYM\n         SPACE 1\nTBDBIS   DSECT\nSYMB     DS    CL8\nOFFB     DS    CL4\nVALB     DS    CL9\nPGEB     DS    CL5\nSYMLB    EQU   *-SYMB\n         SPACE 2\n         END\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//*        DD DISP=SHR,DSN=MVS0011.FILE453.PDS\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSPRINT DD SYSOUT=*\n//*\n//LKED    EXEC PGM=HEWLKED,PARM=MAP\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,DELETE)\n//SYSLMOD  DD DISP=SHR,DSN=SBGOLOB.LOAD(DAHANDBK)\n//SYSPRINT DD SYSOUT=*\n//*\n//ASMH    EXEC PGM=ASMA90,PARM='XREF(SHORT),NODECK,NOOBJECT'\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1   DD UNIT=VIO,DSN=&&SYSUT1,SPACE=(CYL,5)\n//*YSPRINT DD SYSOUT=*\n//SYSPRINT DD UNIT=VIO,SPACE=(CYL,5),DSN=&&ASMLIST,\n//            DCB=(RECFM=FBM,DSORG=PS,LRECL=121),\n//            DISP=(,PASS,DELETE)\n//SYSIN    DD *\n         CVT       DSECT=YES,LIST=YES\nTIOT     DSECT\n         IEFTIOT1\n         END\n/*\n//DBK     EXEC PGM=DAHANDBK,COND=(4,LT)\n//STEPLIB   DD DSN=SBGOLOB.LOAD,DISP=SHR\n//INPUT     DD DSN=&&ASMLIST,DISP=(OLD,DELETE,DELETE)\n//TITLE     DD SYSOUT=*\n//OUTPUT    DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DAHANDJ": {"ttr": 5641, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x04\\x00'\\x00\\x946/\\x01\\x143o\\x12B\\x00\\x85\\x00\\x86\\x00\\x08\\xc3\\xc2\\xe3\\xf4\\xf9\\xf0@@@@\"", "ispf": {"version": "01.04", "flags": 0, "createdate": "1994-12-28T00:00:00", "modifydate": "2014-12-02T12:42:27", "lines": 133, "newlines": 134, "modlines": 8, "user": "CBT490"}, "text": "//SBGOLOBH JOB (ACCT#),DATA-HANDBOOK,\n// NOTIFY=&SYSUID,\n// LINES=50,\n// CLASS=A,MSGCLASS=X,COND=(8,LT)\n//ASMH    EXEC PGM=ASMA90,REGION=0M,\n// PARM='XREF(SHORT),NODECK,NOOBJECT,TERM'\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,55)\n//SYSTERM  DD SYSOUT=*\n//SYSPRINT DD UNIT=VIO,SPACE=(CYL,55),DSN=&&ASMLIST,\n//            DCB=(RECFM=FBM,DSORG=PS,LRECL=121),\n//            DISP=(,PASS,DELETE)\n//SYSIN    DD *\n         IFGACB  ,\n         IHAACEE ,\n         IHAASCB DSECT=YES,LIST=YES\n         IHAASVT DSECT=YES,LIST=YES\n         IHAASXB DSECT=YES,LIST=YES\n         IEEBASEA\n         IHACDE ,\n         IEECHAIN ,\n         IHACSD DSECT=YES\n         CVT DSECT=YES,LIST=YES,PREFIX=YES\n         DCBD  DSORG=PS\n**       DCBD  DSORG=DA\n         IHADECB DSECT=YES\n         IHADFA DSECT=YES\n         IHADSAB\n         IECSDSL1 1\n         DS    44X'04'\n         IECSDSL1 4\n*STATUS      OLD=01   MOD=02    NEW=04    SHR=08\n*DISP    UNCATLG=01 CATLG=02 DELETE=04   KEEP=08\n*SPACE                ALX=02   MXIG=04 CONTIG=08\n*LABEL        NL=01    SL=02    NSL=04            SUL=0A\n*             BLP=10  LTM=21     AL=40    AUL=48\n         IEFZB4D0\n         IEFZB4D2\n         IEZDEB LIST=YES\n         IHADVA DSECT=YES\n         IKJECT\n         IHAECVT LIST=YES\n         IHAGDA\n         IEZIOB DSECT=YES\n         IECDIOCM\nJCT      DSECT\n         IEFAJCTB\nJCTX     DSECT\n         IEFJCTX\n         IEFJESCT\nJFCB     DSECT\n         IEFJFCBN LIST=YES\n         IEZJSCB ,\n         IEFJSCVT\n         IHALCCA DSECT=YES\n         IEFALLCT\n         IHALDA\n         IHALLE\n         IHALPDE\n**       IECDSECS\n**       IECDSECT\n         IRAOUCB DSECT=YES\n         IHAPCCA DSECT=YES\n         IHAPDS DSECT=YES,PDSBLDL=YES\n         IHAPSA DSECT=YES,LIST=YES\n         IKJPSCB\n         IARRCE  ,              RSM CONTROL AND ENUMERATION AREA\n         IHARD   ,              REGION DESCRIPTOR\n         IKJRB DSECT=YES,LIST=YES\n         IRXARGTB\n         IRXCMPTB ,            COMPILER TABLE TSO/E 2.3.1\n         IRXDSIB\n         IRXEFPL\n         IRXENVB               ENVIRONMENT BLOCK\n         IRXENVT               ENVIRONMENT TABLE (IRXANCHR)\n         IRXEVALB\n         IRXEXECB\n         IRXEXTE\n         IRXFPDIR\n         IRXINSTB\n         IRXMODNT\n         IRXPACKT\n         IRXPARMB\n         IRXSHVB\n         IRXSUBCT\n         IRXWORKB\n         ISGRIB\n         IFGRPL  ,\n         IDARMRCD ,                RECORD MGMT ERROR CODES\n         IHASCB DSECT=YES\nSCT      DSECT\n         IEFASCTB\n         IEFSCTX DSECT=YES\n         IHASCVT DSECT=YES,LIST=YES\n         IHASDWA DSECT=YES,VRAMAP=YES\nSIOT     DSECT\n         IEFASIOT\n         IEESMCA\n         IHASNAP DSECT=YES\n*        IHASCA                 SPIE/ESPIE CONTROL AREA\n         IHAEPIE                EXTENDED PROGRAM INTERRUPT ELEMENT\n         IHAPIE                 PROGRAM INTERRUPT ELEMENT\n         IHAPICA                PROGRAM INTERRUPTION CONTROL AREA\n         IHASPQE                SP Q ELEMENT\n         IHAFBQE                FREE BLOCK\n         IHASPQA                SP Q DESCRIPTOR\n         IHADQE                 DESCRIPTOR Q ELEMENT\n         IHAFQE                 FREE Q ELEMENT\n         IHASPT                 CSA\n         IEFJSSOB (AL,SO)\n         IEFJSSIB\n         IEFSSSA\n         IEFJSSVT\n         IHASTCB LIST=YES\n         IKJTCB DSECT=YES,LIST=YES\n         IEFTCT\nTIOT     DSECT\n         IEFTIOT1\n         IKJTSB LIST=YES,EXT=YES\n         IKJTSVT\nUCB      DSECT\n         IEFUCBOB LIST=YES,PREFIX=YES\n         IEECUCM LIST=YES,DSECT=YES\n         IKJUPT\n         IHAXTLST\n         END\n/*\n//DBK     EXEC PGM=DAHANDBK,COND=(8,LT)\n//STEPLIB   DD DSN=SYS1.W$$.LINKLIB,DISP=SHR\n//INPUT     DD DSN=&&ASMLIST,DISP=(OLD,DELETE,DELETE)\n//TITLE     DD SYSOUT=*\n//OUTPUT    DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DCODADDR": {"ttr": 5889, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x006\\x00\\x95\\x05/\\x01\\x031\\x8f\\x18\\x12\\x01\\xc3\\x00\\xb2\\x00\\x17\\xc3\\xc2\\xe3\\xf4\\xf5\\xf5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1995-02-21T00:00:00", "modifydate": "2003-11-14T18:12:36", "lines": 451, "newlines": 178, "modlines": 23, "user": "CBT455"}, "text": "//GILBERTD JOB (ACCT#),DCODADDR,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = DCODADDR                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = CONVERT ADDRESS TO MODULE.CSECT+X'OFFSET'        *\n*                                                                     *\n* FUNCTION = THIS MODULE CONVERTS AN ADDRESS PASSED BY ITS INVOKER    *\n*            INTO A CHARACTER STRING THAT INDICATES WHAT MODULE,      *\n*            CSECT WITHIN THE MODULE, AND OFFSET WITHIN THE CSECT     *\n*            THE ADDRESS POINTS TO.  DCODADDR CAN BE INVOKED BY       *\n*            RECOVERY ROUTINES OR ANY OTHER MODULES.                  *\n*                                                                     *\n* STATUS = R101                                                       *\n*                                                                     *\n* AUTHOR = GILBERT SAINT-FLOUR                                        *\n*                                                                     *\n* INVOCATION = VIA CALL OR LINK                                       *\n*                                                                     *\n*          LOAD EP=DCODADDR                                           *\n*          LR   R15,R0                                                *\n*          CALL (15),((RX),WORKAREA)                                  *\n*     OR                                                              *\n*          LINK EP=DCODADDR,PARAM=((RX),WORKAREA)                     *\n*                                                                     *\n*   RX CONTAINS THE ADDRESS THAT WILL BE CONVERTED                    *\n*                                                                     *\n*   WORKAREA DESIGNATES A 32-BYTE WORK AREA INTO WHICH DCODADDR       *\n*   RETURNS THE RESULTING CHARACTER STRING.                           *\n*                                                                     *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = MVS/ESA V4.3, DFSMS/MVS V1                        *\n*                                                                     *\n*    AUTHORIZATION = NONE                                             *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (SUB-ROUTINE)                              *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 4K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE ANY, AMODE 31,                   *\n*                 PROBLEM STATE, TCB KEY                              *\n*                                                                     *\n* OPERATION = SEE DOCUMENTATION                                       *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n*   @100 INITIAL VERSION                                              *\n*   @101 ADD VERSION=1 TO IEWBUFF MACROS                              *\n*                                                                     *\n*   @101 (DCB,DDN=XXXXXX+002)                                         *\n*        (ACB,DDN=YYYYYY)                                             *\n*                                                                     *\n***********************************************************************\n&REL     SETC  '101'\nDCODADDR CSECT\nDCODADDR RMODE ANY\n         B     BEGIN-DCODADDR(,R15)\n         DC    C'DCODADDR - '\n         DC    C'CONVERT ADDR TO MODULE.CSECT+X''OFFSET'' R&REL'\n         DC    0F'0'\nBEGIN    BAKR  R14,0\n         LR    R11,R15\n         USING DCODADDR,R11\n*USING GSFSUBS,R12\n         LM    R3,R4,0(R1)             REFADDR,WORKAREA\n         LA    R3,0(,R3)               CLEAR HI-ORDER BIT\n*\n         GETMAIN RU,LV=DYNAML          GET DYNAMIC STORAGE\n         LR    R13,R1\n         USING DYNAM,R13\n         LR    R14,R1                  CLEAR STORAGE\n         LR    R15,R0                  CLEAR STORAGE\n         SLR   R1,R1                   CLEAR STORAGE\n         MVCL  R14,R0                  CLEAR STORAGE\n*\n         ST    R3,REFADDR              ADDRESS\n         ST    R4,WORKADDR             ADDR OF WORK AREA\n         STRING '*UNKNOWN*',INTO=WORK32\n         MVI   MODNAME+1,8             LENGTH OF MODULE NAME\n*\n         CSVQUERY SEARCH=JPA,          SEARCH JPAQ                     +\n               INADDR=REFADDR,         ADDRESS                         +\n               OUTEPNM=MODNAME+2,      RETURN EP NAME                  +\n               OUTLENGTH=MODLENGTH,    RETURN LENGTH                   +\n               OUTLOADPT=MODLOADPT,    RETURN LOAD POINT ADDRESS       +\n               OUTPDATA=PDATA,         PROVIDER DATA                   +\n               OUTPID=PID,             PROVIDER ID                     +\n               OUTEPTKN=MODTOKEN,      RETURN TOKEN                    +\n               MF=(E,CSVQRYWK)         WORK AREA\n         LTR   R15,R15                 CSVQUERY OK?\n         BNZ   CSVQLPA                 NO, JUMP\n         SL    R3,MODLOADPT            CALC OFFSET\n         ST    R3,MODOFFSET            STORE OFFSET\n         CLC   =C'PGMF',PID            LOADED FROM JOBLIB/STEPLIB?\n         BNE   EXIT8                   NO, EXIT\n         CLI   PDATA+1,X'01'           LOADED FROM -LNKLST- ?\n         BE    EXIT8                   YES, PREVENT IEW2302S 1031\n         BAL   R14,SCANLOAD         <- SCAN LOAD-MODULE\n         LTR   R15,R15                 IEWBIND OK?\n         BNZ   EXIT8                   NO, USE MODNAME\n         B     EXIT9                   EXIT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        LOOK FOR AN LPA MODULE                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\nCSVQLPA  CSVQUERY SEARCH=LPA,          SEARCH ALPAQ/PLPAQ              +\n               INADDR=REFADDR,         ADDRESS                         +\n               OUTEPNM=MODNAME+2,      RETURN EP NAME                  +\n               OUTLOADPT=MODLOADPT,    RETURN LOAD POINT ADDRESS       +\n               MF=(E,CSVQRYWK)         WORK AREA\n         LTR   R15,R15                 CSVQUERY OK?\n         BZ    EXIT7                   YES, EXIT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        RETRIEVE NUCLEUS MODULE NAME AND OFFSET                      *\n*                                                                     *\n*---------------------------------------------------------------------*\nNUCLKUP  NUCLKUP BYADDR,ADDR=(R3),NAME=MODNAME+2\n         LTR   R15,R15                 NUCLKUP OK?\n         BNZ   VSMLOC                  NO, FIND SUB-POOL\n         ST    R0,MODLOADPT            STORE LOAD POINT ADDRESS\n*\nEXIT7    SL    R3,MODLOADPT            CALC OFFSET\n         ST    R3,MODOFFSET            STORE OFFSET\n*\nEXIT8    STRING (MODNAME+2,8,T),                                       X\n               '+X''',(MODOFFSET+1,3,X),'''',INTO=WORK32\n         CLI   MODOFFSET+1,0           OFFSET > X'00FFFF' ?\n         BNE   EXIT9                   YES, EXIT\n         STRING (MODNAME+2,8,T),                                       X\n               '+X''',(MODOFFSET+2,2,X),'''',INTO=WORK32\n         B     EXIT9\n***********************************************************************\n*                                                                     *\n*        RETRIEVE SUB-POOL ID                                         *\n*                                                                     *\n***********************************************************************\nVSMLOC   L     R3,REFADDR              GET REFERENCE ADDRESS\n         LA    R5,=C'PVT '\n         VSMLOC PVT,AREA=((R3),1)\n         LTR   R15,R15                 STORAGE ALLOCATED?\n         BE    VSMLOC8                 YES, JUMP\n         LA    R5,=C'LSQA'\n         VSMLOC LSQA,AREA=((R3),1)\n         LTR   R15,R15                 STORAGE ALLOCATED?\n         BE    VSMLOC8                 YES, JUMP\n         LA    R5,=C'CSA '\n         VSMLOC CSA,AREA=((R3),1)\n         LTR   R15,R15                 STORAGE ALLOCATED?\n         BE    VSMLOC8                 YES, JUMP\n         LA    R5,=C'SQA '\n         VSMLOC SQA,AREA=((R3),1)\n         LTR   R15,R15                 STORAGE ALLOCATED?\n         BNZ   EXIT9                   NO, EXIT\nVSMLOC8  LA    R1,255                  MASK NOR NR\n         NR    R1,R0                   R1 CONTAINS SUBPOOL ID\n         STRING ((R5),4,T),' SUBPOOL ',((R1),,R3Z),INTO=WORK32\n*\nEXIT9    L     R4,WORKADDR             CALLER'S 32-BYTE WORK AREA\n         MVC   0(L'WORK32,R4),WORK32   MVC RESULT TO CALLER'S WORK AREA\n         FREEMAIN RU,LV=DYNAML,A=(R13)\n         PR                            GOBACK TO CALLER\n***********************************************************************\n*                                                                     *\n*        RETRIEVE CSECT FROM JPAQ MODULE                              *\n*                                                                     *\n***********************************************************************\nSCANLOAD BAKR  R14,0\n         IEWBIND FUNC=STARTD,          START DIALOG                    X\n               DIALOG=DTOKEN,                                          X\n               RETCODE=RETCODE,                                        X\n               RSNCODE=RSNCODE,                                        X\n               MF=(E,BINDPARM)\n         LTR   R15,R15\n         BNZ   SCANL420\n DELETE EP=IEWBIND\n*\n         IEWBIND FUNC=CREATEW,         CREATE WORKMOD                  X\n               WORKMOD=WTOKEN,                                         X\n               DIALOG=DTOKEN,                                          X\n               INTENT=ACCESS,                                          X\n               RETCODE=RETCODE,                                        X\n               RSNCODE=RSNCODE,                                        X\n               MF=(E,BINDPARM)\n         LTR   R15,R15\n         BNZ   SCANL420\n*\n         CLI   PDATA+1,X'02'           LOADED WITH DE PARM?\n         BE    SCANL04                 YES, PREVENT IEW2302S 1031\n         IEWBIND FUNC=INCLUDE,         INCLUDE LOAD-MODULE             X\n               WORKMOD=WTOKEN,                                         X\n               INTYPE=TOKEN,                                           X\n               EPTOKEN=MODTOKEN,                                       X\n               RETCODE=RETCODE,                                        X\n               RSNCODE=RSNCODE,                                        X\n               MF=(E,BINDPARM)\n         B     SCANL05\n*\nSCANL04  MVI   DDNAME+1,8              DDNAME LENGTH\n         MVC   DDNAME+2(8),PDATA+8     MOVE DDNAME\n         IEWBIND FUNC=INCLUDE,         INCLUDE LOAD-MODULE             X\n               WORKMOD=WTOKEN,                                         X\n               INTYPE=NAME,                                            X\n               DDNAME=DDNAME,                                          X\n               MEMBER=MODNAME,                                         X\n               RETCODE=RETCODE,                                        X\n               RSNCODE=RSNCODE,                                        X\n               MF=(E,BINDPARM)\n*\nSCANL05  EQU   *\n         LTR   R15,R15\n         BNZ   SCANL420\n*\n         IEWBUFF FUNC=GETBUF,TYPE=NAME\n         IEWBUFF FUNC=INITBUF,TYPE=NAME\n*\n***      IEWBIND FUNC=GETN,            GET NAMES                       X\n               WORKMOD=WTOKEN,                                         X\n               AREA=IEWBBNL,           ?                               X\n               CURSOR=CURSORN,         CURSOR                          X\n               COUNT=COUNTN,           CURRENT NUMBER OF NAMES         X\n               TCOUNT=TCOUNT,          TOTAL NAME COUNT                X\n               NTYPE=SECTION,          RETURN SECTION NAMES            X\n               RETCODE=RETCODE,                                        X\n               RSNCODE=RSNCODE,                                        X\n               MF=(E,BINDPARM)\n         IEWBIND FUNC=GETE,            GET ESD                         X\n               WORKMOD=WTOKEN,                                         X\n               OFFSET=MODOFFSET,       OFFSET                          X\n               RECTYPE=$SD,            (SD)                            X\n               AREA=IEWBBNL,           ?                               X\n               CURSOR=CURSORN,         CURSOR                          X\n               COUNT=COUNTN,           CURRENT NUMBER OF NAMES         X\n               RETCODE=RETCODE,                                        X\n               RSNCODE=RSNCODE,                                        X\n               MF=(E,BINDPARM)\n         CH    R15,=H'4'\n         BH    SCANL420\n*\n         IEWBUFF FUNC=GETBUF,TYPE=ESD\n         IEWBUFF FUNC=INITBUF,TYPE=ESD\n         L     R5,COUNTN               CURRENT NUMBER OF NAMES\n*LOOP\nSCANL11  DS    0H\n         IEWBIND FUNC=GETD,            GET ESD                         X\n               WORKMOD=WTOKEN,                                         X\n               CLASS=@ESD,                                             X\n               AREA=IEWBESD,                                           X\n               CURSOR=CURSORD,         .                               X\n               COUNT=COUNTD,                                           X\n               RETCODE=RETCODE,                                        X\n               RSNCODE=RSNCODE,                                        X\n               MF=(E,BINDPARM)\n         CH    R15,=H'4'\n         BH    SCANL11N\n         ICM   R4,B'1111',COUNTD       ANY ESD?\n         BZ    SCANL11N                NO, IGNORE THIS NAME\n         LA    R7,ESDH_END             FIRST RECORD IN ESD BUFFER\n*--LOOP\nSCANL12  CLC   ESD_TYPE,=C'SD'         CSECT?\n         BNE   SCANL12N                NO, IGNORE\n         L     R0,ESD_MODULE_OFFSET    GET OFFSET OF THIS CSECT\n*L R1,ESD_NAME_PTR\n*LH R14,ESD_NAME_CHARS\n         CL    R0,MODOFFSET            REF ADDR IN THIS CSECT?\n         BH    SCANL12N                NO, IGNORE\n         AL    R0,ESD_LENG             ADD CSECT LENGTH\n         CL    R0,MODOFFSET            REF ADDR IN THIS CSECT?\n         BNH   SCANL12N                NO, IGNORE\n         L     R0,MODOFFSET            GET REF OFFSET\n         SL    R0,ESD_MODULE_OFFSET    GET OFFSET IN THIS CSECT\n         ST    R0,DWD                  SAVE FOR $PRINT\n         L     R1,ESD_NAME_PTR         ADDRESS OF CSECT NAME\n         CLI   0(R1),0                 UNNAMED CSECT?\n         BE    SCANL12N                YES, IGNORE\n         LH    R0,ESD_NAME_CHARS       LENGTH OF CSECT NAME\n*EX 0,*\n         STRING (MODNAME+2,8,T),'.',((R1),(R0)),                       X\n               '+X''',(DWD+1,3,X),'''',INTO=WORK32\n         CLI   DWD+1,0                 OFFSET > X'00FFFF' ?\n         BNE   SCANL400                YES, EXIT\n         STRING (MODNAME+2,8,T),'.',((R1),(R0)),                       X\n               '+X''',(DWD+2,2,X),'''',INTO=WORK32\n         B     SCANL400\nSCANL12N A     R7,ESDH_ENTRY_LENG      LENGTH OF AN ESD ENTRY\n         BCT   R4,SCANL12\n*--ENDLOOP\nSCANL11N A     R9,BNLH_ENTRY_LENG      LENGTH OF A BNL ENTRY\n         BCT   R5,SCANL11\n*ENDLOOP\nSCANL400 IEWBUFF FUNC=FREEBUF,TYPE=ESD\nSCANL410 IEWBUFF FUNC=FREEBUF,TYPE=NAME\n*\nSCANL420 BAL   R14,SETMAXCC            SAVE RETCODE\n         IEWBIND FUNC=DELETEW,         DELETE WORKMOD                  X\n               WORKMOD=WTOKEN,                                         X\n               PROTECT=YES,                                            X\n               RETCODE=RETCODE,                                        X\n               RSNCODE=RSNCODE,                                        X\n               MF=(E,BINDPARM)\n*\n         IEWBIND FUNC=ENDD,            END DIALOG                      X\n               DIALOG=DTOKEN,                                          X\n               RETCODE=RETCODE,                                        X\n               RSNCODE=RSNCODE,                                        X\n               MF=(E,BINDPARM)\n         LH    R15,MAXCC               SAVED RETCODE\n         PR\n*\nSETMAXCC CH    R15,MAXCC\n         BNHR  R14\n         STH   R15,MAXCC\n         BR    R14\n*\n@ESD     DC    H'4',C'@ESD'\n$SD      DC    H'4',C'(SD)'\n         IEWBUFF FUNC=MAPBUF,                                          X\n               VERSION=1,              VERSION 1 MAPPING               X\n               TYPE=ESD,                                               X\n               SIZE=4096,              # OF ENTRIES                    X\n               HEADREG=6,              R6                              X\n               ENTRYREG=7              R7\n         IEWBUFF FUNC=MAPBUF,                                          X\n               VERSION=1,              VERSION 1 MAPPING               X\n               TYPE=NAME,                                              X\n               SIZE=4096,              # OF ENTRIES                    X\n               HEADREG=8,              R8                              X\n               ENTRYREG=9              R9\n         DS    0A(R6,R7,R8,R9)         THESE REGS USED HERE\nDYNAM    DSECT\n         DS    18F\nDWD      DS    D\nWORKADDR DS    F\n         IEWBIND MF=(L,BINDPARM)\nDTOKEN   DS    D                       DIALOG TOKEN\nWTOKEN   DS    D                       WORKMOD TOKEN\nRETCODE  DS    F\nRSNCODE  DS    F\nCOUNTN   DS    F                       # OF NAMES\nCURSORN  DS    F                       CURRENT NAME\nCOUNTD   DS    F                       # OF ESD\nCURSORD  DS    F                       CURRENT ESD\nTCOUNT   DS    F\nMODNAME  DS    H'8',CL8'IEBGENER'\nDDNAME   DS    H'8',CL8'STEPLIB '\nMAXCC    DS    H                       MAXCC\nREFADDR  DS    A\nMODLENGTH DS   F\nMODLOADPT DS   A\nMODOFFSET DS   F\nPDATA     DS   XL16\nPID       DS   XL4\nMODTOKEN  DS   XL8\nWORK32    DS   CL32\n         CSVQUERY MF=(L,CSVQRYWK),PLISTVER=2\nDYNAML   EQU   *-DYNAM\n         YREGS\n         STRING GENERATE\n         CVT   DSECT=YES,LIST=NO\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n// DD DSN=CBTTAPE.FILE183.PDS,DISP=SHR                STRING\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//LKED    EXEC PGM=HEWLKED,PARM=RENT\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,DELETE)\n//SYSLMOD  DD DSN=CBTTAPE.FILE183.LOAD(DCODADDR),DISP=SHR\n//*\n//HLASM2 EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n        $ENTER\n*\n         LA    R3,GSFSUBS              %GSFSUBS\n        $CALL  DCODADDR,((R3),WORK32)\n        $PRINT ((R3),,X),1X,WORK32\n*\n         L     R3,=X'04128548'         CSA\n        $CALL  DCODADDR,((R3),WORK32)\n        $PRINT ((R3),,X),1X,WORK32\n*\n         LR    R3,R13                  SP 000\n        $CALL  DCODADDR,((R3),WORK32)\n        $PRINT ((R3),,X),1X,WORK32\n*\n         BALR  R3,0\n        $CALL  DCODADDR,((R3),WORK32)\n        $PRINT ((R3),,X),1X,WORK32\n*\n         LOAD  EP=GSFSUBS\n         LR    R3,R0\n         AH    R3,=H'5000'             REFERENCE ADDRESS\n        $CALL  DCODADDR,((R3),WORK32)\n        $PRINT ((R3),,X),1X,WORK32\n*\n         LOAD  EP=IDA019L1\n         LR    R3,R0\n         AH    R3,=H'9000'             REFERENCE ADDRESS\n        $CALL  DCODADDR,((R3),WORK32)\n        $PRINT ((R3),,X),1X,WORK32\n*\n**       L     R1,16\n**       L     R1,8(,R1)\n**       LOAD  EP=TSPEMAN,DCB=(R1)\n**       LR    R3,R0\n**       AH    R3,=H'1000'             REFERENCE ADDRESS\n**      $CALL  DCODADDR,((R3),WORK32)\n**      $PRINT ((R3),,X),1X,WORK32\n**\n         MVI   BLDLLIST+1,1\n         MVI   BLDLLIST+3,74\n         MVC   BLDLLIST+4(8),=C'SHOWMVS '\n         BLDL  0,BLDLLIST\n         LOAD  DE=BLDLLIST+4\n         LR    R3,R0\n         AH    R3,=H'1000'             REFERENCE ADDRESS\n        $CALL  DCODADDR,((R3),WORK32)\n        $PRINT ((R3),,X),1X,WORK32\n*\n         L     R3,16                   CVTPTR\n        $CALL  DCODADDR,((R3),WORK32)\n        $PRINT ((R3),,X),1X,WORK32\n*\n        $EXIT\n        $SUBS\nWORK32   DS    CL32\nBLDLLIST DS    Y(1,74),74X\n         END\n//SYSLIB   DD DSN=GSFSOFT.GSF-ENV.MACLIB,DISP=SHR             $ENTER\n//         DD DSN=SYS1.MACLIB,DISP=SHR                        BLDL\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//GO      EXEC PGM=LOADER,PARM=NOPRINT\n//STEPLIB  DD DSN=CBTTAPE.FILE183.LOAD,DISP=SHR\n// DD DSN=SYS1.LINKLIB,DISP=SHR\n//SYSLIN   DD DSN=*.HLASM2.SYSLIN,DISP=(OLD,DELETE)\n//SYSPRINT DD SYSOUT=*\n//SYSDEBUG DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DEFGDGSR": {"ttr": 5897, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//GILBERTD JOB (ACCT#),DEFGDGSR,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = DEFGDGSR                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = Define or Alter a GDG base                       *\n*                                                                     *\n* FUNCTION = The DEFGDGSR routine can be called by a program to       *\n*            define, delete or alter the GDG limit in a GDG base.     *\n*                                                                     *\n* STATUS = R301                                                       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = DFP V3 or above                                   *\n*                                                                     *\n*    AUTHORIZATION = NONE                                             *\n*                                                                     *\n*    RESTRICTIONS = NONE                                              *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (Sub-Routine)                              *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 4K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REUSABLE, RMODE ANY, AMODE 31,                      *\n*                 PROBLEM STATE, KEY 8                                *\n*                                                                     *\n* OPERATION = See Below                                               *\n*                                                                     *\n*        This subroutine may be called by a program to define GDGs.   *\n*        It requires two parameters:                                  *\n*                                                                     *\n*        1. a 44-byte field, containing the dsname which must be      *\n*           left-justified and padded with blanks.                    *\n*                                                                     *\n*        2. a 3-digit field, containing the number of generations     *\n*           as an unpacked decimal number in the range 001 to 255.    *\n*                                                                     *\n*        Sample calling sequence:                                     *\n*                                                                     *\n*                 01 DSNAME PIC X(44) VALUE 'PAYROLL.MASTER'.         *\n*                 01 GDGLIMIT PIC 999 VALUE 15.                       *\n*                                                                     *\n*            CALL 'DEFGDGSR' USING DSNAME, GDGLIMIT.                  *\n*                                                                     *\n*        A return code is passed in register 15.  a cobol calling     *\n*        program may check the content of the \"return-code\" field,    *\n*        a non-zero value indicating that an error has occured.       *\n*                                                                     *\n*        This sub-routine doesn't call IDCAMS, but directly           *\n*        invokes the DFP catalog management services to perform       *\n*        the following:                                               *\n*                                                                     *\n*        1. LISTCAT the entry to check if the GDG already exists      *\n*           and, if this is the case, what the current limit is.      *\n*           this request is equivalent to the IDCAMS command:         *\n*              'LISTCAT MYDSN GDG ALL '.                              *\n*                                                                     *\n*        2. DELETE the existing GDG base if the limit is zero         *\n*           This request is equivalent to the IDCAMS command:         *\n*              'DELETE MYDSN GDG '.                                   *\n*                                                                     *\n*        3. ALTER the existing GDG base if the limit obtained by      *\n*           LISTCAT is different from the value passed by the caller. *\n*           This request is equivalent to the IDCAMS command:         *\n*              'ALTER MYDSN LIMIT(nnn) SCRATCH GDG'.                  *\n*                                                                     *\n*        4. DEFINE a GDG with the SCRATCH option and the number       *\n*           of generations passed in the second parameter.            *\n*           This request is equivalent to the IDCAMS command:         *\n*              'DEFINE GDG(NAME(MYDSN) LIMIT(GDGNB) SCRATCH)'.        *\n*                                                                     *\n*Programming Notes:                                                   *\n*                                                                     *\n*        DEFGDGSR is reusable, which means that it may be loaded      *\n*        once and called multiple times in the same job step.         *\n*                                                                     *\n*        DEFGDGSR does not define a GDG in the following cases:       *\n*                                                                     *\n*        1. A '//NODEFGDG DD DUMMY' statement is present in the JCL   *\n*           or the equivalent ALLOCATE command has been issued        *\n*           under TSO, or                                             *\n*                                                                     *\n*        2. the first level qualifier of the dsname has not been      *\n*           defined as an alias, or                                   *\n*                                                                     *\n*        3. the second parameter is zero.  In that case, if a GDG     *\n*           base exists and is empty, it is deleted.                  *\n*                                                                     *\n*Change Log                                                           *\n*                                                                     *\n*200 Set GDG base's owner to invoker's RACF user id                   *\n*301 Use ALTER instead of DELETE+DEFINE                               *\n***********************************************************************\nDEFGDGSR CSECT\nDEFGDGSR RMODE ANY\n         SAVE  (14,12),,'GSF Utilities - DEFGDGSR R301'\n         LR    R12,R15\n         USING DEFGDGSR,R12\n         LM    R3,R4,0(R1)             GDGNAME, GDGLIMIT\n         GETMAIN RU,LV=DYNL            GET DYNAMIC STORAGE AREA\n         LR    R9,R1                   KEEP ITS ADDRESS\n         USING DYN,R9\n         DEVTYPE =C'NODEFGDG',WORK265  CHECK DDNAME\n         LTR   R15,R15                 CHECK DEVTYPE RETURN CODE\n         BZ    RETURN                  DD PRESENT, QUIT.\n         LA    R14,DYN                 CLEAR DYNAMIC STORAGE\n         LA    R15,DYNL                CLEAR DYNAMIC STORAGE\n         SLR   R1,R1                   CLEAR DYNAMIC STORAGE\n         MVCL  R14,R0                  CLEAR DYNAMIC STORAGE\n*---------------------------------------------------------------------*\n*        CHECK FOR AN EXISTING ALIAS                                  *\n*---------------------------------------------------------------------*\nP1ALIAS  MVI   WORK265+C'.',C'.'       BUILD TABLE FOR TRT\n         TRT   0(9,R3),WORK265         FIND FIRST PERIOD\n         BZ    RETURN                  ERROR IF NO PERIOD FOUND\n         LR    R0,R3                   POINT TO GDG NAME\n         SLR   R1,R0                   COMPUTE LENGTH OF 1ST QUALIFIER\n         ICM   R1,B'1000',=C' '        PADDING CHARACTER\n         LA    R14,CATNAME             \"TO\" FIELD\n         ST    R14,LOCALIAS+4          UPDATE CAMLST\n         ST    R14,CTGCAT              UPDATE CTGPL\n         LA    R15,L'CATNAME           LENGTH\n         MVCL  R14,R0                  MOVE ALIAS TO CATNAME FIELD\n         LA    R0,WORK265              GET ADDRESS OF WORK AREA\n         ST    R0,LOCALIAS+12          UPDATE CAMLST\n         ST    R0,CTGWKA               UPDATE CTGPL\n         LOCATE LOCALIAS               FIND UCAT NAME\n         LTR   R15,R15                 CHECK SVC 26 RETURN CODE\n         BNZ   RETURN                  NO ALIAS, QUIT.\n*---------------------------------------------------------------------*\n*        BUILD CTGFV                                                  *\n*---------------------------------------------------------------------*\n         PACK  DWD,0(3,R4)             PACK 3-DIGIT GDGLIMIT\n         OI    DWD+7,X'0F'             PREVENT S0C7 IF ALL SPACES\n         CVB   R0,DWD                  CONVERT TO BINARY, GET S0C7\n         STC   R0,GDGLIMIT             KEEP GDG LIMIT\n         LA    R1,GDGLIMIT             GDG LIMIT\n         ST    R1,CTGFVLMT             SAVE ADDR INTO FVT\n         LA    R1,GDGATTR              GDG ATTRIBUTES\n         ST    R1,CTGFVGAT             SAVE ADDR INTO FVT\n         MVI   CTGFVTYP,C'B'           ENTRY TYPE (GDG BASE)\n         ST    R3,CTGFVENT             GDG NAME INTO CTGFVENT\n*---------------------------------------------------------------------*\n*        LISTCAT (RETRIEVE CURRENT GDG LIMIT)                         *\n*---------------------------------------------------------------------*\nP2LISTC  ST    R3,CTGENT               GDGNAME\n         MVC   WORK265(4),=Y(L'WORK265,0) FORMAT WORK AREA HEADER\n         MVI   CTGOPTNS,CTGLTCAT       FUNCTION = LISTCAT\n         CATALOG CTGPL                 IS GDG DEFINED ALREADY?\n         LTR   R15,R15                 CHECK SVC 26 RETURN CODE\n         BNZ   P3ZERO                  GDG ISN'T DEFINED, GO DO IT.\n         CLI   GDGLIMIT,0              GDGLIMIT=0?\n         BE    P3DELETE                YES, ISSUE DELETE GDG\n         L     R1,CTGFLPT              POINTER TO RETURNED GDGLIMIT\n         CLC   GDGLIMIT,0(R1)          COMPARE WITH PASSED VALUE\n         BE    RETURN                  GDG OK ALREADY, RETURN.\n*---------------------------------------------------------------------*\n*        ALTER IF GDG LIMIT IS DIFFERENT FROM THE ONE REQUESTED       *\n*---------------------------------------------------------------------*\nP3ALTER  MVI   CTGOPTNS,CTGALTER       ALTER\n         LA    R0,CTGFV                ADDR OF CTGFV\n         ST    R0,CTGFVT               STORE CTGFV ADDRESS INTO CTGPL\n         MVI   CTGFVFL2,X'02'          CTGFVAPP   FVT APPENDIX PRESENT\n         MVC   CTGFVID,=C'FVT '        EYE-CATCHER\n         MVC   CTGFVERS,=H'1'          VERSION\n         MVC   CTGFVLNA,=AL2(L'CTGFVXA) LENGTH OF FVT APPENDIX\n         MVI   CTGFVFL3,X'20'          CTGFVALM   ALTER GDG LIMIT\n         CATALOG CTGPL                 ALTER GDG LIMIT\n         B     RETURN\n*---------------------------------------------------------------------*\n*        DELETE GDG                                                   *\n*---------------------------------------------------------------------*\nP3DELETE MVI   CTGOPTNS,CTGDELET       FUNCTION = DELETE\n         CATALOG CTGPL                 DELETE EXISTING GDG\n         LTR   R15,R15                 CHECK SVC 26 RETURN CODE\n         BNZ   RETURN                  DELETE FAILED, RETURN\nP3ZERO   CLI   GDGLIMIT,0              CHECK GDGLIMIT\n         BE    RETURN                  QUIT IF GDGLIMIT=0\n*---------------------------------------------------------------------*\n*        RETRIEVE USERID FROM ACEE                                    *\n*---------------------------------------------------------------------*\n         L     R1,PSAAOLD-PSA          MY ASCB\n         L     R1,ASCBASXB-ASCB(,R1)   MY ASXB\n         L     R1,ASXBSENV-ASXB(,R1)   MY ACEE\n         LTR   R1,R1\n         BNP   P4DEFINE                NO ACEE, NO OWNER\n         MVC   OWNERID,ACEEUSRI-ACEE(R1)  MY RACF USER ID\n         LA    R0,CTGFL2               CTGFL FOR OWNER ID\n         ST    R0,CTGFV+28             SET POINTER TO OWNER ID\n*---------------------------------------------------------------------*\n*        DEFINE GDG WITH SCRATCH OPTION.                              *\n*---------------------------------------------------------------------*\nP4DEFINE MVI   CTGOPTNS,CTGDEFIN       FUNCTION = DEFINE\n         LA    R0,CTGFV                ADDR OF CTGFV\n         ST    R0,CTGFVT               STORE CTGFV ADDRESS INTO CTGPL\n         CATALOG CTGPL                 DEFINE GDG\n*\nRETURN   SAVE  15                      STORE RETURN CODE\n         FREEMAIN RU,LV=DYNL,A=(R9)    FREE DYNAMIC STORAGE AREA\n         RETURN (14,12)                RETURN, PASS RETURN CODE.\n***********************************************************************\n*                                                                     *\n*        CATALOG MANAGEMENT CONTROL BLOCKS: CTGPL, CTGFL, CTGFV       *\n*                                                                     *\n***********************************************************************\nCTGPL    DS    0F\nCTGOPTN1 DC    AL1(CTGNAME+CTGCNAME)   FIRST OPTION BYTE:\nCTGNAME  EQU   X'04'                     CTGENT POINTS TO ENTRY NAME\nCTGCNAME EQU   X'02'                     CTGCAT POINTS TO CATALOG NAME\n         DC    B'0'\nCTGFUNC  DC    AL1(CTGCMS+CTGAM0)      CALLER-REQUESTED FUNCTION\nCTGCMS   EQU   X'80'                     REQUEST IS IN CTGOPTNS\nCTGAM0   EQU   X'01'                     OS/VS2 CTGPL, NOT A CAMLST\n         DC    B'0'\nCTGFVT   DS    0A(*-*)                 ADDRESS OF CTGFV FOR DEFINE\nCTGENT   DC    A(*-*)                  ADDRESS OF ENTRY NAME\nCTGCAT   DC    A(*-*)                  ADDRESS OF CATALOG DSNAME\nCTGWKA   DC    A(*-*)                  ADDRESS OF CALLER'S WORK AREA\nCTGOPTNS DC    AL1(CTGLTCAT)           REQUEST:\nCTGLTCAT EQU   X'20' 0010 0...           LISTCAT\nCTGALTER EQU   X'10' 0001 0...           ALTER\nCTGDELET EQU   X'18' 0001 1...           DELETE\nCTGDEFIN EQU   X'08' 0000 1...           DEFINE\n         DC    B'0'\nCTGTYPE  DC    C'B'                    TYPE OF CAT. RECORD (GDG BASE)\nCTGNOFLD DC    FL1'1'                  NUMBER OF POINTERS IN CTGFIELD\nCTGFDBK  DC    XL2'0'                  FEEDBACK AREA\nCTGFBFLG DC    B'0'\n         DC    X'00'                   ERROR CODE\nCTGPSWD  DC    A(0)                    PASSWORD ADDRESS\nCTGFIELD DC    A(CTGFL)                POINTER(S) TO CTGFL(S)\n*\nCTGFL    DS    0F                   +0 FIELD DESCRIPTOR\nCTGFLDNO DC    FL1'1',5X'00'        +0 NUMBER OF FIELDS\nCTGFLDNM DC    A(FLDNM1,0)          +8 PTR TO FIELD NAME\nCTGFLNG  DC    F'0'                +16 LENGTH OF RETURNED DATA\nCTGFLPT  DC    A(*-*)              +20 ADDRESS OF RETURNED DATA\n*\nFLDNM1   DC    C'GDGLIMIT'             FIELD NAME\nGDGATTR  DC    B'01000000'             GDG ATTRIBUTES: SCRATCH, NOEMPTY\nGDGLIMIT DC    FL1'0'                  BINARY GDG LIMIT\nLOCALIAS CAMLST NAME,*-*,,*-*          LOCATE ALIAS\n*\nCTGFL2   DS    0F                   +0 FIELD DESCRIPTOR\n         DC    FL1'1',5X'00'        +0 NUMBER OF FIELDS\n         DC    A(FLDNM2,0)          +8 PTR TO FIELD NAME\n         DC    F'8'                +16 LENGTH OF RETURNED DATA\nCTGFL2PT DC    A(OWNERID)          +20 ADDRESS OF RETURNED DATA\n*\nFLDNM2   DC    C'OWNERID '             FIELD NAME\nOWNERID  DC    C'XXXXXXXX'             VALUE\n*---------------------------------------------------------------------*\n*        DYNAMIC STORAGE, BASED WITH R9.                              *\n*---------------------------------------------------------------------*\nDYN      DSECT\nCATNAME  DS    CL44' '                 CATALOG DSNAME\n*\nCTGFV    DS    0F,XL100\nCTGFVTYP EQU   CTGFV,1,C'C'            ENTRY TYPE\nCTGFVFL2 EQU   CTGFV+3,1,C'B'          FLAGS\nCTGFVENT EQU   CTGFV+20,4,C'A'         ENTRY NAME\nCTGFVLMT EQU   CTGFV+72,4,C'A'         GDG LIMIT\nCTGFVGAT EQU   CTGFV+76,4,C'A'         GDG ATTRIBUTES\nCTGFVXA  DS    XL40                    APPENDIX\nCTGFVID  EQU   CTGFVXA,4,C'C'          EYE CATCHER\nCTGFVERS EQU   CTGFVXA+4,2,C'H'        VERSION\nCTGFVLNA EQU   CTGFVXA+6,2,C'H'        LENGTH\nCTGFVFL3 EQU   CTGFVXA+8,2,C'B'        FLAGS\n*\nDWD      DS    D                       WORK\nWORK265  DS    XL265                   WORK AREA FOR LISTCAT, DELETE.\nDYNL     EQU   *-DYN\n         PRINT NOGEN\n         YREGS                         SYS1.MACLIB\n         IHAPSA DSECT=YES\n         IHAASCB DSECT=YES,LIST=NO\n         IHAASXB\n         IHAACEE\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//LKED    EXEC PGM=IEWL,PARM=REUS\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=GILBERT.LOAD(DEFGDGSR),DISP=SHR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DONTFAIL": {"ttr": 6149, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//GILBERTF JOB (ACCT#),DONTFAIL,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = DONTFAIL                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = DUMMY OUT NEXT STEP'S UNCATALOGED DATA SETS      *\n*                                                                     *\n* FUNCTION = This program has been designed to prevent jobs that      *\n*            accept multiple inputs from failing in the middle        *\n*            of the night because of a \"typo\" in a data set name.     *\n*            When DONTFAIL detects that an input data set is not      *\n*            cataloged, it converts it to a null data set and         *\n*            allows the job to run with partial input.                *\n*                                                                     *\n* STATUS = R106                                                       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = MVS/ESA                                           *\n*                   STRING macro R507                                 *\n*                                                                     *\n*    AUTHORIZATION = APF                                              *\n*                                                                     *\n*    RESTRICTIONS = NONE                                              *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (Batch Program)                            *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 4K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE ANY, AMODE 31,                   *\n*                 SUPERVISOR STATE, KEY 1                             *\n*                                                                     *\n* OPERATION = see below                                               *\n*                                                                     *\n*            DONTFAIL must be executed immediately before the job     *\n*            step to \"protect\", as shown in the following example:    *\n*                                                                     *\n*              //DONTFAIL EXEC PGM=DONTFAIL                           *\n*              //*                                                    *\n*              //SORT53    EXEC PGM=SORT                              *\n*              //SORTIN     DD DSN=USER.INPUT1,DISP=SHR               *\n*              //           DD DSN=USER.INPUT2,DISP=SHR               *\n*                                                                     *\n*            If any input data set in step SORT52 in not cataloged,   *\n*            DONTFAIL will make it a null data set, preventing the    *\n*            job from failing with a DATA SET NOT FOUND error.        *\n*                                                                     *\n*            To detect uncataloged data sets and correct them,        *\n*            DONTFAIL proceeds as follows:                            *\n*                                                                     *\n*            1. scan the SWA control blocks that represent            *\n*               the following step's DD statements for input          *\n*               data sets (i.e. DISP=OLD or DISP=SHR)                 *\n*            2. check the catalog status of each input data set       *\n*            3. modify SWA control blocks to convert each             *\n*               non-cataloged data set to a null data set             *\n*            4. set DCB attributes (optional, see below)              *\n*                                                                     *\n*            NOTES:                                                   *\n*                                                                     *\n*              a. DONTFAIL must be executed once for every            *\n*                 job step that needs to be protected.                *\n*                                                                     *\n*              B. Prior to using DONTFAIL, you must allocate and      *\n*                 catalog an empty disk data set and specify its      *\n*                 name in the SETC instruction below.  You can use    *\n*                 an already-defined pattern DSCB if it has been      *\n*                 created with RECFM=,LRECL=0,BLKSIZE=0.              *\n*                                                                     *\n*              C. The last DD in a concatenation (or the only DD      *\n*                 of a non-concatenated data set) is changed to       *\n*                 DD DUMMY; for other DD statements, the DSN          *\n*                 is changed to &DONTFAIL                             *\n*                                                                     *\n&DONTFAIL SETC 'SYS2.DONTFAIL'    <=== DSN of the empty data set\n*                                                                     *\n*            DCB ATTRIBUTES                                           *\n*                                                                     *\n*              When changing the DSN of a data set in a concate-      *\n*              nation, DONTFAIL also carries DCB attributes (RECFM,   *\n*              LRECL, BLKSIZE) from DDs previously concatenated to    *\n*              the same DDname. This prevents utility programs such   *\n*              as SORT or IDCAMS REPRO from failing when the empty    *\n*              data set has incompatible DCB attributes or no DCB     *\n*              attributes at all.                                     *\n*                                                                     *\n*              Example:                                               *\n*                                                                     *\n*                //COPY53  EXEC PGM=IDCAMS                            *\n*                //DD1      DD DSN=USER.INPUT1,DISP=SHR,              *\n*                //            RECFM=FB,LRECL=124                     *\n*                //         DD DSN=USER.INPUT2,DISP=SHR               *\n*                //         DD DSN=USER.INPUT3,DISP=SHR               *\n*                //DD2      DD DSN=USER.INPUT4,DISP=SHR,              *\n*                //            RECFM=FB,LRECL=124                     *\n*                                                                     *\n*                In this example, if USER.INPUT2 is not cataloged,    *\n*                it is changed to DSN=&DONTFAIL, and                  *\n*                RECFM=FB,LRECL=124,BLKSIZE=124 are added also.       *\n*                If BLKSIZE is not specified, it is set equal to      *\n*                LRECL+4 if RECFM=VB was specified, otherwise,        *\n*                BLKSIZE is set equal to LRECL.  In this example      *\n*                also, if USER.INPUT3 or USER.INPUT4 are not          *\n*                cataloged, they are changed to DD DUMMY.             *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n* 100 Program rewritten for MVS/ESA                                   *\n* 101 Ignore data sets with VOL=REF to a DISP=NEW DD                  *\n* 102 Force SDATA=(LSQA,SWA) in case of an abend                      *\n* 103 Change to DSN=&DONTFAIL instead of DD DUMMY                     *\n*     if JCL specifies FREE=CLOSE                                     *\n* 104 Ignore temporary data sets                                      *\n* 105 Invoke PGM=RECALL if it's been linked with DONTFAIL             *\n* 106 Change STRING GENERATE to STRING 507 format                     *\n*                                                                     *\n&REL     SETA  106                                                    *\n***********************************************************************\nDONTFAIL CSECT\nDONTFAIL RMODE ANY\n         DC    C'GSF UTILITIES - DONTFAIL R&REL '\nBEGIN    BAKR  R14,0                   SAVE REGISTERS\n         LR    R12,R15\n         USING BEGIN,R12\n         MODESET MODE=SUP              SWITCH TO SUPERVISOR MODE\n         ESTAE DUMPOPT,CT\n         STORAGE OBTAIN,LENGTH=DYNAML,SP=230,KEY=1\n         ST    R1,8(,R13)              chain save areas\n         MODESET EXTKEY=JES            SWITCH TO KEY=1\n         ST    R13,4(,R1)              chain save areas\n         LR    R13,R1                  ADDRESS OF DYNAMIC STORAGE AREA\n         USING DYNAM,R13\n         LA    R0,DYNAM+72             CLEAR WORKING STORAGE TO X'00'\n         LA    R1,DYNAML-72            CLEAR WORKING STORAGE TO X'00'\n         SLR   R15,R15                 CLEAR WORKING STORAGE TO X'00'\n         MVCL  R0,R14                  CLEAR WORKING STORAGE TO X'00'\n***********************************************************************\n*                                                                     *\n*        LOCATE TCB, JSCB, GDGNT.                                     *\n*        LOCATE SCT AND 1ST SIOT FOR NEXT STEP.                       *\n*                                                                     *\n***********************************************************************\n         L     R1,540(,0)              PSATOLD\n         L     R3,TCBJSCB-TCB(,R1)     GET THE ADDRESS OF MY JSCB\n         USING IEZJSCB,R3\n         L     R4,JSCBJCT              Address of JCT prefix\n         USING INJMJCT-16,R4\n*\n         ICM   R1,B'0111',JCTGDGNT     3-BYTE SVA OF GDG NAME TABLE\n         BZ    MY_SCT                  JUMP IF THERE IS NO GDGN TABLE\n         BAL   R14,SWAREQ              CONVERT SVA TO 31-BIT ADDRESS\n         ST    R1,GDGNTPTR             KEEP ADDRESS OF GDG NAMES TABLE\n*\nMY_SCT   SLR   R5,R5\n         ICM   R5,B'0111',JSCSCTP      3-BYTE SVA OF CURRENT STEP'S SCT\n         USING INSMSCT-16,R5\n*\nNEXT_SCT ICM   R5,B'0111',SCTANSCT     LOAD 3-BYTE SVA OF NEXT SCT\n         BZ    RETURN                  RETURN IF THERE IS NO NEXT STEP\n         ICM   R1,B'0111',SCTFSIOT     LOAD 3-BYTE SVA OF 1ST SIOT\n         BZ    RETURN                  NO DD CARDS, RETURN\n***********************************************************************\n*                                                                     *\n*        LOOP THRU THE SIOT BLOCKS                                    *\n*                                                                     *\n***********************************************************************\n*LOOP\nLOOPSIOT BAL   R14,SWAREQ              CONVERT SVA TO 31-BIT ADDRESS\n         LR    R6,R1                   ADDRESS OF SIOT\n         USING SIOT,R6\n         IC    R1,SEQNO                INCREMENT CURRENT SEQNO\n         LA    R1,1(,R1)               INCREMENT CURRENT SEQNO\n         STC   R1,SEQNO                INCREMENT CURRENT SEQNO\n         TM    SCTSBYT1,SIOTCCAT       CHECK FOR CONCATENATION\n         BO    TESTDISP                JUMP IF NO DDNAME\n         MVC   DDNAME,SCTDDNAM         KEEP DDNAME\n         MVI   SEQNO,0                 RESET DDSEQ\n         SLR   R0,R0\n         STCM  R0,B'0001',RECFM        zero DCB attributes\n         STCM  R0,B'0011',LRECL        zero DCB attributes\n         STCM  R0,B'0011',BLKSIZE      zero DCB attributes\n*\nTESTDISP TM    SCTSBYT3,SCTSOLD        Check for DISP=OLD (or SHR)\n         BNO   NEXTSIOT                JUMP IF NOT DISP=OLD\n         CLI   SCTUTYPE,C' '           CHECK UNIT NAME\n         BH    NEXTSIOT                JUMP IF THERE IS A UNIT NAME\n*\n*        Ignore DD with VOL=REF to a DISP=NEW data set\n*\n         ICM   R1,B'0111',SIOTVRSB     LOAD 3-BYTE SVA OF VOL=REF SIOT\n         BZ    LOCJFCB                 NO VOL=REF, JUMP\n         BAL   R14,SWAREQ              CONVERT SVA TO 31-BIT ADDRESS\n         TM    SCTSBYT3-SIOT(R1),SCTSNEW   VOL=REF DD has DISP=NEW?\n         BO    NEXTSIOT                yes, ignore current DD\n*\nLOCJFCB  ICM   R1,B'0111',SCTPJFCB     LOAD 3-BYTE SVA OF JFCB\n         BAL   R14,SWAREQ              CONVERT SVA TO 31-BIT ADDRESS\n         LR    R7,R1                   ADDRESS OF JFCB\n         USING JFCB,R7\n         TM    JFCBIND2,JFCTEMP        temporary data set?\n         BO    NEXTSIOT                yes, ignore current DD\n         CLI   JFCBELNM,C'+'           DSNAME(+1)  ?\n         BE    NEXTSIOT                YES, IGNORE\n         MVC   DSNAME,JFCBDSNM         MOVE DSN TO UNPROTECTED STORAGE\n*\nSAVEDCB  ICM   R0,B'0001',JFCRECFM     RECFM present on this DD?\n         BZ    SAVEDCB2                no, jump\n         STCM  R0,B'0001',RECFM        save non-zero DCB attributes\nSAVEDCB2 ICM   R0,B'0011',JFCLRECL     LRECL present on this DD?\n         BZ    SAVEDCB8                no, jump\n         STCM  R0,B'0011',LRECL        save non-zero DCB attributes\n         ICM   R0,B'0001',JFCRECFM     RECFM present on this DD?\n         BNZ   SAVEDCB8                yes, jump\n         MVI   RECFM,JFCFIX+JFCRFB     if LRECL is present but RECFM   +\n                                       is not, assume RECFM=FB\nSAVEDCB8 ICM   R0,B'0011',JFCBLKSI     LRECL present on this DD?\n         BZ    *+8                     no, jump\n         STCM  R0,B'0011',BLKSIZE      save non-zero DCB attributes\n*--------------------------------------------------------------------*\n*                                                                    *\n*        IF THE CURRENT DATA SET IS A GDG, SCAN THE GDG NAMES TABLE  *\n*        FOR THE CURRENT APPARENT GEN (0), IF ANY.                   *\n*                                                                    *\n*--------------------------------------------------------------------*\nGDG000   TM    JFCBIND1,JFCGDG         CHECK GDG INDICATOR\n         BNO   GDG099                  JUMP IF NOT GDG\n         ICM   R1,B'1111',GDGNTPTR     LOAD ADDR OF GDG NAMES TABLE\n         BZ    GDG080                  JUMP IF NO GDGNT\n         USING GDGNTABL,R1\n*--loop\nGDG010   SLR   R14,R14                 PREPARE IC\n         IC    R14,GDGNNO              GET NUMBER OF ENTRIES\n*----loop\nGDG015   CLC   GDGNGDG,DSNAME          COMPARE TABLE ENTRY W/ DSNAME\n         BE    GDG040                  JUMP IF NOT THE SAME\n         LA    R1,GDGNGDG2             BUMP UP TO NEXT ENTRY IN BLOCK\n         BCT   R14,GDG015              LOOP UNTIL END OF BLOCK\n*----endloop\n         ICM   R1,B'1111',GDGNNEXT     LOAD ADDR OF NEXT GDGNT BLOCK\n         BNZ   GDG010                  PROCESS NEXT BLOCK\n*--endloop\n         NI    CTGOPTN3,255-CTGGDGL    CTGWAGB IS NOT SET\n         B     GDG080                  EXIT GDGNT SCAN LOOP\n*\nGDG040   LA    R0,GDGNGDGZ             GET PTR TO APPARENT GEN(0)\n         ST    R0,CTGWAGB              SET POINTER IN SVC 26 WORK AREA\n         OI    CTGOPTN3,CTGGDGL        SHOW CTGWAGB IS SET\n         DROP  R1                      GDGNTABL\n*\n*        append relative gen number to end of data set name\n*\nGDG080   STRING (JFCBDSNM,,T),'(',(JFCBELNM,,T),')',INTO=DSNAME\nGDG099   EQU   *\n*--------------------------------------------------------------------*\n*                                                                    *\n*        GET DEVICE TYPE INFORMATION FROM THE CATALOG.               *\n*                                                                    *\n*--------------------------------------------------------------------*\nLOCATE   LA    R0,DSNAME               DATA SET NAME\n         ST    R0,CTGENT               ENTRY ADDRESS\n         OI    CTGOPTN1,CTGNAME        CTGENT POINTS TO ENTRY NAME\n         LA    R0,CTGWA                WORK AREA FOR SUPERLOCATE\n         ST    R0,CTGWKA               WORK AREA FOR SUPERLOCATE\n         OI    CTGOPTN3,CTGSUPLT       SUPER LOCATE\n         OI    CTGOPTN3,CTGAM0         OS/VS2 CATALOG MGMT REQUEST\n         LA    R0,CTGVL                GET ADDR OF VOLUME LIST\n         ST    R0,CTGWAVL              UPDATE PTR\n         LA    R0,CTGVLLEN             GET LENGTH OF VOLUME LIST\n         STH   R0,CTGWALV              UPDATE LENGTH\n         LOCATE CTGPL                  ISSUE SUPERLOCATE\n         LTR   R15,R15                 DATA SET cataloged?\n         BZ    NEXTSIOT                yes, ignore it\n*---------------------------------------------------------------------*\n*                                                                     *\n*        If this data set is not cataloged, modify the SIOT & JFCB    *\n*                                                                     *\n*          1.  if the DD has other DDs concatenated behind it,        *\n*              or the DD has FREE=CLOSE,                              *\n*                set DSNAME to \"&DONTFAIL\"                            *\n*              else                                                   *\n*                set DD DUMMY flag in SIOT                            *\n*          2.  carry DCB attributes from previous DD in               *\n*              concatenation                                          *\n*          3.  Issue message to operator                              *\n*                                                                     *\n*---------------------------------------------------------------------*\nMSG00    MVC   WTO1L(WTO1LL),WTO1M     move model to dynamic\n         STRING '&DONTFAIL',INTO=DSNAME\n*\n         ICM   R1,B'0111',SCTPSIOT     SVA OF NEXT SIOT\n         BZ    MSG12                   last DD, jump\n         BAL   R14,SWAREQ              CONVERT SVA TO 31-BIT ADDRESS\n         TM    SCTSBYT1-INDMSIOT(R1),SIOTCCAT   concatenated DD?\n         BO    MSG20                   yes, jump\n         TM    SCTSBYT2,SIOCLUNL       FREE=CLOSE?\n         BO    MSG20                   yes, jump\n*\nMSG12    STRING 'DD DUMMY',INTO=DSNAME\n         OI    SCTSBYT1,SCTDUMMY       DD DUMMY\n*\nMSG20    STRING 'DONTFAIL - ',                                         +\n               (JFCBDSNM,,T),' changed to ',(DSNAME,,T),               +\n               '  (DDN=',DDNAME,       do not close parenthesis        +\n               INTO=WTO1TEXT\n         CLI   SEQNO,0                 first DD in concat?\n         BE    MSG80                   yes, jump\n         STRING (WTO1TEXT,,T),'+',(SEQNO,FL1,L),                       +\n               INTO=WTO1TEXT\n*\nMSG80    CLC   =C'DD ',DSNAME          changed to DD DUMMY ?\n         BE    MSG81                   yes, do not change JFCB\n         MVC   JFCBDSNM,DSNAME         move new dsname\n*\n*        Carry DCB attributes from previous DD\n*\nMSG81    ICM   R0,B'0001',JFCRECFM     RECFM specified in JCL?\n         BNZ   MSG88L                  yes, jump\n         MVC   JFCRECFM,RECFM          no, carry from previous DD\nMSG88L   ICM   R0,B'0011',JFCLRECL     LRECL specified in JCL?\n         BNZ   MSG88B                  yes, jump\n         MVC   JFCLRECL,LRECL          no, carry from previous DD\nMSG88B   ICM   R1,B'0011',JFCBLKSI     BLKSIZE specified in JCL?\n         BNZ   MSG90                   yes, exit\n         ICM   R1,B'0011',BLKSIZE      BLKSIZE on previous DD?\n         BNZ   MSG88B4                 yes, use it\n         ICM   R1,B'0011',LRECL        LRECL on previous DD?\n         BZ    MSG90                   no, exit\n         TM    JFCRECFM,JFCVAR         RECFM=V ?\n         BZ    MSG88B4                 no, set BLKSIZE=LRECL\n         LA    R1,4(,R1)               yes, set BLKSIZE=LRECL+4\nMSG88B4  STCM  R1,B'0011',JFCBLKSI     update BLKSIZE\n*\n*        Issue message to operator\n*\nMSG90    STRING (WTO1TEXT,,T),',DCB=',(JFCRECFM,,X),'/',               X\n               (JFCLRECL,H,L),'/',(JFCBLKSI,H,L),')',INTO=WTO1TEXT\n         WTO   MF=(E,WTO1L)            NOTIFY PROGRAMMER\n*\nNEXTSIOT ICM   R1,B'0111',SCTPSIOT     SVA OF NEXT SIOT\n         BNZ   LOOPSIOT                PROCESS NEXT DD CARD IN STEP\n*ENDLOOP\n         DROP  R5,R6,R7                SCT, SIOT, JFCB\n***********************************************************************\n*                                                                     *\n*        CLEAN-UP, RETURN TO CALLER.                                  *\n*                                                                     *\n***********************************************************************\nRETURN   LR    R1,R13                  addr of work area\n         L     R13,4(,R13)             caller's save area\n         STORAGE RELEASE,LENGTH=DYNAML,ADDR=(R1),SP=230,KEY=1\n*\n*        invoke PGM=RECALL\n*\n         WXTRN RECALL                  optional\n         MODESET KEY=NZERO\n         ICM   R15,B'1111',=A(RECALL)  get addr of RECALL pgm\n         BZ    RETURN99                not available, jump\n         EREG  R0,R1                   restore parm address\n         BALR  R14,R15              <- invoke PGM=RECALL\n*\n         SLR   R15,R15                 RC=00\nRETURN99 EQU   *\n         PR                            GOBACK\n***********************************************************************\n*        SUB-ROUTINE TO ACCESS THE SWA MANAGER                        *\n***********************************************************************\nSWAREQ   BAKR  R14,0                   save registers\n         LA    R2,CTGVL                WORK AREA\n         ST    R2,EPAPTR               STORE POINTER\n         USING ZB505,R2\n         XC    SWAEPAX,SWAEPAX         CLEAR 32 BYTES\n         STCM  R1,B'0111',SWVA         STORE 3-BYTE SVA\n         SWAREQ FCODE=RL,EPA=EPAPTR,MF=(E,SWAREQL1)\n         L     R1,SWBLKPTR             LOAD SWA CONTROL BLOCK ADDRESS\n         PR                            GOBACK\n         DROP  R2                      WAS ZB505\n*\n&WTO1    SETC  (120)' '\nWTO1M    WTO   '&WTO1',MF=L,ROUTCDE=11\n*---------------------------------------------------------------------\n*        ESTAE routine: changed dump options\n*---------------------------------------------------------------------\n         USING SDWA,R1\nDUMPOPT  OI    SDWASDA0,SDWALSQA+SDWASWA dump LSQA and SWA\n         OI    SDWADPFS,SDWADLST       DUMP OPTIONS VALID\n         BR    R14\n*---------------------------------------------------------------------\n*        DYNAMIC STORAGE AREA, BASED BY R13.\n*---------------------------------------------------------------------\nDYNAM    DSECT\n         DS    18F                     STANDARD SAVE AREA\nSWAREQL1 SWAREQ MF=L                   PARM LIST FOR SWAREQ\nEPAPTR   DS    F                       POINTER TO EPA (ZB505)\nGDGNTPTR DS    A(GDGNTABL)             POINTER TO GDG NAMES TABLE\nTAPE1    DS    XL2                     INTERNAL DD# FOR 1ST TAPE DD\nDDNAME   DS    CL8                     DDNAME\nRECFM    DS    X                       RECFM\nLRECL    DS    H                       LRECL\nBLKSIZE  DS    H                       BLKSIZE\nSEQNO    DS    FL1                     SEQNO (concatenation)\nDSNAME   DS    CL44                    MODIFIABLE DSNAME\nWTO1L    WTO   '&WTO1',MF=L,ROUTCDE=11\nWTO1LL   EQU   *-WTO1L\nWTO1TEXT EQU   WTO1L+4,120\n*---------------------------------------------------------------------*\n*        CATALOG PARAMETER LIST\n*---------------------------------------------------------------------*\nCTGPL    DS    0D\nCTGOPTN1 DS    B              FIRST OPTION BYTE:\nCTGNAME  EQU   X'04' .... .1..  CTGENT CONTAINS DSNAME OR SERIAL ADDR\nCTGOPTN2 DS    B              SECOND OPTION BYTE\nCTGOPTN3 DS    B     XXX. ....  SPECIFIES THE CALLER-REQUESTED FUNCTION\nCTGSUPLT EQU   X'10' ...1 ....  SUPERLOCATE FUNCTION\nCTGGDGL  EQU   X'08' .... 1...  GDG LOCATE - CALLER SUPPLIED BASE LEVEL\nCTGAM0   EQU   X'01' .... ...1  OS/VS2 CATALOG MANAGMENT REQUEST\nCTGOPTN4 DS    B              FOURTH OPTION BYTE\nCTGLBASE EQU   X'80' 1... ....  LOCATE BASE LEVEL (SUPERLOCATE GDG)\nCTGENT   DS    A              ADDRESS OF CATALOG RECORD IDENTIFIER\nCTGCAT   DS    A              ADDRESS OF CATALOG DSNAME OR ACB\nCTGWKA   DS    A              ADDRESS OF CALLER'S WORK AREA\nCTGOPTNS DS    B              CATALOG MANAGMENT SERVICES REQUEST OPTION\n         DS    B              RESERVED\nCTGTYPE  DS    C              TYPE OF CATALOG RECORD\nCTGNOFLD DS    FL1            NUMBER OF ENTRIES IN CTGFIELD\nCTGFDBK  DS    XL2            FEEDBACK AREA (IF NOT SUPERLOCATE)\nCTGFBFLG DS    B              FLAGS (SUPERLOCATE)\nCTGPAR   EQU   X'80' 1... ....  PARALLEL MOUNT\nCTGKEEP  EQU   X'40' .1.. ....  FORCED KEEP\nCTGGDGB  EQU   X'20' ..1. ....  GDG BASE LOCATED\nCTGNGDSN EQU   X'10' ...1 ....  GDG DSNAME GENERATED (DSNAME.GXXXXVYY)\n         DS    B              RESERVED (SUPERLOCATE)\nCTGPSWD  DS    A              ADDRESS OF CALLER-SUPPLIED PASSWORD\n*---------------------------------------------------------------------*\n*        CATALOG WORK AREA\n*---------------------------------------------------------------------*\nCTGWA    DS    0D\nCTGWAVL  DS    A                       PTR TO CTGVL (VOLUME LIST)\nCTGWALV  DS    H                       LENGTH OF THE VOLUME LIST\nCTGWAVCT DS    H                       # OF VOLSERS RETURNED IN VL\nCTGWAUCT DS    H                       MINIMUM # OF VOLS TO BE MOUNTED\nCTGWAGCT DS    H                       # OF GENERATIONS CATALOGED\nCTGWAGB  DS    A                       PTR TO APPARENT GEN(0)\n*---------------------------------------------------------------------*\n*        CATALOG VOLUME LIST\n*---------------------------------------------------------------------*\nCTGVL    DS    0D\nCTGVLVOL DS    CL6                     VOLUME SERIAL\nCTGVLDEV DS    XL4                     DEVICE TYPE\nCTGVLSEQ DS    H                       FILE SEQNO\nCTGVLX   DS    19XL12                  VOLUME LIST EXTENSION\nCTGVLLEN EQU   *-CTGVL                 LENGTH OF VOLUME LIST\nDYNAML   EQU   *-DYNAM\n*---------------------------------------------------------------------\n*        GDG NAMES TABLE MAPPING (USING IEFZB902 AS A MODEL)\n*---------------------------------------------------------------------\nGDGNTABL DSECT\nGDGNQSVA DS    XL3                     SVA OF NEXT GDGNT RECORD\nGDGNTID  DS    X'23'                   GDGNT ID X'23'\nGDGNNEXT DS    A                       IN-CORE ADDRESS OF NEXT RECORD\nGDGNGDG  DS    CL35                    GDG BASE\nGDGNGDGZ DS    C'1234'                 APPARENT (0) GENERATION\nGDGNGDG2 DS    CL35,C'1234'            2ND GDG NAME\n         DS    CL35,C'1234'            3RD GDG NAME\n         DS    CL35,C'1234'            4TH GDG NAME\nGDGNNO   DS    FL1                     NUMBER OF ENTRIES\n         DS    XL15                    FILLER\nGDGNLEN  EQU   GDGNTABL+176\n*---------------------------------------------------------------------\n*        MAPPING MACROS\n*---------------------------------------------------------------------\n         PRINT NOGEN\nPRINT    OPSYN ANOP\n         YREGS                         REGISTER EQUATES\n         IEFZB505 LOCEPAX=YES          EPA MAPPING FOR SWAREQ\n         IEFJESCT TYPE=DSECT           JES CONTROL TABLE\n         IKJTCB LIST=NO                TASK CONTROL BLOCK\n         IEZJSCB                       JOB STEP CONTROL BLOCK\nJCT      DSECT\n         IEFAJCTB                      JOB CONTROL BLOCK\nSCT      DSECT\n         IEFASCTB                      STEP CONTROL BLOCK\nSIOT     DSECT\n         IEFASIOT                      STEP I/O TABLE\nJFCB     DSECT\n         IEFJFCBN LIST=YES             JOB FILE CONTROL BLOCK\n         CVT   LIST=NO,DSECT=YES       COMMUNICATION VECTOR TABLE\n         IHASDWA VRAMAP=NO             ESTAE\n         STRING (GENERATE,NO_CSECT)    Generate Literals\n         STRING GENERATE               Generate CSECT (Full)\n         END   BEGIN\n//SYSLIB   DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=CBTTAPE.FILE183.PDS,DISP=SHR      STRING macro\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,5)\n//SYSPRINT DD SYSOUT=*\n//*\n//LKED    EXEC PGM=LINKLLA,PARM='RENT,AC=1'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,DELETE)\n//         DD *\n INCLUDE SYSLMOD(RECALL)\n//SYSLMOD  DD DSN=SYS2.AUTHLIB(DONTFAIL),DISP=SHR\n//*\n//NULLFIL1 EXEC PGM=DONTFAIL\n//SYSUDUMP DD SYSOUT=*\n//ABNLIGNR DD DUMMY\n//*\n//REPRO1   EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//INDD     DD DSN=GILBERT.UNCAT1,LRECL=80,DISP=SHR  ,RECFM=FB\n//         DD DSN=GILBERT.X80,DISP=SHR\n//         DD DSN=IBMUSER.UNCAT2,DISP=SHR\n//OUTDD    DD DUMMY,BLKSIZE=800\n REPRO IFILE(INDD) OFILE(OUTDD)\n//DISPMOD  DD UNIT=SYSDA,SPACE=(TRK,0),DSN=&&REFMOD,DISP=MOD\n//VOLREF1  DD VOL=REF=*.DISPMOD,DSN=*.DISPMOD,DISP=OLD\n//DISPNEW  DD UNIT=SYSDA,SPACE=(TRK,0),DSN=&&REFNEW,DISP=NEW\n//VOLREF2  DD VOL=REF=*.DISPNEW,DSN=*.DISPNEW,DISP=OLD\n//*\n//NULLFIL2 EXEC PGM=DONTFAIL\n//SYSUDUMP DD SYSOUT=*\n//ABNLIGNR DD DUMMY\n//*\n//SORT2   EXEC PGM=SORT\n//SYSOUT   DD SYSOUT=*\n//SORTIN   DD DSN=GILBERT.UNCAT1,LRECL=80,DISP=SHR  ,RECFM=FB\n//         DD DSN=GILBERT.X80,DISP=SHR\n//         DD DSN=GILBERT.UNCAT2,DISP=SHR\n//SORTOUT  DD DUMMY,BLKSIZE=800\n SORT FIELDS=(1,8,CH,A)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSLIST": {"ttr": 6404, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\r\\x00\\x00\\x00\\x90\\x17\\x7f\\x00\\x98\\x15\\x0f\\x12)\\x012\\x00\\x02\\x00\\xe7\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "02.13", "flags": 0, "createdate": "1990-06-26T00:00:00", "modifydate": "1998-05-30T12:29:00", "lines": 306, "newlines": 2, "modlines": 231, "user": "CBT472"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* Module Name: DSLIST                                                */\n/*                                                                    */\n/* Descriptive Name: Cursor-driven entry into PDF 3.4 panel           */\n/*                                                                    */\n/* Status: R213                                                       */\n/*                                                                    */\n/* Function: This REXX program allows you to invoke the data-set      */\n/*           list function of ISPF/PDF (option 3.4) with the          */\n/*           DSNAME LEVEL field set to the dsname under which         */\n/*           the cursor is placed when you enter the command.         */\n/*           When running in ISPF 4.2, the Work Place (opt 11)        */\n/*           is invoked instead of the Data Set List Utility.         */\n/*                                                                    */\n/* Author: Gilbert Saint-Flour <carlos@gsf-soft.com>                  */\n/*                                                                    */\n/* Environment: TSO/E V2                                              */\n/*              ISPF/PDF V3 or V4                                     */\n/*                                                                    */\n/* Operation:                                                         */\n/*                                                                    */\n/*     DSLIST may be invoked as a command or as an EDIT macro.        */\n/*                                                                    */\n/*     o  To invoke DSLIST as a command, enter TSO %DSLIST in the     */\n/*        command field, move the cursor under a data set name        */\n/*        currently appearing on your screen and press ENTER.         */\n/*        DSLIST extracts the data set name from the screen,          */\n/*        invokes the Data Set List utility (opt 3.4) and places      */\n/*        the data set name in the DSNAME LEVEL field.  In the        */\n/*        ISPF 4.2 environment, DSLIST invokes the ISPF Workplace     */\n/*        (opt 11) instead of the Data Set List utility.              */\n/*                                                                    */\n/*     o  To invoke DSLIST as an EDIT macro, type %DSLIST in the      */\n/*        command field, move the cursor under a data set name        */\n/*        currently appearing on your screen and press ENTER.         */\n/*                                                                    */\n/* Notes:                                                             */\n/*                                                                    */\n/*     o  DSLIST extracts data set names in upper-case only.          */\n/*                                                                    */\n/*     o  A data set name in a message can not be extracted.          */\n/*                                                                    */\n/*     o  When invoked as a command, the data set name must be        */\n/*        entirely visible on the screen.                             */\n/*                                                                    */\n/*     o  When invoked as an EDIT macro, the data set name only       */\n/*        needs to be partially visible but it must be on a           */\n/*        DATA line.                                                  */\n/*                                                                    */\n/*     o  When invoked as an EDIT macro, DSLIST uses standard ISREDIT */\n/*        functions to retrieve the text at the cursor position.      */\n/*                                                                    */\n/*     o  When invoked as a command, DSLIST accesses control          */\n/*        blocks that are not part of the standard ISPF               */\n/*        programming interface to retrieve the screen image and      */\n/*        cursor position.  This method works with ISPF/PDF V2R3      */\n/*        thru V4R5 but may not work in future releases.              */\n/*        This technique is borrowed from ISPCDSN, a program written  */\n/*        by Gordon J. Schillinger, to whom I'm for ever grateful.    */\n/*                                                                    */\n/*     o  Assign TSO %DSLIST to a PFK in those ISPF applications      */\n/*        that allow you to view job output: SDSF, SAR, IOF, etc.     */\n/*        In some applications (such as SYSVIEW), you MUST invoke     */\n/*        DSLIST using a PFK.                                         */\n/*                                                                    */\n/*     o  When DSLIST is invoked outside of PDF (i.e ZAPPLID is NOT   */\n/*        equal to ISR), DSLIST re-invokes itself with NEWAPPL(ISR)   */\n/*        to ensure the same PFK setting as when option 3.4 is        */\n/*        invoked from the PDF main menu.                             */\n/*                                                                    */\n/*     o  To enable their cursor-driven capability, commercial        */\n/*        products like MVS/QuickRef require you to modify the        */\n/*        main panel of every application in which you intend to      */\n/*        use it.  DSLIST does not require any panel modification.    */\n/*                                                                    */\n/* Change Activity:                                                   */\n/*                                                                    */\n/*  @206 Fix DEBUG option, add \"_\" as dsname delimiter                */\n/*  @207 Rewrite DSN extraction algorithm to support dynamic areas    */\n/*       and windows; dsname must be in upper-case.                   */\n/*  @208 If the cursor is placed under a DSN= or DSNAME= string,      */\n/*       extract the dsname to the right of the = sign.               */\n/*  @209 Invoke ISPF Workplace in the ISPF 4.2 environment            */\n/*  @210 Minor technical changes and documentation improvements       */\n/*  @211 Prevent error when csrw=0                                    */\n/*  @212 Add PROFILE option on VPUT commands                          */\n/*  @213 Rewrite dsname extraction algorithm                          */\n/**********************************************************************/\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\nZerrmsg=''\nDsname=''\n\"ISREDIT MACRO (DEBUG)\"\nIf rc = 0 THEN DO                     /*   if we've been invoked as   */\n  UPPER debug                         /*   an edit macro, use ISREDIT */\n  \"ISREDIT (LINE,CSRP) = CURSOR\"      /*   to retrieve the line and   */\n  \"ISREDIT (LINE) = LINE .ZCSR\"       /*   cursor position            */\n  IF csrp>0 THEN                      /*   then                       */\n    CALL extract_dsname               /*   extract the dsname         */\n  END\nELSE DO                               /*  DSLIST invoked as a command */\n  ARG debug\n  \"VGET ZAPPLID\"                      /*   Get current application ID */\n  IF zapplid \\= 'ISR' THEN DO         /*   If ZAPPLID\\=ISR, re-invoke */\n    \"SELECT CMD(%\"SYSVAR(SYSICMD) debug \") NEWAPPL(ISR)\"\n    EXIT rc                           /*   DSLIST with NEWAPPL(ISR)   */\n    END\n  CALL find_cursor_position           /*   find the cursor position,  */\n  CALL extract_dsname                 /*   extract the dsname         */\n  END\n\"VGET ZENVIR\"                         /* Retrieve ISPF Version        */\n /* Zenvir='ISPF 4.1' */              /* Force usage of DSLIST        */\nIF LEFT(Zenvir,8) < 'ISPF 4.2' THEN\n  CALL Invoke_ISRUDL                  /* Data Set List Utility (3.4)  */\nELSE\n  CALL Invoke_Work_Place              /* Work Place Utility (opt 11)  */\nIF zerrmsg\\='' THEN \"SETMSG MSG(\"zerrmsg\")\"\nEXIT\n/*-------------------------------------------------------- sub-routine*/\n/*                                                                    */\n/*            RETRIEVE LINE ADDRESS AND CURSOR POSITION               */\n/*                                                                    */\n/*--------------------------------------------------------------------*/\nfind_cursor_position:\n  tcb    = PTR(540)               /* TCB (EXEC command)    PSATOLD  */\n  tcb    = PTR(tcb+132)           /* TCB (ISPTASK)         TCBOTC   */\n  fsa    = PTR(tcb+112)           /* first save area       TCBFSA   */\n  r1     = PTR(fsa+24)            /* ISPTASK's R1                   */\n  tld    = PTR(r1)                /* TLD address                    */\n  tls    = PTR(tld+096)           /* screen buffer         TLDTLSP  */\n  csr    = PTR(tld+164)           /* relative cursor pos.  TLDCSR   */\n  scrw   = PTR(tld+192)           /* screen width          TLDCLSWD */\n  IF scrw>0 then\n    csrp = csr//scrw+1            /* cursor position in curr. line  */\n  ELSE\n    csrp = 1                      /* ISPSTRT                        */\n  linead = D2X(tls+csr-csrp+1)    /* address of current line        */\n  line   = STORAGE(linead,scrw)   /* text of current line           */\n  IF debug='DEBUG' THEN SAY 'tcb='D2X(tcb) 'fsa='D2X(fsa) 'r1='D2X(r1),\n          'tld='D2X(tld) STORAGE(D2X(tld),4) 'tls='D2X(tls),\n          'csr='csr 'scrw='scrw 'linead='linead\n  RETURN\nPTR: RETURN C2D(BITAND(STORAGE(D2X(ARG(1)),4),'7FFFFFFF'X))\n/*-------------------------------------------------------- sub-routine*/\n/*                                                                    */\n/*           Scan current line to extract the dsname                  */\n/*                                                                    */\n/*           line -> TEXT OF LINE AT CURSOR POSITION                  */\n/*           csrp -> CURSOR POSITION IN LINE                          */\n/*                                                                    */\n/*--------------------------------------------------------------------*/\nextract_dsname:\n  valid=COPIES(' ',64)||XRANGE('40'x,'FF'x)\n  IF debug='DEBUG' THEN                            /*     debug     */\n    DO                                             /*     debug     */\n      PARSE SOURCE . . cmd ddn dsn . . . . .       /*     debug     */\n      SAY 'cmd='cmd 'ddn='ddn 'dsn='dsn            /*     debug     */\n      DO I=1 BY 16 TO LENGTH(Line)                 /*     debug     */\n        HEX=''; CHAR='*'                           /*     debug     */\n        DO J=I BY 4 UNTIL J>I+16                   /*     debug     */\n          L=LENGTH(Line)-J+1                       /*     debug     */\n          IF L<1 THEN LEAVE                        /*     debug     */\n          S=SUBSTR(Line,J,L)                       /*     debug     */\n          HEX=HEX || ' ' || LEFT(C2X(S),8)         /*     debug     */\n          CHAR=CHAR||LEFT(S,4)                     /*     debug     */\n        END                                        /*     debug     */\n        char=TRANSLATE(char,valid)                 /*     debug     */\n        SAY '  +'RIGHT(I-1,4,'0') ' ' LEFT(HEX,36) ' ' LEFT(CHAR,17)'*'\n      END                                          /*     debug     */\n      SAY 'CURSOR POSITION='csrp                   /*     debug     */\n    END                                            /*     debug     */\n  If SUBSTR(line,csrp,1)=' ' THEN RETURN\n\n  /* If the cursor is positionned under a DSN= or DSNAME= string,   */\n  /* move the cursor pointer to the right of the = sign.            */\n\n  p=SUBSTR(line,MAX(csrp-3,1),MIN(csrp+3,LENGTH(line))+1)\n  IF POS('DSN=',p) > 0 THEN csrp=csrp+4\n\n  p=SUBSTR(line,MAX(csrp-6,1),MIN(csrp+6,LENGTH(line))+1)\n  IF POS('DSNAME=',p) > 0 THEN csrp=csrp+7\n\n  /*  Pad the line at both ends with spaces; convert to upper-case  */\n\n  line=COPIES(' ',10) || TRANSLATE(line,valid) || COPIES(' ',10)\n  csrp=csrp+10\n  UPPER line                              /* convert to upper case  */\n\n  /* If the cursor is positionned under a parenthesis, ignore it    */\n\n  DO WHILE SUBSTR(line,csrp,1)='('; csrp=csrp+1; END\n  DO WHILE SUBSTR(line,csrp,1)=')'; csrp=csrp-1; END\n\n  valid='ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$-{.'\n  ld=0;lp=0\n\n  /*     Check that the cursor is under a valid dsname character.   */\n  /*     If it's under an apostrophe, determine if it's the start   */\n  /*     or the end of the dsname.                                  */\n\n  c=SUBSTR(line,csrp,1)\n  IF VERIFY(c,valid)=1 THEN DO            /* invalid dsname char    */\n    IF c\\=\"'\" THEN RETURN                 /* invalid, not a quote   */\n    IF VERIFY(SUBSTR(line,csrp+1,1),valid)=0 THEN\n      ld=csrp                             /* left delimiter found   */\n    ELSE DO                               /* apost marks start dsn  */\n      p=csrp-1                            /* move csr before apost  */\n      IF SUBSTR(line,p,1)=')' | VERIFY(SUBSTR(line,p,1),valid)=0 THEN\n        csrp=csrp-2                       /* move csr before )      */\n      ELSE                                /* apost surounded by     */\n        RETURN                            /* invalid characters     */\n      END\n    END\n  IF debug='DEBUG' THEN SAY 'ld='ld\n\n  /*                Find start of dsname                            */\n\n  IF ld=0 THEN DO\n    DO csrp=csrp to 1 by -1\n      c=SUBSTR(line,csrp,1)\n      IF VERIFY(c,valid)>0 THEN           /* invalid dsname char    */\n        IF c='(' THEN DO                  /* left paren             */\n          IF lp>0 THEN LEAVE              /* not first left paren   */\n          DO I=1 to 9                     /* search for a period    */\n            IF SUBSTR(line,csrp+i,1) ='.' THEN LEAVE\n          END\n          IF i>8 THEN                     /* no period found after  */\n            lp=csrp                       /* start of member        */\n          ELSE\n            LEAVE                         /* start of member        */\n          END\n        ELSE                              /* invalid char, not \"(\"  */\n          LEAVE\n      END\n    ld=csrp                               /* left delimiter         */\n    IF lp=ld+1 THEN DO\n      lp=0                                /* no member              */\n      ld=ld+1\n      END\n    END\n  IF debug='DEBUG' THEN SAY 'ld='ld 'lp='lp 'csrp='csrp\n\n  /*              Find start of member name                         */\n\n  IF lp=0 THEN DO                         /* \"(\" not seen yet       */\n    csrp=ld+1                             /* 1st byte of dsname     */\n    p=VERIFY(line,valid,,csrp)            /* Find delimiter         */\n    IF debug='DEBUG' THEN SAY 'csrp='csrp 'p='p SUBSTR(line,p,1)\n    IF SUBSTR(line,p,1)='(' THEN DO\n      lp=p                                /* \"(\" found              */\n      csrp=p+1                            /* 1st byte of mbr name   */\n      END\n    END\n  ELSE\n    csrp=lp+1                             /* 1st byte of member     */\n  IF debug='DEBUG' THEN SAY 'ld='ld 'lp='lp 'csrp='csrp\n\n  /*                 Find end of dsname                             */\n\n  rd=VERIFY(line,valid,,csrp)             /* Find delimiter aft dsn */\n  IF debug='DEBUG' THEN SAY 'csrp='csrp 'rd='rd SUBSTR(line,rd,1)\n  IF lp>0 & SUBSTR(line,rd,1)=')' THEN rd=rd+1\n\n  IF SUBSTR(line,ld,1)=\"'\" & SUBSTR(line,rd,1)\\=\"'\" THEN RETURN\n\n  Dsname = SUBSTR(Line,ld+1,rd-ld-1)\n  IF LEFT(Dsname,9) = 'CLUSTER--',        /* IDCAMS LISTCAT         */\n   | LEFT(Dsname,9) = 'DATA-----',        /* IDCAMS LISTCAT         */\n   | LEFT(Dsname,9) = 'INDEX----',        /* IDCAMS LISTCAT         */\n   | LEFT(Dsname,9) = 'NONVSAM--' THEN    /* IDCAMS LISTCAT         */\n    dsname=RIGHT(dsname,LENGTH(dsname)-9) /* IDCAMS LISTCAT         */\n  IF debug='DEBUG' THEN SAY 'Dsname=\"'Dsname'\"'\n  IF LENGTH(Dsname) < 5 | LENGTH(Dsname) > 44 THEN Dsname=''\n  RETURN\n/*-------------------------------------------------------- sub-routine*/\n/*                                                                    */\n/*     Invoke the Data Set List Utility (ISPF 2.3 through 4.1)        */\n/*                                                                    */\n/*--------------------------------------------------------------------*/\nInvoke_ISRUDL:\n  IF Dsname\\='' THEN DO\n    i=INDEX(Dsname,'(')                   /* check for member name    */\n    IF i>0 THEN                           /* If abcd.edfgh(ijkl)      */\n      Zdldsnlv=LEFT(Dsname,i-1)           /* remove (ijkl)            */\n    ELSE\n      Zdldsnlv=Dsname                     /* pass data set name       */\n    zdlpvl=''                             /* blank out volume serial  */\n    \"VPUT (Zdldsnlv Zdlpvl) PROFILE\"      /* update ISRUDLP variables */\n    END\n  \"SELECT PGM(ISRUDL) PARM(ISRUDLP)\"\n  RETURN\n/*-------------------------------------------------------- sub-routine*/\n/*                                                                    */\n/*     Invoke the Work Place Utility (ISPF 4.2 and above)             */\n/*                                                                    */\n/*--------------------------------------------------------------------*/\nInvoke_Work_Place:\n  IF Dsname\\='' THEN DO\n    Zwrkdsn=\"'\"Dsname\"'\"                  /* enclose dsname in quotes */\n    Zwrkvol=''                            /* blank out volume serial  */\n    Zreftype='D'                          /* Data set view            */\n    \"VPUT (Zwrkdsn Zwrkvol Zreftype) PROFILE\" /* update ISRWORK vars */\n    END\n  \"SELECT PGM(ISRUDA) PARM(ISRWORK) SCRNAME(WORK)\"\n  RETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSNLIST": {"ttr": 6410, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x000\\x00\\x88\\x06\\x9f\\x00\\x95\\x10_\\tR\\x00\\xea\\x00\\xf6\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf0\\xf0@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1988-03-09T00:00:00", "modifydate": "1995-04-15T09:52:30", "lines": 234, "newlines": 246, "modlines": 0, "user": "CBT400"}, "text": "//GILBERTD JOB (ACCT#),DSNLIST,\n// NOTIFY=&SYSUID,\n//*RESTART=GO,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n*    DSNLIST   TSO COMMAND                                            *\n*                                                                     *\n*              RETURNS IN &VAR THE DSNAMES ALLOCATED TO &DDN          *\n*                                                                     *\n*              EXAMPLE:                                               *\n*                                                                     *\n*                ALLOC DD(SYSPROC) SHR -                              *\n*                      DS('IPO1.CMDPROC' 'GILBERT.CLIST')             *\n*                DSNLIST DDNAME(SYSPROC) SETVAR(VAR2)                 *\n*                                                                     *\n*                IS EQUIVALENT TO:                                    *\n*                                                                     *\n*                SET VAR2 = 'IPO1.CMDPROC' 'GILBERT.CLIST'            *\n*                                                                     *\n***********************************************************************\nDSNLIST  CSECT\nDSNLIST  RMODE ANY\n         SAVE  (14,12),,'GSF UTILITIES - DSNLIST'\n         LR    R12,R15                 BASE REG\n         USING DSNLIST,R12\n         LR    R11,R1                  CPPL ADDRESS\n         USING CPPL,R11\n         GETMAIN R,LV=DYNL             GET DYNAMIC AREA (LOC=BELOW)\n         ST    R13,4(,R1)\n         LR    R13,R1\n         USING DYN,R13\n         XC    DYN+72(256),DYN+72      CLEAR DYNAMIC STORAGE AREA\n***********************************************************************\n*        BUILD PARSE PARM LIST, CALL IKJPARS                          *\n***********************************************************************\nPARSE000 LA    R1,DYNPPL               POINT TO PPL\n         USING PPL,R1                  SET UP ADDRESSABILITY TO PPL\n         MVC   PPLCBUF,CPPLCBUF        MOVE BUFFER ADDRESS TO PPL\n         MVC   PPLUPT,CPPLUPT          MOVE UPT ADDRESS TO PPL\n         MVC   PPLECT,CPPLECT          MOVE ECT ADDRESS TO PPL\n         LA    R0,DYNECB               EVENT CONTROL BLOCK\n         ST    R0,PPLECB               STORE ECB IN PPL\n         MVC   PPLPCL,=A(PCLCSECT)     STORE PCL ADDR INTO PPL\n         LA    R0,DYNANSWR             ANSWER AREA\n         ST    R0,PPLANS               STORE ANSWER ADDRESS IN PPL\n         LINK  EP=IKJPARS              CALL THE PARSE ROUTINE\n         LTR   R15,R15                 CHECK FOR ZERO PARSE RETURN\n         BNZ   RETURN                  GO AWAY UPSET\n         DROP  R1                      WAS PPL\n***********************************************************************\n*        PROCESS PARSED PARAMETERS                                    *\n***********************************************************************\n         L     R8,DYNANSWR             LOAD PDL ADDRESS\n         USING IKJPARMD,R8             SET UP ADDRESSABILITY TO PDL\nPARSE100 L     R14,DDNPCE2             GET ADDRESS OF DDNAME\n         LH    R15,DDNPCE2+4           ACTUAL LENGTH OF DDNAME\n         ICM   R15,B'1000',=C' '       PADDING\n         LA    R0,DCBDDNAM-IHADCB+DYNDCB1 DDNAME\n         LA    R1,L'DCBDDNAM           LENGTH OF DDNAME\n         MVCL  R0,R14                  MOVE DDNAME, PAD WITH BLANKS\n*\nPARSE300 L     R0,VARPCE2              ADDRESS OF NAME\n         LH    R1,VARPCE2+4            LENGTH OF NAME\n         STM   R0,R1,VARVDESC          VARIABLE DESCRIPTOR\n*\nPARSE999 IKJRLSA DYNANSWR              RELEASE PDL\n         DROP  R8                      WAS IKJPARMD\n*---------------------------------------------------------------------\n*        BUILD DCB, ARL, GET DSNAMES\n*---------------------------------------------------------------------\n         LA    R1,DYNDCB1              STORE DCB ADDRESS\n         USING IHADCB,R1\n         MVI   DCBDSORG,X'02'          DSORG=PO\n         MVI   DCBOFLGS,X'02'          .\n         MVI   DCBMACR1,X'D0'          EXCP, FOUND. EXT, COMMON INTFCE\n         MVI   DCBMACR2,X'08'          5-WORD DEVICE INTERFACE\n         ST    R1,OPENLIST             STORE DCB ADDRESS\n         MVI   OPENLIST,X'80'          OPEN INPUT IS THE DEFAULT\n         LA    R0,EXLST1               DCB EXIT LIST\n         ST    R0,DCBEXLST             STORE INTO DCB\n         LA    R0,ARL                  ALLOC RETRIEVAL LIST\n         ST    R0,EXLST1               STORE INTO EXIT LIST\n         MVI   EXLST1,X'93'            ARL ADDRESS\n         DROP  R1                      WAS IHADCB\n         MVC   ARLLEN,=Y(ARLEND-ARLLEN)  LENGTH OF ARL\n         MVC   ARLIDENT,=C'AR'         BLOCK ID\n         RDJFCB MF=(E,OPENLIST)        BUILD AN ARL\n         LTR   R15,R15\n         BNZ   RETURN                  RDJFCB ERROR\n*---------------------------------------------------------------------\n*        BUILD THE VARIABLE VALUE FROM JFCB'S\n*---------------------------------------------------------------------\n         L     R2,ARLAREA              GET ADDR OF AREA\n         LH    R3,ARLRTRVD             DATA SET COUNT\n         LA    R4,WORK5                WORK AREA\n*LOOP\nLOOPJFCB MVI   0(R4),C''''             LEADING QUOTE\n         MVC   1(44,R4),4(R2)          MOVE DSNAME\n         MVI   1+44(R4),C' '           DELIMITER\n         LA    R4,1(,R4)               BUMP UP TO NEXT BYTE\n         CLI   0(R4),C' '              CHECK FOR A SPACE\n         BNE   *-8                     LOOP UNTIL END OF DSN FOUND\n         MVI   0(R4),C''''             TRAILING QUOTE\n         MVI   1(R4),C' '              SEPARATOR\n         LA    R4,2(,R4)               BUMP UP PAST SPACE\n         AH    R2,0(,R2)               ADD ENTRY LENGTH (180)\n         BCT   R3,LOOPJFCB             PROCESS NEXT JFCB\n*ENDLOOP\n         LA    R0,WORK5                WORK AREA\n         ST    R0,VALUEPTR             POINTER TO VARIABLE VALUE\n         SR    R4,R0                   COMPUTE LENGTH\n         ST    R4,VALUELEN             LENGTH OF VALUE FIELD\n         L     R1,ARLAREA              GET ADDR OF AREA\n         L     R0,ARLPOOL              GET SP, LENGTH\n         FREEMAIN R,LV=(0),A=(1)       FREE AREA\n*---------------------------------------------------------------------*\n*        UPDATE CLIST VARIABLE                                        *\n*---------------------------------------------------------------------*\n         LA    R14,=A(TSVEUPDT)        CT441 FUNCTION\n         LA    R15,VARVDESC+0          POINTER TO VARIABLE NAME\n         LA    R0,VARVDESC+4           LENGTH OF VARIABLE NAME\n         LA    R1,VALUEPTR             POINTER TO VARIABLE VALUE\n         LA    R2,VALUELEN             LENGTH OF VARIABLE VALUE\n         LA    R3,TOKEN                NULL TOKEN\n         STM   R14,R3,SIXWORDS         STORE PARAMETER LIST\n         OI    SIXWORDS+20,X'80'       MARK END OF LIST\n         LA    R1,SIXWORDS             PARM LIST ADDRESS\n         LINK  EP=IKJCT441             CALL THE VARIABLE ACCESS RTNE\n*---------------------------------------------------------------------*\n*        RETURN TO CALLER                                             *\n*---------------------------------------------------------------------*\nRETURN   LR    R1,R13                  DYNAMIC STORAGE AREA ADDRESS\n         L     R13,4(,R13)\n         ST    R15,16(,R13)            PASS RETURN CODE\n**       FREEMAIN R,LV=DYNL,A=(1)      FREE DYNAMIC AREA\n         RETURN (14,12)                GOBACK\n***********************************************************************\n*        DEFINE INPUT PARAMETERS FOR IKJPARS                          *\n***********************************************************************\nPCLCSECT IKJPARM\nPCLCSECT RMODE ANY\nDDNVPCE  IKJKEYWD\n         IKJNAME 'DDNAME',SUBFLD=DDNSUBF,ALIAS=('FILE')\nVARVPCE  IKJKEYWD\n         IKJNAME 'SETVAR',SUBFLD=VARSUBF\nDDNSUBF  IKJSUBF\nDDNPCE2  IKJIDENT 'DDNAME',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM,       X\n               PROMPT='DDNAME'\nVARSUBF  IKJSUBF\nVARPCE2  IKJIDENT 'VARIABLE NAME',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM,X\n               PROMPT='VARIABLE NAME'\n         IKJENDP\n***********************************************************************\n*        DYNAMIC STORAGE AREA                                         *\n***********************************************************************\nDYN      DSECT\n         DS    18F                     SAVE AREA\nDYNANSWR DS    F                       ANSWER AREA FOR PARSE\nDYNUWA   DS    4F                      USER WORK AREA FOR PARSE\nDYNPPL   DS    8F                      PPL FOR USE WITH PARSE\nDYNECB   DS    F                       PPL FOR USE WITH PARSE\nVARVDESC DS    A,F                     ADDR/LEN OF VARIABLE NAME\nVALUEPTR DS    F                       PTR TO DSNAME\nVARPTR   DS    F                       PTR TO .G0001V00\nVALUELEN DS    F                       LENGTH OF VARIABLE VALUE\nTOKEN    DS    F                       TOKEN FOR IKJCT441\nSIXWORDS DS    6F                      PARMLIST\nOPENLIST RDJFCB DYNDCB1,MF=L\nDYNDCB1  DCB   DSORG=PS,MACRF=E,EXLST=EXLST1,DDNAME=DUMMY\nEXLST1   DC    A(ARL+X'93000000')      DCB EXIT LIST\n         IHAARL DSECT=NO               ALLOC RETRIEVAL LIST\nWORK5    DS    255CL46                 WORK AREA\nDYNL     EQU   *-DYN                   LENGTH OF WORK AREA\n*\n         IKJPPL                        PARSE PARAMETER LIST\n         IKJCPPL                       COMMAND PROCESSOR PARM LIST\nTSVEUPDT EQU   2                       UPDATE VARIABLE\n         YREGS                         SYS1.MACLIB\n         DCBD  DSORG=XE                DCB DSECT\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//*       LINK-EDIT THE DSNLIST PROGRAM\n//*\n//LKED    EXEC PGM=HEWL,PARM='MAP,RENT'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,DELETE)\n//SYSLMOD  DD DSN=CBTTAPE.FILE183.LOAD(DSNLIST),DISP=SHR\n//*\n//**********************************************************************\n//*                                                                    *\n//*   Execute an in-line CLIST which runs \"DSNLIST\".                   *\n//*                                                                    *\n//*   The following DSNLIST command is issued:                         *\n//*                                                                    *\n//*     DSNLIST DDNAME(SYSPROC) SETVAR(VAR2)                           *\n//*                                                                    *\n//*   It produces the following output:                                *\n//*                                                                    *\n//*     DSNLIST LASTCC=0 VAR2=('CBTTAPE.FILE183.PDS' 'SYS1.MACLIB')    *\n//*                                                                    *\n//*   The following LISTDSI command is also issued:                    *\n//*                                                                    *\n//*     LISTDSI SYSPROC FILE PREALLOC                                  *\n//*                                                                    *\n//*   It produces the following output:                                *\n//*                                                                    *\n//*     LISTDSI LASTCC=0 DSN=(CBTTAPE.FILE183.PDS) REASON=0000         *\n//*                                                                    *\n//**********************************************************************\n//*\n//GO      EXEC PGM=IKJEFT01,PARM='%EXECUTE CLIST'\n//STEPLIB  DD DSN=CBTTAPE.FILE183.LOAD,DISP=SHR                 DSNLIST\n//SYSPROC  DD DSN=CBTTAPE.FILE183.PDS,DISP=SHR                 %EXECUTE\n//         DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSTSPRT DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//SYSTSIN  DD *\n /* CONTROL LIST CONLIST\nDSNLIST DDNAME(SYSPROC) SETVAR(VAR2)\nWRITE DSNLIST LASTCC=&LASTCC VAR2=(&VAR2)\nLISTDSI SYSPROC FILE PREALLOC             /* RC=16 IF VIO */\nSET RC=&LASTCC\nWRITE LISTDSI LASTCC=&RC DSN=(&SYSDSNAME) REASON=&SYSREASON\nIF &RC > 0 THEN DO\n  WRITE &SYSMSGLVL1\n  WRITE &SYSMSGLVL2\n  END\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EASYSORT": {"ttr": 6660, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x04\\x00\\x00\\x00\\x81\\x10\\x1f\\x00\\x941\\x7f\\x11\\x19\\x00\\xcb\\x00\\xb7\\x00\\x1e\\xc3\\xc2\\xe3\\xf4\\xf0\\xf0@@@@'", "ispf": {"version": "02.04", "flags": 0, "createdate": "1981-04-11T00:00:00", "modifydate": "1994-11-13T11:19:00", "lines": 203, "newlines": 183, "modlines": 30, "user": "CBT400"}, "text": "//GILBERTE JOB (ACCT#),EASYSORT,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//ASMH EXEC PGM=IEV90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n         MACRO\n&REF     EASYSORT &FUNC,&WORKA,&EODAD=,&SET=R1,&ERRET=,                X\n               &TYPE=F,&LENGTH=80,&FIELDS=(1,80,CH,A),&OPTION=\n.**********************************************************************\n.*                                                                    *\n.*   USAGE:                                                           *\n.*                                                                    *\n.*       EASYSORT OPEN,TYPE=F,LENGTH=64,FIELDS=(1,22,CH,A),         X *\n.*              OPTION='EQUALS,RESINV=500K'                           *\n.*       EASYSORT PUT,(1)                                             *\n.*       EASYSORT GET,SET=R3,EODAD=ENDSORT                            *\n.*       EASYSORT CLOSE                                               *\n.*                                                                    *\n.*       MULTIPLE SORTS IN SAME PROGRAM OK (ONE AT A TIME ONLY)       *\n.*                                                                    *\n.**********************************************************************\n         LCLA  &L\n         LCLC  &LABEL,&STR\n&LABEL   SETC  'IHB&SYSNDX'\n         AIF   ('&FUNC' EQ 'OPEN').OPEN\n         AIF   ('&FUNC' EQ 'PUT').PUT\n         AIF   ('&FUNC' EQ 'GET').GET\n         AIF   ('&FUNC' EQ 'CLOSE').CLOSE\n         MNOTE 8,'INVALID FUNCTION REQUESTED &FUNC'\n&REF     DS    0H\n         MEXIT\n.OPEN    ANOP  ,  ====== OPEN ========\n&REF     BAL   R1,&LABEL.L             BRANCH AROUND CONTROL STMTS\n&STR     SETC  ' SORT FIELDS=&FIELDS RECORD TYPE=&TYPE,LENGTH=&LENGTH '\n&L       SETA  K'&STR\n         AIF   (T'&OPTION EQ 'O').AL2\n&STR     SETC  '&STR'.'OPTION '.'&OPTION'(2,K'&OPTION-2)' '\n&L       SETA  K'&STR\n.AL2     DC    Y(&L),C'&STR',0H'0'\n.*\n&LABEL.L L     R15,=A(EZSORT00)\n         BALR  R14,R15                 OPEN SORT\n.**********************************************************************\n         AIF   (D'EZSORT00).NOXXX      JUMP IF NOT FIRST OPEN\nEZSORT00 CSECT\n         STM   R14,R12,12(R13)         SAVE REGISTERS\n         PUSH  USING\n         BALR  R11,0                   LOCAL BASE\n         USING *,R11\n         LA    R14,0(,R1)              CLEAN UP HI-ORDER BIT/BYTE\n         LA    R15,SORT$E15            E15 EXIT\n         LA    R0,SORT$E35             E35 EXIT\n         LR    R1,R13                  PARM FOR EXIT ROUTINE\n         SLR   R2,R2\n         BCTR  R2,0                    R2='FFFFFFFF' (END OF LIST)\n         STM   R14,R2,SORT$PRM         31-BIT PARM LIST\n         LA    R1,SORT$PRM             31-BIT PARM LIST\n.*\n         ST    R13,SORT$SAV+4          BACKWARD CHAIN\n         LA    R13,SORT$SAV            SORT SAVE AREA\n         MVI   0(R13),C'0'             PHASE 0 ENTERED\n         LINK  EP=SORT                 INVOKE SORT UTILITY\n         L     R13,4(,R13)             RELOAD PROGRAM'S SAVE AREA ADDR\n         LM    R14,R12,12(R13)         RESTORE REGISTERS (GET)\n         SLR   R1,R1                   INVALIDATE RECORD POINTER\n         AIF   (T'&ERRET EQ 'O').ERRET\n         LTR   R15,R15                 SORT FAILED?\n         BNZ   &ERRET                  YES, GO TO ERROR ROUTINE\n.ERRET   ANOP\n         BR    R14                     GOBACK TO PROGRAM (GET)\n         DROP  ,                       DROP R11\nSORT$E15 STM   R14,R12,12(R13)         SAVE REGISTERS FROM SORT\n         LA    R0,SORT$E15-EZSORT00\n         SR    R15,R0                  R15=A(EZSORT00)\n         USING EZSORT00,R15\n.*       LR    R14,R13\n         L     R13,4(,R1)              =A(DYN)\n.*       ST    R14,SORT$SAV+8\n         MVI   SORT$SAV,C'1'           PHASE 1 STARTED\n         LM    R14,R12,12(R13)         RESTORE PROGRAM'S REGISTERS\n         BR    R14                     GOBACK TO PROGRAM (PUT)\nSORT$PUT STM   R14,R12,12(R13)         SAVE PROGRAM'S REGISTERS\n         L     R13,SORT$SAV+8          SAVE AREA FOR E15\n         LM    R14,R0,12(R13)          RESTORE SORT R14-R0\n         LA    R15,0012                INSERT RECORD REQUEST\n         LM    R2,R12,28(R13)          RESTORE SORT'S R2-R12\n         BR    R14                     GOBACK TO SORT (E15)\nSORT$E35 STM   R14,R12,12(R13)         SAVE REGISTERS FROM SORT\n         LA    R0,SORT$E35-EZSORT00\n         SR    R15,R0                  R15=A(EZSORT00)\n.*       LR    R14,R13\n         L     R13,8(,R1)              =A(DYN)\n.*       ST    R14,SORT$SAV+8\n         ICM   R1,B'1111',0(R1)        ADDR OF SORTED RECORD\n         BZ    SORT$K35                NO MORE RECORDS, TERMINATE E35\n         CLI   SORT$SAV,C'9'           CHECK PHASE 3 ENTERED\n         BE    SORT$K35                JUMP IF SORT CLOSED IN E15\n         LM    R14,R0,12(R13)          PROGRAM'S R14-R0\n         LM    R2,R12,28(R13)          RESTORE PGM'S R2-R12, PASS R1\n         BR    R14                     GOBACK TO PGM (GET)\nSORT$GET STM   R14,R12,12(R13)         SAVE PROGRAM'S REGISTERS\n         CLI   SORT$SAV,C'3'           CHECK PHASE 3 ENTERED\n         MVI   SORT$SAV,C'3'           SHOW PHASE 3 ENTERED\n         BNE   SORT$RC8                JUMP IF 1ST GET (STILL IN E15)\n         L     R13,SORT$SAV+8          SAVE AREA FOR E15/E35\n         LM    R14,R12,12(R13)         RESTORE REGISTERS\n         LA    R15,0004                DELETE RECORD\n         BR    R14                     GOBACK TO SORT (E35)\nSORT$CLS CLI   SORT$SAV,C'9'           CLOSE ISSUED ALREADY?\n         BER   R14                     YES, DO NOTHING\n         STM   R14,R12,12(R13)         SAVE PROGRAM'S REGISTERS\nSORT$K35 MVI   SORT$SAV,C'9'           SHOW CLOSE ISSUED\nSORT$RC8 L     R13,SORT$SAV+8          SAVE AREA FOR E15/E35\n         LM    R14,R12,12(R13)         RESTORE SORT REGISTERS\n         LA    R15,0008                END OF E15/E35 EXIT\n         BR    R14                     GOBACK TO SORT\nSORT$SAV DS    18F                     SAVE AREA FOR SORT\nSORT$PRM DS    5A                      31-BIT PARM LIST\n&SYSECT  CSECT                         PROGRAM CSECT\n         POP   USING\n.NOXXX   MEXIT\n.**********************************************************************\n.*       PUT\n.**********************************************************************\n.PUT     AIF   ('&WORKA'(1,1) EQ '(').PUTREG\n&REF     LA    R1,&WORKA               GET RECORD ADDRESS\n         AGO   .PUTCOMM\n.PUTREG  AIF   ('&WORKA' EQ '(1)' OR '&WORKA' EQ '(R1)').PUTREG1\n&REF     LR    R1,&WORKA(1)            GET RECORD ADDRESS\n         AGO   .PUTCOMM\n.PUTREG1 ANOP\n&REF     L     R15,=A(EZSORT00)        POINT TO SORT CSECT\n         AGO   .PUTBALR\n.PUTCOMM L     R15,=A(EZSORT00)        POINT TO SORT CSECT\n.PUTBALR BAL   R14,SORT$PUT-EZSORT00(,R15) CALL PUT ROUTINE\n         MEXIT\n.**********************************************************************\n.*       GET\n.**********************************************************************\n.GET     ANOP\n&REF     L     R15,=A(EZSORT00)        POINT TO SORT CSECT\n         BAL   R14,SORT$GET-EZSORT00(,R15) CALL GET ROUTINE\n         LTR   &SET,R1                 CHECK RECORD ADDRESS\n         AIF   (T'&EODAD EQ 'O').GET8\n         BZ    &EODAD                  END OF DATA\n         MEXIT\n.GET8    MNOTE 8,'EODAD PARAMETER MISSING'\n&REF     DS    0H\n         MEXIT\n.**********************************************************************\n.*       CLOSE\n.**********************************************************************\n.CLOSE   ANOP\n&REF     L     R15,=A(EZSORT00)        POINT TO SORT CSECT\n         BAL   R14,SORT$CLS-EZSORT00(,R15) CALL CLOSE ROUTINE\n.MEND    MEND\n***********************************************************************\n*\n*        TEST PROGRAM\n*\n***********************************************************************\n         EJECT\nEASYSORT CSECT\n         SAVE  (14,12),,TEST-EASYSORT-&SYSDATE\n         BALR  R12,0                   BASE REGISTER\n         USING *,R12\n         ST    R13,SAVEAREA+4          CALLER'S SAVE AREA\n         LA    R13,SAVEAREA            MY OWN SAVE AREA\n***********************************************************************\n         OPEN  SYSIN\n         EASYSORT OPEN,TYPE=F,LENGTH=32,FIELDS=(1,12,CH,A)\nGET1     GET   SYSIN                   GET A SYSIN RECORD\n         EASYSORT PUT,(R1)             PASS RECORD TO THE SORT (E15)\n         B     GET1                    GET NEXT RECORD\nEOD1     CLOSE SYSIN                   CLOSE INPUT FILE\n         FREEPOOL SYSIN                FREE BUFFERS\n***********************************************************************\n         OPEN  (SYSPRINT,EXTEND)\nPUT2     EASYSORT GET,SET=R0,EODAD=EOD2 GET SORTED RECORD (E35)\n         PUT   SYSPRINT,(0)            PRINT RECORD\n         B     PUT2                    LOOP UNTIL LAST RECORD RETURNED\nEOD2     CLOSE SYSPRINT                CLOSE OUTPUT FILE\n         FREEPOOL SYSPRINT             FREE BUFFERS\n         L     R13,4(,R13)             CALLER'S SAVE AREA\n         RETURN (14,12),RC=00\n***********************************************************************\nSYSIN    DCB   DSORG=PS,MACRF=GL,DDNAME=SYSIN,EODAD=EOD1\nSYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,RECFM=FB,LRECL=32\nSAVEAREA DS    9D\n         YREGS                         REGISTER EQUATES\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//GO      EXEC PGM=LOADER,PARM=NOPRINT\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,DELETE)\n//SYSOUT   DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n555555555\n444444444444\n333333333333\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EXECPGM": {"ttr": 6664, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x12\\x05\\x000\\x00\\x852o\\x00\\x96\\x06O\\x17\\x10\\x01o\\x01\\xac\\x00\\x80\\xc3\\xc2\\xe3\\xf4\\xf7\\xf6@@@@'", "ispf": {"version": "18.05", "flags": 0, "createdate": "1985-11-22T00:00:00", "modifydate": "1996-03-04T17:10:30", "lines": 367, "newlines": 428, "modlines": 128, "user": "CBT476"}, "text": "//GILBERTE JOB (ACCT#),EXECPGM,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//*\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n*    Program:  EXECPGM                                                *\n*                                                                     *\n*    Function: TSO Command Processor to invoke a compiler             *\n*              with an alternate DDname list                          *\n*                                                                     *\n*    Author:   Gilbert Saint-Flour <carlos@gsf-soft.com>              *\n*              http://gsf-soft.com/Freeware/                          *\n*                                                                     *\n*    Example:                                                         *\n*                                                                     *\n*      EXECPGM ASMA90          +                                      *\n*        PARM('NOOBJECT,NODECK,NOXREF,NORLD,ALIGN')           +       *\n*        STEPLIB(LINKLIST)         +                                  *\n*        SYSIN(TEMPWK2)            +                                  *\n*        SYSUT1(TEMPWK1)           +                                  *\n*        SYSLIB(#ASMLIB)           +                                  *\n*        SYSPRINT(ASMPRINT)                                           *\n*                                                                     *\n*1804 INVOKE THE DEBUGGING ROUTINE AS AN ESTAI                        *\n*1805 BUMP OWN USE COUNT IF DEBUGGING ROUTINE IS INVOKED              *\n*     TO PREVENT S0C1 WHEN PGM INVOKED VIA XCTL ABENDS                *\n***********************************************************************\n*XA_ONLY SPLEVEL SET=1                 MVS/370 COMPATIBILITY\nEXECPGM  CSECT\nEXECPGM  RMODE ANY\n         SAVE  (14,12),,'GSF UTILITIES - EXECPGM 18.05'\n         LR    R12,R15\n         USING EXECPGM,R12\n         GETMAIN R,LV=DYNAML           GET DYNAMIC STORAGE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LA    R14,72(,R1)             CLEAR WORKING STORAGE\n         LA    R15,DYNAML-72           CLEAR WORKING STORAGE\n         SR    R1,R1                   CLEAR WORKING STORAGE\n         MVCL  R14,R0                  CLEAR WORKING STORAGE\n         LM    R13,R1,8(R13)           SET R13, RELOAD R14-R1\n         USING DYNAM,R13\n         LR    R9,R1                   POINT AT CPPL.\n         USING CPPL,R9\n*\n*        SET UP RECOVERY ENVIRONMENT (OPTIONAL)\n*\n         WXTRN SYSDEBUG                OPTIONAL DEBUGGING ROUTINE\n         ICM   R15,B'1111',=A(SYSDEBUG)  DEBUGGING ROUTINE\n         BZ    PARSE000                NOT PRESENT, EXIT\n         BALR  R14,R15                 SET UP RECOVERY ENVIRONMENT\n         STM   R15,R0,ESTAIPRM         SAVE PARAMETERS FOR ATTACH\n         L     R1,540(,0)              PSATOLD (MY TCB)\n         L     R1,0(,R1)               TCBRBP (MY PRB)\n         L     R1,12(,R1)              RBCDE (MY CDE)\n         LOAD  EPLOC=8(,R1)            BUMP MY OWN USE COUNT\n***********************************************************************\n*                                                                     *\n*        BUILD PARSE PARM LIST, CALL IKJPARS                          *\n*                                                                     *\n***********************************************************************\nPARSE000 LA    R1,DYNPPL               POINT TO PPL\n         USING PPL,R1                  SET UP ADDRESSABILITY TO PPL\n         L     R0,CPPLUPT              USER PROFILE TABLE\n         ST    R0,PPLUPT               STORE UPT ADDRESS IN PPL\n         L     R0,CPPLECT              ENVIRONMENT CONTROL TABLE\n         ST    R0,PPLECT               STORE ECT IN PPL\n         LA    R0,DYNECB               EVENT CONTROL BLOCK\n         ST    R0,PPLECB               STORE ECB IN PPL\n         MVC   PPLPCL,=A(PCLCSECT)     STORE PCL ADDR INTO PPL\n         LA    R0,DYNANSWR             ANSWER AREA\n         ST    R0,PPLANS               STORE ANSWER ADDRESS IN PPL\n         L     R0,CPPLCBUF             COMMAND BUFFER\n         ST    R0,PPLCBUF              STORE BUFFER ADDRESS IN PPL\n         LA    R14,=C'IKJPARS '        NAME OF PARSE ROUTINE\n         L     R15,0016(0)             CVTPTR\n         L     R15,0008(,R15)          CVTLINK\n         STM   R14,R15,DWD             BUILD LINK PARMLIST\n         LINK  SF=(E,DWD)              CALL THE PARSE ROUTINE\n         LTR   R15,R15                 CHECK FOR ZERO PARSE RETURN\n         BNZ   ABEND33                 GO AWAY UPSET\n         DROP  R1                      WAS PPL\n***********************************************************************\n*                                                                     *\n*        PROCESS PARSED PARAMETERS                                    *\n*                                                                     *\n***********************************************************************\n         L     R8,DYNANSWR             LOAD PDL ADDRESS\n         USING IKJPARMD,R8             SET UP ADDRESSABILITY TO PDL\n         LA    R14,PARM256             256-BYTE AREA\n         LA    R2,PARMPCE2             FIRST SUB-LIST ITEM\n         TM    6(R2),X'80'             DO WE HAVE A PARM?\n         BZ    ENDPARM                 NO, JUMP\n*LOOP\nMAKEPARM LH    R15,4(,R2)              LENGTH OF SUB_ITEM\n         L     R0,0(,R2)               GET ADDRESS\n         LR    R1,R15                  PASS LENGTH\n         ICM   R1,B'1000',=CL8' '      PADDING\n         MVCL  R14,R0                  MOVE DATA SET NAME\n         MVI   0(R14),C','             ADD COMMA\n         LA    R14,1(,R14)             INCREMENT POINTER\n         ICM   R2,B'1111',8(R2)        IS THIS THE LAST OPERAND?\n         BP    MAKEPARM                NO, LOOP\n*ENDLOOP\n         BCTR  R14,0                   LAST COMMA\nENDPARM  LA    R0,PARM256              256-BYTE AREA\n         SR    R14,R0                  USED LENGTH\n         STH   R14,PARM256L            USED LENGTH\n*\n         MACRO                                                    MACRO\n        @MVCL  &TO,&FROM,&DD                                      MACRO\n         TM    &FROM+6,X'80'           CHECK SUBPARAMETER         MACRO\n         BZ    $&SYSNDX+2              JUMP IF NOT SPECIFIED      MACRO\n         AIF   (T'&DD EQ 'O').MVC                                 MACRO\n         MVI   PARMDDNL+1,8*&DD        LENGTH OF DDN LIST         MACRO\n.MVC     LA    R14,&TO                 44-BYTE AREA               MACRO\n         LA    R15,L'&TO               GET LENGTH                 MACRO\n         ICM   R0,B'1111',&FROM        GET ADDRESS                MACRO\n         LH    R1,&FROM+4              ACTUAL LENGTH OF &MBR      MACRO\n         ICM   R1,B'1000',=CL8' '      PADDING                    MACRO\n$&SYSNDX MVCL  R14,R0                  MOVE DATA SET NAME         MACRO\n         MEND                                                     MACRO\n         MVC   DCBDDNAM,=CL8' '        BLANK OUT DDNAME\n*\n        @MVCL  PGMNM,PGMPCE            PROGRAM NAME\n        @MVCL  DCBDDNAM,LOADPCE2       STEPLIB DDNAME\n        @MVCL  PARMDD1,LINPCE2,1       SYSLIN\n        @MVCL  PARMDD2,MBRPCE2,2       MEMBER NAME\n        @MVCL  PARMDD3,MODPCE2,3       SYSLMOD\n        @MVCL  PARMDD4,LIBPCE2,4       SYSLIB\n        @MVCL  PARMDD5,INPCE2,5        SYSIN\n        @MVCL  PARMDD6,PRTPCE2,6       SYSPRINT\n        @MVCL  PARMDD7,PUNPCE2,7       SYSPUNCH\n        @MVCL  PARMDD8,UT1PCE2,8       SYSUT1\n        @MVCL  PARMDD9,UT2PCE2,9       SYSUT2\n        @MVCL  PARMDD10,UT3PCE2,10     SYSUT3\n        @MVCL  PARMDD11,UT4PCE2,11     SYSUT4\n        @MVCL  PARMDD12,TRMPCE2,12     SYSTERM\nPARSE999 IKJRLSA DYNANSWR              RELEASE PDL\n*\nATTACH   LA    R14,PARM256L            JCLPARM\n         LA    R15,PARMDDNL            DDN LIST\n         STM   R14,R15,PARMLIST        BUILD PARM\n         OI    PARMLIST+4,X'80'        END OF LIST (WITH DDN LIST)\n*\n         CLI   PARMDDNL+1,00           ANY ALTERNATE DDN?\n         BNE   ATTACH3                 YES, JUMP\n         OI    PARMLIST+0,X'80'        END OF LIST (NO DDN LIST)\n*\nATTACH3  CLI   DCBDDNAM,C' '           STEPLIB SPECIFIED?\n         BNH   XCTL1                   NO, SKIP OPEN\n*\n         L     R2,0016                 CVTPTR\n         L     R2,0008(,R2)            CVTLINK\n         CLC   =C'LINKLIST',DCBDDNAM   STEPLIB(LINKLIST)?\n         BE    ATTACH4L                YES, JUMP\n         CLC   =C'SYSTEM  ',DCBDDNAM   STEPLIB(SYSTEM)?\n         BE    ATTACH4L                YES, JUMP\n**       MVI   DCBDSORG,X'02'          DSORG=PO\n         MVI   DCBMACR1,X'D0'          MACRF=E\n         MVI   DCBMACR2,X'08'          MACRF=E\n         MVI   DCBOFLGS,X'02'          DCB FREE FOR USE\n         LA    R2,IHADCB               BUILD OPEN PARM LIST\n         ST    R2,OPENLIST             BUILD OPEN PARM LIST\n         MVI   OPENLIST,X'80'          BUILD OPEN PARM LIST\n         OPEN  MF=(E,OPENLIST)         OPEN TASKLIB\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ATTACH THE PROGRAM                                           *\n*                                                                     *\n*---------------------------------------------------------------------*\nATTACH4L LA    R1,PARMLIST             MOD PARM ADDRESS\n         LM    R3,R4,ESTAIPRM          ESTAI ADDR, PARM\n         LTR   R3,R3                   ESTAI=0 ?\n         BZ    ATTACH4I                YES, JUMP\n         ATTACH EPLOC=PGMNM,                                           X\n               TASKLIB=(R2),                                           X\n               ESTAI=((R3),(R4)),      DEBUGGING ROUTINE               X\n               ECB=ECB1,                                               X\n               SF=(E,ATTACHL)\n         B     ATTACH4S\nATTACH4I ATTACH EPLOC=PGMNM,                                           X\n               TASKLIB=(R2),                                           X\n               ECB=ECB1,                                               X\n               SF=(E,ATTACHL)\nATTACH4S ST    R1,ECB1+4               SAVE TCB ADDRESS\n         WAIT  1,ECB=ECB1              WAIT FOR COMPLETION\n         DETACH ECB1+4                 DETACH SUBTASK\n         TM    DCBOFLGS,X'10'          DCB OPEN?\n         BZ    GOBACK                  NO, JUMP\n         CLOSE MF=(E,OPENLIST)         CLOSE TASKLIB\n*\nGOBACK   LR    R1,R13\n         LH    R2,ECB1+2               PICK UP RETURN CODE\n         L     R13,4(,R13)\n         FREEMAIN RU,LV=DYNAML,A=(R1),SP=0\n         LR    R15,R2                  PASS RETURN CODE\n         RETURN (14,12),RC=(15)\nABEND33  ABEND 33,REASON=(15)          IKJPARS FAILED\n*\n*---------------------------------------------------------------------*\n*        INVOKE PROGRAM VIA XCTL IF NO TASKLIB SPECIFIED              *\n*---------------------------------------------------------------------*\n*\nXCTL1    LA    R15,DWD                 XCTL SF=L\n         LA    R1,PARMLIST             MOD PARM ADDRESS\n         LA    R2,PGMNM                POINT TO PROGRAM NAME\n         SR    R3,R3                   NO DCB\n         STM   R2,R3,0(R15)            XCTL SF=L\n         L     R13,4(,R13)             CALLER'S SAVE AREA\n         XCTL  (2,12),SF=(E,(15))      PASS CONTROL TO SPECIFIED PGM\n*\n*---------------------------------------------------------------------*\n*        DEFINE INPUT PARAMETERS FOR IKJPARS                          *\n*---------------------------------------------------------------------*\n*\nPCLCSECT IKJPARM\nPCLCSECT RMODE ANY\nPGMPCE   IKJPOSIT DSNAME,PROMPT='PROGRAM NAME'\nPARMPCE  IKJKEYWD\n         IKJNAME 'PARM',SUBFLD=PARMSUBF\nLOADPCE  IKJKEYWD\n         IKJNAME 'STEPLIB',SUBFLD=LOADSUBF,ALIAS=('TASKLIB')\nLINPCE   IKJKEYWD\n         IKJNAME 'SYSLIN',SUBFLD=LINSUBF\nMBRPCE   IKJKEYWD\n         IKJNAME 'MEMBER',SUBFLD=MBRSUBF,ALIAS=('MBR')\nMODPCE   IKJKEYWD\n         IKJNAME 'SYSLMOD',SUBFLD=MODSUBF\nLIBPCE   IKJKEYWD\n         IKJNAME 'SYSLIB',SUBFLD=LIBSUBF\nINPCE    IKJKEYWD\n         IKJNAME 'SYSIN',SUBFLD=INSUBF\nPRTPCE   IKJKEYWD\n         IKJNAME 'SYSPRINT',SUBFLD=PRTSUBF\nPUNPCE   IKJKEYWD\n         IKJNAME 'SYSPUNCH',SUBFLD=PUNSUBF\nUT1PCE   IKJKEYWD\n         IKJNAME 'SYSUT1',SUBFLD=UT1SUBF\nUT2PCE   IKJKEYWD\n         IKJNAME 'SYSUT2',SUBFLD=UT2SUBF\nUT3PCE   IKJKEYWD\n         IKJNAME 'SYSUT3',SUBFLD=UT3SUBF\nUT4PCE   IKJKEYWD\n         IKJNAME 'SYSUT4',SUBFLD=UT4SUBF\nTRMPCE   IKJKEYWD\n         IKJNAME 'SYSTERM',SUBFLD=TRMSUBF\n*\nPARMSUBF IKJSUBF\nPARMPCE2 IKJIDENT 'PARM',CHAR,LIST\nLOADSUBF IKJSUBF\nLOADPCE2 IKJIDENT 'STEPLIB',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\nLINSUBF  IKJSUBF\nLINPCE2  IKJIDENT 'SYSLIN',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\nMBRSUBF  IKJSUBF\nMBRPCE2  IKJIDENT 'MEMBER',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\nMODSUBF  IKJSUBF\nMODPCE2  IKJIDENT 'SYSLMOD',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\nLIBSUBF  IKJSUBF\nLIBPCE2  IKJIDENT 'SYSLIB',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\nINSUBF   IKJSUBF\nINPCE2   IKJIDENT 'SYSIN',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\nPRTSUBF  IKJSUBF\nPRTPCE2  IKJIDENT 'SYSPRINT',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\nPUNSUBF  IKJSUBF\nPUNPCE2  IKJIDENT 'SYSPUNCH',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\nUT1SUBF  IKJSUBF\nUT1PCE2  IKJIDENT 'SYSUT1',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\nUT2SUBF  IKJSUBF\nUT2PCE2  IKJIDENT 'SYSUT2',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\nUT3SUBF  IKJSUBF\nUT3PCE2  IKJIDENT 'SYSUT3',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\nUT4SUBF  IKJSUBF\nUT4PCE2  IKJIDENT 'SYSUT4',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\nTRMSUBF  IKJSUBF\nTRMPCE2  IKJIDENT 'SYSTERM',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\n         IKJENDP\n***********************************************************************\n*                                                                     *\n*        DYNAMIC STORAGE AREA (RMODE=24)                              *\n*                                                                     *\n***********************************************************************\nDYNAM    DSECT\n         DS    18F                     SAVE AREA\nDWD      DS    D                       WORK AREA\nDYNECB   DS    F                       ECB FOR IKJPARS\nDYNANSWR DS    F                       WORKA FOR IKJPARS\nDYNPPL   DS    8F                      PPL FOR IKJPARS\nESTAIPRM DS    A(R15,R0)               DEBUGGING ROUTINE PARAMETERS\n*\n*---------------------------------------------------------------------*\n*        PARAMETER LIST AND DDNAME LIST                               *\n*---------------------------------------------------------------------*\n*\nPARMLIST DS    A(PARM256L,PARMDDNL)\nPGMNM    DS    C'ASMA90  '             NAME OF PROGRAM TO BE INVOKED\nECB1     DS    F,A                     ATTACH ECB, TCB ADDR\nPARM256L DS    Y(L'PARM256)            LENGTH OF PARM\nPARM256  DS    CL256                   PARM\n         CNOP  6,8\nPARMDDNL DS    Y(8*12)                 LENGTH OF PARM LIST\nPARMDD1  DS    C'SYSLIN  '         #1  SYSLIN\nPARMDD2  DS    C'TEMPNAME'         #2  MEMBER NAME (LKED)\nPARMDD3  DS    C'SYSLMOD '         #3  SYSLMOD     (LKED)\nPARMDD4  DS    C'SYSLIB  '         #4  SYSLIB\nPARMDD5  DS    C'SYSIN   '         #5  SYSIN\nPARMDD6  DS    C'SYSPRINT'         #6  SYSPRINT (OR SYSLOUT)\nPARMDD7  DS    C'SYSPUNCH'         #7  SYSPUNCH\nPARMDD8  DS    C'SYSUT1  '         #8  SYSUT1\nPARMDD9  DS    C'SYSUT2  '         #9  SYSUT2\nPARMDD10 DS    C'SYSUT3  '         #10 SYSUT3\nPARMDD11 DS    C'SYSUT4  '         #11 SYSUT4\nPARMDD12 DS    C'SYSTERM '         #12 SYSTERM\nDDNAME13 DS    C'SYSUT5  '         +96 SYSUT5\nDDNAME14 DS    C'SYSUT6  '        +104 SYSUT6    SYSCIN\nDDNAME15 DS    C'SYSUT7  '        +112 SYSUT7\nDDNAME16 DS    C'DBRMLIB '        +120 DBRMLIB\n*\n*---------------------------------------------------------------------*\n*        TASKLIB DCB AND ITS OPEN LIST                                *\n*---------------------------------------------------------------------*\n*\nOPENLIST OPEN  IHADCB,MF=L\nIHADCB   DS    13F                     MINI EXCP DCB\nDCBDDNAM EQU   IHADCB+40,8             DDNAME\nDCBOFLGS EQU   IHADCB+48,1             OPEN FLAGS\nDCBMACR1 EQU   IHADCB+50,1             MACRF=E\nDCBMACR2 EQU   IHADCB+51,1             MACRF=E\nATTACHL  ATTACH SF=L\nDYNAML   EQU   *-DYNAM\n         IKJPPL                        PARSE PARAMETER LIST\n         IKJCPPL                       COMMAND PROCESSOR PARM LIST\n         YREGS                         REGISTER EQUATES\n         END   EXECPGM\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//SYSPRINT DD SYSOUT=*\n//*\n//LKED    EXEC PGM=IEWL,PARM='MAP,RENT,REFR,RMODE=ANY'\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=&&LOADMOD(EXECPGM),DISP=(,PASS),\n//            UNIT=VIO,SPACE=(TRK,(1,,1))\n//SYSPRINT DD SYSOUT=*\n//*\n//GO      EXEC PGM=IKJEFT01\n//STEPLIB  DD DSN=&&LOADMOD(EXECPGM),DISP=(OLD,PASS)\n//         DD DSN=CBTTAPE.FILE183.LOAD,DISP=SHR\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\nEXECPGM IEBUPDTE PARM('NEW') +\n                 SYSIN(INDD) +\n                 SYSPRINT(PRTDD) +\n                 SYSUT2(OUTDD)\n//PRTDD    DD SYSOUT=*                           SYSPRINT\n//OUTDD    DD UNIT=VIO,SPACE=(TRK,(1,,1))        SYSUT2\n//INDD     DD *                                  SYSIN\n./ ADD NAME=LEMEMBRE\nIIIIIIIIIIIIIIIIIIIIIIIIIIIII\nJJJJJJJJJJJJJJJJJJJJJJJJJJJJJ\n//*\n//LKED    EXEC PGM=IEWL,PARM='MAP,RENT'\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=CBTTAPE.FILE183.LOAD(EXECPGM),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EXECUTE": {"ttr": 6916, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x05\\x002\\x00\\x881\\x1f\\x01\\x10$O\\x12H\\x00\\xeb\\x00\\x18\\x00\\x9e\\xc3\\xc2\\xe3\\xf4\\xf8\\xf3@@@@'", "ispf": {"version": "02.05", "flags": 0, "createdate": "1988-11-06T00:00:00", "modifydate": "2010-09-01T12:48:32", "lines": 235, "newlines": 24, "modlines": 158, "user": "CBT483"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* MODULE NAME = EXECUTE                                              */\n/*                                                                    */\n/* DESCRIPTIVE NAME = Execute an in-stream CLIST or REXX EXEC         */\n/*                                                                    */\n/* STATUS = R205                                                      */\n/*                                                                    */\n/* FUNCTION = EXECUTE is a REXX EXEC which allows you to execute an   */\n/*            in-stream CLIST or a REXX EXEC in a TSO batch TMP step. */\n/*            Using EXECUTE, you can work around a limitation of      */\n/*            standard TSO/E which can only execute a CLIST or a REXX */\n/*            EXEC stored in a PDS member or a sequential data set.   */\n/*                                                                    */\n/*            EXECUTE can also be invoked as an EDIT macro to         */\n/*            execute the current data set as a CLIST or REXX exec.   */\n/*            The user can select a line or range of lines to         */\n/*            execute by specifying the C, Cn or CC/CC line commands. */\n/*                                                                    */\n/* AUTHOR   =  Gilbert Saint-Flour <carlos@gsf-soft.com>              */\n/*             http://gsf-soft.com/Freeware/                          */\n/*                                                                    */\n/* DEPENDENCIES = TSO/E V2                                            */\n/*                                                                    */\n/* SYNTAX = see below                                                 */\n/*                                                                    */\n/*          EXECUTE CLIST|EXEC                                        */\n/*                  TRACE|NOTRACE                                     */\n/*                  ISPF|ISPSTART                                    */\n/*                                                                    */\n/*     Default:     CLIST,NOTRACE                                     */\n/*                                                                    */\n/*     Sample JCL with PARM and a CLIST :                             */\n/*                                                                    */\n/*        //CLIST EXEC PGM=IKJEFT01,PARM='%EXECUTE'                   */\n/*        //SYSPROC DD DSN=<Library which contains EXECUTE>,DISP=SHR  */\n/*        //SYSTSPRT DD SYSOUT=*                                      */\n/*        //SYSTSIN DD *                                              */\n/*        WRITE In-line CLIST executed by &SYSUID                     */\n/*        /*                                                       */ */\n/*                                                                    */\n/*     Sample JCL with in-line EXECUTE REXX command :                 */\n/*                                                                    */\n/*        //EXEC EXEC PGM=IKJEFT01                                    */\n/*        //SYSEXEC DD DSN=<Library which contains EXECUTE>,DISP=SHR  */\n/*        //SYSTSPRT DD SYSOUT=*                                      */\n/*        //SYSTSIN DD *                                              */\n/*        %EXECUTE EXEC                                               */\n/*        SAY \"In-line EXEC executed by\" USERID()                     */\n/*        /*                                                       */ */\n/*                                                                    */\n/*     Sample JCL with PARM and ISPF option :                         */\n/*                                                                    */\n/*        //ISPF EXEC PGM=IKJEFT01,PARM='%EXECUTE EXEC ISPF'          */\n/*        //SYSEXEC DD DSN=<your EXEC library>,DISP=SHR               */\n/*        //SYSTSPRT DD SYSOUT=*                                      */\n/*        //SYSTSIN DD *                                              */\n/*        SAY \"In-line EXEC executed by\" USERID() in ISPF             */\n/*        SAY \"That's it, it's done !\"                                */\n/*        /*                                                       */ */\n/*        //ISPMLIB DD DSN=ISP.SISPMENU,DISP=SHR                      */\n/*        //ISPTLIB DD DSN=ISP.SISPTENU,DISP=SHR                      */\n/*        //ISPPROF DD UNIT=VIO,SPACE=(TRK,(1,1,1)),RECFM=FB,LRECL=80 */\n/*        //ISPPLIB DD DSN=*.ISPPROF,DISP=OLD,VOL=REF=*.ISPPROF       */\n/*        //ISPSLIB DD DSN=*.ISPPROF,DISP=OLD,VOL=REF=*.ISPPROF       */\n/*        //ISPLOG  DD SYSOUT=*,RECFM=FB,LRECL=121,DSN=&&ISPLOG       */\n/*                                                                    */\n/*      BATCH mode - execute an in-line CLIST which uses REXXTRY      */\n/*                   to execute an in-line REXX exec                  */\n/*                                                                    */\n/*        //CLISTRX EXEC PGM=IKJEFT01                                 */\n/*        //STEPLIB  DD DSN=CBTTAPE.FILE183.LOAD,DISP=SHR   REXXTRY   */\n/*        //SYSPROC  DD DSN=CBTTAPE.FILE183.PDS,DISP=SHR    EXECUTE   */\n/*        //SYSTSPRT DD SYSOUT=*                                      */\n/*        //SYSTSIN  DD *                                             */\n/*        %EXECUTE CLIST                                              */\n/*          /* The CLIST starts here */                               */\n/*        CONTROL LIST CONLIST                             /*CLIST*/  */\n/*        WRITE Start of the CLIST                         /*CLIST*/  */\n/*        REXXTRY A=1;                                     /*REXX*/ + */\n/*                B=2;                                     /*REXX*/ + */\n/*                UID=USERID();                            /*REXX*/ + */\n/*                RETURN(A+B UID)                          /*REXX*/   */\n/*        WRITE LASTCC=&LASTCC RESULT='&RESULT'            /*CLIST*/  */\n/*        EXIT CODE(&LASTCC)                               /*CLIST*/  */\n/*                                                                    */\n/* OPERATION = see below                                              */\n/*                                                                    */\n/*        EXECUTE can be executed from SYSPROC or SYSEXEC.            */\n/*                                                                    */\n/*        EXECUTE creates a temporary data set, copies the in-stream  */\n/*        commands into it, then issues the TSO EXEC command.         */\n/*        EXECUTE processes the in-line commands as a CLIST except    */\n/*        when (1) it is invoked with the EXEC key-word or (2) the    */\n/*        REXX word appears in a comment on the first line.           */\n/*                                                                    */\n/* CHANGES = see below                                                */\n/*                                                                    */\n/* 200 New packaging for the CBT tape                                 */\n/* 201 Can be invoked as an EDIT macro                                */\n/* 202 Add TRACE option                                               */\n/* 203 Add ISPF option                                                */\n/* 204 Change PULL to PARSE PULL to prevent conversion to uppercase   */\n/* 205 Remove \"ADDRESS ISPEXEC\"                                       */\n/*                                                                    */\n/**********************************************************************/\nARG parms                               /* CLIST, EXEC or TRACE     */\nIF SYSVAR('SYSISPF')='ACTIVE' THEN DO\n  \"ISPEXEC CONTROL ERRORS RETURN\"\n  \"ISREDIT MACRO (parms) NOPROCESS\"\n  macro_rc=rc                         /* save rc from ISREDIT macro */\n  END\n  /*                                                                */\n  /*        Process Parameters                                      */\n  /*                                                                */\ntrace=''\ntype=''\nispf=''\nIF WORDS(parms) > 0 THEN DO i=1 to WORDS(parms)\n    p=TRANSLATE(WORD(parms,i))\n    SELECT\n      WHEN ABBREV('CLIST',p,1) THEN\n        type='CLIST'\n      WHEN ABBREV('EXEC',p,1) THEN\n        type='EXEC'\n      WHEN ABBREV('TRACE',p,1) THEN\n        trace='TRACE'\n      WHEN ABBREV('NOTRACE',p,1) THEN\n        trace=''\n      WHEN ABBREV('ISPF',p,1) THEN\n        ispf='ISPF'\n      WHEN ABBREV('ISPSTART',p,1) THEN\n        ispf='ISPF'\n      OTHERWISE DO\n        SAY 'Invalid Parameters, should be CLIST, EXEC or TRACE.'\n        EXIT 20\n        END\n    END\n  END\nIF type='CLIST' and trace='TRACE' THEN DO\n  SAY 'CLIST is not compatible with TRACE.'\n  EXIT 20\n  END\n  /*                                                                */\n  /*        Allocate &SYSUID..INSTREAM.TEMP                         */\n  /*                                                                */\nADDRESS \"TSO\"\ntempdsn=\"'\"USERID()\".INSTREAM.TEMP'\"\nIF LISTDSI('TEMPEXEC' 'FILE')=16 THEN\n  \"ALLOCATE DD(TEMPEXEC) DS(\"tempdsn\") NEW DELETE\",\n         \"UNIT(SYSALLDA) SPACE(1 1) TRACKS\",\n         \"DSORG(PS) RECFM(V B) LRECL(255)\"\n\nIF macro_rc=0 THEN\n  CALL EDIT_MACRO                       /* read EDIT data */\nELSE\n  CALL READ_SYSTSIN                     /* read from //SYSTSIN */\n  /*                                                                */\n  /*        Copy control statements to INSTREAM.TEMP                */\n  /*                                                                */\n\"EXECIO * DISKW TEMPEXEC (STEM stmt. OPEN FINIS)\"\n  /*                                                                */\n  /*        Execute &SYSUID..INSTREAM.TEMP                          */\n  /*                                                                */\nIF ispf='ISPF' THEN\n  PUSH \"ISPSTART CMD(EXEC\" tempdsn type\nELSE\n  PUSH \"EXEC\" tempdsn type             /* add EXEC cmd to TSO stack */\nIF trace='TRACE' THEN                  /* TRACE parameter specified */\n  PUSH \"EXECUTIL TS\"\nEXIT rc\n\n/**********************************************************************/\n/*                                                                    */\n/*                      Read EDIT data set                            */\n/*                                                                    */\n/**********************************************************************/\nEDIT_MACRO:\n\n  /*----------------------------------------------------------------*/\n  /*  If the user selected a range by entering a line command such  */\n  /*  as C, Cnn or C/CC, set line1 and line2 to the first and last  */\n  /*  line numbers, respectively.  Otherwise, set line1 to 1 and    */\n  /*  line2 to the last line of the data set.                       */\n  /*----------------------------------------------------------------*/\n\n  'ISREDIT PROCESS RANGE C'\n  SELECT\n    WHEN rc=0 THEN DO\n      \"ISREDIT (line1) = LINENUM .ZFRANGE\"         /* First line  */\n      \"ISREDIT (line2) = LINENUM .ZLRANGE\"         /* Last line   */\n      END\n    WHEN rc=4 THEN DO\n      line1=1                                    /*   DEFAULTS  */\n      \"ISREDIT (line2) = LINENUM .ZLAST\"         /*   DEFAULTS  */\n      END\n    WHEN rc=20 THEN                       /* All lines deleted        */\n      SIGNAL Empty_dataset                /* No lines to ROUTE        */\n    OTHERWISE DO                          /* Line command conflict    */\n      Pgmrc=rc                            /* Save ISREDIT Return code */\n      IF zerrmsg\\='' THEN\n        'SETMSG MSG('zerrmsg')'           /* Edit has created message */\n      EXIT Pgmrc\n      END\n  END\n  i=0\n  DO line1=line1 to line2\n    \"ISREDIT (line) = LINE\" line1\n    i=i+1\n    stmt.i=line\n  END\n  RETURN\n\nEmpty_dataset:\n  zedsmsg='Empty data set'\n  zedlmsg='There are no lines to execute'\n  'ISPEXEC SETMSG MSG(ISRZ001)'\n  EXIT 12\n\n  /******************************************************************/\n  /*  Read control statements from SYSTSIN into a stemmed variable  */\n  /*  Assume EOF after ten consecutive null strings are returned.   */\n  /******************************************************************/\nREAD_SYSTSIN:\n  n=0\n  DO i = 1 by 1 until n=10\n    PARSE PULL stmt.i                   /* read a line from SYSTSIN */\n    IF stmt.i='' THEN DO                /* blank line or EOF        */\n      n=n+1                             /* count blank lines        */\n      stmt.i=' '                        /* one blank                */\n      END\n    ELSE                                /* non-blank line           */\n      n=0                               /* reset blank lines ctr    */\n  END\n  RETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FASTNOTE": {"ttr": 6921, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x012\\x00I\\x01\\x126\\x1f\\x01\\x18\\x01\\x1f\\x143\\x008\\x00$\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf9\\xf5@@@@'", "ispf": {"version": "01.50", "flags": 0, "createdate": "2012-12-26T00:00:00", "modifydate": "2018-01-11T14:33:49", "lines": 56, "newlines": 36, "modlines": 0, "user": "CBT495"}, "text": "------------------------------------------------------------------\n\nNotes from Sam Golob:\n----- ---- --- -----\n\n1.  December 26, 2012\n\nI looked at Gilbert's work on my z/OS 1.13 system which he had been\nusing.  He invoked FASTPATH from his LOGON CLIST by executing the\ncommand (at the end of the CLIST):\n\nPDF PGM(FASTPATH)\n\nand this worked.  Previously, I tried invoking FASTPATH by saying:\n\nTSO CALL 'library.name(FASTPATH)' and got the following error\nmessages:\n\nIKJ56612I IKJURPS processing ended due to error.  RC=20 ERROR=23\n\n(Sometimes this message comes up, but FASTPATH still loads.  I\nalso invoked FASTPATH with an ISPF SELECT statement as follows:\n\nSELECT PGM(FASTPATH)\n\nwhich seems to work ok, as well.)\n\nSo it seems that on a z/OS 1.12 system (or similar level) you\nshould do what Gilbert himself did.\n\nPrevious to my having tried FASTPATH, I have always updated my ISPF\ncommand table using a package of REXX execs on CBT File 349, from\nWilly Jensen.  The ISPCMDL exec from this collection is useful for\nchecking on the status of your ISPF command table entries, and I am\ntherefore including it here.  While having done that, I also copied\nthe ISPCMDU (table updater) exec, and my ISPCOMND data member.  So\nyou have Willy Jensen's package here too.  In any case, ISPCMDL can\nalways be used to check on whether FASTPATH has done its work.\n\n------------------------------------------------------------------\n\n2.  December 26, 2012\n\nI am a very frequent user of the \"PDS command package\" from CBT File\n182.  This package has a subcommand called LC which lists datasets\naccording to catalog.  And of course, Gilbert's \"LC\" which stands\nfor his LCAT program, conflicts with this.\n\nSo I changed \"LC\" in FASTPATH to \"LCA\".  Sorry.  Gilbert isn't\nusing this himself (I wish he were), and I figure that there are\nso many users of the PDS command out there, that it now outweighs\nthe ones who use LC for LCAT.  So they'll have to use \"LCA\" now.\n\n   SEE MEMBER FASTPMOD IN THIS PDS FOR FURTHER ADVICE ABOUT\n   HOW TO CHANGE THE GENERATED COMMAND TABLE ENTRIES......\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FASTPATH": {"ttr": 6923, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x012\\x00Y\\x00\\x92\\x13O\\x01 5\\x0f\\x14@\\x12u\\x08\\xcd\\x0fM\\xc3\\xc2\\xe3\\xf5\\xf0\\xf0@@@@'", "ispf": {"version": "01.50", "flags": 0, "createdate": "1992-05-13T00:00:00", "modifydate": "2020-12-15T14:40:59", "lines": 4725, "newlines": 2253, "modlines": 3917, "user": "CBT500"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "FASTPDOC": {"ttr": 8964, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x012\\x007\\x01\\x126\\x1f\\x01\\x126\\x1f\\x18C\\x04\\x05\\x04\\x05\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf6@@@@'", "ispf": {"version": "01.50", "flags": 0, "createdate": "2012-12-26T00:00:00", "modifydate": "2012-12-26T18:43:37", "lines": 1029, "newlines": 1029, "modlines": 0, "user": "CBT486"}, "text": "\n    The current version of this document is available here:\n         http://gsf-soft.com/Freeware/FASTPATH.html\n\n            .-----------------------------------.\n            |                                   |\n            |     FASTPATH Utility For ISPF     |\n            |                                   |\n            |       Rel 149 - 25 May 2010       |\n            '-----------------------------------'\n\n              FASTPATH Utility Program for ISPF\n              ---------------------------------\n\n\n\n    INTRODUCTION\n\n*FASTPATH* is a multi-function utility program which allows a TSO user\nto take advantage of the fast-path command facility in ISPF without\nhaving to set up or modify the existing ISPF environment. *FASTPATH*\ntemporarily installs its own commands in the ISPF command table and\nprovides 30 built-in functions to support them.\n\n*FASTPATH* is written in assembler. It is a free program, available in\nsource-code and load-module format in the freeware\n<http://gsf-soft.com/Freeware/> section of this Web site.\n\n\n    OVERVIEW\n\n*FASTPATH* was originally designed for consultants and application\nprogrammers who often are not allowed to customize the ISPF environment\nin which they have to work. To use *FASTPATH*, the TSO user must be able\nto install (or update) a load-library on MVS and issue a TSO command\nfrom within ISPF; that's all.\n\nFor example, let's assume that you just logged on TSO as JOHNDOE using a\nLOGON procedure and ISPF set-up you know nothing about. You transfer\nCBTTAPE.FILE183.LOAD\n<http://gsf-soft.com/Freeware/FILE183.LOAD-LINKMAP.html> to your MVS\nsystem, then activate *FASTPATH* by issuing the\nTSO CALL 'CBTTAPE.FILE183.LOAD(FASTPATH)' command, which returns to you\nwith the \"ISPCMDS Updated\" message in the upper right hand corner of the\nISPF screen. If you press the HELP key at this time, you get a long\nmessage that indicates the name of the commands that have been added to\nthe in-storage copy of the ISPF command table (ISPCMDS).\n\nAt this point, *FASTPATH* has initialized itself by doing the following:\n\n 1. make itself resident in memory for the rest of the ISPF session\n 2. add a set of fast-path commands to your own in-storage copy of\n    ISPCMDS; these commands are:\n\n     Function | Description\n------------------------------------------------------------------------\n     BR       | Browse Entry Panel\n     CALendar | Display pop-up calendar\n     CONNECT  | Connect to your Workstation\n     CNTL 0   | Edit your ISPCTL0 or SPFTEMP0.CNTL data set\n     CNTL     | Edit the current ISPCTLn or SPFTEMPn.CNTL data set\n     CRASH    | Quick exit from ISPF to TSO READY\n     D2X      | Convert a decimal value to hexadecimal\n     ED       | EDIT Entry Panel\n     FSPASTE  | Full-screen PASTE\n     FSTso    | TSO full-screen command (was TSOFS)\n     ICS      | ISPF Command Shell (opt 6)\n     IND$FILE | IND$FILE command (this allows you to transfer files to/\n              | from your PC without having to go to TSO READY or opt 6)\n     LC       | Full-screen LISTCAT\n     LISTBc   | LISTBC command\n     LOAD     | Load a program in memory\n     LOGON    | Exit ISPF and re-LOGON\n     LOGOFf   | Exit ISPF and LOGOFF\n     MAClib   | View a member in SYS1.MACLIB or SYS1.MODGEN\n     NETStat  | Display NETSTAT output in full-screen mode\n     PARMLib  | Edit a member in SYS1.PARMLIB\n     RECEive  | RECEIVE command\n     REXXTry  | Execute a REXX statement\n     RMFmon   | Start RMF\n     SDsf     | SDSF\n     SYSID    | Show system id in screen corner\n     TIME     | Display time, date and julian date\n     TSOCmd   | TSO command\n     UNLOAD   | Remove a program from memory\n     UTil     | Utility Selection Panel (PDF opt 3)\n     VERAse   | Remove a variable from the Shared and/or Profile pool.\n     VI       | View Entry Panel (ISPF V4)\n     WP       | Work-Place (Opt 11 in ISPF V4R2)\n     X2D      | Convert a hexadecimal value to decimal\n     ZDEL     | Display and set the ZDEL variable\n\n 3. make specific TSO, ISPF and SDSF modules resident to improve\n    performance\n 4. start a timer to prevent the TSO session from timing out (if\n    *FASTPATH* has been assembled with the SYSPARM(STOP522) option)\n\nYou're all set to use *FASTPATH*. Here are some of the capabilities\nyou can take advantage of:\n\n 1. Command Stacking\n\n    Enter ED and the EDIT Entry Panel appears on top of the current\n    screen; Enter UT 4 and the Data Set List panel comes up. Enter any\n    of the fast-path commands listed above to activate a new function on\n    top of the current one. The number of functions you can \"stack\" in\n    this fashion is only limited by the REGION parameter you specified\n    at LOGON; to unstack, use the END, RETURN or CANCEL key.\n\n 2. Command Stacking with Dsname or Tag\n\n    Enter a data set name after the ED, BR, VI or WP commands to\n    directly process the specified data set or PDS member; for example,\n    entering the VI 'SYS1.PROCLIB(JES2)' command allows you to VIEW the\n    JES2 procedure.\n\n    Enter a character string (a \"tag\") after the ED, BR, VI or WP\n    commands and the values you enter will be associated with the tag.\n\n    For example, enter ED JCL and enter the values JOHNDOE USER JCL in\n    the Project, Group and Type fields; from that point on, each time\n    you invoke the ED, BR, VI or WP with the JCL tag, *FASTPATH* will\n    present the same values to you, which you can change at any time.\n    For the UT (utilities) and SD (SDSF) commands, the tag is the\n    sub-option for the command; for example, UT 4 takes you to the Data\n    Set List panel (PDF opt 3.4); SD H gets you directly into the SDSF\n    Held Output Display.\n\n 3. Cursor-driven Command Stacking\n\n    Enter BR in the command field, move the cursor under a data set name\n    currently appearing on your screen and press ENTER. *FASTPATH*\n    extracts the data set name from the screen and invokes BROWSE. This\n    feature works with ED, BR, VI, WP and LC.\n\n\n    Installing FASTPATH\n\n*FASTPATH* works on MVS/ESA V4R3, MVS/ESA V5, OS/390 and z/OS. Four\ndifferent installation procedures can be used for *FASTPATH*. The choice\nis determined by the degree of commitment of the tech support staff\ntoward *FASTPATH*: cold, lukewarm, hot.\n\n 1. Low-impact installation\n\n    The easiest installation method consists in linking *FASTPATH* into\n    a load-library that is *not* in the normal search sequence, i.e. not\n    present in the ISPLLIB, STEPLIB or system concatenations. In this\n    case, the user must invoke *FASTPATH* via the TSO CALL command at\n    the beginning of each ISPF session.\n\n 2. Medium-impact installation\n\n    In this scenario, *FASTPATH* is link-edited into a load-library that\n    is in the normal search sequence, i.e. present in the ISPLLIB,\n    STEPLIB, TSOLIB or system concatenations. Users who want to take\n    advantage of the *FASTPATH* facilities must invoke it once, via the\n    TSO FASTPATH command, at the beginning of each ISPF session.\n\n 3. Medium-high-impact installation\n\n    In this scenario also, *FASTPATH* is link-edited into a load-library\n    that is in the normal search sequence, and the ISPF star-up command\n    is modified to execute *FASTPATH*; example:\n\n     ISPSTART PGM(FASTPATH) PARM(SELECT PANEL(MAINMENU))\n\n 4. High-impact installation\n\n    In this scenario also, *FASTPATH* is link-edited into a load-library\n    that is in the normal search sequence, and the technician in charge\n    of ISPF installation customizes the ISPCMDS table (or the site table\n    in ISPF 4.2) to make fast-path commands permanently available. Users\n    no longer have to invoke *FASTPATH* at the beginning of their ISPF\n    session to activate fast-path commands. Note that initialisation\n    functions (such as PRELOAD and STOP522) are not available in this\n    scenario.\n\n\n    Invoking FASTPATH\n\n*FASTPATH* can be invoked as a TSO command or as a program. Depending on\nhow it is invoked, *FASTPATH* will execute an initialisation procedure\nor perform a function.\n\n 1. Initialisation is performed when *FASTPATH* is invoked as a command,\n    as a program with PARM='', or as a program with R1=0.\n      * When *FASTPATH* is invoked as a TSO command, the following\n        initialisation routines are executed:\n\n         o  PRELOAD\n         o  RESET\n         o  STOP522\n         o  ISPCMDS\n\n      * When *FASTPATH* is invoked as a program (without a parm), the\n        following initialisation routines are executed:\n\n         o  PRELOAD\n         o  RESET\n         o  STOP522\n\n        Initialisation only occurs once during an ISPF session. As part\n        of the initialisation procedure, *FASTPATH* makes itself\n        resident in memory until ISPF terminates. If a new version of\n        *FASTPATH* is link-edited, it is not accessible to a user who\n        has already initialized it, because the in-storage copy has\n        precedence over any other version. However, you may issue\n        TSO FASTPATH at any time to receive a message indicating what\n        fast-path commands are available. You may also delete the\n        in-storage copy of *FASTPATH* by entering the UNLOAD FASTPATH\n        command on each of the ISPF logical screens currently open.\n        Then, by entering TSO FASTPATH, you can install the updated\n        version of *FASTPATH*.\n\n      * When *FASTPATH* is invoked via the CALL command with PARM=CRASH,\n        then initialisation functions are not performed. This feature,\n        new in release 139, allows a TSO user to exit ISPF and execute\n        their own set-up CLIST even when their installation forces\n        LOGOFF when ISPF is exited.\n\n 2. function Processing is performed when *FASTPATH* is invoked as a\n    program with a parm that request a specific function (see parm\n    format, below).\n\n        Conflicts between *FASTPATH* and TSO commands\n\nSome *FASTPATH* commands have the same name as TSO/E commands. This can\nbe an issue if a user wants to enter a TSO command such as NETSTAT in\nthe ISPF Command Shell (PDF opt 6). ISPF provides two ways around this\nproblem:\n\n  * prefix the command with the greater-than sign: >NETSTAT DEVL\n  * use the TSO command: TSO NETSTAT DEVL\n\n\n        Execute commands in a new logical screen\n\nIn ISPF 4.2 and above, a user can direct *FASTPATH* commands to execute\nin a new logical screen using one of the following methods:\n\n 1. with the ISPF START command: START BR 'sys1.samplib'\n 2. by appending a + sign to the command: BR 'sys1.samplib' *+*\n 3. by creating new commands in ISPCMDS; for example:\n\n     ISPCMDS VERB=BRS,                                                 X\n      TRUNC=0,                                                         X\n      ACT='SELECT PGM(ISPSTRT) PARM(BR &ZPARM) SUSPEND',               X\n      DESC='Start BROWSE in a new screen'\n\n\n    INITIALISATION FUNCTIONS\n\n\n      1. ISPCMDS\n\nThe ISPCMDS adds a set of fast-path commands to the in-storage copy of\nthe ISPCMDS table. The commands are defined in a table at the end of the\n*FASTPATH* program. Example:\n\n     ISPCMDS VERB=SDsf,                                                X\n      TRUNC=2,                                                         X\n      ACT='SELECT PGM(FASTPATH) PARM(SDSF,&ZPARM)',                    X\n      DESC='Fast Path Command: SDSF'\n\nBefore adding a command to ISPCMDS, *FASTPATH* checks for an existing\ncommand with the same name (homonym) and, if one is found, deletes it.\nIn ISPF 4.2 and above, *FASTPATH* also checks and deletes homonyms\ncommands when they exist in the \"user\" and \"site\" tables.\n\n\n      2. PRELOAD\n\nThe purpose of the PRELOAD routine is to speed up access to some\nre-entrant programs (such as PDF Edit and Browse) which normally reside\nin system libraries (LPA or link-list). The PRELOAD processing is driven\nby an in-line table which can be customized by the user.\n\no For LPA modules, PRELOAD creates an entry in the Job Pack Area (JPAQ).\nWhen LOAD, LINK, ATTACH or XCTL is issued, MVS looks in the JPAQ for a\nuseable copy of the module. If one is found there, I/O is reduced\nbecause the ISPLLIB and STEPLIB directories do not need to be searched.\nThe following programs are among the LPA modules processed by PRELOAD:\n\n ISRBRO   PDF 1\n ISREDIT  PDF 2\n ISRUDA   PDF 3.1 & 3.2\n ISPEXEC  ISPF application interface\n IRXEXEC  REXX interpreter\n IRXSTAMP REXX stack manager\n\no Other re-entrant modules (link-list, ISPLLIB, STEPLIB, etc), are made\npermanently resident in the user's address-space. This can improve\nperformance because no directory searches or module loads are required\nwhen these programs are invoked. It can also increase paging activity;\ntherefore, pre-loading non-LPA modules should be used with caution.\n\no Other modules can be pre-loaded from the tasklib when *FASTPATH* is\ninitialized using the CALL command (see \"low-impact Installation\"\nabove). In this case, *FASTPATH* can pre-load modules that are present\nin the library from which it executes. These modules can be RENT or\nREUS.\n\nNOTE: Pre-loading of PLPA modules in available in MVS/ESA 4.3 and above.\nThis function uses undocumented formats of the LOAD and IDENTIFY macros\nto clone the LPDE, create two CDEs and one XTLST for each module and\nchain the CDEs to the JPAQ. Note that the modules themselves are not\nduplicated, the only version that exists is the one in PLPA; all that\nPRELOAD does is create entries in the JPAQ that point to the PLPA\nmodules.\n\n3. RESET EDIT Macro\n\n*FASTPATH* issues the IDENTIFY macro to define the RESET entry point as\na program. When RESET is executed as an EDIT macro, it issues the\nfollowing statements:\n\n ISREDIT MACRO\n ISREDIT RESET\n\nThis allows you to specify !RESET as an initial macro without having to\nhave a program by that name anywhere. /This is no longer needed in ISPF\nV5 where any EDIT command can be specified as initial macro./\n\n4. STOP522\n\nThis function establishes a recurring timer that prevents system\ntime-out abends (S522) between the hours of 08:00 and 19:00 to keep the\nTSO session active. STOP522 sets its timer interval just one minute\nshorter than the SMF Job Wait Time (JWT); for example, if the JWT is set\nto 0030 (30 minutes), STOP522 uses a 29-minute interval.\n\nThe STOP522 function has two requirements:\n\n 1. SYSPARM(STOP522) must be specified when *FASTPATH* is assembled.\n 2. *FASTPATH* must execute in a TSO/E 2.4 environment (or above).\n\n\n    FASTPATH Commands\n\n\n      The ED, BR, VI and WP commands\n\nThe BR, VI, ED and WP commands produce five different results:\n\n 1. Display the corresponding PDF Entry panel on top of the currently\n    displayed application, or\n 2. Invoke the Browse, View or Edit PDF service (or the ISPF Work-place)\n    using the data set name specified in the command, or\n 3. Invoke the View or Edit PDF service for a Work-station file whose\n    name is specified in the command, or\n 4. Display the Reference Data Set List and, when the user selects an\n    entry, invoke the Browse, View or Edit PDF service (or the ISPF\n    Work-place) for the corresponding data set, PDS member or\n    Work-station file, or\n 5. Invoke the Browse, View or Edit PDF service (or the ISPF Work-place)\n    using the data set name under which the cursor is positionned when\n    the user presses ENTER. This technique is often called\n    \"point-and-shoot\".\n\nThe BR, VI, ED and WP commands invoke the following *FASTPATH*\nfunctions: BROWSE, EDIT, VIEW and WP. *FASTPATH* always switches to\nNEWAPPL(ISR) to ensure predictable PFK configuration.\n\n 1. Display the PDF Entry Panel\n\n    If the BR, VI, ED and WP command is entered without any parameter,\n    *FASTPATH* displays the corresponding PDF entry panel. For example,\n    if the user enters BR, the BROWSE Entry Panel is displayed in\n    ISPF/PDF V3 and, in ISPF V4, the View Entry Panel is displayed with\n    a / in the Browse Mode choice. If the user enters ED, then the Edit\n    Entry panel is displayed.\n\n    If the user specifies a tag such as J or ABCDEF along with the\n    command, *FASTPATH* displays the corresponding entry panel with the\n    values that were specified the last time the same tag was specified.\n\n    For example, user JOHNDOE enters ED J, fills the Project, Group and\n    Type fields with JOHNDOE, USER and JCL. Each time user JOHNDOE\n    issues BR J, or VI J, or ED J, or WP J, the corresponding entry\n    panel comes up with JOHNDOE, USER and JCL in the Project, Group and\n    Type fields.\n\n    *FASTPATH* keeps track of most of the fields on the entry panel,\n    namely Project, Group (1 to 4), Type, Initial Macro, Format, and\n    Browse Mode.\n\n    For the Workplace, *FASTPATH* also keeps track of the last View\n    (Library or Data set), the object name and volume serial.\n\n    When a tag is specified for the first time, *FASTPATH* checks the\n    catalog for an existing data set, using a dsname built by\n    concatenating the TSO prefix to the tag. If the data set exists,\n    *FASTPATH* treats the tag as a partially-qualified dsname and\n    invokes the ISPF function directly.\n\n    *FASTPATH* saves the tags and associated data in profile variables,\n    using names EDBR0000, EDBR0001, etc. The user can clean unwanted\n    variables from the profile using PDF option 7.3 or the VERASE\n    <http://gsf-soft.com/Freeware/FASTPATH.html#verase> command.\n\n 2. Explicit data set name\n\n    The user can specify a partially or fully qualified data set name\n    which may include a member name. For example, the user may enter\n    BR CLIST, ED 'USER.CLIST' or VI CLIST(XXX*). When this format is\n    used, *FASTPATH* directly invokes the corresponding ISPF service\n    without displaying the service's entry panel.\n\n    If a partially-qualified data set name is specified, *FASTPATH*\n    checks the catalog for the name obtained by prefixing the TSO\n    prefix; if the name is found, then it is used. If the prefixed data\n    set name is not found, then *FASTPATH* uses the name as specified,\n    i.e. without the TSO prefix. For example, if the current TSO prefix\n    is JOHNDOE and the user enters BR SYS1.PROCLIB, then *FASTPATH* will\n    access JOHNDOE.SYS1.PROCLIB if it exists, SYS1.PROCLIB otherwise.\n\n    Uncataloged data sets can be accessed by specifying the volume\n    serial number as part of the dsname; two formats are available:\n\n     1. dsname/volser - example: BR SYS1.CMDLIB/OLDRES\n     2. volser:dsname - example: BR OLDRES:SYS1.CMDLIB\n\n    Instead of a dsname, the user may specify an asterisk, which\n    *FASTPATH* interprets as \"the last data set name explicitely\n    specified\".\n\n    *FASTPATH* saves the dsname and volser in the BRDSN, BRMEM and BRVOL\n    profile variables, for compatibility with the CNAEBROW and CNAEEDIT\n    public-domain CLISTs.\n\n    Note: If the ISPF BROWSE service fails and the BR command\n    <http://gsf-soft.com/Freeware/BR.html> is available, *FASTPATH*\n    invokes it. The BR command <http://gsf-soft.com/Freeware/BR.html> is\n    able to process data set formats that are not normally supported by\n    the ISPF BROWSE service, such as VSAM, BDAM, empty data sets,\n    multi-volumes, etc.\n\n 3. Work-station file name\n\n    The user can specify the name of a file on the work-station to which\n    he is connected using the ISPF Work-station agent. This function,\n    which requires ISPF V4R2, only works with Edit and VIEW.\n\n    For *FASTPATH* to properly identify a work-station file, the name\n    must start with:\n\n     1. a slash: ED /etc/user.text\n     2. a drive identifier: VI C:\\config.sys\n     3. a tilde: ED ~myfile.conf\n\n 4. Reference Data Set List\n\n    If the parameter entered in the BR, VI, ED or WP command consists of\n    a single slash character (\"/\"), *FASTPATH* displays the Reference\n    Data Set List; the user can select one of the data set names to be\n    processed as specified by the command entered.\n\n 5. Point-and-shoot\n\n    If the command is entered without a parameter and *FASTPATH* detects\n    that the cursor is positionned under a data set name, then the\n    dsname is extracted and passed to the corresponding function.\n\n    For example, if the user enters BR, VI or ED, moves the cursor under\n    a dsname appearing on the screen and hits ENTER, the corresponding\n    data set or PDS member is automatically browsed, viewed or edited.\n    If WP is entered instead, the Work Place view is switched to Data\n    Set and the Work Place panel is displayed with the dsname placed in\n    the \"Object Name\" field.\n\n    Dsname Extraction Rules:\n\n      * the dsname must appear in totality on the screen and can not be\n        on a message line or in a message window\n      * the data set must be cataloged\n      * the dsname can include a member name\n      * the dsname can be enclosed in apostrophes (single quotes) or\n        surrounded by parentheses\n      * the dsname can be in upper-case, lower-case or mixed-case\n      * the dsname can contain a relative generation number, such as\n        (+1) or (-2)\n      * the member name can be generic, i.e. contain asterisks or\n        percent signs\n\n    The following figure shows examples of data set names and the\n    \"hot-zone\" (marked with hyphens) under which the cursor must be\n    positionned for proper extraction of the data set name.\n\n    If the dsname contains a relative generation number or generic\n    member name, then the \"hot-zone\" only includes the dsname portion of\n    the name.\n\n            EDSN(JOHNDOE.EXEC)            ((JOHNDOE.DDIR))\n                --------------            ----------------\n\n        JOHNDOE.CLIST(LOGPROC)        (JOHNDOE.ISPF.ISPPROF(ISREDIT)\n        ----------------------        ------------------------------\n\n        dsn (johndoe.clist )          'johndoe.ispf.ispprof(isr*)'\n            --------------            ---------------------\n\n        DSN=JOHNDOE.CLIST(PDF44)      DSNAME='JOHNDOE.CLIST(PDF44)'\n        ------------------------      -----------------------------\n\n        NONVSAM--JOHNDOE.EXEC\n        ---------------------\n\n    Notes: When a dsname is not properly extracted by BR, VI or ED, the\n    user should retry with the WP command, correct the dsname, then\n    enter the B, V or E action character. If the ISPF BROWSE service\n    fails, *FASTPATH* invokes the BR command\n    <http://gsf-soft.com/Freeware/BR.html> if it is available.\n\n    When a BR, ED, VI or WP command is entered for a specific data set,\n    i.e. with the explicit dsname, referral list of point-and-shoot\n    options explained above, *FASTPATH* issues RACROUTE to check the\n    user's access to the data set. If the user does not have READ\n    access, *FASTPATH* fails the command to prevent an S913-28 abend and\n    issues a warning message.\n\n 6. Migrated Data Sets\n\n    When it detects that an action is performed against a migrated data\n    set, *FASTPATH* prompts the user before the system RECALLs the data\n    set. The user has the possibility to terminate the action or RECALL\n    the data set and continue.\n\n 7. Relative Generation data sets\n\n    When it detects that a point-and-shoot action is performed against a\n    dsname which contains a relative generation number such as\n    AA.BB.CC(+1), *FASTPATH* changes the relative generation number to\n    .G*V%% and invokes the Work-place instead of the requested function.\n    This results in the ISPF Workplace panel being shown with the\n    converted dsname as follows:\n\n     Object Name . . . . 'AA.BB.CC.G*V%%'\n\n    The user can then press ENTER to invoke the Data Set List utility to\n    display the currently active generation associated to the specified\n    generation data set.\n\n\n      The CALendar Command\n\nThe CALendar command uses the CAL option of the ISPF V4 Status Area to\ndisplay a calendar in a pop-up window.\n\n\n      The CONNECT Command\n\nThe CONNECT command invokes the WSCON function of *FASTPATH* to initiate\na connection with the ISPF Work-station Agent\n<http://gsf-soft.com/Documents/ISPF-CS.html> (ISPF 4.2 and above).\nCONNECT is a shortcut to the panel normally reached using the Settings\noption. CONNECT has no operand. On ISPF 5.0 and above, the WSCON and\nWSDISCON commands should be used instead of CONNECT.\n\n\n      The CNTL Command\n\nThe CNTL command allows the user to EDIT the ISPF control data set\nwhether it's preallocated in the LOGON procedure to DDNAME(ISPCTLn) or\nallocated by ISPF to DSNAME(userid.SPFTEMn.CNTL). CNTL edits the control\ndata set that corresponds to the logical screen in which the CNTL\ncommand is entered, except if CNTL 0 is entered, in which case the\nSUBMIT temporary data set (ISPCTL0) is edited.\n\n\n      The CRASH, LOGON and LOGOFF commands\n\nThe CRASH command causes ISPF and any application executing under it to\nterminate and control to return to the TMP. CRASH is useful when the\nuser wants to exit ISPF in a hurry without properly closing work in\nprogress such as EDIT sessions. For all intents and purposes, CRASH\ncauses ISPF to terminate as if the TSO session was cancelled by the\noperator, except that the TSO session itself does not abend.\n\nThe user can specify a TSO command to be executed at the READY prompt\nafter the termination of ISPF. For example, entering CRASH PDF\nterminates ISPF and re-enters it immediately. Similarly, entering CRASH\n%MYCLIST or CRASH TSOLIB DEACT execute the corresponding command at the\nREADY prompt.\n\nIf the CRASH =pli command is entered, *FASTPATH* retrieves (and executes\nat the READY prompt) the following TSO/E commands:\n\n p. the command specified in the PARM field of the TSO/E LOGON procedure\n l. the command specified in the command field of the TSO/E LOGON panel\n i. the command used to invoke ISPF (such as PDF, ISPF or ISPSTART).\n\nEach command is executed in the order specified for its identifier (that\nis, p, l or i) in the =pli string. For example, if CRASH =p is entered,\nonly the command specified in the LOGON proc's PARM is executed; if\nCRASH =li is specified, both the command from the LOGON panel and the\ncommand used to invoke ISPF are executed. If =pli is specified, all\nthree commands are executed.\n\nIf CRASH is entered without a command, control returns to the READY\nprompt or, if ISPF was invoked from a CLIST, to the next CLIST\nstatement. Note that, unlike CLISTs, REXX EXECs do not survive CRASH:\nany REXX EXEC started before ISPF (and still active at the time CRASH is\nexecuted) is terminated.\n\nThe LOGON and LOGOFF fast-path commands are shortcuts to CRASH LOGON and\nCRASH LOGOFF. For example, entering LOGOFF terminates ISPF and executes\nthe LOGOFF command. Entering LOGON JOHNDOE terminates ISPF and issues\nthe LOGON JOHNDOE command to re-logon.\n\nIf CRASH is issued while a CLIST or REXX EXEC is running within ISPF,\nthe recovery routine of the EXEC command writes abend messages to the\nterminal. This is normal and can not be eliminated.\n\n\n      The D2X Command\n\nThe D2X command uses the REXXTRY\n<http://gsf-soft.com/Freeware/REXXTRY.html> function to convert a\ndecimal value to hexadecimal. Example:\n\n D2X  12345+23\n\n\n      The FSPASTE Command\n\nThe FSPASTE command displays a completely blank input screen that allows\npasting of text that is wider and higher than the ISPF editor input\narea. Once the data is pasted (using the paste facility of the 3270\nemulator), it is presented to the user in a dedicated VIEW session, from\nwhich it can be processed with EDIT command or macros (such as CREATE,\nCUT or ROUTE <http://gsf-soft.com/Freeware/ROUTE.html>). FSPASTE\nrequires the presence of the STEMEDIT\n<http://gsf-soft.com/Freeware/STEMEDIT.html> utility program.\n\nThe maximum number of lines that can be pasted is the number of\nhorizontal lines of the 3270-type terminal; for example, a 3270-5\nstandard terminal, the maximum number of lines is 27. If too many lines\nare pasted, then additional lines overlay the top lines - it's a mess !\nSorry !\n\n\n      The FSTso Command\n\nThe FSTso (TSO Full-Screen) command executes the TSO command passed as a\nparameter, captures the output using OUTTRAP and displays the result\nusing BRIF (the ISPF BRowse InterFace). FSTso requires the presence of\nthe STEMDISP or STEMEDIT <http://gsf-soft.com/Freeware/STEMEDIT.html>\nutility programs. When STEMEDIT\n<http://gsf-soft.com/Freeware/STEMEDIT.html> is used, the user can\nswitch from BROWSE to VIEW by entering the *V* command, then use\ncommands such as CREATE, CUT or ROUTE\n<http://gsf-soft.com/Freeware/ROUTE.html> to transfer the data to a\npermanent location.\n\nTo display the HELP text for the LISTCAT command, enter:\n\n    FSTso H LISTCAT\n\nTo retrieve the data set name at the cursor location, use the %DSNAME\nstring, as shown in this example:\n\n    FSTso LISTCAT ENT('%DSNAME')\n\nFSTso uses the standard TSO/E OUTTRAP facility and, consequently, only\nsupports applications that use PUTLINE to write to the TSO terminal.\nPrograms that use TPUT or BSAM/QSAM to write to the TSO terminal do not\nwork with FSTso\n\n\n      The ICS Command\n\nThe ICS command invokes the ISPF Command Shell (PDF option 6).\n\n\n      The IND$FILE Command\n\nThe IND$FILE command allows 3270-type file transfer on any ISPF screen.\nThis works with IBM's PC/3270 (aka PCOM) and Passport emulators, as well\nas with some (but not all) non-IBM emulators.\n\n\n      The LC command\n\nThe LC command uses the FSTSO\n<http://gsf-soft.com/Freeware/FASTPATH.html#fstso> function to provide a\npoint-and-shoot, full-screen LISTCAT facility. LC extracts the dsname\nunder the cursor, invokes the LISTCAT command and presents the result in\na BROWSE window.\n\n\n      The LISTBc command\n\nThe LISTBc command invokes the TSO LISTBC command with MODE(FSCR) to\nensure displayed messages are displayed at the top of the screen.\n\n\n      The LOAD and UNLOAD commands\n\nThe LOAD command loads a RENT or REUS program in the address space for\nthe duration of the ISPF session or, if ISPF has been invoked via a REXX\nEXEC, until the EXEC terminates. UNLOAD deletes a module that is\ncurrently loaded in memory. Caution should be exercised when using the\nUNLOAD command, as deletion of an in-use module may cause abends.\n\nNotes:\n\n  * The LOAD command supports LIBDEF ISPLLIB\n  * The UNLOAD command cancels timers when the exit address is contained\n    in the UNLOADed module\n\n\n      The MACLib Command\n\nThe MACLIB command displays a macro in the SYS1.MACLIB and SYS1.MODGEN\nconcatenation using BROWSE in ISPF/PDF V3 or VIEW in ISPF V4. To display\nall the TSO macros, enter:\n\n MAClib IKJ*\n\nIf *FASTPATH* finds a PVTMACS library on the system, it concatenates it\nto MACLIB and MODGEN. *FASTPATH* looks for the following names:\n\n SYS1.PVTMACS, &ZUSER..PVTMACS, &ZUSER..PVTMACS.MACLIB\n\n\n      The NETSTAT Command\n\nThe NETSTAT command invokes the TCP/IP NETSTAT command and displays the\nresult using BRIF. This function requires the presence of the STEMDISP\nor STEMEDIT <http://gsf-soft.com/Freeware/STEMEDIT.html> utility\nprograms.\n\nThe NETSTAT command accepts the same parameters as the TCP/IP NETSTAT\ncommand, except STACK and REPORT. For example:\n\n NETSTAT DEVLINK\n\nNote: Specifying NETSTAT without any parameter is equivalent to NETSTAT\nCONN.\n\n\n      The PARMLib Command\n\nThe PARMLib command EDITs members in SYS1.PARMLIB or in the PARMLIB\nconcatenation (OS/390 R2 or above). If the user doesn't have UPDATE\nauthority to SYS1.PARMLIB, then VIEW is used instead of EDIT. Example:\n\n PARML IEASYS*\n\n\n      The REXXTry Command\n\nThe REXXTry command executes a line of REXX code passed as an argument.\nFor example:\n\n REXXTRY SAY 256*3\n\nREXX and ISPF both use the semi-colon to separate statements and\ncommands. Before REXXTRY <http://gsf-soft.com/Freeware/REXXTRY.html> is\ninvoked to execute a the line of code that contains multiple statements\nseparated by a semi-colon, the ZDEL command should be issued to change\nthe ISPF command delimiter to another character. For example:\n\n    ZDEL :\n    REXXT x='abcdef'; SAY x\n    ZDEL ;\n\n\n      The SDsf Command\n\nThe SDdf command starts SDSF. An SDSF option can be specified in the\ncommand. For example:\n\n    SD H ABC*\n\n\n      The SYSID Command\n\nThe SYSID command displays the system ID (SMFSID) and ISPF logical\nscreen number in the upper left-hand corner of the screen (ISPF 4.2 or\nabove). The display is permanent and only affects the current logical\nscreen. Entering SYSID OFF or SCRNAME OFF turns the display off.\n\nThis command can not be entered on an SDSF screen because SDSF has a\nSYSID command of its own. However, SYSID can be issued on the ISPF\nprimary options menu before SDSF is started. To enter the command while\nalready in SDSF, proceed as follows:\n\n 1. stack any non-SDSF panel on top of SDSF (e.g. enter BR)\n 2. issue SYSID\n 3. issue the END or RETURN command to go back to the SDSF screen\n\n\n      The TIME Command\n\nThe TIME command displays the date and time in the upper right-hand\ncorner of the screen. Pressing the HELP key right after entering the\nTIME command displays the day of the week and the julian date. Example:\n\nEDIT     GILBERT.FILE183.PDS                         2009-12-14 19:50:45\nCommand ===>                                            Scroll ===> CSR\nMonday 14 Dec 2009  2009.348  19:50:45  Timezone: E.00.59.16\n\n\n      The TSOCmd Command\n\nThe TSOCmd (TSO Command) command executes the TSO command passed as a\nparameter. To retrieve the data set name at the cursor location, use the\n%DSNAME string, as shown in this example:\n\n    TSOCmd LINKMAP '%DSNAME'\n\n\n      The UTil Command\n\nThe UTil command invokes the Utility Selection Panel (PDF option 3). A\nsub-option can be specified in the command. For example, to invoke the\nData Set Utility (PDF option 3.4), enter:\n\n    UTil 4\n\n\n      The VERASE Command\n\nThe VERASE command removes a variable from the shared and/or the profile\npool. To delete the EDBR0023 variable from the ISPF profile, enter:\n\n    VERASE EDBR0023\n\n\n      The X2D Command\n\nThe X2D command uses the REXXTRY\n<http://gsf-soft.com/Freeware/REXXTRY.html> function to convert a\nhexadecimal value to decimal. Example:\n\n    D2X  3E8\n\n\n      The ZDEL Command\n\nThe ZDEL command displays or sets the ZDEL variable, which specifies the\ncharacter used to chain ISPF commands (the default value is \";\"). When\nentered without an operand, ZDEL displays the current value of the ZDEL\nvariable (i.e. the current command delimiter). A new delimiter can be\nentered in the command; for example, to change the current delimiter to\nthe back-slash, enter:\n\n    ZDEL \\\n\nThe ZDEL function uses an undocumented interface to update the ZDEL\nvariable. This has been tested in ISPF versions from 3.5 through 5.5 but\nmay produce unexpected results in future releases of ISPF.\n\n\n      The B, D, E and V functions\n\nThese functions do not correspond to any fastpath command but are\navailable when access to the BROWSE, LMMDEL, EDIT or VIEW services is\nneeded in an ISPF Dialog Manager panel.\n\n\n      The EXECPGM function\n\nThis function speeds up the execution of a program from the link-list.\n\n\n      The FTINCL function\n\nThis function performs a simple File Tailoring sequence which can be\ninvoked from an ISPF panel. The format of the PARM is as follows:\n\n PARM='FTINCL,&skel,&panel,&applid'\n\nThe FTINCL functions invokes the following ISPF services:\n\n DISPLAY PANEL(&panel) (optional)\n FTOPEN TEMP\n FTINCL &skel\n FTCLOSE\n EDIT DATASET(&ZTEMPF)\n\n\n      The SELECT function\n\nThis function allows *FASTPATH* to be automatically invoked when ISPF\nstarts to perform initialisation tasks such as ADDCMDS and PRELOAD. When\n*FASTPATH* is finished initialising, it starts the main ISPF service,\ntypically a primary option menu such as ISP@MSTR or ISR@PRIM. The main\nISPF service is specified in the SELECT parm as shown in this example:\n\n ISPF PGM(FASTPATH) PARM(SELECT PANEL(APRIOPT) NEWAPPL(MVS))\n\nNote that *FASTPATH* normally requires that a comma be used to separate\nthe name of the function from its parameters; in the case of SELECT, a\nspace may be used as shown in the preceding example.\n\nIf PARM is omitted or simply specified as PARM(SELECT), *FASTPATH*\nstarts PANEL(ISR@PRIM) NEWAPPL(ISR) as the main service.\n\n\n    FASTPATH PARM\n\n       PARM=function<,option><,profile><,parm4>\n\n function   |  option     | profile  |  parm4\n------------|-------------|----------|-------------\n B          |  dsn        | profile  |\n BROWSE     |  tag or dsn | profile  |\n CALENDAR   |             |          |\n CONNECT    |             |          |\n CNTL       |  dsn        | profile  |\n CRASH      |  command    |          |\n D          |  dsn        | member   |  NOENQ\n E          |  dsn        | profile  |\n EDIT       |  tag or dsn | profile  |\n EXECPGM    |  pgm name   | parm     |\n FSPASTE    |             |          |\n FSTSO      |  command    |          |\n FTINCL     |  skeleton   | panel    |  applid\n ICS        |             |          |\n LOAD       |  program    |          |\n MACLIB     |  member     | profile  |\n NETSTAT    |  parameters |          |\n PARMLIB    |  member     | profile  |  VIEW/EDIT\n REXXTry    |  command    |          |\n SDSF       |  subcmd     |          |\n SELECT     |  options    |          |\n SYSID      |  OFF        |          |\n TIME       |             |          |\n UNLOAD     |  program    |          |\n UTIL       |  subopt     |          |\n V          |  dsn        | profile  |\n VERASE     |  var name   |          |\n VIEW       |  tag or dsn | profile  |\n WP         |  tag        |          |\n ZDEL       |  new dlm    |          |\n\n\n    Customizing FASTPATH\n\n1. Tables\n\n*FASTPATH* contains two tables that can be easily modified.\n\na. the ISPCMDS table, which contains the entries that *FASTPATH* adds to\nthe ISPCMDS at the beginning of an ISPF session. This table can be found\nat the very end of the *FASTPATH* source .\n\nb. the PRELOAD table, which contains the name of the programs that\n*FASTPATH* pre-loads to enhance performance.\n\n2. RESET\n\nThe RESET EDIT macro may prevent you from accessing a real program also\ncalled \"RESET\". In that case, you may comment out the IDENTIFY macro\nthat defines RESET.\n\n\n    FASTPATH Q&A\n\nQ. What is the environment required to run *FASTPATH*?\n\nA. Fastpath runs on MVS/ESA V4R3, MVS/ESA V5, OS/390 and z/OS.\n\nQ. My installation does not allow \"command stacking\" in ISPF, they claim\nit \"uses too many resources\".\n\nA. This is probably incorrect. Command stacking uses less resources than\nany of its alternatives, particularly when a user constantly switches\nbetween functions using jump commands (such as =3.4).\n\nQ. We have already modified ISPCMDS and defined ED and BR as fast-path\ncommands to invoke EDIT and BROWSE directly. We plan to use SITECMDS in\nISPF V4.2.\n\nA. *FASTPATH* offers additional capabilities: tags, cursor-driven\ncapabilities, and APPLid consistency. You can get the best of both\nworlds by modifying ISPCMDS to invoke *FASTPATH* built-in functions\ninstead of calling directly EDIT and BROWSE.\n\nQ. We run ISPF 3.5 and have installed fast-path commands in ISRCMDS\nbecause we didn't want to modify ISPCMDS.\n\nA. In that case, fast-path commands can only be used when you're in PDF;\nfor example, they won't work in SDSF.\n\nQ. We use ISPF V4 which has the action bar and Reference Lists. Do we\nstill need *FASTPATH* commands?\n\nA. The action bar is only available when you are in ISPF and it requires\nmore key-strokes than *FASTPATH*. Reference lists also require\nkey-strokes and scrolling. They offer no equivalent to the cursor-driven\ncapabilities of *FASTPATH* commands .\n\nQ. Our systems Programmer is a 3.4 maniac who doesn't want to customize\nISPF so we can use fast-path commands. What can we do?\n\nA. You can use *FASTPATH* just for yourself without having to make\nmodifications to the ISPF environment. Link it into a private\nload-library and call it once at the beginning of an ISPF session: as\nlong as you stay in ISPF, fast-path commands are available to you.\n\nQ. I used fast-path commands before but they were not always working\nproperly: when stacking BROWSE on top of SDSF, for example, the FIND key\nwouldn't work right.\n\nA. This is an APPLid problem caused by an improper set-up. *FASTPATH*\nmakes sure every function is invoked with the right APPLid to ensure\npredictable and constant behaviour.\n\nQ. When using *FASTPATH*'s cursor-driven capabilities, we noticed that\nthe dsname is not always extracted correctly.\n\nA. The dsname extraction algorithm in *FASTPATH* has been rewritten in\nrelease 129 and will be further improved in the future. Dsname\nextraction only works if the dsname is fully visible on the screen, and\nnot in a message line or message window.\n\nQ. How can I automatically set *FASTPATH* commands up without having to\ntype TSO FASTPATH each time I start ISPF?\n\nA. You can specify *FASTPATH* in the ISPF start command, for example:\n\n ISPF PGM(FASTPATH) PARM(SELECT PANEL(APRIOPT) NEWAPPL(MVS))\n\nLast Update: July 2012 for the release 149 of *FASTPATH*.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FASTPMOD": {"ttr": 9226, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x012\\x00\\t\\x01\\x18\\x01\\x1f\\x01\\x18\\x01\\x1f\\x14(\\x00D\\x00D\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf9\\xf5@@@@'", "ispf": {"version": "01.50", "flags": 0, "createdate": "2018-01-11T00:00:00", "modifydate": "2018-01-11T14:28:09", "lines": 68, "newlines": 68, "modlines": 0, "user": "CBT495"}, "text": "      --------- ---- ------- ----- ------- --------- -- --------\n      Modifying ISPF Command Table Entries Generated by FASTPATH\n      --------- ---- ------- ----- ------- --------- -- --------\n\nI hope this little explanation will help you to better use FASTPATH,\nand you can make sure that none of its generated commands will get\nin your way.\n\nPlease let it be known that the FASTPATH command adds a lot of entries\nto the ISPF command table.  These commands may not be the way you want\nthem to be.  For example, the UTIL command to invoke the ISRUTIL panel\ncan be abbreviated to 2 characters, or UT.  Entering UT on a command\nline will then invoke panel ISRUTIL.\n\nPeople who use the PDS 8.6 command from CBT File 182, will not like\nthis setting, because UT as a PDS command will invoke the PDS utility\npanels, and you won't want the IBM ISRUTIL panel always getting in the\nway.\n\nSo how do you fix it?  You have to assemble the FASTPATH program after\nchanging appropriate entries in the ISPCMDS CSECT.  What do you do?\nThe following is an example:\n\nYou want to change:  (for example)\n\nUTIL     2   SELECT PGM(FASTPATH) PARM(UTIL,&ZPARM)   Fast Path Command\n\nto\n\nUTIL     4   SELECT PGM(FASTPATH) PARM(UTIL,&ZPARM)   Fast Path Command\n\nto eliminate the abbreviation to 2 characters.  Or you might want\nan abbreviation to 3 characters, or 0 characters.\n\nSo what do you do?\n\nGo to the assembler source code for FASTPATH and look for the ISPCMDS\nCSECT in column 1.  Then look for the proper command entry, as follows:\n\n*\n         ISPCMDS VERB=UTIL,                                            X\n               TRUNC=2,                                                X\n               ACT='SELECT PGM(FASTPATH) PARM(UTIL,&&ZPARM)',          X\n               DESC='Fast Path Command: PDF Utilities'\n\n\nwhich you will then modify to taste, for example:\n\n*\n         ISPCMDS VERB=UTIL,                                            X\n               TRUNC=4,                                                X\n               ACT='SELECT PGM(FASTPATH) PARM(UTIL,&&ZPARM)',          X\n               DESC='Fast Path Command: PDF Utilities'\n\nand then you reassemble FASTPATH.  Remember to modify the linkedit JCL\nin the middle of the source code.  Look for // in column 1 and scroll\nback upward one screen, to find it.\n\nI hope this little explanation will help you to better use FASTPATH,\nand you can make sure that none of its generated commands will get\nin your way.\n\nAll the best of everything to all of you.\n\n    email:  sbgolob@cbttape.org\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FASTP149": {"ttr": 9473, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x011\\x00!\\x00\\x92\\x13O\\x01\\x126\\x1f\\x163\\x12\\x01\\x01\\xa5\\x0e\\xd3\\xc3\\xc2\\xe3\\xf4\\xf8\\xf3@@@@'", "ispf": {"version": "01.49", "flags": 0, "createdate": "1992-05-13T00:00:00", "modifydate": "2012-12-26T16:33:21", "lines": 4609, "newlines": 421, "modlines": 3795, "user": "CBT483"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "FILE183": {"ttr": 11269, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00'\\x00\\x96\\x14_\\x01\\x08\\x05\\x9f\\x16\\x06\\x002\\x00\\x01\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf8@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-05-24T00:00:00", "modifydate": "2008-02-28T16:06:27", "lines": 50, "newlines": 1, "modlines": 0, "user": "CBT478"}, "text": "/************************************************************** CLIST */\n/*                                                                    */\n/* MODULE NAME = FILE183                                              */\n/*                                                                    */\n/* DESCRIPTIVE NAME = Connect FILE183 libraries to ISPF environment   */\n/*                                                                    */\n/* STATUS = R100                                                      */\n/*                                                                    */\n/* Author: Gilbert Saint-Flour <carlos@gsf-soft.com>                  */\n/*         http://gsf-soft.com/Freeware/                              */\n/*                                                                    */\n/* FUNCTION = This CLIST connects the FILE183 source and load         */\n/*            libraries to ISPF. It allows TSO/ISPF users to execute  */\n/*            REXX execs and programs present in FILE183 libraries,   */\n/*            even if these libraries were not allocated to SYSEXEC   */\n/*            and ISPLLIB before ISPF started.                        */\n/*                                                                    */\n/*          This CLIST does two things;                               */\n/*                                                                    */\n/*          1. It executes the CONCAT exec supplied in FILE183 to     */\n/*             concatenate the FILE183 source library to SYSEXEC.     */\n/*             If SYSEXEC is not already allocated, then CONCAT       */\n/*             allocates and activates it.                            */\n/*                                                                    */\n/*          2. It CALLs the FASTPATH program to LOAD all the modules  */\n/*             present in FILE183.LOAD and executed in the REXX execs */\n/*             present in the FILE183.PDS library.                    */\n/*                                                                    */\n/*          This CLIST gives TSO/ISPF users access to the REXX execs  */\n/*          or programs present in FILE183 when the source and load   */\n/*          libraries are not properly allocated when ISPF starts.    */\n/*                                                                    */\n/* EXECUTION = TSO EXEC 'cbttape.FILE183.PDS(FILE183)'                */\n/*                                                                    */\n/**********************************************************************/\n\nPROC 0 EXEC(cbttape.FILE183.PDS) LOAD(cbttape.FILE183.LOAD)\n\nCONTROL LIST\n\n     /* Concatenate the EXEC library to SYSEXEC */\n\nEXEC '&EXEC.(CONCAT)' 'DS(''&EXEC'') DD(SYSEXEC) AFTER'\n\n     /* Pre-load Programs                       */\n\nCALL '&LOAD.(FASTPATH)'\n\nEXIT\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FILLDASD": {"ttr": 11271, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x00\\x88\\x08\\x7f\\x01\\x04\\x13\\x0f\\x177\\x00\\xe3\\x000\\x000\\xc3\\xc2\\xe3\\xf4\\xf6\\xf9@@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "1988-03-27T00:00:00", "modifydate": "2004-05-09T17:37:00", "lines": 227, "newlines": 48, "modlines": 48, "user": "CBT469"}, "text": "//GILBERTF JOB (ACCT#),FILLDASD,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM  EXEC  PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = FILLDASD                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = Fill free DASD space with binary zeroes          *\n*                                                                     *\n* STATUS = R201                                                       *\n*                                                                     *\n* FUNCTION = This assembler program fills the free space that exists  *\n*            on DASD volumes with binary zeroes.                      *\n*            FILLDASD uses DYNALLOC to allocate temporary data sets   *\n*            and fills the tracks with binary zeroes.                 *\n*            If a volume serial is specified in the PARM, then only   *\n*            the free space of the specified volume is cleared.       *\n*            Otherwise, FILLDASD tries to allocate space on all the   *\n*            available volumes (i.e. PUBLIC, STORAGE, or SMS-managed).*\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = STRING macro                                      *\n*                                                                     *\n*    AUTHORIZATION = NONE                                             *\n*                                                                     *\n*    RESTRICTIONS = NONE                                              *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (CSECT TYPE)                               *\n*                                                                     *\n*    PROCESSOR = IBM Assembler H                                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 2K                                                 *\n*                                                                     *\n*    ATTRIBUTES = NOREUS, RMODE 24, AMODE 24,                         *\n*                 PROBLEM STATE, KEY 8                                *\n*                                                                     *\n* OPERATION = See Examples below:                                     *\n*                                                                     *\n*   Clear free space on TEMP01                                        *\n*                                                                     *\n*     //FILLDASD EXEC PGM=FILLDASD,PARM=TEMP01                        *\n*     //SYSPRINT DD SYSOUT=*                                          *\n*                                                                     *\n*   Clear free space on all available packs:                          *\n*                                                                     *\n*     //FILLDASD EXEC PGM=FILLDASD                                    *\n*     //SYSPRINT DD SYSOUT=*                                          *\n*                                                                     *\n* PARAMETERS = None                                                   *\n*                                                                     *\n* RETURN-CODES = SEE BELOW                                            *\n*                                                                     *\n*        0       OK                                                   *\n*        8       OPEN or CLOSE failed                                 *\n*                                                                     *\n* CHANGE LOG = SEE BELOW                                              *\n*                                                                     *\n*201 SYNAD                                                            *\n***********************************************************************\nFILLDASD CSECT\nFILLDASD AMODE 24\n         DC    C'GSF Utilities - FILLDASD R201 ',0H'0'\nBEGIN    LR    R12,R15                 BASE REG\n         USING BEGIN,R12\n         L     R2,0(,R1)               A(JCLPARM)\n*\n*        Retrieve optional volume serial from the parm\n*\n         LH    R3,0(,R2)               L'JCLPARM\n         LTR   R3,R3                   VOLSER SPECIFIED IN THE PARM?\n         BZ    OPENPRT                 NO, JUMP\n         STRING (2(R2),(R3)),INTO=VOLSER SAVE VOLUME SERIAL\n         MVC   RTVOL,=AL2(DALVLSER)    VOLUME SERIAL IS KNOWN\n*\n*        Print title line\n*\nOPENPRT  OPEN  (SYSPRINT,OUTPUT)\n         LTR   R15,R15                 OPEN OK?\n         BNZ   EOJ                     NO, EXIT\n         TIME  DEC                     GET DATE & TIME\n         STM   R0,R1,TIMEDATE          SAVE TIME AND DATE\n         STRING '1GSF Utilities - FILLDASD R200 - PARM=''',            X\n               (2(R2),(R3)),''' ',(TIMEDATE+4,P,YYYY-MM-DD),           X\n               1X,(TIMEDATE+0,1,X),'.',(TIMEDATE+1,1,X),INTO=PRTLINE\n         PUT   SYSPRINT,PRTLINE        WRITE TITLE LINE\n*\n*        Set up DYNALLOC request block\n*\n         LA    R8,S99RB1               DYNALLOC REQUEST BLOCK\n         USING S99RB,R8\n         MVI   S99RBLN,S99RBEND-S99RB  LENGTH\n         MVI   S99VERB,S99VRBAL        ALLOCATE\n         LA    R0,=A(WKUNIT,TRK,PRIME,RTVOL,RTDDN,CONTIG+VL)\n         ST    R0,S99TXTPP             TEXT UNIT POINTERS\n*---------------------------------------------------------------------*\n*        Main Loop: Allocate temporary DASD data sets                 *\n*        and fill them up with X'00'                                  *\n*---------------------------------------------------------------------*\n*LOOP\nALLOC    LA    R1,=A(S99RB1+VL)        S99RBPTR\n         DYNALLOC\n         LTR   R15,R15                 dynalloc ok?\n         BNZ   HALVE                   no, try smaller size\n         MVC   DCBDISK+40(8),DDNAME    MOVE DDNAME INTO DCB\n         OPEN  (DCBDISK,OUTPUT)        OPEN TEMP DATA SET\n         LTR   R15,R15                 OPEN OK?\n         BNZ   EOJ                     NO, EXIT\n         L     R1,DCBDISK+44           DEB\n         LH    R3,046(,R1)             # of tracks actually allocated\n         STRING 1X,%TIME,'ALLOCATED DDN=',DDNAME,                      X\n               ' VOL=',VOLSER,                                         X\n               ' TRACKS=',((R3),,L),                                   X\n               INTO=PRTLINE\n         PUT   SYSPRINT,PRTLINE        WRITE A PRINT LINE\n         LR    R0,R3                   TALLY TRACKS\n         AL    R0,TOTTRACKS            TALLY TRACKS\n         ST    R0,TOTTRACKS            TALLY TRACKS\n         ALR   R3,R3                   # OF BLOCKS\n         SLR   R0,R0\n         LH    R1,DCBDISK+62           BLKSIZE\n         LH    R2,DCBDISK+82           LRECL\n         DR    R0,R2                   RECORDS/BLOCK\n         MR    R2,R1                   # OF RECORDS\n*--LOOP\nPUTDISK  PUT   DCBDISK                 LOCATE A DISK RECORD\n         BCT   R3,PUTDISK              FILL UP THE TRACKS\n*--LOOP\n         CLOSE DCBDISK                 CLOSE DISK DCB\n         FREEPOOL DCBDISK              free buffer pool\n         B     ALLOC\nHALVE    SLR   R2,R2\n         ICM   R2,B'0111',PRIMEQTY     # OF TRACKS\n         SRL   R2,1                    HALVE\n         STCM  R2,B'0111',PRIMEQTY     # OF TRACKS\n         LTR   R2,R2                   ZERO?\n         BP    ALLOC                   NO, CONTINUE\n*ENDLOOP\n         STRING '0',%TIME,'TOTAL TRACKS WRITTEN: ',(TOTTRACKS,F,L),    X\n               INTO=PRTLINE\n         PUT   SYSPRINT,PRTLINE        WRITE LAST PRINT LINE\n         CLOSE SYSPRINT                CLOSE PRINT DCB\nEOJ      SVC   3                       EOJ\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Error routine to trap hardware errors (EQC)                  *\n*                                                                     *\n*        //DD1 DD DSN=SYS1.VDATA33.CYL-01EF.TRK-000B,DISP=(,CATLG),   *\n*        //  DSORG=PSU,RECFM=F,BLKSIZE=80,                            *\n*        //  UNIT=3390,VOL=SER=DATA33,SPACE=(ABSTR,(1,7436))          *\n*                                                                     *\n*---------------------------------------------------------------------*\nSYNAD1   LR    R10,R14                 return address\n         SYNADAF ACSMETH=QSAM          get error message\n         LR    R2,R1                   addr of SYNAD message\n         STRING '0',%TIME,(50(R2),128-50),INTO=PRTLINE\n         PUT   SYSPRINT,PRTLINE        WRITE SYNAD MESSAGE\n**       STRING '0',%TIME,(DCBDISK+8,4,X),INTO=PRTLINE\n         LA    R0,8                    L'CCCCHHHH\n         LA    R1,111(,R2)             CCCCHHHH\n*LOOP\nSYNAD2   CLI   0(R1),C'F'              A-F ?\n         BH    SYNAD2N                 NO, ITERATE\n         IC    R14,0(,R1)              yes, X'C1' -> X'CA'\n         LA    R14,9(,R14)             yes, X'C1' -> X'CA'\n         STC   R14,0(,R1)              yes, X'C1' -> X'CA'\nSYNAD2N  LA    R1,1(,R1)               BUMP INDEX UP\n         BCT   R0,SYNAD2               ITERATE\n*ENDLOOP\n         PACK  DWD(3),111(5,R2)        CCCC..\n         LH    R4,DWD                  CCCC\n         MH    R4,=H'15'               cylinders -> tracks\n         PACK  DWD+2(3),111+4(5,R2)    HHHH..\n         AH    R4,DWD+2                add tracks\n         STRING '0',%TIME,'Bad track at CCHH=',(DWD,4,X),              X\n               ' VOL=SER=',VOLSER,',SPACE=(ABSTR,(1,',((R4),,L),'))',  X\n               INTO=PRTLINE\n         PUT   SYSPRINT,PRTLINE        WRITE CCHH\n         SYNADRLS                      free error message and save area\n         BR    R10                     goback to PUT macro\n*---------------------------------------------------------------------*\n*        CONSTANTS AND DATA                                           *\n*---------------------------------------------------------------------*\nWKUNIT   DC    AL2(DALUNIT,1,8),CL8'SYSALLDA'\nTRK      DC    AL2(DALTRK,0)\nPRIME    DC    AL2(DALPRIME,1,L'PRIMEQTY)\nPRIMEQTY DC    FL3'10000'\nRTVOL    DC    AL2(DALRTVOL,1,L'VOLSER)\nVOLSER   DC    C'123456'\nRTDDN    DC    AL2(DALRTDDN,1,L'DDNAME)\nDDNAME   DC    CL8' '\nCONTIG   DC    AL2(DALSPFRM,1,1),X'08'\nDWD      DS    D\nDCBDISK  DCB   DSORG=PS,MACRF=PL,DDNAME=*,RECFM=FB,LRECL=80,BUFNO=10,  X\n               SYNAD=SYNAD1\nSYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,RECFM=FBA,LRECL=121\nS99RB1   DC    XL(S99RBEND-S99RB)'00'\nTIMEDATE DS    2F                    TIME MACRO\nTOTTRACKS DS   F\nPRTLINE  DS    CL121\nVL       EQU   X'80000000'           END OF LIST\n         IEFZB4D0                    S99RB\n         IEFZB4D2                    KEY TABLE\n         YREGS\n         STRING GENERATE\n         END   BEGIN\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=CBTTAPE.FILE183.PDS,DISP=SHR       STRING\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//*       clear free space on VOL=OS39M1\n//*\n//GO      EXEC PGM=LOADER,PARM='NOPRINT/OS39M1'\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSPRINT DD SYSOUT=*\n//*\n//*       clear free space on SMS-managed volumes\n//*\n//GO      EXEC PGM=LOADER,PARM='NOPRINT'\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FREEDIR": {"ttr": 11276, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00(\\x00\\x91\\x14_\\x01\\x08\\x08O\\x11#\\x003\\x00\\x13\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf8@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1991-05-25T00:00:00", "modifydate": "2008-03-24T11:23:28", "lines": 51, "newlines": 19, "modlines": 0, "user": "CBT478"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* MODULE NAME = FREEDIR                                              */\n/*                                                                    */\n/*   Invoke PDS86 to add directory blocks to the current data set     */\n/*                                                                    */\n/*        http://www.cbttape.org/ftp/updates/CBT035.zip               */\n/*                                                                    */\n/* STATUS = R200                                                      */\n/*                                                                    */\n/* FUNCTION = FREEDIR is an ISPF EDIT macro which invokes PDS86       */\n/*            to allocate or free directory blocks in a PDS.          */\n/*                                                                    */\n/*            FREEDIR can be used to increase or reduce the number    */\n/*            of directory blocks of the PDS that is being edited.    */\n/*                                                                    */\n/* AUTHOR   =  Gilbert Saint-Flour <carlos@gsf-soft.com>              */\n/*             http://gsf-soft.com/Freeware/                          */\n/*                                                                    */\n/* DEPENDENCIES = ISPF V2R3                                           */\n/*                PDS 8.6                                             */\n/*                                                                    */\n/* SYNTAX   =  FREEDIR                                                */\n/*                nnnn              number of free directory blocks   */\n/*                                                                    */\n/* INSTALLATION = FREEDIR must be installed in a REXX library         */\n/*                which is accessible in ISPF/PDF.                    */\n/*                                                                    */\n/**********************************************************************/\nADDRESS ISPEXEC\nARG dsn numdir\nvol=''\nIF dsn='' THEN DO\n  'ISREDIT MACRO (numdir)'\n  IF rc>0 THEN DO; SAY 'ISREDIT_RC='rc; EXIT(rc);END\n  'ISREDIT (dsn) = DATASET'\n  IF rc=0 THEN DO\n    'ISREDIT (vol) = VOLUME'\n    VOL = 'VOLUME('vol')'\n    END\n  END\nELSE DO\n  'VGET (ZDLDSN ZDLVOL)'\n  IF rc=0 THEN\n    VOL = 'VOLUME('zdlvol')'\n  END\n /* say zdlvol dsn vol rc */\nIF LEFT(dsn,1) <> \"'\" THEN dsn=\"'\" || dsn || \"'\"\nIF numdir='' THEN DO; SAY 'NUMDIR Missing'; EXIT(12);END\n\"SELECT CMD(PDS86\" dsn vol \"FIX FREEDIR(\"numdir\")) MODE(FSCR)\"\nEXIT RC\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FSHELP": {"ttr": 11278, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00A\\x00\\x886_\\x01\\x085\\x1f\\x15\\t\\x007\\x00\\r\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf8@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1988-12-30T00:00:00", "modifydate": "2008-12-16T15:09:41", "lines": 55, "newlines": 13, "modlines": 0, "user": "CBT478"}, "text": "/************************************************************** REXX **\\\n|*                                                                    *|\n|* Module Name: FSHELP                                                *|\n|*                                                                    *|\n|* Descriptive Name:  Issue HELP command under ISPF and display       *|\n|*                    output using the BROWSE service available       *|\n|*                    in the STEMEDIT utility program.                *|\n|*                                                                    *|\n|* Status: R200                                                       *|\n|*                                                                    *|\n|* Function: This EXEC helps ISPF users trap the output of the        *|\n|*           standard TSO/E HELP command and display its output       *|\n|*           via the STEMEDIT routine.                                *|\n|*                                                                    *|\n|*           The user can then enter the V command to display the     *|\n|*           result of the HELP command with VIEW instead of BROWSE.  *|\n|*           Unlike BROWSE, VIEW allows the user to enter commands    *|\n|*           such as CUT or CREATE, and EDIT macros, such as ROUTE.   *|\n|*                                                                    *|\n|*           FSHELP can only be used in ISPF, as a TSO command or     *|\n|*           an EDIT macro.                                           *|\n|*                                                                    *|\n|* Author: Gilbert Saint-Flour <carlos@gsf-soft.com>                  *|\n|*         http://gsf-soft.com/Freeware/                              *|\n|*                                                                    *|\n|* Syntax: FSHELP                                                     *|\n|*           parameters    Name of TSO command and options            *|\n|*                                                                    *|\n|* Example:  FSHELP LISTCAT ALL          ; EDIT Macro                 *|\n|*           TSO %FSHELP LISTDS          ; TSO Command                *|\n|*                                                                    *|\n|* Environment: TSO/E V2                                              *|\n|*              ISPF/PDF 2.3                                          *|\n|*              STEMEDIT  http://gsf-soft.com/Freeware/STEMEDIT.shtml *|\n|*                                                                    *|\n|*200 New version with STEMEDIT                                       *|\n\\**********************************************************************/\n\"ISPEXEC CONTROL ERRORS RETURN\"        /* Prevent MACRO RC=20 ISRE771 */\n\"ISPEXEC ISREDIT MACRO (parms)\"\nIF rc>0 THEN ARG parms                      /* Invoked as TSO %FSHELP */\nUPPER parms; cmd=\"HELP\" parms\nRC=OUTTRAP(\"LINE.\"); cmd; cc=rc; rc=OUTTRAP(\"OFF\")\n\nSIGNAL ON SYNTAX                            /* STEMEDIT not available */\nCALL STEMEDIT \"BROWSE\",\"LINE.\",,,cmd        /* Display HELP Output    */\nEXIT cc\n\nSYNTAX:                            /* STEMEDIT function not available */\n  error=rc\n  'ISPEXEC CONTROL DISPLAY LINE START(1)'\n  SAY 'REXX error' error 'in line' sigl':' errortext(error)\n  SAY sourceline(sigl)\n  SAY ''\n  DO i=1 TO QUEUED(); PARSE PULL line; SAY line ; END\n  EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FTP": {"ttr": 11521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x001\\x00\\x94\\x12O\\x00\\x98\\x01O\\x17T\\x00\\x8d\\x00\\t\\x00_\\xc3\\xc2\\xe3\\xf4\\xf7\\xf6@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-05-04T00:00:00", "modifydate": "1998-01-14T17:54:31", "lines": 141, "newlines": 9, "modlines": 95, "user": "CBT476"}, "text": "/*****************************************************************REXX*/\n/*                                                                    */\n/* MODULE NAME = FTP                                                  */\n/*                                                                    */\n/* DESCRIPTIVE NAME = FTP EDIT Macro for ISPF/PDF                     */\n/*                                                                    */\n/* STATUS = R102                                                      */\n/*                                                                    */\n/* FUNCTION = The FTP EDIT macro is used to transmit a copy of the    */\n/*            data currently being edited to a remote host using      */\n/*            text-mode FTP.  This EDIT macro is useful to transmit   */\n/*            data that does not exist on disk in a transmittable     */\n/*            form, such as packed data, data modified during the     */\n/*            current EDIT session, or data only accessible via the   */\n/*            EDIT Interface (EDIF).                                  */\n/*                                                                    */\n/* AUTHOR   =  Gilbert Saint-Flour <carlos@gsf-soft.com>              */\n/*                                                                    */\n/* Dependencies = TSO/E V2                                            */\n/*                ISPF/PDF V3 or ISPF V4                              */\n/*                TCP/IP V3                                           */\n/*                ROUTEPGM utility R605 (optional)                    */\n/*                FASTPATH utility R128 (optional)                    */\n/*                                                                    */\n/* SYNTAX   =  FTP                                                    */\n/*                 host                  remote host or IP address    */\n/*                 userid                userid to use                */\n/*                                       (default: anonymous)         */\n/*                 password              password for userid          */\n/*                 dir                   directory to change to       */\n/*                                                                    */\n/* OPERATION = see below                                              */\n/*                                                                    */\n/*        FTP creates a temporary data set, copies the data           */\n/*        into it, then creates the control data set and issues       */\n/*        the TCP/IP FTP command.                                     */\n/*                                                                    */\n/* CHANGES = see below                                                */\n/*                                                                    */\n/* 100 New packaging for the CBT tape                                 */\n/* 101 added userid/password and dir options - Lionel Dyck            */\n/* 102 Replace EXECIO with ROUTEPGM                                   */\n/*                                                                    */\n/**********************************************************************/\nRoutepgm='NO'                  /* Use the REXX stack and EXECIO       */\nRoutepgm='YES'                 /* Use the ROUTEPGM program            */\nFastPath='NO'                  /* Invoke the FTP command directly     */\nFastPath='YES'                 /* Invoke FTP via the FASTPATH utility */\n              /* -------------------------- */\n              /* Allocate Tempftp file      */\n              /* -------------------------- */\nftpdsn='tempftp.text'\nRC=LISTDSI(ftpdsn 'NORECALL')\nIF RC>0 THEN DO\n  IF RC=16 & SYSREASON=9 THEN\n    \"HDELETE\" ftpdsn \"WAIT\"\n  \"ALLOC DS(\"ftpdsn\") NEW CATALOG\",\n       \"TRACKS SPACE(10 10) UNIT(SYSALLDA)\",\n       \"DSORG(PS) RECFM(V B) LRECL(255)\"\n  \"FREE DS(\"ftpdsn\")\"\n  END\nRC=LISTDSI('TEMPFTP' 'FILE')\nIF RC>0 THEN\n  \"ALLOC DD(TEMPFTP) DS(\"ftpdsn\") OLD DELETE\"\n            /* -------------------------------- */\n            /*     Retrieve ISPF variables      */\n            /* -------------------------------- */\nADDRESS 'ISPEXEC'\n\"CONTROL ERRORS RETURN\"\n\"ISREDIT MACRO (HOST)\";  IF rc>0 THEN EXIT rc\nIF host='' THEN EXIT 12\n\"VGET (ZTEMPF ZTEMPN)\"\n            /* -------------------------------- */\n            /* Write the text to tempftp.userid */\n            /* -------------------------------- */\nIF Routepgm='YES' THEN\n  \"SELECT PGM(ROUTEPGM) PARM(TEMPFTP)\"\nELSE DO\n    DO I=1 BY 1\n      \"ISREDIT (LINE) = LINE\" I             /* GET CURRENT LINE */\n      IF RC>0 THEN LEAVE\n      IF line='' THEN\n        QUEUE ' '                           /* blank line */\n      ELSE\n        QUEUE STRIP(line,'T')\n    END\n  QUEUE ''\n  ADDRESS 'TSO' \"EXECIO * DISKW TEMPFTP (FINIS\"\n  END\n/**********************************************************************/\n/*                                                                    */\n/*             Build the FTP control statements                       */\n/*                                                                    */\n/**********************************************************************/\nADDRESS 'TSO'\n/* -------------------------- */\n/* Clear out variables        */\n/* -------------------------- */\nparse value \"\" with userid password dir\n\n/* -------------------------- */\n/* test for userid/password   */\n/* -------------------------- */\nif words(host) > 1 then\n   parse value host with host userid password dir .\n\nQUEUE host\n\n/* -------------------------- */\n/* if userid then use it      */\n/* -------------------------- */\nif length(userid) > 0 then\n   QUEUE userid password\nelse\n   QUEUE 'anonymous'\n\n/* -------------------------- */\n/* test for dir               */\n/* -------------------------- */\nif length(dir) > 0 then\n   QUEUE 'cd' dir\n\n/* -------------------------- */\n/* queue out put command      */\n/* -------------------------- */\nQUEUE 'put' ftpdsn 'tempftp.'userid()\nQUEUE 'quit'\nQUEUE ''\n\"EXECIO * DISKW\" ZTEMPN \"(FINIS\"\n/**********************************************************************/\n/*                                                                    */\n/*             Invoke the FTP client program                          */\n/*                                                                    */\n/**********************************************************************/\n\"ALLOC DD(INPUT) OLD DS('\"ZTEMPF\"') REUSE\"\n\"ALLOC DD(OUTPUT) DS(*)\"\nIF FastPath='YES' THEN\n  \"ISPEXEC SELECT PGM(FASTPATH) PARM(EXECPGM,FTP)\"\nELSE\n  \"FTP\"\n\"FREE DD(INPUT OUTPUT)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FULLDSN": {"ttr": 11525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00E\\x01\\x01\\x07O\\x01\\x01\\x07O\\x12\\x18\\x00\\x9e\\x00\\x1f\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf3\\xf4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-03-15T00:00:00", "modifydate": "2001-03-15T12:18:45", "lines": 158, "newlines": 31, "modlines": 0, "user": "CBT434"}, "text": "//GILBERTN JOB (ACCT#),NOTIFY=&SYSUID,CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = FULLDSN                                               *\n*                                                                     *\n* DESCRIPTIVE NAME = REXX function: returns fully-qualified dsname.   *\n*                                                                     *\n* STATUS = R100                                                       *\n*                                                                     *\n* FUNCTION = This assembler sub-routine can be invoked in a REXX      *\n*            EXEC to convert an alias name into the corresponding     *\n*            real dsname, or a dsname with a relative generation      *\n*            number such as PROD.MASTER(-2) into a fully-qualified    *\n*            dsname such as PROD.MASTER.G12345V00.                    *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*          http://gsf-soft.com/Freeware/                              *\n*                                                                     *\n*        Note: This is a rewrite of Doug Nadel's REALNAME program     *\n*              to make it re-entrant and improve performance when     *\n*              FULLDSN is invoked multiple times in the same exec.    *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*    DEPENDENCIES: TSO/E V2                                           *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (CSECT TYPE)                               *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 or                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 2K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE ANY, AMODE 31,                   *\n*                 PROBLEM STATE, KEY 8                                *\n*                 APF AUTHORIZATION: NONE                             *\n*                                                                     *\n* SYNTAX  =  See below                                                *\n*                                                                     *\n*         fdsn=FULLDSN(dsname)                                        *\n*                                                                     *\n*    Arguments:                                                       *\n*                                                                     *\n*         dsname    This is the input data set name which will be     *\n*                   converted to a real dsname or a fully-qualified   *\n*                   GDS name such as PROD.MASTER.G12345V00.           *\n*                                                                     *\n***********************************************************************\nFULLDSN  RSECT\nFULLDSN  RMODE ANY\n         SAVE  (14,12),,FULLDSN\n         LR    R12,R15\n         USING FULLDSN,R12\n         LM    R2,R3,16(R1)        R2/R3\n*\n*        Allocate dynamic storage\n*\n         GETMAIN R,LV=DYNAML\n         LR    R11,R1              A(DYNAM)\n         USING DYNAM,R11\n*\n*        Make sure I stay in memory for the life of the exec\n*\n         L     R4,PSATOLD-PSA(0,0) my TCB\n         USING TCB,R4\n         L     R4,TCBJSTCB         job-step TCB\n         L     R5,TCBJPQ           my CDE\n         USING CDENTRY,R5\n         CLI   CDUSE+1,1           first time through?\n         BNE   PIN99               no, jump\n         TM    CDATTR,CDREN        reentrant module?\n         BZ    PIN99               no, jump\n         CL    R12,CDENTPT         is this my CDE?\n         BNE   PIN99               no, jump\n         LOAD  EPLOC=CDNAME        bump my own use count\nPIN99    EQU   *\n         DROP  R5                  CDENTRY\n*\n         L     R3,0(,R3)           R3 = address REXX eval block\n         USING EVALBLOCK,R3\n*\n*        Move dsname to result area\n*\n         LM    R4,R5,0(R2)         R6/R7 = Addr/Length of input dsn\n         LA    R6,EVALBLOCK_EVDATA R4 = addr(evalblock_evdata);\n         LA    R7,44               R5 = length(evalblock_evdata);\n         ST    R7,EVALBLOCK_EVLEN  Result length=44\n         ICM   R5,B'1000',=C' '    padding character\n         MVCL  R6,R4               evalblock_evdata(1:44) = input dsn\n*\n*        Look up dsname in the catalog\n*\n         L     R14,CAMLST1         CAMLST flags\n         LA    R15,EVALBLOCK_EVDATA R15 = addr(dsname)\n         SLR   R0,R0               CVOL addr\n         LA    R1,WORKAREA         addr of LOCATE work-area\n         STM   R14,R1,CAMLST2      build CAMLST in dynamic storage\n         LOCATE CAMLST2            Issue locate\n         LTR   R15,R15             IF r15 = 0 THEN\n         BZ    EXIT                  goto exit\n*\n*        Set up error code\n*\n         LA    R0,7                RESULT length=7\n         ST    R0,EVALBLOCK_EVLEN  RESULT length=7\n         MVC   EVALBLOCK_EVDATA(7),=CL7'UNKNOWN'  RESULT='UNKNOWN'\n*\n*        Clean up and exit\n*\nEXIT     FREEMAIN R,LV=DYNAML,A=(R11)\n         RETURN (14,12),RC=0       Return code(0)\n*\n*        Model catalog parm list\n*\nCAMLST1  CAMLST NAME,*-*,,*-*\n*\n*        Dynamic storage area\n*\nDYNAM    DSECT\nCAMLST2  CAMLST NAME,EVALBLOCK_EVDATA,,WORKAREA\nWORKAREA DS    32D\nDYNAML   EQU   *-DYNAM\n*\n*        Control Block Definitions\n*\n*        IKJTCB DSECT=YES\nTCB      DSECT\nTCBJPQ   EQU   *+44,4                  last CDE\nTCBJSTCB EQU   *+124,4                 JS TCB\n*        IHAPSA DSECT=YES\nPSA      DSECT\nPSATOLD  EQU   *+540,4                 own TCB\n         IHACDE\n         IRXEVALB\n         YREGS\n         END   FULLDSN\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR                IRXEVALB\n//         DD DSN=SYS1.MODGEN,DISP=SHR                IHACDE\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//LKED    EXEC PGM=IEWL,PARM=RENT\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=GILBERT.LOAD(FULLDSN),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//*\n//GO      EXEC PGM=IKJEFT01\n//STEPLIB  DD DSN=CBTTAPE.FILE183.LOAD,DISP=SHR       REXXTRY\n//         DD DSN=GILBERT.LOAD,DISP=SHR               FULLDSN\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\nREXXTRY\nSAY FULLDSN('GILBERT.CTC(0)')\nSAY FULLDSN('GILBERT.CTC(0)')\nSAY FULLDSN('GILBERT.CTC(0)')\n/*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETDIR": {"ttr": 11529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x82 \\x9f\\x00\\x96$?\\x12\\x14\\x00x\\x00\\x04\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf6\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1982-07-28T00:00:00", "modifydate": "1996-08-30T12:14:00", "lines": 120, "newlines": 4, "modlines": 0, "user": "CBT469"}, "text": "//GILBERTG JOB (ACCT#),GETDIR,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//ASMH EXEC PGM=IEV90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n*\n*    THE \"GETDIR\" MACRO ALLOWS YOU TO READ A PDS DIRECTORY\n*    SEQUENTIALLY, AS FOLLOWS:\n*\n*        IT WORKS IN \"LOCATE\" MODE; AFTER EACH INVOCATION, THE\n*        ADDRESS OF A DIRECTORY ENTRY (MEMBER NAME, TTR, ETC) IS\n*        RETURNED IN R1.\n*\n*        IT USES A BPAM DCB (DSORG=PO,MACRF=R), NOT A QSAM DCB\n*        (WHICH WOULD HAVE DSORG=PS).  THIS ALLOWS YOU TO READ THE\n*        DIRECTORY AND THE MEMBERS WITH THE SAME DCB.\n*\n*        R1 IS SET TO ZERO WHEN THE END OF THE DIRECTORY IS REACHED.\n*        THE \"EODAD\" KEY-WORD OF THE \"GETDIR\" MACRO MAY BE USED TO\n*        SPECIFY THE ADDRESS OF THE END-OF-DIRECTORY ROUTINE.\n*        THE EODAD KEY-WORD OF THE DCB IS ONLY USED AT END-OF-MEMBER.\n*\n*        THE \"GETDIR\" MACRO ONLY PROCESSES THE FIRST PDS IN A\n*        CONCATENATION, AND WILL NOT WORK WITH A PDSE.\n*\n         MACRO\n&NAME    GETDIR &DCB,&EODAD=\n&NAME    IHBINNRA &DCB\n         L     R15,=A(@GETDIR)         ADDR OF \"GETDIR\" RTNE\n         BALR  R14,R15                 GET A DIRECTORY ENTRY\n         AIF   (T'&EODAD EQ 'O').GEN\n         LTR   R1,R1                   END OF DIRECTORY?\n         BZ    &EODAD                  YES, GO AWAY\n.GEN     AIF   (D'GETDIR).MEND\n.**********************************************************************\n.*\n.*       GETDIR SUB-ROUTINE\n.*\n.**********************************************************************\n@GETDIR  CSECT\n         SAVE  (14,12),,'GETDIR 840510'\n         BALR  R2,0\n         USING *,R2\n         LR    R3,R1                   ADRESSE DU DCB\n         ST    R13,@GETDSAV+4\n         LA    R13,@GETDSAV\n         LA    R5,X'000100'            TT=00, R=1, N=0\n         ICM   R1,B'1111',@GETDR1      CURRENT POS IN BUFFER\n         BZ    @GETD22                 PICK UP PARM LIST OFFSET\n         LA    R14,X'1F'               MASQUE POUR \"AND\"\n         IC    R0,11(,R1)              \"C\" BYTE\n         NR    R14,R0                  NOMBRE DE HALFWORDS\n         LA    R14,12(R14,R14)         LONGUEUR DU POSTE DANS R14\n         LH    R15,@GETDBUF            LONGUEUR UTILISEE\n         LA    R15,@GETDBUF-1(R15)     ADRESSE DERNIER OCTET UTILISE\n         BXLE  R1,R14,@GETD24\n         AL    R5,@GETDR5              INCREMENTER LE NUMERO D'ENREG\n@GETD22  ST    R5,@GETDR5              TTRN DU BLOC SUIVANT\n         POINT (R3),@GETDR5            POINTER SUR LE BON BLOC\n         LH    R4,62(,R3)              SAUVER DCBBLKSI\n         MVI   62(R3),1                BLKSIZE=256\n         MVI   63(R3),0                BLKSIZE=256\n         READ  @GETDECB,SF,(R3),@GETDBUF,'S'\n         STH   R4,62(,R3)              RESTAURER DCBBLKSI\n         CHECK @GETDECB\n         LA    R1,@GETDBUF+2           1ER POSTE\n@GETD24  CLI   0(R1),X'FF'             FIN DE BLOC?\n         BNE   @GETD29                 NON, RENDRE L'ADRESSE\n         SLR   R1,R1                   FIN-DE-REPERTOIRE\n@GETD29  ST    R1,@GETDR1              GARDER L'ADRESSE\n         L     R13,4(,R13)\n         L     R14,12(,R13)            ADRESSE DE RETOUR\n         LM    R2,R12,28(R13)          R2-R3\n         BR    R14\n@GETDR1  DS    A(@GETDBUF+2)           POINTEUR COURANT DANS LE BUFFER\n@GETDR5  DS    F                       TTRN DU BLOC COURANT\n@GETDSAV DS    18F\n@GETDBUF DS    H,254X\n&SYSECT  CSECT\n.MEND    MEND\n**********************************************************************\n**********************************************************************\n********* TEST PROGRAM FOR THE 'GETDIR' MACRO ************************\n**********************************************************************\n**********************************************************************\nTESTPGM  START 0\n         BALR  R12,0\n         USING *,R12\n         OPEN  (SYSLIB,,SYSPRINT,OUTPUT)\n*LOOP\nGETD     GETDIR SYSLIB,EODAD=EOJ\n         MVC   WORK80(11),0(R1)         SAVE MEMBER NAME AND TTR\n         PUT   SYSPRINT,WORK80\n         FIND  SYSLIB,WORK80+8,C        FIND WITH TTR0\n         READ  DECB1,SF,SYSLIB,BUFF1    READ FIRST BLOCK\n         CHECK DECB1\n         L     R6,=A(BUFF1)\n         PUT   SYSPRINT,(R6)            WRITE FIRST LINE\n         B     GETD\n*ENDLOOP\nEOJ      SLR   R15,R15\n         SVC   3                        GOBACK\nWORK80   DS    XL80\nSYSPRINT DCB   DSORG=PS,DDNAME=SYSPRINT,MACRF=PM,RECFM=FB,LRECL=80\nSYSLIB   DCB   DSORG=PO,DDNAME=SYSLIB,MACRF=R,EODAD=EOJ\n         YREGS\nBUFF1    CSECT\n         DS    32760X\n         END\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//GO      EXEC PGM=LOADER,PARM=NOPRINT\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//SYSLIB   DD DSN=SYS1.PROCLIB,DISP=SHR\n//SYSPRINT DD SYSOUT=*,OUTLIM=666\n//ABNLTERM DD SYSOUT=*\n//ABNLDUMP DD DUMMY\n//SYSUDUMP DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETPUT31": {"ttr": 11532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x13?\\x00\\x96$?\\x12\\x15\\x00R\\x00\\x00\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf0\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-05-12T00:00:00", "modifydate": "1996-08-30T12:15:00", "lines": 82, "newlines": 0, "modlines": 0, "user": "CBT409"}, "text": "//GILBERTT JOB (ACCT#),GETPUT31,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//ASMH EXEC PGM=IEV90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n*\n*        ISSUE GET/PUT/PUTX WHILE RUNNING WITH AMODE31\n*        NO LONGER NECESSARY WITH DFSMS/MVS\n*\n         MACRO\n&NAME    GET31 &CB,&AREA,&EODAD=\n&NAME    IHBINNRA &CB,&AREA             LOAD R1, R0\n         SLR   15,15\n         ICM   15,B'0111',49(1)         LOAD GET/PUT ROUTINE ADDR\n         BASSM 14,15                    LINK TO GET/PUT ROUTINE\n         AL    14,=F'6'                 L'AL+L'BSM\n         BSM   0,14                     SWITCH BACK TO AMODE31\n         AIF   (T'&EODAD EQ 'O').MEND\n         CL    0,=F'6'                  END-OF-FILE?\n         BE    &EODAD                   YES, GO TO &EODAD\n         AIF   (D'EODAD31).MEND\nEODAD31  CSECT\nEODAD31  AMODE 31\n         LA    0,006                    GET INCREMENT IN R0\n         ALR   14,0                     ADD IT TO RETURN ADDRESS\n         BSM   0,14                     GOBACK TO R14+6\n&SYSECT  CSECT\n.MEND    MEND\n*----------------------------------------------------------------------\n         MACRO\n&NAME    PUT31 &CB,&AREA\n&NAME    IHBINNRA &CB,&AREA             LOAD R1, R0\n         SLR   15,15\n         ICM   15,B'0111',49(1)         LOAD GET/PUT ROUTINE ADDR\n         BASSM 14,15                    LINK TO GET/PUT ROUTINE\n         AL    14,=F'6'                 L'AL+L'BSM\n         BSM   0,14                     SWITCH BACK TO AMODE31\n.MEND    MEND\n*----------------------------------------------------------------------\n         MACRO\n&NAME    PUTX31 &CB,&AREA\n&NAME    IHBINNRA &CB,&AREA             LOAD R1, R0\n         L     15,48(,1)                LOAD GET/PUT ROUTINE ADDR\n         LA    14,4(,15)                OFFSET TO PUTX RTNE\n         BASSM 14,14                    LINK TO PUTX ROUTINE\n         AL    14,=F'6'                 L'AL+L'BSM\n         BSM   0,14                     SWITCH BACK TO AMODE31\n.MEND    MEND\n***********************************************************************\nGETPUT31 CSECT\nGETPUT31 AMODE 31\n         BALR  12,0\n         USING *,12\n         OPEN  (IN,,PUNCH,OUTPUT)\n*\nGET1     GET31 IN,EODAD=EOJ\n         LR    0,1                     PASS RECORD ADDRESS\n***      PUT31 PUNCH,(0)\n         PUTX31 PUNCH,IN               USE EXCHANGE BUFFERING\n         B     GET1\n*\nEOJ      CLOSE (IN,,PUNCH)\n         FREEPOOL IN\n         FREEPOOL PUNCH\n         SLR   15,15\n         BSM   15,0                    IF AMODE=31, THEN R15=80000000\n         SRL   15,28                   IF AMODE=31, THEN R15=00000008\n         SVC   3                       GOBACK WITH RETURN CODE IN R15\nIN       DCB   DSORG=PS,MACRF=GL,DDNAME=SYSIN,EODAD=EODAD31\nPUNCH    DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPUNCH,RECFM=FB,LRECL=80\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,4)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//GO      EXEC PGM=LOADER,PARM=NOPRINT\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//SYSPRINT DD SYSOUT=*\n//SYSPUNCH DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n444444444444444444444444\n88888888888888888888888888888888\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GSFLKED": {"ttr": 11535, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x82\\x01\\x9f\\x00\\x84&/\\x16@\\x00\\x91\\x00%\\x00\\x00\\xc3\\xc2\\xe3\\xf3\\xf3\\xf8@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1982-01-19T00:00:00", "modifydate": "1984-09-18T16:40:00", "lines": 145, "newlines": 37, "modlines": 0, "user": "CBT338"}, "text": "//GILBERTL JOB (ACCT#),GSFLKED,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//ASMH EXEC PGM=IEV90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n*    THIS PROGRAM IS A FRONT-END TO THE LINKAGE-EDITOR WHICH          *\n*    PROVIDES THE FOLLOWING FACILITIES:                               *\n*                                                                     *\n*    1. IF THERE IS AN //INCLUDE DD THAT POINTS TO AN EXISTING        *\n*       PDS MEMBER, THEN THIS MEMBER IS APPENDED TO THE SYSLIN FILE.  *\n*                                                                     *\n*    2. IF THERE IS A //COMPRESS DD IN THE STEP AND THE LINK-EDIT     *\n*       ABENDS WITH SD37-04, THEN IEBCOPY IS INVOKED TO COMPRESS      *\n*       THE SYSLMOD DATA SET AFTER WHICH THE LINK-EDIT IS INVOKED     *\n*       AGAIN.  THE COMPRESS DD MUST CONTAIN THE IEBCOPY SYSIN,       *\n*       AS FOLLOWS:                                                   *\n*                                                                     *\n*            //COMPRESS DD *                                          *\n*              COPY I=SYSLMOD,O=SYSLMOD                               *\n*                                                                     *\n*    3. IF THERE IS AN //RC0 DD DUMMY CARD IN THE STEP'S JCL,         *\n*       THE RETURN CODE OF THE STEP WILL BE RESET TO ZERO.            *\n*                                                                     *\n***********************************************************************\nGSFLKED  CSECT\n         SAVE  (14,12),,'GSF UTILITIES - GSFLKED'\n         BALR  R12,0\n         USING *,R12\n         LR    R14,R13\n         LA    R13,=CL72'APPEL LINK-EDIT AVEC CODE RETOUR A ZERO'\n         ST    R14,4(,R13)\n         ST    R13,8(,R14)\n         ST    R1,@PARM\n*\n*        TEST FOR THE //INCLUDE DD CARD.\n*        IF PRESENT, TEST FOR AN EXISTING MEMBER.\n*          IF MEMBER EXISTS, APPEND IT TO SYSLIN DD\n*\n         RDJFCB MF=(E,OPLPO)             SI PRESENTE,\n         LTR   R15,R15                      CARTE DD 'INCLUDE'\n         BNZ   LINK0\n         OPEN  MF=(E,OPLPO)               CHERCHER SI LE\n         MVC   BLDLIST+4(8),EXL1+4+44      MEMBRE EST\n         BLDL  INPO,BLDLIST                 PRESENT\n         LR    R2,R15\n         CLOSE MF=(E,OPLPO)\n         LTR   R2,R2                       SI PRESENT,\n         BNZ   LINK0                      LIRE SON CONTENU\n         OPEN  MF=(E,OPLPS)                ET LE\nGETPS    GET   INCLUDE                      REECRIRE\n         PUTX  SYSLIN,INCLUDE                 SUR 'SYSLIN'\n         B     GETPS\nFINPS    CLOSE MF=(E,OPLPS)\n         FREEPOOL INCLUDE\n         FREEPOOL SYSLIN\n*\n*        INVOKE THE LINKAGE-EDITOR\n*\n*          1. AS A SUB-TASK IF //COMPRESS DD PRESENT\n*\n*          2. VIA \"LINK\" IF //COMPRESS DD  IS NOT PRESENT\n*\nLINK0    DEVTYPE =C'COMPRESS',16(,13)    COMPRESS PREVU ?\n         LTR   R15,R15                      SI NON,\n         BNZ   LINK8                       PAS DE 'ATTACH'\n         L     R1,@PARM                   EXEC DU LKED\n         ATTACH EP=IEWL,ECB=ECB1          COMME 'SUBTASK'\n         ST    R1,ECB1+4                    POUR PIEGER\n         WAIT  ECB=ECB1                     LES ABENDS\n         DETACH ECB1+4\n         L     R1,ECB1                   SI LE CODE-RETOUR\n         N     R1,=X'00FFF000'             EST ZERO,\n         BZ    RETURN                       RETURN\n         CL    R1,=X'00D37000'           SI ABEND\n         BNE   ABENDR1                    CODE 'SD37'\n*\n*        COMPRESS SYSLMOD PDS\n*\n         MVC   INPO+40(8),=C'SYSLMOD '     PROTECTION\n         RDJFCB MF=(E,OPLPO)                DU PDS\n         ENQ   MF=(E,@ENQL1)                 ET COMPRESS\n         LINK  EP=IEBCOPY,PARAM=(PARM0,COPYDD),VL=1\n         DEQ   MF=(E,@ENQL1)\n*\nLINK8    L     R1,@PARM\n         LINK  EP=IEWL                  EXECUTION DU LINK-EDIT\n         ST    R15,ECB1                 RETURN CODE\n*\nRETURN   DEVTYPE =CL8'RC0',16(,R13)\n         LTR   R15,R15                  '//RC0   DD DUMMY'\n         BNZ   RETURN2\n         XC    ECB1,ECB1                IF //RC0 PRESENT, RC=0\n*\nRETURN2  L     R15,ECB1                 RETURN CODE\n         L     R13,4(,R13)\n         RETURN (14,12),RC=(15)\nABENDR1  ABEND (1)\n*\n         PRINT NOGEN\nINPO     DCB   DSORG=PO,MACRF=E,DDNAME=INCLUDE,EXLST=EXL1\nINCLUDE  DCB   DSORG=PS,MACRF=GL,DDNAME=INCLUDE,EODAD=FINPS\nSYSLIN   DCB   DSORG=PS,MACRF=PM,DDNAME=SYSLIN,LRECL=80,RECFM=FB\nOPLPO    OPEN  MF=L,INPO\nOPLPS    OPEN  MF=L,(INCLUDE,,SYSLIN,EXTEND)\nEXL1     DC    A(X'87000004'+*),CL176' '\nBLDLIST  DC    Y(1,14),CL14' '\nPARM0    DC    Y(0)               PARM VIDE\nCOPYDD   DC    Y(8*11)\n         DC    XL8'00'            1   UNUSED\n         DC    XL8'00'            2   UNUSED\n         DC    XL8'00'            3   UNUSED\n         DC    XL8'00'            4   UNUSED\nCOPYDDK  DC    CL8'COMPRESS'      5   SYSIN\n         DC    XL8'00'            6   UNUSED\n         DC    XL8'00'            7   UNUSED\n         DC    XL8'00'            8   UNUSED\n         DC    XL8'00'            9   UNUSED\n         DC    CL8'SYSUT1  '     10   SYSUT3\n         DC    XL8'00'           11   UNUSED\nQLKED    DC    C'SYSIEWLP'\n@ENQL1   ENQ   (QLKED,EXL1+4,E,44,SYSTEMS, LKED / SHARED               X\n               QLKED,EXL1+4,E,44,SYSTEM), LKED / NON SHARED            X\n               MF=L\n@PARM    DS    A\nECB1     DS    2A\n         YREGS\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//LKED    EXEC PGM=HEWL,PARM='MAP,REUS,AC=1'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=GILBERT.LOAD(GSFLKED),DISP=SHR\n//*\n//GO      EXEC PGM=GSFLKED,PARM=(LIST,XREF)\n//STEPLIB  DD DSN=GILBERT.LOAD,DISP=SHR\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD UNIT=VIO,DISP=(,PASS),SPACE=(TRK,(1,,1))\n//SYSPRINT DD SYSOUT=*\n//COMPRESS DD *\n COPY INDD=SYSLMOD,OUTDD=SYSLMOD,LIST=NO\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HANDBOOK": {"ttr": 11780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x011\\x00\\x00\\x00\\x884\\x7f\\x01\\x04\\x04\\x0f\\x14 \\x01\\xb0\\x00,\\x01\\x8a\\xc3\\xc2\\xe3\\xf4\\xf6\\xf5@@@@'", "ispf": {"version": "01.49", "flags": 0, "createdate": "1988-12-12T00:00:00", "modifydate": "2004-02-09T14:20:00", "lines": 432, "newlines": 44, "modlines": 394, "user": "CBT465"}, "text": "//GILBERTH JOB (ACCT#),HANDBOOK,\n// NOTIFY=&SYSUID,REGION=5M,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//*\n//*    THIS JOB ASSEMBLES SOME MVS CONTROL BLOCKS AND STORES\n//*    THE OUTPUT INTO A PDS FOR ON-LINE VIEWING.\n//*\n//*    TO SAVE DASD SPACE, THE ISPF/PDF'S LMCOPY SERVICE IS INVOKED\n//*    TO PACK EACH MEMBER.\n//*\n//UPDTE   EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSPRINT DD SYSOUT=*\n./  ADD NAME=SPFPACK      <=== MAIN MACRO\nPROC 1 MBR\nCONTROL LIST CONLIST NOFLUSH\nISPEXEC SELECT PGM(IEV90) -\n    PARM(NOESD,NORLD,NOOBJECT,NODECK,LINECOUNT(120),TERM)\nIF &LASTCC > 0 THEN EXIT CODE(&LASTCC)\nISPEXEC LMINIT DATAID(ID1) DDNAME(SYSPRINT) ENQ(SHR)\nIF &LASTCC > 0 THEN GOTO ERROR\nISPEXEC LMINIT DATAID(ID2) DDNAME(PERM) ENQ(SHRW)\nIF &LASTCC > 0 THEN GOTO ERROR\nISPEXEC LMCOPY FROMID(&ID1) TODATAID(&ID2) TOMEM(&MBR) -\n               REPLACE PACK TRUNC\nIF &LASTCC > 0 THEN GOTO ERROR\nISPEXEC LMFREE DATAID(&ID1)\nIF &LASTCC > 0 THEN GOTO ERROR\nISPEXEC LMFREE DATAID(&ID2)\nIF &LASTCC > 0 THEN GOTO ERROR\nEXIT CODE(0)\nERROR: +\n  ISPEXEC GETMSG MSG(&ZERRMSG) LONGMSG(XX)\n  WRITE &XX\n  EXIT CODE(12)\n//SYSUT2   DD UNIT=VIO,SPACE=(80,(1,,1)),DISP=(,PASS),\n//            RECFM=FB,LRECL=80,BLKSIZE=800\n//TEMPF    DD UNIT=VIO,SPACE=(CYL,10),BLKSIZE=12947,DISP=(,PASS)\n//*\n//ASMMAC PROC MBR=\n//TMP     EXEC PGM=IKJEFT01,PARM='ISPSTART CMD(%SPFPACK &MBR)'\n//SYSPROC  DD DSN=*.UPDTE.SYSUT2,DISP=(OLD,PASS)\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//*\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,20)\n//SYSTERM  DD SYSOUT=*\n//SYSPRINT DD DSN=*.UPDTE.TEMPF,DISP=(OLD,PASS)\n//*\n//PERM     DD DSN=GILBERT.HANDBOOK,\n// DISP=(MOD,CATLG,DELETE),\n// UNIT=SYSALLDA,\n// SPACE=(TRK,(100,5,6),RLSE),\n// RECFM=FBM,LRECL=121,DSORG=PO            SDB\n//*\n//ISPPROF  DD UNIT=VIO,SPACE=(800,(1,,1)),\n//            RECFM=FB,LRECL=80,BLKSIZE=800\n//ISPPLIB  DD UNIT=VIO,SPACE=(800,(1,,1)),DCB=*.ISPPROF\n//ISPMLIB  DD DSN=ISP.SISPMENU,DISP=SHR\n//ISPSLIB  DD UNIT=VIO,SPACE=(800,(1,,1)),DCB=*.ISPPROF\n//ISPTLIB  DD DSN=ISP.SISPTENU,DISP=SHR\n//        PEND\n//*\n//ACB    EXEC ASMMAC,MBR=ACB\n         IFGACB\n         END\n//ACEE   EXEC ASMMAC,MBR=ACEE\n         IHAACEE\n         END\n//AMVT   EXEC ASMMAC,MBR=ASMVT\n         ILRASMVT\n         END\n//ASCB   EXEC ASMMAC,MBR=ASCB\n         IHAASCB DSECT=YES,LIST=YES\n         END\n//ASVT   EXEC ASMMAC,MBR=ASVT\n         IHAASVT DSECT=YES,LIST=YES\n         END\n//ASSB   EXEC ASMMAC,MBR=ASSB\n         IHAASSB LIST=YES\n         END\n//ASXB   EXEC ASMMAC,MBR=ASXB\n         IHAASXB DSECT=YES,LIST=YES\n         END\n//ATTACH EXEC ASMMAC,MBR=ATTACH\n         IEZATTCH LIST=YES\n         END\n//BASEA  EXEC ASMMAC,MBR=BASEA\n         IEEBASEA\n         END\n//CDE    EXEC ASMMAC,MBR=CDE\n         IHACDE\n         END\n//CSCB   EXEC ASMMAC,MBR=CSCB\n         IEECHAIN\n         END\n//CSD    EXEC ASMMAC,MBR=CSD\n         IHACSD DSECT=YES\n         END\n//CTXT   EXEC ASMMAC,MBR=CTXT\n         IEZVX100 DSECT=YES\n         END\n//CVT    EXEC ASMMAC,MBR=CVT\n         CVT DSECT=YES,LIST=YES,PREFIX=YES\n         END\n//DCB    EXEC ASMMAC,MBR=DCB\n         DCBD  DSORG=PS\n         END\n//DCBDA  EXEC ASMMAC,MBR=DCBDA\n         DCBD  DSORG=DA\n         END\n//DCBE   EXEC ASMMAC,MBR=DCBE\n         IHADCBE\n         END\n//DCE    EXEC ASMMAC,MBR=DCE\n         IECDDCE\n         END\n//DECB   EXEC ASMMAC,MBR=DECB\n         IHADECB DSECT=YES\n         END\n//DES    EXEC ASMMAC,MBR=DES         DESERV\n         IGWDES\n         END\n//DFA    EXEC ASMMAC,MBR=DFA\n         IHADFA DSECT=YES\n         END\n//DSAB   EXEC ASMMAC,MBR=DSAB\n         IHADSAB\n         END\n//DSCB1  EXEC ASMMAC,MBR=DSCB1\n         IECSDSL1 1\n         END\n//DSCB4  EXEC ASMMAC,MBR=DSCB4\n         DS    44X'04'\n         IECSDSL1 4\n         END\n//DYNALL EXEC ASMMAC,MBR=DYNALLOC\n*STATUS      OLD=01   MOD=02    NEW=04    SHR=08\n*DISP    UNCATLG=01 CATLG=02 DELETE=04   KEEP=08\n*SPACE                ALX=02   MXIG=04 CONTIG=08\n*LABEL        NL=01    SL=02    NSL=04            SUL=0A\n*             BLP=10  LTM=21     AL=40    AUL=48\n         IEFZB4D0\n         IEFZB4D2\n         END\n//DEB    EXEC ASMMAC,MBR=DEB\n         IEZDEB LIST=YES\n         END\n//DVA    EXEC ASMMAC,MBR=DVA\n         IHADVA DSECT=YES\n         END\n//DVCT   EXEC ASMMAC,MBR=DVCT\n         IHADVCT DSECT=YES\n         END\n//ECT    EXEC ASMMAC,MBR=ECT\n         IKJECT\n         END\n//ECVT   EXEC ASMMAC,MBR=ECVT\n         IHAECVT LIST=YES\n         END\n//EPIE   EXEC ASMMAC,MBR=EPIE\n         IHAEPIE\n         END\n//GDA    EXEC ASMMAC,MBR=GDA\n         IHAGDA\n         END\n//IOB    EXEC ASMMAC,MBR=IOB\n         IEZIOB DSECT=YES\n         END\n//IOCOM  EXEC ASMMAC,MBR=IOCOM\n         IECDIOCM\n         END\n//IPA    EXEC ASMMAC,MBR=IPA\n         IHAIPA\n         END\n//JCT    EXEC ASMMAC,MBR=JCT\nJCT      DSECT\n         IEFAJCTB\n         END\n//JCTX   EXEC ASMMAC,MBR=JCTX\nJCTX     DSECT\n         IEFJCTX\n         END\n//JESCT  EXEC ASMMAC,MBR=JESCT\n         IEFJESCT\n         END\n//JFCB   EXEC ASMMAC,MBR=JFCB\nJFCB     DSECT\n         IEFJFCBN LIST=YES\n         END\n//JMR    EXEC ASMMAC,MBR=JMR\n         IEFJMR\n         END\n//JSAB   EXEC ASMMAC,MBR=JSAB\n         IAZJSAB LIST=YES\n         END\n//JSCB   EXEC ASMMAC,MBR=JSCB\n         IEZJSCB\n         END\n//JSCVT  EXEC ASMMAC,MBR=JSCVT\n         IEFJSCVT\n         END\n//LCCA   EXEC ASMMAC,MBR=LCCA\n         IHALCCA DSECT=YES\n         END\n//LCT    EXEC ASMMAC,MBR=LCT\n         IEFALLCT\n         END\n//LDA    EXEC ASMMAC,MBR=LDA\n         IHALDA\n         END\n//LLE    EXEC ASMMAC,MBR=LLE\n         IHALLE\n         END\n//LPDE   EXEC ASMMAC,MBR=LPDE\n         IHALPDE\n         END\n//LWA    EXEC ASMMAC,MBR=LWA\n         IKJEFLWA\n         END\n//OCE    EXEC ASMMAC,MBR=OCE\n         IECDSECS\n         IECDSECT\n         END\n//ORE    EXEC ASMMAC,MBR=ORE\n         IHAORE DSECT=YES\n         END\n//OUCB   EXEC ASMMAC,MBR=OUCB\n         IRAOUCB DSECT=YES\n         END\n//OUXB   EXEC ASMMAC,MBR=OUXB\n         IHAOUXB DSECT=YES\n         IEZBITS\n         END\n//PCCA   EXEC ASMMAC,MBR=PCCA\n         IHAPCCA DSECT=YES\n         END\n//PDS2   EXEC ASMMAC,MBR=PDS2\n         IHAPDS DSECT=YES,PDSBLDL=YES\n         END\n//PMAR   EXEC ASMMAC,MBR=PMAR\n         IEWPMAR\n         END\n//PSA    EXEC ASMMAC,MBR=PSA\n         IHAPSA DSECT=YES,LIST=YES\n         END\n//PSCB   EXEC ASMMAC,MBR=PSCB\n         IKJPSCB\n         END\n//RAX    EXEC ASMMAC,MBR=RAX\n         IARRAX                 RSM ADDR SPC BLOCK EXTENSION\n         END\n//RCE    EXEC ASMMAC,MBR=RCE\n         IARRCE                 RSM CONTROL AND ENUMERATION AREA\n         END\n//RCVT   EXEC ASMMAC,MBR=RCVT\n         ICHPRCVT               RACF CVT\n         END\n//RD     EXEC ASMMAC,MBR=RD\n         IHARD                  REGION DESCRIPTOR\n         END\n//RMCT   EXEC ASMMAC,MBR=RMCT\n         IRARMCT DSECT=YES      RESOURCE MANAGET CONTROL TABLE\n         END\n*/SAMB   EXEC ASMMAC,MBR=SAMB\n*        IGGSAMB DSECT=YES\n*        END\n//RB     EXEC ASMMAC,MBR=RB\n         IKJRB DSECT=YES,LIST=YES\n         END\n//REXX   EXEC ASMMAC,MBR=REXX\n         IRXARGTB\n         IRXCMPTB ,            COMPILER TABLE TSO/E 2.3.1\n         IRXDSIB\n         IRXEFPL\n         IRXENVB               ENVIRONMENT BLOCK\n         IRXENVT               ENVIRONMENT TABLE (IRXANCHR)\n         IRXEVALB\n         IRXEXECB\n         IRXEXTE\n         IRXFPDIR\n         IRXINSTB\n         IRXMODNT\n         IRXPACKT\n         IRXPARMB\n         IRXSHVB\n         IRXSUBCT\n         IRXWORKB\n         END\n//RIB    EXEC ASMMAC,MBR=RIB\n         ISGRIB\n         END\n//RPL    EXEC ASMMAC,MBR=RPL\n         IFGRPL\n         IDARMRCD ,                RECORD MGMT ERROR CODES\n         END\n//SCA    EXEC ASMMAC,MBR=SCA\n         IHASCA\n         END\n//SCB    EXEC ASMMAC,MBR=SCB\n         IHASCB DSECT=YES\n         END\n//SCCB   EXEC ASMMAC,MBR=SCCB\n         IHASCCB\n         END\n//SCT    EXEC ASMMAC,MBR=SCT\nSCT      DSECT\n         IEFASCTB\n         END\n//SCTX   EXEC ASMMAC,MBR=SCTX\n         IEFSCTX DSECT=YES\n         END\n//SCVT   EXEC ASMMAC,MBR=SCVT\n         IHASCVT DSECT=YES,LIST=YES\n         END\n//SDWA   EXEC ASMMAC,MBR=SDWA\n         IHASDWA DSECT=YES,VRAMAP=YES\n         END\n//SIOT   EXEC ASMMAC,MBR=SIOT\nSIOT     DSECT\n         IEFASIOT\n         END\n//SIOTX  EXEC ASMMAC,MBR=SIOTX\n         IEFSIOTX\n         END\n//SMCA   EXEC ASMMAC,MBR=SMCA\n         IEESMCA\n         END\n//SMDE   EXEC ASMMAC,MBR=SMDE        DESERV\n         IGWSMDE\n         END\n//SNAP   EXEC ASMMAC,MBR=SNAP\n         IHASNAP DSECT=YES\n         END\n//SPIE   EXEC ASMMAC,MBR=SPIE\n         IHASCA                 SPIE/ESPIE CONTROL AREA\n         IHAEPIE                EXTENDED PROGRAM INTERRUPT ELEMENT\n         IHAPIE                 PROGRAM INTERRUPT ELEMENT\n         IHAPICA                PROGRAM INTERRUPTION CONTROL AREA\n         END\n//SPQE   EXEC ASMMAC,MBR=SPQE\n         IHASPQE                SP Q ELEMENT\n         IHAFBQE                FREE BLOCK\n         IHASPQA                SP Q DESCRIPTOR\n         IHADQE                 DESCRIPTOR Q ELEMENT\n         IHAFQE                 FREE Q ELEMENT\n         IHASPT                 CSA\n         END\n//SRB    EXEC ASMMAC,MBR=SRB\n         IHASRB LIST=YES\n         END\n//SSCT   EXEC ASMMAC,MBR=SSCT\n         IEFJSCVT\n         END\n//SSOB   EXEC ASMMAC,MBR=SSOB\n         IEFJSSOB (AL,SO)\n         END\n//SSIB   EXEC ASMMAC,MBR=SSIB\n         IEFJSSIB\n         END\n//SSSA   EXEC ASMMAC,MBR=SSSA\n         IEFSSSA\n         END\n//SSVT   EXEC ASMMAC,MBR=SSVT\n         IEFJSSVT\n         END\n//STCB   EXEC ASMMAC,MBR=STCB\n         IHASTCB LIST=YES\n         END\n//SVT    EXEC ASMMAC,MBR=SVT\n         IHASVT LIST=YES\n         END\n//SWB    EXEC ASMMAC,MBR=SWB\n         IEFSWB\n         END\n//TAXE   EXEC ASMMAC,MBR=TAXE\n         IKJTAXE\n         END\n//TCAS   EXEC ASMMAC,MBR=TCAS\n         IKTTCAST DSECT=YES\n         END\n//TCB    EXEC ASMMAC,MBR=TCB\n         IKJTCB DSECT=YES,LIST=YES\n         END\n//TCT    EXEC ASMMAC,MBR=TCT\n         IEFTCT\n         END\n//TIOT   EXEC ASMMAC,MBR=TIOT\nTIOT     DSECT\n         IEFTIOT1\n         END\n//TMPWA  EXEC ASMMAC,MBR=TMPWA\n         IKJTMPWA\n         END\n//TPC    EXEC ASMMAC,MBR=TPC\n         IEAVVTPC\n         END\n//TQE    EXEC ASMMAC,MBR=TQE\n         IHATQE\n         END\n//TSB    EXEC ASMMAC,MBR=TSB\n         IKJTSB LIST=YES,EXT=YES\n         END\n//TSVT   EXEC ASMMAC,MBR=TSVT\n         IKJTSVT\n         END\n//UCB    EXEC ASMMAC,MBR=UCB\n**       IEFUCBOB LIST=YES,PREFIX=YES,SSMD=YES\n         IEFUCBOB LIST=YES,PREFIX=YES\n         END\n//UCM    EXEC ASMMAC,MBR=UCM\n         IEECUCM LIST=YES,DSECT=YES\n         END\n//UPT    EXEC ASMMAC,MBR=UPT\n         IKJUPT\n         END\n//WQE    EXEC ASMMAC,MBR=WQE\n         IHAWQE\n         END\n//SGD    EXEC ASMMAC,MBR=IGDSGD\n         IGDSGD\n         END\n//VLD    EXEC ASMMAC,MBR=IGDVLD\n         IGDVLD\n         END\n//XCF    EXEC ASMMAC,MBR=XCF\n         IXCYQUAA DSECT=YES            XCF-ANSWER AREA\n         END\n//XL     EXEC ASMMAC,MBR=XL\n         IHAXTLST\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEC149I": {"ttr": 11788, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//GILBERTI JOB (ACCT#),IEC149I,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = IEC149I                                               *\n*                                                                     *\n* DESCRIPTIVE NAME = MPF exit for IEC149I 813-04 message              *\n*                                                                     *\n* STATUS = R101                                                       *\n*                                                                     *\n* FUNCTION = This MPF exit is invoked for the following messages:     *\n*                                                                     *\n*              1. IEC149I 813-04,IFG0195H,jobname,stepname,ddname ... *\n*              2. IEC023I 237-08,IFG0553F,jobname,stepname,ddname ... *\n*                                                                     *\n*            These messages are issued when OPEN or EOV detect        *\n*            that the dsname in the header label is not equal to      *\n*            the dsname in the JFCB.                                  *\n*                                                                     *\n*            This exit issues a WTO to display the contents of the    *\n*            HDR1 label and help the programmer debug the problem     *\n*            and correct the JCL.                                     *\n*                                                                     *\n*            The message has the following format:                    *\n*                                                                     *\n*            **HDR1,'17-char label',fileseq,volseq,credt,expdt,fsec   *\n*                                                                     *\n*                    17-char label      data set name                 *\n*                    fileseq            file sequence number          *\n*                    volseq             volume sequence number        *\n*                    credt              creation date (julian)        *\n*                    expdt              expiration date (julian)      *\n*                    fsec               file security indicator       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*    DEPENDENCIES: MVS/ESA, OS/390                                    *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (CSECT TYPE)                               *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 1K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE ANY, AMODE 31,                   *\n*                 SUPERVISOR STATE, KEY 0                             *\n*                                                                     *\n* OPERATION = See documentation for IEAVMXIT                          *\n*                                                                     *\n* INSTALLATION = See Below                                            *\n*                                                                     *\n*    1. Link-edit IEC149I into an APF-authorized link-list            *\n*       library and refresh LLA.                                      *\n*                                                                     *\n*    2. Add the following lines to the active MPFLSTnn                *\n*       member in SYS1.PARMLIB:                                       *\n*                                                                     *\n*         IEC149I,SUP(NO),RETAIN(NO),USEREXIT(IEC149I)                *\n*         IEC023I,SUP(NO),RETAIN(NO),USEREXIT(IEC149I)                *\n*                                                                     *\n*    3. Issue the SET MPF=nn command to activate IEC149I.             *\n*                                                                     *\n* PARAMETERS = NONE                                                   *\n*                                                                     *\n*    IEC149I retrieves the address of the OPEN/CLOSE/EOV              *\n*    work area from the R4 slot of the current SVRB.                  *\n*                                                                     *\n* SECURITY = See Below                                                *\n*                                                                     *\n*    The author considers that this MPF exit does NOT introduce       *\n*    a breach into the integrity of the MVS system, as the            *\n*    information it reveals is already available to the               *\n*    DCB ABEND exit of an unauthorised assembler program.             *\n*                                                                     *\n* RETURN-CODES = NONE                                                 *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n* 100 Initial release                                                 *\n* 101 Replace STRING macro with MVC instructions                      *\n*                                                                     *\n&REL     SETC  '101'                                                  *\n***********************************************************************\nIEC149I  CSECT\nIEC149I  RMODE ANY                     AMODE(31),RMODE(ANY)\n         DC    C'GSF UTILITIES - IEC149I R101'\nBEGIN    BAKR  R14,0\n         SLR   R4,R4                   prevent recursion\n         LR    R5,R15                  BASE REG\n         USING BEGIN,R5\n         L     R6,0(,R1)               A(CTXT)\n         USING CTXT,R6\n         L     R7,CTXTTXPJ             TEXT MAJOR POINTER\n         USING CTXTATTR,R7\n*\n*        Retrieve the address of the O/C/E work area\n*\n         L     R8,X'21C'(,0)           PSATOLD\n         L     R8,0(,R8)               TCBRBP (WTO's SVRB)\n         USING RBBASIC,R8\n         L     R9,RBGRS4               R4 in OPEN is O/C/E area\n         USING FORCORE,R9\n         CLC   =C'HDR1',FL1AREA        am I lost?\n         BNE   EXIT                    yes, quit\n*\n*        Issue WTO to display the IEC149I message\n*\n         L     R1,RBGRS1               get R1 (WTO parm list)\n         WTO   MF=(E,(1))              re-issue WTO\n*\n*        now move the contents of the HDR1 label into the message text\n*\n         MVC   CTXTTMSG+00(8),=C'**HDR1,'''\n         MVC   CTXTTMSG+08(17),FL1ID   17-char label\n         MVI   CTXTTMSG+25,C''''       '\n         MVI   CTXTTMSG+26,C','        ,\n         MVC   CTXTTMSG+27(4),FL1FILSQ file seq no\n         MVI   CTXTTMSG+31,C','        ,\n         MVC   CTXTTMSG+32(4),FL1VOLSQ vol seq no\n         MVI   CTXTTMSG+36,C','        ,\n         MVC   CTXTTMSG+37(6),FL1CREDT creation date YYDDD\n         MVI   CTXTTMSG+43,C','        ,\n         MVC   CTXTTMSG+44(6),FL1EXPDT expiration date YYDDD\n         MVI   CTXTTMSG+50,C','        ,\n         MVC   CTXTTMSG+51(1),FL1FSEC  file security indicator\n         MVI   CTXTTLEN+1,52           adjust length\n*\n         OI    CTXTRFB1,CTXTRCMT       CHANGE THE MESSAGE TEXT\n         OI    CTXTCOLR,CTXTWHIT       COLOR=WHITE\n         OI    CTXTERF1,CTXTEMCO       CHANGE THE COLOR\n*\nEXIT     PR                            RETURN TO WTO SVC\n*\n         PRINT NOGEN\n         IEZVX100 DSECT=YES            CTXT\n         IKJRB DSECT=YES               SVRB\nFORCORE  DSECT                         O/C/E WORK AREA\n         IECDSECT IOB=NO               O/C/E WORK AREA\n         YREGS\n         END   BEGIN\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//LKED    EXEC PGM=IEWL,PARM='MAP,RENT'\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSPRINT DD SYSOUT=*\n//SYSLMOD  DD DSN=USER.LINKLIB(IEC149I),DISP=SHR\n\n\nSample test job:\n\n    //GILBERTJ JOB (ACCT#),IEC149J,\n    // NOTIFY=&SYSUID,\n    // CLASS=A,MSGCLASS=H\n    //*\n    //* TEST JOB FOR THE IEC149I EXIT\n    //*\n    //TEST149 EXEC PGM=IDCAMS\n    //TAPE1    DD UNIT=3400-6,VOL=SER=123456\n    //TAPE2    DD UNIT=3400-6,VOL=SER=123456,DSN=FILE0001,\n    // RECFM=U,BLKSIZE=32760\n    //         DD UNIT=3400-6,VOL=SER=123456\n    //DUMMY    DD DUMMY,RECFM=U,BLKSIZE=32760\n    //SYSPRINT DD SYSOUT=*\n    //SYSUDUMP DD SYSOUT=*\n     REPRO IFILE(TAPE1) OFILE(DUMMY)          /* 813-04 */\n     REPRO IFILE(TAPE2) OFILE(DUMMY)          /* 237-08 */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IGX00GSF": {"ttr": 12036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x02\\x00\\x00\\x00\\x84%\\x0f\\x01\\x03\\x18\\x9f\\x103\\x00\\xe6\\x00L\\x00\\x1a\\xc3\\xc2\\xe3\\xf4\\xf6\\xf2@@@@'", "ispf": {"version": "02.02", "flags": 0, "createdate": "1984-09-06T00:00:00", "modifydate": "2003-07-08T10:33:00", "lines": 230, "newlines": 76, "modlines": 26, "user": "CBT462"}, "text": "//GILBERTG JOB (ACCT#),IGX00GSF,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(0,NE)\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = IGX00GSF                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = Authorization SVC routine for ShowMVS and STEPLIB*\n*                                                                     *\n* STATUS = R202                                                       *\n*                                                                     *\n* FUNCTION = This extended SVC routine (ESR) allows an un-authorized  *\n*            program to switch to MODE=SUP.  Only programs that have  *\n*            been registered and meet security requirements will      *\n*            successfully be switched to MODE=SUP.                    *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*    DEPENDENCIES: MVS/XA, MVS/ESA, OS/390, z/OS                      *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (CSECT TYPE)                               *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 1K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE ANY, AMODE 31,                   *\n*                 PROBLEM STATE, KEY 8                                *\n*                 APF AUTHORIZATION: NONE                             *\n*                                                                     *\n* OPERATION = SEE BELOW                                               *\n*                                                                     *\n*   IGX00GSF checks that its caller is registered and meets           *\n*   security requirements.  If all of the tests are successful,       *\n*   IGX00GSF sets the caller's PSW to supervisor mode.                *\n*                                                                     *\n* INSTALLATION = SEE BELOW                                            *\n*                                                                     *\n*   IGX00GSF must be installed in SYS1.LPALIB under the name          *\n*   IGX00nnn where nnn is a number between 000 and the maximum        *\n*   allowed for a type=3 ESR, which generally is 255.                 *\n*   Of course, the number chosen must not conflict with any other     *\n*   type-3 ESR in use on the system, keeping in mind that some        *\n*   software products dynamically update the ESR table for their      *\n*   own needs.  ShowMVS displays active and inactive ESR entries      *\n*   and can be used to determine which numbers are available.         *\n*                                                                     *\n*   Since the ESR entry number is not fixed, programs such as         *\n*   ShowMVS and STEPLIB that invoke it must determine the entry       *\n*   number by scanning all active entries in the type-3 ESR table     *\n*   for the proper signature.                                         *\n*                                                                     *\n* PARAMETERS = NONE                                                   *\n*                                                                     *\n* RETURN-CODES = SEE BELOW                                            *\n*                                                                     *\n*          0                    OK                                    *\n*          8                    Caller not running under a PRB        *\n*         12                    Unknown caller                        *\n*         16                    Caller not from APF library           *\n*         20                    Caller's prefix invalid               *\n*         24                    Caller issued ESTAE                   *\n*         28                    Caller invoked via XCTL               *\n*         32                    Caller not RENT                       *\n*         36                    SVC 109 not within caller's module    *\n*         40                    Caller in AMODE=64                    *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n*  $200 Initial release for ShowMVS R618                              *\n*  $201 Fix invalid CDREN check                                       *\n*  $202 RC=40 when caller is in AMODE=64                              *\n*       Add LLIBDEF to list of registered callers                     *\n*                                                                     *\n&REL     SETC  '202'                                                  *\n***********************************************************************\nIGX00GSF CSECT\nIGX00GSF RMODE ANY                 AMODE(31),RMODE(ANY)\n*\nRPRB     EQU   5\n         USING RBBASIC,RPRB\nRBASE    EQU   6\n         USING BEGIN,RBASE\nRCDE     EQU   7\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR14      EQU   14\nR15      EQU   15\n*\nBEGIN    B     GETPRB              BRANCH AROUND EYE-CATCHER\n         DC    C'IGX00GSF'         SIGNATURE\n         DC    C' R&REL '          VVMM\n*\n*        POINT AT CALLER'S PRB\n*\nGETPRB   EQU   *\n         L     RPRB,RBLINK         GET ADDRESS OF CALLER'S RB\n         SH    RPRB,=AL2(RBBASIC-RBPRFX) POINT AT RB PREFIX\n         USING RBPREFIX,RPRB\n*\nRC8      TM    RBSTAB,RBFTP        IS THIS A PRB ?\n         BZ    RC12                YES, JUMP\n         LA    R15,8               INDICATE NOT RUNNING UNDER A PRB\n         BR    R14                 GOBACK\n*\nRC12     SLR   RCDE,RCDE\n         ICM   RCDE,B'0111',RBCDE+1 GET CDE ADDRESS\n         BZ    BADPGM              ERROR IF NO CDE (SYNCH, IRB)\n         USING CDENTRY,RCDE\n         TM    CDATTR,CDMIN        IS THIS ENTRY AN ALIAS ?\n         BNO   *+8                 NO, JUMP\n         L     RCDE,CDXLMJP        YES, GET ADDRESS OF MAJOR CDE\n*\nCHECKPGM EQU   *\n         CLC   CDNAME,=CL8'SHOWMVS' IS THIS A REGISTERED CALLER?\n         BE    GOODPGM             YES, JUMP\n         CLC   CDNAME,=CL8'STEPLIB' IS THIS A REGISTERED CALLER?\n         BE    GOODPGM             YES, JUMP\n         CLC   CDNAME,=CL8'LLIBDEF' IS THIS A REGISTERED CALLER?\n         BE    GOODPGM             YES, JUMP\n*\nBADPGM   EQU   *\n         LA    R15,12              CALLED FROM UNKNOWN MODULE\n         BR    R14                 GOBACK\nGOODPGM  EQU   *\n*\nRC16     TM    CDATTR2,CDSYSLIB    IS MODULE FROM AUTHORIZED LIBRARY ?\n         BO    RC20                YES, EXIT\n         LA    R15,16              MODULE NOT FROM AUTHORIZED LIBRARY\n         BR    R14                 GOBACK\n*\n*        CALLER MUST HAVE THE FOLLOWING PREFIX :\n*\n*                B     BEGIN-*(,R15)       +0\n*                DC    A(0)                +4  UNUSED\n*                DC    A(SVC109+2+VL)      +8  CHECKED BY IGX00GSF\n*        BEGIN   SAVE\n*                . . .\n*        SVC109  SVC   109\n*\nRC20     L     R9,CDENTPT          CALLER'S EP ADDRESS (MAJOR CDE)\n         CLC   RBOPSWA,8(R9)       ADDRESS OF SVC 109 MATCHES PREFIX?\n         BE    RC24                YES, JUMP\n         LA    R15,20              BAD MODULE PREFIX\n         BR    R14                 GOBACK\n*\nRC24     TM    RBFLAGS1,RBSCB      IS ESTAE SET ?\n         BNO   RC28                NO, JUMP\n         LA    R15,24              CALLER HAS ISSUED ESTAE\n         BR    R14                 GOBACK\n*\nRC28     TM    RBCDFLGS,RBCDXCTL   IS XCTL BIT ON ?\n         BZ    RC32                NO, JUMP\n         LA    R15,28              CALLER WAS INVOKED VIA XCTL\n         BR    R14                 GOBACK\n*\nRC32     TM    CDATTR,CDREN        IS CALLING MODULE REENTRANT ?\n         BO    RC36                YES, JUMP\n         LA    R15,32              CALLING MODULE NON REENTRANT\n         BR    R14                 GOBACK\n*\nRC36     L     R9,RBOPSWA          ADDRESS OF SVC 109\n         LA    R9,0(,R9)           CLEAN UP AMODE BIT\n         LM    R10,R11,LPDEXTLN-LPDE+CDENTRY length,loadpt\n         TM    CDATTRB,CDELPDE     IS THIS AN LPDE?\n         BO    RC36OFFS            YES, JUMP\n         L     R10,CDXLMJP         GET ADDRESS OF THE EXTENT LIST\n         LM    R10,R11,XTLMSBLA-XTLST(R10) length,loadpt\n         LA    R10,0(,R10)         zero end-of-extent-list indicator\nRC36OFFS SLR   R9,R11              GET OFFSET TO SVC 109\n         CH    R9,=H'8'            SVC 109 IN CALLER'S MODULE ?\n         BNH   RC36ERR             NO, JUMP\n         SH    R10,=H'8'           R10=length-8\n         BNP   RC36ERR             length too small, error\n         CLR   R9,R10              SVC 109 IN CALLER'S MODULE ?\n         BL    RC40                YES, JUMP\nRC36ERR  LA    R15,36              SVC 109 ADDR NOT IN CALLING MODULE\n         BR    R14                 GOBACK\n*\nRC40     EQU   *\n         TM    RBOPSWB4,RBOPSW64   Caller in AMODE=64 ?\n         BNO   RC44                No, continue\n         LA    R15,40              Caller in AMODE=64\n         BR    R14                 GOBACK\n*\nRC44     EQU   *                   RESERVED\n*\n*---------------------------------------------------------------------*\n*        CALLER PASSED ALL THE TESTS: SWITCH PSW TO MODE=SUP          *\n*---------------------------------------------------------------------*\n*\n         NI    RBOPSWB2,255-RBOPSWPS PROBLEM-STATE BIT OFF\n         SR    R15,R15             INDICATE GOOD RETURN\n         BR    R14                 RETURN\n*\n         PRINT NOGEN\nPRINT    OPSYN ANOP\n         IKJRB                     REQUEST BLOCK\n         AIF   (D'RBOPSWB4).A64\nRBOPSWB4 EQU   RBOPSW+3,1,C'B'     OLD PSW BYTE 4\nRBOPSW64 EQU   X'01'               AMODE 64\n.A64     ANOP\n         IHACDE                    CONTENTS DIRECTORY ENTRY\n         IHALPDE                   LPA DIRECTORY ENTRY\n         IHAXTLST                  EXTENT LIST\n         END   BEGIN\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//LKED    EXEC PGM=IEWL,PARM=RENT\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//SYSPRINT DD SYSOUT=*\n//SYSLMOD  DD DSN=ADCD.ZOSV1R2.LPALIB(IGX00000),DISP=SHR\n//\n//*\n//DELMLPA  EXEC PGM=LOADMLPA,PARM=(DELETE,IGX00000)\n//*\n//LOADMLPA EXEC PGM=LOADMLPA,PARM=(LOAD,IGX00000)\n//STEPLIB  DD DSN=ADCD.ZOSV1R2.LPALIB.LPALIB,DISP=SHR\n//*\n//ESR     EXEC PGM=SVCUPDTE,PARM=(109,IGX00000)\n//SYSUDUMP DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IKJEFLN#": {"ttr": 12041, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x12\\x07\\x8f\\x01\\x12\\x07\\x8f\\x138\\x00$\\x00$\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-03-18T00:00:00", "modifydate": "2012-03-18T13:38:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "CBT484"}, "text": "\nIKJEFLN2 is a TSO LOGON exit routine which can be coded to reconnect\na user to an active TSO session.  IBM provides the rules for system\nprogrammers to write such an exit routine, but (as far as I know),\ndoes not distribute a coding example.\n\nIn 2000, I wrote a free version of IKJEFLN2 which soon was\ndistributed in file 183 of the CBT tape and quickly became\npopular.  In 2002, however, it started to stop working on z/OS\nsystems, because the rules with which RACF handles OPERCMDS had\nbecome more restrictive.  When the free IKJEFLN2 exit fails,\nthese messages are produced:\n\n  IEE345I VARY     AUTHORITY INVALID, FAILED BY SECURITY PRODUCT\n  ICH408I JOB(MSTJCL00) STEP(BPXOINIT) MVS.VARY.NET CL(OPERCMDS)\n    INSUFFICIENT ACCESS AUTHORITY\n    ACCESS INTENT(UPDATE) ACCESS ALLOWED(NONE)\n\nI received several suggestions to correct the problem, but I also\nhad personal experience that convinced me to add new capabilities\nto the exit routine.  For this reason, I wrote the IKJEFLN2 product\nwhich no longer had the above OPERCMDS problem and today, works\nfine in z/OS R9 with RACF.\n\nCompared to the free version, the IKJEFLN2 product has additional\ncapabilities.  It displays information about (1) the active TSO\nsession and (2) the new TSO session just created, then prompts the\nuser to (1) reconnect to the active TSO session, or (2) cancel it.\n\nThe IKJEFLN2 product also checks for an IEF238D allocation\nrecovery message.  If it finds one that blocks the TSO session,\nit automatically replies CANCEL to it.\n\nThe IKJEFLN2 product is very inexpensive and described here:\nhttp://gsf-soft.com/Products/IKJEFLN2.shtml\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IKJEFLN2": {"ttr": 12043, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x11\\x01\\x00$\\x1f\\x01\\x00%?\\x17H\\x01z\\x00\\\\\\x00>\\xc3\\xc2\\xe3\\xf4\\xf3\\xf0@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2000-08-28T00:00:00", "modifydate": "2000-09-09T17:48:11", "lines": 378, "newlines": 92, "modlines": 62, "user": "CBT430"}, "text": "//GILBERTL JOB (ACCT#),IKJEFLN2,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = IKJEFLN2                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = TSO Logon Post-Display Exit for TN3270 Reconnect *\n*                                                                     *\n* FUNCTION = This TSO Logon exit allows LOGON RECONNECT to succeed    *\n*            in the TN3270 environment by issuing a VTAM disconnect   *\n*            command before Logon actually proceeds.                  *\n*            The user must specify the Reconnect option on the        *\n*            Logon panel and log onto the system on which the         *\n*            active TSO session was created.                          *\n*                                                                     *\n* STATUS = R099f (Beta)                                               *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*          Thanks to Keith Moe of Amdahl for his suggestions and help.*\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = MVS/ESA or OS/390                                 *\n*                                                                     *\n*    AUTHORIZATION = APF                                              *\n*                                                                     *\n*    RESTRICTIONS = NONE                                              *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (TSO Logon Exit)                           *\n*                                                                     *\n*    PROCESSOR = IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 1K                                                 *\n*                                                                     *\n*    ATTRIBUTES = RENT, REFR, RMODE ANY, AMODE 31,                    *\n*                 SUPERVISOR STATE, KEY 8                             *\n*                                                                     *\n* INSTALLATION = This exit must be installed in an authorized system  *\n*             library (LPA or link-list) under the name IKJEFLN2.     *\n*             No SYS1.PARMLIB change is necessary to activate this    *\n*             exit - its presence is a system library triggers its    *\n*             invocation.                                             *\n*             To deactivate this exit and remove it from the system,  *\n*             simply delete it and refresh LLA if it was in a         *\n*             link-list library.                                      *\n*                                                                     *\n* OPERATION = Retrieve the user-id and password from the input        *\n*             parameters and check all of the active address spaces   *\n*             for an existing TSO session with the specified user-id. *\n*                                                                     *\n*             If a TSO session is found, then check the TSBXWREC      *\n*             flag which indicates that the terminal has been         *\n*             disconnected and the session is already in \"waiting     *\n*             to reconnect\" status. If TSBXWREC=1, exit.              *\n*                                                                     *\n*             If TSBXWREC=0, then validate the password by issuing    *\n*             RACROUTE REQUEST=VERIFY.                                *\n*                                                                     *\n*             If RACROUTE fails, prompt the user for the correct      *\n*             password.                                               *\n*                                                                     *\n*             If RACROUTE is successful, issue a VARY NET,TERM        *\n*             command to disconnect the TSO session from the          *\n*             terminal and and exit to the Logon processor.           *\n*                                                                     *\n* Notes:      This version of the exit allows Reconnect to proceed    *\n*             when the screen size of the new terminal is smaller     *\n*             than the size of the old terminal.  This should not     *\n*             be a problem if the session is at the READY prompt      *\n*             because TSO automatically adjusts to the new screen     *\n*             size.  Reconnecting with a smaller screen size,         *\n*             however, is likely to cause screen writing errors       *\n*             in ISPF and other TSO full-screen applications.         *\n*             Note that the same problem exists with 3270 terminals.  *\n*                                                                     *\n*             This exit will not allow a user to reconnect to         *\n*             a session that is active on a different member          *\n*             of a MAS or SYSPLEX.                                    *\n*                                                                     *\n* CALLED BY = TSO Logon (re: TSO/E Customization manual).             *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n* 099f 5th Beta Release                                               *\n*                                                                     *\n***********************************************************************\nIKJEFLN2 CSECT\nIKJEFLN2 RMODE ANY\n         DC    C'GSF Utilities - IKJEFLN2 R099f '\nBEGIN    BAKR  R14,0                   SAVE THE REGISTERS\n         LR    R11,R1                  parm list\n         USING PARMLIST,R11\n         LR    R12,R15                 local base\n         USING BEGIN,R12\n*\n*        check that the parm list contains reconnect=S, otherwise exit.\n*\nCHKRECON L     R2,PARM31               reconnect option\n         ICM   R0,B'1111',0(R2)        parm omitted?\n         BZ    EXIT                    yes, exit\n         ICM   R1,B'1111',4(R2)        length=0?\n         BZ    EXIT                    yes, exit\n         CLI   8(R2),C'S'              reconnect=S ?\n         BNE   EXIT                    no, exit\n*\n*        allocate dynamic storage area\n*\nGETDYNAM GETMAIN R,LV=DYNAML           allocate dynamic storage\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1                  A(DYNAM)\n         USING DYNAM,R13\n         MVC   VTAMCMD(VTAMCMDL),VTAMCMDM\n*\n*        retrieve user-id from parm list\n*\nGETUID   LA    R0,USERID               \"to\" area\n         LA    R1,L'USERID             \"to\" length\n         L     R2,PARM21               user-id\n         LA    R14,8(,R2)              \"from\" area\n         LH    R15,6(,R2)              \"from\" length\n         ICM   R15,B'1000',BLANKS      padding character\n         MVCL  R0,R14                  move user-ID\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Search ASCB chain for an active TSO session                  *\n*        with the same user-ID.                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\nFINDTSB  LA    R4,2                    FIRST ASID\n         L     R5,CVTPTR(0,0)          CVT ADDRESS\n         L     R5,CVTASVT-CVTMAP(,R5)  POINT TO ASVT\n         L     R5,ASVTMAXU-ASVT(,R5)   MAX ASID\n*LOOP\nLOOP2    LOCASCB ASID=(R4)\n         LTR   R15,R15                 ASCB active?\n         BNZ   LOOP2NXT                no, ignore\n         CL    R1,PSAAOLD-PSA(0,0)     own address space?\n         BE    LOOP2NXT                yes, ignore\n         LR    R7,R1                   pass ASCB address\n         USING ASCB,R7\n         ICM   R8,B'1111',ASCBTSB      TSO ADDRESS SPACE?\n         BZ    LOOP2NXT                no, ignore\n         L     R1,ASCBJBNS             point at job name\n         CLC   USERID,0(R1)            MY USERID?\n         BE    ASIDF99                 YES, EXIT\nLOOP2NXT LA    R4,1(,R4)               NEXT ASID\n         BCT   R5,LOOP2                NEXT ASID\n*ENDLOOP\n         B     CLEANUP                 No active TSO session found\nASIDF99  EQU   *\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Retrieve TSB & TSBX associated with the TSO session.         *\n*                                                                     *\n*---------------------------------------------------------------------*\n         USING TSB,R8\nMOVETSB1 LA    R0,L'TSB1-1             LENGTH OF UNPROTECTED TSB\n         IVSK  R1,R8                   Source key into R1\n         MVCSK TSB1,TSB                Move TSB to unprotected storage\n         LA    R8,TSB1\n         L     R9,TSBEXTNT             addr of the TSBX\n         LA    R0,L'TSBX1-1            LENGTH OF UNPROTECTED TSBX\n         IVSK  R1,R9                   Source key into R1\n         MVCSK TSBX1,0(R9)             Move TSBX to unprotected storage\n         USING TSBX,TSBX1\n*\n*        If the TSO session is already in \"waiting to reconnect\"\n*        status, then exit.\n*\n         TM    TSBXFLG1,TSBXWREC       waiting to reconnect?\n         BO    CLEANUP                 yes, we're done\n         TM    TSBXFLG2,TSBXPREC       Reconnect in progress?\n         BO    CLEANUP                 yes, we're done\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Validate the userid/password using RACROUTE REQUEST=VERIFY   *\n*        and the current terminal name.                               *\n*                                                                     *\n*        If the user specified a Group name, it is not validated      *\n*        here but will be validated later on by Logon processing.     *\n*                                                                     *\n*---------------------------------------------------------------------*\nCHKPSWD  MVC   RACINITL(RACINITLL),RACINITM\n         L     R2,PARM32               OID card\n         ICM   R0,B'1111',0(R2)        any data specified here?\n         BZ    CHKPSWD5                no, ignore\n         RACINIT OIDCARD=7(R2),        OID Card                        X\n               MF=(M,RACINITL)\nCHKPSWD5 EQU   *\n         LM    R2,R3,PARM21            user-id,password\n         ICM   R0,B'1111',0(R3)        was password specified?\n         BZ    CLEANUP                 no, exit\n         RACINIT ENVIR=CREATE,                                         X\n               USERID=7(R2),           user-id                         X\n               PASSWRD=7(R3),          password                        X\n               TERMID=TERMID1,         Own terminal name (current)     X\n               ACEE=ACEEPTR,           addr of the ACEE                X\n               MF=(E,RACINITL)\n         LTR   R2,R15                  RACINIT successful?\n         BNZ   BADPSWD                 No, error\n*\n*        Delete the ACEE we just created, it's useless.\n*\n         MVC   RACINITL(RACINITLL),RACINITM\n         RACINIT ENVIR=DELETE,         DELETE ACEE                     X\n               ACEE=ACEEPTR,           addr of the ACEE                X\n               MF=(E,RACINITL)\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Retrieve current terminal name from my own TSB               *\n*                                                                     *\n*---------------------------------------------------------------------*\nMOVETSB2 L     R7,PSAAOLD-PSA(0,0)     current ASCB\n         L     R8,ASCBTSB              Terminal Status Block\n         LA    R0,L'TSB2-1             LENGTH OF UNPROTECTED TSB\n         IVSK  R1,R8                   Source key into R1\n         MVCSK TSB2,TSB                Move TSB to unprotected storage\n         LA    R8,TSB2\n         MVC   SIZE1,TSBPRMR           save screen sizes\n         L     R9,TSBEXTNT             addr of the TSBX\n         LA    R0,L'TSBX2-1            LENGTH OF UNPROTECTED TSBX\n         IVSK  R1,R9                   Source key into R1\n         MVCSK TSBX2,0(R9)             Move TSBX to unprotected storage\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Issue VTAM disconnect command                                *\n*                                                                     *\n*---------------------------------------------------------------------*\nSENDCMD  MVC   NEWTERM,TERMID1         new terminal name\n         MVC   OLDTERM,TERMID2         old terminal name\n         MODESET KEY=ZERO\n         SLR   R0,R0                   CN(0)\n         MGCR  VTAMCMD                 issue command\n         MODESET KEY=NZERO\n*\n         TPUT  VTAMCMD+4,VTAMCMDL-4    display command\nNEXTPAGE MVC   WORK80(3),=C'***'       move string to 24-bit storage\n         TPUT  WORK80,3,ASIS           display ***\n         TGET  WORK80,1                prompt the user to press ENTER\n         B     CLEANUP\n*---------------------------------------------------------------------*\n*                                                                     *\n*        RACINIT Failed                                               *\n*                                                                     *\n*        If the password is invalid, set up control switches          *\n*        to ensure the user is prompted for a new password.           *\n*                                                                     *\n*---------------------------------------------------------------------*\nBADPSWD  CH    R2,=H'8'                invalid password?\n         BNE   CLEANUP                 no, exit\n*\n         L     R3,PARM10               control switches\n         OI    4+8(R3),BIT0            re-prompt\n         L     R4,PARM15               re-prompt code\n         LA    R1,2                    password code\n         ST    R1,8(,R4)               store code into parm15\n*\n*        Set the \"do not issue RACROUTE\" switch to\n*        prevent RACF from counting two violations.\n*\n         OI    2+8(R3),BIT2            do not issue RACROUTE\n*---------------------------------------------------------------------*\n*                                                                     *\n*        free dynamic storage and exit                                *\n*                                                                     *\n*---------------------------------------------------------------------*\nCLEANUP  FREEMAIN R,LV=DYNAML,A=(R13)\nEXIT     SLR   R15,R15                 RC=0\n         PR                            go back to IKJEFLE\nRACINITM RACINIT MF=L\nVTAMCMDM WTO   'VARY NET,TERM,TYPE=COND,NOTIFY=NO,SLU=12345678 1234567 X\n               12345678',MF=L\nVTAMCMDL EQU   *-VTAMCMDM\nBLANKS   DC    CL8' '\n***********************************************************************\n*        Dynamic Save Area                                            *\n***********************************************************************\nDYNAM    DSECT\n         DS    18F                     standard save area\nVTAMCMD  DS    XL(VTAMCMDL)\n         ORG   VTAMCMD+VTAMCMDL-25\nOLDTERM  DS    CL8,C                   old terminal\nUSERID   DS    CL8                     user-id (8 chars)\nNEWTERM  DS    CL8                     new terminal\n         ORG\nPASSWORD DS    CL8                     password\nRACINITL RACINIT MF=L\nRACINITLL EQU  *-RACINITL\nACEEPTR  DS    A                       addr of ACEE created by RACINIT\nTSB1     DS    XL(TSB_LENGTH)          TSB of active TSO session\nSIZE2    EQU   TSBPRMR-TSB+TSB1,4      screen size (old)\nTERMID2  EQU   TSBTRMID-TSB+TSB1,8     terminal id (old)\nTSBX1    DS    XL(TSBX_LENGTH)         TSBX of active TSO session\nTSB2     DS    XL(TSB_LENGTH)          own TSB  (current)\nSIZE1    EQU   TSBPRMR-TSB+TSB2,4      screen size (current)\nTERMID1  EQU   TSBTRMID-TSB+TSB2,8     terminal id (current)\nTSBX2    DS    XL(TSBX_LENGTH)         own TSBX (current)\nWORK80   DS    CL80                    TPUT\nDYNAML   EQU   *-DYNAM\n***********************************************************************\n*        Parameter list                                               *\n***********************************************************************\nPARMLIST DSECT\nPARM1    DS    A                       Command Buffer\nPARM2    DS    A                       New Command Buffer\nPARM3    DS    A                       UPT\nPARM4    DS    A                       ECT\nPARM5    DS    A                       PSCB\nPARM6    DS    A                       exit-to-exit communication word\nPARM7    DS    A                       exit reason code\nPARM8    DS    A                       reserved\nPARM9    DS    A                       reserved\n*                                      exit-dependent parameter list\nPARM10   DS    A                       control switches\nPARM11   DS    A                       Panel Module\nPARM12   DS    A                       TGET Buffer\nPARM13   DS    A                       Help Panel Number\nPARM14   DS    A                       Language Code\nPARM15   DS    A                       re-prompt code\nPARM16   DS    A                       Installation-defined parm list\nPARM17   DS    A                       reserved\nPARM18   DS    A                       reserved\nPARM19   DS    A                       First Message\nPARM20   DS    A                       Second Message\nPARM21   DS    A                       User-ID\nPARM22   DS    A                       Password\nPARM23   DS    A                       Account\nPARM24   DS    A                       Procedure\nPARM25   DS    A                       Region\nPARM26   DS    A                       Performance Group\nPARM27   DS    A                       New Password\nPARM28   DS    A                       RACF Group Name\nPARM29   DS    A                       No Mail Option\nPARM30   DS    A                       No Notices Option\nPARM31   DS    A                       Reconnect Option\nPARM32   DS    A                       OID Card\nPARM33   DS    A                       First Command\nPARM34   DS    A                       SECLABEL\n         PRINT NOGEN\nPRINT    OPSYN ANOP\n         YREGS                         R0-R15\n         IEZBITS\nPSA      DSECT\nPSAAOLD  EQU   PSA+X'224',4,C'A'       current ASCB\n         CVT   DSECT=YES               COMMUNICATION VECTOR TABLE\n         IHAASCB                       ADDRESS SPACE CONTROL BLOCK\n         IHAASVT                       ADDRESS SPACE VECTOR TABLE\n         IKJTSB EXT=YES                TSB/TSBX\nTSBX_LENGTH EQU *-TSBX\nTSB      DSECT\nTSB_LENGTH EQU *-TSB\n         END   BEGIN\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR             IEZBITS IHAASVT\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//LKED    EXEC PGM=LINKLLA,PARM=(MAP,RENT)\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSPRINT DD SYSOUT=*\n//SYSLMOD  DD DSN=SYS1.LOCAL.LINKLIB(IKJEFLN2),DISP=SHR\n//\n//\n//*\n//* Delete the module; as long as LLA is not refreshed,\n//* it will remain available.  In case of a serious problem,\n//* refreshing LLA will get rid of it.\n//*\n//SCRATCH EXEC PGM=IKJEFT01\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\nTSOLIB ACT DA('GSFSOFT.SCRATCH.LOAD')\nSCRATCH 'SYS1.LOCAL.LINKLIB(IKJEFLN2)' LLAREFRESH\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INITKSDS": {"ttr": 12293, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//GILBERTI JOB (ACCT#),INITKSDS,\n// NOTIFY=&SYSUID,\n//*RESTART=GO,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n*PROCESS FLAG(NOPAGE0)                 VSAM Macros\n***********************************************************************\n*                                                                     *\n* MODULE NAME = INITKSDS                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = Initialize a KSDS                                *\n*                                                                     *\n* FUNCTION = INITKSDS switches an empty VSAM KSDS from \"create\" mode  *\n*            to \"update\" mode.  INITKSDS may be invoked as a TSO      *\n*            command, a batch program, or a subroutine.               *\n*                                                                     *\n* STATUS = R105                                                       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = MVS/ESA, OS/390 or z/OS                           *\n*                                                                     *\n*    AUTHORIZATION = NONE                                             *\n*                                                                     *\n*    RESTRICTIONS = NONE                                              *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (TSO Command Processor)                    *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 4K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE ANY, AMODE 31,                   *\n*                 PROBLEM STATE, KEY 8                                *\n*                                                                     *\n* OPERATION = See Below                                               *\n*                                                                     *\n*        A KSDS is in create mode from the time it is DEFINEd         *\n*        until a record is written into it.  If a program OPENs       *\n*        for input, I-O or with STRNO=2 a KSDS in create mode,        *\n*        OPEN fails with R15=8,ERROR=160.  \"Create\" mode is also      *\n*        called \"load\" mode.                                          *\n*                                                                     *\n*        To change its status from \"create\" mode to \"non-create\"      *\n*        mode, a KSDS must be OPEN'd for output, a record must be     *\n*        written into it, then it must be CLOSEd.  From that point    *\n*        on, the KSDS may be OPEN'd without restriction.              *\n*                                                                     *\n*        INITKSDS proceeds as follows:                                *\n*                                                                     *\n*        1. Dynamically ALLOCATE the data set with DISP=SHR           *\n*           (unless the OLD key-word is specified in which case       *\n*           DISP=OLD is used).                                        *\n*                                                                     *\n*        2. OPEN the data set for output (MACRF=OUT) and check        *\n*           that it really is a KSDS                                  *\n*                                                                     *\n*        3. check that the KSDS contains no records                   *\n*                                                                     *\n*        4. WRITE a dummy record                                      *\n*                                                                     *\n*        5. CLOSE the data set                                        *\n*                                                                     *\n*        6. OPEN the data set again for I-O with MACRF=(IN,OUT)       *\n*                                                                     *\n*        7. DELETE the dummy record                                   *\n*                                                                     *\n*        8. CLOSE the data set and FREE it up                         *\n*                                                                     *\n*        If the RESET option is specified, INITKSDS proceeds          *\n*        as follows:                                                  *\n*                                                                     *\n*        1. ALLOCATE the data set and OPENs it for I-O                *\n*                                                                     *\n*        2. DELETE all of the records, one by one                     *\n*           (this can take a while if the KSDS is big)                *\n*                                                                     *\n*        3. CLOSE the data set (which is now empty and in             *\n*           non-create mode).                                         *\n*                                                                     *\n* SYNTAX = See Below                                                  *\n*                                                                     *\n*        INITKSDS may be invoked as a TSO command using the           *\n*        following syntax:                                            *\n*                                                                     *\n*            INITKSDS 'data-set-name'                                 *\n*                      RESET/NORESET/ERASE/DELETE                     *\n*                      SHR/OLD                                        *\n*                                                                     *\n*            'data-set-name' is the data set name of the KSDS.        *\n*                                                                     *\n*            'NORESET' specifies that the KSDS has just been          *\n*            DEFINEd, contains no records, and must be converted to   *\n*            \"non-create\" mode by adding/deleting a dummy record.     *\n*            This is the default.                                     *\n*                                                                     *\n*            'RESET' specifies that the KSDS contains records and     *\n*            that these records should be deleted.  RESET can be      *\n*            used instead of DELETE/DEFINE/INITKSDS to create an      *\n*            empty KSDS in non-create mode.  ERASE or DELETE are      *\n*            equivalent to RESET.                                     *\n*                                                                     *\n*            'OLD' specifies that the data-set(s) should be           *\n*            allocated with DISP=OLD instead of SHR, which is the     *\n*            default.                                                 *\n*                                                                     *\n*        INITKSDS may be invoked as a batch program, using the        *\n*        following JCL:                                               *\n*                                                                     *\n*            //MYJOB   JOB (ACCT#),'JOHN DOE', . . .                  *\n*            //*                                                      *\n*            //INITKSDS EXEC PGM=INITKSDS                             *\n*            //INITKSDS  DD  DSN=my.new.vsam.ksds,DISP=SHR            *\n*                                                                     *\n*                                                                     *\n*        INITKSDS may be also be invoked from an assembler program,   *\n*        as follows:                                                  *\n*                                                                     *\n*                      LA    R1,MYACB                                 *\n*                      LINK  EP=INITKSDS                              *\n*            .  .  .  .  .  .  .  .  .  .                             *\n*            MYACB     ACB   DDNAME=MYDDNAME,MACRF=(IN, . .           *\n*                                                                     *\n*          If the VSAM data set is allocated with FREE=CLOSE,         *\n*          INITKSDS re-allocates it dynamically to initialize it.     *\n*                                                                     *\n* RETURN CODES                                                        *\n*                                                                     *\n*        RC=0     Successful Completion                               *\n*        RC=4     IKJPARS error                                       *\n*        RC=8     Data set is not a KSDS                              *\n*        RC=12    DYNALLOC error                                      *\n*                 OPEN error                                          *\n*                 Data set is not empty                               *\n*                 ERASE macro failed                                  *\n*        RC=16    invalid PARM field                                  *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n* 102 INITKSDS may be invoked as a PGM with R1 pointing to an ACB     *\n* 103 Use alternate DDname when the data set has FREE=CLOSE           *\n* 104 Complete FREE=CLOSE enhancement, fix others errors.             *\n* 105 RESET/NORESET can now be specified in the JCL PARM              *\n*                                                                     *\n***********************************************************************\nINITKSDS CSECT\nINITKSDS RMODE ANY\n         SAVE  (14,12),,'GSF UTILITIES - INITKSDS R105'\n         LR    R12,R15                 BASE REGISTER\n         USING INITKSDS,R12\n***********************************************************************\n*        ALLOCATE DYNAMIC STORAGE AREA                                *\n***********************************************************************\n         GETMAIN R,LV=DYNAML           ACQUIRE DYNAMIC STORAGE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LM    R13,R1,8(R13)\n         USING DYNAM,R13\n         LR    R11,R1                  POINT AT CPPL.\n         USING CPPL,R11\n         LA    R14,DYNAM+72            clear dynamic storage\n         LA    R15,DYNAML-72           clear dynamic storage\n         SLR   R1,R1                   clear dynamic storage\n         MVCL  R14,R0                  clear dynamic storage\n         MVC   IFGACB(MODELACB_LENGTH),MODELACB\n         MVC   IFGRPL(MODELRPL_LENGTH),MODELRPL\n         MVI   RESET,C'N'              DEFAULT IS 'NORESET'\n         TM    CPPL,X'80'              AM I INVOKED AS A PROGRAM?\n         BO    PGM00                   YES, JUMP\n***********************************************************************\n*        BUILD PARAMETER LIST FOR IKJEFF02                            *\n***********************************************************************\n         ST    R11,MTCPPLP             STORE CPPL ADDRESS IN MTPL\n         LA    R0,MTCSECTP             MESSAGE SECTION\n         ST    R0,MTPLPTR              STORE ADDR IN MTPL\n         LA    R0,DYNECB               EVENT CONTROL BLOCK\n         ST    R0,MTECBP               STORE ECB IN MTPL\n         L     R0,=A(MSGCSECT)         MESSAGE CSECT\n         ST    R0,MTCSECTP             STORE ECT IN PPL\n         OI    MTSW1,MTPUTLSW          PUTLINE IS NEEDED\n         OI    MTSW1,MTNHEXSW          XLATE TO DECIMAL\n         OI    MTSW2,MTFMT             31-BIT PARM LIST\n***********************************************************************\n*        BUILD PARSE PARM LIST, CALL IKJPARS                          *\n***********************************************************************\nPARSE000 LA    R1,WORKAREA             POINT TO PPL\n         USING PPL,R1                  SET UP ADDRESSABILITY TO PPL\n         L     R0,CPPLUPT              USER PROFILE TABLE\n         ST    R0,PPLUPT               STORE UPT ADDRESS IN PPL\n         L     R0,CPPLECT              ENVIRONMENT CONTROL TABLE\n         ST    R0,PPLECT               STORE ECT IN PPL\n         LA    R0,DYNECB               EVENT CONTROL BLOCK\n         ST    R0,PPLECB               STORE ECB IN PPL\n         MVC   PPLPCL,=A(PCLCSECT)     STORE PCL ADDR INTO PPL\n         LA    R0,WORD1                ANSWER AREA\n         ST    R0,PPLANS               STORE ANSWER ADDRESS IN PPL\n         L     R0,CPPLCBUF             COMMAND BUFFER\n         ST    R0,PPLCBUF              STORE BUFFER ADDRESS IN PPL\n         L     R15,CVTPTR(,0)          Address of the CVT\n         L     R15,CVTPARS-CVTMAP(,R15) address of IKJPARS\n         SYNCH (R15)                   call IKJPARS\n         LTR   R2,R15                  CHECK FOR ZERO PARSE RETURN\n         BNZ   FINISH                  GO AWAY UPSET\n         DROP  R1                      WAS PPL\n***********************************************************************\n*        PROCESS PARSED PARAMETERS                                    *\n***********************************************************************\n         MVI   PGMCMD,C'C'             MODE=CMD\n         L     R8,WORD1                LOAD PDL ADDRESS\n         USING IKJPARMD,R8             SET UP ADDRESSABILITY TO PDL\nPARSE100 LA    R14,DSNAME              44-BYTE AREA\n         LA    R15,L'DSNAME            GET LENGTH\n         L     R0,DSNPCE               GET ADDRESS\n         LH    R1,DSNPCE+4             ACTUAL LENGTH OF DSN\n         ICM   R1,B'1000',=C' '        PADDING\n         MVCL  R14,R0                  MOVE DATA SET NAME\nPARSE200 MVC   STATUS(8),=AL2(DALSTATS,1,1,X'0800') DISP=SHR KEY\n         CLI   STATPCE+1,2             CHECK FOR 2ND IKJPNAME\n         BNE   PARSE300                JUMP IF NOT THE 2ND\n         MVI   STATUS+6,X'01'          DISP=OLD KEY\nPARSE300 EQU   *\n         CLI   RSTPCE+1,2              CHECK FOR 2ND IKJPNAME\n         BNE   PARSE999                JUMP IF NOT THE 2ND\n         MVI   RESET,C'R'              2ND IS 'RESET'\n         MVI   STATUS+6,X'01'          DISP=OLD KEY\nPARSE999 IKJRLSA WORD1                 RELEASE PDL\n         B     ALLOC000                allocate and open\n***********************************************************************\n*        INITKSDS IS INVOKED AS A PROGRAM                             *\n***********************************************************************\nPGM00    MVI   PGMCMD,C'P'             MODE=PGM\n         CLC   ACBID,CPPL              R1 POINTS TO AN ACB?\n         BE    PGM50                   yes, jump\n*\n*        Check PARM when invoked in a JCL step\n*\n         L     R2,CPPL                 parm address\n         CLI   0(R2),0                 parm OK?\n         BNE   BADPARM                 no, error\n         CLI   1(R2),0                 PARM=''?\n         BE    PGM21                   yes, continue\n         CLI   1(R2),7                 PARM=NORESET?\n         BNE   PGM15                   no, jump\n         CLC   =C'NORESET',2(R2)       PARM=NORESET?\n         BE    PGM21                   no, jump\nPGM15    CLI   1(R2),5                 PARM=RESET?\n         BNE   BADPARM                 no, bad parm\n         CLC   =C'RESET',2(R2)         PARM=RESET?\n         BNE   BADPARM                 no, bad parm\n*\nPGM20    MVI   RESET,C'R'              PARM='RESET'\nPGM21    BAL   R14,GETDSN           <- retrieve dsname\n         B     OPEN                    continue\n***********************************************************************\n*        INITKSDS was invoked as a sub-routine with                   *\n*        the address of an ACB in R1                                  *\n*                                                                     *\n*        If the data set was allocated with FREE=CLOSE,               *\n*        reallocate it for our own processing.                        *\n***********************************************************************\nPGM50    MVC  ACBDDNM,ACBDDNM-IFGACB+CPPL MOVE DDNAME FROM CALLER'S ACB\n         BAL   R14,GETDSN           <- retrieve dsname\n         LTR   R15,R15                 DD missing?\n         BNZ   OPEN                    yes, fail\n         L     R1,DSAB1                addr of the DSAB\n         TM    DSABFLG2-DSAB(R1),DSABUNAL FREE=CLOSE?\n         BZ    OPEN                    no, jump\n***********************************************************************\n*        Allocate the VSAM data set                                   *\n***********************************************************************\nALLOC000 LA    R2,WORKAREA             S99RB\n         ST    R2,DFS99RBP             S99RBPTR\n         OI    DFS99RBP,X'80'          S99RBPND\n         LA    R0,=AL1(0,DFSVC99)      PUTLINE ONLY, SVC99\n         ST    R0,DFIDP                BUILD PARML FOR DAIRFAIL\n         ST    R11,DFCPPLP             ADDR OF CPPL\n*\n         LA    R0,L'DSNAME             LENGTH OF INSERT           (1)\n         ST    R0,MTLEN+00             LENGTH OF INSERT\n         LA    R0,DSNAME               RETURN CODE\n         ST    R0,MTADDR+00            ADDRESS OF INSERT\n*\n         USING S99RB,R2\n         XC    S99RB(S99RBEND-S99RB),S99RB  CLEAR DYNALLOC WORK SPACE\n         MVI   S99RBLN,S99RBEND-S99RB  RB LENGTH\n         MVI   S99VERB,S99VRBAL        VERB IS \"ALLOCATE\"\n         LA    R0,S99RBEND             END OF RB, START OF T.U. PTRS\n         ST    R0,S99TXTPP             TEXT UNIT POINTERS\n*\n         OI    S99FLG11,S99NOCNV       DO NOT USE EXISTING DD\n         OI    S99FLG11,S99NOMNT       DO NOT MOUNT VOLUMES\n         LA    R14,TU55DDN             DDNAME TEXT UNIT\n         MVC   0(6,R14),=AL2(DALRTDDN,1,L'DDNAME) RETURN DDNAME KEY\n         LA    R15,TU02DSN             DSNAME TEXT UNIT\n         MVC   0(6,R15),=AL2(DALDSNAM,1,L'DSNAME) DSNAME KEY\n         LA    R0,STATUS               ADDRESS OF STATUS KEY\n         LA    R1,TU57ORG              RETURN DSORG\n         MVC   0(6,R1),=AL2(DALRTORG,1,L'DSORG)  DSORG\n         STM   R14,R1,S99RBEND+00      FIRST TO THIRD TEXT UNIT PTRS\n         OI    S99RBEND+12,X'80'       END OF LIST\n*\n         LA    R1,DFS99RBP             S99RBPTR\n         DYNALLOC ,                    ISSUE SVC 99 (ALLOCATE)\n         LTR   R15,R15\n         BNZ   MSG99                   ALLOCATION FAILED, EXIT\n         DROP  R2                      WAS S99RB\n         CLC   DSORG,=AL2(ACBDORGA)    DSORG=VS?\n         BNE   MSG99NVS                NOT A VSAM DATA SET\n         MVC   ACBDDNM,DDNAME          MOVE THE RETURNED DDNAME\n***********************************************************************\n*        OPEN THE VSAM DATA SET                                       *\n***********************************************************************\nOPEN     LA    R2,IFGACB               POINT TO ACB\n         ST    R2,OPENLIST             MAKE OPEN LIST\n         ST    R2,RPLDACB              SET UP RPL\n         MVI   OPENLIST,X'80'          FREE=CLOSE OPTION\n         OPEN  MF=(E,OPENLIST)         OPEN THE ACB\n         CH    R15,=H'4'               OPEN OK?\n         BH    MSGOPEN                 NO, QUIT\n*\n         TESTCB ACB=(R2),ATRB=KSDS,    IS THIS A KSDS?                 X\n               MF=(G,WORKAREA,TESTCBL)\n         BNE   MSG99NVS                NOT A VSAM DATA SET\n*\n         SHOWCB ACB=(R2),AREA=(S,MAXRECNO),LENGTH=08,                  X\n               FIELDS=(NLOGR,LRECL),MF=(G,WORKAREA,SHOWCBL)\n***********************************************************************\n*        PROCESS THE OPEN'D DATA SET                                  *\n***********************************************************************\n         L     R0,MAXLRECL             get lrecl\n         ST    R0,RPLRLEN              RECORD LENGTH\n         GETMAIN RU,LV=(0)             allocate record area\n         ST    R0,RPLBUFL              BUFFER LENGTH\n         ST    R1,RPLAREA              SET UP THE RPL\n         ST    R1,RPLARG               SET UP THE RPL\n         CLI   RESET,C'R'              OPTION RESET SPECIFIED?\n         BE    RESET00                 YES, JUMP\n***********************************************************************\n*        ADD/DELETE A DUMMY RECORD\n***********************************************************************\nADDDEL   ICM   R0,B'1111',MAXRECNO     DATA SET EMPTY?\n         BNZ   MSGFULL                 NO, ERROR\n         MVC   REQUEST,=C'PUT  '       SET REQUEST FOR MESSAGE\n         PUT   RPL=IFGRPL              ADD A DUMMY RECORD\n         LTR   R15,R15                 PUT OK?\n         BNZ   MSGREQ                  NO, QUIT\nADDDEL9  CLOSE MF=(E,OPENLIST)         CLOSE THE ACB\n         OPEN  MF=(E,OPENLIST)         RE-OPEN THE ACB\n         LTR   R15,R15                 OPEN OK?\n         BNZ   MSGOPEN                 NO, QUIT\n***********************************************************************\n*        PROCESS THE 'RESET' FUNCTION (DELETE ALL OF THE RECORDS      *\n***********************************************************************\n*LOOP\nRESET00  MVC   REQUEST,=C'GET  '       SET REQUEST FOR MESSAGE\n         OI    RPLOPT2,RPLUPD          OPTCD=UPD\n         GET   RPL=IFGRPL              READ THE FIRST RECORD\n         LTR   R15,R15                 GET OK?\n         BNZ   MSGREQ                  NO, QUIT\nRESET20  MVC   REQUEST,=C'ERASE'       SET REQUEST FOR MESSAGE\n         ERASE RPL=IFGRPL              DELETE THE FIRST RECORD\n         LTR   R15,R15                 ERASE OK?\n         BNZ   MSGREQ                  NO, QUIT\n         B     RESET00\n*ENDLOOP\n***********************************************************************\n*        ISSUE MESSAGES                                               *\n***********************************************************************\nMSG99    MVC   MTMSGID,=C'99  '        DYNALLOC ERROR\n         CLI   PGMCMD,C'P'             MODE=PGM ?\n         BE    ISSUEMSG                YES, DO NOT CALL DAIRFAIL\n         ST    R15,RETCODE             RETURN CODE\n         LA    R0,RETCODE              RETURN CODE\n         ST    R0,DFRCP                RETURN CODE\n         LA    R0,=A(0)                NO ADDR FOR IKJEFF02\n         ST    R0,DFJEFF02             RETURN CODE\n         LA    R1,DFPARMS              DAIRFAIL PARM LIST\n         LINK  EP=IKJEFF18             Call the DAIRFAIL routine\n         LA    R2,12                   RETURN-CODE\n         B     ISSUEMSG                ISSUE MESSAGE\n*\nMSG99NVS MVC   MTMSGID,=C'NVS '        NON-KSDS\n         LA    R2,8                    RETURN-CODE = 8\n         B     ISSUEMSG                ISSUE MESSAGE\n*\nMSGOPEN  MVC   MTMSGID,=C'OPEN'        \"OPEN FAILED\" MESSAGE\n         ST    R15,RETCODE             RETURN CODE\n*\n         LA    R0,L'RETCODE            LENGTH OF INSERT           (2)\n         ST    R0,MTLEN+08             LENGTH OF INSERT\n         OI    MTHIGHL+08,X'80'        XLATE TO DECIMAL\n         LA    R0,RETCODE              RETURN CODE\n         ST    R0,MTADDR+08            ADDRESS OF INSERT\n         LA    R2,12                   RETURN-CODE\n         B     ISSUEMSG                ISSUE MESSAGE\n*\nMSGFULL  MVC   MTMSGID,=C'FULL'        NON-EMPTY\n         LA    R2,12                   RETURN-CODE\n         B     ISSUEMSG                ISSUE MESSAGE\n*\nMSGREQ   MVC   MTMSGID,=C'REQ '        \"ERASE FAILED\" MESSAGE\n         ST    R15,RETCODE             RETURN CODE\n*\n         LA    R0,L'REQUEST            LENGTH OF INSERT           (1)\n         ST    R0,MTLEN+00             LENGTH OF INSERT\n         LA    R0,REQUEST              RETURN CODE\n         ST    R0,MTADDR+00            ADDRESS OF INSERT\n*\n         LA    R0,L'DSNAME             LENGTH OF INSERT           (2)\n         ST    R0,MTLEN+08             LENGTH OF INSERT\n         LA    R0,DSNAME               RETURN CODE\n         ST    R0,MTADDR+08            ADDRESS OF INSERT\n*\n         LA    R0,L'RPLFDBK            LENGTH OF INSERT           (3)\n         ST    R0,MTLEN+16             LENGTH OF INSERT\n         OI    MTHIGHL+16,X'80'        XLATE NUMERIC\n         OI    MTSW1,MTHEXSW           XLATE TO HEX\n         LA    R0,RPLFDBK              RETURN CODE\n         ST    R0,MTADDR+16            ADDRESS OF INSERT\n         LA    R2,12                   RETURN-CODE\n         B     ISSUEMSG                ISSUE MESSAGE\n***********************************************************************\n*        End-of-file on VSAM data set                                 *\n***********************************************************************\nCLOSE    LTR   R15,R15                 CLOSE OK?\n***      BNZ   MSGCLOS                 NO, QUIT\n         MVC   MTMSGID,=C'00  '        INITKSDS SUCCESSFUL\n         LA    R2,0                    RC=0\n*\nISSUEMSG CLI   PGMCMD,C'P'             MODE=PGM ?\n         BE    FINISH                  YES, IGNORE MESSAGE\n         L     R15,CVTPTR(,0)          Address of the CVT\n         L     R15,CVTEFF02-CVTMAP(,R15) ADDR OF IKJEFF02\n         LA    R1,MTPARML              POINT TO PPL\n         SYNCH (R15)                   CALL THE MESSAGE ISSUER\n         B     FINISH                  GO AWAY UPSET\n***********************************************************************\n*        CLOSE THE ACB, CLEAN UP, RETURN.                             *\n***********************************************************************\nBADPARM  LA    R2,16                   RC=16: bad parm\n*\nFINISH   TM    ACBOFLGS,ACBOPEN        ACB OPEN?\n         BZ    FINISH2                 NO, JUMP\n         CLC   DSORG,=AL2(ACBDORGA)    DD allocated dynamically?\n         BNE   FINISH1                 NO, JUMP\n         OI    OPENLIST,X'20'          yes, FREE=CLOSE\nFINISH1  CLOSE MF=(E,OPENLIST)         CLOSE/FREE\nFINISH2  ICM   R1,B'1111',RPLAREA      buffer address\n         BZ    FINISH8                 NO, JUMP\n         L     R0,RPLBUFL              BUFFER LENGTH\n         FREEMAIN RU,LV=(0),A=(1)      FREE RECORD AREA\nFINISH8  LR    R1,R13                  ADDRESS OF DYNAMIC AREA\n         L     R13,4(,R13)             CALLER'S SAVE AREA\n         FREEMAIN RU,LV=DYNAML,A=(1)   FREE DYNAMIC STORAGE AREA\n         LR    R15,R2                  PASS RETURN CODE\n         RETURN (14,12),RC=(15)        GOBACK TO CALLER\n***********************************************************************\n*        Retrieve dsname from the JFCB                                *\n***********************************************************************\nGETDSN   BAKR  R14,0\n         GETDSAB DDNAME=ACBDDNM,       get the DSAB address            +\n               MF=(E,GETDSABL),        work area                       +\n               DSABPTR=DSAB1           output area\n         LTR   R15,R15                 DD missing?\n         BNZ   GETDSN9                 yes, quit\n         L     R2,DSAB1                A(DSAB)\n         USING DSAB,R2\n         LA    R3,WORKAREA             WORK AREA\n         ST    R3,WORD1                STORE POINTER\n         USING ZB505,R3\n         XC    SWAEPAX,SWAEPAX         CLEAR 28 BYTES\n         L     R1,DSABTIOT             TIOT entry\n         MVC   SWVA,TIOEJFCB-TIOENTRY(R1) move SVA of the JFCB\n         SWAREQ FCODE=RL,EPA=WORD1,MF=(E,SWAREQL1),UNAUTH=YES\n         L     R1,SWBLKPTR             LOAD SWA CONTROL BLOCK ADDRESS\n         MVC   DSNAME,0(R1)            move dsname from JFCB\nGETDSN9  PR\n         DROP  R2,R3                   DSAB,ZB505\n***********************************************************************\n*        MODEL CONTROL BLOCKS, MOVED TO DYNAMIC STORAGE               *\n***********************************************************************\nMODELACB ACB DDNAME=INITKSDS,MACRF=(ADR,SEQ,IN,OUT),EXLST=EXLST1\nMODELACB_LENGTH EQU *-MODELACB\nMODELRPL RPL ACB=*-*,OPTCD=(KEY,SEQ,MVE),AREA=*-*,AREALEN=*-*,ARG=*-*\nMODELRPL_LENGTH EQU *-MODELRPL\nEXLST1   EXLST EODAD=CLOSE\n***********************************************************************\n*        DEFINE MESSAGES TO BE ISSUED VIA IKJEFF02                    *\n***********************************************************************\nMSGCSECT IKJTSMSG ('MSG000 ',,' SUCCESSFULLY INITIALIZED.'),00\n         IKJTSMSG ('MSG008 OPEN FAILED FOR ',,                         X\n               ', RETURN CODE IS ',,'.'),OPEN\n         IKJTSMSG ('MSG012 ',,' REQUEST FAILED FOR ',,                 X\n               ', FDBK=',,'.'),REQ\n         IKJTSMSG ('MSG021 ',,' IS NOT A VSAM KSDS.'),NVS\n         IKJTSMSG ('MSG034 ',,' IS NOT AN EMPTY VSAM DATA SET.'),FULL\n         IKJTSMSG ('MSG099 DYNALLOC FAILED FOR ',,'.'),99\n         IKJTSMSG\n***********************************************************************\n*        DEFINE INPUT PARAMETERS FOR IKJPARS                          *\n***********************************************************************\nPCLCSECT IKJPARM\nPCLCSECT RMODE ANY\nDSNPCE   IKJPOSIT DSNAME,USID,PROMPT='DATA SET NAME'\nRSTPCE   IKJKEYWD\n         IKJNAME 'NORESET'\n         IKJNAME 'RESET',ALIAS=('ERASE','DELETE')\nSTATPCE  IKJKEYWD\n         IKJNAME 'SHR'\n         IKJNAME 'OLD'\n         IKJENDP\n***********************************************************************\n*        DYNAMIC STORAGE AREA                                         *\n***********************************************************************\nDYNAM    DSECT\n         DS    18F                     SAVE AREA\nWORD1    DS    F                       ANSWER AREA\nDYNECB   DS    A                       ECB for parse, IKJEFF02\nRETCODE  DS    F                       RETURN CODE\nDSAB1    DS    A(DSAB)                 addr of the DSAB\nPGMCMD   DS    C                       P=PGM C=CMD\nRESET    DS    C                       R=RESET N=NORESET\n*\nSTATUS   DS    AL2(DALSTATS,1,1,X'0800') STATUS KEY, SHR OR OLD\nTU02DSN  DS    AL2(DALDSNAM,1,44)   +0 DATA SET NAME KEY\nDSNAME   DS    CL44                 +6 DATA SET NAME\nTU55DDN  DS    AL2(DALRTDDN,1,8)    +0 RETURN DDNAME\nDDNAME   DS    C'SYS45678'          +6 DDNAME\nTU57ORG  DS    AL2(DALRTORG,1,2)    +0 RETURN DSORG\nDSORG    DS    X'0000'              +6 VDSORG\n*\nREQUEST  DS    C'ERASE'                VSAM REQUEST\nMAXRECNO DS    F'12345678'          +0 MAX RECORD NUMBER       (SHOWCB)\nMAXLRECL DS    F'32760'             +4 MAX LRECL               (SHOWCB)\n         IKJEFFMT MTDSECT=NO,MTFORMAT=NEW\n         IKJEFFDF DFDSECT=NO,DFDSEC2=NO\nOPENLIST OPEN   IFGACB,MF=L            OPEN LIST\n         IFGACB DSECT=NO\n         IFGRPL DSECT=NO\n         GETDSAB MF=(L,GETDSABL)       PARM LIST FOR GETDSAB\nSWAREQL1 SWAREQ MF=L                   PARM LIST FOR SWAREQ\n*\nWORKAREA DS    0D                      All-purpose work area\n         ORG   WORKAREA+PPL_LENGTH\n         ORG   WORKAREA+L'SWAEPAX\n         ORG   WORKAREA+(S99RBEND-S99RB)+4\n         ORG   WORKAREA+TESTCBL\n         ORG   WORKAREA+SHOWCBL\n         ORG   ,                       high water-mark\nDYNAML   EQU   *-DYNAM                 LENGTH OF WORK AREA\n*\n*              MACROS FROM SYS1.MACLIB\n*\n         IKJPPL                        PARSE PARAMETER LIST\nPPL_LENGTH EQU *-PPL\n         IKJCPPL                       COMMAND PROCESSOR PARM LIST\n         IEFZB4D0                      DYNALLOC REQUEST BLOCK\n         IEFZB4D2                      DYNALLOC TEXT UNIT KEYS\n         IEFZB505 LOCEPAX=YES          EPA MAPPING FOR SWAREQ\n         IEFJESCT TYPE=DSECT           JES CONTROL TABLE\n         IEFTIOT1                      TIOT DSECT\n         CVT DSECT=YES,LIST=NO\n         IHADSAB                       DATA SET ASSOCIATION BLOCK\n         YREGS                         REGISTER EQUATES\n         END   INITKSDS\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,5)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//LKEDTEMP EXEC PGM=IEWL,PARM=(MAP,RENT,REFR)\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=&&TEMPLOAD(INITKSDS),DISP=(,PASS),\n// UNIT=VIO,SPACE=(TRK,(1,,1))\n//SYSPRINT DD SYSOUT=*\n//*\n//GOPGM   EXEC PGM=INITKSDS\n//STEPLIB  DD DSN=&&TEMPLOAD,DISP=(OLD,PASS)\n//*NITKSDS DD SPACE=(TRK,100),RECORG=ES,LRECL=100\n//INITKSDS DD SPACE=(TRK,100),RECORG=KS,KEYLEN=12,LRECL=100\n//*\n//GOCMD   EXEC PGM=IKJEFT01\n//STEPLIB  DD DSN=&&TEMPLOAD,DISP=(OLD,PASS)\n//SYSTSIN  DD *\nDEF CL(NAME(CL)    IX)\nREPRO ODS(CL) IFILE(STEPLIB) COUNT(1) REPLACE\nINITKSDS CL RESET\nINITKSDS CL NORESET\nREPRO ODS(CL) IFILE(STEPLIB) COUNT(1)\nINITKSDS CL\nINITKSDS CL RESET\nDELETE CL\n//SYSTSPRT DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//ABNLIGNR DD DUMMY\n//SYSUDUMP DD SYSOUT=*\n//*\n//HLASM2 EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\nTESTPGM  CSECT\n         BASR  12,0\n         USING *,12\n         LA    1,ACB1\n         LINK  EP=INITKSDS\n         SVC   3\nACB1     ACB   DDNAME=KSDS1\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//LKED2   EXEC PGM=HEWLKED\n//SYSLIN   DD DSN=*.HLASM2.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=&&TEMPLOAD(TESTPGM),DISP=(MOD,PASS)\n//SYSPRINT DD SYSOUT=*\n//*\n//GO      EXEC PGM=TESTPGM,REGION=4M\n//STEPLIB  DD DSN=&&TEMPLOAD,DISP=(OLD,PASS)\n//KSDS1    DD SPACE=(TRK,100),RECORG=KS,KEYLEN=12,LRECL=100\n//SYSDEBUG DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//*\n//LKED    EXEC PGM=IEWL,PARM=(LIST,MAP,RENT,REFR)\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=CBTTAPE.FILE183.LOAD(INITKSDS),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IPADDR": {"ttr": 12549, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*************************************************************** REXX *\\\n|*                                                                    *|\n|* Module Name: IPADDR                                                *|\n|*                                                                    *|\n|* Descriptive Name:  Retrieve IP address from Telnet server          *|\n|*                                                                    *|\n|* Status: R300                                                       *|\n|*                                                                    *|\n|* Function: This REXX program uses the NETSTAT command to            *|\n|*           retrieve the IP address which corresponds to the         *|\n|*           current TSO/E session.                                   *|\n|*                                                                    *|\n|* Author: Gilbert Saint-Flour <carlos@gsf-soft.com>                  *|\n|*                                                                    *|\n|* Environment: TSO/E V2                                              *|\n|*              TCP/IP for MVS 3.1 & 3.2                              *|\n|*              OS/390 eNetwork IP V2R5 (TCP/IP 3.5)                  *|\n|*                                                                    *|\n|* Operation: see below                                               *|\n|*                                                                    *|\n|*        IPADDR can be invoked as a command, a sub-routine,          *|\n|*        a function, or an ISPF EDIT macro.  When invoked as         *|\n|*        a command or EDIT macro, IPADDR displays the IP             *|\n|*        address; when invoked as a sub-routine or function,         *|\n|*        IPADDR returns the IP address to the invoker using          *|\n|*        the RETURN instruction.                                     *|\n|*                                                                    *|\n|* Syntax: IPADDR <jobname> <terminal>                                *|\n|*           or                                                       *|\n|*         CALL IPADDR <jobname> <terminal>                           *|\n|*           or                                                       *|\n|*         rc=IPADDR(<jobname>,<terminal>)                            *|\n|*                                                                    *|\n|*          jobname is the jobname of the TCP/IP address space,       *|\n|*            which defaults to the standard TCP/IP default name.     *|\n|*            Specifying an asterisk indicates the default job name.  *|\n|*                                                                    *|\n|*          terminal is the name of the terminal; the default is the  *|\n|*            terminal associated to the current TSO session.         *|\n|*                                                                    *|\n|* Change Activity:                                                   *|\n|*                                                                    *|\n|* 300 Support for OS/390 eNetwork IP V2R5 (TCP/IP 3.5)               *|\n|*                                                                    *|\n\\**********************************************************************/\nARG jobname,termid                     /*  ipaddr(tcpip4,term22)   */\nIF WORDS(jobname)>1 THEN\n  ARG jobname termid                   /*  ipaddr(tcpip4 term22)   */\nIF jobname || termid = '' THEN\n  IF SYSVAR(SYSISPF)='ACTIVE' THEN\n    \"ISREDIT MACRO (jobname termid)\"   /*  EDIT macro              */\nIF jobname='*' THEN\n  jobname=''                           /*  Default IP Stack        */\nUPPER jobname termid\n  /*----------------------------------------------------------------*\\\n  |*              Retrieve TCP/IP Version                           *|\n  \\*----------------------------------------------------------------*/\ncvt = C2D(STORAGE(10,4))                 /*  CVTPTR                 */\necvt = C2D(STORAGE(D2X(cvt+140),4))      /*  CVTECVT                */\ntsab = C2D(STORAGE(D2X(ecvt+176),4))     /*  ECVTTCP                */\nIF tsab>0 THEN DO\n  tseb=tsab+64                           /*  1st TSEB               */\n  tsebname=STORAGE(D2X(tseb+16),8)       /*  TSEB_TCPIP_NAME        */\n  version=C2X(STORAGE(D2X(tseb+26),2))   /*  TSEB_TCPIP_VERSION     */\n  END\nELSE DO\n  tsebname='TCPIP'                       /*  TSEB_TCPIP_NAME        */\n  version=0301                           /*  TSEB_TCPIP_VERSION     */\n  END\nIF termid='' THEN termid = SYSVAR(SYSTERMID)\nIF jobname='' THEN\n  SAY 'Terminal:' termid ' TCP/IP name:' tsebname ' Version:' version\nELSE\n  SAY 'Terminal:' termid ' TCP/IP name:' jobname ' Version:' version\n\nIF jobname='' & tsebname \\= 'TCPIP' THEN DO\n  IF LISTDSI('SYSTCPD' 'FILE') = 16 THEN\n    jobname = tsebname\n  END\nIF jobname\\='' THEN jobname='TCP' jobname\n\naddr='';port=''                        /* init IP address and port */\nIF version>0302 THEN\n  CALL OS390_STACK                     /* OS/390 STACK */\nELSE\n  CALL MVS_STACK                       /* version=0301 or 0302 */\nPARSE SOURCE . env .\nIF env\\='COMMAND' THEN\n  RETURN addr                          /* FUNCTION or SUBROUTINE */\nIF addr='' THEN\n  SAY 'IP address not found for terminal' termid\nELSE\n  SAY 'Terminal:' termid ' IP address:' addr ' Port:' port\nEXIT\n  /*----------------------------------------------------------------*\\\n  |*               OS/390 eNetwork IP V2R5 (TCP/IP 3.5)             *|\n  \\*----------------------------------------------------------------*/\nOS390_STACK:\n  cmd=\"NETSTAT TELNET\" jobname \"(LUNAME\" termid\n  SAY SPACE(cmd,1)                     /* display NETSTAT command */\n  x=OUTTRAP('line.')\n  cmd                                  /* execute NETSTAT command */\n  x=OUTTRAP('off')\n  IF rc=0 THEN DO i=1 to line.0\n /* EZZ2803I 014A 1.1.0.6..1797 Establsh 3761 63371 A06TSO02 SC0TCP01 */\n    IF WORD(line.i,4) = 'Establsh' THEN\n      addrport = WORD(line.i,3)\n    ELSE  /* 014A 1.1.0.6..1797 Establsh 3761 63371 A06TSO02 SC0TCP01 */\n      IF WORD(line.i,3) = 'Establsh' THEN\n        addrport = WORD(line.i,2)\n    END\n  IF addrport \\= 'ADDRPORT' THEN\n    PARSE VAR addrport addr '..' port\n  RETURN\n  /*----------------------------------------------------------------*\\\n  |*             MVS TCP/IP stack: Version 3.1 or 3.2               *|\n  \\*----------------------------------------------------------------*/\nMVS_STACK:\n  \"NEWSTACK\"\n  \"NETSTAT TELNET\" jobname \"STACK\"\n  DO QUEUED()\n    PULL line\n     /* EZA0093I 1000 Establshd 192.168.0.6 91 247 0001 SC0TCP01 TSO */\n    IF LEFT(line,3) = 'EZA' THEN DO\n      IF WORD(line,1) = 'EZA0216E' THEN SIGNAL EZA0216E\n      IF termid = WORD(line,8) THEN DO\n        addr = WORD(line,4)\n        LEAVE\n        END\n      END\n    ELSE DO   /* 1000 Establshd 192.168.0.6 91 247 0001 SC0TCP01 TSO */\n      IF WORD(line,1) = 'CANNOT' THEN SIGNAL EZA0216E\n      IF termid = WORD(line,7) THEN DO\n        addr = WORD(line,3)\n        LEAVE\n        END\n      END\n  END\n  \"DELSTACK\"\n  RETURN\n/*EZA0216E CANNOT USE TCP/IP: FATAL INTER-ADDRESS COMMUNICATIONS ERROR*/\n  EZA0216E: SAY line; \"DELSTACK\"; EXIT 16\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IRXEHCIR": {"ttr": 12553, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x17\\x00\\x95\\x14\\x8f\\x01\\t\\x03\\x9f\\x16P\\x00\\xea\\x00;\\x00=\\xc3\\xc2\\xe3\\xf4\\xf7\\xf8@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1995-05-28T00:00:00", "modifydate": "2009-02-08T16:50:17", "lines": 234, "newlines": 59, "modlines": 61, "user": "CBT478"}, "text": "//GILBERTC JOB (ACCT#),IRXEHCIR,\n//*RESTART=UPDTE,\n//*RESTART=COB2,\n// CLASS=A,MSGCLASS=H,COND=(0,NE),\n// NOTIFY=&SYSUID\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = IRXEHCIR                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = Interface to IKJEHCIR for REXX and COBOL         *\n*                                                                     *\n* FUNCTION = This module allows a REXX EXEC or a COBOL program to     *\n*            invoke IKJEHCIR, the TSO/E Catalog Information Routine.  *\n*            IKJEHCIR is described in TSO/E Programming Services.     *\n*                                                                     *\n* STATUS = R101                                                       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = MVS/370, MVS/XA, MVS/ESA or OS/390                *\n*                                                                     *\n*    AUTHORIZATION = NONE                                             *\n*                                                                     *\n*    RESTRICTIONS = NONE                                              *\n*                                                                     *\n* MODULE TYPE = PROCEDURE (CSECT type)                                *\n*                                                                     *\n*    PROCESSOR = OS/VS Assembler (XF) or,                             *\n*                IBM OS/ASSEMBLER H VERSION 2 or                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 1K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE ANY, AMODE 31,                   *\n*                 PROBLEM STATE, KEY 8                                *\n*                                                                     *\n* SYNTAX = See below                                                  *\n*                                                                     *\n*      REXX:                                                          *\n*                                                                     *\n*        ADDRESS LINKPGM                                              *\n*        \"IRXEHCIR OPTIONS DSNAME CATNAME WORKAREA SAVEAREA PASSWORD\" *\n*                                                                     *\n*      COBOL:                                                         *\n*                                                                     *\n*        CALL \"IRXEHCIR\" USING OPTIONS                                *\n*                              DSNAME                                 *\n*                              CATNAME                                *\n*                              WORKAREA                               *\n*                              SAVEAREA                               *\n*                              PASS-WORD                              *\n*                                                                     *\n* OPERATION = See Below                                               *\n*                                                                     *\n*        IRXEHCIR moves the first parameter to the first word         *\n*        of the user's parameter list and passes control to           *\n*        the IKJEHCIR module.                                         *\n*                                                                     *\n***********************************************************************\nIRXEHCIR CSECT\nIRXEHCIR RMODE ANY\n         L     R15,0(,R1)              A(OPTIONS)\n         MVC   0(4,R1),0(R15)          MOVE OPTIONS TO PARM LIST\n         L     R15,CVTPTR              CVT pointer\n         L     R15,CVTEHCIR-CVTMAP(,R15) V(IKJEHCIR)\n         BR    R15                     CALL THE CIR\n         DC    C'GSF UTILITIES - IRXEHCIR R101'\n         PRINT NOGEN\n         CVT   DSECT=YES               Communication Vector Table\n         YREGS                         Register Equates\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//*       LINK IRXEHCIR into private loadlib\n//*\n//LKED    EXEC PGM=IEWL,PARM=(RENT,REFR)\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=CBTTAPE.FILE183.LOAD(IRXEHCIR),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//*--------------------------------------------------------------------*\n//*                                                                    *\n//*       Load sample EXEC into temp PDS                               *\n//*                                                                    *\n//*--------------------------------------------------------------------*\n//UPDTE   EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSUT2   DD UNIT=VIO,SPACE=(TRK,(1,,1)),DISP=(,PASS),BLKSIZE=3200\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n./ ADD NAME=SAMPLE\n /* This sample REXX EXEC demonstrates how the IRXEHCIR routine     */\n /* can be used to retrieve data set names and volume information   */\n /* from the catalog for a given high-level qualifier such as       */\n /* \"SYS1\" or \"GILBERT.TEMP\".                                       */\nARG HLQ                             /*  GET SEARCH ARGUMENT         */\nDSNAME = LEFT(HLQ,44)               /*  make it a 44-char name      */\nCATNAME = COPIES(' ',44)            /*  CATALOG NAME                */\n\n     /* Note: for format-2 work-area, see OW16574 */\n\nWORKALEN = 65535                    /*  LENGTH OF THE WORK-AREA     */\nWORKAREA = LEFT(D2C(WORKALEN,2),WORKALEN,'00'X)\nSAVEAREA = COPIES('00000000'X,18)\nPASSWORD = '0000000000000000'X\nOPTIONS  = '06000000'X              /* FUNCTION CODE 06             */\n\nADDRESS LINKPGM,\n  \"IRXEHCIR OPTIONS DSNAME CATNAME WORKAREA SAVEAREA PASSWORD\"\nIF RC>0 THEN DO\n  SAY 'RC='RC 'RSN='C2X(OPTIONS)\n  EXIT RC\n  END\n /*                                                                 */\n /* PROCESS DATA RETURNED IN WORK AREA                              */\n /*                                                                 */\nUSEDLEN = C2D(SUBSTR(WORKAREA,3,2)) /* GET AMOUNT OF WORK AREA USED */\nPOS1=5                            /* STARTING POSITION             */\nDO WHILE POS1 < USEDLEN           /* DO UNTIL ALL DATA IS PROCESSED*/\n\n  TYPE = SUBSTR(WORKAREA,POS1,1)    /* EXTRACT ENTRY TYPE         */\n  DSNAME = SUBSTR(WORKAREA,POS1+1,44)  /* EXTRACT ENTRY NAME      */\n  NUMVOL = SUBSTR(WORKAREA,POS1+45,1)  /* EXTRACT NUMBER OF VOLS  */\n  NUMVOL = C2D(NUMVOL)                 /* convert to decimal      */\n  DEVTYPE= SUBSTR(WORKAREA,POS1+46,4)  /* EXTRACT DEVICE TYPE     */\n  VOLSER = SUBSTR(WORKAREA,POS1+50,6)  /* EXTRACT VOLSER          */\n  FILESEQ= SUBSTR(WORKAREA,POS1+56,2)  /* EXTRACT VOLSER          */\n    SAY TYPE DSNAME C2X(DEVTYPE) VOLSER C2X(FILESEQ)\n  POS1 = POS1+1+44+1+4+6+2          /* NEXT ENTRY                 */\nEND    /*  DO WHILE POS1 < USEDLEN    */\n/*\n//*--------------------------------------------------------------------*\n//*                                                                    *\n//*       Execute sample EXEC                                          *\n//*                                                                    *\n//*--------------------------------------------------------------------*\n//GO      EXEC PGM=IKJEFT01\n//STEPLIB  DD DSN=*.LKED.SYSLMOD,DISP=SHR\n//SYSPROC  DD DSN=*.UPDTE.SYSUT2,DISP=(OLD,PASS)\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%SAMPLE GILBERT                                 /* high-level qualifier\n//*--------------------------------------------------------------------*\n//*                                                                    *\n//*       Compile COBOL sample program                                 *\n//*                                                                    *\n//*--------------------------------------------------------------------*\n//COB2 EXEC PGM=IGYCRCTL,\n// PARM='QUOTE,DYNAM,RES,NOSEQ,DATA(24),BUF(10000),NAME'\n       IDENTIFICATION DIVISION.\n        PROGRAM-ID. CB2EHCIR.\n       ENVIRONMENT DIVISION.\n     ***   This sample COBOL program demonstrates how the IRXEHCIR\n     ***   routine can be used to retrieve data set names and\n     ***   volume information from the catalog for a given\n     ***   high-level qualifier such as \"SYS1\" or \"GILBERT.TEMP\".\n       DATA DIVISION.\n        WORKING-STORAGE SECTION.\n         01 OPTIONS.\n            05 FILLER  PIC X VALUE X\"06\".\n            05 FILLER  PIC X VALUE X\"00\".\n            05 FILLER  PIC X VALUE X\"00\".\n            05 RETCODE PIC X VALUE X\"00\".\n         01 DSNAME  PIC X(44).\n         01 CATNAME PIC X(44) VALUE SPACES.\n         01 WORKAREA.\n            05 WORKALEN PIC XX VALUE HIGH-VALUES.\n            05 USEDLEN  PIC XX VALUE LOW-VALUES.\n            05 FILLER OCCURS 1000 INDEXED BY I.\n               10 ENTRY-TYPE PIC X.\n               10 ENTRY-NAME PIC X(44).\n               10 ENTRY-VOLCT   PIC X.\n               10 ENTRY-DEVTYPE PIC X(4).\n               10 ENTRY-VOLSER  PIC X(6).\n               10 ENTRY-FILESEQ PIC S999 COMP.\n         01 SAVEAREA PIC X(72).\n         01 PASS-WORD PIC X(8).\n         01 VOLCT-X.\n            02 VOLCT  PIC S999 COMP.\n       PROCEDURE DIVISION.\n           ACCEPT DSNAME FROM SYSIN.\n           DISPLAY 'CB2EHCIR started - About to CALL IRXEHCIR'\n           CALL \"IRXEHCIR\" USING OPTIONS\n                                 DSNAME\n                                 CATNAME\n                                 WORKAREA\n                                 SAVEAREA\n                                 PASS-WORD.\n           DISPLAY 'Returned from IRXEHCIR - RC=' RETURN-CODE\n           IF RETURN-CODE = 0 THEN\n             PERFORM VARYING I FROM 1 BY 1\n                     UNTIL ENTRY-TYPE(I) = HIGH-VALUES\n               MOVE ENTRY-VOLCT(I) TO VOLCT-X(2:1)\n               DISPLAY ENTRY-TYPE(I) \" \"\n                       ENTRY-NAME(I) \" \"\n                       VOLCT \" \"\n                       ENTRY-VOLSER(I) \" \"\n                       ENTRY-FILESEQ(I)\n             END-PERFORM\n           END-IF\n           STOP RUN.\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSUT4   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSUT5   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSUT6   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSUT7   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSLIN   DD DISP=(,PASS),UNIT=VIO,SPACE=(TRK,1),DCB=BLKSIZE=3200\n//*\n//LKED   EXEC PGM=HEWLKED,PARM=(REUS,MAP)\n//SYSLIN   DD DSN=*.COB2.SYSLIN,DISP=(OLD,PASS)\n//SYSLIB   DD DSN=CEE.SCEELKED,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSLMOD  DD DSN=&&SYSLMOD,DISP=(,PASS),UNIT=VIO,SPACE=(TRK,(1,,1))\n//SYSPRINT DD SYSOUT=*\n//*\n//*      Execute COBOL program\n//*\n//*      PARM='/STACK(,,BELOW)' is required in z/OS\n//*\n//GO     EXEC PGM=CB2EHCIR,PARM='/STACK(,,BELOW)'\n//STEPLIB  DD DSN=&&SYSLMOD,DISP=(OLD,DELETE)                CB2EHCIR\n//         DD DSN=CBTTAPE.FILE183.LOAD,DISP=SHR              IRXEHCIR\n//SYSOUT   DD SYSOUT=*\n//CEEDUMP  DD SYSOUT=*\n//*YSUDUMP DD SYSOUT=*\nGILBERT.CTC                                     <- high-level qualifier\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISGECMON": {"ttr": 12801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x943\\x1f\\x00\\x943\\x1f\\x16Q\\x00\\x1b\\x00$\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf0\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-27T00:00:00", "modifydate": "1994-11-27T16:51:00", "lines": 27, "newlines": 36, "modlines": 0, "user": "CBT400"}, "text": "//GILBERTE JOB (ACCT#),ISGECMON,\n// NOTIFY=&SYSUID,\n//*RESTART=GO,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//*\n//* ASSEMBLE THE ENQ MONITOR IN SYS1.SAMPLIB(ISGECMON)\n//*\n//ASMH EXEC PGM=IEV90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n//SYSIN    DD *\n         MACRO\n         MODID &BR=NO\n         B    *+28\n&YYMMDD  SETC '&SYSDATE'(7,2)'/'.'&SYSDATE'(1,5)\n         DC   CL24'&SYSECT &YYMMDD &SYSTIME '\n         MEND\n//         DD DSN=SYS1.SAMPLIB(ISGECMON),DISP=SHR\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//LKED    EXEC PGM=LINKLLA,PARM='RENT,AC=1'\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=SYS2.ADP.LOADLIB(ISGECMON),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ISPCMDL": {"ttr": 12803, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00W\\x00\\x95\\x19\\x1f\\x01\\x126/\\x16\\x06\\x00&\\x00\\x10\\x00\\x00\\xd7\\xf3\\xf9\\xf0\\xc1@@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1995-07-10T00:00:00", "modifydate": "2012-12-27T16:06:57", "lines": 38, "newlines": 16, "modlines": 0, "user": "P390A"}, "text": "/* list commands in ispf in-storage command table          REXX */\n\n arg opt  /* any options ?? */\n address command\n address ispexec\n 'vget ztempf'\n 'tbtop ispcmds'\n i=1\n r.i=left(\"Verb\",8,\".\") left(\"Len\",3,\".\"),\n     left(\"Action\",50,\".\") left(\"Desc\",15\".\")\n\n do forever\n   'tbskip ispcmds'\n   if rc > 0 then leave\n   i=i+1\n   r.i=left(zctverb,8) left(zcttrunc,3),\n       left(zctact,50) left(zctdesc,15)\n end\n\n address tso\n \"alloc dd(zcmdl) da('\"ztempf\"') shr reuse\"\n if rc > 0 then do\n   call ispmsg \"*failure to allocate\" ztempf\n   exit\n end\n\n do n=1 to i; queue r.n; end\n \"execio\" queued() \"diskw zcmdl (finis\"\n \"free  dd(zcmdl)\"\n\n if opt = \"E\" | opt = \"EDIT\" then,\n   address ispexec \"edit dataset('\"ztempf\"')\"\n else,\n if opt = \"R\"  then,\n                   \"review  '\"ztempf\"'\"\n else,\n   address ispexec \"browse dataset('\"ztempf\"')\"\n return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPCMDSJ": {"ttr": 12805, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x85\\x13O\\x00\\x96#o\\t\"\\x01\\x1e\\x00\\xe0\\x00\\xbd\\xc3\\xc2\\xe3\\xf4\\xf5\\xf1@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1985-05-14T00:00:00", "modifydate": "1996-08-23T09:22:00", "lines": 286, "newlines": 224, "modlines": 189, "user": "CBT451"}, "text": "//GILBERTI JOB (ACCT#),ISPCMDSJ,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(0,NE)\n//**********************************************************************\n//*                                                                    *\n//*    THIS JOB CREATES ISPF.TABLES(ISPCMDS) BY MERGING A SET          *\n//*    OF IN-LINE COMMANDS WITH THE ORIGINAL ISPF COMMAND TABLE.       *\n//*                                                                    *\n//**********************************************************************\n//ISPCMDS EXEC PGM=IKJEFT01\n//*---------------------------------------------------------------------\n//*\n//*        UPDATE THESE DSNAMES FOR YOUR SITE\n//*\n//*---------------------------------------------------------------------\n//ISPTLIB  DD DISP=SHR,DSN=ISP.SISPTENU              <== INPUT\n//*\n//ISPTABL  DD DISP=SHR,DSN=CONVTEK.PRISM-CS.TABLES      <== OUTPUT\n//*\n//ISPMLIB  DD DISP=SHR,DSN=ISP.SISPMENU              <== MESSAGES\n//*---------------------------------------------------------------------\n//*\n//*       THESE ARE THE NEW COMMANDS THAT WILL BE MERGED\n//*       INTO THE NEW ISPCMDS TABLE.\n//*\n//*---------------------------------------------------------------------\n//UPDATES DD *\nPDF      0 SELECT PANEL(ISR@PRIM) OPT(&ZPARM) NEWAPPL(ISR)\n           PDF MAIN MENU\nED       0 SELECT PGM(FASTPATH) PARM(EDIT,&ZPARM)\n           FAST PATH COMMAND: EDIT\nBR       0 SELECT PGM(FASTPATH) PARM(BROWSE,&ZPARM)\n           FAST PATH COMMAND: BROWSE\nVI       0 SELECT PGM(FASTPATH) PARM(VIEW,&ZPARM)\n           FAST PATH COMMAND: VIEW\nWP       0 SELECT PGM(FASTPATH) PARM(WP,&ZPARM)\n           FAST PATH COMMAND: ISPF WORKPLACE\nICS      0 SELECT PGM(FASTPATH) PARM(ICS,&ZPARM)\n           FAST PATH COMMAND: ICS\nFSHELP   0 SELECT PGM(FASTPATH) PARM(FSHELP,&ZPARM)\n           FULL-SCREEN HELP\nMACLIB   3 SELECT PGM(FASTPATH) PARM(MACLIB,&ZPARM)\n           FAST PATH COMMAND: VIEW MACLIB/MODGEN MACRO\nSDSF     2 SELECT PGM(FASTPATH) PARM(SDSF,&ZPARM)\n           FAST PATH COMMAND: SDSF\nUTIL     2 SELECT PGM(FASTPATH) PARM(UTIL,&ZPARM)\n           FAST PATH COMMAND: PDF UTILITIES\nWHOAMI   3 SELECT CMD(%WHOAMI &ZPARM)\n           DISPLAY SYSTEM ID AND USER ID IN LARGE LETTERS\nRECEIVE  4 SELECT CMD(RECEIVE &ZPARM) MODE(FSCR)\n           TSO INTERACTIVE TRANSMIT/RECEIVE FACILITY\nIND$FILE 0 SELECT CMD(IND$FILE &ZPARM) MODE(FSCR)\n           PC/3270\nLISTALC  5 SELECT PGM(PGMEDBRO) PARM(L,AMSLISTA,AMSLISTA)\n           FULL SCREEN TSO LISTALC\nLISTBC   5 SELECT CMD(LISTBC &ZPARM) MODE(FSCR)\n           FULL SCREEN TSO LISTBC\nSEND     0 SELECT CMD(%AMSSEND &ZPARM) NEWAPPL(ISR)\n           FULL SCREEN TSO SEND\nXMIT     0 SELECT CMD(%AMSXMIT &ZPARM) NEWAPPL(ISR)\n           FULL SCREEN TSO XMIT\nMAIL     0 SELECT CMD(%NEWAPPL MAIL) NEWAPPL(MAIL)\n           TSO/MAIL\nHANDBOOK 5 SELECT PGM(FASTPATH) PARM(B,IBMUSER.HANDBOOK(&ZPARM))\n           ON-LINE MACRO LISTING\nVOLS     0 SELECT CMD(%AMSVOLS &ZPARM) NEWAPPL(ISR)\n           VOLS COMMAND\nPDS      0 SELECT CMD(%NEWAPPL PDS)\n           PDS UTILITY\nCZX      0 SELECT CMD(%NEWAPPL CORTEX &ZPARM) NEWAPPL(CZX)\n           CORTEX PRIMARY MENU\nRMFMON   3 SELECT CMD(RMFMON &ZPARM) MODE(FSCR)\n           RMF\nENQ      0 SELECT CMD(ENQ) MODE(FSCR)\n           ENQ COMMAND\nUSL      0 SELECT PGM(PGMEDBRO) PARM(E,USL,&ZPARM,STD)\n           EDIT A USERLIB MEMBER\nDOC      0 SELECT PGM(PGMEDBRO) PARM(E,DOC,&ZPARM,TEXT)\n           EDIT A DOCLIB MEMBER\nTXT      0 SELECT PGM(PGMEDBRO) PARM(E,TXT,&ZPARM,STD)\n           EDIT A DTXTPRMT MEMBER\nPROC     0 SELECT PGM(PGMEDBRO) PARM(E,PRC,&ZPARM,STD)\n           EDIT A IBMUSER.SITE.MJCLPRC MEMBER\nTEL      0 SELECT PGM(PGMEDBRO) PARM(B,USL,TEL)\n           BROWSE THE TELEPHONE DIRECTORY\nMEMOS    4 SELECT PGM(PGMEDBRO) PARM(E,MEMO,&ZPARM,TEXT)\n           EDIT A MEMO\nRDR      0 SELECT PGM(PGMEDBRO) PARM(E,RDR,&ZPARM,STD)\n           EDIT A DJCLRDR MEMBER\nIPT      0 SELECT PGM(PGMEDBRO) PARM(E,IPT,&ZPARM,STD)\n           EDIT A DJCLIPT MEMBER\nTIME     0 SELECT CMD(%AMSTIME)\n           DISPLAY TIME AND DATE\nCNTL     0 SELECT CMD(%AMSCNTL &ZPARM) NEWAPPL(ISR)\n           EDIT ISPCTL0 DATA SET, EVEN IF VIO\nLMCOPY   3 SELECT PANEL(LMCOPY) NEWAPPL(ISR)\n           ISSUE LMCOPY COMMAND\nCZXMSG   0 SELECT PGM(CZX2PMID) PARM(&ZPARM) NOFUNC\n           DISPLAY MVS-MS MESSAGE\nPGM      0 SELECT CMD(%XYZ2L053 &ZPARM) NEWAPPL(CZX)\n           INVOKE PROGRAM MANAGEMENT PANEL OUTSIDE MVS-MS\nIPCS     4 SELECT CMD(%NEWAPPL IPCS) NEWAPPL(BLSG)\n           INVOKE IPCS COMMAND\nISMF     0 SELECT CMD(%NEWAPPL ISMF) NEWAPPL(DGT)\n           INVOKE ISMF DIALOGS\nRACF     0 SELECT CMD(%NEWAPPL RACF) NEWAPPL(RACF)\n           INVOKE RACF DIALOGS\nHSM      0 SELECT CMD(%NEWAPPL HSM) NEWAPPL(HSM)\n           INVOKE HSM DIALOGS\nSMPE     3 SELECT CMD(%NEWAPPL SMPE) NEWAPPL(GIM)\n           INVOKE SMP/E DIALOGS\nICQ      0 SELECT CMD(%NEWAPPL ICQ) NEWAPPL(ICQ)\n           INVOKE TSO/E DIALOGS\nDITTO    3 SELECT CMD(%NEWAPPL DITTO) NEWAPPL(DUT)\n           INVOKE DITTO/MVS DIALOGS\nTLMS     0 SELECT CMD(%NEWAPPL TLMS) NEWAPPL(TLMS)\n           INVOKE TLMS PANELS (NO SPLIT SCREEN)\nLIBR     3 SELECT CMD(%NEWAPPL LIBR) NEWAPPL(LIB@)\n           INVOKE LIBRARIAN /ELIPS PANELS\nELIPS    3 SELECT CMD(%NEWAPPL LIBR) NEWAPPL(LIB@)\n           INVOKE LIBRARIAN /ELIPS PANELS\nSHOWMVS  5 SELECT PGM(SHOWMVS) PARM(&ZPARM)\n           INVOKE SHOWMVS PROGRAM\nJCL      0 SELECT PGM(FASTPATH) PARM(E,&ZUSER..JCL(&ZPARM),STD)\n           EDIT \"USERID.JCL\"\nSCRIPT   0 SELECT PGM(ISRFPR) PARM((ISRFP09) 9) NEWPOOL\n           ISSUE SCRIPT COMMAND\nPLIB     0 SELECT PGM(FASTPATH) PARM(E,&ZUSER..PANELS(&ZPARM),STD)\n           EDIT \"USERID.PANELS\"\nSLIB     0 SELECT PGM(FASTPATH) PARM(E,&ZUSER..SKELS(&ZPARM),STD)\n           EDIT \"USERID.SKELS\"\nMLIB     0 SELECT PGM(FASTPATH) PARM(E,&ZUSER..MSGS(&ZPARM),STD)\n           EDIT \"USERID.MSGS\"\nEXEC     0 SELECT PGM(FASTPATH) PARM(E,&ZUSER..EXEC(&ZPARM),STD)\n           EDIT \"USERID.EXEC\"\nTEXT     0 SELECT PGM(FASTPATH) PARM(E,&ZUSER..TEXT(&ZPARM),STD)\n           EDIT \"USERID.TEXT\"\nCLIST    0 SELECT PGM(FASTPATH) PARM(E,&ZUSER..CLIST(&ZPARM),STD)\n           EDIT \"USERID.CLIST\"\nCA1      0 SELECT CMD(%NEWAPPL CA1) NEWAPPL(TMS)\n           INVOKE CA-1 ISPF INTERFACE\nEPIC     0 SELECT CMD(%NEWAPPL EPIC) NEWAPPL(EPIC)\n           INVOKE EPIC/MVS PANELS\nJOBTRAC  4 SELECT CMD(%NEWAPPL JOBTRAC) NEWAPPL(LJT)\n           INVOKE JOBTRAC APPLICATION\nSAR      0 SELECT CMD(%NEWAPPL SAR &ZPARM) NEWAPPL(SAR)\n           INVOKE SYSOUT ARCHIVAL AND RETRIEVAL SYSTEM\nOMEGAMON 4 SELECT CMD(%NEWAPPL OMEG)\n           OMEGAMON\nPCOMMAND 4 SELECT CMD(%NEWAPPL PCOMMAND)\n           PREVAIL/XP (ALIAS SYSVIEW, PCOMMAND)\nCCCA     0 SELECT CMD(%NEWAPPL CCCA) NEWAPPL(ABJ)\n           COBOL CONVERSION\nSELECT   0 SELECT &ZPARM\n           GSF TEST\nNEWAPPL  4 SELECT CMD(%NEWAPPL &ZPARM )\n           GSF TEST\nPDB      0 SELECT CMD(%APPLPDB SITE(&ZPARM) ) NEWAPPL(CZXG)\n           CORTEX-PDB V5R2M1\n/*\n//*---------------------------------------------------------------------\n//SYSTSPRT DD SYSOUT=*\n//ISPLOG   DD SYSOUT=*,DCB=(RECFM=F,LRECL=121)\n//BEFORE   DD SYSOUT=*\n//AFTER    DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//ISPPROF  DD UNIT=SYSDA,SPACE=(1,(1,1,1)),DISP=(,PASS),\n//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)\n//SYSPROC  DD DISP=(OLD,PASS),DSN=*.ISPPROF,VOL=REF=*.ISPPROF\n//SYSUT2   DD DISP=(OLD,PASS),DSN=*.ISPPROF,VOL=REF=*.ISPPROF\n//DUMMY    DD DUMMY\n//ISPPLIB  DD DISP=(OLD,PASS),DSN=*.ISPPROF,VOL=REF=*.ISPPROF\n//ISPSLIB  DD DISP=(OLD,PASS),DSN=*.ISPPROF,VOL=REF=*.ISPPROF\n//SYSTSIN  DD  *\nCALL 'SYS1.LINKLIB(IEBUPDTE)' 'NEW'\nISPSTART CMD(%ISPCMDS  -\n             OLD(ISPCMDS)         /* OLD TABLE FROM DDN(ISPTLIB)   */+\n             NEW(ISPCMDS)         /* NEW TABLE CREATED IN ISPTABL  */)\n/*\n//SYSIN    DD  *\n./ ADD NAME=ISPCMDS\nPROC 0 OLD() NEW()\nCONTROL NOLIST NOFLUSH\n\nISPEXEC LMINIT DATAID(ISPTLIB) DDNAME(ISPTLIB) ENQ(SHR)\nIF &LASTCC > 0 THEN GOTO SPFERROR\n\nISPEXEC LMINIT DATAID(ISPPROF) DDNAME(ISPPROF) ENQ(EXCLU)\nIF &LASTCC > 0 THEN GOTO SPFERROR\n\nISPEXEC LMINIT DATAID(ISPTABL) DDNAME(ISPTABL) ENQ(EXCLU)\nIF &LASTCC > 0 THEN GOTO SPFERROR\n\nISPEXEC LMCOPY FROMID(&ISPTLIB) FROMMEM(&OLD) -\n               TODATAID(&ISPPROF) TOMEM(WORKCMDS) REPLACE\nIF &LASTCC > 8 THEN GOTO SPFERROR\n\nISPEXEC TBOPEN WORKCMDS WRITE LIBRARY(ISPPROF)\nIF &LASTCC > 0 THEN GOTO SPFERROR\n                                    /**********************************/\nOPENFILE BEFORE OUTPUT              /*                                */\n                                    /*  DISPLAY TABLE BEFORE UPDATES  */\nDO UNTIL (&RC > 0)                  /*                                */\n  ISPEXEC TBSKIP WORKCMDS           /**********************************/\n  SET RC = &LASTCC\n  IF &RC = 0 THEN -\n    DO\n      ISPEXEC TBGET WORKCMDS ROWID(ROW)\n      IF &LASTCC > 0 THEN GOTO SPFERROR\n      SET BEFORE = &SUBSTR(1:9,&ZCTVERB          )\n      SET BEFORE = &STR(&BEFORE &ZCTTRUNC &SYSNSUB(1,&ZCTACT) )\n      PUTFILE BEFORE\n      SET BEFORE = &STR(            &SYSNSUB(1,&ZCTDESC ) )\n      PUTFILE BEFORE\n    END\nEND\nCLOSFILE BEFORE\n /*TROL SYMLIST CONLIST\n                                    /**********************************/\nISPEXEC TBBOTTOM WORKCMDS           /*                                */\nIF &LASTCC > 0 THEN GOTO SPFERROR   /*   READ UPDATES                 */\n                                    /*   ADD THEM TO THE TABLE        */\n                                    /*                                */\nOPENFILE UPDATES                    /**********************************/\nERROR IF &LASTCC=400 THEN GOTO CLOSEUPD\n\nDO UNTIL (&LASTCC=400)\n  GETFILE  UPDATES                  /*       1ST LINE (VERB)          */\n  SET ZCTVERB  = &SUBSTR(1:8,&SYSNSUB(1,&UPDATES) )\n  SET ZCTVERB  = &ZCTVERB\n  SET ZCTTRUNC = &SUBSTR(10:10,&SYSNSUB(1,&UPDATES) )\n  SET ZCTACT   = &SUBSTR(12:72,&SYSNSUB(1,&UPDATES)                   )\n  SET L = &LENGTH(&SYSNSUB(1,&ZCTACT))\n  DO WHILE &SUBSTR(&L:&L,&SYSNSUB(1,&ZCTACT)) = &STR()\n    SET L=&L-1\n  END\n  SET ZCTACT   = &SUBSTR(1:&L,&SYSNSUB(1,&ZCTACT))\n\n  GETFILE  UPDATES                  /*       2ND LINE (DESC)          */\n  SET ZCTDESC  = &SUBSTR(12:72,&SYSNSUB(1,&UPDATES)                   )\n  SET L = &LENGTH(&SYSNSUB(1,&ZCTDESC))\n  DO WHILE &SUBSTR(&L:&L,&SYSNSUB(1,&ZCTDESC)) = &STR()\n    SET L=&L-1\n  END\n  SET ZCTDESC  = &SUBSTR(1:&L,&SYSNSUB(1,&ZCTDESC))\n  ISPEXEC TBADD WORKCMDS\n  IF &LASTCC > 0 THEN GOTO SPFERROR\nEND\n\nCLOSEUPD: ERROR OFF                 /*     CANCEL ERROR TRAPPING     */\nCLOSFILE UPDATES\n\nISPEXEC TBTOP WORKCMDS\nIF &LASTCC > 0 THEN GOTO SPFERROR\n                                    /**********************************/\nOPENFILE AFTER OUTPUT               /*                                */\n                                    /*  DISPLAY TABLE AFTER UPDATES   */\nDO UNTIL (&RC > 0)                  /*                                */\n  ISPEXEC TBSKIP WORKCMDS           /**********************************/\n  SET RC = &LASTCC\n  IF &RC = 0 THEN -\n    DO\n      ISPEXEC TBGET WORKCMDS ROWID(ROW)\n      IF &LASTCC > 0 THEN GOTO SPFERROR\n      SET AFTER = &SUBSTR(1:9,&ZCTVERB           )\n      SET AFTER = &STR(&AFTER &ZCTTRUNC &SYSNSUB(1,&ZCTACT) )\n      PUTFILE AFTER\n      SET AFTER  = &STR(            &SYSNSUB(1,&ZCTDESC) )\n      PUTFILE AFTER\n    END\nEND\nCLOSFILE AFTER\n\nISPEXEC TBCLOSE WORKCMDS LIBRARY(ISPPROF)\nIF &LASTCC > 0 THEN GOTO SPFERROR\n\nISPEXEC LMCOPY FROMID(&ISPPROF) FROMMEM(WORKCMDS) -\n               TODATAID(&ISPTABL) TOMEM(&NEW) REPLACE\nIF &LASTCC > 8 THEN GOTO SPFERROR\n\nEXIT CODE(0)\n\nSPFERROR: +\n  IF &ZERRMSG \u00ac= &STR() THEN ISPEXEC LOG MSG(&ZERRMSG)\n  EXIT CODE(12)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPCMDU": {"ttr": 12811, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01(\\x00@\\x00\\x95\\x19\\x1f\\x01\\x16\\x03/\\x16\\x10\\x00\\xcb\\x00\"\\x00\\x00\\xe6\\xd1@@@@@@@@'", "ispf": {"version": "01.40", "flags": 0, "createdate": "1995-07-10T00:00:00", "modifydate": "2016-02-01T16:10:40", "lines": 203, "newlines": 34, "modlines": 0, "user": "WJ"}, "text": "/* ------------------------------------------------------- rexx\n  Add commands to ISPF in-storage command table ISPCMDS.\n\n  Parameters:\n\n   DA(dsname(member))   Both dataset and membername are\n                        optional. Default datasets is the\n                        ISPPROF datases, default membername\n                        is 'ISPCOMND'.\n   QUIET                Do not show confirmation and statistics.\n   ID(id)               set 'desc' field to id.\n\n  History:\n\n   2005.04.18 Initial\n   2016.01.31 Retain aliases at top\n              Use BPXWDYN instead of ALLOCATE\n\n   ------------------------------------------------------------ */\n\n $table=''\n parse value ' 'translate(arg(1)) with p1 'DA('pmda')' p2\n if right(p2,1)=')' then p2=substr(p2,2)\n parse value p1 p2 with p1 'ID('pmid')' p2\n parse value p1 p2 with p1 ' QUIET ' +0 pmquiet p2\n if p1 p2<>'' then call close 8 'Invalid parm:' space(p1 p2)\n address isredit \"MACRO NOPROCESS\"\n Select\n   when rc = 0 then call Edit_load /* edit macro */\n   when pmda \u00ac= \"\" then call Dsn_Load pmda\n   otherwise call Dsn_Load Locate_Ispprof()\n end\n\n Address IspExec\n \"control errors return\"\n\n Call MakeWorkTable\n\n added=0\n updated=0\n deleted=0\n do i=1 to r.0\n   c = translate(r.i)\n   if word(c,1) = \"/*\" then iterate\n   if c = \"\"           then iterate\n   dlm=substr(c,1,1)\n   parse var c (dlm) verb (dlm) trunc,\n               (dlm) act  (dlm) desc (dlm) .\n   upper verb act\n   if dlm = '-' then call tbldel\n   else call tblupd\n end\n\n Call RebuildTable    /* rewrite ISPCMDS */\n\n Call Close 0 'added('added') updated('updated') deleted('deleted')'\n\nClose:\n parse arg _rc _msg\n Address TSO \"delstack\"\n if $table<>'' then Address IspExec \"tbend\" $table\n parse arg _rc _msg\n if _msg<>'' then call XMsg _msg\n Exit word(_rc 0,1)\n\nTblUpd:\n if locate(verb) = 0 then do\n   call updvars\n   \"tbput\" $table\n   updated=updated+1\n   return\n end\n /* verb not found, add it */\n \"tbtop\" $table\n call updvars\n \"tbadd\" $table\n added=added+1\n return\n\nTblDel:\n if Locate(verb) > 0 then return\n \"tbdelete\" $table\n deleted=deleted+1\n return\n\nUpdVars:\n zctverb=verb\n zcttrunc=trunc\n zctact=act\n rtype='C'\n if desc = \"\" then desc = \"*\"pmid\"*\"\n zctdesc=desc\n return\n\nLocate:\n \"tbtop\" $table\n \"tbvclear\" $table\n arg zctverb .\n \"tbscan\" $table \"arglist(zctverb)\"\n return rc\n\nXMsg:\n if pmquiet<>'' then return 0\n parse arg zedlmsg\n if zedlmsg = '' then return 0\n zedlmsg= 'ISPCMDU' zedlmsg\n address ispexec \"Vput (zedlmsg)\"\n address ispexec \"setmsg msg(isrz000)\"\n return 0\n\nEdit_Load:   /* load data to stem from edit session */\n do i=1 to 9999\n   address isredit '(l) = line' i\n   if rc > 0 then leave\n   r.i = strip(l,t)\n end\n r.0=i-1\n return\n\nDsn_Load:   /* load from library */\n arg d m .\n d = strip(d,\"b\",\"'\")\n if m = '' then m = 'ISPCOMND'\n d = \"'\"d\"(\"m\")'\"\n address tso\n if sysdsn(d)<>'OK' then ,\n   call close 8 'Could not locate file' d\n if BpxWdyn('alloc da('d') shr rtddn(xdd)')<>0 then,\n   call close 8 'Allocate' d 'failed'\n \"execio * diskr\" xdd \"(stem r. finis)\"\n cc = rc\n zz=BpxWdyn('free dd('xdd')')\n if cc<>0 then call close 8 'Reading' d 'failed rc' cc\n return 0\n\nLocate_Ispprof:   /* locate profile dataset */\n x=outtrap('ddl.')\n Address TSO \"lista st\"\n x=outtrap('off')\n do i=1 to ddl.0\n   c = word(ddl.i,1)\n   if pos(\".\",c) > 0 then iterate /* not ddname */\n   if c = \"ISPPROF\" then do\n     i = i-1\n     return ddl.i\n   end\n end\n return \"\"\n\nMakeWorkTable:  /* copy system ISPCMDS */\n $table='T'left(space(translate(time('l'),' ','.:'),0),7)\n Address IspExec\n \"tbcreate\" $table \"names(rtype zctverb zcttrunc zctact zctdesc)\"\n \"tbtop ispcmds\"\n do forever\n   \"tbskip ispcmds\"\n   if rc<>0 then leave\n   if word(zctact,1)='ALIAS' then rtype='A'  /* alias   */\n   else rtype='C'                     /* command */\n   \"tbadd\" $table\n end\n \"tbtop\" $table\n return 0\n\nRebuildTable:  /* rewrite system ISPCMDS */\n Address IspExec\n /* clear system table */\n \"tbbottom ispcmds\"\n do forever\n   \"tbdelete ispcmds\"\n   if rc<>0 then leave\n end\n /* build system table */\n \"tbsort\" $table \"FIELDS(RTYPE,C,A,ZCTVERB,C,A) \"\n \"tbtop\"  $table\n do forever\n   \"tbskip\" $table\n   if rc<>0 then leave\n   \"tbadd ispcmds\"\n end\n \"tbtop ispcmds\"\n return 0\n Call ListTable 'ispcmds'\n return 0\n\nListTable: Procedure   /* list in-storage command table */\n arg name\n address ispexec\n 'tbtop' name\n i=1\n r.i='T' left(\"Verb\",8,\".\") left(\"Len\",3,\".\"),\n     left(\"Action\",50,\".\") left(\"Desc\",15\".\")\n do forever\n   'tbskip' name\n   if rc > 0 then leave\n   i=i+1\n   r.i=left(rtype,1) left(zctverb,8) left(zcttrunc,3),\n       left(zctact,50) left(zctdesc,15)\n end\n r.0=i\n Address TSO\n CALL STEMEDIT 'BROWSE','R.',,,'Command table' name\n return 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPCOMND": {"ttr": 13057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00R\\x01\\x10\\x04o\\x01\\x126\\x1f\\x12B\\x00C\\x00?\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2010-02-15T00:00:00", "modifydate": "2012-12-26T12:42:52", "lines": 67, "newlines": 63, "modlines": 0, "user": "SBGOLOB"}, "text": "/*    MEMBER TO UPDATE THE ISPF COMMAND TABLE IN STORAGE  */\n/*  ------ you should enjoy using this immensely ------   */\n/*  ------     Invoke by issuing TSO ISPCMDU     ------   */\n/FVE/0/SELECT CMD(%FVE PARM &ZPARM) NEWAPPL(ISR)/Fast-ViewEdit\n/FP/0/SELECT PGM(FASTPATH)/FASTPATH\n/IQI/0/SELECT PANEL(IQI@PRIM) NEWAPPL(IQI)/Spiffy\n/FMN/0/SELECT PANEL(FMNSTASK) NEWAPPL(FMN)/File Manager\n/MVSXREF/4/SELECT PANEL(XREFPRIM)/MVSXREF/\n/JCLXREF/4/SELECT PANEL(JXRFPRIM)/JCLXREF/\n/NPHELP/4/SELECT PANEL(NOTEPADH)/Notepad/\n/NPANEL/4/SELECT PANEL(NOTEPAD) NEWAPPL(NOTE)/Notepad/\n/NOTEPAD/4/SELECT CMD(%NOTEPAD &ZPARM) NEWAPPL(NOTE)/Notepad/\n/PROFSRCH/5/SELECT CMD(%THSPROFS &ZPARM) NEWAPPL(ISR) PASSLIB/Profile Srch/\n/XSP/0/SELECT PANEL(PDS@PRIM) NEWAPPL(XSP)/SWITCH APPLID/\n/REASM/3/SELECT PGM(REASM) NEWAPPL(REA)/Reasm 4.0/\n/FDSPACE/3/SELECT CMD(FDSPACE)/Disk Space and contents/\n/SMPE/3/SELECT PGM(GIMSTART) PARM(&ZCMD) NOCHECK/SMP/E Dialogs/\n/UMB/0/SELECT CMD(UMSGN)/Browse message member in MESAJ.PDS/\n/UMSG/2/SELECT CMD(UMSG)/Browse message member in MESAJ.PDS/\n/ISMF/0/SELECT PGM(DGTFMD01)/ISMF ISPF DIALOG/\n/STACK/3/SELECT PANEL(ISR@PRIM)/STACK A MAIN ISPF PANEL/\n/DITTO/3/SELECT PGM(DITTO) /DITTO-ESA/\n/SPACE/0/SELECT PANEL(SSCSPC01) SCRNAME(SPACE)/SPACE TSO command/\n/MXI/0/SELECT CMD(MXI)/MXI Invocation/\n/RACF/2/SELECT PANEL(ICHP00) NEWAPPL(RACF)/RACF Admin Panels/\n/SHZOS/0/SELECT CMD(SHOWZOS &ZPARM) MODE(FSCR)/INVOKE SHOWMVS COMMAND/\n/SHOWMVS/5/SELECT CMD(SHOWMVS &ZPARM) MODE(FSCR)/INVOKE SHOWMVS COMMAND/\n/SHO9716/4/SELECT CMD(SHO9716 &ZPARM) MODE(FSCR)/INVOKE SHOWMVS COMMAND/\n/SDSF/0/SELECT PGM(ISFISP) NEWAPPL(ISF)/INVOKE SDSF UNDER ISPF/\n/PRIM/3/SELECT PANEL(ISR@PRIM)/main ispf panel/\n/PDE/0/SELECT PANEL(PDS@PRIM)/STARTOOL OR PDS 8.5 MAIN ENTRY PANEL/\n/PT1/0/SELECT PANEL(PTOOLS01)/SYSTEM PROGRAMMER TOOLS - 1/\n/SX/0/ALIAS SAVE                    /SHORT FORM OF SAVE/\n/IM/0/SELECT CMD(IM &ZPARM)/INVOKE IMON/\n/FDM/0/SELECT CMD(FDM &ZPARM)/INVOKE STARTOOL/\n/PDSE/0/SELECT CMD(PDSE &ZPARM)/INVOKE STARTOOL/\n/P8/0/SELECT CMD(PDS86 &ZPARM)/INVOKE PDS 8.6/\n/PDS8/4/SELECT CMD(PDS86 &ZPARM)/INVOKE PDS 8.6/\n/LPTF/0/SELECT CMD(%LPTF &ZPARM)/INVOKE LIST PTFS FROM SMPPTS/\n/PRINTO/0/SELECT CMD(%ISPFPRTO &ZPARM)/ISPF INVOKE PRINTOFF/\n/SP0 /0/SELECT PGM(ISPISM) SCRNAME(SETTINGS)/ISPF 0/\n/SP1 /0/SELECT PGM(ISRBRO) PARM(ISRBRO01) SCRNAME(VIEW)/ISPF 1/\n/SP2 /0/SELECT PGM(ISREDIT) PARM(P,ISREDM01) SCRNAME(EDIT)/ISPF 2/\n/SP3 /0/SELECT PANEL(ISRUTIL) SCRNAME(UTIL)/ISPF 3/\n/SP4 /0/SELECT PANEL(ISRFPA) SCRNAME(FOREGRND)/ISPF 4/\n/SP5 /0/SELECT PGM(ISRJB1) PARM(ISRJPA) SCRNAME(BATCH) NOCHECK/ISPF 5/\n/SP6 /0/SELECT PGM(ISRPTC) SCRNAME(CMD)/ISPF 6/\n/SP6A/0/SELECT PGM(ISRPTC)             /ISPF 6/\n/SP7 /0/SELECT PGM(ISPYXDR) PARM(&ZTAPPLID) SCRNAME(DTEST) NOCHECK/SP7/\n/SP8 /0/SELECT PANEL(ISRLPRIM) SCRNAME(LMF)/ISPF8/\n/SP9 /0/SELECT PANEL(ISRDIIS) ADDPOP/ISPF 9/\n/SP10 /0/SELECT PGM(ISRSCLM) SCRNAME(SCLM) NOCHECK/ISPF 10/\n/SP11 /0/SELECT PGM(ISRUDA) PARM(ISRWORK) SCRNAME(WORK)/ISPF 11/\n/SP31/0/SELECT PGM(ISRUDA) PARM(ISRUDA1) SCRNAME(LIBUTIL)/ISPF 3.1/\n/SP32/0/SELECT PGM(ISRUDA) PARM(ISRUDA2) SCRNAME(DSUTIL)/ISPF 3.2/\n/SP33/0/SELECT PGM(ISRUMC) SCRNAME(MCOPY)/ISPF 3.3/\n/SP34/0/SELECT PGM(ISRUDL) PARM(ISRUDLP) SCRNAME(DSLIST)/ISPF 3.4/\n/SP35/0/SELECT PGM(ISRURS) SCRNAME(RESET)/ISPF 3.5/\n/SP36/0/SELECT PGM(ISRUHC) SCRNAME(HARDCOPY)/ISPF 3.6/\n/SP37/0/SELECT PANEL(ISPUDL) SCRNAME(DOWNLOAD)/ISPF 3.7/\n/SP38/0/SELECT PGM(ISRUOLP) SCRNAME(OUTLIST)/ISPF 3.8/\n/SP39/0/SELECT PANEL(ISPUCMA) ADDPOP SCRNAME(CMDTABLE)/ISPF 3.9/\n/SP311/0/SELECT PGM(ISRFMT) SCRNAME(FORMAT)/ISPF 3.11/\n/SP312/0/SELECT PGM(ISRSSM) SCRNAME(SUPERC)/ISPF 3.12/\n/SP313/0/SELECT PGM(ISRSEPRM) SCRNAME(SUPERCE) NOCHECK/ISPF 3.13/\n/SP314/0/SELECT PGM(ISRSFM) SCRNAME(SRCHFOR)/ISPF 3.14/\n/SP315/0/SELECT PGM(ISRSEPRM) PARM(S4) SCRNAME(SRCHFORE) NOCHECK/3.15/\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ISPTASK": {"ttr": 13059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x03\\x05\\x00\\x06\\x00\\x82\\x01?\\x00\\x953\\x9f\\x12\\x14\\x01\\x16\\x00\\x83\\x00a\\xc3\\xc2\\xe3\\xf4\\xf7\\xf6@@@@'", "ispf": {"version": "03.05", "flags": 0, "createdate": "1982-01-13T00:00:00", "modifydate": "1995-12-05T12:14:06", "lines": 278, "newlines": 131, "modlines": 97, "user": "CBT476"}, "text": "//GILBERTI JOB (ACCT#),ISPTASK,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n*        ISPTASK MODULE                                               *\n*                                                                     *\n*        This module prevents S522 abends while in ISPF,              *\n*        between midnight and 19:00:00                                *\n*                                                                     *\n*        Link-edit it into your ISPLLIB or STEPLIB,                   *\n*        re-enter ISPF, you won't time out anymore.                   *\n*                                                                     *\n*        For this module to work, the following conditions            *\n*        must be met:                                                 *\n*                                                                     *\n*        1.  This module must be link-edited with the NOREUS          *\n*            attribute into a library allocated to your TSO           *\n*            session under the name ISPLLIB or STEPLIB.               *\n*            DO NOT try to link-edit this module with the REUS        *\n*            or RENT attribute, nor to link-edit it into a            *\n*            link-list or LPA library.                                *\n*                                                                     *\n*        2.  The ISPF modules must be in LPA or in the link-list.     *\n*            DO NOT use this module if ISPF's ISPTASK module is in    *\n*            your ISPLLIB or STEPLIB.                                 *\n*                                                                     *\n*        NOTE:                                                        *\n*                                                                     *\n*            ISPSTART issues an ATTACH EP=ISPTASK,TASKLIB=ISPLLIB     *\n*            macro at least once, twice if you use split-screen.      *\n*                                                                     *\n*  AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                 *\n*           http://gsf-soft.com/Freeware/                             *\n*                                                                     *\n*302 Do not prevent S522 during week-ends                             *\n*303 Get ISPF's ISPTASK from STEPLIB, if it's in it                   *\n*304 Issue BLDL against every active tasklib until JSTCB reached      *\n*305 Fix day-of-the-week calc routine for year 2000                   *\n*    Fix alignment error in BLDLLIST                                  *\n&REL     SETC  '305'                                                  *\n***********************************************************************\nISPTASK  CSECT\nISPTASK  RMODE ANY\n         SAVE  (14,12),,'GSF Utilities - ISPTASK R&REL'\n         LR    R12,R15                 BASE REGISTER\n         USING ISPTASK,R12\n*\n* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\n*        USERID selection - R2 Points to USERID in TIOT\n* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\n*\n         L     R2,X'021C'(,0)          PSATOLD (my TCB)\n         L     R2,012(,R2)             TCBTIO  (my TIOT)\n**       CLC   =C'IBMUSER ',0(R2)      USER=IBMUSER ?\n**       BNE   XCTL                    no, do nothing\n*\n* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\n*        End of USERID Selection\n* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\n*\n*        Pass control to the Secondary entry point\n*\n*        1.  bump my own use count, to make sure I don't get\n*            deleted by XCTL\n*\n*        2.  issue XCTL to remove one PRB\n*\nBUMP_USE IDENTIFY EPLOC=ISP_TASK,ENTRY=ISP_TASK+8\n         LOAD  EPLOC=ISP_TASK          BUMP USE COUNT\n         XCTL  EPLOC=ISP_TASK          INVOKE SECONDARY ENTRY POINT\n*\n*        Secondary entry point\n*\nISP_TASK DC    C'ISP_TASK'             SECONDARY ENTRY POINT\n         LR    R12,R15                 BASE REGISTER\n         USING ISP_TASK+8,R12\n*\n* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\n*\n*        Make some PDF modules resident in JPAQ (ESA 4.3 and up)\n*\n*        The purpose of this paragraph is to speed up access\n*        to some PDF functions (Edit, Browse) when ISPLLIB and\n*        STEPLIB contain large numbers of libraries.\n*\n*        LOAD and IDENTIFY macros are used to clone the LPDE,\n*        create two CDEs and one XTLST for each module and chain\n*        the CDEs to the JPAQ.  Note that the modules\n*        themselves are not duplicated, the only version that\n*        exists is the one in PLPA; all we do here is to create\n*        entries in the JPAQ that point to the PLPA modules.\n*\n*        Using this technique allows you to avoid time-consuming\n*        directory searches whenever you invoke the most common\n*        PDF functions.\n*\n*        If you're lucky enough that you have no ISPLLIB or\n*        STEPLIB, this won't do you any good, but it won't do\n*        you any harm either.\n*\n*        If you're so unlucky that ISPF/PDF is in the link-list\n*        and not in the LPA on your system (shame on your system\n*        programmers), then this will definitely help you.\n*\n* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\n*\nLOADJPAQ BAL   R3,LOADJPA1             issue LOAD/IDENTIFY\n         DC    C'ISRBRO  '             PDF 1\n         DC    C'ISREDIT '             PDF 2\n         DC    C'ISRUDA  '             PDF 3.1 & 3.2\n         DC    C'ISRUMC  '             PDF 3.3\n         DC    C'ISRUDL  '             PDF 3.4\n         DC    C'ISRPTC  '             PDF 6\n         DC    C'ISPEXEC '             ISPLINK/ISPEXEC interface\n         DC    C'ISRSUBS '             PDF RMODE31 routines\n         DC    C'ISRSUBX '             PDF RMODE24 routines\n*\n         DC    C'IRXINIT '             REXX main pgm\n         DC    C'IRXSTAMP'             REXX stack manager\n         DC    C'IRXAPPC '             REXX APPC interface\n         DC    C'IRXECUSP'             REXX ?\n*\n         DC    C'ALLOCATE'             TSO ALLOCATE command\n         DC    C'EXEC    '             TSO EXEC command\n         DC    C'CALL    '             TSO CALL command\n         DC    C'DELETE  '             TSO DELETE command\n         DC    C'IDCSATO '             IDCAMS interface for TSO\n         DC    C'HELP    '             TSO HELP command\n         DC    C'SUBMIT  '             TSO SUBMIT command\n*\n*\n*\n         DC    X'FFFF'                 end of table\n*loop\nLOADJPA1 LOAD  EPLOC=(R3),             load ISRBRO                     X\n               ERRET=LOADJPA9          module not found\n         LR    R2,R0                   save entry point addr\n         LA    R0,0(,R2)               clean entry point\n         L     R1,CVTPTR               CVT address\n         USING CVT,R1\n         L     R1,CVTSMEXT             STORAGE MAP EXTENSION\n         USING CVTVSTGX,R1\n         CL    R0,CVTPLPAS             entry-point in PLPA?\n         BL    LOADJPA9                no, jump\n         CL    R0,CVTEPLPE             entry-point in PLPA?\n         BH    LOADJPA9                no, jump\n         DROP  R1                      CVTSTGX\nLOADJPA2 MVC   DWD,0(R3)               convert ISRBRO to ISR_BRO\n         MVI   DWD+3,C'_'              convert ISRBRO to ISR_BRO\n         MVC   DWD+4(4),3(R3)          convert ISRBRO to ISR_BRO\n         IDENTIFY EPLOC=DWD,ENTRY=(R2) define ISR_BRO\n         LTR   R15,R15\n         BNZ   LOADJPA9\n         LOAD  EPLOC=DWD               load ISR_BRO\n         DELETE EPLOC=(R3)             delete ISRBRO\n         IDENTIFY EPLOC=(R3),ENTRY=(R2) define ISRBRO onto ISR_BRO\nLOADJPA9 LA    R3,8(,R3)               next entry\n         CLI   0(R3),X'FF'             end of table reached?\n         BNE   LOADJPA1                not yet, process next entry\n*endloop\n*\n* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\n*        DETERMINE DAY OF THE WEEK\n* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\n*\n         TIME  ZONE=GMT                R1=0YYYDDDF\n         ST    R1,GMTDATE              store date\n         MVO   DWD,GMTDATE(2)          0YYY FROM 0YYY.DDD\n         OI    DWD+7,15                sign\n         CVB   R0,DWD                  R0=YEAR\n         LR    R1,R0                   R1=YEAR\n         BCTR  R1,0                    R1=YEAR-1\n         SRL   R1,2                    DIVIDE YEAR-1 BY 4\n         AR    R1,R0                   ADD RESULT TO NUMBER OF YEARS\n         ZAP   DWD,GMTDATE+2(2)        DDD FROM YY.DDD\n         SLR   R14,R14                 PREPARE DIVISION\n         CVB   R15,DWD                 R15=DAY\n         BCTR  R15,0                   R15=DAY-1\n         AR    R15,R1                  ADD NUMBER OF YEARS\n         D     R14,=F'7'               DIVIDE BY NUM OF DAYS IN WEEK\n*R14 contains the day of the week code (0=monday, 4=friday, 6=sunday)\n         CH    R14,=H'4'               saturday or sunday?\n         BH    XCTL                    yes, do not prevent S522\n*\n* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\n*        Prime the timer\n* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\n*\n         SYNCH STIMER                  PRIME TIMER\n         DROP\n*\n* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\n*        Now pass control to ISPF's own ISPTASK module in\n*        the STEPLIB or the LPA/link-list.\n* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\n*\nXCTL     LM    R14,R12,12(R13)         restore R14-R12\n         BALR  R15,0                   LOCAL BASE\n         USING *,R15\n         ICM   R1,B'1111',0(R1)        A(TLD)\n         BMR   R14                     invoked as a program, exit\n         CLC   =C'TLD',0(R1)           check for a TLD\n         BNER  R14                     invoked as a TSO command, exit\n*\n         BALR  R12,0                   LOCAL BASE\n         USING *,R12\n         NOP   XCTL89                  fall through first time\n         OI    *-3,X'F0'               close the door\n*\n         L     R4,X'021C'(,0)          PSATOLD (my TCB)\n         USING TCB,R4\n         L     R5,TCBJLB               DCB for ISPLLIB\n*loop\nXCTL83   CL    R4,TCBJSTCB             Job Step TCB\n         BE    XCTL87                  yes, use LINKLIST\n         L     R4,TCBOTC               mother task\n         CL    R5,TCBJLB               same tasklib?\n         BE    XCTL83                  yes, try previous TCB\n         ICM   R5,B'1111',TCBJLB       addr of tasklib TCB\n         BZ    XCTL87                  no tasklib, try CVTLINK\n         BLDL  (R5),BLDLLIST           search STEPLIB's directory\n         LTR   R15,R15                 ISPTASK found in tasklib ?\n         BNZ   XCTL83                  no, try next TCB\n         TM    PDS2ATR1,PDS2RENT       is it ISPF's ISPTASK?\n         BNO   XCTL83                  no, try next TCB\n*endloop\n         B     XCTL88                  yes, use this DCB\n*\nXCTL87   L     R5,16                   CVTPTR\n         L     R5,8(,R5)               CVTLINK\nXCTL88   LA    R4,BLDLLIST+4           C'ISPTASK '\n         STM   R4,R5,XCTLL             XCTL EP=ISPTASK,DCB=CVTLINK,SF=L\n*\nXCTL89   LA    R15,XCTLL               XCTL EP=ISPTASK,DCB=CVTLINK,SF=L\n         DROP\n         LM    R0,R12,20(R13)          restore R0-R12\n         XCTL  SF=(E,(15))             Invoke ISPF's own ISPTASK       x\n                                       module, while bypassing ISPLLIB x\n                                       and STEPLIB\n         DC    0F'0'                   fwd alignment req'd for IHAPDS\nBLDLLIST DC    H'1,64',CL64'ISPTASK'\n         ORG   BLDLLIST+4              overlay member name\n         IHAPDS DSECT=NO,PDSBLDL=YES\n         ORG\n*\n* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\n*        TIMER EXIT RTNE\n* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\n*\nSTIMER   TIME  DEC                     R0=HHMMSSHH\n         BALR  R15,0                   Local base\n         USING *,R15\n         CLM   R0,B'1100',STIMER19     PAST 19:00:00 ?\n         BH    STIMER99                YES, ALLOW S522 AGAIN\n         STIMERM SET,ID=DWD,EXIT=STIMER,BINTVL=STIMER60\nSTIMER99 SVC   3                       GOBACK TO FLIH\nSTIMER19 DC    X'1900'                 19:00:00\nSTIMER60 DC    A(10*60*100)            WAIT TIME IN 1/100 SEC\n*\nDWD      DS    D                       WORK AREA\nXCTLL    XCTL  SF=L                    WORK AREA\nGMTDATE  DS    F                       GMT julian date\n         YREGS\n         CVT   DSECT=YES,LIST=NO\n         IKJTCB DSECT=YES,LIST=NO\n         END   ISPTASK\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR                   IHAPDS/IEZBITS\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//LKED    EXEC PGM=HEWL,PARM='MAP,NOREUS'\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,DELETE)\n//SYSPRINT DD SYSOUT=*\n//SYSLMOD  DD DSN=CBTTAPE.FILE183.LOAD(ISPTASK),DISP=SHR  <== ISPLLIB\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ISREDIT2": {"ttr": 13064, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x04\\x02\\x0f\\x01\\x04\\x02\\x9f\\t\\x00\\x00G\\x00$\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf6\\xf5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-01-20T00:00:00", "modifydate": "2004-01-29T09:00:00", "lines": 71, "newlines": 36, "modlines": 0, "user": "CBT465"}, "text": "//GILBERT2 JOB (ACCT#),ISREDIT2,\n// CLASS=A,MSGCLASS=H,COND=(0,NE),NOTIFY=&SYSUID\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n* PROGRAM NAME = ISREDIT2                                             *\n*                                                                     *\n* DESCRIPTIVE NAME = SPEED UP ISPF EDIT MACROS                        *\n*                                                                     *\n* FUNCTION = CREATE A PERMANENT CDE ON JPAQ TO ELIMINATE DIRECTORY    *\n*            SEARCHES FOR ISPLLIB/STEPLIB/TSOLIB WHEN THE ISREDIT     *\n*            MODULE IS IN THE LINK-LIST OR THE LPA                    *\n*                                                                     *\n* STATUS = R100                                                       *\n*                                                                     *\n* AUTHOR = GILBERT SAINT-FLOUR <carlos@gsf-soft.com>                  *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*     AMODE = 31                                                      *\n*     SCP   = MVS/ESA 4.3 OR ABOVE                                    *\n*     KEY   = USER                                                    *\n*     MODE  = PROBLEM                                                 *\n*     APF   = OFF                                                     *\n*                                                                     *\n* OPERATION = ISREDIT2 USES AN UNDOCUMENTED FEATURE OF THE IDENTIFY   *\n*             MACRO TO CREATE A MAJOR CDE FOR THE ISREDIT MODULE.     *\n*                                                                     *\n* INVOCATION = SEE BELOW                                              *\n*                                                                     *\n*          AS A COMMAND: ISREDIT2                                     *\n*                        ISPEXEC SELECT CMD(ISREDIT2)                 *\n*          AS A PROGRAM: CALL *(ISREDIT2)                             *\n*                        ISPEXEC SELECT PGM(ISREDIT2)                 *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*        ISREDIT2 MAY BE INVOKED MORE THAN ONCE                       *\n*                                                                     *\n***********************************************************************\nISREDIT2 CSECT\nISREDIT2 AMODE ANY\n         LR    R12,R15\n         USING ISREDIT2,R12\n         LOAD  EP=ISPEXEC\n         LOAD  EP=ISREDIT\n         LR    R2,R0\n         IDENTIFY EP=ISR_EDIT,ENTRY=(R2)\n         LTR   R15,R15\n         BNZ   ERR1\nDELETE   LOAD  EP=ISR_EDIT\n         DELETE EP=ISREDIT\n         IDENTIFY EP=ISREDIT,ENTRY=(R2)\n         LTR   R15,R15\n         BNZ   ERR2\n         SVC   3\nERR1     TPUT  =C'IDENTIFY 1 FAILED',17\n         SVC   3\nERR2     TPUT  =C'IDENTIFY 2 FAILED',17\n         SVC   3\n         YREGS\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS)\n//*\n//LKED    EXEC PGM=IEWL\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,DELETE)\n//SYSLMOD  DD DSN=GILBERT.LOAD(ISREDIT2),DISP=SHR\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JOBRLSE": {"ttr": 13067, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x833o\\x01\\x04\\x14\\x0f\\x124\\x00\\xa7\\x00F\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf6\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1983-12-02T00:00:00", "modifydate": "2004-05-19T12:34:00", "lines": 167, "newlines": 70, "modlines": 0, "user": "CBT469"}, "text": "//GILBERTJ JOB (ACCT#),JOBRLSE,\n// NOTIFY=&SYSUID,\n//*RESTART=EXEC,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//*\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n*PROCESS BATCH,USING(NOMAP,WARN(8))\n***********************************************************************\n*                                                                     *\n*                       JOB RELEASE (JES2)                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        THIS PROGRAM ALLOWS YOU TO ISSUE A $A COMMAND TO RELEASE     *\n*        A JOB PREVIOUSLY SUBMITTED WITH \"TYPRUN=HOLD\".               *\n*                                                                     *\n*        TO PREVENT \"MULTIPLE JOBS FOUND\" PROBLEMS, THIS PROGRAM      *\n*        USES THE SUB-SYSTEM INTERFACE TO INQUIRE ABOUT THE STATUS    *\n*        OF HOMONYM JOBS.  IT THEN ISSUES A $A COMMAND WITH THE JOB   *\n*        NUMBER (FOR EXAMPLE: $A JOB01234) OF THE FIRST JOB FOUND     *\n*        IN THE INPUT QUEUE IN HELD STATUS.                           *\n*                                                                     *\n*        SAMPLE EXECUTION JCL:                                        *\n*                                                                     *\n*          //RLSENEXT EXEC PGM=JOBRLSE,PARM=JOBNAME                   *\n*                                                                     *\n*        WARNING !!! THIS PROGRAM MUST BE APF-AUTHORIZED.             *\n*                                                                     *\n***********************************************************************\nJOBRLSE  CSECT\nJOBRLSE  RMODE ANY\nMAXJOBS  EQU   200                     MAX NUMBER OF HOMONYM JOBS\n         SAVE  (14,12),,'GSF UTILITIES - JOBRLSE R100'\n         LR    R12,R15\n         USING JOBRLSE,R12\n         ST    R13,SAVEAREA+4\n         LA    R13,SAVEAREA\n*\n*        VALIDATE JCL PARM\n*\n         L     R2,0(,R1)               JCL PARM ADDRESS\n         LH    R3,0(,R2)               PICK UP LENGTH\n         LTR   R3,R3\n         BNP   RETURN16                INVALID PARM LENGTH\n         CH    R3,=H'8'\n         BH    RETURN16                INVALID PARM LENGTH\n*\n*        ALLOCATE A SSOB AND BUILD IT.\n*\n         LA    R0,SSOBHSIZ+SSCSELSZ*MAXJOBS+256\n         GETMAIN RU,LV=(0)\n         ST    R1,SSOBPTR1\n         OI    SSOBPTR1,X'80'\n         LR    R11,R1\n         USING SSOB,R11\n         XC    SSOB(SSOBHSIZ),SSOB     BUILD THE SSOB\n         LA    R0,SSOBHSIZ\n         STH   R0,SSOBLEN\n         MVC   SSOBID,=C'SSOB'\n         LA    R0,SSOBSTAT\n         STH   R0,SSOBFUNC             FUNCTION CODE: CANCEL/STATUS\n         LA    R0,SSOBGN\n         ST    R0,SSOBINDV\n         LA    R0,SSCSIZE\n         STH   R0,SSCSLEN\n         MVI   SSCSFLGS,0\n         MVI   SSCSULEN,0\n         MVC   SSCSJOBN,SPACES         INITIALIZE THE FIELD\n         BCTR  R3,0\n         EX    R3,*+4\n         MVC   SSCSJOBN(*-*),2(R2)     MOVE JOBNAME FROM PARM\n         MVC   SSCSJOBI,SPACES         JOB ID\n         LA    R0,SSCSELSZ*MAXJOBS\n         STH   R0,SSCSDIMP\n*\n*        CALL JES2 VIA THE SUBSYSTEM INTERFACE\n*\n         MODESET KEY=ZERO,MODE=SUP\n         LA    R1,SSOBPTR1\n         IEFSSREQ  ,                   <==== CALL JES2\n         LTR   R2,R15                  COPY/TEST RETURN CODE\n         BZ    MODESET2                RC=0, CONTINUE\n         ABEND 2001,DUMP,REASON=(15)   IEFSSREQ ERROR\nMODESET2 MODESET KEY=NZERO,MODE=PROB\n         ICM   R15,B'1111',SSOBRETN    PICK UP RETURN-CODE\n         BZ    LOOKUP                  RC=0, CONTINUE\n         ABEND 2002,DUMP,REASON=(15)   RETURNED LENGTH IS ZERO\n*\n*        LOOK UP JOB ID\n*\nLOOKUP   LA    R3,SSCSARBG             START OF ARRAY\n         LA    R4,SSCSELSZ             ELEMENT SIZE\n         LH    R5,SSCSDIMR             LENGTH OF ARRAY (IN BYTES)\n         BCTR  R5,0\n         ALR   R5,R3                   END OF ARRAY\n         SLR   R3,R4                   1ST ENTRY\n         USING SSCSARAY,R3\n*LOOP\nLOOP1    BXH   R3,R4,RETURN04          SCAN JOB NAMES\n         TM    SSCSFLG1,SSCSEXCQ+SSCSHOLD\n         BNO   LOOP1                   TRY NEXT JOB\n*ENDLOOP\n         MVC   CMDJOBI,SSCSARID        JOB NUMBER: 'JOB01234'\n         MODESET KEY=ZERO,MODE=SUP\n         SLR   R0,R0                   CONSOLE ID\n         MGCR  CMD                     ISSUE 'RELEASE' COMMAND\n         MODESET KEY=NZERO,MODE=PROB\n         SLR   R2,R2                   RC=00\n         B     FREEMAIN\n*\n*        CLEAN UP, RETURN\n*\nRETURN04 LA    R2,0004(0)              NO JOB FOUND: RC=04\n*\nFREEMAIN LA    R0,SSOBHSIZ+SSCSELSZ*MAXJOBS+256\n         FREEMAIN RU,LV=(0),A=(R11)    FREE DYNAMIC AREA\n         LR    R15,R2                  PASS RETURN CODE\n         B     RETURN20\n*\nRETURN16 LA    R15,0016                PARM ERROR: RC16\nRETURN20 L     R13,4(,R13)\n         RETURN (14,12),RC=(15)        GOBACK TO SYSTEM\n*----------------------------------------------------------------------\n*\n*        WORK AREA\n*\n*----------------------------------------------------------------------\nSPACES   DC    CL8' '\nCMD      DC    Y(CMDL,0),C'$A '\nCMDJOBI  DS    CL8' '\nCMDL     EQU   *-CMD\nSSOBPTR1 DS    A\nSAVEAREA DS    18A\n*----------------------------------------------------------------------\n*\n*        CONTROL BLOCK DEFINITIONS\n*\n*----------------------------------------------------------------------\n         IEFJSSOB CS\n         CVT   DSECT=YES,PREFIX=NO\n         IEFJESCT\n         YREGS\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,5)\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSPRINT DD SYSOUT=*\n//*\n//LKED    EXEC PGM=IEWL,PARM='MAP,REUS,AC=1'\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,DELETE)\n//SYSPRINT DD SYSOUT=*\n//SYSLMOD  DD DSN=GILBERT.LOAD(JOBRLSE),DISP=SHR    <== APF LOADLIB\n//*\n//*       TEST STEP\n//*\n//EXEC    EXEC PGM=JOBRLSE,PARM=GILBERTH\n//STEPLIB  DD DSN=*.LKED.SYSLMOD,DISP=SHR\n//EXEC    EXEC PGM=JOBRLSE,PARM=GILBERTH\n//STEPLIB  DD DSN=*.LKED.SYSLMOD,DISP=SHR\n//EXEC    EXEC PGM=JOBRLSE,PARM=GILBERTH\n//STEPLIB  DD DSN=*.LKED.SYSLMOD,DISP=SHR\n//SYSUDUMP DD SYSOUT=*\n//\n//GILBERTH JOB (ACCT#),GILBERT,TYPRUN=HOLD,       TARGET JOB\n// CLASS=A,MSGCLASS=H                             TARGET JOB\n//TGT EXEC PGM=IEFBR14                            TARGET JOB\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LC": {"ttr": 13313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x05\\x00\\x886_\\x01\\t\\x06\\x8f\\x115\\x00=\\x00\\r\\x00\\x0c\\xc3\\xc2\\xe3\\xf4\\xf7\\xf8@@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "1988-12-30T00:00:00", "modifydate": "2009-03-09T11:35:05", "lines": 61, "newlines": 13, "modlines": 12, "user": "CBT478"}, "text": "/*************************************************************** REXX *\\\n|*                                                                    *|\n|* Module Name: LC (ListCat)                                          *|\n|*                                                                    *|\n|* Descriptive Name:  Issue LISTCAT command and display output        *|\n|*                    using the ISPF BRIF option.                     *|\n|*                                                                    *|\n|* Status: R201                                                       *|\n|*                                                                    *|\n|* Function: This EXEC helps ISPF users trap the output of the        *|\n|*           LISTCAT command and display it via the STEMVIEW routine. *|\n|*           If the user enters the V command, then STEMVIEW displays *|\n|*           the result of the LISTCAT command with VIEW instead      *|\n|*           of BROWSE.  VIEW allows commands such as CUT or CREATE,  *|\n|*           and EDIT macros, such as ROUTE.                          *|\n|*                                                                    *|\n|*           LC can be used here :                                    *|\n|*             Opt 11 : ISPF WorkPlace              (WP)              *|\n|*             Opt 3.4 : ISPF Data Set List Utility (DSLIST)          *|\n|*             Opt 6 : ISPF Command Shell           (ICS)             *|\n|*                                                                    *|\n|* Author: Gilbert Saint-Flour <carlos@gsf-soft.com>                  *|\n|*         http://gsf-soft.com/Freeware/                              *|\n|*                                                                    *|\n|* Syntax: LC                                                         *|\n|*             dsname        data set name                            *|\n|*             options       ALL NAME HISTORY VOLUME                  *|\n|*                                                                    *|\n|* Example:  LC 'ibmuser.load' ALL                                    *|\n|*           LC 'ibmuser.load' VOLUME                                 *|\n|*                                                                    *|\n|* Environment: TSO/E V2                                              *|\n|*              ISPF/PDF 2.3                                          *|\n|*              STEMVIEW  http://gsf-soft.com/Freeware/STEMEDIT.shtml *|\n|*                                                                    *|\n|*200 New version (STEMVIEW)                                          *|\n|*201 Check for missing data set name                                 *|\n\\**********************************************************************/\nPARSE UPPER ARG dsname options\nIF dsname='' THEN DO                        /* dsname is missing      */\n  ZEDSMSG = 'Missing Data Set Name'\n  ZEDLMSG = 'Data Set Name is required but was not specified'\n  \"ISPEXEC SETMSG MSG(ISRZ001)\"\n  EXIT 20\n  END\nIF options='' THEN options='ALL'            /* Default Options        */\ncmd=\"LISTCAT ENT(\"dsname\")\" options\nRC=OUTTRAP(\"LINE.\"); cmd; cc=rc; rc=OUTTRAP(\"OFF\")\n\nSIGNAL ON SYNTAX                            /* STEMDISP not available */\nCALL STEMDISP \"BROWSE\",\"LINE.\",,,cmd        /* Display LISTCAT Output */\nEXIT cc\n\nSYNTAX:                            /* STEMDISP function not available */\n  error=rc\n  'ISPEXEC CONTROL DISPLAY LINE START(1)'\n  SAY 'REXX error' error 'in line' sigl':' errortext(error)\n  SAY sourceline(sigl)\n  SAY ''\n  DO i=1 TO QUEUED(); PARSE PULL line; SAY line ; END\n  EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LCAT": {"ttr": 13315, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//GILBERTL JOB (ACCT#),LCAT,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//*\n//HLASM EXEC PGM=ASMA90,PARM='OBJECT,NODECK,NOESD,NORLD,NOXREF,RENT'\n***********************************************************************\n*                                                                     *\n* NAME = LCAT                                                         *\n*                                                                     *\n* DESCRIPTIVE NAME = ISPF/PDF INTERFACE TO THE \"LISTCAT\" COMMAND      *\n*                                                                     *\n* FUNCTION = THIS TSO/ISPF COMMAND INVOKES IDCAMS THEN                *\n*            USES BRIF TO DISPLAY THE OUTPUT.                         *\n*                                                                     *\n* STATUS = R101                                                       *\n*                                                                     *\n* AUTHOR = GILBERT SAINT-FLOUR <carlos@gsf-soft.com>                  *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = OS/390 V1R3 OR ABOVE, ISPF/PDF                    *\n*    AUTHORIZATION = NONE                                             *\n*    RESTRICTIONS = NONE                                              *\n*                                                                     *\n* SYNTAX = TO USE IT, JUST ENTER LCAT (OR LC) AS A LINE COMMAND       *\n*          ON THE DATA SET LIST UTILITY SCREEN.                       *\n*                                                                     *\n*             LCAT  DSNAME                                            *\n*                   CATALOG | LEVEL | ENTRIES                         *\n*                   NAME    | ALL                                     *\n*                                                                     *\n*          DEFAULT: ENTRIES, ALL                                      *\n*                                                                     *\n*101 LOAD LINK-LIST DCB ADDR FROM DLCB (OS/390 R3)                    *\n***********************************************************************\n         PUNCH ' ALIAS LC'          <- \"LC\" IS AN ALIAS FOR \"LCAT\"\nLCAT     CSECT\nLCAT     AMODE 31\n         SAVE  (14,12),,'GSF UTILITIES - LCAT R101'\n         LR    R11,R15\n         USING LCAT,R11\n         LR    R10,R1                  CPPL ADDRESS\n         USING CPPL,R10                SET UP ADDRESSABILITY TO CPPL\n         LA    R2,020                  RC=20\n         TM    CPPL,X'80'              INVOKED AS A PGM?\n         BO    GOBACK20                YES, QUIT WITH RC=20\n         GETMAIN R,LV=DYNAML           GET DYNAMIC STORAGE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1                  NEW SAVE AREA\n         USING DYNAM,R13\n         XC    DYNAM+72(256),DYNAM+72  JUST IN CASE . . .\n***********************************************************************\n*                                                                     *\n*        BUILD PARSE PARM LIST, CALL IKJPARS                          *\n*                                                                     *\n***********************************************************************\n         LA    R1,TENWORDS             POINT TO PPL\n         USING PPL,R1                  SET UP ADDRESSABILITY TO PPL\n         L     R0,CPPLUPT              USER PROFILE TABLE\n         ST    R0,PPLUPT               STORE UPT ADDRESS IN PPL\n         L     R0,CPPLECT              ENVIRONMENT CONTROL TABLE\n         ST    R0,PPLECT               STORE ECT IN PPL\n         LA    R0,ECB1                 EVENT CONTROL BLOCK\n         ST    R0,PPLECB               STORE ECB IN PPL\n         MVC   PPLPCL,=A(PCLCSECT)     STORE PCL ADDR INTO PPL\n         LA    R0,DYNANSWR             ANSWER AREA\n         ST    R0,PPLANS               STORE ANSWER ADDRESS IN PPL\n         L     R0,CPPLCBUF             COMMAND BUFFER\n         ST    R0,PPLCBUF              STORE BUFFER ADDRESS IN PPL\n         LA    R14,=C'IKJPARS '        NAME OF PARSE ROUTINE\n         L     R15,16(,0)              CVTPTR\n         L     R15,008(,R15)           CVTLINK\n         STM   R14,R15,ATTACHL         BUILD LINK PARMLIST\n         LINK  SF=(E,ATTACHL)          CALL THE PARSE ROUTINE\n         LTR   R2,R15                  CHECK FOR ZERO PARSE RETURN\n         BNZ   GOBACK                  GO AWAY UPSET\n         DROP  R1,R10                  PPL, CPPL\n***********************************************************************\n*                                                                     *\n*        PROCESS PARSED PARAMETERS                                    *\n*        BUILD 'LISTCAT' COMMAND                                      *\n*                                                                     *\n***********************************************************************\n         L     R2,DYNANSWR             LOAD PDL ADDRESS\n         USING IKJPARMD,R2             SET UP ADDRESSABILITY TO PDL\n         MVC   COMMAND+8(17),=C' LISTC NAME LVL('''\n         CLI   ALLPCE+1,1              NAME?\n         BE    BUILD3                  YES, JUMP\n         MVC   COMMAND+15(4),=C'ALL '  CHANGE 'NAME' TO 'ALL '\n*\nBUILD3   CLI   CATPCE+1,1              LEVEL ?\n         BE    BUILD4                  YES, JUMP\n         MVC   COMMAND+20(3),=C'CAT'\n         CLI   CATPCE+1,2              CATALOG?\n         BE    BUILD4                  YES, JUMP\n         MVC   COMMAND+20(3),=C'ENT'   ENTRIES\n*\nBUILD4   LA    R14,COMMAND+8+17        POINT PAST PREFIX\n         LH    R15,DSNPCE+4            ACTUAL LENGTH OF DSN\n         L     R0,DSNPCE               GET ADDRESS\n         LR    R1,R15                  ACTUAL LENGTH OF DSN\n         MVCL  R14,R0                  MOVE DATA SET NAME\n         MVI   0(R14),C''''\n         MVI   1(R14),C')'\n         LA    R15,2(,R14)             POINT PAST COMMAND\n         LA    R14,COMMAND+8           START OF WORK AREA\n         SLR   R15,R14                 TOTAL LENGTH OF COMMAND\n         STM   R14,R15,COMMAND         ADDRESS, LENGTH\n*\n         LA    R14,DSNAME              LENGTH\n         LA    R15,L'DSNAME            LENGTH\n         L     R0,DSNPCE               GET ADDRESS\n         LH    R1,DSNPCE+4             ACTUAL LENGTH OF DSN\n         ICM   R1,B'1000',BLANKS       PADDING\n         MVCL  R14,R0                  MOVE DATA SET NAME (TITLE)\n         DROP  R2\n         IKJRLSA DYNANSWR              FREE PDL\n*\n         LM    R0,R1,=A(X'F00000',500*121)      MAXIMUM/MINIMUM\n         GETMAIN VRU,LV=((0),(1)),LOC=ANY       GET DYNAMIC STORAGE\n         LR    R15,R1                  FIRST LINE\n         STM   R15,R1,BUFFER           ADDRESS/LENGTH/ADDRESS\n***********************************************************************\n*                                                                     *\n*        INVOKE IDCAMS                                                *\n*                                                                     *\n***********************************************************************\n         LA    R14,002                 NUMBER OF DD NAMES\n         LA    R15,DDSYSIN             1ST DDNAME\n         LA    R0,SYSIN00              I/O RTNE FOR SYSIN RTNE\n         LA    R1,DYNAM                USER DATA FOR SYSIN\n         STM   R14,R1,IOLIST           BUILD IDCAMS'S I/O LIST\n         LA    R15,DDPRINT             2ND DDNAME\n         LA    R0,PRINT00              I/O RTNE FOR SYSPRINT\n         LA    R1,DYNAM                USER DATA FOR SYSPRINT RTNE\n         STM   R15,R1,IOLIST+4+12      BUILD IDCAMS'S I/O LIST\n*\n         L     R1,X'224'(,0)           PSAAOLD\n         L     R1,ASCBASSB-ASCB(,R1)   A(ASSB)\n         L     R1,ASSBDLCB-ASSB(,R1)   A(DLCB)\n         L     R2,DLCBDCB@-DLCB(,R1)   A(DCB)\n*\n         ATTACH EP=IDCAMS,TASKLIB=(R2),ECB=ECB1,SF=(E,ATTACHL),        X\n               PARAM=(H0,H0,H0,IOLIST),VL=1,MF=(E,TENWORDS)\n         ST    R1,ECB1+4               KEEP TCB ADDR FOR DETACH\n         WAIT  1,ECB=ECB1              WAIT A WHILE\n         DETACH ECB1+4                 DETACH SUBTASK\n***********************************************************************\n*                                                                     *\n*        FREE UNUSED STORAGE                                          *\n*                                                                     *\n***********************************************************************\n         LM    R3,R5,BUFFER            CURRENT/LENGTH/START\n         LA    R1,7(,R3)               ROUND UP ADDRESS\n         N     R1,=F'-8'               ROUND UP ADDRESS\n         LR    R3,R1                   PASS ADDRESS FOR CALCULATIONS\n         SR    R3,R5                   LENGTH USED\n         ST    R3,BUFFER+4             LENGTH USED\n         SLR   R4,R3                   LENGTH UNUSED\n         FREEMAIN RU,LV=(R4),A=(R1)    FREE UNUSED STORAGE\n***********************************************************************\n*                                                                     *\n*        COMPUTE NUMBER OF LINES TO DISPLAY                           *\n*                                                                     *\n***********************************************************************\n         SLR   R2,R2\n         D     R2,MAXLRECL             NUMBER OF ENTRIES\n         LTR   R3,R3                   ANYTHING TO BROWSE?\n         BZ    GOBACK                  NO, QUIT\n         ST    R3,MAXRECNO             MAX RECORD NUMBER\n***********************************************************************\n*                                                                     *\n*        INVOKE \"BRIF\" SERVICE                                        *\n*                                                                     *\n***********************************************************************\n         LOAD  EP=ISPLINK\n         LR    R15,R0\n         CALL  (15),(BRIF,DSNAME,RECFM,MAXLRECL,RADDR,0,IOLIST+12),VL, +\n               MF=(E,ATTACHL)\n         LR    R2,R15                  PASS RETURN CODE\n*\n*        FREE STORAGE, GOBACK\n*\nGOBACK   LM    R0,R1,BUFFER+4          LENGTH/ADDRESS\n         FREEMAIN RU,LV=(0),A=(1)\n         LR    R1,R13\n         L     R13,4(,R13)\n         FREEMAIN RU,LV=DYNAML,A=(1)\nGOBACK20 LR    R15,R2                  RETURN CODE\n         RETURN (14,12),RC=(15)\n         DROP\n***********************************************************************\n*                                                                     *\n*        DEFINE INPUT PARAMETERS FOR IKJPARS                          *\n*                                                                     *\n***********************************************************************\nPCLCSECT IKJPARM\nDSNPCE   IKJPOSIT  DSNAME,USID,PROMPT='DATA SET NAME',                 X\n               HELP='NAME OF THE DATA SET TO BE LISTED'\nCATPCE   IKJKEYWD\n         IKJNAME 'LEVEL',ALIAS='LVL'   1\n         IKJNAME 'CATALOG'             2\n         IKJNAME 'ENTRIES'             3\nALLPCE   IKJKEYWD\n         IKJNAME 'NAME'                1\n         IKJNAME 'ALL'                 2\n         IKJENDP\n* ------------------------------------------------------------------- *\n*        INPUT ROUTINE (SYSIN)                                        *\n* ------------------------------------------------------------------- *\nDDSYSIN  DC    C'DDSYSIN   '           SYSIN DD\nSYSIN00  SAVE  (14,12),,'SYSIN ROUTINE'\n         LR    R11,R15\n         USING SYSIN00,R11\n         LM    R4,R6,0(R1)             USER DATA, IOFLAGS, IOINFO\n         USING DYNAM,R4\n         CLI   0(R5),X'08'             GET REQUEST?\n         BNE   SYSIN90                 NO, QUIT\n         TS    SYSIN_RC                FIRST TIME?\n         BNZ   SYSIN94                 NO, SIGNAL EOF\n         LM    R1,R2,COMMAND           ADDRESS, LENGTH\n         STM   R1,R2,0(R6)             PASS ADDRESS AND LEN TO IDCAMS\nSYSIN90  RETURN (14,12),RC=00\nSYSIN94  RETURN (14,12),RC=04          EOF\n         DROP\n* ------------------------------------------------------------------- *\n*        OUTPUT ROUTINE (SYSPRINT)                                    *\n* ------------------------------------------------------------------- *\nDDPRINT  DC    C'DDSYSPRINT'           SYSPRINT DD\nPRINT00  SAVE  (14,12),,'SYSPRINT ROUTINE'\n         LR    R11,R15\n         USING PRINT00,R11\n         LM    R4,R6,0(R1)             USER DATA, IOFLAGS, IOINFO\n         USING DYNAM,R4\n         CLI   0(R5),X'0C'             PUT REQUEST?\n         BNE   PRINT99                 NO, QUIT\n*LM R1,R2,0(R5)\n*TPUT (R1),(R2)\n         L     R15,=A(PRINT31+VL)      AMODE31\n         BSM   0,R15                   AMODE31\nPRINT31  L     R14,BUFFER              BUFFER PTR\n         L     R15,MAXLRECL            LENGTH\n         LM    R2,R3,0(R6)             ADDR, LEN\n         CLI   0(R2),C'1'              PAGE HEADER?\n         BE    PRINT99                 YES, IGNORE IT\n         CLI   0(R2),C' '              CONTROL CHARACTER?\n         BE    PRINT71                 NO, JUMP\n         MVI   0(R2),C' '              YES, GET RID OF IT\n         SLR   R1,R1\n         ICM   R1,B'1000',BLANKS       PADDING\n         MVCL  R14,R0                  BLANK LINE\n         L     R15,MAXLRECL            RELOAD LENGTH\nPRINT71  ICM   R3,B'1000',BLANKS       PADDING\n         MVCL  R14,R2                  MOVE CURRENT LINE\n         ST    R14,BUFFER              UPDATE BUFFER PTR\nPRINT99  RETURN (14,12),RC=00\n         ORG   *-2\n         BSM   0,R14\n         DROP\n***********************************************************************\n*                                                                     *\n*        READ ROUTINE (BRIF)                                          *\n*                                                                     *\n***********************************************************************\nREADRTN  SAVE  (14,12),,'READRTN'\n         LR    R11,R15\n         USING READRTN,R11\n         LM    R4,R7,0(R1)             INPUT PARMS\n         L     R12,0(,R7)              =A(DYNAM)\n         USING DYNAM,R12\n*\n         L     R3,0(,R6)               RECORD NUMBER (FROM BROWSE)\n         C     R3,MAXRECNO             BEYOND END OF FILE?\n         BH    GOBACK8                 YES, EXIT\n         BCTR  R3,0                    CALCULATE OFFSET\n         M     R2,MAXLRECL             CALCULATE OFFSET\n         AL    R3,BUFFER+8             CHANGE OFFSET TO ADDRESS\n         ST    R3,0(,R4)               PASS RECORD ADDRESS TO BRIF\n**       MVC   0(4,R5),MAXLRECL        PASS RECORD LENGTH TO BRIF\n         RETURN (14,12),RC=00\n*\nGOBACK8  MVC   0(4,R6),MAXRECNO        RETURN MAX RECORD NUMBER\n         RETURN (14,12),RC=8\n*\nRADDR    DC    A(READRTN)              READ ROUTINE (BRIF)\nMAXLRECL DC    F'121'\nBRIF     DC    C'BRIF    '             FUNCTION\nRECFM    DC    C'F '\nH0       DC    2X'00'                  NULL PARM\nBLANKS   DC    CL8' '\n*\nDYNAM    DSECT\n         DS    18F\nIOLIST   DS    A(2,DDSYSIN,SYSIN00,DYNAM,DDPRINT,PRINT00,DYNAM)\nATTACHL  ATTACH SF=L\nTENWORDS DS    10F                     WORK AREA\nSYSIN_RC DS    X'00'\nMAXRECNO DS    F\nECB1     DS   2F'0'\nDYNANSWR DS    A\nCOMMAND  DS    A,F,CL80                INITIAL COMMAND\nDSNAME   DS    CL46                    DSNAME FOR TITLE LINE\nBUFFER   DS    A(15,0,1)               ADDRESS/LENGTH/ADDRESS\nDYNAML   EQU   *-DYNAM\n         YREGS\n         IKJCPPL\n         IKJPPL\nVL       EQU   X'80000000'\n         IHAASCB\n         IHAASSB\n         CSVDLCB\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//SYSPRINT DD SYSOUT=*\n//*\n//LKED    EXEC PGM=HEWL,PARM=(LIST,MAP,RENT,REFR)\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=CBTTAPE.FILE183.LOAD(LCAT),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LCAT92": {"ttr": 13321, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x00\\x9f\\x00\\x92\\x17\\x8f\\x11&\\x014\\x00\\x1f\\x00\\x00\\xc3\\xc2\\xe3\\xf3\\xf7\\xf1@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-01-09T00:00:00", "modifydate": "1992-06-26T11:26:00", "lines": 308, "newlines": 31, "modlines": 0, "user": "CBT371"}, "text": "//GILBERTL JOB (ACCT#),LCAT,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//*\n//ASMH EXEC PGM=IEV90,PARM='OBJECT,NODECK,NOESD,NORLD,NOXREF,RENT'\n***********************************************************************\n*                                                                     *\n* NAME = LCAT                                                         *\n*                                                                     *\n* DESCRIPTIVE NAME = ISPF/PDF INTERFACE TO THE \"LISTCAT\" COMMAND      *\n*                                                                     *\n* FUNCTION = THIS TSO/ISPF COMMAND INVOKES IDCAMS THEN                *\n*            USES BRIF TO DISPLAY THE OUTPUT.                         *\n*                                                                     *\n* STATUS = R100                                                       *\n*                                                                     *\n* AUTHOR = GILBERT SAINT-FLOUR <carlos@gsf-soft.com>                  *\n*                                                                     *\n* SYNTAX = TO USE IT, JUST ENTER LCAT (OR LC) AS A LINE COMMAND       *\n*          ON THE DATA SET LIST UTILITY SCREEN.                       *\n*                                                                     *\n*             LCAT  DSNAME                                            *\n*                   CATALOG | LEVEL | ENTRIES                         *\n*                   NAME    | ALL                                     *\n*                                                                     *\n*          DEFAULT: ENTRIES, ALL                                      *\n*                                                                     *\n***********************************************************************\n         PUNCH ' ALIAS LC'          <- \"LC\" IS AN ALIAS FOR \"LCAT\"\nLCAT     CSECT\nLCAT     AMODE 31\n         SAVE  (14,12),,'GSF UTILITIES - LCAT R100'\n         BASR  R11,0\n         USING *,R11\n         LR    R10,R1                  CPPL ADDRESS\n         USING CPPL,R10                SET UP ADDRESSABILITY TO CPPL\n         LA    R2,020                  RC=20\n         TM    CPPL,X'80'              INVOKED AS A PGM?\n         BO    GOBACK20                YES, QUIT WITH RC=20\n         GETMAIN R,LV=DYNAML           GET DYNAMIC STORAGE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1                  NEW SAVE AREA\n         USING DYNAM,R13\n         XC    DYNAM+72(256),DYNAM+72  JUST IN CASE . . .\n***********************************************************************\n*                                                                     *\n*        BUILD PARSE PARM LIST, CALL IKJPARS                          *\n*                                                                     *\n***********************************************************************\n         LA    R1,TENWORDS             POINT TO PPL\n         USING PPL,R1                  SET UP ADDRESSABILITY TO PPL\n         L     R0,CPPLUPT              USER PROFILE TABLE\n         ST    R0,PPLUPT               STORE UPT ADDRESS IN PPL\n         L     R0,CPPLECT              ENVIRONMENT CONTROL TABLE\n         ST    R0,PPLECT               STORE ECT IN PPL\n         LA    R0,ECB1                 EVENT CONTROL BLOCK\n         ST    R0,PPLECB               STORE ECB IN PPL\n         MVC   PPLPCL,=A(PCLCSECT)     STORE PCL ADDR INTO PPL\n         LA    R0,DYNANSWR             ANSWER AREA\n         ST    R0,PPLANS               STORE ANSWER ADDRESS IN PPL\n         L     R0,CPPLCBUF             COMMAND BUFFER\n         ST    R0,PPLCBUF              STORE BUFFER ADDRESS IN PPL\n         LA    R14,=C'IKJPARS '        NAME OF PARSE ROUTINE\n         L     R15,0016                CVTPTR\n         L     R15,008(,R15)           CVTLINK\n         STM   R14,R15,ATTACHL         BUILD LINK PARMLIST\n         LINK  SF=(E,ATTACHL)          CALL THE PARSE ROUTINE\n         LTR   R2,R15                  CHECK FOR ZERO PARSE RETURN\n         BNZ   GOBACK                  GO AWAY UPSET\n         DROP  R1,R10                  PPL, CPPL\n***********************************************************************\n*                                                                     *\n*        PROCESS PARSED PARAMETERS                                    *\n*        BUILD 'LISTCAT' COMMAND                                      *\n*                                                                     *\n***********************************************************************\n         L     R2,DYNANSWR             LOAD PDL ADDRESS\n         USING IKJPARMD,R2             SET UP ADDRESSABILITY TO PDL\n         MVC   COMMAND+8(17),=C' LISTC NAME LVL('''\n         CLI   ALLPCE+1,1              NAME?\n         BE    BUILD3                  YES, JUMP\n         MVC   COMMAND+15(4),=C'ALL '  CHANGE 'NAME' TO 'ALL '\n*\nBUILD3   CLI   CATPCE+1,1              LEVEL ?\n         BE    BUILD4                  YES, JUMP\n         MVC   COMMAND+20(3),=C'CAT'\n         CLI   CATPCE+1,2              CATALOG?\n         BE    BUILD4                  YES, JUMP\n         MVC   COMMAND+20(3),=C'ENT'   ENTRIES\n*\nBUILD4   LA    R14,COMMAND+8+17        POINT PAST PREFIX\n         LH    R15,DSNPCE+4            ACTUAL LENGTH OF DSN\n         L     R0,DSNPCE               GET ADDRESS\n         LR    R1,R15                  ACTUAL LENGTH OF DSN\n         MVCL  R14,R0                  MOVE DATA SET NAME\n         MVI   0(R14),C''''\n         MVI   1(R14),C')'\n         LA    R15,2(,R14)             POINT PAST COMMAND\n         LA    R14,COMMAND+8           START OF WORK AREA\n         SLR   R15,R14                 TOTAL LENGTH OF COMMAND\n         STM   R14,R15,COMMAND         ADDRESS, LENGTH\n*\n         LA    R14,DSNAME              LENGTH\n         LA    R15,L'DSNAME            LENGTH\n         L     R0,DSNPCE               GET ADDRESS\n         LH    R1,DSNPCE+4             ACTUAL LENGTH OF DSN\n         ICM   R1,B'1000',BLANKS       PADDING\n         MVCL  R14,R0                  MOVE DATA SET NAME (TITLE)\n         DROP  R2\n         IKJRLSA DYNANSWR              FREE PDL\n*\n         LM    R0,R1,=A(X'F00000',500*121)      MAXIMUM/MINIMUM\n         GETMAIN VRU,LV=((0),(1)),LOC=ANY       GET DYNAMIC STORAGE\n         LR    R15,R1                  FIRST LINE\n         STM   R15,R1,BUFFER           ADDRESS/LENGTH/ADDRESS\n***********************************************************************\n*                                                                     *\n*        INVOKE IDCAMS                                                *\n*                                                                     *\n***********************************************************************\n         LA    R14,002                 NUMBER OF DD NAMES\n         LA    R15,DDSYSIN             1ST DDNAME\n         LA    R0,SYSIN00              I/O RTNE FOR SYSIN RTNE\n         LA    R1,DYNAM                USER DATA FOR SYSIN\n         STM   R14,R1,IOLIST           BUILD IDCAMS'S I/O LIST\n         LA    R15,DDPRINT             2ND DDNAME\n         LA    R0,PRINT00              I/O RTNE FOR SYSPRINT\n         LA    R1,DYNAM                USER DATA FOR SYSPRINT RTNE\n         STM   R15,R1,IOLIST+4+12      BUILD IDCAMS'S I/O LIST\n         L     R1,0016                 CVTPTR\n         L     R2,008(,R1)             CVTLINK\n         ATTACH EP=IDCAMS,TASKLIB=(R2),ECB=ECB1,SF=(E,ATTACHL),        X\n               PARAM=(H0,H0,H0,IOLIST),VL=1,MF=(E,TENWORDS)\n         ST    R1,ECB1+4               KEEP TCB ADDR FOR DETACH\n         WAIT  1,ECB=ECB1              WAIT A WHILE\n         DETACH ECB1+4                 DETACH SUBTASK\n***********************************************************************\n*                                                                     *\n*        FREE UNUSED STORAGE                                          *\n*                                                                     *\n***********************************************************************\n         LM    R3,R5,BUFFER            CURRENT/LENGTH/START\n         LA    R1,7(,R3)               ROUND UP ADDRESS\n         N     R1,=F'-8'               ROUND UP ADDRESS\n         LR    R3,R1                   PASS ADDRESS FOR CALCULATIONS\n         SR    R3,R5                   LENGTH USED\n         ST    R3,BUFFER+4             LENGTH USED\n         SLR   R4,R3                   LENGTH UNUSED\n         FREEMAIN RU,LV=(R4),A=(R1)    FREE UNUSED STORAGE\n***********************************************************************\n*                                                                     *\n*        COMPUTE NUMBER OF LINES TO DISPLAY                           *\n*                                                                     *\n***********************************************************************\n         SLR   R2,R2\n         D     R2,MAXLRECL             NUMBER OF ENTRIES\n         LTR   R3,R3                   ANYTHING TO BROWSE?\n         BZ    GOBACK                  NO, QUIT\n         ST    R3,MAXRECNO             MAX RECORD NUMBER\n***********************************************************************\n*                                                                     *\n*        INVOKE \"BRIF\" SERVICE                                        *\n*                                                                     *\n***********************************************************************\n         LOAD  EP=ISPLINK\n         LR    R15,R0\n         CALL  (15),(BRIF,DSNAME,RECFM,MAXLRECL,RADDR,0,IOLIST+12),VL, +\n               MF=(E,ATTACHL)\n         LR    R2,R15                  PASS RETURN CODE\n*\n*        FREE STORAGE, GOBACK\n*\nGOBACK   LM    R0,R1,BUFFER+4          LENGTH/ADDRESS\n         FREEMAIN RU,LV=(0),A=(1)\n         LR    R1,R13\n         L     R13,4(,R13)\n         FREEMAIN RU,LV=DYNAML,A=(1)\nGOBACK20 LR    R15,R2                  RETURN CODE\n         RETURN (14,12),RC=(15)\n         DROP\n***********************************************************************\n*                                                                     *\n*        DEFINE INPUT PARAMETERS FOR IKJPARS                          *\n*                                                                     *\n***********************************************************************\nPCLCSECT IKJPARM\nDSNPCE   IKJPOSIT  DSNAME,LIST,USID,PROMPT='DATA SET NAME',            X\n               HELP='NAME OF THE DATA SET TO BE LISTED'\nCATPCE   IKJKEYWD\n         IKJNAME 'LEVEL',ALIAS='LVL'   1\n         IKJNAME 'CATALOG'             2\n         IKJNAME 'ENTRIES'             3\nALLPCE   IKJKEYWD\n         IKJNAME 'NAME'                1\n         IKJNAME 'ALL'                 2\n         IKJENDP\n* ------------------------------------------------------------------- *\n*        INPUT ROUTINE (SYSIN)                                        *\n* ------------------------------------------------------------------- *\nDDSYSIN  DC    C'DDSYSIN   '           SYSIN DD\nSYSIN00  SAVE  (14,12),,'SYSIN ROUTINE'\n         BASR  R11,0\n         USING *,R11\n         LM    R4,R6,0(R1)             USER DATA, IOFLAGS, IOINFO\n         USING DYNAM,R4\n         CLI   0(R5),X'08'             GET REQUEST?\n         BNE   SYSIN90                 NO, QUIT\n         TS    SYSIN_RC                FIRST TIME?\n         BNZ   SYSIN94                 NO, SIGNAL EOF\n         LM    R1,R2,COMMAND           ADDRESS, LENGTH\n         STM   R1,R2,0(R6)             PASS ADDRESS AND LEN TO IDCAMS\nSYSIN90  RETURN (14,12),RC=00\nSYSIN94  RETURN (14,12),RC=04          EOF\n         DROP\n* ------------------------------------------------------------------- *\n*        OUTPUT ROUTINE (SYSPRINT)                                    *\n* ------------------------------------------------------------------- *\nDDPRINT  DC    C'DDSYSPRINT'           SYSPRINT DD\nPRINT00  SAVE  (14,12),,'SYSPRINT ROUTINE'\n         BASR  R11,0\n         USING *,R11\n         LM    R4,R6,0(R1)             USER DATA, IOFLAGS, IOINFO\n         USING DYNAM,R4\n         CLI   0(R5),X'0C'             PUT REQUEST?\n         BNE   PRINT99                 NO, QUIT\n*LM R1,R2,0(R5)\n*TPUT (R1),(R2)\n         L     R15,=A(PRINT31+VL)      AMODE31\n         BSM   0,R15                   AMODE31\nPRINT31  L     R14,BUFFER              BUFFER PTR\n         L     R15,MAXLRECL            LENGTH\n         LM    R2,R3,0(R6)             ADDR, LEN\n         CLI   0(R2),C'1'              PAGE HEADER?\n         BE    PRINT99                 YES, IGNORE IT\n         CLI   0(R2),C' '              CONTROL CHARACTER?\n         BE    PRINT71                 NO, JUMP\n         MVI   0(R2),C' '              YES, GET RID OF IT\n         SLR   R1,R1\n         ICM   R1,B'1000',BLANKS       PADDING\n         MVCL  R14,R0                  BLANK LINE\n         L     R15,MAXLRECL            RELOAD LENGTH\nPRINT71  ICM   R3,B'1000',BLANKS       PADDING\n         MVCL  R14,R2                  MOVE CURRENT LINE\n         ST    R14,BUFFER              UPDATE BUFFER PTR\nPRINT99  RETURN (14,12),RC=00\n         ORG   *-2\n         BSM   0,R14\n         DROP\n***********************************************************************\n*                                                                     *\n*        READ ROUTINE (BRIF)                                          *\n*                                                                     *\n***********************************************************************\nREADRTN  SAVE  (14,12),,'READRTN'\n         BASR  R11,0\n         USING *,R11\n         LM    R4,R7,0(R1)             INPUT PARMS\n         L     R12,0(,R7)              =A(DYNAM)\n         USING DYNAM,R12\n*\n         L     R3,0(,R6)               RECORD NUMBER (FROM BROWSE)\n         C     R3,MAXRECNO             BEYOND END OF FILE?\n         BH    GOBACK8                 YES, EXIT\n         BCTR  R3,0                    CALCULATE OFFSET\n         M     R2,MAXLRECL             CALCULATE OFFSET\n         AL    R3,BUFFER+8             CHANGE OFFSET TO ADDRESS\n         ST    R3,0(,R4)               PASS RECORD ADDRESS TO BRIF\n**       MVC   0(4,R5),MAXLRECL        PASS RECORD LENGTH TO BRIF\n         RETURN (14,12),RC=00\n*\nGOBACK8  MVC   0(4,R6),MAXRECNO        RETURN MAX RECORD NUMBER\n         RETURN (14,12),RC=8\n*\nRADDR    DC    A(READRTN)              READ ROUTINE (BRIF)\nMAXLRECL DC    F'121'\nBRIF     DC    C'BRIF    '             FUNCTION\nRECFM    DC    C'F '\nH0       DC    2X'00'                  NULL PARM\nBLANKS   DC    CL8' '\n*\nDYNAM    DSECT\n         DS    18F\nIOLIST   DS    A(2,DDSYSIN,SYSIN00,DYNAM,DDPRINT,PRINT00,DYNAM)\nATTACHL  ATTACH SF=L\nTENWORDS DS    10F                     WORK AREA\nSYSIN_RC DS    X'00'\nMAXRECNO DS    F\nECB1     DS   2F'0'\nDYNANSWR DS    A\nCOMMAND  DS    A,F,CL80                INITIAL COMMAND\nDSNAME   DS    CL46                    DSNAME FOR TITLE LINE\nBUFFER   DS    A(15,0,1)               ADDRESS/LENGTH/ADDRESS\nDYNAML   EQU   *-DYNAM\n         YREGS\n         IKJCPPL\n         IKJPPL\nVL       EQU   X'80000000'\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSPRINT DD SYSOUT=*\n//*\n//LKED    EXEC PGM=HEWL,PARM='LIST,MAP,RENT'\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=CBTTAPE.FILE183.LOAD(LCAT),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LINKLLA": {"ttr": 13572, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x03\\x01\\x007\\x00\\x84\\x18\\x0f\\x00\\x99\\x05_\\x10\\x13\\x00\\xf6\\x00\\xbb\\x00N\\xc3\\xc2\\xe3\\xf4\\xf2\\xf0@@@@'", "ispf": {"version": "03.01", "flags": 0, "createdate": "1984-06-28T00:00:00", "modifydate": "1999-02-24T10:13:37", "lines": 246, "newlines": 187, "modlines": 78, "user": "CBT420"}, "text": "//GILBERTL JOB (ACCT#),LINKLLA,\n// NOTIFY=&SYSUID,\n//*RESTART=REFRESH,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = LINKLLA                                               *\n*                                                                     *\n* DESCRIPTIVE NAME = Simulate \"REFRESH LLA\" Command in a Batch Job    *\n*                                                                     *\n* FUNCTION = Issue the LLACOPY macro to refresh an LLA-managed        *\n*            member (or library) without making any modification      *\n*            to SYS1.PARMLIB.  Also, link-edit a module and           *\n*            refresh it in a single step.                             *\n*                                                                     *\n* STATUS = R301                                                       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*          http://gsf-soft.com/Freeware/                              *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = MVS/ESA or OS/390                                 *\n*                   DFSMS/MVS                                         *\n*                                                                     *\n*    AUTHORIZATION = APF                                              *\n*                                                                     *\n*    RESTRICTIONS = NONE                                              *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (BATCH PROGRAM)                            *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 1K                                                 *\n*                                                                     *\n*    ATTRIBUTES = RENT, REUS, RMODE ANY, AMODE 31,                    *\n*                 SUPERVISOR STATE, KEY 8                             *\n*                                                                     *\n* OPERATION = Issues the \"LLACOPY\" macro to send refresh requests     *\n*             to LLA.                                                 *\n*                                                                     *\n* CALLED BY = JCL - three different set-ups are possible:             *\n*                                                                     *\n*        Set-up 1: refresh a whole library (SYSLMOD DD does not       *\n*                  specify a member)                                  *\n*                                                                     *\n*               //WHOLELIB EXEC PGM=LINKLLA                           *\n*               //SYSLMOD  DD DSN=<library-name>,DISP=SHR             *\n*               //SYSPRINT DD SYSOUT=*                                *\n*                                                                     *\n*        Set-up 2: refresh only a member (SYSLMOD DD specifies        *\n*                  a member)                                          *\n*                                                                     *\n*               //ONEMBR  EXEC PGM=LINKLLA                            *\n*               //SYSLMOD  DD DSN=<library-name(member)>,DISP=SHR     *\n*               //SYSPRINT DD SYSOUT=*                                *\n*                                                                     *\n*        Set-up 3: invoke the linkage-editor then refresh the         *\n*                  module (SYSLMOD DD specifies a member name,        *\n*                  and the invocation JCL contains //SYSLIN DD)       *\n*                                                                     *\n*               //LINKRFR EXEC PGM=LINKLLA,PARM='LIST,MAP,RENT'       *\n*               //SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)      *\n*               //SYSLMOD  DD DSN=<library-name(member)>,DISP=SHR     *\n*               //SYSPRINT DD SYSOUT=*                                *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n* 300 New packaging                                                   *\n* 301 Make the code RENT and RMODE=ANY                                *\n*                                                                     *\n***********************************************************************\nLINKLLA  CSECT\nLINKLLA  RMODE ANY\n         DC    C'GSF Utilities - LINKLLA R301'\nBEGIN    BAKR  R14,0                   SAVE THE REGISTERS\n         LR    R12,R15\n         USING BEGIN,R12\n         MODESET MODE=SUP              GET S047 RIGHT AWAY\n         STORAGE OBTAIN,LENGTH=DYNAML,LOC=BELOW,ADDR=(R10)\n         USING DYNAM,R10\n         MVC   SYSLMOD(MODELDCBL),MODELDCB MOVE MODEL DCBS\n         LA    R0,SYSLMOD              OPEN (SYSLMOD,INPUT)\n         ST    R0,OPENLMOD             OPEN (SYSLMOD,INPUT)\n         MVI   OPENLMOD,X'80'          OPEN (SYSLMOD,INPUT)\n         LA    R0,SYSPRINT             OPEN (SYSPRINT,EXTEND)\n         ST    R0,OPENPRT              OPEN (SYSPRINT,EXTEND)\n         MVI   OPENPRT,X'8E'           OPEN (SYSPRINT,EXTEND)\n         LA    R0,EXITLIST             EXIT LIST\n         ST    R0,DCBEXLST-IHADCB+SYSLMOD\n         LA    R0,INFMJFCB             JFCB ADDR\n         ST    R0,EXITLIST             EXIT LIST\n         MVI   EXITLIST,X'87'          EXIT LIST\n         RDJFCB MF=(E,OPENLMOD)        READ THE SYSLMOD JFCB\n         LTR   R15,R15\n         BNZ   GETDIR\n         TM    JFCBIND1,JFCPDS         MEMBER NAME SPECIFIED?\n         BO    SINGLE                  YES, JUMP\n*\n*----------------------------------------------------------------------\n*        READ THE SYSLMOD DIRECTORY TO REFRESH ALL THE MEMBERS\n*----------------------------------------------------------------------\n*\nGETDIR   OPEN  MF=(E,OPENLMOD)         SYSLMOD\n         LTR   R15,R15\n         BNZ   ABEND13\n         OPEN  MF=(E,OPENPRT)          SYSPRINT\n         LTR   R15,R15\n         BNZ   ABEND13\n*LOOP\nGETDIR1  LA    R7,BUFFER               POINT TO BUFFER\n         READ  DECB1,SF,SYSLMOD,(R7),'S',MF=E\n         CHECK DECB1\n         LA    R7,2(,R7)               1ST ENTRY\n*--LOOP\nGETDIR4  CLI   0(R7),X'FF'             END OF DIRECTORY?\n         BE    EOJ                     YES, QUIT\n         BAL   R9,REFRESH          <== REFRESH THIS MEMBER\n         IC    R14,11(,R7)             \"C\" BYTE\n         N     R14,=F'31'              NUMBER OF HALFWORDS\n         LA    R14,12(R14,R14)         ENTRY LENGTH IN R14\n         LH    R15,BUFFER              LENGTH USED\n         LA    R15,BUFFER-1(R15)       END OF BLOCK\n         BXLE  R7,R14,GETDIR4\n*--ENDLOOP\nGETDIR9  B     GETDIR1                 NEXT DIRECTORY BLOCK\n*ENDLOOP\n*\n*----------------------------------------------------------------------\n*        REFRESH A SINGLE MEMBER\n*----------------------------------------------------------------------\n*\nSINGLE   DEVTYPE =C'SYSLIN  ',DWD      DO WE HAVE A SYSLIN DD?\n         LTR   R15,R15\n         BNZ   SINGLE6                 NO DD, JUMP\n         EREG  R1,R1                   POP R1 FROM STACK\n         LINK  EP=IEWL             <== INVOKE THE LINKAGE EDITOR\n         LR    R3,R15                  SAVE RETURN CODE\n         CH    R15,=H'4'\n         BH    EOJ                     RC > 4, SKIP LLACOPY\n*\nSINGLE6  NI    JFCBIND1,255-JFCPDS     Prevent S013-18\n         OPEN  MF=(E,OPENLMOD),TYPE=J  SYSLMOD\n         LTR   R15,R15\n         BNZ   ABEND13\n         OPEN  MF=(E,OPENPRT)          SYSPRINT\n         LTR   R15,R15\n         BNZ   ABEND13\n         LA    R7,JFCBELNM             MEMBER NAME\n         BAL   R9,REFRESH          <== REFRESH A SINGLE MEMBER\n*\nEOJ      CLOSE MF=(E,OPENLMOD)         SYSLMOD\n         CLOSE MF=(E,OPENPRT)          SYSPRINT\n         FREEPOOL SYSPRINT             Free Buffers\n         STORAGE RELEASE,LENGTH=DYNAML,ADDR=(R10) FREE WORK AREA\n         LR    R15,R3                  PASS RETURN CODE\n         PR                            GOBACK TO SYSTEM\n*\nABEND13  ABEND 13                      OPEN ERROR\n*\n*----------------------------------------------------------------------\n*        ISSUE LLACOPY, WRITE LINE TO SYSPRINT\n*----------------------------------------------------------------------\n*\nREFRESH  MVC   BLDLAREA(4),=Y(1,62)\n         MVC   MEMBER,0(R7)            MEMBER NAME\n         LLACOPY DCB=SYSLMOD,                                          X\n               BLDLLIST=BLDLAREA,                                      X\n               MF=(E,LLACOPYL)\n         LR    R3,R15                  SAVE RETURN CODE\n*\n         PUT   SYSPRINT                LOCATE A PRINT RECORD\n         LR    R2,R1                   PASS ADDRESS\n         MVC   0(16,R2),=C' LINKLLA   MBR= '\n         MVC   16(105,R2),15(R2)       CLEAR AREA\n         MVC   15(8,R2),MEMBER         MEMBER NAME\n         LR    R1,R3                   RETURN CODE\n         BAL   R14,CONVHEX             DISPLAY HEX\n         MVC   28(3,R2),=C'RC='        MOVE LITERAL\n         MVC   31(2,R2),6(R1)          MOVE RC\n         ICM   R1,B'1110',TTR\n         BAL   R14,CONVHEX             DISPLAY HEX\n         MVC   38(4,R2),=C'TTR='       MOVE LITERAL\n         MVC   42(6,R2),0(R1)          MOVE TTR\n         ICM   R1,B'1110',TTR+3\n         BAL   R14,CONVHEX             DISPLAY HEX\n         MVC   49(4,R2),0(R1)          MOVE CONCAT#/LIBRARY FLAGS\n         MVC   54(2,R2),4(R1)          MOVE \"C\" BYTE\n         MVC   58(44,R2),JFCBDSNM      MOVE DSNAME\n         BR    R9\n*\nCONVHEX  ST    R1,0(,R13)              PREPARE UNPK\n         LA    R1,28(,R13)             WORK AREA\n         UNPK  0(9,R1),0(5,R13)        EXPAND BYTES\n         NI    0(R1),X'0F'             TURN OFF ZONES\n         MVZ   1(7,R1),0(R1)           TURN OFF ZONES\n         TR    0(8,R1),=C'0123456789ABCDEF'\n         BR    R14\n*\nMODELDCB DCB   DSORG=PO,MACRF=R,DDNAME=SYSLMOD,EXLST=*-*,              N\n               BLKSIZE=256,RECFM=U\n         DCB   DSORG=PS,MACRF=PL,DDNAME=SYSPRINT,RECFM=FBA,LRECL=121\nMODELDCBL EQU  *-MODELDCB\n***********************************************************************\n*                                                                     *\n***********************************************************************\nDYNAM    DSECT\nDWD      DS    D\nOPENLMOD OPEN  (SYSLMOD,INPUT),MF=L\nOPENPRT  OPEN  (SYSPRINT,EXTEND),MF=L\nSYSLMOD  DCB   DSORG=PO,MACRF=R,DDNAME=SYSLMOD,EXLST=EXITLIST,         N\n               BLKSIZE=256,RECFM=U\nSYSPRINT DCB   DSORG=PS,MACRF=PL,DDNAME=SYSPRINT,RECFM=FBA,LRECL=121\n         READ  DECB1,SF,SYSLMOD,BUFFER,'S',MF=L\nEXITLIST DS    A(X'87000000'+INFMJFCB) EXIT LIST\n         IEFJFCBN\n         LLACOPY MF=(L,LLACOPYL)\nRETCODE  DS    H                       RETURN CODE\nBLDLAREA DS    Y(1,62)                 BLDL\nMEMBER   DS    CL8                     BLDL\nTTR      DS    XL3                     BLDL\n         DS    51X                     BLDL\nBUFFER   DS    XL256                   BUFFER\nDYNAML   EQU   *-DYNAM\n         YREGS\n         DCBD  DSORG=PS,DEVD=DA\n         END   BEGIN\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//LKED    EXEC PGM=IEWL,PARM='MAP,RENT,AC=1'\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSPRINT DD SYSOUT=*\n//SYSLMOD  DD DSN=SYS1.P390.LINKLIB(LINKLLA),DISP=SHR\n//*\n//REFRESH EXEC PGM=LINKLLA\n//SYSLMOD  DD DSN=SYS1.P390.LINKLIB(LINKLLA),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//*\n//RC4 EXEC PGM=LINKLLA\n//SYSPRINT DD SYSOUT=*\n//SYSLMOD  DD DSN=SYS1.LPALIB(QWERTY),DISP=SHR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTDSI": {"ttr": 13577, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x00\\x88\\x07\\x9f\\x01\\x06!/\"U\\x00\\xab\\x00\\x11\\x00\\x03\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "1988-03-19T00:00:00", "modifydate": "2006-07-31T22:55:00", "lines": 171, "newlines": 17, "modlines": 3, "user": "CBT472"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* Module Name: LISTDSI                                               */\n/*                                                                    */\n/* Descriptive Name:  Display output of LISTDSI REXX function         */\n/*                                                                    */\n/* Status: R201                                                       */\n/*                                                                    */\n/* Function: This EXEC helps REXX programmers implement the           */\n/*           LISTDSI function by displaying the value of all of       */\n/*           the variables returned by LISTDSI for the specified      */\n/*           data set, as well as providing the syntax, return        */\n/*           codes and reason codes in the form of comments at        */\n/*           the end of the source.                                   */\n/*                                                                    */\n/* Author: Gilbert Saint-Flour <carlos@gsf-soft.com>                  */\n/*                                                                    */\n/* Syntax   =  LISTDSI                                                */\n/*                 dsname|*              data set name                */\n/*                 VOL(volume)           volume serial                */\n/*                 DIRECTORY             get directory info           */\n/*                 RECALL                HRECALL                      */\n/*                 SMSINFO               get SMS info                 */\n/*                                                                    */\n/* Environment: TSO/E V2                                              */\n/*              ISPF/PDF 2.3  (optional)                              */\n/*              STEMVIEW R105 (optional)                              */\n/*                                                                    */\n/*201 SYSSEQDSNTYPE z/OS 1.8                                          */\n/**********************************************************************/\nIF SYSVAR(SYSISPF)='ACTIVE' THEN DO\n  ADDRESS ISPEXEC\n  'ISREDIT MACRO (dsname opt)'\n  IF rc=0 THEN DO\n    IF dsname='' | dsname='*' THEN DO    /* Current Data Set          */\n      \"ISREDIT (dsname) = DATASET\"       /* Retrieve dsname           */\n      dsname=\"'\" || dsname || \"'\"        /* Enclose dsname in quotes  */\n      END\n    END\n  ELSE\n    ARG dsname opt                       /* Invoked as TSO %LISTDSI   */\n  END\nELSE\n  ARG dsname opt                         /* Invoked outside ISPF      */\n\nUPPER dsname opt                         /* Convert to upper-case     */\n\nADDRESS TSO\n\"MAKEBUF\"\nQUEUE 'command=LISTDSI('dsname opt')'\nrc=LISTDSI(dsname opt)\nQUEUE 'RC='rc\nQUEUE 'SYSADIRBLK='sysadirblk                         /* DIRECTORY */\nQUEUE 'SYSALLOC='sysalloc\nQUEUE 'SYSBLKSIZE='sysblksize\nQUEUE 'SYSBLKSTRK='sysblkstrk\nQUEUE 'SYSCREATE='syscreate\nQUEUE 'SYSDATACLASS='sysdataclass                     /* SMSINFO */\nQUEUE 'SYSDSNAME='sysdsname\nQUEUE 'SYSDSORG='sysdsorg\nQUEUE 'SYSDSSMS='sysdssms                             /* SMSINFO */\nQUEUE 'SYSEXDATE='sysexdate\nQUEUE 'SYSEXTENTS='sysextents\nQUEUE 'SYSKEYLEN='syskeylen\nQUEUE 'SYSLRECL='syslrecl\nQUEUE 'SYSMEMBERS='sysmembers                         /* DIRECTORY */\nQUEUE 'SYSMGMTCLASS='sysmgmtclass                     /* SMSINFO */\nQUEUE 'SYSMSGLVL1='sysmsglvl1\nQUEUE 'SYSMSGLVL2='sysmsglvl2\nQUEUE 'SYSPASSWORD='syspassword\nQUEUE 'SYSPRIMARY='sysprimary\nQUEUE 'SYSRACFA='sysracfa\nQUEUE 'SYSREASON='sysreason\nQUEUE 'SYSRECFM='sysrecfm\nQUEUE 'SYSREFDATE='sysrefdate\nQUEUE 'SYSSECONDS='sysseconds\nQUEUE 'SYSSEQDSNTYPE='sysseqdsntype                   /* z/OS 1.8 */\nQUEUE 'SYSSTORCLASS='sysstorclass                     /* SMSINFO */\nQUEUE 'SYSTRKSCYL='systrkscyl\nQUEUE 'SYSUDIRBLK='sysudirblk                         /* DIRECTORY */\nQUEUE 'SYSUNIT='sysunit\nQUEUE 'SYSUNITS='sysunits\nQUEUE 'SYSUPDATED='sysupdated\nQUEUE 'SYSUSED='sysused\nQUEUE 'SYSUSEDPAGES='sysusedpages                    /* SMSINFO   */\nQUEUE 'SYSVOLUME='sysvolume\n\nIF SYSVAR(SYSISPF)='ACTIVE' THEN DO\n  SIGNAL ON SYNTAX                  /*    STEMVIEW not available     */\n  CALL STEMVIEW 'VIEW',,,,'LISTDSI' dsname opt\n  END\nELSE\n  CALL DISPLAY                      /*    not running in ISPF        */\n\n\"DROPBUF\"\nEXIT\n\nSYNTAX:                            /* STEMVIEW function not available */\n  error=rc\n  'ISPEXEC CONTROL DISPLAY LINE START(1)'\n  SAY 'REXX error' error 'in line' sigl':' errortext(error)\n  SAY sourceline(sigl)\n  SAY ''\n\nDISPLAY:  DO WHILE QUEUED()>0; PULL line; SAY line; END\n  \"DROPBUF\"\n  EXIT\n\n/**********************************************************************/\n/*                                                                    */\n/* LISTDSI Syntax                                                     */\n/*                                                                    */\n/*   LISTDSI(dsname VOL(volume) DIRECTORY RECALL SMSINFO)             */\n/*   LISTDSI(dsname PREALLOC    DIRECTORY        SMSINFO)             */\n/*   LISTDSI(ddname FILE        DIRECTORY        SMSINFO)             */\n/*                                                                    */\n/* LISTDSI Return Codes                                               */\n/*                                                                    */\n/*   0   LISTDSI processing was successful.                           */\n/*       Data set information was retrieved.                          */\n/*   4   LISTDSI processing was successful.  However, some data set   */\n/*       information is unavailable.  All data set information,       */\n/*       other than directory information, can be considered valid.   */\n/*   16  LISTDSI processing was not successful.  An error occurred.   */\n/*       None of the variables containing information about the data  */\n/*       set can be considered valid, except for SYSREASON.           */\n/*       The SYSREASON variable contains the LISTDSI reason code.     */\n/*                                                                    */\n/* LISTDSI Reason Codes                                               */\n/*                                                                    */\n/*   0   Normal completion.                                           */\n/*   1   Error parsing the function.                                  */\n/*   2   Dynamic allocation processing error.                         */\n/*   3   The data set is a type that cannot be processed.             */\n/*   4   Error determining UNIT name.                                 */\n/*   5   Data set not cataloged.                                      */\n/*   6   Error obtaining the data set name.                           */\n/*   7   Error finding device type.                                   */\n/*   8   The data set does not reside on DASD.                        */\n/*   9   DFHSM migrated the data set.                                 */\n/*       NORECALL prevents retrieval.                                 */\n/*   11  Directory information was requested, but you lack            */\n/*       authority to access the data set.                            */\n/*   12  VSAM data sets are not supported.                            */\n/*   13  The data set could not be opened.                            */\n/*   14  Device type not found in unit control block (UCB) tables.    */\n/*   17  System or user abend occurred.                               */\n/*   18  Partial data set information was obtained.                   */\n/*   19  Data set resides on multiple volumes.                        */\n/*   20  Device type not found in eligible device table (EDT).        */\n/*   21  Catalog error trying to locate the data set.                 */\n/*   22  Volume not mounted.                                          */\n/*   23  Permanent I/O error on volume.                               */\n/*   24  Data set not found.                                          */\n/*   25  Data set migrated to non-DASD device.                        */\n/*   27  No volume serial is allocated to the data set.               */\n/*   28  The ddname must be one to eight characters.                  */\n/*   29  Data set name or ddname must be specified.                   */\n/*   30  Data set is not SMS-managed.                                 */\n/*   31  ISITMGD macro returned with bad return code and reason code. */\n/*       Return code and reason code can be found in message          */\n/*       IKJ58431I, which is returned in variable &SYSMSGLVL2.        */\n/*   32  Unable to retrieve SMS information.                          */\n/*       DFSMS/MVS has incorrect level.                               */\n/*   33  Unable to retrieve SMS information.                          */\n/*       DFSMS/MVS is not active.                                     */\n/*   34  Unable to retrieve SMS information.  OPEN error.             */\n/*   35  Unexpected error from DFSMS/MVS internal service IGWFAMS.    */\n/*   36  Unexpected error from the SMS service module.                */\n/*                                                                    */\n/**********************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LLIBDEF1": {"ttr": 13581, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x12\\x0f\\x00\\x933O\\x110\\x00W\\x00g\\x00\\x00\\xc3\\xc2\\xe3\\xf3\\xf7\\xf1@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-29T00:00:00", "modifydate": "1993-11-30T11:30:00", "lines": 87, "newlines": 103, "modlines": 0, "user": "CBT371"}, "text": "//GILBERTL JOB (ACCT#),LLIBDEF1,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//*\n//ASMH EXEC PGM=IEV90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n*        PRELOAD A PROGRAM FROM ISPLLIB LIBDEF LIBRARY                *\n*                                                                     *\n*        THIS PROGRAM ALLOWS YOU TO PRE-LOAD A REUS OR                *\n*        RENT MODULE FROM A LOAD LIBRARY DEFINED VIA                  *\n*        LIBDEF.  THIS CAN PREVENT S806-4 ABENDS THAT                 *\n*        OCCUR WHEN A PROGRAM THAT IS NOT LIBDEF-AWARE                *\n*        TRIES TO ACCESS ANOTHER PROGRAM VIA LOAD OR LINK.            *\n*                                                                     *\n*        EXAMPLE:                                                     *\n*                                                                     *\n*        /*           DEFINE ALTERNATE LOADLIB                 */     *\n*        \"ISPEXEC LIBDEF ISPLLIB DATASET ID('MYAPPL.LOADLIB')\"        *\n*        /*           PRE-LOAD THE TABLE                       */     *\n*        \"ISPEXEC SELECT PGM(LLIBDEF1) PARM(MYTABLE)\"                 *\n*        /*           INVOKE THE APPLICATION'S MAIN MENU       */     *\n*        \"ISPEXEC SELECT PANEL(MYPANEL)\"                              *\n*                                                                     *\n***********************************************************************\nLLIBDEF1 START 0\n         SAVE  (14,12),,'GSF UTILITIES - LLIBDEF1 R100'\n         LR    R12,R15\n         USING LLIBDEF1,R12\n         ICM   R2,B'1111',0(R1)        GET PARM ADDR, CHECK X'80' BIT\n         BP    QUIT12                  QUIT IF INVOKED AS A CP\n*----------------------------------------------------------------------\n*\n*        MOVE PROGRAM NAME TO BLDL LIST\n*\n*----------------------------------------------------------------------\n         LA    R14,2(,R2)              ADDR OF MODULE IN PARM\n         LH    R15,0(,R2)              PARM LENGTH\n         ICM   R15,B'1000',=C' '       PADDING (X'40')\n         LA    R0,PDS2NAME             TARGET AREA\n         LA    R1,L'PDS2NAME           TARGET AREA\n         MVCL  R0,R14                  MOVE PGM NAME\n*----------------------------------------------------------------------\n*\n*        RETRIEVE DCB ADDRESS FROM LINK PARM LIST\n*\n*----------------------------------------------------------------------\n         L     R1,540(,0)              PSATOLD\n         L     R2,00(,R1)              TCBRBP\n         L     R3,RBGRS15-RBBASIC(,R2) SVC 6 PARM LIST\n         LM    R5,R6,0(R3)             PGM NAME/DEFLLIB DCB\n*----------------------------------------------------------------------\n*\n*        LOCATE PROGRAM USING BLDL MACRO AND LOAD IT\n*\n*----------------------------------------------------------------------\n         BLDL  (R6),BLDL_HDR           LOCATE THE PROGRAM IN TASKLIB\n         LTR   R15,R15                 CHECK RETURN CODE\n         BNZ   QUIT16                  QUIT IF PGM NOT FOUND\n         LOAD  DE=PDS2NAME,            LOAD THE MODULE                 X\n               DCB=(R6),               FROM LIBDEF DCB                 X\n               LSEARCH=YES,            LIMIT SEARCH                    X\n               ERRET=QUIT24            PREVENT TASK ABEND\n         RETURN (14,12),RC=00\nQUIT12   RETURN (14,12),RC=12          PROGRAM INVOKED AS A COMMNAD\nQUIT16   RETURN (14,12),RC=16          BLDL FAILED\nQUIT24   RETURN (14,12),RC=24          LOAD FAILED\n*----------------------------------------------------------------------\nBLDL_HDR DC    0F'0',H'1,80'           BLDL HDR\n         IHAPDS PDSBLDL=YES,DSECT=NO\nRBBASIC  DSECT                         IKJRB/IHARB\nRBSTAB2  EQU   *+X'0B',1,C'B'          STATUS BYTE\nRBCDE    EQU   *+X'0C',4,C'A'          PTR TO CDE\nRBTCBNXT EQU   X'80'                   FIRST (OLDEST) RB IN CHAIN\nRBGRS15  EQU   *+X'5C',4,C'F'          R15 SLOT\n         YREGS                         SYS1.MACLIB\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSPRINT DD SYSOUT=*\n//*\n//LKED    EXEC PGM=HEWL,PARM=(MAP,REUS)\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//SYSPRINT DD SYSOUT=*\n//SYSLMOD  DD DSN=CBTTAPE.FILE183.LOAD(LLIBDEF1),DISP=SHR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOADMLPA": {"ttr": 13827, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x03\\x02\\x00$\\x00x\\x14?\\x00\\x99\\x14\\x8f\\x12\\x12\\x02\\x97\\x00?\\x00Q\\xc3\\xc2\\xe3\\xf4\\xf2\\xf1@@@@'", "ispf": {"version": "03.02", "flags": 0, "createdate": "1978-05-23T00:00:00", "modifydate": "1999-05-28T12:12:24", "lines": 663, "newlines": 63, "modlines": 81, "user": "CBT421"}, "text": "//GILBERTL JOB (ACCT#),LOADMLPA,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF,RENT)\n*PROCESS BATCH,USING(NOMAP,WARN(8))\n***********************************************************************\n*                                                                     *\n* MODULE NAME = LOADMLPA                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = INSTALL A REENTRANT MODULE INTO THE MLPA.        *\n*                                                                     *\n* FUNCTION = THIS PROGRAM LOADS A REENTRANT MODULE INTO THE           *\n*            CSA AND ADDS AN ENTRY TO THE ACTIVE LPA QUEUE.           *\n*                                                                     *\n* STATUS = R302                                                       *\n*                                                                     *\n* AUTHOR = GILBERT SAINT-FLOUR <carlos@gsf-soft.com>                  *\n*          http://gsf-soft.com/Freeware/                              *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = MVS/XA, MVS/ESA                                   *\n*                                                                     *\n*    AUTHORIZATION = APF                                              *\n*                                                                     *\n*    RESTRICTIONS = INVOKER MUST HAVE UPDATE AUTHORITY TO             *\n*                   SYS1.PARMLIB.                                     *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (BATCH PROGRAM)                            *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 4K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE ANY, AMODE 31,                   *\n*                 SUPERVISOR STATE, KEY 0                             *\n*                                                                     *\n* OPERATION = LOADMLPA BUILDS A CDE AND EXTENT-LIST TO REPRESENT      *\n*             THE MODULE, THEN CHAINS THE CDE TO THE BOTTOM OF THE    *\n*             ACTIVE LPA QUEUE (ALPAQ). IF THE MODULE IS AN ALIAS,    *\n*             THEN TWO CDE'S ARE CREATED AND ADDED TO THE ALPAQ.      *\n*                                                                     *\n*             LOADMLPA CHECKS FOR EXISTING ENTRIES IN THE LPAQ.       *\n*             IF THE ENTRY-POINT (OR THE CORRESPONDING MAJOR NAME)    *\n*             IS (OR ARE) ALREADY IN THE LPAQ, THEN THE PROGRAM       *\n*             TERMINATES WITH RC=12.                                  *\n*                                                                     *\n*             IF AN OLD VERSION OF THE MODULE IS ALREADY IN PLPA,     *\n*             THE NEW COPY MUST BE LOADED FROM A STEPLIB.             *\n*                                                                     *\n* INVOCATION = LOADMLPA IS INVOKED VIA JCL, AS FOLLOWS:               *\n*                                                                     *\n*        //LOADMLPA EXEC PGM=LOADMLPA,PARM='LOAD,MMMMMMMM'            *\n*                                                                     *\n*            MMMMMMMM IS THE NAME OF A LOAD MODULE (OR ALIAS)         *\n*                 THAT YOU WANT TO INSTALL IN MLPA.  IT MUST          *\n*                 COME FROM AN AUTHORIZED LIBRARY (JOBLIB,            *\n*                 STEPLIB OR LINK-LIST)                               *\n*                                                                     *\n*        //REMOVE EXEC PGM=LOADMLPA,PARM='DELETE,MMMMMMMM'            *\n*                                                                     *\n*            MMMMMMMM IS THE NAME OF THE LOAD MODULE (OR ALIAS)       *\n*                 THAT YOU WANT TO REMOVE FROM MLPA.                  *\n*                                                                     *\n* RETURN CODES = LOADMLPA PRODUCES RETURN-CODES AND ABENDS,           *\n*                AS FOLLOWS:                                          *\n*                                                                     *\n*    RETURN-CODES:                                                    *\n*                                                                     *\n*        0  SUCCESSFUL COMPLETION: MODULE HAS BEEN LOADED INTO MLPA   *\n*                                                                     *\n*        4  MODULE NOT IN MLPA (DELETE FUNCTION)                      *\n*                                                                     *\n*        8  USER NOT AUTHORIZED TO UPDATE SYS1.PARMLIB                *\n*                                                                     *\n*       12  MODULE ALREADY PRESENT IN MLPA                            *\n*                                                                     *\n*       16  PARM IS INVALID                                           *\n*                                                                     *\n*       20  MODULE FOUND IN PLPA; LOAD IT FROM A STEPLIB              *\n*                                                                     *\n*    ABENDS:                                                          *\n*                                                                     *\n*      S047     LOADMLPA MODULE NOT AUTHORIZED                        *\n*                                                                     *\n*      S306-08  TARGET MODULE NOT RE-ENTRANT                          *\n*                                                                     *\n*      S306-0C  TARGET MODULE NOT FROM AN AUTHORIZED LIBRARY          *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n* 301 NEW PACKAGING FOR CBT TAPE                                      *\n* 302 FIX BAD BRANCH TO EXIT20 LABEL                                  *\n*                                                                     *\n***********************************************************************\nLOADMLPA CSECT\nLOADMLPA RMODE ANY\n         SAVE  (14,12),,'GSF UTILITIES - LOADMLPA R302'\n         LR    R12,R15\n         USING LOADMLPA,R12\n         L     R11,0(,R1)              PARM ADDRESS\n         USING PARM,R11\n*\n*        GET ABENDS047 IF THE PROGRAM IS NOT APF-AUTHORIZED\n*\n         MODESET MODE=PROB             CHECK APF AUTHORIZATION\n*\n*        ALLOCATE DYNAMIC STORAGE\n*\n         GETMAIN R,LV=DYNAML           DYNAMIC STORAGE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DYNAM,R13\n         LA    R14,DYNAM+72            CLEAR WORK AREA\n         LA    R15,DYNAML-72           CLEAR WORK AREA\n         SLR   R1,R1                   CLEAR WORK AREA\n         MVCL  R14,R0                  CLEAR WORK AREA\n*\n*        PROCESS JCL PARM\n*\nPARM00   LA    R0,PARMFUNC+5           1ST BYTE AFTER FUNCTION\n         CLC   =C'LOAD,',PARMFUNC      FUNCTION=LOAD?\n         BE    PARM10                  YES, JUMP\n         LA    R0,PARMFUNC+7           1ST BYTE AFTER FUNCTION\n         CLC   =C'DELETE,',PARMFUNC    FUNCTION=DELETE?\n         BNE   EXIT16                  NO, QUIT\n*\nPARM10   LA    R14,MODULE              MODULE NAME\n         LA    R15,L'MODULE            MAX LENGTH\n         MVC   FUNCTION,PARMFUNC       L=LOAD, D=DELETE\n*\n*        MOVE MODULE NAME TO WORK AREA\n*\n*\nPARM20   LH    R1,PARMLEN              PARM LENGTH\n         LA    R1,PARMFUNC(R1)         FIRST BYTE AFTER PARM\n         SR    R1,R0                   LENGTH OF NAME\n         BZ    EXIT16                  NO NAME, QUIT\n         CLR   R1,R15                  LENGTH > 8?\n         BH    EXIT16                  YES, QUIT\n         ICM   R1,B'1000',=X'40'       PADDING CHARACTER\n         MVCL  R14,R0                  MOVE MODULE NAME, PAD WITH X'40'\n         DROP  R11\n***********************************************************************\n*                                                                     *\n*        CHECK THAT THE USER HAS \"UPDATE\" AUTHORITY TO SYS1.PARMLIB.  *\n*                                                                     *\n*        IF HE DOESN'T, EXIT WITH RC=8                                *\n*                                                                     *\n***********************************************************************\n         L     R14,RACF_CML            CAMLST 1ST WORD\n         LA    R15,RACF_DSN            DATA SET NAME\n         SLR   R0,R0\n         LA    R1,RACFWORK             WORK AREA\n         STM   R14,R1,SIXWORDS         STORE RELOCATED CAMLST\n         LOCATE SIXWORDS               GET VOLSER AND DEVICE TYPE\n         LTR   R15,R15                 CHECK FOR SUCCESSFUL COMPLETION\n         BNZ   EXIT8                   LOCATE FAILED, EXIT\n         MVC   RACF_VOL,RACFWORK+6     VOLSER\n*\n         MVC   RACF_DYN(RACF_LEN),RACF_MOD\n         RACROUTE REQUEST=AUTH,                                        X\n               WORKA=RACFWORK,                                         X\n               VOLSER=RACF_VOL,        VOLUME                          X\n               MF=(E,RACF_DYN)\n         LTR   R15,R15                 USER AUTHORIZED?\n         BZ    CHKFUNC                 YES, CONTINUE\n*\n         L     R2,PSAAOLD-PSA          POINT TO MY ASCB.\n         L     R2,ASCBASXB-ASCB(,R2)   POINT TO MY ASXB.\n         L     R2,ASXBSENV-ASXB(,R2)   POINT TO MY ACEE.\n         USING ACEE,R2\n         CLC   =CL8'IBMUSER',ACEEUSRI  AUTHORIZED USER?\n         BE    CHKFUNC                 YES, CONTINUE\n         DROP  R2                      ACEE\n         B     EXIT8                   NO, QUIT\n*\nRACF_MOD RACROUTE REQUEST=AUTH,        CHECK AUTHORIZATION             X\n               LOG=NONE,               DO NOT LOG FAILURES             X\n               CLASS='DATASET',        CHECK FOR DATASET AUTHORITY     X\n               ENTITY=RACF_DSN,        DATA SET NAME                   X\n               ATTR=UPDATE,            MUST BE ALLOWED TO UPDATE       X\n               MF=L\nRACF_DSN DC    CL44'SYS1.PARMLIB'\nRACF_CML CAMLST NAME,*-*,,*-*          CAMLST FOR LOCATE\n*\nCHKFUNC  CLI   FUNCTION,C'D'           PARM=DELETE?\n         BE    DEL00                   YES, JUMP\n***********************************************************************\n*                                                                     *\n*        LOAD THE MODULE TO CREATE A CDE/XTLST                        *\n*                                                                     *\n*        THIS IS A TRIAL LOAD OF THE MODULE TO CHECK                  *\n*        ITS EXISTENCE, VALIDITY, ETC.                                *\n*                                                                     *\n*        IF THE LOAD IS SUCCESSFUL, THE CDE AND XTLST CREATED BY      *\n*        LOAD ARE RETRIEVED FROM THE JPAQ AND USED AS A MODEL TO      *\n*        CREATE THE CDE AND XTLST IN SQA.                             *\n*                                                                     *\n*        ONCE THE CDE (AND XTLST) HAVE BEEN PROCESSED, A DELETE       *\n*        MACRO IS ISSUED TO FREE UP THE SPACE.                        *\n*                                                                     *\n***********************************************************************\nJPAQ00   L     R4,PSATOLD-PSA          PSATOLD (MY TCB)\n         USING TCB,R4\n         ICM   R2,B'1111',TCBJLB       JOBLIB/STEPLIB/TASKLIB DCB\n         BNZ   JPAQ12                  OK, JUMP\n         L     R1,CVTPTR               NO STEPLIB, USE LINKLIST\n         L     R2,CVTLINK-CVT(,R1)     DCB FOR SYS1.LINKLIB\nJPAQ12   ST    R2,STEPLIB              SAVE FOR 2ND LOAD\n*\n         LOAD  EPLOC=MODULE,           ENTRY-POINT NAME                X\n               GLOBAL=YES,             LOAD INTO SP 241                X\n               DCB=(R2),               JOBLIB/STEPLIB OR LINKLIST      X\n               SF=(E,LOAD1L)\n*\n*        RETRIEVE THE CDE FROM THE JPAQ\n*\n         L     R4,TCBJSTCB             THE JOB STEP TCB\n         L     R5,TCBJPQ               POINT TO FIRST CDE IN CHAIN\n         USING CDENTRY,R5\n*LOOP\nJPAQ21   CLC   MODULE,CDNAME           IS THIS MY MODULE?\n         BE    SCAN00                  YES, EXIT\n         ICM   R5,B'1111',CDCHAIN      CHECK FOR END OF CHAIN\n         BNZ   JPAQ21                  LOOP THROUGH RB TABLE\n*ENDLOOP\n         B     EXIT20                  NOT FOUND IN JPAQ\n         DROP  R4                      TCB\n***********************************************************************\n*                                                                     *\n*        SCAN THE JPAQ TO CHECK IF THE MODULE IS ALREADY THERE        *\n*                                                                     *\n*        IF IT'S FOUND, EXIT WITH RC=12                               *\n*                                                                     *\n***********************************************************************\nSCAN00   MVC   MAJNAME,CDNAME          MAJOR NAME\n         TM    CDATTR,CDMIN            IS THIS A MINOR CDE?\n         BZ    SCAN12                  NO, JUMP\n         L     R1,CDXLMJP              POINT TO MAJOR CDE\n         MVC   MAJNAME,CDNAME-CDENTRY(R1)   MAJOR NAME\n*\nSCAN12   L     R3,CVTPTR\n         L     R6,CVTQLPAQ-CVT(,R3)    ACTIVE LPA QUEUE\n         USING CDENTRY,R6\n*LOOP\nSCAN31   CLC   MODULE,CDNAME           IS THIS MY NAME?\n         BE    EXIT12                  YES, QUIT\n         CLC   MAJNAME,CDNAME          IS THIS MY NAME?\n         BE    EXIT12                  YES, QUIT\n         ICM   R6,B'1111',CDCHAIN      END OF CHAIN?\n         BNZ   SCAN31                  NO, LOOP\n*ENDLOOP\n         DROP  R6\n***********************************************************************\n*                                                                     *\n*        ALLOCATE SPACE IN SQA FOR THE CDE & XTLST                    *\n*                                                                     *\n*        IF THE ENTRY-POINT IS AN ALIAS, GET SPACE FOR 2 CDE'S        *\n*                                                                     *\n***********************************************************************\nBUILD10  LA    R2,CDE_LEN+XTL_LEN      LENGTH OF CDE + XTLST\n         TM    CDATTR,CDMIN            IS THIS A MINOR CDE?\n         BZ    BUILD12                 NO, JUMP\n         ST    R5,JPAMINOR             SAVE ADDR OF MINOR CDE\n         L     R5,CDXLMJP              POINT TO MAJOR CDE\n         LA    R2,CDE_LEN+XTL_LEN+CDE_LEN   ROOM FOR 2 CDE'S AND 1 XTL\n*\nBUILD12  GETMAIN R,                    GET STORAGE FOR CDE/XTLST       X\n               SP=245,                 SQA, FIXED                      X\n               LV=(R2)                 LENGTH OF CDE + XTLST\n         ST    R1,LPAMAJOR             SAVE ADDRESS\n*\n         LR    R6,R1                   NEW CDE\n         USING CDENTRY,R6\n         MODESET KEY=ZERO\n         MVC   CDENTRY(CDE_LEN),0(R5)  MOVE MAJOR CDE\n         XC    CDCHAIN,CDCHAIN         END OF CHAIN\n         OI    CDATTR,CDNIP            NIP=1,JPAQ=0\n         NI    CDATTR,255-CDJPA        NIP=1,JPAQ=0\n         MVI   CDATTRB,0               RESET CDEX FLAG\n         XC    CDUSE,CDUSE             USE COUNT IS ZERO\n*\n         LA    R7,CDENTRY+CDE_LEN      NEW XTLST\n         USING XTLST,R7\n         L     R1,CDXLMJP              ADDR OF ORIGINAL XTLST\n         MVC   XTLST(XTL_LEN),0(R1)    MOVE XTLST\n         ST    R7,CDXLMJP              ADDR OF NEW XTLST\n*\n*        SET-UP THE MINOR CDE IF THE ENTRY-POINT IS AN ALIAS\n*\n         ICM   R5,B'1111',JPAMINOR     POINT TO THE MINOR CDE\n         BZ    BUILD38                 NO MINOR CDE, JUMP\n*\n         LA    R1,CDENTRY+CDE_LEN+XTL_LEN  MY MINOR CDE\n         ST    R1,CDCHAIN              MAJOR-->MINOR\n         LR    R6,R1                   MY MINOR CDE\n         MVC   CDENTRY(CDE_LEN),0(R5)  MOVE MINOR CDE\n         XC    CDCHAIN,CDCHAIN         END OF CHAIN\n         OI    CDATTR,CDNIP            NIP=1,JPAQ=0\n         NI    CDATTR,255-CDJPA        NIP=1,JPAQ=0\n         MVI   CDATTRB,0               RESET CDEX FLAG\n         MVC   CDXLMJP,LPAMAJOR        POINT TO MAJOR CDE\n*\n*        FREE UP THE TRIAL COPY OF THE MODULE\n*\nBUILD38  MODESET KEY=NZERO\n         DELETE EPLOC=MODULE           DELETE PATTERN MODULE\n*\n***********************************************************************\n*                                                                     *\n*        LOAD THE MODULE INTO THE CSA (SP=241,KEY=0)                  *\n*                                                                     *\n*        UPDATE LOAD-POINT AND ENTRY-POINT ADDRESSES IN CDE/XTLST     *\n*                                                                     *\n***********************************************************************\n*\nLOAD00   SLR   R2,R2\n         ICM   R2,B'0111',XTLMSBLN     24-BIT LENGTH\n         MODESET KEY=ZERO\n         CLI   XTLMSBAD,0              RMODE=ANY?\n         BNE   LOAD31                  YES, JUMP\n*\n*        ALLOCATE CSA SPACE (RMODE=24)\n*\n         GETMAIN R,                    RMODE=24                        X\n               SP=241,                 CSA, KEY=0                      X\n               LV=(R2)                 LENGTH OF THE MODULE\n         B     LOAD40\n*\n*        ALLOCATE CSA SPACE (RMODE=ANY)\n*\nLOAD31   GETMAIN RU,                   RMODE=ANY                       X\n               SP=241,                 CSA, KEY=0                      X\n               LV=(R2),                LENGTH OF THE MODULE            X\n               LOC=ANY                 RMODE=31\n*\n*        LOAD MODULE INTO CSA (USING MAJOR ENTRY POINT NAME)\n*\nLOAD40   LR    R2,R1                   LOAD POINT ADDRESS\n         L     R3,STEPLIB              STEPLIB DCB\n         L     R6,LPAMAJOR             MAJOR CDE\n         LOAD  EPLOC=MAJNAME,          MODULE NAME                     X\n               ADDR=(R2),              LOAD INTO CSA (SP 241)          X\n               DCB=(R3),               JOBLIB/STEPLIB/TASKLIB/LINKLIST X\n               SF=(E,LOAD2L)\n         ST    R0,CDENTPT              ENTRY POINT OF MAJOR NAME\n*\n*        SET UP ADDR OF MINOR ENTRY-POINT\n*\n         ICM   R6,B'1111',CDCHAIN      DO WE HAVE A MINOR ENTRY POINT?\n         BZ    LOAD90                  NO, QUIT\n         ST    R6,LPAMINOR             YES, KEEP IT FOR DSPLY\n         L     R0,CDENTPT              GET JPAQ ENTRY-POINT\n         SL    R0,XTLMSBAD             OFFSET TO MINOR EP\n         ALR   R0,R2                   CHANGE OFFSET TO ADDRESS\n         ST    R0,CDENTPT              STORE RELOCATED ENTRY POINT\n*\nLOAD90   ST    R2,XTLMSBAD             LOAD-POINT\n         DROP  R6,R7                   CDE, XTLST\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CHAIN THE CDE AT THE BOTTOM OF THE LPAQ                      *\n*                                                                     *\n*---------------------------------------------------------------------*\nCHAIN    MODESET KEY=ZERO,MODE=SUP\n         SETLOCK OBTAIN,                                               X\n               TYPE=LOCAL,             LOCAL LOCK                      X\n               MODE=UNCOND,                                            X\n               REGS=USE,               DO NOT CHANGE R11-R13           X\n               RELATED=CHAIN9\n         SETLOCK OBTAIN,                                               X\n               TYPE=CMS,               CROSS-MEMORY SERVICES           X\n               MODE=UNCOND,                                            X\n               REGS=USE,               DO NOT CHANGE R11-R13           X\n               RELATED=CHAIN9\n*\n         L     R3,CVTPTR\n         L     R6,CVTQLPAQ-CVT(,R3)    ACTIVE LPA QUEUE\n         L     R0,0(,R6)               FIRST CDE IN LPAQ\n*LOOP\nCHAIN3   LR    R6,R0                   PASS ADDR OF NEXT CDE\n         USING CDENTRY,R6\n         ICM   R0,B'1111',CDCHAIN      END OF CHAIN?\n         BNZ   CHAIN3                  NO, LOOP\n*ENDLOOP\n         MVC   CDCHAIN,LPAMAJOR        UPDATE FWD PTR\n         DROP  R6\n*\nCHAIN9   SETLOCK RELEASE,                                              X\n               TYPE=ALL,               LOCAL AND CMS                   X\n               REGS=USE,               DO NOT CHANGE R11-R13           X\n               RELATED=CHAIN1\n         MODESET KEY=NZERO,MODE=PROB\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DISPLAY CDE/XTLST ON CONSOLE                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\nDSPLY00  WTO   MF=(E,WTO1L)            DISPLAY HEADER\n         MVC   WTO1M(WTO1LL),WTO1L     MOVE MODEL WTO\n         MVC   WTO1TEXT+1(L'WTO1TEXT-1),WTO1TEXT  BLANK HEADER OUT\n*\nDSPLY20  L     R6,LPAMAJOR             POINT TO MAJOR CDE\n         USING CDENTRY,R6\n         L     R7,CDXLMJP              POINT TO XTLST (OR MAJOR CDE)\n         USING XTLST,R7\n         MVC   WTO1TEXT+3(L'CDNAME),CDNAME\n         ICM   R0,B'1111',CDENTPT      CONVERT TO HEX\n         BAL   R14,DSPLYHEX            CONVERT TO HEX\n         MVC   WTO1TEXT+12(8),SIXWORDS\n         ICM   R0,B'1111',CDATTRB      CONVERT TO HEX\n         BAL   R14,DSPLYHEX            CONVERT TO HEX\n         MVC   WTO1TEXT+23(2),SIXWORDS\n         ICM   R0,B'1111',CDSP         CONVERT TO HEX\n         BAL   R14,DSPLYHEX            CONVERT TO HEX\n         MVC   WTO1TEXT+27(2),SIXWORDS\n         ICM   R0,B'1111',CDATTR       CONVERT TO HEX\n         BAL   R14,DSPLYHEX            CONVERT TO HEX\n         MVC   WTO1TEXT+31(2),SIXWORDS\n         ICM   R0,B'1111',CDATTR2      CONVERT TO HEX\n         BAL   R14,DSPLYHEX            CONVERT TO HEX\n         MVC   WTO1TEXT+37(2),SIXWORDS\n         ICM   R0,B'1111',CDUSE        CONVERT TO HEX\n         BAL   R14,DSPLYHEX            CONVERT TO HEX\n         MVC   WTO1TEXT+43(4),SIXWORDS\n         ICM   R0,B'1111',XTLMSBLN     CONVERT TO HEX\n         BAL   R14,DSPLYHEX            CONVERT TO HEX\n         MVC   WTO1TEXT+60(6),SIXWORDS\n         ICM   R0,B'1111',XTLMSBAD     CONVERT TO HEX\n         BAL   R14,DSPLYHEX            CONVERT TO HEX\n         MVC   WTO1TEXT+69(8),SIXWORDS\n         ICM   R0,B'1111',LPAMAJOR+1   CONVERT TO HEX\n         BAL   R14,DSPLYHEX            CONVERT TO HEX\n         MVC   WTO1TEXT+81(6),SIXWORDS\n         ICM   R0,B'1111',CDXLMJP+1    CONVERT TO HEX\n         BAL   R14,DSPLYHEX            CONVERT TO HEX\n         MVC   WTO1TEXT+90(6),SIXWORDS\n         WTO   MF=(E,WTO1M)            DISPLAY MAJOR CDE\n*\nDSPLY40  ICM   R6,B'1111',LPAMINOR     DO WE HAVE A MINOR CDE?\n         BZ    DSPLY99                 NO MINOR CDE, EXIT\n         MVC   WTO1TEXT+3(L'CDNAME),CDNAME\n         ICM   R0,B'1111',CDENTPT      CONVERT TO HEX\n         BAL   R14,DSPLYHEX            CONVERT TO HEX\n         MVC   WTO1TEXT+12(8),SIXWORDS\n         ICM   R0,B'1111',CDATTRB      CONVERT TO HEX\n         BAL   R14,DSPLYHEX            CONVERT TO HEX\n         MVC   WTO1TEXT+23(2),SIXWORDS\n         ICM   R0,B'1111',CDATTR       CONVERT TO HEX\n         BAL   R14,DSPLYHEX            CONVERT TO HEX\n         MVC   WTO1TEXT+31(2),SIXWORDS\n         ICM   R0,B'1111',CDATTR2      CONVERT TO HEX\n         BAL   R14,DSPLYHEX            CONVERT TO HEX\n         MVC   WTO1TEXT+37(2),SIXWORDS\n         MVC   WTO1TEXT+49(8),MAJNAME\n         ICM   R0,B'1111',LPAMINOR+1   CONVERT TO HEX\n         BAL   R14,DSPLYHEX            CONVERT TO HEX\n         MVC   WTO1TEXT+81(6),SIXWORDS\n         MVC   WTO1TEXT+90(6),WTO1TEXT+89   ERASE XTLST\n         WTO   MF=(E,WTO1M)            DISPLAY MINOR CDE\n*\nDSPLY99  SLR   R15,R15                 RC=00\n         B     EXIT\n*\n&TEXT    SETC  '   NAME     ENTPT    ATTRB SP ATTR  ATTR2  USE'\n&TEXT    SETC  '&TEXT   MAJ-CDE    LENGTH   LOAD-PNT     CDE     XTLST'\n&TEXTL   SETA  K'&TEXT\nWTO1L    WTO   '&TEXT ',ROUTCDE=2,MF=L\nWTO1LL   EQU   *-WTO1L\n*\n*        CONVERT (R0) TO HEXADECIMAL FOR DISPLAY\n*\nDSPLYHEX ST    R0,SIXWORDS+20          HEX VALUE\n         UNPK  SIXWORDS(9),SIXWORDS+20(5)\n         TR    SIXWORDS(8),DSPLYTAB-C'0'\n         BR    R14\nDSPLYTAB DC    C'0123456789ABCDEF'\n*\n***********************************************************************\n*                                                                     *\n*        FUNCTION=DELETE                                              *\n*                                                                     *\n***********************************************************************\n*\nDEL00    MODESET KEY=ZERO,MODE=SUP\n         SETLOCK OBTAIN,                                               X\n               TYPE=LOCAL,             LOCAL LOCK                      X\n               MODE=UNCOND,                                            X\n               REGS=USE,               DO NOT CHANGE R11-R13           X\n               RELATED=DEL32\n         SETLOCK OBTAIN,                                               X\n               TYPE=CMS,               CROSS-MEMORY SERVICES           X\n               MODE=UNCOND,                                            X\n               REGS=USE,               DO NOT CHANGE R11-R13           X\n               RELATED=DEL32\n*\n         L     R3,CVTPTR\n         L     R6,CVTQLPAQ-CVT(,R3)    ACTIVE LPA QUEUE\n         USING CDENTRY,R6\n*LOOP\nDEL23    CLC   MODULE,CDNAME           IS THIS MY CDE?\n         BE    DEL31                   YES, EXIT LOOP\n         LR    R3,R6                   SAVE ADDR OF PREVIOUS CDE\n         ICM   R6,B'1111',CDCHAIN      END OF CHAIN?\n         BNZ   DEL23                   NO, LOOP\n*ENDLOOP\n         B     DEL32                   MODULE NOT FOUND\n*\n*        CDE FOUND ON QUEUE, REMOVE IT\n*\nDEL31    MVC   CDCHAIN-CDENTRY(,R3),CDCHAIN    REMOVE MY CDE FROM CHAIN\n*\nDEL32    SETLOCK RELEASE,                                              X\n               TYPE=ALL,               LOCAL AND CMS                   X\n               REGS=USE,               DO NOT CHANGE R11-R13           X\n               RELATED=DEL21\n         MODESET KEY=NZERO,MODE=PROB\n         LTR   R6,R6                   MODULE FOUND?\n         BZ    EXIT4                   NO, QUIT\n*\n*        FREE MODULE AND XTLST (MAJOR CDE ONLY)\n*\n         TM    CDATTR,CDMIN            IS THIS A MINOR CDE?\n         BO    DEL77                   YES, JUMP\n         L     R7,CDXLMJP              ADDR OF XTLST\n         USING XTLST,R7\n*\n*        FREE THE MODULE (CSA, SP=241)\n*\n         MODESET KEY=ZERO              SWITCH TO KEY=ZERO FOR FREEMAIN\n         SLR   R0,R0\n         ICM   R0,B'0111',XTLMSBLN     24-BIT LENGTH\n         L     R1,XTLMSBAD             31-BIT ADDRESS\n         FREEMAIN RU,                  FREE MODULE                     X\n               SP=241,                 SQA, FIXED                      X\n               A=(R1),                 A(MODULE)                       X\n               LV=(R0)                 LENGTH OF MODULE\n         MODESET KEY=NZERO             SWITCH TO KEY=TCB\n*\n*        FREE XTLST (SQA,SP=245)\n*\n         FREEMAIN R,                   FREE XTLST                      X\n               SP=245,                 SQA, FIXED                      X\n               A=(R7),                 A(XTLST)                        X\n               LV=XTL_LEN              LENGTH OF XTLST\n*\n*        FREE CDE (SQA,SP=245)\n*\nDEL77    FREEMAIN R,                   FREE CDE                        X\n               SP=245,                 SQA, FIXED                      X\n               A=(R6),                 A(CDENTRY)                      X\n               LV=CDE_LEN              LENGTH OF CDE\n*\nDEL99    SLR   R15,R15                 RC=00\n         B     EXIT\n*\n***********************************************************************\n*                                                                     *\n*        GOBACK TO CALLER                                             *\n*                                                                     *\n***********************************************************************\n*\nEXIT4    LA    R15,4                   MODULE NOT FOUND ON LPAQ\n         B     EXIT\n*\nEXIT8    LA    R15,8                   USER IS NOT AUTHORIZED\n         B     EXIT\n*\nEXIT12   LA    R15,12                  MODULE ALREADY IN LPA\n         B     EXIT\n*\nEXIT16   LA    R15,16                  PARM INVALID OR OMITTED\n         B     EXIT\n*\nEXIT20   LA    R15,20                  MODULE FOUND IN PLPA\n*\nEXIT     LR    R1,R13                  A(DYNAM)\n         LR    R2,R15                  RETURN_CODE\n         L     R13,4(,R13)\n         FREEMAIN R,LV=DYNAML,A=(1)    FREE DYNAMIC STORAGE\n         LR    R15,R2                  RETURN_CODE\n         RETURN (14,12),RC=(15)\n*\n***********************************************************************\n*                                                                     *\n*        INPUT PARM (FROM EXEC STATEMENT)                             *\n*                                                                     *\n***********************************************************************\nPARM     DSECT\nPARMLEN  DS    H                      LENGTH OF PARM\nPARMFUNC DS    C'LOAD,'               FUNCTION: LOAD/DELETE\nPARMNAME DS    CL8                    NAME OF LOAD MODULE\n***********************************************************************\n*                                                                     *\n*        DYNAMIC STORAGE                                              *\n*                                                                     *\n***********************************************************************\nDYNAM    DSECT\n         DS    18F                    SAVE AREA\nMODULE   DS    CL8                    ENTRY-POINT NAME\nMAJNAME  DS    CL8                    MAJOR NAME\nFUNCTION DS    C'L'                   L=LOAD  D=DELETE\nJPAMINOR DS    A(CDENTRY)             ADDR OF THE MINOR CDE (IN JPAQ)\nLPAMAJOR DS    A(CDENTRY)             ADDR OF MY MAJOR CDE (IN SQA)\nLPAMINOR DS    A(CDENTRY)             ADDR OF MY MINOR CDE (IN SQA)\nSTEPLIB  DS    A                      DCB ADDRESS\nSIXWORDS DS    6F                     WORK AREA\n*\nLOAD1L   LOAD  SF=L\nLOAD2L   LOAD  SF=L\n*\nRACF_DYN RACROUTE REQUEST=AUTH,MF=L\nRACF_LEN EQU   *-RACF_DYN\nRACFWORK DS    64D                    RACROUTE WORK AREA (512 BYTES)\nRACF_VOL DS    C'SYSRES'              VOLSER\n*\nWTO1M    WTO   '&TEXT',ROUTCDE=2,MF=L\nWTO1TEXT EQU   WTO1M+4,&TEXTL         TEXT\n*\nDYNAML   EQU   *-DYNAM\n***********************************************************************\n*                                                                     *\n*        MVS CONTROL BLOCKS USED IN LOADMLPA                          *\n*                                                                     *\n***********************************************************************\n         PRINT NOGEN\nPRINT    OPSYN ANOP\n         IHAPSA DSECT=YES\n         CVT   DSECT=YES,LIST=NO\n         IKJTCB DSECT=YES,LIST=NO\n         IHAASCB\n         IHAASXB\n         IHAACEE\n         IHACDE\n         DS    0F                      ALIGNMENT\nCDE_LEN  EQU   *-CDENTRY\n         IHAXTLST\n         DS    0F                      ALIGNMENT\nXTL_LEN  EQU   *-XTLST\n         YREGS\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,3)\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSPRINT DD SYSOUT=*\n//*\n//LKED    EXEC PGM=LINKLLA,PARM='MAP,RENT,AC=1'\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,DELETE)\n//SYSLMOD  DD DSN=SYS1.P390.LINKLIB(LOADMLPA),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//\n//*\n//INSTALL EXEC PGM=LOADMLPA,PARM=(LOAD,EXECPGM)\n//REMOVE  EXEC PGM=LOADMLPA,PARM=(DELETE,EXECPGM)\n//SYSUDUMP DD SYSOUT=*\n//ABNLTERM DD SYSOUT=*\n//\n//\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOCKTERM": {"ttr": 14084, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//SBGOLOBL JOB (ACCT#),LOCKTERM,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = LOCKTERM                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = Lock TSO terminal                                *\n*                                                                     *\n* STATUS = R202                                                       *\n*                                                                     *\n* FUNCTION = This TSO command locks the TSO terminal until            *\n*            the user's LOGON password is entered.                    *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*    DEPENDENCIES: MVS/ESA or OS/390                                  *\n*                  RACF or ACF2 6.x or TopSecret 5.x                  *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (CSECT TYPE)                               *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 4K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE ANY, AMODE 31,                   *\n*                 SUPERVISOR STATE, KEY 0                             *\n*                 APF AUTHORIZATION: YES                              *\n*                                                                     *\n* INSTALLATION: LOCKTERM must run authorized, which means it must     *\n*               be link-edited into an APF-authorized load library    *\n*               and be defined in the AUTHCMD section of IKJTSOnn.    *\n*                                                                     *\n* OPERATION = SEE BELOW                                               *\n*                                                                     *\n*   When invoked as a TSO command, LOCKTERM locks up the TSO terminal *\n*   until the LOGON password is entered to resume the TSO session.    *\n*   If the words CANCEL or LOGOFF are entered instead of the LOGON    *\n*   password, then the TSO session is abended with code S222.         *\n*                                                                     *\n*   During the time the TSO terminal is locked, messages are          *\n*   not accepted and time-out abends (S522) will not occur.           *\n*                                                                     *\n* PARAMETERS = None                                                   *\n*                                                                     *\n* HISTORY = This program is based on the LOCK command written         *\n*           by Leonard D. Woren in 1984 at Hughes Aircraft and        *\n*           found in file 179 of the CBT tape.  Among other           *\n*           things, I simplified the code by removing non-IBM         *\n*           macros and added the CANCEL and NOINTERCOM features.      *\n*                                                                     *\n* RETURN-CODES = Always Zero                                          *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n* 200 Initial release for the CBT tape                                *\n* 201 Make LOGOFF an alias of CANCEL                                  *\n*     STCOM NO only issued on OS390R4                                 *\n* 202 Adjust size of TSO userid for 8 characters                      *\n*                                                                     *\n&REL     SETC  'R202'                                                 *\n***********************************************************************\nLOCKTERM CSECT\nLOCKTERM RMODE ANY\n         B     BEGIN-*(,R15)           skip eye-catcher\n         DC    C'GSF Utilities - LOCKTERM &REL '\nBEGIN    BAKR  R14,0\n         LR    R12,R15                 BASE REGISTER\n         USING LOCKTERM,R12\n         LR    R11,R1                  POINT AT CPPL\n         USING CPPL,R11\n         MODESET MODE=SUP              GET S047 IF NOT AUTHORISED\n*--------------------------------------*\n*  INITIALISATION                      *\n*--------------------------------------*\n         STORAGE OBTAIN,ADDR=(R10),LENGTH=DYNAML,                      X\n               LOC=BELOW,BNDRY=PAGE\n         USING DYNAM,R10\n         L     R14,=A(SCREEN$)         MODEL ADDR\n         LA    R15,SCREENL             MODEL LENGTH\n         LA    R0,SCREEN               \"TO\" ADDR\n         LR    R1,R15                  \"TO\" LENGTH\n         MVCL  R0,R14                  MOVE MODEL TO DYNAMIC\n         LA    R9,SCREEN               screen image in dynamic storage\n         USING SCREEN$,R9\n         MVI   BLANKS,C' '\n         MVC   BLANKS+1(L'BLANKS-1),BLANKS\n         XC    RACINITL(RACINITLL),RACINITL\n         MVI   RACINITL,RACINITLL      INIT LENGTH\n*\n*        Retrieve SMF SID\n*\n         L     R8,CVTPTR               addr of the CVT\n         USING CVTMAP,R8\n         MVC   SYSNAME,CVTSNAME        SYSTEM NAME\n         L     R4,CVTSMCA              SMF\n         USING SMCABASE,R4\n         MVC   SMFSID,SMCASID          system ID\n*\n*        Retrieve ACEE addr and terminal name\n*\n         L     R4,PSAAOLD-PSA          MY ASCB\n         USING ASCB,R4\n         L     R5,ASCBASXB             MY ASXB\n         USING ASXB,R5\n         MVC   USERID,ASXBUSER         TSO USERID\n         L     R6,ASXBSENV             MY ACEE\n         USING ACEE,R6\n         MVC   TERMNAME,ACEETRID       terminal name\n*\n*        Initial time and date\n*\n         TIME  DEC                     GET CURRENT TIME (HHMMSSTH)\n         ST    R0,DWD                  STORE FOR EDIT\n         MVC   TIMELOCK,TIMEMASK       MOVE EDIT MASK TO SCREEN\n         ED    TIMELOCK,DWD            HH:MM:SS\n*\n*        PROFILE NOINTERCOM\n*\n*        This code prevents messages issued using the SEND command\n*        (which includes NOTIFY from JES) to the LOCKTERM'd session\n*        from being totally lost in OS/390 R4; as of 99/3/3, this\n*        mysterious bug is still being researched by TSO L2 support.\n*\n         TM    CVTOSLV2,CVTOS390_R4    OS390 R4?\n         BNO   NCOM5                   no, skip STCOM\n         L     R7,CPPLUPT              User Profile Table\n         USING UPT,R7\n         MVC   $UPTSWS,UPTSWS          save NOINTERCOM indicator\n         TM    $UPTSWS,UPTNCOM         NOINTERCOM\n         BO    NCOM5                   flag on, skip NCOM\n         STCOM NO                      NOINTERCOM\nNCOM5    EQU   *\n*\n*        Trap ATTN/PA1 keys\n*\n         STAX  DEFER=YES               IGNORE ATTENTIONS\n         STFSMODE ON,INITIAL=YES       Switch to full-screen mode\n         STTMPMD ON,KEYS=ALL           Trap ATTN/PA1\n*\n*        Prevent S522 abends\n*\n         MODESET EXTKEY=ZERO\n         OI    ASCBRCTF,ASCBTOFF       no S522\n         MODESET KEY=NZERO\n*--------------------------------------*\n*  MAIN LOOP                           *\n*--------------------------------------*\n         SR    R3,R3                   CLEAR LOOP COUNTER\n*loop\nLOOP     CVD   R3,DWD                  loop counter\n         MVC   NUM,=X'40202020'\n         ED    NUM,DWD+6\n         TIME  DEC                     GET CURRENT TIME (HHMMSSTH)\n         ST    R0,DWD                  STORE FOR EDIT\n         MVC   TIMETPUT,TIMEMASK       MOVE EDIT MASK TO SCREEN\n         ED    TIMETPUT,DWD            HH:MM:SS\n         TPUT  SCREEN,SCREENL,FULLSCR\n         CH    R15,=H'20'              RC TOO BIG?\n         BH    TPUT$ERR                YES - ABEND\n         B     *+4(R15)                DECODE RC\n         B     TPUT$OK                 00 - CONTINUE\n         B     TPUT$ERR                04 - NO BUFFERS FOR NOWAIT\n         B     ATTN$HIT                08 - ATTN HIT\n         B     TPUT$ERR                0C - INPUT BUFFER TOO SMALL\n         B     TPUT$ERR                10 - INVALID PARAMETERS\n         B     CLEANUP                 14 - TERMINAL IS DISCONNECTED\n         SPACE 1\nTPUT$ERR ABEND 93,,STEP                GET OUT FOR SURE\n         SPACE 3\nTPUT$OK  MVC   ATTNMSG,BLANKS          CLEAR MSG\n         OC    WAITTIME,WAITTIME       ANY WAITTIME?\n         BZ    NO$WAIT                 NO - GO DO TGET NOW\n         CLC   INBUF,BLANKS            WAS THERE ANY INPUT?\n         BE    NO$WAIT                 NO - DON'T DO THE WAIT\n         STIMER WAIT,BINTVL=WAITTIME   YES - MAKE HIM WAIT A WHILE\n         SPACE 1\nNO$WAIT  TGET  INBUF,80                READ SOMETHING\n         CH    R15,=H'20'              RC TOO BIG?\n         BH    TGET$ERR                YES - ABEND\n         B     *+4(R15)                DECODE RC\n         B     TGET$OK                 00 - CONTINUE\n         B     TGET$ERR                04 - NO BUFFERS FOR NOWAIT\n         B     ATTN$HIT                08 - ATTN HIT\n         B     TGET$OK                 0C - INPUT BUFFER TOO SMALL\n         B     TGET$ERR                10 - INVALID PARAMETERS\n         B     CLEANUP                 14 - TERMINAL IS DISCONNECTED\n         SPACE 1\nTGET$ERR ABEND 93,,STEP,REASON=(15)    GET OUT FOR SURE\n         SPACE 3\n*--------------------------------------*\n*  SEE IF CORRECT PASSWORD SUPPLIED    *\n*--------------------------------------*\nTGET$OK  TCLEARQ INPUT\n         OC    INBUF,BLANKS            UPPER CASE THE INPUT\n         CLC   INBUF,BLANKS            ANY INPUT?\n         BE    NO$INPUT                NO - CLEAR MSG & RESHOW SCREEN\n         CLI   INBUF,C'>'              RESHOW???\n         BNE   NOT$RS                  NO - CONTINUE\n         CLC   INBUF+1(L'INBUF-1),BLANKS  ANY MORE INPUT?\n         BE    LOOP                    NO - JUST RESHOW SCREEN\nNOT$RS   LA    R3,1(,R3)               INCR ATTEMPTS COUNTER\n         MVC   ATTEMPTS,=C'Attempts'   MOVE IN TEXT STRING 'ATTEMPTS'\n         CH    R3,=H'1'                IS THIS THE FIRST ATTEMPT?\n         BNE   *+8                     NO - SKIP\n         MVI   ATTEMPTS+L'ATTEMPTS-1,C' ' YES - MAKE IT SAY 'ATTEMPT '\n*\n         MVC   PASSWORD,INBUF          SET PASSWORD\n         CLC   =CL8'CANCEL',PASSWORD   CANCEL request?\n         BE    CANCEL                  yes, crash the TMP\n         CLC   =CL8'LOGOFF',PASSWORD   CANCEL request?\n         BE    CANCEL                  yes, crash the TMP\n         MVI   PSWDL,L'PASSWORD        PASSWORD LENGTH\n         RACINIT ENVIR=CREATE,                                         X\n               USERID=ACEEUSRL,        TSO user ID                     X\n               PASSWRD=PSWDL,          Password                        X\n               TERMID=ACEETRID,        Terminal name                   X\n               ACEE=$ACEE,             new ACEE                        X\n               MF=(E,RACINITL)\n         SPACE 1\n         CH    R15,=X'0034'            RC TOO BIG?\n         BH    RACF$BAD                YES - JUST LOOP\n         B     *+4(R15)                NO - DECODE IT\n         B     RACF$00                 00 - OK\n         B     RACF$04                 04 - USER NOT DEFINED TO RACF\n         B     RACF$08                 08 - PASSWORD NOT AUTHORIZED\n         B     RACF$0C                 0C - THE PASSWORD IS EXPIRED\n         B     RACF$10                 10 - THE NEW PSWD IS INVALID\n         B     RACF$14                 14 - USER NOT DEFINED TO GROUP\n         B     RACF$18                 18 - RACINIT FAILED BY INST EXT\n         B     RACF$1C                 1C - USER ACCESS REVOKED\n         B     RACFDOWN                20 - RACF IS NOT ACTIVE\n         B     RACF$24                 24 - USER ACC TO GROUP REVOKED\n         B     RACF$28                 28 - OID REQD NOT SUPPLIED\n         B     RACF$2C                 2C - OID CARD INVALID FOR USER\n         B     RACF$30                 30 - USER NOT AUTH TO TERMINAL\n         B     RACF$34                 34 - USER NOT AUTH TO APPL\n         SPACE 2\nRACF$00  XC    RACINITL+4(44),RACINITL+4\n         RACINIT ENVIR=DELETE,MF=(E,RACINITL)\n         SPACE 1\n         B     CLEANUP                 ALL DONE - LEAVE\n         SPACE 2\nRACF$BAD MVC   RACFMSG(27),=C'RACINIT return code > X''34'''\n         B     LOOP\n         SPACE 2\nRACF$04  MVC   RACFMSG(24),=C'User not defined to RACF'\n         B     LOOP\n         SPACE 2\nRACF$08  MVC   RACFMSG(18),=C'Incorrect password'\n*--------------------------------------*\n*  IF INCORRECT PASSWORD ENTERED,      *\n*  INCREASE DELAY TIME BEFORE USER IS  *\n*  GIVEN ANOTHER TRY.                  *\n*--------------------------------------*\n         L     R1,WAITTIME             GET CURRENT WAIT TIME\n         LA    R1,100(,R1)             ADD 1 SECOND\n         ST    R1,WAITTIME             SAVE NEW WAIT TIME\n         B     LOOP                    AND TRY AGAIN\n         SPACE 2\nRACF$0C  MVC   RACFMSG(19),=C'Password is expired'\n         B     LOOP\n         SPACE 2\nRACF$10  MVC   RACFMSG(23),=C'New password is invalid'\n         B     LOOP\n         SPACE 2\nRACF$14  MVC   RACFMSG(25),=C'User not defined to group'\n         B     LOOP\n         SPACE 2\nRACF$18  MVC   RACFMSG(27),=C'RACINIT failed by inst exit'\n         B     LOOP\n         SPACE 2\nRACF$1C  MVC   RACFMSG(19),=C'User access revoked'\n         B     LOOP\n         SPACE 2\nRACF$24  MVC   RACFMSG(28),=C'User access to group revoked'\n         B     LOOP\n         SPACE 2\nRACF$28  MVC   RACFMSG(26),=C'OID required, not supplied'\n         B     LOOP\n         SPACE 2\nRACF$2C  MVC   RACFMSG(20),=C'OID invalid for user'\n         B     LOOP\n         SPACE 2\nRACF$30  MVC   RACFMSG(31),=C'User not authorized to terminal'\n         B     LOOP\n         SPACE 2\nRACF$34  MVC   RACFMSG(34),=C'User not authorized to application'\n         B     LOOP\nNO$INPUT MVC   RACFMSG,BLANKS          CLEAR MSG AREA\n         B     LOOP\n*endloop\n         SPACE 3\n*--------------------------------------*\n*  RACF IS NOT UP.  ABEND              *\n*--------------------------------------*\nRACFDOWN EQU   CANCEL\n         SPACE 3\n*--------------------------------------*\n*  CORRECT PSWD ENTERED.  CLEAN UP.    *\n*--------------------------------------*\nCLEANUP  STFSMODE OFF                  TURN OFF FULLSCREEN MODE\n         STTMPMD OFF,KEYS=NO           TURN OFF TMP MODE\n         STAX  DEFER=NO                ALLOW ATTENTIONS\n*\n         MODESET EXTKEY=ZERO\n         NI    ASCBRCTF,X'FF'-ASCBTOFF S522 again\n         MODESET KEY=NZERO\n*\n         TM    CVTOSLV2,CVTOS390_R4    OS390 R4?\n         BNO   NCOM6                   no, skip STCOM\n         TM    $UPTSWS,UPTNCOM         Initial status was NOINTERCOM?\n         BO    NCOM6                   yes, leave it this way\n         STCOM YES                     INTERCOM\nNCOM6    EQU   *\n*\n         STORAGE RELEASE,ADDR=(R10),LENGTH=DYNAML\n         PR                            AND LEAVE\n         SPACE 3\n*--------------------------------------*\n*  ATTN PRESSED.  PRETEND LIKE WE      *\n*  IGNORED IT.                         *\n*--------------------------------------*\nATTN$HIT MVC   ATTNMSG,ATTNMSGC\n         MVI   ATTNHIT,C'*'            PERMANENT INDICATOR\n         LA    R3,1(,R3)               INCR ATTEMPTS COUNTER\n         MVC   ATTEMPTS,=C'Attempts'   MOVE IN TEXT STRING 'ATTEMPTS'\n         CH    R3,=H'1'                IS THIS THE FIRST ATTEMPT?\n         BNE   *+8                     NO - SKIP\n         MVI   ATTEMPTS+L'ATTEMPTS-1,C' ' YES - MAKE IT SAY 'ATTEMPT '\n         L     R1,WAITTIME             PICK UP WAITTIME\n         SRL   R1,2                    DIVIDE BY 4\n         ST    R1,WAITTIME             STORE REDUCED WAITTIME\n         STFSMODE ON                   ATTN TURNS OFF FULLSCR\n         B     LOOP\nSTAXEXIT BR    R14                     JUST RETURN, TGET RC=8\n         SPACE 3\n*--------------------------------------*\n*  CANCEL Processing                   *\n*--------------------------------------*\n         DROP\nCANCEL   MODESET EXTKEY=ZERO           KEY=ZERO,MODE=SUP\n         LR    R3,R13                  save R13\n         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND\n         SETLOCK OBTAIN,TYPE=CMS,MODE=UNCOND\n         LR    R13,R3                  restore R13 corrupted by SETLOCK\n         LA    R0,X'222'               abend code\n         L     R1,PSAAOLD-PSA          own ASCB\n         L     R15,CVTPTR              get CVT address\n         L     R15,CVTSIC-CVTMAP(,R15) system-initiated CANCEL\n         BALR  R14,R15              <- commit suicide !!!\n         SETLOCK RELEASE,TYPE=ALL\n         PR\n*--------------------------------------*\n*  MISCELLANEOUS CONSTANTS             *\n*--------------------------------------*\nATTNMSGC DC    C'Nice try, but that would be too easy.'\nTIMEMASK DC    C' ',X'2120',C':',X'2020',C':',X'2020'\n         SPACE 3\n*--------------------------------------*\n*  3270 SCREEN BUFFER                  *\n*--------------------------------------*\nSCREEN$  CSECT\nSCREEN$  RMODE ANY\n         DC    X'27F5'                 ESC, ERASE WRITE STD\n         DC    X'C1'                   WCC:\n*        F3270 ROW=24,COL=80,MODEL=2   SPF START\n         DC    X'115D7F'               SBA\n*        F3270 ROW=1,COL=1             ...\n         DC    X'114040'               SBA\n*        F3270 ROW=1,COL=1,RA=00       CLEAR WHOLE SCREEN\n         DC    X'3C4040',X'00'         RA\n*        F3270 ROW=1,COL=1,ATTR=(SF,PROT,BRIGHT)\n         DC    X'114040'               SBA\n         DC    X'1DE8'                 SF\n         DC    C'UserID='\nUSERID   DC    CL8' '                  TSO User ID - 8 characters\n         DC    C' SMFSID='\nSMFSID   DC    CL4' '                  SMF System ID from SMCA\n         DC    C'  SYSNAME='\nSYSNAME  DC    CL8' '                  GRS name from CVTSNAME\n         DC    C'  Terminal='\nTERMNAME DC    CL8' '                  Terminal name from ACEE\n*        F3270 ROW=1,COL=70\n         DC    X'11C1C5'               SBA\nTIMETPUT DC    C' HH:MM:SS'\n*        F3270 ROW=5,COL=1,ATTR=(SF,PROT,NORM)\n         DC    X'11C540'               SBA\n         DC    X'1D60'                 SF\n         DC    C'This terminal locked at'\nTIMELOCK DC    C' HH:MM:SS',C'.'\n*        F3270 ROW=7,COL=2\n         DC    X'11C761'               SBA\n         DC    C'To unlock, enter logon password.'\n*        F3270 ATTR=(SF,PROT,BRIGHT),INITIAL='===>'\n         DC    X'1DE8'                 SF\n         DC    C'===>'                 DATA\n*        F3270 ATTR=(SF,NDISP,UNPROT),LENGTH=8\n         DC    X'1D4C'                 SF\n         DC    CL8' '                  DATA AREA\n*        F3270 ATTR=(SF,PROT,BRIGHT)\n         DC    X'1DE8'                 SF\n*        F3270 ROW=9,COL=2\n         DC    X'114AC1'               SBA\nRACFMSG  DC    CL79' '\n*        F3270 ROW=22,COL=1,ATTR=(SF,PROT,BRIGHT)\n         DC    X'115A50'               SBA\n         DC    X'1DE8'                 SF\nNUM      DC    CL4' '\n*        F3270 ATTR=(SF,PROT,NORM)\n         DC    X'1D60'                 SF\nATTEMPTS DC    CL8' '                  'ATTEMPTS'\n*        F3270 ROW=22,COL=80\n         DC    X'115B5F'               SBA\nATTNHIT  DC    C' '                    ATTN HIT INDICATOR\n*        F3270 ROW=24,COL=5\n         DC    X'115CF4'               SBA\nATTNMSG  DC    CL(L'ATTNMSGC)' '\n*        F3270 ROW=7,COL=40\n         DC    X'11C8C7'               SBA\n         DC    X'13'                   IC\nSCREENL  EQU   *-SCREEN$\n         SPACE 2\n*--------------------------------------*\n*  WORK AREA                           *\n*--------------------------------------*\nDYNAM    DSECT\nDWD      DS    D                       CVD WORK AREA\nWAITTIME DS    F'0'                    WAITTIME BEFORE TGET, IN .01SEC\nRACINITL RACINIT MF=L\nRACINITLL EQU *-RACINITL\n$ACEE    DS    A(ACEE)                 ACEE addr returned by RACINIT\n$UPTSWS  DS    AL1(UPTNCOM)            NOINTERCOM indicator\nPSWDL    DS    AL1(8)                  LENGTH OF PASSWORD\nPASSWORD DS    CL8' '                  PASSWORD\nBLANKS   DS    CL80' '                 a bunch of blanks\n         DS    0D                      *** double-word alignment ***\nINBUF    DS    CL80                    TGET INPUT BUFFER\nSCREEN   DS    XL(SCREENL)             UNPROTECTED STORAGE\nDYNAML   EQU   *-DYNAM                 LENGTH TO GETMAIN\n         SPACE 2\n*--------------------------------------*\n*  CONTROL BLOCK DSECTS                *\n*--------------------------------------*\n         PRINT NOGEN\n         CVT   DSECT=YES\n         AIF   (D'CVTOS390_R4).CVT99\nCVTOS390_R4 EQU X'80'                  OS/390 R4\n.CVT99   ANOP\n         IHAPSA\n         IEESMCA\n         IHAASCB\n         IHAASXB\n         IHAACEE\n         IKJCPPL\n         IKJUPT\n         YREGS\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,5)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//LKED    EXEC PGM=HEWL,PARM='MAP,RENT,AC=1'\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,DELETE)\n//SYSLMOD  DD DSN=SYS1.W$$.LINKLIB(LOCKTERM),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LPA24": {"ttr": 14337, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x13\\x00\\x97\\t?\\x00\\x98)\\x7f\\x11\"\\x00\\x99\\x00\\x1f\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf1\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-04-03T00:00:00", "modifydate": "1998-10-24T11:22:13", "lines": 153, "newlines": 31, "modlines": 0, "user": "CBT419"}, "text": "/*---------------------------------------------------------------REXX-*\\\n|*                                                                    *|\n|* MODULE NAME = LPA24                                                *|\n|*                                                                    *|\n|* DESCRIPTIVE NAME = Display PLPA usage below the 16MB line.         *|\n|*                                                                    *|\n|* STATUS = R100                                                      *|\n|*                                                                    *|\n|* FUNCTION = Scan the PLPA directory and display the size of         *|\n|*            the RMODE=24 modules, along with the size used by       *|\n|*            each system component, based on the first three         *|\n|*            characters of module names.  This command can help      *|\n|*            system administrators in their efforts to reduce        *|\n|*            the size of the PLPA below the 16MB line.               *|\n|*                                                                    *|\n|* AUTHOR   =  Gilbert Saint-Flour <carlos@gsf-soft.com>              *|\n|*                                                                    *|\n|* DEPENDENCIES = TSO/E V2                                            *|\n|*                STEMVIEW routine R105 (optional)                    *|\n|*                                                                    *|\n|* SYNTAX   =  LPA24                                                  *|\n|*               ALL   When the ALL option is specified, each         *|\n|*                     module is displayed.  When ALL is not          *|\n|*                     specified, only totals are displayed.          *|\n|*                                                                    *|\n|* Sample Output with ALL option:                                     *|\n|*                                                                    *|\n|*      Module   EntPt    Flags   Size LoadPt                         *|\n|*      AMDUSRFE 00E3E040 B1 22   1808                                *|\n|*      AMDUSRFF 00EBA000 B1 22  12720                                *|\n|*          2 AMD modules:       14528                                *|\n|*      ARCATTNW 00E0CBC0 B1 22   1320 E0CAD8                         *|\n|*          1 ARC modules:        1320                                *|\n|*       .  .  .  .  .  .  .  .  .  .  .  .  .                        *|\n|*      SECLOADA 00CECDE8 B1 22    536                                *|\n|*          1 SEC modules:         536                                *|\n|*        All 307 modules:     1920272                                *|\n|*                                                                    *|\n\\*--------------------------------------------------------------------*/\nARG parm\nispf=SYSVAR(SYSISPF)='ACTIVE'\nIF ispf THEN\n  'ISREDIT MACRO (parm)'\nUPPER parm\nIF parm\\='' & parm\\='ALL' THEN DO\n  SAY 'Invalid parameter, must be ALL or blank'\n  EXIT 20\n  END\n  /*----------------------------------------------------------------*\\\n  |*          Retrieve RMODE=24 modules from PLPA directory         *|\n  \\*----------------------------------------------------------------*/\nSAY 'LPA24 1.00 - Scanning the PLPA directory.'\nx=TIME('R')                            /* reset timer                 */\ncvt = C2D(STORAGE(10,4))               /* CVT                 CVTPTR  */\nlpde = C2D(STORAGE(D2X(cvt+361),3))    /* PLPA Directory      CVTLPDIR*/\nn=0\nDO FOREVER\n  temp=STORAGE(D2X(lpde),40)\n  PARSE VAR temp WITH 1 . 9 modnm 17 ep 21 maj 25 flgs 33 len 37 ldpt\n  IF LEFT(modnm,1)='FF'X THEN LEAVE\n  IF LEFT(ldpt,1)='00'X & LEFT(len,1)='00'X THEN DO\n    PARSE VAR flgs WITH 1 . 5 attr 6 attr2 7 .\n    n=n+1\n    line.n = modnm C2X(ep) C2X(attr) C2X(attr2) RIGHT(c2d(len),6)\n    IF RIGHT(ep,3)\\=RIGHT(ldpt,3) THEN\n      line.n = line.n C2X(RIGHT(ldpt,3)) /* entry-point \\= load-point */\n    END\n  lpde=lpde+40\nEND\nSAY 'End of PLPD scan; elapsed time:' TIME('R') 'seconds.'\nSAY 'Number of RMODE=24 modules found:' n\nCALL QSORT 1,n                         /* Sort the data lines         */\nSAY 'End of SORT phase; elapsed time:' TIME('R') 'seconds.'\n  /*----------------------------------------------------------------*\\\n  |*            Add up module sizes by 3-char prefix                *|\n  \\*----------------------------------------------------------------*/\n\"MAKEBUF\"\nIF parm='ALL' THEN\n  QUEUE 'Module   EntPt    Flags   Size LoadPt'\nprefix=''\ntotal=0\n  DO i=1 TO n\n    IF LEFT(line.i,3)\\=prefix THEN DO\n      IF prefix\\='' THEN DO\n        QUEUE RIGHT(i-j,5) prefix 'modules:' RIGHT(sum,11)\n        total=total+sum                /* grand total                 */\n        END\n      prefix=LEFT(line.i,3)            /* 3-char module prefix        */\n      j=i\n      sum=0\n      END\n      sum=sum+WORD(line.i,5)\n    IF parm='ALL' THEN\n      QUEUE line.i\n  END\nQUEUE RIGHT(i-j,5) prefix 'modules:' RIGHT(sum,11)\nQUEUE '  All' n      'modules:' RIGHT(total,11)\n  /*----------------------------------------------------------------*\\\n  |*                  Display the output                            *|\n  \\*----------------------------------------------------------------*/\nIF ispf THEN DO\n  SIGNAL ON SYNTAX                  /* in case STEMVIEW not available */\n  CALL STEMVIEW 'VIEW',,,,'RMODE=24 Modules in PLPA'\n  END\nELSE\n  CALL DISPLAY                      /*    not running in ISPF         */\n\n\"DROPBUF\"\nEXIT\n\nSYNTAX:                            /* STEMVIEW function not available */\n  error=rc\n  'ISPEXEC CONTROL DISPLAY LINE START(1)'\n  SAY 'REXX error' error 'in line' sigl':' errortext(error)\n  SAY sourceline(sigl)\n  SAY ''\n\nDISPLAY:  DO WHILE QUEUED()>0; PULL line; SAY line; END\n  \"DROPBUF\"\n  EXIT\n  /*----------------------------------------------------------------*\\\n  |*                      QuickSort Routine                         *|\n  \\*----------------------------------------------------------------*/\nQSORT: PROCEDURE EXPOSE line.\n  ARG l,r\n  i = TRUNC((l + r) / 2)\n  keep = line.i\n  i = l\n  j = r\n  DO until i > j\n    DO i = i WHILE line.i < keep; END\n    DO j = j BY -1 WHILE keep < line.j; END\n    IF i <= j THEN DO\n      save = line.i\n      line.i = line.j\n      line.j = save\n      i = i + 1\n      j = j - 1\n      END\n  END\n  IF j - l > r - i THEN DO\n    IF i < r THEN\n      CALL QSORT i,r\n    IF l < j THEN\n      CALL QSORT l,j\n    END\n  ELSE DO\n    IF l < j THEN\n      CALL QSORT l,j\n    IF i < r THEN\n      CALL QSORT i,r\n    END\n  RETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LPR": {"ttr": 14341, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*****************************************************************REXX*/\n/*                                                                    */\n/* MODULE NAME = LPR                                                  */\n/*                                                                    */\n/* DESCRIPTIVE NAME = LPR EDIT Macro for ISPF/PDF                     */\n/*                                                                    */\n/* STATUS = R100                                                      */\n/*                                                                    */\n/* FUNCTION = The LPR EDIT macro is used to transmit a copy of        */\n/*            the data currently being edited via LPR to a            */\n/*            remote host.  The data are converted to ASCII           */\n/*            during the transmission.  This EDIT macro is useful     */\n/*            to transmit data that does not exist on disk in a       */\n/*            transmittable form, such as packed data, data           */\n/*            modified during the current EDIT session, or data       */\n/*            only accessible via the EDIT Interface (EDIF).          */\n/*                                                                    */\n/* AUTHOR   =  Gilbert Saint-Flour <carlos@gsf-soft.com>              */\n/*                                                                    */\n/* Dependencies = TSO/E V2                                            */\n/*                ISPF/PDF V3 or ISPF V4                              */\n/*                TCP/IP V3.2                                         */\n/*                ROUTEPGM utility R605 (optional)                    */\n/*                FASTPATH utility R128 (optional)                    */\n/*                                                                    */\n/* SYNTAX   =  LPR                                                    */\n/*                 host                  remote host or IP address    */\n/*                 printer               printer name                 */\n/*                                       (default: LPT1)              */\n/*                                                                    */\n/* OPERATION = see below                                              */\n/*                                                                    */\n/*        LPR creates a temporary data set, copies the data into      */\n/*        into it, then invokes the TCP/IP LPR command.               */\n/*                                                                    */\n/* CHANGES = see below                                                */\n/*                                                                    */\n/* 100 New packaging for the CBT tape                                 */\n/*                                                                    */\n/**********************************************************************/\nRoutepgm='NO'                  /* Use the REXX stack and EXECIO       */\nRoutepgm='YES'                 /* Use the ROUTEPGM program            */\nFastPath='NO'                  /* Invoke the FTP command directly     */\nFastPath='YES'                 /* Invoke FTP via the FASTPATH utility */\n              /* -------------------------- */\n              /* Allocate Tempftp file      */\n              /* -------------------------- */\nftpdsn='tempftp.text'\nRC=LISTDSI(ftpdsn 'NORECALL')\nIF RC>0 THEN DO\n  IF RC=16 & SYSREASON=9 THEN               /* Migrated data set */\n    \"HDELETE\" ftpdsn \"WAIT\"\n  \"ALLOC DS(\"ftpdsn\") NEW CATALOG\",\n       \"TRACKS SPACE(10 10) UNIT(SYSALLDA)\",\n       \"DSORG(PS) RECFM(V B) LRECL(255)\"\n  \"FREE DS(\"ftpdsn\")\"\n  END\nRC=LISTDSI('TEMPFTP' 'FILE')\nIF RC>0 THEN\n  \"ALLOC DD(TEMPFTP) DS(\"ftpdsn\") OLD DELETE\"\n            /* -------------------------------- */\n            /*     Retrieve ISPF variables      */\n            /* -------------------------------- */\nADDRESS 'ISPEXEC'\n\"CONTROL ERRORS RETURN\"\n\"ISREDIT MACRO (HOST)\";  IF rc>0 THEN EXIT rc\nIF host='' THEN EXIT 12\n\"VGET (ZTEMPF ZTEMPN)\"\n            /* -------------------------------- */\n            /* Write the text to tempftp.userid */\n            /* -------------------------------- */\nIF Routepgm='YES' THEN\n  \"SELECT PGM(ROUTEPGM) PARM(TEMPFTP)\"\nELSE DO\n    DO I=1 BY 1\n      \"ISREDIT (LINE) = LINE\" I             /* GET CURRENT LINE */\n      IF RC>0 THEN LEAVE\n      IF line='' THEN\n        QUEUE ' '                           /* blank line */\n      ELSE\n        QUEUE STRIP(line,'T')\n    END\n  QUEUE ''\n  ADDRESS 'TSO' \"EXECIO * DISKW TEMPFTP (FINIS\"\n  END\n/**********************************************************************/\n/*                                                                    */\n/*             Build the LPR control statements                       */\n/*                                                                    */\n/**********************************************************************/\nADDRESS 'TSO'\n/* -------------------------- */\n/* Clear out variables        */\n/* -------------------------- */\nparse value \"\" with printer\n\n/* -------------------------- */\n/* test for printer           */\n/* -------------------------- */\nif words(host) > 1 then\n   parse value host with host printer .\n\n/* -------------------------- */\n/* if printer then use it     */\n/* -------------------------- */\nif length(printer) = 0 then\n   printer='LPT1'\n\n/**********************************************************************/\n/*                                                                    */\n/*             Invoke the LPR client program                          */\n/*                                                                    */\n/**********************************************************************/\nparm=ftpdsn \"HOST\" host \"PRINTER\" printer\nIF FastPath='YES' THEN\n  cmd=\"ISPEXEC SELECT PGM(FASTPATH) PARM(EXECPGM,LPR,\"parm\nELSE\n  cmd=\"LPR\" parm\nSAY cmd\ncmd\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LVL": {"ttr": 14344, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x00\\x88%\\x9f\\x00\\x99\\x01\\x9f\\x15\\x18\\x00X\\x00\"\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1988-09-15T00:00:00", "modifydate": "1999-01-19T15:18:00", "lines": 88, "newlines": 34, "modlines": 0, "user": "CBT472"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* MODULE NAME = LVL                                                  */\n/*                                                                    */\n/* DESCRIPTIVE NAME = Compress level numbers and adjust pos 79-80     */\n/*                                                                    */\n/* STATUS = R200                                                      */\n/*                                                                    */\n/* FUNCTION = This ISPF EDIT Macro compresses level numbers for       */\n/*     FB-80 PDS members with STATS ON and NUMBER STD.                */\n/*                                                                    */\n/*     LVL reuses \"gas levels\", i.e. levels which are not used        */\n/*     in any record in the member and adjusts pos 79-80 of the       */\n/*     records accordingly.                                           */\n/*                                                                    */\n/*     If the macro invocation includes a number, then levels         */\n/*     up to the specified number are reset to zero.                  */\n/*                                                                    */\n/* Author: Gilbert Saint-Flour <carlos@gsf-soft.com>                  */\n/*                                                                    */\n/**********************************************************************/\nADDRESS \"ISPEXEC\"\n\"ISREDIT MACRO (MIN)\"\nIF MIN='' THEN\n  MIN=0\nELSE\n  MIN=MIN+0\n\"ISREDIT (NUMMODE,NUMTYPE) = NUMBER\"   /* QUERY NUMBER MODE INFO    */\nIF NUMMODE='ON' THEN\n  \"ISREDIT NUMBER = OFF\"               /* TURN OFF NUMBER MODE      */\n\nDO LEV=0 TO 99; N.LEV=0 ; END          /* INIT ARRAY          */\nHWM=0\n\n'ISREDIT (ZLAST) = LINENUM .ZLAST'     /* LAST LINE           */\n    /*--------------------------------------------------*\\\n    |*     DETERMINE WHICH LEVEL NUMBERS ARE USED       *|\n    \\*--------------------------------------------------*/\nDO L=1 TO ZLAST\n  \"ISREDIT (LINE) = LINE\" L                /* GET CURRENT LINE */\n  IF RC>0 THEN EXIT RC\n  LEV=RIGHT(LINE,2) + 0                /* EXTRACT LEVEL             */\n  IF HWM<LEV THEN HWM=LEV              /* GET HIGHEST LEV           */\n  N.LEV=N.LEV+1                        /* EXTRACT LEVEL             */\n /*  SAY LEV LINE N.LEV */\nEND\n    /*---------------------------------------------*\\\n    |*          COMPRESS LEVEL NUMBERS             *|\n    \\*---------------------------------------------*/\nRELEVEL=0\nIF N.0 = 0 THEN\n  N=-1\nELSE\n  N=0\nDO LEV=0 TO HWM\n  IF N.LEV > 0 THEN DO\n    IF LEV>0 THEN DO\n      IF LEV > MIN THEN\n        N=N+1\n      ELSE DO\n        N=0\n        RELEVEL=1\n        END\n      END\n    SAY RIGHT(LEV,3) RIGHT(N.LEV,5) 'N='N RELEVEL\n    N.LEV=N                            /* NEW LEVEL NUMBER          */\n    END\n  ELSE DO                              /* THIS LVL IS NOT USED      */\n    SAY RIGHT(LEV,3)\n    RELEVEL=1\n    END\nEND\n    /*--------------------------------------------------*\\\n    |*              UPDATE LEVEL NUMBERS                *|\n    \\*--------------------------------------------------*/\nIF RELEVEL THEN DO L=1 TO ZLAST\n  \"ISREDIT (LINE) = LINE\" L                /* GET CURRENT LINE */\n  IF RC>0 THEN EXIT RC\n  LEV=RIGHT(LINE,2) + 0                /* EXTRACT LEVEL             */\n  IF LEV\\=N.LEV THEN DO                /* LEVEL NEEDS BE CHANGED    */\n    LINE2 = LEFT(LINE,LENGTH(LINE)-2) || RIGHT(N.LEV,2,'0')\n    \"ISREDIT LINE\" L \"= (LINE2)\"       /* UPDATE CURRENT LINE */\n    END\nEND\n\n\"ISREDIT (L) = LEVEL\"                    /* CURRENT LEVEL NUMBER */\nIF L \\= N THEN\n  \"ISREDIT LEVEL =\" N                    /* NEW LEVEL NUMBER    */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NEWAPPL": {"ttr": 14347, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x17\\x002\\x00\\x89\\x05\\x9f\\x01\\x05\\x17?\\x12\\x16\\x02Z\\x00\\x03\\x00\\xf2\\xc3\\xc2\\xe3\\xf4\\xf6\\xf9@@@@'", "ispf": {"version": "01.23", "flags": 0, "createdate": "1989-02-28T00:00:00", "modifydate": "2005-06-22T12:16:32", "lines": 602, "newlines": 3, "modlines": 242, "user": "CBT469"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* MODULE NAME = NEWAPPL                                              */\n/*                                                                    */\n/* DESCRIPTIVE NAME = Start a new ISPF application                    */\n/*                                                                    */\n/* STATUS = R123                                                      */\n/*                                                                    */\n/* FUNCTION = NEWAPPL uses LIBDEF and ALTLIB to define application    */\n/*            libraries and issues the SELECT service.                */\n/*                                                                    */\n/* AUTHOR   =  Gilbert Saint-Flour <carlos@gsf-soft.com>              */\n/*                                                                    */\n/* Dependencies = TSO/E V2                                            */\n/*                ISPF/PDF V3, V4 or V5                               */\n/*                LLIBDEF R300 (optional)                             */\n/*                                                                    */\n/* SYNTAX   =  NEWAPPL                                                */\n/*                 application                                        */\n/*                 parameters                                         */\n/*                                                                    */\n/**********************************************************************/\nARG Product Parm\nADDRESS 'ISPEXEC'; \"CONTROL ERRORS RETURN\"\n/**********************************************************************/\n/***                        IBM Products                            ***/\n/**********************************************************************/\nSELECT\n  WHEN Product='BOOK' THEN DO                           /*BOOK Manager*/\n    CALL Switch_Applid 'EOXR'\n    CALL LIBDEF 'ISPMLIB' 'EOY.SEOYMENU'\n    CALL LIBDEF 'ISPPLIB' 'EOY.SEOYPENU'\n    CALL LIBDEF 'ISPTLIB' 'EOY.SEOYTENU'\n    CALL LIBDEF 'ISPLLIB' 'EOY.SEOYLOAD' 'EOY.SEOYLPA'\n    CALL ALTLIB 'CLIST'   'EOY.SEOYCLIB'\n    ADDRESS TSO \"CALL 'GSFSOFT.LOAD(LLIBDEF3)'\"\n    \"SELECT CMD(%EOXVSTRT\" Parm\") MODE(FSCR)\"\n    END\n  WHEN Product='CCCA' THEN DO                           /*   CCCA    */\n    CALL Switch_Applid 'ABJ'\n    CALL LIBDEF 'ISPMLIB' 'ABJ.H09F210.SABJMLIB'\n    CALL LIBDEF 'ISPPLIB' 'ABJ.H09F210.SABJPLIB'\n    CALL LIBDEF 'ISPSLIB' 'ABJ.H09F210.SABJSLIB'\n    CALL LIBDEF 'ISPTLIB' 'ABJ.H09F210.SABJTLIB'\n    CALL LIBDEF 'ISPLLIB' 'ABJ.H09F210.SABJMOD1'\n    CALL ALTLIB 'CLIST'   'ABJ.H09F210.SABJCLST'\n  /*\n    ABJNVSH = 'SYS1.COBCONV.V1R6M0' /* NON-VSAM SHARED    */\n    ABJNVPR = 'MVS0016'             /* NON-VSAM PRIVATE   */\n    ABJVSSH = 'MVS0016'             /*     VSAM SHARED    */\n    ABJVSPR = 'MVS0016'             /*     VSAM PRIVATE   */\n    ABJUNIT = 'SYSALLDA'            /* work data sets     */\n    \"VPUT (ABJNVSH ABJNVPR ABJVSSH ABJVSPR ABJUNIT) PROFILE\"\n   */\n    \"SELECT PANEL(ABJ@M2)\"\n    END\n  WHEN Product='DB2I' THEN DO                           /*  DB2I     */\n    CALL Switch_Applid 'DSNE'\n    CALL LIBDEF 'ISPPLIB' 'DB2.V3R1M0.SDSNSPFP',\n                          'DB2.V3R1M0.SDSNPFPE'\n    CALL LIBDEF 'ISPMLIB' 'DB2.V3R1M0.SDSNSPFM'\n    CALL LIBDEF 'ISPLLIB' 'DB2.V3R1M0.SDSNLOAD'\n    CALL ALTLIB 'CLIST'   'DB2.V3R1M0.SDSNCLST'\n    \"SELECT PANEL(DSNEPRI)\"\n    END\n  WHEN Product='DFSORT' THEN DO                         /*  DF/SORT  */\n    CALL Switch_Applid 'ICE'\n    CALL LIBDEF 'ISPMLIB' 'SYS1.DFSORT.V1R12M0.ICEISPM',\n                          'SYS1.DFSORT.V1R12M0.ICEDGTM'\n    CALL LIBDEF 'ISPPLIB' 'SYS1.DFSORT.V1R12M0.ICEISPP',\n                          'SYS1.DFSORT.V1R12M0.ICEDGTP'\n    CALL LIBDEF 'ISPSLIB' 'SYS1.DFSORT.V1R12M0.ICEISPS',\n                          'SYS1.DFSORT.V1R12M0.ICEDGTS'\n    CALL LIBDEF 'ISPTLIB' 'SYS1.DFSORT.V1R12M0.ICEISPT',\n                          'SYS1.DFSORT.V1R12M0.ICEDGTT'\n    CALL LIBDEF 'ISPLLIB' 'SYS1.DFSORT.V1R12M0.ICEISPL',\n                          'SYS1.DFSORT.V1R12M0.ICEDGTL'\n    CALL ALTLIB 'CLIST'   'SYS1.DFSORT.V1R12M0.ICEISPC'\n    \"SELECT PANEL(ICESPRIM) NEWAPPL(ICE) PASSLIB\"\n    END\n  WHEN Product='DITTO' THEN DO                          /*   DITTO   */\n    CALL Allocate 'DUTPLIB' 'SYS1.SDITPLIB'\n    CALL Allocate 'DUTPROF' USERID()'.DUTPROF'\n    \"SELECT CMD(DITTO) MODE(FSCR)\"\n    END\n  WHEN Product='FAULT' THEN DO                     /* Fault Analyzer */\n    CALL Switch_Applid 'IDI'\n    CALL LIBDEF 'ISPPLIB' 'IDI.SIDIPLIB'\n    CALL LIBDEF 'ISPMLIB' 'IDI.SIDIMLIB'\n    CALL LIBDEF 'ISPSLIB' 'IDI.SIDISLIB'\n    CALL LIBDEF 'ISPTLIB' 'IDI.SIDITLIB'\n    CALL ALTLIB 'EXEC'    'IDI.SIDIEXEC'\n    \"SELECT PGM(IDIPDDIR) SCRNAME(FAULTA)\"\n    END\n  WHEN Product='FM' THEN DO                         /* File Manager */\n    CALL Switch_Applid 'FMN'\n    CALL LIBDEF 'ISPPLIB' 'SYS1.IFM.SFMNPENU'\n    CALL LIBDEF 'ISPMLIB' 'SYS1.IFM.SFMNMENU'\n    CALL LIBDEF 'ISPSLIB' 'SYS1.IFM.SFMNSLIB'\n    CALL LIBDEF 'ISPTLIB' 'SYS1.IFM.SFMNTENU'\n  /*CALL LIBDEF 'ISPLLIB' 'SYS1.IFM.LINKLIB' */\n    CALL ALTLIB 'EXEC'    'SYS1.IFM.SFMNEXEC'\n    \"SELECT PANEL(FMNSTASK) SCRNAME(FILEMGR)\"\n    END\n  WHEN Product='HCD' THEN DO                            /*   HCD     */\n    CALL Switch_Applid 'HCD'\n    CALL LIBDEF 'ISPLLIB' 'SYS1.SCBDHENU' 'SYS1.NUCLEUS'\n  /*CALL LIBDEF 'ISPMLIB' 'SYS1.SCBDMENU'   */\n  /*CALL LIBDEF 'ISPPLIB' 'SYS1.SCBDPENU'   */\n  /*CALL LIBDEF 'ISPTLIB' 'SYS1.SCBDTENU'   */\n    CALL ALTLIB 'CLIST'   'SYS1.SCBDCLST'\n    ADDRESS TSO \"ALLOC DD(LIBTRACE) SYSOUT REUSE\"\n    ADDRESS TSO \"CALL 'GSFSOFT.LOAD(LLIBDEF3)'\"\n    \"SELECT CMD(%CBDCHCD) MODE(FSCR)\"\n    END\n  WHEN Product='ICQ' THEN DO                            /*   TSO/E   */\n    CALL Switch_Applid 'ICQ'\n    CALL LIBDEF 'ISPPLIB' 'ICQ.ICQPLIB'\n    CALL LIBDEF 'ISPMLIB' 'ICQ.ICQMLIB'\n    CALL LIBDEF 'ISPSLIB' 'ICQ.ICQSLIB'\n    CALL LIBDEF 'ISPTLIB' 'ICQ.ICQTLIB'\n    CALL ALTLIB 'CLIST'   'ICQ.ICQCCLIB'\n    CALL ALLOCATE 'ICQAATAB' 'ICQ.ICQAATAB'\n    CALL ALLOCATE 'ICQAMTAB' 'ICQ.ICQAMTAB'\n    CALL ALLOCATE 'ICQANTAB' 'ICQ.ICQANTAB'\n    CALL ALLOCATE 'ICQAPTAB' 'ICQ.ICQAPTAB'\n    CALL ALLOCATE 'ICQCMTAB' 'ICQ.ICQCMTAB'\n    \"SELECT CMD(ICQAMLI0 APPLNAME(ICQADMIN)) NEWAPPL(ICQ) PASSLIB\"\n    END\n  WHEN Product='IPCS' THEN DO                           /*   IPCS    */\n    ADDRESS TSO \"EXEC 'SYS1.SBLSCLI0(BLSCLIBD)'\"\n    END\n  WHEN Product='IPCS$' THEN DO                          /*   IPCS    */\n    CALL Switch_Applid 'BLSG'\n    CALL LIBDEF 'ISPPLIB' 'SYS1.SBLSPNL0'\n    CALL LIBDEF 'ISPMLIB' 'SYS1.SBLSMSG0'\n    CALL LIBDEF 'ISPSLIB' 'SYS1.SBLSKEL0'\n    CALL LIBDEF 'ISPTLIB' 'SYS1.SBLSTBL0'\n    CALL ALTLIB 'CLIST'   'SYS1.SBLSCLI0'\n    \"SELECT PGM(BLSG) PARM(PANEL(BLSPPRIM))\",\n                  \" NEWAPPL(BLSG) PASSLIB\"\n    END\n  WHEN Product='ISMF' THEN DO                           /*   ISMF    */\n    CALL Switch_Applid 'DGT'\n    CALL LIBDEF 'ISPPLIB' 'SYS1.DGTPLIB'\n    CALL LIBDEF 'ISPMLIB' 'SYS1.DGTMLIB'\n    CALL LIBDEF 'ISPSLIB' 'SYS1.DGTSLIB'\n    CALL LIBDEF 'ISPTLIB' 'SYS1.DGTTLIB'\n    CALL ALTLIB 'CLIST'   'SYS1.DGTCLIB'\n    \"SELECT PGM(DGTFMD01)\"\n    END\n  WHEN Product='OMVS' THEN DO                           /*   OMVS    */\n    CALL Switch_Applid 'BPXW'\n    CALL LIBDEF 'ISPPLIB' 'SYS1.SBPXPENU'\n    CALL LIBDEF 'ISPMLIB' 'SYS1.SBPXMENU'\n    CALL LIBDEF 'ISPTLIB' 'SYS1.SBPXTENU'\n    CALL ALTLIB 'EXEC'    'SYS1.SBPXEXEC'\n    \"SELECT CMD(OMVS) MODE(FSCR)\"\n    END\n  WHEN Product='ISHELL' THEN DO                         /*   ISHELL  */\n    CALL Switch_Applid 'BPXW'\n    CALL LIBDEF 'ISPPLIB' 'SYS1.SBPXPENU'\n    CALL LIBDEF 'ISPMLIB' 'SYS1.SBPXMENU'\n    CALL LIBDEF 'ISPTLIB' 'SYS1.SBPXTENU'\n    CALL ALTLIB 'EXEC'    'SYS1.SBPXEXEC'\n    \"SELECT CMD(%ISHELL) MODE(FSCR)\"\n    END\n  WHEN Product='OEDIT' THEN DO                          /* OMVS EDIT */\n    CALL Switch_Applid 'BPXW'\n    CALL LIBDEF 'ISPPLIB' 'SYS1.SBPXPENU'\n    CALL LIBDEF 'ISPMLIB' 'SYS1.SBPXMENU'\n    CALL LIBDEF 'ISPTLIB' 'SYS1.SBPXTENU'\n    CALL ALTLIB 'EXEC'    'SYS1.SBPXEXEC'\n    \"SELECT CMD(%OEDIT) MODE(FSCR)\"\n    END\n  WHEN Product='OBROWSE' THEN DO                      /* OMVS BROWSE */\n    CALL Switch_Applid 'BPXW'\n    CALL LIBDEF 'ISPPLIB' 'SYS1.SBPXPENU'\n    CALL LIBDEF 'ISPMLIB' 'SYS1.SBPXMENU'\n    CALL LIBDEF 'ISPTLIB' 'SYS1.SBPXTENU'\n    CALL ALTLIB 'EXEC'    'SYS1.SBPXEXEC'\n    \"SELECT CMD(%OBROWSE) MODE(FSCR)\"\n    END\n  WHEN Product='PRINTWAY' THEN DO                     /* IP PRINTWAY */\n    CALL Switch_Applid 'ANF'\n    CALL LIBDEF 'ISPPLIB' 'ANF.SANFPLIB'\n    CALL LIBDEF 'ISPMLIB' 'ANF.SANFMLIB'\n    CALL ALTLIB 'EXEC'    'ANF.SANFEXEC'\n    \"SELECT PANEL(ANFIPM)\"\n    END\n  WHEN Product='RMM' THEN DO                            /*   RMM     */\n    CALL Switch_Applid 'EDG'\n    CALL LIBDEF 'ISPMLIB' 'SYS1.SEDGMENU'\n    CALL LIBDEF 'ISPPLIB' 'SYS1.SEDGPENU'\n    CALL LIBDEF 'ISPSLIB' 'SYS1.SEDGSKL1'\n    CALL LIBDEF 'ISPTLIB' 'SYS1.SEDGTBL1'\n    CALL ALTLIB 'EXEC'    'SYS1.SEDGEXE1'\n    \"SELECT CMD(%EDGRMAIN)\"\n    END\n  WHEN Product='RACF' THEN DO                           /*   RACF    */\n    CALL Switch_Applid 'RACF'\n    CALL LIBDEF 'ISPPLIB' 'SYS1.HRFPANL'\n    CALL LIBDEF 'ISPMLIB' 'SYS1.HRFMSG'\n    CALL LIBDEF 'ISPSLIB' 'SYS1.HRFSKEL'\n    CALL ALTLIB 'CLIST'   'SYS1.HRFCLST'\n    \"SELECT PANEL(ICHP00)\"\n    END\n  WHEN Product='QMF' THEN DO                            /*   QMF     */\n    CALL Switch_Applid 'DSQE'\n    CALL LIBDEF 'ISPPLIB' 'QMF.V3R1M1.DSQPLIBE'\n    CALL LIBDEF 'ISPMLIB' 'QMF.V3R1M1.DSQMLIBE'\n    CALL LIBDEF 'ISPSLIB' 'QMF.V3R1M1.DSQSLIBE'\n    CALL LIBDEF 'ISPTLIB' 'QMF.V3R1M1.DSQTLIBE'\n    CALL LIBDEF 'ISPLLIB' 'QMF.V3R1M1.DSQLOAD' ,\n                          'DB2.V3R1M0.SDSNLOAD'\n    CALL ALTLIB 'EXEC'    'QMF.V3R1M1.DSQEXECE'\n    CALL ALLOCATE 'ADMGGMAP' 'QMF.V3R1M1.DSQMAPE'\n    CALL ALLOCATE 'ADMCFORM' 'QMF.V3R1M1.DSQCHART'\n    CALL ALLOCATE 'DSQPNLE'  'QMF.V3R1M1.DSQPNLE'\n    ADDRESS TSO \"ALLOC DD(DSQDEBUG) SYSOUT(Z)\"\n    ADDRESS TSO \"ALLOC DD(LIBTRACE) SYSOUT(Z)\"\n    ADDRESS TSO \"CALL 'GSFSOFT.LOAD(LLIBDEF3)'\"\n    \"SELECT PGM(DSQQMFE)\"\n    END\n  WHEN Product='RMF' THEN DO                            /*  RMF III  */\n    CALL Switch_Applid 'ERB'\n    CALL ALTLIB 'CLIST'   'SYS1.SERBCLS'\n    \"SELECT CMD(%ERBRMF3X)\"\n    \"SELECT CMD(%ERBRMF)\"\n    END\n  WHEN Product='SDF' THEN DO                            /*  SDF II   */\n    CALL Switch_Applid 'DGI'\n    CALL ALTLIB 'EXEC'    'SDF2.V1R4M0.SDGICMD'\n    \"SELECT CMD(%DGIIXINV)\"\n    END\n  WHEN Product='SDSF' THEN DO                           /*   SDSF    */\n    CALL Switch_Applid 'ISF'\n    CALL LIBDEF 'ISPPLIB' 'SYS1.SISFPLIB'\n    CALL LIBDEF 'ISPMLIB' 'SYS1.SISFMLIB'\n    CALL LIBDEF 'ISPTLIB' 'SYS1.SISFTLIB'\n /* CALL LIBDEF 'ISPLLIB' 'SYS1.ISFLOAD' 'SYS1.ISFLPA'        */\n    \"SELECT PGM(ISFISP)\"\n    END\n  WHEN Product='SMPE' THEN DO                           /*  SMP/E    */\n    CALL Switch_Applid 'SMPE'\n    CALL LIBDEF 'ISPPLIB' 'GIM.SGIMPENU'\n    CALL LIBDEF 'ISPMLIB' 'GIM.SGIMMENU'\n    CALL LIBDEF 'ISPSLIB' 'GIM.SGIMSENU'\n    X=LISTDSI('ISPPROF' 'FILE')              /* get dsn of ISPPROF */\n    CALL LIBDEF 'ISPTLIB' 'GIM.SGIMTENU' sysdsname\n    CALL Allocate 'SMPTABL' sysdsname\n    \"SELECT PGM(GIMISCV)\"\n    END\n  WHEN Product='TOPS' THEN DO                           /*  TOPS     */\n    CALL Switch_Applid 'TOPS'\n    CALL LIBDEF 'ISPPLIB' 'SYS1.SAMPLIB'\n    CALL ALTLIB 'CLIST'   'SYS1.SAMPLIB'\n    \"SELECT CMD(%IEATOPS)\"\n    END\n/**********************************************************************/\n/***                      Non-IBM Products                          ***/\n/**********************************************************************/\n  WHEN Product='PDS' THEN DO                            /*  CBT tape */\n    CALL Switch_Applid 'PDS'\n    CALL LIBDEF 'ISPPLIB' 'GSFSOFT.GSF-ENV.PDS86'\n    CALL LIBDEF 'ISPMLIB' 'GSFSOFT.GSF-ENV.PDS86'\n    IF parm\\='' THEN DO; Pdspdsn=parm; \"VPUT Pdspdsn\"; END\n    \"SELECT PANEL(PDS@PRIM)\"\n    END\n  WHEN Product='MAIL' THEN DO                           /*  CBT tape */\n    CALL Switch_Applid 'MAIL'\n    CALL LIBDEF 'ISPPLIB' 'IBMUSER.TSOMAIL.PANELS'\n    CALL LIBDEF 'ISPMLIB' 'IBMUSER.TSOMAIL.PANELS'\n    CALL ALTLIB 'EXEC'    'IBMUSER.TSOMAIL.EXEC'\n    \"SELECT CMD(%TSOMAIL)\"\n    END\n  WHEN Product='ABENDAID' THEN DO                       /* Compuware */\n    CALL Switch_Applid 'AAUT'\n    CALL LIBDEF 'ISPMLIB' 'STC.CWARE.ISPMLIB'\n    CALL LIBDEF 'ISPPLIB' 'STC.CWARE.ISPPLIB'\n    CALL LIBDEF 'ISPLLIB' 'SYS1.CWARE.ABAID.LOAD.LIB',\n                          'SYS1.CWARE.SHRSERV.LOAD.LIB'\n    \"SELECT CMD(EXECPGM CWDDSUTL PARM(SPF)) MODE(FSCR)\"\n    END\n  WHEN Product='FILEAID' THEN DO                        /* Compuware */\n    CALL Switch_Applid 'FAXE'\n    CALL LIBDEF 'ISPMLIB' 'TPPX.FILEAID.V8R0M0.ISPMLIB'\n    CALL LIBDEF 'ISPPLIB' 'TPPX.FILEAID.V8R0M0.ISPPLIB'\n    CALL LIBDEF 'ISPSLIB' 'TPPX.FILEAID.V8R0M0.ISPSLIB'\n    CALL LIBDEF 'ISPTLIB' 'TPPX.FILEAID.V8R0M0.ISPTLIB'\n    CALL LIBDEF 'ISPLLIB' 'TPPX.FILEAID.V8R0M0.LOAD'\n    \"SELECT PANEL(IFAMU01) OPT(\"parm\")\"\n    END\n  WHEN Product='M4DM' THEN DO                           /*  MACRO 4  */\n    CALL Switch_Applid 'M4DM'\n    CALL LIBDEF 'ISPMLIB' 'TPPX.DUMPMSTR.V4R105.MSGS'\n    CALL LIBDEF 'ISPPLIB' 'TPPX.DUMPMSTR.V4R105.PANELS'\n    CALL LIBDEF 'ISPTLIB' 'TPPX.DUMPMSTR.V4R105.TABLES'\n    CALL LIBDEF 'ISPTABL' 'TPPX.DUMPMSTR.V4R105.TABLES'\n    CALL LIBDEF 'ISPLLIB' 'TPPX.DUMPMSTR.V4R105.LOADLIB'\n    CALL ALTLIB 'CLIST'   'TPPX.DUMPMSTR.V4R105.CLIST'\n    CALL ALTLIB 'EXEC'    'TPPX.DUMPMSTR.V4R105.EXEC'\n    \"SELECT PANEL(DMOMENU)\"\n    END\n  WHEN Product='INSYNC' THEN DO                         /*  MACRO 4  */\n    CALL Switch_Applid '#IS1'\n    CALL LIBDEF 'ISPMLIB' 'IBMUSER.INSYNC.V311.MLIB'\n    CALL LIBDEF 'ISPPLIB' 'IBMUSER.INSYNC.V311.PLIB'\n    CALL LIBDEF 'ISPSLIB' 'IBMUSER.INSYNC.V311.SLIB'\n    CALL LIBDEF 'ISPTLIB' 'IBMUSER.INSYNC.V311.TLIB'\n  /*CALL ALTLIB 'EXEC'    'IBMUSER.INSYNC.V311.ELIB' */\n    'VGET zscreen'\n    CALL ALLOCATE '#ELIBDD' || zscreen 'IBMUSER.INSYNC.V311.ELIB'\n    CALL LIBDEF 'ISPLLIB' 'IBMUSER.INSYNC.V311.LOADLIB'\n    \"SELECT CMD(INS10\" Parm \")\"\n    END\n  WHEN Product='CHANGEMAN' THEN DO                      /*   Serena  */\n    CALL Switch_Applid 'CMN'\n    CALL LIBDEF 'ISPPLIB' 'TPPX.CHGMAN.V4R1M0.FMAINPAN',\n                          'TPPX.CHGMAN.V4R1M0.FHELPPAN',\n                          'PROD.CHGMAN.V4R1M0.FCUSTPAN'\n    CALL LIBDEF 'ISPSLIB' 'PROD.CHGMAN.V4R1M0.CMNSKELS',\n                          'TPPX.CHGMAN.V4R1M0.SKELS'\n    CALL LIBDEF 'ISPMLIB' 'TPPX.CHGMAN.V4R1M0.MSGS'\n  /*CALL LIBDEF 'ISPLLIB' 'TPPX.CHGMAN.V4R1M0.LINKLIB' */\n    CALL ALTLIB 'CLIST'   'TPPX.CHGMAN.V4R1M0.CLIST'\n    \"SELECT CMD(CMNINIT) MODE(FSCR)\"\n    END\n  WHEN Product='STARTOOL' THEN DO                       /*   Serena  */\n    CALL Switch_Applid 'ISR'\n    CALL LIBDEF 'ISPPLIB' 'IBMUSER.PDSE610.PANELS'\n    CALL LIBDEF 'ISPMLIB' 'IBMUSER.PDSE610.MSGS'\n    CALL LIBDEF 'ISPSLIB' 'IBMUSER.PDSE610.SKELS'\n    CALL LIBDEF 'ISPLLIB' 'IBMUSER.PDSE610.LOAD',\n                          'IBMUSER.PDSE610.TLOD'\n    CALL ALTLIB 'CLIST'   'IBMUSER.PDSE610.CLIST'\n    \"SELECT CMD(STARTOOL) MODE(FSCR)\"\n    END\n  WHEN Product='COMPAREX' THEN DO                       /*   Serena  */\n    CALL Switch_Applid 'CPX'\n    CALL LIBDEF 'ISPMLIB' 'TPPX.COMPAREX.V7R2M0.MSGS'\n    CALL LIBDEF 'ISPPLIB' 'TPPX.COMPAREX.V7R2M0.PANELS'\n    CALL LIBDEF 'ISPTLIB' 'TPPX.COMPAREX.V7R2M0.TABLES'\n    \"SELECT PANEL(CPX@PRIM) NEWAPPL(CPX) PASSLIB\"\n    END\n  WHEN Product='CATSCAN' THEN DO                        /* SOFTWORKS */\n    CALL Switch_Applid 'CATS'\n    CALL LIBDEF 'ISPMLIB' 'TPPX.CATSCAN.V2R1M1.ISPMLIB'\n    CALL LIBDEF 'ISPPLIB' 'TPPX.CATSCAN.V2R1M1.ISPPLIB'\n    CALL LIBDEF 'ISPSLIB' 'TPPX.CATSCAN.V2R1M1.ISPSLIB'\n /* CALL LIBDEF 'ISPLLIB' 'SYS2.TPPX.CATSCAN.V2R4M0.LOADLIB' */\n    CALL ALTLIB 'EXEC'    'TPPX.CATSCAN.V2R1M1.ISPCLIB'\n    \"SELECT CMD(CSLMAN) MODE(FSCR)\"\n    END\n  WHEN Product='JCLPREP' THEN DO                        /*   Altare  */\n    CALL Switch_Applid 'JPRP'\n    CALL ALTLIB 'CLIST'   'TPPX.JCLPREP.V3R6M0.CLIST'\n    \"SELECT CMD(%JPRCDLA)\"\n    END\n  WHEN Product='LEGACY' THEN DO                     /* Knowledgeware */\n    CALL Switch_Applid 'LGCY'\n    CALL LIBDEF 'ISPMLIB' 'IBMUSER.LEGACY.R46AA.ISPMLIB',\n                          'IBMUSER.LEGACY.R46PD.ISPMLIB',\n                          'IBMUSER.LEGACY.R46PR.ISPMLIB'\n    CALL LIBDEF 'ISPPLIB' 'IBMUSER.LEGACY.R46AA.ISPPLIB',\n                          'IBMUSER.LEGACY.R46PD.ISPPLIB',\n                          'IBMUSER.LEGACY.R46PR.ISPPLIB'\n    CALL LIBDEF 'ISPSLIB' 'IBMUSER.LEGACY.R46AA.ISPSLIB',\n                          'IBMUSER.LEGACY.R46PD.ISPSLIB',\n                          'IBMUSER.LEGACY.R46PR.ISPSLIB'\n    CALL ALTLIB 'CLIST'   'IBMUSER.LEGACY.R46AA.CLIST',\n                          'IBMUSER.LEGACY.R46PD.CLIST',\n                          'IBMUSER.LEGACY.R46PR.CLIST'\n    \"SELECT PANEL(LEGACY)\"\n    END\n  WHEN Product='SFINDER' THEN DO                        /*  Trilogy  */\n    CALL LIBDEF 'ISPMLIB' 'TPPX.SFW.V1R1M0.MESSAGE'\n    CALL LIBDEF 'ISPPLIB' 'TPPX.SFW.V1R1M0.PANEL'\n    CALL LIBDEF 'ISPSLIB' 'TPPX.SFW.V1R1M0.SKELETON'\n    CALL ALTLIB 'CLIST'   'SYS2.ADP.CLISTS'\n    \"SELECT PANEL(SF@MSTR)\"\n    END\n  WHEN Product='STROBE' THEN DO                         /*Programmart*/\n    CALL Switch_Applid 'STR'\n    CALL LIBDEF 'ISPMLIB' 'TPPX.STROBE.R930.ISPMLIB'\n    CALL LIBDEF 'ISPPLIB' 'TPPX.STROBE.R930.ISPPLIB'\n    CALL LIBDEF 'ISPSLIB' 'TPPX.STROBE.R930.ISPSLIB'\n    \"SELECT PGM(STRBISPF)\"\n    END\n  WHEN Product='TDS'    THEN DO                         /*Apogee Soft*/\n    CALL Switch_Applid 'TDS'\n    CALL LIBDEF 'ISPMLIB' 'TPPX.TDM.V1R0M3.ISPMLIB'\n    CALL LIBDEF 'ISPPLIB' 'TPPX.TDM.V1R0M3.ISPPLIB'\n    \"SELECT CMD(CALL 'TPPX.TDM.V1R0M3.LOAD(TDSMAIN)')\"\n    END\n  WHEN Product='TRE'    THEN DO                         /*Apogee Soft*/\n    CALL Switch_Applid 'TRE'\n    CALL LIBDEF 'ISPMLIB' 'TPPX.TDM.V1R0M3.ISPMLIB'\n    CALL LIBDEF 'ISPPLIB' 'TPPX.TDM.V1R0M3.ISPPLIB'\n    \"SELECT CMD(CALL 'TPPX.TDM.V1R0M3.LOAD(TREMAIN)')\"\n    END\n  WHEN Product='CORTEX' THEN DO                         /*   SISRO   */\n    CALL Switch_Applid 'CZX'\n    CALL LIBDEF 'ISPMLIB' 'CORTEX5.V5R2M1.MESSLIB'\n    CALL LIBDEF 'ISPPLIB' 'CORTEX.ADP4.USERLIB' ,\n                          'CORTEX.ADP0.USERLIB' ,\n                          'CORTEX5.V5R2M1.ISPPLIB'\n    CALL LIBDEF 'ISPSLIB' 'CORTEX.ADP4.USERLIB' ,\n                          'CORTEX.ADP0.USERLIB' ,\n                          'CORTEX5.V5R2M1.ISPSLIB'\n    CALL LIBDEF 'ISPLLIB' 'CORTEX.ADP4.EXITLIB' ,\n                          'CORTEX.ADP0.EXITLIB' ,\n                          'CORTEX5.V5R2M1.LINKLIB'\n    ADDRESS TSO \"ALLOC DD(SYSTERM) SYSOUT REUSE\"\n    ADDRESS TSO \"ALLOC DD(LIBTRACE) SYSOUT REUSE\"\n    CALL ALTLIB 'CLIST'   'CORTEX5.V5R2M1.CMDLIB'\n    ADDRESS TSO \"CALL 'GSFSOFT.LOAD(LLIBDEF3)'\"\n    \"SELECT PGM(CZX2POCV) PARM(AN-,PANEL(CZX2ECTX))\"\n    END\n  WHEN Product='EPIC' THEN DO                           /*  Legent   */\n    CALL Switch_Applid 'PXPM'\n    CALL LIBDEF 'ISPPLIB' 'TPPX.PXPM.V3R3M0.EPMPLIB'\n    CALL LIBDEF 'ISPTLIB' 'TPPX.PXPM.V3R3M0.EPMTLIB'\n    CALL LIBDEF 'ISPMLIB' 'TPPX.PXPM.V3R3M0.EPMMLIB'\n    \"SELECT PGM(TSIOMS00)\"\n    END\n  WHEN Product='EPIC32' THEN DO                         /*  Legent   */\n    CALL Switch_Applid 'EPIC'\n    CALL LIBDEF 'ISPPLIB' 'TPPX.EPIC.V3R2M0.PLIB'\n    CALL LIBDEF 'ISPMLIB' 'TPPX.EPIC.V3R2M0.MLIB'\n    CALL LIBDEF 'ISPTLIB' 'TPPX.EPIC.V3R2M0.TLIB'\n    \"SELECT CMD(TSIOISPF EPIC) MODE(FSCR)\"\n    END\n  WHEN Product='EXPRESS' THEN DO                        /*  Legent   */\n    CALL Switch_Applid 'RMO'\n    IF parm='' THEN parm='PROD.RMO'\n    CALL LIBDEF 'ISPPLIB' 'TPPX.RMO.V5R1M3.ISPPLIB'\n    CALL LIBDEF 'ISPTLIB' 'TPPX.RMO.V5R1M3.ISPTLIB'\n    \"SELECT PGM(RMOSPF) PARM(\"parm\") NEWAPPL(RMO) PASSLIB\"\n    END\n  WHEN Product='ISM' THEN DO                            /*  Legent   */\n    CALL Switch_Applid 'ISM'\n    CALL LIBDEF 'ISPMLIB' 'TPPX.ISM.R381.ISPMLIB'\n    CALL LIBDEF 'ISPPLIB' 'TPPX.ISM.R381.ISPPLIB'\n    CALL LIBDEF 'ISPSLIB' 'TPPX.ISM.R381.ISPSLIB'\n    CALL LIBDEF 'ISPTLIB' 'TPPX.ISM.R381.ISPTLIB'\n    CALL ALTLIB 'CLIST'   'TPPX.ISM.R381.CMDPROCF'\n    \"SELECT PANEL(MI@PRIM)\"\n    END\n  WHEN Product='JOBTRAC' THEN DO                        /*  Legent   */\n    CALL Switch_Applid 'LJT'\n    CALL ALLOCATE 'JOBTRACY' 'PROD.JOBTRAC.CKPT'\n    CALL ALLOCATE 'JOBHISTY' 'PROD.JOBTRAC.JOBHIST'\n    CALL ALLOCATE 'SEQHISTY' 'PROD.JOBTRAC.JOBHIST.DATA'\n    CALL ALLOCATE 'CAPTURE' 'PROD.JOBTRAC.CAPTURE'\n    CALL ALLOCATE 'TRACPARM' 'PROD.JOBTRAC.PARMLIB'\n    CALL ALLOCATE 'TRACS000' 'PROD.JOBTRAC.SCL000'\n   CALL ALLOCATE 'TRACJ000' 'PROD.JOBTRAC.JCLLIB' 'PROQ.ADP.APL2.JCLLIB'\n    CALL ALLOCATE 'TRACT000' 'PROD.JOBTRAC.TEMPJCL'\n    CALL ALLOCATE 'TRACD000' 'PROD.JOBTRAC.DOCLIB'\n    CALL ALLOCATE 'DATEFILE' 'PROD.JOBTRAC.DATELIB'\n    CALL LIBDEF 'ISPMLIB' 'TPPX.JOBTRAC.V3R2M0.TRACMLIB'\n    CALL LIBDEF 'ISPPLIB' 'TPPX.JOBTRAC.V3R2M0.TRACPLIB'\n    \"SELECT PGM(GJTRVSPF)\"\n    END\n  WHEN Product='QW'   THEN DO                        /* Chicago-Soft */\n    CALL Switch_Applid 'QWRF'\n    CALL LIBDEF 'ISPMLIB'   'IBMUSER.QUICKREF.MESSAGES'\n    CALL LIBDEF 'ISPPLIB'   'IBMUSER.QUICKREF.PANELS'\n    CALL LIBDEF 'ISPLLIB'   'IBMUSER.QUICKREF.LINKLIB'\n    CALL ALLOCATE 'QWREFDD' 'IBMUSER.QUICKREF.DATABASE'\n    \"SELECT PGM(QWIKREF1) PARM(\"parm\")\"\n    END\n  WHEN Product='SYSVIEW' THEN DO                        /*  Legent   */\n    CALL Switch_Applid 'GSVX'\n    CALL LIBDEF 'ISPPLIB' 'TPPX.PCOMMAND.V61.ISPPLIB'\n    CALL LIBDEF 'ISPTLIB' 'TPPX.PCOMMAND.V61.ISPTLIB'\n    \"SELECT CMD(GSVXSPF) MODE(FSCR) NEWAPPL(GSVX) PASSLIB\"\n    END\n  WHEN Product='SAR' THEN DO                            /*  Legent   */\n    CALL Switch_Applid 'SAR'\n    IF parm='' THEN parm='PROD.SAR'\n    CALL LIBDEF 'ISPTLIB' 'TPPX.SAR.V6R5M3.ISPTLIB'\n    CALL LIBDEF 'ISPPLIB' 'TPPX.SAR.V6R5M3.ISPPLIB'\n    \"SELECT PGM(SARSPF) PARM(\"parm\") NEWAPPL(SAR) PASSLIB\"\n    END\n  WHEN Product='TMS' THEN DO                            /*  CA1/TMS  */\n    CALL Switch_Applid 'TMS'\n    CALL LIBDEF 'ISPMLIB' 'SYSV.CAI.CAIISPM'\n    CALL LIBDEF 'ISPPLIB' 'SYSV.CAI.CAIISPP'\n    CALL LIBDEF 'ISPTLIB' 'SYSV.CAI.CAIISPT'\n    \"SELECT PGM(TMSIOPRI)\"\n    END\n  WHEN Product='IOA' THEN DO                            /* 4th dim   */\n    CALL Switch_Applid 'CTM'\n    CALL LIBDEF 'ISPMLIB' 'SYSP.IOA.ISMSG'\n    CALL LIBDEF 'ISPPLIB' 'SYSP.IOA.PANEL'\n    CALL LIBDEF 'ISPSLIB' 'SYSP.IOA.SKEL'\n    CALL LIBDEF 'ISPTLIB' 'SYSP.IOA.TABLE'\n    CALL LIBDEF 'ISPLLIB' 'SYSP.IOA.LOAD'\n    CALL ALTLIB 'CLIST'   'SYSP.IOA.CLIST'\n    ADDRESS TSO \"CALL 'GSFSOFT.LOAD(LLIBDEF3)'\"\n    \"SELECT CMD(%CTOISPF) MODE(FSCR)\"\n    END\n  WHEN Product='TCPIPM' THEN DO                    /* David Alcock   */\n    CALL Switch_Applid 'TCPM'\n    CALL LIBDEF 'ISPPLIB' 'IBMUSER.PACKAGE.TCPIPM.V17'\n    CALL ALTLIB 'EXEC'    'IBMUSER.PACKAGE.TCPIPM.V17'\n    \"SELECT CMD(%TCPIPM)\"\n    END\n  WHEN Product='FTPB'   THEN DO                    /* Lionel Dyck    */\n    CALL Switch_Applid 'FTP'\n    CALL LIBDEF 'ISPPLIB' 'IBMUSER.FTPB.PANELS'\n    CALL ALTLIB 'EXEC'    'IBMUSER.FTPB.EXEC'\n    \"SELECT CMD(%FTPB)\"\n    END\n  WHEN Product='MXI'   THEN DO                     /* Rob Scott   */\n    CALL Switch_Applid 'MXI'\n    CALL LIBDEF 'ISPLLIB' 'IBMUSER.MXI21.LOAD'\n    CALL LIBDEF 'ISPPLIB' 'IBMUSER.MXI21.PANELS'\n    CALL LIBDEF 'ISPTLIB' 'IBMUSER.MXI21.TABLES'\n    \"SELECT CMD(MXI) MODE(FSCR)\"\n    END\n  WHEN Product='IOF'   THEN DO                /* Triangle Systems */\n    CAlL Switch_Applid 'IOF'\n    CALL LIBDEF 'ISPPLIB' 'ISR.OEM.ISRPLIB'\n    CALL LIBDEF 'ISPTLIB' 'ISR.OEM.ISRTLIB'\n    CALL LIBDEF 'ISPMLIB' 'ISR.OEM.ISRMLIB'\n    CALL LIBDEF 'ISPSLIB' 'ISR.OEM.ISRSLIB'\n    CALL ALTLIB 'CLIST'   'ISR.OEM.CLIST'\n    \"SELECT PGM(IOFSPF) PARM(\" parm \")\"\n    END\n  OTHERWISE SAY 'Product' Product \"is not supported\"\n  END\n\nIF RC>8 THEN DO\n  \"VGET ZERRMSG\"\n  IF Zerrmsg\\='' THEN\n    \"SETMSG MSG(\"Zerrmsg\") COND\"\n  END\n\nIF RC.ISPLLIB=0 THEN \"LIBDEF ISPLLIB\"\nIF RC.ISPMLIB=0 THEN \"LIBDEF ISPMLIB\"\nIF RC.ISPPLIB=0 THEN \"LIBDEF ISPPLIB\"\nIF RC.ISPSLIB=0 THEN \"LIBDEF ISPSLIB\"\nIF RC.ISPTLIB=0 THEN \"LIBDEF ISPTLIB\"\nIF RC.CLIST=0   THEN ADDRESS TSO \"ALTLIB DEACT APPL(CLIST)\"\nIF RC.EXEC=0    THEN ADDRESS TSO \"ALTLIB DEACT APPL(EXEC)\"\n/* IF Ddn_string \\= '' THEN ADDRESS TSO \"FREE DD(\" Ddn_string \")\"  */\nEXIT\n/**********************************************************************/\n/***                        Sub-Routines                            ***/\n/**********************************************************************/\nSwitch_applid:\n  ARG Appl\n  'VGET (ZAPPLID)'\n  IF Appl\\=ZAPPLID THEN DO\n    \"SELECT CMD(%\"SYSVAR(SYSICMD) Product Parm \") NEWAPPL(\" Appl \")\"\n    EXIT RC\n    END\n  Ddn_string=''\n  RETURN\n\nLIBDEF:\n  ARG ddn dsn\n  ddn2=LEFT(Product,4,'$')||RIGHT(ddn,4)\n  CALL Allocate ddn2 dsn\n  \"LIBDEF\" ddn \"LIBRARY ID(\"ddn2\") COND\"\n  IF RC>8 THEN SIGNAL ERRMSG\n  INTERPRET 'RC.'ddn '=' rc\n  RETURN\n\nALTLIB:\n  ARG ddn dsn\n  ddn2=LEFT(Product,4,'$')||LEFT(ddn,4)\n  CALL Allocate ddn2 dsn\n  ADDRESS TSO \"ALTLIB ACT APPL(\"ddn\") DDNAME(\"ddn2\")\"\n  INTERPRET 'RC.'ddn '=' rc\n  RETURN\n\nALLOCATE:\n  ARG Ddn2 Dsn.1 dsn.2 dsn.3 dsn.4\n  IF LISTDSI(ddn2 'FILE') \\= 16 THEN RETURN\n  DO i=1 to 4\n    if dsn.i='' THEN LEAVE\n    dsn.i=\"'\"dsn.i\"'\"\n    x=LISTDSI(dsn.i 'NORECALL')\n    IF x=16 & SYSREASON=9 THEN DO\n      SAY \"Data Set\" dsn.i 'is migrated; do you want to recall it?'\n      pull x\n      If left(x,1)='N' then exit\n      END\n  END\n  ADDRESS TSO \"ALLOC DD(\"ddn2\") SHR DS(\"dsn.1 dsn.2 dsn.3 dsn.4 \")\"\n  Ddn_string = Ddn_string ' ' ddn2\n  RETURN\n\nERRMSG:\n  \"VGET ZERRMSG\"\n  IF Zerrmsg\\='' THEN\n    \"SETMSG MSG(\"Zerrmsg\")\"\n  EXIT RC\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NOTCTLG3": {"ttr": 14600, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x00\\x82(\\x0f\\x00\\x984o\\x18\\x10\\x01f\\x01\\xde\\x00\\x17\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "1982-10-07T00:00:00", "modifydate": "1998-12-12T18:10:00", "lines": 358, "newlines": 478, "modlines": 23, "user": "CBT472"}, "text": "//GILBERTN JOB (ACCT#),NOTCTLG3,\n//*RESTART=EXECPROC.FROM,\n// CLASS=A,MSGCLASS=X\n//ASMH EXEC PGM=IEV90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n*        REPLACEMENT FOR CZX3PSRC                                     *\n*                                                                     *\n*        1.  PREVENTS \"NOT CATLG 2\" CONDITIONS                        *\n*        2.  VERIFY VSAM DATA SETS                                    *\n*                                                                     *\n*        WARNING: The detection of NOT CATLG 2 situations only        *\n*        occurs when the program's own STEP name is \"FROM\".           *\n*                                                                     *\n***********************************************************************\nNOTCTLG3 CSECT\nNOTCTLG3 RMODE ANY\n         SAVE  (14,12),,'GSF UTILITIES - NOTCTLG3 R201'\n         LR    R11,R15\n         USING NOTCTLG3,R11\n         L     R2,0(,R1)               PARM FROM JCL\n         STORAGE OBTAIN,LENGTH=DYNL,BNDRY=PAGE ALLOCATE DYNAMIC STORAGE\n         ST    R13,4(,R1)              SAVE SAVE AREA ADDRESS\n         LR    R13,R1                  NEW SAVE AREA\n         USING DYN,R13\n         LA    R0,CATNAME              WORK AREA\n         LA    R1,WORK26               WORK AREA\n         STM   R0,R1,CTGPL1+8          ADDR OF CATALOG NAME, WORK AREA\n         ST    R1,CTGPL6+12            ADDRESS OF WORK AREA\n         ST    R1,CAML26+12            ADDRESS OF WORK AREA\n*\n*        PROCESS PARM (GET RETURN CODE VALUE IN BINARY)\n*\n         LH    R15,0(,R2)              PARM LENGTH\n         BCTR  R15,0\n         PACK  RETCODE,2(*-*,R2)       RETURN CODE\n         EX    R15,*-6                 EXECUTE PACK INSTRUCTION\n         CVB   R10,RETCODE             GET RETCODE, CHECK FOR A S0C7\n*\n         L     R1,540(,0)              MY TCB (PSATOLD-PSA)\n         L     R4,TCBJSCB-TCB(,R1)     MY JSCB\n         USING IEZJSCB,R4\n         L     R5,JSCBJCT              GET JCT ADDRESS\n         USING JCT,R5\n         L     R6,JSCSCT               CURRENT STEP'S SCT PREFIX\n         USING SCT,R6\n**       CLC   =C'FROM ',SCTSCLPC      PROCSTEP\n**       BE    LOOPSCT\n         CLC   =C'FROM ',SCTSNAME      STEP=FROM?\n         BNE   RETURN                  IT'S NOT THE RIGHT STEP, I QUIT\n*LOOP\nLOOPSCT  CLC   SCTSDPSA,JSCSCT+1       COND MUST REFER TO MY STEP\n         BNE   NEXTSTEP                IT'S NOT THE CASE, TRY NEXT STEP\n         CH    R10,SCTSDPCD            COND=(54,LT,FROM)\n         BH    NEXTSTEP                STEP TO BE BYPASSED\n         ICM   R1,B'0111',SCTFSIOT     PREFIX OF 1ST SIOT\n         BZ    NEXTSTEP                NO MORE DDS, TRY NEXT SCT\n*--LOOP\nLOOPSIOT BAL   R9,SWAREQ               CONVERT SVA TO 31-BIT ADDRESS\n         LR    R7,R1                   PASS SIOT ADDRESS\n         USING SIOT,R7\n         ICM   R1,B'0111',SCTPJFCB     JFCB PREFIX\n         BAL   R9,SWAREQ               CONVERT SVA TO 31-BIT ADDRESS\n         LR    R8,R1                   PASS JFCB ADDRESS\n         USING JFCB,R8                 DSNAME FROM JFCB\n         MVC   DSNAME,JFCBDSNM         MOVE DSN TO UNPROTECTED STORAGE\n*\n         TM    SCTSDISP,2              DISP=(,CATLG) ?\n         BNO   VSAM00                  JUMP, DISP IS NOT CATLG\n         TM    SCTSBYT3,4              DISP=NEW\n         BO    DISPOK                  JUMP IF DISP=NEW\n         TM    SCTSBYT3,2              DISP=MOD\n         BNO   NEXTSIOT                EXIT IF NOT NEW OR MOD\nDISPOK   TM    JFCBIND1,JFCGDG         CHECK FOR (+1)\n         BO    NEXTSIOT                JUMP, THIS IS A GDG\n         LOCATE CAML26\n         LTR   R15,R15\n         BNZ   NEXTSIOT                DATA SET NOT CATALOGED\n         CLI   MSG2DSN,C' '            CHECK DSNAME\n         BNE   NOTFIRST                NOT FIRST ERROR, JUMP\n         WTO   MF=(E,BLANKLNE)         BLANK LINE\n         WTO   MF=(E,BLANKLNE)         BLANK LINE\nNOTFIRST MVC   MSG2STEP,SCTSNAME       STEPNAME\n         MVC   MSG2DDN,SCTDDNAM        DDNAME\n         MVC   MSG2DSN,JFCBDSNM        DSNAME\n         WTO   MF=(E,MSG2)             ISSUE \"ALREADY CATALOGED\" MSG\n         B     NEXTSIOT\n*\n*        SELECT VSAM DATA SETS\n*\nVSAM00   CLI   JFCDSRG2,JFCORGAM       AMP='AMORG' ON DD?\n         BE    VSAM10                  YES, IT'S A VSAM DATA SET\n         CLC   =C'PPV.',JFCBDSNM       /// FILTER\n         BNE   NEXTSIOT                NOT VSAM, JUMP\n*\nVSAM10   LA    R1,VSTABLE              ADDRESS OF VSAM DSN TABLE\n*--LOOP\nVSAM20   ICM   R2,B'1111',0(R1)        PTR TO JFCBDSNM\n         BZ    VSAM30                  END OF TABLE, QUIT\n         CLC   JFCBDSNM,0(R2)          SAME DSN?\n         BE    NEXTSIOT                YES, DSN PROCESSED ALREADY\n         LA    R1,4(,R1)               BUMP UP TABLE POINTER\n         B     VSAM20                  LOOP THRU VSAM TABLE\n*----ENDLOOP\nVSAM30   LA    R0,JFCBDSNM             ADDR OF DSNAME\n         ST    R0,0(,R1)               ADD NEW ENTRY TO VSTABLE\n         BAL   R9,VERIFY00             GO VERIFY THE VSAM DATA SET\n*\nNEXTSIOT ICM   R1,B'0111',SCTPSIOT     NEXT SIOT'S PREFIX\n         BNZ   LOOPSIOT                PROCESS NEXT DD CARD IN STEP\n*--ENDLOOP\n         DROP  R7,R8                   WERE SIOT, JFCB\nNEXTSTEP ICM   R6,B'0111',SCTANSCT     NEXT SCT PREFIX\n         BNZ   LOOPSCT                 PROCESS NEXT STEP\n*ENDLOOP\nENDSCT   CLI   MSG2DSN,C' '            CHECK FOR AN ERROR\n         BE    RETURN                  NO ERRORS, RETURN.\n         WTO   MF=(E,BLANKLNE)         BLANK LINE\n         WTO   MF=(E,BLANKLNE)         BLANK LINE\n*\n*        IF THE STEP IS AUTHORIZED, SET THE \"JOB FAILED\" BIT ON\n*        IN THE JCT.  IF THE STEP ISN'T AUTHORIZED, ISSUE AN ABEND.\n*        THE ADVANTAGE OF A \"JOB FAILED\" IS THAT COND=EVEN STEPS\n*        ARE NOT EXECUTED.\n*\n         TM    JSCBOPTS,JSCBAUTH       TEST AUTHORIZATION\n         BZ    ABEND88                 JUMP IF NOT AUTHORIZED.\n         MODESET KEY=ZERO              CHANGE TO KEY 0\n         OI    JCTJSTAT,INCMSTS        TURN ON \"JOB FAILED\" BIT\n*\nRETURN   LR    R1,R13                  PASS ADDR FOR FREEMAIN\n         L     R13,4(,R13)\n         STORAGE RELEASE,LENGTH=DYNL,ADDR=(1) FREE DYNAMIC STORAGE\n         LR    R15,R10                 RETURN CODE FROM PARM\n         RETURN (14,12),RC=(15)\nABEND88  ABEND 2088                    AT LEAST 1 CATALOGED DATA SET\n***********************************************************************\n*                                                                     *\n*        SUB-ROUTINE USED TO ACCESS THE SWA MANAGER                   *\n*                                                                     *\n***********************************************************************\nSWAREQ   ICM   R1,B'1000',16(0)        CLEAR FIRST BYTE\n         TM    JCTSTAT2,JCTSWAUP       CHECK SWA PLACEMENT\n         BZR   R9                      SWA BELOW, BYPASS SWAREQ\n         LA    R2,WORK26               WORK AREA\n         ST    R2,EPAPTR               STORE POINTER\n         USING ZB505,R2\n         XC    SWAEPAX,SWAEPAX         CLEAR 32 BYTES\n         STCM  R1,B'0111',SWVA         STORE 3-BYTE SVA\n         SWAREQ FCODE=RL,EPA=EPAPTR,MF=(E,SWAREQL1),UNAUTH=YES\n         L     R1,SWBLKPTR             LOAD SWA CONTROL BLOCK ADDRESS\n         SH    R1,=H'16'               SUBTRACT LENGTH OF PREFIX\n         BR    R9\n         DROP  R2,R5                   WERE ZB505, JCT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        WORK AREAS FOR NOT-CATLG 2 FUNCTION                          *\n*                                                                     *\n*---------------------------------------------------------------------*\nBLANKLNE WTO   '****',ROUTCDE=14,MF=L  BLANK LINE FOR READABILITY\n&STR     SETC  (44)' '\nMSG2     WTO   '**** ALREADY CATALOGED: SSSSSSSS DDDDDDDD &STR',       X\n               ROUTCDE=(11,14),MF=L\nMSG2STEP EQU   MSG2+28+00,8            STEPNAME\nMSG2DDN  EQU   MSG2+28+09,8            DDNAME\nMSG2DSN  EQU   MSG2+28+18,44           DSNAME\nCAML26   CAMLST NAME,DSNAME,,WORK26-WORK26\n***********************************************************************\n*                                                                     *\n*        VERIFY A VSAM DATA SET IF IT NEEDS TO                        *\n*                                                                     *\n***********************************************************************\nVERIFY00 MVI   CATNAME,C' '            LOCATE RETURNS THE CATALOG NAME\n         MVC   WORK26(4),=Y(L'WORK26,0)  FORMAT WORK AREA HEADER\n         LOCATE CTGPL1                 LISTCAT CATACB/NAMEDS/ENTIDNO\n         LTR   R15,R15\n         BNZ   VERIFY99                NOT CATALOGED, QUIT\n         L     R15,CTGFLDA1+4          TCCC (TYPE, CI NUMBER)\n         LA    R15,1(,R15)             CCC (CI NUMBER)\n         L     R0,CTGFLDA2+4           AAAA (CAT ACB ADDRESS)\n         STM   R15,R0,CTGPL6+4         STORE INTO CTGENT, CTGCAT\n         LOCATE CTGPL6                 LISTCAT OPENIND/ENTNAME\n         LTR   R15,R15\n         BNZ   VERIFY99\n         L     R1,CTGFLDA6+4           ADDRESS OF OPENIND\n         CLI   0(R1),X'80'             CHECK OPENIND\n         BNE   VERIFY99                DATA SET NOT OPEN\n         L     R2,CTGFLDA7+4           ADDRESS OF DATA COMPONENT NAME\n         LR    R14,R2                  POINT PAST NAME\nVERIFYL1 LA    R14,1(,R14)             BUMP UP TO NEXT BYTE\n         CLI   0(R14),C' '\n         BNE   VERIFYL1                FIND FIRST BLANK AFTER NAME\n         MVC   0(44,R14),CATNAME       CONCATENATE CATALOG NAME\n         LR    R15,R14                 LENGTH OF COMPONENT NAME\nVERIFYL2 LA    R15,1(,R15)             BUMP UP TO NEXT BYTE\n         CLI   0(R15),C' '\n         BNE   VERIFYL2                FIND FIRST BLANK AFTER NAME\n         LR    R1,R15                  KEEP ADDR OF 1ST BLANK\n         SR    R15,R14                 LENGTH OF CATALOG NAME\n         SR    R14,R2                  LENGTH OF COMPONENT NAME\n         LA    R3,4(R14,R15)           LENGTH OF RNAME\n         STC   R3,0(,R1)               LENGTH OF RNAME\n         STC   R14,1(,R1)              LENGTH OF COMPONENT NAME\n         STC   R15,2(,R1)              LENGTH OF CATALOG NAME\n         MVI   3(R1),C'O'              OPENED FOR OUTPUT\n         GQSCAN AREA=(WORK26,L'WORK26), ADDR & LENGTH OF INFO RETURNED X\n               REQLIM=1,               MAX NUM OF OWNERS TO BE RETURNEDX\n               SCOPE=ALL,              ALL SYSTEMS IN GRS RING         X\n               RESNAME=(QNAME1,(R2),(R3)),                             X\n               MF=(E,GRSWORK)          WORK AREA\n         LTR   R15,R15\n         BZ    VERIFY99                DATA SET IS OPEN\n         LA    R1,=A(S99RB+VL)\n         SVC   99                      ALLOCATE VSAM DATA SET\n         LTR   R15,R15\n         BNZ   VERIFY99                DYNALLOC FAILED\n         MVC   ACB1DDN,S99T1+6         MOVE SYS12345 DDNAME\n         OPEN  ACB1,MODE=31            OPEN ACB FOR AUTOMATIC VERIFY\n         CLOSE ACB1,MODE=31            CLOSE/FREE\nVERIFY99 BR    R9                      GOBACK TO MAIN LOOP\nQNAME1   DC    C'SYSVSAM '             QNAME FOR VSAM OPEN\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DYNAMIC ALLOCATION OF A VSAM DATA SET                        *\n*                                                                     *\n*---------------------------------------------------------------------*\nS99RB    DC    A(X'14010000',0,S99TUPL,0,0)\nS99TUPL  DC    A(S99T1,S99T2,S99T4+VL)\nS99T1    DC    XL2'55,1,8',C'$$VERIFY' DDNAME\nS99T2    DC    AL2(2,1,44),CL44' '     DSNAME\nDSNAME   EQU   S99T2+6,44\nS99T4    DC    AL2(4,1,1),X'08'        DISP=SHR\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CATALOG PARM LIST FOR LISTCAT (NAMEDS,CATACB)                *\n*                                                                     *\n*---------------------------------------------------------------------*\nCTGPL1   DC    A(X'06408100',DSNAME,CATNAME-CATNAME,WORK26-WORK26)\n         DC    X'2000',C' ',X'02'\n         DC    A(0,0,CTGFL1,CTGFL2)\nCTGFL1   DC    A(X'01000000',0,FLDNM1,0)\nCTGFLDA1 DC    2A(0)\nFLDNM1   DC    CL8'NAMEDS'             DATA/INDEX CI NUMBERS\nCTGFL2   DC    A(X'01000000',0,FLDNM2,0)\nCTGFLDA2 DC    2A(0)\nFLDNM2   DC    CL8'CATACB'             ADDRESS OF CATALOG'S ACB\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CATALOG PARM LIST FOR LISTCAT (OPENIND/ENTNAME,HURBADS)      *\n*                                                                     *\n*---------------------------------------------------------------------*\nCTGPL6   DC    A(X'00408100',*-*,*-*,WORK26-WORK26)\n         DC    X'2000',C'D',X'03'\n         DC    A(0,0,CTGFL6,CTGFL7,CTGFL8)\nCTGFL6   DC    A(X'01000000',0,FLDNM6,0)\nCTGFLDA6 DC    2A(0)\nFLDNM6   DC    CL8'OPENIND'            OPEN INDICATOR\nCTGFL7   DC    A(X'01000000',0,FLDNM7,0)\nCTGFLDA7 DC    2A(0)\nFLDNM7   DC    CL8'ENTNAME'            NAME OF ENTRY\nCTGFL8   DC    A(X'01000000',0,FLDNM8,0)\nCTGFLDA8 DC    2A(0)\nFLDNM8   DC    CL8'HURBADS'            HIGH USED RBA\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ACB USED TO VERIFY VSAM DATA SETS                            *\n*                                                                     *\n*---------------------------------------------------------------------*\nACB1     ACB   DDNAME=$$VERIFY,MACRF=(ADR,SEQ,OUT)\nACB1DDN  EQU   ACB1+40,8               DDN POSITION IN ACB\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DYNAMIC STORAGE AREA                                         *\n*                                                                     *\n*---------------------------------------------------------------------*\nDYN      DSECT\nSAVEAREA DS    18F\nRETCODE  DS    D\nSWAREQL1 SWAREQ MF=L                   PARM LIST FOR SWAREQ\nEPAPTR   DS    F                       POINTER TO EPA (ZB505)\nCATNAME  DS    CL44                    CATALOG NAME\nGRSWORK  GQSCAN MF=L\nWORK26   DS    XL512                   SVC26\nVSTABLE  DS    1000A(JFCBDSNM)         VSAM DSN TABLE\nDYNL     EQU   (((*-DYN+4095)/4096)*4096)\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DSECTS FOR SWA/LSQA CONTROL BLOCKS                           *\n*                                                                     *\n*---------------------------------------------------------------------*\nVL       EQU   X'80000000'\n         YREGS                         SYS1.MACLIB\n         IEFZB505 LOCEPAX=YES          EPA MAPPING FOR SWAREQ\n         EJECT\n         IEFJESCT TYPE=DSECT           JES CONTROL TABLE\n         EJECT\n         IKJTCB LIST=NO                SYS1.MODGEN\n         EJECT\n         IEZJSCB ,                     SYS1.AMODGEN\n         EJECT\nJCT      DSECT\n         DS    XL16                    PREFIX\n         IEFAJCTB ,                    SYS1.AMODGEN\n         EJECT\nSCT      DSECT\n         DS    XL16                    PREFIX\n         IEFASCTB ,                    SYS1.AMODGEN\n         EJECT\nSIOT     DSECT\n         DS    XL16                    PREFIX\n         IEFASIOT ,                    SYS1.AMODGEN\n         EJECT\nJFCB     DSECT\n         DS    XL16                    PREFIX\n         IEFJFCBN ,                    SYS1.AMODGEN\n         CVT   LIST=NO,DSECT=YES       COMMUNICATION VECTOR TABLE\n         END\n//SYSLIB   DD DSN=SYS1.AMODGEN,DISP=SHR\n//         DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//LKED    EXEC PGM=HEWL,PARM='MAP,AC=1',COND=(0,NE,ASMH)\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,DELETE)\n//SYSLMOD  DD DSN=GILBERT.LOAD(CZX3PSRC),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//*\n//DD2## DD DISP=(MOD,DELETE),DSN=GILBERT.NOTCTLG2,UNIT=3380,SPACE=(1,0)\n//DD2   DD DISP=(,CATLG),DSN=GILBERT.NOTCTLG2,UNIT=3380,SPACE=(1,0)\n//DD3   DD DISP=(MOD,DELETE),DSN=GILBERT.NOTCTLG3,UNIT=3380,SPACE=(1,0)\n//*\n//PROC    PROC\n//FROM    EXEC PGM=CZX3PSRC,PARM=54\n//STEPLIB  DD DSN=GILBERT.LOAD,DISP=SHR\n//ABNLTERM DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//*\n//STEP53  EXEC PGM=IEFBR14,COND=(53,LT,FROM)\n//DDCAT2 DD DISP=(,CATLG),DSN=GILBERT.NOTCTLG2,UNIT=3380,SPACE=(1,0)\n//*\n//STEP54  EXEC PGM=IEFBR14,COND=(54,LT,FROM)\n//DDCAT2 DD DISP=(,CATLG),DSN=GILBERT.NOTCTLG2,UNIT=3380,SPACE=(1,0)\n//*\n//STEP55  EXEC PGM=IEFBR14,COND=(55,LT,FROM)\n//DDCAT5 DD DISP=(,CATLG),DSN=GILBERT.NOTCTLG3,UNIT=3380,SPACE=(1,0)\n//*\n//STEP56  EXEC PGM=IEFBR14,COND=(56,LT,FROM)\n//DD6A DD DISP=(,CATLG),DSN=GILBERT.NOTCTLG2(+1),UNIT=3380,SPACE=(1,0)\n//DD6B DD DISP=(MOD,CATLG),DSN=GILBERT.NOTCTLG2(MM),\n// UNIT=3380,SPACE=(1,0)\n//VFY  DD DSN=PPV.VFY,DISP=SHR\n//*\n//STEP57  EXEC PGM=IEFBR14,COND=(57,LT,FROM)\n//VFY  DD DSN=GILBERT.VFY2,AMP='AMORG',DISP=SHR\n//        PEND\n//*\n//EXECPROC EXEC PROC\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OBEYFILE": {"ttr": 14853, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97$\\x1f\\x00\\x98\\x17\\x1f\\x11\\x05\\x00\\xa3\\x00L\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-08-29T00:00:00", "modifydate": "1998-06-20T11:05:00", "lines": 163, "newlines": 76, "modlines": 0, "user": "CBT472"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* Module Name: OBEYFILE                                              */\n/*                                                                    */\n/* Descriptive Name:  OBEYFILE EDIT macro for ISPF and MVS TCP/IP.    */\n/*                                                                    */\n/* Status: R100                                                       */\n/*                                                                    */\n/* Function: This ISPF EDIT macro allows the TCP/IP administrator     */\n/*           to use the data being edited as input to the TSO         */\n/*           OBEYFILE command without having to SAVE it.              */\n/*                                                                    */\n/*           This EDIT macro writes the data being edited to the ISPF */\n/*           control data set and issues the TSO OBEYFILE command.    */\n/*                                                                    */\n/*           The user can use the C, Cnn or CC/CC line command to     */\n/*           select a range of lines to be passed to OBEYFILE.        */\n/*                                                                    */\n/*           This EDIT macro is a convenient way to test changes      */\n/*           to the TCP/IP profile data set without having to         */\n/*           actually save the modifications into the profile         */\n/*           or another data set.                                     */\n/*                                                                    */\n/* Author: Gilbert Saint-Flour <carlos@gsf-soft.com>                  */\n/*                                                                    */\n/* Environment: ISPF/PDF V3                                           */\n/*              TCP/IP for MVS                                        */\n/*                                                                    */\n/* Operation: OBEYFILE must be invoked as an EDIT macro without       */\n/*            any parameter.  A range selection line command such     */\n/*            as C, Cnn or CC/CC can be specified.                    */\n/*                                                                    */\n/* Change Activity:                                                   */\n/*                                                                    */\n/**********************************************************************/\n\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"ISREDIT MACRO (parm) NOPROCESS\"\nIF rc>0 THEN SIGNAL Not_an_EDIT_macro\nIF parm\\='' THEN SIGNAL No_Parms_allowed\n\n/**********************************************************************/\n/*                                                                    */\n/*          Determine what temporary data set to use.                 */\n/*                                                                    */\n/*  1. If the current ISPF control data set is non-temporary          */\n/*     (ztempf=userid.SPFTEMPn.CNTL), use it.                         */\n/*                                                                    */\n/*  2. If the control data set is preallocated to DD(ISPCTLn),        */\n/*     allocate userid.SPFTEMPn.CNTL and use it.                      */\n/*                                                                    */\n/**********************************************************************/\n\n\"VGET (ZTEMPF ZTEMPN ZSCREEN ZUSER)\"\nIF ztempn = 'ISPCTL' || zscreen then DO\n  ztempn = 'OBEYFILE'\n  rc=LISTDSI(ztempn FILE)\n  IF rc=0 THEN\n    ztempf = \"'\" || sysdsname || \"'\"\n  ELSE DO\n    ztempf = \"'\" || zuser || \".SPFTEMP\" || zscreen || \".CNTL'\"\n    rc=LISTDSI(ztempf NORECALL)\n    IF rc=0 THEN DO\n      ADDRESS TSO \"ALLOCATE DD(\" ztempn \") DS(\" ztempf \") SHR\"\n      IF rc>0 THEN EXIT rc\n      END\n    ELSE DO\n      IF sysreason = 9 | sysreason = 26 THEN\n        \"HDELETE\" ztempf \"WAIT\"\n      ADDRESS TSO \"ALLOCATE DD(\" ztempn \") DS(\" ztempf \") NEW CATALOG\",\n                  \"SPACE (1 1) TRACKS UNIT(SYSALLDA)\",\n                  \"DSORG(PS) RECFM(F B) LRECL(80)\"\n      END\n    END\n  END\nELSE\n  ztempf = \"'\" || ztempf || \"'\"\n\n/**********************************************************************/\n/*                                                                    */\n/*   If the user selected a range by entering a line command such     */\n/*   as C, Cnn or C/CC, set line1 and line2 to the first and last     */\n/*   line numbers, respectively.  Otherwise, set line1 to 1 and       */\n/*   line2 to the last line of the data set.                          */\n/*                                                                    */\n/**********************************************************************/\n\n'ISREDIT PROCESS RANGE C'\nSELECT\n  WHEN rc=0 THEN DO\n    \"ISREDIT (LINE1) = LINENUM .ZFRANGE\"         /* First line  */\n    \"ISREDIT (LINE2) = LINENUM .ZLRANGE\"         /* Last line   */\n    END\n  WHEN rc=4 THEN DO\n    Line1=1                                    /*   DEFAULTS  */\n    \"ISREDIT (LINE2) = LINENUM .ZLAST\"         /*   DEFAULTS  */\n    END\n  WHEN rc=20 THEN                       /* All lines deleted        */\n    SIGNAL Empty_dataset                /* No lines to ROUTE        */\n  OTHERWISE DO                          /* Line command conflict    */\n    Pgmrc=rc                            /* Save ISREDIT Return code */\n    IF zerrmsg\\='' THEN\n      'SETMSG MSG('zerrmsg')'           /* Edit has created message */\n    EXIT Pgmrc\n    END\nEND\n\n/**********************************************************************/\n/*                                                                    */\n/*  QUEUE the data lines to the stack and write them out to &ztempf   */\n/*                                                                    */\n/**********************************************************************/\n\nDO line1=line1 TO line2\n  \"ISREDIT (LINE) = LINE\" Line1               /* GET CURRENT LINE */\n  QUEUE Line\n  END\nQUEUE ''                                      /* end of file      */\n\nADDRESS TSO\n\"EXECIO * DISKW\" ztempn \"(FINIS\"\n\n/**********************************************************************/\n/*                                                                    */\n/*       Reallocate &ztempf with DISP(SHR) to prevent error 8538      */\n/*                                                                    */\n/**********************************************************************/\n\n\"FREE DD(\" ztempn \") KEEP\"\nIF rc>0 THEN EXIT rc\n\"ALLOCATE DD(\" ztempn \") DS(\" ztempf \")\" SHR\nIF rc>0 THEN EXIT rc\n\n/**********************************************************************/\n/*                                                                    */\n/*             Execute the TCP/IP OBEYFILE command                    */\n/*                                                                    */\n/**********************************************************************/\n\n\"OBEYFILE\" ztempf\nEXIT rc\n\n/**********************************************************************/\n/*                      Exception Routines                            */\n/**********************************************************************/\nNot_an_EDIT_macro:\n  Zedsmsg = \"EDIT Macro Only\"                  /* Short message    */\n  Zedlmsg = \"OBEYFILE may only be invoked as an EDIT macro\"\n  \"SETMSG MSG(ISRZ001)\"                        /* send the message */\n  EXIT 8\nNo_Parms_allowed:\n  Zedsmsg = \"No parms allowed\"                 /* Short message    */\n  Zedlmsg = \"The OBEYFILE EDIT macro does not accept any parameters\",\n            \"other than a range selection line command such as\",\n            \"C, Cnn or CC/CC\"\n  \"SETMSG MSG(ISRZ001)\"                        /* send the message */\n  EXIT 8\nEmpty_dataset:\n  zedsmsg='Empty data set'\n  zedlmsg='There are no lines to print'\n  'SETMSG MSG(ISRZ001)'\n  EXIT 12\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PACKOFF": {"ttr": 14857, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x91)\\x1f\\x00\\x912\\x7f\\x11W\\x00\\xd1\\x00\\xba\\x00\\x00\\xc3\\xc2\\xe3\\xf3\\xf4\\xf3@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1991-10-18T00:00:00", "modifydate": "1991-11-23T11:57:00", "lines": 209, "newlines": 186, "modlines": 0, "user": "CBT343"}, "text": "//GILBERTL JOB (ACCT#),PACKOFF,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//*\n//*      UNPACK A FILE PACKED BY ISPF/PDF OR XEDIT\n//*\n//ASMH EXEC PGM=IEV90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\nUNPACK   CSECT\n         SAVE  (14,12),,UNPK-PDF-XEDIT-&SYSDATE\n         BALR  R12,0                   BASE REGISTER\n         USING *,R12\n         ST    R13,SAVEAREA+4          CALLER'S SAVE AREA\n         LA    R13,SAVEAREA            MY OWN SAVE AREA\n         OPEN  (SYSIN,,SYSPUNCH,OUTPUT)\n         GET   SYSIN                   GET FIRST INPUT RECORD, SET R1\n         MVI   TENWORDS+0,00           RESET PACKED/UNPACKED FLAG\n         MVI   TENWORDS+1,C'F'         RECFM=F\n         B     L1GET2                  PROCESS 1ST BLOCK\n*LOOP\nL1GET    GET   SYSIN                   GET INPUT RECORD, SET R1\nL1GET2   MVC   TENWORDS+2(2),SYSIN+82  PASS BLOCK LENGTH\n*\nL1UNPK   LA    R0,TENWORDS             UNPACK WORK AREA\n         L     R15,=A(PACKOFF)         UNPACK ROUTINE\n         BALR  R14,R15             <== INVOKE \"PACKOFF\" ROUTINE\n         LTR   R15,R15                 DO I NEED ANOTHER INPUT RECORD?\n         BNZ   L1GET                   YES, GET ONE\n         LR    R0,R1                   PASS ADDR OF UNPACKED RECORD\n         PUT   SYSPUNCH,(0)            PRINT IT\n         B     L1UNPK\n*ENDLOOP\nEOD1     CLOSE (SYSIN,,SYSPUNCH)\n         FREEPOOL SYSIN                FREE BUFFERS\n         FREEPOOL SYSPUNCH             FREE BUFFERS\n         L     R13,4(,R13)             CALLER'S SAVE AREA\n         RETURN (14,12),RC=00\n***********************************************************************\nSYSIN    DCB   DSORG=PS,MACRF=GL,DDNAME=SYSIN,EODAD=EOD1,RECFM=U\nSYSPUNCH DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPUNCH,RECFM=FB,LRECL=80\nSAVEAREA DS    9D\nTENWORDS DS    10F\n         YREGS                         REGISTER EQUATES\n***********************************************************************\n*\n*        PACKOFF ROUTINE\n*\n***********************************************************************\nPACKOFF  CSECT\n         SAVE  (14,12),,*              SAVE REGISTERS\n         BALR  R10,0                   ,\n         USING *,R10                   ,\n         LR    R9,R0                   WORK AREA\n         USING UNPKWORK,R9             WORK AREA\n*\n*              #1.  C'U' UNPACKED FILE\n*              #2.  C'P' RE-ENTRY (NEXT LINE REQUESTED)\n*              #3.  C'P' RE-ENTRY (FORCED EXIT FOR NEW INPUT REC)\n*              #4.  X'00' FIRST TIME\n*\n         CLI   UNPKWORK,C'U'           IS IT UNPACKED?\n         BE    UNPK990                 YES, GOBACK                 (#1)\n         L     R2,UNPKSAVE+4           CURRENT POS IN INPUT RECORD\n         CLI   UNPKSAVE,X'FF'          FORCED EXIT?\n         BE    UNPK110                 NO, BUILD NEXT RECORD       (#2)\n         LA    R2,0(,R1)               PASS RCD ADDR, CLEAR HI-BIT\n         LR    R3,R2                   PASS ADDR\n         AH    R3,UNPKWORK+2           ADD RECORD LENGTH\n         LM    R15,R1,UNPKSAVE         RESTORE R14, R0, R1\n         STM   R2,R3,UNPKSAVE+4        BEGIN/END OF INREC\n         CLI   UNPKWORK,0              FIRST TIME?\n         BNER  R15                     NO, RESUME PROCESSING       (#3)\n*\n*        FIRST TIME - DETERMINE WHETHER THIS IS A PACKED FILE      (#4)\n*\nUNPK050  MVI   UNPKWORK,C'U'           SET \"PACK OFF\" FLAG\n         MVI   UNPKSAVE,00             INIT \"PACK OFF\" RETURN CODE\n         CLI   UNPKWORK+1,C'F'         RECFM=F?\n         BNE   UNPK990                 NO, QUIT\n***      CLC   0(8,R2),=X'0001,40,C6,0000,0050'\n         CLI   0(R2),00                PACKED FILE?\n         BNE   UNPK990                 PACK OFF, JUMP\n         CLI   1(R2),1                 CHECK LEVEL\n         BNE   UNPK990                 PACK OFF, JUMP\n***      CLC   3(1,R2),UNPKWORK+1      COMPARE RECFM\n***      BNE   UNPK990                 PACK OFF, JUMP\n***      CLC   6(2,R2),UNPKWORK+2      COMPARE LRECL\n***      BNE   UNPK990                 PACK OFF, JUMP\n*\n         MVI   UNPKWORK,C'P'           SET \"PACK ON\" FLAG\n         MVC   UNPKWHDR,0(R2)          SAVE HEADER\n         LA    R2,8(,R2)               FIRST CONTROL BYTE\n*NEW INREC\nUNPK110  ICM   R0,B'1111',UNPKW255+4   LOAD/TEST ADDR OF RECORD AREA\n         BNZ   UNPK200                 ALREADY ALLOCATED, JUMP\n         GETMAIN R,LV=255              GET A RECORD AREA\n         STM   R0,R1,UNPKW255          SAVE LEN/ADDR OF RECORD AREA\n         LR    R0,R1                   PASS ADDRESS\n*--LOOP\nUNPK200  CL    R2,UNPKSAVE+4+4         END OF LINE REACHED?\n         BL    UNPK205                 NOT YET, JUMP\n         BAL   R14,UNPK600             READ NEW INPUT RECORD\n*\nUNPK205  CLI   0(R2),X'FF'             END OF FILE OR MEMBER?\n         BE    UNPK980                 YES, NEXT MEMBER OR EODAD\n         TM    0(R2),X'80'             IS IT A STRING?\n         BO    UNPK220                 YES, JUMP\n         CLI   0(R2),X'7A'             IS IT A REPEATED CHARACTER?\n         BE    UNPK230                 YES, JUMP\n*SPACES\nUNPK210  SLR   R1,R1\n         IC    R1,0(,R2)               GET REPEAT FACTOR -1\n         LA    R1,1(,R1)               LENGTH OF STRING\n         SLR   R3,R3\n         ICM   R3,B'1000',UNPKWHDR+2   PICK UP CHARACTER TO REPEAT\n         LA    R2,1(,R2)               BUMP UP PTR IN INPUT RCD\n         B     UNPK290                 MOVE SPACES\n*STRING\nUNPK220  LA    R15,X'0000007F'         MASK FOR \"NR\"\n         IC    R1,0(,R2)               STRING LENGTH-1+X80\n         NR    R1,R15                  STRING LENGTH-1\n         LA    R1,1(,R1)               LENGTH OF STRING\n         LA    R2,1(,R2)               SKIP OVER CONTROL BYTE\n         L     R3,UNPKSAVE+4+4         1ST BYTE AFTER INREC\n         SR    R3,R2                   LENGTH REMAINING IN INPUT RECORD\n         BZ    UNPK220L                CTL BYTE IS LAST BYTE, RE-READ\n         CR    R3,R1                   BYTES LEFT, STRING LENGTH\n         BNL   UNPK290                 NOT BROKEN, MOVE FULL STRING\n*BROKEN STRING\n         XR    R1,R3                   SWAP \"FROM\" AND \"TO\" LENGTHS\n         XR    R3,R1                   SWAP \"FROM\" AND \"TO\" LENGTHS\n         XR    R1,R3                   SWAP \"FROM\" AND \"TO\" LENGTHS\n         MVCL  R0,R2                   MOVE 1ST PART OF STRING\n         LR    R1,R3                   NUMBER OF BYTES LEFT\nUNPK220L BAL   R14,UNPK600             READ NEXT INREC\n         LR    R3,R1                   REMAINING LENGTH\n         B     UNPK290                 MOVE REST OF STRING\n*ALLCHAR\nUNPK230  L     R1,UNPKSAVE+4+4         1ST BYTE AFTER INREC\n         SLR   R1,R2                   REMAINING LENGTH\n         LA    R15,0002                PREPARE \"CR\"\n         CR    R1,R15                  2 BYTES LEFT?\n         BE    UNPK232                 YES, JUMP\n         BH    UNPK233                 AT LEAST 3, JUMP\n*SPLIT ALLCHAR (1)\nUNPK231  BAL   R14,UNPK600             READ NEXT INREC\n         SLR   R1,R1\n         IC    R1,0(,R2)               GET REPEAT FACTOR\n         LA    R2,1(,R2)               BUMP UP OVER REPEAT FACTOR\n         B     UNPK240                 MOVE ALL CHARS TO OUTPUT RECORD\n*SPLIT ALLCHAR (2)\nUNPK232  SLR   R1,R1\n         IC    R1,1(,R2)               GET REPEAT FACTOR\n         BAL   R14,UNPK600             READ NEXT INREC\n         B     UNPK240                 MOVE ALL CHARS TO OUTPUT RECORD\n*ALLCHAR (3)\nUNPK233  SLR   R1,R1\n         IC    R1,1(,R2)               GET REPEAT FACTOR\n         LA    R2,2(,R2)               BUMP UP OVER 7A02\n*\nUNPK240  LA    R1,1(,R1)               \"TO\" LENGTH\n         LA    R3,0001                 MOVE JUST ONE BYTE\n         ICM   R3,B'1000',0(R2)        INSERT PADDING CHARACTER\n*\n*     MOVE  STRING - R0=UNPKW255 R1=OUTLEN R2=INADDR   R3=INLEN+PADDING\n*\nUNPK290  MVCL  R0,R2                   MOVE CHARS TO UNPKW255\nUNPK291  L     R1,UNPKW255+4           OUTPUT RECORD\n         AH    R1,UNPKWHDR+6           LRECL\n         CR    R0,R1                   EOL REACHED YET?\n         BL    UNPK200                 NO, LOOP\n*--ENDLOOP\n         ST    R2,UNPKSAVE+4           CURRENT POS IN INPUT RECORD\n         MVC   24(4,R13),UNPKW255+4    PASS ADDR OF UNPACKED RECORD\n         MVI   UNPKSAVE,X'FF'          INVALIDATE ADDRESS\n         RETURN (14,12),RC=0           NORMAL EXIT\n*\n*        FORCED EXIT (TO REQUEST NEXT INPUT RECORD)\n*\nUNPK600  LR    R15,R14                 SAVE RETURN ADDRESS\n         STM   R15,R1,UNPKSAVE         SAVE R14, R0, R1\n         RETURN (14,12),RC=4\nUNPK980  MVI   UNPKSAVE,X'00'          INVALIDATE ADDRESS\n         RETURN (14,12),RC=8           END OF FILE (X'FF')\n*\n*        \"PACK OFF\" EXIT (SENDS ALTERNATIVELY RC0 AND RC 4)\n*\nUNPK990  SLR   R15,R15                 INVALIDATE ADDRESS\n         IC    R15,UNPKSAVE            PICK UP RETURN CODE\n         XI    UNPKSAVE,X'04'          TOGGLE RETCODE\n         RETURN (14,12),RC=(15)        \"PACK OFF\" EXIT\n*\nUNPKWORK DSECT\n         DS    X'00'               +0  X'00' C'P' C'U'\n         DS    C'F'                +1  RECORD FORMAT\n         DS    H'80'               +2  LENGTH OF INPUT RECORD/BLOCK\nUNPKW255 DS    F,A                 +4  LENGTH/ADDRESS OF RECORD AREA\nUNPKWHDR DS    0XL8,X'0001,40,C6,0000,0050'\nUNPKSAVE DS    A(R15,R0,R1)            FORCED EXIT\n         DS    (UNPKWORK+32-*)X        MAX SIZE IS 8 WORDS\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//GO      EXEC PGM=LOADER,PARM=NOPRINT\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,DELETE)\n//*\n//SYSIN    DD DSN=GILBERT.XEDIT,RECFM=U,DISP=SHR\n//SYSPUNCH DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PASTE": {"ttr": 14861, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04\\x03\\x00\\x00\\x00\\x93\\x03\\x8f\\x00\\x96\\x06o\\tD\\x01\\x01\\x00\\x04\\x00L\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "04.03", "flags": 0, "createdate": "1993-02-07T00:00:00", "modifydate": "1996-03-06T09:44:00", "lines": 257, "newlines": 4, "modlines": 76, "user": "CBT472"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* MODULE NAME = PASTE                                                */\n/*                                                                    */\n/* DESCRIPTIVE NAME = PASTE EDIT Macro for ISPF/PDF                   */\n/*                                                                    */\n/* STATUS   =  R403                                                   */\n/*                                                                    */\n/* FUNCTION =  Retrieve the data stored in a clip-board by the CUT    */\n/*             macro and insert it into the the current data set.     */\n/*                                                                    */\n/*             PASTE is functionally similar to a COPY command.       */\n/*             It is used in conjunction with the CUT macro.          */\n/*                                                                    */\n/*             PASTE's OUTTRAP function executes a specified TSO      */\n/*             command and pastes its output into the EDIT data set.  */\n/*                                                                    */\n/* AUTHOR   =  Gilbert Saint-Flour <carlos@gsf-soft.com>              */\n/*                                                                    */\n/* SYNTAX   =  PASTE                                                  */\n/*                 clipboard             name of clip-board           */\n/*                 BEFORE|AFTER .label   destination                  */\n/*                                                                    */\n/*             clip-board is the name you specified in the CUT        */\n/*             command that you entered to CUT the data you now       */\n/*             want to PASTE.                                         */\n/*                                                                    */\n/*             Destination indicates where the data should be copied  */\n/*             into the current data set.  Specification is the same  */\n/*             as in a COPY command:                                  */\n/*                                                                    */\n/*             1. as an operand of the PASTE command, such as:        */\n/*                                                                    */\n/*                     PASTE BEFORE .X                                */\n/*                or                                                  */\n/*                     PASTE AFTER .ZL                                */\n/*                                                                    */\n/*             2. with the A or B line commands.                      */\n/*                                                                    */\n/*             BEFORE and AFTER can be abbreviated BEF and AFT,       */\n/*             respectively.  The destination is not required if      */\n/*             the current data set is empty.                         */\n/*                                                                    */\n/*             The data present in the clip-board are not deleted     */\n/*             by the PASTE command and can be PASTE'd again until    */\n/*             the end the TSO session.                               */\n/*                                                                    */\n/* SYNTAX   =  PASTE                                                  */\n/*                 *                     indicates OUTTRAP function   */\n/*                 TSO Command           TSO command to execute       */\n/*                                                                    */\n/*             When the user specifies an asterisk as clip-board name */\n/*             and a TSO command, as in PASTE * LISTA the TSO command */\n/*             is executed, its output trapped with the OUTTRAP       */\n/*             function and pasted at the specified destination.      */\n/*                                                                    */\n/* DEPENDENCIES =  MVS/ESA 4.2.2                                      */\n/*                 TSO/E V2                                           */\n/*                 ISPF and ISPF/PDF V3                               */\n/*                 CUTPGM utility program R400                        */\n/*                                                                    */\n/* CHANGE ACTIVITY                                                    */\n/*                                                                    */\n/*  $401  Remove EXIT stmt before last SETMSG command                 */\n/*  $402  OUTTRAP function                                            */\n/*  $403  Clip-board name may be enclosed in quotes                   */\n/*                                                                    */\n/**********************************************************************/\nADDRESS ISPEXEC; 'CONTROL ERRORS RETURN'; ZERRMSG=''\n\nCALL Parse_parm                           /*  Analyse the command    */\nCALL Process_dest                         /*  Process Destination    */\n\nIF LENGTH(Parm) > 2 & LEFT(Parm,2)='* ' THEN\n  CALL Paste_OUTTRAP\nELSE DO\n  /*-----------------------------------------------------------------*/\n  /*   Build the parm for the CUTPGM program, as follows:            */\n  /*                                                                 */\n  /*     parm=Pcccccccc111111                                        */\n  /*                                                                 */\n  /*         P          function=PASTE                               */\n  /*         cccccccc   8-character clipboard name (or blanks)       */\n  /*         111111     first line                                   */\n  /*-----------------------------------------------------------------*/\n\n  'ISREDIT (Nummode,Numtype) = NUMBER'   /* Query number mode info    */\n  IF Nummode='ON' THEN DO\n    IF WORDPOS('COBOL',Numtype) >0 THEN\n      'ISREDIT NUMBER = OFF'             /* Turn OFF number mode      */\n    END\n\n  parm='P'||LEFT(clipboard,8)||RIGHT(Line1,6,'0')\n\n  'SELECT PGM(CUTPGM) PARM('parm')'; Pgmrc=rc\n\n  'ISREDIT NUMBER =' Nummode              /* Turn number mode back ON */\n\n  IF Pgmrc = 12 THEN SIGNAL Empty_clipboard\nEND\n  /*-----------------------------------------------------------------*/\n  /*   Issue completion message and exit                             */\n  /*-----------------------------------------------------------------*/\n\n'ISREDIT (Line1) = LINENUM .ZLAST'       /* NUMBER OF LINES NOW       */\nI=Line1-Line2                            /* NUMBER OF LINES PASTED    */\nzedsmsg=I 'Lines pasted'\nIF clipboard='' THEN\n  zedlmsg=i 'lines have been copied from the default clipboard '\nELSE\n  zedlmsg=i 'lines have been copied from clipboard' clipboard\n'SETMSG MSG(ISRZ000)'\nEXIT 0\n/**********************************************************************/\n/*                                                                    */\n/*            Parse Input Parm, process line commands.                */\n/*                                                                    */\n/**********************************************************************/\nParse_parm:\n  'ISREDIT MACRO (PARM) NOPROCESS'\n  IF rc>0 THEN\n    SIGNAL Not_an_EDIT_macro                  /* Invoked as a TSO cmd */\n\n  IF parm='?' THEN\n    SIGNAL HELP_panel\n\n  UPPER parm; clipboard=''; after=''; Line1=''\n  'ISREDIT (Line2) = LINENUM .ZLAST'          /* Number of lines now  */\n\n  IF LENGTH(Parm) > 2 & LEFT(Parm,2)='* ' THEN    /* OUTTRAP function */\n    RETURN\n\n  DO i=1 to WORDS(parm)\n    p=WORD(parm,i)                            /* Extract current word */\n    IF LEFT(p,1)='.' THEN\n      SIGNAL Invalid_label\n    ELSE DO\n      IF ABBREV('BEFORE',p,3) | ABBREV('AFTER',p,3) THEN DO\n        IF after\\='' THEN SIGNAL Invalid_label\n        IF i=WORDS(parm) THEN SIGNAL Missing_Label\n        after=LEFT(p,1)                       /* save A or B          */\n        i=i+1\n        p=WORD(parm,i)                        /* get next word (label)*/\n        IF LEFT(p,1)='.' THEN DO\n          'ISREDIT (Line1) = LINENUM' p\n          IF rc>0 then SIGNAL Invalid_label\n          IF after='B' THEN\n            Line1=Line1-1                     /* Before .X            */\n          END\n        ELSE\n          SIGNAL Invalid_label                /* AFTER xyz            */\n        END\n      ELSE DO\n        IF clipboard\\='' THEN\n          SIGNAL Invalid_label                /* Duplicate clip-board */\n        /*    Check the clip-board name for correct syntax.           */\n        IF LEFT(p,1)=\"'\" | LEFT(p,1)='\"' THEN /* Quoted string        */\n          p=STRIP(p,'B',LEFT(p,1))\n        IF LENGTH(p)>8 THEN                   /* name is too long     */\n          SIGNAL Bad_clip_board\n        IF VERIFY(p,'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$ ') > 0 THEN\n          SIGNAL Bad_clip_board               /* invalid character    */\n        clipboard=p\n        END\n    END\n  END\n  RETURN\n/**********************************************************************/\n/*                                                                    */\n/*      Check if the user selected a destination by entering a line   */\n/*      command such as A or B.  If it is the case, set line1 to the  */\n/*      line number after which the data should be inserted.  If the  */\n/*      user selected a destination both in the PASTE command (as in  */\n/*      PASTE AFT .X) and in a line command, issue an error message.  */\n/*                                                                    */\n/**********************************************************************/\nProcess_dest:\n  'ISREDIT PROCESS DEST'                 /* set .ZDEST to destination */\n  SELECT\n    WHEN RC=0 THEN DO                    /* A or B entered */\n      IF Line1\\='' THEN SIGNAL Command_conflict\n      'ISREDIT (Line1) = LINENUM .ZDEST'\n    END\n    WHEN RC=8 THEN DO                    /* Neither A nor B entered */\n      IF Line1='' THEN DO\n        zerrsm = 'Enter A or B line cmd'\n        zerrlm = 'PASTE requires an A or B line command'\n        SIGNAL Beep_msg\n      END\n    END\n    WHEN RC=20 THEN                      /* Empty data set           */\n      Line1=0\n    OTHERWISE                            /* Line command conflict    */\n      SIGNAL SETMSG                      /* Edit has created message */\n  END\n  RETURN\n/**********************************************************************/\n/*                                                                    */\n/*      OUTTRAP Function (Sub-routine)                                */\n/*                                                                    */\n/*      This function is executed when the user specifies an asterisk */\n/*      as clip-board name and a TSO command, as in PASTE * LISTA.    */\n/*      The TSO command is executed, its output trapped with the      */\n/*      OUTTRAP function and pasted at the specified destination.     */\n/*                                                                    */\n/**********************************************************************/\nPaste_OUTTRAP:\n  cmd=RIGHT(Parm,LENGTH(Parm)-2)               /* delete leading \"*\"  */\n  Pgmrc = OUTTRAP('MSG.')                      /* TRAP PUTLINE        */\n  ADDRESS TSO cmd\n  DO I=MSG.0 TO 1 BY -1\n    Line=Msg.I\n    \"ISREDIT LINE_AFTER\" Line1 \"= DATALINE (LINE)\"\n  END\n  RETURN\n/**********************************************************************/\n/*            Exception Routines                                      */\n/**********************************************************************/\nNot_an_EDIT_macro:\n  Zedsmsg = \"EDIT Macro Only\"                  /* Short message    */\n  Zedlmsg = \"PASTE may only be invoked as an EDIT macro\"\n  \"SETMSG MSG(ISRZ001)\"                        /* send the message */\n  EXIT 8\nHELP_panel:\n  'DISPLAY PANEL(CUTHLP2)'               /* Display HELP panel        */\n  IF rc>8 THEN\n    SIGNAL SETMSG                        /* HELP panel is missing     */\n  EXIT 0\nMissing_Label:\n  zerrsm='Missing Label'\n  p='You must specify a label after the \"BEFORE\" or \"AFTER\" keyword.'\n  zerrlm=p\n  SIGNAL Beep_msg\nInvalid_label:\n  zerrsm='Probable label error'\n  zerrlm=p 'recognized as invalid or undefined label.'\n  SIGNAL Beep_msg\nCommand_conflict:\n  zerrsm='Command Conflict'\n  zerrlm='A or B conflicts with range specification; blank it out.'\n  SIGNAL Beep_msg\nBad_clip_board:\n  zerrsm='Invalid clip-board'\n  zerrlm='The clip-board name must be a valid member name'\n  SIGNAL Beep_msg\nEmpty_clipboard:\n  zerrsm='Empty clip-board'\n  zerrlm='Nothing was cut to this clip-board during this TSO session.'\n  SIGNAL Beep_msg\nBeep_msg:\n  zerralrm='YES'                  /*   ALARM=YES                      */\n  zerrhm='CUTHLP2'                /*   HELP Panel                     */\n  'SETMSG MSG(ISRZ002)'           /*   Issue error message            */\n  EXIT 20\nSETMSG:\n  'SETMSG MSG('zerrmsg')'\n  EXIT 20\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PLI2JOB": {"ttr": 15109, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x006\\x00\\x93\\x04O\\x01\\x085O\\x12\\x12\\x00\\x8e\\x00[\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-02-13T00:00:00", "modifydate": "2008-12-19T12:12:36", "lines": 142, "newlines": 91, "modlines": 0, "user": "CBT476"}, "text": "//GILBERTJ JOB (ACCT#),PLI2JOB,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(4,LT)\n//*PLI EXEC PGM=IEL1AA,PARM=(OPTIONS,SOURCE)\n//*STEPLIB DD DSN=IEL111.SIELCOMP,DISP=SHR\n//PLI EXEC PGM=IBMZPLI,PARM=(OPTIONS,SOURCE,NOLIST),REGION=64M\n//STEPLIB  DD DSN=IEL330.SIBMZCMP,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD UNIT=VIO\n//SYSLIN   DD UNIT=VIO,DISP=(,PASS)\n//SYSIN    DD *\n /********************************************************************/\n /*                                                                  */\n /*  MODULE NAME = PLI2JOB                                           */\n /*                                                                  */\n /*  DESCRIPTIVE NAME = Sample PL/I program to retrieve job-related  */\n /*                     information from MVS control blocks and      */\n /*                     display it on SYSPRINT.                      */\n /*                                                                  */\n /*  FUNCTION = This sample program demonstrates how to retrieve     */\n /*             JOB-related info about the job, TSO or STC address   */\n /*             space in which it is executed.                       */\n /*                                                                  */\n /*             The layout of the MVS control blocks is described    */\n /*             in the MVS Data Areas manuals, which can be found    */\n /*             on any MVS or OS/390 CD collection or viewed         */\n /*             on-line by going to:                                 */\n /*          http://www.s390.ibm.com/bookmgr-cgi/bookmgr.cmd/library */\n /*             and searching for:  MVS DATA AREAS                   */\n /*                                                                  */\n /*  AUTHOR   =  Gilbert Saint-Flour <carlos@gsf-soft.com>           */\n /*              http://gsf-soft.com/Freeware/                       */\n /*                                                                  */\n /********************************************************************/\n     PLI2JOB: Procedure Options(MAIN);\n\n       DCL cb1(256) based(addr_cb1) Pointer;\n       DCL cb1_text based(addr_cb1) Char(1024);\n       DCL cb2(256) based(addr_cb2) Pointer;\n       DCL cb2_text based(addr_cb2) Char(1024);\n       DCL four_bytes Char(4),\n           full_word Fixed Bin(31,0) based(Addr(four_bytes)),\n           ptr4 Pointer based(Addr(four_bytes));\n       DCL ptr0 Pointer;\n       DCL eight_bytes Char(8),\n           double_word Fixed Bin(31,0) based(addr(eight_bytes));\n       DCL 1 Results,\n             2 job_name  Char(8),\n             2 proc_step Char(8),\n             2 step_name Char(8),\n             2 program_name Char(8),\n             2 program_name2 Char(8),\n             2 job_number Char(8),\n             2 job_class Char(1),\n             2 msg_class Char(1),\n             2 acct1 Char(32),\n             2 programmer_name Char(20),\n             2 batch_or_cics Char(5),\n             2 micro_seconds Fixed Dec(12,0),\n             2 user_id Char(8),\n             2 group_name Char(8),\n             2 user_name Char(20);\n\n       four_bytes='00000000'X; ptr0=ptr4;                   /* PTR0=0 */\n\n       addr_cb1=ptr0;                                         /* PSA  */\n       addr_cb1=cb1(136);                                     /* TCB  */\n       eight_bytes=SUBSTR(cb1_text,317,8);\n       micro_seconds=double_word/4096;\n\n       addr_cb2=cb1(4);                                       /* TIOT */\n       job_name=SUBSTR(cb2_text,1,8);\n      step_name=SUBSTR(cb2_text,9,8);\n      proc_step=SUBSTR(cb2_text,17,8);\n\n       addr_cb2=cb1(46);                                      /* JSCB */\n      program_name=SUBSTR(cb2_text,361,8);\n\n       addr_cb2=cb2(80);                                      /* SSIB */\n      job_number=SUBSTR(cb2_text,13,8);\n\n       addr_cb2=cb1(1);                                       /* PRB  */\n      program_name2=SUBSTR(cb2_text,97,8);\n\n      PUT FILE(SYSPRINT) SKIP EDIT(' JOB=',job_name,\n                                   ' STEP=',step_name,\n                                   ' PROCSTEP=',proc_step,\n                                   ' PGM=',program_name,\n                                   ' PGM2=',program_name2,\n                                   ' ',micro_seconds)      (A);\n\n       addr_cb2=cb1(46);                                      /* JSCB */\n       addr_cb2=cb2(66);                                      /* JCT  */\n      job_class=SUBSTR(cb2_text,48,1);\n      msg_class=SUBSTR(cb2_text,23,1);\n\n      four_bytes='00'X || SUBSTR(cb2_text,57,3);\n      addr_cb2=ptr4;                                          /* ACT  */\n      programmer_name=SUBSTR(cb2_text,25,20);\n      four_bytes='000000'X || SUBSTR(cb2_text,49,1);\n      acct1=SUBSTR(cb2_text,50,full_word);\n\n      addr_cb2=cb1(53);                                       /* EXT2 */\n      If SUBSTR(cb2_text,21,4) = '00000000'X THEN             /* CAUF */\n        batch_or_cics='BATCH';\n      Else\n        batch_or_cics='CICS ';\n\n      PUT FILE(SYSPRINT) SKIP EDIT(' ',batch_or_cics,\n                                   ' JNUM=',job_number,\n                                   ' CLASS=',job_class,\n                                   ' MSGCLASS=',msg_class,\n                                   \" PGMR='\",programmer_name,\"'\",\n                                   ' ACCT=',acct1,\n                                                    ' ') (A);\n\n      addr_cb1=ptr0;                                          /* PSA  */\n      addr_cb1=cb1(138);                                      /* ASCB */\n      addr_cb2=cb1(28);                                       /* ASXB */\n      user_id=SUBSTR(cb2_text,193,8);\n      addr_cb2=cb2(51);                                       /* ACEE */\n      group_name=SUBSTR(cb2_text,31,8);\n      addr_cb1=cb2(26);                                       /* UNAM */\n      user_name=SUBSTR(cb1_text,2,20);\n      PUT FILE(SYSPRINT) SKIP EDIT(' USERID=',user_id,\n                                   ' GROUP=',group_name,\n                                   \" USER='\",user_name,\"'\",\n                                                    ' ') (A);\n\n     END PLI2JOB;\n/*\n//PROC2 PROC\n//GO    EXEC PGM=LOADER,PARM=PRINT\n//SYSLIN DD DSN=*.PLI.SYSLIN,DISP=(OLD,DELETE)\n//SYSLIB DD DSN=CEE.SCEELKED,DISP=SHR\n//SYSLOUT DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//CEEDUMP DD SYSOUT=*\n//      PEND\n//*\n//PSTEP1 EXEC PROC2\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PLI2TSO": {"ttr": 15113, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00@\\x00\\x93\\x03\\x8f\\x01\\x066O\\x129\\x00Z\\x00B\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-02-07T00:00:00", "modifydate": "2006-12-30T12:39:40", "lines": 90, "newlines": 66, "modlines": 0, "user": "CBT475"}, "text": "//GILBERTJ JOB (ACCT#),PLI2TSO,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(4,LT)\n//*PLI EXEC PGM=IEL1AA,PARM=(OPTIONS,SOURCE)\n//*STEPLIB DD DSN=IEL111.SIELCOMP,DISP=SHR\n//PLI EXEC PGM=IBMZPLI,PARM=(OPTIONS,SOURCE),REGION=64M\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD UNIT=VIO\n//SYSLIN   DD UNIT=VIO,DISP=(,PASS)\n//SYSIN    DD *\n  /******************************************************************/\n  /*                                                                */\n  /*  MODULE NAME = PLI2TSO                                         */\n  /*                                                                */\n  /*  DESCRIPTIVE NAME = Sample PL/I program to issue a TSO command */\n  /*                                                                */\n  /*  FUNCTION = This sample program demonstrates how to invoke     */\n  /*             TSO commands from a PL/I program using             */\n  /*             standard TSO services as documented in the         */\n  /*             TSO/E Programming Services manual.                 */\n  /*                                                                */\n  /*             Most TSO commands, including CLISTs and REXX       */\n  /*             execs can be executed using this technique.        */\n  /*             TSO commands which require authorization           */\n  /*             (such as OUTPUT, SEND, TRANSMIT and RECEIVE)       */\n  /*             will not work.                                     */\n  /*                                                                */\n  /*  AUTHOR   =  Gilbert Saint-Flour <carlos@gsf-soft.com>         */\n  /*              http://gsf-soft.com/Freeware/                     */\n  /*                                                                */\n  /******************************************************************/\n     PLI2TSO: Procedure Options(MAIN);\n\n       DCL ws_dummy        Fixed Bin(31,0),\n           ws_return_code  Fixed Bin(31,0),\n           ws_reason_code  Fixed Bin(31,0),\n           ws_info_code    Fixed Bin(31,0),\n           ws_cppl_address Fixed Bin(31,0),\n           IKJTSOEV        Entry Options(ASM);\n\n  /*----------------------------------------------------------------*/\n  /*          Call IKJTSOEV to create the TSO/E environment         */\n  /*----------------------------------------------------------------*/\n        Fetch IKJTSOEV;\n         CALL IKJTSOEV(ws_dummy,\n                       ws_return_code,\n                       ws_reason_code,\n                       ws_info_code,\n                       ws_cppl_address);\n         IF ws_return_code > 0 Then Do;\n           DISPLAY ( 'IKJTSOEV Failed, Return_code=' || ws_return_code\n                                  || ' Reason_code=' || ws_reason_code\n                                  || ' Info_code='   || ws_info_code);\n           Call PLIRETC(ws_return_code);\n           Return;\n           END;\n  /*----------------------------------------------------------------*/\n  /*          Build the TSO/E command in ws-buffer                  */\n  /*----------------------------------------------------------------*/\n       DCL ws_buffer       Char(256),\n           ws_length       Fixed Bin(31,0) Init(Length(ws_buffer)),\n           IKJEFTSR        Entry Options(ASM);\n\n         ws_buffer='ALLOCATE DD(MSGDD) SYSOUT HOLD BLKSIZE(80)';\n\n  /*----------------------------------------------------------------*/\n  /*   Call the TSO/E Service Routine to execute the TSO/E command  */\n  /*----------------------------------------------------------------*/\n      Fetch IKJEFTSR;\n       CALL IKJEFTSR('00010001'X,ws_buffer,ws_length,\n                     ws_return_code,ws_reason_code,ws_dummy);\n       IF ws_return_code > 0 Then Do;\n         DISPLAY ('IKJEFTSR Failed, Return_code=' ||\n                ws_return_code || ' Reason_code=' || ws_reason_code);\n         Call PLIRETC(ws_return_code);\n         Return;\n         END;\n  /*----------------------------------------------------------------*/\n  /*          Print that the ALLOCATE command worked                */\n  /*----------------------------------------------------------------*/\n       PUT FILE(MSGDD) SKIP EDIT('Command ALLOCATE Worked ! ') (A);\n     END PLI2TSO;\n/*\n//GO    EXEC PGM=LOADER,PARM=PRINT\n//SYSLIN DD DSN=*.PLI.SYSLIN,DISP=(OLD,DELETE)\n//SYSLIB DD DSN=CEE.SCEELKED,DISP=SHR\n//SYSLOUT DD SYSOUT=*\n//SYSTSPRT DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//CEEDUMP DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RECALL": {"ttr": 15116, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\t\\x00\\x17\\x00\\x882\\x8f\\x01\\x001\\x9f\\x14\\x06\\x023\\x01+\\x01\\x99\\xc3\\xc2\\xe3\\xf4\\xf3\\xf0@@@@'", "ispf": {"version": "02.09", "flags": 0, "createdate": "1988-11-23T00:00:00", "modifydate": "2000-11-14T14:06:17", "lines": 563, "newlines": 299, "modlines": 409, "user": "CBT430"}, "text": "//GILBERTR JOB (ACCT#),RECALL,\n//*RESTART=HMIG,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(1,LT)\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n*PROCESS USING(WARN(8))\n***********************************************************************\n*                                                                     *\n* MODULE NAME = RECALL                                                *\n*                                                                     *\n* DESCRIPTIVE NAME = Data Set RECALL Utility                          *\n*                                                                     *\n* FUNCTION = The \"RECALL\" program recalls migrated data sets          *\n*            that will be used in subsequent steps of the JOB         *\n*            in which it is executed.  Pre-staging data sets          *\n*            in this manner reduces HSM tape mount activity.          *\n*                                                                     *\n* STATUS = R209                                                       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*          http://gsf-soft.com/Freeware/                              *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = MVS/XA, MVS/ESA, OS/390, DFHSM                    *\n*                   STRING macro R400                                 *\n*                                                                     *\n*    AUTHORIZATION = NONE                                             *\n*                                                                     *\n*    RESTRICTIONS = NONE                                              *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (BATCH PROGRAM)                            *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 4K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE 24, AMODE 31,                    *\n*                 PROBLEM STATE, KEY 8                                *\n*                                                                     *\n* OPERATION = See Below                                               *\n*                                                                     *\n*         o  RECALL scans the SWA control blocks of every step        *\n*            of your job for data sets migrated by DFHSM.             *\n*                                                                     *\n*         o  A sub-task is created for each migrated data set;        *\n*            this sub-task issues a LOCATE macro with the             *\n*            CAMHSMRC bit on.                                         *\n*                                                                     *\n*         o  Then, RECALL waits for the sub-tasks to complete         *\n*            and terminates.                                          *\n*                                                                     *\n* RESTRICTIONS                                                        *\n*                                                                     *\n*         RECALL does NOT process the following data sets:            *\n*                                                                     *\n*         o  GDG ALL                                                  *\n*                                                                     *\n* INVOCATION JCL                                                      *\n*                                                                     *\n*            //MYJOB   JOB (ACCT#),'JOHN DOE', . . .                  *\n*            //*                                                      *\n*            //JOBLIB   DD . . . .                                    *\n*            //*                                                      *\n*            //RECALL EXEC PGM=RECALL                                 *\n*            //*                                                      *\n*            //STEP1   EXEC PROC=MYPROC, . . .                        *\n*                                                                     *\n* RETURN CODES                                                        *\n*                                                                     *\n*            Always zero                                              *\n*                                                                     *\n*                                                                     *\n* Messages = RECALL Activity log on DDname $$RECALL                   *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n*   203  New packaging for the CBT tape                               *\n*   204  XCTL to HRECALL if I've been invoked as a TSO command        *\n*   205  Create sub-tasks and use WAIT=YES on ARCHRCAL macros         *\n*   206  Write out messages to //$$RECALL DD                          *\n*   207  Process referback dsnames (VOL=REF, DCB, LIKE)               *\n*        Process generation data sets (GDS)                           *\n*   208  Replace ARCHRCAL with LOCATE macro                           *\n*   209  Use QNAME outside of the DCB to prevent ENQ errors           *\n*                                                                     *\n&REL     SETC  'R209'                                                 *\n***********************************************************************\nRECALL   CSECT\nRECALL   AMODE 31\n         SAVE  (14,12),,'GSF Utilities - RECALL &REL'\n         LR    R12,R15\n         USING RECALL,R12\n*\n*        XCTL to HRECALL if I've been invoked as a TSO command\n*\n         CLI   0(R1),X'80'             invoked as a batch pgm?\n         BE    INIT20                  yes, proceed further\n         XCTL  (2,12),EP=HRECALL       no, exit to HSM HRECALL command\n*\nINIT20   GETMAIN RU,LV=DYNAML,LOC=BELOW,BNDRY=PAGE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LM    R13,R1,8(R13)\n         USING DYNAM,R13\n         MVC   JCLPARM,0(R1)           SAVE THE PARM ADDR\n         GETMAIN RU,LV=8192*L'DSNAME,LOC=ANY\n         ST    R1,TABLE1               save table address\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Set up scan from first step after ours.                      *\n*                                                                     *\n*---------------------------------------------------------------------*\nINIT50   L     R3,540(,0)              MY TCB (PSATOLD-PSA)\n         L     R4,TCBJSCB-TCB(,R3)     MY JSCB\n         USING IEZJSCB,R4\n         L     R5,JSCSCT               CURRENT STEP'S SCT PREFIX\n         USING SCT,R5\n         SLR   R10,R10                 SET RC=00 (NOTHING RECALLED)\n*\n         LM    R14,R1,CAMLST$          MODEL CAMLST\n         LA    R15,DSNAME              Data set name\n         LA    R1,WORK265              WORK AREA\n         STM   R14,R1,CAMLST2          UPDATE CAMLST IN DYNAMIC STRGE\n*\n         IDENTIFY EPLOC=SUB_TASK,ENTRY=SUB_TASK+8\n LR R2,R15\n LOAD EPLOC=SUB_TASK\n***********************************************************************\n*                                                                     *\n*        SCAN SCT/SIOT CHAINS                                         *\n*                                                                     *\n*           1. Select data sets that have DISP=OLD or DISP=MOD        *\n*                                                                     *\n*           2. Checks if the data sets have been migrated by DFHSM    *\n*              (i.e. cataloged on VOL=MIGRAT)                         *\n*                                                                     *\n*           3. Issue an internal HRECALL command for each migrated    *\n*              data set                                               *\n*                                                                     *\n***********************************************************************\n*LOOP\nLOOPSCT  ICM   R1,B'0111',SCTFSIOT     PREFIX OF 1ST SIOT\n         BZ    NEXTSTEP                NO DD STATEMENTS, TRY NEXT SCT\n*--LOOP\nLOOPSIOT BAL   R11,SWAREQ              CONVERT SVA TO 31-BIT ADDRESS\n         LR    R6,R1                   PASS SIOT ADDRESS\n         USING SIOT,R6\n*\n*        process refer-backs (VOL=REF, DCB, LIKE)\n*\nREFBACK  ICM   R0,B'0001',SIOVDSNL     length of VOL=REF dsname\n         BZ    REFBACK2                zero, ignore\n         LH    R1,SIOVDSNT             offset in DSNTABLE\n         SYNCH SCAN_DSNTABLE           extract dsname from DSNT\n         SYNCH PROCESS_DSNAME          process dsname\nREFBACK2 EQU   *\n         ICM   R0,B'0001',SIODDSNL     length of DCB dsname\n         BZ    REFBACK3                zero, ignore\n         LH    R1,SIODSNTE             offset in DSNTABLE\n         SYNCH SCAN_DSNTABLE           extract dsname from DSNT\n         SYNCH PROCESS_DSNAME          process dsname\nREFBACK3 EQU   *\n         ICM   R1,B'1111',SIOTSWB      First SWB\n         BZ    REFBACK4                zero, ignore\n         BAL   R11,SWAREQ              CONVERT SVA TO 31-BIT ADDRESS\n         LR    R7,R1                   PASS JFCB ADDRESS\n         USING SWB,R7\n         MVC   DSNAME,SWBDATA+48       move LIKE dsname\n         SYNCH PROCESS_DSNAME          process dsname\nREFBACK4 EQU   *\n*\n*        process JFCB\n*\n         TM    SCTSBYT3,SCTSOLD+SCTSMOD   DISP=OLD/SHR/MOD ?\n         BZ    NEXTSIOT                NO, JUMP\n         ICM   R1,B'0111',SCTPJFCB     JFCB PREFIX\n         BAL   R11,SWAREQ              CONVERT SVA TO 31-BIT ADDRESS\n         LR    R7,R1                   PASS JFCB ADDRESS\n         USING JFCB,R7\n         TM    JFCBIND2,JFCTEMP        temporary data set?\n         BO    NEXTSIOT                YES, IGNORE\n         CLI   JFCBELNM,C'+'           DSNAME(+1)  ?\n         BE    NEXTSIOT                YES, IGNORE\n         MVC   DSNAME,JFCBDSNM         move data set name\n         CLI   JFCBELNM,C'0'           dsname(0) ?\n         BE    GDS3                    yes, jump\n         CLI   JFCBELNM,C'-'           dsname(-1) ?\n         BNE   GDS4                    no, jump\nGDS3     STRING (JFCBDSNM,,T),'(',(JFCBELNM,,T),')',INTO=DSNAME\n         LOCATE CAMLST2                convert (0) to G0010V00\n         LTR   R15,R15                 IS IT CATALOGED?\n         BNZ   NEXTSIOT                NO, IGNORE\nGDS4     EQU   *\n         SYNCH PROCESS_DSNAME          process dsname\n*\nNEXTSIOT ICM   R1,B'0111',SCTPSIOT     NEXT SIOT'S PREFIX\n         BNZ   LOOPSIOT                PROCESS NEXT DD CARD IN STEP\n*--ENDLOOP\nNEXTSTEP ICM   R5,B'0111',SCTANSCT     NEXT SCT PREFIX\n         BNZ   LOOPSCT                 PROCESS NEXT STEP\n*ENDLOOP\n*\n*        wait for completion of all sub-tasks\n*\n         LTR   R10,R10                 any sub-task attached?\n         BZ    GOBACK                  no, quit\n*\n*        Close/open the DCB to make messages visible in SDSF\n*\n         ENQ   MF=(E,DYNAMENQ)         serialize DCB\n         CLOSE MF=(E,OPENLIST)         CLOSE the DCB\n         OPEN  MF=(E,OPENLIST)         re-open the DCB\n         DEQ   MF=(E,DYNAMENQ)         free DCB\n*\n         WAIT  1,ECB=ECB1              wait for all subtasks to end\n         CLOSE MF=(E,OPENLIST)         CLOSE the DCB\n         FREEPOOL DYNAMDCB             free the buffers\n*\nGOBACK   L     R13,4(,R13)             CALLER'S SAVE AREA\n         RETURN (14,12),RC=0\n***********************************************************************\n*                                                                     *\n*        Process a dsname                                             *\n*                                                                     *\n*        1. eliminate duplicates                                      *\n*        2. retrieve catalog information                              *\n*        3. select migrated data sets                                 *\n*        4. count sub-tasks and issue message                         *\n*        5. attach HRECALL sub-task                                   *\n*                                                                     *\n***********************************************************************\nPROCESS_DSNAME EQU *\n*\n*        check if this dsname has already been processed\n*\nSCANTBL1 L     R1,TABLE1               start of dsn table\n*LOOP\nSCANTBL2 CLI   0(R1),0                 end of table ?\n         BE    SCANTBL8                yes, exit\n         CLC   0(L'DSNAME,R1),DSNAME   dsname already processed?\n         BE    PROCESS9                YES, IGNORE\n         LA    R1,L'DSNAME(,R1)        next entry in TABLE1\n         B     SCANTBL2                check next entry\n*ENDLOOP\nSCANTBL8 MVC   0(L'DSNAME,R1),DSNAME   save dsname address\n         LR    R7,R1                   address of dsname\n*\n*        Retrieve catalog information and select migrated data sets\n*\n         LOCATE CAMLST2                GET VOLSER\n         LTR   R15,R15                 IS IT CATALOGED?\n         BNZ   PROCESS9                NO, IGNORE\n         CLC   =C'MIGRAT',VOLSER       is it archived?\n         BNE   PROCESS9                NO, IGNORE\n*\n         MVI   ML$,C'1'                ML1\n         CLI   DEVTYPE+2,X'20'         ML1?\n         BE    *+8                     yes, jump\n         MVI   ML$,C'2'                no, ML2\n*\n*        Count sub-tasks\n*\nBUMPCNT  L     R1,SUBTASKS             COUNT SUB-TASKS\n         LA    R10,1(,R1)              COUNT SUB-TASKS\n         CS    R1,R10,SUBTASKS         COUNT SUB-TASKS\n         BNZ   BUMPCNT                 try again\n*\n         BAL   R11,OPENDCB             alloc/open message DCB\n*\n*        Issue message\n*\n         ENQ   MF=(E,DYNAMENQ)         serialize DCB\n         STRING 1X,%TIME,'Task ',((R10),,L),                           X\n               ' Recalling ',((R7),L'DSNAME,T),                        X\n               ' from ML',ML$,                                         X\n               INTO=LINE\n         LA    R15,*+6                 switch to AMODE24 for PUT\n         BSM   0,R15                   switch to AMODE24 for PUT\n         PUT   DYNAMDCB,LINE           write message\n         L     R15,=A(*+X'80000006')   switch to AMODE31\n         BSM   0,R15                   switch to AMODE31\n         DEQ   MF=(E,DYNAMENQ)         free DCB\n*---------------------------------------------------------------------*\n*                                                                     *\n*        attach HRECALL sub-task                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n         L     R14,16                  CVTPTR\n         L     R0,8(,R14)              CVTLINK\n         IC    R2,ML$                  mig level\n         LA    R3,ECB1                 point at ECB and SUBTASKS\n         ATTACH EPLOC=SUB_TASK,        attach HRECALL sub-task         X\n               SZERO=YES,              Share sub-pool zero             X\n               TASKLIB=(R0),           LINK-LIST DCB                   X\n               ETXR=ETXR00,            end-of-task exit routine        X\n               SF=(E,ATTACHL)\nPROCESS9 SVC   3                       GOBACK\n***********************************************************************\n*                                                                     *\n*        Extract dsname from DSNT                                     *\n*                                                                     *\n***********************************************************************\nSCAN_DSNTABLE LA R3,255                mask for NR\n         NR    R3,R0                   length of dsname in DSNT\n         LR    R7,R1                   offset to dsn in DSNT\n         ICM   R1,B'0111',SCTADSTB     SVA OF DSNT\n         BZ    SCAN_D99                NO DSNT, EXIT\n*LOOP\nSCAN_D2  BAL   R11,SWAREQ              CONVERT SVA TO 31-BIT ADDRESS\n         USING DSNTABLE,R1\n         SH    R7,=AL2(L'DSNENTRY)     DSNT\n         BM    SCAN_D4                 DSNT\n         ICM   R1,B'0111',DSNTNSVA     SVA OF DSNT\n         BNZ   SCAN_D2                 NO DD CARDS, RETURN\n*ENDLOOP\n         MVI   DSNAME,0                DSN NOT FOUND\n         B     SCAN_D99                EXIT\nSCAN_D4  LA    R2,DSNENTRY+L'DSNENTRY(R7) point at dsname\n         STRING ((R2),(R3)),INTO=DSNAME\nSCAN_D99 SVC   3                       GOBACK\n         DROP  R4,R5,R6,R7,R1          JSCB, SCT, SIOT, JFCB, DSNT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Allocate/OPEN message DCB                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\nOPENDCB  TM    DYNAMDCB+48,X'10'       DCB open already?\n         BOR   R11                     yes, goback\n*\n         LA    R1,DYNAMDCB             WORK AREA FOR DYNALLOC\n         MVI   0(R1),20                LENGTH\n         MVI   1(R1),1                 VERB=ALLOC\n         LA    R0,=A(INIT9901,INIT9902,INIT9918,INIT9952+X'80000000')\n         ST    R0,8(,R1)               S99TUPTR\n         ST    R1,20(,R1)              WORK AREA ADDRESS\n         LA    R1,20(,R1)              S99RBPTR\n         OI    0(R1),X'80'             S99RBPTR\n         DYNALLOC                      ALLOCATE //$$RECALL DD SYSOUT=*\n*\n         MVC   DYNAMDCB,MODELDCB       move model DCB\n         MVC   DYNAMENQ,MODELENQ       move model ENQ\n         LA    R0,DYNAMDCB             build OPEN list\n         ST    R0,OPENLIST             build OPEN list\n         MVI   OPENLIST,X'8F'          build OPEN list\n         OPEN  MF=(E,OPENLIST)         OPEN the DCB\n         STRING '1RECALL Utility &REL',                                X\n               INTO=LINE\n         PUT   DYNAMDCB,LINE           write title line\n         BR    R11\n*\nMODELDCB  DCB  DSORG=PS,MACRF=PM,DDNAME=$$RECALL,RECFM=FBA,LRECL=L'LINE\nMODELDCBL EQU  *-MODELDCB\nMODELENQ  ENQ  ($$RECALL,$$RECALL,E),MF=L\nMODELENQL EQU  *-MODELENQ\nCAMLST$  CAMLST NAME,*-*,,*-*          CAMLST FOR LOCATE MACRO\nFIVESEC  DC    F'500'                  500 1/100th of a second\nINIT9901 DC    AL2(1,1,L'$$RECALL)     DDNAME\n$$RECALL DC    CL8'$$RECALL'           DDNAME\nINIT9902 DC    AL2(2,1,L'$$RECALL2)    DSN=&&$$RECALL\n$$RECALL2 DC   C'&&&&$$RECALL'         DSNAME\nINIT9918 DC    X'0018,0000'            SYSOUT=*\nINIT9952 DC    X'0052,0000'            PERMANENTLY ALLOCATED\n*---------------------------------------------------------------------*\n*                                                                     *\n*        SUB-ROUTINE USED TO ACCESS THE SWA MANAGER                   *\n*                                                                     *\n*---------------------------------------------------------------------*\nSWAREQ   LA    R2,WORK265              WORK AREA\n         ST    R2,EPAPTR               STORE POINTER\n         USING ZB505,R2\n         XC    SWAEPAX,SWAEPAX         CLEAR 32 BYTES\n         STCM  R1,B'0111',SWVA         STORE 3-BYTE SVA\n         SWAREQ FCODE=RL,EPA=EPAPTR,MF=(E,SWAREQL1),UNAUTH=YES\n         L     R1,SWBLKPTR             LOAD SWA CONTROL BLOCK ADDRESS\n         BR    R11\n         DROP  R13\n***********************************************************************\n*                                                                     *\n*        HRECALL sub-task                                             *\n*                                                                     *\n*        1. allocate 24-bit work area                                 *\n*        2. move dsname from TABLE1 to work area                      *\n*        3. issue LOCATE with CAMHSMRC bit on                         *\n*        4. format completion message and write it out                *\n*        5. terminate                                                 *\n*                                                                     *\n***********************************************************************\n         CNOP  0,8\nSUB_TASK DC    C'/HRECALL'\n         ST    R3,0(,R13)              save A(ECB1) for ETXR\n         USING ECB1,R3\n*\n         GETMAIN RU,LV=TASKWORKL       get work area\n         LR    R4,R1                   pass addr of work area\n         USING TASKWORK,R4\n         MVC   TASKDSN,0(R7)           move dsname to 24-bit area\n         STC   R2,TASKML$              same mig lvl\n*\n         LM    R14,R1,CAMLST$          MODEL CAMLST\n         LA    R15,TASKDSN             Data set name\n         LA    R1,TASKW265             WORK AREA\n         STM   R14,R1,TASKCAML         UPDATE CAMLST IN DYNAMIC STRGE\n         OI    CAMOPTN3,CAMHSMRC       HSM RECALL\n         LOCATE TASKCAML               LOCATE/RECALL\n         STM   R15,R0,TASKRETC         return code, reason code\n*\n*        Issue completion message\n*\n         ENQ   MF=(E,DYNAMENQ)         serialize DCB\n         STRING 1X,%TIME,'Task ',((R10),,L),                           X\n               1X,(TASKDSN,,T),' recalled from ML',TASKML$,            X\n               INTO=LINE\n         L     R15,TASKRETC            return code\n         A     R15,TASKRETC+4          reason code\n         BZ    SUBT084                 all zero, jump\n         STRING 1X,%TIME,'Task ',((R10),,L),                           X\n               ' HRECALL failed for ',(TASKDSN,,T),                    X\n               ', RC=',(TASKRETC+2,2,X),',REASON=',(TASKRETC+6,2,X),   X\n               INTO=LINE\n*\nSUBT084  LA    R15,SUBT085             switch to AMODE24 for PUT\n         BSM   0,R15                   switch to AMODE24 for PUT\nSUBT085  PUT   DYNAMDCB,LINE           write message\n         DEQ   MF=(E,DYNAMENQ)         free DCB\n*\n         FREEMAIN RU,LV=TASKWORKL,A=(R4) free work area\n         LR    R15,R6                  return code\n         SVC   3                       exit\n         DROP\n***********************************************************************\n*                                                                     *\n*        End of task exit routine; invoked via an IRB under           *\n*        the main task's TCB.                                         *\n*                                                                     *\n*        1. detach the sub-task                                       *\n*        2. decrement the number of active sub-tasks (SUBTASKS field) *\n*        3. post the main task if the SUBTASKS field is zero          *\n*                                                                     *\n***********************************************************************\nETXR00   L     R13,TCBFSA-TCB(,R1)     point to subtask's FSA\n         L     R12,0(,R13)             get A(ECB1)\n         USING ECB1,R12\n         BALR  R11,0\n         USING *,R11\n         ST    R1,0(,R13)              store TCB address\n         DETACH (R13)                  detach sub-task\n*\n*        decrement sub-task count, post ECB1 if count reaches zero\n*\nETXR21   L     R6,SUBTASKS             sub-task count\n         LR    R7,R6                   sub-task count\n         BCT   R7,ETXR22               decrement, br if not zero\n         POST  ECB1,0                  post ECB1 if R7=0\nETXR22   CS    R6,R7,SUBTASKS          update sub-task count\n         BNE   ETXR21                  do it again\n*\n         SVC   3                       exit\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Dynamic storage (main task)                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\nDYNAM    DSECT\n         DS    18F\nJCLPARM  DS    A                       JCL PARM field\nCAMLST2  CAMLST NAME,DSNAME,,WORK265   CAMLST FOR LOCATE MACRO\nSWAREQL1 SWAREQ MF=L                   PARM LIST FOR SWAREQ\nEPAPTR   DS    F                       POINTER TO EPA (ZB505)\nDSNAME   DS    CL44                    DSNAME\nWORK265  DS    CL265                   LOCATE COMMAND\nDEVTYPE  EQU   WORK265+2,4,C'X'        device type\nVOLSER   EQU   WORK265+6,6,C'C'        volser\nML$      DS    C'1'\nATTACHL  ATTACH SF=L\nOPENLIST OPEN  (DYNAMDCB,OUTPUT),MF=L\n*\n*        data accessible from the sub-task and ETXR exit\n*\nECB1     DS    F                       comm ECB\nSUBTASKS DS    F                       sub-task counter\nDYNAMDCB DS    XL(MODELDCBL)           DCB\nDYNAMENQ DS    XL(MODELENQL)           ENQ list\nLINE     DS    CL80                    print line\n*\nTABLE1   DS    A(DSNAME)               data sets already processed\n*\nDYNAML   EQU   *-DYNAM\n*---------------------------------------------------------------------*\n*                                                                     *\n*        SUB-TASK WORK AREA                                           *\n*                                                                     *\n*---------------------------------------------------------------------*\nTASKWORK DSECT\nTASKDSN  DS    CL44                    dsname\nTASKML$  DS    C                       ML1/ML2\nTASKRETC DS    F,F                     return code, reason code\nTASKW265 DS    XL265                   LOCATE work area\nTASKCAML CAMLST NAME,TASKDSN,,TASKW265 CAMLST FOR LOCATE MACRO\nCAMOPTN3 EQU   TASKCAML+2,1,C'X'       THIRD OPTION BYTE\nCAMHSMRC EQU   X'20'                   HSM RECALL\nTASKWORKL EQU  *-TASKWORK\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DSECTS FOR VARIOUS MVS CONTROL BLOCKS                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         PRINT NOGEN\nPRINT    OPSYN ANOP\n         IKJTCB LIST=NO                SYS1.MODGEN\n         IEZJSCB                       SYS1.MODGEN\nSCT      DSECT                         Step Control Table\n         DS    XL16                    PREFIX\n         IEFASCTB                      SYS1.MODGEN\n         IEFDSNT                       SYS1.MODGEN\nSIOT     DSECT                         Step I/O Table\n         IEFASIOT                      SYS1.MODGEN\nJFCB     DSECT                         Job File Control Block\n         IEFJFCBN                      SYS1.MODGEN\n         IEFSWB                        SYS1.MODGEN\n         CVT   LIST=NO,DSECT=YES       COMMUNICATION VECTOR TABLE\n         IEFZB505 LOCEPAX=YES          EPA MAPPING FOR SWAREQ\n         IEFJESCT TYPE=DSECT           JES CONTROL TABLE\n         YREGS                         SYS1.MACLIB\n         STRING GENERATE\n         END   RECALL\n//SYSLIB   DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=CBTTAPE.FILE183.PDS,DISP=SHR    STRING\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//LKED    EXEC PGM=IEWL,PARM=(MAP,RENT)\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=CBTTAPE.FILE183.LOAD(RECALL),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//*\n//GO      EXEC PGM=RECALL\n//STEPLIB  DD DSN=*.LKED.SYSLMOD,DISP=SHR\n//SYSDEBUG DD SYSOUT=*\n//ABNLIGNR DD DUMMY\n//SYSUDUMP DD SYSOUT=*\n//*\n//STEP99 EXEC PGM=IEFBR14,COND=(99,NE)\n//DD1 DD    LIKE=GILBERT.XREF32.DJCLIPT\n//    DD VOL=REF=GILBERT.XREF32.DJCLRDR,\n//           DCB=GILBERT.XREF32.DJCLSET\n//DD2 DD    LIKE=GILBERT.XREF32.DASMMAC\n//    DD VOL=REF=GILBERT.XREF32.DASMMOD,\n//           DCB=GILBERT.XREF32.DASMCOP\n//TAPEOUT DD DSN=GILBERT.RECALL1,DISP=(MOD,CATLG),\n// UNIT=VIO,SPACE=(TRK,1)\n//TAPEOUT DD DCB=GILBERT.RECALL2,\n// UNIT=VIO,SPACE=(TRK,1)\n//*\n//HMIG    EXEC PGM=IKJEFT01,COND=EVEN\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\nHMIG 'GILBERT.RECALL1' WAIT\nHMIG 'GILBERT.RECALL2' WAIT\nHMIG 'GILBERT.XREF32.*' WAIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RESET5": {"ttr": 15369, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x906_\\x00\\x93\\x15O\\x104\\x00/\\x00*\\x00\\x00\\xc3\\xc2\\xe3\\xf3\\xf4\\xf3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-12-31T00:00:00", "modifydate": "1993-06-03T10:34:00", "lines": 47, "newlines": 42, "modlines": 0, "user": "CBT343"}, "text": "//GILBERTR JOB (ACCT#),RESET5,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//ASMH EXEC PGM=IEV90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n*        \"RESET\" PROGRAM TO BE USED AS AN EDIT MACRO                  *\n*                                                                     *\n***********************************************************************\nRESET5   CSECT\nRESET5   RMODE ANY\n         BALR  R14,0                   LOCAL BASE\n         USING *,R14\n         LA    R0,=C'ISPEXEC '         ISREDIT INTERFACE\n         LOAD  EPLOC=(0)               GET ITS ADDRESS\n         ST    R0,00(,R13)             AND SAVE IT\n*  ISREDIT MACRO\n         L     R15,00(,R13)            V(ISPEXEC)\n         LA    R1,=A(F13,ISREDIT1+VL)  ISREDIT MACRO\n         BALR  R14,R15                 EXECUTE FUNCTION\n         USING *,R14\n*  ISREDIT RESET\n         L     R15,00(,R13)            V(ISPEXEC)\n         LA    R1,=A(F13,ISREDIT2+VL)  ISREDIT RESET\n         BALR  R14,R15                 EXECUTE FUNCTION\n         USING *,R14\n*  PIN LOAD MODULE\n         LA    R0,=C'RESET   '         MY OWN NAME\n         LOAD  EPLOC=(0)               INCREASE USE COUNT\n*  RETURN TO SYSTEM\n         SLR   R15,R15                 RETURN CODE\n         SVC   3                       GOBACK WITH RC=00\nISREDIT1 DC    C'ISREDIT MACRO'\nISREDIT2 DC    C'ISREDIT RESET'\nF13      DC    AL4(L'ISREDIT1)         LENGTH\nVL       EQU   X'80000000'\n         YREGS                         SYS1.MACLIB\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//LKED    EXEC PGM=HEWL,PARM='MAP,RENT'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,DELETE)\n//SYSLMOD  DD DSN=SYS1.P390.LINKLIB(RESET),DISP=SHR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXXTRY": {"ttr": 15371, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00@\\x00\\x91\\x06?\\x01\\t%\\x8f\\x15U\\x02\\x1c\\x01O\\x01\\x04\\xc3\\xc2\\xe3\\xf4\\xf7\\xf8@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1991-03-04T00:00:00", "modifydate": "2009-09-15T15:55:40", "lines": 540, "newlines": 335, "modlines": 260, "user": "CBT478"}, "text": "//GILBERTR JOB (ACCT#),REXXTRY,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(1,LT)\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n*            COPYRIGHT (C) 1991-2009 GILBERT SAINT-FLOUR              *\n*                       ALL RIGHTS RESERVED                           *\n*                                                                     *\n* MODULE NAME = REXXTRY                                               *\n*                                                                     *\n* DESCRIPTIVE NAME = Execute a line of REXX code and set &result      *\n*                                                                     *\n* STATUS = R104                                                       *\n*                                                                     *\n* FUNCTION = This TSO command processor can be used to execute a      *\n*            one-line REXX exec as a sub-routine. The REXX exec,      *\n*            which can be a single REXX instruction or multiple       *\n*            instructions separated by semi-colons, must be           *\n*            specified as an argument in the REXXTRY command,         *\n*            for example:                                             *\n*                                                                     *\n*               REXXTRY a='A'; b='B'; RETURN a || b                   *\n*                                                                     *\n*            REXXTRY can be invoked anywhere a TSO command can be     *\n*            entered: READY prompt, PDF opt 6, ISPF TSO command,      *\n*            CLIST, ISPF panel, ISPF command table, etc.              *\n*                                                                     *\n*            If the REXX exec ends with a RETURN instruction (as      *\n*            shown in the example above), the returned value is       *\n*            stored into the &RESULT variable.  The length of the     *\n*            data returned by the exec is limited to 256 bytes.       *\n*                                                                     *\n*            In the ISPF environment, if the REXX exec needs to       *\n*            access ISPF variables using VGET and VPUT, REXXTRY       *\n*            must be invoked with LANG(CREX).  However, specifying    *\n*            LANG(CREX) prevents REXXTRY from storing the data        *\n*            returned by the REXX exec into &RESULT.  Consequently,   *\n*            the REXX exec must be designed to use RETURN or          *\n*            VGET/VPUT, but not both.  This restriction is imposed    *\n*            by the method ISPF uses to handle variables in the       *\n*            compiled REXX environment.                               *\n*                                                                     *\n*            REXXTRY can also be invoked in batch mode, in which      *\n*            case the REXX code is (1) an argument to the command,\n*            or (2) all the input lines present in SYSTSIN after      *\n*            the REXXTRY command.                                     *\n*                                                                     *\n*            Note that in batch mode, REXXTRY invokes the REXX        *\n*            code as a command and does not set &RESULT.              *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*          http://gsf-soft.com/Freeware/                              *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*    DEPENDENCIES: MVS/ESA, OS/390 or z/OS                            *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (CSECT TYPE)                               *\n*                                                                     *\n*    PROCESSOR = IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 2K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE ANY, AMODE 31,                   *\n*                 PROBLEM STATE, KEY 8                                *\n*                 APF AUTHORIZATION: NONE                             *\n*                                                                     *\n* OPERATION = See Examples below:                                     *\n*                                                                     *\n*   Invocation in a CLIST:                                            *\n*                                                                     *\n*     SET string = ABC DEF GHI JKL                                    *\n*     REXXTRY parm=\"&string\"; +                                       *\n*             n=WORDS(parm); +                                        *\n*             RETURN WORD(parm,n)                                     *\n*     WRITE LASTCC=&LASTCC RESULT=&RESULT                             *\n*                                                                     *\n*   Invocation in an ISPF Panel; the REXX code ends with RETURN:      *\n*                                                                     *\n*     %RESULT=&result                                                 *\n*     )INIT                                                           *\n*       IF (&result=&Z) &result=0                                     *\n*     )PROC                                                           *\n*       &ZSEL='CMD(REXXTRY RETURN &result+1) MODE(FSCR)'              *\n*     )END                                                            *\n*                                                                     *\n*   Invocation in an ISPF Panel; the REXX code uses VGET and VPUT:    *\n*                                                                     *\n*     %RESULT=&result                                                 *\n*     )INIT                                                           *\n*       IF (&result=&Z) &result=0                                     *\n*     )PROC                                                           *\n*       &rexx='\"VGET result\"; result=&result+1; \"VPUT result\"'        *\n*       &ZSEL='CMD(REXXTRY ADDRESS ISPEXEC; &rexx) LANG(CREX)'        *\n*     )END                                                            *\n*                                                                     *\n*   Invocation in BATCH mode.                                         *\n*                                                                     *\n*     //TMP     EXEC PGM=IKJEFT01                                     *\n*     //SYSTSPRT DD SYSOUT=*                                          *\n*     //SYSTSIN  DD *                                                 *\n*     REXXTRY                                                         *\n*     SAY \"this is my REXX exec (line 1)\"                             *\n*     SAY \"this is my REXX exec (line 2)\"                             *\n*     EXIT 3                                                          *\n*                                                                     *\n*   BATCH mode - execute an in-line CLIST which uses REXXTRY          *\n*                to execute an in-line REXX exec                      *\n*                                                                     *\n*     //CLISTRX EXEC PGM=IKJEFT01                                     *\n*     //STEPLIB  DD DSN=CBTTAPE.FILE183.LOAD,DISP=SHR    REXXTRY      *\n*     //SYSPROC  DD DSN=CBTTAPE.FILE183.PDS,DISP=SHR     EXECUTE      *\n*     //SYSTSPRT DD SYSOUT=*                                          *\n*     //SYSTSIN  DD *                                                 *\n*     %EXECUTE CLIST                                                  *\n*       /* The CLIST starts here */                                   *\n*     CONTROL LIST CONLIST                              /*CLIST*/     *\n*     WRITE Start of the CLIST                          /*CLIST*/     *\n*     REXXTRY A=1;                                      /*REXX*/ +    *\n*             B=2;                                      /*REXX*/ +    *\n*             UID=USERID();                             /*REXX*/ +    *\n*             RETURN(A+B UID)                           /*REXX*/      *\n*     WRITE LASTCC=&LASTCC RESULT='&RESULT'             /*CLIST*/     *\n*     EXIT CODE(&LASTCC)                                /*CLIST*/     *\n*                                                                     *\n*   Invocation via a CALL command                                     *\n*                                                                     *\n*     //VIACALL EXEC PGM=IKJEFT01                                     *\n*     //SYSTSPRT DD SYSOUT=*                                          *\n*     //SYSTSIN  DD *                                                 *\n*     CALL 'CBTTAPE.FILE183.LOAD(REXXTRY)' 'SAY XXX; SAY YYY'         *\n*     /*                                                              *\n*     //VIACALL2 EXEC PGM=IKJEFT01                                    *\n*     //SYSTSPRT DD SYSOUT=*                                          *\n*     //SYSTSIN  DD *                                                 *\n*     CALL 'CBTTAPE.FILE183.LOAD(REXXTRY)'                            *\n*     SAY XXX                                                         *\n*     SAY YYY                                                         *\n*     /*                                                              *\n*                                                                     *\n* PARAMETERS = None                                                   *\n*                                                                     *\n* ABENDS = SEE BELOW                                                  *\n*                                                                     *\n*        U0020       PARM missing in CALL *(REXXTRY) in TSO On-Line   *\n*                                                                     *\n* RETURN-CODES = SEE BELOW                                            *\n*                                                                     *\n*        nnn         Return-code nnn from the REXX interpreter        *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n* 100 Packaging for distribution on CBT Tape                     1998 *\n* 101 In BATCH mode, REXXTRY reads REXX code from SYSTSIN        1999 *\n* 102 CALL FILE183.LOAD(REXXTRY) 'SAY XXX; SAY YYY'              2009 *\n* 103 CALL FILE183.LOAD(REXXTRY) /* read SYSTSIN */                   *\n* 104 Quit if there is no cmd and we're not in TSO/Batch              *\n*                                                                     *\n&REL     SETC  'R104'                                                 *\n***********************************************************************\nREXXTRY  CSECT\nREXXTRY  RMODE ANY\n&D       SETC  '&SYSDATE'(7,2)'-'.'&SYSDATE'(1,2)'-'.'&SYSDATE'(4,2)\n         SAVE  (14,12),,'GSF Utilities - REXXTRY &REL - 20&D &SYSTIME'\n         LR    R12,R15\n         USING REXXTRY,R12\n*\n*        Initialization\n*\n         GETMAIN R,LV=DYNAML           GET DYNAMIC STORAGE\n         ST    R13,4(,R1)              chain save areas\n         ST    R1,8(,R13)              chain save areas\n         LM    R13,R1,8(R13)           load R13, reload R1\n         USING DYNAM,R13\n         XC    DYNAM+72(256),DYNAM+72  CLEAR DYNAMIC STORAGE\n         MVC   DYNCPPL(16),0(R1)       A(CPPL)\n         USING CPPL,DYNCPPL\n         L     R10,CVTPTR(,0)          CVT ADDRESS\n         L     R10,CVTTVT-CVTMAP(,R10) TSO/E VECTOR TABLE\n         USING TSVT,R10\n         L     R9,CPPLECT              pick up ECT address\n         USING ECT,R9\n*\n*        BUILD CPPL IF INVOKED VIA CALL\n*\n         TM    CPPL,X'80'              CPPL or PARM ?\n         BZ    STEP2                   CPPL, jump\n         L     R1,X'0224'(,0)          PSAAOLD   A(ASCB)\n         L     R1,X'006C'(,R1)         ASCBASXB  A(ASXB)\n         L     R1,X'0014'(,R1)         ASXBLWA   A(LWA)\n         L     R9,X'0020'(,R1)         LWAPECT   A(ECT)\n         ST    R9,CPPLECT              Store ECT address\n         L     R1,X'0018'(,R1)         LWAPSCB   A(PSCB)\n         ST    R1,CPPLPSCB             A(PSCB)\n         MVC   CPPLUPT,X'0034'(R1)     PSCBUPT   A(UPT)\n         L     R2,CPPLCBUF             addr of command buffer\n         LA    R4,2(,R2)               R4: first byte of REXX code\n         LH    R5,0(,R2)               R5: length of REXX code\n         LTR   R5,R5                   PARM specified?\n         BNZ   STEP25                  YES, process PARM\n*\n*        CALL *(REXXTRY) with no PARM only works in batch\n*\n         TM    ECTSWS,ECTBKGRD         Running in a batch job?\n         BO    STEP4                   YES, read SYSTSIN\n         ABEND 0020                    NO, ABEND U0020\n*\n*        Build address/length array\n*\nSTEP2    L     R2,CPPLCBUF             addr of command buffer\n         LH    R3,0(,R2)               length of command buffer\n         LA    R4,4(,R2)               addr of REXXTRY command\n         AH    R4,2(,R2)               R4: first byte of REXX code\n         LA    R5,0(R3,R2)             end of command buffer\n         SR    R5,R4                   R5: length of REXX code\n         BZ    STEP4                   no REXX code, use GETLINE\nSTEP25   EQU   *\n         CLC   =C'/*',0(R4)            just a comment?\n         BNE   STEP5                   no, use REXX code\n*\n*        Read REXX statements from SYSTSIN\n*\n         USING IOPL,DYNIOPL            SET UP ADDRESSABILITY TO IOPL\nSTEP4    MVC   IOPLUPT,CPPLUPT         MOVE UPT ADDRESS INTO IOPL\n         ST    R9,IOPLECT              store ECT address into IOPL\n         LA    R0,DYNECB               EVENT CONTROL BLOCK\n         ST    R0,IOPLECB              STORE ECB INTO IOPL\n         USING GTPB,DYNGTPB\n*\n*        if I'm not in TSO/Batch, display hdr and quit with rc=20\n*\n         TM    ECTSWS,ECTBKGRD         Running in a batch job?\n         BO    STEP4D                  YES, read SYSTSIN\n         SLR   R6,R6\n         IC    R6,REXXTRY+4            hdr length\n         MVC   VECTORS(64),REXXTRY+5   copy hdr to R24 for TPUT\n         TPUT  VECTORS,(R6)            Issue error message\n         LA    R6,20                   RC=20\n         B     STEP9                   QUIT\n*\nSTEP4D   EQU   *\n         LA    R5,VECTORS              FIRST VECTOR\n         TM    ECTSWS,ECTBKGRD         Running in a batch job?\n*LOOP\nSTEP4G   MVI   DYNECB,0                RESET POST BIT\n         GETLINE INPUT=ISTACK,         READ FROM STACK                 X\n               TERMGET=(EDIT,WAIT),                                    X\n               PARM=GTPB,                                              X\n               MF=(E,IOPL)\n         CH    R15,=H'16'              EOD?\n         BE    STEP4X                  YES, EXIT\n         TM    ECTSWS,ECTLOGF          EOD?\n         BO    STEP4X                  YES, EXIT\n         L     R2,GTPBIBUF             INPUT BUFFER\n         LH    R3,0(,R2)               LENGTH\n         LA    R2,4(,R2)               POINT PAST LENGTH\n         SH    R3,=H'4'                SUBTRACT LENGTH\n         STM   R2,R3,0(R5)             STORE ADDRESS, LENGTH\n         LA    R5,8(,R5)               NEXT VECTOR\n         B     STEP4G\n*ENDLOOP\nSTEP4X   LR    R0,R5                   addr/len array\n         MVI   IRXFLAGS,X'80'          invoke as a command\n         B     STEP6\n         DROP  R9                      ECT\n*\n*        Execute REXX code specified in the command\n*\nSTEP5    STM   R4,R5,VECTORS           build addr/len array\n         LA    R0,VECTORS+4*2          addr/len array\n         MVI   IRXFLAGS,X'40'          invoke as an external function\n*\n*        Execute the REXX code as a sub-routine\n*\nSTEP6    LA    R1,VECTORS              first vector in R1\n         SLR   R0,R1                   calc length of vectors\n         BAL   R14,RUNEXEC          <- Run the EXEC\n         LR    R6,R15                  save return code\n*\n*        Set the TSO/E and ISPF variables\n*\nSTEP7    CLI   IRXFLAGS,X'80'          exec invoked as a command?\n         BE    STEP9                   yes, skip SETVAR\n ORG STEP7\n         BAL   R14,SETVAR           <- SET VARIABLE\n         SLR   R6,R6                   RC=0\n*\n*        Clean up and exit\n*\nSTEP9    LR    R1,R13                  ADDRESS OF DYNAMIC AREA\n         L     R13,4(,R13)             CALLER'S SAVE AREA\n         FREEMAIN R,LV=DYNAML,A=(1)    FREE DYNAMIC AREA\n         LR    R15,R6                  PASS RETURN CODE\n         RETURN (14,12),RC=(15)        GOBACK, PASS RC IN R15\n***********************************************************************\n*                                                                     *\n*        Execute the in-storage REXX exec as a sub-routine.           *\n*                                                                     *\n***********************************************************************\nRUNEXEC  BAKR  R14,0                   Save Registers\n*\n*        Build the In-storage block (INSTBLK)\n*\n         LA    R6,DYNAM_INSTBLK_HEADER ADDR OF IN-STORAGE BLOCK\n         USING INSTBLK_HEADER,R6\n         ST    R6,PTR_INSTBLK          ADDR OF IN-STORAGE BLOCK\n         ST    R1,INSTBLK_ADDRESS      STORE INTO IN-STORAGE BLOCK\n         ST    R0,INSTBLK_USEDLEN      STORE INTO IN-STORAGE BLOCK\n         MVC   INSTBLK_ACRONYM,=C'IRXINSTB'\n         MVC   INSTBLK_HDRLEN,=A(L'INSTBLK_HEADER)\n         MVC   INSTBLK_MEMBER,=CL8' '\n         MVC   INSTBLK_DDNAME,=C'SYSIN   '\n         MVC   INSTBLK_SUBCOM,=CL8' '\n*\n*        Build the Evaluation Block (EVALBLOCK)\n*\n         LA    R7,DYNAM_EVALBLOCK      ADDR OF EVAL BLOCK\n         USING EVALBLOCK,R7\n         ST    R7,PTR_EVALBLOCK        ADDR OF EXEC BLOCK\n         LA    R0,EVALBLOCK_LENGTH/8   LENGTH IN DOUBLE-WORDS\n         ST    R0,EVALBLOCK_EVSIZE     LENGTH IN DOUBLE-WORDS\n         LA    R0,DATA_LENGTH          LENGTH OF DATA IN BYTES\n         ST    R0,EVALBLOCK_EVLEN      LENGTH OF DATA IN BYTES\n*\n*        Invoke the REXX Interpreter (IRXEXEC)\n*\n         LA    R14,DUMMY               no EXEC block\n         SLR   R15,R15                 no arguments\n         LA    R0,IRXFLAGS             flags for IRXEXEC\n         LA    R1,PTR_INSTBLK          IN-STORAGE BLOCK\n         LA    R2,DUMMY                CPPL\n         LA    R3,PTR_EVALBLOCK        EVAL BLOCK\n         LA    R4,DUMMY                WORK AREA\n         LA    R5,DUMMY                USER WORK AREA\n         STM   R14,R5,PARMLIST         build parm list\n         OI    PARMLIST+28,X'80'       eol flag\n         L     R15,TSVTEXE             A(IRXEXEC)\n         LA    R1,PARMLIST             PARM LIST ADDRESS\n         SYNCH (R15)                <- CALL IRXEXEC\n*\n*        Check the completion-code from the REXX interpreter\n*\n         LTR   R15,R15                 check return code\n         BNZ   RUNEXEC9                non-zero, exit\n*\n*        Retrieve the data returned by the REXX EXEC\n*\n         LA    R1,EVALBLOCK_EVDATA     data passed in the RETURN instr\n         L     R2,EVALBLOCK_EVLEN      length of the returned data\n         STM   R1,R2,VARVALUE          store address and length\n*\n*        If the in-line exec was invoked as a command,\n*        use the returned value as REXXTRY's return-code\n*\n         LTR   R2,R2                   anything returned?\n         BNP   RUNEXEC9                no, exit\n         CLI   IRXFLAGS,X'80'          exec invoked as a command?\n         BNE   RUNEXEC9                no, exit\n         BCTR  R2,0                    for EX\n         PACK  DWD,0(*-*,R1)           PACK VALUE\n         EX    R2,*-6                  PACK VALUE\n         CVB   R15,DWD                 get rc in R15\n*\nRUNEXEC9 PR                            Restore registers, go back\n         DROP  R6,R7                   INSTBLK,EVALBLK\n***********************************************************************\n*                                                                     *\n*        Set ISPF and TSO/E variables                                 *\n*                                                                     *\n***********************************************************************\nSETVAR   BAKR  R14,0                   Save Registers\n*\n*        Invoke ISPLINK to VREPLACE/VPUT the ISPF variable\n*\n         ICM   R15,B'1111',=V(ISPQRY)  ISPF SERVICES AVAILABLE?\n         BZ    SETVAR60                NO, QUIT\n         BALR  R14,R15              <- CALL ISPQRY\n         LTR   R15,R15                 ISPF SERVICES AVAILABLE?\n         BNZ   SETVAR60                NO, QUIT\n* ISPEXEC CONTROL ERRORS RETURN\n         LA    R1,=A(SETVAR54,SETVAR55+X'80000000')\n         L     R15,=V(ISPEXEC)         EXEC INTERFACE\n         BALR  R14,R15              <- CALL ISPEXEC\n* ISPLINK VREPLACE RESULT LENGTH DATA\nSETVAR40 LA    R14,=C'VREPLACE'        SERVICE\n         L     R15,VARNAME+0           VARIABLE NAME\n         LA    R0,VARVALUE+4           VALUE LENGTH\n         L     R1,VARVALUE+0           ADDR OF VARIABLE VALUE\n         STM   R14,R1,PARMLIST         STORE PARM LIST\n         OI    PARMLIST+12,X'80'       MARK END OF LIST\n         LA    R1,PARMLIST             PARM LIST ADDRESS\n         L     R15,=V(ISPLINK)         ISPF SERVICES\n         BALR  R14,R15              <- CALL ISPLINK\n         LTR   R15,R15                 If VREPLACE fails, it's probably\n         BNZ   SETVAR90                because of LANG(CREX).\n* ISPEXEC VPUT RESULT SHARED\n         LA    R1,=A(SETVAR56,SETVAR57+X'80000000')\n         L     R15,=V(ISPEXEC)         EXEC INTERFACE\n         BALR  R14,R15              <- CALL ISPEXEC\n*\n*        Invoke IKJCT441 to replace/create the &RESULT variable\n*\nSETVAR60 LA    R14,=A(TSVEUPDT)        CT441 FUNCTION\n         LA    R15,VARNAME+0           POINTER TO VARIABLE NAME\n         LA    R0,VARNAME+4            LENGTH OF VARIABLE NAME\n         LA    R1,VARVALUE+0           POINTER TO VARIABLE VALUE\n         LA    R2,VARVALUE+4           LENGTH OF VARIABLE VALUE\n         SLR   R3,R3                   null token\n         STM   R14,R3,PARMLIST         STORE PARAMETER LIST\n         OI    PARMLIST+20,X'80'       MARK END OF LIST\n         L     R15,TSVTVACC            A(IKJCT441)\n         LA    R1,PARMLIST             PARM LIST ADDRESS\n         SYNCH (R15)                <- CALL IKJCT441\nSETVAR90 PR                            Restore registers, go back\n***********************************************************************\n*        Constants                                                    *\n***********************************************************************\n         CNOP  0,4\nVARNAME  DC    A(SETVAR57+5,6)         ADDR/LEN OF VARIABLE NAME\nSETVAR54 DC    A(L'SETVAR55)           LENGTH\nSETVAR56 DC    A(L'SETVAR57)           LENGTH\nSETVAR55 DC    C'CONTROL ERRORS RETURN'\nSETVAR57 DC    C'VPUT RESULT SHARED'\n***********************************************************************\n*        Dynamic Storage                                              *\n***********************************************************************\nDYNAM    DSECT\n         DS    18F                     standard save area\nDWD      DS    D                       work area\nVARVALUE DS    A,F                     addr/len (variable value)\nPARMLIST DS    8A                      parm list\nIRXFLAGS DS    X'40000000'             flags for IRXEXEC\nDUMMY    DS    F                       Dummy parm for IRXEXEC\nDYNECB   DS    F                       ECB FOR IKJPARS\nDYNCPPL  DS    4F                      CPPL if invoked via CALL\nDYNIOPL  DS    XL(IOPL_LENGTH)\nDYNGTPB  DS    XL(GTPB_LENGTH)\nPTR_INSTBLK DS A(DYNAM_INSTBLK_HEADER)\nDYNAM_INSTBLK_HEADER DS XL(L'INSTBLK_HEADER)\nPTR_EVALBLOCK DS A(DYNAM_EVALBLOCK)\nDYNAM_EVALBLOCK DS XL(EVALBLOCK_LENGTH)\nVECTORS  DS    4096A(0,0)              4096 addr/len pairs\nDYNAML   EQU   *-DYNAM                 LENGTH OF WORK AREA\n***********************************************************************\n*        Control block definitions (DSECTs)                           *\n***********************************************************************\n         IKJCPPL\n         IKJECT\n         IKJIOPL                       I/O ROUTINES\nIOPL_LENGTH EQU *-IOPL\n         IKJGTPB                       GETLINE\nGTPB_LENGTH EQU *-GTPB\n         IRXINSTB                      IN-STORAGE BLOCK\n         IRXEVALB                      EVALUATION BLOCK\nDATA_LENGTH EQU 256                    256 bytes of data\n         ORG   EVALBLOCK_EVDATA+DATA_LENGTH\nEVALBLOCK_LENGTH EQU *-EVALBLOCK\n         PRINT NOGEN\nPRINT    OPSYN ANOP\n         CVT   DSECT=YES,LIST=NO\n         IKJTSVT\n         YREGS\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//LKED    EXEC PGM=HEWL,PARM=(MAP,RENT)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSLIB   DD DSN=ISP.SISPLOAD(ISPLINK),DISP=SHR\n//SYSLMOD  DD DSN=GILBERT.FILE183.LOAD(REXXTRY),DISP=SHR\n//*\n//GO      EXEC PGM=IKJEFT01\n//SYSTSPRT DD SYSOUT=*\n//SYSSNAP  DD SYSOUT=*\n//SYSTSIN  DD *\nTSOLIB ACT DS('GILBERT.FILE183.LOAD')\nCALL *(REXXTRY) 'SAY XXX; SAY YYY'\nEXEC 'GILBERT.FILE183.PDS(EXECUTE)'\nCONTROL LIST ASIS\nSET string = ABC DEF GHI JKL\n /* format #1: REXXTRY receives a long REXX line as an argument */\nREXXTRY TRACE 'R'; +\n        parm='&string'; +\n        n=WORDS(parm); +\n        RETURN WORD(parm,n)\nWRITE LASTCC=&LASTCC RESULT=&RESULT\n /* format #2: REXXTRY reads REXX code from the rest of the CLIST */\nREXXTRY           /* add your comment here\n  DATA\n    TRACE 'R'\n    parm='&string'\n    n=WORDS(parm)\n    SAY WORD(parm,n)\n    RETURN 1\n    /*\n    EXIT 003\n    */\n  ENDDATA\nWRITE this stmt executes after the last REXXTRY\nWRITE RESULT=&RESULT\n/*\n//GO2     EXEC PGM=IKJEFT01\n//SYSTSPRT DD SYSOUT=*\n//SYSSNAP  DD SYSOUT=*\n//SYSTSIN  DD *\nTSOLIB ACT DS('GILBERT.FILE183.LOAD')\nCALL *(REXXTRY)\nSAY XXX\nSAY YYY\n//\n//\n//*\n//GO1     EXEC PGM=IKJEFT01\n//SYSUT2   DD DSN=&&TEMPPDS(REXXEXEC),UNIT=VIO,SPACE=(TRK,(1,,1))\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//SYSEXEC  DD DSN=&&TEMPPDS,VOL=REF=*.SYSUT2,DISP=(OLD,DELETE)\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\nCALL *(IEBGENER)\n%REXXEXEC\n//*\n//SYSUT1   DD *\nSAY 'Hello!'\n//*\n//GO2     EXEC PGM=IKJEFT01,PARM='%EXECUTE EXEC'\n//SYSPROC  DD DSN=GILBERT.FILE183.PDS,DISP=SHR\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\nSAY 'Hello!'\n//*\n//GO3     EXEC PGM=IKJEFT01,PARM=REXXTRY\n//STEPLIB  DD DSN=GILBERT.FILE183.LOAD,DISP=SHR\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\nSAY 'Hello!'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ROUTE": {"ttr": 15624, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x16\\x00'\\x00\\x88\\x13O\\x01\\x030/\\x10V\\x02\\xe9\\x007\\x02#\\xc3\\xc2\\xe3\\xf4\\xf5\\xf5@@@@\"", "ispf": {"version": "06.22", "flags": 0, "createdate": "1988-05-13T00:00:00", "modifydate": "2003-10-29T10:56:27", "lines": 745, "newlines": 55, "modlines": 547, "user": "CBT455"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* MODULE NAME = ROUTE                                                */\n/*                                                                    */\n/* DESCRIPTIVE NAME = ROUTE EDIT Macro for ISPF/PDF                   */\n/*                                                                    */\n/* STATUS = R622                                                      */\n/*                                                                    */\n/* FUNCTION = The ROUTE EDIT macro is used to obtain hard copy of     */\n/*            the data currently being edited.  It is useful to       */\n/*            print data that does not exist on disk in a printable   */\n/*            form, such as packed data, data modified during the     */\n/*            current EDIT session, or data only accessible via the   */\n/*            EDIT Interface (EDIF).                                  */\n/*                                                                    */\n/* AUTHOR   =  Gilbert Saint-Flour <carlos@gsf-soft.com>              */\n/*             http://gsf-soft.com/Freeware/                          */\n/*                                                                    */\n/* Dependencies = TSO/E V2                                            */\n/*                ISPF/PDF V3 or ISPF V4                              */\n/*                ROUTEPGM program R603 (optional)                    */\n/*                Printer Default Attribute Table (must be customized)*/\n/*                                                                    */\n/* SYNTAX   =  ROUTE                                                  */\n/*                 dest                  Destination                  */\n/*                 first                 First line       .A          */\n/*                 last                  Last line        .B          */\n/*                 CCHAR                 Data contains carriage       */\n/*                                       control characters           */\n/*                 CLASS(class)          Class                        */\n/*                 COPIES(copies)        Number of copies             */\n/*                 DEST(dest)            Destination (alt)            */\n/*                 FCB(FCB-name)         Name of the FCB              */\n/*                 FORMS(forms-number)   Forms number                 */\n/*                 HOLD/NOHOLD           HOLD/NOHOLD                  */\n/*                 TITLE|NOTITLE         Print/Do-not-print header    */\n/*                 PAGELEN(lines)        Number of lines per page     */\n/*                 OUTDES(output-descriptor-name)                     */\n/*                 PORTRAIT|LANDSCAPE    Print Format (HP LaserJet)   */\n/*                 WRITER(external-writer-name)                       */\n/*                                                                    */\n/* DEFAULTS                                                           */\n/*                 CLASS(A)                                           */\n/*                 NOCCHAR                                            */\n/*                 NOHOLD                                             */\n/*                 PAGELEN(60)                                        */\n/*                 TITLE                                              */\n/*                                                                    */\n/* OPERANDS                                                           */\n/*                                                                    */\n/*           See ROUTEHLP panel for details.                          */\n/*                                                                    */\n/* EXAMPLES                                                           */\n/*                                                                    */\n/*   ROUTE R4                                                         */\n/*                                                                    */\n/*   ROUTE FLOOR1 COPIES(2) CCHAR                                     */\n/*                                                                    */\n/*   ROUTE XRX3700 .A .B CLASS(Q) COPIES(3) NOTITLE PORTRAIT CCHAR    */\n/*                                                                    */\n/* CHANGE ACTIVITY                                                    */\n/*                                                                    */\n/* 602 IF dest='' & class\\='' THEN dest='LOCAL'                       */\n/* 603 Range selection using line commands (C/CC or M/MM)             */\n/* 604 Implement the default class table to simplify customizing.     */\n/*     Rewrite Parm Parsing routine.                                  */\n/*     Add OUTDES and LINECT parameters.                              */\n/*     Print line numbers when NUMBER ON is in effect.                */\n/*     Write documentation.                                           */\n/* 605 Convert a JES remote id to a standard format (i.e. RMTn)       */\n/*     to make sure that if the user enters RM002 and the table       */\n/*     contains RMT2, we'll get a match when we look it up.           */\n/* 606 Printer table expanded to contain multiple attributes.         */\n/*     Add support for NODE, FORMS and FCB.                           */\n/* 607 Prevent truncation of last character when the NOASA option     */\n/*     is specified or used as a default.                             */\n/*     Change date format from 95/08/08 to 8AUG1995                   */\n/* 608 Replace ROTATE key-word with PORTRAIT and LANDSCAPE            */\n/* 609 Correct various errors when user enters D/DD line commands     */\n/*     Replace ASA keyword with CCHAR to support machine ctl chars.   */\n/* 610 Add support for the WRITER operand.                            */\n/*     Change LINECT and HDR operands to PAGELEN and TITLE to         */\n/*     look more like the PRINTDS command.                            */\n/* 611 Accept operands from outer macro.                              */\n/*     Right parenthesis at end of command is optional.               */\n/* 612 Add support for the HOLD operand.                              */\n/*     The destination may also be specified as DEST(dest).           */\n/* 613 Prevent error in Parse_Parm when invoked without parameters    */\n/* 614 Move documentation to the ROUTEHLP panel.                      */\n/* 615 Download to a Workstation file using FILEXFER.                 */\n/* 616 Set up PRN and LPT1-4 as PC printer destination                */\n/* 617 Retry with EXECIO after ROUTEPGM failure                       */\n/* 618 Fix \"0 Lines Written\" message when routepgm=no                 */\n/* 619 Line length may be longer than 255 charcters                   */\n/* 620 Replace XEROX 3700 code with HP LaserJet codes                 */\n/* 621 Display WSCON Panel when needed                                */\n/* 622 END missing on line 306                                        */\n/*                                                                    */\n/**********************************************************************/\nRel=R622                       /* Current release                     */\n/*--------------------------------------------------------------------*/\n/*                                                                    */\n/*                  Define Default Values                             */\n/*                                                                    */\n/*--------------------------------------------------------------------*/\nDefault_Class='A'              /* Default CLASS                       */\nDefault_Dest='LOCAL'           /* DEST defaults to LOCAL              */\nDefault_Dest=''                /* User must specify DEST              */\nDefault_Forms=''               /* No special form required            */\nDefault_Node=''                /* Dest defined on this JES            */\nDefault_Pagelen=60             /* Lines per page                      */\nPrint_Line_Numbers='NO'        /* Do NOT print line numbers           */\nPrint_Line_Numbers='YES'       /* Print line numbers                  */\nRoutepgm='XYZ.LOAD'            /* Use ISPLLIB LIBDEF                  */\nRoutepgm='NO'                  /* Use the REXX stack and EXECIO       */\nRoutepgm='YES'                 /* Use the ROUTEPGM program            */\nxdsn='ISPFCS.TEXT'             /* temp dsn for WS download            */\n/*--------------------------------------------------------------------*/\n/*                                                                    */\n/*                Printer Default Attribute Table                     */\n/*                                                                    */\n/*     This table defines default attributes for printers.            */\n/*  It must be set up locally for every printer that requires default */\n/*  attributes different from the values set in the Default_nnnnn     */\n/*  variables above.  Hyphens must be used to indicate null values.   */\n/*                                                                    */\n/*  Note: for a JES2 remote, you must use the RMTn format (no leading */\n/*        zeroes in the numeric portion).                             */\n/*--------------------------------------------------------------------*/\n\n /*         PRINTER  NODE/NODE.DEST CLASS PAGELEN FORMS  FCB  MODE   */\nprinter.1 =\"LOCAL    -                A     60    -       -    -      \"\nprinter.2 =\"DEVV     -                G     60    -       -    -      \"\nprinter.3 =\"ROSV     -                Q     60    -       -    -      \"\nprinter.4 =\"XRX3700  -                Q     60    -       -    P37    \"\nprinter.5 =\"ESG3700  DEVV             Q     60    -       -    P37    \"\nprinter.6 =\"SSG1     DEVV.SSG13287    Q     60    -       -    L37    \"\nprinter.7 =\"VSA      -                M     60    Z100    -    -      \"\nprinter.10=\"GSFTEST  APL1             2     60    3PLY    8    -      \"\nprinter.11=\"RDGUISTS -                U     60    -       -    -      \"\nprinter.12=\"RDGCMPRM -                U     60    -       -    -      \"\nprinter.13=\"RDGPRGMR -                U     60    -       -    -      \"\nprinter.17=\"RMT2     CHIC             U     60    -       -    -      \"\nprinter.21=\"FLOOR1   A019.DSLASER5    A     60    STD     -    -      \"\nprinter.22=\"FLOOR2   A019.U22         A     60    STD     -    -      \"\nprinter.24=\"FLOOR4   A019.RMT2        A     60    4SH1    -    -      \"\nprinter.30=\"PRN      C:\\DEV\\PRN       A     0     EJECT   -    -      \"\nprinter.31=\"LPT1     C:\\DEV\\LPT1      A     0     EJECT   -    -      \"\nprinter.32=\"LPT2     C:\\DEV\\LPT2      A     0     EJECT   -    -      \"\nprinter.33=\"LPT3     C:\\DEV\\LPT3      A     0     EJECT   -    -      \"\nprinter.34=\"LPT4     C:\\DEV\\LPT4      A     0     EJECT   -    -      \"\nNumber_of_printers=34\n  /*----------------------------------------------------------------*/\n  /*     Initialise Variables used by the PARM parsing routine      */\n  /*----------------------------------------------------------------*/\nCchar=''                                /* CCHAR                      */\nClass=''                                /* SYSOUT class               */\nCopies=''                               /* Number of copies           */\nDest=''                                 /* Destination                */\nForms=''                                /* Forms number               */\nFcb=''                                  /* FCB name                   */\nHold=''                                 /* HOLD/NOHOLD                */\nLine1=''                                /* First Line (default is .ZF)*/\nLine2=''                                /* Last Line (default is .ZL) */\nMode=''                                 /* Portrait/Landscape         */\nNode=''                                 /* Routing Node               */\nOutdes=''                               /* Output Descriptor          */\nPagelen=''                              /* Lines per page             */\nTitle=''                                /* TITLE/NOTITLE              */\nWriter=''                               /* Name of external writer    */\n  /*----------------------------------------------------------------*/\n  /*              Invoke the PARM parsing routine                   */\n  /*----------------------------------------------------------------*/\nADDRESS ISPEXEC;  \"CONTROL ERRORS RETURN\"\n\"ISREDIT MACRO (PARM) NOPROCESS\"\nIF rc>0 THEN\n  SIGNAL Not_an_EDIT_macro\n\nARG Other_operands                      /* options from invoking EXEC */\n\nCALL PARSE_PARM                         /* PARSE PARAMETERS           */\n  /*----------------------------------------------------------------*/\n  /*              Build the Title line (TITLE option)               */\n  /*----------------------------------------------------------------*/\n\"ISREDIT (LRECL) = LRECL\"         /*  MAX Line LENGTH                 */\nIF Cchar \\= 'CCHAR' THEN\n  lrecl=lrecl+1\nIF LEFT(Title,1)='T' THEN DO      /*  Set up header                   */\n  \"ISREDIT (DSNAME) = DATASET\"; \"ISREDIT (MEMBER) = MEMBER\"\n  IF member \\= \" \" THEN    member = \"(\"member\")\"\n  Line = '1'USERID()\" \"SPACE(DATE(),0)\" \"TIME()\" \"dsname||member\n  Line = JUSTIFY(TRANSLATE(Line),81)\n  IF lrecl < LENGTH(line) THEN lrecl=LENGTH(line)\n  END\n  /*----------------------------------------------------------------*/\n  /* If CCHAR option specified, determine CC type from first record */\n  /* Note: RECFM=U can NOT be used with EXECIO, because EXECIO will */\n  /*    change it to RECFM=VB, which may cause S002-18 in ROUTEPGM. */\n  /*----------------------------------------------------------------*/\nRecfm='F A'                       /*  Default control characters      */\nIF Cchar='CCHAR' THEN DO\n  \"ISREDIT (L) = LINE\" Line1      /*  Read first line                 */\n  IF VERIFY(LEFT(L,1),' 0-+1')=1 THEN\n    Recfm='F M'                   /*  Machine control characters      */\n  END\n  /*----------------------------------------------------------------*/\n  /*                Allocate the SYSOUT data set                    */\n  /*----------------------------------------------------------------*/\nAlloc=Class Copies Dest Fcb Forms Hold Outdes Writer\nAlloc=SPACE(Alloc,1) 'RECFM('Recfm') BLKSIZE('Lrecl')'\nIF wsfn\\='' THEN DO                         /* download to WS */\n  alloc=\"DS(\"xdsn\") OLD DELETE\"\n  RC=LISTDSI(xdsn 'NORECALL')\n  IF RC>0 THEN DO\n    IF RC=16 & SYSREASON=9 THEN             /* Migrated data set */\n      \"HDELETE\" xdsn \"WAIT\"\n    alloc=\"DS(\"xdsn\") MOD CATALOG\",\n         \"TRACKS SPACE(10 10) UNIT(SYSALLDA)\",\n         \"DSORG(PS) RECFM(V B) LRECL(\" lrecl+4 \")\"\n    END\n  END\nIF debug='DEBUG' THEN SAY Alloc\nADDRESS TSO,                      /*  Issue ALLOCATE Command  */\n        \"ALLOCATE DD(DDROUTE) REUSE\" Alloc\nIF rc>0 THEN EXIT 20              /*  ALLOCATE command failed */\n  /*----------------------------------------------------------------*/\n  /*                Write the title line                            */\n  /*----------------------------------------------------------------*/\nTitlelen='000'                    /*  number of lines in header       */\nIF LEFT(Title,1)='T' THEN DO      /*  Write header                    */\n  QUEUE Line;QUEUE ' ';QUEUE ' '\n  Titlelen='003'                  /*  number of lines in header       */\n  END\n  /*----------------------------------------------------------------*/\n  /*     Set the LaserJet print mode: Landscape or Portrait         */\n  /*----------------------------------------------------------------*/\nIF Mode\\='' THEN DO                /*  Rotate output                  */\n  If Mode='L' THEN DO\n    QUEUE 'C51B5093F1D6'X          /*  Mode(landscape)                */\n    END\n  If Mode='P' THEN DO\n    QUEUE 'C51B5093F0D6'X          /*  Mode(portrait)                 */\n    END\n  END\n  /*----------------------------------------------------------------*/\n  /*   If NUMBER mode is ON and global variable Print_line_numbers  */\n  /*   is set to YES, change NUMBER mode to OFF.                    */\n  /*----------------------------------------------------------------*/\n\"ISREDIT (NUMMODE,NUMTYPE) = NUMBER\"   /* Query number mode info    */\nIF Nummode='ON' & Print_Line_Numbers='YES' THEN\n  'ISREDIT NUMBER = OFF'               /* Turn OFF number mode      */\n  /*----------------------------------------------------------------*/\n  /*                                                                */\n  /*   Write data to DDROUTE.                                       */\n  /*                                                                */\n  /*   1. If the ROUTEPGM program is NOT available, then use QUEUE  */\n  /*      and EXECIO for writing.                                   */\n  /*                                                                */\n  /*   2. If the ROUTEPGM program IS available, then invoke it to   */\n  /*      speed things up.                                          */\n  /*                                                                */\n  /*----------------------------------------------------------------*/\n\nIF routepgm='NO' THEN\n  CALL stack_print                     /* ROUTEPGM is NOT available  */\nELSE DO\n  CALL pgm_print                       /* ROUTEPGM is available      */\n  IF Pgmrc>0 THEN                      /* If ROUTEPGM failed,        */\n    CALL stack_print                   /*   use EXECIO instead       */\n  END\n\n\"ISREDIT NUMBER =\" Nummode             /* Reset NUMBER mode          */\n  /*----------------------------------------------------------------*/\n  /*     Reset the LaserJet printer to default print mode           */\n  /*----------------------------------------------------------------*/\nIF Mode\\='' THEN                  /* reset printer to default mode  */\n    QUEUE 'C51B45'X\n  /*----------------------------------------------------------------*/\n  /*    Write lines out from the TSO stack to the output data set   */\n  /*----------------------------------------------------------------*/\nIF QUEUED() > 0 THEN DO\n  QUEUE ''\n  ADDRESS TSO \"EXECIO * DISKW DDROUTE (FINIS\"    /* WRITE lines       */\n  END\n  /*----------------------------------------------------------------*/\n  /*            Download temp data set to the Workstation           */\n  /*----------------------------------------------------------------*/\nIF wsfn\\='' THEN DO                            /* Download to WS ? */\n  IF Forms='FORMS(EJECT)' THEN DO\n    QUEUE '0C'X                                  /* form feed (FF) */\n    QUEUE ''                                       /* eof */\n    ADDRESS TSO \"EXECIO * DISKW DDROUTE (FINIS\"    /* append x'0C' */\n    END\n  IF Debug='DEBUG' THEN\n    SAY \"FILEXFER HOST(xdsn) WS(wsfn) TO(WS) TEXT\" xdsn wsfn\n  \"FILEXFER HOST(xdsn) WS(wsfn) TO(WS) TEXT\"\n  IF rc>0 THEN DO                              /* FILEXFER error   */\n    IF zerrmsg='ISPX010' THEN DO\n      \"SETMSG MSG(\"zerrmsg\")\"                  /* send the message */\n      \"SELECT PGM(ISPWSCD) PARM(WSCON,PANEL)\"\n      If rc>0 THEN\n        SIGNAL SETMSG\n      \"FILEXFER HOST(xdsn) WS(wsfn) TO(WS) TEXT\"  /* retry */\n      If rc>0 THEN\n        SIGNAL Not_connected\n      END\n    END\n  i=line2-line1+1                               /* count lines copied */\n  Zedsmsg = i \"Lines Written\"                    /* Short message    */\n  Zedlmsg = \"ROUTE \"Rel\": Your EDIT Data Set has been routed to\" wsfn\n  \"SETMSG MSG(ISRZ001)\"                          /* send the message */\n  IF cmd = 'M' THEN                       /* if MM/MM range specified */\n    'ISREDIT DELETE' Line1 Line2          /* delete the lines printed */\n  ADDRESS TSO \"FREE DD(DDROUTE) DELETE\"    /* delete temp data set */\n  EXIT\n  END\n  /*----------------------------------------------------------------*/\n  /*            Issue completion message to terminal                */\n  /*----------------------------------------------------------------*/\nIF Pgmrc=0 THEN DO                               /* If COPY went OK  */\n  i=line2-line1+1                               /* count lines copied */\n  Zedsmsg = i \"Lines Written\"                    /* Short message    */\n  Zedlmsg = \"ROUTE \"Rel\": Your EDIT Data set has been routed to\" Alloc\n  \"SETMSG MSG(ISRZ001)\"                          /* send the message */\n  IF cmd = 'M' THEN                       /* if MM/MM range specified */\n    'ISREDIT DELETE' Line1 Line2          /* delete the lines printed */\n  END\n  /*----------------------------------------------------------------*/\n  /*               Free up the output data set                      */\n  /*----------------------------------------------------------------*/\nADDRESS TSO \"FREE DD(DDROUTE)\"        /* make output available to JES */\nEXIT\n/**********************************************************************/\n/*                                                                    */\n/*                    PROCESS INPUT PARAMETERS                        */\n/*                                                                    */\n/**********************************************************************/\nPARSE_PARM:\n  IF parm='?' THEN\n    SIGNAL HELP_panel                         /* User requested HELP */\n\n  'ISREDIT (LINE2) = LINENUM .ZLAST'          /* Last Line           */\n  IF rc>0 | line2=0 THEN\n    SIGNAL Empty_dataset                      /* No lines to print   */\n\n  Debug=''\n  Range1=''\n  Range2=''\n  Alphabetic=XRANGE('A','Z')\n  Numeric='1234567890'\n  Alphanumeric=Alphabetic||Numeric\n  IF Other_operands\\='' THEN            /* invoked from outer macro   */\n    Parm=Parm Other_operands            /* add at end of command      */\n  wsfn=''                               /* dest is NOT a wsfn         */\n  /*----------------------------------------------------------------*/\n  /*            Add closing parenthesis at end of string            */\n  /*----------------------------------------------------------------*/\n  IF parm\\='' THEN DO\n    p=WORD(Parm,WORDS(Parm))\n    IF RIGHT(p,1)\\=')' & POS('(',p)>1 THEN\n      Parm=Parm||')'\n  END\n  /*----------------------------------------------------------------*/\n  /*               Process input parameters                         */\n  /*----------------------------------------------------------------*/\n  DO i=1 to WORDS(parm)\n    p=TRANSLATE(WORD(parm,i))\n    IF Debug='DEBUG' THEN SAY 'p='p 'parm='parm\n    kwd=''\n    IF RIGHT(p,1)=')' & POS('(',p)>1 THEN DO\n      value=LEFT(p,LENGTH(p)-1)               /* remove right paren */\n      PARSE VAR value kwd '(' value           /* extract key-word   */\n      END\n    SELECT\n      WHEN p='DEBUG'  THEN Debug=p            /* debugging */\n      WHEN p='EXECIO' THEN Routepgm='NO'      /* debugging */\n      WHEN LEFT(p,1) = '.' THEN DO\n        If Range1='' THEN\n          Range1=p\n        ELSE DO\n          IF Range2\\='' THEN SIGNAL Duplicate_keyword\n          Range2=p\n          END\n        END\n      WHEN ABBREV('CCHAR',p,2) THEN\n        IF Cchar='' THEN\n          Cchar='CCHAR'\n        ELSE\n          SIGNAL Duplicate_keyword\n      WHEN ABBREV('CLASS',kwd,2) THEN\n        SELECT\n          WHEN Class\\='' THEN SIGNAL Duplicate_keyword\n          WHEN LENGTH(value)\\=1 THEN SIGNAL Invalid_value\n          WHEN VERIFY(value,Alphanumeric) > 0 THEN SIGNAL Invalid_value\n          OTHERWISE Class=value\n        END\n      WHEN ABBREV('COPIES',kwd,2) THEN\n        SELECT\n          WHEN Copies\\='' THEN SIGNAL Duplicate_keyword\n          WHEN VERIFY(value,Numeric) > 0 THEN SIGNAL Invalid_value\n          WHEN value<1 | value>255 THEN SIGNAL Invalid_value\n          OTHERWISE Copies='COPIES('value+0')'\n        END\n      WHEN ABBREV('DEST',kwd,2) THEN\n        SELECT\n          WHEN Dest\\='' THEN SIGNAL Duplicate_keyword\n          OTHERWISE Dest=Value\n        END\n      WHEN ABBREV('FCB',kwd,2) THEN\n        SELECT\n          WHEN Fcb\\='' THEN SIGNAL Duplicate_keyword\n          WHEN LENGTH(value)=0 THEN SIGNAL Invalid_value\n          WHEN LENGTH(value)>4 THEN SIGNAL Invalid_value\n          OTHERWISE Fcb='FCB('value')'\n        END\n      WHEN ABBREV('FORMS',kwd,2) THEN\n        SELECT\n          WHEN Forms\\='' THEN SIGNAL Duplicate_keyword\n          WHEN LENGTH(value)=0 THEN SIGNAL Invalid_value\n          WHEN LENGTH(value)>4 THEN SIGNAL Invalid_value\n          OTHERWISE Forms='FORMS('value')'\n        END\n      WHEN ABBREV('HOLD',p,2) THEN\n        IF Hold='' THEN\n          Hold='HOLD'\n        ELSE\n          SIGNAL Duplicate_keyword\n      WHEN ABBREV('NOHOLD',p,3) THEN\n        IF Hold='' THEN\n          Hold='NOHOLD'\n        ELSE\n          SIGNAL Duplicate_keyword\n      WHEN ABBREV('PAGELEN',kwd,2) THEN\n        SELECT\n          WHEN Pagelen\\='' THEN SIGNAL Duplicate_keyword\n          WHEN VERIFY(value,Numeric) > 0 THEN SIGNAL Invalid_value\n          WHEN value<10 | value>255 THEN SIGNAL Invalid_value\n          OTHERWISE Pagelen=value\n        END\n      WHEN ABBREV('PORTRAIT',p,4) | ABBREV('LANDSCAPE',p,4) THEN\n        IF Mode='' THEN\n          Mode=LEFT(p,1)                 /* P(ortrait) or L(andscape) */\n        ELSE\n          SIGNAL Duplicate_keyword\n      WHEN ABBREV('OUTDES',kwd,4) THEN\n        SELECT\n          WHEN Outdes\\='' THEN SIGNAL Duplicate_keyword\n          WHEN LENGTH(value)=0 THEN SIGNAL Invalid_value\n          WHEN LENGTH(value)>8 THEN SIGNAL Invalid_value\n          WHEN VERIFY(value,Alphanumeric) > 0 THEN SIGNAL Invalid_value\n          OTHERWISE Outdes='OUTDES('value')'\n        END\n      WHEN ABBREV('TITLE',p,3) | ABBREV('NOTITLE',p,5) THEN\n        IF Title='' THEN\n          Title=p\n        ELSE\n          SIGNAL Duplicate_keyword\n      WHEN ABBREV('WRITER',kwd,2) THEN\n        SELECT\n          WHEN Writer\\='' THEN SIGNAL Duplicate_keyword\n          WHEN LENGTH(value)=0 THEN SIGNAL Invalid_value\n          WHEN LENGTH(value)>8 THEN SIGNAL Invalid_value\n          WHEN VERIFY(value,Alphanumeric) > 0 THEN SIGNAL Invalid_value\n          OTHERWISE Writer='WRITER('value')'\n        END\n      OTHERWISE\n        IF dest='' THEN\n          dest=p\n        ELSE\n          SIGNAL Dest_multiple                /* too many DESTs      */\n    END\n  END\n\n  /*    Check if the user selected a range by entering a line        */\n  /*    command such as C, Cnn, CC/CC or M, Mnn, MM/MM. If it is     */\n  /*    the case, set line1 and line2 to the first and last line     */\n  /*    numbers, respectively.  If the user selected a range both    */\n  /*    in the ROUTE command (such as ROUTE .X .Y) and in a line     */\n  /*    command, issue an error message.                             */\n\n  'ISREDIT PROCESS RANGE C M'\n  SELECT\n    WHEN rc=0 THEN DO\n      'ISREDIT (CMD)   = RANGE_CMD'                /* get C or M  */\n      IF range1\\='' THEN SIGNAL Command_conflict\n      \"ISREDIT (LINE1) = LINENUM .ZFRANGE\"         /* First line  */\n      \"ISREDIT (LINE2) = LINENUM .ZLRANGE\"         /* Last line   */\n      END\n    WHEN rc=4 THEN DO\n      CMD='C'\n      IF Range1\\='' THEN DO                       /* ROUTE .X .Y     */\n        p=Range1\n        \"ISREDIT (LINE1) = LINENUM\" Range1        /* LINENUM .X      */\n        IF rc>0 THEN SIGNAL Invalid_label\n        IF Range2='' THEN Range2='.ZLAST'          /*   DEFAULTS  */\n        p=Range2\n        \"ISREDIT (LINE2) = LINENUM\" Range2        /* LINENUM .Y      */\n        IF rc>0 THEN SIGNAL Invalid_label\n        IF Line2<Line1 THEN DO\n          x=Line1; Line1=Line2; Line2=x           /* Swap labels     */\n          END\n        END\n      ELSE DO\n        Line1=1                                    /*   DEFAULTS  */\n        \"ISREDIT (LINE2) = LINENUM .ZLAST\"         /*   DEFAULTS  */\n        END\n      END\n    WHEN rc=20 THEN                       /* All lines deleted        */\n      SIGNAL Empty_dataset                /* No lines to ROUTE        */\n    OTHERWISE DO                          /* Line command conflict    */\n      Pgmrc=RC                            /* Save ISREDIT Return code */\n      IF zerrmsg\\='' THEN\n        'SETMSG MSG('zerrmsg')'           /* Edit has created message */\n      EXIT Pgmrc\n      END\n  END\n  /*----------------------------------------------------------------*/\n  /*                 Assign default value for DEST                  */\n  /*----------------------------------------------------------------*/\nIF Dest='' THEN\n  SELECT\n    WHEN default_dest\\='' THEN\n      Dest=Default_dest                       /* use default value   */\n    WHEN Class\\='' THEN NOP                   /* CLASS(c) specified  */\n    WHEN Outdes\\='' THEN NOP                  /* OUTDES(x) specified */\n    Otherwise\n      SIGNAL Dest_missing                     /* dest is mandatory   */\n  END\n  /*----------------------------------------------------------------*/\n  /*                     Search Printer Table                       */\n  /*----------------------------------------------------------------*/\nn=VERIFY(REVERSE(dest),'0123456789')\nIF n>0 & ABBREV('RMT',LEFT(dest,LENGTH(dest)-n+1)) THEN\n  dest='RMT'RIGHT(dest,n-1)+0                 /* R002 -> RMT2        */\n\nDO i=1 to Number_of_printers\n  IF WORD(printer.i,1)=dest THEN DO\n    IF WORD(printer.i,2)\\='-' THEN Default_node=WORD(printer.i,2)\n    IF WORD(printer.i,3)\\='-' THEN Default_class=WORD(printer.i,3)\n    IF WORD(printer.i,4)\\='-' THEN Default_Pagelen=WORD(printer.i,4)\n    IF Pagelen='' & WORD(printer.i,4)\\='-' THEN\n      Pagelen=WORD(printer.i,4)\n    IF Forms='' & WORD(printer.i,5)\\='-' THEN\n      Forms='FORMS('WORD(printer.i,5)')'\n    IF FCB='' & WORD(printer.i,6)\\='-' THEN\n      FCB='FCB('WORD(printer.i,6)')'\n    LEAVE\n  END\nEND\n\nIF Default_node\\='' THEN\n  IF POS('.',Default_node)=0 & POS('\\',Default_node)=0 THEN\n    Dest= Default_node'.'dest                /* node=A019           */\n  ELSE\n    Dest=Default_node                        /* node=A019.RMT2      */\n\n  /*----------------------------------------------------------------*/\n  /*                 Check for a workstation file                   */\n  /*----------------------------------------------------------------*/\nIF LEFT(dest,1) = '/' | SUBSTR(dest,2,1) = ':' THEN DO\n  'VGET (ZWSCON ZSCREEND ZPREFIX) SHARED'\n  IF zwscon='' THEN DO\n    Zedsmsg = 'Not Connected'                /* Short message    */\n    Zedlmsg = 'A connection must be established with the work-station',\n              'before this command is entered.'\n    \"SETMSG MSG(ISRZ001)\"                    /* send the message */\n    \"SELECT PGM(ISPWSCD) PARM(WSCON,PANEL)\"\n    If rc>0 THEN\n      SIGNAL Not_connected\n    END\n  wsfn=dest\n  Cchar='CCHAR'\n  Pagelen=0\n  END\n  /*----------------------------------------------------------------*/\n  /*                  Assign default value for TITLE                */\n  /*----------------------------------------------------------------*/\nIF Title='' then                  /*  Default for Title is TITLE      */\n  IF Cchar='CCHAR' then\n     Title='NOTITLE'              /*  unless CCHAR has been           */\n  ELSE\n     Title='TITLE'                /*  specified                       */\n\nIF Debug='DEBUG' THEN SAY dest','Class','Line1','Line2','Cchar','Mode\n\nIF Dest\\='' THEN\n  Dest='DEST('dest')'\n\nIF Class='' THEN\n  IF Default_class='' THEN\n    Class='SYSOUT'\n  ELSE\n    Class='SYSOUT('Default_class')'\nELSE\n  Class='SYSOUT('Class')'\n\nIF Pagelen='' THEN Pagelen=Default_Pagelen\n\nRETURN\n/**********************************************************************/\n/*                                                                    */\n/*              QUEUE the data lines to the TSO stack                 */\n/*                                                                    */\n/**********************************************************************/\nStack_print:\n  ctlchr=' '\n  IF Cchar='CCHAR' THEN\n    DO i = Line1 TO Line2\n      \"ISREDIT (LINE) = LINE\" i                /* GET CURRENT LINE */\n      QUEUE Line\n    END\n  ELSE\n    DO i = Line1 TO Line2\n      \"ISREDIT (LINE) = LINE\" i                /* GET CURRENT LINE */\n      QUEUE ctlchr||Line\n      ctlchr=\" \";Titlelen=Titlelen+1\n      IF Titlelen>Pagelen THEN DO; CTLCHR=\"1\"; Titlelen=001; END\n    END\n  Pgmrc=0                                  /* copy successful       */\nRETURN\n/**********************************************************************/\n/*                                                                    */\n/*              Invoke ROUTEPGM to write data lines                   */\n/*                                                                    */\n/**********************************************************************/\nPgm_print:\n  Line1=RIGHT(Line1,6,'0')\n  Line2=RIGHT(Line2,6,'0')\n  IF Cchar='CCHAR' THEN\n    PARM=\"DDROUTE,\"Line1\",\"Line2\n  ELSE\n    PARM=\"DDROUTE,\"Line1\",\"Line2\",\"RIGHT(Pagelen,3,'0')\",\"Titlelen\n\n  IF QUEUED() > 0 THEN DO                          /* write title */\n    QUEUE ''                                       /* write title */\n    ADDRESS TSO \"EXECIO * DISKW DDROUTE (FINIS\"    /* write title */\n    END                                            /* write title */\n\n  IF LENGTH(routepgm) > 3 THEN DO\n    p7=routepgm                            /* for ISPD014 message   */\n    \"LIBDEF ISPLLIB DATASET ID('\"routepgm\"')\"\n    IF rc>0 THEN                           /* ISPLLIB error         */\n      SIGNAL SETMSG\n    END\n\n  \"SELECT PGM(ROUTEPGM) PARM(\"parm\")\"      /* write the data lines  */\n  Pgmrc=rc                                 /* save return code      */\n\n  IF LENGTH(routepgm) > 3 THEN \"LIBDEF ISPLLIB\"\n\n  SELECT\n    WHEN Pgmrc=0 THEN NOP\n    WHEN Pgmrc=8 THEN\n      SAY \"OPEN FAILED FOR DDN=DDROUTE, RC=\"Pgmrc\n    WHEN Pgmrc=12 THEN\n      SAY \"INVALID PARM: '\"parm\"'\"\n    OTHERWISE\n      SAY \"ROUTEPGM.RC=\"Pgmrc \"PARM='\"parm\"'\"\n      \"GETMSG MSG(&zerrmsg) SHORTMSG(ZERRSM) LONGMSG(ZERRLM)\"\n      IF rc=0 THEN DO\n        SAY zerrsm\n        SAY zerrlm\n        END\n    END\n  RETURN\n/**********************************************************************/\n/*                      Exception Routines                            */\n/**********************************************************************/\nNot_an_EDIT_macro:\n  Zedsmsg = \"EDIT Macro Only\"                  /* Short message    */\n  Zedlmsg = \"ROUTE may only be invoked as an EDIT macro\"\n  \"SETMSG MSG(ISRZ001)\"                        /* send the message */\n  EXIT 8\nHELP_panel:\n  \"DISPLAY PANEL(ROUTEHLP)\"              /* Display HELP panel        */\n  IF rc>8 THEN\n    SIGNAL SETMSG                        /* HELP panel is missing     */\n  EXIT\nEmpty_dataset:\n  zedsmsg='Empty data set'\n  zedlmsg='There are no lines to print'\n  'SETMSG MSG(ISRZ001)'\n  EXIT 12\nDuplicate_keyword:\n  IF kwd='' THEN kwd=p\n  zerrsm='Duplicate Key-word'\n  zerrlm='Key-word' kwd 'has been specified more than once.'\n  SIGNAL Beep_msg\nInvalid_value:\n  zerrsm='Invalid Value'\n  zerrlm='Value' value 'is invalid for key-word' kwd\n  IF Value='' THEN\n    zerrlm='A null value is invalid for key-word' kwd\n  SIGNAL Beep_msg\nInvalid_label:\n  zerrsm='Probable label error'\n  zerrlm=p 'recognized as invalid or undefined label.'\n  SIGNAL Beep_msg\nCommand_conflict:\n  zerrsm='Command Conflict'\n  zerrlm='\"'cmd'\" conflicts with range specification; blank it out.'\n  SIGNAL Beep_msg\nDest_missing:\n  zerrsm='Destination missing'\n  zerrlm='The output destination has not been specified.'\n  SIGNAL Beep_msg\nDest_multiple:\n  zerrsm='Multiple Destinations'\n  zerrlm=p 'recognized as duplicate destination.'\n  SIGNAL Beep_msg\nNot_connected:\n  zerrsm='Not Connected'\n  zerrlm='A connection must be established with the work-station',\n         'before this command is entered.'\n  SIGNAL Beep_msg\nBeep_msg:\n  zerralrm='YES'                  /*   ALARM=YES                      */\n  zerrhm='ROUTEHLP'               /*   HELP Panel                     */\n  'SETMSG MSG(ISRZ002)'           /*   Issue error message            */\n  EXIT 20\nSETMSG:\n  IF zerrmsg\\='' THEN 'SETMSG MSG('zerrmsg')'\n  EXIT 20\n\n  /*----------------------------------------------------------------*/\n  /*     Set the XEROX 3700 print mode: Landscape or Portrait       */\n  /*----------------------------------------------------------------*/\nIF Mode\\='' THEN DO                /*  Rotate output                  */\n  Udk='A1'X                        /*  Tilde=X'A1'                    */\n  QUEUE ' ='||'UDK'||'='Udk' '     /*  User-defined key               */\n  If Mode='L' THEN DO\n    QUEUE ' 'Udk'+1XCP14-L'        /*  Mode(Landscape)                */\n    QUEUE ' 'Udk'1 '\n    END\n  If Mode='P' THEN DO\n    QUEUE ' 'Udk'+2Titan12iso-P'   /*  Mode(portrait)                 */\n    QUEUE ' 'Udk'2 '\n    END\n  END\n\n  /*----------------------------------------------------------------*/\n  /*     Reset the XEROX 3700 printer to default print mode         */\n  /*----------------------------------------------------------------*/\nIF Mode\\='' THEN                  /* reset printer to default mode  */\n    QUEUE ' 'Udk'+X'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ROUTEHLP": {"ttr": 15882, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\x10\\x00\\x00\\x00\\x91\\x11_\\x00\\x984_\\x14\\x14\\x00\\x98\\x00\\x19\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf5\\xf1@@@@'", "ispf": {"version": "06.16", "flags": 0, "createdate": "1991-04-25T00:00:00", "modifydate": "1998-12-11T14:14:00", "lines": 152, "newlines": 25, "modlines": 0, "user": "CBT451"}, "text": ")ATTR DEFAULT($+!)\n   $ TYPE(ET)\n   ! TYPE(NEF) PAD(USER) CAPS(ON)\n   + TYPE(NT)\n   # AREA(SCRL) EXTEND(ON)\n)BODY\n$TUTORIAL ------------------ EDIT - 'ROUTE' COMMAND ------------------- TUTORIAL\n$COMMAND ===>!ZCMD                                                             +\n\n#SAREA                                                                         #\n#                                                                              #\n#                                                                              #\n#                                                                              #\n#                                                                              #\n#                                                                              #\n#                                                                              #\n#                                                                              #\n+\n)AREA SAREA\n\n FUNCTION = The ROUTE EDIT macro prints the data currently being edited.\n            Although it can be used as an alternative to PRINTDS, PRINTOFF,\n            or the various PRINT functions of ISPF/PDF, ROUTE is particularly\n            useful to print data that does not exist on disk in a printable\n            form, such as packed data, data modified during the current EDIT\n            session, or data only accessible via the EDIT Interface (EDIF).\n\n SYNTAX  =  ROUTE\n              dest                  Destination\n              first                 First line       .A\n              last                  Last line        .B\n              CCHAR                 Data contains carriage control characters\n              CLASS(class)          Class\n              COPIES(copies)        Number of copies\n              DEST(dest)            Destination (alt)\n              FCB(FCB-name)         Name of the FCB\n              FORMS(forms-number)   Forms number\n              HOLD/NOHOLD           HOLD/NOHOLD\n              TITLE|NOTITLE         Print/Do-not-print header\n              PAGELEN(lines)        Number of lines per page\n              OUTDES(output-descriptor-name)\n              PORTRAIT|LANDSCAPE    Print Format on Xerox 3700\n              WRITER(external-writer-name)\n\n DEFAULTS\n              CLASS(A)\n              NOCCHAR\n              NOHOLD\n              PAGELEN(60)\n              TITLE\n\n OPERANDS\n\n              Destination is the name of the JES printer on\n                  which the hardcopy will be created.\n                  It must be coded like the DEST key-word of\n                  a DD statement or ALLOCATE command.\n                  For a local printer, specify LOCAL or R0.\n                  Examples: R4, L3287, PROD.X3700, N5R22, RMT35\n                  Destination defaults to LOCAL if CLASS is\n                  specified; otherwise, it must be specified.\n                  The destination may also be specified as\n                  DEST(destination).\n                  If the destination is a work-station file name\n                  such as c:\\abcdef.txt or /usr/etc/abcdef.txt\n                  then the FILEXFER service is used to transfer\n                  the data to the corresponding WS file.\n              first and last are labels that define the range\n                  of lines to be printed.  Any currently defined\n                  label is valid, e.g. .ZF .ZCSR .HERE, etc\n                  A range can alternatively be specified using\n                  C/CC or M/MM line commands.  Specification of\n                  a range is optional.  If no range is\n                  specified, the entire data set is printed.\n              class optionally specifies the output class used\n                  to allocate the SYSOUT data set.\n                  If not specified, Default_class is used or,\n                  if destination is present in the Default\n                  Class Table, the associated class is used.\n              copies optionally specifies the number of copies.\n                  The default value is one.\n              Output-descriptor is the name of an output descrip-\n                  tor that will be associated with the SYSOUT\n                  data set.  Output descriptors are created by\n                  the // OUTPUT statement in the LOGON procedure\n                  or the OUTDES command.\n              Lines optionally specifies the number of lines\n                  printed per page.\n                  The default is Default_pagelen.\n              Forms-number is a 4-character forms number\n              HOLD Specifies that the output should be held in\n                  the JES output queue until it is released.\n              NOHOLD Specifies that the output should be made\n                  available for printing immediately.\n              FCB-number is a 4-character FCB number\n              CCHAR is an optional key-word indicating that the\n                  first byte of each record is a carriage\n                  control character (ASA or machine).  ROUTE\n                  inspects the first record to determine the\n                  control character type (i.e. ASA or machine).\n                  CCHAR implies NOTITLE.\n              TITLE is a default key-word that needs only be\n                  specified in conjunction with CCHAR.\n              NOTITLE is an optional key-word that prevents a\n                  title line from being printed at the beginning\n                  of the print file to identify its contents.\n              PORTRAIT and LANDSCAPE are optional key-words that\n                  generate the character sequences to switch a\n                  XEROX 3700 printer to portrait mode or\n                  landscape mode at the beginning of the print\n                  file, then switch it back to the default mode\n                  at the end.\n\n       Operands may be specified in any order.\n\n       ROUTE was initially designed to print on RJE printers, which\n       is why the destination parameter is mandatory.  To make the\n       destination an optional parameter, set the Default_dest\n       variable to the default destination (such as LOCAL or RMTnn).\n\n       You may use the C or M line commands (in any form) to select\n       a range of lines. If the M line command is used, the lines\n       printed are deleted.\n\n       When printing data that does not contain control characters,\n       you may use the control word .SK in pos 1 of a line each\n       time you want to start a new page.\n\n       Routing to a work-station file requires an existing connection\n       to the work-station agent (WSA).  Only the dest and debug\n       parameters are allowed; all other parameters are ignored.\n\n       You can invoke ROUTE from a REXX exec or CLIST to provide\n       shortcuts or hide complex option strings.  The outer macro\n       specifies additional operands as arguments to the ROUTE macro.\n       For example, to relieve users from having to type WRITER(W132)\n       when they print to an HP Laserjet, create a ROUTEJET macro as\n       follows:\n\n             \"%ROUTE WRITER(W132)\"; EXIT RC\n\n     Examples:\n\n       ROUTE R4\n\n       ROUTE FLOOR1 COPIES(2) CCHAR\n\n       ROUTE XRX3700 .A .B CLASS(Q) COPIES(3) NOTITLE PORTRAIT CCHAR\n\n       ROUTE c:\\temp\\text.file debug\n\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ROUTEPGM": {"ttr": 16132, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x06\\x00$\\x00\\x88!\\x0f\\x01\\x02'O\\x15G\\x01\\xcd\\x00\\x85\\x01%\\xc3\\xc2\\xe3\\xf4\\xf5\\xf5@@@@\"", "ispf": {"version": "06.06", "flags": 0, "createdate": "1988-07-28T00:00:00", "modifydate": "2002-10-01T15:47:24", "lines": 461, "newlines": 133, "modlines": 293, "user": "CBT455"}, "text": "//GILBERTR JOB (ACCT#),ROUTEPGM,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = ROUTEPGM                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = COPY EDIT DATA TO A QSAM DATA SET                *\n*                                                                     *\n* FUNCTION = THIS PGM CAN BE INVOKED IN AN EDIT MACRO TO COPY         *\n*            THE DATA BEING EDITED TO A SEQUENTIAL DATA SET.          *\n*            IT ALSO PROVIDES ADDITIONAL FUNCTIONS SPECIFIC TO        *\n*            THE ROUTE EDIT MACRO.                                    *\n*                                                                     *\n* STATUS = R606                                                       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*          http://gsf-soft.com/Freeware/                              *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = MVS/370, MVS/XA, MVS/ESA, OS/390                  *\n*                   ISPF/PDF V2R3 OR ABOVE                            *\n*                                                                     *\n*    AUTHORIZATION = NONE                                             *\n*                                                                     *\n*    RESTRICTIONS = NONE                                              *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (TSO COMMAND PROCESSOR)                    *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 2K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE 24, AMODE ANY,                   *\n*                 PROBLEM STATE, KEY 8                                *\n*                                                                     *\n* OPERATION = SEE COMMENTS IN SOURCE CODE                             *\n*                                                                     *\n* SYNTAX = SEE BELOW                                                  *\n*                                                                     *\n*           PARM=(&DDNAME,&LINE1,&LINE2,&LINECT,&INITLINE)            *\n*                                                                     *\n*              &DDNAME       OUTPUT DDNAME                            *\n*                            REQUIRED, MUST BE A VALID DDNAME         *\n*              &LINE1        FIRST LINE (.ZF)                         *\n*                            IF SPECIFIED, MUST BE A 6-DIGIT NUMBER   *\n*              &LINE2        LAST LINE (.ZL)                          *\n*                            IF SPECIFIED, MUST BE A 6-DIGIT NUMBER   *\n*              &LINECT       LINE COUNT (60)                          *\n*                            IF SPECIFIED, MUST BE A 3-DIGIT NUMBER   *\n*              &INITLINE     LINES ALREADY WRITTEN ON 1ST PAGE        *\n*                            IF SPECIFIED, MUST BE A 3-DIGIT NUMBER   *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n* 603 MAKE MODULE REENTRANT                                           *\n* 604 CONVERT JESJCL FROM RECFM=M TO RECFM=A FOR SDSF 1.4             *\n* 605 ADD SUPPORT FOR RECFM=V AND RECFM=U                             *\n* 606 INCREASE LINE LENGTH TO 32760                                   *\n*                                                                     *\n***********************************************************************\nROUTEPGM RSECT\nROUTEPGM AMODE ANY\n         SAVE  (14,12),,'GSF UTILITIES - ROUTEPGM R606D'\n         LR    R12,R15\n         USING ROUTEPGM,R12\n         GETMAIN R,LV=DYNAML           GET DYNAMIC STORAGE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LM    R13,R1,8(R13)           A(DYNAM)\n         USING DYNAM,R13\n         MVC   DCB1(DCB1L),DCB1MOD     MOVE MODEL DCB\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PARSE PARM INTO WORKING-STORAGE FIELDS                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         L     R15,=A(PARSE)           PARM PARSING RTNE\n         BALR  R14,R15             <-- PARSE PARM\n         DC    S(L'DCB1DDNAM,DCB1DDNAM) OUTPUT DDNAME\n         DC    S(L'LINE1,LINE1)        FIRST LINE (.ZF)\n         DC    S(L'LINE2,LINE2)        LAST LINE (.ZL)\n         DC    S(L'LINECT,LINECT)      LINE COUNT (60)\n         DC    S(L'INITLINE,INITLINE)  LINE ALREADY WRITTEN ON 1ST PAGE\n*---------------------------------------------------------------------*\n*                                                                     *\n*        SET-UP CONNECTION WITH ISPF                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         LOAD  EP=ROUTEPGM             PIN MYSELF IN MEMORY\n*\n         LOAD  EP=ISPLINK              ISREDIT/ISPLINK\n         ST    R0,ISPLINK@             SAVE THE ADDRESS\n*\n         LA    R1,=A($CONTROL,$ERRORS,$RETURN+VL)\n         L     R15,ISPLINK@            PICK UP ISPF INTERFACE ADDRESS\n         BALR  R14,R15                 CALL ISPLINK\n*---------------------------------------------------------------------*\n*                                                                     *\n*        SET UP PARAMETERS                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\nPARM21   CLI   DCB1DDNAM,C' '          DDNAME SPECIFIED?\n         LA    R15,12                  PRIME R15 WITH ERROR CODE\n         BNH   EXIT15                  NO, QUIT\n*\nPARM22   PACK  DWD,LINE1               LINE 1?\n         OI    DWD+7,X'0F'             PREVENT S0C7 IF NOT SPECIFIED\n         CVB   R4,DWD                  LINE COUNTER (.ZF)\n         LTR   R4,R4                   ANY VALUE SPECIFIED?\n         BZ    PARM23                  NO, JUMP\n         BCTR  R4,0                    YES, MAKE IT RELATIVE TO ZERO\n*\nPARM23   PACK  DWD,LINE2               LINE 2?\n         OI    DWD+7,X'0F'             PREVENT S0C7 IF NOT SPECIFIED\n         CVB   R5,DWD                  LAST LINE (.ZL)\n         LTR   R5,R5                   ANY VALUE SPECIFIED?\n         BNZ   PARM24                  YES, JUMP\n         BCTR  R5,0                    NO, MAKE IT X'FFFFFFFF'\n*\nPARM24   PACK  DWD,LINECT              LINE COUNT\n         OI    DWD+7,X'0F'             PREVENT S0C7 IF NOT SPECIFIED\n         ZAP   LINECT,DWD              LAST COUNT\n*\nPARM25   PACK  DWD,INITLINE            INITIAL LINES\n         OI    DWD+7,X'0F'             PREVENT S0C7 IF NOT SPECIFIED\n         ZAP   INITLINE,DWD            INITIAL LINES\n*---------------------------------------------------------------------*\n*                                                                     *\n*        OPEN THE OUTPUT DATA SET                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nOPEN2    LA    R0,DCB1                 BUILD OPEN LIST\n         ST    R0,OPENLIST             BUILD OPEN LIST\n         MVI   OPENLIST,X'8F'          BUILD OPEN LIST\n         OPEN  MF=(E,OPENLIST)         OPEN (DCB1,OUTPUT)\n         LTR   R15,R15\n         LA    R15,8                   OPEN FAILED\n         BNZ   EXIT15\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ISPLINK VDEFINE (LINE) CHAR                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         LA    R15,=C'ISREDIT '        COMMAND\n         LA    R0,=F'15'               LENGTH\n         LA    R1,=C'(LRECL) = LRECL'\n         STM   R15,R1,SIXWORDS         BUILD PARM LIST\n         OI    SIXWORDS+8,X'80'        MARK END OF LIST\n         L     R15,ISPLINK@            ISPF INTERFACE\n         LA    R1,SIXWORDS             PARM LIST\n         BALR  R14,R15              <- \"ISREDIT (LRECL) = LRECL\"\n         LTR   R15,R15\n         LA    R15,1000(R15)           ISREDIT FAILED\n         BNZ   EXIT15\n*\n         LA    R14,=C'VCOPY '          COMMAND\n         LA    R15,=C'(LRECL) = LRECL'\n         LA    R0,5                    LENGTH\n         ST    R0,DWD                  LENGTH\n         LA    R0,DWD                  LENGTH\n         LA    R1,COMMAND              WORK AREA\n         LA    R2,=C'MOVE'             WORK AREA\n         STM   R14,R2,SIXWORDS         BUILD PARM LIST\n         OI    SIXWORDS+16,X'80'       END OF LIST\n         L     R15,ISPLINK@            ISPF INTERFACE\n         LA    R1,SIXWORDS             PARM LIST\n         BALR  R14,R15              <- VCOPY,'LRECL','5',COMMAND,'MOVE'\n         LTR   R15,R15\n         LA    R15,1100(R15)           VCOPY FAILED\n         BNZ   EXIT15\n*\n         PACK  DWD,COMMAND(5)          LRECL\n         CVB   R1,DWD                  LRECL\n         ST    R1,LINE_LEN             LENGTH\n         LA    R0,8(,R1)               LENGTH OF DATA LINE\n         GETMAIN RU,LV=(0),LOC=ANY     ALLOC DATA LINE\n         ST    R1,LINE_ADDR            ADDRESS\n         LR    R8,R1\n         USING LINE,R8\n*\n         LA    R14,=C'VDEFINE'         FUNCTION\n         LA    R15,=C'LINE '           NAME\n         LA    R0,LINE+1               ADDRESS OF POS 2\n         LA    R1,=C'CHAR'             TYPE\n         LA    R2,LINE_LEN             LENGTH\n         STM   R14,R2,SIXWORDS         BUILD PARM LIST\n         OI    SIXWORDS+16,X'80'       MARK END OF LIST\n         L     R15,ISPLINK@            ISPF INTERFACE\n         LA    R1,SIXWORDS             PARAM\n         BALR  R14,R15              <- VDEFINE,'LINE',LINE,L'LINE\n         LTR   R15,R15\n         LA    R15,1200(R15)           VDEFINE FAILED\n         BNZ   EXIT15\n         MVC   COMMAND,=C'(LINE) = LINE 123456'\n         MVI   JESJCL,0                INITIALISE SWITCHES\n***********************************************************************\n*                                                                     *\n*        COPY THE DATA LINES TO THE OUTPUT DATA SET                   *\n*                                                                     *\n***********************************************************************\n*LOOP\nLOOP2    LA    R4,1(,R4)               NEXT LINE NUMBER\n         CVD   R4,DWD                  &I\n         OI    DWD+7,X'0F'             SUPPRESS SIGN\n         UNPK  COMMAND+14(6),DWD       123456\n         LA    R15,=C'ISREDIT '        COMMAND\n         LA    R0,=F'20'               LENGTH\n         LA    R1,COMMAND              COMMAND\n         STM   R15,R1,SIXWORDS         BUILD PARM LIST\n         OI    SIXWORDS+8,X'80'        MARK END OF LIST\n         L     R15,ISPLINK@            ISPF INTERFACE\n         LA    R1,SIXWORDS             PARAM\n         BALR  R14,R15                 CALL ISPLINK\n         CH    R15,=H'12'              INVALID LINE NUMBER\n         BE    EXIT00                  QUIT\n         LTR   R15,R15\n         LA    R15,1200(R15)           ISPLINK FAILED\n         BNZ   EXIT15\n*\n         ZAP   LINECT,LINECT           PAGE SKIP REQUIRED?\n         BZ    LOOP2JCL                NO, JUMP\n         MVC   DWD(4),LINE+1           .SK COMMAND?\n         OC    DWD(4),=C'    '         CONVERT TO UPPERCASE\n         CLC   DWD(4),=C'.SK '          .SK COMMAND?\n         BE    LOOP2SK                 YES, JUMP\n         MVI   LINE,C' '               SINGLE SPACE\n         CP    INITLINE,LINECT         END-OF-PAGE?\n         BL    LOOP2P1                 NO, JUMP\n         MVI   LINE,C'1'               NEW PAGE\n         SP    INITLINE,INITLINE       RESET CTR\nLOOP2P1  LA    R1,LINE                 LINE ADDRESS\n         BAL   R14,PUTLINE          <- WRITE LINE\n         AP    INITLINE,=P'1'          COUNT LINES\n         B     LOOP2NXT                NEXT LINE\n*\nLOOP2SK  MVI   INITLINE,X'99'          FORCE NEW PAGE NEXT TIME\n         B     LOOP2NXT                NEW PAGE\n*\n*        CHANGE X'09' TO C' ' IN JESJCL\n*        FORCE NEW PAGE AT THE BEGINNING OF JESJCL AND JESYSMSG\n*\nLOOP2JCL TM    DCB1RECFM,DCBRECCA      RECFM=.A?\n         BNO   LOOP2J99                NO, EXIT\n         CLI   JESJCL,3                JCL PROCESSED ALREADY?\n         BE    LOOP2J99                YES, EXIT\n         CLI   LINE+1,X'09'            SINGLE SPACE?\n         BNE   LOOP2J20                NO, JUMP\nLOOP2J05 TM    JESJCL,1                JOB CARD PROCESSED ALREADY?\n         BO    LOOP2J40                YES, JUMP\n         CLC   =C' 1 //',LINE+1+8      IS THIS A JOB CARD?\n         BNE   LOOP2J99                NO, EXIT\n         OI    JESJCL,1                JOB CARD SEEN\n         MVI   LINE+1,C'1'             NEW PAGE\n         B     LOOP2J99                EXIT\nLOOP2J20 TM    JESJCL,1                JOB CARD PROCESSED ALREADY?\n         BZ    LOOP2J99                NO, EXIT\n         OI    JESJCL,2                END OF JESJCL FILE\n         CLI   LINE+1,X'40'            SINGLE SPACE?\n         BNE   LOOP2J99                NO, EXIT\n         MVI   LINE+1,C'1'             START OF SYSTEM MESSAGES\n         B     LOOP2J99                EXIT\nLOOP2J40 MVI   LINE+1,C' '             SINGLE SPACE (ASA)\nLOOP2J99 EQU   *\n*\nLOOP2P2  LA    R1,LINE+1               LINE ADDRESS\n         BAL   R14,PUTLINE          <- WRITE LINE\n*\nLOOP2NXT CLR   R4,R5                   LAST LINE REACHED?\n         BL    LOOP2                   NOT YET, PROCESS NEXT LINE\n*ENDLOOP\nEXIT00   SLR   R15,R15                 RC=00\n***********************************************************************\n*                                                                     *\n*        RETURN TO CALLER                                             *\n*                                                                     *\n***********************************************************************\nEXIT15   LR    R2,R15                  SAVE RETURN CODE\n         TM    DCB1OFLGS,DCBOFOPN      DCB OPEN?\n         BZ    EXIT42                  NO, SKIP CLOSE\n         CLOSE MF=(E,OPENLIST)         CLOSE DCB\n         FREEPOOL DCB1                 FREE BUFFERS\n*\nEXIT42   EQU   *\n         L     R1,LINE_LEN             LENGTH OF DATA LINE\n         LA    R0,8(,R1)               LENGTH OF WORK AREA\n         FREEMAIN RU,LV=(0),A=(R8)     FREE DATA LINE\n         LR    R1,R13                  A(DYNAM)\n         L     R13,4(,R13)\n         FREEMAIN R,LV=DYNAML,A=(1)    FREE DYNAMIC STORAGE\n         LR    R15,R2                  PASS RETURN CODE\n         RETURN (14,12),RC=(15)        GOBACK TO CALLER WITH RC IN R15\n*---------------------------------------------------------------------*\n*        WRITE A LINE (RECFM=F/V/U)                                   *\n*---------------------------------------------------------------------*\nPUTLINE  ST    R14,R14PUTL             SAVE RETURN ADDRESS\n         TM    DCB1RECFM,DCBRECV       RECFM=F (NOT V, NOT U) ?\n         BZ    PUTLINE8                YES, JUMP\n*\n*        IF RECFM=V/U, TRUNCATE TRAILING BLANKS\n*\n         L     R15,LINE_LEN            CURRENT LENGTH OF THE LINE\n         LA    R15,LINE+1(R15)         1ST CHAR AFTER END OF LINE\n         BCTR  R15,0                   LAST CHAR IN LINE\n         SLR   R0,R0\n         BCTR  R0,0                    R0=-1 (INCREMENT FOR BXH)\n*LOOP\nPUTLINE4 CLI   0(R15),C' '             IS IT A SPACE?\n         BNE   PUTLINE5                NO, EXIT\n         BXH   R15,R0,PUTLINE4         PREV CHAR\n*ENDLOOP\nPUTLINE5 LA    R15,1(,R15)             FIRST BLANK\n         SLR   R15,R1                  CALC LENGTH\n         TM    DCB1RECFM,DCBRECU       RECFM=U?\n         BO    PUTLINE7                YES, JUMP\n         SH    R1,=H'4'                POINT AT RDW\n         LA    R15,4(,R15)             ADD 4 BYTES FOR THE RDW\n         SLL   R15,16                  MAKE LENGTH A RDW\n         ST    R15,0(,R1)              STORE RDW\n         B     PUTLINE8\n*\nPUTLINE7 STH   R15,DCB1LRECL           PASS LENGTH FOR RECFM=U\n*\nPUTLINE8 LR    R0,R1                   RECORD ADDRESS\n         PUT   DCB1,(R0)               WRITE A FIXED-LENGTH RECORD\n         L     R14,R14PUTL             LOAD RETURN ADDRESS\n         BR    R14                     GOBACK\n         DROP\n***********************************************************************\n*                                                                     *\n*        DATA                                                         *\n*                                                                     *\n***********************************************************************\nDCB1MOD  DCB   DSORG=PS,MACRF=PM,DDNAME=ISREDIT,EXLST=EXL1\n$CONTROL DC    C'CONTROL'              FUNCTION\n$ERRORS  DC    C'ERRORS'               OPTION\n$RETURN  DC    C'RETURN'               OPTION\nVL       EQU   X'80000000'             END OF LIST INDICATOR\n*\n*        OPEN EXIT\n*\n*        1. SETS DEFAULT ATTRIBUTES: RECFM=FB,LRECL=80\n*\n*        2. SETS BLKSIZE=0 TO TAKE ADVANTAGE OF SYSTEM-DETERMINED\n*           BLKSIZE FOR SPFTEMP% DATA SETS.\n*\nEXL1     DC    A(OPENEXIT+X'85000000')\n         USING OPENEXIT,R15\n         USING IHADCB,R1\nOPENEXIT CLI   DCBRECFM,0              RECFM SPECIFIED?\n         BNZ   OPENEX4                 YES, JUMP\n         MVI   DCBRECFM,DCBRECF+DCBRECBR NO, RECFM=FB\nOPENEX4  TM    DCBRECFM,DCBRECBR       RECFM=.B ?\n         BZR   R14                     NO, EXIT\n         XC    DCBBLKSI,DCBBLKSI       BLKSIZE=0\n         ICM   R0,B'1100',DCBLRECL     LRECL > 0 ?\n         BNZR  R14                     YES, EXIT\n         MVI   DCBLRECL+1,80           NO, LRECL=80\n         BR    R14\n***********************************************************************\n*                                                                     *\n*        WORKING-STORAGE AREA                                         *\n*                                                                     *\n***********************************************************************\nDYNAM    DSECT\n         DS    18F\nISPLINK@ DS    V(ISPLINK)\nSIXWORDS DS    6F\nR14PUTL  DS    A(R14)\nLINE1    DS    Z'123456'               FIRST LINE (.ZF)\nLINE2    DS    Z'123456'               LAST LINE (.ZL)\nLINECT   DS    Z'123'                  LINE COUNT (60)\nINITLINE DS    Z'123'                  LINE ALREADY WRITTEN ON 1ST PAGE\nCOMMAND  DS    C'(LINE) = LINE 123456'\nJESJCL   DS    X                       JESJCL SWITCHES\nLINE_ADDR DS   V(LINE)                 ADDR OF DATA LINE\nLINE_LEN DS    A(L'LINE)               LENGTH OF LINE\nDWD      DS    D\nOPENLIST OPEN  (DCB1,OUTPUT),MF=L\nDCB1     DCB   DSORG=PS,MACRF=PM,DDNAME=ISREDIT,EXLST=EXL1\nDCB1L    EQU   *-DCB1\nDCB1RECFM EQU  DCBRECFM-IHADCB+DCB1    RECFM\nDCB1DDNAM EQU  DCBDDNAM-IHADCB+DCB1    DDNAME\nDCB1OFLGS EQU  DCBOFLGS-IHADCB+DCB1    OPEN FLAGS\nDCB1LRECL EQU  DCBLRECL-IHADCB+DCB1    LRECL\nDYNAML   EQU   *-DYNAM\n*\nLINE_DSECT DSECT\nLINE_RDW DS    Y(L'LINE,0)             RDW FOR RECFM=V\nLINE     DS    CL32760                 DATA LINE\n         DROP\n***********************************************************************\n*                                                                     *\n*        PARSE A COMMA-DELIMITED JCL PARM                             *\n*                                                                     *\n*        L     R15,=V(PARSE)                                          *\n*        BALR  R14,R15                                                *\n*        DC    S(L'PARM1,PARM1)        LENGTH,ADDR                    *\n*        DC    S(L'PARM2,PARM2)        LENGTH,ADDR                    *\n*                                                                     *\n***********************************************************************\nPARSE    RSECT\nPARSE    RMODE ANY\n         SAVE  (14,12),,PARSE\n         LR    R11,R15\n         USING PARSE,R11\n**       L     R1,4(,R13)              CALLER'S SAVE AREA\n**       L     R1,24(,R1)              R1 ON ENTRY\n         L     R2,0(,R1)               JCL PARM\nPARSEX40 EQU   *+1,1                   X'40'\n         LA    R4,1(,R2)               START OR PARM - 1\n         LH    R5,0(,R2)               LENGTH OF PARM\n         ALR   R5,R4                   LAST BYTE OF PARM\n*LOOP\nPARS1    SLR   R0,R0                   R0 = 00000000\n         ICM   R0,B'0011',2(R14)       R0 = 0000BDDD\n         SRDL  R0,12(0)                R0 = 0000000B, R1= BBB.....\n         SRL   R1,20(0)                R1 = 00000DDD DISPLACEMENT\n         CLI   2(R14),R13*16           IS R13 THE BASE REG?\n         BL    PARS1D                  NO, JUMP\n         ALR   R1,R13                  ADD CALLER'S SAVE AREA ADDR\n         B     PARS1E\nPARS1D   LR    R15,R0                  R15= 0000000B BASE\n         SLL   R15,2                   R15= 000000BB BASE * 4\n         AL    R1,20(R13,R15)          ADD BASE REG VALUE TO DISPL\nPARS1E   LR    R6,R1                   ADDR OF TARGET FIELD\n         LH    R7,0(,R14)              LENGTH OF TARGET FIELD\n*\n         LA    R2,1(,R4)               FIRST BYTE OF CURRENT PARAMETER\n*--LOOP\nPARS2    LA    R4,1(,R4)               ,\n         CLR   R4,R5                   END OF PARM REACHED?\n         BH    PARS41                  YES, EXIT LOOP\n         CLI   0(R4),C','\n         BNE   PARS2\n*--ENDLOOP\nPARS41   LR    R3,R4                   POSITION OF ','\n         SR    R3,R2                   LENGTH OF SOURCE PARAM\n         ICM   R3,B'1000',PARSEX40     PADDING\n         MVCL  R6,R2                   MOVE SOURCE TO TARGET\nPARS44   LA    R14,2+2(,R14)           NEXT TARGET\n         CLI   0(R14),0                IS THIS A FIELD DESCRIPTOR?\n         BE    PARS1                   YES, PROCESS IT\n*ENDLOOP\n         RETURN (0,12),T\n         PRINT NOGEN\n         YREGS                         SYS1.MACLIB\n         DCBD  DSORG=PS                SYS1.MACLIB\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//LKED    EXEC PGM=HEWL,PARM='MAP,RENT,REFR'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,DELETE)\n//SYSLMOD  DD DSN=CBTTAPE.FILE183.LOAD(ROUTEPGM),DISP=SHR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXSMS": {"ttr": 16140, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x00\\x930o\\x00\\x994o\\x15$\\x02\\xb0\\x00-\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-11-02T00:00:00", "modifydate": "1999-12-12T15:24:09", "lines": 688, "newlines": 45, "modlines": 0, "user": "CBT476"}, "text": "//GILBERTR JOB (ACCT#),RXSMS,\n//*RESTART=TMP,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,\n// PARM='OBJECT,NODECK,NOESD,NORLD,NOXREF,USING(WARN(8))'\n***********************************************************************\n*                                                                     *\n*            COPYRIGHT (C) 1993-1999 GILBERT SAINT-FLOUR              *\n*                       ALL RIGHTS RESERVED                           *\n*                                                                     *\n* MODULE NAME = RXSMS                                                 *\n*                                                                     *\n* DESCRIPTIVE NAME = Retrieve SMS Information in a REXX exec          *\n*                                                                     *\n* STATUS = R100                                                       *\n*                                                                     *\n* FUNCTION = This assembler sub-routine can be invoked in a REXX      *\n*            exec to retrieve information from the SMS sub-system     *\n*            or from a volume's VTOC.                                 *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*          http://gsf-soft.com/Freeware/                              *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*    DEPENDENCIES: MVS/ESA 4.3 (or above) or OS/390 or z/OS           *\n*                  STRING macro                                       *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (CSECT TYPE)                               *\n*                                                                     *\n*    PROCESSOR = IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 2K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE ANY, AMODE 31,                   *\n*                 PROBLEM STATE, KEY 8                                *\n*                 APF AUTHORIZATION: NONE                             *\n*                                                                     *\n* SYNTAX  =  See below                                                *\n*                                                                     *\n*    CALL RXSMS     function,                                         *\n*                   stemname                                          *\n*                   <,search argument>                                *\n*      or                                                             *\n*                                                                     *\n*    rc=RXSMS(function,stemname<,search argument>)                    *\n*                                                                     *\n*    Arguments:                                                       *\n*                                                                     *\n*         function  This argument is a 3-character function code      *\n*                   which indicates the type of information that      *\n*                   is to be retrieved from SMS.  The following       *\n*                   values are supported:                             *\n*                                                                     *\n*                     AVL   All volumes in current configuration      *\n*                     SGL   List of all Storage Groups                *\n*                     SGV   Volser list for a given Storage Group     *\n*                     VSG   Storage Group for a given volser          *\n*                     VOL   Volume definition for a given volser      *\n*                     DCL   List of all Data Classes                  *\n*                     SCL   List of all Storage Classes               *\n*                     MCL   List of all Management Classes            *\n*                     LSP   LSPACE                                    *\n*                                                                     *\n*         stemname  the stem of the family of variables which         *\n*                   are set to the returned data.                     *\n*                                                                     *\n*         search arg  is the volser or SG name for which data is      *\n*                     to be retrieved from SMS.  This argument        *\n*                     is mandatory for the SGV, VSG and VOL           *\n*                     functions and must be omitted for all           *\n*                     other function.                                 *\n*                                                                     *\n*    Examples:                                                        *\n*                                                                     *\n*         Retrieve a list of all of the Data Classes currently        *\n*         defined in the SMS configuration into the \"dc.\" variable.   *\n*                                                                     *\n*            CALL RXSMS 'DCL','dc.'                                   *\n*            IF rc=0 THEN DO i=1 TO dc.0                              *\n*              SAY i 'SC =' sc.i                                      *\n*            END                                                      *\n*                                                                     *\n*         Retrieve the Storage Group to which the VOL123 volume       *\n*         belongs into the sg.1 variable:                             *\n*                                                                     *\n*            IF RXSMS('VSG','sg.','VOL123') THEN                      *\n*              SAY 'volume VOL123 belongs to SG=' sg.1                *\n*                                                                     *\n*         Retrieve all the volumes that belong to the \"SGPROD2\"       *\n*         Storage Group into the \"vol.\" variables:                    *\n*                                                                     *\n*            IF RXSMS('SGV','vol.') = 0 THEN                          *\n*              DO i=1 TO vol.0                                        *\n*               SAY i 'VOL:' vol.i                                    *\n*              END                                                    *\n*                                                                     *\n* Format of the Data Returned                                         *\n*                                                                     *\n*         RXSMS returns three types of data:                          *\n*                                                                     *\n*         1. a return-code in the RC variable;                        *\n*            see \"return-codes\" below.                                *\n*                                                                     *\n*         2. the number of objects returned, in the stem.0            *\n*            variable.  For example, if CALL RXSMS 'SGL','sg.'        *\n*            is issued, the number of Storage Groups is returned      *\n*            in the sg.0 variable.                                    *\n*                                                                     *\n*         3. the objects requested are returned in var.1 through      *\n*            var.n, where n=var.0                                     *\n*                                                                     *\n*            The format of the data returned depends on the type      *\n*            of object it represents.  The following table shows      *\n*            the format of the data for each of the supported         *\n*            function codes:                                          *\n*                                                                     *\n*              AVL   Volume record (12 words)                         *\n*              SGL   Storage Group record (10 words)                  *\n*              SGV   Volume record (12 words)                         *\n*              VSG   Storage Group record (10 words)                  *\n*              VOL   Volume record (12 words)                         *\n*              DCL   Data Class name (1 to 30 characters)             *\n*              SCL   Storage Class name (1 to 30 characters)          *\n*              MCL   Management Class name (1 to 30 characters)       *\n*              LSPACE Data returned by the LSPACE macro               *\n*                                                                     *\n*    The Volume record is made up of 12 words (see example below).    *\n*                                                                     *\n*      1   volume serial number                                       *\n*      2   name of storage group                                      *\n*      3   user-ID of last updater                                    *\n*      4   date of last update                                        *\n*      5   time of last update                                        *\n*      6   track capacity (bytes)                                     *\n*      7   ucb address (or zero if the device is off-line)            *\n*      8   total space (MB)                                           *\n*      9   free space (MB)                                            *\n*     10   largest free extent (MB)                                   *\n*     11   flags (VLDFLAGS)                                           *\n*     12   status in storage group (VLDSGST)                          *\n*                                                                     *\n*    Example of a volume record, as returned from RXSMS:              *\n*                                                                     *\n*      PRIM10 SG2 JIM 1997/03/27 16:03 56664 F49F00 2042 179 67 00 01 *\n*                                                                     *\n*    The Storage Group record is made up of 10 words.                 *\n*                                                                     *\n*      1   name of storage group                                      *\n*      2   user-ID of last updater                                    *\n*      3   date of last update                                        *\n*      4   time of last update                                        *\n*      5   flags (SDGFLAGS)                                           *\n*      6   SG type (0=pool, 1=VIO)                                    *\n*      7   VIO max size (MB)                                          *\n*      8   VIO unit type                                              *\n*      9   high threshold (0-99%)                                     *\n*     10   low threshold (0-99%)                                      *\n*     11   description (max 30 characters)                            *\n*                                                                     *\n*    Example of a storege group record, as returned from RXSMS:       *\n*                                                                     *\n*       SG2 JIM 1996/06/03 20:57 10 0 0 ? 99 0 DEFAULT STORAGE GROUP  *\n*                                                                     *\n*    The LSPACE record is made up of 19 words.                        *\n*                                                                     *\n*      1   volume serial                                              *\n*      2   LSPACE return area status byte                             *\n*      3   LSPACE volume status byte                                  *\n*      4   Number of free extents                                     *\n*      5   total free cylinders                                       *\n*      6   total additional free tracks                               *\n*      7   number of cylinders in largest free extent                 *\n*      8   number of additional tracks in largest free extent         *\n*      9   format-0 count                                             *\n*     10   free VIR count                                             *\n*     11   fragmentation index                                        *\n*     12   VTOC index (DS4VTOCI)                                      *\n*     13   Volume's SMS attributes (DS4SMSFG)                         *\n*     14   available DSCBs (DS4DSREC)                                 *\n*     15   Number of Cylinders (DS4DEVSZ)                             *\n*     16   Tracks per Cylinders (DS4DEVSZ)                            *\n*     17   Track Size (DS4DEVTK)                                      *\n*     18   DSCBs per track (DS4DEVDT)                                 *\n*     19   Directory Blocks per track (DS4DEVDB)                      *\n*                                                                     *\n*    Example of a LSPACE record, as returned from RXSMS:              *\n*                                                                     *\n*     SYSCAT E0 C0 2 0 4 0 2 235 14 1000 81 00 262 100 15 47968 53 46 *\n*                                                                     *\n* RETURN-CODES = See below                                            *\n*                                                                     *\n*         The RXSMS function returns a return code that indicates     *\n*         whether information was successfully retrieved.  The        *\n*         return-code is stored into the RC special variable.         *\n*                                                                     *\n*         The following RXSMS return code values are possible:        *\n*                                                                     *\n*         0    Data was retrieved into the specified stem variable.   *\n*              var.0 is set to the number of objects retrieved.       *\n*                                                                     *\n*         4    No data was retrieved; var.0 is set to 0.              *\n*                                                                     *\n*         nnnn   Error retrieving the data, nnnn is the SSSA          *\n*                reason code (see IEFSSSA macro).                     *\n*                                                                     *\n*         1nn    UCBSCAN macro failed with R15=nn (LSPACE only)       *\n*                                                                     *\n*         2nn    LSPACE macro failed with R15=nn (LSPACE only)        *\n*                                                                     *\n*   Error in Argument List                                            *\n*                                                                     *\n*         12   Invalid Service requested.                             *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n* 100 Initial release                                                 *\n*                                                                     *\n&REL     SETC  'R100'                                                 *\n***********************************************************************\nRXSMS    CSECT\nRXSMS    RMODE ANY\n         SAVE  (14,12),,'GSF Utilities - RXSMS &REL'\n         LR    R12,R15\n         USING RXSMS,R12\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ALLOCATE DYNAMIC STORAGE                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         GETMAIN R,LV=DYNAML\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LA    R14,72(,R1)             CLEAR WORKING STORAGE\n         LA    R15,DYNAML-72           CLEAR WORKING STORAGE\n         SLR   R1,R1                   CLEAR WORKING STORAGE\n         MVCL  R14,R0                  CLEAR WORKING STORAGE\n         LM    R13,R1,8(R13)           SET R13, RELOAD R14-R1\n         USING DYNAM,R13\n         ST    R0,ADDR_OF_ENVBLOCK     ENVIRONMENT BLOCK\n         ST    R1,ADDR_OF_EFPL         External Function Parm List\n         MVI   BLANKS,C' '             a bunch of blanks\n         MVC   BLANKS+1(L'BLANKS-1),BLANKS\n*---------------------------------------------------------------------*\n*                                                                     *\n*        BUILD THE SHVBLOCK                                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         USING SHVBLOCK,DYNAM_SHVB\n         MVI   SHVCODE,SHVSTORE        STORE VARIABLE\n         LA    R0,VALUE                ADDRESS OF VALUE BUFFER\n         ST    R0,SHVVALA              ADDRESS OF VALUE BUFFER\n         LA    R0,VARNAME              ADDRESS OF VARIABLE NAME\n         ST    R0,SHVNAMA              ADDRESS OF VARIABLE NAME\n         L     R15,ADDR_OF_ENVBLOCK    Environment block\n         L     R15,ENVBLOCK_IRXEXTE-ENVBLOCK(,R15) A(IRXEXTE)\n         L     R15,IRXEXCOM-IRXEXTE(,R15)          A(IRXEXCOM)\n         L     R0,ADDR_OF_ENVBLOCK     ENVIRONMENT BLOCK\n         LA    R1,IRXEXCOM_PARM        parm list\n         STM   R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         LA    R14,=C'IRXEXCOM'        Shared Variable Routine\n         SLR   R15,R15                 PARM2=0\n         SLR   R0,R0                   PARM3=0\n         LA    R1,SHVBLOCK             PARM4\n         STM   R14,R1,IRXEXCOM_PARM    build parm list for IRXEXCOM\n         OI    IRXEXCOM_PARM+12,X'80'  VL=1\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS ARGUMENTS                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         USING IEFSSSA,SSSA_WRK\n         L     R1,ADDR_OF_EFPL         External Function Parm List\n         L     R11,EFPLARG-EFPL(,R1)   ADDR OF ARG LIST\n         LM    R2,R3,8*1-8(R11)        1st ARG (service)\n         LTR   R3,R3                   service specified?\n         BNP   ARG1N                   no, error\n         CH    R3,=H'3'                length=3?\n         BNE   ARG1N                   no, jump\n         BAL   R1,ARG1L                br around table\n         DC    AL1(SSSA1SGL),C'SGL'    SG list\n         DC    AL1(SSSA1SGV),C'SGV'    volser list for given SG\n         DC    AL1(SSSA1AVL),C'AVL'    all volumes in config\n         DC    AL1(SSSA1VSG),C'VSG'    SG for a volser\n         DC    AL1(SSSA1VOL),C'VOL'    return volume definition\n         DC    AL1(SSSA1DCL),C'DCL'    DC list\n         DC    AL1(SSSA1SCL),C'SCL'    SC list\n         DC    AL1(SSSA1MCL),C'MCL'    MC list\n         DC    X'FF',0H'0'             end of table\n*loop\nARG1L    CLC   1(3,R1),0(R2)           compare function code\n         BE    ARG1T                   match, leave\n         LA    R1,1+3(,R1)             next entry in the table\n         CLI   0(R1),X'FF'             end of table?\n         BNE   ARG1L                   no, next entry\n*endloop\nARG1N    EQU   *                       no service specified\n         CH    R3,=H'6'                length=6?\n         BNE   ARG1N2                  no, error\n         CLC   =C'LSPACE',0(R2)        FUNC=LSPACE?\n         BNE   ARG1N2                  no, error\n         MVI   SSSA1TYP,X'EE'          save SSSA1 function code\n         B     ARG1X\nARG1N2   EQU   *                       no service specified\n         B     EXIT12                  no service, exit with RC=12\nARG1T    EQU   *                       no service specified\n         MVC   SSSA1TYP,0(R1)          save SSSA1 function code\nARG1X    EQU   *\n*\n         LM    R2,R3,8*2-8(R11)        2ND ARG (VAR NAME)\n         STM   R2,R3,STEMNAME          2ND ARG (VAR NAME)\n         LTR   R3,R3                   stemname specified?\n         BNP   EXIT12                  no var name, exit with RC=12\n         OI    0(R2),X'40'             convert to uppercase\n         LA    R2,1(,R2)               convert to uppercase\n         BCT   R3,*-8                  convert to uppercase\nARG2X    EQU   *\n*\n         LM    R2,R3,8*3-8(R11)        3rd ARG (search arg)\n         LTR   R3,R3                   zero length?\n         BZ    ARG3X                   yes, jump\n         BM    ARG9X                   eof, exit\n         MVI   SSSA1CNT+3,1            COUNT=1\n         STRING ((R2),(R3)),INTO=SSSA1NAM move SG/vol name\n         STH   R15,SSSA1NML            save length\nARG3X    EQU   *\n*\nARG9X    EQU   *                       end of arg list\n         CLI   SSSA1TYP,X'EE'          func=LSPACE?\n         BE    LSPACE1                 yes, go there\n*---------------------------------------------------------------------*\n*                                                                     *\n*        BUILD SSOB                                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n         USING SSOB,SSOB_WRK\n         LA    R0,SSOB                 SSOB address\n         ST    R0,SSOB_PTR             SAVE ADDRESSES\n         OI    SSOB_PTR,X'80'          SSOB_PTR\n         MVC   SSOBID,=C'SSOB'         CB ACRONYM\n         LA    R0,SSOBHSIZ             LENGTH OF THE SSOB\n         STH   R0,SSOBLEN              STORE INTO SSOB\n         LA    R0,SSOBSSMS             FUNCTION CODE 55\n         STH   R0,SSOBFUNC             STORE INTO SSOB\n*\n         L     R1,CVTPTR               CVT\n         L     R1,CVTJESCT-CVTMAP(,R1) JES COMM TABLE\n         L     R1,JESCTEXT-JESCT(,R1)  JESCT EXTENSION\n         MVC   SSOBSSIB,JESSMSIB-JESPEXT(R1) SMS SSIB\n*\n*        BUILD SSSA\n*\n         LA    R8,SSSA_WRK             SSSA WORK AREA\n         ST    R8,SSOBINDV             FUNCTION-DEPENDENT AREA\n         LA    R0,SSSALN+SSSA1LN+L'SSSA1NMS\n         STH   R0,SSSALEN              LENGTH OF SSSA\n         MVC   SSSAID,=C'SSSA'         CB ACRONYM\n         MVI   SSSAVER+1,SSOBSSVR      VERSION\n         MVI   SSSASFN+1,SSSAACTV      SUB-FUNCTION CODE\n         MVI   SSSAIFLG,SSSANAUT       NON-AUTHORIZED CALLER\n*\n*        ISSUE THE IEFSSREQ MACRO\n*\n         LA    R1,SSOB_PTR             SSOB_PTR\n         IEFSSREQ                  <== CALL SMS\n*\n*        PROCESS THE RETURNED DATA\n*\n         L     R4,SSSA1PTR             ADDR OF RETURNED DATA\n         USING IGDVLD,R4\n         L     R5,SSSA1ALN             LENGTH\n         ICM   R7,B'1111',SSSARSN      reason code from sub-function\n         BNZ   SET_RC                  error, quit\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Set var.0 to number of objects returned                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n         LTR   R1,R4                   any data returned?\n         BZ    *+8                     no, do not use VLDPCNT\n         L     R1,VLDPCNT              number of items returned\n         STRING ((R1),,L),INTO=VALUE   edit number of objects\n         ST    R15,SHVVALL             save length into shvblock\n         SLR   R5,R5                   var.0\n         BAL   R14,SETVAR           <- set variable\n         LTR   R4,R4                   any data returned?\n         BZ    GOBACK4                 no, exit\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Set stem variables                                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         LA    R5,1                    suffix for stem variable\n         LA    R6,VLDEF                first definition\n         USING VLDEF,R6\n*loop\nLOOP1    LH    R0,VLDVSLEN             length of object name\n         ST    R0,SHVVALL              save into shvblock\n         LA    R1,VLDVSER              name of object\n         ST    R1,SHVVALA              save into shvblock\n         CLC   =CL8'IGDVLD',VLDPID     is this a VLD?\n         BNE   LOOP5                   no, return only the object name\n         BAL   R14,VLD00            <- edit the volume definition\n         B     LOOP8                   no, return only the object name\nLOOP5    CLC   =CL8'IGDSGD',VLDPID     is this an SGD?\n         BNE   LOOP8                   no, return only the object name\n         BAL   R14,SGD00            <- edit the storgrp definition\nLOOP8    BAL   R14,SETVAR           <- set variable\n*@SNAP VLDFNAME,(VARNAME,12)\n         LA    R5,1(,R5)               next i\n         AL    R6,VLDPLEN              next definition\n         CL    R5,VLDPCNT              finished?\n         BNH   LOOP1                   not yet\n*endloop\n         L     R1,SSSA1PTR             ADDR OF RETURNED DATA\n         L     R2,SSSA1ALN             LENGTH\n         FREEMAIN RU,A=(R1),LV=(R2)    Free data area returned by SMS\n         B     GOBACK\n         DROP  R4,R6                   IGDVLD,VLDEF\n*---------------------------------------------------------------------*\n*                                                                     *\n*        FUNC=LSPACE                                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\nLSPACE1  EQU   *\n         LA    R4,UCBAREA48            copy of the UCB\n         UCBSCAN COPY,                                                 X\n               VOLSER=SSSA1NAM,                                        X\n               UCBAREA=(R4),                                           X\n               DYNAMIC=YES,                                            X\n               WORKAREA=WORK256,                                       X\n               MF=(E,UCBSCANL,COMPLETE)\n         LTR   R7,R15\n         LA    R7,100(,R15)            rc=1nn\n         BNZ   SET_RC\n         MVC   LSPACEL(LSPACELL),LSPACEM\n         LSPACE UCB=(R4),DATA=LSPACED,F4DSCB=IECSDSL4,MF=(E,LSPACEL)\n         LTR   R7,R15\n         LA    R7,200(,R15)            rc=2nn\n         BNZ   SET_RC\n         USING LSPDATA,LSPACED\n         STRING (SSSA1NAM,,T),         VOLUME SERIAL                   X\n               1X,(LSPDRETN,,X),       RETURN AREA STATUS BYTE         X\n               1X,(LSPDSTAT,,X),       VOLUME STATUS BYTE              X\n               1X,(LSPDNEXT,F,L),      NUMBER OF FREE EXTENTS          X\n               1X,(LSPDTCYL,F,L),      TOTAL FREE CYLINDERS            X\n               1X,(LSPDTTRK,F,L),      TOTAL ADDITIONAL FREE TRKS      X\n               1X,(LSPDLCYL,F,L),      NUMBER OF CYLINERS IN           X\n               1X,(LSPDLTRK,F,L),      NUMBER OF ADDL TRACKS IN        X\n               1X,(LSPDF0S,F,L),       FORMAT 0 COUNT                  X\n               1X,(LSPDVIRS,F,L),      FREE VIR COUNT                  X\n               1X,(LSPDFRAG,F,L),      FRAGMENTATION INDEX             X\n               1X,(DS4VTOCI,,X),       VTOC INDEX                      X\n               1X,(DS4SMSFG,,X),       SMS FLAGS                       X\n               1X,(DS4DSREC,FL2,L),    NUMBER OF AVAILABLE DSCBS       X\n               1X,(DS4DEVSZ,FL2,L),    NUMBER OF CYLINDERS             X\n               1X,(DS4DEVSZ+2,FL2,L),  NUMBER OF TRACKS PER CYLINDER   X\n               1X,(DS4DEVTK,FL2,L),    TRACK CAPACITY                  X\n               1X,(DS4DEVDT,FL1,L),    NO OF DSCBS PER TRACK           X\n               1X,(DS4DEVDB,FL1,L),    DIR BLOCKS PER TRACK            X\n               INTO=VALUE\n         ST    R15,SHVVALL             save length into shvblock\n         LA    R5,1                    var.1\n         BAL   R14,SETVAR           <- set variable\n         MVI   VALUE,C'1'              var.0=1\n         LA    R15,1                   length=1\n         ST    R15,SHVVALL             save length into shvblock\n         SLR   R5,R5                   var.0\n         BAL   R14,SETVAR           <- set variable\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Set return code                                              *\n*                                                                     *\n*---------------------------------------------------------------------*\nGOBACK   SLR   R7,R7                   RC=0: OK\n         B     SET_RC\nGOBACK4  LA    R7,4                    RC=4: \"no data returned\"\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Pass return code in RC variable                              *\n*                                                                     *\n*---------------------------------------------------------------------*\nSET_RC   EQU   *\n         LA    R0,VALUE                addr of value\n         ST    R0,SHVVALA              save addr into shvblock\n         STRING ((R7),,L),INTO=VALUE   edit RC\n         ST    R15,SHVVALL             save length into shvblock\n         MVC   VARNAME(2),=C'RC'       variable name\n         LA    R15,2                   LENGTH OF VARIABLE NAME\n         ST    R15,SHVNAML             LENGTH OF VARIABLE NAME\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         SYNCH (R15)                   CALL IRXEXCOM\n*\n*        return RC value into EVALBLOCK\n*\n         L     R1,ADDR_OF_EFPL         External Function Parm List\n         L     R2,EFPLEVAL-EFPL(,R1)   addr of EVALBLOCK ptr\n         L     R4,0(,R2)               addr of EVALBLOCK\n         USING EVALBLOCK,R4\n         STRING ((R7),,L),INTO=(EVALBLOCK_EVDATA,8)\n         ST    R15,EVALBLOCK_EVLEN     store length\n         DROP  R4                      EVALBLOCK\n*\n         SLR   R7,R7                   RC=0\n         B     EXIT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CLEAN-UP AND EXIT                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\nEXIT12   LA    R7,12                   RC=12: input parameter error\n*\nEXIT     LR    R1,R13                  A(DYNAM)\n         L     R13,4(,R13)\n         FREEMAIN R,LV=DYNAML,A=(R1)\n         LR    R15,R7                  pass return code\n         RETURN (14,12),RC=(15)\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Set a variable                                               *\n*                                                                     *\n*        1. build variable name by concatenating the stem name        *\n*           (such as \"SG.\") to the sequence number in R5              *\n*        2. pass control to IRXEXCOM                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\nSETVAR   BAKR  R14,0\n         LM    R2,R3,STEMNAME          2ND ARG (VAR NAME)\n         STRING ((R2),(R3)),((R5),,L),INTO=VARNAME\n         ST    R15,SHVNAML             LENGTH OF VARIABLE NAME\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         SYNCH (R15)                   CALL IRXEXCOM\n         PR\n***********************************************************************\n*                                                                     *\n*        Edit a volume definition                                     *\n*                                                                     *\n***********************************************************************\nVLD00    BAKR  R14,0\n         LA    R1,VALUE                point at string\n         ST    R1,SHVVALA              save addr into shvblock\n         USING VLDEF,R6\n         LH    R1,VLDVSLEN             length of vol ser\n         LH    R2,VLDSGLEN             length of stor grp\n         STRING (VLDVSER,(R1)),        volume serial                   X\n               1X,(VLDSTGRP,(R2)),     storage group                   X\n               1X,(VLDDUSER,,T),       userid of last updater          X\n               1X,VLDDDATE,            date of last update             X\n               1X,(VLDDTIME,,T),       time of last update             X\n               1X,(VLDTRKSZ,H,L),      track capacity                  X\n               1X,(VLDNUCBA,,X),       UCB address                     X\n               1X,(VLDNTCPY,F,L),      total capacity in megabytes     X\n               1X,(VLDNFREE,F,L),      amount free in megabytes        X\n               1X,(VLDNLEXT,F,L),      largest free extent in MB       X\n               1X,(VLDFLAGS,,X),       flags                           X\n               1X,(VLDSGST,,X),        status on this system           X\n               INTO=VALUE\n         ST    R15,SHVVALL             save length into shvblock\nVLD99    PR\n***********************************************************************\n*                                                                     *\n*        Edit a Storage Group Definition                              *\n*                                                                     *\n***********************************************************************\nSGD00    BAKR  R14,0\n         LA    R1,VALUE                point at string\n         ST    R1,SHVVALA              save addr into shvblock\n         USING SGDEF,R6\n         LH    R1,SGDNMLEN             length of vol ser\n         STRING (SGDFNAME,(R1)),       name of the SG                  X\n               1X,(SGDFUSER,,T),       userid of last updater          X\n               1X,SGDFDATE,            date of last update             X\n               1X,(SGDFTIME,,T),       time of last update             X\n               1X,(SGDFLAGS,,X),       flags                           X\n               1X,(SGDFTYPE,FL1,L),    SG type 0=pool 1=VIO            X\n               1X,(SGDFVMAX,F,L),      VIO max size                    X\n               1X,(SGDFVUNT,,X),       VIO unit type                   X\n               1X,(SGDFHTHR,FL1,L),    high threshold 0-99%            X\n               1X,(SGDFLTHR,FL1,L),    low threshold 0-99%             X\n               1X,(SGDFDESC,,T),       description                     X\n               INTO=VALUE\n         ST    R15,SHVVALL             save length into shvblock\nSGD99    PR\nLSPACEM  LSPACE MF=L\n***********************************************************************\n*                                                                     *\n*        Dynamic Storage Area                                         *\n*                                                                     *\n***********************************************************************\nDYNAM    DSECT\n         DS    18F\nDWD      DS    D                       work area for CVD\nADDR_OF_ENVBLOCK DS A(ENVBLOCK)        ENVIRONMENT BLOCK\nADDR_OF_EFPL   DS A(EFPL)              External Function Parm List\nSTEMNAME DS    A,F                     ADDR/LEN OF STEM NAME\nIRXEXCOM_REGS DS A(R15,R0,R1)          IRXEXCOM\nIRXEXCOM_PARM DS 4A                    IRXEXCOM\nSSOB_PTR DS    A(SSOB+X'80000000')\nDYNAM_SHVB DS  XL(SHVBLEN)             SHVB (IRXEXCOM)\nSSOB_WRK DS    XL(SSOBHSIZ)            SSOB\nSSSA_WRK DS    XL(SSSALN+SSSA1LN+L'SSSA1NMS)\n         UCBSCAN MF=(L,UCBSCANL)\nUCBAREA48 DS   XL48                    returned copy of the UCB\nLSPACEL  LSPACE MF=L\nLSPACELL EQU   *-LSPACEL\nLSPACED  LSPACE MF=(L,DATA)            LSPACE Data area\n         IECSDSL1 4\n         ORG   DYNAM+((*+256-1-DYNAM)/256)*256\nVARNAME  DS    CL256                   variable name\nVALUE    DS    CL255,C\nBLANKS   DS    CL256                   a bunch of blanks\nWORK256  DS    XL256                   work area for UCBSCAN\nDYNAML   EQU   *-DYNAM\n         PRINT NOGEN\n         IRXEFPL DSECT=YES             External Function Parm List\n         IRXENVB                       Environment Block\n         IRXEXTE                       External Function Entry Points\n         IRXSHVB                       Shared REXX Variable Req Block\n         IRXEVALB                      Evaluation Block\n*\n         CVT   DSECT=YES               CVT\n         IEFJESCT                      JES CVT\n         IEFJSSOB ,                    SSOB HEADER DSECT\n         IEFSSSA                       SSOB EXTENSION FOR SMS\n         IGDVLD                        VOLUME DEFINITION\n         IGDSGD                        Storage Group Definition\nLSPDATA  LSPACE MF=(D,DATA)            LSPACE DATA\n         STRING GENERATE\n         YREGS                         Register Equates (R0-R15)\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DSN=CBTTAPE.FILE183.PDS,DISP=SHR  STRING macro\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//LKED    EXEC PGM=IEWL,PARM='MAP,RENT,REFR'\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=CBTTAPE.FILE183.LOAD(RXSMS),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//*\n//TMP     EXEC PGM=IKJEFT01,TIME=(,5)\n//SYSTSPRT DD SYSOUT=*\n//SYSSNAP  DD SYSOUT=*\n//SYSTSIN  DD *\nTSOLIB ACT DA('CBTTAPE.FILE183.LOAD')\nREXXTRY\nCALL RXSMS 'LSPACE','LS.','SYSCAT'\nSAY 'LSPACE rc='rc 'LS.0='ls.0 'LS.1='ls.1\n/*\nSAY COPIES('-',130)\nSAY RXSMS('VOL','vol.','PRIM10')\nSAY 'VOL rc='rc 'vol.0='vol.0 'vol.1='vol.1\nCALL RXSMS 'AVL','avl.'\nSAY 'AVL rc='rc 'avl.0='avl.0\nDO i=1 TO avl.0\n  SAY ' ' i avl.i\nEND\nCALL RXSMS 'VSG','grp.','PRIM13'\nSAY 'VSG rc='rc 'grp.0='grp.0 'grp.1='grp.1 'vol=PRIM13'\nCALL RXSMS 'SGL','SG.'\nSAY 'SGL rc='rc 'sg.0='sg.0\nDO i=1 TO sg.0\n  SAY i 'SG='sg.i\n    CALL RXSMS 'SGV','VOL.',WORD(sg.i,1)\n    SAY 'SGV rc='rc 'vol.0='vol.0\n    DO j=1 TO vol.0\n      SAY ' ' j vol.j\n      DROP vol.j\n    END\nEND\nCALL RXSMS 'SCL','SC.'\nSAY 'SCL rc='rc 'sc.0='sc.0\nDO i=1 TO sc.0\n  SAY i 'SC='sc.i\nEND\nCALL RXSMS 'DCL','DC.'\nSAY 'DCL rc='rc 'dc.0='dc.0\nDO i=1 TO dc.0\n  SAY i 'DC='dc.i\nEND\nCALL RXSMS 'MCL','MC.'\nSAY 'MCL rc='rc 'mc.0='mc.0\nDO i=1 TO mc.0\n  SAY i 'MC='mc.i\nEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCANMODL": {"ttr": 16641, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x00\\x95)\\x7f\\x01\\x042\\x1f\\x11Q\\x00\\xb5\\x00O\\x00?\\xc3\\xc2\\xe3\\xf4\\xf6\\xf9@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1995-10-24T00:00:00", "modifydate": "2004-11-16T11:51:18", "lines": 181, "newlines": 79, "modlines": 63, "user": "CBT469"}, "text": "//GILBERTH JOB (ACCT#),SCANMODL,\n//*RESTART=HLASM2,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = SCANMODL                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = RETRIEVE OFFSET & LENGTH OF A JES2 FIELD         *\n*                                                                     *\n* FUNCTION = THIS MODULE LOADS AN IPCS MODEL FROM SYS1.MIGLIB AND     *\n*            RETURNS THE OFFSET & LENGTH OF A GIVEN FIELD.            *\n*            IT IS USED TO WRITE PROGRAMS THAT ACCESS JES2 CONTROL    *\n*            BLOCKS WITHOUT USING HASPSRC AND CONSEQUENTLY,           *\n*            ARE RELEASE-INDEPENDENT.                                 *\n*                                                                     *\n* STATUS = R101                                                       *\n*                                                                     *\n* AUTHOR = GILBERT SAINT-FLOUR <carlos@gsf-soft.com>                  *\n*                                                                     *\n* INVOCATION = VIA CALL OR LINK                                       *\n*                                                                     *\n*          LA   R2,=CL8'HASMSDB'          HASP SDB                    *\n*          LA   R3,=CL8'SDBRECCT'         RECORD COUNT                *\n*          LINK EP=SCANMODL,PARAM=((R2),(R3))                         *\n*          LH   R4,0(,R1)                 OFFSET                      *\n*          LH   R5,2(,R1)                 LENGTH                      *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = MVS/ESA V4.1 OR ABOVE                             *\n*                                                                     *\n*    AUTHORIZATION = NONE                                             *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (SUB-ROUTINE)                              *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 4K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE ANY, AMODE 31,                   *\n*                 PROBLEM STATE, TCB KEY                              *\n*                                                                     *\n* OPERATION = SEE DOCUMENTATION                                       *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n*   @100 INITIAL VERSION                                              *\n*   @101 MINOR CHANGES                                                *\n*                                                                     *\n***********************************************************************\nSCANMODL CSECT\nSCANMODL RMODE ANY\n         B     BEGIN-*(,R15)\n         DC    C'GSF UTILITIES - SCANMODL R101 '\nBEGIN    BAKR  R14,0\n         LR    R11,R15\n         USING SCANMODL,R11\n         LM    R8,R9,0(R1)             R8=HASMSDB,R9=SDBRECCT\n         L     R1,16(,0)               CVTPTR\n         L     R1,8(,R1)               CVTLINK\n         LOAD  EPLOC=(R8),DCB=(R1),ERRET=RC12\n         LR    R4,R0                   IM$SDB\n         USING HEADER,R4\n         SLR   R1,R1\n         IC    R1,HDROFFSET            OFFSET TO 1ST FIELD DESC\n         LA    R5,HEADER(R1)           ADDR OF 1ST FIELD DESC\n         USING FLDDESC,R5\n*LOOP\nLOOP5    CLC   FLDNAME,0(R9)           REQUESTED FIELD?\n         BE    LOOP5X                  YES, EXIT\n         LA    R5,FLD_NEXT             NEXT FIELD DESCRIPTOR\n         CLI   FLDDESC,0               END OF MODEL?\n         BNE   LOOP5                   NO, PROCESS NEXT FIELD\n*ENDLOOP\n         LA    R15,8                   RC=8  (FIELD NOT FOUND)\n         PR\n*\n*        RETURN OFFSET AND LENGTH IN SAVEAREA+8\n*\nLOOP5X   LA    R1,8(,R13)              4-BYTE WORK AREA CALLER'S AMODE\n         MVC   0(4,R1),FLDOFFSET       MOVE OFFSET & LENGTH\n         SLR   R15,R15                 RC=0\n         PR\n*\nRC12     LA    R15,12                  RC=12 (LOAD FAILED)\n         PR\n*        BLSQCBM                   CONTROL BLOCK MODEL USED BY BLSQFORM\nHEADER   DSECT\nHDRACRO  DS    CL8                     EBCDIC CB ACRONYM\nHDRUTHDR DS    CL8'$SDB'               OUTPUT HEADER\nHDRMLVL  DS    CL8'HJE4430'            MAINTENANCE LEVEL\nHDRCBLEN DS    FL2                     LENGTH OF CONTROL BLOCK\nHDRAOFF  DS    FL2                     OFFSET TO ACRONYM\nHDRALEN  DS    FL1                     LENGTH OF ACRONYM\nHDRLLEN  DS    FL1                     LABEL LENGTH\nHDRSCOL  DS    FL1                     START COLUMN OR LEFT MARGIN\nHDRNCOL  DS    FL1                     NUMBER OF COLS BETWEEN LABELS\nHDRFLAGS DS    XL1                     NUMBER OF COLS BETWEEN LABELS\nHDROFFSET DS   FL1                     OFFSET TO 1ST FIELD DESC\nHDRMODLVL DS   FL1                     MODEL LEVEL\n          DS   X                       RESERVED\n*\nFLDDESC  DSECT\nFLDNAME  DS    CL8                0    FIELD NAME\nFLDFLAGS DS    X,X                8    FLAGS\nFLDVIEW  DS    XL2               10    VIEW\nFLDOFFSET DS   FL2               12    OFFSET\nFLDLENGTH DS   FL2               14    LENGTH\nFLD_NEXT EQU   *                 16\n         YREGS\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//LKED    EXEC PGM=IEWL,PARM=RENT\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,DELETE)\n//SYSLMOD  DD DSN=CBTTAPE.FILE183.LOAD(SCANMODL),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//*\n//*      TEST PROGRAM - DISPLAY OFFSETS NEEDED BY SYSDEBUG\n//*\n//HLASM2 EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\nTEMPNAME CSECT\n         BAKR  R14,0\n         LR    R12,R15\n         USING TEMPNAME,R12\n         LOAD  EP=SCANMODL             PRE-LOAD\n         OPEN  (SYSPRINT,OUTPUT)\n         LA    R2,=CL8'HASMSDB'\n         LA    R3,=CL8'SDBDEB'\n         BAL   R14,DISPLAY          <- DISPLAY SDBDEB\n         LA    R3,=CL8'SDBUBF'\n         BAL   R14,DISPLAY          <- DISPLAY SDBUBF\n         LA    R2,=CL8'HASMBUFR'\n         LA    R2,=CL8'HASMBFD'        HJE7707\n         LA    R3,=CL8'BFDLOC'\n         BAL   R14,DISPLAY          <- DISPLAY BFDLOC\n         LA    R3,=CL8'TPBUFST'\n         LA    R3,=CL8'BFDSTART'       HJE7707\n         BAL   R14,DISPLAY          <- DISPLAY TPBUFST (BFDDATA)\n         PR\n*\nDISPLAY  BAKR  R14,0\n         LINK  EP=SCANMODL,PARAM=((R2),(R3))\n         ST    R15,RC                  RETURN CODE\n         MVC   OFFSET,0(R1)            OFFSET\n         MVC   LENGTH,2(R1)            LENGTH\n         STRING ' CB=',((R2),8),       CONTROL BLOCK                   X\n               ' FLD=',((R3),8),       FIELD                           X\n               ' RC=',(RC,F,R3Z),                                      X\n               ' OFFSET=',(OFFSET,,X),                                 X\n               ' LENGTH=',(LENGTH,,X),                                 X\n               INTO=WORK121\n         PUT   SYSPRINT,WORK121\n         L     R15,RC                  RETURN CODE\n         PR\n*\nSYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,RECFM=FBA,LRECL=121\nRC       DS    F\nOFFSET   DS    H                       OFFSET\nLENGTH   DS    H                       LENGTH\nWORK121  DS    CL121\n         STRING GENERATE\n         YREGS\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=CBTTAPE.FILE183.PDS,DISP=SHR            STRING\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//GO      EXEC PGM=LOADER,PARM=NOPRINT\n//STEPLIB  DD DSN=CBTTAPE.FILE183.LOAD,DISP=SHR           SCANMODL\n//*DD DSN=SYS1.SHASMIG,DISP=SHR                           HASMSDB\n//SYSLIN   DD DSN=*.HLASM2.SYSLIN,DISP=(OLD,DELETE)\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SFE": {"ttr": 16645, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x06?\\x01\\x02!\\x7f\\x10%\\x00)\\x00\\x1f\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf6\\xf2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-04T00:00:00", "modifydate": "2002-08-05T10:25:00", "lines": 41, "newlines": 31, "modlines": 0, "user": "CBT462"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* Module Name: SFE                                                   */\n/*                                                                    */\n/* Descriptive Name: Invoke Search-For Extended utility               */\n/*                                                                    */\n/* Status: R100                                                       */\n/*                                                                    */\n/* Function: This REXX exec can be issued as an EDIT macro            */\n/*           or from the Data Set List panel to invoke the            */\n/*           Search-For Extended utility for the current data set.    */\n/*                                                                    */\n/* Author: Gilbert Saint-Flour <carlos@gsf-soft.com>                  */\n/*                                                                    */\n/* Environment: ISPF/PDF V4.2 or above                                */\n/*                                                                    */\n/* Operation: see below                                               */\n/*                                                                    */\n/*         Enter SFE as a line command on the DSLIST panel or as a    */\n/*         primary command in EDIT or VIEW to enter the Search-For    */\n/*         Extended utility and search the current data set.          */\n/*                                                                    */\n/**********************************************************************/\nADDRESS 'ISPEXEC'\n\"CONTROL ERRORS RETURN\"\n\"ISREDIT MACRO (srf4file)\"            /* invoked from EDIT/VIEW?      */\nIF rc=0 THEN DO\n  IF srf4file='' THEN DO\n    \"ISREDIT (DSN) = DATASET\"         /* current data set             */\n    IF rc>0 THEN EXIT rc\n    srf4file=\"'\"DSN\"'\"\n    END\n  END\nELSE\n  ARG srf4file                        /* 1st arg must be dsn          */\nIF srf4file='' THEN EXIT 4            /* no dsn, quit                 */\nsrf4mem='*'                           /* members(*)                   */\nsrc4wkpl='Y'                          /* Call SFE from work-place     */\n\"VPUT (src4wkpl srf4file srf4mem)\"\n\"SELECT PGM(ISRSEPRM) PARM(S4) SCRNAME(SRCHFORE) \"\nIF zerrmsg\\='' THEN \"SETMSG MSG(\"zerrmsg\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHOWDASD": {"ttr": 16647, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00S\\x01\\x15\\x02o\\x01\\x15\\x02\\x8f\\x13\\x10\\x01\\x90\\x01\\x8e\\x00\\x04\\xc1\\xc3\\xc9\\xc5\\xd9\\xc9@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2015-01-26T00:00:00", "modifydate": "2015-01-28T13:10:53", "lines": 400, "newlines": 398, "modlines": 4, "user": "ACIERI"}, "text": "/*************************************************************** REXX *\\\n|*                                                                    *|\n|* MODULE NAME = SHOWDASD                                             *|\n|*                                                                    *|\n|* DESCRIPTIVE NAME = Display on-line DASD devices                    *|\n|*                                                                    *|\n|* STATUS = R105                                                      *|\n|*                                                                    *|\n|* FUNCTION = This REXX exec allows an ISPF user to display a list    *|\n|*            of on-line DASD devices.                                *|\n|*                                                                    *|\n|* AUTHOR   =  Gilbert Saint-Flour <carlos@gsf-soft.com>              *|\n|*             http://gsf-soft.com/Freeware/SHOWDASD.shtml            *|\n|*                                                                    *|\n|* DEPENDENCIES = TSO/E V2                                            *|\n|*                ISPF V4 or V5                                       *|\n|*                RXSMS module                                        *|\n|*                SHOWDPNL and SHOWVTOC Panels                        *|\n|*                                                                    *|\n|* SYNTAX = See below                                                 *|\n|*                                                                    *|\n|*     SHOWDASD                                                       *|\n|*              <volume filter>                                       *|\n|*              <SG=storgrp>                                          *|\n|*                                                                    *|\n|*101 Check for invalid commands                                 2004 *|\n|*102 z/OS 1.7 HBB7720 ULUT V2                                   2007 *|\n|*103 LIBDEF ISPPLIB LIBRARY ID(SYSEXEC) STACK                   2009 *|\n|*    Activate REFRESH command                                        *|\n|*104 VTOC info now displayed with V or I                        2010 *|\n|*105 z/OS 2.2 HBB77A0 ULUT V3 (or Z/OS 2.1 / 1.13 w/PTFs)       2015 *|\n|*    ULUT is now in 64 bit storage                                   *|\n|*                                                                    *|\n\\**********************************************************************/\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"ISREDIT MACRO (filter)\"\nIF rc>0 THEN ARG filter\nUPPER filter\nIF filter='' THEN filter='*'\nfilter2=filter\n\nvars='ucb volser devn devc device sg cyls totspc fspc fpct maxfree'\nDO i=1 BY 1\n  tbname='VOLS' || RIGHT(i,4,'0')\n  \"TBCREATE &tbname NOWRITE KEYS(&vars) NAMES(lcmd)\"\n  IF rc=0 THEN LEAVE\nEND\nlcmd=''; n=0\nCALL Build_table                                /* Build the table */\nIF n=0 THEN DO\n   ZMSG000S='No on-line volume'\n   ZMSG000L='No on-line volumes were found ' ||,\n                                     'that match specified vol/sg names'\n  \"SETMSG MSG(ISPZ000)\"                      /* initial Message       */\n  EXIT 8\n  END\nMSG000S=n || 'volumes displayed'\nMSG000L=n || 'DASD volumes are displayed'\n\"SETMSG MSG(ISPZ000)\"                      /* initial Message       */\n  /*---------------------------------------------------------------*\\\n  |*                  Display the table                            *|\n  \\*---------------------------------------------------------------*/\n\"TBTOP &tbname\"\n\nDO FOREVER\n  n=0; zerrmsg=''\n  \"TBDISPL &tbname PANEL(SHOWDPNL) AUTOSEL(YES) ROWID(rowid)\"\n  IF rc=8 THEN LEAVE                       /* END/RETURN */\n  tbrc=rc                                  /* save rc=4 */\n  IF rc=12 THEN DO\n    \"LIBDEF ISPPLIB LIBRARY ID(SYSEXEC) STACK\"\n    IF rc=0 THEN sysexec='OK'\n    \"TBDISPL &tbname PANEL(SHOWDPNL) AUTOSEL(YES) ROWID(rowid)\"\n    IF rc=8 THEN LEAVE                     /* END/RETURN */\n    tbrc=rc                                /* save rc=4 */\n    END\n  IF rc>8 THEN DO\n    IF zerrmsg\\='' THEN\n      'SETMSG MSG(&zerrmsg)'              /* TBDISPL error message */\n    EXIT tbrc\n    END\n  IF zcmd\\='' THEN DO\n    SELECT\n      WHEN WORD(zcmd,1) = 'SORT' THEN DO\n        fields=DELWORD(zcmd,1,1)\n        IF fields='' THEN fields='VOLSER'\n        \"TBSORT &tbname FIELDS(&fields)\"\n        IF rc>0 THEN DO\n          IF zerrmsg\\='' THEN\n            'SETMSG MSG(&zerrmsg)'           /* TBSORT error message */\n          END\n        \"TBTOP &tbname\"\n        ITERATE                              /* ignore selections */\n        END\n      WHEN ABBREV('REFRESH',WORD(zcmd,1),3) THEN DO\n  n=0\n        CALL Refresh                         /* refresh SMS info */\n        END\n      OTHERWISE\n        'SETMSG MSG(ISPZ001)'                /* Invalid Command */\n      END\n    END\n  IF tbrc=4 THEN DO UNTIL rc=0\n    CALL Selected_Row                      /* show current volume */\n    \"TBDISPL &tbname\"\n    END\n\n  CALL Selected_Row                        /* show last volume */\n  \"TBSKIP &tbname NUMBER(&n)\"              /* undo scrolling         */\nEND\n\n\"TBCLOSE &tbname\"\nIF sysexec='OK' THEN\n  \"LIBDEF ISPPLIB\"       /* say sysexec rc */\nEXIT 1\n\n  /*---------------------------------------------------------------*\\\n  |*       Sub-routine: Refresh SMS information                    *|\n  \\*---------------------------------------------------------------*/\n\nRefresh:\n  \"TBCLOSE &tbname\"\n  \"TBCREATE &tbname NOWRITE KEYS(&vars) NAMES(lcmd)\"\n    IF zerrmsg\\='' THEN\n      'SETMSG MSG(&zerrmsg)'              /* TBDISPL error message */\n  filter=filter2\n  CALL Build_table                         /* Rebuild the table */\n  \"TBTOP &tbname\"\n  RETURN\n\n    /*------------------------------------------------------*\\\n    |*   Scan UCB table and load data into table entries    *|\n    \\*------------------------------------------------------*/\n\nBuild_table :\n  TotTracks=0;TotFree=0\n\n    /*     Retrieve volumes from SMS if filter=\"SG=xxxx\"    */\n\nIF LEFT(filter,3)='SG=' THEN DO\n  filter=SUBSTR(filter,4)                /* name of storage group  */\n  IF INDEX(filter,'*')=0 & INDEX(filter,'%')=0 THEN DO\n    IF RXSMS('SGV','vol.',filter) = 0 THEN DO v=1 TO vol.0\n      ucb=X2D(WORD(vol.v,7))\n      IF ucb>0 THEN                        /* on-line device?        */\n        CALL Process_UCB ucb v\n      END\n    END\n  ELSE DO                                  /* generic filter         */\n    IF RXSMS('AVL','vol.',filter) = 0 THEN DO v=1 TO vol.0\n      IF WILDCARD(WORD(vol.v,2),filter) THEN DO\n        ucb=X2D(WORD(vol.v,7))\n        IF ucb>0 THEN                        /* on-line device?      */\n          CALL Process_UCB ucb v\n        END\n      END\n    END\n  END\n\n    /*     Loop through ULUT entries if filter=''       */\n\nELSE DO\n  cvt = C2D(STORAGE(10,4))                 /* CVTPTR               */\n  iocom = C2D(STORAGE(D2X(cvt+124),4))     /* CVTIXAVL             */\n  iovt = C2D(STORAGE(D2X(iocom+208),4))    /* IOCIOVTP             */\n  NUMERIC DIGITS 20                        /* ULUT > 3B9AC9FF      */\n  ulut = C2D(STORAGE(D2X(iovt+8),4))       /* IOVTULUT             */\n  if ulut = 0 then                           /* IF 31 bit addr = 0 */\n    ulut = C2D(STORAGE(D2X(iovt+440),8))     /* THEN ULUT in 64 bit*/\n  uluentry = C2D(STORAGE(D2X(ulut+12),4))  /* ULUT1ST              */\n  count = C2D(STORAGE(D2X(ulut+16),4))     /* ULUTUCBC             */\n  IF STORAGE(D2X(ulut+4),1)='02'X THEN DO       /* ULUT V2 HBB7720 */\n    uluentry = C2D(STORAGE(D2X(ulut+12+8),4))   /* ULUT V2 HBB7720 */\n    count = C2D(STORAGE(D2X(ulut+16+8),4))      /* ULUT V2 HBB7720 */\n    END                                         /* ULUT V2 HBB7720 */\n  IF STORAGE(D2X(ulut+4),1)='03'X THEN DO       /* ULUT V3         */\n    uluentry = C2D(STORAGE(D2X(ulut+12+4),8))   /* ULUT V3 64 bits */\n    count = C2D(STORAGE(D2X(ulut+24+4),4))      /* ULUT V3 HBB7780 */\n    END                                         /* ULUT V3 HBB7780 */\n  DO i=1 TO count\n    ucb = C2D(STORAGE(D2X(uluentry+8),4))  /* ULUEUCBP             */\n    stat = STORAGE(D2X(ucb+3),1)           /* UCBSTAT              */\n    IF BITAND(stat,'80'x)='80'x THEN DO    /* on-line device?      */\n      byt3 = STORAGE(D2X(ucb+18),1)        /* UCBTBYT3             */\n      IF byt3='20'x THEN DO                /* class=DASD           */\n        volser=STORAGE(D2X(ucb+28),6)      /* UCBVOLI              */\n        IF WILDCARD(volser,filter) THEN DO\n          fl5 = STORAGE(D2X(ucb+1),1)      /* UCBFL5               */\n          IF BITAND(fl5,'20'x)='20'x THEN DO /* UCBSMS             */\n            rc=RXSMS('VOL','vol.',STORAGE(D2X(ucb+28),6))\n            CALL Process_UCB ucb 1\n            END\n          ELSE                             /* non-SMS              */\n            CALL Process_UCB ucb 0\n          END\n        END                                /* Wildcard             */\n      END                                  /* DASD                 */\n    uluentry=uluentry+12                   /* next UCB look-up entry */\n    END                                    /* on-line              */\n  END                                      /* ULUT scan            */\n\n  /*                  Display the message                          */\n\nIF TotTracks>0 THEN DO\n  pct=TRUNC((TotFree*100)/TotTracks,1) || '%'\n  IF TotTracks<10000 THEN\n   TotTracks=TotTracks || 'MB'\n  ELSE\n   TotTracks=TRUNC(TotTracks/1000,1) || 'GB'\n  IF TotFree<10000 THEN\n   TotFree=TotFree || 'MB'\n  ELSE\n   TotFree=TRUNC(TotFree/1000,1) || 'GB'\n   ZMSG000S= TotTracks TotFree pct\n   ZMSG000L= 'Total Space:' TotTracks,\n            ' Total Free Space:' TotFree,\n            '(' || pct || ')'\n  \"SETMSG MSG(ISPZ000)\"                      /* initial Message       */\n  END\nRETURN\n\n  /*---------------------------------------------------------------*\\\n  |*                 Process a selected volume                     *|\n  \\*---------------------------------------------------------------*/\n\nSelected_Row:\n  tbvol=volser\n  IF tbrc=0 & zcurinx>0 & rowid=0 THEN\n    \"TBSKIP &tbname NUMBER(&zcurinx)\"\n  IF zcurinx>0 THEN\n    n=ztdtop-zcurinx\n\n /*\n SAY 'rc='tbrc 'zsel='zsel 'ztdtop='ztdtop+0 'zcurinx='zcurinx+0,\n     'rowid='rowid+0 'volser='volser 'tbvol='tbvol 'n='n\n */\n\n  \"CONTROL DISPLAY SAVE\"\n  SELECT\n    WHEN zcurinx+rowid=0 THEN DO            /* ENTER, no selection */\n      \"TBSKIP &tbname NUMBER(&ztdtop)\"\n      zsel=''\n      END\n    WHEN zsel='S' THEN DO                   /* List VTOC */\n      'LMDINIT LISTID(LID) VOLUME(&volser)'\n      IF RC>0 THEN SAY 'LMDINIT RC='RC\n      'LMDDISP LISTID(&LID)'\n      IF RC>0 THEN SAY 'LMDDISP RC='RC\n      'LMDFREE LISTID(&LID)'\n      IF RC>0 THEN SAY 'LMDFREE RC='RC\n      END\n    WHEN zsel='U' THEN DO                   /* Show UCB */\n      say 'UCB='D2X(ucb) 'VOL='volser\n      END\n    WHEN (zsel='I' | zsel='V') THEN DO      /* VTOC stats */\n      ZDDNVOL=volser\n      'VPUT ZDDNVOL SHARED'\n      ZDDNSKP='0'\n      'SELECT PGM(ISRUDL) PARM(SHOWVTOC)'\n      END\n    OTHERWISE DO\n      SAY 'invalid selection'\n      zsel=''\n      END\n    END\n  \"CONTROL DISPLAY RESTORE\"\n  IF zsel\\='' THEN DO\n    lcmd=zsel\n    'TBPUT &tbname'\n /* say 'lcmd='lcmd 'tbput='rc 'volser='volser */\n    END\nRETURN\n\n  /*---------------------------------------------------------------*\\\n  |*  Sub-routine: Process a DASD volume and create a table entry  *|\n  \\*---------------------------------------------------------------*/\n\nProcess_UCB: PROCEDURE EXPOSE tbname vol. TotTracks TotFree n\n  ARG ucb v\n  volser=STORAGE(D2X(ucb+28),6)           /* UCBVOLI                */\n  devc = C2X(STORAGE(D2X(ucb+4),2))       /* UCBCHAN                */\n  devn = STORAGE(D2X(ucb+4),2)            /* UCBCHAN                */\n  devt = STORAGE(D2X(ucb+16),4)           /* UCBTYP                 */\n  cmext = C2D(STORAGE(D2X(ucb+21),3))     /* UCBEXTP                */\n  IF cmext//2 = 1 THEN                    /* UCB above the 16MB line */\n    cmext=TRUNC(ucb/16777216)*16777216+cmext-1\n  dce = C2D(STORAGE(D2X(cmext+24),4))     /* UCBCLEXT               */\n  obr = STORAGE(D2X(dce+23),1)            /* DCEOBRDT               */\n  SELECT\n    WHEN obr='1E'x THEN unit=STRIP(unitname(devt)) || 'D '\n    WHEN obr='21'x THEN unit=STRIP(unitname(devt)) || 'J '\n    WHEN obr='23'x THEN unit=STRIP(unitname(devt)) || 'K '\n    WHEN obr='2E'x THEN unit=STRIP(unitname(devt)) || 'E '\n    WHEN obr='26'x THEN unit=STRIP(unitname(devt)) || '-1'\n    WHEN obr='27'x THEN unit=STRIP(unitname(devt)) || '-2'\n    WHEN obr='24'x THEN unit=STRIP(unitname(devt)) || '-3'\n    WHEN obr='32'x THEN unit=STRIP(unitname(devt)) || '-9'\n    OTHERWISE unit=STRIP(unitname(devt))\n    END\n  device=LEFT(unit,6)                     /* pad                    */\n  hicyl = C2D(STORAGE(D2X(dce+20),2))     /* DCEHICYL               */\n  cyls = RIGHT(hicyl+1,5)                 /* pad                    */\n  IF v>0 THEN DO                          /* SMS info available     */\n    sg=WORD(vol.v,2)                      /* Storage Group          */\n    TotSpc=WORD(vol.v,8)                  /* Total Space            */\n    fspc=WORD(vol.v,9)                    /* Free Space             */\n    TotFree=TotFree+fspc                  /* Tally Free Space       */\n    MaxFree=WORD(vol.v,10)                /* Largest Extent         */\n    fpct=''\n    IF TotSpc>0 THEN DO\n      TotTracks=TotTracks+TotSpc          /* Tally Tracks           */\n      fpct=TRUNC((fspc*100)/TotSpc)\n      fpct=RIGHT(fpct,2) || '%'\n      END\n    fspc=RIGHT(fspc,5) || 'MB'\n    TotSpc=RIGHT(TotSpc,5) || 'MB'\n    MaxFree=RIGHT(MaxFree,5) || 'MB'\n    END\n  ELSE DO\n    stab = STORAGE(D2X(ucb+34),1)          /* UCBSTAB              */\n    SELECT\n      WHEN BITAND(stab,'10'x)='10'x THEN sg='Private'\n      WHEN BITAND(stab,'08'x)='08'x THEN sg='Public'\n      OTHERWISE sg='Storage'\n      END\n    END\n  \"TBADD &tbname\"\n  n=n+1\n  IF rc>0 THEN SAY 'TBADD rc='rc 'vol='volser\n  RETURN\n\n  /*---------------------------------------------------------------*\\\n  |*       Sub-routine: Match name against specified pattern       *|\n  \\*---------------------------------------------------------------*/\n\nWILDCARD: PROCEDURE\n  ARG name,pattern                   /* parse arguments */\n/*SAY name pattern*/\n  IF pattern='*' THEN RETURN 1       /* we have a match */\n  n=1\n  DO p=1 TO LENGTH(pattern)\n    p1=SUBSTR(pattern,p,1)\n    SELECT\n      WHEN p1=SUBSTR(name,n,1) THEN n=n+1\n      WHEN p1='%' THEN n=n+1\n      WHEN p1='*' THEN DO\n        IF p=LENGTH(pattern) THEN RETURN 1\n        n=INDEX(name,SUBSTR(pattern,p+1,1),n+1)\n        IF n=0 THEN RETURN 0        /* mismatch, exit */\n        END\n      OTHERWISE RETURN 0            /* mismatch, exit */\n      END\n  END\n  RETURN n=LENGTH(name)+1\n\n  /*----------------------------------------------------------------*\\\n  |*                                                                *|\n  |*         Convert a device type (UCBTYP) to a unit name          *|\n  |*                                                                *|\n  |* This routine converts a 4-byte device type such as '3030200F'x *|\n  |* to an 8-character unit name such as '3390    ' using the       *|\n  |* IEFEB4UV service, as described in the IBM docs.                *|\n  |* To speed things up, this routine maintains a look-aside table  *|\n  |* of already converted devtype/unitname pairs.                   *|\n  |*                                                                *|\n  \\*----------------------------------------------------------------*/\n\nunitname: PROCEDURE EXPOSE devtunit.\n  ARG devt                                   /* e.g. '3030200F'x */\n  IF devtunit.0 = 'DEVTUNIT.0' THEN          /* first time */\n    i=1\n  ELSE                                       /* not first time */\n    DO i=1 to devtunit.0                  /* scan look-aside table */\n      IF LEFT(devtunit.i,4) = devt THEN\n        RETURN RIGHT(devtunit.i,8)                /* e.g. '3390' */\n    END\n    /*                                                      */\n    /* devt not found in table, invoke IEFEB4UV to perform  */\n    /*       conversion and add new entry to table          */\n    /*                                                      */\n  devtunit.0 = i\n  unitname = '12345678' || devt || '00000000'x\n  flags='0100'x\n  ADDRESS LINKPGM 'IEFEB4UV unitname flags'\n  IF rc=0 THEN DO                            /* unknown devt */\n    flags='2000'x\n    ADDRESS LINKPGM 'IEFEB4UV unitname flags'\n    IF rc=0 THEN DO\n      devtunit.i = devt || LEFT(unitname,8)\n      RETURN RIGHT(devtunit.i,8)                  /* e.g. '3390' */\n      END\n    END\n    /*                                                        */\n    /* If IEFEB4UV failed to convert the devt to a unit name, */\n    /* convert the devt to EBCDIC and return it to the caller */\n    /*                                                        */\n  SAY 'IEFEB4UV RC='rc 'FLAGS='C2X(flags) 'DEVT='C2X(devt)\n  devtunit.i = devt || C2X(devt)\n  RETURN RIGHT(devtunit.i,8)                     /* '3030200F' */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHOWDAS1": {"ttr": 16899, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00X\\x00\\x94\\x12\\x9f\\x01\\x10\\x14\\x7f\\x14P\\x01\\x88\\x00R\\x00K\\xd6\\xd3\\xc4@@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1994-05-09T00:00:00", "modifydate": "2010-05-27T14:50:58", "lines": 392, "newlines": 82, "modlines": 75, "user": "OLD"}, "text": "/*************************************************************** REXX *\\\n|*                                                                    *|\n|* MODULE NAME = SHOWDASD                                             *|\n|*                                                                    *|\n|* DESCRIPTIVE NAME = Display on-line DASD devices                    *|\n|*                                                                    *|\n|* STATUS = R104                                                      *|\n|*                                                                    *|\n|* FUNCTION = This REXX exec allows an ISPF user to display a list    *|\n|*            of on-line DASD devices.                                *|\n|*                                                                    *|\n|* AUTHOR   =  Gilbert Saint-Flour <carlos@gsf-soft.com>              *|\n|*             http://gsf-soft.com/Freeware/SHOWDASD.shtml            *|\n|*                                                                    *|\n|* DEPENDENCIES = TSO/E V2                                            *|\n|*                ISPF V4 or V5                                       *|\n|*                RXSMS module                                        *|\n|*                SHOWDPNL and SHOWVTOC Panels                        *|\n|*                                                                    *|\n|* SYNTAX = See below                                                 *|\n|*                                                                    *|\n|*     SHOWDASD                                                       *|\n|*              <volume filter>                                       *|\n|*              <SG=storgrp>                                          *|\n|*                                                                    *|\n|*101 Check for invalid commands                                 2004 *|\n|*102 z/OS 1.7 HBB7720 ULUT V2                                   2007 *|\n|*103 LIBDEF ISPPLIB LIBRARY ID(SYSEXEC) STACK                   2009 *|\n|*    Activate REFRESH command                                        *|\n|*104 VTOC info now displayed with V or I                        2010 *|\n|*                                                                    *|\n\\**********************************************************************/\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"ISREDIT MACRO (filter)\"\nIF rc>0 THEN ARG filter\nUPPER filter\nIF filter='' THEN filter='*'\nfilter2=filter\n\nvars='ucb volser devn devc device sg cyls totspc fspc fpct maxfree'\nDO i=1 BY 1\n  tbname='VOLS' || RIGHT(i,4,'0')\n  \"TBCREATE &tbname NOWRITE KEYS(&vars) NAMES(lcmd)\"\n  IF rc=0 THEN LEAVE\nEND\nlcmd=''; n=0\nCALL Build_table                                /* Build the table */\nIF n=0 THEN DO\n   ZMSG000S='No on-line volume'\n   ZMSG000L='No on-line volumes were found ' ||,\n                                     'that match specified vol/sg names'\n  \"SETMSG MSG(ISPZ000)\"                      /* initial Message       */\n  EXIT 8\n  END\nMSG000S=n || 'volumes displayed'\nMSG000L=n || 'DASD volumes are displayed'\n\"SETMSG MSG(ISPZ000)\"                      /* initial Message       */\n  /*---------------------------------------------------------------*\\\n  |*                  Display the table                            *|\n  \\*---------------------------------------------------------------*/\n\"TBTOP &tbname\"\n\nDO FOREVER\n  n=0; zerrmsg=''\n  \"TBDISPL &tbname PANEL(SHOWDPNL) AUTOSEL(YES) ROWID(rowid)\"\n  IF rc=8 THEN LEAVE                       /* END/RETURN */\n  tbrc=rc                                  /* save rc=4 */\n  IF rc=12 THEN DO\n    \"LIBDEF ISPPLIB LIBRARY ID(SYSEXEC) STACK\"\n    IF rc=0 THEN sysexec='OK'\n    \"TBDISPL &tbname PANEL(SHOWDPNL) AUTOSEL(YES) ROWID(rowid)\"\n    IF rc=8 THEN LEAVE                     /* END/RETURN */\n    tbrc=rc                                /* save rc=4 */\n    END\n  IF rc>8 THEN DO\n    IF zerrmsg\\='' THEN\n      'SETMSG MSG(&zerrmsg)'              /* TBDISPL error message */\n    EXIT tbrc\n    END\n  IF zcmd\\='' THEN DO\n    SELECT\n      WHEN WORD(zcmd,1) = 'SORT' THEN DO\n        fields=DELWORD(zcmd,1,1)\n        IF fields='' THEN fields='VOLSER'\n        \"TBSORT &tbname FIELDS(&fields)\"\n        IF rc>0 THEN DO\n          IF zerrmsg\\='' THEN\n            'SETMSG MSG(&zerrmsg)'           /* TBSORT error message */\n          END\n        \"TBTOP &tbname\"\n        ITERATE                              /* ignore selections */\n        END\n      WHEN ABBREV('REFRESH',WORD(zcmd,1),3) THEN DO\n  n=0\n        CALL Refresh                         /* refresh SMS info */\n        END\n      OTHERWISE\n        'SETMSG MSG(ISPZ001)'                /* Invalid Command */\n      END\n    END\n  IF tbrc=4 THEN DO UNTIL rc=0\n    CALL Selected_Row                      /* show current volume */\n    \"TBDISPL &tbname\"\n    END\n\n  CALL Selected_Row                        /* show last volume */\n  \"TBSKIP &tbname NUMBER(&n)\"              /* undo scrolling         */\nEND\n\n\"TBCLOSE &tbname\"\nIF sysexec='OK' THEN\n  \"LIBDEF ISPPLIB\"       /* say sysexec rc */\nEXIT 1\n\n  /*---------------------------------------------------------------*\\\n  |*       Sub-routine: Refresh SMS information                    *|\n  \\*---------------------------------------------------------------*/\n\nRefresh:\n  \"TBCLOSE &tbname\"\n  \"TBCREATE &tbname NOWRITE KEYS(&vars) NAMES(lcmd)\"\n    IF zerrmsg\\='' THEN\n      'SETMSG MSG(&zerrmsg)'              /* TBDISPL error message */\n  filter=filter2\n  CALL Build_table                         /* Rebuild the table */\n  \"TBTOP &tbname\"\n  RETURN\n\n    /*------------------------------------------------------*\\\n    |*   Scan UCB table and load data into table entries    *|\n    \\*------------------------------------------------------*/\n\nBuild_table :\n  TotTracks=0;TotFree=0\n\n    /*     Retrieve volumes from SMS if filter=\"SG=xxxx\"    */\n\nIF LEFT(filter,3)='SG=' THEN DO\n  filter=SUBSTR(filter,4)                /* name of storage group  */\n  IF INDEX(filter,'*')=0 & INDEX(filter,'%')=0 THEN DO\n    IF RXSMS('SGV','vol.',filter) = 0 THEN DO v=1 TO vol.0\n      ucb=X2D(WORD(vol.v,7))\n      IF ucb>0 THEN                        /* on-line device?        */\n        CALL Process_UCB ucb v\n      END\n    END\n  ELSE DO                                  /* generic filter         */\n    IF RXSMS('AVL','vol.',filter) = 0 THEN DO v=1 TO vol.0\n      IF WILDCARD(WORD(vol.v,2),filter) THEN DO\n        ucb=X2D(WORD(vol.v,7))\n        IF ucb>0 THEN                        /* on-line device?      */\n          CALL Process_UCB ucb v\n        END\n      END\n    END\n  END\n\n    /*     Loop through ULUT entries if filter=''       */\n\nELSE DO\n  cvt = C2D(STORAGE(10,4))                 /* CVTPTR               */\n  iocom = C2D(STORAGE(D2X(cvt+124),4))     /* CVTIXAVL             */\n  iovt = C2D(STORAGE(D2X(iocom+208),4))    /* IOCIOVTP             */\n  NUMERIC DIGITS 10                        /* ULUT > 3B9AC9FF      */\n  ulut = C2D(STORAGE(D2X(iovt+8),4))       /* IOVTULUT             */\n  uluentry = C2D(STORAGE(D2X(ulut+12),4))  /* ULUT1ST              */\n  count = C2D(STORAGE(D2X(ulut+16),4))     /* ULUTUCBC             */\n  IF STORAGE(D2X(ulut+4),1)='02'X THEN DO       /* ULUT V2 HBB7720 */\n    uluentry = C2D(STORAGE(D2X(ulut+12+8),4))   /* ULUT V2 HBB7720 */\n    count = C2D(STORAGE(D2X(ulut+16+8),4))      /* ULUT V2 HBB7720 */\n    END                                         /* ULUT V2 HBB7720 */\n  DO i=1 TO count\n    ucb = C2D(STORAGE(D2X(uluentry+8),4))  /* ULUEUCBP             */\n    stat = STORAGE(D2X(ucb+3),1)           /* UCBSTAT              */\n    IF BITAND(stat,'80'x)='80'x THEN DO    /* on-line device?      */\n      byt3 = STORAGE(D2X(ucb+18),1)        /* UCBTBYT3             */\n      IF byt3='20'x THEN DO                /* class=DASD           */\n        volser=STORAGE(D2X(ucb+28),6)      /* UCBVOLI              */\n        IF WILDCARD(volser,filter) THEN DO\n          fl5 = STORAGE(D2X(ucb+1),1)      /* UCBFL5               */\n          IF BITAND(fl5,'20'x)='20'x THEN DO /* UCBSMS             */\n            rc=RXSMS('VOL','vol.',STORAGE(D2X(ucb+28),6))\n            CALL Process_UCB ucb 1\n            END\n          ELSE                             /* non-SMS              */\n            CALL Process_UCB ucb 0\n          END\n        END                                /* Wildcard             */\n      END                                  /* DASD                 */\n    uluentry=uluentry+12                   /* next UCB look-up entry */\n    END                                    /* on-line              */\n  END                                      /* ULUT scan            */\n\n  /*                  Display the message                          */\n\nIF TotTracks>0 THEN DO\n  pct=TRUNC((TotFree*100)/TotTracks,1) || '%'\n  IF TotTracks<10000 THEN\n   TotTracks=TotTracks || 'MB'\n  ELSE\n   TotTracks=TRUNC(TotTracks/1000,1) || 'GB'\n  IF TotFree<10000 THEN\n   TotFree=TotFree || 'MB'\n  ELSE\n   TotFree=TRUNC(TotFree/1000,1) || 'GB'\n   ZMSG000S= TotTracks TotFree pct\n   ZMSG000L= 'Total Space:' TotTracks,\n            ' Total Free Space:' TotFree,\n            '(' || pct || ')'\n  \"SETMSG MSG(ISPZ000)\"                      /* initial Message       */\n  END\nRETURN\n\n  /*---------------------------------------------------------------*\\\n  |*                 Process a selected volume                     *|\n  \\*---------------------------------------------------------------*/\n\nSelected_Row:\n  tbvol=volser\n  IF tbrc=0 & zcurinx>0 & rowid=0 THEN\n    \"TBSKIP &tbname NUMBER(&zcurinx)\"\n  IF zcurinx>0 THEN\n    n=ztdtop-zcurinx\n\n /*\n SAY 'rc='tbrc 'zsel='zsel 'ztdtop='ztdtop+0 'zcurinx='zcurinx+0,\n     'rowid='rowid+0 'volser='volser 'tbvol='tbvol 'n='n\n */\n\n  \"CONTROL DISPLAY SAVE\"\n  SELECT\n    WHEN zcurinx+rowid=0 THEN DO            /* ENTER, no selection */\n      \"TBSKIP &tbname NUMBER(&ztdtop)\"\n      zsel=''\n      END\n    WHEN zsel='S' THEN DO                   /* List VTOC */\n      'LMDINIT LISTID(LID) VOLUME(&volser)'\n      IF RC>0 THEN SAY 'LMDINIT RC='RC\n      'LMDDISP LISTID(&LID)'\n      IF RC>0 THEN SAY 'LMDDISP RC='RC\n      'LMDFREE LISTID(&LID)'\n      IF RC>0 THEN SAY 'LMDFREE RC='RC\n      END\n    WHEN zsel='U' THEN DO                   /* Show UCB */\n      say 'UCB='D2X(ucb) 'VOL='volser\n      END\n    WHEN (zsel='I' | zsel='V') THEN DO      /* VTOC stats */\n      ZDDNVOL=volser\n      'VPUT ZDDNVOL SHARED'\n      ZDDNSKP='0'\n      'SELECT PGM(ISRUDL) PARM(SHOWVTOC)'\n      END\n    OTHERWISE DO\n      SAY 'invalid selection'\n      zsel=''\n      END\n    END\n  \"CONTROL DISPLAY RESTORE\"\n  IF zsel\\='' THEN DO\n    lcmd=zsel\n    'TBPUT &tbname'\n /* say 'lcmd='lcmd 'tbput='rc 'volser='volser */\n    END\nRETURN\n\n  /*---------------------------------------------------------------*\\\n  |*  Sub-routine: Process a DASD volume and create a table entry  *|\n  \\*---------------------------------------------------------------*/\n\nProcess_UCB: PROCEDURE EXPOSE tbname vol. TotTracks TotFree n\n  ARG ucb v\n  volser=STORAGE(D2X(ucb+28),6)           /* UCBVOLI                */\n  devc = C2X(STORAGE(D2X(ucb+4),2))       /* UCBCHAN                */\n  devn = STORAGE(D2X(ucb+4),2)            /* UCBCHAN                */\n  devt = STORAGE(D2X(ucb+16),4)           /* UCBTYP                 */\n  cmext = C2D(STORAGE(D2X(ucb+21),3))     /* UCBEXTP                */\n  IF cmext//2 = 1 THEN                    /* UCB above the 16MB line */\n    cmext=TRUNC(ucb/16777216)*16777216+cmext-1\n  dce = C2D(STORAGE(D2X(cmext+24),4))     /* UCBCLEXT               */\n  obr = STORAGE(D2X(dce+23),1)            /* DCEOBRDT               */\n  SELECT\n    WHEN obr='1E'x THEN unit=STRIP(unitname(devt)) || 'D '\n    WHEN obr='21'x THEN unit=STRIP(unitname(devt)) || 'J '\n    WHEN obr='23'x THEN unit=STRIP(unitname(devt)) || 'K '\n    WHEN obr='2E'x THEN unit=STRIP(unitname(devt)) || 'E '\n    WHEN obr='26'x THEN unit=STRIP(unitname(devt)) || '-1'\n    WHEN obr='27'x THEN unit=STRIP(unitname(devt)) || '-2'\n    WHEN obr='24'x THEN unit=STRIP(unitname(devt)) || '-3'\n    WHEN obr='32'x THEN unit=STRIP(unitname(devt)) || '-9'\n    OTHERWISE unit=STRIP(unitname(devt))\n    END\n  device=LEFT(unit,6)                     /* pad                    */\n  hicyl = C2D(STORAGE(D2X(dce+20),2))     /* DCEHICYL               */\n  cyls = RIGHT(hicyl+1,5)                 /* pad                    */\n  IF v>0 THEN DO                          /* SMS info available     */\n    sg=WORD(vol.v,2)                      /* Storage Group          */\n    TotSpc=WORD(vol.v,8)                  /* Total Space            */\n    fspc=WORD(vol.v,9)                    /* Free Space             */\n    TotFree=TotFree+fspc                  /* Tally Free Space       */\n    MaxFree=WORD(vol.v,10)                /* Largest Extent         */\n    fpct=''\n    IF TotSpc>0 THEN DO\n      TotTracks=TotTracks+TotSpc          /* Tally Tracks           */\n      fpct=TRUNC((fspc*100)/TotSpc)\n      fpct=RIGHT(fpct,2) || '%'\n      END\n    fspc=RIGHT(fspc,5) || 'MB'\n    TotSpc=RIGHT(TotSpc,5) || 'MB'\n    MaxFree=RIGHT(MaxFree,5) || 'MB'\n    END\n  ELSE DO\n    stab = STORAGE(D2X(ucb+34),1)          /* UCBSTAB              */\n    SELECT\n      WHEN BITAND(stab,'10'x)='10'x THEN sg='Private'\n      WHEN BITAND(stab,'08'x)='08'x THEN sg='Public'\n      OTHERWISE sg='Storage'\n      END\n    END\n  \"TBADD &tbname\"\n  n=n+1\n  IF rc>0 THEN SAY 'TBADD rc='rc 'vol='volser\n  RETURN\n\n  /*---------------------------------------------------------------*\\\n  |*       Sub-routine: Match name against specified pattern       *|\n  \\*---------------------------------------------------------------*/\n\nWILDCARD: PROCEDURE\n  ARG name,pattern                   /* parse arguments */\n/*SAY name pattern*/\n  IF pattern='*' THEN RETURN 1       /* we have a match */\n  n=1\n  DO p=1 TO LENGTH(pattern)\n    p1=SUBSTR(pattern,p,1)\n    SELECT\n      WHEN p1=SUBSTR(name,n,1) THEN n=n+1\n      WHEN p1='%' THEN n=n+1\n      WHEN p1='*' THEN DO\n        IF p=LENGTH(pattern) THEN RETURN 1\n        n=INDEX(name,SUBSTR(pattern,p+1,1),n+1)\n        IF n=0 THEN RETURN 0        /* mismatch, exit */\n        END\n      OTHERWISE RETURN 0            /* mismatch, exit */\n      END\n  END\n  RETURN n=LENGTH(name)+1\n\n  /*----------------------------------------------------------------*\\\n  |*                                                                *|\n  |*         Convert a device type (UCBTYP) to a unit name          *|\n  |*                                                                *|\n  |* This routine converts a 4-byte device type such as '3030200F'x *|\n  |* to an 8-character unit name such as '3390    ' using the       *|\n  |* IEFEB4UV service, as described in the IBM docs.                *|\n  |* To speed things up, this routine maintains a look-aside table  *|\n  |* of already converted devtype/unitname pairs.                   *|\n  |*                                                                *|\n  \\*----------------------------------------------------------------*/\n\nunitname: PROCEDURE EXPOSE devtunit.\n  ARG devt                                   /* e.g. '3030200F'x */\n  IF devtunit.0 = 'DEVTUNIT.0' THEN          /* first time */\n    i=1\n  ELSE                                       /* not first time */\n    DO i=1 to devtunit.0                  /* scan look-aside table */\n      IF LEFT(devtunit.i,4) = devt THEN\n        RETURN RIGHT(devtunit.i,8)                /* e.g. '3390' */\n    END\n    /*                                                      */\n    /* devt not found in table, invoke IEFEB4UV to perform  */\n    /*       conversion and add new entry to table          */\n    /*                                                      */\n  devtunit.0 = i\n  unitname = '12345678' || devt || '00000000'x\n  flags='0100'x\n  ADDRESS LINKPGM 'IEFEB4UV unitname flags'\n  IF rc=0 THEN DO                            /* unknown devt */\n    flags='2000'x\n    ADDRESS LINKPGM 'IEFEB4UV unitname flags'\n    IF rc=0 THEN DO\n      devtunit.i = devt || LEFT(unitname,8)\n      RETURN RIGHT(devtunit.i,8)                  /* e.g. '3390' */\n      END\n    END\n    /*                                                        */\n    /* If IEFEB4UV failed to convert the devt to a unit name, */\n    /* convert the devt to EBCDIC and return it to the caller */\n    /*                                                        */\n  SAY 'IEFEB4UV RC='rc 'FLAGS='C2X(flags) 'DEVT='C2X(devt)\n  devtunit.i = devt || C2X(devt)\n  RETURN RIGHT(devtunit.i,8)                     /* '3030200F' */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHOWDPNL": {"ttr": 16906, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x89\\x06O\\x01\\x04\\x02\\x8f\\x08#\\x00\\x1d\\x00\\x0f\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf6\\xf5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1989-03-05T00:00:00", "modifydate": "2004-01-28T08:23:00", "lines": 29, "newlines": 15, "modlines": 0, "user": "CBT465"}, "text": ")Panel Keylist(ISRSAB,ISR)              /* ISPF Panel for the ShowDASD dialog */\n)Attr Default(%+_)                      /* authored by Gilbert Saint-Flour    */\n/* % Type(Text)   Intens(High)              Defaults displayed for */\n/* + Type(Text)   Intens(Low)                    information only  */\n/* _ Type(Input)  Intens(High) Caps(On) Just(Left)                 */\n   ! Type(Input)  Intens(High) Caps(On) Pas(On)\n   # Type(Output) Intens(Low)\n   \u00a2 Type(Output) Intens(High)\n)Body\n%------------------------- On-line Direct-access Volumes -----------------------\n%Command ===>_zcmd                                            %Scroll ===>_zamt+\n%\n+                            Storage           Total                  Largest\n+  Volser  S  Devn  Device    Group     Cyls   Space    Free Space   Free Xtnt\n+\n)Model\n!Z\u00a2volser \u00a2z #devc #device  #sg        #cyls  #TotSpc  #fspc   #fpct #maxfree+\n)Init\n .ZVARS = '(zsel lcmd)'\n IF (&zamt = &Z) &zamt = 'CSR'\n &zsel = '.'\n &zcmd = &z\n)Proc\n  Refresh(*)\n  IF  (&zsel = '.') &zsel = 'S'\n  VER (&zsel,NB,LIST,S,V,U)\n)Pnts\n  Field(zsel) VAR(zsel) VAL(S)\n)End\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SHOWJPAQ": {"ttr": 16908, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x02\\x008\\x00\\x885_\\x01\\t \\x1f\\x15P\\x01k\\x00V\\x00(\\xc3\\xc2\\xe3\\xf4\\xf7\\xf8@@@@'", "ispf": {"version": "02.02", "flags": 0, "createdate": "1988-12-20T00:00:00", "modifydate": "2009-07-20T15:50:38", "lines": 363, "newlines": 86, "modlines": 40, "user": "CBT478"}, "text": "//GILBERTS JOB (ACCT#),SHOWJPAQ,\n//*RESTART=GO,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE),REGION=6M\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n*PROCESS NOBATCH,USING(WARN(8))\n***********************************************************************\n*                                                                     *\n* MODULE NAME = SHOWJPAQ                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = Display contents of the JPAQ in TSO environment  *\n*                                                                     *\n* STATUS = R202                                                       *\n*                                                                     *\n* FUNCTION = This assembler command can be invoked under TSO or ISPF  *\n*            to display the contents of the Job Pack Area (JPAQ).     *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*          http://gsf-soft.com/Freeware/                              *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*    DEPENDENCIES: OS/390 or z/OS                                     *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (CSECT TYPE)                               *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 2K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE ANY, AMODE 31,                   *\n*                 PROBLEM STATE, KEY 8                                *\n*                 APF AUTHORIZATION: NONE                             *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n* 100 Initial version called MAPJPAQ                             1988 *\n* 200 New version, based on the JPAQ section of SHOWMVS          2004 *\n* 201 PDATA=X'08020000,007D2D00,008D1768,00000000'               2009 *\n*     Move left                                                       *\n* 202 CDATTR3                                                         *\n*                                                                     *\n&REL     SETC  'R202'                                                 *\n***********************************************************************\nSHOWJPAQ CSECT\nSHOWJPAQ AMODE 31\n         B     BEGIN-*(,R15)\n&D       SETC  '&SYSDATE'(7,2)'-'.'&SYSDATE'(1,2)'-'.'&SYSDATE'(4,2)\n         DC    C'GSF Utilities - SHOWJPAQ &REL - 20&D &SYSTIME',0H'0'\nBEGIN    BAKR  R14,0\n         LR    R12,R15\n         USING SHOWJPAQ,R12\n         GETMAIN R,LV=DYNAML\n         LR    R11,R1\n         USING DYNAM,R11\n         L     R7,X'021C'(,0)          PSATOLD   A(TCB)\n         USING TCB,R7\n*---------------------------------------------------------------------*\n*                                                                     *\n*   NAME     ENTPT    ATTRB SP ATTR  ATTR2  USE    MAJ-CDE   LENGTH   *\n*                                                                     *\n*   SHOWJPAQ 840BAA30   30  FC  31    22    0001             0007E0   *\n*   JPAQ     840BAA30   30      35    02           SHOWJPAQ           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         STRING       'Name     EntPt   Attrb Sp Attr Attr2 Attr3 Use  X\n               Maj-CDE  Length Load-pnt Data-Set Name',INTO=LINE\n         BAL   R10,PUTLINE          <- Print line\n         BAL   R10,PUTBLANK         <- Print blank line\n*\n         SLR   R5,R5                   first-time switch\n*LOOP\nJPAQ11   BAL   R14,NEXTCDE          <- get next CDE\n         LTR   R5,R5                   end of JPAQ?\n         BZ    JPAQ91                  yes, exit\n         USING CDENTRY,R5\n*\n         CSVQUERY SEARCH=JPALPA,       SEARCH JPAQ                     +\n               INADDR=CDENTPT,         ADDRESS                         +\n               OUTEPNM=EPNM,           RETURN EP NAME                  +\n               OUTPID=PID,             PROVIDER ID                     +\n               OUTPDATA=PDATA,         PROVIDER DATA                   +\n               OUTEPTKN=MODTOKEN,      RETURN TOKEN                    +\n               MF=(E,CSVQRYWK)         WORK AREA\n         LTR   R2,R15                  pass return code\n         BZ    JPAQ17                  OK, continue\n         STRING 'CSVQUERY Failed, R15=',((R2),,L),INTO=CSVDWORK\n         LA    R1,CSVDWORK             message\n         B     JPAQ82\n*\nJPAQ17   CLC   =C'PGMF',PID            LOADED FROM JOBLIB/STEPLIB?\n         BNE   JPAQ31                  no, jump\n         OC    PDATA,PDATA             Any provider data returned?\n         BZ    JPAQ41                  no, quit\n         LA    R2,X'000000FF'          mask for NR\n         N     R2,PDATA_TTRN           load TTRN from Provider Data\n         CLI   PDATA+1,X'01'           LOADED FROM -LNKLST- ?\n         BE    JPAQ34                  yes, jump\n         CLI   PDATA+1,X'02'           LOADED FROM TASKLIB ?\n         BE    JPAQ50                  yes, jump\n*\n*        Loaded from JOBLIB/STEPLIB/TASKLIB\n*\nJPAQ21   TM    PDATA,X'80'             loaded from a PDSE?\n         BZ    JPAQ21L                 no, jump\n         L     R3,PDATA_DDN+4          yes, get LFMD address\n         MVC   PDATA_DDN,044(R3)       move true ddname\nJPAQ21L  L     R3,TCBTIO               TIOT\n         USING TIOT1,R3\n         LA    R3,TIOENTRY             First TIOT Entry\n         USING TIOENTRY,R3\n         SLR   R0,R0                   PREPARE IC\n*LOOP\nJPAQ22   CLC   PDATA_DDN,TIOEDDNM      is this my ddname ?\n         BE    JPAQ60                  yes, exit loop\n         IC    R0,TIOELNGH             LOAD LENGTH OF CURRENT ENTRY\n         ALR   R3,R0                   BUMP UP TO NEXT ENTRY\n         CLI   TIOELNGH,0              IS THIS THE END?\n         BNZ   JPAQ22                  NOT YET, LOOP THROUGH TIOT\n*ENDLOOP\n*        DDname has been freed (not found in TIOT)\n*\n         STRING (PDATA_DDN,,T),'+',((R2),,L),INTO=CSVDWORK\n         LA    R1,CSVDWORK             message\n         B     JPAQ80                  exit\n*\n*        Get module's TTRN in linklist (PID=LLAF)\n*\nJPAQ31   CLC   =C'LLAF',PID            LOADED FROM LINK-LIST?\n         BNE   JPAQ41                  NO, EXIT\n         MVC   CSVDWORK,=AL2(1,L'CSVDWORK)\n         MVC   PDS2NAME,EPNM           EPNAME\n         L     R1,CVTPTR               CVT address\n         L     R1,CVTLINK-CVTMAP(,R1)  link-list DCB\n         BLDL  (1),CSVDWORK            ISSUE BLDL (to LLA)\n         LTR   R15,R15\n         BNZ   JPAQ45                  NOT FOUND, QUIT\n         IC    R2,PDS2CNCT             pick-up concat#\n         MVC   PDATA_DDN,DDNAME        move ddname\n*\n*        Find link-list dsname from LLT\n*\nJPAQ34   MH    R2,=Y(LLTNEXT-LLTENTRY) make it an offset into the LLT\n         L     R14,X'0224'(,0)         PSAAOLD   A(ASCB)\n         L     R14,ASCBASSB-ASCB(,R14) ASSB\n         L     R14,ASSBDLCB-ASSB(,R14) CSVDLCB\n         L     R3,DLCBLLT@-DLCB(,R14)  LLT\n         LA    R1,LLTDSN-LLT(R2,R3)    change offset to address\n         B     JPAQ80                  exit\n*\n*        PDATA=zero or PID not equal to PGMF or LLAF\n*\nJPAQ41   STRING 'PID(',(PID,,T),')',INTO=WORK44\n         LA    R1,WORK44               message\n         LA    R15,4                   RC=4\n         B     JPAQ82\n*\n*        BLDL_RC>0\n*\nJPAQ45   STRING 1X,INTO=WORK44         dsname not found\n         B     JPAQ82\n*\n*        PDATA=X'08020000,007D2D00,008D1768,00000000'\n*        PDATA may be related to DESERV/IGWSMDE ???\n*        It seems that PDATA+0=X'08' ???\n*                      PDATA+1=PDS2LIBF (the \"Z byte\").\n*                      PDATA+4=TTRN\n*                      PDATA+8=A(TCB)\n*\nJPAQ50   LA    R1,TCB                  R1=A(TCB) - my own TCB\n         TM    PDATA+0,X'08'           X'08' ??\n         BNO   JPAQ51                  no, jump\n         L     R14,PDATA+8             R14=A(TCB)\n         CLC   TCBTIO,TCBTIO-TCB(R14)  is this a TCB ?\n         BNE   JPAQ51                  no, jump\n         LR    R1,R14                  R1=A(TCB)\nJPAQ51   L     R1,TCBJLB-TCB(,R1)      R1=A(DCB) STEPLIB/JOBLIB/TASKLIB\n         LH    R3,040(,R1)             DCBTIOT\n         AL    R3,TCBTIO               ADD A(TIOT)\n         MVC   PDATA_DDN,TIOEDDNM      copy JOBLIB/STEPLIB ddname\n*\n*        DDname found - Retrieve dsname from JFCB\n*\nJPAQ60   LTR   R2,R2                   first data set in concat?\n         BZ    JPAQ66                  yes, exit\n         SLR   R0,R0\n*loop\nJPAQ61   IC    R0,TIOELNGH             LOAD LENGTH OF CURRENT ENTRY\n         ALR   R3,R0                   BUMP UP TO NEXT ENTRY\n         BCT   R2,JPAQ61               next concat#\n*endloop\nJPAQ66   LA    R2,CSVDWORK+4           WORK AREA\n         ST    R2,CSVDWORK             WORK AREA\n         USING ZB505,R2\n         XC    SWAEPAX,SWAEPAX         CLEAR WORK AREA\n         MVC   SWVA,TIOEJFCB           SVA OF THE JFCB\n         SWAREQ FCODE=RL,EPA=CSVDWORK,MF=(E,SWAREQL1),UNAUTH=YES\n         L     R1,SWBLKPTR             31-BIT ADDRESS OF JFCB\n*\nJPAQ80   SLR   R15,R15                 RC=0\n*\nJPAQ82   L     R6,CDXLMJP              POINT TO XL (OR MAJOR CDE)\n         TM    CDATTR,CDMIN            CHECK ATTRIBUTES\n         BO    JPAQ85                  JUMP IF THIS IS A MINOR CDE\n         USING XTLST,R6\n         STRING CDNAME,1X,(CDENTPT,,X),2X,(CDATTRB,,X),2X,(CDSP,,X),2X,X\n               (CDATTR,,X),4X,(CDATTR2,,X),4X,(CDATTR3,,X),2X,         X\n               (CDUSE,,X),10X,(XTLMSBLN,,X),1X,(XTLMSBAD,,X),          X\n               1X,((R1),44,T),         DSname from CDEX                X\n               INTO=LINE\n         BAL   R10,PUTLINE          <- Print line\n         B     JPAQ11\nJPAQ85   STRING CDNAME,1X,(CDENTPT,,X),2X,(CDATTRB,,X),6X,             X\n               (CDATTR,,X),4X,(CDATTR2,,X),4X,(CDATTR3,,X),            X\n               7X,(CDNAME-CDENTRY(R6),8),                              X\n               17X,((R1),44,T),        DSname from CDEX                X\n               INTO=LINE\n         BAL   R10,PUTLINE          <- Print line\n         B     JPAQ11                  next JPAQ entry\n*ENDLOOP\n*\n* ATTRB: 80-EOM 40-IDENTY 20-DIRTY 10-CDEX 08-LPDE 04-GLOBAL 02-CONTA..\n*  ATTR: 80-NIP/MLPA 40-NIC 20-RENT 10-REUS 08-NREUS 04-MINOR 02-JPAQ\n* ATTR2: 80-SP0 40-REL 20-XLE 10-RLC 08-AMODE_ANY 04-OVLY 02-APFLIB ...\n*\nJPAQ91   BAL   R10,PUTBLANK         <- Print blank line\n         STRING 'ATTRB: 80-EOM 40-IDENTY 20-DIRTY 10-CDEX ',           X\n               '08-LPDE 04-GLOBAL 02-CONTAMINATION 01-RACF',           X\n               INTO=LINE\n         BAL   R10,PUTLINE          <- NEXT LINE\n         STRING ' ATTR: 80-NIP/MLPA 40-NIC 20-RENT 10-REUS ',          X\n               '08-NREUS 04-MINOR 02-JPAQ 01-NOT_OL',                  X\n               INTO=LINE\n         BAL   R10,PUTLINE          <- NEXT LINE\n         STRING 'ATTR2: 80-SP0 40-REL 20-XLE 10-RLC ',                 X\n               '08-AMODE_ANY 04-OVLY 02-APFLIB 01-AC=1',               X\n               INTO=LINE\n         BAL   R10,PUTLINE          <- NEXT LINE\n         STRING 'Attr3: 80-OpMvsPath 40-PML',                          X\n               INTO=LINE\n         BAL   R10,PUTLINE          <- NEXT LINE\n         BAL   R10,PUTBLANK         <- Print blank line\n         FREEMAIN R,LV=DYNAML,A=(R11)\n*\n         SLR   R15,R15                 RC=0\n         PR\n*\n*---------------------------------------------------------------------*\n*        Scan JPAQ backwards (from oldest CDE)                        *\n*              Input:  R5 points to current CDENTRY                   *\n*              Output: R5 point to next CDE                           *\n*---------------------------------------------------------------------*\n*\nNEXTCDE  LR    R0,R5                   point to current CDE\n         L     R5,TCBJSTCB             job-step TCB\n         L     R5,TCBJPQ-TCB(,R5)      Top CDE (most recent)\n         LTR   R5,R5                   empty JPAQ?\n         BZR   R14                     yes, goback with R5=0\n         USING CDENTRY,R5\n*--LOOP\nNEXTCDE2 CL    R0,CDCHAIN              is this the next RB?\n         BER   R14                     yes, goback\n         ICM   R5,B'1111',CDCHAIN      previous CDE\n         BNZ   NEXTCDE2                not found yet, loop more\n*--ENDLOOP\n         BR    R14                     goback with R5=0\n*---------------------------------------------------------------------*\n*        Display message using PUTLINE                                *\n*        ECT=LWAPECT,UPT=PSCBUPT in case we're CALLed as a program    *\n*---------------------------------------------------------------------*\nPUTBLANK MVI   LINE,C' '               blank line\n         LA    R15,1                   length=1\nPUTLINE  LA    R0,4(,R15)              length\n         SLL   R0,16                   ll,00\n         STCM  R0,B'1111',LINEHDR      store RDW\n         L     R1,X'0224'(,0)          PSAAOLD   A(ASCB)\n         L     R1,ASCBASXB-ASCB(,R1)   A(ASXB)\n         L     R1,X'0014'(,R1)         ASXBLWA   A(LWA)\n         L     R0,X'0020'(,R1)         LWAPECT   A(ECT)\n         L     R14,X'0018'(,R1)        LWAPSCB   A(PSCB)\n         L     R14,X'0034'(,R14)       PSCBUPT   A(UPT)\n         L     R15,CVTPTR(,0)          CVT ADDRESS\n         L     R15,CVTPUTL-CVTMAP(,R15) A(IKJPUTL)\n         PUTLINE PARM=PUTBLK,UPT=(R14),ECT=(R0),ECB=ECB1,              X\n               ENTRY=(15),             A(IKJPUTL)                      X\n               OUTPUT=(LINEHDR,TERM,SINGLE,DATA),MF=(E,TENWORDS)\n         BR    R10\n*---------------------------------------------------------------------*\n*        Dynamic Storage                                              *\n*---------------------------------------------------------------------*\nDYNAM    DSECT\nTENWORDS DS    10F\nECB1     DS    F\nPUTBLK   PUTLINE MF=L\nSWAREQL1 SWAREQ MF=L\n         CSVQUERY MF=(L,CSVQRYWK),PLISTVER=MAX\n*\nBLDLWORK DS    0F,AL2(1,L'CSVDWORK)    prefix for BLDL\n         IHAPDS DSECT=NO,PDSBLDL=YES   PDS Directory\nCSVDWORK EQU   BLDLWORK,*-BLDLWORK     Work area for CSVDSN routine\n*\nLRETCODE DS    F                       Return code\nLRSNCODE DS    F                       Reason code\nPDATA    DS    XL16\nPDATA_DDN EQU PDATA+8,8,C'C'           DDNAME\nPDATA_TTRN EQU PDATA+4,4,C'X'          TTRN\nPID      DS    XL4\nMODTOKEN DS    XL8\nPDATA_DSN DS   CL44\n*\nLINEHDR  DS    Y(L'LINE+4,0)           PUTLINE\nLINE     DS    CL121\n*\nWORK44   DS    CL44\nDDNAME   DS    CL8'-LNKLST-'\nEPNM     DS    CL8'SHOWJPAQ'\nEYECATCH DS    CL120\nDYNAML   EQU   *-DYNAM\n*---------------------------------------------------------------------*\n*        MVS control blocks used in this program                      *\n*---------------------------------------------------------------------*\n         CVT   PREFIX=YES,DSECT=YES,LIST=NO\n         IKJTCB DSECT=YES,LIST=NO      Task Control Block\n         IHACDE                        Contents Directory Entry\n         IEFTIOT1                      Task Input-Output Table\n         IEFZB505 LOCEPAX=YES          EPA mapping for SWAREQ\n         IEFJESCT                      JES Vector Table\n         IHAXTLST                      Extent List\n         IHAASCB DSECT=YES             Address Space Control Block\n         IHAASSB LIST=NO               Address Space Secondary Block\n         CSVDLCB TITLE=NO              Dynamic Link-List\n*        IHALLT DSECT=YES              LNKLST/LPALST tables\nLLT      DSECT\nLLTLLT   DS    C'LLT '                 BLOCK ACRONYM\nLLTNO    DS    F                       NUMBER OF ENTRIES\nLLTENTRY DS    0CL45                   DSNAME ENTRY\nLLTDSNL  DS    FL1                     DSNAME LENGTH AFTER TRUNCATION\nLLTDSN   DS    CL44                    DATA SET NAME\nLLTNEXT  EQU   *                       NEXT ENTRY\n*\n         STRING (GENERATE,,LOCTR)\n         YREGS                         R0-R15\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DSN=GILBERT.FILE183.PDS,DISP=SHR               STRING\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,5)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,2),DISP=(,PASS),BLKSIZE=3200\n//*\n//LKED    EXEC PGM=LINKEDIT,PARM='LIST,MAP,RENT,REFR'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=GILBERT.FILE183.LOAD(SHOWJPAQ),DISP=SHR,\n// SPACE=(CYL,(0,1))\n//*\n//GO      EXEC PGM=IKJEFT01,TIME=(,1)\n//STEPLIB  DD DSN=GILBERT.FILE183.LOAD,DISP=SHR\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\nSHOWJPAQ\nCALL *(SHOWJPAQ)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHOWMACS": {"ttr": 17159, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\x1a\\x00\\x00\\x00\\x842/\\x01\\x01\\x00\\x1f\\t\\x04\\x00\\x04\\x00\\x84\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf5\\xf1@@@@'", "ispf": {"version": "06.26", "flags": 0, "createdate": "1984-11-17T00:00:00", "modifydate": "2001-01-01T09:04:00", "lines": 4, "newlines": 132, "modlines": 0, "user": "CBT451"}, "text": "\n     The latest ShowMVS source code is now distributed\n   in file 492 of the CBT tape at http://www.cbttape/org\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SHOWMVS": {"ttr": 17161, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\x1a\\x00\\x00\\x00\\x842/\\x01\\x01\\x00\\x1f\\t\\x04\\x00\\x04\\x00\\x84\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf5\\xf1@@@@'", "ispf": {"version": "06.26", "flags": 0, "createdate": "1984-11-17T00:00:00", "modifydate": "2001-01-01T09:04:00", "lines": 4, "newlines": 132, "modlines": 0, "user": "CBT451"}, "text": "\n     The latest ShowMVS source code is now distributed\n   in file 492 of the CBT tape at http://www.cbttape/org\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SHOWTIOT": {"ttr": 17163, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00%\\x00\\x98\\x11/\\x01\\t\\x19?\\x18D\\x00<\\x00-\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf8@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-04-22T00:00:00", "modifydate": "2009-07-12T18:44:25", "lines": 60, "newlines": 45, "modlines": 0, "user": "CBT478"}, "text": "/*------------------------------------------------------------ REXX --*\\\n|*                                                                    *|\n|* MODULE NAME = SHOWTIOT                                             *|\n|*                                                                    *|\n|* DESCRIPTIVE NAME = Display TIOT Entries (Allocated Files)          *|\n|*                                                                    *|\n|* STATUS = R100                                                      *|\n|*                                                                    *|\n|* FUNCTION = The SHOWTIOT exec scans the TIOT and displays active    *|\n|*            entries, particularly their dsname and volser.          *|\n|*                                                                    *|\n|*            The output is a subset of what's produced by the        *|\n|*            LISTALC TSO cmd and by ISRDDN, an ISPF utility          *|\n|*            program invoked via the DDLIST cmd.                     *|\n|*                                                                    *|\n|*            The primary interest in SHOWTIOT is how to retrieve     *|\n|*            information about allocated files in REXX, and in       *|\n|*            COBOL or PL/I as well.                                  *|\n|*                                                                    *|\n|*            This version of SHOWTIOT does NOT support               *|\n|*            multi-volume TIOT entries.                              *|\n|*                                                                    *|\n|* AUTHOR   = Gilbert Saint-Flour <carlos@gsf-soft.com>               *|\n|*            http://gsf-soft.com/Freeware/                           *|\n|*                                                                    *|\n|* DEPENDENCIES = TSO/E V2                                            *|\n|*                SWAREQ REXX Routine                                 *|\n|*                                                                    *|\n|* SYNTAX   = SHOWTIOT                                                *|\n|*                                                                    *|\n\\*--------------------------------------------------------------------*/\ntcb = C2D(STORAGE(21C,4))                   /* TCB          PSATOLD  */\ntiot= C2D(STORAGE(D2X(tcb+12),4))           /* TIOT         TCBTIO   */\nn=0\nNUMERIC DIGITS 10\nSAY 'DDNAME  ' Left('Data Set Name',44) 'VOLSER TIOENTRY  SVA     JFCB'\nDo Until STORAGE(D2X(tiot+24),1) = '00'X\n  sva = STORAGE(D2X(tiot+24+12),3)          /* JFCB         TIOEJFCB */\n  jfcb=SWAREQ(sva)                     /* convert SVA to 31-bit addr */\n  ddn=STORAGE(D2X(tiot+24+4),8)             /* DDname       IOCBDSNM */\n  If jfcb>16 & Left(ddn,1)>'00'x Then Do\n    dsn=STORAGE(D2X(jfcb),44)               /* dsname       JFCBDSNM */\n    vol=STORAGE(D2X(jfcb+118),6)            /* volser       JFCBVOLS */\n    tioelink=STORAGE(D2X(tiot+24+3),1)      /* Flags        TIOELINK */\n    If STORAGE(D2X(tiot+24+1),1)<'80'X Then Do /* TIOESTTA  TIOSLTYP */\n      if vol='      ' THEN Do\n        vol='VIO   '\n        If tioelink='02'X Then\n          vol='SYSOUT'\n        End\n      SAY ddn dsn vol C2X(STORAGE(D2X(tiot+24),4)) C2X(sva) D2X(jfcb)\n      /* C2X(tioelink) */\n      End\n    End\n  tiot=tiot+20                              /* next TIOT entry       */\n  n=n+1; if n=111 Then Exit 20              /* prevent endless loop  */\nEND\nExit\n  /* To make SHOWTIOT work faster, copy the SWAREQ routine here   */\n  /* and activate the first line which contains SWAREQ: PROCEDURE */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SHOWVTOC": {"ttr": 17165, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x01_\\x01\\x04\\x02\\x8f\\x08#\\x00\\x12\\x00\\x10\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf6\\xf5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-15T00:00:00", "modifydate": "2004-01-28T08:23:00", "lines": 18, "newlines": 16, "modlines": 0, "user": "CBT465"}, "text": ")PANEL                    /* This ISPF panel is part of the ShowDASD package */\n)ATTR                     /* authored by Gilbert Saint-Flour                 */\n ? type(output)\n)BODY cmd()\n _ZCMD      +\n ?ZDLPVL+\n)INIT\n VGET (ZDDNVOL) SHARED\n &ZCMD = &Z\n &ZUOPT = 'V'\n &ZDLPVL = &ZDDNVOL\n IF (&ZDDNSKP NE '1') .RESP = ENTER\n ELSE .RESP = END\n &ZDDNSKP = '1'\n)REINIT\n .RESP = END\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STEMEDI#": {"ttr": 17167, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x13#\\x0f\\x01\\x13#\\x0f\\x14F\\x07%\\x07%\\x00\\x00\\xd9\\xd5\\xd6\\xe6\\xc1\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-08-18T00:00:00", "modifydate": "2013-08-18T14:46:00", "lines": 1829, "newlines": 1829, "modlines": 0, "user": "RNOWAK"}, "text": "./ ADD NAME=$$$#DATE 0487-13230-13230-1424-00012-00012-00000-CBT-487\nREGULAR CBT TAPE - VERSION 487    FILE:  895\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT487.FILE895\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 8 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,821 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   08/18/13    14:24:35    UTC-4:00\n\n./ ADD NAME=$$NOTE01 0100-13230-13230-1416-00035-00035-00000-SBGOLOB\nSubject:  CBT Tape File 183\nFrom:     \"Rainer Nowak\" <rainer_nowak@gmx.de>\nDate:     8/17/2013 4:08 PM\nTo:       sbgolob@cbttape.org\n\nHello Mr. Golob,\n\nFor many years the CBT tape has been a great help for me. Usually\nI used the programs 'as is', but now a colleague wants a way to\nshow him all the stem variables in a REXX exec.  OK, there's\nSTEMEDIT in CBT tape file 183, but this can only be used for stem\nvariables like a.1, a.2 and so on.  One big advantage of REXX is,\nthat you can use stem variables in the way like a. =0;do i=1 to\nwords(text);j=WORD(text,i);a.j=a.j+1;end . So you can count how\nmany times a word is used in a text.  For such stem variables you\ncan't use STEMEDIT.  So I changed STEMEDIT to VIEW and EDIT all\nvariables in a REXX exec.  You'll find the changed source in the\nzip file I attached to this eMail.\n\nThere are also two edit macros to be used with STEMEDIT.  Call\nSTEMEMCB at the beginning of the edit session to change all '00'x\nin blanks and shift the '=' to the left.  At the end of the edit\nsession STEMEMCE should be called to end up the lines with '00'x.\nI've also changed TALLY to work under z/OS 1.13.  I know you don't\nneed TALLY anymore, because DSLIST now can do this for you.  But\nthe idea behind TALLY is, to find the ISPF table used by DSLIST\nand use it for your own needs.  So I wrote DSL as an example, how\nto use this table.  In DSL you can exclude Datasets from the list,\nflip between excluded and visible and do HSM RECALL for all\nvisible Datasets.  I hope these programs will be a help for someone.\n\nThank you for your help and work for so many years.\n\nRainer Nowak\n\n./ ADD NAME=@FILE895 0487-13230-13230-1424-00043-00043-00000-CBT-487\n//***FILE 895 is from Rainer Nowak and contains some modifications  *   FILE 895\n//*           to Gilbert Saint-flour's STEMEDIT program as well as  *   FILE 895\n//*           some other things that are related.                   *   FILE 895\n//*                                                                 *   FILE 895\n//*           Please refer to CBT File 183 for Gilbert              *   FILE 895\n//*           Saint-flour's materials.                              *   FILE 895\n//*                                                                 *   FILE 895\n//*           email:  rainer_nowak@gmx.de                           *   FILE 895\n//*                                                                 *   FILE 895\n//*                   Description of Contents                       *   FILE 895\n//*                   ----------- -- --------                       *   FILE 895\n//*                                                                 *   FILE 895\n//*     For many years the CBT tape has been a great help for       *   FILE 895\n//*     me. Usually I used the programs 'as is', but now a          *   FILE 895\n//*     colleague wants a way to show him all the stem variables    *   FILE 895\n//*     in a REXX exec.  OK, there's STEMEDIT in CBT tape file      *   FILE 895\n//*     183, but this can only be used for stem variables like      *   FILE 895\n//*     a.1, a.2 and so on.  One big advantage of REXX is, that     *   FILE 895\n//*     you can use stem variables in the way like a. =0;do i=1     *   FILE 895\n//*     to words(text);j=WORD(text,i);a.j=a.j+1;end . So you can    *   FILE 895\n//*     count how many times a word is used in a text.  For such    *   FILE 895\n//*     stem variables you can't use STEMEDIT.  So I changed        *   FILE 895\n//*     STEMEDIT to VIEW and EDIT all variables in a REXX exec.     *   FILE 895\n//*     You'll find the changed source in the zip file I            *   FILE 895\n//*     attached to this eMail.                                     *   FILE 895\n//*                                                                 *   FILE 895\n//*     There are also two edit macros to be used with              *   FILE 895\n//*     STEMEDIT.  Call STEMEMCB at the beginning of the edit       *   FILE 895\n//*     session to change all '00'x in blanks and shift the '='     *   FILE 895\n//*     to the left.  At the end of the edit session STEMEMCE       *   FILE 895\n//*     should be called to end up the lines with '00'x.  I've      *   FILE 895\n//*     also changed TALLY to work under z/OS 1.13.  I know you     *   FILE 895\n//*     don't need TALLY anymore, because DSLIST now can do         *   FILE 895\n//*     this for you.  But the idea behind TALLY is, to find        *   FILE 895\n//*     the ISPF table used by DSLIST and use it for your own       *   FILE 895\n//*     needs.  So I wrote DSL as an example, how to use this       *   FILE 895\n//*     table.  In DSL you can exclude Datasets from the list,      *   FILE 895\n//*     flip between excluded and visible and do HSM RECALL for     *   FILE 895\n//*     all visible Datasets.  I hope these programs will be a      *   FILE 895\n//*     help for someone.                                           *   FILE 895\n//*                                                                 *   FILE 895\n//*     Rainer Nowak                                                *   FILE 895\n//*                                                                 *   FILE 895\n./ ADD NAME=DSL      0100-13230-13230-1410-00353-00353-00000-RNOWAK\n/* REXX **************************************************************/\n/* MEMBER : DSL                                                      */\n/*                                                                   */\n/* DESCRIPTION:                                                      */\n/* REXX to work with the DSLIST (=3.4).                              */\n/* Must be called from within DSLIST.                                */\n/* To fill up all fields in the DSLIST panel, you must scroll to the */\n/* left (or right) and to the bottom.                                */\n/* %DSL X parm=value : eXclude Datasets from the list. parm can be   */\n/*                     EXT (for extents), ORG, RECFM, LRECL, BLKSIZ  */\n/*                     (for which the value must match) and CAT, VOL,*/\n/*                     CDATE, EDATE, RDATE, DSN (for which value only*/\n/*                     needs to be included). Always all matching    */\n/*                     datasets will be excluded.                    */\n/*                                                                   */\n/* %DSL FLIP         : like FLIP in the editor you flip between      */\n/*                     excluded and visible.                         */\n/*                                                                   */\n/* %DSL HR           : HSM RECALL will be send for all visible       */\n/*                     migrated datasets. This is just an example    */\n/*                     how to work with the DSLIST table.            */\n/*                                                                   */\n/* Example: Exclude all PDS  %DSL X ORG=PO                           */\n/*                                                                   */\n/* AUTHOR : Rainer Nowak                                             */\n/* DATE   : 30.05.2013                                               */\n/*                                                                   */\n/*********************************************************************/\nARG p1 p2\nSELECT\n   WHEN p1 = 'X' THEN CALL Wue_DSL_X\n   WHEN p1 = 'HR' THEN CALL Wue_DSLHR\n   WHEN p1 = 'FLIP' THEN CALL Wue_DSL_Flip\n   OTHERWISE DO\n    SAY 'WRONG PARM. ONLY X, HR OR FLIP ARE ALLOWED.'\n   END\nEND\nEXIT\n/* ================================================================= */\n/* === Subroutins ================================================== */\n/* ================================================================= */\n\n/* ================================================================= */\n/* Pointer function                                                  */\n/* ================================================================= */\nPTR: RETURN C2D(STORAGE(D2X(ARG(1)),ARG(2)))\n/* ================================================================= */\n/* Routine to search all open tables - the heart of this REXX        */\n/* ================================================================= */\n/* get_OTab                                                          */\n/* search the open tables of this ISPF screen.                       */\n/* This REXX is based on TALLY from Gilbert Saint-flour (CBT File    */\n/* 183). The used ISPF control blocks are not documented, so use is  */\n/* of own risk.                                                      */\n/*                                                                   */\n/* The table of 3.4 has the name DSLnnnnn with variables:            */\n/* ZUDSNS       ZUSIZE       ZUUS         ZUCDATE      ZUEDATE       */\n/* ZURDATE      ZUDVOL       ZUDMVOL      ZUDEVICE     ZUCDAT2       */\n/* ZUEDAT2      ZURDAT2      ZUORG        ZUX          ZURECFM       */\n/* ZULRECL      ZUBLKSIZ     ZUSTAT       ZUDSPACU     ZULMSG        */\n/* ZULOCVOL     ZUOBTATT     ZUOBTSPC     ZUOBTDAT     ZUDXSTAT      */\n/* ZULCMDL      ZUD20V       ZUDVOL7      ZUCATNAM     ZUSIZEX       */\n/* ZUXX         ZUOVF        ZUGFLAG      ZUEATR                     */\n/* ================================================================= */\nget_OTab:\nADDRESS ISPEXEC\n\"VGET ZENVIR\"                      /* Retrieve ISPF version          */\nIF LEFT(Zenvir,8) < 'ISPF 5.9' THEN DO\n   ZMSG000S = 'ISPF is to old'\n   ZMSG000L = 'You need at least ISPF 5.9. You have 'Zenvir\n   \"SETMSG MSG(ISPZ000)\"\n   EXIT\nEND\ntcb    = PTR(540,4)             /* TCB (EXEC command)    PSATOLD  */\ntcb    = PTR(tcb+132,4)         /* TCB (ISPTASK)         TCBOTC   */\nfsa    = PTR(tcb+112,4)         /* first save area       TCBFSA   */\nr1     = PTR(fsa+24,4)          /* ISPTASK's R1                   */\ntld    = PTR(r1,4)              /* TLD address                    */\ndta    = PTR(tld+076,4)         /* DTA address           TLDDTAP  */\nstart = dta + 196               /* Address of first table name    */\nfinished = 'NO'\notnr = 0\notab.0 = otnr\nDO UNTIL finished = 'YES'\n   tbl = STORAGE(D2X(start),8) /* Name of table */\n   if C2X(LEFT(tbl,1)) = '00' then do\n      finished = 'YES'\n   end\n   else do\n      otnr = otnr + 1\n      otab.0 = otnr\n      otab.otnr.1 = tbl\n      otab.otnr.2 = STORAGE(D2X(start+8),4)\n      start = start + 12\n   end\nEND\nRETURN\n/* ================================================================= */\n/* Routine to exclude datasets from the list                         */\n/* ================================================================= */\nWue_DSL_X:\nCALL get_OTab\nif otab.0 > 0 then do\n   tbl = ''\n   do i = 1 to otab.0\n      if LEFT(otab.i.1,3) = 'DSL' then do\n         tbl = otab.i.1\n         i = otab.0 + 1\n      end\n   end\n   if LEFT(tbl,3) = 'DSL' then do\n      CALL X_parm\n      IF parm = 'NIX' THEN DO\n         \"ISPEXEC SETMSG MSG(ISRZ001)\"\n         EXIT\n      END\n      ADDRESS ISPEXEC\n      'CONTROL ERRORS RETURN'\n      'TBTOP' tbl\n      IF rc>0 THEN DO\n         ZEDLMSG=\"TBTOP failed for table\" tbl \"RC=\"rc\n         \"ISPEXEC SETMSG MSG(ISRZ001)\"\n         EXIT 8\n      END\n      rows=0;processed=0                           /* Init counters */\n      DO FOREVER\n        'TBSKIP' tbl                               /* NEXT ROW      */\n         IF rc>0 THEN LEAVE\n         'TBGET' tbl                               /* SET VARIABLES */\n         IF rc>0 THEN LEAVE\n         rows=rows+1                               /* count rows    */\n         IF zudxstat = 'N' THEN DO\n            IF parm = 'ALL' THEN DO\n               zudxstat = 'Y'\n               'TBPUT' tbl                         /* PUT VARIABLES */\n               IF RC = 0 THEN processed=processed + 1\n            END\n            ELSE DO\n             IF match = 'IN' THEN DO\n               IF POS(matchvalue,VALUE(parm)) > 0 THEN DO\n                  zudxstat = 'Y'\n                  'TBPUT' tbl                      /* PUT VARIABLES */\n                  IF RC = 0 THEN processed=processed + 1\n               END\n             END\n             ELSE DO\n               IF VALUE(parm) = matchvalue THEN DO\n                  zudxstat = 'Y'\n                  'TBPUT' tbl                      /* PUT VARIABLES */\n                  IF RC = 0 THEN processed=processed + 1\n               END\n             END\n            END\n         END\n      END\n      ZEDLMSG=\"EXCLUDE for \"processed\" of \"rows\" datasets performed.\"\n      IF processed = 0 THEN DO\n         ZEDLMSG=ZEDLMSG!!\" Use LEFT and DOWN to fill up the fields!\"\n      END\n      ZEDSMSG=\"EXCLUDE performed!!\"\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      \"ISPEXEC CONTROL NONDISPL ENTER\" /* skip one ENTER         */\n   end\n   else do\n      ZEDLMSG=\"DSL X must be called in DSLIST (=3.4).\"\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      EXIT 8\n   end\nend\nelse do\n   ADDRESS ISPEXEC\n   ZMSG000S = 'No open tables'\n   ZMSG000L = 'No open tables can be found.'\n   \"SETMSG MSG(ISPZ000)\"\nend\nRETURN\n/* ================================================================= */\n/* Routine to validate parm=value in DSL X parm=value                */\n/* ================================================================= */\nX_parm:\nIF p2 = '' THEN DO\n   parm = 'ALL'\nEND\nELSE DO\n   PARSE VAR p2 parm '=' matchvalue\n   match = 'IN'\n   SELECT\n      WHEN parm = 'VOL' THEN DO   /* Volser                          */\n         parm = 'ZUDVOL7'\n      END\n      WHEN parm = 'EXT' THEN DO   /* Extents                         */\n         parm = 'ZUX'\n         match = 'EQ'\n      END\n      WHEN parm = 'ORG' THEN DO   /* Dataset organisation            */\n         parm = 'ZUORG'\n         match = 'EQ'\n      END\n      WHEN parm = 'RECFM' THEN DO   /* Recordformat                  */\n         parm = 'ZURECFM'\n         match = 'EQ'\n      END\n      WHEN parm = 'LRECL' THEN DO   /* Recordlength                  */\n         parm = 'ZULRECL'\n         match = 'EQ'\n      END\n      WHEN parm = 'BLKSIZ' THEN DO   /* Blocksize                    */\n         parm = 'ZUBLKSIZ'\n         match = 'EQ'\n      END\n      WHEN parm = 'CAT' THEN parm = 'ZUCATNAM'   /* Catalogname      */\n      WHEN parm = 'CDATE' THEN parm = 'ZUCDATE'  /* Creation Date    */\n      WHEN parm = 'EDATE' THEN parm = 'ZUEDATE'  /* Expiration Date  */\n      WHEN parm = 'RDATE' THEN parm = 'ZURDATE'  /* Last Reference   */\n      WHEN parm = 'DSN' THEN parm = 'ZUDSNS'     /* Dataset name     */\n      OTHERWISE DO\n         ZEDLMSG=\"Wrong Parm :\"parm\n         parm = 'NIX'\n      END\n   END\nEND\nRETURN\n/* ================================================================= */\n/* Routine to flip between excluded and visible                      */\n/* ================================================================= */\nWue_DSL_Flip:\nCALL get_OTab\nif otab.0 > 0 then do\n   tbl = ''\n   do i = 1 to otab.0\n      if LEFT(otab.i.1,3) = 'DSL' then do\n         tbl = otab.i.1\n         i = otab.0 + 1\n      end\n   end\n   if LEFT(tbl,3) = 'DSL' then do\n      ADDRESS ISPEXEC\n      'CONTROL ERRORS RETURN'\n      'TBTOP' tbl\n      IF rc>0 THEN DO\n         ZEDLMSG=\"TBTOP failed for table\" tbl \"RC=\"rc\n         \"ISPEXEC SETMSG MSG(ISRZ001)\"\n         EXIT 8\n      END\n      rows=0;processed=0                           /* Init counters */\n      DO FOREVER\n        'TBSKIP' tbl                               /* NEXT ROW      */\n         IF rc>0 THEN LEAVE\n         'TBGET' tbl                               /* SET VARIABLES */\n         IF rc>0 THEN LEAVE\n         rows=rows+1                               /* count rows    */\n         IF zudxstat = 'N' THEN DO\n            zudxstat = 'Y'\n         END\n         ELSE DO\n            zudxstat = 'N'\n         END\n         'TBPUT' tbl                               /* PUT VARIABLES */\n         IF RC = 0 THEN processed=processed + 1\n      END\n      ZEDLMSG=\"FLIP for \"processed\" of \"rows\" datasets performed.\"\n      ZEDSMSG=\"FLIP performed!!\"\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      \"ISPEXEC CONTROL NONDISPL ENTER\" /* skip one ENTER             */\n   end\n   else do\n      ZEDLMSG=\"DSL FLIP must be called in DSLIST (=3.4).\"\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      EXIT 8\n   end\nend\nelse do\n   ADDRESS ISPEXEC\n   ZMSG000S = 'No open tables'\n   ZMSG000L = 'No open tables can be found.'\n   \"SETMSG MSG(ISPZ000)\"\nend\nRETURN\n/* ================================================================= */\n/* Routine to RECALL a list of datasets                              */\n/* ================================================================= */\nWue_DSLHR:\nCALL get_OTab\nif otab.0 > 0 then do\n   tbl = ''\n   do i = 1 to otab.0\n      if LEFT(otab.i.1,3) = 'DSL' then do\n         tbl = otab.i.1\n         i = otab.0 + 1\n      end\n   end\n   if LEFT(tbl,3) = 'DSL' then do\n      ADDRESS ISPEXEC\n      'CONTROL ERRORS RETURN'\n      'TBTOP' tbl\n      IF rc>0 THEN DO\n         ZEDLMSG=\"TBTOP failed for table\" tbl \"RC=\"rc\n         \"ISPEXEC SETMSG MSG(ISRZ001)\"\n         EXIT 8\n      END\n      rows=0;processed=0                           /* Init counters */\n      DO FOREVER\n        'TBSKIP' tbl                               /* NEXT ROW      */\n         IF rc>0 THEN LEAVE\n         'TBGET' tbl                               /* SET VARIABLES */\n         IF rc>0 THEN LEAVE\n         rows=rows+1                               /* count rows    */\n         IF LEFT(zudvol7,6) = 'MIGRAT' & zudxstat = 'N' THEN DO\n            dsn = STRIP(zudsns,'B',' ')\n            ret = Wue_HR_Func(dsn)\n            IF ret = 9 THEN DO\n               say \"Dataset \"dsn\" is not migrated.\"\n            END\n            processed=processed + 1\n         END\n      END\n      ZEDLMSG=\"RECALL for \"processed\" of \"rows\" datasets was send.\"\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n   end\n   else do\n      ZEDLMSG=\"DSL HR must be called in DSLIST (=3.4).\"\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      EXIT 8\n   end\nend\nelse do\n   ADDRESS ISPEXEC\n   ZMSG000S = 'No open tables'\n   ZMSG000L = 'No open tables can be found.'\n   \"SETMSG MSG(ISPZ000)\"\nend\nRETURN\n/* ================================================================= */\n/* Function to send HRECALL for one dataset                          */\n/* ================================================================= */\nWue_HR_Func:\nPROCEDURE\nARG dsn\npref = SYSVAR(SYSPREF)\nADDRESS TSO\n\"profile noprefix\"\nretcode = LISTDSI(\"'\"dsn\"' DIRECTORY SMSINFO NORECALL\")\nif SYSREASON = 9 then do   /* dataset migrated */\n   \"HRECALL ('\"dsn\"') NOWAIT\"\n   ret = RC\nend\nelse do\n   ret = 9\nEND\nADDRESS TSO\nif pref = '' then \"profile noprefix\"\nelse \"profile prefix(\"pref\")\"\nreturn ret\n./ ADD NAME=STEMEDIT 0100-13230-13230-1410-01242-01242-00000-RNOWAK\n//GILBERTV JOB (ACCT#),STEMEDIT,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = STEMEDIT                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = Display REXX Stem Variables using BRIF or VIIF.  *\n*                                                                     *\n* STATUS = R208                                                       *\n*                                                                     *\n* FUNCTION = This assembler sub-routine can be invoked by a REXX      *\n*            EXEC to display the contents of stem variables using     *\n*            the ISPF BRIF, VIIF or EDIT services.  STEMEDIT is       *\n*            a nice complement to the REXX OUTTRAP function,          *\n*            when it is used in the ISPF/PDF environment.             *\n*                                                                     *\n*            STEMEDIT can also PULL lines from the data stack         *\n*            instead of using stem variables.  This only works        *\n*            with EDIT or VIEW, i.e. not with BROWSE.                 *\n*                                                                     *\n* R208       STEMEDIT can be used to view or edit all variables.      *\n* R208       Together with \"TRACE ?R\" STEMEDIT can be used for        *\n* R208       debugging your REXX programs.                            *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos\u00bagsf-soft.com>                  *\n*          http://gsf-soft.com/Freeware/                              *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*    DEPENDENCIES: OS/390 R10 or z/OS                                 *\n*                  ISPF/PDF V3 (or above)                             *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (CSECT TYPE)                               *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 2K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE ANY, AMODE 31,                   *\n*                 PROBLEM STATE, KEY 8                                *\n*                 APF AUTHORIZATION: NONE                             *\n*                                                                     *\n* SYNTAX  =  See below                                                *\n*                                                                     *\n*    CALL STEMEDIT  service,                                          *\n*                   stemname                                          *\n*                   <,firstelem>                                      *\n*                   <,stemcount>                                      *\n*                   <,title>                                          *\n*                   <,panel>                                          *\n*                   <,lrecl>                                          *\n*                   <,recfm>                                          *\n*                   <,profile>                                        *\n* R208              <,varl>                                           *\n*                                                                     *\n*    Arguments:                                                       *\n*                                                                     *\n*         service   This argument must be coded as 'BROWSE', 'VIEW'   *\n*                   or 'EDIT'.  It indicates which of the BRIF,       *\n*                   VIIF or EDIF services will be used for display.   *\n*                                                                     *\n*                   If the BROWSE service is requested, the user can  *\n*                   enter the V commands on the BROWSE screen to      *\n*                   switch to VIEW.  This allows the data to be       *\n*                   saved using CREATE/REPLACE, CUT or ROUTE.         *\n*                                                                     *\n*         stemname  the stem of the family of variables to display.   *\n*                   The combined lengths of the stemname argument     *\n*                   and the largest subscript (plus the period, if    *\n*                   specified) cannot exceed 80 characters.           *\n*                   If stemname is a true REXX stem, code a period    *\n*                   as the last character.  If you do not specify     *\n*                   the period, the subscripts will be concatenated   *\n*                   to the stem name without an intervening period.   *\n*                   For example, if you specify a stemname of \"ABC.\", *\n*                   STEMEDIT will look for variables of the form      *\n*                   \"ABC.1\", \"ABC.2\", etc. If you specify a stemname  *\n*                   of \"XYZ\" (no period), STEMEDIT will look for      *\n*                   variables of the form \"XYZ1\", \"XYZ2\", etc.        *\n*                                                                     *\n*                   If the service is coded as \"VIEW\" or \"EDIT\" and   *\n*                   stemname is omitted, STEMEDIT PULLs lines from    *\n*                   the stack.                                        *\n* R208              If the service is coded as \"VIEW\" or \"EDIT\"       *\n* R208              stemname can be coded as \"*\", which will display  *\n* R208              all variables in the REXX variable pool. Variable *\n* R208              names will be shown with 39 characters, except you*\n* R208              code varl as \"L\", showing variable names with 255 *\n* R208              characters. If variable name is longer, it will   *\n* R208              be abbreviated to 38 or 254 characters and        *\n* R208              suffixed with \"*\". Last variable is always the    *\n* R208              contents of VARNAME from this program.            *\n* R208              If the service is coded as \"EDIT\" and stemname    *\n* R208              is coded as \"*\", variables can be edited. It must *\n* R208              be coded with variable name beginning in colume   *\n* R208              1, some blanks endet with \"=\" and immediately     *\n* R208              followed by the value, which must be ended with   *\n* R208              \"00\"x. You can also drop a variable or a stem     *\n* R208              by coding \"DROP variablename\" at the beginning    *\n* R208              of the line and end it with \"00\"x.                *\n* R208              Variable name can have a length up to 250.        *\n*                                                                     *\n*         firstelem the element of the pseudo-array to begin the      *\n*                   display on.  The default value is element 1.      *\n*                                                                     *\n*         stemcount the number of elements to display.                *\n*                   If you do not specify stemcount, STEMEDIT will    *\n*                   display variables beginning with firstelem, and   *\n*                   continuing until an un-initialized variable is    *\n*                   found (i.e., a variable which has its name for    *\n*                   a value).                                         *\n*                                                                     *\n*         title     an arbitrary character string which identifies    *\n*                   the data which is being displayed.  The maximum   *\n*                   length of this string is 54 characters.           *\n*                                                                     *\n*         panel     a 1 to 8 character name of the panel member       *\n*                   to use for the display.                           *\n*                   The default panel is ISRBROBA for BROWSE          *\n*                   and ISREDDE2 for VIEW and EDIT.                   *\n*                                                                     *\n*         lrecl     the record length that should be passed to        *\n*                   the BRIF, VIIF or EDIF services.                  *\n*                   The default value is 255.                         *\n*                                                                     *\n*         recfm     the record format that should be passed to        *\n*                   the BRIF, VIIF or EDIF services.                  *\n*                   Possible values are F, FA, FM, V, VA, VM, or U.   *\n*                   The default value is V.                           *\n*                                                                     *\n*         profile   the 8-char name of the profile that should be     *\n*                   used by VIIF and EDIF when the VIEW or EDIT       *\n*                   services are requested.                           *\n*                   The default value is TEXT.                        *\n*                                                                     *\n* R208    varl      form of the variable list, if varname is *.       *\n* R208              Can be S for short (=39 char) or L for long       *\n* R208              (=255 char) varnames.                             *\n*                                                                     *\n*    Examples:                                                        *\n*                                                                     *\n*         Call the STEMEDIT routine to display the output of the      *\n*         TSO \"LISTCAT\" command.  The variables to display            *\n*         begin with the characters \"LINE.\":                          *\n*                                                                     *\n*            CALL OUTTRAP 'LINE.'                                     *\n*            \"LISTCAT\"                                                *\n*            CALL STEMEDIT 'BROWSE','LINE.',,,'List Catalog'          *\n*                                                                     *\n*         QUEUE JCL to the data stack and call the STEMEDIT           *\n*         routine to VIEW it:                                         *\n*                                                                     *\n*            \"MAKEBUF\"                                                *\n*            QUEUE '//MYJOB JOB 12345,CLASS=A'                        *\n*            QUEUE '//STEP2 EXEC PGM=IEFBR14'                         *\n*            CALL STEMEDIT 'VIEW',,,,'Sample JCL'                     *\n*            \"DROPBUF\"                                                *\n*                                                                     *\n* RETURN-CODES = See below                                            *\n*                                                                     *\n*        The STEMEDIT function returns a return code that indicates   *\n*        whether the display worked.  The returned value is           *\n*        contained in the RC special variable.                        *\n*                                                                     *\n*        The following STEMEDIT return code values are possible:      *\n*                                                                     *\n*        0    The display was successful.                             *\n*                                                                     *\n*        4    There were no stems matching the description given in   *\n*             stemname (BROWSE).  The data was not modified (EDIT).   *\n*                                                                     *\n*        8    Option incompatible with requested service.             *\n*                                                                     *\n*        12   Invalid Service requested.                              *\n*                                                                     *\n*        16   BRIF, VIIF or EDIF failed.                              *\n*                                                                     *\n* USAGE NOTES = See below                                             *\n*                                                                     *\n*        The EDIT service only works with a stem variable.            *\n*        If the data is modified by the user, STEMEDIT DROPs the      *\n*        stem variable, sets stem.0 to the number of records          *\n*        written, copies records to the stem.1 through stem.n         *\n*        where n is equal to the value of the stem.0 variable,        *\n*        and sets the RC variable to 0.  If the data is not           *\n*        modified by the user, STEMEDIT sets the RC variable to 4.    *\n*                                                                     *\n* COMPATIBILITY                                                       *\n*                                                                     *\n*        STEMEDIT has been designed to be compatible with             *\n*        the STEMDISP function of the REXXTOOLS product from          *\n*        Open Software Technologies, with the following               *\n*        exceptions:                                                  *\n*                                                                     *\n*        1. STEMEDIT supports the BROWSE, VIEW and EDIT services      *\n*           (STEMDISP only supports BROWSE).                          *\n*                                                                     *\n*        2. If stemcount is not specified, STEMEDIT scans             *\n*           variables until an unitialised variable is found.         *\n*           (STEMDISP stops after 100000 variables).                  *\n*                                                                     *\n*        3. STEMEDIT has the ability to retrieve data from a          *\n*           stem variable or the data stack (STEMDISP can only        *\n*           retrieve data from a stem variable).                      *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n* 100 Initial release                                            1995 *\n* 101 Fix S0C4 in RDRTNE                                         1996 *\n* 102 VIEW support via EDIF                                           *\n* 103 Convert 2nd argument to uppercase (variable name)               *\n*     Add support for 3rd and 4th arguments                           *\n* 104 Change module name from STEMDISP to STEMVIEW               1997 *\n*     Punch ' ALIAS STEMDISP ' for compatibility with REXXTOOLS       *\n*     Change name of EDIT function to VIEW                            *\n*     Issue CONTROL DISPLAY REFRESH before BROWSE/EDIT                *\n*     Pass address of environment block to IRXEXCOM                   *\n* 105 PULL data from the stack when no variable name specified        *\n*     Prompt user before saving data in VIEW mode                     *\n*     LRECL can be specified in 7th argument                          *\n*     Check for missing parms to prevent S0C4                         *\n*     Replace STRING macro with in-line code                          *\n*     Accept SHVTRUNC as valid RC from IRXEXCOM                       *\n* 106 Truncate Title                                                  *\n* 107 E or V command switches from BROWSE to VIEW                1999 *\n* 108 Set ZVMODET='VIEW' to show VIEW instead of EDIT on ISREDDEx     *\n*     Add recfm and profile parameters for VIEW                       *\n*     Display error message after BRIF/EDIF failure                   *\n*     Display STEMVIEW Arguments Syntax if not invoked from REXX      *\n* 201 Program name changed from STEMVIEW to STEMEDIT             2002 *\n*     Use VIIF instead of EDIF (OS/390 R10 and z/OS)                  *\n*     Add EDIT function for stem variables                            *\n*     Maximum length of variable name increased to 255                *\n*     Maximum length of data line increased to 32760                  *\n* 202 Set default LRECL to 255                                   2003 *\n* 203 Force default panel names - ISRBROBA/ISREDDE2              2009 *\n*     Use SAVE3 in RDRTNE and WRITERTN                                *\n*     Move LINE fld to own DSECT                                      *\n*     When invoked for BROWSE and user issues V or E :                *\n*     1. Issue CONTROL DISPLAY SAVE/RESTORE                           *\n*     2. Clear Panel Name                                             *\n* 204 Change X'40' to X'41' (NBSP) in TITLE                           *\n* 205 Add support for ISPF V3                                         *\n*     Replace LINK macro with ISPLINK                                 *\n* 206 Check for empty records in RDRTN84                         2010 *\n* 207 VIIF only supported in ISPF V5 and above                        *\n*                                                                     *\n* 208 List all Variables, stemname=*                       2013 R208  *\n*     Remove ORG instruction from R206 (this had made STEMCOUNT R208  *\n*     to an LASTELEMENT)                                        R208  *\n*     Change at label RDRTN88 to prevent display of empty lines R208  *\n*     when BROWSE is invoked with first element specified.      R208  *\n*     EDIT of variables.                                        R208  *\n*                                                                     *\n&REL     SETC  'R208'                                                 *\n***********************************************************************\n         PUNCH ' ALIAS STEMDISP (compatibility with REXXTOOLS) '\n         PUNCH ' ALIAS STEMVIEW (compatibility with STEMVIEW) '\nSTEMEDIT CSECT\nSTEMEDIT RMODE 24                      For TPUT\nSTEMEDIT AMODE 31\n&D       SETC  '&SYSDATE'(7,2)'-'.'&SYSDATE'(1,2)'-'.'&SYSDATE'(4,2)\n         SAVE  (14,12),,'GSF Utilities - STEMEDIT &REL - 20&D &SYSTIME'\n         LR    R12,R15\n         USING STEMEDIT,R12\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ALLOCATE DYNAMIC STORAGE                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         GETMAIN RU,LV=DYNAML,         Allocate Dynamic Storage Area   X\n               LOC=BELOW,              24-bit address for TPUT         X\n               BNDRY=PAGE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LA    R14,72(,R1)             CLEAR WORKING STORAGE\n         LA    R15,DYNAML-72           CLEAR WORKING STORAGE\n         SLR   R1,R1                   CLEAR WORKING STORAGE\n         MVCL  R14,R0                  CLEAR WORKING STORAGE\n         LM    R13,R1,8(R13)           SET R13, RELOAD R1\n         USING DYNAM,R13\n         STM   R15,R1,R15R0R1          save regs for cmd rtne\n         L     R11,EFPLARG-EFPL(,R1)   ADDR OF ARG LIST\n         MVI   BLANKS,C' '             a bunch of blanks\n         MVC   BLANKS+1(L'BLANKS-1),BLANKS\n         MVC   TITLE,BLANKS            default title\n         MVC   PANEL_NAME,BLANKS       default panel name\n         MVI   STEMCOUNT,1             default count: X'01000000'\n         GETMAIN RU,LV=L'LINE+256,     Alloc Dynamic Storage Area  R208X\n               BNDRY=PAGE\n         STM   R0,R1,LINE_LEN_ADDR     Save length/address\n         LR    R9,R1                   Copy A(LINE)\n         USING LINE_DSECT,R9\n*---------------------------------------------------------------------*\n*                                                                     *\n*        BUILD THE SHVBLOCK                                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         LA    R10,DYNAM_SHVB\n         USING SHVBLOCK,R10\n         MVI   SHVCODE,SHVFETCH        FETCH VARIABLE\n         LH    R0,=Y(L'LINE)           LENGTH OF 'FETCH' VALUE BUFFER\n         ST    R0,SHVBUFL              LENGTH OF 'FETCH' VALUE BUFFER\n         LA    R0,255                  default lrecl for BRIF/VIIF/EDIF\n         ST    R0,LRECL                default lrecl for BRIF/VIIF/EDIF\n         MVC   RECFM,=C'V '            default RECFM is V\n         MVC   PROFILE_NAME,=CL8'TEXT' default profile name\n         LA    R0,LINE                 ADDRESS OF VALUE BUFFER\n         ST    R0,SHVVALA              ADDRESS OF VALUE BUFFER\n         LA    R0,VARNAME              ADDRESS OF VARIABLE NAME\n         ST    R0,SHVNAMA              ADDRESS OF VARIABLE NAME\n         L     R15,ADDR_OF_ENVBLOCK    Environment block\n         CLC   =C'ENVBLOCK',0(R15)     Invoked from REXX?\n         BNE   NOREXX                  no, quit\n         L     R15,ENVBLOCK_IRXEXTE-ENVBLOCK(,R15) A(IRXEXTE)\n         L     R15,IRXEXCOM-IRXEXTE(,R15)          A(IRXEXCOM)\n         L     R0,ADDR_OF_ENVBLOCK     ENVIRONMENT BLOCK\n         LA    R1,IRXEXCOM_PARM        parm list\n         STM   R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         LA    R14,=C'IRXEXCOM'        Shared Variable Routine\n         SLR   R15,R15                 PARM2=0\n         SLR   R0,R0                   PARM3=0\n         LA    R1,SHVBLOCK             PARM4\n         STM   R14,R1,IRXEXCOM_PARM    build parm list for IRXEXCOM\n         OI    IRXEXCOM_PARM+12,X'80'  VL=1\n*---------------------------------------------------------------------*\n         MACRO                                                    macro\n&NAME    ISPLINK &OPRNDS,&ERRET=                                  macro\n         GBLB  &IHBSWA                                            macro\n&IHBSWA  SETB  1                       VL=1                       macro\n&NAME    LA    R1,PARMLIST             parm list                  macro\n         IHBOPLST ,&OPRNDS,MF=(E,(1))                             macro\n         L     R15,ISPLINK\u00ba            ISPLINK bootstrap\n         BALR  R14,R15                 invoke ISPLINK\n         AIF   (T'&ERRET EQ 'O').MEND                             macro\n         LTR   R15,R15                 Any error?\n         BNZ   &ERRET                  yes, jump\n.MEND    MEND                                                     macro\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS ARGUMENTS                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         LOAD  EP=ISPLINK              preload ISPLINK\n         ST    R0,ISPLINK\u00ba             A(ISPLINK)\n         LA    R0,L'ZENVIR\n         ST    R0,DWD\n         ISPLINK ($VCOPY,$ZENVIR,DWD,ZENVIR,$MOVE)\n*\n* Set VAR1 to Blank for further compares                           R208\n         MVI   VAR1,C' '                                           R208\n* Set VARL to 'S' for further compares                             R208\n         MVI   VARL,C'S'                                           R208\n*\n         LM    R2,R3,8*1-8(R11)        1st ARG (BROWSE/EDIT)\n         LTR   R3,R3                   service specified?\n         BNP   ARG1N                   no, error\n         CH    R3,=AL2(L'SERVICE)      name too long?\n         BH    ARG1N                   yes, error\n         BCTR  R3,0                    prepare \"EX\"\n         MVC   SERVICE(*-*),0(R2)      move string\n         EX    R3,*-6                  execute MVC\n         OC    SERVICE,BLANKS          convert to uppercase\n*\n         CLI   ZENVIR+5,C'4'           ISPF V4 or above ?\n         BL    ARG1G                   no, keep blank panel name\n         MVC   PANEL_NAME,=C'ISRBROBA' default panel name (BROWSE)\nARG1G    EQU   *\n         CLC   =C'BROWSE',SERVICE      BROWSE?\n         BE    ARG1X                   yes, exit\n         CLI   ZENVIR+5,C'4'           ISPF V4 or above ?\n         BL    ARG1J                   no, keep blank panel name\n         MVC   PANEL_NAME,=C'ISREDDE2' default panel name (VIEW/EDIT)\nARG1J    EQU   *\n         CLC   =C'VIEW  ',SERVICE      VIEW?\n         BE    ARG1X                   yes, exit\n         CLC   =C'EDIT  ',SERVICE      EDIT?\n         BE    ARG1X                   yes, exit\nARG1N    EQU   *                       bad service specified\n         B     EXIT12                  no service, exit with RC=12\nARG1X    EQU   *\n*\n         LM    R2,R3,8*2-8(R11)        2ND ARG (VAR NAME)\n         STM   R2,R3,STEMNAME          2ND ARG (VAR NAME)\n         LTR   R3,R3                   stemname specified?\n         BNP   ARG2N                   no, jump\n         MVC   VAR1,0(R2)              first char of varname       R208\n         OI    0(R2),X'40'             convert to uppercase\n         LA    R2,1(,R2)               convert to uppercase\n         BCT   R3,*-8                  convert to uppercase\n         CLI   VAR1,C'*'               is varname '*' ?            R208\n         BE    ARG2RN                  yes, go to ARG2RN           R208\n         B     ARG2X\nARG2N    EQU   *                       no stemname specified\n         CLI   SERVICE,C'B'            SERVICE=BROWSE?\n         BE    EXIT8                   yes, exit with RC=8\n         CLI   SERVICE,C'E'            SERVICE=EDIT?\n         BE    EXIT8                   yes, exit with RC=8\n         LA    R14,=CL8'PULL'          FUNCTION\n         LA    R15,SHVVALA             ADDRESS OF DATA RETURNED\n         LA    R0,SHVVALL              LENGTH OF DATA RETURNED\n         LA    R1,VALUE                VALUE RETURNED BY IRXSTK\n         LA    R2,ADDR_OF_ENVBLOCK     Environment block\n         LA    R3,RETCODE              RETURN CODE\n         STM   R14,R3,IRXSTK_PARM      BUILD PARM LIST\n         OI    IRXSTK_PARM+20,X'80'    BUILD PARM LIST\n         B     ARG2X                   Jump over ARG2RN            R208\nARG2RN   EQU   *                                                   R208\n         CLI   SERVICE,C'B'            SERVICE=BROWSE?             R208\n         BE    EXIT8                   yes, exit with RC=8         R208\n         MVI   SHVCODE,SHVNEXTV        FETCH NEXT VARIABLE         R208\nARG2X    EQU   *\n*\n         LM    R2,R3,8*3-8(R11)        3rd ARG (first element)\n         LTR   R3,R3                   zero length?\n         BZ    ARG3X                   yes, jump\n         BM    ARG10X                  eof, exit                   R208\n         BCTR  R3,0                    decrement\n         PACK  DWD,0(,R2)              *executed*\n         EX    R3,*-6                  pack the value\n         CVB   R0,DWD                  make it binary\n         BCTR  R0,0                    relative to zero\n         ST    R0,CURRECNO             save it for later\nARG3X    EQU   *\n*\n         LM    R2,R3,8*4-8(R11)        4th ARG (stem count)\n         LTR   R3,R3                   zero length?\n         BZ    ARG4X                   yes, jump\n         BM    ARG10X                  eof, exit                   R208\n         BCTR  R3,0                    decrement\n         PACK  DWD,0(,R2)              *executed*\n         EX    R3,*-6                  pack the value\n         CVB   R0,DWD                  make it binary\n         AL    R0,CURRECNO             add origin\n*        ORG   *-4                                                 R208\n         ST    R0,STEMCOUNT            save it for later\nARG4X    EQU   *\n*\n         LM    R2,R3,8*5-8(R11)        5TH ARG (TITLE)\n         LTR   R3,R3                   zero length?\n         BZ    ARG5X                   yes, jump\n         BM    ARG10X                  eof, exit                   R208\n         LA    R1,TITLE                start of output area\n         CH    R3,=Y(L'TITLE)          title too long?\n         BNH   ARG5M                   no, jump\n         LH    R3,=Y(L'TITLE)          yes, truncate it\n*LOOP\nARG5M    MVC   0(1,R1),0(R2)           move one character\n         CLI   0(R1),X'40'             X'40' -> X'41' (NBSP)\n         BNE   *+8                     X'40' -> X'41' (NBSP)\n         MVI   0(R1),X'41'             X'40' -> X'41' (NBSP)\n         LA    R1,1(,R1)               next output char\n         LA    R2,1(,R2)               next input char\n         BCT   R3,ARG5M                move title, one char at a time\n*ENDLOOP\nARG5X    EQU   *\n*\n         LM    R2,R3,8*6-8(R11)        6TH ARG (PANEL)\n         LTR   R2,R2                   SPECIFIED?\n         BZ    ARG6X                   no, jump\n         BM    ARG10X                  eof, exit                   R208\n         BCTR  R3,0                    prepare \"EX\"\n         MVC   PANEL_NAME(*-*),0(R2)   move string\n         EX    R3,*-6                  execute MVC\nARG6X    EQU   *\n*\n         LM    R2,R3,8*7-8(R11)        7th ARG (lrecl)\n         LTR   R3,R3                   zero length?\n         BZ    ARG7X                   yes, jump\n         BM    ARG10X                  eof, exit                   R208\n         BCTR  R3,0                    decrement\n         PACK  DWD,0(,R2)              *executed*\n         EX    R3,*-6                  pack the value\n         CVB   R0,DWD                  make it binary\n         ST    R0,LRECL                save it for later\n         CH    R0,=Y(L'LINE)           lrecl too big?\n         BH    EXIT8                   yes, exit with RC=8\nARG7X    EQU   *\n*\n         LM    R2,R3,8*8-8(R11)        8TH ARG (recfm)\n         LTR   R2,R2                   SPECIFIED?\n         BZ    ARG8X                   no, jump\n         BM    ARG10X                  eof, exit                   R208\n         CLI   SERVICE,C'B'            SERVICE=BROWSE?\n         BE    EXIT8                   yes, exit with RC=8\n         CH    R3,=Y(L'RECFM)          too long?\n         BH    EXIT8                   yes, exit with RC=8\n         BCTR  R3,0                    prepare \"EX\"\n         MVC   RECFM(*-*),0(R2)        move string\n         EX    R3,*-6                  execute MVC\n         OC    RECFM,BLANKS            upper-case\nARG8X    EQU   *\n*\n         LM    R2,R3,8*9-8(R11)        9TH ARG (profile)\n         LTR   R2,R2                   SPECIFIED?\n         BZ    ARG9X                   no, jump\n         BM    ARG10X                  eof, exit                   R208\n         CLI   SERVICE,C'B'            SERVICE=BROWSE?\n         BE    EXIT8                   yes, exit with RC=8\n         CH    R3,=Y(L'PROFILE_NAME)   too long?\n         BH    EXIT8                   yes, exit with RC=8\n         BCTR  R3,0                    prepare \"EX\"\n         MVC   PROFILE_NAME(*-*),0(R2) move string\n         EX    R3,*-6                  execute MVC\n*\nARG9X    EQU   *                       S or L                      R208\n*                                                                  R208\n         LM    R2,R3,8*10-8(R11)       10TH ARG (S or L)           R208\n         LTR   R2,R2                   SPECIFIED?                  R208\n         BZ    ARG10X                  no, jump                    R208\n         BM    ARG10X                  eof, exit                   R208\n         CLI   SERVICE,C'B'            SERVICE=BROWSE?             R208\n         BE    EXIT8                   yes, exit with RC=8         R208\n         MVC   VARL,0(R2)              first char of varlistform   R208\n         OC    VARL,BLANKS             convert to uppercase        R208\n*\nARG10X   EQU   *                       end of arg list             R208\n*\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Invoke BRIF, VIIF or EDIF Services                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         ISPLINK ($CONTROL,$ERRORS,$RETURN) CONTROL ERRORS RETURN\n         ISPLINK ($CONTROL,$DISPLAY,$REFRESH) CONTROL DISPLAY REFRESH\n         LA    R0,SAVE2                PARM FOR READ ROUTINE\n         ST    R0,SAVE2                PARM FOR READ ROUTINE\n         LA    R2,RDRTNE               READ ROUTINE\n         LA    R3,CMDRTNE              COMMAND ROUTINE\n         LA    R4,WRITERTN             WRITE ROUTINE\n         STM   R2,R4,RDCMDWR+0         READ,CMD,WRITE\n         CLI   SERVICE,C'V'            SERVICE=VIEW?\n         BE    VIIF                    yes, jump\n         CLI   SERVICE,C'E'            SERVICE=EDIT?\n         BE    EDIF                    yes, jump\n         ISPLINK (=C'BRIF',            ISPF SERVICE                    X\n               TITLE,                  DSNAME                          X\n               RECFM,                  RECFM                           X\n               LRECL,                  LRECL                           X\n               RDCMDWR+0,              READ ROUTINE                    X\n               RDCMDWR+4,              COMMAND ROUTINE                 X\n               SAVE2,                  PARM FOR READ ROUTINE           X\n               PANEL_NAME)             PANEL (ISRBROBF/ISRBROBA)\n         CH    R15,=H'12'              empty data set?\n         BNE   GOBACK                  no, jump\n         LA    R7,4                    yes, RC=4 \"no data to browse\"\n         B     GOBACK40\nVIIF     EQU   *\n         CLI   ZENVIR+5,C'5'           ISPF V5 or above ?\n         BL    EDIF                    no, use EDIF instead of VIIF\n         ISPLINK (=C'VIIF',            ISPF SERVICE                    X\n               TITLE,                  DSNAME                          X\n               PROFILE_NAME,           PROFILE NAME                    X\n               RECFM,                  RECFM                           X\n               LRECL,                  LRECL                           X\n               RDCMDWR+0,              READ ROUTINE                    X\n               0,                      COMMAND EXIT                    X\n               SAVE2,                  PARM FOR READ ROUTINE           X\n               0,                      Edit Length                     X\n               PANEL_NAME)             PANEL (ISREDDE2/ISREDDE3)\n         B     GOBACK\nEDIF     EQU   *\n         ISPLINK (=C'EDIF',            ISPF SERVICE                    X\n               TITLE,                  DSNAME                          X\n               PROFILE_NAME,           PROFILE NAME                    X\n               RECFM,                  RECFM                           X\n               LRECL,                  LRECL                           X\n               RDCMDWR+0,              READ ROUTINE                    X\n               RDCMDWR+8,              WRITE ROUTINE                   X\n               0,                      COMMAND EXIT                    X\n               SAVE2,                  PARM FOR READ ROUTINE           X\n               0,                      Edit Length                     X\n               PANEL_NAME)             PANEL (ISREDDE2/ISREDDE3)\n         LTR   R7,R15                  OK?\n         BZ    GOBACK40                yes, jump\n         CH    R7,=H'4'                Data Modified?\n         BE    GOBACK40                no, exit with RC=4\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Set return code                                              *\n*                                                                     *\n*---------------------------------------------------------------------*\nGOBACK   EQU   *\n         LTR   R7,R15                  OK?\n         BZ    GOBACK40                yes, jump\n         CH    R7,=H'4'                Severe error in BRIF/VIIF/EDIF?\n         BH    GOBACK16                yes, RC=16\n         SLR   R7,R7                   no, RC=0\n         B     GOBACK40\n*\n*        BRIF/VIIF/EDIF error: display error message\n*\nGOBACK16 LA    R7,1000(,R7)            RC=10nn: rc nn from BRIF/VIIF\n         LA    R0,L'ZERRMSG            max length\n         ST    R0,DWD                  max length\n         ISPLINK ($VCOPY,$ZERRMSG,DWD,ZERRMSG,$MOVE),                  X\n               ERRET=GOBACK40          No MSG, skip SETMSG\n         ISPLINK ($SETMSG,ZERRMSG)\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Pass return code in RC variable                              *\n*                                                                     *\n*---------------------------------------------------------------------*\nGOBACK40 EQU   *\n         LA    R0,WORK80               ADDRESS OF VALUE BUFFER\n         ST    R0,SHVVALA              ADDRESS OF VALUE BUFFER\n         CVD   R7,DWD                  convert to decimal\n         OI    DWD+7,15                convert to decimal\n         UNPK  WORK80(5),DWD           convert to decimal\n         LA    R15,5                   LENGTH OF VARIABLE NAME\n         ST    R15,SHVVALL             length\n         MVC   VARNAME(2),=C'RC'       variable name\n         LA    R15,2                   LENGTH OF VARIABLE NAME\n         ST    R15,SHVNAML             LENGTH OF VARIABLE NAME\n         LA    R0,VARNAME              ADDRESS OF VARIABLE NAME    R208\n         ST    R0,SHVNAMA              ADDRESS OF VARIABLE NAME    R208\n         MVI   SHVCODE,SHVSTORE        STORE VARIABLE\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         BALR  R14,R15              <- Store REXX variable \"RC\"\n         SLR   R7,R7                   RC=0\n         B     EXIT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        STEMEDIT was not invoked from a REXX exec                    *\n*        Display argument syntax using TPUT                           *\n*                                                                     *\n*---------------------------------------------------------------------*\nNOREXX   EQU   *\n         TPUT  SYNTAXMSG,L'SYNTAXMSG   display syntax\n         LA    R7,20                   RC=20\n         B     EXIT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CLEAN-UP AND EXIT                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\nEXIT8    LA    R7,8                    RC=8 Option incompat w/service\n         B     EXIT\nEXIT12   LA    R7,12                   RC=12 Invalid Service\n*\nEXIT     LM    R0,R1,LINE_LEN_ADDR     Load length/address\n         FREEMAIN RU,LV=(R0),A=(R1)    Free Dynamic Storage Area\n         LR    R1,R13                  A(DYNAM)\n         L     R13,4(,R13)\n         FREEMAIN RU,LV=DYNAML,A=(R1)  Free Dynamic Storage Area\n         LR    R15,R7                  pass return code\n         RETURN (14,12),RC=(15)\n         DROP\n***********************************************************************\n*                                                                     *\n*        BRIF Command Routine                                         *\n*                                                                     *\n*        This routine is invoked by BRIF each time a command is       *\n*        entered on the BROWSE screen.  If the user enters the E      *\n*        or V command, then STEMEDIT reinvokes itself with VIEW       *\n*        instead of BROWSE.                                           *\n*                                                                     *\n***********************************************************************\nCMDRTNE  SAVE  (14,12),,*\n         LR    R12,R15\n         USING CMDRTNE,R12\n         LR    R14,R13                 CALLER'S SAVE AREA\n         L     R13,04(,R1)             PTR TO DIALOG DATA AREA\n         L     R13,0(,R13)             A(SAVE2)\n         ST    R14,4(,R13)             CHAIN SAVE AREAS\n         ST    R13,8(,R14)             CHAIN SAVE AREAS\n         USING SAVE2,R13\n         L     R6,00(,R1)              Function Code\n         L     R9,LINE_LEN_ADDR+4      A(LINE)\n         USING LINE_DSECT,R9\n         CLC   =F'20',0(R6)            UNKNOWN COMMAND?\n         BNE   CMDRTNE4                NO, EXIT\n         LA    R0,L'WORK80             max length of variable\n         ST    R0,DWD                  max length of variable\n         ISPLINK ($VCOPY,$ZCMD,DWD,WORK80,$MOVE)\n         OC    WORK80(2),BLANKS        upper-case\n         CLC   =C'E ',WORK80           ZCMD=\"E\" ?\n         BE    CMDRTNE7                yes, do it\n         CLC   =C'V ',WORK80           ZCMD=\"V\" ?\n         BE    CMDRTNE7                yes, do it\nCMDRTNE4 L     R13,4(,R13)             BRIF SAVE AREA\n         RETURN (14,12),RC=4           ISPF will process the command\n*\n*        Invoke VIEW when user enters V or E during BROWSE display\n*\nCMDRTNE7 EQU   *\n         ISPLINK ($CONTROL,$DISPLAY,$SAVE) CONTROL DISPLAY SAVE\n*\n         LM    R15,R1,R15R0R1          restore regs at entry\n         L     R11,EFPLARG-EFPL(,R1)   ADDR OF ARG LIST\n         LA    R2,$VIEW                service=VIEW\n         LA    R3,L'$VIEW              length\n         STM   R2,R3,0(R11)            update service name\n         SLR   R2,R2                   R2=0\n         SLR   R3,R3                   R3=0\n         STM   R2,R3,8*6-8(R11)        6TH ARG (PANEL)\n         BALR  R14,R15              <- re-invoke myself for VIEW\n*\n         ISPLINK ($CONTROL,$DISPLAY,$RESTORE) CONTROL DISPLAY RESTORE\n*\n         L     R13,4(,R13)             BRIF SAVE AREA\n         RETURN (14,12),RC=0           command processed\n         DROP\n***********************************************************************\n*                                                                     *\n*        BRIF/VIIF READ Routine                                       *\n*                                                                     *\n*        This routine is invoked by BRIF and VIIF to                  *\n*        return the address of a record.                              *\n*                                                                     *\n***********************************************************************\nRDRTNE   SAVE  (14,12),,*\n         LR    R12,R15\n         USING RDRTNE,R12\n         LR    R14,R13                 CALLER'S SAVE AREA\n         L     R13,12(,R1)             PTR TO DIALOG DATA AREA\n         L     R13,0(,R13)             A(SAVE2)\n         LA    R13,SAVE3-SAVE2(,R13)   A(SAVE3)\n         ST    R14,4(,R13)             CHAIN SAVE AREAS\n         ST    R13,8(,R14)             CHAIN SAVE AREAS\n         USING SAVE3,R13\n         L     R6,00(,R1)              RECORD DATA READ\n         L     R7,04(,R1)              LENGTH\n         L     R4,08(,R1)              RELATIVE RECORD NUMBER\n         L     R9,LINE_LEN_ADDR+4      A(LINE)\n         USING LINE_DSECT,R9\n         CLI   SERVICE,C'V'            VIIF?\n         BE    RDRTNE06                YES, JUMP\n         CLI   SERVICE,C'E'            EDIF?\n         BE    RDRTNE06                YES, JUMP\n         L     R5,0(,R4)               LINE NUMBER REQUESTED BY BRIF\n         AL    R5,CURRECNO             add first element (4th arg)\n         B     RDRTNE07\nRDRTNE06 EQU   *\n         LA    R5,1                    NEXT LINE FOR EDIT\n         AL    R5,CURRECNO             RECORD NUMBER\n         ST    R5,CURRECNO             RECORD NUMBER\nRDRTNE07 EQU   *\n*\n         LA    R10,DYNAM_SHVB\n         USING SHVBLOCK,R10\n         CL    R5,STEMCOUNT            end reached?\n         BH    RDRTN79                 yes, exit with RC=8\n         CLI   SHVRET,SHVLVAR          last variable to fetch?     R208\n         BE    RDRTN79                 yes, exit with RC=8         R208\n*\n*        Retrieve value of current variable\n*\n         BAL   R14,FETCHVAR         <- retrieve stemmed variable\n         CLI   SHVRET,SHVCLEAN         OK?\n         BE    RDRTN70                 yes, pass line to BRIF\n         CLI   SHVRET,SHVTRUNC         truncated value?\n         BE    RDRTN70                 yes, pass line to BRIF\n         CLI   SHVRET,SHVNEWV          this variable exists?\n         BE    RDRTN80                 NO, EXIT\n*\n*        If IRXEXCOM fails, display R15 and SHVRET values.\n*\n         MVC   LINE(L'VARNAME),VARNAME move variable name\n         L     R1,SHVNAML              length of variable name\n         LA    R2,LINE(R1)             length of variable name\n         MVC   0(5,R2),=C' R15='       move literal\n         CVD   R15,DWD                 save return code\n         OI    DWD+7,15                convert to decimal\n         UNPK  5(3,R2),DWD             move return code: R15=008\n         MVC   8(8,R2),=C',SHVRET='    move literal\n         UNPK  16(3,R2),SHVRET(2)      hex display\n         TR    16(2,R2),HEXTAB-240     hex display\n         LA    R15,18(,R1)             data length\n         ST    R15,SHVVALL             length\n*\n*        Return value of variable\n*\nRDRTN70  L     R0,SHVVALA              DATA ADDRESS\n         L     R1,SHVVALL              DATA LENGTH\n         CLI   VAR1,C'*'               Fetch all vars?             R208\n         BNE   RDRTN72                 No, jump over next lines    R208\n         CLI   VARL,C'L'               Show long var name?         R208\n         BE    RDRTN71L                yes, jump over next lines   R208\n         MVI   LVARN,C' '              Clear LVARN                 R208\n         MVC   LVARN+1(39),LVARN                                   R208\n         L     R3,SHVNAML              length of variable name     R208\n         CL    R3,=F'39'               var name longer than 39?    R208\n         BH    RDRTN71                 if longer jump              R208\n         BCTR  R3,0                    prepare \"EX\"                R208\n         MVC   LVARN(*-*),VARNAME      move variable name          R208\n         EX    R3,*-6                  execute MVC                 R208\n         B     RDRTN71E                                            R208\nRDRTN71  EQU   *                                                   R208\n         MVC   LVARN(38),VARNAME       move variable name          R208\n         MVI   LVARN+38,C'*'           move * to end of var name   R208\nRDRTN71E EQU   *                                                   R208\n         MVI   LVARN+39,C'='           move = after var name       R208\n         LA    R3,40                   R3=40                       R208\n         LA    R14,LINE                \"to\" address                R208\n         L     R15,LRECL               \"to\" length                 R208\n         SR    R15,R3                  length - 40                 R208\n         MVCL  R14,R0                  move data to LINE           R208\n         LA    R0,LINEA                DATA ADDRESS incl. varname  R208\n         L     R1,LRECL                DATA LENGTH                 R208\n         B     RDRTN72                 jump over next lines        R208\nRDRTN71L EQU   *                                                   R208\n         MVI   LVARNL,C' '             Clear LVARNL                R208\n         MVC   LVARNL+1(255),LVARNL                                R208\n         L     R3,SHVNAML              length of variable name     R208\n         CL    R3,=F'255'              var name longer than 255?   R208\n         BH    RDRTN71M                if longer jump              R208\n         BCTR  R3,0                    prepare \"EX\"                R208\n         MVC   LVARNL(*-*),VARNAME     move variable name          R208\n         EX    R3,*-6                  execute MVC                 R208\n         B     RDRTN71N                                            R208\nRDRTN71M EQU   *                                                   R208\n         MVC   LVARNL(254),VARNAME     move variable name          R208\n         MVI   LVARNL+254,C'*'         move * to end of var name   R208\nRDRTN71N EQU   *                                                   R208\n         MVI   LVARNL+255,C'='         move = after var name       R208\n         LA    R3,256                  R3=256                      R208\n         LA    R14,LINE                \"to\" address                R208\n         L     R15,LRECL               \"to\" length                 R208\n         SR    R15,R3                  length - 256                R208\n         MVCL  R14,R0                  move data to LINE           R208\n         LA    R0,LINEAL               DATA ADDRESS incl. varname  R208\n         L     R1,LRECL                DATA LENGTH                 R208\nRDRTN72  EQU   *                                                   R208\n         CLI   RECFM,C'F'              RECFM=F?\n         BNE   RDRTN74                 no, jump\n         CL    R1,LRECL                needs padding?\n         BNL   RDRTN74                 no, jump\n         LA    R14,LINE                \"to\" address\n         L     R15,LRECL               \"to\" length\n         ICM   R1,B'1000',BLANKS       padding\n         MVCL  R14,R0                  move data to LINE\n         LA    R0,LINE                 DATA ADDRESS\n         L     R1,LRECL                DATA LENGTH\nRDRTN74  EQU   *\n         ST    R0,0(,R6)               PASS DATA ADDRESS\n         ST    R1,0(,R7)               PASS DATA LENGTH\n         ST    R5,LASTLINE             CURRENT LINE NUMBER\n         L     R13,4(,R13)             BRIF SAVE AREA\n         RETURN (14,12),RC=0           GOBACK TO EDIT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Scan variables to find the highest one                       *\n*                                                                     *\n*        This section determines the number of the last line and      *\n*        passes it to BRIF/VIIF/EDIF along with the EOF indicator.    *\n*                                                                     *\n*---------------------------------------------------------------------*\nRDRTN79  L     R5,STEMCOUNT            eof\n         B     RDRTN81\nRDRTN80  BCTR  R5,0                    previous line\nRDRTN81  EQU   *\n         CL    R5,LASTLINE             was good?\n         BE    RDRTN88                 yes, exit\n         L     R5,LASTLINE             previous line\n*loop\nRDRTN84  LA    R5,1(,R5)               BUMP LINE NUMBER\n         CL    R5,STEMCOUNT            end reached?\n         BH    RDRTN87                 yes, exit with RC=8\n         CLI   SHVRET,SHVLVAR          last variable to fetch?     R208\n         BE    RDRTN87                 yes, exit with RC=8         R208\n         BAL   R14,FETCHVAR         <- retrieve stemmed variable\n*check for empty variable generally created with:  stem. = ' '\n         OC    SHVVALL,SHVVALL         length=0 ?\n         BZ    RDRTN87                 yes, exit\n         CLI   SHVRET,SHVCLEAN         OK?\n         BE    RDRTN84                 yes, try next variable\n*endloop\nRDRTN87  BCTR  R5,0                    previous line\n         ST    R5,LASTLINE             save number of last line\n*RDRTN88  ST    R5,0(,R4)               LAST LINE\n*         L     R13,4(,R13)             BRIF SAVE AREA\n*         RETURN (14,12),RC=8           GOBACK TO BRIF (EOF)\nRDRTN88  EQU   *                                                   R208\n         CLI   SERVICE,C'V'            VIIF?                       R208\n         BE    RDRTN88V                YES, JUMP                   R208\n         CLI   SERVICE,C'E'            EDIF?                       R208\n         BE    RDRTN88V                YES, JUMP                   R208\n         S     R5,CURRECNO             subtract 4th arg            R208\nRDRTN88V EQU   *                                                   R208\n         ST    R5,0(,R4)               # of lines to display       R208\n         L     R13,4(,R13)             BRIF SAVE AREA              R208\n         RETURN (14,12),RC=8           GOBACK TO BRIF (EOF)        R208\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Fetch value of a variable                                    *\n*                                                                     *\n*        1. build variable name by concatenating the stem name        *\n*           (such as \"LINE.\") to the sequence number in R5            *\n*        2. pass control to IRXEXCOM                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\nFETCHVAR LM    R2,R3,STEMNAME          2ND ARG (VAR NAME)\n         LTR   R3,R3                   variable name specified?\n         BNP   FETCHV50                no, PULL from stack\n         CLI   VAR1,C'*'               Read all variables?         R208\n         BE    FETCHV40                yes jump to FETCHV40        R208\n         LR    R0,R5                   seqno\n         BAL   R15,BLDVARNM         <- build variable name\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         BR    R15                     FETCH VARIABLE\n*\nFETCHV40 EQU   *                                                   R208\n         LA    R0,255                                              R208\n         ST    R0,SHVUSER              Length of varname buffer    R208\n         ST    R0,SHVNAML              LENGTH OF VARIABLE NAME     R208\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)  R208\n         BR    R15                     FETCH VARIABLE              R208\n*\n*        PULL an element from the data stack\n*\nFETCHV50 LR    R2,R14                  save return address\n         L     R15,ADDR_OF_ENVBLOCK    Environment block\n         L     R15,ENVBLOCK_IRXEXTE-ENVBLOCK(,R15) A(IRXEXTE)\n         L     R15,IRXSTK-IRXEXTE(,R15) STACK MANAGER\n         LA    R1,IRXSTK_PARM          PARM LIST\n         BALR  R14,R15              <- CALL IRXSTK\n         LTR   R15,R15                 EOF yet?\n         BZR   R2                      no, goback\n         MVI   SHVRET,SHVNEWV          yes, simulate EOF\n         BR    R2                      and goback\n         DROP\nHEXTAB   DC    C'0123456789ABCDEF'\n***********************************************************************\n*                                                                     *\n*        Write Routine (SERVICE=EDIT)                                 *\n*                                                                     *\n***********************************************************************\nWRITERTN SAVE  (14,12),,*\n         LR    R12,R15\n         USING WRITERTN,R12\n         LR    R14,R13                 CALLER'S SAVE AREA\n         L     R13,16(,R1)             PTR TO DIALOG DATA AREA\n         L     R13,0(,R13)             A(SAVE2)\n         LA    R13,SAVE3-SAVE2(,R13)   A(SAVE3)\n         ST    R14,4(,R13)             CHAIN SAVE AREAS\n         ST    R13,8(,R14)             CHAIN SAVE AREAS\n         USING SAVE3,R13\n         L     R6,00(,R1)              RECORD DATA\n         L     R7,04(,R1)              LENGTH\n         L     R4,08(,R1)              SOURCE/CHANGE BITS\n         L     R5,12(,R1)              REQUEST CODE\n*              REQ=0                   write next record\n*              REQ=1                   first write request\n*              REQ=2                   last write request\n*              REQ=3                   first and last write request\n*              REQ=4                   no record to write (all deleted)\n*\n         L     R9,LINE_LEN_ADDR+4      A(LINE)\n         USING LINE_DSECT,R9\n         LA    R10,DYNAM_SHVB\n         USING SHVBLOCK,R10\n         L     R5,0(,R5)               request code\n         CH    R5,=H'0'                write next record\n         BE    WRTRTN40                yes, skip DROPVAR\n         CH    R5,=H'2'                write last record\n         BE    WRTRTN40                yes, skip DROPVAR\n         CLI   VAR1,C'*'               Fetch all vars?             R208\n         BE    WRTRTN40                yes, skip DROPVAR           R208\n*\n*        First time only: DROP stem. variables\n*\nDROPVAR  LM    R2,R3,STEMNAME          2ND ARG (VAR NAME)\n         ST    R3,SHVNAML              LENGTH OF VARIABLE NAME\n         MVI   SHVCODE,SHVDROPV        DROP STEM VARIABLE\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         BALR  R14,R15              <- DROP STEM VARIABLE\n*\n*        Write current record to stem.nnn\n*\nWRTRTN40 CH    R5,=H'4'                any record to write?\n         BE    WRTRTN80                no, exit\n         MVC   SHVVALA,0(R6)           Record ADDRESS\n         MVC   SHVVALL,0(R7)           Record LENGTH\n         LA    R0,1                    count output records\n         AL    R0,WRTLINUM             count output records\n         ST    R0,WRTLINUM             count output records\n         CLI   VAR1,C'*'               Fetch all vars?             R208\n         BE    WRTRTN90                                            R208\n         BAL   R15,BLDVARNM         <- build variable name\n         MVI   SHVCODE,SHVSTORE        STORE VARIABLE\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         BALR  R14,R15              <- STORE VARIABLE\n*\n*        Last record only: set stem.0 to the number of records written\n*\nWRTRTN80 EQU   *\n         CH    R5,=H'2'                last record ?\n         BL    WRTRTN99                no, exit\n         CLI   VAR1,C'*'               Fetch all vars?             R208\n         BE    WRTRTN99                yes, exit                   R208\n         L     R0,WRTLINUM             count output records\n         CVD   R0,DWD                  seqno\n         OI    DWD+7,15\n         UNPK  LINE(8),DWD             99999999\n         LA    R0,LINE                 unpack 7 digits\n         ST    R0,SHVVALA              Value addr\n         LA    R0,8                    Value length\n         ST    R0,SHVVALL              Value length\n         LM    R2,R3,STEMNAME          2ND ARG (VAR NAME)\n         LA    R0,1(,R3)               add one byte for \"0\"\n         ST    R0,SHVNAML              LENGTH OF VARIABLE NAME\n         LA    R14,VARNAME             \"to\" addr\n         LR    R15,R3                  \"to\" length\n         MVCL  R14,R2                  move stem.\n         MVI   0(R14),C'0'             append a \"0\" : stem.0\n         MVI   SHVCODE,SHVSTORE        STORE VARIABLE\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         BALR  R14,R15              <- STORE stem.0 VARIABLE\n         B     WRTRTN99                END                         R208\n*                                                                  R208\nWRTRTN90 EQU   *                                                   R208\n         LA    R14,LINE                \"to\" address                R208\n         L     R15,LRECL               \"to\" length                 R208\n         L     R6,SHVVALA              get value address           R208\n         L     R7,SHVVALL              get value length            R208\n         MVCL  R14,R6                  move data to LINE           R208\n         LA    R14,LINE                address of LINE             R208\n         L     R7,SHVVALL              repair R7 after MVCL        R208\n         LR    R15,R7                                              R208\n         MVI   TAB,X'00'               fill up TAB with '00'x      R208\n         MVC   TAB+1(L'TAB-1),TAB                                  R208\n         MVI   TAB+92,X'04'            '*'                         R208\n         XR    R2,R2                   R2 = 0                      R208\n         BCTR  R15,0                   prepare \"EX\"                R208\n         TRT   LINE(*-*),TAB           find '*'                    R208\n         EX    R15,*-6                 execute TRT                 R208\n         BZ    WRTRN90A                no '*', jump                R208\n         SLR   R1,R14                  position of '*'             R208\n         ST    R1,POSST                store position              R208\n         B     WRTRN90B                jump                        R208\nWRTRN90A LR    R1,R7                   max position                R208\n         ST    R1,POSST                store position              R208\nWRTRN90B MVI   TAB+92,X'00'            clear TAB                   R208\n         MVI   TAB+64,X'04'            ' '                         R208\n         XR    R2,R2                   R2 = 0                      R208\n         TRT   LINE(*-*),TAB           find ' '                    R208\n         EX    R15,*-6                 execute TRT                 R208\n         BZ    WRTRN90C                no ' ', jump                R208\n         SLR   R1,R14                  position of ' '             R208\n         ST    R1,POSBL                store position              R208\n         B     WRTRN90D                jump                        R208\nWRTRN90C LR    R1,R7                   max position                R208\n         ST    R1,POSBL                store position              R208\nWRTRN90D MVI   TAB+64,X'00'            clear TAB                   R208\n         MVI   TAB+0,X'04'             '00'x                       R208\n         XR    R2,R2                   R2 = 0                      R208\n         TRT   LINE(*-*),TAB           find '00'x                  R208\n         EX    R15,*-6                 execute TRT                 R208\n         BZ    WRTRN90E                no '00', jump               R208\n         SLR   R1,R14                  position of '00'x           R208\n         ST    R1,POS00                store position              R208\n         B     WRTRN90F                jump                        R208\nWRTRN90E LR    R1,R7                   max position                R208\n         ST    R1,POS00                store position              R208\nWRTRN90F MVI   TAB+0,X'00'             clear TAB                   R208\n         MVI   TAB+126,X'04'           '='                         R208\n         XR    R2,R2                   R2 = 0                      R208\n         TRT   LINE(*-*),TAB           find '='                    R208\n         EX    R15,*-6                 execute TRT                 R208\n         BZ    WRTRN90G                no '=', DROP var?           R208\n         SLR   R1,R14                  position of '='             R208\n         ST    R1,POSEQ                store position              R208\n         B     WRTRN90H                jump                        R208\nWRTRN90G EQU   *                       DROP var                    R208\n         CL    R7,POSST                '*' in line?                R208\n         BH    WRTRTN99                yes - jump back to EDIF     R208\n         LR    R2,R14                  convert to uppercase        R208\n         L     R3,LRECL                convert to uppercase        R208\n         OI    0(R2),X'40'             convert to uppercase        R208\n         LA    R2,1(,R2)               convert to uppercase        R208\n         BCT   R3,*-8                  convert to uppercase        R208\n         CLC   LINE(5),=C'DROP '       DROP a variable?            R208\n         BNE   WRTRTN99                no - jump back to EDIF      R208\n         LA    R1,5                    R1 = 5                      R208\n         LR    R2,R14                  R2 = Address of LINE        R208\n         AR    R2,R1                   Start of var name           R208\n         ST    R2,SHVNAMA              ADDRESS OF VARIABLE NAME    R208\n         L     R2,POS00                end of variable name        R208\n         SLR   R2,R1                   R2 = R2 - 5                 R208\n         ST    R2,SHVNAML              LENGTH OF VARIABLE NAME     R208\n         LA    R1,250                  max length of var name      R208\n         CR    R2,R1                   name too long?              R208\n         BH    WRTRTN99                yes, goback to EDIF         R208\n         MVI   SHVCODE,SHVDROPV        DROP VARIABLE               R208\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)  R208\n         BALR  R14,R15              <- DROP VARIABLE               R208\n         B     WRTRTN99                jump back to EDIF           R208\nWRTRN90H EQU   *                       SET var                     R208\n         CLC   POSST,POSEQ             '*' before '=' ?            R208\n         BL    WRTRTN99                yes - jump back to EDIF     R208\n         CLC   POSBL,POSEQ             ' ' before '=' ?            R208\n         BL    WRTRN90I                yes - jump over next libes  R208\n         ST    R14,SHVNAMA             ADDRESS OF VARIABLE NAME    R208\n         L     R1,POSEQ                POS of '=' is var length    R208\n         ST    R1,SHVNAML              set var length              R208\n         B     WRTRN90J                jump over next lines        R208\nWRTRN90I ST    R14,SHVNAMA             ADDRESS OF VARIABLE NAME    R208\n         L     R1,POSBL                POS of ' ' is var length    R208\n         ST    R1,SHVNAML              set var length              R208\nWRTRN90J L     R1,POSEQ                R1 = pos of '='             R208\n         L     R2,POS00                R2 = End of line            R208\n         SLR   R2,R1                   R2 = R2 - R1                R208\n         ST    R2,SHVVALL              set value length            R208\n         LA    R1,1(,R1)               R1 = R1 + 1                 R208\n         AR    R1,R14                  R1 = R1 + address of line   R208\n         ST    R1,SHVVALA              Convert variable name to    R208\n         L     R2,SHVNAMA              uppercase                   R208\n         L     R3,SHVNAML              convert to uppercase        R208\n         LA    R1,250                  max length of var name      R208\n         CR    R3,R1                   name too long?              R208\n         BH    WRTRTN99                yes, goback to EDIF         R208\n         OI    0(R2),X'40'             convert to uppercase        R208\n         LA    R2,1(,R2)               convert to uppercase        R208\n         BCT   R3,*-8                  convert to uppercase        R208\n         MVI   SHVCODE,SHVSTORE        STORE VARIABLE              R208\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)  R208\n         BALR  R14,R15              <- STORE VARIABLE              R208\n         B     WRTRTN99                jump back to EDIF           R208\n*\nWRTRTN99 L     R13,4(,R13)             EDIF SAVE AREA\n         RETURN (14,12),RC=0           GOBACK TO BRIF (EOF)\n         DROP  R12\n***********************************************************************\n*                                                                     *\n*        Build Variable Name                                          *\n*                                                                     *\n***********************************************************************\nBLDVARNM CVD   R0,DWD                  seqno\n         BALR  R2,0                 <- local base\n         MVC   LINE(8),=X'4020202020202020'-*(R2)\n         LM    R2,R3,STEMNAME          2ND ARG (VAR NAME)\n         LA    R0,VARNAME              \"to\" addr\n         LR    R1,R3                   \"to\" length\n         MVCL  R0,R2                   move stem name \"LINE.\"\n         EDMK  LINE(8),DWD+4           unpack 7 digits\n         LR    R2,R1                   addr of 1st non-zero byte\n         LA    R3,LINE+8               calc length\n         SLR   R3,R2                   calc length\n         LR    R1,R3                   \"to\" length\n         MVCL  R0,R2                   move seq number\n         LA    R1,VARNAME              \"to\" addr\n         SLR   R0,R1                   calc length of variable name\n         ST    R0,SHVNAML              LENGTH OF VARIABLE NAME\n         BR    R15                     GOBACK\n***********************************************************************\n*                                                                     *\n*        CONSTANTS                                                    *\n*                                                                     *\n***********************************************************************\n$CONTROL DC    C'CONTROL '\n$ERRORS  DC    C'ERRORS '\n$RETURN  DC    C'RETURN '\n$DISPLAY DC    C'DISPLAY '\n$REFRESH DC    C'REFRESH '\n$VCOPY   DC    C'VCOPY '\n$VERASE  DC    C'VERASE '\n$SETMSG  DC    C'SETMSG '\n$VDEFINE DC    C'VDEFINE '\n$ZERRMSG DC    C'ZERRMSG '\n$ZENVIR  DC    C'ZENVIR '\n$SAVE    DC    C'SAVE '\n$RESTORE DC    C'RESTORE '\n$ZCMD    DC    C'ZCMD '\n$VIEW    DC    C'VIEW '\n$MOVE    DC    C'MOVE '\nSYNTAXMSG DC     C'Syntax: CALL STEMEDIT service<,stemname><,firstelem>X\n               <,stemcount><,title><,panel><,lrecl><,recfm><,profile>'\n***********************************************************************\n*                                                                     *\n*        Dynamic Storage Area - LOC=BELOW                             *\n*                                                                     *\n***********************************************************************\nDYNAM    DSECT\n         DS    18F                     MAIN-LINE\nSAVE2    DS    18F                     Save area for cmd rtne\nSAVE3    DS    18F                     Save area for read/write rtnes\n*\nDWD      DS    D                       work area for CVB/CVD\nR15R0R1  DS    A(R15,R0,R1)            regs at entry to STEMEDIT\nISPLINK\u00ba DS    V(ISPLINK)              ISPF INTERFACE\nADDR_OF_ENVBLOCK EQU R15R0R1+4,4,C'A'  ENVIRONMENT BLOCK\nPANEL_NAME DS  C'ISRBROBA'             PANEL (6th arg)\nTITLE    DS    CL54                    Title\nSERVICE  DS    C'BROWSE'               ISPF Service (\"B\" or \"V\" or \"E\")\nRECFM    DS    C'V '                   record format\nPROFILE_NAME DS CL8'TEXT'              profile name for EDIF/VIIF\nSTEMNAME DS    A,F                     ADDR/LEN OF STEM NAME (2nd arg)\nCURRECNO DS    F                       first element (3rd arg)\nSTEMCOUNT DS   F                       number of variables (4th arg)\nLRECL    DS    F                       record length (7th arg)\nLASTLINE DS    F                       last line number\nWRTLINUM DS    F                       line number for write rtne\nLINE_LEN_ADDR DS F,A(LINE_DSECT)       length and address of LINE fld\nPARMLIST DS    12F                     EDIF/BRIF/VIIF Parm List\nRDCMDWR  DS    A(RDRTNE,CMDRTNE,WRITERTN) READ/CMD/WRITE Routines\nIRXEXCOM_REGS DS A(R15,R0,R1)          IRXEXCOM\nIRXEXCOM_PARM DS 4A                    IRXEXCOM\nIRXSTK_PARM DS 6A                      IRXSTK\nDYNAM_SHVB DS  XL(SHVBLEN)             SHVB (IRXEXCOM)\nRETCODE  DS    F                       RETURN CODE\nVALUE    DS    F                       VALUE RETURNED BY FUNCTION\nVARNAME  DS    CL255                   variable name\nVAR1     DS    CL1                     VARNAME first character     R208\nVARL     DS    CL1                     Form of var-list S or L     R208\nPOSEQ    DS    F                       position of '='             R208\nPOSBL    DS    F                       position of ' '             R208\nPOS00    DS    F                       position of '00'x           R208\nPOSST    DS    F                       position of '*'             R208\nZENVIR   DS    CL32'ISPF 3.2'          CURRENT ISPF LEVEL\nZERRMSG  DS    CL8                     error message\nWORK80   DS    CL80                    work area\nBLANKS   DS    CL256                   a bunch of blanks\nTAB      DS    XL256                   table for TRT               R208\nDYNAML   EQU   *-DYNAM\n*\nLINE_DSECT DSECT                       RMODE=31\nLINEAL   DS    0CL33016                Line in * output, long varn R208\nLVARNL   DS    CL216                   Long varname in * output    R208\nLINEA    DS    0CL32800                Line in * output            R208\nLVARN    DS    CL40                    Varname in * output         R208\nLINE     DS    CL32760\n*\n         PRINT NOGEN\n         IRXEFPL DSECT=YES             External Function Parm List\n         IRXENVB                       Environment Block\n         IRXEXTE                       External Function Entry Points\n         IRXSHVB                       Shared REXX Variable Req Block\n         YREGS                         Register Equates (R0-R15)\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//LKED    EXEC PGM=IEWL,PARM='LIST,MAP,RENT,REFR'\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,DELETE)\n//SYSPRINT DD SYSOUT=*\n//SYSLMOD  DD DSN=GILBERT.FILE183.LOAD(STEMEDIT),DISP=SHR\n./ ADD NAME=STEMEMCB 0100-13230-13230-1410-00014-00014-00000-RNOWAK\n/* Rexx **************************************************************/\n/* Edit Macro for STEMEDIT 'EDIT','*'                                */\n/* Call this macro at the beginning of the edit session to change    */\n/* all '00'x in blanks and shift the '=' to the left.                */\n/* At the end of the edit session STEMEMCE should be called to end   */\n/* up the lines with '00'x                                           */\n/*********************************************************************/\n\"ISREDIT MACRO\"\n\"ISREDIT CHANGE '00'X '40'X ALL\"\nDO UNTIL RC > 0\n   \"ISREDIT CHANGE '  =' ' =' ALL\"\nEND\n\"ISREDIT MEND\"\nEXIT\n./ ADD NAME=STEMEMCE 0100-13230-13230-1410-00022-00022-00000-RNOWAK\n/* Rexx **************************************************************/\n/* Edit Macro for STEMEDIT 'EDIT','*'                                */\n/* Call this macro at the end of the edit session to end up the      */\n/* lines with '00'x.                                                 */\n/*********************************************************************/\n\"ISREDIT MACRO\"\n\"ISREDIT (n) = LINENUM .ZLAST\"\nDO i=1 to n\n  \"ISREDIT (currline) =LINE \"i\n  if POS('00'x,currline) = 0 then do\n     l = LENGTH(currline)\n     c = SUBSTR(currline,l,1)\n     DO WHILE c = ' '\n        l = l - 1\n        c = SUBSTR(currline,l,1)\n     END\n     currline = LEFT(currline,l) !! '00'x !! SUBSTR(currline,l+2)\n     \"ISREDIT LINE \"i\" = '\"currline\"'\"\n  end\nEND\n\"ISREDIT MEND\"\nEXIT\n./ ADD NAME=TALLY    0100-13230-13230-1410-00100-00100-00000-RNOWAK\n/*---------------------------------------------------------------REXX-*\u00de\n!*                                                                    *!\n!* MODULE NAME = TALLY                                                *!\n!*                                                                    *!\n!* DESCRIPTIVE NAME = Tallies tracks on DSLIST panel.                 *!\n!*                                                                    *!\n!* STATUS = R103                                                      *!\n!*                                                                    *!\n!* FUNCTION = Display the total number of tracks used up by the       *!\n!*            data sets currently displayed on the Data Set List      *!\n!*            panel (ISPF 3.4).  Requires that the size information   *!\n!*            for all the data sets be previously obtained from the   *!\n!*            VTOC, for example with a SORT SIZE command.             *!\n!*                                                                    *!\n!* AUTHOR   =  Gilbert Saint-Flour <carlos\u00bagsf-soft.com>              *!\n!*             http://gsf-soft.com/Freeware/                          *!\n!*                                                                    *!\n!* DEPENDENCIES = TSO/E V2                                            *!\n!*                ISPF V3, V4, V5 or V6                               *!\n!*                                                                    *!\n!* SYNTAX   =  TALLY                                                  *!\n!*                                                                    *!\n!*             Must be issued while on the DSLIST panel, either       *!\n!*             as a line command (on any line) or as TSO %TALLY.      *!\n!*                                                                    *!\n!* CHANGE LOG                                                         *!\n!*                                                                    *!\n!*101 When DTA+016=0, get DSB addr from DTA+044                       *!\n!*102 Stop using DTB in ISPF 5.9 and above                Ron.Hesketh *!\n!*103 Changed for ISPF above V5.9                        Rainer Nowak *!\n!*                                                                    *!\n\u00de*--------------------------------------------------------------------*/\nADDRESS 'ISPEXEC'\ntcb    = PTR(540)               /* TCB (EXEC command)    PSATOLD  */\ntcb    = PTR(tcb+132)           /* TCB (ISPTASK)         TCBOTC   */\nfsa    = PTR(tcb+112)           /* first save area       TCBFSA   */\nr1     = PTR(fsa+24)            /* ISPTASK's R1                   */\ntld    = PTR(r1)                /* TLD address                    */\ndta    = PTR(tld+076)           /* DTA address                    */\ntbl    = STORAGE(D2X(dta+12),8) /* Name of temp table    DSL12345 */\n\"VGET ZENVIR\"                   /* Retrieve ISPF Version          */\nIF LEFT(Zenvir,8) < 'ISPF 5.9' THEN DO\n  dtb    = PTR(dta+016)           /* DTB address                  */\n  IF dtb=0 THEN\n    dtb  = PTR(dta+044)           /* OPEN Table Chain             */\n  IF STORAGE(D2X(dtb),3) /= 'DTB' THEN DO\n    SAY 'Error: Table name could not be located (DTB)' zenvir\n    EXIT 12\n    END\n  tbl  = STORAGE(D2X(dtb+6),8)  /* Name of temp table    DSL12345 */\n  END\nELSE DO                         /* ISPF >= 5.9                    */\n   start = dta + 196            /* Address of first table name    */\n   finished = 'NO'\n   otnr = 0\n   DO UNTIL finished = 'YES'\n      tbl = STORAGE(D2X(start),8) /* Name of table */\n      if C2X(LEFT(tbl,1)) = '00' then do\n         finished = 'YES'\n      end\n      else do\n         if LEFT(tbl,3) = 'DSL' then do\n            otnr = otnr + 1\n            finished = 'YES'\n         end\n         start = start + 12\n      end\n   END\n   IF otnr = 0 THEN DO\n    SAY 'Error: Table name could not be located' zenvir\n    EXIT 12\n    END\nEND\n\n'CONTROL ERRORS RETURN'\n'TBTOP' tbl\n  IF rc>0 THEN DO\n    SAY 'TBTOP failed for table' tbl 'RC='rc\n    EXIT\n  END\n\ntally=0;rows=0;processed=0;zusize=0   /* Init counters */\nDO FOREVER\n  'TBSKIP' tbl                        /* NEXT ROW      */\n  IF rc>0 THEN LEAVE\n  'TBGET' tbl                         /* SET VARIABLES */\n  IF rc>0 THEN LEAVE\n  rows=rows+1                         /* count rows    */\n  IF zusize = '' THEN ITERATE         /* ignore migrated data sets */\n  tally=tally+zusize                  /* tally file size */\n  processed=processed+1               /* count processed data sets */\nEND\nZMSG000S = tally 'Tracks'\nZMSG000L = 'Total Data sets:' rows,\n           ' Data sets processed:' processed,\n           ' Total tracks:' tally\n\"SETMSG MSG(ISPZ000)\"\nEXIT\n\nPTR: RETURN C2D(STORAGE(D2X(ARG(1)),4))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STEMEDI@": {"ttr": 17929, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00I\\x01\\x13#\\x0f\\x01\\x13#\\x0f\\x14E\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-08-18T00:00:00", "modifydate": "2013-08-18T14:45:49", "lines": 12, "newlines": 12, "modlines": 0, "user": "SBGOLOB"}, "text": "Notes concerning STEMEDIT......\n\nPlease reference CBT Tape File 895 from Rainer Nowak, which contains,\namong other things, and extension to the STEMEDIT program to increase\nits utility.  The entire File 895 is copied here, as member STEMEDI#,\nso that if you only have this file, and not File 895, you can still\naccess these materials.\n\nSam Golob   sbgolob@cbttape.org    (Aug 18, 2013)\n            sbgolob@att.net\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STEMEDID": {"ttr": 17931, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00A\\x01\\x161/\\x01\\x161/\\x170\\x00\\xc2\\x00\\xc2\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-11-07T00:00:00", "modifydate": "2016-11-07T17:30:41", "lines": 194, "newlines": 194, "modlines": 0, "user": "SYSLBD"}, "text": "STEMEDIT.DOC\n\nMany times when writing an ISPF dialog in REXX there is a need to\npresent data to the user. The lazy way is to use the say command,\nor write code to write the data to a dataset and then invoke an\nISPF service to Browse, Edit, or View it.  If the data is only\ntemporary then a better option would be to use the data that\nresides in a REXX STEM and that is what STEMEDIT is designed to do.\n\n=====================================================================\n\n\nSTEMEDIT ISPF REXX Command\n\nThe STEMEDIT routine can be invoked by a REXX EXEC to display the\ncontents of stem variables using the ISPF BRIF, VIIF or EDIT\nservices.  STEMEDIT is a nice complement to the REXX OUTTRAP\nfunction, when it is used in the ISPF/PDF environment.\n\nSTEMEDIT can also PULL lines from the data stack instead of using\nstem variables.  This only works with EDIT or VIEW, i.e. not with\nBROWSE.\n\nThe author is Gilbert Saint-Flour and the code is available on the\nCBT TAPE (www.cbttape.org) as a great example of the z/OS Open Source\ncommunity.  (File 183)\n\nThe syntax is:\n\n   CALL STEMEDIT  service,\n                  stemname\n                  <,firstelem>\n                  <,stemcount>\n                  <,title>\n                  <,panel>\n                  <,lrecl>\n                  <,recfm>\n                  <,profile>\n                  <,varl>\n\nParameters:\n\n  SERVICE\n\n  This argument must be coded as 'BROWSE', 'VIEW' or 'EDIT'.  It\n  indicates which of the BRIF, VIIF or EDIF services will be used\n  for display.\n\n  If the BROWSE service is requested, the user can enter the V\n  commands on the BROWSE screen to switch to VIEW.  This allows the\n  data to be saved using CREATE/REPLACE, CUT or ROUTE.\n\n  STEMNAME\n\n  The stem of the family of variables to display.  The combined\n  lengths of the stemname argument and the largest subscript (plus\n  the period, if specified) cannot exceed 80 characters.  If\n  stemname is a true REXX stem, code a period as the last character.\n  If you do not specify the period, the subscripts will be\n  concatenated to the stem name without an intervening period.  For\n  example, if you specify a stemname of \"ABC.\", STEMEDIT will look\n  for variables of the form \"ABC.1\", \"ABC.2\", etc. If you specify a\n  stemname of \"XYZ\" (no period), STEMEDIT will look for variables of\n  the form \"XYZ1\", \"XYZ2\", etc.\n\n  If the service is coded as \"VIEW\" or \"EDIT\" and stemname is\n  omitted, STEMEDIT PULLs lines from the stack.\n\n  If the service is coded as \"VIEW\" or \"EDIT\" the stemname can be\n  coded as \"*\", which will display all variables in the REXX\n  variable pool.  Variable names will be shown with 39 characters,\n  except you code varl as \"L\", showing variable names with 255\n  characters. If variable name is longer, it will be abbreviated to\n  38 or 254 characters and suffixed with \"*\". Last variable is\n  always the contents of VARNAME from this program.  If the service\n  is coded as \"EDIT\" and stemname is coded as \"*\", variables can be\n  edited. It must be coded with variable name beginning in column 1,\n  some blanks end with \"=\" and immediately followed by the value,\n  which must be ended with \"00\"x. You can also drop a variable or a\n  stem by coding \"DROP variablename\" at the beginning of the line\n  and end it with \"00\"x.  Variable name can have a length up to 250.\n\n  FIRSTELEM\n\n  The element of the pseudo-array to begin the display on.  The\n  default value is element 1.\n\n  STEMCOUNT\n\n  The number of elements to display.  If you do not specify\n  stemcount, STEMEDIT will display variables beginning with\n  firstelem, and continuing until an un-initialized variable is\n  found (i.e., a variable which has its name for a value).\n\n  TITLE\n\n  An arbitrary character string which identifies the data which is\n  being displayed.  The maximum length of this string is 54\n  characters.\n\n  PANEL\n\n  A 1 to 8 character name of the panel member to use for the\n  display.  The default panel is ISRBROBA for BROWSE and ISREDDE2\n  for VIEW and EDIT.\n\n  LRECL\n\n  The record length that should be passed to the BRIF, VIIF or EDIF\n  services.  The default value is 255.\n\n  RECFM\n\n  The record format that should be passed to the BRIF, VIIF or EDIF\n  services.  Possible values are F, FA, FM, V, VA, VM, or U.  The\n  default value is V.\n\n  PROFILE\n\n  The 8-char name of the profile that should be used by VIIF and\n  EDIF when the VIEW or EDIT services are requested.  The default\n  value is TEXT.\n\n  VARL\n\n  Form of the variable list, if varname is *.  Can be S for short\n  (=39 char) or L for long (=255 char) varnames.\n\nEXAMPLES\n\n    Call the STEMEDIT routine to display the output of the\n    TSO \"LISTCAT\" command.  The variables to display\n    begin with the characters \"LINE.\":\n\n       CALL OUTTRAP 'LINE.'\n       \"LISTCAT\"\n       CALL STEMEDIT 'BROWSE','LINE.',,,'List Catalog'\n\n    QUEUE JCL to the data stack and call the STEMEDIT\n    routine to VIEW it:\n\n       \"MAKEBUF\"\n       QUEUE '//MYJOB JOB 12345,CLASS=A'\n       QUEUE '//STEP2 EXEC PGM=IEFBR14'\n       CALL STEMEDIT 'VIEW',,,,'Sample JCL'\n       \"DROPBUF\"\n\nRETURN CODES\n\n    The STEMEDIT function returns a return code that indicates\n    whether the display worked.  The returned value is\n    contained in the RC special variable.\n\n    The following STEMEDIT return code values are possible:\n\n    0    The display was successful.\n\n    4    There were no stems matching the description given in\n         stemname (BROWSE).  The data was not modified (EDIT).\n\n    8    Option incompatible with requested service.\n\n    12   Invalid Service requested.\n\n    16   BRIF, VIIF or EDIF failed.\n\nUSAGE NOTES\n\n    The EDIT service only works with a stem variable.  If the\n    data is modified by the user, STEMEDIT DROPs the stem\n    variable, sets stem.0 to the number of records written,\n    copies records to the stem.1 through stem.n where n is\n    equal to the value of the stem.0 variable, and sets the\n    RC variable to 0.  If the data is not modified by the\n    user, STEMEDIT sets the RC variable to 4.\n\nCOMPATIBILITY\n\n    STEMEDIT has been designed to be compatible with\n    the STEMDISP function of the REXXTOOLS product from\n    Open Software Technologies, with the following\n    exceptions:\n\n    1. STEMEDIT supports the BROWSE, VIEW and EDIT services\n       (STEMDISP only supports BROWSE).\n\n    2. If stemcount is not specified, STEMEDIT scans\n       variables until an uninitialized variable is found.\n       (STEMDISP stops after 100000 variables).\n\n    3. STEMEDIT has the ability to retrieve data from a\n       stem variable or the data stack (STEMDISP can only\n       retrieve data from a stem variable).\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STEMEDIH": {"ttr": 18179, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x16%\\x9f\\x01\\x16%\\x9f\\x06X\\x00\\xbe\\x00\\xb9\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2016-09-15T00:00:00", "modifydate": "2016-09-15T06:58:00", "lines": 190, "newlines": 185, "modlines": 0, "user": "SYSLBD"}, "text": ")F Function\n\n This assembler sub-routine can be invoked by a REXX EXEC to\n display the contents of stem variables using the ISPF BRIF,\n VIIF or EDIT services.  STEMEDIT is a nice complement to\n the REXX OUTTRAP function, when it is used in the ISPF/PDF\n environment.\n\n STEMEDIT can also PULL lines from the data stack instead of\n using stem variables.  This only works with EDIT or VIEW,\n i.e. not with BROWSE.\n\n STEMEDIT can be used to view or edit all variables.\n Together with \"TRACE ?R\" STEMEDIT can be used for debugging\n your REXX programs.\n\n AUTHOR = Gilbert Saint-Flour <carlos\u00bagsf-soft.com>\n          http://gsf-soft.com/Freeware/\n\n)X Syntax\n   CALL STEMEDIT  service,\n                  stemname\n                  <,firstelem>\n                  <,stemcount>\n                  <,title>\n                  <,panel>\n                  <,lrecl>\n                  <,recfm>\n                  <,profile>\n                  <,varl>\n\n)O Arguments\n\n))SERVICE\n\n  This argument must be coded as 'BROWSE', 'VIEW' or 'EDIT'.\n  It indicates which of the BRIF, VIIF or EDIF services will\n  be used for display.\n\n  If the BROWSE service is requested, the user can enter the\n  V commands on the BROWSE screen to switch to VIEW.  This\n  allows the data to be saved using CREATE/REPLACE, CUT or\n  ROUTE.\n\n))STEMNAME\n\n  The stem of the family of variables to display.  The\n  combined lengths of the stemname argument and the largest\n  subscript (plus the period, if specified) cannot exceed 80\n  characters.  If stemname is a true REXX stem, code a\n  period as the last character.  If you do not specify the\n  period, the subscripts will be concatenated to the stem\n  name without an intervening period.  For example, if you\n  specify a stemname of \"ABC.\", STEMEDIT will look for\n  variables of the form \"ABC.1\", \"ABC.2\", etc. If you\n  specify a stemname of \"XYZ\" (no period), STEMEDIT will\n  look for variables of the form \"XYZ1\", \"XYZ2\", etc.\n\n  If the service is coded as \"VIEW\" or \"EDIT\" and stemname\n  is omitted, STEMEDIT PULLs lines from the stack.\n\n  If the service is coded as \"VIEW\" or \"EDIT\" the stemname\n  can be coded as \"*\", which will display all variables in\n  the REXX variable pool. Variable names will be shown with\n  39 characters, except you code varl as \"L\", showing\n  variable names with 255 characters. If variable name is\n  longer, it will be abbreviated to 38 or 254 characters and\n  suffixed with \"*\". Last variable is always the contents of\n  VARNAME from this program.  If the service is coded as\n  \"EDIT\" and stemname is coded as \"*\", variables can be\n  edited. It must be coded with variable name beginning in\n  column 1, some blanks end with \"=\" and immediately\n  followed by the value, which must be ended with \"00\"x. You\n  can also drop a variable or a stem by coding \"DROP\n  variablename\" at the beginning of the line and end it with\n  \"00\"x.  Variable name can have a length up to 250.\n\n))FIRSTELEM\n\n  The element of the pseudo-array to begin the display on.\n  The default value is element 1.\n\n))STEMCOUNT\n\n  The number of elements to display.  If you do not specify\n  stemcount, STEMEDIT will display variables beginning with\n  firstelem, and continuing until an un-initialized variable\n  is found (i.e., a variable which has its name for a\n  value).\n\n))TITLE\n\n  An arbitrary character string which identifies the data\n  which is being displayed.  The maximum length of this\n  string is 54 characters.\n\n))PANEL\n\n  A 1 to 8 character name of the panel member to use for the\n  display.  The default panel is ISRBROBA for BROWSE and\n  ISREDDE2 for VIEW and EDIT.\n\n))LRECL\n\n  The record length that should be passed to the BRIF, VIIF\n  or EDIF services.  The default value is 255.\n\n))RECFM\n\n  The record format that should be passed to the BRIF, VIIF\n  or EDIF services.  Possible values are F, FA, FM, V, VA,\n  VM, or U.  The default value is V.\n\n))PROFILE\n\n  The 8-char name of the profile that should be used by VIIF\n  and EDIF when the VIEW or EDIT services are requested.\n  The default value is TEXT.\n\n))VARL\n\n  Form of the variable list, if varname is *.  Can be S for\n  short (=39 char) or L for long (=255 char) varnames.\n\n)Examples\n\n    Call the STEMEDIT routine to display the output of the\n    TSO \"LISTCAT\" command.  The variables to display\n    begin with the characters \"LINE.\":\n\n       CALL OUTTRAP 'LINE.'\n       \"LISTCAT\"\n       CALL STEMEDIT 'BROWSE','LINE.',,,'List Catalog'\n\n    QUEUE JCL to the data stack and call the STEMEDIT\n    routine to VIEW it:\n\n       \"MAKEBUF\"\n       QUEUE '//MYJOB JOB 12345,CLASS=A'\n       QUEUE '//STEP2 EXEC PGM=IEFBR14'\n       CALL STEMEDIT 'VIEW',,,,'Sample JCL'\n       \"DROPBUF\"\n\n)Return Codes\n\n    The STEMEDIT function returns a return code that indicates\n    whether the display worked.  The returned value is\n    contained in the RC special variable.\n\n    The following STEMEDIT return code values are possible:\n\n    0    The display was successful.\n\n    4    There were no stems matching the description given in\n         stemname (BROWSE).  The data was not modified (EDIT).\n\n    8    Option incompatible with requested service.\n\n    12   Invalid Service requested.\n\n    16   BRIF, VIIF or EDIF failed.\n\n)Usage Notes\n\n    The EDIT service only works with a stem variable.  If the\n    data is modified by the user, STEMEDIT DROPs the stem\n    variable, sets stem.0 to the number of records written,\n    copies records to the stem.1 through stem.n where n is\n    equal to the value of the stem.0 variable, and sets the\n    RC variable to 0.  If the data is not modified by the\n    user, STEMEDIT sets the RC variable to 4.\n\n)Compatibility\n\n    STEMEDIT has been designed to be compatible with\n    the STEMDISP function of the REXXTOOLS product from\n    Open Software Technologies, with the following\n    exceptions:\n\n    1. STEMEDIT supports the BROWSE, VIEW and EDIT services\n       (STEMDISP only supports BROWSE).\n\n    2. If stemcount is not specified, STEMEDIT scans\n       variables until an uninitialized variable is found.\n       (STEMDISP stops after 100000 variables).\n\n    3. STEMEDIT has the ability to retrieve data from a\n       stem variable or the data stack (STEMDISP can only\n       retrieve data from a stem variable).\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STEMEDIT": {"ttr": 18183, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x07\\x009\\x00\\x95\\x05\\x9f\\x01\\x10\\x18\\x0f\\x11\\x03\\x03\\xd6\\x00\\x83\\x01}\\xc3\\xc2\\xe3\\xf4\\xf8\\xf3@@@@'", "ispf": {"version": "02.07", "flags": 0, "createdate": "1995-02-28T00:00:00", "modifydate": "2010-06-29T11:03:39", "lines": 982, "newlines": 131, "modlines": 381, "user": "CBT483"}, "text": "//GILBERTV JOB (ACCT#),STEMEDIT,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = STEMEDIT                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = Display REXX Stem Variables using BRIF or VIIF.  *\n*                                                                     *\n* STATUS = R207                                                       *\n*                                                                     *\n* FUNCTION = This assembler sub-routine can be invoked by a REXX      *\n*            EXEC to display the contents of stem variables using     *\n*            the ISPF BRIF, VIIF or EDIT services.  STEMEDIT is       *\n*            a nice complement to the REXX OUTTRAP function,          *\n*            when it is used in the ISPF/PDF environment.             *\n*                                                                     *\n*            STEMEDIT can also PULL lines from the data stack         *\n*            instead of using stem variables.  This only works        *\n*            with EDIT or VIEW, i.e. not with BROWSE.                 *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*          http://gsf-soft.com/Freeware/                              *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*    DEPENDENCIES: OS/390 R10 or z/OS                                 *\n*                  ISPF/PDF V3 (or above)                             *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (CSECT TYPE)                               *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 2K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE ANY, AMODE 31,                   *\n*                 PROBLEM STATE, KEY 8                                *\n*                 APF AUTHORIZATION: NONE                             *\n*                                                                     *\n* SYNTAX  =  See below                                                *\n*                                                                     *\n*    CALL STEMEDIT  service,                                          *\n*                   stemname                                          *\n*                   <,firstelem>                                      *\n*                   <,stemcount>                                      *\n*                   <,title>                                          *\n*                   <,panel>                                          *\n*                   <,lrecl>                                          *\n*                   <,recfm>                                          *\n*                   <,profile>                                        *\n*                                                                     *\n*    Arguments:                                                       *\n*                                                                     *\n*         service   This argument must be coded as 'BROWSE', 'VIEW'   *\n*                   or 'EDIT'.  It indicates which of the BRIF,       *\n*                   VIIF or EDIF services will be used for display.   *\n*                                                                     *\n*                   If the BROWSE service is requested, the user can  *\n*                   enter the V commands on the BROWSE screen to      *\n*                   switch to VIEW.  This allows the data to be       *\n*                   saved using CREATE/REPLACE, CUT or ROUTE.         *\n*                                                                     *\n*         stemname  the stem of the family of variables to display.   *\n*                   The combined lengths of the stemname argument     *\n*                   and the largest subscript (plus the period, if    *\n*                   specified) cannot exceed 80 characters.           *\n*                   If stemname is a true REXX stem, code a period    *\n*                   as the last character.  If you do not specify     *\n*                   the period, the subscripts will be concatenated   *\n*                   to the stem name without an intervening period.   *\n*                   For example, if you specify a stemname of \"ABC.\", *\n*                   STEMEDIT will look for variables of the form      *\n*                   \"ABC.1\", \"ABC.2\", etc. If you specify a stemname  *\n*                   of \"XYZ\" (no period), STEMEDIT will look for      *\n*                   variables of the form \"XYZ1\", \"XYZ2\", etc.        *\n*                                                                     *\n*                   If the service is coded as \"VIEW\" or \"EDIT\" and   *\n*                   stemname is omitted, STEMEDIT PULLs lines from    *\n*                   the stack.                                        *\n*                                                                     *\n*         firstelem the element of the pseudo-array to begin the      *\n*                   display on.  The default value is element 1.      *\n*                                                                     *\n*         stemcount the number of elements to display.                *\n*                   If you do not specify stemcount, STEMEDIT will    *\n*                   display variables beginning with firstelem, and   *\n*                   continuing until an un-initialized variable is    *\n*                   found (i.e., a variable which has its name for    *\n*                   a value).                                         *\n*                                                                     *\n*         title     an arbitrary character string which identifies    *\n*                   the data which is being displayed.  The maximum   *\n*                   length of this string is 54 characters.           *\n*                                                                     *\n*         panel     a 1 to 8 character name of the panel member       *\n*                   to use for the display.                           *\n*                   The default panel is ISRBROBA for BROWSE          *\n*                   and ISREDDE2 for VIEW and EDIT.                   *\n*                                                                     *\n*         lrecl     the record length that should be passed to        *\n*                   the BRIF, VIIF or EDIF services.                  *\n*                   The default value is 255.                         *\n*                                                                     *\n*         recfm     the record format that should be passed to        *\n*                   the BRIF, VIIF or EDIF services.                  *\n*                   Possible values are F, FA, FM, V, VA, VM, or U.   *\n*                   The default value is V.                           *\n*                                                                     *\n*         profile   the 8-char name of the profile that should be     *\n*                   used by VIIF and EDIF when the VIEW or EDIT       *\n*                   services are requested.                           *\n*                   The default value is TEXT.                        *\n*                                                                     *\n*    Examples:                                                        *\n*                                                                     *\n*         Call the STEMEDIT routine to display the output of the      *\n*         TSO \"LISTCAT\" command.  The variables to display            *\n*         begin with the characters \"LINE.\":                          *\n*                                                                     *\n*            CALL OUTTRAP 'LINE.'                                     *\n*            \"LISTCAT\"                                                *\n*            CALL STEMEDIT 'BROWSE','LINE.',,,'List Catalog'          *\n*                                                                     *\n*         QUEUE JCL to the data stack and call the STEMEDIT           *\n*         routine to VIEW it:                                         *\n*                                                                     *\n*            \"MAKEBUF\"                                                *\n*            QUEUE '//MYJOB JOB 12345,CLASS=A'                        *\n*            QUEUE '//STEP2 EXEC PGM=IEFBR14'                         *\n*            CALL STEMEDIT 'VIEW',,,,'Sample JCL'                     *\n*            \"DROPBUF\"                                                *\n*                                                                     *\n* RETURN-CODES = See below                                            *\n*                                                                     *\n*        The STEMEDIT function returns a return code that indicates   *\n*        whether the display worked.  The returned value is           *\n*        contained in the RC special variable.                        *\n*                                                                     *\n*        The following STEMEDIT return code values are possible:      *\n*                                                                     *\n*        0    The display was successful.                             *\n*                                                                     *\n*        4    There were no stems matching the description given in   *\n*             stemname (BROWSE).  The data was not modified (EDIT).   *\n*                                                                     *\n*        8    Option incompatible with requested service.             *\n*                                                                     *\n*        12   Invalid Service requested.                              *\n*                                                                     *\n*        16   BRIF, VIIF or EDIF failed.                              *\n*                                                                     *\n* USAGE NOTES = See below                                             *\n*                                                                     *\n*        The EDIT service only works with a stem variable.            *\n*        If the data is modified by the user, STEMEDIT DROPs the      *\n*        stem variable, sets stem.0 to the number of records          *\n*        written, copies records to the stem.1 through stem.n         *\n*        where n is equal to the value of the stem.0 variable,        *\n*        and sets the RC variable to 0.  If the data is not           *\n*        modified by the user, STEMEDIT sets the RC variable to 4.    *\n*                                                                     *\n* COMPATIBILITY                                                       *\n*                                                                     *\n*        STEMEDIT has been designed to be compatible with             *\n*        the STEMDISP function of the REXXTOOLS product from          *\n*        Open Software Technologies, with the following               *\n*        exceptions:                                                  *\n*                                                                     *\n*        1. STEMEDIT supports the BROWSE, VIEW and EDIT services      *\n*           (STEMDISP only supports BROWSE).                          *\n*                                                                     *\n*        2. If stemcount is not specified, STEMEDIT scans             *\n*           variables until an unitialised variable is found.         *\n*           (STEMDISP stops after 100000 variables).                  *\n*                                                                     *\n*        3. STEMEDIT has the ability to retrieve data from a          *\n*           stem variable or the data stack (STEMDISP can only        *\n*           retrieve data from a stem variable).                      *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n* 100 Initial release                                            1995 *\n* 101 Fix S0C4 in RDRTNE                                         1996 *\n* 102 VIEW support via EDIF                                           *\n* 103 Convert 2nd argument to uppercase (variable name)               *\n*     Add support for 3rd and 4th arguments                           *\n* 104 Change module name from STEMDISP to STEMVIEW               1997 *\n*     Punch ' ALIAS STEMDISP ' for compatibility with REXXTOOLS       *\n*     Change name of EDIT function to VIEW                            *\n*     Issue CONTROL DISPLAY REFRESH before BROWSE/EDIT                *\n*     Pass address of environment block to IRXEXCOM                   *\n* 105 PULL data from the stack when no variable name specified        *\n*     Prompt user before saving data in VIEW mode                     *\n*     LRECL can be specified in 7th argument                          *\n*     Check for missing parms to prevent S0C4                         *\n*     Replace STRING macro with in-line code                          *\n*     Accept SHVTRUNC as valid RC from IRXEXCOM                       *\n* 106 Truncate Title                                                  *\n* 107 E or V command switches from BROWSE to VIEW                1999 *\n* 108 Set ZVMODET='VIEW' to show VIEW instead of EDIT on ISREDDEx     *\n*     Add recfm and profile parameters for VIEW                       *\n*     Display error message after BRIF/EDIF failure                   *\n*     Display STEMVIEW Arguments Syntax if not invoked from REXX      *\n* 201 Program name changed from STEMVIEW to STEMEDIT             2002 *\n*     Use VIIF instead of EDIF (OS/390 R10 and z/OS)                  *\n*     Add EDIT function for stem variables                            *\n*     Maximum length of variable name increased to 255                *\n*     Maximum length of data line increased to 32760                  *\n* 202 Set default LRECL to 255                                   2003 *\n* 203 Force default panel names - ISRBROBA/ISREDDE2              2009 *\n*     Use SAVE3 in RDRTNE and WRITERTN                                *\n*     Move LINE fld to own DSECT                                      *\n*     When invoked for BROWSE and user issues V or E :                *\n*     1. Issue CONTROL DISPLAY SAVE/RESTORE                           *\n*     2. Clear Panel Name                                             *\n* 204 Change X'40' to X'41' (NBSP) in TITLE                           *\n* 205 Add support for ISPF V3                                         *\n*     Replace LINK macro with ISPLINK                                 *\n* 206 Check for empty records in RDRTN84                         2010 *\n* 207 VIIF only supported in ISPF V5 and above                        *\n*                                                                     *\n&REL     SETC  'R207'                                                 *\n***********************************************************************\n         PUNCH ' ALIAS STEMDISP (compatibility with REXXTOOLS) '\n         PUNCH ' ALIAS STEMVIEW (compatibility with STEMVIEW) '\nSTEMEDIT CSECT\nSTEMEDIT RMODE 24                      For TPUT\nSTEMEDIT AMODE 31\n&D       SETC  '&SYSDATE'(7,2)'-'.'&SYSDATE'(1,2)'-'.'&SYSDATE'(4,2)\n         SAVE  (14,12),,'GSF Utilities - STEMEDIT &REL - 20&D &SYSTIME'\n         LR    R12,R15\n         USING STEMEDIT,R12\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ALLOCATE DYNAMIC STORAGE                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         GETMAIN RU,LV=DYNAML,         Allocate Dynamic Storage Area   X\n               LOC=BELOW,              24-bit address for TPUT         X\n               BNDRY=PAGE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LA    R14,72(,R1)             CLEAR WORKING STORAGE\n         LA    R15,DYNAML-72           CLEAR WORKING STORAGE\n         SLR   R1,R1                   CLEAR WORKING STORAGE\n         MVCL  R14,R0                  CLEAR WORKING STORAGE\n         LM    R13,R1,8(R13)           SET R13, RELOAD R1\n         USING DYNAM,R13\n         STM   R15,R1,R15R0R1          save regs for cmd rtne\n         L     R11,EFPLARG-EFPL(,R1)   ADDR OF ARG LIST\n         MVI   BLANKS,C' '             a bunch of blanks\n         MVC   BLANKS+1(L'BLANKS-1),BLANKS\n         MVC   TITLE,BLANKS            default title\n         MVC   PANEL_NAME,BLANKS       default panel name\n         MVI   STEMCOUNT,1             default count: X'01000000'\n         GETMAIN RU,LV=L'LINE,         Allocate Dynamic Storage Area   X\n               BNDRY=PAGE\n         STM   R0,R1,LINE_LEN_ADDR     Save length/address\n         LR    R9,R1                   Copy A(LINE)\n         USING LINE_DSECT,R9\n*---------------------------------------------------------------------*\n*                                                                     *\n*        BUILD THE SHVBLOCK                                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         LA    R10,DYNAM_SHVB\n         USING SHVBLOCK,R10\n         MVI   SHVCODE,SHVFETCH        FETCH VARIABLE\n         LH    R0,=Y(L'LINE)           LENGTH OF 'FETCH' VALUE BUFFER\n         ST    R0,SHVBUFL              LENGTH OF 'FETCH' VALUE BUFFER\n         LA    R0,255                  default lrecl for BRIF/VIIF/EDIF\n         ST    R0,LRECL                default lrecl for BRIF/VIIF/EDIF\n         MVC   RECFM,=C'V '            default RECFM is V\n         MVC   PROFILE_NAME,=CL8'TEXT' default profile name\n         LA    R0,LINE                 ADDRESS OF VALUE BUFFER\n         ST    R0,SHVVALA              ADDRESS OF VALUE BUFFER\n         LA    R0,VARNAME              ADDRESS OF VARIABLE NAME\n         ST    R0,SHVNAMA              ADDRESS OF VARIABLE NAME\n         L     R15,ADDR_OF_ENVBLOCK    Environment block\n         CLC   =C'ENVBLOCK',0(R15)     Invoked from REXX?\n         BNE   NOREXX                  no, quit\n         L     R15,ENVBLOCK_IRXEXTE-ENVBLOCK(,R15) A(IRXEXTE)\n         L     R15,IRXEXCOM-IRXEXTE(,R15)          A(IRXEXCOM)\n         L     R0,ADDR_OF_ENVBLOCK     ENVIRONMENT BLOCK\n         LA    R1,IRXEXCOM_PARM        parm list\n         STM   R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         LA    R14,=C'IRXEXCOM'        Shared Variable Routine\n         SLR   R15,R15                 PARM2=0\n         SLR   R0,R0                   PARM3=0\n         LA    R1,SHVBLOCK             PARM4\n         STM   R14,R1,IRXEXCOM_PARM    build parm list for IRXEXCOM\n         OI    IRXEXCOM_PARM+12,X'80'  VL=1\n*---------------------------------------------------------------------*\n         MACRO                                                    macro\n&NAME    ISPLINK &OPRNDS,&ERRET=                                  macro\n         GBLB  &IHBSWA                                            macro\n&IHBSWA  SETB  1                       VL=1                       macro\n&NAME    LA    R1,PARMLIST             parm list                  macro\n         IHBOPLST ,&OPRNDS,MF=(E,(1))                             macro\n         L     R15,ISPLINK@            ISPLINK bootstrap\n         BALR  R14,R15                 invoke ISPLINK\n         AIF   (T'&ERRET EQ 'O').MEND                             macro\n         LTR   R15,R15                 Any error?\n         BNZ   &ERRET                  yes, jump\n.MEND    MEND                                                     macro\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS ARGUMENTS                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         LOAD  EP=ISPLINK              preload ISPLINK\n         ST    R0,ISPLINK@             A(ISPLINK)\n         LA    R0,L'ZENVIR\n         ST    R0,DWD\n         ISPLINK ($VCOPY,$ZENVIR,DWD,ZENVIR,$MOVE)\n*\n         LM    R2,R3,8*1-8(R11)        1st ARG (BROWSE/EDIT)\n         LTR   R3,R3                   service specified?\n         BNP   ARG1N                   no, error\n         CH    R3,=AL2(L'SERVICE)      name too long?\n         BH    ARG1N                   yes, error\n         BCTR  R3,0                    prepare \"EX\"\n         MVC   SERVICE(*-*),0(R2)      move string\n         EX    R3,*-6                  execute MVC\n         OC    SERVICE,BLANKS          convert to uppercase\n*\n         CLI   ZENVIR+5,C'4'           ISPF V4 or above ?\n         BL    ARG1G                   no, keep blank panel name\n         MVC   PANEL_NAME,=C'ISRBROBA' default panel name (BROWSE)\nARG1G    EQU   *\n         CLC   =C'BROWSE',SERVICE      BROWSE?\n         BE    ARG1X                   yes, exit\n         CLI   ZENVIR+5,C'4'           ISPF V4 or above ?\n         BL    ARG1J                   no, keep blank panel name\n         MVC   PANEL_NAME,=C'ISREDDE2' default panel name (VIEW/EDIT)\nARG1J    EQU   *\n         CLC   =C'VIEW  ',SERVICE      VIEW?\n         BE    ARG1X                   yes, exit\n         CLC   =C'EDIT  ',SERVICE      EDIT?\n         BE    ARG1X                   yes, exit\nARG1N    EQU   *                       bad service specified\n         B     EXIT12                  no service, exit with RC=12\nARG1X    EQU   *\n*\n         LM    R2,R3,8*2-8(R11)        2ND ARG (VAR NAME)\n         STM   R2,R3,STEMNAME          2ND ARG (VAR NAME)\n         LTR   R3,R3                   stemname specified?\n         BNP   ARG2N                   no, jump\n         OI    0(R2),X'40'             convert to uppercase\n         LA    R2,1(,R2)               convert to uppercase\n         BCT   R3,*-8                  convert to uppercase\n         B     ARG2X\nARG2N    EQU   *                       no stemname specified\n         CLI   SERVICE,C'B'            SERVICE=BROWSE?\n         BE    EXIT8                   yes, exit with RC=8\n         CLI   SERVICE,C'E'            SERVICE=EDIT?\n         BE    EXIT8                   yes, exit with RC=8\n         LA    R14,=CL8'PULL'          FUNCTION\n         LA    R15,SHVVALA             ADDRESS OF DATA RETURNED\n         LA    R0,SHVVALL              LENGTH OF DATA RETURNED\n         LA    R1,VALUE                VALUE RETURNED BY IRXSTK\n         LA    R2,ADDR_OF_ENVBLOCK     Environment block\n         LA    R3,RETCODE              RETURN CODE\n         STM   R14,R3,IRXSTK_PARM      BUILD PARM LIST\n         OI    IRXSTK_PARM+20,X'80'    BUILD PARM LIST\nARG2X    EQU   *\n*\n         LM    R2,R3,8*3-8(R11)        3rd ARG (first element)\n         LTR   R3,R3                   zero length?\n         BZ    ARG3X                   yes, jump\n         BM    ARG9X                   eof, exit\n         BCTR  R3,0                    decrement\n         PACK  DWD,0(,R2)              *executed*\n         EX    R3,*-6                  pack the value\n         CVB   R0,DWD                  make it binary\n         BCTR  R0,0                    relative to zero\n         ST    R0,CURRECNO             save it for later\nARG3X    EQU   *\n*\n         LM    R2,R3,8*4-8(R11)        4th ARG (stem count)\n         LTR   R3,R3                   zero length?\n         BZ    ARG4X                   yes, jump\n         BM    ARG9X                   eof, exit\n         BCTR  R3,0                    decrement\n         PACK  DWD,0(,R2)              *executed*\n         EX    R3,*-6                  pack the value\n         CVB   R0,DWD                  make it binary\n         AL    R0,CURRECNO             add origin\n ORG *-4\n         ST    R0,STEMCOUNT            save it for later\nARG4X    EQU   *\n*\n         LM    R2,R3,8*5-8(R11)        5TH ARG (TITLE)\n         LTR   R3,R3                   zero length?\n         BZ    ARG5X                   yes, jump\n         BM    ARG9X                   eof, exit\n         LA    R1,TITLE                start of output area\n         CH    R3,=Y(L'TITLE)          title too long?\n         BNH   ARG5M                   no, jump\n         LH    R3,=Y(L'TITLE)          yes, truncate it\n*LOOP\nARG5M    MVC   0(1,R1),0(R2)           move one character\n         CLI   0(R1),X'40'             X'40' -> X'41' (NBSP)\n         BNE   *+8                     X'40' -> X'41' (NBSP)\n         MVI   0(R1),X'41'             X'40' -> X'41' (NBSP)\n         LA    R1,1(,R1)               next output char\n         LA    R2,1(,R2)               next input char\n         BCT   R3,ARG5M                move title, one char at a time\n*ENDLOOP\nARG5X    EQU   *\n*\n         LM    R2,R3,8*6-8(R11)        6TH ARG (PANEL)\n         LTR   R2,R2                   SPECIFIED?\n         BZ    ARG6X                   no, jump\n         BM    ARG9X                   eof, exit\n         BCTR  R3,0                    prepare \"EX\"\n         MVC   PANEL_NAME(*-*),0(R2)   move string\n         EX    R3,*-6                  execute MVC\nARG6X    EQU   *\n*\n         LM    R2,R3,8*7-8(R11)        7th ARG (lrecl)\n         LTR   R3,R3                   zero length?\n         BZ    ARG7X                   yes, jump\n         BM    ARG9X                   eof, exit\n         BCTR  R3,0                    decrement\n         PACK  DWD,0(,R2)              *executed*\n         EX    R3,*-6                  pack the value\n         CVB   R0,DWD                  make it binary\n         ST    R0,LRECL                save it for later\n         CH    R0,=Y(L'LINE)           lrecl too big?\n         BH    EXIT8                   yes, exit with RC=8\nARG7X    EQU   *\n*\n         LM    R2,R3,8*8-8(R11)        8TH ARG (recfm)\n         LTR   R2,R2                   SPECIFIED?\n         BZ    ARG8X                   no, jump\n         BM    ARG9X                   eof, exit\n         CLI   SERVICE,C'B'            SERVICE=BROWSE?\n         BE    EXIT8                   yes, exit with RC=8\n         CH    R3,=Y(L'RECFM)          too long?\n         BH    EXIT8                   yes, exit with RC=8\n         BCTR  R3,0                    prepare \"EX\"\n         MVC   RECFM(*-*),0(R2)        move string\n         EX    R3,*-6                  execute MVC\n         OC    RECFM,BLANKS            upper-case\nARG8X    EQU   *\n*\n         LM    R2,R3,8*9-8(R11)        9TH ARG (profile)\n         LTR   R2,R2                   SPECIFIED?\n         BZ    ARG9X                   no, jump\n         BM    ARG9X                   eof, exit\n         CLI   SERVICE,C'B'            SERVICE=BROWSE?\n         BE    EXIT8                   yes, exit with RC=8\n         CH    R3,=Y(L'PROFILE_NAME)   too long?\n         BH    EXIT8                   yes, exit with RC=8\n         BCTR  R3,0                    prepare \"EX\"\n         MVC   PROFILE_NAME(*-*),0(R2) move string\n         EX    R3,*-6                  execute MVC\n*\nARG9X    EQU   *                       end of arg list\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Invoke BRIF, VIIF or EDIF Services                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         ISPLINK ($CONTROL,$ERRORS,$RETURN) CONTROL ERRORS RETURN\n         ISPLINK ($CONTROL,$DISPLAY,$REFRESH) CONTROL DISPLAY REFRESH\n         LA    R0,SAVE2                PARM FOR READ ROUTINE\n         ST    R0,SAVE2                PARM FOR READ ROUTINE\n         LA    R2,RDRTNE               READ ROUTINE\n         LA    R3,CMDRTNE              COMMAND ROUTINE\n         LA    R4,WRITERTN             WRITE ROUTINE\n         STM   R2,R4,RDCMDWR+0         READ,CMD,WRITE\n         CLI   SERVICE,C'V'            SERVICE=VIEW?\n         BE    VIIF                    yes, jump\n         CLI   SERVICE,C'E'            SERVICE=EDIT?\n         BE    EDIF                    yes, jump\n         ISPLINK (=C'BRIF',            ISPF SERVICE                    X\n               TITLE,                  DSNAME                          X\n               RECFM,                  RECFM                           X\n               LRECL,                  LRECL                           X\n               RDCMDWR+0,              READ ROUTINE                    X\n               RDCMDWR+4,              COMMAND ROUTINE                 X\n               SAVE2,                  PARM FOR READ ROUTINE           X\n               PANEL_NAME)             PANEL (ISRBROBF/ISRBROBA)\n         CH    R15,=H'12'              empty data set?\n         BNE   GOBACK                  no, jump\n         LA    R7,4                    yes, RC=4 \"no data to browse\"\n         B     GOBACK40\nVIIF     EQU   *\n         CLI   ZENVIR+5,C'5'           ISPF V5 or above ?\n         BL    EDIF                    no, use EDIF instead of VIIF\n         ISPLINK (=C'VIIF',            ISPF SERVICE                    X\n               TITLE,                  DSNAME                          X\n               PROFILE_NAME,           PROFILE NAME                    X\n               RECFM,                  RECFM                           X\n               LRECL,                  LRECL                           X\n               RDCMDWR+0,              READ ROUTINE                    X\n               0,                      COMMAND EXIT                    X\n               SAVE2,                  PARM FOR READ ROUTINE           X\n               0,                      Edit Length                     X\n               PANEL_NAME)             PANEL (ISREDDE2/ISREDDE3)\n         B     GOBACK\nEDIF     EQU   *\n         ISPLINK (=C'EDIF',            ISPF SERVICE                    X\n               TITLE,                  DSNAME                          X\n               PROFILE_NAME,           PROFILE NAME                    X\n               RECFM,                  RECFM                           X\n               LRECL,                  LRECL                           X\n               RDCMDWR+0,              READ ROUTINE                    X\n               RDCMDWR+8,              WRITE ROUTINE                   X\n               0,                      COMMAND EXIT                    X\n               SAVE2,                  PARM FOR READ ROUTINE           X\n               0,                      Edit Length                     X\n               PANEL_NAME)             PANEL (ISREDDE2/ISREDDE3)\n         LTR   R7,R15                  OK?\n         BZ    GOBACK40                yes, jump\n         CH    R7,=H'4'                Data Modified?\n         BE    GOBACK40                no, exit with RC=4\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Set return code                                              *\n*                                                                     *\n*---------------------------------------------------------------------*\nGOBACK   EQU   *\n         LTR   R7,R15                  OK?\n         BZ    GOBACK40                yes, jump\n         CH    R7,=H'4'                Severe error in BRIF/VIIF/EDIF?\n         BH    GOBACK16                yes, RC=16\n         SLR   R7,R7                   no, RC=0\n         B     GOBACK40\n*\n*        BRIF/VIIF/EDIF error: display error message\n*\nGOBACK16 LA    R7,1000(,R7)            RC=10nn: rc nn from BRIF/VIIF\n         LA    R0,L'ZERRMSG            max length\n         ST    R0,DWD                  max length\n         ISPLINK ($VCOPY,$ZERRMSG,DWD,ZERRMSG,$MOVE),                  X\n               ERRET=GOBACK40          No MSG, skip SETMSG\n         ISPLINK ($SETMSG,ZERRMSG)\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Pass return code in RC variable                              *\n*                                                                     *\n*---------------------------------------------------------------------*\nGOBACK40 EQU   *\n         LA    R0,WORK80               ADDRESS OF VALUE BUFFER\n         ST    R0,SHVVALA              ADDRESS OF VALUE BUFFER\n         CVD   R7,DWD                  convert to decimal\n         OI    DWD+7,15                convert to decimal\n         UNPK  WORK80(5),DWD           convert to decimal\n         LA    R15,5                   LENGTH OF VARIABLE NAME\n         ST    R15,SHVVALL             length\n         MVC   VARNAME(2),=C'RC'       variable name\n         LA    R15,2                   LENGTH OF VARIABLE NAME\n         ST    R15,SHVNAML             LENGTH OF VARIABLE NAME\n         MVI   SHVCODE,SHVSTORE        STORE VARIABLE\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         BALR  R14,R15              <- Store REXX variable \"RC\"\n         SLR   R7,R7                   RC=0\n         B     EXIT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        STEMEDIT was not invoked from a REXX exec                    *\n*        Display argument syntax using TPUT                           *\n*                                                                     *\n*---------------------------------------------------------------------*\nNOREXX   EQU   *\n         TPUT  SYNTAXMSG,L'SYNTAXMSG   display syntax\n         LA    R7,20                   RC=20\n         B     EXIT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CLEAN-UP AND EXIT                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\nEXIT8    LA    R7,8                    RC=8 Option incompat w/service\n         B     EXIT\nEXIT12   LA    R7,12                   RC=12 Invalid Service\n*\nEXIT     LM    R0,R1,LINE_LEN_ADDR     Load length/address\n         FREEMAIN RU,LV=(R0),A=(R1)    Free Dynamic Storage Area\n         LR    R1,R13                  A(DYNAM)\n         L     R13,4(,R13)\n         FREEMAIN RU,LV=DYNAML,A=(R1)  Free Dynamic Storage Area\n         LR    R15,R7                  pass return code\n         RETURN (14,12),RC=(15)\n         DROP\n***********************************************************************\n*                                                                     *\n*        BRIF Command Routine                                         *\n*                                                                     *\n*        This routine is invoked by BRIF each time a command is       *\n*        entered on the BROWSE screen.  If the user enters the E      *\n*        or V command, then STEMEDIT reinvokes itself with VIEW       *\n*        instead of BROWSE.                                           *\n*                                                                     *\n***********************************************************************\nCMDRTNE  SAVE  (14,12),,*\n         LR    R12,R15\n         USING CMDRTNE,R12\n         LR    R14,R13                 CALLER'S SAVE AREA\n         L     R13,04(,R1)             PTR TO DIALOG DATA AREA\n         L     R13,0(,R13)             A(SAVE2)\n         ST    R14,4(,R13)             CHAIN SAVE AREAS\n         ST    R13,8(,R14)             CHAIN SAVE AREAS\n         USING SAVE2,R13\n         L     R6,00(,R1)              Function Code\n         L     R9,LINE_LEN_ADDR+4      A(LINE)\n         USING LINE_DSECT,R9\n         CLC   =F'20',0(R6)            UNKNOWN COMMAND?\n         BNE   CMDRTNE4                NO, EXIT\n         LA    R0,L'WORK80             max length of variable\n         ST    R0,DWD                  max length of variable\n         ISPLINK ($VCOPY,$ZCMD,DWD,WORK80,$MOVE)\n         OC    WORK80(2),BLANKS        upper-case\n         CLC   =C'E ',WORK80           ZCMD=\"E\" ?\n         BE    CMDRTNE7                yes, do it\n         CLC   =C'V ',WORK80           ZCMD=\"V\" ?\n         BE    CMDRTNE7                yes, do it\nCMDRTNE4 L     R13,4(,R13)             BRIF SAVE AREA\n         RETURN (14,12),RC=4           ISPF will process the command\n*\n*        Invoke VIEW when user enters V or E during BROWSE display\n*\nCMDRTNE7 EQU   *\n         ISPLINK ($CONTROL,$DISPLAY,$SAVE) CONTROL DISPLAY SAVE\n*\n         LM    R15,R1,R15R0R1          restore regs at entry\n         L     R11,EFPLARG-EFPL(,R1)   ADDR OF ARG LIST\n         LA    R2,$VIEW                service=VIEW\n         LA    R3,L'$VIEW              length\n         STM   R2,R3,0(R11)            update service name\n         SLR   R2,R2                   R2=0\n         SLR   R3,R3                   R3=0\n         STM   R2,R3,8*6-8(R11)        6TH ARG (PANEL)\n         BALR  R14,R15              <- re-invoke myself for VIEW\n*\n         ISPLINK ($CONTROL,$DISPLAY,$RESTORE) CONTROL DISPLAY RESTORE\n*\n         L     R13,4(,R13)             BRIF SAVE AREA\n         RETURN (14,12),RC=0           command processed\n         DROP\n***********************************************************************\n*                                                                     *\n*        BRIF/VIIF READ Routine                                       *\n*                                                                     *\n*        This routine is invoked by BRIF and VIIF to                  *\n*        return the address of a record.                              *\n*                                                                     *\n***********************************************************************\nRDRTNE   SAVE  (14,12),,*\n         LR    R12,R15\n         USING RDRTNE,R12\n         LR    R14,R13                 CALLER'S SAVE AREA\n         L     R13,12(,R1)             PTR TO DIALOG DATA AREA\n         L     R13,0(,R13)             A(SAVE2)\n         LA    R13,SAVE3-SAVE2(,R13)   A(SAVE3)\n         ST    R14,4(,R13)             CHAIN SAVE AREAS\n         ST    R13,8(,R14)             CHAIN SAVE AREAS\n         USING SAVE3,R13\n         L     R6,00(,R1)              RECORD DATA READ\n         L     R7,04(,R1)              LENGTH\n         L     R4,08(,R1)              RELATIVE RECORD NUMBER\n         L     R9,LINE_LEN_ADDR+4      A(LINE)\n         USING LINE_DSECT,R9\n         CLI   SERVICE,C'V'            VIIF?\n         BE    RDRTNE06                YES, JUMP\n         CLI   SERVICE,C'E'            EDIF?\n         BE    RDRTNE06                YES, JUMP\n         L     R5,0(,R4)               LINE NUMBER REQUESTED BY BRIF\n         AL    R5,CURRECNO             add first element (4th arg)\n         B     RDRTNE07\nRDRTNE06 EQU   *\n         LA    R5,1                    NEXT LINE FOR EDIT\n         AL    R5,CURRECNO             RECORD NUMBER\n         ST    R5,CURRECNO             RECORD NUMBER\nRDRTNE07 EQU   *\n*\n         LA    R10,DYNAM_SHVB\n         USING SHVBLOCK,R10\n         CL    R5,STEMCOUNT            end reached?\n         BH    RDRTN79                 yes, exit with RC=8\n*\n*        Retrieve value of current variable\n*\n         BAL   R14,FETCHVAR         <- retrieve stemmed variable\n         CLI   SHVRET,SHVCLEAN         OK?\n         BE    RDRTN70                 yes, pass line to BRIF\n         CLI   SHVRET,SHVTRUNC         truncated value?\n         BE    RDRTN70                 yes, pass line to BRIF\n         CLI   SHVRET,SHVNEWV          this variable exists?\n         BE    RDRTN80                 NO, EXIT\n*\n*        If IRXEXCOM fails, display R15 and SHVRET values.\n*\n         MVC   LINE(L'VARNAME),VARNAME move variable name\n         L     R1,SHVNAML              length of variable name\n         LA    R2,LINE(R1)             length of variable name\n         MVC   0(5,R2),=C' R15='       move literal\n         CVD   R15,DWD                 save return code\n         OI    DWD+7,15                convert to decimal\n         UNPK  5(3,R2),DWD             move return code: R15=008\n         MVC   8(8,R2),=C',SHVRET='    move literal\n         UNPK  16(3,R2),SHVRET(2)      hex display\n         TR    16(2,R2),HEXTAB-240     hex display\n         LA    R15,18(,R1)             data length\n         ST    R15,SHVVALL             length\n*\n*        Return value of variable\n*\nRDRTN70  L     R0,SHVVALA              DATA ADDRESS\n         L     R1,SHVVALL              DATA LENGTH\n         CLI   RECFM,C'F'              RECFM=F?\n         BNE   RDRTN74                 no, jump\n         CL    R1,LRECL                needs padding?\n         BNL   RDRTN74                 no, jump\n         LA    R14,LINE                \"to\" address\n         L     R15,LRECL               \"to\" length\n         ICM   R1,B'1000',BLANKS       padding\n         MVCL  R14,R0                  move data to LINE\n         LA    R0,LINE                 DATA ADDRESS\n         L     R1,LRECL                DATA LENGTH\nRDRTN74  EQU   *\n         ST    R0,0(,R6)               PASS DATA ADDRESS\n         ST    R1,0(,R7)               PASS DATA LENGTH\n         ST    R5,LASTLINE             CURRENT LINE NUMBER\n         L     R13,4(,R13)             BRIF SAVE AREA\n         RETURN (14,12),RC=0           GOBACK TO EDIT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Scan variables to find the highest one                       *\n*                                                                     *\n*        This section determines the number of the last line and      *\n*        passes it to BRIF/VIIF/EDIF along with the EOF indicator.    *\n*                                                                     *\n*---------------------------------------------------------------------*\nRDRTN79  L     R5,STEMCOUNT            eof\n         B     RDRTN81\nRDRTN80  BCTR  R5,0                    previous line\nRDRTN81  EQU   *\n         CL    R5,LASTLINE             was good?\n         BE    RDRTN88                 yes, exit\n         L     R5,LASTLINE             previous line\n*loop\nRDRTN84  LA    R5,1(,R5)               BUMP LINE NUMBER\n         CL    R5,STEMCOUNT            end reached?\n         BH    RDRTN87                 yes, exit with RC=8\n         BAL   R14,FETCHVAR         <- retrieve stemmed variable\n*check for empty variable generally created with:  stem. = ' '\n         OC    SHVVALL,SHVVALL         length=0 ?\n         BZ    RDRTN87                 yes, exit\n         CLI   SHVRET,SHVCLEAN         OK?\n         BE    RDRTN84                 yes, try next variable\n*endloop\nRDRTN87  BCTR  R5,0                    previous line\n         ST    R5,LASTLINE             save number of last line\nRDRTN88  ST    R5,0(,R4)               LAST LINE\n         L     R13,4(,R13)             BRIF SAVE AREA\n         RETURN (14,12),RC=8           GOBACK TO BRIF (EOF)\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Fetch value of a variable                                    *\n*                                                                     *\n*        1. build variable name by concatenating the stem name        *\n*           (such as \"LINE.\") to the sequence number in R5            *\n*        2. pass control to IRXEXCOM                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\nFETCHVAR LM    R2,R3,STEMNAME          2ND ARG (VAR NAME)\n         LTR   R3,R3                   variable name specified?\n         BNP   FETCHV50                no, PULL from stack\n         LR    R0,R5                   seqno\n         BAL   R15,BLDVARNM         <- build variable name\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         BR    R15                     FETCH VARIABLE\n*\n*        PULL an element from the data stack\n*\nFETCHV50 LR    R2,R14                  save return address\n         L     R15,ADDR_OF_ENVBLOCK    Environment block\n         L     R15,ENVBLOCK_IRXEXTE-ENVBLOCK(,R15) A(IRXEXTE)\n         L     R15,IRXSTK-IRXEXTE(,R15) STACK MANAGER\n         LA    R1,IRXSTK_PARM          PARM LIST\n         BALR  R14,R15              <- CALL IRXSTK\n         LTR   R15,R15                 EOF yet?\n         BZR   R2                      no, goback\n         MVI   SHVRET,SHVNEWV          yes, simulate EOF\n         BR    R2                      and goback\n         DROP\nHEXTAB   DC    C'0123456789ABCDEF'\n***********************************************************************\n*                                                                     *\n*        Write Routine (SERVICE=EDIT)                                 *\n*                                                                     *\n***********************************************************************\nWRITERTN SAVE  (14,12),,*\n         LR    R12,R15\n         USING WRITERTN,R12\n         LR    R14,R13                 CALLER'S SAVE AREA\n         L     R13,16(,R1)             PTR TO DIALOG DATA AREA\n         L     R13,0(,R13)             A(SAVE2)\n         LA    R13,SAVE3-SAVE2(,R13)   A(SAVE3)\n         ST    R14,4(,R13)             CHAIN SAVE AREAS\n         ST    R13,8(,R14)             CHAIN SAVE AREAS\n         USING SAVE3,R13\n         L     R6,00(,R1)              RECORD DATA\n         L     R7,04(,R1)              LENGTH\n         L     R4,08(,R1)              SOURCE/CHANGE BITS\n         L     R5,12(,R1)              REQUEST CODE\n*              REQ=0                   write next record\n*              REQ=1                   first write request\n*              REQ=2                   last write request\n*              REQ=3                   first and last write request\n*              REQ=4                   no record to write (all deleted)\n*\n         L     R9,LINE_LEN_ADDR+4      A(LINE)\n         USING LINE_DSECT,R9\n         LA    R10,DYNAM_SHVB\n         USING SHVBLOCK,R10\n         L     R5,0(,R5)               request code\n         CH    R5,=H'0'                write next record\n         BE    WRTRTN40                yes, skip DROPVAR\n         CH    R5,=H'2'                write last record\n         BE    WRTRTN40                yes, skip DROPVAR\n*\n*        First time only: DROP stem. variables\n*\nDROPVAR  LM    R2,R3,STEMNAME          2ND ARG (VAR NAME)\n         ST    R3,SHVNAML              LENGTH OF VARIABLE NAME\n         MVI   SHVCODE,SHVDROPV        DROP STEM VARIABLE\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         BALR  R14,R15              <- DROP STEM VARIABLE\n*\n*        Write current record to stem.nnn\n*\nWRTRTN40 CH    R5,=H'4'                any record to write?\n         BE    WRTRTN80                no, exit\n         MVC   SHVVALA,0(R6)           Record ADDRESS\n         MVC   SHVVALL,0(R7)           Record LENGTH\n         LA    R0,1                    count output records\n         AL    R0,WRTLINUM             count output records\n         ST    R0,WRTLINUM             count output records\n         BAL   R15,BLDVARNM         <- build variable name\n         MVI   SHVCODE,SHVSTORE        STORE VARIABLE\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         BALR  R14,R15              <- STORE VARIABLE\n*\n*        Last record only: set stem.0 to the number of records written\n*\nWRTRTN80 EQU   *\n         CH    R5,=H'2'                last record ?\n         BL    WRTRTN99                no, exit\n         L     R0,WRTLINUM             count output records\n         CVD   R0,DWD                  seqno\n         OI    DWD+7,15\n         UNPK  LINE(8),DWD             99999999\n         LA    R0,LINE                 unpack 7 digits\n         ST    R0,SHVVALA              Value addr\n         LA    R0,8                    Value length\n         ST    R0,SHVVALL              Value length\n         LM    R2,R3,STEMNAME          2ND ARG (VAR NAME)\n         LA    R0,1(,R3)               add one byte for \"0\"\n         ST    R0,SHVNAML              LENGTH OF VARIABLE NAME\n         LA    R14,VARNAME             \"to\" addr\n         LR    R15,R3                  \"to\" length\n         MVCL  R14,R2                  move stem.\n         MVI   0(R14),C'0'             append a \"0\" : stem.0\n         MVI   SHVCODE,SHVSTORE        STORE VARIABLE\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         BALR  R14,R15              <- STORE stem.0 VARIABLE\n*\nWRTRTN99 L     R13,4(,R13)             EDIF SAVE AREA\n         RETURN (14,12),RC=0           GOBACK TO BRIF (EOF)\n         DROP  R12\n***********************************************************************\n*                                                                     *\n*        Build Variable Name                                          *\n*                                                                     *\n***********************************************************************\nBLDVARNM CVD   R0,DWD                  seqno\n         BALR  R2,0                 <- local base\n         MVC   LINE(8),=X'4020202020202020'-*(R2)\n         LM    R2,R3,STEMNAME          2ND ARG (VAR NAME)\n         LA    R0,VARNAME              \"to\" addr\n         LR    R1,R3                   \"to\" length\n         MVCL  R0,R2                   move stem name \"LINE.\"\n         EDMK  LINE(8),DWD+4           unpack 7 digits\n         LR    R2,R1                   addr of 1st non-zero byte\n         LA    R3,LINE+8               calc length\n         SLR   R3,R2                   calc length\n         LR    R1,R3                   \"to\" length\n         MVCL  R0,R2                   move seq number\n         LA    R1,VARNAME              \"to\" addr\n         SLR   R0,R1                   calc length of variable name\n         ST    R0,SHVNAML              LENGTH OF VARIABLE NAME\n         BR    R15                     GOBACK\n***********************************************************************\n*                                                                     *\n*        CONSTANTS                                                    *\n*                                                                     *\n***********************************************************************\n$CONTROL DC    C'CONTROL '\n$ERRORS  DC    C'ERRORS '\n$RETURN  DC    C'RETURN '\n$DISPLAY DC    C'DISPLAY '\n$REFRESH DC    C'REFRESH '\n$VCOPY   DC    C'VCOPY '\n$VERASE  DC    C'VERASE '\n$SETMSG  DC    C'SETMSG '\n$VDEFINE DC    C'VDEFINE '\n$ZERRMSG DC    C'ZERRMSG '\n$ZENVIR  DC    C'ZENVIR '\n$SAVE    DC    C'SAVE '\n$RESTORE DC    C'RESTORE '\n$ZCMD    DC    C'ZCMD '\n$VIEW    DC    C'VIEW '\n$MOVE    DC    C'MOVE '\nSYNTAXMSG DC     C'Syntax: CALL STEMEDIT service<,stemname><,firstelem>X\n               <,stemcount><,title><,panel><,lrecl><,recfm><,profile>'\n***********************************************************************\n*                                                                     *\n*        Dynamic Storage Area - LOC=BELOW                             *\n*                                                                     *\n***********************************************************************\nDYNAM    DSECT\n         DS    18F                     MAIN-LINE\nSAVE2    DS    18F                     Save area for cmd rtne\nSAVE3    DS    18F                     Save area for read/write rtnes\n*\nDWD      DS    D                       work area for CVB/CVD\nR15R0R1  DS    A(R15,R0,R1)            regs at entry to STEMEDIT\nISPLINK@ DS    V(ISPLINK)              ISPF INTERFACE\nADDR_OF_ENVBLOCK EQU R15R0R1+4,4,C'A'  ENVIRONMENT BLOCK\nPANEL_NAME DS  C'ISRBROBA'             PANEL (6th arg)\nTITLE    DS    CL54                    Title\nSERVICE  DS    C'BROWSE'               ISPF Service (\"B\" or \"V\" or \"E\")\nRECFM    DS    C'V '                   record format\nPROFILE_NAME DS CL8'TEXT'              profile name for EDIF/VIIF\nSTEMNAME DS    A,F                     ADDR/LEN OF STEM NAME (2nd arg)\nCURRECNO DS    F                       first element (3rd arg)\nSTEMCOUNT DS   F                       number of variables (4th arg)\nLRECL    DS    F                       record length (7th arg)\nLASTLINE DS    F                       last line number\nWRTLINUM DS    F                       line number for write rtne\nLINE_LEN_ADDR DS F,A(LINE_DSECT)       length and address of LINE fld\nPARMLIST DS    12F                     EDIF/BRIF/VIIF Parm List\nRDCMDWR  DS    A(RDRTNE,CMDRTNE,WRITERTN) READ/CMD/WRITE Routines\nIRXEXCOM_REGS DS A(R15,R0,R1)          IRXEXCOM\nIRXEXCOM_PARM DS 4A                    IRXEXCOM\nIRXSTK_PARM DS 6A                      IRXSTK\nDYNAM_SHVB DS  XL(SHVBLEN)             SHVB (IRXEXCOM)\nRETCODE  DS    F                       RETURN CODE\nVALUE    DS    F                       VALUE RETURNED BY FUNCTION\nZENVIR   DS    CL32'ISPF 3.2'          CURRENT ISPF LEVEL\nZERRMSG  DS    CL8                     error message\nWORK80   DS    CL80                    work area\nVARNAME  DS    CL255                   variable name\nBLANKS   DS    CL256                   a bunch of blanks\nDYNAML   EQU   *-DYNAM\n*\nLINE_DSECT DSECT                       RMODE=31\nLINE     DS    CL32760\n*\n         PRINT NOGEN\n         IRXEFPL DSECT=YES             External Function Parm List\n         IRXENVB                       Environment Block\n         IRXEXTE                       External Function Entry Points\n         IRXSHVB                       Shared REXX Variable Req Block\n         YREGS                         Register Equates (R0-R15)\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//LKED    EXEC PGM=IEWL,PARM='LIST,MAP,RENT,REFR'\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,DELETE)\n//SYSPRINT DD SYSOUT=*\n//SYSLMOD  DD DSN=GILBERT.FILE183.LOAD(STEMEDIT),DISP=SHR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STEMVIEW": {"ttr": 18690, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00@\\x00\\x95\\x05\\x9f\\x00\\x995\\x1f\\x12\\x11\\x03\\xe0\\x00\\x83\\x02\\xdd\\xc3\\xc2\\xe3\\xf4\\xf2\\xf3@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1995-02-28T00:00:00", "modifydate": "1999-12-17T12:11:40", "lines": 992, "newlines": 131, "modlines": 733, "user": "CBT423"}, "text": "//GILBERTV JOB (ACCT#),STEMVIEW,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF,BATCH)\n***********************************************************************\n*                                                                     *\n*            COPYRIGHT (C) 1995-1999 GILBERT SAINT-FLOUR              *\n*                       ALL RIGHTS RESERVED                           *\n*                                                                     *\n* MODULE NAME = STEMVIEW                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = Display Stem Variables using BRIF or EDIF.       *\n*                                                                     *\n* STATUS = R108                                                       *\n*                                                                     *\n* FUNCTION = This assembler sub-routine can be invoked in a REXX      *\n*            EXEC to display the contents of stem variables using     *\n*            the ISPF BRIF or EDIF service.  STEMVIEW is a nice       *\n*            complement to the REXX OUTTRAP function.                 *\n*                                                                     *\n*            STEMVIEW can also PULL lines from the data stack.        *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*    DEPENDENCIES: TSO/E V2                                           *\n*                  ISPF/PDF V3 (or above)                             *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (CSECT TYPE)                               *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 2K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE ANY, AMODE 31,                   *\n*                 PROBLEM STATE, KEY 8                                *\n*                 APF AUTHORIZATION: NONE                             *\n*                                                                     *\n* SYNTAX  =  See below                                                *\n*                                                                     *\n*    CALL STEMVIEW  service,                                          *\n*                   stemname                                          *\n*                   <,firstelem>                                      *\n*                   <,stemcount>                                      *\n*                   <,title>                                          *\n*                   <,panel>                                          *\n*                   <,lrecl>                                          *\n*                   <,recfm>                                          *\n*                   <,profile>                                        *\n*                                                                     *\n*    Arguments:                                                       *\n*                                                                     *\n*         service   This argument must be coded as 'BROWSE' or 'VIEW'.*\n*                   It indicates which of the BRIF or EDIF services   *\n*                   will be used for display.                         *\n*                                                                     *\n*                   If the BROWSE service is requested, the user can  *\n*                   enter the E or V commands on the BROWSE screen    *\n*                   to switch to VIEW.  This allows the data to       *\n*                   be saved using CREATE/REPLACE, CUT or ROUTE.      *\n*                                                                     *\n*         stemname  the stem of the family of variables to display.   *\n*                   The combined lengths of the stemname argument     *\n*                   and the largest subscript (plus the period, if    *\n*                   specified) cannot exceed 80 characters.           *\n*                   If stemname is a true REXX stem, code a period    *\n*                   as the last character.  If you do not specify     *\n*                   the period, the subscripts will be concatenated   *\n*                   to the stem name without an intervening period.   *\n*                   For example, if you specify a stemname of \"ABC.\", *\n*                   STEMVIEW will look for variables of the form      *\n*                   \"ABC.1\", \"ABC.2\", etc. If you specify a stemname  *\n*                   of \"XYZ\" (no period), STEMVIEW will look for      *\n*                   variables of the form \"XYZ1\", \"XYZ2\", etc.        *\n*                                                                     *\n*                   If the first argument is coded as \"VIEW\" and      *\n*                   stemname is omitted, STEMVIEW PULLs lines from    *\n*                   the stack.                                        *\n*                                                                     *\n*         firstelem the element of the pseudo-array to begin the      *\n*                   display on.  The default value is element 1.      *\n*                                                                     *\n*         stemcount the number of elements to display.                *\n*                   If you do not specify stemcount, STEMVIEW will    *\n*                   display variables beginning with firstelem, and   *\n*                   continuing until an un-initialized variable is    *\n*                   found (i.e., a variable which has its name for    *\n*                   a value).                                         *\n*                                                                     *\n*         title     an arbitrary character string which identifies    *\n*                   the data which is being displayed.  The maximum   *\n*                   length of this string is 54 characters.           *\n*                                                                     *\n*         panel     a 1 to 8 character name of the panel member to    *\n*                   use for the display. The default panel is         *\n*                   ISRBROBF for BROWSE and ISREDDEx for VIEW,        *\n*                   where x is 2 for ISPF V3 and 3 for ISPF V4.       *\n*                                                                     *\n*         lrecl     the record length that should be passed           *\n*                   to EDIF when the VIEW service is requested.       *\n*                   The default value is 255.                         *\n*                                                                     *\n*         recfm     the record format that should be passed to        *\n*                   EDIF when the VIEW service is requested.          *\n*                   Possible values are F, FA, FM, V, VA, VM, or U.   *\n*                   The default value is V.                           *\n*                                                                     *\n*         profile   the 8-char name of the profile that should be     *\n*                   used by EDIF when the VIEW service is requested.  *\n*                   The default value is TEXT.                        *\n*                                                                     *\n*    Examples:                                                        *\n*                                                                     *\n*         Call the STEMVIEW routine to display the output of the      *\n*         TSO \"LISTCAT\" command.  The variables to display            *\n*         begin with the characters \"LINE.\":                          *\n*                                                                     *\n*            CALL OUTTRAP 'LINE.'                                     *\n*            \"LISTCAT\"                                                *\n*            CALL STEMVIEW 'BROWSE','LINE.',,,'List Catalog'          *\n*                                                                     *\n*         QUEUE JCL to the data stack and call the STEMVIEW           *\n*         routine to VIEW it:                                         *\n*                                                                     *\n*            \"MAKEBUF\"                                                *\n*            QUEUE '//MYJOB JOB 12345,CLASS=A'                        *\n*            QUEUE '//STEP2 EXEC PGM=IEFBR14'                         *\n*            CALL STEMVIEW 'VIEW',,,,'Sample JCL'                     *\n*            \"DROPBUF\"                                                *\n*                                                                     *\n* RETURN-CODES = See below                                            *\n*                                                                     *\n*         The STEMVIEW function returns a return code that indicates  *\n*         whether the display worked.  The returned value is          *\n*         contained in the RC special variable.                       *\n*                                                                     *\n*         The following STEMVIEW return code values are possible:     *\n*                                                                     *\n*         0    The display was successful.                            *\n*                                                                     *\n*         4    There were no stems matching the description given     *\n*              in stemname.                                           *\n*                                                                     *\n*         12   Invalid Service requested.                             *\n*                                                                     *\n*         16   BRIF or EDIF failed.                                   *\n*                                                                     *\n* COMPATIBILITY                                                       *\n*                                                                     *\n*        STEMVIEW has been designed to be compatible with             *\n*        the STEMDISP function of the REXXTOOLS product from          *\n*        Open Software Technologies, with the following               *\n*        exceptions:                                                  *\n*                                                                     *\n*        1. STEMDISP does not support the VIEW service                *\n*                                                                     *\n*        2. the length of the fully-qualified variable name           *\n*           is limited to 80 characters (STEMDISP allows 255          *\n*           characters).                                              *\n*                                                                     *\n*        3. the length of a data line is limited to 255 characters    *\n*           (STEMDISP allows 32760 characters).                       *\n*                                                                     *\n*        4. STEMDISP stops after 100000 variables if stemcount        *\n*           is not specified.                                         *\n*                                                                     *\n*        5. STEMDISP does not have the ability to PULL data           *\n*           from the stack.                                           *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n* 100 Initial release                                                 *\n* 101 Fix S0C4 in RDRTNE                                              *\n* 102 VIEW support via EDIF                                           *\n* 103 Convert 2nd argument to uppercase (variable name)               *\n*     Add support for 3rd and 4th arguments                           *\n* 104 Change module name from STEMDISP to STEMVIEW                    *\n*     Punch ' ALIAS STEMDISP ' for compatibility with REXXTOOLS       *\n*     Change name of EDIT function to VIEW                            *\n*     Issue CONTROL DISPLAY REFRESH before BROWSE/EDIT                *\n*     Pass address of environment block to IRXEXCOM                   *\n* 105 PULL data from the stack when no variable name specified        *\n*     Prompt user before saving data in VIEW mode                     *\n*     LRECL can be specified in 7th argument                          *\n*     Check for missing parms to prevent S0C4                         *\n*     Replace STRING macro with in-line code                          *\n*     Accept SHVTRUNC as valid RC from IRXEXCOM                       *\n* 106 Truncate Title                                                  *\n* 107 E or V command switches from BROWSE to VIEW                     *\n* 108 Set ZVMODET='VIEW' to show VIEW instead of EDIT on ISREDDEx     *\n*     Add recfm and profile parameters for VIEW                       *\n*     Display error message after BRIF/EDIF failure                   *\n*     Display STEMVIEW Arguments Syntax if not invoked from REXX      *\n*                                                                     *\n&REL     SETC  'R108'                                                 *\n***********************************************************************\n         PUNCH ' ALIAS STEMDISP (compatibility with REXXTOOLS) '\nSTEMVIEW CSECT\nSTEMVIEW RMODE ANY\n         SAVE  (14,12),,'GSF UTILITIES - STEMVIEW &REL'\n         LR    R12,R15\n         USING STEMVIEW,R12\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ALLOCATE DYNAMIC STORAGE                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         GETMAIN R,LV=DYNAML\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LA    R14,72(,R1)             CLEAR WORKING STORAGE\n         LA    R15,DYNAML-72           CLEAR WORKING STORAGE\n         SLR   R1,R1                   CLEAR WORKING STORAGE\n         MVCL  R14,R0                  CLEAR WORKING STORAGE\n         LM    R13,R1,8(R13)           SET R13, RELOAD R1\n         USING DYNAM,R13\n         STM   R15,R1,R15R0R1          save regs for cmd rtne\n         L     R11,EFPLARG-EFPL(,R1)   ADDR OF ARG LIST\n         MVI   BLANKS,C' '             a bunch of blanks\n         MVC   BLANKS+1(L'BLANKS-1),BLANKS\n         MVI   STEMCOUNT,1             default count: X'01000000'\n         MVC   TITLE,BLANKS            default title\n         MVC   PANEL_NAME,BLANKS       default panel name\n*---------------------------------------------------------------------*\n*                                                                     *\n*        BUILD THE SHVBLOCK                                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         LA    R10,DYNAM_SHVB\n         USING SHVBLOCK,R10\n         MVI   SHVCODE,SHVFETCH        FETCH VARIABLE\n         LA    R0,L'LINE               LENGTH OF 'FETCH' VALUE BUFFER\n         ST    R0,SHVBUFL              LENGTH OF 'FETCH' VALUE BUFFER\n         ST    R0,LRECL                default lrecl for BRIF and EDIF\n         MVC   RECFM,=C'V '            default RECFM is V\n         MVC   PROFILE_NAME,=CL8'TEXT' default profile name\n         LA    R0,LINE                 ADDRESS OF VALUE BUFFER\n         ST    R0,SHVVALA              ADDRESS OF VALUE BUFFER\n         LA    R0,VARNAME              ADDRESS OF VARIABLE NAME\n         ST    R0,SHVNAMA              ADDRESS OF VARIABLE NAME\n         L     R15,ADDR_OF_ENVBLOCK    Environment block\n         CLC   =C'ENVBLOCK',0(R15)     Invoked from REXX?\n         BNE   NOREXX                  no, quit\n         L     R15,ENVBLOCK_IRXEXTE-ENVBLOCK(,R15) A(IRXEXTE)\n         L     R15,IRXEXCOM-IRXEXTE(,R15)          A(IRXEXCOM)\n         L     R0,ADDR_OF_ENVBLOCK     ENVIRONMENT BLOCK\n         LA    R1,IRXEXCOM_PARM        parm list\n         STM   R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         LA    R14,=C'IRXEXCOM'        Shared Variable Routine\n         SLR   R15,R15                 PARM2=0\n         SLR   R0,R0                   PARM3=0\n         LA    R1,SHVBLOCK             PARM4\n         STM   R14,R1,IRXEXCOM_PARM    build parm list for IRXEXCOM\n         OI    IRXEXCOM_PARM+12,X'80'  VL=1\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS ARGUMENTS                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         LM    R2,R3,8*1-8(R11)        1st ARG (BROWSE/EDIT)\n         LTR   R3,R3                   service specified?\n         BNP   ARG1N                   no, error\n         CH    R3,=AL2(L'SERVICE)      name too long?\n         BH    ARG1N                   yes, error\n         BCTR  R3,0                    prepare \"EX\"\n         MVC   SERVICE(*-*),0(R2)      move string\n         EX    R3,*-6                  execute MVC\n         OC    SERVICE,BLANKS          convert to uppercase\n         CLC   =C'BROWSE',SERVICE      BROWSE?\n         BE    ARG1X                   yes, exit\n         CLC   =C'VIEW  ',SERVICE      VIEW?\n         BE    ARG1X                   yes, exit\nARG1N    EQU   *                       no service specified\n         LA    R7,12                   rc=12\n         B     EXIT                    no service, exit with RC=12\nARG1X    EQU   *\n*\n         LM    R2,R3,8*2-8(R11)        2ND ARG (VAR NAME)\n         STM   R2,R3,STEMNAME          2ND ARG (VAR NAME)\n         LTR   R3,R3                   stemname specified?\n         BNP   ARG2N                   no, jump\n         OI    0(R2),X'40'             convert to uppercase\n         LA    R2,1(,R2)               convert to uppercase\n         BCT   R3,*-8                  convert to uppercase\n         B     ARG2X\nARG2N    EQU   *                       no stemname specified\n         LA    R7,12                   rc=12\n         CLI   SERVICE,C'V'            SERVICE=VIEW?\n         BNE   EXIT                    no, exit with RC=12\n         LA    R14,=CL8'PULL'          FUNCTION\n         LA    R15,SHVVALA             ADDRESS OF DATA RETURNED\n         LA    R0,SHVVALL              LENGTH OF DATA RETURNED\n         LA    R1,VALUE                VALUE RETURNED BY IRXSTK\n         LA    R2,ADDR_OF_ENVBLOCK     Environment block\n         LA    R3,RETCODE              RETURN CODE\n         STM   R14,R3,IRXSTK_PARM      BUILD PARM LIST\n         OI    IRXSTK_PARM+20,X'80'    BUILD PARM LIST\nARG2X    EQU   *\n*\n         LM    R2,R3,8*3-8(R11)        3rd ARG (first element)\n         LTR   R3,R3                   zero length?\n         BZ    ARG3X                   yes, jump\n         BM    ARG9X                   eof, exit\n         BCTR  R3,0                    decrement\n         PACK  DWD,0(,R2)              *executed*\n         EX    R3,*-6                  pack the value\n         CVB   R0,DWD                  make it binary\n         BCTR  R0,0                    relative to zero\n         ST    R0,CURRECNO             save it for later\nARG3X    EQU   *\n*\n         LM    R2,R3,8*4-8(R11)        4th ARG (stem count)\n         LTR   R3,R3                   zero length?\n         BZ    ARG4X                   yes, jump\n         BM    ARG9X                   eof, exit\n         BCTR  R3,0                    decrement\n         PACK  DWD,0(,R2)              *executed*\n         EX    R3,*-6                  pack the value\n         CVB   R0,DWD                  make it binary\n         AL    R0,CURRECNO             add origin\n         ST    R0,STEMCOUNT            save it for later\nARG4X    EQU   *\n*\n         LM    R2,R3,8*5-8(R11)        5TH ARG (TITLE)\n         LTR   R3,R3                   zero length?\n         BZ    ARG5X                   yes, jump\n         BM    ARG9X                   eof, exit\n         LA    R1,TITLE                start of output area\n         CH    R3,=Y(L'TITLE)          title too long?\n         BNH   ARG5M                   no, jump\n         LH    R3,=Y(L'TITLE)          yes, truncate it\nARG5M    MVC   0(1,R1),0(R2)           move one character\n         CLI   0(R1),C' '              X'40' -> X'00'\n         BNE   *+8                     X'40' -> X'00'\n         MVI   0(R1),0                 X'40' -> X'00'\n         LA    R1,1(,R1)               next output char\n         LA    R2,1(,R2)               next input char\n         BCT   R3,ARG5M                move title, one char at a time\nARG5X    EQU   *\n*\n         LM    R2,R3,8*6-8(R11)        6TH ARG (PANEL)\n         LTR   R2,R2                   SPECIFIED?\n         BZ    ARG6X                   no, jump\n         BM    ARG9X                   eof, exit\n         BCTR  R3,0                    prepare \"EX\"\n         MVC   PANEL_NAME(*-*),0(R2)   move string\n         EX    R3,*-6                  execute MVC\nARG6X    EQU   *\n*\n         LM    R2,R3,8*7-8(R11)        7th ARG (lrecl)\n         LTR   R3,R3                   zero length?\n         BZ    ARG7X                   yes, jump\n         BM    ARG9X                   eof, exit\n         BCTR  R3,0                    decrement\n         PACK  DWD,0(,R2)              *executed*\n         EX    R3,*-6                  pack the value\n         CVB   R0,DWD                  make it binary\n         ST    R0,LRECL                save it for later\n         CH    R0,=Y(L'LINE)           lrecl too big?\n         BH    EXIT                    yes, exit with RC=12\nARG7X    EQU   *\n*\n         LM    R2,R3,8*8-8(R11)        8TH ARG (recfm)\n         LTR   R2,R2                   SPECIFIED?\n         BZ    ARG8X                   no, jump\n         BM    ARG9X                   eof, exit\n         CLI   SERVICE,C'V'            SERVICE=VIEW?\n         BNE   EXIT                    no, exit with RC=12\n         CH    R3,=Y(L'RECFM)          too long?\n         BH    EXIT                    yes, exit with RC=12\n         BCTR  R3,0                    prepare \"EX\"\n         MVC   RECFM(*-*),0(R2)        move string\n         EX    R3,*-6                  execute MVC\n         OC    RECFM,BLANKS            upper-case\nARG8X    EQU   *\n*\n         LM    R2,R3,8*9-8(R11)        9TH ARG (profile)\n         LTR   R2,R2                   SPECIFIED?\n         BZ    ARG9X                   no, jump\n         BM    ARG9X                   eof, exit\n         CLI   SERVICE,C'V'            SERVICE=VIEW?\n         BNE   EXIT                    no, exit with RC=12\n         CH    R3,=Y(L'PROFILE_NAME)   too long?\n         BH    EXIT                    yes, exit with RC=12\n         BCTR  R3,0                    prepare \"EX\"\n         MVC   PROFILE_NAME(*-*),0(R2) move string\n         EX    R3,*-6                  execute MVC\n*\nARG9X    EQU   *                       end of arg list\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Invoke BRIF or EDIF Service                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         L     R0,ISPLINK$             =CL8'ISPLINK'\n         LOAD  EPLOC=(0)               preload ISPLINK\n         LA    R1,=A($CONTROL,$ERRORS,$RETURN+VL)\n         LINK  SF=(E,ISPLINK$)         CONTROL ERRORS RETURN\n         LA    R1,=A($CONTROL,$DISPLAY,$REFRESH+VL)\n         LINK  SF=(E,ISPLINK$)         CONTROL DISPLAY REFRESH\n         LA    R0,SAVE2                PARM FOR READ ROUTINE\n         ST    R0,SAVE2                PARM FOR READ ROUTINE\n         CLI   SERVICE,C'V'            SERVICE=VIEW?\n         BE    EDIF                    yes, jump\n         LINK  SF=(E,ISPLINK$),        ISPF INTERFACE                  X\n               PARAM=(=C'BRIF',        ISPF SERVICE                    X\n               TITLE,                  DSNAME                          X\n               RECFM,                  RECFM                           X\n               LRECL,                  LRECL                           X\n               =A(RDRTNE),             READ ROUTINE                    X\n               =A(CMDRTNE),            COMMAND ROUTINE                 X\n               SAVE2,                  PARM FOR READ ROUTINE           X\n               PANEL_NAME),            PANEL (ISRBROBF/ISRBROBA)       X\n               MF=(E,PARMLIST),        PARM LIST                       X\n               VL=1\n         CH    R15,=H'12'              no data to browse?\n         BE    GOBACK4                 yes, jump\n         B     GOBACK\nEDIF     L     R15,=V(ENDVIEW)         Trap END/RETURN/SAVE\n         BALR  R14,R15                 set up IMACRO\n         LR    R2,R1                   name of IMACRO\n         LINK  SF=(E,ISPLINK$),        ISPF INTERFACE                  X\n               PARAM=(=C'EDIF',        ISPF SERVICE                    X\n               TITLE,                  DSNAME                          X\n               PROFILE_NAME,           PROFILE NAME                    X\n               RECFM,                  RECFM                           X\n               LRECL,                  LRECL                           X\n               =A(RDRTNE),             READ ROUTINE                    X\n               =A(WRITERTN),           WRITE ROUTINE                   X\n               0,                      COMMAND EXIT                    X\n               SAVE2,                  PARM FOR READ ROUTINE           X\n               0,                      Edit Length                     X\n               PANEL_NAME,             PANEL (ISREDDE2/ISREDDE3)       X\n               (R2)),                  Initial Macro (ENDVIEW)         X\n               MF=(E,PARMLIST),        PARM LIST                       X\n               VL=1\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Set return code                                              *\n*                                                                     *\n*---------------------------------------------------------------------*\nGOBACK   EQU   *\n         LTR   R7,R15                  OK?\n         BZ    GOBACK40                yes, jump\n         CH    R7,=H'4'                Severe error in BRIF or EDIF?\n         BH    GOBACK16                yes, jump\n         SLR   R7,R7                   RC=0: OK\n         B     GOBACK40\nGOBACK4  LA    R7,4                    RC=4: \"no data to browse\"\n         B     GOBACK40\n*\n*        BRIF/EDIF error: display error message\n*\nGOBACK16 LA    R7,1000(,R7)            RC=10nn: rc nn from BRIF/EDIF\n         LA    R0,L'ZERRMSG            max length\n         ST    R0,DWD                  max length\n         LINK  SF=(E,ISPLINK$),        ISPF INTERFACE                  X\n               PARAM=($VCOPY,$ZERRMSG,DWD,ZERRMSG,$MOVE),              X\n               MF=(E,PARMLIST),VL=1\n         LTR   R15,R15                 OK?\n         BNZ   GOBACK40                no, skip SETMSG\n         LINK  SF=(E,ISPLINK$),PARAM=($SETMSG,ZERRMSG),                X\n               MF=(E,PARMLIST),VL=1\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Pass return code in RC variable                              *\n*                                                                     *\n*---------------------------------------------------------------------*\nGOBACK40 EQU   *\n         LA    R0,LINE                 ADDRESS OF VALUE BUFFER\n         ST    R0,SHVVALA              ADDRESS OF VALUE BUFFER\n         CVD   R7,DWD                  convert to decimal\n         OI    DWD+7,15                convert to decimal\n         UNPK  LINE(5),DWD             convert to decimal\n         LA    R15,5                   LENGTH OF VARIABLE NAME\n         ST    R15,SHVVALL             length\n         MVC   VARNAME(2),=C'RC'       variable name\n         LA    R15,2                   LENGTH OF VARIABLE NAME\n         ST    R15,SHVNAML             LENGTH OF VARIABLE NAME\n         MVI   SHVCODE,SHVSTORE        STORE VARIABLE\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         BALR  R14,R15                 STORE VARIABLE\n         SLR   R7,R7                   RC=0\n         B     EXIT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        STEMVIEW was not invoked from a REXX exec                    *\n*        Display argument syntax using TPUT                           *\n*                                                                     *\n*---------------------------------------------------------------------*\nNOREXX   MVC   LINE(L'SYNTAXMSG),SYNTAXMSG move text to 24-bit storage\n         TPUT  LINE,L'SYNTAXMSG        display syntax\n         SLR   R7,R7                   RC=0\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CLEAN-UP AND EXIT                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\nEXIT     LR    R1,R13                  A(DYNAM)\n         L     R13,4(,R13)\n         FREEMAIN R,LV=DYNAML,A=(R1)\n         LR    R15,R7                  pass return code\n         RETURN (14,12),RC=(15)\n         DROP\n***********************************************************************\n*                                                                     *\n*        BRIF Command Routine                                         *\n*                                                                     *\n*        This routine is invoked by BRIF each time a command is       *\n*        entered on the BROWSE screen.  If the user enters the E      *\n*        or V command, then STEMVIEW reinvokes itself with VIEW       *\n*        instead of BROWSE.                                           *\n*                                                                     *\n***********************************************************************\nCMDRTNE  SAVE  (14,12),,*\n         LR    R12,R15\n         USING CMDRTNE,R12\n         LR    R14,R13                 CALLER'S SAVE AREA\n         L     R13,04(,R1)             PTR TO DIALOG DATA AREA\n         L     R13,0(,R13)             A(SAVE2)\n         ST    R14,4(,R13)             CHAIN SAVE AREAS\n         ST    R13,8(,R14)             CHAIN SAVE AREAS\n         USING SAVE2,R13\n         L     R6,00(,R1)              Function Code\n         CLC   =F'20',0(R6)            UNKNOWN COMMAND?\n         BNE   CMDRTNE4                NO, EXIT\n         LA    R0,L'LINE               max length of variable\n         ST    R0,DWD                  max length of variable\n         LINK  SF=(E,ISPLINK$),PARAM=($VCOPY,$ZCMD,DWD,LINE,$MOVE),    X\n               MF=(E,PARMLIST),VL=1\n         OC    LINE,BLANKS             upper-case\n         CLC   =C'E ',LINE             ZCMD=\"E\" ?\n         BE    CMDRTNE7                yes, do it\n         CLC   =C'V ',LINE             ZCMD=\"V\" ?\n         BE    CMDRTNE7                yes, do it\nCMDRTNE4 L     R13,4(,R13)             BRIF SAVE AREA\n         RETURN (14,12),RC=4           ISPF will process the command\n*\nCMDRTNE7 LM    R15,R1,R15R0R1          restore regs at entry\n         L     R11,EFPLARG-EFPL(,R1)   ADDR OF ARG LIST\n         LA    R2,$VIEW                service=VIEW\n         LA    R3,L'$VIEW              length\n         STM   R2,R3,0(R11)            update service name\n         BALR  R14,R15                 re-invoke myself for VIEW\n         L     R13,4(,R13)             BRIF SAVE AREA\n         RETURN (14,12),RC=0           command processed\n         DROP\n***********************************************************************\n*                                                                     *\n*        BRIF/EDIF READ Routine                                       *\n*                                                                     *\n*        This routine is invoked by BRIF and EDIF to                  *\n*        return the address of a record.                              *\n*                                                                     *\n***********************************************************************\nRDRTNE   SAVE  (14,12),,*\n         LR    R12,R15\n         USING RDRTNE,R12\n         LR    R14,R13                 CALLER'S SAVE AREA\n         L     R13,12(,R1)             PTR TO DIALOG DATA AREA\n         L     R13,0(,R13)             A(SAVE2)\n         ST    R14,4(,R13)             CHAIN SAVE AREAS\n         ST    R13,8(,R14)             CHAIN SAVE AREAS\n         USING SAVE2,R13\n         L     R6,00(,R1)              RECORD DATA READ\n         L     R7,04(,R1)              LENGTH\n         L     R4,08(,R1)              RELATIVE RECORD NUMBER\n         CLI   SERVICE,C'V'            EDIF?\n         BE    RDRTNE06                YES, JUMP\n         L     R5,0(,R4)               LINE NUMBER REQUESTED BY BRIF\n         AL    R5,CURRECNO             add first element (4th arg)\n         B     RDRTNE07\nRDRTNE06 EQU   *\n         LA    R5,1                    NEXT LINE FOR EDIT\n         AL    R5,CURRECNO             RECORD NUMBER\n         ST    R5,CURRECNO             RECORD NUMBER\nRDRTNE07 EQU   *\n*\n         LA    R10,DYNAM_SHVB\n         USING SHVBLOCK,R10\n         CL    R5,STEMCOUNT            end reached?\n         BH    RDRTN79                 yes, exit with RC=8\n*\n*        Retrieve value of current variable\n*\n         BAL   R14,FETCHVAR            retrieve stemmed variable\n         CLI   SHVRET,SHVCLEAN         OK?\n         BE    RDRTN70                 yes, pass line to BRIF\n         CLI   SHVRET,SHVTRUNC         truncated value?\n         BE    RDRTN70                 yes, pass line to BRIF\n         CLI   SHVRET,SHVNEWV          this variable exists?\n         BE    RDRTN80                 NO, EXIT\n*\n*        If IRXEXCOM fails, display R15 and SHVRET values.\n*\n         MVC   LINE(L'VARNAME),VARNAME move variable name\n         L     R1,SHVNAML              length of variable name\n         LA    R2,LINE(R1)             length of variable name\n         MVC   0(5,R2),=C' R15='       move literal\n         CVD   R15,DWD                 save return code\n         OI    DWD+7,15                convert to decimal\n         UNPK  5(3,R2),DWD             move return code: R15=008\n         MVC   8(8,R2),=C',SHVRET='    move literal\n         UNPK  16(3,R2),SHVRET(2)      hex display\n         TR    16(2,R2),HEXTAB-240     hex display\n         LA    R15,18(,R1)             data length\n         ST    R15,SHVVALL             length\n*\n*        Return value of variable\n*\nRDRTN70  L     R0,SHVVALA              DATA ADDRESS\n         L     R1,SHVVALL              DATA LENGTH\n         CLI   RECFM,C'F'              RECFM=F?\n         BNE   RDRTN74                 no, jump\n         CL    R1,LRECL                needs padding?\n         BNL   RDRTN74                 no, jump\n         LA    R14,LINE                \"to\" address\n         L     R15,LRECL               \"to\" length\n         ICM   R1,B'1000',BLANKS       padding\n         MVCL  R14,R0                  move data to LINE\n         LA    R0,LINE                 DATA ADDRESS\n         L     R1,LRECL                DATA LENGTH\nRDRTN74  EQU   *\n         ST    R0,0(,R6)               PASS DATA ADDRESS\n         ST    R1,0(,R7)               PASS DATA LENGTH\n         ST    R5,LASTLINE             CURRENT LINE NUMBER\n         L     R13,4(,R13)             BRIF SAVE AREA\n         RETURN (14,12),RC=0           GOBACK TO EDIT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Scan variables to find the highest one                       *\n*                                                                     *\n*        This section determines the number of the last line          *\n*        and passes it to BRIF along with the EOF indicator.          *\n*                                                                     *\n*---------------------------------------------------------------------*\nRDRTN79  L     R5,STEMCOUNT            eof\n         B     RDRTN81\nRDRTN80  BCTR  R5,0                    previous line\nRDRTN81  EQU   *\n         CL    R5,LASTLINE             was good?\n         BE    RDRTN88                 yes, exit\n         L     R5,LASTLINE             previous line\n*loop\nRDRTN84  LA    R5,1(,R5)               BUMP LINE NUMBER\n         BAL   R14,FETCHVAR            retrieve stemmed variable\n         CLI   SHVRET,SHVCLEAN         OK?\n         BE    RDRTN84                 yes, try next variable\n*endloop\nRDRTN87  BCTR  R5,0                    previous line\nRDRTN88  ST    R5,0(,R4)               LAST LINE\n*\n*        EDIF only: set ZVMODET='VIEW'\n*\n         CLI   SERVICE,C'V'            EDIF?\n         BNE   RDRTN89                 no, skip VDEFINE\n         LA    R1,=A($VERASE,$ZVMODET+VL)\n         LINK  SF=(E,ISPLINK$)\n         LA    R1,=A($VDEFINE,$ZVMODET,$VIEW,$CHAR,F4+VL)\n         LINK  SF=(E,ISPLINK$)\nRDRTN89  EQU   *\n         L     R13,4(,R13)             BRIF SAVE AREA\n         RETURN (14,12),RC=8           GOBACK TO BRIF (EOF)\n*\nISPLINK$ LINK  EP=ISPLINK,SF=L         ISPF INTERFACE\n$CONTROL DC    C'CONTROL '\n$ERRORS  DC    C'ERRORS  '\n$RETURN  DC    C'RETURN  '\n$DISPLAY DC    C'DISPLAY '\n$REFRESH DC    C'REFRESH '\n$VCOPY   DC    C'VCOPY   '\n$VERASE  DC    C'VERASE  '\n$SETMSG  DC    C'SETMSG  '\n$VDEFINE DC    C'VDEFINE '\n$ZERRMSG DC    C'ZERRMSG '\n$ZCMD    DC    C'ZCMD    '\n$ZVMODET DC    C'ZVMODET '\n$VIEW    DC    C'VIEW'\nF4       DC    FL4'4'\n$CHAR    DC    C'CHAR'\n$MOVE    DC    C'MOVE'\nVL       EQU   X'80000000'             END-OF-LIST FLAG\nSYNTAXMSG DC     C'Syntax: CALL STEMVIEW service<,stemname><,firstelem>X\n               <,stemcount><,title><,panel><,lrecl><,recfm><,profile>'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Fetch value of a variable                                    *\n*                                                                     *\n*        1. build variable name by concatenating the stem name        *\n*           (such as \"LINE.\") to the sequence number in R5            *\n*        2. pass control to IRXEXCOM                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\nFETCHVAR LM    R2,R3,STEMNAME          2ND ARG (VAR NAME)\n         LTR   R3,R3                   variable name specified?\n         BNP   FETCHV50                no, PULL from stack\n         LA    R0,VARNAME              \"to\" addr\n         LR    R1,R3                   \"to\" length\n         MVCL  R0,R2                   move stem name \"LINE.\"\n         CVD   R5,DWD                  seqno\n         MVC   LINE(8),=X'4020202020202020'\n         EDMK  LINE(8),DWD+4           unpack 7 digits\n         LR    R2,R1                   addr of 1st non-zero byte\n         LA    R3,LINE+8               calc length\n         SLR   R3,R2                   calc length\n         LR    R1,R3                   \"to\" length\n         MVCL  R0,R2                   move seq number\n         LA    R1,VARNAME              \"to\" addr\n         SLR   R0,R1                   calc length of variable name\n         ST    R0,SHVNAML              LENGTH OF VARIABLE NAME\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         BR    R15                     FETCH VARIABLE\n*\n*        PULL an element from the data stack\n*\nFETCHV50 LR    R2,R14                  save return address\n         L     R15,ADDR_OF_ENVBLOCK    Environment block\n         L     R15,ENVBLOCK_IRXEXTE-ENVBLOCK(,R15) A(IRXEXTE)\n         L     R15,IRXSTK-IRXEXTE(,R15) STACK MANAGER\n         LA    R1,IRXSTK_PARM          PARM LIST\n         BALR  R14,R15              <- CALL IRXSTK\n         LTR   R15,R15                 EOF yet?\n         BZR   R2                      no, goback\n         MVI   SHVRET,SHVNEWV          yes, simulate EOF\n         BR    R2                      and goback\n         DROP\nHEXTAB   DC    C'0123456789ABCDEF'\n*---------------------------------------------------------------------*\n*        Dummy write routine for EDIF                                 *\n*---------------------------------------------------------------------*\nWRITERTN LA    R15,16                  OUTPUT ERROR\n         BR    R14                     GOBACK\n***********************************************************************\n*                                                                     *\n*        Dynamic Storage Area                                         *\n*                                                                     *\n***********************************************************************\nDYNAM    DSECT\n         DS    18F                     MAIN-LINE\nPANEL_NAME DS  C'ISRBROBF'             PANEL (6th arg)\nTITLE    DS    CL54                    Title\n*\nSAVE2    DS    18F                     READ ROUTINE\nDWD      DS    D                       work area\nR15R0R1  DS    A(R15,R0,R1)            regs at entry to STEMVIEW\nADDR_OF_ENVBLOCK EQU R15R0R1+4,4,C'A'  ENVIRONMENT BLOCK\nSERVICE  DS    C'BROWSE'               ISPF Service (\"B\" or \"V\")\nRECFM    DS    C'V '                   record format\nPROFILE_NAME DS CL8'TEXT'              profile name for EDIF\nSTEMNAME DS    A,F                     ADDR/LEN OF STEM NAME\nCURRECNO DS    F                       first element (3rd parm)\nSTEMCOUNT DS   F                       number of variables (4th parm)\nLASTLINE DS    F                       last line number\nLRECL    DS    F                       record length (7th arg)\nPARMLIST DS    12F                     EDIF/BRIF\nIRXEXCOM_REGS DS A(R15,R0,R1)          IRXEXCOM\nIRXEXCOM_PARM DS 4A                    IRXEXCOM\nIRXSTK_PARM DS 6A                      IRXSTK\nDYNAM_SHVB DS  XL(SHVBLEN)             SHVB (IRXEXCOM)\nRETCODE  DS    F                       RETURN CODE\nVALUE    DS    F                       VALUE RETURNED BY FUNCTION\nZERRMSG  DS    CL8                     error message\nVARNAME  DS    CL80                    variable name\nLINE     DS    CL255\nBLANKS   DS    CL256                   a bunch of blanks\nDYNAML   EQU   *-DYNAM\n         PRINT NOGEN\n         IRXEFPL DSECT=YES             External Function Parm List\n         IRXENVB                       Environment Block\n         IRXEXTE                       External Function Entry Points\n         IRXSHVB                       Shared REXX Variable Req Block\n         YREGS                         Register Equates (R0-R15)\n         END\n***********************************************************************\n*                                                                     *\n* MODULE NAME = ENDVIEW\n*                                                                     *\n* DESCRIPTIVE NAME = Prompt user at the end of a VIEW session.        *\n*                                                                     *\n* STATUS = R100                                                       *\n*                                                                     *\n* FUNCTION = This assembler sub-routine can be invoked from a         *\n*            program that uses EDIF to view data.  If the data        *\n*            has been modified, ENDVIEW automatically prompts         *\n*            the user when END or RETURN commands are issued.         *\n*            ENDVIEW also displays a prompt panel when the user       *\n*            issues the SAVE command.                                 *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*    DEPENDENCIES = ISPF V4                                           *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (CSECT TYPE)                               *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 1K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE ANY, AMODE 31,                   *\n*                 PROBLEM STATE, KEY 8                                *\n*                 APF AUTHORIZATION: NONE                             *\n*                                                                     *\n* SYNTAX  =  See below                                                *\n*                                                                     *\n*        CALL  ENDVIEW            install ENDVIEW                     *\n*        MVC   IMACRO,0(R1)       save name of Initial Macro for EDIF *\n*                                                                     *\n***********************************************************************\nENDVIEW  CSECT\nENDVIEW  RMODE ANY\n         SAVE  (14,12),,*\n         LR    R12,R15\n         USING ENDVIEW,R12\n         L     R0,ISPLINK$             =CL8'ISPLINK'\n         LOAD  EPLOC=(0)               preload ISPLINK\n         IDENTIFY EP=$IMACRO,ENTRY=IMACRO Initial Macro\n         IDENTIFY EP=$ENDMAC,ENTRY=ENDMAC END/RETURN\n         IDENTIFY EP=$SAVEMAC,ENTRY=SAVEMAC SAVE\n         LA    R1,=CL8'!$IMACRO'       name of IMACRO\n         SAVE  (1)                     return it to caller\n         RETURN (14,12),RC=0\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Initial EDIT Macro for EDIF                                  *\n*                                                                     *\n*          \"ISREDIT MACRO\"                                            *\n*          \"ISREDIT RESET\"                                            *\n*          \"ISREDIT DEFINE $ENDMAC MACRO PGM\"                         *\n*          \"ISREDIT DEFINE END ALIAS $ENDMAC\"                         *\n*          \"ISREDIT DEFINE $SAVEMAC MACRO PGM\"                        *\n*          \"ISREDIT DEFINE SAVE ALIAS $SAVEMAC\"                       *\n*                                                                     *\n*---------------------------------------------------------------------*\nIMACRO   BAKR  R14,0\n         LR    R12,R15\n         USING IMACRO,R12\n*\n         LA    R1,=A($ISREDIT,F8,$MACRO+VL)\n         LINK  SF=(E,ISPLINK$)       ISREDIT MACRO\n*\n         LA    R1,=A($ISREDIT,F8,$RESET+VL)\n         LINK  SF=(E,ISPLINK$)       ISREDIT RESET\n*\n         LA    R1,=A($ISREDIT,F28,DEFINE1+VL)\n         LINK  SF=(E,ISPLINK$)       ISREDIT DEFINE $ENDMAC MACRO PGM\n*\n         LA    R1,=A($ISREDIT,F28,DEFINE2+VL)\n         LINK  SF=(E,ISPLINK$)       ISREDIT DEFINE END ALIAS $ENDMAC\n*\n         LA    R1,=A($ISREDIT,F28,DEFINE3+VL)\n         LINK  SF=(E,ISPLINK$)       ISREDIT DEFINE $SAVEMAC MACRO PGM\n*\n         LA    R1,=A($ISREDIT,F28,DEFINE4+VL)\n         LINK  SF=(E,ISPLINK$)       ISREDIT DEFINE SAVE ALIAS $SAVEMAC\n         PR\nDEFINE1  DC    CL28'DEFINE $ENDMAC MACRO PGM'\nDEFINE2  DC    CL28'DEFINE END    ALIAS $ENDMAC'\nDEFINE3  DC    CL28'DEFINE $SAVEMAC MACRO PGM'\nDEFINE4  DC    CL28'DEFINE SAVE   ALIAS $SAVEMAC'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        SAVE EDIT Macro                                              *\n*                                                                     *\n*          \"ISREDIT MACRO\"                                            *\n*          \"CONTROL ERRORS RETURN\"                                    *\n*          \"ADDPOP\"                                                   *\n*          \"DISPLAY PANEL(ISREVQST)\"                                  *\n*           EXIT                                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\nSAVEMAC  BAKR  R14,0\n         LR    R12,R15\n         USING SAVEMAC,R12\n*\n         LA    R1,=A($ISREDIT,F8,$MACRO+VL)\n         LINK  SF=(E,ISPLINK$)         ISREDIT MACRO\n*\n         LA    R1,=A($CONTROL,$ERRORS,$RETURN+VL)\n         LINK  SF=(E,ISPLINK$)         CONTROL ERRORS RETURN\n*\n         LA    R1,=A($ADDPOP+VL)\n         LINK  SF=(E,ISPLINK$)         ISPEXEC ADDPOP\n*\n         LINK  SF=(E,ISPLINK$),        ISPEXEC DISPLAY PANEL(ISREVQST) X\n               PARAM=($DISPLAY,ISREVQST),VL=1\n         PR\n*---------------------------------------------------------------------*\n*                                                                     *\n*        END/RETURN EDIT Macro                                        *\n*                                                                     *\n*          \"ISREDIT MACRO\"                                            *\n*          \"ISREDIT (DC) = DATA_CHANGED\"                              *\n*          IF DC='NO' THEN                                            *\n*            \"ISREDIT CANCEL\"                                         *\n*          ELSE DO                                                    *\n*            \"CONTROL ERRORS RETURN\"                                  *\n*            \"ADDPOP\"                                                 *\n*            \"DISPLAY PANEL(ISREVIEW)\"                                *\n*            IF RC=0 THEN                                             *\n*              \"ISREDIT CANCEL\"                                       *\n*            END                                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\nENDMAC   BAKR  R14,0\n         LR    R12,R15\n         USING ENDMAC,R12\n         GETMAIN R,LV=DYNAML           allocate dynamic storage\n         LR    R13,R1                  A(DYNAM)\n         USING DYNAM,R13\n*\n         LA    R1,=A($ISREDIT,F8,$MACRO+VL)\n         LINK  SF=(E,ISPLINK$)         ISREDIT MACRO\n*\n         LINK  SF=(E,ISPLINK$),        VDEFINE (DC)                    X\n               PARAM=($VDEFINE,DATA_CHANGED,DWD,$CHAR,F8),VL=1,        X\n               MF=(E,PARMLIST)\n*\n         LA    R1,=A($ISREDIT,F20,DATA_CHANGED+VL)\n         LINK  SF=(E,ISPLINK$)         ISREDIT (DC) = DATA_CHANGED\n         LTR   R7,R15                  save return code\n         CLI   DWD,C'N'                DATA_CHANGED ?\n         BE    ENDMAC8                 no, issue ISREDIT CANCEL\n*\n         LA    R1,=A($CONTROL,$ERRORS,$RETURN+VL)\n         LINK  SF=(E,ISPLINK$)         CONTROL ERRORS RETURN\n*\n         LA    R1,=A($ADDPOP+VL)\n         LINK  SF=(E,ISPLINK$)         ISPEXEC ADDPOP\n*\n         LINK  SF=(E,ISPLINK$),        ISPEXEC DISPLAY PANEL(ISREVIEW) X\n               PARAM=($DISPLAY,ISREVIEW),VL=1\n         LTR   R7,R15                  user pressed ENTER?\n         BZ    ENDMAC8                 yes, issue ISREDIT CANCEL\n         CH    R15,=H'12'              panel not found (ISPF V3) ?\n         BNE   ENDMAC9                 no, go back to VIEW\n*\nENDMAC8  LA    R1,=A($ISREDIT,F8,$CANCEL+VL)\n         LINK  SF=(E,ISPLINK$)         ISREDIT CANCEL\n*\nENDMAC9  FREEMAIN R,LV=DYNAML,A=(R13)  free dynamic storage\n         LR    R15,R7                  rc from DISPLAY service\n         PR\nDATA_CHANGED DC CL20'(DC) = DATA_CHANGED'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Constants                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\nISPLINK$ LINK  EP=ISPLINK,SF=L         ISPF INTERFACE\nF8       DC    F'8'\nF20      DC    F'20'\nF28      DC    F'28'\n$ISREDIT DC    C'ISREDIT '\n$MACRO   DC    C'MACRO   '\n$RESET   DC    C'RESET   '\n$CANCEL  DC    C'CANCEL  '\n$CONTROL DC    C'CONTROL '             FUNCTION\n$ERRORS  DC    C'ERRORS  '             OPTION\n$RETURN  DC    C'RETURN  '             OPTION\n$ADDPOP  DC    C'ADDPOP  '\n$VDEFINE DC    C'VDEFINE '\n$DISPLAY DC    C'DISPLAY '\nISREVIEW DC    C'ISREVIEW'             PANEL FOR END/RETURN\nISREVQST DC    C'ISREVQST'             PANEL FOR SAVE\n$CHAR    DC    C'CHAR'\nVL       EQU   X'80000000'             END-OF-LIST FLAG\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Dynamic Storage Area                                         *\n*                                                                     *\n*---------------------------------------------------------------------*\nDYNAM    DSECT\n         DS    18F                     MAIN-LINE\nDWD      DS    D                       work area\nPARMLIST DS    12F                     EDIF/BRIF\nDYNAML   EQU   *-DYNAM\n         YREGS\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//LKED    EXEC PGM=HEWLKED,PARM='MAP,RENT'\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=CBTTAPE.FILE183.LOAD(STEMVIEW),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STRING": {"ttr": 18952, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x12\\x00\\x01\\x00\\x89\\x00\\x9f\\x01\\x10\\t\\x7f\\x16R\\x05w\\x00\\x19\\x02\\xc6\\xc3\\xc2\\xe3\\xf4\\xf8\\xf3@@@@'", "ispf": {"version": "05.18", "flags": 0, "createdate": "1989-01-09T00:00:00", "modifydate": "2010-04-07T16:52:01", "lines": 1399, "newlines": 25, "modlines": 710, "user": "CBT483"}, "text": "*/GILBERTS JOB (ACCT#),STRING-MACRO,\n*/ NOTIFY=&SYSUID,\n*/ CLASS=A,MSGCLASS=H,COND=(0,NE)\n*/HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF,\n*/*FLAG(PAGE0),NORXREF,NODXREF,                   HLASM R3\n*/ NOBATCH)\n***********************************************************************\n*                                                                     *\n*            COPYRIGHT (C) 1989-2010 GILBERT SAINT-FLOUR              *\n*                       ALL RIGHTS RESERVED                           *\n*                                                                     *\n* MACRO NAME = STRING                                                 *\n*                                                                     *\n* DESCRIPTIVE NAME = STRING Macro Instruction.                        *\n*                                                                     *\n* FUNCTION = Provide capabilities similar to PUT EDIT (of PL/I)       *\n*            or STRING (of COBOL) to assembler programs.              *\n*                                                                     *\n* STATUS = R518                                                       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*          http://gsf-soft.com/Freeware/STRING.shtml                  *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*     AMODE = ANY                                                     *\n*     RMODE = ANY                                                     *\n*     SCP   = OS/360, OS/VS, MVS/370, MVS/XA, MVS/ESA, OS/390 or z/OS *\n*     KEY   = ANY                                                     *\n*     MODE  = ANY                                                     *\n*     APF   = ANY                                                     *\n*                                                                     *\n* Processor = Assembler H, High-Level Assembler                       *\n*                                                                     *\n* OPERATION = SEE DOCUMENTATION AT THE END OF THIS FILE               *\n*                                                                     *\n* INVOCATION = SEE DOCUMENTATION AT THE END OF THIS FILE              *\n*                                                                     *\n* NOTES = SEE DOCUMENTATION AT THE END OF THIS FILE                   *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n*200 Build STRING macro based on $PUNCH,$FIELD,@PRTPUN            1989*\n*300 @STRING always runs with AMODE31                             1992*\n*    Make slight modifications to the SCON2A routine                  *\n*    Length used in output field returned in R15                      *\n*    @JDATE routine integrated into @STRING CSECT                     *\n*301 FIX BUGS WITH (XYZ,,L8) AND INTO=((R1),(R2))                 1993*\n*302 GENERATE $DEBUG BOOT-STRAP IN FINAL_CALL INVOCATION              *\n*303 REPLACE @STRPAD WITH @STRBLANKS                              1994*\n*304 USE @00-@15 INSTEAD OF R0-R15 FOR REGISTER EQUATES               *\n*306 TAILOR @STRING CSECT TO PROGRAM'S REQUIREMENTS                   *\n*    LITERALS CAN BE CODED AS 'ABC' OR C'ABC' OR X'C1C2C3'            *\n*    USE L'PSATOLD AS IMPLICIT LENGTH FOR (PSATOLD-PSA,,X)            *\n*307 \"FINAL_CALL\" OPTION CHANGED TO \"GENERATE\"                        *\n*    ADD NOCSECT AND LOCTR OPTIONS TO \"GENERATE\" CALL                 *\n*308 USE L'RBCDE AS IMPLICIT LENGTH FOR (PRB.RBCDE,,X)                *\n*    PREVENT S0C4 WHEN ADDR IS BAD AND LENGTH IS ZERO                 *\n*400 Reorg the code to simplify feature selection                 1995*\n*    BLANKS no longer used or generated                               *\n*401 Generate @STRHEXT when ((REG),,X) only hex field                 *\n*502 @STRING Routine rewritten for MVS/ESA:                       1996*\n*    . Use linkage stack to store caller's registers                  *\n*    . Add support for AR Mode                                        *\n*    . @STRING now executes in caller's AMODE                         *\n*    . Rename previous version to STRINGXA                            *\n*503 Date Conversion to YYYY-MM-DD Format (ISO Standard)              *\n*    Improve Support for AR mode                                      *\n*504 Set &STRBLANKS to 10 when processing dates                   1997*\n*505 Allow for 128K-offset                                        1998*\n*506 Remove literal from BAL instruction for HLASM R3             1999*\n*507 Merge STRINGXA code, add AR_MODE option                      2000*\n*    Change syntax of GENERATE call                                   *\n*508 Compatibility with FLAG(PAGE0) in HLASM R3                       *\n*    Compatibility with pre-XA version of the SAVE macro              *\n*    Remove AMODE-based R2 cleanup in 370 mode                        *\n*509 Hex string can contain commas, e.g. X'12,3456,7890'          2001*\n*    Length of parm-list entries can vary between 2 and 6 bytes       *\n*    Short literals (up to 5 bytes) are generated in parm list        *\n*510 JDATE=90366 produces 90/13/01 instead of S0C7                2002*\n*511 Prevent ACTR error with long literals                        2003*\n*512 Packed fields no longer ignored when R0=0                        *\n*513 Local base not needed for (GENERATE,,LOCTR)                  2004*\n*514 '&&'(1,1) at .LIT11C                                         2005*\n*515 Negative Value: -12345678 (Tim Alpaerts)                     2007*\n*516 STRING may be present in multiple CSECTs in same assembly    2009*\n*    One of the CSECTs that use STRING may have no name               *\n*517 Fix addressability error in CSECT23/CSECT28 reported by IBM/AU   *\n*518 %TIME hh:mm:ss.hh instead of hh:mm:ss:hh                     2010*\n*    (%TIME,5) or (%TIME,8) or (%TIME,11) or (%TIME,12)               *\n*    Fix bug near GENL2D reported by IBM/AU                           *\n*                                                                     *\n***********************************************************************\n         MACRO\n&NAME    STRING &INTO=,&PRINT=NOGEN,&STRING_MACRO_VERSION=518\n         AIF   ('&PRINT' EQ 'NOGEN').NOGEN\n         PUSH  PRINT\n         PRINT GEN\n.NOGEN   GBLA  &$_LIT\n         GBLA  &$_CSECT_NO             Number of CSECTs\n         GBLB  &$_FEAT(16)             FEATURES\n.*                                       1 LITERALS\n.*                                       2 REGISTER (BIN)\n.*                                       3 REGISTER (HEX)\n.*                                       4 PACKED\n.*                                       5 JDATE\n.*                                       6 BINARY\n.*                                       7 HEX\n.*                                       8 NUMERIC\n.*                                       9 LEFT JUST (NUMERIC)\n.*                                       10 LEADING ZEROES\n.*                                       11 TRUNCATE (CHAR STRING)\n.*                                       12 %TIME\n         GBLC  &$_LITS(9999)           LITERALS\n         GBLC  &$_CSECT(99)            CSECTs\n         GBLC  &$_LITS_CSECT(9999)     CSECT OF LITERALS\n         LCLA  &I,&J,&L,&N,&FLAG,&LEN2,&STRBLANKS\n         LCLB  &LAST,&BIN,&HEX,&REG,&PACKED,&LEFT,&ZERO,&TRUNC,&NUMERIC\n         LCLC  &LABEL,&LQ,&STR,&TO1,&TO2,&P1S,&P2C,&P2L,&P3C,&P3L\n         LCLC  &LIT,&ALLFEAT,&OPT2,&OPT3\n         LCLC  &LOCTR1,&SYSECT2\n.* MNOTE *,'CSECT_NO=&$_CSECT_NO CSECT1=&$_CSECT(1) CSECT2=&$_CSECT(2) X\n               CSECT3=&$_CSECT(3) .'\n         AIF   (T'&INTO EQ 'O' AND N'&SYSLIST EQ 1                     X\n               AND '&SYSLIST(1,1)' EQ 'GENERATE').GENL\n&LABEL   SETC  'IHB&SYSNDX'            STEM FOR LOCAL LABELS\n&LQ      SETC  'L'''                   LENGTH ATTRIBUTE\n&STR     SETC  '  R&STRING_MACRO_VERSION'\n.*MNOTE ' &$_CSECT_NO &$_CSECT(&$_CSECT_NO) .'\n&SYSECT2 SETC  '&SYSECT'\n         AIF   ('&SYSECT' NE '').CSECT21\n&SYSECT2 SETC  'NO_NAME'\n.CSECT21 ANOP\n         AIF   (&$_CSECT_NO GT 0).CSECT22\n&$_CSECT_NO SETA 1\n&$_CSECT(1) SETC '&SYSECT2'\n.CSECT22 ANOP\n&I       SETA  1\n.*loop\n.CSECT23 ANOP\n         AIF   ('&$_CSECT(&I)' EQ '&SYSECT2').CSECT27\n&I       SETA  1+&I\n         AIF   (&I LE &$_CSECT_NO).CSECT23\n.*endloop\n&$_CSECT_NO SETA &I\n&$_CSECT(&I) SETC '&SYSECT2'\n.*MNOTE ' &$_CSECT_NO &$_CSECT(&I) .'\n.CSECT27 ANOP                                         <=== New line\n         AIF   (&I EQ 1).CSECT28                      <=== New line\n.**      AIF   ('&SYSECT' EQ '&$_CSECT(&I)').CSECT28\n&STR     SETC  '_'.'&SYSECT2'          $STRING_CSECT2\n.CSECT28 ANOP\n&NAME    BAS   R14,$STRING&STR         CALL @STRING SUB-ROUTINE\n         AIF   (N'&SYSLIST EQ 0).ERR1  NO POSITIONAL OPERANDS, ERROR\n         AIF   (T'&INTO EQ 'O').ERR2   NO RECEIVING FIELD, ERROR\n         AIF   (N'&INTO GT 2).ERR2     INTO=(A,32,BLURB)\n         DC    AL2((&LABEL.P-*)/2)     OFFSET TO FIELD DESCRIPTORS\n&LOCTR1  SETC  '&SYSLOC'\n         AIF   ('&SYSLOC' NE '').LOCTR1X\n&LOCTR1  SETC  'LOCTR_'.'NO_NAME'\n&LOCTR1  LOCTR                         IN-LINE CODE IN FIRST CSECT\n.*MNOTE 1,'LOCTR1=&LOCTR1'\n.LOCTR1X ANOP\n         AIF   (D'$LITERAL).LOCTR2     NOT FIRST TIME, JUMP\n$LTORG   LOCTR                         ADDRESSABLE CONSTANTS\n$FARRTNE LOCTR                         FAR ROUTINES\n.LOCTR2  AIF   ('&SYSECT2' NE '&$_CSECT(1)').LOCTR3\n$LITERAL LOCTR                         NON-ADDRESSABLE CONSTANTS\n.LOCTR3  AIF   ('&SYSECT2' EQ '&$_CSECT(1)').LOCTR5\n&STR     SETC  '$LTORG_&$_CSECT(&I)'\n         AIF   (D'&STR).LOCTR4         NOT FIRST TIME, JUMP\n&STR     LOCTR                         ADDRESSABLE CONSTANTS\n&STR     SETC  '$FARRTNE_&$_CSECT(&I)'\n&STR     LOCTR                         FAR ROUTINES\n.LOCTR4  ANOP\n&STR     SETC  '$LITERAL_&$_CSECT(&I)'\n&STR     LOCTR                         NON-ADDRESSABLE CONSTANTS\n.LOCTR5  ANOP\n.*once   DS    0H\n&TO1     SETC  '&INTO(1)'\n&TO2     SETC  '&LQ&INTO'\n         AIF   (N'&INTO EQ 1).PUNTO8            JUMP IF INTO=XXX\n         AIF   ('&INTO(1)'(1,1) NE '(').PUNTO3  JUMP IF INTO=(XXX,44)\n&TO1     SETC  '0&INTO(1)'                              INTO=((R3),44)\n.PUNTO3  ANOP\n&TO2     SETC  '&INTO(2)'                               INTO=(XXX,LL)\n         AIF   ('&INTO(2)'(1,1) NE '(').PUNTO8  JUMP IF INTO=(XXX,44)\n&TO2     SETC  '0&INTO(2)'                              INTO=(XXX,(R1))\n.PUNTO8  ANOP\n&LABEL.P DC    S(&TO1,&TO2)\n.*--------------------------------------------------------------------*\n.*-------      FIELDS       ------------------------------------------*\n.*--------------------------------------------------------------------*\n&I       SETA  1\n.*LOOP\n.LOOP1   ANOP\n         ACTR  200                            SYSDEBUG/DIAG055\n         AIF   (N'&SYSLIST(&I) GT 3).FLD990   TOO MANY SUB-OPERANDS\n&LAST    SETB  (&I EQ N'&SYSLIST)                LOOP\n         AIF   ('&SYSLIST(&I)'(1,1) EQ '''').LIT00\n         AIF   ('&SYSLIST(&I)'(K'&SYSLIST(&I),1) EQ '''').LIT01\n.*--------------------------------------------------------------------*\n.*       PROCESS FIRST SUBPARAMETER (ADDRESS)                         *\n.*--------------------------------------------------------------------*\n&P1S     SETC  '&SYSLIST(&I,1)'\n&P2L     SETC  '0'                     INPUT LENGTH\n&P3L     SETC  '0'                     OUTPUT LENGTH\n         AIF   ('&SYSLIST(&I)'(1,1) GE '0').FLD180 SPACES\n         AIF   ('&SYSLIST(&I,1)' EQ '%TIME').FLD190 %TIME\n         AIF   ('&SYSLIST(&I,1)'(1,1) NE '(').FLD115 (R2)\n         AIF   (T'&SYSLIST(&I,2) EQ 'O').FLD250\n&P1S     SETC  '0&SYSLIST(&I,1)'       CHANGE (R1) TO 0(R1)\n.FLD115  ANOP\n.*\n         AIF   (T'&SYSLIST(&I,2) NE 'O').FLD200\n.*\n.*       EXTRACT RBCDE FROM PRB.RBCDE (HLASM)\n.*\n&L       SETA  1\n.*--LOOP\n.FLD131  AIF   ('&P1S'(&L,1) EQ '.').FLD133\n&L       SETA  &L+1\n         AIF   (&L LT K'&P1S).FLD131\n.*--ENDLOOP\n&P2L     SETC  '&P1S'                    ABCDEF FROM ABCDEF\n         AGO   .FLD134\n.FLD133  ANOP\n&P2L     SETC  '&P1S'(&L+1,K'&P1S-&L)    RBCDE FROM PRB.RBCDE\n.FLD134  ANOP\n.*\n         AIF   (NOT D'&P2L).FLD140\n&P2C     SETC  T'&P2L\n.*MNOTE *,'&P1 &P2C'\n         AIF   ('&P2C' EQ 'F' OR '&P2C' EQ 'H' OR '&P2C' EQ 'P').FLD220\n         AIF   ('&P2C' EQ 'G').FLD210  FL2\n.FLD140  ANOP\n.*\n.*       EXTRACT PSATOLD FROM PSATOLD-PSA\n.*\n&L       SETA  1\n.*--LOOP\n.FLD141  AIF   ('&P2L'(&L,1) EQ '-').FLD143\n         AIF   ('&P2L'(&L,1) EQ '+').FLD143\n&L       SETA  &L+1\n         AIF   (&L LT K'&P2L).FLD141\n.*--ENDLOOP\n&P2L     SETC  '&LQ&P2L'               L'ABCDEF\n         AGO   .FLD300\n.FLD143  ANOP\n&P2L     SETC  '&LQ'.'&P2L'(1,&L-1)    L'PSATOLD FROM PSATOLD-PSA\n         AGO   .FLD300\n.*\n.FLD180  AIF   ('&SYSLIST(&I)'(K'&SYSLIST(&I),1) NE 'X').FLD800\n&P2L     SETC  '&SYSLIST(&I)'(1,K'&SYSLIST(&I)-1) 12\n         AIF   (&LAST).FLD186\n         DC    X'60',AL1(&P2L)         BLANKS\n         AGO   .LIT90\n.FLD186  DC    X'E0',AL1(&P2L),0S(0)   BLANKS\n         AGO   .LIT90\n.*\n.FLD190  AIF   (N'&SYSLIST(&I) GT 2).FLD992\n&P1S     SETC  '1(14)'                 %TIME\n&$_FEAT(12) SETB 1                     %TIME\n&P2L     SETC  '12'                    hh:mm:ss.hh\n         AIF   (N'&SYSLIST(&I) EQ 1).FLD1905\n         AIF   (T'&SYSLIST(&I,2) NE 'N').FLD1904\n&P2L     SETC  '&SYSLIST(&I,2)'        5,8,11,12\n&L       SETA  &SYSLIST(&I,2)\n         AIF   (&L EQ 5 OR &L EQ 8 OR &L EQ 11 OR &L EQ 12).FLD1905\n.FLD1904 MNOTE 8,'Second sub-parameter is invalid: &SYSLIST(&I)'\n.FLD1905 ANOP\n.*MNOTE 1,'FLD1905 &SYSLIST(&I) &P1S &P2L '\n         AGO   .FLD800\n.*--------------------------------------------------------------------*\n.*       PROCESS SECOND SUBPARAMETER (LENGTH/TYPE)                    *\n.*--------------------------------------------------------------------*\n.FLD200  AIF   (T'&SYSLIST(&I,2) EQ 'O').FLD300 NO LENGTH SPECIFIED\n&P2C     SETC  '&SYSLIST(&I,2)'\n         AGO   .FLD220\n.*T'&P1=G\n.FLD210  ANOP\n&L       SETA  L'&SYSLIST(&I)          T'&P1 = 'G'\n&P2C     SETC  'FL&L'                  T'&P1 = 'G'\n.*\n.FLD220  ANOP\n&P2L     SETC  '0&P2C'                 (R2) LENGTH\n         AIF   ('&P2C'(1,1) EQ '(').FLD300\n&P2L     SETC  '&P2C'                  3(R2) LENGTH\n         AIF   ('&P2C'(K'&P2C,1) EQ ')').FLD300\n&P2L     SETC  '0'\n&PACKED  SETB  ('&P2C' EQ 'P')\n         AIF   (&PACKED).FLD290\n&P2L     SETC  '1'\n         AIF   ('&P2C' EQ 'FL1').FLD240\n&P2L     SETC  '3'\n         AIF   ('&P2C' EQ 'FL2' OR '&P2C' EQ 'H').FLD240\n&P2L     SETC  '7'\n         AIF   ('&P2C' EQ 'FL3').FLD240\n&P2L     SETC  '15'\n         AIF   ('&P2C' EQ 'F').FLD240\n&P2L     SETC  '&P2C'                  IMMEDIATE LENGTH, FIELD\n         AGO   .FLD300\n.*\n.FLD240  ANOP                          BINARY VARIABLE\n&BIN     SETB  1\n         AGO   .FLD300\n.*\n.FLD250  ANOP                          REGISTER CONTENT\n&REG     SETB  1\n         AGO   .FLD300\n.*\n.FLD290  ANOP                          PACKED\n&P2L     SETC  '1'\n.*--------------------------------------------------------------------*\n.*       PROCESS THIRD SUBPARAMETER (OUTPUT FORMAT)                   *\n.*--------------------------------------------------------------------*\n.FLD300  AIF   (T'&SYSLIST(&I,3) EQ 'O').FLD800\n&HEX     SETB  ('&SYSLIST(&I,3)' EQ 'X') HEXADECIMAL\n&TRUNC   SETB  ('&SYSLIST(&I,3)' EQ 'T') TRUNCATE\n         AIF   (&HEX OR &TRUNC).FLD800\n.*\n&P3C     SETC  '&SYSLIST(&I,3)'\n&P3L     SETC  '248'\n         AIF   ('&P3C' EQ 'YYYY-MM-DD' AND &PACKED).FLD308\n&P3L     SETC  '249'\n         AIF   ('&P3C' EQ 'YYYYMMDD' AND &PACKED).FLD308\n&P3L     SETC  '250'\n         AIF   ('&P3C' EQ 'YY/MM/DD' AND &PACKED).FLD308\n&P3L     SETC  '251'\n         AIF   ('&P3C' EQ 'DD/MM/YY' AND &PACKED).FLD308\n&P3L     SETC  '252'\n         AIF   ('&P3C' EQ 'MM/DD/YY' AND &PACKED).FLD308\n&P3L     SETC  '253'\n         AIF   ('&P3C' EQ 'YYMMDD'   AND &PACKED).FLD308\n&P3L     SETC  '0'\n         AIF   (T'&SYSLIST(&I,2) NE 'N').FLD310\n         MNOTE 8,'EDIT PATTERN NOT ALLOWED WITH CHARACTER STRING'\n         AGO   .FLD310\n.FLD308  ANOP\n&$_FEAT(5) SETB 1                      JDATE\n         AGO   .FLD800\n.*--LOOP\n.FLD310  AIF   ('&P3C'(1,1) EQ 'R').FLD318       DEFAULT\n         AIF   ('&P3C'(1,1) EQ 'B').FLD318       DEFAULT\n         AIF   ('&P3C'(1,1) NE 'L').FLD311\n&LEFT    SETB  1\n         AGO   .FLD318\n.FLD311  AIF   ('&P3C'(1,1) NE 'Z').FLD312\n&ZERO    SETB  1\n         AGO   .FLD318\n.FLD312  AIF   ('&P3C'(1,1) LT '0').FLD993       nn in RnnB is not num\n         AIF   ('&P3C'(1,1) GT '9').FLD993       nn in RnnB is not num\n&P3L     SETC  '&P3L'.'&P3C'(1,1)\n.FLD318  ANOP\n.*MNOTE *,'&SYSLIST(&I) P3C=/&P3C/ P3L=/&P3L/'\n&P3C     SETC  '&P3C '(2,K'&P3C-1)     STRIP OFF FIRST CHARACTER\n         AIF   (K'&P3C GT 0).FLD310\n.*--ENDLOOP\n         AIF   (&P3L GT 16).FLD993               nn in RnnB is too big\n.*--------------------------------------------------------------------*\n.FLD800  ANOP\n&NUMERIC SETB  (&BIN OR &PACKED OR (&REG AND NOT &HEX))\n&TRUNC   SETB  (&TRUNC OR (&LEFT AND NOT &NUMERIC))\n&LEFT    SETB  (&LEFT AND &NUMERIC)\n         AIF   (NOT &NUMERIC).FLD810\n         AIF   (&LEFT OR '&P3L' NE '0').FLD810\n&P3L     SETC  '7'                     DEFAULT OUTPUT LENGTH ((R3))\n         AIF   (&REG).FLD810\n&P3L     SETC  '3'                     DEFAULT OUTPUT LENGTH\n         AIF   ('&P2C' EQ 'FL1').FLD810\n&P3L     SETC  '5'                     DEFAULT OUTPUT LENGTH\n         AIF   ('&P2C' EQ 'H' OR '&P2C' EQ 'FL2').FLD810\n&P3L     SETC  '7'                     DEFAULT OUTPUT LENGTH\n.FLD810  ANOP\n&FLAG    SETA  &HEX*8+&BIN*4+&PACKED*2+&REG*1\n&LEN2    SETA  &TRUNC*128+&LEFT*128+&ZERO*64+&P3L\n&$_FEAT(2) SETB (&$_FEAT(2) OR (&REG AND NOT &HEX))   REGISTER (BIN)\n&$_FEAT(3) SETB (&$_FEAT(3) OR (&REG AND &HEX))       REGISTER (HEX)\n&$_FEAT(4) SETB (&$_FEAT(4) OR &PACKED)               PACKED\n&$_FEAT(6) SETB (&$_FEAT(6) OR &BIN)                  BINARY\n&$_FEAT(7) SETB (&$_FEAT(7) OR (&HEX AND NOT &REG))   HEX\n&$_FEAT(8) SETB (&$_FEAT(8) OR &NUMERIC)              BIN,PACKED\n&$_FEAT(9) SETB (&$_FEAT(9) OR (&LEFT AND &NUMERIC))\n&$_FEAT(10) SETB (&$_FEAT(10) OR &ZERO)\n&$_FEAT(11) SETB (&$_FEAT(11) OR &TRUNC)\n&BIN     SETB  0                    RESET FLAGS\n&HEX     SETB  0                    RESET FLAGS\n&REG     SETB  0                    RESET FLAGS\n&PACKED  SETB  0                    RESET FLAGS\n&LEFT    SETB  0                    RESET FLAGS\n&ZERO    SETB  0                    RESET FLAGS\n&TRUNC   SETB  0                    RESET FLAGS\n         AIF   (&FLAG GE 10).FLD995\n         AIF   (&LAST).FLD816\n         DC    X'0&FLAG',AL1(&LEN2),SL2(&P1S,&P2L)\n         AGO   .LIT99\n.FLD816  DC    X'8&FLAG',AL1(&LEN2),SL2(&P1S,&P2L),0S(0)\n         AGO   .LIT99\n.FLD990  MNOTE 12,'OPERAND &I HAS TOO MANY SUB-OPERANDS'\n         AGO   .LIT99\n.FLD992  MNOTE 12,'Too many sub-operands: &SYSLIST,(&I)'\n         AGO   .LIT99\n.FLD993  MNOTE 8,'THIRD SUBPARAMETER IS INVALID: ''&SYSLIST(&I,3)'''\n         AGO   .LIT99\n.FLD995  MNOTE 8,'Invalid Combination of Attributes: &SYSLIST(&I)'\n         AGO   .LIT99\n.*--------------------------------------------------------------------*\n.*------------ LITERALS ----------------------------------------------*\n.*--------------------------------------------------------------------*\n.LIT00   ANOP\n&LIT     SETC  'C&SYSLIST(&I)'\n         AGO   .LIT09\n.LIT01   ANOP\n&LIT     SETC  '&SYSLIST(&I)'\n.LIT09   ANOP                              calculate length of literal\n&J       SETA  3\n&L       SETA  0\n         ACTR  K'&LIT+K'&LIT+100\n         AIF   ('&LIT'(1,1) EQ 'X').LIT11X\n.*--LOOP\n.LIT11C AIF ('&LIT'(&J,1) NE '''' AND '&LIT'(&J,1) NE '&&'(1,1)).LIT12C\n&J       SETA  &J+1\n.LIT12C  ANOP\n&J       SETA  &J+1\n&L       SETA  &L+1\n         AIF   (&J LT K'&LIT).LIT11C\n.*--ENDLOOP\n         AGO   .LIT15\n.*--LOOP\n.LIT11X  AIF   ('&LIT'(&J,1) EQ ',').LIT12X\n&L       SETA  &L+1\n.LIT12X  ANOP\n&J       SETA  &J+1\n         AIF   (&J LT K'&LIT).LIT11X\n.*--ENDLOOP\n&L       SETA  (&L+1)/2\n.LIT15   ANOP                               generate in-line literal\n         AIF   (&L GT 5).LIT40\n         AIF   (&LAST).LIT16\n         DC    X'4&L',&LIT\n         AGO   .LIT90\n.LIT16   DC    X'C&L',&LIT,0S(0)\n         AGO   .LIT90\n.LIT40   ANOP                                  check literal table\n         AIF   (&$_LIT EQ 0).LIT50\n&N       SETA  1\n         ACTR  &$_LIT*3+200\n         AIF   (&$_CSECT_NO GT 1).LIT42\n.*--loop\n.LIT41   AIF   ('&LIT' EQ '&$_LITS(&N)').LIT80       LOOP\n&N       SETA  &N+1                                  LOOP\n         AIF   (&N LE &$_LIT).LIT41                  LOOP\n.*--endloop\n         AGO   .LIT50\n.LIT42   ANOP\n.*--loop\n.LIT422  AIF   ('&$_LITS_CSECT(&N)' EQ '&SYSECT2' AND                  X\n               '&LIT' EQ '&$_LITS(&N)').LIT80 LOOP\n&N       SETA  &N+1                                  LOOP\n         AIF   (&N LE &$_LIT).LIT422                 LOOP\n.*--endloop\n.LIT50   ANOP\n&$_LIT   SETA  &$_LIT+1\n&$_LITS(&$_LIT) SETC '&LIT'\n&$_LITS_CSECT(&$_LIT) SETC '&SYSECT2'\n.LIT55   ANOP\n.*NOTE 0,' &$_LIT &$_LITS_CSECT(&$_LIT) &SYSECT'\n.*NOTE 0,'&$_CSECT_NO &$_CSECT(1) &$_CSECT(2) &$_CSECT(3) &$_CSECT(4)'\n.**            &$_LITS(9999)           LITERALS\n&N       SETA  &$_LIT\n.LIT80   ANOP                               generate remote literal\n&N       SETA  &N+1000\n         AIF   (&LAST).LIT86\n         DC    X'40',AL1(&L),AL2($LIT&N-*)\n         AGO   .LIT90\n.LIT86   DC    X'C0',AL1(&L),AL2($LIT&N-*),0S(0)\n.LIT90   ANOP\n&$_FEAT(1) SETB 1                      LITERAL\n.LIT99   ANOP\n.*--------------------------------------------------------------------*\n&I       SETA  1+&I                              LOOP\n         AIF   (&I LE N'&SYSLIST).LOOP1          LOOP\n.*ENDLOOP\n&LOCTR1  LOCTR\n         AGO   .MEND\n.ERR1    MNOTE 12,'AT LEAST ONE INPUT FIELD MUST BE SPECIFIED'\n         AGO   .MEND\n.ERR2    MNOTE 12,'INVALID OUTPUT AREA SPECIFICATION'\n         AGO   .MEND\n.**********************************************************************\n.*       GENERATE: GENERATE LITERALS AND PROCESSING ROUTINE           *\n.**********************************************************************\n.GENL    ANOP\n         AIF   (N'&SYSLIST(1) GT 3).GENL1R\n&OPT2    SETC  '&SYSLIST(1,2)'\n         AIF   ('&OPT2' NE '' AND '&OPT2' NE 'AR_MODE'                 X\n               AND '&OPT2' NE 'NO_CSECT').GENL1R\n&OPT3    SETC  '&SYSLIST(1,3)'\n         AIF   ('&OPT3' NE '' AND '&OPT3' NE 'LOCTR').GENL1R\n         AIF   ('&OPT2' EQ 'NO_CSECT' AND '&OPT3' EQ 'LOCTR').GENL1R\n         AGO   .GENL1D\n.GENL1R  MNOTE 12,'Invalid GENERATE options, default used'\n&OPT2    SETC  ''\n&OPT3    SETC  ''\n.GENL1D  ANOP\n&STRBLANKS SETA 2\n         AIF   (D'$LTORG).GENL1F             CSECT-ONLY\n&$_FEAT(1) SETB 1,1,1,1,1,1,1,1,1,1,1,1\n.GENL1F  ANOP\n&ALLFEAT SETC  '&$_FEAT(1)&$_FEAT(2)&$_FEAT(3)&$_FEAT(4)'\n&ALLFEAT SETC  '&ALLFEAT&$_FEAT(5)&$_FEAT(7)&$_FEAT(6)&$_FEAT(8)'\n&ALLFEAT SETC  '&ALLFEAT&$_FEAT(9)&$_FEAT(10)&$_FEAT(11)&$_FEAT(12)'\n&STR     SETC  '&STRING_MACRO_VERSION'\n         MNOTE *,'STRING R&STR - FEATURES GENERATED: &ALLFEAT'\n         AIF   (&$_LIT EQ 0).GENL3\n&STR     SETC  '*CSECT'\n.*LOOP\n.GENL2   ANOP                                LOOP\n&N       SETA  &N+1                          LOOP\n&I       SETA  &N+1000                       LOOP\n.*MNOTE *,'&$_LITS_CSECT(1) &$_LITS_CSECT(&N) &N &I'\n         AIF   ('&STR' EQ '&$_LITS_CSECT(&N)').GENL2L\n&STR     SETC  '&$_LITS_CSECT(&N)'           LOOP\n&LOCTR1  SETC  '$LITERAL'                    LOOP\n         AIF   ('&$_CSECT(1)' EQ '&$_LITS_CSECT(&N)').GENL2D\n&LOCTR1  SETC  '$LITERAL_&STR'               LOOP\n.GENL2D  ANOP                                LOOP\n&LOCTR1  LOCTR\n.GENL2L  ANOP                                LOOP\n$LIT&I   DC    &$_LITS(&N)\n         AIF   (&N LT &$_LIT).GENL2          LOOP\n.*ENDLOOP\n.GENL3   ANOP\n         AIF   ('&OPT2' EQ 'NO_CSECT').GENL8\n&ARMODE  SETB  ('&OPT2' EQ 'AR_MODE')\n.**********************************************************************\n.*                                                                    *\n.*       STRING SUB-ROUTINE                                           *\n.*                                                                    *\n.*             CAUTION: BYTES 49-72 OF THE CALLER'S SAVE AREA         *\n.*                      (R7-R12 SLOTS) ARE USED AS WORK SPACE         *\n.*                                                                    *\n.**********************************************************************\n         AIF   ('&OPT3' EQ 'LOCTR').GENL4L\n@STRING  CSECT\n@STRING  RMODE ANY\n         AGO   .GENL4X\n.GENL4L  PUSH  USING                   GENERATE,LOCTR\n         DROP\n@STRING@ LOCTR\n@STRING  DS    0H                      ALIGNMENT\n.GENL4X  ANOP\n@00      EQU   0                       WORK REGISTER\n@01      EQU   1                       WORK REGISTER\n@02      EQU   2                       WORK REGISTER\n@03      EQU   3                       WORK REGISTER\n@04      EQU   4                       WORK REGISTER\n@05      EQU   5                       WORK REGISTER\n@06      EQU   6                       WORK REGISTER\n         AIF   (NOT &ARMODE).ARMODE1X\n@07      EQU   7                       WORK REGISTER\n@08      EQU   8                       WORK REGISTER\n@09      EQU   9                       WORK REGISTER\n@10      EQU   10                      WORK REGISTER\n@11      EQU   11                      WORK REGISTER\n@12      EQU   12                      WORK REGISTER\n.ARMODE1X ANOP\n@13      EQU   13                      CALLER'S SAVE AREA\n@14      EQU   14                      WORK REGISTER\n@15      EQU   15                      BASE REG\n         USING @STRING,@15\n         USING @STRSAVE,@13\n         B     @STR003                 BRANCH AROUND EYE-CATCHER\n         AIF   (&ARMODE).ARMODE2Y\n         DC    C'@STRING/370 R&STRING_MACRO_VERSION &ALLFEAT',0H'0'\n@STR003  STM   @14,@06,12(@13)         Save caller's registers\n         SLR   @06,@06                 R6=0\n&LAE     SETC  'LA'\n         AGO   .ARMODE2X\n.ARMODE2Y ANOP\n         DC    C'@STRING/390 R&STRING_MACRO_VERSION &ALLFEAT',0H'0'\n@STR002  DC    H'2'\n@STR003  STM   @14,@12,12(@13)         SAVE REGS (DEBUGGING ONLY)\n.*+++    BSM   @14,0                   Set AMODE when invoked via BAL\n         AH    @14,@STR002-@STRING(@15,0) POINT PAST PARM-LIST OFFSET\n         BAKR  @14,0                   SAVE REGS AND RETURN ADDRESS\n         BCTR  @14,0                   ADJUST ADDR OF PARM LIST OFFSET\n         BCTR  @14,0                   ADJUST ADDR OF PARM LIST OFFSET\n         LAE   @06,0                   R6=0 AR6=0\n         CPYA  @14,@06                 AR14=0\n         CPYA  @15,@06                 AR15=0\n&LAE     SETC  'LAE'\n.ARMODE2X ANOP\n         ICM   @06,B'0011',0(@14)      PICK UP PARM-LIST 1/2 OFFSET\n         ALR   @06,@06                 PICK UP PARM-LIST OFFSET\n         ALR   @06,@14                 R6 NOW POINTS TO PARM LIST\n         USING @STRSCON,@06\n         &LAE  @02,@STRSCON            RESOLVE FIRST SCON (ADDR)\n         BAL   @14,@STRS2A             GET ADDRESS IN R2\n         &LAE  @04,0(,@02)             KEEP ADDRESS OF \"INTO\" FIELD\n         L     @14,12(,@13)            RESTORE ADDR OF STRING MACRO\n         OI    0(@04),0                GET CLEAN S0C4 IF ADDRESS IS BAD\n         &LAE  @02,@STRFLEN            RESOLVE SECOND S-CON (LEN)\n         BAL   @14,@STRS2A             GET LENGTH IN R2\n         LR    @05,@02                 KEEP LENGTH OF \"INTO\" FIELD\n         CR    @05,@04                 END ADDRESS?\n         BL    @STR282                 NO, JUMP\n         SR    @05,@04                 CALCULATE LENGTH\n         AIF   (NOT &ARMODE).ARMODE5N\n@STR282  MSTA  @04                     SAVE R4,R5 ON LINKAGE STACK\n.*SLAC   DC    X'B247,0040'            SLAC assembler error\n         AGO   .ARMODE5X\n.ARMODE5N ANOP\n@STR282  ST    @04,8(,@13)             SAVE ADDRESS FOR LATER\n.ARMODE5X ANOP\n.**********************************************************************\n.*       MOVE FIELDS TO OUTPUT AREA                                   *\n.**********************************************************************\n         &LAE  @06,@STRNEXT            POINT TO 1ST FIELD DESC\n         USING @STRPARM,@06\n.*LOOP\n@STR310  EQU   *\n         AIF   (NOT &$_FEAT(1)).FEAT1A\n         TM    @STRFLAG,@STRLIT        IS THIS A LITERAL?\n         BO    @STR372                 YES, JUMP\n.FEAT1A  ANOP\n         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(3)).FEAT23A\n         TM    @STRFLAG,@STRREG        REGISTER?\n         BO    @STR323                 YES, JUMP\n.FEAT23A ANOP\n         AIF   (NOT &$_FEAT(12)).FEAT12A\n         CLI   @STRSCON,X'E0'          IS IT %TIME ?\n         BE    @STR378                 YES, JUMP\n.FEAT12A ANOP\n.*\n.*       IT'S A FIELD (SCON)\n.*\n         &LAE  @02,@STRFLEN            RESOLVE SECOND S-CON (LEN)\n         BAL   @14,@STRS2A             GET LENGTH IN R2\n         AIF   (&$_FEAT(9)).FEAT9E1    (LEFT JUSTIFICATION, NUMERIC)\n         LTR   @03,@02                 KEEP/TEST LENGTH\n         BZ    @STR398                 ZERO LENGTH, DO NOT EDIT\n         AGO   .FEAT9E2\n.FEAT9E1 LTR   @03,@02                 KEEP/TEST LENGTH\n         BP    @STR313                 LENGTH POSITIVE, JUMP\n         TM    @STRLEN2,@STRLEFT       LEFT JUSTIFICATION?\n         BNO   @STR398                 NO, ZERO LENGTH IS NOT OK\n@STR313  EQU   *\n.FEAT9E2 ANOP\n         &LAE  @02,@STRSCON            RESOLVE FIRST SCON (ADDR)\n         BAL   @14,@STRS2A             GET ADDRESS IN R2\n         L     @14,12(,@13)            RESTORE ADDR OF STRING MACRO\n         CLI   0(@02),0                GET CLEAN S0C4 IF ADDRESS IS BAD\n         CR    @03,@02                 END ADDRESS?\n         BL    @STR314                 NO, JUMP\n         LA    @00,X'0080'             PSA ADDRESS\n         CLR   @02,@00                 PSA REFERENCE?\n         BL    @STR314                 YES, JUMP\n         SR    @03,@02                 CALCULATE LENGTH\n@STR314  EQU   *\n         AIF   (NOT &$_FEAT(6)).FEAT6A\n         TM    @STRFLAG,@STRBIN        BINARY FIELD?\n         BO    @STR328                 YES, JUMP\n.FEAT6A  ANOP\n         AIF   (NOT &$_FEAT(4)).FEAT4A\n         TM    @STRFLAG,@STRPACK       PACKED FIELD?\n         BO    @STR351                 YES, JUMP\n.FEAT4A  ANOP\n         AIF   (NOT &$_FEAT(7)).FEAT7A\n         TM    @STRFLAG,@STRHEX        EDIT IN HEX?\n         BO    @STR376                 YES, JUMP\n.FEAT7A  ANOP\n.*\n.*       TRUNCATE CHARACTER STRING\n.*\n         AIF   (NOT &$_FEAT(11)).FEAT11A\n         CLI   @STRLEN2,@STRLEFT       CHECK JUSTIFICATION, OUTPUT LEN\n         BNE   @STR390                 NO STRING TRUNCATION, JUMP\n         &LAE  @01,0(@03,@02)          FIRST BYTE AFTER FIELD\n@STR318  BCTR  @01,0                   DOWN 1 BYTE                 LOOP\n         CLI   0(@01),C' '             IS IT A SPACE ?             LOOP\n         BNE   @STR390                 LAST NON-BLANK BYTE         LOOP\n         BCT   @03,@STR318             LOOP UNTIL 1ST NON-BLANK    LOOP\n         B     @STR398                 BLANK FIELD, DO NOT EDIT\n         AGO   .FEAT11B\n.FEAT11A ANOP\n         AIF (&$_FEAT(2)+&$_FEAT(3)+&$_FEAT(4)+&$_FEAT(6) EQ 0).FEAT11B\n         B     @STR390                 EDIT\n.FEAT11B ANOP\n.*\n.*       REGISTER (R0-R13)\n.*\n         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(3)).FEAT23B\n         AIF   (NOT &ARMODE).ARMODE7N\n@STR323  LH    @01,@STRSCON            REG NUMBER IN BITS 28-31\n         CLI   @STRSCON+1,@06          IS THIS R7-R13?\n         BH    @STR323R                YES, JUMP\n         LR    @07,@01                 SAVE R1 (R)\n         LAE   @10,0(,@04)             SAVE R4\n         LR    @11,@05                 SAVE R5\n         LAE   @12,0(,@06)             SAVE R6\n         EREG  @00,@06                 RELOAD CALLER'S R0-R6\n         EX    @07,@STR323L            COPY R0-R6 VALUE\n         LAE   @04,0(,@10)             RESTORE R4\n         LR    @05,@11                 RESTORE R5\n         LAE   @06,0(,@12)             RESTORE R6\n         B     @STR323T\n@STR323L LR    @00,*-*                 COPY VALUE FOR EDIT\n@STR323R EQU   *\n         EREG  @07,@12                 RESTORE CALLER'S R7-R12\n         EX    @01,@STR323L            COPY R7-R13 INTO R0\n         AGO   .ARMODE7X\n.ARMODE7N ANOP\n@STR323L LR    @00,*-*                 COPY VALUE FOR EDIT\n@STR323  LH    @01,@STRSCON            REG NUMBER IN BITS 28-31\n         EX    @01,@STR323L            COPY R7-R13 INTO R0\n         CLI   @STRSCON+1,@06+1        IS THIS R7-R13?\n         BNL   @STR323T                YES, JUMP\n         SLL   @01,2                   R1= 000000BB BASE * 4\n         L     @00,20(@01,@13)         PICK UP VALUE FOR R0-R6\n.ARMODE7X ANOP\n@STR323T EQU   *\n         AIF   (NOT &$_FEAT(3)).FEAT3R REG,HEX\n         AIF   (NOT &$_FEAT(2)).FEAT2H REG,BIN\n         TM    @STRFLAG,@STRHEX        EDIT IN HEX?\n         BNO   @STR330                 NO, EDIT FWD\n.FEAT2H  ANOP\n         STCM  @00,B'1111',@STRDWD-1   STORE IT FOR CVD/UNPK\n         LA    @03,8                   OUTPUT LENGTH\n         B     @STR376X                EDIT IN HEX\n.FEAT3R  ANOP\n         AIF   (NOT &$_FEAT(6)).FEAT23B\n         B     @STR330                 EDIT R0\n.FEAT23B ANOP\n.*\n.*       BINARY VARIABLE: @03 CONTAINS THE ICM MASK (1 3 7 F)\n.*\n         AIF   (NOT &$_FEAT(6)).FEAT6B\n@STR328M ICM   @00,*-*,0(@02)          **EXECUTED INSTRUCTION**\n@STR328  SLR   @00,@00\n         EX    @03,@STR328M            LOAD THE BINARY VARIABLE\n.FEAT6B  ANOP\n.*\n         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(6)).FEAT6C\n@STR330  CVD   @00,@STRDWD             CONVERT VALUE TO DECIMAL\n         AIF   (NOT &$_FEAT(4)).FEAT6C\n         B     @STR361                 EDIT DWD\n.FEAT6C  ANOP\n.*\n.*       PACKED FIELD\n.*\n         AIF   (NOT &$_FEAT(4)).FEAT4B\n@STRZAP  ZAP   @STRDWD,0(*-*,@02)      MOVE TO @STRDWD\n@STR351  &LAE  @03,0(,@02)             FIRST BYTE OF PACKED FIELD\n         BALR  @14,0\n         TM    0(@03),X'0C'            IS THIS THE SIGN BYTE?\n         LA    @03,1(,@03)              (NEXT BYTE)\n         BNOR  @14                     NO, LOOP MORE\n         SLR   @03,@02                 GET LENGTH OF PACKED FIELD\n         BCTR  @03,0\n         EX    @03,@STRZAP             EXECUTE ZAP\n         AIF   (NOT &$_FEAT(5)).FEAT4B\n         CLI   @STRLEN2,248            JULIAN-TO-YYMMDD CONV?\n         BNL   @STR375                 YES, JUMP\n.FEAT4B  ANOP                          PACKED\n.*\n.*       EDIT @STRDWD (BIN, REG, PACKED)\n.*\n         AIF   (NOT &$_FEAT(8)).FEAT8B\n@STR361  IC    @00,@STRLEN2            OUTPUT LENGTH\n         LA    @03,X'003F'             MASK FOR \"AND\"\n         NR    @03,@00                 OUTPUT LENGTH\n         MVC   @STRWK16(16),@STRMASK   EDIT MASK\n.*\n.*       LEFT-JUSTIFICATION (NUMERIC)\n.*\n         AIF   (NOT &$_FEAT(9)).FEAT9B\n         TM    @STRLEN2,@STRLEFT       LEFT JUSTIFICATION?\n         BNO   @STR367                 NO, JUMP\n         &LAE  @01,@STRWK16+15         PREVENT BAD R1\n         EDMK  @STRWK16(16),@STRDWD    ZONED DECIMAL\n         BNM   @STR362                 skip if not a negative number\n         BCTR  @01,0                   R1 = significance start ptr -1\n         MVI   0(@01),C'-'             sink negative sign in front\n@STR362  &LAE  @02,0(,@01)             FIRST STRING POSITION\n         LTR   @03,@03                 CHECK OUTPUT LENGTH\n         BNZ   @STR363                 JUMP IF NOT ZERO\n.*       L0    (LEFT JUSTIFIED, NO PADDING)\n         &LAE  @03,@STRWK16+16         FIRST POSITION AFTER STRING\n         SR    @03,@02                 COMPUTE STRING LENGTH\n         B     @STR390                 MOVE FIELD TO OUTPUT LINE\n.*       L1-L63 (LEFT JUSTIFIED, PADDING)\n@STR363  CR    @03,@05                 COMPARE LENGTH TO REMAINING LEN\n         BNH   @STR364                 LARGE ENOUGH, JUMP\n         LR    @03,@05                 TOO BIG, TRUNCATE TO REM. LEN.\n@STR364  SR    @05,@03                 COMPUTE REMAINING LENGTH\n         AIF   (NOT &ARMODE).ARMODE8N\n         LAE   @08,0(,@04)             POINTER IN OUTPUT LINE\n         LR    @09,@03                 LENGTH WITH PADDING\n         AGO   .ARMODE8X\n.ARMODE8N ANOP\n         LR    @00,@04                 POINTER IN OUTPUT LINE\n         LR    @01,@03                 LENGTH WITH PADDING\n.ARMODE8X ANOP\n         LA    @03,@STRWK16+16         FIRST POSITION AFTER STRING\n         SR    @03,@02                 COMPUTE STRING LENGTH\n         B     @STR392                 MOVE FIELD TO OUTPUT LINE\n@STR367  EQU   *\n.FEAT9B  ANOP\n         AIF   (NOT &$_FEAT(10)).FEAT10B\n         TM    @STRLEN2,@STRZERO       LEADING ZEROES REQ'D?\n         BNO   @STR368                 NO, JUMP\n         MVI   @STRWK16,C'0'           YES, CHANGE X'40' TO C'0'\n@STR368  EQU   *\n.FEAT10B ANOP\n         &LAE  @01,@STRWK16+15         PREVENT BAD R1\n         EDMK  @STRWK16(16),@STRDWD    ZONED DECIMAL\n         BNM   @STR369                 skip if not a negative number\n         BCTR  @01,0                   R1 = significance start ptr -1\n         MVI   0(@01),C'-'             sink negative sign in front\n@STR369  &LAE  @02,@STRWK16+16         FIRST POSITION AFTER STRING\n         SR    @02,@03                 FIRST STRING POSITION\n.FEAT8B  ANOP\n.*\n.*       LITERAL (@STRSCON IS A 16-BIT OFFSET)\n.*       Short Literal (low-order 4 bits of @STRFLAG contains length)\n.*       BLANKS  (@STRSCON=ZERO)\n.*\n         AIF   (NOT &$_FEAT(1)).FEAT1B\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n@STR372  LA    @01,7                   mask for NR\n         &LAE  @02,@STRLEN2            1st byte of short literal\n         IC    @03,@STRFLAG            pick up flags+length\n         NR    @03,@01                 R3 has length of short literal\n         BNZ   @STR390                 short literal, go move it\n         SLR   @02,@02                 Clear Address Register\n         IC    @03,@STRLEN2            GET LITERAL LENGTH\n         TM    @STRFLAG,@STRX40        string of spaces?\n         BO    @STR390                 yes, go move them\n         ICM   @02,B'0011',@STRSCON    LOAD LITERAL OFFSET\n         LA    @02,@STRSCON(@02)       CONVERT OFFSET TO FULL ADDRESS\n.FEAT1B  ANOP\n.*\n.*       CONVERT JULIAN DATE TO YYMMDD\n.*\n         AIF   (NOT &$_FEAT(5)).FEAT5F\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n@STR375  LA    @00,248                 MASK FOR 'SLR'\n         SLR   @01,@01\n         IC    @01,@STRLEN2            248-255\n         SLR   @01,@00                 000-007\n         LA    @00,12                  L'@STR375W\n         MR    @00,@00                 COMPUTE OFFSET\n         &LAE  @01,@STR375W(@01)       ENTRY IN \"TR\" MASK TABLE\n         SLR   @03,@03\n         IC    @03,0(,@01)             LENGTH OF DATE (6, 8 OR 10)\n         ZAP   @STRDWD,@STRDWD         DATE=0000000?               @JDT\n         BNZ   @STR375B                NO, JUMP                    @JDT\n@STR375Z &LAE  @02,@STRBLANKS          WORK AREA\n&STRBLANKS SETA 10                     WE NEED AT LEAST 10 BLANKS\n         B     @STR390                 MOVE FIELD TO OUTPUT LINE\n@STR375W DC    AL1(10,C'-',0,1,2,3,8,4,5,8,6,7) YYYY-MM-DD   248\n         DC    AL1(8,C' ',0,1,2,3,4,5,6,7,8,8)  YYYYMMDD//   249\n         DC    AL1(8,C'/',2,3,8,4,5,8,6,7,8,8)  YY/MM/DD//   250\n         DC    AL1(8,C'/',6,7,8,4,5,8,2,3,8,8)  DD/MM/YY//   251\n         DC    AL1(8,C'/',4,5,8,6,7,8,2,3,8,8)  MM/DD/YY//   252\n         DC    AL1(6,C' ',2,3,4,5,6,7,8,8,8,8)  YYMMDD       253\n.*       DC    AL1(6,C' ',6,7,4,5,2,3,8,8,8,8)  DDMMYY       254\n.*       DC    AL1(6,C' ',4,5,6,7,2,3,8,8,8,8)  MMDDYY       255\n@STR375T DC    P'59,31,29,31,30,31,30,31,31,30,31,30,31'\n         DC    P'999'                  Prevent S0C7 with 90366\n@STR375B CLI   @STRDWD+4,X'01'         YEAR 2000 OR ABOVE?\n         BH    @STR375C                CC>01, JUMP (MUST BE 19 OR 20)\n         MVI   @STRDWD+4,X'20'         CC=01, CHANGE TO CC=20\n         BE    @STR375C                CC=01, USE CC=20\n         CLI   @STRDWD+4+1,X'50'       YY<50?\n         BL    @STR375C                YES, USE CC=20\n         MVI   @STRDWD+4,X'19'         NO, FORCE CC=19\n@STR375C UNPK  @STRWK16(5),@STRDWD+4(3) CCYY?\n         ZAP   @STRDWD+1(2),@STR375T+9(1) INIT MONTH COUNTER\n         &LAE  @02,@STR375T            TABLE OF MONTHS (NUMBER OF DAYS)\n         TM    @STRDWD+4+1,X'01'       ODD YEARS\n         BO    @STR375N                  AREN'T LEAP YEARS\n         TM    @STRDWD+4+1,X'12'       ZEROES IN 1980, ALL ONES IN 1992\n         BNM   @STR375L                MIXED IN 1982/1990\n.*       IF IT'S NOT A LEAP YEAR AND DDD>59, THEN ADD 1 TO DDD\n@STR375N CP    @STRDWD+4+2(2),@STR375T ARE WE PAST FEB 28 (DDD>59) ?\n         BNH   @STR375L                NO, JUMP\n         AP    @STRDWD+4+2(2),@STR375T+3(1) ADD 1 (FROM 31) TO DDD\n.*--LOOP WHILE DDD > 0\n@STR375L AP    @STRDWD+1(2),@STR375T+3(1)   ADD 1 (FROM 31) TO MONTH\n         LA    @02,2(,@02)             NEXT ENTRY IN \"MONTHS\" TABLE\n         SP    @STRDWD+4+2(2),0(2,@02) SUB DAYS-IN-MONTH FROM DDD\n         BP    @STR375L\n.*--ENDLOOP\n         AP    @STRDWD+4+2(2),0(2,@02) UNDO LAST \"SP\" INSTRUCTION\n         UNPK  @STRWK16+4(2),@STRDWD+1(2) FYFYFYFY,FMCM??\n         UNPK  @STRWK16+6(2),@STRDWD+6(2) FYFYFYFY,FMCMFDCD\n         MVZ   @STRWK16+1(7),@STRWK16     FYFYFYFY,FMCMFDCD\n         MVC   @STRWK16+8(1),1(@01)    SEPARATOR\n         &LAE  @02,@STRWK16+9          WORK AREA\n         MVC   0(10,@02),2(@01)        MOVE CORRESPONDING MASK\n         TR    0(10,@02),@STRWK16      CONVERT DATE TO THE RIGHT FORMAT\n.FEAT5F  ANOP                          JDATE\n.*\n.*       HEX STRING\n.*\n         AIF   (NOT &$_FEAT(7)).FEAT7B\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n@STR376M MVC   @STRDWD-1(*-*),0(@02)   PREVENT S0C4 IN UNPK\n@STR376  LA    @00,8                   MAX LENGTH\n         CLR   @03,@00                 CHECK LENGTH\n         BNH   @STR376B                JUMP IF LE 8\n         LR    @03,@00                 TRUNCATE TO MAXIMUM LENGTH\n@STR376B LR    @01,@03                 INPUT LENGTH\n         BCTR  @01,0\n         EX    @01,@STR376M            MOVE DATA TO SAFE STORAGE\n         ALR   @03,@03                 OUTPUT LENGTH\n         AGO   .FEAT37B\n.FEAT7B  ANOP\n         AIF   (NOT &$_FEAT(3)).FEAT37C\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n.FEAT37B ANOP\n@STR376X &LAE  @02,@STRWK16            WORK AREA\n         UNPK  0(9,@02),@STRDWD-1(5)   EXPAND SOURCE BYTES FOR \"TR\"\n         UNPK  8(9,@02),@STRDWD+3(5)   EXPAND SOURCE BYTES FOR \"TR\"\n         TR    0(16,@02),@STRHEXT-240  =C'0123456789ABCDEF'\n.FEAT37C ANOP\n.*\n.*       %TIME\n.*\n         AIF   (NOT &$_FEAT(12)).FEAT12B\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n@STRTIME DC    X'4021207A20207A20204B20204000' 0X:XX:XX.XX\n@STR378  LR    @02,@15                 SAVE BASE REG\n         TIME  DEC                     GET HHMMSSHH\n         LR    @15,@02                 RESTORE BASE REG\n         ST    @00,@STRDWD             STORE HHMMSSHH\n         MVC   @STRWK16(13),@STRTIME   MOVE EDIT MASK\n         ED    @STRWK16(13),@STRDWD    EDIT HH:MM:SS.HH\n         &LAE  @02,@STRWK16+1          WORK AREA\n         LA    @03,12                  HH:MM:SS.HH+ SPACE\n ORG *-4\n         LH    @03,@STRFLEN            length is 5 8 11 12\n.FEAT12B ANOP\n.*MOVE\n@STR390  CR    @03,@05                 COMPARE LENGTH TO REMAINING LEN\n         BNH   @STR391                 LARGE ENOUGH, JUMP\n         LR    @03,@05                 TOO BIG, TRUNCATE TO REM. LEN.\n@STR391  SR    @05,@03                 COMPUTE REMAINING LENGTH\n         AIF   (NOT &ARMODE).ARMODE39N\n         LAE   @08,0(,@04)             POINTER IN OUTPUT LINE\n         LR    @09,@03                 PASS REMAINING LENGTH\n         AGO   .ARMODE39X\n.ARMODE39N ANOP\n         LR    @00,@04                 POINTER IN OUTPUT LINE\n         LR    @01,@03                 PASS REMAINING LENGTH\n.ARMODE39X ANOP\n         LTR   @02,@02                 BLANKS?\n         BNZ   @STR392                 NO, JUMP\n         SLR   @03,@03                 YES, ZERO LENGTH\n@STR392  ICM   @03,B'1000',@STRBLANKS  PAD WITH BLANKS\n         AIF   (NOT &ARMODE).ARMODE44N\n         MVCL  @08,@02                 MOVE FIELD TO OUTPUT LINE\n         LR    @04,@08                 NEW POINTER IN OUTPUT LINE\n         AGO   .ARMODE44X\n.ARMODE44N ANOP\n         MVCL  @00,@02                 MOVE FIELD TO OUTPUT LINE\n         LR    @04,@00                 NEW POINTER IN OUTPUT LINE\n.ARMODE44X ANOP\n@STR398  TM    @STRFLAG,@STRLAST       TEST LAST-ENTRY INDICATOR\n         BO    @STR399                 Done, exit\n         AIF   (NOT &$_FEAT(1)).FEAT1C\n         TM    @STRFLAG,@STRLIT+@STRX40 literal or spaces?\n         BM    @STR398L                Literal, not spaces\n         BZ    @STR398X                Neither literal nor spaces\n         LA    @06,@STRSCON            2-byte entry for blank spaces\n         B     @STR310                 PROCESS NEXT ENTRY\n@STR398L LA    @01,7                   mask for NR\n         IC    @03,@STRFLAG            pick up flags+length\n         NR    @03,@01                 R3 has length of short literal\n         BZ    @STR398T                not an in-line literal, jump\n         LA    @06,@STRLEN2(@03)       Skip VL parm for in-line literal\n         B     @STR310                 PROCESS NEXT ENTRY\n@STR398T LA    @06,@STRFLEN            4-byte parm for remote literal\n         B     @STR310                 PROCESS NEXT ENTRY\n.FEAT1C  ANOP\n@STR398X LA    @06,@STRNEXT            BUMP UP TO NEXT ENTRY\n         B     @STR310                 PROCESS NEXT ENTRY\n.*ENDLOOP\n.*\n.*       END-OF-LINE PROCESSING - PAD WITH BLANKS\n.*\n@STR399  SLR   @01,@01                 SET UP R1 FOR PADDING\n         ICM   @01,B'1000',@STRBLANKS  SET UP R1 FOR PADDING\n.***     DROP  @06,@13,@15\n         AIF   (&ARMODE).ARMODE52Y\n         LA    @14,2                   INCREMENT\n         AL    @14,12(,@13)            RETURN ADDRESS\n         LR    @15,@04                 CURRENT POINTER IN OUTPUT FIELD\n         SL    @15,8(,@13)             CALCULATE LENGTH USED\n         MVCL  @04,@00                 PAD WITH BLANKS\n         LM    @00,@06,20(@13)         RESTORE WORK REGISTERS\n         STM   @06+1,@13-1,48(@13)     MAKE SAVE AREA LOOK NORMAL\n         OI    15(@13),1               SIMULATE \"T\" OPTION OF RETURN\n         BR    @14                     RETURN TO CALLER\n         AGO   .ARMODE52X\n.ARMODE52Y ANOP\n         LA    @15,3                   MODIFIABLE AREA\n         ESTA  @14,@15                 R14 = START OF OUTPUT AREA\n         LR    @15,@04                 END OF OUTPUT AREA\n         SR    @15,@14                 R15 = LENGTH USED IN OUTPUT AREA\n         MVCL  @04,@00                 PAD WITH BLANKS\n         EREG  @00,@14                 RESTORE WORK REGISTERS\n         STM   @14,@12,12(@13)         MAKE SAVE AREA LOOK NORMAL\n         OI    15(@13),1               SIMULATE \"T\" OPTION OF RETURN\n         PR                            RETURN TO CALLER\n.ARMODE52X ANOP\n.*\n         AIF   (NOT (&$_FEAT(3) OR &$_FEAT(7))).FEAT37T\n@STRHEXT DC    C'0123456789ABCDEF'     HEX-TO-EBCDIC CONVERSION\n.FEAT37T ANOP\n         AIF   (NOT &$_FEAT(8)).FEAT8T\n@STRMASK DC    X'4020202020202020,2020202020202120'\n.FEAT8T  ANOP\n.**********************************************************************\n.*       Convert S-con to address                                     *\n.*             Input: GPR2 points to an S-CON in the remote parm list *\n.*             Output: GPR2 contains the address                      *\n.**********************************************************************\n@STRS2A  SLR   @00,@00\n         ICM   @00,B'0011',0(@02)      R0 = 0000BDDD\n         SRDL  @00,12                  R0 = 0000000B, R1= DDD.....\n         SRL   @01,20                  R1 = 00000DDD (DISPLACEMENT)\n         AIF   (&ARMODE).ARMODE88Y\n         CLI   0(@02),@06*16+15        R7-R13?\n         BH    @STRS2A3                YES, JUMP\n.*BASE REG IS R0-R6\n         LTR   @02,@00                 IS R0 THE BASE REG?\n         BNZ   @STRS2A2                NO, JUMP\n         LTR   @02,@01                 IS THIS A PSA ADDRESS?\n         BNZR  @14                     YES, GOBACK\n@STRS2A2 SLL   @02,2                   R2= 000000BB BASE * 4\n         L     @02,20(@02,@13)         PICK UP BASE REG VALUE\n         LA    @02,0(@02,@01)          ADD BASE REG VALUE TO DISPL\n         BR    @14\n.*BASE REG IS R7-R13\n@STRS2A3 LR    @02,@00                 R2= 0000000B (BASE REG NUMBER)\n         EX    @02,@STRS2A4            ADD BASE REG VALUE TO DISPL\n         BR    @14\n@STRS2A4 LA    @02,0(*-*,@01)          ADD BASE REG VALUE TO DISPL\n         AGO   .ARMODE88X\n.ARMODE88Y ANOP                        AR_MODE=YES\n         SLL   @00,2                   MULT BY 4\n         CLI   0(@02),@06*16+15        R7-R13?\n         BH    @STRS2A6                YES, JUMP\n.*BASE REG IS R0-R6\n         LTR   @02,@00                 IS R0 THE BASE REG?\n         BNZ   @STRS2A5                NO, JUMP\n         LTR   @02,@01                 IS THIS A PSA ADDRESS?\n         BNZR  @14                     YES, GOBACK\n         EREG  @00,@00                 POP R0\n         LAE   @02,0                   R2=0 AR2=0\n         LR    @02,@00                 PASS R0 VALUE\n         LA    @02,0(,@02)             CLEAN UP\n         BR    @14                     GOBACK\n.*BASE REG IS R1-R6\n@STRS2A5 LR    @07,@00                 SAVE R0 (B*4)\n         LR    @08,@01                 SAVE R1 (DDD)\n         LR    @09,@03                 SAVE R3\n         LAE   @10,0(,@04)             SAVE R4\n         LR    @11,@05                 SAVE R5\n         LAE   @12,0(,@06)             SAVE R6\n         EREG  @01,@06                 RELOAD CALLER'S R1-R6\n         EX    0,@STRS2A7-4(@07)       ADD BASE REG VALUE TO DISPL\n         LR    @03,@09                 RESTORE R3\n         LAE   @04,0(,@10)             RESTORE R4\n         LR    @05,@11                 RESTORE R5\n         LAE   @06,0(,@12)             RESTORE R6\n         BR    @14                     GOBACK\n.*BASE REG IS R7-R13\n@STRS2A6 LR    @02,@00                 R2= 0000000B (BASE REG NUMBER)\n         EREG  @07,@12                 RESTORE CALLER'S R7-R12\n         EX    0,@STRS2A7-4(@02)       ADD BASE REG VALUE TO DISPL\n         BR    @14                     GOBACK\n@STRS2A7 LAE   @02,0(@08,@01)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@02)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@03)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@04)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@05)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@06)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@07)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@08)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@09)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@10)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@11)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@12)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@13)          ADD BASE REG VALUE TO DISPL\n.ARMODE88X ANOP\n         AIF   ('&OPT3' EQ 'LOCTR').GENL7L\n@STRBLANKS DC  CL((((*+&STRBLANKS+7-@STRING)/8)*8)-(*-@STRING))' '\n         AGO   .GENL7X\n.GENL7L  ANOP\n@STRBLANKS DC  CL&STRBLANKS.' '\n.GENL7X  ANOP\n@STRING_SIZE EQU *-@STRING             SIZE OF GENERATED CSECT\n         DROP  @06,@13,@15\n.**********************************************************************\n.*       WORK AREA (CALLER'S SAVE AREA)                               *\n.**********************************************************************\n@STRSAVE DSECT                         24-BYTE WORK AREA\n         DS    A(0,@STRSAVE,@STRSAVE,14,15,0,1,2,3,4,5,6)\n@STRWK16 DS    F'7,8,9,10'             WORK AREA\n@STRDWD  DS    D'1112'                 WORK AREA\n@STRPARM DSECT\n@STRFLAG DS    B                   +0  FORMAT, FLAGS\n@STRLAST EQU   X'80'                     LAST ENTRY\n@STRLIT  EQU   X'40'                     LITERAL, @STRSCON IS AN OFFSET\n@STRX40  EQU   X'20'                   String of Spaces\n.*             X'0F'                   CONVERSION REQUIRED\n.*                                     or length of short literal\n@STRHEX  EQU   X'08'                     HEXADECIMAL\n@STRBIN  EQU   X'04'                     BINARY\n@STRPACK EQU   X'02'                     PACKED\n@STRREG  EQU   X'01'                     REGISTER\n@STRLEN2 DS    B                   +1  FORMAT, OUTPUT LENGTH\n.*                                     or start of short literal\n@STRLEFT EQU   X'80'                     LEFT JUSTIFICATION\n@STRZERO EQU   X'40'                     LEADING ZEROES\n.*             X'3F'                     OUTPUT LENGTH, 0 MEANS TRUNC.\n@STRSCON DS    S                   +2  FIELD ADDRESS\n@STRFLEN DS    S                   +4  FIELD LENGTH\n@STRNEXT EQU   *                   +6\n         AIF   (NOT D'$LTORG).MEND99   CSECT-ONLY\n         AIF   (D'$STRING).MEND99      CSECT-ONLY\n$LTORG   LOCTR\n         AIF   ('&OPT3' EQ 'LOCTR').GENL9L\n         CNOP  0,4\n$STRING  BALR  @15,0                   LOCAL BASE\n         L     @15,6(@15,0)            ROUTINE ADDRESS           00\n         BR    @15                     GO TO @STRING             04\n         AGO   .GENL9\n.GENL8   ANOP                          GENERATE,NOCSECT\n&$_LIT   SETA  0                       DO NOT GENERATE LITERALS TWICE\n&$_FEAT(1) SETB 1,1,1,1,1,1,1,1,1,1,1,1   GENERATE=FULL\n$LTORG   LOCTR\n         CNOP  0,4\n$STRING  BALR  R15,0                   LOCAL BASE\n         L     R15,6(R15,0)            ROUTINE ADDRESS           00\n         BR    R15                     GO TO @STRING             04\n.GENL9   ANOP\n         DC    V(@STRING)              ROUTINE ADDRESS           06\n.* MNOTE   1,'&$_CSECT_NO '\n         AIF   (&$_CSECT_NO EQ 1).MEND\n&I       SETA  2\n.*loop\n.GENL8K  ANOP\n.* MNOTE   1,'&$_CSECT(&I) '\n         AIF   ('&$_CSECT(&I)' EQ '').MEND\n&STR     SETC  '&$_CSECT(&I)'\n$LTORG_&STR LOCTR\n         CNOP  0,4\n$STRING_&STR BALR R15,0                LOCAL BASE\n         L     R15,6(R15,0)            ROUTINE ADDRESS           00\n         BR    R15                     GO TO @STRING             04\n         DC    V(@STRING)              ROUTINE ADDRESS           06\n&I       SETA  1+&I\n         AGO   .GENL8K\n.*endloop\n         AGO   .MEND\n.GENL9L  POP   USING                   GENERATE,LOCTR\n$STRING  BASR  R15,0                   Local Base\n         AH    R15,6(R15,0)            Add offset to @STRING routine\n         BR    R15                     Branch to @STRING\n         DC    Y(@STRING-$STRING-2)    Offset to @STRING Routine\n.MEND    AIF   ('&PRINT' EQ 'NOGEN').MEND99\n         POP   PRINT\n.MEND99  MEND\n         EJECT\n**********************************************************************\n**********************************************************************\n********* MVS TEST PROGRAM FOR THE 'STRING' MACRO ********************\n**********************************************************************\n**********************************************************************\n**       STRING (GENERATE,AR_MODE)\n**       END\n         LCLA  &ASMH_HLASM\n         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X\n&SYSVER  SETC  'ASMH'\n&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n.ASMH1X  ANOP\nTESTPGM  START X'027000'\nTESTPGM  AMODE 24                      (PRE-SMS PUT)\n         BALR  R12,0\n         USING *,R12\n LOAD EP=SYSDEBUG,ERRET=DEBUG111\n LR R15,R0\n BASSM R14,R15\nDEBUG111 EQU *\n*STRING 1X,INTO=XXX\n*RC8     STRING ((R1),,R**B),((R1),,R22Z),((R1),,R16B),INTO=XXX\n         OPEN  (SYSPRINT,OUTPUT)\n         STRING 'Assembler is &SYSVER, DATE is &SYSDATC',INTO=XXX\n         PUT   SYSPRINT,XXX\n         STRING 'AMPERSAND=&& AND APOSTROPHE='' ',INTO=XXX\n         PUT   SYSPRINT,XXX\nRBPREFIX EQU   *\nRBINTCOD EQU   *+6,2,C'H'\n         L     R1,PSATOLD-PSA(0,0)     TCB\n         L     R1,0(,R1)               TCBRBP\n         L     R2,PSAAOLD-PSA(0,0)     ASCB\nR2ASCB   USING ASCB,R2\n         L     R8,=X'88888888'\n         STRING 'SVC',(RBINTCOD-RBPREFIX(R1),H,R3Z),                   X\n               1X,(WWWW,,T),' - ',     VV.MM OF SVC RTNE               X\n               ((R8),,X),1X,           COM-REG ADDR                    X\n               'ASID=',(R2ASCB.ASCBASID,,X),1X,                        X\n               PARM1,1X,               MAIN PGM NAME                   X\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n*\n         LA    R2,XXX\n         STRING 1X,INTO=((R2),8)\n         MACRO                                       JDATE MACRO\n        @JDATE &DATE                                 JDATE MACRO\n         LA    R1,=P'&DATE'                          JDATE MACRO\n*** STRING ((R1),P),2X,((R1),P),INTO=XXX\n         STRING ((R1),P,R5Z),                        JDATE MACRO       X\n               2X,((R1),P,YYMMDD),                   JDATE MACRO       X\n               2X,((R1),P,YY/MM/DD),                 JDATE MACRO       X\n               2X,((R1),P,DD/MM/YY),                 JDATE MACRO       X\n               2X,((R1),P,MM/DD/YY),                 JDATE MACRO       X\n               2X,((R1),P,YYYYMMDD),                 JDATE MACRO       X\n               2X,((R1),P,YYYY-MM-DD),               JDATE MACRO       X\n               INTO=XXX                              JDATE MACRO\n         PUT   SYSPRINT,XXX                          JDATE MACRO\n         MEND                                        JDATE MACRO\n        @JDATE 90058\n        @JDATE 91059\n        @JDATE 93060\n        @JDATE 94365\n        @JDATE 80058\n        @JDATE 84059\n        @JDATE 88060\n        @JDATE 92061\n        @JDATE 00366\n         LA    R2,1234\n         STRING 'CVTPTR=X''',(CVTPTR,4,X),'''',INTO=XXX,               X\n               ' 1234=',((R2),,R4Z)\n         PUT   SYSPRINT,XXX\n         L     R1,CVTPTR(0,0)\n         STRING 'CVTDATE=',(56(R1),P,YYMMDD),INTO=XXX\n         PUT   SYSPRINT,XXX\n         LA    R0,1000\n         LA    R3,0033\n         STRING 'D1=/',D1,'/,WWWW=/',WWWW,'/',                         X\n               ((R3),,L),'/',((R3),,X),'/',((R0),,L),'/',              X\n               ((R3),,R9B),'/',INTO=XXX\n         LR    R4,R15                   LENGTH USED\n         PUT   SYSPRINT,XXX\n         STRING WWWW,                                                  X\n               (4(R13),4,X),'''',(4(R13),F),'''',                      X\n               (4(R13),F,L),'''',                                      X\n               (4(R13),F,L11),'''',                                    X\n               (4(R13),F,Z9),'''',                                     X\n               8X,'R4=',((R4),,L),      LENGTH USED                    X\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n         STRING %TIME,D1,'B12345678B',5X,(CTR1,P),1X,PARM1,1X,PARM2,   X\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n         STRING (%TIME,5),'|',(%TIME,8),'|',(%TIME,11),'|',(%TIME,12), X\n               '|',INTO=XXX\n         PUT   SYSPRINT,XXX\n         LA    R3,17\n         STRING INTO=XXX,'CCC1234A',(D1,(R3)),'.',(CTR1,P,R7Z)\n         PUT   SYSPRINT,XXX\n         STRING C'DDN2(',(D1,,T),')',X'40C1C2,C3C4',                   +\n               ' PSATOLD=',(PSATOLD-PSA,,X),                           +\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n         AIF   ('&SYSVER' EQ 'ASMH').HLASM99\nPSABASE  USING PSA,R0\n         STRING 'PSATOLD=',(PSABASE.PSATOLD,,X),                       +\n               ' PSATOLD=',(PSATOLD-PSA,,X),                           +\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n.HLASM99 ANOP\n         BALR  R0,0\n         STRING 'R0=',((R0),,X),'   16(R0)=',(16(R0),4,X),INTO=XXX\n         PUT   SYSPRINT,XXX\n         STRING 'R0=',((R0),,X),'   CTR1=',(CTR1,P,R5B),INTO=XXX\n         PUT   SYSPRINT,XXX\n         SLR   R0,R0\n         STRING 'R0=',((R0),,X),'   CTR2=',(CTR2,P,L),'.',INTO=XXX\n         PUT   SYSPRINT,XXX\n*\n         CALL  TCSECT2              <- 2nd CSECT\n*\n         CALL  TCSECT3              <- 3rd CSECT\n*\nAMODE31  LA    R12,0(,R12)             BALR->BASR\n         L     R15,=A(*+X'80000006')   AMODE=31\n         BSM   0,R15                   AMODE=31\n         L     R1,=A(@STRING)          point at CSECT\n         CLC   =C'/390',11(R1)         (GENERATE,AR_MODE) ?\n         BNE   EXIT                    no, prevent S0E0\n         DSPSERV CREATE,                                               X\n               NAME==CL8'STRING00',    C'STRING00'                     X\n               BLOCKS=HDRBLKS,         SIZE IN PAGES                   X\n               STOKEN=DSPCSTKN,                                        X\n               ORIGIN=DSPCORG\n         ALESERV ADD,STOKEN=DSPCSTKN,ALET=DSPCALET\n         LAM   R8,R8,DSPCALET          POINT TO THE DATA SPACE\n         L     R8,DSPCORG              SPACE ORIGIN (0 OR 4096)\n         SAC   512                     MODE=AR\n LAM R14,R6,TESTPGM+40                 S0E0-28\n         STRING WWWW,'AR_MODE WORKED OK',INTO=(2048(R8),100)\n         LAM   R2,R2,DSPCALET          POINT TO THE DATA SPACE\n         LR    R2,R8                   SPACE ORIGIN (0 OR 4096)\n         STRING (2048+L'WWWW(R2),30,T),INTO=XXX\n         SAC   0                       MODE=AR OFF\n         PUT   SYSPRINT,XXX            AR_MODE WORKS OK\n*\nEXIT     SLR   R15,R15\n         SVC   3                       GOBACK\n*\n*        2ND CSECT\n*\nTCSECT2  CSECT\n         BAKR  R14,0\n         LR    R10,R15\n         USING TCSECT2,R10\n         STRING '----> TCSECT2 STRING <----  R516',INTO=XXX\n         PUT   SYSPRINT,XXX\n         L     R1,CVTPTR(0,0)\n         STRING 'CVTDATE=',(56(R1),4,X),',R8=',((R8),,L),INTO=XXX\n         PUT   SYSPRINT,XXX\n         PR\n         DROP\n*\n*        3RD CSECT with NO name\n*\n         CSECT                           no-name\n         ENTRY TCSECT3\nTCSECT3  BAKR  R14,0\n         LR    R12,R15\n         USING TCSECT3,R12\n         L     R10,PRT3ADDR\n         USING SYSPRINT,R10\n         STRING '----> TCSECT3 STRING <----  R517',INTO=XXX\n         PUT   SYSPRINT,XXX\n         L     R1,CVTPTR(0,0)\n         STRING 'CVTDATE=',(56(R1),4,X),',R9=',((R9),,L),INTO=XXX\n         PUT   SYSPRINT,XXX\n         PR\n         DS    0F\nPRT3ADDR DC    A(SYSPRINT)\n*\nTESTPGM  CSECT\nD1       DC    C'D1-----D1    '\nWWWW     DC    C'WWWW'\nCTR1     DC    P'1'\nCTR2     DC    P'-33'\nPARM1    DC    C'<-PARM1->'\nPARM2    DC    C'<-PARM2->'\nDSPCSTKN DS    XL8                  0  AS TOKEN\nDSPCALET DS    F                    8  ALET\nDSPCORG  DS    F                   12  ORIGIN\nHDRBLKS  DC    F'100'\nCVTPTR   EQU   0016,4,C'A'\nSYSPRINT DCB   DSORG=PS,DDNAME=SYSPRINT,MACRF=PM,RECFM=FB,LRECL=121\nXXX      DS    CL121\n*\nXYZ      DSECT\n         STRING GENERATE\n**       STRING (GENERATE,NO_CSECT) -\\\n**       STRING (GENERATE,AR_MODE)  -/\n**       STRING (GENERATE,,LOCTR)\n**       STRING (GENERATE,AR_MODE,LOCTR)\n**       STRING (GENERATE,NO_CSECT,LOCTR)    invalid combination\n         YREGS\nPSA      DSECT\nPSATOLD  EQU   *+X'21C',4,C'A'\nPSAAOLD  EQU   *+X'224',4,C'A'\nASCB     DSECT\nASCBASID EQU   *+36,2,C'X'\n         END\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//GO      EXEC PGM=LOADER,PARM=PRINT,TIME=(,2)\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,DELETE)\n//SYSLOUT  DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//SYSDEBUG DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SVCUPDTE": {"ttr": 19466, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x03\\t\\x00@\\x00\\x85\\x15?\\x01\\x034/\\x17\\x02\\x02\\xbe\\x00?\\x01\\xab\\xc3\\xc2\\xe3\\xf4\\xf6\\xf5@@@@'", "ispf": {"version": "03.09", "flags": 0, "createdate": "1985-06-02T00:00:00", "modifydate": "2003-12-08T17:02:40", "lines": 702, "newlines": 63, "modlines": 427, "user": "CBT465"}, "text": "//GILBERTU JOB (ACCT#),SVCUPDTE,\n// CLASS=A,MSGCLASS=H,COND=(0,NE),\n//*RESTART=ESR,\n// NOTIFY=&SYSUID\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF,NORENT)\n*PROCESS BATCH,USING(NOMAP,WARN(8))\n***********************************************************************\n*                                                                     *\n*            COPYRIGHT (C) 1985-2003 GILBERT SAINT-FLOUR              *\n*                       ALL RIGHTS RESERVED                           *\n*                                                                     *\n* MODULE NAME = SVCUPDTE                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = INSTALL A TYPE-3 SVC ROUTINE.                    *\n*                                                                     *\n* FUNCTION = This program defines an SVC routine to the system as a   *\n*            type-3 SVC.  The module is loaded into the CSA unless    *\n*            it is already in PLPA or MLPA.  The installation of      *\n*            SVC routine can be permanent or temporary.               *\n*            Access to the new SVC routine may be restricted to       *\n*            jobs submitted by a particular user.                     *\n*            An IGX00nnn module may be installed as a type-3 ESR.     *\n*                                                                     *\n* STATUS = R309                                                       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = MVS/ESA 4.2.2 or above                            *\n*                                                                     *\n*    AUTHORIZATION = APF                                              *\n*                                                                     *\n*    RESTRICTIONS = Invoker must have UPDATE authority to             *\n*                   SYS1.PARMLIB.                                     *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (BATCH PROGRAM)                            *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 2K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE 24, AMODE 31,                    *\n*                 PROBLEM STATE, KEY 8                                *\n*                                                                     *\n* OPERATION = See Below                                               *\n*                                                                     *\n*        This program defines an SVC routine to the system as a       *\n*        type-3 SVC or ESR.  The module is loaded into the CSA        *\n*        unless it is already in PLPA or MLPA.                        *\n*                                                                     *\n*        The installation can be permanent or temporary.  It is       *\n*        permanent when the following two conditions are met:         *\n*                                                                     *\n*          1. the SVC routine is loaded from PLPA or MLPA             *\n*                                                                     *\n*          2. the good-night time is NOT specified in the parm        *\n*                                                                     *\n*        If either condition isn't true, the installation is          *\n*        temporary and SVCUPDTE remains in memory until a STOP or     *\n*        CANCEL command is issued, then re-installs the old SVC       *\n*        and terminates.                                              *\n*                                                                     *\n*        If the good-night time is specified in the PARM, SVCUPDTE    *\n*        shut itself off automatically at the specified time.         *\n*                                                                     *\n*        ENQ is used to prevent simultaneous installation of          *\n*        the same SVC by different jobs.                              *\n*                                                                     *\n*        If the specified SVC routine is in the LPA and a module      *\n*        with the same name is also in the JOBLIB or STEPLIB, then    *\n*        SVCUPDTE temporarily installs the module in JOBLIB or        *\n*        STEPLIB and stays active until it is STOP'd or CANCEL'd.     *\n*        The installation can only be permanent if the specified SVC  *\n*        routine is NOT in the JOBLIB or STEPLIB.  One way to work    *\n*        around this is to use an MVS facility called FETCHLIB,       *\n*        as shown in JCL example no 5 below.                          *\n*                                                                     *\n* INVOCATION = SVCUPDTE IS INVOKED VIA JCL, AS FOLLOWS:               *\n*                                                                     *\n*          PARM=(nnn,mmmmmmm,lock,hhmm,userid)                        *\n*                                                                     *\n*            nnn  is the SVC number you want to install;              *\n*                 it must be specified as a 3-digit number.           *\n*                                                                     *\n*            mmmmmmmm is the name of a load module (or alias)         *\n*                 that you want to install as SVC nnn; it MUST        *\n*                 come from an authorized library (STEPLIB or         *\n*                 link-list).  If the SVC number is 109, the          *\n*                 load-module name must be IGX00nnn, where            *\n*                 nnn is the number of the ESR entry.                 *\n*                                                                     *\n*            lock is the optional lock bit string which must be       *\n*                 specified as follows:                               *\n*                 .  8000 indicates the local lock                    *\n*                 .  C000 indicates the CMS and local locks           *\n*                                                                     *\n*            hhmm is the optional \"good-night\" time, in 24-hour       *\n*                 clock format.  When the specified time is           *\n*                 reached, SVCUPDTE automatically un-installs         *\n*                 the SVC and stops.                                  *\n*                                                                     *\n*            userid is the user-ID that will be compared to that      *\n*                 of each invoker of the new SVC routine.             *\n*                 If they're equal, the new SVC is invoked.           *\n*                 If they're not equal, the old SVC is invoked.       *\n*                                                                     *\n* RETURN CODES = See Below                                            *\n*                                                                     *\n*        0  Successful completion: SVC has been installed             *\n*                                                                     *\n*        8  User not authorized to update SYS1.PARMLIB                *\n*                                                                     *\n*       12  ENQ failed: Another copy of SVCUPDTE is currently         *\n*           installing the same SVC                                   *\n*                                                                     *\n*       24  Current SVC entry is not Type 2,3,4                       *\n*                                                                     *\n* ABENDS = See below                                                  *\n*                                                                     *\n*      U1001    Invalid PARM                                          *\n*                                                                     *\n*      S047     SVCUPDTE MODULE NOT AUTHORIZED                        *\n*                                                                     *\n*      S306-08  SVC routine not re-entrant                            *\n*                                                                     *\n*      S306-0C  SVC routine not from an authorized library            *\n*                                                                     *\n* EXAMPLES = See below                                                *\n*                                                                     *\n*      1. install IGC0022B as SVC 222                                 *\n*                                                                     *\n*         //SVC222  EXEC PGM=SVCUPDTE,PARM=(222,IGC0022B)             *\n*                                                                     *\n*      2. install IGX00066 as type-3 ESR 66                           *\n*                                                                     *\n*         //ESR66   EXEC PGM=SVCUPDTE,PARM=(109,IGX00066)             *\n*                                                                     *\n*      3. install TESTSVC2 as SVC 244 until 20:00                     *\n*                                                                     *\n*         //TEMPSVC EXEC PGM=SVCUPDTE,PARM=(244,TESTSVC2,,2000)       *\n*                                                                     *\n*      4. install SVC11Y2K as SVC 11 until 18:00 for user(IBMUSER)    *\n*                                                                     *\n*         //SVC11TMP EXEC PGM=SVCUPDTE,                               *\n*         //              PARM=(011,SVC11Y2K,,1800,IBMUSER)           *\n*                                                                     *\n*      5. permanently install an SVC routine from the same private    *\n*         library from which SVCUPDTE is executed.                    *\n*                                                                     *\n*        //LOADMLPA EXEC PGM=LOADMLPA,PARM=(LOAD,SVC11Y2K)            *\n*        //STEPLIB  DD DSN=SYS1.P390.LINKLIB,DISP=SHR                 *\n*        //*                                                          *\n*        //FETCHLIB EXEC PGM=IEFBR14                                  *\n*        //SVCUPDTE DD DSN=SYS1.P390.LINKLIB(SVCUPDTE),DISP=SHR       *\n*        //*                                                          *\n*        //INSTALL  EXEC PGM=*.FETCHLIB.SVCUPDTE,PARM=(011,SVC11Y2K)  *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n*228 Leave SVC installed and exit if module was loaded from LPA       *\n*229 Issue ENQ on SYSZSVC/TABLE to prevent simultaneous updates       *\n*230 Restore address of OLD SVC after temporary installation          *\n*231 Fix \"good-night\" routine which hasn't been working for a while   *\n*232 Restrict access to new SVC to userid specified in parm           *\n*306 Install IGX00nnn module as a type-3 ESR.                         *\n*307 Parm option for LOCAL and CMS locks                              *\n*308 More doc, minor technical changes                                *\n*309 Wait for one second before final FREEMAIN                        *\n***********************************************************************\nSVCUPDTE CSECT\nSVCUPDTE AMODE 31\n         SAVE  (14,12),,'GSF Utilities - SVCUPDTE R309'\n         LR    R12,R15\n         USING SVCUPDTE,R12\n         L     R4,0(,R1)               PARM ADDRESS\n*\n*        ALLOCATE DYNAMIC STORAGE\n*\n         GETMAIN R,LV=DYNAML           DYNAMIC STORAGE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DYNAM,R13\n         LA    R14,DYNAM+72            CLEAR WORK AREA\n         LA    R15,DYNAML-72           CLEAR WORK AREA\n         SLR   R1,R1                   CLEAR WORK AREA\n         MVCL  R14,R0                  CLEAR WORK AREA\n*\n*        CHECK JCL PARM\n*\nSCANPARM L     R15,=A(PARSE)           parse rtne addr\n         BALR  R14,R15                 parse parm into function,opt\n         DC    S(L'SVCNO,SVCNO)        first operand\n         DC    S(L'EPNAME,EPNAME)      second operand\n         DC    S(L'LOCKS,LOCKS)        third operand\n         DC    S(L'ENDOFDAY,ENDOFDAY)  fourth operand\n         DC    S(L'USERID,USERID)      fifth operand\n         CLI   LOCKS,C' '              any lock?\n         BE    LOCK6                   no, jump\n         CLC   =C'C000 ',LOCKS         CMS+local?\n         BE    LOCK4                   yes, jump\n         CLC   =C'8000 ',LOCKS         Local lock?\n         BNE   PARMERR                 no, abend\n         MVI   LOCK#,X'80'             local lock\n         B     LOCK6                   continue\nLOCK4    MVI   LOCK#,X'C0'             CMS+local\nLOCK6    EQU   *\n         UNPK  DWD,=X'0F'              DWD=F0F0F0F0F0F0F0F0\n         MVN   DWD(L'SVCNO),SVCNO      move nnn\n         CLC   DWD(L'SVCNO),SVCNO      nnn numeric?\n         BNE   PARMERR                 NO, ABEND\n         CLI   ENDOFDAY,C' '           ENDOFDAY specified?\n         BE    INIT34                  no, quit\n         MVN   DWD(4),ENDOFDAY         move HHMM\n         CLC   DWD(4),ENDOFDAY         hhmm numeric?\n         BNE   PARMERR                 NO, ABEND\n         MVC   ENDOFDAY,DWD            HHMM -> HHMM0000\n*\n*        Retrieve old SVC entry\n*\nINIT34   EQU   *\n         PACK  DWD,SVCNO               SVC NUMBER (NNN)\n         CVB   R5,DWD                  SVC NUMBER (NNN)\n         STC   R5,SVC#                 SVC NUMBER (NNN)\n*\n         L     R3,CVTPTR               CVT\n         USING CVTMAP,R3\n         L     R4,CVTABEND             SECONDARY CVT\n         USING SCVTSECT,R4\n         SLL   R5,3                    mult by 8\n         AL    R5,SCVTSVCT             add origin of SVC table\n         USING SVCENTRY,R5\n         ST    R5,SVCENTRY_PTR         save entry address\n         TM    SVCTP,SVCTP2            TYPE 2/3/4 ?\n         BNO   RC24                    NO, QUIT\n*\n*        ESR   PARM='109,IGX00nnn'\n*\n         CLI   SVC#,109                T3-ESR?\n         BNE   INIT39                  no, jump\n         UNPK  DWD,=X'0F'              DWD=F0F0F0F0F0F0F0F0\n         MVN   DWD(5),EPNAME+3         move 00nnn from IGX00nnn\n         CLC   DWD(5),EPNAME+3         00nnn numeric?\n         BNE   PARMERR                 NO, ABEND\n         PACK  DWD,EPNAME+3(5)         ESR NUMBER (NNN)\n         CVB   R1,DWD                  ESR NUMBER (NNN)\n         STC   R5,ESR#                 ESR NUMBER (NNN)\n         SLL   R1,3                    mult by 8\n         L     R5,SVCEP                point to ESR table\n         LA    R5,SVCENTRY+8(R1)       point to ESR entry\n         ST    R5,SVCENTRY_PTR         save entry address\n*\nINIT39   EQU   *\n         MVC   OLDENTRY,SVCENTRY       save old SVC entry\n         MODESET MODE=SUP              check that I'm APF-authorized\n***********************************************************************\n*                                                                     *\n*        CHECK THAT THE USER HAS \"UPDATE\" AUTHORITY TO SYS1.PARMLIB.  *\n*                                                                     *\n*        IF HE DOESN'T, EXIT WITH RC=8                                *\n*                                                                     *\n***********************************************************************\n         L     R14,RACF_CML            CAMLST 1ST WORD\n         LA    R15,RACF_DSN            DATA SET NAME\n         SLR   R0,R0\n         LA    R1,RACFWORK             WORK AREA\n         STM   R14,R1,SIXWORDS         STORE RELOCATED CAMLST\n         LOCATE SIXWORDS               GET VOLSER AND DEVICE TYPE\n         LTR   R15,R15                 CHECK FOR SUCCESSFUL COMPLETION\n         BNZ   RACF_BAD                LOCATE FAILED, EXIT\n         MVC   RACF_VOL,RACFWORK+6     VOLSER\n*\n         MVC   RACF_DYN(RACF_LEN),RACF_MOD\n         RACROUTE REQUEST=AUTH,                                        X\n               WORKA=RACFWORK,                                         X\n               VOLSER=RACF_VOL,        VOLUME                          X\n               MF=(E,RACF_DYN)\n         LTR   R15,R15                 USER AUTHORIZED?\n         BZ    INSTALL                 YES, CONTINUE\n*\n*        Allow selected users to bypass RACF protection\n*\n         L     R2,PSAAOLD-PSA          POINT TO MY ASCB.\n         L     R2,ASCBASXB-ASCB(,R2)   POINT TO MY ASXB.\n         L     R2,ASXBSENV-ASXB(,R2)   POINT TO MY ACEE.\n         USING ACEE,R2\n         CLC   =CL8'IBMUSER',ACEEUSRI  AUTHORIZED USER?\n         BE    INSTALL                 YES, CONTINUE\n         DROP  R2                      ACEE\n*\nRACF_BAD L     R13,4(,R13)\n         RETURN (14,12),RC=8           User is not authorized, RC=8\n****     ABEND  1002,DUMP\n*\nRACF_MOD RACROUTE REQUEST=AUTH,        CHECK AUTHORIZATION             X\n               LOG=NONE,               DO NOT LOG FAILURES             X\n               CLASS='DATASET',        CHECK FOR DATASET AUTHORITY     X\n               ENTITY=RACF_DSN,        DATA SET NAME                   X\n               ATTR=UPDATE,            MUST BE ALLOWED TO UPDATE       X\n               MF=L\nRACF_DSN DC    CL44'SYS1.PARMLIB'\nRACF_CML CAMLST NAME,*-*,,*-*          CAMLST FOR LOCATE\n*\nPARMERR  WTO    'SVCUPDTE: INVALID PARM <====',ROUTCDE=11\n         ABEND  1001,DUMP\n*\nRC24     L     R13,4(,R13)\n         RETURN (14,12),RC=24          entry is not Type 2,3,4\n*\n***********************************************************************\n*                                                                     *\n*        FUNCTION=INSTALL                                             *\n*                                                                     *\n***********************************************************************\n*\nINSTALL  MVC   SVCULIST(MODELS_L),MODELS   MF=L MACROS\n         MVC   SVCULOCK,LOCK#          move lock indicators\n*\n         ENQ   (,SVCNO),MF=(E,ENQL)    serialize update\n         LTR   R15,R15                 ENQ OK?\n         BZ    INSTALL4                yes, jump\n         L     R13,4(,R13)\n         RETURN (14,12),RC=12          no, exit with RC=12\n*\nINSTALL4 LOAD  EPLOC=EPNAME,           name of SVC routine             X\n               GLOBAL=YES,             load into SP 241                X\n               SF=(E,LOAD4L)\n         LR    R6,R0                   ENTRY POINT\n*\n         LA    R10,DWD                 address work area\n         SYNCH UPDATE,STATE=SUPV,RESTORE=YES Update SVC table entry\n*\n         CLI   ENDOFDAY,C' '           good night time specified?\n         BNE   CHKUSER                 yes, jump\n         CLI   USERID,C' '             userid screening requested?\n         BNE   CHKUSER                 yes, jump\n*\n*        Check if the module just loaded was in LPA.\n*        If it was, exit immediately.\n*\nCHECKLPA L     R2,PSATOLD-PSA          MY TCB\n         USING TCB,R2\n         L     R2,TCBLLS               last LLE\n         USING LLE,R2\n         L     R2,LLECDPT              Corresponding CDE or LPDE\n         USING CDENTRY,R2\n         TM    CDATTR,CDNIP            An LPA module?\n         BNO   CHKUSER                 No, jump\n         CLC   EPNAME,CDNAME           Right module?\n         BNE   CHKUSER                 No, jump\n         CL    R6,CDENTPT              Right entry point address?\n         BE    EXIT                    YES, EXIT\n*\n***********************************************************************\n*                                                                     *\n*        FUNCTION=CHKUSER                                             *\n*                                                                     *\n*        Allocate storage in SQA, move the user-ID screening code     *\n*        into it and set its address into the SVC table.              *\n*                                                                     *\n***********************************************************************\n*\nCHKUSER  CLI   USERID,C' '             userid screening requested?\n         BE    WAIT                    yes, jump\n*\n         GETMAIN RU,SP=245,LV=CHKU500L,LOC=ANY   SQA space\n         ST    R1,SQA_ADDR             work-area in SQA\n*\n         MODESET EXTKEY=ZERO\n         MVC   0(CHKU500L,R1),CHKU500  move screening code to SQA\n         USING CHKU500,R1\n         ST    R6,CHKU500N             addr of new SVC\n         MVC   CHKU500O,OLDENTRY       addr of old SVC\n         MVC   CHKU500U,USERID         user-ID\n         MVC   CHKU500#,SVCNO          SVC number\n         DROP  R1                      CHKU500 in SQA\n         LR    R6,R1                   SVC screening code\n         BSM   R6,0                    set AMODE bit\n         MODESET EXTKEY=ZERO\n*\n         LA    R10,DWD                 address work area\n         SYNCH UPDATE,STATE=SUPV,RESTORE=YES Restore old SVC entry\n*\n***********************************************************************\n*                                                                     *\n*        FUNCTION=WAIT                                                *\n*                                                                     *\n*        This routine sets-up a timer for automatic shut-down         *\n*        (if user specified a \"good-night\" time).  It then waits      *\n*        on the communication ECB which is posted by a STOP           *\n*        command or when the timer interval expires.                  *\n*                                                                     *\n***********************************************************************\n*\nWAIT     MODESET EXTKEY=ZERO\n*\n         L     R2,PSAAOLD-PSA          MY ASCB\n         OI    ASCBRCTF-ASCB(R2),ASCBTOFF   PREVENT S522\n*\n         MODESET KEY=NZERO\n*\n         EXTRACT COMMADDR,FIELDS=COMM,MF=(E,EXTRACTL)\n         L     R2,COMMADDR             ECB/CIB POINTERS\n*\n         CLI   ENDOFDAY,C'0'           good night time specified?\n         BL    SET_RCVY                no, do not set a timer\n         STIMERM SET,                                                  X\n               ID=TIMER_ID,            token                           X\n               EXIT=GOODNITE,          exit rtne                       X\n               LT=ENDOFDAY,            hhmmss                          X\n               PARM=(R2),              ECB/CIB POINTERS                X\n               MF=(E,STIMER_L)\n*\nSET_RCVY ESTAE CANCEL,CT,                                              X\n               PARAM=SAVE2,            parameter                       X\n               TERM=YES,               trap CANCEL commands            X\n               MF=(E,ESTAEL)\n*\n         L     R1,0(,R2)               PICK UP ADDRESS OF COMM ECB\n         WAIT  1,ECB=(R1),LONG=YES     WAIT FOR A STOP COMMAND\n*\n         ESTAE 0                       DO NOT TRAP CANCEL COMMANDS\n*\n***********************************************************************\n*                                                                     *\n*        FUNCTION=REMOVE                                              *\n*                                                                     *\n*        This routine re-instates the initial SVC entry saved in the  *\n*        OLDENTRY area, frees-up storage and exits to the system.     *\n*                                                                     *\n***********************************************************************\n*\n         L     R6,OLDENTRY             Addr of old SVC entry\n         LA    R10,DWD                 address work area\n         SYNCH UPDATE,STATE=SUPV,RESTORE=YES Restore old SVC entry\n         STH   R15,RETCODE             return code\n*\n         ICM   R1,B'1111',SQA_ADDR     work-area in SQA\n         BZ    EXIT                    no, exit\n         FREEMAIN RU,SP=245,A=(R1),LV=CHKU500L SQA space\n*\nEXIT     LH    R15,RETCODE             return code\n         L     R13,4(,R13)\n         RETURN (14,12),RC=(15)\n         DROP\n*\n*---------------------------------------------------------------------*\n*                                                                     *\n*        USER-ID SCREENING ROUTINE                                    *\n*                                                                     *\n*        This code is moved to SQA and executes from there each       *\n*        time a program issues an SVC instruction for the new SVC.    *\n*        If the user-id of the invoker is equal to the user-id        *\n*        specified in the parm, then the new SVC is invoked,          *\n*        otherwise the old code is called.                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n*\n         USING TCB,R4\n         USING CHKU500,R6\n         USING ASCB,R7\nCHKU500  B     CHKU510                 branch around eye-catcher\n         DC    C'SVCUPDTE UTILITY - USER-ID SCREENING',0H'0'\nCHKU510  L     R2,PSAAOLD-PSA          POINT TO MY ASCB.\n         L     R2,ASCBASXB-ASCB(,R2)   POINT TO MY ASXB.\n         ICM   R2,B'1111',ASXBSENV-ASXB(R2) POINT TO MY ACEE.\n         BZ    CHKU530                 no ACEE, use old code\n         USING ACEE,R2\n         CLC   ACEEUSRI,CHKU500U       AUTHORIZED USER?\n         BE    CHKU540                 yes, use new code\nCHKU530  L     R6,CHKU500O             OLD SVC\n         BSM   0,R6\nCHKU540  L     R6,CHKU500N             NEW SVC\n         BSM   0,R6\nCHKU500O DS    V                       OLD ENTRY\nCHKU500N DS    V                       NEW ENTRY\nCHKU500U DS    CL8                     USER-ID\nCHKU500# DS    C'222'                  SVC number\nCHKU500L EQU   *-CHKU500\n         DROP\n*\n*---------------------------------------------------------------------*\n*                                                                     *\n*        END-OF-DAY ROUTINE                                           *\n*                                                                     *\n*        This routine executes at the end of the timer interval       *\n*        when the user specified a \"good-night\" time in the parm.     *\n*        It posts the communication ECB to simulate a STOP command    *\n*        and allow the main-line to shutdown.                         *\n*                                                                     *\n*---------------------------------------------------------------------*\n*\nGOODNITE BALR  R10,0                   LOCAL BASE\n         USING *,R10\n         L     R2,4(,R1)               COMM ECB ADDR\n*@SNAP ((R1),8),((R2),4)\n         MODESET KEY=ZERO              Switch to key=zero\n         POST  (R2),0                  SIMULATE STOP COMMAND\n         SVC   3                       EXIT\n         DROP\n*\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ESTAE EXIT USED TO TRAP CANCEL COMMANDS                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n*\nCANCEL   SAVE  (14,12),,*\n         LR    R10,R15\n         USING CANCEL,R10\n         LR    R8,R1                   SDWA\n         USING SDWA,R8\n         LR    R0,R13\n         L     R13,SDWAPARM            A(SAVE2)\n         ST    R0,4(,R13)\n         USING SAVE2,R13\n*\n         L     R6,OLDENTRY             Addr of old SVC entry\n         LA    R10,DWD                 address work area\n         SYNCH UPDATE,STATE=SUPV,RESTORE=YES Update SVC table entry\n*\n         ICM   R1,B'1111',SQA_ADDR     work-area in SQA\n         BZ    CANCEL99                no, exit\n         STIMER WAIT,BINTVL=ONESEC     wait for one second\n         FREEMAIN RU,SP=245,A=(R1),LV=CHKU500L SQA space\n*\nCANCEL99 L     R13,4(,R13)\n         SETRP WKAREA=(R8),REGS=(14,12),RC=00\n         DROP\n*\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Update SVC Table Entry                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n*\nUPDATE   BALR  R11,0\n         USING *,R11\n         USING DWD,R10\n*\n         ENQ   MF=(E,ENQ_TABLE)        SYSZSVC/TABLE/SYSTEM\n         MODESET EXTKEY=ZERO\n         L     R5,SVCENTRY_PTR         point at SVC table entry\n         USING SVCENTRY,R5\n*\n         CLI   SVC#,109                ESR?\n         BE    UPDATE6                 yes, jump\n*\n         SLR   R2,R2\n         IC    R2,SVC#                 pick up SVC number\n         SVCUPDTE (R2),EP=(R6),MF=(E,SVCULIST)\n         LR    R3,R15                  return code\n         B     UPDATE7\n*\nUPDATE6  EQU   *                       ESR\n         PGSER R,UNPROTECT,A=SVCENTRY,EA=SVCENTRY+1\n         ST    R6,SVCEP                ESRTABLE\n         SLR   R3,R3                   rc=0\n         PGSER R,PROTECT,A=SVCENTRY,EA=SVCENTRY+1\n*\nUPDATE7  EQU   *\n         DEQ   MF=(E,ENQ_TABLE)        SYSZSVC/TABLE/SYSTEM\n         LR    R15,R3                  pass return code\n         SVC   3                       goback to synch\n***********************************************************************\n*                                                                     *\n*        Model storage, moved to dynamic                              *\n*                                                                     *\n***********************************************************************\nMODELS   SVCUPDTE 0,REPLACE,TYPE=4,EP=0,MF=L\n         ENQ   (QNAME1,*-*,E,L'SVCNO,SYSTEM),RET=USE,MF=L\n         ENQ   (SYSZSVCQ,SYSZSVCR,E,,SYSTEM),MF=L\nMODELS_L EQU   *-MODELS\n*\nQNAME1   DC    C'SVCUPDTE'             QNAME for ENQ\nSYSZSVCQ DC    C'SYSZSVC '             QNAME for ENQ\nSYSZSVCR DC    C'TABLE'                RNAME for ENQ\nONESEC   DC    FL4'100'                One Second (STIMER)\n***********************************************************************\n*                                                                     *\n*        PARSE A COMMA-DELIMITED JCL PARM                             *\n*                                                                     *\n*        L     R15,=A(PARSE)                                          *\n*        BALR  R14,R15                                                *\n*        DC    S(L'PARM1,PARM1)        LENGTH,ADDR                    *\n*        DC    S(L'PARM2,PARM2)        LENGTH,ADDR                    *\n*                                                                     *\n***********************************************************************\nPARSE    CSECT\n         SAVE  (14,12),,PARSE\n         BALR  R11,0\n         USING *,R11\n         LH    R5,0(,R4)               LENGTH OF PARM\n         LA    R4,1(,R4)               START OF PARM - 1\n         ALR   R5,R4                   LAST BYTE OF PARM\n*LOOP\nPARS1    SLR   R0,R0                   R0 = 00000000\n         ICM   R0,B'0011',2(R14)       R0 = 0000BDDD\n         SRDL  R0,12(0)                R0 = 0000000B, R1= BBB.....\n         SRL   R1,20(0)                R1 = 00000DDD DISPLACEMENT\n         ALR   R1,R13                  ADD CALLER'S SAVE AREA ADDR\n         LR    R6,R1                   ADDR OF TARGET FIELD\n         LH    R7,0(,R14)              LENGTH OF TARGET FIELD\n*\n         LA    R2,1(,R4)               FIRST BYTE OF CURRENT PARAMETER\n*--LOOP\nPARS2    LA    R4,1(,R4)               BUMP POINTER\n         CLR   R4,R5                   END OF PARM REACHED?\n         BH    PARS41                  YES, EXIT LOOP\n         CLI   0(R4),C','              DELIMITER?\n         BNE   PARS2                   NO, KEEP LOOPIN'\n*--ENDLOOP\nPARS41   LR    R3,R4                   POSITION OF ','\n         SR    R3,R2                   LENGTH OF SOURCE PARAM\n         ICM   R3,B'1000',PARSEPAD     PADDING\n         MVCL  R6,R2                   MOVE SOURCE TO TARGET\nPARS44   LA    R14,2+2(,R14)           NEXT TARGET\n         CLI   0(R14),0                IS THIS A FIELD DESCRIPTOR?\n         BE    PARS1                   YES, PROCESS IT\n*ENDLOOP\n         RETURN (0,12),T\nPARSEPAD DC    C' '                    padding\n***********************************************************************\n*                                                                     *\n*        DYNAMIC STORAGE                                              *\n*                                                                     *\n***********************************************************************\nDYNAM    DSECT\n         DS    18F                    save area\nSAVE2    DS    18F                    save area for ESTAE routine\nDWD      DS    D\nSVCENTRY_PTR DS A(SVCENTRY)           SVC or ESR entry\nTIMER_ID DS    F\nSIXWORDS DS    6F                     WORK AREA\n*\nLOAD4L   LOAD  SF=L\nEXTRACTL EXTRACT *-*,FIELDS=COMM,MF=L\nCOMMADDR DS    A\nESTAEL   ESTAE MF=L\nSTIMER_L STIMERM SET,MF=L\nRETCODE  DS    H                      return-code\nSQA_ADDR DS    A(CHKU500)             work-area in SQA\nOLDENTRY DS    D                      old SVC entry\nSVCNO    DS    Z'222'                 SVC number\nEPNAME   DS    C'IGC0022B'            name of SVC routine\nLOCKS    DS    C'8000 '               lock indtcators: 8000 or C000\nENDOFDAY DC    Z'19000000'            CUTOFF TIME: HHMMSSHH\nUSERID   DS    CL8                    user-ID\nSVC#     DS    X                      SVC number\nESR#     DS    X                      ESR number\nLOCK#    DS    X'80'                  locks in binary: 80 or C0\n*\nRACF_DYN RACROUTE REQUEST=AUTH,MF=L\nRACF_LEN EQU   *-RACF_DYN\nRACFWORK DS    64D                    RACROUTE WORK AREA (512 BYTES)\nRACF_VOL DS    C'SYSRES'              VOLSER\n*\n*        Parameter lists initialized from \"models\"\n*\nSVCULIST SVCUPDTE 0,REPLACE,TYPE=4,EP=0,MF=L\nSVCULOCK EQU   SVCULIST+10,1,C'X'\nENQL     ENQ   (QNAME1,*-*,E,L'SVCNO,SYSTEMS),RET=USE,MF=L\nENQ_TABLE ENQ  (SYSZSVCQ,SYSZSVCR,E,,SYSTEM),MF=L\nDYNAML   EQU   *-DYNAM\n***********************************************************************\n         PRINT NOGEN\n         IHAPSA DSECT=YES\n         CVT   DSECT=YES,LIST=NO\n         IHASCVT DSECT=YES,LIST=NO     SECONDARY CVT\n         IHASVC                        SVC TABLE ENTRY\n         IHAASCB DSECT=YES,LIST=NO\n         IHAASXB\n         IHAACEE\n         IKJTCB DSECT=YES,LIST=NO\n         IHALLE\n         IHACDE\n         IHASDWA DSECT=YES,VRAMAP=NO\n         YREGS\n         END   SVCUPDTE\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,3)\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//SYSPRINT DD SYSOUT=*\n//*\n//LKED    EXEC PGM=LINKLLA,PARM='MAP,RENT,AC=1'\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,DELETE)\n//SYSLMOD  DD DSN=SYS1.P390.LINKLIB(SVCUPDTE),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//*\n//INSTALL EXEC PGM=SVCUPDTE,PARM=(244,IEFBR14,8000)\n//SYSUDUMP DD SYSOUT=*\n//\n//*\n//ESR     EXEC PGM=SVCUPDTE,PARM=(109,IGX00000)\n//SYSUDUMP DD SYSOUT=*\n//*\n//TEMP    EXEC PGM=SVCUPDTE,\n// PARM='222,IGC0022B,1100,&SYSUID'\n//SYSUDUMP DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SWAREQ": {"ttr": 19970, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x01\\x00P\\x00\\x96\\x06O\\x01\\x15'_\\x14G\\x000\\x00\\x12\\x00\\x01\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "02.01", "flags": 0, "createdate": "1996-03-04T00:00:00", "modifydate": "2015-10-02T14:47:50", "lines": 48, "newlines": 18, "modlines": 1, "user": "SBGOLOB"}, "text": "/*----REXX------------------------------------------------------------*\\\n|*                                                                    *|\n|* MODULE NAME = SWAREQ                                               *|\n|*                                                                    *|\n|* DESCRIPTIVE NAME = Convert an SVA to a 31-bit address              *|\n|*                                                                    *|\n|* STATUS = R200                                                      *|\n|*                                                                    *|\n|* FUNCTION = The SWAREQ function simulates the SWAREQ macro to       *|\n|*            convert an SWA Virtual Address (SVA) to a full 31-bit   *|\n|*            address which can be used to access SWA control blocks  *|\n|*            in the SWA=ABOVE environment.  The input is a 3-byte    *|\n|*            SVA; the output value is a 10-digit decimal number.     *|\n|*                                                                    *|\n|* AUTHOR   =  Gilbert Saint-Flour <carlos@gsf-soft.com>              *|\n|*                                                                    *|\n|* DEPENDENCIES = TSO/E V2                                            *|\n|*                                                                    *|\n|* SYNTAX   =  SWAREQ(sva)                                            *|\n|*                                                                    *|\n|*             sva must contain a 3-byte SVA.                         *|\n|*                                                                    *|\n|* Sample Invocation:                                                 *|\n|*                                                                    *|\n|*    NUMERIC DIGITS 10                                               *|\n|*    tcb = C2D(STORAGE(21C,4))         /* TCB          PSATOLD  */   *|\n|*    tiot= C2D(STORAGE(D2X(tcb+12),4)) /* TIOT         TCBTIO   */   *|\n|*    sva = STORAGE(D2X(tiot+36),3)     /* First JFCB   TIOEJFCB */   *|\n|*    jfcb=SWAREQ(sva)             /* convert SVA to 31-bit addr */   *|\n|*    dsn=STORAGE(D2X(jfcb),44)         /* dsname       JFCBDSNM */   *|\n|*    vol=STORAGE(D2X(jfcb+118),6)      /* volser       JFCBVOLS */   *|\n|*    SAY 'sva='C2X(sva) 'jfcb='D2X(jfcb) 'dsn='dsn 'vol='vol         *|\n|*                                                                    *|\n\\*--------------------------------------------------------------------*/\n/*SWAREQ: PROCEDURE */\n  IF RIGHT(C2X(ARG(1)),1) \\= 'F' THEN       /* SWA=BELOW ?          */\n    RETURN C2D(ARG(1))+16                   /* yes, return sva+16   */\n  NUMERIC DIGITS 10                         /* allow up to 7FFFFFFF */\n  sva=C2D(ARG(1))                           /* convert to decimal   */\n  tcb = C2D(STORAGE(21C,4))                 /* TCB         PSATOLD  */\n  jscb = C2D(STORAGE(D2X(tcb+180),4))       /* JSCB        TCBJSCB  */\n  qmpl = C2D(STORAGE(D2X(jscb+244),4))      /* QMPL        JSCBQMPI */\n  qmat = C2D(STORAGE(D2X(qmpl+24),4))       /* QMAT        QMADD    */\n    DO WHILE sva>65536\n      qmat = C2D(STORAGE(D2X(qmat+12),4)) /* next QMAT     QMAT+12  */\n      sva=sva-65536                         /* 010006F -> 000006F   */\n    END\n  RETURN C2D(STORAGE(D2X(qmat+sva+1),4))+16\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SWAREQ2#": {"ttr": 19972, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x11\\x01\\x15'_\\x01\\x15'_\\x14\\x05\\x00P\\x00P\\x00\\x00\\xd7\\xd6\\xc9\\xe3\\xd9\\xc1\\xe2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2015-10-02T00:00:00", "modifydate": "2015-10-02T14:05:11", "lines": 80, "newlines": 80, "modlines": 0, "user": "POITRAS"}, "text": "Subject:  FILE183 - SWAREQ update for z/OS 2.2\nFrom:     Don Poitras <sasdtp@sas.com>\nDate:     10/1/2015 3:05 PM\nTo:       <sbgolob@cbttape.org>\n\nSam,\n  IBM broke Gilbert's SWAREQ exec at z/OS 2.2 by moving a control\n  block above the bar. We use this as a basis for an IPCS REXX\n  exec we use, so I researched what would be needed to fix it.\n  Here's what I came up with:\n\n/*--------------------------------------------------------------------*\\\n|*                                                                    *|\n|* MODULE NAME = SWAREQ                                               *|\n|*                                                                    *|\n|* DESCRIPTIVE NAME = Convert an SVA to a 31-bit address              *|\n|*                                                                    *|\n|* STATUS = R200                                                      *|\n|*                                                                    *|\n|* FUNCTION = The SWAREQ function simulates the SWAREQ macro to       *|\n|*            convert an SWA Virtual Address (SVA) to a full 31-bit   *|\n|*            address which can be used to access SWA control blocks  *|\n|*            in the SWA=ABOVE environment.  The input is a 3-byte    *|\n|*            SVA; the output value is a 10-digit decimal number.     *|\n|*                                                                    *|\n|* AUTHOR   =  Gilbert Saint-Flour <gsf@pobox.com>                    *|\n|*                                                                    *|\n|* DEPENDENCIES = TSO/E V2                                            *|\n|*                                                                    *|\n|* SYNTAX   =  SWAREQ(sva)                                            *|\n|*                                                                    *|\n|*             sva must contain a 3-byte SVA.                         *|\n|*                                                                    *|\n|* Sample Invocation:                                                 *|\n|*                                                                    *|\n|*    NUMERIC DIGITS 10                                               *|\n|*    tcb = C2D(STORAGE(21C,4))         /* TCB          PSATOLD  */   *|\n|*    tiot= C2D(STORAGE(D2X(tcb+12),4)) /* TIOT         TCBTIO   */   *|\n|*    sva = STORAGE(D2X(tiot+36),3)     /* First JFCB   TIOEJFCB */   *|\n|*    jfcb=SWAREQ(sva)             /* convert SVA to 31-bit addr */   *|\n|*    dsn=STORAGE(D2X(jfcb),44)         /* dsname       JFCBDSNM */   *|\n|*    vol=STORAGE(D2X(jfcb+118),6)      /* volser       JFCBVOLS */   *|\n|*    SAY 'sva='C2X(sva) 'jfcb='D2X(jfcb) 'dsn='dsn 'vol='vol         *|\n|*                                                                    *|\n\\*--------------------------------------------------------------------*/\n/*SWAREQ: PROCEDURE */\nNUMERIC DIGITS 20                         /* allow up to 2**64    */\nsva=C2D(ARG(1))                           /* convert to decimal   */\ntcb = C2D(STORAGE(21C,4))                 /* TCB         PSATOLD  */\njscb = C2D(STORAGE(D2X(tcb+180),4))       /* JSCB        TCBJSCB  */\nqmpl = C2D(STORAGE(D2X(jscb+244),4))      /* QMPL        JSCBQMPI */\n/* See if qmat can be above the bar */\nqmsta= C2X(STORAGE(D2X(qmpl+16),1))       /* JOB STATUS BYTE      */\nif SUBSTR(X2B(qmsta),6,1) then            /* is QMQMAT64 bit on?  */\ndo                                        /* yes, qmat can be ATB */\n  IF RIGHT(X2B(C2X(ARG(1))),1) \\= '1' THEN/* SWA=BELOW ?          */\n    RETURN C2D(ARG(1))+16                 /* yes, return sva+16   */\n  qmat=C2D(STORAGE(D2X(qmpl+10),2))*(2**48) +,/* QMAT+0  QMADD01  */\n       C2D(STORAGE(D2X(qmpl+18),2))*(2**32) +,/* QMAT+2  QMADD23  */\n       C2D(STORAGE(D2X(qmpl+24),4))       /* QMAT+4      QMADD    */\n  RETURN C2D(STORAGE(D2X(qmat+(sva*12)+64),4))+16\nend\nelse\ndo                                        /* no, qmat is BTB      */\n  IF RIGHT(C2X(ARG(1)),1) \\= 'F' THEN     /* SWA=BELOW ?          */\n    RETURN C2D(ARG(1))+16                 /* yes, return sva+16   */\n  qmat = C2D(STORAGE(D2X(qmpl+24),4))     /* QMAT        QMADD    */\n  DO WHILE sva>65536\n    qmat = C2D(STORAGE(D2X(qmat+12),4))   /* next QMAT   QMAT+12  */\n    sva=sva-65536                         /* 010006F -> 000006F   */\n  END\n  RETURN C2D(STORAGE(D2X(qmat+sva+1),4))+16\nend\n\nI tested this on our 2.2 system. Of course, no guarantees as the\nQMAT is OCO.\n\n--\nDon Poitras - zSeries R & D  -  SAS Institute Inc. -  SAS Campus Drive\nmailto:sasdtp@sas.com   (919)531-5637  Fax:677-4444     Cary, NC 27513\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SWAREQ22": {"ttr": 19975, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00B\\x01\\x15'_\\x01\\x15'_\\x144\\x00>\\x00P\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "2015-10-02T00:00:00", "modifydate": "2015-10-02T14:34:42", "lines": 62, "newlines": 80, "modlines": 0, "user": "SBGOLOB"}, "text": "/*---- REXX ---- */ /*------------------------------------------------*\\\n|*                                                                    *|\n|* MODULE NAME = SWAREQ                                               *|\n|*                                                                    *|\n|* DESCRIPTIVE NAME = Convert an SVA to a 31-bit address              *|\n|*                                                                    *|\n|* STATUS = R200                                                      *|\n|*                                                                    *|\n|* FUNCTION = The SWAREQ function simulates the SWAREQ macro to       *|\n|*            convert an SWA Virtual Address (SVA) to a full 31-bit   *|\n|*            address which can be used to access SWA control blocks  *|\n|*            in the SWA=ABOVE environment.  The input is a 3-byte    *|\n|*            SVA; the output value is a 10-digit decimal number.     *|\n|*                                                                    *|\n|* AUTHOR   =  Gilbert Saint-Flour <gsf@pobox.com>                    *|\n|*                                                                    *|\n|* DEPENDENCIES = TSO/E V2                                            *|\n|*                                                                    *|\n|* SYNTAX   =  SWAREQ(sva)                                            *|\n|*                                                                    *|\n|*             sva must contain a 3-byte SVA.                         *|\n|*                                                                    *|\n|* Sample Invocation:                                                 *|\n|*                                                                    *|\n|*    NUMERIC DIGITS 10                                               *|\n|*    tcb = C2D(STORAGE(21C,4))         /* TCB          PSATOLD  */   *|\n|*    tiot= C2D(STORAGE(D2X(tcb+12),4)) /* TIOT         TCBTIO   */   *|\n|*    sva = STORAGE(D2X(tiot+36),3)     /* First JFCB   TIOEJFCB */   *|\n|*    jfcb=SWAREQ(sva)             /* convert SVA to 31-bit addr */   *|\n|*    dsn=STORAGE(D2X(jfcb),44)         /* dsname       JFCBDSNM */   *|\n|*    vol=STORAGE(D2X(jfcb+118),6)      /* volser       JFCBVOLS */   *|\n|*    SAY 'sva='C2X(sva) 'jfcb='D2X(jfcb) 'dsn='dsn 'vol='vol         *|\n|*                                                                    *|\n\\*--------------------------------------------------------------------*/\n/*SWAREQ: PROCEDURE */\nNUMERIC DIGITS 20                         /* allow up to 2**64    */\nsva=C2D(ARG(1))                           /* convert to decimal   */\ntcb = C2D(STORAGE(21C,4))                 /* TCB         PSATOLD  */\njscb = C2D(STORAGE(D2X(tcb+180),4))       /* JSCB        TCBJSCB  */\nqmpl = C2D(STORAGE(D2X(jscb+244),4))      /* QMPL        JSCBQMPI */\n/* See if qmat can be above the bar */\nqmsta= C2X(STORAGE(D2X(qmpl+16),1))       /* JOB STATUS BYTE      */\nif SUBSTR(X2B(qmsta),6,1) then            /* is QMQMAT64 bit on?  */\ndo                                        /* yes, qmat can be ATB */\n  IF RIGHT(X2B(C2X(ARG(1))),1) \\= '1' THEN/* SWA=BELOW ?          */\n    RETURN C2D(ARG(1))+16                 /* yes, return sva+16   */\n  qmat=C2D(STORAGE(D2X(qmpl+10),2))*(2**48) +,/* QMAT+0  QMADD01  */\n       C2D(STORAGE(D2X(qmpl+18),2))*(2**32) +,/* QMAT+2  QMADD23  */\n       C2D(STORAGE(D2X(qmpl+24),4))       /* QMAT+4      QMADD    */\n  RETURN C2D(STORAGE(D2X(qmat+(sva*12)+64),4))+16\nend\nelse\ndo                                        /* no, qmat is BTB      */\n  IF RIGHT(C2X(ARG(1)),1) \\= 'F' THEN     /* SWA=BELOW ?          */\n    RETURN C2D(ARG(1))+16                 /* yes, return sva+16   */\n  qmat = C2D(STORAGE(D2X(qmpl+24),4))     /* QMAT        QMADD    */\n  DO WHILE sva>65536\n    qmat = C2D(STORAGE(D2X(qmat+12),4))   /* next QMAT   QMAT+12  */\n    sva=sva-65536                         /* 010006F -> 000006F   */\n  END\n  RETURN C2D(STORAGE(D2X(qmat+sva+1),4))+16\nend\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SYSDEBUG": {"ttr": 19977, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x029\\x00I\\x00\\x80)\\x9f\\x01\\t1_\\x11!\\x13\\xcb\\x00I\\r\\xa9\\xc3\\xc2\\xe3\\xf4\\xf7\\xf8@@@@'", "ispf": {"version": "02.57", "flags": 0, "createdate": "1980-10-25T00:00:00", "modifydate": "2009-11-11T11:21:49", "lines": 5067, "newlines": 73, "modlines": 3497, "user": "CBT478"}, "text": "//GILBERTD JOB (ACCT#),SYSDEBUG,\n//*RESTART=HLASM2,\n// NOTIFY=&SYSUID,\n// LINES=25,\n// CLASS=A,MSGCLASS=H,COND=(0,NE),REGION=6M\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n*PROCESS NOBATCH,USING(WARN(8))\n***********************************************************************\n*                                                                     *\n*            COPYRIGHT (C) 1980-2009 GILBERT SAINT-FLOUR              *\n*                       ALL RIGHTS RESERVED                           *\n*                                                                     *\n* MODULE NAME = SYSDEBUG                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = GSF-ENV Debugging Routine                        *\n*                                                                     *\n* FUNCTION = This generalized ESTAE routine simplifies abend          *\n*       resolution by formatting important MVS control blocks         *\n*       in an easy-to-read fashion.                                   *\n*                                                                     *\n* STATUS = R257                                                       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*          http://gsf-soft.com/Freeware/SYSDEBUG.shtml                *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = OS/390 R4, z/OS                                   *\n*                   DFSMS/MVS                                         *\n*                   STRING macro R510                                 *\n*                                                                     *\n*    AUTHORIZATION = NONE                                             *\n*                                                                     *\n*    RESTRICTIONS = NONE                                              *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (Sub-Routine)                              *\n*                                                                     *\n*    PROCESSOR = IBM Assembler H Version 2                            *\n*                IBM High-Level Assembler/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 23K                                                *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE ANY, AMODE 31,                   *\n*                 PROBLEM STATE, KEY 8                                *\n*                                                                     *\n*    OPERATION = See Below                                            *\n*                                                                     *\n*       This is not a system-wide debugging tool like ABEND-AID.      *\n*       To use it, a program must invoke it once with AMODE=31        *\n*       as follows:                                                   *\n*                                                                     *\n*                  LOAD  EP=SYSDEBUG                                  *\n*                  LR    R15,R0                                       *\n*                  BASSM R14,R15              invoke with AMODE31     *\n*                                                                     *\n*       Notes:                                                        *\n*                                                                     *\n*         1. This first invocation of the routine sets up a standard  *\n*            recovery environment (ESTAE) to trap abends.             *\n*                                                                     *\n*         2. DO NOT try to replace LOAD/BASSM with LINK in the        *\n*            invoking sequence.                                       *\n*                                                                     *\n*         3. If the program already runs with AMODE=31, then          *\n*            BALR or BASR can be used instead of BASSM.               *\n*                                                                     *\n*       The debugging routine may also be used from JCL,              *\n*       without modifying the program, as follows:                    *\n*                                                                     *\n*         //MYSTEP  EXEC PGM=SYSDEBUG,                                *\n*         //            ACCT=MYPROG,            <== program name      *\n*         //            PARM=(a,b,c,d)          <== program's parm    *\n*         //STEPLIB  DD DSN=GILBERT.LOAD,DISP=SHR                     *\n*         //SYSDEBUG DD SYSOUT=*                                      *\n*         //SYSUDUMP DD SYSOUT=*                                      *\n*                                                                     *\n*       The debugging report (written to DDN=SYSDEBUG) contains       *\n*       the following data:                                           *\n*                                                                     *\n*         o  The abend PSW and registers                              *\n*                                                                     *\n*         o  The TCB tree and RB chains (if this is a multi-task step *\n*                                                                     *\n*         o  The RB chain of the abending TCB, in greater detail      *\n*                                                                     *\n*         o  The JPAQ and Load-list                                   *\n*                                                                     *\n*         o  The save-area chain (forward only)                       *\n*                                                                     *\n*         o  The TIOT (allocated DDs)                                 *\n*                                                                     *\n*         o  OPEN data sets (with current record)                     *\n*                                                                     *\n*       Example: http://gsf-soft.com/Freeware/SYSDEBUG.report1.shtml  *\n*                                                                     *\n*       The debugging routine has a loop detection feature            *\n*       that causes an U0322 abend if the program consumes            *\n*       more that 5 seconds of CPU time without doing an IO.          *\n*       This feature is inactivated when a //DBGNO322 DD is           *\n*       present in step's JCL.                                        *\n*                                                                     *\n***********************************************************************\n*200 Do not use GSFSUBS services                                   1992\n*205 Print sysout record from JES2 unprotected buffer\n*206 Allow invocation from JCL to front-end PGM\n*208 Get rid of @JDATE routine\n*209 Improve save area processing\n*210 Use only standard macro libraries\n*211 Use NUCLKUP to enhance address identification\n*212 Display current save area if not in fwd chain\n*220 Fixed bug in DUMP32 routine that prevented PLH/RPL display\n*222 Validate address of work area to prevent S0C4\n*223 Identify OS/VS COBOL eye-catchers\n*224 Print SDWA at the end of the report\n*225 Some modifications in VSAM control block display\n*226 Display Reg1 for DATACOM subtask\n*227 Scan LPAQ in addition to JPAQ and LPAD\n*228 display attributes of SYSOUT data sets\n*229 print RPLOPTCD options codes and DCBE\n*230 Display R14,R15,R0,R1 values for each RB\n*231 Display LABEL=(,SUL) if present on DD stmt for disk data sets\n*232 Flag Abending RB, use NEXTRB routine\n*233 Display contents of PARM field\n*234 Flag Save Area pointed to by R13 at time of abend\n*234 Retrieve CDEX to display DDname for JPAQ modules\n*235 Identify sub-tasks on TCB tree that have terminated already\n*236 Convert DDN to DSN for JPAQ entries\n*236 Use ESTAE instead of ESPIE to validate A(DYNAM31)\n*237 Storage Allocation Table (using TCTCORE and LDA)              1994\n*    Some information from JOB and EXEC JCL statements\n*238 Prevent S806 when invoker doesn't set R13\n*239 Enhance JOB/STEP information reporting\n*    Improve method to locate V/VB record in QSAM buffers\n*    Provide support for QSAM buffers above the line (DFSMS/MVS)\n*    Prevent S0C4 when IOBECBAD is bad\n*    Print contents of COM_REG area\n*    Print all active PLHs if STRNO>1\n*    Hash-code name to access CDX\n*240 Do not print lines with identical contents (PDUMP rtne)\n*    Print PLH/RPL seq# when STRNO>1\n*241 Do not display OPEN mode for VSAM ACB, it's meaningless\n*    Check for R0=12 on entry to recovery routine\n*    Implement NEXTLLE rtne to prevent stack overflow\n*    Retrieve buffer addr from ICB when chained scheduling is used\n*    Prevent S30A-14 abend when invoked by a user in key 0-7\n*    Do not issue U0322 abend if //DBGNO322 DD present in step's JCL\n*242 Use RTM2WA to distinguish between type-1 SVC and Program check\n*    Get addr of RMODE31 ACB from DEBRRQ\n*    Convert ESTAE to ESTAI if invoked from an SVC routine\n*    Inactivate ESPIE environment created by invoking pgm\n*243 Allocate 4 pages below the line at initialization time.       1995\n*    Free-up all 4 pages if recovery invoked with R0=12 (no SDWA)\n*    Free-up 3 pages in recovery rtne to prevent GETMAIN failures.\n*244 Add support for callers in MODE=SUP and key 0-7\n*    Locate DDname for JPAQ modules loaded from a PDSE\n*    Minor changes to JOB card formatting routine\n*245 Initialisation routine has been rewritten to no longer\n*    require caller to provide addr of save area in R13.\n*246 Correct RECFM=U record length                                 1996\n*    Change name from DEBUG to SYSDEBUG                            1998\n*247 Title line displays date in YYYY-MM-DD format                 1999\n*248 Add support for HLASM R3                                      2000\n*    Add support for JES2 OS 1.3.0\n*249 Fix S0C7 in OS/390 R3 bug when JCTJMRJD=0 and JCTSSD=0        2001\n*250 ENQ and HH.MM.SS                                              2002\n*251 4-digit DEVN (requires MVS/ESA 4.1 or above).\n*252 Flag CURR_R13 earlier                                         2004\n*253 Fix TCTDCTR bug - EXCP count for last DD was always zero\n*    Do not display DEBLRECL when RECFM=U\n*    Expand REASON to three characters\n*    Miscellaneous technical and documentation changes\n*    Display SYSOUT record in JES2 buffer on z/OS 1.2              2005\n*254 Display BKTEK=A in QSAM DCB\n*    Display LBI BLKSIZE from DCBEBLKSI\n*255 Change HH.MM.SS to HH:MM:SS in title line                     2009\n*    Change STRING GENERATE to STRING (GENERATE,,LOCTR)\n*256 Use CSVQUERY instead of CDX\n*    Needs changes to assemble in MVS/ESA and OS/390\n*257 Change time format from 12H34M56 to 12:34:56\n***********************************************************************\n&HDR     SETC  'GSF UTILITIES - SYSDEBUG R257'\n         PUNCH ' SETSSI 02570000'\nSYSDEBUG CSECT                         MAIN CSECT\nSYSDEBUG RMODE ANY                     MAIN CSECT\n         USING *,R15\n         B     BEGIN\n*\n*        Using the official ASMH/HLASM distinction trick,\n*        simulate the SYSVER and SYSDATC variables\n*        of HLASM when assembled under ASMH\n*\n         LCLA  &ASMH_HLASM\n         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X\n&SYSVER  SETC  'ASMH'\n&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n.ASMH1X  ANOP\n&STR     SETC  '&HDR &SYSDATC &SYSTIME'\n&K       SETA  K'&STR\n         DC    AL1(&K),C'&STR',0H'0'   Eye-Catcher\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Determine if recovery is already initialized for this task.  *\n*        If it is, set R15 and R0 and goback to caller                *\n*                                                                     *\n*---------------------------------------------------------------------*\nBEGIN    L     R1,PSATOLD-PSA(,0)      MY TCB\n         USING TCB,R1\n         ICM   R1,B'1111',TCBSTAB      FIRST SCB\n         BZ    INIT12                  no SCB for this task, exit\n         USING SCB,R1\n         LA    R0,DEBUGAID             MY RECOVERY EXIT\n*LOOP\nINIT11B  CL    R0,SCBEXIT              IS THIS ME?\n         BNE   INIT11N                 NO, EXIT\n         L     R1,SCBXPTR              SCB EXTENSION\n         LR    R15,R0                  A(DEBUGAID)\n         BSM   R15,0                   set amode bit\n         L     R0,SCBXPARM-SCBX(,R1)   PARM ADDRESS (DYNAM31)\n         BSM   0,R14                   goback to caller\nINIT11N  ICM   R1,B'1111',SCBCHAIN     NEXT SCB\n         BNZ   INIT11B                 LOOP\n*ENDLOOP\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Scan TIOT to see if a SYSDEBUG DD is allocated.              *\n*        If it is allocated to a DD DUMMY, quit.                      *\n*        If it is not allocated and we're under TSO, quit.            *\n*                                                                     *\n*---------------------------------------------------------------------*\nINIT12   BALR  R15,0\n         USING *,R15\n         L     R1,PSATOLD-PSA(,0)      MY TCB\n         USING TCB,R1\n         L     R1,TCBTIO               TIOT\n         USING TIOT1,R1\n         SLR   R0,R0                   PREPARE IC\n*LOOP\nINIT12B  CLC   TIOEDDNM,DCBDDNAM-IHADCB+MODELDCB is this my ddname?\n         BE    INIT12K                 yes, exit loop\n         IC    R0,TIOELNGH             LOAD LENGTH OF CURRENT ENTRY\n         ALR   R1,R0                   BUMP UP TO NEXT ENTRY\n         CLI   TIOELNGH,0              IS THIS THE END?\n         BNZ   INIT12B                 NOT YET, LOOP THROUGH TIOT\n*ENDLOOP\n*\n*        IF TSO AND DD MISSING, DO NOT ACTIVATE DEBUGGING\n*\nINIT12D  L     R1,PSAAOLD-PSA(,0)      MY ASCB\n         L     R1,ASCBCSCB-ASCB(,R1)   MY CSCB\n         LA    R0,1                    R0=1\n         CLI   CHTRKID-CHAIN(R1),CHTSID  AM I A TSO USER?\n         BE    INIT19                  YES, QUIT (R15=0,R0=1)\n*\n*        If //SYSDEBUG DD DUMMY, exit\n*\nINIT12K  BALR  R15,0                   (local base)\n         USING *,R15\n         TM    TIOELINK,TIOESSDS       SUB-system data set?\n         BO    INIT20                  YES, continue\n         ICM   R0,B'0111',TIOEFSRT     DD DUMMY?\n         BNZ   INIT20                  no, continue\n         DROP  R1                      TIOT\n         LA    R0,2                    R0=2\n*\n*        Initialisation error: goback to caller with R15=0\n*\nINIT19   SLR   R15,R15                 YES, QUIT (R15=00)\n         SLR   R1,R1                   R1=0\n         BSM   0,R14\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Issue TESTAUTH to determine if we should take the            *\n*        authorized or the non-authorized init path.                  *\n*                                                                     *\n*---------------------------------------------------------------------*\nINIT20   BALR  R15,0                   (local base)\n         USING *,R15\n         TESTAUTH STATE=YES,RBLEVEL=1  Check PSW mode\n         LTR   R15,R15                 running in mode=sup ?\n         BALR  R15,0                   (local base)\n         USING *,R15\n         BNZ   INIT200                 no, jump\n***********************************************************************\n*                                                                     *\n*        Authorized Initialisation Path (invoked with MODE=SUP)       *\n*                                                                     *\n*        1. GETMAIN protected save area (SP 252)                      *\n*        2. Save caller's regs                                        *\n*        3. Switch to TCB key                                         *\n*        4. GETMAIN DYNAM31                                           *\n*        5. GETMAIN DYNAM24                                           *\n*        6. Issue ESTAE                                               *\n*        7. Change ESTAE to ESTAI (if invoked from SVC routine)       *\n*        8. Restore caller's regs and PSW key                         *\n*        9. Free protected save area and goback to caller             *\n*                                                                     *\n***********************************************************************\nINIT100  GETMAIN RU,LV=64,LOC=ANY,SP=252\n         LR    R0,R2                   save R2 accross MODESET\n         MODESET EXTKEY=ZERO,SAVEKEY=(2) switch to TCB key\n         XR    R2,R0                   restore R2\n         XR    R0,R2                   restore R2\n         XR    R2,R0                   restore R2\n         STM   R0,R15,0(R1)            save caller's regs and PSW key\n         BALR  R11,0\n         USING *,R11\n         LR    R12,R1                  KEEP SAVE AREA ADDR\n*\n*        switch to TCB key\n*\nINIT101  L     R4,PSATOLD-PSA(,0)\n         USING TCB,R4\n         MODESET EXTKEY=TCB,WORKREG=2  switch to TCB key\n*\nINIT102  LA    R0,DYNAM31L-1\n         GETMAIN RC,LV=(0),BNDRY=PAGE,LOC=ANY\n         LTR   R15,R15                 GETMAIN OK?\n         BNZ   INIT190                 no, quit\n         LR    R13,R1                  pass address\n         USING DYNAM31,R13\n*\n         BAL   R14,INIT900             allocate //SYSDEBUG DD\n*\n*        Allocate 4 pages below the line.  Most of this storage\n*        is a place-holder which is FREEMAIN'd by the recovery\n*        rtne when it is entered to prevent possible S80A or S878\n*        abends during OPEN of the SYSDEBUG DCB.\n*\n         GETMAIN RC,LV=DYNAM24L,LOC=(BELOW,ANY)  RMODE24 WORK AREA\n         LTR   R15,R15                 GETMAIN OK?\n         BNZ   INIT190                 NO, GOBACK\n         ST    R1,DYNAM24P             save A(DYNAM24)\n*\n*        Issue ESTAE\n*\n         ESTAE DEBUGAID,               RECOVERY ROUTINE                X\n               CT,                     CREATE                          X\n               PARAM=(R13),            PARAM FOR RECOVERY ROUTINE      X\n               TERM=YES,               PROCESS CANCEL ABENDS           X\n               MF=(E,ESTAEL)\n         LTR   R0,R15                  ESTAE OK?\n         BNZ   INIT190                 NO, GOBACK\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Convert the ESTAE to an ESTAI if I've been invoked from      *\n*        an SVC routine.                                              *\n*                                                                     *\n*---------------------------------------------------------------------*\nINIT130  L     R5,TCBRBP               MY PRB OR SVRB\n         USING RBBASIC,R5\n         LA    R0,130                  exit code\n         TM    RBSTAB1,RBFTSVRB        running under an SVRB?\n         BNO   INIT190                 NO, EXIT\n*\nINIT135  LA    R0,135                  exit code\n         ICM   R6,B'1111',TCBSTAB      MOST RECENT SCB\n         BZ    INIT190                 NO SCB, EXIT (very bizare!!!)\n         USING SCB,R6\n         LA    R15,DEBUGAID            exit addr without AMODE bit\n         LA    R0,136                  exit code\n         CL    R15,SCBEXIT             is this the addr of my exit?\n         BNE   INIT190                 NO, QUIT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Patch the SCB                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         BALR  R15,0\n         USING *,R15\n         MODESET EXTKEY=ZERO           switch to key zero\n         STCM  R4,B'0111',SCBOWNRA     Associate SCB with TCB\n         OI    SCBFLGS1,SCBSTAI        ESTAI\n         NI    SCBFLGS2,255-SCBSUPER   MODE=PROB\n         NI    SCBFLGS2,255-SCBKEY0    KEY=NZERO\n*\n*        Check if my SCB is the only one chained to my TCB.\n*        If there are other SCBs on the queue, move my SCB\n*        to the end of the queue to ensure I'm invoked last\n*        and prevent S0C4 in IEAVTAS1.\n*\n         LA    R0,141                  exit code\n         ICM   R2,B'1111',SCBCHAIN     ONLY SCB ON QUEUE?\n         BZ    INIT190                 YES, EXIT\n*LOOP\nINIT144  LR    R1,R2                   PREVIOUS SCB\n         ICM   R2,B'1111',SCBCHAIN-SCB(R1) LAST SCB ON QUEUE?\n         BNZ   INIT144                 NO, LOOP MORE\n*ENDLOOP\n         ST    R6,SCBCHAIN-SCB(,R1)    MY SCB AT BOTTOM OF QUEUE\n         MVC   TCBSTAB,SCBCHAIN        NEXT SCB AT TOP OF QUEUE\n         XC    SCBCHAIN,SCBCHAIN       MY SCB IS LAST ON QUEUE\n         LA    R0,145                  exit code\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Restore caller's environment and goback                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n         DROP\nINIT190  BALR  R15,0\n         USING *,R15\n         L     R2,0(,R12)              R0 from protected save area\n         MODESET KEYREG=(R2)           switch back to caller's key\n         LR    R1,R12                  addr of protected save area\n         LM    R2,R14,8(R12)           restore caller's R2-R14\n LR R2,R0                              pass exit code\n         FREEMAIN RU,LV=64,A=(R1),SP=252 free protected save area\n*\n         SLR   R15,R15                 R15=0\n         BCTR  R15,0                   R15=-1\n         SLR   R0,R0                   R0=0\n         SLR   R1,R1                   R1=0\n         BSM   0,R14                   goback to caller\n         DROP\n***********************************************************************\n*                                                                     *\n*        Non-Authorized Initialisation Path (invoked with MODE=PROB)  *\n*                                                                     *\n*        1. GETMAIN DYNAM31                                           *\n*        2. save caller's regs in SAVER012                            *\n*        3. GETMAIN DYNAM24                                           *\n*        4. Issue ESTAE                                               *\n*        5. Prime timer                                               *\n*        6. Issue XCTL (if invoked from JCL)                          *\n*        7. Restore caller's regs and goback (if invoked from pgm)    *\n*                                                                     *\n***********************************************************************\nINIT200  BALR  R15,0\n         USING *,R15\n         LA    R0,DYNAM31L-1\n         GETMAIN RC,LV=(0),BNDRY=PAGE,LOC=ANY\n         DROP  R15\n         LTR   R15,R15                 GETMAIN OK?\n         BALR  R15,0\n         BZ    INIT210-*(,R15)         no, quit\n         SLR   R15,R15                 R15=0\n         SLR   R0,R0                   R05=0\n         SLR   R1,R1                   R1=0\n         BSM   0,R14                   goback\n*\nINIT210  STM   R0,R15,SAVER012-DYNAM31(R1) save caller's regs\n         LR    R13,R1                  A(DYNAM31)\n         USING DYNAM31,R13\n*\n         BALR  R11,0\n         USING *,R11\n*\n         BAL   R14,INIT900             allocate //SYSDEBUG DD\n*\n*        Allocate 4 pages below the line.  Most of this storage\n*        is a place-holder which is FREEMAIN'd by the recovery\n*        rtne when it is entered to prevent possible S80A or S878\n*        abends during OPEN of the SYSDEBUG DCB.\n*\n         GETMAIN RC,LV=DYNAM24L,LOC=(BELOW,ANY)  RMODE24 WORK AREA\n         LTR   R15,R15                 GETMAIN OK?\n         BNZ   INIT209                 NO, QUIT\n         ST    R1,DYNAM24P             save A(DYNAM24)\n*\n*        Issue ESTAE XCTL=YES\n*\n         ESTAE DEBUGAID,               RECOVERY ROUTINE                X\n               CT,                     CREATE                          X\n               PARAM=(R13),            PARAM FOR RECOVERY ROUTINE      X\n               TERM=YES,               PROCESS CANCEL ABENDS           X\n               XCTL=YES,               STAY ACTIVE ACROSS XCTL         X\n               MF=(E,ESTAEL)\n         LA    R0,X'0020'              RETCODE FOR XCTL/STACK CONFLICT\n         CLR   R15,R0                  XCTL/STACK CONFLICT?\n         BNE   INIT220                 NO, CONTINUE\n*\n*        Issue ESTAE XCTL=NO if there is at least a stack entry active\n*\n         ESTAE DEBUGAID,               RECOVERY ROUTINE                X\n               CT,                     CREATE                          X\n               PARAM=(R13),            PARAM FOR RECOVERY ROUTINE      X\n               TERM=YES,               PROCESS CANCEL ABENDS           X\n               MF=(E,ESTAEL)\n         LTR   R15,R15                 ESTAE OK?\n         BZ    INIT220                 yes, jump\n*\nINIT209  LM    R2,R14,SAVER012+8       restore caller's registers\n         SLR   R15,R15                 R15=0\n         SLR   R0,R0                   R05=0\n         SLR   R1,R1                   R1=0\n         BSM   0,R14                   goback\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Set-up timer for loop detection                              *\n*                                                                     *\n*---------------------------------------------------------------------*\nINIT220  L     R4,PSATOLD-PSA(,0)      my TCB\n         USING TCB,R4\n         L     R5,TCBRBP               MY PRB OR SVRB\n         USING RBBASIC,R5\n         CL    R4,RBLINK               FIRST AND ONLY PRB IN CHAIN?\n         BNE   INIT250                 NO, DO NOT SET TIMER\n         DEVTYPE =C'DBGNO322',WKCELL1\n         LTR   R15,R15                 //DBGNO322 DD specified?\n         BZ    INIT250                 YES, DO NOT SET TIMER\n         L     R1,TCBFSA               FIRST SAVE AREA\n         MVI   044(R1),255             FOR U322, JUST IN CASE . . .\n         SYNCH U322SET                 PRIME THE U322 PUMP\n*---------------------------------------------------------------------*\n*                                                                     *\n*        XCTL TO PGMNM IN ACCT FIELD                                  *\n*                                                                     *\n*        //GO EXEC PGM=SYSDEBUG,ACCT=USERPROG,PARM=(USER-PARM)        *\n*                                                                     *\n*---------------------------------------------------------------------*\nINIT250  CL    R4,TCBJSTCB             Is this the JOB-STEP TCB ?\n         BNE   INIT290                 NO, GOBACK\n         CLC   TCBFSA,SAVER012+R13*4   AM I INVOKED THRU JCL?\n         BNE   INIT290                 NO, GOBACK\n         L     R5,TCBRBP               POINT TO MY PRB\n         SLR   R6,R6\n         ICM   R6,B'0111',RBCDE1       Do we have a CDE?\n         BZ    INIT290                 NO, GOBACK\n         USING CDENTRY,R6\n         CLC   CDENTPT,=A(SYSDEBUG+X'80000000')                        +\n                                       Current PRB pointing at myself?\n         BNE   INIT290                 NO, GOBACK\n         MVC   SAVER012(8),RBGRSAVE    PASS R0-R1\n*\n         L     R5,TCBJSCB              MY JSCB\n         USING IEZJSCB,R5\n         LOAD  EPLOC=JSCBPGMN          BUMP MY USE COUNT FOR XCTL\n         L     R6,JSCSCT               MY SCT\n         USING SCT,R6\n         SLR   R7,R7\n         ICM   R7,B'0111',SCTAFACT     ACCOUNT DATA\n         USING IEFAACTB-16,R7\n         LA    R14,WKCELL1             8-BYTE WORK AREA\n         LA    R15,L'WKCELL1           LENGTH\n         LA    R0,ACTACCNT+1           FIRST ACCOUNT FIELD\n         L     R1,=X'40000000'         PADDING\n         IC    R1,ACTACCNT+0           LENGTH OF PGM NAME\n         MVCL  R14,R0                  MOVE PGM NAME\n         LA    R15,WKCELL2             WORK AREA\n         LA    R0,WKCELL1              PGM NAME\n         SLR   R1,R1\n         STM   R0,R1,0(R15)            XCTL LIST\n         LM    R0,R14,SAVER012         restore caller's registers\n         XCTL  SF=(E,(15))             EXECUTE TARGET PROGRAM\n         DROP  R4,R5,R6,R7\n*\n*        ESTAE executed, set R15/R0 and go back to caller\n*\nINIT290  LA    R15,DEBUGAID            R15=A(DEBUGAID)\n         BSM   R15,0                   SET AMODE BIT\n         LA    R0,DYNAM31              R0=A(DYNAM31)\n         SLR   R1,R1                   R1=0\n         LM    R2,R14,SAVER012+8       restore caller's registers\n         BSM   0,R14                   GOBACK, PASS R15-R0\n         DROP\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ALLOCATE SYSOUT DATA SET                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nINIT900  BALR  R15,0\n         USING *,R15\n         LA    R1,TENWORDS-DYNAM31(,R13) WORK AREA FOR DYNALLOC\n         XC    0(20,R1),0(R1)          CLEAR STORAGE\n         MVI   0(R1),20                LENGTH\n         MVI   1(R1),1                 VERB=ALLOC\n         LA    R0,INIT9900             TEXT UNIT POINTERS\n         ST    R0,8(,R1)               S99TUPTR\n         ST    R1,20(,R1)              WORK AREA ADDRESS\n         LA    R1,20(,R1)              S99RBPTR\n         OI    0(R1),X'80'             S99RBPTR\n         SVC   99                      ALLOCATE SYSDEBUG\n         BR    R14                     continue\n*\nINIT9900 DC    A(INIT9901,INIT9902,INIT9918,INIT9952+X'80000000')\nINIT9901 DC    AL2(1,1,8),C'SYSDEBUG'  DDNAME\nINIT9902 DC    AL2(2,1,10),C'&&&&SYSDEBUG' DSNAME=&&SYSDEBUG\nINIT9918 DC    X'0018,0000'            SYSOUT=*\nINIT9952 DC    X'0052,0000'            PERMANENTLY ALLOCATED\n*---------------------------------------------------------------------*\n*                                                                     *\n*        LOOP DETECTOR (ABENDU0322 AFTER 5 SECONDS OF CPU WITHOUT I/O)*\n*                                                                     *\n*        Uses the R6 slot of the 1st save area to hold the EXCP count *\n*                                                                     *\n*---------------------------------------------------------------------*\nU322SET  SAVE  (14,12),,DEBUG.U322SET  SAVE REGISTERS\n         LR    R3,R15                  LOCAL BASE\n         USING U322SET,R3\n         L     R4,PSATOLD-PSA(,0)      MY TCB\n         L     R5,PSAAOLD-PSA(,0)      MY ASCB\n         L     R0,ASCBIOSC-ASCB(,R5)   CURRENT EXCP COUNT\n         L     R1,TCBFSA-TCB(,R4)      FIRST SAVE AREA\n         CL    R0,044(,R1)             SAME EXCP COUNT ?\n         BE    U322ABND                YES, ABEND\n         ST    R0,044(,R1)             SAVE EXCP COUNT INTO R6 SLOT\n         STIMER TASK,U322SET,BINTVL=U322TIME\nU322EXIT RETURN (14,12)                GOBACK TO FLIH\n*\nU322ABND L     R6,TCBRBP-TCB(,R4)      POINT TO MY RB (TIRB)\n         LM    R0,R15,RBGRSAVE-RBBASIC(R6)  LOOPING PROGRAM'S REGISTERS\n         BALR  R1,0\n         ICM   R1,B'1111',U322CODE-*(R1)    LOAD ABEND CODE\n         CNOP  6,8\n         SVC   13                      ISSUE ABEND SVC\nU322TIME DC    F'00500'                TIMER INTVL IN 1/100 OF A SECOND\nU322CODE DC    X'80',FL3'322'          ABEND 0322,DUMP\n         DROP\n*\n***********************************************************************\n*                                                                     *\n*        DEBUGGING ROUTINE                                            *\n*                                                                     *\n***********************************************************************\n*\n         USING DEBUGAID,R15\nDEBUGAID CH    R0,H12                  SDWA ALLOCATED?\n         BNE   DEBUGAID4               YES, JUMP\n         USING DYNAM31,R2\n         TM    DYNAM24P,X'80'          place-holder freed already?\n         BNO   DEBUGAID2               NO, JUMP\n         SLR   R15,R15                 RC=0\n         BR    R14                     continue with abend\nDEBUGAID2 EQU  *\n         OI    DYNAM24P,X'80'          place-holder has been freed\n         L     R1,DYNAM24P             ADDR OF MY 24-BIT WORK AREA\n         LA    R1,DYNAM24H-DYNAM24(,R1) addr of place-holder\n         FREEMAIN RC,LV=L'DYNAM24H,A=(1) free place holder\n         DROP  R15                     local base\n         LA    R13,SAVER012            save area\n         LA    R0,12                   restore R0 contents\n         DROP  R2                      DYNAM31\n*\nDEBUGAID4 BALR R15,0                   set base reg for SAVE macro\n         SAVE  (14,12),,'&HDR ESTAE &SYSDATC &SYSTIME'\n         LR    R11,R15                 local base\n         USING DEBUGAID4+2,R11\n         LR    R8,R1                   SDWA address\n         USING SDWA,R8\n         L     R9,PSATOLD-PSA(,0)      MY TCB\n         USING TCB,R9\n*\n*        If I was invoked without an SDWA, copy RTM2's SDWA\n*        into a work area\n*\n         CH    R0,H12                  did we get an SDWA from RTM2?\n         BNE   DEBUGAID8               yes, jump\n         USING DYNAM31,R2\n         L     R3,TCBRTWA              RTM2WA\n         USING RTM2WA,R3\n         L     R14,RTM2SDW2            RTM2's SDWA\n         LH    R15,SDWALNTH+1-SDWA(,R14) length of the SDWA\n         LA    R0,D31SDWA              my own SDWA\n         LA    R1,L'D31SDWA            my own SDWA\n         MVCL  R0,R14                  move RTM2 SDWA to my work area\n         LA    R8,D31SDWA              my own SDWA\n         ST    R2,SDWAPARM             A(DYNAM31)\n         OI    SDWAPARM,X'80'          prevent freemain\n         MVC   SDWAEC1,RTM2EPSW        error psw\n         MVC   SDWAAEC1,RTM2AEC1       additional error information\n         MVC   SDWAEC2,RTM2EPSW        error psw\n         MVC   SDWAABCC,RTM2CODE       completion code\n         MVC   SDWAGRSV,RTM2EREG       REGISTERS AT TIME OF ABEND\n         MVC   SDWAFLGS,RTM2FLGS       PASS FLAGS\n         DROP  R2,R3                   DYNAM31,RTM2WA\nDEBUGAID8 EQU  *\n*\n         CLC   =X'222000',SDWACMPC     CANCEL COMMAND?\n         BE    GOBACK8                 YES, QUIT\n*\n         CLI   SDWARCDE,0              return code set by previous     +\n                                       recovery routine?\n         BNE   GOBACK9                 YES, QUIT\n*\n*        Inactivate any ESPIE environment created earlier\n*        which could interfere with the trapping of my\n*        own addressing and protection exceptions.\n*\n         ICM   R0,B'1111',TCBPIE       any ESPIE created earlier?\n         BZ    ESPIE12                 no, exit\n         TESTAUTH KEY=YES,STATE=YES,RBLEVEL=1    Check PSW key\n         LTR   R15,R15                 running in mode=sup or key 0-7 ?\n         BZ    ESPIE12                 yes, exit\n         ESPIE SET,MF=(E,ESPIE11L)     Override existing PICA\n         B     ESPIE12\nESPIE11L ESPIE SET,ESPIE11X,MF=L       INTERRUPT MASK ALL ZERO\nESPIE11X LR    R0,R1                   save addr of EPIE\n         ICM   R1,B'1111',ESPIE11Z-ESPIE11X(R15)   get completion code\n         ABEND (1)                     ABEND0C0\nESPIE11Z DC    X'80,0C0000'            S0C0 completion code\nESPIE12  EQU   *\n*\n*        Chain save areas\n*        Use ESTAE to trap S0C4 if A(DYNAM31) is invalid\n*\nNEW_SAVE ESTAE ESPIEXIT,CT             RECOVERY ROUTINE\n         L     R2,SDWAPARM             =A(DYNAM31)\n         ST    R2,8(,R13)              bwd chain\n         ST    R13,4(,R2)              fwd chain\n         LR    R13,R2                  A(DYNAM31)\n         USING DYNAM31,R13\n         ESTAE 0                       PARM LOOKS GOOD, RESET MY ESPIE\n*\n         MVC   ENQLIST(ENQLISTL),ENQMODEL ENQ/DEQ LIST\n         ENQ   MF=(E,ENQLIST)          PREPARE TO UPDATE WORK AREA\n*\nDUMPOPT  TM    SDWACMPF,SDWAREQ        DUMP REQUESTED?\n         BNO   ESTAE2                  NO, JUMP\n         OI    SDWADPFS,SDWADLST       DUMP OPTIONS VALID\n         MVC   SDWADDAT,=X'0F00,AF00'  MOVE SDATA/PDATA\n         TM    SDWAMWP1,SDWAPGM1       Abend in SUPVR mode?\n         BO    ESTAE2                  NO, JUMP\n         OI    SDWASDA0,SDWALSQA       yes, dump LSQA too\n*\nESTAE2   ESTAE RETRY00,                RECOVERY ROUTINE                X\n               CT,                     CREATE                          X\n               PARAM=DYNAM31,          PARAM FOR RECOVERY ROUTINE      X\n               MF=(E,ESTAEL)\n*\nSETK7    TESTAUTH KEY=YES,STATE=YES,RBLEVEL=1    Check PSW key\n         LTR   R15,R15                 caller in system key?\n         BNZ   FREEPH24                no, jump\n         MODESET KEY=NZERO,MODE=SUP    yes, switch to a safe key\n*\n*        Free AMODE24 place-holder if we're low on memory\n*\nFREEPH24 L     R12,DYNAM24P            ADDR OF MY 24-BIT WORK AREA\n         USING DYNAM24,R12\n         TM    DYNAM24P,X'80'          place-holder freed already?\n         BO    OPENDCB                 yes, do not do it again\n         L     R1,PSAAOLD-PSA(,0)      ASCB\n         L     R1,ASCBLDA-ASCB(,R1)    Local Data Area\n         USING LDA,R1\n         L     R0,LDALIMIT             LIMIT\n         S     R0,LDALOAL              size of remaining memory below\n         BM    OPENDCB                 negative, exit\n         DROP  R1                      was LDA\n         CH    R0,=H'12288'            at least 12K available?\n         BH    OPENDCB                 yes, keep place-holder\n         LA    R1,DYNAM24H             place-holder (last 3 pages)\n         FREEMAIN RC,LV=L'DYNAM24H,A=(1)   free place holder\n         OI    DYNAM24P,X'80'          place-holder has been freed\n*\n*        OPEN the SYSDEBUG DCB\n*\nOPENDCB  EQU   *\n         MVC   DCBDEBUG(DCBLNGQS),MODELDCB   MOVE MODEL DCB\n         LA    R0,DCBDEBUG             OPEN LIST\n         ST    R0,OPENLIST             OPEN LIST\n         MVI   OPENLIST,X'8F'          OPEN LIST\n         OPEN  MF=(E,OPENLIST)         OPEN MY DCB\n*\n         SLR   R0,R0                   R0=0\n         BCTR  R0,0                    R0=-1\n         ST    R0,MASKADDR             X'FFFFFFFF'\n*\n         MVI   TRTPRINT,C' '           PRINTABLE CHARACTERS\n         MVC   TRTPRINT+1(255),TRTPRINT\n         MVC   BLANKS,TRTPRINT         KEEP BLANKS\n         SLR   R15,R15\n         SLR   R0,R0\n         BAL   R1,TRTPRT2\n         DC    X'4A,7,5A,8,6A,6,7A,6'  Special characters\n         DC    X'81,9,91,9,A2,8'       Lowercase\n         DC    X'C1,9,D1,9,E2,8'       Uppercase\n         DC    X'F0,A'                 Digits\n         DC    X'00,0'                 end of table\n*LOOP\nTRTPRT2  IC    R15,0(,R1)              FIRST BYTE\n         IC    R0,1(,R1)               ITERATIONS\n*--LOOP\nTRTPRT3  STC   R15,TRTPRINT(R15)       STORE X'4A' INTO TRTPRINT+X'4A'\n         LA    R15,1(,R15)             BUMP INDEX\n         BCT   R0,TRTPRT3              NEXT CHARACTER\n*--ENDLOOP\n         LA    R1,2(,R1)               NEXT ENTRY IN TABLE\n         CLI   0(R1),0                 END OF TABLE?\n         BNE   TRTPRT2                 NEXT STRING\n*ENDLOOP\n*\n         BAL   R14,DIAG000         <== SET TITLE, DIAGNOSE\n         BAL   R14,PSW00           <== PRINT PSW, GPRS\n         BAL   R14,JOBSTEP         <== PRINT JOB/STEP DATA\n         BAL   R14,PRB00           <== PRINT RB CHAIN\n         BAL   R14,PGM00           <== PRINT JPAQ AND LOAD LIST\n         BAL   R14,COMREG00        <== PRINT COM_REG area\n         BAL   R14,LINK00          <== PRINT SAVE AREA TRACE\n         BAL   R14,TIOT00          <== PRINT DATA SET ALLOCATIONS\n         BAL   R14,DEB000          <== PRINT OPEN DATA SETS\n*TEST    BAL   R14,PRWA00          <== PRINT SDWA\n*\n         CLOSE MF=(E,OPENLIST)         CLOSE DEBUG DD\n         MVI   DCBBUFNO-IHADCB+DCBDEBUG,00\n         FREEPOOL DCBDEBUG\n         ESTAE 0                       DELETE RECOVERY ROUTINE\n*\n*----------------------------------------------------------------------\n*\n*        GOBACK TO RTM\n*\n*              Free working-storage (unless hi-order bit is on)\n*\n*----------------------------------------------------------------------\n*\nGOBACK   L     R2,DYN_TCB              getmain tcb\n         LR    R3,R13                  A(DYNAM31)\n         DEQ   MF=(E,ENQLIST)          FREE WORK AREA\n         L     R13,4(,R13)             caller's save area\n         TM    SDWAPARM,X'80'          hi-order bit on?\n         BO    GOBACK7                 yes, skip freemain\n         CL    R2,PSATOLD-PSA(,0)      is this the right TCB?\n         BNE   GOBACK7                 no, skip freemain\n         LA    R0,DYNAM31L-1           length of dynamic storage area\n         FREEMAIN RU,LV=(0),A=(R3)     free dynamic storage\n*\nGOBACK7  TESTAUTH KEY=YES,STATE=YES,RBLEVEL=1    Check PSW key\n         LTR   R15,R15                 caller in system key?\n         BNZ   GOBACK8                 no, jump\n         MODESET KEY=ZERO,MODE=PROB    yes, switch to KEY=0\n*\nGOBACK8  SETRP WKAREA=(R8),            SDWA address                    X\n               RC=00                   Continue with abend\nGOBACK9  RETURN (14,12)                go back to R/TM\nH12      DC    H'12'                   no SDWA on entry to DEBUGAID\n*\n*----------------------------------------------------------------------\n*\n*        RETRY ROUTINE (FOR ESPIE)\n*\n*----------------------------------------------------------------------\n*\nESPIEXIT SAVE  (14,12),,*              save registers\n         BALR  R2,0                    local base\n         USING *,R2\n*WTO 'ESPIEXIT ENTERED'\n         SETRP RETADDR=ESPIEBAD,RC=4,  <== RETRY                       X\n               FRESDWA=YES,RETREGS=YES,                                X\n               DUMP=NO,                suppress dump                   X\n               REGS=(14,12)            restore registers\n         DROP  R2\n*\nESPIEBAD ESTAE 0                       RESET MY ESPIE\n         SETRP WKAREA=(R8),            SDWA address                    X\n               REGS=(14,12),           restore registers               X\n               RC=00                   Continue with abend\n*\nMODELDCB DCB   DSORG=PS,MACRF=PM,DDNAME=SYSDEBUG,                      X\n               RECFM=FBA,LRECL=121,BUFNO=1\nENQMODEL ENQ   (ENQNAMES,ENQNAMES,E,,STEP),MF=L\nENQNAMES DC    CL8'SYSDEBUG'           QNAME/RNAME\n*----------------------------------------------------------------------\n         MACRO\n&NAME    BEGIN_PROC &SAVE=YES\n         GBLC  &#PROC\n&#PROC   SETC  'IHB&SYSNDX'\n$LTORG   LOCTR\n&NAME    BAL   R15,BEGIN_PROC          BRANCH TO RELAY CODE\n         DC    Y(&#PROC.A-*)           OFFSET TO FAR CODE\n         AIF   ('&SAVE' EQ 'NO').NOSAVE\nDYNAM31  DSECT\nDYN31FAR LOCTR\n&#PROC.S DS    2F                      SAVE AREA FOR R14 AND R10\n$FARRTNE LOCTR\n&#PROC.A LR    R15,R10                 BASE REG\n         STM   R14,R15,&#PROC.S        SAVE REGISTERS\n         BALR  R10,0\n         USING *,R10\n         MEXIT\n.NOSAVE  ANOP\n$FARRTNE LOCTR\n&#PROC.A DS    0H\n         USING *,R15\n         MEND\n         MACRO\n&NAME    END_PROC &RC=\n         GBLC  &#PROC\n&NAME    L     R14,&#PROC.S            RESTORE LINKAGE REGISTER\n         L     R10,&#PROC.S+4          RESTORE BASE REGISTER\n         BR    R14\n&SYSECT  LOCTR                         MAIN CODE\n         MEND\n*----------------------------------------------------------------------\n         MACRO                                                    MACRO\n&REF    #SETMASK &AMODE                                           MACRO\n&REF     MVI   MASKADDR,X'7F'          X'7FFFFFFF'                MACRO\n         TM    &AMODE,X'80'            CHECK AMODE BIT            MACRO\n         BO    *+8                     AMODE31, JUMP              MACRO\n         MVI   MASKADDR,X'00'          X'00FFFFFF'                MACRO\n         MEND                                                     MACRO\n*----------------------------------------------------------------------\n         MACRO                                                    MACRO\n&NAME   #S0C4  &ERRET,&PUSH                                       MACRO\n         AIF   ('&ERRET' EQ 'RESET').RESET                        MACRO\n         AIF   ('&ERRET' EQ 'POP').POP                            MACRO\n&DD      SETC  '(&ERRET-RETRY11)'                                 MACRO\n         AIF   ('&PUSH' EQ 'PUSH').PUSH                           MACRO\n&NAME    MVI   #RETRY+0,&DD/256\n         MVI #RETRY+1,&DD-((&DD/256)*256)\n         MEXIT                                                    MACRO\n.PUSH    ANOP                                                     MACRO\n&NAME    MVC   #RETRY+2,#RETRY         push current address\n         MVI   #RETRY+0,&DD/256\n         MVI #RETRY+1,&DD-((&DD/256)*256)\n         MEXIT                                                    MACRO\n.RESET   ANOP                                                     MACRO\n&NAME    MVI   #RETRY+0,0              RESET RETRY ADDRESS\n         MEXIT                                                    MACRO\n.POP     ANOP                                                     MACRO\n&NAME    MVC   #RETRY,#RETRY+2         pop previous address\n         MVI   #RETRY+2,0              RESET RETRY ADDRESS\n.MEND    MEND                                                     MACRO\n*----------------------------------------------------------------------\n$LTORG   LOCTR                         ADDRESSABLE CODE\n$FARRTNE LOCTR                         FAR ROUTINES\n         SPLEVEL SET                   SET &SYSSPLV SYMBOL\n         GBLC  &SYSSPLV                MVS/SP LEVEL\n*\n*----------------------------------------------------------------------\n*\n*        ABEND-SPECIFIC DIAGNOSTIC INFORMATION\n*\n*              FORMAT AND DISPLAY ABEND-CODE\n*              LOCATE LAST PRB, FIRST SVRB\n*              DETERMINE IF THIS IS AN OPEN/CLOSE/EOV (OCE) ABEND\n*              INVOKE THE CORRESPONDING DIAGNOSIS ROUTINE\n*\n*----------------------------------------------------------------------\n*\nDIAG000  BEGIN_PROC\n         L     R5,TCBRD                REGION DESCRIPTOR\n         LM    R0,R1,RDSTART-RD(R5)    START/LENGTH OF MY REGION\n         ALR   R1,R0                   START/END OF MY REGION\n         STM   R0,R1,REGION24          START/END OF MY REGION\n******   MVC   CURR_R13,RBGRS13        keep addr of current save area\n******  #SETMASK RBOPSW+4              SET ADDRESS CLEAN-UP MASK\n         MVC   CURR_R13,SDWAGR13       keep addr of current save area\n        #SETMASK SDWANXT1              SET ADDRESS CLEAN-UP MASK\n         NC    CURR_R13,MASKADDR       clean-up\n*\n*        BUILD A FAKE PSW2 IF PSW1=PSW2 OR PSW2=ZERO            @910624\n*\n         MVC   ORIGIN2,BLANKS          ORIGIN OF PSW2 IS SDWAEC2\n         LM    R0,R1,SDWAEC2           pick up PSW2\n         ALR   R0,R1                   PSW2=ZERO?\n         BZ    DIAG005                 YES, JUMP\n         CLC   SDWAEC1,SDWAEC2         PSW1=PSW2?\n         BNE   DIAG010                 NO, QUIT\nDIAG005 #S0C4  DIAG010\n         L     R1,SDWAGR13             VALIDATE CALLER'S R13\n         L     R1,4(,R1)               CALLER'S SAVE AREA\n         CLC   0(72,R1),0(R1)          VALIDATE CALLER'S SAVE AREA\n        #S0C4  RESET\n         C     R1,TCBFSA               IS THIS THE FIRST SAVE AREA?\n         BE    DIAG010                 YES, JUMP\n         MVC   ORIGIN2,=C'  (HSA)'     ORIGIN OF PSW2 IS HIGH-SA\n         MVC   SDWASR00(4*13),20(R1)   MOVE R0-R12\n         ST    R1,SDWASR13             STORE R13\n         MVC   SDWASR14(4*2),12(R1)    MOVE R14-R15\n         MVC   SDWANXT2,12(R1)         USE R14 AS NEXT ADDRESS\n         XC    SDWAAEC2(4),SDWAAEC2    ZERO ILC, INTC\n*\n*        BUILD RB CHAIN IN REVERSE ORDER\n*\nDIAG010  L     R6,TCBRBP               TOP OF RB CHAIN (MOST RECENT RB)\n         LR    R0,R6                   POINT TO BASIC SECTION\n         SH    R0,=Y(RBBASIC-RBPREFIX) POINT TO RBPREFIX\n         ST    R0,MY_PRB               MY RBPREFIX\n         SLR   R6,R6                   first time switch for NEXTRB\n*\n*        GET ADDR OF LAST PRB, FIRST SVRB, ABEND SVRB.\n*\n*LOOP\nDIAG031  BAL   R14,NEXTRB              GET RB ADDRESS\n         LTR   R6,R6                   eof?\n         BZ    DIAG035                 yes, exit\n         CL    R6,MY_PRB               END OF CHAIN?\n         BE    DIAG035                 yes, exit\n         USING RBPREFIX,R6\n         CLI   RBSTAB1,RBFTPRB         IS THIS A PRB?\n         BNE   DIAG031S                NO, JUMP\n         ICM   R0,B'1111',FRSTSVRB     SET ALREADY?\n         BNZ   DIAG031S                YES, JUMP\n         ST    R6,LASTPRB              SAVE ADDR OF LAST PRB\n*\nDIAG031S TM    RBSTAB1,RBFTSVRB        IS THIS AN SVRB?\n         BZ    DIAG031N                NO, JUMP\n         ICM   R0,B'1111',FRSTSVRB     SET ALREADY?\n         BNZ   DIAG031A                YES, JUMP\n         ST    R6,FRSTSVRB             SAVE ADDR OF FIRST SVRB\n*LOOP\nDIAG031A TM    RBFLAGS1,RBABEND        IS THIS THE ABEND SVRB?\n         BZ    DIAG031N                NO, JUMP\n         ICM   R0,B'1111',ABNDSVRB     SET ALREADY?\n         BNZ   DIAG031N                YES, JUMP\n         ST    R6,ABNDSVRB             SAVE ADDR OF ABEND SVRB\n*\nDIAG031N B     DIAG031                 NEXT ENTRY IN RB STACK\n*ENDLOOP\nDIAG035  L     R6,LASTPRB              LAST PRB\n         MVI   OCE_CODE,C'O'           ABEND DURING OPEN\n         CLI   RBWLIC+3,19             O/C/E SVC?\n         BE    DIAG040                 YES, JUMP\n         CLI   RBWLIC+3,22             O/C/E SVC?\n         BE    DIAG040                 YES, JUMP\n         MVI   OCE_CODE,C'C'           ABEND DURING CLOSE\n         CLI   RBWLIC+3,20             O/C/E SVC?\n         BE    DIAG040                 YES, JUMP\n         MVI   OCE_CODE,C'E'           ABEND DURING EOV\n         CLI   RBWLIC+3,55             O/C/E SVC?\n         BE    DIAG040                 YES, JUMP\n         MVI   OCE_CODE,00\n         DROP  R6                      RBPREFIX\n*\nDIAG040  STRING 'ABEND U',(SDWACMPC+1,H,R4Z),INTO=ABCODE ABEND=U0046\n         CLC   =X'000F',SDWACMPC       SYSTEM CODE ALL ZEROES?\n         BNL   DIAG044                 YES, JUMP\n         STRING (SDWACMPC,,X),INTO=WKCELL1\n         STRING 'ABEND S',(WKCELL1,3),'-',(SDWAGR15+3,1,X),            X\n               INTO=ABCODE             ABEND=SD37-04\n         TM    SDWAERRA,SDWASVCD       TASK ISSUED SVC 13?\n         BNO   DIAG042                 NO, JUMP\n         TM    SDWACMPF,SDWARCF        REASON-CODE SPECIFIED?\n         BO    DIAG044                 YES, JUMP\n         ICM   R15,B'1111',SDWAGR15    R15=00?\n         BZ    DIAG042                 YES, JUMP\n         ICM   R15,B'1110',SDWAGR15    R15>FF?\n         BZ    DIAG044                 NO, JUMP\nDIAG042  MVC   ABCODE+10(3),BLANKS     GET RID OF '-04'\n*\nDIAG044  L     R15,TCBTIO              MY TIOT\n         LA    R1,MSG60\n         MVC   MSG60,BLANKS\n         MVC   0(8,R1),0(R15)          JOBNAME\n         CLI   16(R15),C' '\n         BNH   DIAG046\n         LA    R1,1(,R1)\n         CLI   0(R1),C' '\n         BNE   *-8\n         MVI   0(R1),C'.'\n         MVC   1(8,R1),16(R15)         PROCSTEP\nDIAG046  LA    R1,1(,R1)\n         CLI   0(R1),C' '\n         BNE   *-8\n         MVI   0(R1),C'.'\n         MVC   1(8,R1),8(R15)          STEPNAME\n         TIME  DEC\n         STM   R0,R1,WKCELL1           TIME, DATE\n*\nDIAG050  L     R1,CVTPTR(,0)           CVT ADDRESS\n         USING CVTMAP,R1\n         MVI   SPLEVEL,1               MVS/370                      370\n         TM    CVTDCB,CVTMVSE          XA FLAG ON?\n         BNO   DIAG055                 NO, JUMP\n         MVI   SPLEVEL,2               MVS/XA\n         AIF   ('&SYSSPLV' LT '3').DIAG55      MVS/XA MACLIB, JUMP\n         TM    CVTDCB,CVTOSEXT         CHECK OSLVL EXTENSION\n         BNO   DIAG055                 NO, JUMP\n         TM    CVTOSLVL,CVTXAX         CHECK FOR ESA FLAG\n         BNO   DIAG055                 NO, JUMP\n         MVI   SPLEVEL,3               MVS SP/3\n         AIF   ('&SYSSPLV' LT '4').DIAG55      ESA V3 MACLIB, JUMP\n         TM    CVTOSLVL,CVTH4410       CHECK FOR ESA V4 FLAG\n         BNO   DIAG055                 NO, JUMP\n         MVI   SPLEVEL,4               MVS SP/4\n.DIAG55  ANOP\nDIAG055  SH    R1,=Y(CVTMAP-CVTFIX)    POINT TO CVT PREFIX\n         USING CVTFIX,R1\n         STRING '1&HDR - ',ABCODE,5X,(MSG60,,L),                       X\n               2X,(WKCELL1+4,P,YYYY-MM-DD),            YYYY-MM-DD      X\n               ' (',(WKCELL1+4+1,1,X),'.',(WKCELL1+4+2,P,R3Z),') ',    X\n               (WKCELL1,1,X),':',(WKCELL1+1,1,X),':',(WKCELL1+2,1,X),  X\n               2X,(CVTMDL,,X),2X,CVTPRODN,                             X\n               INTO=TITLE121\n         MVC   LINE121,TITLE121        TITLE LINE\n         MVI   RLINES,0                RESET LINE COUNTER\n         BAL   R14,SPACE1          <== Print line\n         DROP  R1                      CVTFIX\n*\n*        INVOKE ABEND-SPECIFIC DIAG ROUTINE\n*\nDIAG060  LA    R1,DIAG094              INDEX\n         LA    R14,0008                TABLE ENTRY\n         LA    R15,DIAG095             LIMIT FOR BXLE\n*LOOP\nDIAG062  CLC   ABCODE+6(4),4(R1)       COMPARE ABEND CODE\n         BE    DIAG066                 FOUND, JUMP\n         BXLE  R1,R14,DIAG062\n*ENDLOOP\n         LA    R15,S0C0                PROGRAM CHECK RTNE\n         TM    SDWAERRA,SDWAPCHK       IS THIS A PROGRAM CHECK?\n         BO    DIAG067                 YES, JUMP\n         LA    R15,S013                O/C/E ABEND RTNE\n         CLI   OCE_CODE,0              IS THIS AN OPEN/CLOSE/EOV ABEND?\n         BNE   DIAG067                 YES, JUMP\n         B     DIAG999                 NO DIAG FOR THIS ABEND\n*\nDIAG066  L     R15,000(,R1)            ADDR OF DIAG RTNE\nDIAG067  BALR  R14,R15             <== CALL THE ROUTINE\n         B     DIAG999                 NO DIAG FOR THIS ABEND\n*\nDIAG094  DC    A(S001),C'S001'         SAM\nDIAG095  DC    A(S001),C'S002'         SAM\n*\nDIAG999  END_PROC\n*\n*----------------------------------------------------------------------\n*        DIAGNOSTIC FOR S001 & S002 ABENDS\n*----------------------------------------------------------------------\n*\nS001     BEGIN_PROC\n         CLI   OCE_CODE,C'E'           EOV SVC?\n         BNE   S001ZZ                  NO, QUIT\n         BAL   R14,BLANK1              BLANK LINE\n         L     R1,FRSTSVRB             LOAD ADDR OF FIRST SVRB\n         SLR   R5,R5                   no DEB\n         L     R6,RBGRS1-RBPREFIX(,R1) R6 POINTS TO DCB\n         ICM   R6,B'1000',X00          ZERO HI-ORDER BYTE OF DCB ADDR\n         BAL   R14,SWA000          <== locate DEB/DSAB/SIOT/JFCB/TIOT\n         BAL   R14,VALDCB          <== VALIDATE DCB\n         LTR   R6,R6                   GOOD DCB?\n         BZ    S001ZZ                  NO, QUIT\n         STRING (ABCODE,,T),' OCCURED WHILE PROCESSING DDN=',          X\n               DDNAME2,INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n         BAL   R14,PRDCB           <== PRINT DCB\n**      $PRTDSN DDNAME,INTO=LINE       PRINT ALLOCATION\nS001ZZ   END_PROC\n*\n*----------------------------------------------------------------------\n*        DIAGNOSTIC FOR O/C/E ABENDS\n*----------------------------------------------------------------------\n*\nS013     BEGIN_PROC\n        #S0C4  S013ZZ\n         L     R6,SDWAGR02             R6 POINTS TO DCB\n         USING IHADCB,R6\n         L     R7,SDWAGR04             R7 POINTS TO O/C/E WORK AREA\n         L     R1,FRSTSVRB             POINT TO 1ST SVRB        @921013\n         CLI   RBWLIC-RBPREFIX(R1),0   THIS RB WAITING?         @921013\n         BE    S013B                   NO, JUMP                 @921013\n         L     R6,RBEXSAVE+00-RBPREFIX(,R1)  GET R2 VALUE       @921013\n         L     R7,RBEXSAVE+08-RBPREFIX(,R1)  GET R4 VALUE       @921013\nS013B    SLR   R5,R5                   no DEB\n         BAL   R14,SWA000          <== locate DEB/DSAB/SIOT/JFCB/TIOT\n         BAL   R14,VALDCB          <== VALIDATE DCB\n         LTR   R6,R6                   GOOD DCB?\n         BZ    S013ZZ                  NO, QUIT\n         BAL   R14,BLANK1              BLANK LINE\n         STRING (ABCODE,,T),' OCCURED WHILE PROCESSING DDN=',          X\n               DDNAME2,INTO=LINE\n         BAL   R14,SPACE1          <== PRINT MESSAGE\n         BAL   R14,PRDCB           <== PRINT DCB\n        #S0C4  S013ZZ\n         CLI   0(R7),0                 ANY TAPE LABEL?\n         BE    S013ZZ                  NO, QUIT\n         CLC   0(256,R7),0             VALIDATE O/C/E WORK AREA\n        #S0C4  RESET\n         STRING '0   O/C/E WORK AREA:',INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\n         LA    R0,X'298'               LENGTH OF O/C/E WORK AREA\n         LR    R1,R7                   PASS ADDRESS\n         BAL   R14,PDUMP           <== DUMP IT\nS013ZZ   END_PROC\n         DROP  R6                      WAS IHADCB\n*\n*----------------------------------------------------------------------\n*        DIAGNOSTIC FOR S0CX (PROGRAM CHECK) ABENDS\n*----------------------------------------------------------------------\n*\nS0C0     BEGIN_PROC\n         BAL   R14,BLANK1              BLANK LINE\n        #SETMASK SDWANXT1              SET ADDRESS CLEAN-UP MASK\n         L     R6,SDWANXT1             NEXT INSTRUCTION ADDRESS\n         N     R6,MASKADDR             CLEAN-UP ADDRESS\n         SR    R1,R1\n         IC    R1,SDWAILC1             INSTR LEN CODE\n         CLI   SDWAICD1,X'10'          SEGMENT TRANSLATION EXCEPTION?\n         BE    S0C0F                   YES, JUMP\n         CLI   SDWAICD1,X'11'          PAGE TRANSLATION EXCEPTION?\n         BE    S0C0F                   YES, JUMP\n         SR    R6,R1                   POINT TO INSTRUCTION\n*\nS0C0F    LR    R1,R6                   INSTRUCTION ADDR\n         BAL   R14,CSVQRY00        <== FIND PROGRAM NAME\n*\n         IC    R0,SDWAICD1             EXCEPTION CODE IN R0\n         L     R1,=A(PCKTABLE)         START OF PROGRAM-CHECK TABLE\n         BAL   R14,SCANTBL             FIND EXCEPTION NAME\n         BE    S0C0P                   FOUND, JUMP\n         LA    R1,=C'..UNKNOWN'        FAKE IT\n         LA    R2,7                    FAKE IT\nS0C0P    STRING 2X,(2(R1),(R2)),' EXCEPTION OCCURED AT LOCATION ',     X\n               ((R6),,X),2X,MSG20,INTO=LINE\n         BAL   R14,SPACE1          <== PRINT MESSAGE\n         BAL   R14,PRINTI          <== PRINT INSTRUCTION\n         STRING '  INSTRUCTION IS ',(MSG20,(R1)),INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n         BAL   R14,EXECUTE         <== PRINT EXECUTED INSTRUCTION\n*\n         CLI   SDWAICD1,X'10'          SEGMENT TRANSLATION EXCEPTION?\n         BE    S0C5                    YES, JUMP\n         CLI   SDWAICD1,X'11'          PAGE TRANSLATION EXCEPTION?\n         BNE   S0C0ZZ                  NO, EXIT\nS0C5     STRING '  ADDRESS CAUSING EXCEPTION: ',                       X\n               (SDWATRAN,,X),INTO=LINE\n         BAL   R14,SPACE1          <== Print line\nS0C0ZZ   END_PROC\n*\n*----------------------------------------------------------------------\n*        PRINT DATA SET ALLOCATIONS\n*----------------------------------------------------------------------\n*\nTIOT00   BEGIN_PROC\n         BAL   R14,BLANK1          <== BLANK LINE\n         L     R1,CVTPTR(,0)           CVT ADDRESS\n         L     R1,CVTLINK-CVTMAP(,R1)  LINKLIST DCB\n         LOAD  EP=IEFEB4UV,DCB=(1)\n         ST    R0,IEFEB4UV\n**       L     R4,PSATOLD-PSA(,0)      MY TCB\n**       USING TCB,R4\n*\nTIOT20   L     R5,TCBTIO               TIOT\n         USING TIOT1,R5\n         L     R6,PSAAOLD-PSA(,0)      MY ASCB\n         L     R6,ASCBOUCB-ASCB(,R6)   MY OUCB\n         USING OUCB,R6\n         MVI   MINLINES,8\n***      STRING '-  JOBNAME: ',TIOCNJOB,'  STEP: ',(TIOCSTEP+0,8),     X\n               '  PROCSTEP: ',(TIOCSTEP+8,8),                          X\n               '  PERFORM=',(OUCBNPG,H,L),                             X\n               INTO=LINE121\n         STRING '  DDNAME  DISP VOLSER   EXCP DATA SET NAME',32X,      X\n               'DEVICE   DEVN  MISCELLANEOUS',INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n         MVI   LINE,C'0'               CTLCHR\n         L     R1,PSATOLD-PSA(,0)      MY TCB\n         L     R1,TCBJSCB-TCB(,R1)     MY JSCB\n         L     R1,JSCDSABQ-IEZJSCB(,R1)  DSAB QDB\n         L     R5,DSQFRSTP-DSABQDB(,R1)  FIRST DSAB ON CHAIN\n         USING DSAB,R5\n*LOOP\nTIOT_GET ICM   R6,B'1111',DSABSIOT     POINT TO SIOT\n         BNZ   TIOT31                  GOOD ADDRESS, USE IT\n         LA    R6,TENWORDS+4           WORK AREA\n         ST    R6,TENWORDS             WORK AREA\n         USING ZB505,R6\n         XC    SWAEPAX,SWAEPAX         CLEAR WORK AREA\n         MVC   SWVA,DSABSSVA           SVA OF THE SIOT\n         SWAREQ FCODE=RL,EPA=TENWORDS,MF=(E,SWAREQL1),UNAUTH=YES\n         L     R6,SWBLKPTR             31-BIT ADDRESS OF SIOT\n         USING INDMSIOT,R6\n*\nTIOT31   L     R7,SJFCBPTR             GET JFCB ADDRESS FROM SIOT\n         USING INFMJFCB,R7\n*\n         MVC   MSG60,BLANKS            CLEAR WORK AREA\n         MVC   STATUS,BLANKS           CLEAR WORK AREA\n         MVC   UNITNAME,BLANKS         CLEAR WORK AREA\n         MVC   VOLSER,BLANKS\n         SLR   R1,R1                   EXCP=0\n         SLR   R3,R3                   NO UCB\n         MVC   VOLSER(4),SIOTSSNM      SYSIN/SYSOUT\n         TM    JFCBTSDM,JFCSDS         IS THIS A JES DATA SET?\n         BO    TIOT61                  YES, JUMP\n         MVC   VOLSER,=C'DUMMY   '     DUMMY DATA SET\n         TM    SCTSBYT1,SCTDUMMY       DD DUMMY?\n         BO    TIOT62                  yes, jump\n         ICM   R3,B'0111',SIOUCBAD     UCB ADDRESS\n ORG *-4 UCB above the line\n         L     R3,SIOUCBA4             31-BIT UCB ADDRESS\n         USING UCBOB,R3\n         MVC   UNITNAME+8(4),UCBTYP    DEVICE TYPE\n         BAL   R14,GETUNIT         <== GET UNITNAME\n         MVC   VOLSER,=C'VIO     '     UNIT=VIO\n         TM    UCBJBNR,UCBVRDEV        IS THIS A VIO DATA SET?\n         BO    TIOT41                  YES, JUMP\n         MVC   VOLSER,UCBVOLI          NO, MOVE FIRST VOLSER\n         TR    VOLSER,TRTPRINT         get rid of garbage\n         CLC   VOLSER,UCBVOLI          is the volser ok?\n         BE    TIOT41                  YES, JUMP\n         MVC   VOLSER,BLANKS           NO, blank it out\n*\nTIOT41   BAS   R1,TIOT41IC\n         DC    C'NEW',AL1(JFCNEW)\n         DC    C'MOD',AL1(JFCMOD)\n         DC    C'SHR',AL1(JFCOLD+JFCSHARE)\n         DC    C'OLD',AL1(JFCOLD)\n         DC    C'???',0H'0'\nTIOT41TM TM    JFCBIND2,*-*            TEST LABEL TYPE FLAGS\n*--LOOP\nTIOT41IC IC    R15,3(,R1)              PICK UP MASK FOR \"TM\"\n         EX    R15,TIOT41TM\n         BO    TIOT41X\n         LA    R1,3+1(,R1)             BUMP TABLE PTR\n         CLI   0(R1),C'?'              END OF TABLE?\n         BNE   TIOT41IC                NEXT TABLE ENTRY\n*--ENDLOOP\nTIOT41X  MVC   STATUS,0(R1)            DISP\n*\nTIOT43S  TM    UCBFL5,UCBSMS           SMS VOL?     X'20'\n         BZ    TIOT43V                 NO, JUMP\n         STRING (MSG60,,T),',SMS',INTO=MSG60\n*\nTIOT43V  CLC   JFCDSORG,=AL2(JFCORGAM) VSAM DATA SET?\n         BNE   TIOT46                  NO, JUMP\n         STRING (MSG60,,T),',VSAM',INTO=MSG60\n         B     TIOT61\n*\nTIOT46   CLI   UCBTBYT3,UCB3TAPE       TAPE DEVICE?\n         BE    TIOT46B                 yes, jump\n         CLI   UCBTBYT3,UCB3DACC       DASD DEVICE?\n         BNE   TIOT61                  NO, JUMP\n         TM    JFCBLTYP,JFCSUL         LABEL=(,SUL) ?\n         BNO   TIOT61                  no, jump\nTIOT46B  BAS   R1,TIOT46IC\n         DC    C'LTM',AL1(JFCBLTM)\n         DC    C'BLP',AL1(JFCBLP)\n         DC    C'SUL',AL1(JFCSUL)\n         DC    C'AUL',AL1(JFCSUL+JFCBAL)\n         DC    C'AL ',AL1(JFCBAL)\n         DC    C'NSL',AL1(JFCNSL)\n         DC    C'SL ',AL1(JFCSL)\n         DC    C'NL ',AL1(JFCNL)\n         DC    C'???',0H'0'\nTIOT46TM TM    JFCBLTYP,*-*            TEST LABEL TYPE FLAGS\n*--LOOP\nTIOT46IC IC    R15,3(,R1)              PICK UP MASK FOR \"TM\"\n         EX    R15,TIOT46TM\n         BO    TIOT46X\n         LA    R1,3+1(,R1)             BUMP TABLE PTR\n         CLI   0(R1),C'?'              END OF TABLE?\n         BNE   TIOT46IC                NEXT TABLE ENTRY\n*--ENDLOOP\nTIOT46X  LH    R0,JFCBFLSQ             PICK UP FILE SEQUENCE NUMBER\n         LTR   R0,R0                   LABEL=0?\n         BNZ   TIOT46Y                 NO, JUMP\n         LA    R0,0001                 YES, CHANGE TO LABEL=1\nTIOT46Y  STRING ',',((R0),,L),',',((R1),3),INTO=MSG60\n*\nTIOT61   L     R0,DSABTIOT             POINT TO CURRENT TIOT ENTRY\n         SL    R0,TCBTIO               CHANGE ADDRESS TO OFFSET\n         BAL   R14,EXCP00          <== GET EXCP COUNT IN R1\n*\nTIOT62   STRING ((R1),,R6B),INTO=WKCELL2\n         CL    R1,=F'100000'           OVER 100K?\n         BL    TIOT63                  NO, JUMP\n         SLR   R0,R0                   YES, DIVIDE BY 1000\n         LA    R1,500(,R1)             YES, DIVIDE BY 1000\n         D     R0,=F'1000'             YES, DIVIDE BY 1000\n         STRING ((R1),,R5B),'K',INTO=WKCELL2\n*\nTIOT63   TM    JFCBTSDM,JFCSDS         IS THIS A JES DATA SET?\n         BZ    TIOT64                  NO, JUMP\n         CLI   SCTOUTPN,C' '           DO WE HAVE A CLASS?\n         BE    TIOT64                  NO, JUMP\n         STRING ',SYSOUT=',SCTOUTPN,INTO=MSG60\n         ICM   R0,B'0111',JFCOUTLI     OUTLIM=0?\n         BE    TIOT64                  YES, JUMP\n         STRING (MSG60,,T),',OUTLIM=',(JFCOUTLI,FL3,L),INTO=MSG60\n*\nTIOT64   LTR   R3,R3                   DO WE HAVE A UCB?\n         BNZ   TIOT64U                 YES, JUMP\n         MVC   UCB_NAME,BLANKS\n         LA    R3,BLANKS               NO, POINT TO A DUMMY UCB\n         B     TIOT65\nTIOT64U  UCBDEVN DEVN=UCB_NAME         get UCB name (ESA V4 only)\n*\nTIOT65   MVC   EYECATCH(L'JFCBDSNM),JFCBDSNM MOVE DATA SET NAME\n         TM    JFCBIND1,JFCPDS         DO WE HAVE A MEMBER NAME?\n         BZ    TIOT71                  NO, JUMP\n         STRING (JFCBDSNM,,T),'(',(JFCBELNM,,T),')',INTO=EYECATCH\nTIOT65L  CLI   EYECATCH+L'JFCBDSNM,C' ' OVERFLOW?\n         BE    TIOT71                  NO, JUMP\n         MVC   EYECATCH(60),EYECATCH+1 SHIFT DSN(MBR) TO THE LEFT\n         B     TIOT65L                 TRY AGAIN\n*\nTIOT71   ICM   R0,B'0011',DSABOPCT     Any DCB OPEN?\n         BZ    TIOT_PRT                NO, JUMP\n         STRING (MSG60,,T),',OPEN',INTO=MSG60\n*\nTIOT_PRT STRING 2X,SCTDDNAM,1X,STATUS,1X,VOLSER,1X,(WKCELL2,7),        X\n               (EYECATCH,L'JFCBDSNM),1X,UNITNAME,1X,UCB_NAME,2X,       X\n               (MSG60+1,L'MSG60-1),INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n*\nTIOT_NXT L     R5,DSABFCHN             NEXT DSAB                  -\n         LTR   R5,R5                   end of chain?\n         BNZ   TIOT_GET                NOT YET, LOOP THROUGH TIOT\n*ENDLOOP\n         DROP  R5,R6,R7,R3             DSAB, SIOT, JFCB, UCB\n         DELETE EP=IEFEB4UV\nTIOT90   END_PROC\n*\n*----------------------------------------------------------------------\n*\n*        PRINT PSW, REGISTERS\n*\n*              SDWA DATA (PSW1/PSW2)\n*              LAST PRB DATA (IF REQUIRED)\n*\n*----------------------------------------------------------------------\n*\nPSW00    BEGIN_PROC\n         BAL   R14,BLANK1          <== BLANK LINE\n        #SETMASK SDWANXT1              SET ADDRESS CLEAN-UP MASK\n         L     R1,SDWANXT1             NEXT INSTRUCTION\n         BAL   R14,CSVQRY00        <== FIND CORRESPONDING CDE\nPSW11    STRING 'PSW1: ',(SDWAEC1,4,X),1X,(SDWAEC1+4,4,X),2X,MSG20,    X\n               '  ILC: ',(SDWAILC1,FL1,L),                             X\n               '  INTC: ',(SDWAINC1,,X),INTO=LINE\n         MVI   MINLINES,8\n         BAL   R14,SPACE1          <== Print line\n         L     R1,SDWANXT1             NEXT INSTRUCTION\n         N     R1,MASKADDR             CLEAN UP ADDRESS\n         SH    R1,=H'6'                6 BYTES BEFORE\n         BNP   PSW15                   LOW CORE\n        #S0C4  PSW15\n         CLC   0(12,R1),0(R1)          VALIDATE 12 BYTES\n        #S0C4  RESET\n         STRING ' DATA AROUND PSW1 ADDR:  ',INTO=LINE,                 X\n               (00(R1),2,X),1X,(02(R1),2,X),1X,(04(R1),2,X),1X,        X\n               (06(R1),2,X),1X,(08(R1),2,X),1X,(10(R1),2,X),1X\n         BAL   R14,SPACE1          <== Print line\n*SW15    BAL   R14,EXECUTE         <== PROCESS 'EX' OPCODE (X'44')\nPSW15    STRING '0   GPR00-03: ',(SDWAGR00,,X),2X,(SDWAGR01,,X),2X,    X\n               (SDWAGR02,,X),2X,(SDWAGR03,,X),INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\n         STRING '   GPR04-07: ',(SDWAGR04,,X),2X,(SDWAGR05,,X),2X,     X\n               (SDWAGR06,,X),2X,(SDWAGR07,,X),INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n         STRING '   GPR08-11: ',(SDWAGR08,,X),2X,(SDWAGR09,,X),2X,     X\n               (SDWAGR10,,X),2X,(SDWAGR11,,X),INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n         STRING '   GPR12-15: ',(SDWAGR12,,X),2X,(SDWAGR13,,X),2X,     X\n               (SDWAGR14,,X),2X,(SDWAGR15,,X),INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n*\nPSW20    CLC   SDWAEC1,SDWAEC2         PSW1=PSW2?\n         BE    PSW99                   YES, DON'T BOTHER\n         L     R1,SDWANXT2             NEXT INSTRUCTION\n         LTR   R1,R1                   ANY DATA THERE?\n         BZ    PSW31                   NONE, DON'T BOTHER       @911019\n        #SETMASK SDWANXT2              SET ADDRESS CLEAN-UP MASK\n         BAL   R14,CSVQRY00        <== FIND CORRESPONDING CDE\n         BAL   R14,BLANK1          <== BLANK LINE\n         MVI   MINLINES,8\n         STRING 'PSW2: ',(SDWAEC2,4,X),1X,(SDWAEC2+4,4,X),2X,MSG20,    X\n               '  ILC: ',(SDWAILC2,FL1,L),                             X\n               '  INTC: ',(SDWAINC2,,X),ORIGIN2,INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n         L     R1,SDWANXT2             NEXT INSTRUCTION\n         N     R1,MASKADDR             CLEAN UP ADDRESS\n         SH    R1,=H'6'                6 BYTES BEFORE\n        #S0C4  PSW25\n         CLC   0(12,R1),0(R1)          VALIDATE 12 BYTES\n        #S0C4  RESET\n         STRING ' DATA AROUND PSW2 ADDR:  ',INTO=LINE,                 X\n               (00(R1),2,X),1X,(02(R1),2,X),1X,(04(R1),2,X),1X,        X\n               (06(R1),2,X),1X,(08(R1),2,X),1X,(10(R1),2,X),1X\n         BAL   R14,SPACE1          <== Print line\nPSW25    STRING '0   GPR00-03: ',(SDWASR00,,X),2X,(SDWASR01,,X),2X,    X\n               (SDWASR02,,X),2X,(SDWASR03,,X),INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\n         STRING '   GPR04-07: ',(SDWASR04,,X),2X,(SDWASR05,,X),2X,     X\n               (SDWASR06,,X),2X,(SDWASR07,,X),INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n         STRING '   GPR08-11: ',(SDWASR08,,X),2X,(SDWASR09,,X),2X,     X\n               (SDWASR10,,X),2X,(SDWASR11,,X),INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n         STRING '   GPR12-15: ',(SDWASR12,,X),2X,(SDWASR13,,X),2X,     X\n               (SDWASR14,,X),2X,(SDWASR15,,X),INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n*\n*        PRINT PSW AND REGS FOR LAST PRB IF DIFFERENT FROM PSW1/2\n*\nPSW31    L     R6,LASTPRB              LAST PRB\n         USING RBPREFIX,R6\n         CLC   SDWAEC1,RBOPSW          SAME AS PSW1 IN SDWA?\n         BE    PSW99                   YES, JUMP\n         CLC   SDWAEC2,RBOPSW          SAME AS PSW2 IN SDWA?\n         BE    PSW99                   YES, JUMP\n        #SETMASK RBOPSW+4              SET ADDRESS CLEAN-UP MASK\n         L     R1,RBOPSW+4             NEXT INSTRUCTION\n         BAL   R14,CSVQRY00        <== FIND CORRESPONDING CDE\n         BAL   R14,BLANK1          <== BLANK LINE\n         MVI   MINLINES,8\n         STRING 'PSW3: ',(RBOPSW,4,X),1X,(RBOPSW+4,4,X),2X,MSG20,      X\n               '  ILC: ',(RBWLIC+1,FL1,L),                             X\n               '  INTC: ',(RBWLIC+2,2,X),                              X\n               '  (LASTPRB)',INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n         L     R1,RBOPSW+4             NEXT INSTRUCTION\n         N     R1,MASKADDR             CLEAN UP ADDRESS\n         SH    R1,=H'6'                6 BYTES BEFORE\n        #S0C4  PSW35\n         CLC   0(12,R1),0(R1)          VALIDATE 12 BYTES\n        #S0C4  RESET\n         STRING ' DATA AROUND PSW3 ADDR:  ',INTO=LINE,                 X\n               (00(R1),2,X),1X,(02(R1),2,X),1X,(04(R1),2,X),1X,        X\n               (06(R1),2,X),1X,(08(R1),2,X),1X,(10(R1),2,X),1X\n         BAL   R14,SPACE1          <== Print line\nPSW35    L     R6,FRSTSVRB             NEXT IRB/SVRB\n         STRING '0   GPR00-03: ',(RBGRS0,,X),2X,(RBGRS1,,X),2X,        X\n               (RBGRS2,,X),2X,(RBGRS3,,X),INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\n         STRING '   GPR04-07: ',(RBGRS4,,X),2X,(RBGRS5,,X),2X,         X\n               (RBGRS6,,X),2X,(RBGRS7,,X),INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n         STRING '   GPR08-11: ',(RBGRS8,,X),2X,(RBGRS9,,X),2X,         X\n               (RBGRS10,,X),2X,(RBGRS11,,X),INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n         STRING '   GPR12-15: ',(RBGRS12,,X),2X,(RBGRS13,,X),2X,       X\n               (RBGRS14,,X),2X,(RBGRS15,,X),INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n         DROP  R6                      PRB\nPSW99    END_PROC\n*\n*----------------------------------------------------------------------\n*        PRINT JOB/STEP INFORMATION\n*----------------------------------------------------------------------\n*\nJOBSTEP  BEGIN_PROC\n         BAL   R14,BLANK1              blank line\n         STRING 'JOB/STEP INFORMATION',INTO=LINE\n         BAL   R14,SPACE2              Double Space\n*\n         L     R4,TCBJSCB              job step control block\n         USING IEZJSCB,R4\n         L     R5,JSCBJCT              Job Control Table\n         USING JCT,R5\n         SLR   R7,R7\n         ICM   R7,B'0111',JCTACTAD     SVA OF ACT\n         USING IEFAACTB-16,R7\n*\n         STRING '  //',(JCTJNAME,,T),' JOB ',INTO=LINE\n         MVI   WKCELL3,C' '            no comma\n         MVI   WKCELL3+1,C'('          begin sub-list\n         SLR   R3,R3\n         ICM   R3,B'0001',ACTJNFLD     # OF ACCT FIELDS\n         BZ    JOBS120                 no account information\n         CLC   =X'0100',ACTJNFLD       one null sub-field?\n         BE    JOBS120                 yes, ignore\n         LA    R1,ACTJNFLD+1           first sub-parm\n         SLR   R2,R2\n*loop\nJOBS114  ICM   R2,B'0001',0(R1)        size of sub-parm\n         STRING (1(R1),(R2)),INTO=MSG60\n         BAL   R14,JOBS155             append new text to current line\n         LA    R1,1(R2,R1)             skip current sub-field\n         BCT   R3,JOBS114              next sub-field\n*endloop\n         LA    R15,LINE(R15)           last pos in line\n         MVI   0(R15),C')'             close sub-list\n         B     JOBS121\n*\nJOBS120  MVI   WKCELL3+1,C','          ACCT field missing\n*\nJOBS121  CLC   ACTPRGNM,BLANKS         do we have a PROGRAMMER'S NAME ?\n         BE    JOBS122                 no, jump\n         STRING (ACTPRGNM,,T),INTO=MSG60\n         BAL   R14,JOBS155             append new text to current line\n*\nJOBS122  CLI   JCTJCSMF,X'E0'          TSO user?\n         BE    JOBS125                 yes, jump\n         CLI   JCTJCSMF,X'E0'          Started Task?\n         BE    JOBS125                 yes, jump\n         STRING 'CLASS=',JCTJCSMF,INTO=MSG60\n         BAL   R14,JOBS155             append new text to current line\n*\nJOBS125  STRING 'MSGCLASS=',JCTJMGPO,INTO=MSG60\n         BAL   R14,JOBS155             append new text to current line\n*\nJOBS130  STRING 'MSGLEVEL=(1,1)',INTO=MSG60     MSGLEVEL=(1,1)\n         TM    JCTJMGLV,INCMMGL1       MSGLEVEL=1 ?\n         BO    JOBS133                 yes, jump\n         MVI   MSG60+10,C'2'           MSGLEVEL=(2,1)\n         TM    JCTJMGLV,INCMMGL2       MSGLEVEL=2 ?\n         BO    JOBS133                 yes, jump\n         MVI   MSG60+10,C'0'           MSGLEVEL=(0,1)\nJOBS133  TM    JCTJMGLV,INCMALL        MSGLEVEL=(,1) ?\n         BO    JOBS134                 yes, jump\n         MVI   MSG60+12,C'0'           MSGLEVEL=(,0)\nJOBS134  BAL   R14,JOBS155             append new text to current line\n*\nJOBS136  SLR   R6,R6\n         ICM   R6,B'0111',JCTJCTX      SVA OF JCTX\n         USING JCTX,R6\n         L     R1,JCTXJTL              JOB TIME limit (ESA410)\n         CLI   SPLEVEL,4               running on ESA 410?\n         BNL   JOBS136T                yes, jump\n         SLR   R1,R1\n         ICM   R1,B'0111',JCTJMRTL     JOB TIME limit (XA,ESA313)\nJOBS136T LTR   R1,R1                   TIME=0 (TSO) ?\n         BZ    JOBS140                 yes, exit\n         SLR   R0,R0\n         D     R0,=F'100'              get time in seconds\n         SLR   R0,R0\n         D     R0,=F'60'               get time in minutes\n         STRING 'TIME=(',((R1),,L),',',((R0),,L),')',INTO=MSG60\n         BAL   R14,JOBS155             append new text to current line\n*\nJOBS140  L     R6,JSCSCT               Current step's SCT\n         USING SCT,R6\n         LH    R2,JCTEQREG             region parm from job card\n         CH    R2,=H'16383'            region > 16M ?\n         BE    JOBS146                 yes, jump\n         CLM   R2,B'0111',SCTRGSZ      same as REGION on EXEC card ?\n         BNE   JOBS147                 no, exit\nJOBS146  ICM   R2,B'0111',SCTRGSZ      yes, use value from EXEC card\n         STRING 'REGION=',((R2),,L),'K',INTO=MSG60\n         BAL   R14,JOBS155             append new text to current line\n         BSM   R5,0                    make R5 negative\n*\nJOBS147  TM    JCTSTAT2,JCTPERFM       PERFORM specified on EXEC?\n         BZ    JOBS149                 no, jump\n         STRING 'PERFORM=',(SCTPRFMF,H,L),INTO=MSG60\n         BAL   R14,JOBS155             append new text to current line\n         BSM   R6,0                    make R6 negative\n*\nJOBS149  L     R2,PSAAOLD-PSA(,0)      MY ASCB\n         USING ASCB,R2\n         L     R3,ASCBASXB             MY ASXB\n         USING ASXB,R3\n         STRING 'USER=',(ASXBUSER,,T),INTO=MSG60\n         BAL   R14,JOBS155             append new text to current line\n         ICM   R3,B'1111',ASXBSENV     MY ACEE\n         BNP   JOBS149Z                no RACF, exit\n         USING ACEE,R3\n         STRING 'GROUP=',(ACEEGRPN,,T),INTO=MSG60\n         BAL   R14,JOBS155             append new text to current line\nJOBS149Z BAL   R14,SPACE2          <== Double Space\n         B     JOBS162\n*\n*        append MSG60 to LINE\n*\nJOBS155  ST    R14,WKCELL3+4           save return address\n         LTR   R0,R15                  save length\n         BZ    JOBS155C                zero length, jump\n         LA    R14,MSG60               FIRST POS\nJOBS155L CLI   0(R14),C' '             imbedded space?\n         BE    JOBS155Q                YES, EXIT\n**MSGL   CLI   0(R14),C','             imbedded comma?\n**MSGL   BE    JOBS155Q                YES, EXIT\n         LA    R14,1(,R14)             BUMP POINTER\n         BCT   R15,JOBS155L            SCAN AREA\n         B     JOBS155C                YES, EXIT\nJOBS155Q MVC   EYECATCH,MSG60          move to work area\n         STRING '''',(EYECATCH,(R0)),'''',INTO=MSG60\n         LR    R0,R15                  save length\nJOBS155C STRING (LINE,,T),(WKCELL3,2,T),(MSG60,(R0)),',',INTO=EYECATCH\n         CL    R15,=F'80'              overflow?\n         BH    JOBS155O                yes, jump\n         STRING (LINE,,T),(WKCELL3,2,T),(MSG60,(R0)),INTO=LINE\n         B     JOBS155X\nJOBS155O STRING (LINE,,T),',',INTO=LINE\n         BAL   R14,SPACE1          <== Single space\n         STRING '  // ',(MSG60,(R0)),INTO=LINE\nJOBS155X MVI   WKCELL3,C','            next parm needs a comma\n         MVI   WKCELL3+1,C' '          next parm needs no space\n         L     R14,WKCELL3+4           return address\n         BR    R14\n*\nJOBS162  MVC   WKCELL1(5),=C'Below'    default placement for SWA\n         TM    JCTSTAT2,JCTSWAUP       SWA above?\n         BZ    JOBS163                 no, jump\n         MVC   WKCELL1(5),=C'Above'    yes, remember it\nJOBS163  MVC   WKCELL2(3),=C'No '      default\n         TM    JCTSTAT2,JCTBLP         BLP authorized?\n         BZ    JOBS164                 no, jump\n         MVC   WKCELL2(3),=C'Yes'      yes, remember it\nJOBS164  MVC   WKCELL3(3),=C'No '      default\n         TM    JSCBJJSB,JSCBJNLF       Job Journaling active?\n         BO    JOBS168                 no, jump\n         MVC   WKCELL3(3),=C'Yes'      yes, remember it\nJOBS168  L     R3,JSCBSSIB             point to the SSIB\n         USING SSIB,R3\n         STRING '    Sub-System(',SSIBSSNM,')',                        X\n               '  JOB-Id(',SSIBJBID,')',                               X\n               '  SWA(',(WKCELL1,5),')',     SWA(below/above)          X\n               '  BLP(',(WKCELL2,3,T),')',     BLP(yes/no)             X\n               '  Journal(',(WKCELL3,3,T),')', Job Journal (yes/no)    X\n               '  ASID(X''',(ASCBASID,,X),''')',                       X\n               INTO=LINE\n         BAL   R14,SPACE1          <== Single space\n*\nJOBS170  ICM   R0,B'0111',JCTJMRJD     OS/390 R3 Bug?\n         BZ    JOBS172                 yes, use Y2K date from JCTX\n         ZAP   WKCELL1,JCTJMRJD        yydddF   (prior to HBB4430)\n         ZAP   WKCELL2,JCTSSD          yydddF   (prior to HBB4430)\n         B     JOBS173                 continue\nJOBS172  EQU   *\n         SLR   R14,R14\n         ICM   R14,B'0111',JCTJCTX     SVA OF JCTX\n         ZAP   WKCELL1,JCTXJMRD-JCTX(,R14) 0cyydddF (HBB4430 and up)\n         ZAP   WKCELL2,JCTXSSD-JCTX(,R14) 0cyydddF (HBB4430 and up)\nJOBS173  EQU   *\n         SLR   R0,R0\n         SLR   R1,R1\n         ICM   R1,B'0111',JCTJMRJT     job start time (binary)\n         D     R0,=F'00360000'         GET HOURS\n         LR    R2,R1                   HH\n         LR    R1,R0                   REMAINDER\n         SLR   R0,R0\n         D     R0,=F'6000'             GET MINUTES IN R1\n         LR    R3,R1                   MM\n         LR    R1,R0                   REMAINDER\n         SLR   R0,R0\n         D     R0,=F'100'              GET SECONDS IN R1\n         STRING '    Job Start Date: ',(WKCELL1,P,YYYY-MM-DD),         X\n               ' (',(WKCELL1+4+1,1,X),'.',(WKCELL1+4+2,P,R3Z),') ',    X\n               '  Time: ',((R2),,R2Z),':',((R3),,R2Z),':',((R1),,R2Z), X\n               INTO=LINE\n         BAL   R14,SPACE2          <== Double space\n*\n*        CPU time used (JOB)\n*\nJOBS180  SLR   R0,R0\n         L     R1,ACTJTIME             Accumulated TCB time\n         A     R1,JCTSRBT              Accumulated SRB time\n         BZ    JOBS200                 zero, quit\n         D     R0,=F'00360000'         GET HOURS\n         LR    R2,R1                   HH\n         LR    R1,R0                   REMAINDER\n         SLR   R0,R0\n         D     R0,=F'6000'             GET MINUTES IN R1\n         LR    R3,R1                   MM\n         LR    R1,R0                   REMAINDER\n         SLR   R0,R0\n         D     R0,=F'100'              GET SECONDS IN R1\n         STRING '    CPU time used: ',((R2),,R3Z),'H',((R3),,R2Z),'M', X\n               ((R1),,R2Z),'S',((R0),,R2Z),                            X\n               INTO=LINE\n**           1X,(ACTJTIME,,X),1X,(JCTSRBT,,X),                       X\n         BAL   R14,SPACE2          <== Double Space\n*\n*        //stepname EXEC PGM=program,REGION=1234K,TIME=(30,0)\n*\nJOBS200  SLR   R7,R7                   SCTX address\n         ICM   R7,B'0111',SCTXBTTR     address of SCTX (SCT extension)\n         USING SCTX,R7\n         SLR   R0,R0\n         ICM   R1,B'1111',SCTXSTL      step time limit (ESA410)\n         BNZ   *+8                     OK, jump\n         ICM   R1,B'0111',SCTSTIME     step time limit (XA/ESA310)\n         D     R0,=F'100'              get it in seconds\n         SLR   R0,R0\n         D     R0,=F'60'               get it in minutes\n         STRING '  //',(SCTSNAME,,T),' EXEC PGM=',(SCTPGMNM,,T),       X\n               ',TIME=(',((R1),,L),',',((R0),,L),')',                  X\n               INTO=LINE\n*\n         LTR   R5,R5                   REGION specified on JOB card?\n         BM    JOBS230                 yes, jump\n         STRING (LINE,,T),',REGION=',(SCTRGSZ,FL3,L),'K',INTO=LINE\nJOBS230  LH    R2,SCTNIUSL             max number of DD stmts\n         SH    R2,SCTLALOC             minus # of godd DDs\n         BZ    JOBS240                 zero, jump\n         STRING (LINE,,T),',DYNAMNBR=',((R2),,L),INTO=LINE\nJOBS240  EQU   *\n         LTR   R6,R6                   PERFORM specified on JOB?\n         BO    JOBS250                 yes, jump (JOB overrides EXEC)\n         TM    SCTSDP,SCTEPRFM         PERFORM specified on EXEC?\n         BZ    JOBS250                 no, jump\n         STRING (LINE,,T),',PERFORM=',(SCTPRFMF,H,L),INTO=LINE\nJOBS250  EQU   *\n         SLR   R2,R2\n         ICM   R2,B'0011',SCTSEXEC     PARM length\n         BZ    JOBS270                 no PARM, jump\n         STRING (LINE,,T),',',INTO=LINE\n         BAL   R14,SPACE1          <== next line\n         STRING '  // PARM=''',(SCTXPARM,(R2)),'''',                   X\n               INTO=LINE\nJOBS270  BAL   R14,SPACE2          <== Double Space\n*\nJOBS300  L     R6,PSAAOLD-PSA(,0)      ASCB\n         USING ASCB,R6\n         L     R7,ASCBOUCB             MY OUCB\n         USING OUCB,R7\n         STRING '    PERFORM(',(OUCBSPG,H,L),')',                      X\n               '   DPRTY(X''',(ASCBDP,,X),''')',  dispatching priority X\n               INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n*\nJOBS410  SLR   R0,R0\n         SLR   R1,R1\n         ICM   R1,B'0111',JCTJMRSS     Step start time (binary)\n         D     R0,=F'00360000'         GET HOURS\n         LR    R2,R1                   HH\n         LR    R1,R0                   REMAINDER\n         SLR   R0,R0\n         D     R0,=F'6000'             GET MINUTES IN R1\n         LR    R3,R1                   MM\n         LR    R1,R0                   REMAINDER\n         SLR   R0,R0\n         D     R0,=F'100'              GET SECONDS IN R1\n         STRING '    Step Start Date: ',(WKCELL2,P,YYYY-MM-DD),        X\n               ' (',(WKCELL1+4+1,1,X),'.',(WKCELL1+4+2,P,R3Z),') ',    X\n               '  Time: ',((R2),,R2Z),':',((R3),,R2Z),':',((R1),,R2Z), X\n               INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n*\n*        CPU TIME (STEP)\n*\nJOBS420  LM    R0,R1,ASCBEJST          GET ELAPSED JOB TCB TIME\n         CLM   R0,B'1100',=F'0'        IS TOD ACCURATE?\n         BE    JOBS421                 BRANCH IF YES\n         SR    R0,R0                   ZERO OUT R0\n         SR    R1,R1                   ZERO OUT R1\nJOBS421  DS    0H\n         SRDL  R0,0012                 IN MICRO-SECONDS\n         LM    R14,R15,ASCBSRBT        GET ELAPSED SRB TIME\n         CLM   R14,B'1100',=F'0'       IS TOD ACCURATE?\n         BE    JOBS422                 BRANCH IF YES\n         SR    R14,R14                 ZERO OUT R14\n         SR    R15,R15                 ZERO OUT R15\nJOBS422  DS    0H\n         SRDL  R14,0012                IN MICRO-SECONDS\n         ALR   R1,R15                  ADD TCB AND SRB TIME\n         BNO   JOBS423                 BRANCH IF NO OVERFLOW\n         AH    R0,=H'1'                HANDLE CARRY\nJOBS423  DS    0H\n         AR    R0,R14\n         D     R0,=F'10000'            GET IN HUNDREDTHS\n         CH    R0,=H'5000'          -  ROUND UP NEEDED ?\n         BL    JOBS427              -  BRANCH IF NOT\n         AH    R1,=H'1'             -  ROUND UP\n*\nJOBS427  SLR   R0,R0\n         D     R0,=F'100'              TIME IN SECOND\n         LR    R3,R0                   SAVE REMAINING 1/100\n         SLR   R0,R0\n         D     R0,=F'60'               TIME IN MINUTES\n         LR    R2,R0                   SAVE REMAINING SECONDS\n         SLR   R0,R0\n         D     R0,=F'60'               TIME IN HOURS\n         STRING ((R1),,L),'H',((R0),,R2Z),'M',INTO=WKCELL1\n         LTR   R1,R1                   MORE THAN 1 HOUR?\n         BNZ   JOBS429                 YES, JUMP\n         STRING ((R0),,L),'M',((R2),,R2Z),'S',INTO=WKCELL1\n         LTR   R0,R0                   MORE THAN 1 MINUTE?\n         BNZ   JOBS429                 YES, JUMP\n         STRING ((R2),,L),'.',((R3),,R2Z),INTO=WKCELL1\nJOBS429  STRING '    CPU time used: ',WKCELL1,INTO=LINE\n         BAL   R14,SPACE2          <== Double Space\n*\n*        Storage Allocation Table\n*\nJOBS600  MVI   MINLINES,6\n         STRING '  Virtual Storage Usage:',INTO=LINE\n         BAL   R14,SPACE2          <== Double Space\n         L     R5,TCBTCT               SMF Timing Control Table\n         USING SMFTCT,R5\n         L     R5,TCTCRTBL             SMF Storage Control Table\n         USING TCTCORE,R5\n         L     R6,ASCBLDA              Local Data Area\n         USING LDA,R6\n         STRING 30X,'Limit      In Use    Available    High-watermark',x\n               INTO=LINE\n         BAL   R14,SPACE2          <== Double Space\n         L     R0,LDALIMIT             LIMIT\n         SRL   R0,10                   BYTES -> KILOS\n         L     R1,LDALOAL              user region current value\n         SRL   R1,10                   BYTES -> KILOS\n         LR    R2,R0                   LIMIT\n         SLR   R2,R1                   AVAILABLE\n         L     R3,TCTLWM               high-watermark\n         SRL   R3,10                   BYTES -> KILOS\n         STRING '    User SPLS (Below)  ',INTO=LINE,((R0),,R11B),'K',  X\n               ((R1),,R11B),'K',((R2),,R12B),'K',((R3),,R14B),'K'\n         BAL   R14,SPACE1          <== Print line\n         L     R0,LDASIZA              SIZE OF PRIVATE AREA\n         SL    R0,LDALIMIT             LIMIT\n         SRL   R0,10                   BYTES -> KILOS\n         L     R1,LDAHIAL              auth region current value\n         SRL   R1,10                   BYTES -> KILOS\n         LTR   R2,R0                   LIMIT\n         BZ    *+6                     region>16M, jump\n         SLR   R2,R1                   AVAILABLE\n         L     R3,TCTHWM               high-watermark\n         SRL   R3,10                   BYTES -> KILOS\n         STRING '    Auth SPLS (Below)  ',INTO=LINE,((R0),,R11B),'K',  X\n               ((R1),,R11B),'K',((R2),,R12B),'K',((R3),,R14B),'K'\n         BAL   R14,SPACE1          <== Print line\n         L     R0,LDAELIM              LIMIT\n         SRL   R0,10                   BYTES -> KILOS\n         L     R1,LDAELOAL             user region current value\n         SRL   R1,10                   BYTES -> KILOS\n         LR    R2,R0                   LIMIT\n         SLR   R2,R1                   AVAILABLE\n         L     R3,TCTELWM              high-watermark\n         SRL   R3,10                   BYTES -> KILOS\n         STRING '    User SPLS (Above)  ',INTO=LINE,((R0),,R11B),'K',  X\n               ((R1),,R11B),'K',((R2),,R12B),'K',((R3),,R14B),'K'\n         BAL   R14,SPACE1          <== Print line\n         L     R0,LDAESIZA             SIZE OF PRIVATE AREA\n         SL    R0,LDAELIM              LIMIT\n         SRL   R0,10                   BYTES -> KILOS\n         L     R1,LDAEHIAL             auth region current value\n         SRL   R1,10                   BYTES -> KILOS\n         LTR   R2,R0                   LIMIT\n         BZ    *+6                     region=0M, jump\n         SLR   R2,R1                   AVAILABLE\n         L     R3,TCTEHWM              high-watermark\n         SRL   R3,10                   BYTES -> KILOS\n         STRING '    Auth SPLS (Above)  ',INTO=LINE,((R0),,R11B),'K',  X\n               ((R1),,R11B),'K',((R2),,R12B),'K',((R3),,R14B),'K'\n         BAL   R14,SPACE1              Print line\nJOBSTP99 END_PROC\n*\n*----------------------------------------------------------------------\n*        PRINT RB CHAIN\n*----------------------------------------------------------------------\n*\nPRB00    BEGIN_PROC\n         CL    R9,TCBJSTCB             MAIN TASK?               @920630\n         BNE   PRB1000                 NO, JUMP                 @920630\n         ICM   R0,B'1111',TCBLTC       YES, ANY SUB-TASKS?      @921020\n         BZ    PRB20                   NONE, JUMP               @921020\n*\n*        DISPLAY TCB TREE AND RB CHAINS (IF TCB IS NOT JSTCB)\n*\nPRB1000  BAL   R14,BLANK1          <== BLANK LINE\n         MVI   MINLINES,5\n         STRING 'TCB TREE AND RB CHAINS:',INTO=LINE\n         BAL   R14,SPACE1              PRINT LINE\n         STRING '0   TCB ADDRESS',18X,INTO=LINE121,                    X\n               'PROGRAM    IC  STAB  FLAGS1 CDFLGS    DDNAME'\n         BAL   R14,SPACE1              PRINT LINE\n         L     R9,TCBJSTCB             THE JOB STEP TCB\n         SLR   R3,R3                   INDENTATION INDEX\n*LOOP\nPRB1100  STCM  R9,B'0111',WKCELL1      STORE TCB ADDR\n         STRING (BLANKS,4(R3)),(WKCELL1,3,X),INTO=LINE121\n         TM    TCBFLGS5,TCBFC          task ended already?\n         BO    PRB1288                 yes, next TCB\n         SLR   R6,R6                   first time switch for NEXTRB\n*\n*        Process RB chain from the oldest RB\n*--LOOP\nPRB1200  BAL   R14,NEXTRB              Point to next RB\n         LTR   R6,R6                   end of chain?\n         BZ    PRB1290                 yes, exit loop\n         USING RBPREFIX,R6\n         CLI   RBSTAB1,RBFTPRB         IS THIS A PRB?\n         BNE   PRB1240                 NO, jump\n*227     TM    RBCDFLGS,RBCDSYNC       CHECK FLAGS\n*227     BO    PRB1260                 JUMP IF IT IS A SYNCH PRB\n         SLR   R1,R1\n         ICM   R1,B'0111',RBCDE1       Do we have a CDE?\n         BZ    PRB1230                 No, jump (must be a SYNCH PRB)\n         MVC   WKCELL1,BLANKS          TASKLIB DDNAME\n         ICM   R15,B'1111',TCBJLB      LOAD/TEST DCB ADDRESS\n         BZ    PRB1220                 NO TASKLIB, JUMP\n         MVC   WKCELL1,=C'-LNKLST-'\n         L     R14,CVTPTR(,0)          POINT AT CVT\n         CL    R15,CVTLINK-CVTMAP(,R14) SYS1.LINKLIB\n         BE    PRB1220                 JUMP IF SYS1.LINKLIB DCB ADDR\n         LH    R15,DCBTIOT-IHADCB(,R15) LOAD TIOT OFFSET\n         A     R15,TCBTIO              CHANGE OFFSET INTO AN ADDRESS\n         MVC   WKCELL1,4(R15)          MOVE TASKLIB DDNAME\n*\n*        \"LINK\" PRB\n*\nPRB1220  STRING INTO=(LINE+30,L'LINE-30),2X,                           X\n               (CDNAME-CDENTRY(R1),8),3X,      PGM NAME                X\n               (RBWLIC+3,1,X),2X,      IC                              X\n               (RBSTAB,2,X),4X,        STATUS BYTE                     X\n               (RBFLAGS1,,X),5X,       Flags                           X\n               (RBCDFLGS,,X),6X,       FLAGS                           X\n               WKCELL1                 DDNAME OF TASKLIB\n*        DISPLAY REG1 FOR DATACOM SUB-TASK                      @930824\n         CLC   =C'DBISBPR ',CDNAME-CDENTRY(R1)    DATACOM/DB?   @930824\n         BNE   PRB1270                 no, jump                 @930824\n         LA    R1,LINE+30(R15)         END OF TEXT              @930824\n         STRING ' R1=',(RBGRS1,,X),INTO=((R1),5+8)              @930824\n         B     PRB1270\n*\n*        \"SYNCH\" PRB\n*\nPRB1230  MVC   WKCELL1,RBGRS15         PICK UP ENTRY POINT ADDRESS\n         NI    WKCELL1+3,X'FE'         SET BIT 31 TO ZERO\n         STRING INTO=(LINE+30,L'LINE-30),2X,                           X\n               (WKCELL1,4,X),3X,       EP ADDRESS                      X\n               (RBWLIC+3,1,X),2X,                                      X\n               (RBSTAB,2,X),4X,        FLAGS                           X\n               (RBFLAGS1,,X),5X,       FLAGS                           X\n               (RBCDFLGS,,X)\n         B     PRB1270\n*\n*        SVRB\n*\nPRB1240  TM    RBSTAB1,RBFTSVRB        IS THIS AN SVRB?\n         BNO   PRB1250                 no, jump\n         STRING INTO=(LINE+30,L'LINE-30),2X,                           X\n               WKCELL1,3X,             SVC 055                         X\n               (RBWLIC+3,1,X),2X,                                      X\n               (RBSTAB,2,X),4X,        FLAGS                           X\n               (RBFLAGS1,,X),5X,       FLAGS                           X\n               (RBCDFLGS,,X)\n         B     PRB1270\n*\n*        IRB\n*\nPRB1250  TM    RBSTAB1,RBFTIRB         IS THIS AN IRB?\n         BNO   PRB1280                 no, ignore it\n         STRING INTO=(LINE+30,L'LINE-30),2X,                           X\n               '-IRB    ',3X,          IRB                             X\n               (RBWLIC+3,1,X),2X,                                      X\n               (RBSTAB,2,X),4X,        FLAGS                           X\n               (RBFLAGS1,,X),5X,       FLAGS                           X\n               (RBCDFLGS,,X)\n*\nPRB1270  CLC   RBOPSW,SDWAEC1          Abending RB?\n         BNE   PRB1271                 No, jump\n         MVI   LINE+29+1,C'*'          Yes, flag it\nPRB1271  BAL   R14,SPACE1              PRINT LINE\n         ICM   R1,B'1111',$RTM2WA      RTM2WA located?\n         BNP   PRB1279                 NO, JUMP\n         USING RTM2WA,R1\n         TM    RTM2ERRA,RTM2ABTM       ABTERM?\n         BO    PRB1275                 yes, jump\n         TM    RTM2ERRA,RTM2PCHK       PROGRAM CHECK?\n         BNO   PRB1279                 NO, JUMP\n         L     R0,RTM2AEC1             GET INTERRUPT CODE IN R0\n         DROP  R1                      RTM2WA\n         STRING '-PCK',(RBWLIC+3,FL1,R3Z),'-',INTO=WKCELL1\n         B     PRB1280                 NO, JUMP\nPRB1275  MVC   WKCELL1,=C'-ABTERM-'\n         B     PRB1280                 NO, JUMP\nPRB1279  STRING '-SVC',(RBWLIC+3,FL1,R3Z),'-',INTO=WKCELL1\nPRB1280  B     PRB1200                 LOOP THROUGH RB TABLE\n*--ENDLOOP\nPRB1288  STRING '  TASK TERMINATED',INTO=(LINE+30,L'LINE-30)\n         BAL   R14,SPACE1              PRINT LINE\n*\nPRB1290  BAL   R14,SCANTCB             GET NEXT TCB\n         BNZ   PRB1100                 PROCESS NEXT TCB\n*ENDLOOP\n         L     R9,PSATOLD-PSA(,0)      POINT TO ABENDING TCB\n*\n*        DISPLAY RB CHAIN FOR ABENDING TCB\n*\nPRB20    BAL   R14,BLANK1          <== BLANK LINE\n         MVI   MINLINES,5\n         STRING 'ABENDING TCB: ',(PSATOLD-PSA+1(0),3,X),INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n         SLR   R6,R6                   first time switch for NEXTRB\n*\n*        Process RB chain from the oldest RB\n*--LOOP\nPRB21    BAL   R14,NEXTRB              Point to next RB\n         LTR   R6,R6                   end of chain?\n         BZ    PRB99                   yes, exit loop\n         CL    R6,MY_PRB               END OF CHAIN?\n         BE    PRB99                   yes, exit loop\n         USING RBPREFIX,R6\n         LA    R0,RBBASIC              POINT TO BASIC SECTION\n         ST    R0,WKCELL1              KEEP ADDR FOR DISPLAY\n         MVI   MINLINES,3\n*\n         TM    RBSTAB1,RBFTSVRB        IS THIS AN SVRB?\n         BO    PRB29                   YES, JUMP\n*\n         TM    RBSTAB1,RBFTIRB         IS THIS AN IRB?\n         BO    PRB30                   YES, JUMP\n*\n*227     TM    RBCDFLGS,RBCDSYNC       CHECK FLAGS\n*227     BO    PRB28                   JUMP IF IT IS A SYNCH PRB\n*227     L     R5,RBCDE                GET ADDR OF CDE/LPDE\n         SLR   R5,R5\n         ICM   R5,B'0111',RBCDE1       Do we have a CDE?\n         BZ    PRB28                   No, jump (must be a SYNCH PRB)\n         STRING INTO=LINE121,                                          X\n               '0  PRB: ',(WKCELL1+1,3,X),                             X\n               '  STAB: ',(RBSTAB,,X),            STATUS BYTES         X\n               '  FLAGS1: ',(RBFLAGS1,,X),        FLAGS                X\n               '  CDFLGS: ',(RBCDFLGS,,X),        FLAGS                X\n               '  CDNAME: ',(CDNAME-CDENTRY(R5),8) PROGRAM NAME\n         BAL   R14,SPACE1          <== Print line\n         B     PRB31\n*\nPRB28    MVC   WKCELL2,RBGRS15         PICK UP ENTRY POINT ADDRESS\n         NI    WKCELL2+3,X'FE'         SET BIT 31 TO ZERO\n         STRING INTO=LINE121,                                          X\n               '0  PRB: ',(WKCELL1+1,3,X),                             X\n               '  STAB: ',(RBSTAB,,X),            STATUS BYTES         X\n               '  FLAGS1: ',(RBFLAGS1,,X),        FLAGS                X\n               '  CDFLGS: ',(RBCDFLGS,,X),        FLAGS                X\n               '  EPADDR: ',(WKCELL2,4,X)         ENTRY POINT\n         BAL   R14,SPACE1          <== Print line\n         CL    R6,MY_PRB               MY RBPREFIX ?\n         BNE   PRB31                   NO, JUMP\n         B     PRB39                   YES, QUIT\n*\nPRB29    STRING INTO=LINE121,                                          X\n               '0 SVRB: ',(WKCELL1+1,3,X),                             X\n               '  STAB: ',(RBSTAB,,X),            STATUS BYTES         X\n               '  FLAGS1: ',(RBFLAGS1,,X),        FLAGS                X\n               '  CDFLGS: ',(RBCDFLGS,,X)         FLAGS\n         BAL   R14,SPACE1          <== Print line\n         STRING 'SVC ROUTINE',INTO=MSG20\n         TM    RBFLAGS1,RBABEND        IS THIS THE ABEND SVRB?\n         BNO   PRB32                   NO, JUMP\n         STRING 'RTM',INTO=MSG20\n         B     PRB32                   JUMP OVER CSVQRY00 IF SVRB\n*\nPRB30    MVC   WKCELL2(4),RBCDE        IRB EP ADDRESS\n         NI    WKCELL2+3,X'FE'         SET BIT 31 TO ZERO\n         STRING INTO=LINE121,                                          X\n               '0  IRB: ',(WKCELL1+1,3,X),                             X\n               '  STAB: ',(RBSTAB,,X),            STATUS BYTES         X\n               '  FLAGS1: ',(RBFLAGS1,,X),        FLAGS                X\n               '  CDFLGS: ',(RBCDFLGS,,X),        FLAGS                X\n               '  EPADDR: ',(WKCELL2,4,X)         ENTRY POINT\n         BAL   R14,SPACE1          <== Print line\n*\nPRB31   #SETMASK RBOPSW+4              SET MASK FOR ADDR CLEAN-UP\n         L     R1,RBOPSW+4             PICK UP ADDR OF NEXT INSTR.\n         BAL   R14,CSVQRY00        <== FIND CORRESPONDING CDE\n*\nPRB32    TM    RBFLAGS1,RBXWAIT        THIS RB IN WAIT?\n         BNO   PRB33                   NO, JUMP\n         STRING 2X,(MSG20,,T),' *ISSUED WAIT',INTO=MSG60\n         B     PRB38\n*\nPRB33    ICM   R1,B'1111',$RTM2WA      RTM2WA located?\n         BNP   PRB37                   NO, JUMP\n         USING RTM2WA,R1\n         TM    RTM2ERRA,RTM2ABTM       ABTERM?\n         BO    PRB36                   yes, jump\n         TM    RTM2ERRA,RTM2PCHK       PROGRAM CHECK?\n         BNO   PRB37                   NO, JUMP\n         STRING 2X,(MSG20,,T),' *PROGRAM CHECK*',INTO=MSG60\n         L     R0,RTM2AEC1             GET INTERRUPT CODE IN R0\n         DROP  R1                      RTM2WA\n         L     R1,=A(PCKTABLE)         START OF PCK TABLE\n         BAL   R14,SCANTBL             FIND PCK NAME\n         BNE   PRB38                   NOT FOUND, JUMP\n         STRING (MSG60,,T),' (',(2(R1),(R2)),')',INTO=MSG60\n         B     PRB38\n*\nPRB36    STRING 2X,(MSG20,,T),' *SYSTEM ISSUED SVC 13 (ABEND)',       --\n               INTO=MSG60\n         B     PRB38\n*\nPRB37    STRING 2X,(MSG20,,T),' ISSUED SVC ',(RBWLIC+3,FL1,L0),       --\n               INTO=MSG60\n         L     R0,RBWLIC               GET INTERRUPT CODE IN R0\n         L     R1,=A(SVCTABLE)         START OF SVC TABLE\n         BAL   R14,SCANTBL             FIND SVC NAME\n         BNE   PRB38                   NOT FOUND, JUMP\n         STRING (MSG60,,T),' (',(2(R1),(R2)),')',INTO=MSG60\n*\nPRB38    STRING 5X,INTO=LINE,                                          X\n               'W-L-IC ',(RBWLIC,1,X),            WAIT COUNT           X\n               '-',(RBWLIC+1,1,X),                INSTRUCTION LENGTH   X\n               '-',(RBWLIC+2,2,X),                INTERRUPT CODE       X\n               '  PSW ',(RBOPSW,4,X),1X,(RBOPSW+4,4,X),                X\n               MSG60                   DIAGNOSTIC\n         BAL   R14,SPACE1          <== Print line\n*\n*        Display R14-R1 from previous RB\n*\n         ST    R6,WKCELL1              save RB addr\n         BAL   R14,NEXTRB              next RB\n         STRING 5X,INTO=LINE,                                          X\n               ' R14=',(RBGRS14,,X),                                   X\n               '  R15=',(RBGRS15,,X),                                  X\n               '  R0=',(RBGRS0,,X),                                    X\n               '  R1=',(RBGRS1,,X)\n         BAL   R14,SPACE1          <== Print line\n         L     R6,WKCELL1              restore RB addr\n*\nPRB39    B     PRB21                   PROCESS NEXT RB\n*ENDLOOP\nPRB99    END_PROC\n*----------------------------------------------------------------------\n*        TCB TREE SCAN ROUTINE\n*----------------------------------------------------------------------\nSCANTCB  BEGIN_PROC SAVE=NO\n         LR    R1,R9                   SAVE TCB ADDRESS\n         L     R9,TCBLTC-TCB(,R9)      DAUGHTER\n         LA    R3,1(,R3)               INDENTATION INDEX\n*LOOP\nSCANTCB2 LTR   R9,R9                   CHECK FOR END OF CHAIN\n         BNZR  R14                     PASS VALID TCB ADDRESS\n         L     R9,TCBNTC-TCB(,R1)      SISTER\n         L     R1,TCBOTC-TCB(,R1)      MOTHER\n         BCT   R3,SCANTCB2             INDENTATION INDEX\n*ENDLOOP\n         SR    R9,R9                   SET CC=0\n         BR    R14                     GOBACK\n*\n*----------------------------------------------------------------------\n*        SCAN RB chain backwards (from oldest RB)\n*              Input:  R9 points to the TCB\n*                      R6 points to current RBPREFIX\n*              Output: R6 point to next RB\n*----------------------------------------------------------------------\n*\n         USING RBPREFIX,R6\nNEXTRB   BEGIN_PROC SAVE=NO\n         LA    R0,RBBASIC              point to basic section\n         SLR   R6,R6                   end of chain\n         CL    R0,TCBRBP               end of chain?\n         BER   R14                     yes, goback with R6=0\n         ICM   R6,B'1111',TCBRBP       Point to top RB (most recent)\n         BZR   R14                     no RB for this TCB, goback\n*--LOOP\nNEXTRB2  SH    R6,=Y(RBBASIC-RBPREFIX) POINT TO RBPREFIX\n         CLM   R0,B'0111',RBLINK+1     is this the next RB?\n         BE    NEXTRB4                 yes, exit loop\n         TM    RBSTAB2,RBTCBNXT        oldest RB (end of chain) ?\n         BO    NEXTRB4                 yes, exit loop\n         LA    R1,RBBASIC              previous RB in chain\n         ICM   R6,B'0111',RBLINK+1     POINT TO PREVIOUS RB (OR TCB)\n         BNZ   NEXTRB2                 next RB in chain\n*--ENDLOOP\n         BR    R14                     goback with R6=0\n*\n*        Retrieve addr of RTM2WA associated with previous SVRB\n*\nNEXTRB4  ST    R1,$RTM2WA              previous RB\n         ICM   R1,B'1111',TCBRTWA      RTM2WA\n         BZ    NEXTRB4N                lost, exit\n         USING RTM2WA,R1\n*loop\nNEXTRB4L CLC   RTM2VRBC,$RTM2WA        SVRB addr?\n         BE    NEXTRB4X                yes, exit\n         ICM   R1,B'1111',RTM2PREV     end of RTM2WA chain?\n         BNZ   NEXTRB4L                no, process next one\n*ensloop\nNEXTRB4N BCTR  R1,0                    R1=FFFFFFFF\n*\nNEXTRB4X ST    R1,$RTM2WA              RTM2WA address or FFFFFFFF\n         BR    R14                     goback\n         DROP  R6,R1                   RBPREFIX,RTM2WA\n*\n*----------------------------------------------------------------------\n*        SCAN SVC/PCK TABLES\n*----------------------------------------------------------------------\n*\nSCANTBL  BEGIN_PROC SAVE=NO\n         SLR   R2,R2\n*LOOP\nSCANTBL2 IC    R2,1(,R1)               PICK UP ENTRY LENGTH\n         CLM   R0,B'0001',0(R1)        COMPARE SVC NUMBER WITH INTCODE\n         BER   R14                     EQUAL, QUIT LOOP\n         LA    R1,2(R2,R1)             BUMP TO NEXT ENTRY IN SVC TABLE\n         CLI   0(R1),FF                END OF TABLE?\n         BNE   SCANTBL2                NO, TRY NEXT ENTRY\n*ENDLOOP\n         LTR   R14,R14                 SET CC\u00ac\n         BR    R14\n*\n*---------------------------------------------------------------------*\n*                                                                     *\n*   NAME     ENTPT    ATTRB SP ATTR  ATTR2  USE    MAJ-CDE   LENGTH   *\n*                                                                     *\n*   SHOWJPAQ 840BAA30   30  FC  31    22    0001             0007E0   *\n*   JPAQ     840BAA30   30      35    02           SHOWJPAQ           *\n*                                                                     *\n*---------------------------------------------------------------------*\n*\nPGM00    BEGIN_PROC\n         BAL   R14,SPACE1          <== Print line\n         STRING 'JOB PACK AREA FOR ABENDING STEP',INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n         MVI   MINLINES,6\n         STRING    '   Name     EntPt   Attrb Sp Attr Attr2 Attr3 Use  X\n               Maj-CDE  Length Load-pnt Data-Set Name',INTO=LINE\n         BAL   R14,SPACE1           <- Print line\n         SLR   R5,R5                   first-time switch\n*LOOP\nJPAQ11   BAL   R14,NEXTCDE          <- get next CDE\n         LTR   R5,R5                   end of JPAQ?\n         BZ    JPAQ91                  yes, exit\n         USING CDENTRY,R5\n*\n         CSVQUERY SEARCH=JPALPA,       SEARCH JPAQ                     +\n               INADDR=CDENTPT,         ADDRESS                         +\n               OUTEPNM=EPNAME,         RETURN EP NAME                  +\n               OUTPID=PID,             PROVIDER ID                     +\n               OUTPDATA=PDATA,         PROVIDER DATA                   +\n               OUTEPTKN=MODTOKEN,      RETURN TOKEN                    +\n               MF=(E,CSVQRYWK)         WORK AREA\n         LTR   R2,R15                  pass return code\n         BZ    JPAQ17                  OK, continue\n         STRING 'CSVQUERY Failed, R15=',((R2),,L),INTO=CSVDWORK\n         LA    R1,CSVDWORK             message\n         B     JPAQ82\n*\nJPAQ17   CLC   =C'PGMF',PID            LOADED FROM JOBLIB/STEPLIB?\n         BNE   JPAQ31                  no, jump\n         OC    PDATA,PDATA             Any provider data returned?\n         BZ    JPAQ41                  no, quit\n         LA    R2,X'000000FF'          mask for NR\n         N     R2,PDATA_TTRN           load TTRN from Provider Data\n         CLI   PDATA+1,X'01'           LOADED FROM -LNKLST- ?\n         BE    JPAQ34                  yes, jump\n         CLI   PDATA+1,X'02'           LOADED FROM TASKLIB ?\n         BE    JPAQ50                  yes, jump\n*\n*        Loaded from JOBLIB/STEPLIB/TASKLIB\n*\nJPAQ21   TM    PDATA,X'80'             loaded from a PDSE?\n         BZ    JPAQ21L                 no, jump\n         L     R3,PDATA_DDN+4          yes, get LFMD address\n         MVC   PDATA_DDN,044(R3)       move true ddname\nJPAQ21L  L     R3,TCBTIO               TIOT\n         USING TIOT1,R3\n         LA    R3,TIOENTRY             First TIOT Entry\n         USING TIOENTRY,R3\n         SLR   R0,R0                   PREPARE IC\n*LOOP\nJPAQ22   CLC   PDATA_DDN,TIOEDDNM      is this my ddname ?\n         BE    JPAQ60                  yes, exit loop\n         IC    R0,TIOELNGH             LOAD LENGTH OF CURRENT ENTRY\n         ALR   R3,R0                   BUMP UP TO NEXT ENTRY\n         CLI   TIOELNGH,0              IS THIS THE END?\n         BNZ   JPAQ22                  NOT YET, LOOP THROUGH TIOT\n*ENDLOOP\n*        DDname has been freed (not found in TIOT)\n*\n         STRING (PDATA_DDN,,T),'+',((R2),,L),INTO=CSVDWORK\n         LA    R1,CSVDWORK             message\n         B     JPAQ80                  exit\n*\n*        Get module's TTRN in linklist (PID=LLAF)\n*\nJPAQ31   CLC   =C'LLAF',PID            LOADED FROM LINK-LIST?\n         BNE   JPAQ41                  NO, EXIT\n         MVC   CSVDWORK,=AL2(1,L'CSVDWORK)\n         MVC   PDS2NAME,EPNAME         EPNAME\n         L     R1,CVTPTR               CVT address\n         L     R1,CVTLINK-CVTMAP(,R1)  link-list DCB\n         BLDL  (1),CSVDWORK            ISSUE BLDL (to LLA)\n         LTR   R15,R15\n         BNZ   JPAQ45                  NOT FOUND, QUIT\n         IC    R2,PDS2CNCT             pick-up concat#\n         MVC   PDATA_DDN,DDNAME        move ddname\n*\n*        Find link-list dsname from LLT\n*\nJPAQ34   MH    R2,=Y(LLTNEXT-LLTENTRY) make it an offset into the LLT\n         L     R14,X'0224'(,0)         PSAAOLD   A(ASCB)\n         L     R14,ASCBASSB-ASCB(,R14) ASSB\n         L     R14,ASSBDLCB-ASSB(,R14) CSVDLCB\n         L     R3,DLCBLLT@-DLCB(,R14)  LLT\n         LA    R1,LLTDSN-LLT(R2,R3)    change offset to address\n         B     JPAQ80                  exit\n*\n*        PDATA=zero or PID not equal to PGMF or LLAF\n*\nJPAQ41   STRING 'PID(',(PID,,T),')',INTO=WORK44\n         LA    R1,WORK44               message\n         LA    R15,4                   RC=4\n         B     JPAQ82\n*\n*        BLDL_RC>0\n*\nJPAQ45   STRING 1X,INTO=WORK44         dsname not found\n         B     JPAQ82\n*\n*        PDATA=X'08020000,007D2D00,008D1768,00000000'\n*        PDATA may be related to DESERV/IGWSMDE ???\n*        It seems that PDATA+0=X'08' ???\n*                      PDATA+1=PDS2LIBF (the \"Z byte\").\n*                      PDATA+4=TTRN\n*                      PDATA+8=A(TCB)\n*\nJPAQ50   LA    R1,TCB                  R1=A(TCB) - my own TCB\n         TM    PDATA+0,X'08'           X'08' ??\n         BNO   JPAQ51                  no, jump\n         L     R14,PDATA+8             R14=A(TCB)\n         CLC   TCBTIO,TCBTIO-TCB(R14)  is this a TCB ?\n         BNE   JPAQ51                  no, jump\n         LR    R1,R14                  R1=A(TCB)\nJPAQ51   L     R1,TCBJLB-TCB(,R1)      R1=A(DCB) STEPLIB/JOBLIB/TASKLIB\n         LH    R3,040(,R1)             DCBTIOT\n         AL    R3,TCBTIO               ADD A(TIOT)\n         MVC   PDATA_DDN,TIOEDDNM      copy JOBLIB/STEPLIB ddname\n*\n*        DDname found - Retrieve dsname from JFCB\n*\nJPAQ60   LTR   R2,R2                   first data set in concat?\n         BZ    JPAQ66                  yes, exit\n         SLR   R0,R0\n*loop\nJPAQ61   IC    R0,TIOELNGH             LOAD LENGTH OF CURRENT ENTRY\n         ALR   R3,R0                   BUMP UP TO NEXT ENTRY\n         BCT   R2,JPAQ61               next concat#\n*endloop\nJPAQ66   LA    R2,CSVDWORK+4           WORK AREA\n         ST    R2,CSVDWORK             WORK AREA\n         USING ZB505,R2\n         XC    SWAEPAX,SWAEPAX         CLEAR WORK AREA\n         MVC   SWVA,TIOEJFCB           SVA OF THE JFCB\n         SWAREQ FCODE=RL,EPA=CSVDWORK,MF=(E,SWAREQL1),UNAUTH=YES\n         L     R1,SWBLKPTR             31-BIT ADDRESS OF JFCB\n*\nJPAQ80   SLR   R15,R15                 RC=0\n*\nJPAQ82   L     R6,CDXLMJP              POINT TO XL (OR MAJOR CDE)\n         TM    CDATTR,CDMIN            CHECK ATTRIBUTES\n         BO    JPAQ85                  JUMP IF THIS IS A MINOR CDE\n         USING XTLST,R6\n         STRING 3X,CDNAME,1X,(CDENTPT,,X),2X,(CDATTRB,,X),2X,(CDSP,,X),X\n               2X,(CDATTR,,X),4X,(CDATTR2,,X),4X,(CDATTR3,,X),2X,      X\n               (CDUSE,,X),10X,(XTLMSBLN,,X),1X,(XTLMSBAD,,X),          X\n               1X,((R1),44,T),         DSname from CDEX                X\n               INTO=LINE\n         BAL   R14,SPACE1           <- Print line\n         B     JPAQ11\nJPAQ85   STRING 3X,CDNAME,1X,(CDENTPT,,X),2X,(CDATTRB,,X),6X,          X\n               (CDATTR,,X),4X,(CDATTR2,,X),4X,(CDATTR3,,X),            X\n               7X,(CDNAME-CDENTRY(R6),8),                              X\n               17X,((R1),44,T),        DSname from CDEX                X\n               INTO=LINE\n         BAL   R14,SPACE1           <- Print line\n         B     JPAQ11                  next JPAQ entry\n*ENDLOOP\n*\n* ATTRB: 80-EOM 40-IDENTY 20-DIRTY 10-CDEX 08-LPDE 04-GLOBAL 02-CONTA..\n*  ATTR: 80-NIP/MLPA 40-NIC 20-RENT 10-REUS 08-NREUS 04-MINOR 02-JPAQ\n* ATTR2: 80-SP0 40-REL 20-XLE 10-RLC 08-AMODE_ANY 04-OVLY 02-APFLIB ...\n*\nJPAQ91   BAL   R14,BLANK1           <- Print blank line\n         STRING '   ATTRB: 80-EOM 40-IDENTY 20-DIRTY 10-CDEX ',        X\n               '08-LPDE 04-GLOBAL 02-CONTAMINATION 01-RACF',           X\n               INTO=LINE\n         BAL   R14,SPACE1           <- NEXT LINE\n         STRING '    ATTR: 80-NIP/MLPA 40-NIC 20-RENT 10-REUS ',       X\n               '08-NREUS 04-MINOR 02-JPAQ 01-NOT_OL',                  X\n               INTO=LINE\n         BAL   R14,SPACE1           <- NEXT LINE\n         STRING '   ATTR2: 80-SP0 40-REL 20-XLE 10-RLC ',              X\n               '08-AMODE_ANY 04-OVLY 02-APFLIB 01-AC=1',               X\n               INTO=LINE\n         BAL   R14,SPACE1           <- NEXT LINE\n         STRING '   Attr3: 80-OpMvsPath 40-PML',                       X\n               INTO=LINE\n         BAL   R14,SPACE1           <- NEXT LINE\n         BAL   R14,BLANK1           <- Print blank line\n*----------------------------------------------------------------------\n*        PRINT LOAD-LIST\n*----------------------------------------------------------------------\n         MVI   MINLINES,6\n         STRING 'LOAD LIST FOR ABENDING TCB',INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n         STRING '0   NAME     ENTPT   ATTRB SP ATTR ATTR2  ',          X\n               '  COUNT  SYSCT     LENGTH LOAD-PNT',INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\n         SLR   R7,R7                   first-time switch\n*\n*        PRINT LLE CHAIN\n*LOOP\nPGM51    BAL   R14,NEXTLLE          <- get next LLE\n         LTR   R7,R7                   end of load-list ?\n         BZ    PGM80                   yes, exit\n         USING LLE,R7\n         L     R5,LLECDPT              CDE PTR\n         TM    CDATTR,CDMIN            CHECK ATTRIBUTES\n         BNO   PGM52                   JUMP IF THIS IS A MAJOR CDE\n         L     R5,CDXLMJP              POINT TO MAJOR CDE\nPGM52    L     R6,CDXLMJP              POINT TO XL\n         TM    CDATTRB,CDELPDE         CHECK ATTRIBUTES\n         BO    PGM55                   JUMP IF THIS IS A LPA MODULE\n         STRING 3X,CDNAME,1X,(CDENTPT,,X),2X,(CDATTRB,,X),2X,          X\n               (CDSP,,X),2X,(CDATTR,,X),4X,(CDATTR2,,X),5X,            X\n               (LLECOUNT,,X),3X,(LLESYSCT,,X),6X,                      X\n               (XTLMSBLN,,X),1X,(XTLMSBAD,,X),INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n         B     PGM51                   LOOP THROUGH LOAD LIST\n         USING LPDE,R5\nPGM55    STRING 3X,LPDENAME,1X,(LPDENTP,,X),2X,(LPDEATTB,,X),2X,       X\n               (LPDESP,,X),2X,(LPDEATTR,,X),4X,(LPDEATT2,,X),5X,       X\n               (LLECOUNT,,X),3X,(LLESYSCT,,X),6X,                      X\n               (LPDEXTLN+1,3,X),1X,(LPDEXTAD,,X),INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n         B     PGM51                   LOOP THROUGH LOAD LIST\n*ENDLOOP\nPGM80    END_PROC\n*\n*----------------------------------------------------------------------\n*        Scan JPAQ backwards (from oldest CDE)\n*              Input:  R5 points to current CDENTRY\n*              Output: R5 point to next CDE\n*----------------------------------------------------------------------\n*\nNEXTCDE  BEGIN_PROC SAVE=NO\n         USING *,R15\n         LR    R0,R5                   point to current CDE\n         L     R5,PSATOLD-PSA(,0)      my TCB\n         L     R5,TCBJSTCB-TCB(,R5)    job-step TCB\n         L     R5,TCBJPQ-TCB(,R5)      Top CDE (most recent)\n         LTR   R5,R5                   empty JPAQ?\n         BZR   R14                     yes, goback with R5=0\n         USING CDENTRY,R5\n*--LOOP\nNEXTCDE2 CL    R0,CDCHAIN              is this the next RB?\n         BER   R14                     yes, goback\n         ICM   R5,B'1111',CDCHAIN      previous CDE\n         BNZ   NEXTCDE2                not found yet, loop more\n*--ENDLOOP\n         BR    R14                     goback with R5=0\n*\n*----------------------------------------------------------------------\n*        Scan LOAD-LIST backwards (from oldest LLE)\n*              Input:  R7 points to current LLE\n*              Output: R7 point to next LLE\n*----------------------------------------------------------------------\n*\nNEXTLLE  BEGIN_PROC SAVE=NO\n         USING *,R15\n         LR    R0,R7                   point to current LLE\n         L     R7,PSATOLD-PSA(,0)      my TCB\n         L     R7,TCBLLS-TCB(,R7)      Top LLE (most recent)\n         LTR   R7,R7                   empty load list?\n         BZR   R14                     yes, goback with R7=0\n         USING LLE,R7\n*--LOOP\nNEXTLLE2 CL    R0,LLECHN               is this the next RB?\n         BER   R14                     yes, goback\n         ICM   R7,B'1111',LLECHN       previous LLE\n         BNZ   NEXTLLE2                not found yet, loop more\n*--ENDLOOP\n         BR    R14                     goback with R7=0\n         DROP  R5,R6,R7                CDE, XL, LLE\n*\n*----------------------------------------------------------------------\n*        PRINT COM-REG\n*----------------------------------------------------------------------\n*\nCOMREG00 BEGIN_PROC\n         L     R5,PSATOLD-PSA(,0)      my TCB\n         L     R5,TCBJSTCB-TCB(,R5)    job-step TCB\n         L     R5,TCBJPQ-TCB(,R5)      Top CDE (most recent)\n         LTR   R5,R5                   empty JPAQ?\n         BZ    COMREG99                yes, exit\n         USING CDENTRY,R5\n*LOOP\nCOMREG12 CLC   =C'COM_REG ',CDNAME     is this the next RB?\n         BE    COMREG21                yes, exit loop\n         ICM   R5,B'1111',CDCHAIN      previous CDE\n         BNZ   COMREG12                not found yet, loop more\n*ENDLOOP\n         B     COMREG99                not found, exit\nCOMREG21 L     R6,CDXLMJP              POINT TO XL\n         USING XTLST,R6\n         MVI   MINLINES,6\n         BAL   R14,BLANK1          <== BLANK LINE\n         STRING 'COM_REG',INTO=LINE\n         BAL   R14,SPACE1          <== print header\n         SLR   R0,R0\n         ICM   R0,B'0111',XTLMSBLN     LENGTH\n         L     R1,XTLMSBAD             ADDRESS\n         BAL   R14,PDUMP           <== PRINT COM-REG\nCOMREG99 END_PROC\n         DROP  R5,R6\n*\n*----------------------------------------------------------------------\n*        PRINT PROGRAM LINKAGE INFORMATION (SAVE AREA TRACE)\n*----------------------------------------------------------------------\n*\nLINK00   BEGIN_PROC\n         BAL   R14,BLANK1          <== BLANK LINE\n         MVI   MINLINES,10\n         STRING '0SAVE AREA FORWARD TRACE (STARTING FROM TCBFSA)',     X\n               INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\n         L     R6,TCBFSA               FIRST SAVE AREA\n         LA    R7,STACK128             LOOP PREVENTION\n         XC    0(256,R7),0(R7)         CLEAN UP\n         MVI   MASKADDR,X'7F'          31-BIT MODE\n*LOOP\nLINK10   CLM   R6,B'1000',=X'FF'       LO-SA FLAGGED?\n         BNE   LINK11                  NO, JUMP\n         ICM   R6,B'1000',X00          YES, ZERO IT\nLINK11   LA    R6,0(,R6)               CLEAR HI-ORDER BIT\n         CL    R6,REGION24             DOES THIS LOOK RIGHT?\n         BL    LINK90                  NO, QUIT\n        #S0C4  LINK90\n         CLC   0(72,R6),0              VALIDATE 72 BYTES\n        #S0C4  RESET\n         BAL   R14,LINK200         <== edit save area data\n         CL    R6,CURR_R13             is this the current save?\n         BNE   *+8                     no, jump\n         MVI   CURR_R13,FF             yes, remember we saw it\n         LA    R0,128                  MAX NUMBER OF SAVE AREAS\n         LA    R1,STACK128             START OF STACK\n*--LOOP\nLINK18   CLC   0(4,R1),8(R6)           ALREADY PROCESSED OR ZERO?\n         BE    LINK90                  YES, QUIT\n         LA    R1,4(,R1)               BUMP INDEX\n         BCT   R0,LINK18               NEXT STACK ENTRY\n*--ENDLOOP\n         ST    R6,0(,R7)               REMEMBER THIS SAVE AREA\nLINK19   LR    R0,R6                   current save area\n         L     R6,8(,R6)               NEXT SAVE AREA\n         CLR   R6,R0                   points to itself?\n         BE    LINK90                  yes, exit\n         LA    R7,4(,R7)               NEXT STACK ENTRY\n         B     LINK10                  DUMP IT TOO\n*ENDLOOP\n*        process save area at time of abend, if not processed already\n*\nLINK90   CLI   CURR_R13,FF             current save area processed?\n         BE    LINK99                  yes, exit\n         L     R6,CURR_R13             point to current save area\n         CL    R6,REGION24             DOES THIS LOOK RIGHT?\n         BL    LINK99                  NO, QUIT\n        #S0C4  LINK99\n         CLC   0(72,R6),0              VALIDATE 72 BYTES\n        #S0C4  RESET\n         STRING '0CURRENT SAVE AREA (R13 FROM LAST PRB)',              X\n               INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\n         BAL   R14,LINK200         <== edit save area data\nLINK99   END_PROC\n*\n*----------------------------------------------------------------------\n*        Edit save-area fields\n*----------------------------------------------------------------------\n*\nLINK200  BEGIN_PROC\n         MVI   MINLINES,8\n         MVC   WKCELL1,BLANKS          clear work area\n         L     R1,FRSTSVRB             ABEND SVRB\n         CLM   R6,B'0111',RBGRS13+1-RBPREFIX(R1)  R13 at time of abend?\n         BNE   LINK203                 no, jump\n         MVC   WKCELL1+3(3),=C'<=='    Current save area\nLINK203  STRING INTO=LINE121,                                          X\n               '0 SAVE AREA: ',((R6),,X),                              X\n               '  WORD1: ',(0(R6),4,X),                                X\n               '  PREVIOUS: ',(4(R6),4,X),                             X\n               '  NEXT: ',(8(R6),4,X),WKCELL1\n         BAL   R14,SPACE1          <== Print line\n*\n*        DECODE ENTRY ADDRESS\n*\n         MVC   VIACALL,=C'CALL '       CALL/LINK/SYNCH\n         MVC   REGS(52),20(R6)         MOVE R0-R12\n         MVC   REGS+56(8),12(R6)       MOVE R14-R15\n         L     R14,CVTPTR(,0)      <== GET CVT ADDRESS\n         LA    R0,CVTEXIT-CVTMAP(,R14) GET ADDR OF CVTEXIT FIELD\n         CLM   R0,B'0111',13(R6)       IS THIS THE RETURN ADDRESS?\n         BNE   LINK222                 NO, JUMP\n         TM    12(R6),X'7F'            IS THIS A 24-BIT ADDR?\n         BNZ   LINK222                 NO, JUMP\n         MVC   VIACALL,=C'LINK '       YES, CHANGE 'CALL' TO 'LINK'\n         B     LINK228\n*\n*        CHECK IF REGISTERS SAVED WITH \"STM R14,R10,20(R13)\"\n*\nLINK222 #S0C4  LINK228\n**       L     R2,LASTPRB              POINT TO LAST PRB\n**       CLI   RBOPSW+4-RBPREFIX(R2),0 AMODE24?\n**       BNE   LINK228                 NO, JUMP\n         L     R2,FRSTSVRB             POINT TO FIRST SVRB\n**       CL    R6,RBGRS13-RBPREFIX(,R2) SAVE AREA AT TIME OF ABEND?\n**       BNE   LINK228                 NO, JUMP\n**       CLI   20(R6),X'00'            BAL/BALR?\n**       BE    LINK228                 NO, JUMP\n         LM    R14,R1,20(R6)           R14-R1 FROM R0-R3 SLOTS\n         CLI   32(R6),FF               R1 IN COMPLEMENT FORM?\n         BNE   LINK223                 NO, JUMP\n         LPR   R1,R1                   YES, MAKE IT POSITIVE\n*\nLINK223  ICM   R1,B'1000',X00          CLEAN UP HI-ORDER BYTE\n**       CL    R1,RBGRS1-RBPREFIX(,R2) IS THIS MY DCB ADDRESS?\n**       BNE   LINK224                 NO, JUMP\n         CLM   R15,B'0111',DCBPUT+1-IHADCB(R1)   R15 in R1 slot?\n         BE    LINK225                 yes, JUMP\n*read/write/check macro\n         USING DECB,R1\nLINK224  TM    DECBDCBA,X'7F'          valid DCB addr?\n         BNZ   LINK228                 NO, JUMP\n         TM    DECBDCBA+3,X'03'        valid DCB addr?\n         BNZ   LINK228                 NO, JUMP\n         L     R1,DECBDCBA             DCB address from DECB\n         DROP  R1                      was DECB\n         CL    R1,REGION24             DOES THIS LOOK RIGHT?\n         BL    LINK228                 NO, QUIT\n         CL    R1,REGION24+4           DOES THIS LOOK RIGHT?\n         BH    LINK228                 NO, QUIT\n         CLM   R15,B'0111',DCBREAD+1-IHADCB(R1)  R15 in R1 slot?\n         BE    LINK225                 yes, jump\n         CL    R15,DCBCHECK-IHADCB(,R1) DCBCHECK IN R1 SLOT?\n         BNE   LINK228                 NO, JUMP\n*\n*        validate DCB/DEB pointers\n*\nLINK225  ICM   R14,B'0111',DCBDEBAD+1-IHADCB(R1)   DEB address\n         BZ    LINK228                 BAD, QUIT\n         CLM   R1,B'0111',DEBDCBAD+1-DEBBASIC(R14) COMP W/ DCB ADDR\n         BNE   LINK228                 BAD, QUIT\n*\n*        make sure R15 points to IGG019xx\n*\n         LR    R1,R15                  PASS EP ADDR\n         ICM   R1,B'1000',X00          CLEAN UP\n         BAL   R14,CSVQRY00        <== FIND LOAD MODULE\n         LTR   R5,R5                   CDE FOUND?\n         BZ    LINK228                 NO, JUMP\n         CLC   =C'IGG019',CDNAME-CDENTRY(R5)\n         BNE   LINK228                 NO, JUMP\n         MVC   REGS(44),28(R6)                   MOVE R0-R10\n         MVC   REGS+44(8),RBGRS11-RBPREFIX(R2)        R11-R12\n         MVC   REGS+56(8),20(R6)                      R14-R15\n         MVI   MASKADDR,X'00'          24-BIT MODE              @921003\n         B     LINK231                                          @921003\n*\nLINK228 #S0C4  LINK237\n         ICM   R1,B'1111',REGS+60      R15 (ENTRY ADDRESS)\n         BZ    LINK241                 NO EP ADDR, JUMP\n         CLM   R1,B'1111',BLANKS       R15 (ENTRY ADDRESS)\n         BE    LINK241                 NO EP ADDR, JUMP\n         TM    REGS+56,X'80'           AMODE31 IN R14?\n         BZ    LINK228C                NO, JUMP\n         TM    REGS+56,X'40'           BAL R14,8(,R15) ?\n         BO    LINK228C                YES, JUMP\n         BAL   R14,CSVQRY00        <== FIND LOAD MODULE\n         LTR   R5,R5                   CDE FOUND?\n         BP    LINK231                 YES, JUMP\nLINK228C MVI   MASKADDR,X'00'          24-BIT MODE\n         L     R1,REGS+60              R15 (ENTRY ADDRESS)\n         BAL   R14,CSVQRY00        <== FIND LOAD MODULE\n         LTR   R5,R5                   CDE FOUND?\n         BNP   LINK237                 NO, JUMP\n*\n*        EDIT EYE CATCHER AT ENTRY POINT\n*\nLINK231  MVC   EYECATCH,BLANKS\n         TM    REGS+63,1               R15 HAS ODD VALUE?\n         BO    LINK234                 YES, DO NOT IDENTIFY ENTRY ADDR\n         L     R1,REGS+60              R15 (ENTRY ADDRESS)\n         N     R1,MASKADDR             CLEAN-UP ADDRESS\n        #S0C4  LINK234\n         CLC   0(24,R1),0              VALIDATE 24 BYTES\n        #S0C4  RESET\n*sub-routine: B 4(15)\nLINK232B LA    R0,64                   default length for eye-catcher\n         LA    R2,4(,R1)               first byte of eye-catcher\n         CLC   =X'47FF00',0(R1)        IS THIS A BRANCH?\n         BE    LINK233                 yes, JUMP\n*OS/VS COBOL INIT1\nLINK232C LA    R0,8+4                  modulenmVSR1\n         LA    R2,12(,R1)              first byte of eye-catcher\n         CLC   =C'VSR1',8(R2)          OS/VS INIT1 signature?\n         BE    LINK233                 yes, JUMP\n*SAVE MACRO\nLINK232S IC    R0,4(,R1)               LENGTH OF EYE CATCHER\n         LA    R2,5(,R1)               first byte of eye-catcher\n         CLC   =X'47F0',0(R1)          IS THIS A BRANCH?\n         BNE   LINK232P                NO, JUMP\n         TM    2(R1),X'F0'             IS THIS A BRANCH?\n         BO    LINK233                 yes, JUMP\n*PROGID macro\nLINK232P LA    R0,X'001A'              eye catcher length\n         LR    R2,R1                   entry address (R15)\n         SLR   R2,R0                   point to CSECT origin\n         CLC   0(4,R1),=X'90EC,D00C'   PROGID prolog?\n         BNE   LINK234                 NO, JUMP\n         CLC   8(10,R1),=X'50E0D008,50D0E004,18DE'\n         BNE   LINK234                 NO, JUMP\n         CLC   20(4,R1),=X'41F0001A'   PROGID prolog?\n         BNE   LINK234                 NO, JUMP\n*\nLINK233  STRING ', EYE CATCHER IS \"',((R2),(R0)),'\"',INTO=EYECATCH\n         TR    EYECATCH,TRTPRINT       KEEP ONLY PRINTABLE CHARACTERS\n*\n*INK234  STRING 2X,EPNAME,' WAS ENTERED VIA ',VIACALL,                 X\n               ' AT OFFSET ',OFFSET,EYECATCH,INTO=LINE\nLINK234  STRING 1X,(EPNAME,,T),(OFFSET,,T),                            X\n               ' WAS ENTERED VIA ',(VIACALL,,T),EYECATCH,INTO=LINE\n         BAL   R14,SPACE1L         <== print with lower-case\n         B     LINK241\n*\nLINK237  STRING ' *UNKNOWN WAS ENTERED VIA ',VIACALL,                  X\n               ' AT LOCATION ',(REGS+60,4,X),INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n*\n*        DECODE RETURN ADDRESS\n*\nLINK241  MVC   EYECATCH,BLANKS         CLEAR WORK AREA\n         CLI   VIACALL,C'C'            WAS IT A CALL?\n         BNE   LINK261                 NO, JUMP\n         MVI   MASKADDR,X'7F'          31-BIT MODE\n         L     R1,REGS+56              RETURN ADDRESS\n         SRL   R1,1                    CLEAN UP \"T\" BIT\n         SLL   R1,1                    CLEAN UP \"T\" BIT\n         BAL   R14,CSVQRY00        <== FIND LOAD MODULE\n         LTR   R5,R5                   CDE FOUND?\n         BP    LINK248                 YES, JUMP\n         SLR   R1,R1\n         ICM   R1,B'0111',REGS+56+1    TRY 24-BIT ADDRESS\n         BAL   R14,CSVQRY00        <== FIND LOAD MODULE\n         LTR   R5,R5                   CDE FOUND?\n         BZ    LINK261                 NO, JUMP\nLINK248  STRING 4X,'RETURN ADDRESS',' IS ',MSG20,INTO=EYECATCH\n         TM    REGS+56+3,1             R14 flagged by RETURN macro?\n         BZ    LINK261                 NO, JUMP\n         STRING 4X,'RETURN ADDRESS',' WAS ',MSG20,INTO=EYECATCH\n*\nLINK261  STRING '0   GPR00-03: ',(REGS,4,X),2X,(REGS+4,4,X),2X,        X\n               (REGS+8,4,X),2X,(REGS+12,4,X),INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\n         STRING '   GPR04-07: ',(REGS+16,4,X),2X,(REGS+20,4,X),2X,     X\n               (REGS+24,4,X),2X,(REGS+28,4,X),INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n         STRING '   GPR08-11: ',(REGS+32,4,X),2X,(REGS+36,4,X),2X,     X\n               (REGS+40,4,X),2X,(REGS+44,4,X),INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n         STRING '   GPR12-15: ',(REGS+48,4,X),12X,                     X\n               (REGS+56,4,X),2X,(REGS+60,4,X),EYECATCH,INTO=LINE\n         BAL   R14,SPACE1          <== Print line\nLINK299  END_PROC\n*\n*----------------------------------------------------------------------\n*        PRINT OPEN FILES\n*----------------------------------------------------------------------\n*\nDEB000   BEGIN_PROC\n         ICM   R5,B'1111',TCBDEB       FIRST DEB\n         BZ    DEB099                  NO DEB, JUMP\n*LOOP\nDEB011   SH    R5,=Y(DEBBASIC-DEBPREFX) POINT TO DEB PREFIX\n         USING DEBPREFX,R5\n         MVI   MINLINES,9\n         LA    R0,DEBBASIC             POINT TO BASIC SECTION\n         CLM   R0,B'0111',DCBDEBAD+1-IHADCB+DCBDEBUG  is it my own DCB?\n         BE    DEB080                  YES, SKIP IT\n         ST    R0,WKCELL1+4            DEB ADDRESS FOR $PRINT\n*\n         BAS   R3,DEB032\n         DC    C'VSAM',AL1(DEBAMVSM)\n         DC    C'EXCP',AL1(DEBAMXCP)\n         DC    C'SAM ',AL1(DEBAMSAM)\n         DC    C'BDAM',AL1(DEBAMBDM)\n         DC    C'JES ',AL1(DEBAMSUB)\n         DC    C'VTAM',AL1(DEBAMVTM)\n         DC    C'????',0H'0'\n*--LOOP\nDEB032   CLC   DEBAMTYP,4(R3)          IS THIS MY AMTYPE?\n         BE    DEB040                  YES, JUMP\n         LA    R3,4+1(,R3)             BUMP TABLE PTR\n         CLI   0(R3),C'?'              END OF TABLE?\n         BNE   DEB032                  NEXT TABLE ENTRY\n*--ENDLOOP\nDEB040   SLR   R6,R6                   DCB/ACB addr set by VALDCB rtne\n         BAL   R14,SWA000          <== locate DEB/DSAB/SIOT/JFCB/TIOT\n         BAL   R14,VALDCB          <== LOCATE/VALIDATE DCB (or ACB)\n         LTR   R6,R6                   CHECKED OUT OK?\n         BZ    DEB048                  NO, SKIP IT\n         ST    R6,WKCELL1              FOR $PRINT\n         LH    R0,DCBTIOT-IHADCB(,R6)  GET TIOT OFFSET FOR THIS DCB\n         BAL   R14,EXCP00          <== GET EXCP COUNT IN R0\n         B     DEB050\n*\nDEB048   MVC   WKCELL1(4),DEBDCBAD     FOR $PRINT\n         MVC   DDNAME2(8),=C'********' DCB is bad\n         SLR   R0,R0                   EXCP=0\n         ICM   R15,B'1111',$SIOT       SIOT addr good?\n*EX 0,*\n         BNP   DEB050                  no, exit\n         MVC   DDNAME2(8),SCTDDNAM-SIOT(R15)\n*\n         L     R1,PSATOLD-PSA(,0)      MY TCB\n         L     R1,TCBTCT-TCB(,R1)      TCBTCT\n         USING SMFTCT,R1\n         L     R1,TCTIOTBL             START OF I/O MEASUREMENT TABLE\n         USING TCTTIOT,R1\n         ICM   R15,B'1111',$DSAB       DSAB POINTER\n         BNP   DEB050                  no, exit\n         USING DSAB,R15\n         LH    R15,DSABTCTL            OFFSET TO TCT DD ENTRY\n         LA    R15,TCTTIOT(R15)        DD LOOKUP TABLE ENTRY\n         USING TCTIODSP,R15\n         L     R15,TCTIOTSD            OFFSET TO I/O CTR ENTRY\n         LA    R1,TCTTIOT(R15)         ADDRESS OF I/O CTR ENTRY\n         USING TCTDDENT,R1\n         L     R0,TCTDCTR              EXCP COUNT\n         DROP  R15,R1\n*\nDEB050   IC    R1,DEBOPATB             OPEN OPTION\n         LA    R15,X'0F'               MASK FOR 'NR'\n         NR    R1,R15                  KEEP ONLY X'0F' BITS\n         IC    R1,OPENOPT1(R1)         GET OFFSET TO OPENOPT2 ENTRY\n         LA    R1,OPENOPT2(R1)         POINT TO OPEN OPTION\n*\n         BAL   R14,BLANK1          <== BLANK LINE\n         CLI   DEBAMTYP,DEBAMVSM       VSAM?\n         BE    DEB060                  YES, JUMP\n         CLI   DEBAMTYP,DEBAMSUB       SUB-SYSTEM DATA SET?\n         BE    DEB070                  YES, JUMP\n***      STRING '0',INTO=LINE121,                                      X\n               ((R3),4),' DEB: ',(WKCELL1+5,3,X),                      X\n               2X,((R1),6),            IN/OUT/UPD                      X\n               '  DCB: ',(WKCELL1+1,3,X),                              X\n               '  DDN: ',DDNAME2,                                      X\n               '  EXCP: ',((R0),,L)\n         STRING '0DEB=',(WKCELL1+5,3,X),                               +\n               ',',((R3),4,T),         SAM/VSAM/JES                    +\n               ',',((R1),6,T),         INPUT/OUTPUT/UPDATE/EXTEND/OUTIN+\n               ',DCB=',(WKCELL1+1,3,X),                                +\n               ',DDN=',(DDNAME2,,T),                                   +\n               ',EXCP=',((R0),,L),                                     +\n               INTO=LINE121\n         TM    DEBFLGS1,DEBEOFDF       EOF flag ON?     IECEQU=DEBF1EOF\n*LASTVOL BO    DEB056                  yes, jump\n*LASTVOL TM    DEBOFLGS,DEBEOF         EOF flag ON?     IECEQU=DEBOFEOF\n         BZ    DEB057                  no, jump\nDEB056   LA    R15,LINE121(R15)        end of text\n         MVC   0(4,R15),=C',EOF'       append indicator\nDEB057   BAL   R14,SPACE1          <== Print line\n         CLI   DDNAME2,C'*'            DCB OK?\n         BE    DEB080                  no, exit\n         BAL   R14,PRDCB           <== PRINT DCB DATA\n         B     DEB080\n*                   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\nOPENOPT1 DC    AL1(00,06,00,12,18,00,42,24,00,00,00,00,00,00,30,36)\nOPENOPT2 DC    C'INPUT RDBACKINOUT UPDAT OUTIN EXTENDOUTPUTOUTINX'\n*\nDEB060   STRING '0DEB=',(WKCELL1+5,3,X),                           VSAM+\n               ',',((R3),4,T),         VSAM                            +\n               ',ACB=',(WKCELL1,4,X),                                  +\n               ',DDN=',(DDNAME2,,T),                                   +\n               ',EXCP=',((R0),,L),                                     +\n               INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\n         CLI   DDNAME2,C'*'            ACB OK?\n         BE    DEB080                  no, exit\n         BAL   R14,PRACB           <== PRINT ACB/PLH (VSAM/JES)\n         B     DEB080\n*\nDEB070   STRING '0DEB=',(WKCELL1+5,3,X),                         SUBSYS+\n               ',',((R3),4,T),         SUBSYS                          +\n               ',',((R1),6,T),         INPUT/OUTPUT/UPDATE/EXTEND/OUTIN+\n               ',ACB=',(WKCELL1,4,X),                                  +\n               ',DDN=',(DDNAME2,,T),                                   +\n               ',EXCP=',((R0),,L),                                     +\n               INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\n         CLI   DDNAME2,C'*'            ACB OK?\n         BE    DEB080                  no, exit\n         BAL   R14,PRACB           <== PRINT ACB/PLH (VSAM/JES)\n*\nDEB080   ICM   R5,B'0111',DEBDEBAD+1   NEXT DEB IN CHAIN\n         BNZ   DEB011                  TRY NEXT DCB\n*ENDLOOP\nDEB099   END_PROC\n*\n*----------------------------------------------------------------------\n*        Print SDWA\n*----------------------------------------------------------------------\n*\nPRWA00   BEGIN_PROC\n         STRING '0SCHEDULER WORK AREA',INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\n         LA    R0,SDWALEN              LENGTH\n         LA    R1,SDWA                 ADDRESS\n         BAL   R14,DUMP32          <== PRINT SDWA\nPRWA99   END_PROC\n*\n*----------------------------------------------------------------------\n*        GET EXCP COUNT FROM TCT\n*----------------------------------------------------------------------\n*\nEXCP00   BEGIN_PROC\n         L     R1,PSATOLD-PSA(,0)      MY TCB\n         L     R1,TCBTCT-TCB(,R1)      TCBTCT\n         L     R1,TCTIOTBL-SMFTCT(,R1) START OF I/O MEASUREMENT TABLE\n         LA    R1,TCTIODSP-TCTTIOT(,R1) FIRST DD ENTRY\n         USING TCTDCBTD,R1\n*LOOP\nEXCP11   CL    R0,TCTDCBTD             SAME TIOT OFFSET?\n         BE    EXCP21                  YES, EXIT LOOP\n         ICM   R15,B'1111',TCTDCBLE    END OF TABLE ?\n         LA    R1,TCTDCBLE             NEXT LOOKUP TABLE ENTRY\n         BNZ   EXCP11                  NOT YET, TRY NEXT DD ENTRY\n*ENDLOOP\n         SLR   R0,R0                   EXCP COUNT IS ZERO\n         B     EXCP99\n*\nEXCP21   L     R1,TCTIOTSD             OFFSET IN I/O MEASURE. TABLE\n         L     R15,PSATOLD-PSA(,0)     MY TCB\n         L     R15,TCBTCT-TCB(,R15)    MY TCT\n         A     R1,TCTIOTBL-SMFTCT(,R15) START OF I/O MEASUREMENT TABLE\n         USING TCTDDENT,R1\n         ICM   R0,B'1111',TCTDCTR      EXCP COUNT IN R0\nEXCP99   LR    R1,R0                   EXCP COUNT IN R1 TOO\n         END_PROC\n         DROP  R1\n*\n*----------------------------------------------------------------------\n*        CONVERT UCBTYP TO UNITNAME\n*----------------------------------------------------------------------\n*\nGETUNIT  BEGIN_PROC\n         MVI   TENWORDS+20,X'01'       RETURN A LOOK-UP VALUE (BIT7)\n         MVI   TENWORDS+21,X'00'       CLEAR UNUSED BYTE\n         LA    R14,UNITNAME        <== UNITNAME+DEVTYPE\n         LA    R15,TENWORDS+20         FLAGS\n         STM   R14,R15,TENWORDS    <==\n         OI    TENWORDS+4,X'80'        END-OF-LIST FLAG\n         LA    R1,TENWORDS             PARM LIST ADDRESS\n         L     R15,IEFEB4UV            LOAD ROUTINE ADDRESS\n         BALR  R14,R15             <== GET UNIT NAME\n         LTR   R15,R15\n         BNZ   GETUNIT6                BAD RETURN CODE, QUIT\n         MVI   TENWORDS+20,X'20'       RETURN A UNIT NAME (BIT2)\n         LA    R1,TENWORDS             PARM LIST ADDRESS\n         L     R15,IEFEB4UV            LOAD ROUTINE ADDRESS\n         BALR  R14,R15             <== GET UNIT NAME\n         LTR   R15,R15\n         BZ    GETUNIT9                GOOD RETURN CODE, GOBACK\nGETUNIT6 MVC   UNITNAME,BLANKS         CONVERSION DID NOT WORK\nGETUNIT9 DS    0H\n         END_PROC\n*\n*----------------------------------------------------------------------\n*        VALIDATE DCB, FIND TIOT OFFSET\n*----------------------------------------------------------------------\n*\nVALDCB   BEGIN_PROC\n        #S0C4  VALDCB8\n         CLI   $ACB,FF                 VSAM/SUBSYS?\n         BNZ   VALDCB3                 YES, JUMP\n         USING DEBPREFX,R5\n         USING IHADCB,R6\n         TM    DCBTIOT,X'C0'           IS DCB OPEN?\n         BNZ   VALDCB5                 NO, JUMP\n*\n*        VALIDATE DCB/DEB CROSS POINTERS\n*\n         CLI   OCE_CODE,C'O'           OPEN SVC?                @921015\n         BE    VALDCB3                 YES, SKIP DEB VALIDATION\n         LTR   R5,R5                   DEB address set already?\n         BNZ   VALDCB3                 YES, SKIP DEB VALIDATION\n         SLR   R1,R1\n         ICM   R1,B'0111',DCBDEBAD+1   PICK UP DEB ADDRESS\n         BZ    VALDCB8                 BAD, QUIT\n         CLM   R6,B'0111',DEBDCBAD+1-DEBBASIC(R1) COMP W/ DCB ADDR\n         BNE   VALDCB8                 BAD, QUIT\n         SLR   R5,R5\n         ICM   R5,B'0111',DCBDEBAD+1   GET DEB ADDRESS          @920408\n         SH    R5,=Y(DEBBASIC-DEBPREFX) POINT TO DEB PREFIX     @920408\n*\n*        LOCATE CORRESPONDING TIOT ENTRY\n*\nVALDCB3  L     R1,TCBTIO               TIOT ADDRESS\n         LA    R1,0024(,R1)            FIRST DD ENTRY\n*LOOP\nVALDCB3B CLI   4(R1),C' '              BLANK DDNAME?\n         BNH   VALDCB3F                YES, JUMP\n         MVC   DDNAME,4(R1)            SAVE DDNAME\n         SLR   R15,R15                 CONCAT#\n         B     VALDCB3G\nVALDCB3F LA    R15,1(,R15)             BUMP CONCAT#\nVALDCB3G CL    R1,$TIOT                is it my DD entry?\n         BE    VALDCB4                 YES, QUIT\n         SLR   R0,R0\n         IC    R0,0(,R1)               LOAD TIOELNGH\n         AR    R1,R0                   NEXT TIOT ENTRY\n         CLI   0(R1),00                END-OF-TIOT REACHED?\n         BNE   VALDCB3B                NOT YET, LOOP FURTHER\n*ENDLOOP\n         B     VALDCB8                 END OF TIOT, QUIT\n*\nVALDCB4  MVC   DDNAME2,BLANKS          CLEAR WORK AREA\n         MVC   DDNAME2(8),DDNAME       SAVE DDNAME\n         LTR   R0,R15                  PASS CONCAT#\n         BZ    VALDCB9                 FIRST IN CONCAT, JUMP\n         STRING (DDNAME,,T),'+',((R0),,R3Z),INTO=DDNAME2 SYSIN+002\n         B     VALDCB9\n*\n*        NON-OPEN DCB\n*\nVALDCB5  CLI   DCBOFLGS,2              OPEN FLAGS OK?\n         BNE   VALDCB8                 NO, JUMP\n         MVC   DDNAME,DCBDDNAM         SAVE DDNAME\n         MVC   DDNAME2,DCBDDNAM        SAVE DDNAME\n         TR    DDNAME2,TRTPRINT\n         CLC   DDNAME2,DCBDDNAM        GOOD DDNAME?\n         BE    VALDCB9                 YES, JUMP\n*\nVALDCB8  SR    R6,R6                   NOT A DCB, GOBACK\n         MVC   DDNAME,BLANKS           CLEAR DDN\n         MVC   DDNAME2,BLANKS          CLEAR DDN\nVALDCB9 #S0C4  RESET\n         END_PROC\n*\n*----------------------------------------------------------------------\n*        Locate DSAB/SIOT/JFCB/TIOT from DEB extension\n*----------------------------------------------------------------------\n*\nSWA000   BEGIN_PROC\n         MVI   $DCB,FF                 invalidate DCB address\n         MVI   $ACB,FF                 invalidate ACB address\n         MVI   $DSAB,FF                invalid address\n         MVI   $SIOT,FF                invalid address\n         MVI   $JFCB,FF                invalid address\n         MVI   $TIOT,FF                invalid address\n*\n*        retrieve DCB/ACB address from DEB if R5=A(DEBPREFX)\n*\nSWA010   LTR   R5,R5                   DEB addr valid?\n         BZ    SWA020                  no, jump\n         USING DEBPREFX,R5\n         LTR   R6,R6                   DCB/ACB addr valid?\n         BNZ   SWA025                  yes, jump\n         ICM   R6,B'0111',DEBDCBAD+1   24-bit DCB/ACB addr\n         CLI   DEBAMTYP,DEBAMSUB       AM=SUBSYS?\n         BE    SWA018                  yes, jump\n         CLI   DEBAMTYP,DEBAMVSM       AM=VSAM?\n         BNE   SWA025                  no, process DCB\n*\n*        AM=VSAM\n*\nSWA017   ST    R6,$ACB                 ACB address (24-bit)\n         ICM   R0,B'1111',DEBRRQ       do we have an RMODE31 ACB?\n         BZ    SWA030                  no, use RMODE24 ACB\n         LR    R6,R0                   yes, use RMODE31 ACB\n         B     SWA030                  Process ACB\n*\n*        AM=SUBSYS\n*\nSWA018   ST    R6,$ACB                 ACB address\n         ICM   R0,B'1111',DEBRRQ       do we have a DCB?\n         BZ    SWA030                  no, use ACB\n         LR    R6,R0                   yes, use DCB\n         B     SWA025                  Process ACB\n*\n*        if invoked with R5=0, set DEB addr from DCB/ACB\n*\nSWA020   LTR   R6,R6                   DCB/ACB addr valid?\n         BZ    SWA090                  no, exit\n         TM    DCBOFLGS,DCBOFOPN       OPEN DCB?\n         BZ    SWA090                  no, exit\n         ICM   R5,B'0111',DCBDEBAD+1   DEB address from DCB/ACB\n         SH    R5,=Y(DEBBASIC-DEBPREFX)  point at DEB prefix\n*\nSWA025   ST    R6,$DCB                 DCB address\n         USING IHADCB,R6\n*\n*        retrieve DSAB addr from DEB extension\n*\nSWA030   TM    DEBFLGS1,DEBXTNIN       do we have a DEB extension?\n         BZ    SWA090                  no, exit\n         ICM   R1,B'1111',DEBXTNP      DEB extension\n         BZ    SWA090                  zero, exit\n         USING DEBXTN,R1\n         ICM   R2,B'1111',DEBXDSAB     OPENJ DSAB pointer\n         BNZ   SWA035                  non-zero, jump\n         ICM   R2,B'1111',DEBXDSAB     DSAB pointer\n         BZ    SWA090                  no DSAB, exit\n         USING DSAB,R2\nSWA035   CLC   DSABID,=C'DSAB'         is this a DSAB?\n         BNE   SWA090                  no DSAB, jump\n         ICM   R1,B'1111',DSABSIOT     SIOT ptr\n         BNZ   SWA040                  ok, jump\n         LA    R1,TENWORDS+4           WORK AREA\n         ST    R1,TENWORDS             WORK AREA\n         USING ZB505,R1\n         XC    SWAEPAX,SWAEPAX         CLEAR WORK AREA\n         MVC   SWVA,DSABSSVA           SVA OF THE SIOT\n         DROP  R1\n         SWAREQ FCODE=RL,EPA=TENWORDS,MF=(E,SWAREQL1),UNAUTH=YES\n         L     R1,SWBLKPTR-ZB505+TENWORDS+4  31-BIT ADDRESS OF SIOT\n*\nSWA040   ST    R2,$DSAB                DSAB ADDRESS\n         ST    R1,$SIOT                SIOT ADDRESS\n         USING INDMSIOT,R1\n         MVC   $JFCB,SJFCBPTR          JFCB pointer\n         MVC   $TIOT,DSABTIOT          TIOENTRY pointer\n         DROP  R2,R1                   DSAB,SIOT\n*\nSWA090   END_PROC\n         DROP  R5,R6                   DEB, DCB\n*\n*----------------------------------------------------------------------\n*        PRINT DCB INFORMATION\n*----------------------------------------------------------------------\n*\nPRDCB    BEGIN_PROC\n         USING DEBPREFX,R5\n         USING IHADCB,R6\n         LTR   R6,R6                   DCBADDR=0?\n         BNP   PRDCB99                 yes, ignore\n         ST    R6,WKCELL1              STORE DCB ADDRESS\n*\n         LA    R15,=C'ISPSDAPOVS??'\n         TM    DCBDSORG+0,X'80'        IS\n         BO    PRDCB07                 IS\n         LA    R15,2(,R15)\n         TM    DCBDSORG+0,X'40'        PS\n         BO    PRDCB07                 PS\n         LA    R15,2(,R15)\n         TM    DCBDSORG+0,X'20'        DA\n         BO    PRDCB07                 DA\n         LA    R15,2(,R15)\n         TM    DCBDSORG+0,X'02'        PO\n         BO    PRDCB07                 PO\n         LA    R15,2(,R15)\n         TM    DCBDSORG+1,X'08'        VS\n         BO    PRDCB07                 VS\n         LA    R15,2(,R15)\nPRDCB07  MVC   XDSORG,0(R15)           MOVE DSORG\n*\n         MVC   XRECFM,BLANKS\n         LA    R1,XRECFM               START OF WORK AREA\n         TM    DCBRECFM,DCBRECF        F/V/U\n         BNO   PRDCB08V                F/V/U\n         MVI   0(R1),C'F'              F/V/U\nPRDCB08V TM    DCBRECFM,DCBRECV        F/V/U\n         BNO   PRDCB08U                F/V/U\n         MVI   0(R1),C'V'              F/V/U\nPRDCB08U TM    DCBRECFM,DCBRECU        F/V/U\n         BNO   PRDCB08B                F/V/U\n         MVI   0(R1),C'U'              F/V/U\nPRDCB08B TM    DCBRECFM,DCBRECBR       .B\n         BNO   PRDCB08S                .B\n         MVI   1(R1),C'B'              .B\n         LA    R1,1(,R1)\nPRDCB08S TM    DCBRECFM,X'08'          ..S\n         BNO   PRDCB08A                ..S\n         MVI   1(R1),C'S'              ..S\n         LA    R1,1(,R1)\nPRDCB08A TM    DCBRECFM,X'04'          ...A\n         BNO   PRDCB08M                ...A\n         MVI   1(R1),C'A'              ...A\nPRDCB08M TM    DCBRECFM,X'02'          ...M\n         BNO   PRDCB08Z                ...M\n         MVI   1(R1),C'M'              ...M\nPRDCB08Z EQU   *\n         TM    DCBMACRF,DCBMRECP       EXCP DCB?\n         BO    PRDCB31                 YES, JUMP\n         TM    DCBMACRF,DCBMRGET       QSAM DCB?\n         BO    PRDCB41                 YES, JUMP\n         TM    DCBMACRF+1,DCBMRPUT     QSAM DCB?\n         BO    PRDCB41                 YES, JUMP\n         MVI   WKCELL1,C'P'            A \"P\" FOR BPAM\n         TM    DCBDSORG,JFCORGPO       BPAM DCB?\n         BO    PRDCB11                 YES, JUMP\n         MVI   WKCELL1,C'D'            A \"D\" FOR BDAM\n         TM    DCBDSORG,JFCORGDA       BDAM DCB?\n         BO    PRDCB11                 YES, JUMP\n         MVI   WKCELL1,C'S'            A \"S\" FOR BSAM\nPRDCB11  MVI   MINLINES,6\n         STRING '0  B',(WKCELL1,1),'AM',                               X\n               ' DCB AT LOCATION ',(WKCELL1+1,3,X),                    X\n               6X,'RECFM=',(XRECFM,,T),                                X\n               ',LRECL=',(DCBLRECL,H,L),                               X\n               ',BLKSIZE=',(DCBBLKSI,H,L),                             X\n               ',BUFNO=',(DCBBUFNO,FL1,L),                             X\n               ',NCP=',(DCBNCP,FL1,L),                                 X\n               ',BUFL=',(DCBBUFL,H,L),                                 X\n               ',DSORG=',(XDSORG,,T),INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\n         LA    R0,DCBLNGPO             LENGTH\n         LA    R1,IHADCB               ADDRESS\n         BAL   R14,DUMP32          <== PRINT IT\n*\n*        Print DCBE, if present\n*\n         TM    DCBEODAD,DCBH0+DCBH1    Is DCBDCBE valid ?\n         BNO   PRDCB16                 no, jump\n         L     R1,DCBDCBE              A(DCBE)\n         USING DCBE,R1\n         OC    DCBE(DCBEMINL),DCBE     validate\n         MVI   MINLINES,6\n         STRING '0  DCBE AT LOCATION ',(DCBDCBE,,X),INTO=LINE121\n         BAL   R14,SPACE1          <== print header\n         LH    R0,DCBELEN              length of DCBE\n         BAL   R14,DUMP32          <== print DCBE\n*\n*        LOOK FOR DECB IF S001-XX ABEND\n*\nPRDCB16  CLI   OCE_CODE,C'E'           S001 ABEND?\n         BNE   PRDCB21                 NO, JUMP\n         L     R1,FRSTSVRB             LOAD ADDR OF FIRST SVRB\n         L     R1,RBGRS4-RBPREFIX(,R1) R1 POINTS TO DECB\n        #S0C4  PRDCB21\n         C     R6,DECDCBAD-DECB(,R1)   IS THIS MY DCB?\n         BNE   PRDCB21                 NO, QUIT\n         ST    R1,WKCELL1              STORE DECB ADDRESS\n         STRING '0  DECB AT LOCATION ',(WKCELL1+1,3,X),INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\n         LA    R0,020                  LENGTH OF DECB\n         BAL   R14,DUMP32          <== PRINT DECB\n         L     R2,DECIOBPT-DECB(,R1)   PICK UP IOB ADDRESS FROM DECB+16\n         USING IOBSTDRD-8,R2\n         CL    R6,IOBDCBPT             IS THIS MY DCB?\n         BE    PRDCB24                 YES, JUMP\n*\n*        LOCATE CURRENT IOB FROM DCBIOBA (DCB+68)\n*\nPRDCB21 #S0C4  RESET\n         SLR   R2,R2\n         ICM   R2,B'0111',DCBIOBA+1    GET IOB ADDRESS (DCB+68)\n         CLI   DCBNCP,1                NCP>1?\n         BNH   PRDCB24                 NO, JUMP\n         ICM   R2,B'0111',DCBICQE+1    YES, GET ICQE ADDRESS (DCB+28)\n         STRING '0  ICQE AT LOCATION ',(DCBICQE+1,3,X),INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\n         LA    R0,032                  ICQE SIZE\n         LR    R1,R2                   ICQE ADDRESS\n         BAL   R14,DUMP32          <== PRINT ICQE\n         L     R2,ICQFIRST-ICQE(,R2)   POINT TO FIRST IOB IN CHAIN\n         ICM   R2,B'1000',X00          zero first byte\n*SAMB    L     R2,ICQIOBAD-ICQE(,R2)   POINT TO IOB IN SAMB\n*SAMB    SH    R2,=H'16'               POINT TO START OF SAMB\n*SAMB    ST    R2,WKCELL1              STORE FOR STRING\n*SAMB    STRING '0  SAMB AT ADDRESS ',(WKCELL1+1,3,X),INTO=LINE\n*SAMB    BAL   R14,SPACE1          <== Print line\n*SAMB    LA    R0,256                  SAMB SIZE\n*SAMB    LR    R1,R2                   SAMB ADDRESS\n*SAMB    BAL   R14,DUMP32          <== PRINT ICQE\n*SAMB    LA    R2,8(,R2)               SAMIOB (IOB PREFIX)\n*\n*        PRINT CURRENT IOB\n*\nPRDCB24  CL    R2,REGION24             DOES THIS LOOK RIGHT?\n         BL    PRDCB99                 NO, QUIT\n         CLI   DEBAMTYP,DEBAMSUB       JES DEB?\n         BE    PRDCB99                 YES, QUIT\n         LA    R0,IOBSTDRD             STANDARD SECTION\n         ST    R0,WKCELL1              STORE FOR STRING\n         MVI   MINLINES,6\n         STRING '0  IOB AT LOCATION ',(WKCELL1+1,3,X),INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\n         STRING '0   -08 ',56X,(IOBPREFX+08,4,X),1X,(IOBPREFX+12,4,X), X\n               INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\n         LA    R0,064                  IOB SIZE\n         LA    R1,IOBSTDRD             IOB ADDRESS\n         O     R1,=X'80000000'         NO CTLCHR\n         BAL   R14,DUMP32          <== PRINT IOB\n         ICM   R1,B'0111',IOBECBPT+1   PICK UP DECB ADDRESS\n        #S0C4  PRDCB99                 DECB addr may be bad\n         LA    R0,IOBSTDRD             STANDARD SECTION\n         C     R0,DECIOBPT-DECB(,R1)   DOES THIS LOOK RIGHT?\n         BNE   PRDCB99                 NO, QUIT\n         MVI   MINLINES,4\n         STRING '0  DECB AT LOCATION ',(IOBECBPT+1,3,X),INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\n         LA    R0,020                  DECB SIZE\n         BAL   R14,DUMP32          <== PRINT DECB\n         B     PRDCB99\n         DROP  R2                      IOB\n*\nPRDCB31  MVI   MINLINES,5\n         STRING '0  EXCP DCB AT LOCATION ',(WKCELL1+1,3,X),            X\n               INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\n         LA    R0,DCBLNGXE             LENGTH\n         LA    R1,IHADCB               ADDRESS\n         BAL   R14,DUMP32          <== PRINT IT\n         B     PRDCB99\n*\nPRDCB41  MVI   MINLINES,6\n         STRING '(GL,PL)',INTO=XMACRF\n         CLI   DEBOPATB,DEBUPDAT       OPENED FOR UPDATE?\n         BE    PRDCB41S                yes, jump\n*\n*        edit MACRF codes\n*\n         BAS   R1,PRDCB41B             BR AROUND TABLE\n         DC    C'G',AL1(DCBMRGET)      40 GET\n         DC    C'M',AL1(DCBMRMVG)      10 MOVE MODE\n         DC    C'L',AL1(DCBMRLCG)      08 LOCATE MODE\n         DC    C'T',AL1(DCBMRSBG)      04 SUBSTITUTE MODE\n         DC    C'C',AL1(DCBMRCRL)      02 CNTRL\n         DC    C'D',AL1(DCBMRDMG)      01 DATA MODE\n         DC    2X'00'\nPRDCB41B MVC   WKCELL3,DCBMACF1        move macrf byte (input/update)\n         TM    DEBOPATB,DEBXTEND       OPENED FOR EXTEND/OUTPUT?\n         BNO   PRDCB41C                no, jump\n         MVC   WKCELL3,DCBMACF2        move macrf byte (output/extend)\n         BAS   R1,PRDCB41C             BR AROUND TABLE\n         DC    C'P',AL1(DCBMRPUT)      40 PUT\n         DC    C'M',AL1(DCBMRMVP)      10 MOVE MODE\n         DC    C'L',AL1(DCBMRLCP)      08 LOCATE MODE\n         DC    C'T',AL1(DCBMRTMD)      04 SUBSTITUTE MODE\n         DC    C'C',AL1(DCBMRCTL)      02 CNTRL\n         DC    C'D',AL1(DCBMRDMD)      01 DATA MODE\n         DC    2X'00'\nPRDCB41C TM    WKCELL3,*-*             DCBMACF1/DCBMACF2\n         MVC   XMACRF,BLANKS\n*loop\nPRDCB41D IC    R14,1(,R1)              MASK\n         EX    R14,PRDCB41C\n         BZ    PRDCB41E\n         STRING (XMACRF,,T),((R1),1),INTO=XMACRF\nPRDCB41E LA    R1,1+1(,R1)             NEXT ENTRY\n         CLI   0(R1),C'A'              end of table?\n         BNL   PRDCB41D                not yet, loop more\n*endloop\nPRDCB41S MVC   OPNBLKSI+2(2),DCBBLKSI  move BLKSI from DCB\n         MVC   OPNLRECL+2(2),DCBLRECL  move LRECL from DCB\n         CLI   DEBAMTYP,DEBAMSUB       JES DEB?\n         BE    PRDCB41Z                YES, EXIT\n         CLI   DEBLNGTH,16             DEB long enough?\n         BL    PRDCB41L                NO, TRY LBI\n         SR    R1,R1                   CLEAR REGISTER\n         SR    R2,R2                   CLEAR REGISTER\n         IC    R1,DEBNMEXT             NUMBER OF EXTENTS\n         IC    R2,DEBEXSCL             EXTENT SCALE\n         SLL   R1,0(R2)                SIZE OF EXTENT\n         LA    R2,DEBBASND(R1)         ADJ TO PROPER OFFSET\n         USING DEBACSMD,R2             Access Method Extension\n         LH    R14,DEBLRECL            Get DCBLRECL before OPEN\n         LH    R15,DEBBLKSI            Get DCBBLKSI before OPEN\n         DROP  R2                      DEB\n         LTR   R14,R14                 DEBLRECL=0?\n         BZ    PRDCB41X                yes, use DCBLRECL\n         TM    DCBRECFM,DCBRECU        RECFM=U?\n         BO    PRDCB41X                yes, use DCBLRECL\n         ST    R14,OPNLRECL            save it for later\nPRDCB41X LTR   R15,R15                 DEBBLKSI=0?\n         BNZ   PRDCB41Y                no, use it\nPRDCB41L TM    DCBEODAD,DCBH0+DCBH1    Is DCBDCBE valid ?\n         BNO   PRDCB41Z                no, use DCBLRECL\n         L     R1,DCBDCBE              A(DCBE)\n         USING DCBE,R1\n         TM    DCBEFLG1,DCBESLBI       LBI IN EFFECT?\n         BNO   PRDCB41Z                no, use DCBLRECL\n         L     R15,DCBEBLKSI           LBI block size\n         DROP  R1                      DCBE\nPRDCB41Y ST    R15,OPNBLKSI            save it for later\n*\nPRDCB41Z STRING '0  QSAM',                                             X\n               ' DCB AT LOCATION ',(WKCELL1+1,3,X),                    X\n               6X,'MACRF=',(XMACRF,,T),                                X\n               ',RECFM=',(XRECFM,,T),                                  X\n               ',LRECL=',(OPNLRECL,F,L),                               X\n               ',BLKSIZE=',(OPNBLKSI,F,L),                             X\n               ',BUFNO=',(DCBBUFNO,FL1,L),                             X\n               ',DSORG=',(XDSORG,,T),INTO=LINE121\n         TM    DCBBFTEK,DCBBFTA        BFTEK=A?\n         BNO   PRDCB41K                NO, JUMP\n         STRING (LINE121,,T),',BFTEK=A',INTO=LINE121\nPRDCB41K EQU   *\n         BAL   R14,SPACE1          <== print header\n         LA    R0,DCBLNGQS             LENGTH\n         LA    R1,IHADCB               ADDRESS\n         BAL   R14,DUMP32          <== print DCB\n*\n*        Print DCBE, if present\n*\n         TM    DCBEODAD,DCBH0+DCBH1    Is DCBDCBE valid ?\n         BNO   PRDCB42                 no, jump\n         L     R1,DCBDCBE              A(DCBE)\n         USING DCBE,R1\n         OC    DCBE(DCBEMINL),DCBE     validate\n         MVI   MINLINES,6\n         STRING '0  DCBE AT LOCATION ',(DCBDCBE,,X),INTO=LINE121\n         BAL   R14,SPACE1          <== print header\n         LH    R0,DCBELEN              length of DCBE\n         BAL   R14,DUMP32          <== print DCBE\n*\n*        PRINT CURRENT RECORD FOR A QSAM DCB\n*\nPRDCB42  CLI   OCE_CODE,C'O'           ABEND DURING OPEN?\n         BNE   PRDCB42J                NO, JUMP\n         CL    R6,SDWAGR02             WAS THIS FOR THIS DCB?\n         BE    PRDCB99                 YES, QUIT\n*\n*        If it's a SAM-CI DCB with MACRF=PM, do not print the record\n*        pointed to by DCBRECAD; the DFP V3 version of IGG019DJ (the\n*        SAM-CI QSAM processor) does not move any data to the buffer.\n*        The record should be printed from the JES2 unprotected\n*        buffer in the PRACB routine.\n*\nPRDCB42J CLI   DEBAMTYP,DEBAMSUB       SUB-SYSTEM DATA SET?\n         BNE   PRDCB43                 no, jump\n         TM    DEBOPATB,DEBXTEND       OPENED FOR EXTEND/OUTPUT?\n         BNO   PRDCB43                 NO, JUMP\n         TM    DCBMACRF+1,DCBMRPUT+DCBMRMVP  MACRF=PM?\n         BNO   PRDCB43                 NO, JUMP\n         CLI   SPLEVEL,2               CHECK MVS/SP LEVEL\n         BH    PRDCB99                 QUIT (MODE=O,MACRF=PM,SPLEVEL=3)\n*\nPRDCB43  LM    R0,R1,DCBEOBAD          R0=EOBAD,R1=RECAD\n         TM    DCBEODAD,DCBH0+DCBH1    Is DCBDCBE valid ?\n         BO    PRDCB43C                yes, jump\n         ICM   R0,B'1000',X00          zero first byte (DCBNCP)\n         ICM   R1,B'1000',X00          zero first byte (DCBRECBT)\n*\n*        locate start of current buffer\n*\nPRDCB43C MVC   REASON,=C'EOB'          invalid value in DCBEOBAD\n         CL    R0,REGION24             EOBAD VALID?\n         BL    PRDCB90                 NO RECORD YET, QUIT\n         CLI   DEBAMTYP,DEBAMSUB       SUB-SYSTEM DATA SET?\n         BE    PRDCB43J                yes, jump\n         L     R2,DCBIOBA              current IOB\n         ICM   R2,B'1000',X00          zero first byte\n         USING IOBSTDRD-8,R2\n         CL    R6,IOBDCBPT             does this IOB look right?\n         BNE   PRDCB43F                no, jump\n         MVC   WKCELL2,IOBCCW          move r/w CCW\n         B     PRDCB43G\n*\n*        Process ICB pointed to by DCBIOBS (chained scheduling)\n*\nPRDCB43F MVC   REASON,=C'006'          invalid IOB/ICB\n         TM    DCBCIND2,DCBCNCHS       Chained scheduling (i.e. tape) ?\n         BZ    PRDCB90                 no, we're lost\n         USING IOBCCW-32,R2            CCW is at ICB+32\n         MVC   WKCELL2,IOBCCW          move r/w CCW\n         DROP  R2                      IOB\n*\n*        Get buffer addr from R/W CCW (or IDAW)\n*\nPRDCB43G SLR   R14,R14\n         ICM   R14,B'0111',WKCELL2+1   get buffer addr from CCW\n         TM    WKCELL2+4,X'04'         IDA bit on?\n         BZ    PRDCB43S                no, jump\n         L     R14,0(,R14)             get 31-bit buffer address\n         B     PRDCB43S\n*\nPRDCB43J LR    R14,R0                  PASS DCBEOBAD\n         SH    R14,DCBBLKSI            SUBTRACT BUFFER LENGTH FROM EOB\n         BNP   PRDCB90                 NO RECORD YET, QUIT\n*\nPRDCB43S ST    R14,BUFFER              BEGINNING OF CURR BUFFER\n*\n         TM    DCBRECFM,DCBRECU        U?\n         BO    PRDCB60                 YES, JUMP\n         TM    DCBRECFM,DCBRECV        V/VB?\n         BO    PRDCB70                 YES, JUMP\n         LH    R2,DCBLRECL             RECORD LENGTH IF FB\n         TM    DCBRECFM,DCBRECF+DCBRECBR   FB?\n         BO    PRDCB50                 YES, JUMP\n         LH    R2,DCBBLKSI             RECORD LENGTH IF F\n*F/FB\nPRDCB50  TM    DEBOPATB,DEBXTEND       OPENED FOR EXTEND/OUTPUT?\n         BNO   PRDCB80                 NO, JUMP\n         SR    R1,R2                   GET ADDR OF CURRENT RECORD\n         MVC   REASON,=C'REC'          invalid value in DCBRECAD\n         C     R1,BUFFER               TOO LOW?\n         BL    PRDCB90                 YES, JUMP\n*\n*        LOCATE PREVIOUS RECORD (RECFM=F/FB)\n*\n         TM    DCBRECFM,DCBRECF+DCBRECBR   FB?\n         BNO   PRDCB80                 NO, JUMP\n         LR    R0,R1                   GET ADDR OF CURRENT RECORD\n         SR    R0,R2                   GET ADDR OF PREVIOUS RECORD\n         C     R0,BUFFER               PREV RCD IN CURR BUFFER?\n         BL    PRDCB80                 NO, JUMP\n         MVI   MINLINES,6\n         STRING '0    PREVIOUS RECORD:',INTO=LINE121\n         BAL   R14,SPACE1          <== PRINT HEADER\n         LR    R1,R0                   PASS ADDRESS\n         LR    R0,R2                   LENGTH\n         BAL   R14,PDUMP           <== DUMP PREVIOUS RECORD\n         AR    R1,R2                   GET ADDR OF CURRENT RECORD\n         B     PRDCB80\n*\n*        LOCATE CURRENT RECORD (RECFM=U)\n*\nPRDCB60  LH    R2,DCBLRECL             RECORD LENGTH IF U\n         C     R1,BUFFER               IS THIS THE START OF THE BUFFER?\n         BE    PRDCB80                 YES, JUMP\n         SLR   R1,R2                   NO, POINT TO START OF RECORD (U)\n         B     PRDCB80\n*\n*        LOCATE CURRENT RECORD (RECFM=V/VB)\n*\n*          MACRF=GM       DCBRECAD=next\n*          MACRF=GL       DCBRECAD=current\n*          MACRF=(GL,PL)  DCBRECAD=current\n*          MACRF=PM       DCBRECAD=next\n*          MACRF=PL       DCBRECAD=current\n*\nPRDCB70  TM    DEBOPATB,DEBXTEND       OPENED FOR EXTEND/OUTPUT?\n         BO    PRDCB71                 yes, jump\n         LH    R15,0(,R14)             pick up block length from BDW\n         ALR   R15,R14                 1st byte after current block\n         MVC   REASON,=C'BDW'          BUFFER/BDW/EOBAD incompatible\n         CLR   R15,R0                  same as DCBEOBAD?\n         BNE   PRDCB90                 NO, QUIT\n*\nPRDCB71  CLI   XMACRF+1,C'L'           LOCATE mode?\n         BE    PRDCB78                 YES, JUMP\n*\n*        DCBRECAD=next, scan current buffer to locate record\n*\n         LR    R0,R1                   first byte after current record\n         LA    R1,4(,R14)              first record (skip BDW)\n         SLR   R2,R2\n*--loop\nPRDCB73L ICM   R2,B'0011',0(R1)        length of current record (RDW)\n         MVC   REASON,=C'012'          RDW<4\n         CH    R2,=H'4'                is record at least 4 bytes?\n         BL    PRDCB90                 no, quit\n         MVC   REASON,=C'013'          RDW is not LLLL0000\n         CL    R2,OPNLRECL             record longer than LRECL?\n         BH    PRDCB90                 yes, quit\n         MVC   REASON,=C'014'          RDW is not LLLL0000\n         ICM   R2,B'1100',2(R1)        3rd-4th bytes of RDW\n         BNZ   PRDCB90                 NO, QUIT\n         ALR   R1,R2                   1st byte after record\n         CLR   R1,R0                   is this the record I want?\n         BL    PRDCB73L                not yet, keep on scannin'\n*--endloop\n         MVC   REASON,=C'015'          V/VB scan failed\n         BH    PRDCB90                 too high, exit\n         SLR   R1,R2                   point to record again\n*\nPRDCB78  LH    R2,0(,R1)               RECORD LENGTH IF V/VB\n         CLM   R2,B'0011',DCBLRECL     GOOD RDW?\n         BH    PRDCB90                 NO, QUIT\n*\n*        PRINT CURRENT RECORD (F/V/U)\n*\nPRDCB80  MVC   REASON,=C'000'          length=0\n         LTR   R0,R2                   LENGTH=0?\n         BZ    PRDCB90                 YES, JUMP\n         MVI   MINLINES,6\n         STRING '0    CURRENT RECORD:',INTO=LINE121\n** STRING '0    CURRENT RECORD ',((R0),,X),1X,((R1),,X),1X,((R2),,X),  X\n               INTO=LINE\n         BAL   R14,SPACE1          <== Print line\n         BAL   R14,PDUMP           <== DUMP IT\n         ST    R6,CURR_REC             CURRENT RECORD HAS BEEN PRINTED\n         B     PRDCB99\n*\nPRDCB90  STRING '0    CURRENT RECORD IS NOT AVAILABLE (',REASON,')',   X\n               INTO=LINE121\n*ORG PRDCB90\n*        STM   R14,R15,WKCELL1\n*        STRING '0    CURRENT RECORD IS NOT AVAILABLE (',REASON,')',   X\n               2X,(BUFFER,,X),1X,(WKCELL1,4,X),1X,(WKCELL1+4,4,X),     X\n               1X,((R0),,X),1X,((R1),,X),1X,((R2),,X),                 X\n               INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\nPRDCB99  END_PROC\n*\n*----------------------------------------------------------------------\n*        PRINT ACB INFORMATION (VSAM, JES)\n*----------------------------------------------------------------------\n*\nPRACB    BEGIN_PROC\n         USING DEBPREFX,R5\n         L     R6,$ACB                 pick up ACB address\n         STRING '0  ACB AT LOCATION ',((R6),,X),'   MACRF=(',          X\n               INTO=LINE121\n         USING IFGACB,R6\n*\n*        display MACRF\n*\n         BAS   R1,PRACB11A             BR AROUND TABLE\n         DC    C'KEY',AL1(ACBKEY)      80 00 00\n         DC    C'ADR',AL1(ACBADR)      40 00 00\n         DC    C'CNV',AL1(ACBCNV)      20 00 00\n         DC    C'SEQ',AL1(ACBSEQ)      10 00 00\n         DC    C'DIR',AL1(ACBDIR)      08 00 00\n         DC    C'IN ',AL1(ACBIN)       04 00 00\n         DC    C'OUT',AL1(ACBOUT)      02 00 00\n         DC    C'UBF',AL1(ACBUBF)      01 00 00\nPRACB11A TM    ACBMACR1,*-*\n*loop\nPRACB11B IC    R14,3(,R1)              MASK\n         EX    R14,PRACB11A\n         BZ    PRACB11C\n         STRING (LINE,,T),((R1),3,T),',',INTO=LINE\nPRACB11C LA    R1,3+1(,R1)             NEXT ENTRY\n         CLI   0(R1),C'A'              end of table?\n         BNL   PRACB11B                not yet, loop more\n*endloop\n         BAS   R1,PRACB12A             BR AROUND TABLE\n         DC    C'BWO',AL1(ACBBWO)      00 20 00\n         DC    C'SKP',AL1(ACBSKP)      00 10 00\n         DC    C'RST',AL1(ACBRST) NRS  80 04 00\n         DC    C'DSN',AL1(ACBDSN)      00 02 00\n         DC    C'AIX',AL1(ACBAIX) NRM  00 01 00\nPRACB12A TM    ACBMACR2,*-*\n*loop\nPRACB12B IC    R14,3(,R1)              MASK\n         EX    R14,PRACB12A\n         BZ    PRACB12C\n         STRING (LINE,,T),((R1),3,T),',',INTO=LINE\nPRACB12C LA    R1,3+1(,R1)             NEXT ENTRY\n         CLI   0(R1),C'A'              end of table?\n         BNL   PRACB12B                not yet, loop more\n*endloop\n         BAS   R1,PRACB13A             BR AROUND TABLE\n         DC    C'NLW',AL1(ACBNLW)      00 00 80    macr3\n         DC    C'LSR',AL1(ACBLSR) NSR  00 00 40\n         DC    C'GSR',AL1(ACBGSR)      00 00 20\n         DC    C'ICI',AL1(ACBICI)      00 00 10\n         DC    C'DFR',AL1(ACBDFR) NDF  00 00 08\n         DC    C'SIS',AL1(ACBSIS)      00 00 04\n**       DC    C'A31',AL1(ACBA31)      00 00 01\nPRACB13A TM    ACBMACR3,*-*\n*loop\nPRACB13B IC    R14,3(,R1)              MASK\n         EX    R14,PRACB13A\n         BZ    PRACB13C\n         STRING (LINE,,T),((R1),3,T),',',INTO=LINE\nPRACB13C LA    R1,3+1(,R1)             NEXT ENTRY\n         CLI   0(R1),C'A'              end of table?\n         BNL   PRACB13B                not yet, loop more\n*endloop\n         LA    R15,LINE-1(R15)         last comma\n         MVI   0(R15),C')'             close sub-list\n*\n         MVI   $AMBL,FF                invalidate AMBL address\n         MVI   $AMB_D,FF               invalidate DATA AMB address\n         MVI   $AMB_I,FF               invalidate INDX AMB address\n         MVI   $AMDSB_D,FF             invalidate DATA AMDSB address\n         MVI   $AMDSB_I,FF             invalidate INDX AMDSB address\n         MVI   $PLHDR,FF               invalidate PLH HEADER address\n*\n*        Locate/validate AMBL (VSAM data set only)\n*\n         L     R2,ACBAMBL              POINT TO AMBL\n         USING AMBL,R2\n         C     R2,REGION24             VALIDATE AMBL\n         BL    PRACB18                 LOST, QUIT\n        #S0C4  PRACB18\n         CLC   AMBL(64),0              VALIDATE\n         CLI   AMBLID,X'50'            am I lost?\n         BNE   PRACB18                 yes, exit\n         CL    R6,AMBLACB              AM I LOST?\n         BNE   PRACB18                 yes, exit\n         ST    R2,$AMBL                AMBL address OK\n*\n*        BUFNI/BUFND/STRNO\n*\nPRACB16  CLI   DEBAMTYP,DEBAMVSM       VSAM?\n         BNE   PRACB18                 NO, JUMP\n        #S0C4  PRACB18\nPRACB16I ICM   R3,B'1111',AMBLIX       INDEX AMB\n         BZ    PRACB16D                NO INDEX, JUMP\n         USING AMB,R3\n         CLI   AMBID,X'40'             am I lost?\n         BNE   PRACB16D                YES, JUMP\n         L     R1,AMBBUFC              INDEX BUFC HEADER\n         CLI   0(R1),X'70'             am I lost?\n         BNE   PRACB16D                yes, exit\n         ST    R3,$AMB_I               INDEX AMB address OK\n         MVC   $AMDSB_I,AMBDSB         INDEX AMDSB address OK\n         STRING (LINE,,T),',BUFNI=',(BUFCBUFN-BUFC(R1),FL1,L),         X\n               INTO=LINE\nPRACB16D L     R3,AMBLDTA              DATA AMB\n         C     R3,REGION24             VALIDATE AMB\n         BL    PRACB16S                LOST, QUIT\n         CLI   AMBID,X'40'             VALIDATE AMB\n         BNE   PRACB16S                LOST, QUIT\n         CLC   AMB(188),0              VALIDATE DATA AMB\n         ST    R3,$AMB_D               DATA AMB address OK\n         MVC   $AMDSB_D,AMBDSB         DATA AMDSB address OK\n         L     R1,AMBBUFC              DATA BUFC HEADER\n         CLI   0(R1),X'70'             validate BUFC\n         BNE   PRACB16S                LOST, QUIT\n         STRING (LINE,,T),',BUFND=',(BUFCBUFN-BUFC(R1),FL1,L),         X\n               INTO=LINE\n         TM    AMBFLG1,AMBCREAT        CREATE MODE?\n         BZ    PRACB16S                NO, JUMP\n         STRING (LINE,,T),',CREATE',INTO=LINE\nPRACB16S L     R1,AMBPH                PICK UP ADDR OF PLH HEADER\n         CLI   PLHID-IDAPLHDR(R1),X'30' VALIDATE\n         BNE   PRACB18                 LOST, QUIT\n         STRING (LINE,,T),',STRNO=',(PLHCNT-IDAPLHDR(R1),H,L),         X\n               INTO=LINE\n         ST    R1,$PLHDR               PLH HEADER addr OK\n*\nPRACB18  MVI   MINLINES,6\n         BAL   R14,SPACE1          <== print ACB address & MACRF\n         LH    R0,ACBLENG              ACB LENGTH\n         LA    R1,IFGACB               ACB ADDRESS\n         BAL   R14,DUMP32          <== PRINT ACB\n*\n         CLI   DEBAMTYP,DEBAMSUB       SUB-SYSTEM DATA SET?\n         BE    PRACB70                 YES, JUMP\n         CLI   DEBAMTYP,DEBAMVSM       VSAM?\n         BNE   PRACB99                 NO, EXIT\n         CL    R2,$AMBL                AMBL address OK ?\n         BNE   PRACB99                 NO, EXIT\n*\n*        PRINT VSAM CONTROL BLOCKS\n*\nPRACB20  MVC   MSG60,BLANKS            optional attributes\n         LA    R1,=C'DUMMY'\n         TM    AMBLFLG1,AMBLDUMY       DD DUMMY?\n         BO    PRACB20X                YES, JUMP\n         LA    R1,=C'KSDS '\n         TM    AMBLQ,AMBLKSDS          IS THIS A KSDS?\n         BO    PRACB20X                YES, JUMP\n         ICM   R3,B'1111',$AMB_D       DATA AMB\n         BNP   PRACB26                 BAD, JUMP\n         LA    R1,=C'LDS  '\n         TM    AMBFLG0,AMBLDS          Is this an LDS?\n         BO    PRACB20X                YES, JUMP\n         L     R14,$AMDSB_D            A(AMDSB)\n         LA    R1,=C'RRDS '\n         TM    AMDATTR-AMDSB(R14),AMDRRDS Is this an RRDS?\n         BO    PRACB20X                YES, JUMP\n         LA    R1,=C'ESDS '\nPRACB20X MVC   MSG60(5),0(R1)          DUMMY/KSDS/LDS/RRDS/ESDS\n*\n         TM    AMBLSHAR,AMBLWRIT       Update mode?\n         BNO   PRACB22                 NO, JUMP\n         STRING (MSG60,,T),',UPDATE',INTO=MSG60\n*\nPRACB22  EQU   *\n*\nPRACB26  MVI   MINLINES,6\n         STRING '0  AMBL AT LOCATION ',(ACBAMBL,,X),6X,MSG60,          X\n               INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\n         SLR   R0,R0\n         IC    R0,AMBLLEN              AMBL LENGTH\n         LA    R1,AMBL                 AMBL ADDRESS\n         BAL   R14,DUMP32          <== PRINT AMBL\n*\n*        Print DATA AMB\n*\n         LA    R0,188                  AMB LENGTH\n         ICM   R1,B'1111',$AMB_D       DATA AMB\n         BNP   PRACB99                 BAD, QUIT\n         MVI   MINLINES,9\n         STRING '0  DATA AMB AT LOCATION ',((R1),,X),                  X\n               '  DSNAME=',AMBDSNM,                                    X\n               INTO=LINE121\n         BAL   R14,SPACE1          <== PRINT HEADER\n         BAL   R14,DUMP32          <== PRINT AMB\n         DROP  R1,R2                   AMBL\n*\n         L     R2,AMBPH-AMB(,R1)       PICK UP ADDR OF PLH HEADER\n         USING IDAPLHDR,R2\n         MVI   MINLINES,4\n         STRING '0  PLH HEADER AT LOCATION ',((R2),,X),INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\n         C     R2,REGION24             VALIDATE\n         BL    PRACB99                 LOST, QUIT\n        #S0C4  PRACB99\n         CLC   IDAPLHDR(16),0          VALIDATE\n         LA    R0,016                  PLHDR LENGTH\n         LA    R1,IDAPLHDR             PLH Header\n         BAL   R14,DUMP32          <== PRINT PLHDR\n         CLI   PLHID,X'30'             VALIDATE\n         BNE   PRACB99                 LOST, QUIT\n         LA    R3,IDAPLH               POINT PAST PLH HEADER\n         USING IDAPLH,R3\n         MVI   STRNO,0                 PLH/RPL sequence number\n*\n*        Print PLH (one for each string)\n*loop\nPRACB40  C     R3,REGION24             VALIDATE\n         BL    PRACB99                 LOST, QUIT\n         IC    R14,STRNO               PLH sequence number\n         LA    R14,1(,R14)             PLH sequence number\n         STC   R14,STRNO               PLH sequence number\n        #S0C4  PRACB99\n         CLC   0(210,R3),0             VALIDATE\n         CLC   =C'PLH',PLHIDENT        VALIDATE\n         BNE   PRACB99                 LOST, QUIT\n         STM   R2,R3,SAVPLHPT          save A(IDAPLHDR,IDAPLH)\n         CLI   IDAPLH,FF               VALIDATE\n         BNE   PRACB69                 PLH not in use, try next one\n*\n*        Check if the PLH entry points to my ACB;\n*        If MACRF=LSR/GSR, the PLH entry could point to another\n*        ACB that shares the same buffer pool.\n*\n         C     R6,PLHACB               VALIDATE\n         BE    PRACB45                 OK, jump\n         LA    R0,IFGACB+1             VALIDATE\n         C     R0,PLHACB               VALIDATE\n         BNE   PRACB69                 not for this ACB, ignore it\n*\nPRACB45  MVI   MINLINES,10\n         STRING '0  PLH AT LOCATION ',((R3),,X),INTO=LINE121\n         CLC   PLHCNT,=H'1'            STRNO=1?\n         BE    PRACB45P                yes, do not count PLHs\n         STRING '0  PLH',(STRNO,FL1,L),' AT LOCATION ',((R3),,X),      X\n               INTO=LINE121\nPRACB45P BAL   R14,SPACE1          <== Print line\n*\nPRACB46  LA    R0,210                  PLH LENGTH\n         LA    R1,IDAPLH               PASS PLH ADDRESS\n         BAL   R14,DUMP32          <== PRINT PLH\n*\n*        PRINT RPL\n*\nPRACB50  L     R4,PLHCRPL              PICK UP RPL ADDRESS\n         USING IFGRPL,R4\n         C     R4,REGION24             VALIDATE\n         BL    PRACB99                 LOST, QUIT\n        #S0C4  PRACB99\n         CLC   IFGRPL(76),0            VALIDATE RPL\n*\n         BAL   R1,PRACB51R             BRANCH AROUND TABLE\n         DC    C'GET  ',AL1(RPLGET)    REQUEST\n         DC    C'PUT  ',AL1(RPLPUT)    REQUEST\n         DC    C'POINT',AL1(RPLPOINT)  REQUEST\n         DC    C'ERASE',AL1(RPLERASE)  REQUEST\n         DC    C'*REQ ',AL1(255)       unknown request\n*--loop\nPRACB51R CLC   RPLREQ,5(R1)            compare RPL request code\n         BE    PRACB51S                equal, exit loop\n         LA    R1,5+1(,R1)             next entry\n         CLI   5(R1),255               end of table?\n         BNE   PRACB51R                no, try next entry\n*--endloop\nPRACB51S MVI   MINLINES,6\n         STRING '0  RPL AT LOCATION ',((R4),,X),3X,                    X\n               ((R1),5,T),',OPTCD=(',INTO=LINE121\n         CLC   PLHCNT,=H'1'            STRNO=1?\n         BE    PRACB51J                yes, do not count PLHs\n         STRING '0  RPL',(STRNO,FL1,L),' AT LOCATION ',((R4),,X),3X,   X\n               ((R1),5,T),',OPTCD=(',INTO=LINE121\n*\n*        display OPTCD\n*\nPRACB51J BAS   R1,PRACB51A             BR AROUND TABLE\n         DC    C'LOC',AL1(RPLLOC)      80 00\n         DC    C'DIR',AL1(RPLDIR)      40 00\n         DC    C'SEQ',AL1(RPLSEQ)      20 00\n         DC    C'SKP',AL1(RPLSKP)      10 00\n         DC    C'KGE',AL1(RPLKGE)      04 00\n         DC    C'GEN',AL1(RPLGEN)      02 00\nPRACB51A TM    RPLOPT1,*-*\n*loop\nPRACB51B IC    R14,3(,R1)              MASK\n         EX    R14,PRACB51A\n         BZ    PRACB51C\n         STRING (LINE,,T),((R1),3,T),',',INTO=LINE\nPRACB51C LA    R1,3+1(,R1)             NEXT ENTRY\n         CLI   0(R1),C'A'              end of table?\n         BNL   PRACB51B                not yet, loop more\n*endloop\n         BAS   R1,PRACB52A             BR AROUND TABLE\n         DC    C'KEY',AL1(RPLKEY)      00 80\n         DC    C'ADR',AL1(RPLADR)      00 40\n         DC    C'CNV',AL1(RPLCNV)      00 20\n         DC    C'BWD',AL1(RPLBWD)      00 10\n         DC    C'UPD',AL1(RPLUPD)      00 02\n         DC    C'NSP',AL1(RPLNSP)      00 01\nPRACB52A TM    RPLOPT2,*-*\n*loop\nPRACB52B IC    R14,3(,R1)              MASK\n         EX    R14,PRACB52A\n         BZ    PRACB52C\n         STRING (LINE,,T),((R1),3,T),',',INTO=LINE\nPRACB52C LA    R1,3+1(,R1)             NEXT ENTRY\n         CLI   0(R1),C'A'              end of table?\n         BNL   PRACB52B                not yet, loop more\n*endloop\n         LA    R15,LINE-1(R15)         last comma\n         MVI   0(R15),C')'             close sub-list\n         OC    RPLFDBK,RPLFDBK         any error?\n         BZ    PRACB53                 no, jump\n         STRING (LINE,,T),',FDBK=',(RPLFDBK,,X),INTO=LINE\nPRACB53  BAL   R14,SPACE1          <== print RPL header\n*\n         SLR   R0,R0\n         IC    R0,RPLLEN               RPL LENGTH\n         LA    R1,IFGRPL               RPL address\n         BAL   R14,DUMP32          <== PRINT RPL\n*\n         CL    R6,RPLDACB              VALIDATE\n         BNE   PRACB99                 LOST, QUIT\n         L     R1,RPLARG               SEARCH ARGUMENT\n         C     R1,REGION24             VALIDATE\n         BL    PRACB60                 NONE FOUND, JUMP\n        #S0C4  PRACB60\n         CLI   0(R1),0                 VALIDATE SEARCH ARGUMENT\n         L     R14,$AMDSB_D            DATA AMDSB\n         LH    R0,AMDKEYLN-AMDSB(,R14) KEY LENGTH\n         MVI   MINLINES,5\n         STRING '0    SEARCH ARGUMENT:',INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\n         LTR   R0,R0                   IS THIS A KSDS?\n         BNZ   PRACB59                 YES, JUMP\n         LA    R0,004                  NO, ARG IS AN RBA\nPRACB59  BAL   R14,PDUMP           <== PRINT KEY\n         DROP  R4                      RPL\n*\n*        Print current record (from PLH)\n*\nPRACB60  MVI   MINLINES,6\n         LM    R2,R3,SAVPLHPT          restore A(PLHDR,PLH)\n         ICM   R0,B'1111',PLHLRECL     PICK UP RECORD LENGTH\n         BNP   PRACB68                 zero, quit\n         L     R1,PLHRECP              PICK UP RECORD ADDRESS\n         C     R1,REGION24             VALIDATE\n         BL    PRACB68                 LOST, QUIT\n        #S0C4  PRACB68\n         CLI   0(R1),0                 VALIDATE\n         STRING '0    CURRENT RECORD:',INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\n         BAL   R14,PDUMP           <== PRINT RECORD\n         B     PRACB69\nPRACB68  STRING '0    CURRENT RECORD IS NOT AVAILABLE',INTO=LINE121\n STRING (LINE121,,T),' R0=',((R0),,X),' R1=',((R1),,X),INTO=LINE121,   X\n               ' R2=',((R2),,X),' R3=',((R3),,X),' R4=',((R4),,X)\n         BAL   R14,SPACE1          <== Print line\n*\nPRACB69  LM    R2,R3,SAVPLHPT          restore A(PLHDR,PLH)\n*ORG PRACB69\n         ICM   R3,B'1111',PLHCHAIN     do we have another PLH?\n         BNZ   PRACB40                 yes, process it\n*endloop\n         DROP  R3                      IDAPLH\n         B     PRACB99\n*\n*        PRINT DCB IF THIS IS A JES ACB\n*\nPRACB70  SLR   R1,R1\n         ICM   R1,B'0111',DEBRRQ+1     DCB ADDRESS (JES)\n         BZ    PRACB71                 NO DCB, JUMP\n        #S0C4  PRACB71\n         CLC   ACBDEB,ACBDEB-IFGACB(R1) DOES THIS LOOK LIKE A DCB?\n         BNE   PRACB71                 NO, JUMP\n         CLC   ACBTIOT,ACBTIOT-IFGACB(R1) DOES THIS LOOK LIKE A DCB?\n         BNE   PRACB71                 NO, JUMP\n         LR    R6,R1                   PASS DCB ADDRESS\n         BAL   R14,PRDCB           <== PRINT DCB ALSO\n**       L     R7,DCBCICB              CICB\n**       USING CICB,R7\n         CL    R6,CURR_REC             CURRENT RECORD PRINTED ALREADY?\n         BE    PRACB99                 YES, QUIT\n         ICM   R6,B'0111',DEBDCBAD+1   RELOAD ACB ADDRESS (JES)\n*\n*        Retrieve current record: DEB->SDB->UBF->BFD\n*\nPRACB71 #S0C4  PRACB97\n         MVC   REASON,=C'001'          INPUT\n         TM    DEBOPATB,DEBXTEND       OPEN FOR EXTEND/OUTPUT?\n         BNO   PRACB97                 NO, QUIT\n         SLR   R7,R7\n         ICM   R7,B'0111',DEBIRBB      SDB (SUB-SYSTEM DATA SET BLOCK)\n         CLI   DEBIRBB,X'FF'           HJE7707?\n         BNE   *+8                     no, jump\n         SLL   R7,8-1                  yes, DEBIRBB contains bits 1-24\n         USING SDB,R7\n         MVC   REASON,=C'SDB'          SDB\n         CLC   =C'SDB ',SDBID          SDBID\n         BNE   PRACB97                 I'M LOST, QUIT\n        #S0C4  PRACB72N\n*        Offsets to SDBDEB,SDBUBF,BFDLOC,BFDDATA\n*        SDBDEB and SDBUBF are defined in SHASMAC($SDB)\n*        BFDLOC was defined in $BFD until HJE3313, then in $BUFFER\n*        BFDDATA was defined in $BFD until HJE3313;\n*        As of HJE7705, the offset to BFDDATA is the same as TPBUFST\n*        Test pgm in SCANMODL displays values for current JES2\n*        As of HJE7707, BFDDATA is defined again as BFDSTART.\n         BAL   R2,PRACB72              br around table\n         DC    X'007C,00B4,0018,0036'  XA 2.2\n         DC    X'0084,00E4,002C,0084'  ESA 420\n         DC    X'008C,00EC,002C,0088'  OS/390 R3\n         DC    X'008C,011C,002C,0088'  OS/390 R5   ????\n         DC    X'0094,0124,002C,0088'  OS/390 R10\n         DC    X'009C,0144,0064,0068'  z/OS R4     HJE7707\n*loop\nPRACB72  LH    R1,0(,R2)               SDBDEB-SDB\n         L     R1,SDB(R1)              SDBDEB\n         CLM   R1,B'0111',ACBDEB       SDBDEB\n         BNE   PRACB72N                NOT MY JES2, JUMP\n         LH    R1,2(,R2)               SDBUBF-SDB\n         L     R4,SDB(R1)              SDBUBF (BUFFER ADDRESS)\n         USING UBF,R4\n         CLC   =C'UBF ',UBFID          BFDID\n         BE    PRACB81                 This is my JES2, jump\nPRACB72N LA    R2,2+2+2+2(,R2)         next table entry\n         CLC   PRACB72,0(R2)           SDBDEB-SDB\n         BNE   PRACB72                 SCAN BUFFER\n*endloop\n         MVC   REASON,=C'UBF'          UBF\n*        As of HJE7707, JES2 no longer uses a UBF, only a PBF\n         B     PRACB97                 I'M LOST, QUIT\n*\n*        Scan JES2 unprotected buffer to retrieve the current record\n*\nPRACB81  MVC   REASON,=C'0C4'          S0C4 in UBF\n        #S0C4  PRACB97\n         LH    R1,4(,R2)               SDBLOC-UBF\n         L     R3,UBF(R1)              SDBLOC (CURR POS IN BUFFER)\n         LH    R1,6(,R2)               BFDDATA-UBF\n         LA    R0,UBF(R1)              BFDDATA\n         SLR   R1,R1\n         CR    R3,R0                   ANY RECORD YET?\n         BE    PRACB98                 NO, QUIT\n*LOOP\nPRACB81C LR    R2,R0                   Copy record address\n         USING LRC,R2\n         IC    R1,LRCTLENG             LENGTH OF TEXT\n         TM    LRCFLAG1,LRC1CCTL       CTLCHR PRESENT?\n         BNO   PRACB81N                NO, JUMP\n         LA    R1,1(,R1)               YES, ADD 1 TO LENGTH\nPRACB81N LA    R0,LRCTEXT(R1)          POINT PAST RECORD\n         CLR   R0,R3                   WAS THIS THE LAST RECORD?\n         BL    PRACB81C                NO, LOOP FURTHER\n*ENDLOOP\n         MVI   MINLINES,6\n         STRING '0    CURRENT RECORD:',INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\n         LR    R0,R1                   PASS LENGTH\n         LA    R1,LRCTEXT              PASS ADDRESS\n         BAL   R14,PDUMP           <== DUMP CURRENT RECORD\n         B     PRACB99                 NO, QUIT\n*\nPRACB97  EQU   *\n         STRING '0    CURRENT RECORD IS NOT AVAILABLE (',REASON,')',   X\n               INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\n         B     PRACB99                 NO, QUIT\n*\nPRACB98  STRING '0    NO RECORD WRITTEN YET.',INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\n*\nPRACB99  END_PROC\n         DROP  R4,R5,R6,R7             UBF, DEB, ACB, SDB\n*\n*----------------------------------------------------------------------\n*        SCAN JPAQ/LPAD TO FIND CALLER'S CDE\n*----------------------------------------------------------------------\n*\nCSVQRY00 BEGIN_PROC\n         STM   R6,R7,TENWORDS          SAVE R6, R7\n         N     R1,MASKADDR             CLEAN-UP ADDRESS\n         L     R5,PSATOLD-PSA(,0)      MY TCB\n         L     R5,TCBJSTCB-TCB(,R5)    JOB STEP TCB\n         ICM   R5,B'1111',TCBJPQ-TCB(R5)  FIRST CDE ON JPA QUEUE\n         BZ    CSVQRY20                EMPTY QUEUE, SKIP SEARCH\n         USING CDENTRY,R5\n*LOOP\nCSVQRY11 TM    CDATTR2,CDXLE           IS THERE AN EXTENT LIST?\n         BNO   CSVQRY12                NO, JUMP\n         TM    CDATTR,CDNIC            this module being loaded?\n         BO    CSVQRY12                yes, jump\n         L     R7,CDXLMJP              EXTENT LIST\n         USING XTLST,R7\n         C     R1,XTLMSBAD             WITHIN BOUNDARIES?\n         BL    CSVQRY12                NO, IGNORE\n         L     R15,XTLMSBLA            LENGTH OF LOAD MOD\n         LA    R15,0(,R15)             CLEAR HI-ORDER BIT\n         A     R15,XTLMSBAD            ADD LOAD POINT ADDRESS\n         CR    R1,R15                  WITHIN BOUNDARIES?\n         BL    CSVQRY75                YES, PROCESS\nCSVQRY12 ICM   R5,B'1111',CDCHAIN      NEXT CDE IN QUEUE\n         BNZ   CSVQRY11                GOOD ADDR, PROCESS\n*ENDLOOP\n*\n*        SCAN ACTIVE LPA QUEUE (MLPA/FLPA)\n*\nCSVQRY20 L     R5,CVTPTR(,0)\n         L     R5,CVTQLPAQ-CVTMAP(,R5) ACTIVE LPA QUEUE\n         ICM   R5,B'1111',0(R5)        FIRST CDE ON QUEUE\n         BZ    CSVQRY60                EMPTY QUEUE, SKIP SEARCH\n         USING CDENTRY,R5\n*LOOP\nCSVQRY21 TM    CDATTR2,CDXLE           IS THERE AN EXTENT LIST?\n         BNO   CSVQRY22                NO, JUMP\n         L     R7,CDXLMJP              EXTENT LIST\n         USING XTLST,R7\n         C     R1,XTLMSBAD             WITHIN BOUNDARIES?\n         BL    CSVQRY22                NO, IGNORE\n         L     R15,XTLMSBLA            LENGTH OF LOAD MOD\n         LA    R15,0(,R15)             CLEAR HI-ORDER BIT\n         A     R15,XTLMSBAD            ADD LOAD POINT ADDRESS\n         CR    R1,R15                  WITHIN BOUNDARIES?\n         BL    CSVQRY75                YES, PROCESS\nCSVQRY22 ICM   R5,B'1111',CDCHAIN      NEXT CDE IN QUEUE\n         BNZ   CSVQRY21                GOOD ADDR, PROCESS\n*ENDLOOP\n*\n*        SCAN LPA DIRECTORY IF MODULE NOT FOUND IN JPAQ\n*\nCSVQRY60 L     R6,CVTPTR(,0)\n         L     R6,CVTLPDIA-CVTMAP(,R6)\n         USING LPDE,R6\n*LOOP\nCSVQRY61 TM    LPDEATTR,LPDEMIN        MINOR LPDE?\n         BO    CSVQRY62                YES, JUMP\n         LM    R15,R0,LPDEXTLN         LENGTH/LOAD ADDR\n         CR    R0,R1\n         BH    CSVQRY62                OUTSIDE BOUNDARIES, JUMP\n         AR    R0,R15\n         CR    R0,R1\n         BH    CSVQRY71                MODULE FOUND, JUMP\nCSVQRY62 LA    R6,LPDEXTAD+4           BUMP LPDE ADDR\n         CLI   LPDENAME,FF             END OF LPA DIRECTORY?\n         BNE   CSVQRY61                NO, LOOP FURTHER\n*ENDLOOP\n         B     CSVQRY81                not found in LPA\n*\n*        found in LPAD\n*\nCSVQRY71 LR    R5,R6                   CDE=LPDE\n         S     R1,LPDEXTAD             GET OFFSET\n         MVC   EPNAME,LPDENAME         PASS EP NAME\n         B     CSVQRY85\n*\n*        found in JPAQ\n*\nCSVQRY75 S     R1,XTLMSBAD             GET OFFSET\n         MVC   EPNAME,CDNAME           PASS EP NAME\n         B     CSVQRY85\n         DROP  R5,R6,R7                CDE, LPDE, XTLST\n*\n*        look for a nucleus module\n*\nCSVQRY81 LR    R5,R1                   save address\n         LR    R0,R1                   pass address\n         NUCLKUP BYADDR,ADDR=(R0),NAME=EPNAME\n         LTR   R15,R15                 addr found in nucleus?\n         BNZ   CSVQRY95                no, quit\n         LR    R1,R5                   restore address\n         SLR   R1,R0                   GET OFFSET in R1\n*\nCSVQRY85 ST    R1,TENWORDS+12          STORE OFFSET\n         STRING '+X''',(TENWORDS+14,2,X),'''',INTO=OFFSET\n         CLI   TENWORDS+13,00\n         BE    CSVQRY88                OFFSET LT 64K, JUMP\n         STRING '+X''',(TENWORDS+13,3,X),'''',INTO=OFFSET\nCSVQRY88 STRING (EPNAME,,L),OFFSET,INTO=MSG20\n         B     CSVQRY99                QUIT\n*\n*        not found anywhere\n*\nCSVQRY95 SR    R5,R5\n         MVC   MSG20,BLANKS            NO PGM FOUND\n         MVC   EPNAME,=C'*UNKNOWN'     NO PGM FOUND\n*\nCSVQRY99 LM    R6,R7,TENWORDS          RESTORE R6, R7\n         END_PROC\n*\n*----------------------------------------------------------------------\n*        PRINT OBJECT INSTRUCTION IF X'44' OPCODE\n*----------------------------------------------------------------------\n*\nEXECUTE  BEGIN_PROC\n         CLI   SDWAILC1,4              ILC=4?\n         BNE   EXEC999                 NO, QUIT\n        #S0C4  EXEC999\n         CLI   0(R6),X'44'             IS THIS AN EXECUTE?\n         BNE   EXEC999                 NO, QUIT\n*\n         ICM   R0,B'0001',1(R6)        R1,RX\n         LA    R2,X'000F'              MASK FOR NR\n         NR    R2,R0                   R2=(RX)\n         BZ    EXEC12                  NO RX, JUMP\n         AR    R2,R2                   R*4\n         AR    R2,R2                   R*4\n         L     R2,SDWAGRSV(R2)         POINT TO RX SLOT\n*\nEXEC12   SR    R14,R14\n         ICM   R14,B'0011',2(R6)       D2(B2)\n         LA    R15,X'0FFF'             MASK FOR \"NR\"\n         NR    R15,R14                 R15=D2\n         SRL   R14,12                  R14=(B2)\n         AR    R14,R14                 R14*2\n         BZ    EXEC30                  B2=R0, JUMP\n         AR    R14,R14                 R14*4\n         AL    R2,SDWAGRSV(R14)        ADD VALUE(B2)\n*\nEXEC30   LA    R6,0(R15,R2)            ADD D2, CLEAN UP\n         N     R6,MASKADDR             CLEAN-UP ADDRESS\n         BAL   R14,PRINTI          <== PRINT INSTRUCTION (USES R6)\n         STRING '   EXECUTED INSTRUCTION AT LOCATION ',((R6),,X),      X\n               ' IS ',(MSG20,(R1)),INTO=LINE121\n         BAL   R14,SPACE1          <== Print line\nEXEC999  END_PROC\n*\n*----------------------------------------------------------------------\n*        PRINT INSTRUCTION\n*----------------------------------------------------------------------\n*\nPRINTI   BEGIN_PROC\n         STRING '**** **** ****',INTO=MSG20 INIT OUTPUT AREA\n         LA    R1,014                  MAX LENGTH\n        #S0C4  PRINTI9\n         MVC   WKCELL1(2),0(R6)        1ST HALFWORD\n         UNPK  MSG20+0(5),WKCELL1+0(3) CONVERT TO HEX\n         TR    MSG20+0(4),TABHEX-240   CONVERT TO HEX\n         LA    R1,004                  4 BYTES\n         CLI   0(R6),X'40'             TEST INSTRUCTION LENGTH\n         BL    PRINTI9                 OK, JUMP\n         MVC   WKCELL1(4),0(R6)        2 HALFWORDS\n         MVI   MSG20+4,C' '            CLEAN UP\n         UNPK  MSG20+5(5),WKCELL1+2(3) CONVERT TO HEX\n         TR    MSG20+5(4),TABHEX-240   CONVERT TO HEX\n         LA    R1,009                  9 BYTES\n         CLI   0(R6),X'C0'             TEST INSTRUCTION LENGTH\n         BL    PRINTI9                 OK, JUMP\n         MVC   WKCELL1(6),0(R6)        6 HALFWORDS\n         MVI   MSG20+9,C' '            CLEAN UP\n         UNPK  MSG20+10(5),WKCELL1+4(3) CONVERT TO HEX\n         TR    MSG20+10(4),TABHEX-240  CONVERT TO HEX\n         MVI   MSG20+14,C' '           CLEAN UP\n         LA    R1,014                  55 BYTES\nPRINTI9 #S0C4  RESET\n         END_PROC\n*\n*----------------------------------------------------------------------\n*\n*        PDUMP ROUTINE    R0=LENGTH,R1=ADDRESS\n*\n*+0000 00036800  C1C2C3C4 812653D8  00000000 00000000  *ABCDA  Q      *\n*+0010 00036810-0003685F same as above (X'0050' bytes)\n*+0060 00036860  00FD3BF0 00000000  078D2000 00C941A2  *   0          *\n*----------------------------------------------------------------------\n*\nPDUMP    BEGIN_PROC\n        #S0C4  PDUMP99,PUSH\n         STM   R0,R3,TENWORDS          KEEP LENGTH AND ADDRESS\n         LTR   R0,R0                   length=0?\n         BNP   PDUMP99                 yes, quit\n         MVI   LINE121,C'0'            CTLCHR\n         L     R3,TENWORDS             LENGTH\n         AL    R3,TENWORDS+4           LIMIT\n         BCTR  R3,0                    BXLE LIMIT\n*LOOP\nPDUMP4   LR    R0,R1                   GET ADDRESS\n         SL    R0,TENWORDS+4           MAKE OFFSET\n         STM   R0,R1,TENWORDS+12       OFFSET, ADDRESS\n         L     R2,TENWORDS             LENGTH\n         AL    R2,TENWORDS+4           1ST BYTE AFTER AREA\n         SR    R2,R1                   # OF REMAINING BYTES\n         BNP   PDUMP99                 FINISHED, QUIT\n*\n         MVC   MSG20,BLANKS            CLEAR WORK AREA\n         CH    R2,=H'16'\n         BL    *+8\n         LH    R2,=H'16'\n         LR    R14,R2                  PASS LENGTH FOR MVC\n         BCTR  R14,0                   FOR EX\n**      #S0C4  PDUMP99\n         EX    R14,*+4                 MOVE FIELD\n         MVC   MSG20(*-*),0(R1)        MOVE FIELD\n**      #S0C4  RESET\n         TR    MSG20,TRTPRINT\n*\n         LR    R0,R2                   PASS LENGTH\n         CH    R0,=H'12'\n         BH    PDUMP16                 SNAP 16 BYTES\n         CH    R0,=H'08'\n         BH    PDUMP12                 SNAP 12 BYTES\n         CH    R0,=H'04'\n         BH    PDUMP08                 SNAP  8 BYTES\nPDUMP04  STRING ((R1),(R0),X),INTO=(MSG60,36)\n         B     PDUMP33\nPDUMP08  SH    R0,=H'04'\n         STRING ((R1),4,X),1X,(4(R1),(R0),X),INTO=(MSG60,36)\n         B     PDUMP33\nPDUMP12  SH    R0,=H'08'\n         STRING ((R1),4,X),1X,(4(R1),4,X),2X,(8(R1),(R0),X),           X\n               INTO=(MSG60,36)\n         B     PDUMP33\nPDUMP16  SH    R0,=H'12'\n         STRING (0(R1),4,X),1X,(4(R1),4,X),2X,                         X\n               (8(R1),4,X),1X,(12(R1),(R0),X),INTO=(MSG60,36)\nPDUMP33  STRING '  +',(TENWORDS+12+2,2,X),1X,(TENWORDS+12+4,4,X),3X,   X\n               (MSG60,36),'   *',(MSG20,16),'*',                       X\n               INTO=LINE\n         BAL   R14,SPACE1L         <== print with lower-case\n*\n*        do not print lines with identical contents\n*\n         CH    R2,=H'16'               increment\n         BNE   PDUMP39                 no, jump\n         LA    R14,48(,R1)             48 bytes beyond current addr\n         CLR   R14,R3                  more than 48 bytes left?\n         BH    PDUMP39                 no, jump\n         CLC   16(32,R1),0(R1)         3 identical lines?\n         BNE   PDUMP39                 no, jump\n         LA    R0,16(,R1)              start of -SAME- area\n*--loop\nPDUMP37L CLC   16(16,R1),0(R1)         same contents?\n         BNE   PDUMP38                 yes, exit\n         ALR   R1,R2                   next line\n         LA    R14,32(,R1)             32 bytes beyond current addr\n         CLR   R14,R3                  more than 32 bytes left?\n         BNH   PDUMP37L\n*--endloop\nPDUMP38  LR    R14,R0                  first -SAME- line\n         SL    R14,TENWORDS+4          MAKE OFFSET\n         LR    R15,R1                  last -SAME line\n         ALR   R15,R2                  first non-SAME- line\n         SLR   R15,R0                  size of -SAME- area\n         STM   R14,R0,TENWORDS+12      offset, size, start\n         LA    R0,15(,R1)              last -SAME- byte\n         STRING '  +',(TENWORDS+12+2,2,X),1X,                          X\n               (TENWORDS+20,4,X),'-',((R0),,X),                        X\n               ' (X''',(TENWORDS+18,2,X),''' BYTES) SAME AS ABOVE',    X\n               INTO=LINE\n         BAL   R14,SPACE1          <== Print line\nPDUMP39  BXLE  R1,R2,PDUMP4\n*ENDLOOP\nPDUMP99  LM    R0,R3,TENWORDS          LENGTH/START ADDRESS\n        #S0C4  POP\n         END_PROC\n*\n*----------------------------------------------------------------------\n*        DUMP32 ROUTINE    R0=LENGTH,R1=ADDRESS\n*----------------------------------------------------------------------\n*\nDUMP32   BEGIN_PROC\n         LTR   R1,R1                   HI-ORDER BIT ON?\n         LA    R1,0(,R1)               CLEAN UP HI-BIT\n         STM   R0,R2,TENWORDS          KEEP LENGTH AND ADDRESS\n         BM    DUMP32A                 YES, NO DOUBLE SPACE\n         MVI   LINE121,C'0'            CTLCHR\n*LOOP\nDUMP32A  LR    R0,R1                   GET ADDRESS\n         SL    R0,TENWORDS+4           MAKE OFFSET\n         STM   R0,R1,TENWORDS+12       OFFSET, ADDRESS\n         L     R0,TENWORDS             LENGTH (R0)\n         AL    R0,TENWORDS+4           1ST BYTE AFTER AREA (add R1)\n         SR    R0,R1                   # OF REMAINING BYTES\n         BNP   DUMP32Z                 FINISHED, QUIT\n         STRING '   +',(TENWORDS+12+3,1,X),INTO=LINE\n         OC    TENWORDS(3),TENWORDS    offset > FF ?\n         BZ    DUMP32L                 no, jump\n         STRING '  +',(TENWORDS+12+2,2,X),INTO=LINE\nDUMP32L  LA    R2,LINE+8               FIRST WORD\n         BAL   R14,DUMP32X             00-03\n         BAL   R14,DUMP32X             04-07\n         BAL   R14,DUMP32X             08-11\n         BAL   R14,DUMP32X             12-15\n         LA    R2,1(,R2)               WIDE MARGIN IN THE MIDDLE\n         BAL   R14,DUMP32X             16-19\n         BAL   R14,DUMP32X             20-23\n         BAL   R14,DUMP32X             24-27\n         BAL   R14,DUMP32X             28-31\n         BAL   R14,SPACE1          <== Print line\n         LTR   R0,R0                   # OF REMAINING BYTES\n         BP    DUMP32A                 PRINT NEXT 32 BYTES\n*ENDLOOP\nDUMP32Z  LM    R0,R2,TENWORDS          LENGTH/START ADDRESS\n         END_PROC\n*\nDUMP32X  LTR   R0,R0                   # OF REMAINING BYTES\n         BNPR  R14                     FINISHED, QUIT\n         MVC   0(4,R2),0(R1)           PREVENT S0C4 IF R1=.....FFC\n         UNPK  0(9,R2),0(5,R2)         TRANSLATE TO HEX\n         TR    0(8,R2),TABHEX-240      TRANSLATE TO HEX\n         SH    R0,=H'4'                DECREMENT LENGTH\n         LA    R1,4(,R1)               PTR IN INPUT AREA\n         MVI   8(R2),C' '\n         LA    R2,9(,R2)               PTR IN OUTPUT LINE\n         BR    R14\nTABHEX   DC    C'0123456789ABCDEF'\n*\n*----------------------------------------------------------------------\n*        PRINT ROUTINE\n*----------------------------------------------------------------------\n*\nSPACE2   ST    R14,SPACE2RE            save R14\n         BAL   R14,SPACE1          <== print current line\n         L     R14,SPACE2RE            restore R14\n         B     SPACE1L                 print blank line\n*        print blank line\nBLANK1   MVC   LINE121,BLANKS          BLANK LINE\n         B     SPACE1L                 print blank line\n*        convert to caps\nSPACE1   TR    LINE,TRTPRINT           get rid of non-printable chars\n         OC    LINE,BLANKS             make it all caps\n*\nSPACE1L  BALR  R15,0\n         SAVE  (14,2),,SPACE1\n         CLC   MINLINES,RLINES         ENOUGH LINES LEFT?\n         BH    SPACE1D                 NO, JUMP\n         LA    R0,3                    COUNT LINES\n         CLI   LINE121,C'-'            COUNT LINES\n         BE    SPACE1B                 COUNT LINES\n         LA    R0,2                    COUNT LINES\n         CLI   LINE121,C'0'            COUNT LINES\n         BE    SPACE1B                 COUNT LINES\n         LA    R0,1                    COUNT LINES\nSPACE1B  SR    R1,R1\n         ICM   R1,1,RLINES             ANY LINES LEFT?\n         BZ    SPACE1D                 NO, JUMP\n         SR    R1,R0                   DECREMENT LINE COUNT\n         BNM   SPACE1K                 NOT END-OF-PAGE YET, JUMP\nSPACE1D  MVI   LINE121,C'1'            NEW PAGE\n         LA    R1,060-1                RESET LINE COUNTER\n         CLC   LINE,BLANKS             BLANK LINE?\n         BNE   SPACE1K                 NO, JUMP\n         MVI   LINE121,C'+'            YES, KEEP IT\n         SR    R1,R1                   RESET LINE COUNTER\nSPACE1K  STCM  R1,1,RLINES             NUMBER OF REMAINING LINES\n         MVI   MINLINES,0              RESET MINLINES\n*\n         ST    R13,DYNAM24+4           OLD SAVE AREA (DYNAM31)\n         LA    R13,DYNAM24             NEW SAVE AREA (DYNAM24)\n         PUT   DCBDEBUG,LINE121        ISSUE PUT WITH AMODE24\n         MVC   LINE121,BLANKS          BLANK OUT\n         L     R13,4(,R13)             OLD SAVE AREA (DYNAM31)\n         RETURN (14,2)\n         DROP\n*\n*----------------------------------------------------------------------\n*        RECOVERY ROUTINE FOR TRAPPING MY OWN ABENDS\n*----------------------------------------------------------------------\n*\n         CNOP  0,8\n         DC    C'RETRY00'              EYE CATCHER\nRETRY00  LA    R15,012                 R0 VALUE FOR 'NO SDWA ALLOCATED'\n         CLR   R0,R15                  SDWA ALLOCATED?\n         BALR  R15,0                   LOCAL BASE\n         BNE   RETRY04-*(,R15)         YES, JUMP\n         SR    R15,R15                 SET RC=0 (IF R0=12)\n         BR    R14                     RETURN TO EXIT PROLOG\n*\nRETRY04  BALR  R15,0                   LOCAL BASE\n         SAVE  (14,12),,RETRY04        SAVE REGS\n         BALR  R7,0\n         USING *,R7\nRETRY11  LR    R8,R1                   SAVE ADDR OF SDWA\n         USING SDWA,R8\n         L     R4,SDWAPARM             =A(DYNAM31)\n         USING DYNAM31,R4\n         CLI   #RETRY,0                ANY RETRY ADDRESS?\n         BE    RETRY70                 NO, JUMP\n*\nRETRY40  CLC   =X'0C4000',SDWACMPC     S0C4 ABEND?\n         BNE   RETRY70                 NO, IGNORE\n         CL    R7,SDWANXT1             RETRY11 > ABEND ?\n         BH    RETRY70                 YES, IGNORE\n         SLR   R10,R10\n         ICM   R10,B'0011',#RETRY      GET 16-BIT OFFSET\n         ALR   R10,R7                  CHANGE OFFSET TO ADDRESS\n         CL    R10,SDWANXT1            RETRY < ABEND ?\n         BL    RETRY70                 YES, IGNORE\n         NI    SDWACMPF,255-SDWAREQ    NO DUMP\n         B     RETRY77\n*\nRETRY70  LA    R10,RETRY99             RETRY ADDRESS\n         WTO   '==> DEBUGGING ROUTINE ABENDED <==',ROUTCDE=11\n         MVC   SDWAGR13,DYNAM31+4      RTM SAVE AREA\n*\nRETRY77  MVC   SDWASRSV,SDWAGRSV       MOVE REGISTERS\n         MVI   #RETRY,0                RESET RETRY ADDRESS\n         SETRP WKAREA=(R8),                                            X\n               RETADDR=(R10),RC=4,    <== RETRY                        X\n               FRESDWA=YES,RETREGS=YES\nRETRY99  RETURN (14,12)                GOBACK TO RTM\n*---------------------------------------------------------------------*\n*        BEGIN_PROC bootstrap                                         *\n*---------------------------------------------------------------------*\nBEGIN_PROC AH  R15,0(,R15)             add offset to far routine\n         BR    R15                     branch to far routine\n***********************************************************************\n         MACRO\n&NAME    TABLE &FN\n&I       SETA  2\n&J       SETA  &FN\n&NAME2   SETC  '&NAME'\n.LOOP    AIF   (T'&SYSLIST(&I) EQ 'O').NEXT\n         AIF   ('&SYSLIST(&I)'(1,1) EQ '''').HH\n&K       SETA  K'&SYSLIST(&I)\n&NAME2   DC    AL1(&J,&K),C'&SYSLIST(&I)'\n.HH      AIF   ('&SYSLIST(&I)'(1,1) NE '''').NEXT\n&K       SETA  K'&SYSLIST(&I)-2\n&NAME2   DC    AL1(&J,&K),C&SYSLIST(&I)\n.NEXT    ANOP\n&NAME2   SETC  ''\n&I       SETA  &I+1\n&J       SETA  &J+1\n         AIF   (&I LE N'&SYSLIST).LOOP\n         MEND\n***********************************************************************\nTABLES   LOCTR\nSVCTABLE TABLE 0,EXCP,WAIT,POST,EXIT,GETMAIN,FREEMAIN,LINK,XCTL,       X\n               LOAD,DELETE,GETMAIN/FREEMAIN,TIME,SYNCH,ABEND,SPIE,     X\n               ERREXCP,PURGE,RESTORE,BLDL/FIND,OPEN,CLOSE,STOW,        X\n               'OPEN TYPE=J','CLOSE TYPE=T',DEVTYPE,TRKBAL,            X\n               LOCATE/CATALOG,OBTAIN,CVOL,SCRATCH,RENAME,FEOV,REALLOC, X\n               IOHALT,MGCR/QEDIT,WTO/WTOL,WTL,SEGLD/SEGWT,,LABEL,      X\n               EXTRACT,IDENTIFY,ATTACH,CIRB,CHAP,OVLYBRCH,TTIMER,      X\n               STIMER,DEQ,,,SNAP/SDUMP,RESTART,RELEX,DISABLE,EOV,      X\n               ENQ/RESERVE,FREEDBUF,RELBUF/REQBUF,OLTEP,STAE/ESTAE,    X\n               IKJEGS6A,DETACH,CHKPT,RDJFCB,,BTAMTEST,,                X\n               SYNADAF/SYNADRLS,BSP,GSERV\n         TABLE 79,STATUS,,SETPRT,,SMFWTM,GRAPHICS,DDRSWAP,ATLAS,DOM\n         TABLE 91,VOLSTAT,TCBEXCP,TGET/TPUT,STCC,SYSEVENT,STAX,        X\n               'TSO TEST',PROTECT,DYNALLOC,IKJEFFIB,,,XLATE,,IMGLIB,,  X\n               MODESET,,'TYPE 3 ESR',DSTATUS,HASPSSSM,PGRLSE,PGFIX,    X\n               EXCPVR,,'TYPE 1 ESR',DEBCHK,,TESTAUTH,                  X\n               GETMAIN/FREEMAIN,VSAM,'TYPE 2 ESR',PURGEDEQ,,EVENTS\n         TABLE 130,RACHECK,RACINIT,RACLIST,RACDEF\n         TABLE 138,PGSER,CVAF,,,,CIPHER\n         DC    X'FF',0D'0'             END OF TABLE\nPCKTABLE TABLE 1,OPERATION,'PRIVILEGED OPERATION',EXECUTE,             X\n               PROTECTION,ADDRESSING,SPECIFICATION,DATA,               X\n               'FIXED-PT OVERFLOW','FIXED-PT DIVIDE',                  X\n               'DECIMAL OVERFLOW','DECIMAL DIVIDE',                    X\n               'EXPONENT OVERFLOW','EXPONENT UNDERFLOW',               X\n               SIGNIFICANCE,'FLOATING-PT DIVIDE',                      X\n               'SEGMENT TRANSLATION','PAGE TRANSLATION',               X\n               'TRANSLATION SPECIFICATION','SPECIAL OPERATION'\n         DC    X'FF',0D'0'             END OF TABLE\nFF       EQU   X'FF'\n*----------------------------------------------------------------------\n*        DYNAMIC STORAGE\n*----------------------------------------------------------------------\nDYNAM31  LOCTR                     <== R13\n         DS    18F                     SAVE AREA\nTENWORDS DS    10F                     WORK\nWKCELL1  DS    D                       WORK CELL\nWKCELL2  DS    D                       WORK CELL\nWKCELL3  DS    D                       WORK CELL\nREGION24 DS    A,A                     START/END OF 24-BIT REGION\nREGION31 DS    A,A                     START/END OF 31-BIT REGION\nDYN_TCB  DS    A(TCB)                  TCB FOR FREEMAIN\nDYNAM24P DS    A(DYNAM24)              24-BIT WORK AREA\nSPACE2RE DS    A(R14)                  save area for R14\nESTAEL   ESTAE MF=L\nMASKADDR DS    A(X'7FFFFFFF')          MASK FOR CLEANING UP ADDRESSES\nLASTPRB  DS    A(RBPREFIX)             ADDR OF LAST PRB\nFRSTSVRB DS    A(RBPREFIX)             ADDR OF FIRST SVRB\nABNDSVRB DS    A(RBPREFIX)             ADDR OF ABEND SVRB\nMY_PRB   DS    A(RBPREFIX)             MY OWN RBPREFIX\nCURR_R13 DS    A(R13)                  R13 at time of abend\nBUFFER   DS    A                       START OF CURRENT BUFFER\nCURR_REC DS    A(IHADCB)               CURRENT RCD PRINTED FOR THIS DCB\nPREV_REC DS    A(IHADCB)               previous record\nOPNLRECL DS    F                       LRECL from DEBLRECL/DCBLRECL\nOPNBLKSI DS    F                       BLKSIZE from DEBBLKSI/DCBBLKSI\nREGS     DS    16F\nIEFEB4UV DS    V(IEFEB4UV)             IEFEB4UV\nBLDLWORK DS    0F,AL2(1,L'CSVDWORK)    prefix for BLDL\n         IHAPDS DSECT=NO,PDSBLDL=YES   PDS Directory\n*ASSB\n*ASSBDLCB\n*DLCB\n*DLCBLLT@\n*EPNM\n*LLTDSN\n*MODTOKEN\n*PDATA\n*PDATA_DDN\n*PDATA_TTRN\n*PID\n*WORK44\nCSVDWORK EQU   BLDLWORK,*-BLDLWORK     Work area for CSVDSN routine\nSWAREQL1 SWAREQ MF=L\n         CSVQUERY MF=(L,CSVQRYWK),PLISTVER=2\nENQLIST  ENQ   (ENQNAMES,ENQNAMES,E,,STEP),MF=L\nENQLISTL EQU   *-ENQLIST\nSAVPLHPT DS    A(IDAPLHDR,IDAPLH)      save area\n$DSAB    DS    A(DSAB)                 set by VALDCB\n$JFCB    DS    A(INFMJFCB)             set by VALDCB\n$SIOT    DS    A(INDMSIOT)             set by VALDCB\n$TIOT    DS    A(TIOENTRY)             set by VALDCB\n$DCB     DS    A(IHADCB)\n$ACB     DS    A(IFGACB)\n$AMBL    DS    A(AMBL)\n$AMB_D   DS    A(AMB)\n$AMB_I   DS    A(AMB)\n$AMDSB_D DS    A(AMDSB)\n$AMDSB_I DS    A(AMDSB)\n$PLHDR   DS    A(IDAPLHDR)\n$RPL     DS    A(IFGRPL)\n$RTM2WA  DS    A(RTM2WA)               set by NEXTRB\n#RETRY   DS    H,H                     OFFSET TO RETRY ADDRESS\nSPLEVEL  DS    X                       MVS/SP LEVEL: 1, 2, 3, 4\nRLINES   DS    FL1'60'                 LINE COUNT\nMINLINES DS    FL1'01'                 MINIMUM NUMBER OF LINES\nSTRNO    DS    FL1                     string number (PLH/RPL)\nDDNAME   DS    C'SYSPRINT'             SAVED DDNAME\nDDNAME2  DS    C'SYSPRINT+002'         SAVED DDNAME\nABCODE   DS    C'ABEND=S013-18'        ABEND CODE\nXDSORG   DS    C'PS'                   DATA SET ORG\nXMACRF   DS    C'(GMC,PLC)'            DCBMACRF\nXRECFM   DS    C'UTBSAM'               RECORD FORMAT\nREASON   DS    C'SDB'                  reason code\nOCE_CODE DS    C                       O/C/E CODE\nORIGIN2  DS    C'  (HSA)'              ORIGIN OF PSW2\nEPNAME   DS    CL8                     EP NAME\nOFFSET   DS    C'+X''123456'''         OFFSET FROM LOAD POINT\nVIACALL  DS    C'SYNCH'                CALL/LINK/SYNCH\nMSG20    DS    CL20\nMSG60    DS    CL60\nVOLSER   DS    CL6\nSTATUS   DS    C'OLD'\nUCB_NAME DS    C'1234'                 4-character device number (ESA4)\nWORK44   DS    CL44\nEYECATCH DS    CL120\nTRTPRINT DS    XL256\nBLANKS   DS    CL121                   LOTS OF BLANKS\nUNITNAME DS    CL8,XL4,XL4             IEFEB4UV\nTITLE121 DS    CL121                   TITLE LINE\nX00      EQU   16,1                    X'00'\nSTACK128 DS    128A\nSAVER012 DS    16F                     save area for R0=12 entry\n*\nPDATA    DS    XL16\nPDATA_DDN EQU PDATA+8,8,C'C'           DDNAME\nPDATA_TTRN EQU PDATA+4,4,C'X'          TTRN\nPID      DS    XL4\nMODTOKEN DS    XL8\nPDATA_DSN DS   CL44\n*\n         DS    0D\nD31SDWA  DS    XL1000                  copy of RTM2's SDWA\nDYN31FAR LOCTR\n         DS    (DYNAM31+4096-*)C       MAKE IT A FULL PAGE\nDYNAM31L EQU   *-DYNAM31\n*\n*        24-BIT WORKING STORAGE        <-- R12\n*\nDYNAM24  DSECT\n         DS    18F                     SAVE AREA\nOPENLIST OPEN  (DCBDEBUG,OUTPUT),MF=L\nDCBDEBUG DCB   DSORG=PS,MACRF=PM,DDNAME=SYSDEBUG\nLINE121  DS    CL121                   PRINT LINE (control character)\nLINE     EQU   LINE121+1,L'LINE121-1   PRINT LINE\n         DS    0D                      align place-holder for freemain\nDYNAM24H DS    CL(DYNAM24+16384-*)     PLACE HOLDER\nDYNAM24L EQU   *-DYNAM24\n         STRING (GENERATE,,LOCTR)\n***********************************************************************\n         PRINT NOGEN\nPRINT    OPSYN ANOP\n         IHAPSA DSECT=YES              PREFIXED STORAGE AREA\n         CVT   PREFIX=YES,DSECT=YES,LIST=NO\n*@@@     IHALLT DSECT=YES              LNKLST/LPALST tables\nLLT      DSECT\nLLTLLT   DS    C'LLT '                 BLOCK ACRONYM\nLLTNO    DS    F                       NUMBER OF ENTRIES\nLLTENTRY DS    0CL45                   DSNAME ENTRY\nLLTDSNL  DS    FL1                     DSNAME LENGTH AFTER TRUNCATION\nLLTDSN   DS    CL44                    DATA SET NAME\nLLTNEXT  EQU   *                       NEXT ENTRY\n         CSVDLCB TITLE=NO              Dynamic Link-List\n         IHAASCB DSECT=YES             ADDRESS SPACE CONTROL BLOCK\n         IHAASSB LIST=NO               Address Space Secondary Block\n         IHAASXB DSECT=YES             ADDRESS SPACE EXTENSION BLOCK\n         IHAACEE                       Accessor Environment Element\n         IHALDA                        Local Data Area\nCSCB     DSECT\n         IEECHAIN                      COMMAND SCHEDULER CONTROL BLOCK\n         IKJTCB DSECT=YES              TASK CONTROL BLOCK\n         IHASTCB                       Secondary TCB\n         IKJRB  DSECT=YES              REQUEST BLOCK\n         IHACDE                        CONTENTS DIRECTORY ENTRY\n         IHALLE                        LOAD-LIST ELEMENT\n         IHAXTLST                      EXTENT LIST\n         IEFTCT                        SMF TCT\n         IEFTIOT1                      TASK INPUT-OUTPUT TABLE\n******** IEFZB4D5\nDSABQDB  DSECT                         DSAB QUEUE DESCRIPTOR BLOCK\nDSQDBID  DS    C'DSAB'                 ACRONYM\nDSQATTRS DS    XL2                     ATTRIBUTES\nDSQQDBLN DS    H'32'                   QDB LENGTH\nDSQNELMS DS    F                       NUMBER OF ELEMENTS ON QUEUE\nDSQFRSTP DS    A(DSAB)                 FIRST DSAB\nDSQLASTP DS    A(DSAB)                 LAST DSAB\n         IHADSAB                       DATA SET ASSOCIATION BLOCK\nSIOT     DSECT\n         IEFASIOT                      STEP I/O TABLE\nJFCB     DSECT\n         IEFJFCBN                      JOB FILE CONTROL BLOCK\n         DCBD  DSORG=PS,DEVD=DA        IHADCB\n         AIF   (D'DCBDCBE).SMS33\nDCBDCBE  EQU   DCBRELAD                DCBE address\n.SMS33   ANOP\n         IHADCBE                       DFSMS/MVS DCB extension\n         AIF   (D'DCBESLBI).SMS44\nDCBESLBI EQU   X'20'                   z/OS R1\nDCBEBLKSI EQU  DCBE+28,4,C'F'          z/OS R1\n.SMS44   ANOP\n         IEZDEB                        DATA EXTENT BLOCK\n         AIF   (D'DEBXTEND).DEB34      HDZ11C0\nDEBXTEND EQU   X'0E'                   OPEN EXTEND\nDEBOTINX EQU   X'06'                   OUTINX\n.DEB34   ANOP\n         IHADECB DSECT=YES             READ/WRITE\n         IEZIOB  DSECT=YES             I/O BLOCK\n         IEFUCBOB LIST=NO,PREFIX=NO    UNIT CONTROL BLOCK\n         IEFJESCT                      JES VECTOR TABLE\n         IHASCB  DSECT=YES             STAE CONTROL BLOCK\n         IHASDWA DSECT=YES,VRAMAP=NO   SDWA DSECT\n*@@      IHARTM2A\nRTM2WA   DSECT\nRTM2ID   DS    C'RTM2'                 CB ID\nRTM2ADDR DS    A(RTM2WA)               Address\nRTM2SPID DS    AL1(255)                sub-pool\nRTM2LGTH DS    FL3'972'                length\nRTM2CVT  DS    V(CVT)                  CVT addr\nRTM2TCBC DS    V(TCB)                  TCB addr\nRTM2VRBC DS    V(RBBASIC)              SVRB addr\nRTM2ASC  DS    V(ASCB)                 addr of ASCB\nRTM2CODE DS    0XL4                    completion code\nRTM2CCF  DS    X                       flags\nRTM2CC   DS    XL3                     Completion code\nRTM2EREG DS    16F                     GPRs at time of abend\n         DS    7F\nRTM2EPSW DS    XL8                     EC PSW at time of error\nRTM2AEC1 DS    XL8                     Additional EC mode information\n         DS    10F\nRTM2FLGS DS   0BL4                     Error Flags\nRTM2ERRA DS    B                       Error type causing entry to RTM2\nRTM2PCHK  EQU  X'40'                   Program Check\nRTM2ABTM  EQU  X'08'                   ABTERM (SVC 13)\n         DS    45F\nRTM2PREV DS    A                       Previous RTM2WA\nRTM2SDW2 EQU   RTM2WA+X'3DC',4,C'A'    RTM2's SDWA\n         IRAOUCB DSECT=YES             OUCB DSECT\n         IHALPDE                       LPDE DSECT\n         IHARD                         REGION DESCRIPTOR\nIFGACBVS OPSYN  ANOP\n         IFGACB DSECT=YES              ACB DSECT\nIFGRPLVS OPSYN  ANOP\n         IFGRPL DSECT=YES              RPL DSECT\n         IEFZB505 LOCEPAX=YES          EPA MAPPING FOR SWAREQ\nJCT      DSECT                         <--  JSCBJCT, LCTJCTAD\n         DS    F,A,F,C'JCT '           PREFIX\nJCTEQREG EQU   *+92,2,C'H'             REGION IN K (MAX VALUE IS 16383)\n         IEFAJCTB                      JOB Control Table\n         AIF   (D'JCTSWAUP).JCT2\nJCTSISO  EQU   2                       JCTSTAT2, NEW WITH DFP 2.3\nJCTSWAUP EQU   1                       JCTSTAT2, NEW WITH DFP 2.3\n.JCT2    ANOP\n         AIF   (D'JCTJMRTL).JCT3\nJCTJMRTL EQU   INJMJCT+X'8C',3,C'F'    TIME limit (XA,ESA313)\n.JCT3    ANOP\nJCTX     DSECT                         <--  JCTJCTX\n         DS    F,A,F,C'JCTX'           PREFIX\n         IEFJCTX                       JCT Extension\n         AIF   (D'JCTXJMRD).JCTX3\nJCTXSSD  EQU   JCTXIN+X'58',4,C'P'     step start date  (HBB4430)\nJCTXJMRD EQU   JCTXIN+X'5C',4,C'P'     job start date  (HBB4430)\n         AIF   (D'JCTXJTL).JCTX3\nJCTXJTL  EQU   JCTXIN+X'3C',4,C'F'     TIME limit (ESA410)\n.JCTX3   ANOP\nSCT      DSECT                         Step Control Table\n         DS    XL16                    PREFIX\n         IEFASCTB                      SCT\n         AIF   (D'SCTSTIME).SCT2\nSCTSTIME EQU   SCT+X'15',3,C'F'        step time limit (XA/ESA31)\n.SCT2    ANOP\nSCTX     DSECT                         Step Control Table Extension\n         DS    XL16                    PREFIX\n         IEFSCTX DSECT=NO              SYS1.MODGEN\n         IEZJSCB                       JSCB\n         IEFJSSIB                      Sub-System Identification Block\n*@@      IGGICQE                       INTERRUPT CONTROL QUEUE ELEMENT\nICQE     DSECT                         INTERRUPT CONTROL QUEUE ELEMENT\nICQECB   DS    F                       ECB POINTED TO BY IOB IN SAMB\nICQIOBAD DS    A(IOB)                  ADDRESS OF IOB IN SAMB\nICQFIRST DS    A(IOB)                  FIRST USER IOB\nICQFLG   DS    X                       FLAG BYTE\nICQEXND  EQU   X'80'                   EXCPVR PROCESSING NEEDED\nICQENDAD DS    AL3(IOB)                LAST USER IOB\nICQFSTQ  DS    A(IOB)                  FIRST USER IOB IN QUEUE\nICQMAXQ  DS    FL1                     MAX NUMBER OF IOBS ON QUEUE\nICQNOQ   DS    FL1                     CURRENT NUMBER OF IOBS ON QUEUE\nICQSAVQ  DS    X,X                     SAVE AREA FOR ICQMAXQ (EOV)\nICQSAVCT DS    C'MBBCCHHR'             SAVE AREA FOR MBBCCHHR\nICQSAV   DS    18F                     SAVE AREA FOR EOB PROCESSING\n*@@      VSAM MACROS\nAMBL     DSECT\n         DS    2F\nAMBLACB  DS    V(IFGACB)               ADDRESS OF THE ACB\n         DS    1F\nAMBLDDNM DS    0CL8                    THE ACB'S DDNAME\nAMBLCACB DS    A,XL3                   CATALOG ACB ADDR, CI NO\nAMBLQ    DS    X                       QUALIFIER\nAMBLDDC  EQU   X'80'                   DD CONNECT ONLY\nAMBLGSR  EQU   X'40'                   GLOBAL SHARED RESOURCES\nAMBLLSR  EQU   X'20'                   LOCAL SHARED RESOURCES\nAMBLFSTP EQU   X'10'                   FAST PATH\nAMBLUBF  EQU   X'08'                   USER BUFFERING\nAMBLKSDS EQU   X'04'                   KEY-SEQUENCED DATA SET\nAMBLESDS EQU   X'02'                   ENTRY-SEQUENCED DATA SET\nAMBLDFR  EQU   X'01'                   DEFERRED WRITES\n         DS    F,H                     XPT,LVC\nAMBLTYPE DS    X                       TYPE OF CB ATRUCTURE OPENED\nAMBLPATH EQU   X'80'                   PATH\nAMBLUPGR EQU   X'40'                   UPGRADE SET\nAMBLAIX  EQU   X'20'                   ALTERNATE INDEX\nAMBLBASE EQU   X'10'                   BASE CLUSTER\nAMBLQ2   DS    X                       QUALIFIED EXTENSION\nAMBLSHR  EQU   X'20'                   SHR(3) OR SHR(4)\nAMBLCRE8 EQU   X'10'                   CREATE MODE\nAMBLID   DS    X'50'                   ID\nAMBLSHAR DS    X                       Sharing indicators\nAMBLPRIM EQU   X'80'                   Primary AMBL\nAMBLWRIT EQU   X'20'                   OUTPUT or UPDATE mode\nAMBLLEN  DS    FL1'80'                 Length of the AMBL\nAMBLFLG1 DS    X,X                     FLG1, FLG2\nAMBLDUMY EQU   X'01'                   DD DUMMY\nAMBLNST  DS    FL1                     STRNO\n         DS    H,A,A,F                 LNUM, MMIB, DSAB, SMFT\nAMBLDTA  DS    A(AMB)                  DATA'S AMB\nAMBLIX   DS    A(AMB)                  INDEX'S AMB\nAMBLBIB  DS    V(BIB)                  BASE INFORMATION BLOCK\nAMBLCMB  DS    V(CMB)                  CLUSTER MANAGEMENT BLOCK\n*\nAMB      DSECT\nAMBID    DS    X'40',X,H,A             ID, TS, LEN, LINK\nAMBBUFC  DS    A(BUFC)                 ADDRESS OF BUFC HEADER\nAMBPH    DS    A(IDAPLHDR)             ADDRESS OF THE PLH HEADER\nAMBCACB  DS    A(IFGACB)               ADDRESS OF THE ACB\nAMBDSB   DS    A(AMDSB)                DATA SET STATISTICS BLOCK\nAMBFLG0  DS    X                       FLAGS\nAMBLDS   EQU   X'04'                   Linear Data Set\nAMBFLG1  DS    X                       FLAGS\nAMBCREAT EQU   X'80'                   CREATE MODE\nAMBSPEED EQU   X'08'                   SPEED OPTION\nAMBDSORG DS    X'0008'                 DSORG\n         DS    A,XL3,AL3,H             IOB/IOMB, *, DDSN, *\nAMBTIOT  DS    AL2,X,X,V(TCB)          TIOT, INFL, AMETH, TCB\nAMBOFLGS DS    X,X,XL2                 OFLGS, FLG2\n         DS    XL(136-52)\nAMBDSNM  DS    CL44                    DATA SET NAME\n*\nBUFC     DSECT                         BUFC Header\nBUFCID   DS    X'70'                   ID\nBUFCBUFN DS    FL1                     BUFNI/BUFND\nBUFCLEN  DS    H'88'                   length of BUFC entry\n         DS    A,A,A,A                 more stuff\n*\nAMDSB    DSECT\nAMDSBID  DS    X'60'                   ID\nAMDATTR  DS    X                       ATTR\nAMDRRDS  EQU   X'02'                   RRDS\nAMDLEN   DS    H,H                     LEN, NEST\nAMDRKP   DS    H                       KEY OFFSET\nAMDKEYLN DS    H                       KEY LENGTH\n*\nIDAPLHDR DSECT\nPLHID    DS    X'30',X,H               PLH HEADER\nPLHCNT   DS    H                       COUNT OF PLH ENTRIES BEHIND HDR\nPLHDRREQ DS    H                       COUNT OF DEFERRED REQUESTS\nPLHDRMAX DS    H                       MAX NO OF PLH ENTRIES IN USE\nPLHDRCUR DS    H                       NO OF ACTIVE ENTRIES\nPLHIOSDQ DS    A                       DEFERRAL QUEUE HEADER\n*\nIDAPLH   DS    X'FF'              +016\nPLHIDENT DS    C'PLH'\n         DS    X,X,X,X,X,X,XL2         FLG0,1,2,3,4,5,EFLGS\n         DS    X,X,X,FL1               RCODE, RMIN, FRCNT, BFRNO\nPLHMRPL  DS    V(IFGRPL),0A            RPL HEADER, JRNAD\nPLHCRPL  DS    V(IFGRPL),A        +036 CURRENT RPL\nPLHCRBA  DS    A,A,A,X,X,X,X,A    +044 Current RBA\nPLHLRECL DS    F,A,A              +064 LENGTH OF RECORD\nPLHRECP  DS    A                  +076 ADDRESS OF CURRENT RECORD\n         DS    A,A,H,H,A,A,6F\nPLHACB   DS    V(IFGACB),X,3X     +124 ADDRESS OF THE ACB\nPLHCHAIN DS    A(IDAPLH)          +132 ADDRESS OF THE NEXT PLH\n         YREGS\n        $LRC                           HASP LOGICAL RECORD\nSDB      DSECT                         JES2\nSDBID    EQU   SDB+X'0048',4           \"SDB \"\nUBF      DSECT                         JES2\nUBFID    EQU   UBF,4                   \"UBF \"\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//*R10     DD DSN=SYS1.V2R10M0.SHASMAC,DISP=SHR (OR HASPSRC) $LRC\n//         DD DSN=SYS1.SHASMAC,DISP=SHR                      $LRC\n//         DD DSN=GILBERT.FILE183.PDS,DISP=SHR               STRING\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,5)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,2),DISP=(,PASS),BLKSIZE=3200\n//*\n//LKED    EXEC PGM=LINKEDIT,PARM='LIST,MAP,RENT,REFR'\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD *\n  ORDER SYSDEBUG(P)\n//         DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=GILBERT.FILE183.LOAD(SYSDEBUG),DISP=SHR\n//**********************************************************************\n//*                                                                    *\n//*       Simple test (no abend) - check XCTL function                 *\n//*                                                                    *\n//**********************************************************************\n//XCTL    EXEC PGM=SYSDEBUG,ACCT=IEFBR14\n//STEPLIB  DD DSN=GILBERT.FILE183.LOAD,DISP=SHR\n//SYSDEBUG DD SYSOUT=*\n//*YSUDUMP DD SYSOUT=*\n//**********************************************************************\n//*                                                                    *\n//*       Test Program - Abends with S0C3                              *\n//*                                                                    *\n//**********************************************************************\n//HLASM2 EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\nTESTDBUG CSECT\n         SAVE  (14,12),,*\n         BALR  R11,0\n         USING *,R11\n         LR    R14,R13\n         LA    R13,=9C'SAVEAREA'\n         ST    R14,4(,R13)\n         ST    R13,8(,R14)\n         LOAD  EP=SYSDEBUG\n         LR    R15,R0\n         BASSM R14,R15              <-- INITIALIZE DEBUGGING RTNE\n         ESPIE SET,*+2,(4)              check my ESPIE override is OK\n         OPEN  (STEPLIB,,SYSLIN,,ACB1,,                                X\n               SYSUT2,OUTPUT,SYSPRINT,OUTPUT,SYSPUNCH,EXTEND)\n         GET   SYSLIN                   FIRST RECORD\n         MVC   LINE121+1(80),0(R1)      copy record\n         PUT   SYSPRINT                 PUT Locate\n         MVC   0(L'LINE121,R1),LINE121  copy record to buffer\n         PUTX  SYSPUNCH,SYSLIN\n         READ  DECB1,SF,STEPLIB,WK256,256\n         CHECK DECB1\n         PUT   RPL=RPL1\n         CLOSE ACB1\n         OPEN  (DISKSUL,OUTPUT)\n         LH    R2,=H'5000'\nPUTSUL   PUT   DISKSUL,=AL2(21,0,1,2,3,4,5,6,7,8,9)\n         BCT   R2,PUTSUL\n         CLOSE DISKSUL\n         MODCB ACB=ACB1,STRNO=2\n         OPEN  (ACB1,,DISKSUL)\n         GET   DISKSUL\n         MVI   WK256,44\n         PUT   RPL=RPL1\nS80A     GETMAIN RC,LV=1024         <-- fill up private area below\n         LTR   R15,R15\n**       BZ    S80A\n         EX 0,*                     <-- CAUSES S0C3\nPUT2     PUT   SYSUT2               <-- CAUSES D37-04\n*MVI SYSUT2+40,255\n*EX 0,*\n         B     PUT2                 <-- CAUSES D37-04\nSTEPLIB  DCB   DSORG=PO,MACRF=R,DDNAME=STEPLIB\nSYSLIN   DCB   DSORG=PS,MACRF=GL,DDNAME=SYSLIN,DCBE=SYSLINX\nSYSLINX  DCBE\nACB1     ACB   DDNAME=VSAMDD,MACRF=(KEY,SEQ,OUT),STRNO=1\nRPL1     RPL   ACB=ACB1,OPTCD=KEY,AREA=WK256,AREALEN=256,RECLEN=100\nSYSPRINT DCB   DSORG=PS,MACRF=PL,DDNAME=SYSPRINT,RECFM=FBA,LRECL=121\nSYSPUNCH DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPUNCH,RECFM=F,LRECL=80\nSYSUT2   DCB   DSORG=PS,MACRF=PM,DDNAME=SYSUT2,RECFM=FB,LRECL=80\nDISKSUL  DCB   DSORG=PS,MACRF=(GL,PM),DDNAME=DISKSUL,RECFM=VB,LRECL=80\nLINE121  DC    CL121' '\nWK256    DS    256X\n         YREGS\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//GO      EXEC PGM=LOADER,PARM=NOPRINT\n//STEPLIB  DD DSN=GILBERT.FILE183.LOAD,DISP=SHR\n//SYSLIN   DD DSN=*.HLASM2.SYSLIN,DISP=(OLD,PASS)\n//$DMY     DD DUMMY\n//SYSUT2   DD UNIT=SYSALLDA,SPACE=(TRK,(1,,1)),\n// DSN=&&T2345678(M2345678)\n//DISKSUL  DD UNIT=VIO,SPACE=(CYL,1),LABEL=(,SUL),BLKSIZE=32760\n//*\n//VSAMDD   DD UNIT=SYSALLDA,SPACE=(TRK,10),\n//**          AMP='STRNO=1',\n//            STORCLAS=DEFAULT,\n//            RECORG=KS,LRECL=100,KEYLEN=12\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSPUNCH DD SYSOUT=*\n//SYSIN    DD *\n3333333\n//SYSDEBUG DD SYSOUT=*,OUTLIM=01111\n//SYSUDUMP DD SYSOUT=*,OUTLIM=22222\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYSMOVE": {"ttr": 22023, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//GILBERTM JOB (ACCT#),SYSMOVE,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n*PROCESS BATCH,USING(NOMAP,WARN(8))\n***********************************************************************\n*                                                                     *\n* MODULE NAME = SYSMOVE                                               *\n*                                                                     *\n* DESCRIPTIVE NAME = Unload a PDS in IEHMOVE format                   *\n*                                                                     *\n* FUNCTION = The SYSMOVE program unloads a PDS to a sequential        *\n*        data set in IEHMOVE format.  The resulting data set          *\n*        (which is DSORG=PS,RECFM=FB,LRECL=80) can be written to      *\n*        disk or tape, and later used as input to IEHMOVE to          *\n*        reload the original PDS.                                     *\n*                                                                     *\n* STATUS = R405                                                       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = STRING Macro                                      *\n*                                                                     *\n*    AUTHORIZATION = NONE                                             *\n*                                                                     *\n*    RESTRICTIONS = NONE                                              *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (BATCH PROGRAM)                            *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 4K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REUSABLE, RMODE 24, AMODE 24,                       *\n*                 PROBLEM STATE, KEY 8                                *\n*                                                                     *\n* OPERATION = See Below                                               *\n*                                                                     *\n*        Sample invocation JCL:                                       *\n*                                                                     *\n*            //UNLOAD EXEC PGM=SYSMOVE                                *\n*            //SYSPRINT DD SYSOUT=*                                   *\n*            //SYSUT1   DD DSN=INPUT.PDS,DISP=SHR                     *\n*            //SYSUT2   DD DSN=OUTPUT.FLAT,DISP=(,CATLG),             *\n*            // UNIT=SYSDA,SPACE=(TRK,(50,50),RLSE)                   *\n*                                                                     *\n*        Notes:                                                       *\n*                                                                     *\n*          1. SYSMOVE is fully compatible with SMS (which is not the  *\n*             case with IEHMOVE).                                     *\n*                                                                     *\n*          2. SYSMOVE imposes no restriction on the BLKSIZE of SYSUT2 *\n*             which can be any multiple of 80 you choose.  However,   *\n*             in order for IEHMOVE to reload it successfully, the     *\n*             BLKSIZE of the unloaded data set must be 800.           *\n*                                                                     *\n*          3. SYSMOVE does not support NOTE lists (as created by the  *\n*             linkage editor for load-modules in overlay format).     *\n*                                                                     *\n*          4. SYSMOVE can unload a full PDS or a single member.       *\n*             If you want to unload several PDS's and/or selected     *\n*             members, use the merge/selection capabilities of        *\n*             IEBCOPY to create a temporary PDS, then run SYSMOVE     *\n*             to unload it.                                           *\n*                                                                     *\n*          5. SYSMOVE is a convenient way to distribute a PDS         *\n*             via a network; see \"usage notes\", below.                *\n*                                                                     *\n*          6. SYSMOVE can be used recursively to distribute several   *\n*             PDSs as a single FB/80 file: unload each PDS with       *\n*             SYSMOVE into a temporary FB/80, unload the temporary    *\n*             PDS with SYSMOVE, and ship the resulting sequential     *\n*             data set.  The receiver can use IEBGENER to copy each   *\n*             member to a sequential data set and feed it to          *\n*             IEHMOVE to reload each of the initial PDSs.             *\n*                                                                     *\n*          7. unloaded PDS's in IEHMOVE format can be processed       *\n*             in CMS with the TAPEMAC and TAPPDS commands.            *\n*                                                                     *\n*                                                                     *\n* ABENDS:     U0013 OPEN Failed, probably because a DD is missing     *\n*                                                                     *\n* USAGE NOTES: See below                                              *\n*                                                                     *\n*    Using SYSMOVE to distribute a PDS on PC diskettes.               *\n*                                                                     *\n*        SYSMOVE provides a convenient way to distribute a PDS via    *\n*        PC diskette, using the following procedure:                  *\n*                                                                     *\n*          1. unload the PDS with SYSMOVE                             *\n*                                                                     *\n*          2. download the unloaded data set to a PC in EBCDIC        *\n*             using the \"RECEIVE\" command:                            *\n*                                                                     *\n*                 RECEIVE pc_file_name unloaded_data_set_name         *\n*                                                                     *\n*          3. pack the PC file with PKZIP (or equivalent)             *\n*                                                                     *\n*          4. copy the packed file to a diskette                      *\n*                                                                     *\n*          5. send the diskette out; whoever you send it to           *\n*             does not need SYSMOVE to process it.                    *\n*                                                                     *\n*       On the receiving MVS system, re-create the PDS as follows:    *\n*                                                                     *\n*          1. unpack the diskette file (if it's been packed)          *\n*                                                                     *\n*          2. upload the unpacked file in EBCDIC                      *\n*             using the \"SEND\" command:                               *\n*                                                                     *\n*                 SEND pc_file_name unloaded_data_set_name            *\n*                      recfm(fb) lrecl(80) blksize(800)               *\n*                                                                     *\n*          3. load the uploaded data set into a PDS                   *\n*             using IEHMOVE:                                          *\n*                                                                     *\n*             //RELOAD EXEC PGM=IEHMOVE,PARM='POWER=4',REGION=2M      *\n*             //SYSUT1 DD DISP=OLD,UNIT=SYSALLDA,VOL=SER=nonsms       *\n*             //DD1    DD DSN=GILBERT.UNLOAD,DISP=SHR   INPUT VOLUME  *\n*             //DD2    DD DISP=OLD,UNIT=SYSALLDA,VOL=SER=nonsms       *\n*             //SYSPRINT DD SYSOUT=*                                  *\n*                COPY      DSNAME=GILBERT.UNLOAD,                    X*\n*                          TO=3380=nonsms,                           X*\n*                          RENAME=GILBERT.MYPDS,                     X*\n*                          CATLG                                      *\n*                                                                     *\n*       NOTE:  You may NOT specify SMS-managed volumes for either     *\n*              SYSUT1 (work files) or the output volume (DD2 in       *\n*              this example).  IEHMOVE uses SVC 32 (REALLOC), not     *\n*              dynamic allocation, and SVC 32 does not support        *\n*              SMS-managed volumes.                                   *\n*                                                                     *\n*CHANGE ACTIVITY                                                      *\n*                                                                     *\n*401 Build DIRTABLE and process ALIAS entries like IEHMOVE:           *\n*        1. If an ALIAS has no corresponding member, turn off         *\n*           the ALIAS indicator in the directory entry                *\n*        2. Do not write the data pointed to by ALIAS entries,        *\n*           instead, write the directory entries immediately          *\n*           after the corresponding main member's data.               *\n*402 Print number of records and bytes written to SYSUT2              *\n*403 If a member name is specified on SYSUT1, unload only this member*\n*404 Change date format to yyyy-mm-dd                                 *\n*405 Zero last reference date in F1-DSCB                              *\n***********************************************************************\n&REL     SETC  '405'                   Current version/release\nSYSMOVE  CSECT\n         SAVE  (14,12),,'GSF Utilities - SYSMOVE R&REL'\n         LR    R12,R15\n         USING SYSMOVE,R12\n         GETMAIN R,LV=DYNAML           GET DYNAMIC STORAGE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LA    R14,72(,R1)             CLEAR WORKING STORAGE\n         LA    R15,DYNAML-72           CLEAR WORKING STORAGE\n         SLR   R1,R1                   CLEAR WORKING STORAGE\n         MVCL  R14,R0                  CLEAR WORKING STORAGE\n         LM    R13,R1,8(R13)\n         USING DYNAM,R13\n         L     R2,0(,R1)               point to PARM field\n*\n         OPEN  MF=(E,OPENLIST)         OPEN DATA SETS\n         LTR   R15,R15                 OPEN OK?\n         BZ    TITLE1                  YES, JUMP\n         ABEND 13,REASON=(15)       <- OPEN failed\n***********************************************************************\n*                                                                     *\n*        Print the Title Line on SYSPRINT                             *\n*                                                                     *\n***********************************************************************\nTITLE1   TIME  DEC                     get time, date\n         STM   R0,R1,DWD               R0=HHMMSSHH,R1=00YYDDDF\n         LH    R3,0(,R2)               parm length\n         STRING '1GSF Utilities - SYSMOVE R&REL  ',                    X\n               (DWD+4,P,YYYY-MM-DD),2X,      YYYY-MM-DD                X\n               (DWD+0,1,X),':',(DWD+1,1,X),  HH:MM                     X\n               '  PARM=''',(2(R2),(R3)),'''',                          X\n               INTO=LINE\n         PUT   SYSPRINT,LINE           print title line\n*\n         LA    R0,JFCB1                JFCB IN DYNAMIC STORAGE\n         STCM  R0,B'0111',EXL1+1       UPDATE EXIT LIST\n         RDJFCB SYSUT2                 READ THE JFCB (SYSUT2)\n         MVC   JFCB2,JFCB1             save the SYSUT2 JFCB\n*\n         RDJFCB MF=(E,OPENDIRL)        READ THE JFCB (SYSUT1)\n*\n*        Save the member name specified on the SYSUT1 DD\n*\n         MVI   UT1MBR,FF               no member\n         TM    JFCBIND1,JFCPDS         member name specified on sysut1?\n         BNO   PASS1                   no, jump\n         NI    JFCBIND1,FF-JFCPDS      NO MEMBER\n         MVC   UT1MBR,JFCBELNM         SAVE MEMBER NAME\n***********************************************************************\n*                                                                     *\n*        READ THE DIRECTORY                                           *\n*                                                                     *\n*           1. READ SYSUT1 DIRECTORY                                  *\n*           2. COUNT DIRECTORY ENTRIES                                *\n*           3. COUNT DIRECTORY BLOCKS AFTER LOGICAL END OF DIRECTORY  *\n*                                                                     *\n***********************************************************************\nPASS1    OPEN  MF=(E,OPENDIRL),TYPE=J  OPEN DIRECTORY\n         USING PDS2,R6\n*LOOP\nPASS1A   BAL   R9,GETDIR            <- GET DIRECTORY ENTRY\n         CLI   PDS2,FF                 LOGICAL END OF DIRECTORY?\n         BE    PASS1F                  YES, EXIT\n         AL    R0,DIRTABLE             tally directory entry sizes\n         ST    R0,DIRTABLE             tally directory entry sizes\n         TM    PDS2INDC,PDS2ALIS       is this an alias?\n         BO    PASS1AL                 yes, jump\n         LA    R0,1                    COUNT MEMBERS\n         AL    R0,MEMBERS              COUNT MEMBERS\n         ST    R0,MEMBERS              COUNT MEMBERS\n         B     PASS1A\nPASS1AL  LA    R0,1                    COUNT ALIASES\n         AL    R0,ALIASES              COUNT ALIASES\n         ST    R0,ALIASES              COUNT ALIASES\n         B     PASS1A\n*ENDLOOP\n*LOOP\nPASS1F   GET   SYSUT1D              <- READ NEXT DIRECTORY BLOCK\n         LTR   R1,R1                   PHYSICAL END OF DIRECTORY?\n         BZ    PASS1EOD                YES, EXIT\n         LA    R0,1                    COUNT DIRECTORY BLOCKS\n         AL    R0,DIRBLKS              COUNT DIRECTORY BLOCKS\n         ST    R0,DIRBLKS              COUNT DIRECTORY BLOCKS\n         B     PASS1F\n*ENDLOOP\nPASS1EOD CLOSE MF=(E,OPENDIRL)         CLOSE DIRECTORY\n***********************************************************************\n*                                                                     *\n*        WRITE HEADER RECORDS                                         *\n*                                                                     *\n*           1. read the JFCB and the F1-DSCB                          *\n*           2. calculate the data set size                            *\n*           3. write UNLOAD header records                            *\n*                                                                     *\n***********************************************************************\n         LA    R0,78                   LENGTH OF HEADER RECORD\n         LA    R1,HDR1REC              ADDR OF HEADER RECORD\n         BAL   R9,WRITE                WRITE FIRST RECORD\n         MVC   DS1DSNAM,JFCBDSNM       MOVE DSNAME\n         MVC   DS1DSSN,JFCBVOLS        MOVE VOLSER\n         OBTAIN CAML26                 READ F1-DSCB\n         DEVTYPE DCBDDNAM-IHADCB+SYSUT1D,DVAREA,DEVTAB\n*\n         MVC   UNLDDIR,DIRBLKS+2       NUMBER OF DIRECTORY BLOCKS\n         MVI   UNLDFLAG,X'40'          AVG BLK\n         SLR   R1,R1\n         ICM   R1,B'0011',DS1LSTAR     LAST TRACK USED\n         LA    R1,1(,R1)               NUMBER OF TRACKS USED\n         ST    R1,TRKSUSED             NUMBER OF TRACKS USED\n         SLR   R2,R2\n         ICM   R2,B'0011',DVATRKLN     TRACK LENGTH\n         MR    R0,R2                   TRACKS * TRKLN\n         STCM  R1,B'1111',UNLDSIZE     STORE RESULT\n*\n         XC    DS1REFD,DS1REFD         ZERO THE LAST REF DATE\n*\n         TM    DS1SCALO,X'80'          ALLOC IN CYLINDERS OR TRACKS?\n         BZ    HDR1DEVT                NO, SET SSIZ=0\n         SLR   R1,R1\n         ICM   R1,B'0111',DS1SCAL3     LOAD NO OF CYLS IN R1\n         TM    DS1SCALO,X'40'          AVERAGE LENGTH?\n         BZ    HDR1SQTY                NO, JUMP\n         MH    R1,DVATRK               MULTIPLY BY NO OF CYL PER TRK\nHDR1SQTY MR    R0,R2                   TRACKS * TRKLN\n         STCM  R1,B'1111',UNLDSSIZ     SECONDARY SPACE IN BYTES\n*\nHDR1DEVT MVC   UNLDDEVT,DVAUCBTY       UCB TYPE\n         LA    R0,HDR2LEN              LENGTH\n         LA    R1,HDR2REC              BACK END\n         BAL   R9,WRITE                WRITE RECORD SEGMENT\n***********************************************************************\n*                                                                     *\n*        Print Characteristics of SYSUT1 & SYSUT2                     *\n*                                                                     *\n*          INPUT PDS:                                                 *\n*            DSNAME=GILBERT.LOAD,VOL=3380=SYS157                      *\n*            RECFM=U,LRECL=0,BLKSIZE=32760                            *\n*            DIRECTORY_BLOCKS=11,MEMBERS=24,ALIASES=2                 *\n*            TRACKS_USED=22,EXTENTS_ALLOCATED=2                       *\n*                                                                     *\n*          OUTPUT SDS:                                                *\n*            DSNAME=GILBERT.UNLOAD,VOL=SER=STR319                     *\n*            RECFM=FB,LRECL=80,BLKSIZE=800                            *\n*            RECORDS=100,BYTES=8000                                   *\n*                                                                     *\n***********************************************************************\nPRT10    STRING '0INPUT PDS:',INTO=LINE\n         PUT   SYSPRINT,LINE           print message\n         STRING '0  DSNAME=',(JFCBDSNM,,T),                            X\n               ',VOL=SER=',(JFCBVOLS,6),                               X\n               INTO=LINE\n         MVC   UNITNAME+8,DVAUCBTY     move device type\n         LINK  EP=IEFEB4UV,                                            X\n               PARAM=(UNITNAME,        work area                       X\n               =X'0100'),              function flags  \"7\"             X\n               MF=(E,DWD),VL=1\n         LTR   R15,R15                 OK?\n         BNZ   PRT13                   no, jump\n         LINK  EP=IEFEB4UV,                                            X\n               PARAM=(UNITNAME,        work area                       X\n               =X'2000'),              function flags  \"2\"             X\n               MF=(E,DWD),VL=1\n         LTR   R15,R15                 OK?\n         BNZ   PRT13                   no, jump\n         STRING '0  DSNAME=',(JFCBDSNM,,T),                            X\n               ',VOL=',(UNITNAME,,T),'=',(JFCBVOLS,6),                 X\n               INTO=LINE\nPRT13    PUT   SYSPRINT,LINE           print message\n         LA    R1,RECFM                RECFM for SYSUT1\n         BAL   R14,#RECFM1             B'11111111' -> C'VBSA'\n         STRING '   RECFM=',(RECFM,,T),                                X\n               ',LRECL=',(DS1LRECL,H,L),                               X\n               ',BLKSIZE=',(DS1BLKL,H,L),                              X\n               INTO=LINE\n         PUT   SYSPRINT,LINE           print message\n         STRING '   Directory_blocks=',(DIRBLKS,F,L),                  X\n               ',Members=',(MEMBERS,F,L),                              X\n               ',Aliases=',(ALIASES,F,L),                              X\n               INTO=LINE\n         PUT   SYSPRINT,LINE           print message\n         STRING '   Tracks_used=',(TRKSUSED,F,L),                      X\n               ',Extents_allocated=',(DS1NOEPV,FL1,L),                 X\n               INTO=LINE\n         PUT   SYSPRINT,LINE           print message\n*\n         STRING '0OUTPUT SDS:',INTO=LINE\n         PUT   SYSPRINT,LINE           print message\n         STRING '0  DSNAME=',(JFCBDSNM-INFMJFCB+JFCB2,,L),             X\n               ',VOL=SER=',(JFCBVOLS-INFMJFCB+JFCB2,,L),               X\n               INTO=LINE\n         PUT   SYSPRINT,LINE           print message\n         LA    R1,RECFM                RECFM for SYSUT1\n         BAL   R14,#RECFM1             B'11111111' -> C'VBSA'\n         STRING '   RECFM=FB,LRECL=80',                                X\n               ',BLKSIZE=',(DCBBLKSI-IHADCB+SYSUT2,H,L),               X\n               INTO=LINE\n         PUT   SYSPRINT,LINE           print message\n***********************************************************************\n*                                                                     *\n*        BUILD TABLE OF DIRECTORY ENTRIES                             *\n*                                                                     *\n***********************************************************************\n         LA    R0,1                    Room for X'FF' at end of table\n         AL    R0,DIRTABLE             SIZE OF DIRECTORY ENTRIES\n         GETMAIN RU,LV=(0),BNDRY=PAGE  GET STORAGE FOR DIRECTRY ENTRIES\n         STM   R0,R1,DIRTABLE          len/addr of dir entries\n         LR    R4,R1                   point to start of table\n         OPEN  MF=(E,OPENDIRL)         re-open DIRECTORY\n         MVI   DIRENTRY,FF             FIRST TIME SWITCH FOR \"GETDIR\"\n*LOOP\nBLDTBL1  BAL   R9,GETDIR            <- GET DIRECTORY ENTRY\n         CLI   PDS2,FF                 LOGICAL END OF DIRECTORY?\n         BE    BLDTBL9                 YES, EXIT\n         CLI   UT1MBR,FF               select a member ?\n         BE    BLDTBL6                 no, jump\n         CLC   PDS2NAME,JFCBELNM       IS IT MY MEMBER?\n         BE    BLDTBL6                 yes, jump\nBLDTBL5  ALR   R6,R0                   ignore this mbr\n         B     BLDTBL1                 next directory entry\nBLDTBL6  LR    R5,R0                   size of dir entry\n         LR    R7,R0                   size of dir entry\n         MVCL  R4,R6                   move directory entry to table\n         B     BLDTBL1                 next directory entry\n*ENDLOOP\nBLDTBL9  MVI   0(R4),FF                mark end of table\n         CLOSE MF=(E,OPENDIRL)         CLOSE DIRECTORY\n         FREEPOOL SYSUT1D              FREE BUFFERS\n         CL    R4,DIRTABLE+4           any member selected?\n         BE    EOJ                     no, exit\n***********************************************************************\n*                                                                     *\n*        Turn off ALIAS indicator in directory entries                *\n*        for which no main member is present.                         *\n*                                                                     *\n***********************************************************************\nUNALIAS  ICM   R0,B'1111',ALIASES      any ALIAS?\n         BZ    GETMBR                  no, exit\n         L     R6,DIRTABLE+4           first directory entry\n*LOOP\nUNALIAS1 TM    PDS2INDC,PDS2ALIS       is this an alias?\n         BNO   UNALIAS8                no, ignore it\n         L     R7,DIRTABLE+4           first directory entry\n         USING PDS2,R7\n*--loop\nUNALIAS2 TM    PDS2INDC,PDS2ALIS       is this an alias?\n         BO    UNALIAS3                yes, ignore it\n         CLC   PDS2TTRP,PDS2TTRP-PDS2(R6)   main mbr of my alias?\n         BE    UNALIAS8                yes, exit inner loop\nUNALIAS3 LA    R14,PDS2LUSR            MASK\n         N     R14,PDS2TTRP            SIZE OF USER DATA\n         ALR   R14,R14                 size of user data in bytes\n         LA    R7,PDS2USRD(R14)        NEXT DIRECTORY ENTRY\n         CLI   PDS2,FF                 LOGICAL END OF DIRECTORY?\n         BNE   UNALIAS2                NO, NEXT MEMBER\n*--endloop\n         DROP  R7                      was PDS2 (local only)\n         NI    PDS2INDC,FF-PDS2ALIS    turn off ALIAS indicator\n*\nUNALIAS8 LA    R14,PDS2LUSR            MASK\n         N     R14,PDS2TTRP            size of user data in half-words\n         ALR   R14,R14                 size of user data in bytes\n         LA    R6,PDS2USRD(R14)        NEXT DIRECTORY ENTRY\n         CLI   PDS2,FF                 LOGICAL END OF DIRECTORY?\n         BNE   UNALIAS1                NO, NEXT MEMBER\n*ENDLOOP\n***********************************************************************\n*                                                                     *\n*        PROCESS DIRECTORY ENTRIES AND MEMBER DATA                    *\n*                                                                     *\n*          1.  READ DIRECTORY ENTRIES FROM \"DIRTABLE\"                 *\n*          2.  READ MEMBERS FROM DDN=SYSUT1 USING BPAM                *\n*          3.  PASS RECORDS TO \"WRITE\" ROUTINE                        *\n*          4.  Write ALIAS entry after corresponding main member      *\n*                                                                     *\n***********************************************************************\nGETMBR   GETBUF SYSUT1M,(R3)           GET ADDR OF A BUFFER\n         ST    R3,DECB1+12             UPDATE BUFFER ADDR IN DECB\n         L     R6,DIRTABLE+4           first directory entry\n*LOOP\nGETMBR1  LA    R14,PDS2LUSR            MASK\n         N     R14,PDS2TTRP            SIZE OF USER DATA\n         LA    R0,12(R14,R14)          SIZE OF DIRECTORY ENTRY\n         TM    PDS2INDC,PDS2ALIS       is this an alias?\n         BO    GETMBR9                 yes, ignore it\n         STH   R0,DWD                  SIZE OF DIRECTORY ENTRY\n         MVI   DWD+2,X'C8'             THIS IS A DIRECTORY ENTRY\n         MVC   DWD+3(3),TTRN           TTRN OF PREVIOUS BLOCK\n         LA    R0,2+1+3                LENGTH,FLAGS,TTR\n         LA    R1,DWD                  002A,C8,00000A\n         BAL   R9,WRITE                WRITE RECORD SEGMENT\n         LH    R0,DWD                  SIZE OF DIRECTORY ENTRY\n         LA    R1,PDS2                 ADDR OF DIRECTORY ENTRY\n         BAL   R9,WRITE                WRITE RECORD SEGMENT\n         MVC   TTRN(3),8(R6)           TTR\n         FIND  SYSUT1M,TTRN,C          POINT TO MEMBER\n*--LOOP\nGETMBR2  READ  DECB1,SF,SYSUT1M,*-*,'S'\n         CHECK DECB1\n         MVC   DWD(2),DCBLRECL-IHADCB+SYSUT1M\n         MVI   DWD+2,X'E0'             DATA RECORD\n         NOTE  SYSUT1M                 GET TTR\n         STCM  R1,B'1110',DWD+3        SAVE TTR\n         LA    R0,2+1+3                LENGTH,FLAGS,TTR\n         LA    R1,DWD                  TTR\n         BAL   R9,WRITE                WRITE RECORD SEGMENT\n         LH    R0,DCBLRECL-IHADCB+SYSUT1M\n         L     R1,DECB1+12             BUFFER ADDR IN DECB\n         BAL   R9,WRITE                WRITE DATA\n         B     GETMBR2                 NEXT BLOCK\n*--ENDLOOP\n*\n*        Write ALIAS directory entries corresponding to the member\n*        just written\n*\nGETMBR8  ICM   R0,B'1111',ALIASES      any ALIAS?\n         BZ    GETMBR9                 no, jump\n         L     R7,DIRTABLE+4           first directory entry\n         USING PDS2,R7\n*--LOOP\nGETMBR8B LA    R14,PDS2LUSR            MASK\n         N     R14,PDS2TTRP            SIZE OF USER DATA\n         LA    R0,12(R14,R14)          SIZE OF DIRECTORY ENTRY\n         TM    PDS2INDC,PDS2ALIS       is this an alias?\n         BNO   GETMBR8N                no, ignore it\n         CLC   TTRN(3),PDS2TTRP        alias of member just written?\n         BNE   GETMBR8N                no, ignore it\n         STH   R0,DWD                  SIZE OF DIRECTORY ENTRY\n         MVI   DWD+2,X'C8'             THIS IS A DIRECTORY ENTRY\n         MVC   DWD+3(3),TTRN           TTRN OF PREVIOUS BLOCK\n         LA    R0,2+1+3                LENGTH,FLAGS,TTR\n         LA    R1,DWD                  002A,C8,00000A\n         BAL   R9,WRITE                WRITE RECORD SEGMENT\n         LH    R0,DWD                  SIZE OF DIRECTORY ENTRY\n         LA    R1,PDS2                 ADDR OF DIRECTORY ENTRY\n         BAL   R9,WRITE                WRITE RECORD SEGMENT\n         LH    R0,DWD                  SIZE OF DIRECTORY ENTRY\nGETMBR8N ALR   R7,R0                   NEXT DIRECTORY ENTRY\n         CLI   PDS2,FF                 LOGICAL END OF DIRECTORY?\n         BNE   GETMBR8B                NO, NEXT MEMBER\n*--ENDLOOP\n         DROP  R7                      was PDS2 (local only)\n*\nGETMBR9  LA    R14,PDS2LUSR            MASK\n         N     R14,PDS2TTRP            size of user data in half-words\n         ALR   R14,R14                 size of user data in bytes\n         LA    R6,PDS2USRD(R14)        NEXT DIRECTORY ENTRY\n         CLI   PDS2,FF                 LOGICAL END OF DIRECTORY?\n         BNE   GETMBR1                 NO, NEXT MEMBER\n*ENDLOOP\n***********************************************************************\n*                                                                     *\n*        END OF DIRECTORY                                             *\n*                                                                     *\n*          1.  WRITE AN EOF RECORD                                    *\n*          2.  CLOSE THE FILES                                        *\n*          3.  CLEAN UP                                               *\n*          4.  GOBACK                                                 *\n*                                                                     *\n***********************************************************************\nEOJ      LA    R0,3                    L'TTR\n         LA    R1,=X'0000,01'          LENGTH=0\n         BAL   R9,WRITE                WRITE EOF RECORD\n         LM    R4,R5,CURRENT           CURRENT ADDR & REMAINING LENGTH\n         SLR   R15,R15                 PADDING TO X'00'\n         MVCL  R4,R14                  PAD LAST RECORD\n*\nLASTMSG  LA    R1,80                   LRECL of SYSUT2 data set\n         M     R0,SEQNO                calculate number of bytes\n         STRING '   Records=',(SEQNO,F,L),',Bytes=',((R1),,L),INTO=LINE\n         PUT   SYSPRINT,LINE           print message\n*\nCLOSEALL CLOSE MF=(E,OPENLIST)         CLOSE ALL DATA SETS\n         FREEPOOL SYSUT1M              FREE BUFFERS\n         FREEPOOL SYSUT2               FREE BUFFERS\n         FREEPOOL SYSPRINT             FREE BUFFERS\n*\n         LM    R0,R1,DIRTABLE          len/addr of dir entries\n         FREEMAIN RU,LV=(0),A=(1)      free directory entry table\n*\nGOBACK   LR    R1,R13\n         L     R13,4(,R13)\n         FREEMAIN R,LV=DYNAML,A=(1)    FREE DYNAMIC STORAGE\n         RETURN (14,12),RC=00          GOBACK\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Read Directory Blocks from SYSUT1D and un-block them         *\n*                                                                     *\n*        Returns:                                                     *\n*                                                                     *\n*          R0 Length of the directory entry                           *\n*          R6 Address of the directory entry (8X'FF' at EOF)          *\n*                                                                     *\n*---------------------------------------------------------------------*\nGETDIR   ICM   R6,B'1111',DIRENTRY     CURRENT DIRECTORY ENTRY\n         BP    GETDIR4                 NOT FIRST TIME, JUMP\n*LOOP\nGETDIR1  GET   SYSUT1D                 READ DIRECTORY BLOCK\n         LA    R0,1                    COUNT DIRECTORY BLOCKS\n         AL    R0,DIRBLKS              COUNT DIRECTORY BLOCKS\n         ST    R0,DIRBLKS              COUNT DIRECTORY BLOCKS\n         LA    R6,2(,R1)               FIRST ENTRY IN THIS BLOCK\n         B     GETDIR9                 EXIT\n*--LOOP\nGETDIR4  LA    R14,PDS2LUSR            MASK\n         N     R14,PDS2TTRP            SIZE OF USER DATA\n         LA    R14,12(R14,R14)         SIZE OF DIRECTORY ENTRY\n         L     R15,DCBRECAD-IHADCB+SYSUT1D  1ST BYTE OF CURR DIR BLK\n         AH    R15,0(,R15)             LENGTH OF CURR DIR BLK\n         BCTR  R15,0                   LIMIT FOR BXH\n         BXH   R6,R14,GETDIR1          SIZE\n*--ENDLOOP\nGETDIR9  ST    R6,DIRENTRY             SAVE ADDR OF CURR DIR ENTRY\n         LA    R14,PDS2LUSR            MASK\n         N     R14,PDS2TTRP            SIZE OF USER DATA\n         LA    R0,12(R14,R14)          SIZE OF DIRECTORY ENTRY\n         BR    R9\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Write Records to SYSUT2 in IEHMOVE format                    *\n*                                                                     *\n*---------------------------------------------------------------------*\nWRITE    LR    R2,R1                   ADDRESS\n         LR    R3,R0                   LENGTH\n         LM    R4,R5,CURRENT           CURRENT ADDR & REMAINING LENGTH\n*LOOP\nWRITE1   LTR   R5,R5                   ANY SPACE LEFT IN PREVIOUS RCD?\n         BP    WRITE2                  YES, JUMP\n         PUT   SYSUT2                  NO, LOCATE ANOTHER\n         LA    R0,1                    BUMP SEQNO\n         AL    R0,SEQNO                BUMP SEQNO\n         ST    R0,SEQNO                BUMP SEQNO\n         STH   R0,0(,R1)               BUMP SEQNO\n         LA    R4,2(,R1)               ADDRESS\n         LA    R5,78                   LENGTH\nWRITE2   LR    R14,R4                  \"TO\" ADDR\n         LR    R15,R5                  \"TO\" ADDR\n         CLR   R15,R3                  INREC TOO BIG?\n         BL    WRITE3                  NO, JUMP\n         LR    R15,R3                  YES, TRUNCATE\nWRITE3   ALR   R4,R15                  BUMP ADDR\n         SLR   R5,R15                  DECREASE LENGTH\n         MVCL  R14,R2                  FILL IN RECORD\n         LTR   R3,R3                   INPUT RECORD ALL MOVED?\n         BP    WRITE1                  NOT YET, KEEP ON MOVING\n*ENDLOOP\n         STM   R4,R5,CURRENT           CURRENT ADDR & REMAINING LENGTH\nWRITE99  BR    R9\n*---------------------------------------------------------------------*\n*                                                                     *\n*        RECFM Edit Routine                                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n#RECFM1  MVC   RECFM,BLANKS            INITIALIZE RECFM AREA\n         MVI   0(R1),C'U'\n         TM    DS1RECFM,DS1RECFU       RECFM=U?\n         BO    #RECFM2                 YES, JUMP\n         MVI   0(R1),C'F'\n         TM    DS1RECFM,DS1RECFF       RECFM=F?\n         BO    #RECFM2                 YES, JUMP\n         MVI   0(R1),C'V'\n#RECFM2  TM    DS1RECFM,DS1RECFB       RECFM=.B ?\n         BNO   #RECFM3                 NO, JUMP\n         MVI   1(R1),C'B'              .B\n         LA    R1,1(,R1)\n#RECFM3  TM    DS1RECFM,DS1RECFS       RECFM=..S ?\n         BNO   #RECFM4                 NO, JUMP\n         MVI   1(R1),C'S'              ..S\n         LA    R1,1(,R1)\n#RECFM4  TM    DS1RECFM,DS1RECFA       RECFM=...A ?\n         BNO   #RECFM5                 NO, JUMP\n         MVI   1(R1),C'A'              ...A\n#RECFM5  TM    DS1RECFM,DS1RECMC       RECFM=...M ?\n         BNO   #RECFM6                 NO, JUMP\n         MVI   1(R1),C'M'              ...M\n#RECFM6  TM    DS1RECFM,DS1RECFT       RECFM=...T ?\n         BNOR  R14                     NO, JUMP\n         MVI   1(R1),C'T'              ...T\n         BR    R14\n***********************************************************************\n*                                                                     *\n*        DATA AREAS                                                   *\n*                                                                     *\n***********************************************************************\nOPENLIST OPEN  (SYSUT1M,,SYSUT2,OUTPUT,SYSPRINT,OUTPUT),MF=L\nOPENDIRL OPEN  (SYSUT1D),MF=L\nSYSUT1D  DCB   DSORG=PS,MACRF=GL,DDNAME=SYSUT1,EODAD=ENDOFDIR,         X\n               EXLST=EXL1,RECFM=U,BLKSIZE=256\nEXL1     DC    A(X'87000000')          DCB EXIT LIST (SYSUT1)\nENDOFDIR SLR   R1,R1\n         BR    R14\nSYSUT1M  DCB   DSORG=PO,MACRF=R,DDNAME=SYSUT1,EODAD=GETMBR8,           X\n               RECFM=U,BUFNO=1\nSYSUT2   DCB   DSORG=PS,MACRF=PL,DDNAME=SYSUT2,                        X\n               EXLST=EXL1,RECFM=FB,LRECL=80\nSYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,                      X\n               RECFM=FBA,LRECL=121\nCAML26   CAMLST SEARCH,DS1DSNAM,DS1DSSN,DS1FMTID\nBLANKS   DC    CL(L'RECFM)' '\nFF       EQU   X'FF'\n*\n*        HEADER RECORDS (IEHMVSSX/IEHMVSXY)\n*\nHDR1REC  DC    H'75',X'0E'             HEADER RECORD\n         DC    C'THIS IS AN UNLOADED DATA SET PRODUCED BY',X'80'\n         DC    C'THE IBM UTILITY, SYSMOVE.'\n         DC    C'OMMBRLDWB'            WHATEVER\n*\nHDR2REC  DC    AL2(HDR2LEN-3)          L'DSCB1 + 57\n         DC    X'00'                   NO FLAGS\n         IECSDSL1 1                    F1-DSCB\nUNLDDIR  DS    XL2                     DIRECTORY QUANTITY\nUNLDFLAG DS    XL1                     UNLOAD CONTROL FLAG\nUNLDSIZE DS    XL4                     PRIM ALLOC OF DS (IN BYTES)\nUNLDSSIZ DS    XL4                     SEC ALLOCATION OF DS (IN BYTES)\nUNLDSPAR DS    XL42                    UNUSED SPARE BYTES\nUNLDDEVT DS    XL4                     FROM DEVICE TYPE\nHDR2LEN  EQU   *-HDR2REC\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DYNAMIC STORAGE AREA                                         *\n*                                                                     *\n*---------------------------------------------------------------------*\nDYNAM    DSECT\n         DS    18F                     SAVE AREA\nUT1MBR   DS    CL8                     SYSUT1 member\nDWD      DS    D\nUNITNAME DS    CL8,XL4,XL4,XL4,XL8     IEFEB4UV\nDIRENTRY DS    A                       DIRECTORY ENTRY\nDIRBLKS  DS    F                       NUMBER OF DIRECTORY BLOCKS\nMEMBERS  DS    F                       NUMBER OF MEMBERS\nALIASES  DS    F                       NUMBER OF ALIASES\nDIRTABLE DS    F,A                     addr/size of dir entry table\nTRKSUSED DS    F                       NUMBER OF tracks used\nCURRENT  DS    A,F                     OUTPUT ADDR, LENGTH\nTTRN     DS    F                       TTRN OF FIRST/CURRENT BLOCK\nSEQNO    DS    F                       SYSUT2 RECORD SEQUENCE NUMBER\nRECFM    DS    C'VBSAMT'               Record Format\nLINE     DS    CL121                   print line\n         DS    0F                      ALIGN DVAREA\n         IHADVA DSECT=NO               DEVTYPE AREA\n         ORG   ,                       ALIGN DVAREA\nJFCB1    DS    0F                      First JFCB for SYSUT1\n         IEFJFCBN                      JFCB for SYSUT1\nJFCB2    DS    XL(*-JFCB1)             JFCB for SYSUT2\nDYNAML   EQU   *-DYNAM\n*\n         DCBD  DSORG=PS,DEVD=DA\n*@@      IHAPDS DSECT=YES,PDSBLDL=NO\nPDS2     DSECT\nPDS2NAME DS    CL8                     member name\nPDS2TTRP DS    XL3                     TTR\nPDS2INDC DS    X                       flags, length of user data\nPDS2ALIS EQU   X'80'                   ALIAS entry\nPDS2LUSR EQU   X'1F'                   len of user data in half-words\nPDS2USRD DS    0C                      start of user data\n         YREGS\n         STRING GENERATE               generate literals, routine\n*---------------------------------------------------------------------*\n*                                                                     *\n*        FORMAT OF IEHMOVE UNLOAD RECORDS (IEHMVSRA)                  *\n*                                                                     *\n*    (FOR DOCUMENTATION ONLY, THIS DSECT IS NOT USED IN THE PROGRAM)  *\n*                                                                     *\n*---------------------------------------------------------------------*\nBUFFER   DSECT\n         DC    H'1'                    RECORD SEQUENCE NUMBER\nRECLEN   DC    H'75'                   RECORD LENGTH\nRECTYPE  DC    X'0E'                   RECORD TYPE\nRTYP_TTR   EQU X'80'                   3-BYTE TTR FOLLOWS\nRTYP_PDS   EQU X'40'                   INPUT DATA SET IS A PDS\nRTYP_DATA  EQU X'20'                   MEMBER DATA\nRTYP_NOTE  EQU X'10'                   NOTE LIST\nRTYP_DIR   EQU X'08'                   DIRECTORY ENTRY\nRTYP_DMY   EQU X'04'                   DUMMY RECORD\nRTYP_HDR   EQU X'02'                   HEADER RECORD\nRTYP_EOF   EQU X'01'                   EOF RECORD\nRECTTR   DS    XL3                     TTR OF THIS RECORD\nRECDATA  DS    XL(BUFFER+800-*)        DATA\n         END\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=CBTTAPE.FILE183.PDS(STRING),DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//LKED    EXEC PGM=HEWL,PARM=REUS\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,DELETE)\n//SYSLMOD  DD DSN=CBTTAPE.FILE183.LOAD(SYSMOVE),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//\n//\n//GO      EXEC PGM=LOADER,PARM=NOPRINT\n//STEPLIB  DD DSN=CBTTAPE.FILE183.LOAD,DISP=SHR\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DSN=GILBERT.LOAD(BLK0),DISP=SHR\n//SYSUT2   DD DSN=GILBERT.X80,BLKSIZE=800,DISP=SHR\n//SYSUDUMP DD SYSOUT=*\n//\n//*---------------------\n//DEL12 EXEC PGM=IEFBR14\n//DEL12 DD DSN=GILBERT.IEB12,DISP=(MOD,DELETE),SPACE=(1,0)\n//DEL12 DD DSN=GILBERT.IEB12,DISP=(OLD,DELETE),VOL=REF=SYS1.PARMLIB\n//RELOAD EXEC PGM=IEHMOVE,PARM='POWER=4'\n//SYSUT1 DD DSN=SYS1.PARMLIB,DISP=SHR\n//DD1    DD DSN=GILBERT.X80,DISP=SHR\n//DD2    DD DSN=SYS1.PARMLIB,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n     COPY      DSNAME=GILBERT.X80,                                     X\n               TO=3380=TEST01,                                         X\n               RENAME=GILBERT.IEB12,                                   X\n               CATLG\n/*\n//*---------------------\n//CMPR    EXEC PGM=COMPAREX\n//SYSUT1   DD DSN=GILBERT.IEB11,DISP=SHR\n//SYSUT2   DD DSN=GILBERT.X80,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TALLY": {"ttr": 22281, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*---------------------------------------------------------------REXX-*\\\n|*                                                                    *|\n|* MODULE NAME = TALLY                                                *|\n|*                                                                    *|\n|* DESCRIPTIVE NAME = Tallies tracks on DSLIST panel.                 *|\n|*                                                                    *|\n|* STATUS = R102                                                      *|\n|*                                                                    *|\n|* FUNCTION = Display the total number of tracks used up by the       *|\n|*            data sets currently displayed on the Data Set List      *|\n|*            panel (ISPF 3.4).  Requires that the size information   *|\n|*            for all the data sets be previously obtained from the   *|\n|*            VTOC, for example with a SORT SIZE command.             *|\n|*                                                                    *|\n|* AUTHOR   =  Gilbert Saint-Flour <carlos@gsf-soft.com>              *|\n|*             http://gsf-soft.com/Freeware/                          *|\n|*                                                                    *|\n|* DEPENDENCIES = TSO/E V2                                            *|\n|*                ISPF V3, V4 or V5                                   *|\n|*                                                                    *|\n|* SYNTAX   =  TALLY                                                  *|\n|*                                                                    *|\n|*             Must be issued while on the DSLIST panel, either       *|\n|*             as a line command (on any line) or as TSO %TALLY.      *|\n|*                                                                    *|\n|* CHANGE LOG                                                         *|\n|*                                                                    *|\n|*101 When DTA+016=0, get DSB addr from DTA+044                       *|\n|*102 Stop using DTB in ISPF 5.9 and above                Ron.Hesketh *|\n|*                                                                    *|\n\\*--------------------------------------------------------------------*/\nADDRESS 'ISPEXEC'\ntcb    = PTR(540)               /* TCB (EXEC command)    PSATOLD  */\ntcb    = PTR(tcb+132)           /* TCB (ISPTASK)         TCBOTC   */\nfsa    = PTR(tcb+112)           /* first save area       TCBFSA   */\nr1     = PTR(fsa+24)            /* ISPTASK's R1                   */\ntld    = PTR(r1)                /* TLD address                    */\ndta    = PTR(tld+076)           /* DTA address                    */\ntbl    = STORAGE(D2X(dta+12),8) /* Name of temp table    DSL12345 */\n\"VGET ZENVIR\"                   /* Retrieve ISPF Version          */\nIF LEFT(Zenvir,8) < 'ISPF 5.9' THEN DO\n  dtb    = PTR(dta+016)           /* DTB address                  */\n  IF dtb=0 THEN\n    dtb  = PTR(dta+044)           /* OPEN Table Chain             */\n  IF STORAGE(D2X(dtb),3) /= 'DTB' THEN DO\n    SAY 'Error: Table name could not be located (DTB)' zenvir\n    EXIT 12\n    END\n  tbl  = STORAGE(D2X(dtb+6),8)  /* Name of temp table    DSL12345 */\n  END\n\n'CONTROL ERRORS RETURN'\n'TBTOP' tbl\n  IF rc>0 THEN DO\n    SAY 'TBTOP failed for table' tbl 'RC='rc\n    EXIT\n  END\n\ntally=0;rows=0;processed=0;zusize=0   /* Init counters */\nDO FOREVER\n  'TBSKIP' tbl                        /* NEXT ROW      */\n  IF rc>0 THEN LEAVE\n  'TBGET' tbl                         /* SET VARIABLES */\n  IF rc>0 THEN LEAVE\n  rows=rows+1                         /* count rows    */\n  IF zusize = '' THEN ITERATE         /* ignore migrated data sets */\n  tally=tally+zusize                  /* tally file size */\n  processed=processed+1               /* count processed data sets */\nEND\nZMSG000S = tally 'Tracks'\nZMSG000L = 'Total Data sets:' rows,\n           ' Data sets processed:' processed,\n           ' Total tracks:' tally\n\"SETMSG MSG(ISPZ000)\"\nEXIT\n\nPTR: RETURN C2D(STORAGE(D2X(ARG(1)),4))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TCTDCTR": {"ttr": 22529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x85\\x11\\x8f\\x01\\x042\\x0f\\x16\\x00\\x01-\\x00~\\x00_\\xc3\\xc2\\xe3\\xf4\\xf6\\xf9@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1985-04-28T00:00:00", "modifydate": "2004-11-15T16:00:00", "lines": 301, "newlines": 126, "modlines": 95, "user": "CBT469"}, "text": "//GILBERTT JOB (ACCT#),TCTDCTR,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//*\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n*\n*\n*        EDITION DU NOMBRE D'EXCP SUR TOUS LES FICHIERS DU STEP\n*\n*        VERSION CHAPEAU DE TCTDCTR, XA 2.2\n*\n*\n$TCTDCTR START 0\n$TCTDCTR AMODE 31\n         L     R15,6(,R15)             AMODE31\n         BSM   0,R15                   AMODE31\n         DC    AL4(*+X'80000004')      AMODE31\n         SAVE  (14,12),,TCTDCTR-&SYSDATE.-&SYSTIME\n         BALR  R12,0                   LOAD BASE REGISTER\n         USING *,R12                   SPECIFY IT TO ASSEMBLER\n         LR    R14,R13                 SYSTEM SAVE-AREA\n         LA    R13,=18C'SAVE'          NEW SAVE-AREA\n         ST    R14,4(,R13)             FORWARD CHAIN\n         ST    R13,8(,R14)             BACKWARD CHAIN\n*\n         WXTRN MEMBER\n         ICM   R15,B'1111',=A(MEMBER)  PROGRAM TO BE TRACED\n         BZ    NOCALL                  NO PROGRAM TO CALL\n         BALR  R14,R15                 CALL PROGRAM TO BE TRACED\nNOCALL   STH   R15,RETCODE\n*\n         L     R4,540(,0)              PSATOLD\n         USING TCB,R4\n*=       C     RTCB,TCBJSTCB           CHECK IF I'M A BATCH PGM\n*=       BNE   GOBACK                  QUIT IF TSO\n*\n         LA    R1,=A(S99RB+X'80000000') SVC99 REQUEST BLOCK    HEADER\n         SVC   99                      ALLOCATE SYSDBOUT\n         OPEN  MF=(E,OPENL1)           OPEN SYSDBOUT\n         LTR   R15,R15                 CHECK OPEN RETURN CODE\n         BNZ   GOBACK                  QUIT IF OPEN FAILED\n         L     R5,TCBTIO               MY TIOT\n         USING TIOT1,R5\n         L     R6,X'0224'              MY ASCB\n         L     R6,ASCBOUCB-ASCB(,R6)   MY OUCB\n         USING OUCB,R6\n         L     R7,TCBJSCB              MY JSCB\n         USING IEZJSCB,R7\n         BAL   R11,PUTDCB2         <== LOCATE OUTPUT RECORD\n         STRING '1 JOB=',TIOCNJOB,'  STEP=',(TIOCSTEP+0,8),            X\n               '  PROCSTEP=',(TIOCSTEP+8,8),                           X\n               '  PGM=',JSCBPGMN,                                      X\n               '  PERFORM=',(OUCBNPG,H,L),                             X\n               INTO=((R1),121)\n         BAL   R11,PUTDCB2             WRITE BLANK LINE\n         BAL   R11,PUTDCB2\n         STRING '   DDNAME     DISP  VOLSER    EXCP   DATA SET NAME',  X\n               34X,'DEVICE     CUA    LABEL',                          X\n               INTO=((R1),121)\n         BAL   R11,PUTDCB2\n         MVI   1(R1),C'-'              LINE OF DASHES\n         MVC   2(109,R1),1(R1)         LINE OF DASHES\n*LOOP\nTIOT_GET CLI   TIOEDDNM,C' '           FREED DD?\n         BL    TIOT_NXT                YES, JUMP\n         LA    R6,TENWORDS+4           WORK AREA\n         ST    R6,TENWORDS             WORK AREA\n         USING ZB505,R6\n         XC    SWAEPAX,SWAEPAX\n         MVC   SWVA,TIOEJFCB           SVA OF THE JFCB\n         SWAREQ FCODE=RL,EPA=TENWORDS,MF=(E,SWAREQL1),UNAUTH=YES\n         L     R6,SWBLKPTR             31-BIT ADDRESS OF JFCB\n         USING INFMJFCB,R6\n         MVC   WKCELL1,BLANKS          CLEAR WORK AREA\n         MVC   STATUS,BLANKS           CLEAR WORK AREA\n         MVC   UNITNAME,BLANKS         CLEAR WORK AREA\n         MVC   VOLSER,=C'JES     '     SYSIN/SYSOUT\n         SLR   R1,R1                   EXCP=0\n         SLR   R7,R7                   NO UCB\n         TM    TIOELINK,TIOESSDS       IS THIS A JES DATA SET?\n         BO    TIOT61                  YES, JUMP\n         MVC   VOLSER,=C'DUMMY   '     DUMMY DATA SET\n         ICM   R7,B'0111',TIOEFSRT     UCB ADDRESS\n         BZ    TIOT64                  NO UCB, SKIP TCT SCAN\n         USING UCBOB,R7\n         MVC   UNITNAME+8(4),UCBTYP    DEVICE TYPE\n         BAL   R14,GETUNIT         <== GET UNITNAME\n         MVC   VOLSER,=C'VIO     '     UNIT=VIO\n         TM    UCBOB,UCBVRDEV          IS THIS A VIO DATA SET?\n         BO    TIOT41                  YES, JUMP\n         MVC   VOLSER,JFCBVOLS         NO, MOVE FIRST VOLSER\n*\nTIOT41   BAS   R1,TIOT41IC\n         DC    C'NEW',AL1(JFCNEW)\n         DC    C'MOD',AL1(JFCMOD)\n         DC    C'SHR',AL1(JFCOLD+JFCSHARE)\n         DC    C'OLD',AL1(JFCOLD)\n         DC    C'???',0H'0'\nTIOT41TM TM    JFCBIND2,*-*            TEST LABEL TYPE FLAGS\n*--LOOP\nTIOT41IC IC    R15,3(,R1)              PICK UP MASK FOR \"TM\"\n         EX    R15,TIOT41TM\n         BO    TIOT41X\n         LA    R1,3+1(,R1)             BUMP TABLE PTR\n         CLI   0(R1),C'?'              END OF TABLE?\n         BNE   TIOT41IC                NEXT TABLE ENTRY\n*--ENDLOOP\nTIOT41X  MVC   STATUS,0(R1)            DISP\n*\n         TM    UCBFL5,UCBSMS           SMS VOL?     X'20'\n         BZ    TIOT46                  NO, JUMP\n         MVC   WKCELL1(3),=C'SMS'      SMS-MANAGED\n*\nTIOT46   CLI   UCBTBYT3,UCB3TAPE       TAPE DEVICE?\n         BNE   TIOT61                  NO, JUMP\n         BAS   R1,TIOT46IC\n         DC    C'LTM',AL1(JFCBLTM)\n         DC    C'BLP',AL1(JFCBLP)\n         DC    C'SUL',AL1(JFCSUL)\n         DC    C'AUL',AL1(JFCSUL+JFCBAL)\n         DC    C'AL ',AL1(JFCBAL)\n         DC    C'NSL',AL1(JFCNSL)\n         DC    C'SL ',AL1(JFCSL)\n         DC    C'NL ',AL1(JFCNL)\n         DC    C'???',0H'0'\nTIOT46TM TM    JFCBLTYP,*-*            TEST LABEL TYPE FLAGS\n*--LOOP\nTIOT46IC IC    R15,3(,R1)              PICK UP MASK FOR \"TM\"\n         EX    R15,TIOT46TM\n         BO    TIOT46X\n         LA    R1,3+1(,R1)             BUMP TABLE PTR\n         CLI   0(R1),C'?'              END OF TABLE?\n         BNE   TIOT46IC                NEXT TABLE ENTRY\n*--ENDLOOP\nTIOT46X  LH    R0,JFCBFLSQ             PICK UP FILE SEQUENCE NUMBER\n         LTR   R0,R0                   LABEL=0?\n         BNZ   TIOT46Y                 NO, JUMP\n         LA    R0,0001                 YES, CHANGE TO LABEL=1\nTIOT46Y  STRING ((R0),,L),',',((R1),3),INTO=WKCELL1\n*\nTIOT61   LA    R0,TIOENTRY             POINT TO CURRENT TIOT ENTRY\n         SL    R0,TCBTIO               CHANGE ADDRESS TO OFFSET\n         BAL   R14,EXCP00          <== GET EXCP COUNT IN R1\n         STRING ((R1),,R5B),INTO=WKCELL2\n         CL    R1,=F'100000'           OVER 100K?\n         BL    TIOT64                  NO, JUMP\n         SLR   R0,R0                   YES, DIVIDE BY 1000\n         LA    R1,500(,R1)             YES, DIVIDE BY 1000\n         D     R0,=F'1000'             YES, DIVIDE BY 1000\n         STRING ((R1),,R4B),'K',INTO=WKCELL2\n*\nTIOT64   LTR   R7,R7                   DO WE HAVE AN UCB?\n         BNZ   TIOT_PRT                YES, JUMP\n         LA    R7,BLANKS               NO, POINT TO A DUMMY UCB\nTIOT_PRT BAL   R11,PUTDCB2         <== LOCATE OUTPUT RECORD\n         STRING $$$,TIOEDDNM,$$$,STATUS,$$$,                          XX\n               VOLSER,$$$,(WKCELL2,5),$$$,JFCBDSNM,$$$,               XX\n               UNITNAME,$$$,UCBNAME,$$$,WKCELL1,$$$,                  XX\n               INTO=((R1),121)\n*\nTIOT_NXT SLR   R0,R0                   PREPARE IC\n         IC    R0,TIOELNGH             LOAD LENGTH OF CURRENT ENTRY\n         ALR   R5,R0                   BUMP UP TO NEXT ENTRY\n         CLI   TIOELNGH,0              IS THIS THE END?\n         BNZ   TIOT_GET                NOT YET, LOOP THROUGH TIOT\n*ENDLOOP\n         BAL   R11,PUTDCB2             WRITE BLANK LINE\n         MVI   1(R1),C'-'              LINE OF DASHES\n         MVC   2(109,R1),1(R1)         LINE OF DASHES\n         BAL   R11,PUTDCB2             WRITE BLANK LINE\n         CLOSE MF=(E,OPENL1)           CLOSE SYSDBOUT (IF NECESSARY)\n         FREEPOOL DCB2\n*\nGOBACK   L     R13,4(,R13)\n         L     R14,12(,R13)            RESTORE REGISTERS\n         LH    R15,RETCODE\n         LM    R0,R12,20(R13)          RESTORE REGISTERS\n         BSM   0,R14                   GOBACK WITH CALLER'S AMODE\n*----------------------------------------------------------------------\n*        ISSUE PUT WITH AMODE=24                                      *\n*---------------------------------------------------------------------*\nPUTDCB2  LA    R15,PUTDCB2P            AMODE24\n         BSM   0,R15                   AMODE24\nPUTDCB2P PUT   DCB2\n         MVI   0(R1),C' '              ALL SPACES\n         MVC   1(120,R1),0(R1)         ALL SPACES\n         BSM   0,R11                   GOBACK, RESET AMODE\n*---------------------------------------------------------------------*\n*        EXCP00: RETRIEVE EXCP COUNT IN TCTIOTSD AREA                 *\n*---------------------------------------------------------------------*\nEXCP00   L     R1,540(,0)              MY TCB\n         L     R1,TCBTCT-TCB(,R1)      TCBTCT\n         L     R1,TCTIOTBL-SMFTCT(,R1) START OF I/O MEASUREMENT TABLE\n         LA    R1,TCTIODSP-TCTTIOT(,R1) FIRST DD ENTRY\n         USING TCTDCBTD,R1\n*LOOP\nEXCP11   CL    R0,TCTDCBTD             SAME TIOT OFFSET?\n         BE    EXCP21                  YES, EXIT LOOP\n         ICM   R15,B'1111',TCTDCBLE    END OF TABLE ?\n         LA    R1,TCTDCBLE             NEXT LOOKUP TABLE ENTRY\n         BNZ   EXCP11                  NOT YET, TRY NEXT DD ENTRY\n*ENDLOOP\n         SLR   R0,R0                   EXCP COUNT IS ZERO\n         B     EXCP99\n*\nEXCP21   L     R1,TCTIOTSD             OFFSET IN I/O MEASURE. TABLE\n         L     R15,540(,0)             MY TCB\n         L     R15,TCBTCT-TCB(,R15)    MY TCT\n         A     R1,TCTIOTBL-SMFTCT(,R15) START OF I/O MEASUREMENT TABLE\n         USING TCTDDENT,R1\n         ICM   R0,B'1111',TCTDCTR      EXCP COUNT IN R0\nEXCP99   LR    R1,R0                   EXCP COUNT IN R1 TOO\n         BR    R14\n         DROP  R1\n*---------------------------------------------------------------------*\n*        CONVERT UCBTYP TO UNITNAME                                   *\n*---------------------------------------------------------------------*\nGETUNIT  ST    R14,TENWORDS+32         SAVE R14\n         MVI   TENWORDS+20,X'01'       RETURN A LOOK-UP VALUE (BIT7)\n         MVI   TENWORDS+21,X'00'       CLEAR UNUSED BYTE\n         LA    R14,UNITNAME            UNITNAME+DEVTYPE\n         LA    R15,TENWORDS+20         FLAGS\n         STM   R14,R15,TENWORDS\n         OI    TENWORDS+4,X'80'        END-OF-LIST FLAG\n         LA    R1,TENWORDS             PARM LIST ADDRESS\n         L     R14,CVTPTR              POINT TO CVT\n         L     R14,CVTLINK-CVTMAP(,R14) POINT TO LINKLIST DCB\n         LINK  SF=(E,IEFEB4UV),DCB=(R14)   GET UNIT NAME\n         LTR   R15,R15\n         BNZ   GETUNIT6                BAD RETURN CODE, QUIT\n         MVI   TENWORDS+20,X'20'       RETURN A UNIT NAME (BIT2)\n         LA    R1,TENWORDS             PARM LIST ADDRESS\n         LINK  SF=(E,IEFEB4UV)         GET UNIT NAME\n         LTR   R15,R15\n         BZ    GETUNIT9                GOOD RETURN CODE, GOBACK\nGETUNIT6 MVC   UNITNAME,BLANKS         CONVERSION DID NOT WORK\nGETUNIT9 L     R14,TENWORDS+32         RESTORE R14\n         BR    R14\n*---------------------------------------------------------------------*\n*        WORK AREAS                                                   *\n*---------------------------------------------------------------------*\nBLANKS   DC    CL40' '\n$$$      DC    C' | '\n         PRINT NOGEN\nPRINT    OPSYN ANOP\nIEFEB4UV LINK  EP=IEFEB4UV,SF=L\nDCB2     DCB   DSORG=PS,MACRF=PL,DDNAME=SYSDBOUT,RECFM=FBA,LRECL=121\nOPENL1   OPEN  (DCB2,OUTPUT),MF=L\nS99RB    DC    A(X'14010000',0,*+12,0,0)\n         DC    A(S99TXT01,X'80000000'+S99TXT18)\nS99TXT01 DC    AL2(X'01',1,8),CL8'SYSDBOUT '  DDNAME\nS99TXT18 DC    AL2(X'18',0)                   SYSOUT=*\nRETCODE  DS    H\nWKCELL1  DS    D\nWKCELL2  DS    D\nSTATUS   DS    C'OLD'\nVOLSER   DS    CL6\nUNITNAME DS    CL8,XL4\nSWAREQL1 SWAREQ MF=L                   WORK AREA FOR SWAREQ\nTENWORDS DS    10F\n*-------------------------------------------------------------------\n*        DSECTS FOR MVS SYSTEM CONTROL BLOCKS\n*               SOME OF THESE MACRO INSTRUCTION WILL BE FOUND\n*               IN SYS1.MODGEN INSTEAD OF SYS1.MACLIB.\n*-------------------------------------------------------------------\n         IKJTCB LIST=NO    TCB MAPPING       TASK CONTROL BLOCK\n         IEFTCT            TCT MAPPING       TIMING CONTROL TABLE\nTIOT     DSECT\n         IEFTIOT1          TIOT MAPPING      TASK INPUT-OUTPUT TABLE\n         IKJRB             PRB DSECT         PROGRAM REQUEST BLOCK\n         IHACDE            CDE DSECT         CONTENTS DIRECTORY ENTRY\n         IEFZB505 LOCEPAX=YES          SWAREQ\n         IEFJFCBN                      JOB FILE CONTROL BLOCK\n         IEFJESCT                      JES COMMUNICATION TABLE\n         IEZJSCB                       JOB STEP CONTROL BLOCK\n         CVT   DSECT=YES\n         IEFUCBOB LIST=NO,PREFIX=NO    UCB DSECT\n         IHAASCB                       ADDRESS SPACE CONTROL BLOCK\n         IRAOUCB                       SRM PARMS\n         YREGS             REGISTER EQUATES\n         STRING GENERATE\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DSN=CBTTAPE.FILE183.PDS,DISP=SHR          STRING\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,5)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//GO      EXEC PGM=LOADER,PARM=NOPRINT\n//SYSPRINT DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//SYSDBOUT DD SYSOUT=*\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//\n//\n//LKED    EXEC PGM=IEWL,PARM='MAP,REUS'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,5)\n//SYSLMOD  DD DSN=CBTTAPE.FILE183.LOAD(TCTDCTR),DISP=SHR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TLMS": {"ttr": 22535, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//GILBERTT JOB (ACCT#),TLMS,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(NODECK,OBJECT,NOESD,NORLD,NOXREF)\n*PROCESS USING(NOMAP,WARN(8))\n***********************************************************************\n*                                                                     *\n* MODULE NAME = TLMS                                                  *\n*                                                                     *\n* DESCRIPTIVE NAME = DISPLAY A VMF RECORD (CA/TLMS)                   *\n*                                                                     *\n* FUNCTION = THE TLMS PROGRAM READS THE VMF RECORD FOR THE FIRST      *\n*        VOLUME OF A TAPE DATA SET, FORMATS IT PRETTY MUCH LIKE       *\n*        THE CATLTSO COMMAND, THEN INVOKES BRIF TO DISPLAY THE        *\n*        RESULT.  MAY ONLY BE USED AS A LINE COMMAND ON THE DATA      *\n*        SET LIST PANEL (OPTION 3.4 OF ISPF/PDF).                     *\n*                                                                     *\n* STATUS = R202                                                       *\n*                                                                     *\n* AUTHOR = GILBERT SAINT-FLOUR <carlos@gsf-soft.com>                  *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = CA/TLMS                                           *\n*                   STRING MACRO                                      *\n*                                                                     *\n*    AUTHORIZATION = NONE                                             *\n*                                                                     *\n*    RESTRICTIONS = NONE                                              *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (BATCH PROGRAM)                            *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 4K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REUSABLE, RMODE 24, AMODE 24,                       *\n*                 PROBLEM STATE, KEY 8                                *\n*                                                                     *\n* CHANGES                                                             *\n*                                                                     *\n*201 TLMS 5.5 (VMF RECORDS CAN BE BLOCKED)                            *\n*202 TLMS 5.5 (VMF RECORDS MAY NOT NECESSARILY BE BLOCKED)            *\n*                                                                     *\n&VMFDSN  SETC  'CAI.TLMS.VMF'          <== DSNAME OF VMF              *\n***********************************************************************\nTLMS     CSECT\n         SAVE  (14,12),,'GSF UTILITIES - TLMS R202'\n         LR    R12,R15\n         USING TLMS,R12\n         GETMAIN R,LV=DYNAML,SP=2      DYNAMIC STORAGE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DYNAM,R13\n         ST    R13,DDATA               PARM FOR READ RTNE\n         TIME  DEC\n         STCM  R1,B'1111',TODAY        00YYDDDF\n         MVI   BLANKS,C' '\n         MVC   BLANKS+1(L'BLANKS-1),BLANKS\n*\n         CALL  ISPLINK,(VDEFINE,DSNVOL,DSNAME,FORMATL,LENL,LIST),VL\n         LTR   R15,R15\n         BNZ   QUIT16\n         CALL  ISPLINK,(VGET,DSNVOL),VL\n         LTR   R15,R15\n         BNZ   QUIT16\n         LA    R1,=A(S99RB+VL)\n         SVC   99                      ALLOCATE THE DATA SET\n         LTR   R15,R15\n         BNZ   QUIT16                  SVC99 FAILED, QUIT\n         PACK  WK1,VOLSER              030001\n         UNPK  WK2(6),WK1              UNPACK FOR CLC\n         OI    WK2+5,X'F0'             NO SIGN\n         CLC   WK2(6),VOLSER           NUMERIC VOLSER?\n         BNE   QUIT16                  NO, QUIT\n         OPEN  MF=(E,OPENLIST)\n         LTR   R15,R15\n         BNZ   QUIT16\n         CLC   DCB1BLKSI,=AL2(L'S3SEGREC) BLOCKED VMF?\n         BNE   *+8                     YES, JUMP\n         OI    BLKREF+3,1              NO, READ 2ND RECORD\n*\n*        READ FIRST BLOCK\n*\n         LA    R3,BUFFER               32K BUFFER\n         READ  DECB1,DI,DCB1,(R3),'S','S',BLKREF+1\n         CHECK DECB1                   WAIT FOR COMPLETION (OR SYNAD)\n         CLC   DCB1BLKSI,=AL2(L'S3SEGREC) BLOCKED VMF?\n         BE    *+8                     NO, JUMP\n         LA    R3,BUFFER+L'S3SEGREC    SKIP 1ST RECORD (CONTROL)\n         USING S3SEGSCT,R3\n         LH    R4,S3SEGNUM             MAX NUMBER OF SEGMENTS IN FILE\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS SEGMENT RECORDS TO DETERMINE THE                     *\n*        BLOCK NUMBER OF MY VMFBASE RECORD                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SLR   R5,R5                   BLOCK NUMBER\n*LOOP\nSCANSEG1 CLI   S3RECTYP,C'S'           IS THIS A SEGMENT RECORD?\n         BNE   QUIT16                  NO, QUIT\n         LA    R1,S3SEGTAB             POINT TO 1ST SEGMENT ENTRY\n         USING S3SEGENT,R1\n         LA    R2,S3SEGCNT             # OF SEGMENTS IN A VMFSEGMT\n*--LOOP\nSCANSEG4 SLR   R14,R14\n         ICM   R14,B'0111',S3SEGSFX    1ST VOLSER IN SEGMENT\n         SLR   R15,R15\n         ICM   R15,B'0111',S3NUMSFX    NUMBER OF VOLSERS IN SEGMENT\n         CVB   R0,WK1                  MY VOLSER\n         SR    R0,R14                  GET DIFFERENCE\n         BL    SCANSEG5                NOT IN THIS SEGMENT\n         CR    R0,R15                  ARE WE WITHIN IT?\n         BNH   SCANSEG9                YES, EXIT LOOP\nSCANSEG5 AR    R5,R15                  INCREMENT VOLSER COUNT\n         LA    R1,S3SEGENT+L'S3SEGENT  NEXT SEGMENT\n         BCT   R4,*+8                  DECREMENT SEGMENT COUNT\n         B     QUIT16                  VOLSER NOT FOUND IN TABLE\n         BCT   R2,SCANSEG4             NEXT SEGMENT IN CURRENT VMFSEGMT\n*--ENDLOOP\n         LA    R3,S3SEGREC+L'S3SEGREC  NEXT SEGMENT RECORD\n         B     SCANSEG1                NEXT VMFSEGMT\n*ENDLOOP\n         DROP  R1                      S3SEGTAB\nSCANSEG9 AR    R5,R0                   ADD DIFFERENCE\n         LA    R5,1(,R5)               ADD 1 MORE\n         AH    R5,S3SEGMAX             ADD # OF LAST SEGMENT RECORD\n*\n*        CONVERT RECORD NUMBER TO BLKREF/OFFSET\n*\n         SLR   R4,R4                   OFFSET=ZERO\n         CLC   DCB1BLKSI,=AL2(L'S3SEGREC) BLOCKED VMF?\n         BE    CALCBLK3                NO, JUMP\n         LA    R4,L'B3BSEREC           LRECL\n         MR    R4,R4                   MULT RECNO BY LRECL\n         LH    R0,DCB1+62              BLKSIZE\n         DR    R4,R0                   RECORDS PER BLOCK\nCALCBLK3 EQU   *\n         CL    R5,DCB1+16              BLKREF TOO HIGH?\n         BH    QUIT16                  YES, QUIT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        READ THE VMF RECORD FOR MY VOLSER                            *\n*        EDIT ITS CONTENTS INTO \"LINES\"                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         CL    R5,BLKREF               FIRST BLOCK?\n         BE    CLOSE1                  YES, SKIP READ\n         ST    R5,BLKREF               SAVE BLOCK NUMBER\n         READ  DECB1,DI,MF=E           READ VMF RECORD FOR MY VOLSER\n         CHECK DECB1                   WAIT FOR COMPLETION (OR SYNAD)\nCLOSE1   CLOSE MF=(E,OPENLIST)\n         LA    R5,BUFFER(R4)           START OF BASE RECORD\n         USING B3BSEREC,R5\n*\n         LA    R3,LINES                FIRST LINE\n         MVC   0(L'LINES,R3),BLANKS\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\n         MVC   WK1,=C'NO '             SCRATCH 1/3\n         TM    B3SRVSCR,C'1'           SCRATCH 1/3\n         BO    LINE1W                  SCRATCH 1/3\n         MVC   WK1,=C'YES'             SCRATCH 1/3\nLINE1W   STRING INTO=((R3),L'LINES),                                   X\n               '  VSN.....',B3VOLSER,  VOLSER                          X\n               '     SCRATCH.',(WK1,3), IN SERVICE, SCRATCH            X\n               '     CDS....',(B3CDSSEQ,H,R4Z), CTL DATA SET SEQNO     X\n               '     BASE VOLUME....',B3CHNVOL  1ST VOL\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\n         MVC   WK1,=C'OUT'             NOT IN SERVICE\n         CLI   B3SRVSCR,C'2'           CHECK STATUS\n         BH    LINE2W                  NO, JUMP\n         MVC   WK1,=C'IN '             IN SERVICE\nLINE2W   STRING INTO=((R3),L'LINES),                                   X\n               '  SERVICE.',(WK1,3),  IN SERVICE, SCRATCH              X\n               '   VOLSEQ.. ',(B3VOLSEQ,P,R3Z), VOL SEQNO              X\n               '   VOLCNT. ',(B3VOLCNT,P,R3Z),  VOL COUNT              X\n               '   FILESEQ. ',(B3FILSEQ,H,R4Z), FILE SEQNO             X\n               '   FILECNT. ',(B3FILCNT,H,R4Z)  FILE COUNT\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\n         MVC   0(L'LINES,R3),BLANKS\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\n         MVC   WK1,=C'ACTIVE  '\n         CP    TODAY,B3EXPDAT          DATA SET EXPIRED?\n         BH    LINE3W                  NO, JUMP\n         MVC   WK1,=C'EXPIRED '\nLINE3W   STRING INTO=((R3),L'LINES),2X,WK1,                            X\n               ' VERSION. ','000',     ???                             X\n               '  DSN. ',B3DSN         DATA SET NAME\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE4    STRING INTO=((R3),L'LINES),                                   X\n               '  LRECL... ',(B3RECSIZ,F,R5Z),                         X\n               '     BLKSIZE. ',(B3BLKSIZ,F,R5Z),                      X\n               '     RECFM.... ',B3RFM,                                X\n               '   LABEL. ',B3LABTYP\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE5    STRING INTO=((R3),L'LINES),                                   X\n               '  BLKCNT.. ',(B3BLKCNT,F,R7Z),                         X\n               '   CPU..... ',B3CPUSMF,                                X\n               '      ABEND... ',B3ABDFLG,                             X\n               '      DEN... ',B3DEN,                                  X\n               '      TRTCH. ',B3TAPMOD\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\n         MVC   0(L'LINES,R3),BLANKS\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE6    STRING INTO=((R3),L'LINES),                                   X\n               '  EXPDT... ',(B3EXPDAT,P,YY/MM/DD),                    X\n               '  KEEPDT.. ',(B3KEPDAT,P,YY/MM/DD),                    X\n               '  EXPIRED.. ',(B3EXPDAT,P,YY/MM/DD)\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE7    STRING INTO=((R3),L'LINES),                                   X\n               '  CJOB.... ',B3CREJOB, CREATION JOB                    X\n               '  CSTEP... ',B3CRESTP, CREATION STEP                   X\n               '  CDATE.... ',(B3CREDAT,P,YY/MM/DD) CREATION DATE\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE8    OI    B3CRETIM+L'B3CRETIM-1,15 NO SIGN\n         UNPK  WK1,B3CRETIM            00HHMMSS\n         MVC   WK1+0(2),WK1+2          HHHHMMSS\n         MVI   WK1+2,C':'              HH:HMMSS\n         MVC   WK1+3(2),WK1+4          HH:MMMSS\n         MVI   WK1+5,C':'              HH:HM:SS\n         STRING INTO=((R3),L'LINES),                                   X\n               '  CUNIT... ',B3CREDEV,5X, UNIT                         X\n               '  CTIME... ',WK1,      HH:MM:SS                        X\n               '  JACCT.... ',B3USR001 ACCOUNTING FIELD\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE9    STRING INTO=((R3),L'LINES),                                   X\n               '  IJOB.... ',B3LASJOB, LAST JOB                        X\n               '  IDATE... ',(B3LASDAT,P,YY/MM/DD), LAST DATE          X\n               '  IUNIT.... ',B3LASDEV\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\n         MVC   0(L'LINES,R3),BLANKS\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE10   STRING INTO=((R3),L'LINES),                                   X\n               '  CERTDT.. ',(B3CRTDAT,P,YY/MM/DD),                    X\n               '  CERTCNT. ',(B3CRTCNT,H,R4Z),4X,                      X\n               '  CLEANDT.. ',(B3CLNDAT,P,YY/MM/DD),                   X\n               '  CLEANCNT. ',(B3CLNCNT,H,R4Z)\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE11   STRING INTO=((R3),L'LINES),                                   X\n               '  ERG..... ',(B3ERGCNT,H,R4Z),4X,                      X\n               '  MAX-ERG. ',(B3ERGMAX,H,R4Z),4X,                      X\n               '  TMPRDERR. ',(B3REDERR,H,R4Z)\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE12   STRING INTO=((R3),L'LINES),                                   X\n               '  CLN-USE. ',(B3USECLN,H,R4Z),4X,                      X\n               '  CER-USE. ',(B3USECRT,H,R4Z),4X,                      X\n               '  LOC...... ',B3LOC    LOCATION\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\n*        USER-UPDATED FIELDS\n*\nLINE13   STRING INTO=((R3),L'LINES),                                   X\n               '  LOST.... ',B3LOSCDE,7X,                              X\n               '  PURCHDT. ',(B3BUYDAT,P,YY/MM/DD), PURCHASE DATE      X\n               '  TAPETYPE. ',B3TAPTYP,6X,                             X\n               '  VENDOR... ',B3VENDER MANUFACTURER\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE14   STRING INTO=((R3),L'LINES),                                   X\n               '  LENGTH.. ',(B3TAPLEN,H,R4Z),4X,                      X\n               '  DAMAGE.. ',B3DAMCDE,7X,                              X\n               '  DESTROY.. ',B3DESCDE,7X,                             X\n               '  DESTRYDT. ',(B3DESDAT,P,YY/MM/DD) DESTROYED DATE\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\n         MVC   0(L'LINES,R3),BLANKS\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE15   STRING INTO=((R3),L'LINES),                                   X\n               '  SCRDT... ',(B3SCRDAT,P,YY/MM/DD), DATE VOL SCRATCHED X\n               '  MOVEDT.. ',(B3MOVDAT,P,YY/MM/DD),                    X\n               '  EXPDT.... ',(B3CDSEXP,P,YY/MM/DD),                   X\n               '  KEEPDT... ',(B3CDSKEP,P,YY/MM/DD)\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\n         MVC   0(L'LINES,R3),BLANKS\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\n*        SHOW TODAY'S DATE FOR AIR-HEADS LIKE ME\n*\n         STRING INTO=((R3),L'LINES),'  TODAY... ',(TODAY,P,YY/MM/DD)\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\n         MVC   0(L'LINES,R3),BLANKS\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*---------------------------------------------------------------------*\n*                                                                     *\n*        INVOKE ISPF/PDF \"BRIF\" SERVICE                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         LA    R0,LINES                FIRST LINE\n         SLR   R2,R2\n         SLR   R3,R0                   LENGTH USED\n         D     R2,MAXLRECL             NUMBER OF LINES WRITTEN\n         ST    R3,MAXRECNO             NUMBER OF LINES WRITTEN\n         CALL  ISPLINK,(BRIF,DSNAME,RECFM,MAXLRECL,RADDR,,DDATA),VL\n*\nQUIT00   L     R13,4(,R13)\n         RETURN (14,12),RC=00\n*\nQUIT16   CLOSE MF=(E,OPENLIST)\n         L     R13,4(,R13)\n         RETURN (14,12),RC=16\n*------- ISPLINK CONSTANTS -------------------------------------------\nVDEFINE  DC    C'VDEFINE '             FUNCTION\nVGET     DC    C'VGET    '             FUNCTION\nDSNVOL   DC    C'(ZDLDSN ZDLVOL)'\nFORMATL  DC   2C'CHAR    '\nLENL     DC    AL4(L'DSNAME,L'VOLSER)\nLIST     DC    C'LIST    '\nBRIF     DC    C'BRIF    '             FUNCTION\nRECFM    DC    C'F '\nDSNAME   DS    CL44                    ZDLDSN\nVOLSER   DS    C'030001'               ZDLVOL\nRADDR    DC    A(READRTN)\nDDATA    DS    A(DYNAM)                BASE ADDRESS\nVL       EQU   X'80000000'\n*------- BLOCS POUR ALLOCATION DYNAMIQUE DES FICHIERS ----------------\nS99RB    DC    A(X'14010000',0,S99TUPL,0,0)\nS99TUPL  DC    A(S99T1,S99T2,S99T4+VL)\nS99T1    DC    AL2(1,1,6),C'CAIVMF'    DDNAME\nS99T2    DC    AL2(2,1,L'VMFDSN)       DSNAME\nVMFDSN   DC    C'&VMFDSN'\nS99T4    DC    AL2(4,1,1),X'08'        DISP=SHR\n         DROP\n***********************************************************************\n*                                                                     *\n*        READ ROUTINE (BRIF)                                          *\n*                                                                     *\n***********************************************************************\nREADRTN  SAVE  (14,12),,'READRTN'\n         LM    R4,R7,0(R1)             INPUT PARMS\n         LR    R11,R15\n         USING READRTN,R11\n         L     R12,0(,R7)              =A(DYNAM)\n         USING DYNAM,R12\n*\n         L     R3,0(,R6)               RECORD NUMBER (FROM BROWSE)\n         C     R3,MAXRECNO             BEYOND END OF FILE?\n         BH    GOBACK8                 YES, EXIT\n         BCTR  R3,0                    CALCULATE OFFSET\n         M     R2,MAXLRECL             CALCULATE OFFSET\n         LA    R3,LINES(R3)            CHANGE OFFSET TO ADDRESS\n         ST    R3,0(,R4)               PASS RECORD ADDRESS TO BRIF\n         RETURN (14,12),RC=00\n*\nGOBACK8  MVC   0(4,R6),MAXRECNO        RETURN MAX RECORD NUMBER\n         RETURN (14,12),RC=8\n*\nOPENLIST OPEN  DCB1,MF=L\nDCB1     DCB   DSORG=DA,MACRF=RIC,OPTCD=R,DDNAME=CAIVMF\nDCB1BLKSI EQU  DCB1+62,2,C'H'          BLKSIZE\nBLKREF   DC    F'0'                    BLOCK NUMBER\nMAXLRECL DC    A(L'LINES)\n*---------------------------------------------------------------------*\n*        DYNAMIC STORAGE                                              *\n*---------------------------------------------------------------------*\nDYNAM    DSECT\n         DS    18F\nTODAY    DS    PL4                     CVTDATE\nWK1      DS    D\nWK2      DS    D\nWK3      DS    D\nWK4      DS    D\nMAXRECNO DS    F                       MAX RECORD NUMBER\nBLANKS   DS    CL(L'LINES)\nLINES    DS    32CL81\n         DS    0D\nBUFFER   DS    XL32760                 32K BUFFER\nDYNAML   EQU   *-DYNAM\nISPLINK  CSECT\n         USING *,R15\n         ST    R1,24(,R13)\n         LOAD  EP=ISPLINK\n         LR    R15,R0\n         L     R1,24(,R13)\n         BR    R15\nS3       TLMVMF TYPE=SEG,DEFINE=YES,DSECT=YES\nB3       TLMVMF TYPE=BSE,DEFINE=YES,DSECT=YES\n         PRINT NOGEN\n         STRING GENERATE\n         YREGS\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=CAI.CAIMAC,DISP=SHR                           TLMVMF\n//         DD DSN=CBTTAPE.FILE183.PDS,DISP=SHR                  STRING\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//LKED    EXEC PGM=HEWL,PARM='MAP,REUS'\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=CBTTAPE.FILE183.LOAD(TLMS),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TMS": {"ttr": 22788, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//GILBERTT JOB (ACCT#),TMS50,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(NODECK,OBJECT,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = TMS                                                   *\n*                                                                     *\n* DESCRIPTIVE NAME = DISPLAY A TMC RECORD (CA1/TMS 5.0)               *\n*                                                                     *\n* FUNCTION = THE TMS PROGRAM READS THE TMC RECORD FOR THE FIRST       *\n*        VOLUME OF A TAPE DATA SET, FORMATS IT PRETTY MUCH LIKE       *\n*        THE CA1 TSO COMMAND, THEN INVOKES BRIF TO DISPLAY THE        *\n*        RESULT.  MAY ONLY BE USED AS A LINE COMMAND ON THE DATA      *\n*        SET LIST PANEL (OPTION 3.4 OF ISPF/PDF).                     *\n*                                                                     *\n* STATUS = R508                                                       *\n*                                                                     *\n* AUTHOR = GILBERT SAINT-FLOUR <carlos@gsf-soft.com>                  *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = CA1/TMS 5.0                                       *\n*                   STRING MACRO                                      *\n*                                                                     *\n*    AUTHORIZATION = NONE                                             *\n*                                                                     *\n*    RESTRICTIONS = NONE                                              *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (BATCH PROGRAM)                            *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 4K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REUSABLE, RMODE 24, AMODE 24,                       *\n*                 PROBLEM STATE, KEY 8                                *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n*  505  REDESIGN SCREEN LAYOUT TO LOOK LIKE CA1'S                     *\n*       TRANSLATE LTYPE,DEN,TRTCH,RECFM                               *\n*       SHOW ALL DATES AS YYYY-MM-DD                                  *\n*  506  FIX TWO ERRORS IN LINE14                                      *\n*  507  CHANGED EXPIRATION DATE TO LOOK LIKE CA'S ON LINE3            *\n*       CORRECTED CLNCNT.  IT WAS LOOKING AT A HALFWORD INSTEAD       *\n*         OF A SINGLE BYTE.                                           *\n*       ADDED FLAG5, ROBTY AND ROBID.                                 *\n*       ADDED CPGM AND LPGM.                                          *\n*       MOVED LAST COLUMN OVER 1 BECAUSE CPGM WAS SLAMMING UP AGAINST *\n*         LPGM LITERAL.                                               *\n*  508  BLOCKED TMC (DAVID QUINTON)                                   *\n*                                                                     *\n&TMCDSN  SETC  'CAI.CA1.TMC'                <== TMC DSNAME            *\n***********************************************************************\nTMS      CSECT\n         SAVE  (14,12),,'GSF UTILITIES - TMS R508'\n         LR    R12,R15\n         USING TMS,R12\n         GETMAIN R,LV=DYNAML           DYNAMIC STORAGE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DYNAM,R13\n*\n*        DEFINE VARIABLES, GET VOLSER (&ZDLVOL)\n*\n         CALL  ISPLINK,(VDEFINE,DSNVOL,DSNAME,FORMATL,LENL,LIST),VL\n         LTR   R15,R15\n         BNZ   QUIT16\n         CALL  ISPLINK,(VGET,DSNVOL),VL\n         LTR   R15,R15\n         BNZ   QUIT16\n         PACK  WK1,VOLSER              030001\n         OI    WK1+7,15                NO SIGN\n         UNPK  WK2(6),WK1+4(4)         GET S0C7 IF BAD\n         CLC   WK2(6),VOLSER           NUMERIC VOLSER?\n         BNE   QUIT16                  NO, QUIT\n*\n*        ALLOCATE & OPEN THE TAPE MANAGEMENT CATALOG (TMC)\n*\n         LA    R1,=A(S99RB+VL)\n         SVC   99                      ALLOCATE THE TMC DATA SET\n**       LTR   R15,R15\n**       BNZ   QUIT16                  SVC99 FAILED, QUIT\n         OPEN  MF=(E,OPENLIST)\n         LTR   R15,R15\n         BNZ   QUIT16\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS SEGMENT RECORDS TO DETERMINE THE                     *\n*        BLOCK NUMBER OF MY TMCBASE RECORD                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n*LOOP\nSCANSEG1 EQU   *\n         LA    R0,TMCBUFF              BUFFER\n         READ  DECB1,DI,DCB1,(R0),'S','S',BLKREF+1\n         CHECK DECB1                   WAIT FOR COMPLETION (OR SYNAD)\n         MVC   TMSCTL#1(256),TMCBUFF   COPY RECORD BUFFER TO TMS AREA\n         MVC   TMSCTL#1+256(TMCLRECL-256),TMCBUFF+256\n         CLC   =C'TMSCTL#1',TMSCTL#1   IS THIS THE RIGHT RECORD?\n         BNE   QUIT16                  NO, QUIT\n         CVB   R0,WK1                  MY VOLSER\n         LA    R1,H1VOLLOW             POINT TO 1ST VOL-SER RANGE\n         LH    R2,TMCEXTNT             MAX NUMBER OF VOL-SER RANGES\n*--LOOP\nSCANSEG4 CL    R0,000(,R1)             COMPARE TO H1VOLLOW (LOW-VOL)\n         BL    SCANSEG5                NOT IN THIS RANGE\n         CL    R0,004(,R1)             COMPARE TO H1VOLHGH (HIGH-VOL)\n         BNH   SCANSEG9                YES, EXIT LOOP\nSCANSEG5 LA    R1,012(,R1)             NEXT RANGE\n         BCT   R2,SCANSEG4             NEXT RANGE IN TMSCTL#1\n*--ENDLOOP\n         B     QUIT16                  VOLSER NOT FOUND, QUIT\n*\nSCANSEG9 AL    R0,008(,R1)             ADJUST BLK NUMBER\n         ST    R0,BLKREF               STORE RECORD NUMBER\n         XR    R0,R0                   CLEAR EVEN REGISTER FOR DR\n         LH    R1,DECB1+6              GET TMC BLOCK SIZE\n         LA    R3,TMCLRECL             GET TMC LRECL\n         DR    R0,R3                   DIVIDE BLKSIZE BY LRECL,\n*                                      GIVING RECORDS/BLOCK IN R1\n         LR    R3,R1                   COPY RECORDS/BLOCK\n         XR    R0,R0                   CLEAR EVEN REGISTER FOR DR\n         ICM   R1,B'1111',BLKREF       GET RECORD NUMBER\n         DR    R0,R3                   DIVIDE RECORDS BY RECORD/BLOCK\n*                                      GIVING BLOCK IN R1\n*                                      REMAINDER IN R0 - DEAL WITH\n         CL    R1,DCB1+16              IS IT TOO HIGH?\n         BH    QUIT16                  YES, QUIT\n         ST    R1,BLKREF               STORE BLOCK NUMBER\n         ST    R0,RECREF               STORE RECORD NUMBER\n*---------------------------------------------------------------------*\n*                                                                     *\n*        READ THE TMC RECORD FOR MY VOLSER                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         READ  DECB1,DI,MF=E           READ TMC RECORD FOR MY VOLSER\n         CHECK DECB1                   WAIT FOR COMPLETION (OR SYNAD)\n         LA    R0,TMCLRECL             GET TMC LRECL\n         L     R1,RECREF               GET RECORD NUMBER WITHIN BLOCK\n         MR    R0,R0                   MULTIPLY BY LRECL, GIVING OFFSET\n         LA    R1,TMCBUFF(R1)          GET A(TMC RECORD) W/IN TMC BLOCK\n         MVC   TMSCTL#1(256),0(R1)     COPY RECORD BUFFER TO TMS AREA\n         MVC   TMSCTL#1+256(TMCLRECL-256),256(R1)\n         CLOSE MF=(E,OPENLIST)\n*---------------------------------------------------------------------*\n*                                                                     *\n*        EDIT CONTENTS OF TMC RECORD INTO \"LINES\"                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         LA    R3,LINES                FIRST LINE\n         MVI   BLANKS,C' '\n         MVC   BLANKS+1(L'BLANKS-1),BLANKS\n*\nLINE1    TIME  DEC                     R1=00YYDDDF\n         ST    R1,WK1                  00YYDDDF\n         AP    WK1(4),=P'1900000'      1900123F\n         STRING INTO=((R3),L'LINES),                                   X\n               'VOLSER = ',TMVOLSER,                                   X\n               42X,'TODAY= ',(WK1,P,YYYY-MM-DD)\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE2    STRING INTO=((R3),L'LINES),                                   X\n               'DSN    = ',TMDSN,4X,                                   X\n               'DSN17= ',TMDSN17\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE3    TMMDATE OPEN,FMT='YYYY/DDD',ANCHOR=TMANCHOR,PARM=TMPARM\n         TMMDATE TO_PREFERRED,TODATE=EXPDT,FRDATE=TMEXPDT,             X\n               ANCHOR=TMANCHOR,PARM=TMPARM\n         STRING INTO=((R3),L'LINES),                                   X\n               'EXPDT  = ',EXPDT,                                      X\n               ' ACCT= ',TMUSER\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE4    MVC   WK2,=C'(...)   '\n         STRING INTO=((R3),L'LINES),                                   X\n               'FLAG1  = ',(TMFLAG1,1,X),' = ',WK2,35X,                X\n               'BATCHID= ',(TMVABTCH,,X),' = '\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE5    MVC   WK1,=C'(...)   '\n         STRING INTO=((R3),L'LINES),                                   X\n               'FLAG2  = ',(TMFLAG2,1,X),' = ',WK1,35X,                X\n               'HOOKID = ',(TMVAHOOK,,X),' = '\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE6    MVC   WK1,=C'(...)   '\n         STRING INTO=((R3),L'LINES),                                   X\n               'FLAG3  = ',(TMFLAG3,1,X),' = ',WK1,35X,                X\n               'EDMID  = ',TMEDMID\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE7    MVC   WK1,=C'(...)   '\n         MVC   WK2,=C'(...)   '\n         STRING INTO=((R3),L'LINES),                                   X\n               'FLAG4  = ',(TMFLAG4,1,X),' = ',WK1,35X,                X\n               'FLAG5  = ',(TMFLAG5,1,X),' = ',WK2\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE8    STRING INTO=((R3),L'LINES),                                   X\n               'CDATE  = ',(TMCRTDT,P,YYYY-MM-DD), DATE                X\n               ' CJOB   = ',TMJOBNM, CREATION JOB                      X\n               '  CTIME  = ',(TMCRTTI,P,R4Z), TIME                     X\n               '     CUNIT  = ',(TMCRUNI,,X)  UNIT\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE9    STRING INTO=((R3),L'LINES),                                   X\n               'LDATE  = ',(TMLASUSD,P,YYYY-MM-DD), DATE               X\n               ' LJOB   = ',TMLASUSJ,    LAST USE JOB                  X\n               '  LTIME  = ',(TMLASUST,P,R4Z), TIME                    X\n               '     LUNIT  = ',(TMUSUNI,,X)      UNIT\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE10   STRING INTO=((R3),L'LINES),                                   X\n               'CSTEP  = ',TMSTPNAM,        STEP                       X\n               '   CDDNAME= ',TMDDNAME,     CREATION DDNAME            X\n               '  CPGM   = ',TMCPGM,        CREATION PROGRAM           X\n               ' LPGM   = ',TMLPGM          LAST USE PROGRAM\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE11   STRING INTO=((R3),L'LINES),                                   X\n               'OUTDATE= ',(TMOUTDAT,P,YYYY-MM-DD), OUT-OF-AREA DATE   X\n               ' OUTCODE= ',TMOUTAR, OUT-OF-AREA CODE                  X\n               '      SLOT   = ',(TMSLOT,F,R6Z), SLOT                  X\n               '   TWERRC = ',(TMTWERRC,H,R5Z)   WRITE ERRORS\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE12   STRING INTO=((R3),L'LINES),                                   X\n               'BTHDATE= ',(TMBTHDT,P,YYYY-MM-DD), BIRTH DATE          X\n               ' VENDOR =',TMVENDOR,            VENDOR                 X\n               '   COUNT  = ',(TMUCOUNT,H,R5Z), TIMES TAPE OPENED      X\n               '    TRERRI = ',(TMTRERRI,H,R5Z) TEMP READ ERRORS\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE13   STRING INTO=((R3),L'LINES),                                   X\n               'DATECLN= ',(TMDATCLN,P,YYYY-MM-DD), DATE LAST CLEANED  X\n               ' USECLN = ',(TMUSECLN,H,R5Z), USE CNT AT LAST CLN      X\n               '     CLNCNT = ',(TMCLNCNT,FL1,R3Z), TIMES TAPE CLEANED X\n               '      TWERRI = ',(TMTWERRI,H,R5Z)   WRITE ERRORS\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE14   STRING INTO=((R3),L'LINES),                                   X\n               57X,'TRERRC = ',(TMTRERRC,H,R5Z)     TEMP READ ERRORS\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE15   STRING INTO=((R3),L'LINES),                                   X\n               'VOLSEQ = ',(TMVOLSEQ,H,R4Z),                           X\n               7X,'ROBTY  = ',(TMROBTY,H,R3Z),  TAPE IN ROBOT          X\n               7X,'ROBID  = ',(TMROBID,H,R3Z),  ROBOT ID               X\n               6X,'PRERRC = ',(TMPRERRC,H,R5Z)  PERM READ ERRORS\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE16   STRING INTO=((R3),L'LINES),                                   X\n               '1STVOL = ',TMFRSVOL, FIRST VOLSER                      X\n               '     NEXTVOL= ',TMNXTVOL, NEXT VOLSER                  X\n               '    PREVVOL= ',TMPRVVOL, PREVIOUS VOLSER               X\n               '   PWERRC = ',(TMPWERRC,H,R5Z)          WRITE ERRORS\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE17   STRING INTO=((R3),L'LINES),                                   X\n               'NUMDSNB= ',(TM#DSNBS,H,R4Z), NUMBER OF DSNBS           X\n               7X,'1STDSNB= ',(TMADSNB,F,R6Z),   FIRST DSNB            X\n               '    LSTDSNB= ',(TMALDSNB,F,R6Z),   LAST DSNB           X\n               '   PRERRI = ',(TMPRERRI,H,R5Z)  PERM READ ERRORS\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE18#  BAL   R1,LINE18B\n         DC    X'02',C'SL '\n         DC    X'0A',C'SUL'\n         DC    X'01',C'NL '\n         DC    X'04',C'NSL'\n         DC    X'10',C'BLP'\n         DC    X'40',C'AL1'\n         DC    X'48',C'AU1'\n         DC    X'C0',C'AL3'\n         DC    X'C8',C'AU3'\n         DC    X'00',0H'0'\nLINE18B  BAL   R14,SCAN_CLI            CALL SCAN RTNE\n         DC    Y(1+3)               0  LENGTH OF A TABLE ENTRY\n         CLI   TMLTYPE,*-*          2  TEST LABEL TYPE FLAGS\n         MVC   WK1,1(R1)            6  MOVE LABEL TYPE\n*\n         BAL   R1,LINE18C\n         DC    X'83',C'800 BPI '\n         DC    X'C3',C'1600 BPI'\n         DC    X'D3',C'6250 BPI'\n         DC    X'E3',C'38K BPI '\n         DC    X'E7',C'38K BPI '\n         DC    X'43',C'556 BPI '\n         DC    X'03',C'200 BPI '\n         DC    X'00',0H'0'\nLINE18C  BAL   R14,SCAN_CLI            CALL SCAN RTNE\n         DC    Y(1+8)               0  LENGTH OF A TABLE ENTRY\n         CLI   TMDEN,*-*            2  TEST DEN FLAGS\n         MVC   WK2,1(R1)            6  MOVE DEN\n*\n         BAL   R1,LINE18D\n         DC    X'80',C'9TK  '     NINE TRACK TAPE\n         DC    X'C0',C'18TK '     18 TRACK (CARTRIDGE)\n         DC    X'E0',C'36TK '     36 TRACK (CARTRIDGE)\n         DC    X'23',C'EVEN '     EVEN PARITY\n         DC    X'3B',C'BCD/E'     BCD/EBCDIC TRANSLATION\n         DC    X'13',C'DATAX'     DATA CONVERSION\n         DC    X'2B',C'EVENX'     EVEN PARITY AND TRANSLATION\n         DC    X'00',0H'0'\nLINE18D  BAL   R14,SCAN_CLI            CALL SCAN RTNE\n         DC    Y(1+5)               0  LENGTH OF A TABLE ENTRY\n         CLI   TMTRTCH,*-*          2  TEST TRTCH FLAGS\n         MVC   WK3,1(R1)            6  MOVE TRTCH\n*\nLINE18X  STRING INTO=((R3),L'LINES),                                   X\n               'LABEL  = ',(WK1,3),    LABEL TYPE                      X\n               8X,'DEN    = ',(WK2,8),  DENSITY                        X\n               '  TRTCH  = ',(WK3,5), TRTCH                            X\n               '    PWERRI = ',(TMPWERRI,H,R5Z)          WRITE ERRORS\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE19   BAL   R14,#RECFM1             CONVERT RECFM\n         STRING INTO=((R3),L'LINES),                                   X\n               'RECFM  = ',(WK1,5),    RECORD FORMAT                   X\n               '      LRECL  = ',(TMLRECL,F,L10),                      X\n               'BLKSIZE= ',(TMBLKSI,F,L8),                             X\n               ' BLKCNT = ',(TMBLKCNT,F,L)\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE20   STRING INTO=((R3),L'LINES),                                   X\n               'AUDATE = ',(TMVADATE,P,YYYY-MM-DD), UPDATE DATE        X\n               ' AUTIME = ',(TMVATIME,P,R4Z),     TIME                 X\n               '      USERID = ',TMVAUSER         USERID\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*\nLINE21   STRING INTO=((R3),L'LINES),                                   X\n               'AUCODE = ',(TMVACODE,,X),          AUDIT CODE          X\n               9X,'AUFLAG1= ',(TMVAFLG1,,X),                           X\n               8X,'CPUID  = ',TMVACPU              CPUID\n         LA    R3,L'LINES(,R3)         NEXT LINE\n*---------------------------------------------------------------------*\n*                                                                     *\n*        INVOKE ISPF/PDF \"BRIF\" SERVICE                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         LA    R0,LINES                FIRST LINE\n         SLR   R2,R2\n         SLR   R3,R0                   LENGTH USED\n         D     R2,MAXLRECL             NUMBER OF LINES WRITTEN\n         ST    R3,MAXRECNO             NUMBER OF LINES WRITTEN\n         ST    R13,DDATA               PARM FOR READ RTNE\n         CALL  ISPLINK,(BRIF,DSNAME,RECFM,MAXLRECL,RADDR,,DDATA),VL\n*\nQUIT00   L     R13,4(,R13)\n         RETURN (14,12),RC=00\n*\nQUIT16   CLOSE MF=(E,OPENLIST)\n         L     R13,4(,R13)\n         RETURN (14,12),RC=16\n*---------------------------------------------------------------------*\n*                                                                     *\n*        RECFM EDIT ROUTINE                                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n#RECFM1  MVC   WK1,BLANKS              INITIALIZE RECFM AREA\n         LA    R1,WK1                  START OF WORK AREA\n         MVI   0(R1),C'U'\n         TM    TMRECFM,DS1RECFU        RECFM=U?\n         BO    #RECFM2                 YES, JUMP\n         MVI   0(R1),C'F'\n         TM    TMRECFM,DS1RECFF        RECFM=F?\n         BO    #RECFM2                 YES, JUMP\n         MVI   0(R1),C'V'\n#RECFM2  TM    TMRECFM,DS1RECFB        RECFM=.B ?\n         BNO   #RECFM3                 NO, JUMP\n         MVI   1(R1),C'B'              .B\n         LA    R1,1(,R1)\n#RECFM3  TM    TMRECFM,DS1RECFS        RECFM=..S ?\n         BNO   #RECFM4                 NO, JUMP\n         MVI   1(R1),C'S'              ..S\n         LA    R1,1(,R1)\n#RECFM4  TM    TMRECFM,DS1RECFA        RECFM=...A ?\n         BNO   #RECFM5                 NO, JUMP\n         MVI   1(R1),C'A'              ...A\n#RECFM5  TM    TMRECFM,DS1RECMC        RECFM=...M ?\n         BNO   #RECFM6                 NO, JUMP\n         MVI   1(R1),C'M'              ...M\n#RECFM6  TM    TMRECFM,DS1RECFT        RECFM=...T ?\n         BNOR  R14                     NO, JUMP\n         MVI   1(R1),C'T'              ...T\n         BR    R14\n*---------------------------------------------------------------------*\n*        TABLE SCAN ROUTINE                                           *\n*---------------------------------------------------------------------*\n*LOOP\nSCAN_CLI IC    R15,0(,R1)              PICK UP MASK FOR \"TM\"\n         EX    R15,2(,R14)             EXECUTE TM UNSTRUCTION\n         BE    6(,R14)                 FOUND, GOBACK\n         AH    R1,0(,R14)              BUMP TABLE PTR\n         CLI   0(R1),0                 END OF TABLE?\n         BNE   SCAN_CLI                NEXT TABLE ENTRY\n*ENDLOOP\n         LA    R1,BLANKS               ALL BLANKS\n         B     6(,R14)                 NOT FOUND, GOBACK\n*------- ISPLINK CONSTANTS -------------------------------------------\nVDEFINE  DC    C'VDEFINE '             FUNCTION\nVGET     DC    C'VGET    '             FUNCTION\nDSNVOL   DC    C'(ZDLDSN ZDLVOL)'\nFORMATL  DC   2C'CHAR    '\nLENL     DC    AL4(L'DSNAME,L'VOLSER)\nLIST     DC    C'LIST    '\nBRIF     DC    C'BRIF    '             FUNCTION\nRECFM    DC    C'F '\nDSNAME   DS    CL44                    ZDLDSN\nVOLSER   DS    C'030001'               ZDLVOL\nRADDR    DC    A(READRTN)\nDDATA    DS    A(DYNAM)                BASE ADDRESS\nVL       EQU   X'80000000'\n*------- BLOCS POUR ALLOCATION DYNAMIQUE DES FICHIERS ----------------\nS99RB    DC    A(X'14010000',0,S99TUPL,0,0)\nS99TUPL  DC    A(S99T1,S99T2,S99T4+VL)\nS99T1    DC    AL2(1,1,6),C'CAITMC'    DDNAME\nS99T2    DC    AL2(2,1,L'TMCDSN)       DSNAME\nTMCDSN   DC    C'&TMCDSN'              TMC DSNAME\nS99T4    DC    AL2(4,1,1),X'08',0F'0'  DISP=SHR\nBLKREF   DC    F'0'                    BLOCK NUMBER (TMSCTL#1)\nDS1RECFF EQU   X'80'  10.. ....    F - FIXED LENGTH\nDS1RECFV EQU   X'40'  01.. ....    V - VARIABLE LENGTH\nDS1RECFU EQU   X'C0'  11.. ....    U - UNDEFINED LENGTH\nDS1RECFT EQU   X'20'  ..1. ....    T - TRACK OVERFLOW\nDS1RECFB EQU   X'10'  ...1 ....    B - BLOCKED\nDS1RECFS EQU   X'08'  .... 1...    FIXED LENGTH: (X'88')\nDS1RECFA EQU   X'04'  .... .10.    ANSI CONTROL CHARACTER\nDS1RECMC EQU   X'02'  .... .01.    MACHINE CONTROL CHARACTER\n         DROP\n***********************************************************************\n*                                                                     *\n*        READ ROUTINE (BRIF)                                          *\n*                                                                     *\n***********************************************************************\nREADRTN  SAVE  (14,12),,'READRTN'\n         LR    R11,R15\n         USING READRTN,R11\n         LM    R4,R7,0(R1)             INPUT PARMS\n         L     R12,0(,R7)              =A(DYNAM)\n         USING DYNAM,R12\n*\n         L     R3,0(,R6)               RECORD NUMBER (FROM BROWSE)\n         C     R3,MAXRECNO             BEYOND END OF FILE?\n         BH    GOBACK8                 YES, EXIT\n         BCTR  R3,0                    CALCULATE OFFSET\n         M     R2,MAXLRECL             CALCULATE OFFSET\n         LA    R3,LINES(R3)            CHANGE OFFSET TO ADDRESS\n         OC    0(L'LINES,R3),BLANKS    X'00'=>X'40'\n         ST    R3,0(,R4)               PASS RECORD ADDRESS TO BRIF\n         RETURN (14,12),RC=00\n*\nGOBACK8  MVC   0(4,R6),MAXRECNO        RETURN MAX RECORD NUMBER\n         RETURN (14,12),RC=8\n*----------------------------------------------------------------------\nOPENLIST OPEN  DCB1,MF=L\nDCB1     DCB   DSORG=DA,MACRF=RIC,OPTCD=R,DDNAME=CAITMC\nMAXLRECL DC    A(L'LINES)\n*----------------------------------------------------------------------\nDYNAM    DSECT\n         DS    18F\nWK1      DS    D\nWK2      DS    D\nWK3      DS    D\nEXPDT    DS    C'YYYY-MM-DD'           EXPDT/CATALOG\nMAXRECNO DS    F                       MAX RECORD NUMBER\nBLANKS   DS    CL(L'LINES)\n         TMMTMREC PREFIX=TM,DSECT=     CAI.CAIMAC\nEXDATA   TMMDATE EXPLODED_DATA\nTMANCHOR TMMDATE ANCHOR\nTMPARM   TMMDATE PARM\nLINES    DS    32CL81\nRECREF   DS    F'0'                    RECORD NUMBER\nTMCBUFF  DS    CL32767                 BUFFER FOR TMC RECORDS\nDYNAML   EQU   *-DYNAM\n         STRING GENERATE\n         YREGS\nISPLINK  CSECT\n         USING *,R15\n         ST    R1,24(,R13)\n         LOAD  EP=ISPLINK\n         LR    R15,R0\n         L     R1,24(,R13)\n         BR    R15\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=CAI.CA1.CAIMAC,DISP=SHR                     TMMTMREC\n//         DD DSN=CBTTAPE.FILE183.PDS,DISP=SHR                STRING\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//LKED    EXEC PGM=HEWL,PARM='MAP,NOREUS'\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=CBTTAPE.FILE183.LOAD(TMS),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TRIMMAC": {"ttr": 23043, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x03\\x11\\x00\\x00\\x00\\x90\\x10/\\x01\\x04\\x05/\\x15\\x11\\x02t\\x002\\x01Z\\xc3\\xc2\\xe3\\xf4\\xf6\\xf5@@@@'", "ispf": {"version": "03.17", "flags": 0, "createdate": "1990-04-12T00:00:00", "modifydate": "2004-02-21T15:11:00", "lines": 628, "newlines": 50, "modlines": 346, "user": "CBT465"}, "text": "//GILBERTT JOB (ACCT#),TRIMMAC,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(1,LT)\n//*\n//*     THIS PROGRAM CREATES A REDUCED-SIZE MACLIB THAT MAY BE\n//*     USED INSTEAD OF THE SYS1.MACLIB/SYS1.MODGEN CONCATENATION\n//*     TO IMPROVE THE PERFORMANCE OF THE ASSEMBLER.\n//*\n//*     THE \"TRIMMAC\" LIBRARY IS BUILT AS FOLLOWS:\n//*\n//*        1. SELECTED MACROS ARE READ FROM DDNAME \"SYSLIB\",\n//*           TRIMMED FROM PL/AS CODE AND OTHER COMMENT LINES,\n//*           THEN COPIED TO A TEMPORARY DATA SET.\n//*\n//*        2. THE SORT UTILITY IS INVOKED TO SORT THE MACROS\n//*           IN ASCENDING SEQUENCE OF THEIR SIZE.\n//*\n//*        3. THE SORTED MACROS ARE WRITTEN TO SYSPUNCH\n//*           AS AN IEBUPDTE SYSIN STREAM.\n//*\n//*        4. IEBUPDTE IS EXECUTED IN THE LAST STEP TO\n//*           LOAD THE MACROS INTO THE \"TRIMMAC\" LIBRARY,\n//*           THE SMALLEST MACROS BEING LOADED FIRST.\n//*\n//*    YOU MAY CUSTOMIZE THE MEMBER LIST AND THE INPUT\n//*    CONCATENATION TO ADD OTHER MACROS AND/OR MACRO\n//*    LIBRARIES, AS NEEDED.\n//*\n//*    USE THE \"TRIMMAC\" LIBRARY INSTEAD OF THE MACLIB/AMODGEN\n//*    CONCATENATION TO ASSEMBLE A PROGRAM AND COMPARE THE\n//*    BEFORE/AFTER VALUES FOR THE ELAPSED TIME, EXCP COUNT AND\n//*    I/O CONNECT TIME.  EXPECT SAVINGS OF 30 TO 60 PERCENT WHEN\n//*    \"TRIMMAC\" IS USED.\n//*\n//*    MY \"TRIMMAC\" PDS IS CURRENTLY ALLOCATED AS FOLLOWS:\n//*\n//*          UNIT=3390,SPACE=(CYL,(18,,18)),\n//*          DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920)\n//*\n//ASMH EXEC PGM=IEV90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\nTRIMMAC  CSECT\n         SAVE  (14,12),,'TRIMMAC &SYSDATE '\n         LR    R12,R15\n         USING TRIMMAC,R12\n         GETMAIN R,LV=DYNAML\n         ST    R1,8(,R13)\n         ST    R13,4(,R1)\n         LM    R13,R1,8(R13)           SET R13, RELOAD R1\n         USING DYNAM,R13\n         XC    TRTBL,TRTBL             BUILD TRT TABLE (FIRST BLANK)\n         MVI   TRTBL+C' ',C' '         BUILD TRT TABLE (FIRST BLANK)\n         MVI   TRTNBL,1                BUILD TRT TABLE (1ST NON-BLANK)\n         MVC   TRTNBL+1(255),TRTNBL    BUILD TRT TABLE (1ST NON-BLANK)\n         MVI   TRTNBL+C' ',0           BUILD TRT TABLE (1ST NON-BLANK)\n***********************************************************************\n*\n*        SECTION 1\n*\n*              READ MACRO NAMES FROM DDNAME=MEMBERS\n*              READ MACRO TEXT FROM DDNAME=SYSLIB\n*              WRITE SELECTED LINES TO DDN=SORTIN\n*              BUILD TABLE WITH THE NUMBER OF LINES FOR EACH MEMBER\n*\n***********************************************************************\n         OPEN  (MEMBERS,,SYSLIB,,SORTIN,OUTPUT,SYSPRINT,OUTPUT)\n         GETBUF SYSLIB,(R3)            GET A BUFFER FROM POOL\n         ST    R3,DECB1+12             STORE ITS ADDRESS INTO DECB\n         LA    R8,TABLE                START OF TABLE\n*LOOP\nL1GET    GET   MEMBERS                 GET A MACRO NAME\n         CLI   0(R1),C'*'              IS THIS A COMMENT LINE?\n         BE    L1GET                   YES, IGNORE IT\n         MVC   BLDLIST(4),=Y(1,12)     HEADER\n         MVC   MEMBER,0(R1)            MEMBER NAME\n         BLDL  SYSLIB,BLDLIST          LOCATE MEMBER\n         LTR   R15,R15\n         BNZ   L1NOTF                  NOT FOUND, ERROR\n         ZAP   RECNO,=P'0'             RESET COUNTER\n         ZAP   DWD,=P'0'               INIT COUNTER & FLAGS\n         FIND  SYSLIB,TTRN,C           POINT TO START OF MEMBER\n*--LOOP\nL1GETB   READ  DECB1,SF,SYSLIB,*-*,'S' READ A BLOCK\n         CHECK DECB1\n         L     R3,DECB1+12             BUFFER ADDRESS FROM DECB\n*----LOOP\nL1GETR   AP    RECNO,=P'1'             COUNT INPUT RECORDS\n         BAL   R14,SELECT              SELECT/SKIP RECORDS\n         B     L1NEXTR              +0 RECORD SHOULD BE IGNORED\n         PUT   SORTIN               +4 RECORD SHOULD BE WRITTEN\n         MVC   0(72,R1),0(R3)          MOVE RECORD\n         MVC   72(8,R1),MEMBER         MOVE MEMBER NAME\n         AP    DWD+4(4),=P'1'          COUNT WRITTEN RECORDS\nL1NEXTR  LH    R14,SYSLIB+82           R14 CONTAINS RECORD LENGTH\n         L     R15,DECB1+12            ADDRESS OF BUFFER\n         AH    R15,SYSLIB+62           ADD BLKSIZE FROM DCB\n         L     R1,DECB1+16             IOB ADDRESS FROM DECB\n         SH    R15,14(,R1)             SUBTRACT RESIDUAL COUNT\n         SLR   R15,R14                 LAST BYTE OF CURRENT BLOCK\n         BXLE  R3,R14,L1GETR           LOOP UNTIL END-OF-BLOCK\n*----ENDLOOP\n         B     L1GETB                  NEXT BLOCK\n*--ENDLOOP\nL1EOM    ZAP   DWD,DWD                 ANY LINES SELECTED?\n         BZ    L1NOTF                  NO, IGNORE\n         MVC   MESSAGE+08(8),MEMBER    BUILD PRINT RECORD\n         OI    DWD+7,15                NO SIGN\n         UNPK  MESSAGE+29(5),DWD+5(3)  BUILD PRINT RECORD\n         OI    RECNO+3,15              NO SIGN\n         UNPK  MESSAGE+59(5),RECNO+1(3) BUILD PRINT RECORD\n         PUT   SYSPRINT,MESSAGE        WRITE PRINT RECORD\n         MVC   0(4,R8),DWD+4           MOVE NUMBER OF LINES TO TABLE\n         LA    R8,4(,R8)               BUMP POINTER\nL1NOTF   B     L1GET                   NEXT SYSIN RECORD (MACRO NAME)\n*ENDLOOP\nL1EOD    CLOSE (MEMBERS,,SYSLIB,,SORTIN)\n         FREEPOOL MEMBERS\n         FREEPOOL SYSLIB\n***********************************************************************\n*        SECTION 2: UPDATE RECORDS TO ADD MACRO SIZE IN POS 81-84\n***********************************************************************\n         OPEN  (SORTIN,UPDAT)\n         LA    R8,TABLE-4              START OF TABLE\n*LOOP\nL2GET    GET   SORTIN\n         LTR   R3,R1                   PASS RECORD ADDRESS\n         BZ    L2EOD                   EOJ, EXIT\n         CLC   DWD,72(R3)              SAME MEMBER?\n         BE    L2PUT                   YES, JUMP\n         MVC   DWD,72(R3)              NO, KEEP NAME\n         LA    R8,4(,R8)               NEXT ENTRY IN TABLE\nL2PUT    MVC   80(4,R3),0(R8)          NUMBER OF LINES\n         PUTX  SORTIN                  REWRITE RECORD\n         B     L2GET\n*ENDLOOP\nL2EOD    CLOSE SORTIN\n         FREEPOOL SORTIN\n***********************************************************************\n*        SECTION 3: SORT MACROS BY SIZE, WRITE IEBUPDTE INPUT\n***********************************************************************\n         LINK  EP=SORT,PARAM=H0,VL=1   SORT WORK DATA SET\n         OPEN  (SORTOUT,,SYSPUNCH,OUTPUT)\n         MVI   DWD,0                   FIRST TIME\n*LOOP\nL3GET    GET   SORTOUT\n         LTR   R3,R1                   PASS RECORD ADDRESS\n         BZ    L3EOD                   EOJ, EXIT\n         CLC   DWD,72(R1)              SAME MEMBER?\n         BE    L3PUT                   YES, JUMP\n         MVC   DWD,72(R1)              NO, KEEP NAME\n         PUT   SYSPUNCH\n         MVC   0(13,R1),=C'./ ADD NAME= '\n         MVC   13(67,R1),12(R1)        BLANK OUT REST OF RECORD\n         MVC   12(8,R1),DWD            MOVE MEMBER NAME\nL3PUT    PUT   SYSPUNCH\n         MVC   0(80,R1),0(R3)          MOVE RECORD\n         B     L3GET\n*ENDLOOP\nL3EOD    CLOSE (SORTOUT,,SYSPUNCH,,SYSPRINT)\n         L     R13,4(,R13)\n         RETURN (14,12),RC=00\n*\n*        RECORD SELECTION ROUTINE\n*\nSELECT   TM    DWD,1                   MEND CARD FOUND YET?\n         BOR   R14                     YES, SKIP TEXT AFTER MEND CARD\n         TM    DWD,2                   CHECK CONTINUATION FLAG\n         BO    L1SKIP                  JUMP IF CONTINUED COMMENT\n         TM    DWD,4                   CHECK CONTINUATION FLAG\n         BO    L1CONT                  JUMP IF CONTINUED INSTRUCTION\n         CLI   0(R3),C'*'              ASM COMMENT\n         BE    L1SKIP                  JUMP IF ASM COMMENT LINE\n         CLI   1(R3),C'*'              MACRO COMMENT\n         BE    L1SKIP                  JUMP IF MACRO COMMENT LINE\n         CLI   0(R3),C'/'              IS THIS A JCL LINE?\n         BE    L1SKIP                  YES, IGNORE IT\n*\n         TRT   0(16,R3),TRTBL          FIND FIRST BLANK\n         BZ    L1CONT                  FAILED, WRITE RECORD\n         TRT   0(64,R1),TRTNBL         FIND FIRST NON-BLANK\n         BZ    L1CONT                  FAILED, WRITE RECORD\n         CLC   =C'MEND ',0(R1)         CHECK OPCODE\n         BNE   L1SPACE                 JUMP IF NOT 'MEND'\n         OI    DWD,1                   REMEMBER \"MEND\" CARD FOUND\nL1SPACE  CLI   0(R3),C' '              ANY LABEL ON THIS LINE?\n         BNE   L1CONT                  YES, WRITE IT\n         CLC   =C'SPACE ',0(R1)        CHECK OPCODE\n         BE    L1SKIP                  JUMP IF 'SPACE'\n         CLC   =C'EJECT ',0(R1)        CHECK OPCODE\n         BNE   L1CONT                  RECORD SHOULD BE WRITTEN\n*\nL1SKIP   NI    DWD,255-2               RESET CONTINUATION FLAG\n         CLI   71(R3),C' '             CHECK FOR A CONTINUATION\n         BER   R14                     QUIT WITH RC4 IF NO CONTINUATION\n         OI    DWD,2                   SET CONTINUATION FLAG\n         BR    R14                     GOBACK\n*\nL1CONT   NI    DWD,255-4               RESET CONTINUATION FLAG\n         CLI   71(R3),C' '             CHECK FOR A CONTINUATION\n         BE    4(,R14)                 GOBACK, WRITE RECORD\n         OI    DWD,4                   SET CONTINUATION FLAG\n         B     4(,R14)                 GOBACK, WRITE RECORD\nH0       DC    H'0'\nMESSAGE  DC   C' MEMBER 12345678 PROCESSED - 12345 RECORDS SELECTED OUT+\n                OF 12345'\nMEMBERS  DCB   DSORG=PS,MACRF=GL,DDNAME=MEMBERS,EODAD=L1EOD\nSYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,                      X\n               RECFM=FBA,LRECL=L'MESSAGE\nSYSPUNCH DCB   DSORG=PS,MACRF=PL,DDNAME=SYSPUNCH,RECFM=FB,LRECL=80\nSORTIN   DCB   DSORG=PS,MACRF=(GL,PL),DDNAME=SORTIN,EODAD=EOD11,       X\n               RECFM=FB,LRECL=72+8+4\nSORTOUT  DCB   DSORG=PS,MACRF=(GL,PL),DDNAME=SORTOUT,EODAD=EOD11\nEOD11    SLR   R1,R1\n         BR    R14\nSYSLIB   DCB   DSORG=PO,MACRF=R,DDNAME=SYSLIB,EODAD=L1EOM,             X\n               BUFNO=1,NCP=1,RECFM=FB,LRECL=80\n         YREGS\nDYNAM    DSECT\n         DS    18F\nDWD      DS    D\nRECNO    DS    PL4\nBLDLIST  DS    Y(1,12),CL8,4X          BLDL/FIND\nMEMBER   EQU   BLDLIST+4,8             BLDL/FIND\nTTRN     EQU   MEMBER+8,4              BLDL/FIND\nTRTBL    DS    XL256                   TRT TABLE (FIND FIRST BLANK)\nTRTNBL   DS    XL256                   TRT TABLE (FIND FIRST NON-BLANK)\nTABLE    DS    999PL4                  RECORD NUMBERS\nDYNAML   EQU   *-DYNAM\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//GO      EXEC PGM=LOADER,PARM=NOPRINT\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//SYSPRINT DD SYSOUT=*\n//SYSOUT   DD SYSOUT=*\n//SORTIN   DD UNIT=SYSALLDA,SPACE=(CYL,20),DSN=&&SORTIN\n//SORTOUT  DD DSN=*.SORTIN,VOL=REF=*.SORTIN,DISP=(OLD,DELETE)\n//SORTWK01 DD UNIT=SYSALLDA,SPACE=(CYL,25),DSN=&&SORTWK01\n//SYSPUNCH DD UNIT=SYSALLDA,SPACE=(CYL,20),DISP=(,PASS)\n//SYSIN    DD *\n SORT FIELDS=(81,4,CH,A),EQUALS\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR,           <== INPUT LIBRARY\n// UNIT=SYSALLDA,VOL=SER=Z5RES1\n//         DD DSN=SYS1.MODGEN,DISP=SHR,           <== INPUT LIBRARY\n// UNIT=SYSALLDA,VOL=SER=Z5RES1\n//         DD DSN=SYS1.SHASMAC,DISP=SHR           <== INPUT LIBRARY\n//* THESE ARE MY OWN LIBRARIES\n//         DD DSN=GILBERT.GSF.SOURCE,DISP=SHR     <== INPUT LIBRARY\n//MEMBERS  DD *\nABEND              MVS\nACB                DFP VSAM\nACBVS              DFP VSAM\nALESERV            BCP 3.1\nANTRQST            SDM\nANTRQSTL           SDM\nANTRQT1            SDM\nASASYMBP           MVS 5.1\nASAXWC             MVS 5.2\nATRFZQRY           OS/390 R3\nATRQUERY           OS/390 R3\nATTACH             MVS\nAXSET              MVS\nBLDL               DFP\nBPXYCONS           ESA510\nBPXYGIDN           ESA510\nBPXYGIDS           ESA510\nBPXYMNTE           ESA510\nBPXYPGPS           ESA510\nCALL               MVS\nCALLTSSR           TSO/E\nCAMLST             DFP\nCHECK              DFP\nCIRB               MVS\nCLOSE              DFP\nCSFCCVT            OS390R4\nCSVAPF             MVS/ESA 4.3\nCSVAPFAA           MVS/ESA 4.3\nCSVDLAA            OS/390 R3\nCSVDLCB            OS/390 R3\nCSVDYNEX           MVS/ESA 5.1\nCSVDYNL            OS/390 R3\nCSVEXAA            MVS/ESA 5.1\nCSVEXRET           MVS/ESA 5.1\nCSVQUERY           MVS/ESA 4.2\nCSVRTAA            OS/390 R4\nCSVRTLS            OS/390 R4\nCVT                MVS\nDCB                DFP\nDCBD               DFP\nDCBE               DFSMS/MVS\nDEBCHK             DFP\nDELETE             MVS\nDEQ                MVS\nDETACH             MVS\nDEVTYPE            DFP\nDOM\nDYNALLOC           MVS\nENDREQ             DFP VSAM\nENQ                MVS\nERASE              DFP VSAM\nESPIE              MVS\nESTAE              MVS\nEXCP               DFP\nEXLST              DFP VSAM\nEXLVS              DFP VSAM\nEXTRACT            BCP\nFEOV               DFP\nFIND               DFP BPAM\nFREEMAIN           MVS\nFREEPOOL           DFP\nGET                DFP\nGETBUF             DFP\nGETDSAB            MVS 3.1\nGETLINE            TSO\nGETMAIN            MVS\nGQSCAN             MVS\nGTSIZE             TSO\nIARRAX             MVS SRM\nIARRCE             MVS SRM\nIAZJSAB            MVS\nIAZXJSAB\nICHMM\nICHPRCVT           RACF\nICHSAFP            RACROUTE\nIDACBACB           DFP VSAM\nIDACB1             DFP VSAM\nIDACB2             DFP VSAM\nIDACB3             DFP VSAM\nIDAVSACB           DFP VSAM\nIDAVSCB3           DFP VSAM\nIDAVSOPT           DFP VSAM\nIDAVSRPL           DFP VSAM\nIDENTIFY           MVS\nIEAMETR            MVS ETR\nIECDDCE            MVS IOS\nIECDIOCM           MVS IOS\nIECDPPL            DFP PURGE PARM LIST\nIECDUCBC           MVS\nIECDUCBD           MVS\nIECDUCBE           MVS\nIECDUCBG           MVS\nIECDUCBT           MVS\nIECDUCBU           MVS\nIECSDSL1           DFP\nIEEBASEA           MVS MASTER SCHED RES DATA AREA\nIEECHAIN           MVS CSCB\nIEECUCM            MVS UNIT CONTROL MODULE\nIEESMCA            SMF\nIEFAJCTB           DFP JOB CONTROL BLOCK + ACCOUNT TABLE\nIEFALLCT           MVS\nIEFASCTB           DFP STEP CONTROL BLOCK\nIEFASIOT           DFP STEP I/O TABLE\nIEFDDSRV           MVS 5.2 DD SERVICES\nIEFDISMP           MVS 5.2 DD SERVICES\nIEFDISRC           MVS 5.2 DD SERVICES\nIEFJCTX            MVS JCT EXTENSION\nIEFJESCT           MVS\nIEFJFCBN           DFP\nIEFJFCBX           DFP\nIEFJSCVT           MVS\nIEFJSSIB           MVS\nIEFJSSOB           MVS\nIEFJSSVT           MVS\nIEFPRMLB           OS/390 R2\nIEFQMIDS           MVS SWA MANAGER\nIEFQMNGR           MVS SWA MANAGER\nIEFSCTX            MVS SCT EXTENSION\nIEFSJDKY\nIEFSSCS            CANCEL/STATUS\nIEFSSOB            MVS\nIEFSSOBH           MVS\nIEFSSREQ           MVS\nIEFSSSA            SMS\nIEFSSVI            BCP\nIEFTCT             SMF\nIEFTIOT1           MVS\nIEFUCBOB           MVS\nIEFZB4D0                      DYNALLOC REQUEST BLOCK\nIEFZB4D2                      DYNALLOC TEXT UNIT KEYS\nIEFZB4UV           MVS\nIEFZB505           DFP\nIEFZPMAP           OS/390 R2\nIEZATTCH           MVS\nIEZBITS            MVS BIT0-BIT7\nIEZDEB             DFP\nIEZIOB             DFP\nIEZJSCB            MVS\nIEZVX100\nIFAEDIDF           PRODUCT ENABLE/DISABLE\nIFBNTASM           MVS 5.1\nIFGACB             DFP VSAM\nIFGACBVS           DFP VSAM\nIFGRPL             DFP VSAM\nIFGRPLVS           DFP VSAM\nIGDSGD             SMS\nIGDVLD             SMS\nIGWCISM            DFP\nIHAACEE            RACF\nIHAARL             DFP\nIHAASCB            MVS\nIHAASSB            BCP\nIHAASVT            MVS\nIHAASXB            MVS\nIHACDE             MVS\nIHACSD             MVS\nIHADCBE            DFSMS/MVS\nIHADECB            DFP\nIHADFA             DFP\nIHADQE             MVS\nIHADSAB            DFP\nIHADVA             DFP\nIHAECVT            BCP\nIHAEPIE            MVS\nIHAETRI            MVS ETR\nIHAGDA             MVS CSV\nIHAIPA             OS/390 R2\nIHAIQE             MVS\nIHALDA             MVS CSV\nIHALLCB            MVS CSV LLA\nIHALLE             MVS\nIHALPDE            MVS\nIHAOUXB            SRM\nIHAPCCA            MVS\nIHAPDS             DFP\nIHAPSA             MVS\nIHAPSAE            R10\nIHARB              MVS\nIHARD              MVS\nIHARMPL            MVS (RESMGR)\nIHASCA             MVS SPIE/ESPIE CONTROL AREA\nIHASCB             MVS STAE CONTROL BLOCK\nIHASCCB            MVS SVC PROCESSOR\nIHASCVT            MVS\nIHASDWA            MVS\nIHASPQA            MVS\nIHASPQE            MVS\nIHASTCB            MVS\nIHASVC             MVS\nIHASVT             MVS\nIHATQE             MVS\nIHAUDA             DFP\nIHAXTLST           MVS\nIHBERMAC           DFP\nIHBINNRA           MVS\nIHBINNRB           MVS\nIHBINNRR           MVS\nIHBINNRX           MVS\nIHBOPLST           MVS\nIHBOPLTX           MVS/ESA\nIHBRDWRD           DFP BSAM/BPAM\nIHBRDWRS           DFP BSAM/BPAM\nIHB01              DFP\nIKJCPPL            TSO/E\nIKJECT             TSO/E\nIKJEESCB           TSO/E SEND PARMLIB\nIKJEFFDF           TSO/E DAIRFAIL\nIKJEFFMT           TSO/E\nIKJEFLWA           TSO/E\nIKJENDP            TSO/E\nIKJGTPB            TSO/E\nIKJIDENT           TSO/E\nIKJIOPL            TSO/E\nIKJKEYWD           TSO/E\nIKJLSD             TSO/E\nIKJNAME            TSO/E\nIKJPARM            TSO/E\nIKJPOSIT           TSO/E\nIKJPPL             TSO/E\nIKJPSCB            TSO/E\nIKJRB              MVS\nIKJRLGB            TSO/E\nIKJRLSA            TSO/E\nIKJSUBF            TSO/E\nIKJTAXE            TSO/E\nIKJTCB             MVS\nIKJTMPWA           TSO/E\nIKJTPL             TSO/E\nIKJTSB             TSO/E\nIKJTSMSG           TSO/E\nIKJTSVT            TSO/E\nIKJUPT             TSO/E\nIKTTCAST           TSO/VTAM\nIKTTSBX            TSO/VTAM\nILRASMVT           MVS\nIOSCHPD            OS390R7\nIOSCMXA            MVS 5.1\nIOSDSHID           MVS 4.3             OW13347\nIOSDUCBC           MVS\nIOSDUCBP           MVS\nIRAOUCB            MVS\nIRARASD            WLM 5.1\nIRARMCT            SRM 4.3\nIRASRMST           SRM 5.1\nIRAWMST            SRM HBB6606\nIRXEFPL            REXX EXTERNAL FUNCTION PARM LIST\nIRXENVB            REXX ENVIRONMENT BLOCK\nIRXENVT            REXX ENVIRONMENT TABLE (IRXANCHR)\nIRXEVALB           REXX EVALUATION BLOCK\nIRXEXTE            REXX EXTERNAL FUNCTION ENTRY POINTS\nIRXINSTB           REXX IN-STORAGE BLOCK\nIRXPACKT           REXX FUNCTION PACKAGE TABLE\nIRXPARMB           REXX PARAMETER BLOCK\nIRXSHVB            REXX SHARED VARIABLE REQ BLOCK\nIRXSUBCT           REXX SUBCOMMAND TABLE\nISGGVT             MVS        GRS\nISGPEL             MVS        GRS\nISGRIB             MVS        GRS\nISGRNLE            MVS        GRS\nISITMGD            DFP\nIVTCSM             OS390R3\nIVTDATSP           OS390R3\nIVTSTATA           OS390R3\nIWMCQRY            WORKLOAD MANAGER\nIWMPB              WORKLOAD MANAGER\nIWMPQRY            WORKLOAD MANAGER\nIWMSVDCR           WORKLOAD MANAGER\nIWMSVPCD           WORKLOAD MANAGER\nIWMSVPOL           WORKLOAD MANAGER\nIWMYCON            WORKLOAD MANAGER\nIXCMG              XCF ACCOUNTING\nIXCQUERY           XCF\nIXCYAMDA           XCF ACCOUNTING\nIXCYQUAA           XCF\nIXLMG              XES MEASUREMENTS\nIXLYAMDA           XES MEASUREMENTS\nIXLYNDE            XES MEASUREMENTS\nLINK               MVS\nLOAD               MVS\nLOCASCB            MVS\nLOCATE             DFP\nLSPACE             DADSM\nMGCR\nMODESET            MVS\nNOTE               DFP\nNUCLKUP            MVS        (SVCUPDTE)\nOBTAIN             DFP\nOPEN               DFP\nPGSER              MVS        PAGE SERVICES\nPOINT              DFP\nPOST               MVS\nPURGE              DFP\nPUT                DFP\nPUTLINE            TSO\nPUTX               DFP\nRACHECK            RACF\nRACINIT            RACF\nRACROUTE           MVS/SAF RACF\nRDJFCB             DFP\nREAD               DFP\nRELSE              DFP\nRESERVE            MVS\nRESMGR             ESA 4.1\nRETURN             MVS\nRPL                DFP VSAM\nRPLVS              DFP VSAM\nSAVE               MVS\nSCHEDIRB           MVS 4.3\nSCHEDXIT           MVS 4.1\nSETLOCK            MVS\nSETRP              MVS\nSHOWCB             DFP VSAM\nSPIE               MVS\nSPLEVEL            MVS\nSTACK              TSO/E\nSTAE               OS/360\nSTATUS             MVS\nSTAX               TSO/E\nSTCKCONV           MVS/ESA 4.1\nSTCKSYNC           MVS/ESA 4.1\nSTCOM              TSO/E\nSTFSMODE           TSO/E\nSTIMER             MVS\nSTIMERM            MVS\nSTLINENO           TSO/E\nSTORAGE            MVS\nSTTMPMD            TSO/E\nSVCUPDTE           MVS\nSWAREQ             DFP\nSYNADAF            DFP\nSYNADRLS           DFP\nSYNCH              MVS\nSYSEVENT           SRM\nSYSSTATE           MVS/ESA\nTCBTOKEN           MVS/ESA\nTCLEARQ            TSO/E\nTESTAUTH           MVS\nTESTCB             DFP VSAM\nTGET               TSO/E\nTIME               MVS\nTPUT               TSO/E\nTRKCALC            DFP\nTRUNC              DFP\nTTIMER             MVS\nUCBDEVN            MVS/ESA 4.3\nUCBINFO            MVS/ESA 4.2.2\nUCBLOOK            MVS/ESA 4.1\nUCBSCAN            MVS/ESA 4.1\nWAIT               MVS\nWRITE              DFP\nWTO                MVS\nXCTL               MVS\nYREGS              MVS R0-R15\n*\n*        THESE ARE MACROS FROM MY OWN LIBRARIES\n*\nSTRING             ---\n//*--------------------------------------------------------------------\n//LOADPROC PROC DS='GILBERT.TRIMMAC',            <== DSNAME\n//            UNIT=3390,                         <== UNIT NAME\n//          VOLSER=,                             <== VOL SER\n//         BLKSIZE=0                             <== BLOCK SIZE (SDB)\n//DELOLD  EXEC PGM=IEFBR14\n//DELOLD   DD DSN=&DS,UNIT=&UNIT,SPACE=(1,0),DISP=(MOD,DELETE)\n//*\n//LOAD    EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSIN    DD DSN=*.GO.SYSPUNCH,DISP=(OLD,PASS)\n//SYSUT2   DD DSN=&DS,DISP=(,CATLG,DELETE),\n// UNIT=&UNIT,\n// SPACE=(CYL,(20,1,20),RLSE,CONTIG),\n// VOL=SER=&VOLSER,\n// DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=&BLKSIZE)\n//SYSPRINT DD DUMMY\n//LOADPROC PEND\n//*--------------------------------------------------------------------\n//TRIMMAC  EXEC LOADPROC                          <== EXEC PROC\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNITAFF": {"ttr": 23299, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//GILBERTA JOB (ACCT#),UNITAFF,\n// NOTIFY=&SYSUID,\n//*RESTART=UNITAFF,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = UNITAFF                                               *\n*                                                                     *\n* DESCRIPTIVE NAME = Dynamically set UNIT=AFF for input tape files    *\n*                                                                     *\n* FUNCTION = This program was originally designed to reduce the       *\n*            number of tape drives used by user-submitted SAS jobs.   *\n*            It scans the SWA of the next step and changes some of    *\n*            the SIOT pointers to force all input tape data sets to   *\n*            use the same drive.                                      *\n*                                                                     *\n* STATUS = R101                                                       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*                                                                     *\n* DEPENDENCIES = MVS/XA, MVS/ESA, OS/390, z/OS                        *\n*                                                                     *\n* AUTHORIZATION = APF                                                 *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (BATCH PROGRAM)                            *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 3K                                                 *\n*                                                                     *\n*    ATTRIBUTES = NOREUS, RMODE ANY, AMODE 31,                        *\n*                 PROBLEM STATE, KEY ZERO                             *\n*                                                                     *\n* OPERATION = UNITAFF must be executed immediately before the step    *\n*             to process (SAS, SORT, or any other program that reads  *\n*             a variable number of tape files, one at a time).        *\n*                                                                     *\n*             Sample JCL:                                             *\n*                                                                     *\n*               //UNITAFF EXEC PGM=UNITAFF                            *\n*               //STEPLIB  DD DSN=SYS2.AUTHLIB,DISP=SHR               *\n*               //*                                                   *\n*               //STEP53  EXEC PGM=SAS                                *\n*               //OSIN     DD DSN=USER1.X,DISP=SHR                    *\n*               //         DD DSN=UPQE.DQE40530(-1),DISP=SHR          *\n*               //OSIN2    DD DSN=UPQR.DQR02150(0),DISP=SHR           *\n*               //OSIN3    DD DSN=USER1.X,DISP=SHR                    *\n*               //         DD DSN=UPBG.DBGA0240(-1),DISP=SHR          *\n*               //OSIN4    DD DSN=USER1.X,DISP=SHR                    *\n*               //         DD DSN=USER1.YY,DISP=SHR                   *\n*               //         DD DSN=UPQR.DQR02140(-1),DISP=SHR          *\n*                                                                     *\n*             This program only supports cataloged data sets;         *\n*             relative generation numbers are handled                 *\n*             correctly via the GDGNT.                                *\n*                                                                     *\n*             No distinction is made between 3420 and 3480 types,     *\n*             which will cause incorrect results if the input to      *\n*             a step is mixed.                                        *\n*                                                                     *\n*Changes:                                                             *\n* 101 Fix SWA=BELOW bug                                               *\n***********************************************************************\nUNITAFF  CSECT\nUNITAFF  RMODE ANY\n         SAVE  (14,12),,'GSF UTILITIES - UNITAFF R101'\n         LR    R12,R15                 base reg\n         USING UNITAFF,R12\n         LA    R0,DYNL\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)              CHAIN SAVE AREA\n         LR    R13,R1                  DYN ADDRESS\n         USING DYN,R13\n         LA    R0,DYN+72               CLEAR WORKING STORAGE TO X'00'\n         LA    R1,DYNL-72              CLEAR WORKING STORAGE TO X'00'\n         SLR   R15,R15                 CLEAR WORKING STORAGE TO X'00'\n         MVCL  R0,R14                  CLEAR WORKING STORAGE TO X'00'\n***********************************************************************\n*                                                                     *\n*        LOCATE TCB, JSCB, GDGNT.                                     *\n*        LOCATE SCT AND 1ST SIOT FOR NEXT STEP.                       *\n*                                                                     *\n***********************************************************************\n         L     R1,540(,0)              PSATOLD\n         L     R3,TCBJSCB-TCB(,R1)     GET THE ADDRESS OF MY JSCB\n         USING IEZJSCB,R3\n         L     R4,JSCBJCT              Address of JCT prefix\n         USING INJMJCT-16,R4\n         ICM   R1,B'0111',JCTGDGNT     3-BYTE SVA OF GDG NAME TABLE\n         BZ    NOGDGNT                 JUMP IF THERE IS NO GDGN TABLE\n         BAL   R9,SWAREQ               CONVERT SVA TO 31-BIT ADDRESS\n         ST    R1,GDGNTPTR             KEEP ADDRESS OF GDG NAMES TABLE\n*\nNOGDGNT  ICM   R1,B'0111',JSCSCTP      3-BYTE SVA OF CURRENT STEP'S SCT\n         BAL   R9,SWAREQ               CONVERT SVA TO 31-BIT ADDRESS\n         LR    R5,R1                   CURRENT STEP'S SCT ADDRESS\n         USING SCT,R5\n*\nNEXTSTEP ICM   R1,B'0111',SCTANSCT     LOAD 3-BYTE SVA OF NEXT SCT\n         BZ    RETURN                  RETURN IF THERE IS NO NEXT STEP\n         BAL   R9,SWAREQ               CONVERT SVA TO 31-BIT ADDRESS\n         LR    R5,R1                   ADDRESS OF NEXT STEP'S SCT\n         ICM   R1,B'0111',SCTFSIOT     LOAD 3-BYTE SVA OF 1ST SIOT\n         BZ    RETURN                  NO DD CARDS, RETURN\n***********************************************************************\n*                                                                     *\n*        LOOP THRU THE SIOT BLOCKS                                    *\n*                                                                     *\n***********************************************************************\nLOOPSIOT BAL   R9,SWAREQ               CONVERT SVA TO 31-BIT ADDRESS\n         LR    R6,R1                   ADDRESS OF SIOT\n         USING SIOT,R6\n         AP    SEQ#,=P'1'              INCREMENT CURRENT SEQ#\n         TM    SCTSBYT1,SIOTCCAT       CHECK FOR CONCATENATION\n         BO    TESTDISP                JUMP IF NO DDNAME\n         MVC   DDNAME,SCTDDNAM         KEEP DDNAME\n         SP    SEQ#,SEQ#               RESET DDSEQ\nTESTDISP OI    SEQ#+L'SEQ#-1,X'0F'     SUPPRESS SIGN\n         TM    SCTSBYT3,1              CHECK DISP=OLD\n         BNO   NEXTSIOT                JUMP IF NOT DISP=OLD\n         CLI   SCTUTYPE,C' '           CHECK UNIT NAME\n         BH    NEXTSIOT                JUMP IF THERE IS A UNIT NAME\n         TM    SCTSBYT1,SCTUNAFF       TEST UNIT=AFF BIT\n         BO    NEXTSIOT                JUMP IF UNIT=AFF ALREADY THERE\n         ICM   R1,B'0111',SCTPJFCB     LOAD 3-BYTE SVA OF JFCB\n         BAL   R9,SWAREQ               CONVERT SVA TO 31-BIT ADDRESS\n         LR    R7,R1                   ADDRESS OF JFCB\n         USING JFCB,R7                 DSNAME FROM JFCB\n         MVC   DSNAME,JFCBDSNM         MOVE DSN TO UNPROTECTED STORAGE\n         TM    JFCBIND1,JFCGDG         CHECK GDG INDICATOR\n         BNO   LOCATE                  JUMP IF NOT GDG\n*--------------------------------------------------------------------*\n*        IF THE CURRENT DATA SET IS A GDG, SCAN THE GDG NAMES TABLE\n*        FOR THE CURRENT APPARENT GEN (0), IF ANY.\n*--------------------------------------------------------------------*\nGDG000   ICM   R1,B'1111',GDGNTPTR     LOAD ADDR OF GDG NAMES TABLE\n         BZ    GDG100                  JUMP IF NO GDGNT\n         USING GDGNTABL,R1\nGDG010   SLR   R14,R14                 PREPARE IC\n         IC    R14,GDGNNO              GET NUMBER OF ENTRIES\nGDG015   CLC   GDGNGDG,DSNAME          COMPARE TABLE ENTRY W/ DSNAME\n         BNE   GDG030                  JUMP IF NOT THE SAME\n         LA    R0,GDGNGDGZ             GET PTR TO APPARENT GEN(0)\n         ST    R0,CTGWAGB              SET POINTER IN SVC 26 WORK AREA\n         OI    CTGOPTN3,CTGGDGL        SHOW CTGWAGB IS SET\n         B     GDG100                  EXIT GDGNT SCAN LOOP\nGDG030   LA    R1,GDGNGDG2             BUMP UP TO NEXT ENTRY IN BLOCK\n         BCT   R14,GDG015              LOOP UNTIL END OF BLOCK\n         ICM   R1,B'1111',GDGNNEXT     LOAD ADDR OF NEXT GDGNT BLOCK\n         BNZ   GDG010                  PROCESS NEXT BLOCK\n         NI    CTGOPTN3,255-CTGGDGL    SHOW CTGWAGB IS SET\n         DROP  R1                      GDGNTABL\nGDG100   LA    R1,DSNAME               1ST BYTE OF DSNAME\nGDG120   LA    R1,1(,R1)               BUMP UP TO NEXT BYTE\n         CLI   0(R1),C' '              CHECK FOR A SPACE\n         BNE   GDG120                  LOOP UNTIL END OF DSNAME\n         MVI   0(R1),C'('              DSNAME(\n         MVC   1(4,R1),JFCBELNM        DSNAME(0\nGDG125   LA    R1,1(,R1)               BUMP UP TO NEXT BYTE\n         CLI   0(R1),C' '              CHECK FOR A SPACE\n         BNE   GDG125                  LOOP UNTIL END OF GEN. NO.\n         MVI   0(R1),C')'              DSNAME(0)\n*--------------------------------------------------------------------*\n*        GET DEVICE TYPE INFORMATION FROM THE CATALOG.\n*        KEEP RELATIVE DD# IF IT IS THE FIRST TAPE DD IN THE STEP.\n*--------------------------------------------------------------------*\nLOCATE   LA    R0,DSNAME               DATA SET NAME\n         ST    R0,CTGENT               ENTRY ADDRESS\n         OI    CTGOPTN1,CTGNAME        CTGENT POINTS TO ENTRY NAME\n         LA    R0,CTGWA                WORK AREA FOR SUPERLOCATE\n         ST    R0,CTGWKA               WORK AREA FOR SUPERLOCATE\n         OI    CTGOPTN3,CTGSUPLT       SUPER LOCATE\n         OI    CTGOPTN3,CTGAM0         OS/VS2 CATALOG MGMT REQUEST\n         LA    R0,CTGVL                GET ADDR OF VOLUME LIST\n         ST    R0,CTGWAVL              UPDATE PTR\n         LA    R0,CTGVLLEN             GET LENGTH OF VOLUME LIST\n         STH   R0,CTGWALV              UPDATE LENGTH\n         LOCATE CTGPL                  ISSUE SUPERLOCATE\n         LTR   R15,R15\n         BNZ   NEXTSIOT                JUMP IF DATA SET NOT CATALOGED\n         CLI   CTGVLDEV+2,X'80'        CHECK DEVICE CLASS\n         BNE   NEXTSIOT                JUMP IF NOT A TAPE\n         OC    TAPE1,TAPE1             CHECK 1ST TIME\n         BNZ   NOTFIRST                JUMP IF NOT 1ST TIME\n         MVC   TAPE1,SCTDDINO          KEEP DD# FOR 1ST TAPE DD\n         MVC   DDNAME1,DDNAME          KEEP DDNAME\n         UNPK  DDSEQ1,SEQ#             KEEP DDSEQ\n         B     NEXTSIOT                JUMP IF 1ST TAPE DD\n*--------------------------------------------------------------------*\n*        UPDATE THE SIOT IF THIS IS NOT THE FIRST TAPE IN THE STEP.\n*--------------------------------------------------------------------*\nNOTFIRST MODESET KEY=ZERO\n         MVC   SCTUSADD,TAPE1          MOVE DD# OF 1ST TAPE DD\n         OI    SCTSBYT1,SCTUNAFF       SET UNIT=AFF BIT\n         MODESET KEY=NZERO\n         UNPK  DDSEQ,SEQ#              MOVE DDSEQ\n         WTO   MF=(E,WTO1L)            NOTIFY PROGRAMMER\n*--------------------------------------------------------------------*\n*        LOCATE NEXT SIOT BLOCK, CHECK FOR LAST ONE.\n*--------------------------------------------------------------------*\nNEXTSIOT ICM   R1,B'0111',SCTPSIOT     SVA OF NEXT SIOT\n         BNZ   LOOPSIOT                PROCESS NEXT DD CARD IN STEP\n         DROP  R5,R6,R7                SCT, SIOT, JFCB\n***********************************************************************\n*                                                                     *\n*        CLEAN-UP, RETURN TO CALLER.                                  *\n*                                                                     *\n***********************************************************************\nRETURN   LA    R0,DYNL\n         LR    R1,R13                  DYN ADDRESS\n         L     R13,4(,R13)             CALLER'S SAVE AREA\n         FREEMAIN R,LV=(0),A=(1)      FREE DYNAMIC STORAGE\n         RETURN (14,12),RC=0\n***********************************************************************\n*        SUB-ROUTINE TO ACCESS THE SWA MANAGER                        *\n***********************************************************************\nSWAREQ   LA    R2,CTGVL                WORK AREA\n         ST    R2,EPAPTR               STORE POINTER\n         USING ZB505,R2\n         XC    SWAEPAX,SWAEPAX         CLEAR 32 BYTES\n         STCM  R1,B'0111',SWVA         STORE 3-BYTE SVA\n         MODESET MODE=SUP              SWITCH TO SUPERVISOR MODE\n         SWAREQ FCODE=RL,EPA=EPAPTR,MF=(E,SWAREQL1)\n         MODESET MODE=PROB             SWITCH BACK TO PROBLEM PGM MODE\n         L     R1,SWBLKPTR             LOAD SWA CONTROL BLOCK ADDRESS\n         BR    R9\n         DROP  R2                      WAS ZB505\n***********************************************************************\n*        CONTROL BLOCKS FOR LOCATE & WTO.                             *\n***********************************************************************\n&STR     SETC  (126)' '\nWTO1L    WTO   '&STR',MF=L,ROUTCDE=14\n         ORG   WTO1L+4\n         DC    C'UNITAFF: '\nDDNAME   DC    CL8' ',C' +'            DDNAME FOR CURRENT TAPE DD\nDDSEQ    DS    C'000'                  DD SEQ# FOR CURRENT TAPE DD\n         DC    C' USES SAME UNIT AS '  DDNAME FOR 1ST TAPE DD\nDDNAME1  DC    CL8' ',C' +'            DDNAME FOR 1ST TAPE DD\nDDSEQ1   DC    C'000'                  DD SEQ# FOR 1ST TAPE DD\n         ORG   ,\nSEQ#     DC    P'000'                  SEQ#\n*---------------------------------------------------------------------\n*        DYNAMIC STORAGE AREA, BASED BY R13.\n*---------------------------------------------------------------------\nDYN      DSECT\n         DS    18F\nSWAREQL1 SWAREQ MF=L                   PARM LIST FOR SWAREQ\nEPAPTR   DS    F                       POINTER TO EPA (ZB505)\nGDGNTPTR DS    F                       POINTER TO GDG NAMES TABLE\nTAPE1    DS    XL2                     INTERNAL DD# FOR 1ST TAPE DD\nDSNAME   DS    CL44                    MODIFIABLE DSNAME\n*---------------------------------------------------------------------*\n*        CATALOG PARAMETER LIST\n*---------------------------------------------------------------------*\nCTGPL    DS    0D\nCTGOPTN1 DS    B              FIRST OPTION BYTE:\nCTGNAME  EQU   X'04' .... .1..  CTGENT CONTAINS DSNAME OR SERIAL ADDR\nCTGOPTN2 DS    B              SECOND OPTION BYTE\nCTGOPTN3 DS    B     XXX. ....  SPECIFIES THE CALLER-REQUESTED FUNCTION\nCTGSUPLT EQU   X'10' ...1 ....  SUPERLOCATE FUNCTION\nCTGGDGL  EQU   X'08' .... 1...  GDG LOCATE - CALLER SUPPLIED BASE LEVEL\nCTGAM0   EQU   X'01' .... ...1  OS/VS2 CATALOG MANAGMENT REQUEST\nCTGOPTN4 DS    B              FOURTH OPTION BYTE\nCTGLBASE EQU   X'80' 1... ....  LOCATE BASE LEVEL (SUPERLOCATE GDG)\nCTGENT   DS    A              ADDRESS OF CATALOG RECORD IDENTIFIER\nCTGCAT   DS    A              ADDRESS OF CATALOG DSNAME OR ACB\nCTGWKA   DS    A              ADDRESS OF CALLER'S WORK AREA\nCTGOPTNS DS    B              CATALOG MANAGMENT SERVICES REQUEST OPTION\n         DS    B              RESERVED\nCTGTYPE  DS    C              TYPE OF CATALOG RECORD\nCTGNOFLD DS    FL1            NUMBER OF ENTRIES IN CTGFIELD\nCTGFDBK  DS    XL2            FEEDBACK AREA (IF NOT SUPERLOCATE)\nCTGFBFLG DS    B              FLAGS (SUPERLOCATE)\nCTGPAR   EQU   X'80' 1... ....  PARALLEL MOUNT\nCTGKEEP  EQU   X'40' .1.. ....  FORCED KEEP\nCTGGDGB  EQU   X'20' ..1. ....  GDG BASE LOCATED\nCTGNGDSN EQU   X'10' ...1 ....  GDG DSNAME GENERATED (DSNAME.GXXXXVYY)\n         DS    B              RESERVED (SUPERLOCATE)\nCTGPSWD  DS    A              ADDRESS OF CALLER-SUPPLIED PASSWORD\n*---------------------------------------------------------------------*\n*        CATALOG WORK AREA\n*---------------------------------------------------------------------*\nCTGWA    DS    0D\nCTGWAVL  DS    A                       PTR TO CTGVL (VOLUME LIST)\nCTGWALV  DS    H                       LENGTH OF THE VOLUME LIST\nCTGWAVCT DS    H                       # OF VOLSERS RETURNED IN VL\nCTGWAUCT DS    H                       MINIMUM # OF VOLS TO BE MOUNTED\nCTGWAGCT DS    H                       # OF GENERATIONS CATALOGED\nCTGWAGB  DS    A                       PTR TO APPARENT GEN(0)\n*---------------------------------------------------------------------*\n*        CATALOG VOLUME LIST\n*---------------------------------------------------------------------*\nCTGVL    DS    0D\nCTGVLVOL DS    CL6                     VOLUME SERIAL\nCTGVLDEV DS    XL4                     DEVICE TYPE\nCTGVLSEQ DS    H                       FILE SEQ#\nCTGVLX   DS    19XL12                  VOLUME LIST EXTENSION\nCTGVLLEN EQU   *-CTGVL                 LENGTH OF VOLUME LIST\nDYNL     EQU   *-DYN\n*---------------------------------------------------------------------\n*        GDG NAMES TABLE MAPPING (USING IEFZB902 AS A MODEL)\n*---------------------------------------------------------------------\n**       SYS1.MODGEN(IEFZB429)\nGDGNTABL DSECT\nGDGNQSVA DS    XL3                     SVA OF NEXT GDGNT RECORD\nGDGNTID  DS    X'23'                   GDGNT ID X'23'\nGDGNNEXT DS    A                       IN-CORE ADDRESS OF NEXT RECORD\nGDGNGDG  DS    CL35                    GDG BASE\nGDGNGDGZ DS    C'1234'                 APPARENT (0) GENERATION\nGDGNGDG2 DS    CL35,C'1234'            2ND GDG NAME\n         DS    CL35,C'1234'            3RD GDG NAME\n         DS    CL35,C'1234'            4TH GDG NAME\nGDGNNO   DS    FL1                     NUMBER OF ENTRIES\n         DS    XL15                    FILLER\nGDGNLEN  EQU   GDGNTABL+176\n*---------------------------------------------------------------------\n*        MAPPING MACROS FROM SYS1.MACLIB\n*---------------------------------------------------------------------\n         YREGS                         REGISTER EQUATES\n         IEFZB505 LOCEPAX=YES          EPA MAPPING FOR SWAREQ\n         EJECT\n         IEFJESCT TYPE=DSECT           JES CONTROL TABLE\n         EJECT\n*---------------------------------------------------------------------\n*        MAPPING MACROS FROM SYS1.MODGEN\n*---------------------------------------------------------------------\n         IKJTCB LIST=YES               TASK CONTROL BLOCK\n         EJECT\n         IEZJSCB ,                     JOB STEP CONTROL BLOCK\n         EJECT\nJCT      DSECT\n         IEFAJCTB ,                    JOB CONTROL BLOCK\n*JCTSWAUP EQU 1                        X'01' IN JCTSTAT2, FOR MVS/370\n         EJECT\nSCT      DSECT\n         IEFASCTB ,                    STEP CONTROL BLOCK\n         EJECT\nSIOT     DSECT\n         IEFASIOT ,                    STEP I/O TABLE\n         EJECT\nJFCB     DSECT\n         IEFJFCBN LIST=YES             JOB FILE CONTROL BLOCK\n         EJECT\n         CVT   LIST=NO,DSECT=YES       COMMUNICATION VECTOR TABLE\n         END\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,5)\n//*\n//LKED    EXEC PGM=HEWL,PARM='MAP,AC=1'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,DELETE)\n//SYSLMOD  DD DSN=GILBERT.LOAD(UNITAFF),DISP=SHR\n//*\n//UNITAFF EXEC PGM=UNITAFF\n//STEPLIB  DD DSN=GILBERT.LOAD,DISP=SHR\n//SYSUDUMP DD SYSOUT=*\n//OSIN     DD DSN=GILBERT.UNITAFF1,DISP=SHR\n//*\n//STEP53  EXEC PGM=IEFBR14\n//OSIN     DD DSN=GILBERT.UNITAFF1,DISP=SHR\n//         DD DSN=GILBERT.UNITAFF2,DISP=SHR\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "USERCMDS": {"ttr": 23306, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x06\\x004\\x00\\x92\\x19\\x1f\\x01\\t%/\\t8\\x01\\x8e\\x00\\xdf\\x00\\xc3\\xc3\\xc2\\xe3\\xf4\\xf7\\xf8@@@@'", "ispf": {"version": "05.06", "flags": 0, "createdate": "1992-07-09T00:00:00", "modifydate": "2009-09-09T09:38:34", "lines": 398, "newlines": 223, "modlines": 195, "user": "CBT478"}, "text": "//GILBERTC JOB (ACCT#),USERCMDS,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,REGION=4M\n//**********************************************************************\n//*                                                                    *\n//*    This job creates the USERCMDS command table                     *\n//*    from a set of in-line commands.                                 *\n//*                                                                    *\n//*    Check existing tables with the ISPF/PDF 3.9 option              *\n//*                                                                    *\n//*    If USERCMDS conflicts with an existing table, try SITECMDS      *\n//*                                                                    *\n//*    http://gsf-soft.com/Freeware/USERCMDS.shtml                     *\n//*                                                                    *\n//**********************************************************************\n//LOADCMDS EXEC PGM=IKJEFT01\n//*--------------------------------------------------------------------*\n//*                                                                    *\n//*        UPDATE THESE DSNAMES FOR YOUR SITE                          *\n//*                                                                    *\n//*--------------------------------------------------------------------*\n//ISPMLIB  DD DSN=ISP.SISPMENU,DISP=SHR               <== MESSAGES\n//ISPTLIB  DD DSN=ISP.SISPTENU,DISP=SHR               <== TABLES\n//*\n//SYSEXEC  DD DSN=CBTTAPE.FILE183.PDS,DISP=SHR        <== EXECUTE CMD\n//*\n//ISPTABL  DD DSN=userid.ISPF.ISPPROF,DISP=SHR        <== OUTPUT\n//*\n//ISPPROF  DD UNIT=VIO,SPACE=(800,(1,1,1)),DISP=(,PASS),\n//            RECFM=FB,LRECL=80,BLKSIZE=800\n//ISPPLIB  DD DSN=*.ISPPROF,DISP=(OLD,DELETE),VOL=REF=*.ISPPROF\n//ISPSLIB  DD DSN=*.ISPPROF,DISP=(OLD,DELETE),VOL=REF=*.ISPPROF\n//*\n//SYSTSPRT DD SYSOUT=*\n//ISPLOG   DD SYSOUT=*,RECFM=F,LRECL=121\n//SYSTSIN  DD  *\nISPSTART CMD(%EXECUTE EXEC)            /* Execute in-line REXX exec */\ntable='USERCMDS'                         /* table name (xxxxCMDS) */\n  /*******************************************************************/\n  /*                Create new command table                         */\n  /*******************************************************************/\nADDRESS 'ISPEXEC'\n\"TBCREATE\" table,\n  \"NAMES(ZCTVERB ZCTTRUNC ZCTACT ZCTDESC)\",\n  \"WRITE REPLACE LIBRARY(ISPPROF)\"\nIF RC > 0 THEN SIGNAL SPFERROR\n  /*******************************************************************/\n  /*             read table entries from //updates dd                */\n  /*******************************************************************/\nADDRESS TSO,\n  \"EXECIO * DISKR UPDATES (FINIS STEM updates.\"\n  /*******************************************************************/\n  /*             load table entries into new table                   */\n  /*******************************************************************/\nDO I = 1 TO updates.0\n  line=STRIP(LEFT(updates.I,72))\n  SAY line\n  PARSE VAR line ZCTVERB ZCTTRUNC ZCTACT\n  I=I+1\n  line=LEFT(updates.I,72)\n  SAY line\n  ZCTDESC=STRIP(line)\n  \"TBADD\" table\n  IF RC > 0 THEN SIGNAL SPFERROR\nEND\n\n\"TBCLOSE\" table \"LIBRARY(ISPTABL)\"\nIF RC > 0 THEN SIGNAL SPFERROR\n\nEXIT\n\nSPFERROR:\n  IF ZERRMSG \\= '' THEN \"LOG MSG(\"ZERRMSG\")\"\n  EXIT 12\n//*---------------------------------------------------------------------\n//*\n//*       THESE ARE THE COMMANDS THAT WILL BE LOADED\n//*       INTO THE xxxxCMDS TABLE.\n//*\n//*---------------------------------------------------------------------\n//UPDATES  DD  *\nBOOKMGR  5 SELECT CMD(%BOOKMGR)\n           BOOK-MANAGER/READ\nBR       0 SELECT PGM(FASTPATH) PARM(BROWSE,&ZPARM)\n           FAST PATH COMMAND: BROWSE\nCLIST    0 SELECT PGM(FASTPATH) PARM(E,&ZUSER..CLIST(&ZPARM),STD)\n           EDIT \"USERID.CLIST\"\nCNTL     0 SELECT PGM(FASTPATH) PARM(CNTL,&ZPARM,CNTL)\n           EDIT ISPCTL0 DATA SET, EVEN IF VIO\nCONNECT  4 SELECT PGM(FASTPATH) PARM(WSCON)\n           ESTABLISH CONNECTION TO THE WORK-STATION\nCRASH    0 SELECT PGM(FASTPATH) PARM(CRASH,&ZPARM)\n           QUICK EXIT FROM ISPF\nDITTO    3 SELECT CMD(%NEWAPPL DITTO) NEWAPPL(DUT)\n           INVOKE DITTO/MVS DIALOGS\nDUMPMSTR 5 SELECT CMD(%NEWAPPL M4DM &ZPARM)\n           DUMP-MASTER (MACRO 4)\nD2X      0 SELECT PGM(FASTPATH) PARM(REXXT,SAY D2X(&ZPARM))\n           FAST PATH COMMAND: DEC-TO-HEX CONVERSION\nED       0 SELECT PGM(FASTPATH) PARM(EDIT,&ZPARM)\n           FAST PATH COMMAND: EDIT\nENQ      0 SELECT CMD(ENQ) MODE(FSCR)\n           ENQ COMMAND\nEXEC     0 SELECT PGM(FASTPATH) PARM(E,&ZUSER..EXEC(&ZPARM),STD)\n           EDIT \"USERID.EXEC\"\nFM       2 SELECT CMD(%NEWAPPL FM) NEWAPPL(FMN)\n           IBM File Manager\nFSHELP   3 SELECT PGM(FASTPATH) PARM(TSOFS,HELP &ZPARM)\n           FULL-SCREEN TSO HELP\nFSPASTE  0 SELECT PGM(FASTPATH) PARM(FSPASTE)\n           FULL-SCREEN PASTE\nFSPRINT  4 SELECT PGM(FASTPATH) PARM(TSOFS,PRINT IDS('%DSNAME') DUMP\n           FULL-SCREEN PRINT\nHANDBOOK 5 SELECT PGM(FASTPATH) PARM(B,GILBERT.HANDBOOK(&ZPARM))\n           ON-LINE MACRO LISTING\nHSM      0 SELECT CMD(%NEWAPPL HSM) NEWAPPL(HSM)\n           INVOKE HSM DIALOGS\nICQ      0 SELECT CMD(%NEWAPPL ICQ) NEWAPPL(ICQ)\n           INVOKE TSO/E DIALOGS\nICS      0 SELECT PGM(FASTPATH) PARM(ICS,&ZPARM)\n           FAST PATH COMMAND: ICS\nIND$FILE 0 SELECT CMD(IND$FILE &ZPARM) MODE(FSCR)\n           PC/3270\nIPADDR   0 SELECT PGM(FASTPATH) PARM(TSOFS,%IPADDR)\n           DISPLAY IP ADDRESS OF TCP/IP TERMINAL\nIPCS     4 SELECT CMD(%NEWAPPL IPCS) NEWAPPL(BLSG)\n           INVOKE IPCS COMMAND\nISMF     0 SELECT CMD(%NEWAPPL ISMF) NEWAPPL(DGT)\n           IBM Storage Management Facility\nJCL      0 SELECT PGM(FASTPATH) PARM(E,&ZUSER..JCL(&ZPARM),STD)\n           EDIT \"USERID.JCL\"\nLC       0 SELECT PGM(FASTPATH) PARM(TSOFS,LISTCAT ENT('%DSNAME') ALL)\n           FULL-SCREEN LISTCAT\nLINKMAP  5 SELECT PGM(FASTPATH) PARM(TSOCMD,%LINKMAP '%DSNAME')\n           GSF-SOFT LINKMAP\nLISTBC   5 SELECT CMD(LISTBC &ZPARM) MODE(FSCR)\n           FULL SCREEN TSO LISTBC\nLM       2 SELECT PGM(FASTPATH) PARM(TSOCMD,%LINKMAP '%DSNAME')\n           GSF-SOFT LINKMAP\nLMCOPY   3 SELECT PANEL(LMCOPY) NEWAPPL(ISR)\n           ISSUE LMCOPY COMMAND\nLOAD     0 SELECT PGM(FASTPATH) PARM(LOAD,&ZPARM)\n           MAKE A PROGRAM RESIDENT IN MEMORY\nLOCK     0 SELECT CMD(LOCKTERM) MODE(FSCR)\n           LOCK TSO TERMINAL\nLOGOFF   5 SELECT PGM(FASTPATH) PARM(CRASH,LOGOFF)\n           QUICK LOGOFF OUT OF ISPF\nLOGON    0 SELECT PGM(FASTPATH) PARM(CRASH,LOGON &ZPARM)\n           QUICK LOGOFF OUT OF ISPF\nMACLIB   3 SELECT PGM(FASTPATH) PARM(MACLIB,&ZPARM,STD)\n           FAST PATH COMMAND: VIEW MACLIB/MODGEN MACRO\nMSGS     0 SELECT PGM(FASTPATH) PARM(E,&ZUSER..MSGS(&ZPARM),STD)\n           EDIT \"USERID.MSGS\"\nNETSTAT  4 SELECT PGM(FASTPATH) PARM(NETSTAT,&ZPARM)\n           FAST PATH COMMAND: FULL-SCREEN NETSTAT\nNEWAPPL  4 SELECT CMD(%NEWAPPL &ZPARM)\n           GSF TEST\nOPENCMDS 5 SELECT PGM(FASTPATH) PARM(OPENCMDS,&ZPARM)\n           FAST PATH COMMAND: OPEN CMD TABLE\nPANELS   4 SELECT PGM(FASTPATH) PARM(E,&ZUSER..PANELS(&ZPARM),STD)\n           EDIT \"USERID.PANELS\"\nPARMLIB  5 SELECT PGM(FASTPATH) PARM(PARMLIB,&ZPARM,STD)\n           FAST PATH COMMAND: EDIT SYS1.PARMLIB\nPDF      0 SELECT PANEL(ISR@PRIM) OPT(&ZPARM) NEWAPPL(ISR)\n           PDF MAIN MENU\nPDS      0 SELECT CMD(%NEWAPPL PDS)\n           PDS UTILITY\nRACF     0 SELECT CMD(%NEWAPPL RACF) NEWAPPL(RACF)\n           INVOKE RACF DIALOGS\nRECEIVE  4 SELECT CMD(RECEIVE &ZPARM) MODE(FSCR)\n           TSO INTERACTIVE TRANSMIT/RECEIVE FACILITY\nREXXTRY  5 SELECT PGM(FASTPATH) PARM(REXXTRY,&ZPARM)\n           FAST PATH COMMAND: TRY A REXX EXEC\nRMFMON   3 SELECT CMD(RMFMON &ZPARM) MODE(FSCR)\n           RMF\nRMM      0 SELECT CMD(%NEWAPPL RMM) NEWAPPL(EDG)\n           INVOKE DFSMSRMM INTERFACE\nSDSF     2 SELECT PGM(FASTPATH) PARM(SDSF,&ZPARM)\n           FAST PATH COMMAND: SDSF\nSEND     0 SELECT CMD(%GSFSEND &ZPARM) NEWAPPL(ISR)\n           FULL SCREEN TSO SEND\nSHOWDASD 5 SELECT CMD(%SHOWDASD &ZPARM) NEWAPPL(ISR)\n           INVOKE SHOWDASD DIALOG\nSHOWJPAQ 5 SELECT PGM(FASTPATH) PARM(TSOFS,SHOWJPAQ)\n           Invoke SHOWJPAQ Command in TSOFS Mode\nSHOWMVS  5 SELECT CMD(SHOWMVS &ZPARM) MODE(FSCR)\n           INVOKE SHOWMVS PROGRAM\nSHOWZOS  5 SELECT CMD(SHOWZOS &ZPARM) MODE(FSCR)\n           Invoke SHOWzOS Utility Program\nSKELS    4 SELECT PGM(FASTPATH) PARM(E,&ZUSER..SKELS(&ZPARM),STD)\n           EDIT \"USERID.SKELS\"\nSMPE     3 SELECT CMD(%NEWAPPL SMPE) NEWAPPL(GIM)\n           INVOKE SMP/E DIALOGS\nSYSID    0 SELECT PGM(FASTPATH) PARM(SYSID,&ZPARM)\n           DISPLAY SYSTEM ID AND SCREEN NUMBER ON EVERY PANEL\nTASID    0 SELECT PGM(TASID) PARM(&ZPARM) NEWAPPL(ISR)\n           DOUG NADEL'S TASID PROGRAM\nTIME     0 SELECT PGM(FASTPATH) PARM(TIME)\n           DISPLAY TIME AND DATE\nTSOFS    4 SELECT PGM(FASTPATH) PARM(TSOFS,&ZPARM)\n           FULL-SCREEN TSO COMMAND\nUNLOAD   0 SELECT PGM(FASTPATH) PARM(UNLOAD,&ZPARM)\n           REMOVE A PROGRAM FROM MEMORY\nUTIL     2 SELECT PGM(FASTPATH) PARM(UTIL,&ZPARM)\n           FAST PATH COMMAND: PDF UTILITIES\nVI       0 SELECT PGM(FASTPATH) PARM(VIEW,&ZPARM)\n           FAST PATH COMMAND: VIEW\nVERASE   0 SELECT PGM(FASTPATH) PARM(VERASE,&ZPARM)\n           REMOVE VARIABLES FROM THE PROFILE\nWHOAMI   3 SELECT CMD(%WHOAMI &ZPARM)\n           DISPLAY SYSTEM ID AND USER ID IN LARGE LETTERS\nWP       0 SELECT PGM(FASTPATH) PARM(WP,&ZPARM)\n           FAST PATH COMMAND: ISPF WORKPLACE\nXMIT     0 SELECT CMD(%GSFXMIT &ZPARM) NEWAPPL(ISR)\n           FULL SCREEN TSO XMIT\nX2D      0 SELECT PGM(FASTPATH) PARM(REXXT,SAY X2D(&ZPARM))\n           FAST PATH COMMAND: HEX-TO-DEC CONVERSION\nZDEL     0 SELECT PGM(FASTPATH) PARM(ZDEL,&ZPARM)\n           DISPLAY/SET COMMAND DELIMITER\n/*\n//\n//         Optional commands\n//\nCA1      0 SELECT CMD(%NEWAPPL CA1) NEWAPPL(TMS)\n           INVOKE CA-1 ISPF INTERFACE\nCCCA     0 SELECT CMD(%NEWAPPL CCCA) NEWAPPL(ABJ)\n           COBOL CONVERSION\nCZXMSG   0 SELECT PGM(CZX2PMID) PARM(&ZPARM) NOFUNC\n           DISPLAY MVS-MS MESSAGE\nDDLIST   0 SELECT PGM(ISRDDN) NEWAPPL(ISR) SUSPEND SCRNAME(DDLIST)\n           FULL SCREEN TSO LISTALC\nDOC      0 SELECT PGM(PGMEDBRO) PARM(E,DOC,&ZPARM,TEXT)\n           EDIT A DOCLIB MEMBER\nELIPS    3 SELECT CMD(%NEWAPPL LIBR) NEWAPPL(LIB@)\n           INVOKE LIBRARIAN /ELIPS PANELS\nEPIC     0 SELECT CMD(%NEWAPPL EPIC) NEWAPPL(EPIC)\n           INVOKE EPIC/MVS PANELS\nFAULT    2 SELECT CMD(%NEWAPPL FAULT) NEWAPPL(IDI)\n           IBM FAULT ANALYSER\nFILEAID  5 SELECT CMD(%NEWAPPL FILEAID &ZPARM)\n           FILEAID UTILITY (COMPUWARE)\nIPT      0 SELECT PGM(PGMEDBRO) PARM(E,IPT,&ZPARM,STD)\n           EDIT A DJCLIPT MEMBER\nJOBTRAC  4 SELECT CMD(%NEWAPPL JOBTRAC) NEWAPPL(LJT)\n           INVOKE JOBTRAC APPLICATION\nLIBR     3 SELECT CMD(%NEWAPPL LIBR) NEWAPPL(LIB@)\n           INVOKE LIBRARIAN /ELIPS PANELS\nMAIL     0 SELECT CMD(%NEWAPPL MAIL) NEWAPPL(MAIL)\n           TSO/MAIL\nMEMOS    4 SELECT PGM(PGMEDBRO) PARM(E,MEMO,&ZPARM,TEXT)\n           EDIT A MEMO\nOMEGAMON 4 SELECT CMD(%NEWAPPL OMEG)\n           OMEGAMON\nPCS      2 SELECT PANEL(PCS@PRIM) OPT(&ZPARM)\n           PRISM-CS PRIMARY MENU\nPDB      0 SELECT CMD(%APPLPDB SITE(&ZPARM) ) NEWAPPL(CZXG)\n           CORTEX-PDB V5R2M1\nPDSMATCH 4 SELECT CMD(%PDSMATCH) NEWAPPL(ISR)\n           MIKE NEWELL'S PDSMATCH DIALOG\nPGM      0 SELECT CMD(%XYZ2L053 &ZPARM) NEWAPPL(CZX)\n           INVOKE PROGRAM MANAGEMENT PANEL OUTSIDE MVS-MS\nPRINTWAY 6 SELECT CMD(%NEWAPPL PRINTWAY) NEWAPPL(ANF)\n           IP PRINTWAY\nQW       0 SELECT CMD(%NEWAPPL QW &ZPARM)\n           MVS/QUICKREF\nRDR      0 SELECT PGM(PGMEDBRO) PARM(E,RDR,&ZPARM,STD)\n           EDIT A DJCLRDR MEMBER\nSAR      0 SELECT CMD(%NEWAPPL SAR &ZPARM) NEWAPPL(SAR)\n           INVOKE SYSOUT ARCHIVAL AND RETRIEVAL SYSTEM\nSCRIPT   3 SELECT PGM(ISRFPR) PARM((ISRFP09) 9) NEWAPPL(ISR) NEWPOOL\n           ISSUE SCRIPT COMMAND\nSELECT   0 SELECT &ZPARM\n           GSF TEST\nSTARTOOL 6 SELECT CMD(%NEWAPPL STARTOOL)\n           STARTOOL UTILITY (SERENA)\nSYSVIEW  4 SELECT CMD(%NEWAPPL SYSVIEW)\n           PREVAIL/XP (ALIAS SYSVIEW, PCOMMAND)\nTEL      0 SELECT PGM(FASTPATH) PARM(B,GSFSOFT.GSF-ENV.TEXT(TEL))\n           BROWSE THE TELEPHONE DIRECTORY\nTEXT     0 SELECT PGM(FASTPATH) PARM(E,&ZUSER..TEXT(&ZPARM),STD)\n           EDIT \"USERID.TEXT\"\nTLMS     0 SELECT CMD(%NEWAPPL TLMS) NEWAPPL(TLMS)\n           INVOKE TLMS PANELS (NO SPLIT SCREEN)\nTXT      0 SELECT PGM(PGMEDBRO) PARM(E,TXT,&ZPARM,STD)\n           EDIT A DTXTPRMT MEMBER\nUSL      0 SELECT PGM(PGMEDBRO) PARM(E,USL,&ZPARM,STD)\n           EDIT A USERLIB MEMBER\nVOLS     0 SELECT CMD(%GSFVOLS &ZPARM) NEWAPPL(ISR)\n           VOLS COMMAND\n\n//         More optional commands in FASTPATH format\n//         You have to convert them to the above format to use them\n\n         ISPCMDS VERB=CMDList,                                         X\n               TRUNC=4,                                                X\n               ACT='SELECT CMD(%CMDLIST &&ZPARM)',                     X\n               DESC='Display ISPF PROFILE Commands'\n*\n         ISPCMDS VERB=CMDMaint,                                        X\n               TRUNC=4,                                                X\n               ACT='SELECT CMD(%CMDMAINT &&ZPARM)',                    X\n               DESC='Maintain ISPF PROFILE Commands'\n*\n*        ISPCMDS VERB=EJes,\n*              TRUNC=2,\n*              ACT='SELECT CMD(%@EJES,&&ZPARM) NEWAPPL(EJEP)',\n*              DESC='(E)JES SYSOUT Viewing'\n*\n         ISPCMDS VERB=FLASHer,                                         X\n               TRUNC=5,                                                X\n               ACT='SELECT CMD(%FLASHER,&&ZPARM) NEWAPPL(TFLP)',       X\n               DESC='OMS-Flash SYSOUT Viewing'\n*\n         ISPCMDS VERB=IPCS,                                            X\n               ACT='SELECT CMD(%@IPCS &&ZPARM) NOCHECK LANG(CREX)',    X\n               DESC='IBM IPCS Problem Analysis tool'\n*\n         ISPCMDS VERB=ISPF,                                            X\n               ACT='SELECT PGM(ISPSTRT) PARM(&&ZPARM) NEWAPPL(ISR)',   X\n               DESC='Stack ISPF'\n*\n         ISPCMDS VERB=ISMF,                                            X\n               ACT='SELECT CMD(%ISMF &&ZPARM) NOCHECK LANG(CREX)',     X\n               DESC='IBM Storage Management Facility tool'\n*\n         ISPCMDS VERB=JCLlib,                                          X\n               TRUNC=3,                                                X\n               ACT='SELECT PGM(FASTPATH) PARM(JCLLIB,&&ZPARM,STD)',    X\n               DESC='Fast Path Command: JCLLIB'\n*\n         ISPCMDS VERB=MXI,                                             X\n               ACT='SELECT CMD(%CBTSTUFF MXI &&ZPARM)',                X\n               DESC='MVS Extended Information'\n*\n         ISPCMDS VERB=MXIDS,                                           X\n               TRUNC=4,                                                X\n               ACT='SELECT CMD(%CBTSTUFF MXI DS &&ZPARM)',             X\n               DESC='MVS Extended Information, Dataset Utility'\n*\n         ISPCMDS VERB=MUcmd,                                           X\n               TRUNC=2,                                                X\n               ACT='SELECT CMD(%MU &&ZPARM) NEWAPPL(ISP)',             X\n               DESC='Invoke Member Utility REXX against a PDS'\n*\n         ISPCMDS VERB=PDS,                                             X\n               ACT='SELECT PGM(PDS) PARM(PDS &&ZPARM ISPMODE)',        X\n               DESC='Call CBT PDS Command'\n*\n         ISPCMDS VERB=PROClib,                                         X\n               TRUNC=4,                                                X\n               ACT='SELECT PGM(FASTPATH) PARM(PROCLIB,&&ZPARM,STD,E)', X\n               DESC='Fast Path Command: View PROCLIB Member'\n*\n         ISPCMDS VERB=RLISTa,                                          X\n               TRUNC=5,                                                X\n               ACT='SELECT CMD(%RLISTA &&ZPARM VIEW(TRUE))',           X\n               DESC='View Dataset Allocations'\n*\n         ISPCMDS VERB=RMFiii,                                          X\n               TRUNC=3,                                                X\n               ACT='SELECT CMD(RMFSTART &&ZPARM) MODE(FSCR)',          X\n               DESC='RMF III Start Command'\n*\n         ISPCMDS VERB=SMPe,                                            X\n               TRUNC=3,                                                X\n               ACT='SELECT CMD(%SMPE VERSION(CURRENT) &&ZPARM)',       X\n               DESC='Current version of SMP/E'\n*\n         ISPCMDS VERB=USS,                                             X\n               ACT='SELECT CMD(%USS &&ZPARM) NEWAPPL(BPX)',            X\n               DESC='Display USS@PRIM Panel and allocate USS DSNs'\n*\n         ISPCMDS VERB=GRoup,                                           X\n               TRUNC=2,                                                X\n               ACT='SELECT PANEL(GRP@PRIM) OPT(&&ZPARM)',              X\n               DESC='Display GRP@PRIM Panel'\n*\n         ISPCMDS VERB=USer,                                            X\n               TRUNC=2,                                                X\n               ACT='SELECT PANEL(USR@PRIM) OPT(&&ZPARM)',              X\n               DESC='Display USR@PRIM Panel'\n*\n         ISPCMDS VERB=XL,                                              X\n               ACT='SELECT SUSPEND PGM(XL) MODE(FSCR) PARM(&&ZPARM)',  X\n               DESC='Do a DSN List using template, ala 3.4'\n*\n         ISPCMDS VERB=OMVS,                                            X\n               ACT='SELECT CMD(OMVS)',                                 X\n               DESC='Startup OMVS Shell'\n*\n         ISPCMDS VERB=IShell,                                          X\n               TRUNC=2,                                                X\n               ACT='SELECT CMD(%$ISHELL)',                             X\n               DESC='Startup ISPF IShell OMVS Interface'\n*\n         ISPCMDS VERB=ISPFTEST,                                        X\n               ACT='SELECT PGM(ISPYXDR) PARM(&&ZAPPLID)',              X\n               DESC='Startup ISPF Dialog Test Interface'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VALLOC": {"ttr": 23558, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x06\\x01\\x00\\x10o\\x01\\x07\\x19?\\x05U\\x00X\\x00,\\x00\\x04\\xc3\\xc2\\xe3\\xf4\\xf7\\xf5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-04-15T00:00:00", "modifydate": "2007-07-12T05:55:06", "lines": 88, "newlines": 44, "modlines": 4, "user": "CBT475"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* MODULE NAME = VALLOC                                               */\n/*                                                                    */\n/* DESCRIPTIVE NAME = Generate ALLOCATE commands from data set list   */\n/*                                                                    */\n/* STATUS = R101                                                      */\n/*                                                                    */\n/* Author: Gilbert Saint-Flour <carlos@gsf-soft.com>                  */\n/*         http://gsf-soft.com/Freeware/                              */\n/*                                                                    */\n/* FUNCTION = This EDIT macro reads a list of data set names          */\n/*  starting in pos 1 of each line and generates a set of             */\n/*  corresponding ALLOCATE commands.  A data set name list can        */\n/*  be created from the DSLIST panel using the VDL exec.              */\n/*                                                                    */\n/* DEPENDENCIES = TSO/E V2                                            */\n/*                ISPF V2.3 or above                                  */\n/*                STEMVIEW or STEMEDIT                                */\n/*                                                                    */\n/**********************************************************************/\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"ISREDIT MACRO (TRAIL)\"\n\n\"ISREDIT (I) = LINENUM .ZFIRST\"\n\"ISREDIT (LASTLINE) = LINENUM .ZLAST\"\n\nQUEUE \"//VALLOCJ  JOB (ACCT#),LOCAL.VALLOC,\"\nQUEUE \"// NOTIFY=&SYSUID,REGION=2M,\"\nQUEUE \"// CLASS=A,MSGCLASS=H,COND=(0,NE)\"\nQUEUE \"//*\"\nQUEUE \"//ALLOC   EXEC PGM=IKJEFT01,DYNAMNBR=200\"\nQUEUE \"//SYSTSPRT DD SYSOUT=*\"\nQUEUE \"//SYSTSIN  DD *\"\n\ntracks=0; datasets=0; aliases=0\n\nDO i=1 to lastline\n  \"ISREDIT (line) = LINE\" I             /* GET current data set name */\n  dsn=TRANSLATE(WORD(line,1))           /* extract data set name */\n  rc=LISTDSI(\"'\" || dsn || \"'\" 'DIR' 'NORECALL')\n  say dsn rc sysdsname syscreate \"'\" || sysrecfm || \"'\" sysdsorg\n  IF rc>4 THEN ITERATE                  /* MIGRAT */\n  IF sysdsorg='VS' THEN ITERATE         /* VSAM */\n  IF sysalloc > sysprimary THEN\n    sysprimary=sysalloc                 /* num of trks used */\n  QUEUE \" \"                             /* blank line */\n  IF dsn=sysdsname THEN DO\n    QUEUE \"ALLOCATE DSNAME('\"sysdsname\"') NEW CATALOG +\"\n    QUEUE \"           UNIT(SYSALLDA) VOLUME(WORK01) +\"\n    IF sysrecfm='U' THEN\n      dcb=\"RECFM(U) BLKSIZE(\"sysblksize\")\"\n    ELSE DO\n      recfm=LEFT(STRIP(sysrecfm),3)\n      recfm=SUBSTR(recfm,1,1) SUBSTR(recfm,2,1) SUBSTR(recfm,3,1)\n      dcb=\"RECFM(\"STRIP(recfm)\") LRECL(\"syslrecl\")\"\n      dcb=dcb \"DSORG(\"sysdsorg\")\"\n      END\n    IF sysunits='BLOCK' THEN\n      sysunits='BLOCK(' || sysblksize || ')'\n    IF SYSDSSMS='DATA_LIBRARY' | SYSDSSMS='PROGRAM_LIBRARY' THEN\n      dcb=dcb 'DSNTYPE(LIBRARY)'\n    IF sysadirblk='' | sysadirblk='NO_LIM' THEN\n      line=\"          SPACE(\"sysprimary','sysseconds\")\" sysunits dcb\n    ELSE\n      line=\"          SPACE(\"sysprimary','sysseconds\")\" sysunits,\n                        \"DIR(\"sysadirblk\")\" dcb\n    IF LENGTH(line)>72 THEN\n      line=RIGHT(LINE,72)\n    QUEUE line\n    tracks=tracks+sysprimary\n    datasets=datasets+1\n    END\n  ELSE DO                              /* ALIAS */\n    QUEUE \"DEFINE ALIAS(NAME('\"dsn\"') -\"\n    QUEUE \"           RELATE('\"sysdsname\"'))\"\n    aliases=aliases+1\n    END\nEND\n\nQUEUE \" \"\nQUEUE \" /* datasets=\"datasets \"aliases=\"aliases \"tracks=\"tracks \"*/\"\nQUEUE \" \"\n\nCALL STEMVIEW 'VIEW',,,,'ALLOCATE Commands'\n\nEXIT rc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VARS": {"ttr": 23561, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97\\x06\\x8f\\x00\\x98\\x17\\x1f\\x13R\\x00k\\x00\\x13\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-03-09T00:00:00", "modifydate": "1998-06-20T13:52:00", "lines": 107, "newlines": 19, "modlines": 0, "user": "CBT472"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* Module Name: VARS                                                  */\n/*                                                                    */\n/* Descriptive Name:  Display ISPF variables currently in storage.    */\n/*                                                                    */\n/* Status: R100                                                       */\n/*                                                                    */\n/* Function: This REXX program displays the variables                 */\n/*           currently in storage using STEMVIEW.                     */\n/*                                                                    */\n/* Author: Gilbert Saint-Flour <carlos@gsf-soft.com>                  */\n/*                                                                    */\n/* Environment: ISPF/PDF V3                                           */\n/*              STEMVIEW R105                                         */\n/*                                                                    */\n/* Operation: VARS can be invoked as:                                 */\n/*                                                                    */\n/*               1. a TSO command:    TSO %VARS                       */\n/*                                                                    */\n/*               2. an EDIT macro:    VARS                            */\n/*                                                                    */\n/*               3. a line command on the DSLIST panel                */\n/*                                                                    */\n/* Sample Output:                                                     */\n/*                                                                    */\n/*         TLD2 0980C0                                                */\n/*           VCB  0A8A8C                                              */\n/*             VPL  0B01D8                                            */\n/*             VPL  0AFD48                                            */\n/*               VDT  0C9DD8 44                                       */\n/*                 ZPDMIX__ 28000020                                  */\n/*               VDT  0C9BB8 228                                      */\n/*                 ZSCML___ 28000020 3 CSR                            */\n/*                 MLI2____ 2800001C                                  */\n/*                 MLI3____ 2800001C                                  */\n/*                 ZMSCPOS_ 28000020 4 0002                           */\n/*                 ZEDEXTVN 28000020 28 (ZEDPIMAC ZEDPFLG2 ZEDPFLG3)  */\n/*                 ZEDTZCMD 28000020 256 vars                         */\n/*                 ZSCED___ 28000020 3 CSR                            */\n/*               VDT  0A888C 228                                      */\n/*                 Z_______ 6808001C                                  */\n/*                 ZLOGON__ 680C0020 8 TSOPROC                        */\n/*                 ZENVIR__ 680D0020 32 ISPF 4.4MVS     TSO           */\n/*                 ZSCREEN_ 680E0020 1 2                              */\n/*                                                                    */\n/**********************************************************************/\nADDRESS 'ISPEXEC';\"CONTROL ERRORS RETURN\";\"ISREDIT MACRO\"\nTCB    = PTR(540)               /* TCB (EXEC COMMAND)    PSATOLD  */\nTCB    = PTR(TCB+132)           /* TCB (ISPTASK)         TCBOTC   */\nFSA    = PTR(TCB+112)           /* FIRST SAVE AREA       TCBFSA   */\nR1     = PTR(FSA+24)            /* ISPTASK'S R1                   */\nTLD    = PTR(R1)                /* TLD ADDRESS                    */\n\nl.1 = STORAGE(D2X(tld),4) RIGHT(D2X(tld),6,'0')\n\nvcb    = PTR(TLD+80)            /* vcb ADDRESS                    */\nl.2 = ' ' STORAGE(D2X(vcb),4) RIGHT(D2X(vcb),6,'0')\n\nvpl = PTR(vcb+8)                /* first VPL                      */\nn=3\nDO UNTIL vpl=0\n  l.n = '   ' STORAGE(D2X(vpl),4) RIGHT(D2X(vpl),6,'0')\n  n=n+1\n  vdt = PTR(vpl+12)             /* first VDT                      */\n  IF vdt>0 THEN DO UNTIL vdt=0\n    vdtlen=C2D(STORAGE(D2X(vdt+6),2))\n    l.n = '     ' STORAGE(D2X(vdt),4) RIGHT(D2X(vdt),6,'0') vdtlen\n    n=n+1\n    i=12\n    DO WHILE i<vdtlen\n      flags=C2X(STORAGE(D2X(vdt+i+16),4))\n      varlen=C2D(STORAGE(D2X(vdt+i+22),2))\n      var= STORAGE(D2X(vdt+i+24),varlen)\n   /* say  n var d2x(vdt) i vdtlen varlen var */\n      addr=PTR(vdt+i)\n      IF addr=0 THEN\n        l.n = '       ' LEFT(var,8,'_') flags\n      ELSE DO\n        len=C2D(STORAGE(D2X(vdt+i+12),2))\n        l.n = '       ' LEFT(var,8,'_') flags len STORAGE(D2X(addr),len)\n        END\n      n=n+1\n   /* say  n l.n */\n      IF varlen>4 THEN i=i+32; ELSE i=i+28\n    END\n    vdt=PTR(vdt+8)              /* next VDT                       */\n  END\n  vpl=PTR(vpl+8)                /* next VPL                       */\nEND\n\nSIGNAL ON SYNTAX                  /*    STEMVIEW NOT AVAILABLE     */\nCALL STEMVIEW 'VIEW','l.',1,,\"Show variables for\",\n              STORAGE(D2X(tld),4) RIGHT(D2X(tld),6,'0')\nEXIT rc\n\nSYNTAX:                            /* STEMVIEW FUNCTION NOT AVAILABLE */\n  error=rc\n  'CONTROL DISPLAY LINE START(1)'\n  SAY 'REXX error' error 'in line' sigl':' errortext(error)\n  SAY sourceline(sigl)\n  SAY ''\n  DO n=1 TO i-1; SAY l.n ; END\n  EXIT\n\nPTR: RETURN C2D(BITAND(STORAGE(D2X(ARG(1)),4),'7FFFFFFF'X))\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VDL": {"ttr": 23564, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00H\\x00\\x89\\x05\\x8f\\x01\\x105\\x0f\\x11\\x15\\x00\\x9b\\x00!\\x00\\x13\\xc3\\xc2\\xe3\\xf4\\xf8\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1989-02-27T00:00:00", "modifydate": "2010-12-16T11:15:48", "lines": 155, "newlines": 33, "modlines": 19, "user": "CBT483"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* Module Name: VDL                                                   */\n/*                                                                    */\n/* Descriptive Name:  VIEW Data set List.                             */\n/*                                                                    */\n/* Status: R102                                                       */\n/*                                                                    */\n/* Function: This REXX program makes the list of data set created     */\n/*           by DSLIST available as data in a VIEW session.           */\n/*                                                                    */\n/*           Using VDL is faster than using the SAVE command to       */\n/*           store the dsnames into a data set then editing it.       */\n/*                                                                    */\n/*           VDL retrieves the dsnames from the table internally      */\n/*           built by the DSLIST utility, copies the dsnames to a     */\n/*           stemmed variable, then invokes STEMVIEW to VIEW the      */\n/*           resulting data set list with each data set name in       */\n/*           pos 1 of a data record.                                  */\n/*                                                                    */\n/* Author: Gilbert Saint-Flour <carlos@gsf-soft.com>                  */\n/*                                                                    */\n/* Environment: ISPF/PDF V3                                           */\n/*              STEMVIEW R105                                         */\n/*                                                                    */\n/* Operation: VDL must be invoked from the DSLIST screen, either as   */\n/*            a line command or as a TSO command, such as  TSO %VDL   */\n/*                                                                    */\n/* Change Activity:                                                   */\n/*  R101 Misc changes                                                 */\n/*  R102 Stop using DTB in ISPF 5.9 and above                         */\n/*                                                                    */\n/**********************************************************************/\nADDRESS 'ISPEXEC'; \"CONTROL ERRORS RETURN\"\n              /*---------------------------------------*/\n              /* Retrieve the name of the DSLIST table */\n              /*---------------------------------------*/\nTCB    = PTR(540)                  /* TCB (EXEC COMMAND)    PSATOLD  */\nTCB    = PTR(TCB+132)              /* TCB (ISPTASK)         TCBOTC   */\nFSA    = PTR(TCB+112)              /* FIRST SAVE AREA       TCBFSA   */\nR1     = PTR(FSA+24)               /* ISPTASK'S R1                   */\nTLD    = PTR(R1)                   /* TLD ADDRESS                    */\ndta    = PTR(tld+076)              /* DTA address                    */\ntable  = STORAGE(D2X(dta+12),8)    /* Name of temp table    DSL12345 */\n\"VGET ZENVIR\"                      /* Retrieve ISPF Version          */\nIF LEFT(Zenvir,8) < 'ISPF 5.9' THEN DO\n  dtb    = PTR(dta+016)            /* DTB address                    */\n  IF dtb=0 THEN\n    dtb  = PTR(dta+044)            /* OPEN Table Chain               */\n  IF STORAGE(D2X(dtb),3) /= 'DTB' THEN DO\n    SAY 'Error: Table name could not be located (DTB)' zenvir\n    EXIT 12\n    END\n  table = STORAGE(D2X(dtb+6),8)    /* Name of temp table    DSL12345 */\n  END\n\n\"TBQUERY\" table \"KEYS(KEYS) NAMES(NAMES) NAMENUM(NAMENUM)\",\n                \"ROWNUM(ROWNUM) KEYNUM(KEYNUM) POSITION(CRP)\"\nIF rc>0 THEN SIGNAL TBQUERY_Failed\n              /*---------------------------------------*/\n              /* Scan the DSLIST table and build array */\n              /*---------------------------------------*/\n\"TBTOP\" table                      /* start from the top             */\nIF rc>0 THEN EXIT rc\n\nDO N=1 TO rownum                   /* read all the table entries     */\n  \"TBSKIP\" table\n  IF rc>0 THEN LEAVE\n  space=''; attributes=''; dates=''\n  IF zurecfm='FF'X THEN DO\n     space=COPIES(' ',20)\n     attributes = zuorg\n     END\n  ELSE\n    IF zuobtatt='Y' THEN DO\n      attributes = LEFT(zuorg,4) LEFT(zurecfm,4) zulrecl zublksiz\n      IF zuobtspc='Y' THEN DO\n        space      = zusize zuus || '%' zux zudevice\n        IF zuobtdat='Y' THEN\n          dates      = zucdate zuedate zurdate\n        END\n      END\n  ds.n = LEFT(zudsns,44) zudvol space attributes dates\n  ds.n = LEFT(ds.n,132) zuobtatt zuobtspc zuobtdat\nEND\n\"TBSKIP\" table \"ROW(\"CRP\")\"        /* re-position the table          */\n                 /*-------------------*/\n                 /* Display the array */\n                 /*-------------------*/\nSIGNAL ON SYNTAX                  /*    STEMVIEW not available     */\nCALL STEMVIEW 'VIEW','ds.',1,rownum,\"Data set name list\"\nEXIT rc\n\nSYNTAX:                            /* STEMVIEW FUNCTION NOT AVAILABLE */\n  'CONTROL DISPLAY LINE START(1)'\n  SAY 'REXX error' rc 'in line' sigl':' errortext(rc)\n  SAY sourceline(sigl)\n  SAY ''\n  DO i=1 TO rownum; SAY ds.i ; END\n  EXIT\n                  /*----------------*/\n                  /*  Sub-routines  */\n                  /*----------------*/\n\nPTR: RETURN C2D(BITAND(STORAGE(D2X(ARG(1)),4),'7FFFFFFF'X))\n\nInvalid_Environment:\n  ZEDSMSG = 'Invalid environment'\n  ZEDLMSG = 'This command must be invoked from the Data Set List',\n            'utility; the current panel is' panel'.'\n  \"SETMSG MSG(ISRZ001)\"\n  EXIT 12\n\nTBQUERY_Failed:\n  ZEDSMSG = 'TBQUERY failed'\n  ZEDLMSG = 'TBQUERY' table 'service failed with RC=' rc\n  \"SETMSG MSG(ISRZ001)\"\n  EXIT 12\n\n        /*------------------------------------*/\n        /* Variables (for documentation only) */\n        /*------------------------------------*/\n\n  SAY 'KEYS='KEYS 'NAMES='NAMES 'NAMENUM='NAMENUM\n  SAY 'ROWNUM='ROWNUM 'KEYNUM='KEYNUM 'POSITION='CRP\n\n  ZUBLKSIZ      ZDLBLKSZ\n  ZUCDATE       ZDLCDATE\n  ZUCDAT2\n  ZUDEVICE      ZDLDEV\n  ZUDMVOL       ZDLMVOL\n  ZUDSNS        ZDLDSN\n  ZUDSPACU\n  ZUDVOL        ZDLVOL\n  ZUDXSTAT      ZDLXSTAT\n  ZUEDATE       ZDLEDATE\n  ZUEDAT2\n  ZULCMDL\n                ZDLCMD\n  ZULMSG\n                ZDLMSG\n  ZULOCVOL\n                ZDLCAT\n  ZULRECL       ZDLLRECL\n  ZUOBTATT\n  ZUOBTDAT\n  ZUOBTSPC\n  ZUORG         ZDLDSORG\n  ZURDATE       ZDLRDATE\n  ZURDAT2\n  ZURECFM       ZDLRECFM\n  ZUSIZE        ZDLSIZE\n  ZUSTAT\n  ZUUS          ZDLUSED\n  ZUX           ZDLEXT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VML": {"ttr": 23811, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00Y\\x00\\x97\\x06\\x7f\\x01\\t\\x14o\\x154\\x00\\xc7\\x00\\x12\\x00}\\xc3\\xc2\\xe3\\xf4\\xf7\\xf8@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1997-03-08T00:00:00", "modifydate": "2009-05-26T15:34:59", "lines": 199, "newlines": 18, "modlines": 125, "user": "CBT478"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* Module Name: VML                                                   */\n/*                                                                    */\n/* Descriptive Name:  Read PDS directory and VIEW/BROWSE Member List  */\n/*                                                                    */\n/* Status: R107                                                       */\n/*                                                                    */\n/* Function: This REXX exec reads the directory of the specified      */\n/*           PDS and invokes STEMVIEW to allow the user to VIEW       */\n/*           or BROWSE the resulting member list with each member     */\n/*           name in pos 1 of a record.                               */\n/*                                                                    */\n/* Author: Gilbert Saint-Flour <carlos@gsf-soft.com>                  */\n/*         http://gsf-soft.com/Freeware/                              */\n/*                                                                    */\n/* Environment: ISPF/PDF V3                                           */\n/*              STEMVIEW R105                                         */\n/*                                                                    */\n/* Operation: see below                                               */\n/*                                                                    */\n/*        VML can be invoked as:                                      */\n/*                                                                    */\n/*        1. a line command on the DSLIST panel                       */\n/*                                                                    */\n/*        2. a TSO command:    TSO %VML 'SYS1.PROCLIB'                */\n/*                                                                    */\n/*        3. an EDIT macro:    VML <my.data.set>                      */\n/*                                                                    */\n/*        By default, the member list is displayed with VIEW.         */\n/*        To display the member list with BROWSE instead of VIEW,     */\n/*        add BROWSE as 2nd positional parameter, as follows:         */\n/*                                                                    */\n/*        1. On the DSLIST panel, enter a line cmd:  VML / B          */\n/*                                                                    */\n/*        2. As a TSO command:    TSO %VML 'SYS1.PROCLIB' B           */\n/*                                                                    */\n/*        3. As an EDIT macro:    %VML 'SYS1.PROCLIB' B               */\n/*                          or    %VML / B                            */\n/*                                                                    */\n/* Change Activity:                                                   */\n/*                                                                    */\n/*  101   Can be invoked as an EDIT macro                             */\n/*  102   Display SPF stats                                           */\n/*  103   Can be invoked outside ISPF                                 */\n/*  104   Exit main loop after 8X'FF' member                          */\n/*  105   Remove member name from dsname                              */\n/*  106   Change YYYY/MM/DD to YYYY-MM-DD                             */\n/*  107   VIEW/BROWSE                                                 */\n/*                                                                    */\n/**********************************************************************/\nispf=SYSVAR(SYSISPF)='ACTIVE'\n  /*-----------------------------------------------------------------*/\n  /*             Retrieve Data Set Name and Volume Serial            */\n  /*-----------------------------------------------------------------*/\nARG dsn vibr ; vol=''\nIF dsn='' THEN DO\n  IF ispf THEN\n    \"ISREDIT MACRO (DSN VIBR)\"\n  IF ispf & rc=0 THEN DO                          /* EDIT macro */\n    IF dsn='' | dsn='*' | dsn='/' THEN DO\n      \"ISREDIT (DSN) = DATASET\"\n      IF dsn='' THEN DO\n        ZEDSMSG = 'Invalid Environment'\n        ZEDLMSG = \"This command does not work in the EDIF environment\"\n        \"ISPEXEC SETMSG MSG(ISRZ001)\"\n        EXIT 12\n        END\n      ELSE\n        dsn = \"'\" || dsn || \"'\"\n      END\n    END\n  ELSE DO WHILE dsn=''                            /* TSO %VML   */\n    SAY Enter dsname\n    PULL dsn\n    END\n  END\nELSE\n  IF ispf THEN DO\n    \"ISPEXEC VGET (ZDLDSN ZDLVOL ZDLCAT)\"         /* DSLIST     */\n    IF rc=0 THEN DO\n      IF ZDLDSN=STRIP(dsn,,\"'\") THEN DO\n        IF ZDLCAT\\=0 THEN\n          vol='VOL('zdlvol')'\n        END\n      END\n    END\n  /*-----------------------------------------------------------------*/\n  /*           Allocate target PDS and read its Directory            */\n  /*-----------------------------------------------------------------*/\nIF INDEX(dsn,'(') > 0 THEN                   /* remove member name */\n  dsn=LEFT(dsn,INDEX(dsn,'(')-1) || \"'\"\n\"ALLOCATE DD(VMLPDS) SHR DS(\"dsn\") REUSE\" vol,\n  \"RECF(F B) LRECL(256) BLKSIZE(256) DSORG(PS)\"\nIF rc>0 THEN EXIT(rc)\nx=LISTDSI(VMLPDS FILE)\nIF sysdsorg\\='PO' THEN DO\n  ZEDSMSG = 'Not a PDS'\n  ZEDLMSG = sysdsname \"is not a PDS or a PDSE\"\n  IF vol\\='' THEN\n    ZEDLMSG = sysdsname \"on\" vol \"is not a PDS or a PDSE\"\n  IF ispf THEN\n    \"ISPEXEC SETMSG MSG(ISRZ001)\"\n  ELSE\n    SAY zedlmsg\n  EXIT 12\n  END\n\"EXECIO * DISKR VMLPDS (STEM DIR. FINIS\" /* read PDS directory */\n\"FREE DD(VMLPDS)\"\n  /*-----------------------------------------------------------------*/\n  /*                 Process Directory Blocks                        */\n  /*-----------------------------------------------------------------*/\nn=0\n  DO blk = 1 to dir.0\n    usedbytes = C2D(LEFT(dir.blk,2))\n    index = 3                            /* skip past used bytes */\n    DO WHILE index < usedbytes\n      pds2name = SUBSTR(dir.blk,index,8) /* member name */\n      IF pds2name = 'FFFFFFFFFFFFFFFF'x THEN LEAVE blk\n      pds2indc = SUBSTR(dir.blk,index+11,1)\n      len = BITAND(pds2indc,'1F'x)       /* isolate user data length */\n      userdata = C2D(len) * 2            /* halfwords to bytes */\n      n=n+1                              /* next n                   */\n      IF userdata=30 & sysrecfm\\='U' THEN DO /* SPF stats present    */\n        sde=SUBSTR(dir.blk,index+12,30)  /* extract SPF Dir Entry    */\n        ver=C2D(SUBSTR(sde,1,1))\n        mod=C2D(SUBSTR(sde,2,1))\n        idate=C2X(SUBSTR(sde,5,4))       /* 0092123F    */\n        idate=LEFT(idate,7)+1900000      /* 1992123     */\n        cdate=C2X(SUBSTR(sde,9,4))       /* 0092123F    */\n        cdate=LEFT(cdate,7)+1900000      /* 1992123     */\n        hh=C2X(SUBSTR(sde,13,1))\n        mm=C2X(SUBSTR(sde,14,1))\n        ss=C2X(SUBSTR(sde,4,1))\n        iline=C2D(SUBSTR(sde,15,2))\n        cline=C2D(SUBSTR(sde,17,2))\n        mline=C2D(SUBSTR(sde,19,2))\n        sclm=BITAND(SUBSTR(sde,3,1),'80'x) /* isolate SCLM flag      */\n        IF sclm='80'x THEN\n          sclm='SCLM'\n        ELSE\n          sclm=''\n        mbr.n=pds2name,                  /* member name              */\n              RIGHT(ver,2,'0') || '.' || RIGHT(mod,2,'0'),\n              GREGORIAN(idate),          /* creation date            */\n              GREGORIAN(cdate),          /* last-modified date       */\n              hh || ':' || mm || ':' || ss, /* HH:MM:SS              */\n              RIGHT(iline,5),            /* initial lines            */\n              RIGHT(cline,5),            /* current lines            */\n              RIGHT(mline,5),            /* modified lines           */\n              RIGHT(sde,10),             /* userID                   */\n              SCLM                       /* SCLM indicator           */\n        END\n      ELSE                               /* no ISPF stats            */\n        mbr.n=pds2name                   /* store member name        */\n      index = index + 12 + userdata      /* skip past user data */\n    END\n  END\n  /*-----------------------------------------------------------------*/\n  /*                    Display the Member List                      */\n  /*-----------------------------------------------------------------*/\nIF n=0 THEN DO\n  SAY sysdsname is empty\n  EXIT 4\n  END\nIF ispf THEN DO\n  SIGNAL ON SYNTAX                /*    STEMVIEW not available     */\n  IF ABBREV('BROWSE',TRANSLATE(STRIP(vibr)),1) THEN\n    CALL STEMVIEW 'BROWSE','mbr.',1,n,sysdsname 'Member List',,72\n  ELSE\n    CALL STEMVIEW 'VIEW','mbr.',1,n,sysdsname 'Member List',,72\n  EXIT rc\n  END\nELSE\n  SIGNAL DISPLAY\n\nSYNTAX:                           /* STEMVIEW function not available */\n  error=rc\n  IF ispf THEN\n    'ISPEXEC CONTROL DISPLAY LINE START(1)'\n  SAY 'REXX error' error 'in line' sigl':' errortext(error)\n  SAY sourceline(sigl)\n  SAY ''\nDISPLAY:\n  DO i=1 TO n; SAY mbr.i ; END\n  EXIT\n/**********************************************************************/\n/*             JULIAN-TO-GREGORIAN CONVERSION ROUTINE                 */\n/*                   GDATE=GREGORIAN(1992134)                         */\n/*                      RETURNS \"YYYY-MM-DD\"                          */\n/**********************************************************************/\nGREGORIAN: PROCEDURE\n  YYYY=LEFT(ARG(1),LENGTH(ARG(1))-3)\n  DDD=RIGHT(ARG(1),3)\n  T=(YYYY//4=0)\n  DD=DDD; IF DD>(59+T) THEN DD=DD+2-T\n  MM=((DD+91)*100)%3055\n  DD=DD+91-(MM*3055)%100\n  RETURN YYYY'-'RIGHT(MM-2,2,'0')'-'RIGHT(DD,2,'0')\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VSAMVIEW": {"ttr": 23815, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x18\\x00\\x90\\x07O\\x01\\x10\\x05\\x0f\\x16Y\\x02\\xb7\\x02@\\x00}\\xc3\\xc2\\xe3\\xf4\\xf8\\xf3@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1990-03-15T00:00:00", "modifydate": "2010-02-19T16:59:18", "lines": 695, "newlines": 576, "modlines": 125, "user": "CBT483"}, "text": "//GILBERTV JOB (ACCT#),VSAMVIEW,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(NODECK,OBJECT,NOESD,NORLD,NOXREF)\n         PUNCH ' ALIAS VV'          <- \"VV\" IS AN ALIAS FOR \"VSAMVIEW\"\n***********************************************************************\n*                                                                     *\n* MODULE NAME = VSAMVIEW                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = VIEW A VSAM DATA SET UNDER ISPF                  *\n*                                                                     *\n* Function = This command allows you to view a VSAM data set in       *\n*            ISPF using the VIEW interface (VIIF).                    *\n*            The SAVE command is disabled, but all other VIEW         *\n*            facilities are available (create, etc).                  *\n*                                                                     *\n* STATUS = R105                                                       *\n*                                                                     *\n* Author = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*          http://gsf-soft.com/Freeware/                              *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = OS/390 R10 and z/OS                               *\n*                   ISPF/PDF V3                                       *\n*                   STRING macro R510                                 *\n*                                                                     *\n*    AUTHORIZATION = NONE                                             *\n*                                                                     *\n*    RESTRICTIONS = NONE                                              *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (TSO COMMAND PROCESSOR)                    *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 3K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE 24, AMODE 31,                    *\n*                 PROBLEM STATE, KEY 8                                *\n*                                                                     *\n* OPERATION = SEE COMMENTS IN SOURCE CODE                             *\n*                                                                     *\n* SYNTAX = SEE BELOW                                                  *\n*                                                                     *\n*        VSAMVIEW 'DATA-SET-NAME'                                     *\n*                 RECSIZE('MAX-RECORD-LENGTH')                        *\n*                 SKIP('COUNT')                                       *\n*                 COUNT('COUNT')                                      *\n*                                                                     *\n*        REQUIRED: DATA-SET-NAME                                      *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n*  100   INITIAL RELEASE                                          1995*\n*  101   Replace EDIF with VIIF (OS/390 R10 and z/OS)             2002*\n*  102   ISRCONFG no longer exists in ISPF V5                     2003*\n*  103   VRDS Support                                             2005*\n*  104   ISPF/PDF V3 Support                                      2009*\n*  105   Display ISRZ001 Message at start-up                          *\n*  106   Data Set <dsname> is of unsupported type (LDS)           2010*\n*                                                                     *\n&REL     SETC  'R106'                                                 *\n***********************************************************************\nVSAMVIEW CSECT\nVSAMVIEW AMODE 31\n&D       SETC  '&SYSDATE'(7,2)'-'.'&SYSDATE'(1,2)'-'.'&SYSDATE'(4,2)\n         SAVE  (14,12),,'GSF Utilities - VSAMVIEW &REL - 20&D &SYSTIME'\n         LR    R11,R15\n         USING VSAMVIEW,R11\n         LR    R9,R1                   SAVE CPPL ADDRESS\n         USING CPPL,R9                 SET UP ADDRESSABILITY TO CPPL\n         ICM   R2,B'1111',CPPL         INVOKED AS A PGM?\n         BM    ALLOCATE                YES, JUMP\n         LA    R3,DYNAML               LENGTH OF DYNAMIC STORAGE AREA\n         GETMAIN R,LV=(R3)             ALLOCATE DYNAMIC STORAGE\n         LR    R2,R1                   CLEAR DYNAMIC STORAGE\n         SLR   R15,R15                 CLEAR DYNAMIC STORAGE\n         MVCL  R2,R14                  CLEAR DYNAMIC STORAGE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LM    R13,R1,8(R13)           SET R13, RELOAD R14-R1\n         USING DYNAM,R13\n         STM   R11,R12,BASEREGS        FOR READ ROUTINES\n***********************************************************************\n*                                                                     *\n*        BUILD PARSE PARM LIST, CALL IKJPARS                          *\n*                                                                     *\n***********************************************************************\nCALLPARS LA    R1,TENWORDS             POINT TO PPL\n         USING PPL,R1                  SET UP ADDRESSABILITY TO PPL\n         L     R0,CPPLUPT              USER PROFILE TABLE\n         ST    R0,PPLUPT               STORE UPT ADDRESS IN PPL\n         L     R0,CPPLECT              ENVIRONMENT CONTROL TABLE\n         ST    R0,PPLECT               STORE ECT IN PPL\n         LA    R0,ECB1                 EVENT CONTROL BLOCK\n         ST    R0,PPLECB               STORE ECB IN PPL\n         MVC   PPLPCL,=A(PCLCSECT)     STORE PCL ADDR INTO PPL\n         LA    R0,DYNANSWR             ANSWER AREA\n         ST    R0,PPLANS               STORE ANSWER ADDRESS IN PPL\n         L     R0,CPPLCBUF             COMMAND BUFFER\n         ST    R0,PPLCBUF              STORE BUFFER ADDRESS IN PPL\n         LA    R14,=C'IKJPARS '        NAME OF PARSE ROUTINE\n         L     R15,16                  CVTPTR\n         L     R15,8(,R15)             CVTLINK\n         STM   R14,R15,DWD             BUILD LINK PARMLIST\n         LINK  SF=(E,DWD)              CALL THE PARSE ROUTINE\n         LTR   R7,R15                  CHECK FOR ZERO PARSE RETURN\n         BNZ   QUIT16                  GO AWAY UPSET\n         DROP  R1,R9                   PPL, CPPL\n***********************************************************************\n*                                                                     *\n*        PROCESS PARSED PARAMETERS                                    *\n*                                                                     *\n***********************************************************************\nPARSE100 L     R2,DYNANSWR             LOAD PDL ADDRESS\n         USING IKJPARMD,R2             SET UP ADDRESSABILITY TO PDL\n         LA    R14,DSNAME              44-BYTE AREA\n         LA    R15,L'DSNAME            GET LENGTH\n         L     R0,DSNPCE               GET ADDRESS\n         LH    R1,DSNPCE+4             ACTUAL LENGTH OF DSN\n         ICM   R1,B'1000',=C' '        PADDING\n         MVCL  R14,R0                  MOVE DATA SET NAME\n*TPUT DSNAME,L'DSNAME\nPARSE180 LA    R1,RECSZIDL             LOAD POINTER TO RECSZ FIELD\n         BAL   R14,PACKCVB             CONVERT PARAMETER\n         ST    R0,RECSIZE              STORE RECORD SIZE\n         LA    R1,SKIPIDL              LOAD POINTER TO SKIP FIELD\n         BAL   R14,PACKCVB             CONVERT PARAMETER\n         ST    R0,RECSKIP              STORE SKIP COUNT\n         LA    R1,COUNTIDL             LOAD POINTER TO COUNT FIELD\n         BAL   R14,PACKCVB             CONVERT PARAMETER\n         AL    R0,RECSKIP              ADD SKIP COUNT\n         ST    R0,RECCOUNT             STORE UPPER LIMIT\n*\n*        FREE-UP STORAGE ACQUIRED BY PARSE\n*\n         IKJRLSA DYNANSWR              FREE PDL\n*\n*        BUMP MY USE COUNT TO PREVENT S0C4 ON $SELECT\n*\n         L     R1,540(,0)              PSATOLD (MY TCB)\n         L     R1,0(,R1)               TCBRBP (MY PRB)\n         ICM   R1,B'0111',X'00D'(R1)   RBCDE1 (MY CDE)\n         MVC   OWNNAME,CDNAME-CDENTRY(R1) MOVE OWN NAME\n         LOAD  EPLOC=OWNNAME           BUMP CDUSE\n*\n*        RE-INVOKE MYSELF AS A PGM AND PASS THE ADDR OF THE DYNAMIC\n*        STORAGE AREA IN THE PARM.\n*\n         STRING 'PGM(',(OWNNAME,,T),') PARM(',((R13),,R8Z),')',        X\n               INTO=MESSAGE\n         ST    R15,DWD                 LENGTH\n         LA    R14,$SELECT             SERVICE\n         LA    R15,DWD                 LENGTH\n         LA    R0,MESSAGE              PARAMETERS\n         STM   R14,R1,TENWORDS         PARM LIST\n         OI    TENWORDS+8,X'80'        PARM LIST\n         LA    R1,TENWORDS             PARM LIST\n         L     R13,4(,R13)             CALLER'S SAVE AREA\n         XCTL  (2,12),EPLOC=$ISPLINK\n*---------------------------------------------------------------------*\n*        PACKCVB SUB-ROUTINE                                          *\n*---------------------------------------------------------------------*\nPACKCVB  LH    R15,4(,R1)              LOAD LENGTH\n         LTR   R0,R15                  THIS PARM SPECIFIED?\n         BZR   R14                     NO, GOBACK WITH R0=0\n         L     R1,0(,R1)               LOAD ADDRESS\n         BCTR  R15,0                   DECREMENT R15 FOR EXECUTE\n         EX    R15,PACKCVBX            PACK VALUE\n         CVB   R0,DWD                  CONVERT ZONED TO BINARY\n         BR    R14\nPACKCVBX PACK  DWD,0(,R1)              *EXECUTED*\n*---------------------------------------------------------------------*\n         MACRO                                                    MACRO\n&NAME    ISPLINK &OPRNDS,&ERRET=                                  MACRO\n         GBLB  &IHBSWA                                            MACRO\n&IHBSWA  SETB  1                       VL=1                       MACRO\n&NAME    LA    R1,TENWORDS             PARM LIST                  MACRO\n         IHBOPLST ,&OPRNDS,MF=(E,(1))                             MACRO\n         L     R15,ISPLINK@            ISPLINK BOOTSTRAP\n         BALR  R14,R15                 INVOKE ISPLINK\n         AIF   (T'&ERRET EQ 'O').MEND                             MACRO\n         LTR   R15,R15                 ANY ERROR?\n         BNZ   &ERRET                  YES, JUMP\n.MEND    MEND                                                     MACRO\n***********************************************************************\n*                                                                     *\n*        ALLOCATE THE DATA SET                                        *\n*                                                                     *\n***********************************************************************\nALLOCATE PACK  16(8,R13),2(8,R2)       PACK THE PARM\n         CVB   R1,16(,R13)             GET IT IN BINARY\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LM    R13,R1,8(R13)           SET R13, RELOAD R14-R1\n         USING DYNAM,R13\n*---------------------------------------------------------------------*\n*        ISPEXEC CONTROL ERRORS RETURN                                *\n*---------------------------------------------------------------------*\n         LOAD  EPLOC=$ISPLINK\n         ST    R0,ISPLINK@             SAVE ISPLINK ADDRESS\n         ISPLINK ($CONTROL,$ERRORS,$RETURN), CONTROL ERRORS RETURN     X\n               ERRET=QUIT16            ISPF NOT ACTIVE\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ALLOCATE THE DATA SET                                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MVC   S99RB,=X'14,01,2000'    SVC 99 REQUEST BLOCK\n         LA    R1,S99TUPTR             TEXT UNIT POINTERS\n         ST    R1,S99RB+8              TEXT UNIT POINTERS\n*\n         LA    R14,S99T1                   RETURN DDNAME\n         MVC   S99T1(6),=X'0055,0001,0008' RETURN DDNAME\n         LA    R15,S99T2                   DSNAME\n         MVC   S99T2(6),=X'0002,0001,002C' DSNAME\n         LA    R0,=X'0004,0001,0001,08'    DISP=SHR\n         LA    R1,=X'001C,0000'            FREE=CLOSE\n         STM   R14,R1,S99TUPTR             TEXT-UNIT POINTERS\n         OI    S99TUPTR+12,X'80'           END OF LIST\n*\n         LA    R1,S99RB                BUILD SVC99 PARM LIST\n         ST    R1,S99RBPTR             BUILD SVC99 PARM LIST\n         OI    S99RBPTR,X'80'          BUILD SVC99 PARM LIST\n         LA    R1,S99RBPTR\n         DYNALLOC ,                    ALLOCATE THE DATA SET\n         LTR   R15,R15\n NOP 0   BNZ   ALLOC900                SVC99 FAILED, JUMP\n*---------------------------------------------------------------------*\n*                                                                     *\n*        INITIALIZE VSAM CONTROL BLOCKS (ACB, RPL)                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MVC   IFGACB(ACB1_L),ACB1_M   MOVE ACB,RPL\n         MVC   ACBDDNM,DDNAME          MOVE DDNAME\n         LA    R2,IFGACB               POINT TO ACB\n         ST    R2,OPENLIST             BUILD OPEN LIST\n         MVI   OPENLIST,X'80'          BUILD OPEN LIST\n         OPEN  MF=(E,OPENLIST)         OPEN VSAM DATA SET\n         CH    R15,=H'4'               OPEN OK?\n         BH    OPENR160                NO, QUIT\n*\n         SHOWCB ACB=(R2),AREA=(S,MAXRECNO),LENGTH=12,                  X\n               FIELDS=(NLOGR,LRECL),MF=(G,MESSAGE)\n         ICM   R0,B'1111',MAXLRECL     LRECL=0 (LDS)\n         BNZ   OPENVS3                 NO, JUMP\n         STRING '(LDS)',INTO=BAD_TYPE  bad type\n         B     OPENR170                Issue message\n*\nOPENVS3  EQU   *\n         ICM   R0,B'1111',MAXRECNO     EMPTY/OPEN ?\n         BNZ   OPENVS4                 NO, JUMP\n         MVI   MAXRECNO,X'7F'          YES, SET MAX NUMBER\n         ICM   R0,B'1111',RECCOUNT     COUNT SPECIFIED?\n         BZ    OPENVS4                 NO, JUMP\n         ST    R0,MAXRECNO             YES, USE COUNT\nOPENVS4  EQU   *\n*\n*        SET UP RPL FOR ESDS/KSDS\n*\n         MVC   IFGRPL(RPL1_L),RPL1_M   MOVE ACB,RPL\n*TPUT =C'ST R2,RPLDACB',13\n         ST    R2,RPLDACB              STORE ACB ADDRESS INTO RPL\n         LA    R0,RECAD                THE RIGHT WORD\n         ST    R0,RPLAREA              STORE AREA ADDRESS INTO RPL\n         LA    R0,L'RECAD              ADDRESS\n         ST    R0,RPLBUFL              STORE AREA LENGTH INTO RPL\n*\n         TESTCB ACB=(R2),ATRB=KSDS,MF=(G,MESSAGE) IS THIS A KSDS?\n         BE    OPENKSDS                YES, JUMP\n         TESTCB ACB=(R2),ATRB=RRDS,MF=(G,MESSAGE) IS THIS AN RRDS?\n         BE    OPENRRDS                YES, JUMP\n         TESTCB ACB=(R2),ATRB=VRRDS,MF=(G,MESSAGE) IS THIS A VRDS?\n         BE    OPENRRDS                YES, JUMP\n         TESTCB ACB=(R2),ATRB=ESDS,MF=(G,MESSAGE) IS THIS AN ESDS?\n         BE    OPENESDS                YES, JUMP\n         STRING 1X,INTO=BAD_TYPE       unknown bad type\n         B     OPENR170                UNSUPPORTED TYPE\n*\nOPENESDS MVI   VS_TYPE,C'E'            CLUSTER IS AN ESDS\n         B     OPENVS6\n*\nOPENKSDS MVI   VS_TYPE,C'K'            CLUSTER IS A KSDS\n         B     OPENVS6\n*\nOPENRRDS MVI   VS_TYPE,C'R'            CLUSTER IS AN RRDS\n         LA    R0,CURRECNO             RECORD NUMBER\n         ST    R0,RPLARG               RECORD NUMBER\n         OI    RPLOPT1,RPLDIR          OPTCD=(DIR,KEY)\n*\nOPENVS6  EQU   *\n         LOAD  EP=ISRCONFG,ERRET=OPENVS7 PDF CONFIG TABLE\n         LR    R1,R0                   ENTRY ADDRESS\n         L     R2,X'190'(,R1)          UNDOSIZE (IN K)\n         SLL   R2,10                   UNDOSIZE (IN BYTES)\n         ST    R2,UNDOSIZE             ADD SIZE OF UNDO BUFFER\n*\nOPENVS7  EQU   *\n         ICM   R0,B'1111',RECSIZE      RECSIZE PARM SPECIFIED?\n         BNZ   *+10                    NO, EXIT\n         MVC   RECSIZE,MAXLRECL        USE CALLER'S RECORD SIZE\n*\n         STRING VS_TYPE,'SDS',                                         X\n               ' MAXRECNO=',(MAXRECNO,F,L),                            X\n               ' Records_processed=',(MAXRECNO,F,L),                   X\n               ' RECSIZE=',(RECSIZE,F,L),                              X\n               INTO=MESSAGE\n         LR    R0,R15                  save length of long message\n         STRING 'VSAMVIEW &REL',INTO=SHORTMSG\n         STM   R15,R0,DWD              lengths of short & long msgs\n         ISPLINK (=C'VREPLACE',=C'ZEDSMSG ',DWD,SHORTMSG)\n         ISPLINK (=C'VREPLACE',=C'ZEDLMSG ',DWD+4,MESSAGE)\n         ISPLINK (=C'SETMSG ',=C'ISRZ000 ')\n*\n         B     VIIF\n*\n*        VSAM OPEN ERROR\n*\nOPENR160 CLI   ACBERFLG,160            EMPTY DATA SET?\n         BNE   OPENR161                NO, QUIT\n         MVC   ZERRMSG,=C'ISRB603 '    \"NO DATA TO BROWSE\"\n         LA    R7,4                    RC=4\n         B     SETMSG8                 ISSUE MESSAGE\n*\nOPENR161 EQU   *\n         ST    R15,DWD+4               OPEN RC\n         STRING 'OPEN Error',INTO=MESSAGE\n         ST    R15,DWD                 LENGTH OF SHORT MESSAGE\n         ISPLINK (=C'VREPLACE',=C'ZEDSMSG ',DWD,MESSAGE)\n         STRING 'OPEN failed for ',(DSNAME,,T),                        X\n               ', R15=',(DWD+4,F,L),                                   X\n               ', ACBERFLG=',(ACBERFLG,FL1,R3Z),'.',                   X\n               INTO=MESSAGE\n         B     OPENR190\n*\n*        Unsupported Data Set Type\n*\nOPENR170 EQU   *\n         STRING 'Unsupported Data Set',INTO=MESSAGE\n         ST    R15,DWD                 LENGTH OF SHORT MESSAGE\n         ISPLINK (=C'VREPLACE',=C'ZEDSMSG ',DWD,MESSAGE)\n         STRING 'Data Set ',(DSNAME,,T),' is of unsupported type ',    X\n               BAD_TYPE,INTO=MESSAGE\n*\nOPENR190 EQU   *\n         ST    R15,DWD                 LENGTH OF LONG MESSAGE\n         ISPLINK (=C'VREPLACE',=C'ZEDLMSG ',DWD,MESSAGE)\n         ISPLINK (=C'SETMSG ',=C'ISRZ001 ')\n         B     QUIT16\n***********************************************************************\n*\n*        INVOKE ISPF/PDF VIEW SERVICE (VIIF)\n*\n***********************************************************************\nVIIF     LA    R0,SAVERRTN             DDATA FOR VIIF\n         ST    R0,SAVERRTN             DDATA FOR VIIF\n         LA    R0,READVS00             read routine\n         ST    R0,READRTNE             read routine\n*\n         LA    R0,L'ZENVIR             max length of ZENVIR\n         ST    R0,DWD                  max length of ZENVIR\n         ISPLINK (=C'VCOPY ',=C'(ZENVIR)',DWD,ZENVIR,=C'MOVE ')\n*\n         CLI   ZENVIR+5,C'4'           ISPF V4 or above ?\n         BL    EDIF                    no, use EDIF\n*\n         ISPLINK (=C'VIIF',            SERVICE - ISPF V4/V5            X\n               DSNAME,                 DATA SET NAME                   X\n               =C'VSAMVIEW',           PROFILE NAME                    X\n               =C'V ',                 RECFM                           X\n               RECSIZE,                RECORD LENGTH                   X\n               READRTNE,               Addr of READ Routine            X\n               0,                      COMMAND EXIT                    X\n               SAVERRTN)               DIALOG DATA ADDR\n         LR    R7,R15                  SAVE RETURN CODE FROM VIIF\n         B     SETMSG\n*\nEDIF     ISPLINK (=C'EDIF',            SERVICE - ISPF V3               X\n               DSNAME,                 DATA SET NAME                   X\n               =C'VSAMVIEW',           PROFILE NAME                    X\n               =C'V ',                 RECFM                           X\n               RECSIZE,                RECORD LENGTH                   X\n               READRTNE,               Addr of READ Routine            X\n               =A(WRITERTN),           WRITE ROUTINE                   X\n               0,                      COMMAND EXIT                    X\n               SAVERRTN)               DIALOG DATA ADDR\n         LR    R7,R15                  SAVE RETURN CODE FROM EDIF\n         B     SETMSG\n*---------------------------------------------------------------------*\n*        DUMMY WRITE ROUTINE                                          *\n*---------------------------------------------------------------------*\nWRITERTN SAVE  (14,12),,WRITERTN\n         RETURN (14,12),RC=16\n***********************************************************************\n*\n*        PROGRAM EXIT\n*\n*           1. ISSUE ERROR MESSAGE\n*           2. CLEAN UP\n*           3. GOBACK TO CALLER\n*\n***********************************************************************\nSETMSG   LTR   R7,R7                   CHECK RC FROM VIIF\n         BZ    QUIT50                  OK, EXIT\n         LA    R0,L'ZERRMSG\n         ST    R0,DWD\n         ISPLINK (=C'VCOPY ',=C'ZERRMSG ',DWD,ZERRMSG,=C'MOVE ')\n         LTR   R15,R15                 CHECK RC\n         BNZ   QUIT50                  BAD, EXIT\nSETMSG8  ISPLINK (=C'SETMSG ',ZERRMSG)\n         B     QUIT50\n*\nQUIT16   LA    R7,16                   RC=16\n*---------------------------------------------------------------------*\n*\n*        FREE WORK AREA AND GOBACK TO ISPF\n*\n*---------------------------------------------------------------------*\nQUIT50   TM    OPENLIST,X'80'          OPEN LIST OK?\n         BZ    QUIT53                  NO, JUMP\n         CLOSE MF=(E,OPENLIST)         CLOSE ACB/DCB\n*\nQUIT53   TM    S99RBPTR,X'80'          SVC 99 REQ BLK OK?\n         BNO   QUIT90                  NO, JUMP\n         MVI   S99RB+1,2               VERB=FREE\n         OI    S99TUPTR,X'80'          ONLY 1 T.U.\n         MVI   S99T1+1,1               X'55' -> X'01'\n         LA    R1,S99RBPTR\n         DYNALLOC ,                    FREE THE DATA SET\n*\nQUIT90   LR    R15,R7                  RETURN CODE\n         L     R13,4(,R13)\n         RETURN (14,12),RC=(15)\n***********************************************************************\n*\n*        VSAM READ ROUTINE\n*\n***********************************************************************\nREADVS00 SAVE  (14,12),,'VSAMVIEW READ ROUTINE'\n         LM    R4,R7,0(R1)             INPUT PARMS\n         L     R7,0(,R7)               A(SAVERRTN)\n         ST    R13,4(,R7)              CHAIN SAVE AREA\n         ST    R7,8(,R13)              CHAIN SAVE AREA\n         LR    R13,R7                  NEW SAVE AREA\n         USING SAVERRTN,R13\n         LM    R11,R12,BASEREGS        BASE REGISTERS\n*LOOP\nREADVS10 EQU   *\n         LA    R3,1                    RECORD NUMBER\n         AL    R3,CURRECNO             RECORD NUMBER\n         ST    R3,CURRECNO             RECORD NUMBER\n         C     R3,MAXRECNO             BEYOND END OF FILE?\n         BH    READVS80                YES, EXIT\n*\n         ICM   R0,B'1111',RECCOUNT     COUNT SPECIFIED?\n         BZ    READVS12                NO, JUMP\n         CLR   R0,R3                   USER LIMIT REACHED?\n         BL    READVS80                YES, QUIT\nREADVS12 EQU   *\n*\n*        Check if we have enough memory available\n*\n         SLR   R0,R0\n         LR    R1,R3                   RECORD NUMBER\n         D     R0,=F'1000'             DIVIDE BY SIZE OF A SEGMENT\n         LTR   R0,R0                   START OF A NEW SEGMENT?\n         BNZ   READVS20                NO, JUMP\n         LA    R1,32                   LENGTH OF VIIF HEADER\n         AL    R1,RECSIZE              ADD RECORD LENGTH\n         M     R0,=F'1000'             CALCULATE SIZE OF A SEGMENT\n         AL    R1,=F'100000'           ADD ANOTHER 100K TO BE SAFE\n         AL    R1,UNDOSIZE             ADD SIZE OF UNDO BUFFER\n         GETMAIN RC,LV=(R1),LOC=ANY    ALLOC ROOM FOR 1000 RECORDS\n         LTR   R15,R15                 ENOUGH STORAGE LEFT?\n         BZ    READVS17                YES, JUMP\n         LR    R2,R0                   CUSHION SIZE IN BYTES\n         SRL   R2,10                   CUSHION SIZE IN K\n*\n         STRING 'INSUFFICIENT STORAGE',INTO=MESSAGE\n         ST    R15,DWD                 LENGTH OF SHORT MESSAGE\n         ISPLINK (=C'VREPLACE',=C'ZEDSMSG ',DWD,MESSAGE)\n         STRING 'TOTAL RECORDS: ',(MAXRECNO,F,L),                      X\n               ' RECORDS PROCESSED: ',((R3),,L),                       X\n               ' CUSHION: ',((R2),,L),'K',                             X\n               INTO=MESSAGE\n         ST    R15,DWD                 LENGTH OF LONG MESSAGE\n         ISPLINK (=C'VREPLACE',=C'ZEDLMSG ',DWD,MESSAGE)\n         ISPLINK (=C'SETMSG ',=C'ISRZ001 ')\n*\n         ST    R3,MAXRECNO             NO, TRUNCATE DATA SET\n         L     R0,RECSIZE              RECORD LENGTH\n         LA    R2,MESSAGE              POINT TO MESSAGE AREA\n         STRING '++++++ DATA TRUNCATED ++++++',INTO=((R2),(R0))\n         B     READVS77                PASS MESSAGE TO VIIF\n*\nREADVS17 FREEMAIN RC,LV=(0),A=(1)      FREE UP THE CUSHION\n*\nREADVS20 GET   RPL=IFGRPL              GET NEXT RECORD\n         LTR   R15,R15                 OK?\n         BZ    READVS70                YES, JUMP\n*\n*        ACTUAL END OF DATA (SHOULD ONLY OCCUR WHEN SHOWCB\n*        RETURNED MAXRECNO=0)\n*\n         CLI   RPLRTNCD,X'08'          IS THIS A LOGICAL ERROR?\n         BNE   READVS90                NO, QUIT\n         CLI   RPLFDB3,X'04'           END OF DATA?\n         BE    READVS80                YES, EXIT\n*\n*        THE FIRST TIME A SPANNED RECORD IS READ (FDBK=X'84'),\n*        SWITCH IFGRPL FROM OPTCD=LOC TO OPTCD=MVE.\n*        FROM THAT POINT ON, ALL GETS WILL BE MOVE MODE.\n*        NOTE THAT A CLUSTER DEFINED WITH THE SPANNED ATTRIBUTE\n*        DOES NOT NECESSARILY CONTAIN SPANNED RECORDS (IE RECORDS\n*        MADE UP OF MORE THAN ONE SEGMENT).\n*\nREADVS34 CLI   RPLFDB3,X'48'           OPTCD=KEY WITH DATA COMPONENT?\n         BE    READVS35                YES, JUMP\n*\n         CLI   RPLFDB3,X'84'           OPTCD=LOC WITH SPANNED RECORDS?\n         BNE   READVS90                NO, ERROR\n*\n         NI    RPLOPT1,255-RPLLOC      OPTCD=MVE\n         L     R0,MAXLRECL             MAX RECORD SIZE\n         GETMAIN RU,LV=(0),LOC=ANY     ALLOC BUFFER FOR SPANNED RECORDS\n         ST    R0,RPLBUFL              AREALEN=MAXLRECL\n         ST    R1,RPLAREA              STORE AREA ADDRESS INTO RPL\n         B     READVS40\n*\nREADVS35 MVI   VS_TYPE,C'E'            CLUSTER IS AN ESDS\n         MVI   RPLOPT2,RPLADR          OPTCD=ADR\n*\n*        RE-READ A RECORD AFTER X'48' OR X'84'\n*\nREADVS40 EQU   *\n         GET   RPL=IFGRPL              RE-READ RECORD AFTER 48 OR 84\n         LTR   R15,R15                 OK?\n         BNZ   READVS90                NO, QUIT\n*\n*        RETURN RECORD JUST READ TO VIIF\n*\nREADVS70 CL    R3,RECSKIP              SHOULD I SKIP THIS RECORD?\n*STRING ((R3)),(RECSKIP,F),INTO=MESSAGE\n*TPUT MESSAGE,44\n*CL R3,RECSKIP\n         BNH   READVS10                YES, READ ANOTHER\n*ENDLOOP\n         L     R0,RPLRLEN              PICK UP RECORD LENGTH\n         L     R2,RPLAREA              NO, GET RECORD ADDR (OPTCD=MVE)\n         TM    RPLOPTCD,RPLLOC         OPTCD=MVE?\n         BZ    READVS77                YES, JUMP\n         L     R2,0(,R2)               GET RECORD ADDR (OPTCD=LOC)\n*\nREADVS77 ST    R2,0(,R4)               PASS RECORD ADDRESS TO VIIF\n         ST    R0,0(,R5)               PASS RECORD LENGTH TO VIIF\n         L     R13,4(,R13)\n         RETURN (14,12),RC=00\n*\n*        RECORD NUMBER TOO HIGH, RETURN NUMBER OF HIGHEST RCD TO VIIF\n*\nREADVS80 MVC   0(4,R6),MAXRECNO        RETURN MAX RECORD NUMBER\n         TM    RPLOPT1,RPLLOC          OPTCD=LOC\n         BO    READVS81                YES, JUMP\n         L     R0,RPLBUFL              R0=AREALEN\n         FREEMAIN RU,LV=(0),A=RPLAREA  FREE MOVE MODE BUFFER\nREADVS81 CLOSE MF=(E,OPENLIST)         CLOSE THE ACB\n         L     R13,4(,R13)\n         RETURN (14,12),RC=8\n*\n*        ERROR IN GET MACRO, SHOW FEEDBACK CODE\n*\nREADVS90 STRING '** ERROR ** RPLFDBWD=',(RPLFDBWD,,X),                 X\n               ' REQ=',(RPLREQ,,X),' OPTCD=',(RPLOPTCD,2,X),           X\n               ' RRN=',((R3),,L),' MAXRECNO=',(MAXRECNO,F,L),          X\n               INTO=MESSAGE\n         ST    R3,0(,R6)               END OF FILE\n         ST    R3,MAXRECNO             END OF FILE\n         LA    R15,008                 RC=8 (EOF)\n.@TEST2 SR 15,15\n*\n*        RETURN ERROR MESSAGE TO VIIF\n*\nREADVS95 LA    R0,MESSAGE              MESSAGE\n         ST    R0,0(,R4)               PASS ADDRESS\n         LA    R0,L'MESSAGE            LENGTH\n         ST    R0,0(,R5)               PASS LENGTH\n         L     R13,4(,R13)\n         RETURN (14,12),RC=(15)\n*---------------------------------------------------------------------*\n*        CONSTANTS\n*---------------------------------------------------------------------*\n$ISPLINK DC    C'ISPLINK '             ISPF COMMAND INTERFACE\n$SELECT  DC    C'SELECT'               SERVICE\n$CONTROL DC    C'CONTROL'              FUNCTION\n$ERRORS  DC    C'ERRORS'               OPTION\n$RETURN  DC    C'RETURN'               OPTION\n         PRINT NOGEN\nACB1_M   ACB   MACRF=SEQ,RMODE31=ALL,BUFSP=200000\nACB1_L   EQU   *-ACB1_M\nRPL1_M   RPL   ACB=*-*,OPTCD=(SEQ,LOC),AREA=*-*,AREALEN=4\nRPL1_L   EQU   *-RPL1_M\n***********************************************************************\n*                                                                     *\n*        DYNAMIC STORAGE           <-- R13                            *\n*                                                                     *\n***********************************************************************\nDYNAM    DSECT\n         DS    18F                     SAVE AREA (MAIN LINE)\nSAVERRTN DS    18F                     SAVE AREA (READ ROUTINE)\nBASEREGS DS    A(VSAMVIEW,VSAMVIEW+4095)\nTENWORDS DS    10F\nDWD      DS    D\nOWNNAME  DS    CL8                     MY OWN NAME\nZERRMSG  DS    C'12345678'             ERROR MESSAGE\nEDITVIEW DS    C'VIIF'                 VIIF/EDIF\nREADRTNE DS    A(READVS00)             VSAM read routine\nRECSIZE  DS    F                       INVOCATION PARAMETER\nRECSKIP  DS    F                       INVOCATION PARAMETER\nRECCOUNT DS    F                       INVOCATION PARAMETER\nISPLINK@ DS    V(ISPLINK)              ISPF INTERFACE\nUNDOSIZE DS    F                       STORAGE FOR SETUNDO STG\nDYNANSWR DS    F                       PARSE\nECB1     DS    F                       PARSE\nVS_TYPE  DS    C'K'                    VSAM TYPE: K E R\nBAD_TYPE DS    C'(LDS)'                unsupported cluster type\nOPENLIST OPEN  IFGACB,MF=L\n         IFGACB DSECT=NO\n         IFGRPL DSECT=NO\nRECAD    DS    A                       RECORD ADDRESS\nCURRECNO DS    F'12345678'             CURRENT RECORD NUMBER\nSPANBUFF DS    F,A                     VBS BUFFER\n*\nMAXRECNO DS    F'12345678'          +0 MAX RECORD NUMBER\nMAXLRECL DS    F'32760'             +4 MAX LRECL\n*\nS99RBPTR DS    A(S99RB+X'80000000')\nS99RB    DS    A(X'14012000',0,S99TUPTR,0,0)\nS99TUPTR DS    4A\nS99T1    DS    X'0055,0001',AL2(L'DDNAME)   RETURN DDNAME\nDDNAME   DS    CL8       '\nS99T2    DS    X'0002,0001',AL2(L'DSNAME)   DSNAME\nDSNAME   DS    CL44,C                       DATA SET NAME\n*\n         DS    0F                      ALIGN\nZENVIR   DS    CL32'ISPF 3.2'          CURRENT ISPF LEVEL\nMESSAGE  DS    CL120\nSHORTMSG DS    CL32\nDYNAML   EQU   *-DYNAM\n         STRING (GENERATE,,LOCTR)\n***********************************************************************\n*                                                                     *\n*        DEFINE INPUT PARAMETERS FOR IKJPARS                          *\n*                                                                     *\n***********************************************************************\nPCLCSECT IKJPARM\nDSNPCE   IKJPOSIT DSNAME,USID,PROMPT='DATA SET NAME',                  X\n               HELP='NAME OF THE VSAM DATA SET TO BE EDITED'\nRECSZPCE IKJKEYWD\n         IKJNAME 'RECSIZE',SUBFLD=RECSZPCL\nSKIPPCE  IKJKEYWD\n         IKJNAME 'SKIP',SUBFLD=SKIPPCL\nCOUNTPCE IKJKEYWD\n         IKJNAME 'COUNT',SUBFLD=COUNTPCL\n*SUB-FIELDS\nRECSZPCL IKJSUBF\nRECSZIDL IKJIDENT 'NUMBER',MAXLNTH=5,FIRST=NUMERIC,OTHER=NUMERIC,      X\n               PROMPT='RECORD SIZE',                                   X\n               HELP='RECORD SIZE FOR EDIT'\nSKIPPCL IKJSUBF\nSKIPIDL IKJIDENT 'NUMBER',MAXLNTH=8,FIRST=NUMERIC,OTHER=NUMERIC,       X\n               PROMPT='RECORD SKIP',                                   X\n               HELP='NUMBER OF RECORDS TO SKIP'\nCOUNTPCL IKJSUBF\nCOUNTIDL IKJIDENT 'NUMBER',MAXLNTH=8,FIRST=NUMERIC,OTHER=NUMERIC,      X\n               PROMPT='RECORD COUNT',                                  X\n               HELP='NUMBER OF RECORDS TO EDIT'\n         IKJENDP\n*\n         IKJCPPL                       COMMAND BUFFER PARM LIST\n         IKJPPL                        PARSE PARM LIST (IKJPARS)\n         YREGS\n         IHACDE\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR            IFGACB/IFGRPL\n//         DD DSN=CBTTAPE.FILE183.PDS,DISP=SHR    STRING\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*-------------------------------------------------------------------\n//LKED    EXEC PGM=HEWL,PARM='LIST,MAP,RENT,REFR'\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=CBTTAPE.FILE183.LOAD(VSAMVIEW),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VSAMVW95": {"ttr": 24071, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x16\\x00\\x90\\x07O\\x00\\x95\\x17O\\x12F\\x02f\\x02@\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-03-15T00:00:00", "modifydate": "1995-06-23T12:46:16", "lines": 614, "newlines": 576, "modlines": 0, "user": "CBT476"}, "text": "//GILBERTV JOB (ACCT#),VSAMVIEW,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//ASMH EXEC PGM=IEV90,PARM=(NODECK,OBJECT,NOESD,NORLD,NOXREF)\n         PUNCH ' ALIAS VV'          <- \"VV\" IS AN ALIAS FOR \"VSAMVIEW\"\n***********************************************************************\n*                                                                     *\n* MODULE NAME = VSAMVIEW                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = VIEW A VSAM DATA SET UNDER ISPF                  *\n*                                                                     *\n* FUNCTION = THIS COMMAND ALLOWS YOU TO VIEW A VSAM DATA SET IN       *\n*            ISPF USING EDIF.  THE SAVE COMMAND IS DISABLED, BUT      *\n*            ALL OTHER EDIT FACILITIES ARE AVAILABLE (CREATE, ETC).   *\n*                                                                     *\n* STATUS = R100                                                       *\n*                                                                     *\n* AUTHOR = GILBERT SAINT-FLOUR <carlos@gsf-soft.com>                  *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = MVS/370, MVS/XA, MVS/ESA                          *\n*                   ISPF/PDF V2R3                                     *\n*                                                                     *\n*    AUTHORIZATION = NONE                                             *\n*                                                                     *\n*    RESTRICTIONS = NONE                                              *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (TSO COMMAND PROCESSOR)                    *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 3K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE 24, AMODE 31,                    *\n*                 PROBLEM STATE, KEY 8                                *\n*                                                                     *\n* OPERATION = SEE COMMENTS IN SOURCE CODE                             *\n*                                                                     *\n* SYNTAX = SEE BELOW                                                  *\n*                                                                     *\n*        VSAMVIEW 'DATA-SET-NAME'                                     *\n*                 RECSIZE('MAX-RECORD-LENGTH')                        *\n*                 SKIP('COUNT')                                       *\n*                 COUNT('COUNT')                                      *\n*                                                                     *\n*        REQUIRED: DATA-SET-NAME                                      *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n*   100  INITIAL RELEASE                                              *\n*                                                                     *\n***********************************************************************\nVSAMVIEW CSECT\nVSAMVIEW AMODE 31\n         SAVE  (14,12),,'GSF UTILITIES - VSAMVIEW R100'\n         LR    R11,R15\n         USING VSAMVIEW,R11\n         LA    R12,VSAMVIEW+4095\n         USING VSAMVIEW+4095,R12\n         LR    R9,R1                   SAVE CPPL ADDRESS\n         USING CPPL,R9                 SET UP ADDRESSABILITY TO CPPL\n         ICM   R2,B'1111',CPPL         INVOKED AS A PGM?\n         BM    ALLOCATE                YES, JUMP\n         LA    R3,DYNAML               LENGTH OF DYNAMIC STORAGE AREA\n         GETMAIN R,LV=(R3)             ALLOCATE DYNAMIC STORAGE\n         LR    R2,R1                   CLEAR DYNAMIC STORAGE\n         SLR   R15,R15                 CLEAR DYNAMIC STORAGE\n         MVCL  R2,R14                  CLEAR DYNAMIC STORAGE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LM    R13,R1,8(R13)           SET R13, RELOAD R14-R1\n         USING DYNAM,R13\n         STM   R11,R12,BASEREGS        FOR READ ROUTINES\n***********************************************************************\n*                                                                     *\n*        BUILD PARSE PARM LIST, CALL IKJPARS                          *\n*                                                                     *\n***********************************************************************\nCALLPARS LA    R1,TENWORDS             POINT TO PPL\n         USING PPL,R1                  SET UP ADDRESSABILITY TO PPL\n         L     R0,CPPLUPT              USER PROFILE TABLE\n         ST    R0,PPLUPT               STORE UPT ADDRESS IN PPL\n         L     R0,CPPLECT              ENVIRONMENT CONTROL TABLE\n         ST    R0,PPLECT               STORE ECT IN PPL\n         LA    R0,ECB1                 EVENT CONTROL BLOCK\n         ST    R0,PPLECB               STORE ECB IN PPL\n         MVC   PPLPCL,=A(PCLCSECT)     STORE PCL ADDR INTO PPL\n         LA    R0,DYNANSWR             ANSWER AREA\n         ST    R0,PPLANS               STORE ANSWER ADDRESS IN PPL\n         L     R0,CPPLCBUF             COMMAND BUFFER\n         ST    R0,PPLCBUF              STORE BUFFER ADDRESS IN PPL\n         LA    R14,=C'IKJPARS '        NAME OF PARSE ROUTINE\n         L     R15,16                  CVTPTR\n         L     R15,8(,R15)             CVTLINK\n         STM   R14,R15,DWD             BUILD LINK PARMLIST\n         LINK  SF=(E,DWD)              CALL THE PARSE ROUTINE\n         LTR   R7,R15                  CHECK FOR ZERO PARSE RETURN\n         BNZ   QUIT16                  GO AWAY UPSET\n         DROP  R1,R9                   PPL, CPPL\n***********************************************************************\n*                                                                     *\n*        PROCESS PARSED PARAMETERS                                    *\n*                                                                     *\n***********************************************************************\nPARSE100 L     R2,DYNANSWR             LOAD PDL ADDRESS\n         USING IKJPARMD,R2             SET UP ADDRESSABILITY TO PDL\n         LA    R14,DSNAME              44-BYTE AREA\n         LA    R15,L'DSNAME            GET LENGTH\n         L     R0,DSNPCE               GET ADDRESS\n         LH    R1,DSNPCE+4             ACTUAL LENGTH OF DSN\n         ICM   R1,B'1000',=C' '        PADDING\n         MVCL  R14,R0                  MOVE DATA SET NAME\n*TPUT DSNAME,L'DSNAME\nPARSE180 LA    R1,RECSZIDL             LOAD POINTER TO RECSZ FIELD\n         BAL   R14,PACKCVB             CONVERT PARAMETER\n         ST    R0,RECSIZE              STORE RECORD SIZE\n         LA    R1,SKIPIDL              LOAD POINTER TO SKIP FIELD\n         BAL   R14,PACKCVB             CONVERT PARAMETER\n         ST    R0,RECSKIP              STORE SKIP COUNT\n         LA    R1,COUNTIDL             LOAD POINTER TO COUNT FIELD\n         BAL   R14,PACKCVB             CONVERT PARAMETER\n         AL    R0,RECSKIP              ADD SKIP COUNT\n         ST    R0,RECCOUNT             STORE UPPER LIMIT\n*\n*        FREE-UP STORAGE ACQUIRED BY PARSE\n*\n         IKJRLSA DYNANSWR              FREE PDL\n*\n*        BUMP MY USE COUNT TO PREVENT S0C4 ON $SELECT\n*\n         L     R1,540(,0)              PSATOLD (MY TCB)\n         L     R1,0(,R1)               TCBRBP (MY PRB)\n         ICM   R1,B'0111',X'00D'(R1)   RBCDE1 (MY CDE)\n         MVC   OWNNAME,CDNAME-CDENTRY(R1) MOVE OWN NAME\n         LOAD  EPLOC=OWNNAME           BUMP CDUSE\n*\n*        RE-INVOKE MYSELF AS A PGM AND PASS THE ADDR OF THE DYNAMIC\n*        STORAGE AREA IN THE PARM.\n*\n         STRING 'PGM(',(OWNNAME,,T),') PARM(',((R13),,R8Z),')',        X\n               INTO=MESSAGE\n         ST    R15,DWD                 LENGTH\n         LA    R14,$SELECT             SERVICE\n         LA    R15,DWD                 LENGTH\n         LA    R0,MESSAGE              PARAMETERS\n         STM   R14,R1,TENWORDS         PARM LIST\n         OI    TENWORDS+8,X'80'        PARM LIST\n         LA    R1,TENWORDS             PARM LIST\n         L     R13,4(,R13)             CALLER'S SAVE AREA\n         XCTL  (2,12),EPLOC=$ISPLINK\n*---------------------------------------------------------------------*\n*        PACKCVB SUB-ROUTINE                                          *\n*---------------------------------------------------------------------*\nPACKCVB  LH    R15,4(,R1)              LOAD LENGTH\n         LTR   R0,R15                  THIS PARM SPECIFIED?\n         BZR   R14                     NO, GOBACK WITH R0=0\n         L     R1,0(,R1)               LOAD ADDRESS\n         BCTR  R15,0                   DECREMENT R15 FOR EXECUTE\n         EX    R15,PACKCVBX            PACK VALUE\n         CVB   R0,DWD                  CONVERT ZONED TO BINARY\n         BR    R14\nPACKCVBX PACK  DWD,0(,R1)              *EXECUTED*\n*---------------------------------------------------------------------*\n         MACRO                                                    MACRO\n&NAME    ISPLINK &OPRNDS,&ERRET=                                  MACRO\n         GBLB  &IHBSWA                                            MACRO\n&IHBSWA  SETB  1                       VL=1                       MACRO\n&NAME    LA    R1,TENWORDS             PARM LIST                  MACRO\n         IHBOPLST ,&OPRNDS,MF=(E,(1))                             MACRO\n         L     R15,ISPLINK@            ISPLINK BOOTSTRAP\n         BALR  R14,R15                 INVOKE ISPLINK\n         AIF   (T'&ERRET EQ 'O').MEND                             MACRO\n         LTR   R15,R15                 ANY ERROR?\n         BNZ   &ERRET                  YES, JUMP\n.MEND    MEND                                                     MACRO\n***********************************************************************\n*                                                                     *\n*        ALLOCATE THE DATA SET                                        *\n*                                                                     *\n***********************************************************************\nALLOCATE PACK  16(8,R13),2(8,R2)       PACK THE PARM\n         CVB   R1,16(,R13)             GET IT IN BINARY\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LM    R13,R1,8(R13)           SET R13, RELOAD R14-R1\n         USING DYNAM,R13\n*---------------------------------------------------------------------*\n*        ISPEXEC CONTROL ERRORS RETURN                                *\n*---------------------------------------------------------------------*\n         LOAD  EPLOC=$ISPLINK\n         ST    R0,ISPLINK@             SAVE ISPLINK ADDRESS\n         LA    R1,=A($CONTROL,$ERRORS,$RETURN+X'80000000')\n         L     R15,ISPLINK@\n         BALR  R14,R15                 CONTROL ERRORS RETURN\n         LTR   R15,R15\n         BNZ   QUIT16                  ISPF NOT ACTIVE\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ALLOCATE THE DATA SET                                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MVC   S99RB,=X'14,01,2000'    SVC 99 REQUEST BLOCK\n         LA    R1,S99TUPTR             TEXT UNIT POINTERS\n         ST    R1,S99RB+8              TEXT UNIT POINTERS\n*\n         LA    R14,S99T1                   RETURN DDNAME\n         MVC   S99T1(6),=X'0055,0001,0008' RETURN DDNAME\n         LA    R15,S99T2                   DSNAME\n         MVC   S99T2(6),=X'0002,0001,002C' DSNAME\n         LA    R0,=X'0004,0001,0001,08'    DISP=SHR\n         LA    R1,=X'001C,0000'            FREE=CLOSE\n         STM   R14,R1,S99TUPTR             TEXT-UNIT POINTERS\n         OI    S99TUPTR+12,X'80'           END OF LIST\n*\n         LA    R1,S99RB                BUILD SVC99 PARM LIST\n         ST    R1,S99RBPTR             BUILD SVC99 PARM LIST\n         OI    S99RBPTR,X'80'          BUILD SVC99 PARM LIST\n         LA    R1,S99RBPTR\n         DYNALLOC ,                    ALLOCATE THE DATA SET\n         LTR   R15,R15\n NOP 0   BNZ   ALLOC900                SVC99 FAILED, JUMP\n*---------------------------------------------------------------------*\n*                                                                     *\n*        INITIALIZE VSAM CONTROL BLOCKS (ACB, RPL)                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MVC   IFGACB(ACB1_L),ACB1_M   MOVE ACB,RPL\n         MVC   ACBDDNM,DDNAME          MOVE DDNAME\n         LA    R2,IFGACB               POINT TO ACB\n         ST    R2,OPENLIST             BUILD OPEN LIST\n         MVI   OPENLIST,X'80'          BUILD OPEN LIST\n         OPEN  MF=(E,OPENLIST)         OPEN VSAM DATA SET\n         CH    R15,=H'4'               OPEN OK?\n         BH    OPENR160                NO, QUIT\n*\n         SHOWCB ACB=(R2),AREA=(S,MAXRECNO),LENGTH=12,                  X\n               FIELDS=(NLOGR,LRECL),MF=(G,MESSAGE)\n         ICM   R0,B'1111',MAXLRECL     LRECL=0 (LDS)\n         BZ    OPENR160                YES, JUMP\n*\n         ICM   R0,B'1111',MAXRECNO     EMPTY/OPEN ?\n         BNZ   OPENVS4                 NO, JUMP\n         MVI   MAXRECNO,X'7F'          YES, SET MAX NUMBER\n         ICM   R0,B'1111',RECCOUNT     COUNT SPECIFIED?\n         BZ    OPENVS4                 NO, JUMP\n         ST    R0,MAXRECNO             YES, USE COUNT\nOPENVS4  EQU   *\n*\n*        SET UP RPL FOR ESDS/KSDS\n*\n         MVC   IFGRPL(RPL1_L),RPL1_M   MOVE ACB,RPL\n*TPUT =C'ST R2,RPLDACB',13\n         ST    R2,RPLDACB              STORE ACB ADDRESS INTO RPL\n         LA    R0,RECAD                THE RIGHT WORD\n         ST    R0,RPLAREA              STORE AREA ADDRESS INTO RPL\n         LA    R0,L'RECAD              ADDRESS\n         ST    R0,RPLBUFL              STORE AREA LENGTH INTO RPL\n*\n         TESTCB ACB=(R2),ATRB=KSDS,MF=(G,MESSAGE) IS THIS A KSDS?\n         BE    OPENKSDS                YES, JUMP\n         TESTCB ACB=(R2),ATRB=RRDS,MF=(G,MESSAGE) IS THIS AN RRDS?\n         BE    OPENRRDS                YES, JUMP\n         TESTCB ACB=(R2),ATRB=ESDS,MF=(G,MESSAGE) IS THIS AN ESDS?\n         BNE   OPENR160                UNSUPPORTED TYPE\n*\nOPENESDS MVI   VS_TYPE,C'E'            CLUSTER IS AN ESDS\n         B     OPENVS6\n*\nOPENKSDS MVI   VS_TYPE,C'K'            CLUSTER IS A KSDS\n         B     OPENVS6\n*\nOPENRRDS MVI   VS_TYPE,C'R'            CLUSTER IS AN RRDS\n         LA    R0,CURRECNO             RECORD NUMBER\n         ST    R0,RPLARG               RECORD NUMBER\n         OI    RPLOPT1,RPLDIR          OPTCD=(DIR,KEY)\n*\nOPENVS6  EQU   *\n         LOAD  EP=ISRCONFG             PDF CONFIG TABLE\n         LR    R1,R0                   ENTRY ADDRESS\n         L     R2,X'190'(,R1)          UNDOSIZE (IN K)\n         SLL   R2,10                   UNDOSIZE (IN BYTES)\n         ST    R2,UNDOSIZE             ADD SIZE OF UNDO BUFFER\n*\n         ICM   R0,B'1111',RECSIZE      RECSIZE PARM SPECIFIED?\n         BNZ   *+10                    NO, EXIT\n         MVC   RECSIZE,MAXLRECL        USE CALLER'S RECORD SIZE\n*\n         B     EDIF\n*\n*        VSAM OPEN ERROR\n*\nOPENR160 CLI   ACBERFLG,160            EMPTY DATA SET?\n         BNE   QUIT16                  NO, QUIT\n         MVC   ZERRMSG,=C'ISRB603 '    \"NO DATA TO BROWSE\"\n         LA    R7,4                    RC=4\n         B     SETMSG8                 ISSUE MESSAGE\n***********************************************************************\n*\n*        INVOKE ISPF/PDF EDIF SERVICE\n*\n***********************************************************************\nEDIF     LA    R0,SAVERRTN             DDATA FOR EDIF\n         ST    R0,SAVERRTN             DDATA FOR EDIF\n*\n         ISPLINK (=C'EDIF',            SERVICE                         X\n               DSNAME,                 DATA SET NAME                   X\n               =C'VSAMVIEW',           PROFILE NAME                    X\n               =C'V ',                 RECFM                           X\n               RECSIZE,                RECORD LENGTH                   X\n               =A(READRTNE),           READ ROUTINE                    X\n               =A(WRITERTN),           WRITE ROUTINE                   X\n               0,                      COMMAND EXIT                    X\n               SAVERRTN)               DIALOG DATA ADDR\n         LR    R7,R15                  SAVE RETURN CODE FROM EDIF\n***********************************************************************\n*\n*        PROGRAM EXIT\n*\n*           1. ISSUE ERROR MESSAGE\n*           2. CLEAN UP\n*           3. GOBACK TO CALLER\n*\n***********************************************************************\nSETMSG   LTR   R7,R7                   CHECK RC FROM EDIF\n         BZ    QUIT50                  OK, EXIT\n         LA    R0,L'ZERRMSG\n         ST    R0,DWD\n         ISPLINK (=C'VCOPY ',=C'ZERRMSG ',DWD,ZERRMSG,=C'MOVE ')\n         LTR   R15,R15                 CHECK RC\n         BNZ   QUIT50                  BAD, EXIT\nSETMSG8  ISPLINK (=C'SETMSG ',ZERRMSG)\n         B     QUIT50\n*\nQUIT16   LA    R7,16                   RC=16\n*---------------------------------------------------------------------*\n*\n*        FREE WORK AREA AND GOBACK TO ISPF\n*\n*---------------------------------------------------------------------*\nQUIT50   TM    OPENLIST,X'80'          OPEN LIST OK?\n         BZ    QUIT53                  NO, JUMP\n         CLOSE MF=(E,OPENLIST)         CLOSE ACB/DCB\n*\nQUIT53   TM    S99RBPTR,X'80'          SVC 99 REQ BLK OK?\n         BNO   QUIT90                  NO, JUMP\n         MVI   S99RB+1,2               VERB=FREE\n         OI    S99TUPTR,X'80'          ONLY 1 T.U.\n         MVI   S99T1+1,1               X'55' -> X'01'\n         LA    R1,S99RBPTR\n         DYNALLOC ,                    FREE THE DATA SET\n*\nQUIT90   LR    R15,R7                  RETURN CODE\n         L     R13,4(,R13)\n         RETURN (14,12),RC=(15)\n***********************************************************************\n*\n*        VSAM READ ROUTINE\n*\n***********************************************************************\nREADRTNE SAVE  (14,12),,'VSAMVIEW READ ROUTINE'\n         LM    R4,R7,0(R1)             INPUT PARMS\n         L     R7,0(,R7)               A(SAVERRTN)\n         ST    R13,4(,R7)              CHAIN SAVE AREA\n         ST    R7,8(,R13)              CHAIN SAVE AREA\n         LR    R13,R7                  NEW SAVE AREA\n         USING SAVERRTN,R13\n         LM    R11,R12,BASEREGS        BASE REGISTERS\n*LOOP\nREADVS10 EQU   *\n         LA    R3,1                    RECORD NUMBER\n         AL    R3,CURRECNO             RECORD NUMBER\n         ST    R3,CURRECNO             RECORD NUMBER\n         C     R3,MAXRECNO             BEYOND END OF FILE?\n         BH    READVS80                YES, EXIT\n*\n         ICM   R0,B'1111',RECCOUNT     COUNT SPECIFIED?\n         BZ    READVS12                NO, JUMP\n         CLR   R0,R3                   USER LIMIT REACHED?\n         BL    READVS80                YES, QUIT\nREADVS12 EQU   *\n*\n         SLR   R0,R0\n         LR    R1,R3                   RECORD NUMBER\n         D     R0,=F'1000'             DIVIDE BY SIZE OF A SEGMENT\n         LTR   R0,R0                   START OF A NEW SEGMENT?\n         BNZ   READVS20                NO, JUMP\n         LA    R1,32                   LENGTH OF EDIF HEADER\n         AL    R1,RECSIZE              ADD RECORD LENGTH\n         M     R0,=F'1000'             CALCULATE SIZE OF A SEGMENT\n         AL    R1,=F'100000'           ADD ANOTHER 100K TO BE SAFE\n         AL    R1,UNDOSIZE             ADD SIZE OF UNDO BUFFER\n         GETMAIN RC,LV=(R1),LOC=ANY    ALLOC ROOM FOR 1000 RECORDS\n         LTR   R15,R15                 ENOUGH STORAGE LEFT?\n         BZ    READVS17                YES, JUMP\n         LR    R2,R0                   CUSHION SIZE IN BYTES\n         SRL   R2,10                   CUSHION SIZE IN K\n*\n         STRING 'INSUFFICIENT STORAGE',INTO=MESSAGE\n         ST    R15,DWD                 LENGTH OF SHORT MESSAGE\n         ISPLINK (=C'VREPLACE',=C'ZEDSMSG ',DWD,MESSAGE)\n         STRING 'TOTAL RECORDS: ',(MAXRECNO,F,L),                      X\n               ' RECORDS PROCESSED: ',((R3),,L),                       X\n               ' CUSHION: ',((R2),,L),'K',                             X\n               INTO=MESSAGE\n         ST    R15,DWD                 LENGTH OF LONG MESSAGE\n         ISPLINK (=C'VREPLACE',=C'ZEDLMSG ',DWD,MESSAGE)\n         ISPLINK (=C'SETMSG ',=C'ISRZ001 ')\n*\n         ST    R3,MAXRECNO             NO, TRUNCATE DATA SET\n         L     R0,RECSIZE              RECORD LENGTH\n         LA    R2,MESSAGE              POINT TO MESSAGE AREA\n         STRING '++++++ DATA TRUNCATED ++++++',INTO=((R2),(R0))\n         B     READVS77                PASS MESSAGE TO EDIF\n*\nREADVS17 FREEMAIN RC,LV=(0),A=(1)      FREE UP THE CUSHION\n*\nREADVS20 GET   RPL=IFGRPL              GET NEXT RECORD\n         LTR   R15,R15                 OK?\n         BZ    READVS70                YES, JUMP\n*\n*        ACTUAL END OF DATA (SHOULD ONLY OCCUR WHEN SHOWCB\n*        RETURNED MAXRECNO=0)\n*\n         CLI   RPLRTNCD,X'08'          IS THIS A LOGICAL ERROR?\n         BNE   READVS90                NO, QUIT\n         CLI   RPLFDB3,X'04'           END OF DATA?\n         BE    READVS80                YES, EXIT\n*\n*        THE FIRST TIME A SPANNED RECORD IS READ (FDBK=X'84'),\n*        SWITCH IFGRPL FROM OPTCD=LOC TO OPTCD=MVE.\n*        FROM THAT POINT ON, ALL GETS WILL BE MOVE MODE.\n*        NOTE THAT A CLUSTER DEFINED WITH THE SPANNED ATTRIBUTE\n*        DOES NOT NECESSARILY CONTAIN SPANNED RECORDS (IE RECORDS\n*        MADE UP OF MORE THAN ONE SEGMENT).\n*\nREADVS34 CLI   RPLFDB3,X'48'           OPTCD=KEY WITH DATA COMPONENT?\n         BE    READVS35                YES, JUMP\n*\n         CLI   RPLFDB3,X'84'           OPTCD=LOC WITH SPANNED RECORDS?\n         BNE   READVS90                NO, ERROR\n*\n         NI    RPLOPT1,255-RPLLOC      OPTCD=MVE\n         L     R0,MAXLRECL             MAX RECORD SIZE\n         GETMAIN RU,LV=(0),LOC=ANY     ALLOC BUFFER FOR SPANNED RECORDS\n         ST    R0,RPLBUFL              AREALEN=MAXLRECL\n         ST    R1,RPLAREA              STORE AREA ADDRESS INTO RPL\n         B     READVS40\n*\nREADVS35 MVI   VS_TYPE,C'E'            CLUSTER IS AN ESDS\n         MVI   RPLOPT2,RPLADR          OPTCD=ADR\n*\n*        RE-READ A RECORD AFTER X'48' OR X'84'\n*\nREADVS40 EQU   *\n         GET   RPL=IFGRPL              RE-READ RECORD AFTER 48 OR 84\n         LTR   R15,R15                 OK?\n         BNZ   READVS90                NO, QUIT\n*\n*        RETURN RECORD JUST READ TO EDIF\n*\nREADVS70 CL    R3,RECSKIP              SHOULD I SKIP THIS RECORD?\n*STRING ((R3)),(RECSKIP,F),INTO=MESSAGE\n*TPUT MESSAGE,44\n*CL R3,RECSKIP\n         BNH   READVS10                YES, READ ANOTHER\n*ENDLOOP\n         L     R0,RPLRLEN              PICK UP RECORD LENGTH\n         L     R2,RPLAREA              NO, GET RECORD ADDR (OPTCD=MVE)\n         TM    RPLOPTCD,RPLLOC         OPTCD=MVE?\n         BZ    READVS77                YES, JUMP\n         L     R2,0(,R2)               GET RECORD ADDR (OPTCD=LOC)\n*\nREADVS77 ST    R2,0(,R4)               PASS RECORD ADDRESS TO EDIF\n         ST    R0,0(,R5)               PASS RECORD LENGTH TO EDIF\n         L     R13,4(,R13)\n         RETURN (14,12),RC=00\n*\n*        RECORD NUMBER TOO HIGH, RETURN NUMBER OF HIGHEST RCD TO EDIF\n*\nREADVS80 MVC   0(4,R6),MAXRECNO        RETURN MAX RECORD NUMBER\n         TM    RPLOPT1,RPLLOC          OPTCD=LOC\n         BO    READVS81                YES, JUMP\n         L     R0,RPLBUFL              R0=AREALEN\n         FREEMAIN RU,LV=(0),A=RPLAREA  FREE MOVE MODE BUFFER\nREADVS81 CLOSE MF=(E,OPENLIST)         CLOSE THE ACB\n         L     R13,4(,R13)\n         RETURN (14,12),RC=8\n*\n*        ERROR IN GET MACRO, SHOW FEEDBACK CODE\n*\nREADVS90 STRING '** ERROR ** RPLFDBWD=',(RPLFDBWD,,X),                 X\n               ' REQ=',(RPLREQ,,X),' OPTCD=',(RPLOPTCD,2,X),           X\n               ' RRN=',((R3),,L),' MAXRECNO=',(MAXRECNO,F,L),          X\n               INTO=MESSAGE\n         ST    R3,0(,R6)               END OF FILE\n         ST    R3,MAXRECNO             END OF FILE\n         LA    R15,008                 RC=8 (EOF)\n.@TEST2 SR 15,15\n*\n*        RETURN ERROR MESSAGE TO EDIF\n*\nREADVS95 LA    R0,MESSAGE              MESSAGE\n         ST    R0,0(,R4)               PASS ADDRESS\n         LA    R0,L'MESSAGE            LENGTH\n         ST    R0,0(,R5)               PASS LENGTH\n         L     R13,4(,R13)\n         RETURN (14,12),RC=(15)\n*---------------------------------------------------------------------*\n*        DUMMY WRITE ROUTINE                                          *\n*---------------------------------------------------------------------*\nWRITERTN SAVE  (14,12),,WRITERTN\n         RETURN (14,12),RC=16\n*---------------------------------------------------------------------*\n*        CONSTANTS\n*---------------------------------------------------------------------*\n$ISPLINK DC    C'ISPLINK '             ISPF COMMAND INTERFACE\n$SELECT  DC    C'SELECT'               SERVICE\n$CONTROL DC    C'CONTROL'              FUNCTION\n$ERRORS  DC    C'ERRORS'               OPTION\n$RETURN  DC    C'RETURN'               OPTION\n         PRINT NOGEN\nACB1_M   ACB   MACRF=SEQ,RMODE31=ALL,BUFSP=200000\nACB1_L   EQU   *-ACB1_M\nRPL1_M   RPL   ACB=*-*,OPTCD=(SEQ,LOC),AREA=*-*,AREALEN=4\nRPL1_L   EQU   *-RPL1_M\n***********************************************************************\n*                                                                     *\n*        DYNAMIC STORAGE           <-- R13                            *\n*                                                                     *\n***********************************************************************\nDYNAM    DSECT\n         DS    18F                     SAVE AREA (MAIN LINE)\nSAVERRTN DS    18F                     SAVE AREA (READ ROUTINE)\nBASEREGS DS    A(VSAMVIEW,VSAMVIEW+4095)\nTENWORDS DS    10F\nDWD      DS    D\nOWNNAME  DS    CL8                     MY OWN NAME\nZERRMSG  DS    C'12345678'             ERROR MESSAGE\nRECSIZE  DS    F                       INVOCATION PARAMETER\nRECSKIP  DS    F                       INVOCATION PARAMETER\nRECCOUNT DS    F                       INVOCATION PARAMETER\nISPLINK@ DS    V(ISPLINK)              ISPF INTERFACE\nUNDOSIZE DS    F                       STORAGE FOR SETUNDO STG\nDYNANSWR DS    F                       PARSE\nECB1     DS    F                       PARSE\nVS_TYPE  DS    C'K'                    VSAM TYPE: K E R\nOPENLIST OPEN  IFGACB,MF=L\n         IFGACB DSECT=NO\n         IFGRPL DSECT=NO\nRECAD    DS    A                       RECORD ADDRESS\nCURRECNO DS    F'12345678'             CURRENT RECORD NUMBER\nSPANBUFF DS    F,A                     VBS BUFFER\n*\nMAXRECNO DS    F'12345678'          +0 MAX RECORD NUMBER\nMAXLRECL DS    F'32760'             +4 MAX LRECL\n*\nS99RBPTR DS    A(S99RB+X'80000000')\nS99RB    DS    A(X'14012000',0,S99TUPTR,0,0)\nS99TUPTR DS    4A\nS99T1    DS    X'0055,0001',AL2(L'DDNAME)   RETURN DDNAME\nDDNAME   DS    CL8       '\nS99T2    DS    X'0002,0001',AL2(L'DSNAME)   DSNAME\nDSNAME   DS    CL44,C                       DATA SET NAME\n*\nMESSAGE  DS    CL120\nDYNAML   EQU   *-DYNAM\n         STRING GENERATE\n***********************************************************************\n*                                                                     *\n*        DEFINE INPUT PARAMETERS FOR IKJPARS                          *\n*                                                                     *\n***********************************************************************\nPCLCSECT IKJPARM\nDSNPCE   IKJPOSIT DSNAME,LIST,USID,PROMPT='DATA SET NAME',             X\n               HELP='NAME OF THE VSAM DATA SET TO BE EDITED'\nRECSZPCE IKJKEYWD\n         IKJNAME 'RECSIZE',SUBFLD=RECSZPCL\nSKIPPCE  IKJKEYWD\n         IKJNAME 'SKIP',SUBFLD=SKIPPCL\nCOUNTPCE IKJKEYWD\n         IKJNAME 'COUNT',SUBFLD=COUNTPCL\n*SUB-FIELDS\nRECSZPCL IKJSUBF\nRECSZIDL IKJIDENT 'NUMBER',MAXLNTH=5,FIRST=NUMERIC,OTHER=NUMERIC,      X\n               PROMPT='RECORD SIZE',                                   X\n               HELP='RECORD SIZE FOR EDIT'\nSKIPPCL IKJSUBF\nSKIPIDL IKJIDENT 'NUMBER',MAXLNTH=8,FIRST=NUMERIC,OTHER=NUMERIC,       X\n               PROMPT='RECORD SKIP',                                   X\n               HELP='NUMBER OF RECORDS TO SKIP'\nCOUNTPCL IKJSUBF\nCOUNTIDL IKJIDENT 'NUMBER',MAXLNTH=8,FIRST=NUMERIC,OTHER=NUMERIC,      X\n               PROMPT='RECORD COUNT',                                  X\n               HELP='NUMBER OF RECORDS TO EDIT'\n         IKJENDP\n*\n         IKJCPPL                       COMMAND BUFFER PARM LIST\n         IKJPPL                        PARSE PARM LIST (IKJPARS)\n         YREGS\n         IHACDE\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR            DIV\n//         DD DSN=SYS1.MODGEN,DISP=SHR            IFGACB/IFGRPL\n//         DD DSN=CBTTAPE.FILE183.PDS,DISP=SHR    STRING\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*-------------------------------------------------------------------\n//LKED    EXEC PGM=HEWL,PARM='LIST,MAP,RENT'\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=CBTTAPE.FILE183.LOAD(VSAMVIEW),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VSAVE": {"ttr": 24327, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04\\x04\\x00W\\x00\\x95\\x12_\\x01\\t%/\\x12&\\x00\\x9c\\x00d\\x00\\x1d\\xc3\\xc2\\xe3\\xf4\\xf7\\xf8@@@@'", "ispf": {"version": "04.04", "flags": 0, "createdate": "1995-05-05T00:00:00", "modifydate": "2009-09-09T12:26:57", "lines": 156, "newlines": 100, "modlines": 29, "user": "CBT478"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* MODULE NAME = VIEWSAVE                                             */\n/*                                                                    */\n/* DESCRIPTIVE NAME = SAVE command for VIEW                           */\n/*                                                                    */\n/* STATUS   =  R404                                                   */\n/*                                                                    */\n/* FUNCTION =  This ISPF EDIT macro provides the equivalent of the    */\n/*             SAVE command in a VIEW session (SAVE is only available */\n/*             in EDIT).  VIEWSAVE uses REPLACE to write the data     */\n/*             and LMMSTATS to set the statistics.  This macro        */\n/*             supports PDS members and sequential data sets.         */\n/*                                                                    */\n/*             LMMSTATS is only used if STATS ON is in effect and     */\n/*             the member's directory entry contains ISPF statistics. */\n/*             In that case, the VERSION, LEVEL, CREATED, INIT and    */\n/*             MOD values are set to the values that would have been  */\n/*             set by the SAVE command in EDIT.                       */\n/*                                                                    */\n/* AUTHOR   =  Gilbert Saint-Flour <carlos@gsf-soft.com>              */\n/*             http://gsf-soft.com/Freeware/                          */\n/*                                                                    */\n/* SYNTAX   =  VIEWSAVE <DEBUG>                                       */\n/*                                                                    */\n/* DEPENDENCIES =  ISPF V4                                            */\n/*                                                                    */\n/* Change Activity:                                                   */\n/*                                                                    */\n/*  401   Prevent LMMSTATS failure when zlvers=00                     */\n/*  402   Support for sequential data sets (Carl Hafner)              */\n/*  403   ISRE017                                                     */\n/*  404   Blank Dsname                                                */\n/*                                                                    */\n/**********************************************************************/\nADDRESS 'ISPEXEC'\n\"ISREDIT MACRO (DEBUG)\"\nIF rc>0 THEN EXIT rc                            /* not an EDIT macro */\nUPPER debug\n\"CONTROL ERRORS RETURN\"\n\"ISREDIT (zdsn) = DATASET\"\nIF zdsn='' THEN DO                                  /* SDSF=SE   */\n  VGET zapplid\n  Zedsmsg = \"Blank Dsname\"                       /* Short message    */\n  Zedlmsg = \"Data Set Name only contains spaces, APPLID=\" || zapplid\n  \"SETMSG MSG(ISRZ001)\"                          /* send the message */\n  EXIT 12\n  END\n\"ISREDIT (zmemb) = MEMBER\"\nIF zmemb='' THEN                                    /* DSORG=PS  */\n  CALL Process_sequential_data_set\n /*------------------------------------------------------------------*/\n /*     Fast-path processing when STATS=OFF                          */\n /*------------------------------------------------------------------*/\n\"ISREDIT (stats) = STATS\"\nIF stats='OFF' THEN DO                              /* STATS=OFF    */\n  \"ISREDIT REPLACE\" zmemb \".ZFIRST .ZLAST\"          /* SAVE MEMBER  */\n  CALL Check_RC rc,0,'REPLACE'\n  \"SETMSG MSG(ISRE016)\"                       /* member zmemb saved */\n  EXIT\n  END\n /*------------------------------------------------------------------*/\n /*     Prevent LMMSTATS failure when VERSION=00                     */\n /*------------------------------------------------------------------*/\n\"ISREDIT (zlvers) = VERSION\"                        /* NEW VERSION   */\nIF zlvers=0 THEN DO\n  Zedsmsg = \"Invalid Version\"                    /* Short message    */\n  Zedlmsg = \"Version 00 is not supported by the LMMSTATS service\".\n  \"SETMSG MSG(ISRZ001)\"                          /* send the message */\n  EXIT 4                    /* not supported in this release */\n  END\n /*------------------------------------------------------------------*/\n /*     Retrieve current statistics from member's directory entry    */\n /*------------------------------------------------------------------*/\n\"ISREDIT (dataid) = DATAID\"\n\"LMOPEN DATAID(\"dataid\")\"\nCALL Check_RC rc,0,'LMOPEN'\n\"LMMFIND DATAID(\"dataid\") MEMBER(\"zmemb\") STATS(YES)\" /* GET STATS   */\nlmmfind_rc=rc                                    /* save return code */\nCALL Check_RC rc,8,'LMMFIND'\n /*------------------------------------------------------------------*/\n /*     Rewrite member using the REPLACE command                     */\n /*------------------------------------------------------------------*/\n\"ISREDIT (n1,n2) = NUMBER\"\nmodlines=0                                        /* modified lines  */\nIF n1='ON' & LEFT(n2,1)='S' THEN DO               /* NUMBER ON STD   */\n  \"ISREDIT (ustat) = USER_STATE\"                  /* push user_state */\n  CALL Count_modlines                      /* Cound modified lines   */\n  \"ISREDIT REPLACE\" zmemb \".ZF .ZL\"               /* SAVE MEMBER     */\n  xrc=rc\n  \"ISREDIT USER_STATE = (ustat)\"                  /* pop user_state  */\n  CALL Check_RC xrc,0,'REPLACE'\n  END\nELSE DO                                           /* NUMBER OFF      */\n  \"ISREDIT REPLACE\" zmemb \".ZF .ZL\"               /* SAVE MEMBER     */\n  CALL Check_RC rc,0,'REPLACE'\n  END\n /*------------------------------------------------------------------*/\n /*     Update statistics using LMMSTATS                             */\n /*------------------------------------------------------------------*/\n\"ISREDIT (zlvers) = VERSION\"                        /* NEW VERSION   */\n\"ISREDIT (zlmod) = LEVEL\"                           /* NEW LEVEL     */\nIF lmmfind_rc=8 THEN                                /* new member    */\n  \"LMMSTATS DATAID(\"dataid\") MEMBER(\"zmemb\")\",\n      \"VERSION(\"zlvers\") MODLEVEL(\"zlmod\")\",\n      \"MODRECS(\"modlines+0\")\"\nELSE                                        /* member existed before */\n  \"LMMSTATS DATAID(\"dataid\") MEMBER(\"zmemb\")\",\n      \"VERSION(\"zlvers\") MODLEVEL(\"zlmod\")\",\n      \"CREATED(\"zlcdate\") INITSIZE(\"zlinorc\")\",\n      \"MODRECS(\"modlines+0\")\"\nCALL Check_RC rc,0,'LMMSTATS'\n /*------------------------------------------------------------------*/\n /*     Issue completion message and exit                            */\n /*------------------------------------------------------------------*/\n\"LMCLOSE DATAID(\"dataid\")\"\nCALL Check_RC rc,0,'LMCLOSE'\n\"SETMSG MSG(ISRE016)\"                         /* member zmemb saved */\nEXIT\n\n /*------------------------------------------------------------------*/\n /*     Count_modlines internal function: Count modified lines       */\n /*------------------------------------------------------------------*/\nCount_modlines:\n  \"ISREDIT NUMBER OFF\"\n  \"ISREDIT (recfm) = RECFM\"\n  IF recfm='F' THEN\n    \"ISREDIT (lrecl) = LRECL\"\n  ELSE\n    lrecl=8                                         /* RECFM=V        */\n  \"ISREDIT (modlines) = LINENUM .ZL\"          /* total number of lines*/\n  \"ISREDIT SEEK '00' ALL\" lrecl-1             /*count unmodified lines*/\n  IF rc=0 THEN DO\n    \"ISREDIT (c1,c2) = SEEK_COUNTS\"\n    modlines=modlines-c1                            /* modified lines*/\n    END\n  IF debug='DEBUG' THEN\n    SAY recfm lrecl xrc rc c1 c2 c3 modlines\n  RETURN\n /*------------------------------------------------------------------*/\n /*           Process a sequential data set                          */\n /*------------------------------------------------------------------*/\nProcess_sequential_data_set:\n  \"ISREDIT REPLACE '\"zdsn\"'\" .zfirst .zlast\n  \"SETMSG MSG(ISRE017)\"\n  EXIT\n /*------------------------------------------------------------------*/\n /*           Error routine                                          */\n /*------------------------------------------------------------------*/\nCheck_rc:\n  IF arg(1)\\>arg(2) THEN RETURN                 /* RC=0 */\n  \"SETMSG MSG(\"zerrmsg\")\"\n  \"LMCLOSE DATAID(\"dataid\")\"\n  IF debug='DEBUG' THEN\n    SAY 'FUNC='arg(3) 'RC='arg(1) 'ZERRMSG='zerrmsg\n  EXIT 20\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WHEREIS": {"ttr": 24331, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x004\\x00\\x90\\x13/\\x01\\x00\\x02o!1\\x00k\\x00\\x00\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf0\\xf9@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1990-05-12T00:00:00", "modifydate": "2000-01-26T21:31:34", "lines": 107, "newlines": 0, "modlines": 0, "user": "CBT409"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* Module Name = WHEREIS                                              */\n/*                                                                    */\n/* Descriptive Name = Search for a member in allocated libraries      */\n/*                                                                    */\n/* Status = R200                                                      */\n/*                                                                    */\n/* Function = Look for all occurences of a member in the libraries    */\n/*            currently allocated to your TSO session.                */\n/*            If multiple versions of the member are present in       */\n/*            a concatenation, they are all displayed.                */\n/*            ISPF stats are displayed if present.                    */\n/*                                                                    */\n/* Author   =  Gilbert Saint-Flour <carlos@gsf-soft.com>              */\n/*                                                                    */\n/* Dependencies = TSO/E V2                                            */\n/*                ISPF V3 or V4                                       */\n/*                STEMDISP Sub-routine (optional)                     */\n/*                                                                    */\n/* SYNTAX   =  WHEREIS                                                */\n/*                 member                Member Name                  */\n/*                                                                    */\n/* DEFAULTS =  none                                                   */\n/*                                                                    */\n/* OPERANDS = See Below                                               */\n/*                                                                    */\n/*             member is the name of the member you are looking for.  */\n/*                                                                    */\n/* INVOCATION = WHEREIS can be invoked as a command or as an          */\n/*              EDIT macro.                                           */\n/*                                                                    */\n/**********************************************************************/\nARG Mbr\nIF Mbr='' THEN DO                      /*  IF NO ARGUMENT SPECIFIED,  */\n  ADDRESS ISREDIT                      /*  SWITCH TO \"EDIT MACRO\"     */\n  'MACRO (Mbr)'                        /*  MODE TO LOCATE MEMBER      */\n  IF RC>0 THEN EXIT RC                 /*  BEING EDITED               */\n  IF Mbr='' THEN DO\n    \"(Mbr) = MEMBER\"\n    IF RC>0 | Mbr='' THEN DO\n      SAY 'ENTER MEMBER NAME'\n      PULL Mbr\n      IF Mbr='' THEN EXIT 1            /*  User hit ENTER             */\n    END\n  END\nUPPER Mbr\nEND\nX=OUTTRAP('Hline.')                    /*  TRAP LISTALC OUTPUT        */\nADDRESS TSO \"LISTALC SY ST\"            /*  GET DDN/DSN LIST           */\nX=OUTTRAP('OFF')                       /*  STOP TRAPPING              */\nADDRESS ISPEXEC  ;I=0;J=0;K=1\n\nDO I=2 TO Hline.0\n  IF LEFT(Hline.I,2)='  ' THEN DO\n    X=SUBSTR(Hline.I,3,8)\n    IF LEFT(X,1)=' ' THEN\n      J=J+1\n    ELSE DO;\n      J=0;\n      DDN=STRIP(X)\n      END\n    IF POS('(',Dsn)>0 THEN ITERATE\n    IF LEFT(Dsn,1)='*' THEN ITERATE\n    IF LEFT(Dsn,9)='TERMFILE ' THEN ITERATE\n    IF LEFT(Dsn,9)='NULLFILE ' THEN ITERATE\n    IF RIGHT(Dsn,1)='?' THEN ITERATE\n    IF SYSDSN(\"'\"Dsn\"(\"Mbr\")'\")='OK' THEN\n      CALL GET_STATS\n    END\n  ELSE\n    Dsn=Hline.I\nEND\n\nIF K>1 THEN DO\n  'VGET (ZENVIR)'\n  SIGNAL ON SYNTAX                /* REXXTOOLS NOT PRESENT ON SYSTEM */\n  CALL STEMDISP 'BROWSE','Line.',,,'Where is' Mbr\n  END\nEXIT\n\nGET_STATS:\n  \"LMINIT DATAID(DD1) DATASET('\"Dsn\"') ENQ(SHR)\"\n  IF RC>0 THEN SIGNAL ERROR\n  \"LMOPEN DATAID(\"DD1\")\"\n  IF RC>0 THEN SIGNAL ERROR\n  \"LMMFIND DATAID(\"DD1\") MEMBER(\"Mbr\") STATS(YES)\"\n  RC2=RC\n  \"LMCLOSE DATAID(\"DD1\")\"\n  IF RC>0 THEN SIGNAL ERROR\n  \"LMFREE DATAID(\"DD1\")\"\n  IF RC>0 THEN SIGNAL ERROR\n  IF RC2=0 THEN DO\n    X=ZLVERS'.'ZLMOD  ZLCDATE  ZLMDATE  ZLMTIME,\n      ZLCNORC ZLINORC ZLMNORC ZLUSER\n    IF LEFT(X,1)='Z' THEN X='(NO STATS)'\n    Line.K=LEFT(DDN'+'J,12) Dsn;  L=K+1\n    Line.L='            ' LEFT(Mbr,9) X\n    K=K+2\n    END\nRETURN\n\nSYNTAX:                            /* STEMDISP FUNCTION NOT AVAILABLE */\n  'CONTROL DISPLAY LINE START(1)'\n  DO I=1 TO K-1\n    SAY Line.I; I=I+1; SAY Line.I\n  END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WHOAMI": {"ttr": 24577, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x01\\x00\\x92\\x18?\\x01\\t\\x07\\x9f\\x19V\\x00\\x98\\x00\\x06\\x00!\\xc3\\xc2\\xe3\\xf4\\xf7\\xf8@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1992-07-01T00:00:00", "modifydate": "2009-03-20T19:56:01", "lines": 152, "newlines": 6, "modlines": 33, "user": "CBT478"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* MODULE NAME = WHOAMI                                               */\n/*                                                                    */\n/* DESCRIPTIVE NAME = DISPLAY SYSTEM ID IN LARGE LETTERS              */\n/*                                                                    */\n/* STATUS = R103                                                      */\n/*                                                                    */\n/* FUNCTION = The WHOAMI command displays your user-ID                */\n/*            and the system SMF ID in large letters.                 */\n/*                                                                    */\n/* Author: Gilbert Saint-Flour <carlos@gsf-soft.com>                  */\n/*         http://gsf-soft.com/Freeware/                              */\n/*                                                                    */\n/* DEPENDENCIES = OS/390 or z/OS                                      */\n/*                ISPF V4 or V5                                       */\n/*                                                                    */\n/*102 Retrieve OS name and level from ECVT                            */\n/*103 YY.DDD instead of YYDDD - JDATE                                 */\n/**********************************************************************/\nCALL INIT_BIG_LETTERS               /* INITIALISE BIG LETTERS     */\nCVT    = PTR(16)                    /* CVTPTR                     */\nSMCA   = PTR(CVT+196)               /* CVTSMCA (SMF CTL AREA)     */\nSMCASID = STRING(SMCA+16,4)         /* SMCASID (SMF SYSTEM ID)    */\n\nCALL BIG_LETTERS SMCASID  1\nCALL BIG_LETTERS USERID() 7\n\nJDATE   = LEFT(DATE('J'),2) || '.' || RIGHT(DATE('J'),3)\nLINE.15 = DATE('W') DATE() JDATE TIME()\n\nASCB   = PTR(548)                   /* PSAAOLD  (MY ASCB)         */\nASXB   = PTR(ASCB+108)              /* ASCBASXB (MY ASXB)         */\nACEE   = PTR(ASXB+200)              /* ASXBSENV (MY ACEE)         */\nGROUP  = STRING(ACEE+30,8)          /* ACEEGRPN (RACF GROUP NAME) */\nTERM   = STRING(ACEE+64,8)          /* ACEETRID (TERMINAL NAME)   */\nLINE.16 = 'USERID='SYSVAR('SYSUID'),\n     'PROC='SYSVAR('SYSPROC'),\n     'PREFIX='SYSVAR(SYSPREF),\n     'GROUP='GROUP,\n     'TERMINAL='TERM\n\nSNAME  = STRING(CVT+340,8)          /* CVTSNAME (GRS SYSTEM NAME) */\nECVT   = PTR(CVT+140)               /* CVTECVT                    */\nPRODN  = STRING(ECVT+496,16)        /* ECVTPNAM (OS/390 or z/OS)  */\nPVER   = STRING(ECVT+512,2)         /* ECVTPVER                   */\nPREL   = STRING(ECVT+514,2)         /* ECVTPREL                   */\nPMOD   = STRING(ECVT+516,2)         /* ECVTPMOD                   */\nVRM    = PVER+0 || '.' || PREL+0 || '.' || PMOD+0\n\nIDTE   = C2X(STRING(SMCA+340,4))    /* 0092123F    SMCAIDTE       */\nIDTE   = LEFT(IDTE,7)+1900000       /* 1992123                    */\nITME   = C2D(STRING(SMCA+336,4))    /* 0453624     SMCAITME       */\nHH     = RIGHT(ITME%360000,2,'0')\nMM     = RIGHT((ITME//360000)%6000,2,'0')\nIPLUCB = PTR(CVT+048)               /* CVTSYSAD (UCB FOR IPL VOL) */\nLINE.17 = 'SNAME='SNAME PRODN VRM '-',\n         'IPL='GREGORIAN(IDTE) HH':'MM,\n         'VOL='STRING(IPLUCB+28,6)\nLINE.14 = ' '\nLINE.15 = CENTER(LINE.15,79)\nLINE.16 = CENTER(LINE.16,79)\nLINE.17 = CENTER(LINE.17,79)\nLINE.18 = ' '\n\nIF SYSVAR(SYSISPF)='ACTIVE' THEN DO\n  ADDRESS 'ISPEXEC'\n  'ISREDIT MACRO'\n  'CONTROL ERRORS RETURN'\n  'VGET (ZENVIR ZAPPLID CZXCPXA)'\n  LINE.18 = LEFT(ZENVIR,8) 'APPLID='ZAPPLID\n  IF CZXCPXA\\='' THEN\n    LINE.18 = LINE.18 'CZXCPXA='CZXCPXA\n  LINE.18 = CENTER(LINE.18,79)\n  LINE.19 = ' '\n  SIGNAL ON SYNTAX                  /* in case STEMDISP not available */\n  CALL STEMDISP 'BROWSE', 'LINE.',,,'USERID('USERID()')','ISRBROBA'\n  END\nELSE\n  CALL DISPLAY                      /* ISPF SERVICES NOT AVAILABLE  */\nEXIT\n\nSYNTAX:                            /* STEMDISP FUNCTION NOT AVAILABLE */\n  'ISPEXEC CONTROL DISPLAY LINE START(1)'\n\nDISPLAY:\n  DO I=1 WHILE LINE.I \\= 'LINE.'I\n    SAY LINE.I\n  END\n  EXIT\n\nPTR:  RETURN C2D(BITAND(STORAGE(D2X(ARG(1)),4),'7FFFFFFF'X))\nSTRING: RETURN STRIP(STORAGE(D2X(ARG(1)),ARG(2)))\n\nINIT_BIG_LETTERS:\n  T0='ABCDEFGHIJKLMNOPQRSTUVWXYZ#,$0123456789@%*/-()&+_\u00a2|>:;.?\"=!<\u00ac '\n\nT1=  '  A  BBBB  CCCCDDDD EEEEEFFFFF GGGGH   H III   JJJK  K L    M   M'\nT2=  ' A A B   BC    D   DE    F    G    H   H  I     J K K  L    MM MM'\nT3=  'A   ABBBB C    D   DEEEE FFFF G  GGHHHHH  I     J KK   L    M M M'\nT4=  'AAAAAB   BC    D   DE    F    G   GH   H  I  J  J K K  L    M   M'\nT5=  'A   ABBBB  CCCCDDDD EEEEEF     GGGGH   H III  JJ  K  K LLLLLM   M'\nT1=T1'N   NOOOOOPPPP  QQQ RRRR  SSSSTTTTTU   UV   VW   WX   XY   YZZZZZ'\nT2=T2'NN  NO   OP   PQ   QR   RS      T  U   UV   VW   W X X  Y Y    Z '\nT3=T3'N N NO   OPPPP Q Q QRRRR  SSS   T  U   UV   VW W W  X    Y    Z  '\nT4=T4'N  NNO   OP    Q  Q R  R     S  T  U   U V V WW WW X X   Y   Z   '\nT5=T5'N   NOOOOOP     QQ QR   RSSSS   T   UUU   V  W   WX   X  Y  ZZZZZ'\nT1=T1' # #       $$$$ 000   1  2222 3333 4  4 55555 666 77777 888  999 '\nT2=T2'#####     $ $  0  00 11      2    34  4 5    6       7 8   89   9'\nT3=T3' # #       $$$ 0 0 0  1     2  333 444445555 6666   7   888  9999'\nT4=T4'##### ,,    $ $00  0  1    2      3   4     56   6  7  8   8    9'\nT5=T5' # #   ,  $$$$  000  111 222223333    4 5555  666   7   888  999 '\nT1=T1' @@@ %%  %* * *    /        (  )    &&&   +         *    |   >   '\nT2=T2'@   @   %  ***    /        (    )  &      +        C*C   |    >  '\nT3=T3'@ @@   %  *****  /  -----  (    )   &&  +++++     C *    |     > '\nT4=T4'@     %    ***  /          (    )  &   &  +        C*C   |    >  '\nT5=T5' @@@@%  %%* * */            (  )    &&&&  +  _____  *    |   >   '\nT1=T1' ..   ..        ???  \" \"       ||     <           '\nT2=T2' ..   ..       ?   ?     ===== ||    <            '\nT3=T3'                  ?            ||   <   \u00ac\u00ac\u00ac\u00ac\u00ac     '\nT4=T4' ..   ,,   ..    ?       =====       <      \u00ac     '\nT5=T5' ..    ,   ..    ?             ..     <           '\nRETURN\n\nBIG_LETTERS:\n  ARG STRING L\n  STRING=CENTER(STRING,11)\n  DO I=L TO L+6;LINE.I=' ';END\n  DO I=1 TO LENGTH(STRING)\n    N=1+(INDEX(T0,TRANSLATE(SUBSTR(STRING,I,1)))-1)*5\n    P=L+1\n    LINE.P=LINE.P'  'SUBSTR(T1,N,5);P=P+1\n    LINE.P=LINE.P'  'SUBSTR(T2,N,5);P=P+1\n    LINE.P=LINE.P'  'SUBSTR(T3,N,5);P=P+1\n    LINE.P=LINE.P'  'SUBSTR(T4,N,5);P=P+1\n    LINE.P=LINE.P'  'SUBSTR(T5,N,5);P=P+1\n  END\n  LINE.P=' '\n  RETURN\n/**********************************************************************/\n/*             JULIAN-TO-GREGORIAN CONVERSION ROUTINE                 */\n/*                   GDATE=GREGORIAN(1992134)                         */\n/*                      RETURNS \"YYYY-MM-DD\"                          */\n/**********************************************************************/\nGREGORIAN: PROCEDURE\n  YYYY=LEFT(ARG(1),LENGTH(ARG(1))-3)\n  DDD=RIGHT(ARG(1),3)\n  T=(YYYY//4=0)\n  DD=DDD; IF DD>(59+T) THEN DD=DD+2-T\n  MM=((DD+91)*100)%3055\n  DD=DD+91-(MM*3055)%100\n  RETURN YYYY'-'RIGHT(MM-2,2,'0')'-'RIGHT(DD,2,'0')\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WP": {"ttr": 24581, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x963O\\x00\\x963O\\x14\\x11\\x00&\\x00\\x1f\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-11-29T00:00:00", "modifydate": "1996-11-29T14:11:00", "lines": 38, "newlines": 31, "modlines": 0, "user": "CBT472"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* Module Name: WP                                                    */\n/*                                                                    */\n/* Descriptive Name: Invoke ISPF Workplace                            */\n/*                                                                    */\n/* Status: R100                                                       */\n/*                                                                    */\n/* Function: This REXX program allows you to invoke the               */\n/*           Workplace from the Data Set List panel.                  */\n/*                                                                    */\n/* Author: Gilbert Saint-Flour <carlos@gsf-soft.com>                  */\n/*                                                                    */\n/* Environment: ISPF/PDF V4.2                                         */\n/*                                                                    */\n/* Operation: see below                                               */\n/*                                                                    */\n/*         Enter WP as a line command on the DSLIST panel             */\n/*         to enter the ISPF Workplace and process                    */\n/*         the corresponding data set.                                */\n/*                                                                    */\n/* Change Activity:                                                   */\n/*                                                                    */\n/**********************************************************************/\nADDRESS 'ISPEXEC'\n\"CONTROL ERRORS RETURN\"\n\"ISREDIT MACRO (zwrkdsn)\"             /* invoked from EDIT/VIEW?      */\nIF rc>0 THEN ARG zwrkdsn              /* no, 1st arg must be dsn      */\nIF zwrkdsn='' THEN EXIT 4             /* no dsn, quit                 */\nZwrkvol=''                            /* blank out volume serial      */\nZreftype='D'                          /* Data Set View                */\n\"VGET (ZDLDSN ZDLVOL ZDLCAT)\"         /* get catalog status, volser   */\nIF rc=0 THEN\n  IF zdlcat>0 THEN                    /* uncatalogued data set?       */\n    Zwrkvol=zdlvol                    /* pass actual volume serial    */\n\"VPUT (Zwrkdsn Zwrkvol Zreftype) PROFILE\"  /* update ISRWORK vars     */\n\"SELECT PGM(ISRUDA) PARM(ISRWORK) SCRNAME(WORK)\"\nIF zerrmsg\\='' THEN \"SETMSG MSG(\"zerrmsg\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XDEL": {"ttr": 24583, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x03\\x00\\x00U\\x00\\x91\\x18\\x8f\\x00\\x97\\x16\\x8f\\x150\\x00G\\x00\\x10\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf5\\xf5@@@@'", "ispf": {"version": "03.00", "flags": 0, "createdate": "1991-07-07T00:00:00", "modifydate": "1997-06-17T15:30:55", "lines": 71, "newlines": 16, "modlines": 0, "user": "CBT455"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* MODULE NAME = XDEL                                                 */\n/*                                                                    */\n/* DESCRIPTIVE NAME = REXX EDIT Macro - Delete current member         */\n/*                                                                    */\n/* STATUS = R300                                                      */\n/*                                                                    */\n/* FUNCTION = XDEL can be used as a TSO command or as an EDIT macro   */\n/*            to delete a PDS member using the LMMDEL ISPF service.   */\n/*                                                                    */\n/* SYNTAX = See below                                                 */\n/*                                                                    */\n/*         EDIT Macro: XDEL member-name                               */\n/*            Example: XDEL IEASYS33                                  */\n/*                                                                    */\n/*        When XDEL is invoked as an EDIT macro and no member name    */\n/*        is specified, then the member being EDITed is deleted.      */\n/*                                                                    */\n/*        TSO Command: XDEL data.set.name member-name                 */\n/*            Example: XDEL 'SYS1.PARMLIB' IEASYS33                   */\n/*                                                                    */\n/* Author: Gilbert Saint-Flour <carlos@gsf-soft.com>                  */\n/*             http://gsf-soft.com/Freeware/                          */\n/*                                                                    */\n/**********************************************************************/\nADDRESS 'ISPEXEC'\n\"CONTROL ERRORS RETURN\"\nmacro='NO'\n\"ISREDIT MACRO (PARM)\"\nIF rc=0 THEN DO               /* Invoked as an EDIT macro */\n  zmemb=TRANSLATE(Parm)\n  \"ISREDIT (zdsn) = DATASET\"\n  zdsn=\"'\"zdsn\"'\"\n  IF zmemb = \"\" THEN DO\n    \"ISREDIT (zmemb) = MEMBER\"\n    IF zmemb = \"\" THEN EXIT 20\n    Macro='YES'\n    END\n  END\nELSE                          /* Invoked as a TSO command */\n  ARG zdsn zmemb\n  /*---------------------------------------------------------------*/\n  /*          Scratch the member                                   */\n  /*---------------------------------------------------------------*/\n\"LMINIT DATAID(dataid) DATASET(\"zdsn\") ENQ(SHRW)\"\nIF rc>0 THEN SIGNAL ERROR\n\"LMOPEN DATAID(\"dataid\") OPTION(OUTPUT)\"\nIF rc > 0 THEN SIGNAL ERROR\n\"LMMDEL DATAID(\"dataid\") MEMBER(\"zmemb\")\"\nIF rc = 12 & macro='YES' THEN\n  \"LMMDEL DATAID(\"dataid\") MEMBER(\"zmemb\") NOENQ\" /* ISPF V4 */\nIF rc > 0 THEN SIGNAL ERROR\nZEDSMSG = \"Member\" zmemb \"deleted\"\nZEDLMSG = zmemb \"was deleted in\" zdsn\n\"SETMSG MSG(ISRZ000)\"\n  /*---------------------------------------------------------------*/\n  /*          Clean-up                                             */\n  /*---------------------------------------------------------------*/\n\"LMCLOSE DATAID(\"dataid\")\"\n\"LMFREE DATAID(\"dataid\")\"\nIF macro='YES' THEN\n  \"ISREDIT CANCEL\"\nEXIT\n  /*---------------------------------------------------------------*/\n  /*          Error routine                                        */\n  /*---------------------------------------------------------------*/\nERROR:\n  \"SETMSG MSG(\"ZERRMSG\")\"\n  \"LMCLOSE DATAID(\"dataid\")\"\n  IF macro='NO' THEN \"LMFREE DATAID(\"dataid\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XDELETE": {"ttr": 24586, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x05\\x000\\x00\\x95\\x12\\x1f\\x01\\t\\x14o!\\x16\\x01\\x18\\x00\\xa3\\x003\\xc3\\xc2\\xe3\\xf4\\xf7\\xf8@@@@'", "ispf": {"version": "02.05", "flags": 0, "createdate": "1995-05-01T00:00:00", "modifydate": "2009-05-26T21:16:30", "lines": 280, "newlines": 163, "modlines": 51, "user": "CBT478"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* MODULE NAME = XDELETE                                              */\n/*                                                                    */\n/* DESCRIPTIVE NAME = Delete data sets using generic name             */\n/*                                                                    */\n/* STATUS = R205                                                      */\n/*                                                                    */\n/* FUNCTION = The XDELETE command scans the catalog for data set      */\n/*            names that match a filter (such as USERID.*.C%K*.**)    */\n/*            then issues a DELETE command for each disk data set     */\n/*            or a DELETE NOSCRATCH for each tape data set.           */\n/*                                                                    */\n/* AUTHOR   =  Gilbert Saint-Flour <carlos@gsf-soft.com>              */\n/*             http://gsf-soft.com/Freeware/                          */\n/*                                                                    */\n/* DEPENDENCIES = TSO/E V2                                            */\n/*                DFP 3.2.0                                           */\n/*                Catalog Search Interface                            */\n/*                                                                    */\n/* SYNTAX   =  XDELETE                                                */\n/*                generic_name      generic name specification        */\n/*                EXECUTE           indicates that DELETE commands    */\n/*                                  will actually be issued for       */\n/*                                  selected data sets.               */\n/*                                  DELETE commands are only          */\n/*                                  displayed otherwise.              */\n/*                                                                    */\n/* SPECIFYING THE GENERIC NAME                                        */\n/*                                                                    */\n/* The generic name defines the level qualifiers for the data set     */\n/* names to be included in the list.  Qualifiers can be specified     */\n/* fully, partially or defaulted.  For data sets that are cataloged   */\n/* in CVOL or VSAM catalogs, the high level qualifier must be         */\n/* specified fully.  For ICF catalogs, at least one qualifier must    */\n/* be partially specified.  A Dsname Level of '*' or '**' or any      */\n/* combination of '*' and '**' qualifiers is invalid.                 */\n/*                                                                    */\n/* The following examples are valid for generic_name:                 */\n/*                                                                    */\n/*  DSNAME LEVEL              Data Set List                           */\n/* ------------------------------------------------------------------ */\n/*  SYS1.PARMLIB         One data set name.                           */\n/*                                                                    */\n/*  SYS1.*               All data set names with SYS1 as the first    */\n/*                       qualifier and one more qualifier.            */\n/*                                                                    */\n/*  SYS1 or SYS1.**      All data set names with SYS1 as the first    */\n/*                       qualifier.                                   */\n/*                                                                    */\n/*  **.LIST              All data set names with a qualifier of LIST. */\n/*                                                                    */\n/*  AAA%*.B*%%%B         All data sets that start with AAA, have at   */\n/*                       least one more character in the high level   */\n/*                       qualifier and have a second qualifier that   */\n/*                       begins and ends in B with at least three     */\n/*                       letters between the Bs.                      */\n/*                                                                    */\n/* Data set name qualifiers can be partially specified using asterisks*/\n/* as global file-name characters and percent signs as placeholders:  */\n/*      *  A single asterisk by itself indicates that at least one    */\n/*         qualifier is needed to occupy that position.  A single     */\n/*         asterisk within a qualifier indicates that zero or more    */\n/*         characters can occupy that position.                       */\n/*     **  A double asterisk indicates that zero or more qualifiers   */\n/*         can occupy that position.  A double asterisk within a      */\n/*         qualifier is invalid.                                      */\n/*      %  A single percent sign indicates that any one single        */\n/*         alphameric or national character can occupy that position. */\n/*  %%...  One to eight percent signs can be specified in each        */\n/*         qualifier.                                                 */\n/*                                                                    */\n/* INSTALLATION = XDELETE can be installed in a library concatenated  */\n/*                to SYSEXEC, SYSPROC, or any private library         */\n/*                accessible to the EXEC command.                     */\n/*                                                                    */\n/*                The CSI module (IGGCSI00) must be available at      */\n/*                execution time.  IGGCSI00 is available with         */\n/*                DFSMS/MVS V1R4 or the CSI PRPQ (5799-CSI).          */\n/*                                                                    */\n/*                Recent MVS systems also contain a copy of IGGCSI00  */\n/*                in the following distribution libraries:            */\n/*                                                                    */\n/*                      1. SYS1.AOS28(ARCCSI)                         */\n/*                      2. SYS1.AAPPMOD2(APPCSI00)                    */\n/*                                                                    */\n/* EXECUTION = XDELETE is invoked as a TSO command, either on-line    */\n/*          or in batch, as shown in the following example.           */\n/*                                                                    */\n/*          //XDELETE EXEC PGM=IKJEFT01                               */\n/*          //SYSEXEC  DD DSN=GSFSOFT.FILE183.PDS,DISP=SHR            */\n/*          //SYSTSPRT DD SYSOUT=*                                    */\n/*          //SYSTSIN  DD *                                           */\n/*          %XDELETE  ABC*.D%%FG*.**  EXEC                            */\n            /*                                                        */\n/*                                                                    */\n/* DOCUMENTATION = The documentation for the CSI can be found in      */\n/*                 DFSMS/MVS V1R4 Managing Catalogs (Appendix D)      */\n/*                 and on the Web at:                                 */\n/*                                                                    */\n/* ppdbooks.pok.ibm.com/cgi-bin/bookmgr/bookmgr.cmd/BOOKS/DGT1C104/D.0*/\n/*                                                                    */\n/* CHANGE ACTIVITY                                                    */\n/*                                                                    */\n/*  101   EXIT with maxcc=12 if DELETE fails                          */\n/*  200   Rewrite much of the code to make it more generic            */\n/*  201   Remove erroneous apostrophes in VALUE() function            */\n/*  202   Check devtyp=disk instead of devtyp\\=tape for SCRATCH       */\n/*  203   Check type for VSAM entries                                 */\n/*        Check syntax and issue message if invalid                   */\n/*  204   Display creation date (DSCRDT2) on DELETE commands          */\n/*  205   TRANSLATE(STRIP(execute))                                   */\n/*                                                                    */\n/**********************************************************************/\nARG filter execute                  /*   GET FILTER KEY              */\nIF filter='' THEN DO\n  SAY 'Syntax: XDELETE filter <EXECute>'\n  EXIT 12                           /*   filter is missing           */\n  END\nexecute=TRANSLATE(STRIP(execute))\nIF execute\\='' THEN\n  IF ABBREV('EXECUTE',execute,4) THEN\n    execute='EXECUTE'\n  ELSE DO\n    SAY 'The second operand is invalid'\n    SAY 'Syntax: XDELETE filter EXECute'\n    EXIT 12                         /*   filter is missing           */\n    END\n /*------------------------------------------------------------------*/\n /*                                                                  */\n /*  Initialize the parm list and the work variables                 */\n /*                                                                  */\n /*------------------------------------------------------------------*/\ncsifiltk = STRIP(filter,'BOTH',\"'\") /*  FILTER KEY                  */\ncsicatnm = ''                       /*  CLEAR CATALOG NAME          */\ncsiresnm = ''                       /*  CLEAR RESUME NAME           */\ncsidtyps = 'ACH'                    /*  NVSAM, CLUSTER, GDS         */\ncsicldi  = 'Y'                      /*  RETURN DATA & INDEX         */\ncsicldi  = ' '                      /*  Do not return Data & Index  */\ncsiresum = ' '                      /*  CLEAR RESUME FLAG           */\ncsis1cat = 'Y'                      /*  Search only one catalog     */\ncsis1cat = ' '                      /*  SEARCH ALL CATALOGS         */\n\ncsifldno = 3                        /*  NUMBER OF FIELDS            */\nfldnm.1  = 'DEVTYP'                 /*    field name                */\nfldnm.2  = 'VOLSER'                 /*    field name                */\nfldnm.3  = 'DSCRDT2'                /*    field name                */\n\ncsiopts  = csicldi || csiresum || csis1cat || ' '\ncsifield = LEFT(csifiltk,44) || LEFT(csicatnm,44) || LEFT(csiresnm,44),\n        || LEFT(CSIDTYPS,16) || CSIOPTS  || D2C(csifldno,2)\nDO i=1 to csifldno\n  csifield = csifield || left(fldnm.i,8)\nEND\n\nmodrsnrc = COPIES(' ',4)            /*  CLEAR MODULE/RETURN/REASON  */\nworklen = 256*1024                  /*  Size of work-area in bytes  */\nworka = LEFT(D2C(worklen,4),worklen,'00'X)\nmaxcc=0                             /*  Init highest return-code    */\n\n /********************************************************************/\n /*                                                                  */\n /*  Main CSI Loop Until csiresum=' '                                */\n /*                                                                  */\n /********************************************************************/\nDO FOREVER\n   /*--------------------------------------------------------------*\\\n   |           Issue LINK to the Catalog Search Interface           |\n   \\*--------------------------------------------------------------*/\n  ADDRESS LINKPGM 'IGGCSI00 MODRSNRC CSIFIELD worka'\n  IF RC>0 THEN DO\n    rtn=C2D(SUBSTR(modrsnrc,4,1))      /* Return Code                */\n    rsn=C2D(SUBSTR(modrsnrc,3,1))      /* Reason Code                */\n    IF LEFT(modrsnrc,2)='FFFF'X THEN DO\n      SAY 'IGGCSI00 Error - RC='rtn 'RSN='rsn\n      IF RC>4 THEN                     /* Severe Error, QUIT         */\n        EXIT rc\n      END\n    ELSE DO\n      SAY 'IDC3009I VSAM CATALOG RETURN CODE IS' rtn,\n          '- REASON CODE IS IGG0CLA' || LEFT(modrsnrc,2) '-' rsn\n      END\n    END\n  csiresnm = SUBSTR(CSIFIELD,89,44) /* GET RESUME name FOR NEXT LOOP */\n  csiresum = SUBSTR(CSIFIELD,150,1) /* GET RESUME FLAG FOR NEXT LOOP */\n  usedlen = C2D(SUBSTR(worka,9,4))  /* GET AMOUNT OF WORK AREA USED  */\n  pos1=15                           /* STARTING POSITION             */\n   /*--------------------------------------------------------------*\\\n   |              Process Data Returned in Work Area                |\n   \\*--------------------------------------------------------------*/\n  DO WHILE pos1 < usedlen           /* DO UNTIL ALL DATA IS PROCESSED*/\n\n    flag  = SUBSTR(worka,pos1+0,1)     /* EXTRACT FLAG               */\n    type = SUBSTR(worka,pos1+1,1)      /* EXTRACT ENTRY TYPE         */\n    dsname = SUBSTR(worka,pos1+2,44)   /* EXTRACT ENTRY NAME         */\n    IF type='0' THEN DO                /* CATALOG                    */\n      catname=dsname                   /* Save catalog name          */\n      dlen=50                          /* Length of Catalog entry    */\n      END\n    ELSE DO\n      pos1 = pos1 + 46                 /* skip flag, type, name      */\n      csieretn=''\n      csienter='40'X                   /* Error Indicator            */\n      IF csienter=BITAND(flag,csienter) THEN DO\n        csieretn= SUBSTR(worka,pos1,4) /* error codes: mod,rsn,rtn   */\n        rtn=C2D(SUBSTR(csieretn,4,1))  /* Return Code                */\n        rsn=C2D(SUBSTR(csieretn,3,1))  /* Reason Code                */\n        SAY '**Error Processing catalog entry - Name='STRIP(dsname),\n            'Type='type 'Flag='C2X(flag) 'CAT='STRIP(catname)\n        SAY 'IDC3009I VSAM CATALOG RETURN CODE IS' rtn,\n            '- REASON CODE IS IGG0CLA' || LEFT(csieretn,2) '-' rsn\n        dlen=4                         /* Length of Error Info       */\n        maxcc=12                       /* Remember we had an error   */\n        END\n      ELSE DO\n        dlen = C2D(SUBSTR(worka,pos1,2)) /* length of data           */\n        CALL Process_Catalog_Entry       /* Process current entry    */\n        END\n      END\n    pos1 = pos1 + dlen                   /* next catalog entry       */\n  END    /* DO WHILE pos1 < usedlen */\n  IF csiresum\\='Y' THEN LEAVE\nEND /* RESUME = Y */\nIF cmd='CMD' THEN\n  SAY \"No data sets deleted\"\nEXIT maxcc\n /********************************************************************/\n /*                                                                  */\n /*  Process current catalog entry                                   */\n /*                                                                  */\n /********************************************************************/\nProcess_Catalog_Entry:\n  pos2 = pos1+4                        /* start of length array    */\n  pos3 = pos2+csifldno*2               /* start of data array      */\n   /*--------------------------------------------------------------*\\\n   |              Parse data into named variables                   |\n   \\*--------------------------------------------------------------*/\n  DO i=1 TO csifldno\n    l=C2D(SUBSTR(worka,pos2,2))        /* length of current field  */\n    x=VALUE(fldnm.i,SUBSTR(worka,pos3,l)) /* move value            */\n    pos2=pos2+2                        /* next length              */\n    pos3=pos3+l                        /* next data                */\n    END\n   /*--------------------------------------------------------------*\\\n   |              Generate DELETE/HDELETE commands                  |\n   \\*--------------------------------------------------------------*/\n  IF cmd='CMD' & execute\\='EXECUTE' THEN\n    SAY \"EXECUTE option not specified; Data sets will NOT be deleted.\"\n  dsname = \"'\" || STRIP(dsname) || \"'\"  /* Enclose dsname in quotes  */\n\n        /* Convert DSCRDT2 to YYYY.DDD */\n\n  credt = RIGHT(C2X(dscrdt2),2) || LEFT(C2X(dscrdt2),5)\n  credt = LEFT(1900000+credt,4) || '.' || RIGHT(credt,3)\n    /* SAY dsname type C2X(devtyp) credt /* DATE('U',credt,'J') */*/\n  credt = \"/*\" credt                    /* Display date on DEL cmd   */\n   /*\n  credt = \" \"                           /* Do not display date       */\n   */\n\n  IF volser='MIGRAT' THEN\n    cmd=\"HDELETE\" dsname                /* Migrated data set         */\n  ELSE\n    IF type='A' | type='H' THEN\n      IF SUBSTR(devtyp,3,1) = '20'x THEN  /* DEVICE CLASS = DISK ? */\n        cmd=\"DELETE\" dsname \"SCRATCH\" credt             /* DISK */\n      ELSE\n        cmd=\"DELETE\" dsname \"NOSCRATCH\" credt           /* TAPE */\n    ELSE\n      cmd=\"DELETE\" dsname credt                         /* VSAM */\n   /*--------------------------------------------------------------*\\\n   |               Execute DELETE/HDELETE commands                  |\n   \\*--------------------------------------------------------------*/\n  IF execute='EXECUTE' THEN DO          /* EXECUTE option specified? */\n    cmd                                 /*   YES, issue DELETE cmd   */\n    IF rc>0 THEN maxcc=12               /*  remember we had an error */\n    END\n  ELSE\n    SAY cmd                             /*   NO, display command     */\n  RETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XREN": {"ttr": 24833, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00U\\x00\\x91'_\\x01\\x03\\x19O\\x13\\x13\\x00S\\x00\\x11\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf5\\xf5@@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "1991-10-02T00:00:00", "modifydate": "2003-07-13T13:13:55", "lines": 83, "newlines": 17, "modlines": 0, "user": "CBT455"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* MODULE NAME = XREN                                                 */\n/*                                                                    */\n/* DESCRIPTIVE NAME = Rename Current Member (EDIT Macro)              */\n/*                                                                    */\n/* FUNCTION = This EDIT macro renames the member being edited         */\n/*  to the specified new name.                                        */\n/*                                                                    */\n/*  If a new name is not specified in the command, the member name    */\n/*  at the cursor position is extracted and used as the new name.     */\n/*                                                                    */\n/*  If \"XREN newname END\" or \"XREN newname SAVE\" is specified,        */\n/*  then an END or SAVE command is issued after the successful        */\n/*  completion of the rename operation.                               */\n/*                                                                    */\n/* STATUS = R200                                                      */\n/*                                                                    */\n/* Author: Gilbert Saint-Flour <carlos@gsf-soft.com>                  */\n/*                                                                    */\n/**********************************************************************/\nADDRESS ISPEXEC; \"ISREDIT MACRO (NEWNM ENDSAVE)\"\n\n   /* If the new name is not specified in the command,  */\n   /* extract the member name at the cursor position    */\n\nIF newnm='' THEN DO\n  \"ISREDIT (LINE,CSRP) = CURSOR\"      /*   TO RETRIEVE THE LINE AND   */\n  \"ISREDIT (LINE) = LINE .ZCSR\"       /*   CURSOR POSITION            */\n  IF CSRP>0 THEN DO                   /*   THEN                       */\n    P = POS(' ',LINE,CSRP); IF P>CSRP THEN LINE=LEFT(LINE,P-1)\n    P = POS(',',LINE,CSRP); IF P>CSRP THEN LINE=LEFT(LINE,P-1)\n    P = POS('.',LINE,CSRP); IF P>CSRP THEN LINE=LEFT(LINE,P-1)\n    P = POS(')',LINE,CSRP); IF P>CSRP THEN LINE=LEFT(LINE,P-1)\n    P = POS('(',LINE,CSRP); IF P>CSRP THEN LINE=LEFT(LINE,P-1)\n    LINE = REVERSE(LINE)\n    P = POS(' ',LINE); IF P>1 THEN LINE=LEFT(LINE,P-1)\n    P = POS(',',LINE); IF P>1 THEN LINE=LEFT(LINE,P-1)\n    P = POS('.',LINE); IF P>1 THEN LINE=LEFT(LINE,P-1)\n    P = POS('=',LINE); IF P>1 THEN LINE=LEFT(LINE,P-1)\n    P = POS('(',LINE); IF P>1 THEN LINE=LEFT(LINE,P-1)\n    P = POS(')',LINE); IF P>1 THEN LINE=LEFT(LINE,P-1)\n    newnm = REVERSE(LINE)\n  END\nEND\n\n         /* If a new name is not available, issue error messsage */\n\nIF newnm = \"\" THEN DO\n  ZEDSMSG='New Name Missing'\n  ZEDLMSG='A new member name was not specified in the command'\n  \"SETMSG MSG(ISRZ000)\"\n  EXIT 12\n  END\n\n         /* Rename the member using the LMMREN service */\n\n\"CONTROL ERRORS RETURN\"\n\"ISREDIT (DD1) = DATAID\"\n\"ISREDIT (MBR) = MEMBER\"\n\"LMOPEN DATAID(\"DD1\") OPTION(OUTPUT)\"\nIF RC > 0 THEN SIGNAL ERROR\n\"LMMREN DATAID(\"DD1\") MEMBER(\"MBR\") NEWNAME(\"newnm\")\"\nIF RC = 12 THEN\n  \"LMMREN DATAID(\"DD1\") MEMBER(\"MBR\") NEWNAME(\"newnm\") NOENQ\"\nIF RC > 0 THEN SIGNAL ERROR\nZEDSMSG = \"Member renamed\"\nZEDLMSG = \"Member\" mbr \"renamed to\" TRANSLATE(newnm)\n\"SETMSG MSG(ISRZ000)\"\n\"LMCLOSE DATAID(\"DD1\")\"\n\n         /* Optionally Issue END or SAVE then EXIT */\n\nIF endsave \u00ac= '' THEN\n  \"ISREDIT\" TRANSLATE(endsave)\nEXIT\n\n         /* Error, issue error message */\n\nERROR:\n  \"SETMSG MSG(\"ZERRMSG\")\"\n  \"LMCLOSE DATAID(\"DD1\")\"\n  EXIT 20\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XRENAME": {"ttr": 24836, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00Y\\x00\\x95\\x12\\x1f\\x01\\t\\x14o!\\x12\\x01\\x18\\x00\\xa3\\x00\\x03\\xc3\\xc2\\xe3\\xf4\\xf7\\xf8@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1995-05-01T00:00:00", "modifydate": "2009-05-26T21:12:59", "lines": 280, "newlines": 163, "modlines": 3, "user": "CBT478"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* MODULE NAME = XRENAME                                              */\n/*                                                                    */\n/* DESCRIPTIVE NAME = Rename data sets using generic name             */\n/*                                                                    */\n/* STATUS = R101                                                      */\n/*                                                                    */\n/* FUNCTION = The XRENAME command scans the catalog for data set      */\n/*            names that match a filter (such as USERID.*.C%K*.**)    */\n/*            then issues an ALTER command for each data set.         */\n/*            Tape data sets and migrated data sets can't be ALTER'd  */\n/*            and are ignored.                                        */\n/*                                                                    */\n/* AUTHOR   =  Gilbert Saint-Flour <carlos@gsf-soft.com>              */\n/*             http://gsf-soft.com/Freeware/                          */\n/*                                                                    */\n/* DEPENDENCIES = TSO/E V2                                            */\n/*                DFP 3.2.0                                           */\n/*                Catalog Search Interface                            */\n/*                                                                    */\n/* SYNTAX   =  XRENAME                                                */\n/*                generic_name      generic name specification        */\n/*                old-string        old string                        */\n/*                new-string        replacement string                */\n/*                EXECUTE           indicates that ALTER commands     */\n/*                                  will actually be issued for       */\n/*                                  selected data sets.               */\n/*                                  ALTER commands are only           */\n/*                                  displayed otherwise.              */\n/*                                                                    */\n/* SPECIFYING THE GENERIC NAME                                        */\n/*                                                                    */\n/* The generic name defines the level qualifiers for the data set     */\n/* names to be included in the list.  Qualifiers can be specified     */\n/* fully, partially or defaulted.  For data sets that are cataloged   */\n/* in CVOL or VSAM catalogs, the high level qualifier must be         */\n/* specified fully.  For ICF catalogs, at least one qualifier must    */\n/* be partially specified.  A Dsname Level of '*' or '**' or any      */\n/* combination of '*' and '**' qualifiers is invalid.                 */\n/*                                                                    */\n/* The following examples are valid for generic_name:                 */\n/*                                                                    */\n/*  DSNAME LEVEL              Data Set List                           */\n/* ------------------------------------------------------------------ */\n/*  SYS1.PARMLIB         One data set name.                           */\n/*                                                                    */\n/*  SYS1.*               All data set names with SYS1 as the first    */\n/*                       qualifier and one more qualifier.            */\n/*                                                                    */\n/*  SYS1 or SYS1.**      All data set names with SYS1 as the first    */\n/*                       qualifier.                                   */\n/*                                                                    */\n/*  **.LIST              All data set names with a qualifier of LIST. */\n/*                                                                    */\n/*  AAA%*.B*%%%B         All data sets that start with AAA, have at   */\n/*                       least one more character in the high level   */\n/*                       qualifier and have a second qualifier that   */\n/*                       begins and ends in B with at least three     */\n/*                       letters between the Bs.                      */\n/*                                                                    */\n/* Data set name qualifiers can be partially specified using asterisks*/\n/* as global file-name characters and percent signs as placeholders:  */\n/*      *  A single asterisk by itself indicates that at least one    */\n/*         qualifier is needed to occupy that position.  A single     */\n/*         asterisk within a qualifier indicates that zero or more    */\n/*         characters can occupy that position.                       */\n/*     **  A double asterisk indicates that zero or more qualifiers   */\n/*         can occupy that position.  A double asterisk within a      */\n/*         qualifier is invalid.                                      */\n/*      %  A single percent sign indicates that any one single        */\n/*         alphameric or national character can occupy that position. */\n/*  %%...  One to eight percent signs can be specified in each        */\n/*         qualifier.                                                 */\n/*                                                                    */\n/* INSTALLATION = XRENAME can be installed in a library concatenated  */\n/*                to SYSEXEC, SYSPROC, or any private library         */\n/*                accessible to the EXEC command.                     */\n/*                                                                    */\n/*                The CSI module (IGGCSI00) must be available at      */\n/*                execution time.  IGGCSI00 is available with         */\n/*                DFSMS/MVS V1R4 or the CSI PRPQ (5799-CSI).          */\n/*                                                                    */\n/*                Recent MVS systems also contain a copy of IGGCSI00  */\n/*                in the following distribution libraries:            */\n/*                                                                    */\n/*                      1. SYS1.AOS28(ARCCSI)                         */\n/*                      2. SYS1.AAPPMOD2(APPCSI00)                    */\n/*                                                                    */\n/* EXECUTION = XRENAME is invoked as a TSO command, either on-line    */\n/*          or in batch, as shown in the following example.           */\n/*                                                                    */\n/*          //XRENAME EXEC PGM=IKJEFT01                               */\n/*          //SYSEXEC  DD DSN=GSFSOFT.FILE183.PDS,DISP=SHR            */\n/*          //SYSTSPRT DD SYSOUT=*                                    */\n/*          //SYSTSIN  DD *                                           */\n/*          %XRENAME  ABC*.D%%FG*.**  D23FG44.A  K56A.CC  EXEC        */\n            /*                                                        */\n/*                                                                    */\n/* DOCUMENTATION = The documentation for the CSI can be found in      */\n/*                 DFSMS/MVS V1R4 Managing Catalogs (Appendix D)      */\n/*                 and on the Web at:                                 */\n/*                                                                    */\n/* ppdbooks.pok.ibm.com/cgi-bin/bookmgr/bookmgr.cmd/BOOKS/DGT1C104/D.0*/\n/*                                                                    */\n/* CHANGE ACTIVITY                                                    */\n/*                                                                    */\n/*  100   New exec, built from XDELETE R203                           */\n/*  101   TRANSLATE(STRIP(execute))                                   */\n/*                                                                    */\n/**********************************************************************/\nARG filter oldstr newstr execute    /*   GET FILTER KEY              */\nIF newstr='' THEN DO\n  SAY 'Syntax: XRENAME filter old-string new-string <EXECute>'\n  EXIT 12                           /*   newstr is missing           */\n  END\nexecute=TRANSLATE(STRIP(execute))\nIF execute\\='' THEN\n  IF ABBREV('EXECUTE',execute,4) THEN\n    execute='EXECUTE'\n  ELSE\n    SAY 'The fourth operand is invalid and will be ignored'\n /*------------------------------------------------------------------*/\n /*                                                                  */\n /*  Initialize the parm list and the work variables                 */\n /*                                                                  */\n /*------------------------------------------------------------------*/\ncsifiltk = STRIP(filter,'BOTH',\"'\") /*  FILTER KEY                  */\ncsicatnm = ''                       /*  CLEAR CATALOG NAME          */\ncsiresnm = ''                       /*  CLEAR RESUME NAME           */\ncsidtyps = 'ACH'                    /*  NVSAM, CLUSTER, GDS         */\ncsicldi  = 'Y'                      /*  RETURN DATA & INDEX         */\ncsicldi  = ' '                      /*  Do not return Data & Index  */\ncsiresum = ' '                      /*  CLEAR RESUME FLAG           */\ncsis1cat = 'Y'                      /*  Search only one catalog     */\ncsis1cat = ' '                      /*  SEARCH ALL CATALOGS         */\n\ncsifldno = 2                        /*  NUMBER OF FIELDS            */\nfldnm.1  = 'DEVTYP'                 /*    field name                */\nfldnm.2  = 'VOLSER'                 /*    field name                */\n\ncsiopts  = csicldi || csiresum || csis1cat || ' '\ncsifield = LEFT(csifiltk,44) || LEFT(csicatnm,44) || LEFT(csiresnm,44),\n        || LEFT(CSIDTYPS,16) || CSIOPTS  || D2C(csifldno,2)\nDO i=1 to csifldno\n  csifield = csifield || left(fldnm.i,8)\nEND\n\nmodrsnrc = COPIES(' ',4)            /*  CLEAR MODULE/RETURN/REASON  */\nworklen = 256*1024                  /*  Size of work-area in bytes  */\nworka = LEFT(D2C(worklen,4),worklen,'00'X)\nmaxcc=0                             /*  Init highest return-code    */\n\n /********************************************************************/\n /*                                                                  */\n /*  Main CSI Loop Until csiresum=' '                                */\n /*                                                                  */\n /********************************************************************/\nDO FOREVER\n   /*--------------------------------------------------------------*\\\n   |           Issue LINK to the Catalog Search Interface           |\n   \\*--------------------------------------------------------------*/\n  ADDRESS LINKPGM 'IGGCSI00 MODRSNRC CSIFIELD worka'\n  IF RC>0 THEN DO\n    rtn=C2D(SUBSTR(modrsnrc,4,1))      /* Return Code                */\n    rsn=C2D(SUBSTR(modrsnrc,3,1))      /* Reason Code                */\n    IF LEFT(modrsnrc,2)='FFFF'X THEN DO\n      SAY 'IGGCSI00 Error - RC='rtn 'RSN='rsn\n      IF RC>4 THEN                     /* Severe Error, QUIT         */\n        EXIT rc\n      END\n    ELSE DO\n      SAY 'IDC3009I VSAM CATALOG RETURN CODE IS' rtn,\n          '- REASON CODE IS IGG0CLA' || LEFT(modrsnrc,2) '-' rsn\n      END\n    END\n  csiresnm = SUBSTR(CSIFIELD,89,44) /* GET RESUME name FOR NEXT LOOP */\n  csiresum = SUBSTR(CSIFIELD,150,1) /* GET RESUME FLAG FOR NEXT LOOP */\n  usedlen = C2D(SUBSTR(worka,9,4))  /* GET AMOUNT OF WORK AREA USED  */\n  pos1=15                           /* STARTING POSITION             */\n   /*--------------------------------------------------------------*\\\n   |              Process Data Returned in Work Area                |\n   \\*--------------------------------------------------------------*/\n  DO WHILE pos1 < usedlen           /* DO UNTIL ALL DATA IS PROCESSED*/\n\n    flag  = SUBSTR(worka,pos1+0,1)     /* EXTRACT FLAG               */\n    type = SUBSTR(worka,pos1+1,1)      /* EXTRACT ENTRY TYPE         */\n    dsname = SUBSTR(worka,pos1+2,44)   /* EXTRACT ENTRY NAME         */\n    IF type='0' THEN DO                /* CATALOG                    */\n      catname=dsname                   /* Save catalog name          */\n      dlen=50                          /* Length of Catalog entry    */\n      END\n    ELSE DO\n      pos1 = pos1 + 46                 /* skip flag, type, name      */\n      csieretn=''\n      csienter='40'X                   /* Error Indicator            */\n      IF csienter=BITAND(flag,csienter) THEN DO\n        csieretn= SUBSTR(worka,pos1,4) /* error codes: mod,rsn,rtn   */\n        rtn=C2D(SUBSTR(csieretn,4,1))  /* Return Code                */\n        rsn=C2D(SUBSTR(csieretn,3,1))  /* Reason Code                */\n        SAY '**Error Processing catalog entry - Name='STRIP(dsname),\n            'Type='type 'Flag='C2X(flag) 'CAT='STRIP(catname)\n        SAY 'IDC3009I VSAM CATALOG RETURN CODE IS' rtn,\n            '- REASON CODE IS IGG0CLA' || LEFT(csieretn,2) '-' rsn\n        dlen=4                         /* Length of Error Info       */\n        maxcc=12                       /* Remember we had an error   */\n        END\n      ELSE DO\n        dlen = C2D(SUBSTR(worka,pos1,2)) /* length of data           */\n        CALL Process_Catalog_Entry       /* Process current entry    */\n        END\n      END\n    pos1 = pos1 + dlen                   /* next catalog entry       */\n  END    /* DO WHILE pos1 < usedlen */\n  IF csiresum\\='Y' THEN LEAVE\nEND /* RESUME = Y */\nIF cmd='CMD' THEN\n  SAY \"No data sets renamed\"\nEXIT maxcc\n /********************************************************************/\n /*                                                                  */\n /*  Process current catalog entry                                   */\n /*                                                                  */\n /********************************************************************/\nProcess_Catalog_Entry:\n  pos2 = pos1+4                        /* start of length array    */\n  pos3 = pos2+csifldno*2               /* start of data array      */\n   /*--------------------------------------------------------------*\\\n   |              Parse data into named variables                   |\n   \\*--------------------------------------------------------------*/\n  DO i=1 TO csifldno\n    l    = C2D(SUBSTR(worka,pos2,2))   /* length of current field  */\n    x=VALUE(fldnm.i,SUBSTR(worka,pos3,l)) /* move value            */\n    pos2=pos2+2                        /* next length              */\n    pos3=pos3+l                        /* next data                */\n    END\n   /*--------------------------------------------------------------*\\\n   |              Generate ALTER commands                           |\n   \\*--------------------------------------------------------------*/\n  IF cmd='CMD' & execute\\='EXECUTE' THEN\n    SAY \"EXECUTE option not specified; Data sets will NOT be renamed.\"\n  dsname = \"'\" || STRIP(dsname) || \"'\"  /* Enclose dsname in quotes  */\n  cmd='';head=''\n\n  SELECT\n    WHEN volser='MIGRAT' THEN DO        /* Migrated data set         */\n      SAY dsname 'is migrated'\n      RETURN\n      END\n    WHEN (type='A' | type='H') & SUBSTR(devtyp,3,1) /= '20'x THEN DO\n      SAY dsname 'is on tape'\n      RETURN\n      END\n    OTHERWISE DO\n      i = INDEX(dsname,oldstr)\n      SELECT\n        WHEN i=0 THEN DO\n          SAY dsname 'does not contain' oldstr\n          RETURN\n          END\n        OTHERWISE DO\n          head = LEFT(dsname,i-1)\n          tail = RIGHT(dsname,LENGTH(dsname)-i-LENGTH(oldstr)+1)\n          newnm = head || newstr || tail\n     /* SAY dsname 'head='head 'tail='tail 'newnm='newnm */\n          cmd=\"ALTER \" || dsname || \" NEWNM(\" || newnm || \")\"\n          END\n        END\n      END\n    END\n   /*--------------------------------------------------------------*\\\n   |               Execute ALTER commands                           |\n   \\*--------------------------------------------------------------*/\n  IF execute='EXECUTE' THEN DO          /* EXECUTE option specified? */\n    cmd                                 /*   YES, issue ALTER cmd    */\n    IF rc>0 THEN maxcc=12               /*  remember we had an error */\n    END\n  ELSE\n    SAY cmd                             /*   NO, display command     */\n  RETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZAPONTR0": {"ttr": 24841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x884?\\x00\\x94\"\\x0f\\x13\\x02\\x00\\xb0\\x00B\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf0\\xf0@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-12-08T00:00:00", "modifydate": "1994-08-08T13:02:00", "lines": 176, "newlines": 66, "modlines": 0, "user": "CBT400"}, "text": "//GILBERTO JOB (ACCT#),ILBONTR,\n// NOTIFY=&SYSUID,\n//*RESTART=COB,\n// CLASS=A,MSGCLASS=H,COND=(4,LT)\n//*\n//*      THIS JOB PRODUCES A CUSTOMIZED VERSION OF THE ILBONTR\n//*      MODULE THAT BYPASSES THE STEPLIB/JOBLIB FOR ALL ILBOXXX\n//*      SUBROUTINES.\n//*\n//COPY    EXEC PGM=IEBCOPY\n//SYSPRINT DD SYSOUT=*\n//VSCLLIB  DD DSN=SYS1.R2M4.VSCLLIB,DISP=SHR\n//TEMPLMOD DD UNIT=VIO,DISP=(,PASS),SPACE=(1,(1,,1))\n//SYSIN    DD *\n COPYMOD I=VSCLLIB,O=TEMPLMOD\n SELECT  MEMBER=ILBONTR\n//*\n//ZAP     EXEC PGM=AMASPZAP\n//SYSLIB   DD DSN=*.COPY.TEMPLMOD,DISP=(OLD,PASS)\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *                 101988 UPDATE\n NAME ILBONTR ILBONTR\n VER  0052 C9D3C2D6,C3D4D4F0           DC    C'ILBOCMM0'\n VER  006C C9D3C2D6,E2D94040           DC    C'ILBOSR  '\n VER  0208 4100B20E,47F0B216           LA    R0,*+8\n VER  09E8 50E0,D0C8,1803,1B11         ST    R14,200(,R13)\n VER  0A7C C9D3C2D6                    DC    C'ILBO'\n VER  0C30 0000,0000,0000,0000         PATCH AREA\n*\n REP  004A 5880,0010                   L     R8,CVTPTR\n REP  004E 5880,8008                   L     R8,CVTLINK-CVT(,R8)\n REP  0052 4100,B06C                   LA    R0,=C'ILBOCMM0'\n REP  0056 1818                        LR    R1,R8\n REP  0058 0A08                        SVC   8\n REP  005A 5000,20AC                   ST    R0,172(,R2)\n REP  005E 4100,B074                   LA    R0,=C'ILBOSR  '\n REP  0062 1818                        LR    R1,R8\n REP  0064 0A08                        SVC   8\n REP  0066 5000,2038                   ST    R0,56(,R2)\n REP  006A 47F0,B07C                   B     *+20\n REP  006E C9D3C2D6,C3D4D4F0           DC    C'ILBOCMM0'\n REP  0076 C9D3C2D6,E2D94040           DC    C'ILBOSR  '\n*\n REP  0208 4100,B222                   LA    R0,A000224    =C'ILBOPRM0'\n REP  020C 5810,0010                   L     R1,CVTPTR\n REP  0210 5810,1008                   L     R0,CVTLINK-CVT(,R1)\n REP  0214 0707,0707,0707              NOPR  7\n*\n REP  09EC 45E0,BC2E                   BAL   R14,A000C30\n*\n REP  0C30 1803                        LR    R0,R3\n REP  0C32 1B11                        SR    R1,R1\n REP  0C34 D503,BA7A,3000              CLC   A000A7C,0(R3)   =C'ILBO'\n REP  0C3A 077E                        BNER  R14\n REP  0C3C 5810,0010                   L     R1,CVTPTR\n REP  0C40 5810,1008                   L     R1,CVTLINK-CVT(,R1)\n REP  0C44 07FE                        BR    R14\n/*\n//OLDZAP   DD *\n NAME ILBONTR ILBONTR\n VER  0052 C9D3C2D6,C3D4D4F0           DC    C'ILBOCMM0'\n VER  006C C9D3C2D6,E2D94040           DC    C'ILBOSR  '\n VER  01FE 4100,B204                   LA    R0,*+8\n VER  0210 0A08                        SVC   8\n VER  09DC 50E0,D0C8,1803,1B11         ST    R14,200(,R13)\n VER  0C00 0000,0000,0000,0000         PATCH AREA\n*\n REP  004A 5880,0010                   L     R8,CVTPTR\n REP  004E 5880,8008                   L     R8,CVTLINK-CVT(,R8)\n REP  0052 4100,B06C                   LA    R0,=C'ILBOCMM0'\n REP  0056 1818                        LR    R1,R8\n REP  0058 0A08                        SVC   8\n REP  005A 5000,20AC                   ST    R0,172(,R2)\n REP  005E 4100,B074                   LA    R0,=C'ILBOSR  '\n REP  0062 1818                        LR    R1,R8\n REP  0064 0A08                        SVC   8\n REP  0066 5000,2038                   ST    R0,56(,R2)\n REP  006A 47F0,B07C                   B     *+20\n REP  006E C9D3C2D6,C3D4D4F0           DC    C'ILBOCMM0'\n REP  0076 C9D3C2D6,E2D94040           DC    C'ILBOSR  '\n*\n REP  01FE 4100,B218                   LA    R0,*+8\n REP  0202 0700,0700                   NOPR\n REP  0206 5810,0010                   L     R1,CVTPTR\n REP  020A 5810,1008                   L     R0,CVTLINK-CVT(,R1)\n REP  020E 0700                        NOPR\n*\n REP  09DC 4100,3000                   LA    R0,0(,R3)\n REP  09E0 5810,0010                   L     R1,CVTPTR\n REP  09E4 5810,1008                   L     R1,CVTLINK-CVT(,R1)\n REP  09E8 47F0,BBFE                   B     A000C00\n REP  0C00 D503,BA6E,3000              CLC   =C'ILBO',0(R3)\n REP  0C06 4780,BC0A                   BE    A000C0A\n REP  0C0A 1B11                        SR    R1,R1\n REP  0C0C 0A08                        SVC   8\n REP  0C0E 07FE                        BR    R14\n/*\n//DISASM  EXEC PGM=DISASM0,REGION=1000K\n//STEPLIB  DD DSN=GILBERT.LOAD,DISP=SHR\n//SYSLIB   DD DSN=*.COPY.TEMPLMOD,DISP=(OLD,PASS)\n//SYSPRINT DD SYSOUT=*\n//SYSPUNCH DD DUMMY\nILBONTR  ILBONTR\nUSING 000006 000016 F P 000002\nUSING 000018 000B94 B P 000002\nUSING 000B14 000B80 F P 000B14           ESTAE EXIT 1\nUSING 000B94 000BE6 B P 000B94           ESTAE EXIT 2\nUSING 000BEE 000C48 B P 000002           PATCH AREA\nDATA 000C4A 000C83                       MODULE STATUS\n/*\nWORKA    DSECT 0001\nWORKA6   0000 0033\nUSING 000128 000E00 D D WORKA\nDATA 000BBA 000FFF\n/*\nUSING FROM-- TO---- R P CONT..\nUSING FROM-- TO---- R D DSECTNME\nULABL LABELNME OFFSET LLL\nDSECTNME DSECT NNN\nFIELDNME OOOO LLL\nDATA SSSSSS EEEEEE\n//*\n//COB  EXEC PGM=IKFCBL00,REGION=1000K,\n// PARM='OBJECT,NODECK,RES,QUOTE,NOLIB,NOXREF,BATCH,NAME'\n//STEPLIB DD DSN=SYS1.R2M4.VSCOLIB,DISP=SHR\n000300 ID DIVISION.\n000500  PROGRAM-ID.  TESTNTR.\n001400 ENVIRONMENT DIVISION.\n001700  INPUT-OUTPUT SECTION.\n002100 DATA DIVISION.\n002200  LINKAGE SECTION.\n002300   01 JCL-PARM.\n002400     02 PARM-LENGTH PIC S999 COMP.\n002500     02 PARM-TEXT.\n002600       04 FILLER PIC X OCCURS 100 DEPENDING ON PARM-LENGTH.\n004100 PROCEDURE DIVISION USING JCL-PARM.\n004200     DISPLAY \"LOOKS OK  \"  PARM-TEXT.\n004300     STOP RUN.\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,5)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,5)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,5)\n//SYSUT4   DD UNIT=VIO,SPACE=(CYL,5)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//LKEDCOB EXEC PGM=HEWL\n//SYSLIN   DD DSN=*.COB.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD UNIT=VIO,DISP=(,PASS),SPACE=(TRK,(1,,1))\n//SYSPRINT DD SYSOUT=*\n//*\n//GO1     EXEC PGM=TESTNTR,PARM='WITHOUT ZAP'\n//STEPLIB  DD DSN=*.LKEDCOB.SYSLMOD,DISP=(OLD,PASS)\n//         DD UNIT=VIO,SPACE=(TRK,(1,,1))\n//         DD UNIT=VIO,SPACE=(TRK,(1,,1))\n//         DD UNIT=VIO,SPACE=(TRK,(1,,1))\n//SYSOUT   DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//*\n//GO2     EXEC PGM=TESTNTR,PARM='WITH ZAP'\n//STEPLIB  DD DSN=*.COPY.TEMPLMOD,DISP=(OLD,PASS)\n//         DD DSN=*.LKEDCOB.SYSLMOD,DISP=(OLD,PASS)\n//         DD UNIT=VIO,SPACE=(TRK,(1,,1))\n//         DD UNIT=VIO,SPACE=(TRK,(1,,1))\n//SYSOUT   DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//*\n//RELINK   EXEC PGM=HEWL,PARM=(LIST,MAP,RENT)\n//SYSPRINT DD SYSOUT=*\n//TEMPLMOD DD DSN=*.COPY.TEMPLMOD,DISP=(OLD,PASS)\n//*YSLMOD  DD UNIT=VIO,SPACE=(TRK,(8,,2))\n//SYSLMOD  DD DSN=GILBERT.LOAD,DISP=SHR\n//SYSLIN   DD *\n INCLUDE TEMPLMOD(ILBONTR)      ZAPPED LOAD MODULE\n LIBRARY (ILBOCMM0)             DO NOT RESOLVE\n ALIAS   ILBONTR0\n NAME    ILBONTR(R)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZAPXMIT": {"ttr": 24845, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x04\\x00\\x93\\x14O\\x01\\x10\\x06\\x7f\\x121\\x00\\x16\\x00\\x1a\\x00\\x08\\xc3\\xc2\\xe3\\xf4\\xf8\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1993-05-24T00:00:00", "modifydate": "2010-03-08T12:31:04", "lines": 22, "newlines": 26, "modlines": 8, "user": "CBT483"}, "text": "//GILBERTZ JOB (ACCT#),ZAP.XMIT,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//*--------------------------------------------------------------------*\n//*       REMOVE BLKSIZE=3120 IN TRANSMIT OUTDS() COMMAND              *\n//*                 REFRESH LLA TO ACTIVATE                            *\n//*--------------------------------------------------------------------*\n//ZAPXMIT EXEC PGM=AMASPZAP\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.LINKLIB,DISP=SHR\n NAME INMXM\n  VER 1A64 00000C30                                Z/OS R11\n  REP 1A64 00000000\n/*        REFRESH LLA TO ACTIVATE\n NAME INMXM\n  VER 19FC 00000C30                                HTE7708\n  REP 19FC 00000000\n/*        REFRESH LLA TO ACTIVATE\n NAME INMXM\n  VER 19B4 00000C30                                HTE26D2\n  REP 19B4 00000000\n/*        REFRESH LLA TO ACTIVATE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT183/FILE183.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT183", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}