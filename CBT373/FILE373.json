{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011852000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 470288, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE373.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE373.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x08\\r'", "DS1TRBAL": "b'\\x1a\\xf6'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\xb1\\x00\\x0b\\x02\\xb2\\x00\\x04\\x00\\t'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$DOCNEWS": {"ttr": 516, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n\n 1.  Contact person for this command processor is:\n\n                Chuck Hoffman\n                Systems Programming\n                GTE Laboratories - Computer Center\n                40 Sylvan Road\n                Waltham, Massachusetts  02254\n\n                            Phone: (617)466-2131.\n\n 2.  Source for command processor NEWSPACE is in member NEW.\n     General documentation concerning NEWSPACE is in the help\n     document in member HELP.\n\n 3.  NEWSPACE should be assembled with the RENT option.\n\n 4.  NEWSPACE should be link-edited with RENT, REUS, and ALIAS NEW.\n\n 5.  The program uses GTE Laboratories macros for standard linkage\n     conventions and register equates.  They are:\n\n            LINKSAVE\n            LINKBACK\n            EQ$R\n\n 6.  The program uses GTE Laboratories macros for dynamic\n     allocation.  Documentation is in macro GTEDADOC.  All\n     features used by NEWSPACE have been tested and found okay.\n     However, GTE Laboratories has not completed testing other\n     features which are not used by NEWSPACE. Not all features\n     have been included yet, and not all of those which have been\n     included have been tested.  If you use these macros for\n     other applications, please let GTE Laboratories know of any\n     bugs...  especially the ones you have corrected!\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$DOCSAL": {"ttr": 518, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n   The \"SAL\" program is a friendlier replacement for the TSO\n   \"LISTALC\" command.  \"SAL\" stands for \"Show ALlocations.\"\n\n   SAL shows DDNAME, DATASET NAME, STATUS, NORMAL DISPOSITION and\n   DATASET TYPE for each allocation.  It was designed to produce\n   more readable output than \"LISTALC.\"  It's primary use is in\n   developing CLISTs and ISPF/PDF dialogs.\n\n   SAL uses dynamic allocation information retrieval to get\n   information about all current allocations.  See the MVS Job\n   Management manual for more info on this use of dynamic\n   allocation.\n\n   SAL writes to file SYSPRINT, which would normally be allocated to\n   the user's TSO terminal.  It works with Session Manager or\n   without it, and is written to be reentrant.\n\n   This package includes well-commented assembler code (member\n   \"SAL\"), macros (\"XSAVE1,\" \"XRETURN,\" \"REGISTER,\" \"DYNABLD,\" and\n   \"DYNATXTU\"), and a TSO HELP member (\"SALHELP\").\n\n\n   Ric Ford\n   GTE Laboratories, Incorporated\n   40 Sylvan Road\n   Waltham, Massachusetts 02254\n   (617) 466-2133\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CBTSAL": {"ttr": 520, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         PRINT GEN\n  TITLE 'SHOW TSO ALLOCATIONS USING DYNAMIC ALLOCATION    '\n*=====================================================================\n*\n* FUNCTION:\n*            \"SAL\" IS A PROGRAM TO REPLACE THE \"LISTALC\" TSO\n*            COMMAND FOR MOST USES.  ITS PURPOSE IS TO TELL THE\n*            TSO USER WHAT DATASETS AND DDNAMES ARE CURRENTLY\n*            ALLOCATED, HOW THEY ARE ALLOCATED, AND TO TELL HIM\n*            THIS IN A READABLE FORMAT.\n*\n*            SAL WRITES A REPORT WITH THE FOLLOWING INFORMATION\n*            FOR EACH ALLOCATION:\n*\n*               DDNAME\n*               DATASET NAME\n*               STATUS\n*               NORMAL DISPOSITION\n*               DATASET TYPE\n*\n*            THIS PROGRAM WORKS BY USING DYNAMIC ALLOCATION INFORMATION\n*            RETRIEVAL. IT RETRIEVES INFORMATION ABOUT EACH RELATIVE\n*            REQUEST (REQUEST 1, REQUEST 2, ...) UNTIL THE LAST\n*            RELATIVE REQUEST HAS BEEN PROCESSED.\n*            (SEE THE \"OS/VS MVS SYSTEM PROGRAMMING LIBRARY:\n*            JOB MANAGEMENT\" MANUAL FOR DETAILS ON HOW DYNAMIC\n*            ALLOCATION CAN BE USED TO RETRIEVE ALLOCATION INFORMATION)\n*\n*            THIS CODE HAS BEEN WRITTEN TO BE REENTRANT, SO THAT\n*            THE PROGRAM MAY BE PLACED IN \"LPALIB\" FOR BETTER\n*            PERFORMANCE.\n*\n         EJECT\n*\n* INPUT:\n*            NONE\n*\n*\n* OUTPUT:\n*            TO FILE SYSPRINT: HEADING LINE, AND A LINE FOR EACH\n*            RELATIVE REQUEST, SHOWING WHAT'S ALLOCATED.\n*            2 BLANK LINES ARE PRINTED BEFORE THE HEADING, AND A BLANK\n*            LINE IS PRINTED AT THE END OF THE REPORT.\n*\n*            THE SYSPRINT FILE IS DEFINED WITH THE FOLLOWING\n*            ATTRIBUTES:\n*              RECFM=FBA, DSORG=PS\n*\n*\n* ERROR ROUTINES:\n*\n*            IF THE SYSPRINT FILE COULDN'T BE OPENED, THE PROGRAM\n*            ABENDS WITH A USER 013 CODE.\n*\n*            IF SYSPRINT IS ALLOCATED TO A DATASET WITH THE WRONG\n*            ATTRIBUTES, THE USER WILL GET A SYSTEM X13 ABEND CODE.\n*\n*            IF GETMAIN CAN'T GET ENOUGH STORAGE, IT ABENDS.\n*\n*            IF SVC 99 RETURNED A NON-ZERO RETURN CODE, THE PROGRAM\n*            ENDS, PASSING ALONG THAT RETURN CODE.\n*\n         EJECT\n*\n* REGISTERS:\n*            R4 - POINTS TO REQUEST BLOCK POINTER\n*            R5 - POINTS TO REQUEST BLOCK START\n*            R6 - POINTS TO A TEXT UNIT ADDRESS\n*            R7 - POINTS TO A TEXT UNIT\n*            R8 - POINTS TO DCB\n*            R9 - USED TO BUILD OPEN AND CLOSE PARM LISTS\n*           R10 - HOLDS RELATIVE REQUEST NUMBER\n*\n*           R13 - BASE REG. FOR THIS PROGRAM (FROM XSAVE1 MACRO)\n*\n*           R15 - HOLDS RETURN CODE FROM SVC 99.  I WON'T CHANGE IT,\n*                 SO THIS RETURN CODE WILL BE PASSED WHEN I END.\n*\n*\n* LINKAGE:\n*\n*         MVS STANDARD LINKAGE CONVENTIONS ARE USED.\n*\n*\n* DEPENDENCIES/RESTRICTIONS:\n*\n*         USES MACROS XSAVE1 AND XRETURN FOR LINKAGE\n*         USES MACRO REGISTER FOR DEFINING REGISTER SYMBOLIC NAMES\n*         USES MACROS DYNATXTU AND DYNABLD FOR BUILDING DYNAMIC\n*         ALLOCATION CONTROL BLOCKS\n*\n*         THERE IS AN MVS/TSO HELP ENTRY FOR THIS PROGRAM.\n*\n         EJECT\n*\n* STORAGE LAYOUT:\n*\n*         ------------------------------------------------------\n*         I  STANDARD SAVE AREA                                I\n*         I                                                    I\n*         ------------------------------------------------------\n*         I  REQUEST BLOCK POINTER                             I\n*         ------------------------------------------------------\n*         I  REQUEST BLOCK                                     I\n*         I                                                    I\n*         ------------------------------------------------------\n*         I  TEXT UNIT ADDRESSES                               I\n*         I                                                    I\n*         ------------------------------------------------------\n*         I  TEXT UNITS                                        I\n*         I                                                    I\n*         I                                                    I\n*         ------------------------------------------------------\n*         I  OUTPUT BUFFER                                     I\n*         ------------------------------------------------------\n*         I  OUTPUT DATASET CONTROL BLOCK                      I\n*         I                                                    I\n*         ------------------------------------------------------\n*         I  OPEN MACRO                                        I\n*         I                                                    I\n*         ------------------------------------------------------\n*         I  CLOSE MACRO                                       I\n*         I                                                    I\n*         ------------------------------------------------------\n*\n*\n* NOTES:\n*         ALTHOUGH TU7, THE DSORG TEXT UNIT, IS DEFINED IN THE\n*         PROGRAM, IT IS NOT CURRENTLY USED.  THIS TEXT UNIT MAY\n*         BE REPLACED BY ANOTHER ONE IF OTHER INFORMATION IS\n*         DESIRED.\n*\n         EJECT\n*\n* CHANGE LOG:\n*\n*          3/22/83  COMPLETE,\n*                   FULL FUNCTION: DSN, DDN, STATUS, NORMAL DISP,\n*                   AND DATASET TYPE ARE PRINTED OUT WITH AN\n*                   UNDERLINED TITLE LINE AND BLANK LINES AT THE\n*                   BEGINNING AND END OF THE REPORT.\n*\n*          5/10/83  DOCUMENTATION IMPROVED, AND TEST FOR \"UNCAT\"\n*                   NORMAL DISPOSITION ADDED.\n*\n*          5/11/83  CHANGED PRINT LINE LENGTH FROM 81 TO 121 BYTES.\n*                   SINCE LRECL IS NOT CODED ON THE DCB, IT SHOULD\n*                   WORK WITH SIZES BETWEEN 81 AND 121 SUCCESSFULLY.\n* AUTHOR:\n*         RIC FORD                 (617) 466-2133\n*         COMPUTER CENTER\n*         GTE LABORATORIES\n*         40 SYLVAN ROAD\n*         WALTHAM, MASSACHUSETTS  02254\n*\n*\n*=====================================================================\n         EJECT\n*---------------------------------------------------------------------\n* ENTER PROGRAM AND MAP GETMAINED STORAGE AREA\n*---------------------------------------------------------------------\n*\nSAL      XSAVE1 OPT=CSECT,REEN=STGSIZE,REG=12\n*\n         USING STGAREA,R13\n*\n*---------------------------------------------------------------------\n* BUILD REQUEST BLOCK POINTER AND REQUEST BLOCK\n*---------------------------------------------------------------------\n         LA    R4,RBPOINTR        GET R.B. POINTER ADDRESS\n         USING S99RBPTR,R4        MAP POINTER\n         LA    R5,REQBLOCK        GET REQUEST BLOCK ADDRESS\n         USING S99RB,R5           MAP REQUEST BLOCK\n         ST    R5,RBPOINTR        STORE POINTER TO REQUEST BLOCK\n         OI    S99RBPTR,S99RBPND  MARK IT LAST POINTER\n         XC    S99RB(RBLEN),S99RB ZERO OUT REQUEST BLOCK\n         MVI   S99RBLN,RBLEN      FILL IN REQUEST BLOCK'S LENGTH FIELD\n         MVI   S99VERB,S99VRBIN   SET VERB TO DO INFOMATION RETRIEVAL\n*\n         LA    R6,$ADDRLST        POINT TO FIRST T.U. ADDRESS\n         USING S99TUPL,R6         MAP IT\n         ST    R6,S99TXTPP        STORE ADDRESS LIST POINTER IN R.B.\n*\n         EJECT\n*---------------------------------------------------------------------\n*  BUILD TEXT UNIT ADDRESS LIST\n*---------------------------------------------------------------------\n         DYNABLD $ADDRLST,(TU1,TU2,TU3,TU4,TU5,TU6,TU7,TU8)  BUILD LIST\n*\n*---------------------------------------------------------------------\n* BUILD DCB FOR WRITING ALLOCATION INFORMATION.\n*---------------------------------------------------------------------\n         LA    R8,SYSPRINT               POINT TO DCB\n         USING IHADCB,R8                 MAP DCB\n         MVC   SYSPRINT(DCBSIZE),OUTDCB  COPY DCB INTO GETMAINED AREA\n*\n         EJECT\n*---------------------------------------------------------------------\n*  OPEN THE OUTPUT FILE\n*---------------------------------------------------------------------\n         LINK  EP=CLEAR\n         LA    R9,SYSPRINT             GET DCB ADDRESS\n         ICM   R9,PARMMASK,OPENLIST    FILL IN OPEN PARMS BYTE\n         ST    R9,OPENLSTD             STORE IT INTO DCB\n         OPEN  (SYSPRINT,(OUTPUT)),MF=(E,OPENLSTD)  TRY TO OPEN OUTPUT X\n                                                  FILE USING PARM-LIST.\n         TM    DCBOFLGS,DCBOFOPN    DID OPEN COMPLETE SUCCESSFULLY?\n         BO    WRTHEADR             YES, GO WRITE HEADER LINE\n         TPUT  MESS,L'MESS\n         ABEND ABCODE               DIDN'T OPEN, GIVE HIM AN OPEN ABEND\nMESS     DC    CL30'ALLOCATE SYSPRINT AND RETRY'\n*\n         EJECT\n*---------------------------------------------------------------------\n*  WRITE THE HEADER LINES\n*---------------------------------------------------------------------\nWRTHEADR EQU   *\n         PUT   SYSPRINT,BLANKS\n         PUT   SYSPRINT,BLANKS\n         PUT   SYSPRINT,HEADER1\n         PUT   SYSPRINT,HEADER2\n*\n         EJECT\n*---------------------------------------------------------------------\n*  SET DYNAMIC ALLOCATION RELATIVE REQUEST NUMBER TO 1 TO\n*  RETRIEVE INFORMATION ABOUT THE FIRST ALLOCATION.\n*---------------------------------------------------------------------\n         LA    R10,1                SET RELATIVE REQUEST NO. TO 1\n*\n         USING S99TUNIT,R7          R7 WILL MAP TEXT UNIT\n*---------------------------------------------------------------------\n* INVOKE SVC 99, DYNAMIC ALLOCATION, FOR INFORMATION RETRIEVAL. THE\n* TEXT UNITS REQUEST INFORMATION ABOUT CURRENT ALLOCATIONS AND PROVIDE\n* SPACE FOR THE INFORMATION RETURNED BY SVC 99.\n*   R10 HOLDS RELATIVE REQUEST NUMBER FOR THIS INVOCATION.\n*   R4 HOLDS ADDRESS OF REQUEST BLOCK POINTER.\n*---------------------------------------------------------------------\nSVC99    EQU   *\n         LA    R7,TU1                    POINT TO FIRST TEXT UNIT\n         MVC   S99TUNIT(TUSSIZE),RELNOTU COPY ALL TEXT UNITS INTO      X\n                                         GETMAINED AREA\n*\n         STCM  R10,REQMASK,S99TUPAR STORE REL. REQ. # INTO T.U. PARM.\n         LR    R1,R4                POINT TO REQUEST BLOCK POINTER\n         SVC   99                   GET THE INFORMATION\n*\n         CH    R15,ZERO             TEST RETURN CODE\n         BNE   BADRC                IF IT'S NOT ZERO GO PROCESS ERROR\n*\n         EJECT\n*---------------------------------------------------------------------\n*  SVC 99 COMPLETION WAS SUCCESSFUL.  PROCESS THE INFORMATION.\n*---------------------------------------------------------------------\n         MVC   PUTLINED(LINELEN),BLANKS  CLEAR OUTPUT BUFFER\n*\n         LA    R7,TU3                  MAP DDNAME TEXT UNIT\n         MVC   DDN(L'DDN),S99TUPAR     GET DDNAME IN OUTPUT BUFFER\n*\n         LA    R7,TU4                  MAP DSNAME TEXT UNIT\n         MVC   DSN(L'DSN),S99TUPAR     GET DSNAME IN OUTPUT BUFFER\n*\n         LA    R7,TU6                  MAP STATUS TEXT UNIT\n         TM    S99TUPAR,SHRQ           IS IT SHR?\n         BNO   TESTNEW                 NO, TRY AGAIN\n         MVC   STATUS(STATLEN),SHR     PUT \"SHR\" IN BUFFER\n         B     ENDSTAT                 GO LOOK AT TYPE TEXT UNIT\nTESTNEW  EQU   *\n         TM    S99TUPAR,NEWQ           IS IT NEW?\n         BNO   TESTMOD                 NO, TRY AGAIN\n         MVC   STATUS(STATLEN),NEW     PUT \"NEW\" IN BUFFER\n         B     ENDSTAT                 GO LOOK AT TYPE\nTESTMOD  EQU   *\n         TM    S99TUPAR,MODQ           IS IT MOD?\n         BNO   TESTOLD                 NO, TRY AGAIN\n         MVC   STATUS(STATLEN),MOD     PUT \"MOD\" IN BUFFER\n         B     ENDSTAT                 GO LOOK AT TYPE\nTESTOLD  EQU   *\n         TM    S99TUPAR,OLDQ           IS IT OLD?\n         BNO   NOSTAT                  NO, GO PUT BLANKS IN\n         MVC   STATUS(STATLEN),OLD     PUT \"OLD\" IN BUFFER\n         B     ENDSTAT                 GO LOOK AT TYPE\nNOSTAT   EQU   *                       STATUS RETURNED IS UNDEFINED\n         MVC   STATUS(STATLEN),BLANKS MOVE BLANKS IN\n*\n         EJECT\n*\nENDSTAT  EQU   *\n         LA    R7,TU5                  MAP DATASET NORMAL DISP. T.U.\n*\n         TM    S99TUPAR,PASSQ          IS NORMAL DISP. \"PASS\"?\n         BNO   TESTKEEP\n         MVC   DISP(DISPLEN),PASS\n         B     ENDDISP\nTESTKEEP EQU   *\n         TM    S99TUPAR,KEEPQ          IS NORMAL DISP. \"KEEP\"?\n         BNO   TESTDEL\n         MVC   DISP(DISPLEN),KEEP\n         B     ENDDISP\nTESTDEL  EQU   *\n         TM    S99TUPAR,DELETEQ        IS NORMAL DISP. \"DELETE\"?\n         BNO   TESTUNCT\n         MVC   DISP(DISPLEN),DELETE\n         B     ENDDISP\nTESTUNCT EQU  *\n         TM    S99TUPAR,UNCATQ         IS NORMAL DISP. \"UNCAT\"?\n         BNO   TESTCATL\n         MVC   DISP(DISPLEN),UNCAT\n         B     ENDDISP\nTESTCATL EQU  *\n         TM    S99TUPAR,CATLGQ         IS NORMAL DISP. \"CATLG\"?\n         BNO   NODISP                  NO, THERE'S NO VALID DISP.\n         MVC   DISP(DISPLEN),CATLG\n         B     ENDDISP\nNODISP   EQU   *                       DATASET IS UNDEFINED DISP\n         MVC   DISP(DISPLEN),BLANKS    MOVE BLANKS IN\n*\n         EJECT\nENDDISP  EQU   *\n         LA    R7,TU8                  MAP DATASET TYPE TEXT UNIT\n*\n         TM    S99TUPAR,DUMMQ          IS DS DUMMY TYPE?\n         BNO   TESTTERM\n         MVC   TYPE(TYPELEN),DUMMY\n         B     ENDTYPE\nTESTTERM EQU   *\n         TM    S99TUPAR,TERMQ          IS DS TERMINAL TYPE?\n         BNO   TESTSYOU\n         MVC   TYPE(TYPELEN),TERMINAL\n         B     ENDTYPE\nTESTSYOU EQU   *\n         TM    S99TUPAR,SYSOUTQ        IS DATASET SYSOUT TYPE?\n         BNO   TESTSYIN\n         MVC   TYPE(TYPELEN),SYSOUT\n         B     ENDTYPE\nTESTSYIN EQU   *\n         TM    S99TUPAR,SYSINQ         IS DATASET SYSIN TYPE?\n         BNO   NOTYPE\n         MVC   TYPE(TYPELEN),SYSIN\n         B     ENDTYPE\nNOTYPE   EQU   *                       DATASET IS UNDEFINED TYPE\n         MVC   TYPE(TYPELEN),BLANKS    MOVE BLANKS IN\n*\nENDTYPE  EQU   *\n         EJECT\n*---------------------------------------------------------------------\n*  WRITE OUT REPORT LINE.\n*---------------------------------------------------------------------\n         PUT   SYSPRINT,PUTLINED       WRITE OUTPUT BUFFER OUT\n*\n*\n*---------------------------------------------------------------------\n*  END IF THIS IS THE LAST REQUEST. OTHERWISE, INCREMENT THE RELATIVE\n*  REQUEST NUMBER AND GO INVOKE SVC 99 AGAIN.\n*---------------------------------------------------------------------\n         LA    R7,TU2                  POINT TO LAST-REL# INDICATOR T.U\n         TM    S99TUPAR,LASTREL#       WAS THIS THE LAST RELATIVE REQ?\n         BO    XRETURN                 YES, GO CLOSE AND END\n         LA    R10,1(R10)              NO, INCREASE REL. REQUEST #\n         B     SVC99                   PROCESS NEXT REL. REQUEST\n*\n         EJECT\n*---------------------------------------------------------------------\n*  SVC 99 JUST GOT A BAD RETURN CODE.  WE'LL PASS IT OUT VIA R15.\n*---------------------------------------------------------------------\nBADRC    EQU   *\n*\n*---------------------------------------------------------------------\n*  CLOSE OUTPUT FILE AND END\n*---------------------------------------------------------------------\nXRETURN  EQU   *\n         PUT   SYSPRINT,BLANKS\n         LA    R9,SYSPRINT             GET DCB ADDRESS\n         ICM   R9,PARMMASK,CLOSLIST    FILL IN CLOSE PARMS BYTE\n         ST    R9,CLOSLSTD             STORE IT INTO DCB\n         CLOSE (SYSPRINT),MF=(E,CLOSLSTD)  CLOSE THE OUTPUT FILE\n*\n         XRETURN RTN=RC      END\n*\n         EJECT\n**********************************************************************\n*  CREATE CONSTANTS\n**********************************************************************\nZERO     DC    F'0'\nDUMMY    DC    CL8'DUMMY   '\nTERMINAL DC    CL8'TERMINAL'\nSYSIN    DC    CL8'SYSIN   '\nSYSOUT   DC    CL8'SYSOUT  '\n*\nBLANKS   DC    121CL1' '\n*\nOLD      DC    CL5'OLD  '\nMOD      DC    CL5'MOD  '\nNEW      DC    CL5'NEW  '\nSHR      DC    CL5'SHR  '\n*\nPASS     DC    CL6'PASS  '\nKEEP     DC    CL6'KEEP  '\nDELETE   DC    CL6'DELETE'\nCATLG    DC    CL6'CATLG '\nUNCAT    DC    CL6'UNCAT '\n*\n         EJECT\n*---------------------------------------------------------------------\n*  CREATE HEADER LINE 1\n*---------------------------------------------------------------------\nHEADER1  DS    0F\n         DC    CL1'1'\n         DC    CL8'DDNAME  '\n         DC    CL1' '\n         DC    CL44'DATASET NAME                                '\n         DC    CL1' '\n         DC    CL5'STAT.'\n         DC    CL1' '\n         DC    CL6'N-DISP'\n         DC    CL2' '\n         DC    CL8'DS-TYPE '\n         DC    CL44'                                            '\n*\n*---------------------------------------------------------------------\n*  CREATE HEADER LINE 2\n*---------------------------------------------------------------------\nHEADER2  DS    0F\n         DC    CL1' '\n         DC    CL8'--------'\n         DC    CL1' '\n         DC    CL44'--------------------------------------------'\n         DC    CL1' '\n         DC    CL5'---- '\n         DC    CL1' '\n         DC    CL6'------'\n         DC    CL2'  '\n         DC    CL8'--------'\n         DC    CL44'                                            '\n*\n         EJECT\n*---------------------------------------------------------------------\n*  CREATE TEXT UNITS\n*---------------------------------------------------------------------\nRELNOTU  DYNATXTU DINRELNO,2,F00  DEFINE RELATIVE REQUEST NO. T.U.\nRTLSTTU  DYNATXTU DINRTLST,1,F00  DEFINE RETURN-LAST-RELATIVE-         X\n                                  ENTRY-INDICATOR TEXT UNIT\nRTDDNTU  DYNATXTU DINRTDDN,8,F40       DEFINE RETURN-DDN T.U.\nRTDSNTU  DYNATXTU DINRTDSN,44,F40      DEFINE RETURN-DSN TEXT UNIT\nRTNDPTU  DYNATXTU DINRTNDP,1,F00       DEFINE RETURN-NORMAL-DISP T.U.\nRTSTATU  DYNATXTU DINRTSTA,1,F00       DEFINE RETURN-STATUS T.U.\nRTORGTU  DYNATXTU DINRTORG,2,F00       RETURN-DS-ORGANIZATION T.U.\nRTTYPTU  DYNATXTU DINRTTYP,1,F00       DEFINE RETURN-DS-TYPE T.U.\nTUSSIZE  EQU   *-RELNOTU\n         EJECT\n*---------------------------------------------------------------------\n*  CREATE LIST FORMS OF OPEN AND CLOSE\n*---------------------------------------------------------------------\nOPENLIST OPEN  (OUTDCB,(OUTPUT)),MF=L  CREATE OPEN PARMS LIST\nCLOSLIST CLOSE (OUTDCB),MF=L           CREATE CLOSE PARMS LIST\n*\n         EJECT\n*---------------------------------------------------------------------\n*  CREATE DATASET CONTROL BLOCK FOR OUTPUT.\n*---------------------------------------------------------------------\nOUTDCB   DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=(PM),RECFM=FBA,    XXXXXXX\n               LRECL=80,BLKSIZE=80\nDCBSIZE  EQU   *-OUTDCB\n*\n         EJECT\n**********************************************************************\n*  DEFINE DSECTS TO MAP STORAGE\n**********************************************************************\n*---------------------------------------------------------------------\n*  DEFINE ENTIRE GETMAINED STORAGE AREA\n*---------------------------------------------------------------------\nSTGAREA  DSECT\nSAVEAREA DS    18F           SAVE AREA\nRBPOINTR DS    F             REQUEST BLOCK POINTER\nREQBLOCK DS    XL20          REQUEST BLOCK\n$ADDRLST DS    8A            TEXT UNIT ADDRESSES\n         EJECT\nTU1      DYNATXTU DINRELNO,2,F00  DEFINE RELATIVE REQUEST NO. T.U.\nTU2      DYNATXTU DINRTLST,1,F00  DEFINE RETURN-LAST-RELATIVE-ENTRY-   X\n                                  -INDICATOR TEXT UNIT\nTU3      DYNATXTU DINRTDDN,8,F40       DEFINE RETURN-DDN TEXT UNIT\nTU4      DYNATXTU DINRTDSN,44,F40      DEFINE RETURN-DSN TEXT UNIT\nTU5      DYNATXTU DINRTNDP,1,F00       DEFINE RETURN-NORMAL-DISP. T.U.\nTU6      DYNATXTU DINRTSTA,1,F00       DEFINE RETURN-STATUS T.U.\nTU7      DYNATXTU DINRTORG,2,F00       RETURN-DS-ORGANIZATION T.U.\nTU8      DYNATXTU DINRTTYP,1,F00       DEFINE RETURN-DS-TYPE T.U.\n         EJECT\nPUTLINED DS    0CL121\nANSICNTL DS    CL1\nDDN      DS    CL8\n         DS    CL1\nDSN      DS    CL44\n         DS    CL1\nSTATUS   DS    CL5\n         DS    CL1\nDISP     DS    CL6\n         DS    CL2\nTYPE     DS    CL8\n         DS    CL44\n         PRINT NOGEN\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=(PM),RECFM=FBA,    XXXXXXX\n               LRECL=80,BLKSIZE=80\n         PRINT GEN\nOPENLSTD OPEN  (OUTDCB,(OUTPUT)),MF=L\nCLOSLSTD CLOSE (OUTDCB),MF=L\nSTGSIZE  EQU   *-STGAREA\n         EJECT\n*---------------------------------------------------------------------\n* MAP THE SVC 99 PARAMETER LIST:\n*\n*   1. REQUEST BLOCK POINTER, POINTED TO BY R1\n*   2. A DYNAMIC ALLOCATION REQUEST BLOCK\n*   3. TEXT UNIT ADDRESSES LIST\n*   4. TEXT UNITS\n*\n*---------------------------------------------------------------------\n         IEFZB4D0            MAP SVC 99 PARAMETER LIST\nRBLEN    EQU   (S99RBEND-S99RB)     LENGTH OF REQUEST BLOCK\n*\n         EJECT\n*---------------------------------------------------------------------\n*  MAP DCB\n*---------------------------------------------------------------------\n         IHADCB DSORG=QS     MAP THE DCB FIELDS\n*\n         EJECT\n**********************************************************************\n*  DEFINE MORE SYMBOLS\n**********************************************************************\nSYMBOLS  DSECT\n         REGISTER            DEFINE REGISTERS\nSTATLEN  EQU   5             LENGTH OF STATUS FIELD\nDISPLEN  EQU   6             LENGTH OF STATUS FIELD\nTYPELEN  EQU   8             LENGTH OF TYPE FIELD\nLINELEN  EQU   121           SIZE OF OUTPUT PRINT LINE\n*\nABCODE   EQU   13            USER ABEND CODE IF SYSPRINT WON'T OPEN\n*\nLASTREL# EQU   X'80'         THIS BIT ON IF LAST RELATIVE REQUEST\n*\nDUMMQ    EQU   X'80'         THIS BIT ON IF TYPE IS DUMMY\nTERMQ    EQU   X'40'         THIS BIT ON IF TYPE IS TERMINAL\nSYSINQ   EQU   X'20'         THIS BIT ON IF TYPE IS SYSIN\nSYSOUTQ  EQU   X'10'         THIS BIT ON IF TYPE IS SYSOUT\n*\nSHRQ     EQU   X'08'         THIS BIT ON IF STATUS IS SHR\nNEWQ     EQU   X'04'         THIS BIT ON IF STATUS IS NEW\nMODQ     EQU   X'02'         THIS BIT ON IF STATUS IS MOD\nOLDQ     EQU   X'01'         THIS BIT ON IF STATUS IS OLD\n*\nPASSQ    EQU   X'10'         THIS BIT ON IF NORMAL DISP IS PASS\nKEEPQ    EQU   X'08'         THIS BIT ON IF NORMAL DISP IS KEEP\nDELETEQ  EQU   X'04'         THIS BIT ON IF NORMAL DISP IS DELETE\nCATLGQ   EQU   X'02'         THIS BIT ON IF NORMAL DISP IS CATLG\nUNCATQ   EQU   X'01'         THIS BIT ON IF NORMAL DISP IS UNCATLG\n*\nREQMASK  EQU   B'0011'       LOWER-ORDER HALF WORD OF REG. HOLDS       X\n                             RELATIVE REQUEST NUMBER\nPARMMASK EQU   B'1000'       HIGH-ORDER BYTE IS PARM FOR OPEN/CLOSE.\n         EJECT\n*---------------------------------------------------------------------\n*  IDENTIFY THE DYNAMIC ALLOCATION FUNCTION CODES\n*  (OR \"TEXT UNIT KEYS\")\n*---------------------------------------------------------------------\n         IEFZB4D2            MAP SVC 99 TEXT UNIT KEYS\n*\n*\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DYNABLD": {"ttr": 772, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   DYNABLD &ADDR,&PARMS\n.*--------------------------------------------------------------------*\n.* M.SCHERFLING   GTE LABORATORIES  1/83                              *\n.*                                                                    *\n.* MACRO BUILDS THE DYNAMIC ALLOCATION CONTROL BLOCK                  *\n.* PARAMETER: ADDR  - LOCATION TO BUILD LIST                          *\n.*                    * - HERE  (&LABEL THEN REQUIRED)                *\n.*                    #.. OR $..  - DSECT ADDR                        *\n.*                                                                    *\n.*            PARMS - LIST (IN PARENTHESIS) OF NAMES OF CONTROL BLKS  *\n.*   TO BUILD IN LIST                                                 *\n.*                                                                    *\n.* MNOTE IF ANY OPERANDS ARE MISSING                                  *\n.*--------------------------------------------------------------------*\n.*\n         LCLA  &END,&CNT,&OFFSET\n.*\n         AIF   ('&ADDR'   EQ '').NOADDR\n         AIF   ('&PARMS' EQ '').NOPARMS\n&LABEL   DS    0H                 TEXT POINTER CHAIN\n.*\n         AIF   ('&ADDR'(1,1) NE '#' AND '&ADDR'(1,1) NE '$').GOLOOP\n         LA    1,&ADDR            LOAD POINTER TO CHAIN AREA\n.GOLOOP  ANOP\n&END     SETA  N'&PARMS\n&CNT     SETA  1\n.LOOP    AIF   (&CNT   GE  &END).ENDLOOP\n         AIF   ('&ADDR' NE '*').TRYDSCT\n         DC    A(&PARMS(&CNT))    TEXT UNIT &CNT\n         AGO   .INCRCNT\n.TRYDSCT LA    0,&PARMS(&CNT)     LOAD PARM NUMBER &CNT\n         ST    0,&OFFSET.(1)      STORE IN CHAIN\n&OFFSET  SETA  &OFFSET+4\n.INCRCNT ANOP\n&CNT     SETA  &CNT+1\n         AGO   .LOOP\n.ENDLOOP AIF   ('&ADDR' NE '*').TRYDST2\n         DC    A(X'80000000'+&PARMS(&CNT)) TEXT UNT &CNT\n         MEXIT\n.TRYDST2 LA    0,&PARMS(&CNT)     LOAD PARM NUMBER &CNT\n         ST    0,&OFFSET.(1)      STORE IN CHAIN\n         MVI   &OFFSET.(1),X'80'  SET HIGH BYTE\n         MEXIT\n.NOADDR  MNOTE 8,'SUPPLY ADDRESS OF TEXT UNIT POINTERS'\n         MEXIT\n.NOPARMS MNOTE 8,'SUPPLY TEXT UNITS TO CREATE POINTER CHAIN'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DYNATXTU": {"ttr": 774, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   DYNATXTU  &CODE,&LEN,&PARM\n.*--------------------------------------------------------------------*\n.* M.SCHERFLING  GTE LABORATORIES  1/83                               *\n.*                                                                    *\n.* MACRO CREATES DYNAMIC ALLOCATION TEXT UNIT                         *\n.* ** WARNING ** MACRO NOT DESIGNED FOR MULTIBLE PARAMETER TEXT UNITS *\n.*                                                                    *\n.* PARMS: &LABEL - NAME ASSOCIATED WITH TEXT UNIT                     *\n.*        &CODE  - TEXT UNIT IDENTIFIER, CAN BE THE DYNALLOC EQUATES  *\n.*        &LEN   - LENGTH OF PARMETER. IF OMITED, IT WILL BE CALC'ED  *\n.*        &PARM  - PARM VALUE, CAN BE QUOTED                          *\n.*                 PREFIX: C - CHARACTER PARM VALUE                   *\n.*                         X - HEX PARM VALUE                         *\n.*                         F - FILL VALUE (SPECIFIED IN HEX)          *\n.* NOTE : TEXT UNIT PARM COUNT DEFAULTS TO 1                          *\n.*        IF LENGTH OMITTED, DEFAULTS TO ONE IF PARAMETER IS SPECIFIED*\n.*                                                                    *\n.* MNOTE IF &LABEL, OR &CODE MISSING                                  *\n.*       IF PARM CODE NOT C OR X OR F                                 *\n.*                                                                    *\n.* CHANGES:                                                           *\n.*         3/8/83  CHANGED &CODE FROM XL2' '  TO AL2( ) SO THAT       *\n.*                 IEFZB4D2 SYMBOLS FOR KEYS CAN BE USED INSTEAD OF   *\n.*                 STRAIGHT HEX CODES.  -- RIC FORD                   *\n.*        3/17/83  CHANGED &LEN  FROM XL2' '  TO AL2( ) SO THAT       *\n.*                 DECIMAL LENGTHS ARE USED INSTEAD OF HEX LENGTHS.   *\n.*                                      -- RIC FORD                   *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         LCLC  &PARMX,&T\n         LCLA  &LENX\n         LCLB  &F\n         AIF   ('&LABEL' EQ '').NOLABL\n         AIF   ('&CODE' EQ '').NOCODE\n.*\n&LABEL   DS    0H                START OF TEXT UNIT\n         DC    AL2(&CODE)        TEXT UNIT ID\n         AIF   ('&LEN' NE '').GOCOUNT\n         AIF   ('&PARM' NE '').GETLEN\n         DC    XL2'00'           NO PARM DEFINITION\n         MEXIT\n.GOCOUNT DC    XL2'01'           PARM COUNT\n         DC    AL2(&LEN)         PARM LENGTH * DEFAULT\n&F       SETB  1                 FLAG SET TO INDICATE ALREADY DONE\n         AGO   .PARM\n.GETLEN  DC    XL2'01'           PARM COUNT\n.*\n.PARM    AIF   ('&PARM'(1,1) EQ 'C').GOCHAR\n         AIF   ('&PARM'(1,1) EQ 'X').GOHEX\n         AIF   ('&PARM'(1,1) EQ 'F').GOHEX\n         AGO   .BADTYPE\n.GOCHAR  ANOP\n&T       SETC  'C'\n         AIF   (&F).GOPARM\n&LENX    SETA  (K'&PARM)-1\n         AGO   .GOPARM\n.GOHEX   ANOP\n&T       SETC  'X'\n         AIF   (&F).GOPARM\n&LENX    SETA  ((K'&PARM)-1)/2\n.GOPARM  ANOP\n&PARMX   SETC  '&PARM'(2,(K'&PARM)-1)\n         AIF   (NOT &F).DOLEN\n         AIF   ('&PARM'(1,1) EQ 'F').DOFILL1\n         DC    &T.L&LEN.'&PARMX' PARM VALUE\n         MEXIT\n.DOFILL1 DC    &LEN.&T.'&PARMX'  PARM VALUE\n         MEXIT\n.DOLEN   DC    AL2(&LENX)        PARM LENGTH\n         AIF   ('&PARM'(1,1) EQ 'F').DOFILL2\n         DC    &T.L&LENX.'&PARMX'      PARM VALUE\n         MEXIT\n.DOFILL2 DC    &LEN.&T.'&PARMX'  PARM VALUE\n         MEXIT\n.NOLABL  MNOTE 8,'LABEL MISSING FOR TEXT UNIT NAME'\n         MEXIT\n.NOCODE  MNOTE 8,'TEXT UNIT CODE MISSING'\n         MEXIT\n.BADTYPE MNOTE 8,'PREFIX OF PARM TYPE MUST BE \"C\" OR \"X\" OR \"F\"'\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EQ$R": {"ttr": 777, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         EQ$R\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GTEDAALC": {"ttr": 779, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   GTEDAALC  &NM,&VERB=AL,&ERRMSG=YES\n.*\n.*          +-----------------------------------------------+\n.*          |  See macro GTEDADOC for documentation of the  |\n.*          |  use of this and other GTEDAxxx macros.       |\n.*          +-----------------------------------------------+\n.*\n*\n**********************************************************************\n***   PERFORM DYNAMIC ALLOCATION USING A DATA AREA CREATED         ***\n***   BY MACRO GTEDADAT, AND POINTERS/DATA SET BY MACRO GTEDASET.  ***\n**********************************************************************\n*\n**********************************************************************\n***   SET VERB CODE INTO S99RB.                                    ***\n***   MAPPING MACRO IEFZB4D0 MUST APPEAR IN THE SOURCE.            ***\n**********************************************************************\n*\n&LABEL   LA    1,&NM.RB\n.*\n.VBAL    AIF   ('&VERB' NE 'AL').VBUN\n         MVI   (S99VERB-S99RB)(1),S99VRBAL   SET VERB, DSN ALLOC\n         AGO   .VBEND\n.VBUN    AIF   ('&VERB' NE 'UN').VBCC\n         MVI   (S99VERB-S99RB)(1),S99VRBUN   SET VERB, DSN UNALLOC\n         AGO   .VBEND\n.VBCC    AIF   ('&VERB' NE 'CC').VBDC\n         MVI   (S99VERB-S99RB)(1),S99VRBCC   SET VERB, CONCATENATE\n         AGO   .VBEND\n.VBDC    AIF   ('&VERB' NE 'DC').VBRI\n         MVI   (S99VERB-S99RB)(1),S99VRBDC   SET VERB, DECONCATENATE\n         AGO   .VBEND\n.VBRI    AIF   ('&VERB' NE 'RI').VBDN\n         MVI   (S99VERB-S99RB)(1),S99VRBRI   SET VERB, REMOVE IN-USE\n         AGO   .VBEND\n.VBDN    AIF   ('&VERB' NE 'DN').VBIN\n         MVI   (S99VERB-S99RB)(1),S99VRBDN   SET VERB, DDN ALLOC\n         AGO   .VBEND\n.VBIN    AIF   ('&VERB' NE 'IN').VBEND\n         MVI   (S99VERB-S99RB)(1),S99VRBIN   SET VERB, REQUEST INFO\n         AGO   .VBEND\n.VBEND   ANOP\n.*\n*\n**********************************************************************\n***    DO DYNAMIC ALLOCATION                                       ***\n**********************************************************************\n*\n         LA    1,&NM.RBP                ADDRESS OF PTR TO SVC-99 RB\n         SVC   99                       DYNALLOC\n         ST    15,&NM.S99RC             SAVE RETURN CODE FROM SVC-99\n.*\n.*********************************************************************\n.**                                                                ***\n.**   IF &ERRMSG=NO, DO NOT EVER GENERATE CODE FOR IKJEFF18        ***\n.**                                                                ***\n.*********************************************************************\n.*\n         AIF   ('&ERRMSG' EQ 'NO').NOPR\n.*\n*\n**********************************************************************\n***    IF R/C FROM DYNAMIC ALLOCATION NOT ZERO,                    ***\n***    EXECUTE THE IKJEFF18 (DAIRFAIL) PROGRAM TO PRODUCE          ***\n***    ERROR MESSAGES.                                             ***\n**********************************************************************\n*\n         CNOP  2,4                      ALIGN FOR BRANCH INSTRUCTION\n         LTR   15,15                    IF RETURN CODE IS GOOD\n         BZ    EXZ&SYSNDX                 BRANCH TO END OF ROUTINE\n         BAL   1,EXA&SYSNDX  BRANCH AROUND LIST\n*\n**********************************************************************\n***    EXCEPTIONS, DON'T USE IKJEFF18 FOR THESE VERB/ERROR COMBOS  ***\n***                                                                ***\n         DC    H'1'          NUMBER OF MEMBERS IN THIS LIST\n         DC    X'02,0438'    VERB 02 ERR 0438 DDNAME NOT FOUND\n***                                                                ***\n**********************************************************************\n*\nEXA&SYSNDX LA    2,2(0,1)                    R2 IS POINTER TO COMBOS\n           LH    1,0(0,1)                    R1 IS COUNT OF COMBOS\n           LA    15,&NM.RB                   R15 IS BASE OF RB\n*\n           CLC   (S99VERB-S99RB)(1,15),0(2)  IF NO MATCH ON VERB\n           BNE   *+14                          BRANCH TO END OF LOOP\n           CLC   (S99ERROR-S99RB)(2,15),1(2) ELSE IF ERRCDE MATCHES\n           BE    EXZ&SYSNDX                    BRANCH TO ENDING\n           LA    2,6(0,2)                    POINT TO NEXT ENTRY\n           BCT   1,*-24                      LOOP BACK UP TIL EOL\n*\n         LA    1,&NM.DFPRM              POINT TO IKJEFF18 PARM BLOCK\n         CNOP  0,4                      ALIGN FOR FOLLOWING BAL\n         BAL   15,*+20                  LOAD CONST ADDR AND BRANCH\n         DC    A(*+8)                   ADDR OF LINK PARM LIST\n         DC    A(0)                     ADDR OF DCB (NONE)\n         DC    CL8'IKJEFF18'            EP NAME\n         SVC   6                        LINK\n*\n.NOPR    ANOP\nEXZ&SYSNDX NOPR  0                        END POINT\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GTEDADAT": {"ttr": 782, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NM      GTEDADAT  &MAP=,&DDNAM=,&DSNAM=,&MEMBR=,&STATS=,              X\n               &NDISP=,&CDISP=,                                        X\n               &TRK=,&CYL=,&BLKLN=,&PRIME=,&SECND=,&DIR=,&RLSE=,       X\n               &SPFRM=,&ROUND=,&VLSER=,&PRIVT=,&VLSEQ=,&VLCNT=,        X\n               &VLRDS=,&UNIT=,&UNCNT=,&PARAL=,&SYSOU=,&SPGNM=,&SFMNO=, X\n               &OUTLM=,&CLOSE=,&COPYS=,&LABEL=,&DSSEQ=,&PASPR=,        X\n               &INOUT=,&EXPDT=,&RETPD=,&DUMMY=,&FCBIM=,&FCBAV=,        X\n               &QNAME=,&TERM=,&UCS=,&UFOLD=,&UVRFY=,&DCBDS=,&DCBDD=,   X\n               &SUSER=,&SHOLD=,&MSVGP=,&SSNM=,&PROT=,&BFALN=,&BFTEK=,  X\n               &BLKSZ=,&BUFIN=,&BUFL=,&BUFMX=,&BUFNO=,&BUFOF=,&BUFOU=, X\n               &BUFRQ=,&BUFSZ=,&CODE=,&CPRI=,&DEN=,&DSORG=,&EROPT=,    X\n               &GNCP=,&INTVL=,&KYLEN=,&LIMCT=,&LRECL=,&MODE=,&NCP=,    X\n               &OPTCD=,&PCIR=,&PCIS=,&PRTSP=,&RECFM=,&RSRVF=,&RSRVS=,  X\n               &SOWA=,&STACK=,&THRSH=,&TRTCH=,&IPLTX=,&DIAGN=,&FUNC=,  X\n               &FRID=,&PASSW=,&PERMA=,&CNVRT=,                         X\n               &RTDDN=,&RTDSN=,&RTORG=,       <== FOR DSN ALLOCATION   X\n               &INDDN=,&INDSN=,&INORG=,       <== FOR INFO RETRIEVAL   X\n               &RTMEM=,&RTSTA=,&RTNDP=,&RTCDP=,&RTLIM=,&RTATT=,        X\n               &RTLST=,&RTTYP=,&RELNO=,                                X\n               &RTVOL=,&SSPRM=,&TCBAD=,&REMOV=,&UNALC=\n.*\n.*          +-----------------------------------------------+\n.*          |  See macro GTEDADOC for documentation of the  |\n.*          |  use of this and other GTEDAxxx macros.       |\n.*          +-----------------------------------------------+\n.*\n           LCLA  &TUPLEN\n&TUPLEN    SETA  0\n*\n&NM        DS  0D                       ALIGN FOR GETMAIN\n*\n**********************************************************************\n***        TEXT UNITS FOR SVC99                                    ***\n**********************************************************************\n*\n&NM.TU     DS  0F   TEXT UNITS FOR SVC99\n.*\n.*********************************************************************\n.***       DSNAME ALLOCATION TEXT UNITS - VERB CODE 01             ***\n.*********************************************************************\n.*\n.TUDDNAM   AIF ('&DDNAM' EQ '').TUDSNAM\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUDDNA#\n           DS  XL6\n&NM.DDNAM  DS  CL8                      DDNAME\n           AGO .TUDSNAM\n.TUDDNA#   ANOP\n           DC  X'0001,0001,0008'\n&NM.DDNAM  DC  CL8'&DDNAM'              DDNAME\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUDSNAM   AIF ('&DSNAM' EQ '').TUMEMBR\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUDSNA#\n           DS  XL6\n&NM.DSNAM  DS  CL44                     DATASET NAME\n           AGO .TUMEMBR\n.TUDSNA#   ANOP\n           DC  X'0002,0001,002C'        DATASET NAME (NEXT LINE)\n&NM.DSNAM  DC  CL44'&DSNAM'\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUMEMBR   AIF ('&MEMBR' EQ '').TUSTATS\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUMEMB#\n&NM.MEMKY  DS  XL6\n&NM.MEMBR  DS  CL8                      MEMBER NAME\n           AGO .TUSTATS\n.TUMEMB#   ANOP\n&NM.MEMKY  DC  X'0003,0001,0008'\n&NM.MEMBR  DC  CL8'&MEMBR'              MEMBER NAME\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUSTATS   AIF ('&STATS' EQ '').TUNDISP\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUSTAT#\n&NM.STATS  DS  XL7                      STATUS\n           AGO .TUNDISP\n.TUSTAT#   AIF ('&STATS' NE 'OLD').TUSTAT2\n&NM.STATS  DC  X'0004,0001,0001,01'     STATUS=OLD\n           AGO .TUNDISP\n.TUSTAT2   AIF ('&STATS' NE 'MOD').TUSTAT4\n&NM.STATS  DC  X'0004,0001,0001,02'     STATUS=MOD\n           AGO .TUNDISP\n.TUSTAT4   AIF ('&STATS' NE 'NEW').TUSTAT8\n&NM.STATS  DC  X'0004,0001,0001,04'     STATUS=NEW\n           AGO .TUNDISP\n.TUSTAT8   AIF ('&STATS' NE 'SHR').TUNDISP\n&NM.STATS  DC  X'0004,0001,0001,08'     STATUS=SHR\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUNDISP   AIF ('&NDISP' EQ '').TUCDISP\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUNDIS#\n&NM.NDISP  DS  XL7                      NORMAL DISP\n           AGO .TUCDISP\n.TUNDIS#   AIF ('&NDISP' NE 'UNCATLG').TUNDIS2\n&NM.NDISP  DC  X'0005,0001,0001,01'     NORMAL DISP=UNCATLG\n           AGO .TUCDISP\n.TUNDIS2   AIF ('&NDISP' NE 'CATLG').TUNDIS4\n&NM.NDISP  DC  X'0005,0001,0001,02'     NORMAL DISP=CATLG\n           AGO .TUCDISP\n.TUNDIS4   AIF ('&NDISP' NE 'DELETE').TUNDIS8\n&NM.NDISP  DC  X'0005,0001,0001,04'     NORMAL DISP=DELETE\n           AGO .TUCDISP\n.TUNDIS8   AIF ('&NDISP' NE 'KEEP').TUCDISP\n&NM.NDISP  DC  X'0005,0001,0001,08'     NORMAL DISP=KEEP\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUCDISP   AIF ('&CDISP' EQ '').TUTRK\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUCDIS#\n&NM.CDISP  DS  XL7                      COND DISP\n           AGO .TUTRK\n.TUCDIS#   AIF ('&CDISP' NE 'UNCATLG').TUCDIS2\n&NM.CDISP  DC  X'0006,0001,0001,01'     COND DISP=UNCATLG\n           AGO .TUTRK\n.TUCDIS2   AIF ('&CDISP' NE 'CATLG').TUCDIS4\n&NM.CDISP  DC  X'0006,0001,0001,02'     COND DISP=CATLG\n           AGO .TUTRK\n.TUCDIS4   AIF ('&CDISP' NE 'DELETE').TUCDIS8\n&NM.CDISP  DC  X'0006,0001,0001,04'     COND DISP=DELETE\n           AGO .TUTRK\n.TUCDIS8   AIF ('&CDISP' NE 'KEEP').TUTRK\n&NM.CDISP  DC  X'0006,0001,0001,08'     COND DISP=KEEP\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUTRK     AIF ('&TRK' EQ '').TUCYL\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUTRKA\n&NM.TRK    DS  XL4                      TRK\n           AGO .TUCYL\n.TUTRKA    ANOP\n&NM.TRK    DC  X'0007,0000'             TRK\n           AGO .TUPRIME\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUCYL     AIF ('&CYL' EQ '').TUBLKLN\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUCYLA\n&NM.CYL    DS  XL4                      CYL\n           AGO .TUBLKLN\n.TUCYLA    ANOP\n&NM.CYL    DC  X'0008,0000'             CYL\n           AGO .TUPRIME\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUBLKLN   AIF ('&BLKLN' EQ '').TUPRIME\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUBLKL#\n           DS  XL6\n&NM.BLKLN  DS  AL3                      AVERAGE BLOCK LENGTH\n           AGO .TUPRIME\n.TUBLKL#   ANOP\n           DC  X'0009,0001,0003'\n&NM.BLKLN  DC  AL3(&BLKLN)              AVERAGE BLOCK LENGTH\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUPRIME   AIF ('&PRIME' EQ '').TUSECND\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUPRIM#\n           DS  XL6\n&NM.PRIME  DS  AL3                      PRIMARY SPACE QUANTITY\n           AGO .TUSECND\n.TUPRIM#   ANOP\n           DC  X'000A,0001,0003'\n&NM.PRIME  DC  AL3(&PRIME)              PRIMARY SPACE QUANTITY\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUSECND   AIF ('&SECND' EQ '').TUDIR\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUSECN#\n           DS  XL6\n&NM.SECND  DS  AL3                      SECONDARY SPACE QUANTITY\n           AGO .TUDIR\n.TUSECN#   ANOP\n           DC  X'000B,0001,0003'\n&NM.SECND  DC  AL3(&SECND)              SECONDARY SPACE QUANTITY\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUDIR     AIF ('&DIR' EQ '').TURLSE\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUDIRA\n           DS  XL6\n&NM.DIR    DS  AL3                      NUMBER OF DIRECTORY BLOCKS\n           AGO .TURLSE\n.TUDIRA    ANOP\n           DC  X'000C,0001,0003'\n&NM.DIR    DC  AL3(&DIR)                NUMBER OF DIRECTORY BLOCKS\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURLSE    AIF ('&RLSE' EQ '').TUSPFRM\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURLSEA\n&NM.RLSE   DS  XL4                      RLSE\n           AGO .TUSPFRM\n.TURLSEA   ANOP\n&NM.RLSE   DC  X'000D,0000'             RLSE\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUSPFRM   AIF ('&SPFRM' EQ '').TUROUND\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUSPFR#\n&NM.SPFRM  DS  XL7                      SPACE FORMAT\n           AGO .TUROUND\n.TUSPFR#   AIF ('&SPFRM' NE 'ALX').TUSPFR4\n&NM.SPFRM  DC  X'000E,0001,0001,02'     ALX\n           AGO .TUROUND\n.TUSPFR4   AIF ('&SPFRM' NE 'MXIG').TUSPFR8\n&NM.SPFRM  DC  X'000E,0001,0001,04'     MXIG\n           AGO .TUROUND\n.TUSPFR8   AIF ('&SPFRM' NE 'CONTIG').TUROUND\n&NM.SPFRM  DC  X'000E,0001,0001,08'     CONTIG\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUROUND   AIF ('&ROUND' EQ '').TUVLSER\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUROUN#\n&NM.ROUND  DS  XL4                      ROUND\n           AGO .TUVLSER\n.TUROUN#   ANOP\n&NM.ROUND  DC  X'000F,0000'             ROUND\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUVLSER   AIF ('&VLSER' EQ '').TUPRIVT\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUVLSE#\n           DS  XL6\n&NM.VLSER  DS  CL6                      VOLUME SERIAL NUMBER\n           AGO .TUPRIVT\n.TUVLSE#   ANOP\n           DC  X'0010,0001,0006'\n&NM.VLSER  DC  CL6'&VLSER'              VOLUME SERIAL NUMBER\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUPRIVT   AIF ('&PRIVT' EQ '').TUVLSEQ\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUPRIV#\n&NM.PRIVT  DS  XL4                      PVT\n           AGO .TUVLSEQ\n.TUPRIV#   ANOP\n&NM.PRIVT  DC  X'0011,0000'             PVT\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUVLSEQ   AIF ('&VLSEQ' EQ '').TUVLCNT\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUVLSQ#\n           DS  XL6\n&NM.VLSEQ  DS  AL2                      VOLUME SEQUENCE NUMBER\n           AGO .TUVLCNT\n.TUVLSQ#   ANOP\n           DC  X'0012,0001,0002'\n&NM.VLSEQ  DC  AL2(&VLSEQ)              VOLUME SEQUENCE NUMBER\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUVLCNT   AIF ('&VLCNT' EQ '').TUVLRDS\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUVLCN#\n           DS  XL6\n&NM.VLCNT  DC  AL1                      VOLUME COUNT\n           AGO .TUVLRDS\n.TUVLCN#   ANOP\n           DC  X'0013,0001,0001'\n&NM.VLCNT  DC  AL1(&VLCNT)              VOLUME COUNT\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUVLRDS   AIF ('&VLRDS' EQ '').TUUNIT\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUVLRD#\n           DS  XL6\n&NM.VLRDS  DS  CL44                     VOLUME REF TO THIS DSN\n           AGO .TUUNIT\n.TUVLRD#   ANOP\n           DC  X'0014,0001,002C'        VOLUME REF TO DSN (BELOW)\n&NM.VLRDS  DC  CL44'&VLRDS'\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUUNIT    AIF ('&UNIT' EQ '').TUUNCNT\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUUNITA\n           DS  XL6\n&NM.UNIT   DS  CL6                      UNIT\n           AGO .TUUNCNT\n.TUUNITA   ANOP\n           DC  X'0015,0001,0006'\n&NM.UNIT   DC  CL6'&UNIT'               UNIT\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUUNCNT   AIF ('&UNCNT' EQ '').TUPARAL\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUUNCN#\n           DS  XL6\n&NM.UNCNT  DS  AL1                      UNIT COUNT\n           AGO .TUPARAL\n.TUUNCN#   ANOP\n           DC  X'0016,0001,0001'\n&NM.UNCNT  DC  AL1(&UNCNT)              UNIT COUNT\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUPARAL   AIF ('&PARAL' EQ '').TUSYSOU\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUPARA#\n&NM.PARAL  DS  XL4                      PARALLEL MOUNT\n           AGO .TUSYSOU\n.TUPARA#   ANOP\n&NM.PARAL  DC  X'0017,0000'             PARALLEL MOUNT\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUSYSOU   AIF ('&SYSOU' EQ '').TUSPGNM\n           AIF ('&SYSOU' NE '*').TUSYSO2\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUSYSO#\n&NM.SYSOU  DS  XL4                      SYSOUT=*\n           AGO .TUSPGNM\n.TUSYSO#   ANOP\n&NM.SYSOU  DC  X'0018,0000'             SYSOUT=*\n           AGO .TUSPGNM\n.TUSYSO2   ANOP\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUSYS##\n           DS  XL6\n&NM.SYSOU  DS  CL1                      SYSOUT CLASS\n           AGO .TUSPGNM\n.TUSYS##   ANOP\n           DC  X'0018,0001,0001'\n&NM.SYSOU  DC  CL1'&SYSOU'              SYSOUT CLASS\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUSPGNM   AIF ('&SPGNM' EQ '').TUSFMNO\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUSPGN#\n           DS  XL6\n&NM.SPGNM  DS  CL8                      SYSOUT PROGRAM NAME\n           AGO .TUSFMNO\n.TUSPGN#   ANOP\n           DC  X'0019,0001,0008'\n&NM.SPGNM  DC  CL8'&SPGNM'              SYSOUT PROGRAM NAME\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUSFMNO   AIF ('&SFMNO' EQ '').TUOUTLM\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUSFMN#\n           DS  XL6\n&NM.SFMNO  DS  CL4                      SYSOUT FORM NAME/NUMBER\n           AGO .TUOUTLM\n.TUSFMN#   ANOP\n           DC  X'001A,0001,0004'\n&NM.SFMNO  DC  CL4'&SFMNO'              SYSOUT FORM NAME/NUMBER\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUOUTLM   AIF ('&OUTLM' EQ '').TUCLOSE\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUOUTL#\n           DS  XL6\n&NM.OUTLM  DS  AL3                      OUTLIM\n           AGO .TUCLOSE\n.TUOUTL#   ANOP\n           DC  X'001B,0001,0003'\n&NM.OUTLM  DC  AL3(&OUTLM)              OUTLIM\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUCLOSE   AIF ('&CLOSE' EQ '').TUCOPYS\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUCLOS#\n&NM.CLOSE  DS  XL4                      FREE=CLOSE\n           AGO .TUCOPYS\n.TUCLOS#   ANOP\n&NM.CLOSE  DC  X'001C,0000'             FREE=CLOSE\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUCOPYS   AIF ('&COPYS' EQ '').TULABEL\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUCOPY#\n           DS  XL6\n&NM.COPYS  DS  AL1                      COPIES\n           AGO .TULABEL\n.TUCOPY#   ANOP\n           DC  X'001D,0001,0001'\n&NM.COPYS  DC  AL1(&COPYS)              COPIES\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TULABEL   AIF ('&LABEL' EQ '').TUDSSEQ\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TULABE#\n&NM.LABEL  DS  XL7                      LABEL\n           AGO .TUDSSEQ\n.TULABE#   AIF ('&LABEL' NE 'NL').TULABE2\n&NM.LABEL  DC  X'001E,0001,0001,01'     LABEL=NL\n           AGO .TUDSSEQ\n.TULABE2   AIF ('&LABEL' NE 'SL').TULABE3\n&NM.LABEL  DC  X'001E,0001,0001,02'     LABEL=SL\n           AGO .TUDSSEQ\n.TULABE3   AIF ('&LABEL' NE 'NSL').TULABE4\n&NM.LABEL  DC  X'001E,0001,0001,04'     LABEL=NSL\n           AGO .TUDSSEQ\n.TULABE4   AIF ('&LABEL' NE 'SUL').TULABE5\n&NM.LABEL  DC  X'001E,0001,0001,0A'     LABEL=SUL\n           AGO .TUDSSEQ\n.TULABE5   AIF ('&LABEL' NE 'BLP').TULABE6\n&NM.LABEL  DC  X'001E,0001,0001,10'     LABEL=BLP\n           AGO .TUDSSEQ\n.TULABE6   AIF ('&LABEL' NE 'LTM').TULABE7\n&NM.LABEL  DC  X'001E,0001,0001,21'     LABEL=LTM\n           AGO .TUDSSEQ\n.TULABE7   AIF ('&LABEL' NE 'AL').TULABE8\n&NM.LABEL  DC  X'001E,0001,0001,40'     LABEL=AL\n           AGO .TUDSSEQ\n.TULABE8   AIF ('&LABEL' NE 'AUL').TUDSSEQ\n&NM.LABEL  DC  X'001E,0001,0001,48'     LABEL=AUL\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUDSSEQ   AIF ('&DSSEQ' EQ '').TUPASPR\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUDSSE#\n           DS  XL6\n&NM.DSSEQ  DS  AL2                      LABEL= DATASET SEQUENCE NUMBER\n           AGO .TUPASPR\n.TUDSSE#   ANOP\n           DC  X'001F,0001,0002'\n&NM.DSSEQ  DC  AL2(&DSSEQ)              LABEL= DATASET SEQUENCE NUMBER\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUPASPR   AIF ('&PASPR' EQ '').TUINOUT\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUINOUT   AIF ('&INOUT' EQ '').TUEXPDT\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUINOU#\n&NM.INOUT  DS  XL7                      LABEL=IN OR OUT\n           AGO .TUEXPDT\n.TUINOU#   AIF ('&INOUT' NE 'IN').TUINOU2\n&NM.INOUT  DC  X'0021,0001,0001,40'     LABEL=IN\n           AGO .TUEXPDT\n.TUINOU2   AIF ('&INOUT' NE 'OUT').TUEXPDT\n&NM.INOUT  DC  X'0021,0001,0001,80'     LABEL=OUT\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUEXPDT   AIF ('&EXPDT' EQ '').TURETPD\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUEXPD#\n           DS  XL6\n&NM.EXPDT  DS  CL5                      EXPDT\n           AGO .TURETPD\n.TUEXPD#   ANOP\n           DC  X'0022,0001,0005'\n&NM.EXPDT  DC  CL5'&EXPDT'              EXPDT\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURETPD   AIF ('&RETPD' EQ '').TUDUMMY\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURETP#\n           DS  XL6\n&NM.RETPD  DS  AL2                      RETPD\n           AGO .TUDUMMY\n.TURETP#   ANOP\n           DC  X'0023,0001,0002'\n&NM.RETPD  DC  AL2(&RETPD)              RETPD\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUDUMMY   AIF ('&DUMMY' EQ '').TUFCBIM\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUDUMM#\n&NM.DUMMY  DS  XL4                      DD DUMMY / DSN=NULLFILE\n           AGO .TUFCBIM\n.TUDUMM#   ANOP\n&NM.DUMMY  DC  X'0024,0000'             DD DUMMY / DSN=NULLFILE\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUFCBIM   AIF ('&FCBIM' EQ '').TUFCBAV\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUFCBI#\n           DS  XL6\n&NM.FCBIM  DS  CL4                      FCB\n           AGO .TUFCBAV\n.TUFCBI#   ANOP\n           DC  X'0025,0001,0004'\n&NM.FCBIM  DC  CL4'&FCBIM'              FCB\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUFCBAV   AIF ('&FCBAV' EQ '').TUQNAME\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUFCBA#\n&NM.FCBAV  DS  XL7                      FCB VERIFY OR ALIGN\n           AGO .TUQNAME\n.TUFCBA#   AIF ('&FCBAV' NE 'VERIFY').TUFCBA2\n&NM.FCBAV  DC  X'0026,0001,0001,04'     FCB VERIFY\n           AGO .TUQNAME\n.TUFCBA2   AIF ('&FCBAV' NE 'ALIGN').TUQNAME\n&NM.FCBAV  DC  X'0026,0001,0001,08'     FCB ALIGN\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUQNAME   AIF ('&QNAME' EQ '').TUTERM\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUTERM    AIF ('&TERM' EQ '').TUUCS\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUTERMA\n&NM.TERM   DS  XL4                      TERM=TS / DSN(*)\n           AGO .TUUCS\n.TUTERMA   ANOP\n&NM.TERM   DC  X'0028,0000'             TERM=TS / DSN(*)\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUUCS     AIF ('&UCS' EQ '').TUUFOLD\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUUCSA\n           DS  XL6\n&NM.UCS    DS  CL4                      UCS CHARACTER SET\n           AGO .TUUFOLD\n.TUUCSA    ANOP\n           DC  X'0029,0001,0004'\n&NM.UCS    DC  CL4'&UCS'                UCS CHARACTER SET\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUUFOLD   AIF ('&UFOLD' EQ '').TUUVRFY\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUUFOL#\n&NM.UFOLD  DS  XL4                      UCS FOLD\n           AGO .TUUVRFY\n.TUUFOL#   ANOP\n&NM.UFOLD  DC  X'002A,0000'             UCS FOLD\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUUVRFY   AIF ('&UVRFY' EQ '').TUDCBDS\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUUVRF#\n&NM.UVRFY  DS  XL4                      UCS VERIFY\n           AGO .TUDCBDS\n.TUUVRF#   ANOP\n&NM.UVRFY  DC  X'002B,0000'             UCS VERIFY\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUDCBDS   AIF ('&DCBDS' EQ '').TUDCBDD\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUDCBS#\n           DS  XL6\n&NM.DCBDS  DS  CL44                     DCB REFERENCE TO DSN\n           AGO .TUDCBDD\n.TUDCBS#   ANOP\n           DC  X'002C,0001,0003'        DCB REFERENCE TO DSN (BELOW)\n&NM.DCBDS  DC  CL44'&DCBDS'\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUDCBDD   AIF ('&DCBDD' EQ '').TUSUSER\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUDCBD#\n           DS  XL6\n&NM.DCBDD  DS  CL8                      DCB REFERENCE TO DDNAME\n           AGO .TUSUSER\n.TUDCBD#   ANOP\n           DC  X'002D,0001,0008'\n&NM.DCBDD  DC  CL8'&DCBDD'              DCB REFERENCE TO DDNAME\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUSUSER   AIF ('&SUSER' EQ '').TUSHOLD\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUSUSE#\n           DS  XL6\n&NM.SUSER  DS  CL8                      SYSOUT DESTINATION\n           AGO .TUSHOLD\n.TUSUSE#   ANOP\n           DC  X'0058,0001,0008'\n&NM.SUSER  DC  CL8'&SUSER'              SYSOUT DESTINATION\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUSHOLD   AIF ('&SHOLD' EQ '').TUMSVGP\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUSHOL#\n&NM.SHOLD  DS  XL4                      SYSOUT HOLD=YES\n           AGO .TUMSVGP\n.TUSHOL#   ANOP\n&NM.SHOLD  DC  X'0059,0000'             SYSOUT HOLD=YES\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUMSVGP   AIF ('&MSVGP' EQ '').TUSSNM\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUSSNM    AIF ('&SSNM' EQ '').TUSSPRM\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUSSPRM   AIF ('&SSPRM' EQ '').TUPROT\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUPROT    AIF ('&PROT' EQ '').TUBFALN\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.*\n.*********************************************************************\n.***          DCB ATTRIBUTE TEXT UNITS - VERB CODE 01              ***\n.*********************************************************************\n.*\n.TUBFALN   AIF ('&BFALN' EQ '').TUBFTEK\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUBFAL#\n&NM.BFALN  DS  XL7                      BFALN\n           AGO .TUBFTEK\n.TUBFAL#   AIF ('&BFALN' NE 'F').TUBFAL2\n&NM.BFALN  DC  X'002E,0001,0001,01'     BFALN=F\n           AGO .TUBFTEK\n.TUBFAL2   AIF ('&BFALN' NE 'D').TUBFTEK\n&NM.BFALN  DC  X'002E,0001,0001,02'     BFALN=D\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUBFTEK   AIF ('&BFTEK' EQ '').TUBLKSZ\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUBFTE#\n&NM.BFTEK  DS  XL7                      BFTEK\n           AGO .TUBLKSZ\n.TUBFTE#   AIF ('&BFTEK' NE 'D').TUBFTE2\n&NM.BFTEK  DC  X'002F,0001,0001,08'     BFTEK=D\n           AGO .TUBLKSZ\n.TUBFTE2   AIF ('&BFTEK' NE 'E').TUBFTE3\n&NM.BFTEK  DC  X'002F,0001,0001,10'     BFTEK=E\n           AGO .TUBLKSZ\n.TUBFTE3   AIF ('&BFTEK' NE 'R').TUBFTE4\n&NM.BFTEK  DC  X'002F,0001,0001,20'     BFTEK=R\n           AGO .TUBLKSZ\n.TUBFTE4   AIF ('&BFTEK' NE 'S').TUBFTE5\n&NM.BFTEK  DC  X'002F,0001,0001,40'     BFTEK=S\n           AGO .TUBLKSZ\n.TUBFTE5   AIF ('&BFTEK' NE 'A').TUBLKSZ\n&NM.BFTEK  DC  X'002F,0001,0001,60'     BFTEK=A\n           AGO .TUBLKSZ\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUBLKSZ   AIF ('&BLKSZ' EQ '').TUBUFIN\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUBLKS#\n           DS  XL6\n&NM.BLKSZ  DS  AL2                      BLKSIZE\n           AGO .TUBUFIN\n.TUBLKS#   ANOP\n           DC  X'0030,0001,0002'\n&NM.BLKSZ  DC  AL2(&BLKSZ)              BLKSIZE\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUBUFIN   AIF ('&BUFIN' EQ '').TUBUFL\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUBUFI#\n           DS  XL6\n&NM.BUFIN  DS  AL1                      BUFIN\n           AGO .TUBUFL\n.TUBUFI#   ANOP\n           DC  X'0031,0001,0001'\n&NM.BUFIN  DC  AL1(&BUFIN)              BUFIN\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUBUFL    AIF ('&BUFL' EQ '').TUBUFMX\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUBUFLA\n           DS  XL6\n&NM.BUFL   DC  AL2                      BUFL\n           AGO .TUBUFMX\n.TUBUFLA   ANOP\n           DC  X'0032,0001,0002'\n&NM.BUFL   DC  AL2(&BUFL)               BUFL\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUBUFMX   AIF ('&BUFMX' EQ '').TUBUFNO\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUBUFM#\n           DS  XL6\n&NM.BUFMX  DS  AL1                      BUFMAX\n           AGO .TUBUFNO\n.TUBUFM#   ANOP\n           DC  X'0033,0001,0001'\n&NM.BUFMX  DC  AL1(&BUFMX)              BUFMAX\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUBUFNO   AIF ('&BUFNO' EQ '').TUBUFOF\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUBUFN#\n           DS  XL6\n&NM.BUFNO  DC  AL1                      BUFNO\n           AGO .TUBUFOF\n.TUBUFN#   ANOP\n           DC  X'0034,0001,0001'\n&NM.BUFNO  DC  AL1(&BUFNO)              BUFNO\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUBUFOF   AIF ('&BUFOF' EQ '').TUBUFOU\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&BUFOF' NE 'L').TUBUFO2\n           AIF ('&MAP' NE 'ONLY').TUBUFF#\n&NM.BUFOF  DS  XL7                      BUFOFF=L\n           AGO .TUBUFOU\n.TUBUFF#   ANOP\n&NM.BUFOF  DC  X'0035,0001,0001,80'     BUFOFF=L\n           AGO .TUBUFOU\n.TUBUFO2   ANOP\n           AIF ('&MAP' NE 'ONLY').TUBUF##\n           DS  XL6\n&NM.BUFOF  DS  AL1                      BUFOFF\n           AGO .TUBUFOU\n.TUBUF##   ANOP\n           DC  X'0035,0001,0001'\n&NM.BUFOF  DC  AL1(&BUFOF)              BUFOFF\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUBUFOU   AIF ('&BUFOU' EQ '').TUBUFRQ\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUBUFO#\n           DS  XL6\n&NM.BUFOU  DS  AL1                      BUFOUT\n           AGO .TUBUFRQ\n.TUBUFO#   ANOP\n           DC  X'0036,0001,0001'\n&NM.BUFOU  DC  AL1(&BUFOU)              BUFOUT\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUBUFRQ   AIF ('&BUFRQ' EQ '').TUBUFSZ\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUBUFR#\n           DS  XL6\n&NM.BUFRQ  DS  AL1                      BUFRQ\n           AGO .TUBUFSZ\n.TUBUFR#   ANOP\n           DC  X'0037,0001,0001'\n&NM.BUFRQ  DC  AL1(&BUFRQ)              BUFRQ\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUBUFSZ   AIF ('&BUFSZ' EQ '').TUCODE\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUBUFS#\n           DS  XL6\n&NM.BUFSZ  DS  AL2                      BUFSIZE\n           AGO .TUCODE\n.TUBUFS#   ANOP\n           DC  X'0038,0001,0002'\n&NM.BUFSZ  DC  AL2(&BUFSZ)              BUFSIZE\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUCODE    AIF ('&CODE' EQ '').TUCPRI\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUCPRI    AIF ('&CPRI' EQ '').TUDEN\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUDEN     AIF ('&DEN' EQ '').TUDSORG\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUDENA\n&NM.DEN    DS  XL7                      DEN\n           AGO .TUDSORG\n.TUDENA    AIF ('&DEN' NE '0').TUDE2\n&NM.DEN    DC  X'003B,0001,0001,03'     DEN=0  (200 BPI, 7-TRACK)\n           AGO .TUDSORG\n.TUDE2     AIF ('&DEN' NE '1').TUDE3\n&NM.DEN    DC  X'003B,0001,0001,43'     DEN=1  (556 BPI, 7-TRACK)\n           AGO .TUDSORG\n.TUDE3     AIF ('&DEN' NE '2').TUDE4\n&NM.DEN    DC  X'003B,0001,0001,83'     DEN=2  (800 BPI, 7/9-TRACK)\n           AGO .TUDSORG\n.TUDE4     AIF ('&DEN' NE '3').TUDE5\n&NM.DEN    DC  X'003B,0001,0001,C3'     DEN=3  (1600 BPI, 9-TRACK)\n           AGO .TUDSORG\n.TUDE5     AIF ('&DEN' NE '4').TUDSORG\n&NM.DEN    DC  X'003B,0001,0001,D3'     DEN=4  (6250 BPI, 9-TRACK)\n           AGO .TUDSORG\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUDSORG   AIF ('&DSORG' EQ '').TUEROPT\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUDSOR#\n&NM.DSORG  DS  XL8                      DSORG\n           AGO .TUEROPT\n.TUDSOR#   AIF ('&DSORG' NE 'VS').TUDSOR2\n&NM.DSORG  DC  X'003C,0001,0002,0008'   DSORG=VS\n           AGO .TUEROPT\n.TUDSOR2   AIF ('&DSORG' NE 'TQ').TUDSOR3\n&NM.DSORG  DC  X'003C,0001,0002,0020'   DSORG=TQ\n           AGO .TUEROPT\n.TUDSOR3   AIF ('&DSORG' NE 'TX').TUDSOR4\n&NM.DSORG  DC  X'003C,0001,0002,0040'   DSORG=TX\n           AGO .TUEROPT\n.TUDSOR4   AIF ('&DSORG' NE 'GS').TUDSOR5\n&NM.DSORG  DC  X'003C,0001,0002,0080'   DSORG=GS\n           AGO .TUEROPT\n.TUDSOR5   AIF ('&DSORG' NE 'PO').TUDSOR6\n&NM.DSORG  DC  X'003C,0001,0002,0200'   DSORG=PO\n           AGO .TUEROPT\n.TUDSOR6   AIF ('&DSORG' NE 'POU').TUDSOR7\n&NM.DSORG  DC  X'003C,0001,0002,0300'   DSORG=POU\n           AGO .TUEROPT\n.TUDSOR7   AIF ('&DSORG' NE 'MQ').TUDSOR8\n&NM.DSORG  DC  X'003C,0001,0002,0400'   DSORG=MQ\n           AGO .TUEROPT\n.TUDSOR8   AIF ('&DSORG' NE 'CQ').TUDSOR9\n&NM.DSORG  DC  X'003C,0001,0002,0800'   DSORG=CQ\n           AGO .TUEROPT\n.TUDSOR9   AIF ('&DSORG' NE 'CX').TUDSORA\n&NM.DSORG  DC  X'003C,0001,0002,1000'   DSORG=CX\n           AGO .TUEROPT\n.TUDSORA   AIF ('&DSORG' NE 'DA').TUDSORB\n&NM.DSORG  DC  X'003C,0001,0002,2000'   DSORG=DA\n           AGO .TUEROPT\n.TUDSORB   AIF ('&DSORG' NE 'DAU').TUDSORC\n&NM.DSORG  DC  X'003C,0001,0002,2100'   DSORG=DAU\n           AGO .TUEROPT\n.TUDSORC   AIF ('&DSORG' NE 'PS').TUDSORD\n&NM.DSORG  DC  X'003C,0001,0002,4000'   DSORG=PS\n           AGO .TUEROPT\n.TUDSORD   AIF ('&DSORG' NE 'PSU').TUEROPT\n&NM.DSORG  DC  X'003C,0001,0002,4100'   DSORG=PSU\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUEROPT   AIF ('&EROPT' EQ '').TUGNCP\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUEROP#\n&NM.EROPT  DS  XL7                      EROPT\n           AGO .TUGNCP\n.TUEROP#   AIF ('&EROPT' NE 'T').TUEROP2\n&NM.EROPT  DC  X'003D,0001,0001,10'     EROPT=T\n           AGO .TUGNCP\n.TUEROP2   AIF ('&EROPT' NE 'ABE').TUEROP3\n&NM.EROPT  DC  X'003D,0001,0001,20'     EROPT=ABE\n           AGO .TUGNCP\n.TUEROP3   AIF ('&EROPT' NE 'SKP').TUEROP4\n&NM.EROPT  DC  X'003D,0001,0001,40'     EROPT=SKP\n           AGO .TUGNCP\n.TUEROP4   AIF ('&EROPT' NE 'ACC').TUGNCP\n&NM.EROPT  DC  X'003D,0001,0001,80'     EROPT=ACC\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUGNCP    AIF ('&GNCP' EQ '').TUINTVL\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUGNCPA\n           DS  XL6\n&NM.GNCP   DC  AL1                      GNCP\n           AGO .TUINTVL\n.TUGNCPA   ANOP\n           DC  X'003E,0001,0001'\n&NM.GNCP   DC  AL1(&GNCP)               GNCP\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUINTVL   AIF ('&INTVL' EQ '').TUKYLEN\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUKYLEN   AIF ('&KYLEN' EQ '').TULIMCT\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUKYLE#\n           DS  XL6\n&NM.KYLEN  DS  AL1                      KEYLEN\n           AGO .TULIMCT\n.TUKYLE#   ANOP\n           DC  X'0040,0001,0001'\n&NM.KYLEN  DC  AL1(&KYLEN)              KEYLEN\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TULIMCT   AIF ('&LIMCT' EQ '').TULRECL\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TULRECL   AIF ('&LRECL' EQ '').TUMODE\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TULREC#\n           DS  XL6\n&NM.LRECL  DS  AL2                      LRECL\n           AGO .TUMODE\n.TULREC#   ANOP\n           DC  X'0042,0001,0002'\n&NM.LRECL  DC  AL2(&LRECL)              LRECL\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUMODE    AIF ('&MODE' EQ '').TUNCP\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUNCP     AIF ('&NCP' EQ '').TUOPTCD\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUNCPA\n           DS  XL6\n&NM.NCP    DS  AL1                      NCP\n           AGO .TUOPTCD\n.TUNCPA    ANOP\n           DC  X'0044,0001,0001'\n&NM.NCP    DC  AL1(&NCP)                NCP\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUOPTCD   AIF ('&OPTCD' EQ '').TUPCIR\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUOPTC#\n&NM.OPTCD  DS  XL7                      OPTCD\n           AGO .TUPCIR\n.TUOPTC#   AIF ('&OPTCD' NE 'W').TUPCIR\n&NM.OPTCD  DC  X'0045,0001,0001,80'     OPTCD=W\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUPCIR    AIF ('&PCIR' EQ '').TUPCIS\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUPCIS    AIF ('&PCIS' EQ '').TUPRTSP\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUPRTSP   AIF ('&PRTSP' EQ '').TURECFM\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUPRTS#\n&NM.PRTSP  DS  XL7                      PRTSP\n           AGO .TURECFM\n.TUPRTS#   AIF ('&PRTSP' NE '0').TUPRTS2\n&NM.PRTSP  DC  X'0048,0001,0001,01'     PRTSP=0\n           AGO .TURECFM\n.TUPRTS2   AIF ('&PRTSP' NE '1').TUPRTS3\n&NM.PRTSP  DC  X'0048,0001,0001,09'     PRTSP=1\n           AGO .TURECFM\n.TUPRTS3   AIF ('&PRTSP' NE '2').TUPRTS4\n&NM.PRTSP  DC  X'0048,0001,0001,11'     PRTSP=2\n           AGO .TURECFM\n.TUPRTS4   AIF ('&PRTSP' NE '3').TURECFM\n&NM.PRTSP  DC  X'0048,0001,0001,19'     PRTSP=3\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURECFM   AIF ('&RECFM' EQ '').TURSRVF\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURECF#\n&NM.RECFM  DS  XL7                      RECFM=F\n           AGO .TURSRVF\n.TURECF#   AIF ('&RECFM' NE 'F').TURECF2\n&NM.RECFM  DC  X'0049,0001,0001,80'     RECFM=F\n           AGO .TURSRVF\n.TURECF2   AIF ('&RECFM' NE 'FA').TURECF3\n&NM.RECFM  DC  X'0049,0001,0001,84'     RECFM=FA\n           AGO .TURSRVF\n.TURECF3   AIF ('&RECFM' NE 'FB').TURECF4\n&NM.RECFM  DC  X'0049,0001,0001,90'     RECFM=FB\n           AGO .TURSRVF\n.TURECF4   AIF ('&RECFM' NE 'FBA').TURECF5\n&NM.RECFM  DC  X'0049,0001,0001,94'     RECFM=FBA\n           AGO .TURSRVF\n.TURECF5   AIF ('&RECFM' NE 'V').TURECF6\n&NM.RECFM  DC  X'0049,0001,0001,40'     RECFM=V\n           AGO .TURSRVF\n.TURECF6   AIF ('&RECFM' NE 'VB').TURECF7\n&NM.RECFM  DC  X'0049,0001,0001,50'     RECFM=VB\n           AGO .TURSRVF\n.TURECF7   AIF ('&RECFM' NE 'U').TURSRVF\n&NM.RECFM  DC  X'0049,0001,0001,C0'     RECFM=U\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURSRVF   AIF ('&RSRVF' EQ '').TURSRVS\n.TURSRVS   AIF ('&RSRVS' EQ '').TUSOWA\n.TUSOWA    AIF ('&SOWA' EQ '').TUSTACK\n.TUSTACK   AIF ('&STACK' EQ '').TUTHRSH\n.TUTHRSH   AIF ('&THRSH' EQ '').TUTRTCH\n.TUTRTCH   AIF ('&TRTCH' EQ '').TUIPLTX\n.TUIPLTX   AIF ('&IPLTX' EQ '').TUDIAGN\n.TUDIAGN   AIF ('&DIAGN' EQ '').TUFUNC\n.TUFUNC    AIF ('&FUNC' EQ '').TUFRID\n.TUFRID    AIF ('&FRID' EQ '').TUPASSW\n.*\n.*********************************************************************\n.***       NON-JCL DYNAMIC ALLOCATION FUNCTIONS - VERB CODE 01     ***\n.*********************************************************************\n.*\n.TUPASSW   AIF ('&PASSW' EQ '').TUPERMA\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUPERMA   AIF ('&PERMA' EQ '').TUCNVRT\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUPERM#\n&NM.PERMA  DS  XL4                      PERMANENT ALLOCATION\n           AGO .TUCNVRT\n.TUPERM#   ANOP\n&NM.PERMA  DC  X'0052,0000'             PERMANENT ALLOCATION\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUCNVRT   AIF ('&CNVRT' EQ '').TURTDDN\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUCNVR#\n&NM.CNVRT  DS  XL4                      CONVERTABLE ALLOCATION\n           AGO .TURTDDN\n.TUCNVR#   ANOP\n&NM.CNVRT  DC  X'0053,0000'             CONVERTABLE ALLOCATION\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURTDDN   AIF ('&RTDDN' EQ '').TURTDSN\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURTDD#\n           DS  XL4\n           DS  XL2                      LEN OF RETURNED DDNAME\n&NM.RTDDN  DS  CL8                      RETURNED DDNAME\n           AGO .TURTDSN\n.TURTDD#   ANOP\n           DC  X'0055,0001'\n           DC  XL2'0008'                LEN OF RETURNED DDNAME\n&NM.RTDDN  DC  CL8' '                   RETURNED DDNAME\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURTDSN   AIF ('&RTDSN' EQ '').TURTORG\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURTDS#\n           DS  XL4\n           DS  AL2                      LEN OF RETURNED DSNAME\n&NM.RTDSN  DS  CL44                     RETURNED DSNAME\n           AGO .TURTORG\n.TURTDS#   ANOP\n           DC  X'0056,0001'\n           DC  AL2(44)                  LEN OF RETURNED DSNAME\n&NM.RTDSN  DC  CL44' '                  RETURNED DSNAME\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURTORG   AIF ('&RTORG' EQ '').TURTVOL\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURTOR#\n           DS  XL6\n&NM.RTORG  DS  XL2                      RETURNED DSORG\n           AGO .TURTVOL\n.TURTOR#   DC  X'0057,0001,0002'\n&NM.RTORG  DC  XL2'0000'                RETURNED DSORG\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURTVOL   AIF ('&RTVOL' EQ '').TUREMOV\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURTVO#\n           DS  XL4\n           DS  XL2                      LEN OF RETURNED VOLSER\n&NM.RTVOL  DS  CL6                      RETURNED VOLSER\n           AGO .TUREMOV\n.TURTVO#   ANOP\n           DC  X'005D,0001'\n           DC  XL2'0006'                LEN OF RETURNED VOLSER\n&NM.RTVOL  DC  CL6' '                   RETURNED VOLSER\n.*\n.*********************************************************************\n.***       UNALLOCATE - VERB CODE 02                               ***\n.*********************************************************************\n.*\n.TUREMOV   AIF ('&REMOV' EQ '').TUUNALC\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUREMO#\n&NM.REMOV  DS  XL4                      REMOVE INUSE EVEN IF PERMANENT\n           AGO .TUUNALC\n.TUREMO#   ANOP\n&NM.REMOV  DC  X'0008,0000'             REMOVE INUSE EVEN IF PERMANENT\n.*\n.TUUNALC   AIF ('&UNALC' EQ '').TUTCBAD\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUUNAL#\n&NM.UNALC  DS  XL4                      UNALLOCATE EVEN IF PERMANENT\n           AGO .TUTCBAD\n.TUUNAL#   ANOP\n&NM.UNALC  DC  X'0007,0000'             UNALLOCATE EVEN IF PERMANENT\n.*\n.*********************************************************************\n.***       REMOVE IN-USE ATTRIBUTE - VERB CODE 05                  ***\n.*********************************************************************\n.*\n.TUTCBAD   AIF ('&TCBAD' EQ '').TUINDDN\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUTCBA#\n           DS  XL6\n&NM.TCBAD  DS  XL4                      TCB ADDRESS\n           AGO .TUINDDN\n.TUTCBA#   ANOP\n           DC  X'0001,0001,0004'\n&NM.TCBAD  DS  XL4                      TCB ADDRESS\n.*\n.*********************************************************************\n.***       RETURN INFORMATION - VERB CODE 07                       ***\n.*********************************************************************\n.*\n.TUINDDN   AIF ('&INDDN' EQ '').TUINDSN\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUINDD#\n           DS  XL4\n           DS  XL2                      LEN OF RETURNED DDNAME\n&NM.INDDN  DS  CL8                      RETURNED DDNAME\n           AGO .TUINDSN\n.TUINDD#   ANOP\n           DC  X'0004,0001'\n           DC  XL2'0008'                LEN OF RETURNED DDNAME\n&NM.INDDN  DC  CL8' '                   RETURNED DDNAME\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUINDSN   AIF ('&INDSN' EQ '').TUINORG\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUINDS#\n           DS  XL4\n           DS  AL2                      LEN OF RETURNED DSNAME\n&NM.INDSN  DS  CL44                     RETURNED DSNAME\n           AGO .TUINORG\n.TUINDS#   ANOP\n           DC  X'0005,0001'\n           DC  AL2(44)                  LEN OF RETURNED DSNAME\n&NM.INDSN  DC  CL44' '                  RETURNED DSNAME\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUINORG   AIF ('&INORG' EQ '').TURTMEM\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TUINOR#\n           DS  XL6\n&NM.INORG  DS  XL2                      RETURNED DSORG\n           AGO .TURTMEM\n.TUINOR#   DC  X'000A,0001,0002'\n&NM.INORG  DC  XL2'0000'                RETURNED DSORG\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURTMEM   AIF ('&RTMEM' EQ '').TURTSTA\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURTME#\n           DS  XL6\n&NM.RTMEM  DS  CL8                      RETURNED MEMBER NAME\n           AGO .TURTSTA\n.TURTME#   ANOP\n           DC  X'0006,0001,0008'\n&NM.RTMEM  DC  CL8' '                   RETURNED MEMBER NAME\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURTSTA   AIF ('&RTSTA' EQ '').TURTNDP\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURTST#\n           DS  XL6\n&NM.RTSTA  DS  XL1                      RETURNED DATASET STATUS\n           AGO .TURTNDP\n.TURTST#   ANOP\n           DC  X'0007,0001,0001'\n&NM.RTSTA  DS  XL1'00'                  RETURNED DATASET STATUS\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURTNDP   AIF ('&RTNDP' EQ '').TURTCDP\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURTND#\n           DS  XL6\n&NM.RTNDP  DS  XL1                      RETURNED NORMAL DISP\n           AGO .TURTCDP\n.TURTND#   ANOP\n           DC  X'0008,0001,0001'\n&NM.RTNDP  DS  XL1'00'                  RETURNED NORMAL DISP\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURTCDP   AIF ('&RTCDP' EQ '').TURTLIM\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURTCD#\n           DS  XL6\n&NM.RTCDP  DS  XL1                      RETURNED CONDITIONAL DISP\n           AGO .TURTLIM\n.TURTCD#   ANOP\n           DC  X'0009,0001,0001'\n&NM.RTCDP  DS  XL1'00'                  RETURNED CONDITIONAL DISP\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURTLIM   AIF ('&RTLIM' EQ '').TURTATT\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURTLI#\n           DS  XL6\n&NM.RTLIM  DS  XL2                      RETURNED LIMIT SPECIFICATION\n           AGO .TURTATT\n.TURTLI#   ANOP\n           DC  X'000B,0001,0002'\n&NM.RTLIM  DS  XL2'0000'                RETURNED LIMIT SPECIFICATION\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURTATT   AIF ('&RTATT' EQ '').TURTLST\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURTAT#\n           DS  XL6\n&NM.RTATT  DS  XL1                      RETURNED D.A. ATTRIBUTE\n           AGO .TURTLST\n.TURTAT#   ANOP\n           DC  X'000C,0001,0001'\n&NM.RTATT  DS  XL1'00'                  RETURNED D.A. ATTRIBUTE\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURTLST   AIF ('&RTLST' EQ '').TURTTYP\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURTLS#\n           DS  XL6\n&NM.RTLST  DS  XL1                      RETURNED LAST ENTRY SPEC.\n           AGO .TURTTYP\n.TURTLS#   ANOP\n           DC  X'000D,0001,0001'\n&NM.RTLST  DS  XL1'00'                  RETURNED LAST ENTRY SPEC.\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURTTYP   AIF ('&RTTYP' EQ '').TURELNO\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURTTY#\n           DS  XL6\n&NM.RTTYP  DS  XL1                      RETURNED DATASET TYPE\n           AGO .TURELNO\n.TURTTY#   ANOP\n           DC  X'000E,0001,0001'\n&NM.RTTYP  DS  XL1'00'                  RETURNED DATASET TYPE\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TURELNO   AIF ('&RELNO' EQ '').TUENDM\n&TUPLEN    SETA &TUPLEN+1\n           AIF ('&MAP' NE 'ONLY').TURELN#\n           DS  XL6\n&NM.RELNO  DS  XL2                      RETURNED RELATIVE REQUEST NO.\n           AGO .TUENDM\n.TURELN#   ANOP\n           DC  X'000F,0001,0002'\n&NM.RELNO  DS  XL2'0000'                RETURNED RELATIVE REQUEST NO.\n.*\n.*********************************************************************\n.***       MARK END OF LIST OF TEXT UNITS                          ***\n.*********************************************************************\n.*\n.TUENDM    AIF ('&MAP' NE 'ONLY').TUENDU#\n           DS  XL1                      END OF LIST MARKER\n           AGO .TUEND\n.TUENDU#   ANOP\n           DC  X'FF'                    END OF LIST MARKER\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.TUEND     ANOP\n.*\n**********************************************************************\n***        REQUEST BLOCKS FOR SVC99                                ***\n**********************************************************************\n*\n&NM.RBP    DS  A                        POINTER TO REQUEST BLOCK\n&NM.RB     DS  5A                       REQUEST BLOCK\n&NM.TUPL   DS  &TUPLEN.A                TEXT UNIT POINTER LIST\n*\n**********************************************************************\n***        DAIRFAIL PARAMETER BLOCK & MISCELLANEOUS STORAGE        ***\n**********************************************************************\n*\n&NM.DFPRM  DS  6F                       PARM BLOCK FOR IKJEFF18\n*\n&NM.S99RC  DS  F                        STORAGE AREA FOR SVC 99 R/C\n           AIF ('&MAP' NE 'ONLY').DF2\n&NM.F02EP  DS  F                        STORGE AREA FOR EP OF IKJEFF18\n&NM.ID     DS  XL2                      DAIRFAIL SWITCHES & CALLER ID\n           AGO .DF3\n.DF2       ANOP\n&NM.F02EP  DC  F'0'                     STORGE AREA FOR EP OF IKJEFF18\n&NM.ID     DC  X'0032'                  DAIRFAIL SWITCHES & CALLER ID\n.DF3       ANOP\n*\n**********************************************************************\n***        EQUATE FOR TOTAL LENGTH                                 ***\n**********************************************************************\n*\n           DS  0D                       ALIGN FOR GETMAIN\n&NM.LEN    EQU *-&NM                    TOTAL LENGTH\n           MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GTEDADOC": {"ttr": 1287, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   GTEDADOC\n*\n*  +----------------------------------------------------------------+\n*  |  This is an explanation of the GTE Dynamic Allocation macros.  |\n*  |                                                                |\n*  |         Chuck Hoffman                                          |\n*  |         Systems Programming                                    |\n*  |         GTE Laboratories - Technical Computation Center        |\n*  |         40 Sylvan Road                                         |\n*  |         Waltham, MA  02254                                     |\n*  |                               617/466-2131  v/n 679-2131       |\n*  +----------------------------------------------------------------+\n*\n* PURPOSE:\n*     DAIR/IKJDAIR is now being maintained only for compatability with\n* older programs.  IBM states that all new applications should be\n* written using SVC-99 rather than DAIR.  The purpose of these macros\n* is to make the use of SVC-99 and IKJEFF18 (DAIRFAIL messages) easy\n* from assembler programs.\n*\n* REFERENCE:\n*     The user of these routines should have available the IBM manual:\n* 'GC28-0627, OS/VS2 MVS Systems Programming Library:  Job Management'\n* which describes SVC-99.  A detailed knowledge of SVC-99 is not\n* necessary.\n*\n* FUNCTION:\n*     GTEDADAT - Allocates space at assembly time for control blocks.\n*                Generates literals and constants.\n*     GTEDASET - Initializes control blocks at exection time.\n*     GTEDAALC - Invokes SVC-99 and IKJEFF18.\n*\n*\n* GTEDADAT - creating control blocks.\n*\n* 1.  The name of the control blocks is limited to three characters,\n*     because it is used as a prefix for data items in the generated\n*     control blocks.\n*                okay:  ABC      GTEDADAT ...\n*                  no:  ABCD     GTEDADAT ...\n*\n* 2.  The use of MAP=ONLY will produce DS entries without initializing\n*     the contents of the blocks.\n*          DC entries:  ABC      GTEDADAT ...\n*          DS entries:  ABC      GTEDADAT MAP=ONLY,...\n*\n* 3.  The names of text unit operands are the same as those used in the\n*     'Job Management' manual.  For instance, DSNAM and DDNAM rather\n*     than DSNAME and DDNAME.  By limiting operands to five characters,\n*     labels can be created using the 3-character block name as a\n*     prefix, followed by the 5-character (max) operand name.  The\n*     dataset name in the example in 2, above, would be labeled\n*     ABCDSNAM.\n*           -------------------------------------------------\n*           ---  There is one exception because IBM uses  ---\n*           ---  the same last 5 characters for infor-    ---\n*           ---  mation retrieval with two different      ---\n*           ---  SVC-99 verb codes.  If using the DSN     ---\n*           ---  Allocation SVC-99 verb (X'01') use the   ---\n*           ---  IBM names on the left.  If using the     ---\n*           ---  Information Retrieval SVC-99 verb (X'07')---\n*           ---  use the GTE names on the right:          ---\n*           ---                                           ---\n*           ---     DSN Alloc.        Info. Retrieval     ---\n*           ---       RTDDN              INDDN            ---\n*           ---       RTDSN              INDSN            ---\n*           ---       RTORG              INORG            ---\n*           -------------------------------------------------\n*\n* 4.  Text unit operands come in three flavors (refer to 'Job\n*     Management')\n*\n*     A.  Those for which an explicit value is supplied, e.g. DDNAME.\n*\n*              code:  ADC      GTEDADAT DDNAM=FILEA\n*\n*         generated: +         DC     X'0001,0001,0008'\n*                    +ADCDDNAM DC     CL8'FILEA'\n*\n*     B.  Those which are either on or off:  e.g. Space type TRK\n*\n*              code:  ADC      GTEDADAT DDNAM=FILEA,TRK=YES\n*\n*         generated: +         DC     X'0001,0001,0008'\n*                    +ADCDDNAM DC     CL8'FILEA'\n*                    +ADCTRK   DC     X'0007,0000'\n*         ----------------------------------------------------------\n*         ---  Note.  Information retrieval is in this category. ---\n*         ----------------------------------------------------------\n*\n*     C.  Those for which there is a choice which can be coded,\n*         e.g. Dataset organization.\n*\n*              code:  ADC      GTEDADAT DDNAM=FILEA,TRK=YES,DSORG=PS\n*\n*         generated: +         DC     X'0001,0001,0008'\n*                    +ADCDDNAM DC     CL8'FILEA'\n*                    +ADCTRK   DC     X'0007,0000'\n*                    +ADCDSORG DC     X'003C,0001,0002,4000'\n*\n*   NOTE 1. -\n*     Each operand generates a text unit which begins with a two-byte\n*     key.  Each operand generates a label.  The label may be at the\n*     key, as in ADCTRK and ADCDSORG, above, or it may be at the\n*     literal, as in ADCDDNAM, above.  Location of the label is based\n*     on a best guess of anticipated use of that text unit.\n*\n*   NOTE 2. -\n*     Setting a key value to X'0000' will cause SVC-99 to ignore that\n*     text unit.  After executing GTEDASET which builds a list of\n*     pointers to the text units, values in the text units can be\n*     changed at will.\n*\n*   NOTE 3. -\n*     At this time, not all operands generate executable code, and\n*     those which do may be in error.  If you discover errors or need\n*     new functions, call Systems Programming.\n*\n*\n* GTEDASET - setting addresses in control blocks\n*\n* 1.  This macro needs to be executed once before the GTEDAALC macro\n*     executes.  It simply links together the control blocks generated\n*     by GTEDADAT.  After this macro has been executed, there is no\n*     problem changing values in the control blocks.\n*\n* 2.  The CPPLPTR operand is the name of a fullword.  If the program is\n*     a TSO Command Processor, the fullword must contain the address of\n*     the Command Processor Parameter List (CPPL).  If the program is\n*     not a Command Processor, the fullword should contain the address\n*     of a fake CPPL, or ERRMSG=NO should be coded in the GTEDAALC\n*     macro (below).\n*\n*\n* GTEDAALC - executing SVC-99 and IKJEFF18\n*\n* 1.  This macro is executed once each time you want SVC-99 to\n*     execute.\n*\n* 2.  The choice of VERB= are as follows.  Again, keywords correspond\n*     to names in the 'Job Management' manual.\n*       VERB=AL  dsn allocation        VERB=UN  dsn or ddn unallocation\n*       VERB=CC  concatenation         VERB=DC  deconcatenation\n*       VERB=RI  remove in-use         VERB=DN  ddn allocation\n*       VERB=IN  information retrieveal\n*\n*     Concatenation and deconcatenation aren't yet supported, but they\n*     will be.\n*\n* 3.  This macro has the ERRMSG=NO operand to suppress creating code to\n*     return the SVC-99 failure messages to the TSO terminal.  Use this\n*     operand when the CPPLPTR operand of the GTEDASET macro points to\n*     a fullword which does not contain the address of a CPPL.  When\n*     this operand is used, the SVC-99 return code and the error and\n*     info codes are still available to your program.  Only the writing\n*     of an error message to the terminal is suppressed.  E.g.:\n*\n*                         GTEDAALC  ADC,VERB=AL,ERRMSG=NO\n*\n*     Places the return and error/info codes in these areas:\n*\n*               +ADCS99RC DS     F        SVC-99 RETURN CODE\n*\n*               +ADCERROR DS     H        SVC-99 ERROR CODE\n*               +ADCINFO  DS     H        SVC-99 INFO CODE\n*\n*     The error and info codes are contiguous, and the error code is\n*     aligned on a fullword boundry.\n*\n*\n* MAPPING MACROS:\n*     The following mapping macros must appear in the source.  Base\n* registers do not need to be assigned.\n*\n*     IEFZB4D0                             Maps SVC-99 blocks\n*     IKJEFFDF DFDSECT=YES,DFDSEC2=YES     Maps IKJEFF18 control blocks\n* ---------------------------------------------------------------------\n         EJECT\n* ---------------------------------------------------------------------\n*                        *** EXAMPLE ***\n*\n* We want to allocate member CURVES of CAH0.PDS.DATA to file FT12F001,\n* and we want to allocate member SPLINE of the same dataset to file\n* FT14F001.  Dataset status should be SHR, and sequential organization\n* will be used.  Further, we want the program to be reenterable, so all\n* variable data will be located in storage obtained with GETMAIN.\n*\n* Choose operands for the GTEDADAT macro by reference to the 'Job\n* Management' manual.\n*\n*\n*\n*             PRINT NOGEN\n*    EXMPL1   LINKSAVE BASE=12,GETMAIN=YES           LINKAGE CNVNTNS\n*             LR    5,1                              HOLD CPPL ADDRESS\n*             GETMAIN R,LV=1024                      GET WORK STORAGE\n*             LR    11,1                             ADDRESSABILITY OF\n*             USING AREA1,11                           WORK STORAGE\n*              .       .\n*             ST    5,CPPLADDR                       SAVE CPPL ADDRESS\n*              .       .\n*              .       .\n*             MVC   XYZ(XYZLEN),ABC                  COPY TO WORK AREA\n*             GTEDASET XYZ,CPPLPTR=CPPLADDR          SET POINTERS\n*              .       .\n*              .       .\n*             GTEDAALC XYZ,VERB=AL                   ALLOCATE FT12F001\n*              .       .\n*              .       .\n*             MVC   XYZMEMBR,=C'SPLINE  '            CHANGE MEMBER NME\n*             MVC   XYZDDNAM,=C'FT14F001'            CHANGE FILE NAME\n*             GTEDAALC XYZ,VERB=AL                   ALLOCATE FT14F001\n*              .       .\n*              .       .\n*    ENDUP    FREEMAIN R,LV=1024,A=(11)              FREE STORAGE\n*             XR    15,15                            ZERO R/C\n*             LINKBACK                               LINKAGE CNVNTNS\n*              .       .\n*              .       .\n*              .       .\n*    ABC      GTEDADAT DSNAM=CAH0.PDS.DATA,MEMBR=CURVES,              X\n*                   DDNAM=FT12F001,STATS=SHR,CNVRT=YES\n*              .       .\n*              .       .\n*    AREA1    DSECT\n*    CPPLADDR DS    F\n*    XYZ      GTEDADAT MAP=ONLY,DSNAM=CAH0.PDS.DATA,MEMBR=CURVES,     X\n*                   DDNAM=FT12F001,STATS=SHR,CNVRT=YES\n*              .       .\n*              .       .\n*             IEFZB4D0\n*             IKJEFFDF DFDSECT=YES,DFDSEC2=YES\n*             END\n* ---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GTEDASET": {"ttr": 1292, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   GTEDASET &NM,&CPPLPTR=\n.*\n.*          +-----------------------------------------------+\n.*          |  See macro GTEDADOC for documentation of the  |\n.*          |  use of this and other GTEDAxxx macros.       |\n.*          +-----------------------------------------------+\n.*\n*\n**********************************************************************\n***   SET POINTERS AND DATA FOR DYNAMIC ALLOCATION IN DATA AREAS   ***\n***   CREATED BY MACRO GTEDADAT.                                   ***\n**********************************************************************\n*\n**********************************************************************\n***      PLACE ADDRESS OF S99RB INTO S99RBPTR.                     ***\n**********************************************************************\n*\n&LABEL   LA    1,&NM.RB                       ==> R1 POINTS TO S99RB\n         ST    1,&NM.RBP                          FILL IN S99RBPTR\n         OI    &NM.RBP,X'80'                      TURN ON HI BIT\n*\n**********************************************************************\n***      FILL IN S99RB REQUEST BLOCK.                              ***\n***      MAPPING MACRO IEFZB4D0 MUST APPEAR IN SOURCE.             ***\n**********************************************************************\n*\n         MVI   (S99RBLN-S99RB)(1),X'14'           FILL IN LENGTH\n         MVI   (S99VERB-S99RB)(1),X'00'           ZERO VERB CODE\n         XC    (S99FLAG1-S99RB)(4,1),(S99FLAG1-S99RB)(1)   ZERO FLAGS1\n         OI    (S99FLAG1-S99RB)(1),S99ONCNV       SET FLAGS1 OK CONVRT\n         OI    (S99FLAG1-S99RB)(1),S99NOMNT       SET FLAGS1 NO MOUNT\n         LA    2,&NM.TUPL                     ==> R2 POINTS TO TUPL\n         ST    2,(S99TXTPP-S99RB)(0,1)            TUPL ADDR INTO RB\n         XC    (S99FLAG2-S99RB)(4,1),(S99FLAG2-S99RB)(1)   ZERO FLAGS2\n*\n**********************************************************************\n***  BUILD TUPL.                                                   ***\n***  KEY OF LAST TEXT UNIT MUST BE X'FF..'                         ***\n**********************************************************************\n*\n         LA    1,&NM.TU                       ==> R1 POINTS TO TUNITS\n         XR    0,0                                CLEAR R0 FOR COUNTER\n         XR    15,15                              CLEAR R15 WORK REG\n*\nRBA&SYSNDX CLI (S99TUKEY-S99TUNIT)(1),X'FF'       IF KEY IS X'FF..'\n         BE    RBD&SYSNDX                           BRANCH OUT OF LOOP\n         ST    1,0(0,2)                           ADDR OF KEY TO TUPL\n         LA    2,4(0,2)                           INCR POINTER TO TUPL\n*\n         ICM   0,3,(S99TUNUM-S99TUNIT)(1)         TU NUM TO R0\n         LA    1,4(0,1)                           R1 POINTS BEYOND NUM\n         LTR   0,0                                IF TU NUM IS 0\n         BZ    RBA&SYSNDX                         PROCESS NEXT TU\n*\n         ICM   15,3,0(1)                          TU LEN TO R15\n         LA    1,2(15,1)                          PNT BEYND LEN & PARM\n         BCT   0,*-8                              DO FOR EACH LEN+PARM\n*\n         B     RBA&SYSNDX                         PROCESS NEXT TU\n*\nRBD&SYSNDX LA  15,4(0,0)                          POINT TO LAST\n         SR    2,15                                 TUPL ENTRY\n         OI    0(2),S99TUPLN                      MARK LAST TUPL ENTRY\n*\n**********************************************************************\n***  FILL IN THE DAIRFAIL PARAMETER BLOCK.                         ***\n***  IKJEFFDF DFDSECT=YES,DFDSEC2=YES MUST APPEAR IN SOURCE.       ***\n**********************************************************************\n*\n         MVC   &NM.DFPRM+(DFS99RBP-DFDSECTD)(4),&NM.RBP *PTR TO RB\n*\n         LA    1,&NM.S99RC\n         ST    1,&NM.DFPRM+(DFRCP-DFDSECTD)             *PTR TO S99RC\n*\n         LA    1,&NM.F02EP\n         ST    1,&NM.DFPRM+(DFJEFF02-DFDSECTD)          *PTR TO EP\n*\n         LA    1,&NM.ID\n         ST    1,&NM.DFPRM+(DFIDP-DFDSECTD)             *PTR TO SW+ID\n*\n         MVC   &NM.DFPRM+(DFCPPLP-DFDSECTD)(4),&CPPLPTR *PTR TO CPPL\n*\n         XC  &NM.DFPRM+(DFBUFP-DFDSECTD)(4),&NM.DFPRM+(DFBUFP-DFDSECTD)\n*                                                       *ZERO BUFF ADDR\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HELP": {"ttr": 1539, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ")F Function -\n     NEWSPACE is a command for easily creating new, moderately sized,\n     datasets and libraries.  It was written with beginners in mind.\n     (Larger or more complex datasets should be created with the\n     ALLOCATE and ATTRIB commands, or with the ISPF/PDF Dataset Utility\n     (Option 3.2))\n\n)X Syntax -\n\n     NEWSPACE  dataset-name  type  LIBRARY     FIXED\n     NEW                           SEQUENTIAL  VARIABLE\n                                               UNFORMATTED\n\n     ALIAS:     NEW\n     REQUIRED:  dataset-name\n     DEFAULTS:  1.  LIBRARY\n                2.  FIXED, VARIABLE or UNFORMATTED, depending on type\n                    or dataset-name.\n\n)O Operands -\n\n))dataset-name -\n    The name of the dataset to be created.  If single quotes (') are\n    placed around the name, it will be used as is.  If not, the TSO\n    user prefix will be added to the front of the name, and the dataset\n    'type', if used, will be added to the end.  For example, if your\n    user prefix is ABC0:\n\n            'ABC0.PROJECT.DATA'  will be used as is\n\n                       PROGRAM1  will have the user prefix and type\n                                 added to it.  If it is to contain\n                                 FORTRAN statements, the name would\n                                 become:  'ABC0.PROGRAM1.FORT'\n\n))type -\n    This designates the intended use of the dataset.  Datasets for\n    different uses have different internal characteristics.  You do not\n    have to specify 'type'.  'Types' recognized by NEWSPACE are:\n\n    ASM     - Assembler programs     LIST    - Program output listings\n  * CLIST   - TSO Command Lists      LOAD    - Executable load modules\n    CNTL    - Job Control Language   OBJ     - Compiler output (object)\n    COBOL   - COBOL programs         PLI     - PL/1 programs\n  * COMMAND - TSO Command Lists      PLIF    - PL/1(F) programs\n    DATA    - General Data           TEXT    - Text, especially SCRIPT\n    FORT    - FORTRAN programs       VSBASIC - IBM VS BASIC programs\n  _______\n  * CLIST and COMMAND are the same, except for different default\n    internal characteristics.  COMMAND type is used for personal CLISTs\n    which are to be used as if they are TSO commands.  See the FIXED\n    and VARIABLE operands, below.\n\n\n))SEQUENTIAL -\n    The dataset will be constructed to hold a single group of data,\n    such as one FORTRAN program, or one Memo.\n\n))LIBRARY (or PARTITIONED, or PDS) -\n    The dataset will be constructed as a library (partitioned dataset)\n    which can hold many groups of data, such as many FORTRAN programs\n    or many Memos.  LIBRARY IS THE DEFAULT.\n\n))FIXED -\n    All lines of data have the same length.  This is the default if no\n    'type' is selected and the dataset name doesn't end with a 'type'\n    name.  It is also the default if the following types are selected:\n\n                ASM        COMMAND     LIST\n                CNTL       DATA        OBJ\n                COBOL      FORT        PLIF\n\n))VARIABLE -\n    Each line fo data may be a different length from the rest.  This\n    is the default if one of these types is selected.\n\n                CLIST      TEXT\n                PLI        VSBASIC\n\n))UNFORMATTED -\n    This is the format for LOAD datasets.\n\n\n))Examples:\n\n     (Assume your TSO user prefix is ABC0)\n\n\n        1.  NEWSPACE  MYPROJ\n                Creates library 'ABC0.MYPROJ'.  Since no TYPE is\n                designated, and MYPROJ doesn't end in a TYPE name, a\n                default internal characteristics are used.\n\n        2.  NEWSPACE  MYPROJ  DATA\n               - or - MYPROJ.DATA\n                Creates library 'ABC0.MYPROJ.DATA', using the DATA type\n                internal characteristics, with the default FIXED\n                format.\n\n        3.  NEWSPACE  MYPROJ.DATA  SEQUENTIAL\n                Creates sequential dataset 'ABC0.MYPROJ.DATA'\n\n        4.  NEWSPACE  MYPROJ.DATA  VARIABLE\n                Creates library 'ABC0.MYPROJ.DATA', using the DATA type\n                internal characteristics, and the VARIABLE format.\n\n        5.  NEWSPACE 'XYZ9.SHARE.JOB82'\n                Creates library 'XYZ9.SHARE.JOB82'.  Since no TYPE is\n                designated, and JOB82 isn't a type name, the default\n                internal characteristics are used.\n\n\n)M\n))Messages issued by NEWSPACE are:\n\n))NSP0001 - RECORD FORMAT IS INVALID FOR THIS DATA TYPE.\n          You have requested an invalid combination, such as CNTL type\n          and VARIABLE format.\n\n))NSP0002 - DATASET WAS NOT CREATED.\n          The dataset wasn't created because of some problem, such as\n          another dataset already having the same name.\n\n))NSP0003 - organization DATASET 'dataset-name' CREATED\n          The dataset named in this message has been successfully\n          created.\n\n))NSP0004 - IMPROPER DATASET NAME\n          Dataset name was incorrect, such as zero length or ending\n          with a period.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LINKBACK": {"ttr": 1542, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&ENDNAME LINKBACK &RCADDR=\n.*********************************************************************\n.*  MACRO FOR STANDARD LINKAGE CONVENTIONS AT PROGRAM EXIT.        ***\n.*  USED IN CONJUNCTION WITH THE LINKSAVE MACRO.                   ***\n.*                                                                 ***\n.*  RCADDR=NAME   NAME OF FULLWORD RETURN CODE TO BE LOADED        ***\n.*                INTO R15.  IF THIS OPERAND IS NOT USED, THE      ***\n.*                RETURN CODE WILL BE THE VALUE CONTAINED IN R15   ***\n.*                JUST PRIOR TO ENTERING THE CODE GENERATED BY     ***\n.*                THIS MACRO.                                      ***\n.*                                                                 ***\n.* NOTE -                                                          ***\n.*  IF GETMAIN=YES WAS USED WITH LINKSAVE, THIS MACRO WILL         ***\n.*  FREEMAIN THE STORAGE AREA WHICH LINKSAVE GOTMAINED.            ***\n.*                                                                 ***\n.*  CHUCK HOFFMAN, SYSTEMS PROGRAMMING, GTEL COMPUTING CENTER      ***\n.*********************************************************************\n         GBLC  &GMN\n         LCLA  &RCLEN\n&RCLEN   SETA  K'&RCADDR               LENGTH OF NAME OF RETURN CODE\n         AIF ('&GMN' EQ 'YES').FORM2   IF LINKSAVE USED A GETMAIN, GO\n&ENDNAME L     13,4(0,13)              RESTORE R13 FROM MY SAVE AREA\n         AIF (&RCLEN EQ 0).FORM1A\n         L     15,&RCADDR              SET RETURN CODE\n.FORM1A  ANOP\n         LM    0,12,20(13)             RESTORE R0-12\n         L     14,12(0,13)             RESTORE R14\n         MVI   12(13),X'FF'            RETURN INDICATOR\n         BR    14                      RETURN TO CALLING PROGRAM\n         MEXIT\n.FORM2   ANOP\n&ENDNAME LR    1,13                    COPY MY SA ADDR FOR FREEMAIN\n         AIF (K'&RCADDR EQ 0).FORM2C\n         L     14,&RCADDR              SAVE RETURN CODE\n         AGO .FORM2A\n.FORM2C  LR    14,15                   SAVE RETURN CODE\n.FORM2A  ANOP\n         L     13,4(0,13)              RESTORE R13 FROM MY SAVE AREA\n*        FREEMAIN R,LV=136,A=(1)       FREE STORAGE\n         FREEMAIN R,LV=136,A=(1)       FREE STORAGE\n         LR    15,14                   SET RETURN ADDRESS\n.FORM2B  ANOP\n         LM    0,12,20(13)             RESTORE R0-12\n         L     14,12(0,13)             RESTORE R14\n         MVI   12(13),X'FF'            RETURN INDICATOR\n         BR    14                      RETURN TO CALLING PROGRAM\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LINKSAVE": {"ttr": 1544, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&CSNAME  LINKSAVE &BASE=,&GETMAIN=NO\n.*********************************************************************\n.*  MACRO FOR STANDARD LINKAGE CONVENTIONS AT PROGRAM ENTRY.       ***\n.*  USED IN CONJUNCTION WITH THE LINKBACK MACRO.                   ***\n.*                                                                 ***\n.*  BASE=NN     REGISTER NUMBER OF BASE REGISTER.                  ***\n.*                                                                 ***\n.*  GETMAIN=YES WILL DO A GETMAIN FOR STORAGE SPACE.  SPACE        ***\n.*              OBTAINED WILL BE 72 BYTES FOR SAVE AREA, PLUS      ***\n.*              64 BYTES FOR PROGRAMMER'S USE.  R13 WILL BE        ***\n.*              THE BASE ADDRESS OF THE STORAGE AREA.              ***\n.*                                                                 ***\n.*  CHUCK HOFFMAN, SYSTEMS PROGRAMMING, GTEL COMPUTING CENTER      ***\n.*********************************************************************\n         GBLC  &GMN\n         LCLA  &C,&D\n&GMN     SETC  '&GETMAIN'\n         AIF   ('&GMN' EQ 'YES').FORM2\n&CSNAME  CSECT\n&C       SETA  K'&CSNAME\n&D       SETA  ((20+&C)/2)*2\n         B     &D.(0,15)                BRANCH AROUND ID\n         DC    AL1(&C)                    LENGTH\n         DC    CL&C'&CSNAME'              ID\n         DC    CL8'&SYSDATE'              SYSTEM DATE:  MM/DD/YY\n         DC    CL6' &SYSTIME'             SYSTEM TIME:  HH.MM\n         STM   14,12,12(13)             SAVE R0-R12, R14-R15\n         LR    &BASE,15                 LOAD BASE ADDRESS\n         USING &CSNAME,&BASE            ASSIGN BASE REGISTER\n         ST    13,MYSV&SYSNDX+4         STORE ADDR OF PREV SAVE AREA\n*                                         INTO MY SAVE AREA\n         LA    14,MYSV&SYSNDX           LOAD ADDR OF MY SAVE AREA\n         ST    14,8(0,13)                 STORE IT INTO PREV SAVE AREA\n         LR    13,14                      ALSO LOAD IT INTO R13\n         B     MYSV&SYSNDX+72           BRANCH AROUND MY SAVE AREA\nMYSV&SYSNDX DC 18F'0'                   MY SAVE AREA\n         MEXIT\n.FORM2   ANOP\n&CSNAME  CSECT\n&C       SETA  K'&CSNAME\n&D       SETA  ((20+&C)/2)*2\n         B     &D.(0,15)                BRANCH AROUND ID\n         DC    AL1(&C)                    LENGTH\n         DC    CL&C'&CSNAME'              ID\n         DC    CL8'&SYSDATE'              SYSTEM DATE:  MM/DD/YY\n         DC    CL6' &SYSTIME'             SYSTEM TIME:  HH.MM\n         STM   14,12,12(13)             SAVE R0-R12, R14-R15\n         LR    &BASE,15                 LOAD BASE ADDRESS\n         USING &CSNAME,&BASE            ASSIGN BASE REGISTER\n*        GETMAIN R,LV=136               GET STORAGE FOR S.A. + 64 BYTES\n         GETMAIN R,LV=136               GET STORAGE FOR S.A. + 64 BYTES\n         ST    13,4(0,1)                STORE ADDR OF PREV SAVE AREA\n*                                         INTO MY SAVE AREA\n         ST    1,8(0,13)                ADDR OF MY SA TO PREV SAVE AREA\n         LM    0,1,20(13)               RESTORE R0-R1 TO ORIGINAL VALUE\n         L     13,8(0,13)               POINT R13 TO MY SAVE AREA\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NEW": {"ttr": 1546, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE 'NEWSPACE - EASY ALLOCATION OF DATASETS'\n**********************************************************************\n***                                                                ***\n***                NEWSPACE COMMAND                                ***\n***                                                                ***\n***  DESCRIPTION:                                                  ***\n***    THE FUNCTION OF THIS COMMAND IS TO PROVIDE AN EASY WAY FOR  ***\n***    NEW TSO USERS TO CREATE NEW SEQUENTIAL AND PARTITIONED      ***\n***    DATASETS.  THIS COMMAND IS MUCH EASIER TO USE THAN          ***\n***    ISPF/PDF OPTION 3.2, OR THE ALLOCATE AND ATTRIB COMMANDS.   ***\n***    HOWEVER, IT IS NOT AS VERSITILE AS THOSE COMMANDS.          ***\n***                                                                ***\n***  FORMAT:                                                       ***\n***          NEWSPACE  DSNAME  ORG  TYPE  FORMAT                   ***\n***                                                                ***\n***      REQUIRED: DSNAME                                          ***\n***                                                                ***\n***  FUNCTION:                                                     ***\n***                                                                ***\n***  1. NEWSPACE FIRST PARSES THE PARM STRING, THEN DETERMINES     ***\n***     THE LENGTH AND TEXT OF THE LOW-LEVEL QUALIFIER OF THE      ***\n***     DSNAME.                                                    ***\n***                                                                ***\n***  2. A TABLE IS THEN USED.  THE ENTRY IN THE TABLE IS LOCATED   ***\n***     ON THE BASIS OF THE 'TYPE' OPERAND.  IF 'TYPE' IS NOT      ***\n***     USED, THE ENTRY IS LOCATED BY USE OF THE LOW-LEVEL         ***\n***     QUALIFIER.                                                 ***\n***                                                                ***\n***  3. EACH DATA TYPE ENTRY IS FOLLOWED BY ONE OR MORE SETS OF    ***\n***     DCB INFORMATION (SUBENTRY).  IF THE 'FORMAT' OPTION HAS    ***\n***     BEEN USED, THAT SUBENTRY IS SEARCHED FOR.  IF NOT, THE     ***\n***     FIRST SUBENTRY IN THE LIST IS USED AS A DEFAULT.  THE      ***\n***     TABLE IS AT THE 'DATATBLE' LABEL IN THE SOURCE CODE.       ***\n***                                                                ***\n***  4. NEWSPACE THEN ALTERS THE SVC-99 DYNAMIC ALLOCATION TEXT    ***\n***     UNITS CREATED BY THE GTEDADAT MACRO.  THE ALTERATION FILLS ***\n***     IN THE DATASET NAME AND DCB INFORMATION.  THE TYPE IS      ***\n***     APPENDED ONTO THE END OF THE DATASET NAME, UNLESS QUOTES   ***\n***     HAVE BEEN USED AROUND THE NAME, OR THE TYPE OPERAND HAS    ***\n***     NOT BEEN USED.  THE DATASET IS THEN DYNAMICALLY ALLOCATED. ***\n***     THE GTEDAALC MACRO USES DAIRFAIL TO PRODUCE DYNAMIC        ***\n***     ALLOCATION ERROR MESSAGES.                                 ***\n***                                                                ***\n***  5. NEWSPACE THEN CLEANS UP AND TERMINATES.                    ***\n***                                                                ***\n***  6. ERROR/INFO MESSAGES ARE HANDLED BY THE ERRMSG ROUTINE.     ***\n***     MOST MESSAGES ARE A SINGLE SEGMENT.  MESSAGE #3, THE       ***\n***     'DATASET CREATED' MESSAGE HAS THREE SEGMENTS WHICH ARE     ***\n***     GLUED TOGETHER BY PUTLINE BEFORE BEING WRITTEN TO THE      ***\n***     TERMINAL.                                                  ***\n***                                                                ***\n**********************************************************************\n         EJECT\n**********************************************************************\n***                                                                ***\n***  RETURN CODES:                                                 ***\n***     00 - OKAY                                                  ***\n***     12 - SOMETHING WAS WRONG.  SHOULD ALSO HAVE AN ERROR MSG.  ***\n***                                                                ***\n***  REGISTER USAGE:                                               ***\n***     R0-R3   - USED BY MACROS                                   ***\n***     R4-R7   - WORK REGISTERS, NOT USED TO PASS INFORMATION     ***\n***               BETWEEN ROUTINES.                                ***\n***     R8      - UNUSED                                           ***\n***     R9      - BASE OF PARM DESCRIPTOR LIST (PDL) RETURNED BY   ***\n***               IKJPARS PARSE SERVICE ROUTINE                    ***\n***     R10     - LINKAGE REGISTER USED WITH BAL                   ***\n***     R11     - BASE OF WORK AREA OBTAINED WITH GETMAIN          ***\n***     R12     - BASE REGISTER OF PROGRAM CODE.                   ***\n***     R13-R15 - LINKAGE REGISTERS                                ***\n***                                                                ***\n***                                                                ***\n***  NON-IBM MACROS USED:                                          ***\n***     LINKSAVE - LINKAGE CONVENTIONS IN                          ***\n***     EQ$R     - REGISTER EQUATES                                ***\n***     LINKBACK - LINKAGE CONVENTIONS BACK                        ***\n***     GTEDADAT - CREATE SVC-99 AND IKJEFF18 CONTROL BLOCKS       ***\n***     GTEDASET - INITIALIZE AND LINK SVC-99 AND IKJEFF18 CONTROL ***\n***                BLOCKS                                          ***\n***     GTEDAALC - PERFORM DYNAMIC ALLOCATION AND DAIRFAIL         ***\n***                ANALYSIS OF FAILURES                            ***\n***                                                                ***\n***  ASSEMBLER OPTIONS:       RENT                                 ***\n***  LINKAGE EDITOR OPTIONS:  RENT, REUS, ALIAS(NEW)               ***\n***                                                                ***\n***  CULPRIT:                                                      ***\n***     CHUCK HOFFMAN, SYSTEMS PROGRAMMING                         ***\n***     GTE LABORATORIES TECHNICAL COMPUTING CENTER                ***\n***     WALTHAM, MASSACHUSETTS  617/466-2131    V/N 466-2131       ***\n***                                                                ***\n***  MAINTENANCE HISTORY:                                          ***\n***                                                                ***\n***                                                                ***\n**********************************************************************\n         PRINT NOGEN\n         MACRO\n&LABEL   HIREP &WORD=,&CODE=,&REG=15    SET HIGHER CODE\n&LABEL   LA    &REG,&CODE.(0,0)         NEW CODE TO REG\n         C     &REG,&WORD               IF EXISTING CODE HIGHER\n         BNH   *+8                        BRANCH AROUND\n         ST    &REG,&WORD               ELSE SAVE NEW CODE\n         CNOP  0,4                      ALIGN\n         MEND\n         EJECT\n**********************************************************************\n***                                                                ***\n***   PROLOGUE                                                     ***\n***                                                                ***\n**********************************************************************\n*\nNEWSPACE LINKSAVE BASE=12,GETMAIN=YES\n         EQ$R\n         USING WORK0,R13                ADDRESSABILITY OF WORK0\n         USING PARMPDL,R9               ADDRESSABILITY OF PRM DESC LST\n         ST    R1,CPPLPTR               SAVE CPPL POINTER\n         GETMAIN  R,LV=WORK1LEN         GET MAIN STORAGE\n         LR    R11,R1                   ADDRESS OF MAIN STORAGE\n         USING WORK1,R11                ADDRESSABILITY OF WORK1\n         XC    COMPCODE,COMPCODE        CLEAR PROGRAM RETURN CODE\n         XC    RETCDE,RETCDE            CLEAR INTERNAL RETURN CODE\n*\n         EJECT\n**********************************************************************\n***                                                                ***\n***   MAIN LINE ROUTINE                                            ***\n***                                                                ***\n**********************************************************************\n*\n         BAL   R10,PPLSETUP             SET UP PARSE PARM LIST\n         BAL   R10,PARSE                PARSE THE INPUT PARAMETERS\n         BAL   R10,LOLEVEL              FIND LOW LEVEL OF NAME\n         L     R4,RETCDE                IF RETURN CODE NOT GOOD\n         LTR   R4,R4                      THEN\n         BNZ   ENDING                     BRANCH TO ENDING\n         BAL   R10,DATATYPE             FIND DATA TYPE\n         BAL   R10,DCBSELCT             SELECT DCB INFO FROM TABLE\n         L     R4,RETCDE                IF RETURN CODE NOT GOOD\n         LTR   R4,R4                      THEN\n         BNZ   ENDING                     BRANCH TO ENDING\n         BAL   R10,ALLOC                ALLOCATE THE DATASET\n         L     R4,RETCDE                IF RETURN CODE\n         LTR   R4,R4                      IS ZERO\n         BZ    GOODMSG                  BRANCH AROUND\n         LA    R4,2(0,0)                ELSE\n         ST    R4,RETCDE                  SELECT MESSAGE #2\n         BAL   R10,ERRMSG                 AND WRITE IT\n         B     ENDING                     THEN BRANCH TO ENDING\n*\nGOODMSG  LA    R4,3(0,0)\n         ST    R4,RETCDE                SELECT MESSAGE #3\n         BAL   R10,ERRMSG                 AND WRITE IT\n         B     ENDING                     THEN BRANCH TO ENDING\n*\n         EJECT\n**********************************************************************\n***                                                                ***\n***   EPILOGUE                                                     ***\n***                                                                ***\n**********************************************************************\nENDING   LA       R4,MYPPL+(PPLANS-PPL)   ADDRESS OF PTR TO PDL\n         L        R4,0(0,R4)              R4 POINTS TO PDL\n         IKJRLSA  (R4)                    FREE STORAGE OF PDL\n         FREEMAIN R,LV=WORK1LEN,A=(R11) , FREE MAIN STORAGE\n         LINKBACK RCADDR=COMPCODE\n*\n*\n         EJECT\n**********************************************************************\n***                                                                ***\n***        CREATE PARSE PARAMETER LIST                             ***\n***                                                                ***\n**********************************************************************\nPPLSETUP ST    R10,PPR10SAV             SAVE RETURN ADDRESS\n         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO\n*\n         L     R4,CPPLPTR               ADDRESS OF CMD PROC PARM LIST\n         USING CPPL,R4                    ADDRESSABILITY\n         MVC   MYPPL+(PPLUPT-PPL)(4),CPPLUPT              UPT  (CPPL)\n         MVC   MYPPL+(PPLECT-PPL)(4),CPPLECT              ECT  (CPPL)\n         LA    R5,MYECB\n         ST    R5,MYPPL+(PPLECB-PPL)                      ECB  (MINE)\n         MVC   MYPPL+(PPLPCL-PPL)(4),VPARMPCL             PCL  (CSECT)\n         LA    R5,MYANS\n         ST    R5,MYPPL+(PPLANS-PPL)                      ANS  (MINE)\n         MVC   MYPPL+(PPLCBUF-PPL)(4),CPPLCBUF            CBUF (CPPL)\n         XC    MYPPL+(PPLUWA-PPL)(4),MYPPL+(PPLUWA-PPL)   UWA  (MINE)\n         DROP  R4\n*\nPPEND    L     R10,PPR10SAV             RESTORE RETURN ADDRESS\n         BR    R10                      RETURN\n         EJECT\n**********************************************************************\n***                                                                ***\n***    PARSE THE INPUT PARAMETER STRING                            ***\n***                                                                ***\n**********************************************************************\nPARSE    ST    R10,PAR10SAV             SAVE RETURN ADDRESS\n         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO\n*\n         XC    MYECB,MYECB              ZERO THE ECB FOR PARSE\nPARSEIT  CALLTSSR EP=IKJPARS,MF=(E,MYPPL)  PARSE THE PARMS\n         L     R9,MYPPL+(PPLANS-PPL)    POINTER TO PDL ADDRESS\n         L     R9,0(0,R9)               ADDRESSABILITY OF PDL\n*\nPAEND    L     R10,PAR10SAV             RESTORE RETURN ADDRESS\n         BR    R10                      RETURN\n         EJECT\n**********************************************************************\n***                                                                ***\n***   FIND LENGTH AND VALUE OF LOW LEVEL QUALIFIER                 ***\n***                                                                ***\n**********************************************************************\nLOLEVEL  ST    R10,LOR10SAV             SAVE RETURN ADDRESS\n         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO\n*\n         L     R4,NAME+0                R4 POINTS TO DSN\n         LH    R5,NAME+4                R5 HAS LENGTH OF DSN\n         LA    R6,0(R5,R4)              R6 POINTS JUST BEYOND DSN\n*\nLOLOOP   BCTR  R6,0                     DECR POINTER BY 1\n         CLI   0(R6),C'.'               IF PRECEEDING DECIMAL POINT\n         BE    *+12                       BRANCH OUT\n         BCT   R5,LOLOOP                ELSE KEEP LOOKING\n*                                    ** REACH HERE ONLY IF 1 LEVEL DSN\n         B     *+8                      POINTING AT BEGINNING, SO BR\n*                                    ** REACH HERE IF FOUND '.'\n         LA    R6,1(0,R6)               POINTING TO '.', SO INCR BY 1\n*                                    ** R6 POINTS TO 1ST CHAR OF QULFR\n*\n         AH    R4,NAME+4                R4 POINTS JUST BEYOND NAME\n         SR    R4,R6                    R4 IS LENGTH OF NAME\n*\n         ST    R6,LOADDR                SAVE ADDR OF LOW LEVEL OF DSN\n         STH   R4,LOLEN                 SAVE LEN OF LOW LEVEL OF DSN\n*\n         LTR   R4,R4                    IF LOW LEVEL IS LENGTH > 0\n         BP    LOSAVE                     BRANCH TO END\n         LA    R4,4(0,0)                ELSE\n         ST    R4,RETCDE                  SET INTERNAL RETCDE TO 4\n         BAL   R10,ERRMSG                 PUT OUT ERROR MESSAGE #4\n         HIREP WORD=COMPCODE,CODE=12      SET COMPLETION CODE TO 12\n         B     LOEND                      BRANCH TO END OF ROUTINE\n*\nLOSAVE   BCTR  R4,0                     MINUS 1 FOR EXECUTE\n         B     *+10                     BRANCH AROUND EXECUTED INSTR\n         MVC   LOTEXT(0),0(R6)            SAVE TEXT OF LOW LEVEL\n         EX    R4,*-6                   EXECUTE THE MOVE\n*\nLOEND    L     R10,LOR10SAV             RESTORE RETURN ADDRESS\n         BR    R10                      RETURN\n         EJECT\n**********************************************************************\n***                                                                ***\n***    LOCATE DATA TYPE IN TABLE                                   ***\n***                                                                ***\n***    IF THE TYPE OPERAND HAS BEEN USED, USE THE INTEGER RETURNED ***\n***    FROM IKJPARS AS THE KEY TO ENTERING THE TABLE.  OTHERWISE,  ***\n***    USE THE TEXT AND LENGTH OF THE LOW LEVEL QUALIFIER AS THE   ***\n***    KEY FOR ENTERING THE TABLE.                                 ***\n***                                                                ***\n**********************************************************************\nDATATYPE ST    R10,DAR10SAV             SAVE RETURN ADDRESS\n         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO\n*\n         LH    R4,TYPE                  LOAD TYPE NUMBER FROM PARM\n         LTR   R4,R4                    IF NO TYPE DESIGNATED\n         BNP   DATAFIND                   USE TABLE FOR TYPE\n         B     DATAPARM                 ELSE LOOK UP TYPE DIRECTLY\n*\nDATAFIND LH    R4,LOLEN                 LENGTH OF LO LEVEL QUALIFIER\n         XR    R5,R5                    CLEAR R5 FOR IC\n         LA    R6,DATATBLE              BASE ADDRESS OF TABLE\n*\nDALOOP   CLI   0(R6),X'FF'              IF AT END OF TABLE,\n         BE    DAFOUND                    BRANCH OUT OF LOOP\n         IC    R5,1(0,R6)               R5 HAS LEN OF NAME IN TABLE\n         CR    R4,R5                    IF NO MATCH\n         BNE   DANEXT                     BRANCH TO BOTTOM OF LOOP\n         BCTR  R5,0                     MINUS 1 FOR EXEC\n         B     *+10                     BRANCH AROUND COMPARE\n         CLC   2(0,R6),LOTEXT             COMPARE LO TEXT WITH TBL TXT\n         EX    R5,*-6                   EXECUTE COMPARE\n         BE    DAFOUND                  IF EQUAL, BRANCH OUT OF LOOP\n*\nDANEXT   LH    R5,10(0,R6)              RECFM COUNT TO R5\n         LA    R6,12(0,R6)              POINT TO FIRST RECFM\n         LA    R6,6(0,R6)               POINT TO NEXT RECFM\n         BCT   R5,*-4                   PERFORM TILL NO MORE RECFM'S\n         B     DALOOP                   LOOP BACK UP FOR NEXT ENTRY\n*\nDATAPARM LA    R6,DATATBLE              BASE ADDRESS OF TABLE\nDAPLOOP  CLI   0(R6),X'FF'              IF AT END OF TABLE\n         BE    DAFOUND                    BRANCH OUT OF LOOP\n         XR    R5,R5                    CLEAR R5 FOR IC\n         IC    R5,0(0,R6)               DATA TYPE FROM TBL TO R5\n         CR    R4,R5                    IF A MATCH\n         BE    DAFOUND                    BRANCH OUT OF LOOP\n         LH    R5,10(0,R6)              RECFM COUNT TO R5\n         LA    R6,12(0,R6)              POINT TO FIRST RECFM\n         LA    R6,6(0,R6)               POINT TO NEXT RECFM\n         BCT   R5,*-4                   PERFORM TILL NO MORE RECFM'S\n         B     DAPLOOP\n*\nDAFOUND  ST    R6,DATYPADR              SAVE ADDR OF TABLE ENTRY\n*\nDAEND    L     R10,DAR10SAV             RESTORE RETURN ADDRESS\n         BR    R10                      RETURN\n         EJECT\n**********************************************************************\n***                                                                ***\n***   SELECT DCB INFO FROM TABLE                                   ***\n***                                                                ***\n***   LOOK FOR DCB-INFO SUBENTRIES IN THE TABLE TO MATCH THE       ***\n***   INTEGER RETURNED BY IKJPARS FOR THE FORMAT OPERAND.  IF      ***\n***   THE FORMAT OPERAND HAS NOT BEEN USED, SELECT THE FIRST       ***\n***   DCB-INFO SUBENTRY.                                           ***\n***                                                                ***\n**********************************************************************\nDCBSELCT ST    R10,DCR10SAV             SAVE RETURN ADDRESS\n         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO\n*\n         L     R4,DATYPADR              R4 IS ADDR OF TABLE ENTRY\n         LH    R5,10(0,R4)              R5 IS COUNT OF DCB ENTRIES\n         LA    R6,12(0,R4)              R6 POINTS TO FIRST DCB ENTRY\n*\n         LH    R7,RFORM                 RFORM OPERAND TO R7\n         LTR   R7,R7                    IF RFORM OPERAND NOT USED\n         BZ    DCBMATCH                   BRANCH AROUND\n*\n         LA    R6,12-6(0,R4)            POINT TO -1 DCB ENTRY\nDCBLOOP  LA    R6,6(0,R6)               R6 POINTS TO NEXT DCB ENTRY\n         B     *+8                      BRANCH AROUND COMPARE\n         CLI   0(R6),0                    REG FOR EXEC : DCB ENTRY\n         EX    R7,*-4                   EXECUTE COMPARE\n         BE    DCBMATCH                 IF HIT, BRANCH OUT\n         BCT   R5,DCBLOOP               LOOP UP IF MORE DCB ENTRIES\n*          ***  GET HERE ONLY IF NO HIT ***\n         LA    R15,1(0,0)               SET INTERNAL R/C\n         ST    R15,RETCDE                 TO ONE\n         BAL   R10,ERRMSG               PERFORM ERROR MSG\n         HIREP WORD=COMPCODE,CODE=12    SET COMP CODE TO 12\n         B     DCEND                    BRANCH TO ENDING\n*\nDCBMATCH ST    R6,DCBADDR               SAVE DCB ENTRY ADDR\n*\nDCEND    L     R10,DCR10SAV             RESTORE RETURN ADDRESS\n         BR    R10                      RETURN\n         EJECT\n**********************************************************************\n***                                                                ***\n***   ERROR MESSAGES                                               ***\n***                                                                ***\n***     ===> NOTE THAT RETCDE IS USED AS AN INPUT ARGUMENT <===    ***\n***                                                                ***\n**********************************************************************\nERRMSG   ST    R10,ERR10SAV             SAVE RETURN ADDRESS\n*\n*    +-------------------------------------+\n*    |  SPECIAL PROCESSING FOR MESSAGE #3  |\n*    +-------------------------------------+\n         LA    R4,3(0,0)                CONSTANT FOR COMPARE\n         C     R4,RETCDE                IF RETCODE WAS NOT 3\n         BNE   ERRMSGS                    BRANCH AROUND SPECL PROCESS\n         LA    R6,OLD0003V              ADDRESS OF WORK O.L.D.\n         MVC   OLD0003V(16),OLD0003     COPY CONSTANTS TO WORK O.L.D.\n         CLI   ORG+1,X'01'              IF ORG PARM NOT 'SEQUENTIAL'\n         BNE   *+12                       BRANCH AROUND\n         LA    R4,MSG0003S              ELSE ADDR OF 'SEQ' LITERAL\n         ST    R4,OLD0003V+8              INTO WORK O.L.D.\n         MVC   MSG0003C(48),MSG0003B    INITIALIZE WORK MSG SEGMENT\n         LA    R4,MSG0003C              ADDRESS OF WORK MSG SEGMENT\n         ST    R4,OLD0003V+12             INTO WORK O.L.D\n         LH    R4,DSNLEN                R4 IS TOTAL DSN LENGTH\n         LA    R4,4(0,R4)                 PLUS HEADER IN MSG SEGMENT\n         STH   R4,MSG0003C+0              INTO WORK MSG SEGMENT\n         MVC   MSG0003C+4(44),DSDSNAM   MOVE DSNAME INTO WORK MSG SEG\n         B     ERIOPL                   BRANCH TO INITIALIZE IOPL\n*\nERRMSGS  L     R6,RETCDE                RET CODE TO R4\n         SLA   R6,2                     R6 IS OFFSET FROM ERADDRS-4\n         LA    R6,ERADDRS-4(R6)         R6 POINTS TO ERADNNNN\n         L     R6,0(0,R6)               R6 POINTS TO OLDNNNN\n*\nERIOPL   XC    MYECB,MYECB              CLEAR ECB\n         L     R4,CPPLPTR               R4 POINTS TO CPPL\n         L     R4,(CPPLUPT-CPPL)(0,R4)  R4 CONTAINS UPT ADDRESS\n         L     R5,CPPLPTR               R5 POINTS TO CPPL\n         L     R5,(CPPLECT-CPPL)(0,R5)  R5 CONTAINS ECT ADDR\nERRPUTL  PUTLINE PARM=MYPTPB,UPT=(R4),ECT=(R5),                        X\n               ECB=MYECB,OUTPUT=((R6)),MF=(E,MYIOPL)\n*\nEREND    L     R10,ERR10SAV             RESTORE RETURN ADDRESS\n         BR    R10                      RETURN\n*\n*\nERADDRS  DS    0F                       TABLE OF OUTPUT LINE DESCRIPTRS\nERAD0001 DC    A(OLD0001)               #1 BAD TYPE/FORMAT COMBO\nERAD0002 DC    A(OLD0002)               #2 DATASET NOT ALLOCATED\nERAD0003 DC    A(0)                     DUMMY\nERAD0004 DC    A(OLD0004)               #4 IMPROPER DSN\n         EJECT\n**********************************************************************\n***                                                                ***\n***   ALLOCATE THE DATASET                                         ***\n***                                                                ***\n**********************************************************************\nALLOC    ST    R10,ALR10SAV             SAVE RETURN ADDRESS\n         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO\n*\n         MVC   DS(256),@DS              COPY CNTROL BLOCK DTA TO WORK1\n         MVC   DS+256(DSLEN-256),@DS+256  COPY THE REMAINDER TO WORK1\n*\nALDSN    L     R4,NAME                  R4 POINTS TO PARM DSNAME\n         LH    R5,NAME+4                R5 IS LENGTH OF NAME\n         STH   R5,DSNLEN                SAVE THE LENGTH\n         BCTR  R5,0                       MINUS 1 FOR EXEC\n         B     *+10                     BRANCH AROUND MVC\n         MVC   DSDSNAM(0),0(R4)           MOVE PARM NAME TO TEXT UNIT\n         EX    R5,*-6                   PERFORM MOVE\n         L     R4,DATYPADR              R4 POINTS TO TABLE TYPE-ENTRY\n         TM    NAME+6,X'40'             IF PARM HAD QUOTES\n         BO    ALDSORG                    BRANCH TO NEXT ROUTINE\n         LH    R6,TYPE                  ELSE\n         LTR   R6,R6                    IF NOT USING 'TYPE' PARM\n         BZ    ALDSORG                    BRANCH TO NEXT ROUTINE\n         CLI   0(R4),X'FF'              ELSE IF USING DEFALT TYPE-ENTRY\n         BE    ALDSORG                    BRANCH TO NEXT ROUTINE\n         LA    R5,DSDSNAM+1(R5)         R5 POINTS JUST BEYOND DSNAME\n         MVI   0(R5),C'.'               PUT DOT AT END OF NAME\n         IC    R6,1(0,R4)               R6 HAS LENGTH OF TYPE-NAME\n         BCTR  R6,0                       MINUS 1 FOR EXEC\n         B     *+10                     BRANCH AROUND MVC\n         MVC   1(0,R5),2(R4)              TYPE-NAME TO END OF DSNAM\n         EX    R6,*-6                   EXECUTE MVC\n         LA    R6,2(0,R6)               LENGTH OF SUFFIX + DOT\n         AH    R6,DSNLEN                ADD THE PREVIOUS LENGTH OF DSN\n         STH   R6,DSNLEN                  AND SAVE IT\nALDSORG  LH    R4,ORG                   PARM ORG TO R4\n         LA    R5,1(0,0)                CONSTANT FOR COMPARE\n         CR    R4,R5                    IF 1 (SEQUENTIAL)\n         BNE   ALRECFM                  THEN\n         XC    DSDIR-6(2),DSDIR-6         SET DIRECTORY SPACE KEY=0000\n         MVC   DSDSORG+6(2),PS            SET DSORG TO PS (X'4000')\nALRECFM  L     R4,DCBADDR               R4 POINTS TO DCB INFO IN TABLE\n         MVC   DSRECFM+6(1),1(R4)       MOVE RECORD FORMAT TO T.U.\nALLRECL  MVC   DSLRECL(2),2(R4)         MOVE LRECL TO T.U.\nALBLKSZ  MVC   DSBLKSZ(2),4(R4)         MOVE BLKSIZE TO T.U.\n*\n*\nALSET    GTEDASET DS,CPPLPTR=CPPLPTR    LINK CONTROL BLOCKS TOGETHER\n*\nALALC    GTEDAALC DS,VERB=AL,ERRMSG=YES ALLOCATE THE DATASET\n         MVC   RETCDE,DSS99RC           COPY ALLOCATION R/C\n*\nALEND    L     R10,ALR10SAV             RESTORE RETURN ADDRESS\n         BR    R10                      RETURN\n         EJECT\n**********************************************************************\n***                                                                ***\n***   DATA CONSTANTS                                               ***\n***                                                                ***\n**********************************************************************\nCONSTDTA DS    0D                       AREA FOR DATA CONSTANTS\nPS       DC    XL2'4000'                TEXT UNIT DATA FOR DSORG=PS\nVPARMPCL DC    V(PARMPCL)               ADDR OF PARM CONTROL LIST\nCONSTEND DS    0D\n*\n*----------------------------------------------------------------------\nDATATBLE DC    X'01,03',CL8'ASM     ',H'1'  +------------------------+\n         DC    X'01,90',H'080',H'6160'      | TABLE ENTRIES:         |\n*                                           |                        |\n         DC    X'02,05',CL8'CLIST   ',H'2'  | TYPE ENTRY:            |\n         DC    X'02,50',H'255',H'6160'      |   BYTE 1  SEQUENCE NO, |\n         DC    X'01,90',H'080',H'6160'      |     DEFAULT=X'FF' (EOL)|\n*                                           |   BYTE 2  NAME LENGTH  |\n         DC    X'03,04',CL8'CNTL    ',H'1'  |   BYTE 3-10  NAME      |\n         DC    X'01,90',H'080',H'6160'      |   BYTE 11-12 NUMBER-OF |\n*                                           |     DCB-INFO SUBENTRIES|\n         DC    X'04,05',CL8'COBOL   ',H'1'  |                        |\n         DC    X'01,90',H'080',H'6160'      | DCB INFO SUBENTRY:     |\n*                                           |   BYTE 1  FORMAT PARM  |\n         DC    X'05,07',CL8'COMMAND ',H'2'  |     01 FIXED           |\n         DC    X'01,90',H'080',H'6160'      |     02 VARIABLE        |\n         DC    X'02,50',H'255',H'6160'      |     03 UNFORMATTED     |\n*                                           |   BYTE 2  RECFM        |\n         DC    X'06,04',CL8'DATA    ',H'2'  |     50 VB              |\n         DC    X'01,90',H'080',H'6160'      |     54 VBA             |\n         DC    X'02,50',H'255',H'6160'      |     90 FB              |\n*                                           |     94 FBA             |\n         DC    X'07,04',CL8'FORT    ',H'1'  |     C0 U               |\n         DC    X'01,90',H'080',H'6160'      |   BYTE 3-4  LRECL      |\n*                                           |   BYTE 5-6  BLKSIZE    |\n         DC    X'08,04',CL8'LIST    ',H'1'  +------------------------+\n         DC    X'01,94',H'131',H'6118'\n*\n         DC    X'09,04',CL8'LOAD    ',H'1'\n         DC    X'03,C0',H'000',H'6233'\n*\n         DC    X'0A,03',CL8'OBJ     ',H'1'\n         DC    X'01,90',H'080',H'0800'\n*\n         DC    X'0B,03',CL8'PLI     ',H'1'\n         DC    X'02,50',H'104',H'6160'\n*\n         DC    X'0C,04',CL8'PLIF    ',H'1'\n         DC    X'01,90',H'080',H'0400'\n*\n         DC    X'0D,04',CL8'TEXT    ',H'2'\n         DC    X'02,50',H'255',H'6160'\n         DC    X'01,90',H'080',H'6160'\n*\n         DC    X'0E,07',CL8'VSBASIC ',H'1'\n         DC    X'02,50',H'255',H'6160'\n*\n         DC    X'FF,07',CL8'DEFAULT ',H'2'\n         DC    X'01,90',H'080',H'6160'\n         DC    X'02,50',H'255',H'6160'\n*----------------------------------------------------------------------\n         EJECT\n*\n         PRINT GEN\n@DS      GTEDADAT                                                      X\n               DSNAM=X,STATS=NEW,NDISP=CATLG,CDISP=DELETE,TRK=YES,     X\n               PRIME=2,SECND=2,DIR=10,UNIT=SYSTSO,BLKSZ=0,DSORG=PO,    X\n               LRECL=0,RECFM=FB\n         PRINT NOGEN\n*\nOLD0001  DC    F'1',A(MSG0001)\nMSG0001  DC    H'55',H'00',CL51'NSP0001 RECORD FORMAT IS INVALID FOR THX\n               IS DATA TYPE'\n*\nOLD0002  DC    F'1',A(MSG0002)\nMSG0002  DC    H'35',H'00',CL31'NSP0002 DATASET WAS NOT CREATED'\n*\nOLD0003  DC    F'3',A(MSG0003),A(MSG0003P),A(0)\n*                               ....+....1....+.. . .2....+....3....+\nMSG0003  DC    H'30',H'00',CL26'NSP0003 DATASET '''' CREATED'\nMSG0003P DC    H'16',H'08',CL12'PARTITIONED '\nMSG0003S DC    H'15',H'08',CL12'SEQUENTIAL '\nMSG0003B DC    H'0',H'17',CL44' '\n*\nOLD0004  DC    F'1',A(MSG0004)\nMSG0004  DC    H'33',H'00',CL29'NSP0004 IMPROPER DATASET NAME'\n*\nCONSTLEN EQU   *-CONSTDTA               TOTAL LENGTH OF CONSTANTS\n*\n         EJECT\n**********************************************************************\n***                                                                ***\n***    COMMAND OPERANDS                                            ***\n***                                                                ***\n**********************************************************************\nPARMPCL  IKJPARM  DSECT=PARMPDL\n*\nNAME     IKJPOSIT DSNAME,PROMPT='DATASET NAME +',USID,                 X\n               HELP=('NAME OF SEQUENTIAL DATASET OR LIBRARY (PARTITIONEX\n               D DATASET) TO BE CREATED')\n*\nTYPE     IKJKEYWD\n         IKJNAME 'ASM'\n         IKJNAME 'CLIST'\n         IKJNAME 'CNTL',ALIAS=('JCL')\n         IKJNAME 'COBOL'\n         IKJNAME 'COMMAND'\n         IKJNAME 'DATA'\n         IKJNAME 'FORT',ALIAS=('FORTGI','FORTVS','FORTRAN')\n         IKJNAME 'LIST'\n         IKJNAME 'LOAD'\n         IKJNAME 'OBJ',ALIAS=('OBJECT')\n         IKJNAME 'PLI',ALIAS=('PL1')\n         IKJNAME 'PLIF',ALIAS=('PL1F')\n         IKJNAME 'TEXT'\n         IKJNAME 'VSBASIC'\n*\nORG      IKJKEYWD DEFAULT='PARTITIONED'\n         IKJNAME  'SEQUENTIAL'\n         IKJNAME  'PARTITIONED',ALIAS=('PDS','LIBRARY')\n*\nRFORM    IKJKEYWD\n         IKJNAME  'FIXED'\n         IKJNAME  'VARIABLE'\n         IKJNAME  'UNFORMATTED'\n*\n         IKJENDP\n*\n         EJECT\n**********************************************************************\n***                                                                ***\n***   DATA AREA OBTAINED WITH LINKSAVE                             ***\n***                                                                ***\n**********************************************************************\nWORK0    DSECT                          AREA-0 FOR VARIABLES\nMYSAVE   DS    18F                      REGISTER SAVE AREA\nCPPLPTR  DS    F                        INITIAL VALUE OF R1 (CPPLADDR)\nRETCDE   DS    F                        INTERNAL RETURN CODE\nCOMPCODE DS    F                        PROGRAM COMPLETION CODE\n*\n         EJECT\n**********************************************************************\n***                                                                ***\n***  DATA VARIABLES                                                ***\n***                                                                ***\n**********************************************************************\nWORK1    DSECT                          AREA-1 FOR VARIABLES\nPPR10SAV DS    F                        RETURN ADDRESS SAVE AREA\nPAR10SAV DS    F                        RETURN ADDRESS SAVE AREA\nLOR10SAV DS    F                        RETURN ADDRESS SAVE AREA\nDAR10SAV DS    F                        RETURN ADDRESS SAVE AREA\nDCR10SAV DS    F                        RETURN ADDRESS SAVE AREA\nERR10SAV DS    F                        RETURN ADDRESS SAVE AREA\nALR10SAV DS    F                        RETURN ADDRESS SAVE AREA\nMYPPL    DS    7F                       PARSE PARAMETER LIST\nMYECB    DS    F                        ECB FOR PARSE\nMYANS    DS    F                        POINTER TO THE PDL\nMYIOPL   DS    4F                       IOP LIST FOR PUTLINE\nMYPTPB   DS    3F                       PUTLINE PARM BLOCK\nLOADDR   DS    F                        ADDR OF LOW LEVEL QUALIFIER\nLOLEN    DS    H                        LENGTH OF LOW LEVEL QUALIFIER\nLOTEXT   DS    CL8                      TEXT OF LOW LEVEL QUALIFIER\nDATYPADR DS    F                        ADDR OF TABLE ENTRY\nDCBADDR  DS    F                        DCB ENTRY ADDRESS\nDSNLEN   DS    H                        TOTAL LENGTH OF DSN\nOLD0003V DS    F,3A                     WORK O.L.D. FOR MSG #3\nMSG0003C DS    2H,CL44                  WORK MSG SEG #2 FOR MSG #3\n         PRINT GEN\nDS       GTEDADAT MAP=ONLY,                                            X\n               DSNAM=X,STATS=NEW,NDISP=CATLG,CDISP=DELETE,TRK=YES,     X\n               PRIME=2,SECND=2,DIR=10,UNIT=SYSTSO,BLKSZ=0,DSORG=PO,    X\n               LRECL=0,RECFM=FB\n         PRINT NOGEN\nWORK1END DS    0D\nWORK1LEN EQU   *-WORK1                  TOTAL LENGTH OF WORK-1 AREA\n*\n         EJECT\n**********************************************************************\n***                                                                ***\n***   MAPPING MACROS                                               ***\n***                                                                ***\n**********************************************************************\n         CVT                          , CVTMAP FOR IKJPARS\n         PRINT GEN\n         IKJCPPL                        COMMAND PROCESSOR PARM LIST\n         IKJPPL                         PARSE PARM LIST\n         IKJPTPB                        PUTLINE PARM BLOCK\n         PRINT NOGEN\n         IEFZB4D0                       MAPS SVC-99 CONTROL BLOCKS\n         IKJEFFDF DFDSECT=YES,DFDSEC2=YES  MAPS IKJEFF18 CONTROL BLOCKS\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REGISTER": {"ttr": 1800, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         REGISTER\n         LCLA  &N\n         SPACE\n*****    REGISTER EQUATES\n         SPACE\n&N       SETA  0\n.LOOP    ANOP\nR&N      EQU   &N\n         AIF   (&N EQ 15).OUT\n&N       SETA  &N+1\n         AGO   .LOOP\n.OUT     ANOP\n         SPACE\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SAL": {"ttr": 1802, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         PRINT GEN\n  TITLE 'SHOW TSO ALLOCATIONS USING DYNAMIC ALLOCATION    '\n*=====================================================================\n*\n* FUNCTION:\n*            \"SAL\" IS A PROGRAM TO REPLACE THE \"LISTALC\" TSO\n*            COMMAND FOR MOST USES.  ITS PURPOSE IS TO TELL THE\n*            TSO USER WHAT DATASETS AND DDNAMES ARE CURRENTLY\n*            ALLOCATED, HOW THEY ARE ALLOCATED, AND TO TELL HIM\n*            THIS IN A READABLE FORMAT.\n*\n*            SAL WRITES A REPORT WITH THE FOLLOWING INFORMATION\n*            FOR EACH ALLOCATION:\n*\n*               DDNAME\n*               DATASET NAME\n*               STATUS\n*               NORMAL DISPOSITION\n*               DATASET TYPE\n*\n*            THIS PROGRAM WORKS BY USING DYNAMIC ALLOCATION INFORMATION\n*            RETRIEVAL. IT RETRIEVES INFORMATION ABOUT EACH RELATIVE\n*            REQUEST (REQUEST 1, REQUEST 2, ...) UNTIL THE LAST\n*            RELATIVE REQUEST HAS BEEN PROCESSED.\n*            (SEE THE \"OS/VS MVS SYSTEM PROGRAMMING LIBRARY:\n*            JOB MANAGEMENT\" MANUAL FOR DETAILS ON HOW DYNAMIC\n*            ALLOCATION CAN BE USED TO RETRIEVE ALLOCATION INFORMATION)\n*\n*            THIS CODE HAS BEEN WRITTEN TO BE REENTRANT, SO THAT\n*            THE PROGRAM MAY BE PLACED IN \"LPALIB\" FOR BETTER\n*            PERFORMANCE.\n*\n         EJECT\n*\n* INPUT:\n*            NONE\n*\n*\n* OUTPUT:\n*            TO FILE SYSPRINT: HEADING LINE, AND A LINE FOR EACH\n*            RELATIVE REQUEST, SHOWING WHAT'S ALLOCATED.\n*            2 BLANK LINES ARE PRINTED BEFORE THE HEADING, AND A BLANK\n*            LINE IS PRINTED AT THE END OF THE REPORT.\n*\n*            THE SYSPRINT FILE IS DEFINED WITH THE FOLLOWING\n*            ATTRIBUTES:\n*              RECFM=FBA, DSORG=PS\n*\n*\n* ERROR ROUTINES:\n*\n*            IF THE SYSPRINT FILE COULDN'T BE OPENED, THE PROGRAM\n*            ABENDS WITH A USER 013 CODE.\n*\n*            IF SYSPRINT IS ALLOCATED TO A DATASET WITH THE WRONG\n*            ATTRIBUTES, THE USER WILL GET A SYSTEM X13 ABEND CODE.\n*\n*            IF GETMAIN CAN'T GET ENOUGH STORAGE, IT ABENDS.\n*\n*            IF SVC 99 RETURNED A NON-ZERO RETURN CODE, THE PROGRAM\n*            ENDS, PASSING ALONG THAT RETURN CODE.\n*\n         EJECT\n*\n* REGISTERS:\n*            R4 - POINTS TO REQUEST BLOCK POINTER\n*            R5 - POINTS TO REQUEST BLOCK START\n*            R6 - POINTS TO A TEXT UNIT ADDRESS\n*            R7 - POINTS TO A TEXT UNIT\n*            R8 - POINTS TO DCB\n*            R9 - USED TO BUILD OPEN AND CLOSE PARM LISTS\n*           R10 - HOLDS RELATIVE REQUEST NUMBER\n*\n*           R13 - BASE REG. FOR THIS PROGRAM (FROM XSAVE1 MACRO)\n*\n*           R15 - HOLDS RETURN CODE FROM SVC 99.  I WON'T CHANGE IT,\n*                 SO THIS RETURN CODE WILL BE PASSED WHEN I END.\n*\n*\n* LINKAGE:\n*\n*         MVS STANDARD LINKAGE CONVENTIONS ARE USED.\n*\n*\n* DEPENDENCIES/RESTRICTIONS:\n*\n*         USES MACROS XSAVE1 AND XRETURN FOR LINKAGE\n*         USES MACRO REGISTER FOR DEFINING REGISTER SYMBOLIC NAMES\n*         USES MACROS DYNATXTU AND DYNABLD FOR BUILDING DYNAMIC\n*         ALLOCATION CONTROL BLOCKS\n*\n*         THERE IS AN MVS/TSO HELP ENTRY FOR THIS PROGRAM.\n*\n         EJECT\n*\n* STORAGE LAYOUT:\n*\n*         ------------------------------------------------------\n*         I  STANDARD SAVE AREA                                I\n*         I                                                    I\n*         ------------------------------------------------------\n*         I  REQUEST BLOCK POINTER                             I\n*         ------------------------------------------------------\n*         I  REQUEST BLOCK                                     I\n*         I                                                    I\n*         ------------------------------------------------------\n*         I  TEXT UNIT ADDRESSES                               I\n*         I                                                    I\n*         ------------------------------------------------------\n*         I  TEXT UNITS                                        I\n*         I                                                    I\n*         I                                                    I\n*         ------------------------------------------------------\n*         I  OUTPUT BUFFER                                     I\n*         ------------------------------------------------------\n*         I  OUTPUT DATASET CONTROL BLOCK                      I\n*         I                                                    I\n*         ------------------------------------------------------\n*         I  OPEN MACRO                                        I\n*         I                                                    I\n*         ------------------------------------------------------\n*         I  CLOSE MACRO                                       I\n*         I                                                    I\n*         ------------------------------------------------------\n*\n*\n* NOTES:\n*         ALTHOUGH TU7, THE DSORG TEXT UNIT, IS DEFINED IN THE\n*         PROGRAM, IT IS NOT CURRENTLY USED.  THIS TEXT UNIT MAY\n*         BE REPLACED BY ANOTHER ONE IF OTHER INFORMATION IS\n*         DESIRED.\n*\n         EJECT\n*\n* CHANGE LOG:\n*\n*          3/22/83  COMPLETE,\n*                   FULL FUNCTION: DSN, DDN, STATUS, NORMAL DISP,\n*                   AND DATASET TYPE ARE PRINTED OUT WITH AN\n*                   UNDERLINED TITLE LINE AND BLANK LINES AT THE\n*                   BEGINNING AND END OF THE REPORT.\n*\n*          5/10/83  DOCUMENTATION IMPROVED, AND TEST FOR \"UNCAT\"\n*                   NORMAL DISPOSITION ADDED.\n*\n*          5/11/83  CHANGED PRINT LINE LENGTH FROM 81 TO 121 BYTES.\n*                   SINCE LRECL IS NOT CODED ON THE DCB, IT SHOULD\n*                   WORK WITH SIZES BETWEEN 81 AND 121 SUCCESSFULLY.\n* AUTHOR:\n*         RIC FORD                 (617) 466-2133\n*         COMPUTER CENTER\n*         GTE LABORATORIES\n*         40 SYLVAN ROAD\n*         WALTHAM, MASSACHUSETTS  02254\n*\n*\n*=====================================================================\n         EJECT\n*---------------------------------------------------------------------\n* ENTER PROGRAM AND MAP GETMAINED STORAGE AREA\n*---------------------------------------------------------------------\n*\nSAL      XSAVE1 OPT=CSECT,REEN=STGSIZE,REG=12\n*\n         USING STGAREA,R13\n*\n*---------------------------------------------------------------------\n* BUILD REQUEST BLOCK POINTER AND REQUEST BLOCK\n*---------------------------------------------------------------------\n         LA    R4,RBPOINTR        GET R.B. POINTER ADDRESS\n         USING S99RBPTR,R4        MAP POINTER\n         LA    R5,REQBLOCK        GET REQUEST BLOCK ADDRESS\n         USING S99RB,R5           MAP REQUEST BLOCK\n         ST    R5,RBPOINTR        STORE POINTER TO REQUEST BLOCK\n         OI    S99RBPTR,S99RBPND  MARK IT LAST POINTER\n         XC    S99RB(RBLEN),S99RB ZERO OUT REQUEST BLOCK\n         MVI   S99RBLN,RBLEN      FILL IN REQUEST BLOCK'S LENGTH FIELD\n         MVI   S99VERB,S99VRBIN   SET VERB TO DO INFOMATION RETRIEVAL\n*\n         LA    R6,$ADDRLST        POINT TO FIRST T.U. ADDRESS\n         USING S99TUPL,R6         MAP IT\n         ST    R6,S99TXTPP        STORE ADDRESS LIST POINTER IN R.B.\n*\n         EJECT\n*---------------------------------------------------------------------\n*  BUILD TEXT UNIT ADDRESS LIST\n*---------------------------------------------------------------------\n         DYNABLD $ADDRLST,(TU1,TU2,TU3,TU4,TU5,TU6,TU7,TU8)  BUILD LIST\n*\n*---------------------------------------------------------------------\n* BUILD DCB FOR WRITING ALLOCATION INFORMATION.\n*---------------------------------------------------------------------\n         LA    R8,SYSPRINT               POINT TO DCB\n         USING IHADCB,R8                 MAP DCB\n         MVC   SYSPRINT(DCBSIZE),OUTDCB  COPY DCB INTO GETMAINED AREA\n*\n         EJECT\n*---------------------------------------------------------------------\n*  OPEN THE OUTPUT FILE\n*---------------------------------------------------------------------\n         LA    R9,SYSPRINT             GET DCB ADDRESS\n         ICM   R9,PARMMASK,OPENLIST    FILL IN OPEN PARMS BYTE\n         ST    R9,OPENLSTD             STORE IT INTO DCB\n         OPEN  (SYSPRINT,(OUTPUT)),MF=(E,OPENLSTD)  TRY TO OPEN OUTPUT X\n                                                  FILE USING PARM-LIST.\n         TM    DCBOFLGS,DCBOFOPN    DID OPEN COMPLETE SUCCESSFULLY?\n         BO    WRTHEADR             YES, GO WRITE HEADER LINE\n         ABEND ABCODE               DIDN'T OPEN, GIVE HIM AN OPEN ABEND\n*\n         EJECT\n*---------------------------------------------------------------------\n*  WRITE THE HEADER LINES\n*---------------------------------------------------------------------\nWRTHEADR EQU   *\n         PUT   SYSPRINT,BLANKS\n         PUT   SYSPRINT,BLANKS\n         PUT   SYSPRINT,HEADER1\n         PUT   SYSPRINT,HEADER2\n*\n         EJECT\n*---------------------------------------------------------------------\n*  SET DYNAMIC ALLOCATION RELATIVE REQUEST NUMBER TO 1 TO\n*  RETRIEVE INFORMATION ABOUT THE FIRST ALLOCATION.\n*---------------------------------------------------------------------\n         LA    R10,1                SET RELATIVE REQUEST NO. TO 1\n*\n         USING S99TUNIT,R7          R7 WILL MAP TEXT UNIT\n*---------------------------------------------------------------------\n* INVOKE SVC 99, DYNAMIC ALLOCATION, FOR INFORMATION RETRIEVAL. THE\n* TEXT UNITS REQUEST INFORMATION ABOUT CURRENT ALLOCATIONS AND PROVIDE\n* SPACE FOR THE INFORMATION RETURNED BY SVC 99.\n*   R10 HOLDS RELATIVE REQUEST NUMBER FOR THIS INVOCATION.\n*   R4 HOLDS ADDRESS OF REQUEST BLOCK POINTER.\n*---------------------------------------------------------------------\nSVC99    EQU   *\n         LA    R7,TU1                    POINT TO FIRST TEXT UNIT\n         MVC   S99TUNIT(TUSSIZE),RELNOTU COPY ALL TEXT UNITS INTO      X\n                                         GETMAINED AREA\n*\n         STCM  R10,REQMASK,S99TUPAR STORE REL. REQ. # INTO T.U. PARM.\n         LR    R1,R4                POINT TO REQUEST BLOCK POINTER\n         SVC   99                   GET THE INFORMATION\n*\n         CH    R15,ZERO             TEST RETURN CODE\n         BNE   BADRC                IF IT'S NOT ZERO GO PROCESS ERROR\n*\n         EJECT\n*---------------------------------------------------------------------\n*  SVC 99 COMPLETION WAS SUCCESSFUL.  PROCESS THE INFORMATION.\n*---------------------------------------------------------------------\n         MVC   PUTLINED(LINELEN),BLANKS  CLEAR OUTPUT BUFFER\n*\n         LA    R7,TU3                  MAP DDNAME TEXT UNIT\n         MVC   DDN(L'DDN),S99TUPAR     GET DDNAME IN OUTPUT BUFFER\n*\n         LA    R7,TU4                  MAP DSNAME TEXT UNIT\n         MVC   DSN(L'DSN),S99TUPAR     GET DSNAME IN OUTPUT BUFFER\n*\n         LA    R7,TU6                  MAP STATUS TEXT UNIT\n         TM    S99TUPAR,SHRQ           IS IT SHR?\n         BNO   TESTNEW                 NO, TRY AGAIN\n         MVC   STATUS(STATLEN),SHR     PUT \"SHR\" IN BUFFER\n         B     ENDSTAT                 GO LOOK AT TYPE TEXT UNIT\nTESTNEW  EQU   *\n         TM    S99TUPAR,NEWQ           IS IT NEW?\n         BNO   TESTMOD                 NO, TRY AGAIN\n         MVC   STATUS(STATLEN),NEW     PUT \"NEW\" IN BUFFER\n         B     ENDSTAT                 GO LOOK AT TYPE\nTESTMOD  EQU   *\n         TM    S99TUPAR,MODQ           IS IT MOD?\n         BNO   TESTOLD                 NO, TRY AGAIN\n         MVC   STATUS(STATLEN),MOD     PUT \"MOD\" IN BUFFER\n         B     ENDSTAT                 GO LOOK AT TYPE\nTESTOLD  EQU   *\n         TM    S99TUPAR,OLDQ           IS IT OLD?\n         BNO   NOSTAT                  NO, GO PUT BLANKS IN\n         MVC   STATUS(STATLEN),OLD     PUT \"OLD\" IN BUFFER\n         B     ENDSTAT                 GO LOOK AT TYPE\nNOSTAT   EQU   *                       STATUS RETURNED IS UNDEFINED\n         MVC   STATUS(STATLEN),BLANKS MOVE BLANKS IN\n*\n         EJECT\n*\nENDSTAT  EQU   *\n         LA    R7,TU5                  MAP DATASET NORMAL DISP. T.U.\n*\n         TM    S99TUPAR,PASSQ          IS NORMAL DISP. \"PASS\"?\n         BNO   TESTKEEP\n         MVC   DISP(DISPLEN),PASS\n         B     ENDDISP\nTESTKEEP EQU   *\n         TM    S99TUPAR,KEEPQ          IS NORMAL DISP. \"KEEP\"?\n         BNO   TESTDEL\n         MVC   DISP(DISPLEN),KEEP\n         B     ENDDISP\nTESTDEL  EQU   *\n         TM    S99TUPAR,DELETEQ        IS NORMAL DISP. \"DELETE\"?\n         BNO   TESTUNCT\n         MVC   DISP(DISPLEN),DELETE\n         B     ENDDISP\nTESTUNCT EQU  *\n         TM    S99TUPAR,UNCATQ         IS NORMAL DISP. \"UNCAT\"?\n         BNO   TESTCATL\n         MVC   DISP(DISPLEN),UNCAT\n         B     ENDDISP\nTESTCATL EQU  *\n         TM    S99TUPAR,CATLGQ         IS NORMAL DISP. \"CATLG\"?\n         BNO   NODISP                  NO, THERE'S NO VALID DISP.\n         MVC   DISP(DISPLEN),CATLG\n         B     ENDDISP\nNODISP   EQU   *                       DATASET IS UNDEFINED DISP\n         MVC   DISP(DISPLEN),BLANKS    MOVE BLANKS IN\n*\n         EJECT\nENDDISP  EQU   *\n         LA    R7,TU8                  MAP DATASET TYPE TEXT UNIT\n*\n         TM    S99TUPAR,DUMMQ          IS DS DUMMY TYPE?\n         BNO   TESTTERM\n         MVC   TYPE(TYPELEN),DUMMY\n         B     ENDTYPE\nTESTTERM EQU   *\n         TM    S99TUPAR,TERMQ          IS DS TERMINAL TYPE?\n         BNO   TESTSYOU\n         MVC   TYPE(TYPELEN),TERMINAL\n         B     ENDTYPE\nTESTSYOU EQU   *\n         TM    S99TUPAR,SYSOUTQ        IS DATASET SYSOUT TYPE?\n         BNO   TESTSYIN\n         MVC   TYPE(TYPELEN),SYSOUT\n         B     ENDTYPE\nTESTSYIN EQU   *\n         TM    S99TUPAR,SYSINQ         IS DATASET SYSIN TYPE?\n         BNO   NOTYPE\n         MVC   TYPE(TYPELEN),SYSIN\n         B     ENDTYPE\nNOTYPE   EQU   *                       DATASET IS UNDEFINED TYPE\n         MVC   TYPE(TYPELEN),BLANKS    MOVE BLANKS IN\n*\nENDTYPE  EQU   *\n         EJECT\n*---------------------------------------------------------------------\n*  WRITE OUT REPORT LINE.\n*---------------------------------------------------------------------\n         PUT   SYSPRINT,PUTLINED       WRITE OUTPUT BUFFER OUT\n*\n*\n*---------------------------------------------------------------------\n*  END IF THIS IS THE LAST REQUEST. OTHERWISE, INCREMENT THE RELATIVE\n*  REQUEST NUMBER AND GO INVOKE SVC 99 AGAIN.\n*---------------------------------------------------------------------\n         LA    R7,TU2                  POINT TO LAST-REL# INDICATOR T.U\n         TM    S99TUPAR,LASTREL#       WAS THIS THE LAST RELATIVE REQ?\n         BO    XRETURN                 YES, GO CLOSE AND END\n         LA    R10,1(R10)              NO, INCREASE REL. REQUEST #\n         B     SVC99                   PROCESS NEXT REL. REQUEST\n*\n         EJECT\n*---------------------------------------------------------------------\n*  SVC 99 JUST GOT A BAD RETURN CODE.  WE'LL PASS IT OUT VIA R15.\n*---------------------------------------------------------------------\nBADRC    EQU   *\n*\n*---------------------------------------------------------------------\n*  CLOSE OUTPUT FILE AND END\n*---------------------------------------------------------------------\nXRETURN  EQU   *\n         PUT   SYSPRINT,BLANKS\n         LA    R9,SYSPRINT             GET DCB ADDRESS\n         ICM   R9,PARMMASK,CLOSLIST    FILL IN CLOSE PARMS BYTE\n         ST    R9,CLOSLSTD             STORE IT INTO DCB\n         CLOSE (SYSPRINT),MF=(E,CLOSLSTD)  CLOSE THE OUTPUT FILE\n*\n         XRETURN RTN=RC      END\n*\n         EJECT\n**********************************************************************\n*  CREATE CONSTANTS\n**********************************************************************\nZERO     DC    F'0'\nDUMMY    DC    CL8'DUMMY   '\nTERMINAL DC    CL8'TERMINAL'\nSYSIN    DC    CL8'SYSIN   '\nSYSOUT   DC    CL8'SYSOUT  '\n*\nBLANKS   DC    121CL1' '\n*\nOLD      DC    CL5'OLD  '\nMOD      DC    CL5'MOD  '\nNEW      DC    CL5'NEW  '\nSHR      DC    CL5'SHR  '\n*\nPASS     DC    CL6'PASS  '\nKEEP     DC    CL6'KEEP  '\nDELETE   DC    CL6'DELETE'\nCATLG    DC    CL6'CATLG '\nUNCAT    DC    CL6'UNCAT '\n*\n         EJECT\n*---------------------------------------------------------------------\n*  CREATE HEADER LINE 1\n*---------------------------------------------------------------------\nHEADER1  DS    0F\n         DC    CL1'1'\n         DC    CL8'DDNAME  '\n         DC    CL1' '\n         DC    CL44'DATASET NAME                                '\n         DC    CL1' '\n         DC    CL5'STAT.'\n         DC    CL1' '\n         DC    CL6'N-DISP'\n         DC    CL2' '\n         DC    CL8'DS-TYPE '\n         DC    CL44'                                            '\n*\n*---------------------------------------------------------------------\n*  CREATE HEADER LINE 2\n*---------------------------------------------------------------------\nHEADER2  DS    0F\n         DC    CL1' '\n         DC    CL8'--------'\n         DC    CL1' '\n         DC    CL44'--------------------------------------------'\n         DC    CL1' '\n         DC    CL5'---- '\n         DC    CL1' '\n         DC    CL6'------'\n         DC    CL2'  '\n         DC    CL8'--------'\n         DC    CL44'                                            '\n*\n         EJECT\n*---------------------------------------------------------------------\n*  CREATE TEXT UNITS\n*---------------------------------------------------------------------\nRELNOTU  DYNATXTU DINRELNO,2,F00  DEFINE RELATIVE REQUEST NO. T.U.\nRTLSTTU  DYNATXTU DINRTLST,1,F00  DEFINE RETURN-LAST-RELATIVE-         X\n                                  ENTRY-INDICATOR TEXT UNIT\nRTDDNTU  DYNATXTU DINRTDDN,8,F40       DEFINE RETURN-DDN T.U.\nRTDSNTU  DYNATXTU DINRTDSN,44,F40      DEFINE RETURN-DSN TEXT UNIT\nRTNDPTU  DYNATXTU DINRTNDP,1,F00       DEFINE RETURN-NORMAL-DISP T.U.\nRTSTATU  DYNATXTU DINRTSTA,1,F00       DEFINE RETURN-STATUS T.U.\nRTORGTU  DYNATXTU DINRTORG,2,F00       RETURN-DS-ORGANIZATION T.U.\nRTTYPTU  DYNATXTU DINRTTYP,1,F00       DEFINE RETURN-DS-TYPE T.U.\nTUSSIZE  EQU   *-RELNOTU\n         EJECT\n*---------------------------------------------------------------------\n*  CREATE LIST FORMS OF OPEN AND CLOSE\n*---------------------------------------------------------------------\nOPENLIST OPEN  (OUTDCB,(OUTPUT)),MF=L  CREATE OPEN PARMS LIST\nCLOSLIST CLOSE (OUTDCB),MF=L           CREATE CLOSE PARMS LIST\n*\n         EJECT\n*---------------------------------------------------------------------\n*  CREATE DATASET CONTROL BLOCK FOR OUTPUT.\n*---------------------------------------------------------------------\nOUTDCB   DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=(PM),RECFM=FBA\nDCBSIZE  EQU   *-OUTDCB\n*\n         EJECT\n**********************************************************************\n*  DEFINE DSECTS TO MAP STORAGE\n**********************************************************************\n*---------------------------------------------------------------------\n*  DEFINE ENTIRE GETMAINED STORAGE AREA\n*---------------------------------------------------------------------\nSTGAREA  DSECT\nSAVEAREA DS    18F           SAVE AREA\nRBPOINTR DS    F             REQUEST BLOCK POINTER\nREQBLOCK DS    XL20          REQUEST BLOCK\n$ADDRLST DS    8A            TEXT UNIT ADDRESSES\n         EJECT\nTU1      DYNATXTU DINRELNO,2,F00  DEFINE RELATIVE REQUEST NO. T.U.\nTU2      DYNATXTU DINRTLST,1,F00  DEFINE RETURN-LAST-RELATIVE-ENTRY-   X\n                                  -INDICATOR TEXT UNIT\nTU3      DYNATXTU DINRTDDN,8,F40       DEFINE RETURN-DDN TEXT UNIT\nTU4      DYNATXTU DINRTDSN,44,F40      DEFINE RETURN-DSN TEXT UNIT\nTU5      DYNATXTU DINRTNDP,1,F00       DEFINE RETURN-NORMAL-DISP. T.U.\nTU6      DYNATXTU DINRTSTA,1,F00       DEFINE RETURN-STATUS T.U.\nTU7      DYNATXTU DINRTORG,2,F00       RETURN-DS-ORGANIZATION T.U.\nTU8      DYNATXTU DINRTTYP,1,F00       DEFINE RETURN-DS-TYPE T.U.\n         EJECT\nPUTLINED DS    0CL121\nANSICNTL DS    CL1\nDDN      DS    CL8\n         DS    CL1\nDSN      DS    CL44\n         DS    CL1\nSTATUS   DS    CL5\n         DS    CL1\nDISP     DS    CL6\n         DS    CL2\nTYPE     DS    CL8\n         DS    CL44\n         PRINT NOGEN\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=(PM),RECFM=FBA\n         PRINT GEN\nOPENLSTD OPEN  (OUTDCB,(OUTPUT)),MF=L\nCLOSLSTD CLOSE (OUTDCB),MF=L\nSTGSIZE  EQU   *-STGAREA\n         EJECT\n*---------------------------------------------------------------------\n* MAP THE SVC 99 PARAMETER LIST:\n*\n*   1. REQUEST BLOCK POINTER, POINTED TO BY R1\n*   2. A DYNAMIC ALLOCATION REQUEST BLOCK\n*   3. TEXT UNIT ADDRESSES LIST\n*   4. TEXT UNITS\n*\n*---------------------------------------------------------------------\n         IEFZB4D0            MAP SVC 99 PARAMETER LIST\nRBLEN    EQU   (S99RBEND-S99RB)     LENGTH OF REQUEST BLOCK\n*\n         EJECT\n*---------------------------------------------------------------------\n*  MAP DCB\n*---------------------------------------------------------------------\n         IHADCB DSORG=QS     MAP THE DCB FIELDS\n*\n         EJECT\n**********************************************************************\n*  DEFINE MORE SYMBOLS\n**********************************************************************\nSYMBOLS  DSECT\n         REGISTER            DEFINE REGISTERS\nSTATLEN  EQU   5             LENGTH OF STATUS FIELD\nDISPLEN  EQU   6             LENGTH OF STATUS FIELD\nTYPELEN  EQU   8             LENGTH OF TYPE FIELD\nLINELEN  EQU   121           SIZE OF OUTPUT PRINT LINE\n*\nABCODE   EQU   13            USER ABEND CODE IF SYSPRINT WON'T OPEN\n*\nLASTREL# EQU   X'80'         THIS BIT ON IF LAST RELATIVE REQUEST\n*\nDUMMQ    EQU   X'80'         THIS BIT ON IF TYPE IS DUMMY\nTERMQ    EQU   X'40'         THIS BIT ON IF TYPE IS TERMINAL\nSYSINQ   EQU   X'20'         THIS BIT ON IF TYPE IS SYSIN\nSYSOUTQ  EQU   X'10'         THIS BIT ON IF TYPE IS SYSOUT\n*\nSHRQ     EQU   X'08'         THIS BIT ON IF STATUS IS SHR\nNEWQ     EQU   X'04'         THIS BIT ON IF STATUS IS NEW\nMODQ     EQU   X'02'         THIS BIT ON IF STATUS IS MOD\nOLDQ     EQU   X'01'         THIS BIT ON IF STATUS IS OLD\n*\nPASSQ    EQU   X'10'         THIS BIT ON IF NORMAL DISP IS PASS\nKEEPQ    EQU   X'08'         THIS BIT ON IF NORMAL DISP IS KEEP\nDELETEQ  EQU   X'04'         THIS BIT ON IF NORMAL DISP IS DELETE\nCATLGQ   EQU   X'02'         THIS BIT ON IF NORMAL DISP IS CATLG\nUNCATQ   EQU   X'01'         THIS BIT ON IF NORMAL DISP IS UNCATLG\n*\nREQMASK  EQU   B'0011'       LOWER-ORDER HALF WORD OF REG. HOLDS       X\n                             RELATIVE REQUEST NUMBER\nPARMMASK EQU   B'1000'       HIGH-ORDER BYTE IS PARM FOR OPEN/CLOSE.\n         EJECT\n*---------------------------------------------------------------------\n*  IDENTIFY THE DYNAMIC ALLOCATION FUNCTION CODES\n*  (OR \"TEXT UNIT KEYS\")\n*---------------------------------------------------------------------\n         IEFZB4D2            MAP SVC 99 TEXT UNIT KEYS\n*\n*\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SALHELP": {"ttr": 2056, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ")F\nSAL, short for Show ALlocations, shows how all your files and datasets\nare allocated.\n\n\nHere is a description of the information shown:\n\n      DDNAME:  Data definition name -- the name used in a program,\n               to say where the program is to read or write.\n               (When SAL lists a dataset without a DDNAME, the\n               DDNAME associated with it is the first one above it.)\n\nDATASET NAME:  The dataset name is the name used by the computer's\n               operating system to find data files.\n\n       STAT.:  Dataset status.  OLD means you have control of the\n               dataset, no one else can use it, and when you write to\n               the dataset you'll wipe out the previous version.  SHR\n               means you will share the dataset with another job or\n               user who also allocates the dataset as SHR -- this\n               would be used when you're only reading the dataset.\n               MOD says that when you write to the dataset, you'll\n               stick the data at the end of what was there before, so\n               you'll still have the old data, too.\n\n      N-DISP:  Normal disposition.  This says what the computer's\n               operating system will do with the data file when\n               you LOGOFF normally or free the dataset.  DELETE\n               means the dataset will be deleted.  KEEP means\n               that it will be kept.  CATLG means it will be kept\n               and cataloged.\n\n     DS-TYPE:  Dataset type -- whether the dataset is a TERMINAL, or\n               a print dataset (SYSOUT), or a DUMMY dataset.  Data\n               written to a DUMMY dataset is thrown away.\n\n\nNote:  SAL writes her information to the SYSPRINT DDNAME, so you\n       can send the information to a dataset or printer by\n       reallocating SYSPRINT. (It expects a sequential dataset\n       with RECFM=FBA, LRECL=121, if you send output to a dataset.)\n\n\n\nERROR CODES:  If SYSPRINT isn't allocated correctly, you'll probably\nget an x13 abend code.  The return code is 0 when SAL works\nsuccessfully.\n\n\n)X SYNTAX:\n              SAL\n\n\n  Options  - none\n  Defaults - none\n  Alias    - none, but LISTALC command is similar.\n)O\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XRETURN": {"ttr": 2058, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   XRETURN &RTN=,&REEN=\n.*********************************************************************\n.*  DATE     01/81                                                   *\n.*  AUTHOR   MARK SCHERFLING                                         *\n.*  MACRO    XRETURN                                                 *\n.*                                                                   *\n.*  FUNCTION: USING STANDARD LINKAGE, RETURN A CALLING ROUTINES      *\n.*     REGISTERS AND RETURN CONTROL TO THAT ROUTINE                  *\n.*                                                                   *\n.*  PARAMETERS:                                                      *\n.*     RTN=  RC    - SAVE REGISTER 15 THAT CONTAINS A RETURN CODE    *\n.*           VALUE - SAVE REGISTER 0 THAT CONTAINS A COMPUTED VALUE  *\n.*           BOTH  - SAVE BOTH REGISTER 15 AND 0                     *\n.*                 - DEFAULT IS RETURN ALL SAVED REGISTERS           *\n.*     REEN= VALUE - NUMBER OF BYTES USED FOR A LOCAL SAVE AREA      *\n.*                   (INCLUDING THE 72 BYTES USED FOR REG SVAREA     *\n.*********************************************************************\n.*\n         AIF   ('&REEN' EQ '').NOFREE\n&LABEL   L     12,4(,13)          SAVE ADDR OF NEXT SAVE AREA\n         LR    10,0               SAVE REG 0\n         LR    11,15              SAVE REG 15 - MAY HAVE RC\n         LA    0,&REEN            LOAD USER STORAGE AREA\n         LR    1,13               MOVE ADDR OF AREA TO FREE\n         FREEMAIN  R,LV=(0),A=(1) FREE THE SAVE AREA\n         LR    0,10               RETURN THE REGISTER VALUE\n         LR    15,11              RETURN RC REGISTER\n         LR    13,12              RETURN ADDR OF SAVE AREA\n.*\n         AGO   .NEXT\n.NOFREE  ANOP\n&LABEL   L     13,4(,13)          LOAD CALLERS SAVE AREA\n.*\n.NEXT    AIF   ('&RTN' EQ '').SAVEALL\n         AIF   ('&RTN' EQ 'RC').SVRC\n         AIF   ('&RTN' EQ 'VALUE').SVVAL\n         AIF   ('&RTN' EQ 'BOTH').SVBOTH\n         MNOTE 8,'** INVALID RETURN SPECIFICATION'\n         MEXIT\n.SAVEALL LM    14,12,12(13)       RETURN ALL THE REGISTERS\n.*\n.RETURN  BR    14                 RETURN TO CALLER\n         MEXIT\n.SVRC    L     14,12(,13)         RETURN REG 14\n         LM    0,12,20(13)        PASS OVER REG 15\n         AGO   .RETURN\n.SVVAL   LM    14,15,12(13)       RETURN 14 AND 15\n         LM    1,12,24(13)        PASS OVER REG 0\n         AGO   .RETURN\n.SVBOTH  L     14,12(,13)         RETURN 14\n         LM    1,12,24(13)        PASS OVER 15 AND 0\n         AGO   .RETURN\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XSAVE1": {"ttr": 2060, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   XSAVE1 &SVAREA=,&REEN=,&OPT=,&REG=\n.**********************************************************************\n.* MACRO    = XSAVE                                                   *\n.* AUTHOR   = MARK SCHERFLING                                         *\n.* DATE     = 01/16/81                                                *\n.* CHANGE   = 05/12/83  RIC FORD                                      *\n.*            CHANGED \"BAL 15,12(15)\" TO \"BC 15,12(,15)\"              *\n.*                                                                    *\n.*                                                                    *\n.* FUNCTION = THIS MARCO SETS UP STANDARD LINKAGE IN SAVING THE       *\n.*      CALLING ROUTINE'S REGISTERS AND LINKING IN THE NEW SAVE AREA  *\n.*                                                                    *\n.* PARAMETERS =                                                       *\n.*      SVAREA  = LABEL OF THE OF A SAVE AREA SPECIFIED BY THE USER   *\n.*                IF OMITTED, A SAVE AREA IS GENERATED.               *\n.*      REG     = IF THE SVAREA OR REEN PARAMETER IS USED, A REGISTER *\n.*                IS REQUIRED TO SET UP A BASE REGISTER.              *\n.*                IF A SAVE AREA IS SETUP, R13 IS USED AS BASE        *\n.*                                                                    *\n.*      REEN    = NUMBER OF BYTES TO BE ALLOCATED.                    *\n.*                THIS AREA MUST INCLUDE THE 18 FULLWORDS FOR A LOCAL *\n.*                PROGRAM WORK AREA ALONG WITH LOCAL WORK STORAGE     *\n.*      OPT     = CSECT  - GENERATE A CSECT STATMENT WITH THE LABEL   *\n.*                         PROVIDED                                   *\n.**********************************************************************\n.*\n         LCLC  &BREG\n&BREG    SETC  '15'               DEFAULT BASE REGISTER IS R15\n.*\n         AIF   ('&OPT' NE 'CSECT').NOCSECT\n&LABEL   CSECT\n         B     12(0,15)        BRANCH OVER TRACE NAME\n         DC    CL8'&LABEL'        MODULE NAME\n         AGO   .OVLBL\n.NOCSECT ANOP\n&LABEL   CNOP  0,4\n.OVLBL   AIF   ('&REG' EQ '').NOREG\n&BREG    SETC  '&REG'\n.NOREG   ANOP\n         STM   14,12,12(13)       SAVE REGISTERS\n         BALR  &BREG,0            GET CURRENT ADDR IN 15\n         USING *,&BREG            MAKE TEMP REGISTER\n         AIF   ('&REEN' EQ '').NOREEN\n         LA    0,&REEN            LOAD BYTE COUNT\n         GETMAIN R,LV=(0)         GETMAIN AS SAVE AREA AND WORK BUFFER\n         LR    14,1               MOVE STORAGE AREA ADDR\n         L     1,24(,13)          RELOAD R1 (MAY HAVE A PARM LIST)\n         AGO   .SVPTRS\n.NOREEN  AIF   ('&SVAREA' EQ '').MKSAVE\n         LA    14,&SVAREA         LOAD USER SAVE AREA\n         AGO   .SVPTRS\n.MKSAVE  CNOP  0,4                MAKE SURE RIGHT ALIGNMENT\n         BAL   14,*+76            BRANCH OVER SAVE AREA\n         USING *,13               SET UP ADDRESSABILTY\n         DS    18F                REGISTER SAVE AREA\n         DROP  &BREG\n.SVPTRS  ANOP\n         ST    14,8(,13)          SAVE FORWARD PTR\n         ST    13,4(,14)          SAVE BACKWARD PTR\n         LR    13,14              MAKE SV CURRENT\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT373/FILE373.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT373", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}