{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013420000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 3056872, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "CBT.V500.FILE913.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 3056872, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 3056872, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE913.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x000\\x07'", "DS1TRBAL": "b'l>'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\t\\n\\x00\\x04\\t\\r\\x00\\x07\\x001'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04Y\\x00\\x12\\x01\\x14 \\x9f\\x01\\x14 \\x9f\\x143\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf9@@@'", "ispf": {"version": "04.89", "flags": 0, "createdate": "2014-07-28T00:00:00", "modifydate": "2014-07-28T14:33:12", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-489"}, "text": "REGULAR CBT TAPE - VERSION 489    FILE:  913\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT489.FILE913\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 19 MEMBERS COUNTED; CUMULATIVE SIZE IS 28,917 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   07/28/14    14:33:12    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$INDEX": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x03\\x01\\x14\\x18\\x9f\\x01\\x14 O\\x05\\x08\\x00\\x1e\\x00\\x01\\x00\\x00\\xd7\\xc5\\xe3\\xc5\\xd9\\xe3@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2014-07-08T00:00:00", "modifydate": "2014-07-23T05:08:03", "lines": 30, "newlines": 1, "modlines": 0, "user": "PETERT"}, "text": "$ASM     - COMPILER AND LINK-EDIT A SMSINFO ASSEMBLER PRPGRAM JCL\nHCSMS    - C PROGRAM TO CALLING SMSINFO PROGRAM TO QUERY SMS INFORMATION\n           THOROUGH SSI\nHCSMS$   - COMPILER AND LINK-EDIT A HCSMS C PROGRAM JCL\nHCSMSJ   - EXECUTION HCSMS PROGRAM JCL\n           OUTPUT AS:\n           SMS DASD SPACE INFORMATION\n           STORAGE GROUP NAME   VOLUMES     CAPACITY         FREE  %USED\n           -------------------------------------------------------------\n           DBARCH                   9        73080MB      43844MB  40.01\n           DBDATA                   9        73080MB      71644MB   1.96\n           LOG                     10        81200MB      75899MB   6.53\n           USER                    47       381640MB     365728MB   4.17\n           WORK                     4        10828MB       9989MB   7.75\n\n$CCOMP   - COMPILER AND KINK-EDIT C PROGRAMS HCMTCL, MTCCSUB JCL\nHCMTCL   - C SOCKET SERVER PROGRAM IT PERFORMS THE SERVER FUNCTIONS\n           FOR MULTITASKING\nHCMTCLJ  - RUNNING HCMTCL C SOCKET SERVER PROGRAM JCL\nMTCCSUB  - C SOCKET SERVER SUBTASK PROGRAM IT'S STARTED BY THE TSCHED()\n           ROUTINE OF C/370 MTF, AND QUERY SMS INFORMATION THOROUGH\n           SSI THE RESULT SENT TO REMOTE CONNECT CLIENT\nSMSINFO  - ASSEMBLER PROGRAM IT QUERY SMS INFORMATION THOROUGH SSI\nMVSCB    - C PROGRAM HEAD FILES IT'S TSO XMIT FORMAT\nMVSCB$   - RESTORE C PROGRAM HEAD FILE JCL\nLOAD     - PROGRAMS LOAD LIBRARY IT'S TSO XMIT FORMAT\nLOAD$    - RESTORE LOAD LIBRARY DATASET JCL\nPDFDOC   - SETUP SMS CLIENT APPLICATION ON IPHONE DEVICE DOCUMENT, IT'S\n           PDF FORMAT YOU COULD DOWNLOAD IT TO YOUR PC WITH BINARY AND\n           USING ADOBE READER TO OPEN IT.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE01": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x004\\x01\\x14 O\\x01\\x14 O!'\\x00\\x10\\x00\\x10\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-07-23T00:00:00", "modifydate": "2014-07-23T21:27:34", "lines": 16, "newlines": 16, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Contribute C program access to z/OS SMS space information\nFrom:     Tsai HC <mz055t@ms13.hinet.net>\nDate:     7/23/2014 6:57 AM\nTo:       sbgolob@cbttape.org\n\nHi Sam,\n\nI am attaching my contributions to the CBT Tape, it is small C\nprogram to query SMS information and generate SMS free space\ninformation by storage group, and C socket server program with\nmultitasking for remote client query z/OS SMS storage group free\nspace information.\n\nRegards,\nHC Tsai\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE02": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x005\\x01\\x14 \\x9f\\x01\\x14 \\x9f\\x140\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-07-28T00:00:00", "modifydate": "2014-07-28T14:30:35", "lines": 14, "newlines": 14, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Re: Contribute C program access to z/OS SMS space information\nFrom:     Tsai HC <mz055t@ms13.hinet.net>\nDate:     7/28/2014 9:15 AM\nTo:       Sam Golob <sbgolob@cbttape.org>\n\nHi Sam,\n\nThe \"z/OS Storage Management\" iPhone app is now ready on the Apple\nStore.  You can install it into your iPhone.  The app is called\n\"z/OS Storage Management\".\n\nReagrds,\nHC Tsai\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$ASM": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01c\\x00E\\x01\\x12\\t\\x1f\\x01\\x14\\x18\\x9f\\x07I\\x00'\\x00,\\x00\\x00\\xd7\\xc5\\xe3\\xc5\\xd9\\xe3@@@@\"", "ispf": {"version": "01.99", "flags": 0, "createdate": "2012-03-31T00:00:00", "modifydate": "2014-07-08T07:49:45", "lines": 39, "newlines": 44, "modlines": 0, "user": "PETERT"}, "text": "//PETERTJ  JOB (12345678),PETERT,MSGCLASS=H,\n//        MSGLEVEL=(1,1),CLASS=A,NOTIFY=&SYSUID\n//*\n//*\n//**********************************************************************\n//*  COMPILER AND LINK-EDIT A ASSEMBLER PROGRAM                        *\n//**********************************************************************\n//*\n//EDSTW03  PROC MEM=\n//*\n//C        EXEC PGM=ASMA90,\n//         REGION=1M,\n//         PARM='OBJECT'\n//SYSIN    DD  DISP=SHR,DSN=PETERT.HC.PDS(&MEM)\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//         DD  DSN=CEE.SCEEMAC,DISP=SHR\n//SYSUT1   DD  DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),UNIT=SYSDA,\n//             DCB=BUFNO=1\n//SYSPUNCH DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),UNIT=SYSDA,\n//             DISP=(MOD,PASS),\n//             DCB=(BLKSIZE=3040,LRECL=80,RECFM=FBS,BUFNO=1)\n//L        EXEC PGM=HEWL,PARM='MAP,LET,LIST,RENT,XREF',\n//         COND=(8,LT,C)\n//SYSLIN   DD  DSN=&&OBJ,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSLIB   DD  DISP=SHR,DSN=PETERT.TEST.LOAD\n//         DD DSN=CEE.SCEELKED,DISP=SHR\n//SYSLMOD  DD  DISP=SHR,DSN=PETERT.HC.LOADLIB(&MEM)\n//SYSUT1   DD  DSN=&&SYSUT1,SPACE=(1024,(120,120),,,ROUND),UNIT=SYSDA,\n//             DCB=BUFNO=1\n//SYSPRINT DD  SYSOUT=*\n//   PEND\n//*\n//STEP001  EXEC EDSTW03,MEM=SMSINFO\n//*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$CCOMP": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01B\\x00)\\x01\\x14\\x01\\x8f\\x01\\x14\\x19\\x1f\\x057\\x00h\\x00Q\\x00\\x00\\xd7\\xc5\\xe3\\xc5\\xd9\\xe3@@@@'", "ispf": {"version": "01.66", "flags": 0, "createdate": "2014-01-18T00:00:00", "modifydate": "2014-07-10T05:37:29", "lines": 104, "newlines": 81, "modlines": 0, "user": "PETERT"}, "text": "//PETERTJ  JOB (12345678),PETERT,MSGCLASS=H,\n//        MSGLEVEL=(1,1),CLASS=A,NOTIFY=&SYSUID\n//**\n//*\n//EDCCPL   PROC  MEM=,                   < MEMBER NAMR\n//  INFILE='PETERT.HC.PDS',              < INPUT C SOURCE CODE\n//  OUTFILE='PETERT.HC.LOADLIB',         < OUTPUT LOADMODULE PDS\n//  CREGSIZ='48M',                       < COMPILER REGION SIZE\n//  CRUN=,                               < COMPILER RUNTIME OPTIONS\n//  CPARM='LIST,LSEARCH(DD:HCLIB)',      < COMPILER OPTIONS\n//  CPARM2='RENT,NOSEARCH,LONGNAME',     < COMPILER OPTIONS\n//  CPARM3='LANGLVL(EXTENDED),SOURCE',   < COMPILER OPTIONS\n//  CPARM4='NOMAR,NOSEQ,NOOPT,SSCOMM',   < COMPILER OPTIONS\n//  CPARM5='',                           < COMPILER OPTIONS\n//  SYSLBLK='3200',                      < BLOCKSIZE FOR &&LOADSET\n//  LIBPRFX='CEE',                       < PREFIX FOR LIBRARY DSN\n//  LNGPRFX='CBC',                       < PREFIX FOR LANGUAGE DSN\n//  CLANG='EDCMSGE', < NOT USED IN THIS RELEASE. KEPT FOR COMPATIBILITY\n//  PLANG='EDCPMSGE',                    < PRE-LINKER MESSAGE NAME\n//  PREGSIZ='2048K',                     < PRE-LINKER REGION SIZE\n//  PPARM='UPCASE,OMVS',                 < PRE-LINKER OPTIONS\n//  LREGSIZ='1024K',                     < LINK EDIT  REGION SIZE\n//  LPARM='AMODE=31,XREF,LIST,MAP,RENT', < LINK EDIT  OPTIONS\n//  LPARM2=',COMPAT=LKED',               < LINK EDIT  OPTIONS\n//  DCB80='(RECFM=FB,LRECL=80,BLKSIZE=3200)',      <DCB FOR LRECL 80\n//  DCB3200='(RECFM=FB,LRECL=3200,BLKSIZE=12800)', <DCB FOR LRECL 3200\n//  TUNIT='SYSDA'                        < UNIT FOR TEMPORARY FILES\n//*\n//*-------------------------------------------------------------------\n//*  COMPILE STEP:\n//*-------------------------------------------------------------------\n//COMPILE EXEC PGM=CBCDRVR,REGION=&CREGSIZ,\n//    PARM=('&CRUN/&CPARM &CPARM2 &CPARM3 &CPARM4 &CPARM5')\n//STEPLIB  DD  DSNAME=&LIBPRFX..SCEERUN,DISP=SHR\n//         DD  DSNAME=&LNGPRFX..SCBCCMP,DISP=SHR\n//SYSMSGS  DD  DUMMY,DSN=&LNGPRFX..SCBC3MSG(&CLANG),DISP=SHR\n//SYSIN    DD  DSNAME=&INFILE(&MEM),DISP=SHR\n//SYSLIB   DD  DSNAME=TCPIP.SEZACMAC,DISP=SHR\n//         DD  DSNAME=&LIBPRFX..SCEEH.H,DISP=SHR\n//         DD  DSNAME=&LIBPRFX..SCEEH.SYS.H,DISP=SHR\n//HCLIB    DD  DSNAME=PETERT.HC.MVSCB,DISP=SHR\n//         DD  DSNAME=PETERT.HC.PDS,DISP=SHR\n//SYSLIN   DD  DSNAME=&&LOADSET,UNIT=&TUNIT.,\n//             DISP=(MOD,PASS),SPACE=(TRK,(3,3)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=&SYSLBLK)\n//SYSPRINT DD  SYSOUT=*\n//SYSOUT   DD  SYSOUT=*\n//SYSCPRT  DD  SYSOUT=*\n//SYSUT1   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),DCB=&DCB80\n//SYSUT4   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),DCB=&DCB80\n//SYSUT5   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),DCB=&DCB3200\n//SYSUT6   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),DCB=&DCB3200\n//SYSUT7   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),DCB=&DCB3200\n//SYSUT8   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),DCB=&DCB3200\n//SYSUT9   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),\n//             DCB=(RECFM=VB,LRECL=137,BLKSIZE=882)\n//SYSUT10  DD  SYSOUT=*\n//SYSUT14  DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),\n//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)\n//*\n//*-------------------------------------------------------------\n//* PRE-LINKEDIT STEP:\n//*-------------------------------------------------------------\n//PLKED   EXEC PGM=EDCPRLK,PARM='&PPARM',COND=(4,LT,COMPILE),\n//    REGION=&PREGSIZ\n//STEPLIB  DD  DSNAME=&LIBPRFX..SCEERUN,DISP=SHR\n//SYSMSGS  DD  DSNAME=&LIBPRFX..SCEEMSGP(&PLANG),DISP=SHR\n//**SYSLIB   DD  DUMMY\n//SYSLIB   DD  DSN=TCPIP.SEZARNT1,DISP=SHR\n//SYSIN    DD  DSN=*.COMPILE.SYSLIN,DISP=(MOD,DELETE)\n//         DD  DDNAME=SYSIN2\n//SYSMOD   DD  DSNAME=&&PLKSET,UNIT=&TUNIT.,DISP=(NEW,PASS),\n//             SPACE=(32000,(30,30)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=&SYSLBLK)\n//SYSOBJ   DD  DUMMY\n//SYSOUT   DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//SYSIN2   DD  DUMMY\n//*\n//*-------------------------------------------------------------------\n//* LINKEDIT STEP:\n//*-------------------------------------------------------------------\n//LKED   EXEC PGM=HEWL,COND=((4,LT,COMPILE),(4,LT,PLKED)),\n//    REGION=&LREGSIZ,PARM='&LPARM &LPARM2'\n//SYSLIB   DD  DSNAME=TCPIP.SEZACMTX,DISP=SHR\n//         DD  DSNAME=TCPIP.SEZALOAD,DISP=SHR\n//         DD  DSNAME=&LIBPRFX..SCEELKED,DISP=SHR\n//         DD  DSNAME=SYS1.SERBLINK,DISP=SHR\n//         DD  DSNAME=PETERT.HC.LOADLIB,DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSNAME=*.PLKED.SYSMOD,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSLMOD  DD  DSNAME=&OUTFILE(&MEM),DISP=SHR\n//SYSUT1   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30))\n//SYSIN    DD  DUMMY\n//   PEND\n//*\n//STEP001  EXEC EDCCPL,MEM=HCMTCL\n//STEP002  EXEC EDCCPL,MEM=MTCCSUB\n//LKED.SYSIN DD *\n  INCLUDE SYSLIB(EDCMTFS)\n  ENTRY CEESTART\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE913": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04Y\\x00\\x02\\x01\\x14 \\x9f\\x01\\x14 \\x9f\\x143\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf9@@@'", "ispf": {"version": "04.89", "flags": 0, "createdate": "2014-07-28T00:00:00", "modifydate": "2014-07-28T14:33:02", "lines": 14, "newlines": 14, "modlines": 0, "user": "CBT-489"}, "text": "//***FILE 913 is from Peter H.C. Tsai, and contains a way of        *   FILE 913\n//*           displaying SMS information from your z/OS system      *   FILE 913\n//*           on your Apple iPhone.                                 *   FILE 913\n//*                                                                 *   FILE 913\n//*           Documentation is in PDF format, which describes       *   FILE 913\n//*           the installation procedure.  Also see member          *   FILE 913\n//*           $$INDEX.                                              *   FILE 913\n//*                                                                 *   FILE 913\n//*           email:  <mz055t@ms13.hinet.net>                       *   FILE 913\n//*                                                                 *   FILE 913\n//*       The \"z/OS Storage Management\" iPhone app is now ready     *   FILE 913\n//*       on the Apple Store.  You can install it into your         *   FILE 913\n//*       iPhone.  The app is called \"z/OS Storage Management\".     *   FILE 913\n//*                                                                 *   FILE 913\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HCMTCL": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x18\\x00\"\\x01\\x14\\x01\\x7f\\x01\\x14\\x14\\x0f\\x05F\\x01x\\x01R\\x00\\x00\\xd7\\xc5\\xe3\\xc5\\xd9\\xe3@@@@'", "ispf": {"version": "01.24", "flags": 0, "createdate": "2014-01-17T00:00:00", "modifydate": "2014-05-20T05:46:22", "lines": 376, "newlines": 338, "modlines": 0, "user": "PETERT"}, "text": "/*********************************************************************/\n/* C socket Server Program                                           */\n/*                                                                   */\n/* This code performs the server functions for multitasking, which   */\n/* include                                                           */\n/*      . creating subtasks                                          */\n/*      . socket(), setsockopt(), bind(), listen(), accept()         */\n/*      . getclientid                                                */\n/*      . givesocket() to TCP/IP in preparation for the subtask      */\n/*                      to do a takesocket()                         */\n/*      . select()                                                   */\n/*                                                                   */\n/* There are three test tasks running:                               */\n/*      . server master                                              */\n/*      . server subtask - separate TCB within server address space  */\n/*      . client                                                     */\n/*                                                                   */\n/*********************************************************************/\n\nstatic char ibmcopyr\u00dd\u00a8 =\n   \"MTCSRVR - Licensed Materials - Property of IBM. \"\n   \"This module is \\\"Restricted Materials of IBM\\\" \"\n   \"5647-A01 (C) Copyright IBM Corp. 1994, 1996. \"\n   \"See IBM Copyright Instructions.\";\n\n#include <manifest.h>\n#include <bsdtypes.h>\n#include <in.h>\n#include <netdb.h>\n#include <socket.h>\n#include <inet.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <tcperrno.h>\n#include <bsdtime.h>\n#include <mtf.h>\n#include <stdio.h>\n\n/*\n#pragma linkage (EXPGM1,OS)\ntypedef int EXPGM1();\n     */\n\nint  dotinit(void);\nvoid getsock(int *s);\nint  setsock(int *s);\nint  dobind(int *s, unsigned short port);\nint  dolisten(int *s);\nint  getname(char *myname, char *mysname);\nint  doaccept(int *s);\nint  testgive(int *s);\nint  dogive(int *clsocket, char *myname);\n\n/*\n * Server Main.\n */\nmain(argc, argv)\nint argc;\nchar **argv;\n{\n    /*\n    EXPGM1 *fptr;\n    */\n    unsigned short port;       /* port server for bind                */\n    int s;                     /* socket for accepting connections    */\n    int rc;                    /* return code                         */\n    int i;                     /*                                     */\n    int call_rc;               /* return code                         */\n    int count;                 /* counter for number of sockets       */\n    int clsocket;              /* client socket                       */\n    char myname\u00dd8\u00a8;            /* 8 char name of this addres space    */\n    char mysname\u00dd8\u00a8;           /* my subtask name                     */\n\n    /*\n     * Check arguments. Should be only one: the port number to bind to.\n     */\n    if (argc != 2) {\n        fprintf(stderr, \"Usage: %s port\\n\", argv\u00dd0\u00a8);\n        exit(1);\n    }\n\n    /*\n     * First argument should be the port.\n     */\n    port = (unsigned short) atoi(argv\u00dd1\u00a8);\n    fprintf(stdout, \"Server: port = %d \\n\", port);\n\n    /*\n     * Create subtasks\n     */\n    rc = dotinit();\n    if (rc < 0)\n        perror(\"Srvr: error for tinit\");\n    printf(\"rc from tinit is %d\\n\", rc);\n\n    getsock(&s);\n    printf(\"Srvr: socket = %d\\n\", s);\n\n    rc = setsock(&s);\n    printf(\"Srvr: set TCP_NODELAY option return value is %d\\n\", rc);\n\n    rc = dobind(&s, port);\n    if (rc < 0)\n        tcperror(\"Srvr: error for bind\");\n    printf(\"Srvr: rc from bind is %d\\n\", rc);\n\n    rc = dolisten(&s);\n    if (rc < 0)\n        tcperror(\"Srvr: error for listen\");\n    printf(\"Srvr: rc from listen is %d\\n\", rc);\n\n    /***************************************\n     * To do nonblocking mode,\n     *  uncomment out this code.\n     *\n    rc = fcntl(s, F_SETFL, FNDELAY);\n    if (rc != 0)\n        tcperror(\"Error for fcntl\");\n    printf(\"rc from fcntl is %d\\n\", rc);\n\n     **************************************/\n\n    rc = getname(myname, mysname);\n    if (rc < 0)\n        tcperror(\"Srvr: error for getclientid\");\n    printf(\"Srvr: rc from getclientid is %d\\n\", rc);\n\n    /*----------------------------------------------------------------*/\n    /* . issue accept(), waiting for client connection                */\n    /* . issue givesocket() to pass client's socket to TCP/IP         */\n    /* . issue select(), waiting for subtask to complete takesocket() */\n    /* . close our local socket associated with client's socket       */\n    /* . loop on accept(), waiting for another client connection      */\n    /*----------------------------------------------------------------*/\n    rc    = 0;\n    count = 0;          /* number of sockets */\n    while (rc == 0) {\n        clsocket = doaccept(&s);\n        printf(\"Srvr: clsocket from accept is %d\\n\", clsocket);\n        count = count + 1;\n        printf(\"Srvr: ###number of sockets is %d\\n\", count);\n        if (clsocket != 0) {\n            rc = dogive(&clsocket, myname);\n            if (rc < 0)\n                tcperror(\"Srvr: error for dogive\");\n            printf(\"Srvr: rc from dogive is %d\\n\", rc);\n            if (rc == 0) {\n                rc = tsched(MTF_ANY,\"csub\", &clsocket,\n                                myname, mysname);\n                if (rc < 0)\n                    perror(\"error for tsched\");\n                printf(\"Srvr: rc from tsched is %d\\n\", rc);\n\n                rc = testgive(&clsocket);\n                printf(\"Srvr: rc from testgive is %d\\n\", rc);\n\n                /*sleep(60); ** do simplified situation first ***/\n\n                /*\n                i = 60;\n                fptr = (EXPGM1 *)fetch(\"WAITIME\");\n                call_rc = (*fptr)(&i);\n                printf(\"Srvr: call_rc is %d\\n\", call_rc);\n                release(fptr);\n                   */\n\n                printf(\"Srvr: closing client socket %d\\n\", clsocket);\n                rc = close(clsocket);   /* give back this socket */\n                if (rc < 0)\n                    tcperror(\"error for close of clsocket\");\n                printf(\"Srvr: rc from close of clsocket is %d\\n\", rc);\n                /****************************************************/\n                /*exit(0); ** do  this simplified situation first ***/\n                /****************************************************/\n            } /** end of if (rc == 0)       ****/\n        }   /**** end of if (clsocket != 0) ****/\n    }   /******** end of while (rc == 0)    ****/\n}   /************ end of main           ********/\n\n/*--------------------------------------------------------------------*/\n/*    dotinit()                                                       */\n/*    Call tinit() to ATTACH subtask and fetch() subtask load module  */\n/*--------------------------------------------------------------------*/\nint dotinit(void)\n{\n    int rc;\n    int numsubs = 1;\n    printf(\"Srvr: calling __tinit\\n\");\n    rc = __tinit(\"mtccsub\", numsubs);\n    return rc;\n}\n\n/*--------------------------------------------------------------------*/\n/*    getsock()                                                       */\n/*    Get a socket                                                    */\n/*--------------------------------------------------------------------*/\nvoid getsock(int *s)\n{\n    int temp;\n    temp = socket(AF_INET, SOCK_STREAM, 0);\n    *s = temp;\n    return;\n}\n\n/*--------------------------------------------------------------------*/\n/*    setsock()                                                       */\n/*    Set socket option                                               */\n/*--------------------------------------------------------------------*/\nint setsock(int *s)\n{\n    int optval = 1;\n    int temps;\n    int rc;\n\n    temps = *s;\n    rc = setsockopt(temps, IPPROTO_TCP, TCP_NODELAY,\n                    (char *) &optval, sizeof(int));\n    return rc;\n}\n\n/*--------------------------------------------------------------------*/\n/*    dobind()                                                        */\n/*    Bind to all interfaces                                          */\n/*--------------------------------------------------------------------*/\nint dobind(int *s, unsigned short port)\n{\n    int rc;\n    int temps;\n    struct sockaddr_in tsock;\n    memset(&tsock, 0, sizeof(tsock));   /* clear tsock to 0's */\n    tsock.sin_family      = AF_INET;\n    tsock.sin_addr.s_addr = INADDR_ANY; /* bind to all interfaces */\n    tsock.sin_port        = htons(port);\n\n    temps = *s;\n    rc = bind(temps, (struct sockaddr *)&tsock, sizeof(tsock));\n    return rc;\n}\n\n/*--------------------------------------------------------------------*/\n/*    dolisten()                                                      */\n/*    Listen to prepare for client connections.                       */\n/*--------------------------------------------------------------------*/\nint dolisten(int *s)\n{\n    int rc;\n    int temps;\n    temps = *s;\n    rc = listen(temps, 10);     /* backlog of 10 */\n    return rc;\n}\n\n/*--------------------------------------------------------------------*/\n/*    getname()                                                       */\n/*    Get the identifiers by which TCP/IP knows this server.          */\n/*--------------------------------------------------------------------*/\nint getname(char *myname, char *mysname)\n{\n    int rc;\n    struct clientid cid;\n    memset(&cid, 0, sizeof(cid));\n    rc = getclientid(AF_INET, &cid);\n    memcpy(myname,  cid.name,        8);\n    memcpy(mysname, cid.subtaskname, 8);\n    return rc;\n}\n\n/*--------------------------------------------------------------------*/\n/*    doaccept()                                                      */\n/*    Select() on this socket, waiting for another client connection. */\n/*    If connection is pending, issue accept() to get client's socket */\n/*--------------------------------------------------------------------*/\nint doaccept(int *s)\n{\n    int temps;\n    int clsocket;\n    struct sockaddr clientaddress;\n    int addrlen;\n    int maxfdpl;\n    struct fd_set readmask;\n    struct fd_set writmask;\n    struct fd_set excpmask;\n    int rc;\n    struct timeval time;\n\n    temps = *s;\n    time.tv_sec  = 1000;\n    time.tv_usec = 0;\n    maxfdpl = temps + 1;\n\n    FD_ZERO(&readmask);\n    FD_ZERO(&writmask);\n    FD_ZERO(&excpmask);\n\n    FD_SET(temps, &readmask);\n\n    rc = select(maxfdpl, &readmask, &writmask, &excpmask, &time);\n    printf(\"Srvr: rc from select is %d\\n\", rc);\n    if (rc < 0) {\n        tcperror(\"error from select\");\n        return rc;\n    }\n    else if (rc == 0) {  /* time limit expired */\n        return rc;\n    }\n    else {              /* this socket is ready */\n        addrlen = sizeof(clientaddress);\n        clsocket = accept(temps, &clientaddress, &addrlen);\n        return clsocket;\n    }\n}\n\n/*--------------------------------------------------------------------*/\n/*    testgive()                                                      */\n/*    Issue select(), checking for an exception condition, which      */\n/*    indicates that takesocket() by the subtask was successful.      */\n/*--------------------------------------------------------------------*/\nint testgive(int *s)\n{\n    int temps;\n    struct sockaddr clientaddress;\n    int addrlen;\n    int maxfdpl;\n    struct fd_set readmask;\n    struct fd_set writmask;\n    struct fd_set excpmask;\n    int rc;\n    struct timeval time;\n\n    temps = *s;\n    time.tv_sec  = 1000;\n    time.tv_usec = 0;\n    maxfdpl = temps + 1;\n\n    FD_ZERO(&readmask);\n    FD_ZERO(&writmask);\n    FD_ZERO(&excpmask);\n\n /* FD_SET(temps, &readmask); */\n /* FD_SET(temps, &writmask); */\n    FD_SET(temps, &excpmask);\n\n    rc = select(maxfdpl, &readmask, &writmask, &excpmask, &time);\n    printf(\"Srvr: rc from select for testgive is %d\\n\", rc);\n    if (rc < 0) {\n        tcperror(\"Srvr: error from testgive\");\n    }\n    else\n        rc = 0;\n\n    return rc;\n}\n\n/*--------------------------------------------------------------------*/\n/*    dogive()                                                        */\n/*    Issue givesocket() for giving client's socket to subtask.       */\n/*--------------------------------------------------------------------*/\nint dogive(int *clsocket, char *myname)\n{\n    int rc;\n    struct clientid cid;\n    int temps;\n\n    temps = *clsocket;\n    memset(&cid, 0, sizeof(cid));\n    cid.domain = AF_INET;\n\n    memcpy(cid.name,       myname,     8);\n    memcpy(cid.subtaskname,\"        \", 8);\n    printf(\"Srvr: givesocket socket is %d\\n\", temps);\n    printf(\"Srvr: givesocket name is %s\\n\", cid.name);\n\n    rc = givesocket(temps, &cid);\n    return rc;\n}\n\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "HCMTCLJ": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01H\\x007\\x01\\x14\\x01\\x7f\\x01\\x14\\x19\\x1f\\x059\\x00\\x0b\\x00\\x0e\\x00\\x00\\xd7\\xc5\\xe3\\xc5\\xd9\\xe3@@@@'", "ispf": {"version": "01.72", "flags": 0, "createdate": "2014-01-17T00:00:00", "modifydate": "2014-07-10T05:39:37", "lines": 11, "newlines": 14, "modlines": 0, "user": "PETERT"}, "text": "//PETERTJJ JOB (12345678),PETERT,MSGCLASS=H,\n//        MSGLEVEL=(1,1),CLASS=A,NOTIFY=&SYSUID\n//*\n//*\n//TEST0J   EXEC PGM=HCMTCL,REGION=0M,\n//         PARM='9010'\n//STEPLIB  DD DSN=PETERT.HC.LOADLIB,DISP=SHR\n//MSGFILE  DD  SYSOUT=*\n//SYSOUT   DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//SYSABEND DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HCSMS": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01T\\x00S\\x01\\x14\\x00_\\x01\\x14\\x01O\\x03H\\x01\\x0e\\x00\\xdb\\x00\\x00\\xd7\\xc5\\xe3\\xc5\\xd9\\xe3@@@@'", "ispf": {"version": "01.84", "flags": 0, "createdate": "2014-01-05T00:00:00", "modifydate": "2014-01-14T03:48:53", "lines": 270, "newlines": 219, "modlines": 0, "user": "PETERT"}, "text": "/*\n * hcsms - query SMS information thorough SSI\n *\n * Copyright 2014 WLPF390\n *\n * Permission to use, copy, modify, and distribute this software and its\n * documentation for any purpose and without fee is hereby granted.\n *\n * Author: HC Tsai\n */\n\n/* ================================================================== */\n/* Includes and Variables                                             */\n/* ================================================================== */\n/* --- Includes  ---------------------------------------------------- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"hexdump.h\"\n#include \"StoHxS.h\"\n#include \"hccopyr.h\"\n\n/* ================================================================== */\n/* Map z/OS Control Blocks                                            */\n/* ================================================================== */\n/* --- include z/OS control blocks ---------------------------------- */\n#include \"ihapsa\"                      /* PSA                         */\n#include \"cvt\"                         /* CVT                         */\n#include \"igdsms\"                      /* SMS desct - IGDVLD & IGDSGD */\n#include \"hcsgd\"                       /* HCSGD desct                 */\n/* --- Set PSA address to x0 ---------------------------------------- */\nstruct psa *psa_ptr = 0;               /* PSA is at address 0         */\nstruct cvt *cvt_ptr;\nstruct igdsgd *igdsgd_ptr;\nstruct igdvld *igdvld_ptr;\nstruct vldsysdt *vldsysdt_ptr;\nstruct hcsgd *hcsgd_ptr;\n\n/* for dynamic link assembler program                                 */\n#pragma linkage (EXPGM1,OS)\ntypedef int EXPGM1();\n\n#define MAXVOLS 2000;\n\n/* ================================================================== */\n/* Main Program                                                       */\n/* ================================================================== */\nvoid main(int argc, char *argv\u00dd\u00a8) {\n   time_t now;\n\n   EXPGM1 *fptr;                     /* link assembler program        */\n\n   char *str1;                       /* Output buffer                 */\n   char outline\u00dd80\u00a8;                 /* sprintf output work           */\n   int  pd = 0x00000000;             /* debugging switch              */\n   int  loop_sw = 0x00000000;        /* loop switch                   */\n   int  loop_s1 = 0x00000000;        /* loop switch                   */\n   int  B_address= 0x00000000;       /* store SSI buffer address - SGD*/\n   int  V_address= 0x00000000;       /* store SSI buffer address - VLD*/\n   int  S_address= 0x00000000;       /* system relate data of status  */\n   int  *SSI_Buffer;                 /* Call SSI of work area buffer  */\n   int  H_address= 0x00000000;       /* store HC buffer address       */\n   int  *HC_Buffer;                  /* Call SSI of work area buffer  */\n   int  WA_length;                   /* VLD work area length          */\n   int  tc;                          /* total capacity in megabytes   */\n   int  tf;                          /* total amount free in megabytes*/\n   float rt;                         /* %Used                         */\n   float ftc;\n   float ftf;\n   int  tv;                          /* total volumes                 */\n   int  rc;                          /* link assembler return code    */\n   int  SG_count;                    /* Number of SG defs count       */\n   int  SG_length;                   /* Length of one SGDEF+extents   */\n   int  VL_count;                    /* Number of Volumes count       */\n   int  VL_length;                   /* Length of one def VLDEF       */\n   char SGtype\u00dd3\u00a8 = {0};             /* SG request type               */\n   char SGname\u00dd30\u00a8 = {0};            /* SG name                       */\n   short int SGnameLen = 0x0000;     /* SG name length                */\n\n   WA_length = wktbl;\n   tc = 0;\n   tf = 0;\n   rt = 0;\n   tv = 0;\n\n   /* --begin-------------------------------------------------------- */\n   if (strcmp(argv\u00dd1\u00a8, \"YES\") == 0) {\n      pd = 999;\n      printf(\"<PD MSG>Debug on\\n\");\n     }  /* end if */\n\n   time(&now);\n   if (pd > 0) {\n      printf(\"<PD MSG>date/time: %s\\n\", ctime(&now));\n     } /* end if - pd */\n\n\n   /* --------------------------------------------------------------- */\n   /* Set Things Up                                                   */\n   /* --------------------------------------------------------------- */\n   str1= (char *)malloc(256);          /* Area for printing strings   */\n   memset(str1,0,255);                 /* Zero output buffer          */\n\n   SSI_Buffer = (int *)malloc(WA_length);\n   memset(SSI_Buffer,0,WA_length);\n   B_address = SSI_Buffer;             /* store SSI buffer address    */\n\n   /* --------------------------------------------------------------- */\n   /* Output z/OS System Name                                         */\n   /* --------------------------------------------------------------- */\n   cvt_ptr = psa_ptr->flccvt;        /* CVT at address flccvt         */\n   printf(\"%s\\n \\n\", hccopyr);\n   memcpy(str1,cvt_ptr->cvtsname,8);\n   printf(\"z/OS system identify name: %s\\n \\n\",str1);\n   memset(str1,0,8);                 /* Zero output buffer            */\n\n   fptr = (EXPGM1 *)fetch(\"SMSINFO\");   /* load SMSINFO assembler     */\n\n   strcpy(SGtype, \"SGL\");\n   strcpy(SGname, \"                              \");  /* move spaces */\n   SGnameLen = 0;\n   rc = (*fptr)(SSI_Buffer, &WA_length, &SGtype, &SGname, &SGnameLen);\n   if (pd > 0) {\n      printf(\"<PD MSG>Calling SMSINFO return code is %d\\n\", rc);\n   } /* end if */\n\n   igdsgd_ptr = SSI_Buffer;\n   SG_count = igdsgd_ptr->sgdpcnt;\n   SG_length = igdsgd_ptr->sgdplen;\n   if (pd > 0) {\n      printf(\"<PD MSG>sgdpcnt = %d\\n\", igdsgd_ptr->sgdpcnt);\n      printf(\"<PD MSG>sgdplen = %d\\n\", igdsgd_ptr->sgdplen);\n   } /* end if */\n\n   HC_Buffer = (int *)malloc(hcsgdlen*igdsgd_ptr->sgdpcnt);\n   memset(HC_Buffer,0,(hcsgdlen*igdsgd_ptr->sgdpcnt));\n   H_address = HC_Buffer;             /* store HC buffer address    */\n   hcsgd_ptr = HC_Buffer;\n\n   for(loop_sw=1; loop_sw<=SG_count; loop_sw++) {\n      if (pd > 0) {\n         printf(\"<PD MSG>(%d)sgdfname = %s\\n\",\n                strlen(igdsgd_ptr->sgdfname),\n                igdsgd_ptr->sgdfname);\n         printf(\"<PD MSG>sgdfdesc = %s\\n\", igdsgd_ptr->sgdfdesc);\n         printf(\"<PD MSG>sgdftype = %d\\n\", igdsgd_ptr->sgdftype);\n      }  /* end the if */\n\n      /* copy igdsgd data to hcsgd */\n      strcpy(hcsgd_ptr->hcfname,igdsgd_ptr->sgdfname);\n      strcpy(hcsgd_ptr->hcfdesc,igdsgd_ptr->sgdfdesc);\n      hcsgd_ptr->hcftype = igdsgd_ptr->sgdftype;\n      hcsgd_ptr = hcsgd_ptr + 1;\n\n      B_address = B_address + SG_length;\n      igdsgd_ptr = B_address;\n   } /* end for loop */\n\n   hcsgd_ptr = H_address;\n   if (pd > 0) {\n      for(loop_sw=1; loop_sw<=SG_count; loop_sw++) {\n         printf(\"<PD MSG>(hc buffer - %d)hcfname = %s\\n\",\n                strlen(hcsgd_ptr->hcfname),\n                hcsgd_ptr->hcfname);\n         printf(\"<PD MSG>(hc buffer)hcfdesc = %s\\n\",\n                hcsgd_ptr->hcfdesc);\n         printf(\"<PD MSG>(hc buffer)hcftype = %d\\n\",\n                hcsgd_ptr->hcftype);\n         hcsgd_ptr = hcsgd_ptr + 1;\n      } /* end for loop */\n   }  /* end the if */\n\n   /*----------------------------------------------------------------*/\n   memset(SSI_Buffer,0,WA_length);    /* clear SSI buffer to NULL    */\n   V_address = SSI_Buffer;             /* store SSI buffer address    */\n   hcsgd_ptr = H_address;\n\n   printf(\"SMS DASD Space Information\\n\");\n   printf(\"\\n\");\n   printf(\"Storage Group Name   Volumes     Capacity         Free  %%Used\\n\");\n   printf(\"-------------------------------------------------------------\\n\");\n   for(loop_sw=1; loop_sw<=SG_count; loop_sw++) {\n      strcpy(SGname,hcsgd_ptr->hcfname);\n      strcpy(SGtype, \"SGV\");\n      SGnameLen = strlen(hcsgd_ptr->hcfname);\n      rc = (*fptr)(SSI_Buffer, &WA_length,\n                   &SGtype, &SGname, &SGnameLen);\n      if (pd > 0) {\n         printf(\"<PD MSG>Calling SMSINFO with SGV \"\n                \"type return code is %d\\n\", rc);\n      } /* end if */\n\n      V_address = SSI_Buffer;          /* store SSI buffer address    */\n      igdvld_ptr = SSI_Buffer;\n      VL_count = igdvld_ptr->vldpcnt;\n      VL_length = igdvld_ptr->vldplen;\n      if (pd > 0) {\n         printf(\"<PD MSG>vldpid  = %s\\n\", igdvld_ptr->vldpid);\n         printf(\"<PD MSG>vldpcnt = %d\\n\", igdvld_ptr->vldpcnt);\n         printf(\"<PD MSG>vldplen = %d\\n\", igdvld_ptr->vldplen);\n      } /* end if */\n      tc = 0;\n      tf = 0;\n      tv = 0;\n      for(loop_s1=1; loop_s1<=VL_count; loop_s1++) {\n         if (pd > 0) {\n            printf(\"<PD MSG>SMS Volume information list: \"\n                   \"%s - %s (%d / %d / %d)\\n\",\n                   igdvld_ptr->vldstgrp,\n                   igdvld_ptr->vldvser,\n                   igdvld_ptr->vldntcpy,\n                   igdvld_ptr->vldnfree,\n                   igdvld_ptr->vldnlext);\n         } /* end if */\n         /* point to System related data  (24 is VLDP length) */\n         S_address = V_address + igdvld_ptr->vldsysof + 24;\n         vldsysdt_ptr = S_address;\n         if (pd > 0) {\n            printf(\"<PD MSG>System status VLDSYSOF - VLDSYSLN \"\n                   \"(SMS/MVS): %d - %d (%d / %d)\\n\",\n                   igdvld_ptr->vldsysof,\n                   igdvld_ptr->vldsysln,\n                   vldsysdt_ptr->vldstsms,\n                   vldsysdt_ptr->vldstmvs);\n         } /* end if */\n                                /* SMS Status           */\n                                /* 0 - No status given  */\n                                /* 1 - Enabled          */\n                                /* 2 - Quiesce/All      */\n                                /* 3 - Quiesce/New      */\n                                /* 4 - Disabled/All     */\n                                /* 5 - Disabled/New     */\n                                /* MVS Status           */\n                                /* 1 - Online           */\n                                /* 2 - Offline          */\n                                /* 3 - Pending offline  */\n                                /* 4 - Boxed            */\n                                /* 5 - Not Ready        */\n         if (vldsysdt_ptr->vldstmvs == vldonln) {\n            tc = tc + igdvld_ptr->vldntcpy;\n            tf = tf + igdvld_ptr->vldnfree;\n            tv = tv + 1;\n         } /* end if */\n\n         V_address = V_address + VL_length;\n         igdvld_ptr = V_address;\n      } /* end the for loop */\n\n      /* rt = ((tc-tf)/tc)*100; */\n      ftc = (float)tc;\n      ftf = (float)tf;\n\n      if (tc == 0)\n         rt = 0;\n      else\n         rt = ((ftc-ftf)*100)/ftc;\n\n      printf(\"% -20s %5i   %10iMB %10iMB  %5.2f\\n\",\n             hcsgd_ptr->hcfname,\n             tv,\n             tc,\n             tf,\n             rt);\n\n      hcsgd_ptr = hcsgd_ptr + 1;\n      memset(SSI_Buffer,0,WA_length);    /* clear SSI buffer to NULL */\n   } /* end for loop */\n   /*----------------------------------------------------------------*/\n\n}                                      /* main                        */\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "HCSMS$": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01K\\x00\\x07\\x01\\x14\\x00_\\x01\\x14\\x19\\x1f\\x05#\\x00`\\x00\\x11\\x00\\x00\\xd7\\xc5\\xe3\\xc5\\xd9\\xe3@@@@'", "ispf": {"version": "01.75", "flags": 0, "createdate": "2014-01-05T00:00:00", "modifydate": "2014-07-10T05:23:07", "lines": 96, "newlines": 17, "modlines": 0, "user": "PETERT"}, "text": "//PETERTJ  JOB (12345678),PETERT,MSGCLASS=H,\n//        MSGLEVEL=(1,1),CLASS=A,NOTIFY=&SYSUID\n//*\n//*\n//**\n//EDCCPL   PROC  MEM=,                   < MEMBER NAMR\n//  INFILE='PETERT.HC.PDS',              < INPUT C SOURCE CODE\n//  OUTFILE='PETERT.HC.LOADLIB',         < OUTPUT LOADMODULE PDS\n//  CREGSIZ='48M',                       < COMPILER REGION SIZE\n//  CRUN=,                               < COMPILER RUNTIME OPTIONS\n//  CPARM='LIST,LSEARCH(DD:HCLIB)',      < COMPILER OPTIONS\n//  CPARM2='RENT,NOSEARCH,LONGNAME',     < COMPILER OPTIONS\n//  CPARM3='LANGLVL(EXTENDED),SOURCE',   < COMPILER OPTIONS\n//  CPARM4='NOMAR,NOSEQ,NOOPT,SSCOMM',   < COMPILER OPTIONS\n//  CPARM5='',                           < COMPILER OPTIONS\n//  SYSLBLK='3200',                      < BLOCKSIZE FOR &&LOADSET\n//  LIBPRFX='CEE',                       < PREFIX FOR LIBRARY DSN\n//  LNGPRFX='CBC',                       < PREFIX FOR LANGUAGE DSN\n//  CLANG='EDCMSGE', < NOT USED IN THIS RELEASE. KEPT FOR COMPATIBILITY\n//  PLANG='EDCPMSGE',                    < PRE-LINKER MESSAGE NAME\n//  PREGSIZ='2048K',                     < PRE-LINKER REGION SIZE\n//  PPARM='UPCASE,OMVS',                 < PRE-LINKER OPTIONS\n//  LREGSIZ='1024K',                     < LINK EDIT  REGION SIZE\n//  LPARM='AMODE=31,XREF,LIST,MAP,RENT', < LINK EDIT  OPTIONS\n//  LPARM2=',COMPAT=LKED',               < LINK EDIT  OPTIONS\n//  DCB80='(RECFM=FB,LRECL=80,BLKSIZE=3200)',      <DCB FOR LRECL 80\n//  DCB3200='(RECFM=FB,LRECL=3200,BLKSIZE=12800)', <DCB FOR LRECL 3200\n//  TUNIT='SYSDA'                        < UNIT FOR TEMPORARY FILES\n//*\n//*-------------------------------------------------------------------\n//*  COMPILE STEP:\n//*-------------------------------------------------------------------\n//COMPILE EXEC PGM=CBCDRVR,REGION=&CREGSIZ,\n//    PARM=('&CRUN/&CPARM &CPARM2 &CPARM3 &CPARM4 &CPARM5')\n//STEPLIB  DD  DSNAME=&LIBPRFX..SCEERUN,DISP=SHR\n//         DD  DSNAME=&LNGPRFX..SCBCCMP,DISP=SHR\n//SYSMSGS  DD  DUMMY,DSN=&LNGPRFX..SCBC3MSG(&CLANG),DISP=SHR\n//SYSIN    DD  DSNAME=&INFILE(&MEM),DISP=SHR\n//SYSLIB   DD  DSNAME=&LIBPRFX..SCEEH.H,DISP=SHR\n//         DD  DSNAME=&LIBPRFX..SCEEH.SYS.H,DISP=SHR\n//HCLIB    DD  DSNAME=PETERT.HC.MVSCB,DISP=SHR\n//         DD  DSNAME=PETERT.HC.PDS,DISP=SHR\n//SYSLIN   DD  DSNAME=&&LOADSET,UNIT=&TUNIT.,\n//             DISP=(MOD,PASS),SPACE=(TRK,(3,3)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=&SYSLBLK)\n//SYSPRINT DD  SYSOUT=*\n//SYSOUT   DD  SYSOUT=*\n//SYSCPRT  DD  SYSOUT=*\n//SYSUT1   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),DCB=&DCB80\n//SYSUT4   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),DCB=&DCB80\n//SYSUT5   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),DCB=&DCB3200\n//SYSUT6   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),DCB=&DCB3200\n//SYSUT7   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),DCB=&DCB3200\n//SYSUT8   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),DCB=&DCB3200\n//SYSUT9   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),\n//             DCB=(RECFM=VB,LRECL=137,BLKSIZE=882)\n//SYSUT10  DD  SYSOUT=*\n//SYSUT14  DD  UNIT=&TUNIT.,SPACE=(32000,(30,30)),\n//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)\n//*\n//*-------------------------------------------------------------\n//* PRE-LINKEDIT STEP:\n//*-------------------------------------------------------------\n//PLKED   EXEC PGM=EDCPRLK,PARM='&PPARM',COND=(4,LT,COMPILE),\n//    REGION=&PREGSIZ\n//STEPLIB  DD  DSNAME=&LIBPRFX..SCEERUN,DISP=SHR\n//SYSMSGS  DD  DSNAME=&LIBPRFX..SCEEMSGP(&PLANG),DISP=SHR\n//SYSLIB   DD  DUMMY\n//SYSIN    DD  DSN=*.COMPILE.SYSLIN,DISP=(MOD,DELETE)\n//         DD  DDNAME=SYSIN2\n//SYSMOD   DD  DSNAME=&&PLKSET,UNIT=&TUNIT.,DISP=(NEW,PASS),\n//             SPACE=(32000,(30,30)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=&SYSLBLK)\n//SYSOBJ   DD  DUMMY\n//SYSOUT   DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//SYSIN2   DD  DUMMY\n//*\n//*-------------------------------------------------------------------\n//* LINKEDIT STEP:\n//*-------------------------------------------------------------------\n//LKED   EXEC PGM=HEWL,COND=((4,LT,COMPILE),(4,LT,PLKED)),\n//    REGION=&LREGSIZ,PARM='&LPARM &LPARM2'\n//SYSLIB   DD  DSNAME=&LIBPRFX..SCEELKED,DISP=SHR\n//         DD  DSNAME=SYS1.SERBLINK,DISP=SHR\n//         DD  DSNAME=PETERT.HC.LOADLIB,DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSNAME=*.PLKED.SYSMOD,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSLMOD  DD  DSNAME=&OUTFILE(&MEM),DISP=SHR\n//SYSUT1   DD  UNIT=&TUNIT.,SPACE=(32000,(30,30))\n//SYSIN    DD  DUMMY\n//   PEND\n//*\n//STEP001  EXEC EDCCPL,MEM=HCSMS\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HCSMSJ": {"ttr": 782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01D\\x00V\\x01\\x14\\x00_\\x01\\x14\\x19o\\x06\\x07\\x00\\x08\\x00\\x0c\\x00\\x00\\xd7\\xc5\\xe3\\xc5\\xd9\\xe3@@@@'", "ispf": {"version": "01.68", "flags": 0, "createdate": "2014-01-05T00:00:00", "modifydate": "2014-07-15T06:07:56", "lines": 8, "newlines": 12, "modlines": 0, "user": "PETERT"}, "text": "//PETERTJJ JOB (12345678),PETERT,MSGCLASS=H,\n//        MSGLEVEL=(1,1),CLASS=A,NOTIFY=&SYSUID\n//*\n//*\n//TEST0J   EXEC PGM=HCSMS,PARM='NO ',REGION=0M\n//STEPLIB  DD DSN=PETERT.HC.LOADLIB,DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n//SYSABEND DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LOAD": {"ttr": 784, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x14\\x19o\\x01\\x14\\x19o\\x06\\x16\\x13o\\x13o\\x00\\x00\\xd7\\xc5\\xe3\\xc5\\xd9\\xe3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-07-15T00:00:00", "modifydate": "2014-07-15T06:16:44", "lines": 4975, "newlines": 4975, "modlines": 0, "user": "PETERT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "LOAD$": {"ttr": 2826, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x14\\x19o\\x01\\x14\\x19o\\x06\\x18\\x00\\x0f\\x00\\x0f\\x00\\x00\\xd7\\xc5\\xe3\\xc5\\xd9\\xe3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-07-15T00:00:00", "modifydate": "2014-07-15T06:18:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "PETERT"}, "text": "//PETERTJ  JOB (12345678),PETERT,MSGCLASS=H,\n//        MSGLEVEL=(1,1),CLASS=A,NOTIFY=&SYSUID\n//***************************************************************\n//***************RESTORE LOADLIB DATASET    *********************\n//***************************************************************\n//RST1STEP EXEC PGM=IKJEFT01,DYNAMNBR=30\n//SYSPRINT DD SYSOUT=*\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n  PROFILE NOPREFIX\n  RECEIVE USERID(PETERT) INDSN(PETERT.HC.PDS(LOAD))\n  DSNAME(PETERT.HC.LOADLIB) -\n  UNIT(SYSDA)\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MTCCSUB": {"ttr": 2828, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1c\\x00\\x15\\x01\\x14\\x04o\\x01\\x14\\x14\\x0f\\x06\\x19\\x01\\xf8\\x01\\xc7\\x00\\x00\\xd7\\xc5\\xe3\\xc5\\xd9\\xe3@@@@'", "ispf": {"version": "01.28", "flags": 0, "createdate": "2014-02-15T00:00:00", "modifydate": "2014-05-20T06:19:15", "lines": 504, "newlines": 455, "modlines": 0, "user": "PETERT"}, "text": "/*********************************************************************/\n/* C Socket Server Subtask Program                                   */\n/*                                                                   */\n/* This code is started by the tsched() routine of C/370 MTF.        */\n/* Its purpose is to do a takesocket() and then send/recv with the   */\n/* client process.                                                   */\n/*********************************************************************/\n#pragma runopts(noargparse,plist(mvs),noexecops)\n\nstatic char ibmcopyr\u00dd\u00a8 =\n   \"MTCCSUB - Licensed Materials - Property of IBM. \"\n   \"This module is \\\"Restricted Materials of IBM\\\" \"\n   \"5647-A01 (C) Copyright IBM Corp. 1994, 1996. \"\n   \"See IBM Copyright Instructions.\";\n\n#include <manifest.h>\n#include <bsdtypes.h>\n#include <in.h>\n#include <netdb.h>\n#include <socket.h>\n#include <inet.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <tcperrno.h>\n#include <bsdtime.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unistd.h>\n#include \"hexdump.h\"\n#include \"StoHxS.h\"\n#include \"hccopyr.h\"\n/* --- include z/OS control blocks ---------------------------------- */\n#include \"ihapsa\"                      /* PSA                         */\n#include \"cvt\"                         /* CVT                         */\n#include \"igdsms\"                      /* SMS desct - IGDVLD & IGDSGD */\n#include \"hcsgd\"                       /* HCSGD desct                 */\n#include \"volinfod\"                    /* pick SMS volume information */\n\nstruct psa *psa_ptr = 0;               /* PSA is at address 0         */\nstruct cvt *cvt_ptr;\nstruct igdsgd *igdsgd_ptr;\nstruct igdvld *igdvld_ptr;\nstruct vldsysdt *vldsysdt_ptr;\nstruct hcsgd *hcsgd_ptr;\nstruct volinfod *volinfod_ptr;\n\n/* for dynamic link assembler program                                 */\n#pragma linkage (EXPGM1,OS)\ntypedef int EXPGM1();\n\n#define MAXVOLS 2000;\n\n/*\n * Server subtask\n */\ncsub(int *clsock,         /* address of socket passed  */\n     char *tskname,       /* address of caller's name  */\n     char *tsksname)      /* address of caller's sname */\n{\n    /* EXPGM1 *fptr; */\n    int *voltab;               /* SMS volume work buffer              */\n    int H_address= 0x00000000; /* save SMS volume work buffer address */\n    int pd = 0x00000000;       /* Problem Determination switch        */\n    int WA_length;             /* SMS volume work buffer length       */\n    int hc_rc;                 /*                                     */\n    int records;               /* # records                           */\n    int loop_sw = 0x00000000;  /* loop switch                         */\n    int temps;                 /*                                     */\n    int sendbytes;             /* # bytes sent                        */\n    int recvbytes;             /* # bytes received                    */\n    int clsocket;              /* client socket                       */\n    int rc;                    /*                                     */\n    int i;                     /*                                     */\n    int call_rc;               /*                                     */\n    char xtskname\u00dd8\u00a8;          /* caller's name                       */\n    char xtsksname\u00dd8\u00a8;         /* caller's subtask name               */\n\n    /* for iPhone project - start here    */\n    pd = 0;    /* set PD on(1)-off(0) */\n    WA_length = volwktbl;\n    voltab = (int *)malloc(WA_length);\n    memset(voltab,0,WA_length);\n    H_address = voltab;                   /* save voltab address */\n\n    hc_rc = hcsmstp(voltab, pd);\n    records = hc_rc;\n    printf(\"Csub: returned from hcsmstp program - (%d)\\n\", hc_rc);\n\n    volinfod_ptr = H_address;\n    for(loop_sw=1; loop_sw<=hc_rc; loop_sw++) {\n       printf(\"Csub: SMS volume information: \"\n              \"%s-%s(%d/%d/%d)(%d/%d/%d/%d)\\n\",\n              volinfod_ptr->volstgrp,\n              volinfod_ptr->volvser,\n              volinfod_ptr->volntcpy,\n              volinfod_ptr->volnfree,\n              volinfod_ptr->volnlext,\n              volinfod_ptr->volsysof,\n              volinfod_ptr->volsysln,\n              volinfod_ptr->volstsms,\n              volinfod_ptr->volstmvs);\n       volinfod_ptr = volinfod_ptr + 1;   /* point to next        */\n    } /* end the for for(loop_sw=1) loop */\n    /* for iPhone project - end           */\n\n    clsocket = *clsock;\n    memcpy(&xtskname,  tskname,  8);      /* local copy */\n    memcpy(&xtsksname, tsksname, 8);      /* local copy */\n    rc = doget(&clsocket, xtskname, xtsksname);\n    printf(\"Csub: returned from doget()\\n\");\n    if (rc < 0)\n        tcperror(\"Csub: Error from doget\");\n    printf(\"Csub: rc from doget is %d\\n\", rc);\n\n    temps = rc;         /* new socket number */\n    if (temps > -1) do {\n        sendbytes = dosend(&temps, voltab, records, pd);\n        recvbytes = dorecv(&temps);\n    } while (0);\n /* } while (recvbytes > 0); do simplified situation first ***/\n fflush(stdout);\n /* sleep(30); */\n /*\n i = 30;\n fptr = (EXPGM1 *)fetch(\"WAITIME\");\n call_rc = (*fptr)(&i);\n printf(\"Csub: call_rc is %d\\n\", call_rc);\n release(fptr);\n */\n}\n\n\n\n\n/*-----------------*/\n/*    doget()      */\n/*-----------------*/\nint doget(int *clsocket, char *xtskname, char *xtsksname)\n{\n    int rc;\n    int temps;\n    struct clientid cid;\n\n    memset(&cid, 0, sizeof(cid));\n    temps = *clsocket;\n    memcpy(cid.name,        xtskname,  8);\n    memcpy(cid.subtaskname, xtsksname, 8);\n    cid.domain = AF_INET;\n    rc = takesocket(&cid, temps);\n    *clsocket = temps;\n    return rc;\n}\n\n/*-----------------*/\n/*    dosend()     */\n/*-----------------*/\nint dosend(int *clsocket,\n           int *voltab,\n           int records,\n           int pd)\n{\n    int dataflag = 5542;\n    int optval = 1;\n    int nZero = 0;   /* 0 -> 60 */\n    int crc;\n    int rc;\n    int temps;\n    int recvbytes = 0x00000000;\n    int sendbytes = 0x00000000;\n    int t_sendbytes = 0x00000000;\n    int loop_sw = 0x00000000;\n    char data\u00dd60\u00a8;\n\n    memset(data, 0, 60);   /* set data array to null */\n    volinfod_ptr = voltab;\n    temps = *clsocket;\n\n    /***************************************************************/\n    rc = setsockopt(temps, IPPROTO_TCP, TCP_NODELAY,\n                    (char *) &optval, sizeof(int));\n    printf(\"Csub: set TCP_NODELAY option return value is %d\\n\", rc);\n\n    rc = setsockopt(temps, SOL_SOCKET, SO_SNDBUF,\n                    (char *) &nZero, sizeof(int));\n    printf(\"Csub: set SO_SNDBUF option return value is %d\\n\", rc);\n    /***************************************************************/\n\n    for(loop_sw=1; loop_sw<=records; loop_sw++) {\n       sprintf(data,\n              \"%d.%s.%s.%d.%d.%d.%d.%d.%d.%d\\n\",\n              dataflag,\n              volinfod_ptr->volstgrp,\n              volinfod_ptr->volvser,\n              volinfod_ptr->volntcpy,\n              volinfod_ptr->volnfree,\n              volinfod_ptr->volnlext,\n              volinfod_ptr->volsysof,\n              volinfod_ptr->volsysln,\n              volinfod_ptr->volstsms,\n              volinfod_ptr->volstmvs);\n       /* convert EBCDIC to ASCII */\n       crc = __etoa(data);\n       if (crc < 0)\n          printf(\"Csub: convert E2A failed (%s)\\n\", data);\n       /* sendbytes = send(temps, data, sizeof(data), 0); */\n       sendbytes = send(temps, data, strlen(data), 0);\n       t_sendbytes = t_sendbytes + sendbytes;\n       memset(data, 0, 60);\n       volinfod_ptr = volinfod_ptr + 1;   /* point to next        */\n       recvbytes = recv(temps, data, sizeof(data), 0);\n       /* convert ASCII to EBCDIC */\n       crc = __atoe(data);\n       if (crc < 0)\n          printf(\"Csub: convert A2E failed (%s)\\n\", data);\n       printf(\"Csub: remote response (%s)\\n\", data);\n       memset(data, 0, 60);\n    } /* end the for for(loop_sw=1) loop */\n\n    memset(data, 0, 60);\n    strcpy(data, \"0473.end.the.of.data\");\n    /* convert EBCDIC to ASCII */\n    crc = __etoa(data);\n    if (crc < 0)\n       printf(\"Csub: convert E2A failed (%s)\\n\", data);\n    /* sendbytes = send(temps, data, sizeof(data), 0); */\n    sendbytes = send(temps, data, strlen(data), 0);\n    printf(\"Csub: total sendbytes = %d\\n\", t_sendbytes);\n\n    /* 2014-05-07 by HC Tsai                                        */\n    /* below two statement to fixed TCP state of Close_Wait problem */\n    /*\n    memset(data, 0, 60);\n    recvbytes = recv(temps, data, sizeof(data), 0);\n    */\n\n    return t_sendbytes;\n}\n\n/*-----------------*/\n/*    dorecv()     */\n/*-----------------*/\nint dorecv(int *clsocket)\n{\n    int temps;\n    int crc;\n    int recvbytes;\n    char data\u00dd80\u00a8;\n    char *datap;\n\n    /*****************************************************\n          note: stream mode means that data is not sent\n                as a record and can therefore flow in\n                variable sized chunks across the network.\n                This example is a simplified situation.\n    ******************************************************/\n    temps = *clsocket;\n    recvbytes = recv(temps, data, sizeof(data), 0);\n    /* convert ASCII to EBCDIC */\n    crc = __atoe(data);\n    if (crc < 0)\n       printf(\"Csub: convert A2E failed (%s)\\n\", data);\n    if (recvbytes > 0)\n        printf(\"Csub: data recv: %s\\n\", data);\n    else\n        printf(\"Csub: client stopped sending data\\n\");\n    printf(\"Csub: recvbytes = %d\\n\", recvbytes);\n    return recvbytes;\n}\n\nint hcsmstp(int *voltab, int pd)\n{\n   time_t now;\n\n   EXPGM1 *fptr;                     /* link assembler program        */\n\n   char *str1;                       /* Output buffer                 */\n   char outline\u00dd80\u00a8;                 /* sprintf output work           */\n   int  total_vol = 0x00000000;      /* total volume count            */\n   int  loop_sw = 0x00000000;        /* loop switch                   */\n   int  loop_s1 = 0x00000000;        /* loop switch                   */\n   int  B_address= 0x00000000;       /* store SSI buffer address - SGD*/\n   int  V_address= 0x00000000;       /* store SSI buffer address - VLD*/\n   int  S_address= 0x00000000;       /* system relate data of status  */\n   int  *SSI_Buffer;                 /* Call SSI of work area buffer  */\n   int  H_address= 0x00000000;       /* store HC buffer address       */\n   int  *HC_Buffer;                  /* Call SSI of work area buffer  */\n   int  WA_length;                   /* VLD work area length          */\n   int  tc;                          /* total capacity in megabytes   */\n   int  tf;                          /* total amount free in megabytes*/\n   float rt;                         /* %Used                         */\n   float ftc;\n   float ftf;\n   int  tv;                          /* total volumes                 */\n   int  rc;                          /* link assembler return code    */\n   int  SG_count;                    /* Number of SG defs count       */\n   int  SG_length;                   /* Length of one SGDEF+extents   */\n   int  VL_count;                    /* Number of Volumes count       */\n   int  VL_length;                   /* Length of one def VLDEF       */\n   char SGtype\u00dd3\u00a8 = {0};             /* SG request type               */\n   char SGname\u00dd30\u00a8 = {0};            /* SG name                       */\n   short int SGnameLen = 0x0000;     /* SG name length                */\n\n   WA_length = wktbl;\n   tc = 0;\n   tf = 0;\n   rt = 0;\n   tv = 0;\n\n   /* --begin-------------------------------------------------------- */\n   /* --------------------------------------------------------------- */\n   /* point to volume information storage it from calling program     */\n   /* --------------------------------------------------------------- */\n   volinfod_ptr = voltab;\n   /* --------------------------------------------------------------- */\n   /* Set Things Up                                                   */\n   /* --------------------------------------------------------------- */\n   str1= (char *)malloc(256);          /* Area for printing strings   */\n   memset(str1,0,255);                 /* Zero output buffer          */\n\n   SSI_Buffer = (int *)malloc(WA_length);\n   memset(SSI_Buffer,0,WA_length);\n   B_address = SSI_Buffer;             /* store SSI buffer address    */\n\n   /* --------------------------------------------------------------- */\n   /* Output z/OS System Name                                         */\n   /* --------------------------------------------------------------- */\n   cvt_ptr = psa_ptr->flccvt;        /* CVT at address flccvt         */\n   memcpy(str1,cvt_ptr->cvtsname,8);\n   if (pd > 0) {\n      printf(\"z/OS system identify name: %s\\n \\n\",str1);\n   } /* end if */\n   memset(str1,0,8);                 /* Zero output buffer            */\n\n   fptr = (EXPGM1 *)fetch(\"SMSINFO\");   /* load SMSINFO assembler     */\n\n   strcpy(SGtype, \"SGL\");\n   strcpy(SGname, \"                              \");  /* move spaces */\n   SGnameLen = 0;\n   rc = (*fptr)(SSI_Buffer, &WA_length, &SGtype, &SGname, &SGnameLen);\n   if (pd > 0) {\n      printf(\"<PD MSG>Calling SMSINFO return code is %d\\n\", rc);\n   } /* end if */\n\n   igdsgd_ptr = SSI_Buffer;\n   SG_count = igdsgd_ptr->sgdpcnt;\n   SG_length = igdsgd_ptr->sgdplen;\n   if (pd > 0) {\n      printf(\"<PD MSG>sgdpcnt = %d\\n\", igdsgd_ptr->sgdpcnt);\n      printf(\"<PD MSG>sgdplen = %d\\n\", igdsgd_ptr->sgdplen);\n   } /* end if */\n\n   HC_Buffer = (int *)malloc(hcsgdlen*igdsgd_ptr->sgdpcnt);\n   memset(HC_Buffer,0,(hcsgdlen*igdsgd_ptr->sgdpcnt));\n   H_address = HC_Buffer;             /* store HC buffer address    */\n   hcsgd_ptr = HC_Buffer;\n\n   for(loop_sw=1; loop_sw<=SG_count; loop_sw++) {\n      if (pd > 0) {\n         printf(\"<PD MSG>(%d)sgdfname = %s\\n\",\n                strlen(igdsgd_ptr->sgdfname),\n                igdsgd_ptr->sgdfname);\n         printf(\"<PD MSG>sgdfdesc = %s\\n\", igdsgd_ptr->sgdfdesc);\n         printf(\"<PD MSG>sgdftype = %d\\n\", igdsgd_ptr->sgdftype);\n      }  /* end the if */\n\n      /* copy igdsgd data to hcsgd */\n      strcpy(hcsgd_ptr->hcfname,igdsgd_ptr->sgdfname);\n      strcpy(hcsgd_ptr->hcfdesc,igdsgd_ptr->sgdfdesc);\n      hcsgd_ptr->hcftype = igdsgd_ptr->sgdftype;\n      hcsgd_ptr = hcsgd_ptr + 1;\n\n      B_address = B_address + SG_length;\n      igdsgd_ptr = B_address;\n   } /* end for loop */\n\n   hcsgd_ptr = H_address;\n   if (pd > 0) {\n      for(loop_sw=1; loop_sw<=SG_count; loop_sw++) {\n         printf(\"<PD MSG>(hc buffer - %d)hcfname = %s\\n\",\n                strlen(hcsgd_ptr->hcfname),\n                hcsgd_ptr->hcfname);\n         printf(\"<PD MSG>(hc buffer)hcfdesc = %s\\n\",\n                hcsgd_ptr->hcfdesc);\n         printf(\"<PD MSG>(hc buffer)hcftype = %d\\n\",\n                hcsgd_ptr->hcftype);\n         hcsgd_ptr = hcsgd_ptr + 1;\n      } /* end for loop */\n   }  /* end the if */\n\n   /*----------------------------------------------------------------*/\n   memset(SSI_Buffer,0,WA_length);    /* clear SSI buffer to NULL    */\n   V_address = SSI_Buffer;             /* store SSI buffer address    */\n   hcsgd_ptr = H_address;\n\n   if (pd > 0) {\n   printf(\"SMS DASD Space Information\\n\");\n   printf(\"\\n\");\n   printf(\"Storage Group Name   Volumes     Capacity         Free  %%Used\\n\");\n   printf(\"-------------------------------------------------------------\\n\");\n   }  /* end the if */\n\n   total_vol = 0;  /* initial total volume count */\n   for(loop_sw=1; loop_sw<=SG_count; loop_sw++) {\n      strcpy(SGname,hcsgd_ptr->hcfname);\n      strcpy(SGtype, \"SGV\");\n      SGnameLen = strlen(hcsgd_ptr->hcfname);\n      rc = (*fptr)(SSI_Buffer, &WA_length,\n                   &SGtype, &SGname, &SGnameLen);\n      if (pd > 0) {\n         printf(\"<PD MSG>Calling SMSINFO with SGV \"\n                \"type return code is %d\\n\", rc);\n      } /* end if */\n\n      V_address = SSI_Buffer;          /* store SSI buffer address    */\n      igdvld_ptr = SSI_Buffer;\n      VL_count = igdvld_ptr->vldpcnt;\n      VL_length = igdvld_ptr->vldplen;\n      if (pd > 0) {\n         printf(\"<PD MSG>vldpid  = %s\\n\", igdvld_ptr->vldpid);\n         printf(\"<PD MSG>vldpcnt = %d\\n\", igdvld_ptr->vldpcnt);\n         printf(\"<PD MSG>vldplen = %d\\n\", igdvld_ptr->vldplen);\n      } /* end if */\n      tc = 0;\n      tf = 0;\n      tv = 0;\n      for(loop_s1=1; loop_s1<=VL_count; loop_s1++) {\n         if (pd > 0) {\n            printf(\"<PD MSG>SMS Volume information list: \"\n                   \"%s - %s (%d / %d / %d)\\n\",\n                   igdvld_ptr->vldstgrp,\n                   igdvld_ptr->vldvser,\n                   igdvld_ptr->vldntcpy,\n                   igdvld_ptr->vldnfree,\n                   igdvld_ptr->vldnlext);\n         } /* end if */\n         /* copy SMS volume information for iPhone project */\n         strcpy(volinfod_ptr->volstgrp,igdvld_ptr->vldstgrp);   /*hc00*/\n         strcpy(volinfod_ptr->volvser,igdvld_ptr->vldvser);     /*hc00*/\n         volinfod_ptr->volntcpy = igdvld_ptr->vldntcpy;         /*hc00*/\n         volinfod_ptr->volnfree = igdvld_ptr->vldnfree;         /*hc00*/\n         volinfod_ptr->volnlext = igdvld_ptr->vldnlext;         /*hc00*/\n\n         /* point to System related data  (24 is VLDP length) */\n         S_address = V_address + igdvld_ptr->vldsysof + 24;\n         vldsysdt_ptr = S_address;\n         if (pd > 0) {\n            printf(\"<PD MSG>System status VLDSYSOF - VLDSYSLN \"\n                   \"(SMS/MVS): %d - %d (%d / %d)\\n\",\n                   igdvld_ptr->vldsysof,\n                   igdvld_ptr->vldsysln,\n                   vldsysdt_ptr->vldstsms,\n                   vldsysdt_ptr->vldstmvs);\n         } /* end if */\n         /* copy SMS volume information for iPhone project */\n         volinfod_ptr->volsysof = igdvld_ptr->vldsysof;         /*hc00*/\n         volinfod_ptr->volsysln = igdvld_ptr->vldsysln;         /*hc00*/\n         volinfod_ptr->volstsms = vldsysdt_ptr->vldstsms;       /*hc00*/\n         volinfod_ptr->volstmvs = vldsysdt_ptr->vldstmvs;       /*hc00*/\n         volinfod_ptr = volinfod_ptr + 1;    /* point to next         */\n         total_vol = total_vol + 1;          /* add volume count      */\n\n         /* SMS Status           | MVS Status           */\n         /* 0 - No status given  | 1 - Online           */\n         /* 1 - Enabled          | 2 - Offline          */\n         /* 2 - Quiesce/All      | 3 - Pending offline  */\n         /* 3 - Quiesce/New      | 4 - Boxed            */\n         /* 4 - Disabled/All     | 5 - Not Ready        */\n         /* 5 - Disabled/New                            */\n         if (vldsysdt_ptr->vldstmvs == vldonln) {\n            tc = tc + igdvld_ptr->vldntcpy;\n            tf = tf + igdvld_ptr->vldnfree;\n            tv = tv + 1;\n         } /* end if */\n\n         V_address = V_address + VL_length;\n         igdvld_ptr = V_address;\n      } /* end the for loop */\n\n      /* rt = ((tc-tf)/tc)*100; */\n      ftc = (float)tc;\n      ftf = (float)tf;\n\n      if (tc == 0)\n         rt = 0;\n      else\n         rt = ((ftc-ftf)*100)/ftc;\n\n      if (pd > 0) {\n         printf(\"% -20s %5i   %10iMB %10iMB  %5.2f\\n\",\n                hcsgd_ptr->hcfname,\n                tv,\n                tc,\n                tf,\n                rt);\n      } /* end if */\n\n      hcsgd_ptr = hcsgd_ptr + 1;\n      memset(SSI_Buffer,0,WA_length);    /* clear SSI buffer to NULL */\n   } /* end for loop */\n   /*----------------------------------------------------------------*/\n\n   return (total_vol);   /* return to calling */\n}  /* end the hcsmstp */               /* main                        */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVSCB": {"ttr": 3081, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00R\\x01\\x14\\x19o\\x01\\x14\\x19o\\x05I9\\x9b9\\x9b\\x00\\x00\\xd7\\xc5\\xe3\\xc5\\xd9\\xe3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-07-15T00:00:00", "modifydate": "2014-07-15T05:49:52", "lines": 14747, "newlines": 14747, "modlines": 0, "user": "PETERT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "MVSCB$": {"ttr": 9220, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x05\\x01\\x14\\x19o\\x01\\x14\\x19o\\x05U\\x00\\x0f\\x00\\x0f\\x00\\x00\\xd7\\xc5\\xe3\\xc5\\xd9\\xe3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-07-15T00:00:00", "modifydate": "2014-07-15T05:55:05", "lines": 15, "newlines": 15, "modlines": 0, "user": "PETERT"}, "text": "//PETERTJ  JOB (12345678),PETERT,MSGCLASS=H,\n//        MSGLEVEL=(1,1),CLASS=A,NOTIFY=&SYSUID\n//***************************************************************\n//***************RESTORE MVSCB DATASET      *********************\n//***************************************************************\n//RST1STEP EXEC PGM=IKJEFT01,DYNAMNBR=30\n//SYSPRINT DD SYSOUT=*\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n  PROFILE NOPREFIX\n  RECEIVE USERID(PETERT) INDSN(PETERT.HC.PDS(MVSCB)\n  DSNAME(PETERT.HC.MVSCB) -\n  UNIT(SYSDA)\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDFDOC": {"ttr": 9222, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x14 O\\x01\\x14 O\\x12\\x18\\x1d)\\x1d)\\x00\\x00\\xd7\\xc5\\xe3\\xc5\\xd9\\xe3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-07-23T00:00:00", "modifydate": "2014-07-23T12:18:00", "lines": 7465, "newlines": 7465, "modlines": 0, "user": "PETERT"}, "mimetype": "application/pdf", "datatype": "binary", "extension": ".pdf"}, "SMSINFO": {"ttr": 12292, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00\\x12\\x01\\x14\\x00?\\x01\\x14\\x01\\x1f\\x012\\x00\\xce\\x00D\\x00\\x00\\xd7\\xc5\\xe3\\xc5\\xd9\\xe3@@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2014-01-03T00:00:00", "modifydate": "2014-01-11T01:32:12", "lines": 206, "newlines": 68, "modlines": 0, "user": "PETERT"}, "text": "         TITLE 'SMSINFO - Subroutine for get SMS information'\n***********************************************************************\n*\n* Function   : query SMS through SSI\n*\n* Written by : HC Tsai  mz055t@ms13.hint.net\n*\n*   Arguments:    Address of VLD work area\n*                 Address of VLD work area length\n*                 Address of request type\n*                 Address of Storage Group name\n*                 Address of Storage Group name length\n*   Return:       int - 0 No error from called\n*                      -1 VLD work area address invalid\n*                      -2 VLD work area length invalid\n*                      -3 request type invalid\n*                      -4 SG name invalid\n*                      -5 SG name length invalid\n*                      -8 Call SSI bad return code\n*                      -9 Call SSI bad reason code\n*\n*   C usage:      #pragma linkage (EXPGM1,OS)\n*                 typedef int EXPGM1();\n*\n*                 fptr = (EXPGM1 *)fetch(\"SMSINFO\");\n*                 rc = (*fptr)(&vld,&vldlength,&SGtype,&SGname,\n*                              &SGnameLeghth);\n*\n***********************************************************************\nSMSINFO CSECT\nSMSINFO AMODE 31\nSMSINFO RMODE ANY\n         USING SMSINFO,R15             Register 15 contains address\n         B     START                   Skip data\n         DC    C'SMSINFO'              Program-name\n         DC    C'&SYSDATE'             Date\n         DC    C'&SYSTIME'             Time\n         DC    C'V1R0.00'              Version number\n         DS    0H                      Re-align on halfword-boundary\n*\nSTART    STM   R14,R12,12(R13)         Save registers\n         DROP  R15                     No longer needed as base-reg\n         LR    R12,R15                 Fill reg.12 with base address\n         USING SMSINFO,R12             Now use reg.12 as base\n         LA    R14,SAVEAREA            Address new savearea\n         ST    R13,4(R14)              Point to previous savearea\n         ST    R14,8(R13)              Point to next save-area\n         LR    R13,R14                 Reg.13 points to a free savearea\n*\n*\n* main program here\n*\n         LR    R2,R1                   copy incoming parm address to R2\n         ST    R2,PARM0                Save incoming parm address\n         L     R5,0(,R2)               Get VLD work area address\n         ST    R5,PARM1                Save VLD work area address\n         LTR   R5,R5                   Valid parm address?\n         BZ    SPIFRT1                 No - get out\n         L     R5,4(,R2)               Get VLD work area length\n         ST    R5,PARM2                Save VLD work area length\n         LTR   R5,R5                   Valid parm address?\n         BZ    SPIFRT2                 No - get out\n         L     R5,8(,R2)               Get request type\n         ST    R5,PARM3                Save request type address\n         LTR   R5,R5                   Valid parm address?\n         BZ    SPIFRT3                 No - get out\n         L     R5,12(,R2)              Get SG name\n         ST    R5,PARM4                Save SG name address\n         LTR   R5,R5                   Valid parm address?\n         BZ    SPIFRT4                 No - get out\n         L     R5,16(,R2)              Get SG name length\n         ST    R5,PARM5                Save SG name length address\n         LTR   R5,R5                   Valid parm address?\n         BZ    SPIFRT5                 No - get out\n*\n* CONSTRUCT SSOB\n         XC    WORKSSOB,WORKSSOB       Clear SSOB\n         LA    R8,WORKSSOB             Load SSOB address\n         USING SSOB,R8                 Mapping it\n         MVC   SSOBID,=C'SSOB'         SSOB acron.\n         MVC   SSOBLEN,=AL2(SSOBHSIZ)  SSOB length\n         MVC   SSOBFUNC,=AL2(SSOBSSMS) Function code for SMS services\n         L     R1,CVTPTR(0,0)          -> CVT\n         L     R1,CVTJESCT-CVTMAP(,R1) -> JES2 communication table\n         L     R1,JESCTEXT-JESCT(,R1)  -> Pageable JESCT\n         MVC   SSOBSSIB,JESSMSIB-JESPEXT(R1) -> SMS SSIB\n         O     R8,=X'80000000'         Set last parm\n         ST    R8,PTRSSOB              Save it\n* CONSTRUCT SSSA\n         XC    WORKSSSA,WORKSSSA       Clear SSSA\n         LA    R9,WORKSSSA             Load SSSA address\n         ST    R9,SSOBINDV             Function dependent area poiyter\n         USING IEFSSSA,R9              Map it\n         MVC   SSSAID,=C'SSSA'         SSSA acron.\n         LA    R0,SSSALN+SSSA1LN+32    Length\n         STH   R0,SSSALEN\n         MVC   SSSAVER,=AL2(SSOBSSVR)  Version number\n         MVC   SSSASFN,=AL2(SSSAACTV)  Returns data from the active CFG\n         MVI   SSSAIFLG,SSSANAUT       Caller not authorized\n$C0      EQU   *\n         L     R7,PARM3                Request type\n         CLC   0(3,R7),=C'SGV'         Request SGV?\n         BNE   $C4\n         MVI   SSSA1TYP,SSSA1SGV\n         L     R7,PARM5                SG name length\n         MVC   SSSA1NML,0(R7)\n         L     R7,PARM4                SG name\n         MVC   SSSA1NAM(30),0(R7)\n         B     $C9\n$C4      EQU   *                       Request SGL (default type)\n         MVI   SSSA1TYP,SSSA1SGL       Retrun StorageGroup list\n         B     $C9\n$C9      EQU   *\n         MVC   SSSA1CNT,=F'1'          One request\n         L     R7,PARM2\n         MVC   SSSA1LEN,0(R7)          Length of work area\n         L     R1,PARM1                Get VLD work area\n         ST    R1,SSSA1PTR             Save VLD work area\n* CALL SSI\n         LA    R1,PTRSSOB              Get address of SSOB address\n         IEFSSREQ                      Call SSI\n         LTR   R15,R15                 Test RC\n         BNZ   SPIFRT8                 \u00ac=0 -> exit bad return code\n         L     R1,SSSARSN              Load SSSA reason code\n         LTR   R1,R1                   Test RC\n         BNZ   SPIFRT9                 \u00ac=0 -> exit bad return code\n         DROP  R8,R9                   end of process\n*\n         MVC   RETCODE(4),=F'0'    Set return code\n         B     EXIT00\n*\n*\nEXIT00   DS    0H\n         LA    R15,SAVEAREA            Point to our 'RSA'\n         L     R13,4(,R15)             Restore caller's R13\n         L     R15,RETCODE             Set return code\n         RETURN (14,12),RC=(15)        Restore registers and return\n*\nSPIFRT1 DS     0H\n         MVC   RETCODE(4),=F'-1'       Set return code\n         B     EXIT00                  We're done\nSPIFRT2 DS     0H\n         MVC   RETCODE(4),=F'-2'       Set return code\n         B     EXIT00                  We're done\nSPIFRT3 DS     0H\n         MVC   RETCODE(4),=F'-3'       Set return code\n         B     EXIT00                  We're done\nSPIFRT4 DS     0H\n         MVC   RETCODE(4),=F'-4'       Set return code\n         B     EXIT00                  We're done\nSPIFRT5 DS     0H\n         MVC   RETCODE(4),=F'-5'       Set return code\n         B     EXIT00                  We're done\nSPIFRT8 DS     0H\n         MVC   RETCODE(4),=F'-8'       Set return code\n         B     EXIT00                  We're done\nSPIFRT9 DS     0H\n         MVC   RETCODE(4),=F'-9'       Set return code\n         B     EXIT00                  We're done\n*\n*\n         DS  0F                        Force to fullword\nSAVEAREA DS  18F                       Save-area\nPARM0    DS    F\nPARM1    DS    F\nPARM2    DS    F\nPARM3    DS    F\nPARM4    DS    F\nPARM5    DS    F\nPARM6    DS    F\nPARM7    DS    F\nPARM8    DS    F\nPARM9    DS    F\nPARM10   DS    F\nRETCODE  DS    F\nPTRSSOB  DS    F\n         DS    0D                      Align\nWORKSSOB DS    XL(SSOBHSIZ)            Working SSOB\n         DS    0D                      Align\nWORKSSSA DS    XL(SSSALN+SSSA1LN+32)   Working SSSA\n*\n*\n         LTORG                         All literals\n         CVT DSECT=YES                 CVT\n         IEFJSSOB\n         IEFSSSA\n         IEFJESCT                      JESCT\n*\n         LTORG                         All literals\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT913/FILE913.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT913", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}