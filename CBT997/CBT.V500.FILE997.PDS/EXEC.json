{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SLBD", "INMTNODE": "X", "INMTUID": "Y", "INMFTIME": "20200906192812000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2050048, "INMDSORG": "PO", "INMTYPE": "Data Library", "INMLRECL": 80, "INMBLKSZ": 32720, "INMRECFM": "FB", "INMDIR": 1, "INMDSNAM": "SLBD.ZIGING.ZIGI.EXEC", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2050048, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2050048, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"SLBD.ZIGING.ZIGI.EXEC": {"COPYR1": {"type": "PDSE", "DS1DSORG": 512, "DS1BLKL": 32720, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 8, "DVACLASS": 32, "DVAUNIT": 0, "DVAMAXRC": 32760, "DVACYL": 256, "DVATRK": 256, "DVATRKLN": 65535, "DVAOVHD": 0, "num_header_records": 0}, "COPYR2": {"deb": "b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x00\\x00\\x00\\x04\\x00\\x00\\x00'", "extents": ["b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x00\\x00\\x00\\x04\\x00\\x00\\x00'", "b'\\x00\\x11\\xc8H\\x00\\x00\\x00\\x00\\x00\\x00\\x00~\\x00\\xff\\x7f\\x00'", "b'\\x00\\x11\\xc8H\\x00\\x00\\x00\\x7f\\x00\\x00\\x00\\xfd\\x00\\xff\\x7f\\x00'", "b'\\x00\\x11\\xc8H\\x00\\x00\\x00\\xfe\\x00\\x00\\x00\\xff\\x00\\xff\\x02\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"GITHELP": {"ttr": 211, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x01 \\x07\\x1f\\x01 \\x17\\x1f\\x04Y\\x03\\x92\\x03\\x8d\\x00\\x00\\xe2\\xd3\\xc2\\xc4@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2020-03-11T00:00:00", "modifydate": "2020-06-19T04:59:00", "lines": 914, "newlines": 909, "modlines": 0, "user": "SLBD"}, "text": "  /*---------------------  rexx procedure  -------------------- *\n  | Name:      GitHelp                                         |\n  |                                                            |\n  | Function:  Display a menu (table) of git commands and      |\n  |            allow the user to view the selected help,       |\n  |            filtering using Only xxx and a Refresh          |\n  |            options are provided.                           |\n  |                                                            |\n  | Syntax:   %Githelp help-page(s)                            |\n  |                                                            |\n  | Usage Notes:                                               |\n  |       1. git must be installed on the local OMVS           |\n  |          environment                                       |\n  |       2. The user must have OMVS capabilities              |\n  |                                                            |\n  | Author:    Lionel B. Dyck                                  |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |            06/10/20 LBD - Speed up using shareas=yes       |\n  |            05/17/20 LBD - Enabled to open in split screen  |\n  |            01/25/20 LBD - Support Find command             |\n  |                         - Set default scroll to CSR        |\n  |            01/09/20 LBD - Enhance Only to recurse if empty |\n  |            12/06/19 WJS - Allow help page(s) on command    |\n  |                           Thx to William Schoen            |\n  |            11/21/19 LBD - Test after Only for 0 rows       |\n  |            11/20/19 LBD - Enable a wide screen table       |\n  |                         - Save/Restore before browse       |\n  |            11/18/19 LBD - Set LRECL to 84 where it         |\n  |                           should have been to start wtih   |\n  |            11/10/19 LBD - Creation                         |\n  |                                                            |\n  | ---------------------------------------------------------- |\n  |    Githelp - the z/OS ISPF Git Help Interface              |\n  |    Copyright (C) 2019-2020 - Henri Kuiper and Lionel Dyck  |\n  |                                                            |\n  |    This program is free software: you can redistribute it  |\n  |    and/or modify it under the terms of the GNU General     |\n  |    Public License as published by the Free Software        |\n  |    Foundation, either version 3 of the License, or (at     |\n  |    your option) any later version.                         |\n  |                                                            |\n  |    This program is distributed in the hope that it will be |\n  |    useful, but WITHOUT ANY WARRANTY; without even the      |\n  |    implied warranty of MERCHANTABILITY or FITNESS FOR A    |\n  |    PARTICULAR PURPOSE.  See the GNU General Public License |\n  |    for more details.                                       |\n  |                                                            |\n  |    You should have received a copy of the GNU General      |\n  |    Public License along with this program.  If not, see    |\n  |    <https://www.gnu.org/licenses/>.                        |\n  * ---------------------------------------------------------- */\n\n  parse value '' with rx null status\n  passone   = 0                 /* determine wrap with only */\n  save_floc = 0                 /* Save last find location  */\n  save_find = null              /* save last find string    */\n  scrl      = 'CSR'             /* default scroll amt       */\n  ghtbl     = 'GH'time('s')     /* dynamic table name       */\n\n  arg gitfuncs   /* wjs*/\n  do forever\n    parse var gitfuncs pre 'GIT-' suf\n    if suf='' then leave\n    gitfuncs=pre suf  /* ignore git- command prefixes */\n  end\n\n  /* -------------------------------------- *\n  | Get into ISPF and load the ISPF panels |\n  * -------------------------------------- */\n  address ispexec\n  'vget (zscreenw)'\n  load_info = loadispf()\n\n  call popup 'Getting git OMVS environment variables.'\n\n  /* --------------> Enable Repeat Find <------------------- *\n  | This approach does not require recursion or creating an |\n  | ISPF table for the applications commands. This approach |\n  | updates the active site command table in memory.        |\n  |                                                         |\n  | This does:                                              |\n  | 1. Define the commmand table entry                      |\n  | 2. vget the variable with the prefix for the site ISPF  |\n  |    command table.                                       |\n  | 3. define a varable with the command table name         |\n  | 4. Move to the top of the command table                 |\n  | 5. Establish the table search                           |\n  | 6. if the entry is found then add it                    |\n  | 7. prime the variable to null                           |\n  * ------------------------------------------------------- */\n  zctverb = 'RFIND'\n  zctact = \"&ZIGRFIND\"\n  zctdesc  = \"RFIND for zigi Dialog\"\n  zcttrunc = 0\n  'vget (zsctpref)'\n  if zsctpref = null\n     then zsctpref = 'ISP'\n  ctab = zsctpref'cmds'\n  'tbtop' ctab\n  'tbscan' ctab 'arglist(zctdesc) condlist(EQ) Next'\n  if rc > 0 then 'tbadd' ctab\n  zigrfind = null\n  'vput (zigrfind)'\n\n  /* ---------------------------- *\n  | Get the git OMVS environment |\n  * ---------------------------- */\n  call getenv\n\n  /* -------------- *\n  | Open our table |\n  * -------------- */\n  call create_tab\n\n  /* ---------------------------------------- *\n  | Load the very 1st item - the git manpage |\n  * ---------------------------------------- */\n  gitcmd = 'git'\n  gitcat = 'git manpage'\n  gitc = 1\n  git.gitc = gitcmd gitcat\n  'tbadd' ghtbl\n\n  /* ---------------------- *\n  | Now get the git guides |\n  * ---------------------- */\n  cmd = 'git help -g'\n  x = tcmd(cmd)\n  help=0                 /* wjs*/\n  do i = 1 to so.0\n    if strip(so.i) = null then iterate\n    if left(so.i,1) /= ' ' then iterate\n    if left(so.i,4) = 'The ' then iterate\n    if left(so.i,4) = \"'git\" then leave\n    parse value so.i with gitcmd gitcat\n    gitcmd = strip(gitcmd)\n    gitcat = strip(gitcat)\n    gitc = gitc + 1\n    git.gitc = gitcmd gitcat\n    'tbadd' ghtbl\n    if wordpos(translate(gitcmd),gitfuncs)>0 then /* wjs*/\n    do\n      help=help+1\n      help.help=gitcmd\n    end\n  end\n\n  /* -------------------------------------------- *\n  | Now process the git manpage for git commands |\n  * -------------------------------------------- */\n  cmd = 'man git'\n  x = tcmd(cmd)\n  do i = 1 to so.0\n    if words(so.i) > 1 then iterate\n    if left(word(so.i,1),4) /= 'git-' then iterate\n    if word(so.i,1) = 'CONFIGURATION' then leave\n    if pos('(1)',so.i) = 0 then iterate\n    parse value so.i with gitcmd'(' .\n    gitcmd = strip(gitcmd)\n    j = i + 1\n    gitcat = strip(so.j)\n    gitc = gitc + 1\n    git.gitc = gitcmd gitcat\n    'tbadd' ghtbl\n    if wordpos(translate(substr(gitcmd,5)),gitfuncs)>0 then /* wjs*/\n    do\n      help=help+1\n      help.help=gitcmd\n    end\n  end\n  git.0 = gitc\n\n  help.0=help  /* wjs */\n  do help=1 to help.0\n    x = tcmd('git help' help.help)\n    call browse_cmd\n    drop so. se.\n  end\n\n  if help.0=0 then  /* skip table display if specific help wjs*/\n  do\n    /* ----------------- *\n    | process the table |\n    * ----------------- */\n    stop = 0           /* saved top of table */\n    ztdsels = 0\n    'tbtop' ghtbl\n    /* ----------------- *\n    | Display the table |\n    * ----------------- */\n    if zscreenw = 80 then\n    gpanel = 'githelp'\n    else gpanel = 'githelpw'\n    do forever\n      zcmd = null\n      if stop > 0 then do\n        'tbtop' ghtbl\n        'tbskip' ghtbl 'number('stop')'\n      end\n      /* -------------------------------------------- *\n      | Update ZIGRFIND for Passthru to enable RFIND |\n      * -------------------------------------------- */\n      zigrfind = 'PASSTHRU'\n      'vput (zigrfind)'\n      if ztdsels > 0 then\n      'tbdispl' ghtbl\n      else 'tbdispl' ghtbl 'panel('gpanel')'\n      trc = rc\n      /* ----------------------- *\n      | Reset ZIGRFIND to blank |\n      * ----------------------- */\n      zigrfind = ''\n      'vput (zigrfind)'\n      /* ------------------------------------ *\n      | Test tbdispl return code and proceed |\n      * ------------------------------------ */\n      if trc > 4 then leave\n      if row > 0 then do\n        'tbtop' ghtbl\n        'tbskip' ghtbl 'number('row')'\n      end\n\n      /* -------------------- *\n      | Process any commands |\n      * -------------------- */\n      if zcmd /= null then do\n        Select\n          When abbrev(\"REFRESH\",word(zcmd,1),1) = 1 then call do_refresh\n          When abbrev(\"ONLY\",word(zcmd,1),1) = 1 then call do_only\n          When abbrev(\"FIND\",word(zcmd,1),1) = 1 then do\n            save_floc = ztdtop\n            call do_find\n            end\n          When abbrev(\"RFIND\",word(zcmd,1),1) = 1 then do\n            zcmd = 'FIND' save_find\n            call do_find\n          end\n          Otherwise nop\n        end\n        vsel = null\n      end\n\n      /* -------------------------- *\n      | Process any row selections |\n      * -------------------------- */\n      if vsel /= null then do\n        if gitcmd = 'git' then do\n          x = tcmd('man git')\n        end\n        else do\n          cmd = gitcmd\n          x = tcmd('git help' cmd)\n        end\n        call browse_cmd\n        drop so. se.\n        vsel = null\n      end\n    end\n  end  /* wjs*/\n\n  'tbend' ghtbl\n\n  x = dropispf(load_info)\n  exit\n\ndo_find:\n  /* ------------------------------------------------- *\n  | Find and Repeat Find processed.                   |\n  |                                                   |\n  |   Checks for the provided string in the specified |\n  |   row variables.                                  |\n  * ------------------------------------------------- */\n  find = translate(word(zcmd,2))\n  save_find = find\n  wrap   = 0\n  if save_floc > 0 then do\n    'tbtop' ghtbl\n    'tbskip' ghtbl 'number('save_floc')'\n  end\n  do forever\n    'tbskip' ghtbl\n    if rc > 0 then do\n      'tbtop' ghtbl\n      'tbskip' ghtbl\n      if wrap = 1 then do\n        zerrsm = 'Not Found'\n        zerrlm = find 'string not found in any member' ,\n          'name. Try again.'\n        'setmsg msg(isrz003)'\n        leave\n      end\n      else wrap = 1\n    end\n    if pos(find,translate(gitcmd gitcat)) > 0 then do\n      'tbquery' ghtbl 'position(row)'\n      crp = row\n      save_floc = row\n      if wrap = 1 then do\n        zerrsm = 'Wrapped'\n        zerrlm = 'Find restarted at the top of the table.'\n        'setmsg msg(isrz003)'\n      end\n      else do\n        zerrsm = 'Found'\n        zerrlm = 'Found in row:' row\n        'setmsg msg(isrz003)'\n      end\n      leave\n    end\n  end\n  return\n\n  /* ---------------- *\n  | The Only routine |\n  * ---------------- */\nDo_Only:\n  ostring = translate(word(zcmd,2))\n  'tbtop' ghtbl\n  do forever\n    'tbskip' ghtbl\n    if rc > 0 then leave\n    if pos(ostring,translate(gitcmd gitcat)) = 0 then\n    'tbdelete' ghtbl\n  end\n  'tbquery' ghtbl 'rownum(rows)'\n  if rows = 0 then do\n    call do_refresh\n    if passone = 0 then do\n      passone = 1\n      call do_only\n    end\n    else do\n      zerrhm   = 'zigih00'\n      zerralrm = 'NO'\n      zerrtp   = 'NOTIFY'\n      zerrsm = 'Empty.'\n      zerrlm = 'The Only request resulted in zero rows.' ,\n        'Refreshing the table.'\n      'Setmsg msg(isrz003)'\n    end\n  end\n  passone = 0\n  return\n\n  /* --------------------- *\n  | Create our ISPF Table |\n  * --------------------- */\nCreate_tab:\n  'tbcreate' ghtbl 'names(gitcmd gitcat) nowrite share'\n  return\n\n  /* ----------------------------------- *\n  | routine to browse the manpage/guide |\n  * ----------------------------------- */\nBrowse_Cmd:\n  Address TSO\n  /* ------------------------------- *\n  | Randomly define a DDName to use |\n  * ------------------------------- */\n  dd = 'dd'random(9999)\n  /* ------------------------- *\n  | Fixup null records in so. |\n  * ------------------------- */\n  lrecl = 84\n  do fso = 1 to so.0\n    if so.fso = null then so.fso = '  '\n    if length(so.fso) > lrecl then lrecl = length(so.fso)\n  end\n  /* ------------------------------------------ *\n  | Allocate a temporary data set for our data |\n  * ------------------------------------------ */\n  'Alloc f('dd') new spa(5,5) tr' ,\n    'recfm(v b) lrecl('lrecl+4') blksize(0)'\n  /* ----------------------- *\n  | Write out the stem data |\n  * ----------------------- */\n  'Execio * diskw' dd '(finis stem so.'\n  /* -------------------------------------------------- *\n  | Access the Temporary Data Set using ISPF           |\n  | Library Services.                                  |\n  | Then using ISPF Browse service to browse the data. |\n  | And use Library Services to Free the Data Set.     |\n  * -------------------------------------------------- */\n  Address ISPExec\n  'control display save'\n  'lminit dataid(ddb) ddname('dd')'\n  'browse dataid('ddb')'\n  'lmfree dataid('ddb')'\n  'control display restore'\n  /* ----------------------------- *\n  | Last Free the z/OS Allocation |\n  * ----------------------------- */\n  Address TSO ,\n    'Free f('dd')'\n  return\n\n  /* --------------------------- *\n  | Execute the command in OMVS |\n  * --------------------------- */\ntcmd:\n  parse arg cmd\n  call popup 'Invoking command:' cmd\n  x = bpxwunix(cmd,,so.,se.,env.)\n  return x\n\npopup:\n  parse arg msg1\n  msg2 = 'Patience . . .'\n  call pfshow 'off'           /* make sure pfshow is off */\n  'Addpop row(4) column(12)'\n  'Control Display Lock'\n  'Display Panel(gitpop)'\n  'rempop'\n  call pfshow 'reset'         /* make sure pfshow is reset */\n  return\n\npfshow:\n  if zpfshow = 'OFF' then return\n  arg pfkopt\n  if pfkopt = 'RESET' then do\n    if pfkeys = 'ON' then\n    'select pgm(ispopf) parm(FKA,ON)'\n  end\n  if pfkopt = 'OFF' then do\n    'vget (zpfshow)'\n    pfkeys = zpfshow\n    if pfkeys /= 'OFF' then\n    'select pgm(ispopf) parm(FKA,OFF)'\n  end\n  return\n\n  /* ----------------------------------------------------- *\n  | Get the users current OMVS enviornment for use in the |\n  | bpxwunix commands. Needed for git.                    |\n  * ----------------------------------------------------- */\nGETENV:\n  cmd = 'pwd'\n  e.1 = '_BPX_SHAREAS=YES'\n  e.0 = 1\n  x = bpxwunix(cmd,,so.,se.,e.)\n  home    = strip(so.1)\n  rv=bpxwunix('env',,env.,se.,e.,1)\n  x = env.0\n  x = x + 1\n  env.x = 'HOME='pwd\n  env.0 = x\n  drop so. se.\n  return\n\ndocmd:\n  /* ------------------------------------ *\n  | Routine 'borrowed' from Henri Kuiper |\n  * ------------------------------------ */\n  parse arg cmd\n  if rx = null then do\n    rx = 'export HOME='home' && . /etc/profile > /dev/null 2>&1 && '\n    c = \"\u00dd\u00dd -f \"home\"/.profile \u00a8\u00a8 && echo f\"\n    x = bpxwunix(c,,o.,e.,env.)\n    if o.0 = 1 & o.1 = \"f\" then do\n      rx = rx '. 'home'/.profile > /dev/null 2>&1 && '\n    end\n  end\n  r = rx cmd\n  return r\n\n/*\n>Start\n>Panel tgithelp\n)Attr\n)Body Expand(\\\\)\n+\\-\\%git manpages+\\-\\\n%Command ===>_zcmd\n+\n%GITHELP+displays all the availble git commands, along with other git pages\n+with more information. This will help the git novice, and git guru to better\n+use git.\n+\n%Commands:+\n    %Find+scrolls to a row with the find string in the name or description\n    %Only+removes all rows that do not have the provided string:\n          e.g. %o git\n    %Refresh+is used after Only to rebuild the table\n+\n%Selection:\n    %S+Display the manpage for the selected row.\n    (may also put cursor on the row and press enter or double click)\n+\n+  \"Git knows what you did last summer!\"\n+\n+\n+Press%F3+to return to the GitHelp application.\n+\n)Init\n &zcont = tgithelp\n)Proc\n)End\n>Panel githelpw\n)Attr\n  _ type(input) hilite(uscore)\n  @ type(output) intens(high)\n  $ type(output) intens(low )\n)Body Expand(\\\\) width(&zscreenw)\n+\\-\\%git manpages+\\-\\\n%Command ===>_zcmd                  \\ \\                       %Scroll ===>_scrl+\n+ \\ \\ %F3  +\n+Commands:%Find+string%Only+string%Refresh+\n+Line:%S+select to view\n+\n+S  Command                 Description\n)Model\n_z+@z                      $z\n)Init\n .zvars = '(vsel gitcmd gitcat)'\n .help = tgithelp\n)Proc\n IF (&ZCMD = &Z)\n     if (&ztdsels = 0000)\n        &row = .csrrow\n        if (&row \u00ac= 0)\n            if (&vsel = &z)\n                &vsel = S\n     if (&ztdsels \u00ac= 0000)\n          &row = &z\n     IF (&vsel \u00ac= &Z)\n        if (&vsel = '=')\n           &vsel = &osel\n     &osel = &vsel\n     if (&row = 0)\n        &vsel = &Z\n)End\n>Panel githelp\n)Attr\n  _ type(input) hilite(uscore)\n  @ type(output) intens(high)\n  $ type(output) intens(low )\n)Body Expand(\\\\)\n+\\-\\%git manpages+\\-\\\n%Command ===>_zcmd                                             %Scroll ===>_scrl\n+\n+Commands:%Find+string%Only+string%Refresh+\n+Line:%S+select to view\n+\n+S  Command / Description\n)Model\n_z+@z\n   $z\n)Init\n .zvars = '(vsel gitcmd gitcat)'\n .help = tgithelp\n)Proc\n IF (&ZCMD = &Z)\n     if (&ztdsels = 0000)\n        &row = .csrrow\n        if (&row \u00ac= 0)\n            if (&vsel = &z)\n                &vsel = S\n     if (&ztdsels \u00ac= 0000)\n          &row = &z\n     IF (&vsel \u00ac= &Z)\n        if (&vsel = '=')\n           &vsel = &osel\n     &osel = &vsel\n     if (&row = 0)\n        &vsel = &Z\n)End\n>Panel gitpop\n)ATTR DEFAULT(%+_)\n  @ type(output) caps(off) just(left)\n)BODY WINDOW(58,4)\n+\n@msg1\n@msg2\n+\n)INIT\n  &ZWINTTL = 'GIT Help Popup'\n)END\n>End  */\n\n\n/* --------------------  rexx procedure  -------------------- *\n * Name:      LoadISPF                                        *\n *                                                            *\n * Function:  Load ISPF elements that are inline in the       *\n *            REXX source code.                               *\n *                                                            *\n * Syntax:    load_info = loadispf()                          *\n *            rc = dropispf(load_info)                        *\n *                                                            *\n *            The inline ISPF resources are limited to        *\n *            ISPF Messages, Panels, and Skeletons,           *\n *                 CLISTs and EXECs are also supported.       *\n *                                                            *\n *            The inline resources must start in column 1     *\n *            and use the following syntax:                   *\n *                                                            *\n *            >START    used to indicate the start of the     *\n *                      inline data                           *\n *                                                            *\n *            >END    - used to indicate the end of the       *\n *                      inline data                           *\n *                                                            *\n *            Each resource begins with a type record:        *\n *            >type name                                      *\n *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *\n *                     name is the name of the element        *\n *                                                            *\n * Sample usage:                                              *\n *          -* rexx *-                                        *\n *          load_info = loadispf()                            *\n *          ... magic code happens here (your code) ...       *\n *          rc = dropispf(load_info)                          *\n *          exit                                              *\n *          >Start inline elements                            *\n *          >Panel panel1                                     *\n *          ...                                               *\n *          >Msg msg1                                         *\n *          ...                                               *\n *          >End of inline elements                           *\n *                                                            *\n * Returns:   the list of ddnames allocated for use along     *\n *            with the libdef's performed or altlib           *\n *                                                            *\n *            format is ddname libdef ddname libdef ...       *\n *                   libdef may be altlibc or altlibe         *\n *                   for altlib clist or altlib exec          *\n *                                                            *\n * Notes:     Entire routine must be included with REXX       *\n *            exec - inline with the code.                    *\n *                                                            *\n * Comments:  The entire rexx program is processed from the   *\n *            last record to the first to find the >START     *\n *            record at which point all records from that     *\n *            point on are processed until the >END           *\n *            statement or the end of the program is found.   *\n *                                                            *\n *            It is *strongly* suggested that the inline      *\n *            elements be at the very end of your code so     *\n *            that the search for them is faster.             *\n *                                                            *\n *            Inline ISPTLIB or ISPLLIB were not supported    *\n *            because the values for these would have to be   *\n *            in hex.                                         *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            01/09/19 - Include DROPISPF routine             *\n *            08/29/17 - Fixup static values that were vars   *\n *            05/31/17 - Change default directory count       *\n *            12/09/16 - update for add_it routine            *\n *            05/10/16 - correction for clist and exec        *\n *            04/19/16 - bug correction                       *\n *            06/04/04 - Enhancements for speed               *\n *            08/05/02 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- *\n * Disclaimer: There is no warranty, either explicit or       *\n * implied with this code. Use it at your own risk as there   *\n * is no recourse from either the author or his employeer.    *\n * ---------------------------------------------------------- */\nLoadISPF: Procedure\n\n  parse value \"\" with null kmsg kpanel kskel first returns ,\n    kclist kexec\n/* ------------------------------------------------------- *\n * Find the InLine ISPF Elements and load them into a stem *\n * variable.                                               *\n *                                                         *\n * Elements keyword syntax:                                *\n * >START - start of inline data                           *\n * >CLIST name                                             *\n * >EXEC name                                              *\n * >MSG name                                               *\n * >PANEL name                                             *\n * >SKEL name                                              *\n * >END   - end of all inline data (optional if last)      *\n * ------------------------------------------------------- */\n  last_line = sourceline()\n  do i = last_line to 1 by -1\n    line = sourceline(i)\n    if translate(left(line,6)) = \">START \" then leave\n  end\n  rec = 0\n/* --------------------------------------------------- *\n * Flag types of ISPF resources by testing each record *\n * then add each record to the data. stem variable.    *\n * --------------------------------------------------- */\n  do j = i+1 to last_line\n    line = sourceline(j)\n    if translate(left(line,5)) = \">END \"   then leave\n    if translate(left(line,7)) = \">CLIST \" then kclist = 1\n    if translate(left(line,6)) = \">EXEC \"  then kexec  = 1\n    if translate(left(line,5)) = \">MSG \"   then kmsg   = 1\n    if translate(left(line,7)) = \">PANEL \" then kpanel = 1\n    if translate(left(line,6)) = \">SKEL \"  then kskel  = 1\n    rec  = rec + 1\n    data.rec = line\n  end\n\n/* ----------------------------------------------------- *\n * Now create the Library and Load the Member(s)         *\n * ----------------------------------------------------- */\n  Address ISPExec\n/* ----------------------------- *\n * Assign dynamic random ddnames *\n * ----------------------------- */\n  clistdd = \"lc\"random(999)\n  execdd  = \"le\"random(999)\n  msgdd   = \"lm\"random(999)\n  paneldd = \"lp\"random(999)\n  skeldd  = \"ls\"random(999)\n\n/* ---------------------------------------- *\n *  LmInit and LmOpen each resource library *\n * ---------------------------------------- */\n  if kclist <> null then do\n    call alloc_dd clistdd\n    \"Lminit dataid(clist) ddname(\"clistdd\")\"\n    \"LmOpen dataid(\"clist\") Option(Output)\"\n    returns = strip(returns clistdd 'ALTLIBC')\n  end\n  if kexec <> null then do\n    call alloc_dd execdd\n    \"Lminit dataid(exec) ddname(\"execdd\")\"\n    \"LmOpen dataid(\"exec\") Option(Output)\"\n    returns = strip(returns execdd 'ALTLIBE')\n  end\n  if kmsg <> null then do\n    call alloc_dd msgdd\n    \"Lminit dataid(msg) ddname(\"msgdd\")\"\n    \"LmOpen dataid(\"msg\") Option(Output)\"\n    returns = strip(returns msgdd 'ISPMLIB')\n  end\n  if kpanel <> null then do\n    call alloc_dd paneldd\n    \"Lminit dataid(panel) ddname(\"paneldd\")\"\n    \"LmOpen dataid(\"panel\") Option(Output)\"\n    returns = strip(returns paneldd 'ISPPLIB')\n  end\n  if kskel <> null then do\n    call alloc_dd skeldd\n    \"Lminit dataid(skel) ddname(\"skeldd\")\"\n    \"LmOpen dataid(\"skel\") Option(Output)\"\n    returns = strip(returns skeldd 'ISPSLIB')\n  end\n\n/* ----------------------------------------------- *\n * Process all records in the data. stem variable. *\n * ----------------------------------------------- */\n  do i = 1 to rec\n    record = data.i\n    recordu = translate(record)\n    if left(recordu,5) = \">END \" then leave\n    if left(recordu,7) = \">CLIST \" then do\n      if first = 1 then call add_it\n      type = \"Clist\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,6) = \">EXEC \" then do\n      if first = 1 then call add_it\n      type = \"Exec\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,5) = \">MSG \" then do\n      if first = 1 then call add_it\n      type = \"Msg\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,7) = \">PANEL \" then do\n      if first = 1 then call add_it\n      type = \"Panel\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,6) = \">SKEL \" then do\n      if first = 1 then call add_it\n      type = \"Skel\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n   /* --------------------------------------------*\n    * Put the record into the appropriate library *\n    * based on the record type.                   *\n    * ------------------------------------------- */\n    Select\n      When type = \"Clist\" then\n      \"LmPut dataid(\"clist\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(255)\"\n      When type = \"Exec\" then\n      \"LmPut dataid(\"exec\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(255)\"\n      When type = \"Msg\" then\n      \"LmPut dataid(\"msg\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      When type = \"Panel\" then\n      \"LmPut dataid(\"panel\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      When type = \"Skel\" then\n      \"LmPut dataid(\"skel\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      Otherwise nop\n    end\n  end\n  if type <> null then call add_it\n/* ---------------------------------------------------- *\n * Processing completed - now lmfree the allocation and *\n * Libdef the library.                                  *\n * ---------------------------------------------------- */\n  if kclist <> null then do\n    Address TSO,\n      \"Altlib Act Application(Clist) File(\"clistdd\")\"\n    \"LmFree dataid(\"clist\")\"\n  end\n  if kexec <> null then do\n    Address TSO,\n      \"Altlib Act Application(Exec) File(\"execdd\")\"\n    \"LmFree dataid(\"exec\")\"\n  end\n  if kmsg <> null then do\n    \"LmFree dataid(\"msg\")\"\n    \"Libdef ISPMlib Library ID(\"msgdd\") Stack\"\n  end\n  if kpanel <> null then do\n    \"Libdef ISPPlib Library ID(\"paneldd\") Stack\"\n    \"LmFree dataid(\"panel\")\"\n  end\n  if kskel <> null then do\n    \"Libdef ISPSlib Library ID(\"skeldd\") Stack\"\n    \"LmFree dataid(\"skel\")\"\n  end\n  return returns\n\n/* --------------------------- *\n * Add the Member using LmmAdd *\n * based upon type of resource *\n * --------------------------- */\nAdd_It:\n  Select\n    When type = \"Clist\" then\n    \"LmmAdd dataid(\"clist\") Member(\"name\")\"\n    When type = \"Exec\" then\n    \"LmmAdd dataid(\"exec\") Member(\"name\")\"\n    When type = \"Msg\" then\n    \"LmmAdd dataid(\"msg\") Member(\"name\")\"\n    When type = \"Panel\" then\n    \"LmmAdd dataid(\"panel\") Member(\"name\")\"\n    When type = \"Skel\" then\n    \"LmmAdd dataid(\"skel\") Member(\"name\")\"\n    Otherwise nop\n  end\n  type = null\n  return\n\n/* ------------------------------ *\n * ALlocate the temp ispf library *\n * ------------------------------ */\nAlloc_DD:\n  arg dd\n  Address TSO\n  if pos(left(dd,2),\"lc le\") > 0 then\n  \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(v b) lrecl(255) blksize(32760)\"\n  else\n  \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(f b) lrecl(80) blksize(23440)\"\n  return\n\n/* --------------------  rexx procedure  -------------------- *\n * Name:      DropISPF                                        *\n *                                                            *\n * Function:  Remove ISPF LIBDEF's and deactivate ALTLIB's    *\n *            that were created by the LoadISPF function.     *\n *                                                            *\n * Syntax:    rc = dropispf(load_info)                        *\n *                                                            *\n * Author:    Janko                                           *\n *                                                            *\n * History:                                                   *\n *            12/05/18 - Creation                             *\n * ---------------------------------------------------------- */\nDropISPF: Procedure\n  arg load_info\n  Address ISPEXEC\n  do until length(load_info) = 0\n    parse value load_info with dd libd load_info\n    if left(libd,6) = \"ALTLIB\" then do\n      if libd = \"ALTLIBC\" then lib = \"CLIST\"\n      else lib = \"EXEC\"\n      Address TSO,\n        \"Altlib Deact Application(\"lib\")\"\n    end\n    else \"libdef\" libd\n    address tso \"free f(\"dd\")\"\n  end\n  return 0\nDo_Refresh:\n  'tbend' ghtbl\n  call create_tab\n  do i = 1 to git.0\n    parse value git.i with gitcmd gitcat\n    'tbadd' ghtbl\n  end\n  'tbtop' ghtbl\n  stop = 0\n  return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SAMPLE": {"ttr": 11, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00B\\x00\\x01 \\x04O\\x01 \\x04O\\x13\\x06\\x00\\x11\\x00\\x11\\x00\\x00\\xe9\\xc9\\xc7\\xc9\\xf2\\xf1@@@@'", "ispf": {"version": "01.00", "flags": 66, "createdate": "2020-02-13T00:00:00", "modifydate": "2020-02-13T13:06:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "ZIGI21"}, "text": "  /* --------------------- REXX -------------------------------- *\n  | This is a REXX exec that may be copied into a system level, |\n  | group level, or personal SYSEXEC or SYSPROC library for the |\n  | purpose of making it easy to invoke zigi.                   |\n  |                                                             |\n  | To use customize the exec and panels variables.             |\n  * ----------------------------------------------------------- */\n  arg opt\n  exec   = \"'hlq.exec'\"                 /* <=== update */\n  panels = \"'hlq.panels'\"               /*  <=== update */\n\n  Address TSO 'altlib act application(exec) dataset('exec')'\n  Address ISPexec\n  'libdef ispplib dataset id('panels') stack'\n  \"Select CMD(%zigi\" opt\") Newappl(ZIGI) Passlib Scrname(zigi)\"\n  'libdef ispplib'\n  Address TSO 'altlib deact application(exec)'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZG": {"ttr": 293, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01 \\x00S\\x01 \\t\\x1f\\x01 \"\\x0f\\x05\\x10\\x06 \\x03\\x94\\x00\\x00\\xe9\\xc9\\xc7\\xc9\\xf3\\xf0\\xf1@@@'", "ispf": {"version": "01.32", "flags": 0, "createdate": "2020-03-31T00:00:00", "modifydate": "2020-08-07T05:10:53", "lines": 1568, "newlines": 916, "modlines": 0, "user": "ZIGI301"}, "text": "  /* --------------------  rexx procedure  -------------------- *\n  | Name:      zg                                              |\n  |                                                            |\n  | Function:  Add the selected dataset or member to git       |\n  |            with optional commit and push.                  |\n  |                                                            |\n  |            1st time ask for repo name, then remember it    |\n  |            based on the z/OS dataset name.                 |\n  |                                                            |\n  |            Works best when used on an enhanced ISPF        |\n  |            member list row.                                |\n  |                                                            |\n  | Syntax:    %zd dsname(member) opt                          |\n  |                                                            |\n  |            Only PDS members allowed                        |\n  |                                                            |\n  |            opt values:                                     |\n  |            A    Git Add                                    |\n  |            AC   Git Add and Commit                         |\n  |            ACP  Git Add, Commit, and Push                  |\n  |            blank - prompt via popup                        |\n  |            Anything else force prompt for repo             |\n  |                                                            |\n  | Usage Notes: Requires that zigi has been configured        |\n  |              with the local repositories                   |\n  |                                                            |\n  |              Assumes that the member has been updated      |\n  |              as it will be copied to the OMVS repoistory   |\n  |              and then Commited and Push if requested.      |\n  |                                                            |\n  |              A popup for a short Commit message will       |\n  |              be generated on Commit.                       |\n  |                                                            |\n  | Notes:                                                     |\n  |           1. All ISPF Panels are inline and dynamically    |\n  |              loaded for use by the LOADISPF routine.       |\n  |           2. Must be installed into a default SYSEXEC or   |\n  |              SYSPROC library for use.                      |\n  |           3. For the option to open zigi to work the       |\n  |              zigi stub should be installed as in (2).      |\n  |                                                            |\n  | Author:    Lionel B. Dyck                                  |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |            08/07/20 LBD - Add PFSHOW Off/Reset all Pops    |\n  |            07/29/20 LBD - Add _EDC_ZERO_RECLEN=Y to env.   |\n  |            07/12/20 LBD - Correct TBOpen remove NOWRITE    |\n  |            04/05/20 LBD - Expand Commit message to 7 lines |\n  |            04/04/20 LBD - Place all ISPF panels inline     |\n  |                           to avoid customization req       |\n  |            04/01/20 LBD - Add dsn to repo mapping variable |\n  |            03/31/20 LBD - Rework to enhance                |\n  |            03/29/20 LBD - Finally working                  |\n  |            03/09/20 LBD - Creation                         |\n  |                                                            |\n  | ---------------------------------------------------------- |\n  |    zigi - the z/OS ISPF Git Interface                      |\n  |    Copyright (C) 2020 - Henri Kuiper and Lionel Dyck       |\n  |                                                            |\n  |    This program is free software: you can redistribute it  |\n  |    and/or modify it under the terms of the GNU General     |\n  |    Public License as published by the Free Software        |\n  |    Foundation, either version 3 of the License, or (at     |\n  |    your option) any later version.                         |\n  |                                                            |\n  |    This program is distributed in the hope that it will be |\n  |    useful, but WITHOUT ANY WARRANTY; without even the      |\n  |    implied warranty of MERCHANTABILITY or FITNESS FOR A    |\n  |    PARTICULAR PURPOSE.  See the GNU General Public License |\n  |    for more details.                                       |\n  |                                                            |\n  |    You should have received a copy of the GNU General      |\n  |    Public License along with this program.  If not, see    |\n  |    <https://www.gnu.org/licenses/>.                        |\n  * ---------------------------------------------------------- */\n  arg adddsn opt\n\n  Address ISPExec\n\n  parse value '' with null hit repo open\n\n  /* ------------------------------------------------- *\n  | Validate the input prior to proceeding.           |\n  |                                                   |\n  | ADDDSN must be a pds with a member name provided. |\n  | Opt if non-blank will for repository selection.   |\n  * ------------------------------------------------- */\n  parse source s1 s2 command s4 .\n\n  if adddsn = '?' then adddsn = null\n  if adddsn = null then do\n    zedsmsg = null\n    zedlmsg = left('zigi Git Command - quick add/commit/push',75) ,\n      left('-',75) ,\n      left(command 'syntax is:',75) ,\n      left('zg dataset(member)',75) ,\n      left('or zg dataset(member) opt',75) ,\n      left('Where opt is X to force a prompt for a repository,',75) ,\n      'or the selection option of A, AC, or ACP.'\n    'setmsg msg(isrz001)'\n    exit 8\n  end\n  x = listdsi(adddsn)\n  if x > 0 then do\n    zedsmsg = null\n    zedlmsg = left('zigi Git Command - quick add/commit/push',75) ,\n      left('-',75) ,\n      left('Input dataset name failure:' adddsn,75),\n      sysmsglvl2\n    'setmsg msg(isrz001)'\n    exit 8\n  end\n  if pos('(',adddsn) = 0 then do\n    zedsmsg = null\n    zedlmsg = left('zigi Git Command - quick add/commit/push',75) ,\n      left('-',75) ,\n      left(command 'syntax is:',75) ,\n      left('zg dataset(member)',75) ,\n      left('or zg dataset(member) opt',75) ,\n      left('Where opt is X to force a prompt for a repository,',75) ,\n      'or the selection option of A, AC, or ACP.'\n    'setmsg msg(isrz001)'\n    exit 8\n  end\n\n  'control errors return'\n\n  /* --------------------------------------------- *\n  | Recurse into the zigi applid. This makes it   |\n  | easier to work with the ISPF Profile variable |\n  | with the dsnames and repository names.        |\n  * --------------------------------------------- */\n  'vget (zapplid)'\n  if zapplid /= 'ZIGI' then do\n    'Select cmd(%'command adddsn opt') newappl(zigi) passlib'\n    exit\n  end\n\n  /* ----------------------- *\n  | Load inline ISPF Panels |\n  * ----------------------- */\n  load_info = loadispf()\n\n  /* ------------ *\n  | Clean up Opt |\n  * ------------ */\n  opt = translate(opt,'A','S')\n\n  /* ----------------------------------------------------- *\n  | parse the input dsn for dsn and member with no quotes |\n  * ----------------------------------------------------- */\n  workdsn = strip(adddsn,'B',\"'\")\n  parse value workdsn with dsname'('member')'\n\n  /* -------------------------- *\n  | Validate the input options |\n  * -------------------------- */\n  zsel = opt\n  'vget (zgdsns) profile'\n\n  if wordpos(opt,'A AC ACP') = 0 then\n  if opt /= null then do\n    wp = wordpos(dsname,zgdsns)\n    if wp = 0 then opt = null   /* dsn not found */\n    zgdsns = delword(zgdsns,wp,2)\n    'vput (zgdsns) profile'\n    parse value '' with zsel opt\n  end\n  wp = wordpos(dsname,zgdsns)\n  if wp > 0 then\n  repo = word(zgdsns,wp+1)\n  if repo /= null then\n  if opt = null then do\n    call pfshow 'off'           /* make sure pfshow is off */\n    'Addpop row(4) column(4)'\n    'display panel(zgopt)'\n    drc = rc\n    'rempop'\n    call pfshow 'reset'         /* restore pfshow setting */\n    if drc > 0 then do\n      zedsmsg = 'Canceled.'\n      zedlmsg = 'zigi Add canceled.'\n      'setmsg msg(isrz001)'\n      call get_out_of_here\n    end\n    zsel = opt\n  end\n\n  /* ------------------- *\n  | Open the zigi table |\n  * ------------------- */\n  call pop 'Opening zigi Repository Table \\ Patience.'\n  isptabl = 'ISPTABL'\n  x = listdsi(isptabl 'FILE')\n  if x > 0 then isptabl = 'ISPPROF'\n  'TBOpen zigirepo Library('isptabl') Share'\n  if rc > 8 then do\n    zedsmsg = 'Error.'\n    zedlmsg = 'Unable to open the zigi Local Repository table.' ,\n      'Contact your zigi support individual.'\n    'setmsg msg(isrz001)'\n    call get_out_of_here\n  end\n  open = 1\n\n  call pop 'Looking for current dataset \\ in the Repository.'\n  'tbtop zigirepo'\n  if repo /= null then do forever\n    if repo = zigirep then leave\n    'tbskip zigirepo'\n    if rc > 0 then do\n      repo = null\n      leave\n    end\n  end\n\n  /* --------------------------------------- *\n  | Display repository table to select from |\n  * --------------------------------------- */\n  if repo = null then\n  do forever\n    zsel = null\n    call pfshow 'off'           /* make sure pfshow is off */\n    'addpop'\n    'tbdispl zigirepo panel(zgtbl)'\n    drc = rc\n    'rempop'\n    call pfshow 'reset'         /* restore pfshow setting */\n    if zsel /= null then leave\n    if drc > 0 then do\n      zsel = null\n      call done\n    end\n  end\n\n  /* ----------------------------- *\n  | Get the OMVS environment info |\n  * ----------------------------- */\n  call getenv\n\n  /* ------------------------------------------------- *\n  | Validate that the current dataset is part of repo |\n  * ------------------------------------------------- */\n  if pos('(',workdsn) > 0 then\n  parse value workdsn with workdsn'('member')'\n  else member = null\n  omvsdsn = remove_dsn_hlq(workdsn)\n  cmd = 'cd' localrep'/'zigirep\n  cmd = cmd '&& ls' omvsdsn\n  x = bpxwunix(cmd,,xo.,xe.)\n  if x > 0 then do\n    zedsmsg = 'Invalid.'\n    zedlmsg = left('The requested dataset' adddsn ,76) ,\n      left('is not part of the selected repository:' zigirep,76) ,\n      'as such this command is terminating. Please try again.'\n    'setmsg msg(isrz001)'\n    if wordpos(workdsn,zgdsns) > 0 then do\n      wp = wordpos(workdsn,zgdsns)\n      zgdsns = delword(zgdsns,wp,wp+1)\n      'vput (zgdsns) profile'\n    end\n    call done\n  end\n  drop xo. xe.\n\n  if wordpos(workdsn,zgdsns) = 0 then do\n    zgdsns = zgdsns workdsn zigirep\n    'vput (zgdsns) profile'\n  end\n\n  /* --------------------------------------------------- *\n  | Get the list of binary files                        |\n  | Get the list of datasets to check for file suffixes |\n  * --------------------------------------------------- */\n  call get_dsn_info\n\n  /* -------------------------------- *\n  | Process the repository selection |\n  * -------------------------------- */\n\n  /* ------------------------------------------------------- *\n  | Select/Add dataset or dataset(member) to the repository |\n  | - copy from z/OS to OMVS                                |\n  | - git add it                                            |\n  | Copy occurs with the Open request or the select/add.    |\n  * ------------------------------------------------------- */\n  call pop 'Copying the member to OMVS \\ Patience. . .'\n  if pos(left(zsel,1),'SAO') > 0 then do\n    hit = 1\n    omvsfile = omvsdsn\n    ofile = usssafe(omvsfile)\n    omem  = usssafe(member)\n    if zdsn.omvsdsn = null\n    then rmem = omem\n    else rmem = lower(omem)'.'zdsn.dsn\n    sdsn = usssafe(dsname)\n    copycmd = \"//'\"sdsn\"(\"omem\")'\"\n    copycmd = '\"'copycmd'\"'\n    copycmd = \"cp -U -v\" copycmd\" \"localrep\"/\"zigirep'/'ofile\n    copycmd = copycmd || \"/\"rmem\n    x = bpxwunix(copycmd,,so.,se.)\n    call add_so 'Command:' copycmd\n    if x > 0 then\n    call view_std 'B'\n    call pop 'Adding to Git Index \\ Patience. . .'\n    cmd = 'cd' localrep'/'zigirep'/'ofile\n    cmd = cmd '&& git add' omem\n    x = docmd(cmd)\n    call add_so 'Command:' cmd\n    if x > 0 then\n    call view_std 'B'\n    call git_add_member_stats\n  end\n\n  /* ----------------------------------------- *\n  | Perform Commit Processing (optional Push) |\n  * ----------------------------------------- */\n  if pos('C',zsel) > 0 then do\n    call pfshow 'off'           /* make sure pfshow is off */\n    'Addpop row(4) column(4)'\n    'Display Panel(zgcom)'\n    drc = rc\n    'Rempop'\n    call pfshow 'reset'         /* restore pfshow setting */\n    if drc > 0 then call done\n    if strip(cmsg1 cmsg2 cmsg3 cmsg4 cmsg5 cmsg6 cmsg7) /= null\n    then do\n      cfile = 1\n      call do_cmsg\n    end\n    else cfile = 0\n    hit = 1\n    if pos('P',zsel) > 0\n    then  call pop 'Performing Git Commit/Push \\ Patience. . .'\n    else  call pop 'Performing Git Commit \\ Patience. . .'\n    cmd = 'cd' localrep'/'zigirep\n    if cfile =0 then\n    cmd = cmd \"&& git commit -vm '\"cmsg1\"'\"\n    else do\n      cmd = cmd \"&& git commit -F\" file\n    end\n    if right(zsel,1) = 'P' then\n    cmd = cmd '&& git push -v'\n    if cfile = 1 then\n    cmd = cmd '&& rm' file\n    x = docmd(cmd)\n    call add_so 'Command:' cmd\n    if x > 0 then\n    call view_std 'B'\n    call done\n  end\n\n  /* ------------------------------------------------------------- *\n  | Call zigi to open the repository. Use newappl of ISR to force |\n  | zigi to altlib/libdef it's libraries.                         |\n  * ------------------------------------------------------------- */\n  if zsel = 'O' then do\n    open = 0\n    zigi_repo = zigirep\n    'tbend zigirepo'\n    Address ISPExec 'Select cmd(%zigi' zigi_repo') newappl(isr)'\n    hit = 0\n  end\n\n  /* ---------------- *\n  | Done so clean up |\n  * ---------------- */\ndone:\n  if hit = 1 then do\n    zigidate = date('n')\n    sortdate = date('b')''right(time('s')+100000,5)\n    'tbmod zigirepo order'\n    cmd = 'cd' localrep'/'zigirep\n    cmd = cmd '&& git status'\n    x = docmd(cmd)\n    if x > 0\n    then call view_std 'B'\n    else do\n      zedsmsg = 'Done.'\n      msg = null\n      if pos('A',zsel) > 0 then msg = msg 'Git Add complete'\n      if pos('C',zsel) > 0 then\n      if msg = null then msg = 'Git Commit complete'\n      else msg = msg', and Git Commit complete'\n      if pos('P',zsel) > 0 then\n      if msg = null then msg = 'Git Push complete'\n      else msg = msg', and Git Push complete'\n      if zsel = 'A' then msg = msg', and a Commit/Push should be planned.'\n      if zsel = 'AC' then msg = msg', and a Push should be planned.'\n      zedlmsg = msg\n      'setmsg msg(isrz001)'\n    end\n  end\n\nGet_Out_Of_Here:\n  if open /= 0 then do\n    'tbend zigirepo'\n  end\n  exit 0\n\n  /* ----------------------- *\n  | Generalized Pop Message |\n  | with msg passed         |\n  * ----------------------- */\nPop:\n  parse arg zs1 '\\' zs2\n  add = address()             /* save addressing environment */\n  Address ISPExec\n  call do_popup\n  Address add                 /* restore addressing environment */\n  return\n\n  /* ------------------------------------------------------ *\n  | The pfshow routine will:                               |\n  | 1. check to see the passed option                      |\n  | 2. if Off then it will save the current pfshow setting |\n  |    - save the current setting                          |\n  |    - turn off pfshow                                   |\n  | 3. if the option is Reset then it will                 |\n  |    - test if pfshow was on and turn it back on         |\n  * ------------------------------------------------------ */\npfshow:\n  if zpfshow = 'OFF' then return\n  arg pfkopt\n  if pfkopt = 'RESET' then do\n    if pfkeys = 'ON' then\n    'select pgm(ispopf) parm(FKA,ON)'\n  end\n  if pfkopt = 'OFF' then do\n    'vget (zpfshow)'\n    pfkeys = zpfshow\n    if pfkeys /= 'OFF' then\n    'select pgm(ispopf) parm(FKA,OFF)'\n  end\n  return\n\n  /* ---------------------------------------- *\n  | Common routine for normal (2 line) popup |\n  * ---------------------------------------- */\nDo_Popup:\n  call pfshow 'off'           /* make sure pfshow is off */\n  'Control Display Lock'\n  'Addpop row(4) column(12)'\n  'Display Panel(zigipop)'\n  'Rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  return\n\ndo_cmsg:\n  do i = 1 to 7\n    cmsgd.i = value(cmsg''i)\n    cmsgd.i = cmsgd.i' '\n  end\n  do i = 7 to 1 by -1\n    if strip(cmsgd.i) /= null then leave\n  end\n  cmsgd.0 = i\n  file = 'cmsg'random(999)\n  fdd  = file\n  if sysvar('syspref') = null\n  then filem = sysvar('sysuid')'.'file\n  else filem = file\n  file = localrep'/'file\n  file = \"'\"file\"'\"\n  address tso\n  'alloc f('fdd') new spa(1,1) tr recfm(f b) lrecl(72) blksize(0)',\n    'ds('filem')'\n  'execio * diskw' fdd '(finis stem cmsgd.'\n  'free  f('fdd')'\n  call outtrap 'x.'\n  'oput' filem file 'Text'\n  'delete' filem\n  call outtrap 'off'\n  address ispexec\n  return\n\n  /* ---------------------------------- *\n  | Update stats file after member add |\n  * ---------------------------------- */\nGit_Add_Member_Stats:\n  call pop 'Updating member stats in zigi \\ Patience.'\n  x = zigistat(\"'\"workdsn\"'\" ,\n    localrep'/'zigirep'/.zigi/'omvsfile 'S')\n  statfiles = usssafe(omvsfile)\n  x = docmd('cd' localrep'/'zigirep '&& git add .zigi/'statfiles)\n  return\n\n  /* -------------------------- *\n  | Remove the HLQ for our use |\n  * -------------------------- */\nRemove_DSN_HLQ: Procedure expose qualignr pdshlq\n  arg dsn\n  dsn = translate(strip(dsn,'B',\"'\"),' ','.')\n  if qualignr > 0 then\n  dsn = subword(dsn,qualignr+1)\n  dsn = translate(dsn,'.',' ')\n  return dsn\n\n  /* ------------------------- *\n  | Make dsn safe for OMVS cp |\n  * ------------------------- */\nusssafe: procedure\n  parse arg dsn\n  if pos('$',dsn) = 0 then return dsn\n  /* Let's not usssafe it twice :) */\n  if pos('\\$',dsn) > 0 then return dsn\n  dsn = strreplace(dsn, '$', '\\$')\n  return dsn\n\n  /* ----------------------------------------------------- *\n  | Get the users current OMVS enviornment for use in the |\n  | bpxwunix commands.                                    |\n  * ----------------------------------------------------- */\nGETENV:\n  cmd = 'pwd'\n  x = bpxwunix(cmd,,ho.,he.)\n  home    = strip(ho.1)\n  x = bpxwunix('. /etc/profile && env',,env.,se.)\n  envc = env.0\n  call add_env '_BPX_SHAREAS=YES'\n  call add_env '_BPX_SPAWN_SCRIPT=YES'\n  call add_env 'EXPORT _EDC_ADD_ERRORNO2=1'\n  call add_env 'HOME='home\n  call add_env '_EDC_ZERO_RECLEN=Y'\n  env.0 = envc\n  return\n\n  /* -------------------- *\n  | Add info to env stem |\n  * -------------------- */\nadd_env:\n  parse arg env_val\n  envc = envc + 1\n  env.envc = env_val\n  return\n\ndocmd:\n  parse arg cmd\n  drop so. se.\n  x = bpxwunix(cmd,,so.,se.,env.)\n  return x\n\ndocmdx:\n  /* quircky thing, we need to export HOME as we are\n  not running a login shell via bpxwunix */\n  parse arg cmd\n  cmd = 'pwd'\n  x = bpxwunix(cmd,,ho.,he.)\n  home    = strip(ho.1)\n  drop so. se.\n  rx = 'export HOME='home' && . /etc/profile > /dev/null 2>&1 && '\n  c = \"\u00dd\u00dd -f \"home\"/.profile \u00a8\u00a8 && echo f\"\n  x = bpxwunix(c,,o.,e.)\n  if o.0 = 1 & o.1 = \"f\" then do\n    rx = rx '. 'home'/.profile > /dev/null 2>&1 && '\n  end\n  r = rx cmd\n  return r\n\n  /* ----------------------------- *\n  | Add record to end of so. stem |\n  * ----------------------------- */\nAdd_so: procedure expose so.\n  parse arg text\n  c = so.0\n  c = c + 1\n  so.c = '  '\n  c = c + 1\n  so.c = text\n  so.0 = c\n  return\n\n  /* ---------------------------------------------------------- *\n  | Generalized routine to view stdout. (so.) or stderr. (se.) |\n  | based on the parm passed                                   |\n  * ---------------------------------------------------------- */\nview_std:\n  arg stdopt viewopt\n  if stdopt = null then viewopt = 'B'\n  if viewopt = null then viewopt = 'B'\n  if stdopt = 'X' then stdopt = null\n  if datatype(so.0) /= 'NUM' then so.0 = 0\n  if datatype(se.0) /= 'NUM' then se.0 = 0\n  if viewopt = 'B' then if so.0 + se.0 = 0 then return\n  /* ------------------------------- *\n  | Randomly define a DDName to use |\n  * ------------------------------- */\n  dd = 'zd'random(9999)\n  /* --------------------------------------- *\n  | Get lrecl to determine dcb for temp d/s |\n  * --------------------------------------- */\n  if stdopt /= 'C' then do\n    vlrecl = 0\n    do li  = 1 to so.0\n      so.li = strip(so.li,'T')\n      if length(so.li) > vlrecl then vlrecl = length(so.li)\n      if so.li = null then so.li = ' '\n    end\n    do li  = 1 to se.0\n      se.li = strip(se.li,'T')\n      if length(se.li) > vlrecl then vlrecl = length(se.li)\n      if se.li = null then se.li = ' '\n    end\n    sec = so.0 + se.0\n  end\n  else do\n    do li = 1 to combine.0\n      if length(combine.li) > vlrecl then vlrecl = length(combine.li)\n    end\n    sec = combine.0\n  end\n  if vlrecl < 81 then vlrecl = 80\n  /* ------------------------------------------ *\n  | Allocate a temporary data set for our data |\n  * ------------------------------------------ */\n  Address TSO\n  /* calculate space needed with avg 50 bytes per record */\n  prim = (((so.0 + se.0) * 50) % 56000) + 1\n  if prim < 2 then prim = 5\n  if viewopt = 'V' then do\n    if sysvar('syspref') = null then pref = userid()'.'\n    else pref = null\n    vdsn = pref'work.zigi.gitdata'\n  end\n  else vdsn = null\n  x = listdsi(vdsn)\n  if x = 0 then do\n    call outtrap 'x.'\n    'delete' vdsn\n    call outtrap 'off'\n  end\n  if vdsn /= null then vdsnp = 'da('vdsn') unit(3390)'\n  else vdsnp = null\n  if vlrecl > 255 then vlrecl = 251\n  'Alloc f('dd') new spa('prim','prim') tr' ,\n    'recfm(v b) lrecl('vlrecl+4') blksize(0)' vdsnp\n  /* ----------------------------- *\n  | If stdopt is 'B' then do both |\n  * ----------------------------- */\n  if stdopt /= 'C' then do\n    stdopt = null\n    sc = so.0\n    do xi = 1 to se.0\n      sc = sc + 1\n      so.sc = se.xi\n    end\n    so.0 = sc\n  end\n  /* ----------------------- *\n  | Write out the stem data |\n  * ----------------------- */\n  if stdopt = 'C' then do\n    'Execio * diskw' dd '(finis stem combine.'\n    drop combine.\n    combine.0 = 0\n  end\n  if stdopt /= 'C' then do\n    if stdopt = null\n    then do\n      'Execio * diskw' dd '(finis stem so.'\n    end\n    else do\n      'Execio * diskw' dd '(finis stem se.'\n    end\n  end\n  /* -------------------------------------------------- *\n  | Access the Temporary Data Set using ISPF           |\n  | Library Services.                                  |\n  | Then using ISPF Browse service to browse the data. |\n  | And use Library Services to Free the Data Set.     |\n  * -------------------------------------------------- */\n  Address ISPExec\n  if sec > 0 then if viewopt = 'B' then do\n    'lminit dataid(ddb) ddname('dd')'\n    'browse dataid('ddb')'\n    'lmfree dataid('ddb')'\n  end\n  else do\n    'view dataset('vdsn')'\n    vtitle = null\n    'verase vtitle'\n  end\n  /* ----------------------------- *\n  | Last Free the z/OS Allocation |\n  * ----------------------------- */\n  call outtrap 'x.'\n  Address TSO ,\n    'Free f('dd')'\n  if vdsn /= null then\n  Address TSO 'Delete' vdsn\n  call outtrap 'off'\n  return\n\n  /* ------------------------------------------------- *\n  |                                                  |\n  | String replace routine                           |\n  | input string                                     |\n  | from string                                      |\n  | to string                                        |\n  | translate is input to from                       |\n  * ------------------------------------------------- */\nstrreplace: Procedure\n  string  = arg(1)\n  strfrom = arg(2)\n  strto   = arg(3)\n  if pos(strfrom,string) = 0 then return string\n  newString = ''\n  do i = 1 to length(string)\n    if substr(string,i,1) /= strfrom\n    then newstring = newstring''substr(string,i,1)\n    else  newstring = newstring''strto\n  end\n  return newstring\n\nLower: Procedure\n  parse arg input\n  out = translate(input,\"abcdefghijklmnopqrstuvwxyz\",,\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n  return out\n\n  /* ----------------------------------------- *\n  | Get the .zigi/dsn to find file extensions |\n  * ----------------------------------------- */\nget_dsn_info:\n  zdsn. = null\n  cmd = 'cat' localrep'/'zigirep'/.zigi/dsn'\n  x = bpxwunix(cmd,,s.,e.)\n  if x > 0 then return\n  do di = 1 to s.0\n    zd = word(s.di,1)\n    zdsn.zd = word(s.di,6)\n    zdsn.0 = zd\n  end\n  drop s. e.\n  return\n\n  /* --------------------  rexx procedure  -------------------- *\n  * Name:      LoadISPF                                        *\n  *                                                            *\n  * Function:  Load ISPF elements that are inline in the       *\n  *            REXX source code.                               *\n  *                                                            *\n  * Syntax:    load_info = loadispf()                          *\n  *            rc = dropispf(load_info)                        *\n  *                                                            *\n  *            The inline ISPF resources are limited to        *\n  *            ISPF Messages, Panels, and Skeletons,           *\n  *                 CLISTs and EXECs are also supported.       *\n  *                                                            *\n  *            The inline resources must start in column 1     *\n  *            and use the following syntax:                   *\n  *                                                            *\n  *            >START    used to indicate the start of the     *\n  *                      inline data                           *\n  *                                                            *\n  *            >END    - used to indicate the end of the       *\n  *                      inline data                           *\n  *                                                            *\n  *            Each resource begins with a type record:        *\n  *            >type name                                      *\n  *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *\n  *                     name is the name of the element        *\n  *                                                            *\n  * Sample usage:                                              *\n  *          -* rexx *-                                        *\n  *          load_info = loadispf()                            *\n  *          ... magic code happens here (your code) ...       *\n  *          rc = dropispf(load_info)                          *\n  *          exit                                              *\n  *          >Start inline elements                            *\n  *          >Panel panel1                                     *\n  *          ...                                               *\n  *          >Msg msg1                                         *\n  *          ...                                               *\n  *          >End of inline elements                           *\n  *                                                            *\n  * Returns:   the list of ddnames allocated for use along     *\n  *            with the libdef's performed or altlib           *\n  *                                                            *\n  *            format is ddname libdef ddname libdef ...       *\n  *                   libdef may be altlibc or altlibe         *\n  *                   for altlib clist or altlib exec          *\n  *                                                            *\n  * Notes:     Entire routine must be included with REXX       *\n  *            exec - inline with the code.                    *\n  *                                                            *\n  * Comments:  The entire rexx program is processed from the   *\n  *            last record to the first to find the >START     *\n  *            record at which point all records from that     *\n  *            point on are processed until the >END           *\n  *            statement or the end of the program is found.   *\n  *                                                            *\n  *            It is *strongly* suggested that the inline      *\n  *            elements be at the very end of your code so     *\n  *            that the search for them is faster.             *\n  *                                                            *\n  *            Inline ISPTLIB or ISPLLIB were not supported    *\n  *            because the values for these would have to be   *\n  *            in hex.                                         *\n  *                                                            *\n  * Author:    Lionel B. Dyck                                  *\n  *                                                            *\n  * History:                                                   *\n  *            01/09/19 - Include DROPISPF routine             *\n  *            08/29/17 - Fixup static values that were vars   *\n  *            05/31/17 - Change default directory count       *\n  *            12/09/16 - update for add_it routine            *\n  *            05/10/16 - correction for clist and exec        *\n  *            04/19/16 - bug correction                       *\n  *            06/04/04 - Enhancements for speed               *\n  *            08/05/02 - Creation                             *\n  *                                                            *\n  * ---------------------------------------------------------- *\n  * Disclaimer: There is no warranty, either explicit or       *\n  * implied with this code. Use it at your own risk as there   *\n  * is no recourse from either the author or his employeer.    *\n  * ---------------------------------------------------------- */\nLoadISPF: Procedure\n\n  parse value \"\" with null kmsg kpanel kskel first returns ,\n    kclist kexec\n  /* ------------------------------------------------------- *\n  * Find the InLine ISPF Elements and load them into a stem *\n  * variable.                                               *\n  *                                                         *\n  * Elements keyword syntax:                                *\n  * >START - start of inline data                           *\n  * >CLIST name                                             *\n  * >EXEC name                                              *\n  * >MSG name                                               *\n  * >PANEL name                                             *\n  * >SKEL name                                              *\n  * >END   - end of all inline data (optional if last)      *\n  * ------------------------------------------------------- */\n  last_line = sourceline()\n  do i = last_line to 1 by -1\n    line = sourceline(i)\n    if translate(left(line,6)) = \">START \" then leave\n  end\n  rec = 0\n  /* --------------------------------------------------- *\n  * Flag types of ISPF resources by testing each record *\n  * then add each record to the data. stem variable.    *\n  * --------------------------------------------------- */\n  do j = i+1 to last_line\n    line = sourceline(j)\n    if translate(left(line,5)) = \">END \"   then leave\n    if translate(left(line,7)) = \">CLIST \" then kclist = 1\n    if translate(left(line,6)) = \">EXEC \"  then kexec  = 1\n    if translate(left(line,5)) = \">MSG \"   then kmsg   = 1\n    if translate(left(line,7)) = \">PANEL \" then kpanel = 1\n    if translate(left(line,6)) = \">SKEL \"  then kskel  = 1\n    rec  = rec + 1\n    data.rec = line\n  end\n\n  /* ----------------------------------------------------- *\n  * Now create the Library and Load the Member(s)         *\n  * ----------------------------------------------------- */\n  Address ISPExec\n  /* ----------------------------- *\n  * Assign dynamic random ddnames *\n  * ----------------------------- */\n  clistdd = \"lc\"random(999)\n  execdd  = \"le\"random(999)\n  msgdd   = \"lm\"random(999)\n  paneldd = \"lp\"random(999)\n  skeldd  = \"ls\"random(999)\n\n  /* ---------------------------------------- *\n  *  LmInit and LmOpen each resource library *\n  * ---------------------------------------- */\n  if kclist <> null then do\n    call alloc_dd clistdd\n    \"Lminit dataid(clist) ddname(\"clistdd\")\"\n    \"LmOpen dataid(\"clist\") Option(Output)\"\n    returns = strip(returns clistdd 'ALTLIBC')\n  end\n  if kexec <> null then do\n    call alloc_dd execdd\n    \"Lminit dataid(exec) ddname(\"execdd\")\"\n    \"LmOpen dataid(\"exec\") Option(Output)\"\n    returns = strip(returns execdd 'ALTLIBE')\n  end\n  if kmsg <> null then do\n    call alloc_dd msgdd\n    \"Lminit dataid(msg) ddname(\"msgdd\")\"\n    \"LmOpen dataid(\"msg\") Option(Output)\"\n    returns = strip(returns msgdd 'ISPMLIB')\n  end\n  if kpanel <> null then do\n    call alloc_dd paneldd\n    \"Lminit dataid(panel) ddname(\"paneldd\")\"\n    \"LmOpen dataid(\"panel\") Option(Output)\"\n    returns = strip(returns paneldd 'ISPPLIB')\n  end\n  if kskel <> null then do\n    call alloc_dd skeldd\n    \"Lminit dataid(skel) ddname(\"skeldd\")\"\n    \"LmOpen dataid(\"skel\") Option(Output)\"\n    returns = strip(returns skeldd 'ISPSLIB')\n  end\n\n  /* ----------------------------------------------- *\n  * Process all records in the data. stem variable. *\n  * ----------------------------------------------- */\n  do i = 1 to rec\n    record = data.i\n    recordu = translate(record)\n    if left(recordu,5) = \">END \" then leave\n    if left(recordu,7) = \">CLIST \" then do\n      if first = 1 then call add_it\n      type = \"Clist\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,6) = \">EXEC \" then do\n      if first = 1 then call add_it\n      type = \"Exec\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,5) = \">MSG \" then do\n      if first = 1 then call add_it\n      type = \"Msg\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,7) = \">PANEL \" then do\n      if first = 1 then call add_it\n      type = \"Panel\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,6) = \">SKEL \" then do\n      if first = 1 then call add_it\n      type = \"Skel\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    /* --------------------------------------------*\n    * Put the record into the appropriate library *\n    * based on the record type.                   *\n    * ------------------------------------------- */\n    Select\n      When type = \"Clist\" then\n      \"LmPut dataid(\"clist\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(255)\"\n      When type = \"Exec\" then\n      \"LmPut dataid(\"exec\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(255)\"\n      When type = \"Msg\" then\n      \"LmPut dataid(\"msg\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      When type = \"Panel\" then\n      \"LmPut dataid(\"panel\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      When type = \"Skel\" then\n      \"LmPut dataid(\"skel\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      Otherwise nop\n    end\n  end\n  if type <> null then call add_it\n  /* ---------------------------------------------------- *\n  * Processing completed - now lmfree the allocation and *\n  * Libdef the library.                                  *\n  * ---------------------------------------------------- */\n  if kclist <> null then do\n    Address TSO,\n      \"Altlib Act Application(Clist) File(\"clistdd\")\"\n    \"LmFree dataid(\"clist\")\"\n  end\n  if kexec <> null then do\n    Address TSO,\n      \"Altlib Act Application(Exec) File(\"execdd\")\"\n    \"LmFree dataid(\"exec\")\"\n  end\n  if kmsg <> null then do\n    \"LmFree dataid(\"msg\")\"\n    \"Libdef ISPMlib Library ID(\"msgdd\") Stack\"\n  end\n  if kpanel <> null then do\n    \"Libdef ISPPlib Library ID(\"paneldd\") Stack\"\n    \"LmFree dataid(\"panel\")\"\n  end\n  if kskel <> null then do\n    \"Libdef ISPSlib Library ID(\"skeldd\") Stack\"\n    \"LmFree dataid(\"skel\")\"\n  end\n  return returns\n\n  /* --------------------------- *\n  * Add the Member using LmmAdd *\n  * based upon type of resource *\n  * --------------------------- */\nAdd_It:\n  Select\n    When type = \"Clist\" then\n    \"LmmAdd dataid(\"clist\") Member(\"name\")\"\n    When type = \"Exec\" then\n    \"LmmAdd dataid(\"exec\") Member(\"name\")\"\n    When type = \"Msg\" then\n    \"LmmAdd dataid(\"msg\") Member(\"name\")\"\n    When type = \"Panel\" then\n    \"LmmAdd dataid(\"panel\") Member(\"name\")\"\n    When type = \"Skel\" then\n    \"LmmAdd dataid(\"skel\") Member(\"name\")\"\n    Otherwise nop\n  end\n  type = null\n  return\n\n  /* ------------------------------ *\n  * ALlocate the temp ispf library *\n  * ------------------------------ */\nAlloc_DD:\n  arg dd\n  Address TSO\n  if pos(left(dd,2),\"lc le\") > 0 then\n  \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(v b) lrecl(255) blksize(32760)\"\n  else\n  \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(f b) lrecl(80) blksize(23440)\"\n  return\n\n  /* --------------------  rexx procedure  -------------------- *\n  * Name:      DropISPF                                        *\n  *                                                            *\n  * Function:  Remove ISPF LIBDEF's and deactivate ALTLIB's    *\n  *            that were created by the LoadISPF function.     *\n  *                                                            *\n  * Syntax:    rc = dropispf(load_info)                        *\n  *                                                            *\n  * Author:    Janko                                           *\n  *                                                            *\n  * History:                                                   *\n  *            12/05/18 - Creation                             *\n  * ---------------------------------------------------------- */\nDropISPF: Procedure\n  arg load_info\n  Address ISPEXEC\n  do until length(load_info) = 0\n    parse value load_info with dd libd load_info\n    if left(libd,6) = \"ALTLIB\" then do\n      if libd = \"ALTLIBC\" then lib = \"CLIST\"\n      else lib = \"EXEC\"\n      Address TSO,\n        \"Altlib Deact Application(\"lib\")\"\n    end\n    else \"libdef\" libd\n    address tso \"free f(\"dd\")\"\n  end\n  return 0\n\n/*   Start of inline ISPF Panels - do NOT use REXXFORM option CI\n>Start\n>Panel zgopt\n)Attr\n_ type(input) hilite(uscore) caps(on) intens(low) just(left)\n)Body Window(43,3)\n+Enter Git Option:_opt+(A, AC, ACP, or O)\n+\n+Press%Enter+to Continue, or%F3+to Cancel.\n)Init\n&zwinttl = 'zigi Git Option'\n)Proc\nver (&opt,nb,list,A,AC,ACP,S,SC,SCP,O)\n)End\n>Panel zgtbl\n)Attr\n_ type(input) hilite(uscore) caps(on) intens(low) just(left)\n$ type(output) caps(off)\n\u00a8 type(output) caps(off) intens(low)\n} type(output) caps(off) intens(low) just(right)\n@ type(text) caps(off) intens(high) color(white) hilite(uscore)\n)Body Window(64,15) expand(\\\\)\n+\n%Command ===>_zcmd       \\ \\ %Scroll ===>_zscr+\n+\n+Selection:%A+Add%AC+Add/Commit%ACP+Add/Commit/Push%O+Open zigi\n+\n%    @Repository             Category        Last Date  +\n)Model\n_z  +$z                  +  \u00a8z             +}z          +\n)Init\n&zwinttl = 'Update Git Repository'\n&zscr = CSR\n.zvars = '(zsel zigirep zigicat zigidate)'\n)Proc\nVer (&zsel,list,A,AC,O,S,SC,ACP,SCP)\n)End\n>Panel zgcom\n)Attr\n_ type(input) hilite(uscore) caps(off) intens(low) just(left)\n)Body Window(68,10)\n+Enter Commit Message:\n_cmsg1                                                            +\n_cmsg2                                                            +\n_cmsg3                                                            +\n_cmsg4                                                            +\n_cmsg5                                                            +\n_cmsg6                                                            +\n_cmsg7                                                            +\n+\n+Press%Enter+to Continue, or%F3+to Cancel.\n)Init\n&zwinttl = 'zigi Commit Message'\n)Proc\nver (&cmsg1,nb)\n)End\n>Panel zigipop\n)Attr\n $ type(output) caps(off)\n)Body Window(54,4)\n+\n  $zs1\n  $zs2\n\n)Init\n &zwinttl = 'zigi Status Popup'\n)Proc\n)end\n/* -------------------------------------------------------- */\n/* zigi - the z/OS ISPF Git Interface                       */\n/* Copyright (C) 2020 GPL V3 - Henri Kuiper and Lionel Dyck */\n/* -------------------------------------------------------- */\n>Exec zigistat\n  /* --------------------  rexx procedure  -------------------- *\n  | Name:      zigistat                                        |\n  |                                                            |\n  | Function:  Collect or Compare the ISPF Stats for all       |\n  |            members in a PDS                                |\n  |                                                            |\n  | Syntax:    x=zigistat(dsname filepath option)              |\n  |                                                            |\n  |            dsname is the z/OS dataset name to work with    |\n  |                                                            |\n  |            filepath is the OMVS file where the stats are   |\n  |            stored and consists of:                         |\n  |                localdir/repodir/.zigi/filename             |\n  |                filename is the OMVS file that represents   |\n  |                the z/OS PDS dataset name                   |\n  |                                                            |\n  | Options:   C - compare stats                               |\n  |            S - save stats                                  |\n  |            U - update stats to those saved                 |\n  |                used when creating/refreshing datasets      |\n  |                                                            |\n  | Vars:      statmems ispf variable for selective update     |\n  |                                                            |\n  | Usage                                                      |\n  |   Notes: Subroutine of zigi                                |\n  |          Returns string of members changed                 |\n  |                                                            |\n  | Dependencies:                                              |\n  |          ISPF services                                     |\n  |                                                            |\n  | Return:                                                    |\n  |          0 - stats saved or stats applied                  |\n  |          8 - no dsname provided                            |\n  |         12 - no filepath provided                          |\n  |         16 - no option provided                            |\n  |         20 - stats file in /.zigi missing                  |\n  |     string - string of members with different stats        |\n  |                                                            |\n  | Author:    Lionel B. Dyck                                  |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |            01/08/20 LBD - Selecitve stat update if statmems|\n  |            01/05/20 LBD - Correct special chars in filepath|\n  |                           using usssafe routine            |\n  |            11/22/19 LBD - If a member has no stats - add   |\n  |            11/18/19 LBD - Many fixes and add Debug         |\n  |            11/15/19 LBD - Creation                         |\n  |                                                            |\n  | ---------------------------------------------------------- |\n  |    zigi - the z/OS ISPF Git Interface                      |\n  |    Copyright (C) 2020 - Henri Kuiper and Lionel Dyck       |\n  |                                                            |\n  |    This program is free software: you can redistribute it  |\n  |    and/or modify it under the terms of the GNU General     |\n  |    Public License as published by the Free Software        |\n  |    Foundation, either version 3 of the License, or (at     |\n  |    your option) any later version.                         |\n  |                                                            |\n  |    This program is distributed in the hope that it will be |\n  |    useful, but WITHOUT ANY WARRANTY; without even the      |\n  |    implied warranty of MERCHANTABILITY or FITNESS FOR A    |\n  |    PARTICULAR PURPOSE.  See the GNU General Public License |\n  |    for more details.                                       |\n  |                                                            |\n  |    You should have received a copy of the GNU General      |\n  |    Public License along with this program.  If not, see    |\n  |    <https://www.gnu.org/licenses/>.                        |\n  * ---------------------------------------------------------- */\nzigistat:\n\n  /* --------------- *\n  | Define defaults |\n  * --------------- */\n  parse value '' with null string m. rx allmems\n  zdd = 'ZS'time('s')\n\n  /* --------------------------------- *\n  | Check for parms and return if not |\n  * --------------------------------- */\n  parse arg dsn filepath opt\n  if dsn      = null then return 8\n  if filepath = null then return 12\n  if opt      = null then return 16\n  opt         = translate(opt)   /* make upper case */\n\n  /* ---------------------------------------- *\n  | Check for ZIGIDEBG DD for debug purposes |\n  * ---------------------------------------- */\n  x = listdsi('ZIGIDEBG' 'FILE')\n  if x > 0 then if sysreason = 3\n  then zigidebg = 1\n  else zigidebg = 0\n\n  Address ISPExec\n  'vget (debugfil)'\n\n  x = debug('start of zigistat with option:' opt)\n\n  /* --------------------------------------- *\n  | If option C or U then read in the stats |\n  | - check if stats member exists rc=16    |\n  | - read into stem stats.                 |\n  * --------------------------------------- */\n  if pos(opt,'C U') > 0 then do\n    x = debug('Checking stats file' filepath)\n    x = check_stats_file(filepath)\n    rc = x\n    x = debug('Checking stats file complete')\n    if rc > 0 then return x\n    x = debug('Reading the ISPF stats file')\n    drop stats.\n    cmd = 'cat' filepath\n    x = bpxwunix(cmd,,stats.,se.)\n    do i = 1 to stats.0\n      stats.i = translate(stats.i,' ','0D'x)\n    end\n    x = debug('Reading complete')\n  end\n\n  /* ------------------ *\n  * Define ISPF Dataid *\n  * ------------------ */\n  \"LMINIT DATAID(STATUS) DATASET(\"dsn\")\"\n  \"LMOPEN DATAID(\"STATUS\") OPTION(INPUT)\"\n\n  /* ------------ *\n  * Set defaults *\n  * ------------ */\n  x = debug('Collecting stats for all members for:' dsn)\n  parse value null with member mem. ,\n    ZLCDATE ZLMDATE ZLVERS ZLMOD ZLMTIME ZLCNORC,\n    ZLINORC ZLMNORC ZLUSER ,\n    zlcnorce zlinorce zlmnorce\n  mem.0  = 0\n\n  /* ----------------------- *\n  * Now process all members *\n  * ----------------------- */\n  do forever\n    \"LMMLIST Dataid(\"status\") OPTION(LIST) MEMBER(MEMBER)\" ,\n      \"STATS(YES)\"\n    /* --------------------------------- *\n    * If RC 4 or more leave the do loop *\n    * --------------------------------- */\n    if rc > 3 then leave\n    /* -------------------------------- *\n    | Check if no stats then add them. |\n    * -------------------------------- */\n    if zlcdate = null then do\n      'LMMSTATS DATAID('status') Member('member') user('sysvar(sysuid)')'\n      \"LMMFind DATAID(\"status\") Member(\"member\") STATS(YES)\"\n    end\n    /* ------------------------------ *\n    * Add each member info to a stem *\n    * ------------------------------ */\n    c = mem.0 + 1\n    mem.c = strip(member ,\n      ZLCDATE  ZLMDATE  ZLVERS ZLMOD ZLMTIME ZLCNORC ,\n      ZLINORC ZLMNORC ZLUSER ,\n      zlcnorce zlinorce zlmnorce)\n    mem.0 = c\n    if opt = 'C' then allmems = allmems member\n  end\n\n  /* ------------------------- *\n  * Close and Free the Dataid *\n  * ------------------------- */\n  \"LMClose Dataid(\"status\")\"\n  \"LMFree  Dataid(\"status\")\"\n  x = debug('Stat collection complete.')\n\n  /* ----------------------------------------------- *\n  | Process the data based on the provided options: |\n  |                                                 |\n  |    C - compare stats                            |\n  |    S - save stats                               |\n  |    U - update stats to those saved              |\n  |        used when creating/refreshing datasets   |\n  * ----------------------------------------------- */\n  Select\n    /* ----------------------------------------------------- *\n    | Save all stats for all members in the active dataset. |\n    | - data will be saved to /.zigi/filename               |\n    * ----------------------------------------------------- */\n    When opt = 'S' then do\n      x = debug('Saving stats begins to:' filepath)\n      x = bpxwunix('rm' usssafe(filepath),,so.,se.)\n      call write_stats\n      x = debug('Saving stats completed.')\n      return 0\n    end\n    /* ---------------------------------------------------------- *\n    | Update ISPF Stats:                                         |\n    |  - all members in the zigi stats member will have their    |\n    |    ispf stats updated to reflect the saved stats           |\n    |  - Use statmems ispf var for selective stat updates        |\n    |  - new members will not be updated as we don't know about  |\n    |   them                                                     |\n    |  - members with no stats will have stats added if they are |\n    |    in the saved stats member                               |\n    * ---------------------------------------------------------- */\n    When opt = 'U' then do\n      x = debug('Performing ISPF Stats file update for:' dsn)\n      'vget (statmems)'\n      if statmems /= null then do\n        x = debug('Update Members:' statmems)\n      end\n      \"LMINIT DATAID(zstats) DATASET(\"dsn\")\"\n      \"LMOPEN DATAID(\"zstats\") OPTION(INPUT)\"\n      do i = 1 to stats.0\n        parse value stats.i with member ZLCDATE ZLMDATE ZLVERS ZLMOD ,\n          ZLMTIME ZLCNORC ZLINORC ZLMNORC ZLUSER ZLCNORCE ,\n          ZLINORCE ZLMNORCE .\n        if statmems /= null then\n        if wordpos(member,statmems) = 0 then iterate\n        if zlcdate = null then ,\n          'LMMSTATS DATAID('zstats') Member('member') user('sysvar(sysuid)')'\n        else ,\n          'LMMSTATS DATAID('zstats') MEMBER('member') VERSION('zlvers')' ,\n          'MODLEVEL('zlmod') CREATED('zlcdate') MODDATE('zlmdate')' ,\n          'MODTIME('zlmtime') INITSIZE('zlinorc')' ,\n          'MODRECS('zlmnorc') USER('zluser')'\n      end\n      \"LMClose Dataid(\"zstats\")\"\n      \"LMFree  Dataid(\"zstats\")\"\n      x = debug('ISPF Stats file update complete.')\n      return 0\n    end\n    /* ----------------------------------------------------------- *\n    | Compare ISPF stats.                                         |\n    |                                                             |\n    | Comparison will be from the active datasets ISPF stats with |\n    | the saved stats found in ISPF stats file in /.zigi          |\n    |                                                             |\n    | If a member is in the active but not in the saved list then |\n    | it will be added to the returned string.                    |\n    |                                                             |\n    | If a members saved stats do not match the active stats then |\n    | it will be added to the returned string.                    |\n    * ----------------------------------------------------------- */\n    When opt = 'C' then do\n      x = debug('ISPF Stats comparison starting.')\n      /* 1st setup the saved stem for easy comparison */\n      do i = 1 to stats.0\n        parse value stats.i with savedmem data\n        m.savedmem = strip(data)\n      end\n      /* now compare active to saved */\n      do i = 1 to mem.0\n        parse value mem.i with actmem data\n        data = strip(data)\n        if m.actmem = null then string = string actmem\n        else if data /= m.actmem then string = string actmem\n      end\n      'vput (allmems)'\n      x = debug('ISPF Stats comparison complete:' string)\n      return string\n    end\n    Otherwise nop  /* should never get here */\n  end\n\n  /* -------------------------------------------- *\n  | Check to see if the provided filepath exists |\n  | rc 0 it does                                 |\n  | rc 20 it does not                            |\n  * -------------------------------------------- */\nCheck_Stats_File:\n  save_address = address()\n  address syscall 'lstat' filepath 'file.'\n  if file.0 = 0 then do\n    ADDRESS value(save_address)\n    return 20\n  end\n  else return 0\n\n  /* ----------------------------------------------------- *\n  | Get the users current OMVS enviornment for use in the |\n  | bpxwunix commands. Being selective.                   |\n  * ----------------------------------------------------- */\nGETENV:\n  cmd  = docmdx('env')\n  rc = bpxwunix(cmd,,so.,se.)\n  envc = 0\n  do ci = 1 to so.0\n    if left(so.ci,3) = 'GIT' then call add_env so.ci\n    if left(so.ci,4) = 'HOME' then call add_env so.ci\n    if left(so.ci,4) = 'PATH' then call add_env so.ci\n    if left(so.ci,4) = 'MANP' then call add_env so.ci\n    if left(so.ci,4) = 'LIBP' then call add_env so.ci\n    if left(so.ci,3) = 'PWD' then call add_env so.ci\n  end\n  call add_env '_BPX_SHAREAS=YES'\n  call add_env '_BPX_SPAWN_SCRIPT=YES'\n  call add_env '_EDC_ZERO_RECLEN=Y'\n  env.0 = envc\n  drop so. se.\n  return\n\n  /* -------------------- *\n  | Add info to env stem |\n  * -------------------- */\nadd_env:\n  parse arg env_val\n  envc = envc + 1\n  env.envc = env_val\n  return\n\ndocmd:\n  parse arg cmd\n  drop so. se.\n  x = bpxwunix(cmd,,so.,se.,env.)\n  return x\n\ndocmdx:\n  /* quircky thing, we need to export HOME as we are\n  not running a login shell via bpxwunix */\n  parse arg cmd\n  drop so. se.\n  if rx = null then do\n    rx = 'export HOME='home' && . /etc/profile > /dev/null 2>&1 && '\n    c = \"\u00dd\u00dd -f \"home\"/.profile \u00a8\u00a8 && echo f\"\n    x = bpxwunix(c,,o.,e.)\n    if o.0 = 1 & o.1 = \"f\" then do\n      rx = rx '. 'home'/.profile > /dev/null 2>&1 && '\n    end\n  end\n  r = rx cmd\n  return r\n\n  /* ----------------------------- *\n  | Write out the ISPF Stats file |\n  * ----------------------------- */\nWrite_Stats:\n  call syscalls 'ON'\n  address syscall\n  /* Fill dsn file with the comments */\n  /* look like the 'open' command does the escaping for us... */\n  fpok = strreplace(filepath,'\\$', '$')\n  'open' fpok O_rdwr+O_creat+O_trunc 660\n  if retval = -1 then do\n    Address ISPExec\n    zs1 = \"Something bad when creating\"\n    zs2 = filepath\n    zs4 = 'Press F3 to close this popup and exit.'\n    parse value '' with zs3\n    call do_popup4\n    call syscalls 'OFF'\n    return\n  end\n  fd = retval\n  do is = 1 to mem.0\n    call write_fd mem.is\n  end\n  'close' fd\n  call syscalls 'OFF'\n  Address ISPExec\n  return\n\n  /* ----------------------------------- *\n  | Routine to write out a line of data |\n  * ----------------------------------- */\nWrite_FD:\n  parse arg string\n  string = string || ESC_R || ESC_N\n  'write' fd 'string' length(string)\n  return\n\n  /* ----------------------------------- *\n  | Issue popup - turn off pfshow if on |\n  * ----------------------------------- */\nDo_Popup4:\n  call pfshow 'off'           /* make sure pfshow is off */\n  'Addpop row(4) column(6)'\n  'Display Panel(zigipop4)'\n  'Rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  return\n\n  /* -------------------------------- *\n  | routine to turn off pfshow if on |\n  * -------------------------------- */\npfshow:\n  if zpfshow = 'OFF' then return\n  arg pfkopt\n  if pfkopt = 'RESET' then do\n    if pfkeys = 'ON' then\n    'select pgm(ispopf) parm(FKA,ON)'\n  end\n  if pfkopt = 'OFF' then do\n    'vget (zpfshow)'\n    pfkeys = zpfshow\n    if pfkeys /= 'OFF' then\n    'select pgm(ispopf) parm(FKA,OFF)'\n  end\n  return\n\ndebug:\n  if zigidebg  = 1 then do\n    parse arg msg\n    msg = Date() Time()' : 'msg\n    c = 'echo \"'msg'\" >>' debugfil\n    x = bpxwunix(c,,dso.,dse.)\n  end\n  return 0\n\n  /* ---------------------------------- *\n  | Make the z/OS dsname safe for OMVS |\n  * ---------------------------------- */\nusssafe: procedure\n  parse arg dsn\n  if pos('$',dsn) = 0 then return dsn\n  /* Let's not usssafe it twice :) */\n  if pos('\\$',dsn) > 0 then return dsn\n  dsn = strreplace(dsn, '$', '\\$')\n  return dsn\n\nSTRREPLACE:\n  ORIGINAL = ARG(1)\n  OLDTXT = ARG(2)\n  NEWTXT = ARG(3)\n  /* YOU CAN CHANGE THE BELOW KEY (TMPTXT), WHICH IS USED AS A TEMPORARY\n  POINTER TO IDENTIFY THE TEXT TO BE REPLACED */\n  TMPTXT = '6A53CD2EW1F'\n  NEWSTR = ORIGINAL\n  DO WHILE POS(OLDTXT,NEWSTR) > 0\n    NEWSTR = SUBSTR(NEWSTR, 1 , POS(OLDTXT,NEWSTR)-1) ||,\n      TMPTXT || SUBSTR(NEWSTR, POS(OLDTXT,NEWSTR) + LENGTH(OLDTXT))\n  END\n  DO WHILE POS(TMPTXT,NEWSTR) > 0\n    NEWSTR = SUBSTR(NEWSTR, 1 , POS(TMPTXT,NEWSTR)-1) ||,\n      NEWTXT || SUBSTR(NEWSTR, POS(TMPTXT,NEWSTR) + LENGTH(TMPTXT))\n  END\n  RETURN NEWSTR\n>End    End of inline ISPF Panels */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZGBATCH": {"ttr": 301, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01 \\x00H\\x01 \\x15o\\x01 \"\\x1f\\x05H\\x01\\xee\\x00S\\x00\\x00\\xe9\\xc9\\xc7\\xc9\\xf3\\xf0\\xf1@@@'", "ispf": {"version": "01.32", "flags": 0, "createdate": "2020-06-04T00:00:00", "modifydate": "2020-08-08T05:48:48", "lines": 494, "newlines": 83, "modlines": 0, "user": "ZIGI301"}, "text": "  /*---------------------  rexx procedure  -------------------- *\n  | Name:      zgbatch                                         |\n  |                                                            |\n  | Function:  ZIGI Batch is a batch interface to zigi and     |\n  |            git. It supports only text based files.         |\n  |                                                            |\n  |            Processing is identical to ZIGI                 |\n  |                                                            |\n  |            PS datasets are always copied from z/OS to OMVS |\n  |                                                            |\n  |            PDS datasets have their members ISPF stats      |\n  |            checked and if different from the ZIGI managed  |\n  |            stats the members that differ will be copied    |\n  |            from z/OS to OMVS.                              |\n  |                                                            |\n  |            If any copies were performed then ZGBATCH will  |\n  |            perform a 'git add .' to add all the updated    |\n  |            files to the git index.                         |\n  |                                                            |\n  |            A Git Commit using a constructed short message  |\n  |            with the date and time will be processed.       |\n  |                                                            |\n  |            If specified then a Git Push will also be       |\n  |            processed.                                      |\n  |                                                            |\n  |            Informational messages will be written to the   |\n  |            SYSPRINT DD during processing.                  |\n  |                                                            |\n  | Syntax:    %zgbatch hlq qualignr omvsfs compush            |\n  |                                                            |\n  |    Where:  HLQ is HLQ/Prefix used in ZIGI for the z/OS     |\n  |            datasets associated with the repository         |\n  |                                                            |\n  |            QUALIGNR is the Ignore Qualifier number used    |\n  |            by ZIGI                                         |\n  |                                                            |\n  |            OMVSFS is the directory where of the Git        |\n  |            repository that is managed by ZIGI              |\n  |                                                            |\n  |            COMPUSH is Commit (C) or Push (P) to instruct   |\n  |            ZGBATCH to do:                                  |\n  |                                                            |\n  |                 C - Commit Only      (default)             |\n  |                 P - Commit and Push                        |\n  |                                                            |\n  | Usage Notes:                                               |\n  |                                                            |\n  |           Intended as a scheduled batch interface to       |\n  |           capture and commit, or commit/push, changes      |\n  |           to the datasets within a Git repository.         |\n  |                                                            |\n  | Dependencies:                                              |\n  |                                                            |\n  |           The Git repository must be ZIGI managed.         |\n  |                                                            |\n  |           The ZIGI REXX Library must be defined -          |\n  |           do a find for CUSTOMIZE.                         |\n  |                                                            |\n  | Author:    Lionel B. Dyck                                  |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |            08/08/20 LBD - Generalize get_binfiles          |\n  |            07/29/20 LBD - Add _EDC_ZERO_RECLEN=Y to env.   |\n  |            06/10/20 LBD - Use SHAREAS=YES                  |\n  |            06/09/20 LBD - Add LMOD support                 |\n  |            06/08/20 LBD - Cleanup and Add Binary Support   |\n  |            06/06/20 LBD - More comments                    |\n  |                         - Support file extensions          |\n  |            06/05/20 LBD - Creation                         |\n  |                                                            |\n  |___________________________________________________________ |\n  | Sample JCL:                                                |\n  |                                                            |\n  |  //ISPF     EXEC PGM=IKJEFT1B,DYNAMNBR=50                  |\n  |  //SYSEXEC  DD  DISP=SHR,DSN=zigi.exec   <=== change       |\n  |  //ISPMLIB  DD DISP=SHR,DSN=ISP.SISPMENU                   |\n  |  //ISPTLIB DD  DISP=SHR,DSN=ISP.SISPTENU                   |\n  |  //ISPPLIB DD  DISP=(,DELETE),SPACE=(TRK,(1,1,1)),UNIT=VIO,|\n  |  //            DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160)        |\n  |  //ISPSLIB DD  DISP=(,DELETE),SPACE=(TRK,(1,1,1)),UNIT=VIO,|\n  |  //            DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160)        |\n  |  //ISPPROF DD  DISP=(,DELETE),SPACE=(TRK,(1,1,1)),UNIT=VIO,|\n  |  //            DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160)        |\n  |  //SYSTSPRT DD   SYSOUT=*                                  |\n  |  //SYSTSIN  DD   *                                         |\n  |  PROFILE PREFIX(userid or user-prefix)   <=== change       |\n  |  ISPF CMD(%ZGBATCH hlq qualignr /u/home/xxx p) <=== change |\n  |  //                                                        |\n  |___________________________________________________________ |\n  |  Examples: the omvs directory is case sensitive            |\n  |                                                            |\n  |  ISPF CMD(%ZGBATCH ibmuser.git 1 /u/ibmuser/git p)         |\n  |  ISPF CMD(%ZGBATCH ibmuser.prod 2 /u/ibmuser/Prod p)       |\n  * ---------------------------------------------------------- */\n  parse arg hlq qualignr omvsfs compush\n\n  Say 'Batch ZIGI Processing   Date:' date() 'Time:' time()\n  say ' '\n\n  /* ------------------- *\n  | Define our defaults |\n  * ------------------- */\n  hit = 0\n  parse value '' with null rx\n  bpxenv.1 = '_BPX_SHAREAS=YES'\n  bpxenv.2 = '_BPX_SPAWN_SCRIPT=YES'\n  bpxenv.3 = '_EDC_ZERO_RECLEN=Y'\n  bpxenv.0 = 3\n\n  /* ---------------------------- *\n  | Validate qualignr is numeric |\n  * ---------------------------- */\n  if datatype(qualignr) /= 'NUM' then do\n    say 'QUALIGNR is invalid as it is not a number.'\n    exit 8\n  end\n  if qualignr > 7 then do\n    say 'QUALIGNR appears to be invalid and it is greater than 7.'\n    exit 8\n  end\n\n  /* -------------------------------------- *\n  | Remove trailing / from omvs filesystem |\n  | and validate it exists                 |\n  * -------------------------------------- */\n  if right(omvsfs,1) = '/' then\n  omvsfs = left(omvsfs,length(omvsfs)-1)\n  say 'Checking state of OMVS Directory . . .'\n  cmd = 'ls -la' omvsfs\n  x = bpxwunix(cmd,,so.,se.,bpxenv.)\n  if pos('not found',se.1) > 0 then do\n    say 'Error with the OMVS Filesystem' omvsfs\n    say se.1\n    exit 8\n  end\n  say 'OMVS Directory exists.'\n\n  /* ------------------------------------------------ *\n  | Confirm the OMVS directory is a ZIGI repository. |\n  * ------------------------------------------------ */\n  cmd = 'ls -la' omvsfs'/.zigi'\n  say 'Checking the state of the Git OMVS Repository . . .'\n  x = bpxwunix(cmd,,so.,se.,bpxenv.)\n  if pos('not found',se.1) > 0 then do\n    say 'Error with the OMVS Filesystem' omvsfs\n    say 'It is not a ZIGI managed repository filesystem.'\n    exit 8\n  end\n  say 'Repository is in ZIGI format and thus allowed.'\n\n  /* ---------------- *\n  | Clean up ComPush |\n  * ---------------- */\n  compush = translate(strip(compush))\n  if compush = null then compush = 'C'\n  else select\n    When left(compush,1) = 'C' then compush = 'C'\n    When left(compush,1) = 'P' then compush = 'P'\n    Otherwise do\n      say 'Invalid Commit/Push value of:' compush\n      say 'Only C or P are allowed.'\n      say 'Defaulting to C'\n      compush = 'C'\n    end\n  end\n\n  /* ---------------------------------------- *\n  | Get the HLQ to use based on the QUALIGNR |\n  * ---------------------------------------- */\n  hlq = translate(hlq)\n  original_hlq = hlq\n  hlq = translate(hlq,' ','.')\n  hlq = subword(hlq,1,qualignr)\n  hlq = translate(hlq,'.',' ')\n\n  /* --------------------- *\n  | Report Options in Use |\n  * --------------------- */\n  say ' '\n  say left('-',70,'-')\n  say 'Using   HLQ:' original_hlq\n  say '   qualignr:' qualignr\n  say '   OMVS Dir:' omvsfs\n  if compush = 'C'\n  then say 'Commit/Push: Commit'\n  else say 'Commit/Push: Commit then Push'\n  say left('-',70,'-')\n  say ' '\n\n  /* ---------------- *\n  | Begin Processing |\n  * ---------------- */\n  call get_binfiles\n  call get_dsn_info\n  call get_omvs\n\n  /* ------------------------------------------- *\n  | If any datasets were copied then invoke git |\n  * ------------------------------------------- */\n  if hit > 0 then call do_git\n\n  /* -------- *\n  | All done |\n  * -------- */\nDone:\n  Exit 0\n\n  /* --------------------------------------------- *\n  | Get a list of all files in the OMVS directory |\n  |  - if a directory then call the pds routine   |\n  |  - otherwise call the ps (sequential) routine |\n  * --------------------------------------------- */\nGet_omvs:\n  cmd = 'cd' omvsfs '&& ls -l'\n  x = bpxwunix(cmd,,so.,se.,bpxenv.)\n  do i = 2 to so.0\n    if left(so.i,1) = 'd' then call check_pds\n    else call check_ps\n  end\n  return\n\n  /* ------------------------------------------- *\n  | Construct variables                         |\n  |   for the zigi stats files                  |\n  |   z/OS dataset name fully qualified         |\n  | Check ISPF statistics using ZIGISTAT        |\n  | Copy any members (delta) that have changed. |\n  * ------------------------------------------- */\ncheck_pds:\n  hit = 1\n  omvsdsn = word(so.i,9)\n  omvsstat = omvsfs'/.zigi/'omvsdsn\n  omvsdir  = omvsfs'/'omvsdsn\n  zosdsn = \"'\"hlq\".\"omvsdsn\"'\"\n  say 'Checking for changes in PDS:' zosdsn\n  x = listdsi(zosdsn)\n  if x > 0 then do\n    say sysmsglvl1\n    say sysmsglvl2\n    call no_changes\n    return\n  end\n  zosdsnw = hlq'.'word(so.i,9)\n  call check_pds_memstats 'C'\n  if delta = 0 then do\n    call no_changes\n    return\n  end\n  if words(delta) = 0 then do\n    call no_changes\n    return\n  end\n  do ci = 1 to words(delta)\n    mem = word(delta,ci)\n    omem = mem\n    if zdsn.omvsdsn /= null\n    then omem = lower(omem)'.'zdsn.omvsdsn\n    if is_binfile(omvsdsn'/'omem) = 1\n    then do\n      binopt = '-B'\n      bintxt = 'Binary'\n      if sysrecfm = 'U' then do\n         binopt = '-X -I'\n         bintxt = 'Load Module'\n         end\n    end\n    else do\n      binopt = null\n      bintxt = 'Text'\n    end\n    pds = \"'\"zosdsnw\"(\"mem\")'\"\n    cmd = 'cd' omvsfs'/'omvsdsn\n    cmd = cmd '&& cp -U -v' binopt '\"//'pds'\"' omem\n    cmd = usssafe(cmd)\n    say '   Copying PDS member:' pds 'to' omem 'as' bintxt\n    x = bpxwunix(cmd,,co.,ce.,bpxenv.)\n    if x > 0 then call show_cmd 'C'\n    if binopt /= null then do\n      cmd = 'cd' omvsdir '&& chtag -b' omem\n      cmd = usssafe(cmd)\n      x = bpxwunix(cmd,,so.,se.,bpxenv.)\n    end\n  end\n  call check_pds_memstats 'S'\n  return\n\n/* ------------------ *\n | No changes routine |\n * ------------------ */\nNo_Changes:\n  say 'No changes detected'\n  return\n\n  /* -------------------------------------------- *\n  | For sequntial datasets copy them and let Git |\n  | determine if they have changed.              |\n  * -------------------------------------------- */\ncheck_ps:\n  hit = 1\n  zosdsn = \"'\"hlq\".\"word(so.i,9)\"'\"\n  if sysdsn(zosdsn) /= 'OK' then return\n  cmd = 'cd' omvsfs\n  cmd = cmd '&& cp -U -v \"//'zosdsn'\"' word(so.i,9)\n  cmd = usssafe(cmd)\n  say 'Copying PS:' zosdsn\n  x = bpxwunix(cmd,,co.,ce.,bpxenv.)\n  if x > 0 then call show_cmd 'C'\n  return\n\n  /* ------------------------------------------ *\n  | Routine to check the PDS member statistics |\n  * ------------------------------------------ */\ncheck_pds_memstats:\n  arg stat_opt\n  Address ispexec\n  delta = zigistat(zosdsn omvsstat stat_opt)\n  return\n\n  /* ------------------------------------------- *\n  | Display any messages from the OMVS commands |\n  * ------------------------------------------- */\nshow_cmd:\n  arg sopt\n  if sopt = 'C' then do\n    do si = 1 to co.0;say co.si;end\n    do si = 1 to ce.0;say ce.si;end\n  end\n  if sopt = 'S' then do\n    do si = 1 to so.0;say so.si;end\n    do si = 1 to se.0;say se.si;end\n  end\n  return\n\n  /* -------------------------------- *\n  | Routine to invoke Git processing |\n  * -------------------------------- */\nDo_Git:\n  call getenv\n  say ' '\n  say 'Performing Git Processing . . .'\n  cmd = 'cd' omvsfs '&& git add .'\n  cmd = cmd '&& git status'\n  cmd = cmd \"&& git commit -vm 'Automated Commit\" date() time() \"'\"\n  x = docmd(cmd)\n  call show_cmd 'S'\n  say ' '\n  say 'Git Processing completed.'\n  return\n\n  /* ----------------------------------------------------- *\n  | Get the users current OMVS enviornment for use in the |\n  | bpxwunix commands.                                    |\n  * ----------------------------------------------------- */\nGETENV:\n  cmd  = docmdx('env')\n  rc = bpxwunix(cmd,,env.,se.,bpxenv.)\n  envc = env.0\n  call add_env '_BPX_SHAREAS=YES'\n  call add_env '_BPX_SPAWN_SCRIPT=YES'\n  call add_env 'EXPORT _EDC_ADD_ERRORNO2=1'\n  env.0 = envc\n  drop so. se.\n  return\n\n  /* -------------------- *\n  | Add info to env stem |\n  * -------------------- */\nadd_env:\n  parse arg env_val\n  envc = envc + 1\n  env.envc = env_val\n  return\n\n  /* ------------------------------------------------ *\n  | Invoke the Git command with the Environment info |\n  * ------------------------------------------------ */\ndocmd:\n  parse arg cmd\n  drop so. se.\n  x = bpxwunix(cmd,,so.,se.,env.)\n  return x\n\n  /* ------------------------------------- *\n  | Command to get things setup for docmd |\n  * ------------------------------------- */\ndocmdx:\n  /* quircky thing, we need to export HOME as we are\n  not running a login shell via bpxwunix */\n  parse arg cmdx\n  cmd = 'pwd'\n  x = bpxwunix(cmd,,so.,se.,bpxenv.)\n  home    = strip(so.1)\n  drop so. se.\n  if rx = null then do\n    rx = 'export HOME='home' && . /etc/profile > /dev/null 2>&1 && '\n    c = \"\u00dd\u00dd -f \"home\"/.profile \u00a8\u00a8 && echo f\"\n    x = bpxwunix(c,,o.,e.,bpxenv.)\n    if o.0 = 1 & o.1 = \"f\" then do\n      rx = rx '. 'home'/.profile > /dev/null 2>&1 && '\n    end\n  end\n  r = rx ' ' cmdx\n  return r\n\n  /* ------------------------------------------------------------- *\n  | Check for any $ characters and insert an escape character (\\) |\n  | before each.                                                  |\n  * ------------------------------------------------------------- */\nusssafe: procedure\n  parse arg dsn\n  if pos('$',dsn) = 0 then return dsn\n  /* Let's not usssafe it twice :) */\n  if pos('\\$',dsn) > 0 then return dsn\n  dsn = strreplace(dsn, '$', '\\$')\n  return dsn\n\n  /* -------------------------- *\n  | String replace routine     |\n  |  input string              |\n  |  from string               |\n  |  to string                 |\n  | translate is input to from |\n  * -------------------------- */\nstrreplace: Procedure\n  string  = arg(1)\n  strfrom = arg(2)\n  strto   = arg(3)\n  if pos(strfrom,string) = 0 then return string\n  newString = ''\n  do i = 1 to length(string)\n    if substr(string,i,1) /= strfrom\n    then newstring = newstring''substr(string,i,1)\n    else  newstring = newstring''strto\n  end\n  return newstring\n\n/* ----------------------------- *\n | Lowercase the provided string |\n * ----------------------------- */\nLower: Procedure\n  parse arg input\n  out = translate(input,\"abcdefghijklmnopqrstuvwxyz\",,\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n  return out\n\n  /* ----------------------------------------- *\n  | Get the .zigi/dsn to find file extensions |\n  * ----------------------------------------- */\nget_dsn_info:\n  zdsn. = null\n  cmd = 'cat' omvsfs'/.zigi/dsn'\n  x = bpxwunix(cmd,,s.,e.,bpxenv.)\n  if x > 0 then return\n  do di = 1 to s.0\n    zd = word(s.di,1)\n    zdsn.zd = word(s.di,6)\n    zdsn.0 = zd\n  end\n  drop s. e.\n  return\n\nget_binfiles:\n  /* ---------------------------------------------------------\\\n  | Name:      binfiles                                        |\n  |                                                            |\n  | Function:  Fills the global binfiles. stem with all        |\n  |            current repo files that are added as binary.    |\n  \\---------------------------------------------------------- */\n  cmd = 'cd' omvsfs'/ &&'\n  cmd = 'cat -W filecodeset=UTF-8,pgmcodeset=IBM-1047' omvsfs'/.gitattributes'\n  cmd = cmd ' | grep BINARY'\n  cmd = cmd '| cut -d\" \" -f1'\n  x = bpxwunix(cmd,,binfiles.,se.,bpxenv.)\n  return 0\n\nis_binfile:\n  /* ---------------------------------------------------------\\\n  | Name:      is_binfile                                      |\n  |                                                            |\n  | Function:  Checks the global binfiles. stem for the        |\n  |            provided dataset or dataset/member              |\n  \\---------------------------------------------------------- */\n  parse arg file\n  res = 0\n  if datatype(binfiles.0) /= 'NUM' then return res\n  do bi = 1 to binfiles.0\n    if right(binfiles.bi,1) = '*' then do\n      parse value file with test'/'.\n      if left(binfiles.bi,length(binfiles.bi)-2) = test\n      then return 1\n    end\n    if binfiles.bi = file then return 1\n  end\n  return res\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZGINSTAL": {"ttr": 303, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x13\\x01  o\\x01 \"\\x1f\\x05I\\x05\\x8d\\x05n\\x00\\x00\\xe9\\xc9\\xc7\\xc9\\xf3\\xf0\\xf1@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2020-07-24T00:00:00", "modifydate": "2020-08-08T05:49:13", "lines": 1421, "newlines": 1390, "modlines": 0, "user": "ZIGI301"}, "text": "/* REXX - must start in column 1 */\n  /* --------------------------------------------------------- *\n  | Name:      zginstall.rex                                   |\n  |                                                            |\n  | Function:  ZIGI Package Installation Script                |\n  |                                                            |\n  | Syntax:    ./zginstall.rex hlq \\ option                    |\n  |                                                            |\n  | Usage:     If hlq is not provided it will be prompted for  |\n  |            and used for the z/OS dataset hlq.              |\n  |                                                            |\n  |            \\  - delimeter                                  |\n  |                                                            |\n  |            x - any non-blank will cause zginstall to       |\n  |                copy individual files into the PDS instead  |\n  |                of all at once..                            |\n  |                                                            |\n  | Installation: This script should be installed in the root  |\n  |               OMVS directory for the ZIGI managed Git      |\n  |               repository.                                  |\n  |                                                            |\n  |               It is included in this library so that it    |\n  |               can be accessed by ZIGI to prime a new, or   |\n  |               existing, repository.                        |\n  |                                                            |\n  | Usage Notes:                                               |\n  |            1. Prompt for                                   |\n  |               - default HLQ to be used                     |\n  |            2. Sequential files that have no lowercase      |\n  |               will be processed.                           |\n  |            3. Directories that are all uppercase will      |\n  |               be assumed to be PDS directories             |\n  |            4. Upon completing the upload of all z/OS       |\n  |               datasets the hlq.ZGSTAT.EXEC dataset will    |\n  |               be generated. It will be pre-configured for  |\n  |               the uploaded datasets and when executed will |\n  |               apply the ISPF statistics to all partitioned |\n  |               dataset members from the ISPF statistics     |\n  |               files found in the .zigi directory.          |\n  |                                                            |\n  | Author:    Lionel B. Dyck                                  |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |            08/08/20 LBD - Generalize get_binfiles          |\n  |            07/29/20 LBD - Add _EDC_ZERO_RECLEN=Y to env.   |\n  |            07/24/20 LBD - Adjust Popup Panel Location      |\n  |                         - Prompt to Proceed after display  |\n  |                           of target datasets               |\n  |            07/12/20 LBD - Define OMVS env stem             |\n  |            07/04/20 LBD - Use Clear to clear screen        |\n  |            06/29/20 LBD - Add generic installer prose      |\n  |            06/28/20 LBD - Add text graphics                |\n  |                         - Add prose about INPUT state      |\n  |            06/27/20 LBD - Use a single cp if the pds is    |\n  |                           not mixed (text & binary)        |\n  |            06/26/20 LBD - Fixup zgstat.exec dsname quotes  |\n  |            06/11/20 LBD - Redesign self contained exec     |\n  |            06/10/20 LBD - Tweak for zgstat.exec dsn        |\n  |            06/09/20 LBD - Creation from zigickot           |\n  | ---------------------------------------------------------- |\n  |    zigi - the z/OS ISPF Git Interface                      |\n  |    Copyright (C) 2020 - Henri Kuiper and Lionel Dyck       |\n  |                                                            |\n  |    This program is free software: you can redistribute it  |\n  |    and/or modify it under the terms of the GNU General     |\n  |    Public License as published by the Free Software        |\n  |    Foundation, either version 3 of the License, or (at     |\n  |    your option) any later version.                         |\n  |                                                            |\n  |    This program is distributed in the hope that it will be |\n  |    useful, but WITHOUT ANY WARRANTY; without even the      |\n  |    implied warranty of MERCHANTABILITY or FITNESS FOR A    |\n  |    PARTICULAR PURPOSE.  See the GNU General Public License |\n  |    for more details.                                       |\n  |                                                            |\n  |    You should have received a copy of the GNU General      |\n  |    Public License along with this program.  If not, see    |\n  |    <https://www.gnu.org/licenses/>.                        |\n  * ---------------------------------------------------------- */\n\n  arg options\n\n  parse value options with ckothlq'/'opt\n\n  ckothlq = strip(ckothlq)\n\n  x = bpxwunix('clear')\n  say copies('-',73)\n  say \"                                         .zZ.     Zz \"\n  say \"                    ZZZZZZZZ           ZZZZZZZ \"\n  say \"        ZZZZZZZZZZZZZZZZZZZZZZ   ZZ   ZZZ         zZ \"\n  say \" ZZZZZZZZZZZZZZZZZZZZZZZZZZZZ        ZZZ    .zZZ   ZZ \"\n  say \" ZZZZZZZZZZZZZZZZ      ZZZZZZZ   ZZ   ZZZ  ..zZZZ  Zz \"\n  say \" ZZZZZZZZZZ,         ZZZZZZZZZ   ZZZ  ZzZ      ZZ  ZZ         ZZZZZZZ\"\n  say \" ZZZZ               ZZZZZZZZ     ZZZ   ZZZZZZZZZZZ      ZZZZZZZZZZZ \"\n  say \"                  ZZZZZZZZ       ZZZZ    ZZZZZZ      ZZZZZZZZZg \"\n  say \"                 ZZZZZZZZ        ZZZ            ZZZZZZZZZ \"\n  say \"                ZZZZZZZ              zZZZZZZZZZZZZZZ      Common\"\n  say \"              ZZZZZZZ           ZZZZZZZZZZZZZZ              Installation\"\n  say \"            .ZZZZZZZ      ZZZZZZZZZZZZZZ                      Tool\"\n  say \"           ZZZZZZZZZZZZZZZZZZZZZZ \"\n  say \"           ZZZZZZZZZZZZZZZZZ             zOS ISPF Git Interface \"\n  say \"          ZZZZZZZZZZZZ \"\n  say \"         ZZZZZZZZZg               The git interface for the rest of us\"\n  say \"        ZZZZZZig \"\n  say \"       ZZZZZZi                         Henri Kuiper & Lionel Dyck \"\n  say copies('-',73)\n\n\n  /* --------------------- *\n  | Set Default Env and   |\n  | Get current directory |\n  * --------------------- */\n  env.1 = '_BPX_SHAREAS=YES'\n  env.2 = '_BPX_SPAWN_SCRIPT=YES'\n  env.3 = '_EDC_ZERO_RECLEN=Y'\n  env.0 = 3\n  cmd = 'pwd'\n  x = bpxwunix(cmd,,so.,se.,env.)\n  ckotdir = strip(so.1)\n\nRestart:\n  /* ------------------- *\n  | Prompt for z/OS HLQ |\n  * ------------------- */\n  if ckothlq = '' then do\n    say 'Enter the z/OS High Level Qualifier to use:'\n    pull ckothlq\n    if ckothlq = '' then do\n      say 'no qualifier entered - exiting for now.'\n      exit 8\n    end\n    ckothlq = translate(strip(ckothlq))\n  end\n\n  /* -------------------------------------------------------- *\n  | Issue the ls command to get file names and sizes for all |\n  | files in the current directory and sub-directories.      |\n  * -------------------------------------------------------- */\n  cmd = 'ls -laRk' ckotdir\n  rc = bpxwunix(cmd,,stdout.,stderr.,env.)\n\n  /* ---------------------------------------------- *\n  | Display any error messages and if so then exit |\n  * ---------------------------------------------- */\n  if stderr.0 > 0 then do\n    do i = 1 to stderr.0\n      say stderr.i\n    end\n    exit 8\n  end\n\n  /* ------------------------- *\n  | Define our work variables |\n  * ------------------------- */\n  parse value '' with subs files null\n  mgen  = 0\n  hit   = 0\n  filec = 0\n\n/* -------------------------------------------------------------- *\n | Inform the user that if there are directories with a lot of    |\n | members to be copied into a PDS tht the OMVS shell may enter   |\n | an INPUT state and to just press F10 - meanwhile the copy (cp) |\n | is proceeding.                                                 |\n * -------------------------------------------------------------- */\n  if opt = null then do\n    call zmsg ' '\n    call zmsg 'If the repository being installed has partitioned datasets'\n    call zmsg 'with a large number of members, the copy operation will take'\n    call zmsg 'longer than the TN3270 polling expects. This will cause'\n    call zmsg 'the OMVS Shell to change from RUNNING to INPUT.'\n    call zmsg 'Just press the F10 key to return to a RUNNING state. '\n    call zmsg ' '\n    call zmsg 'Do not worry, however, as the copy operation is still running'\n    call zmsg 'and will report out when it completes (but only if the shell'\n    call zmsg 'is in a RUNNING state.'\n    call zmsg ' '\n  end\n\n  /* ------------------------------------ *\n  | Read in ../.zigi/dsn to get dcb info |\n  * ------------------------------------ */\n  cmd = 'cd' ckotdir '&& ls -la .zigi'\n  x = bpxwunix(cmd,,co.,ce.,env.)\n  if x > 0 then do\n    def_recfm = 'FB'\n    def_lrecl = 80\n    def_blksize = 32720\n    def. = null\n  end\n  else do\n    ckdd = 'ck'time('s')\n    x = bpxwunix(\"cat '\"ckotdir\"/.zigi/dsn'\",,ck.)\n    def. = null\n    zdsn. = null\n    do i = 1 to ck.0\n      if left(ck.i,1) = '#' then iterate\n      if word(ck.i,1) = '*' then do\n        parse value ck.i with . def_dsorg def_recfm def_lrecl def_blksize .\n      end\n      else do\n        dsn = word(ck.i,1)          /* dataset name less hlq */\n        def.dsn = subword(ck.i,2)   /* dataset dsorg  */\n        zdsn.dsn = word(ck.i,6)     /* file extension */\n      end\n    end\n  end\n\n  Address TSO\n\n  /* ------------------------------- *\n  | Get the list of Binary Datasets |\n  * ------------------------------- */\n  call get_binfiles\n\n  /* ---------------------------------------------------- *\n  | Process the results of the ls command to:            |\n  | 1. collect number of members per sub-directory       |\n  | 2. collect bytes count (in k) for each sub-directory |\n  | 3. collect info on sequential files                  |\n  * ---------------------------------------------------- */\n  if stdout.0 > 0 then\n  do i = 1 to stdout.0\n    select\n      when pos(ckotdir,stdout.i) > 0 then do\n        parse value stdout.i with (ckotdir)sub':'\n        if left(sub,1) = '/' then sub = substr(sub,2)\n        if strip(sub) /= '' then do\n          size.sub = 0\n          dir.sub = 0\n          si = 0\n          if left(sub,1) /= '.' then do\n            subs = subs sub\n          end\n        end\n      end\n      when word(stdout.i,1) = 'total' then do\n        hit = hit + 1\n      end\n      when hit > 1 & left(stdout.i,1) = '-' then\n      if strip(sub) /= '' then do\n        size.sub = size.sub + word(stdout.i,5)\n        dir.sub = dir.sub + 1\n      end\n      when hit = 1 & left(stdout.i,1) = '-' then do\n        file = word(stdout.i,9)\n        if left(file,1) = '.' then iterate\n        fx = translate(file,'??????????????????????????', ,\n          'abcdefghijklmnopqrstuvwxyz')\n        if pos('?',fx) > 0 then iterate\n        size.file =  word(stdout.i,5)\n        files = files file\n      end\n      otherwise nop\n    end\n  end\n\n  call zmsg 'The following Datasets will be Created or Recreated:'\n  if words(files) > 0 then\n  do fi = 1 to words(files)\n    wdsn = \"'\"ckothlq\".\"word(files,fi)\"'\"\n    call zmsg wdsn\n    if check_file(wdsn) > 0\n    then call zmsg '--- Dataset exists and will be recreated.'\n  end\n  do fi = 1 to words(subs)\n    wdsn = \"'\"ckothlq\".\"word(subs,fi)\"'\"\n    call zmsg wdsn\n    if check_file(wdsn) > 0\n    then call zmsg '--- Dataset exists and will be recreated.'\n  end\n  call zmsg ' '\n  say '  '\n  say 'Enter Y to Proceed or anything to Retry:'\n  pull zgans\n  if translate(zgans) /= 'Y' then  do\n    ckothlq = null\n    signal ReStart\n  end\n\n  /* -------------------------------------------- *\n  | Process the individual files, if any         |\n  | Allocation and Copy                          |\n  * -------------------------------------------- */\n  do i = 1 to words(files)\n    parse value '' with zs1 zs2 zs3 zs4 zs5 zs6 zs7 zs8 zs9\n    sub = word(files,i)\n    fileg = \"'\"ckothlq\".\"sub\"'\"\n    odir = \"'\"ckotdir\"/\"sub\"'\"\n    bin = is_binfile(sub)\n    if bin = 1 then type = 'Binary'\n    else type = 'Text'\n    say 'Copying' odir 'to' fileg 'as' type\n    filec = filec + 1\n    zfile.filec = fileg\n    x = check_file(fileg)\n    if x = 0 then do\n      call outtrap 'x.'\n      'delete' fileg\n      call outtrap 'off'\n    end\n    tracks =  (size.sub%50000 + 1) * 2\n    call get_dcb\n    'alloc ds('fileg') new spa('tracks','tracks') tr dsorg(ps)' ,\n      'recfm('recfm') lrecl('lrecl') blksize('blksize')'\n    'free ds('fileg')'\n    'oget' odir fileg type\n  end\n\n  /* -------------------------------------------- *\n  | Process the sub-directories and initiate the |\n  | Allocation and Copy                          |\n  | Ignore subdirectories                        |\n  * -------------------------------------------- */\n  do isub = 1 to words(subs)\n    parse value '' with zs1 zs2 zs3 zs4 zs5 zs6 zs7 zs8 zs9\n    sub = word(subs,isub)\n    bin = is_binfile(sub)\n    if bin = 1 then type = 'Binary'\n    else type = 'Text'\n    fx = translate(sub,'??????????????????????????', ,\n      'abcdefghijklmnopqrstuvwxyz')\n    if pos('?',fx) > 0 then iterate\n    tracks =  (size.sub%50000 + 1) * 2\n    call alloc_copy_pds\n  end\n\n  /* ------------------------------------------ *\n  | Now update and create the zgstat.exec file |\n  * ------------------------------------------ */\n  c = 0\n  hit = 0\n  last = sourceline()\n  do i = 1 to last\n    card = sourceline(i)\n    if  left(card,8) = '>ZGSTATE' then leave\n    if hit = 0 then\n    if  left(card,8) = '>ZGSTAT ' then do\n      hit = 1\n      iterate\n    end\n    else iterate\n    if pos('$$$$$$',card) > 0 then do\n      parse value card with var '=' .\n      if translate(var) = 'REPODIR' then\n      card = \"   repodir ='\"ckotdir\"'\"\n      if translate(var) = 'HLQ' then\n      card = \"   hlq ='\"ckothlq\"'\"\n    end\n    c = c + 1\n    zg.c = card\n  end\n  zg.0 = c\n\n  Address syscall\n  path = ckotdir'/lrhg.rex'\n  'open' path O_rdwr+O_creat+O_trunc 660\n  if retval = -1 then do\n    say 'Unable to open the output file for ZGSTAT.EXEC'\n    say 'so ISPF statistics will not be able to be recreated.'\n    exit 8\n  end\n  fd = retval\n  do i = 1 to zg.0\n    rec = zg.i ESC_N\n    'write' fd 'rec' length(rec)\n  end\n  'close' fd\n  Address TSO\n\n  zgstat_dsn = \"'\"ckothlq\".ZGSTAT.EXEC'\"\n  cmd = 'cp -v  lrhg.rex \"//'zgstat_dsn '\"'\n  cmd = cmd '&& rm lrhg.rex'\n  x = bpxwunix(cmd,,so.,se.,env.)\n  if so.0 > 0 then\n  do i = 1 to so.0;say so.i;end\n  if se.0 > 0 then\n  do i = 1 to se.0;say se.i;end\n\n  /* -------------------- *\n  | Done with everything |\n  * -------------------- */\n  say ' '\n  say 'Completed - z/OS datasets created:'\n  say ' '\n  do i = 1 to filec\n    say zfile.i\n  end\n  say ' '\n  say 'Note that using this installation path does not allow the ISPF'\n  say 'statistics to be recreated. Other than the missing ISPF statistics'\n  say 'everything has been successfully installed on z/OS.'\n  say ' '\n  say 'To recreate the ISPF statistics execute the following command'\n  say 'after returning to TSO/ISPF:'\n  say ' '\n  say 'TSO EX' zgstat_dsn 'EX'\n  say ' '\n  say 'After it completes successfully it can be deleted.'\n\n  Exit\n\nzmsg:\n  parse arg message\n  if strip(message) = null then\n  message = copies('-',63)\n  say '* 'left(message,63)' *'\n  return\n\n  /* ----------------------------------------------------- */\n  /* number format code thanks to Doug Nadel               */\n  /* ----------------------------------------------------- */\nfix_num: procedure\n  arg bytes\n  str=strip(translate('0,123,456,789,abc,def', ,\n    right(bytes,16,','), ,\n    '0123456789abcdef'),'L',',')\n  bytes = strip(str)\n  return bytes\n\n  /* ----------------------------------------------------------------- *\n  | Allocate the PDS and perform the copy using cp                    |\n  | - if the target PDS exists as a PDS, delete and realloc as a PDSE |\n  | - if the target is a PDSE then it will NOT be reallocated         |\n  | - The target PDS will be allocated as a PDSE version 2.           |\n  | - if maxgen (mgen) is provided then member generations will       |\n  |   also be defined at allocation                                   |\n  | - Uppercase and remove defined extension for members              |\n  * ----------------------------------------------------------------- */\nAlloc_Copy_PDS:\n  pds = \"'\"ckothlq\".\"sub\"'\"\n  odir = \"'\"ckotdir\"/\"sub\"/'\"\n  filec = filec + 1\n  zfile.filec = pds\n  x = check_file(pds)\n  if x = 0 then do\n    call outtrap 'x.'\n    Address TSO ,\n      'delete' pds\n    call outtrap 'off'\n  end\n  call get_dcb\n  if recfm = 'U' then do\n    type = 'Load module'\n  end\n  say 'Copying' odir 'to' pds\n  if mgen > 0 then gens = 'maxgens('mgen')'\n  else gens = null\n  'Alloc new spa('tracks','tracks') recfm('recfm') lrecl('lrecl')' ,\n    'Blksize('blksize') Dsntype(Library,2) dsorg(po) dir(1)' ,\n    'dsn('pds')' gens\n  'Free ds('pds')'\n\n  /* ---------------------------------------------------- *\n  | Read directory to get all member file names and then |\n  | adjust according and then do individual cp           |\n  * ---------------------------------------------------- */\n  target = strip(pds,'B',\"'\")\n  address syscall\n  rdir = strip(odir,'B',\"'\")\n  rdir = strip(rdir,'T','/')\n  'readdir' rdir 'mems.'\n  tcount = mems.0 - 2\n\n  if opt /= null then\n  mixed = check_mixed_bintext(sub)\n  else mixed = 0\n\n  if mixed = 0 then do\n    bin = is_binfile(sub)\n    if bin = 1 then binopt = '-B'\n    else binopt = null\n    if recfm = 'U' then binopt = '-X -I'\n    if binopt = null then type = 'Text'\n    else if binopt = '-B' then  type = 'Binary'\n    else if recfm = 'U' then type = 'Load module'\n    zos = usssafe(\"//'\"target\"'\")\n    say 'Copying' tcount 'members as' type\n    cmd = 'cp -A -U -v' binopt usssafe(rdir'/*') '\"'zos'\"'\n    x = docmd(cmd)\n    if x > 0 then do\n      say ' '\n      say 'Copy command:' cmd\n      say ' '\n      say 'Standard messages:'\n      say ' '\n      do vs = 1 to so.0;say so.vs;end\n      say ' '\n      say 'Error messages:'\n      say ' '\n      do vs = 1 to se.0;say se.vs;end\n    end\n  end\n  else do   /* mixed text and binary in same PDS */\n    mcount = 0\n    do ii = 1 to mems.0\n      if mems.ii = \".\" | mems.ii = \"..\" then do\n        /* skip the . and .. things */\n        iterate\n      end\n      m = mems.ii    /* ignore the translation */\n      if zdsn.sub /= null then\n      if right(m,length(zdsn.sub)) = zdsn.sub then do\n        parse value m with m'.'.\n        m = translate(m)\n      end\n      src = rdir'/'mems.ii\n      bin = is_binfile(sub'/'mems.ii)\n      if bin = 1 then binopt = '-B'\n      else binopt = null\n      if recfm = 'U' then binopt = '-X -I'\n      src = usssafe(mems.ii)\n      if left(src,1) = '#' then src = '\\'src\n      zos = usssafe(\"//'\"target\"(\"m\")'\")\n      mcount = mcount + 1\n      if binopt = null then type = 'Text'\n      else if binopt = '-B' then  type = 'Binary'\n      else if recfm = 'U' then type = 'Load module'\n      say left('Copying' mcount 'of' tcount,24) 'Member:' m 'as' type\n      cmd = 'cd' usssafe(rdir)\n      cmd = cmd '&& cp -U -v' binopt src '\"'zos'\"'\n      x = docmd(cmd)\n      if x > 0 then do\n        say ' '\n        say 'Standard messages:'\n        say ' '\n        do vs = 1 to so.0;say so.vs;end\n        say ' '\n        say 'Error messages:'\n        say ' '\n        do vs = 1 to se.0;say se.vs;end\n      end\n    end\n  end\n  return\n\nget_dcb:\n  if def.sub /= null then do\n    parse value def.sub with dsorg recfm lrecl blksize .\n    recfm = left(recfm,1) substr(recfm,2,1) substr(recfm,3,1)\n  end\n  else do\n    recfm = left(def_recfm,1) substr(def_recfm,2,1) substr(def_recfm,3,1)\n    lrecl = def_lrecl\n    blksize = def_blksize\n  end\n  return\n\nCheck_File: Procedure\n  arg dsn\n  call outtrap 'x.'\n  Address TSO 'Listd' dsn\n  call outtrap 'off'\n  if x.0 > 3 then return 8\n  else return 0\n\n  /* ---------------------------------------- *\n  | Check if a PDS has mixed binary and text |\n  | 0 = not mixed   1 = mixed                |\n  * ---------------------------------------- */\nCheck_Mixed_BinText:\n  parse arg checkForBinFile\n  cmbtRC = 0\n  if datatype(binfiles.0) /= 'NUM' then return 0\n  do bi = 1 to binfiles.0\n    parse value binfiles.bi with cmbtfile'/'cmbtmbr\n    parse value checkForBinFile with checkFile'/'checkmbr\n    if cmbtfile = checkFile then\n    if cmbtmbr = '*' then cmbtRC = 0\n    else return 1\n    if binfiles.bi = checkForBinFile then return 1\n  end\n  return cmbtRC\n\nusssafe: procedure\n  parse arg dsn\n  if pos('$',dsn) = 0 then return dsn\n  /* Let's not usssafe it twice :) */\n  if pos('\\$',dsn) > 0 then return dsn\n  dsn = strreplace(dsn, '$', '\\$')\n  return dsn\n\nstrreplace: Procedure\n  string  = arg(1)\n  strfrom = arg(2)\n  strto   = arg(3)\n  null = ''\n  if pos(strfrom,string) = 0 then return string\n  newString = null\n  do i = 1 to length(string)\n    if substr(string,i,1) /= strfrom\n    then newstring = newstring''substr(string,i,1)\n    else  newstring = newstring''strto\n  end\n  return newstring\n\nget_binfiles:\n  /* ---------------------------------------------------------\\\n  | Name:      binfiles                                        |\n  |                                                            |\n  | Function:  Fills the global binfiles. stem with all        |\n  |            current repo files that are added as binary.    |\n  \\---------------------------------------------------------- */\n  cmd = 'cd' ckotdir'/ &&'\n  cmd = 'cat -W filecodeset=UTF-8,pgmcodeset=IBM-1047' ckotdir'/.gitattributes'\n  cmd = cmd ' | grep BINARY'\n  cmd = cmd '| cut -d\" \" -f1'\n  x = docmd(cmd)\n  if so.0 = 0 then do\n    binfiles.0 = 0\n    return 0\n  end\n  do b = 1 to so.0\n    binfiles.b = so.b\n  end\n  binfiles.0 = so.0\n  return 0\n\nis_binfile: procedure expose binfiles.\n  /* ---------------------------------------------------------\\\n  | Name:      is_binfile                                      |\n  |                                                            |\n  | Function:  Checks the global binfiles. stem for the        |\n  |            provided dataset or dataset/member              |\n  \\---------------------------------------------------------- */\n  parse arg file\n  if datatype(binfiles.0) /= 'NUM' then return 0\n  do bi = 1 to binfiles.0\n    if right(binfiles.bi,1) = '*' then do\n      parse value file with test'/'.\n      if left(binfiles.bi,length(binfiles.bi)-2) = test\n      then return 1\n    end\n    if binfiles.bi = file then return 1\n  end\n  return 0\n\ndocmd:\n  parse arg cmd\n  drop so. se.\n  x = bpxwunix(cmd,,so.,se.,env.)\n  return x\n\n/*\n>ZGSTAT     *** Inline ZGSTAT that will be updated and uploaded */\n  /*---------------------  rexx procedure  -------------------- *\n  | Name:      ZGSTAT                                          |\n  |                                                            |\n  | Function:  To work with the ZIGI Generic Installation      |\n  |            tool to add the ISPF statistics to the ZIGI     |\n  |            managed partitioned datasets after they have    |\n  |            been created by the ZGINSTALL.                  |\n  |                                                            |\n  | Syntax:    ex zgstat ex                                    |\n  |                                                            |\n  | Dependencies: Uses a modified copy of the ZIGI zigistat    |\n  |               exec                                         |\n  |                                                            |\n  | Author:    Lionel B. Dyck                                  |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |            06/11/20 LBD - Put inline in zginstall.rex      |\n  |            06/10/20 LBD - Usability enhancements           |\n  |            06/09/20 LBD - Creation                         |\n  |                                                            |\n  | ---------------------------------------------------------- |\n  |    ZIGI - the z/OS ISPF Git Interface                      |\n  |    Copyright (C) 2020 - Henri Kuiper and Lionel Dyck       |\n  |                                                            |\n  |    This program is free software: you can redistribute it  |\n  |    and/or modify it under the terms of the GNU General     |\n  |    Public License as published by the Free Software        |\n  |    Foundation, either version 3 of the License, or (at     |\n  |    your option) any later version.                         |\n  |                                                            |\n  |    This program is distributed in the hope that it will be |\n  |    useful, but WITHOUT ANY WARRANTY; without even the      |\n  |    implied warranty of MERCHANTABILITY or FITNESS FOR A    |\n  |    PARTICULAR PURPOSE.  See the GNU General Public License |\n  |    for more details.                                       |\n  |                                                            |\n  |    You should have received a copy of the GNU General      |\n  |    Public License along with this program.  If not, see    |\n  |    <https://www.gnu.org/licenses/>.                        |\n  * ---------------------------------------------------------- */\n\n/* ------------------------------------------------ *\n | These variables will be updated by zginstall.rex |\n * ------------------------------------------------ */\n  repodir = '$$$$$$'\n  hlq     = '$$$$$$'\n\n  Address ISPExec\n  load_info = loadispf()\n\n  address syscall ,\n    'readdir' repodir 'files.'\n\n  if files.0 = 0 then do\n    zedsmsg = 'Error'\n    zedlmsg = 'The directory specified is not the correct directory.'\n    'setmsg msg(isrz001)'\n    exit 8\n  end\n\n  do i = 1 to files.0\n    file = files.i\n    if left(file,1) = '.' then iterate\n    /* check for lower case so ignore these */\n    fx = translate(file,'??????????????????????????', ,\n      'abcdefghijklmnopqrstuvwxyz')\n    if pos('?',fx) > 0 then iterate\n    dsname = \"'\"hlq\".\"file\"'\"\n    x = listdsi(dsname)\n    if sysdsorg /= 'PO' then iterate\n    msg1 = 'Applying ISPF Statistics to:'\n    msg2 = dsname\n    call pfshow 'off'           /* make sure pfshow is off */\n    'Control Display Lock'\n    'Addpop row(8) column(11)'\n    'Display Panel(zgpop)'\n    'Rempop'\n    call pfshow 'reset'         /* restore pfshow setting */\n    x = zigistat(dsname repodir'/.zigi/'file 'U')\n  end\n\nDone:\n  x = dropispf(load_info)\n  zedsmsg = 'Completed.'\n  zedlmsg = 'ZGSTAT completed ISPF statistics updates.'\n  'setmsg msg(isrz001)'\n  exit 0\n\nCancel:\n  x = dropispf(load_info)\n  Say 'ZGSTAT utility canceled.'\n  exit 8\n\n  /* ------------------------------------------------------ *\n  | The pfshow routine will:                               |\n  | 1. check to see the passed option                      |\n  | 2. if Off then it will save the current pfshow setting |\n  |    - save the current setting                          |\n  |    - turn off pfshow                                   |\n  | 3. if the option is Reset then it will                 |\n  |    - test if pfshow was on and turn it back on         |\n  * ------------------------------------------------------ */\npfshow:\n  if zpfshow = 'OFF' then return\n  arg pfkopt\n  if pfkopt = 'RESET' then do\n    if pfkeys = 'ON' then\n    'select pgm(ispopf) parm(FKA,ON)'\n  end\n  if pfkopt = 'OFF' then do\n    'vget (zpfshow)'\n    pfkeys = zpfshow\n    if pfkeys /= 'OFF' then\n    'select pgm(ispopf) parm(FKA,OFF)'\n  end\n  return\n\n  /* Inline ISPF Elements - must remain within a comment\n>Start\n>Panel zgstat\n)Attr\n  _ type(input) caps(on) hilite(uscore)\n  $ type(input) caps(off) hilite(uscore)\n)Body Window(65,7)\n+\n+Enter the z/OS Dataset HLQ (Prefix):\n_hlq                          +\n+\n+Enter the OMVS Directory for the Repository:\n$repodir                                                      +\n+\n)Init\n &zwinttl = 'ZIGI Statistics Apply Utility'\n)Proc\n  ver (&hlq,nb,dsname)\n  ver (&repodir,nb)\n)End\n>Panel zgpop\n)Attr\n @ type(output) caps(off) intens(low)\n)Body Window(46,4)\n+\n@msg1\n@msg2\n+\n)Init\n &zwinttl = 'ZIGI Statistics Apply Utility'\n)Proc\n  ver (&hlq,nb,dsname)\n  ver (&repodir,nb)\n)End\n>End   */\n\n  /* --------------------  rexx procedure  -------------------- *\n  | Name:      zigistat                                        |\n  |                                                            |\n  | Function:  Collect or Compare the ISPF Stats for all       |\n  |            members in a PDS                                |\n  |                                                            |\n  | Syntax:    x=zigistat(dsname filepath option)              |\n  |                                                            |\n  |            dsname is the z/OS dataset name to work with    |\n  |                                                            |\n  |            filepath is the OMVS file where the stats are   |\n  |            stored and consists of:                         |\n  |                localdir/repodir/.ZIGI/filename             |\n  |                filename is the OMVS file that represents   |\n  |                the z/OS PDS dataset name                   |\n  |                                                            |\n  | Options:   C - compare stats                               |\n  |            S - save stats                                  |\n  |            U - update stats to those saved                 |\n  |                used when creating/refreshing datasets      |\n  |                                                            |\n  | Vars:      statmems ispf variable for selective update     |\n  |                                                            |\n  | Usage                                                      |\n  |   Notes: Subroutine of ZIGI                                |\n  |          Returns string of members changed                 |\n  |                                                            |\n  | Dependencies:                                              |\n  |          ISPF services                                     |\n  |                                                            |\n  | Return:                                                    |\n  |          0 - stats saved or stats applied                  |\n  |          8 - no dsname provided                            |\n  |         12 - no filepath provided                          |\n  |         16 - no option provided                            |\n  |         20 - stats file in /.zigi missing                  |\n  |     string - string of members with different stats        |\n  |                                                            |\n  | Author:    Lionel B. Dyck                                  |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |            06/09/20 LBD - Modified and included here       |\n  |            06/09/20 LBD - Bypass stat update for lmod      |\n  |            05/08/20 LBD - Support Load Libraries           |\n  |            01/08/20 LBD - Selecitve stat update if statmems|\n  |            01/05/20 LBD - Correct special chars in filepath|\n  |                           using usssafe routine            |\n  |            11/22/19 LBD - If a member has no stats - add   |\n  |            11/18/19 LBD - Many fixes and add Debug         |\n  |            11/15/19 LBD - Creation                         |\n  |                                                            |\n  | ---------------------------------------------------------- |\n  |    ZIGI - the z/OS ISPF Git Interface                      |\n  |    Copyright (C) 2020 - Henri Kuiper and Lionel Dyck       |\n  |                                                            |\n  |    This program is free software: you can redistribute it  |\n  |    and/or modify it under the terms of the GNU General     |\n  |    Public License as published by the Free Software        |\n  |    Foundation, either version 3 of the License, or (at     |\n  |    your option) any later version.                         |\n  |                                                            |\n  |    This program is distributed in the hope that it will be |\n  |    useful, but WITHOUT ANY WARRANTY; without even the      |\n  |    implied warranty of MERCHANTABILITY or FITNESS FOR A    |\n  |    PARTICULAR PURPOSE.  See the GNU General Public License |\n  |    for more details.                                       |\n  |                                                            |\n  |    You should have received a copy of the GNU General      |\n  |    Public License along with this program.  If not, see    |\n  |    <https://www.gnu.org/licenses/>.                        |\n  * ---------------------------------------------------------- */\nzigistat: Procedure\n\n  /* --------------------------------- *\n   | Define OMVS Environment Variables |\n   * --------------------------------- */\n  env.1 = '_BPX_SHAREAS=YES'\n  env.2 = '_BPX_SPAWN_SCRIPT=YES'\n  env.0 = 2\n\n  /* --------------- *\n  | Define defaults |\n  * --------------- */\n  parse value '' with null string m. rx allmems\n  zdd = 'ZS'time('s')\n\n  /* --------------------------------- *\n  | Check for parms and return if not |\n  * --------------------------------- */\n  parse arg dsn filepath opt\n  if dsn      = null then return 8\n  if filepath = null then return 12\n  if opt      = null then return 16\n  opt         = translate(opt)   /* make upper case */\n\n  /* --------------------------------------- *\n  | If option C or U then read in the stats |\n  | - check if stats member exists rc=16    |\n  | - read into stem stats.                 |\n  * --------------------------------------- */\n  if pos(opt,'C U') > 0 then do\n    x = check_stats_file(filepath)\n    rc = x\n    if rc > 0 then return x\n    drop stats.\n    cmd = 'cat' usssafe(filepath)\n    x = bpxwunix(cmd,,stats.,se.,env.)\n    do i = 1 to stats.0\n      stats.i = translate(stats.i,' ','0D'x)\n    end\n  end\n\n  /* ------------------ *\n  * Define ISPF Dataid *\n  * ------------------ */\n  Address ISPExec\n  \"LMINIT DATAID(STATUS) DATASET(\"dsn\")\"\n  \"LMOPEN DATAID(\"STATUS\") OPTION(INPUT)\"\n\n  /* ---------------------------------- *\n  | Get dataset recfm (check for lmod) |\n  * ---------------------------------- */\n  x = listdsi(dsn)\n\n  /* ------------ *\n  * Set defaults *\n  * ------------ */\n  parse value null with member mem. ,\n    ZLCDATE ZLMDATE ZLVERS ZLMOD ZLMTIME ZLCNORC,\n    ZLINORC ZLMNORC ZLUSER ,\n    zlcnorce zlinorce zlmnorce ,\n    zlsize zlamod zlrmode zlattr zlalias zlssi\n  mem.0  = 0\n\n  /* ----------------------- *\n  * Now process all members *\n  * ----------------------- */\n  do forever\n    \"LMMLIST Dataid(\"status\") OPTION(LIST) MEMBER(MEMBER)\" ,\n      \"STATS(YES)\"\n    /* --------------------------------- *\n    * If RC 4 or more leave the do loop *\n    * --------------------------------- */\n    if rc > 3 then leave\n    /* -------------------------------- *\n    | Check if no stats then add them. |\n    * -------------------------------- */\n    if sysrecfm /= 'U' then\n    if zlcdate = null then do\n      'LMMSTATS DATAID('status') Member('member') user('sysvar(sysuid)')'\n      \"LMMFind DATAID(\"status\") Member(\"member\") STATS(YES)\"\n    end\n    /* ------------------------------ *\n    * Add each member info to a stem *\n    * ------------------------------ */\n    c = mem.0 + 1\n    if sysrecfm /= 'U'\n    then mem.c = strip(member ,\n      ZLCDATE  ZLMDATE  ZLVERS ZLMOD ZLMTIME ZLCNORC ,\n      ZLINORC ZLMNORC ZLUSER ,\n      zlcnorce zlinorce zlmnorce)\n    else mem.c = strip(member ,\n      zlsize zlamod zlrmode zlattr zlalias zlssi)\n    mem.0 = c\n    if opt = 'C' then allmems = allmems member\n  end\n\n  /* ------------------------- *\n  * Close and Free the Dataid *\n  * ------------------------- */\n  \"LMClose Dataid(\"status\")\"\n  \"LMFree  Dataid(\"status\")\"\n\n  /* ----------------------------------------------- *\n  | Process the data based on the provided options: |\n  |                                                 |\n  |    C - compare stats                            |\n  |    S - save stats                               |\n  |    U - update stats to those saved              |\n  |        used when creating/refreshing datasets   |\n  * ----------------------------------------------- */\n  Select\n    /* ---------------------------------------------------------- *\n    | Update ISPF Stats:                                         |\n    |  - all members in the ZIGI stats member will have their    |\n    |    ispf stats updated to reflect the saved stats           |\n    |  - Use statmems ispf var for selective stat updates        |\n    |  - new members will not be updated as we don't know about  |\n    |   them                                                     |\n    |  - members with no stats will have stats added if they are |\n    |    in the saved stats member                               |\n    * ---------------------------------------------------------- */\n    When opt = 'U' then\n    if sysrecfm /= 'U' then do\n      'vget (statmems)'\n      if statmems /= null then do\n      end\n      \"LMINIT DATAID(zstats) DATASET(\"dsn\")\"\n      \"LMOPEN DATAID(\"zstats\") OPTION(INPUT)\"\n      do i = 1 to stats.0\n        parse value stats.i with member ZLCDATE ZLMDATE ZLVERS ZLMOD ,\n          ZLMTIME ZLCNORC ZLINORC ZLMNORC ZLUSER ZLCNORCE ,\n          ZLINORCE ZLMNORCE .\n        if statmems /= null then\n        if wordpos(member,statmems) = 0 then iterate\n        if zlcdate = null then ,\n          'LMMSTATS DATAID('zstats') Member('member') user('sysvar(sysuid)')'\n        else ,\n          'LMMSTATS DATAID('zstats') MEMBER('member') VERSION('zlvers')' ,\n          'MODLEVEL('zlmod') CREATED('zlcdate') MODDATE('zlmdate')' ,\n          'MODTIME('zlmtime') INITSIZE('zlinorc')' ,\n          'MODRECS('zlmnorc') USER('zluser')'\n      end\n      \"LMClose Dataid(\"zstats\")\"\n      \"LMFree  Dataid(\"zstats\")\"\n      return 0\n    end\n    /* ----------------------------------------------------------- *\n    | Compare ISPF stats.                                         |\n    |                                                             |\n    | Comparison will be from the active datasets ISPF stats with |\n    | the saved stats found in ISPF stats file in /.zigi          |\n    |                                                             |\n    | If a member is in the active but not in the saved list then |\n    | it will be added to the returned string.                    |\n    |                                                             |\n    | If a members saved stats do not match the active stats then |\n    | it will be added to the returned string.                    |\n    * ----------------------------------------------------------- */\n    When opt = 'C' then do\n      /* 1st setup the saved stem for easy comparison */\n      do i = 1 to stats.0\n        parse value stats.i with savedmem data\n        m.savedmem = strip(data)\n      end\n      /* now compare active to saved */\n      do i = 1 to mem.0\n        parse value mem.i with actmem data\n        data = strip(data)\n        if m.actmem = null then string = string actmem\n        else if data /= m.actmem then string = string actmem\n      end\n      'vput (allmems)'\n      return string\n    end\n    Otherwise nop  /* should never get here */\n  end\n\n  /* -------------------------------------------- *\n  | Check to see if the provided filepath exists |\n  | rc 0 it does                                 |\n  | rc 20 it does not                            |\n  * -------------------------------------------- */\nCheck_Stats_File:\n  save_address = address()\n  address syscall 'lstat' filepath 'file.'\n  if file.0 = 0 then do\n    ADDRESS value(save_address)\n    return 20\n  end\n  else return 0\n\ndocmd:\n  parse arg cmd\n  drop so. se.\n  x = bpxwunix(cmd,,so.,se.,env.)\n  return x\n\n  /* ---------------------------------- *\n  | Make the z/OS dsname safe for OMVS |\n  * ---------------------------------- */\nusssafe: procedure\n  parse arg dsn\n  if pos('$',dsn) = 0 then return dsn\n  /* Let's not usssafe it twice :) */\n  if pos('\\$',dsn) > 0 then return dsn\n  dsn = strreplace(dsn, '$', '\\$')\n  return dsn\n\nSTRREPLACE:\n  ORIGINAL = ARG(1)\n  OLDTXT = ARG(2)\n  NEWTXT = ARG(3)\n  /* YOU CAN CHANGE THE BELOW KEY (TMPTXT), WHICH IS USED AS A TEMPORARY\n  POINTER TO IDENTIFY THE TEXT TO BE REPLACED */\n  TMPTXT = '6A53CD2EW1F'\n  NEWSTR = ORIGINAL\n  DO WHILE POS(OLDTXT,NEWSTR) > 0\n    NEWSTR = SUBSTR(NEWSTR, 1 , POS(OLDTXT,NEWSTR)-1) ||,\n      TMPTXT || SUBSTR(NEWSTR, POS(OLDTXT,NEWSTR) + LENGTH(OLDTXT))\n  END\n  DO WHILE POS(TMPTXT,NEWSTR) > 0\n    NEWSTR = SUBSTR(NEWSTR, 1 , POS(TMPTXT,NEWSTR)-1) ||,\n      NEWTXT || SUBSTR(NEWSTR, POS(TMPTXT,NEWSTR) + LENGTH(TMPTXT))\n  END\n  RETURN NEWSTR\n\n  /* --------------------  rexx procedure  -------------------- *\n  * Name:      LoadISPF                                        *\n  *                                                            *\n  * Function:  Load ISPF elements that are inline in the       *\n  *            REXX source code.                               *\n  *                                                            *\n  * Syntax:    load_info = loadispf()                          *\n  *            rc = dropispf(load_info)                        *\n  *                                                            *\n  *            The inline ISPF resources are limited to        *\n  *            ISPF Messages, Panels, and Skeletons,           *\n  *                 CLISTs and EXECs are also supported.       *\n  *                                                            *\n  *            The inline resources must start in column 1     *\n  *            and use the following syntax:                   *\n  *                                                            *\n  *            >START    used to indicate the start of the     *\n  *                      inline data                           *\n  *                                                            *\n  *            >END    - used to indicate the end of the       *\n  *                      inline data                           *\n  *                                                            *\n  *            Each resource begins with a type record:        *\n  *            >type name                                      *\n  *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *\n  *                     name is the name of the element        *\n  *                                                            *\n  * Sample usage:                                              *\n  *          -* rexx *-                                        *\n  *          load_info = loadispf()                            *\n  *          ... magic code happens here (your code) ...       *\n  *          rc = dropispf(load_info)                          *\n  *          exit                                              *\n  *          >Start inline elements                            *\n  *          >Panel panel1                                     *\n  *          ...                                               *\n  *          >Msg msg1                                         *\n  *          ...                                               *\n  *          >End of inline elements                           *\n  *                                                            *\n  * Returns:   the list of ddnames allocated for use along     *\n  *            with the libdef's performed or altlib           *\n  *                                                            *\n  *            format is ddname libdef ddname libdef ...       *\n  *                   libdef may be altlibc or altlibe         *\n  *                   for altlib clist or altlib exec          *\n  *                                                            *\n  * Notes:     Entire routine must be included with REXX       *\n  *            exec - inline with the code.                    *\n  *                                                            *\n  * Comments:  The entire rexx program is processed from the   *\n  *            last record to the first to find the >START     *\n  *            record at which point all records from that     *\n  *            point on are processed until the >END           *\n  *            statement or the end of the program is found.   *\n  *                                                            *\n  *            It is *strongly* suggested that the inline      *\n  *            elements be at the very end of your code so     *\n  *            that the search for them is faster.             *\n  *                                                            *\n  *            Inline ISPTLIB or ISPLLIB were not supported    *\n  *            because the values for these would have to be   *\n  *            in hex.                                         *\n  *                                                            *\n  * Author:    Lionel B. Dyck                                  *\n  *                                                            *\n  * History:                                                   *\n  *            01/09/19 - Include DROPISPF routine             *\n  *            08/29/17 - Fixup static values that were vars   *\n  *            05/31/17 - Change default directory count       *\n  *            12/09/16 - update for add_it routine            *\n  *            05/10/16 - correction for clist and exec        *\n  *            04/19/16 - bug correction                       *\n  *            06/04/04 - Enhancements for speed               *\n  *            08/05/02 - Creation                             *\n  *                                                            *\n  * ---------------------------------------------------------- *\n  * Disclaimer: There is no warranty, either explicit or       *\n  * implied with this code. Use it at your own risk as there   *\n  * is no recourse from either the author or his employeer.    *\n  * ---------------------------------------------------------- */\nLoadISPF: Procedure\n\n  parse value \"\" with null kmsg kpanel kskel first returns ,\n    kclist kexec\n  /* ------------------------------------------------------- *\n  * Find the InLine ISPF Elements and load them into a stem *\n  * variable.                                               *\n  *                                                         *\n  * Elements keyword syntax:                                *\n  * >START - start of inline data                           *\n  * >CLIST name                                             *\n  * >EXEC name                                              *\n  * >MSG name                                               *\n  * >PANEL name                                             *\n  * >SKEL name                                              *\n  * >END   - end of all inline data (optional if last)      *\n  * ------------------------------------------------------- */\n  last_line = sourceline()\n  do i = last_line to 1 by -1\n    line = sourceline(i)\n    if translate(left(line,6)) = \">START \" then leave\n  end\n  rec = 0\n  /* --------------------------------------------------- *\n  * Flag types of ISPF resources by testing each record *\n  * then add each record to the data. stem variable.    *\n  * --------------------------------------------------- */\n  do j = i+1 to last_line\n    line = sourceline(j)\n    if translate(left(line,5)) = \">END \"   then leave\n    if translate(left(line,7)) = \">CLIST \" then kclist = 1\n    if translate(left(line,6)) = \">EXEC \"  then kexec  = 1\n    if translate(left(line,5)) = \">MSG \"   then kmsg   = 1\n    if translate(left(line,7)) = \">PANEL \" then kpanel = 1\n    if translate(left(line,6)) = \">SKEL \"  then kskel  = 1\n    rec  = rec + 1\n    data.rec = line\n  end\n\n  /* ----------------------------------------------------- *\n  * Now create the Library and Load the Member(s)         *\n  * ----------------------------------------------------- */\n  Address ISPExec\n  /* ----------------------------- *\n  * Assign dynamic random ddnames *\n  * ----------------------------- */\n  clistdd = \"lc\"random(999)\n  execdd  = \"le\"random(999)\n  msgdd   = \"lm\"random(999)\n  paneldd = \"lp\"random(999)\n  skeldd  = \"ls\"random(999)\n\n  /* ---------------------------------------- *\n  *  LmInit and LmOpen each resource library *\n  * ---------------------------------------- */\n  if kclist <> null then do\n    call alloc_dd clistdd\n    \"Lminit dataid(clist) ddname(\"clistdd\")\"\n    \"LmOpen dataid(\"clist\") Option(Output)\"\n    returns = strip(returns clistdd 'ALTLIBC')\n  end\n  if kexec <> null then do\n    call alloc_dd execdd\n    \"Lminit dataid(exec) ddname(\"execdd\")\"\n    \"LmOpen dataid(\"exec\") Option(Output)\"\n    returns = strip(returns execdd 'ALTLIBE')\n  end\n  if kmsg <> null then do\n    call alloc_dd msgdd\n    \"Lminit dataid(msg) ddname(\"msgdd\")\"\n    \"LmOpen dataid(\"msg\") Option(Output)\"\n    returns = strip(returns msgdd 'ISPMLIB')\n  end\n  if kpanel <> null then do\n    call alloc_dd paneldd\n    \"Lminit dataid(panel) ddname(\"paneldd\")\"\n    \"LmOpen dataid(\"panel\") Option(Output)\"\n    returns = strip(returns paneldd 'ISPPLIB')\n  end\n  if kskel <> null then do\n    call alloc_dd skeldd\n    \"Lminit dataid(skel) ddname(\"skeldd\")\"\n    \"LmOpen dataid(\"skel\") Option(Output)\"\n    returns = strip(returns skeldd 'ISPSLIB')\n  end\n\n  /* ----------------------------------------------- *\n  * Process all records in the data. stem variable. *\n  * ----------------------------------------------- */\n  do i = 1 to rec\n    record = data.i\n    recordu = translate(record)\n    if left(recordu,5) = \">END \" then leave\n    if left(recordu,7) = \">CLIST \" then do\n      if first = 1 then call add_it\n      type = \"Clist\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,6) = \">EXEC \" then do\n      if first = 1 then call add_it\n      type = \"Exec\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,5) = \">MSG \" then do\n      if first = 1 then call add_it\n      type = \"Msg\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,7) = \">PANEL \" then do\n      if first = 1 then call add_it\n      type = \"Panel\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,6) = \">SKEL \" then do\n      if first = 1 then call add_it\n      type = \"Skel\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    /* --------------------------------------------*\n    * Put the record into the appropriate library *\n    * based on the record type.                   *\n    * ------------------------------------------- */\n    Select\n      When type = \"Clist\" then\n      \"LmPut dataid(\"clist\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(255)\"\n      When type = \"Exec\" then\n      \"LmPut dataid(\"exec\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(255)\"\n      When type = \"Msg\" then\n      \"LmPut dataid(\"msg\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      When type = \"Panel\" then\n      \"LmPut dataid(\"panel\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      When type = \"Skel\" then\n      \"LmPut dataid(\"skel\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      Otherwise nop\n    end\n  end\n  if type <> null then call add_it\n  /* ---------------------------------------------------- *\n  * Processing completed - now lmfree the allocation and *\n  * Libdef the library.                                  *\n  * ---------------------------------------------------- */\n  if kclist <> null then do\n    Address TSO,\n      \"Altlib Act Application(Clist) File(\"clistdd\")\"\n    \"LmFree dataid(\"clist\")\"\n  end\n  if kexec <> null then do\n    Address TSO,\n      \"Altlib Act Application(Exec) File(\"execdd\")\"\n    \"LmFree dataid(\"exec\")\"\n  end\n  if kmsg <> null then do\n    \"LmFree dataid(\"msg\")\"\n    \"Libdef ISPMlib Library ID(\"msgdd\") Stack\"\n  end\n  if kpanel <> null then do\n    \"Libdef ISPPlib Library ID(\"paneldd\") Stack\"\n    \"LmFree dataid(\"panel\")\"\n  end\n  if kskel <> null then do\n    \"Libdef ISPSlib Library ID(\"skeldd\") Stack\"\n    \"LmFree dataid(\"skel\")\"\n  end\n  return returns\n\n  /* --------------------------- *\n  * Add the Member using LmmAdd *\n  * based upon type of resource *\n  * --------------------------- */\nAdd_It:\n  Select\n    When type = \"Clist\" then\n    \"LmmAdd dataid(\"clist\") Member(\"name\")\"\n    When type = \"Exec\" then\n    \"LmmAdd dataid(\"exec\") Member(\"name\")\"\n    When type = \"Msg\" then\n    \"LmmAdd dataid(\"msg\") Member(\"name\")\"\n    When type = \"Panel\" then\n    \"LmmAdd dataid(\"panel\") Member(\"name\")\"\n    When type = \"Skel\" then\n    \"LmmAdd dataid(\"skel\") Member(\"name\")\"\n    Otherwise nop\n  end\n  type = null\n  return\n\n  /* ------------------------------ *\n  * ALlocate the temp ispf library *\n  * ------------------------------ */\nAlloc_DD:\n  arg dd\n  Address TSO\n  if pos(left(dd,2),\"lc le\") > 0 then\n  \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(v b) lrecl(255) blksize(32760)\"\n  else\n  \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(f b) lrecl(80) blksize(23440)\"\n  return\n\n  /* --------------------  rexx procedure  -------------------- *\n  * Name:      DropISPF                                        *\n  *                                                            *\n  * Function:  Remove ISPF LIBDEF's and deactivate ALTLIB's    *\n  *            that were created by the LoadISPF function.     *\n  *                                                            *\n  * Syntax:    rc = dropispf(load_info)                        *\n  *                                                            *\n  * Author:    Janko                                           *\n  *                                                            *\n  * History:                                                   *\n  *            12/05/18 - Creation                             *\n  * ---------------------------------------------------------- */\nDropISPF: Procedure\n  arg load_info\n  Address ISPEXEC\n  do until length(load_info) = 0\n    parse value load_info with dd libd load_info\n    if left(libd,6) = \"ALTLIB\" then do\n      if libd = \"ALTLIBC\" then lib = \"CLIST\"\n      else lib = \"EXEC\"\n      Address TSO,\n        \"Altlib Deact Application(\"lib\")\"\n    end\n    else \"libdef\" libd\n    address tso \"free f(\"dd\")\"\n  end\n  return 0\n    >ZGSTATE    *** End of the ZGSTAT inline code\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZIGI": {"ttr": 353, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01D\\x00D\\x01 \\x19o\\x01 %\\x0f\\x10\\x18\") \\x82\\x00\\x00\\xe9\\xc9\\xc7\\xc9\\xf3\\xf0\\xf1@@@'", "ispf": {"version": "01.68", "flags": 0, "createdate": "2020-07-14T00:00:00", "modifydate": "2020-09-06T10:18:44", "lines": 8745, "newlines": 8322, "modlines": 0, "user": "ZIGI301"}, "text": "  /* --------------------  rexx procedure  ------------------- */\n  ver = 'v3r02'\n  /*Name:      ZIGI  (z ISPF Git Interface)                    |\n  |                                                            |\n  | Function:  ISPF Interface to Git for source code           |\n  |            management                                      |\n  |                                                            |\n  | Syntax:    ex 'zigi.exec(zigi)'                            |\n  |                                                            |\n  |            or to restore the splash screen                 |\n  |            ex 'zigi.exec(zigi)' 'S'                        |\n  |                                                            |\n  |            or to start with a specific repository          |\n  |            ex 'zigi.exec(zigi)' 'repo-name'                |\n  |                                                            |\n  | NOTE:      ZIGI MUST NEVER be started under the ZIGI       |\n  |            ISPF Applications ID unless the libdef and      |\n  |            altlibs are done prior to starting.             |\n  |                                                            |\n  | Dependencies:                                              |\n  |            1. Requires the z/OS port of GIT be installed   |\n  |            2. Git setup in /etc/profile or ~/.profile      |\n  |                                                            |\n  | Authors:   Henri Kuiper                                    |\n  |            Lionel B. Dyck                                  |\n  |                                                            |\n  | History:  (most recent on top, see git log for full info)  |\n  |                                                            |\n  |            09/06/20 LBD - Remove calls to work/update after|\n  |                           PDS member update                |\n  |            08/24/20 LBD - Correct Del Repo processing      |\n  |            08/23/20 LBD - On ADDDSN if ignore is 0 allow   |\n  |                           changing HLQ while in table      |\n  |                         - Correctly detected Added if 0    |\n  |                         - Make remove from repo clearer    |\n  |            08/16/20 LBD - On Clone if non-zigi bypass      |\n  |                           gitattributes and .zigi create   |\n  |            08/15/20 LBD - Refine z/OS replace prompt       |\n  |                         - On stash pop leave stash table   |\n  |            08/14/20 LBD - Support for ReadOnly Repositories|\n  |                         - Prompt before full z/OS replace  |\n  |            08/08/20 LBD - Allow qualignr of 0              |\n  |                         - if file not in new branch do     |\n  |                           NOT delete z/OS dataset or mem   |\n  |                         - After Merge call update repo     |\n  |                         - Generalize get_binfiles          |\n  |            08/07/20 LBD - Add pfshow off/reset all pops    |\n  |            08/06/20 LBD - Remove redundant repo del code   |\n  |            07/29/20 LBD - Add _EDC_ZERO_RECLEN=Y to env.   |\n  |            07/25/20 LBD - Correct Stash processing         |\n  |            07/24/20 LBD - Set wrap message on zigiprim     |\n  |                           and for zigirepo                 |\n  |            07/22/20 LBD - Fix merge issue if no deletes    |\n  |                           and enable selective replace     |\n  |                           after merge conflicts resolved   |\n  |            07/18/20 LBD - Add Find for History table       |\n  |            07/17/20 LBD - Speed up History commit find     |\n  |                         - Rewrite History View/Recover     |\n  |            07/15/20 LBD - Keep .git/.gitattributes on del  |\n  |                           from zigi if omvs retained       |\n  |                         - On repo delete option to keep    |\n  |                           git directories/files            |\n  |            07/14/20 LBD - Fix bug detecting entry updates  |\n  |                         - Correct dataset check on branch  |\n  |            07/12/20 LBD - Resolve merge deletion issue     |\n  |                         - Fix multiple member RM issue     |\n  |            07/11/20 LBD - Correct member status after RN   |\n  |                         - Correct merge conflict on ispf   |\n  |                           stats member (do automatically)  |\n  |            07/08/20 LBD - Correct copy after member edit   |\n  |            07/07/20 LBD - Ensure status update after A/AB  |\n  |                         - Support members w/ext for defurid|\n  |            07/06/20 LBD - Correct F3 on Rollback process   |\n  |                         - Fix zigirep with reponame        |\n  |                           and vice versa                   |\n  |            07/05/20 LBD - Fix member delete on pull        |\n  |                         - Support Repoistory Name          |\n  |                           unique from directory name       |\n  |                         - Update Stats after member chg    |\n  |                         - For Find use reponame and cat    |\n  |                           along with prefix in zigiprim    |\n  |            07/04/20 HBK - Fix bug in zigi-flow             |\n  |            06/28/20 LBD - After edit use usssafe on cp     |\n  |            06/27/20 LBD - Correct check on repo select     |\n  |            06/25/20 LBD - Correct .gitattributes update for|\n  |                           load library add                 |\n  |            06/24/20 LBD - On a branch only update/copy/del |\n  |                           changed elements                 |\n  |            06/23/20 LBD - Enable Prompt for AB extensions  |\n  |            06/20/20 LBD - Add object hash to taglist tag   |\n  |            06/19/20 LBD - swap git rm and rm if mbr gone   |\n  |            06/18/20 LBD - Correct Extract list and Show    |\n  |                         - On Add Dataset copy all using    |\n  |                           a single cp if not mixed (t/b)   |\n  |                         - On Add Dataset RECFM=U is set    |\n  |                           to Binary Load Module on S/A     |\n  |            06/17/20 LBD - Backout cp change on add copy    |\n  |                         - Add PopUp when Commit starts     |\n  |            06/16/20 LBD - Fix SET ID on Commit             |\n  |                         - Fix Invalid Selection on PDS List|\n  |                         - vput Default UID on Repo Open    |\n  |            06/15/20 LBD - Support recovery in mem delete   |\n  |                         - enhance repo status info         |\n  |                         - Clean up clone time message      |\n  |                         - Correct Member list sort date    |\n  |            06/14/20 LBD - Add prompt for delete processing |\n  |                           if PDS member mia but OMVS not   |\n  |            06/13/20 LBD - Replace Extract routines  with   |\n  |                           call to zigiextr                 |\n  |            06/12/20 LBD - Numerous bug fixes all small     |\n  |            06/11/20 LBD - Tag Extract corrections          |\n  |            06/10/20 LBD - Speed up bpxwunix with shareas   |\n  |            06/08/20 LBD - Fix add member counter           |\n  |                         - Add Parse to Arg is_binfile      |\n  |                         - Correct is_binfile (procedure)   |\n  |            06/07/20 LBD - Correct binfile check (no safe)  |\n  |            05/27/20 LBD - Add error messages on browse     |\n  |            05/26/20 LBD - Correct RM if untracked          |\n  |            05/25/20 LBD - Improve status field for all     |\n  |            05/19/20 EJA - Improve status field for PDS     |\n  |            05/17/20 LBD - Fix merge resolution stats if    |\n  |                           file extensions in use           |\n  |                         - Fix current repo multi-select    |\n  |                           failure                          |\n  |            05/16/20 LBD - Fix last ref date file if hlq    |\n  |                           changed on set                   |\n  |            05/15/20 LBD - New Z line command repo/pds to   |\n  |                           view the omvs directory/file     |\n  |            05/15/20 HBK - Fix bug adding with extensions   |\n  |            05/10/20 LBD - Fix TagList sort date            |\n  |            05/08/20 LBD - Add support for executables      |\n  |                           from RECFM=U libraries (-X -I)   |\n  |                     HBK - Test for -X/-I support           |\n  |                     LBD - On repo delete rm the last       |\n  |                           reference file                   |\n  |            05/02/20 LBD - Support graph view colors        |\n  |            05/01/20 LBD - Fix Stash and Stash Pop issues   |\n  |            04/29/20 LBD - Add volser to Add Dsn display    |\n  |            04/28/20 LBD - Correct taglist create repo      |\n  |                           display                          |\n  |                         - Change to routine to set the     |\n  |                           sortdate value                   |\n  |            04/26/20 LBD - Update SnapShot to allow a null  |\n  |                           path to bypass OMVS copy         |\n  |                         - Same change for TagList Extract  |\n  |            04/25/20 LBD - Add Commit Import command        |\n  |            04/23/20 LBD - Fix Locate in Member List        |\n  |                         - TagList Extract validate dir     |\n  |            04/19/20 LBD - Correct D# bug in Commit table   |\n  |            04/18/20 LBD - Remove residual Commit msgs      |\n  |            04/16/20 LBD - Colorize ZIGIPRIM columns        |\n  |                           white = sorted TURQ = not        |\n  |                         - refacrot zigihist routines       |\n  |            04/12/20 EJA - Improve overview by using        |\n  |                           more function calls              |\n  |                           There should be no functional    |\n  |                           change                           |\n  |            03/30/20 LBD - Enhance RM delete options        |\n  |                         - Set version to 2.8               |\n  |            03/28/20 LBD - Support PDS member file          |\n  |                           extensions                       |\n  |            03/18/20 LBD - Refine ref date check            |\n  |                         - Bypass update check after repo   |\n  |                           is selected.                     |\n  |                         - New CHECK command to check       |\n  |                           updated datasets.                |\n  |            03/17/20 LBD - Improve delete PDS member        |\n  |                           detection on PULL                |\n  |                         - Bypass update check based on     |\n  |                           last reference date of dataset   |\n  |            03/15/20 LBD - Detect when PDS members deleted  |\n  |                           outside of ZIGI                  |\n  |            03/09/20 LBD - Remove unneeded control save/rest|\n  |            03/05/20 HBK - Fixed another qualignr 'bug'     |\n  |                         - More deletes at remove repo      |\n  |            03/04/20 LBD - Jump to Add Dataset after Create |\n  |            03/03/20 LBD - Several updates                  |\n  |            02/28/20 LBD - Added Convert Repo capability    |\n  |            02/27/20 HBK - Added feature 'zigiflow'         |\n  |                           Fixed another edge case with $'s |\n  |            02/26/20 LBD - Numerous changes to support      |\n  |                           Stash processes                  |\n  |                         - Fix fetch flag setting           |\n  |            02/21/20 LBD - Change Refresh to Replace        |\n  |                         - Add Fetch command                |\n  |                         - Only fetch 1st time or on demand |\n  |            02/15/20 LBD - Remove view_std's where not      |\n  |                           worth it (rm/rn) and added msgs  |\n  |                         - Change commit to use a table for |\n  |                           an unlimited # of message lines  |\n  |            02/14/20 LBD - Correctly identify already added |\n  |                           datasets during ADDDSN           |\n  |            02/13/20 LBD - Enable 2 column sort on Local    |\n  |                           Repository and retain sort order |\n  |                           for next time ZIGI starts.       |\n  |                         - Fix bug with selective OMVS to   |\n  |                           z/OS copy during PULL for both   |\n  |                           renames and deletes.             |\n  |                         - Enable passing a repo name on    |\n  |                           start                            |\n  |            02/10/20 LBD - Add SortDate for proper sorting  |\n  |                         - Add optional tag on commit       |\n  |            02/09/20 LBD - Update sort default orders       |\n  |                         - add time to zigidate             |\n  |                         - save default sort for zigirepo   |\n  |            02/08/20 LBD - Test for branch before create    |\n  |            02/07/20 LBD - Support Tag/Tagline              |\n  |            02/03/20 LBD - Support mixed text/binary pds    |\n  |            02/02/20 LBD - Add ADDALL to current repo and   |\n  |                           PDS member list commands         |\n  |            01/24/20 LBD - Improve RFIND table entry setup  |\n  |            01/23/20 LBD - Eliminate use of LISTC for ADDdsn|\n  |                           and call ZIGIRCSI                |\n  |                         - Add FIND for ADDDSN routine      |\n  |                         - Enable RFIND                     |\n  |            01/21/20 LBD - Undo now works for PS and PDS    |\n  |                         - Correct bug in RM for OMVS file  |\n  |                           with blanks in name              |\n  |                         - On Pull correctly delete items   |\n  |                           that have been removed.          |\n  |                         - After Commit if no push and a    |\n  |                           Remote issue message to remind   |\n  |                           to push.                         |\n  |            01/20/20 LBD - Put OMVS files in quotes for     |\n  |                           git add                          |\n  |                         - Add several binary filetypes     |\n  |                           to .gitattributes priming        |\n  |            01/19/20 LBD - Add LMFree after every LMClose   |\n  |                         - Pass qualignr to zigickot        |\n  |                         - Fix qualignr=0 issues            |\n  |            01/17/20 LBD - Support Only and Refresh in      |\n  |                           Rollback                         |\n  |            01/16/20 LBD - Support Recover in History for   |\n  |                           individual element               |\n  |            01/15/20 LBD - Fix binary PDS member tag -R     |\n  |            01/14/20 HBK - Binary support implemented       |\n  |                     LBD - Correct selective refresh bug    |\n  |            01/13/20 LBD - Implement repository Snapshot    |\n  |                         - Change current repo ADD to       |\n  |                           ADDDSN                           |\n  |            01/12/20 LBD - Always copy PS files and let     |\n  |                           git determine any changes        |\n  |            01/11/20 LBD - Do git add for stats after PDS   |\n  |                           member rm                        |\n  |                         - Prompt for OK to delete branch   |\n  |            01/10/20 LBD - Correct detection of renames     |\n  |                         - fix rename member with specials  |\n  |            01/09/20 LBD - Support Repo del of the z/OS     |\n  |                           datasets and more confirmation   |\n  |            01/08/20 LBD - Update for PDSE generations      |\n  |                           at allocation                    |\n  |            01/07/20 LBD - Additional debug calls           |\n  |                         - debug file name date/time added  |\n  |                         - change list debug files from B   |\n  |                         - don't copy PS if not new/changed |\n  |            01/05/20 LBD - If PDSE then never do full       |\n  |                           refresh on a pull                |\n  |            01/03/20 LBD - On Pull only refresh updated     |\n  |                           datasets and/or members.         |\n  |                         - if > 25% members updated in pull |\n  |                           then refresh full pds.           |\n  |                         - Correct primary panel zcmd for   |\n  |                           upper case command, mixed other  |\n  |                         - Change sort order if Date to     |\n  |                           include Time                     |\n  |                         - On Edit_PS use usssafe for cp    |\n  |                           on the repository file name      |\n  |                         - Bypass update_repo_metadata if   |\n  |                           multiple rows selected           |\n  |            01/02/20 LBD - For clone/create set sets to null|\n  |                         - Add Select command for repo      |\n  |            12/26/19 LBD - Change temp dsn suffix: gitdata  |\n  |            12/24/19 HBK - Correct URL parse                |\n  |                     LBD - Enable O.xxx commands            |\n  |            12/23/19 HBK - One more fix for file status     |\n  |                     LBD - Use View for DIFF for hilite     |\n  |            12/22/19 HBK - Correct stats for subdirectories |\n  |            12/15/19 LBD - Add Author  to History display   |\n  |            12/14/19 LBD - Improve history log search       |\n  |                           using grep                       |\n  |            12/13/19 LBD - Add new History selection        |\n  |                         - Add incldiff leed-dev            |\n  |            12/10/19 LBD - Add FIND/RFIND for Repo table    |\n  |                           and in the dataset/file table    |\n  |            12/09/19 LBD - Improve OMVS directory support   |\n  |            12/07/19 LBD - Implement a git merge conflict   |\n  |                           resolution process.              |\n  |            12/06/19 LBD - Define top tutorial panel        |\n  |            12/04/19 LBD - Support Remove (RM) and          |\n  |                           Rename (RN) options              |\n  |            11/30/19 LBD - Use Edit and View for OMVS files |\n  |                         - Test if Edit OMVS file changed   |\n  |            11/27/19 HBK - Check for minimal git version    |\n  |            11/27/19 LBD - Translate ' and \" from commit    |\n  |                           1 line msg.                      |\n  |                         - add -i (ignore case) to grep     |\n  |                         - in grep dsn allow b/e/v of       |\n  |                           omvs files                       |\n  |            11/26/19 HBK - Support site profile             |\n  |            11/25/19 LBD - Add repository SET for defaults  |\n  |                         - Support ROLLBACK of repo         |\n  |                         - Enhance GITLOG and GREP          |\n  |                         - Update member uids if default id |\n  |                           set during commit                |\n  |            11/21/19 LBD - Check for ISPTABL and use it     |\n  |                           otherwise use ISPPROF for our    |\n  |                           table.                           |\n  |            11/18/19 LBD - Support F3 in ZIGIOSEL and       |\n  |                           skip clone.                      |\n  |                         - Replace LMMSTATS with LMMFIND    |\n  |                           to get member stats              |\n  |                         - Add -v (verbose) where ok        |\n  |            11/16/19 LBD - Convert to using zigitstat       |\n  |                           to save/update/compare           |\n  |                           ispf stats on PDS members.       |\n  |            11/13/19 LBD - Enhance the debug routine:       |\n  |                           Return a return code             |\n  |                           check for ZIGIDEBG DD enable     |\n  |                           log is in users home dir         |\n  |            11/11/19 LBD - Add GITHELP as a command from    |\n  |                           all panels (except browse)       |\n  |            11/10/19 HBK - Fix qualignr edge-cases          |\n  |            11/09/19 HBK - My history keeps dissapearing    |\n  |                           see git :)                       |\n  |            11/06/19 LBD - Numerous changes including       |\n  |                           - Improve bpxwunix performance   |\n  |                             by using an env stem           |\n  |                           - fix lrecl for browse reports   |\n  |                           - other bug fixes and cleanup    |\n  |            11/02/19 LBD - Add shorten ZIGIREPO panel       |\n  |                           ZIGIREPS if Short command used   |\n  |            10/31/19 LBD - Various Fixes :)                 |\n  |            10/29/19 LBD - Add MultiDCB Support             |\n  |            10/24/19 HBK - Also source ~/.profile if exists |\n  |            10/24/19 LBD - Change 2 routines to procedure   |\n  |                         - Add Commit message               |\n  |            10/21/19 LBD - Use PARSE SOURCE for hlq         |\n  |            10/20/19 HBK - Fix LMM things :)                |\n  |            10/19/19 LBD - Better prefix, scrolling etc.    |\n  |            10/17/19 HBK - Add back LMM, cleanup code       |\n  |            09/30/19 HBK - Major rewrite :)                 |\n  |            07/24/19 HBK - Some git functions               |\n  |            06/15/19 HBK - Autofind git binary              |\n  |            06/14/19 LBD - Major updates                    |\n  |            06/12/19 LBD - Major updates                    |\n  |            06/11/19 LBD - Creation                         |\n  |                                                            |\n  | ---------------------------------------------------------- |\n  |    ZIGI - the z/OS ISPF Git Interface                      |\n  |    Copyright (C) 2020 - Henri Kuiper and Lionel Dyck       |\n  |                                                            |\n  |    This program is free software: you can redistribute it  |\n  |    and/or modify it under the terms of the GNU General     |\n  |    Public License as published by the Free Software        |\n  |    Foundation, either version 3 of the License, or (at     |\n  |    your option) any later version.                         |\n  |                                                            |\n  |    This program is distributed in the hope that it will be |\n  |    useful, but WITHOUT ANY WARRANTY; without even the      |\n  |    implied warranty of MERCHANTABILITY or FITNESS FOR A    |\n  |    PARTICULAR PURPOSE.  See the GNU General Public License |\n  |    for more details.                                       |\n  |                                                            |\n  |    You should have received a copy of the GNU General      |\n  |    Public License along with this program.  If not, see    |\n  |    <https://www.gnu.org/licenses/>.                        |\n  * ---------------------------------------------------------- */\n  parse arg start_option\n\n  null = ''\n  parse value '' with null repo_ztdsels fetch_flag\n\n  /* ------------------------------------------ *\n  | ISPExec is our default host environment    |\n  * ------------------------------------------ */\n  Address ISPExec\n\n  /* ============================================================== */\n  /* ======== main flow          ================================== */\n  /* ============================================================== */\n\n  call init_ispf\n  call display_splash\n  call enable_rfind\n  call init_git\n  call init_repo\n\n  /* ------------------------------------------ *\n  | Handle zigiprim panel                       |\n  * ------------------------------------------ */\n  do forever\n    /* repo was not specified on start command ? */\n    if szcmd = null then do\n      call display_zigiprim\n      /* end selected, exit ZIGI */\n      if result > 4 then leave\n    end\n\n    /* repo was specified on start command, bypass panel ? */\n    if szcmd /= null then do\n      zcmd = szcmd\n      szcmd = null\n    end\n\n    check_flag = 1\n\n    /* uppercase translate the command part of the zcmd, leaving rest asis */\n    zcmd = strip(translate(word(zcmd,1)) subword(zcmd,2))\n\n    /* turn L(ocate) into F(ind) */\n    if word(zcmd,1) = 'L' then\n    zcmd = 'F' subword(zcmd,2)\n\n    /* --------------------------------- *\n    | Show popup with valid menu options |\n    * --------------------------------- */\n    if abbrev('O',word(zcmd,1),1) = 1 then call display_zigioprm\n\n    /* ------------------------ *\n    | Select a repo by command |\n    * ------------------------ */\n    if abbrev('SELECT',word(zcmd,1),1) = 1 then call handle_zigiprim_select\n\n    /* -------------- *\n    | Process a Find |\n    * -------------- */\n    if zcmd = 'RFIND' then do\n      zcmd = 'FIND' fstring\n      rfs  = rowcnt\n    end\n    else rfs = 0\n    if abbrev('FIND',word(zcmd,1),1) = 1 then call handle_zigiprim_find\n\n    parse value '' with fulldsn dsn defcpush defruid\n    /* Get the row after the clear to get variables */\n    'tbget zigirepo'\n    if defcpush = 'Y' then zpush = 'Y'\n    else zpush = 'N'\n\n    /* -------------------------------- *\n    | Define Set as an alias of Config |\n    * -------------------------------- */\n    if abbrev('SET',zcmd,2) = 1 then zcmd = 'CONFIG'\n\n    /* handle remaining primairy commands */\n    if zcmd /= null then\n    Select\n      When abbrev('CREATE',zcmd,2) = 1 then call handle_zigiprim_create\n      When abbrev('CLONE',zcmd,2) = 1 then call handle_zigiprim_clone\n      When abbrev('CONFIG',zcmd,2) = 1 then call handle_zigiprim_config\n      When abbrev('GITHELP',word(zcmd,1),4) = 1 then\n      Address TSO '%githelp' subword(zcmd,2)\n      When abbrev('LOCAL',zcmd,2) = 1 then call handle_zigiprim_local\n      When abbrev('SORT',word(zcmd,1),2) = 1 then call handle_zigiprim_sort\n      When abbrev('SSH',zcmd,2) = 1 then call handle_zigiprim_ssh\n      When zcmd = 'VIEWD' then call view_debug\n      Otherwise if zcmd /= null then do\n        zerrsm = 'Unknown'\n        zerrlm = zcmd 'is not a recognized command.'\n        'setmsg msg(isrz003)'\n      end\n    end\n\n    /* handle line commands */\n    if zsel = '/' then do\n      call pfshow 'off'           /* make sure pfshow is off */\n      'Addpop row(4) column(6)'\n      'Display Panel(zigirprm)'\n      'rempop'\n      call pfshow 'reset'         /* restore pfshow setting */\n    end\n\n    if zsel /= null then\n    Select\n      When zsel = 'I' then call handle_zigiprim_lcmd_i\n      When zsel = 'S' then call select_repo\n      When zsel = 'V' then\n      'SELECT PGM(ISRDSLST) PARM(UDL' localrep'/'zigirep') SUSPEND'\n      When zsel = 'D' then call handle_zigiprim_lcmd_d\n      Otherwise do\n        zerrsm = 'Unknown'\n        zerrlm = zsel 'is not a recognized command.'\n        'setmsg msg(isrz003)'\n      end\n    End\n  end\n\n  if rtbl_open = 1 then\n  'tbend' rtbl\n  'tbclose zigirepo'\n\n  /* ----------------------------------------------------------- *\n  | If the ZIGIDEBG DD was present and the debugging was in use |\n  | then display a list of debug files using the UDList (3.17)  |\n  | utility.                                                    |\n  * ----------------------------------------------------------- */\n  if zigidebg = 1 then\n  if zigidebg_use = 1 then do\n    \"Select Pgm(isrdslst) Parm(UDL ~/zigidebug*) SUSPEND\"\n  end\n  Exit 0\n\n  /* ============================================================== */\n  /* ======== main initialization functions       ================= */\n  /* ============================================================== */\n\ninit_repo:\n  /* ---------------------------------------- *\n  | Open (or create and open) the Repo Table |\n  * ---------------------------------------- */\n  isptabl = 'ISPTABL'\n  x = listdsi(isptabl 'FILE')\n  if x > 0 then isptabl = 'ISPPROF'\n  'TBOpen zigirepo Library('isptabl') Write Share'\n  if rc > 0 then do\n    if rc = 8 then call create_zigirepo\n    if rc > 8 then do\n      'setmsg msg(isrz003)'\n    end\n  end\n\n  /* --------------------------------------------- *\n  | Test to see if the ZIGIREPO table is for V2R0 |\n  | and if not upgrade it.                        |\n  * --------------------------------------------- */\n  call test_repo_table_state\n\n  repo_top = 1\n  'tbtop zigirepo'\n  'vget (defrsort srr src srp srl) profile'\n  if words(defrsort) = 2 then defrsort = 'zigirep,c,a'\n  'TBSort zigirepo Fields('defrsort')'\n  parse value '' with zsel szcmd\n  if start_option /= null\n  then if translate(start_option) /= 'S' then\n  szcmd = 'S' start_option\n\n  /* Panel for when there are no repos in profile yet */\n  'TBStats zigirepo rowcurr('tr')'\n  if tr = 0 then do\n    call pfshow 'off'           /* make sure pfshow is off */\n    'Addpop row(4) column(6)'\n    'Display Panel(zigi1st)'\n    'rempop'\n    call pfshow 'reset'         /* restore pfshow setting */\n  end\n  Return\n\n  /* ------------------------------ *\n  | Populate the SortDate variable |\n  * ------------------------------ */\nset_sortdate:\n  sortdate = date('b')''right(time('s')+100000,5)\n  return\n\n  /* ------------------------------------------- *\n  | Handle zigiprim panel primary command O      |\n  * ------------------------------------------- */\ndisplay_zigioprm:\n  parse value '' with findstr selfind\n  if pos('.',zcmd) > 0 then\n  parse value zcmd with x'.'zcmd\n  call pfshow 'off'           /* make sure pfshow is off */\n  'Addpop row(4) column(6)'\n  'Display Panel(zigioprm)'\n  'rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  if findstr /= null\n  then zcmd = 'F' findstr\n  if selfind /= null\n  then zcmd = 'S' selfind\n  Return\n\n  /* ------------------------------------------- *\n  | Display zigiprim panel                       |\n  * ------------------------------------------- */\ndisplay_zigiprim:\n  parse value '' with zsel row readonly\n  fetch_flag = 0\n  zigpass = 'PASSTHRU'\n  'vput (zigpass) shared'\n  'TBTop zigirepo'\n  'tbskip zigirepo number('repo_top')'\n  localrep = null\n  'vput (localrep) shared'\n  'tbdispl zigirepo panel(zigiprim)'\n  trc = rc\n  zigpass = null\n  'vput (zigpass) shared'\n  if trc > 4 then Return trc\n\n  if ztdsels = 0 then\n  if pnsdef = 'P' then do\n    if row = 0 then zcmd = 'O'\n    if row > 0 then zsel = '/'\n  end\n\n  repo_top = ztdtop\n  if row = 0 then zsel = null\n  if row <> null then\n  if row > 0 then do\n    'TBTop zigirepo'\n    'TBSkip zigirepo Number('row')'\n  end\n  Return\n\n  /* ---------------------------------------------------------- *\n  | See if we have git installed, have a public key, have a    |\n  | correct env and have user.name and user.email set          |\n  * ---------------------------------------------------------- */\ninit_git:\n  /* ------------------------------------ *\n  | define our working default variables |\n  * ------------------------------------ */\n  zhtop = 'ZIGIHINT'\n  zerrhm   = 'zigih00'\n  zerralrm = 'NO'\n  zerrtp   = 'NOTIFY'\n  zs1 = 'Preparing the ZIGI environment for use'\n  zs2 = 'Please standby'\n  call do_popup\n\n  /* See if we've a custom env file in profile already */\n  'vget (gitenv) profile'\n  call getenv\n\n  keyfile = home'/.ssh/id_rsa.pub'\n  rtbl = 'ZIGL'random(9999)\n  rtll = 'ZIGM'random(9999)\n  rtbb = 'ZIGB'random(9999)\n  rtbl_open = 0\n  rtll_open = 0\n  combine.0 = 0\n  zigi_offline = 0\n\n  /* ------------------------------------ *\n  | Let's try to find git.               |\n  * ------------------------------------ */\n  zs1 = 'Checking if you have git installed'\n  zs2 = 'Please standby'\n  call do_popup\n\n  x   = docmd('command -v git')\n\n  x = so.0\n  if so.0 > 0 then do\n    zigigitl = strip(so.x)\n    'vput (zigigitl) profile'\n  end\n  else do\n    'Display Panel(zigigit)'\n    'vput (gitenv) profile'\n    call getenv\n    x = docmd('command -v git')\n    if so.0 > 0 then do\n      x = so.0\n      zigigitl = strip(so.x)\n      'vput (zigigitl) profile'\n    end\n    else do\n      /* Nope that file is not correct. removing from profile */\n      zs1 =  \"The env file (\"gitenv\") does not point me to git :(\"\n      zs2 =  \"Please rerun ZIGI and specify a valid env file\"\n      zs4 = 'Press Enter to exit and try again.'\n      call do_popup4p\n      parse value '' with zs3\n      'verase (gitenv) profile'\n      exit(0)\n    end\n  end\n\n  x = docmd('git --version')\n  required_version = '2.14.4'\n  x = so.0\n  parse var so.x 'git' 'version' version'_'subversion\n  version = strip(version,'B')\n  if version < required_version then do\n    zs1 = \"Your git version is not at the minimum required level\"\n    zs2 = \"Your level    : \"version\n    zs3 = \"Required level: \"required_version\n    zs4 = 'Press Enter to exit and install the correct version.'\n    call do_popup4p\n    exit 8\n  end\n  /* ------------------------------------------ *\n  | Check for GIT Userid and if not found      |\n  | then prompt for it along with a GIT E-Mail |\n  | Find the SSH key and if not there generate |\n  * ------------------------------------------ */\n  zs1 = 'Checking for user.name and user.email'\n  zs2 = 'Please standby'\n  call do_popup\n  x = docmd('git config --global user.name')\n  if x = 0 then do\n    x = so.0\n    zigiuid = so.x\n  end\n  else do\n    zigiuid = null\n  end\n  x = docmd('git config --global user.email')\n\n  if x = 0 then do\n    x = so.0\n    zigimail = so.x\n  end\n  else do\n    zigimail = null\n  end\n  cmd = 'cat 'home'/.ssh/id_rsa.pub'\n  x = docmd(cmd)\n  if x > 0 then do\n    zs1 = 'No SSH identity found in 'home'/.ssh/id_rsa'\n    zs2 = 'Generating keypair, please standby'\n    call do_popup\n    cmd = 'mkdir -p 'home'/.ssh'\n    x = docmd(cmd)\n    cmd = 'cd 'home' && ssh-keygen -t rsa -f .ssh/id_rsa'\n    x = docmd(cmd)\n    cmd = 'cat 'home'/.ssh/id_rsa.pub'\n    x = docmd(cmd)\n  end\n  x = so.0\n  zigissh = so.x\n  old_zigiuid = zigiuid\n  old_zigimail = zigimail\n\n  'vget (mgen extfile) profile'\n  if pos(extfile,'YN') = 0 then do\n    extfile = 'N'\n    'vput (extfile) profile'\n  end\n\n  Select\n    When mgen = null then hit = 0\n    when zigiuid = null then hit = 0\n    when zigimail = null then hit = 0\n    Otherwise hit = 1\n  end\n  do forever\n    if hit = 1 then leave\n    sl = mgen()\n    'Display Panel(zigiset)'\n    if rc > 0 then leave\n    'vput (mgen extfile) profile'\n    call update_config\n    if zigiuid /= null\n    then if zigimail /= null\n    then if zigissh /= null\n    then do forever\n      zcmd = null\n      'Display Panel(zigisshk)'\n      if rc > 0 then do\n        hit = 1\n        leave\n      end\n    end\n  end\n  Return\n\n  /* ---------------------------------------------------------- *\n  | Enable RFIND (Repeat Find) by adding an RFIND entry to the |\n  | active site command table with a symbolic that will be     |\n  | changed to PASSTHRU prior to each TBDISPL and back to null |\n  | after. This allows RFIND to be passed to our applicaiton.  |\n  * ---------------------------------------------------------- */\nenable_rfind:\n\n  zctverb  = \"RFIND\"\n  zcttrunc = 0\n  zctact   = \"&ZIGPASS\"\n  zctdesc  = \"RFIND for ZIGI Dialog\"\n  'vget (zsctpref)'\n  if zsctpref = null\n  then zsctpref = 'ISP'\n  ctab = zsctpref'cmds'\n  'tbtop' ctab\n  'tbscan' ctab 'arglist(zctdesc) condlist(EQ) Next'\n  if rc > 0 then 'tbadd' ctab\n  zigpass = null\n  'vput (zigpass)'\n  Return\n\n  /* ----------------------------------------------------- *\n  | Display and handle the splash screen                  |\n  * ----------------------------------------------------- */\ndisplay_splash:\n  /* ---------------------------------------------------------------- *\n  | Running under the ZIGI ISPF Application ID so let's do some work |\n  * ---------------------------------------------------------------- */\n  parse value '' with zcmd zsel\n  zigtitle = '(ZIGI' ver')'\n  'vput (zigtitle ver) shared'\n  'vget (bypass pnsdef) profile'\n  if pnsdef = null then do\n    pnsdef = 'S'\n    'vput (pnsdef) profile'\n  end\n  bypasso = bypass\n  if translate(start_option) = 'S' then bypass = 'N'\n  if bypass /= 'Y' then do\n    'display panel(zigispls)'\n    if rc = 8 then exit\n    'vput (bypass) profile'\n    if bypasso /= 'Y' then\n    if bypass = 'Y' then do\n      zs1 = 'The splash screen will no longer display per your request.'\n      zs2 = ' '\n      zs3 = 'Start ZIGI with a parm of S to restore.'\n      zs4 = '--- Press Enter to continue.'\n      call do_popup4p\n    end\n  end\n  Return\n\n  /* ----------------------------------------------------- *\n  | Initialize the ispf environment and make sure we      |\n  | are running under the ZIGI applid                     |\n  * ----------------------------------------------------- */\ninit_ispf:\n  'vget (zapplid)'\n\n  /* ----------------------------------------------------- *\n  | Get the Active HLQ for use with the ALTLIB and LIBDEF |\n  | of the ZIGI libraries.                                |\n  | 1st Get the active exec library or dd                 |\n  * ----------------------------------------------------- */\n  parse source TSO Type exec_name DDName exec NameO Env Addr Token\n  if exec = '?' then do\n    x = listdsi(ddname 'FILE')\n    exec = sysdsname\n  end\n  /* ------------------------------------------ *\n  | Now extract the HLQ for the Panels Library |\n  * ------------------------------------------ */\n  zigihlq = translate(exec,' ','.')\n  zigihlq = subword(zigihlq,1,words(zigihlq)-1)\n  zigihlq = translate(zigihlq,'.',' ')\n  /* ---------------------------------------------- *\n  | Fully qualify the EXEC and PANELS library dsns |\n  * ---------------------------------------------- */\n  exec = \"'\"exec\"'\"\n  panels = \"'\"zigihlq\".PANELS'\"\n\n  /* ----------------------------------------------------------- *\n  | Check for running under the ZIGI ISPF application ID and if |\n  | not then recurse into it.                                   |\n  * ----------------------------------------------------------- */\n  if zapplid <> \"ZIGI\" then do\n    Address ISPExec\n    /* ---------------------------------------- *\n    | If panels/exec then libdef and/or altlib |\n    | but only if not under ZIGI applid.       |\n    * ---------------------------------------- */\n    if panels /= null then\n    'libdef ispplib dataset id('panels') stack'\n    if exec /= null then\n    Address TSO 'altlib act application(exec) dataset('exec')'\n    /* --------------------------------------- *\n    | Make sure we are under the ZIGI applid  |\n    * --------------------------------------- */\n    \"Select CMD(\"exec_name start_option\") Newappl(ZIGI) Passlib scrname(ZIGI)\"\n    if panels /= null then\n    'libdef ispplib'\n    if exec /= null then\n    Address TSO 'altlib deact application(exec)'\n    exit 0\n  end\n  zigpass = null\n  'vput (zigpass) shared'\n\n  parse value '' with null rx zigidebg_flag save_zigirep fulldsn cltime\n  cscnt = 0\n  cdrcnt = 0\n\n  cmd = 'pwd'\n  env.1 = '_BPX_SHAREAS=YES'\n  env.0 = 1\n  x = bpxwunix(cmd,,so.,se.,env.)\n  home    = strip(so.1)\n\n  /* ---------------------------------------- *\n  | Check for ZIGIDEBG DD for debug purposes |\n  * ---------------------------------------- */\n  x = listdsi('ZIGIDEBG' 'FILE')\n  if x > 0 then if sysreason = 3 then do\n    zigidebg = 1\n    ztime = time()\n    ztime = left(ztime,2)''substr(ztime,4,2)''substr(ztime,7,2)\n    debugfil = home'/zigidebug.d'date('j')'.t'ztime\n    'vput (debugfil)'\n  end\n  else zigidebg = 0\n  \"Control Errors Return\"\n  Return\n\n  /* ------------------------------------- *\n  | Select the Current Repository Routine |\n  * ------------------------------------- */\nSelect_Repo:\n  check_flag = 1\n  zigidate = date('n')\n  call set_sortdate\n  'tbmod zigirepo order'\n  x = debug('Getting binfiles:' reponame)\n  drop binfiles.\n  call get_binfiles\n  x = debug('Got 'binfiles.0' binfiles')\n  x = debug('Selecting repo:' reponame)\n  'vput (defruid)'\n  call Work_With_Repo\n  x = debug('Return from repo:' reponame)\n  Return\n\n  /* ------------------------------ *\n  | Create the ZIGIREPO ISPF Table |\n  * ------------------------------ */\nCreate_zigirepo:\n  \"TBCreate zigirepo Keys(zigikey)\",\n    \"Names(zigirep localrep pdshlq qualignr zigidate defcpush\" ,\n    \" sortdate defruid zigicat branch remote1 reponame)\",\n    'Library('isptabl') Write Share Replace'\n  'vget (defrsort srr src srp srl) profile'\n  'TBSort zigirepo Fields('defrsort')'\n  'TBSAVE zigirepo REPLCOPY LIBRARY('isptabl')'\n  return\n\n  /* ============================================================== */\n  /* ======== zigiprim handling support functions ================= */\n  /* ============================================================== */\n\n  /* ------------------------------------------ *\n  | Handle zigiprim panel linecommand i         |\n  * ------------------------------------------ */\nhandle_zigiprim_lcmd_i:\n  call pfshow 'off'           /* make sure pfshow is off */\n  'addpop row(3) column(1)'\n  'display panel(zigiinfo)'\n  'rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  zsel = null\n  Return\n\n  /* ------------------------------------------ *\n  | Handle zigiprim panel linecommand d         |\n  * ------------------------------------------ */\nhandle_zigiprim_lcmd_d:\n  readonly = check_read_only()\n  parse value '' with delcz delcg delco delcf delzd\n  call pfshow 'off'           /* make sure pfshow is off */\n  'Addpop row(3) column(10)'\n  'Display panel(zigidelc)'\n  drc = rc\n  'rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  if drc = 0 & delcf = 'Y' then do\n    'tbdelete zigirepo'\n    cmd = 'cd 'localrep'/'zigirep' && rm -rf .zigi'\n    x = docmd(cmd)\n    if x = 0 then do\n      zerrsm = 'Deleted.'\n      delcz = 'Repo removed from ZIGI, .zigi files deleted.'\n    end\n    cmd = 'cd 'localrep'/'zigirep' && rm -rf .git .gitattributes'\n    x = docmd(cmd)\n    if x = 0 then do\n      zerrsm = 'Deleted.'\n      delcg = 'Git files removed.'\n      del_refd = zigirefd(localrep'/'zigirep pdshlq 1 'D')\n    end\n    if readonly = 1 then delzd = 'Y'\n    if delzd = 'N' then do\n      delzd = 'The z/OS datasets have been deleted.'\n      address syscall 'readdir' localrep'/'zigirep d.\n      do id = 1 to d.0\n        if left(d.id,1) = '.' then iterate\n        deldsn = Add_DSN_HLQ(word(d.id,1))\n        if dsnvalid(deldsn) = 'NO' then iterate\n        call outtrap 'x.'\n        address tso 'delete' deldsn\n        call outtrap 'off'\n      end\n    end\n    else delzd = 'The z/OS datasets were NOT deleted.'\n    if delco = 'N' then do\n      cmd = 'cd' localrep' && rm -rf 'zigirep\n      x = docmd(cmd)\n      delco = 'The local repository has been deleted from OMVS.'\n    end\n    else delco = 'The local repository was NOT deleted from OMVS.'\n    zerrlm = left(delcz,76) left(delcg,76) left(delco,76) ,\n      left(localrep'/'zigirep,76) left(delzd,76)\n    'setmsg msg(isrz003)'\n  end\n  else do\n    zerrsm = 'Retained.'\n    zerrlm = 'The local repository was NOT deleted from ZIGI, from' ,\n      'OMVS' localrep'/'zigirep', or from z/OS.'\n    'setmsg msg(isrz003)'\n  end\n  Return\n\n  /* ------------------------------------------ *\n  | Handle zigiprim panel primary command ssh   |\n  * ------------------------------------------ */\nhandle_zigiprim_ssh:\n  do forever\n    zcmd = null\n    'display panel(zigisshk)'\n    if rc > 0 then leave\n  end\n  Return\n\n  /* ------------------------------------------ *\n  | Handle zigiprim panel primary command sort  |\n  * ------------------------------------------ */\nhandle_zigiprim_sort:\n  zcmd = translate(zcmd)\n  defrsort = null\n  parse value zcmd with . skey sopt skey2 sopt2\n  if skey = null then do\n    call pfshow 'off'           /* make sure pfshow is off */\n    'Addpop row(4) column(6)'\n    'Display Panel(zigipsrt)'\n    'Rempop'\n    call pfshow 'reset'         /* restore pfshow setting */\n  end\n  if sopt = '' then\n  if lsopt = 'A' then sopt = 'D'\n  else sopt = 'A'\n  select\n    when abbrev('REPOSITORY',skey,1) = 1 then\n    skey = 'zigirep'\n    when abbrev('CATEGORY',skey,1) = 1 then\n    skey = 'zigicat'\n    when abbrev('PREFIX',skey,1) = 1 then\n    skey = 'pdshlq'\n    when abbrev('LAST',skey,1) = 1 then\n    skey = 'sortdate'\n    when abbrev('DATE',skey,1) = 1 then\n    skey = 'sortdate'\n    otherwise skey = 'zigirep'\n  end\n  select\n    when abbrev('REPOSITORY',skey2,1) = 1 then\n    skey2 = 'zigirep'\n    when abbrev('CATEGORY',skey2,1) = 1 then\n    skey2 = 'zigicat'\n    when abbrev('PREFIX',skey2,1) = 1 then\n    skey2 = 'pdshlq'\n    when abbrev('LAST',skey2,1) = 1 then\n    skey2 = 'sortdate'\n    when abbrev('DATE',skey2,1) = 1 then\n    skey2 = 'sortdate'\n    otherwise nop\n  end\n  if pos('zigirep',skey skey2)  > 0\n  then srr = 'white'\n  else srr = 'blue'\n  if pos('zigicat',skey skey2)  > 0\n  then src = 'white'\n  else src = 'blue'\n  if pos('pdshlq',skey skey2)   > 0\n  then srp = 'white'\n  else srp = 'blue'\n  if pos('sortdate',skey skey2) > 0\n  then srl = 'white'\n  else srl = 'blue'\n  if left(sopt,1) = 'D' then sopt = 'D'\n  else sopt = 'A'\n  if skey2 /= null then do\n    if left(sopt2,1) = 'D' then sopt2 = 'D'\n    else sopt2 = 'A'\n  end\n  defrsort = skey',c,'sopt\n  if skey2 /= null then\n  defrsort = defrsort','skey2',c,'sopt2\n  'tbsort zigirepo fields('defrsort')'\n  lsopt = sopt\n  'vput (defrsort srr src srp srl) profile'\n  Return\n\n  /* ------------------------------------------ *\n  | Handle zigiprim panel primary command local |\n  * ------------------------------------------ */\nhandle_zigiprim_local:\n  if zigtitle = 'Offline'\n  then do\n    zigtitle = '(ZIGI' ver')'\n    zigi_offline = 0\n  end\n  else do\n    zigtitle = 'Offline'\n    zigi_offline = 1\n  end\n  'vput (zigtitle)'\n  Return\n\n  /* ------------------------------------------- *\n  | Handle zigiprim panel primary command clone  |\n  * ------------------------------------------- */\nhandle_zigiprim_clone:\n  encoding = null\n  call Clone_Repo\n  zsel = null\n  Return\n\n  /* ------------------------------------------- *\n  | Handle zigiprim panel primary command config |\n  * ------------------------------------------- */\nhandle_zigiprim_config:\n  do forever\n    zcmd = null\n    'vget (mgen pnsdef) profile'\n    sl = mgen()\n    'display panel(zigiset)'\n    'vput (mgen pnsdef) profile'\n    call update_config\n    if rc = 0 | rc = 8 then leave\n  end\n  Return\n\n\n  /* ------------------------------------------- *\n  | Handle zigiprim panel primary command create |\n  * ------------------------------------------- */\nhandle_zigiprim_create:\n  x = Create_Repo()\n  crflag = 1\n  if x = 0 then do\n    zcmd = 'ADDDSN'\n    call work_with_repo\n    zsel = null\n  end\n  Return\n\n  /* ------------------------------------------- *\n  | Handle zigiprim panel primary command find   |\n  * ------------------------------------------- */\nhandle_zigiprim_find:\n  fstring = translate(word(zcmd,2))\n  zcmd = null\n  find = null\n  fwrap = 0\n  if fstring = null then do\n    call pfshow 'off'           /* make sure pfshow is off */\n    'Addpop row(4) column(6)'\n    'Display Panel(zigifind)'\n    drc = rc\n    'rempop'\n    call pfshow 'reset'         /* restore pfshow setting */\n    if drc > 0 then find = null\n    fstring = find\n  end\n  if fstring /= null then do\n    rowcnt = 0\n    'tbtop zigirepo'\n    if rfs > 0 then do\n      'tbskip zigirepo number('rfs')'\n      rowcnt = rfs\n    end\n    do forever\n      'tbskip zigirepo'\n      if rc > 0 then do\n        if rfs > 0 then do\n          rfs = 0\n          'tbtop zigirepo'\n          'tbskip zigirepo'\n          rowcnt = 0\n          fwrap = 1\n        end\n        else do\n          zerrsm = 'Not Found'\n          zerrlm = fstring 'not found.'\n          'setmsg msg(isrz003)'\n          Return\n        end\n      end\n      rowcnt = rowcnt + 1\n      'tbget zigirepo'\n      if pos(fstring,translate(reponame pdshlq zigicat)) > 0 then do\n        repo_top = rowcnt\n        if fwrap = 1\n        then zerrsm = 'Wrapped.'\n        else zerrsm = 'Found.'\n        zerrlm = fstring 'found in row' rowcnt + 0\n        'setmsg msg(isrz003)'\n        Return\n      end\n    end\n  end\n  Return\n\n  /* ------------------------------------------- *\n  | Handle zigiprim panel primary command select |\n  * ------------------------------------------- */\nhandle_zigiprim_select:\n  x = debug('Selecting repo via command:'zcmd)\n  zerrsm = null\n  fstring = word(zcmd,2)\n  zcmd = null\n  if fstring = null then do\n    call pfshow 'off'           /* make sure pfshow is off */\n    'addpop row(3) column(4)'\n    'display panel(zigisel)'\n    drc = rc\n    'rempop'\n    call pfshow 'reset'         /* restore pfshow setting */\n    if fstring = null then drc = 4\n    if drc > 0 then  do\n      zerrsm = 'Canceled.'\n      zerrlm = 'Select canceled.'\n      'setmsg msg(isrz003)'\n    end\n  end\n  if zerrsm = null then do\n    'tbtop zigirepo'\n    do forever\n      'tbskip zigirepo'\n      if rc > 0 then do\n        zerrsm = 'Not Found'\n        zerrlm = fstring 'repository not found. Verify the spelling and' ,\n          'case.'\n        'setmsg msg(isrz003)'\n        return\n      end\n      if translate(fstring) /= translate(reponame) then iterate\n      'tbget zigirepo'\n      if defcpush = 'Y' then zpush = 'Y'\n      else zpush = 'N'\n      zcmd = null\n      call select_repo\n      parse value '' with zsel zcmd\n      return\n    end\n  end\n  Return\n\n  /* ============================================================== */\n  /* ======== repo handling      ================================== */\n  /* ============================================================== */\n\n  /* --------------------------------- *\n  | Work with the selected repository |\n  * --------------------------------- */\nWork_With_Repo:\n  arg wwr_opt\n  /* -------------------------------------------------- *\n  | WWR_init will also call update_metadata             |\n  | check command will call work_with_repo recursively  |\n  | with check_flag = 1 to force recheck of ispf dsns   |\n  | If called with option then init and then return     |\n  * -------------------------------------------------- */\n  call WWR_init\n  if wwr_opt /= null then return\n  /* -------------------------------- *\n  | Process the Repository Data Sets |\n  * -------------------------------- */\n  zigi_changed = 0\n  do forever\n    call WWR_display_zigirepo\n    if result > 4 then return\n    repo_ztdsels = ztdsels\n    drop so. se.\n\n    /* translate primary command to upper case */\n    zcmd = translate(zcmd)\n\n    call WWR_handle_options\n\n    /* -------------- *\n    | Process a Find |\n    * -------------- */\n    if zcmd = 'RFIND' then do\n      zcmd = 'FIND' fstring\n      rfs  = rowcnt\n    end\n    else rfs = 0\n    if abbrev('FIND',word(zcmd,1),1) = 1 then call WWR_handle_find\n\n    if abbrev('FLOW',word(zcmd,1),2) = 1 then call WWR_handle_flow\n\n    /* handle other zcmds */\n    if zcmd /= null then\n    Select\n      When abbrev(\"CHECK\",zcmd,3) = 1 then call WWR_handle_check\n      When abbrev('BRANCH',zcmd,2) = 1 then call WWR_handle_branch\n      When abbrev('CONVREPO',zcmd,4) = 1 then call WWR_handle_convrepo\n      /* ----------------- *\n      | Git command prompt |\n      * ------------------ */\n      When abbrev('GITCMD',zcmd,4) = 1 then\n      'Select cmd(%zigigcmd)'\n      When abbrev('GITHELP',word(zcmd,1),4) = 1 then\n      Address TSO '%githelp' subword(zcmd,2)\n      When abbrev('GITLOG',zcmd,2) = 1 then call do_gitlog\n      When abbrev('INFO',zcmd,2) = 1 then call WWR_handle_info\n      When abbrev('SET',zcmd,1) = 1 then call do_rset\n      /* ---------------------------- *\n      | View (UDList) the repository |\n      * ---------------------------- */\n      When abbrev('VIEW',zcmd,1) = 1 then\n      'SELECT PGM(ISRDSLST) PARM(UDL' localrep'/'zigirep') SUSPEND'\n      When abbrev('MERGE',zcmd,2) = 1 then call WWR_handle_merge\n      When abbrev('NETWORK',zcmd,2) = 1 then call WWR_handle_network\n      When abbrev('PUSH',zcmd,2) = 1 then call WWR_handle_push\n      When abbrev('PULL',zcmd,3) = 1 then call WWR_handle_pull\n      When abbrev('FETCH',zcmd,2) = 1 then call WWR_handle_fetch\n      When abbrev('REPLACE',zcmd,3) = 1 then call WWR_handle_replace\n      When abbrev('EXTRACT',zcmd,2) = 1 then call WWR_handle_extract\n      When abbrev('STASH',zcmd,4) = 1 then call stash_it\n      When zcmd = 'STASHL' then call stash_list\n      When abbrev('SNAPSHOT',zcmd,2) = 1 then call WWR_handle_snapshot\n      When abbrev('TAG',zcmd,2) = 1 then call WWR_handle_tag\n      When abbrev('TAGLIST',zcmd,2) = 1 then call do_taglist\n      When abbrev('ADDDSN',zcmd,3) = 1 then call WWR_handle_adddsn\n      When abbrev('ADDALL',zcmd,4) = 1 then call WWR_handle_addall\n      When abbrev('STATUS',zcmd,2) = 1 then call do_status\n      When abbrev('GREP',zcmd,2) = 1 then call WWR_handle_grep\n      When abbrev('COMMIT',zcmd,3) = 1 then call do_commit\n      When abbrev('REMOTE',zcmd,3) = 1 then call WWR_handle_remote\n      When abbrev('FLOWSEL',zcmd,5) = 1 then call WWR_handle_flowsel\n      When abbrev('FLOWGO',zcmd,5) = 1 then call WWR_handle_flowgo\n      When abbrev('FLOWEND',zcmd,5) = 1 then call WWR_handle_flowend\n      when zcmd = 'VIEWD' then call view_debug\n      Otherwise do\n        zerrsm = 'Unknown'\n        zerrlm = zcmd 'is not a recognized command.'\n        'setmsg msg(isrz003)'\n      end\n    end\n\n    if zsel = '/' then do\n      call pfshow 'off'           /* make sure pfshow is off */\n      'Addpop row(3) column(4)'\n      'Display Panel(zigirrep)'\n      'rempop'\n      call pfshow 'reset'         /* restore pfshow setting */\n    end\n\n    /* flag for USS file or ZOS dataset */\n    zosflg = 1\n    if filetype = '(D)' then do\n      if zsel = 'B' then zsel = 'S'\n      if zsel = 'V' then zsel = 'S'\n    end\n\n    /* -------------------------------- *\n    | Handle the linecommands           |\n    * -------------------------------- */\n    if zsel /= null then\n    Select\n      when zsel = 'D' then call WWR_handle_lcmd_d\n      When zsel = 'H' then call WWR_handle_lcmd_h\n      When zsel = 'B' then call WWR_handle_lcmd_b\n      When zsel = 'V' then call WWR_handle_lcmd_v\n      When zsel = 'RN' then call WWR_handle_lcmd_rn\n      When zsel = 'RM' then call WWR_handle_lcmd_rm\n      When zsel = 'S' & left(fulldsn,1) /= \"'\" then\n      call WWR_handle_lcmd_s_omvs\n      When zsel = 'S' & zosflg = 1 then\n      call WWR_handle_lcmd_s_mvs\n      When zsel = 'A' then\n      call WWR_handle_lcmd_a\n      When zsel = 'U' then call WWR_handle_lcmd_u\n      When zsel = 'Z' then call WWR_handle_lcmd_z\n      Otherwise do\n        zerrsm = 'Invalid.'\n        zerrlm = zsel 'is not a valid selection value. Review the' ,\n          'ISPF Tutorial using F1 for available line selection' ,\n          'options.'\n        'setmsg msg(isrz003)'\n      end\n    end\n    if zigi_changed = 1 then\n    if ztdsels = 1 then do\n      'tbend' rtbl\n      rtbl_open = 0\n      call work_with_repo\n      zigi_changed = 0\n    end\n  end\n  if zigi_changed = 1 then call work_with_repo\n  return\n\n  /* ============================================================== */\n  /* ======== repo handling support functions ===================== */\n  /* ============================================================== */\n\nWWR_init:\n  parse value '' with dsn dsnstat zsel\n  list_top = 0\n  crflag = 0\n  remc = 'NO'\n  x = debug('Working with Repo:' zigirep)\n  readonly = check_read_only()\n  'vput (readonly) shared'\n  call update_repo_metadata\n  if cltime /= null then do\n    zerrsm  = 'Clone:' cltime\n    zerrlm  = left('Cloning completed for:' zigirep,76) ,\n      'Total time to clone was:' cltime\n    'setmsg msg(isrz003)'\n    cltime = null\n  end\n  'vput (localrep zigirep) shared'\n  'tbsort' rtbl 'Fields(dsn,c,a)'\n  'tbtop' rtbl\n  repo_ztdsels = 0\n  rtop = 0\n  repo_save = 0\n  Return\n\nWWR_display_zigirepo:\n  parse value '' with zsel row\n  ztdsels = repo_ztdsels\n  if zcmd /= 'ADDDSN' then do\n    parse value '' with zsel zcmd row zcmd\n    if ztdsels > 1\n    then 'TBdispl' rtbl\n    else do\n      zigpass = 'PASSTHRU'\n      'vput (zigpass) shared'\n      'tbtop' rtbl\n      'tbskip' rtbl 'Number('rtop')'\n      'TBdispl' rtbl 'Panel(zigirepo)'\n      rtop = ztdtop\n    end\n    trc = rc\n    zigpass = null\n    'vput (zigpass) shared'\n    if trc > 4 then do\n      'tbend' rtbl\n      rtbl_open = 0\n      Return trc\n    end\n  end\n  Return 0\n\nWWR_handle_options:\n  /* if no row selected and point of shoot default is P */\n  /* show options panel or select pointed row and show  */\n  /* options for that row                               */\n  if ztdsels = 0 then\n  if pnsdef = 'P' then do\n    if row = 0 then zcmd = 'O'\n    if row > 0 then zsel = '/'\n  end\n\n  if row = 0 then zsel = null\n  if row <> null then\n  if row > 0 then do\n    \"TBTop \" rtbl\n    \"TBSkip\" rtbl \"Number(\"row\")\"\n  end\n\n  if pos('.',zcmd) > 0 then\n  parse value zcmd with x'.'zcmd\n  if zcmd = 'O' then do\n    call pfshow 'off'           /* make sure pfshow is off */\n    'Addpop row(4) column(10)'\n    'Display Panel(zigiorep)'\n    'rempop'\n    call pfshow 'reset'         /* restore pfshow setting */\n  end\n  Return\n\nWWR_handle_find:\n  fstring = translate(word(zcmd,2))\n  zcmd = null\n  find = null\n  rwrap = 0\n  if fstring = null then do\n    call pfshow 'off'           /* make sure pfshow is off */\n    'Addpop row(4) column(6)'\n    'Display Panel(zigifind)'\n    drc = rc\n    'rempop'\n    call pfshow 'reset'         /* restore pfshow setting */\n    if drc > 0 then find = null\n    fstring = find\n  end\n  rowcnt = 0\n  'tbtop' rtbl\n  if rfs > 0 then do\n    'tbskip' rtbl 'number('rfs')'\n    rowcnt = rfs\n  end\n  do forever\n    'tbskip' rtbl\n    if rc > 0 then do\n      if rfs > 0 then do\n        rfs = 0\n        'tbtop' rtbl\n        'tbskip' rtbl\n        rowcnt = 0\n        rwrap = 1\n      end\n      else do\n        zerrsm = 'Not Found'\n        zerrlm = fstring 'not found.'\n        'setmsg msg(isrz003)'\n        leave\n      end\n    end\n    rowcnt = rowcnt + 1\n    'tbget' rtbl\n    if pos(fstring,translate(fulldsn)) > 0 then do\n      rtop = rowcnt\n      if rwrap = 0\n      then zerrsm = 'Found.'\n      else zerrsm = 'Wrapped.'\n      zerrlm = fstring 'found in row' rowcnt '-' fulldsn\n      'setmsg msg(isrz003)'\n      leave\n    end\n  end\n  Return\n\n  /* -------- *\n  | zigiFlow |\n  * -------- */\nWWR_handle_flow:\n  if readonly = 1 then do\n    zerrsm = 'Invalid.'\n    zerrlm = 'Flow is not supported for ReadOnly Repositories.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  call pfshow 'off'           /* make sure pfshow is off */\n  'addpop row(3) column(4)'\n  'display panel(zigiflow)'\n  drc = rc\n  'rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  if drc > 0 then zcmd = null\n  Return\n\nWWR_handle_check:\n  check_flag = 1\n  call work_with_repo\n  zsel = null\n  Return\n\n  /* -------------------------------- *\n  | Branch dialog - create or change |\n  * -------------------------------- */\nWWR_handle_branch:\n  if readonly = 1 then do\n    zerrsm = 'Invalid.'\n    zerrlm = 'Branching is not supported for ReadOnly Repositories.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  x = check_clean()\n  if x = 'NO' then do\n    zs1 = 'Cannot checkout branch as it is not clean.'\n    zs2 = 'Use the Status command and fix then try again.'\n    call pfshow 'off'           /* make sure pfshow is off */\n    'Addpop row(4) column(8)'\n    'Display Panel(zigipop)'\n    'Rempop'\n    call pfshow 'reset'         /* restore pfshow setting */\n    return\n  end\n  if words(save_zigirep) > 0 then do\n    zerrsm = 'Invalid.'\n    zerrlm = 'Branch is not supported in subdirectories.'\n    'setmsg msg(isrz003)'\n  end\n  else call Branch_it\n  Return\n\n  /* ----------------------- *\n  | Convert a non-ZIGI Repo |\n  * ----------------------- */\nWWR_handle_convrepo:\n  parse value '' with zcmd ans\n  'display panel(zigivcnv)'\n  drc = rc\n  if ans /= 'Y' then drc = 4\n  if drc > 0 then do\n    zerrsm = 'Canceled.'\n    zerrlm = 'Conversion canceled.'\n    'setmsg msg(isrz003)'\n  end\n  else do\n    if branch = 'master' then do\n      convdir = localrep'/'zigirep\n      cmd = 'cd' convdir '&& git checkout -b zigi-master'\n      x = docmd(cmd)\n    end\n    call convert_repo\n    x = docmd(cmd)\n    defcpush = 'N'\n    call work_with_repo\n  end\n  Return\n\n  /* -------------------------------- *\n  | View summary info of repository  |\n  * -------------------------------- */\nWWR_handle_info:\n  call pfshow 'off'           /* make sure pfshow is off */\n  'addpop row(3) column(2)'\n  'display panel(zigiinfo)'\n  'rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  Return\n\n  /* -------------------------------- *\n  | Merge a branch into current branch|\n  * -------------------------------- */\nWWR_handle_merge:\n  zerrsm = null\n  if readonly = 1 then do\n    zerrsm = 'Invalid.'\n    zerrlm = 'Merge is not supported for ReadOnly Repositories.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  if words(save_zigirep) > 0 then do\n    zerrsm = 'Invalid.'\n    zerrlm = 'Merge is not supported in subdirectories.'\n    'setmsg msg(isrz003)'\n  end\n  if zerrsm = null then call Merge_it\n  check_flag = 1\n  call work_with_repo\n  zsel = null\n  Return\n\n  /* -------------------------------- *\n  | Show the network graph            |\n  * -------------------------------- */\nWWR_handle_network:\n  cmd = 'cd' localdir' && git log --graph --oneline'\n  cmd = cmd '--format=\"%h %<(50,trunc)%f\"'\n  x = docmd(cmd)\n  vtype = 'graph'\n  'vput (vtype) shared'\n  if so.0 + se.0 > 1\n  then call view_std 'B' 'V'\n  vtype = null\n  'vput (vtype) shared'\n  Return\n\n  /* -------------------------------- *\n  | Push current branch to origin    |\n  * -------------------------------- */\nWWR_handle_push:\n  if zigi_offline = 0 then call do_push\n  else do\n    zerrsm = 'Offline.'\n    zerrlm = 'Push is not allowed when offline.'\n    'Setmsg msg(isrz003)'\n  end\n  Return\n\n  /* --------------------------------------------------------- *\n  | Pull latest version of remote current branch from origin  |\n  * --------------------------------------------------------- */\nWWR_handle_pull:\n  if zigi_offline = 1 then do\n    zerrsm = 'Offline.'\n    zerrlm = 'Pull is not allowed when offline.'\n    'Setmsg msg(isrz003)'\n  end\n  else do\n    call pop 'Pulling from remote'\n    /* get the current commit hash */\n    cmd = 'cd' localdir '&& git rev-parse HEAD'\n    x = docmd(cmd)\n    rev_head = so.1    /* save the current commit hash */\n\n    cmd = 'cd' localdir' && git pull -v'\n    x = docmd(cmd)\n    if x > 0 then call view_std 'B'\n    parse value '' with pulldsns pullmems. deletes.\n    deletes.0 = 0\n    pulled = 0\n    do pi = 1 to so.0\n      if left(so.pi,1) /= ' ' then iterate\n      if pos(' changed,',so.pi) > 0 then do\n        pullmsg = so.pi\n        pulled = 1\n        iterate\n      end\n      if word(so.pi,1) = 'rename' then do\n        if pos('/',so.pi) > 0 then do\n          parse value so.pi with . dd'/{'dm '=>' nm'}' .\n          dc = deletes.0 + 1\n          deletes.dc = strip(dd)'/'strip(dm)\n          deletes.0 = dc\n          if wordpos(dd,pulldsns) = 0 then do\n            pulldsns = pulldsns dd\n            pullmems.dd = nm\n          end\n          else pullmems.dd = pullmems.dd nm\n        end\n        else do\n          parse value so.pi with . dd '=>' nd .\n          dc = deletes.0 + 1\n          deletes.dc = strip(dd)\n          deletes.0 = dc\n          if wordpos(nd,pulldsns) = 0 then\n          pulldsns = pulldsns nd\n        end\n      end\n      if word(so.pi,1) = 'delete' then\n      if word(so.pi,2) = 'mode' then do\n        delds = word(so.pi,4)\n        dhit = 1\n        if left(delds,1) = '.' then dhit = 0\n        if dhit = 1 then do\n          dc = deletes.0 + 1\n          if pos('/',delds) > 0 then do\n            parse value delds with dd'/'dm\n            if pos('.',dm) > 0 then do\n              parse value dm with dm'.'.\n              delds = dd'/'translate(dm)\n            end\n          end\n          deletes.dc = delds\n          deletes.0 = dc\n          if pos('/',delds) = 0 then do\n            wp = wordpos(delds,pulldsns)\n            pulldsns = delword(pulldsns,wp,1)\n          end\n          else do\n            parse value delds with dd'/'dm\n            ext = zdsn.dd\n            if ext = null\n            then wp = wordpos(dm,pullmems.dd)\n            else do\n              dm = lower(dm'.'ext)\n              wp = wordpos(dm,pullmems.dd)\n            end\n            pullmems.dd = delword(pullmems.dd,wp,1)\n          end\n        end\n      end\n      if left(so.pi,5) = 'From' then leave\n      pidsn = word(so.pi,1)\n      if left(pidsn,1) = '.' then iterate\n      parse value pidsn with pidsn'/'pimem\n      if wordpos(pidsn,pulldsns) = 0 then do\n        pulldsns = pulldsns pidsn\n        pullmems.pidsn = pimem\n      end\n      else pullmems.pidsn = pullmems.pidsn pimem\n    end\n    /* ------------------------------------------------- *\n    | Validate all the Pulldsns and remove if not valid |\n    * ------------------------------------------------- */\n    do ip = words(pulldsns) to 1 by -1\n      w = word(pulldsns,ip)\n      if dsnvalid(w) = 'OK' then iterate\n      pulldsns = delword(pulldsns,ip,1)\n    end\n    /* create the ispf variable with member names for\n    the dataset using the dataset offset in pulldsns\n    for the variable suffix */\n    if qualignr = 0\n    then delhlq = pdshlq\n    else do\n      delhlq = translate(pdshlq,' ','.')\n      if qualignr /= '*' then\n      delhlq = subword(delhlq,1,qualignr)\n      delhlq = translate(delhlq,'.',' ')\n    end\n    do zz = 1 to words(pulldsns)\n      zd = word(pulldsns,zz)\n      zw = words(pullmems.zd)\n      ldsn = \"'\"delhlq\".\"zd\"'\"\n      x = listdsi(ldsn \"dir\")\n      /* check if a PDSE and bypass the full Replace or if not\n      a PDSE then check of more than 25% of members being\n      updated and if so then nullify the member list so a full\n      Replace will occur for the dataset */\n      if x = 0 then\n      if sysmembers /= null then\n      if sysadirblk /= 'NO_LIM' then\n      if sysmembers/zw < 4 then pullmems.zd = ''\n      interpret 'zv'zz '= (pullmems.zd)'\n      'vput zv'zz\n    end\n    if pulldsns /= null then do\n      call Replace localrep zigirep pdshlq qualignr pulldsns\n      if replace_state = 1 then do\n        call reverse_pull\n        return\n      end\n      'Verase pulldsns Both'\n      call outtrap 'x.'\n      if deletes.0 > 0 then do dc = 1 to deletes.0\n        if pos('/',deletes.dc) = 0\n        then do\n          delds =  \"'\"pdshlq\".\"deletes.dc\"'\"\n          dm.dc = delds\n          Address TSO 'Delete' delds\n          cmd = 'cd' localrep'/'zigirep\n          cmd = cmd '&& rm' deletes.dc\n        end\n        else do\n          parse value deletes.dc with delds'/'mem\n          if pos('.',mem) > 0\n          then parse value mem with m'.'.\n          else m = mem\n          dm.dc = \"'\"pdshlq\".\"delds\"(\"m\")'\"\n          call delete_member \"'\"pdshlq\".\"delds\"'\" m\n          cmd = 'cd' localrep'/'zigirep'/'delds\n          cmd = cmd '&& rm' mem\n          x = docmd(cmd)\n        end\n      end\n      call outtrap 'off'\n      do id = 1 to deletes.0\n        so.id = 'Deleted:' dm.id\n      end\n      so.0 = deletes.0\n      se.0 = 0\n      call view_std\n      call update_repo_metadata\n    end\n    else do\n      if pulled = 0 then do\n        zerrsm = 'Nothing'\n        zerrlm = 'Nothing to pull.'\n        'setmsg msg(isrz003)'\n      end\n      else call update_repo_metadata\n    end\n    if pulled > 0 then do\n      zerrsm = 'Successful.'\n      zerrlm = left('Pull was a success.',76) pullmsg\n      'setmsg msg(isrz003)'\n    end\n  end\n  Return\n\n  /* -------------------------------- *\n  | Fetch Remote Repo Updates        |\n  * -------------------------------- */\nWWR_handle_fetch:\n  zs1 = 'Performing the git fetch . . .'\n  zs2 = 'Please standby'\n  call do_popup\n  cmd = 'cd' localrep'/'zigirep\n  x = docmd(cmd '&& git fetch && git status')\n  fetch_flag = 1\n  branch = word(so.1,3)\n  if so.0 > 1 then call Update_Status\n  else do\n    parse value '' with bstat baction\n  end\n  Return\n\n  /* -------------------------------- *\n  | Replace z/OS datasets            |\n  * -------------------------------- */\nWWR_handle_replace:\n  if words(save_zigirep) > 0 then do\n    zerrsm = 'Invalid.'\n    zerrlm = 'Replace is not supported in subdirectories.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  if readonly = 1 then do\n    zerrsm = 'Invalid.'\n    zerrlm = 'Replace is not supported for ReadOnly Repositories.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  do\n    zcmd = null\n    refa = 'NO'\n    call pfshow 'off'           /* make sure pfshow is off */\n    'Addpop row(4) column(12)'\n    'Display Panel(zigipopr)'\n    prc = rc\n    'Rempop'\n    call pfshow 'reset'         /* restore pfshow setting */\n    if prc > 0 then refa = 'NO'\n    if refa = 'YES' then do\n      call Replace localrep zigirep pdshlq qualignr\n      if replace_state = 1 then return\n      call update_repo_metadata\n    end\n    else do\n      zerrsm = 'Canceled.'\n      zerrlm = 'Replace canceled.'\n      'setmsg msg(isrz003)'\n    end\n  end\n  Return\n\n  /* -------------------------------- *\n  | Extract/Rollback a Commit        |\n  * -------------------------------- */\nWWR_handle_extract:\n  if words(save_zigirep) > 0 then do\n    zerrsm = 'Invalid.'\n    zerrlm = 'Extract is not supported in subdirectories.'\n    'setmsg msg(isrz003)'\n  end\n  else call do_extract\n  Return\n\n  /* -------------------------------- *\n  | Snapshot the current repository  |\n  * -------------------------------- */\nWWR_handle_snapshot:\n  do forever\n    parse value '' with zcmd path snaphlq gtag sans\n    'display panel(zigisnap)'\n    if rc > 0 then leave\n    call pfshow 'off'           /* make sure pfshow is off */\n    'Addpop row(4) column(10)'\n    'Display Panel(zigisnpq)'\n    drc = rc\n    'rempop'\n    call pfshow 'reset'         /* restore pfshow setting */\n    if drc > 0 then leave\n    if sans = 'Y' then do\n      cmd = 'cd' localrep'/'zigirep\n      cmd = cmd '&& git tag' gtag\n      zs1 = 'Performing the git tag'\n      zs2 = 'Please standby'\n      call do_popup\n      x = docmd(cmd)\n      if path /= null then do\n        zs1 = 'Copying' localrep'/'zigirep\n        zs2 = 'To:' path\n        call do_popup\n        cmd = 'cp -rp' localrep'/'zigirep path\n        x = docmd(cmd)\n        if x > 0 then call view_std 'B'\n        zs1 = 'Performing the cleanup of git files'\n        zs2 = 'Please standby'\n        call do_popup\n        cmd = 'cd' path\n        cmd = cmd '&& rm .gitattributes && rm -rf .git && rm -rf .zigi'\n        x = docmd(cmd)\n        if x > 0 then call view_std 'B'\n        /*  create a git log in the snapshot directory */\n        cmd = 'cd' localrep'/'zigirep\n        cmd = cmd \"&& echo 'Git Tag for this Snapshot is:' >\" ,\n          path'gitlog.txt'\n        cmd = cmd '&& git tag -l' gtag '>>' path'gitlog.txt'\n        cmd = cmd \"&& echo ' ' >>\" path'gitlog.txt'\n        cmd = cmd \"&& echo 'Recent Git Log Entries:' >>\" path'gitlog.txt'\n        cmd = cmd \"&& echo ' ' >>\" path'gitlog.txt'\n        cmd = cmd '&& git log -n 10'\n        cmd = cmd '>>' path'gitlog.txt'\n        x = docmd(cmd)\n        if x > 0 then call view_std 'B'\n      end\n\n      save_hlq = pdshlq\n      call Replace localrep zigirep snaphlq '*'\n      pdshlq = save_hlq\n\n      /* now view both the omvs directory and snaphlq */\n      sans = null\n      call pfshow 'off'           /* make sure pfshow is off */\n      'Addpop row(4) column(10)'\n      'Display Panel(zigisnpr)'\n      drc = rc\n      'rempop'\n      call pfshow 'reset'         /* restore pfshow setting */\n      if drc > 0 then sans = 'N'\n      if sans = 'N' then do\n        zerrsm = 'Completed.'\n        zerrlm = 'Snapshot completed - tag:' gtag\n        'setmsg msg(isrz003)'\n        leave\n      end\n      if path /= null then\n      'SELECT PGM(ISRDSLST) PARM(UDL' path') SUSPEND'\n      \"SELECT PGM(ISRDSLST) PARM(DSL '\"snaphlq\"') SUSPEND\"\n      zerrsm = 'Completed.'\n      zerrlm = 'Snapshot completed - tag:' gtag\n      'setmsg msg(isrz003)'\n      leave\n    end\n  end\n  Return\n\n  /* --------------------------------- *\n  | Tag the repo with an annotated tag |\n  * --------------------------------- */\nWWR_handle_tag:\n  parse value '' with tagid tagmsg\n  call pfshow 'off'           /* make sure pfshow is off */\n  'addpop row(4) column(6)'\n  'display panel(zigitag)'\n  drc = rc\n  'rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  if drc = 0 then do\n    if tagmsg = null then\n    cmd = 'git tag' tagid\n    else cmd = 'git tag -a' tagid '-m \"'tagmsg'\"'\n    cmd = 'cd' localrep'/'zigirep '&&' cmd\n    if pos('no remote',remote1) = 0\n    then if zigi_offline = 0\n    then cmd = cmd '&& git push origin' tagid\n    cmd = cmd '&& git show' tagid\n    x = docmd(cmd)\n    if x = 0 then do\n      zerrsm = 'Tagged.'\n      zerrlm = tagid 'has been tagged to the current' ,\n        'repository.'\n      'setmsg msg(isrz003)'\n    end\n    else call view_std 'B'\n  end\n  Return\n\n  /* --------------------------------------------------------- *\n  | Add a PDS or a Sequential File to \"Working Directory\"     |\n  * --------------------------------------------------------- */\nWWR_handle_adddsn:\n  if words(save_zigirep) > 0 then do\n    zerrsm = 'Invalid.'\n    zerrlm = 'ADDDSN is not supported in subdirectories.'\n    'setmsg msg(isrz003)'\n  end\n  else call Add_Dataset\n  Return\n\n  /* --------------------------------- *\n  | Git add all modified or untracked |\n  * --------------------------------- */\nWWR_handle_addall:\n  'tbtop' rtbl\n  x = debug('ADDALL started:' zigirep)\n  do forever\n    'tbskip' rtbl\n    if rc > 0 then leave\n    hit = 0\n    if pos('\u00ddM',dsnstat) > 0 then hit = 1\n    if pos('M\u00a8',dsnstat) > 0 then hit = 1\n    if pos('Untracked',dsnstat) > 0 then hit = 1\n    if hit = 0 then iterate\n    call git_add\n  end\n  cmd = 'cd' localrep'/'zigirep\n  cmd = cmd '&& git add .'\n  x = docmd(cmd)\n  call update_repo_metadata\n  zcmd = null\n  x = debug('ADDALL completed' zigirep)\n  Return\n\n  /* -------------------------------- *\n  | GIT GREP                         |\n  * -------------------------------- */\nWWR_handle_grep:\n  parse value  '' with zcmd grepstr grepopt\n  grepdir = localrep'/'zigirep\n  gds = 'Dataset/File'\n  call do_grep grepdir\n  Return\n\n  /* -------------------------------- *\n  | Add/replace remote URI (origin)  |\n  * -------------------------------- */\nWWR_handle_remote:\n  zcmd = null\n  origin = null\n  'display panel(zigiremo)'\n  if rc > 0 then do\n    zerrsm = 'Canceled.'\n    zerrlm = 'Remote update canceled.'\n    'setmsg msg(isrz003)'\n  end\n  else do\n    'tbmod zigirepo order'\n    'TBSAVE zigirepo REPLCOPY LIBRARY('isptabl')'\n    parsedURI = parseGitURI(origin)\n    parse var parsedURI user host port repo\n    if port /= 22 then extrabits = '-p 'port\n    else extrabits = null\n    cmd = 'touch 'home'/.ssh/known_hosts && '\n    cmd = cmd 'if ! grep 'host\n    cmd = cmd home'/.ssh/known_hosts >/dev/null;'\n    cmd = cmd 'then ssh-keyscan 'extrabits' -t rsa,dsa 'host\n    cmd = cmd ' 2>/dev/null >> 'home'/.ssh/known_hosts ;'\n    cmd = cmd 'fi'\n    x = docmd(cmd)\n    cmd = 'cd' localrep'/'zigirep\n    x = docmd(cmd '&& git remote add origin 'origin)\n    call View_std 'B'\n    cmd = 'cd' localrep'/'zigirep\n    if zigi_offline = 0 then do\n      x = docmd(cmd '&& git push -vu origin 'branch)\n      call View_std 'B'\n      gitcmd = 'git remote -v | sed -e \"s/\u00dd\u00dd:space:\u00a8\u00a8\\+/ /g\"'\n      x = docmd('cd 'localrep'/'zigirep' && 'gitcmd)\n      if so.0 > 0 then\n      remote1 = word(so.1,1)' 'word(so.1,2)\n      'tbmod zigirepo order'\n      'TBSAVE zigirepo REPLCOPY LIBRARY('isptabl')'\n    end\n    call update_repo_metadata\n  end\n  Return\n\n  /* -------------------------------- *\n  | Select a zigiflow to work on     |\n  * -------------------------------- */\nWWR_handle_flowsel:\n  x = check_clean()\n  if x = 'NO' then do\n    zerrsm = 'Not Clean'\n    zerrlm = \"Can't switch flows in dirty workspace\"\n    'setmsg msg(isrz003)'\n  end\n  else do\n    call flowselect\n  end\n  Return\n\n  /* -------------------------------- *\n  | Start a zigiflow                 |\n  * -------------------------------- */\nWWR_handle_flowgo:\n  x = check_clean()\n  if x = 'NO' then do\n    zerrsm = 'Not Clean'\n    zerrlm = \"Can't start flow in dirty workspace\"\n    'setmsg msg(isrz003)'\n  end\n  else do\n    call pfshow 'off'           /* make sure pfshow is off */\n    'Addpop row(3) column(4)'\n    'Display Panel(zigifgo)'\n    drc = rc\n    'rempop'\n    call pfshow 'reset'         /* restore pfshow setting */\n    if drc > 0 then do\n      zerrsm = 'Canceled.'\n      zerrlm = 'FlowGo was canceled.'\n      'setmsg msg(isrz003)'\n    end\n    else do\n      cmd = 'cd' localrep'/'zigirep\n      cmd = cmd || ' && git checkout master &&'\n      cmd = cmd || ' git checkout -b 'flowname\n      cmd = cmd || ' && git checkout -b zigiflow-'flowname\n      cmd = cmd || ' && git tag 'flowname\n      x = docmd(cmd)\n      call Replace localrep zigirep pdshlq qualignr\n      call update_repo_metadata\n    end\n  end\n  Return\n\n  /* -------------------------------- *\n  | Finish a zigiflow                |\n  * -------------------------------- */\nWWR_handle_flowend:\n  /* what flow are we in? */\n  cmd = 'cd' localrep'/'zigirep\n  cmd = cmd || ' && git rev-parse --abbrev-ref HEAD'\n  x = docmd(cmd)\n  currbranch = so.1\n  if substr(currbranch,1,8) = 'zigiflow' then do\n    /* We're in a zigiflow...continue */\n    x = check_clean()\n    if x = 'NO' then do\n      /* working dir not clean. abort */\n      zerrsm = 'Not Clean'\n      zerrlm = \"Can't finish flow. Uncommited changes\"\n      'setmsg msg(isrz003)'\n    end\n    else do\n      /* all looks good, let's merge to the feature */\n      flowname = substr(currbranch,10)\n      /* get the commit messages in */\n      cmd = 'cd' localrep'/'zigirep\n      cmd = cmd || ' && git log --pretty=format:%s'\n      cmd = cmd || ' 'flowname'...HEAD'\n      x = docmd(cmd)\n      m.1 = flowname': '\n      do prepcom = 1 to so.0\n        cid = prepcom + 1\n        m.cid = so.prepcom\n      end\n      m.0 = cid\n      /* execute the merge */\n      cmd = 'cd' localrep'/'zigirep\n      cmd = cmd || ' && git checkout 'flowname\n      cmd = cmd || ' && git merge --squash zigiflow-'flowname\n      call pfshow 'off'           /* make sure pfshow is off */\n      'Addpop row(3) column(4)'\n      'Display Panel(zigifend)'\n      drc = rc\n      'rempop'\n      call pfshow 'reset'         /* restore pfshow setting */\n      if drc > 0 then do\n        zerrsm = 'Canceled.'\n        zerrlm = 'FlowEnd canceled.'\n        'Setmsg msg(isrz003)'\n      end\n      else do\n        x = docmd(cmd)\n        /* perform the commit */\n        call do_commit 'x'\n        /* Make sure remote has the new branch */\n        cmd = 'cd' localrep'/'zigirep\n        cmd = cmd || ' && git push --set-upstream origin '\n        cmd = cmd || 'refs/heads/'flowname\n        x = docmd(cmd)\n        /* delete the work branch */\n        cmd = 'cd' localrep'/'zigirep\n        cmd = cmd || ' && git branch -D zigiflow-'flowname\n        x = docmd(cmd)\n        /* Get things updated */\n        call update_repo_metadata\n        call Replace localrep zigirep pdshlq qualignr\n      end\n    end\n  end\n  else do\n    /* error for when not in zigiflow */\n    zerrsm = 'No zigiflow'\n    zerrlm = \"You're not working in a zigiflow\"\n    'setmsg msg(isrz003)'\n  end\n  Return\n\n  /* -------------------------------- *\n  | Show the diff for the file       |\n  * -------------------------------- */\nWWR_handle_lcmd_d:\n  dtest = 0\n  if left(fulldsn,1) = \"'\" then do\n    x = listdsi(fulldsn)\n    if sysdsorg = 'PO' then do\n      zerrlm = 'Diff does not work on Partitioned Datasets'\n      zerrsm = 'Error.'\n      'setmsg msg(isrz003)'\n      dtest = 1\n    end\n  end\n  else if filetype = '(D)' then do\n    zerrlm = 'Diff does not work on directories'\n    zerrsm = 'Error.'\n    'setmsg msg(isrz003)'\n    dtest = 1\n  end\n  if dtest = 0 then do\n    cmd = 'cd' localrep'/'zigirep\n    x = docmd(cmd ' && git diff 'dsn)\n    if so.0 + se.0 > 0\n    then call View_std 'X' 'V'\n    else do\n      zerrsm = 'No Diff'\n      zerrlm = 'No differnce found.'\n      'Setmsg msg(isrz003)'\n    end\n  end\n  Return\n\n  /* -------------------------------- *\n  | Show the history for the file    |\n  * -------------------------------- */\nWWR_handle_lcmd_h:\n  htest = 0\n  if left(fulldsn,1) = \"'\" then do\n    x = listdsi(fulldsn)\n    if sysdsorg = 'PO' then do\n      zerrlm = 'History does not work on Partitioned Datasets'\n      zerrsm = 'Error.'\n      'setmsg msg(isrz003)'\n      htest = 1\n    end\n  end\n  if htest = 0 then\n  call do_history dsn\n  Return\n\n  /* -------------------------------- *\n  | Browse the file or list members  |\n  * -------------------------------- */\nWWR_handle_lcmd_b:\n  'control display save'\n  if left(fulldsn,1) = \"'\" then do\n    x = listdsi(fulldsn)\n    if sysdsorg = 'PO' then do\n      'LMInit Dataid(zigdid) Dataset('fulldsn')'\n      \"Memlist Dataid(\"zigdid\") Default(B)\"\n      drc = rc\n      \"LMfree Dataid(\"zigdid\")\"\n    end\n    else do\n      'Browse Dataset('fulldsn')'\n      drc = rc\n    end\n  end\n  else do\n    Address TSO 'Obrowse' localrep'/'zigirep'/'fulldsn\n    drc = rc\n  end\n  'control display restore'\n  if drc > 0 then 'setmsg msg(isrz003)'\n  Return\n\n  /* -------------------------------- *\n  | View the file or list members     |\n  * -------------------------------- */\nWWR_handle_lcmd_v:\n  'control display save'\n  if left(fulldsn,1) = \"'\" then do\n    x = listdsi(fulldsn)\n    if sysdsorg = 'PO' then do\n      'LMInit Dataid(zigdid) Dataset('fulldsn')'\n      \"Memlist Dataid(\"zigdid\") Default(V)\"\n      \"LMfree Dataid(\"zigdid\")\"\n    end\n    else 'View Dataset('fulldsn')'\n  end\n  else do\n    ofile = localrep'/'zigirep'/'fulldsn\n    'View File(ofile)'\n  end\n  'control display restore'\n  Return\n\n  /* ------------------------ *\n  | Rename the element in git|\n  | and OMVS and z/OS        |\n  * ------------------------ */\nWWR_handle_lcmd_rn:\n  if readonly = 1 then do\n    zerrsm = 'Invalid.'\n    zerrlm = 'Rename (RN) is not supported for ReadOnly Repositories.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  newdsn = fulldsn\n  fulldsnq = fulldsn\n  if dsnvalid(fulldsn) = 'OK' then zos = 1\n  else zos = 2\n  do forever\n    call pfshow 'off'           /* make sure pfshow is off */\n    'Addpop row(4) column(6)'\n    if zos = 1 then\n    'display panel(zigirena)'\n    else\n    'display panel(zigireno)'\n    drc = rc\n    'rempop'\n    call pfshow 'reset'         /* restore pfshow setting */\n    if drc > 0 then leave\n    if zos = 1 then do\n      x = listdsi(newdsn)\n    end\n    else x = 1\n    if x = 0 then do\n      zerrsm = 'Error'\n      zerrlm = newdsn 'currently exists. Select a different' ,\n        'dataset name for the rename operation.'\n      'setmsg msg(isrz003)'\n    end\n    else do\n      zs1 = 'Renaming:' fulldsn\n      zs2 = 'To:      ' newdsn\n      call do_popup\n      if left(fulldsn,1) = \"'\"  /* z/OS rename */\n      then Address TSO 'Rename' fulldsn newdsn\n      else do\n        cmd = 'cd' localrep'/'zigirep\n        cmd = cmd '&& mv' '\"'fulldsn'\" \"'newdsn'\"'\n        x = docmd(cmd)\n      end\n      cmd = 'cd' localrep'/'zigirep\n      newdsns = usssafe(newdsn)\n      fulldsns = usssafe(fulldsn)\n      zs1 = 'Renaming:' fulldsns\n      zs2 = 'To:      ' newdsns\n      call do_popup\n      if left(fulldsn,1) /= \"'\"\n      then cmd = cmd '&& git mv' '\"'fulldsns'\" \"'newdsns'\"'\n      else do\n        x = listdsi(newdsn)\n        oldfile = remove_dsn_hlq(fulldsn)\n        newfile = remove_dsn_hlq(newdsn)\n        oldfiles = usssafe(oldfile)\n        newfiles = usssafe(newfile)\n        cmd = cmd '&& git mv' oldfiles newfiles\n      end\n      x = docmd(cmd)\n      if sysdsorg = 'PO' then do\n        zs1 = 'Renaming:' '.zigi/'oldfiles\n        zs2 = 'To:      ' '.zigi/'newfiles\n        call do_popup\n        /* still weird with rename of statsfile? */\n        cmd = 'cd' localrep'/'zigirep'/.zigi'\n        cmd = cmd '&& git mv' oldfiles newfiles\n        x = docmd(cmd)\n      end\n      if x > 0 then\n      call view_std 'B'\n      'tbdelete' rtbl\n      fulldsn = newdsn\n      dsn = newfile\n      dsnstat = '\u00ddR \u00a8 Renamed in index'\n      'tbadd' rtbl 'Order'\n      bstat = 'Changes to be committed:'\n      baction = null\n      zerrsm = 'Renamed.'\n      zerrlm = fulldsns 'has been renamed in ZIGI, git, z/OS, and OMVS.'\n      'setmsg msg(isrz003)'\n      leave\n    end\n  end\n  Return\n\n  /* -------------------------------- *\n  | Remove a Dataset or File         |\n  | - git rm -f file                 |\n  | - OMVS file just rm -f file      |\n  | - PS Dataset                     |\n  |   Delete dataset                 |\n  |   rm -f file                     |\n  | - PDS Dataset                    |\n  |   Delete dataset                 |\n  |   rm -frv file                   |\n  |   rm -f .zigi/file (ispf stats)  |\n  |    - git rm -f .zigi/file        |\n  * -------------------------------- */\nWWR_handle_lcmd_rm:\n  if readonly = 1 then do\n    zerrsm = 'Invalid.'\n    zerrlm = 'Remove (RM) is not supported for ReadOnly Repositories.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  rc = confirm_remove(fulldsn)\n  rm_msg = null\n  if rc > 0 then do\n    zerrsm = 'Canceled.'\n    zerrlm = 'Removal of' fulldsn 'canceled.'\n    'setmsg msg(isrz003)'\n  end\n  else do\n    rtype = null\n    localdir =  localrep'/'zigirep\n    if left(fulldsn,1) /= \"'\" then rtype = 'OMVS'\n    /* only listdsi on zOs datsets */\n    if rtype = null then do\n      x = listdsi(fulldsn)\n      if rc = 0 & sysdsorg = 'PS' then rtype = 'PS'\n      if rc = 0 & sysdsorg = 'PO' then rtype = 'PO'\n    end\n    if rtype = null then do\n      zs1 = fulldsn 'is not recogizned.'\n      zs2 = sysmsglvl2\n      zs3 = null\n      zs4 = 'Press Enter to continue.'\n      call do_popup4p\n    end\n    else Select\n      when remq = 'N' then do\n        cmd = 'cd' localdir '&& git rm --cached' '\"'usssafe(fulldsn)'\"'\n        x = docmd(cmd,,so.,se.)\n        rm_msg = 'the git index.'\n      end\n      when pos(remq,'OB') > 0 & rtype = 'OMVS' then do\n        cmd = 'cd' localdir '&& git rm -rf' '\"'usssafe(fulldsn)'\"'\n        cmd = cmd '&& git add -u'\n        x = docmd(cmd,,so.,se.)\n        rm_msg = 'OMVS.'\n      end\n      when pos(remq,'ZOB') > 0 & rtype = 'PS' then do\n        if pos(remq,'ZB') > 0 then do\n          call outtrap 'x.'\n          Address TSO ,\n            'Delete' fulldsn\n          call outtrap 'off'\n          rm_msg = 'z/OS'\n        end\n        if pos(remq,'OB') > 0 then do\n          cmd = 'cd' localdir '&& git rm -rf' usssafe(dsn)\n          x = docmd(cmd,,so.,se.)\n          cmd = 'cd' localdir '&& rm -rf' usssafe(dsn)\n          x = docmd(cmd,,so.,se.)\n          if rm_msg /= null\n          then rm_msg = rm_msg 'and OMVS.'\n          else rm_msg = 'OMVS.'\n        end\n      end\n      when pos(remq,'ZOB') > 0 & rtype = 'PO' then do\n        if pos(remq,'ZB') > 0 then do\n          call outtrap 'x.'\n          Address TSO ,\n            'Delete' fulldsn\n          call outtrap 'off'\n          rm_msg = 'z/OS'\n        end\n        if pos(remq,'OB') > 0 then do\n          cmd = 'cd' localdir '&& git rm -rf' dsn\n          cmd = usssafe(cmd)\n          x = docmd(cmd,,so.,se.)\n          cmd = 'cd' localdir\n          cmd = cmd '&& rm -f' localdir'/.zigi/'dsn\n          cmd = cmd '&& rm -f' localdir'/'dsn\n          cmd = usssafe(cmd)\n          x = docmd(cmd,,so.,se.)\n          if x > 0 then call view_std 'B'\n          if rm_msg /= null\n          then rm_msg = rm_msg 'and OMVS.'\n          else rm_msg = 'OMVS.'\n        end\n      end\n      Otherwise nop\n    end\n    dsnstat = '*Removed'\n    'tbmod' rtbl\n    if rm_msg /= null then do\n      zerrsm = 'Removed.'\n      zerrlm = fulldsn 'has been removed from ZIGI, from git, and has' ,\n        'been deleted from' rm_msg\n      'setmsg msg(isrz003)'\n    end\n  end\n  Return\n\n  /* -------------------------------- *\n  | Work with a omvs file from repo   |\n  * -------------------------------- */\nWWR_handle_lcmd_s_omvs:\n  if readonly = 1 then do\n    zerrsm = 'Invalid.'\n    zerrlm = 'Edit is not supported for ReadOnly Repositories.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  zosflg = 0\n  ofile = localrep'/'zigirep'/'fulldsn\n  cur_date = get_fd_date(ofile)\n  if filetype /= '(D)' then do\n    'control display save'\n    'Edit file(ofile)'\n    'control display restore'\n    new_date = get_fd_date(ofile)\n    if cur_date /= new_date then\n    if ztdsels < 2 then\n    call update_repo_metadata\n  end\n  else do\n    save_zigirep = save_zigirep zigirep\n    x = debug('Entering subdirectory - save_zigirep:' save_zigirep)\n    zigirep = zigirep'/'dsn\n    'tbend' rtbl\n    rtbl_open = 0\n    call work_with_repo\n    zigirep = word(save_zigirep,words(save_zigirep))\n    save_zigirep = subword(save_zigirep,1,words(save_zigirep)-1)\n    x = debug('Return from subdirectory - save_zigirep:' save_zigirep)\n    call work_with_repo\n  end\n  Return\n\n  /* -------------------------------- *\n  | Work with a mvs dataset from repo |\n  * -------------------------------- */\nWWR_handle_lcmd_s_mvs:\n  dhit = 1\n  call outtrap 'x.'\n  if sysdsn(fulldsn) /= 'OK' then dhit = 0\n  call outtrap 'off'\n  if dhit = 0 then do\n    zerrsm = 'Error'\n    zerrlm = fulldsn 'does not exist. This should not have happened.' ,\n      'Somehow it may have been deleted.'\n    'Setmsg msg(isrz003)'\n  end\n  else do\n    'control display save'\n    call work_with_repo_file\n    'control display restore'\n  end\n  Return\n\n  /* -------------------------------- *\n  | Add repo item to staging area    |\n  * -------------------------------- */\nWWR_handle_lcmd_a:\n  call git_add\n  zigi_changed = 1\n  Return\n\n  /* -------------------------------- *\n  | Un-Modify entire dataset         |\n  * -------------------------------- */\nWWR_handle_lcmd_u:\n  if dsnvalid(fulldsn) = 'NO' then do\n    zerrsm = 'Invalid.'\n    zerrlm = 'Undo is only valid on a PDS member and not on an OMVS file.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  x = listdsi(fulldsn)\n  if sysdsorg = 'PS' then call do_undo 'D'\n  else do\n    zerrsm = 'Invalid.'\n    zerrlm = 'Undo is not valid on a complete PDS - Select the PDS' ,\n      'and use Undo on the invididual members.'\n    'setmsg msg(isrz003)'\n  end\n  Return\n\n  /* -------------------------------- *\n  | View the OMVS file or directory. |\n  * -------------------------------- */\nWWR_handle_lcmd_z:\n  fdsn = localrep'/'zigirep'/'dsn\n  'control display save'\n  'View file(fdsn)'\n  'control display restore'\n  return\n\n  /* ============================================================== */\n  /* ======== repo file handling ================================== */\n  /* ============================================================== */\n\n  /* ---------------------------------------- *\n  | Process the selected dataset (PDS or PS) |\n  * ---------------------------------------- */\nWork_with_repo_file:\n  remc = 'NO'\n  x = debug('Working with Repo File:' zigirep'/'dsn)\n  x = listdsi(fulldsn)\n  if sysdsorg /= 'PS' then do\n    zs1 = 'Building list of library statuses....'\n    zs2 = 'Patience . . .'\n    call do_popup\n  end\n  /* Determine if the repo item is a PDS or a flat-file */\n  if sysdsorg = 'PS' then\n  call edit_ps\n  else do\n    call WWRF_build_member_table\n    /* ---------------------------------- *\n    | Process the Member list until done |\n    * ---------------------------------- */\n    save_rtll = 0\n    zigi_changed = 0\n    save_ztdsels = ztdsels\n    extens = zdsn.dsn\n    'vput (extens)'\n    Do Forever\n      if rtll_open = 0 then leave\n      call WWRF_display_zigilist\n      if result > 4 then leave\n\n      call WWRF_handle_options\n\n      if zcmd /= null then\n      Select\n        When abbrev('ADDALL',zcmd,2) = 1 then call WWRF_handle_addall\n        When abbrev('COMMIT',zcmd,3) = 1 then call WWRF_handle_commit\n        When abbrev('GITHELP',word(zcmd,1),4) = 1 then\n        Address TSO '%githelp' subword(zcmd,2)\n        When abbrev('GITCMD',zcmd,4) = 1 then\n        'Select cmd(%zigigcmd)'\n        When abbrev('GITLOG',zcmd,2) = 1 then call do_gitlog\n        When abbrev('GREP',zcmd,2) = 1 then do\n          gds = 'PDS Member'\n          call do_grep localdir'/'dsn\n        end\n        When abbrev('STATUS',zcmd,2) = 1 then call do_status\n        When abbrev('RESET',zcmd,2) = 1 then call do_resetid\n        When abbrev('SORT',word(zcmd,1),2) = 1 then call do_lsort\n        When abbrev(\"LOCATE\",translate(word(zcmd,1)),1) = 1 then\n        call WWRF_handle_locate\n        when zcmd = 'VIEWD' then call view_debug\n        Otherwise do\n          zerrsm = 'Unknown'\n          zerrlm = zcmd 'is not a recognized command.'\n          'setmsg msg(isrz003)'\n        end\n        zsel = null\n        zcmd = null\n      end\n\n      if zsel = '/' then do\n        call pfshow 'off'           /* make sure pfshow is off */\n        'Addpop row(4) column(6)'\n        'Display Panel(zigirlst)'\n        'rempop'\n        call pfshow 'reset'         /* restore pfshow setting */\n      end\n\n      /* handle line commands */\n      if zsel /= null then do\n        if zsel = 'E' then zsel = 'S'\n        Select\n          When zsel = 'B' then call WWRF_handle_lcmd_b\n          When zsel = 'V' then call WWRF_handle_lcmd_v\n          When zsel = 'S' then call WWRF_handle_lcmd_s\n          When zsel = 'H' then call do_history dsn'/'mem\n          When zsel = 'RN' then call WWRF_handle_lcmd_rn\n          When zsel = 'RM' then call WWRF_handle_lcmd_rm\n          when zsel = 'A' then do\n            /* -------------------------------- *\n            | Add member of PDS to staging area|\n            * -------------------------------- */\n            call git_add_member\n            zigi_changed = 1\n          end\n          when zsel = 'AB' then call WWRF_handle_lcmd_ab\n          When zsel = 'U' then call do_undo 'M'\n          When zsel = 'D' then call WWRF_handle_lcmd_d\n          When zsel = 'Z' then call WWRF_handle_lcmd_z\n          Otherwise do\n            zerrsm = 'Invalid.'\n            zerrlm = zsel 'is not a valid selection value. Review the' ,\n              'ISPF Tutorial using F1 for available line selection' ,\n              'options.'\n            'setmsg msg(isrz003)'\n          end\n        end\n          /* Comment Start\n        if ztdsels = 1 then\n        if zigi_changed = 1 then do\n          call work_with_repo_file\n          call update_repo_metadata\n        end\n             Comment End */\n      end\n    end\n  end\n  ztdsels = save_ztdsels\n  zsel = null\n  return\n\n  /* ============================================================== */\n  /* ======== repo file handling support functions ================ */\n  /* ============================================================== */\n\nWWRF_build_member_table:\n  /* Do this if it's a PDS */\n  localdir = localrep'/'zigirep\n  'TBCreate' rtll 'Keys(mem) Names(memstat zlcnorc' ,\n    'zlmdate zlmtime zluser mtype zlm4date)',\n    'replace NoWrite'\n  rtll_open = 1\n  cmd = 'ls -laT' localrep'/'zigirep'/'usssafe(dsn)\n  x = bpxwunix(cmd,,root.,re.,env.)\n  address ispexec\n  \"LMINIT DATAID(DID) Dataset(\"fulldsn\")\"\n  \"LMOPEN DATAID(\"did\")\"\n  cmd = 'cd' localrep'/'zigirep\n  x = docmd(cmd '&& git status --porcelain')\n  file_ext = zdsn.dsn\n  file_extl = length(file_ext)\n  dstat = dsnstat\n  do bmi = 1 to root.0\n    if left(root.bmi,1) = ' ' then iterate\n    if word(root.bmi,1) = 'total' then iterate\n    do\n      mem = word(root.bmi,12)\n      if file_ext /= null then\n      if right(mem,file_extl) = file_ext then do\n        parse value mem with mem'.'.\n        mem = translate(mem)\n      end\n      else iterate\n      memstat = null\n      if word(root.bmi,2) = 'binary'\n      then mtype = 'B'\n      else mtype = 'T'\n      do ii = 1 to so.0\n        /* see if we have this file in git status */\n        stat = substr(so.ii,1,2)\n        if pos('R',stat) = 0\n        then thepath = word(so.ii,2)\n        else thepath = word(so.ii,4)\n        parse var thepath FOLDER\"/\"MEMBER\n        if zdsn.dsn /= null then do\n          parse value member with member'.' .\n          member = translate(member)\n        end\n        if folder /= dsn then iterate\n        if mem = MEMBER then do\n          memstat = porcelain(stat)\n          if FOLDER = \"./\" & stat = \"??\" then\n          memstat = '\u00dd??\u00a8 Untracked'\n          leave\n        end\n      end\n    end\n    /* ------------------------------------------------------- *\n    |  The files in OMVS have some chars changed due to cp -M |\n    |  So we fix the name before we save to table :)          |\n    * ------------------------------------------------------- */\n    /* ----------------------------------------------- *\n    | Now get ISPF stats for each member for the list |\n    * ----------------------------------------------- */\n    \"LMMFind DATAID(\"did\") Member(\"mem\") STATS(YES)\"\n    'tbadd' rtll\n  end\n  \"LMCLOSE DATAID(\"did\")\"\n  \"LMFREE DATAID(\"did\")\"\n  'tbsort' rtll 'Fields(mem,c,a)'\n  Return\n\nWWRF_display_zigilist:\n  parse value '' with zsel zcmd row\n  ztdsels = save_rtll\n  if ztdsels > 1 then\n  'tbdispl' rtll\n  else do\n    zigi_changed = 0\n    'tbtop' rtll\n    'tbskip' rtll 'number('list_top')'\n    'TBdispl' rtll 'Panel(zigilist)'\n  end\n  if rc > 4 then do\n    panel_rc = rc\n    if rtll_open = 1 then\n    'tbend' rtll\n    list_top = 0\n    rtll_open = 0\n    Return panel_rc\n  end\n  Return 0\n\nWWRF_handle_options:\n  /* Make sure we edit (and copy) right dataset when we have\n  a prefix set */\n  list_top = ztdtop\n  save_rtll = ztdsels\n  edsn = strip(fulldsn,'B',\"'\")\n\n  if ztdsels = 0 then\n  if pnsdef = 'P' then do\n    if row = 0 then zcmd = 'O'\n    if row > 0 then zsel = '/'\n  end\n\n  if row = 0 then zsel = null\n  if row <> null then\n  if row > 0 then do\n    'TBTop' rtll\n    'TBSkip' rtll 'Number('row')'\n  end\n  if pos('.',zcmd) > 0 then\n  parse value zcmd with x'.'zcmd\n  lstloc = null\n  if zcmd = 'O' then do\n    zcmd = null\n    call pfshow 'off'           /* make sure pfshow is off */\n    'Addpop row(4) column(6)'\n    'Display Panel(zigiolst)'\n    'rempop'\n    call pfshow 'reset'         /* restore pfshow setting */\n  end\n  Return\n\nWWRF_handle_addall:\n  'tbtop' rtll\n  x = debug('ADDALL started:' zigirep)\n  do forever\n    'tbskip' rtll\n    if rc > 0 then leave\n    hit = 0\n    if pos('Untracked',memstat) > 0 then hit = 1\n    if pos('\u00ddM',memstat) > 0 then hit = 1\n    if pos('M\u00a8',memstat) > 0 then hit = 1\n    if hit = 0 then iterate\n    zs1 = 'Adding' mem\n    zs2 = 'Making it ready to Commit'\n    call do_popup\n    call git_add_member\n  end\n  call git_add_member_stats\n  cmd = 'cd' localrep'/'zigirep\n  cmd = cmd '&& git add .'\n  x = docmd(cmd)\n  zcmd = null\n  x = debug('ADDALL completed:' zigirep)\n  Return\n\nWWRF_handle_commit:\n  zsel = null\n  call do_commit\n  call work_with_repo_file\n  Return\n\nWWRF_handle_locate:\n  if words(zcmd) = 1 then do\n    call pfshow 'off'           /* make sure pfshow is off */\n    'addpop row(3) column(4)'\n    'display panel(zigilocq)'\n    drc = rc\n    'rempop'\n    call pfshow 'reset'         /* restore pfshow setting */\n    if drc > 0 then return\n    zcmd = 'L' filter\n  end\n  mem = translate(word(zcmd,2))\n  zcmd = null\n  'tbtop' rtll\n  'tbsarg' rtll\n  'tbscan' rtll 'arglist(mem) position(scanrow) condlist(ge)'\n  if rc = 0 then do\n    save_top = scanrow\n    zerrsm = null\n    zerrlm = mem 'was found in row' scanrow + 0\n    'Setmsg msg(isrz003)'\n    ztdsels = 1\n    list_top = scanrow\n  end\n  else do\n    zerrsm = null\n    zerrlm = word(zcmd,2) 'was not found'\n    'Setmsg msg(isrz003)'\n  end\n  Return\n\n  /* -------------------------------- *\n  | Browse PDS member or PS dataset  |\n  * -------------------------------- */\nWWRF_handle_lcmd_b:\n  'control display save'\n  x = listdsi(fulldsn)\n  edsn = strip(fulldsn,'B',\"'\")\n  r = usssafe(dsn)\n  if sysdsorg = 'PS'\n  then \"Browse Dataset('\"edsn\"')\"\n  else \"Browse Dataset('\"edsn\"(\"mem\")'\"\n  brc = rc\n  'control display restore'\n  if brc > 0 then 'setmsg msg(isrz003)'\n  Return\n\n  /* -------------------------------- *\n  | View PDS member or PS dataset    |\n  * -------------------------------- */\nWWRF_handle_lcmd_v:\n  x = listdsi(fulldsn)\n  edsn = strip(fulldsn,'B',\"'\")\n  r = usssafe(dsn)\n  if is_binfile(dsn'/'mem) = 1 then do\n    zerrsm = 'Invalid'\n    zerrlm = 'Unable to View a binary dataset.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  'control display save'\n  if sysdsorg = 'PS'\n  then \"View Dataset('\"edsn\"')\"\n  else \"View Dataset('\"edsn\"(\"mem\")'\"\n  'control display restore'\n  Return\n\n  /* -------------------------------- *\n  | Edit PDS member or PS dataset    |\n  * -------------------------------- */\nWWRF_handle_lcmd_s:\n  if readonly = 1 then do\n    zerrsm = 'Invalid.'\n    zerrlm = 'Edit is not supported for ReadOnly Repositories.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  x = listdsi(fulldsn)\n  edsn = strip(fulldsn,'B',\"'\")\n  r = usssafe(dsn)\n  eok = 1\n  if is_binfile(dsn'/'mem) = 1 then do\n    zerrsm = 'Invalid'\n    zerrlm = 'Unable to Edit a binary dataset.'\n    'setmsg msg(isrz003)'\n    eok = 0\n    zsel = null\n  end\n  if eok = 1 then do\n    'control display save'\n    if sysdsorg = 'PS'\n    then \"Edit Dataset('\"edsn\"')\"\n    else \"Edit Dataset('\"edsn\"(\"mem\")'\"\n    erc = rc\n    'control display restore'\n  end\n  else erc = 1\n  if erc = 0 then do\n    m = strip(mem)\n    if zdsn.dsn /= null\n    then rm = lower(m)'.'zdsn.dsn\n    else rm = m\n    m = usssafe(m)\n    e = usssafe(edsn)\n    r = usssafe(dsn)\n    /* Binary v1, check if PDS is a bin, then copy binary */\n    if is_binfile(dsn'/*') = 1 then do\n      binopt = '-B'\n    end\n    else do\n      binopt = null\n    end\n    if is_binfile(dsn'/'mem) = 1 then do\n      binopt = '-B'\n    end\n    else do\n      binopt = null\n    end\n    /* Check if a Load Library and update binary option variable */\n    if sysrecfm = 'U' then do\n      binopt = null\n      cplmod = '-X -I'\n    end\n    else cplmod = null\n    if sysdsorg = 'PS'\n    then copycmd = \"//'\"e\"'\"\n    else copycmd = \"//'\"e\"(\"m\")'\"\n    if sysdsorg = 'PO'\n    then r = r'/'rm\n    else r = r'/'\n    r = usssafe(r)\n    copycmd = '\"'copycmd'\"'\n    copycmd = \"cp \"binopt cplmod\" -U -v\" copycmd\" \"localrep\"/\"zigirep\n    copycmd = copycmd || \"/\"r\n    x = docmd(copycmd)\n    if x > 0 then call view_std 'B'\n    x = debug('Copy:' copycmd)\n    if strip(binopt''cplmod) /= null then do\n      tagcmd = 'chtag -b 'localrep'/'zigirep'/'r\n      x = docmd(tagcmd)\n    end\n    call update_mem_stats r mem\n    zigi_changed = 0\n  end\n  Return\n\nUpdate_Mem_Stats:\n  /* r = dsn/mem */\n  parse arg ums_file ums_mem\n  cmd = 'cd' localrep'/'zigirep\n  cmd = cmd '&& git status --porcelain' ums_file\n  cmd = usssafe(cmd)\n  x = docmd(cmd)\n  if so.0 = 1 then do\n    memstat = porcelain(left(so.1,2))\n    s_mem = mem\n    mem = ums_mem\n    'tbmod' rtll\n    mem = s_mem\n  end\n\n  /* fixup dsn status */\n  dsnstat = fixup_dsn_status(memstat dsnstat)\n  'tbmod' rtbl\n\n  x = zigistat(fulldsn ,\n    localrep'/'zigirep'/.zigi/'dsn 'S')\n  cmd = 'cd' localrep'/'zigirep\n  cmd = cmd '&&git add .zigi/'dsn\n  cmd = usssafe(cmd)\n  x = docmd(cmd)\n  return\n\nFixUp_DSN_Status:\n  mstat = memstat\n  parse value mstat with '\u00dd'mstat'\u00a8' .\n  parse value dstat with '\u00dd'dstat'\u00a8' .\n  if pos('\u00a8',memstat) = 0 then return dsnstat\n  if pos('\u00a8',dsnstat) = 0 then do\n    dstat = memstat\n    return dstat\n  end\n  if left(dstat,1) = ' ' then\n  dstat = overlay(left(mstat,1),dstat,1,1)\n  if right(dstat,1) = ' ' then\n  dstat = overlay(right(mstat,1),dstat,2,1)\n  return porcelain(dstat)\n\n  /* ------------------- *\n  | reName a PDS Member |\n  * ------------------- */\nWWRF_handle_lcmd_rn:\n  if readonly = 1 then do\n    zerrsm = 'Invalid.'\n    zerrlm = 'Rename (RN) is not supported for ReadOnly Repositories.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  do forever\n    newmem = mem\n    call pfshow 'off'           /* make sure pfshow is off */\n    'Addpop row(4) column(6)'\n    'display panel(zigirenm)'\n    drc = rc\n    'rempop'\n    call pfshow 'reset'         /* restore pfshow setting */\n    if drc > 0 then leave\n    olddsn = \"'\"strip(fulldsn,'B',\"'\")\"(\"mem\")'\"\n    newdsn = \"'\"strip(fulldsn,'B',\"'\")\"(\"newmem\")'\"\n    call outtrap 'x.'\n    rc = sysdsn(newdsn)\n    call outtrap 'off'\n    if rc = 'OK' then do\n      zerrsm = 'Error'\n      zerrlm = newmem 'currently exists. Select a different' ,\n        'member name for the rename operation.'\n      'setmsg msg(isrz003)'\n    end\n    else do\n      Address TSO 'Rename' olddsn newdsn\n      if zdsn.dsn /= null then do\n        rnmem = lower(mem)'.'zdsn.dsn\n        rnnewmem = lower(newmem)'.'zdsn.dsn\n      end\n      else do\n        rnmem = mem\n        rnnewmem = newmem\n      end\n      cmd = 'cd' localrep'/'zigirep'/'dsn\n      cmd = cmd '&& git mv' rnmem rnnewmem\n      cmd = usssafe(cmd)\n      x = docmd(cmd)\n      call view_std 'B'\n      'tbdelete' rtll\n      mem = newmem\n      'tbadd' rtll 'Order'\n      zerrsm = 'Renamed.'\n      zerrlm = mem 'has been renamed in ZIGI, git, z/OS, and OMVS.'\n      'setmsg msg(isrz003)'\n      call update_mem_stats dsn'/'rnnewmem mem\n      leave\n    end\n  end\n  Return\n\n  /* --------------------------------- *\n  | Remove a PDS member from the Repo |\n  * --------------------------------- */\nWWRF_handle_lcmd_rm:\n  if readonly = 1 then do\n    zerrsm = 'Invalid.'\n    zerrlm = 'Remove (RM) is not supported for ReadOnly Repositories.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  localdir =  localrep'/'zigirep'/'dsn\n  call outtrap 'x.'\n  rdsn = strip(fulldsn,'B',\"'\")\n  rdsn = \"'\"rdsn\"(\"mem\")'\"\n  rc = confirm_remove(rdsn)\n  if rc = 0 then do\n    Address TSO ,\n      'Delete' rdsn\n    call outtrap 'off'\n    if zdsn.dsn /= null then do\n      rmem = lower(mem)'.'zdsn.dsn\n    end\n    else rmem = mem\n    m = usssafe(rmem)\n    xldir = usssafe(localdir)\n    cmd = 'cd' xldir\n    if pos('??',memstat) = 0\n    then cmd = cmd '&& git rm -f \"'m'\"'\n    else cmd = cmd '&& rm -f' m\n    x = docmd(cmd,,so.,se.)\n    memstat = '*Removed'\n    'tbmod' rtll\n    zerrsm = 'Removed.'\n    zerrlm = m 'has been removed from ZIGI, from git, and has' ,\n      'been deleted from z/OS and OMVS.'\n    'setmsg msg(isrz003)'\n    statfile = translate(strip(fulldsn,'B',\"'\"),' ','.')\n    if qualignr > 0 then\n    statfile = subword(statfile,qualignr+1)\n    statfile = translate(statfile,'.',' ')\n    cmd = 'cd' localrep'/'zigirep'/.zigi/'\n    stats = usssafe(statfile)\n    x = zigistat(fulldsn localrep'/'zigirep'/.zigi/'stats 'S')\n    cmd = 'cd' localrep'/'zigirep\n    cmd = cmd || '&& git add -v .zigi/'stats\n    x = docmd(cmd)\n    if x > 0 then call view_std 'B'\n    zigi_changed = 1\n  end\n  else do\n    zerrsm = 'Canceled.'\n    zerrlm = 'Removal of' rdsn 'canceled.'\n    'setmsg msg(isrz003)'\n  end\n  Return\n\n  /* --------------------------------- *\n  | Add member of PDS to staging area |\n  | as a binary member and copy/tag it|\n  * --------------------------------- */\nWWRF_handle_lcmd_ab:\n  dsna = translate(strip(fulldsn,'B',\"'\"),' ','.')\n  add_count = 0\n  dsnapfx = pdshlq\n  sa_dsna = dsna\n  dsna = strip(fulldsn,'B',\"'\")'('mem')'\n  call do_add_copy 'binary'\n  parse value dsn with dsn'/'mem\n  dsna = sa_dsna\n  call git_add_member\n  zigi_changed = 1\n  if zdsn.dsn /= null then\n  mem = lower(zdsn.dsn'.'mem)\n  r = dsn'/'mem\n  if ztdsels < 2 then do\n    call get_binfiles\n  end\n  Return\n\n  /* -------------------------------- *\n  | Show the diff for the member     |\n  * -------------------------------- */\nWWRF_handle_lcmd_d:\n  d = usssafe(dsn)\n  cmd = 'cd' localrep'/'zigirep'/'d\n  m = usssafe(mem)\n  if zdsn.dsn /= null then\n  m = lower(m)'.'zdsn.dsn\n  x = docmd(cmd ' && git diff 'm)\n  if so.0 + se.0 > 0\n  then call View_std 'X' 'V'\n  else do\n    zerrsm = 'No Diff'\n    zerrlm = 'No differnce found.'\n    'Setmsg msg(isrz003)'\n  end\n  Return\n\nWWRF_handle_lcmd_z:\n  if zdsn.dsn /= null\n  then m = lower(mem)'.'zdsn.dsn\n  else m = mem\n  fdsn = localrep'/'zigirep'/'dsn'/'m\n  'control display save'\n  'View file(fdsn)'\n  'control display restore'\n  return\n\n  /* ============================================================== */\n  /* ======== generic support functions       ===================== */\n  /* ============================================================== */\n\nSetup_Selective_Replace:\n  parse arg ssrmsg\n  parse value '' with pulldsns pullmems. deletes.\n  deletes.0 = 0\n  pulled = 0\n  ptype = 0\n  do pi = 1 to so.0\n    so.pi = translate(so.pi,' ','05'x)\n    if word(so.pi,1) = 'Removing' then do\n      if left(w,1) = '.' then iterate\n      dc = deletes.0 + 1\n      deletes.dc = w\n      deletes.0 = dc\n    end\n    if word(so.pi,1) = 'deleted:' then do\n      if left(w,1) = '.' then iterate\n      dc = deletes.0 + 1\n      deletes.dc = w\n      deletes.0 = dc\n      if pos('/',w) > 0 then do\n        parse value w with w'/'.\n        if wordpos(w,pulldsns) = 0 then\n        pulldsns = pulldsns w\n      end\n    end\n    if pos('new file:',so.pi) > 0 then do\n      w = word(so.pi,3)\n      if left(w,1) = '.' then iterate\n      if pos('/',w) > 0 then do\n        parse value w with w'/'m\n        if wordpos(w,pulldsns) = 0 then\n        pulldsns = pulldsns w\n        pullmems.w = pullmems.w m\n      end\n      else if wordpos(w,pulldsns) = 0 then\n      pulldsns = pulldsns w\n    end\n    if pos('modified:',so.pi) > 0 then do\n      w = word(so.pi,2)\n      if left(w,1) = '.' then iterate\n      if pos('/',w) > 0 then do\n        parse value w with w'/'m\n        if wordpos(w,pulldsns) = 0 then\n        pulldsns = pulldsns w\n        pullmems.w = pullmems.w m\n      end\n      else if wordpos(w,pulldsns) = 0 then\n      pulldsns = pulldsns w\n    end\n    if ptype = 1 then do  /* status report */\n      if left(so.pi,1) /= ' ' then iterate\n      if pos(' changed,',so.pi) > 0 then do\n        pullmsg = so.pi\n        pulled = 1\n        iterate\n      end\n      if word(so.pi,1) = 'rename' then do\n        if pos('/',so.pi) > 0 then do\n          parse value so.pi with . dd'/{'dm '=>' nm'}' .\n          dc = deletes.0 + 1\n          deletes.dc = strip(dd)'/'strip(dm)\n          deletes.0 = dc\n          if wordpos(dd,pulldsns) = 0 then do\n            pulldsns = pulldsns dd\n            pullmems.dd = nm\n          end\n          else pullmems.dd = pullmems.dd nm\n        end\n        else do\n          parse value so.pi with . dd '=>' nd .\n          dc = deletes.0 + 1\n          deletes.dc = strip(dd)\n          deletes.0 = dc\n          if wordpos(nd,pulldsns) = 0 then\n          pulldsns = pulldsns nd\n        end\n      end\n      if word(so.pi,1) = 'delete' then\n      if word(so.pi,2) = 'mode' then do\n        delds = word(so.pi,4)\n        dhit = 1\n        if left(delds,1) = '.' then dhit = 0\n        if dsnvalid(delds) = 'NO' then dhit = 0\n        if dhit = 1 then do\n          dc = deletes.0 + 1\n          deletes.dc = delds\n          deletes.0 = dc\n        end\n      end\n      if left(so.pi,5) = 'From' then leave\n      pidsn = word(so.pi,1)\n      if left(pidsn,1) = '.' then iterate\n      parse value pidsn with pidsn'/'pimem\n      if wordpos(pidsn,pulldsns) = 0 then do\n        pulldsns = pulldsns pidsn\n        pullmems.pidsn = pimem\n      end\n      else pullmems.pidsn = pullmems.pidsn pimem\n    end\n    if ptype = 2 then do  /* stash report */\n      w = word(so.pi,1)\n      if left(w,1) = '.' then iterate\n      if pos('/',w) = 0 then do\n        if pos('=>',so.pi) = 0 then do\n          if wordpos(w,pulldsns) = 0 then\n          pulldsns = pulldsns w\n        end\n        else do\n          parse value so.pi with wd '=>' w\n          dc = deletes.0 + 1\n          deletes.dc = wd\n          deletes.0 = dc\n          if wordpos(w,pulldsns) = 0 then\n          pulldsns = pulldsns w\n        end\n      end\n      else do\n        parse value w with w'/'m\n        if pos('{',m) > 0 then do\n          parse value m with '{'dm '=>' nm'}' .\n          dc = deletes.0 + 1\n          deletes.dc = w'/'dm\n          deletes.0 = dc\n          pullmems.w = pullmems.w nm\n          if wordpos(w,pulldsns) = 0 then\n          pulldsns = pulldsns w\n        end\n        else do\n          pullmems.w = pullmems.w m\n          if wordpos(w,pulldsns) = 0 then\n          pulldsns = pulldsns w\n        end\n      end\n    end\n  end\n  call do_post_pull 'Stash Pop'\n  return\n\nDo_Post_Pull:\n  if strip(pulldsns) = null then do\n    zerrsm = 'Nothing'\n    zerrlm = 'No updates to process for' ssrmsg\n    'setmsg msg(isrz003)'\n    return\n  end\n  /* ------------------------------------------------- *\n  | Validate all the Pulldsns and remove if not valid |\n  * ------------------------------------------------- */\n  do ip = words(pulldsns) to 1 by -1\n    w = word(pulldsns,ip)\n    if dsnvalid(w) = 'OK' then iterate\n    pulldsns = delword(pulldsns,ip,1)\n  end\n  /* create the ispf variable with member names for\n  the dataset using the dataset offset in pulldsns\n  for the variable suffix */\n  if qualignr = 0\n  then delhlq = pdshlq\n  else do\n    delhlq = translate(pdshlq,' ','.')\n    if qualignr /= '*' then\n    delhlq = subword(delhlq,1,qualignr)\n    delhlq = translate(delhlq,'.',' ')\n  end\n  do zz = 1 to words(pulldsns)\n    zd = word(pulldsns,zz)\n    zw = words(pullmems.zd)\n    ldsn = \"'\"delhlq\".\"zd\"'\"\n    x = listdsi(ldsn \"dir\")\n    /* check if a PDSE and bypass the full Replace or if not\n    a PDSE then check of more than 25% of members being\n    updated and if so then nullify the member list so a full\n    Replace will occur for the dataset */\n    if x = 0 then\n    if sysmembers /= null then\n    if sysadirblk /= 'NO_LIM' then\n    if sysmembers/zw < 4 then pullmems.zd = ''\n    interpret 'zv'zz '= (pullmems.zd)'\n    'vput zv'zz\n  end\n  if pulldsns /= null then do\n    call Replace localrep zigirep pdshlq qualignr pulldsns\n    if qualignr = 0\n    then delhlq = pdshlq\n    else do\n      delhlq = translate(pdshlq,' ','.')\n      if qualignr /= '*' then\n      delhlq = subword(delhlq,1,qualignr)\n      delhlq = translate(delhlq,'.',' ')\n    end\n    'Verase pulldsns Both'\n    call check_for_more_deletes\n    call outtrap 'x.'\n    if deletes.0 > 0 then\n    do dc = 1 to deletes.0\n      if pos('/',deletes.dc) = 0\n      then do\n        delds =  \"'\"delhlq\".\"deletes.dc\"'\"\n        dm.dc = delds\n        Address TSO 'Delete' delds\n        cmd = 'cd' localrep'/'zigirep\n        cmd = cmd '&& rm' deletes.dc\n        x = docmd(cmd)\n      end\n      else do\n        parse value deletes.dc with delds'/'mem\n        mem = strip(mem)\n        dm.dc = \"'\"delhlq\".\"delds\"(\"mem\")'\"\n        call delete_member \"'\"delhlq\".\"delds\"'\" mem\n        cmd = 'cd' localrep'/'zigirep'/'delds\n        cmd = cmd '&& rm -f' mem\n        x = docmd(cmd)\n      end\n    end\n    call outtrap 'off'\n    do id = 1 to deletes.0\n      so.id = 'Deleted:' dm.id\n    end\n    so.0 = deletes.0\n    se.0 = 0\n    call update_repo_metadata\n  end\n  if pulled > 0 then do\n    zerrsm = 'Successful.'\n    zerrlm = left(ssrmsg 'was a success.',76) pullmsg\n    'setmsg msg(isrz003)'\n  end\n  return\n\n  /* ----------------------- *\n  | Git Add Dataset Routine |\n  * ----------------------- */\ngit_add:\n  zs1 = 'Adding' fulldsn\n  zs2 = 'Making it ready to Commit'\n  call do_popup\n  if left(dsn,1) = \"'\"\n  then d = usssafe(dsn)\n  else d = '\"'usssafe(dsn)'\"'\n  cmd = 'cd' localrep'/'zigirep\n  drop so. se.\n  x = docmd(cmd ' && git add -v 'd)\n  if dsnvalid(fulldsn) = \"OK\" then do\n    /* Only get the stats if it's a z/OS dataset\n    Don't do it for the USS files\n    */\n    x = listdsi(fulldsn)\n    if x = 0 then do\n      if sysdsorg /= 'PS' then do\n        statfile = remove_dsn_hlq(fulldsn)\n        cmd = 'cd' localrep'/'zigirep'/.zigi/'\n        stats = usssafe(statfile)\n        x = zigistat(fulldsn localrep'/'zigirep'/.zigi/'stats 'S')\n        x = docmd(cmd '&& git add -v 'stats)\n        if x > 0 then call view_std 'B'\n      end\n    end\n  end\n  return\n\n  /* ------------------------------------------------- *\n  | Stash the current workspace                       |\n  | git stash push -u -a -m \"date time\"               |\n  | then                                              |\n  | git stash show (to get the affected datasets)     |\n  |                                                   |\n  | generate a replace based on the affected datasets |\n  * ------------------------------------------------- */\nStash_IT:\n  if readonly = 1 then do\n    zerrsm = 'Invalid.'\n    zerrlm = 'STASH is not supported for ReadOnly Repositories.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  stashmsg = null\n  call pfshow 'off'           /* make sure pfshow is off */\n  'addpop row(3) column(4)'\n  'display panel(zigistaq)'\n  drc = rc\n  'rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  if drc > 0 then do\n    zerrsm = 'Canceled.'\n    zerrlm = 'Stash canceled.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  zs1 = 'Initiating git stash processing.'\n  zs2 = 'Please be patient while git does its thing.'\n  call pfshow 'off'           /* make sure pfshow is off */\n  'addpop row(3) column(4)'\n  'control display lock'\n  'display panel(zigipop)'\n  'rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  cmd = 'cd' localrep'/'zigirep\n  cmd = cmd '&& git stash push -a -u -m \"'date() time() stashmsg'\"'\n  cmd = cmd '&& git stash show'\n  x = docmd(cmd)\n  call view_std 'B'\n  deletes.0 = 0\n  parse value '' with pulldsns pullmems. renames.\n  renames.0 = 0\n  dc = 0\n  do stashi = 1 to so.0\n    if pos('|',so.stashi) = 0 then iterate\n    parse value so.stashi with w '|' c\n    w = strip(w)\n    if left(w,1) = '.' then iterate\n    Select\n      when pos('->',c) > 0 then do\n        if pos('0 bytes',c) > 0 then do\n          if pos('/',w) = 0 then do\n            cmd = 'cd' localrep'/'zigirep\n            cmd = cmd '&& rm' usssafe(w)\n            x = bpxwunix(cmd,,stdo.,stde.,env.)\n          end\n          else do\n            parse value w with w'/'m\n            cmd = 'cd' localrep'/'zigirep'/'usssafe(w)\n            cmd = cmd '&& rm' usssafe(w)\n            x = bpxwunix(cmd,,stdo.,stde.,env.)\n            if wordpos(w,pulldsns) = 0 then\n            pulldsns = pulldsns w\n          end\n        end\n      end\n      when pos('{',w) > 0 then do   /* rename */\n        parse value w with w'/'m\n        if wordpos(w,pulldsns) = 0 then\n        pulldsns = pulldsns w\n        parse value m with '{'dm '=>' nm'}' .\n        pullmems.w = pullmems.w nm\n        rn = renames.0 + 1\n        renames.rn = w'/'dm w'/'nm\n        renames.0 = rn\n      end\n      when pos('=>',w) = 0 then do\n        if pos('/',w) = 0 then\n        if wordpos(w,pulldsns) = 0 then\n        pulldsns = pulldsns w\n        if pos('/',w) > 0 then do\n          parse value w with w'/'m\n          if wordpos(w,pulldsns) = 0 then\n          pulldsns = pulldsns w\n          pullmems.w = pullmems.w m\n        end\n      end\n      when pos('=>',w) > 0 then do   /* Rename */\n        parse value w with wd '=>' w\n        w = strip(w)\n        if pos('/',w) = 0 then\n        if wordpos(w,pulldsns) = 0 then\n        pulldsns = pulldsns w\n        if pos('/',w) > 0 then do\n          parse value w with w'/'m\n          if wordpos(w,pulldsns) = 0 then\n          pulldsns = pulldsns w\n          pullmems.w = pullmems.w m\n        end\n        else do\n          rn = renames.0 + 1\n          renames.rn = wd w\n          renames.0 = rn\n        end\n      end\n      Otherwise nop\n    end\n  end\n  call do_post_pull 'Stash Push/Save'\n  do rename_i = 1 to renames.0\n    parse value renames.rename_i with newname oldname\n    if pos('/',newname) = 0 then do\n      call outtrap 'x.'\n      address tso ,\n        'rename' Add_DSN_HLQ(oldname) Add_DSN_HLQ(newname)\n      call outtrap 'off'\n    end\n    else do\n      parse value newname with d'/'m\n      newname = Add_DSN_HLQ(d'('m')')\n      parse value oldname with d'/'m\n      oldname = Add_DSN_HLQ(d'('m')')\n      call outtrap 'x.'\n      address tso ,\n        'rename' Add_DSN_HLQ(oldname) Add_DSN_HLQ(newname)\n      call outtrap 'off'\n    end\n  end\n  zerrsm = 'Complete.'\n  zerrlm = 'Stash Push (save) completed.'\n  'setmsg msg(isrz003)'\n  return\n\n  /* ---------------------------------------------------------- *\n  | Add_DSN_HLQ take the input dataset name, the active pdshlq |\n  | and qualignr. Then returns the fully qualified, in quotes, |\n  | dataset name.                                              |\n  |                                                            |\n  | Calling parm: OMVS-filename HLQ                            |\n  | where HLQ is optional and will default to the active       |\n  | pdshlq value.                                              |\n  * ---------------------------------------------------------- */\nAdd_DSN_HLQ:\n  arg addsn newhlq\n  if newhlq = null\n  then adwhlq = pdshlq\n  else adwhlq = newhlq\n  if length(qualignr) = 0 then qualignr = 0\n  if datatype(qualignr) /= 'NUM' then qualignr = 0\n  if qualignr = 0\n  then nhlq = null\n  else do\n    nhlq = translate(adwhlq,' ','.')\n    if qualignr /= '*' then\n    nhlq = subword(nhlq,1,qualignr)\n    nhlq = translate(nhlq,'.',' ')'.'\n  end\n  addsn = \"'\"nhlq\"\"addsn\"'\"\n  return addsn\n\nRemove_DSN_HLQ:\n  arg rmdsn\n  rmdsn = translate(strip(rmdsn,'B',\"'\"),' ','.')\n  if qualignr > 0 then\n  rmdsn = subword(rmdsn,qualignr+1)\n  rmdsn = translate(rmdsn,'.',' ')\n  return rmdsn\n\n  /* ------------------------------------------------ *\n  | Process the stashl (stash list) command:         |\n  | - issue git stash list to get a list of stashes  |\n  | - display them in a table                        |\n  | - selection commands will be:                    |\n  |   BRanch - git stash branch-name stash-#   (B)   |\n  |     - do a replace for affected datasets         |\n  |   DIFF - git stash show # -p (then view)   (D)   |\n  |   Remove - git stash drop stash-#          (R)   |\n  |   POP  - git stash pop #                   (P)   |\n  |   SHOW - git stash show #                  (S)   |\n  | - Commands                                       |\n  |   CLEAR - git stash clear  (removed ALL stashes) |\n  * ------------------------------------------------ */\nStash_List:\n  if readonly = 1 then do\n    zerrsm = 'Invalid.'\n    zerrlm = 'STASHList is not supported for ReadOnly Repositories.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  cmd = 'cd' localrep'/'zigirep\n  cmd = cmd '&& git stash list'\n  x = docmd(cmd)\n  hit = 0\n  do sti = 1 to so.0\n    if left(so.sti,5) /= 'stash' then iterate\n    parse value so.sti with stashid':' stashcmt\n    if hit = 0 then do\n      stab = 'STAB'random(9999)\n      'tbcreate' stab 'names(stashid stashcmt) nowrite'\n    end\n    'tbadd' stab 'order'\n    hit = 1\n  end\n  if hit = 0 then do\n    zerrsm = 'Nothing.'\n    zerrlm = 'No stashes have been found.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  ztop = 1\n  ztdsels = 0\n  do forever\n    zsel = null\n    if ztdsels > 1 then do\n      'tbdispl' stab\n    end\n    else do\n      'tbtop' stab\n      'tbskip' stab 'number(ztop)'\n      'tbdispl' stab 'panel(zigistab)'\n    end\n    if rc > 4 then do\n      'tbend' stab\n      return\n    end\n    ztop = ztdtop\n    if zcmd = 'CLEAR' then do\n      'tbend' stab\n      cmd = 'cd' localrep'/'zigirep\n      cmd = cmd '&& git stash clear'\n      x = docmd(cmd)\n      zerrsm = 'Cleared.'\n      zerrlm = 'All stashes have been removed from the repository.'\n      'setmsg msg(isrz003)'\n      return\n    end\n    if zsel = '/' then do\n      call pfshow 'off'           /* make sure pfshow is off */\n      'addpop row(3) column(4)'\n      'display panel(zigirsth)'\n      drc = rc\n      'rempop'\n      call pfshow 'reset'         /* restore pfshow setting */\n      if drc > 0 then zsel = null\n    end\n    if zsel /= null then\n    Select\n      When zsel = 'B' then do   /* branch */\n        bname = null\n        call pfshow 'off'           /* make sure pfshow is off */\n        'addpop row(3) column(4)'\n        'display panel(zigistbq)'\n        drc = rc\n        'rempop'\n        call pfshow 'reset'         /* restore pfshow setting */\n        if drc > 0 then do\n          zerrsm = 'Canceled.'\n          zerrlm = 'Stash Branch canceled.'\n          'setmsg msg(isrz003)'\n        end\n        else do\n          cmd = 'cd' localrep'/'zigirep\n          cmd = cmd '&& git stash branch' bname stashid\n          x = docmd(cmd)\n          call view_std 'B'\n          call Setup_Selective_Replace 'Stash Branch'\n          'tbdelete' stab\n        end\n      end\n      When zsel = 'P' then do   /* pop */\n        abort = 0\n        pass = 0\n        stash_hit = do_stash_pop()\n        if stash_hit = 1 then do\n          call pfshow 'off'           /* make sure pfshow is off */\n          'Addpop row(3) column(4)'\n          'display panel(zigispbd)'\n          'rempop'\n          call pfshow 'reset'         /* restore pfshow setting */\n        end\n        else do\n          'tbdelete' stab\n          call Setup_Selective_Replace 'Stash Pop'\n          zerrsm = 'Completed.'\n          zerrlm = 'Stash pop processing completed for' stashid\n          'setmsg msg(isrz003)'\n          zsel = null\n          leave\n        end\n      end\n      When zsel = 'R' then do   /* remove/drop */\n        cmd = 'cd' localrep'/'zigirep\n        cmd = cmd '&& git stash drop' stashid\n        x = docmd(cmd)\n        call view_std 'B'\n        sid = stashid\n        'tbdelete' stab\n        zerrsm = 'Removed.'\n        zerrlm = 'Stash entry removed.' sid\n        'setmsg msg(isrz003)'\n      end\n      When zsel = 'S' then do   /* show */\n        cmd = 'cd' localrep'/'zigirep\n        cmd = cmd '&& git stash show' stashid\n        x = docmd(cmd)\n        call view_std 'B'\n      end\n      When zsel = 'D' then do   /* show diff */\n        cmd = 'cd' localrep'/'zigirep\n        cmd = cmd '&& git stash show -p' stashid\n        x = docmd(cmd)\n        call view_std 'B' 'V'\n      end\n      Otherwise do\n        zerrsm = 'Unknown.'\n        zerrlm = zsel 'is an unknown line selection - try again.'\n        'setmsg msg(isrz003)'\n      end\n    end\n  end /* end of do forever */\n  return\n\nDo_Stash_Pop:\n  x = git_clean_check()\n  if x > 0 then return 1\n  cmd = 'cd' localrep'/'zigirep\n  cmd = cmd '&& git stash pop' stashid\n  zs1 = 'Initiating git stash pop processing.'\n  zs2 = 'Please be patient while git does its thing.'\n  call pfshow 'off'           /* make sure pfshow is off */\n  'addpop row(3) column(4)'\n  'control display lock'\n  'display panel(zigipop)'\n  'rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  xrc = docmd(cmd)\n  if xrc > 0 then do\n    call view_std 'B'\n    Return 1\n  end\n  return 0\n\nGit_Clean_Check:\n  lcmd = 'cd' localrep'/'zigirep\n  cmd = lcmd '&& git status'\n  x = docmd(cmd)\n  if so.0 = 2 then return 0\n  return 1\n\n  /* -------------------------------------- *\n  | Set/Confirm/Change Repository Settings |\n  | for Push and Userid Change             |\n  * -------------------------------------- */\nDo_Rset:\n  zcmd = null\n  pdshlqn = pdshlq\n  hlq_change = 0\n  extans = extfile\n  zginst = 'N'\n  call pfshow 'off'           /* make sure pfshow is off */\n  'Addpop row(2) column(4)'\n  'Display Panel(zigirset)'\n  drc = rc\n  'rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  if drc > 0 then return\n  if extans /= null then do\n    extfile = extans\n    'vput (extfile) profile'\n  end\n  if defcpush = 'Y' then zpush = 'Y'\n  else zpush = 'N'\n\n  /* ---------------------------------- *\n  | Check for zginstall.rex enablement |\n  * ---------------------------------- */\n  if zginst = 'Y' then do\n    rc = zigigeni(localrep'/'zigirep)\n    cmd = 'cd' localrep'/'zigirep\n    cmd = cmd '&& git add zginstall.rex zginstall.readme'\n    x = docmd(cmd)\n    call view_std 'B'\n  end\n\n  /* ------------------------------ *\n  | Check for change in HLQ Prefix |\n  * ------------------------------ */\n  if pdshlqn /= pdshlq then do\n    hlq_change = 1\n    hlqnw = words(translate(pdshlqn,' ','.'))\n    lr = localrep'/'zigirep\n    'tbtop' rtbl\n    do forever\n      'tbskip' rtbl\n      if rc > 0 then leave\n      if left(fulldsn,1)/= \"'\" then iterate\n      oldfile = fulldsn\n      newfile = strip(fulldsn,'B',\"'\")\n      newfile = translate(newfile,' ','.')\n      newfile = \"'\"pdshlqn'.'subword(newfile,hlqnw+1)\"'\"\n      newfile = translate(newfile,'.',' ')\n      zs1 = 'Renaming:' oldfile\n      zs2 = 'To:      ' newfile\n      call do_popup\n      Address TSO ,\n        'Rename' oldfile newfile\n      oldfile = remove_dsn_hlq(oldfile)\n      newfile = remove_dsn_hlq(newfile)\n      if newfile /= oldfile then do\n        zs1 = 'Renaming:' lr'/'oldfile\n        zs2 = 'To:      ' lr'/'newfile\n        call do_popup\n        address syscall 'lstat' lr'/'oldfile s.\n        cmd = 'cd' lr\n        cmd = cmd '&& git mv' oldfile newfile\n        if s.1 = 1 then do\n          cmd = cmd '&& cd .zigi'\n          cmd = cmd '&& git mv' oldfile newfile\n        end\n        x = docmd(cmd)\n        if x > 0 then call view_std 'B'\n      end\n    end\n    x = debug('Calling zigirefd to update last access info.')\n    /* Delete the old reference date file */\n    x = zigirefd(localrep'/'zigirep pdshlq qualignr 'D')\n    /* reset the hlq variable */\n    pdshlq = pdshlqn\n    /* update/create the last reference date file */\n    x = zigirefd(localrep'/'zigirep pdshlq qualignr 'U')\n    x = debug('Completed the last access update.')\n  end\n  'tbmod zigirepo order'\n  'TBSAVE zigirepo REPLCOPY LIBRARY('isptabl')'\n  if defcpush = 'Y' then zpush = 'Y'\n  else zpush = 'N'\n  if zginst /= 'N' then do\n    zerrsm = 'Updated.'\n    zerrlm = 'Repository default actions updates and saved.'\n    'setmsg msg(isrz003)'\n  end\n  if hlq_change = 1 then\n  call work_with_repo\n  return\n\n  /* --------------------------------------------- *\n  | Process Tag List Request with optional create |\n  * --------------------------------------------- */\nGet_TagList:\n  all_tags = null\n  cmd = 'cd' localrep'/'zigirep\n  cmd = cmd \"&& git for-each-ref --format\" ,\n    \"'%(creatordate) %(refname) %(objectname) %(subject)'\" ,\n    \"refs/tags\"\n  x = docmd(cmd)\n  'TBCreate' zcrtbl 'Keys(ctag) Names(cdatetim ctitle chash' ,\n    'sortdate sorttime) nowrite share'\n  do cri = 1 to so.0\n    if left(strip(so.cri),4) = 'refs' then do\n      parse value so.cri with ctag ctitle\n      cdatetim = 'no date'\n      sortdate = 0\n      sorttime = 0\n    end\n    else do\n      parse value so.cri with day mm dd time yy gmt ctag chash ctitle\n      cdatetim = yy mm dd time\n      zd = dd mm yy\n      sortdate = dd mm yy\n      sortdate = date('b',sortdate,'n')\n      sorttime = left(time,2)''substr(time,4,2)\n    end\n    ctag = translate(ctag,' ','/')\n    ctag = word(ctag,3)\n    all_tags = all_tags ctag\n    chash = left(chash,7)\n    'tbadd' zcrtbl\n  end\n  return\n\n  /* -------------- *\n  | Do Tag Summary |\n  * -------------- */\nDo_TAGLIST:\n  zcmd = null\n  crcnt = 10\n  ocrcnt = 10\n  zcrtbl = 'ZT'time('s')\n  call get_TAGLIST\n  ztdsels = 0\n  ztdtop = 1\n  tags = null\n  'tbsort' zcrtbl 'fields(sortdate,n,d,sorttime,n,d)'\n  'tbtop' zcrtbl\n  do forever\n    zsel = null\n    if ztdsels > 1\n    then 'tbdispl' zcrtbl\n    else do\n      'tbtop' zcrtbl\n      'tbskip' zcrtbl 'number('ztdtop')'\n      'tbdispl' zcrtbl 'panel(zigitagt)'\n    end\n    if rc > 4 then leave\n\n    if ztdsels = 0 then\n    if pnsdef = 'P' then\n    if crcnt = ocrcnt then do\n      if row = 0 then zcmd = 'O'\n      if row > 0 then zsel = '/'\n    end\n\n    if pos('.',zcmd) > 0 then\n    parse value zcmd with x'.'zcmd\n\n    if zcmd = 'O' then do\n      call pfshow 'off'           /* make sure pfshow is off */\n      'Addpop row(4) column(10)'\n      'Display Panel(zigiotag)'\n      'rempop'\n      call pfshow 'reset'         /* restore pfshow setting */\n    end\n\n    if zsel = '/' then do\n      call pfshow 'off'           /* make sure pfshow is off */\n      'Addpop row(3) column(4)'\n      'Display Panel(zigirtag)'\n      'rempop'\n      call pfshow 'reset'         /* restore pfshow setting */\n    end\n\n    if row /= null then do\n      'tbtop' zcrtbl\n      'tbskip' zcrtbl    'number('row')'\n    end\n\n    Select\n      When abbrev('Replace',word(zcmd,1),1) = 1 then do\n        'tbend' zcrtbl\n        call get_TAGLIST\n      end\n      When abbrev('ONLY',word(zcmd,1),1) = 1 then do\n        if words(zcmd) = 1 then do\n          call pfshow 'off'           /* make sure pfshow is off */\n          'addpop row(3) column(4)'\n          'display panel(zigionly)'\n          drc = rc\n          'rempop'\n          call pfshow 'reset'         /* restore pfshow setting */\n          if drc > 0 then leave\n          zcmd = 'O' filter\n        end\n        'tbtop' zcrtbl\n        ohit = 0\n        fw = subword(zcmd,2)\n        ztdtop = 0\n        do forever\n          'tbskip' zcrtbl\n          if rc > 0 then\n          if ohit = 1 then do\n            ztdtop = 1\n            leave\n          end\n          if rc > 0 then do\n            'tbend' zcrtbl\n            call get_TAGLIST\n            zerrsm = 'Not Found.'\n            zerrlm = fw 'not found in the rollback log.'\n            'Setmsg msg(isrz003)'\n            ztdtop = 1\n            leave\n          end\n          ztdtop = ztdtop + 1\n          if pos(fw,translate(ctag ctitle)) = 0 then 'tbdelete' zcrtbl\n          else ohit = 1\n        end\n      end\n      when zsel = 'X' then do\n        ext_type = 'T'\n        tags = tags chash\n        if ztdsels = 1 then\n        call do_tag_extract\n      end\n      when zsel = 'S' then do\n        cmd = 'cd' localrep'/'zigirep\n        cmd = cmd '&& git show -P' ctag\n        x = docmd(cmd)\n        call view_std 'B'\n      end\n      when zsel = 'C' then do\n        zcmd  = null\n        newbr = null\n        rolla = 'Cancel'\n        call pfshow 'off'           /* make sure pfshow is off */\n        'Addpop row(4) column(12)'\n        'Display Panel(zigitagq)'\n        prc = rc\n        'Rempop'\n        call pfshow 'reset'         /* restore pfshow setting */\n        if prc > 0 then do\n          zerrsm = 'Canceled.'\n          zerrlm = 'Create branch canceled.'\n          prc = 1\n        end\n        if prc = 0 then do\n          call get_branches\n          if wordpos(newbr,all_tags) > 0 then prc = 1\n          if prc = 0 then\n          do bi = 1 to bl.0\n            if newbr = bl.bi then prc = 1\n          end\n        end\n        if prc = 1 then\n        if zerrsm = null then do\n          zerrsm = 'Invalid.'\n          zerrlm = newbr 'branch/tag currently exists - pick a different' ,\n            'name for the branch and try again.'\n          'setmsg msg(isrz003)'\n          prc = 1\n          newbr = null\n        end\n        if prc = 0 then\n        if newbr /= null then do\n          cmd = 'cd' localrep'/'zigirep\n          drop combine.\n          combine.0 = 0\n          call add_combine cmd\n          x = docmd(cmd ' && git checkout' ctag '-b' newbr)\n          call add_combine 'git checkout' ctag '-b' newbr\n          call combine_msgs\n          if left(remote1,1) /= '<' then\n          if zigi_offline = 0 then do\n            cmd = 'cd' localrep'/'zigirep\n            x = docmd(cmd ' && git push origin 'newbr)\n            call add_combine 'git push origin' newbr\n            branch = newb\n            call combine_msgs\n          end\n          if combine.0 > 0 then call view_std 'C'\n          call Replace localrep zigirep pdshlq qualignr\n          /* --------------------------------------- *\n          | Call work_with_repo with flag to return |\n          * --------------------------------------- */\n          call work_with_repo 'x'\n          leave\n        end\n        if prc > 0 then do\n          'setmsg msg(isrz003)'\n          ztdsels = 1\n        end\n      end\n      Otherwise nop\n    end\n  end\n  'tbend' zcrtbl\n  drop cr.\n  return\n\nDo_Extract:\n  zcmd = null\n  crcnt = 1000\n  ocrcnt = 1000\n  zcrtbl = 'ZR'time('s')\n  ext_type = 'C'\n  call do_extract_log\n  ztdsels = 0\n  ztdtop = 1\n  tags = null\n  'tbtop' zcrtbl\n  'tbsort' zcrtbl 'fields(cdatetim,c,d)'\n  do forever\n    zsel = null\n    if ztdsels > 1\n    then 'tbdispl' zcrtbl\n    else do\n      'tbtop' zcrtbl\n      'tbskip' zcrtbl 'number('ztdtop')'\n      'tbdispl' zcrtbl 'panel(zigicomx)'\n    end\n    if rc > 4 then leave\n\n    if ztdsels = 0 then\n    if pnsdef = 'P' then\n    if crcnt = ocrcnt then do\n      if row = 0 then zcmd = 'O'\n      if row > 0 then zsel = '/'\n    end\n\n    if zsel = '/' then do\n      call pfshow 'off'           /* make sure pfshow is off */\n      'Addpop row(4) column(10)'\n      'Display Panel(zigicomo)'\n      'rempop'\n      call pfshow 'reset'         /* restore pfshow setting */\n    end\n\n    if zcmd = 'O' then do\n      zcmd = null\n      call pfshow 'off'           /* make sure pfshow is off */\n      'Addpop row(4) column(6)'\n      'Display Panel(zigicomc)'\n      'rempop'\n      call pfshow 'reset'         /* restore pfshow setting */\n    end\n\n    if crcnt /= ocrcnt then do\n      ocrcnt = crcnt\n      'tbend' zcrtbl\n      call do_extract_log\n      ztdtop = 1\n      zsel = null\n      ztdsels = 0\n      row = null\n    end\n    if row /= null then do\n      'tbtop' zcrtbl\n      'tbskip' zcrtbl    'number('row')'\n    end\n    Select\n      When abbrev('REPLACE',word(zcmd,1),1) = 1 then do\n        'tbend' zcrtbl\n        call do_extract_log\n      end\n      When abbrev('ONLY',word(zcmd,1),1) = 1 then do\n        if words(zcmd) = 1 then do\n          call pfshow 'off'           /* make sure pfshow is off */\n          'addpop row(3) column(4)'\n          'display panel(zigionly)'\n          drc = rc\n          'rempop'\n          call pfshow 'reset'         /* restore pfshow setting */\n          if drc > 0 then leave\n          zcmd = 'O' filter\n        end\n        'tbtop' zcrtbl\n        ohit = 0\n        fw = subword(zcmd,2)\n        ztdtop = 0\n        do forever\n          'tbskip' zcrtbl\n          if rc > 0 then\n          if ohit = 1 then do\n            ztdtop = 1\n            leave\n          end\n          if rc > 0 then do\n            'tbend' zcrtbl\n            call do_extract_log\n            zerrsm = 'Not Found.'\n            zerrlm = fw 'not found in the rollback log.'\n            'Setmsg msg(isrz003)'\n            ztdtop = 1\n            leave\n          end\n          ztdtop = ztdtop + 1\n          if pos(fw,translate(ctitle)) = 0 then 'tbdelete' zcrtbl\n          else ohit = 1\n        end\n      end\n      when zsel = 'X' then do\n        tags = tags ctag\n        if ztdsels = 1 then\n        call do_tag_extract\n      end\n      when zsel = 'S' then do\n        zsel = null\n        drop so. se.\n        cmd = 'cd' localrep'/'zigirep\n        cmd = cmd '&& git show -P' ctag\n        x = docmd(cmd)\n        call view_std 'B' 'V'\n      end\n      when zsel = 'R' then do\n        zcmd  = null\n        zsel  = null\n        newbr = null\n        rolla = 'Cancel'\n        call pfshow 'off'           /* make sure pfshow is off */\n        'Addpop row(4) column(12)'\n        'Display Panel(zigipoph)'\n        prc = rc\n        'Rempop'\n        call pfshow 'reset'         /* restore pfshow setting */\n        if prc > 0 then do\n          zerrsm = 'Canceled.'\n          zerrlm = 'Rollback canceled.'\n          'setmsg msg(isrz003)'\n          prc = 1\n          newbr = null\n          return\n        end\n        call get_branches\n        bad = 0\n        do bi = 1 to bl.0\n          if newbr = bl.bi then bad = 1\n        end\n        if bad = 1 then do\n          zerrsm = 'Invalid.'\n          zerrlm = newbr 'branch currently exists - pick a different' ,\n            'name for the branch and try again.'\n          'setmsg msg(isrz003)'\n          prc = 1\n          newbr = null\n        end\n        if prc = 0 then\n        if newbr /= null then do\n          cmd = 'cd' localrep'/'zigirep\n          drop combine.\n          combine.0 = 0\n          call add_combine cmd\n          x = docmd(cmd ' && git checkout -b' newbr ctag)\n          call add_combine 'git checkout -b' newbr ctag\n          call combine_msgs\n          if zigi_offline = 0 then\n          if left(remote1,1) /= '<' then do\n            cmd = 'cd' localrep'/'zigirep\n            x = docmd(cmd ' && git push origin 'newbr)\n            call add_combine 'git push origin' newbr\n            branch = newb\n            call combine_msgs\n          end\n          if combine.0 > 0 then call view_std 'C'\n          call Replace localrep zigirep pdshlq qualignr\n          call work_with_repo\n        end\n        if prc > 1 then do\n          zerrsm = 'Canceled.'\n          zerrlm = 'Rollback canceled.'\n          'setmsg msg(isrz003)'\n          ztdsels = 1\n        end\n        if prc > 1 then leave\n      end\n      Otherwise nop\n    end\n  end\n  'tbend' zcrtbl\n  drop cr.\n  return\n\nDo_Extract_Log:\n  'TBCreate' zcrtbl 'Keys(ctag) Names(cdatetim ctitle) nowrite share'\n  cmd = 'cd' localdir\n  if ext_type = 'T' then do\n    x = docmd(cmd '&& git log --cc -m -n' ocrcnt)\n    do cri = 1 to so.0\n      parse value so.cri with 'refs/tags/'ctag dow mon day time year . ctitle\n      mon = wordpos(mon,'Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec')\n      cdatetim = year'/'right(mon+100,2)'/'right(day+100,2) time\n      'tbadd' zcrtbl\n    end\n  end\n  else do\n    x = docmd(cmd \"&& git log -n\" ocrcnt \"--abbrev=commit\" ,\n      \" --pretty=format:'%H    %cd subject:%f'\")\n    do cri = 1 to so.0\n      parse value so.cri with ctag dow mon day time year . 'subject:'ctitle\n      ctag = left(ctag,7)\n      mon = wordpos(mon,'Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec')\n      cdatetim = year'/'right(mon+100,2)'/'right(day+100,2) time\n      'tbadd' zcrtbl\n    end\n  end\n  return\n\n  /* ------------------- *\n  | Grep the repository |\n  * ------------------- */\ndo_grep:\n  parse arg grepdir\n  zcmd = null\n  do forever\n    'display panel(zigigrep)'\n    if rc > 0 then leave\n    cmd = 'cd' grepdir\n    x = docmd(cmd '&& git grep -i \"'grepstr'\"')\n    select\n      when x = 1 then do\n        zerrsm = null\n        zerrlm = 'grep search found nothing.'\n        'setmsg msg(isrz003)'\n      end\n      when grepopt = 'R' then do\n        call View_std 'B'\n      end\n      when grepopt = 'D' then do\n        pdshlqt = translate(pdshlq,' ','.')\n        if qualignr > 0 then\n        pdshlqt = subword(pdshlqt,1,qualignr)\n        pdshlqt = translate(pdshlqt,'.',' ')\n        parse value '' with dsntbl gstat gcount\n        zgreptbl = 'ZG'time('s')\n        'TBCreate' zgreptbl 'Keys(gdsn) Names(gstat gcount) nowrite share'\n        do si = 1 to so.0\n          if left(so.si,1) = '.' then iterate\n          mem = null\n          parse value so.si with gdsn\":\" .\n          if pos('/',gdsn) > 0 then do\n            parse value gdsn with gdsn'/'mem':' .\n            if zdsn.gdsn /= null then\n            parse value mem with mem'.'.\n            if dsnvalid(gdsn) = 'OK'\n            then gdsn = gdsn'('mem')'\n            else gdsn = gdsn'/'mem\n          end\n          gdsnt = \"'\"pdshlqt\".\"strip(gdsn)\"'\"\n          if pos('/',gdsnt) = 0 then do\n            call outtrap 'x.'\n            if sysdsn(gdsnt) = 'OK' then gdsn = gdsnt\n            call outtrap 'off'\n          end\n          if wordpos(gdsn,dsntbl) > 0\n          then do\n            gcount = gcount + 1\n            'tbmod' zgreptbl\n          end\n          else do\n            gcount = 1\n            'tbadd' zgreptbl\n            dsntbl = dsntbl gdsn\n          end\n        end\n        ztdsels = 0\n        ztdtop = 1\n        file_changed = 0\n        'tbtop' zgreptbl\n        'tbsort' zgreptbl 'fields(gdsn,c,a)'\n        do forever\n          if ztdsels > 1\n          then 'tbdispl' zgreptbl\n          else do\n            'tbtop' zgreptbl\n            'tbskip' zgreptbl 'number('ztdtop')'\n            'tbdispl' zgreptbl 'panel(zigigrds)'\n          end\n          if rc > 4 then leave\n\n          if ztdsels = 0 then\n          if pnsdef = 'P' then do\n            if row = 0 then zcmd = 'O'\n            if row > 0 then zsel = '/'\n          end\n\n          if zsel = null then iterate\n          if row /= null then do\n            'tbtop' zgreptbl\n            'tbskip' zgreptbl  'number('row')'\n          end\n          if zsel = '/' then do\n            call pfshow 'off'           /* make sure pfshow is off */\n            'Addpop row(4) column(6)'\n            'Display Panel(zigirgrp)'\n            'rempop'\n            call pfshow 'reset'         /* restore pfshow setting */\n          end\n          if zsel = 'S' then zsel = 'E'\n          Select\n            When zsel = 'B' then do\n              if left(gdsn,1) = \"'\"\n              then do\n                'Browse dataset('gdsn')'\n                gstat = '*Browse'\n              end\n              else do\n                Address TSO 'OBrowse' grepdir'/'gdsn\n                gstat = '*OBrowse'\n              end\n              'tbmod' zgreptbl\n            end\n            When zsel = 'E' then do\n              if left(gdsn,1) = \"'\"\n              then do\n                'Edit dataset('gdsn')'\n                gstat = '*Edit'\n                if rc = 0 then file_changed = 1\n              end\n              else do\n                ofile = grepdir'/'gdsn\n                'Edit file(ofile)'\n                gstat = '*Edit'\n                if rc = 0 then file_changed = 1\n              end\n              'tbmod' zgreptbl\n            end\n            When zsel = 'V' then do\n              if left(gdsn,1) = \"'\"\n              then do\n                'View dataset('gdsn')'\n                gstat = '*View'\n              end\n              else do\n                ofile = grepdir'/'gdsn\n                'View file(ofile)'\n                gstat = '*View'\n              end\n              'tbmod' zgreptbl\n            end\n            Otherwise nop\n          end\n          zsel = null\n        end\n        'tbend' zgreptbl\n        zsel = null\n        if file_changed = 1 then call update_repo_metadata\n      end\n      otherwise nop\n    end\n  end\n  return\n\n  /* ---------------------- *\n  | Display the git Status |\n  * ---------------------- */\nDo_Status:\n  zcmd = null\n  cmd = 'cd' localrep'/'zigirep\n  x = docmd(cmd '&& git status')\n  call view_std\n  return\n\n  /* ------------------- *\n  | Display the Git Log |\n  * ------------------- */\nDo_GitLog:\n  zcmd = null\n  call pfshow 'off'           /* make sure pfshow is off */\n  'vget (lcnt logdfrom logdto greplog lbv incldiff) profile'\n  if incldiff = null then incldiff = 'N'\n  'Addpop row(4) column(6)'\n  'Display Panel(zigilog)'\n  drc = rc\n  'Rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  if drc = 0 then do\n    lopts = null\n    if incldiff = 'Y' then lopts = '--cc -m'\n    if lcnt /= null then lopts = lopts '-n' lcnt\n    if logdfrom /= null then lopts = lopts '--after=\"'logdfrom'\"'\n    if logdto   /= null then lopts = lopts '--until=\"'logdto'\"'\n    if greplog /= null then lopts = lopts '--grep='greplog '-i'\n    lopts = translate(lopts,'-','/')\n    cmd = 'cd' localdir' && git log' lopts\n    'vput (lcnt logdfrom logdto greplog lbv incldiff) profile'\n    x = docmd(cmd)\n    htitle = 'GitLog Results'\n    'vput (htitle)'\n    if so.0 + se.0 > 1\n    then call view_std 'X' lbv\n    else do\n      zerrsm = null\n      zerrlm = 'GitLog filters resulted in an empty report.'\n      'setmsg msg(isrz003)'\n    end\n  end\n  return\n\n  /* ----------------------------------------------- *\n  | Reset USERIDs for all members                   |\n  | May be called with a userid to be used and that |\n  | will bypass the prompt.                         |\n  * ----------------------------------------------- */\nDo_Resetid:\n  arg resetid\n  if resetid = null then do\n    call pfshow 'off'\n    'Addpop row(4) column(12)'\n    'display panel(zigirsid)'\n    xrc = rc\n    'Rempop'\n    call pfshow 'reset'\n  end\n  else xrc = 0\n  if xrc = 0 then do\n    save_top = ztdtop\n    'tbtop' rtll\n    \"LMINIT DATAID(zstats) DATASET(\"fulldsn\")\"\n    \"LMOPEN DATAID(\"zstats\") OPTION(INPUT)\"\n    do forever\n      'tbskip' rtll\n      if rc > 3 then leave\n      if zluser = resetid then iterate\n      zluser = resetid\n      'LMMSTATS DATAID('zstats') Member('mem') user('zluser')'\n      'tbput' rtll\n    end\n    \"LMClose Dataid(\"zstats\")\"\n    \"LMFree  Dataid(\"zstats\")\"\n    ztdtop = save_top\n    statfile = translate(strip(fulldsn,'B',\"'\"),' ','.')\n    if qualignr > 0 then\n    statfile = subword(statfile,qualignr+1)\n    statfile = translate(statfile,'.',' ')\n    x = zigistat(fulldsn localrep'/'zigirep'/.zigi/'statfile 'S')\n    statfiles = usssafe(statfile)\n    x = docmd('cd' localrep'/'zigirep '&& git add .zigi/'statfiles)\n  end\n  return\n\n  /* ------------------------ *\n  | Do the Commit Processing |\n  * ------------------------ */\nDo_Commit:\n  arg copt\n  x = debug('Starting Commit:' zigirep)\n  parse value '' with tagid msg1 cmsg file zcmd\n  cmtab = 'zc'random(99999)\n  'tbcreate' cmtab 'names(cmsg) nowrite'\n  if datatype(m.0) = 'NUM' then do\n    if copt /= null then do\n      msg1 = m.1\n      do dci = 2 to m.0\n        cmsg = m.dci\n        'tbadd' cmtab\n      end\n    end\n    cmsg = null\n  end\n  do dci = 1 to 15\n    'tbadd' cmtab\n  end\n  drop m.\n  ctop = 0\n  ztdmark = Center('Use F3 to Continue - Cancel if Title blank',79,'-')\n  do forever\n    if ztdsels > 1 then 'tbdispl' cmtab\n    else do\n      parse value '' with zsel zcmd\n      'tbtop' cmtab\n      'tbskip' cmtab 'number('ctop')'\n      'tbdispl' cmtab 'panel(zigicom)'\n    end\n    if rc > 4 then leave\n    if translate(zcmd) = 'CANCEL' then leave\n    ctop = ztdtop\n    if datatype(right(zcmd,1)) = 'NUM' then\n    zcmd = left(zcmd,1) substr(zcmd,2)\n    if zcmd /= null then\n    Select\n      When abbrev('IMPORT',word(translate(zcmd),1),2) = 1\n      then call commit_import\n      When abbrev('INSERT',translate(word(zcmd,1)),1) = 1 then do\n        c = word(zcmd,2)\n        if c = null then c = 1\n        'tbquery' cmtab 'rownum(cr)'\n        'tbtop' cmtab\n        'tbskip' cmtab 'number('cr')'\n        cmsg = ' '\n        do ix = 1 to c\n          'tbadd' cmtab\n        end\n      end\n      Otherwise nop\n    end\n    select\n      when zsel = 'D' then 'tbdelete' cmtab\n      when left(zsel,1) = 'D' & length(zsel) > 1 then do\n        dc = substr(zsel,2)\n        if datatype(dc) /= 'NUM' then dc = 1\n        do ix = 1 to dc\n          'tbdelete' cmtab\n          'tbskip' cmtab\n        end\n      end\n      when zsel = 'I' then do\n        cmsg = ' '\n        'tbadd' cmtab\n      end\n      when left(zsel,1) = 'I' then do\n        c = substr(zsel,2,1)\n        if datatype(c) /= 'NUM' then c = 1\n        cmsg = ' '\n        do i = 1 to c\n          'tbadd' cmtab\n        end\n      end\n      when zsel = null then\n      'tbput' cmtab\n      Otherwise if zsel /= null then do\n        zerrsm = 'Invalid.'\n        zerrlm = zsel 'is an invalid line selection. Try again with a valid' ,\n          'line selection of I, I#,or D.'\n        'setmsg msg(isrz003)'\n      end\n    end\n  end\n\n  drop ztdmark\n\n  if translate(zcmd) = 'CANCEL' then msg1 = null\n  if strip(msg1) = null then do\n    x = debug('Commit canceled:' zigirep)\n    zerrsm = 'Canceled.'\n    zerrlm = 'Commit canceled due to an empty title message.'\n    'setmsg msg(isrz003)'\n    'tbend' cmtab\n    drop m.\n    return\n  end\n\n  zs1 = 'Commit processing started.'\n  zs2 = null\n  call do_popup\n\n  /* find last row */\n  'tbbottom' cmtab\n  do forever\n    'tbskip' cmtab 'number(-1)'\n    if rc > 0 then leave\n    if strip(cmsg) /= null then leave\n  end\n  'tbquery' cmtab 'position(lastrow)'\n\n  cmsg.1 = value('msg1')\n  cmsg.2 = left('-',length(cmsg.1),'-')\n  io = 2\n\n  'tbtop' cmtab\n  if lastrow > 0 then\n  do forever\n    'tbskip' cmtab\n    if rc > 0 then leave\n    'tbquery' cmtab 'position(crp)'\n    io = io + 1\n    cmsg.io = strip(cmsg,'T') ' '\n    if crp = lastrow then leave\n  end\n  cmsg.0 = io\n\n  'tbend' cmtab\n\n  if defruid /= null then call fixup_userids\n  drop combine.\n  combine.0 = 0\n  /* ------------------------------- *\n  | If > 1 msg line then use a file |\n  * ------------------------------- */\n  if io > 2 then do\n    file = 'cmsg'random(999)\n    fdd  = file\n    if sysvar('syspref') = null\n    then filem = sysvar('sysuid')'.'file\n    else filem = file\n    file = localrep'/'file\n    file = \"'\"file\"'\"\n    address tso\n    'alloc f('fdd') new spa(1,1) tr recfm(f b) lrecl(72) blksize(0)',\n      'ds('filem')'\n    'execio * diskw' fdd '(finis stem cmsg.'\n    'free  f('fdd')'\n    call outtrap 'x.'\n    'oput' filem file 'Text'\n    'delete' filem\n    call outtrap 'off'\n    address ispexec\n    cmd = 'cd' localrep'/'zigirep\n    cmd = cmd '&& git commit -F' file\n    if zigi_offline = 0 then\n    if zpush = 'Y' then\n    cmd = cmd '&& git push -v'\n    cmd = cmd '&& rm' file\n    x = docmd(cmd)\n    call add_combine cmd\n    call combine_msgs\n  end\n  /* ------------------------------------- *\n  | If cmsg.0 = 2 then use commit -m msg   |\n  | remove quotes for this msg             |\n  * -------------------------------------- */\n  else do\n    cmsg.1 = translate(cmsg.1,' ',\"'\" '\"')\n    cmd = 'cd' localrep'/'zigirep\n    cmd = cmd \"&& git commit -vm '\"cmsg.1\"'\"\n    if zigi_offline = 0 then\n    if zpush = 'Y' then\n    cmd = cmd '&& git push -v'\n    x = docmd(cmd)\n    call add_combine cmd\n    call combine_msgs\n  end\n  if tagid /= null then do\n    parse value so.1 with '\u00dd'.  ctag'\u00a8' .\n    cmd = 'cd' localrep'/'zigirep\n    cmd = cmd '&& git tag' tagid ctag\n    if zigi_offline = 0 then\n    if remote1 /= '<no remote defined>' then\n    cmd = cmd '&& git push origin' tagid\n    cmd = cmd '&& git show' tagid\n    x = docmd(cmd)\n    call add_combine cmd\n    call combine_msgs\n  end\n  if x > 0 then do\n    call view_std 'C'\n  end\n  if left(remote1,1) /= '<' then\n  if zpush = 'N' then do\n    zerrsm = 'Push Needed.'\n    zerrlm = 'The commit has completed and a push is now required to' ,\n      'update the Git remote repository.'\n    if zigi_offline = 1 then\n    zerrlm = zerrlm 'Which will require not being in Offline mode.'\n    'setmsg msg(isrz003)'\n  end\n  x = debug('Commit completed:' zigirep)\n  drop m. cmsg.\n  call update_repo_metadata\n  return\n\n  /* ---------------------------------------------------------- *\n  | Import the Commit Prose from a dataset.                    |\n  |                                                            |\n  | If the Import command has no dataset then display popup.   |\n  | If the import dataset is not valid then display the popup. |\n  * ---------------------------------------------------------- */\nCommit_Import:\n  parse value zcmd with imp comimprt .\n  zcmd = null\n  com_prompt = 0\n  if strip(comimprt) = null then com_prompt = 1\n  else do\n    x = sysdsn(comimprt)\n    if x /= 'OK' then do\n      com_prompt = 1\n      zerrsm = 'Error.'\n      zerrlm = left(comimprt,76) x\n      'setmsg msg(isrz003)'\n    end\n  end\n  if com_prompt = 1 then do\n    call pfshow 'off'           /* make sure pfshow is off */\n    'addpop row(3) column(4)'\n    'display panel(zigicimp)'\n    drc = rc\n    'rempop'\n    call pfshow 'reset'         /* restore pfshow setting */\n    if drc > 0 then return\n  end\n  cdd = 'CI'time('s')\n  Address TSO\n  'Alloc f('cdd') shr reuse ds('comimprt')'\n  'Execio * diskr' cdd '(finis stem cddin.'\n  'Free  f('cdd')'\n  Address ISPExec\n  'tbbottom' cmtab\n  do forever\n    'tbskip' cmtab 'number(-1)'\n    if rc > 0 then leave\n    if strip(cmsg) /= null then leave\n  end\n  'tbquery' cmtab 'position(lastrow)'\n  do cinp = 1 to cddin.0\n    cmsg = cddin.cinp\n    'tbadd' cmtab\n  end\n  'tbtop' cmtab\n  drop cddin.\n  return\n\n  /* ------------------------------------------------------ *\n  | If the default userid is not null then                 |\n  | 1. git status to see what pds files were modified      |\n  | 2. reset the userids in all pds files                  |\n  * ------------------------------------------------------ */\nfixup_userids:\n  cmd = 'cd' localrep'/'zigirep  '&& git status'\n  x = docmd(cmd)\n  dsns = null\n  members. = null\n  hlq = translate(pdshlq,' ','.')\n  if qualignr > 0 then\n  hlq = subword(hlq,1,qualignr)\n  hlq = translate(hlq,'.',' ')\n  do iw = 1 to so.0\n    if word(so.iw,1) = 'Untracked' then leave\n    if word(so.iw,1) = 'Changes not' then leave\n    if left(so.iw,1) /= '05'x then iterate\n    if pos('new file',so.iw) = 0\n    then parse value so.iw with . file .\n    else parse value so.iw with . . file .\n    if left(file,1) = '.' then iterate\n    if pos('/',file) > 0 then parse value file with file'/'mem\n    if dsnvalid(file) = 'NO' then iterate\n    if wordpos(file,dsns) = 0 then do\n      dsns = dsns file\n    end\n    members.file = members.file mem\n  end\n  do iw = 1 to words(dsns)\n    file = word(dsns,iw)\n    workdsn = \"'\"hlq\".\"file\"'\"\n    x = listdsi(workdsn)\n    if sysdsorg /= 'PO' then iterate\n    \"LMINIT DATAID(reset) DATASET(\"workdsn\")\"\n    \"LMOPEN DATAID(\"reset\") OPTION(INPUT)\"\n    do im = 1 to words(members.file)\n      member = word(members.file,im)\n      if pos('.',member) > 0 then\n      parse value member with member'.' .\n      \"LMMFind DATAID(\"reset\") Member(\"member\") STATS(YES)\"\n      if rc > 7 then iterate\n      if zluser /= defruid then do\n        'LMMSTATS DATAID('reset') Member('member') user('defruid')'\n      end\n    end\n    \"LMClose Dataid(\"reset\")\"\n    \"LMFree  Dataid(\"reset\")\"\n    statfile = translate(strip(workdsn,'B',\"'\"),' ','.')\n    if qualignr > 0 then\n    statfile = subword(statfile,qualignr+1)\n    statfile = translate(statfile,'.',' ')\n    x = zigistat(workdsn localrep'/'zigirep'/.zigi/'statfile 'S')\n    dir = localrep'/'zigirep\n    statfiles = usssafe(statfile)\n    x = docmd('cd' dir '&& git add .zigi/'statfiles)\n    if x > 0 then\n    call view_std 'B'\n  end\n  return\n\n  /* ---------------------------------- *\n  | Push the updates to the remote git |\n  * ---------------------------------- */\nDo_Push:\n  arg opt\n  call pop 'Pushing Updates to Remote Git'\n  cmd = 'cd' localdir' && git push -v'\n  x = docmd(cmd)\n  if x > 0 then do\n    call view_std 'B'\n  end\n  call update_repo_metadata\n  return\n\n  /* ----------------------------- *\n  | Clone a remote repo           |\n  * ----------------------------- */\nClone_Repo:\n  if zigi_offline = 1 then do\n    zerrsm = 'Offline.'\n    zerrlm = 'Clone is not allowed when offline.'\n    'Setmsg msg(isrz003)'\n    return\n  end\n  parse value '' with pdshlq remotebr defcpush defruid zigicat reponame\n  'vget (saverep) profile'\n  if saverep /= null then localrep = saverep\n  do forever\n    zcmd = null\n    remote = null\n    c_stat = 0\n    cc_rc = 0\n    'Display Panel(zigicc)'\n    if rc > 0 then return\n    if localrep = \"?\" then\n    localrep = zigiosel()\n    if strip(localrep) = null then do\n      zerrsm = 'Canceled.'\n      zerrlm = 'Clone canceled as OMVS directory selection canceled.'\n      'Setmsg msg(isrz003)'\n      return 1\n    end\n    saverep = localrep\n    'vput (saverep) profile'\n    parsedURI = parseGitURI(remote)\n    parse var parsedURI guser host port zigirep '.git'\n    if port /= 22 then extrabits = '-p 'port\n    else extrabits = null\n    /* Let's clone the remote repo... */\n    zs1 = \"Cloning \"zigirep\" by \"owner\n    zs2 = \"from \"host\n    call do_popup\n    cmd = 'touch 'home'/.ssh/known_hosts && '\n    cmd = cmd 'ssh-keyscan 'extrabits' -t rsa,dsa 'host\n    cmd = cmd ' 2>&1 | sort -u - 'home'/.ssh/known_hosts >'\n    cmd = cmd ' 'home'/.ssh/tmp_hosts && '\n    cmd = cmd 'mv 'home'/.ssh/tmp_hosts 'home'/.ssh/known_hosts'\n    x = docmd(cmd)\n    localrep = strip(localrep,'T','/')\n    x = time('r')  /* begin timer */\n    cmd = 'cd 'localrep\n    if remotebr = null\n    then cmd = cmd ' && git clone -v 'remote reponame\n    else cmd = cmd ' && git clone -vb' remotebr remote reponame\n    x = docmd(cmd)\n    if x > 0 then do\n      c_stat = 1\n      call view_std 'B'\n      Address ISPExec\n      return\n    end\n    if reponame /= null then zigirep = reponame\n    else reponame = zigirep\n    /* Check to see if this is a ZIGI-managed repo */\n    cmd = '\u00dd\u00dd ! -d 'localrep'/'zigirep'/.zigi \u00a8\u00a8 && echo 0'\n    x = docmd(cmd)\n    if so.0 = 1 & so.1 = 0 then do\n      call pfshow 'off'           /* make sure pfshow is off */\n      'Addpop row(4) column(7)'\n      'Display Panel(zigipopn)'\n      'Rempop'\n      call pfshow 'reset'         /* restore pfshow setting */\n      'Select pgm(isptutor) parm(zigih800)'\n      non_zigi = 1\n    end\n    else non_zigi = 0\n    Address ISPExec\n    if c_stat = 1 then return\n    qualignr = words(translate(pdshlq,' ','.'))\n    if non_zigi = 0 then\n    call Replace localrep zigirep pdshlq qualignr '\\ Clone'\n    zigikey = localrep'/'zigirep\n    zigidate = date('n')\n    call set_sortdate\n    'tbadd zigirepo order'\n    'vget (defrsort srr src srp srl) profile'\n    'TBSort zigirepo Fields('defrsort')'\n    'TBSAVE zigirepo REPLCOPY LIBRARY('isptabl')'\n    leave\n  end\n  e_time = time(\"E\")\n  parse value e_time with ss \".\" uu\n  numeric digits 6\n  mm = ss % 60   /* get minutes integer */\n  ss = ss // 60  /* get seconds integer */\n  uu = uu // 100 /* get micro seconds integer */\n  cltime = right(mm+100,2)':'right(ss+100,2)'.'right(uu+100,2)\n  call work_with_repo\n  return\n\n  /* -------------------------------- *\n  | Add Member to Git for Committing |\n  * -------------------------------- */\nGit_Add_Member:\n  /* The member 'can' have an extension in the local-repo\n  of course this information is not present in the member-name\n  as shown in the table. So we 'should' check the dsn-info file\n  and check if it has an extension (and if so which one).\n  */\n  repodir = localrep'/'zigirep\n  x = docmd(\"cat '\"repodir\"/.zigi/dsn'\")\n  extension = null\n  do cki = 1 to so.0\n    if left(so.cki,1) = '#' then iterate\n    if word(so.cki,1) = '*' then do\n      parse value so.cki with . def_dsorg def_recfm def_lrecl def_blksiz e .\n    end\n    else do\n      idsn = word(so.cki,1)        /* dataset name less hlq */\n      if idsn = dsn then do\n        if word(so.cki,6) <> \"\" then do\n          /* we have an extension for this library */\n          extension = word(so.cki,6)\n          leave\n        end\n      end\n    end\n  end\n\n  d = usssafe(dsn)\n  cmd = 'cd' repodir\n\n  if extension \\= null then do\n    /* so we have an extension, better add correctly */\n    toadd = lower(usssafe(mem))'.'extension\n  end\n  else do\n    /* regular add */\n    toadd = usssafe(mem)\n  end\n  x = docmd(cmd ' && git add -v 'd'/'toadd)\n  call update_mem_stats d'/'toadd mem\n  zigi_changed = 1\n  return\n\n  /* ---------------------------------- *\n  | Update stats file after member add |\n  * ---------------------------------- */\nGit_Add_Member_Stats:\n  statfile = translate(strip(fulldsn,'B',\"'\"),' ','.')\n  x = debug('Add member stats:' statfile)\n  if qualignr > 0 then\n  statfile = subword(statfile,qualignr+1)\n  statfile = translate(statfile,'.',' ')\n  cmd = 'cd' localrep'/'zigirep'/.zigi/'\n  statfiles = usssafe(statfile)\n  x = cmd '&& git add -v 'statfiles\n  x = docmd(cmd)\n  x = zigistat(fulldsn ,\n    localrep'/'zigirep'/.zigi/'statfiles 'S')\n  statfiles = usssafe(statfile)\n  x = docmd('cd' localrep'/'zigirep '&& git add .zigi/'statfiles)\n  call work_with_repo_file\n  x = debug('Add member stats completed.')\n  return\n\n  /* ------------------------- *\n  | Copy a PS dataset to OMVS |\n  * ------------------------- */\nEdit_PS:\n  arg noedit\n  edsn = strip(fulldsn,'B',\"'\")\n  /* Do this if it's a regular file (sequential in z/OS) */\n  if is_binfile(dsn) = 1 then do\n    zerrsm = 'Invalid'\n    zerrlm = 'Unable to Edit a binary dataset.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  \"Edit Dataset('\"edsn\"')\"\n  /* so after the edit, we should update it to working directory */\n  if rc = 0 then do\n    edsn = usssafe(edsn)\n    copcm = \"//'\"edsn\"'\"\n    /* -M was replaced with -v in all CP commands */\n    copcm = 'cp -U -v \"'copcm'\" 'localrep'/'zigirep'/'usssafe(dsn)\n    x = docmd(copcm)\n    if x > 0 then call view_std 'B'\n    if ztdsels < 2 then\n    call update_repo_metadata\n  end\n  return\n\n  /* ------------------------------- *\n  | Sort the member list (zigilist) |\n  * ------------------------------- */\nDo_LSort:\n  parse value zcmd with x sort_field sort_order sf sc\n  save_lsorto\n  zcmd = null\n  if sort_field = null then do\n    call pfshow 'off'           /* make sure pfshow is off */\n    'Addpop row(4) column(6)'\n    'Display Panel(zigilsrt)'\n    drc = rc\n    'Rempop'\n    call pfshow 'reset'         /* restore pfshow setting */\n    if drc > 0 then return\n    sort_field = sf\n    sort_order = sc\n  end\n  if sort_order = null then\n  if save_lsorto = null then do\n    sort_order = 'A'\n  end\n  else do\n    if save_lsorto = 'A' then sort_order = 'D'\n    else sort_order = 'A'\n  end\n  save_lsorto = sort_order\n  /* support abbreviations in field names */\n  Select\n    When abbrev('MEMBER',sort_field,2) = 1 then sort_field = 'MEMBER'\n    When abbrev('STATUS',sort_field,2) = 1 then sort_field = 'STATUS'\n    When abbrev('SIZE',sort_field,2)   = 1 then sort_field = 'SIZE'\n    When abbrev('DATE',sort_field,2)   = 1 then sort_field = 'DATE'\n    When abbrev('TIME',sort_field,2)   = 1 then sort_field = 'TIME'\n    When abbrev('USERID',sort_field,2) = 1 then sort_field = 'USERID'\n    Otherwise nop\n  end\n  /* 1st validate sort_field */\n  if wordpos(sort_field,'MEMBER STATUS SIZE DATE TIME USERID') = 0\n  then do\n    zerrsm = 'Invalid.'\n    zerrlm = sort_field 'is an invalid sort field. Valid names are:' ,\n      'MEMBER STATUS SIZE DATE TIME USERID'\n    'Setmsg msg(isrz003)'\n    return\n  end\n  /* 2nd validate the sort_order A or D */\n  if pos(sort_order,'AD') = 0 then do\n    zerrsm = 'Invalid.'\n    zerrlm = sort_order 'is an invalid sort order. Must be either' ,\n      'A for ascending or D for descending.'\n    'Setmsg msg(isrz003)'\n    return\n  end\n  sw = wordpos(sort_field,'MEMBER STATUS SIZE DATE TIME USERID')\n  sort_field = subword('mem memstat zlcnorc zlm4date zlmtime zluser',sw,1)\n  if sw = 3 then sort_type = 'N'\n  else sort_type = 'C'\n  if sort_field /= zlm4date\n  then 'tbsort' rtll 'fields('sort_field','sort_type','sort_order')'\n  else 'tbsort' rtll 'fields('sort_field','sort_type','sort_order',' ,\n    'zlmtime,'sort_type','sort_order')'\n  return\n\n  /* ----------------------------- *\n  | Replace z/OS side of repo     |\n  * ----------------------------- */\nReplace:\n  parse arg r_localrep r_zigirep r_pdshlq r_qualignr r_pulldsns '\\' r_type\n  replace_state = 0\n  ckotdir = r_localrep'/'r_zigirep\n  if r_qualignr /= '*' then\n  if datatype(r_qualignr) /= 'NUM' then r_qualignr = 0\n  if r_qualignr = 0\n  then ckothlq = null\n  else do\n    ckothlq = translate(r_pdshlq,' ','.')\n    if r_qualignr /= '*' then\n    ckothlq = subword(ckothlq,1,r_qualignr)\n    ckothlq = translate(ckothlq,'.',' ')'.'\n  end\n  ckotqual = r_qualignr\n  pulldsns = r_pulldsns\n  newhlq = null\n  if wordpos(r_type,'CLONE') > 0 then do\n    x = check_replace()\n    if x > 0 then do\n      zerrsm = 'Cancelled.'\n      zerrlm = 'z/OS Dataset Update cancelled.'\n      'Setmsg Msg(isrz003)'\n      return\n    end\n    if x = 0 then\n    if newhlq /= null then do\n      pdshlqw = words(translate(pdshlq,' ','.'))\n      newhlqw = words(translate(newhlq,' ','.'))\n      if newhlqw > pdshlqw then do\n        iqn = newhlqw - pdshlqw + r_qualignr\n        pdshlq = newhlq\n        qualignr = r_qualignr\n        if iqn /= null then qualignr = iqn\n        'tbmod zigirepo'\n        call replace r_localrep r_zigirep pdshlq qualignr r_pulldsns '\\' r_type\n        return\n      end\n    end\n  end\n  'vput (ckotdir ckothlq pulldsns ckotqual)'\n  'Select cmd(%zigickot)'\n  'vget (badckot) shared'\n  if badckot = 1 then do\n    zerrsm = 'Failed.'\n    zerrlm = 'z/OS Dataset Update failed due to one, or more, of the' ,\n      'target datasets are allocated. Free those allocations and' ,\n      'try again.'\n    'Setmsg Msg(isrz003)'\n    'verase (badckot) shared'\n    replace_state = 1\n  end\n  return\n\n/* -------------------------------------------------------- *\n | Check the datasets to be replaced and prompt the user to |\n | confirm they really REALLY want to replace them.         |\n * -------------------------------------------------------- */\nCheck_Replace:\n  cmd = 'cd' ckotdir '&& ls -l'\n  x = docmd(cmd)\n  cr_files  = null\n  iqn = null\n  do i = 2 to so.0\n    cfile = word(so.i,9)\n    cfile = \"'\"ckothlq\"\"cfile\"'\"\n    if dsnvalid(cfile) /= 'OK' then iterate\n    if sysdsn(cfile) = 'OK' then\n    cr_files = cr_files cfile\n  end\n  if strip(cr_files) = null then return 0\n  crtbl = 'CRT'random(9999)\n  'tbcreate' crtbl 'names(cfile) nowrite'\n  do i = 1 to words(cr_files)\n    cfile = word(cr_files,i)\n    'tbadd' crtbl\n  end\n  'tbtop' crtbl\n  'tbdispl' crtbl 'panel(zigicrds)'\n  drc = rc\n  'tbend' crtbl\n  if drc > 0 then return 3\n  return 0\n\n  /* ----------------------------- *\n  | Branch management             |\n  * ----------------------------- */\nBranch_it:\n  if rtbb_open = 1 then 'tbend' rtbb\n  'TBCreate' rtbb 'keys(bname) Names(brstatus) Replace NoWrite'\n  rtbb_open = 1\n  localdir = localrep'/'zigirep\n  if zigi_offline = 0 then do\n    cmd = ' && git remote prune origin > /dev/null 2>&1 && git branch -a'\n    x = docmd('cd 'localdir cmd)\n  end\n  else parse value '0 0' with so.0 se.0\n  if so.0 + se.0 = 0 then do\n    cmd = '&& git branch -a'\n    x = docmd('cd 'localdir cmd)\n  end\n  bl. = null\n  bl.0 = 0\n  do bri = 1 to so.0\n    b1 = strip(so.bri,'B')\n    if pos('/',b1) > 0 then do\n      /* this is a remote branch we (maybe) have never checked out */\n      seen_this_branch = 0\n      parse var b1 remotes'/'origin'/'bname zooi\n      bname = strip(bname)\n      do ii = 1 to bl.0\n        if bl.ii = bname then seen_this_branch = 1\n      end\n      if seen_this_branch = 1 then do\n        sbname = bname\n        'tbtop' rtbb\n        do forever\n          'tbskip' rtbb\n          if rc > 0 then leave\n          if sbname = bname then do\n            brstatus = 'Local/Remote'\n            'tbmod' rtbb\n            leave\n          end\n        end\n      end\n      /* but only add it to table if we haven't yet */\n      if seen_this_branch = 0 then do\n        if bname <> branch & bname <> \"HEAD\" then do\n          ni = bl.0 + 1\n          bl.ni = bname\n          bl.0 = ni\n          brstatus = 'Remote'\n          'tbadd' rtbb\n        end\n      end\n    end\n    else do\n      /* this is already a local branch */\n      if pos('*',b1) = 0 then do\n        /* Add it to the table if it's not the current (*) branch */\n        bname = strip(so.bri)\n        ni = bl.0 + 1\n        bl.ni = b1\n        bl.0 = ni\n        brstatus = 'Local'\n        'tbadd' rtbb\n      end\n    end\n  end\n  'tbsort' rtbb 'fields(bname,c,a)'\n  'tbtop' rtbb\n  save_btop = 0\n  do forever\n    zcmd = null\n    cc_rc = 0\n    newb = null\n    zsel = null\n    if save_btop > 0 then do\n      'tbtop' rtbb\n      'tbskip' rtbb 'number('save_btop')'\n    end\n    'tbdispl' rtbb 'panel(zigibra)'\n    if rc > 4 then leave\n    save_btop = ztdtop\n    if abbrev('GITHELP',word(zcmd,1),4) = 1 then\n    Address TSO '%githelp' subword(zcmd,2)\n    if newb <> null then do\n      /* ----------------------------- *\n      | Create this new branch, switch|\n      * ----------------------------- */\n      bad = 0\n      do bi = 1 to bl.0\n        if newb = bl.bi then bad = 1\n      end\n      if bad = 1 then do\n        zerrsm = 'Invalid.'\n        zerrlm = newb 'branch already exists - select a new name.'\n        'setmsg msg(isrz003)'\n      end\n      else do\n        localdir = localrep'/'zigirep\n        x = docmd('cd 'localdir' && git checkout -b 'newb)\n        /* TODO only do this when there is a remote? */\n        if zigi_offline = 0 then\n        x = docmd('cd 'localdir' && git push -u origin 'newb)\n        branch = newb\n        leave\n      end\n    end\n    /* ----------------------------- *\n    | Checkout the selected bname   |\n    * ----------------------------- */\n    if zsel = \"C\" then do\n      x = check_clean()\n      if x = 'NO' then do\n        zs1 = 'Cannot checkout branch as it is not clean.'\n        zs2 = 'Use the Status command and fix then try again.'\n        call pfshow 'off'           /* make sure pfshow is off */\n        'Addpop row(4) column(8)'\n        'Display Panel(zigipop)'\n        'Rempop'\n        call pfshow 'reset'         /* restore pfshow setting */\n        call view_std 'B'\n      end\n      else do\n        call check_branch_delta\n        call update_repo_metadata\n        branch = bname\n      end\n      leave\n    end\n    if zsel = \"D\" then do\n      if brstatus = 'Remote' then do\n        zerrsm = 'Invalid.'\n        zerrlm = 'Unable to delete a remote only branch.' ,\n          'That can only be done at the remote repository.'\n        'setmsg msg(isrz003)'\n      end\n      else do\n        call pfshow 'off'           /* make sure pfshow is off */\n        'Addpop row(4) column(6)'\n        'display panel(zigibrdq)'\n        drc = rc\n        'Rempop'\n        call pfshow 'reset'         /* restore pfshow setting */\n        if ans = 'N' then drc = 4\n        if drc > 0 then do\n          ans = 'N'\n          zerrsm = 'Canceled.'\n          zerrlm = 'Branch delete canceled.'\n          'setmsg msg(isrz003)'\n        end\n        if ans = 'Y' then do\n          x = docmd('cd 'localdir' && git branch -D 'bname)\n          if pos('Remote',brstatus) = 0 then do\n            'tbdelete' rtbb\n            zerrsm = 'Deleted.'\n            zerrlm = 'Branch 'bname' succesfully deleted'\n            'Setmsg msg(isrz003)'\n          end\n          else do\n            zerrsm = 'Local Deleted.'\n            zerrlm = 'Branch 'bname' succesfully deleted from the local' ,\n              'repository but remains on the remote.'\n            'Setmsg msg(isrz003)'\n            brstatus = 'Remote'\n            'tbmod' rtbb\n          end\n        end\n      end\n    end\n  end\n  'tbend' rtbb\n  rtbb_open = 0\n  ztdsels = 0\n  zsel = null\n  call update_repo_metadata /* to reflect status after branch */\n  return\n\n  /* ----------------------------- *\n  | Merging things...             |\n  * ----------------------------- */\nMerge_it:\n  'tbquery' rtbm\n  if rc = 0 then 'tbend' rtbm\n  'TBCreate' rtbm 'keys(bname) Names(brstatus) Replace NoWrite'\n  localdir = localrep'/'zigirep\n  zsel = null\n  if zigi_offline = 0 then do\n    cmd = ' && git remote prune origin > /dev/null 2>&1 && git branch -a'\n    x = docmd('cd 'localdir cmd)\n  end\n  else parse value '0 0' with so.0 se.0\n  if so.0 + se.0 = 0 then do\n    cmd = '&& git branch -a'\n    x = docmd('cd 'localdir cmd)\n  end\n  bl. = null\n  bl.0 = 0\n  do bri = 1 to so.0\n    b1 = strip(so.bri,'B')\n    if pos('/',b1) > 0 then do\n      /* this is a remote branch we (maybe) have never checked out */\n      seen_this_branch = 0\n      parse var b1 remotes'/'origin'/'bname zooi\n      bname = strip(bname)\n      do ii = 1 to bl.0\n        if bl.ii = bname then seen_this_branch = 1\n      end\n      if seen_this_branch = 1 then do\n        sbname = bname\n        'tbtop' rtbm\n        do forever\n          'tbskip' rtbm\n          if rc > 0 then leave\n          if sbname = bname then do\n            brstatus = 'Local/Remote'\n            'tbmod' rtbm\n            leave\n          end\n        end\n      end\n      /* but only add it to table if we haven't yet */\n      if seen_this_branch = 0 then do\n        if bname <> branch & bname <> \"HEAD\" then do\n          ni = bl.0 + 1\n          bl.ni = bname\n          bl.0 = ni\n          brstatus = 'Remote'\n          'tbadd' rtbm\n        end\n      end\n    end\n    else do\n      /* this is already a local branch */\n      if pos('*',b1) = 0 then do\n        /* Add it to the table if it's not the current (*) branch */\n        bname = strip(so.bri)\n        ni = bl.0 + 1\n        bl.ni = b1\n        bl.0 = ni\n        brstatus = 'Local'\n        'tbadd' rtbm\n      end\n    end\n  end\n  'tbsort' rtbm 'fields(bname,c,a)'\n  'tbtop' rtbm\n  save_btop = 0\n  do forever\n    zcmd = null\n    cc_rc = 0\n    newb = null\n    zsel = null\n    if save_btop > 0 then do\n      'tbtop' rtbm\n      'tbskip' rtbm 'number('save_btop')'\n    end\n    'tbdispl' rtbm 'panel(zigimer)'\n    if rc > 4 then leave\n    save_btop = ztdtop\n    if abbrev('GITHELP',word(zcmd,1),4) = 1 then\n    Address TSO '%githelp' subword(zcmd,2)\n    /* ----------------------------- *\n    | Checkout the selected bname   |\n    * ----------------------------- */\n    if zsel = \"M\" then do\n      /* ----------------------------------------- */\n      /* Get the delta of the elements between the */\n      /* branches being merged.                    */\n      /* ----------------------------------------- */\n      cmd = 'cd 'localdir\n      cmd = cmd '&& git diff --name-status' branch'..'bname\n      x = docmd(cmd)\n      /* save the delta info for future use */\n      drop save_so.\n      do mi = 1 to so.0\n        save_so.mi = so.mi\n      end\n      save_so.0 = so.0\n      /* ----------------------------------------- */\n      cmd = 'cd 'localdir' && git merge --no-commit --no-ff'\n      cmd = cmd || ' refs/heads/'bname\n      x = docmd(cmd)\n      if so.1 = 'Already up-to-date.' then do\n        /* No need to merge! */\n        zs1 = \"Merge not needed\"\n        zs2 = \"Branches are the same\"\n        zs3 = \"\"\n        zs4 = \"Press Enter/F3 to continue\"\n        call do_popup4p\n        leave\n      end\n      parse var se.1 \"Automatic merge went well; stopped\" rest\n      if rest /= \"\" then do\n        /* No issues. Commit the merge then execute a Replace */\n        /* Maybe popup a panel here for the commit message? */\n        x = docmd('cd 'localdir' && git commit -m \"Merge 'bname'\"')\n        Report_Header = 'Merge Report'\n        delta_from = bname\n        delta_to   = branch\n        drop so.\n        do mi = 1 to save_so.0\n          so.mi = save_so.mi\n        end\n        so.0 = save_so.0\n        call check_delta\n      end\n      else do\n        mhit = 0\n        do im = 1 to so.0\n          if word(so.im,1) /= 'CONFLICT' then iterate\n          if pos('.zigi/',so.im) = 0  then do\n            mhit = 1\n            zcmd = 2\n            leave\n          end\n        end\n        /* Merge went fubar */\n        if mhit = 1 then\n        do forever\n          zcmd = null\n          call pfshow 'off'           /* make sure pfshow is off */\n          'Addpop row(4) column(6)'\n          'Display Panel(zigimrgq)'\n          drc = rc\n          'Rempop'\n          call pfshow 'reset'         /* restore pfshow setting */\n          if drc > 0 then leave\n          if zcmd > 0 then leave\n          if zcmd = 0 then do\n            zerrsm = null\n            zerrlm = 'Issues with .zigi/xxx files can be ignored as they' ,\n              'will be handled automatically by ZIGI.'\n            'setmsg msg(isrz003)'\n            call view_std 'V'\n          end\n        end\n        if drc > 0 then zcmd = 3\n        if zcmd = 3 then do\n          cmd = 'cd' localdir\n          cmd = cmd '&& git merge --abort'\n          x = docmd(cmd)\n          zerrsm = 'Canceled.'\n          zerrlm = \"Merge canceled and git merge --abort executed.\"\n          'setmsg msg(isrz003)'\n        end\n        mrgtype = zcmd\n        if zcmd = 2 then zcmd = 1\n        /* --------------------------------------------------------------- *\n        | If option 1 then setup for the user to resolve the conflicts    |\n        | using ispf edit.                                                |\n        |                                                                 |\n        | 1. parse merge conflict messages for the merge files            |\n        | 2. if a file is a PDS then process then add the file name       |\n        |    to fix_stats for later and edit to retain only merge records |\n        | 3. display the files for selection and correction               |\n        | 4. if ALL files have been resolved (edit saved) then            |\n        |    process any fix_stats files:                                 |\n        |    - run zigistat 'S'                                           |\n        |    - git add it                                                 |\n        |                                                                 |\n        | If option 1 then don't do any processing just display the       |\n        | files for editing and manual resolution.  But still fix the     |\n        | ISPF stats files                                                |\n        * --------------------------------------------------------------- */\n        if zcmd = 1 then do\n          pdshlqt = translate(pdshlq,' ','.')\n          if qualignr > 0 then\n          pdshlqt = subword(pdshlqt,1,qualignr)\n          pdshlqt = translate(pdshlqt,'.',' ')\n          parse value '' with dsntbl mstat\n          zmergtbl = 'ZG'time('s')\n          zmcount = 0\n          fix_stats = null\n          'TBCreate' zmergtbl 'Keys(mdsn)' ,\n            'Names(mfile mstat) nowrite share'\n          mrgdir = localrep'/'zigirep\n          merge_rms = null\n          do si = 1 to so.0\n            mem = null\n            if word(so.si,1) /= 'CONFLICT' then iterate\n            Select\n              When pos('rename/',word(so.si,2)) > 0 then\n              parse value so.si with . '->'mdsn .\n              When pos('/delete',word(so.si,2)) > 0 then do\n                parse value so.si with . 'Version'. 'of' mdsn .\n                merge_rms = merge_rms mdsn\n                iterate\n              end\n              When pos('modify/',word(so.si,2)) > 0 then\n              parse value so.si with . 'Version'. 'of' mdsn .\n              Otherwise\n              parse value so.si with 'CONFLICT' . 'in' mdsn .\n            End\n            mfile = mrgdir'/'mdsn\n            if mdsn /= '.zigi/dsn' then\n            if left(mdsn,6) = '.zigi/' then do\n              if pos(mfile,fix_stats) = 0 then\n              fix_stats = fix_stats mfile\n              parm = 'M'\n              'vput (mrgdir mdsn mfile) shared'\n              'Edit file(mfile) macro(zigimrgm) parm(parm)'\n              iterate\n            end\n            if wordpos(mdsn,dsntbl) > 0\n            then do\n              'tbmod' zmergtbl\n            end\n            else do\n              'tbadd' zmergtbl\n              dsntbl = dsntbl mdsn\n              zmcount = zmcount + 1\n            end\n          end\n          if zmcount = 0 then do\n            zs1 = 'Merge conflicts will be automatically resolved,'\n            zs2 = 'issues with ISPF Stat Files only.'\n            call do_popup\n          end\n          ztdsels = 0\n          ztdtop = 1\n          zsel = null\n          file_changed = 0\n          drop so. se.\n          'tbtop' zmergtbl\n          'tbsort' zmergtbl 'fields(mdsn,c,a)'\n          if zmcount > 0 then\n          do forever\n            if ztdsels > 1\n            then 'tbdispl' zmergtbl\n            else do\n              'tbtop' zmergtbl\n              'tbskip' zmergtbl 'number('ztdtop')'\n              'tbdispl' zmergtbl 'panel(zigimrds)'\n            end\n            if rc > 4 then leave\n            if zsel = null then iterate\n            if row /= null then do\n              'tbtop' zmergtbl\n              'tbskip' zmergtbl  'number('row')'\n            end\n            if zsel = '/' then do\n              call pfshow 'off'           /* make sure pfshow is off */\n              'Addpop row(4) column(6)'\n              'Display Panel(zigirmrg)'\n              'rempop'\n              call pfshow 'reset'         /* restore pfshow setting */\n            end\n\n            if ztdsels = 0 then\n            if pnsdef = 'P' then do\n              if row = 0 then zcmd = 'O'\n              if row > 0 then zsel = '/'\n            end\n\n            if zsel = 'S' then zsel = 'E'\n            Select\n              When zsel = 'B' then do\n                Address TSO 'OBrowse' mrgdir'/'mdsn\n                mstat = '*OBrowse'\n                'tbmod' zmergtbl\n              end\n              When zsel = 'E' then do\n                ofile = mrgdir'/'mdsn\n                if mrgtype = 1 then do\n                  mrgfile = '/tmp/'userid()'.merge'\n                  md = usssafe(mrgdir)\n                  mdsns = usssafe(mdsn)\n                  cmd = 'cd' md '&& cp' mdsns mrgfile\n                  x = docmd(cmd)\n                  parm = 'M'\n                  'vput (mrgdir mdsn mrgfile) shared'\n                  'Edit file(mrgfile) macro(zigimrgm) parm(parm)'\n                  'Edit file(ofile) macro(zigimrgm)'\n                  mstat = '*Edit'\n                end\n                else do\n                  'Edit file(ofile) panel(zigiedit) macro(zigiem)'\n                end\n                if rc = 0 then do\n                  file_changed = 1\n                  zmcount = zmcount - 1\n                  cmd = 'cd' mrgdir '&& git add' mdsn\n                  x = docmd(cmd)\n                  mstat = '*Updated'\n                end\n                'tbmod' zmergtbl\n                cmd = 'rm' mrgfile\n                x = docmd(cmd)\n              end\n              When zsel = 'V' then do\n                ofile = mrgdir'/'mdsn\n                'View file(ofile)'\n                mstat = '*View'\n                'tbmod' zmergtbl\n              end\n              Otherwise nop\n            end\n            zsel = null\n          end\n          'tbend' zmergtbl\n          zsel = null\n          if zmcount = 0 then do\n            call do_merge_conflict_rms\n            cmd = 'cd' mrgdir '&& git commit -m \"Resolve merge conflicts\"'\n            x = docmd(cmd)\n            Report_Header = 'Merge Report'\n            delta_from = bname\n            delta_to   = branch\n            drop so.\n            do mi = 1 to save_so.0\n              so.mi = save_so.mi\n            end\n            so.0 = save_so.0\n            call check_delta\n            if fix_stats /= null\n            then do fs = 1 to words(fix_stats)\n              sfile = usssafe(word(fix_stats,fs))\n              wfile = translate(word(fix_stats,fs),' ','/')\n              wfile = subword(wfile,words(wfile))\n              pds = usssafe(pdshlqt'.'wfile)\n              Address TSO '%zigistat' \"'\"pds\"'\" sfile 'S'\n              x = docmd('cd' localrep'/'zigirep '&& git add' sfile)\n              if x > 0 then call view_std 'B'\n            end\n            call update_repo_metadata\n          end\n          else do\n            zs1 = 'Not all conflicts have been resolved.'\n            zs2 = 'Merge request is now aborted.'\n            zs3 = null\n            zs4 = 'Press Enter to exit merge.'\n            call do_popup4p\n            cmd = 'cd' localdir\n            cmd = cmd  '&& git merge --abort'\n            x = docmd(cmd)\n            call view_std 'B'\n          end\n        end\n      end\n      leave\n    end\n  end\n  'tbend' rtbm\n  ztdsels = 1\n  zsel = null\n  return\n\n  /* -------------------------------------------------------- *\n  | During a merge if there are deletions then those need to |\n  | be handled via a git rm.                                 |\n  * -------------------------------------------------------- */\ndo_merge_conflict_rms:\n  if words(merge_rms) = 0 then return\n  cmd = 'cd' mrgdir '&& git rm' usssafe(merge_rms)\n  x = docmd(cmd)\n  if x > 0 then call view_std 'B'\n  return\n\n  /* --------------------------------------- *\n  | Delete a PDS Member using ISPF Services |\n  * --------------------------------------- */\nDelete_member:\n  arg dsn mem\n  \"LMInit Dataid(test) dataset(\"dsn\") enq(shrw)\"\n  \"LMOpen Dataid(\"test\") Option(Output)\"\n  \"LMMDel  Dataid(\"test\") Member(\"mem\") NoEnq\"\n  \"LMClose Dataid(\"test\")\"\n  \"LMFree Dataid(\"test\")\"\n  return\n\n  /* ------------------------ *\n  | Get the branches for use |\n  * ------------------------ */\nget_branches:\n  localdir = localrep'/'zigirep\n  if zigi_offline = 0 then do\n    cmd = ' && git remote prune origin > /dev/null 2>&1 && git branch -a'\n    x = docmd('cd 'localdir cmd)\n  end\n  else parse value '0 0' with so.0 se.0\n  if so.0 + se.0 = 0 then do\n    cmd = '&& git branch -a'\n    x = docmd('cd 'localdir cmd)\n  end\n  bl. = null\n  bc = 0\n  do bri = 1 to so.0\n    branch = strip(so.bri)\n    if word(branch,1) = '*' then branch = word(branch,2)\n    if pos('->',branch) > 0 then iterate\n    if pos('/',branch) > 0 then do\n      branch = translate(branch,' ','/')\n      branch = word(branch,words(branch))\n    end\n    bc = bc + 1\n    bl.bc = branch\n  end\n  bl.0 = bc\n  return\n\n  /* ----------------------- *\n  | Create a new Repository |\n  * ----------------------- */\nCreate_Repo:\n  'vget (saverep) profile'\n  if saverep /= null then localrep = saverep\n  do forever\n    parse value '' with zerrsm zcmd zigirep cc_rc pdshlq ,\n      defcpush defruid qualignr zigicat encoding\n    'Display Panel(ziginew)'\n    if readonly = 'N' then readonly = null\n    if rc > 0 then return 8\n    if localrep = '?' then\n    localrep = zigiosel()\n    if localrep = null then do\n      zerrsm = 'Canceled.'\n      zerrlm = 'Create canceled as OMVS directory selection canceled.'\n      'setmsg msg(isrz003)'\n      return 1\n    end\n    localrep = strip(localrep,'T','/')\n    /* ---------------------------------------------------- *\n    | We do some basic git repo setup here...              |\n    | Fair warning, it's going to be very verbose.         |\n    | But that eases feature adding :)                     |\n    * ---------------------------------------------------- */\n    /* encoding given? */\n    if encoding = null then encoding = 'ibm-1047'\n    /* test if localrep is present */\n    cmd = '\u00dd\u00dd -d 'localrep' \u00a8\u00a8 && echo 1'\n    x = docmd(cmd)\n    if so.0 = 1 & so.1 = 1 then do\n      /* ok, localrep is there. better not have zigirep */\n      cmd = '\u00dd\u00dd -d 'localrep'/'zigirep' \u00a8\u00a8 && echo 1'\n      x = docmd(cmd)\n      if so.0 = 1 & so.1 = 1 then do\n        zerrsm = \"Failed.\"\n        zerrlm = \"Error: \"localrep\"/\"zigirep\" exists and must not.\"\n        'setmsg msg(isrz003)'\n        leave\n      end\n    end\n    saverep = localrep\n    'vput (saverep) profile'\n    /* If we made it here, we can freely git init */\n    zs1 = 'Creating your repository'\n    zs2 = 'Please standby'\n    call do_popup\n    x = docmd('cd 'localrep' && git init 'zigirep)\n    call do_git_attributes\n    if readonly = 'Y' then call set_read_only\n\n    Address ISPExec\n    zigikey = localrep'/'zigirep\n    zigidate = date('n')\n    reponame = zigirep\n    call set_sortdate\n    'tbadd zigirepo order'\n    zpush = defcpush\n    'vget (defrsort srr src srp srl) profile'\n    'TBSort zigirepo Fields('defrsort')'\n    'TBSAVE zigirepo REPLCOPY LIBRARY('isptabl')'\n    leave\n  end\n  return 0\n\ndo_git_attributes:\n  /* The git repo is initialized. Time to stick a\n  .gitattributes (ASCII) in there */\n  cmd = 'ls' localrep'/'zigirep'/.gitattributes'\n  x = docmd(cmd)\n  if so.0 = 1 then return\n  call syscalls 'ON'\n  address syscall\n  path = localrep\"/\"zigirep\"/.ga\"\n  'open' path,\n    O_rdwr+O_creat+O_trunc,\n    660\n  if retval = -1 then do\n    Address ISPExec\n    zs1 = \"Something bad when creating .gitattributes. Make errormsg\"\n    zs4 = 'Press F3 to close this popup and exit.'\n    parse value '' with zs2 zs3\n    call do_popup4\n    call syscalls 'OFF'\n    return\n  end\n  fd = retval  /* as I think it's weird to write to a retval lol */\n  call write_fd ,\n    \"# This .gitattributes file is autogenerated with ZIGI\" ver\n  call write_fd ,\n    \"*   git-encoding=iso8859-1 zos-working-tree-encoding=\"encoding\n  ga3a = \".gitattributes    \"\n  ga3b = \"git-encoding=iso8859-1 zos-working-tree-encoding=iso8859-1\"\n  ga3  = ga3a || ga3b\n  call write_fd ga3\n  ga4a = \".gitignore        \"\n  ga4b = \"git-encoding=IBM-1047 zos-working-tree-encoding=IBM-1047\"\n  ga4  = ga4a || ga4b\n  call write_fd  ga4\n  binaries = '*.docm *.docx *.doc *.dotx *.pdf *.epub *.mobi *.azw3' ,\n    '*.jpg *.jpeg *.png *.gif *.zip *.gzip *.tz *.z *.Z *.pax' ,\n    '*.ppt *.pptx *.xls *.xlsx *.xlsm *.obj *.bin'\n  do gai = 1 to words(binaries)\n    ga = word(binaries,gai) 'binary'\n    call write_fd ga\n  end\n  'close' fd\n  call syscalls 'OFF'\n  /* -------------------- .gitattributes written ----------- */\n  /*             UNFORTUNATELY, IT'S IN EBCDIC :(            */\n  /* ------------------------------------------------------- */\n  reporoot = localrep'/'zigirep'/'\n  /* convert to iso8859-1 */\n  cmd = 'cd 'localrep'/'zigirep' && '\n  cmd = cmd 'iconv -f ibm-1047 -t iso8859-1 .ga'\n  cmd = cmd ' > .gitattributes'\n  x = docmd(cmd)\n\n  /* delete the .ga file */\n  cmd = 'cd 'localrep'/'zigirep' && rm -rf .ga'\n  x = docmd(cmd)\n\n  /* tag it and bag it */\n  cmd = 'cd 'localrep'/'zigirep' && '\n  cmd = cmd 'chtag -tc iso8859-1 .gitattributes'\n  x = docmd(cmd)\n\n  /* Create the .zigi folder in the repo and add the dsn-file */\n  cmd = 'cd 'localrep'/'zigirep' && mkdir .zigi'\n  x = docmd(cmd)\n\n  /* Fill dsn file with the comments */\n  path = localrep\"/\"zigirep\"/.zigi/dsn\"\n  'open' path,\n    O_rdwr+O_creat+O_trunc,\n    660\n  if retval = -1 then do\n    Address ISPExec\n    zs1 = \"Something bad when creating .zigi/dsn.\"\n    zs4 = 'Press F3 to close this popup and exit.'\n    parse value '' with zs2 zs3\n    call do_popup4\n    return\n  end\n  fd = retval  /* as I think it's weird to write to a retval lol */\n  call write_fd \"# ZIGI dsn-file\"\n  call write_fd \"# This file needs to be here.\"\n  call write_fd \"# Don't edit unless you know what you're doing :)\"\n  call write_fd '#  '\n  call write_fd '# record format is (case insensitive):'\n  call write_fd '#  '\n  call write_fd '# Position - description'\n  call write_fd '#  '\n  call write_fd '# 1 - directory name which will be prefixed by the'\n  call write_fd '#     defined HLQ to create the z/OS dataset'\n  call write_fd '#     (* defines the default)'\n  call write_fd '# 2 - PS or PO (dataset organization)'\n  call write_fd '#     PS for a flat file'\n  call write_fd '#     PO for a directory and thus a partitioned dataset'\n  call write_fd '# 3 - record format (FB or VB)'\n  call write_fd '# 4 - lrecl'\n  call write_fd '# 5 - blksize'\n  call write_fd '#     0 is allowed if system determined blksize is enabled'\n  call write_fd '# 6 - extension (optional - if used then no period)'\n  call write_fd '#     file extension to be used for PDS members in USS'\n  call write_fd '#  '\n  call write_fd '# Default DSORG and DCB info'\n  call write_fd '* PO FB 80 32720'\n  'close' fd\n\n  /* ------------------ Let's make our first commit :)       */\n  x = docmd('cd 'reporoot' && git add .gitattributes')\n\n  x = docmd('cd 'reporoot' && git add .zigi/dsn')\n\n  commitmsg = \".gitattributes created and added by ZIGI\"\n  x = docmd('cd 'reporoot' && git commit -m \"'commitmsg'\"')\n  return\n\n  /* ---------------------------------------------------------- *\n  | Generalized routine to view stdout. (so.) or stderr. (se.) |\n  | based on the parm passed                                   |\n  * ---------------------------------------------------------- */\nview_std:\n  arg stdopt viewopt\n  if stdopt = null then viewopt = 'B'\n  if viewopt = null then viewopt = 'B'\n  if stdopt = 'X' then stdopt = null\n  if datatype(so.0) /= 'NUM' then so.0 = 0\n  if datatype(se.0) /= 'NUM' then se.0 = 0\n  if viewopt = 'B' then if so.0 + se.0 = 0 then return\n  /* ------------------------------- *\n  | Randomly define a DDName to use |\n  * ------------------------------- */\n  dd = 'zd'random(9999)\n  /* --------------------------------------- *\n  | Get lrecl to determine dcb for temp d/s |\n  * --------------------------------------- */\n  if stdopt /= 'C' then do\n    vlrecl = 0\n    do li  = 1 to so.0\n      so.li = strip(so.li,'T')\n      if length(so.li) > vlrecl then vlrecl = length(so.li)\n      if so.li = null then so.li = ' '\n    end\n    do li  = 1 to se.0\n      se.li = strip(se.li,'T')\n      if length(se.li) > vlrecl then vlrecl = length(se.li)\n      if se.li = null then se.li = ' '\n    end\n    sec = so.0 + se.0\n  end\n  else do\n    do li = 1 to combine.0\n      if length(combine.li) > vlrecl then vlrecl = length(combine.li)\n    end\n    sec = combine.0\n  end\n  if vlrecl < 81 then vlrecl = 80\n  /* ------------------------------------------ *\n  | Allocate a temporary data set for our data |\n  * ------------------------------------------ */\n  Address TSO\n  /* calculate space needed with avg 50 bytes per record */\n  prim = (((so.0 + se.0) * 50) % 56000) + 1\n  if prim < 2 then prim = 5\n  if viewopt = 'V' then do\n    if sysvar('syspref') = null then pref = userid()'.'\n    else pref = null\n    vdsn = pref'work.zigi.gitdata'\n  end\n  else vdsn = null\n  x = listdsi(vdsn)\n  if x = 0 then do\n    call outtrap 'x.'\n    'delete' vdsn\n    call outtrap 'off'\n  end\n  if vdsn /= null then vdsnp = 'da('vdsn') unit(3390)'\n  else vdsnp = null\n  if vlrecl > 255 then vlrecl = 251\n  'Alloc f('dd') new spa('prim','prim') tr' ,\n    'recfm(v b) lrecl('vlrecl+4') blksize(0)' vdsnp\n  /* ----------------------------- *\n  | If stdopt is 'B' then do both |\n  * ----------------------------- */\n  if stdopt /= 'C' then do\n    stdopt = null\n    sc = so.0\n    do xi = 1 to se.0\n      sc = sc + 1\n      so.sc = se.xi\n    end\n    so.0 = sc\n  end\n  /* ----------------------- *\n  | Write out the stem data |\n  * ----------------------- */\n  if stdopt = 'C' then do\n    'Execio * diskw' dd '(finis stem combine.'\n    drop combine.\n    combine.0 = 0\n  end\n  if stdopt /= 'C' then do\n    if stdopt = null\n    then do\n      'Execio * diskw' dd '(finis stem so.'\n    end\n    else do\n      'Execio * diskw' dd '(finis stem se.'\n    end\n  end\n  /* -------------------------------------------------- *\n  | Access the Temporary Data Set using ISPF           |\n  | Library Services.                                  |\n  | Then using ISPF Browse service to browse the data. |\n  | And use Library Services to Free the Data Set.     |\n  * -------------------------------------------------- */\n  Address ISPExec\n  if sec > 0 then if viewopt = 'B' then do\n    'lminit dataid(ddb) ddname('dd')'\n    'browse dataid('ddb') panel(zigibrow)'\n    'lmfree dataid('ddb')'\n  end\n  else do\n    vmac = 'Panel(zigiedit) macro(zigivmac)'\n    'view dataset('vdsn')' vmac\n    vtitle = null\n    'verase vtitle'\n  end\n  /* ----------------------------- *\n  | Last Free the z/OS Allocation |\n  * ----------------------------- */\n  call outtrap 'x.'\n  Address TSO ,\n    'Free f('dd')'\n  if vdsn /= null then\n  Address TSO 'Delete' vdsn\n  call outtrap 'off'\n  return\n\n  /* -------------------------------------------------------- *\n  | This routine will generate the users personal SSH Public |\n  | Key.                                                     |\n  * -------------------------------------------------------- */\nBuild_SSH:\n  parse value '' with zigissh\n  zs1 = 'Building SSH Key'\n  zs2 = 'Patience . . .'\n  do forever\n    call do_popup\n    call catsshk\n    if zigissh /= null then leave\n  end\n  return\n\n  /* ------------------------------ *\n  | Cat the current ssh key if any |\n  * ------------------------------ */\ncatsshk:\n  drop so. se.\n  cmd = 'cat' keyfile\n  x = docmd(cmd)\n  if se.0 = 0\n  then do\n    zigissh = so.1\n    'vput (zigissh) profile'\n  end\n  else zigissh = null\n  return\n\ndsnvalid:\n  /* Tests for a 'potentially valid' z/OS datasetname */\n  parse arg val_dsn\n  if left(val_dsn,1) = '.' then return 'NO'\n  if strip(val_dsn) = null then return 'NO'\n  val_dsn = strip(val_dsn,'B',\"'\")\n  upp = TRANSLATE(val_dsn,\".ABCDEFGHIJKLMNOPQRSTUVWXYZ\",,\n    \".abcdefghijklmnopqrstuvwxyz\")\n  tdsn = translate(val_dsn,' ','.')\n  retval = 'OK'   /* asssume good */\n  do dsnvi = 1 to words(tdsn)\n    w = word(tdsn,dsnvi)\n    if length(w) > 8 then retval = 'NO'\n    if pos(left(w,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ$#@') = 0 then retval = 'NO'\n    w = translate(w,left(' ',39,' '), ,\n      'ABCDEFGHIJKLMNOPQRSTUVWXYZ-$#@0123456789')\n    w = strip(w)\n    if w /= null then retval = 'NO'\n  end\n  if retval /= 'NO' then\n  if upp = val_dsn then do\n    smsg = msg()\n    call msg 'OFF'\n    if sysdsn(val_dsn) = \"OK\" | sysdsn(val_dsn) = \"DATASET NOT FOUND\"\n    then retval = 'OK'\n    else retval = \"NO\"\n    call msg smsg\n  end\n  return retval\n\n  /* ------------------------------------------------- *\n  |                                                  |\n  | String replace routine                           |\n  | input string                                     |\n  | from string                                      |\n  | to string                                        |\n  | translate is input to from                       |\n  * ------------------------------------------------- */\nstrreplace:\n  string  = arg(1)\n  strfrom = arg(2)\n  strto   = arg(3)\n  if pos(strfrom,string) = 0 then return string\n  newString = ''\n  do repi = 1 to length(string)\n    if substr(string,repi,1) /= strfrom\n    then newstring = newstring''substr(string,repi,1)\n    else  newstring = newstring''strto\n  end\n  return newstring\n\nUpdate_repo_metadata:\n  save_fulldsn = fulldsn\n  x = debug('update_repo_metadata: zcmd:'zcmd ,\n    'zsel:' zsel 'zigirep:' zigirep)\n  save_dsn = dsn\n  if repo_ztdsels < 2 then\n  if rtbl_open = 1 then do\n    'tbend' rtbl\n    rtbl_open = 0\n    ztdsels = 0\n    rtop = 0\n  end\n  if rtbl_open = 0 then\n  'TBCreate' rtbl 'Keys(fulldsn) Names(dsnstat dsn filetype)' ,\n    'Replace NoWrite'\n  rtbl_open = 1\n  call get_dsn_info\n  /* We always fetch when we start to work on a repo */\n  if fetch_flag = 1 then crflag = 1\n  if zigi_offline = 1 then crflag = 1\n  if crflag = 0 then do\n    fetch_flag = 1\n    x = debug('fetching remote')\n    zs1 = 'Fetching Remote info'\n    zs2 = 'Patience . . .'\n    call do_popup\n    /* get the remote info.....but */\n    /* we have to get rid of the tab in git output */\n    x = debug('getting the remotes')\n    gitcmd = 'git remote -v | sed -e \"s/\u00dd\u00dd:space:\u00a8\u00a8\\+/ /g\"'\n    localdir = localrep'/'zigirep\n    x = docmd('cd 'localdir' && 'gitcmd)\n    if so.0 > 0 then\n    remote1 = word(so.1,1)' 'word(so.1,2)\n    if so.0 = 0 then do\n      remote1 = \"<no remote defined>\"\n      remote2 = null\n    end\n  end\n  cmd = 'cd' localrep'/'zigirep\n  /* Fetch only if there's a remote */\n  if zigi_offline = 0 then\n  if remote1 /= '<no remote defined>' then\n  x = docmd(cmd '&& git fetch')\n  x = debug('...done fetching remotes')\n  fetch_flag = 1\n  /* now we get the status for all in the repo */\n  if zigi_offline = 0 then\n  if crflag = 0 then  do\n    if se.0 > 1 then fetchmsg = \"Remote updates, check status\"\n    else fetchmsg = \"No remote updates\"\n    zs1 = 'Updating Repo and/or Getting Stats'\n    zs2 = 'Patience . . .'\n    call do_popup\n  end\n  /* get all the files that are in the repo */\n  x = debug('getting all files in repo-1')\n  address syscall\n  'readdir 'localrep'/'zigirep' root.'\n  /* check for .zigi/dsn */\n  'lstat' localrep'/'zigirep'/.zigi/dsn st.'\n  if st.0 = 0 then nonzigi = 1\n  else nonzigi = 0\n  address ispexec\n  if check_flag = 1 then do\n    x = debug('Checking z/OS dataset last reference dates.')\n    zs1 = 'Checking z/OS dataset change status.'\n    zs2 = 'Patience . . .'\n    call do_popup\n    check_files = zigirefd(localrep'/'zigirep pdshlq qualignr 'C')\n    x = debug('Check complete.')\n  end\n  else check_files = '*'\n  do umdi = 1 to root.0\n    if left(root.umdi,1) = \".\" then iterate\n    else do\n      /* not the . and .. things */\n      if dsnvalid(root.umdi) = \"OK\" then do\n        /* and only for valid z/OS-datasets (skip README.md et al) */\n        r = usssafe(root.umdi)\n        x = debug('   check file or dir')\n        cmd = '\u00dd -d 'localrep'/'zigirep'/'r' \u00a8 && echo \"DIR\"'\n        so.1 = null\n        x = docmd(cmd)\n        y = debug('   done')\n        fulldsn = add_dsn_hlq(root.umdi)\n        edsn = strip(fulldsn,'B',\"'\")\n        if check_files /= null then\n        if wordpos(edsn,check_files) = 0 then iterate\n        x = listdsi(fulldsn)\n        zs1 = 'Checking' fulldsn\n        zs2 = 'Patience . . .'\n        call do_popup\n        if so.1 = \"DIR\" & x = 0 then do\n          x = debug('its a dir...lmmstat all the things' edsn)\n          Address TSO\n          /* Oh yeah we need this */\n          root.umdi = usssafe(root.umdi)\n          statpath = localrep'/'zigirep'/.zigi/'root.umdi\n          statfile = root.umdi\n          mem_delta = zigistat(\"'\"edsn\"'\" statpath 'C')\n          if mem_delta = 0 then mem_delta = null\n          Address ISPExec\n          mem_hit = 0\n          memcount = words(mem_delta)\n          do im = 1 to words(mem_delta)\n            mem = word(mem_delta,im)\n            file = root.umdi\n            m = usssafe(strip(mem))\n            e = usssafe(edsn)\n            r = usssafe(file)\n            if zdsn.file /= null\n            then do\n              rm = lower(strip(m)'.'zdsn.file)\n              extopt = null\n            end\n            else do\n              rm = m\n              extopt = '-U'\n            end\n            rm = strip(rm)\n            /* Binary v1, check if PDS is a bin, then copy binary */\n            if is_binfile(file'/*') = 1 then do\n              binopt = '-B'\n            end\n            else do\n              binopt = null\n            end\n            if is_binfile(file'/'rm) = 1 then do\n              binopt = '-B'\n            end\n            else do\n              binopt = null\n            end\n            if binopt = null\n            then bintext = 'as Text'\n            else bintext = 'as Binary'\n            if sysrecfm = 'U' then do\n              binopt = null\n              cplmod = '-X -I'\n              bintext = 'as LMod'\n            end\n            else cplmod = null\n            copycmd = \"//'\"e\"(\"m\")'\"\n            copycmd = '\"'copycmd'\"'\n            copycmd = \"cp\" binopt cplmod extopt \"-v\" copycmd ,\n              localrep\"/\"zigirep\n            copycmd = copycmd || \"/\"r\"/\"rm\n            zs1 = 'Copying:' fulldsn\n            zs2 = 'Member: ' mem 'to' '/'clean(r)'/'clean(rm)\n            zs3 = 'Progress:' im 'of' left(memcount,6) bintext\n            call do_popup3\n            x = docmd(copycmd)\n            if x > 0 then call view_std 'B'\n            x = debug('Copy:' copycmd)\n            if strip(binopt''cplmod) /= null then do\n              tagcmd = 'chtag -b 'localrep'/'zigirep'/'r'/'rm\n              x = docmd(tagcmd)\n            end\n            mem_hit = 1\n          end\n          /* ------------------------------------------------------- *\n          | If any files in the directory do not have a counterpart |\n          | in the PDS that indicates the member was deleted from   |\n          | the PDS prior to ZIGI. Need to remove it from OMVS      |\n          | and git.                                                |\n          * ------------------------------------------------------- */\n          address syscall 'readdir' localrep'/'zigirep'/'r rd.\n          mem_omvs = null\n          'vget (allmems)'\n          do im = 1 to rd.0\n            if left(rd.im,1) = '.' then iterate\n            m = strip(rd.im)\n            mfile = m\n            if zdsn.r /= null\n            then do\n              parse value m with m'.'.\n              m = translate(m)\n            end\n            if wordpos(m,allmems) = 0 then do\n              mem_omvs = mem_omvs mfile\n            end\n          end\n          'verase (allmems)'\n          if strip(mem_omvs) /= null then do\n            x = debug('PDS members deleted - removing from OMVS:' ,\n              mem_omvs)\n            mem_hit = 1\n            cmrecover = 0\n            delkeep_members = null\n            x = confirm_mem_deletes()\n            if strip(mem_omvs) = null then x = 4\n            if x = 0 then do\n              cmd = 'cd' localrep'/'zigirep'/'r\n              cmd = cmd '&& rm -f' mem_omvs\n              cmd = usssafe(cmd)\n              cmd = 'cd' localrep'/'zigirep'/'r\n              cmd = cmd '&& git rm -f' mem_omvs\n              cmd = usssafe(cmd)\n              zs1 = 'Deletions being processed.'\n              zs2 = 'Should not take long.'\n              call do_popup\n              x = docmd(cmd)\n              if x > 0 then call view_std 'B'\n            end\n            if cmrecover = 1 then call fix_mem_stats\n          end\n          /* --------------------------------------------------------- *\n          | If members were updated then need to update the stat file |\n          * --------------------------------------------------------- */\n          if mem_hit = 1 then do\n            cmd = 'cd' localrep'/'zigirep'/.zigi'\n            cmd = cmd '&& git add .'\n            x = zigistat(\"'\"edsn\"'\" statpath 'S')\n          end\n        end\n        else if nonzigi = 0 then do\n          /* It must be a PS, just copy it over to OMVS */\n          x = listdsi(fulldsn)\n          if x = 0 then do\n            s = usssafe(fulldsn)\n            if is_binfile(r) = 1 then do\n              binopt = '-B'\n            end\n            else do\n              binopt = null\n            end\n            if sysrecfm = 'U' then do\n              binopt = null\n              cplmod = '-X -I'\n            end\n            else cplmod = null\n            copycmd = \"//\"s\n            copycmd = '\"'copycmd'\"'\n            copycmd = \"cp \"binopt cplmod\" -U -v\" copycmd\" \"localrep\"/\"zigirep\n            copycmd = copycmd || \"/\"r\n            x = docmd(copycmd)\n            if x > 0 then call view_std 'B'\n            x = debug('Copy:' copycmd)\n            if strip(binopt''cplmod) /= null then do\n              tagcmd = 'chtag -b 'localrep'/'zigirep'/'r\n              x = docmd(tagcmd)\n            end\n          end\n        end\n      end\n    end\n  end\n\n  if check_flag = 1 then do\n    zs1 = 'Updating z/OS Dataset Last Access Information.'\n    zs2 = 'Patience . . .'\n    call do_popup\n    x = debug('Calling zigirefd to update last access info.')\n    x = zigirefd(localrep'/'zigirep pdshlq qualignr 'U')\n    x = debug('Completed the last access update.')\n    check_flag = 0\n  end\n  zs1 = 'Building List of repository Data Sets'\n  zs2 = fetchmsg\n  call do_popup\n  x = debug('get the status')\n  cmd = 'cd' localrep'/'zigirep\n  x = docmd(cmd '&& git status --porcelain')\n  x = debug('done')\n  /* get the stuff from the repo-file */\n  x = debug('get all the files (again?)')\n  address syscall\n  'readdir 'localrep'/'zigirep' root. rstat.'\n  address ispexec\n  x = debug('done')\n  x = debug('iterate the files')\n  do rooti = 1 to root.0\n    zs1 = 'Updating dataset and file Git status to display.'\n    zs2 = 'Patience . . .'\n    call do_popup\n    dsnstat = null\n    if root.rooti = \".\" | root.rooti = \"..\" then do\n      iterate\n    end\n    else do\n      if dsnvalid(root.rooti) = \"OK\" then do\n        x = debug('Get the git status and fill dsnstat' root.rooti)\n        dsn = root.rooti\n        filet. = null\n        do ii = 1 to so.0\n          stat = substr(so.ii,1,2)\n          PATH = substr(so.ii,4)\n          dsnstat = null\n          if pos('/',path) > 0\n          then parse value path with test'/'.\n          else test = path\n          if test = dsn then\n          Select\n            When stat = '??' then do\n              filet.dsn = stat\n              leave\n            end\n            When right(stat,1) /= ' '\n            then filet.dsn = ' M'\n            When left(stat,1) /= ' ' & filet.dsn = null\n            then filet.dsn = 'M '\n            Otherwise nop\n          end\n        end\n\n        if filet.dsn /= null then\n        dsnstat = porcelain(filet.dsn)\n        x = debug('done')\n\n        'tbmod zigirepo order'\n        fulldsn = add_dsn_hlq(dsn)\n        if nonzigi = 0 then do\n          call outtrap 'x.'\n          if sysdsn(fulldsn) /= ok then dsnstat = 'Missing z/OS Dataset'\n          call outtrap 'off'\n        end\n        else if sysdsn(fulldsn) /= 'OK' then fulldsn = dsn\n        'tbadd' rtbl\n      end\n      /* -------------------------------------------------- *\n      | If NOT a z/OS dataset then it must be an OMVS file |\n      | make sure it isn't a . file and then add it        |\n      * -------------------------------------------------- */\n      else do\n        if left(root.rooti,1) /= '.' then do\n          dsn = root.rooti\n          if rstat.rooti.1 = 1 then filetype = '(D)'\n          else filetype = null\n          fulldsn = dsn\n          do ii = 1 to so.0\n            stat = substr(so.ii,1,2)\n            PATH = substr(so.ii,4)\n            if left(path,1) = '\"' then\n            path = strip(path,'B','\"')\n            spos = POS('/',zigirep)\n            cutrep = substr(zigirep,spos+1)\n            trywith = cutrep'/'fulldsn\n            if pos(dsn, PATH) = 1 then do\n              dsnstat = porcelain(stat)\n              leave\n            end\n            if pos(trywith, PATH) = 1 then do\n              dsnstat = porcelain(stat)\n              leave\n            end\n            /* Ugly fix for uss files with a space */\n            if pos('\"'dsn'\"', PATH) = 1 then do\n              dsnstat = porcelain(stat)\n              leave\n            end\n            /* end of ugly fix */\n          end\n          'tbadd' rtbl\n          filetype = null\n        end\n      end\n    end\n  end\n\n  /* --------------------------- *\n  | Get the current branch info |\n  * --------------------------- */\n  zs1 = 'Getting current Git Status.'\n  zs2 = 'Patience . . .'\n  call do_popup\n  x = debug('getting git status for current branch')\n  x = docmd('cd 'localdir' && git status')\n  branch = word(so.1,3)\n  if so.0 > 1 then call Update_Status\n  else do\n    parse value '' with bstat baction\n  end\n  'tbsort' rtbl 'fields(dsn,c,a)'\n  fulldsn = save_fulldsn\n  'tbmod zigirepo order'\n  dsn = save_dsn\n  x = debug('Done with update_repo_metadata' zigirep)\n  return\n\n  /* -------------------------------------------- *\n  | Update the status with more meaningful info. |\n  * -------------------------------------------- */\nUpdate_Status:\n  parse value '' with bstat baction\n  do usi = 1 to so.0\n    Select\n      When bstat = null & ,\n        pos('up-to-date',so.usi) > 0 then bstat = so.usi\n      When bstat = null & ,\n        pos('branch is behind',so.usi) > 0 then\n      parse value so.usi with bstat',' .\n      When pos('working tree clean',so.usi) > 0 then baction = so.usi\n      When pos('Untracked files:',so.usi)   > 0 then baction = so.usi\n      When pos('Changes not staged',so.usi) > 0 then baction = so.usi\n      When pos('Changes to be comm',so.usi) > 0 then baction = so.usi\n      Otherwise nop\n    end\n  end\n  Return\n\n  /* ----------------------------------------------------- *\n  | Confirm the delete of a member with optional recovery |\n  * ----------------------------------------------------- */\nConfirm_Mem_Deletes:\n  tbcd = 'zcd'time('s')\n  'tbcreate' tbcd 'names(dmrow dmorig dmstate) nowrite'\n  do cmdi = 1 to words(mem_omvs)\n    dmrow = word(mem_omvs,cmdi)\n    dmorig = dmrow\n    if pos('.',dmrow) > 0 then do\n      parse value dmrow with dmrow'.'.\n      dmrow = translate(dmrow)\n    end\n    'tbadd' tbcd\n  end\n  'tbtop' tbcd\n  cmtop = 0\n  cmtsels = 0\n  do forever\n    dsel = null\n    if ztdsels < 1 then do\n      if cmtop > 0 then do\n        'tbtop' tbcd\n        'tbskip' tbcd 'number('cmtop')'\n      end\n      'tbdispl' tbcd 'panel(zigicdm)'\n    end\n    else 'tbdispl' tbcd\n    drc = rc\n    if drc > 4 then return 0\n    cmtop = ztdtop\n    if dsel /= null then\n    Select\n      When dsel = 'R' then do\n        cmrecover = 1\n        delkeep_members = delkeep_members dmrow\n        if is_binfile(r'/'dmrow) = 1\n        then cbinopt = '-B'\n        else cbinopt = null\n        x = listdsi(fulldsn)\n        if sysrecfm = 'U' then cbinopt = '-X -I'\n        dw = wordpos(dmorig,mem_omvs)\n        mem_omvs = delword(mem_omvs,dw,1)\n        tdsn = \"'\"strip(fulldsn,'B',\"'\")\"(\"dmrow\")'\"\n        cmd = 'cd' localrep'/'zigirep'/'r\n        cmd = cmd '&& cp -v -U' cbinopt dmorig '\"//'tdsn'\"'\n        x = docmd(cmd)\n        if x > 0 then call view_std 'B'\n        dmstate = 'Recovered'\n        'tbput' tbcd\n      end\n      When dsel = 'E' then\n      Address TSO ,\n        'oedit' localrep'/'zigirep'/'r'/'dmorig\n      Otherwise Address TSO ,\n        'obrowse' localrep'/'zigirep'/'r'/'dmorig\n    end\n  end\n  return 0\n\nFix_mem_stats:\n  cmd = 'cd' localrep'/'zigirep'/.zigi/'\n  cmd = cmd '&& cat' r\n  x = docmd(cmd)\n  do fmsi = 1 to so.0\n    do fmsim = 1 to words(delkeep_members)\n      dmbr = word(delkeep_members,fmsim)\n      if word(so.fmsi,1) = dmbr then call add_stats so.i\n    end\n  end\n  return\n\nporcelain:\n  parse arg stat\n\n  /* parse git status --short as documented in\n  https://www.git-scm.com/docs/git-status#_short_format */\n\n  Select\n    When stat == \" M\" then res = \"Modified\"\n    When stat == \" D\" then res = \"Deleted\"\n    When stat == \" R\" then res = \"Renamed\"\n    When stat == \" C\" then res = \"Copied\"\n    When stat == \"M \" then res = \"Ready to commit\"\n    When stat == \"??\" then res = \"Untracked\"\n    When stat == \"MM\" then res = \"Modified\"\n    When stat == \"AM\" then res = \"Modified\"\n    When stat == \"RM\" then res = \"Modified\"\n    When stat == \"CM\" then res = \"Modified\"\n    When stat == \"MD\" then res = \"Deleted\"\n    When stat == \"AD\" then res = \"Deleted\"\n    When stat == \"RD\" then res = \"Deleted\"\n    When stat == \"CD\" then res = \"Deleted\"\n    When stat == \"DR\" then res = \"Renamed\"\n    When stat == \"DC\" then res = \"Copied\"\n    When stat == \"??\" then res = \"Untracked\"\n    When stat == \"!!\" then res = \"Ignored\"\n    When left(stat,1) == \" \" then res = \"Not Updated\"\n    When left(stat,1) == \"M\" then res = \"Updated in index\"\n    When left(stat,1) == \"A\" then res = \"Added to index\"\n    When left(stat,1) == \"D\" then res = \"Deleted from index\"\n    When left(stat,1) == \"R\" then res = \"Renamed in index\"\n    When left(stat,1) == \"C\" then res = \"Copied in index\"\n    Otherwise res = null\n  end\n  return '\u00dd' || stat || '\u00a8 ' || res\n\nclean:\n  parse arg string\n  if pos('\\',string) = 0 then return string\n  string = translate(string,' ','\\')\n  return strip(string)\n\nusssafe:\n  parse arg safedsn\n  if pos('$',safedsn) = 0 then return safedsn\n  /* Let's not usssafe it twice :) */\n  if pos('\\$',safedsn) > 0 then return safedsn\n  safedsn = strreplace(safedsn, '$', '\\$')\n  return safedsn\n\n  /* ------------------------------------------------------ *\n  | The pfshow routine will:                               |\n  | 1. check to see the passed option                      |\n  | 2. if Off then it will save the current pfshow setting |\n  |    - save the current setting                          |\n  |    - turn off pfshow                                   |\n  | 3. if the option is Reset then it will                 |\n  |    - test if pfshow was on and turn it back on         |\n  * ------------------------------------------------------ */\npfshow:\n  if zpfshow = 'OFF' then return\n  arg pfkopt\n  if pfkopt = 'RESET' then do\n    if pfkeys = 'ON' then\n    'select pgm(ispopf) parm(FKA,ON)'\n  end\n  if pfkopt = 'OFF' then do\n    'vget (zpfshow)'\n    pfkeys = zpfshow\n    if pfkeys /= 'OFF' then\n    'select pgm(ispopf) parm(FKA,OFF)'\n  end\n  return\n\n  /* ------------------------------- *\n  | Add a dataset to the repository |\n  * ------------------------------- */\nAdd_Dataset:\n  parse value '' with zcmd what list dsnapfx zsel\n  call get_dsn_info\n  save_extfile = extfile\n  dsnapfx = pdshlq\n  s_dsnapfx = dsnapfx\n  lc_count = 0\n  add_count = 0\n  last_find = 0\n  top = 0\n  save_top = 0\n  dsnatbl = 'ZIGID'random(999)\n  call tbcreate_dsnatbl\n  if qualignr > 0 then\n  if dsnapfx = null then qualignr = null\n  do forever\n    parse value '' with zsel zcmd row\n    'tbquery' rtbl 'rownum(rows)'\n    if rows = 0 | qualignr = 0 | qualignr = null\n    then dsnapnl = 'zigidsna'\n    else do\n      dsnapnl = 'zigidsnb'\n      if list /= 1 then\n      call get_list\n    end\n    if ztdsels > 1\n    then 'tbdispl' dsnatbl\n    else do\n      select\n        when add_count = 0 & list = 1 then csr = 'ZSEL'\n        when dsnapfx  = null then csr = 'DSNAPFX'\n        when qualignr = null then csr = 'QUALIGNR'\n        otherwise csr = 'ZCMD'\n      end\n      zigpass = 'PASSTHRU'\n      'vput (zigpass) shared'\n      'tbtop' dsnatbl\n      'tbskip' dsnatbl 'number('top')'\n      'tbdispl' dsnatbl 'panel('dsnapnl') cursor('csr')'\n      trc = rc\n      zigpass = null\n      'vput (zigpass) shared'\n      rc = trc\n    end\n    top = ztdtop\n    if add_count > 0 then\n    pdshlq  = dsnapfx\n    if trc > 4 then do\n      zsel = null\n      'tbput' rtbl\n      'tbend' dsnatbl\n      'tbsort' rtbl 'fields(dsn,c,a)'\n      'tbtop' rtbl\n      if qualignr = 0 then pdshlq = null\n      if add_count > 0 then\n      'tbmod zigirepo order'\n      'TBSAVE zigirepo REPLCOPY LIBRARY('isptabl')'\n      extfile = save_extfile\n      return\n    end\n    if dsnapfx /= s_dsnapfx then do\n      s_dsnapfx = dsnapfx\n      zcmd = null\n      zsel = null\n      row = 0\n      call get_list\n    end\n    if row = 0 then zsel = null\n    if row <> null then\n    if row > 0 then do\n      'TBTop' dsnatbl\n      'TBSkip' dsnatbl 'Number('row')'\n    end\n\n    zcmd = translate(zcmd)\n    rf = 0\n    if abbrev('RFIND',word(zcmd,1),2) = 1 then do\n      zcmd = 'FIND' finddsn\n      rf = 1\n      'TBTop' dsnatbl\n      'TBSkip' dsnatbl 'Number('last_find+1') rowid(row)'\n      if rc > 0 then do\n        'TBTop' dsnatbl\n        last_find = 0\n        'TBSkip' dsnatbl 'Number('last_find+1') rowid(row)'\n      end\n    end\n    if abbrev('FIND',word(zcmd,1),1) = 1 then do\n      finddsn = word(zcmd,2)\n      if rf = 0 then do\n        'TBTop' dsnatbl\n        'TBSkip' dsnatbl 'Number('ztdtop') rowid(row)'\n        wrap = 0\n        found = 0\n      end\n      save_top = row\n      do forever\n        if pos(finddsn,dsna) > 0 then do\n          found = 1\n          zerrsm = 'Found.'\n          zerrlm = finddsn 'found in row' row +0\n          if wrap = 1 then zerrlm = zerrlm 'Wrap around.'\n          'setmsg msg(isrz003)'\n          last_find = row\n          if datatype(last_find) /= 'NUM' then\n          last_find = 0\n          top = row\n          leave\n        end\n        /* go to the next row */\n        'tbskip' dsnatbl 'rowid(row)'\n        if rc > 0 then if found = 0 then do\n          zerrsm = 'Not Found.'\n          zerrlm = finddsn 'not found.'\n          'setmsg msg(isrz003)'\n          top = save_top\n          last_find = 0\n          leave\n        end\n        if rc > 0 then if found = 1 then do\n          wrap = 1\n          'tbtop' dsnatbl\n          'tbskip' dsnatbl 'rowid(row)'\n          last_find = 0\n        end\n      end\n    end\n\n    if zsel /= null then\n    Select\n      when zsel = 'B' then do\n        x = listdsi(\"'\"dsna\"'\")\n        if sysdsorg = 'PO' then do\n          \"LMInit Dataid(edvbr) dataset('\"dsna\"')\"\n          \"Memlist Dataid(\"edvbr\") Default(B)\"\n          mrc = rc\n          \"LMfree Dataid(\"edvbr\")\"\n          if mrc > 0 then 'setmsg msg(isrz003)'\n        end\n        else \"Browse Dataset('\"dsna\"')\"\n      end\n      when zsel = 'S' | zsel = 'A' then do\n        rc = Check_Load_Library(dsna)\n        if rc = 0 then\n        call do_add_copy\n        else do\n          call do_add_copy 'binary'\n          gaupdate = 1\n        end\n      end\n      when zsel = 'AB' then do\n        rc = Check_Load_Library(dsna)\n        if rc = 0 then\n        call do_add_copy 'binary'\n        gaupdate = 1\n      end\n      Otherwise nop\n    end\n\n    if list = null then call get_list\n    if lc_count = 0 then do\n      zerrsm = 'Empty List'\n      zerrlm = 'The requested high level qualifier resulted in zero' ,\n        'eligible datasets.'\n      'setmsg msg(isrz003)'\n    end\n    'tbtop' dsnatbl\n  end\n  if ztdels < 2 then\n  if gaupdate = 1 then\n  call get_binfiles\n  extfile = save_extfile\n  return\n\ntbcreate_dsnatbl:\n  'tbcreate' dsnatbl 'keys(dsna) names(dastat dsnvol) nowrite'\n  return\n\nGet_List:\n  'tbend' dsnatbl\n  call tbcreate_dsnatbl\n  dsnapfx = strip(dsnapfx)\n  if qualignr > 0 then do\n    prefix = translate(dsnapfx,' ','.')\n    prefix = subword(prefix,1,qualignr)\n    prefix = translate(prefix,'.',' ')\n  end\n  else prefix = dsnapfx\n  cmd = 'ls' localrep'/'zigirep\n  x = docmd(cmd)\n  Address TSO\n  call outtrap 'x.'\n  do ip = 1 to words(dsnapfx)\n    csipfx = word(dsnapfx,ip)\n    '%zigircsi 'csipfx'.**'\n  end\n  call outtrap 'off'\n  Address ISPExec\n  do dsni = 1 to x.0\n    if word(x.dsni,1) /= 'NONVSAM' then iterate\n    dsna = word(x.dsni,2)\n    dsnvol = word(x.dsni,3)\n    dastat = null\n    do gl = 1 to so.0\n      if qualignr > 0 then do\n        if substr(dsna,length(prefix)+2) = word(so.gl,1)\n        then dastat = 'Added'\n      end\n      else do\n        if dsna = word(so.gl,1) then dastat = 'Added'\n      end\n    end\n    'tbadd' dsnatbl\n    lc_count = lc_count + 1\n  end\n  if lc_count > 0 then\n  list = 1\n  return\n\n  /* -------------------------------------------- *\n  | Perform the actual copy of the added dataset |\n  | or member to the local repository.           |\n  * -------------------------------------------- */\nDo_Add_Copy:\n  arg acopt\n  parse arg option with ''\n  gabs = 'git-encoding=BINARY zos-working-tree-encoding=BINARY binary'\n  call get_binfiles\n  zsel = null\n  ac_mem = null\n  copy_dsna = dsna\n  if pos('(',dsna) > 0 then\n  parse value dsna with dsna'('ac_mem')'\n  what = dsna\n  FC = listdsi(\"'\"WHAT\"'\" \"DIR\")\n  dsnb = remove_dsn_hlq(dsna)\n  ext = null\n  if ac_mem = null then\n  if extfile = 'N' then\n  if sysdsorg = 'PO' then\n  if zdsn.dsnb = null then do\n    extans = 'N'\n    call pfshow 'off'           /* make sure pfshow is off */\n    'addpop row(4) column(6)'\n    'display panel(zigiadde)'\n    drc = rc\n    'rempop'\n    call pfshow 'reset'         /* restore pfshow setting */\n    if drc = 0 then zdsn.dsnb = ext\n    if extans = 'Y' then\n    extfile = 'Y'\n  end\n  if ac_mem /= null then\n  if zdsn.dsnb /= null then do\n    ac_mem = lower(ac_mem'.'zdsn.dsnb)\n  end\n  if ac_mem /= null then dsnb = dsnb'/'ac_mem\n  zs1 = 'Copying' copy_dsna\n  zs2 = 'to' dsnb 'in OMVS'\n  if translate(option) = 'BINARY' then do\n    zs3 = 'Copy as Binary'\n  end\n  else do\n    zs3 = 'Copy as Text'\n  end\n  if sysrecfm = 'U'\n  then do\n    cplmod = '-X -I'\n    binopt = null\n    option = 'BINARY'\n    acopt = 'BINARY'\n    zs3 = 'Copy as Load Module'\n  end\n  else cplmod = null\n  if ac_mem = null then do\n    if sysmembers /= null\n    then patmem = 'Members to copy:' sysmembers\n    else patmem = null\n  end\n  else patmem = null\n  zs4 = 'Patience . . .' patmem\n  call do_popup4\n  DIR = localrep'/'zigirep\n  if SYSDSORG = 'PO' then do\n    pds = what\n    PDS = strip(PDS,\"B\",\"'\")\n    pdss = usssafe(dsnb)\n    pdsc = usssafe(pds)\n    if pos('/',pdss) > 0 then\n    parse value pdss with pdss'/'.\n    mkdir = \"mkdir -p \"DIR\"/\"pdss\n    x = docmd(mkdir)\n    binopt = null\n    if translate(option) = 'BINARY' then do\n      if cplmod = null then\n      binopt = '-B'\n      if is_binfile(dsnb) = 0 then do\n        if ac_mem = null then ga_mem = '*'\n        else ga_mem = ac_mem\n        /* setting the gitattributes file */\n        /* first convert the ASCII atrtib file to ebcdic :( */\n        cmd = 'cd 'DIR' && iconv -f ISO8859-1 -t IBM-1047 '\n        cmd = cmd '.gitattributes > .gae'\n        /* then append the binary attrib for this file */\n        cmd = cmd '&& echo \"'pdss'/'ga_mem' 'gabs'\" >> .gae '\n        /* convert it back to ascii */\n        cmd = cmd '&& iconv -f IBM-1047 -t ISO8859-1 .gae '\n        cmd = cmd '> .gitattributes '\n        /* add (and commit) .gitattributes to the index */\n        cmd = cmd '&& git add .gitattributes '\n        cmd = cmd '&& git commit -m \"zigi changed .gitattributes\"'\n        cmd = cmd \".gitattributes\"\n        x = docmd(cmd)\n        /* finally remove the .gae file */\n        cmd = 'cd 'DIR' && rm .gae'\n        x = docmd(cmd)\n        call view_std 'B'\n        call get_binfiles\n      end\n    end\n    if zdsn.dsnb /= null\n    then extopt = '-S a=.'zdsn.dsnb\n    else extopt = '-U'\n    if check_mixed_bintext(dsnb) = 0 | ac_mem /= null then do\n      if pos('.',ac_mem) = 0\n      then cmem = ac_mem\n      else parse value ac_mem with cmem'.'.\n      if ac_mem /= null then pdsc = pdsc\"(\"cmem\")\"\n      call bpxwdyn \"alloc da('\"pdsc\"') shr rtddn(ddname)\"\n      copycmd = \"//'\"pdsc\"'\"\n      copycmd = '\"'copycmd'\"'\n      cmd = \"cp -v \"binopt extopt cplmod copycmd\" \"DIR\"/\"pdss\"/\"ac_mem\n      x = debug('Copying:' cmd)\n      x =docmd(cmd)\n      call bpxwdyn \"free  fi(\"|| ddname ||\")\"\n    end\n    else do\n      call outtrap 'cm.'\n      address tso 'listd' \"'\"pds\"' m\"\n      call outtrap 'off'\n      hit = 0\n      cm_count = cm.0 - 6\n      call bpxwdyn \"alloc da('\"pds\"') shr rtddn(ddname)\"\n      do ci = 7 to cm.0\n        if pos(')',cm.ci) > 0 then do\n          hit = 0\n          iterate\n        end\n        if hit = 1 then iterate\n        mem = word(cm.ci,1)\n        if pos('ALIAS(',cm.ci) > 0 then hit = 1\n        ussmem = lower(mem)'.'zdsn.dsnb\n        zs2 = 'to' dsnb'/'ussmem\n        zs4 = 'Patience . . .' ci-6 'of' cm_count\n        binopt = null\n        if is_binfile(pdss'/'ussmem) = 1 then\n        if cplmod = null then do\n          binopt = '-B'\n          zs3 = 'Copy as Binary'\n        end\n        else zs3 = 'Copy as Text'\n        call do_popup4\n        pdsc = pds\"(\"mem\")\"\n        pdss = usssafe(pdss)\n        pdsc = usssafe(pdsc)\n        ussmem = usssafe(ussmem)\n        copycmd = \"//'\"pdsc\"'\"\n        copycmd = '\"'copycmd'\"'\n        cmd = \"cp -U -v \"binopt cplmod copycmd\" \"DIR\"/\"pdss\"/\"ussmem\n        x = debug('Copying:' cmd)\n        x =docmd(cmd)\n      end\n      call bpxwdyn \"free  fi(\"|| ddname ||\")\"\n    end\n    if translate(option) = 'BINARY' then do\n      /* for some reason the git autotagging due to .gitattributes\n      does not work all the time (?? weird) so we tag it if binary\n      */\n      tagcmd = 'chtag -bR 'DIR'/'pdss'/'ac_mem\n      x = docmd(tagcmd)\n    end\n    Address TSO '%zigistat' \"'\"pds\"'\" dir\"/.zigi/\"pdss 'S'\n    x = docmd('cd' dir '&& git add .zigi/'pdss)\n  end\n  else do\n    W = usssafe(WHAT)\n    PSS = usssafe(dsnb)\n    binopt = null\n    if translate(option) = 'BINARY' then\n    if is_binfile(dsnb) = 0 then do\n      binopt = '-B'\n      /* setting the gitattributes file */\n      /* first convert the ASCII atrtib file to ebcdic :( */\n      cmd = 'cd 'DIR' && iconv -f ISO8859-1 -t IBM-1047 '\n      cmd = cmd '.gitattributes > .gae'\n      /* then append the binary attrib for this file */\n      cmd = cmd '&& echo \"'pss gabs'\" >> .gae '\n      /* convert it back to ascii */\n      cmd = cmd '&& iconv -f IBM-1047 -t ISO8859-1 .gae '\n      cmd = cmd '> .gitattributes '\n      /* add (and commit) .gitattributes to the index */\n      cmd = cmd '&& git add .gitattributes '\n      cmd = cmd '&& git commit -m \"ZIGI changed .gitattributes\"'\n      /* finally remove the .gae file */\n      cmd = cmd '&& rm .gae'\n      x = docmd(cmd)\n      call get_binfiles\n    end\n    if sysrecfm = 'U'\n    then binopt = binopt '-X -I'\n    copycmd = \"//'\"W\"'\"\n    copycmd = '\"'copycmd'\"'\n    copycmd = \"cp -U -v \"binopt copycmd\" \"DIR\"/\"pss\n    x = debug('Copying:' copycmd)\n    x =docmd(copycmd)\n    if translate(option) = 'BINARY' then do\n      /* for some reason the git autotagging due to .gitattributes\n      does not work all the time (?? weird) so we tag it if binary\n      */\n      tagcmd = 'chtag -b 'DIR'/'pss\n      x =docmd(tagcmd)\n    end\n  end\n  dsnstat = '\u00dd??\u00a8 Untracked'\n  dsn = dsnb\n  fulldsn = \"'\"what\"'\"\n  pdshlq = dsnapfx\n  'tbadd' rtbl\n  dastat = 'Added'\n  'tbmod' dsnatbl\n  add_count = add_count + 1\n  call save_dsninfo\n  return\n\n  /* ------------------------------------------------------- *\n  | Get the DCB and optionally Directory info for the added |\n  | dataset and save in the /.zigi/dsn file for use when    |\n  | creating/recreating the z/OS dataset.                   |\n  |                                                         |\n  | Routine uses OGET and OPUT along with ALLOC/EXECIO.     |\n  |                                                         |\n  | Format is:                                              |\n  | dsn PS/PO recfm lrecl blksize extension                 |\n  | the extension is optional - no preceeding period        |\n  * ------------------------------------------------------- */\nsave_dsninfo:\n  /* better make sure sd. stem is empty before we start :) */\n  sd. = ''\n  sd.0 = 0\n  x = listdsi(fulldsn)\n  dsn_record = dsn sysdsorg sysrecfm syslrecl sysblksize zdsn.dsn\n  if sysvar('syspref') = null then pref = sysvar('sysuid')'.'\n  else pref = null\n  sd_dsn = pref'zigi.t'time('s')\n  sd_dd  = 'zdd'time('s')\n  path = localrep\"/\"zigirep\"/.zigi/dsn\"\n  address tso\n  call outtrap 'x.'\n  \"oget '\"path\"'\" sd_dsn 'text'\n  'alloc f('sd_dd') shr ds('sd_dsn')'\n  'execio * diskr' sd_dd '(finis stem sd.'\n  do x = 1 to sd.0\n    wd = translate(sd.x,' ','/')\n    if word(wd,1) = dsn then do\n      sd.x = '*'sd.x\n    end\n  end\n  slast = sd.0\n  slast = slast + 1\n  sd.slast = dsn_record\n  sd.0 = slast\n  do sx = 1 to sd.0\n    sd.sx = translate(sd.sx,' ','0D'x)\n  end\n  'execio * diskw' sd_dd '(finis stem sd.'\n  call outtrap 'x.'\n  'oput' sd_dsn \"'\"path\"' text\"\n  'free f('sd_dd')'\n  'delete' sd_dsn\n  cmd = 'cd 'localrep'/'zigirep' && git add .zigi/dsn'\n  x = docmd(cmd)\n  call outtrap 'off'\n  Address ISPExec\n  return\n\nWrite_FD:\n  parse arg string\n  string = string || ESC_R || ESC_N\n  'write' fd 'string' length(string)\n  return\n\n  /* ----------------------------------------------------------- *\n  | Undo Routine to revert an element in a Modified state prior |\n  | to a commit.                                                |\n  * ----------------------------------------------------------- */\nDo_Undo:\n  if readonly = 1 then do\n    zerrsm = 'Invalid.'\n    zerrlm = 'UNDO is not supported for ReadOnly Repositories.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  arg uopt\n  if uopt = 'D' then mem = null\n  zerrsm = null\n  /* -------------------------------- *\n  | Undo a commit. eg checkout --    |\n  * -------------------------------- */\n  d = usssafe(dsn)\n  if uopt = 'M' then\n  m = usssafe(mem)\n\n  zs1 = 'Un-modiying 'mem\n  zs2 = 'This never happened...'\n  call do_popup\n  address 'SYSCALL' 'SLEEP (1)'\n\n  if uopt = 'M'\n  then parse value memstat with '\u00dd'vm'\u00a8' vt\n  else parse value dsnstat with '\u00dd'vm'\u00a8' vt\n  if pos('M',vm) = 0 then do\n    zerrsm = 'Not Applicable'\n    zerrlm = 'Undo is only valid on a status of \u00ddM \u00a8 or \u00dd M\u00a8' ,\n      'where the element is modified or Ready for commit.'\n    'setmsg msg(isrz003)'\n  end\n\n  /* ------------------------ *\n  | check for file extension |\n  * ------------------------ */\n  if uopt = 'M' then do\n    if zdsn.dsn /= null\n    then rm = lower(m)'.'zdsn.dsn\n    else rm = m\n  end\n\n  if zerrsm = null then do\n    cmd = 'cd' localrep'/'zigirep\n    cmd2 = null\n    if pos('Ready to',vt) > 0 then do\n      if mem = null\n      then cmd2 = '&& git reset HEAD' d\n      else do\n        cmd2 = '&& git reset HEAD' d'/'rm\n        cmd2 = cmd2 '&& git reset HEAD .zigi/'d\n        cmd2 = cmd2 '&& git checkout -- .zigi/'d\n      end\n    end\n    if uopt = 'M'\n    then cmd = cmd cmd2 ' && git checkout -- 'd'/'rm\n    else cmd = cmd cmd2 ' && git checkout -- 'd\n    cmd = cmd '&& echo \"----------------------\"'\n    x = docmd(cmd)\n    drop combine.\n    combine.0 = 0\n    call combine_msgs\n    if is_binfile(dsn) = 1 then cpbin = '-B'\n    else cpbin = null\n    if uopt = 'M' then do\n      cmd = 'cd' localrep'/'zigirep'/'d\n      fdsn = strip(fulldsn,'B',\"'\")\n      cmd = cmd '&& echo \"Copy results:\" && echo \" \"'\n      cmd = cmd '&& cp -Uv' cpbin rm ,\n        '\"//' || \"'\"usssafe(fdsn)\"(\"m\")'\" || '\"'\n    end\n    else do\n      cmd = 'cd' localrep'/'zigirep\n      cmd = cmd '&& echo \"Copy results:\" && echo \" \"'\n      cmd = cmd '&& cp -Uv' cpbin d ,\n        '\"//' || \"'\"usssafe(strip(fulldsn,'B',\"'\"))\"'\" || '\"'\n    end\n    cmd = cmd '&& echo \" \" && echo \"after copy status:\" && git status'\n    x = docmd(cmd)\n    call combine_msgs\n    call view_std 'C'\n    drop combine.\n    combine.0 = 0\n    if uopt = 'M' then do\n      sfile = localrep'/'zigirep'/.zigi/'d\n      statmems = mem\n      'vput (statmems)'\n      Address TSO '%zigistat' fulldsn sfile 'U'\n      memstat = null\n      'tbmod' rtbl\n    end\n    call update_repo_metadata\n    if uopt = 'D'\n    then call work_with_repo\n    else call work_with_repo_file\n  end\n  return\n\n  /* ------------------------- *\n  | Do History for an element |\n  * ------------------------- */\ndo_history:\n  parse arg element\n  zerrlm = null\n  zsel = null\n  update_flag = 0\n  select\n    When filetype = '(D)' then zerrlm = 'History does not work on directories'\n    When left(element,1) = \"'\" then do\n      x = listdsi(element)\n      if sysdsorg = 'PO' then\n      zerrlm = 'History does not work on Partitioned Datasets'\n    end\n    otherwise nop\n  end\n  if zerrlm /= null then do\n    zerrsm = 'Error.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  if zdsn.dsn /= null then do\n    if pos('/',element) > 0\n    then parse value element with l'/'element\n    else l = null\n    element = lower(element)'.'zdsn.dsn\n    if l /= null then element = l'/'element\n  end\n  shelement = element\n  if pos('/',zigirep) > 0 then do\n    parse value zigirep with x'/'zrep\n    element = zrep'/'element\n  end\n  cmd = 'cd' localrep'/'zigirep\n  cmd = cmd '&& git log --cc -m -n 9999 --unified=1'\n  cmd = cmd \"--pretty=format:'commit:%h %b Date:%cD Subject:%f' --name-only\" ,\n    '| grep -e commit -e' usssafe(element)\n  x = docmd(cmd)\n  hhit = 0\n  hist_tbl = 'ZHIST'random(999)\n  'tbcreate' hist_tbl 'Names(hdate hcommit hsubject) nowrite'\n  do ih = 1 to so.0\n    if left(so.ih,7) = 'commit:' then do\n      if pos('Date:',so.ih) = 0 then iterate\n      parse value so.ih with 'commit:'hcommit 'Date:'.',' d m year ,\n        time zone 'Subject:'hsubject\n      m = wordpos(translate(m), ,\n        'JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEV')\n      hdate = year'/'right(m+100,2)'/'right(d+100,2) time\n    end\n    else do\n      so.ih =strip(shelement)\n      if element /= shelement then iterate\n    end\n    hhit = 1\n    'tbadd' hist_tbl\n  end\n  if hhit = 0 then do\n    zerrsm = 'Warning'\n    zerrlm = 'There was no git commit history found.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  'control display save'\n  if hhit = 1 then do\n    delement = element\n    if pos('/',delement) > 0 then do\n      parse value delement with le'/'re\n    end\n    'tbtop' hist_tbl\n    save_top = ztdtop\n    top = 1\n    save_ztdsels = ztdsels\n    last_hfind = 0\n    wrap = 0\n    do forever\n      zsel = null\n      if ztdsels > 1 then 'tbdispl' hist_tbl\n      else do\n        zigpass = 'PASSTHRU'\n        'vput (zigpass) shared'\n        'tbtop' hist_tbl\n        'tbskip' hist_tbl 'number('top')'\n        'tbdispl' hist_tbl 'Panel(zigihist)'\n        drc = rc\n        zigpass = null\n        'vput (zigpass) shared'\n      end\n      if drc > 4 then leave\n      top = ztdtop\n\n      if zcmd = 'RFIND' then do\n        zcmd = 'FIND' fstring\n        'tbtop' hist_tbl\n        'tbskip' hist_tbl 'number('last_hfind')'\n      end\n      if strip(zcmd) /= null then\n      if abbrev('FIND',translate(word(zcmd,1))) = 1 then do\n        fstring = translate(word(zcmd,2))\n        zcmd = null\n        do forever\n          'tbskip' hist_tbl 'Position(fcrp)'\n          if rc > 0 then if wrap = 1 then do\n            zerrsm = 'Not Found'\n            zerrlm = fstring 'not found.'\n            'setmsg msg(isrz003)'\n            leave\n          end\n          else do\n            wrap = 1\n            'tbtop' hist_tbl\n          end\n          if pos(fstring,translate(hsubject)) > 0 then do\n            top = fcrp + 0\n            zerrsm = 'Found'\n            if wrap = 1\n            then wmsg = 'wrapped.'\n            else wmsg = null\n            zerrlm = fstring 'found in row' fcrp + 0 wmsg\n            last_hfind = fcrp\n            wrap = 0\n            'setmsg msg(isrz003)'\n            leave\n          end\n        end\n      end\n\n      if ztdsels = 0 then\n      if pnsdef = 'P' then do\n        if row = 0 then zcmd = 'O'\n        if row > 0 then zsel = '/'\n      end\n\n      if zsel = '/' then do\n        call pfshow 'off'           /* make sure pfshow is off */\n        'Addpop row(4) column(6)'\n        'Display Panel(zigirhst)'\n        'rempop'\n        call pfshow 'reset'         /* restore pfshow setting */\n      end\n      if zsel /= null then\n      Select\n        When zsel = 'C' then call DoHist_ComView\n        When zsel = 'R' then call DoHist_Recover\n        When zsel = 'S' then call DoHist_ViewSource\n        Otherwise nop\n      end\n    end\n  end\n  'control display restore'\n  'tbend' hist_tbl\n  ztdsels = save_ztdsels\n  ztdtop = save_top\n  if update_flag = 1 then do\n    if sysdsorg = 'PS' then call work_with_repo\n    else do\n      call update_repo_metadata\n      call work_with_repo_file\n    end\n  end\n  return\n\n  /* ---------------------------------------- *\n  | Confirm removal of the requested element |\n  * ---------------------------------------- */\nConfirm_Remove:\n  parse arg rxdsn\n  if remc = 'YES' then return 0\n  if remc = null then remc = 'NO'\n  rema = null\n  remq = null\n  call pfshow 'off'           /* make sure pfshow is off */\n  if pos('(',rxdsn) = 0\n  then rmpan = 'zigirmsq'\n  else rmpan = 'zigiremq'\n  'Addpop row(4) column(12)'\n  'Display Panel('rmpan')'\n  drc = rc\n  if rema /= 'YES' then rrc = 4\n  else rrc = 0\n  'Rempop'\n  if drc > 0 then do\n    rrc = 4\n    remc = 'NO'\n  end\n  call pfshow 'reset'         /* restore pfshow setting */\n  return rrc\n\n  /* ----------------------- *\n  | Generalized Pop Message |\n  | with msg passed         |\n  * ----------------------- */\nPop:\n  parse arg zs1 zs2\n  add = address()             /* save addressing environment */\n  Address ISPExec\n  call do_popup\n  Address add                 /* restore addressing environment */\n  return\n\n  /* ---------------------------------------- *\n  | Common routine for normal (2 line) popup |\n  * ---------------------------------------- */\nDo_Popup:\n  call pfshow 'off'           /* make sure pfshow is off */\n  'Control Display Lock'\n  'Addpop row(4) column(8)'\n  'Display Panel(zigipop)'\n  'Rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  return\n\n  /* ---------------------------------------- *\n  | Common routine for normal (2 line) popup |\n  * ---------------------------------------- */\nDo_PopupP:\n  call pfshow 'off'           /* make sure pfshow is off */\n  'Addpop row(4) column(8)'\n  'Display Panel(zigipop)'\n  'Rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  return\n\n  /* ---------------------------------------- *\n  | Common routine for normal (3 line) popup |\n  * ---------------------------------------- */\nDo_Popup3:\n  call pfshow 'off'           /* make sure pfshow is off */\n  'Control Display Lock'\n  'Addpop row(4) column(4)'\n  'Display Panel(zigipop3)'\n  'Rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  return\n\n  /* ---------------------------------------- *\n  | Common routine for normal (4 line) popup |\n  * ---------------------------------------- */\nDo_Popup4:\n  call pfshow 'off'           /* make sure pfshow is off */\n  'Control Display Lock'\n  'Addpop row(4) column(6)'\n  'Display Panel(zigipop4)'\n  'Rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  return\n\n  /* ---------------------------------------- *\n  | Common routine for normal (4 line) popup |\n  * ---------------------------------------- */\nDo_Popup4p:\n  call pfshow 'off'           /* make sure pfshow is off */\n  'Addpop row(4) column(6)'\n  'Display Panel(zigipop4)'\n  'Rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  return\n\n  /* ----------------------------------------------------- *\n  | Get the users current OMVS enviornment for use in the |\n  | bpxwunix commands.                                    |\n  * ----------------------------------------------------- */\nGETENV:\n  x = debug('Starting collection of env variables')\n  cmd  = docmdx('env')\n  rc = bpxwunix(cmd,,env.,se.)\n  envc = env.0\n  call add_env '_BPX_SHAREAS=YES'\n  call add_env '_BPX_SPAWN_SCRIPT=YES'\n  call add_env 'EXPORT _EDC_ADD_ERRNO2=1'\n  call add_env '_EDC_ZERO_RECLEN=Y'\n  env.0 = envc\n  drop so. se.\n  x = debug('Finished collection of env variables')\n  return\n\n  /* -------------------- *\n  | Add info to env stem |\n  * -------------------- */\nadd_env:\n  parse arg env_val\n  envc = envc + 1\n  env.envc = env_val\n  return\n\ndocmd:\n  parse arg cmd\n  drop so. se.\n  if gitenv /= null then do\n    cmd = \". \"gitenv\" > /dev/null 2>&1 && \"cmd\n  end\n  x = bpxwunix(cmd,,so.,se.,env.)\n  return x\n\ndocmdx:\n  /* quircky thing, we need to export HOME as we are\n  not running a login shell via bpxwunix */\n  parse arg cmd\n  drop o. se.\n  if rx = null then do\n    rx = 'export HOME='home' && . /etc/profile > /dev/null 2>&1 && '\n    c = \"\u00dd\u00dd -f \"home\"/.profile \u00a8\u00a8 && echo f\"\n    x = bpxwunix(c,,o.,se.)\n    if o.0 = 1 & o.1 = \"f\" then do\n      rx = rx '. 'home'/.profile > /dev/null 2>&1 && '\n    end\n  end\n  r = rx ' ' cmd\n  return r\n\nview_debug:\n  if zigidebg = 1 then do\n    filev = debugfil\n    'view  file(filev)'\n  end\n  else do\n    zerrsm = 'Invalid.'\n    zerrlm = 'VIEWD is not supported when debug is not enabled. To' ,\n      'enable debug allocate a ZIGIDEBG DD to Dummy and' ,\n      'restart ZIGI.'\n    'setmsg msg(isrz003)'\n  end\n  return\n\ndebug:\n  if zigidebg  = 1 then do\n    parse arg msg\n    msg = Date() Time()' : 'msg\n    c = 'echo \"'msg'\" >>' debugfil\n    x = bpxwunix(c,,dso.,dse.,env.)\n    zigidebg_use = 1\n  end\n  return 0\n\n  /* --------------------------------- *\n  | Add a message to the combine stem |\n  * --------------------------------- */\nAdd_Combine:\n  parse arg msg\n  combine_count = combine.0\n  combine_count = combine_count + 1\n  combine.combine_count = '   '\n  combine_count = combine_count + 1\n  combine.combine_count = msg\n  combine_count = combine_count + 1\n  combine.combine_count = '   '\n  combine.0 = combine_count\n  return\n\n  /* --------------------------------------------------------- *\n  | Combine the stdout and stderr messages into combine. stem |\n  | for viewing.                                              |\n  * --------------------------------------------------------- */\nCombine_msgs:\n  combine_count = combine.0\n  do combi = 1 to so.0\n    combine_count = combine_count + 1\n    combine.combine_count = strip(so.combi,'T')\n    if combine.combine_count = null then combine.combine_count = ' '\n  end\n  do combi = 1 to se.0\n    combine_count = combine_count + 1\n    combine.combine_count = strip(se.combi,'T')\n    if combine.combine_count = null then combine.combine_count = ' '\n  end\n  combine.0 = combine_count\n  return\n\n  /* -------------------------------------------- *\n  | Get the date/time for the provided omvs file |\n  * -------------------------------------------- */\nget_fd_date:\n  parse arg file_var\n  x = docmd('ls -la' file_var)\n  fdate = subword(so.1,6,3)\n  return fdate\n\nTest_Repo_Table_State:\n  /* --------------------------------------------- *\n  | Test to see if the ZIGIREPO table is for V2R1 |\n  | and if not upgrade it.                        |\n  * --------------------------------------------- */\n  'TBQuery zigirepo Names(names)'\n  if pos('REPONAME',names) = 0 then do\n    zs1 = 'Upgrading the ZIGI Repository ISPF Table'\n    zs2 = 'This should not take long.'\n    call do_popup\n    'tbtop zigirepo'\n    branch = null\n    remote1 = null\n    reponame = null\n    sortdate = null\n    zigicat = null\n    tc = 0\n    do forever\n      'tbskip zigirepo'\n      if rc > 0 then leave\n      'tbget zigirepo'\n      tc = tc + 1\n      key.tc = zigikey'\\'localrep'\\'pdshlq'\\'qualignr'\\'zigirep ,\n        '\\'defcpush '\\'defruid'\\'zigidate '\\' sortdate '\\' zigicat ,\n        '\\' branch '\\' remote1 '\\' reponame\n    end\n    key.0 = tc\n    'TBErase zigiorep Library('isptabl')'\n    'tbclose zigirepo name(zigiorep) library('isptabl')'\n    call create_zigirepo\n    do i = 1 to key.0\n      parse value key.i with zigikey'\\'localrep'\\'pdshlq'\\'qualignr ,\n        '\\'zigirep ,\n        '\\'defcpush'\\'defruid'\\'zigidate'\\'sortdate'\\'zigicat ,\n        '\\'branch'\\'remote1'\\'reponame\n      if right(localrep,1) = '/' then localrep = strip(localrep,'T','/')\n      if reponame = null then reponame = zigirep\n      localdir = strip(localdir)\n      zigirep  = strip(zigirep)\n      zigicat  = strip(zigicat)\n      sortdate  = strip(sortdate)\n      zigikey = localrep'/'zigirep\n      if cat = 0 then\n      Select\n        when zigidate /= null then do\n          zd = subword(zigidate,1,3)\n          zt = subword(zigidate,4)\n          zigidate = zd\n          if strip(zt) = null then zt = 0\n          sortdate = date('b',zd,'n') zt\n        end\n        When words(zigidate) > 3 then do\n          zigidate = strip(subword(zigidate,1,3))\n          zt = subword(zigidate,4)\n          if pos(':',zt) > 0 then zt = left(zt,2)''substr(zt,4,2)\n          sortdate = date('b',strip(zigidate),'n') zt\n        end\n        When words(zigidate) = 3 then do\n          sortdate = date('b',strip(zigidate),'n') 0\n        end\n        Otherwise call set_sortdate\n      end\n      'tbadd zigirepo order'\n      if cat = 0 then do\n        sortdate = null\n        zigicat = null\n      end\n    end\n    zerrsm = null\n    zerrlm = 'The ZIGI Repository Table has been upgraded' ,\n      'with new variables' ,\n      'and the prior version of the table has been saved in DD' ,\n      isptabl 'as ZIGIREPO.'\n    'setmsg msg(isrz003)'\n  end\n  Return\n\nparseGitURI:\n  /* --------------------------------------------- *\n  | Parse the various forms of git repo uri's into|\n  | <user> <site> <port> <repo>                   |\n  * --------------------------------------------- */\n  parse arg uri\n  /* port and user defaults */\n  port = 22\n  /* normal style ssh:// processing */\n  if translate(substr(uri,1,6)) = 'SSH://' then do\n    uri = substr(uri,7)\n    if pos('@',uri) > 0 & pos(':',uri) > 0 then\n    /* user and port specified */\n    parse var uri user '@' site ':' port '/' owner '/' repo\n    else\n    if pos('@',uri) > 0 & pos(':',uri) = 0 then\n    /* user but no port specified */\n    parse var uri user '@' site '/' owner '/' repo\n    else\n    if pos('@',uri) = 0 & pos(':',uri) > 0 then\n    /* no user, but port specified */\n    parse var uri site ':' port '/' owner '/' repo\n    else\n    /* no user and port specified */\n    parse var uri site '/' owner '/' repo\n  end\n  /* alternative scp-like processing */\n  else\n  /* user specified */\n  if pos('@',uri) > 0 then\n  parse var uri user '@' site ':' owner '/' repo\n  else\n  /* no user specified */\n  parse var uri site ':' owner '/' repo\n  return owner site port repo\n\n  /* -------------------------------------------------- *\n  | Routine to update git with the user name and email |\n  * -------------------------------------------------- */\nUpdate_Config:\n  /* dunno if we still need these in the profile?? */\n  'VPut (zigiuid zigimail zigissh) Profile'\n  /* maybe we could use the ispprof for some lazy caching */\n  /* now that we've had the user see the settings.\n  set the git config if they have changed...\n  */\n  if old_zigiuid /= zigiuid then do\n    x = docmd('git config --global user.name \"'zigiuid'\"')\n    if x > 0 then do\n      zs1 = \"something went wrong with git config user.name\"\n      x = so.0\n      zs2 = so.x\n      zs3 = se.1\n      zs4 = null\n      call do_popup4\n    end\n    x = docmd('git config --global user.email \"'zigimail'\"')\n    if x > 0 then do\n      zs1 = \"something went wrong with git config user.email\"\n      x = so.0\n      zs2 = so.x\n      zs3 = se.1\n      zs4 = null\n      call do_popup4\n    end\n    /* Let's adopt the new style. Only push current branch */\n    x = docmd('git config --global push.default simple')\n  end\n  'VPut (zigiuid zigimail zigissh) Profile'\n  zerrsm = 'Updated.'\n  zerrlm = 'ZIGI Settings updated successfully.'\n  'Setmsg msg(isrz003)'\n  return\n\nMGEN:\n  /* ---------------------------------------------------------- |\n  | Name:      MGEN                                            |\n  |                                                            |\n  | Function:  Return the current system  MAXGENS_LIMIT        |\n  |            which is the system max generations value       |\n  |            for PDSE Version 2 libraries                    |\n  |                                                            |\n  | Syntax:    mgen=(mgen)                                     |\n  |                                                            |\n  | ---------------------------------------------------------- */\n  parse source source\n  Numeric Digits 10\n  CVT      = C2D(Storage(10,4))\n  CVTDFA   = C2D(Storage(D2X(CVT + 1216),4))   /* cvt + 4c0 */\n  DFAMGEN  = C2D(Storage(D2X(cvtdfa + 76),4))  /* dfa + 4c */\n  return dfamgen\n\nget_binfiles:\n  /* ---------------------------------------------------------\\\n  | Name:      get_binfiles                                    |\n  |                                                            |\n  | Function:  Fills the global binfiles. stem with all        |\n  |            current repo files that are added as binary.    |\n  \\---------------------------------------------------------- */\n  cmd = 'cd 'localrep'/'zigirep' &&' ,\n    'cat .gitattributes | grep binary' ,\n    '| cut -d\" \" -f1'\n  x = docmd(cmd)\n  binfiles. = null\n  bc = 0\n  do b = 1 to so.0\n    if left(strip(so.b),2) = '*.' then iterate\n    bc = bc + 1\n    binfiles.bc = so.b\n  end\n  binfiles.0 = bc\n  return 0\n\nis_binfile:\n  /* ---------------------------------------------------------\\\n  | Name:      is_binfile                                      |\n  |                                                            |\n  | Function:  Checks the global binfiles. stem for the        |\n  |            provided dataset or dataset/member              |\n  \\---------------------------------------------------------- */\n  parse arg checkForBinFile\n  if datatype(binfiles.0) /= 'NUM' then return 0\n  do bi = 1 to binfiles.0\n    if binfiles.bi = checkForBinFile then return 1\n    if right(binfiles.bi,1) = '*' then do\n      parse value checkForBinFile with test'/'.\n      if left(binfiles.bi,length(binfiles.bi)-2) = test\n      then return 1\n    end\n  end\n  return 0\n\n  /* ---------------------------------------- *\n  | Check if a PDS has mixed binary and text |\n  * ---------------------------------------- */\nCheck_Mixed_BinText:\n  parse arg checkForBinFile\n  cmbtRC = 0\n  if datatype(binfiles.0) /= 'NUM' then return 0\n  do bi = 1 to binfiles.0\n    parse value binfiles.bi with cmbtfile'/'cmbtmbr\n    parse value checkForBinFile with checkFile'/'checkmbr\n    if cmbtfile = checkFile then\n    if cmbtmbr = '*' then cmbtRC = 0\n    else return 1\n    if binfiles.bi = checkForBinFile then return 1\n  end\n  return cmbtRC\n\ncheck_clean:\n  /* ---------------------------------------------------------\\\n  | Name:      check_clean                                     |\n  |                                                            |\n  | Function:  Checks if working dir is clean                  |\n  |            returns YES or NO                               |\n  \\---------------------------------------------------------- */\n  cmd = 'cd 'localrep'/'zigirep' && git status'\n  x = docmd(cmd)\n  clast = so.0\n  if pos('working tree clean',so.clast) > 0 then return 'YES'\n  else return \"NO\"\n\n  /* -------------------------------------------------------- *\n  | This is where the most recent pull will be reversed.     |\n  |                                                          |\n  | The reverse will use the last hash saved in: rev_head    |\n  * -------------------------------------------------------- */\nReverse_Pull:\n  cmd = 'cd' localrep'/'zigirep\n  cmd = cmd '&& git reset --hard' rev_head\n  cmd = cmd '&& git status'\n  x = docmd(cmd)\n  call view_std 'B'\n  return\n\nflowselect:\n  /* ----------------------------- *\n  | Show the flows and select one |\n  * ----------------------------- */\n  if rtbf_open = 1 then 'tbend' rtbf\n  'TBCreate' rtbf 'keys(bname) Names(brstatus) Replace NoWrite'\n  rtbf_open = 1\n  localdir = localrep'/'zigirep\n  if zigi_offline = 0 then do\n    cmd = ' && git remote prune origin > /dev/null 2>&1 && git branch -a'\n    x = docmd('cd 'localdir cmd)\n  end\n  else parse value '0 0' with so.0 se.0\n  if so.0 + se.0 = 0 then do\n    cmd = '&& git branch -a'\n    x = docmd('cd 'localdir cmd)\n  end\n  bl. = null\n  bl.0 = 0\n  do flowi = 1 to so.0\n    b1 = strip(so.flowi,'B')\n    if pos('/',b1) > 0 then do\n      /* this is a remote branch we (maybe) have never checked out */\n      seen_this_branch = 0\n      parse var b1 remotes'/'origin'/'bname zooi\n      bname = strip(bname)\n      do ii = 1 to bl.0\n        if bl.ii = bname then seen_this_branch = 1\n      end\n      if seen_this_branch = 1 then do\n        sbname = bname\n        'tbtop' rtbf\n        do forever\n          'tbskip' rtbf\n          if rc > 0 then leave\n          if sbname = bname then do\n            brstatus = 'Local/Remote'\n            'tbmod' rtbf\n            leave\n          end\n        end\n      end\n      /* but only add it to table if we haven't yet */\n      if seen_this_branch = 0 then do\n        if bname <> branch & bname <> \"HEAD\" then do\n          ni = bl.0 + 1\n          bl.ni = bname\n          bl.0 = ni\n          brstatus = 'Remote'\n          /* and only if it's a zigiflow branch */\n          if substr(bname,1,9) = 'zigiflow-' then do\n            'tbadd' rtbf\n          end\n        end\n      end\n    end\n    else do\n      /* this is already a local branch */\n      if pos('*',b1) = 0 then do\n        /* Add it to the table if it's not the current (*) branch */\n        bname = strip(so.flowi)\n        ni = bl.0 + 1\n        bl.ni = b1\n        bl.0 = ni\n        brstatus = 'Local'\n        if substr(bname,1,9) = 'zigiflow-' then do\n          'tbadd' rtbf\n        end\n      end\n    end\n  end\n  'tbsort' rtbf 'fields(bname,c,a)'\n  'tbtop' rtbf\n  save_btop = 0\n  do forever\n    zcmd = null\n    cc_rc = 0\n    newb = null\n    zsel = null\n    if save_btop > 0 then do\n      'tbtop' rtbf\n      'tbskip' rtbf 'number('save_btop')'\n    end\n    'tbdispl' rtbf 'panel(zigifsel)'\n    if rc > 4 then leave\n    save_btop = ztdtop\n    /* ----------------------------- *\n    | Workin selected flow          |\n    * ----------------------------- */\n    if zsel = \"S\" then do\n      x = docmd('cd 'localdir' && git checkout 'bname)\n      call Replace localrep zigirep pdshlq qualignr\n      call update_repo_metadata\n      branch = bname\n      leave\n    end\n  end\n  'tbend' rtbf\n  rtbf_open = 0\n  ztdsels = 0\n  zsel = null\n  return\n\n  /* ------------------------------------------------------------- *\n  | Convert a non-zig repository to enable ZIGI management.       |\n  |  - for this to work the repository must be manually setup     |\n  |    by the user after the clone thus:                          |\n  |    - All sequential files in the repo root that are z/OS      |\n  |      datasets must be renamed to upper case and using z/OS    |\n  |      naming conventions.                                      |\n  |   - all subdirectories that will be the OMVS copy of a PDS    |\n  |     must also be upper case with z/OS naming                  |\n  |   - all PDS members must be in their respective OMVS          |\n  |     subdirectory without a suffix and follow PDS member       |\n  |     name conventions and be upper case                        |\n  |                                                               |\n  | This routine will call ZIGICNVT and pass the OMVS directory   |\n  | for the repository to be converted.                           |\n  |                                                               |\n  | After conversion the ZIGICKOT routine will be called to copy  |\n  | the OMVS files into their respective z/OS datasts (which will |\n  | be dynamically allocated)                                     |\n  * ------------------------------------------------------------- */\nConvert_Repo:\n  convdir = localrep'/'zigirep\n  'vput (convdir)'\n  'Select cmd(%zigicnvt)'\n  qualignr = words(translate(pdshlq,' ','.'))\n  call Replace localrep zigirep pdshlq qualignr\n  return\n\nDo_Tag_Extract:\n  x = check_clean()\n  if x = 'NO' then do\n    zerrsm = null\n    zerrlm = left('The current repository has uncommited changes.',74) ,\n      'Resolve and try again.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  do forever\n    call pfshow 'off'           /* make sure pfshow is off */\n    'Addpop row(3) column(4)'\n    'Display Panel(zigitagx)'\n    drc = rc\n    'Rempop'\n    call pfshow 'reset'         /* restore pfshow setting */\n    if drc > 0 then do\n      zerrsm = 'Canceled.'\n      zerrlm = 'Extract canceled.'\n      'setmsg msg(isrz003)'\n      return\n    end\n    if tagxpath = '?' then tagxpath = zigiosel()\n    call pfshow 'off'           /* make sure pfshow is off */\n    'Addpop row(3) column(4)'\n    'Display Panel(zigiextq)'\n    drc = rc\n    'Rempop'\n    call pfshow 'reset'         /* restore pfshow setting */\n    if sans = 'Y' then leave\n  end\n  if tagxpath /= null then\n  if validate_path(tagxpath) = 8 then do\n    zerrsm = 'Error.'\n    zerrlm = tagxpath e.1\n    'Setmsg msg(isrz003)'\n    return\n  end\n  zs1 = 'Preparing the extract. This could take a minute'\n  zs2 = '(or two) so please be patient.'\n  call do_popup\n  exhlq = tagxhlq\n  expath = tagxpath\n  if expath = null then expath = '.'\n  'Select Cmd(%zigiextr' localrep'/'zigirep exhlq expath tags')'\n  return\n\n  /* --------------------------------------------------------- *\n  | This routine checks for deletes that are not included     |\n  | in the git messages. These would be PDS members that are  |\n  | deleted and thus no longer in the OMVS directory and need |\n  | to be removed from the z/OS PDS.                          |\n  * --------------------------------------------------------- */\nCheck_For_More_Deletes:\n  cmd = 'cd' localrep'/'zigirep '&& ls -lR'\n  x = docmd(cmd)\n  ckd_dir = null\n  do ck_i = 1 to so.0\n    if left(so.ck_i,2) = './' then do\n      parse value so.ck_i with './'ckd_dir':'\n      call Get_PDS_Members\n    end\n    if ckd_dir = null then iterate\n    if left(so.ck_i,1) /= '-' then iterate\n    m = word(so.ck_i,9)\n    if pos('.',m) > 0 then do\n      parse value m with m'.'.\n      m = translate(m)\n    end\n  end\n  return\n\nGet_PDS_Members:\n  members = null\n  call outtrap 'pdsmems.'\n  address tso \"listd '\"delhlq\".\"dir\"' M\"\n  call outtrap 'off'\n  do gm = 7 to pdsmems.0\n    members = members word(pdsmems.gm,1)\n  end\n  drop pdsmems.\n  return\n\n  /* -------------------------------------------------------- *\n  | Get the file extension information for the datasets from |\n  | .zigi/dsn.                                               |\n  * -------------------------------------------------------- */\nget_dsn_info:\n  zdsn. = null\n  cmd = 'cat' localrep'/'zigirep'/.zigi/dsn'\n  x = bpxwunix(cmd,,s.,e.,env.)\n  if x > 0 then return\n  do di = 1 to s.0\n    zd = word(s.di,1)\n    zdsn.zd = word(s.di,6)\n    zdsn.0 = zd\n  end\n  drop s. e.\n  return\n\n  /* ------------------------------------- *\n  * Name:     Lower                       *\n  *                                       *\n  * Function: Lowercase the provided data *\n  *                                       *\n  * Syntax:   x=lower(input)              *\n  * ------------------------------------- */\nLower:\n  parse arg Lower_Input\n  Lower_Out = translate(Lower_Input,\"abcdefghijklmnopqrstuvwxyz\",,\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n  return Lower_Out\n\n  /* -------------------------------------------- *\n  | View the commit log for this historical item |\n  * -------------------------------------------- */\nDoHist_ComView:\n  cmd = 'cd' localrep'/'zigirep\n  cmd = cmd '&& git log' hcommit '-n 1 --cc'\n  x = docmd(cmd)\n  'control display save'\n  call view_std 'X' 'V'\n  'control display restore'\n  zsel = null\n  return\n\n  /* ----------------------------------------------------------- *\n  | Recover the specific historical level of the element. This  |\n  | does use the dohist_file_extract routine to get the element |\n  | and then prompts for a target dataset.                      |\n  | If the element is a PDS member then it must be recovered to |\n  | a PDS member.                                               |\n  * ----------------------------------------------------------- */\nDoHist_Recover:\n  if readonly = 1 then do\n    zerrsm = 'Invalid.'\n    zerrlm = 'History Recover is not supported for ReadOnly Repositories.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  if dsnvalid(fulldsn) = 'NO' then do\n    zerrsm = 'Error.'\n    zerrlm = 'The recovery of a non-z/OS dataset is not supported' ,\n      'at this time. You can use S to view the historical' ,\n      'data and then copy it into the clipboard to paste' ,\n      'into a OMVS file to recover it.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  if left(fulldsn,1) /= \"'\" then\n  relement = fulldsn\n  if left(fulldsn,1) = \"'\" then do\n    if pos('/',element) = 0\n    then relement = fulldsn\n    else do\n      parse value element with .'/'rcmem\n      if zdsn.dsn /= null then\n      parse value rcmem with rcmem'.'.\n      relement = left(fulldsn,length(fulldsn)-1) ,\n        || \"(\"rcmem\")'\"\n    end\n  end\n  rdsn = null\n  ralc = 'N'\n  rans = null\n  rover = null\n  call pfshow 'off'           /* make sure pfshow is off */\n  'Addpop row(4) column(8)'\n  'Display Panel(zigiresq)'\n  drc = rc\n  'Rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  if drc > 0 then return\n  if rans = 'N' then return\n  rcdd = 'RC'random(99999)\n\n  address tso\n  if sysdsn(rdsn) = 'DATASET NOT FOUND' then ralloc = 'Y'\n  else ralloc = 'N'\n  if ralloc = 'N'\n  then 'Alloc f('rcdd') shr reuse da('rdsn')'\n  else 'Alloc f('rcdd') new like('relement') da('rdsn')'\n  'Free f('rcdd')'\n  save_rdsn = rdsn\n\n  call dohist_file_extract\n\n  if is_binfile(rdsn) = 1 then binopt = '-B'\n  else binopt = null\n  x = check_llib(rdsn)\n  if x = 0 then binopt = binopt '-X -I'\n\n  cmd = 'cd' localrep'/'zigirep ,\n    '&& cp -UA' binopt usssafe(file) ,\n    '\"//'rdsn'\"'\n  x = docmd(cmd)\n  if x > 0 then call view_std 'B'\n\n  x = bpxwunix('rm' usssafe(file))\n\n  address ispexec\n\n  teste = strip(relement,'B',\"'\")\n  testr = strip(rdsn,'B',\"'\")\n  parse value teste with teste'('.\n  parse value testr with testr'('.\n\n  if is_binfile(rdsn) = 1 then binopt = '-B'\n  else binopt = null\n  x = check_llib(rdsn)\n  if x = 0 then binopt = binopt '-X -I'\n  if pos('-X',binopt) = 0 then\n  if pos('(',rdsn) > 0 then do\n    parse value rdsn with rdsn\"(\"mem\")\"\n    if left(rdsn,1) = \"'\" then rdsn = rdsn\"'\"\n    \"LMINIT DATAID(zstats) DATASET(\"rdsn\")\"\n    \"LMOPEN DATAID(\"zstats\") OPTION(INPUT)\"\n    'LMMSTATS DATAID('zstats') Member('mem') user('zluser')'\n    \"LMClose Dataid(\"zstats\")\"\n    \"LMFree  Dataid(\"zstats\")\"\n  end\n  if teste = testr then do\n    m = usssafe(strip(mem))\n    if sysvar('syspref') = null\n    then pref = sysvar('sysuid')\n    else pref = sysvar('syspref')\n    if left(rdsn,1) /= \"'\"\n    then rdsne = pref'.'rdsn\n    else rdsne = rdsn\n    e = usssafe(strip(rdsne,'B',\"'\"))\n    r = usssafe(dsn)\n\n    if zdsn.dsn /= null\n    then rm = lower(strip(mem)'.'zdsn.dsn)\n    else rm = m\n    rm = usssafe(rm)\n\n    copycmd = \"//'\"e\"(\"m\")'\"\n    copycmd = '\"'copycmd'\"'\n    copycmd = \"cp \"binopt\" -U -v\" copycmd\" \"localrep\"/\"zigirep\n    copycmd = copycmd || \"/\"r\"/\"rm\n    x = docmd(copycmd)\n    if x > 0 then call view_std 'B'\n    zerrsm = 'Completed.'\n    zerrlm = relement 'successfully recovered into' save_rdsn ,\n      left(' ',76) ,\n      'the recovered element will be in a Modified state and will' ,\n      'need to be added to the staging index and committed if' ,\n      'desired.'\n    'setmsg msg(isrz003)'\n    if fulldsn = rdsn then update_flag = 1\n  end\n  zerrsm = 'Success.'\n  zerrlm = element 'successfully recovered.'\n  'setmsg msg(isrz003)'\n  \"View Dataset('\"strip(rdsn,'B',\"'\")\"(\"mem\")')\"\n  if rc > 0 then say zerrlm\n  return\n\n  /* ---------------------------------------------------------- *\n  | View the Source for the element at the historical (commit) |\n  | point in time.                                             |\n  * ---------------------------------------------------------- */\nDoHist_ViewSource:\n  call dohist_file_extract\n  vtitle = element '\\' hdate '\\' hsubject '\\' fulldsn\n  gitcmde = null\n  'vput (vtitle gitcmde localrep zigirep)'\n  'View File(file) panel(zigiedit) macro(zigivmac)'\n  x = bpxwunix('rm' usssafe(file))\n  return\n\n  /* ------------------------------------------------------ *\n  | Extract the historic level of the element based on the |\n  | commit hash provided.                                  |\n  |                                                        |\n  | 1. change (checkout) to the commit hash level          |\n  | 2. copy (cp) the requested file to home/tmp/file-name  |\n  | 3. change (checkout) back to the original branch       |\n  * ------------------------------------------------------ */\nDoHist_File_Extract:\n  if pos('/',element) > 0\n  then do\n    parse value element with file'/'work\n    file = translate(file,' ','.')\n    ext = word(file,words(file))\n    file = home'/tmp/'work'.'ext\n  end\n  else file = home'/tmp/'element\n  call check_tmp\n  cmd = 'cd' localrep'/'zigirep ,\n    '&& git checkout' hcommit ,\n    '&& cp' localrep'/'zigirep'/'usssafe(element) usssafe(file)\n  x = docmd(cmd)\n  if x > 0 then call view_std 'B'\n  cmd = 'cd' localrep'/'zigirep ,\n    '&& git checkout' branch\n  x = docmd(cmd)\n  if x > 0 then call view_std 'B'\n  return\n\n  /* ------------------------------------------------------------ *\n  | Checks for the home/tmp directory by attempting to create it |\n  | and if it exists great, if not then it does now.             |\n  * ------------------------------------------------------------ */\nCheck_TMP:\n  x = bpxwunix('mkdir' home'/tmp',,so.,se.)\n  return\n\n  /* ------------------------------- *\n  | Validate the provided OMVS Path |\n  * ------------------------------- */\nValidate_path:\n  parse arg valid_path\n  if valid_path = null then return 8\n  valid_path = translate(valid_path,' ','/')\n  valid_path = subword(valid_path,1,words(valid_path)-1)\n  valid_path = '/'translate(valid_path,'/',' ')'/'\n  x = bpxwunix('ls -la' valid_path,,n.,e.,env.)\n  if e.0 > 0 then return 8\n  else return 0\n\n  /* -------------------------------------------------- *\n  | Check for load library                             |\n  |  - argument passed is fully qualified dataset name |\n  |  - return codes                                    |\n  |    0 = load library                                |\n  |    1 = not a load library                          |\n  * -------------------------------------------------- */\nCheck_LLib:\n  arg check_llib_dsn\n  x = listdsi(check_llib_dsn)\n  if sysrecfm = 'U'\n  then do\n    x = check_load_library(dsn)\n    return rc\n  end\n  else return 1\n\nCheck_Load_Library:\n  arg check_loadlib_dsn\n  x = listdsi(\"'\"check_loadlib_dsn\"'\")\n  if sysrecfm /= 'U' then return 0\n  x = check_lmod_ptf()\n  if x = 0 then return 0\n  zerrsm = 'Not Supported.'\n  zerrlm = 'Load Library support is not available. To enable it install' ,\n    'PTF UJ01358 for z/OS 2.2 or UJ01356 for z/OS 2.3.'\n  'setmsg msg(isrz003)'\n  return 4\n\n  /* -------------------------------------------------- *\n  | Validate that the PTF with the -I support has been |\n  | installed and return 0 if good and >0 if not       |\n  * -------------------------------------------------- */\nCheck_LMOD_PTF:\n  cmd = 'cp -X -I \"//'\n  cmd = cmd\"'SYS1.LINKLIB(IEFBR14)'\"\n  cmd = cmd '\"  test'\n  x = docmd(cmd)\n  return x\n\n  /* --------------------------- *\n  | Add statistics to a member. |\n  * --------------------------- */\nAdd_Stats:\n  arg mstats\n  zstats = 'ZS'time('s')\n  \"LMINIT DATAID(zstats) DATASET(\"fulldsn\")\"\n  \"LMOPEN DATAID(\"zstats\") OPTION(INPUT)\"\n  parse value mstats with upmbr ZLCDATE ZLMDATE ZLVERS ZLMOD ,\n    ZLMTIME ZLCNORC ZLINORC ZLMNORC ZLUSER ZLCNORCE ,\n    ZLINORCE ZLMNORCE .\n  if zlcdate = null then ,\n    'LMMSTATS DATAID('zstats') Member('upmbr') user('sysvar(sysuid)')'\n  else ,\n    'LMMSTATS DATAID('zstats') MEMBER('upmbr') VERSION('zlvers')' ,\n    'MODLEVEL('zlmod') CREATED('zlcdate') MODDATE('zlmdate')' ,\n    'MODTIME('zlmtime') INITSIZE('zlinorc')' ,\n    'MODRECS('zlmnorc') USER('zluser')'\n  \"LMClose Dataid(\"zstats\")\"\n  \"LMFree  Dataid(\"zstats\")\"\n  return\n\n  /* ------------------------------------------------------------- *\n  | Change to the new branch                                      |\n  | Then determine what changed from the previous branch to       |\n  | this branch.                                                  |\n  | Based on the delta setup the zigickot input to make the       |\n  | changes for only those affected elements (and handle deletes) |\n  * ------------------------------------------------------------- */\nCheck_Branch_Delta:\n  cmd = 'cd 'localdir' && git checkout 'bname\n  cmd = cmd '&& git diff --name-status' branch'..'bname\n  x = docmd(cmd)\n  if x > 0 then call view_std 'B'\n  Report_Header = 'ZIGI Branch Change Report'\n  delta_from = branch\n  delta_to   = bname\n  call  Check_Delta\n  return\n\nAdd_Report:\n  parse arg br_text\n  rcr = rcr + 1\n  report.rcr = br_text\n  report.0 = rcr\n  return\n\nCheck_Delta:\n  x05 = '05'x\n  parse value '' with brdsns brmems. brdeletes pullmems. report.\n  rcr = 0\n  call add_report report_header copies(' ',10) ,\n    date('n') time('c')\n  call add_report 'From branch:' delta_from\n  call add_report 'To branch:  ' delta_to\n  call add_report ' '\n  call add_report 'Elements added or changed from branch:' delta_from\n  call add_report ' '\n  /* Get the HLQ for use */\n  if qualignr = 0\n  then ckothlq = null\n  else do\n    ckothlq = translate(pdshlq,' ','.')\n    if qualignr /= '*' then\n    ckothlq = subword(ckothlq,1,qualignr)\n    ckothlq = translate(ckothlq,'.',' ')'.'\n  end\n  /* ------------------------------- *\n  | Process the differences report: |\n  | M = modified                    |\n  | A = added                       |\n  | D = deleted                     |\n  | R = renamed                     |\n  |     - ignore the xxx in Rxxx    |\n  * ------------------------------- */\n  do bri = 1 to so.0\n    if pos(x05,so.bri) = 0 then iterate\n    data = translate(so.bri,' ',x05)\n    parse value data with change_flag change_file\n    if left(change_file,1) = '.' then iterate\n    change_flag = left(change_flag,1)\n    call brDelta\n  end\n  do zz = 1 to words(brdsns)\n    zd = word(brdsns,zz)\n    zw = words(brmems.zd)\n    ldsn = \"'\"ckothlq\"\"zd\"'\"\n    x = listdsi(ldsn \"dir\")\n    if sysdsorg /= 'PO' then iterate\n    interpret 'zv'zz '= (brmems.zd)'\n    'vput zv'zz\n  end\n  ckotdir = localrep'/'zigirep\n  pulldsns = brdsns\n  if pulldsns /= null then do\n    ckotqual = qualignr\n    'vput (ckotdir ckothlq pulldsns ckotqual)'\n    'Select cmd(%zigickot)'\n  end\n  'vget (badckot) shared'\n  if badckot = 1 then do\n    zerrsm = 'Failed.'\n    zerrlm = 'z/OS Dataset Update failed due to one, or more, of the' ,\n      'target datasets are allocated. Free those allocations and' ,\n      'try again.'\n    'Setmsg Msg(isrz003)'\n    'verase (badckot) shared'\n    return\n  end\n  if words(brdeletes) > 0 then do\n    call add_report ' '\n    call add_report 'Elements not in the To branch:' delta_to\n    call add_report '(They may not exist, have been deleted, or renamed)'\n    call add_report ' '\n  end\n  do brdel = 1 to words(brdeletes)\n    deldsn = \"'\"ckothlq\"\"word(brdeletes,brdel)\"'\"\n    call add_report translate(deldsn)\n    Address TSO\n    call outtrap 'brd.'\n    'Delete' deldsn\n    call outtrap 'off'\n    Address ISPExec\n  end\n  drop so. se.\n  if pulldsns /= null then do\n    do copyr = 1 to report.0\n      so.copyr = report.copyr\n    end\n    so.0 = report.0\n    call view_std\n  end\n  Return\n\n/* ---------------------------------------------- *\n | Set Repository as Read Only by creating a file |\n | .zigi/readonly                                 |\n * ---------------------------------------------- */\nSet_Read_Only:\n  x = bpxwunix('touch' localrep'/'zigirep'/.zigi/readonly')\n  cmd = 'cd' localrep'/'zigirep ,\n    \"&& echo '.zigi/readonly' > .gitignore\" ,\n    '&& git add .gitignore'\n  x = docmd(cmd)\n  return 0\n\nCheck_Read_Only:\n  x = bpxwunix('ls -la' localrep'/'zigirep'/.zigi/readonly',,cs.,ce.)\n  if cs.0 > 0 then return 1\n  else return 0\n\n  /* ----------------------------------------------- *\n  | Check if a OMVS file exists (rc = 1 if it does) |\n  * ----------------------------------------------- */\nFile_Exists:\n  parse arg file_check\n  ckotdir = localrep'/'zigirep\n  x = bpxwunix('ls -la' localrep'/'zigirep'/'file_check,,fs.,fe.)\n  if fe.0 = 0 then return 1\n  return 0\n\n  /* -------------------------------------------------------------- *\n  | Process the branch delta from the git diff command to identify |\n  | the files changed.                                             |\n  * -------------------------------------------------------------- */\nBrDelta:\n  Select\n    When change_flag = 'M' then BrType = 'A'\n    When change_flag = 'A' then BrType = 'A'\n    When change_flag = 'D' then\n    if file_exists(change_file) = 1 then do\n      if pos('/',change_file) > 0\n      then do\n        parse value change_file with change_file'/'brdmem\n        if pos('.',brdmem) > 0 then\n        parse value brdmem with brdmem'.'.\n        change_file = change_file\"(\"brdmem\")\"\n      end\n      brdeletes = brdeletes change_file\n      BrType = 'D'\n    end\n    When change_flag = 'R' then do\n      parse value change_file with brdelfile change_file\n      if pos('/',brdelFile) > 0\n      then do\n        parse value brdelFile with brdelFile'/'brdmem\n        if pos('.',brdmem) > 0 then\n        parse value brdmem with brdmem'.'.\n        brdelFile = brdelFile\"(\"brdmem\")\"\n      end\n      brdeletes = brdeletes brdelFile\n      BrType = 'A'\n    end\n    Otherwise nop\n  end\n  if BrType = 'D' then return\n  if pos('/',change_file) = 0 then do\n    if dsnvalid(change_file) = 'NO' then return\n    brdsns = brdsns change_file\n    call add_report \"'\"ckothlq\"\"change_file\"'\"\n  end\n  else do\n    parse value change_file with change_file'/'BrMem\n    if wordpos(change_file,brdsns) = 0 then\n    brdsns = brdsns change_file\n    if pos('.',brmem) > 0 then\n    parse value brmem with brmem'.'.\n    brmems.change_file = brmems.change_file BrMem\n    call add_report \"'\"ckothlq\"\"change_file'('translate(brmem)')'\"'\"\n  end\n  return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZIGICHG": {"ttr": 21, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02B\\x00\\x01 \\x07\\x1f\\x01 \\x12\\x1f\\x05$\\x000\\x00/\\x00\\x00\\xe9\\xc9\\xc7\\xc9\\xf2\\xf8@@@@'", "ispf": {"version": "01.02", "flags": 66, "createdate": "2020-03-11T00:00:00", "modifydate": "2020-04-30T05:24:00", "lines": 48, "newlines": 47, "modlines": 0, "user": "ZIGI28"}, "text": "  /* --------------------  rexx procedure  -------------------- *\n  | Name:      zigichg                                         |\n  |                                                            |\n  | Function:  Display in ISPF Browse the $CHANGE ISPF Panel   |\n  |            which is a copy of the Release Notes            |\n  |                                                            |\n  | Syntax:    %zigichg                                        |\n  |                                                            |\n  | Dependencies: Requires the ISPF Panel $CHANGES             |\n  |                                                            |\n  | Author:    Lionel B. Dyck                                  |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |            04/30/20 LBD - Change from view to browse       |\n  |            03/07/20 LBD - Creation                         |\n  | ---------------------------------------------------------- |\n  |    ZIGI - the z/OS ISPF Git Interface                      |\n  |    Copyright (C) 2020 - Henri Kuiper and Lionel Dyck       |\n  |                                                            |\n  |    This program is free software: you can redistribute it  |\n  |    and/or modify it under the terms of the GNU General     |\n  |    Public License as published by the Free Software        |\n  |    Foundation, either version 3 of the License, or (at     |\n  |    your option) any later version.                         |\n  |                                                            |\n  |    This program is distributed in the hope that it will be |\n  |    useful, but WITHOUT ANY WARRANTY; without even the      |\n  |    implied warranty of MERCHANTABILITY or FITNESS FOR A    |\n  |    PARTICULAR PURPOSE.  See the GNU General Public License |\n  |    for more details.                                       |\n  |                                                            |\n  |    You should have received a copy of the GNU General      |\n  |    Public License along with this program.  If not, see    |\n  |    <https://www.gnu.org/licenses/>.                        |\n  * ---------------------------------------------------------- */\n\n  address ISPExec\n  'QLIBDEF ISPPLIB ID('id')'\n  if rc > 0 then do\n    zerrsm = 'Failure.'\n    zerrlm = 'Unable to execute this command as the ZIGI ISPPLIB' ,\n      'dataset is not allocated using LIBDEF.'\n    'setmsg msg(isrz003)'\n    exit 4\n  end\n  id = strip(id,'B',\"'\")\n  id = \"'\"id\"($CHANGES)'\"\n  'Browse Dataset('id')'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZIGICKOT": {"ttr": 307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00G\\x01 \\x02O\\x01 \"\\x1f\\x05I\\x03\"\\x01\\xd6\\x00\\x00\\xe9\\xc9\\xc7\\xc9\\xf3\\xf0\\xf1@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2020-01-24T00:00:00", "modifydate": "2020-08-08T05:49:47", "lines": 802, "newlines": 470, "modlines": 0, "user": "ZIGI301"}, "text": "  /* --------------------  rexx procedure  -------------------- *\n  | Name:      zigickot                                        |\n  |                                                            |\n  | Function:  ZIGI Checkout                                   |\n  |                                                            |\n  | Syntax:    %zigickot                                       |\n  |                                                            |\n  | Usage Notes:                                               |\n  |            1. ISPF Variables will pass the                 |\n  |               - default HLQ to be used                     |\n  |            2. The OMVS Directory where the project is      |\n  |            3. Sequential files that have no lowercase      |\n  |               will be processed.                           |\n  |            4. Enq checking will be performed and if fail   |\n  |               ispf variable badckot = 1                    |\n  |                                                            |\n  | Author:    Lionel B. Dyck                                  |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |            08/08/20 LBD - Allow null ckothlq               |\n  |                         - Generalize get_binfiles          |\n  |            08/07/20 LBD - Add pfshow off/reset all pops    |\n  |            07/29/20 LBD - Add _EDC_ZERO_RECLEN=Y to env.   |\n  |            07/16/20 LBD - Correct test for Load Mod msg    |\n  |            07/08/20 LBD - Corrections for binary copy      |\n  |                           that broke with single cp        |\n  |            07/07/20 LBD - Check ENQ's before Alloc/cp      |\n  |            06/28/20 LBD - Fix Aopt for indiv member cp     |\n  |            06/24/20 LBD - Fix LMOD selective copy          |\n  |            06/20/20 LBD - Fix copy counter                 |\n  |            06/19/20 LBD - If a PDS is not Text and Binary  |\n  |                           (mixed) then do a single cp      |\n  |            06/13/20 LBD - Cleanup Allocation Test for PDS  |\n  |            06/12/20 LBD - Remove ckotqual (not used)       |\n  |            06/10/20 LBD - Add OMVS Environment Variables   |\n  |            06/08/20 LBD - Add Parse to arg for is_binfile  |\n  |                         - Add Procedure to is_binfile      |\n  |            06/07/20 LBD - usssafe omvs directory on cd     |\n  |            06/04/20 LBD - Remove obsolete code (git)       |\n  |            05/14/20 LBD - Remove (k) from space calc       |\n  |                         - Fix omvs files starting with #   |\n  |                         - Add progress info on copy        |\n  |            05/10/20 LBD - Bug fix in strreplace (null)     |\n  |            05/08/20 LBD - Support for Load Libraries       |\n  |                           Change OGET to cp                |\n  |            03/27/20 LBD - Remove defined extensions an U/C |\n  |            03/24/20 LBD - Replace alloc/execio/free with   |\n  |                           cat for .zigi/dsn                |\n  |            03/11/20 LBD - Check for .zigi before reading   |\n  |                           .zigi/dsn                        |\n  |            02/23/20 LBD - Make numbers pretty              |\n  |            01/24/20 HKB - Really fix it :)                 |\n  |            01/23/20 LBD - Fix if user is NOPREFIX          |\n  |            01/19/20 LBD - Use ckotqual (required)          |\n  |                           * for snapshot                   |\n  |            01/18/20 LBD - Convert from individual OGETs    |\n  |                           to one OGETX for a PDS if no     |\n  |                           selective restores               |\n  |            01/14/20 LBD - Incorporate Binary Support       |\n  |                         - Correct selective refresh bug    |\n  |            01/08/20 LBD - Pass updated mems to zigistat    |\n  |                         - Honor mgen config setting for    |\n  |                           PDSE member gen allocation       |\n  |            01/05/20 LBD - vErase passed variable           |\n  |            01/02/20 LBD - Support selective refresh        |\n  |                           with ispf var pulldsns           |\n  |            12/09/19 LBD - Support (ignore) omvs files and  |\n  |                           subdirectories                   |\n  |            11/16/19 LBD - Change to use ZIGISTAT routine   |\n  |            10/30/19 LBD - Get DCB info from /.zigi/dsn     |\n  |            10/28/19 LBD - Support sequential files         |\n  |            06/12/19 LBD - Correct to handle a git direcory |\n  |            06/11/19 LBD - Add popup status                 |\n  |            06/10/19 LBD - Creation                         |\n  | ---------------------------------------------------------- |\n  |    zigi - the z/OS ISPF Git Interface                      |\n  |    Copyright (C) 2020 - Henri Kuiper and Lionel Dyck       |\n  |                                                            |\n  |    This program is free software: you can redistribute it  |\n  |    and/or modify it under the terms of the GNU General     |\n  |    Public License as published by the Free Software        |\n  |    Foundation, either version 3 of the License, or (at     |\n  |    your option) any later version.                         |\n  |                                                            |\n  |    This program is distributed in the hope that it will be |\n  |    useful, but WITHOUT ANY WARRANTY; without even the      |\n  |    implied warranty of MERCHANTABILITY or FITNESS FOR A    |\n  |    PARTICULAR PURPOSE.  See the GNU General Public License |\n  |    for more details.                                       |\n  |                                                            |\n  |    You should have received a copy of the GNU General      |\n  |    Public License along with this program.  If not, see    |\n  |    <https://www.gnu.org/licenses/>.                        |\n  * ---------------------------------------------------------- */\n\n  /* -------------------------------------------- *\n  | Get the ISPF Variables with our instructions |\n  * -------------------------------------------- */\n  Address ISPExec\n  'vget (ckothlq ckotdir pulldsns mgenl)'\n  if datatype(mgen) /= 'NUM' then mgen = 0\n\n  Address TSO\n\n  /* ------------------------------------- *\n  | Define bpxwunix Environment Variables |\n  * ------------------------------------- */\n  env.1 = '_BPX_SHAREAS=YES'\n  env.2 = '_BPX_SPAWN_SCRIPT=YES'\n  env.3 = '_EDC_ZERO_RECLEN=Y'\n  env.0 = 3\n\n  /* -------------------------------------------------------- *\n  | Issue the ls command to get file names and sizes for all |\n  | files in the current directory and sub-directories.      |\n  * -------------------------------------------------------- */\n  cmd = 'ls -laRk' ckotdir\n  rc = bpxwunix(cmd,,stdout.,stderr.,env.)\n\n  /* ---------------------------------------------- *\n  | Display any error messages and if so then exit |\n  * ---------------------------------------------- */\n  if stderr.0 > 0 then do\n    do i = 1 to stderr.0\n      say stderr.i\n    end\n    exit 8\n  end\n\n  /* ------------------------- *\n  | Define our work variables |\n  * ------------------------- */\n  parse value '' with subs files null pullmems.\n  hit = 0\n\n  /* ------------------------------------------------------- *\n  | Get a list of all z/OS datasets and then check to       |\n  | determine if any are allocated.  If so then return bad. |\n  * ------------------------------------------------------- */\n  all_dsns = null\n  pulldsns = strip(pulldsns)\n  do i = 3 to stdout.0\n    if strip(stdout.i) = null then leave\n    if words(stdout.i) < 9 then iterate\n    if left(word(stdout.i,9),1) = '.' then iterate\n    file = word(stdout.i,9)\n    fx = translate(file,'??????????????????????????', ,\n      'abcdefghijklmnopqrstuvwxyz')\n    if pos('?',fx) > 0 then iterate\n    if pulldsns = null then\n    all_dsns = all_dsns file\n    if wordpos(file,pulldsns) > 0 then\n    all_dsns = all_dsns file\n  end\n  Address ISPexec\n  x = check_enqs(ckothlq all_dsns)\n  if x > 0 then do\n    badckot = 1\n    Address ISPExec ,\n      'vput (badckot) shared'\n    return 1\n  end\n  Address TSO\n\n  /* ------------------------------------ *\n  | Read in ../.zigi/dsn to get dcb info |\n  * ------------------------------------ */\n  cmd = 'cd' ckotdir '&& ls -la .zigi'\n  x = bpxwunix(cmd,,co.,ce.,env.)\n  if x > 0 then do\n    def_recfm = 'FB'\n    def_lrecl = 80\n    def_blksize = 32720\n    def. = null\n  end\n  else do\n    call outtrap 'x.'\n    ckdd = 'ck'time('s')\n    if sysvar('syspref') = null then pref = sysvar('sysuid')\n    else pref = sysvar('syspref')\n    x = bpxwunix(\"cat '\"ckotdir\"/.zigi/dsn'\",,ck.,,env.)\n    def. = null\n    zdsn. = null\n    call outtrap 'off'\n    do i = 1 to ck.0\n      if left(ck.i,1) = '#' then iterate\n      if word(ck.i,1) = '*' then do\n        parse value ck.i with . def_dsorg def_recfm def_lrecl def_blksize .\n      end\n      else do\n        dsn = word(ck.i,1)          /* dataset name less hlq */\n        def.dsn = subword(ck.i,2)   /* dataset dsorg  */\n        zdsn.dsn = word(ck.i,6)     /* file extension */\n      end\n    end\n  end\n\n  /* ------------------------------- *\n  | Get the list of Binary Datasets |\n  * ------------------------------- */\n  Address ISPExec 'vget (gitenv) profile'\n  call get_binfiles\n\n  /* ---------------------------------------------------- *\n  | Process the results of the ls command to:            |\n  | 1. collect number of members per sub-directory       |\n  | 2. collect bytes count (in k) for each sub-directory |\n  | 3. collect info on sequential files                  |\n  * ---------------------------------------------------- */\n  if stdout.0 > 0 then\n  do i = 1 to stdout.0\n    select\n      when pos(ckotdir,stdout.i) > 0 then do\n        parse value stdout.i with (ckotdir)sub':'\n        if left(sub,1) = '/' then sub = substr(sub,2)\n        if strip(sub) /= '' then do\n          size.sub = 0\n          dir.sub = 0\n          si = 0\n          if left(sub,1) /= '.' then do\n            if pulldsns = null then subs = subs sub\n            else if wordpos(sub,pulldsns) > 0 then do\n              subs = subs sub\n              wp = wordpos(sub,pulldsns)\n              Address ISPExec 'vget (zv'wp')'\n              interpret 'mems = zv'wp\n              si = si + 1\n              if zdsn.sub /= null then do\n                ext = '.'zdsn.sub\n                if pos(ext,mems) > 0 then do is = 1 to words(mems)\n                  parse value word(mems,is) with m'.'.\n                  mems = m delword(mems,is,1)\n                end\n                mems = translate(mems)\n              end\n              pullmems.sub = mems\n              Address ISPExec 'verase zv'wp\n            end\n          end\n        end\n      end\n      when word(stdout.i,1) = 'total' then do\n        hit = hit + 1\n      end\n      when hit > 1 & left(stdout.i,1) = '-' then\n      if strip(sub) /= '' then do\n        size.sub = size.sub + word(stdout.i,5)\n        dir.sub = dir.sub + 1\n      end\n      when hit = 1 & left(stdout.i,1) = '-' then do\n        file = word(stdout.i,9)\n        if left(file,1) = '.' then iterate\n        fx = translate(file,'??????????????????????????', ,\n          'abcdefghijklmnopqrstuvwxyz')\n        if pos('?',fx) > 0 then iterate\n        if pulldsns = null then do\n          size.file =  word(stdout.i,5)\n          files = files file\n        end\n        if wordpos(file,pulldsns) > 0 then do\n          size.file =  word(stdout.i,5)\n          files = files file\n        end\n      end\n      otherwise nop\n    end\n  end\n\n  /* -------------------------------------------- *\n  | Process the individual files, if any         |\n  | Allocation and Copy                          |\n  * -------------------------------------------- */\n  do i = 1 to words(files)\n    parse value '' with zs1 zs2 zs3 zs4 zs5 zs6 zs7 zs8 zs9\n    zs10 = 'Patience while the data is copied from OMVS' ,\n      'to the z/OS Dataset.'\n    sub = word(files,i)\n    fileg = \"'\"ckothlq\"\"sub\"'\"\n    odir = \"'\"ckotdir\"/\"sub\"'\"\n    zs1 = 'Processing file:' sub\n    zs2 = 'From:           ' odir\n    zs3 = 'To:             ' fileg\n    bin = is_binfile(sub)\n    if bin = 1 then type = 'Binary'\n    else type = 'Text'\n    zs7 = 'Type            ' type\n    call pop_status\n    call outtrap 'x.'\n    if sysdsn(fileg) = 'OK' then\n    'delete' fileg\n    tracks =  (size.sub%50000 + 1) * 2\n    call get_dcb\n    'alloc ds('fileg') new spa('tracks','tracks') tr dsorg(ps)' ,\n      'recfm('recfm') lrecl('lrecl') blksize('blksize')'\n    'free ds('fileg')'\n    call outtrap 'x.'\n    'oget' odir fileg type\n    call outtrap 'off'\n  end\n\n  /* -------------------------------------------- *\n  | Process the sub-directories and initiate the |\n  | Allocation and Copy                          |\n  | Ignore subdirectories                        |\n  * -------------------------------------------- */\n  do i = 1 to words(subs)\n    parse value '' with zs1 zs2 zs3 zs4 zs5 zs6 zs7 zs8 zs9\n    zs10 = 'Patience while the data is copied from OMVS' ,\n      'to the z/OS PDS.'\n    sub = word(subs,i)\n    bin = is_binfile(sub)\n    if bin = 1 then type = 'Binary'\n    else type = 'Text'\n    zs7 = 'Type:                   ' type\n    fx = translate(sub,'??????????????????????????', ,\n      'abcdefghijklmnopqrstuvwxyz')\n    if pos('?',fx) > 0 then iterate\n    if pullmems.sub /= null then dir.sub = words(pullmems.sub)\n    zs1 = 'Populating from:        ' ckotdir\n    zs2 = 'Processing subdirectory:' sub\n    zs3 = 'Members:                ' fix_num(dir.sub)\n    zs4 = 'Total bytes:            ' fix_num(size.sub)\n    tracks =  (size.sub%50000 + 1) * 2\n    zs5 = 'Tracks allocated:       ' fix_num(tracks)\n    call pop_status\n    call alloc_copy_pds\n    if recfm /= 'U' then\n    call add_stats\n  end\n\n  Exit\n\n  /* ----------------------------------------------------- */\n  /* number format code thanks to Doug Nadel               */\n  /* ----------------------------------------------------- */\nfix_num: procedure\n  arg bytes\n  str=strip(translate('0,123,456,789,abc,def', ,\n    right(bytes,16,','), ,\n    '0123456789abcdef'),'L',',')\n  bytes = strip(str)\n  return bytes\n\n  /* ----------------------------------------------------------------- *\n  | Allocate the PDS and perform the copy using cp                    |\n  | - if the target PDS exists as a PDS, delete and realloc as a PDSE |\n  | - if the target is a PDSE then it will NOT be reallocated         |\n  | - The target PDS will be allocated as a PDSE version 2.           |\n  | - if maxgen (mgen) is provided then member generations will       |\n  |   also be defined at allocation                                   |\n  | - Uppercase and remove defined extension for members              |\n  * ----------------------------------------------------------------- */\nAlloc_Copy_PDS:\n  pds = \"'\"ckothlq\"\"sub\"'\"\n  odir = \"'\"ckotdir\"/\"sub\"/'\"\n  zs8 = ''\n  deleted = 0\n  dsnstat = sysdsn(pds)\n  if pullmems.sub = null then\n  if dsnstat = 'OK' then do\n    zs8 = 'Re-Allocating'\n    call outtrap 'x.'\n    'delete' pds\n    deleted = 1\n    call outtrap 'off'\n  end\n  else  zs8 = 'Allocating New'\n  zs6 = 'Allocating PDSE:        ' pds\n  call pop_status\n  if dsnstat /= 'OK' then deleted = 1\n  if deleted = 1 then do\n    call get_dcb\n    if recfm = 'U' then do\n      type = 'Load module'\n      zs7 = 'Type:                   ' type\n    end\n    if mgen > 0 then gens = 'maxgens('mgen')'\n    else gens = null\n    'Alloc new spa('tracks','tracks') recfm('recfm') lrecl('lrecl')' ,\n      'Blksize('blksize') Dsntype(Library,2) dsorg(po) dir(1)' ,\n      'dsn('pds')' gens\n    'Free ds('pds')'\n  end\n  call pop_status\n  /* ---------------------------------------------------- *\n  | Read directory to get all member file names and then |\n  | adjust according and then do individual cp           |\n  * ---------------------------------------------------- */\n  x = listdsi(pds)\n  recfm = sysrecfm\n  target = strip(pds,'B',\"'\")\n  call syscalls 'ON'\n  address syscall\n  rdir = strip(odir,'B',\"'\")\n  rdir = strip(rdir,'T','/')\n  'readdir' rdir 'mems.'\n  address ispexec\n  call outtrap 'x.'\n  mcount = 0\n  if pullmems.sub = null\n  then tcount = mems.0 - 2\n  else tcount = words(pullmems.sub)\n  if pullmems.sub = null & check_mixed_bintext(sub) = 0 then do\n    if is_binfile(sub) = 1 then do\n      binopt = '-B'\n      type = 'Binary'\n    end\n    else do\n      binopt = null\n      type = 'Text'\n    end\n    if recfm = 'U' then do\n      binopt = '-X -I'\n      type = 'Load Module'\n    end\n    zs9 = 'Copying' tcount 'members.'\n    call pop_status\n    cmd = 'cp -A -v' binopt rdir'/*' '\"//'pds'\"'\n    x = docmd(cmd)\n    if x > 0 then call view_std 'B'\n  end\n  else do\n    do ii = 1 to mems.0\n      if left(mems.ii,1) = \".\" then iterate\n      m = mems.ii    /* ignore the translation */\n      aopt = null\n      if zdsn.sub /= null then\n      if right(m,length(zdsn.sub)) = zdsn.sub then do\n        parse value m with m'.'.\n        m = translate(m)\n        aopt = '-A'\n      end\n      if pullmems.sub /= null then\n      if wordpos(m,pullmems.sub) = 0 then iterate\n      src = rdir'/'mems.ii\n      bin = is_binfile(sub'/'mems.ii)\n      if bin = 1 then binopt = '-B'\n      else binopt = null\n      if recfm = 'U' then binopt = '-X -I'\n      Select\n        when pos('-B',binopt) > 0 then type = 'Binary'\n        when pos('-X',binopt) > 0 then type = 'Load Module'\n        otherwise type = 'Text'\n      end\n      zs7 = 'Type:                   ' type\n      src = usssafe(mems.ii)\n      if left(src,1) = '#' then src = '\\'src\n      zos = usssafe(\"//'\"target\"(\"m\")'\")\n      mcount = mcount + 1\n      zs9 = left('Copying' mcount 'of' tcount,24) 'Member:' m\n      call pop_status\n      cmd = 'cd' usssafe(rdir)\n      cmd = cmd '&& cp -v' aopt binopt src '\"'zos'\"'\n      x = docmd(cmd)\n      if x > 0 then call view_std 'B'\n      Address ISPexec\n      zs9 = null\n    end\n  end\n  call syscalls 'OFF'\n  call outtrap 'off'\n  return\n\nget_dcb:\n  if def.sub /= null then do\n    parse value def.sub with dsorg recfm lrecl blksize .\n    recfm = left(recfm,1) substr(recfm,2,1) substr(recfm,3,1)\n  end\n  else do\n    recfm = left(def_recfm,1) substr(def_recfm,2,1) substr(def_recfm,3,1)\n    lrecl = def_lrecl\n    blksize = def_blksize\n  end\n  return\n\nusssafe: procedure\n  parse arg dsn\n  if pos('$',dsn) = 0 then return dsn\n  /* Let's not usssafe it twice :) */\n  if pos('\\$',dsn) > 0 then return dsn\n  dsn = strreplace(dsn, '$', '\\$')\n  return dsn\n\n  /* ------------ *\n  | PopUp Status |\n  * ------------ */\nPop_Status:\n  Address ISPExec\n  call pfshow 'off'\n  'Control Display Lock'\n  'Addpop row(3) column(2)'\n  'Display Panel(zigipopc)'\n  'Rempop'\n  call pfshow 'reset'\n  Address TSO\n  return\n\n  /* ---------------------------------- *\n  | Add ISPF Statistics to all Members |\n  | - set the initial userid to ZIGI   |\n  * ---------------------------------- */\nAdd_Stats:\n  zs8 = 'Adding/Updating ISPF Statistics'\n  call pop_status\n  filepath = ckotdir'/.zigi/'sub\n  statmems = pullmems.sub\n  Address ISPExec 'vput (statmems)'\n  '%zigistat' pds filepath 'U'\n  return\n\n  /* ------------------------------------------------------ *\n  | The pfshow routine will:                               |\n  | 1. check to see the passed option                      |\n  | 2. if Off then it will save the current pfshow setting |\n  |    - save the current setting                          |\n  |    - turn off pfshow                                   |\n  | 3. if the option is Reset then it will                 |\n  |    - test if pfshow was on and turn it back on         |\n  * ------------------------------------------------------ */\npfshow:\n  arg pfkopt\n  if pfkopt = 'RESET' then do\n    if pfkeys = 'ON' then\n    'select pgm(ispopf) parm(FKA,ON)'\n  end\n  if pfkopt = 'OFF' then do\n    'vget (zpfshow)'\n    pfkeys = zpfshow\n    if pfkeys /= 'OFF' then\n    'select pgm(ispopf) parm(FKA,OFF)'\n  end\n  return\n\nstrreplace: Procedure\n  string  = arg(1)\n  strfrom = arg(2)\n  strto   = arg(3)\n  null = ''\n  if pos(strfrom,string) = 0 then return string\n  newString = null\n  do i = 1 to length(string)\n    if substr(string,i,1) /= strfrom\n    then newstring = newstring''substr(string,i,1)\n    else  newstring = newstring''strto\n  end\n  return newstring\n\nget_binfiles:\n  /* ---------------------------------------------------------\\\n  | Name:      binfiles                                        |\n  |                                                            |\n  | Function:  Fills the global binfiles. stem with all        |\n  |            current repo files that are added as binary.    |\n  \\---------------------------------------------------------- */\n  cmd = 'cd' ckotdir'/ &&'\n  cmd = 'cat -W filecodeset=UTF-8,pgmcodeset=IBM-1047' ckotdir'/.gitattributes'\n  cmd = cmd ' | grep BINARY'\n  cmd = cmd '| cut -d\" \" -f1'\n  x = docmd(cmd)\n  if so.0 = 0 then do\n    binfiles.0 = 0\n    return 0\n  end\n  do b = 1 to so.0\n    binfiles.b = so.b\n  end\n  binfiles.0 = so.0\n  return 0\n\nis_binfile: procedure expose binfiles.\n  /* ---------------------------------------------------------\\\n  | Name:      is_binfile                                      |\n  |                                                            |\n  | Function:  Checks the global binfiles. stem for the        |\n  |            provided dataset or dataset/member              |\n  \\---------------------------------------------------------- */\n  parse arg file\n  if datatype(binfiles.0) /= 'NUM' then return 0\n  do bi = 1 to binfiles.0\n    if right(binfiles.bi,1) = '*' then do\n      parse value file with test'/'.\n      if left(binfiles.bi,length(binfiles.bi)-2) = test\n      then return 1\n    end\n    if binfiles.bi = file then return 1\n  end\n  return 0\n\ndocmd:\n  parse arg cmd\n  drop so. se.\n  x = bpxwunix(cmd,,so.,se.,env.)\n  return x\n\n  /* ---------------------------------------------------------- *\n  | Generalized routine to view stdout. (so.) or stderr. (se.) |\n  | based on the parm passed                                   |\n  * ---------------------------------------------------------- */\nview_std:\n  arg stdopt viewopt\n  if stdopt = null then viewopt = 'B'\n  if viewopt = null then viewopt = 'B'\n  if stdopt = 'X' then stdopt = null\n  if datatype(so.0) /= 'NUM' then so.0 = 0\n  if datatype(se.0) /= 'NUM' then se.0 = 0\n  if viewopt = 'B' then if so.0 + se.0 = 0 then return\n  /* ------------------------------- *\n  | Randomly define a DDName to use |\n  * ------------------------------- */\n  dd = 'zd'random(9999)\n  /* --------------------------------------- *\n  | Get lrecl to determine dcb for temp d/s |\n  * --------------------------------------- */\n  if stdopt /= 'C' then do\n    vlrecl = 0\n    do li  = 1 to so.0\n      so.li = strip(so.li,'T')\n      if length(so.li) > vlrecl then vlrecl = length(so.li)\n      if so.li = null then so.li = ' '\n    end\n    do li  = 1 to se.0\n      se.li = strip(se.li,'T')\n      if length(se.li) > vlrecl then vlrecl = length(se.li)\n      if se.li = null then se.li = ' '\n    end\n    sec = so.0 + se.0\n  end\n  else do\n    do li = 1 to combine.0\n      if length(combine.li) > vlrecl then vlrecl = length(combine.li)\n    end\n    sec = combine.0\n  end\n  if vlrecl < 81 then vlrecl = 80\n  /* ------------------------------------------ *\n  | Allocate a temporary data set for our data |\n  * ------------------------------------------ */\n  Address TSO\n  /* calculate space needed with avg 50 bytes per record */\n  prim = (((so.0 + se.0) * 50) % 56000) + 1\n  if prim < 2 then prim = 5\n  if viewopt = 'V' then do\n    if sysvar('syspref') = null then pref = userid()'.'\n    else pref = null\n    vdsn = pref'work.zigi.gitdata'\n  end\n  else vdsn = null\n  x = listdsi(vdsn)\n  if x = 0 then do\n    call outtrap 'x.'\n    'delete' vdsn\n    call outtrap 'off'\n  end\n  if vdsn /= null then vdsnp = 'da('vdsn') unit(3390)'\n  else vdsnp = null\n  if vlrecl > 255 then vlrecl = 251\n  'Alloc f('dd') new spa('prim','prim') tr' ,\n    'recfm(v b) lrecl('vlrecl+4') blksize(0)' vdsnp\n  /* ----------------------------- *\n  | If stdopt is 'B' then do both |\n  * ----------------------------- */\n  if stdopt /= 'C' then do\n    stdopt = null\n    sc = so.0\n    do xi = 1 to se.0\n      sc = sc + 1\n      so.sc = se.xi\n    end\n    so.0 = sc\n  end\n  /* ----------------------- *\n  | Write out the stem data |\n  * ----------------------- */\n  if stdopt = 'C' then do\n    'Execio * diskw' dd '(finis stem combine.'\n    drop combine.\n    combine.0 = 0\n  end\n  if stdopt /= 'C' then do\n    if stdopt = null\n    then do\n      'Execio * diskw' dd '(finis stem so.'\n    end\n    else do\n      'Execio * diskw' dd '(finis stem se.'\n    end\n  end\n  /* -------------------------------------------------- *\n  | Access the Temporary Data Set using ISPF           |\n  | Library Services.                                  |\n  | Then using ISPF Browse service to browse the data. |\n  | And use Library Services to Free the Data Set.     |\n  * -------------------------------------------------- */\n  Address ISPExec\n  if sec > 0 then if viewopt = 'B' then do\n    'lminit dataid(ddb) ddname('dd')'\n    'browse dataid('ddb') panel(zigibrow)'\n    'lmfree dataid('ddb')'\n  end\n  else do\n    vmac = 'Panel(zigiedit) macro(zigivmac)'\n    'view dataset('vdsn')' vmac\n    vtitle = null\n    'verase vtitle'\n  end\n  /* ----------------------------- *\n  | Last Free the z/OS Allocation |\n  * ----------------------------- */\n  call outtrap 'x.'\n  Address TSO ,\n    'Free f('dd')'\n  if vdsn /= null then\n  Address TSO 'Delete' vdsn\n  call outtrap 'off'\n  return\n\n  /* ---------------------------------------- *\n  | Check if a PDS has mixed binary and text |\n  * ---------------------------------------- */\nCheck_Mixed_BinText:\n  parse arg checkForBinFile\n  cmbtRC = 0\n  if datatype(binfiles.0) /= 'NUM' then return 0\n  do bi = 1 to binfiles.0\n    parse value binfiles.bi with cmbtfile'/'cmbtmbr\n    parse value checkForBinFile with checkFile'/'checkmbr\n    if cmbtfile = checkFile then\n    if cmbtmbr = '*' then cmbtRC = 0\n    else return 1\n    if binfiles.bi = checkForBinFile then return 1\n  end\n  return cmbtRC\n\n  /* --------------------------------------------------------- *\n  | Determine is any of the datasets to be updated by pull    |\n  | have any outstanding enq's (they are allocated somewhere) |\n  |                                                           |\n  | If so inform the user and prompt them to release the      |\n  | allocation and retry                                      |\n  |                                                           |\n  | Or abort the pull (not sure how to do that yet)           |\n  * --------------------------------------------------------- */\nCheck_ENQS: Procedure\n  arg pdshlq pulldsns\n  enq_clean = 1\n  /* do until no more enq's or an abort request */\n  do until enq_clean = 0\n    major = '*'\n    minor = pdshlq\n    save = 'Z'random(99999)\n    if right(minor,1) /= '*' then minor = minor'*'\n    \"QueryENQ Qname(major) Rname(minor) XSYS Table(\"save\")\"\n    qrc = rc\n    if qrc > 7 then return 0\n    if qrc < 8 then do\n      'tbquery' save 'rownum(cer)'\n      if cer = 0 then do\n        'tbend' save\n        return 0\n      end\n      else enq_clean = 1\n      if qualignr > 0 then do\n        prefix = translate(pdshlq,' ','.')\n        prefix = subword(prefix,1,qualignr)\n        prefix = translate(prefix,'.',' ')\n      end\n      else prefix = pdshlq\n     /* --------------------------------------- *\n      | Remove any datasets not being processed |\n      * --------------------------------------- */\n      'tbtop' save\n      do forever\n        'tbskip' save\n        if rc > 0 then leave\n        hit = 1\n        do ice = 1 to words(pulldsns)\n          cw = word(pulldsns,ice)\n          ckdsn = prefix\".\"cw\n          if ckdsn = zenrname then hit = 0\n          if rc > 0 then leave\n        end\n        if hit = 1 then 'tbdelete' save\n      end\n      'tbquery' save 'rownum(cer)'\n      if cer = 0 then do\n        'tbend' save\n        return 0\n      end\n    end\n    call pfshow 'off'           /* make sure pfshow is off */\n    'addpop row(2) column(2)'\n    'tbdispl' save 'panel(zigienqk)'\n    'rempop'\n    call pfshow 'reset'         /* restore pfshow setting */\n    if enqact = 'R' then enq_clean = 1 /* retry */\n    else do\n      'TBEnd' save\n      return 1\n    end\n    'TBEnd' save\n  end\n  return 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZIGICNVT": {"ttr": 309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1b\\x00\\x08\\x01 \\x05\\x8f\\x01 \"\\x1f\\x05P\\x01<\\x00\\xa3\\x00\\x00\\xe9\\xc9\\xc7\\xc9\\xf3\\xf0\\xf1@@@'", "ispf": {"version": "01.27", "flags": 0, "createdate": "2020-02-27T00:00:00", "modifydate": "2020-08-08T05:50:08", "lines": 316, "newlines": 163, "modlines": 0, "user": "ZIGI301"}, "text": "  /* --------------------  rexx procedure  -------------------- *\n  | Name:      zigicnvt                                        |\n  |                                                            |\n  | Function:  ZIGI convert a non-ZIGI repo to ZIGI format     |\n  |                                                            |\n  | Syntax:    %zigicnvt                                       |\n  |                                                            |\n  | Usage Notes:                                               |\n  |            1. ISPF Variables will pass the                 |\n  |               - default HLQ to be used                     |\n  |            2. The OMVS Directory where the project is      |\n  |            3. Sequential files that have no lowercase      |\n  |               will be processed.                           |\n  |            4. Directories that are all upper case and      |\n  |               8 chars or less will be assumed to be        |\n  |               a PDS                                        |\n  |            5. Files ending in .bin will have the .bin      |\n  |               removed and be defined as binary             |\n  |                                                            |\n  | Dependencies: Will call zigickot when done to upload       |\n  |               to z/OS                                      |\n  |                                                            |\n  | Author:    Lionel B. Dyck                                  |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |            08/08/20 LBD - Generalize get_binfiles          |\n  |            03/02/20 LBD - Minor cleanup                    |\n  |            02/27/20 LBD - Creation                         |\n  | ---------------------------------------------------------- |\n  |    ZIGI - the z/OS ISPF Git Interface                      |\n  |    Copyright (C) 2020 - Henri Kuiper and Lionel Dyck       |\n  |                                                            |\n  |    This program is free software: you can redistribute it  |\n  |    and/or modify it under the terms of the GNU General     |\n  |    Public License as published by the Free Software        |\n  |    Foundation, either version 3 of the License, or (at     |\n  |    your option) any later version.                         |\n  |                                                            |\n  |    This program is distributed in the hope that it will be |\n  |    useful, but WITHOUT ANY WARRANTY; without even the      |\n  |    implied warranty of MERCHANTABILITY or FITNESS FOR A    |\n  |    PARTICULAR PURPOSE.  See the GNU General Public License |\n  |    for more details.                                       |\n  |                                                            |\n  |    You should have received a copy of the GNU General      |\n  |    Public License along with this program.  If not, see    |\n  |    <https://www.gnu.org/licenses/>.                        |\n  * ---------------------------------------------------------- */\n\n  address ispexec,\n    'vget (convdir)'\n\n  parse value '' with null fail binfiles.\n\n  if convdir = null then exit 8\n\n  x = syscalls('ON')\n  call readdir convdir\n  /* process the root directory */\n  do i = 1 to d.0\n    fileo = d.i\n    type = s.i.st_type  /* 3 = ps 1 = dir */\n    if left(fileo,1) = '.' then iterate\n    if right(fileo,3) = '.md' then iterate\n    file = translate(fileo)\n    if dsnvalid(file) = 'OK' then call convert\n  end\n\n  x = syscalls('OFF')\n\n  call outtrap 'x.'\n  call make_dsn convdir\n  call outtrap 'off'\n  exit 0\n\nconvert:\n  zs1 = 'Working on conversion'\n  zs2 = 'Patience.'\n  call pop\n  if type = 1 then do\n    dir = convdir'/'fileo\n    zs1 = 'Reading' dir\n    zs2 = 'Patience.'\n    call pop\n    call readsub dir\n    do di = 1 to sd.0\n      stype = ss.di.st_type  /* 3 = ps 1 = dir */\n      if stype = 1 then iterate\n      dfile = sd.di\n      if left(dfile,1) = '.' then iterate\n      parse value dfile with ndfile'.'suf\n      ndfile = translate(ndfile)\n      cmd = 'cd' dir '&& mv' dfile ndfile\n      zs1 = 'Converting:' dfile\n      zs2 = 'To:        ' ndfile\n      call pop\n      x = bpxwunix(cmd,,so.,se.)\n      if x > 0 then do\n        do z = 1 to so.0;say so.z;end\n        do z = 1 to se.0;say se.z;end\n      end\n      if translate(suf) = 'BIN' then do\n        call set_binary\n      end\n    end\n    zs1 = 'Renaming Directory:' fileo\n    zs2 = 'To                :' file\n    call pop\n    cmd = 'cd' convdir '&& mv' fileo file\n    x = bpxwunix(cmd,,so.,se.)\n    if x > 0 then do\n      do z = 1 to so.0;say so.z;end\n      do z = 1 to se.0;say se.z;end\n    end\n  end\n  if type = 3 then do\n    if right(file,4) = '.BIN' then do\n      parse value file with file'.BIN'\n      call set_binary\n    end\n    if file /= fileo then do\n      zs1 = 'Converting:' fileo\n      zs2 = 'To        :' file\n      call pop\n      cmd = 'cd' convdir '&& mv' fileo file\n      x = bpxwunix(cmd,,so.,se.)\n      if x > 0 then do\n        do z = 1 to so.0;say so.z;end\n        do z = 1 to se.0;say se.z;end\n      end\n    end\n  end\n  return\n\n  /* ----------------------- *\n  | Generalized Pop Message |\n  * ----------------------- */\nPop:\n  add = address()             /* save addressing environment */\n  Address ISPExec\n  call do_popup\n  Address add                 /* restore addressing environment */\n  return\n\n  /* ---------------------------------------- *\n  | Common routine for normal (2 line) popup |\n  * ---------------------------------------- */\nDo_Popup:\n  call pfshow 'off'           /* make sure pfshow is off */\n  'Control Display Lock'\n  'Addpop row(4) column(8)'\n  'Display Panel(zigipop)'\n  'Rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  return\n\n  /* ------------------------------------------------------ *\n  | The pfshow routine will:                               |\n  | 1. check to see the passed option                      |\n  | 2. if Off then it will save the current pfshow setting |\n  |    - save the current setting                          |\n  |    - turn off pfshow                                   |\n  | 3. if the option is Reset then it will                 |\n  |    - test if pfshow was on and turn it back on         |\n  * ------------------------------------------------------ */\npfshow:\n  if zpfshow = 'OFF' then return\n  arg pfkopt\n  if pfkopt = 'RESET' then do\n    if pfkeys = 'ON' then\n    'select pgm(ispopf) parm(FKA,ON)'\n  end\n  if pfkopt = 'OFF' then do\n    'vget (zpfshow)'\n    pfkeys = zpfshow\n    if pfkeys /= 'OFF' then\n    'select pgm(ispopf) parm(FKA,OFF)'\n  end\n  return\n\nReadsub:\n  parse arg dir\n  address syscall 'readdir' dir 'sd. ss.'\n  return\n\nReaddir:\n  parse arg dir\n  address syscall 'readdir' dir  'd. s.'\n  return\n\nMake_dsn:\n  parse arg dir\n  x = bpxwunix('cd' dir '&& mkdir .zigi && chmod 755 .zigi')\n  r.1 = \"# ZIGI dsn-file \"\n  r.2 = \"# This file needs to be here.\"\n  r.3 = \"# Don't edit unless you know what you're doing :)\"\n  r.4 = '#  '\n  r.5 = '# record format is (case insensitive):'\n  r.6 = '#  '\n  r.7 = '# Position - description'\n  r.8 = '#  '\n  r.9 = '# 1 - directory name which will be prefixed by the'\n  r.10 = '#     defined HLQ to create the z/OS dataset'\n  r.11 = '#     (* defines the default)'\n  r.12 = '# 2 - PS or PO (dataset organization)'\n  r.13 = '#     PS for a flat file'\n  r.14 = '#     PO for a directory and thus a partitioned dataset'\n  r.15 = '# 3 - record format (FB or VB)'\n  r.16 = '# 4 - lrecl'\n  r.17 = '# 5 - blksize'\n  r.18 = '#     0 is allowed if system determined blksize is enabled'\n  r.19 = '# 6 - file-extension (optional and no-period)'\n  r.20 = '#  '\n  r.21 = '# Default DSORG and DCB info'\n  r.22 = '* PO FB 80 32720'\n  r.0 = 22\n  Address TSO\n  dsn = \"'\"dir\"/.zigi/dsn'\"\n  dd = 'cv'random(9999)\n  if sysvar('syspref') = null\n  then pref = sysvar('sysuid')\n  else pref = sysvar('syspref')\n  'alloc f('dd') new spa(1,1) tr recfm(f b) lrecl(80) blksize(0)' ,\n    \"ds('\"pref'.'dd\"')\"\n  'Execio * diskw' dd '(finis stem r.'\n  'free f('dd')'\n  'oput' \"'\"pref'.'dd\"'\" dsn 'text'\n  'delete' \"'\"pref\".\"dd\"'\"\n  return\n\ndsnvalid: Procedure Expose null\n  /* Tests for a 'potentially valid' z/OS datasetname */\n  parse arg val_dsn\n  if strip(val_dsn) = null then return 'NO'\n  val_dsn = strip(val_dsn,'B',\"'\")\n  upp = TRANSLATE(val_dsn,\".ABCDEFGHIJKLMNOPQRSTUVWXYZ\",,\n    \".abcdefghijklmnopqrstuvwxyz\")\n  tdsn = translate(val_dsn,' ','.')\n  retval = 'OK'   /* asssume good */\n  do i = 1 to words(tdsn)\n    w = word(tdsn,i)\n    if length(w) > 8 then retval = 'NO'\n    if pos(left(w,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ$#@') = 0 then retval = 'NO'\n    w = translate(w,left(' ',39,' '), ,\n      'ABCDEFGHIJKLMNOPQRSTUVWXYZ-$#@0123456789')\n    w = strip(w)\n    if w /= null then retval = 'NO'\n  end\n  if retval /= 'NO' then\n  if upp = val_dsn then do\n    smsg = msg()\n    call msg 'OFF'\n    if sysdsn(val_dsn) = \"OK\" | sysdsn(val_dsn) = \"DATASET NOT FOUND\"\n    then retval = 'OK'\n    else retval = \"NO\"\n    call msg smsg\n  end\n  return retval\n\nSet_Binary:\n  if bin_already(ndfile) = 0 then do\n    binopt = '-B'\n      /* setting the gitattributes file */\n      /* first convert the ASCII atrtib file to ebcdic :( */\n    gabs = 'git-encoding=BINARY zos-working-tree-encoding=BINARY binary'\n    cmd = 'cd' convdir '&& iconv -f ISO8859-1 -t IBM-1047 '\n    cmd = cmd '.gitattributes > .gae'\n      /* then append the binary attrib for this file */\n    if type = 1 then\n    cmd = cmd '&& echo \"'file'/'ndfile' 'gabs'\" >> .gae '\n    if type = 3 then\n    cmd = cmd '&& echo \"'file gabs'\" >> .gae '\n      /* convert it back to ascii */\n    cmd = cmd '&& iconv -f IBM-1047 -t ISO8859-1 .gae '\n    cmd = cmd '> .gitattributes '\n    cmd = cmd '&& rm .gae'\n    x = bpxwunix(cmd,,so.,se.)\n      /* make sure the file is tagged as binary */\n    if type = 1 then\n    tagcmd = 'chtag -bR' convdir'/'fileo'/'ndfile\n    if type = 3 then\n    tagcmd = 'chtag -bR' convdir'/'fileo\n    x = bpxwunix(tagcmd,,so.,se.)\n    call get_binfiles\n  end\n  return\n\nget_binfiles:\n  /* ---------------------------------------------------------\\\n  | Name:      get_binfiles                                    |\n  |                                                            |\n  | Function:  Fills the global binfiles. stem with all        |\n  |            current repo files that are added as binary.    |\n  \\---------------------------------------------------------- */\n  cmd = 'cd 'localrep'/'zigirep' &&'\n  cmd = cmd 'cat .gitattributes | grep BINARY'\n  cmd = cmd '| cut -d\" \" -f1'\n  x = bpxwunix(cmd,,so.,se.)\n  binfiles. = null\n  do b = 1 to so.0\n    binfiles.b = so.b\n  end\n  binfiles.0 = so.0\n  return 0\n\nbin_already: Procedure expose binfiles.\n  arg file\n  if datatype(binfiles.0) /= 'NUM' then call get_binfiles\n  do b = 1 to binfiles.0\n    if file = binfiles.b then return 1\n    if pos('/',binfiles.b) = 0\n    then test = binfiles.b\n    else parse value binfiles.b with test'/'.\n    if file = test then return 1\n  end\n  return 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZIGIEM": {"ttr": 27, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01B\\x00\\x01 \\x07\\x1f\\x01 \\x11\\x8f\\x06 \\x008\\x008\\x00\\x00\\xe9\\xc9\\xc7\\xc9\\xf2\\xf8@@@@'", "ispf": {"version": "01.01", "flags": 66, "createdate": "2020-03-11T00:00:00", "modifydate": "2020-04-27T06:20:00", "lines": 56, "newlines": 56, "modlines": 0, "user": "ZIGI28"}, "text": "/*---------------------  rexx procedure  -------------------- *\n | Name:      ZIGIEM                                          |\n |                                                            |\n | Function:  ISPF Edit Macro used by the ZIGI application    |\n |            to confirm that all the merge conflict records  |\n |            have been removed.                              |\n |                                                            |\n |            Enables Recovery and turns Pack Off             |\n |                                                            |\n | Author:    Lionel B. Dyck                                  |\n |                                                            |\n | History:  (most recent on top)                             |\n |            01/08/20 LBD - Add msgline comments             |\n |            12/18/19 LBD - turn off hilite                  |\n |            12/13/19 LBD - creation                         |\n |                                                            |\n | ---------------------------------------------------------- |\n |    ZIGI - the z/OS ISPF Git Interface                      |\n |    Copyright (C) 2020 - Henri Kuiper and Lionel Dyck       |\n |                                                            |\n |    This program is free software: you can redistribute it  |\n |    and/or modify it under the terms of the GNU General     |\n |    Public License as published by the Free Software        |\n |    Foundation, either version 3 of the License, or (at     |\n |    your option) any later version.                         |\n |                                                            |\n |    This program is distributed in the hope that it will be |\n |    useful, but WITHOUT ANY WARRANTY; without even the      |\n |    implied warranty of MERCHANTABILITY or FITNESS FOR A    |\n |    PARTICULAR PURPOSE.  See the GNU General Public License |\n |    for more details.                                       |\n |                                                            |\n |    You should have received a copy of the GNU General      |\n |    Public License along with this program.  If not, see    |\n |    <https://www.gnu.org/licenses/>.                        |\n * ---------------------------------------------------------- */\n Address ISREdit\n 'Macro (options)'\n\n  \"RECOVERY ON\"\n  \"PACK OFF\"\n  'Hilite Off'\n  \"DEFINE ZIGIEME MACRO CMD\"\n  \"DEFINE ZIGIEMS MACRO CMD\"\n  \"DEFINE SAVE ALIAS ZIGIEMS\"\n  \"DEFINE END  ALIAS ZIGIEME\"\n\n  text = 'Remove the records that you do not want in the merge results'\n  'line_before 1 = msgline (text)'\n  text = 'or use the Cancel command to terminate the merge.'\n  'line_before 1 = msgline (text)'\n  text = 'Records from <<<<<< to ====== are from the current branch'\n  'line_before 1 = msgline (text)'\n  text = 'Records from ====== to >>>>>> are from the merge branch'\n  'line_before 1 = msgline (text)'\n  Exit 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZIGIEME": {"ttr": 29, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01B\\x00\\x01 \\x07\\x1f\\x01 \\x11\\x8f\\x06 \\x00W\\x00W\\x00\\x00\\xe9\\xc9\\xc7\\xc9\\xf2\\xf8@@@@'", "ispf": {"version": "01.01", "flags": 66, "createdate": "2020-03-11T00:00:00", "modifydate": "2020-04-27T06:20:00", "lines": 87, "newlines": 87, "modlines": 0, "user": "ZIGI28"}, "text": " /*---------------------  rexx procedure  -------------------- *\n  | Name:      ZIGIEME                                         |\n  |                                                            |\n  | Function:  ISPF Edit Macro to                              |\n  |            - Confirm ALL merge conflict records are gone   |\n  |            - Save the current member if changed            |\n  |            - End the Edit session                          |\n  |                                                            |\n  | Author:    Lionel B. Dyck                                  |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |            12/13/19 LBD - creation                         |\n  |                                                            |\n  | ---------------------------------------------------------- |\n  |    ZIGI - the z/OS ISPF Git Interface                      |\n  |    Copyright (C) 2020 - Henri Kuiper and Lionel Dyck       |\n  |                                                            |\n  |    This program is free software: you can redistribute it  |\n  |    and/or modify it under the terms of the GNU General     |\n  |    Public License as published by the Free Software        |\n  |    Foundation, either version 3 of the License, or (at     |\n  |    your option) any later version.                         |\n  |                                                            |\n  |    This program is distributed in the hope that it will be |\n  |    useful, but WITHOUT ANY WARRANTY; without even the      |\n  |    implied warranty of MERCHANTABILITY or FITNESS FOR A    |\n  |    PARTICULAR PURPOSE.  See the GNU General Public License |\n  |    for more details.                                       |\n  |                                                            |\n  |    You should have received a copy of the GNU General      |\n  |    Public License along with this program.  If not, see    |\n  |    <https://www.gnu.org/licenses/>.                        |\n  * ---------------------------------------------------------- */\n  Address ISREdit\n  'Macro (options)'\n\n  /* ---------------------------------- *\n  | Get the current member information |\n  * ---------------------------------- */\n  '(member)  = member'\n  '(dataset) = dataset'\n  '(changed) = data_changed'\n  'Reset all'\n\n  /* --------------------------------------------- *\n  | Check for merge conflict records and if found |\n  | - insert warning message                      |\n  | - prevent save or end                         |\n  * --------------------------------------------- */\n  \"find '<<<<<<<' first 1\"\n  if rc = 0 then call dontsave\n  \"find '=======' first 1\"\n  if rc = 0 then call dontsave\n  \"find '>>>>>>>' first 1\"\n  if rc = 0 then call dontsave\n\n  /* ----------------------------- *\n  | If the data was changed then: |\n  | - save the data               |\n  | - update the changed string   |\n  | - copy to uss                 |\n  * ----------------------------- */\n  if changed = 'YES' then do\n    'Builtin Save'\n  end\n\n  /* ---------------------------------- *\n  | Now issue the End command and exit |\n  * ---------------------------------- */\n  Address ISREdit 'Builtin End'\n\n  exit\n\n  /* ------------------ *\n  | Don't Save routine |\n  * ------------------ */\n  dontsave:\n  msg = 'End Canceled  as git merge conflict records found.'\n  'line_before 1 = msgline (msg)'\n  msg = 'Resolve ALL conflicts and Remove ALL merge conflict records'\n  'line_before 1 = msgline (msg)'\n  msg = 'before trying to Save or End. Use Cancel if you can not resolve.'\n  'line_before 1 = msgline (msg)'\n  msg = left('-',70,'-')\n  'line_before 1 = msgline (msg)'\n  'cursor = 1'\n  exit 8\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZIGIEMS": {"ttr": 31, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01B\\x00\\x01 \\x07\\x1f\\x01 \\x11\\x8f\\x06 \\x00Q\\x00Q\\x00\\x00\\xe9\\xc9\\xc7\\xc9\\xf2\\xf8@@@@'", "ispf": {"version": "01.01", "flags": 66, "createdate": "2020-03-11T00:00:00", "modifydate": "2020-04-27T06:20:00", "lines": 81, "newlines": 81, "modlines": 0, "user": "ZIGI28"}, "text": " /*---------------------  rexx procedure  -------------------- *\n  | Name:      ZIGIEMS                                         |\n  |                                                            |\n  | Function:  ISPF Edit Macro to                              |\n  |            - Confirm ALL merge conflict records are gone   |\n  |            - Save the current member if changed            |\n  |                                                            |\n  | Author:    Lionel B. Dyck                                  |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |            12/13/19 LBD - creation                         |\n  |                                                            |\n  | ---------------------------------------------------------- |\n  |    ZIGI - the z/OS ISPF Git Interface                      |\n  |    Copyright (C) 2020 - Henri Kuiper and Lionel Dyck       |\n  |                                                            |\n  |    This program is free software: you can redistribute it  |\n  |    and/or modify it under the terms of the GNU General     |\n  |    Public License as published by the Free Software        |\n  |    Foundation, either version 3 of the License, or (at     |\n  |    your option) any later version.                         |\n  |                                                            |\n  |    This program is distributed in the hope that it will be |\n  |    useful, but WITHOUT ANY WARRANTY; without even the      |\n  |    implied warranty of MERCHANTABILITY or FITNESS FOR A    |\n  |    PARTICULAR PURPOSE.  See the GNU General Public License |\n  |    for more details.                                       |\n  |                                                            |\n  |    You should have received a copy of the GNU General      |\n  |    Public License along with this program.  If not, see    |\n  |    <https://www.gnu.org/licenses/>.                        |\n  * ---------------------------------------------------------- */\n  Address ISREdit\n  'Macro (options)'\n\n  /* ---------------------------------- *\n  | Get the current member information |\n  * ---------------------------------- */\n  '(member)  = member'\n  '(dataset) = dataset'\n  '(changed) = data_changed'\n  'Reset All'\n\n  /* --------------------------------------------- *\n  | Check for merge conflict records and if found |\n  | - insert warning message                      |\n  | - prevent save or end                         |\n  * --------------------------------------------- */\n  \"find '<<<<<<<' first 1\"\n  if rc = 0 then call dontsave\n  \"find '=======' first 1\"\n  if rc = 0 then call dontsave\n  \"find '>>>>>>>' first 1\"\n  if rc = 0 then call dontsave\n\n  /* ----------------------------- *\n  | If the data was changed then: |\n  | - save the data               |\n  | - update the changed string   |\n  | - copy to uss                 |\n  * ----------------------------- */\n  if changed = 'YES' then do\n    'Builtin Save'\n  end\n\n  exit\n\n  /* ------------------ *\n  | Don't Save routine |\n  * ------------------ */\n  dontsave:\n  msg = 'Save Canceled  as git merge conflict records found.'\n  'line_before 1 = msgline (msg)'\n  msg = 'Resolve ALL conflicts and Remove ALL merge conflict records'\n  'line_before 1 = msgline (msg)'\n  msg = 'before trying to Save or End. Use Cancel if you can not resolve.'\n  'line_before 1 = msgline (msg)'\n  msg = left('-',70,'-')\n  'line_before 1 = msgline (msg)'\n  'cursor = 1'\n  exit 8\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZIGIEXTR": {"ttr": 289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01!\\x001\\x01 \\x16O\\x01 !\\x1f\\x07R\\x03\\x03\\x006\\x00\\x00\\xe9\\xc9\\xc7\\xc9\\xf3\\xf0@@@@'", "ispf": {"version": "01.33", "flags": 0, "createdate": "2020-06-12T00:00:00", "modifydate": "2020-07-29T07:52:31", "lines": 771, "newlines": 54, "modlines": 0, "user": "ZIGI30"}, "text": "  /* --------------------  rexx procedure  -------------------- *\n  | Name:      zigiextr                                        |\n  |                                                            |\n  | Function:  ZIGI Extract                                    |\n  |                                                            |\n  |  Extract the changed files from the Git repository         |\n  |  based upon the tags provided.                             |\n  |                                                            |\n  |  Processing: 0. Validate we are running under ISPF         |\n  |              1. Process parameters and validate            |\n  |              2. Validate omvs-directory (Git repository)   |\n  |                 exists and is a ZIGI repository            |\n  |              3. Validate the extract-dir does not exist    |\n  |                 and create it                              |\n  |              4. Save current repository branch             |\n  |              5. Checkout a temporary branch                |\n  |              6. Checkout the <hash>                        |\n  |              7. Copy directory into a working directory    |\n  |              8. Git Show the provided tags to find delta   |\n  |                 elements                                   |\n  |                 - save files in the new extract directory  |\n  |                   if one provided                          |\n  |              9. Checkout original branch (master)          |\n  |             10. Copy changed OMVS files into the extract   |\n  |                 directory (if provided)                    |\n  |             11. Generate ISPF variables for datasets and   |\n  |                 members and call ZIGICKOT to create the    |\n  |                 z/OS datasets with the changed elements    |\n  |             12. Delete the temporary branch (5)            |\n  |             13. Delete the working directory (7)           |\n  |                                                            |\n  | Syntax:    %zigiextr omvs-directory zos-hlq ,              |\n  |                      extract-dir tags                      |\n  |                                                            |\n  | Parameters: (all required)                                 |\n  |                                                            |\n  |      omvs-directory  Directory of the Repository           |\n  |      zos-hlq         z/OS HLQ for the extracted datasets   |\n  |      extract-dir     OMVS directory to be created for      |\n  |                      any extracted OMVS files or . if none |\n  |      tags            Git commit tags to identify the       |\n  |                      changed elements                      |\n  |                                                            |\n  | Dependencies:                                              |\n  |             1. Must have access to ISPF services           |\n  |             2. Calls ZIGICKOT which must be in the         |\n  |                SYSPROC or SYSEXEC allocation               |\n  |                                                            |\n  | Author:    Lionel B. Dyck                                  |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |            07/29/20 LBD - Add _EDC_ZERO_RECLEN=Y to env.   |\n  |            06/21/20 LBD - View the extract log if omvsdir  |\n  |            06/20/20 LBD - Fix getting newest hash          |\n  |                           (major update)                   |\n  |            06/14/20 LBD - Correct copy of OMVS subdirs     |\n  |            06/13/20 LBD - Lots of work - appears ready     |\n  |            06/12/20 LBD - Creation                         |\n  | ---------------------------------------------------------- |\n  |    zigi - the z/OS ISPF Git Interface                      |\n  |    Copyright (C) 2020 - Henri Kuiper and Lionel Dyck       |\n  |                                                            |\n  |    This program is free software: you can redistribute it  |\n  |    and/or modify it under the terms of the GNU General     |\n  |    Public License as published by the Free Software        |\n  |    Foundation, either version 3 of the License, or (at     |\n  |    your option) any later version.                         |\n  |                                                            |\n  |    This program is distributed in the hope that it will be |\n  |    useful, but WITHOUT ANY WARRANTY; without even the      |\n  |    implied warranty of MERCHANTABILITY or FITNESS FOR A    |\n  |    PARTICULAR PURPOSE.  See the GNU General Public License |\n  |    for more details.                                       |\n  |                                                            |\n  |    You should have received a copy of the GNU General      |\n  |    Public License along with this program.  If not, see    |\n  |    <https://www.gnu.org/licenses/>.                        |\n  * ---------------------------------------------------------- */\n\n  Parse Arg omvsdir zoshlq extdir tags\n\n\n  if sysvar('sysispf') /= 'ACTIVE' then do\n    say 'ZIGIEXTR requires ISPF services which are currently unavailable.'\n    say 'Try again under ISPF.'\n    exit 16\n  end\n\n  /* ------------------- *\n  | Define our defaults |\n  * ------------------- */\n  parse value '' with null pulldsns members omvsfiles ofile tagl. ,\n    hash_tags\n  zerrhm     = 'zigih00'\n  zerralrm   = 'NO'\n  zerrtp     = 'NOTIFY'\n  Address ISPExec\n\n  /* ----------------------------------- *\n  | Get the environment variables setup |\n  * ----------------------------------- */\n  call setenv\n  tempBranch = 'zigiExtract-'date('j')'-'time('s')\n  tempDir    = home'/zigiExtract-'date('j')'-'time('s')\n\n  /* -------------------------- *\n  | Check the OMVS directories |\n  * -------------------------- */\n  if extdir /= '.' then\n  call check_omvs\n\n  /* ------------- *\n  | Check for Git |\n  * ------------- */\n  call check_git\n\n  /* ------------------------------------------- *\n  | Get Current Repoistory Info and commit info |\n  * ------------------------------------------- */\n  call get_newest_hash_tag\n  call get_repo_info\n  if extdir /= '.' then\n  call create_new_omvsdir\n  call do_Extract\n\n  Address ISPExec\n  'Control Display Save'\n  if extdir /= '.' then do\n   ofile = extDir'/Extract.info'\n   'View file(ofile) panel(zigiedit)'\n    \"Select Pgm(ISRDSLST) PARM(UDL\" extdir\") SUSPEND\"\n  end\n\n  \"LMDINIT LISTID(LISTID) LEVEL(\"zoshlq\")\"\n  \"LMDDISP LISTID(\"ListId\") Confirm(Yes)\",\n    \"View(Volume)\"\n  \"LMDFREE LISTID(\"ListId\")\"\n  'Control Display Restore'\n\n  Exit\n\n  /* -------------------------------- *\n  | Create new Target OMVS Directory |\n  * -------------------------------- */\nCreate_New_OmvsDir:\n  zs1 = 'Creating the Target OMVS Directory:'\n  zs2 = extdir\n  call do_popup\n  cmd = 'mkdir' extdir\n  cmd = cmd '&& chmod 744' extdir\n  x = docmd(cmd)\n  if x > 0 then call view_std 'B'\n  /* -------------------------------------------- *\n  | Now save the delta info in the new directory |\n  * -------------------------------------------- */\n  zs1 = 'Saving Extract File info.'\n  zs2 = null\n  call do_popup\n  cmd = 'cd' omvsdir\n  do ai = 1 to words(all_hash)\n    hloc = word(all_hash,ai)\n    cmd = cmd '&& git log  --diff-filter=\"ACDMRT\" -1 -U' Hloc\n    cmd = cmd '>>' extDir'/Extract.info'\n  end\n  x = docmd(cmd)\n  if x > 0 then call view_std 'B'\n  return\n\n  /* ------------------------------------------------------------- *\n  | Do the actual extract:                                        |\n  |                                                               |\n  | 1. Create and change to (checkout) a working branch           |\n  | 2. Get the delta for the requested hash (converted from tag)  |\n  | 3. Checkout the hash into the working branch                  |\n  | 4. Copy into new target omvs directory if one was requested   |\n  | 5. Checkout the original branch                               |\n  | 6. Copy any OMVS delta files into the omvs directory (4)      |\n  | 7. Call zigickot to create the z/OS datasets of the delta (2) |\n  * ------------------------------------------------------------- */\nDo_Extract:\n  /* ------------------------------------------ *\n  | Define temporary branch and directory name |\n  * ------------------------------------------ */\n  /* ------------------------------------------------------------ *\n  | Checkout (create) the working Branch                         |\n  | Then Copy the current directory, and subdirectories, into it |\n  | Then Checkout (return) to the original branch                |\n  * ------------------------------------------------------------ */\n  zs1 = 'Creating a temporary branch'\n  zs2 = 'Please standby'\n  call do_popup\n  cmd = 'cd' omvsdir\n  cmd = cmd '&& git checkout -b' tempBranch newest_hash\n  cmd = cmd '&& mkdir' tempDir '&& git status'\n  x = docmd(cmd)\n  if x > 0 then call view_std 'B'\n  call do_omvscopy\n  zs1 = 'Returning to the original Branch'\n  zs2 = 'Please standby'\n  call do_popup\n  cmd = 'cd' omvsdir\n  cmd = cmd '&& git checkout' activeBranch\n  x = docmd(cmd)\n  if x > 0 then call view_std 'B'\n  ckotdir = tempDir\n  ckothlq = translate(zoshlq)\n  if strip(pulldsns) = null then do\n    zs1 = 'Nothing to do'\n    zs2 = 'There are no z/OS datasets or OMVS files that changed' ,\n      'with the selected Commit Hash or Tag.'\n    call do_popupP\n    return\n  end\n  zs1 = 'Creating the z/OS Datasets'\n  zs2 = ckotdir ckothlq\n  call do_popup\n  'vput (ckotdir ckothlq pulldsns)'\n  'Select cmd(%zigickot)'\n\n/* ------------------------------- *\n | Now copy the omvsfiles (if any) |\n * ------------------------------- */\n  if extdir /= '.' then\n  if words(omvsfiles) >> 0 then\n  do omvi = 1 to words(omvsfiles)\n    file= word(omvsfiles,omvi)\n    zs1 = 'Copying OMVS file:'\n    zs2 = 'to' extDir\n    call do_popup\n    if  pos('/',file) > 0 then do\n      cpdir = '-R'\n      ndir = translate(file,' ','/')\n      ndir = subword(ndir,1,words(ndir)-1)\n      ndir = translate(ndir,'/',' ')\n    end\n    else do\n      ndir = null\n      cpdir = null\n    end\n    cmd = 'cd' tempDir\n    if ndir /= null then\n    cmd = cmd '&& mkdir' extDir''ndir\n    cmd = cmd '&& cp -v' cpdir file extDir''file\n    x = docmd(cmd)\n    if x > 0 then call view_std 'B'\n  end\n  cmd = 'rm -r' tempDir\n  cmd = cmd '&& cd' omvsdir\n  cmd = cmd '&& git branch  -D' tempBranch\n  x = docmd(cmd)\n  if x > 0 then call view_std 'B'\n  return\n\n  /* ------------------------------------------ *\n  | Only copy real files ignoring the . files. |\n  * ------------------------------------------ */\nDo_OmvsCopy:\n  zs1 = 'Copying temporary branch OMVS directory.'\n  zs2 = 'Please standby'\n  call do_popup\n  x = syscalls('ON')\n  address syscall 'readdir' omvsdir d. s.\n  x = syscalls('OFF')\n  do ocopyi = 1 to d.0\n    file = strip(d.ocopyi)\n    if file /= '.zigi' then\n    if left(file,1) = '.' then iterate\n    zs1 = 'Copying file:' file\n    zs2 = 'Please standby'\n    call do_popup\n    if s.ocopyi.st_type = '1'\n    then do\n      cdir = '-R'\n      file = file'/'\n      newdir = tempDir'/'file\n      odir = file\n    end\n    else do\n      cdir = null\n      newdir = null\n      odir = null\n    end\n    cmd = 'cd' omvsdir\n    if newdir /= null then\n    cmd = cmd '&& mkdir' newdir\n    cmd = cmd '&& cp' cdir omvsdir'/'file tempDir'/'odir\n    cmd = usssafe(cmd)\n    x = docmd(cmd)\n    if x > 0 then call view_std 'B'\n  end\n  return\n\n  /* -------------------------------------------------------------- *\n  | If more than one hash/tag was provided we need to get the most |\n  | recent hash. If a tag then we need the hash.                   |\n  * -------------------------------------------------------------- */\nGet_Newest_Hash_Tag:\n  zs1 = 'Getting the commit/tag specifics.'\n  zs2 = 'Please standby'\n  call do_popup\n  cmd = 'cd' omvsdir\n  cmd = cmd \"&& git log --abbrev-commit --pretty=format:'%h %cd'\"\n  x = docmd(cmd)\n  if x > 0 then call view_std 'B'\n  latest = 0\n  newest_hash = null\n  oldest_hash = null\n  all_hash = null\n  test_tags = tags\n  hit = 0\n  hash_counter = 0\n  do glht = 1 to so.0\n    hash = word(so.glht,1)\n    hash_counter = hash_counter + 1\n    if wordpos(hash,test_tags) > 0 then do\n      hit = 1\n      all_hash = all_hash hash\n      HashLoc.hash = glht\n      hp = wordpos(hash,test_tags)\n      test_tags = strip(delword(test_tags,hp,1))\n      if newest_hash = null then\n      newest_hash = hash\n      oldest_hash = hash\n    end\n    else if hit = 1 then all_hash = all_hash hash\n    if test_tags = null then return\n  end\n  return\n\n  /* ------------------------------------------------------------ *\n  | Get the repository information, including the delta elements |\n  | for the requested hash/tags                                  |\n  * ------------------------------------------------------------ */\nGet_Repo_Info:\n  zs1 = 'Getting the repository information'\n  zs2 = 'Please standby'\n  call do_popup\n  cmd = 'cd' omvsdir\n  cmd = cmd '&& git status'\n  x = docmd(cmd)\n  if x > 0 then call view_std 'B'\n  parse value so.1 with 'On branch' activeBranch\n  zs1 = 'Collecting information on what was changed.'\n  zs2 = 'Please standby'\n  call do_popup\n  cmd = 'cd' omvsdir\n  do ai = 1 to words(all_hash)\n    hloc = word(all_hash,ai)\n    cmd = cmd '&& git log  --diff-filter=\"ACDMRT\" -1 -U' Hloc\n    cmd = cmd \" | grep -e '+++' -e 'Binary'\"\n  end\n  x = docmd(cmd)\n  if x > 0 then call view_std 'B'\n  call stem_sort\n  old = null\n  do i = 1 to so.0\n    if left(so.i,1) = '+' then do\n      if old = so.i then iterate\n      old = so.i\n      parse value so.i with '+++ b/'file\n      if left(file,1) = '/' then iterate\n      if left(file,1) = '.' then iterate\n      if pos('/',file) > 0\n      then parse value file with file'/'mbr\n      else mbr = null\n      if ofile = null then ofile = file\n    end\n    else do\n      parse value so.i with . . . . 'b/'file 'differ'\n      if left(file,1) = '/' then iterate\n      if left(file,1) = '.' then iterate\n      if pos('/',file) > 0\n      then parse value file with file'/'mbr\n      else mbr = null\n      if ofile = null then ofile = file\n    end\n    call update_pulldsns\n  end\n  last = 1\n  call update_pulldsns\n\n  do i = 1 to words(pulldsns)\n    dsn = word(pulldsns,i)\n    'vget zv'i\n  end\n  return\n\n  /* ----------------------------------------------------- *\n  | Update the pulldsns and create the ispf variables for |\n  | pds members to pass to zigickot                       |\n  * ----------------------------------------------------- */\nUpdate_Pulldsns:\n  if dsnvalid(file) = 'NO' then do\n    if mbr /= null then file = file'/'mbr\n    if wordpos(file,omvsfiles) = 0 then\n    omvsfiles = omvsfiles file\n    if ofile /= file then do\n      wp = wordpos(ofile,pulldsns)\n      interpret 'zv'wp '= (members)'\n      zv.wp = members\n      'vput zv'wp\n      members = null\n      ofile = file\n    end\n    pulldsns = pulldsns file\n  end\n  else do\n    if wordpos(file,pulldsns) = 0 | last = 1 then do\n      if last = 1 then file = 0\n      if ofile /= file then do\n        wp = wordpos(ofile,pulldsns)\n        interpret 'zv'wp '= (members)'\n        zv.wp = members\n        'vput zv'wp\n        members = null\n        ofile = file\n      end\n      pulldsns = pulldsns file\n    end\n    if last /= 1 then\n    if mbr /= null then members = members mbr\n  end\n  return\n\n  /* -------------------------------------------------- *\n  | Determine if the provided filename is a valid z/OS |\n  | dataset name.                                      |\n  * -------------------------------------------------- */\ndsnvalid:\n  /* Tests for a 'potentially valid' z/OS datasetname */\n  parse arg val_dsn\n  if left(val_dsn,1) = '.' then return 'NO'\n  if strip(val_dsn) = null then return 'NO'\n  val_dsn = strip(val_dsn,'B',\"'\")\n  upp = TRANSLATE(val_dsn,\".ABCDEFGHIJKLMNOPQRSTUVWXYZ\",,\n    \".abcdefghijklmnopqrstuvwxyz\")\n  tdsn = translate(val_dsn,' ','.')\n  retval = 'OK'   /* asssume good */\n  do dsnvi = 1 to words(tdsn)\n    w = word(tdsn,dsnvi)\n    if length(w) > 8 then retval = 'NO'\n    if pos(left(w,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ$#@') = 0 then retval = 'NO'\n    w = translate(w,left(' ',39,' '), ,\n      'ABCDEFGHIJKLMNOPQRSTUVWXYZ-$#@0123456789')\n    w = strip(w)\n    if w /= null then retval = 'NO'\n  end\n  if retval /= 'NO' then\n  if upp = val_dsn then do\n    smsg = msg()\n    call msg 'OFF'\n    if sysdsn(val_dsn) = \"OK\" | sysdsn(val_dsn) = \"DATASET NOT FOUND\"\n    then retval = 'OK'\n    else retval = \"NO\"\n    call msg smsg\n  end\n  return retval\n\n  /* --------------------------------------------------- *\n  | Validate the OMVS directory is a ZIGI Git directory |\n  * --------------------------------------------------- */\nCheck_Git:\n  cmd = 'cd' omvsdir '&& ls -la .zigi'\n  x = docmd(cmd)\n  if pos('not found',se.1) > 1 then do\n    zerrsm = 'Error'\n    zerrlm = 'The requested OMVS Directory is NOT a ZIGI managed Git',\n      'repository:'\n    'Setmsg msg(isrz003)'\n    exit 8\n  end\n  return\n\n  /* ---------------------------------- *\n  | Validate the OMVS directory exists |\n  * ---------------------------------- */\nCheck_OMVS:\n  cmd = 'ls -la' omvsdir\n  x = docmd(cmd)\n  if pos('not found',se.1) > 1 then do\n    zerrsm = 'Error'\n    zerrlm = 'The requested OMVS Directory where the Git Repository' ,\n      'resides does not exist:' omvsdir\n    'Setmsg msg(isrz003)'\n    exit 8\n  end\n  cmd = 'ls -la' extdir\n  x = docmd(cmd)\n  if pos('not found',se.1) = 0 then do\n    zerrsm = 'Error'\n    zerrlm = 'The requested OMVS Directory to receive the extracted' ,\n      'OMVS files exists and it should not:' ,\n      left(extdir,74) 'Try again with a non-existent directory.'\n    'Setmsg msg(isrz003)'\n    exit 8\n  end\n  return\n\n  /* -------------------------------- *\n  | Issue the requested OMVS command |\n  * -------------------------------- */\ndocmd:\n  parse arg cmd\n  drop so. se.\n  x = bpxwunix(cmd,,so.,se.,env.)\n  return x\n\n  /* ----------------------------------------------------- *\n  | Get the users current OMVS enviornment for use in the |\n  | bpxwunix commands.                                    |\n  * ----------------------------------------------------- */\nSetEnv:\n  cmd = 'pwd'\n  env.1 = '_BPX_SHAREAS=YES'\n  env.0 = 1\n  x = bpxwunix(cmd,,so.,se.,env.)\n  home    = strip(so.1)\n  sol = so.0\n  cmd  = docmdx('env')\n  rc = bpxwunix(cmd,,env.,se.)\n  envc = env.0\n  call add_env '_BPX_SHAREAS=YES'\n  call add_env '_BPX_SPAWN_SCRIPT=YES'\n  call add_env 'EXPORT _EDC_ADD_ERRNO2=1'\n  call add_env '_EDC_ZERO_RECLEN=Y'\n  env.0 = envc\n  drop so. se.\n  return\n\n  /* -------------------- *\n  | Add info to env stem |\n  * -------------------- */\nadd_env:\n  parse arg env_val\n  envc = envc + 1\n  env.envc = env_val\n  return\n\n  /* ---------------------------------------- *\n  | Used by getenv for special circumstances |\n  * ---------------------------------------- */\ndocmdx:\n  /* quircky thing, we need to export HOME as we are\n  not running a login shell via bpxwunix */\n  parse arg cmd\n  drop o. se.\n  rx = 'export HOME='home' && . /etc/profile > /dev/null 2>&1 && '\n  c = \"\u00dd\u00dd -f \"home\"/.profile \u00a8\u00a8 && echo f\"\n  x = bpxwunix(c,,o.,se.)\n  if o.0 = 1 & o.1 = \"f\" then do\n    rx = rx '. 'home'/.profile > /dev/null 2>&1 && '\n  end\n  r = rx ' ' cmd\n  return r\n\n  /* ---------------------------------------------------------- *\n  | Generalized routine to view stdout. (so.) or stderr. (se.) |\n  | based on the parm passed                                   |\n  * ---------------------------------------------------------- */\nview_std:\n  arg stdopt viewopt\n  if stdopt = null then viewopt = 'B'\n  if viewopt = null then viewopt = 'B'\n  if stdopt = 'X' then stdopt = null\n  if datatype(so.0) /= 'NUM' then so.0 = 0\n  if datatype(se.0) /= 'NUM' then se.0 = 0\n  if viewopt = 'B' then if so.0 + se.0 = 0 then return\n  /* ------------------------------- *\n  | Randomly define a DDName to use |\n  * ------------------------------- */\n  dd = 'zd'random(9999)\n  /* --------------------------------------- *\n  | Get lrecl to determine dcb for temp d/s |\n  * --------------------------------------- */\n  if stdopt /= 'C' then do\n    vlrecl = 0\n    do li  = 1 to so.0\n      so.li = strip(so.li,'T')\n      if length(so.li) > vlrecl then vlrecl = length(so.li)\n      if so.li = null then so.li = ' '\n    end\n    do li  = 1 to se.0\n      se.li = strip(se.li,'T')\n      if length(se.li) > vlrecl then vlrecl = length(se.li)\n      if se.li = null then se.li = ' '\n    end\n    sec = so.0 + se.0\n  end\n  else do\n    do li = 1 to combine.0\n      if length(combine.li) > vlrecl then vlrecl = length(combine.li)\n    end\n    sec = combine.0\n  end\n  if vlrecl < 81 then vlrecl = 80\n  /* ------------------------------------------ *\n  | Allocate a temporary data set for our data |\n  * ------------------------------------------ */\n  Address TSO\n  /* calculate space needed with avg 50 bytes per record */\n  prim = (((so.0 + se.0) * 50) % 56000) + 1\n  if prim < 2 then prim = 5\n  if viewopt = 'V' then do\n    if sysvar('syspref') = null then pref = userid()'.'\n    else pref = null\n    vdsn = pref'work.zigi.gitdata'\n  end\n  else vdsn = null\n  x = listdsi(vdsn)\n  if x = 0 then do\n    call outtrap 'x.'\n    'delete' vdsn\n    call outtrap 'off'\n  end\n  if vdsn /= null then vdsnp = 'da('vdsn') unit(3390)'\n  else vdsnp = null\n  if vlrecl > 255 then vlrecl = 251\n  'Alloc f('dd') new spa('prim','prim') tr' ,\n    'recfm(v b) lrecl('vlrecl+4') blksize(0)' vdsnp\n  /* ----------------------------- *\n  | If stdopt is 'B' then do both |\n  * ----------------------------- */\n  if stdopt /= 'C' then do\n    stdopt = null\n    sc = so.0\n    do xi = 1 to se.0\n      sc = sc + 1\n      so.sc = se.xi\n    end\n    so.0 = sc\n  end\n  /* ----------------------- *\n  | Write out the stem data |\n  * ----------------------- */\n  if stdopt = 'C' then do\n    'Execio * diskw' dd '(finis stem combine.'\n    drop combine.\n    combine.0 = 0\n  end\n  if stdopt /= 'C' then do\n    if stdopt = null\n    then do\n      'Execio * diskw' dd '(finis stem so.'\n    end\n    else do\n      'Execio * diskw' dd '(finis stem se.'\n    end\n  end\n  /* -------------------------------------------------- *\n  | Access the Temporary Data Set using ISPF           |\n  | Library Services.                                  |\n  | Then using ISPF Browse service to browse the data. |\n  | And use Library Services to Free the Data Set.     |\n  * -------------------------------------------------- */\n  Address ISPExec\n  if sec > 0 then if viewopt = 'B' then do\n    'lminit dataid(ddb) ddname('dd')'\n    'browse dataid('ddb') panel(zigibrow)'\n    'lmfree dataid('ddb')'\n  end\n  else do\n    vmac = 'Panel(zigiedit) macro(zigivmac)'\n    'view dataset('vdsn')' vmac\n    vtitle = null\n    'verase vtitle'\n  end\n  /* ----------------------------- *\n  | Last Free the z/OS Allocation |\n  * ----------------------------- */\n  call outtrap 'x.'\n  Address TSO ,\n    'Free f('dd')'\n  if vdsn /= null then\n  Address TSO 'Delete' vdsn\n  call outtrap 'off'\n  return\n\n  /* ---------------------------------------- *\n  | Common routine for locked (2 line) popup |\n  * ---------------------------------------- */\nDo_Popup:\n  call pfshow 'off'           /* make sure pfshow is off */\n  'Control Display Lock'\n  'Addpop row(4) column(8)'\n  'Display Panel(zigipop)'\n  'Rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  return\n\n  /* ---------------------------------------- *\n  | Common routine for normal (2 line) popup |\n  * ---------------------------------------- */\nDo_PopupP:\n  call pfshow 'off'           /* make sure pfshow is off */\n  'Addpop row(4) column(8)'\n  'Display Panel(zigipop)'\n  'Rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  return\n\n  /* ------------------------------------------------------ *\n  | The pfshow routine will:                               |\n  | 1. check to see the passed option                      |\n  | 2. if Off then it will save the current pfshow setting |\n  |    - save the current setting                          |\n  |    - turn off pfshow                                   |\n  | 3. if the option is Reset then it will                 |\n  |    - test if pfshow was on and turn it back on         |\n  * ------------------------------------------------------ */\npfshow:\n  if zpfshow = 'OFF' then return\n  arg pfkopt\n  if pfkopt = 'RESET' then do\n    if pfkeys = 'ON' then\n    'select pgm(ispopf) parm(FKA,ON)'\n  end\n  if pfkopt = 'OFF' then do\n    'vget (zpfshow)'\n    pfkeys = zpfshow\n    if pfkeys /= 'OFF' then\n    'select pgm(ispopf) parm(FKA,OFF)'\n  end\n  return\n\nusssafe:\n  parse arg safedsn\n  if pos('$',safedsn) = 0 then return safedsn\n  /* Let's not usssafe it twice :) */\n  if pos('\\$',safedsn) > 0 then return safedsn\n  safedsn = strreplace(safedsn, '$', '\\$')\n  return safedsn\n\n  /* ------------------------------------------------- *\n  | String replace routine                           |\n  | input string                                     |\n  | from string                                      |\n  | to string                                        |\n  | translate is input to from                       |\n  * ------------------------------------------------- */\nstrreplace:\n  string  = arg(1)\n  strfrom = arg(2)\n  strto   = arg(3)\n  if pos(strfrom,string) = 0 then return string\n  newString = ''\n  do repi = 1 to length(string)\n    if substr(string,repi,1) /= strfrom\n    then newstring = newstring''substr(string,repi,1)\n    else  newstring = newstring''strto\n  end\n  return newstring\n\nStem_Sort:\n  /* rexx command to sort a stem variable\n  Simple bubble sort of \"stem' by so.1\n  Ken Singer, Shell Oil, Houston\n  ********************************************************/\n  if so.0 = 1 then return /* simple sort !*/\n  ctr =  so.0\n  do y = 1 to  ctr - 1\n    do x = y+1 to ctr\n      if so.x = null then leave\n      if so.x < so.y then do\n        /* swap these 2 entries */\n        t1 = so.y ;\n        so.y = so.x\n        so.x = t1\n      end\n    end x\n  end y\n  Return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZIGIGCMD": {"ttr": 217, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x02\\x00\\x01 \\x07\\x1f\\x01 \\x17O\\x06\\x13\\x01K\\x019\\x00\\x00\\xe2\\xd3\\xc2\\xc4@@@@@@'", "ispf": {"version": "01.10", "flags": 2, "createdate": "2020-03-11T00:00:00", "modifydate": "2020-06-22T06:13:00", "lines": 331, "newlines": 313, "modlines": 0, "user": "SLBD"}, "text": "  /* --------------------  rexx procedure  -------------------- *\n  | Name:      zigigcmd                                        |\n  |                                                            |\n  | Function:  Issue any git command and browse the results    |\n  |                                                            |\n  | Syntax:    %zigigcmd                                       |\n  |                                                            |\n  | Usage Notes: display a prompt panel with table of recent   |\n  |              the localrep ispf variable must be available  |\n  |                                                            |\n  | Author:    Lionel B. Dyck                                  |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |            06/22/20 LBD - Save command in ISPF var         |\n  |            06/17/20 LBD - Message on command completion    |\n  |            05/02/20 LBD - If git log set vtype variable    |\n  |            01/12/20 LBD - Add CLEAR command to clear all   |\n  |            12/13/19 LBD - Add Browse / View options        |\n  |            11/27/19 LBD - Creation                         |\n  |                                                            |\n  | ---------------------------------------------------------- |\n  |    ZIGI - the z/OS ISPF Git Interface                      |\n  |    Copyright (C) 2020 - Henri Kuiper and Lionel Dyck       |\n  |                                                            |\n  |    This program is free software: you can redistribute it  |\n  |    and/or modify it under the terms of the GNU General     |\n  |    Public License as published by the Free Software        |\n  |    Foundation, either version 3 of the License, or (at     |\n  |    your option) any later version.                         |\n  |                                                            |\n  |    This program is distributed in the hope that it will be |\n  |    useful, but WITHOUT ANY WARRANTY; without even the      |\n  |    implied warranty of MERCHANTABILITY or FITNESS FOR A    |\n  |    PARTICULAR PURPOSE.  See the GNU General Public License |\n  |    for more details.                                       |\n  |                                                            |\n  |    You should have received a copy of the GNU General      |\n  |    Public License along with this program.  If not, see    |\n  |    <https://www.gnu.org/licenses/>.                        |\n  * ---------------------------------------------------------- */\n  parse arg cmd\n\n  /* ----------------------------- *\n  | Get env vars and set defaults |\n  * ----------------------------- */\n  call getenv\n  dd = 'ZC'time('s')\n  parse value '' with null gsel\n  zerrhm = 'zigih0'\n  zerralrm = 'NO'\n  zerrtp   = 'NOTIFY'\n\n  /* ---------------------------------------------------- *\n  | Set ISPExec                                          |\n  | Get the ISPF vars from ZIGI for localrep and zigirep |\n  | Define localdir as a composite variable              |\n  * ---------------------------------------------------- */\n  Address ISPExec\n  'Control Errors Return'\n  'vget (gopt) profile'\n  if gopt = null then gopt = 'B'\n  'vget (localrep zigirep)'\n  localdir = localrep'/'zigirep\n\n  /* ------------------------------------ *\n  | Check if we actually have a localrep |\n  * ------------------------------------ */\n  if localrep = null then do\n     zerrsm = 'Error.'\n     zerrlm = 'The ZIGI git Command dialog will only work while in' ,\n       'a repository.'\n     'Setmsg msg(isrz003)'\n     exit\n  end\n\n  /* -------------------------------------------------- *\n  | Check to see if the user has ISPTABL allocated and |\n  | if not then use ISPPROF as our table DD            |\n  * -------------------------------------------------- */\n  isptabl = 'ISPTABL'\n  x = listdsi(isptabl 'FILE')\n  if x > 0 then isptabl = 'ISPPROF'\n\n  /* ----------------------------------------------------- *\n  | Open the table but if it doesn't exist then create it |\n  * ----------------------------------------------------- */\n  'TBOpen zigigcmd Library('isptabl') Write Share'\n  if rc > 0 then do\n  'tbcreate zigigcmd keys(gitcmde) library('isptabl') write share'\n  call populate\n  end\n\n  /* -------------------- *\n  | Setup table defaults |\n  * -------------------- */\n  ztdtop = 0\n  ztdsels = 0\n\n  /* ---------------------------------------------------------------- *\n  | Process the table.                                               |\n  |                                                                  |\n  | All row selections will be processed and if none then the git    |\n  | command will be executed.                                        |\n  |                                                                  |\n  | Row selections:  S to copy the command to the git command  entry |\n  |                  D to delete the command (supports multipe row   |\n  |                    selections)                                   |\n  |                  X to execute the command now and update the     |\n  |                    git command entry field                       |\n  * ---------------------------------------------------------------- */\n  do forever\n     if ztdsels = 0 then do\n        'tbtop zigigcmd'\n        'tbskip zigigcmd number('ztdtop')'\n        'tbdispl zigigcmd panel(zigigcmd) cursor(gitcmd)'\n     end\n     else\n     'tbdispl zigigcmd'\n     if rc > 4 then leave\n     'vput (gopt) profile'\n     if row = 0 then gsel = null\n     if row <> null then\n     if row > 0 then do\n       'TBTop zigigcmd'\n       'TBSkip zigigcmd Number('row')'\n     end\n     Select\n        When zcmd = 'CLEAR' then do\n             'tbclose zigigcmd replcopy library('isptabl')'\n             'tberase zigigcmd library('isptabl')'\n             'tbcreate zigigcmd keys(gitcmde) library('isptabl') write share'\n             gitcmd = null\n             end\n        When gsel = 'D' then 'tbdelete zigigcmd'\n        When gsel = 'S' then do\n           gitcmd = gitcmde\n           ztdsels = 0\n        end\n        When gsel = 'X' then do\n           gitcmd = gitcmde\n           ztdsels = 0\n           call do_gitcmd\n        end\n        When gitcmd /= null then call do_gitcmd\n        Otherwise nop\n     end\n     gsel = null\n  end\n\n  /* -------------- *\n  | Close and exit |\n  * -------------- */\n  'tbclose zigigcmd replcopy library('isptabl')'\n  exit\n\n  /* ------------------------------------------------------------- *\n  | Execute the git command                                       |\n  | But 1st - check and remove git from the user provided command |\n  * ------------------------------------------------------------- */\ndo_gitcmd:\n  gitcmde = gitcmd\n  if translate(word(gitcmde,1)) = 'GIT' then\n  gitcmd = subword(gitcmd,2)\n  gitcmde = gitcmd\n  'tbadd zigigcmd'\n  cmd = 'cd' localdir '&& git' gitcmde\n  x = bpxwunix(cmd,,so.,se.,env.)\n  if word(gitcmd,1) = 'log' then\n    if wordpos('--graph',gitcmd) > 0 then do\n     vtype = 'X'\n     'vput (vtype) shared'\n     end\n  zerrsm = 'Completed.'\n  zerrlm = 'The command completed processing. There may, or may not, be' ,\n           'messages. If there are then the messages will be displayed.'\n  'Setmsg msg(isrz003)'\n  'vput (gitcmde) shared'\n  call view_std\n  vtype = null\n  'verase (gitcmde)'\n  'vput (vtype) shared'\n  return\n\n  /* ------------------------------------- *\n  * Name:     Lower                       *\n  *                                       *\n  * Function: Lowercase the provided data *\n  *                                       *\n  * Syntax:   x=lower(input)              *\n  *                                       *\n  * History:                              *\n  *           08/17/07: created           *\n  * ------------------------------------- */\nLower: Procedure\n  parse arg input\n  out = translate(input,\"abcdefghijklmnopqrstuvwxyz\",,\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n  return out\n\n  /* ----------------------------------------------------- *\n  | Get the users current OMVS enviornment for use in the |\n  | bpxwunix commands.                                    |\n  * ----------------------------------------------------- */\nGETENV: procedure expose env.\n  cmd = 'pwd'\n  e.1 = '_BPX_SHAREAS=YES'\n  e.0 = 1\n  x = bpxwunix(cmd,,so.,se.,e.)\n  home    = strip(so.1)\n  cmd  = docmd('env')\n  rc = bpxwunix(cmd,,env.,se.)\n  envc = env.0\n  call add_env '_BPX_SHAREAS=YES'\n  call add_env '_BPX_SPAWN_SCRIPT=YES'\n  env.0 = envc\n  return\n\n  /* -------------------- *\n  | Add info to env stem |\n  * -------------------- */\nadd_env:\n  parse arg env_val\n  envc = envc + 1\n  env.envc = env_val\n  return\n\n  /* ------------------------- *\n  | Execute the  omvs command |\n  | Used by GETENV only.      |\n  * ------------------------- */\ndocmd:\n  rx = null\n  /* quircky thing, we need to export HOME as we are\n  not running a login shell via bpxwunix */\n  parse arg cmd\n  if rx = null then do\n     rx = 'export HOME='home' && . /etc/profile > /dev/null 2>&1 && '\n     c = \"\u00dd\u00dd -f \"home\"/.profile \u00a8\u00a8 && echo f\"\n     x = bpxwunix(c,,o.,e.)\n     if o.0 = 1 & o.1 = \"f\" then do\n        rx = rx '. 'home'/.profile > /dev/null 2>&1 && '\n     end\n  end\n  r = rx cmd\n  return r\n\n  /* ---------------------------------------------------------- *\n  | Generalized routine to view stdout. (so.) or stderr. (se.) |\n  | based on the parm passed                                   |\n  * ---------------------------------------------------------- */\nview_std:\n  stdopt = 'B'\n  'Control Display Save'\n  /* ------------------------------- *\n  | Randomly define a DDName to use |\n  * ------------------------------- */\n  dd = 'dd'random(9999)\n  /* --------------------------------------- *\n  | Get lrecl to determine dcb for temp d/s |\n  * --------------------------------------- */\n  vlrecl = 80\n  do li  = 1 to so.0\n     so.li = strip(so.li)\n     if length(so.li) > vlrecl then vlrecl = length(so.li)\n     if so.li = null then so.li = ' '\n  end\n  do li  = 1 to se.0\n     se.li = strip(se.li)\n     if length(se.li) > vlrecl then vlrecl = length(se.li)\n     if se.li = null then se.li = ' '\n  end\n  sec = so.0 + se.0\n  if vlrecl < 81 then vlrecl = 80\n  else vlrecl = vlrecl + 4\n  if vlrecl = 80 then vrecfm = 'f b'\n  else vrecfm = 'v b'\n  /* ------------------------------------------ *\n  | Allocate a temporary data set for our data |\n  * ------------------------------------------ */\n  Address TSO\n  'Alloc f('dd') new spa(5,5) tr' ,\n    'recfm('vrecfm') lrecl('vlrecl') blksize(0)'\n  stdopt = null\n  sc = so.0\n  do xi = 1 to se.0\n     sc = sc + 1\n     so.sc = se.xi\n  end\n  so.0 = sc\n  drop se.\n  /* ----------------------- *\n  | Write out the stem data |\n  * ----------------------- */\n  if stdopt = null\n  then do\n     'Execio * diskw' dd '(finis stem so.'\n     drop so.\n  end\n  /* -------------------------------------------------- *\n  | Access the Temporary Data Set using ISPF           |\n  | Library Services.                                  |\n  | Then using ISPF Browse service to browse the data. |\n  | And use Library Services to Free the Data Set.     |\n  * -------------------------------------------------- */\n  Address ISPExec\n  if sec > 0 then do\n     'lminit dataid(ddb) ddname('dd')'\n     if gopt = 'B'\n     then 'browse dataid('ddb') panel(zigibrow)'\n     else 'view   dataid('ddb') panel(zigiedit) macro(zigivmac)'\n     'lmfree dataid('ddb')'\n  end\n  /* ----------------------------- *\n  | Last Free the z/OS Allocation |\n  * ----------------------------- */\n  Address TSO ,\n    'Free f('dd')'\n  'Control Display Restore'\n  return\n\n/* ---------------------------------- *\n | Pre-Populate the git command table |\n * ---------------------------------- */\nPopulate:\n  gitcmde = 'shortlog HEAD  --format=\"%<(80,trunc)%f\"'\n  'tbadd zigigcmd'\n  gitcmde = 'merge --abort'\n  'tbadd zigigcmd'\n  gitcmde = 'status'\n  'tbadd zigigcmd'\n  return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZIGIGENI": {"ttr": 237, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x02\\x00\\x01 \\x16?\\x01 \\x17\\x8f\\x04R\\x01B\\x00*\\x00\\x00\\xe9\\xc9\\xc7\\xc9\\xf3\\xf0@@@@'", "ispf": {"version": "01.15", "flags": 2, "createdate": "2020-06-11T00:00:00", "modifydate": "2020-06-26T04:52:00", "lines": 322, "newlines": 42, "modlines": 0, "user": "ZIGI30"}, "text": "  /* --------------------  rexx procedure  -------------------- *\n  | Name:      zigigeni                                        |\n  |                                                            |\n  | Function:  ZIGI Generalized Installer Setup Routine        |\n  |                                                            |\n  |            Will copy the generalized installer exec from   |\n  |            the ZIGI Exec library into the ZIGI managed     |\n  |            repositories root directory as zginstall.rex    |\n  |            with a chmod +x.                                |\n  |                                                            |\n  | Syntax:    rc = zigigeni(omvsdir)                          |\n  |                                                            |\n  |            rc = 0 is ok                                    |\n  |            rc = 4 is not                                   |\n  |                                                            |\n  | Author:    Lionel B. Dyck                                  |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |            06/26/20 LBD - Add git add and if clean do      |\n  |                           a git commit                     |\n  |            06/14/20 LBD - Update long message remove add.  |\n  |            06/11/20 LBD - Creation                         |\n  | ---------------------------------------------------------- |\n  |    zigi - the z/OS ISPF Git Interface                      |\n  |    Copyright (C) 2020 - Henri Kuiper and Lionel Dyck       |\n  |                                                            |\n  |    This program is free software: you can redistribute it  |\n  |    and/or modify it under the terms of the GNU General     |\n  |    Public License as published by the Free Software        |\n  |    Foundation, either version 3 of the License, or (at     |\n  |    your option) any later version.                         |\n  |                                                            |\n  |    This program is distributed in the hope that it will be |\n  |    useful, but WITHOUT ANY WARRANTY; without even the      |\n  |    implied warranty of MERCHANTABILITY or FITNESS FOR A    |\n  |    PARTICULAR PURPOSE.  See the GNU General Public License |\n  |    for more details.                                       |\n  |                                                            |\n  |    You should have received a copy of the GNU General      |\n  |    Public License along with this program.  If not, see    |\n  |    <https://www.gnu.org/licenses/>.                        |\n  * ---------------------------------------------------------- */\n\n  parse arg omvsdir\n\n  parse value '' with null\n  zerrhm   = 'zigih00'\n  zerralrm = 'NO'\n  zerrtp   = 'NOTIFY'\n\n  /* ----------------------------- *\n  | Find active exec library name |\n  * ----------------------------- */\n  parse source x1 x2 x3 ddn dsn .\n\n  if dsn = '?' then do\n    x = listdsi(ddn 'FILE')\n    dsn = sysdsname\n  end\n\n  panels = translate(dsn,' ','.')\n  panels = subword(panels,1,words(panels)-1)' PANELS'\n  panels = translate(panels,'.',' ')\n  panels = \"'\"panels\"(ZIGIGENI)'\"\n\n  dsn = \"'\"sysdsname\"(zginstal)'\"\n  if sysdsn(dsn) /= 'OK' then do\n    zerrsm = 'Error'\n    zerrlm = 'There was a problem finding the ZGINSTAL REXX Exec Library.'\n    Address ISPExec 'Setmsg msg(isrz003)'\n    return 4\n  end\n\n  /* -------------------------------------- *\n  | Define the BPX environmental variables |\n  * -------------------------------------- */\n  call getenv\n\n  /* ------------------------------------------------------------- *\n  | Copy the ZGINSTAL REXX member into zginstall.rex and copy the |\n  | ZIGIGENI ISPF Panel member (not really a panel) into          |\n  | zginstall.readme                                              |\n  * ------------------------------------------------------------- */\n  commit = null\n  if check_clean() = 'YES' then do\n  commit = \"&& git commit -m 'ZIGI Generalized Installation Tool added.'\"\n  com_push = 'PUSH'\n  end\n  else com_push = 'COMMIT with a PUSH'\n  cmd = 'cd' omvsdir\n  cmd = cmd '&& cp -v \"//'dsn'\" zginstall.rex'\n  cmd = cmd '&& chmod +x zginstall.rex'\n  cmd = cmd '&& cp -v \"//'panels'\" zginstall.readme'\n  cmd = cmd '&& git add zginstall.rex zginstall.readme' commit\n  x = docmd(cmd)\n  if x > 0 then call view_std 'B'\n\n  zs1 = 'The ZIGI Generalized Installation Tool has been' ,\n    'copied into the Git'\n  zs2 = 'repository. Both' ,\n    'zginstall.rex and zginstall.readme have been created.'\n  zs3 = 'A' com_push 'should now be performed.'\n  Address ISPExec\n  call do_popup\n  return 0\n\n  /* ---------------------------------------- *\n  | Common routine for normal (2 line) popup |\n  * ---------------------------------------- */\nDo_Popup:\n  call pfshow 'off'           /* make sure pfshow is off */\n  'Addpop row(4) column(4)'\n  'Display Panel(zigipop3)'\n  'Rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  return\n\n  /* ------------------------------------------------------ *\n  | The pfshow routine will:                               |\n  | 1. check to see the passed option                      |\n  | 2. if Off then it will save the current pfshow setting |\n  |    - save the current setting                          |\n  |    - turn off pfshow                                   |\n  | 3. if the option is Reset then it will                 |\n  |    - test if pfshow was on and turn it back on         |\n  * ------------------------------------------------------ */\npfshow:\n  if zpfshow = 'OFF' then return\n  arg pfkopt\n  if pfkopt = 'RESET' then do\n    if pfkeys = 'ON' then\n    'select pgm(ispopf) parm(FKA,ON)'\n  end\n  if pfkopt = 'OFF' then do\n    'vget (zpfshow)'\n    pfkeys = zpfshow\n    if pfkeys /= 'OFF' then\n    'select pgm(ispopf) parm(FKA,OFF)'\n  end\n  return\n\ncheck_clean:\n  /* ---------------------------------------------------------\\\n  | Name:      check_clean                                     |\n  |                                                            |\n  | Function:  Checks if working dir is clean                  |\n  |            returns YES or NO                               |\n  \\---------------------------------------------------------- */\n  cmd = 'cd 'omvsdir '&& git status'\n  x = docmd(cmd)\n  clast = so.0\n  if pos('working tree clean',so.clast) > 0 then return 'YES'\n  else return \"NO\"\n\n  /* ----------------------------------------------------- *\n  | Get the users current OMVS enviornment for use in the |\n  | bpxwunix commands.                                    |\n  * ----------------------------------------------------- */\nGETENV:\n  cmd = 'pwd'\n  x = bpxwunix(cmd,,so.,se.)\n  home    = strip(so.1)\n  cmd  = docmdx('env')\n  rc = bpxwunix(cmd,,env.,se.)\n  envc = env.0\n  call add_env '_BPX_SHAREAS=YES'\n  call add_env '_BPX_SPAWN_SCRIPT=YES'\n  call add_env 'EXPORT _EDC_ADD_ERRNO2=1'\n  env.0 = envc\n  drop so. se.\n  return\n\n  /* -------------------- *\n  | Add info to env stem |\n  * -------------------- */\nadd_env:\n  parse arg env_val\n  envc = envc + 1\n  env.envc = env_val\n  return\n\ndocmd:\n  parse arg cmd\n  drop so. se.\n  x = bpxwunix(cmd,,so.,se.,env.)\n  return x\n\ndocmdx:\n  /* quircky thing, we need to export HOME as we are\n  not running a login shell via bpxwunix */\n  parse arg cmd\n  drop o. se.\n    rx = 'export HOME='home' && . /etc/profile > /dev/null 2>&1 && '\n    c = \"\u00dd\u00dd -f \"home\"/.profile \u00a8\u00a8 && echo f\"\n    x = bpxwunix(c,,o.,se.)\n    if o.0 = 1 & o.1 = \"f\" then do\n      rx = rx '. 'home'/.profile > /dev/null 2>&1 && '\n    end\n  r = rx ' ' cmd\n  return r\n\n  /* ---------------------------------------------------------- *\n  | Generalized routine to view stdout. (so.) or stderr. (se.) |\n  | based on the parm passed                                   |\n  * ---------------------------------------------------------- */\nview_std:\n  arg stdopt viewopt\n  if stdopt = null then viewopt = 'B'\n  if viewopt = null then viewopt = 'B'\n  if stdopt = 'X' then stdopt = null\n  if datatype(so.0) /= 'NUM' then so.0 = 0\n  if datatype(se.0) /= 'NUM' then se.0 = 0\n  if viewopt = 'B' then if so.0 + se.0 = 0 then return\n  /* ------------------------------- *\n  | Randomly define a DDName to use |\n  * ------------------------------- */\n  dd = 'zd'random(9999)\n  /* --------------------------------------- *\n  | Get lrecl to determine dcb for temp d/s |\n  * --------------------------------------- */\n  if stdopt /= 'C' then do\n    vlrecl = 0\n    do li  = 1 to so.0\n      so.li = strip(so.li,'T')\n      if length(so.li) > vlrecl then vlrecl = length(so.li)\n      if so.li = null then so.li = ' '\n    end\n    do li  = 1 to se.0\n      se.li = strip(se.li,'T')\n      if length(se.li) > vlrecl then vlrecl = length(se.li)\n      if se.li = null then se.li = ' '\n    end\n    sec = so.0 + se.0\n  end\n  else do\n    do li = 1 to combine.0\n      if length(combine.li) > vlrecl then vlrecl = length(combine.li)\n    end\n    sec = combine.0\n  end\n  if vlrecl < 81 then vlrecl = 80\n  /* ------------------------------------------ *\n  | Allocate a temporary data set for our data |\n  * ------------------------------------------ */\n  Address TSO\n  /* calculate space needed with avg 50 bytes per record */\n  prim = (((so.0 + se.0) * 50) % 56000) + 1\n  if prim < 2 then prim = 5\n  if viewopt = 'V' then do\n    if sysvar('syspref') = null then pref = userid()'.'\n    else pref = null\n    vdsn = pref'work.zigi.gitdata'\n  end\n  else vdsn = null\n  x = listdsi(vdsn)\n  if x = 0 then do\n    call outtrap 'x.'\n    'delete' vdsn\n    call outtrap 'off'\n  end\n  if vdsn /= null then vdsnp = 'da('vdsn') unit(3390)'\n  else vdsnp = null\n  if vlrecl > 255 then vlrecl = 251\n  'Alloc f('dd') new spa('prim','prim') tr' ,\n    'recfm(v b) lrecl('vlrecl+4') blksize(0)' vdsnp\n  /* ----------------------------- *\n  | If stdopt is 'B' then do both |\n  * ----------------------------- */\n  if stdopt /= 'C' then do\n    stdopt = null\n    sc = so.0\n    do xi = 1 to se.0\n      sc = sc + 1\n      so.sc = se.xi\n    end\n    so.0 = sc\n  end\n  /* ----------------------- *\n  | Write out the stem data |\n  * ----------------------- */\n  if stdopt = 'C' then do\n    'Execio * diskw' dd '(finis stem combine.'\n    drop combine.\n    combine.0 = 0\n  end\n  if stdopt /= 'C' then do\n    if stdopt = null\n    then do\n      'Execio * diskw' dd '(finis stem so.'\n    end\n    else do\n      'Execio * diskw' dd '(finis stem se.'\n    end\n  end\n  /* -------------------------------------------------- *\n  | Access the Temporary Data Set using ISPF           |\n  | Library Services.                                  |\n  | Then using ISPF Browse service to browse the data. |\n  | And use Library Services to Free the Data Set.     |\n  * -------------------------------------------------- */\n  Address ISPExec\n  if sec > 0 then if viewopt = 'B' then do\n    'lminit dataid(ddb) ddname('dd')'\n    'browse dataid('ddb') panel(zigibrow)'\n    'lmfree dataid('ddb')'\n  end\n  else do\n    vmac = 'Panel(zigiedit) macro(zigivmac)'\n    'view dataset('vdsn')' vmac\n    vtitle = null\n    'verase vtitle'\n  end\n  /* ----------------------------- *\n  | Last Free the z/OS Allocation |\n  * ----------------------------- */\n  call outtrap 'x.'\n  Address TSO ,\n    'Free f('dd')'\n  if vdsn /= null then\n  Address TSO 'Delete' vdsn\n  call outtrap 'off'\n  return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZIGIMRGM": {"ttr": 219, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x02\\x00\\x01 \\x07\\x1f\\x01 \\x19O\\x108\\x00p\\x00p\\x00\\x00\\xe9\\xc9\\xc7\\xc9\\xf3\\xf0@@@@'", "ispf": {"version": "01.04", "flags": 2, "createdate": "2020-03-11T00:00:00", "modifydate": "2020-07-12T10:38:00", "lines": 112, "newlines": 112, "modlines": 0, "user": "ZIGI30"}, "text": "/* --------------------  rexx procedure  -------------------- *\n | Name:      zigimrgm                                        |\n |                                                            |\n | Function:  ISPF Edit Macro to:                             |\n |                                                            |\n |   Parm M: remove all non-merge records                     |\n |   Parm blank: remove all merge records                     |\n |               and compare merge-file x                     |\n |                                                            |\n | Usage Notes: called by ZIGI                                |\n |                                                            |\n | Author:    Lionel B. Dyck                                  |\n |                                                            |\n | History:  (most recent on top)                             |\n |            01/08/20 LBD - add msgline comments             |\n |            12/08/19 LBD - creation                         |\n |                                                            |\n | ---------------------------------------------------------- |\n |    ZIGI - the z/OS ISPF Git Interface                      |\n |    Copyright (C) 2020 - Henri Kuiper and Lionel Dyck       |\n |                                                            |\n |    This program is free software: you can redistribute it  |\n |    and/or modify it under the terms of the GNU General     |\n |    Public License as published by the Free Software        |\n |    Foundation, either version 3 of the License, or (at     |\n |    your option) any later version.                         |\n |                                                            |\n |    This program is distributed in the hope that it will be |\n |    useful, but WITHOUT ANY WARRANTY; without even the      |\n |    implied warranty of MERCHANTABILITY or FITNESS FOR A    |\n |    PARTICULAR PURPOSE.  See the GNU General Public License |\n |    for more details.                                       |\n |                                                            |\n |    You should have received a copy of the GNU General      |\n |    Public License along with this program.  If not, see    |\n |    <https://www.gnu.org/licenses/>.                        |\n * ---------------------------------------------------------- */\n  Address ISREdit\n  'Macro (options)'\n  'reset all'\n  'recovery on'\n  address ispexec 'vget (mdsn mrgdir mrgfile)'\n\n  if options = '' then do\n    '(last) = linenum .zlast'\n    hit = 0\n    do i = last to 1 by -1\n      '(data) = line' i\n      Select\n      when pos('<<<<<<<',data) > 0 then do\n        'delete' i\n        hit = 0\n      end\n      when pos('=======',data) > 0 then do\n        'delete' i\n        hit = 0\n      end\n      when pos('>>>>>>>',data) > 0 then do\n        'delete' i\n        hit = 1\n      end\n      when hit = 1 then do\n        'delete' i\n      end\n      otherwise nop\n    end\n    end\n    'Compare' mrgfile 'x'\n    'locate first excluded'\n    '(line) = cursor'\n    text = 'Or, use the CANCEL command to terminate the merge.'\n    'line_after' line '= msgline (text)'\n    text = 'Then Save and End to update.'\n    'line_after' line '= msgline (text)'\n    text = 'using the MD (make data) Edit line command.'\n    'line_after' line '= msgline (text)'\n    text = 'Update this data by deleting records or converting' ,\n           'the deleted records'\n    'line_after' line '= msgline (text)'\n    'Cursor = 1'\n    Exit 1\n  end\n\n  if options = 'M' then do\n    '(last) = linenum .zlast'\n    hit = 0\n    do i = last to 1 by -1\n      '(data) = line' i\n      Select\n      when pos('<<<<<<<',data) > 0 then do\n        'delete' i\n        hit = 1\n      end\n      when pos('=======',data) > 0 then do\n        'delete' i\n        hit = 1\n      end\n      when pos('>>>>>>>',data) > 0 then do\n        'delete' i\n        hit = 0\n      end\n      when hit = 1 then do\n        'delete' i\n      end\n      otherwise nop\n    end\n    end\n    'End'\n    exit\n  end\n\n  exit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZIGIOSEL": {"ttr": 221, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x02\\x00\\x01 \\x07\\x1f\\x01 \\x17\\x1f\\x04Y\\x01\\xc0\\x01\\xbc\\x00\\x00\\xe2\\xd3\\xc2\\xc4@@@@@@'", "ispf": {"version": "01.07", "flags": 2, "createdate": "2020-03-11T00:00:00", "modifydate": "2020-06-19T04:59:00", "lines": 448, "newlines": 444, "modlines": 0, "user": "SLBD"}, "text": "  /* -------------------  rexx procedure  -------------------- *\n  | Name:      ZIGIOSEL                                        |\n  |                                                            |\n  | Function:  ISPF Dialog REXX subroutine to select an OMVS   |\n  |            file and return it to the caller for use.       |\n  |                                                            |\n  |            Similar to ISPF 3.17 (UDList) but without all   |\n  |            the capabilities. But it is easy to traverse    |\n  |            directories to find the desired file.           |\n  |                                                            |\n  | Syntax:    omvsfile = ZIGIOSEL(prime)                      |\n  |                                                            |\n  |            omvsfile is the rexx variable that will be      |\n  |            the result of calling the ZIGIOSEL routine      |\n  |                                                            |\n  |                - result will be null if canceled  out      |\n  |                                                            |\n  |            prime is optional and if provided is a          |\n  |            starting point for the selection process        |\n  |            - if blank/null then start at users home dir    |\n  |                                                            |\n  | Commands:  CD to change directories                        |\n  |            CANCEL to quit and return a null value          |\n  |            F to find the string in the display             |\n  |            L to locate the string                          |\n  |            MKDIR new directory from current location       |\n  |                                                            |\n  | Line commands:   B - to browse the selected file           |\n  |                  L - to list the selected directory        |\n  |                  I - display info on the file              |\n  |                  S - to select the file or directory       |\n  |                      and return it                         |\n  |                                                            |\n  | Sample usage:    Must be called from a REXX Exec under     |\n  |                  ISPF in the foreground:                   |\n  |                                                            |\n  |                  omvsfile = ZIGIOSEL()                     |\n  |                  omvsfile = ZIGIOSEL('/usr/lpp/')          |\n  |                                                            |\n  | Notes:     For testing may be called directly and the      |\n  |            selection will then be displayed using SAY.     |\n  |                                                            |\n  | Author:    Lionel B. Dyck                                  |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |            06/10/20 - Use SHAREAS=YES                      |\n  |            05/09/20 - Get zigtitle for panel title         |\n  |            02/27/20 - Convert S to L on . and ..           |\n  |            01/24/20 - Improve prompt for mkdir             |\n  |            11/15/19 - Use ZIGI version                     |\n  |            11/12/19 - V1.03                                |\n  |                     - Change ISRZ002 to ISRZ003            |\n  |            10/22/19 - V1.02                                |\n  |                     - Prompt for Permissions for MKDIR     |\n  |            10/18/19 - V1.01                                |\n  |                     - Added MKDIR                          |\n  |            06/12/19 - V1.00                                |\n  |                     - Created from OMVSSEL with permission |\n  |                       of the author (me)                   |\n  | ---------------------------------------------------------- |\n  |    ZIGI - the z/OS ISPF Git Interface                      |\n  |    Copyright (C) 2020 - Henri Kuiper and Lionel Dyck       |\n  |                                                            |\n  |    This program is free software: you can redistribute it  |\n  |    and/or modify it under the terms of the GNU General     |\n  |    Public License as published by the Free Software        |\n  |    Foundation, either version 3 of the License, or (at     |\n  |    your option) any later version.                         |\n  |                                                            |\n  |    This program is distributed in the hope that it will be |\n  |    useful, but WITHOUT ANY WARRANTY; without even the      |\n  |    implied warranty of MERCHANTABILITY or FITNESS FOR A    |\n  |    PARTICULAR PURPOSE.  See the GNU General Public License |\n  |    for more details.                                       |\n  |                                                            |\n  |    You should have received a copy of the GNU General      |\n  |    Public License along with this program.  If not, see    |\n  |    <https://www.gnu.org/licenses/>.                        |\n  * ---------------------------------------------------------- */\n  parse arg prime\n\n  /* ---------------------------------------- *\n  | Check to see if we are under ISPF or not |\n  * ---------------------------------------- */\n  env = sysvar('sysenv')\n  if env = 'FORE' then do\n    if sysvar('sysispf') /= 'ACTIVE'\n    then do\n      say 'Error....'\n      say '%ZIGIOSEL may only be used under ISPF.'\n      say 'Exiting'\n      exit 16\n    end\n  end\n  else do\n    say 'Error....'\n    say '%ZIGIOSEL may only be used under ISPF under TSO.'\n    say 'Exiting'\n    exit 16\n  end\n\n  /* --------------- *\n  | Define defaults |\n  * --------------- */\n  parse value '' with null selections\n  omcsu = 'N'\n  parse source x source x\n  zerrhm   = 'zigih00'\n  zerralrm = 'NO'\n  zerrtp   = 'NOTIFY'\n  bpxenv.1 = '_BPX_SHAREAS=YES'\n  bpxenv.0 = 1\n  Address ISPExec\n  'Control Errors return'\n\n  /* --------------------------------- *\n  | Get version from ZIGI shared pool |\n  * --------------------------------- */\n  'vget (zigtitle ver) shared'\n  if ver = null then ver = 'ZIGI'\n\n  /* ------------------------------------ *\n  | Get the users default Home directory |\n  * ------------------------------------ */\n  call syscalls('ON')\n  address syscall \"getpwnam\" userid() \"pw.\"\n  home_dir = pw.pw_dir'/'\n\n  /* -------------------------------------------- *\n  | convert \\ to / to help out our windows users |\n  * -------------------------------------------- */\n  if prime /= null\n  then prime = translate(prime,'61'x,'e0'x)\n  else prime = home_dir\n\n  /* ----------------------- *\n  | Call the key subroutine |\n  * ----------------------- */\n  ZIGIOSEL = change_odir(prime)\n\n  /* --------------------------------- *\n  | If canceled  out then return null |\n  * --------------------------------- */\n  if zcmd = 'CANCEL' then ZIGIOSEL = null\n\n  call syscalls('OFF')\n\n  /* --------------- *\n  | Exit processing |\n  * --------------- */\nExit:\n  /* ----------------------------------------------- *\n  | Finally return the selected omvs file - or null |\n  * ----------------------------------------------- */\n  if source = 'FUNCTION' then Exit ZIGIOSEL\n  else do\n    if ZIGIOSEL = null then ZIGIOSEL = '*none*'\n    say 'Selection:' ZIGIOSEL\n    exit 0\n  end\n\n  /* ------------------------------ *\n  | Change to a new OMVS Directory |\n  * ------------------------------ */\nChange_ODIR: procedure expose zcmd home_dir omcsu ver bpxenv.\n  parse arg fromdir\n  parse value '' with null selections stack_dir\n  if fromdir = '~' then fromdir = home_dir\n\n  /* ---------------------------------------------------- *\n  | Rebuild the table if L selection or CD command used. |\n  * ---------------------------------------------------- */\nRestart:\n  call do_restart\n  tblrc = 0\n  do forever\n    ocsel = null\n    if ztdsels = 0 then tblrc = 0\n    if tblrc = 0\n    then 'tbdispl' tbl 'panel(zigiotbl)'\n    else if tblrc = 4 then 'tbdispl' tbl\n    tblrc = rc\n    if translate(zcmd) = 'CANCEL' then leave\n    if tblrc > 4 then do\n      if pos('|',stack_dir) = 0 then leave\n      lp = lastpos('|',stack_dir)\n      fromdir = strip(substr(stack_dir,lp+1))\n      stack_dir = left(stack_dir,lp-1)\n      call restart_odir\n    end\n    if ocsel /= null then ocsel = translate(ocsel)\n    zerrsm = null\n    if zcmd /= null then\n    Select\n      When translate(word(zcmd,1)) = 'MKDIR' then do\n        trace 'off'\n        mkdir = word(zcmd,2)\n        call pfshow 'off'           /* make sure pfshow is off */\n        zcmd = null\n        do forever\n          'Addpop row(4) column(12)'\n          answer = 755\n          'Display Panel(zigimdir)'\n          drc = rc\n          'Rempop'\n          call pfshow 'reset'       /* reset pfshow */\n          if drc > 0 then do\n            zerrsm = 'Canceled.'\n            zerrlm = 'MKDIR canceled.'\n            'setmsg msg(isrz003)'\n            leave\n          end\n          cmd = 'mkdir' fromdir'/'mkdir\n          rc = bpxwunix(cmd,,stdout.,stderr.,bpxenv.)\n          cmd = 'chmod' mp fromdir\n          rc = bpxwunix(cmd,,stdout.,stderr.,bpxenv.)\n          zerrsm = null\n          zerrlm = 'Permissions set to:' mp\n          'setmsg msg(isrz003)'\n          signal restart_odir\n        end\n      end\n      When translate(word(zcmd,1)) = 'CD' then do\n        savedir = fromdir\n        fromdir = word(zcmd,2)\n        if left(fromdir,1) = '~' then\n        fromdir = strip(home_dir''substr(fromdir,3))\n        address syscall 'chdir (fromdir)'\n        if retval < 0 then do\n          zerrsm = 'Invalid Dir'\n          zerrlm = fromdir 'is an invalid directory'\n          'setmsg msg(isrz003)'\n          fromdir = savedir\n        end\n        else stack_dir = stack_dir '|' savedir\n        address syscall 'getcwd fromdir'\n        if right(fromdir,1) /= '/' then fromdir = fromdir'/'\n        if zerrsm = null then\n        call restart_odir\n      end\n      When translate(left(zcmd,1)) = 'F' then do\n        fw = translate(word(zcmd,2))\n        'tbtop' tbl\n        do forever\n          'tbskip' tbl\n          if rc > 0 then leave\n          if pos(fw,translate(ofile)) > 0 then do\n            zerrsm = 'Found'\n            zerrlm = fw 'found in the list'\n            'setmsg msg(isrz003)'\n            leave\n          end\n        end\n      end\n      When translate(left(zcmd,1)) = 'L' then do\n        fw = translate(word(zcmd,2))\n        fl = length(fw)\n        'tbtop' tbl\n        do forever\n          'tbskip' tbl\n          if rc > 0 then leave\n          if translate(left(ofile,fl)) = fw then do\n            zerrsm = 'Found'\n            zerrlm = fw 'found in the list'\n            'setmsg msg(isrz003)'\n            leave\n          end\n        end\n      end\n      Otherwise nop\n    end\n\n    if ocsel /= null then do\n      if ocsel = 'S'  then if ofile = '.' | ofile = '..'\n         then ocsel = 'L'\n      Select\n        When ocsel = 'B' then do\n          if otype = '-' then do\n            'control display save'\n            call outtrap 'x.'\n            Address TSO 'OBrowse' fromdir''ofile\n            call outtrap 'off'\n            'control display restore'\n            if x.0 > 0 then do\n              zerrsm = 'Error'\n              zerrlm = x.2\n              'Setmsg msg(isrz003)'\n            end\n          end\n          else do\n            zerrsm = 'Invalid'\n            zerrlm = 'This file may not be browsed.'\n            'Setmsg msg(isrz003)'\n          end\n        end\n        when ocsel = 'I' then call list_info\n        when ocsel = 'L' then call do_dirlist\n        When ocsel = 'S' then do\n          selections = fromdir''ofile\n        end\n        Otherwise do\n           zerrsm = 'Invalid.'\n           zerrlm = ocsel 'is not a valid line selection.'\n           'setmsg msg(isrz003)'\n           end\n      end\n    end\n    if selections /= null then leave\n    if zcmd = 'CANCEL' then leave\n    ocsel = null\n  end\n\n  'tbend' tbl\n  if selections = null then zcmd = 'CANCEL'\n  return selections\n\n  /* ---------------------------------------------- *\n  | Build the list of directories/files to display |\n  * ---------------------------------------------- */\nDo_Restart:\n  do forever\n    cmd = 'ls -la' fromdir\n    rc = bpxwunix(cmd,,stdout.,stderr.,bpxenv.)\n    if stdout.0 = 0 then do\n      zerrsm = 'Invalid Dir'\n      zerrlm = fromdir stderr.1\n      Address ISPExec 'setmsg msg(isrz003)'\n      zcmd = null\n      if cdir_flag = 0 then return fromdir\n      else do\n        if pos('|',stack_dir) = 0 then leave\n        lp = lastpos('|',stack_dir)\n        fromdir = strip(substr(stack_dir,lp+1))\n        stack_dir = left(stack_dir,lp-1)\n      end\n    end\n    else leave\n  end\n  cdir_flag = 1\n\n  /* ------------------------------------------ *\n  | List the OMVS directory. Once a valid file |\n  | is selected then process it.               |\n  * ------------------------------------------ */\n  Address ISPExec\n  tbl = 'OC'random(999)\n\n  'TBCreate' tbl 'Names(ocsel ofile odate operm otype) Nowrite'\n\n  do i = 2 to stdout.0\n    parse value stdout.i with operm x1 oid ogrp ,\n      osize omon ody oyr ofile\n    otype = left(operm,1)\n    opermv = 0\n    offset = 100\n    do ip = 2 to 10\n      op = substr(operm,ip,1)\n      select\n        when op = 'r' then opermv = opermv + (4*offset)\n        when op = 'w' then opermv = opermv + (2*offset)\n        when op = 'x' then opermv = opermv + (1*offset)\n        otherwise nop\n      end\n      if ip = 4 then offset = offset / 10\n      if ip = 7 then offset = offset / 10\n    end\n    odate = omon left(ody+100,2) oyr\n    operm = opermv\n    'tbadd' tbl\n  end\n\n  'tbtop' tbl\n  return\n\n  /* ---------------------------- *\n  | Process into a sub directory |\n  * ---------------------------- */\ndo_dirlist:\n  ocsel = null\n  if ofile = '..' then do\n    stack_dir = stack_dir '|' fromdir\n    fromdir = left(fromdir,length(fromdir)-1)\n    lp = lastpos('/',fromdir)\n    fromdir = left(fromdir,lp)\n    call restart_odir\n    return\n  end\n  else do\n    stack_dir = stack_dir '|' fromdir\n    fromdir = fromdir''ofile'/'\n  end\n  call restart_odir\n  return\n\n  /* ------------------------------ *\n  | List the info on the OMVS File |\n  * ------------------------------ */\nList_Info:\n  cmd = 'ls -la' fromdir''ofile\n  drop stdout. stderr.\n  rc = bpxwunix(cmd,,stdout.,stderr.,bpxenv.)\n  /* allocate a temp file to browse the results */\n  Address TSO\n  cmd_dd = \"C\"random()\n  \"ALLOCATE FILE(\"cmd_dd\") REUSE UNIT(vio) SPACE(1 1)\" ,\n    \"CYL DSORG(PS) RECFM(V B) LRECL(120)\"\n  \"EXECIO * DISKW\" cmd_dd \"(STEM stdout. FINIS)\"\n  Address ISPExec\n  \"LMINIT DATAID(DATAID) DDNAME(\"cmd_dd\")\"\n  'control display save'\n  \"BROWSE DATAID(\"dataid\")\"\n  'control display restore'\n  \"LMFREE DATAID(\"dataid\")\"\n  Address TSO ,\n    \"FREE FILE(\"cmd_dd\")\"\n  Address ISPExec\n  return\n\n  /* --------------------------------------------- *\n  | Restart the OMVS Directory at a new directory |\n  * --------------------------------------------- */\nRestart_Odir:\n  'tbend' tbl\n  call restart\n  return selections\n\n  /* ------------------------------------------------------ *\n  | The pfshow routine will:                               |\n  | 1. check to see the passed option                      |\n  | 2. if Off then it will save the current pfshow setting |\n  |    - save the current setting                          |\n  |    - turn off pfshow                                   |\n  | 3. if the option is Reset then it will                 |\n  |    - test if pfshow was on and turn it back on         |\n  * ------------------------------------------------------ */\npfshow:\n  arg pfkopt\n  if pfkopt = 'RESET' then do\n    if pfkeys = 'ON' then\n    'select pgm(ispopf) parm(FKA,ON)'\n  end\n  if pfkopt = 'OFF' then do\n    'vget (zpfshow)'\n    pfkeys = zpfshow\n    if pfkeys /= 'OFF' then\n    'select pgm(ispopf) parm(FKA,OFF)'\n  end\n  return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZIGIRCSI": {"ttr": 43, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00B\\x00\\x01 \\x07\\x1f\\x01 \\x07\\x1f\\x07&\\x00\\xab\\x00\\xab\\x00\\x00\\xe9\\xc9\\xc7\\xc9\\xf2\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 66, "createdate": "2020-03-11T00:00:00", "modifydate": "2020-03-11T07:26:00", "lines": 171, "newlines": 171, "modlines": 0, "user": "ZIGI26"}, "text": "/* REXX */\n /********************************************************************/\n /*                                                                  */\n /*       NAME: REXXCSI   (WAS IGGCSIRX)                             */\n /*DESCRIPTION: THIS REXX EXEC IS USED TO CALL THE CATALOG           */\n /*             SEARCH INTERFACE.                                    */\n /*      INPUT: FILTER KEY                                           */\n /*     OUTPUT: DSNTYPE  DSNAME  VOLSER                              */\n /*                                                                  */\n /* MODIFIED BY LBD TO REQUIRE A HLQ ON ENTRY AND RETURN JUST        */\n /*          THE DSNAMES                                             */\n /*                                                                  */\n /* CHANGE ACTIVITY:                                                 */\n /* $01=OW39593,HDZ11F0,990904,SJPLMET: BUMP WORK AREA TO        @01A*/\n /*              64,000 BYTES TO HANDLE CASES WHERE THE RETURN   @01A*/\n /*              DATA FOR A GDG BASE CANNOT FIT IN A WORKAREA    @01A*/\n /*              EVEN ON A RESUME.  THE EXAMPLE IS CHANGED TO    @01A*/\n /*              STOP WHEN THIS HAPPENS AND ISSUE A MESSAGE.     @01A*/\n /* $01=OW46614,HDZ11G0,010130,SJPLMET: CORRECT FAILURE TO       @02A*/\n /*             DISPLAY ALL INFO WHEN THE FILTER KEY CONTAINS A  @02A*/\n /*             GENERIC IN THE HLQ.                              @02A*/\n /*                                                                  */\n /********************************************************************/\n ARG KEY\n /********************************************************************/\n /*                                                                  */\n /*  INITIALIZE THE PARM LIST                                        */\n /*                                                                  */\n /********************************************************************/\nMODRSNRC = SUBSTR(' ',1,4)          /*   CLEAR MODULE/RETURN/REASON  */\nCSIFILTK = SUBSTR(KEY,1,44)         /*   MOVE FILTER KEY INTO LIST   */\nCSICATNM = SUBSTR(' ',1,44)         /*   CLEAR CATALOG NAME          */\nCSIRESNM = SUBSTR(' ',1,44)         /*   CLEAR RESUME NAME           */\nCSIDTYPS = SUBSTR(' ',1,16)         /*   CLEAR ENTRY TYPES           */\nCSICLDI  = SUBSTR('Y',1,1)          /*   INDICATE DATA AND INDEX     */\nCSIRESUM = SUBSTR(' ',1,1)          /*   CLEAR RESUME FLAG           */\nCSIS1CAT = SUBSTR(' ',1,1)          /*   INDICATE SEARCH > 1 CATALOGS*/\nCSIRESRV = SUBSTR(' ',1,1)          /*   CLEAR RESERVE CHARACTER     */\nCSINUMEN = '0001'X                  /*   INIT NUMBER OF FIELDS       */\nCSIFLD1    = SUBSTR('VOLSER',1,8)   /*   INIT FIELD 1 FOR VOLSERS    */\n /********************************************************************/\n /*                                                                  */\n /*  BUILD THE SELECTION CRITERIA FIELDS PART OF PARAMETER LIST      */\n /*                                                                  */\n /********************************************************************/\nCSIOPTS  = CSICLDI || CSIRESUM || CSIS1CAT || CSIRESRV\nCSIFIELD = CSIFILTK || CSICATNM || CSIRESNM || CSIDTYPS || CSIOPTS\nCSIFIELD = CSIFIELD || CSINUMEN || CSIFLD1\n\n /********************************************************************/\n /*                                                                  */\n /*  INITIALIZE AND BUILD WORK ARE OUTPUT PART OF PARAMETER LIST     */\n /*                                                                  */\n /********************************************************************/\nWORKLEN = 64000                                                /*@01C*/\nDWORK = '0000FA00'X || COPIES('00'X,WORKLEN-4)                 /*@01C*/\n\n /********************************************************************/\n /*                                                                  */\n /*  INITIALIZE WORK VARIABLES                                       */\n /*                                                                  */\n /********************************************************************/\nRESUME = 'Y'\nPREVNAME = ''                     /* NO PREVIOUS NAME            @01A*/\nCATNAMET = SUBSTR(' ',1,44)\nDNAMET = SUBSTR(' ',1,44)\n\n /********************************************************************/\n /*                                                                  */\n /*  SET UP LOOP FOR RESUME (IF A RESUME IS NCESSARY)                */\n /*                                                                  */\n /********************************************************************/\nDO WHILE RESUME = 'Y'\n\n /********************************************************************/\n /*                                                                  */\n /*  ISSUE LINK TO CATALOG GENERIC FILTER INTERFACE                  */\n /*                                                                  */\n /********************************************************************/\n ADDRESS LINKPGM 'IGGCSI00  MODRSNRC  CSIFIELD  DWORK'\n\n RESUME = SUBSTR(CSIFIELD,150,1)    /* GET RESUME FLAG FOR NEXT LOOP */\n USEDLEN = C2D(SUBSTR(DWORK,9,4))   /* GET AMOUNT OF WORK AREA USED  */\n POS1=15                            /* STARTING POSITION             */\n\n /********************************************************************/\n /*                                                                  */\n /*  PROCESS DATA RETURNED IN WORK AREA                              */\n /*                                                                  */\n /********************************************************************/\n DO WHILE POS1 < USEDLEN            /* DO UNTIL ALL DATA IS PROCESSED*/\n   IF SUBSTR(DWORK,POS1+1,1) = '0'  /* IF CATALOG, EXTRACT CATALOG   */\n    THEN DO                         /* NAME FOR LATER PRINTING   @02C*/\n         CATNAME=SUBSTR(DWORK,POS1+2,44)\n         POS1 = POS1 + 50\n         END\n  IF POS1 < USEDLEN THEN             /* IF STILL MORE DATA       @02A*/\n   DO                                /* CONTINUE WITH NEXT ENTRY @02A*/\n    DNAME = SUBSTR(DWORK,POS1+2,44)  /* GET ENTRY NAME               */\n\n /********************************************************************/\n /*                                                                  */\n /*  ASSIGN ENTRY TYPE NAME                                          */\n /*                                                                  */\n /********************************************************************/\n   IF SUBSTR(DWORK,POS1+1,1) = 'C' THEN DTYPE = 'CLUSTER '\n    ELSE\n      IF SUBSTR(DWORK,POS1+1,1) = 'D' THEN DTYPE = 'DATA    '\n     ELSE\n      IF SUBSTR(DWORK,POS1+1,1) = 'I' THEN DTYPE = 'INDEX   '\n     ELSE\n      IF SUBSTR(DWORK,POS1+1,1) = 'A' THEN DTYPE = 'NONVSAM '\n     ELSE\n      IF SUBSTR(DWORK,POS1+1,1) = 'H' THEN DTYPE = 'GDS     '\n     ELSE\n      IF SUBSTR(DWORK,POS1+1,1) = 'B' THEN DTYPE = 'GDG     '\n     ELSE\n      IF SUBSTR(DWORK,POS1+1,1) = 'R' THEN DTYPE = 'PATH    '\n     ELSE\n      IF SUBSTR(DWORK,POS1+1,1) = 'G' THEN DTYPE = 'AIX     '\n     ELSE\n      IF SUBSTR(DWORK,POS1+1,1) = 'X' THEN DTYPE = 'ALIAS   '\n     ELSE\n      IF SUBSTR(DWORK,POS1+1,1) = 'U' THEN DTYPE = 'UCAT    '\n     ELSE\n       IF SUBSTR(DWORK,POS1+1,1) = 'L' THEN DTYPE = 'ATLLIB  ' /*@02A*/\n      ELSE                                                     /*@02A*/\n       IF SUBSTR(DWORK,POS1+1,1) = 'W' THEN DTYPE = 'ATLVOL  ' /*@02A*/\n      ELSE ,    /*  NO ENTRIES IN THE CATALOG - LOOK AT    */  /*@02A*/\n        ITERATE   /*  NEXT CATALOG NAME - GENERIC HLQ ONLY */  /*@02A*/\n /********************************************************************/\n /*                                                                  */\n /*  HAVE NAME AND TYPE, GET VOLSER INFO.  IF WE FOUND A VALID TYPE  */\n /*  FOR THIS CATALOG, NOW PRINT THE CATALOG NAME (FIRST ENTRY ONLY).*/\n /*                                                                  */\n /********************************************************************/\n     IF CATNAME \u00ac= CATNAMET THEN /* IF RESUME NAME MAY ALREADY   @02C*/\n      DO                         /*    BE PRINTED                    */\n       SAY 'CATALOG ' CATNAME    /* IF NOT, PRINT IT             @02C*/\n       SAY ' '                                                 /*@02C*/\n       CATNAMET = CATNAME                                      /*@02C*/\n      END                                                      /*@02C*/\n    POS1 = POS1 + 46\n    NUMVOL = C2D(SUBSTR(DWORK,POS1+4,2))/6 /* HOW MANY VOLSERS ?     */\n                                    /*                               */\n    POS2 = POS1+6                   /* POSITION ON DATA              */\n    DO I=1 TO 3                     /* ONLY CLEAR 3 VOLSER FIELDS    */\n      VOLSER.I = SUBSTR(' ',1,6)\n    END\n    DO I = 1 TO NUMVOL              /* MOVE VOLSERS TO OUTPUT FIELDS */\n      VOLSER.I = SUBSTR(DWORK,POS2,6)\n      POS2 = POS2 + 6\n    END\n     SAY COPIES(' ',8) DTYPE DNAME VOLSER.1 VOLSER.2 VOLSER.3\n /********************************************************************/\n /*                                                                  */\n /*   GET POSITION OF NEXT ENTRY                                     */\n /*                                                                  */\n /********************************************************************/\n    POS1 = POS1 + C2D(SUBSTR(DWORK,POS1,2))\n  END                               /* OF ROOM LEFT IN WORKAREA  @02A*/\n END\n IF RESUME = 'Y' &,                 /* IF WE'VE TRIED THIS ENTRY @01A*/\n  PREVNAME = DNAME THEN             /* TWICE, WE'VE GOT TO QUIT  @01A*/\n   DO                                                          /*@01A*/\n     SAY STRIP(DNAME) 'CANNOT BE PROCESSED WITH THE WORK AREA SIZE ',\n         'PROVIDED - YOU MUST INCREASE THE WORK AREA AND RETRY'\n     RETURN                                                    /*@01A*/\n   END                                                         /*@01A*/\n PREVNAME = DNAME                   /* SAVE FOR NEXT ITERATION   @01A*/\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ZIGIREFD": {"ttr": 347, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01 \\x00\"\\x01 \\x07\\x7f\\x01 #\\x8f\\x13F\\x00\\xd0\\x00l\\x00\\x00\\xe9\\xc9\\xc7\\xc9\\xf3\\xf0\\xf1@@@'", "ispf": {"version": "01.32", "flags": 0, "createdate": "2020-03-17T00:00:00", "modifydate": "2020-08-25T13:46:22", "lines": 208, "newlines": 108, "modlines": 0, "user": "ZIGI301"}, "text": "  /* --------------------  rexx procedure  -------------------- *\n  | Name:      zigirefd                                        |\n  |                                                            |\n  | Function:  ZIGI code to check/update the last reference    |\n  |            date for a z/OS dataset. Used to determine if   |\n  |            the dataset needs to be checked for updates.    |\n  |                                                            |\n  | Syntax:    check = zigirefd(zigidir pdshlq qualignr option)|\n  |                                                            |\n  |            parameters:                                     |\n  |            zigidir - OMVS directory for the repository     |\n  |            pdshlq  - hlq for z/OS datasets                 |\n  |            qualignr- # of hlq quals to ignore              |\n  |            option  - C to check                            |\n  |                      U to update                           |\n  |                      D to delete                           |\n  |                                                            |\n  |            check will be a string of datasets that have    |\n  |            changed since the last ZIGI access.             |\n  |                                                            |\n  |            A value of * will indicate to check ALL files.  |\n  |                                                            |\n  | Notes:     A file will be created in the users home dir    |\n  |            under a .zigirefd directory with the dataset    |\n  |            name and last access information.               |\n  |                                                            |\n  | Author:    Lionel B. Dyck                                  |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |            08/25/20 LBD - Fix temp dsn if no tso prefix    |\n  |            07/14/20 LBD - Change .zigi to .zigirefd        |\n  |            06/10/20 LBD - Use SHAREAS=YES                  |\n  |            05/08/20 HBK - Fix bug if dir is not in home    |\n  |                     LBD - Add D (delete) option            |\n  |            03/18/20 LBD - Refinement                       |\n  |            03/17/20 LBD - Creation                         |\n  | ---------------------------------------------------------- |\n  |    ZIGI - the z/OS ISPF Git Interface                      |\n  |    Copyright (C) 2020 - Henri Kuiper and Lionel Dyck       |\n  |                                                            |\n  |    This program is free software: you can redistribute it  |\n  |    and/or modify it under the terms of the GNU General     |\n  |    Public License as published by the Free Software        |\n  |    Foundation, either version 3 of the License, or (at     |\n  |    your option) any later version.                         |\n  |                                                            |\n  |    This program is distributed in the hope that it will be |\n  |    useful, but WITHOUT ANY WARRANTY; without even the      |\n  |    implied warranty of MERCHANTABILITY or FITNESS FOR A    |\n  |    PARTICULAR PURPOSE.  See the GNU General Public License |\n  |    for more details.                                       |\n  |                                                            |\n  |    You should have received a copy of the GNU General      |\n  |    Public License along with this program.  If not, see    |\n  |    <https://www.gnu.org/licenses/>.                        |\n  * ---------------------------------------------------------- */\n\n  parse arg dir hlq qualignr opt\n\n  parse value '' with null check outfiles. last_check\n  outc = 0\n\n  parse value date('j') with 1 yy 3 ddd\n  today = '20'yy''ddd\n\n  if left(dir,1) = \"'\" then dir = strip(dir,'B',\"'\")\n  if left(hlq,1) = \"'\" then hlq = strip(hlq,'B',\"'\")\n  if left(opt,1) = \"'\" then opt = strip(opt,'B',\"'\")\n\n  if qualignr > 0 then do\n    hlq = translate(hlq,' ',\".\")\n    hlq = subword(hlq,1,qualignr)\n    hlq = translate(hlq,'.',\" \")\n  end\n\n  bpxenv.1 = '_BPX_SHAREAS=YES'\n  bpxenv.0 = 1\n\n  /* ---------------------------- *\n  | Get the users home directory |\n  * ---------------------------- */\n  Address syscall\n  'getcwd homedir'\n\n  /* ---------------------------------------------------------- *\n  | Get the repositories subdirectory by removing the users    |\n  | home directory from it and use the entire thing if the pwd |\n  | is not part of it.  Remove trailing /.                     |\n  * ---------------------------------------------------------- */\n  homedir = homedir'/'\n  dl = length(homedir)\n  if left(dir,dl) = homedir\n  then wdir = substr(dir,dl+1)\n  else wdir = dir\n  if right(wdir,1) = '/' then wdir = strip(wdir,'T','/')\n\n  /* ------------------------------ *\n  | Translate the directory / to _ |\n  * ------------------------------ */\n  refdir = translate(wdir,'_','/')\n  ref_file = homedir'.zigirefd/'refdir\n\n  'lstat' homedir'.zigirefd/' stem.\n  if stem.0 = 0 then do\n    'mkdir' homedir'.zigirefd/ 755'\n  end\n\n  Address TSO\n\n  opt = translate(opt)\n\n  Select\n  When opt = 'C' then do\n    cmd = 'cat' ref_file\n    x = bpxwunix(cmd,,so.,se.,bpxenv.)\n    if x > 0 then return '*'\n    last_check = strip(substr(so.i,2))\n    do i = 1 to so.0\n      parse value so.i with dsn date .\n      files.dsn = date\n    end\n    call check_files\n    if check = null then check = '*'\n  end\n  When opt = 'D' then do\n    cmd = 'rm' ref_file\n    x = bpxwunix(cmd,,so.,se.,bpxenv.)\n    check = 0\n    end\n  otherwise call update\n  end\n\n  return check\n\nupdate:\n  call check_files\n  outfiles.0 = outc\n  if outc = 0 then return check\n  fdd = 'ZG'time('s')\n  if sysvar('syspref') = null\n     then pref = userid()'.'\n     else pref = sysvar('syspref')'.'\n  fdsn = \"'\"pref\"\"fdd\"'\"\n  'alloc f('fdd') ds('fdsn') new spa(1,1) tr recfm(f b)' ,\n    'lrecl(80) blksize(32720)'\n  'execio * diskw' fdd '(finis stem outfiles.'\n  'free f('fdd')'\n  call outtrap 'x.'\n  'oput' fdsn \"'\"ref_file\"'\" 'text'\n  'delete' fdsn\n  call outtrap 'off'\n  return outfiles.0\n\nCheck_files:\n  address syscall ,\n    'readdir' dir f.\n  do i = 1 to f.0\n    file = f.i\n    if left(file,1) = '.' then iterate\n    if dsnvalid(\"'\"hlq\".\"file\"'\") /= 'OK' then iterate\n    x = listdsi(\"'\"hlq\".\"file\"'\")\n    if x > 0 then iterate\n    file = sysdsname\n    parse value sysrefdate with yyyy'/'ddd\n    sysrefdate = yyyy''ddd\n    if opt = 'C' then\n    Select\n      When sysrefdate = today then check = check sysdsname\n      when datatype(files.file) /= 'NUM' then check = check sysdsname\n      When sysrefdate > files.file then check = check sysdsname\n      otherwise nop\n    end\n    else do\n      outc = outc + 1\n      outfiles.outc = sysdsname sysrefdate\n    end\n  end\n  return\n\ndsnvalid: Procedure Expose null\n  /* Tests for a 'potentially valid' z/OS datasetname */\n  parse arg val_dsn\n  if left(val_dsn,1) = '.' then return 'NO'\n  if strip(val_dsn) = null then return 'NO'\n  val_dsn = strip(val_dsn,'B',\"'\")\n  upp = TRANSLATE(val_dsn,\".ABCDEFGHIJKLMNOPQRSTUVWXYZ\",,\n    \".abcdefghijklmnopqrstuvwxyz\")\n  tdsn = translate(val_dsn,' ','.')\n  retval = 'OK'   /* asssume good */\n  do i = 1 to words(tdsn)\n    w = word(tdsn,i)\n    if length(w) > 8 then retval = 'NO'\n    if pos(left(w,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ$#@') = 0 then retval = 'NO'\n    w = translate(w,left(' ',39,' '), ,\n      'ABCDEFGHIJKLMNOPQRSTUVWXYZ-$#@0123456789')\n    w = strip(w)\n    if w /= null then retval = 'NO'\n  end\n  if retval /= 'NO' then\n  if upp = val_dsn then do\n    smsg = msg()\n    call msg 'OFF'\n    if sysdsn(val_dsn) = \"OK\" | sysdsn(val_dsn) = \"DATASET NOT FOUND\"\n    then retval = 'OK'\n    else retval = \"NO\"\n    call msg smsg\n  end\n  return retval\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZIGISTAT": {"ttr": 351, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01!\\x00\\x02\\x01 \\x06o\\x01 $\\x0f\\x05\\x12\\x01\\xdb\\x01\\xad\\x00\\x00\\xe9\\xc9\\xc7\\xc9\\xf3\\xf0\\xf1@@@'", "ispf": {"version": "01.33", "flags": 0, "createdate": "2020-03-06T00:00:00", "modifydate": "2020-08-27T05:12:02", "lines": 475, "newlines": 429, "modlines": 0, "user": "ZIGI301"}, "text": "  /* --------------------  rexx procedure  -------------------- *\n  | Name:      zigistat                                        |\n  |                                                            |\n  | Function:  Collect or Compare the ISPF Stats for all       |\n  |            members in a PDS                                |\n  |                                                            |\n  | Syntax:    x=zigistat(dsname filepath option)              |\n  |                                                            |\n  |            dsname is the z/OS dataset name to work with    |\n  |                                                            |\n  |            filepath is the OMVS file where the stats are   |\n  |            stored and consists of:                         |\n  |                localdir/repodir/.ZIGI/filename             |\n  |                filename is the OMVS file that represents   |\n  |                the z/OS PDS dataset name                   |\n  |                                                            |\n  | Options:   C - compare stats                               |\n  |            S - save stats                                  |\n  |            U - update stats to those saved                 |\n  |                used when creating/refreshing datasets      |\n  |                                                            |\n  | Vars:      statmems ispf variable for selective update     |\n  |                                                            |\n  | Usage                                                      |\n  |   Notes: Subroutine of ZIGI                                |\n  |          Returns string of members changed                 |\n  |                                                            |\n  | Dependencies:                                              |\n  |          ISPF services                                     |\n  |                                                            |\n  | Return:                                                    |\n  |          0 - stats saved or stats applied                  |\n  |          8 - no dsname provided                            |\n  |         12 - no filepath provided                          |\n  |         16 - no option provided                            |\n  |         20 - stats file in /.zigi missing                  |\n  |     string - string of members with different stats        |\n  |                                                            |\n  | Author:    Lionel B. Dyck                                  |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |            08/27/20 LBD - Enhance stat compare for future  |\n  |            08/14/20 LBD - Don't update if readonly repo    |\n  |            06/19/20 LBD - Ignore LMOD aliases as the main  |\n  |                           lmod will have them included     |\n  |            06/16/20 LBD - Use DEFRUID if it exists         |\n  |            06/09/20 LBD - Bypass stat update for lmod      |\n  |            05/08/20 LBD - Support Load Libraries           |\n  |            01/08/20 LBD - Selecitve stat update if statmems|\n  |            01/05/20 LBD - Correct special chars in filepath|\n  |                           using usssafe routine            |\n  |            11/22/19 LBD - If a member has no stats - add   |\n  |            11/18/19 LBD - Many fixes and add Debug         |\n  |            11/15/19 LBD - Creation                         |\n  |                                                            |\n  | ---------------------------------------------------------- |\n  |    ZIGI - the z/OS ISPF Git Interface                      |\n  |    Copyright (C) 2020 - Henri Kuiper and Lionel Dyck       |\n  |                                                            |\n  |    This program is free software: you can redistribute it  |\n  |    and/or modify it under the terms of the GNU General     |\n  |    Public License as published by the Free Software        |\n  |    Foundation, either version 3 of the License, or (at     |\n  |    your option) any later version.                         |\n  |                                                            |\n  |    This program is distributed in the hope that it will be |\n  |    useful, but WITHOUT ANY WARRANTY; without even the      |\n  |    implied warranty of MERCHANTABILITY or FITNESS FOR A    |\n  |    PARTICULAR PURPOSE.  See the GNU General Public License |\n  |    for more details.                                       |\n  |                                                            |\n  |    You should have received a copy of the GNU General      |\n  |    Public License along with this program.  If not, see    |\n  |    <https://www.gnu.org/licenses/>.                        |\n  * ---------------------------------------------------------- */\nzigistat:\n\n  /* --------------- *\n  | Define defaults |\n  * --------------- */\n  parse value '' with null string m. rx allmems\n  zdd = 'ZS'time('s')\n\n  /* --------------------------------- *\n  | Check for parms and return if not |\n  * --------------------------------- */\n  parse arg dsn filepath opt\n  if dsn      = null then return 8\n  if filepath = null then return 12\n  if opt      = null then return 16\n  opt         = translate(opt)   /* make upper case */\n\n  /* ---------------------------------------- *\n  | Check for ZIGIDEBG DD for debug purposes |\n  * ---------------------------------------- */\n  x = listdsi('ZIGIDEBG' 'FILE')\n  if x > 0 then if sysreason = 3\n  then zigidebg = 1\n  else zigidebg = 0\n\n  Address ISPExec\n  'vget (debugfil defruid readonly)'\n\n  x = debug('start of zigistat with option:' opt)\n\n  /* --------------------------------------- *\n  | If option C or U then read in the stats |\n  | - check if stats member exists rc=16    |\n  | - read into stem stats.                 |\n  * --------------------------------------- */\n  if pos(opt,'C U') > 0 then do\n    x = debug('Checking stats file' filepath)\n    x = check_stats_file(filepath)\n    rc = x\n    x = debug('Checking stats file complete')\n    if rc > 0 then return x\n    x = debug('Reading the ISPF stats file')\n    drop stats.\n    cmd = 'cat' usssafe(filepath)\n    x = bpxwunix(cmd,,stats.,se.)\n    do i = 1 to stats.0\n      stats.i = translate(stats.i,' ','0D'x)\n    end\n    x = debug('Reading complete')\n  end\n\n  /* ------------------ *\n  * Define ISPF Dataid *\n  * ------------------ */\n  \"LMINIT DATAID(STATUS) DATASET(\"dsn\")\"\n  \"LMOPEN DATAID(\"STATUS\") OPTION(INPUT)\"\n\n /* ---------------------------------- *\n  | Get dataset recfm (check for lmod) |\n  * ---------------------------------- */\n  x = listdsi(dsn)\n\n  /* ------------ *\n  * Set defaults *\n  * ------------ */\n  x = debug('Collecting stats for all members for:' dsn)\n  parse value null with member mem. ,\n    ZLCDATE ZLMDATE ZLVERS ZLMOD ZLMTIME ZLCNORC,\n    ZLINORC ZLMNORC ZLUSER ,\n    zlcnorce zlinorce zlmnorce ,\n    zlsize zlamod zlrmode zlattr zlalias zlssi\n  mem.0  = 0\n  if defruid = null\n  then newuid = sysvar('sysuid')\n  else newuid = defruid\n\n  /* ----------------------- *\n  * Now process all members *\n  * ----------------------- */\n  do forever\n    \"LMMLIST Dataid(\"status\") OPTION(LIST) MEMBER(MEMBER)\" ,\n      \"STATS(YES)\"\n    /* --------------------------------- *\n    * If RC 4 or more leave the do loop *\n    * --------------------------------- */\n    if rc > 3 then leave\n    /* -------------------------------- *\n    | Check if no stats then add them. |\n    * -------------------------------- */\n    if sysrecfm /= 'U' then\n    if zlcdate = null then\n    if readonly = 0 then do\n      'LMMSTATS DATAID('status') Member('member') user('newuid')'\n      \"LMMFind DATAID(\"status\") Member(\"member\") STATS(YES)\"\n    end\n    /* ------------------------------ *\n    * Add each member info to a stem *\n    * ------------------------------ */\n    c = mem.0 + 1\n    if sysrecfm /= 'U'\n    then mem.c = strip(member ,\n      ZLCDATE  ZLMDATE  ZLVERS ZLMOD ZLMTIME ZLCNORC ,\n      ZLINORC ZLMNORC ZLUSER ,\n      zlcnorce zlinorce zlmnorce)\n    else if strip(zlalias) = null then do\n      mem.c = strip(member ,\n        zlsize zlamod zlrmode zlattr zlalias zlssi)\n    end\n    else c = c - 1\n    mem.0 = c\n    if strip(zlalias) = null then\n    if opt = 'C' then allmems = allmems member\n  end\n\n  /* ------------------------- *\n  * Close and Free the Dataid *\n  * ------------------------- */\n  \"LMClose Dataid(\"status\")\"\n  \"LMFree  Dataid(\"status\")\"\n  x = debug('Stat collection complete.')\n\n  /* ----------------------------------------------- *\n  | Process the data based on the provided options: |\n  |                                                 |\n  |    C - compare stats                            |\n  |    S - save stats                               |\n  |    U - update stats to those saved              |\n  |        used when creating/refreshing datasets   |\n  * ----------------------------------------------- */\n  Select\n    /* ----------------------------------------------------- *\n    | Save all stats for all members in the active dataset. |\n    | - data will be saved to /.zigi/filename               |\n    * ----------------------------------------------------- */\n    When opt = 'S' then do\n      x = debug('Saving stats begins to:' filepath)\n      x = bpxwunix('rm' usssafe(filepath),,so.,se.)\n      call write_stats\n      x = debug('Saving stats completed.')\n      return 0\n    end\n    /* ---------------------------------------------------------- *\n    | Update ISPF Stats:                                         |\n    |  - all members in the ZIGI stats member will have their    |\n    |    ispf stats updated to reflect the saved stats           |\n    |  - Use statmems ispf var for selective stat updates        |\n    |  - new members will not be updated as we don't know about  |\n    |   them                                                     |\n    |  - members with no stats will have stats added if they are |\n    |    in the saved stats member                               |\n    * ---------------------------------------------------------- */\n    When opt = 'U' then do\n      if readonly = 1 then return 0\n      if sysrecfm /= 'U' then do\n        x = debug('Performing ISPF Stats file update for:' dsn)\n        'vget (statmems)'\n        if statmems /= null then do\n          x = debug('Update Members:' statmems)\n        end\n        \"LMINIT DATAID(zstats) DATASET(\"dsn\")\"\n        \"LMOPEN DATAID(\"zstats\") OPTION(INPUT)\"\n        do i = 1 to stats.0\n          parse value stats.i with member ZLCDATE ZLMDATE ZLVERS ZLMOD ,\n            ZLMTIME ZLCNORC ZLINORC ZLMNORC ZLUSER ZLCNORCE ,\n            ZLINORCE ZLMNORCE .\n          if statmems /= null then\n          if wordpos(member,statmems) = 0 then iterate\n          if zlcdate = null then ,\n            'LMMSTATS DATAID('zstats') Member('member') user('sysvar(sysuid)')'\n          else ,\n            'LMMSTATS DATAID('zstats') MEMBER('member') VERSION('zlvers')' ,\n            'MODLEVEL('zlmod') CREATED('zlcdate') MODDATE('zlmdate')' ,\n            'MODTIME('zlmtime') INITSIZE('zlinorc')' ,\n            'MODRECS('zlmnorc') USER('zluser')'\n        end\n        \"LMClose Dataid(\"zstats\")\"\n        \"LMFree  Dataid(\"zstats\")\"\n        x = debug('ISPF Stats file update complete.')\n        return 0\n      end\n    end\n    /* ----------------------------------------------------------- *\n    | Compare ISPF stats.                                         |\n    |                                                             |\n    | Comparison will be from the active datasets ISPF stats with |\n    | the saved stats found in ISPF stats file in /.zigi          |\n    |                                                             |\n    | If a member is in the active but not in the saved list then |\n    | it will be added to the returned string.                    |\n    |                                                             |\n    | If a members saved stats do not match the active stats then |\n    | it will be added to the returned string.                    |\n    * ----------------------------------------------------------- */\n    When opt = 'C' then do\n      x = debug('ISPF Stats comparison starting.')\n      /* 1st setup the saved stem for easy comparison */\n      do i = 1 to stats.0\n        parse value stats.i with savedmem data\n        m.savedmem = strip(data)\n      end\n      /* now compare active to saved */\n      do i = 1 to mem.0\n        parse value mem.i with actmem data\n        if m.actmem = null then string = string actmem\n        else do\n          if strip(data) /= null then do\n            parse value data with cdate mdate ver mod mtime nc ic mc usr ,\n              nce ice mce\n            data = strip(cdate mdate ver+0 mod+0 mtime ,\n              nc ic mc usr nce ice mce)\n          end\n          if strip(m.actmem) /= null then do\n            parse value m.actmem with cdate mdate ver mod mtime nc ic mc usr ,\n              nce ice mce\n            mdata = strip(cdate mdate ver+0 mod+0 mtime ,\n              nc ic mc usr nce ice mce)\n          end\n          else mdata = null\n          if data /= mdata then string = string actmem\n        end\n      end\n      'vput (allmems)'\n      x = debug('ISPF Stats comparison complete:' string)\n      return string\n    end\n    Otherwise nop  /* should never get here */\n  end\n\n  /* -------------------------------------------- *\n  | Check to see if the provided filepath exists |\n  | rc 0 it does                                 |\n  | rc 20 it does not                            |\n  * -------------------------------------------- */\nCheck_Stats_File:\n  save_address = address()\n  address syscall 'lstat' filepath 'file.'\n  if file.0 = 0 then do\n    ADDRESS value(save_address)\n    return 20\n  end\n  else return 0\n\n  /* ----------------------------------------------------- *\n  | Get the users current OMVS enviornment for use in the |\n  | bpxwunix commands. Being selective.                   |\n  * ----------------------------------------------------- */\nGETENV:\n  cmd  = docmdx('env')\n  rc = bpxwunix(cmd,,so.,se.)\n  envc = 0\n  do ci = 1 to so.0\n    if left(so.ci,3) = 'GIT' then call add_env so.ci\n    if left(so.ci,4) = 'HOME' then call add_env so.ci\n    if left(so.ci,4) = 'PATH' then call add_env so.ci\n    if left(so.ci,4) = 'MANP' then call add_env so.ci\n    if left(so.ci,4) = 'LIBP' then call add_env so.ci\n    if left(so.ci,3) = 'PWD' then call add_env so.ci\n  end\n  call add_env '_BPX_SHAREAS=YES'\n  call add_env '_BPX_SPAWN_SCRIPT=YES'\n  env.0 = envc\n  drop so. se.\n  return\n\n  /* -------------------- *\n  | Add info to env stem |\n  * -------------------- */\nadd_env:\n  parse arg env_val\n  envc = envc + 1\n  env.envc = env_val\n  return\n\ndocmd:\n  parse arg cmd\n  drop so. se.\n  x = bpxwunix(cmd,,so.,se.,env.)\n  return x\n\ndocmdx:\n  /* quircky thing, we need to export HOME as we are\n  not running a login shell via bpxwunix */\n  parse arg cmd\n  drop so. se.\n  if rx = null then do\n    rx = 'export HOME='home' && . /etc/profile > /dev/null 2>&1 && '\n    c = \"\u00dd\u00dd -f \"home\"/.profile \u00a8\u00a8 && echo f\"\n    x = bpxwunix(c,,o.,e.)\n    if o.0 = 1 & o.1 = \"f\" then do\n      rx = rx '. 'home'/.profile > /dev/null 2>&1 && '\n    end\n  end\n  r = rx cmd\n  return r\n\n  /* ----------------------------- *\n  | Write out the ISPF Stats file |\n  * ----------------------------- */\nWrite_Stats:\n  call syscalls 'ON'\n  address syscall\n  /* Fill dsn file with the comments */\n  /* look like the 'open' command does the escaping for us... */\n  fpok = strreplace(filepath,'\\$', '$')\n  'open' fpok O_rdwr+O_creat+O_trunc 660\n  if retval = -1 then do\n    Address ISPExec\n    zs1 = \"Something bad when creating\"\n    zs2 = filepath\n    zs4 = 'Press F3 to close this popup and exit.'\n    parse value '' with zs3\n    call do_popup4\n    'close' fd\n    call syscalls 'OFF'\n    return\n  end\n  fd = retval\n  do is = 1 to mem.0\n    call write_fd mem.is\n  end\n  'close' fd\n  call syscalls 'OFF'\n  Address ISPExec\n  return\n\n  /* ----------------------------------- *\n  | Routine to write out a line of data |\n  * ----------------------------------- */\nWrite_FD:\n  parse arg string\n  string = string || ESC_R || ESC_N\n  'write' fd 'string' length(string)\n  return\n\n  /* ----------------------------------- *\n  | Issue popup - turn off pfshow if on |\n  * ----------------------------------- */\nDo_Popup4:\n  call pfshow 'off'           /* make sure pfshow is off */\n  'Addpop row(4) column(6)'\n  'Display Panel(zigipop4)'\n  'Rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  return\n\n  /* -------------------------------- *\n  | routine to turn off pfshow if on |\n  * -------------------------------- */\npfshow:\n  if zpfshow = 'OFF' then return\n  arg pfkopt\n  if pfkopt = 'RESET' then do\n    if pfkeys = 'ON' then\n    'select pgm(ispopf) parm(FKA,ON)'\n  end\n  if pfkopt = 'OFF' then do\n    'vget (zpfshow)'\n    pfkeys = zpfshow\n    if pfkeys /= 'OFF' then\n    'select pgm(ispopf) parm(FKA,OFF)'\n  end\n  return\n\ndebug:\n  if zigidebg  = 1 then do\n    parse arg msg\n    msg = Date() Time()' : 'msg\n    c = 'echo \"'msg'\" >>' debugfil\n    x = bpxwunix(c,,dso.,dse.)\n  end\n  return 0\n\n  /* ---------------------------------- *\n  | Make the z/OS dsname safe for OMVS |\n  * ---------------------------------- */\nusssafe: procedure\n  parse arg dsn\n  if pos('$',dsn) = 0 then return dsn\n  /* Let's not usssafe it twice :) */\n  if pos('\\$',dsn) > 0 then return dsn\n  dsn = strreplace(dsn, '$', '\\$')\n  return dsn\n\nSTRREPLACE:\n  ORIGINAL = ARG(1)\n  OLDTXT = ARG(2)\n  NEWTXT = ARG(3)\n  /* YOU CAN CHANGE THE BELOW KEY (TMPTXT), WHICH IS USED AS A TEMPORARY\n  POINTER TO IDENTIFY THE TEXT TO BE REPLACED */\n  TMPTXT = '6A53CD2EW1F'\n  NEWSTR = ORIGINAL\n  DO WHILE POS(OLDTXT,NEWSTR) > 0\n    NEWSTR = SUBSTR(NEWSTR, 1 , POS(OLDTXT,NEWSTR)-1) ||,\n      TMPTXT || SUBSTR(NEWSTR, POS(OLDTXT,NEWSTR) + LENGTH(OLDTXT))\n  END\n  DO WHILE POS(TMPTXT,NEWSTR) > 0\n    NEWSTR = SUBSTR(NEWSTR, 1 , POS(TMPTXT,NEWSTR)-1) ||,\n      NEWTXT || SUBSTR(NEWSTR, POS(TMPTXT,NEWSTR) + LENGTH(TMPTXT))\n  END\n  RETURN NEWSTR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZIGIVMAC": {"ttr": 227, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x02\\x00\\x01 \\x07\\x1f\\x01  \\x0f\\x08E\\x00G\\x008\\x00\\x00\\xe9\\xc9\\xc7\\xc9\\xf3\\xf0@@@@'", "ispf": {"version": "01.07", "flags": 2, "createdate": "2020-03-11T00:00:00", "modifydate": "2020-07-18T08:45:00", "lines": 71, "newlines": 56, "modlines": 0, "user": "ZIGI30"}, "text": "/* --------------------  rexx procedure  -------------------- *\n | Name:      zigivmac                                        |\n |                                                            |\n | Function:  ISPF Edit Macro to insert messages at the top   |\n |            of the viewed data.                             |\n |                                                            |\n | Author:    Lionel B. Dyck                                  |\n |                                                            |\n | History:  (most recent on top)                             |\n |            07/17/20 LBD - Turn off Hilite                  |\n |            06/22/20 LBD - Add Git Command msg if present   |\n |            06/11/20 LBD - If lrecl > 255 no hilite         |\n |            03/07/20 LBD - Check for > 1 records for hilite |\n |            12/16/19 LBD - creation                         |\n |                                                            |\n | ---------------------------------------------------------- |\n |    ZIGI - the z/OS ISPF Git Interface                      |\n |    Copyright (C) 2020 - Henri Kuiper and Lionel Dyck       |\n |                                                            |\n |    This program is free software: you can redistribute it  |\n |    and/or modify it under the terms of the GNU General     |\n |    Public License as published by the Free Software        |\n |    Foundation, either version 3 of the License, or (at     |\n |    your option) any later version.                         |\n |                                                            |\n |    This program is distributed in the hope that it will be |\n |    useful, but WITHOUT ANY WARRANTY; without even the      |\n |    implied warranty of MERCHANTABILITY or FITNESS FOR A    |\n |    PARTICULAR PURPOSE.  See the GNU General Public License |\n |    for more details.                                       |\n |                                                            |\n |    You should have received a copy of the GNU General      |\n |    Public License along with this program.  If not, see    |\n |    <https://www.gnu.org/licenses/>.                        |\n * ---------------------------------------------------------- */\n  Address ISREdit\n  'Macro (options)'\n  'Reset ALL'\n  '(last) = linenum .zlast'\n  if last = 0 then do\n     'end'\n     exit\n     end\n  '(lrecl) = lrecl'\n  'hilite off'\n  Address ISPExec 'vget (vtitle gitcmde localrep zigirep)'\n  if gitcmde /= '' then do\n    data = 'Current Directory:' localrep'/'zigirep\n    'line_before 1 = msgline (data)'\n    data = 'Git Command: git' gitcmde\n    'line_before 1 = msgline (data)'\n    data = left('-',length(data),'-')\n    'line_before 1 = msgline (data)'\n  end\n  if vtitle = '' then exit\n  parse value vtitle with element'\\'hdate'\\'hauthor'\\'fulldsn .\n  if left(fulldsn,1) = \"'\" then do\n    parse value element with x'/'mem .\n    fulldsn = strip(fulldsn,'B',\"'\")\n    fulldsn = fulldsn'('mem')'\n  end\n  else fulldsn = element\n  data = 'Historical view of element:' fulldsn\n  'line_before 1 = msgline (data)'\n  data = 'From:' strip(hauthor) 'on' strip(hdate)\n  'line_before 1 = msgline (data)'\n  data = 'All ISPF View commands are available, including Compare, Create' ,\n    'and Copy.'\n  'line_before 1 = msgline (data)'\n  data = left('-',72,'-')\n  'line_before 1 = msgline (data)'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT997/CBT.V500.FILE997.PDS/EXEC.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT997/CBT.V500.FILE997.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}