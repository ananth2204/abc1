{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012137000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 176358, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE477.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE477.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x04\\x06'", "DS1TRBAL": "b'm,'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03\\x80\\x00\\x08\\x03\\x80\\x00\\x0c\\x00\\x05'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$DOC": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x00#?\\x01\\x00#_\\x086\\x00\\x81\\x00z\\x00\\x00\\xc2\\xd3\\xc8\\xc9\\xd3\\xd3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-08-20T00:00:00", "modifydate": "2000-08-22T08:36:00", "lines": 129, "newlines": 122, "modlines": 0, "user": "BLHILL"}, "text": "***********************************************************************\n* AWSUTIL - AWS Format Tape File generation utility - V1.1            *\n*                                                                     *\n* Copyright (C) 2000  Brandon Hill                                    *\n*                                                                     *\n* This program is free software; you can redistribute it and/or       *\n* modify it under the terms of the GNU General Public License.        *\n*                                                                     *\n* This program is distributed in the hope that it will be useful,     *\n* but WITHOUT ANY WARRANTY; including all implied warranties.         *\n*                                                                     *\n* For more information, see the complete GPL at: www.gnu.org          *\n*                                                                     *\n* Please report any bugs and/or enhancements to blh@flybird.com       *\n*                                                                     *\n* Revision History:                                                   *\n*                                                                     *\n* Date     Vers Comments                                              *\n* -------- ---- -----------------------------------                   *\n* 06/13/00 V1.0 Initial Release...                                    *\n* 08/22/00 V1.1 Added GET to use QSAM to read a file                  *\n*                                                                     *\n* Abstract:                                                           *\n*                                                                     *\n* This is a fairly comprehensive program for creating virtual tape    *\n* files.  Labels can be generated.  Tape marks can be written.        *\n* Any dataset that can be accessed by BSAM can be copied.  Any real   *\n* tape device can have either a single file, or the entire tape       *\n* copied.                                                             *\n*                                                                     *\n* Commands are read from SYSIN and status and errors are written to   *\n* SYSPRINT.  The AWS TAPE image is written to SYSOUT as a VB file     *\n* that is suitable to be copied with FTP in binary mode to any other  *\n* system.                                                             *\n*                                                                     *\n* Any number of DD statements representing sequential data and tapes  *\n* may be specified and read via the appropriate statements in SYSIN.  *\n*                                                                     *\n*                                                                     *\n* Jcl Example:                                                        *\n*                                                                     *\n* //MAKETAPE EXEC PGM=AWSUTIL                                         *\n* //STEPLIB  DD DISP=SHR,DSN=my.load.library                          *\n* //SYSPRINT DD SYSOUT=*                                              *\n* //SYSOUT   DD DISP=(,CATLG),SPACE=(TRK,(15,15)),DSN=my.dsn.name     *\n* //INDATA   DD DISP=SHR,DSN=my.input.sequential.data                 *\n* //INTAPE   DD DISP=OLD,DNS=my.real.tape.file                        *\n* //SYSIN    DD *                                                     *\n* READ INDATA                                                         *\n* TAPEMARK                                                            *\n* TAPEFILE INTAPE                                                     *\n* TAPEMARK                                                            *\n* /*                                                                  *\n*                                                                     *\n* Summary of supported SYSIN commands:                                *\n*                                                                     *\n* READ     ddname                                                     *\n*                                                                     *\n*  Perform BSAM read from ddname and convert each block to AWS TAPE   *\n*  format.  Works on whatever BSAM will read.  Maximum BLKSIZE        *\n*  is 32760.                                                          *\n*                                                                     *\n* GET      ddname                                                     *\n*                                                                     *\n*  Perform QSAM read from ddname and convert each record to AWS TAPE  *\n*  format.  Works on whatever QSAM will read.  Maximum BLKSIZE        *\n*  is 32760.                                                          *\n*                                                                     *\n* TAPEFILE ddname                                                     *\n*                                                                     *\n*  Perform EXCP read from a real tape device and convert each block   *\n*  to AWS TAPE format.  Only works on a tape device.  Maximum BLKSIZE *\n*  is 65535.  This command stops reading when a tape mark is read.    *\n*  Therefore, only the current tape file is processed.  If BLP were   *\n*  used, only the tape headers would be processed.                    *\n*                                                                     *\n* TAPEALL  ddname                                                     *\n*                                                                     *\n*  Perform EXCP read from a real tape device and convert each block   *\n*  to AWS TAPE format.  Only works on a tape device.  Maximum BLKSIZE *\n*  is 65535.  This command rewinds the tape and reads until an error  *\n*  condition is returned.  This effectively copies the entire contents*\n*  of the tape.  BLP is not necessary, as a Rewind command is sent    *\n*  before the tape is read.  Tape marks are duplicated as they are    *\n*  encountered.                                                       *\n*                                                                     *\n*  NOTE: Because end of reel reflectors are rarely effective, this    *\n*        command can run a tape off the reel on a 3420 type drive.    *\n*        3480/3490/3590 type drives have better stopping mechanisms.  *\n*        You have been warned.                                        *\n*                                                                     *\n* TAPEMARK                                                            *\n*                                                                     *\n*  Write a tape mark to the output file.  This is usually used to     *\n*  separate individual files on a tape.  Two consecutive tape marks   *\n*  sometimes signals the end of the tape.                             *\n*                                                                     *\n* VERIFY                                                              *\n*                                                                     *\n*  Print a message after each command verifying that the command was  *\n*  executed ok.  This merely prints a message.  It has no effect on   *\n*  the integrity of the data.  Because SYSOUT should be directed to   *\n*  disk, there should be no data integrity problems, anyway.          *\n*                                                                     *\n* ASCII                                                               *\n*                                                                     *\n*  All subsequent labels generated are converted to ASCII before they *\n*  are written.  This only affects labels.  All data is copied        *\n*  exactly as it is read no matter the setting of this command.       *\n*                                                                     *\n* EBCDIC                                                              *\n*                                                                     *\n*  All subsequent labels generated are not to be converted before they*\n*  are written.  The implication is that the data is still in EBCDIC  *\n*  format.  This only affects labels.  All data is copied exactly as  *\n*  it is read no matter the setting of this command.                  *\n*                                                                     *\n* VOL1, HDR1 - HDR2, EOF1 - EOF2, EOV1 - EOV2, UHL1 - UHL8, UTL1- UTL8*\n*                                                                     *\n*  These commands write 80 byte labels to the tape image.  The format *\n*  of the labels is controlled by the ASCII and EBCDIC commands.      *\n*  Except for the first 4 bytes of each input line, none of the data  *\n*  is checked to make sure it is a valid tape label.  It is up to the *\n*  user to provide correctly formatted labels as desired.             *\n*                                                                     *\n*  Essentially, the entire 80 byte input record is written to the     *\n*  AWS TAPE image as is (or converted to ASCII if the flag is set)    *\n*                                                                     *\n***********************************************************************\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$USES": {"ttr": 519, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x00#O\\x01\\x00#O\\x17V\\x00\\x1f\\x00\\x1d\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-08-21T00:00:00", "modifydate": "2000-08-21T17:56:00", "lines": 31, "newlines": 29, "modlines": 0, "user": "WSBG"}, "text": "Subject: AWS on MVS system\nDate: Mon, 21 Aug 2000 17:34:58 -0400\nFrom: \"Brandon Hill\" <blh@flybird.com>\nTo: <sbgolob@attglobal.net>\n\nCan a real, hardware 9672 or 3090 do anything useful with AWSTAPE\nformat files?  No, not really.\n\nHowever, here is my use for them:\n\nI have a handful of old reel tapes from my high school and college\ndays.  I am attempting to copy them to something (a few already have\ndata checks) to save them.\n\nI found AWSTAPE a useful format to just store a tape file in so that\nan actual tape may be produced at a later date.  It stores files,\nblocks, marks, and whatnot transparently.  I had no better ideas\n(actually, my first attempt was DSORG=PS, LRECL=32756,\nBLKSIZE=32760, RECFM=VB) so I used it for my personal archiving\nproject.\n\nJust so happens that under Hercules, these are (more or less) real\ntapes.\n\nOne note:  I read on the Hercules list that the actual AWSTAPE\nspecification only allows 4096 bytes/block header.  My program puts\nthe whole block under one block header.  Hercules doesn't seem to\ncare.  The length fields are long enough.  I'll fix it when I've\nnothing better to do, but it seems ok for now.\n\nBrandon\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$RUN": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x00#?\\x01\\x00#_\\x086\\x00\\x1c\\x00\\x19\\x00\\x00\\xc2\\xd3\\xc8\\xc9\\xd3\\xd3@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2000-08-20T00:00:00", "modifydate": "2000-08-22T08:36:00", "lines": 28, "newlines": 25, "modlines": 0, "user": "BLHILL"}, "text": "//WSBGAWS  JOB ,'SAM GOLOB',CLASS=S,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//* Run the program\n//*\n//*  This is a simple test to see if things are ok.  It should create\n//* a simple SL tape with a single 80 byte record read from INPUT\n//*\n//AWSUTIL  EXEC PGM=AWSUTIL,COND=(4,LT)\n//STEPLIB  DD DISP=SHR,DSN=WSBG.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSOUT   DD SYSOUT=* <--- REPLACE WITH ACTUAL DATASET\n//INPUT    DD *\nTest record\n//SYSIN    DD *\nVERIFY\nVOL1MYTAPE                               TAPE OWNER\nHDR1SYS1.TEST.DATA   MYTAPE00010001      0001640001640000000IBM OS/VS 370\nHDR2F00080000800TAPEJOB1/TAPESTEP\nTAPEMARK\nREAD INPUT\nTAPEMARK\nEOF1SYS1.TEST.DATA   MYTAPE00010001      0001640001640000001IBM OS/VS 370\nEOF2F00080000800TAPEJOB1/TAPESTEP\nTAPEMARK\nTAPEMARK\n/*\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$RUN1": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x01\\x00#?\\x01\\x00#_\\x12D\\x00\\x16\\x00\\x19\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2000-08-20T00:00:00", "modifydate": "2000-08-22T12:44:00", "lines": 22, "newlines": 25, "modlines": 0, "user": "WSBG"}, "text": "//WSBGAWS  JOB ,'SAM GOLOB',CLASS=S,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//* RUN THE PROGRAM AGAINST A TAPE WITH ABOUT 250 MEG OF DATA\n//*          AND 504 FILES\n//*\n//*  THIS JOB COPIES AN ENTIRE TAPE TO A DISK FILE.\n//*\n//AWSUTIL  EXEC PGM=AWSUTIL\n//STEPLIB  DD DISP=SHR,DSN=WSBG.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSOUT   DD DISP=(NEW,CATLG,DELETE),DSN=WSBG.C427MU.AWSIMAGE,\n//   UNIT=SYSDA,\n//   VOL=SER=SP3288,SPACE=(CYL,(1200,348),RLSE)\n//INTAPE   DD DISP=SHR,UNIT=TAPE,VOL=SER=C427MU,\n//            LABEL=(1,BLP,EXPDT=98000),DSN=WSBG.INTAPE\n//*NPUT    DD *\n//SYSIN    DD *\n   VERIFY\n   TAPEALL INTAPE\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE477": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x99\\x08?\\x01\\x00#_\\x12\\x16\\x00\\n\\x00\\x02\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-03-24T00:00:00", "modifydate": "2000-08-22T12:16:00", "lines": 10, "newlines": 2, "modlines": 0, "user": "WSBG"}, "text": "//***FILE 477 is from Brandon Hill and contains a program,          *   FILE 477\n//*           called AWSUTIL, which takes MVS data from either      *   FILE 477\n//*           disk or tape, and creates a \"virtual tape file\"       *   FILE 477\n//*           in AWS format.  This file, which contains all the     *   FILE 477\n//*           data normally in a complete tape, can then be         *   FILE 477\n//*           electronically sent anywhere.  You no longer have     *   FILE 477\n//*           to ship a physical tape.                              *   FILE 477\n//*                                                                 *   FILE 477\n//*           email:  Brandon Hill <nsysblh@acs.ncsu.edu>           *   FILE 477\n//*                                                                 *   FILE 477\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AWSUTIL": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x00#?\\x01\\x00#_\\x086\\x04\\xd4\\x043\\x00\\x00\\xc2\\xd3\\xc8\\xc9\\xd3\\xd3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-08-20T00:00:00", "modifydate": "2000-08-22T08:36:00", "lines": 1236, "newlines": 1075, "modlines": 0, "user": "BLHILL"}, "text": "//AWSUTIL  JOB\n//ASM      EXEC PGM=ASMA90,PARM='OBJECT,NODECK'\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSUT1   DD UNIT=VIO,SPACE=(TRK,(30,30))\n//SYSLIN   DD DISP=(,PASS),DSN=&&SYSLIN,SPACE=(TRK,(1,1))\n//SYSIN    DD *\n***********************************************************************\n* AWSUTIL - AWS Format Tape File generation utility - V1.1            *\n*                                                                     *\n* Copyright (C) 2000  Brandon Hill                                    *\n*                                                                     *\n* This program is free software; you can redistribute it and/or       *\n* modify it under the terms of the GNU General Public License.        *\n*                                                                     *\n* This program is distributed in the hope that it will be useful,     *\n* but WITHOUT ANY WARRANTY; including all implied warranties.         *\n*                                                                     *\n* For more information, see the complete GPL at: www.gnu.org          *\n*                                                                     *\n* Please report any bugs and/or enhancements to blh@flybird.com       *\n*                                                                     *\n* Revision History:                                                   *\n*                                                                     *\n* Date     Vers Comments                                              *\n* -------- ---- -----------------------------------                   *\n* 06/13/00 V1.0 Initial Release...                                    *\n* 08/22/00 V1.1 Added GET to use QSAM to read a file                  *\n*                                                                     *\n* Abstract:                                                           *\n*                                                                     *\n* This is a fairly comprehensive program for creating virtual tape    *\n* files.  Labels can be generated.  Tape marks can be written.        *\n* Any dataset that can be accessed by BSAM can be copied.  Any real   *\n* tape device can have either a single file, or the entire tape       *\n* copied.                                                             *\n*                                                                     *\n* Commands are read from SYSIN and status and errors are written to   *\n* SYSPRINT.  The AWS TAPE image is written to SYSOUT as a VB file     *\n* that is suitable to be copied with FTP in binary mode to any other  *\n* system.                                                             *\n*                                                                     *\n* Any number of DD statements representing sequential data and tapes  *\n* may be specified and read via the appropriate statements in SYSIN.  *\n*                                                                     *\n*                                                                     *\n* Jcl Example:                                                        *\n*                                                                     *\n* //MAKETAPE EXEC PGM=AWSUTIL                                         *\n* //STEPLIB  DD DISP=SHR,DSN=my.load.library                          *\n* //SYSPRINT DD SYSOUT=*                                              *\n* //SYSOUT   DD DISP=(,CATLG),SPACE=(TRK,(15,15)),DSN=my.dsn.name     *\n* //INDATA   DD DISP=SHR,DSN=my.input.sequential.data                 *\n* //INTAPE   DD DISP=OLD,DNS=my.real.tape.file                        *\n* //SYSIN    DD *                                                     *\n* READ INDATA                                                         *\n* TAPEMARK                                                            *\n* TAPEFILE INTAPE                                                     *\n* TAPEMARK                                                            *\n* /*                                                                  *\n*                                                                     *\n* Summary of supported SYSIN commands:                                *\n*                                                                     *\n* READ     ddname                                                     *\n*                                                                     *\n*  Perform BSAM read from ddname and convert each block to AWS TAPE   *\n*  format.  Works on whatever BSAM will read.  Maximum BLKSIZE        *\n*  is 32760.                                                          *\n*                                                                     *\n* GET      ddname                                                     *\n*                                                                     *\n*  Perform QSAM read from ddname and convert each record to AWS TAPE  *\n*  format.  Works on whatever QSAM will read.  Maximum BLKSIZE        *\n*  is 32760.                                                          *\n*                                                                     *\n* TAPEFILE ddname                                                     *\n*                                                                     *\n*  Perform EXCP read from a real tape device and convert each block   *\n*  to AWS TAPE format.  Only works on a tape device.  Maximum BLKSIZE *\n*  is 65535.  This command stops reading when a tape mark is read.    *\n*  Therefore, only the current tape file is processed.  If BLP were   *\n*  used, only the tape headers would be processed.                    *\n*                                                                     *\n* TAPEALL  ddname                                                     *\n*                                                                     *\n*  Perform EXCP read from a real tape device and convert each block   *\n*  to AWS TAPE format.  Only works on a tape device.  Maximum BLKSIZE *\n*  is 65535.  This command rewinds the tape and reads until an error  *\n*  condition is returned.  This effectively copies the entire contents*\n*  of the tape.  BLP is not necessary, as a Rewind command is sent    *\n*  before the tape is read.  Tape marks are duplicated as they are    *\n*  encountered.                                                       *\n*                                                                     *\n*  NOTE: Because end of reel reflectors are rarely effective, this    *\n*        command can run a tape off the reel on a 3420 type drive.    *\n*        3480/3490/3590 type drives have better stopping mechanisms.  *\n*        You have been warned.                                        *\n*                                                                     *\n* TAPEMARK                                                            *\n*                                                                     *\n*  Write a tape mark to the output file.  This is usually used to     *\n*  separate individual files on a tape.  Two consecutive tape marks   *\n*  sometimes signals the end of the tape.                             *\n*                                                                     *\n* VERIFY                                                              *\n*                                                                     *\n*  Print a message after each command verifying that the command was  *\n*  executed ok.  This merely prints a message.  It has no effect on   *\n*  the integrity of the data.  Because SYSOUT should be directed to   *\n*  disk, there should be no data integrity problems, anyway.          *\n*                                                                     *\n* ASCII                                                               *\n*                                                                     *\n*  All subsequent labels generated are converted to ASCII before they *\n*  are written.  This only affects labels.  All data is copied        *\n*  exactly as it is read no matter the setting of this command.       *\n*                                                                     *\n* EBCDIC                                                              *\n*                                                                     *\n*  All subsequent labels generated are not to be converted before they*\n*  are written.  The implication is that the data is still in EBCDIC  *\n*  format.  This only affects labels.  All data is copied exactly as  *\n*  it is read no matter the setting of this command.                  *\n*                                                                     *\n* VOL1, HDR1 - HDR2, EOF1 - EOF2, EOV1 - EOV2, UHL1 - UHL8, UTL1- UTL8*\n*                                                                     *\n*  These commands write 80 byte labels to the tape image.  The format *\n*  of the labels is controlled by the ASCII and EBCDIC commands.      *\n*  Except for the first 4 bytes of each input line, none of the data  *\n*  is checked to make sure it is a valid tape label.  It is up to the *\n*  user to provide correctly formatted labels as desired.             *\n*                                                                     *\n*  Essentially, the entire 80 byte input record is written to the     *\n*  AWS TAPE image as is (or converted to ASCII if the flag is set)    *\n*                                                                     *\n***********************************************************************\n         MACRO\n&LABEL   SETRC &SYM\n&LABEL   CLC   MAXRC,&SYM                             | Check for\n         BNL   *+4+6                                  |  ERR>MAX\n         MVC   MAXRC,&SYM                             |\n         MEND\n         MACRO\n&LABEL   PRMSG &MSG,&INIT=NO,&INCPTR=YES,&LEN=0\n         LCLA  &L\n         LCLC  &LIT\n         AIF   ('&INIT' EQ 'YES').INIT\n         AIF   ('&MSG'(1,1) EQ '=').LIT\n.SYM     ANOP\n&L       SETA  &LEN\n         AIF   (&L NE 0).MOVESYM\n&L       SETA  L'&MSG\n.MOVESYM ANOP\n&LABEL   MVC   0(&L.,1),&MSG                          | Move data\n         AIF   ('&INCPTR' EQ 'NO').EXITSYM\n         LA    1,&L.(,1)                              | Bump pointer\n.EXITSYM MEXIT\n.LIT     ANOP\n&L       SETA  &LEN\n         AIF   (&L NE 0).MOVELIT\n&L       SETA  K'&MSG-4\n         AIF   ('&MSG'(2,1) EQ 'C').MOVELIT\n&L       SETA  &L/2\n         AIF   ('&MSG'(2,1) EQ 'X').MOVELIT\n&LIT     SETC  '&MSG'(1,2)\n         MNOTE 8,'UNSUPPORTED LITERAL: &LIT'\n         MEXIT\n.MOVELIT ANOP\n&LABEL   MVC   0(&L.,1),&MSG                          | Move data\n         AIF   ('&INCPTR' EQ 'NO').EXITLIT\n         LA    1,&L.(,1)                              | Bump pointer\n.EXITLIT MEXIT\n.INIT    ANOP\n         AIF   ('&MSG' EQ '').DEFCC\n&LABEL   MVI   OUTANSI,&MSG                           | Set CC\n         AGO   .CLRBUF\n.DEFCC   ANOP\n&LABEL   MVI   OUTANSI,ANSI#1L                        | Default CC\n.CLRBUF  ANOP\n         MVI   OUTBUFF,C' '                           | Clear Buffer\n         MVC   OUTBUFF+1(L'OUTBUFF-1),OUTBUFF         |\n         LA    1,OUTBUFF                              | Set Pointer\n         MEND\n         TITLE 'AWSUTIL - Generate AWSTAPE format tape image'\nAWSUTIL  CSECT\n         STM   14,12,12(13)                           | Entry\n         LR    12,15                                  |\n         USING AWSUTIL,12                             |\n         GETMAIN R,LV=72                              |\n         ST    13,4(,1)                               |\n         ST    1,8(,13)                               |\n         LR    13,1                                   |\n         SPACE\n         OPEN  (SYSPRINT,OUTPUT)                      | Open SYSOUT\n         LTR   15,15                                  |\n         BNZ   PRINTERR                               |\n         SPACE\n         PRMSG ANSI#TOP,INIT=YES                      | Page header\n         PRMSG =C'AWSUTIL V1.1 PROGRAM STARTED'       |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\n         PRMSG INIT=YES                               | Blank line\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\n         OPEN  SYSIN                                  | Open SYSIN\n         LTR   15,15                                  |\n         BNZ   INPUTERR                               |\n         SPACE\n         OPEN  (SYSOUT,OUTPUT)                        | Open SYSOUT\n         LTR   15,15                                  |\n         BNZ   SYSOUTER                               |\n         SPACE\n         XC    PREVBLOK,PREVBLOK                      | Reset counters\n         XC    CURRBLOK,CURRBLOK                      |\n         SPACE\n         GETMAIN R,LV=OUTBLKL+4                       | Put Buffer\n         LR    10,1                                   |\n         SPACE\nMAINLOOP DS    0H\n         SPACE\n         GET   SYSIN,INLINE                           | Get a line\n         SPACE\n         PRMSG ANSI#1L,INIT=YES                       |\n         CLI   VERIFY$,X'00'                          | Skip?\n         BE    *+8                                    |\n         MVI   OUTANSI,ANSI#2L                        |\n         SPACE\n         PRMSG =C'>>> '                               | Redisplay\n         PRMSG INLINE                                 |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\n         MVC   INVERB,=CL8' '                         | Erase tokens\n         MVC   INARG1,=CL8' '                         |\n         SPACE\n         LA    0,L'INLINE                             | Buffer to scan\n         LA    1,INLINE                               |\n         SPACE\nPARSET1A CLI   0(1),C' '                              | Skip past space\n         BNE   PARSET1                                |\n         LA    1,1(,1)                                |\n         BCT   0,PARSET1A                             |\n         B     PARSEXX                                |\n         SPACE\nPARSET1  LA    2,L'INVERB                             | Fill Verb\n         LA    3,INVERB                               |\n         SPACE\nPARSET1X CLI   0(1),C' '                              | Copy data\n         BE    PARSET2A                               |\n         LTR   2,2                                    |\n         BNP   PARSET1Y                               |\n         MVC   0(1,3),0(1)                            |\n         SH    2,=H'1'                                |\n         LA    3,1(,3)                                |\nPARSET1Y LA    1,1(,1)                                |\n         BCT   0,PARSET1X                             |\n         B     PARSEXX                                |\n         SPACE\nPARSET2A CLI   0(1),C' '                              | Skip past space\n         BNE   PARSET2                                |\n         LA    1,1(,1)                                |\n         BCT   0,PARSET2A                             |\n         B     PARSEXX                                |\n         SPACE\nPARSET2  LA    2,L'INARG1                             | Fill Arg1\n         LA    3,INARG1                               |\n         SPACE\nPARSET2X CLI   0(1),C' '                              | Copy data\n         BE    PARSEXX                                |\n         LTR   2,2                                    |\n         BNP   PARSET2Y                               |\n         MVC   0(1,3),0(1)                            |\n         SH    2,=H'1'                                |\n         LA    3,1(,3)                                |\nPARSET2Y LA    1,1(,1)                                |\n         BCT   0,PARSET2X                             |\n         SPACE\nPARSEXX  DS    0H\n         SPACE\n         CLI   INVERB,C'*'                            | Comment?\n         BE    MAINLOOP                               |\n         SPACE\n*\n* Check command name and call routine\n*\n         SPACE\n         CLC   INVERB,=CL8'TAPEMARK'                  | TAPEMARK cmd\n         L     11,=A(@TAPEMRK)                        |\n         BZR   11                                     |\n         SPACE\n         CLC   INVERB,=CL8'READ'                      | READ cmd\n         L     11,=A(@READ)                           |\n         BZR   11                                     |\n         SPACE\n         CLC   INVERB,=CL8'GET'                       | GET cmd\n         L     11,=A(@GET)                            |\n         BZR   11                                     |\n         SPACE\n         CLC   INVERB,=CL8'TAPEFILE'                  | TAPEFILE cmd\n         L     11,=A(@TAPE)                           |\n         BZR   11                                     |\n         SPACE\n         CLC   INVERB,=CL8'TAPEALL'                   | TAPEALL cmd\n         L     11,=A(@TAPE)                           |\n         BZR   11                                     |\n         SPACE\n         CLC   INVERB,=CL8'ASCII'                     | ASCII command\n         L     11,=A(@LABLFRM)                        |\n         BZR   11                                     |\n         SPACE\n         CLC   INVERB,=CL8'EBCDIC'                    | EBCDIC command\n         L     11,=A(@LABLFRM)                        |\n         BZR   11                                     |\n         SPACE\n         CLC   INVERB,=CL8'VERIFY'                    | VERIFY command\n         L     11,=A(@VERIFY)                         |\n         BZR   11                                     |\n         SPACE\n*\n* Check command name for tape label identifier\n*\n         SPACE\n         LA    0,LABELS#                              | Setup loop\n         LA    1,LABELS                               |\n         L     11,=A(@LABELS)                         |\n         SPACE\nLABELOOP CLC   INVERB(4),0(1)                         | Check for\n         BER   11                                     |  label id\n         SPACE\n         LA    1,4(,1)                                | Check next\n         BCT   0,LABELOOP                             |\n         SPACE\n*\n* Command is not supported, report error\n*\n         SPACE\n         PRMSG ANSI#3L,INIT=YES                       | Print Err\n         PRMSG =C'ERROR: COMMAND VERB \"'              |\n         PRMSG INVERB                                 |\n         PRMSG =C'\" IS UNKNOWN'                       |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\n         SETRC ERR$ERR                                | Error\n         SPACE\n         B     MAINLOOP                               | Loop\n         SPACE\nINPUTERR DS    0H\n         SPACE\n         PRMSG ANSI#3L,INIT=YES                       | Print Err\n         PRMSG =C'FATAL: UNABLE TO OPEN DD=SYSIN'     |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\n         SETRC ERR$FATL                               | Fatal Error\n         SPACE\n         B     CLOSEOUT                               |\n         SPACE\nSYSOUTER DS    0H\n         SPACE\n         PRMSG ANSI#3L,INIT=YES                       | Print Err\n         PRMSG =C'FATAL: UNABLE TO OPEN DD=SYSOUT'    |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\n         SETRC ERR$FATL                               | Fatal Error\n         SPACE\n         B     CLOSEIN\n         SPACE\nCLOSE    DS    0H\n         SPACE\n         FREEMAIN R,LV=OUTBLKL+4,A=(10)               | Free Put Buff\n         SPACE\n         CLOSE SYSOUT                                 | Try to close\n         LTR   15,15                                  |\n         BZ    CLOSEIN                                |\n         SPACE\n         PRMSG ANSI#3L,INIT=YES                       | Print Err\n         PRMSG =C'FATAL: ERROR CLOSING DD=SYSOUT'     |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\n         SETRC ERR$FATL                               | Fatal Error\n         SPACE\nCLOSEIN  DS    0H\n         SPACE\n         CLOSE SYSIN                                  | Close input\n         SPACE\nCLOSEOUT DS    0H\n         SPACE\n         PRMSG ANSI#3L,INIT=YES                       | Final Line\n         PRMSG =C'AWSUTIL PROGRAM TERMINATED, MAX RC' |\n         PRMSG =X'40202120',INCPTR=NO                 |\n         LH    0,MAXRC                                |\n         CVD   0,DWORD                                |\n         ED    0(4,1),DWORD+6                         |\n         PRMSG =C'='                                  |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\n         CLOSE SYSPRINT                               | Close output\n         SPACE\n         B     RETURN\n         SPACE\nRETURN   LR    1,13                                   | Exit with rc\n         L     13,4(,1)                               |\n         FREEMAIN R,LV=72,A=(1)                       |\n         LH    15,MAXRC                               |\n         L     14,12(13)                              |\n         LM    0,12,20(13)                            |\n         BR    14                                     |\n         SPACE\nPRINTERR DS    0H\n         SPACE\n         SETRC ERR$FATL                               | Fatal Error\n         SPACE\n         B     RETURN                                 |\n         SPACE\n         DROP  12\n         SPACE\nOUTBLKL  EQU   4096                                   | block length\n         SPACE\nANSI#TOP EQU C'1'\nANSI#3L  EQU C'-'\nANSI#2L  EQU C'0'\nANSI#1L  EQU C' '\n         LTORG\n         TITLE 'Common Storage'\n         SPACE\nDWORD    DS    1D                                     | DoubleWord\nECB      DS    1F                                     | General ECB\n         SPACE\nMAXRC    DC    H'0'                                   | Maximum RC\nERR$ERR  DC    H'8'                                   | error rc\nERR$FATL DC    H'16'                                  | fatal rc\n         SPACE\nVERIFY$  DC    X'00'                                  | Verify off\n         SPACE\nASCIILBL DC    X'00'                                  | ASC/EBC labels\n         SPACE\nOUTLINE  DS    0CL133' '                              | Output buffer\nOUTANSI  DS    CL1' '                                 |\nOUTBUFF  DS    CL132' '                               |\n         SPACE\nINLINE   DS    CL80' '                                | Input buffer\n         SPACE\nINVERB   DS    CL8' '                                 |\nINARG1   DS    CL8' '                                 |\n         SPACE\nPREVBLOK DS    F\nCURRBLOK DS    F\nAWS#MARK EQU   X'40'\nAWS#REC  EQU   X'80'+X'20'\n         SPACE\nLABELS   DC    C'VOL1HDR1EOV1EOF1HDR2EOV2EOF2'        | All valid\n         DC    C'UHL1UHL2UHL3UHL4UHL5UHL6UHL7UHL8'    |  80 byte\n         DC    C'UTL1UTL2UTL3UTL4UTL5UTL6UTL7UTL8'    |   labels\nLABELS#  EQU   (*-LABELS)/4\n         SPACE\n         IEZIOB DSECT=NO                              | IOB\n         SPACE\nSYSPRINT DCB   DDNAME=SYSPRINT,                                        +\n               MACRF=PM,                                               +\n               DSORG=PS,                                               +\n               LRECL=133,                                              +\n               RECFM=FBA\nSYSIN    DCB   DDNAME=SYSIN,                                           +\n               MACRF=GM,                                               +\n               DSORG=PS,                                               +\n               LRECL=80,                                               +\n               RECFM=FB,                                               +\n               EODAD=CLOSE\nSYSOUT   DCB   DDNAME=SYSOUT,                                          +\n               MACRF=PM,                                               +\n               DSORG=PS,                                               +\n               LRECL=OUTBLKL+4,                                        +\n               RECFM=VB\n         SPACE\n         LTORG\n         SPACE\n         TITLE '@VERIFY - toggle verify flag'\n         SPACE\n@VERIFY  CSECT\n         USING @VERIFY,11\n         USING AWSUTIL,12\n         SPACE\n         CLI   VERIFY$,X'00'                          | Check flag\n         BE    VFY$ON                                 |\n         SPACE\n         MVI   VERIFY$,X'00'                          |\n         SPACE\n         PRMSG ANSI#1L,INIT=YES                       | Print\n         PRMSG =C'VERIFY FLAG IS NOW OFF'             |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\n         B     MAINLOOP\n         SPACE\nVFY$ON   DS    0H\n         SPACE\n         MVI   VERIFY$,X'FF'                          | Turn on flag\n         SPACE\n         PRMSG ANSI#1L,INIT=YES                       | Print\n         PRMSG =C'VERIFY FLAG IS NOW ON'              |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\n         B     MAINLOOP\n         SPACE\n         DROP  11,12\n         SPACE\n         LTORG\n         TITLE '@LABLFRM - set ASCII or EBCDIC labels'\n         SPACE\n@LABLFRM CSECT\n         USING @LABLFRM,11\n         USING AWSUTIL,12\n         SPACE\n         CLC   INVERB,=CL8'ASCII'\n         BE    LAB$ASC\n         SPACE\n         MVI   ASCIILBL,X'00'\n         SPACE\n         CLI   VERIFY$,X'00'                          | Check flag\n         BE    MAINLOOP                               |\n         SPACE\n         PRMSG ANSI#1L,INIT=YES                       | Print\n         PRMSG =C'EBCDIC LABELS SELECTED'             |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\n         B     MAINLOOP\n         SPACE\nLAB$ASC  DS    0H\n         SPACE\n         MVI   ASCIILBL,X'FF'\n         SPACE\n         CLI   VERIFY$,X'00'                          | Check flag\n         BE    MAINLOOP                               |\n         SPACE\n         PRMSG ANSI#1L,INIT=YES                       | Print\n         PRMSG =C'ASCII LABELS SELECTED'              |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\n         B     MAINLOOP\n         SPACE\n         DROP  11,12\n         SPACE\n         LTORG\n         SPACE\n         TITLE '@TAPEMRK - write a tapemark to the AWS tape'\n         SPACE\n@TAPEMRK CSECT\n         USING PUTBUFF,10\n         USING @TAPEMRK,11\n         USING AWSUTIL,12\n         SPACE\n         MVC   PUTRDW,=AL2(6+4)                       | Setup RDW\n         XC    PUTCLR,PUTCLR                          |\n         SPACE\n         MVC   PREVBLOK,CURRBLOK                      | Cycle bloks\n         XC    CURRBLOK,CURRBLOK                      |\n         SPACE\n         MVC   PUTCURL,CURRBLOK+3                     | Reverse byte\n         MVC   PUTCURH,CURRBLOK+2                     |  order\n         SPACE\n         MVC   PUTPRVL,PREVBLOK+3                     | Reverse byte\n         MVC   PUTPRVH,PREVBLOK+2                     |  order\n         SPACE\n         MVI   PUTFLG1,AWS#MARK                       | Tape Mark\n         XC    PUTFLG2,PUTFLG2\n         SPACE\n         PUT   SYSOUT,PUTBUFF                         | Put record\n         SPACE\n         CLI   VERIFY$,X'00'                          | Skip?\n         BE    MAINLOOP                               |\n         SPACE\n         PRMSG ANSI#1L,INIT=YES                       | Print info\n         PRMSG =C'WRITE TAPE MARK OK'                 |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\n         B     MAINLOOP                               | Back to loop\n         SPACE\n         DROP  10,11,12\n         SPACE\n         LTORG\n         TITLE '@LABELS - write 80 byte tape label to AWS tape'\n         SPACE\n@LABELS  CSECT\n         USING PUTBUFF,10\n         USING @LABELS,11\n         USING AWSUTIL,12\n         SPACE\n         MVC   PUTRDW,=AL2(80+6+4)                    | Setup RDW\n         XC    PUTCLR,PUTCLR                          |\n         SPACE\n         MVC   PREVBLOK,CURRBLOK                      | Cycle bloks\n         MVC   CURRBLOK,=F'80'                        |\n         SPACE\n         MVC   PUTCURL,CURRBLOK+3                     | Reverse byte\n         MVC   PUTCURH,CURRBLOK+2                     |  order\n         SPACE\n         MVC   PUTPRVL,PREVBLOK+3                     | Reverse byte\n         MVC   PUTPRVH,PREVBLOK+2                     |  order\n         SPACE\n         MVI   PUTFLG1,AWS#REC                        | Data Block\n         XC    PUTFLG2,PUTFLG2                        |\n         SPACE\n         MVC   PUTDATA(L'INLINE),INLINE               | Copy record\n         SPACE\n         CLI   ASCIILBL,X'00'                         | Check for\n         BE    LAB$PUT                                |  ASCII\n         SPACE\n         XLATE PUTDATA,80,TO=A                        | Xlate 2 ASCII\n         SPACE\nLAB$PUT  DS    0H\n         SPACE\n         PUT   SYSOUT,PUTBUFF                         | Put record\n         SPACE\n         CLI   VERIFY$,X'00'                          | Skip?\n         BE    MAINLOOP                               |\n         SPACE\n         PRMSG ANSI#1L,INIT=YES                       | Print info\n         PRMSG =C'WRITE LABEL '                       |\n         PRMSG INVERB,LEN=4                           |\n         PRMSG =C' OK'                                |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\n         B     MAINLOOP                               | Back to loop\n         SPACE\n         DROP  10,11,12\n         SPACE\n         LTORG\n         TITLE '@READ - read records from input to AWS tape'\n         SPACE\n@READ    CSECT\n         USING PUTBUFF,10\n         USING @READ,11\n         USING AWSUTIL,12\n         SPACE\n         MVC   RD$INDCB+DCBDDNAM-IHADCB(8),=CL8'INPUT'  Default name\n         SPACE\n         CLI   INARG1,C' '                            | Check DDNAME\n         BE    *+10                                   |\n         MVC   RD$INDCB+DCBDDNAM-IHADCB(8),INARG1     | Set DDNAME\n         SPACE\n         MVC   RD$INDD,RD$INDCB+DCBDDNAM-IHADCB       | Save DDNAME\n         SPACE\n         OPEN  RD$INDCB                               | Open DD\n         LTR   15,15                                  |\n         BNZ   RD$OERR                                |\n         SPACE\n         CLI   VERIFY$,X'00'                          | Skip?\n         BE    RD$START                               |\n         SPACE\n         PRMSG ANSI#1L,INIT=YES                       | Print it\n         PRMSG =C'OPEN COMPLETE FOR INPUT DD='        |\n         PRMSG RD$INDD                                |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\nRD$START DS    0H\n         SPACE\n         XC    RD$BLK,RD$BLK                          | Clear counter\n         SPACE\n         GETMAIN R,LV=65536                           | Get buffer\n         LR    9,1                                    |\n         SPACE\nRD$LOOP  DS    0H\n         SPACE\n         READ  RD$CHK,SF,RD$INDCB,(9)                 | Read block\n         CHECK RD$CHK                                 |\n         SPACE\n         LH    3,RD$INDCB+DCBBLKSI-IHADCB             | Calc block\n         L     2,RD$CHK+16                            |  length\n         SH    3,14(,2)                               |\n         LR    2,9                                    |\n         SPACE\n         MVC   PREVBLOK,CURRBLOK                      | Cycle bloks\n         ST    3,CURRBLOK                             |\n         SPACE\n         MVC   PUTRDW,=AL2(6+4)                       | Setup RDW\n         XC    PUTCLR,PUTCLR                          |\n         SPACE\n         MVC   PUTCURL,CURRBLOK+3                     | Reverse byte\n         MVC   PUTCURH,CURRBLOK+2                     |  order\n         SPACE\n         MVC   PUTPRVL,PREVBLOK+3                     | Reverse byte\n         MVC   PUTPRVH,PREVBLOK+2                     |  order\n         SPACE\n         MVI   PUTFLG1,AWS#REC                        | Record\n         XC    PUTFLG2,PUTFLG2\n         SPACE\n         PUT   SYSOUT,PUTBUFF                         | Put record\n         SPACE\nRD$LLOP  DS    0H\n         SPACE\n         LR    1,3                                    | Current\n         CH    1,=AL2(OUTBLKL)                        |  output\n         BNH   *+8                                    |   length\n         LH    1,=AL2(OUTBLKL)                        |\n         SPACE\n         LA    0,4(,1)                                | Setup RDW\n         STCM  0,B'0011',PUTRDW                       |\n         XC    PUTCLR,PUTCLR                          |\n         SPACE\n         LA    0,PUTRDW+4                             | Move data\n         MVCL  0,2                                    |\n         SPACE\n         PUT   SYSOUT,PUTBUFF                         | PUT data\n         SPACE\n         LTR   3,3                                    | Check for\n         BP    RD$LLOP                                |  more data\n         SPACE\n         L     0,RD$BLK                               |\n         AH    0,=H'1'                                |\n         ST    0,RD$BLK                               |\n         SPACE\n         B     RD$LOOP                                |\n         SPACE\n*\n* End of input data\n*\n         SPACE\nRD$EOD   DS    0H\n         SPACE\n         CLI   VERIFY$,X'00'                          | Skip?\n         BE    RD$CLOSE                               |\n         SPACE\n         PRMSG ANSI#1L,INIT=YES                       | Print info\n         PRMSG =C'READ OK, BLOCKS PROCESSED'          |\n         PRMSG =X'402020206B2020206B202120',INCPTR=NO |\n         L     0,RD$BLK                               |\n         CVD   0,DWORD                                |\n         ED    0(12,1),DWORD+3                        |\n         PRMSG =C'='                                  |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\nRD$CLOSE DS    0H\n         SPACE\n         FREEMAIN R,LV=65536,A=(9)                    | Free buffer\n         SPACE\n         CLOSE RD$INDCB                               | Try to close\n         LTR   15,15                                  |\n         BZ    RD$CLOSD                               |\n         SPACE\n         PRMSG ANSI#3L,INIT=YES                       | Print it\n         PRMSG =C'FATAL: ERROR CLOSING INPUT DD='     |\n         PRMSG RD$INDD                                |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\n         SETRC ERR$FATL                               | Fatal Error\n         SPACE\n         B     CLOSE                                  | Just leave\n         SPACE\nRD$CLOSD DS    0H\n         SPACE\n         CLI   VERIFY$,X'00'                          | Skip?\n         BE    MAINLOOP                               |\n         SPACE\n         PRMSG ANSI#1L,INIT=YES                       | Print it\n         PRMSG =C'CLOSE COMPLETE FOR INPUT DD='       |\n         PRMSG RD$INDD                                |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\n         B     MAINLOOP                               | Back to main\n         SPACE\nRD$OERR  DS    0H\n         SPACE\n         PRMSG ANSI#3L,INIT=YES                       | Print it\n         PRMSG =C'ERROR: ERROR OPENING INPUT DD='     |\n         PRMSG RD$INDD                                |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\n         SETRC ERR$ERR                                | Error\n         SPACE\n         B     MAINLOOP                               | Back to main\n         SPACE\n         DROP  10,11,12\n         SPACE\nRD$BLK   DS    F                                      | Block Count\nRD$INDCB DCB   DDNAME=INPUT,                                           +\n               MACRF=R,                                                +\n               DSORG=PS,                                               +\n               EODAD=RD$EOD\nRD$INDD  DS    CL8' '\n         LTORG\n         TITLE '@GET - get records from input to AWS tape'\n         SPACE\n@GET     CSECT\n         USING PUTBUFF,10\n         USING @GET,11\n         USING AWSUTIL,12\n         SPACE\n         MVC   GT$INDCB+DCBDDNAM-IHADCB(8),=CL8'INPUT'  Default name\n         SPACE\n         CLI   INARG1,C' '                            | Check DDNAME\n         BE    *+10                                   |\n         MVC   GT$INDCB+DCBDDNAM-IHADCB(8),INARG1     | Set DDNAME\n         SPACE\n         MVC   GT$INDD,GT$INDCB+DCBDDNAM-IHADCB       | Save DDNAME\n         SPACE\n         OPEN  GT$INDCB                               | Open DD\n         LTR   15,15                                  |\n         BNZ   GT$OERR                                |\n         SPACE\n         CLI   VERIFY$,X'00'                          | Skip?\n         BE    GT$START                               |\n         SPACE\n         PRMSG ANSI#1L,INIT=YES                       | Print it\n         PRMSG =C'OPEN COMPLETE FOR INPUT DD='        |\n         PRMSG GT$INDD                                |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\nGT$START DS    0H\n         SPACE\n         XC    GT$BLK,GT$BLK                          | Clear counter\n         SPACE\n         GETMAIN R,LV=65536                           | Get buffer\n         LR    9,1                                    |\n         SPACE\nGT$LOOP  DS    0H\n         SPACE\n         GET   GT$INDCB,(9)                           | Read block\n         SPACE\n         LH    3,GT$INDCB+DCBLRECL-IHADCB             | Calc block\n         LR    2,9                                    |  length\n         SPACE\n         MVC   PREVBLOK,CURRBLOK                      | Cycle bloks\n         ST    3,CURRBLOK                             |\n         SPACE\n         MVC   PUTRDW,=AL2(6+4)                       | Setup RDW\n         XC    PUTCLR,PUTCLR                          |\n         SPACE\n         MVC   PUTCURL,CURRBLOK+3                     | Reverse byte\n         MVC   PUTCURH,CURRBLOK+2                     |  order\n         SPACE\n         MVC   PUTPRVL,PREVBLOK+3                     | Reverse byte\n         MVC   PUTPRVH,PREVBLOK+2                     |  order\n         SPACE\n         MVI   PUTFLG1,AWS#REC                        | Record\n         XC    PUTFLG2,PUTFLG2\n         SPACE\n         PUT   SYSOUT,PUTBUFF                         | Put record\n         SPACE\nGT$LLOP  DS    0H\n         SPACE\n         LR    1,3                                    | Current\n         CH    1,=AL2(OUTBLKL)                        |  output\n         BNH   *+8                                    |   length\n         LH    1,=AL2(OUTBLKL)                        |\n         SPACE\n         LA    0,4(,1)                                | Setup RDW\n         STCM  0,B'0011',PUTRDW                       |\n         XC    PUTCLR,PUTCLR                          |\n         SPACE\n         LA    0,PUTRDW+4                             | Move data\n         MVCL  0,2                                    |\n         SPACE\n         PUT   SYSOUT,PUTBUFF                         | PUT data\n         SPACE\n         LTR   3,3                                    | Check for\n         BP    GT$LLOP                                |  more data\n         SPACE\n         L     0,GT$BLK                               |\n         AH    0,=H'1'                                |\n         ST    0,GT$BLK                               |\n         SPACE\n         B     GT$LOOP                                |\n         SPACE\n*\n* End of input data\n*\n         SPACE\nGT$EOD   DS    0H\n         SPACE\n         CLI   VERIFY$,X'00'                          | Skip?\n         BE    GT$CLOSE                               |\n         SPACE\n         PRMSG ANSI#1L,INIT=YES                       | Print info\n         PRMSG =C'GET OK, RECORDS PROCESSED'          |\n         PRMSG =X'402020206B2020206B202120',INCPTR=NO |\n         L     0,GT$BLK                               |\n         CVD   0,DWORD                                |\n         ED    0(12,1),DWORD+3                        |\n         PRMSG =C'='                                  |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\nGT$CLOSE DS    0H\n         SPACE\n         FREEMAIN R,LV=65536,A=(9)                    | Free buffer\n         SPACE\n         CLOSE GT$INDCB                               | Try to close\n         LTR   15,15                                  |\n         BZ    GT$CLOSD                               |\n         SPACE\n         PRMSG ANSI#3L,INIT=YES                       | Print it\n         PRMSG =C'FATAL: ERROR CLOSING INPUT DD='     |\n         PRMSG GT$INDD                                |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\n         SETRC ERR$FATL                               | Fatal Error\n         SPACE\n         B     CLOSE                                  | Just leave\n         SPACE\nGT$CLOSD DS    0H\n         SPACE\n         CLI   VERIFY$,X'00'                          | Skip?\n         BE    MAINLOOP                               |\n         SPACE\n         PRMSG ANSI#1L,INIT=YES                       | Print it\n         PRMSG =C'CLOSE COMPLETE FOR INPUT DD='       |\n         PRMSG GT$INDD                                |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\n         B     MAINLOOP                               | Back to main\n         SPACE\nGT$OERR  DS    0H\n         SPACE\n         PRMSG ANSI#3L,INIT=YES                       | Print it\n         PRMSG =C'ERROR: ERROR OPENING INPUT DD='     |\n         PRMSG GT$INDD                                |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\n         SETRC ERR$ERR                                | Error\n         SPACE\n         B     MAINLOOP                               | Back to main\n         SPACE\n         DROP  10,11,12\n         SPACE\nGT$BLK   DS    F                                      | Block Count\nGT$INDCB DCB   DDNAME=INPUT,                                           +\n               MACRF=GM,                                               +\n               DSORG=PS,                                               +\n               EODAD=GT$EOD\nGT$INDD  DS    CL8' '\n         LTORG\n         TITLE '@TAPE - Copy tape via excp to AWS tape'\n         SPACE\n@TAPE    CSECT\n         USING PUTBUFF,10\n         USING @TAPE,11\n         USING AWSUTIL,12\n         SPACE\n         MVC   TP$INDCB+DCBDDNAM-IHADCB(8),=CL8'INPUT' | Default name\n         SPACE\n         CLI   INARG1,C' '                            | Check DDNAME\n         BE    *+10                                   |\n         MVC   TP$INDCB+DCBDDNAM-IHADCB(8),INARG1     | Set DDNAME\n         SPACE\n         MVC   TP$INDD,TP$INDCB+DCBDDNAM-IHADCB       | Save DDNAME\n         SPACE\n         OPEN  TP$INDCB                               | Open DD\n         LTR   15,15                                  |\n         BNZ   TP$OERR                                |\n         SPACE\n         XR    1,1                                    |\n         ICM   1,B'0111',TP$INDCB+DCBDEBA-IHADCB      | DEB <-- DCB\n         ICM   1,B'0111',DEBSUCBB-DEBBASIC(1)         | UCB <-- DEB\n         SPACE\n         CLI   UCBTBYT3-UCBOB(1),UCB3TAPE             | Check for tape\n         BNE   TP$NOTAP                               |\n         SPACE\n*\n* The 02 command is read forward on all tape drives except 3590\n* The 06 command is read forward on 3590 tape drives\n*\n         MVI   TP$READ,X'02'                          | Read Forward\n         CLC   =X'78048083',UCBTYP-UCBOB(1)           | 3590?\n         BNE   *+8                                    |\n         MVI   TP$READ,X'06'                          | Read Forward\n         SPACE\n         CLI   VERIFY$,X'00'                          | Skip?\n         BE    TP$START                               |\n         SPACE\n         PRMSG ANSI#1L,INIT=YES                       | Print it\n         PRMSG =C'OPEN COMPLETE FOR INPUT DD='        |\n         PRMSG TP$INDD                                |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\nTP$START DS    0H\n         SPACE\n         CLC   INVERB,=CL8'TAPEALL'                   | If TAPEALL,\n         BNE   TP$GETM                                |  rewind tape\n         SPACE\n         XC    IOB,IOB\n         MVI   IOBFLAG1,B'11000010'                   | Init IOB\n         MVI   IOBFLAG2,B'00100000'                   |\n         LA    0,ECB                                  |\n         STCM  0,B'0111',IOBECBPB                     | Point to ECB\n         LA    0,TP$INDCB                             |\n         STCM  0,B'0111',IOBDCBPB                     | Point to DCB\n         LA    0,TP$REW                               |\n         STCM  0,B'0111',IOBSTRTB                     | Point to CCW\n         SPACE\n         EXCP  IOBSTDRD                               | Execute ch prog\n         LTR   15,15                                  |\n         BNZ   TP$EXCPE                               |\n         SPACE\n         WAIT  ECB=ECB                                | Wait for I/O\n         SPACE\nTP$GETM  DS    0H\n         SPACE\n         GETMAIN R,LV=65536                           | Get buffer\n         LR    9,1                                    |\n         SPACE\n         STCM  9,B'0111',TP$READ+1                    | Save buf addr\n         SPACE\n         XC    TP$BLK,TP$BLK                          | Clear counter\n         SPACE\nTP$LOOP  DS    0H\n         SPACE\n         XC    IOB,IOB\n         MVI   IOBFLAG1,B'11000010'                   | Init IOB\n         MVI   IOBFLAG2,B'00100000'                   |\n         LA    0,ECB                                  |\n         STCM  0,B'0111',IOBECBPB                     | Point to ECB\n         LA    0,TP$INDCB                             |\n         STCM  0,B'0111',IOBDCBPB                     | Point to DCB\n         LA    0,TP$READ                              |\n         STCM  0,B'0111',IOBSTRTB                     | Point to CCW\n         SPACE\n         EXCP  IOBSTDRD                               | Execute ch prog\n         LTR   15,15                                  |\n         BNZ   TP$EXCPE                               |\n         SPACE\n         WAIT  ECB=ECB                                | Wait for I/O\n         SPACE\n         TM    IOBUSTAT,IOBUSB7                       | Check for\n         BZ    TP$DATA                                |  Tape Mark\n         SPACE\n         CLC   INVERB,=CL8'TAPEFILE'                  | Leave if only\n         BE    TP$EOD                                 |  1 file\n         SPACE\n         XR    2,2                                    | Clear ptr\n         XR    3,3                                    |  and len\n         SPACE\n         B     TP$WRITE                               |\n         SPACE\nTP$DATA  DS    0H\n         SPACE\n         CLI   ECB,X'7F'                              | I/O err?\n         BNE   TP$EOD                                 |\n         SPACE\n         L     3,=X'0000FFFF'                         | Record length\n         XC    DWORD(4),DWORD                         |\n         MVC   DWORD+2(2),IOBCSW+5                    |\n         S     3,DWORD                                |\n         SPACE\n         LR    2,9                                    | Block Pointer\n         SPACE\nTP$WRITE DS    0H\n         SPACE\n         MVC   PREVBLOK,CURRBLOK                      | Cycle bloks\n         ST    3,CURRBLOK                             |\n         SPACE\n         MVC   PUTRDW,=AL2(6+4)                       | Setup RDW\n         XC    PUTCLR,PUTCLR                          |\n         SPACE\n         MVC   PUTCURL,CURRBLOK+3                     | Reverse byte\n         MVC   PUTCURH,CURRBLOK+2                     |  order\n         SPACE\n         MVC   PUTPRVL,PREVBLOK+3                     | Reverse byte\n         MVC   PUTPRVH,PREVBLOK+2                     |  order\n         SPACE\n         MVI   PUTFLG1,AWS#REC                        | Record\n         LTR   3,3                                    |\n         BP    *+8                                    |\n         MVI   PUTFLG1,AWS#MARK                       | or tapemark\n         XC    PUTFLG2,PUTFLG2                        |\n         SPACE\n         PUT   SYSOUT,PUTBUFF                         | Put record\n         SPACE\nTP$LLOP  DS    0H\n         SPACE\n         LTR   3,3                                    | Check for\n         BNP   TP$BLKC                                |  more data\n         SPACE\n         LR    1,3                                    | Current\n         CH    1,=AL2(OUTBLKL)                        |  output\n         BNH   *+8                                    |   length\n         LH    1,=AL2(OUTBLKL)                        |\n         SPACE\n         LA    0,4(,1)                                | Setup RDW\n         STCM  0,B'0011',PUTRDW                       |\n         XC    PUTCLR,PUTCLR                          |\n         SPACE\n         LA    0,PUTRDW+4                             | Move data\n         MVCL  0,2                                    |\n         SPACE\n         PUT   SYSOUT,PUTBUFF                         | PUT data\n         SPACE\n         B     TP$LLOP\n         SPACE\nTP$BLKC  L     0,TP$BLK                               |\n         AH    0,=H'1'                                |\n         ST    0,TP$BLK                               |\n         SPACE\n         B     TP$LOOP                                |\n         SPACE\n*\n* End of input data\n*\n         SPACE\nTP$EOD   DS    0H\n         SPACE\n         CLI   VERIFY$,X'00'                          | Skip?\n         BE    TP$CLOSE                               |\n         SPACE\n         PRMSG ANSI#1L,INIT=YES                       | Print info\n         PRMSG =C'READ OK, BLOCKS PROCESSED'          |\n         PRMSG =X'402020206B2020206B202120',INCPTR=NO |\n         L     0,TP$BLK                               |\n         CVD   0,DWORD                                |\n         ED    0(12,1),DWORD+3                        |\n         PRMSG =C'='                                  |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\nTP$CLOSE DS    0H\n         SPACE\n         FREEMAIN R,LV=65536,A=(9)                    | Free buffer\n         SPACE\n         CLOSE TP$INDCB                               | Try to close\n         LTR   15,15                                  |\n         BZ    TP$CLOSD                               |\n         SPACE\n         PRMSG ANSI#3L,INIT=YES                       | Print it\n         PRMSG =C'FATAL: ERROR CLOSING INPUT DD='     |\n         PRMSG TP$INDD                                |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\n         SETRC ERR$FATL                               | Fatal Error\n         SPACE\n         B     CLOSE                                  | Just leave\n         SPACE\nTP$CLOSD DS    0H\n         SPACE\n         CLI   VERIFY$,X'00'                          | Skip?\n         BE    MAINLOOP                               |\n         SPACE\n         PRMSG ANSI#1L,INIT=YES                       | Print it\n         PRMSG =C'CLOSE COMPLETE FOR INPUT DD='       |\n         PRMSG TP$INDD                                |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\n         B     MAINLOOP                               | Back to main\n         SPACE\nTP$OERR  DS    0H\n         SPACE\n         PRMSG ANSI#3L,INIT=YES                       | Print it\n         PRMSG =C'ERROR: ERROR OPENING INPUT DD='     |\n         PRMSG TP$INDD                                |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\n         SETRC ERR$ERR                                | Error\n         SPACE\n         B     MAINLOOP                               | Back to main\n         SPACE\nTP$NOTAP DS    0H\n         SPACE\n         CLOSE TP$INDCB                               | Try to close\n         SPACE\n         PRMSG ANSI#3L,INIT=YES                       | Print it\n         PRMSG =C'ERROR: INPUT DD='                   |\n         PRMSG TP$INDD                                |\n         PRMSG =C' IS NOT ON A TAPE DEVICE'           |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\n         SETRC ERR$ERR                                | Error\n         SPACE\n         B     MAINLOOP                               | Back to main\n         SPACE\nTP$EXCPE DS    0H\n         SPACE\n         PRMSG ANSI#3L,INIT=YES                       | Print it\n         PRMSG =C'ERROR: EXCP ERROR ON INPUT DD='     |\n         PRMSG TP$INDD                                |\n         PUT   SYSPRINT,OUTLINE                       |\n         SPACE\n         SETRC ERR$ERR                                | Error\n         SPACE\n         B     TP$CLOSE                               | Back to main\n         SPACE\n         DROP  10,11,12\n         SPACE\nTP$BLK   DS    F                                      | Block Count\nTP$INDCB DCB   DDNAME=INPUT,                                           +\n               MACRF=E,                                                +\n               EODAD=TP$EOD\nTP$INDD  DS    CL8' '\n         SPACE\nTP$READ  DC    0D'0',X'02',AL3(0),X'2000',AL2(65535)  | Read   CCW\nTP$REW   DC    0D'0',X'07',AL3(0),X'6000',AL2(1)      | Rewind CCW\n         DC          X'03',AL3(0),X'2000',AL2(1)      | Nop    CCW\n         SPACE\n         LTORG\n         TITLE 'DESCTs'\nPUTBUFF  DSECT\nPUTRDW   DS    1H\nPUTCLR   DS    1H\nPUTCURL  DS    1B\nPUTCURH  DS    1B\nPUTPRVL  DS    1B\nPUTPRVH  DS    1B\nPUTFLG1  DS    1B\nPUTFLG2  DS    1B\nPUTDATA  DS    0B\n         DCBD  DSORG=PS\n         IEZDEB\n         IEFUCBOB\n         END\n/*\n//*\n//* Link edit the program\n//*\n//LKED     EXEC PGM=IEWL,COND=(4,LT)\n//SYSLIN   DD DISP=(OLD,DELETE),DSN=&&SYSLIN\n//SYSLMOD  DD DISP=(,PASS),DSN=&&SYSLMOD(AWSUTIL),SPACE=(TRK,(1,1,1))\n//SYSUT1   DD UNIT=VIO,SPACE=(TRK,(30,30))\n//SYSPRINT DD SYSOUT=*\n//*\n//* Run the program\n//*\n//*  This is a simple test to see if things are ok.  It should create\n//* a simple SL tape with a single 80 byte record read from INPUT\n//*\n//AWSUTIL  EXEC PGM=*.LKED.SYSLMOD,COND=(4,LT)\n//SYSPRINT DD SYSOUT=*\n//SYSOUT   DD SYSOUT=* <--- REPLACE WITH ACTUAL DATASET\n//INPUT    DD *\nTest record\n//SYSIN    DD *\nVERIFY\nVOL1MYTAPE                               TAPE OWNER\nHDR1SYS1.TEST.DATA   MYTAPE00010001      0001640001640000000IBM OS/VS 370\nHDR2F00080000800TAPEJOB1/TAPESTEP\nTAPEMARK\nREAD INPUT\nTAPEMARK\nEOF1SYS1.TEST.DATA   MYTAPE00010001      0001640001640000001IBM OS/VS 370\nEOF2F00080000800TAPEJOB1/TAPESTEP\nTAPEMARK\nTAPEMARK\n/*\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT477/FILE477.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT477", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}