{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012818000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 6290102, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 13, "INMDSNAM": "CBT.V500.FILE797.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 6290102, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 6290102, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE797.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00a\\x07'", "DS1TRBAL": "b'O\\xf4'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05b\\x00\\x0b\\x05i\\x00\\x03\\x00b'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00)\\x01 \\x17\\x1f\\x01 \\x17\\x1f\\x18\\x05\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-06-19T00:00:00", "modifydate": "2020-06-19T18:05:29", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-500"}, "text": "REGULAR CBT TAPE - VERSION 500    FILE:  797\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT500.FILE797\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 43 MEMBERS COUNTED; CUMULATIVE SIZE IS 59,369 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   06/19/20    18:05:29    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@ARTICLE": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\t\\x00\\x7f\\x01\\t\\x00\\x7f\\x14\\x12\\x01\\x99\\x01\\x99\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2009-01-07T00:00:00", "modifydate": "2009-01-07T14:12:59", "lines": 409, "newlines": 409, "modlines": 0, "user": "HELP"}, "text": "                    TSO AUTHORIZATION TABLES\n\n(c) Copyright 2009 by Sam Golob.  All rights reserved.\n\n     TSO sessions rely on a set of tables containing program names, when\nthey test a TSO user's ability to run an APF-authorized program, or an\nAPF-authorized TSO command, or when they test if a TSO command can be\nexecuted under TSO-in-batch.  People outside of IBM do not generally\npossess definitive information about where these tables actually are,\nalthough they have general knowledge about how to change them.  In this\narticle, I hope to put most doubts to rest, and after reading this\narticle, you should have a very good idea about your TSO session's\nauthorization tables, where they are, and how they got there.\n\n\nHISTORY OF THE AUTH TABLES\n\n     In the \"ancient\" days, before TSO/E, which many of us still\nremember, the four CSECTs:  IKJEFTE2 (AUTHCMD), IKJEFTE8 (AUTHPGM),\nIKJEFTAP (AUTHTSF - which didn't exist then), and IKJEFTNS (NOTBKGND),\nwere linkedited into the IKJEFT02 load module (mainline TSO).  So I\nlearned a trick about what you should do, if you want to expand which\nprograms you would like authorized in your own TSO session.  The trick\nwas to make your own copy of the IKJEFT02 load module, stick it in an\nAPF-authorized STEPLIB that was in your TSO LOGON PROC, and linkedit\nyour own copies of the IKJTFTE2 and IKJEFTE8 CSECTs, in particular, into\nthat copy of IKJEFT02.  This worked fine and did the job.  You had your\nown personal command and program authorizations, which the other TSO\nusers did not have.  And that is what you, as the \"system doctor\",\nneeded to have, as opposed to what the \"ordinary users\" needed.\n\n     However, there was one problem.  When normal maintenance came in\nfrom the monthly PUT tapes, and hit the other CSECTs in IKJEFT02, or\nelse if a new version of TSO came out, either your own individual copy\nof IKJEFT02 didn't get the maintenance, or else you'd have to copy it\nover again, and re-linkedit the IKJEFTE2 and IKJEFTE8 CSECTs back again.\nIf you didn't do that, the result would be that your own TSO session\nwould become backleveled, often to the point where you'd get some abends\nthat you didn't really want.\n\n     Arrive TSO/E, with one improvement (among many other non-related\nones).  The four CSECTs:  IKJEFTE2, IKJEFTE8, IKJEFTNS, and IKJEFTAP\nwere taken out of IKJEFT02 and inserted into their own load module,\nwhich was called IKJTABLS.  IKJTABLS didn't contain any executable\ncode--it just contained program list tables.  The trick for the special\nuse of your own IKJTABLS was similar to that for IKJEFT02.  If the\nIKJTABLS load module was present in an APF-authorized STEPLIB in your\nTSO session, it would override the same-named CSECTs that were in LPALIB\nor wherever (which the public would use), and you yourself could get\nyour own personal special TSO command authorization.  But this time, the\nauthorization tables, being in a completely separate load module, were\nindependent of which TSO/E release level and maintenance level you were\nrunning.  The \"auth CSECTs\" were no longer connected to \"mainline TSO\",\nand when changing them, you would not interfere with applying normal TSO\nmaintenance.  So TSO itself was now in sync with current maintenance,\nand you had your own personal \"auth tables\" too.  This was a much better\nsituation than before.\n\n     The next improvement in TSO/E came because of the push within IBM,\nspurred on by banks and other institutions which had to remain up for 24\nX 7, to eliminate IPLs.  In the late 80's and early 90's, IBM made a big\neffort to convert hard-coded tables that were created at IPL time, to\ndynamically created tables in common storage, that could be re-created\nat any time after IPL, usually via an operator command.\n\n     Around this time, the IKJTSOxx PARMLIB member was created.  It was\ngiven the capability of renewing a copy of the TSO auth tables in common\nstorage, at any time, via the PARMLIB UPDATE(xx) TSO command.  The\nadvantage of this was obvious, making it possible for installations to\nauthorize commands and programs to TSO, whenever they wanted to do so,\neven in-between IPLs.  Later on, with TSO/E Release 3 (corresponding to\nz/OS 1.3), the SET IKJTSO=xx operator command was also introduced, and\nwas given the same power and action as the PARMLIB UPDATE(xx) TSO\ncommand.  The PARMLIB UPDATE(xx) facility was created first.  I think\nthat's because IBM wanted to give this \"dynamic auth\" capability to\nsystems programmers only, but later they relented, and realized that you\nneed an operator command too, sometimes.  Again, the advantage of the\noperator SET command, is that you don't need to have a TSO session up\nwhen you need to change something.\n\n     In modern z/OS systems, the default auth tables in the system are\ncreated from the default PARMLIB member IKJTSO00, or whatever IKJTSOxx\nmember is pointed to, by the active IEASYSxx member.  So at this point,\nwe have to realize that \"everybody else's\" TSO/E authorizations come\nfrom the PARMLIB member IKJTSOxx that is currently active.\n\n     Nevertheless, if your session's TSO/E authorizations come from a\ncopy of the IKJTABLS load module that is in an APF-authorized STEPLIB,\nthey will STILL COMPLETELY OVERRIDE the default tables.  That is because\nyour TSO session's LWA pointed-to tables were copied from your STEPLIB\nload library at LOGON time, instead of being copied from the\nPARMLIB-created copies of the tables in common storage.  We'll see how\nthis works, a bit later on.\n\n     However, if the PARMLIB member IKJTSOxx does NOT contain one of the\nkeywords:  AUTHCMD, AUTHPGM, AUTHTSF, or NOTBKGND, then that respective\ntable is defaulted from its copy in IKJTABLS that is in LPALIB.  Again,\nif your session has an authorized STEPLIB with IKJTABLS, then your\nSTEPLIB's IKJTABLS will override any other default table that is in the\nenvironment.  We'll discuss all these facts in much greater detail\nlater.\n\n\nTABLE LENGTHS AND TABLE DELIMITERS\n\n     At this point, I just want to interrupt the discussion to talk\nabout the lengths of the tables that were created by the PARMLIB TSO\ncommand (or by the SET IKJTSO=xx operator command).\n\n     When the PARMLIB processing creates one of its incore tables in\ncommon storage, the length of the created table is measured, and it is\nrecorded in the CTLT control block (some details to be discussed later).\nWhen the auth tables are created (for a user's TSO session) via their\nbeing copied from an IKJTABLS load module in STEPLIB, no lengths of\ntables are recorded in the system.  This is a big difference.\n\n     So the question is, if no table lengths are recorded, how does the\nsystem \"know\" where the table ends?  Answer is, that all the TSO auth\ntables are delimited by a blank table entry.  In other words, if the\nprogram name is 8 blanks, then all table entries after that point, are\nignored, and the table is deemed to end at the blank entry.  This is a\nVERY important fact for us to know.\n\n     Since we have the possibility of an \"auth table\" coming from any of\nseveral origins, there have to be \"flags\" in the system, telling you how\nto deal with that particular copy of that particular table.  The Logon\nWork Area (LWA), which we'll talk about later, contains such flags to\ndeal with a TSO session's auth tables that come from various origins.\nBut in any case, the bottom line is that A BLANK TABLE ENTRY WILL ALWAYS\nDELIMIT THE TABLE, no matter what its origin was.\n\n\nYOUR OWN COPY OF THE AUTH TABLES\n\n     Consider this.  It is almost universally true that when you set up\nan entry in a PARMLIB member (that is actively being used by the\nsystem), this entry gets translated into some information that is in an\nMVS control block in storage somewhere, usually in common storage.  And\nthe system itself \"knows\" how to get to that information, through an\nestablished path.  To summarize:  Information in a PARMLIB member will\n(almost) always translate into information in common storage, which the\nsystem can get to, via a known path.\n\n     There's a problem with information in common storage, especially\nwhen it comes to TSO.  The TSO developers always have to consider a case\nwhere a thousand TSO users are trying to LOGON to their TSO sessions at\nthe same time.  In a very large installation, it might happen, and the\nTSO developers have to consider this \"boundary condition\" (so to speak)\nas being one of their developmental constraints.  What happens when a\nthousand users (or any other large number) are trying to get to common\nresources?  There will be contention somewhere, and there will be a\nbackup in trying to get to some of the (common) resources that are shared\nby all (or many) of these TSO sessions.\n\n     One solution to this general problem, is to give each TSO user his\nor her own copy of a resource, rather than for the user to continually\ntry and access the common resource.  Then, contention (by many users)\nfor the common resource is minimized or eliminated.  This happened with\nthe TSO authorization tables:  IKJEFTE2, IKJEFTE8, IKJEFTAP, and\nIKJEFTNS (AUTHCMD, AUTHPGM, AUTHTSF, and NOTBKGND respectively).  At one\npoint in time, the TSO developers decided to GIVE EACH TSO SESSION its\nOWN COPY of these authorization tables.  The \"individual copy\" of these\nauthorization tables is created within the userid's address space at\nLOGON time, in Key 0, Subpool 252 storage, and they are pointed to by\naddress fields in the Logon Work Area (LWA) which is also created for\neach TSO userid at LOGON time.  Each TSO userid has its own unique Logon\nWork Area that was created for it.  And the LWA-pointed-to copies of the\nauthorization tables are the ones which your TSO session actually refers\nto!  Most people don't know this.  I ran a survey test question among\nold MVS veterans with 25 years of experience or more.  Most of them did\nnot know where the \"real\" TSO authorization tables were!\n\n     Getting back to the subject, how do the individual copies of the\nTSO \"auth tables\" get there?  At LOGON time, they are copied into\nGETMAINed storage in Key 0, Subpool 252 from any of several sources.  As\nfar as I can determine, the IKJEFTP1 TSO initialization module (executed\nat LOGON time) performs this construction process.\n\n     Where are the tables copied from?  Under usual circumstances, they\nare copied from either of two places.  One place, is from the \"common\nstorage\" tables that are created from the active IKJTSOxx PARMLIB\nmember.  If the keywords AUTHCMD, AUTHPGM, AUTHTSF, and NOTBKGND were\ncoded in the IKJTSOxx PARMLIB member, together with an appropriate list\nof program names, then \"TSO system initialization\" at IPL time will\ncreate several areas in common storage which contain these tables.\nThese areas can be \"renewed\" or \"re-created\" whenever you do a PARMLIB\nUPDATE(xx) TSO command, or a SET IKJTSO=xx operator command, provided\nthat you have changed the list of names in the IKJTSOxx member.  If you\ndo not issue a(nother) PARMLIB UPDATE(xx) command or a(nother) SET\nIKJTSO=xx command, then these tables remain in place, in common storage,\nfor the duration of the IPL.  When a TSO user does its LOGON, the \"auth\ntables\" are usually copied from the \"common storage\" version of these\ntables, which are intended for \"most TSO users\".  I'll talk about the\n\"second possible place\" soon, where it's possible for your TSO session\nto get its \"auth tables\".\n\n     For the record, if you really want to know where the \"common\nstorage\" versions of the \"auth tables\" are, you do as follows:  The CVT\nhas an address pointer to the TSVT (TSO Vector Table) at +X'9C' from the\nCVT.  The TSVT points to the TPVT (TSO Parmlib Vector Table) at +X'4C'\nfrom the TSVT.  The TPVT points to the CTLT control block at +X'14'.\nAnd the CTLT points to the rest of the table addresses.  The TPVT and\nCTLT are not documented by IBM for public use, and IBM doesn't give out\nmacros in the macro libraries which describe them.  However, approximate\ndescriptions of these control blocks, which were figured out by users,\ncan be found on CBT Tape File 731 in the MODGEN member, or in CBT File\n492 in the SHOWMACS member.  So the macros IKJTPVT and IKJCTLT in CBT\nTape File 731 or File 492 will do the job very well, for us.  I have\nwritten several commands:  ADIS, ASUB, and LSLT, which can be found as\nload modules in the LOADLIB member of CBT File 185, that can display\nand/or directly manipulate the \"common storage\" version of the \"auth\ntables\".\n\n     The second possible place for your TSO session to get its tables\ncopied from, will happen if two circumstances are true.  First, the TSO\nsession's LOGON PROC (i.e. it's JCL) has to contain a STEPLIB DD to an\nAPF-authorized load library.  Second, a properly linkedited copy of the\nIKJTABLS load module must be present in the STEPLIB library, with one,\nseveral, or all, of the CSECTs IKJEFTE2, IKJEFTE8, IKJEFTAP, and\nIKJEFTNS present.  In that case, TSO LOGON (the IKJEFTP1 program which\ncreates your session) will copy the \"auth tables\" individually from the\nappropriate CSECT in the IKJTABLS load module that's in your authorized\nSTEPLIB library, and put that table into Key 0, Subpool 252 storage,\npointed to by the Logon Work Area.\n\n     Remember now, that the LWA version of the \"auth tables\" are the\nones which your TSO session actually uses.  So if your TSO session has\nan APF-authorized load library as a STEPLIB in its LOGON PROC, with an\nIKJTABLS load module in it, then LOGON DOES NOT GET THAT TABLE from the\n\"common storage\" copy.  Therefore the STEPLIB version of the table will\nCOMPLETELY OVERRIDE the version of that table in common storage, which\nwas created by the (active) PARMLIB member IKJTSOxx.  Thus we see that\nyour \"auth tables\" for your TSO session can come from one of two places,\nEITHER, OR, BUT NOT BOTH!\n\n     What if AUTHCMD, AUTHPGM, AUTHTSF, or NOTBKGND are NOT coded in the\nIKJTSOxx PARMLIB member?  And additionally, there is no authorized\nSTEPLIB library, or it doesn't contain an IKJTABLS load module?  Then\nwhat happens?\n\n     In THAT case, the LWA will NOT point to the appropriate table in\nKey 0, Subpool 252 storage.  But it will merely point to the appropriate\ndefault CSECT:  IKJEFTE2, IKJEFTE8, IKJEFTAP, or IKJEFTNS that is in the\ncopy of IKJTABLS that is in LPALIB.  In that case, the LPALIB version of\nthe table will be the one which your session uses.\n\n\nNEW WAYS OF LOADING TSO AUTH TABLES\n\n     Dan Dalby has written a marvelous \"dynamic\" STEPLIB command (found\nin CBT Tape File 452) which can perform the creation of a STEPLIB in a\nTSO session, exactly the way IBM does it with JCL.  This STEPLIB command\nhas to be APF-authorized, but once it is, and you've used it, you've\ngiven your TSO session access to programs that it wouldn't otherwise\nhave had access to.\n\n     If Dan's STEPLIB command is executed against an APF-authorized load\nlibrary, the effect is exactly as if you have an APF-authorized STEPLIB\nin the JCL, but there is one great big difference when it comes to\nloading the auth tables into your TSO session.  Dan's STEPLIB command\nwas not in effect at your session's LOGON time.  If you have an\nauthorized STEPLIB, statically coded in the LOGON PROC, it WAS there at\nLOGON time.  Therefore, if the authorized STEPLIB was there at LOGON\ntime, and it has an IKJTABLS load module in it, the auth tables come\nfrom IKJTABLS.  But if the STEPLIB was NOT there at LOGON time, then the\ntables still come from the \"common storage\" tables that were created\nfrom the active IKJTSOxx PARMLIB member.  Therefore, even though you\nhave executed Dan's STEPLIB command against an APF-authorized load\nlibrary that contains a big IKJTABLS member, you don't have all the\npower you need to execute all the programs, because you are still using\nthe \"common storage auth tables\" and not the (presumably bigger) tables\nthat were coded in the STEPLIB.\n\n     How can we \"dynamically load\" the STEPLIB, and then \"dynamically\nload\" the tables after that?\n\n     Dan and I have independently written two programs which will do\nthis.  Dan's program is called LWATMGR (LWA Table Manager).  My program\nis called LLWA, or (re)Load the LWA.  These two programs can load a\nfresh set of auth tables, from any of 3 different sources, into Key 0\nSubpool 252 storage in your TSO session's address space, and then\nre-point the LWA pointers and flags to properly point to the new tables.\nYour TSO session will then honor the new tables, and not the old ones.\n\n     In addition to my LLWA program, I have written another program\ncalled TSUB, which manipulates pre-existing auth tables that are\npointed to by the LWA.  In functionality, LWATMGR will approximately\nequal the combined capabilities of LLWA and TSUB.  But they do have\nnon-overlapping capabilities too, so it would pay for you to learn about\nall three programs.  These programs are found in the CBT Tape collection\n(at www.cbttape.org on the Updates Page) in File 797.\n\n     In order to get full capability with your \"auth tables\" later, you\nwill have to pre-authorize just two programs in the AUTHCMD table.\nThese would be either STEPLIB and LWATMGR, or STEPLIB and LLWA.\nActually, if you have LLWA or LWATMGR loaded into an authorized load\nlibrary already, that your TSO session has access to, you just have to\npre-authorize either one of these, and you can include STEPLIB in the\nAUTHCMD (IKJEFTE2) list in your new freshly loaded tables.\n\n     So what we do, is to use LLWA or LWATMGR to load a fresh set of\nauth tables for your own TSO session.  And then, it doesn't matter what\nauth tables your TSO session used before.  The combined action of the\nSTEPLIB program and either LLWA or LWATMGR will then exactly duplicate\nthe effect of an authorized STEPLIB in your LOGON PROC, without your\nactually needing to have a special LOGON PROC for yourself.\n\n\nSOURCES OF AUTH TABLES FOR RELOADING\n\n     Both the LLWA and LWATMGR programs can load a new set of auth\ntables from either of 3 sources:  An IKJTABLS-like load module, an\nIKJTSOxx-like LRECL=80 PARMLIB-like dataset (sequential or a pds\nmember), or a raw list of program names, with LRECL=8.  This list of\nnames is as \"bare-bones\" a piece of input as you'll ever need, and it\ntakes very little disk space to store it.  In addition, the LLWA program\ncan convert either load library input, or PARMLIB-like input into the\nLRECL=8 list input, so you can conveniently store the lists away.\n\n     The LRECL=8 list input is most fascinating, in my view.  You\nspecify which table is being loaded, with a special 8-byte header.  For\nthe IKJEFTE2 table, the header in the list, is ---E2---.  For the\nIKJEFTE8 table, the header entry is ---E8---.  And similarly, ---AP---\nand ---NS--- will cause the reloading of those respective tables, with\nall the program name entries that follow that header (until encountering\neither the next header, or the end-of-file).  Again, the LLWA program can\nconvert either load-module input or PARMLIB-like input into LRECL=8\n\"name list\" input.\n\n     For details as to how to run the LWATMGR, LLWA, and TSUB programs,\nplease see CBT Tape File 797, which has source code for all of them, as\nwell as HELP members for them.\n\n     My recommendation would be to store all of your auth tables as\nLRECL=8 lists, as members of a pds.  The pds will take up very little\nroom.  For example if the blocksize of the pds is 6000, then 750 table\nentries will fit in just one block.  Therefore, the data to rebuild all\nof your auth tables will probably fit into just one block of data.  Now\nthat's compact!  If you want to hide your lists and store them offsite,\njust put the pds into TSO XMIT format and download it in BINARY to a PC,\ngiving the XMIT-format dataset any name you want.\n\n     You can sort-merge all of your auth tables to get one big list.  Or\nelse, you can just load \"specialty tables\" as the need arises.  You've\ngot a lot of power here.\n\n\nTHE EFFECT OF PARMLIB UPDATE(xx)\n\n     There's one more fact here, which you should know about.  There are\nflags in the LWA for each of the four tables, saying whether they were\nloaded into your TSO session (presumably at LOGON time) from PARMLIB or\nfrom a STEPLIB.  If the flag bit is 0, that table was presumed to be\nloaded from PARMLIB.  If that flag bit is 1, then the table is presumed\nto have been loaded from STEPLIB.  What happens to the tables for your\nTSO session, when a PARMLIB UPDATE(xx) is done, to change one or more of\nthe tables?\n\n     Well, IBM would like that every active TSO session should use the\nnew tables.  So the PARMLIB command goes around, across address spaces,\nvisits each active TSO session, and looks at each of its auth tables.\nIf the LWA flag for that table says that it came from PARMLIB, then the\nPARMLIB command replaces the given table with a new one, dynamically.\nSo the effect is that if OUR new tables were marked as if they came from\nPARMLIB, then a PARMLIB UPDATE(xx) command would overlay our work with\nthe common tables again.  Therefore, both the LLWA and LWATMGR commands\nwill mark their newly created tables as if they came from STEPLIB rather\nthan PARMLIB, so a PARMLIB UPDATE(xx) command would not re-overlay them.\n\n     An additional consequence comes out from this.  PARMLIB UPDATE(xx)\nhas the effect of making a global change to the auth tables.  Suppose we\nonly want to test a new set of auth tables on one session!  Then we use\neither the LWATMGR or LLWA commands to limit the effect of the new auth\ntable(s) to just the session that invoked them.  This way, we have a\nLOCAL change and not a GLOBAL change.  Thus we can use the new LLWA\nand/or LWATMGR commands to test a new auth table on only one TSO userid,\nwithout consequences for the rest of the TSO sessions in the LPAR.\n\n\nSUMMARY\n\n     The TSO authorization tables (AUTHCMD, AUTHPGM, AUTHTSF and\nNOTBKGND) which your TSO session uses, are local tables in your own\naddress space, that were either copied from the \"common storage\" tables,\ncreated from the IKJTSOxx PARMLIB member, or were copied from an\nIKJTABLS load module in a STEPLIB that is APF-authorized to your TSO\nsession.  The active tables are pointed to, and described, by addresses\nand flags in the LWA (Logon Work Area) which is unique to your TSO\nsession.  Your TSO session's auth tables are created during LOGON\nprocessing, at LOGON time, by the IKJEFTP1 program.  These can be\nreplaced later, by either of the authorized TSO commands, LLWA or\nLWATMGR, which can be found on the CBT collection (www.cbttape.org)\non the Updates page, in File 797.\n\n     The LLWA and LWATMGR programs can take new table input in three\nformats:  load module input, PARMLIB member type input, or LRECL=8 name\nlist input.  See File 797 for the details.  It is my experience that\nyour auth tables are most conveniently stored in LRECL=8 input, as\nmembers of a pds.  The LLWA program can convert auth table input from\neither load module format or PARMLIB-like format into LRECL=8 list\nformat, for convenient storage and later use.\n\n     I hope that this article will open your minds to being able to\ncustomize your TSO environment better, and with more flexibility.  Your\nrole as \"system doctors\" will be greatly enhanced by this knowledge and\nby these new capabilities.\n\n     Best of luck to all of you.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@ARTICL2": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00$\\x01\\t\\x03\\x7f\\x01\\x17\\x11?\\x14F\\x01L\\x01@\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2009-02-06T00:00:00", "modifydate": "2017-04-23T14:46:24", "lines": 332, "newlines": 320, "modlines": 0, "user": "HELP"}, "text": "               TSO AUTHORIZATION TABLES - Part 2\n\n(c) Copyright 2009 by Sam Golob.  All rights reserved.\n\nTOOLS TO MANIPULATE OR REBUILD THE AUTH TABLES:\nASUB, TSUB, LLWA, and LWATMGR\n\n      In our last article, we discussed the TSO authorization tables in\ngeneral, the fact that they consist of lists of program names, and we\nsaid something about what each of the lists accomplishes.  There are\nfour main lists:  These are AUTHCMD (module IKJEFTE2), AUTHPGM (module\nIKJEFTE8), AUTHTSF (module IKJEFTAP), and NOTBKGND (module IKJEFTNS).\nAUTHCMD lists all TSO commands that are allowed to run APF authorized\nunder your TSO session.  AUTHPGM lists all programs that can run APF\nauthorized when called by your TSO session.  AUTHTSF lists all programs\nthat can get authorized using the TSO Service Facility.  And NOTBKGND\nlists all TSO commands that cannot be run under TSO-in-batch.\n\n      As systems programmers, we all know how to set the lists of\nprogram names in each of these categories, by creating or modifying an\nIKJTSOxx PARMLIB member.  Then, once the member is created, we issue a\nPARMLIB UPDATE(xx) TSO command or a SET IKJTSO=xx operator command to\nput that member into effect.  What happens to the system as a result of\nthese commands, is what most people don't know about.  This is part of\nwhat we're going to talk about.  What comes next, though, will be some\ninstructions about how we can directly manipulate the in-core program\ntables that are constructed from the PARMLIB IKJTSOxx member.\n\n      When a PARMLIB UPDATE(xx) command, or an IPL, or a SET IKJTSO=xx\noperator command is issued, in-core tables:  IKJEFTE2, IKJEFTE8,\nIKJEFTAP, and IKJEFTNS are created in common storage.  These become\ntemplates for the corresponding tables that will belong to (almost)\nevery TSO session that will LOGON afterwards.  These common storage\ntables are pointed to by the CVT, the TSO Vector Table, the TSO PARMLIB\nVector Table, and the IKJCTLT control block.  Once you get to the\nIKJCTLT control block, you have the pointers to all of the in-core TSO\nauthorization tables.   The exact addresses are:  TSO Vector Table is\nX'9C' off the CVT.  The TSO PARMLIB Vector Table is X'4C' off the TSVT.\nAnd the CTLT is X'14' off the TPVT.  A map of the TPVT and the CTLT\ncan be obtained from the SHOWMACS member of CBT File 492 or the MODGEN\nmember of CBT File 731.  Maps of these last two control blocks are not\ndistributed by IBM.  We had to figure them out.\n\n\nMANIPULATING THE IN-CORE COPIES OF THE AUTH TABLES - THE ASUB COMMAND\n\n      I wrote an authorized TSO command called ASUB, which goes directly\ninto the in-core TSO auth tables created from the IKJTSOxx PARMLIB\nmember, and manipulates its table entries, which are program names.  The\nASUB program can be found on CBT Tape File 185, where the TSUB program\ncan also be found.\n\n      The ASUB program works as follows:  ASUB has three functions:\nDISPLAY an entry, or the entire table.  REPLACE a numbered entry in the\ntable, and BLANK the last entry in the table.  The syntax of the ASUB\ncommand is:\n\n      ASUB tta nnn pgmname\n\nwhere tt is the table name:  E2, E8, AP, or NS.\na is the action code, D for display, R for replace, B for blank.\nnnn is the specific numbered table entry you want to display or change.\npgmname is the new program name you want to Replace, for the\n   existing name that is in that table slot now\n\n      For example, ASUB E2D   will display the entire IKJEFTE2 table and\nlist all its entries.\n\n      ASUB E2D 55    will list only one entry in the IKJEFTE2 table, the\n55th one.\n\n      ASUB E2R 55 CQX  will replace whatever name was in the 55th entry\nof the IKJEFTE2 table, with the program name of CQX.\n\n      ASUB E2B   will erase whatever program name was in the last entry\nof the IKJEFTE2 table, and will replace it with a blank entry consisting\nof all spaces.\n\n      ASUB E2N   will effectively nullify a table entry, by putting the\nstring C'?' into that table slot.  Syntax is the same as E2B.  Since\nthe C'?' is not eight blanks, it will not delimit the table, and thus\nall table entries following, will remain valid.  Use \"N\" instead of \"B\"\nin almost all cases, unless YOU REALLY WANT to blank the entry.\n\n      A blank entry always delimits the entire table, causing any\nentries after the blank entry, to be ignored.  For that reason, I did\nnot allow the B function of ASUB, to blank any entry in the middle of\nthe table, but if I had filled in the last entry of the table with a\nnon-blank program name, using the ASUB Replace function, the B function\nwill blank out this non-blank entry that I had put at the end of the\ntable.  This concept is very important for us, because when I discuss\nthe similar TSUB program later, I'll show you how TSUB can blank out any\ntable entry even in the middle of the table, and not just the last\nentry.  This is a VERY significant concept for us to grasp.\n\n      Since the ASUB program has to run as an APF authorized TSO\ncommand, its name has to be entered in the IKJEFTE2 (AUTHCMD) table list\nof program names, and its load module has to reside in an APF authorized\nload library.  Again, I must emphasize that ASUB does not modify a copy\nof the tables that is used directly by your TSO session.  The copy of\nthe tables that ASUB modifies, is the \"common storage\" copy of the table\nthat TSO LOGON uses to create your session's tables at LOGON time.  So\nif your TSO session was logged on, and you used ASUB to change one or\nmore table entries, the changes will only affect your TSO session after\nyou re-LOGON.  The effect of ASUB in manipulating the TSO auth tables\nis GLOBAL, and it affects the entire LPAR until another PARMLIB UPDATE\ncommand, or SET IKJTSO= command is issued, or until you IPL.  Every NEW\nTSO session to LOGON, will copy the table version which ASUB has\nmodified.\n\n\nGETTING YOUR TSO SESSION'S TABLES FROM STEPLIB\n\n      The TSO designers have created another way to build your TSO\nsession's \"auth\" tables at LOGON time.  If you are a sysprog or another\n\"special-type\" user, who was allowed by management to have a LOGON PROC\nin your TSO session with a STEPLIB DD to an APF-authorized load library,\nthen this is a special case, different from ordinary TSO users.\n\n      One other condition must be satisfied to create the special case.\nThe APF-authorized STEPLIB must contain a linkedited copy of a load\nmodule called IKJTABLS, that contains CSECTs IKJEFTE2, IKJEFTE8,\nIKJEFTAP, and IKJEFTNS, or some of these.  In this special case, at\nLOGON time, the LOGON processing will not copy your session's auth\ntables from the PARMLIB-created copies in common storage.  But it will\ndo a BLDL for the CSECTs from the STEPLIB, and if the CSECTs are there,\nLOGON will copy them from the authorized STEPLIB instead of from the\n\"common storage\" PARMLIB-created copies.  In this way, a \"special\" user\ncan have different \"auth tables\" than everybody else.\n\n      At LOGON time, there are differences to how the STEPLIB-created\ntables look, as opposed to the PARMLIB-created tables.  In the LWA, the\nSTEPLIB-created tables are marked as having zero length.  This has the\neffect of forcing the only delimiter to the tables, to be the first\nblank entry.  The system (in that case) has no other way of knowing how\nlong each table is.  On the other hand, when the tables are copied from\nthe PARMLIB-created \"common storage\" copy, the length of each table is\nfilled in, in an appropriate field in the LWA (Logon Work Area) for that\nparticular table and that TSO session.\n\n      One other difference exists between STEPLIB-created auth tables\nand PARMLIB-created auth tables for your TSO session.  This is, that the\nLWA for your TSO session contains a flag bit for each of the four\ntables, which is 1 if the table came from STEPLIB, and it is 0 if the\ntable came from PARMLIB.  The effect of this bit is as follows:  If the\nbit for that table is 0, then when some TSO session does a PARMLIB\nUPDATE(xx) command, or the operator issues a SET IKJTSO=xx command, all\nTSO sessions which have their tables marked as coming from PARMLIB, will\nget their tables overlaid and re-created, according to the new IKJTSOxx\nmember that is in effect.  If a table is marked as coming from STEPLIB,\nwith the bit set to 1, then overlay from a PARMLIB UPDATE(xx) or SET\nIKJTSO=xx command DOES NOT OCCUR.  This is understandable.  If a\n\"special user\" has special authorization permissions, he/she does not\nwant them overlaid by a global change for the rest of the TSO users.  So\nthat's why IBM designers put the STEPLIB bit there, in the LWA.\n\n\nMANIPULATING YOUR TSO SESSION'S OWN TABLES - THE TSUB COMMAND\n\n      To manipulate YOUR TSO SESSION's auth tables, or to change the\ncharacteristics of your TSO session's existing tables, I have written\nthe authorized TSO command called TSUB.  Except for its Display\nfunction, TSUB has to be APF-authorized, so its name has to be entered\nin your session's IKJEFTE2 (AUTHCMD) table.\n\n      The TSUB command is like the ASUB command, but with more added\ncapability, owing to the difference in the nature of the \"common\nstorage\" copy of the tables (created by PARMLIB) and the individual\nusers' copy of the tables, pointed to by the LWA.  ASUB works on the\n\"common storage\" copy of the TSO auth tables.  TSUB works locally, on\nYOUR OWN SESSION's copy of the TSO auth tables, pointed to by the LWA.\n\n      As a consequence, other differences between TSUB and ASUB are:\n\n1.  If you make a change to a table with ASUB, your TSO session will\n    only get the changes if you re-LOGON.  When you make table changes\n    with TSUB, the effect (to your TSO session) is immediate.  If you\n    re-LOGON after TSUB has made changes, all changes will be lost.\n\n2.  ASUB only deals with tables that were created from PARMLIB members,\n    and which therefore are marked with a length.  TSUB can get its\n    tables either from PARMLIB or from STEPLIB.  If your session's\n    tables came from STEPLIB, they do not have length values (in the\n    LWA) attached to them.  Therefore, TSUB can not easily \"blank\" a\n    \"last member\" of a table, because we don't really know where the\n    \"last member\" is.  So I allow TSUB to blank ANY member of a table.\n    This is potentially dangerous, but also potentially useful and\n    creative.  It depends on how much knowledge you have, and on how\n    responsible you are.  Fortunately, if you mess up with TSUB, you\n    can re-LOGON and set things back to the beginning state.  Not so\n    with ASUB.  With ASUB you have to re-issue PARMLIB UPDATE(xx) or\n    SET IKJTSO=xx to set things straight again.\n\n    Another warning:  It is better to NULLIFY a table entry than to\n    BLANK it, in most cases.  Use ASUB to replace the entry with a\n    question mark:   ASUB ttR nnn ?   (where nnn is the slot number).\n    The question marks will show up in a D IKJTSO,AUTHCMD display, if,\n    for example, you have nullified entries in the E2 table.\n\n3.  ASUB only manipulates tables in common storage.  TSUB can ALSO\n    manipulate LWA fields that are connected to each of the tables.\n    The effect of a TSUB change is IMMEDIATE, but it only affects\n    your own TSO session.  Therefore, TSUB has extra action codes\n    possible.\n\n    Extra action codes associated with TSUB, which you don't have with\n    ASUB, are:\n\n    H - Alter the header of the table to make it look like it came\n        from PARMLIB.\n\n    L - Measure the table, to put a \"length\" field for it, in the LWA.\n\n    Z - Zero out the length field for the table in the LWA.  Force it\n        to be delimited only by the first blank entry.\n\n    S - Turn on the STEPLIB bit for the table in the LWA.  This has the\n        effect that a PARMLIB UPDATE(xx) or SET IKJTSO=xx command will\n        not overlay your session's table.\n\n    P - Turn off the STEPLIB bit for the table in the LWA.  Then a\n        PARMLIB UPDATE(xx) or SET IKJTSO=xx command will overwrite the\n        existing table when those commands are issued.\n\n    B - Blank any table entry.  With ASUB, you say E2B and you can only\n        blank out the \"last table entry\".  With TSUB, the B action must\n        be followed by a \"slot number\" to blank out, and it can be ANY\n        SLOT, even one in the middle of the table.  The effect of this\n        blanking, is to nullify ALL SUBSEQUENT NON-BLANK entries in the\n        table, and to stop reading the table at the blank entry.  That\n        is dangerous if you don't know what you're doing, but I can\n        think of some very creative ways of using this capability.\n\n\nMAKING COMPLETELY NEW TABLES WITH LLWA, LWATMGR, AND LWATEDIT\n\n      TSUB (and ASUB) deal with MODIFYING ALREADY EXISTING tables.  What\nif you wanted to forget about the existing table and load a completely\nnew one, with a whole set of new and/or different and extra entries?  If\nyou're dealing with your own TSO session's LLWA-pointed auth tables,\nthis is entirely possible, using a set of TSO commands:  LLWA and/or\nLWATMGR from CBT Tape File 797.  LLWA was written by me.  LWATMGR and\nits ISPF interface program, LWATEDIT were written by Dan Dalby.\n\n      To replace an existing table with a new table, a program has to\nGETMAIN some Key 0, Subpool 252 storage (for that, it has to be APF\nauthorized), the new table has to be constructed in storage and copied\ninto the GETMAINed area, and the field in the Logon Work Area, which\npoints to the requisite table, has to be re-pointed to the new table.\n\n      To modify the LWA, you also have to be APF authorized.  And before\na new table location is finalized, there are two more modifications that\nhave to be made.  If the table has a length value associated with it,\nthat length has to be plugged into the proper field in the LWA, and also\nthere is a bit in the LWA which states that this table came from STEPLIB\nand not from PARMLIB.  Our programs LLWA and LWATMGR set this bit on,\nbecause if it is not on, a future PARMLIB UPDATE(xx) or SET IKJTSO=xx\ncommand would overlay our new table in our address space, erasing our\nchanges.\n\n      The LLWA program, written by me, will replace one table, or all\nfour tables, from either of three sources.  The LWATMGR program, written\nby Dan Dalby, will deal with one table at a time only, but LWATMGR can\nalso create an entirely new table from the same three sources.  These\nsources are:  An IKJTABLS load module, similar to the one that you put\nin an APF authorized STEPLIB, or, an FB-80 IKJTSOxx PARMLIB-like member,\nor, an FB-8 (that is, LRECL=8) list of program names.  The FB-8 list of\nprogram names is headed by a \"header record\" that looks like \"---E2---\",\nor \"---E8---\" or \"---AP---\" or \"---NS---\", which tells you which table\nto build from the names that follow the header.\n\n      LLWA will create a new table with 30 blank entries at the end,\nwhich is my preference.  The extra blank entries allow you to add more\nnames with the TSUB program, one at a time.  Dan Dalby's LWATMGR program\nadds only one blank entry at the end, because his program can repeatedly\nFREEMAIN and GETMAIN storage for new tables as needed.  And LWATMGR has\nfacility to add or delete one program name at a time also.\n\n      Dan's LWATEDIT facility for creating a new table is quite amazing.\nYou execute the TSO command LWATEDIT under ISPF, and a panel comes up,\nasking you which table you want to update.  When you pick a table, you\nget the list of program names which that current table contains.  You\nthen can edit the list as you wish, copy names in and out, and then you\nSAVE it.  After you SAVE the list and when you exit it, LWATEDIT calls\nLWATMGR to automatically build a new table with just those entries.  So\nyou can actually EDIT your auth tables and customize them as your\ncurrent needs dictate.\n\n      LWATEDIT makes its table updates by calling LWATMGR, which must be\nAPF authorized.  Since LWATEDIT operates under ISPF, and ISPF does NOT\n\"like\" to be authorized, LWATEDIT must authorize LWATMGR using the\nAUTHTSF facility.  So when you use LWATEDIT, the name LWATMGR must reside\nin BOTH the AUTHCMD and the AUTHTSF tables.  When you use LWATMGR as a\nTSO command only, it need only reside in the AUTHCMD table.\n\n      Either LLWA or LWATMGR, whichever one you use, will have to be in\nthe AUTHCMD list, from the beginning.  Or else, TSUB has to be in the\nAUTHCMD list from the beginning.  Then TSUB can be used to put LLWA or\nLWATMGR in the AUTHCMD list, and after that, LLWA or LWATMGR will be\nused, to build a completely new list, with everything you want in it.\nThis is how you escalate your ability to do useful work for your\ninstallation.  Once you authorize TSUB as a TSO command, you can get all\nthe other commands and programs authorized.\n\n\nSUMMARY\n\n      The four TSO authorization tables, AUTHCMD (IKJEFTE2), AUTHPGM\n(IKJEFTE8), AUTHTSF (IKJEFTAP), and NOTBKGND (IKJEFTNS) that your TSO\nsession uses, are pointed to by fields in the LOGON WORK AREA (LWA)\nwhich is unique to your TSO session.  The LWA is created at LOGON time.\nOnce we authorize one program, for example the TSUB program, to modify\nan existing table, we can get all our other programs authorized, to our\nheart's desire.  This is done either by modifying one of the auth tables\nwith either TSUB or LWATMGR, or by building completely new tables using\neither the programs LLWA or LWATMGR.\n\n      The TSUB program can also modify any of the existing tables'\ncharacteristics, as reflected by fields in the LWA which refer to that\ntable.  These may be either the table's length (whether it has a length\nor not, and if it has, what the length is).  Or, it may be whether the\ntable is marked as coming from STEPLIB or not.  If the table is not\nmarked as coming from STEPLIB, then it is at risk of being overlaid by\na future PARMLIB UPDATE(xx) command or a SET IKJTSO=xx operator\ncommand.\n\n      The LLWA and LWATMGR programs can be used to create a completely\nnew auth table.  The LWATEDIT ISPF interface to the LWATMGR program\nallows you to ISPF EDIT your existing table entries, SAVE the EDIT, and\nbuild a completely new table from the EDIT.  This is an extremely\namazing capability, which I believe, never existed before.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE797": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00#\\x01 \\x17\\x1f\\x01 \\x17\\x1f\\x18\\x05\\x01M\\x01M\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-06-19T00:00:00", "modifydate": "2020-06-19T18:05:23", "lines": 333, "newlines": 333, "modlines": 0, "user": "CBT-500"}, "text": "//***FILE 797 is the combined work of Dan Dalby and Sam Golob.      *   FILE 797\n//*                                                                 *   FILE 797\n//*           email:  sbgolob@cbttape.org                           *   FILE 797\n//*                                                                 *   FILE 797\n//*           email:  zOS.JES2@Gmail.com    (Dan Dalby)             *   FILE 797\n//*                                                                 *   FILE 797\n//*           These programs manipulate, re-create, or alter        *   FILE 797\n//*           the characteristics of your TSO \"auth tables\"         *   FILE 797\n//*           that are pointed to by the LWA (Logon Work Area)      *   FILE 797\n//*           for your TSO session.  With these programs, you       *   FILE 797\n//*           have an amazing and phenomenal amount of control      *   FILE 797\n//*           over those tables (unique to your own TSO session).   *   FILE 797\n//*           You just have to authorize one of these programs      *   FILE 797\n//*           (TSUB or LLWA or LWATMGR) in your IKJEFTE2 table,     *   FILE 797\n//*           and you're on your way.                               *   FILE 797\n//*                                                                 *   FILE 797\n//*           These tools will help if you're installing some       *   FILE 797\n//*           product which requires TSO authorization, and you     *   FILE 797\n//*           want the authorization JUST FOR YOU and for NOBODY    *   FILE 797\n//*           ELSE.                                                 *   FILE 797\n//*                                                                 *   FILE 797\n//*           Also added program ASUB which manipulates the         *   FILE 797\n//*           PARMLIB-generated TSO \"auth tables\" that are in       *   FILE 797\n//*           common storage, which are valid for the entire LPAR,  *   FILE 797\n//*           and which are copied to the LWA-pointed tables that   *   FILE 797\n//*           are manipulated by TSUB and the other programs in     *   FILE 797\n//*           this pds.  ASUB has a syntax similar to TSUB.         *   FILE 797\n//*                                                                 *   FILE 797\n//*           Dan Dalby has contributed the LWATMGR program, and    *   FILE 797\n//*             also the LWATEDIT program to EDIT the tables and    *   FILE 797\n//*             SAVE them, thereby creating updated new tables,     *   FILE 797\n//*             that are effective immediately.                     *   FILE 797\n//*                                                                 *   FILE 797\n//*           These programs must be APF authorized.  However,      *   FILE 797\n//*           once these programs have been authorized to your      *   FILE 797\n//*           TSO session, you can subsequently authorize any       *   FILE 797\n//*           number of other programs, so your initial tables      *   FILE 797\n//*           do not have to contain much, just one of these        *   FILE 797\n//*           programs, and perhaps the STEPLIB program, from       *   FILE 797\n//*           Dan Dalby also (source included in this file).        *   FILE 797\n//*           You need the macros from member MACLIB to assemble    *   FILE 797\n//*           STEPLIB and Dan's other programs.                     *   FILE 797\n//*                                                                 *   FILE 797\n//*           These contributions may be used separately, or they   *   FILE 797\n//*           may be combined, for even further effectiveness.      *   FILE 797\n//*           They all refer to your individual TSO userid's local  *   FILE 797\n//*           copies of the four TSO authorization tables:          *   FILE 797\n//*                                                                 *   FILE 797\n//*               AUTHCMD   - or IKJEFTE2   csect                   *   FILE 797\n//*               AUTHPGM   - or IKJEFTE8   csect                   *   FILE 797\n//*               AUTHTSF   - or IKJEFTAP   csect                   *   FILE 797\n//*               NOTBKGND  - or IKJEFTNS   csect                   *   FILE 797\n//*                                                                 *   FILE 797\n//*           The copies (of these tables) that your own TSO        *   FILE 797\n//*           session uses, are pointed to by the Logon Work Area   *   FILE 797\n//*           (control block LWA - described by the IKJEFLWA macro  *   FILE 797\n//*           in SYS1.MODGEN), and they are unique to your own      *   FILE 797\n//*           TSO session.  Each TSO session has its own copy of    *   FILE 797\n//*           the authorization tables, pointed to by the LWA.      *   FILE 797\n//*                                                                 *   FILE 797\n//*           The programs in this file manipulate or display the   *   FILE 797\n//*           authorization tables that are used by your TSO        *   FILE 797\n//*           session.  Contrary to popular belief, the actual      *   FILE 797\n//*           IKJEFTE2, IKJEFTE8, IKJEFTAP, and IKJEFTNS tables     *   FILE 797\n//*           that are used by your session are NOT in common       *   FILE 797\n//*           storage.  The common storage tables (or the IKJTABLS  *   FILE 797\n//*           load module CSECTs in an APF-authorized STEPLIB in    *   FILE 797\n//*           your LOGON PROC) are actually copied into your own    *   FILE 797\n//*           TSO address space at LOGON time.  So everybody        *   FILE 797\n//*           actually has individual copies of their own tables    *   FILE 797\n//*           in their own TSO address space.  That is why, when    *   FILE 797\n//*           you change these tables in common storage, you have   *   FILE 797\n//*           to LOGON again for them to take effect.  However, a   *   FILE 797\n//*           PARMLIB UPDATE(xx) command, at least in the later     *   FILE 797\n//*           z/OS releases, will go around to all the active TSO   *   FILE 797\n//*           address spaces, and will update their tables.  But    *   FILE 797\n//*           this is with the caveat that if the \"came from        *   FILE 797\n//*           STEPLIB\" bits are on in the LWAPRMLB flag in the      *   FILE 797\n//*           LWA, then PARMLIB UPDATE will not overlay your LWA    *   FILE 797\n//*           tables.  So we make sure to turn those bits on, when  *   FILE 797\n//*           we make our new tables.                               *   FILE 797\n//*                                                                 *   FILE 797\n//*           So when you do a PARMLIB UPDATE, the new tables       *   FILE 797\n//*           are in effect right away, at least when the           *   FILE 797\n//*           current tables are not marked as coming from a        *   FILE 797\n//*           STEPLIB.                                              *   FILE 797\n//*                                                                 *   FILE 797\n//*           Therefore, when you do a PARMLIB UPDATE, these new    *   FILE 797\n//*           settings apply to almost EVERYONE who's logged on     *   FILE 797\n//*           to TSO.  If you want your OWN settings, and you       *   FILE 797\n//*           want to keep them in force, these programs presented  *   FILE 797\n//*           here, are very effective tools.                       *   FILE 797\n//*                                                                 *   FILE 797\n//*       Short summary of the tools -                              *   FILE 797\n//*                                                                 *   FILE 797\n//*           SHOWTPVT shows all fields of the IKJTPVT control      *   FILE 797\n//*           block, with their values on your system.  This        *   FILE 797\n//*           control block is undocumented (for the public)        *   FILE 797\n//*           by IBM.  Very useful for the system programmer.       *   FILE 797\n//*           Its values are controlled by the IKJTSOxx PARMLIB     *   FILE 797\n//*           member.  (See CBT File 731 for more tools.)           *   FILE 797\n//*                                                                 *   FILE 797\n//*           LWATMGR is a self-contained table management tool,    *   FILE 797\n//*           and is described below.                               *   FILE 797\n//*                                                                 *   FILE 797\n//*           TSUB will manipulate existing LWA-pointed auth        *   FILE 797\n//*           tables for a user's TSO session.  So TSUB does        *   FILE 797\n//*           not need to allocate external files.                  *   FILE 797\n//*                                                                 *   FILE 797\n//*           TSUB will DISPLAY, REPLACE, BLANK or \"NULLIFY\" any    *   FILE 797\n//*           existing table entry.  Or TSUB can display any        *   FILE 797\n//*           of the entire tables.  If you BLANK OUT an entry      *   FILE 797\n//*           which is not the last one in the table, then that     *   FILE 797\n//*           invalidates all subsequent entries in that table.     *   FILE 797\n//*           A blank table entry is always treated as a delimiter. *   FILE 797\n//*           So you have to know what you are doing.  TSUB's       *   FILE 797\n//*           DISPLAY functions do not have to be APF-authorized.   *   FILE 797\n//*                                                                 *   FILE 797\n//*           Nullify will insert C'?       ' (? followed by        *   FILE 797\n//*           7 blanks) into a table entry, effectively nullifying  *   FILE 797\n//*           it without invalidating the table entries following.  *   FILE 797\n//*           Use action \"N\" instead of \"B\" unless you know         *   FILE 797\n//*           EXACTLY the effect you want using \"B\".                *   FILE 797\n//*                                                                 *   FILE 797\n//*           TSUB can now alter the characteristics of an          *   FILE 797\n//*           existing auth table.  See the functions of TSUB       *   FILE 797\n//*           below:                                                *   FILE 797\n//*                                                                 *   FILE 797\n//*           The original action codes of TSUB are:                *   FILE 797\n//*                                                                 *   FILE 797\n//*           D - Display table entries by slot number.             *   FILE 797\n//*           R - Replace the entry in a given slot, by another     *   FILE 797\n//*               program name.                                     *   FILE 797\n//*           B - Blank a given table entry, by slot number.        *   FILE 797\n//*           N - Nullify a given table entry, by slot number.      *   FILE 797\n//*                                                                 *   FILE 797\n//*           All action codes in TSUB, except D, require           *   FILE 797\n//*           APF-authorization.                                    *   FILE 797\n//*                                                                 *   FILE 797\n//*           The new action codes of TSUB are:                     *   FILE 797\n//*                                                                 *   FILE 797\n//*           H - Add PARMLIB-like table header, in 2nd 8-bytes.    *   FILE 797\n//*           L - Supply length of table to first blank, in LWA.    *   FILE 797\n//*           Z - Zero the table length marked in the LWA.          *   FILE 797\n//*           S - Mark that the table came from STEPLIB, so         *   FILE 797\n//*                someone (else's) PARMLIB UPDATE(xx) won't        *   FILE 797\n//*                overlay it.  You'll need this if you modified    *   FILE 797\n//*                your existing table (if originally copied from   *   FILE 797\n//*                PARMLIB) and you don't want a PARMLIB UPDATE(xx) *   FILE 797\n//*                to replace your changes.                         *   FILE 797\n//*           P - Turn off STEPLIB bit in LWA and mark that it      *   FILE 797\n//*                came from PARMLIB.  Now PARMLIB UPDATE(xx)       *   FILE 797\n//*                will overlay the table.                          *   FILE 797\n//*           X - (undocumented) Gives LPA storage range display.   *   FILE 797\n//*                                                                 *   FILE 797\n//*           LLWA will replace all, or some, of these tables       *   FILE 797\n//*           completely, from various sources.  LLWA can           *   FILE 797\n//*           provide the new tables from an assembled load         *   FILE 797\n//*           module (similar to IKJTABLS), or from a list of       *   FILE 797\n//*           program names in LRECL=8 format, or from a            *   FILE 797\n//*           card-image file, that is in PARMLIB's IKJTSOxx        *   FILE 797\n//*           format.                                               *   FILE 797\n//*                                                                 *   FILE 797\n//*           You can control the inputs and outputs to the LLWA    *   FILE 797\n//*           program by manually allocating the input datasets     *   FILE 797\n//*           and maybe the one possible output dataset, using      *   FILE 797\n//*           the TSO ALLOCATE and FREE commands.                   *   FILE 797\n//*                                                                 *   FILE 797\n//*           You should Linkedit LLWA as NORENT and NOREUS.        *   FILE 797\n//*           LLWA will operate more efficiently then, and will     *   FILE 797\n//*           not use up so much storage in your address space      *   FILE 797\n//*           when you run it.  It is also better (but not really   *   FILE 797\n//*           necessary) to run LLWA in TSO READY mode, rather      *   FILE 797\n//*           than under ISPF.  Since ISPF takes up the TSO user's  *   FILE 797\n//*           \"below 16M\" storage, and LLWA needs to GETMAIN more   *   FILE 797\n//*           storage for the new auth tables, it is best to run    *   FILE 797\n//*           LLWA in READY mode, when more storage is available.   *   FILE 797\n//*                                                                 *   FILE 797\n//*           LWATMGR uses dynamic allocation throughout.           *   FILE 797\n//*                                                                 *   FILE 797\n//*           The functionality of LWATMGR is pretty much covered   *   FILE 797\n//*           by the two programs LLWA and TSUB.  And vice-versa.   *   FILE 797\n//*           But each one does a few things that the others will   *   FILE 797\n//*           not do.  So it pays to be familiar with all three     *   FILE 797\n//*           programs.                                             *   FILE 797\n//*                                                                 *   FILE 797\n//*       Description of LWATMGR -                                  *   FILE 797\n//*                                                                 *   FILE 797\n//*           This program represents a breakthrough in systems     *   FILE 797\n//*           programmer capability, in that it allows the sysprog  *   FILE 797\n//*           with access to an APF-authorized library to replace   *   FILE 797\n//*           and manipulate his own TSO session's authorization    *   FILE 797\n//*           tables.  It also allows the sysprog to test a new     *   FILE 797\n//*           IKJTSOxx PARMLIB member on one TSO userid at a time,  *   FILE 797\n//*           before letting it loose on every userid in the LPAR.  *   FILE 797\n//*                                                                 *   FILE 797\n//*           Let me explain.  Everybody knows that you can change  *   FILE 797\n//*           the TSO authorization tables globally in your LPAR,   *   FILE 797\n//*           by editing the IKJTSOxx member in PARMLIB and either  *   FILE 797\n//*           using a PARMLIB UPDATE(xx) TSO command, or a SET      *   FILE 797\n//*           IKJTSO=xx operator console command, to make this      *   FILE 797\n//*           member active.  The PARMLIB UPDATE TSO command and    *   FILE 797\n//*           the SET IKJTSO=xx operator command do essentially     *   FILE 797\n//*           the same thing.  What is not generally known, is why  *   FILE 797\n//*           and how these commands will affect every currently    *   FILE 797\n//*           active TSO userid on the system immediately.  You     *   FILE 797\n//*           don't want to do that, if you are merely testing      *   FILE 797\n//*           the effect of a new IKJTSOxx member.  Running a       *   FILE 797\n//*           PARMLIB UPDATE(xx) command on it, would be like       *   FILE 797\n//*           putting it into production immediately.  You would    *   FILE 797\n//*           like to run the new tables in some kind of \"test      *   FILE 797\n//*           mode\" first, on one userid at a time.                 *   FILE 797\n//*                                                                 *   FILE 797\n//*           Enter LWATMGR.  Let me tell you an unknown fact       *   FILE 797\n//*           first.  The PARMLIB-created TSO auth tables are       *   FILE 797\n//*           NOT the ones that are used by your TSO session to     *   FILE 797\n//*           make decisions about authorized TSO commands.         *   FILE 797\n//*           During LOGON time, the public tables are COPIED       *   FILE 797\n//*           into SP-252 Key 0 storage in your own TSO address     *   FILE 797\n//*           space.  They are then pointed to, by fields in the    *   FILE 797\n//*           Logon Work Area (the LWA), and THESE copies of the    *   FILE 797\n//*           tables (IKJEFTE2, IKJEFTE8, IKJEFTAP, IKJEFTNS)       *   FILE 797\n//*           are the ones your session actually uses.  LWATMGR     *   FILE 797\n//*           does something that nothing else (to our              *   FILE 797\n//*           knowledge) does.  It can manipulate those             *   FILE 797\n//*           \"LWA-pointed-to\" copies of the TSO authorization      *   FILE 797\n//*           tables, and its scope immediately affects ONLY the    *   FILE 797\n//*           TSO session which invoked the LWATMGR program.  So    *   FILE 797\n//*           when you use LWATMGR to change your TSO session's     *   FILE 797\n//*           auth tables, you only affect your own session, and    *   FILE 797\n//*           you do not touch the sessions belonging to the        *   FILE 797\n//*           rest of your TSO world (the other sessions on your    *   FILE 797\n//*           LPAR, or MVS instance).                               *   FILE 797\n//*                                                                 *   FILE 797\n//*           LWATMGR has several modes of operation.  LWATMGR      *   FILE 797\n//*           can replace ALL of the Auth tables from an IKJTSOxx-  *   FILE 797\n//*           like source member.  This is called the UPDATE        *   FILE 797\n//*           function.  Input to the UPDATE function of LWATMGR    *   FILE 797\n//*           is an IKJTSOxx PARMLIB member, or another FB-80       *   FILE 797\n//*           file or pds member which looks like it.  You can      *   FILE 797\n//*           also choose to replace only one table from the        *   FILE 797\n//*           IKJTSOxx-format source member.                        *   FILE 797\n//*                                                                 *   FILE 797\n//*           Another thing LWATMGR can do, is to either replace    *   FILE 797\n//*           one (program name) entry in a particular table, by    *   FILE 797\n//*           a different program name.  This is the REPLACE        *   FILE 797\n//*           option.                                               *   FILE 797\n//*                                                                 *   FILE 797\n//*           A third thing LWATMGR can do, is to eliminate one     *   FILE 797\n//*           table entry from a particular table.  This is the     *   FILE 797\n//*           DELETE option.                                        *   FILE 797\n//*                                                                 *   FILE 797\n//*           A fourth thing LWATMGR can do, is to add one new      *   FILE 797\n//*           program name to any of the tables.  This is the ADD   *   FILE 797\n//*           option of LWATMGR.                                    *   FILE 797\n//*                                                                 *   FILE 797\n//*           A fifth option of LWATMGR is to DISPLAY all the       *   FILE 797\n//*           existing \"LWA-pointed-to\" auth tables, or to DISPLAY  *   FILE 797\n//*           any of the tables, one at a time.  The default        *   FILE 797\n//*           action of LWATMGR, entered without parameters, is to  *   FILE 797\n//*           display all four tables as they actually exist for    *   FILE 797\n//*           your TSO session.                                     *   FILE 797\n//*                                                                 *   FILE 797\n//*           LWATMGR has a sixth and a seventh option too.         *   FILE 797\n//*                                                                 *   FILE 797\n//*           The sixth option is called RELOAD.  RELOAD replaces   *   FILE 797\n//*           the \"LWA-pointed-to\" tables for your session, from    *   FILE 797\n//*           an IKJTABLS-like load module, which contains CSECTs   *   FILE 797\n//*           IKJEFTE2, IKJEFTE8, IKJEFTAP, and IKJEFTNS.  You can  *   FILE 797\n//*           assemble and linkedit your own tables of this type.   *   FILE 797\n//*           (See CBT Tape File 185 to learn how to set this up.)  *   FILE 797\n//*           The RELOAD option of LWATMGR is invoked AFTER the     *   FILE 797\n//*           LOGON time.  But although it resembles getting your   *   FILE 797\n//*           tables (at LOGON time) from an APF-authorized         *   FILE 797\n//*           STEPLIB in your LOGON PROC (again see CBT File 185    *   FILE 797\n//*           for more details), THIS NEW process is done AFTER     *   FILE 797\n//*           the LOGON time.  And furthermore, LWATMGR's process   *   FILE 797\n//*           makes the tables look almost as though they came      *   FILE 797\n//*           from PARMLIB, and not as if they came from an         *   FILE 797\n//*           APF-authorized STEPLIB.  (There are significant       *   FILE 797\n//*           internal difference between (LWA) tables that were    *   FILE 797\n//*           created from those two separate sources.              *   FILE 797\n//*                                                                 *   FILE 797\n//*           You can use LWATMGR RELOAD *after* you've used Dan    *   FILE 797\n//*           Dalby's STEPLIB program on an APF-authorized load     *   FILE 797\n//*           library to create the effect of having an             *   FILE 797\n//*           authorized STEPLIB in your LOGON PROC, containing     *   FILE 797\n//*           an IKJTABLS load module.  But this can be done to     *   FILE 797\n//*           ANY TSO session (to which STEPLIB and LWATMGR are     *   FILE 797\n//*           in the AUTHCMD table), without a STEPLIB in the       *   FILE 797\n//*           LOGON PROC, and AFTER LOGON time.                     *   FILE 797\n//*                                                                 *   FILE 797\n//*           A seventh option of LWATMGR is the BUILD option,      *   FILE 797\n//*           where you can reload some or all of the tables, not   *   FILE 797\n//*           from a load module, or from an IKJTSOxx member,       *   FILE 797\n//*           which may be relatively hard to keep and maintain,    *   FILE 797\n//*           but from a mere list of program names, kept in a      *   FILE 797\n//*           file that has LRECL = 8.  This can be either one      *   FILE 797\n//*           flat file, or many members of a pds.  This kind of    *   FILE 797\n//*           \"authorized program list\" is very compact and very    *   FILE 797\n//*           easy to store.  You can keep many different \"special  *   FILE 797\n//*           purpose\" authorization lists in a very small space,   *   FILE 797\n//*           such as members of a pds.                             *   FILE 797\n//*                                                                 *   FILE 797\n//*           Input to the BUILD option of LWATMGR is just a list   *   FILE 797\n//*           of program names, starting with headers ---E2---,     *   FILE 797\n//*           ---E8---, ---NS---, or ---AP---.  These headers tell  *   FILE 797\n//*           LWATMGR which tables to construct.  The record length *   FILE 797\n//*           of each record is just 8 bytes, making the table      *   FILE 797\n//*           extremely compact, and easy to edit.  You can keep    *   FILE 797\n//*           a whole bunch of different auth tables available for  *   FILE 797\n//*           different purposes, very compactly stored in a pds,   *   FILE 797\n//*           and you can shuffle them \"into production\" in your    *   FILE 797\n//*           own TSO session, using the BUILD option of LWATMGR,   *   FILE 797\n//*           as needed.  Again, they are not global.  They affect  *   FILE 797\n//*           only your own TSO session.                            *   FILE 797\n//*                                                                 *   FILE 797\n//*           Please see CBT File 452 (for the STEPLIB command),    *   FILE 797\n//*           and File 185, for more information and tools to       *   FILE 797\n//*           manipulate the TSO authorization tables.              *   FILE 797\n//*                                                                 *   FILE 797\n//*           Included in this file, is a sample LIST pds of        *   FILE 797\n//*           LRECL = 8, to input into the BUILD option, a load     *   FILE 797\n//*           module containing IKJTABLS with the requisite         *   FILE 797\n//*           CSECTs, to input into the RELOAD option, and a        *   FILE 797\n//*           sample IKJTSOxx member, which can be used as input    *   FILE 797\n//*           to the UPDATE option.                                 *   FILE 797\n//*                                                                 *   FILE 797\n//*           The LLWA program can convert input to the tables,     *   FILE 797\n//*           from IKJTSOxx \"PARMLIB-format\" or IKJTABLS load       *   FILE 797\n//*           module format, into the more compact LRECL=8 program  *   FILE 797\n//*           list format, for easier storage and manipulation.     *   FILE 797\n//*                                                                 *   FILE 797\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASUB": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x007\\x01\\x06\\x01\\x8f\\x01\\x160O\\x17T\\x07c\\x04)\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2006-01-18T00:00:00", "modifydate": "2016-10-30T17:54:37", "lines": 1891, "newlines": 1065, "modlines": 0, "user": "SOURCE"}, "text": "ASUB     TITLE 'ASUB - FILL IN ANY SLOT OF THE INCORE TSO AUTH TABLES'\n         SPACE 1\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*   Program Name:   ASUB                                              *\n*                                                                     *\n*  Documentation:   This program is meant to be run as a TSO          *\n*                   command, APF authorized, except for the display   *\n*                   functions.                                        *\n*                                                                     *\n*    Environment:   TSO command, APF Authorized.                      *\n*                   PUTLINE interface enabled by APUT, EPUTL.         *\n*                   This program is non-reentrant.                    *\n*                                                                     *\n*    Description:   Display an Auth Table entry from the TSO/E \"auth\" *\n*                   program list tables in storage.  Or display the   *\n*                   entire table.  Or replace one entry with a new    *\n*                   program name.  If you are invoking a display      *\n*                   function, then the entire table is shown, unless  *\n*                   you enter a number, and then, only that slot is   *\n*                   shown.  Only tables manufactured from PARMLIB     *\n*                   entries are displayed or changed, not the ones    *\n*                   created from IKJTABLS in LPALIB, or from the      *\n*                   IKJTABLS load module that was present in an       *\n*                   APF-authorized STEPLIB.                           *\n*                                                                     *\n*       Function:   To substitute one new program name in the global  *\n*                   incore TSO auth tables, IKJEFTE2, IKJEFTE8, or    *\n*                   IKJEFTAP, IKJEFTNS, or even to the PLATCMD or     *\n*                   PLATPGM lists, if they exist.  This is done to    *\n*                   any numbered entry of each table.  Or else merely *\n*                   display the contents of the entire table, or the  *\n*                   contents of any particular numbered entry.        *\n*                                                                     *\n*                   Also, a blanking function can be performed on     *\n*                   the last entry of any table, which is usually     *\n*                   blank anyway.  No blanking can be performed on    *\n*                   a slot in the middle of a table, because that     *\n*                   will invalidate all the table entries after the   *\n*                   blanked slot, and it is too dangerous to do,      *\n*                   when done irresponsibly.                          *\n*                                                                     *\n*         Syntax:   ASUB TTA nnn pgmname                              *\n*                                                                     *\n*                   Where TT is a table code, and A is an action      *\n*                   code.                                             *\n*                                                                     *\n*                   The table code is a nickname for any of the       *\n*                   TSO/E auth tables which are incore.  They are:    *\n*                                                                     *\n*                   E2 - IKJEFTE2 = AUTHCMD                           *\n*                   E8 - IKJEFTE8 = AUTHPGM                           *\n*                   AP - IKJEFTAP = AUTHTSF                           *\n*                   NS - IKJEFTNS = NOTBKGND                          *\n*                   PC - FCVE     = PLATCMD                           *\n*                   PP - PPVE     = PLATPGM                           *\n*                                                                     *\n*                   If the action code is B (blank the last           *\n*                   entry), then no program name is required.         *\n*                                                                     *\n*                   If the action code is D (display the last         *\n*                   entry), then no program name is required.         *\n*                   The default action is to display the entire       *\n*                   table, unless a number is entered.  If a          *\n*                   number is present, then only that entry           *\n*                   number is displayed.  If the number is larger     *\n*                   than the number of entries in that particular     *\n*                   table, then an informative error message is       *\n*                   issued, and the program ends with code = 4.       *\n*                                                                     *\n*                   If the action code is R (replace the program      *\n*                   name) then a number (the table entry number)      *\n*                   and a program name are required.  If you want     *\n*                   to blank the last slot, instead of putting a      *\n*                   program name into it, then use action code B.     *\n*                                                                     *\n*                   If the PLATCMD or PLATPGM keywords (and at least  *\n*                   one name) were not coded in the active IKJTSOxx   *\n*                   PARMLIB entry, then there is no control block of  *\n*                   names to be pointed to, and therefore no addition *\n*                   of names can be made.  The condition is reported. *\n*                                                                     *\n*             Note:  If an E2, E8, AP, or NS table which is being     *\n*                    used by the system, did not come from the        *\n*                    IKJTSOxx PARMLIB entry, but it came from the     *\n*                    default IKJTABLS entry in LPALIB, then an        *\n*                    appropriate error message is displayed, and      *\n*                    no action is performed on that table.            *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  Change Log:                                                        *\n*                                                                     *\n*    2007/10/21 - 1.0  - Initial version - Got it to work.            *\n*                                                                     *\n*    2009/03/04 - 1.14 - Measure the tables, list the lengths.        *\n*                        Count/display the number of entries and      *\n*                         perceived blanks.  Try to detect the true   *\n*                         end of table in storage, by measuring,      *\n*                         even though (for PARMLIB-created tables)    *\n*                         we have a listed length.                    *\n*                                                                     *\n*    2016/10/30 - 1.15 - Allow a table to validly show question       *\n*                         marks (?) in a table entry.                 *\n*                        So if you want to nullify a table entry      *\n*                         effectively, change the entry to a ?        *\n*                         using the \"xxR\" function.  And \"xxD\"        *\n*                         will show the result accurately.            *\n*                        I don't want to put all the functionality    *\n*                         from TSUB into this program, because this   *\n*                         program affects the whole LPAR, whereas     *\n*                         TSUB only affects the owning TSO id.        *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*       I N S T R E A M    M A C R O S                                *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         YREGS\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.  *\n*  ---------------------------------------------------------------  *\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         STM   R15,R1,HEXSAVE\n         LA    R1,&FROM\n         LA    R0,&LEN\n         LA    R15,&TO\n         BAL   R9,HEX\n         LM    R15,R1,HEXSAVE\n         MEND\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* ------------------------------------------------------------------- *\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\nASUB     CSECT\nASUB     AMODE 31\nASUB     RMODE 24\n         USING *,R15                                                  *  01493\n         B     BEGINN                   Eyecatcher\n         DC    CL8'ASUB  - '\nVERS#    DC    CL10'Ver 1.15'\n         DC    CL1' '\n         DC    CL16' &SYSDATE &SYSTIME '\n         DC    CL6'HLASM '\n         DC    C'&SYSVER'\n         DC    C' '\nBEGINN   DS    0H\n         DROP  R15\n         USING ASUB,R12,R11,R10\n         STM   R14,R12,12(R13)\n         LR    R12,R15                  Set up base registers.\n         ST    R1,SAVEPARM              Save CPPL pointer\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LA    R10,4095(,R11)\n         LA    R10,1(,R10)\n         LA    R1,SAVEAREA          Point to new save area               01508\n         ST    R1,8(,R13)           Forward save area chain pointer      01509\n         ST    R13,4(,R1)           Backward save area chain pointer     01510\n         LR    R13,R1               New save area address                01511\n         B     INITCON              Branch past save area\n         SPACE 1\n* -----------------------\nSAVEAREA DC    18F'0'                                                    01504\n* -----------------------\nINITCON  DS    0H                   Initialize constants\n         MVI   OFFFLAG,X'00'\n         MVI   PLATFLG,X'00'\n         MVI   NSCHFLG,X'00'\n         MVI   LINEB,X'40'\n         MVC   CODEPLAC(2),BLANKS\n         XC    FSTCOUNT,FSTCOUNT\n         XC    FSTNOUNT,FSTNOUNT\n         MVC   FSTFIELD(8),BLANKS\n         MVI   BLANKS-1,X'40'\n         MVC   BLANKS,BLANKS-1\n         XC    BLNKCNT,BLNKCNT      Zero the counters\n         XC    NTRYCNT,NTRYCNT\n         XC    SLOTBIN,SLOTBIN\n         MVC   SLOTSAVE,BLANKS\n         MVC   FSTNAME,BLANKS\n         MVI   CMDBCOPY-1,X'00'\n         MVC   CMDBCOPY,CMDBCOPY-1\n* -----------------------\n         L     R2,16               POINT TO CVT.\n         L     R2,0(,R2)           POINT TO TCB/ASCB WORDS\n         L     R2,4(,R2)           POINT TO TCB.\n         L     R2,X'B4'(,R2)       POINT TO JSCB.\n         L     R2,X'108'(,R2)      POINT TO PSCB.\n         LA    R2,0(,R2)           CLEAR HIGH BYTE.\n         LTR   R2,R2               ANY PSCB?\n         BZ    EOJ4                GET OUT.  NOT TSO.\n         L     R1,SAVEPARM         Get the address of the CPPL back\n         USING CPPL,R1\n         L     R0,CPPLUPT          Copy CPPL fields for possible\n         ST    R0,SAVEUPT            later use, if needed.\n         L     R0,CPPLPSCB\n         ST    R0,SAVEPSCB\n         L     R0,CPPLECT\n         ST    R0,SAVEECT\n         LA    R6,0\n         DROP  R1\n         BAL   R9,PGMTITLE         First display the program title.\n         USING PSCB,R2\nCHEKAUTH DS    0H\n*        B     CONT0               Bypass authorization check\n         TM    PSCBATR1,PSCBACCT   ACCT user?\n         BO    CONT0               Yes.  Continue.\n         TM    PSCBATR1,PSCBCTRL   OPER user?\n         BZ    EOJ4                No.  Get out.\n         DROP  R2\nCONT0    DS    0H                  Get starting addresses for tables\n         L     R2,16               Point to CVT\n         L     R2,X'9C'(,R2)       Point to TSVT (TSO Vector Table)\n         L     R2,X'4C'(,R2)       Point to TPVT\n         ST    R2,SAVETPVT         Save TPVT address for later use\n         L     R2,X'14'(,R2)       Point to CTLT control block\n         ST    R2,SAVECTLT         Save CTLT address for later use\n         L     R2,SAVETPVT         Load TPVT address back\n         L     R2,X'34'(,R2)       Point to PLATCMD pointer\n         LTR   R2,R2               Is there any?\n         BZ    NOFCVE              No. Say so.\n         ST    R2,SAVEFCVE         Yes. Store the FCVE pointer away.\n         OI    PLATFLG,X'01'       Indicate that FCVE exists.\nTRYPPVE  DS    0H\n         L     R2,SAVETPVT         Load TPVT address back\n         L     R2,X'40'(,R2)       Point to PLATPGM pointer\n         LTR   R2,R2               Is there any?\n         BZ    NOPPVE              No. Say so.\n         ST    R2,SAVEPPVE         Yes. Store the PPVE pointer away.\n         OI    PLATFLG,X'02'       Indicate that PPVE exists.\nTRYPPVEE DS    0H\n* ------\n*    There doesn't seem to be a way to tell from an old INMXPARM\n*    control block itself, that it is the old version.  So we use\n*    the position of the active PARMLIB member name in the TPVT.\n* ------\n         L     R2,SAVETPVT         Load TPVT address back.\n         CLC   =C'IKJ',7(R2)       Parmlib member name in old position?\n         BNE   NEWSYSTM            No. It's a new TSO/E version\n         OI    OLDFLAG,X'01'       Yes. Flag that the system is old.\nNEWSYSTM DS    0H\n* ------\n*    We start scanning for PARMs here.\n* ------\n         L     R1,SAVEPARM         Original R1 from entry to program.\n         LTR   R1,R1               Any CPPL?\n         BZ    EOJ8                No. Get out.\n         L     R1,0(,R1)           Point to Command Buffer\n         LTR   R1,R1               Any Command Buffer?\n         BZ    EOJ4                Get out if none.\n         LH    R3,0(,R1)           Load length.\n         CH    R3,=H'4'            Anything?\n         BNH   EOJ4                No.  Get out.\n         LR    R5,R3               Length of command + 4\n         ICM   R5,14,FULLZERO      Clear high order 3 bytes.\n         ST    R1,CMBUFAD          Save Command Buffer Address\n         LH    R3,2(,R1)           Load offset.\n         ST    R3,OFFSETSV\n         SR    R5,R3               Subtract offset from full length+4\n         SH    R5,=H'4'            Correct for length of CMDBUFR header\n*                                  in the command buffer.\n         BC    8,EOJC              Zero, Message\n         BC    5,EOJC              Less, or overflow, out.\n         ST    R5,CMBUFEND         Store away the number of bytes left\n         L     R1,CMBUFAD          Load Command Buffer Address\n*\n* ----  Copy command buffer into pgm's buffer so we can control it.\n*\n         STM   R14,R1,SAVE1401     Now save registers 14 thru 1.\n         XR    R14,R14             Clear R14.\n         LH    R14,0(,R1)          Load full command buffer length.\n         S     R14,=F'5'           Subtract 4 for header, 1 for execute\n         EX    R14,COPYCMDB        Copy command into pgm's area.\n         LM    R14,R1,SAVE1401     Restore registers 14 thru 1.\n         B     GOGOGO              Jump over executed instruction.\nCOPYCMDB MVC   CMDBCOPY(0),4(R1)   <<< Executed >>>\nGOGOGO   DS    0H\n* ----\n         LA    R6,3                Load register for BCT loop.\n* >>>\n         LA    R1,CMDBCOPY         Point to command in our buffer\n         A     R1,OFFSETSV         Add offset, point to subcommands\n         ST    R1,CHARSTRT         Store starting point away\n* >>>\n         LR    R7,R1               Initialize pointer\n         LA    R7,0(,R7)           to first character of function name.\n         LA    R8,0                Initialize character count\nCUTIDLEN CLI   0(R7),X'40'         Is this character a blank?\n         BE    AFTFIRST            Yes, end of the first parm.\n         CLI   0(R7),X'00'         Is this character hex zero?\n         BE    AFTFIRST            Yes, end of command in buffer copy.\n         LA    R7,1(,R7)           Bump another character\n         LA    R8,1(,R8)           Count another character\n         CR    R8,R5               End of command buffer ?\n         BNL   AFTFIRST            Yes. Get out now.\n         BCT   R6,CUTIDLEN         Try for blank again.\nAFTFIRST DS    0H\n         MVC   TABCODE(8),BLANKS   Clear field\n         BCTR  R8,0                Subtract 1 for execute.\n         L     R1,CHARSTRT         Reload R1 to be sure it's correct.\n         EX    R8,MOVOUTL          Move entered parameter to program.\n         LA    R8,1(,R8)           Restore number of characters\n         AR    R1,R8               Point past last search\n         ST    R1,CHARCONT         Continue from here\n         ST    R8,SAVER8           Save\n         ST    R6,SAVER6             the\n         ST    R1,SAVER1A              registers\n* ---- >\nSEEIFPRM DS    0H                  Check if a command is here\n         OC    TABCODE(3),BLANKS   Uppercase. Won't affect numbers\n         CLI   TABCODE+2,C'R'      Replace the entry in the given slot\n         BE    SEEIF0A1\n         CLI   TABCODE+2,C'B'      Blank the last slot\n         BE    SEEIF0A2\n         CLI   TABCODE+2,C'D'      Display contents of last slot\n         BE    SEEIF0A3\n         B     SEEIF000\nSEEIF0A1 DS    0H\n         OI    OFFFLAG,X'01'       Replace an entry\n         B     SEEIF001\nSEEIF0A2 DS    0H\n         OI    OFFFLAG,X'02'       Blank entry in the last slot\n         B     SEEIF001\nSEEIF0A3 DS    0H\n         OI    OFFFLAG,X'04'       Display an entry or entries\n         B     SEEIF001\nSEEIF000 DS    0H                  Wrong function code was entered...\n* --- >                            Display what we entered, plus code\n         MVC   LINE,LINEB          Clear line\n         MVC   LINE(3),TABCODE     Move code in\n         HEX   LINE+6,1,OFFFLAG    Display contents of flag\n         MVC   LINE+13(35),=C'Program table name + Function code '\n         APUT  LINE,48\n* --- >\n         BAL   R9,ERRORCOD         Indicate error and display syntax.\n         B     EOJ4                Get out with code = 4.\nSEEIF001 DS    0H                  Which table to change\n         MVC   CODEPLAC(2),TABCODE\n* --- >                            Display what we entered, plus code\n         MVC   LINE,LINEB          Clear line\n         MVC   LINE(3),TABCODE     Move code in\n         HEX   LINE+6,1,OFFFLAG    Display contents of flag\n         MVC   LINE+13(35),=C'Program table name + Function code '\n         APUT  LINE,48\n* --- >                            Handle each table separately.\n         CLC   TABCODE(2),=C'E2'   Change IKJEFTE2?\n         BE    E2CHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'E8'   Change IKJEFTE8?\n         BE    E8CHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'AP'   Change IKJEFTAP?\n         BE    APCHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'PC'   Change PLATCMD?\n         BE    PCCHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'PP'   Change PLATPGM?\n         BE    PPCHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'NS'   Change IKJEFTNS?\n         BE    NSCHANGE            Yes. Branch.\n         BAL   R9,ERRORCOD         Indicate error and display syntax.\n         B     EOJ4                Invalid code entered.\nEOJ      DS    0H                  END OF JOB                            04216\n         L     R13,4(,R13)                                               04214\n         LR    R15,R5              Put in real return code\n         ST    R15,16(,R13)        Shove it where it belongs\n         L     R14,12(,R13)        R14 and\n         LM    R0,R12,20(R13)        rest of registers\n         BR    R14                 Go back to caller\nEOJ0     DS    0H                  Return code 0\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGR0       Show Return Code 0\n         APUT  MESSAGR0,L'MESSAGR0\n         LA    R5,0                Set CC = 0\n         B     EOJ                 Now end the program\nEOJ4     DS    0H                  Return code 4\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGR4       Show Return Code 4\n         APUT  LINE,L'MESSAGR4\n         L     R5,FULLFOUR         Set CC = 4                            04215\n         B     EOJ                 Now end the program\nEOJ8     DS    0H                  Return code 8\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGR8       Show Return Code 8\n         APUT  LINE,L'MESSAGR8\n         L     R5,FULLEIGT         Set CC = 8                            04215\n         B     EOJ                 Now end the program\nEOJC     DS    0H                  Return code 12\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGRC       Show Return Code 12\n         APUT  LINE,L'MESSAGRC\n         L     R5,FULLTWLV         Set CC = 12\n         B     EOJ                 Now end the program\n** ---------------------------------------------------------------- **\nNOTAUTH  DS    0H                     Command not authorized message.\n         APUT  MESSAG2C,L'MESSAG2C\n         APUT  MESSAG2D,L'MESSAG2D\n         B     EOJC\nE2CHANGE DS    0H                 Handle the E2 table\n         BAL   R9,ADJNEXTP\n         BAL   R9,NAMEPARM\n         L     R2,SAVECTLT\n         LR    R4,R2\n         LA    R4,X'8'(,R4)       POINT TO E2 TABLE\n         L     R4,0(,R4)\n* - -\n         ST    R4,TABLSTRT        Store start address of table\n         ST    R4,TABLADDR        Store start address of table\n         BAL   R9,PRTBLADR        Display table address\n         L     R1,TABLSTRT\n**-->>\n         CLC   =C' PARMLIB',8(R1) Indicator this table is from PARMLIB.\n         BE    E2CHENTY           It is, then we're cool.\n         BAL   R9,MISSPGM3        It isn't, then send message saying so\n         B     EOJ4               And exit with code = 4.\nE2CHENTY DS    0H                 Table was made from a IKJTSOxx entry.\n**-->>\n         LA    R1,X'10'(,R1)      Bump past header\n         ST    R1,TABLSTRT        Store new start address\n* - -\n         L     R3,X'C'(,R2)       LOAD SIZE OF E2 TABLE\n         ST    R3,TABLELEN        Store listed table size\n         LTR   R3,R3              Is there any Parmlib-supplied one?\n         BZ    NOE2               No. Say so and get out.\n         AR    R4,R3              POINT JUST PAST E2 TABLE\n* - -\n         XR    R5,R5\n         LH    R5,X'10'(,R2)      Load number of entries in table\n         ST    R5,TABLENUM        Store number of entries\n         BAL   R9,MEASUR08        Measure the table\n         BAL   R9,LISTLNTH        Print lengths of table\n         BAL   R9,PRTNENTR        Print official number of entries\n* - -\n         XR    R5,R5\n         LH    R5,X'12'(,R2)      LOAD SIZE OF E2 ENTRY\n* - -\n         ST    R5,TABLESIZ        Store size of each entry\n* - -\n         SR    R4,R5              POINT TO LAST SLOT\n         ST    R4,SAVLSLOT\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    E2CHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message\n         B     EOJ0\nE2CHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\nE8CHANGE DS    0H                 Handle the E8 table\n         BAL   R9,ADJNEXTP\n         BAL   R9,NAMEPARM\n         L     R2,SAVECTLT\n         LR    R4,R2\n         LA    R4,X'14'(,R4)      POINT TO E8 TABLE\n         L     R4,0(,R4)\n* - -\n         ST    R4,TABLSTRT        Store start address of table\n         ST    R4,TABLADDR        Store start address of table\n         BAL   R9,PRTBLADR        Display table address\n         L     R1,TABLSTRT\n**-->>\n         CLC   =C' PARMLIB',8(R1) Indicator this table is from PARMLIB.\n         BE    E8CHENTY           It is, then we're cool.\n         BAL   R9,MISSPGM3        It isn't, then send message saying so\n         B     EOJ4               And exit with code = 4.\nE8CHENTY DS    0H                 Table was made from a IKJTSOxx entry.\n**-->>\n         LA    R1,X'10'(,R1)      Bump past header\n         ST    R1,TABLSTRT        Store new start address\n* - -\n         L     R3,X'18'(,R2)      Size of E8 table\n         ST    R3,TABLELEN        Store listed table size\n         LTR   R3,R3              Is there any Parmlib-supplied one?\n         BZ    NOE8               No. Say so and get out.\n         AR    R4,R3              POINT JUST PAST E8 TABLE\n* - -\n         XR    R5,R5\n         LH    R5,X'1C'(,R2)      Load number of entries in table\n         ST    R5,TABLENUM        Store number of entries\n         BAL   R9,MEASUR08        Measure the table\n         BAL   R9,LISTLNTH        Print lengths of table\n         BAL   R9,PRTNENTR        Print official number of entries\n* - -\n         XR    R5,R5\n         LH    R5,X'1E'(,R2)      LOAD SIZE OF E8 ENTRY\n* - -\n         ST    R5,TABLESIZ        Store size of each entry\n* - -\n         SR    R4,R5              POINT TO LAST SLOT\n         ST    R4,SAVLSLOT\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    E8CHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message\n         B     EOJ0\nE8CHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\nAPCHANGE DS    0H                 Handle the AP table\n         BAL   R9,ADJNEXTP\n         BAL   R9,NAMEPARM\n         L     R2,SAVECTLT\n         LR    R4,R2\n         LA    R4,X'2C'(,R4)      POINT TO AP TABLE\n         L     R4,0(,R4)\n* - -\n         ST    R4,TABLSTRT        Store start address of table\n         ST    R4,TABLADDR        Store start address of table\n         BAL   R9,PRTBLADR        Display table address\n         L     R1,TABLSTRT\n**-->>\n         CLC   =C' PARMLIB',8(R1) Indicator this table is from PARMLIB.\n         BE    APCHENTY           It is, then we're cool.\n         BAL   R9,MISSPGM3        It isn't, then send message saying so\n         B     EOJ4               And exit with code = 4.\nAPCHENTY DS    0H                 Table was made from a IKJTSOxx entry.\n**-->>\n         LA    R1,X'10'(,R1)      Bump past header\n         ST    R1,TABLSTRT        Store new start address\n* - -\n         L     R3,X'30'(,R2)      Size of AP table\n         ST    R3,TABLELEN        Store listed table size\n         LTR   R3,R3              Is there any Parmlib-supplied one?\n         BZ    NOAP               No. Say so and get out.\n         AR    R4,R3              POINT JUST PAST AP TABLE\n* - -\n         XR    R5,R5\n         LH    R5,X'34'(,R2)      Load number of entries in table\n         ST    R5,TABLENUM        Store number of entries\n         BAL   R9,MEASUR08        Measure the table\n         BAL   R9,LISTLNTH        Print lengths of table\n         BAL   R9,PRTNENTR        Print official number of entries\n* - -\n         XR    R5,R5\n         LH    R5,X'36'(,R2)      LOAD SIZE OF AP ENTRY\n* - -\n         ST    R5,TABLESIZ        Store size of each entry\n* - -\n         SR    R4,R5              POINT TO LAST SLOT\n         ST    R4,SAVLSLOT\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    APCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message\n         B     EOJ0\nAPCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\nPCCHANGE DS    0H                 Handle the PC table\n         TM    PLATFLG,X'01'\n         BZ    PCCHAERR\n         BAL   R9,ADJNEXTP\n         BAL   R9,NAMEPARM\n         L     R2,SAVEFCVE        Get the PC table address\n         LR    R4,R2              Save it off\n* -- >                            Do Display\n*        MVC   LINE,LINE-1\n         ST    R4,DISPREG\n*        HEX   LINE+13,4,DISPREG\n*        MVC   LINE(8),=C'SAVEFCVE'\n*        APUT  LINE,30\n* -- >\n         L     R3,X'8'(,R4)\n         ST    R3,TABLELEN        Store listed table size\n         AR    R4,R3              POINT JUST PAST PC TABLE\n* - -\n         L     R3,X'C'(,R2)\n         ST    R3,TABLENUM\n         LA    R3,8\n         ST    R3,TABLESIZ\n         L     R3,SAVEFCVE\n         ST    R3,TABLADDR        Store start address of table\n         BAL   R9,PRTBLADR        Display table address\n         BAL   R9,MEASUR08        Measure the table\n         BAL   R9,LISTLNTH        Print lengths of table\n         BAL   R9,PRTNENTR        Print official number of entries\n         LA    R3,X'10'(,R3)\n         ST    R3,TABLSTRT\n* - -\n         LA    R5,8\n         SR    R4,R5              POINT TO LAST SLOT\n         ST    R4,SAVLSLOT\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    PCCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message\n         B     EOJ0\nPCCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\nPCCHAERR DS    0H\n         MVC   LINE,LINE-1\n         MVC   LINE(43),=C'PC command not valid if no PC table exists.'\n         APUT  LINE,43\n         B     EOJ4\nPCCHAEND DS    0H\n         B     EOJ0\nPPCHANGE DS    0H                 Handle the PP table\n         TM    PLATFLG,X'02'\n         BZ    PPCHAERR\n         BAL   R9,ADJNEXTP\n         BAL   R9,NAMEPARM\n         L     R2,SAVEPPVE        Get the PP table address\n         LR    R4,R2              Save it off\n* -- >                            Do Display\n*        MVC   LINE,LINE-1\n         ST    R4,DISPREG\n*        HEX   LINE+13,4,DISPREG\n*        MVC   LINE(8),=C'SAVEPPVE'\n*        APUT  LINE,30\n* -- >\n         L     R3,X'8'(,R4)\n         ST    R3,TABLELEN        Store listed table size\n         AR    R4,R3              POINT JUST PAST PP TABLE\n* - -\n         L     R3,X'C'(,R2)\n         ST    R3,TABLENUM\n         LA    R3,8\n         ST    R3,TABLESIZ\n         L     R3,SAVEPPVE\n         ST    R3,TABLADDR        Store start address of table\n         BAL   R9,PRTBLADR        Display table address\n         BAL   R9,MEASUR08        Measure the table\n         BAL   R9,LISTLNTH        Print lengths of table\n         BAL   R9,PRTNENTR        Print official number of entries\n         LA    R3,X'10'(,R3)\n         ST    R3,TABLSTRT\n* - -\n         LA    R5,8\n         SR    R4,R5              POINT TO LAST SLOT\n         ST    R4,SAVLSLOT\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    PPCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message\n         B     EOJ0\nPPCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\nPPCHAERR DS    0H\n         MVC   LINE,LINE-1\n         MVC   LINE(43),=C'PP command not valid if no PP table exists.'\n         APUT  LINE,43\n         B     EOJ4\nPPCHAEND DS    0H\n         B     EOJ0\nNSCHANGE DS    0H                 Handle the NS table\n         BAL   R9,ADJNEXTP\n         BAL   R9,NAMEPARM\n         L     R2,SAVECTLT\n         OI    NSCHFLG,X'01'      Show SETTMODE we're doing NS\n         LR    R4,R2              Save location of CTLT\n         LA    R4,X'20'(,R4)      Point to NS table address\n         L     R4,0(,R4)          Point to NS table\n* - -\n         ST    R4,TABLSTRT        Store start address of table\n         ST    R4,TABLADDR        Store start address of table\n         BAL   R9,PRTBLADR        Display table address\n         L     R1,TABLSTRT\n**-->>\n         CLC   =C' PARMLIB',8(R1) Indicator this table is from PARMLIB.\n         BE    NSCHENTY           It is, then we're cool.\n         BAL   R9,MISSPGM3        It isn't, then send message saying so\n         B     EOJ4               And exit with code = 4.\nNSCHENTY DS    0H                 Table was made from a IKJTSOxx entry.\n**-->>\n         LA    R1,X'10'(,R1)\n         ST    R1,TABLSTRT        Store new start address\n* - -\n         L     R3,X'24'(,R2)      Load size of NS table\n         ST    R3,TABLELEN        Store listed table size\n         LTR   R3,R3              Is there any Parmlib-supplied one?\n         BZ    NONS               No. Say so and get out.\n         AR    R4,R3              Point just past NS table\n* - -\n         XR    R5,R5\n         LH    R5,X'28'(,R2)      Load number of entries in table\n         ST    R5,TABLENUM        Store number of entries\n         BAL   R9,MEASUR10        Measure the table\n         BAL   R9,LISTLNTH        Print lengths of table\n         BAL   R9,PRTNENTR        Print official number of entries\n* - -\n         XR    R5,R5              Clear register\n         LH    R5,X'2A'(,R2)      Load size of NS entry\n* - -\n         ST    R5,TABLESIZ        Store size of each entry\n* - -\n         SR    R4,R5              Point to Last Slot\n         ST    R4,SAVLSLOT        Save location of last slot\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    NSCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message\n         B     EOJ0\nNSCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\nNOE2     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'E2'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\nNOE8     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'E8'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\nNOAP     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'AP'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\nNONS     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'NS'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\nNOFCVE   DS    0H\n         APUT  =C'No PLATCMD table found',22\n         B     TRYPPVE\nNOPPVE   DS    0H\n         APUT  =C'No PLATPGM table found',22\n         B     TRYPPVEE\n         B     EOJ0\nNOTNUMER DS    0H\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEN),MESSAGEN\n         MVC   LINE+21(1),0(R7)\n         APUT  LINE,L'MESSAGEN\n         B     EOJ4\n** ---------------------------------------------------------------- **\nSAVEPARM DC    F'0'\nSAVETPVT DC    F'0'\nSAVECTLT DC    F'0'\nSAVEFCVE DC    F'0'\nSAVEPPVE DC    F'0'\nSAVEUPT  DC    F'0'\nSAVEECT  DC    F'0'\nSAVEPSCB DC    F'0'\n** ---------------------------------------------------------------- **\nFULLZERO DC    F'0'\nFULLFOUR DC    F'4'\nFULLEIGT DC    F'8'\nFULLTWLV DC    F'12'\nSAVE1401 DC    5F'0'                  More for safety\n* - - - - - - - - - - - - - - - - - - - - - - - - *\nMOVOUTL  MVC   TABCODE(*-*),0(R1)     EXECUTED\nMOVFSTN  MVC   FSTNAME(*-*),0(R3)     EXECUTED\nMOVSNDN  MVC   SNDNAME(*-*),0(R1)     EXECUTED\nMOVFNUM  MVC   FSTNUME(*-*),0(R3)     EXECUTED\nPACK     PACK  WORKA,0(0,3)          <<< EXECUTED >>>                    06758\n** ---------------------------------------------------------------- **\n* - - - - - - - - - - - - - - - - - - - - - - - - *\n*            S U B R O U T I N E S                *\n* - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         ST    R9,SAVER9A\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         L     R9,SAVER9A\n         BR    R9                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\nHEXSAVE  DS    3F                    Register save for HEX macro\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETNAMES DS    0H\n         ST    R9,SAVER9B\nGETNAMST DS    0H                  Get rid of leading blanks\n         L     R1,CHARCONT         Point to start of character\n         CLI   0(R1),X'40'         Is it a blank?\n         BNE   GETNAMNZ            No. Get the entire name.\n         LA    R1,1(,R1)           Yes. Bump start place one up.\n         ST    R1,CHARCONT         And store the place away for now.\n         C     R5,=F'1'            End of cmd buffer one away?\n         BNH   EOJ4                Yes. Error.\n         BCTR  R5,0                Subtract one from end count\n         B     GETNAMST            And loop to find first non-blank.\nGETNAMNZ DS    0H                  Got first non-blank. Get whole name.\n         LA    R6,8                BCT initial quantity - 8 chars.\n         LA    R8,0                Character count\n         L     R1,CHARCONT         Load starting place\n         LR    R7,R1               Initialize pointer\n         LA    R7,0(,R7)           to first character of program name.\nGETNAMLU DS    0H                  Loop to get entire name\n         CLI   0(R7),X'40'         First blank?\n         BE    GETNAMGT            Yes, got whole name.\n         CLI   0(R7),X'00'         First hex zeros?\n         BE    GETNAMGT            Yes, got whole name.\n         CR    R8,R5               End of command buffer?\n         BNL   GETNAMGT            Yes. Got all we can get.\n         LA    R8,1(,R8)           Bump character counter.\n         LA    R7,1(,R7)           Bump where we are.\n         BCT   R6,GETNAMLU         Loop back.\nGETNAMGT DS    0H\n         ST    R8,SAVER8\n         ST    R8,FSTCOUNT\n         CLC   SAVER8,=F'0'\n         BNE   GETREALY\n         BAL   R9,MISSPGM2\n         B     EOJ4\nGETREALY DS    0H\n         MVC   FSTCHALF(2),FSTCOUNT+2\n         MVC   LINE,LINE-1\n         HEX   LINE,4,SAVER8\n         MVC   LINE+13(17),=C'Length of command'\n         APUT  LINE,30\n         L     R3,CHARCONT\n         BCTR  R8,0                One less for EXECUTE\n         MVC   FSTNAME(8),BLANKS\n         EX    R8,MOVFSTN\n         OC    FSTNAME(8),BLANKS\n         MVC   LINE,LINE-1\n         MVC   LINE(8),FSTNAME\n         MVC   LINE+13(17),=C'New program name '\n         APUT  LINE,30\n* - >\nGETNAMEN DS    0H\n         L     R9,SAVER9B\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nCHANGED  DS    0H                     The \"value was changed\" message.\n         ST    R9,SAVER9C\n         TM    OFFFLAG,X'01'\n         BO    CHANGEDA\n         TM    OFFFLAG,X'02'\n         BO    CHANGEDB\n         TM    OFFFLAG,X'04'\n         BO    CHANGEDD\nCHANGEDA DS    0H\n         MVC   MESSAG3A+5(4),TABENNUM+6\n         MVC   MESSAG3A+13(2),CODEPLAC\n         MVC   MESSAG3A+42(8),FSTNAME\n         APUT  MESSAG3A,L'MESSAG3A    Tell em we changed the value.\n         B     CHANGEND\nCHANGEDB DS    0H\n         MVC   MESSAG3B+13(2),CODEPLAC\n         APUT  MESSAG3B,L'MESSAG3B    Tell em we changed the value.\n         B     CHANGEND\nCHANGEDD DS    0H\n         TM    OFFFLAG,X'04'\n         BZ    CHANGEDX\n         CLC   SLOTBIN,=F'0'\n         BE    CHANGEND\nCHANGEDX DS    0H\n         MVC   LINE,LINE-1\n         MVC   LINE(30),=C'Display of Slot contents.     '\n         APUT  LINE,30\nCHANGEND DS    0H\n         L     R9,SAVER9C\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nNAMEPARM DS    0H\n         ST    R9,SAVER9D\n         TM    OFFFLAG,X'02'          Are we blanking?\n         BO    NAMEPEND               Yes. Don't need a name parameter\n         L     R8,SAVER8              Get number of characters used\n         CR    R8,R5                  More than what's left?\n         BNL   NAMEBAD1               Yes. Error.\n         C     R5,=F'3'               Is end bigger than 3?\n         BNH   NAMEBAD1               No. Error.\nNAMEGOOD DS    0H\n         S     R5,=F'3'               Subtract 3 from number till end.\n         BAL   R9,GETNUMES            Get the number of the pgm entry.\n         TM    OFFFLAG,X'04'          Displaying?\n         BO    NAMEPEND               Yes. No names wanted.\n         BAL   R9,GETNAMES            Get the name of pgm to shove in.\n         B     NAMEPEND\nNAMEBAD1 DS    0H\n         TM    OFFFLAG,X'04'          Are we displaying?\n         BO    NAMEPEND\n         BAL   R9,MISSPGM1\n         B     EOJ4\nNAMEPEND DS    0H\n         L     R9,SAVER9D\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nADJNEXTP DS    0H\n         ST    R9,SAVER9E\n         MVC   CHARSTRT,CHARCONT\n         L     R1,CHARSTRT\nSEEIFENX DS    0H\n         CLI   0(R1),X'40'\n         BE    SEEIFENZ\n         LA    R1,1(,R1)\n         ST    R1,CHARSTRT\n         B     SEEIFENX\nSEEIFENZ DS    0H\n         L     R9,SAVER9E\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         LTORG\n************************************************************\nPGMTITLE DS    0H                     Display program name\n         ST    R9,SAVER9F\n         MVC   LINE,LINE-1            Blank line\n         MVC   LINE,MESSAGET          Move title line in\n         APUT  LINE,L'MESSAGET        And put out to tube\n         MVC   LINE,LINE-1            Blank line again\n         MVC   LINE,MESSAGEU          Move underlines in\n         APUT  LINE,L'MESSAGEU        And put them out also\n         L     R9,SAVER9F\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nSETTMODE DS    0H\n         ST    R9,SAVER9G\n* -- >       Test if this command is being run APF Authorized\n         STM   R15,R1,SAVE1401     Now save registers and test if APF\n         XR    R15,R15                  authorized.\n         TESTAUTH FCTN=1           Are we authorized?\n         LTR   R15,R15             Test the return code.\n         BNZ   NOTAUTH             Not zero, tell not authorized.\n         LM    R15,R1,SAVE1401     Restore registers used by TESTAUTH.\n* -- >\n* -- >      Key Zero ---- Here's where we change the stuff.\nKZ       MODESET KEY=ZERO\n* -\n         TM    OFFFLAG,X'03'\n         BZ    ENDKZ\n         TM    NSCHFLG,X'01'\n         BO    TENSLOT\nEIGHSLOT DS    0H\n         L     R3,OURSLOT\n         TM    OFFFLAG,X'01'\n         BZ    BLANKIT\n         CLC   FSTNAME,BLANKS\n         BE    ENDKZ\n         MVC   0(8,R3),FSTNAME\n         B     ENDKZ\nBLANKIT  DS    0H\n         TM    OFFFLAG,X'02'\n         BZ    ENDKZ\n         L     R3,SAVLSLOT\n         MVC   0(8,R3),BLANKS\n         B     ENDKZ\nTENSLOT  DS    0H\n         L     R3,OURSLOT\n         TM    OFFFLAG,X'01'\n         BZ    BLANKTEN\n         CLC   FSTNAME,BLANKS\n         BE    ENDKZ\n         MVC   0(2,R3),FSTCHALF\n         MVC   2(8,R3),FSTNAME\n         B     ENDKZ\nBLANKTEN DS    0H\n         TM    OFFFLAG,X'02'\n         BZ    ENDKZ\n         L     R3,SAVLSLOT\n         MVC   0(2,R3),=X'FFFF'\n         MVC   2(8,R3),BLANKS\n         B     ENDKZ\nENDKZ    DS    0H\n* -\nNZ       MODESET KEY=NZERO\n* -- >      Back to ordinary life ----\n         L     R9,SAVER9G\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nERRORCOD DS    0H\n         ST    R9,SAVER9H\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSA11L,L'MESSA11L\n         APUT  MESSA11M,L'MESSA11M\n         APUT  MESSA11P,L'MESSA11P\n         APUT  MESSA11A,L'MESSA11A\n         APUT  MESSA11C,L'MESSA11C\n         APUT  MESSA11D,L'MESSA11D\n         APUT  MESSA11F,L'MESSA11F\n         APUT  MESSA11I,L'MESSA11I\n         APUT  MESSA11K,L'MESSA11K\n         APUT  MESSA11J,L'MESSA11J\n         APUT  MESSA11N,L'MESSA11N\n         APUT  MESSA11O,L'MESSA11O\n         L     R9,SAVER9H\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMISSPGM1 DS    0H\n         ST    R9,SAVER9I\n         MVC   LINE,LINE-1\n         APUT  MESSA11G,L'MESSA11G\n         L     R9,SAVER9I\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMISSPGM2 DS    0H\n         ST    R9,SAVER9J\n         MVC   LINE,LINE-1\n         APUT  MESSA11E,L'MESSA11E\n         L     R9,SAVER9J\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMISSPGM3 DS    0H\n         ST    R9,SAVER9K\n         MVC   LINE,LINE-1\n         APUT  MESSA11H,L'MESSA11H\n         L     R9,SAVER9K\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nDISPTABL DS    0H                Scan thru the particular table....\n         ST    R9,SAVER9L          Save BAL register\n         ST    R3,SAVER3A          Save\n         ST    R4,SAVER4A             the\n         ST    R5,SAVER5A                work\n         ST    R6,SAVER6A                   registers.\n         TM    OFFFLAG,X'02'       Are we blanking the last entry?\n         BO    DISPTEND            Yes. Don't have to scan entire table\n         XR    R3,R3               Zero\n         XR    R5,R5                  work\n         XR    R6,R6                     registers.\nDISPTSTR DS    0H\n         L     R3,TABLSTRT         Load start address of table\n         L     R6,TABLENUM         Load number of entries in table\n         L     R5,TABLESIZ         Load size of each entry\n         LA    R4,1                Start slot number count at 1\n         ST    R4,SLOTNOW          Stort slot number count away\n         CLC   SLOTBIN,=F'0'       If there's no slot num in param\n         BE    DISPTLUP            Then bypass error checking\n         C     R6,SLOTBIN          Compare table size to parm number\n         BNL   DISPTLUP            If parm number is LE, then display\nDISPTERR DS    0H                  Else error message and out.\n         MVC   LINE,LINE-1\n         MVC   LINE(22),=C'Slot number specified '\n         L     R1,SLOTBIN          Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         MVC   LINE+34(26),=C'is bigger than table size '\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+60(10),MASK10  Move in the mask\n         ED    LINE+60(10),CVDAREA+3 Make it pretty\n         APUT  LINE,72\n         B     EOJ4\nDISPTLUP DS    0H                  Loop thru the table entries.\n         MVC   LINE,LINE-1\n         MVC   LINE(2),CODEPLAC\n         MVC   LINE+3(19),=C'Table Entry Number:'\n         CVD   R4,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         TM    NSCHFLG,X'01'       Is this the 10-byte NS table entry?\n         BO    DISPTBNS            Yes. Handle separately.\n         MVC   LINE+34(8),0(R3)\n         CLC   LINE+34(8),BLANKS   Is this a blank entry.\n         BNE   DISPTBLK            No.\n         MVC   LINE+34(8),=C'*empty* '   Yes. Don't just show blanks.\n         B     DISPTBLK\nDISPTBNS DS    0H\n         HEX   LINE+34,2,0(R3)\n         MVC   LINE+40(8),2(R3)\n         CLC   LINE+40(8),BLANKS   Is this a blank entry.\n         BNE   DISPTBLK            No.\n         MVC   LINE+40(8),=C'*empty* '   Yes. Don't just show blanks.\nDISPTBLK DS    0H                  Search each slot number.\n         CLC   SLOTBIN,=F'0'       Has a slot number been specified?\n         BE    DISPTYES            No. Just display all the slots.\n         CLC   SLOTBIN,SLOTNOW     Yes. Then are we at the one we want?\n         BNE   DISPTNOT            No. Just go further and search.\n* ---  Save contents of the current slot which was found - below\n         LR    R1,R5               Load table entry size\n         BCTR  R1,0                One less for execute\n         EX    R1,MOVESLOT         Save contents of slot for kicks\n         ST    R3,OURSLOT          Store its address - important....\n         MVC   TABENNUM(10),MASK10    Save edited version\n         ED    TABENNUM(10),CVDAREA+3    of this slot number\n         B     DISPTPEX               Branch past executed instruction\nMOVESLOT MVC   SLOTSAVE(*-*),0(R3)    EXECUTED\nDISPTPEX DS    0H\n* ---  Save contents of the current slot which was found - above\nDISPTYES DS    0H                  Print this slot entry\n         APUT  LINE,52\nDISPTNOT DS    0H                  Bump to next slot and loop back.\n         LA    R3,0(R5,R3)         Bump to next slot\n         LA    R4,1(,R4)           Bump count of slot number\n         ST    R4,SLOTNOW          Store new slot number away\n         BCT   R6,DISPTLUP         And loop to examine the new slot.\nDISPTEND DS    0H\n         L     R3,SAVER3A          Restore all the work registers.\n         L     R4,SAVER4A\n         L     R5,SAVER5A\n         L     R6,SAVER6A\n         L     R9,SAVER9L          Restore the BAL register.\n         BR    R9                  Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETNUMES DS    0H\n         ST    R9,SAVER9M\nGETNUMST DS    0H                  Get rid of leading blanks\n         L     R1,CHARCONT         Point to start of character\n         CLI   0(R1),X'40'         Is it a blank?\n         BNE   GETNUMNZ            No. Get the entire name.\n         LA    R1,1(,R1)           Yes. Bump start place one up.\n         ST    R1,CHARCONT         And store the place away for now.\n         C     R5,=F'1'            End of cmd buffer one away?\n         BNH   EOJ4                Yes. Error.\n         S     R5,=F'1'            Subtract one from end count\n         B     GETNUMST            And loop to find first non-blank.\nGETNUMNZ DS    0H                  Got first non-blank. Get whole name.\n         LA    R6,5                BCT initial quantity - 5 chars.\n         LA    R8,0                Character count\n         L     R1,CHARCONT         Load starting place\n         LR    R7,R1               Initialize pointer\n         LA    R7,0(,R7)           to first character of program number\nGETNUMLU DS    0H                  Loop to get entire number\n         CLI   0(R7),X'40'         First blank?\n         BE    GETNUMGT            Yes, got whole number\n         CLI   0(R7),X'00'         First hex zeros?\n         BE    GETNUMGT            Yes, got whole number\n         CR    R8,R5               End of command buffer?\n         BNL   GETNUMGT            Yes. Got all we can get.\n* --\n         CLI   0(R7),X'F0'         Check this parm if numeric.\n         BL    NOTNUMER\n         CLI   0(R7),X'F9'\n         BH    NOTNUMER\n* --\n         LA    R8,1(,R8)           Bump character counter.\n         LA    R7,1(,R7)           Bump where we are.\n         BCT   R6,GETNUMLU         Loop back.\nGETNUMGT DS    0H                  Got the whole number - examine it.\n         ST    R8,SAVER8\n         ST    R8,FSTNOUNT         Get halfword value of slot number\n         MVC   FSTNHALF(2),FSTNOUNT+2\n         L     R3,CHARCONT\n         BCTR  R8,0                One less for EXECUTE\n         MVC   FSTFIELD(8),BLANKS  5-char number plus 3 blanks\n         EX    R8,MOVFNUM          Get the number from the parm\n         EX    R8,PACK             Convert it to packed\n         CVB   R0,WORKA            Convert it to Binary                  06446\n         ST    R0,SLOTBIN          Store the value for later use         06447\n         MVC   LINE,LINE-1\n         MVC   LINE(8),FSTFIELD    8-char number with blanks\n         MVC   LINE+13(19),=C'Entry slot number  '\n         APUT  LINE,32\n         LA    R8,1(,R8)           Restore number of chars after EX\n         ST    R8,CHARSIZE         Save this value off.\n         AR    R3,R8               Add it to R3 so we start past it.\n         ST    R3,CHARCONT         Store start value for next parm.\nGETNUMEN DS    0H\n         L     R9,SAVER9M\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nPRTBLADR DS    0H\n         ST    R9,SAVER9N\n*-*-*->>                          Print the address out so we can see.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1        Clear line area.\n         MVC   LINE(16),=C'Table address:  '\n         HEX   LINE+21,4,TABLADDR     Display address in Hex\n         APUT  LINE,35\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n*-*-*->>\n         L     R9,SAVER9N\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* ----------------------------------------------------------------- *\n*      Measure \"8-byte entry\" loaded table.                         *\n* ----------------------------------------------------------------- *\n*      R5 contains the entry point of the table.                    *\n* ----------------------------------------------------------------- *\nMEASUR08 DS    0H                 R5 has beginning address of table.\n         ST    R9,SAVER9O           Save BAL register\n         ST    R5,SAVER5D           Save work register\n         ST    R4,SAVER4B           Save work register\n         ST    R6,SAVER6B           Save work register\n         L     R5,TABLADDR          Load start of table\n         XC    BLNKCNT,BLNKCNT      Zero the counters\n         XC    NTRYCNT,NTRYCNT\n         LA    R4,16                Count size of header\n         LA    R5,16(,R5)           Bump past header\n         L     R6,TABLENUM          No of entries to limit loop\nME08LOOP DS    0H\n*     Try (real hard) to detect the end of the table  -  below\n         MVC   SAVECHAR(1),0(R5)    Save first character\n         CLC   =C'        ',0(R5)   Is this table entry a blank?\n         BE    ME08BLNK             Yes. Reached virtual end of table\n         CLC   ZEROES8(8),0(R5)     Is this \"entry\" hex zeros?\n         BE    ME08NOBL             Yes. Reached possible junk storage\n         CLC   =C' ',0(R5)          Is first character blank?\n         BE    ME08NOBL             Yes, not a valid table entry.\n         TR    SAVECHAR,TRTPGMNM    Check first char if appropriate.\n         CLI   SAVECHAR,X'02'       Not. probably end of table.\n         BE    ME08NOBL\n         CLC   =C'IKJEFTE2',0(R5)\n         BE    ME08NOBL\n         CLC   =C'IKJEFTE8',0(R5)\n         BE    ME08NOBL\n         CLC   =C'IKJEFTAP',0(R5)\n         BE    ME08NOBL\n         CLC   =C'IKJEFTNS',0(R5)\n         BE    ME08NOBL\n*     Try (real hard) to detect the end of the table  -  above\n         LA    R4,8(,R4)            Count next table entry\n         LA    R5,8(,R5)            Bump to next entry\n         L     R1,NTRYCNT           Increment \"entry count\" counter\n         A     R1,=F'1'\n         ST    R1,NTRYCNT\n         BCT   R6,ME08LOOP          Loop back till table end\n         B     ME08NOBL             No blanks if we fell through\nME08BLNK DS    0H\n         LA    R4,8(,R4)            Add length of blank entry\n         LA    R5,8(,R5)            Bump past blank entry.\n         L     R1,BLNKCNT           Increment \"blank entry\" counter\n         A     R1,=F'1'\n         ST    R1,BLNKCNT\nME08NOBL DS    0H\n         STH   R4,ME08LENG          Store measured length of table.\n         ST    R5,ME08END           And record address of table end.\n*        BAL   R9,MESBLK08          Measure more blanks after table.\n*        TM    MEASFLG,X'01'        Been here already?\n*        BO    ME08NOSH             Don't show count again.\n         BAL   R9,ENTRYDSP          Show number of entries.\nME08NOSH DS    0H\n*        OI    MEASFLG,X'01'        Show we did this once.\n         L     R4,SAVER4B           Restore work register\n         L     R6,SAVER6B           Restore work register\n         L     R5,SAVER5D           Restore work register\n         L     R9,SAVER9O           Restore BAL register\n         BR    R9\nME08END  DS    F                    Store end-of-table address\nME08LENG DS    H                    Store table length\nBL08LENG DS    H                    Store length of blanks\nTO08LENG DS    H                    Store total, nonblank+blank\n* ----------------------------------------------------------------- *\nMEASUR10 DS    0H                 R5 has beginning address of table.\n         ST    R9,SAVER9R           Save BAL register\n         ST    R5,SAVER5D           Save work register\n         ST    R4,SAVER4B           Save work register\n         ST    R6,SAVER6B           Save work register\n         L     R5,TABLADDR          Load start of table\n         XC    BLNKCNT,BLNKCNT      Zero the counters\n         XC    NTRYCNT,NTRYCNT\n         LA    R4,16                Count size of header\n         LA    R5,16(,R5)           Bump past header\n         L     R6,TABLENUM          No of entries to limit loop\nME10LOOP DS    0H\n         MVC   SAVECHAR(1),2(R5)    Save first character of pgm name\n         MVC   SAVECH08(1),9(R5)    Save last character of pgm name\n         CLC   BLKSTRNG(10),0(R5)   Full blank entry here?\n         BE    ME10BLNK             Yes. Count the blank entry.\n         CLC   ENDSTRNG(10),0(R5)   FFFF plus blank pgm name?\n         BE    ME10BLNK             Yes. Can still be considered blank.\n         CLC   =X'0000',0(R5)       Zeros in length field?\n         BE    ME10TEST             Yes. Test rest of entry.\n         B     ME10REST             Not zeros, go on.\nME10TEST DS    0H\n         TR    SAVECHAR,TRTPGMNM    Check for strange character.\n         CLI   SAVECHAR,X'02'       Is it strange?\n         BE    ME10NOBL             Yes. This is not a blank entry.\nME10REST DS    0H\n         CLC   =X'FFFF',0(R5)       Test for end string separately.\n         BNE   ME10TES2             Not. Not at virtual end of table\n         B     ME10NOBL             FFFF alone. Not a blank entry.\nME10TES2 DS    0H\n         TR    SAVECHAR,TRTPGMNM    Check for strange character.\n         CLI   SAVECHAR,X'02'\n         BE    ME10NOBL             Not. probably end of table.\n         TR    SAVECH08,TRTPGMNM    Check last char if strange.\n         CLI   SAVECH08,X'02'\n         BE    ME10NOBL             Not. probably end of table.\n         LA    R4,10(,R4)           Count next table entry\n         LA    R5,10(,R5)           Bump to next entry\n         L     R1,NTRYCNT           Increment \"entry count\" counter\n         A     R1,=F'1'\n         ST    R1,NTRYCNT\n         BCT   R6,ME10LOOP          Finished entry, try for more.\n         B     ME10NOBL\nME10BLNK DS    0H\n         LA    R4,10(,R4)           Add length of blank entry\n         LA    R5,10(,R5)           Bump past blank entry.\n         L     R1,BLNKCNT           Increment \"blank entry\" counter\n         A     R1,=F'1'\n         ST    R1,BLNKCNT\nME10NOBL DS    0H\n         STH   R4,ME10LENG          Store measured length of table.\n         ST    R5,ME10END           And record address of table end.\n         BAL   R9,ENTRYDSP          Show number of entries.\nME10NOSH DS    0H\n         L     R4,SAVER4B           Restore work register\n         L     R6,SAVER6B           Restore work register\n         L     R5,SAVER5D           Restore work register\n         L     R9,SAVER9R           Restore BAL register\n         BR    R9\nME10END  DS    F                    Store end-of-table address\nME10LENG DS    H                    Store table length\nBL10LENG DS    H                    Store length of blanks\nTO10LENG DS    H                    Store total, nonblank+blank\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nENTRYDSP DS    0H\n         ST    R9,SAVER9P\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         L     R1,NTRYCNT\n         CVD   R1,CVDAREA\n         MVC   LINE+22(10),MASK10\n         ED    LINE+22(10),CVDAREA+3\n         MVC   LINE(24),=C'Non-blank table entries:'\n         MVC   LINE+35(25),=C'(these are the ones used)'\n         APUT  LINE,65\n         MVC   LINE,LINE-1\n         L     R1,BLNKCNT\n         CVD   R1,CVDAREA\n         MVC   LINE+22(10),MASK10\n         ED    LINE+22(10),CVDAREA+3\n         MVC   LINE(24),=C'Perceived blank entries:'\n         MVC   LINE+35(25),=C'(blank program name slot)'\n         APUT  LINE,65\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nENTRYEXI DS    0H\n         L     R9,SAVER9P\n         BR    R9\nENTRYDEN DS    0H\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nPRTNENTR DS    0H\n         ST    R9,SAVER9Q\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         L     R9,SAVER9Q\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nLISTLNTH DS    0H\n         ST    R9,SAVER9S\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         MVC   LINE(30),=C'Listed   length of this table:'\n         HEX   LINE+32,2,TABLELEN+2\n         L     R1,TABLELEN         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+45(10),MASK10  Move in the mask\n         ED    LINE+45(10),CVDAREA+3 Make it pretty\n         MVC   LINE+39(8),=C'Decimal:'\n         APUT  LINE,65\n         TM    NSCHFLG,X'01'\n         BO    LISTLN10\n         MVC   LINE,LINE-1\n         MVC   LINE(30),=C'Measured length of this table:'\n         HEX   LINE+32,2,ME08LENG\n         LH    R1,ME08LENG         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+45(10),MASK10  Move in the mask\n         ED    LINE+45(10),CVDAREA+3 Make it pretty\n         MVC   LINE+39(8),=C'Decimal:'\n         APUT  LINE,65\n         B     LISTLNEN\nLISTLN10 DS    0H\n         MVC   LINE,LINE-1\n         MVC   LINE(30),=C'Measured length of this table:'\n         HEX   LINE+32,2,ME10LENG\n         LH    R1,ME10LENG         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+45(10),MASK10  Move in the mask\n         ED    LINE+45(10),CVDAREA+3 Make it pretty\n         MVC   LINE+39(8),=C'Decimal:'\n         APUT  LINE,65\nLISTLNEN DS    0H\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         L     R9,SAVER9S\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nBLKSTRNG DC    XL10'00004040404040404040'\nENDSTRNG DC    XL10'FFFF4040404040404040'\nZEROES8  DC    X'0000000000000000'\nMASK10   DC    XL10'40202020202020202120'\n         DC    C' '\nBLANKS   DC    C'                                            '\nMESSAGET DC    C'ASUB Command - Display or Change PARMLIB Auth Table Enx\n               try - Ver 1.15'\nMESSAGEU DC    C'---- -------   ------- -- ------ ------- ---- ----- --x\n               ---   --- ----'\nMESSAG2C DC    C'Command was not invoked APF authorized.'\nMESSAG2D DC    C'Nothing was changed.  '\nMESSAG3A DC    C'Slot      in XX table has been changed to         .'\nMESSAG3B DC    C'Last slot in XX table has been blanked.            '\nMESSAG3C DC    C'                                                      +\n                  '\nMESSA11A DC    C'Supply a table code, followed by an action code. '\nMESSA11B DC    C'Supply a program name, as the next parameter.   '\nMESSA11C DC    C'Valid table  codes are:  E2, E8, AP, NS, PC, PP. '\nMESSA11D DC    C'Valid action codes are:  R - replace, B - blank, D - d-\n               isplay.'\nMESSA11E DC    C'Please supply a program name.  '\nMESSA11F DC    C'Full command is in the form TTA, TT=table code, A=acti-\n               on code.'\nMESSA11G DC   C'Please supply slot number to change, and program name.'\nMESSA11H DC    C'This table did not come from a PARMLIB specification.'\nMESSA11I DC    C'If D (display) is followed by a slot number, only that-\n                slot is shown.'\nMESSA11J DC    C'R (replace) requires a slot number, followed by a prog-\n               ram name.'\nMESSA11K DC    C'If D is not followed by a number, then the entire tabl-\n               e is displayed.'\nMESSA11L DC    C'  Instructions to use this program:                  '\nMESSA11M DC    C'  ------------ -- --- ---- -------                   '\nMESSA11N DC    C'B (blank) will blank the last table entry, which norma-\n               lly is blank.'\nMESSA11O DC    C'Only R (replace) and B (blank) require APF authorizati-\n               on. D does not.'\nMESSA11P DC    C'  ASUB TTA nnn pgmname (nnn optional for D, both requi-\n               red for R)'\nMESSAGR0 DC    C'Return Code = 0 '\nMESSAGR4 DC    C'Return Code = 4 '\nMESSAGR8 DC    C'Return Code = 8 '\nMESSAGRC DC    C'Return Code = 12'\nMESSDIAG DC    C'                                            '\nMESSAGEP DC    C'No Parmlib-supplied XX table was found in storage. '\nMESSAGEN DC    C'Supplied character        was not numeric. '\n         SPACE 3\n         LTORG\n         SPACE 3\nCVDAREA  DS    D                   For CVD instruction\nSAVEAPUT DS    2D\nSAVER1   DS    F                   Save R1 here\nSAVER1A  DS    F                   Save R1 here\nSAVER1B  DS    F                   Save R1 here\nSAVER3A  DS    F                   Save R3 here\nSAVER4A  DS    F                   Save R4 here\nSAVER4B  DS    F                   Save R4 here\nSAVER5A  DS    F                   Save R5 here\nSAVER5D  DS    F                   Save R5 here\nSAVER6   DS    F                   Save R6 here\nSAVER6A  DS    F                   Save R6 here\nSAVER6B  DS    F                   Save R6 here\nSAVER8   DS    F                   Save R8 here\nSAVER8A  DS    F                   Save R8 here\nSAVER8B  DS    F                   Save R8 here\nSAVER9A  DS    F                   BAL Register Save Area\nSAVER9B  DS    F                   BAL Register Save Area\nSAVER9C  DS    F                   BAL Register Save Area\nSAVER9D  DS    F                   BAL Register Save Area\nSAVER9E  DS    F                   BAL Register Save Area\nSAVER9F  DS    F                   BAL Register Save Area\nSAVER9G  DS    F                   BAL Register Save Area\nSAVER9H  DS    F                   BAL Register Save Area\nSAVER9I  DS    F                   BAL Register Save Area\nSAVER9J  DS    F                   BAL Register Save Area\nSAVER9K  DS    F                   BAL Register Save Area\nSAVER9L  DS    F                   BAL Register Save Area\nSAVER9M  DS    F                   BAL Register Save Area\nSAVER9N  DS    F                   BAL Register Save Area\nSAVER9O  DS    F                   BAL Register Save Area\nSAVER9P  DS    F                   BAL Register Save Area\nSAVER9Q  DS    F                   BAL Register Save Area\nSAVER9R  DS    F                   BAL Register Save Area\nSAVER9S  DS    F                   BAL Register Save Area\nSAVER9T  DS    F                   BAL Register Save Area\nSAVER9U  DS    F                   BAL Register Save Area\nSAVER9V  DS    F                   BAL Register Save Area\nSAVER9W  DS    F                   BAL Register Save Area\nSAVER9X  DS    F                   BAL Register Save Area\nSAVER9Y  DS    F                   BAL Register Save Area\nCMBUFEND DS    F                   Number of bytes to end of cmd buff\nSAVLSLOT DS    F                   Save place where Key 0 will change\nSLOTBIN  DS    F\nSLOTNOW  DS    F\nDISPREG  DS    F                   DISPLAY\nCMBUFAD  DS    F                   Command Buffer address\nCHARSTRT DS    F                   Address of first parm character\nCHARCONT DS    F                   Address of next parm character\nCHARSIZE DS    F\nOURSLOT  DS    F\n* --- >\nTABLSTRT DS    F                   Start address of table\nTABLADDR DS    F                   Start address of table\nTABLENUM DS    F                   Number of entries in table\nTABLESIZ DS    F                   Size of a table entry\nTABLELEN DS    F                   Listed length of the table\n* --- >\nBLNKCNT  DS    F\nNTRYCNT  DS    F\n* --- >\nOFFSETSV DS    F\nWORKA    DC    D'0'                                                      06772\nNUMVSTRT DC    X'00'               Character count of first parm\nNUMCOUTL DC    X'00'               Entered first parm length\nCODEPLAC DS    CL2\nPAD01    DS    CL4                 Filler\nSAVECHAR DS    X\nSAVECH08 DS    X\nOFFFLAG  DS    X                   Are we blanking the last entry?\nOLDFLAG  DS    X                   Old system detected if X'01'\nPLATFLG  DS    X\nNSCHFLG  DS    X\nPAD02    DS    CL4                 Filler\nFSTNAME  DC    CL8' '\nFSTCOUNT DS    F                   Number of characters in FSTNAME\nFSTCHALF DC    H'0'\nPAD03    DS    CL4                 Filler\nFSTFIELD DS    0CL8\nFSTNUME  DC    CL5' '\nFSTNUPAD DC    CL3' '\nFSTNOUNT DS    F                   Number of characters in FSTNAME\nFSTNHALF DC    H'0'\nPAD04    DS    CL4                 Filler\nSLOTSAVE DS    CL10\nPAD05    DS    CL4                 Filler\nSNDNAME  DC    CL8' '\nSNDCOUNT DS    F                   Number of characters in SNDNAME\nSNDCHALF DC    H'0'\nTABCODE  DC    CL8' '              Original OUTLIM character\nTABENNUM DC    CL10' '\n         DS    CL7                 PADDING\n         DS    CL1\nCMDBCOPY DS    CL252\n         DS    CL128               PADDING\n         DS    0F                  ALIGN ON FULLWORD\nLINEB    DS    C                   LINE-1\nLINE     DS    CL137               Output line area\nLINET    EQU   LINE+7              Indented line\nTRTPGMNM DC    X'02020202020202020202020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'40020202020202020202020202020202'\n         DC    X'02020202020202020202025B02020202'\n         DC    X'0202020202020202020202020202026F'\n         DC    X'02020202020202020202027B7C020202'\n         DC    X'02C1C2C3C4C5C6C7C8C9020202020202'\n         DC    X'02D1D2D3D4D5D6D7D8D9020202020202'\n         DC    X'0202E2E3E4E5E6E7E8E9020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'02C1C2C3C4C5C6C7C8C9020202020202'\n         DC    X'02D1D2D3D4D5D6D7D8D9020202020202'\n         DC    X'0202E2E3E4E5E6E7E8E9020202020202'\n         DC    X'02020202020202020202020202020202'\n         SPACE\n         IKJCPPL\n         IKJPSCB\n         CVT      LIST=YES,DSECT=YES\n         IKJTSVT\n         END\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUEMNTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   128                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         EJECT\n         IHAPSA   LIST=YES                                     HD APR88\n         EJECT                                                 HD APR88\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   14,12,12(13)       SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES            RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    1,8(13)            OUR SAVE AREA POINTER\n         ST    13,4(1)            POINTER TO CALLERS SAVE AREA\n         LR    13,1               @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(R13)         POINT TO CALLERS RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 ASSUME BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 ASSUME BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(RML)               MESSAGE LENGTH\n         STH   R15,PUTLEN                 PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    2,R13                    @OUR SAVE AREA\n         LR    3,R15                    SAVE RETURN CODE\n         L     R13,4(R13)               @CALLERS SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,3                    RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END   EPUTL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASUB$": {"ttr": 1547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x001\\x01\\x055O\\x01\\x160O\\x145\\x00\\x1c\\x00\\x1d\\x00\\x00\\xc1\\xe2\\xd4\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2005-12-20T00:00:00", "modifydate": "2016-10-30T14:35:31", "lines": 28, "newlines": 29, "modlines": 0, "user": "ASMJCL"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.B.ASM\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(ASUB)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,9),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(1)\n ENTRY   ASUB\n NAME    ASUB(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASUBHELP": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x02\\x01\\x07)O\\x01\\x19\"_!\\x05\\x00a\\x00S\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2007-10-21T00:00:00", "modifydate": "2019-08-13T21:05:02", "lines": 97, "newlines": 83, "modlines": 0, "user": "HELP"}, "text": "* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                                                                     *\n*   Program Name:   ASUB                                              *\n*                                                                     *\n*  Documentation:   This program is meant to be run as a TSO          *\n*                   command, APF authorized, except for the display   *\n*                   functions.                                        *\n*                                                                     *\n*    Environment:   TSO command, APF Authorized.                      *\n*                   PUTLINE interface enabled by APUT, EPUTL.         *\n*                   This program is non-reentrant.                    *\n*                                                                     *\n*    Description:   Display an Auth Table entry from the TSO/E \"auth\" *\n*                   program list tables in storage.  Or display the   *\n*                   entire table.  Or replace one entry with a new    *\n*                   program name.  If you are invoking a display      *\n*                   function, then the entire table is shown, unless  *\n*                   you enter a number, and then, only that slot is   *\n*                   shown.  Only tables manufactured from PARMLIB     *\n*                   entries are displayed or changed, not the ones    *\n*                   created from IKJTABLS in LPALIB, or from the      *\n*                   IKJTABLS load module that was present in an       *\n*                   APF-authorized STEPLIB.                           *\n*                                                                     *\n*       Function:   To substitute one new program name in the global  *\n*                   incore TSO auth tables, IKJEFTE2, IKJEFTE8, or    *\n*                   IKJEFTAP, IKJEFTNS, or even to the PLATCMD or     *\n*                   PLATPGM lists, if they exist.  This is done to    *\n*                   any numbered entry of each table.  Or else merely *\n*                   display the contents of the entire table, or the  *\n*                   contents of any particular numbered entry.        *\n*                                                                     *\n*                   Also, a blanking function can be performed on     *\n*                   the last entry of any table, which is usually     *\n*                   blank anyway.  No blanking can be performed on    *\n*                   a slot in the middle of a table, because that     *\n*                   will invalidate all the table entries after the   *\n*                   blanked slot, and it is too dangerous to do,      *\n*                   when done irresponsibly.                          *\n*                                                                     *\n*         Syntax:   ASUB TTA nnn pgmname                              *\n*                                                                     *\n*                   Where TT is a table code, and A is an action      *\n*                   code.                                             *\n*                                                                     *\n*                   The table code is a nickname for any of the       *\n*                   TSO/E auth tables which are incore.  They are:    *\n*                                                                     *\n*                   E2 - IKJEFTE2 = AUTHCMD                           *\n*                   E8 - IKJEFTE8 = AUTHPGM                           *\n*                   AP - IKJEFTAP = AUTHTSF                           *\n*                   NS - IKJEFTNS = NOTBKGND                          *\n*                   PC - FCVE     = PLATCMD                           *\n*                   PP - PPVE     = PLATPGM                           *\n*                                                                     *\n*                   If the action code is B (blank the last           *\n*                   entry), then no program name is required.         *\n*                                                                     *\n*                   If the action code is D (display the last         *\n*                   entry), then no program name is required.         *\n*                   The default action is to display the entire       *\n*                   table, unless a number is entered.  If a          *\n*                   number is present, then only that entry           *\n*                   number is displayed.  If the number is larger     *\n*                   than the number of entries in that particular     *\n*                   table, then an informative error message is       *\n*                   issued, and the program ends with code = 4.       *\n*                                                                     *\n*                   If the action code is R (replace the program      *\n*                   name) then a number (the table entry number)      *\n*                   and a program name are required.  If you want     *\n*                   to blank the last slot, instead of putting a      *\n*                   program name into it, then use action code B.     *\n*                                                                     *\n*                   If the PLATCMD or PLATPGM keywords (and at least  *\n*                   one name) were not coded in the active IKJTSOxx   *\n*                   PARMLIB entry, then there is no control block of  *\n*                   names to be pointed to, and therefore no addition *\n*                   of names can be made.  The condition is reported. *\n*                                                                     *\n*             Note:  If an E2, E8, AP, or NS table which is being     *\n*                    used by the system, did not come from the        *\n*                    IKJTSOxx PARMLIB entry, but it came from the     *\n*                    default IKJTABLS entry in LPALIB, then an        *\n*                    appropriate error message is displayed, and      *\n*                    no action is performed on that table.            *\n*                                                                     *\n*       Suggestion:  If you want to \"nullify\" any entry in one of     *\n*                    the tables, replace it with a question mark '?'  *\n*                    by entering ASUB xxR nn ? .                      *\n*                                                                     *\n*                    This will replace the program name entry with    *\n*                    a question mark (not an executable program)      *\n*                    but it will not nullify the subsequent table     *\n*                    entries.                                         *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LLWA": {"ttr": 1796, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01!\\x00&\\x01\\x06\\x01\\x8f\\x01\\t\\x08o\\x181\\r\\xcb\\x04)\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.33", "flags": 0, "createdate": "2006-01-18T00:00:00", "modifydate": "2009-03-27T18:31:26", "lines": 3531, "newlines": 1065, "modlines": 0, "user": "SOURCE"}, "text": "LLWA     TITLE 'LLWA. Replace the TSO AUTH tables from various sources'\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   Program Name:   LLWA                                              *\n*                                                                     *\n*  Documentation:   This program is meant to be run as a TSO          *\n*                   command, APF authorized.  This program will       *\n*                   replace the four TSO authorization tables that    *\n*                   are used by your TSO session:  IKJEFTE2,          *\n*                   IKJEFTE8, IKJEFTAP, and IKJEFTNS, and will        *\n*                   re-point the proper addresses in the LWA          *\n*                   (Logon Work Area) to point to the new tables.     *\n*                   The effect of the change is immediate, and        *\n*                   it will only affect the invoker's TSO session.    *\n*                                                                     *\n*    Environment:   TSO command, APF Authorized.                      *\n*                                                                     *\n*                   Linkedit this program with PARM of NORENT         *\n*                     and NOREUS, for best efficiency.                *\n*                                                                     *\n*                   PUTLINE interface enabled by APUT, EPUTL.         *\n*                                                                     *\n*                   This program is non-reentrant.                    *\n*                                                                     *\n*       Function:   To load a completely new set of TSO authorization *\n*                   tables from any of several sources, including a   *\n*                   load library, a IKJTSOxx-format PARMLIB-type pds  *\n*                   member, or an LRECL=8 list of names.  The newly   *\n*                   loaded tables are immediately honored by your TSO *\n*                   session.  If you choose load library input, the   *\n*                   load library has to be APF authorized.  And this  *\n*                   program has to be APF-authorized.                 *\n*                                                                     *\n*                   If the source is a load library with IKJTABLS     *\n*                   type CSECTs, IKJEFTE2, IKJEFTE8, IKJEFTAP, etc.,  *\n*                   the tables should be present with CSECT names     *\n*                   KKJEFTE2, etc. instead of IKJEFTE2, etc. because  *\n*                   LOAD should find the correct copy, and not reuse  *\n*                   the TSO userid's copy which is in JPA, and which  *\n*                   is searched first, even using a DCB-directed      *\n*                   LOAD.                                             *\n*                                                                     *\n*                   Optionally data conversion of the source tables   *\n*                   can be done, to convert PARMLIB input, or load    *\n*                   module input, to the more easily stored and       *\n*                   manipulated LRECL=8 dataset list input.           *\n*                                                                     *\n*                                                                     *\n*         Syntax:   LLWA  ctnC                                        *\n*                                                                     *\n*                        c=code: L-from loadlib                       *\n*                                D-from LRECL=8 name list             *\n*                                P-from PARMLIB-like IKJTSOxx member  *\n*                                                                     *\n*                        tn=table name:   E2, E8, NS, AP              *\n*                                                                     *\n*                               (tn can usually be left out)          *\n*                                                                     *\n*                        The optional C as fourth letter in the       *\n*                         PARM will perform data conversion only,     *\n*                         from either PARMLIB-format or load library  *\n*                         format, into LRECL=8 dataset list format.   *\n*                                                                     *\n*                   example:  LLWA  LE2  load E2 table from loadlib   *\n*                                                                     *\n*                   example:  LLWA  D    load all tables from dataset *\n*                                                                     *\n*                   example:  LLWA  P--C convert IKJTSOxx-type input  *\n*                                         to an LRECL=8 dataset list  *\n*                                                                     *\n*                   default:  reload all tables.                      *\n*                             no default for code.                    *\n*                                                                     *\n*                   If the LLWAPOUT DD name is allocated (to an       *\n*                   LRECL=8 dataset), then LRECL=8 output in          *\n*                   \"program name list\" format will be produced       *\n*                   from the PARMLIB-format member, or from a         *\n*                   loadlib member in the IKJTABLS load module.       *\n*                   In other words, the PARMLIB-format input or       *\n*                   the load module CSECTs will be converted to       *\n*                   LRECL=8 program name list format.                 *\n*                                                                     *\n*     Conversion:   You can use the LLWA command to perform data      *\n*                   conversion from either load module input, or      *\n*                   PARMLIB-format input, into LRECL=8 dataset        *\n*                   input.  Just allocate the input files:            *\n*                                                                     *\n*                      LLWALIB    or   LLWAPRM                        *\n*                                                                     *\n*                   and the output file:                              *\n*                                                                     *\n*                      LLWAPOUT                                       *\n*                                                                     *\n*                   and execute:                                      *\n*                                                                     *\n*                      LLWA L--C  to convert Load Library input       *\n*                                   to LRECL=8 dataset input          *\n*                                                                     *\n*                   or                                                *\n*                      LLWA P--C  to convert PARMLIB-format input     *\n*                                   to LRECL=8 dataset input          *\n*                                                                     *\n*                   If \"conversion only\" is performed, no new Auth    *\n*                   tables will be reloaded.  The auth tables for     *\n*                   your TSO session will stay as they were.          *\n*                                                                     *\n*         Action:   For LLWA L    (loadlib input for the tables)      *\n*                                                                     *\n*                   Single table, or all four tables, are loaded      *\n*                   into core (from the loadlib) and measured.        *\n*                   Measurement stops at the first blank entry.       *\n*                   Then, 240 bytes  (30 blank entries) are           *\n*                   added at the end of the E2, E8, and AP            *\n*                   tables.  104 bytes (10 blank entries              *\n*                   followed by X'FFFF') are added on at the end      *\n*                   of the NS table.  Subpool 252 storage in Key      *\n*                   0 is GETMAINed for each table, and the            *\n*                   LOADed tables are copied into their               *\n*                   designated GETMAIN areas.  Then the LWA           *\n*                   fields are re-pointed to the new tables and       *\n*                   to their sizes, so that the user's session        *\n*                   will honor them immediately.  Simulation of       *\n*                   a load from PARMLIB is done.  But the STEPLIB     *\n*                   flags are turned on, so that a PARMLIB UPDATE(xx) *\n*                   command (issued globally on the MVS instance)     *\n*                   will not overlay the tables that we have          *\n*                   created.                                          *\n*                                                                     *\n*                   For LLWA D    (LRECL=8 program name list input)   *\n*                                                                     *\n*                   For LRECL=8 input, see notes before label         *\n*                   USEDSET.  These will describe the action of       *\n*                   the program for that kind of input.               *\n*                       (described below)                             *\n*                                                                     *\n*                   For LLWA P    (PARMLIB-format (IKJEFTxx) input)   *\n*                                                                     *\n*                   For PARMLIB-format input, see notes before        *\n*                   label USEPLIB.  These will describe the action    *\n*                   of the program for that kind of input.            *\n*                       (described below)                             *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  Change Log:                                                        *\n*    2008/12/11 - 1.0 - Initial version - Got it to work.             *\n*                                                                     *\n*    2009/03/15 - 1.1 - FREEMAIN the old tables after creating        *\n*                       the new ones.                                 *\n*                                                                     *\n***********************************************************************\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*       I N S T R E A M    M A C R O S                                *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n***********************************************************************\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.\n*  ---------------------------------------------------------------  *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\n         YREGS\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         STM   R15,R1,HEXSAVE\n         LA    R1,&FROM\n         LA    R0,&LEN\n         LA    R15,&TO\n         BAL   R9,HEX\n         LM    R15,R1,HEXSAVE\n         MEND\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* ------------------------------------------------------------------- *\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\nLLWA     CSECT\nLLWA     AMODE 31\nLLWA     RMODE 24\n         USING *,R15                                                  *\n         B     BEGINN               Eyecatcher\nBBYTES   DC    F'4000'        If we have to guess Max size of table\nBENTRIES DC    F'500'         If we have to guess Max number of entries\nNBYTES   DC    F'1000'        If we have to guess Max size of table\nNENTRIES DC    F'100'         If we have to guess Max number of entries\n         DC    CL7'LLWA - '\nVERS#    DC    CL8'Ver 1.33'\n         DC    CL16' &SYSDATE &SYSTIME '\nBEGINN   DS    0H\n         DROP  R15\n         USING LLWA,R12,R11,R10,R6,R7  Set up base registers.\n         STM   R14,R12,12(R13)\n         LR    R12,R15              Set up base registers.\n         ST    R1,SAVEPARM          Save CPPL pointer to use later.\n         LA    R11,4095(,R12)       Second base.\n         LA    R11,1(,R11)\n         LA    R10,4095(,R11)       Third base.\n         LA    R10,1(,R10)\n         LA    R6,4095(,R10)        Fourth base.\n         LA    R6,1(,R6)\n         LA    R7,4095(,R6)         Fifth base.\n         LA    R7,1(,R7)\n         LA    R1,SAVEAREA          Point to new save area\n         ST    R1,8(,R13)           Forward save area chain pointer\n         ST    R13,4(,R1)           Backward save area chain pointer\n         LR    R13,R1               New save area address\n         B     INITCON              Branch past save area\n         SPACE 1\n* ----------------------------------------------------------------- *\nSAVEAREA DC    18F'0'               Non-reentrant save area\nSAVEPARM DC    F'0'                 Parm address from R1 at entry\n* ----------------------------------------------------------------- *\nINITCON  DS    0H                   Initialize constants needed.\n         MVI   BLANKS-1,X'40'       Initialize to blanks.\n         MVC   BLANKS(L'BLANKS),BLANKS-1\n         XC    CVDAREA,CVDAREA\n         MVI   CVDAREA+7,X'0F'      Initialize to packed 0.\n         MVI   GETPINIT,X'40'       Initialize to blanks.\n         MVC   GETPWORK,GETPWORK-1\n         MVC   WORKLIT,BLANKS\n         MVC   OPTSAVE,BLANKS\n         MVI   OPENFLG,X'00'        Initialize flags to zeros.\n         MVI   POUTFLG,X'00'\n         MVI   LONGFLG,X'00'\n         MVI   DTABFLG,X'00'\n         MVI   PTABFLG,X'00'\n         MVI   KEYWFLG,X'00'\n         MVI   MODEFLG,X'00'\n         MVI   LWAPFLG,X'00'\n         MVI   LWAMFLG,X'00'\n         MVI   LOADEFLG,X'00'\n         MVI   WICHFLG,X'F0'        Initialize so all flags are on.\n         MVI   WORKFLG,X'FF'        Has to start \"very non-zero\".\n         MVI   LINEB,X'40'          For clearing output line.\n         XC    E2DLNTH,E2DLNTH      Zero out \"counting\" fields.\n         XC    E8DLNTH,E8DLNTH\n         XC    APDLNTH,APDLNTH\n         XC    NSDLNTH,NSDLNTH\n         XC    BLNKCNT,BLNKCNT\n         XC    NTRYCNT,NTRYCNT\n         XC    PARMLBIN,PARMLBIN\n         XC    SAVETCUR,SAVETCUR\n* ----------------------------------------------------------------- *\nTIOTSCAN DS    0H             Determine the presence of Optional    *\n*                             DDNAME :  LLWAPOUT.                   *\n* ----->                      OPEN and CLOSE only if DD name        *\n* ----->                       is present.                          *\n* ----------------------------------------------------------------- *\n         ST    R4,KEEPR4A     Save work registers.\n         ST    R5,KEEPR5A\n         L     R5,16          R5=CVT\n         L     R5,0(,R5)      R5=TCB WORDS\n         L     R5,4(,R5)      R5=MY TCB\n         L     R5,12(,R5)     R5=TIOT\n         LA    R5,24(,R5)     R5=FIRST DD ENTRY\nTIOTLOOP CLC   0(4,R5),=XL4'00' END OF TIOT?\n         BE    TIOTSEND       YES, CHECK FOR OUTPUT VOL OVERRIDES\n         CLC   4(8,R5),LLWAPOUC     LLWAPOUT DDNAME THERE?\n         BNE   TIOTNEXT       NO\n         OI    OPENFLG,X'01'        SHOW PRESENCE OF LLWAPOUT DD\n         B     TIOTNEXT       CONTINUE\nTIOTNEXT SR    R4,R4\n         IC    R4,0(,R5)      R4=LENGTH OF DD ENTRY\n         AR    R5,R4          R5=NEXT DD ENTRY\n         B     TIOTLOOP       GO CHECK IT\nOPENFLG  DC    X'00'\nOPENSYSL DC    X'00'\nLLWAPOUC DC    C'LLWAPOUT'\nKEEPR4A  DC    F'0'\nKEEPR5A  DC    F'0'\nTIOTSEND DS    0H\n         L     R4,KEEPR4A     Restore work registers.\n         L     R5,KEEPR5A\n* ------------------------------------------------------------------ *\nGETPSCB  DS    0H                  See if we are allowed to\n*                                  run this program.\n         L     R2,16               POINT TO CVT.\n         L     R2,0(,R2)           POINT TO TCB/ASCB WORDS\n         L     R2,4(,R2)           POINT TO TCB.\n         L     R2,X'B4'(,R2)       POINT TO JSCB.\n         L     R2,X'108'(,R2)      POINT TO PSCB.\n         LA    R2,0(,R2)           CLEAR HIGH BYTE.\n         LTR   R2,R2               ANY PSCB?\n         BZ    EOJ4                GET OUT.  NOT TSO.\n         L     R1,SAVEPARM         Get the address of the CPPL back\n         USING CPPL,R1\n         L     R0,CPPLUPT          Copy CPPL fields for possible\n         ST    R0,SAVEUPT            later use, if needed.\n         L     R0,CPPLPSCB\n         ST    R0,SAVEPSCB\n         L     R0,CPPLECT\n         ST    R0,SAVEECT\n         DROP  R1\n         BAL   R9,PGMTITLE         First display the program title.\n         USING PSCB,R2\nCHEKAUTH DS    0H\n         NOP   GETLWA              Bypass authorization check\n         TM    PSCBATR1,PSCBACCT   ACCT user?\n         BO    GETLWA              Yes.  Continue.\n         TM    PSCBATR1,PSCBCTRL   OPER user?\n         BZ    EOJ4                No.  Get out.\n         DROP  R2\n***** ----- >>>>>\nGETLWA   DS    0H                  Obtain all the relevant fields\n*                                  from the LWA (Logon Work Area)\n         L     R2,X'224'           POINT TO PSAAOLD\n         L     R2,X'6C'(,R2)       POINT TO ASXB\n         L     R2,X'14'(,R2)       POINT TO LWA\n         ST    R2,LWAADDR          Store LWA address\n         USING LWA,R2\n* ------------------------------------------------------------------ *\n*    Save all the relevant information from the LWA, to use later.   *\n* ------------------------------------------------------------------ *\n         ST    R5,SAVER5B          Store original contents of R5\n         L     R5,LWATNS           Pointer to NS table\n         ST    R5,SAVETNS          Save it.\n         L     R5,LWATE2           Pointer to E2 table\n         ST    R5,SAVETE2          Save it.\n         L     R5,LWATE8           Pointer to E8 table\n         ST    R5,SAVETE8          Save it.\n         L     R5,LWATAP           Pointer to AP table\n         ST    R5,SAVETAP          Save it.\n         XR    R5,R5               Clear register to be double sure.\n         LH    R5,LWATNSLN         Length of NS table if available\n         STH   R5,SAVETNSL         Save whatever was there in program.\n         LTR   R5,R5               Has a size been supplied in the LWA?\n         BZ    NONSSIZE            No\n         OI    LWAMFLG,X'40'       Yes. Indicate that in a flag.\n         B     YSNSSIZE\nNONSSIZE DS    0H\n         L     R5,SAVETNS            No size given, measure the table.\n         BAL   R9,MEASOL10           Measure as well as possible.\n         MVC   SAVETNSL(2),MO10LENG  Move measured length into field.\nYSNSSIZE DS    0H\n         LH    R5,LWATE2LN         Length of E2 table if available\n         STH   R5,SAVETE2L         Save whatever was there in program.\n         LTR   R5,R5               Has a size been supplied in the LWA?\n         BZ    NOE2SIZE            No\n         OI    LWAMFLG,X'20'       Yes. Indicate that in a flag.\n         B     YSE2SIZE\nNOE2SIZE DS    0H\n         L     R5,SAVETE2            No size given, measure the table.\n         BAL   R9,MEASOL08           Measure as well as possible.\n         MVC   SAVETE2L(2),MO08LENG  Move measured length into field.\nYSE2SIZE DS    0H\n         LH    R5,LWATE8LN         Length of E8 table if available\n         STH   R5,SAVETE8L         Save whatever was there in program.\n         LTR   R5,R5               Has a size been supplied in the LWA?\n         BZ    NOE8SIZE            No\n         OI    LWAMFLG,X'10'       Yes. Indicate that in a flag.\n         B     YSE8SIZE\nNOE8SIZE DS    0H\n         L     R5,SAVETE8            No size given, measure the table.\n         BAL   R9,MEASOL08           Measure as well as possible.\n         MVC   SAVETE8L(2),MO08LENG  Move measured length into field.\nYSE8SIZE DS    0H\n         LH    R5,LWATAPLN         Length of AP table if available\n         STH   R5,SAVETAPL         Save whatever was there in program.\n         LTR   R5,R5               Has a size been supplied in the LWA?\n         BZ    NOAPSIZE            No\n         OI    LWAMFLG,X'80'       Yes. Indicate that in a flag.\n         B     YSAPSIZE\nNOAPSIZE DS    0H\n         L     R5,SAVETAP            No size given, measure the table.\n         BAL   R9,MEASOL08           Measure as well as possible.\n         MVC   SAVETAPL(2),MO08LENG  Move measured length into field.\nYSAPSIZE DS    0H\n         L     R5,SAVER5B          Restore original R5 contents\n         MVC   LWAPFLG,LWAPRMLB    Save flags showing which tables\n*                                  came from STEPLIB, if any.\n         DROP  R2\n* ------------------------------------------------------------------ *\n*    At this point we have finished saving things out of the LWA.    *\n* ------------------------------------------------------------------ *\n* -- >       Test if this command is being run APF Authorized\nAPFTEST  DS    0H\n         STM   R15,R1,SAVE1401     Now save registers and test if APF\n         XR    R15,R15                  authorized.\n         TESTAUTH FCTN=1           Are we authorized?\n         LTR   R15,R15             Test the return code.\n         BNZ   NOTAUTH             Not zero, tell not authorized.\n         LM    R15,R1,SAVE1401     Restore registers used by TESTAUTH.\n* -- >\n* ------------------------------------------------------------------ *\n*    Now we'll get the parm value to see what file we should OPEN.   *\n* ------------------------------------------------------------------ *\n         L     R1,SAVEPARM         Get the Parm pointer we saved before\n         LTR   R1,R1               Any CPPL or PARM pointer?\n         BZ    EOJ4                B if not.\n         ST    R2,SAVER2D\n         L     R2,0(,R1)           Point to buffer\n         LTR   R2,R2               Any?\n         BZ    EOJ4                B if not.\n         LH    R3,0(R2)            Load length.\n         LTR   R3,R3               Any?\n         BZ    EOJ4                B if not.\n         CLI   2(R2),X'00'         Command Processor invocation?\n         BE    RLDCP               Handle it.\n         LA    R2,2(,R2)           Point to PARM.\n         B     PARM\nRLDCP    CH    R3,=H'4'            Any PARM?\n         BE    NOPARMS             B if NOT.\n         AH    R2,2(,R2)           POINT TO ...\n         LA    R2,4(,R2)           ... PARM.\nPARM     OI    0(R2),C' '          UPPERCASE. Parm for which source\n         OI    1(R2),C' '          UPPERCASE. Parm for which table\n         OI    2(R2),C' '          UPPERCASE.\n         OI    3(R2),C' '          UPPERCASE. 3rd Parm for Extras\n         MVC   OPTSAVE(4),0(R2)\n* --- PARMS gotten at this point. ----------------------------------- *\nLONGSHRT DS    0H                  Do we want extra output for LLWA P?\n         CLI   3(R2),C'L'          Is there an L in the fourth place?\n         BE    LONGDIAG            Yes. Extra diagnostics wanted.\n         CLI   3(R2),C'C'          Is there a C in the fourth place?\n         BE    LONGCONV            Yes. Conversion only wanted.\n         B     PARMCLER            Default--don't set any flags.\nLONGDIAG DS    0H\n         OI    LONGFLG,X'01'       Turn on \"extra outputs\" flag.\n         B     PARMCLER\nLONGCONV DS    0H\n         OI    LONGFLG,X'02'       Turn on \"convert only\" flag.\n         BAL   R9,CONVONLY         Message to that effect\n         B     PARMCLER\nPARMCLER DS    0H\n         MVI   3(R2),X'40'         Prevent reuse of PARM later.\n* ------------------------------------------------------------------ *\n*  You can invoke the command:  LLWA P--L  to trigger the extra output.\n*  You can invoke the command:  LLWA P--C  to do data conversion only.\n*  You can invoke the command:  LLWA L--C  to do data conversion only.\n* ------------------------------------------------------------------ *\nWICHTABL DS    0H                  Are we limiting to only one table?\n*                                  WICHFLG is set to X'F0' initially.\n* ------------------------------------------------------------------ *\n         CLC   1(2,R2),=C'E2'      Limiting to E2?\n         BE    SETONLE2            Yes. Set it.\n         CLC   1(2,R2),=C'E8'      Limiting to E8?\n         BE    SETONLE8            Yes. Set it.\n         CLC   1(2,R2),=C'AP'      Limiting to AP?\n         BE    SETONLAP            Yes. Set it.\n         CLC   1(2,R2),=C'NS'      Limiting to NS?\n         BE    SETONLNS            Yes. Set it.\n         B     SETONEND            Default is to do all the tables.\n* ------------------------------------------------------------------ *\n*     This is a global setting for the entire program, to limit\n*      output to only one table.  Default setting for WICHFLG\n*      is X'F0' (all of the outputs on).  See label INITCON.\n* ------------------------------------------------------------------ *\nSETONLE2 DS    0H                  Only E2?\n         OI    WICHFLG,X'20'       Turn on this table.\n         NI    WICHFLG,X'20'       Turn off other tables.\n         B     WICHOPEN\nSETONLE8 DS    0H                  Only E8?\n         OI    WICHFLG,X'10'       Turn on this table.\n         NI    WICHFLG,X'10'       Turn off other tables.\n         B     WICHOPEN\nSETONLAP DS    0H                  Only AP?\n         OI    WICHFLG,X'80'       Turn on this table.\n         NI    WICHFLG,X'80'       Turn off other tables.\n         B     WICHOPEN\nSETONLNS DS    0H                  Only NS?\n         OI    WICHFLG,X'40'       Turn on this table.\n         NI    WICHFLG,X'40'       Turn off other tables.\n         B     WICHOPEN\nSETONEND DS    0H\n* ------------------------------------------------------------------ *\n* Use the PARM to select where the input tables will be coming from.\n* ------------------------------------------------------------------ *\nWICHOPEN DS    0H         What kind of input does the program expect?\n         MVC   1(2,R2),=C'  '      Clear PARMs from 2nd and 3rd places\n         CLI   0(R2),C'L'          PARM = L ?\n         BE    USELOAD             OPEN Load Module input.\n         CLI   0(R2),C'D'          PARM = D ?\n         BE    USEDSET             OPEN LRECL=8 Dataset input.\n         CLI   0(R2),C'P'          PARM = P ?\n         BE    USEPLIB             OPEN IKJTSOxx PARMLIB format input.\n         B     NOPARMS             Otherwise exit with message.\n* ------------------------------------------------------------------ *\n* USEDSET takes LRECL=8 input consisting of (up to) 4 lists of\n* program names.  The list belonging to each table is defined by\n* a header entry, which is \"---E2---\", \"---E8---\", \"---AP---\",\n* or \"---NS---\".\n*\n* Output is 4 prebuilt tables in \"above the 16M line storage\".\n* Depending on the limiting parms, either all the 4 tables are\n* replaced in SP-252 core, or only the one selected is replaced.\n*\n* Copying of the tables is via an MVCL instruction, the same way\n* IBM does it at LOGON time, in module IKJEFTP1.\n* ------------------------------------------------------------------ *\nUSEDSET  DS    0H\n         L     R2,SAVER2D          R2 no longer points to PARMs.\n         MVI   MODEFLG,X'02'       Dataset Input in effect\n* ---       Did we code conversion only by mistake? - below\n         TM    LONGFLG,X'02'       Did we specify conversion only here?\n         BZ    USEDSEDO            No. Just do regular processing.\n         BAL   R9,CONVNOTL         Yes. Say it doesn't make sense.\n         B     EOJ4                And exit the program.\nUSEDSEDO DS    0H\n* ---       Did we code conversion only by mistake? - above\n         OPEN  (LLWALST,(INPUT))\n         TM    LLWALST+48,X'10'    Is the DD OPEN  ?                     01914\n         BZ    NOALLOCD            No. Error message.                    01915\n         RDJFCB LLWALST\n         MVC   MSGPRTJF(7),=C'LLWALST'   Move DD name into message\n         BAL   R9,PRTJFCB          Print dataset information\n         TM    JFCRECFM,X'80'      Is RECFM fixed?\n         BZ    NOTFIXED            No. Send error message.\n         CLC   =H'8',JFCLRECL      Is LRECL = 8 ?\n         BNE   NOLRECL8            No. Send error message.\n* ---                              All is OK with dataset attributes.\n         BAL   R9,GETDBUFS         Get buffers for E2, E8, AP, NS.\n         BAL   R9,GETDMEAS         Read Input File all through.\n* ---                              And measure all the tables.\nDDE2     DS    0H                  Construct all the auth tables.\n         TM    WICHFLG,X'20'\n         BZ    DDE8\n         BAL   R9,E2DNWTAB         Construct E2 table and point to it\nDDE8     DS    0H\n         TM    WICHFLG,X'10'\n         BZ    DDAP\n         BAL   R9,E8DNWTAB         Construct E8 table and point to it\nDDAP     DS    0H\n         TM    WICHFLG,X'80'\n         BZ    DDNS\n         BAL   R9,APDNWTAB         Construct AP table and point to it\nDDNS     DS    0H\n         TM    WICHFLG,X'40'\n         BZ    DDEND\n         BAL   R9,NSDNWTAB         Construct NS table and point to it\nDDEND    DS    0H\n         BAL   R9,FREDBUFS         Free the table construction buffers\n         BAL   R9,FREOLDTB\n         B     EOJ0\n* ------------------------------------------------------------------ *\n* USEPLIB takes PARMLIB-format input that looks like an IKJTSOxx\n* member.  This member is read, and is scanned for names that are\n* between AUTHCMD NAMES ( ), AUTHPGM NAMES ( ), AUTHTSF NAMES( ),\n* or NOTBKGND NAMES( ).  Those program names are converted into a\n* list, in the four separate categories, as they are present in the\n* IKJTSOxx-like dataset.\n*\n* Output is 4 prebuilt tables in \"above the 16M line storage\".\n* Depending on the limiting parms, either all the 4 tables are\n* replaced in SP-252 core, or only the one selected is replaced.\n*\n* Copying of the tables is via an MVCL instruction, the same way\n* IBM does it at LOGON time, in module IKJEFTP1.\n*\n* Optional LRECL=8 output can be generated in LIST format, if an\n* LLWAPOUT DD name is allocated to an LRECL=8 dataset, optionally.\n* This output can be edited later, and used as input to LLWA D.\n* ------------------------------------------------------------------ *\nUSEPLIB  DS    0H\n         L     R2,SAVER2D          R2 no longer points to PARMs.\n         MVI   MODEFLG,X'04'       PARMLIB Input in effect\n         OPEN  (LLWAPRM,(INPUT))\n         TM    LLWAPRM+48,X'10'    Is the DD OPEN  ?                     01914\n         BZ    NOALLOCP            No. Error message.                    01915\n         RDJFCB LLWAPRM\n         MVC   MSGPRTJF(7),=C'LLWAPRM'   Move DD name into message\n         BAL   R9,PRTJFCB          Print dataset information\n         TM    JFCRECFM,X'80'      Is RECFM fixed?\n         BZ    NOTFIXED            No. Send error message.\n         CLC   =H'80',JFCLRECL     Is LRECL = 80 ?\n         BNE   NOLREC80            No. Send error message.\n         BAL   R9,OPENPOUT         Conditionally OPEN LLWAPOUT DD\n* ---                              All is OK with dataset attributes.\n         BAL   R9,GETDBUFS         Get buffers for E2, E8, AP, NS.\n         BAL   R9,GETPREAD         Read parmlib member--put out names\n         BAL   R9,FREDBUFS         Free the table construction buffers\n         BAL   R9,CLOSPOUT         Conditionally CLOSE LLWAPOUT DD\n         BAL   R9,FREOLDTB\n         B     EOJ0\n* ------------------------------------------------------------------ *\nUSELOAD  DS    0H\n         L     R2,SAVER2D          R2 no longer points to PARMs.\n         MVI   MODEFLG,X'01'       Load Library input in effect\n         OPEN  LLWALIB\n         TM    LLWALIB+48,X'10'    Is the DD OPEN  ?                     01914\n         BZ    NOALLOCL            No. Error message.                    01915\n         RDJFCB LLWALIB\n         MVC   MSGPRTJF(7),=C'LLWALIB'   Move DD name into message\n         BAL   R9,PRTJFCB          Print dataset information\n         TM    JFCRECFM,X'C0'      Is RECFM = U ?\n         BNO   NOTLOADL            No. Send error message.\n         TM    JFCDSORG,X'02'      Is DSORG = PO ?\n         BNO   NOTLOADL            No. Send error message.\n         BAL   R9,OPENPOUT         Conditionally OPEN LLWAPOUT DD.\nDOE2     DS    0H                  Is AUTHCMD to be loaded?\n         TM    WICHFLG,X'20'       Check switch\n         BZ    DOE8                Not on. Do next one.\n         BAL   R9,LOADE2           Load IKJEFTE2.\n         BAL   R9,E2NEWTAB         Construct incore table and copy it.\n* -- >\nDOE8     DS    0H                  Is AUTHPGM to be loaded?\n         TM    WICHFLG,X'10'       Check switch\n         BZ    DOAP                Not on. Do next one.\n         BAL   R9,LOADE8           Load IKJEFTE8.\n         BAL   R9,E8NEWTAB         Construct incore table and copy it.\n* -- >\nDOAP     DS    0H                  Is AUTHTSF to be loaded?\n         TM    WICHFLG,X'80'       Check switch\n         BZ    DONS                Not on. Do next one.\n         BAL   R9,LOADAP           Load IKJEFTAP.\n         BAL   R9,APNEWTAB         Construct incore table and copy it.\n* -- >\nDONS     DS    0H                  Is NOTBKGND to be loaded?\n         TM    WICHFLG,X'40'       Check switch\n         BZ    DOEND               Not on. Do next one.\n         BAL   R9,LOADNS           Load IKJEFTNS.\n         BAL   R9,NSNEWTAB         Construct incore table and copy it.\n* -- >\nDOEND    DS    0H                  End of LOADs.\n         CLOSE LLWALIB\n         BAL   R9,CLOSPOUT         Conditionally CLOSE LLWAPOUT DD.\n         BAL   R9,FREDBUFS\n         BAL   R9,FREOLDTB\n         B     EOJ0\n** ---------------------------------------------------------------- **\nEOJ      DS    0H                  END OF JOB\n         L     R13,4(,R13)\n         LR    R15,R5              Put in real return code\n         ST    R15,16(,R13)        Shove it where it belongs\n         L     R14,12(,R13)        R14 and\n         LM    R0,R12,20(R13)        rest of registers\n         BR    R14                 Go back to caller\nEOJ0     DS    0H                  Return code 0\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGR0       Show Return Code 0\n         APUT  MESSAGR0,L'MESSAGR0\n         LA    R5,0                Set CC = 0\n         B     EOJ                 Now end the program\nEOJ4     DS    0H                  Return code 4\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGR4       Show Return Code 4\n         APUT  LINE,L'MESSAGR4\n         L     R5,FULLFOUR         Set CC = 4\n         B     EOJ                 Now end the program\nEOJ8     DS    0H                  Return code 8\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGR8       Show Return Code 8\n         APUT  LINE,L'MESSAGR8\n         L     R5,FULLEIGT         Set CC = 8\n         B     EOJ                 Now end the program\nEOJC     DS    0H                  Return code 12\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGRC       Show Return Code 12\n         APUT  LINE,L'MESSAGRC\n         L     R5,FULLTWLV         Set CC = 12\n         B     EOJ                 Now end the program\n* ----------------------------------------------------------------- *\n*     Various \"abnormal ending\" routines.                           *\n* ----------------------------------------------------------------- *\nNOTAUTH  DS    0H                     Command not authorized message.\n         APUT  MESSAG2C,L'MESSAG2C    This is instead of getting\n         APUT  MESSAG2D,L'MESSAG2D      an S047 abend. We don't let\n         B     EOJC                     that happen.\n* ----------------------------------------------------------------- *\n*     If a PARMLIB card is in error, show the card and line number. *\n* ----------------------------------------------------------------- *\nERRNAME1 DS    0H\n         MVC   LINE,LINE-1        Display a blank line first.\n         APUT  LINE,30\n         ST    R2,SAVER2B         Convert binary line number to\n         L     R2,PARMLBIN          decimal for display purposes.\n         CVD   R2,CVDAREA                 Convert to decimal\n         MVC   PARMLDEC,CVDAREA           Store away for reporting\n         L     R2,SAVER2B         Restore work register.\n         MVC   LINE,LINE-1           Display\n         MVC   LINE(10),MASK10         card\n         ED    LINE(10),PARMLDEC+3       number\n         MVC   LINE(5),=C'Card-'           and\n         MVC   LINE+11(80),GETPWORK          card image.\n         APUT  LINE,91\n         MVC   LINE,LINE-1\n         MVC   LINE+7(28),=C'This line contains an error.'\n         APUT  LINE,53\n         MVC   LINE,LINE-1\n         MVC   LINE+7(32),=C'Please correct and rerun LLWA P.'\n         APUT  LINE,53\n         MVC   LINE,LINE-1        Display another blank line.\n         APUT  LINE,30\n         B     EOJ4               Show RC = 4.\n* ----------------------------------------------------------------- *\nNOPARMS  DS    0H                   Message that PARMs are necessary.\n         APUT  MESSAG2F,L'MESSAG2F\n         B     EOJ4\n* ----------------------------------------------------------------- *\nNOTFIXED DS    0H                   Allocated file is not RECFM=F.\n         APUT  MESSAG6A,L'MESSAG6A\n         B     EOJ4\n* ----------------------------------------------------------------- *\nNOTLOADL DS    0H                   Allocated file is not a load lib\n         APUT  MESSAG6B,L'MESSAG6B\n         B     EOJ4\n* ----------------------------------------------------------------- *\nNOALLOCL DS    0H                   Need to alloc a load library.\n         APUT  MESSAG4A,L'MESSAG4A\n         APUT  MESSAG4B,L'MESSAG4B\n         B     EOJ8\n* ----------------------------------------------------------------- *\nNOALLOCD DS    0H                   Need to alloc an LRECL=8 dataset.\n         APUT  MESSAG4C,L'MESSAG4C\n         APUT  MESSAG4D,L'MESSAG4D\n         B     EOJ8\n* ----------------------------------------------------------------- *\nNOALLOCP DS    0H                   Need to alloc an LRECL=80 dataset.\n         APUT  MESSAG4E,L'MESSAG4E\n         APUT  MESSAG4F,L'MESSAG4F\n         B     EOJ8\n* ----------------------------------------------------------------- *\nNOALLOCQ DS    0H                   Optional LRECL=8 output dsn missing\n         APUT  MESSAG4G,L'MESSAG4G\n         B     EOJ8\n* ----------------------------------------------------------------- *\nNOALLOCR DS    0H                   LLWAPOUT DD is missing. No output\n         ST    R9,KEEPR9A            was produced.\n         STM   R15,R1,SAVE1401\n         TM    LONGFLG,X'02'        This run for data conversion only?\n         BO    NAALTMSG             Yes. Say so.\n         APUT  MESSAG4H,L'MESSAG4H  No. Just say LLWAPOUT DD missing.\n         B     NOALLOCE\nNAALTMSG DS    0H                   Say you need LLWAPOUT DD allocated\n         APUT  MESSAG4I,L'MESSAG4I\n         NI    LONGFLG,X'FF'-X'02'  Turn off conversion flag.\n         B     EOJ4\nNOALLOCE DS    0H\n         LM    R15,R1,SAVE1401\n         L     R9,KEEPR9A\n         BR    R9\n* ----------------------------------------------------------------- *\nCONVONLY DS    0H                   Say this run is for conversion only\n         ST    R9,KEEPR9E\n         STM   R15,R1,SAVE1401\n         APUT  MESSAG4J,L'MESSAG4J\n         LM    R15,R1,SAVE1401\n         L     R9,KEEPR9E\n         BR    R9\n* ----------------------------------------------------------------- *\nCONVNOTL DS    0H                   Say LRECL=8 to LRECL=8 makes no\n         ST    R9,KEEPR9E             sense.\n         STM   R15,R1,SAVE1401\n         APUT  MESSAG4K,L'MESSAG4K\n         LM    R15,R1,SAVE1401\n         L     R9,KEEPR9E\n         BR    R9\n* ----------------------------------------------------------------- *\nNOLRECL8 DS    0H                   LRECL of dataset is not 8.\n         APUT  MESSAG5A,L'MESSAG5A\n         B     EOJ8\n* ----------------------------------------------------------------- *\nNOLREC80 DS    0H                   LRECL of dataset is not 80.\n         APUT  MESSAG5B,L'MESSAG5B\n         B     EOJ8\n* ----------------------------------------------------------------- *\n** ---------------------------------------------------------------- **\n**    Some of the Register and Pointer Save Areas                   **\n** ---------------------------------------------------------------- **\nSAVETPVT DC    F'0'                   Address of TPVT control block\nSAVECTLT DC    F'0'                   Address of CTLT control block\nSAVEFCVE DC    F'0'                   Address of Platcmd table if non-0\nSAVEPPVE DC    F'0'                   Address of Platpgm table if non-0\nSAVEUPT  DC    F'0'                   Address of UPT\nSAVEECT  DC    F'0'                   Address of ECT\nSAVEPSCB DC    F'0'                   Address of PSCB\nSAVETNS  DC    F'0'                   Address of NS table\nSAVETE2  DC    F'0'                   Address of E2 table\nSAVETE8  DC    F'0'                   Address of E8 table\nSAVETAP  DC    F'0'                   Address of AP table\nSVE2ADDR DC    F'0'                   Address of work buffer\nSVE2HOLD DC    F'0'                   Address in work buffer\nSVE2BUFL DC    F'0'                   Length of work buffer\nSVE8ADDR DC    F'0'                   Address of work buffer\nSVE8HOLD DC    F'0'                   Address in work buffer\nSVE8BUFL DC    F'0'                   Length of work buffer\nSVAPADDR DC    F'0'                   Address of work buffer\nSVAPHOLD DC    F'0'                   Address in work buffer\nSVAPBUFL DC    F'0'                   Length of work buffer\nSVNSADDR DC    F'0'                   Address of work buffer\nSVNSHOLD DC    F'0'                   Address in work buffer\nSVNSBUFL DC    F'0'                   Length of work buffer\nENE2ADDR DC    F'0'                   End address of E2 table data\nENE8ADDR DC    F'0'                   End address of E8 table data\nENAPADDR DC    F'0'                   End address of AP table data\nENNSADDR DC    F'0'                   End address of NS table data\nSAVETNSL DC    H'0'                   Length of NS table, if nonzero\nSAVETE2L DC    H'0'                   Length of E2 table, if nonzero\nSAVETE8L DC    H'0'                   Length of E8 table, if nonzero\nSAVETAPL DC    H'0'                   Length of AP table, if nonzero\nSAVETCUR DC    H'0'                   Copied length of current table\n** ---------------------------------------------------------------- **\nFULLZERO DC    F'0'                   Fullword of numeric 0\nFULLFOUR DC    F'4'                   Fullword 4\nFULLEIGT DC    F'8'                   Fullowrd 8\nFULLTWLV DC    F'12'                  Fullword 12\nSAVE1401 DC    5F'0'                  More for safety\nSAVX1401 DC    5F'0'                  More for safety\nLWAADDR  DC    F'0'                   Address of LWA control block\n* ----------------------------------------------------------------- *\n*  Quantities necessary for building the output tables in storage.  *\n* ----------------------------------------------------------------- *\nMODNAME  DC    CL8'KKJEFT--'\nTESTTABL DC    CL8' '\nTESTSIZE DC    H'0'\nE2SIZE   DC    F'0'\nE8SIZE   DC    F'0'\nAPSIZE   DC    F'0'\nNSSIZE   DC    F'0'\nE2SIZEP  DC    F'0'\nE8SIZEP  DC    F'0'\nAPSIZEP  DC    F'0'\nNSSIZEP  DC    F'0'\n* ----------------------------------------------------------------- *\n*   Literal Pool, thus far.                                         *\n* ----------------------------------------------------------------- *\n         LTORG\n** ---------------------------------------------------------------- **\n*         * - - - - - - - - - - - - - - - - - - - - - - - - *        *\n*         *            S U B R O U T I N E S                *        *\n*         * - - - - - - - - - - - - - - - - - - - - - - - - *        *\n** ---------------------------------------------------------------- **\n**  These are executed using a BAL R9,subroutn  instruction.        **\n** ---------------------------------------------------------------- **\nHEX      DS    0H                    Display a Hex quantity.\n         ST    R9,SAVER9A            (Support for the HEX macro)\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         L     R9,SAVER9A\n         BR    R9                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\nHEXSAVE  DS    3F                    Register save for HEX macro\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nPGMTITLE DS    0H                    Display program title\n         ST    R9,SAVER9F             when executing this program.\n         MVC   LINE,LINE-1           Blank line\n         MVC   LINE,MESSAGET         Move title line in\n         MVC   LINE+62(8),VERS#      Version number into title\n         APUT  LINE,L'MESSAGET       And put out to tube\n         MVC   LINE,LINE-1           Blank line again\n         MVC   LINE,MESSAGEU         Move underlines in\n         APUT  LINE,L'MESSAGEU       And put them out also\n         L     R9,SAVER9F\n         BR    R9                    Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* ----------------------------------------------------------------- *\n*      Measure \"8-byte entry\" loaded table.                         *\n* ----------------------------------------------------------------- *\nMEASUR08 DS    0H                 R5 has beginning address of table.\n         ST    R9,SAVER9O\n         LA    R4,16                Count size of header\n         LA    R5,16(,R5)           Bump past header\n         MVC   ME08WORK,BLANKS      Initialize work area.\n*----->                       ----- Handle LLWAPOUT processing - below\n         TM    POUTFLG,X'01'        Is LLWAPOUT DD OPEN?\n         BZ    ME08GO01             No. Skip putting out to it.\n         PUT   LLWAPOUT,WORKLIT     PUT out header literal\n         MVC   ME08WORK(8),0(R5)    Already pointing at first entry.\n         PUT   LLWAPOUT,ME08WORK\nME08GO01 DS    0H                   Back to rest of processing.\n*----->                       ----- Handle LLWAPOUT processing - above\nME08LOOP DS    0H\n         CLC   =C'        ',0(R5)   Is this entry a blank?\n         BE    ME08THER             Yes. Reached virtual end of table\n         LA    R4,8(,R4)            Count next table entry\n         LA    R5,8(,R5)            Bump to next entry\n*----->                       ----- Handle LLWAPOUT processing - below\n         TM    POUTFLG,X'01'        Is LLWAPOUT DD OPEN?\n         BZ    ME08GO02             No. Skip putting out to it.\nME08TEST DS    0H\n         MVC   ME08WORK,0(R5)       Yes-move program name to work area.\n         CLC   ME08WORK,BLANKS      Don't put out\n         BE    ME08GO02               blank entry at the end.\n         PUT   LLWAPOUT,ME08WORK    PUT out program name.\nME08GO02 DS    0H                   Back to rest of processing.\n*----->                       ----- Handle LLWAPOUT processing - above\n         B     ME08LOOP             Loop back till first blank.\nME08THER DS    0H\n         STH   R4,ME08LENG          Store measured length of table.\n         LA    R5,8(,R5)            Bump past blank entry.\n         ST    R5,ME08END           And record address of table end.\n         L     R9,SAVER9O\n         BR    R9\nME08WORK DC    CL8' '\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* ----------------------------------------------------------------- *\n*      Measure \"10-byte entry\" loaded table.                        *\n* ----------------------------------------------------------------- *\nMEASUR10 DS    0H                 R5 has beginning address of table.\n         ST    R9,SAVER9Q\n         LA    R4,16                Count size of header\n         LA    R5,16(,R5)           Bump past header\n         MVC   ME10WORK,BLANKS      Initialize work area.\n*----->                       ----- Handle LLWAPOUT processing - below\n         TM    POUTFLG,X'01'        Is LLWAPOUT DD OPEN?\n         BZ    ME10GO01             No. Skip putting out to it.\n         PUT   LLWAPOUT,WORKLIT     PUT out header literal\n         MVC   ME10WORK(8),2(R5)    Already pointing at first entry.\n         PUT   LLWAPOUT,ME10WORK\nME10GO01 DS    0H                   Back to rest of processing.\n*----->                       ----- Handle LLWAPOUT processing - above\nME10LOOP DS    0H\n         CLC   =C'        ',2(R5)   Is this entry a blank?\n         BE    ME10THER             Yes. Reached virtual end of table\n         LA    R4,10(,R4)           Count next table entry\n         LA    R5,10(,R5)           Bump to next entry\n*----->                       ----- Handle LLWAPOUT processing - below\n         TM    POUTFLG,X'01'        Is LLWAPOUT DD OPEN?\n         BZ    ME10GO02             No. Skip putting out to it.\nME10TEST DS    0H\n         MVC   ME10WORK,2(R5)       Yes-move program name to work area.\n         CLC   ME10WORK,BLANKS      Don't put out\n         BE    ME10GO02               blank entry at the end.\n         PUT   LLWAPOUT,ME10WORK    PUT out program name.\nME10GO02 DS    0H                   Back to rest of processing.\n*----->                       ----- Handle LLWAPOUT processing - above\n         B     ME10LOOP\nME10THER DS    0H\n         STH   R4,ME10LENG          Store measured length of table.\n         LA    R5,10(,R5)           Bump past blank entry.\n         ST    R5,ME10END           And record address of table end.\n         L     R9,SAVER9Q\n         BR    R9\nME10WORK DC    CL8' '\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETSTORG DS    0H                 Get SP-252 storage for 8-byte table.\n         ST    R9,SAVER9P\n         SR    R2,R2                Clear work register\n         LH    R2,GTSLENG           Load it with measured length\n         AH    R2,=H'240'           Add space for blank entries\n         STH   R2,GTSLENG           Save the total length\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'SP-252 table length:   '\n         HEX   LINE+25,2,GTSLENG\n         APUT  LINE,40\n         MODESET KEY=ZERO\n         LH    R2,GTSLENG\n         GETMAIN RU,LV=(R2),SP=252,LOC=BELOW\n         ST    R1,GTSADDR           Save address of GETMAINed storage\n         L     R9,SAVER9P\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETSTORM DS    0H                 Get SP-252 storage for 10-byte table.\n         ST    R9,SAVER9R\n         SR    R2,R2                Clear work register\n         LH    R2,GTSLENG           Load it with measured length\n         AH    R2,=H'104'           Add space for blank entries\n         STH   R2,GTSLENG           Save the total length\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'SP-252 table length:   '\n         HEX   LINE+25,2,GTSLENG\n         APUT  LINE,40\n         MODESET KEY=ZERO\n         LH    R2,GTSLENG\n         GETMAIN RU,LV=(R2),SP=252,LOC=BELOW\n         ST    R1,GTSADDR           Save address of GETMAINed storage\n         L     R9,SAVER9R\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nLOADE2   DS    0H\n         ST    R9,SAVER9S\n         MVC   MODNAME+6(2),=C'E2'\n         LA    R4,MODNAME\n         MODESET KEY=ZERO\n         LOAD  EPLOC=(R4),DCB=LLWALIB,LSEARCH=YES,ERRET=ERRE2\n         LTR   R15,R15\n         BZ    GOSTORE2\nERRE2    STM   R15,R1,SAVE1401     Now save registers R15 R0 R1.\n         MVC   LINE,LINE-1\n         MVC   LINE(32),=C'E2 table not found - not loaded.'\n         APUT  LINE,80\n         LM    R15,R1,SAVE1401     Restore registers R15 R0 R1.\n         OI    LOADEFLG,X'20'\n         B     EOJ4\nGOSTORE2 DS    0H\n         ST    R0,E2EPT\n*        MODESET KEY=NZERO\n         L     R9,SAVER9S\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nLOADE8   DS    0H\n         ST    R9,SAVER9S\n         MVC   MODNAME+6(2),=C'E8'\n         LA    R4,MODNAME\n         MODESET KEY=ZERO\n         LOAD  EPLOC=(R4),DCB=LLWALIB,LSEARCH=YES,ERRET=ERRE8\n         LTR   R15,R15\n         BZ    GOSTORE8\nERRE8    STM   R15,R1,SAVE1401     Now save registers R15 R0 R1.\n         MVC   LINE,LINE-1\n         MVC   LINE(32),=C'E8 table not found - not loaded.'\n         APUT  LINE,80\n         LM    R15,R1,SAVE1401     Restore registers R15 R0 R1.\n         OI    LOADEFLG,X'10'\n         B     EOJ4\nGOSTORE8 DS    0H\n         ST    R0,E8EPT\n*        MODESET KEY=NZERO\n         L     R9,SAVER9S\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nLOADAP   DS    0H\n         ST    R9,SAVER9S\n         MVC   MODNAME+6(2),=C'AP'\n         LA    R4,MODNAME\n         MODESET KEY=ZERO\n         LOAD  EPLOC=(R4),DCB=LLWALIB,LSEARCH=YES,ERRET=ERRAP\n         LTR   R15,R15\n         BZ    GOSTORAP\nERRAP    STM   R15,R1,SAVE1401     Now save registers R15 R0 R1.\n         MVC   LINE,LINE-1\n         MVC   LINE(32),=C'AP table not found - not loaded.'\n         APUT  LINE,80\n         LM    R15,R1,SAVE1401     Restore registers R15 R0 R1.\n         OI    LOADEFLG,X'80'\n         B     EOJ4\nGOSTORAP DS    0H\n         ST    R0,APEPT\n*        MODESET KEY=NZERO\n         L     R9,SAVER9S\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nLOADNS   DS    0H\n         ST    R9,SAVER9S\n         MVC   MODNAME+6(2),=C'NS'\n         LA    R4,MODNAME\n         MODESET KEY=ZERO\n         LOAD  EPLOC=(R4),DCB=LLWALIB,LSEARCH=YES,ERRET=ERRNS\n         LTR   R15,R15\n         BZ    GOSTORNS\nERRNS    STM   R15,R1,SAVE1401     Now save registers R15 R0 R1.\n         MVC   LINE,LINE-1\n         MVC   LINE(32),=C'NS table not found - not loaded.'\n         APUT  LINE,80\n         LM    R15,R1,SAVE1401     Restore registers R15 R0 R1.\n         OI    LOADEFLG,X'40'\n         B     EOJ4\nGOSTORNS DS    0H\n         ST    R0,NSEPT\n*        MODESET KEY=NZERO\n         L     R9,SAVER9S\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                             Routine used by USELOAD.  LLWA L\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nE2NEWTAB DS    0H             Construct SP-252 table and re-point LWA.\n         ST    R9,SAVER9T\n         TM    LOADEFLG,X'20'\n         BO    E2NEWTEN\n         L     R5,E2EPT              Entry point of LOADed table.\n         MVC   8(8,R5),=C' PARMLIB'  Pretend that it came from PARMLIB\n         MVC   LINE,LINE-1           Clear line\n         MVC   LINE(23),=C'LOAD E2 entry point:   '\n         HEX   LINE+25,4,E2EPT\n         APUT  LINE,80               Put to terminal\n         L     R5,E2EPT\n         MVC   WORKLIT,LITE2         Show which table we're doing\n         BAL   R9,MEASUR08           Measure length of table\n         MVC   E2END,ME08END\n         MVC   E2LENG,ME08LENG\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Measured table length: '\n         HEX   LINE+25,2,ME08LENG\n         MVC   LINE+32(14),=C'End address:  '\n         HEX   LINE+48,4,ME08END\n         APUT  LINE,60\n         TM    LONGFLG,X'02'         Data conversion only?\n         BO    E2LNMODE              Skip new table creation.\n         MVC   GTSLENG,E2LENG\n         MODESET KEY=ZERO\n         BAL   R9,GETSTORG         Get SP-252 storage for this table\n         MVC   E2ADDR,GTSADDR\n         MVC   E2LENGB,GTSLENG     GTSLENG is now bigger. Store size.\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'SP-252 E2 address:     '\n         HEX   LINE+25,4,E2ADDR\n         APUT  LINE,60\n         L     R0,GTSADDR\n         LH    R1,E2LENG\n         L     R4,E2EPT\n         LH    R5,E2LENG\n         MVCL  R0,R4          Copy the entire table into SP-252, Key 0\n         L     R2,GTSADDR\n         LH    R3,E2LENG\n         AR    R2,R3\n         MVC   0(240,R2),EIGHTPAD\n         L     R2,GTSADDR\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Beginning of E2 table: '\n         APUT  LINE,60\n         MVC   LINE,LINE-1\n         MVC   LINE(80),0(R2)\n         APUT  LINE,80\n         MVC   LINE,LINE-1\n         APUT  LINE,40\n         L     R2,LWAADDR          Get LWA address\n         USING LWA,R2\n         MVC   LWATE2,GTSADDR      Load new table address\n         MVC   LWATE2LN,E2LENGB    Load new table length\n         OI    LWAVFLGS,LWATE2LD   Show new table is loaded\n*        NI    LWAPRMLB,X'FF'-LWATE2ST   Did not come from STEPLIB\n         OI    LWAPRMLB,LWATE2ST\n         DROP  R2\nE2LNMODE DS    0H\n         DELETE EP=KKJEFTE2\n         MODESET KEY=NZERO\nE2NEWTEN DS    0H\n         L     R9,SAVER9T\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                             Routine used by USELOAD.  LLWA L\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nE8NEWTAB DS    0H             Construct SP-252 table and re-point LWA.\n         ST    R9,SAVER9T\n         TM    LOADEFLG,X'10'\n         BO    E8NEWTEN\n         L     R5,E8EPT              Entry point of LOADed table.\n         MVC   8(8,R5),=C' PARMLIB'  Pretend that it came from PARMLIB\n         MVC   LINE,LINE-1           Clear line\n         MVC   LINE(23),=C'LOAD E8 entry point:   '\n         HEX   LINE+25,4,E8EPT\n         APUT  LINE,80               Put to terminal\n         L     R5,E8EPT\n         MVC   WORKLIT,LITE8         Show which table we're doing\n         BAL   R9,MEASUR08           Measure length of table\n         MVC   E8END,ME08END\n         MVC   E8LENG,ME08LENG\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Measured table length: '\n         HEX   LINE+25,2,ME08LENG\n         MVC   LINE+32(14),=C'End address:  '\n         HEX   LINE+48,4,ME08END\n         APUT  LINE,60\n         TM    LONGFLG,X'02'         Data conversion only?\n         BO    E8LNMODE              Skip new table creation.\n         MVC   GTSLENG,E8LENG\n         MODESET KEY=ZERO\n         BAL   R9,GETSTORG         Get SP-252 storage for this table\n         MVC   E8ADDR,GTSADDR\n         MVC   E8LENGB,GTSLENG     GTSLENG is now bigger. Store size.\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'SP-252 E8 address:     '\n         HEX   LINE+25,4,E8ADDR\n         APUT  LINE,60\n         L     R0,GTSADDR\n         LH    R1,E8LENG\n         L     R4,E8EPT\n         LH    R5,E8LENG\n         MVCL  R0,R4          Copy the entire table into SP-252, Key 0\n         L     R2,GTSADDR\n         LH    R3,E8LENG\n         AR    R2,R3\n         MVC   0(240,R2),EIGHTPAD\n         L     R2,GTSADDR\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Beginning of E8 table: '\n         APUT  LINE,60\n         MVC   LINE,LINE-1\n         MVC   LINE(80),0(R2)\n         APUT  LINE,80\n         MVC   LINE,LINE-1\n         APUT  LINE,40\n         L     R2,LWAADDR          Get LWA address\n         USING LWA,R2\n         MVC   LWATE8,GTSADDR      Load new table address\n         MVC   LWATE8LN,E8LENGB    Load new table length\n         OI    LWAVFLGS,LWATE8LD   Show new table is loaded\n*        NI    LWAPRMLB,X'FF'-LWATE8ST   Did not come from STEPLIB\n         OI    LWAPRMLB,LWATE8ST\n         DROP  R2\nE8LNMODE DS    0H\n         DELETE EP=KKJEFTE8\n         MODESET KEY=NZERO\nE8NEWTEN DS    0H\n         L     R9,SAVER9T\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                             Routine used by USELOAD.  LLWA L\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nAPNEWTAB DS    0H             Construct SP-252 table and re-point LWA.\n         ST    R9,SAVER9T\n         TM    LOADEFLG,X'80'\n         BO    APNEWTEN\n         L     R5,APEPT              Entry point of LOADed table.\n         MVC   8(8,R5),=C' PARMLIB'  Pretend that it came from PARMLIB\n         MVC   LINE,LINE-1           Clear line\n         MVC   LINE(23),=C'LOAD AP entry point:   '\n         HEX   LINE+25,4,APEPT\n         APUT  LINE,80               Put to terminal\n         L     R5,APEPT\n         MVC   WORKLIT,LITAP         Show which table we're doing\n         BAL   R9,MEASUR08           Measure length of table\n         MVC   APEND,ME08END\n         MVC   APLENG,ME08LENG\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Measured table length: '\n         HEX   LINE+25,2,ME08LENG\n         MVC   LINE+32(14),=C'End address:  '\n         HEX   LINE+48,4,ME08END\n         APUT  LINE,60\n         TM    LONGFLG,X'02'         Data conversion only?\n         BO    APLNMODE              Skip new table creation.\n         MVC   GTSLENG,APLENG\n         MODESET KEY=ZERO\n         BAL   R9,GETSTORG         Get SP-252 storage for this table\n         MVC   APADDR,GTSADDR\n         MVC   APLENGB,GTSLENG     GTSLENG is now bigger. Store size.\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'SP-252 AP address:     '\n         HEX   LINE+25,4,APADDR\n         APUT  LINE,60\n         L     R0,GTSADDR\n         LH    R1,APLENG\n         L     R4,APEPT\n         LH    R5,APLENG\n         MVCL  R0,R4          Copy the entire table into SP-252, Key 0\n         L     R2,GTSADDR\n         LH    R3,APLENG\n         AR    R2,R3\n         MVC   0(240,R2),EIGHTPAD\n         L     R2,GTSADDR\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Beginning of AP table: '\n         APUT  LINE,60\n         MVC   LINE,LINE-1\n         MVC   LINE(80),0(R2)\n         APUT  LINE,80\n         MVC   LINE,LINE-1\n         APUT  LINE,40\n         L     R2,LWAADDR          Get LWA address\n         USING LWA,R2\n         MVC   LWATAP,GTSADDR      Load new table address\n         MVC   LWATAPLN,APLENGB    Load new table length\n         OI    LWAVFLGS,LWATAPLD   Show new table is loaded\n*        NI    LWAPRMLB,X'FF'-LWATAPST   Did not come from STEPLIB\n         OI    LWAPRMLB,LWATAPST\n         DROP  R2\nAPLNMODE DS    0H\n         DELETE EP=KKJEFTAP\n         MODESET KEY=NZERO\nAPNEWTEN DS    0H\n         L     R9,SAVER9T\n         BR    R9\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                             Routine used by USELOAD.  LLWA L\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nNSNEWTAB DS    0H             Construct SP-252 table and re-point LWA.\n         ST    R9,SAVER9T\n         TM    LOADEFLG,X'40'\n         BO    EOJ4\n         L     R5,NSEPT              Entry point of LOADed table.\n         MVC   8(8,R5),=C' PARMLIB'  Pretend that it came from PARMLIB\n         MVC   LINE,LINE-1           Clear line\n         MVC   LINE(23),=C'LOAD NS entry point:   '\n         HEX   LINE+25,4,NSEPT\n         APUT  LINE,80               Put to terminal\n         L     R5,NSEPT\n         MVC   WORKLIT,LITNS         Show which table we're doing\n         BAL   R9,MEASUR10           Measure length of table\n         MVC   NSEND,ME10END\n         MVC   NSLENG,ME10LENG\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Measured table length: '\n         HEX   LINE+25,2,ME10LENG\n         MVC   LINE+32(14),=C'End address:  '\n         HEX   LINE+48,4,ME10END\n         APUT  LINE,60\n         TM    LONGFLG,X'02'         Data conversion only?\n         BO    NSLNMODE              Skip new table creation.\n         MVC   GTSLENG,NSLENG\n         MODESET KEY=ZERO\n         BAL   R9,GETSTORM         Get SP-252 storage for this table\n         MVC   NSADDR,GTSADDR\n         MVC   NSLENGB,GTSLENG     GTSLENG is now bigger. Store size.\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'SP-252 NS address:     '\n         HEX   LINE+25,4,NSADDR\n         APUT  LINE,60\n         L     R0,GTSADDR\n         LH    R1,NSLENG\n         L     R4,NSEPT\n         LH    R5,NSLENG\n         MVCL  R0,R4          Copy the entire table into SP-252, Key 0\n         L     R2,GTSADDR\n         LH    R3,NSLENG\n         AR    R2,R3\n         MVC   0(104,R2),TENPAD\n         L     R2,GTSADDR\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Beginning of NS table: '\n         APUT  LINE,60\n         MVC   LINE,LINE-1\n         MVC   LINE(80),0(R2)\n         APUT  LINE,80\n         MVC   LINE,LINE-1\n         APUT  LINE,40\n         L     R2,LWAADDR          Get LWA address\n         USING LWA,R2\n         MVC   LWATNS,GTSADDR      Load new table address\n         MVC   LWATNSLN,NSLENGB    Load new table length\n         OI    LWAVFLGS,LWATNSLD   Show new table is loaded\n*        NI    LWAPRMLB,X'FF'-LWATNSST   Did not come from STEPLIB\n         OI    LWAPRMLB,LWATNSST\n         DROP  R2\nNSLNMODE DS    0H\n         DELETE EP=KKJEFTNS\n         MODESET KEY=NZERO\nNSNEWTEN DS    0H\n         L     R9,SAVER9T\n         BR    R9\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                             Routine used by USEDSET.  LLWA D\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nWICHSTRT DS    0H                  Figure out which table to build.\n         ST    R9,SAVER9U\n         CLC   =C'---E2---',TESTTABL\n         BE    FLAGDE2\n         CLC   =C'---E8---',TESTTABL\n         BE    FLAGDE8\n         CLC   =C'---AP---',TESTTABL\n         BE    FLAGDAP\n         CLC   =C'---NS---',TESTTABL\n         BE    FLAGDNS\n         NI    DTABFLG,X'FF'-X'01'\n         B     WICHSEND\nFLAGDE2  DS    0H\n         OI    DTABFLG,X'21'\n         NI    DTABFLG,X'21'\n         B     WICHSEND\nFLAGDE8  DS    0H\n         OI    DTABFLG,X'11'\n         NI    DTABFLG,X'11'\n         B     WICHSEND\nFLAGDAP  DS    0H\n         OI    DTABFLG,X'81'\n         NI    DTABFLG,X'81'\n         B     WICHSEND\nFLAGDNS  DS    0H\n         OI    DTABFLG,X'41'\n         NI    DTABFLG,X'41'\n         B     WICHSEND\nWICHSEND DS    0H\n         L     R9,SAVER9U\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*    Routine used by USEDSET and USEPLIB.  LLWA D and LLWA P\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*    Get work buffers above the 16M line, to construct tables.\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETDBUFS DS    0H\n         ST    R9,SAVER9V\n* -\n         L     R3,=F'8000'         Get a big enough buffer\n         ST    R3,SVE2BUFL         Save Buffer Length\n         GETMAIN RU,LV=(R3),LOC=ANY\n         ST    R1,SVE2ADDR         Save Buffer Address\n         ST    R1,ENE2ADDR         Initialize end address\n* -\n         L     R3,=F'5000'         Get a big enough buffer\n         ST    R3,SVE8BUFL         Save Buffer Length\n         GETMAIN RU,LV=(R3),LOC=ANY\n         ST    R1,SVE8ADDR         Save Buffer Address\n         ST    R1,ENE8ADDR         Initialize end address\n* -\n         L     R3,=F'5000'         Get a big enough buffer\n         ST    R3,SVAPBUFL         Save Buffer Length\n         GETMAIN RU,LV=(R3),LOC=ANY\n         ST    R1,SVAPADDR         Save Buffer Address\n         ST    R1,ENAPADDR         Initialize end address\n* -\n         L     R3,=F'1000'         Get a big enough buffer\n         ST    R3,SVNSBUFL         Save Buffer Length\n         GETMAIN RU,LV=(R3),LOC=ANY\n         ST    R1,SVNSADDR         Save Buffer Address\n         ST    R1,ENNSADDR         Initialize end address\n* -\n         L     R9,SAVER9V\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*    Routine used by USEDSET and USEPLIB.  LLWA D and LLWA P\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*    Free the work buffers created by GETDBUFS routine.\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nFREDBUFS DS    0H\n         ST    R9,SAVER9W\n         STM   R15,R1,SAVE1401     Now save registers\n         ICM   R1,15,SVE2ADDR      A(Buffer)\n         BZ    NOE2BUFF            B. If Not Available\n         ICM   R0,15,SVE2BUFL      L(Buffer)\n         BZ    NOE2BUFF            B. If Not Available\n         FREEMAIN RU,A=(1),LV=(0)\nNOE2BUFF DS    0H\n         ICM   R1,15,SVE8ADDR      A(Buffer)\n         BZ    NOE8BUFF            B. If Not Available\n         ICM   R0,15,SVE8BUFL      L(Buffer)\n         BZ    NOE8BUFF            B. If Not Available\n         FREEMAIN RU,A=(1),LV=(0)\nNOE8BUFF DS    0H\n         ICM   R1,15,SVAPADDR      A(Buffer)\n         BZ    NOAPBUFF            B. If Not Available\n         ICM   R0,15,SVAPBUFL      L(Buffer)\n         BZ    NOAPBUFF            B. If Not Available\n         FREEMAIN RU,A=(1),LV=(0)\nNOAPBUFF DS    0H\n         ICM   R1,15,SVNSADDR      A(Buffer)\n         BZ    NONSBUFF            B. If Not Available\n         ICM   R0,15,SVNSBUFL      L(Buffer)\n         BZ    NONSBUFF            B. If Not Available\n         FREEMAIN RU,A=(1),LV=(0)\nNONSBUFF DS    0H\n         LM    R15,R1,SAVE1401     Now restore registers\nFREDBEND DS    0H\n         L     R9,SAVER9W\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                             Routine used by USEDSET.  LLWA D\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETDMEAS DS    0H                 Measure the four tables.\n         ST    R9,SAVER9X\nGETDSTRT DS    0H\n         GET   LLWALST            Get a record\n         LR    R5,R1              Save address of buffer\n         MVC   TESTTABL(8),0(R5)  Look at the record\n         BAL   R9,WICHSTRT        Is it a header?\n         TM    DTABFLG,X'F0'      Haven't gotten there yet.\n         BZ    GETDSTRT           Look again.\n         TM    DTABFLG,X'01'      Is it the header entry.\n         BO    GETDSTRT           Yes. Skip over it.\n         CLC   TESTTABL(8),=C'        '   Blank entry?\n         BE    GETDSTRT                   Yes. Ignore it.\n         TM    DTABFLG,X'20'      Are we in the E2 table?\n         BO    STDTBLE2           Copy the entries there.\n         TM    DTABFLG,X'10'      Are we in the E8 table?\n         BO    STDTBLE8           Copy the entries there.\n         TM    DTABFLG,X'80'      Are we in the AP table?\n         BO    STDTBLAP           Copy the entries there.\n         TM    DTABFLG,X'40'      Are we in the NS table?\n         BO    STDTBLNS           Construct the entries there.\n         B     GETDSTRT\n*\nSTDTBLE2 DS    0H\n         L     R3,SVE2ADDR        GETMAINed E2 address\n         MVC   0(16,R3),LOADHDR   Start building table\n         MVC   6(2,R3),=C'E2'     Show it's the E2 table\n         LA    R3,16(,R3)         Bump past table header\nSTDLUPE2 DS    0H\n         MVC   0(8,R3),TESTTABL\n         LA    R3,8(,R3)\n         L     R8,E2SIZE\n         A     R8,=F'8'\n         ST    R8,E2SIZE\n         TM    DTABFLG,X'20'\n         BZ    STDLUEE2\n         GET   LLWALST            Get a record\n         LR    R5,R1              Save address of buffer\n         MVC   TESTTABL(8),0(R5)  Look at the record\n         BAL   R9,WICHSTRT        Is it a header?\n         CLC   TESTTABL(8),=C'        '   Blank entry?\n         BE    GETDSTRT                   Yes. End of table.\n         CLC   TESTTABL(3),=C'---'\n         BE    GETDSTRT\n         B     STDLUPE2\nSTDLUEE2 DS    0H\n         B     GETDSTRT\n*\nSTDTBLE8 DS    0H\n         L     R3,SVE8ADDR        GETMAINed E8 address\n         MVC   0(16,R3),LOADHDR   Start building table\n         MVC   6(2,R3),=C'E8'     Show it's the E8 table\n         LA    R3,16(,R3)         Bump past table header\nSTDLUPE8 DS    0H\n         MVC   0(8,R3),TESTTABL\n         LA    R3,8(,R3)\n         L     R8,E8SIZE\n         A     R8,=F'8'\n         ST    R8,E8SIZE\n         TM    DTABFLG,X'10'\n         BZ    STDLUEE8\n         GET   LLWALST            Get a record\n         LR    R5,R1              Save address of buffer\n         MVC   TESTTABL(8),0(R5)  Look at the record\n         BAL   R9,WICHSTRT        Is it a header?\n         CLC   TESTTABL(8),=C'        '   Blank entry?\n         BE    GETDSTRT                   Yes. End of table.\n         CLC   TESTTABL(3),=C'---'\n         BE    GETDSTRT\n         B     STDLUPE8\nSTDLUEE8 DS    0H\n         B     GETDSTRT\n*\nSTDTBLAP DS    0H\n         L     R3,SVAPADDR        GETMAINed AP address\n         MVC   0(16,R3),LOADHDR   Start building table\n         MVC   6(2,R3),=C'AP'     Show it's the AP table\n         LA    R3,16(,R3)         Bump past table header\nSTDLUPAP DS    0H\n         MVC   0(8,R3),TESTTABL\n         LA    R3,8(,R3)\n         L     R8,APSIZE\n         A     R8,=F'8'\n         ST    R8,APSIZE\n         TM    DTABFLG,X'80'\n         BZ    STDLUEAP\n         GET   LLWALST            Get a record\n         LR    R5,R1              Save address of buffer\n         MVC   TESTTABL(8),0(R5)  Look at the record\n         BAL   R9,WICHSTRT        Is it a header?\n         CLC   TESTTABL(8),=C'        '   Blank entry?\n         BE    GETDSTRT                   Yes. End of table.\n         CLC   TESTTABL(3),=C'---'\n         BE    GETDSTRT\n         B     STDLUPAP\nSTDLUEAP DS    0H\n         B     GETDSTRT\n*\nSTDTBLNS DS    0H\n         L     R3,SVNSADDR        GETMAINed NS address\n         MVC   0(16,R3),LOADHDR   Start building table\n         MVC   6(2,R3),=C'NS'     Show it's the NS table\n         LA    R3,16(,R3)         Bump past table header\nSTDLUPNS DS    0H\n         BAL   R9,NAMESIZE        Get length of command name\n         MVC   0(2,R3),TESTSIZE   Dump it into the table\n         LA    R3,2(,R3)          Bump address by 2 bytes\n         MVC   0(8,R3),TESTTABL   Move program name in\n         LA    R3,8(,R3)          Bump address by 10 bytes\n         L     R8,NSSIZE          Previous loaded table size\n         A     R8,=F'10'          Bump by size of new entry\n         ST    R8,NSSIZE          Store new table size\n         TM    DTABFLG,X'40'      Are we in the correct table?\n         BZ    STDLUENS           No. Reevaluate.\n         GET   LLWALST            Get a record\n         LR    R5,R1              Save address of buffer\n         MVC   TESTTABL(8),0(R5)  Look at the record\n         BAL   R9,WICHSTRT        Is it a header?\n         CLC   TESTTABL(8),=C'        '   Blank entry?\n         BE    GETDSTRT                   Yes. End of table.\n         CLC   TESTTABL(3),=C'---'\n         BE    GETDSTRT\n         B     STDLUPNS           In same table, just keep reading.\nSTDLUENS DS    0H\n         B     GETDSTRT           Reevaluate.\n*\nGETLOOPE DS    0H                 Finished measuring all tables here.\n*                                 Convert sizes to halfwords.\n         L     R4,E2SIZE\n         STH   R4,E2DLNTH\n*\n         L     R4,E8SIZE\n         STH   R4,E8DLNTH\n*\n         L     R4,APSIZE\n         STH   R4,APDLNTH\n*\n         L     R4,NSSIZE\n         STH   R4,NSDLNTH\n*\n* - > Display table sizes obtained - below\n         STM   R15,R1,SAVE1401     Now save registers\n         MVC   LINE,LINE-1\n         MVC   LINE(9),=C'E2 Size: '\n         HEX   LINE+11,2,E2DLNTH\n         MVC   LINE+20(9),=C'E8 Size: '\n         HEX   LINE+31,2,E8DLNTH\n         MVC   LINE+40(9),=C'AP Size: '\n         HEX   LINE+51,2,APDLNTH\n         MVC   LINE+60(9),=C'NS Size: '\n         HEX   LINE+71,2,NSDLNTH\n         APUT  LINE,80\n         LM    R15,R1,SAVE1401     Now reload registers\n* - > Display table sizes obtained - above\n*\n         L     R9,SAVER9X\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*    Routine used by USEDSET and USEPLIB.  LLWA D and LLWA P\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*    Generate length of program names.\n*        Input  is TESTTABL - 8 byte character field\n*        Output is TESTSIZE - binary halfword number\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nNAMESIZE DS    0H\n         ST    R9,SAVER9Y\n         ST    R2,SAVER2A\n         LA    R4,TESTTABL\n         XR    R1,R1\n         LA    R2,8\nNAMELOOP DS    0H\n         CLI   0(R4),X'40'\n         BE    NAMELEND\n         LA    R1,1(,R1)\n         LA    R4,1(,R4)\n         BCT   R2,NAMELOOP\nNAMELEND DS    0H\n         STH   R1,TESTSIZE\n         L     R2,SAVER2A\n         L     R9,SAVER9Y\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                             Routine used by USEPLIB.  LLWA P\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETPREAD DS    0H                 Read thru the PARMLIB member image\n         ST    R9,SAVER9D         Save BAL register\nGETPSTRT DS    0H\n         XC    PARMLBIN,PARMLBIN     Initialize line number counter\n         MVC   GETPWORK,GETPWORK-1   Blank out card image area\n         LA    R1,GETPWORK\n         ST    R1,GETPADDR\n         LA    R1,71(,R1)\n         ST    R1,GETPEADR\nGETPLOOP DS    0H\n         GET   LLWAPRM            Get a record\n         LR    R5,R1              Save address of buffer\n         MVC   GETPWORK(80),0(R5) Move record to work area\n         OC    GETPWORK(80),BLANKS  Uppercase everything in the record\n         L     R1,PARMLBIN        Increment\n         A     R1,=F'1'              Line Number\n         ST    R1,PARMLBIN              Counter\n         NI    KEYWFLG,X'FF'-X'01'   Turn off GET new card flag.\n         NI    CONTFLG,X'FF'-X'04'   Turn off \"new continuation\" flag\n* --- >  test display of card  -  below\n         TM    LONGFLG,X'01'      Is the \"extra outputs\" flag on?\n         BZ    GETPCEND           No. Then don't display PARMLIB image.\n         ST    R2,SAVER2B         Save work register.\n         L     R2,PARMLBIN                Load binary number\n         CVD   R2,CVDAREA                 Convert to decimal\n         MVC   PARMLDEC,CVDAREA           Store away for reporting\n         L     R2,SAVER2B         Restore work register.\n         MVC   LINE,LINE-1           Display\n         MVC   LINE(10),MASK10         card\n         ED    LINE(10),PARMLDEC+3       number\n         MVC   LINE(5),=C'Card-'           and\n         MVC   LINE+11(80),GETPWORK          card image.\n         APUT  LINE,91\nGETPCEND DS    0H\n* --- >  test display of card  -  above\n*\n         BAL   R9,GETPSCAN     Scan the PARMLIB card to get pgm names.\n         B     GETPLOOP        And get another card until End of Data.\n*\nGETPMEND DS    0H                 EODAD address of LLWAPRM DD name.\n*-->                              Move the tables to SP-252 - below\n         L     R4,E2SIZEP         Load fullword size\n         STH   R4,E2PLNTH         Make halfword size\n*\n         L     R4,E8SIZEP         Load fullword size\n         STH   R4,E8PLNTH         Make halfword size\n*\n         L     R4,APSIZEP         Load fullword size\n         STH   R4,APPLNTH         Make halfword size\n*\n         L     R4,NSSIZEP         Load fullword size\n         STH   R4,NSPLNTH         Make halfword size\n*\nDPE2     DS    0H\n         TM    WICHFLG,X'20'       E2 table on?\n         BZ    DPE8\n         BAL   R9,E2PNWTAB         Construct E2 table and point to it\nDPE8     DS    0H\n         TM    WICHFLG,X'10'       E8 table on?\n         BZ    DPAP\n         BAL   R9,E8PNWTAB         Construct E8 table and point to it\nDPAP     DS    0H\n         TM    WICHFLG,X'80'       AP table on?\n         BZ    DPNS\n         BAL   R9,APPNWTAB         Construct AP table and point to it\nDPNS     DS    0H\n         TM    WICHFLG,X'40'       NS table on?\n         BZ    DPEND\n         BAL   R9,NSPNWTAB         Construct NS table and point to it\nDPEND    DS    0H\n*\n*-->                              Move the tables to SP-252 - above\n         L     R9,SAVER9D         Restore BAL register\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                             Routine used by USEPLIB.  LLWA P\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETPSCAN DS    0H                 Scan current PARMLIB record image\n         ST    R9,SAVER9Z         Save BAL register\nGETPSCST DS    0H\n         L     R3,GETPADDR        Point to current card image\n         ST    R3,SAVER3A\nGETPSCLU DS    0H                 Scan card for significant strings.\n*                                  and turn on flags accordingly.\n         L     R3,SAVER3A\n* --- >                           Diagnostics. Produces much output.\n         C     R3,GETPEADR        End of the record yet?\n         BH    GETPSCEN           Yes. Finished with this card.\n         CLC   0(2,R3),=C'*/'     End of comment?\n         BE    GETPNCOM           Yes. Turn off flag.\n         CLC   0(2,R3),=C'/*'     Start of comment?\n         BE    GETPSCOM           Yes. Turn on flag.\n         TM    COMMFLG,X'01'      Are we within a comment?\n         BO    GETPSBMP           Yes, just bump to next character.\n         CLI   0(R3),X'40'        Blank character?\n         BE    GETPSBMP           Yes. Bump past it.\n         CLI   0(R3),C'+'         Continuation?\n         BE    GETPPLUS           Yes. Go no farther.\n         CLI   0(R3),C'-'         Continuation?\n         BE    GETPMNUS           Yes. Go no farther.\n*\n         CLC   =C'AUTHCMD',0(R3)      Handle AUTHCMD\n         BE    GETPSCE2\n         CLC   =C'AUTHPGM',0(R3)      Handle AUTHPGM\n         BE    GETPSCE8\n         CLC   =C'AUTHTSF',0(R3)      Handle AUTHTSF\n         BE    GETPSCAP\n         CLC   =C'NOTBKGND',0(R3)     Handle NOTBKGND\n         BE    GETPSCNS\n*\n         CLC   =C'NAMES',0(R3)    Handle NAMES\n         BE    GETPNAMS           Flag that keyword was seen\n*\n         CLI   0(R3),C'('         Open parenthesis?\n         BE    GETPOPAR           Flag that it was seen\n         CLI   0(R3),C')'         Close parenthesis?\n         BE    GETPCPAR           Flag that it was seen\n*\n         BAL   R9,GETPRNAM        What's in the rest of the card?\n         B     GETPSCEN\nGETPSBMP DS    0H                 Bump position and keep scanning.\n         L     R3,SAVER3A\n         LA    R3,1(,R3)          Bump one character in the card\n         ST    R3,SAVER3A         Save position of scan\n         B     GETPSCLU           Keep scanning card image\nGETPSCOM DS    0H                 Entering a comment area\n         OI    COMMFLG,X'01'      Flag that we're in comment area\n         LA    R3,1(,R3)          Bump a bit past comment symbol\n         ST    R3,SAVER3A         Save position of scan\n         B     GETPSCLU           Keep scanning card image\nGETPNCOM DS    0H                 Leaving a comment area\n         NI    COMMFLG,X'FF'-X'01'   Turn off comment area flag\n         LA    R3,1(,R3)          Bump a bit past \"comment off\" symbol\n         ST    R3,SAVER3A         Save position of scan\n         B     GETPSCLU           Keep scanning card image\nGETPPLUS DS    0H\n         LA    R3,1(,R3)          Bump past plus\n         ST    R3,SAVER3A         Save position of scan\n         OI    CONTFLG,X'01'      Plus continuation to next card\n         NI    CONTFLG,X'01'      Turn off minus continuation flag\n         OI    CONTFLG,X'04'      Fresh continuation in this line.\n         B     GETPSCEN             End scan of card image\nGETPMNUS DS    0H\n         LA    R3,1(,R3)          Bump past minus\n         ST    R3,SAVER3A         Save position of scan\n         OI    CONTFLG,X'02'      Minus continuation to next card\n         NI    CONTFLG,X'02'      Turn off plus continuation flag\n         OI    CONTFLG,X'04'      Fresh continuation in this line.\n         B     GETPSCEN             End scan of card image\nGETPSCE2 DS    0H\n         LA    R3,7(,R3)          Bump past \"AUTHCMD\"\n         ST    R3,SAVER3A         Save position of scan\n         OI    KEYWFLG,X'20'      Show we're in the E2 table\n         NI    KEYWFLG,X'2F'        And not in any other table\n         NI    CONTFLG,X'FF'-X'03'  Turn off all continuations.\n         TM    POUTFLG,X'01'        Is LLWAPOUT OPEN?\n         BZ    NOLLWAP2             No, don't PUT to it.\n         PUT   LLWAPOUT,LITE2       Yes put out header literal.\nNOLLWAP2 DS    0H\n*---->                            Build E2 table header initially\n         L     R3,SVE2ADDR        GETMAINed E2 address\n         MVC   0(16,R3),LOADHDR   Start building table\n         MVC   6(2,R3),=C'E2'     Show it's the E2 table\n         LA    R3,16(,R3)         Bump past table header\n         ST    R3,SVE2HOLD        Save place in E2 table\n         LA    R8,16              Size of table header\n         ST    R8,E2SIZEP         Add to size of table\n*---->\n         B     GETPSCLU           Keep scanning card image\nGETPSCE8 DS    0H\n         LA    R3,7(,R3)          Bump past \"AUTHPGM\"\n         ST    R3,SAVER3A         Save position of scan\n         OI    KEYWFLG,X'10'      Show we're in the E8 table\n         NI    KEYWFLG,X'1F'        And not in any other table\n         NI    CONTFLG,X'FF'-X'03'  Turn off all continuations.\n         TM    POUTFLG,X'01'        Is LLWAPOUT OPEN?\n         BZ    NOLLWAP3             No, don't PUT to it.\n         PUT   LLWAPOUT,LITE8       Yes put out header literal.\nNOLLWAP3 DS    0H\n*---->                            Build E8 table header initially\n         L     R3,SVE8ADDR        GETMAINed E8 address\n         MVC   0(16,R3),LOADHDR   Start building table\n         MVC   6(2,R3),=C'E8'     Show it's the E8 table\n         LA    R3,16(,R3)         Bump past table header\n         ST    R3,SVE8HOLD        Save place in E8 table\n         LA    R8,16              Size of table header\n         ST    R8,E8SIZEP         Add to size of table\n*---->\n         B     GETPSCLU           Keep scanning card image\nGETPSCAP DS    0H\n         LA    R3,7(,R3)          Bump past \"AUTHTSF\"\n         ST    R3,SAVER3A         Save position of scan\n         OI    KEYWFLG,X'80'      Show we're in the AP table\n         NI    KEYWFLG,X'8F'        And not in any other table\n         NI    CONTFLG,X'FF'-X'03'  Turn off all continuations.\n         TM    POUTFLG,X'01'        Is LLWAPOUT OPEN?\n         BZ    NOLLWAP4             No, don't PUT to it.\n         PUT   LLWAPOUT,LITAP       Yes put out header literal.\nNOLLWAP4 DS    0H\n*---->                            Build AP table header initially\n         L     R3,SVAPADDR        GETMAINed AP address\n         MVC   0(16,R3),LOADHDR   Start building table\n         MVC   6(2,R3),=C'AP'     Show it's the AP table\n         LA    R3,16(,R3)         Bump past table header\n         ST    R3,SVAPHOLD        Save place in AP table\n         LA    R8,16              Size of table header\n         ST    R8,APSIZEP         Add to size of table\n*---->\n         B     GETPSCLU           Keep scanning card image\nGETPSCNS DS    0H\n         LA    R3,8(,R3)          Bump past \"NOTBKGND\"\n         ST    R3,SAVER3A         Save position of scan\n         OI    KEYWFLG,X'40'      Show we're in the NS table\n         NI    KEYWFLG,X'4F'        And not in any other table\n         NI    CONTFLG,X'FF'-X'03'  Turn off all continuations.\n         TM    POUTFLG,X'01'        Is LLWAPOUT OPEN?\n         BZ    NOLLWAP5             No, don't PUT to it.\n         PUT   LLWAPOUT,LITNS       Yes put out header literal.\nNOLLWAP5 DS    0H\n*---->                            Build NS table header initially\n         L     R3,SVNSADDR        GETMAINed NS address\n         MVC   0(16,R3),LOADHDR   Start building table\n         MVC   6(2,R3),=C'NS'     Show it's the NS table\n         LA    R3,16(,R3)         Bump past table header\n         ST    R3,SVNSHOLD        Save place in NS table\n         LA    R8,16              Size of table header\n         ST    R8,NSSIZEP         Add to size of table\n*---->\n         B     GETPSCLU           Keep scanning card image\nGETPOPAR DS    0H\n         LA    R3,1(,R3)          Bump past open paren\n         ST    R3,SAVER3A         Save position of scan\n         OI    KEYWFLG,X'04'      Show open paren seen\n         NI    KEYWFLG,X'FF'-X'02'  Show no close paren seen\n         B     GETPSCLU           Keep scanning card image\nGETPCPAR DS    0H\n         LA    R3,1(,R3)\n         ST    R3,SAVER3A         Save position of scan\n         OI    KEYWFLG,X'02'        Show Close Parenthesis seen\n         NI    KEYWFLG,X'0F'        And show we're not in any table\n         NI    KEYWFLG,X'FF'-X'0C'  And turn off open paren and names\n         NI    CONTFLG,X'FF'-X'03'  Turn off all continuations.\n         B     GETPSCEN             End scan of card image\nGETPNAMS DS    0H\n         LA    R3,5(,R3)          Bump past \"NAMES\" keyword\n         ST    R3,SAVER3A         Save position of scan\n         OI    KEYWFLG,X'08'      Flag that \"NAMES\" was seen\n         NI    CONTFLG,X'FF'-X'03'\n         B     GETPSCLU           Keep scanning card image\nGETPSCEN DS    0H                 End of card scan\n* --- >\n         L     R3,GETPADDR        Load beginning address for next card\n         ST    R3,SAVER3A         And store it for safekeeping\n         L     R9,SAVER9Z         Restore BAL register\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                             Routine used by USEPLIB.  LLWA P\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETPRNAM DS    0H\n         ST    R9,SAVER9B\nGETPRSTT DS    0H\n         L     R3,SAVER3A\n         C     R3,GETPEADR        End of the record?\n         BH    GETPREND           Past it. Get out.\nGETPRELP DS    0H\n         TM    KEYWFLG,X'F0'      Are we in the middle of a table?\n         BZ    GETPREND           No. Don't search.\n         TM    KEYWFLG,X'0C'      Have we seen both NAMES and ( ?\n         BO    GETPRSRH           Yes. Keep looking in this card.\n         B     GETPREND           No. Don't search further.\nGETPRSRH DS    0H\n         TM    COMMFLG,X'01'      Are we pointing to a comment?\n         BO    GETPREND           Yes. Get out of card search.\n* --- >       Search for program names  -  below\n         BAL   R9,EXNAMES         Extract names from this card.\n         B     GETPREND\n* --- >       Search for program names  -  above\nGETPRBMP DS    0H\n         LA    R3,1(,R3)          Bump card byte location\n         ST    R3,SAVER3A         Store new address away\n         C     R3,GETPEADR        At the end of the card yet?\n         BH    GETPREND           Past it. Get out.\n         CLI   0(R3),X'40'        Is this byte a blank?\n         BE    GETPRSTT           Yes cycle back and keep trying.\n         B     GETPRELP           Not a blank. Try to extract name.\nGETPREND DS    0H\n* - >\n*->  Test for \"no continuation\" error - below\n         TM    KEYWFLG,X'0C'      Names and Open paren present?\n         BNO   GETPRGUD           Not true-don't test for continuation\n         TM    KEYWFLG,X'F0'      Not inside any table?\n         BZ    GETPRGUD           Yes. Don't need continuation.\n         TM    CONTFLG,X'04'      Is there a fresh continuation?\n         BO    GETPRGUD           Yes, we're OK.\n         L     R3,SAVER3A         Get position of R3 after card scan\n         C     R3,GETPEADR        Is it at the end of the card?\n         BL    GETPRGUD           No. No continuation problem.\n         B     ERRNAME1           No. Put out error message and stop.\nGETPRGUD DS    0H\n         ST    R3,SAVER3A\n*->  Test for \"no continuation\" error - above\n         L     R3,GETPADDR        Load beginning address for next card\n         ST    R3,SAVER3A         And store it for safekeeping.\n         L     R9,SAVER9B\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                             Routine used by USEPLIB.  LLWA P\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nEXNAMES  DS    0H\n         ST    R9,SAVER9G\n         ST    R2,SAVER2C         Save previous reg contents\nEXNARRUN DS    0H\n         TM    KEYWFLG,X'F0'      Are we in the middle of a table?\n         BZ    EXNAMEND           No. Don't search.\nEXNAMSTR DS    0H\n         L     R3,SAVER3A         Load current position in card image\n         ST    R4,SAVER4A         Save previous contents of R4\nEXNAMLUP DS    0H                 Loop to remove blanks\n         C     R3,GETPEADR        End of the record?\n         BH    EXNAMEND           Get out of scan routine\n         CLI   0(R3),X'40'        Blank character?\n         BNE   EXNAMXTR           Try next one.\n         LA    R3,1(,R3)\n         ST    R3,SAVER3A\n         B     EXNAMLUP\n* --                              Non-blank here\nEXNAMXTR DS    0H\n         BAL   R9,EXPLSMNS        Test for +, -, or close paren\n         TM    KEYWFLG,X'01'\n         BO    EXNAMEND\n         LA    R2,GETPNAME        Point to target for name\n         MVC   GETPNAME(8),BLANKS   Initialize to blanks.\n         L     R4,=F'8'           This actually detects a size of 9.\nEXNAMXLP DS    0H                 Loop to handle non-blanks\n         ST    R4,SAVER4B         Save BCT register quantity\n* -- >\n         C     R3,GETPEADR        End of the record?\n         BH    EXNAMEND           Yes, stop scanning\n         BAL   R9,EXPLSMNS        Test for +, -, or close paren\n         TM    KEYWFLG,X'01'      Get another card on next pass?\n         BO    EXNAMEND           Yes. Stop scanning, flags are set.\n         TM    COMMFLG,X'01'\n         BO    EXCPYNAM\n         CLC   =C'*/',0(R3)\n         BO    EXCPYNAM\n*        TM    KEYWFLG,X'F0'      Out of current table?\n*        BO    EXNAMEND           Yes. Stop scanning.\n         MVC   0(1,R2),0(R3)      Move current non-blank character\n         LA    R2,1(,R2)          Bump target position\n         LA    R3,1(,R3)          Bump source position\n         ST    R3,SAVER3A         Store source position\n         CLI   0(R3),X'40'        Found blank after non-blanks?\n         BE    EXCPYNAM           Then copy the non-blanks found.\n*--->\n         CLI   0(R3),C'+'         Test for plus\n         BE    EXCPYNAM\n         CLI   0(R3),C'-'         Test for minus\n         BE    EXCPYNAM\n         CLI   0(R3),C')'         Test for close paren\n         BE    EXCPYNAM\n         CLC   =C'/*',0(R3)       Test for comment\n         BE    EXCPYNAM\n         CLC   =C'*/',0(R3)       Test for end of comment\n         BE    EXCPYNAM\n*--->\n         BCT   R4,EXNAMXLP        BCT loop. If falls thru, then error\nEXCPYNAM DS    0H\n         ST    R4,SAVER4B\n* - >                             Did we fall thru the BCT?\n         LTR   R4,R4              Should be more than 0.\n         BNZ   EXNAMGUD           Not zero. Not 9 chars long.\n*  Have at least 9 characters in a row here.\n*--->\n         CLI   0(R3),C'+'         Test for plus\n         BE    EXHANDLE\n         CLI   0(R3),C'-'         Test for minus\n         BE    EXHANDLE\n         CLI   0(R3),C')'         Test for close paren\n         BE    EXHANDLE\n         CLC   =C'/*',0(R3)       Test for start of comment\n         BE    EXHANDLE\n         CLC   =C'*/',0(R3)       Test for end of comment\n         BE    EXHANDLE\n*--->\n         B     EXGOON01           None of these--can't be a good name.\nEXHANDLE DS    0H\n         BAL   R9,HANDLNAM        Copy this name and try for next.\nEXGOON01 DS    0H\n         BAL   R9,EXPLSMNS        Continuation card found or )\n         TM    KEYWFLG,X'01'      Get a new card next time.\n         BO    EXNAMEND           Yes. Stop scanning, flags are set.\n         TM    COMMFLG,X'01'      Are we in a comment?\n         BO    EXNONAM1           Yes. Don't put out names.\n         B     ERRNAME1           Name is too long. Flag error.\nEXNAMGUD DS    0H\n* --                              Insert alphanum check\n         BAL   R9,EXPLSMNS     TEST TEST TEST TEST TEST TEST\n         CLI   0(R3),C'*'      TEST TEST TEST TEST TEST TEST\n         BE    EXNONAM0        TEST TEST TEST TEST TEST TEST\n         TM    COMMFLG,X'01'      Are we within a comment?\n         BO    EXNONAM1           Yes. Don't put out any found names.\nEXNONAM0 DS    0H\n         BAL   R9,HANDLNAM        Copy this name and try for next.\nEXNONAM1 DS    0H\n         LA    R3,1(,R3)          Bump to next place.\n         ST    R3,SAVER3A         Store the new location.\n         C     R3,GETPEADR        End of the record?\n         BH    EXNAMEND           Yes. Get out.\n         B     EXNAMLUP           No. Keep scanning for more names.\nEXNAMEND DS    0H                 EXIT THIS ROUTINE.\n         L     R2,SAVER2C\n*        L     R4,SAVER4A\n         L     R9,SAVER9G\n         BR    R9\nEXNAMBMP DS    0H\n         LA    R3,1(,R3)          Bump up one place.\n         ST    R3,SAVER3A         And save the location.\n         B     EXNAMXLP           Go loop back and try some more.\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                             Routine used by USEPLIB.  LLWA P\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nEXPLSMNS DS    0H              Test for plus, minus, close parenthesis\n         ST    R9,SAVER9J\n         L     R3,SAVER3A\nEXPLSMSS DS    0H              Start tests\n         CLI   0(R3),C')'         Close paren?\n         BE    EXNAMCLP           End everything and finish card.\n         CLI   0(R3),C'+'         + continuation?\n         BE    EXNAMPLS           Yes. Process + and finish card.\n         CLI   0(R3),C'-'         - continuation?\n         BE    EXNAMMNS           Yes. Process - and finish card.\n         CLC   0(2,R3),=C'*/'     End of comment?\n         BE    EXNPNCOM           Yes. Turn off flag.\n         CLC   0(2,R3),=C'/*'     Start of comment?\n         BE    EXNPSCOM           Yes. Turn on flag.\n         B     EXPLSMFN           End routine and do nothing.\nEXNAMPLS DS    0H\n         OI    CONTFLG,X'01'      Turn on plus indicator\n         NI    CONTFLG,X'01'      Turn off minus indicator\n         OI    CONTFLG,X'04'      Fresh continuation in this line.\n         B     EXFINISH           Finish with this card.\nEXNAMMNS DS    0H\n         OI    CONTFLG,X'02'      Turn on minus indicator\n         NI    CONTFLG,X'02'      Turn off plus indicator\n         OI    CONTFLG,X'04'      Fresh continuation in this line.\n         B     EXFINISH           Finish dealing with this card.\nEXNAMCLP DS    0H\n         NI    KEYWFLG,X'0F'        Say we're not in any table\n         NI    KEYWFLG,X'FF'-X'0C'  Say NAMES and Open Paren not found\n         OI    KEYWFLG,X'02'        Say Close Paren found\n         B     EXFINISH             Stop scanning this card\nEXNPSCOM DS    0H                 Entering a comment area\n         OI    COMMFLG,X'01'      Flag that we're in comment area\n         LA    R3,1(,R3)          Bump past comment symbol\n         ST    R3,SAVER3A         Save position of scan\n         B     EXPLSMFN           Keep scanning card image\nEXNPNCOM DS    0H                 Leaving a comment area\n         LA    R3,1(,R3)             Bump past \"comment off\" symbol\n         ST    R3,SAVER3A         Save position of scan\n         NI    COMMFLG,X'FF'-X'01'   Turn off comment area flag\n         B     EXPLSMFN           Keep scanning card image\nEXFINISH DS    0H                 See if name preceded ending char\n         L     R4,SAVER4B         Load previous BCT register\n         OI    KEYWFLG,X'01'      Signal to get another card\nEXPLSMFN DS    0H                 End tests\n*        L     R4,SAVER4A\n         L     R9,SAVER9J\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                             Routine used by USEPLIB.  LLWA P\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHANDLNAM DS    0H                 When PARMLIB input yields a valid\n*                                  name, it is outputted here.\n         ST    R9,SAVER9K\n         CLC   GETPNAME(8),=C'        '  Don't consider blank name\n         BE    HANDLNEN                    It is an error.\n         CLI   GETPNAME,C'*'             Don't consider if * in col 1.\n         BE    HANDLNEN                    It is an error.\n         CLI   GETPNAME,C'/'             Don't consider if / in col 1.\n         BE    HANDLNEN                    It is an error.\nHANDLNDO DS    0H\n         TM    LONGFLG,X'01'      Extra diagnostic outputs?\n         BZ    HANDLNOO           Flag off. No extras.\n         MVC   LINE,LINE-1\n         MVC   LINE(8),GETPNAME   Show name that's being put out.\n         APUT  LINE,15\nHANDLNOO DS    0H\n         TM    POUTFLG,X'01'      Is LLWAPOUT OPEN?\n         BZ    NOLLWAP6           No. Don't try and PUT to it.\n         PUT   LLWAPOUT,GETPNAME  LRECL=8 output.\nNOLLWAP6 DS    0H\n         BAL   R9,GETPMEAS       Make output LWA table entry in storage\nHANDLNEN DS    0H\n         L     R9,SAVER9K\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                             Routine used by USEPLIB.  LLWA P\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETPMEAS DS    0H                 Output the name found here, to the\n*                                  appropriate table to be built.\n         ST    R9,SAVER9L\n         ST    R3,SAVER3C\nGETPSTRL DS    0H\n         TM    KEYWFLG,X'2C'      Are we in the E2 table?\n         BO    STPLUPE2           Copy the entries there.\n         TM    KEYWFLG,X'1C'      Are we in the E8 table?\n         BO    STPLUPE8           Copy the entries there.\n         TM    KEYWFLG,X'8C'      Are we in the AP table?\n         BO    STPLUPAP           Copy the entries there.\n         TM    KEYWFLG,X'4C'      Are we in the NS table?\n         BO    STPLUPNS           Construct the entries there.\n         B     GETPMENN           Not in a table--get out.\n*\nSTPLUPE2 DS    0H\n         L     R3,SVE2HOLD        Get current position in table\n         MVC   0(8,R3),GETPNAME   Move pgm name into table\n         LA    R3,8(,R3)          Bump past current position\n         ST    R3,SVE2HOLD        Store new position\n         L     R8,E2SIZEP         Get previous table size\n         A     R8,=F'8'           Add this entry's increment\n         ST    R8,E2SIZEP         Store new table size\nSTPLUEE2 DS    0H\n         B     GETPMENN           Finished with name--get out.\n*\nSTPLUPE8 DS    0H\n         L     R3,SVE8HOLD        Get current position in table\n         MVC   0(8,R3),GETPNAME   Move pgm name into table\n         LA    R3,8(,R3)          Bump past current position\n         ST    R3,SVE8HOLD        Store new position\n         L     R8,E8SIZEP         Get previous table size\n         A     R8,=F'8'           Add this entry's increment\n         ST    R8,E8SIZEP         Store new table size\nSTPLUEE8 DS    0H\n         B     GETPMENN           Finished with name--get out.\n*\nSTPLUPAP DS    0H\n         L     R3,SVAPHOLD        Get current position in table\n         MVC   0(8,R3),GETPNAME   Move pgm name into table\n         LA    R3,8(,R3)          Bump past current position\n         ST    R3,SVAPHOLD        Store new position\n         L     R8,APSIZEP         Get previous table size\n         A     R8,=F'8'           Add this entry's increment\n         ST    R8,APSIZEP         Store new table size\nSTPLUEAP DS    0H\n         B     GETPMENN           Finished with name--get out.\n*\nSTPLUPNS DS    0H\n         MVC   TESTTABL,GETPNAME  Move pgm name to NAMESIZE work area\n         BAL   R9,NAMESIZE        Get length of command name\n         L     R3,SVNSHOLD        Get current position in table\n         MVC   0(2,R3),TESTSIZE   Dump it into the table\n         LA    R3,2(,R3)          Bump address by 2 bytes\n         MVC   0(8,R3),GETPNAME   Move program name into table\n         LA    R3,8(,R3)          Bump address by 8 more bytes\n         ST    R3,SVNSHOLD        Repoint current position in table\n         L     R8,NSSIZEP         Previous loaded table size\n         A     R8,=F'10'          Bump by size of new entry\n         ST    R8,NSSIZEP         Store new table size\nSTPLUENS DS    0H\n         B     GETPMENN           Finished handling this name\nGETPMENN DS    0H\n         L     R9,SAVER9L\n         L     R3,SAVER3C\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                             Routine used by USEPLIB.  LLWA P\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nE2PNWTAB DS    0H                    Build new E2 table in SP-252.\n         ST    R9,KEEPR9A\n         L     R5,SVE2ADDR           Entry point of constructed table.\n         LH    R4,E2PLNTH            Load measured table length\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Measured table length: '\n         HEX   LINE+25,2,E2PLNTH\n         APUT  LINE,60\n         TM    LONGFLG,X'02'         Data conversion only?\n         BO    E2PNMODE              Skip new table creation.\n         MVC   GTSLENG,E2PLNTH\n         BAL   R9,GETSTORG         Get SP-252 storage for this table\n         MVC   E2ADDR,GTSADDR\n         MVC   E2LENGB,GTSLENG     GTSLENG is now bigger. Store size.\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'SP-252 E2 address:     '\n         HEX   LINE+25,4,E2ADDR\n         APUT  LINE,60\n         L     R0,GTSADDR\n         LH    R1,E2PLNTH\n         L     R4,SVE2ADDR\n         LH    R5,E2PLNTH\n         MVCL  R0,R4          Copy the entire table into SP-252, Key 0\n         L     R2,GTSADDR\n         LH    R3,E2PLNTH\n         AR    R2,R3\n         MVC   0(240,R2),EIGHTPAD\n         L     R2,GTSADDR\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Beginning of E2 table: '\n         APUT  LINE,60\n         MVC   LINE,LINE-1\n         MVC   LINE(80),0(R2)\n         APUT  LINE,80\n         MVC   LINE,LINE-1\n         APUT  LINE,40\n         L     R2,LWAADDR          Get LWA address\n         USING LWA,R2\n         MVC   LWATE2,GTSADDR      Load new table address\n         MVC   LWATE2LN,E2LENGB    Load new table length\n         OI    LWAVFLGS,LWATE2LD   Show new table is loaded\n*        NI    LWAPRMLB,X'FF'-LWATE2ST   Say it came from PARMLIB\n         OI    LWAPRMLB,LWATE2ST\n         DROP  R2\nE2PNMODE DS    0H\n         MODESET KEY=NZERO\nE2PNWTEN DS    0H\n         L     R9,KEEPR9A\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                             Routine used by USEPLIB.  LLWA P\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nE8PNWTAB DS    0H                    Build new E8 table in SP-252.\n         ST    R9,KEEPR9B\n         L     R5,SVE8ADDR           Entry point of constructed table.\n         LH    R4,E8PLNTH            Load measured table length\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Measured table length: '\n         HEX   LINE+25,2,E8PLNTH\n         APUT  LINE,60\n         TM    LONGFLG,X'02'         Data conversion only?\n         BO    E8PNMODE              Skip new table creation.\n         MVC   GTSLENG,E8PLNTH\n         BAL   R9,GETSTORG         Get SP-252 storage for this table\n         MVC   E8ADDR,GTSADDR\n         MVC   E8LENGB,GTSLENG     GTSLENG is now bigger. Store size.\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'SP-252 E8 address:     '\n         HEX   LINE+25,4,E8ADDR\n         APUT  LINE,60\n         L     R0,GTSADDR\n         LH    R1,E8PLNTH\n         L     R4,SVE8ADDR\n         LH    R5,E8PLNTH\n         MVCL  R0,R4          Copy the entire table into SP-252, Key 0\n         L     R2,GTSADDR\n         LH    R3,E8PLNTH\n         AR    R2,R3\n         MVC   0(240,R2),EIGHTPAD\n         L     R2,GTSADDR\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Beginning of E8 table: '\n         APUT  LINE,60\n         MVC   LINE,LINE-1\n         MVC   LINE(80),0(R2)\n         APUT  LINE,80\n         MVC   LINE,LINE-1\n         APUT  LINE,40\n         L     R2,LWAADDR          Get LWA address\n         USING LWA,R2\n         MVC   LWATE8,GTSADDR      Load new table address\n         MVC   LWATE8LN,E8LENGB    Load new table length\n         OI    LWAVFLGS,LWATE8LD   Show new table is loaded\n*        NI    LWAPRMLB,X'FF'-LWATE8ST   Say it came from PARMLIB\n         OI    LWAPRMLB,LWATE8ST\n         DROP  R2\nE8PNMODE DS    0H\n         MODESET KEY=NZERO\nE8PNWTEN DS    0H\n         L     R9,KEEPR9B\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                             Routine used by USEPLIB.  LLWA P\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nAPPNWTAB DS    0H                    Build new AP table in SP-252.\n         ST    R9,KEEPR9C\n         L     R5,SVAPADDR           Entry point of constructed table.\n         LH    R4,APPLNTH            Load measured table length\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Measured table length: '\n         HEX   LINE+25,2,APPLNTH\n         APUT  LINE,60\n         TM    LONGFLG,X'02'         Data conversion only?\n         BO    APPNMODE              Skip new table creation.\n         MVC   GTSLENG,APPLNTH\n         BAL   R9,GETSTORG         Get SP-252 storage for this table\n         MVC   APADDR,GTSADDR\n         MVC   APLENGB,GTSLENG     GTSLENG is now bigger. Store size.\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'SP-252 AP address:     '\n         HEX   LINE+25,4,APADDR\n         APUT  LINE,60\n         L     R0,GTSADDR\n         LH    R1,APPLNTH\n         L     R4,SVAPADDR\n         LH    R5,APPLNTH\n         MVCL  R0,R4          Copy the entire table into SP-252, Key 0\n         L     R2,GTSADDR\n         LH    R3,APPLNTH\n         AR    R2,R3\n         MVC   0(240,R2),EIGHTPAD\n         L     R2,GTSADDR\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Beginning of AP table: '\n         APUT  LINE,60\n         MVC   LINE,LINE-1\n         MVC   LINE(80),0(R2)\n         APUT  LINE,80\n         MVC   LINE,LINE-1\n         APUT  LINE,40\n         L     R2,LWAADDR          Get LWA address\n         USING LWA,R2\n         MVC   LWATAP,GTSADDR      Load new table address\n         MVC   LWATAPLN,APLENGB    Load new table length\n         OI    LWAVFLGS,LWATAPLD   Show new table is loaded\n*        NI    LWAPRMLB,X'FF'-LWATAPST   Say it came from PARMLIB\n         OI    LWAPRMLB,LWATAPST\n         DROP  R2\nAPPNMODE DS    0H\n         MODESET KEY=NZERO\nAPPNWTEN DS    0H\n         L     R9,KEEPR9C\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                             Routine used by USEPLIB.  LLWA P\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nNSPNWTAB DS    0H                    Build new NS table in SP-252.\n         ST    R9,KEEPR9D\n         L     R5,SVNSADDR           Entry point of constructed table.\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Measured table length: '\n         HEX   LINE+25,2,NSPLNTH\n         APUT  LINE,60\n         TM    LONGFLG,X'02'         Data conversion only?\n         BO    NSPNMODE              Skip new table creation.\n         MVC   GTSLENG,NSPLNTH\n*        MODESET KEY=ZERO\n         BAL   R9,GETSTORM         Get SP-252 storage for this table\n         MVC   NSADDR,GTSADDR\n         MVC   NSLENGB,GTSLENG     GTSLENG is now bigger. Store size.\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'SP-252 NS address:     '\n         HEX   LINE+25,4,NSADDR\n         APUT  LINE,60\n         MODESET KEY=ZERO\n         L     R0,GTSADDR\n         LH    R1,NSPLNTH\n         L     R4,SVNSADDR\n         LH    R5,NSPLNTH\n         MVCL  R0,R4          Copy the entire table into SP-252, Key 0\n         L     R2,GTSADDR\n         LH    R3,NSPLNTH\n         AR    R2,R3\n         MVC   0(104,R2),TENPAD\n         L     R2,GTSADDR\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Beginning of NS table: '\n         APUT  LINE,60\n         MVC   LINE,LINE-1\n         MVC   LINE(80),0(R2)\n         APUT  LINE,80\n         MVC   LINE,LINE-1\n         APUT  LINE,40\n         L     R2,LWAADDR          Get LWA address\n         USING LWA,R2\n         MVC   LWATNS,GTSADDR      Load new table address\n         MVC   LWATNSLN,NSLENGB    Load new table length\n         OI    LWAVFLGS,LWATNSLD   Show new table is loaded\n*        NI    LWAPRMLB,X'FF'-LWATNSST   Say it came from PARMLIB\n         OI    LWAPRMLB,LWATNSST\n         DROP  R2\nNSPNMODE DS    0H\n         MODESET KEY=NZERO\nNSPNWTEN DS    0H\n         L     R9,KEEPR9D\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                             Routine used by USEDSET.  LLWA D\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nE2DNWTAB DS    0H\n         ST    R9,SAVER9C\n         L     R5,SVE2ADDR           Entry point of constructed table.\n         LH    R4,E2DLNTH            Load measured table length\n         LA    R4,16(,R4)            Add size of header\n         STH   R4,E2DLNTH            Store new size\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Measured table length: '\n         HEX   LINE+25,2,E2DLNTH\n         APUT  LINE,60\n         MVC   GTSLENG,E2DLNTH\n*        MODESET KEY=ZERO\n         BAL   R9,GETSTORG         Get SP-252 storage for this table\n         MVC   E2ADDR,GTSADDR\n         MVC   E2LENGB,GTSLENG     GTSLENG is now bigger. Store size.\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'SP-252 E2 address:     '\n         HEX   LINE+25,4,E2ADDR\n         APUT  LINE,60\n         MODESET KEY=ZERO\n         L     R0,GTSADDR\n         LH    R1,E2DLNTH\n         L     R4,SVE2ADDR\n         LH    R5,E2DLNTH\n         MVCL  R0,R4          Copy the entire table into SP-252, Key 0\n         L     R2,GTSADDR\n         LH    R3,E2DLNTH\n         AR    R2,R3\n         MVC   0(240,R2),EIGHTPAD\n         L     R2,GTSADDR\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Beginning of E2 table: '\n         APUT  LINE,60\n         MVC   LINE,LINE-1\n         MVC   LINE(80),0(R2)\n         APUT  LINE,80\n         MVC   LINE,LINE-1\n         APUT  LINE,40\n         L     R2,LWAADDR          Get LWA address\n         USING LWA,R2\n         MVC   LWATE2,GTSADDR      Load new table address\n         MVC   LWATE2LN,E2LENGB    Load new table length\n         OI    LWAVFLGS,LWATE2LD   Show new table is loaded\n*        NI    LWAPRMLB,X'FF'-LWATE2ST   Say it came from PARMLIB\n         OI    LWAPRMLB,LWATE2ST\n         DROP  R2\n         MODESET KEY=NZERO\nE2DNWTEN DS    0H\n         L     R9,SAVER9C\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                             Routine used by USEDSET.  LLWA D\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nE8DNWTAB DS    0H\n         ST    R9,SAVER9C\n         L     R5,SVE8ADDR           Entry point of constructed table.\n         LH    R4,E8DLNTH            Load measured table length\n         LA    R4,16(,R4)            Add size of header\n         STH   R4,E8DLNTH            Store new size\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Measured table length: '\n         HEX   LINE+25,2,E8DLNTH\n         APUT  LINE,60\n         MVC   GTSLENG,E8DLNTH\n         BAL   R9,GETSTORG         Get SP-252 storage for this table\n         MVC   E8ADDR,GTSADDR\n         MVC   E8LENGB,GTSLENG     GTSLENG is now bigger. Store size.\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'SP-252 E8 address:     '\n         HEX   LINE+25,4,E8ADDR\n         APUT  LINE,60\n         MODESET KEY=ZERO\n         L     R0,GTSADDR\n         LH    R1,E8DLNTH\n         L     R4,SVE8ADDR\n         LH    R5,E8DLNTH\n         MVCL  R0,R4          Copy the entire table into SP-252, Key 0\n         L     R2,GTSADDR\n         LH    R3,E8DLNTH\n         AR    R2,R3\n         MVC   0(240,R2),EIGHTPAD\n         L     R2,GTSADDR\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Beginning of E8 table: '\n         APUT  LINE,60\n         MVC   LINE,LINE-1\n         MVC   LINE(80),0(R2)\n         APUT  LINE,80\n         MVC   LINE,LINE-1\n         APUT  LINE,40\n         L     R2,LWAADDR          Get LWA address\n         USING LWA,R2\n         MVC   LWATE8,GTSADDR      Load new table address\n         MVC   LWATE8LN,E8LENGB    Load new table length\n         OI    LWAVFLGS,LWATE8LD   Show new table is loaded\n*        NI    LWAPRMLB,X'FF'-LWATE8ST   Say it came from PARMLIB\n         OI    LWAPRMLB,LWATE8ST\n         DROP  R2\n         MODESET KEY=NZERO\nE8DNWTEN DS    0H\n         L     R9,SAVER9C\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                             Routine used by USEDSET.  LLWA D\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nAPDNWTAB DS    0H\n         ST    R9,SAVER9C\n         L     R5,SVAPADDR           Entry point of constructed table.\n         LH    R4,APDLNTH            Load measured table length\n         LA    R4,16(,R4)            Add size of header\n         STH   R4,APDLNTH            Store new size\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Measured table length: '\n         HEX   LINE+25,2,APDLNTH\n         APUT  LINE,60\n         MVC   GTSLENG,APDLNTH\n         BAL   R9,GETSTORG         Get SP-252 storage for this table\n         MVC   APADDR,GTSADDR\n         MVC   APLENGB,GTSLENG     GTSLENG is now bigger. Store size.\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'SP-252 AP address:     '\n         HEX   LINE+25,4,APADDR\n         APUT  LINE,60\n         MODESET KEY=ZERO\n         L     R0,GTSADDR\n         LH    R1,APDLNTH\n         L     R4,SVAPADDR\n         LH    R5,APDLNTH\n         MVCL  R0,R4          Copy the entire table into SP-252, Key 0\n         L     R2,GTSADDR\n         LH    R3,APDLNTH\n         AR    R2,R3\n         MVC   0(240,R2),EIGHTPAD\n         L     R2,GTSADDR\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Beginning of AP table: '\n         APUT  LINE,60\n         MVC   LINE,LINE-1\n         MVC   LINE(80),0(R2)\n         APUT  LINE,80\n         MVC   LINE,LINE-1\n         APUT  LINE,40\n         L     R2,LWAADDR          Get LWA address\n         USING LWA,R2\n         MVC   LWATAP,GTSADDR      Load new table address\n         MVC   LWATAPLN,APLENGB    Load new table length\n         OI    LWAVFLGS,LWATAPLD   Show new table is loaded\n*        NI    LWAPRMLB,X'FF'-LWATAPST   Say it came from PARMLIB\n         OI    LWAPRMLB,LWATAPST\n         DROP  R2\n         MODESET KEY=NZERO\nAPDNWTEN DS    0H\n         L     R9,SAVER9C\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                             Routine used by USEDSET.  LLWA D\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nNSDNWTAB DS    0H\n         ST    R9,SAVER9C\n         L     R5,SVNSADDR           Entry point of constructed table.\n         LH    R4,NSDLNTH            Load measured table length\n         LA    R4,16(,R4)            Add size of header\n         STH   R4,NSDLNTH            Store new size\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Measured table length: '\n         HEX   LINE+25,2,NSDLNTH\n         APUT  LINE,60\n         MVC   GTSLENG,NSDLNTH\n         BAL   R9,GETSTORM         Get SP-252 storage for this table\n         MVC   NSADDR,GTSADDR\n         MVC   NSLENGB,GTSLENG     GTSLENG is now bigger. Store size.\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'SP-252 NS address:     '\n         HEX   LINE+25,4,NSADDR\n         APUT  LINE,60\n         MODESET KEY=ZERO\n         L     R0,GTSADDR\n         LH    R1,NSDLNTH\n         L     R4,SVNSADDR\n         LH    R5,NSDLNTH\n         MVCL  R0,R4          Copy the entire table into SP-252, Key 0\n         L     R2,GTSADDR\n         LH    R3,NSDLNTH\n         AR    R2,R3\n         MVC   0(104,R2),TENPAD\n         L     R2,GTSADDR\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Beginning of NS table: '\n         APUT  LINE,60\n         MVC   LINE,LINE-1\n         MVC   LINE(80),0(R2)\n         APUT  LINE,80\n         MVC   LINE,LINE-1\n         APUT  LINE,40\n         L     R2,LWAADDR          Get LWA address\n         USING LWA,R2\n         MVC   LWATNS,GTSADDR      Load new table address\n         MVC   LWATNSLN,NSLENGB    Load new table length\n         OI    LWAVFLGS,LWATNSLD   Show new table is loaded\n*        NI    LWAPRMLB,X'FF'-LWATNSST   Say it came from PARMLIB\n         OI    LWAPRMLB,LWATNSST\n         DROP  R2\n         MODESET KEY=NZERO\nNSDNWTEN DS    0H\n         L     R9,SAVER9C\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*    Print characteristics of the allocated datasets.\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nPRTJFCB  DS    0H                         Print JFCB\n         ST    R9,SAVER9H                 Save the BAL register\n         MVC   LINE,LINE-1\n         MVC   LINE(17),MSGPRTJF\n         MVC   LINE+19(44),JFCBDSNM       DSNAME\n         APUT  LINE,60\n         MVC   LINE,LINE-1\n         MVC   LINE,MSGMBR\n         MVC   LINE+19(8),JFCBELNM        MEMBER NAME\n         APUT  LINE,60\n         MVC   LINE,LINE-1\n         MVC   LINE,MSGVOLSR              VOLSER\n         MVC   LINE+19(6),JFCBVOLS\n         MVC   LINE+26(6),JFCBVOLS+6\n         MVC   LINE+33(6),JFCBVOLS+12\n         MVC   LINE+40(6),JFCBVOLS+18\n         MVC   LINE+47(6),JFCBVOLS+24\n         APUT  LINE,60\n         MVC   LINE,LINE-1\n         MVC   LINE,MSGDSORG              DSORG\n         MVC   LINE+19(3),=C'IS '\n         CLI   JFCDSRG1,JFCORGIS\n         BE    PUTDSRG\n         MVC   LINE+19(3),=C'ISU'\n         CLI   JFCDSRG1,JFCORGIS+JFCORGU\n         BE    PUTDSRG\n         MVC   LINE+19(3),=C'PS '\n         CLI   JFCDSRG1,JFCORGPS\n         BE    PUTDSRG\n         MVC   LINE+19(3),=C'PSU'\n         CLI   JFCDSRG1,JFCORGPS+JFCORGU\n         BE    PUTDSRG\n         MVC   LINE+19(3),=C'DA '\n         CLI   JFCDSRG1,JFCORGDA\n         BE    PUTDSRG\n         MVC   LINE+19(3),=C'DAU'\n         CLI   JFCDSRG1,JFCORGDA+JFCORGU\n         BE    PUTDSRG\n         MVC   LINE+19(3),=C'PO '\n         CLI   JFCDSRG1,JFCORGPO\n         BE    PUTDSRG\n         MVC   LINE+19(3),=C'POU'\n         CLI   JFCDSRG1,JFCORGPO+JFCORGU\n         BE    PUTDSRG\n         OI    FLAG1,X'01'                FLAG DSORG MISSING\n         MVC   LINE+19(15),=C'MISSING OR VSAM'\nPUTDSRG  APUT  LINE,60\nRECFM    DS    0H\n         MVC   LINE,LINE-1\n         MVC   LINE,MSGRECFM              RECFM\n         LA    R4,LINE+19\n         TM    JFCRECFM,JFCUND\n         BNO   NOTUND\n         MVI   0(R4),C'U'\n         OI    FLAG2,X'01'                FLAG RECFM=U\n         A     R4,ONE\n         B     CHKB\nNOTUND   TM    JFCRECFM,JFCFIX\n         BNO   NOTFIX\n         MVI   0(R4),C'F'\n         A     R4,ONE\nNOTFIX   TM    JFCRECFM,JFCVAR\n         BNO   CHKB\n         MVI   0(R4),C'V'\n         A     R4,ONE\nCHKB     TM    JFCRECFM,JFCRFB\n         BNO   NOTBLK\n         MVI   0(R4),C'B'\n         A     R4,ONE\nNOTBLK   TM    JFCRECFM,JFCRFS\n         BNO   NOTSCN\n         MVI   0(R4),C'S'\n         A     R4,ONE\nNOTSCN   TM    JFCRECFM,JFCASA\n         BNO   NOTASA\n         MVI   0(R4),C'A'\n         A     R4,ONE\nNOTASA   TM    JFCRECFM,JFCMAC\n         BNO   PUTRCFM\n         MVI   0(R4),C'M'\nPUTRCFM  APUT  LINE,60\nLRECL    DS    0H\n         MVC   LINE,LINE-1                Clear line.\n         MVC   LINE,MSGLRECL              Put LRECL skeleton into it.\n         SR    R4,R4                      Clear work register\n         LH    R4,JFCLRECL                Load LRECL in from JFCB\n         C     R4,=F'0'                   Is it zero?\n         BNE   LRECPRT                    No. Don't check for RECFM=U.\n         TM    FLAG2,X'01'                Is RECFM=U?\n         BO    LRECPRT                    Yes-0 is legitimate.\n         OI    FLAG1,X'04'\n         MVC   LINE+19(7),=C'MISSING'\n         B     LRECPUT\nLRECPRT  DS    0H\n         CVD   R4,DECVALUE\n         MVC   LINE+19(12),EDPAT          LRECL\n         ED    LINE+19(12),DECVALUE+3\nLRECPUT  APUT  LINE,60\nBLKSIZE  MVC   LINE,LINE-1\n         MVC   LINE,MSGBLKSZ\n         SR    R4,R4\n         LH    R4,JFCBLKSI\n         C     R4,=F'0'\n         BNE   BLKSIZEG                   BLOCK SIZE IS GOOD\n         OI    FLAG1,X'02'                FLAG BLKSIZE MISSING\n         MVC   LINE+19(15),=C'ZERO OR MISSING'\n         B     BLKSZPUT\nBLKSIZEG CVD   R4,DECVALUE\n         MVC   LINE+19(12),EDPAT          BLKSIZE\n         ED    LINE+19(12),DECVALUE+3\nBLKSZPUT APUT  LINE,60\n         L     R9,SAVER9H\n         BR    R9\nDECVALUE DS    CL8\nEDPAT    DC    X'402020206B2020206B202120'\nMSGEXP   DC    CL133'0   EXPORT   DSN ='\nMSGDSN   DC    CL133'0   BDMUSOUT DSN ='\nMSGVOLSR DC    CL133'         VOLSER  ='\nMSGMBR   DC    CL133'         MEMBER  ='\nMSGDSORG DC    CL133'         DSORG   ='\nMSGBLKSZ DC    CL133'         BLKSIZE ='\nMSGLRECL DC    CL133'         LRECL   ='\nMSGRECFM DC    CL133'         RECFM   ='\n         DC    CL133' '\nFLAG1    DC    X'00'\n*              X'01'               DSORG IS MISSING\nFLAG2    DC    X'00'\nONE      DC    F'1'\nMSGPRTJF DC    CL17'-------  DSNAME: '\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nOPENPOUT DS    0H                  Conditionally OPEN LLWAPOUT DD\n         ST    R9,SAVER9E\n         TM    OPENFLG,X'01'       Is the DD name present in TIOT?\n         BZ    OPENMSSG            No. It is missing.\n         TM    POUTFLG,X'01'       Is the DD name already OPEN?\n         BO    OPENPALR            Yes. Bypass the OPEN and RDJFCB.\n         OPEN  (LLWAPOUT,(OUTPUT))\n         TM    LLWAPOUT+48,X'10'   Is the DD OPEN  ?                     01914\n         BZ    OPENFAIL            No. Error message.                    01915\n         OI    POUTFLG,X'01'       Show this DD is truly OPEN\n         RDJFCB LLWAPOUT\n         MVC   MSGPRTJF(8),=C'LLWAPOUT'   Move DD name into message\n         BAL   R9,PRTJFCB          Print dataset information\n         TM    JFCRECFM,X'80'      Is RECFM fixed?\n         BZ    NOTFIXED            No. Send error message.\n         CLC   =H'8',JFCLRECL      Is LRECL = 8 ?\n         BNE   NOLRECL8            No. Send error message.\nOPENPALR DS    0H                  LLWAPOUT DD is already OPWN\n         B     OPENPEND\nOPENFAIL DS    0H\n         B     NOALLOCQ            Error message and exit program.       01915\nOPENMSSG DS    0H\n         BAL   R9,NOALLOCR         Say that LLWAPOUT DD is missing.\nOPENPEND DS    0H\n         L     R9,SAVER9E\n         BR    R9\nPOUTFLG  DS    X                   Flag saying LLWAPOUT is OPEN\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nCLOSPOUT DS    0H\n         ST    R9,SAVER9E\n         TM    POUTFLG,X'01'       Is the LLWAPOUT DD OPEN?\n         BZ    CLOSPEND            No. Don't try to CLOSE it.\n         CLOSE LLWAPOUT\n         NI    POUTFLG,X'FF'-X'01'  Turn off LLWAPOUT OPEN flag.\nCLOSPEND DS    0H\n         L     R9,SAVER9E\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nFREOLDTB DS    0H\n         ST    R9,KEEPR9F\n         STM   R15,R1,SAVX1401     Now save registers\n         MODESET KEY=ZERO\n         LM    R15,R1,SAVX1401     Now restore registers\n         STM   R15,R1,SAVE1401     Now save registers\n         TM    WICHFLG,X'20'       Which table?\n         BZ    FRE2BUFF            Not this one.\n         ICM   R1,15,SAVETE2       A(Old Table)\n         BZ    FRE2BUFF            B. If Not Available\n         LA    R0,0\n         ICM   R0,3,SAVETE2L       L(Old Table)\n         BZ    FRE2BUFF            B. If Not Available\n         FREEMAIN RU,A=(1),LV=(0),SP=252\nFRE2BUFF DS    0H\n         TM    WICHFLG,X'10'       Which table?\n         BZ    FRE8BUFF            Not this one.\n         ICM   R1,15,SAVETE8       A(Old Table)\n         BZ    FRE8BUFF            B. If Not Available\n         LA    R0,0\n         ICM   R0,3,SAVETE8L       L(Old Table)\n         BZ    FRE8BUFF            B. If Not Available\n         FREEMAIN RU,A=(1),LV=(0),SP=252\nFRE8BUFF DS    0H\n         TM    WICHFLG,X'80'       Which table?\n         BZ    FRAPBUFF            Not this one.\n         ICM   R1,15,SAVETAP       A(Old Table)\n         BZ    FRAPBUFF            B. If Not Available\n         LA    R0,0\n         ICM   R0,3,SAVETAPL       L(Old Table)\n         BZ    FRAPBUFF            B. If Not Available\n         FREEMAIN RU,A=(1),LV=(0),SP=252\nFRAPBUFF DS    0H\n         TM    WICHFLG,X'40'       Which table?\n         BZ    FRNSBUFF            Not this one.\n         ICM   R1,15,SAVETNS       A(Old Table)\n         BZ    FRNSBUFF            B. If Not Available\n         LA    R0,0\n         ICM   R0,3,SAVETNSL       L(Old Table)\n         BZ    FRNSBUFF            B. If Not Available\n         FREEMAIN RU,A=(1),LV=(0),SP=252\nFRNSBUFF DS    0H\n         LM    R15,R1,SAVE1401     Now restore registers\n         STM   R15,R1,SAVX1401     Now save registers\n         MODESET KEY=NZERO\n         LM    R15,R1,SAVX1401     Now restore registers\n         L     R9,KEEPR9F\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMEASOL08 DS    0H                 R5 has beginning address of table.\n         ST    R9,KEEPR9G           Save BAL register\n         ST    R4,SAVER4C           Save work register\n         XC    BLNKCNT,BLNKCNT      Zero the counters\n         XC    NTRYCNT,NTRYCNT\n         LA    R4,16                Count size of header\n         LA    R5,16(,R5)           Bump past header\nMO08LOOP DS    0H\n*     Try (real hard) to detect the end of the table  -  below\n         MVC   SAVECHAR(1),0(R5)    Save first character\n         CLC   =C'        ',0(R5)   Is this table entry a blank?\n         BE    MO08BLNK             Yes. Reached virtual end of table\n         CLC   ZEROES8(8),0(R5)     Is this \"entry\" hex zeros?\n         BE    MO08NOBL             Yes. Reached possible junk storage\n         CLC   =C' ',0(R5)          Is first character blank?\n         BE    MO08NOBL             Yes, not a valid table entry.\n         TR    SAVECHAR,TRTPGMNM    Check first char if appropriate.\n         CLI   SAVECHAR,X'02'       Not. probably end of table.\n         BE    MO08NOBL\n         CLC   =C'IKJEFTE2',0(R5)\n         BE    MO08NOBL\n         CLC   =C'IKJEFTE8',0(R5)\n         BE    MO08NOBL\n         CLC   =C'IKJEFTAP',0(R5)\n         BE    MO08NOBL\n         CLC   =C'IKJEFTNS',0(R5)\n         BE    MO08NOBL\n*     Try (real hard) to detect the end of the table  -  above\n         LA    R4,8(,R4)            Count next table entry\n         LA    R5,8(,R5)            Bump to next entry\n         L     R1,NTRYCNT           Increment \"entry count\" counter\n         A     R1,=F'1'\n         ST    R1,NTRYCNT\n         B     MO08LOOP             Loop back till perceived table end\nMO08BLNK DS    0H\n         LA    R4,8(,R4)            Add length of blank entry\n         LA    R5,8(,R5)            Bump past blank entry.\n         L     R1,BLNKCNT           Increment \"blank entry\" counter\n         A     R1,=F'1'\n         ST    R1,BLNKCNT\nMO08NOBL DS    0H\n         STH   R4,MO08LENG          Store measured length of table.\n         ST    R5,MO08END           And record address of table end.\n         BO    MO08NOSH             Don't show count again.\nMO08NOSH DS    0H\n         L     R4,SAVER4C           Restore work register\n         L     R9,KEEPR9G           Restore BAL register\n         BR    R9\nMO08END  DS    F                    Store end-of-table address\nMO08LENG DS    H                    Store table length\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMEASOL10 DS    0H                 R5 has beginning address of table.\n         ST    R9,KEEPR9H           Save BAL register\n         ST    R4,SAVER4D           Save work register\n         XC    BLNKCNT,BLNKCNT      Zero the counters\n         XC    NTRYCNT,NTRYCNT\n         LA    R4,16                Count size of header\n         LA    R5,16(,R5)           Bump past header\nMO10LOOP DS    0H\n         MVC   SAVECHAR(1),2(R5)    Save first character of pgm name\n         MVC   SAVECH08(1),9(R5)    Save last character of pgm name\n         CLC   BLKSTRNG(10),0(R5)   Full blank entry here?\n         BE    MO10BLNK             Yes. Count the blank entry.\n         CLC   ENDSTRNG(10),0(R5)   FFFF plus blank pgm name?\n         BE    MO10BLNK             Yes. Can still be considered blank.\n         CLC   =X'0000',0(R5)       Test-test-test-test-test\n         BE    MO10TEST             Test rest of \"entry\n         B     MO10REST             Not zeros, go on.\nMO10TEST DS    0H\n         TR    SAVECHAR,TRTPGMNM    Check for strange character.\n         CLI   SAVECHAR,X'02'       Is it strange?\n         BE    MO10NOBL             Yes. This is not a blank entry.\nMO10REST DS    0H\n         CLC   =X'FFFF',0(R5)       Test for end string separately.\n         BNE   MO10TES2             Not. Not at virtual end of table\n         B     MO10NOBL             FFFF alone. Not a blank entry.\nMO10TES2 DS    0H\n         TR    SAVECHAR,TRTPGMNM    Check first char not upcase alpha.\n         CLI   SAVECHAR,X'02'       Not. probably end of table.\n         BE    MO10NOBL\n         TR    SAVECH08,TRTPGMNM    Check last char not upcase alpha.\n         CLI   SAVECH08,X'02'       Not. probably end of table.\n         BE    MO10NOBL\n         LA    R4,10(,R4)           Count next table entry\n         LA    R5,10(,R5)           Bump to next entry\n         L     R1,NTRYCNT           Increment \"entry count\" counter\n         A     R1,=F'1'\n         ST    R1,NTRYCNT\n         B     MO10LOOP             Finished this entry, try for more.\nMO10BLNK DS    0H\n         LA    R4,10(,R4)           Add length of blank entry\n         LA    R5,10(,R5)           Bump past blank entry.\n         L     R1,BLNKCNT           Increment \"blank entry\" counter\n         A     R1,=F'1'\n         ST    R1,BLNKCNT\nMO10NOBL DS    0H\n         STH   R4,MO10LENG          Store measured length of table.\n         ST    R5,MO10END           And record address of table end.\n         BO    MO10NOSH             Don't show count again.\nMO10NOSH DS    0H\n         L     R4,SAVER4D           Restore work register\n         L     R9,KEEPR9H           Restore BAL register\n         BR    R9\nMO10END  DS    F                    Store end-of-table address\nMO10LENG DS    H                    Store table length\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n** ---------------------------------------------------------------- **\n**   Here are the rest of the constants for the program.            **\n** ---------------------------------------------------------------- **\nLITE2    DC    C'---E2---'\nLITE8    DC    C'---E8---'\nLITAP    DC    C'---AP---'\nLITNS    DC    C'---NS---'\nWORKLIT  DC    C'        '\nBLKSTRNG DC    XL10'00004040404040404040'\nENDSTRNG DC    XL10'FFFF4040404040404040'\nZEROES8  DC    X'0000000000000000'\nMASK10   DC    XL10'40202020202020202120'\n         DC    C' '\nBLANKS   DC    CL90' '                                       '\nMESSAGET DC    C'LLWA Command - Replace LWA Auth Tables from Various So-\n               urces - xxxxxxxx'\nMESSAGEU DC    C'---- -------   ------- --- ---- ------ ---- ------- --x\n               ----- - --------'\nMESSAG2C DC    C'Command was not invoked APF authorized.'\nMESSAG2D DC    C'Nothing was changed.  '\nMESSAG2F DC    C'You must say which input file: L-loadlib, D-Dataset, P+\n               -Parmlib.'\nMESSAG4A DC    C'You need: ALLOC F(LLWALIB) DA(your.load.library) SH RE+\n               USE '\nMESSAG4B DC    C'Load Library containing tables was not allocated. '\nMESSAG4C DC    C'You need: ALLOC F(LLWALST) DA(your.lrecl8.dataset) SH +\n               REUSE '\nMESSAG4D DC    C'LRECL=8 dataset with program list was not allocated.'\nMESSAG4E DC    C'You need: ALLOC F(LLWAPRM) DA(your.IKJTSOxx.member) SH+\n                REUSE '\nMESSAG4F DC    C'IKJTSOxx-format member was not allocated. '\nMESSAG4G DC    C'You need: ALLOC F(LLWAPOUT) DA(your.LRECL8.file) SH RE+\n               USE '\nMESSAG4H DC    C'No LRECL=8 output produced. Need LLWAPOUT DD name to b+\n               e allocated.'\nMESSAG4I DC    C'No conversion is possible until the LLWAPOUT DD name i+\n               s allocated.'\nMESSAG4J DC    C'This run is for data conversion only. No table loading+\n                will be done.'\nMESSAG4K DC    C'Conversion makes no sense. We already have the LRECL=8+\n                input. Program will end.'\nMESSAG5A DC    C'LRECL of table dataset is not 8. Not allocated.'\nMESSAG5B DC    C'LRECL of table dataset is not 80. Not allocated.'\nMESSAG6A DC    C'RECFM of table dataset is not Fixed. '\nMESSAG6B DC    C'Allocated LLWALIB is not a load module library.'\nMESSAGR0 DC    C'Return Code = 0 '\nMESSAGR4 DC    C'Return Code = 4 '\nMESSAGR8 DC    C'Return Code = 8 '\nMESSAGRC DC    C'Return Code = 12'\n         SPACE 3\n* ----------------------------------------------------------------- *\n*   Literal Pool, thus far.                                         *\n* ----------------------------------------------------------------- *\n         LTORG\n         SPACE 3\nCVDAREA  DS    D                   For CVD instruction\nSAVEAPUT DS    2D\nSAVER1   DS    F                   Save R1 here\nSAVER1A  DS    F                   Save R1 here\nSAVER2A  DS    F                   Save R2 here\nSAVER2B  DS    F                   Save R2 here\nSAVER2C  DS    F                   Save R2 here\nSAVER2D  DS    F                   Save R2 here\nSAVER2E  DS    F                   Save R2 here\nSAVER2F  DS    F                   Save R2 here\nSAVER3A  DS    F                   Save R3 here\nSAVER3B  DS    F                   Save R3 here\nSAVER3C  DS    F                   Save R3 here\nSAVER4A  DS    F                   Save R4 here\nSAVER4B  DS    F                   Save R4 here\nSAVER4C  DS    F                   Save R4 here\nSAVER4D  DS    F                   Save R4 here\nSAVER5A  DS    F                   Save R5 here\nSAVER5B  DS    F                   Save R5 here\nSAVER5C  DS    F                   Save R5 here\nSAVER6   DS    F                   Save R6 here\nSAVER6A  DS    F                   Save R6 here\nSAVER6B  DS    F                   Save R6 here\nSAVER8   DS    F                   Save R8 here\nSAVER8A  DS    F                   Save R8 here\nSAVER8B  DS    F                   Save R8 here\nSAVER9A  DS    F                   BAL Register Save Area\nSAVER9B  DS    F                   BAL Register Save Area\nSAVER9C  DS    F                   BAL Register Save Area\nSAVER9D  DS    F                   BAL Register Save Area\nSAVER9E  DS    F                   BAL Register Save Area\nSAVER9F  DS    F                   BAL Register Save Area\nSAVER9G  DS    F                   BAL Register Save Area\nSAVER9H  DS    F                   BAL Register Save Area\nSAVER9I  DS    F                   BAL Register Save Area\nSAVER9J  DS    F                   BAL Register Save Area\nSAVER9K  DS    F                   BAL Register Save Area\nSAVER9L  DS    F                   BAL Register Save Area\nSAVER9M  DS    F                   BAL Register Save Area\nSAVER9N  DS    F                   BAL Register Save Area\nSAVER9O  DS    F                   BAL Register Save Area\nSAVER9P  DS    F                   BAL Register Save Area\nSAVER9Q  DS    F                   BAL Register Save Area\nSAVER9R  DS    F                   BAL Register Save Area\nSAVER9S  DS    F                   BAL Register Save Area\nSAVER9T  DS    F                   BAL Register Save Area\nSAVER9U  DS    F                   BAL Register Save Area\nSAVER9V  DS    F                   BAL Register Save Area\nSAVER9W  DS    F                   BAL Register Save Area\nSAVER9X  DS    F                   BAL Register Save Area\nSAVER9Y  DS    F                   BAL Register Save Area\nSAVER9Z  DS    F                   BAL Register Save Area\nKEEPR9A  DS    F                   BAL Register Save Area\nKEEPR9B  DS    F                   BAL Register Save Area\nKEEPR9C  DS    F                   BAL Register Save Area\nKEEPR9D  DS    F                   BAL Register Save Area\nKEEPR9E  DS    F                   BAL Register Save Area\nKEEPR9F  DS    F                   BAL Register Save Area\nKEEPR9G  DS    F                   BAL Register Save Area\nKEEPR9H  DS    F                   BAL Register Save Area\n* --- >\nE2DLNTH  DS    H\nE8DLNTH  DS    H\nAPDLNTH  DS    H\nNSDLNTH  DS    H\n* --- >\nE2PLNTH  DS    H\nE8PLNTH  DS    H\nAPPLNTH  DS    H\nNSPLNTH  DS    H\n* --- >\nE2EPT    DS    F\nE8EPT    DS    F\nAPEPT    DS    F\nNSEPT    DS    F\nE2END    DS    F\nE8END    DS    F\nAPEND    DS    F\nNSEND    DS    F\nE2LENG   DS    H\nE8LENG   DS    H\nAPLENG   DS    H\nNSLENG   DS    H\nE2LENGB  DS    H\nE8LENGB  DS    H\nAPLENGB  DS    H\nNSLENGB  DS    H\nGTSLENG  DS    H\nE2ADDR   DS    F\nE8ADDR   DS    F\nAPADDR   DS    F\nNSADDR   DS    F\nGTSADDR  DS    F\nME08END  DS    F\nME08LENG DS    H\nME10END  DS    F\nME10LENG DS    H\nEIGHTPAD DC    240X'40'\nTENPAD   DC    X'0000',CL8' '\n         DC    X'0000',CL8' '\n         DC    X'0000',CL8' '\n         DC    X'0000',CL8' '\n         DC    X'0000',CL8' '\n         DC    X'0000',CL8' '\n         DC    X'0000',CL8' '\n         DC    X'0000',CL8' '\n         DC    X'0000',CL8' '\n         DC    X'0000',CL8' '\n         DC    X'FFFF'\nTENPADL  EQU   *-TENPAD\nOPTSAVE  DC    CL5' '\nLOADHDR  DC    CL16'IKJEFT-- PARMLIB'\nSAVECHAR DS    X\nSAVECH08 DS    X\nLONGFLG  DS    X\n*              X'01'               Extra diagnostics wanted on P option\n*              X'02'               Data conversion only to LRECL=8\nCOMMFLG  DS    X                   Are we within a comment?\nCONTFLG  DS    X                   Did we see continuations?\n*              X'01'               A plus was seen\n*              X'02'               A minus was seen\nKEYWFLG  DS    X                   PARM Scan Keyword flag.\n*              X'08'               NAMES    seen\n*              X'04'               Open     paren seen\n*              X'02'               Close    paren seen\n*              X'01'               Go get a new record\n*              X'80'               AUTHTSF  seen\n*              X'40'               NOTBKGND seen\n*              X'20'               AUTHCMD  seen\n*              X'10'               AUTHPGM  seen\nMODEFLG  DS    X\n*              X'01'    L          Input is from Load Library\n*              X'02'    D          Input is LRECL=8 program list table\n*              X'04'    P          Input is from IKJTSOxx format\nDTABFLG  DS    X                                                   m\n*              X'80'               Working on AP Table\n*              X'40'               Working on NS Table\n*              X'20'               Working on E2 Table\n*              X'10'               Working on E8 Table\nPTABFLG  DS    X                                                   m\n*              X'80'               Working on AP Table\n*              X'40'               Working on NS Table\n*              X'20'               Working on E2 Table\n*              X'10'               Working on E8 Table\nWICHFLG  DS    X                                                   m\n*              X'80'               Only AP Table\n*              X'40'               Only NS Table\n*              X'20'               Only E2 Table\n*              X'10'               Only E8 Table\nLWAPFLG  DS    X                   LWAPRMLB flag copied into program\n*              X'80'               LWATAPST TAP came from STEPLIB\n*              X'40'               LWATNSST TNS came from STEPLIB\n*              X'20'               LWATE2ST TE2 came from STEPLIB\n*              X'10'               LWATE8ST TE8 came from STEPLIB\nLWAMFLG  DS    X                   Which tables have a size in the LWA.\n*              X'80'               AP has a size in the LWA.\n*              X'40'               NS has a size in the LWA.\n*              X'20'               E2 has a size in the LWA.\n*              X'10'               E8 has a size in the LWA.\nWORKFLG  DS    X\nLOADEFLG DS    X\nGETPNAME DC    CL8' '\nPARMLBIN DC    F'0'\nPARMLDEC DC    PL8'0'\n         DS    CL1\n*\n         DS    0F                  NEEDED FOR CORRECT EXLST\nJFCB1    DC    X'87'\n         DC    AL3(INFMJFCB)\n         IEFJFCBN LIST=YES\n*\n         DS    0F                  ALIGN ON FULLWORD\nLLWALIB  DCB   DSORG=PO,MACRF=R,DDNAME=LLWALIB,EXLST=JFCB1\nLLWALST  DCB   DDNAME=LLWALST,MACRF=GL,DSORG=PS,RECFM=FB,              X\n               LRECL=8,EXLST=JFCB1,EODAD=GETLOOPE\nLLWAPRM  DCB   DDNAME=LLWAPRM,MACRF=GL,DSORG=PS,RECFM=FB,EXLST=JFCB1,  X\n               LRECL=80,EODAD=GETPMEND\nLLWAPOUT DCB   DDNAME=LLWAPOUT,MACRF=PM,DSORG=PS,                      X\n               EXLST=JFCB1\n* ------------------------------------------------------------------- *\n*  Note.  The LLWAPOUT DCB cannot have an LRECL associated with it.   *\n*         This is because it is an output dataset, and if the LRECL   *\n*         is not 8, then running our program would change it to be 8. *\n*         This is not good.  Rather, we will not define the LRECL     *\n*         in this DCB, but after it is allocated and OPENed, the      *\n*         RDJFCB will catch the error and abort the program.          *\n* ------------------------------------------------------------------- *\nGETPADDR DS    F                   Address of GETPWORK\nGETPEADR DS    F                   Address of end of card scan\n*\nLINEB    DS    C                   LINE-1\nLINE     DS    CL137               Output line area\nLINET    EQU   LINE+7              Indented line\nGETPINIT DS    C\nGETPWORK DS    CL80\n* --- >\nBLNKCNT  DS    F\nNTRYCNT  DS    F\n* --- >\n         SPACE\nTRTPGMNM DC    X'02020202020202020202020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'40020202020202020202020202020202'\n         DC    X'02020202020202020202025B02020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'02020202020202020202027B7C020202'\n         DC    X'02C1C2C3C4C5C6C7C8C9020202020202'\n         DC    X'02D1D2D3D4D5D6D7D8D9020202020202'\n         DC    X'0202E2E3E4E5E6E7E8E9020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'02C1C2C3C4C5C6C7C8C9020202020202'\n         DC    X'02D1D2D3D4D5D6D7D8D9020202020202'\n         DC    X'0202E2E3E4E5E6E7E8E9020202020202'\n         DC    X'02020202020202020202020202020202'\n         SPACE\n         IKJCPPL\n         IKJPSCB\n         CVT      LIST=YES,DSECT=YES\n         IKJTSVT\n         IKJEFLWA\n         END\n* ------------------------------------------------------------------- *\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUEMNTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   128                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         EJECT\n         IHAPSA   LIST=YES                                     HD APR88\n         EJECT                                                 HD APR88\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   14,12,12(13)       SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES            RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    1,8(13)            OUR SAVE AREA POINTER\n         ST    13,4(1)            POINTER TO CALLERS SAVE AREA\n         LR    13,1               @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(R13)         POINT TO CALLERS RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 ASSUME BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 ASSUME BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(RML)               MESSAGE LENGTH\n         STH   R15,PUTLEN                 PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    2,R13                    @OUR SAVE AREA\n         LR    3,R15                    SAVE RETURN CODE\n         L     R13,4(R13)               @CALLERS SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,3                    RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END   EPUTL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LLWA$": {"ttr": 3082, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x07\\x00'\\x01\\x055O\\x01\\t\\x08\\x8f\\x16)\\x00\\x1e\\x00\\x1d\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@\"", "ispf": {"version": "01.07", "flags": 0, "createdate": "2005-12-20T00:00:00", "modifydate": "2009-03-29T16:29:27", "lines": 30, "newlines": 29, "modlines": 0, "user": "JCL"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n//STEPLIB  DD DISP=SHR,DSN=SBGOLOB.R20.HLASM\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.S19.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.S19.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.CBT478.FILE797\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT478.FILE797(LLWA)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,9),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET,NOREUS,NORENT'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(1)\n SETSSI  CB478797\n ENTRY   LLWA\n NAME    LLWA(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LLWAHELP": {"ttr": 3329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00B\\x01\\x084O\\x01\\x084o\"!\\x00\\xa0\\x00P\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2008-12-09T00:00:00", "modifydate": "2008-12-11T22:21:42", "lines": 160, "newlines": 80, "modlines": 0, "user": "HELP"}, "text": "***********************************************************************\n*                                                                     *\n*   Program Name:   LLWA                                              *\n*                                                                     *\n*  Documentation:   This program is meant to be run as a TSO          *\n*                   command, APF authorized.  This program will       *\n*                   replace the four TSO authorization tables that    *\n*                   are used by your TSO session:  IKJEFTE2,          *\n*                   IKJEFTE8, IKJEFTAP, and IKJEFTNS, and will        *\n*                   re-point the proper addresses in the LWA          *\n*                   (Logon Work Area) to point to the new tables.     *\n*                   The effect of the change is immediate, and        *\n*                   it will only affect the invoker's TSO session.    *\n*                                                                     *\n*    Environment:   TSO command, APF Authorized.                      *\n*                                                                     *\n*                   Linkedit this program with PARM of NORENT         *\n*                     and NOREUS, for best efficiency.                *\n*                                                                     *\n*                   PUTLINE interface enabled by APUT, EPUTL.         *\n*                                                                     *\n*                   This program is non-reentrant.                    *\n*                                                                     *\n*       Function:   To load a completely new set of TSO authorization *\n*                   tables from any load library, so they are honored *\n*                   by your TSO session.  The load library has to be  *\n*                   APF-authorized, and this program has to be APF-   *\n*                   authorized.                                       *\n*                                                                     *\n*                   The tables should be present with CSECT names     *\n*                   KKJEFTE2, etc. instead of IKJEFTE2, etc. because  *\n*                   LOAD should find the correct copy, and not reuse  *\n*                   the TSO userid's copy which is in JPA, and which  *\n*                   is searched first, even using a DCB-directed      *\n*                   LOAD.                                             *\n*                                                                     *\n*         Syntax:   LLWA  ctn                                         *\n*                                                                     *\n*                        c=code: L-from loadlib                       *\n*                                D-from LRECL=8 name list             *\n*                                P-from PARMLIB-like IKJTSOxx member  *\n*                                                                     *\n*                        tn=table name:   E2, E8, NS, AP              *\n*                                                                     *\n*                               (tn can be left out)                  *\n*                                                                     *\n*                   example:  LLWA  LE2  load E2 table from loadlib   *\n*                                                                     *\n*                   example:  LLWA  D    load all tables from dataset *\n*                                                                     *\n*                   default:  reload all tables.                      *\n*                             no default for code.                    *\n*                                                                     *\n*                   If the LLWAPOUT DD name is allocated (to an       *\n*                   LRECL=8 dataset), then LRECL=8 output in          *\n*                   \"program name list\" format will be produced       *\n*                   from the PARMLIB-format member, or from a         *\n*                   loadlib member in the IKJTABLS load module.       *\n*                   In other words, the PARMLIB-format input or       *\n*                   the load module CSECTs will be converted to       *\n*                   LRECL=8 program name list format.                 *\n*                                                                     *\n*     Conversion:   You can use the LLWA command to perform data      *\n*                   conversion from either load module input, or      *\n*                   PARMLIB-format input, into LRECL=8 dataset        *\n*                   input.  Just allocate the input files:            *\n*                                                                     *\n*                      LLWALIB    or   LLWAPRM                        *\n*                                                                     *\n*                   and the output file:                              *\n*                                                                     *\n*                      LLWAPOUT                                       *\n*                                                                     *\n*                   and execute:                                      *\n*                                                                     *\n*                      LLWA L--C  to convert Load Library input       *\n*                                   to LRECL=8 dataset input          *\n*                                                                     *\n*                   or                                                *\n*                      LLWA P--C  to convert PARMLIB-format input     *\n*                                   to LRECL=8 dataset input          *\n*                                                                     *\n*                   If \"conversion only\" is performed, no new Auth    *\n*                   tables will be reloaded.  The auth tables for     *\n*                   your TSO session will stay as they were.          *\n*                                                                     *\n*         Action:   For LLWA L    (loadlib input for the tables)      *\n*                                                                     *\n*                   Single table, or all four tables, are loaded      *\n*                   into core (from the loadlib) and measured.        *\n*                   Measurement stops at the first blank entry.       *\n*                   Then, 240 bytes  (30 blank entries) are           *\n*                   added at the end of the E2, E8, and AP            *\n*                   tables.  104 bytes (10 blank entries              *\n*                   followed by X'FFFF') are added on at the end      *\n*                   of the NS table.  Subpool 252 storage in Key      *\n*                   0 is GETMAINed for each table, and the            *\n*                   LOADed tables are copied into their               *\n*                   designated GETMAIN areas.  Then the LWA           *\n*                   fields are re-pointed to the new tables and       *\n*                   to their sizes, so that the user's session        *\n*                   will honor them immediately.  Simulation of       *\n*                   a load from PARMLIB is done.  But the STEPLIB     *\n*                   flags are turned on, so that a PARMLIB UPDATE(xx) *\n*                   command (issued globally on the MVS instance)     *\n*                   will not overlay the tables that we have          *\n*                   created.                                          *\n*                                                                     *\n*                   For LLWA D    (LRECL=8 program name list input)   *\n*                                                                     *\n*                   For LRECL=8 input, see notes before label         *\n*                   USEDSET.  These will describe the action of       *\n*                   the program for that kind of input.               *\n*                       (described below)                             *\n*                                                                     *\n*                   For LLWA P    (PARMLIB-format (IKJEFTxx) input)   *\n*                                                                     *\n*                   For PARMLIB-format input, see notes before        *\n*                   label USEPLIB.  These will describe the action    *\n*                   of the program for that kind of input.            *\n*                       (described below)                             *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                                                                     *\n*     LLWA D  takes LRECL=8 input consisting of (up to) 4 lists\n*     of program names.  The list belonging to each table is\n*     defined by a header entry, which is \"---E2---\",\n*     \"---E8---\", \"---AP---\", or \"---NS---\".\n*\n*     Output is 4 prebuilt tables in \"above the 16M line\n*     storage\".  Depending on the limiting parms, either all\n*     the 4 tables are replaced in SP-252 core, or only the one\n*     selected is replaced.\n*\n*     Copying of the tables is via an MVCL instruction, the\n*     same way IBM does it at LOGON time, in module IKJEFTP1.\n*                                                                     *\n* ------------------------------------------------------------------ *\n*                                                                     *\n*     LLWA P  takes PARMLIB-format input that looks like an\n*     IKJTSOxx member.  This member is read, and is scanned\n*     for names that are between AUTHCMD NAMES ( ), AUTHPGM\n*     NAMES ( ), AUTHTSF NAMES( ), or NOTBKGND NAMES( ).\n*     Those program names are converted into a list, in the\n*     four separate categories, as they are present in the\n*     IKJTSOxx-like dataset.\n*\n*     Output is 4 prebuilt tables in \"above the 16M line\n*     storage\".  Depending on the limiting parms, either all\n*     the 4 tables are replaced in SP-252 core, or only the\n*     one selected is replaced.\n*\n*     Copying of the tables is via an MVCL instruction, the\n*     same way IBM does it at LOGON time, in module IKJEFTP1.\n*\n*     Optional LRECL=8 output can be generated in LIST format,\n*     if an LLWAPOUT DD name is allocated to an LRECL=8\n*     dataset, optionally.  This output can be edited later,\n*     and used as input to LLWA D.\n*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOADLIB": {"ttr": 3333, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01.\\x00I\\x01 \\x17\\x1f\\x01 \\x17\\x1f\\x18\\x02\\x16\\x9d\\x16\\x9d\\x00\\x00\\xd3\\xd6\\xc1\\xc4\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.46", "flags": 0, "createdate": "2020-06-19T00:00:00", "modifydate": "2020-06-19T18:02:49", "lines": 5789, "newlines": 5789, "modlines": 0, "user": "LOADLIB"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "LWAEDIT1": {"ttr": 5639, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x04\\x01\\x082\\x9f\\x01\\x082\\x9f\\x19X\\x009\\x009\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2008-11-24T00:00:00", "modifydate": "2008-11-24T19:58:04", "lines": 57, "newlines": 57, "modlines": 0, "user": "PANEL"}, "text": ")ATTR\n  % TYPE(TEXT)   INTENS(HIGH) CAPS(OFF) JUST(LEFT)            SKIP(ON)\n  + TYPE(TEXT)   INTENS(LOW)  CAPS(OFF) JUST(LEFT)            SKIP(ON)\n  _ TYPE(NEF)    CAPS(ON) PAD(NULLS)\n  \u00ac TYPE(NEF)    CAPS(ON) PAD('.')\n  $ TYPE(NT)\n  ! TYPE(ET)\n  ~ TYPE(LID)\n  \u00a2 TYPE(TEXT)   INTENS(HIGH) CAPS(OFF) JUST(LEFT)            SKIP(OFF)\n)BODY\n%---------------------------------- LWATMgr ------------------------------------\n+Command ===>_ZCMD                                 +Date:%&ZDATE   +Time:%&ZTIME\n+                                                                              +\n      *------------------------------------------------------------------*\n      *                                                                  *\n      *               TSO Authorized Command Table Manager               *\n      *                                                                  *\n      *                                                                  *\n      *------------------------------------------------------------------*\n+                                                                              +\n+                                                                              +\n$Enter!\"/\"$to select table or!\"EXIT\"$/!\"CANCEL\"$to terminate.                  +\n+                                                                              +\n+  \u00acZ~AUTHTSF+  -  Authorized when called through the TSO Service Facility.    +\n+  \u00acZ~AUTHCMD+  -  Authorized Commands.                                        +\n+  \u00acZ~AUTHPGM+  -  Authorized Programs.                                        +\n+  \u00acZ~NOTBKGND+ -  Commands Which May Not Be Issued In The Background.         +\n)INIT\n  &AUTHTSF = 'AUTHTSF'\n  &AUTHCMD = 'AUTHCMD'\n  &AUTHPGM = 'AUTHPGM'\n  &NOTBKGND = 'NOTBKGND'\n\n  .ZVARS='(SEL1 SEL2 SEL3 SEL4)'\n  &SEL1 = &Z\n  &SEL2 = &Z\n  &SEL3 = &Z\n  &SEL4 = &Z\n)PROC\n  &ZCURSOR = .CURSOR\n\n  VER (&SEL1,LIST,'/')\n  VER (&SEL2,LIST,'/')\n  VER (&SEL3,LIST,'/')\n  VER (&SEL4,LIST,'/')\n\n  &ALL = '&SEL1 &SEL2 &SEL3 &SEL4'\n  IF (&ALL = ' ')\n     IF (&ZCURSOR = 'SEL1')\n        &SEL1 = '/'\n     IF (&ZCURSOR = 'SEL2')\n        &SEL2 = '/'\n     IF (&ZCURSOR = 'SEL3')\n        &SEL3 = '/'\n     IF (&ZCURSOR = 'SEL4')\n        &SEL4 = '/'\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LWATEDI$": {"ttr": 5641, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00@\\x01\\x081?\\x01\\t\\x03\\x7f\\x084\\x00\\x1e\\x00\\x1e\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2008-11-08T00:00:00", "modifydate": "2009-02-06T08:34:40", "lines": 30, "newlines": 30, "modlines": 0, "user": "JCL"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,ESD,RLD,BATCH,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.S19.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.S19.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.FILE452.MACLIB\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(LWATEDIT)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,4),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY   LWATEDIT\n SETSSI  CB478452\n SETCODE AC(0)\n NAME    LWATEDIT(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LWATEDI@": {"ttr": 5643, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00P\\x01\\t\\x04\\x1f\\x01\\t\\x04/\\x109\\x00D\\x00!\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2009-02-10T00:00:00", "modifydate": "2009-02-11T10:39:50", "lines": 68, "newlines": 33, "modlines": 0, "user": "HELP"}, "text": "                 NOTES ON HOW TO USE LWATEDIT\n\n\nThe LWATEDIT program was written by Dan Dalby, to make it easier to\nmanipulate your TSO authorization tables, just by editing them.\n\nIngredients:\n\n1.  Copy the LWAEDIT1 panel to one of your ISPPLIB libraries.\n\n2.  Assemble the LWATEDIT program.  It should NOT be APF-authorized.\n\n3.  Assemble the LWATMGR program.  This program has to have its name\n    in the AUTHCMD table (when it is used standalone) and also in the\n    AUTHTSF table (so it can be called by IKJEFTSR from the LWATEDIT\n    program).\n\n4.  Issue the TSO command LWATEDIT from within ISPF.\n\n5.  You will get the LWAEDIT1 panel, which will ask you to pick which\n    table you want to edit.  Place a slash / next to the table you\n    want to edit.  Press ENTER.  You will get a list of 8-character\n    program names that are in the table.  Do what you want with this\n    table, sort it, etc.  When you have finished, if you want to make\n    the new names into a new table, enter SAVE.  Otherwise just END.\n\n    If AUTOSAVE is ON in your EDIT profile, then END will create a\n    new table, because it has followed an implicit SAVE.  Therefore,\n    if you don't want to create a new table, then you have to CANcel\n    the EDIT, whenever AUTOSAVE is ON.\n\n6.  If you SAVEd the table and then exit, LWATEDIT will call LWATMGR\n    using IKJEFTSR (that's why LWATMGR has to be in AUTHTSF), and\n    LWATMGR will update the table with your new SAVEd entries.\n\n7.  Making a new table is easy, just edit the old one with LWATEDIT,\n    change it, SAVE it, and exit.  Easy as pie.  Thanks, Dan Dalby!\n\n8.  One further note.  When you are EDITing a table, you can CREATE\n    a copy of it, or of part of it, and make an LRECL=8 dataset to\n    use against LWATMGR BUILD, or LLWA D, to make a new table at a\n    later time.  You can use LWATEDIT to create lists of programs\n    for use later.  LWATEDIT is a handy way of making a program list.\n\n9.  My own practice is to make a pds with LRECL=8, and I store a large\n    collection of authorization lists there.  So when I use LWATEDIT\n    and CREATE an auth table list, I usually save it in the LRECL=8\n    pds.  When you do this, you have to remember to include the header\n    at the top of the list: \"---E2---\", \"---E8---\", \"---AP---\", or\n    \"---NS---\" so the proper new table will be built from your list\n    of program names.\n\n\nNOTES:\n\n1.  After removing table lengths with TSUB option Z, be VERY CAREFUL\n    to make sure that the resulting table has a blank at the end of\n    it.  You can use the D option of TSUB to see this.  If there is\n    no blank at the end, and no lengths either, the table might pour\n    over into subsequent storage which follows it, and there will be\n    garbage at the end of the table.  YOU DO NOT WANT TO SAVE THAT!\n\n    One solution:  Use TSUB option B to blank an entry where you think\n    the end of the table is.  Then LWATEDIT the table and SAVE it, and\n    END.  Then check it again with LWATEDIT to make sure that no\n    garbage remains at the table's end.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LWATEDIT": {"ttr": 5645, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x003\\x01\\t\\x04\\x0f\\x01\\t\\x07O\\x18\\x08\\x03\\xc1\\x03\\xb9\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2009-02-09T00:00:00", "modifydate": "2009-03-15T18:08:33", "lines": 961, "newlines": 953, "modlines": 0, "user": "SOURCE"}, "text": "LWATEDIT TITLE '- LWATEDIT - LWA Auth Table Editor'\n*---------------------------------------------------------------------*\n*                 |                                                   *\n* L W A T E D I T |                                                   *\n*                 |          Logon WorkArea Table Editor              *\n*------------------                                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*    FUNCTION:     Use ISPF Services to EDIT the TSO user's           *\n*                  authorization tables.                              *\n*                                                                     *\n*                  The update of these tables is performed by the     *\n*                  \"LWATMGR BUILD\" command function.                  *\n*                  This means that LWATMGR must be accessable to      *\n*                  you either via STEPLIB or LNKLST.                  *\n*                                                                     *\n* Special Note: LWATMGR must be added to the AUTHTSF (IKJEFTAP) table.*\n*               Otherwise the call to LWATMGR (using the IKJEFTSR     *\n*               interface) will fail.                                 *\n*                                                                     *\n*                                                                     *\n*       PARMS:  This program must be selected as a command in ISPF.   *\n*                                                                     *\n*                                                                     *\n* REGISTER USAGE:   R0 - PSA                                          *\n*                   R1 - Work Register                                *\n*                   R2 - Work Register                                *\n*                   R3 - Work Register                                *\n*                   R4 - Work Register                                *\n*                   R5 - Work Register                                *\n*                   R6 - Work Register                                *\n*                   R7 - Work Register                                *\n*                   R8 - CPPL                                         *\n*                   R9 - Work Register                                *\n*                  R10 - PCL                                          *\n*                  R11 - Not Used                                     *\n*                  R12 - Base Register #1                             *\n*                  R13 - Work Area Base Register (24-Bit Storage)     *\n*                  R14 - Return Address                               *\n*                  R15 - Return Code                                  *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*     HISTORY: #V01R001 - NOV 07,2008 -  In The Beginning...          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         EJECT 1\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Instream Macros                                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         MACRO ,\n&NAME    #SAVE ,\nSUBRTNS  LOCTR ,\n&NAME    ST    R15,STACK15         Save Work Register\n         L     R15,STACKNX@        A(Next Save Area)\n         C     R15,STACKEND        Check If Stack Has Overflowed\n         JL    #&SYSNDX            B. If Not\n         ABEND 1                   User Abend\n#&SYSNDX STM   R0,R14,0(R15)       Save Registers 0 Through 14\n         MVC   15*4(4,R15),STACK15 Save R15 As Well\n         AHI   R15,16*4            A(Next Save Area)\n         ST    R15,STACKNX@        Save Next Save Area Address\n         BALR  R11,0               Initialize Subroutine Base\n         USING *,R11\n         MEND  ,\n\n         MACRO ,\n&NAME    #RESTORE &R15=\n&NAME    DS    0H\n         AIF   ('&R15' EQ '').REST030\n         AIF   ('&R15'(1,1) EQ '(').REST010\n         LA    R15,&R15            Set Return Code\n         AGO   .REST020\n.REST010 ANOP  ,\n         AIF   ('&R15' EQ '(R15)').REST020\n         LR    R15,&R15(1)         Set Return Code\n.REST020 ANOP  ,\n         ST    R15,WRKR15          Save Return Code Value\n.REST030 ANOP  ,\n         L     R15,STACKNX@        A(Next Save Area)\n         SHI   R15,16*4            A(Current Save Area)\n         ST    R15,STACKNX@        Restore Next Save Area Address\n         LM    R0,R15,0(R15)       Restore All Registers\n         J     #&SYSNDX\n         #EXEC ,                   Executed Statements\n         LTORG ,                   Literal Pool\n#&SYSNDX DS    0H\n         AIF   ('&R15' EQ '').REST040\n         L     R15,WRKR15          Restore Return Code Value\n.REST040 ANOP  ,\n         MEND  ,\n\n         MACRO ,\n&NAME    #CALL &RTN\n&NAME    L     R15,=A(&RTN)        A(Processing Routine)\n         BALR  R14,R15             Call Subroutine\n         MEND  ,\n\n         EJECT 1\nLWATEDIT #START ,                  Start Mainline                      *\n               BASE=(R12),         Define Base Register(s)             *\n               WKDSECT=WRKLWAED,   Define Work Area Name               *\n               LOC=BELOW,          Acquire Work Area Below The Line    *\n               REG1=R8,            Command Parameter List              *\n               AMODE=31,RMODE=ANY, Execute In AMODE 31, RMODE Any      *\n               USING=(PSA,0,CPPL,R8),                                  *\n               LEVEL=#V01R001      Version Identifier\n\n*-------\n*        Initialize Save Area Stack Pointers\n*-------\n         LA    R1,STACK            A(Start Of Save Area Stack)\n         ST    R1,STACKNX@         Save \"Next\" Address\n         AH    R1,=AL2(STACKLEN)   A(End Of Save Area Stack)\n         ST    R1,STACKEND         Save \"End\" Address\n\n         MVI   BLANKS,C' '         Initialize BLANKS Area\n         MVC   BLANKS+1(L'BLANKS-1),BLANKS\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Locate and Validate The LWA                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         L     R14,PSAAOLD         A(ASCB)\n         USING ASCB,R14\n         L     R14,ASCBASXB        A(ASXB)\n         USING ASXB,R14\n         L     R14,ASXBLWA         A(LWA)\n         ST    R14,WRKLWA@         Save LWA Address\n         USING LWA,R14\n\n         C     R14,LWAPPTR         Check If LWA Points To Itself\n         BNE   LWA00400            B. If Not\n         CLC   LWALWA,=C'   LWA  ' Check LWA Identifier\n         BNE   LWA00400            B. If Valid\n\n\n*-------\n*        Save The Authorization Table Pointer Addresses\n*-------\n         LA    R0,LWATAP           A(IKJEFTAP Pointer)\n         ST    R0,WRKTAPP@\n         LA    R0,LWATAPLN         A(IKJEFTAP Length)\n         ST    R0,WRKTAPL@\n         MVC   WRKTAPL,LWATAPLN    Save IKJEFTAP Length\n         TM    LWAPRMLB,LWATAPST   Did IKJEFTAP Come From //STEPLIB\n         BZ    LWA00100            B. If Not\n         OI    WRKTAPF,WRK$STEP\nLWA00100 DS    0H\n         LA    R0,LWATE2           A(IKJEFTE2 Pointer)\n         ST    R0,WRKTE2P@\n         LA    R0,LWATE2LN         A(IKJEFTE2 Length)\n         ST    R0,WRKTE2L@\n         MVC   WRKTE2L,LWATE2LN    Save IKJEFTE2 Length\n         TM    LWAPRMLB,LWATE2ST   Did IKJEFTE2 Come From //STEPLIB\n         BZ    LWA00200            B. If Not\n         OI    WRKTE2F,WRK$STEP\nLWA00200 DS    0H\n         LA    R0,LWATE8           A(IKJEFTE8 Pointer)\n         ST    R0,WRKTE8P@\n         LA    R0,LWATE8LN         A(IKJEFTE8 Length)\n         ST    R0,WRKTE8L@\n         MVC   WRKTE8L,LWATE8LN    Save IKJEFTE8 Length\n         TM    LWAPRMLB,LWATE8ST   Did IKJEFTE8 Come From //STEPLIB\n         BZ    LWA00300            B. If Not\n         OI    WRKTE8F,WRK$STEP\nLWA00300 DS    0H\n         LA    R0,LWATNS           A(IKJEFTNS Pointer)\n         ST    R0,WRKTNSP@\n         LA    R0,LWATNSLN         A(IKJEFTNS Length)\n         ST    R0,WRKTNSL@\n         MVC   WRKTNSL,LWATNSLN    Save IKJEFTNS Length\n         TM    LWAPRMLB,LWATNSST   Did IKJEFTNS Come From //STEPLIB\n         BZ    LWA00500            B. If Not\n         OI    WRKTNSF,WRK$STEP\n         B     LWA00500\n         DROP  R14\n\nLWA00400 DS    0H\n         LHI   R0,1                Message Contains 1 Segment\n         L     R1,=A(#MSG001)      A(Error Message)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n         B     LWAEXIT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Save the TSO control block addresses                         *\n*                                                                     *\n*---------------------------------------------------------------------*\nLWA00500 DS    0H\n         L     R0,CPPLUPT          A(UPT)\n         ST    R0,WRKUPT@\n         L     R0,CPPLECT          A(ECT)\n         ST    R0,WRKECT@\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Process The Tables Via ISPF EDIT                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*-------\n*        Check For ISPF Environment\n*-------\n         LINK  EP=ISPQRY           Check For An ISPF Enfironment\n         LTR   R15,R15             Check Return Code\n         BZ    LWA00600            B. If ISPF Is Available\n         ST    R15,WRKR15          Save Return Code\n\n         LHI   R0,2                Message Contains 2 Segment\n         MVC   WRKINS1(4),=AL2(4+8,#MSG0021)\n         UNPK  WRKINS1+4(9),WRKR15(5)\n         L     R15,=A(HEXTABLE-C'0')\n         TR    WRKINS1+4(8),0(R15)\n         MVI   WRKINS1+4+8,C' '\n         L     R1,=A(#MSG002)      A(Error Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n         B     LWAEXIT\n\n*-------\n*        Define ISPF Variables\n*-------\nLWA00600 DS    0H\n         ISPLINK LOAD,SAVE=WRKLINK@,LIST=WRKCALL\n\n         ISPLINK 'VDEFINE ','DATAID  ',DATAID,'CHAR ',8\n         ISPLINK 'VDEFINE ','SEL1    ',WRKSEL1,'CHAR ',1\n         ISPLINK 'VDEFINE ','SEL2    ',WRKSEL2,'CHAR ',1\n         ISPLINK 'VDEFINE ','SEL3    ',WRKSEL3,'CHAR ',1\n         ISPLINK 'VDEFINE ','SEL4    ',WRKSEL4,'CHAR ',1\n         ISPLINK 'VDEFINE ','TEMPMSG ',TEMPMSG,'CHAR ',8\n         ISPLINK 'VDEFINE ','TEMPREC ',TEMPREC,'CHAR ',80\n         ISPLINK 'VDEFINE ','ZDSN    ',WRKZDSN,'CHAR ',44\n         ISPLINK 'VDEFINE ','ZMEMB   ',WRKCMDNM,'CHAR ',8\n         ISPLINK 'VDEFINE ','ZTEMPF  ',ZTEMPF,'CHAR ',44\n         ISPLINK 'VDEFINE ','ZTEMPN  ',ZTEMPN,'CHAR ',8\n\nLWA00700 DS    0H\n         MVI   WRKSEL1,C' '        Initialize\n         MVI   WRKSEL2,C' '        .  Panel\n         MVI   WRKSEL3,C' '        .     Selection\n         MVI   WRKSEL4,C' '        .        Options\n\n         ISPLINK 'DISPLAY ','LWAEDIT1',ERROR=LWA01500\n\n*-------\n*        Edit \"AUTHTSF\" Table\n*-------\n         CLI   WRKSEL1,C'/'        Check If \"AUTHTSF\"  Selected\n         BNE   LWA00900            B. If Not\n\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHTSF '\n         MVC   WRKTABNM,=C'---AP---'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n\n         L     R15,WRKTAPP@\n         MVC   WRKTAB@,0(R15)      Set Table Address\n         L     R15,WRKTAB@\n         AHI   R15,16              A(1st Table Entry)\n         ST    R15,WRKTABE@\n         L     R15,WRKTAPL@\n         MVC   WRKTABL,0(R15)      Set Table Length\n\n         ICM   R0,3,WRKTABL        Check If Table Has A Length\n         BNZ   LWA00800            B. If Yes\n         #CALL SETTABL             Else. Calculate Table Length\n\nLWA00800 DS    0H\n         #CALL EDIT                Edit The Table Entries\n\n*-------\n*        Edit \"AUTHCMD\" Table\n*-------\nLWA00900 DS    0H\n         CLI   WRKSEL2,C'/'        Check If \"AUTHCMD\"  Selected\n         BNE   LWA01100            B. If Not\n\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHCMD '\n         MVC   WRKTABNM,=C'---E2---'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n\n         L     R15,WRKTE2P@\n         MVC   WRKTAB@,0(R15)      Set Table Address\n         L     R15,WRKTAB@\n         AHI   R15,16              A(1st Table Entry)\n         ST    R15,WRKTABE@\n         L     R15,WRKTE2L@\n         MVC   WRKTABL,0(R15)      Set Table Length\n\n         ICM   R0,3,WRKTABL        Check If Table Has A Length\n         BNZ   LWA01000            B. If Yes\n         #CALL SETTABL             Else. Calculate Table Length\n\nLWA01000 DS    0H\n         #CALL EDIT                Edit The Table Entries\n\n*-------\n*        Edit \"AUTHPGM\" Table\n*-------\nLWA01100 DS    0H\n         CLI   WRKSEL3,C'/'        Check If \"AUTHPGM\"  Selected\n         BNE   LWA01300            B. If Not\n\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHPGM '\n         MVC   WRKTABNM,=C'---E8---'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n\n         L     R15,WRKTE8P@\n         MVC   WRKTAB@,0(R15)      Set Table Address\n         L     R15,WRKTAB@\n         AHI   R15,16              A(1st Table Entry)\n         ST    R15,WRKTABE@\n         L     R15,WRKTE8L@\n         MVC   WRKTABL,0(R15)      Set Table Length\n\n         ICM   R0,3,WRKTABL        Check If Table Has A Length\n         BNZ   LWA01200            B. If Yes\n         #CALL SETTABL             Else. Calculate Table Length\n\nLWA01200 DS    0H\n         #CALL EDIT                Edit The Table Entries\n\n*-------\n*        Edit \"NOTBKGND\" Table\n*-------\nLWA01300 DS    0H\n         CLI   WRKSEL4,C'/'        Check If \"NOTBKGND\" Selected\n         BNE   LWA00700            B. If Not\n\n         MVC   WRKCMDNL,=AL2(8)\n         MVC   WRKCMDNM,=C'NOTBKGND'\n         MVC   WRKTABNM,=C'---NS---'\n         MVC   WRKTABEL,=AL2(10)   Set Table Entry Length\n\n         L     R15,WRKTNSP@\n         MVC   WRKTAB@,0(R15)      Set Table Address\n         L     R15,WRKTAB@\n         AHI   R15,16              A(1st Table Entry)\n         ST    R15,WRKTABE@\n         L     R15,WRKTNSL@\n         MVC   WRKTABL,0(R15)      Set Table Length\n\n         ICM   R0,3,WRKTABL        Check If Table Has A Length\n         BNZ   LWA01400            B. If Yes\n         #CALL SETTABL             Else. Calculate Table Length\n\nLWA01400 DS    0H\n         #CALL EDIT                Edit The Table Entries\n\n         B     LWA00700\n\n*-------\n*        Delete ISPF Variables and Terminate\n*-------\nLWA01500 DS    0H\n         ISPLINK 'VDELETE ','* '   Delete All Defined Variables\n         ISPLINK UNLOAD            Delete ISPLINK Routine\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Terminate                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\nLWAEXIT  DS    0H\n         #CALL CLEANUP             Free All Acquired Storage\n\n         #STOP ,                   Terminate\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Constants                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LTORG ,                   Literal Pool\n         #EXEC ,                   Executed Statements\n\n#MSG001  #MSG  'LWAE01I LWA control block is not valid'\n\n#MSG002  #MSG  'LWAE02I This Program Requires An ISPF Environment.  ISP*\n               QRY Return Code  '\n#MSG0021 EQU   71,8                Insert Offset & Length\n\n#MSG003  #MSG  'LWAE03I R15=, IKJEFTSR RC= RS= ABEND= '\n#MSG0031 EQU   12,8                Insert Offset & Length\n#MSG0032 EQU   26,8                Insert Offset & Length\n#MSG0033 EQU   30,8                Insert Offset & Length\n#MSG0034 EQU   37,8                Insert Offset & Length\n\nHEXTABLE DC    C'0123456789ABCDEF'\n\nCONVDASH DC    256AL1(*-CONVDASH)\n         ORG   CONVDASH+C' '\n         DC    C'-'                Convert Blanks To Dashes\n         ORG   ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Subroutines                                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nLWATEDIT LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Perform Program Termination Cleanup                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nCLEANUP  #SAVE ,                   Save All Registers\n\n         ICM   R1,15,WRKBUFF@      A(Parmlib Read Buffer)\n         BZ    CLEA0200            B. If Not Available\n         ICM   R0,15,WRKBUFFL      L(Parmlib Read Buffer)\n         BZ    CLEA0200            B. If Not Available\n         XC    WRKBUFF@,WRKBUFF@\n         FREEMAIN RU,A=(1),LV=(0)\n\nCLEA0200 DS    0H\n         ICM   R1,15,WRKMSGB@      A(Buffer)\n         BZ    CLEA0300            B. If Not Available\n         ICM   R0,15,WRKMSGBL      L(Buffer)\n         BZ    CLEA0300            B. If Not Available\n         XC    WRKMSGB@,WRKMSGB@\n         FREEMAIN RU,A=(1),LV=(0)\n\nCLEA0300 DS    0H\n         ICM   R1,15,WRKCBUF@      A(Buffer)\n         BZ    CLEANXIT            B. If Not Available\n         ICM   R0,15,WRKCBUFL      L(Buffer)\n         BZ    CLEANXIT            B. If Not Available\n         XC    WRKCBUF@,WRKCBUF@\n         FREEMAIN RU,A=(1),LV=(0)\n\nCLEANXIT #RESTORE ,                Restore All Registers\n\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATEDIT LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Use ISPF EDIT To Process The Authorization Table Entries     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nEDIT     #SAVE ,                   Save All Registers\n\n         L     R15,WRKTAB@         A(Current Table)\n         AH    R15,WRKTABL         A(End Of Current Table)\n         ST    R15,WRKTABX@        Save End Of Table Address\n         SH    R15,WRKTABEL        A(Last Entry In Table)\n\n         CLC   WRKTABEL,=AL2(8)    Check For Normal Entry\n         BE    EDIT0100            B. If Yes\n         ICM   R0,3,0(R15)         Check If Entry Length Is Zero\n         BZ    EDIT0200            B. If Yes (End Of Table)\n         CLC   0(2,R15),=X'FFFF'   Check For Terminating Entry\n         BE    EDIT0200            B. If Yes (End Of Table)\n         TM    2(R15),X'BF'        Check If Entry Is Blank Or Zeros\n         BZ    EDIT0200            B. If Yes (End Of Table)\n         B     EDIT0300            Else. Last Entry Is Used\n\nEDIT0100 DS    0H\n         TM    0(R15),X'BF'        Check If Entry Is Blank Or Zeros\n         BZ    EDIT0200            B. If Yes (End Of Table)\n         B     EDIT0300            Else. Last Entry Is Used\n\nEDIT0200 DS    0H\n         ST    R15,WRKTABX@        Save End Of Table Address\n\nEDIT0300 DS    0H\n         MVC   WRKDSN,BLANKS\n         MVC   WRKDSN(8),WRKCMDNM  Put Table Name in EDIT Heading\n         ICM   R15,15,WRKTAB@      A(Current Table)\n         BZ    EDITEXIT            B. If No Table\n         MVC   WRKDSN+9(16),0(R15) Copy Table Header To Edit Heading\n         UNPK  WRKDSN+26(9),WRKTAB@(5)\n         L     R15,=A(HEXTABLE-C'0')\n         TR    WRKDSN+26(8),0(R15) Insert Table Address\n         MVI   WRKDSN+26+8,C' '\n         L     R15,=A(CONVDASH)\n         TR    WRKDSN(34),0(R15)   Convert Blanks To Dashes\n\n         MVC   WRKZDSN,BLANKS\n         MVC   WRKZDSN(18),=C'LWA.IKJEFTxx.TABLE'\n         MVC   WRKZDSN+10(2),WRKTABNM+3\n\n         ISPLINK 'FTOPEN ','TEMP ' Allocate An SPFTEMP.CNTL Data Set\n         ISPLINK 'VGET ','(ZTEMPF ZTEMPN)','ASIS '\n         ISPLINK 'FTCLOSE ',,ZTEMPF\n\n         ISPLINK 'LMINIT ','DATAID ',,,,,,,,ZTEMPN,,'EXCLU '\n         ISPLINK 'LMOPEN ',DATAID,'OUTPUT '\n         MVC   TEMPREC,BLANKS\n         MVC   TEMPREC(8),WRKTABNM\n         ISPLINK 'LMPUT',DATAID,'INVAR ','TEMPREC ',80\n\n         MVI   WRKUPDTE,C'N'       Initialize \"Update\" Flag\n\n         ST    R13,WRKR13          Save WorkArea Address\n         ISPLINK 'EDIF ',WRKDSN,'LWAPROF ','F ',8,                     *\n               A(EDIFREAD),A(EDIFWRITE),0,WRKR13\n\n         MVC   TEMPREC,BLANKS\n         LHI   R3,5                Add 5 Blank Slots For Use By TSUB\nEDIT0400 DS    0H\n         ISPLINK 'LMPUT',DATAID,'INVAR ','TEMPREC ',80\n         BCT   R3,EDIT0400\n\n         ISPLINK 'LMCLOSE ',DATAID Close The ISPTEMP File\n         ISPLINK 'LMFREE ',DATAID  Free The ISPTEMP File\n\n         CLI   WRKUPDTE,C'N'       Check If An Update Has Occurred\n         BE    EDITEXIT            B. If Not\n\n         MVC   WRKTSRFL,=AL1(0,0,1,1) Set IKJEFTSR Flags\n         MVC   WRKTSRC,BLANKS      Clear Command Buffer\n         MVC   WRKTSRC(19),=C'LWATMGR BUILD LIST('\n         MVI   WRKTSRC+19,C''''    Insert Leading Quote\n         MVC   WRKTSRC+20(44),ZTEMPF\n         L     R15,=A(FINDBLANK)\n         TRT   WRKTSRC+20(45),0(R15)\n         MVI   0(R1),C''''         Insert Trailing Quote\n         MVI   1(R1),C')'          Close the \"LIST\" Operand\n         LA    R15,2(,R1)          A(End Of DSName)\n         MVC   0(6,R15),=C' NOMSG' Don't Issue Messages\n         LA    R15,6(,R15)         A(End Of Command)\n         LA    R14,WRKTSRC         A(Start Of Command)\n         SR    R15,R14\n         ST    R15,WRKTSRCL        Save Command Length\n         XC    WRKRETCD,WRKRETCD\n         XC    WRKRSNCD,WRKRSNCD\n         XC    WRKABNCD,WRKABNCD\n\n         L     R15,CVTPTR             A(CVT)\n         L     R15,CVTTVT-CVT(,R15)   A(TSVT)\n         L     R15,TSVTASF-TSVT(,R15) A(Interface Routine)\n         CALL  (15),(WRKTSRFL,     Invoke IKJEFTSR Service Routine     *\n               WRKTSRC,            - Command                           *\n               WRKTSRCL,           - Command Length                    *\n               WRKRETCD,           - Return Code                       *\n               WRKRSNCD,           - Reason Code                       *\n               WRKABNCD),          - Abend  Code                       *\n               VL,MF=(E,WRKTSRPL)\n\n         LTR   R15,R15             Check Return Code\n         BZ    EDIT0500            B. If Successful\n\n         ST    R15,WRKR15          Save Return Code\n\n         MVC   WRKINS1(4),=AL2(4+8,#MSG0031)\n         UNPK  WRKINS1+4(9),WRKR15(5)\n         L     R15,=A(HEXTABLE-C'0')\n         TR    WRKINS1+4(8),0(R15)\n         MVC   WRKINS2(4),=AL2(4+8,#MSG0032)\n         UNPK  WRKINS2+4(9),WRKRETCD(5)\n         L     R15,=A(HEXTABLE-C'0')\n         TR    WRKINS2+4(8),0(R15)\n         MVC   WRKINS3(4),=AL2(4+8,#MSG0033)\n         UNPK  WRKINS3+4(9),WRKRSNCD(5)\n         L     R15,=A(HEXTABLE-C'0')\n         TR    WRKINS3+4(8),0(R15)\n         MVC   WRKINS4(4),=AL2(4+8,#MSG0034)\n         UNPK  WRKINS4+4(9),WRKABNCD(5)\n         L     R15,=A(HEXTABLE-C'0')\n         TR    WRKINS4+4(8),0(R15)\n\n         LHI   R0,5                Message Contains 5 Segments\n         L     R1,=A(#MSG003)      A(Error Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         LA    R3,WRKINS2          A(Insert #2)\n         LA    R4,WRKINS3          A(Insert #3)\n         LA    R5,WRKINS4          A(Insert #4)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\n         B     EDITEXIT\n\nEDIT0500 DS    0H\n         ISPLINK 'SETMSG ','ISRE016 '\n\nEDITEXIT #RESTORE ,                Restore All Registers\n         BR    R14                 Return To Caller\n\n         POP   USING\n\nLWATEDIT LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ISPF EDIF \"READ\" Routine                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSUBRTNS  LOCTR ,\n\n         PUSH  USING\nEDIFREAD STM   R14,R12,12(R13)     Save Caller's Registers\n         BASR  R11,0               Set Subroutine Base\n         USING *,R11\n\n         LR    R10,R13             Save Caller's Save Area Address\n         L     R13,12(,R1)         A(Save Area Passed By ISPF)\n         L     R13,0(,R13)         A(Mainline Work Area)\n\n         L     R5,8(,R1)\n         L     R5,0(,R5)           Request Code (1-1st 0-Next)\n         L     R4,0(,R1)           A(Recored Area)\n\n         L     R6,WRKTABE@         Calculate Record Offset\n         C     R6,WRKTABX@         Check If Past End Of Table\n         BNL   EDIFR200            B. If Yes\n\n         CLC   WRKTABEL,=AL2(8)    Check For Normal Entry\n         BE    EDIFR100            B. If Yes\n         AHI   R6,2                Skip Record Prefix\n\nEDIFR100 DS    0H\n         CLI   0(R6),C' '          Check For Blank Entry\n         BE    EDIFR200            B. If Yes (Logical End)\n         ST    R6,0(,R4)           Pass Entry Address To ISPF\n\n         AHI   R6,8                A(Next Entry Address)\n         ST    R6,WRKTABE@\n\n         LHI   R15,0               Set Return Code\n         B     EDIFRXIT\n\nEDIFR200 DS    0H\n         LHI   R15,8               Set Return Code\n         B     EDIFRXIT\n\nEDIFRXIT DS    0H\n         ST    R15,16(,R10)        Save Return Code\n         LR    R13,R10             A(Caller's Save Area)\n         LM    R14,R12,12(R13)     Restore Caller's Registers\n         BR    R14                 Return To Caller\n\n         LTORG ,                   Literal Pool\n         #EXEC ,                   Executed Statements\n         POP   USING\n\nLWATEDIT LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ISPF EDIF \"WRITE\" Routine                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSUBRTNS  LOCTR ,\n\n         PUSH  USING\n         DROP  ,\nEDIFWRITE STM  R14,R12,12(R13)     Save Caller's Registers\n         BASR  R11,0               Set Subroutine Base\n         USING *,R11\n\n         L     R9,16(,R1)          A(Save Area Passed By ISPF)\n         L     R9,0(,R9)           A(Mainline Work Area)\n         USING WRKLWAED,R9\n\n         LR    R10,R13             Save Caller's Save Area Address\n         LA    R13,WRKSAVE         Point To A New Save Area\n\n         L     R4,0(,R1)           A(Record Data Pointer)\n         L     R4,0(,R4)           A(Record Data)\n\n         MVI   WRKUPDTE,C'Y'       Indicate An Update Has Occurred\n\n         L     R6,12(,R1)          A(Request Code)\n         CLC   0(4,R6),=A(4)       Check For \"No Data Records\"\n         BE    EDIFWXIT            B. If Yes\n\n         MVC   TEMPREC(8),0(R4)\n\n         ISPLINK 'LMPUT',DATAID,'INVAR ','TEMPREC ',80\n\nEDIFWXIT DS    0H\n         LHI   R15,0               Set Return Code\n\n         ST    R15,16(,R10)        Save Return Code\n         LR    R13,R10             A(Caller's Save Area)\n         LM    R14,R12,12(R13)     Restore Caller's Registers\n         BR    R14                 Return To Caller\n\n         LTORG ,                   Literal Pool\n         #EXEC ,                   Executed Statements\n         POP   USING\n\nLWATEDIT LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PUTLINE Subroutine                                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nPUTLINE  #SAVE ,                   Save All Registers\n\n         STM   R0,R7,WRKOLD        Save Output Line Descriptors\n\n         L     R3,WRKUPT@          A(UPT)\n         L     R4,WRKECT@          A(ECT)\n\n         XC    WRKECB,WRKECB       Clear ECB\n         PUTLINE PARM=PUTLINEL,UPT=(R3),ECT=(R4),ECB=WRKECB,           *\n               OUTPUT=(WRKOLD,TERM,SINGLE,INFOR),                      *\n               MF=(E,WRKIOPL)      Write The Message\n\nPUTLEXIT DS    0H\n         NI    WRKFLAG,255-$ERROR\n\n         #RESTORE ,                Restore All Registers\n\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATEDIT LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Table Length Calculator Routine                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nSETTABL  #SAVE ,                   Save All Registers\n         L     R14,WRKTABE@        A(1st Table Entry)\n\nSETT0100 DS    0H\n         CLC   WRKTABEL,=AL2(8)    Check For Normal Entry\n         BE    SETT0200            B. If Yes\n\n*-------\n*        Check \"NOTBKGND\" Table Entries\n*-------\n         ICM   R0,3,0(R14)         Check If Entry Length Is Zero\n         BZ    SETT0900            B. If Yes (End Of Table)\n         CLC   0(2,R14),=X'FFFF'   Check For Terminating Entry\n         BE    SETT0900            B. If Yes (End Of Table)\n         TM    2(R14),X'BF'        Check If Entry Is Blank Or Zeros\n         BZ    SETT0900            B. If Yes (End Of Table)\n         B     SETT0300            Else. Advance To Next Entry\n\n*-------\n*        Check normal Table Entries\n*-------\nSETT0200 DS    0H\n         TM    0(R14),X'BF'        Check If Entry Is Blank Or Zeros\n         BZ    SETT0900            B. If Yes (End Of Table)\n\nSETT0300 DS    0H\n         AH    R14,WRKTABEL        A(Next Table Entry)\n         B     SETT0100            Loop Till End Of Table\n\nSETT0900 DS    0H\n         AH    R14,WRKTABEL        A(End Of Last Slot)\n         L     R15,WRKTAB@         A(Start Of Table)\n         SR    R14,R15             Calculate Table Length\n         STH   R14,WRKTABL         Save Calculated Table Length\n\n         #RESTORE ,                Restore All Registers\n\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATEDIT LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Dynamic Work Area                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nFINDBLANK DC   256X'00'\n         ORG   FINDBLANK+C' '\n         DC    C' '                Find First Blank\n         ORG   ,\n\n         #STARTWA PATCH=NO\n\nPUTLINEL PUTLINE MF=L              PUTLINE Parameter List\n\nWRKCALL  CALL  ,(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),VL,MF=L\nWRKLINK@ DS    A                   ISPLINK ROUTINE ADDRESS\n\nBLANKS   DS    CL80                Initialized Blanks\n\nWRKDBL   DS    D\nWRKECB   DS    F                   ECB\nWRKECT@  DS    A                   ECT Address\nWRKUPT@  DS    A                   UPT Address\n\nWRKFLAG  DS    X                   General Flag Byte\n$MSG_NF  EQU   X'08'               - Issue \"Not Found\" Message\n$MSG_F   EQU   X'04'               - Issue \"Found\" Message\n$ERROR   EQU   X'02'               - This Is An Error Message\n\nWRKSAVE  DS    20F                 Register Save Area\n\n         CNOP  0,4\nWRKINS1  DS    AL2,AL2,CL80        PUTLINE Message Insert #1\nWRKINS2  DS    AL2,AL2,CL80        PUTLINE Message Insert #2\nWRKINS3  DS    AL2,AL2,CL80        PUTLINE Message Insert #3\nWRKINS4  DS    AL2,AL2,CL80        PUTLINE Message Insert #4\nWRKINS5  DS    AL2,AL2,CL80        PUTLINE Message Insert #5\nWRKINS6  DS    AL2,AL2,CL80        PUTLINE Message Insert #6\n\nWRKIOPL  DS    4F                  IOPL\nWRKLWA@  DS    A                   LWA Address\nWRKOLD   DS    F                   Number Of Message Segments\n         DS    A                   A(Message Text)\n         DS    A                   A(Message Insert 1)\n         DS    A                   A(Message Insert 2)\n         DS    A                   A(Message Insert 3)\n         DS    A                   A(Message Insert 4)\n         DS    A                   A(Message Insert 5)\n         DS    A                   A(Message Insert 6)\n\nWRKPPL   DS    7F                  PPL\nWRKPDL1  DS    A                   PDL\nWRKPDL2  DS    A                   PDL (IKJTSOxx Section Parse)\n\nWRKKW@   DS    A                   Keyword Matching Found Table\n\nWRKDDPDE DS    A,AL2,CL8           DD Name PDE\nWRKDDN   EQU   WRKDDPDE+6,8        DD Name\nWRKDSPDE DS    A,AL2,CL46          Data Set Name PDE\nWRKDSN   EQU   WRKDSPDE+6,46       Data Set Name\nWRKMNPDE DS    A,AL2,CL8           Member Name PDE\nWRKMEMNM EQU   WRKMNPDE+6,8        Member Name\n\nWRKZDSN  DS    CL44                ISPF Message DSName\nWRKUPDTE DS    C                   Edit Performed Update (Y/N)\nWRKSEL1  DS    C                   ISPF Selection Option\nWRKSEL2  DS    C                   ISPF Selection Option\nWRKSEL3  DS    C                   ISPF Selection Option\nWRKSEL4  DS    C                   ISPF Selection Option\n\n         CNOP  0,4\nWRKCMDNL DS    AL2                 IKJTSOxx Section Command Length\nWRKCMDNM DS    CL8                 IKJTSOxx Section Command\n\nWRKCMD@  DS    A                   IKJTSOxx Buffer Section Start\nWRKCMDE@ DS    A                   IKJTSOxx Buffer Section End\n\nWRKCBUF@ DS    A                   Command Buffer Address\nWRKCBUFL DS    F                   Command Buffer Length\n\nWRKTSRFL DS    0F                  TSO Service Routine Flags\n         DC    X'00'               Reserved\n         DC    X'00'               Internal Processing Options\n         DC    X'01'               Dump If Command Abends\n         DC    X'01'               Command Is Being Invoked\n\n         DS    0F\nWRKTSRC  DS    C'LWATMGR BUILD LIST(''123456789.123456789.123456789.123*\n               456789.1234'')'     Authorized Command\nWRKTSRCL DS    A(L'WRKTSRC)        Authorized Command Length\nWRKRETCD DS    F                   Command Return Code\nWRKRSNCD DS    F                   Command Reason Code\nWRKABNCD DS    F                   Command Abend Code\nWRKTSRPL DS    8F                  TSO Service Routine Parameters\n\nWRKR13   DS    F                   Register 13 Save Area\nWRKR14   DS    F                   Register 14 Save Area\nWRKR15   DS    F                   Register 15 Save Area\n\nWRKREASN DS    F                   IEFPRMLB Reason Code\nWRKRCODE DS    F                   IEFPRMLB Return Code\nWRKBUFF@ DS    A                   IEFPRMLB Return Buffer Address\nWRKBUFFL DS    F                   IEFPRMLB Return Buffer Length\nWRKMSGB@ DS    A                   IEFPRMLB Returned Message Buffer\nWRKMSGBL DS    F                   IEFPRMLB Returned Message Buffer Len\nWRKMSGBE DS    A                   End Of Buffer\n\nWRKDATAL DS    AL2                 Current Keyword's Operand Length\nWRKDATA  DS    CL80                Current Keyword's Operand\nWRKNAMEL DS    AL2                 Current Command/Program Name Length\nWRKNAME  DS    CL8                 Current Command/Program Name\nWRKNAMEO DS    A                   Current Entry's Offset In Table\nWRKNEWNL DS    AL2                 New Command/Program Name Length\nWRKNEWN  DS    CL8                 New Command/Program Name\nWRKTMPNL DS    AL2                 Save Area For NAME Length\nWRKTMPN  DS    CL8                 Save Area For NAME\n\nDATAID   DS    CL8                 LM Data Id\nTEMPMSG  DS    CL8                 Temporary ISPF MsgId\nTEMPREC  DS    CL80                Temporary Output Record\nZTEMPF   DS    CL44                ISPTEMP Dsname\nZTEMPN   DS    CL8                 ISPTEMP DDName\n\nWRKTABNM DS    CL8                 Current Table Name\nWRKTAB@  DS    A                   Current Table Address\nWRKTABE@ DS    A                   Current Table End Address\nWRKTABPK DS    X                   Current Table PSW Key\nWRKTABF  DS    X                   Current Table Flags\nWRK$STEP EQU   X'80'   1... ....   Table Was Loaded From //STEPLIB\nWRKTABEL DS    AL2                 Current Table Entry Length\nWRKTABX@ DS    A                   Current Table End Address\nWRKTABL  DS    AL2                 Current Table LWA Length\n\nWRKTAPP@ DS    A                   IKJEFTAP Table Pointer Address\nWRKTAPL@ DS    A                   IKJEFTAP Table Length Address\nWRKTAPL  DS    AL2                 IKJEFTAP Table Length In LWA\nWRKTAPF  DS    C                   IKJEFTAP Flags\n         DS    X\n\nWRKTE2P@ DS    A                   IKJEFTE2 Table Pointer Address\nWRKTE2L@ DS    A                   IKJEFTE2 Table Length Address\nWRKTE2L  DS    AL2                 IKJEFTE2 Table Length In LWA\nWRKTE2F  DS    C                   IKJEFTE2 Flags\n         DS    X\n\nWRKTE8P@ DS    A                   IKJEFTE8 Table Pointer Address\nWRKTE8L@ DS    A                   IKJEFTE8 Table Length Address\nWRKTE8L  DS    AL2                 IKJEFTE8 Table Length In LWA\nWRKTE8F  DS    C                   IKJEFTE8 Flags\n         DS    X\n\nWRKTNSP@ DS    A                   IKJEFTNS Table Pointer Address\nWRKTNSL@ DS    A                   IKJEFTNS Table Length Address\nWRKTNSL  DS    AL2                 IKJEFTNS Table Length In LWA\nWRKTNSF  DS    C                   IKJEFTNS Flags\n         DS    X\n\nSTACK15  DS    F                   Stack Save Area\nSTACKNX@ DS    A                   Next Save Area On The Stack\nSTACKEND DS    A                   End Of Stack Address\nSTACK    DS    (10*16)F            Register Save Area Stack\nSTACKLEN EQU   *-STACK             Length Of Save Area Stack\n         #STOPWA ,\n\n         IKJEFLWA ,                LOGON Work Area\n\n         IKJEFFDF DFDSECT=YES,DFDSEC2=YES\n         IKJTSVT ,                 TSO Service Vector Table\n\n         #DSECTS ASCB,ASXB,CVT,PSA,TSO\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LWATMGR": {"ttr": 6150, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x001\\x01\\t\\x02\\x9f\\x01\\t\\x02\\x9f\\x15\\x11\\x0e\\x07\\x0e\\x07\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2009-01-29T00:00:00", "modifydate": "2009-01-29T15:11:31", "lines": 3591, "newlines": 3591, "modlines": 0, "user": "SOURCE"}, "text": "LWATMGR  TITLE '- LWATMGR - LWA Table Manager'\n*---------------------------------------------------------------------*\n*                 |                                                   *\n* L W A T M G R   |                                                   *\n*                 |          Logon WorkArea Table Manager             *\n*------------------                                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*    FUNCTION:     Dynamically Manage the TSO user's copy of the      *\n*                  authorization tables.                              *\n*                                                                     *\n*                  These tables are typically created from the        *\n*                  IKJTSOxx parmlib member but can be loaded from     *\n*                  an authorized STEPLIB or from LPA when the user    *\n*                  logs on to TSO.                                    *\n*                                                                     *\n*                  This program can replace the tables entirely,      *\n*                  just selected table(s) or it can add or remove     *\n*                  entries from the existing table.                   *\n*                                                                     *\n*                  The updates to this table affect the current TSO   *\n*                  user only.  The other TSO users are unchanged.     *\n*                  This makes this command ideal for testing a new    *\n*                  IKJTSOxx member.                                   *\n*                                                                     *\n*                  Note: If the initial table was loaded from either  *\n*                        STEPLIB or it resides in LPA, this program   *\n*                        will replace the table with one simulating   *\n*                        the PARMLIB version of the table.            *\n*                        Once the table is in this format additions   *\n*                        and deletions can easily be performed.       *\n*                        When this \"LOAD MODULE\" verion of the table  *\n*                        is replaced, it's storage is not released    *\n*                        as the actual size is unknown.               *\n*                        As this is only done one time it should not  *\n*                        cause a storage shortage problem.            *\n*                                                                     *\n*                                                                     *\n*       PARMS:  See comment block above \"PCL\".                        *\n*                                                                     *\n*                                                                     *\n* REGISTER USAGE:   R0 - PSA                                          *\n*                   R1 - Work Register                                *\n*                   R2 - Work Register                                *\n*                   R3 - Work Register                                *\n*                   R4 - Work Register                                *\n*                   R5 - Work Register                                *\n*                   R6 - Work Register                                *\n*                   R7 - Work Register                                *\n*                   R8 - CPPL                                         *\n*                   R9 - Work Register                                *\n*                  R10 - PCL                                          *\n*                  R11 - Base Register #2                             *\n*                  R12 - Base Register #1                             *\n*                  R13 - Work Area Base Register (24-Bit Storage)     *\n*                  R14 - Return Address                               *\n*                  R15 - Return Code                                  *\n*                                                                     *\n*                                                                     *\n* EXTERNALS:                                                          *\n*            DYNALLOC - Under the guise of the \"ALLOC\" and \"FREE\"     *\n*                       macro, to perform dynamic allocation.         *\n*            IEFPRMLB - Read the specified PARMLIB member into        *\n*                       storage as one large string.                  *\n*            IKJPARS  - Parse the main command & also parse the       *\n*                       IKJTSOxx statements.                          *\n*            ISPLINK  - Invoke ISPF Services.                         *\n*            PUTLINE  - Write messages to the user.                   *\n*                                                                     *\n*                                                                     *\n* Attributes:  Authorized, Key 8, Problem State, Reentrant, Amode 31. *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*     HISTORY: #V01R001 - NOV 07,2008 -  In The Beginning...          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         EJECT 1\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Instream Macros                                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         MACRO ,\n&NAME    #SAVE ,\nSUBRTNS  LOCTR ,\n&NAME    ST    R15,STACK15         Save Work Register\n         L     R15,STACKNX@        A(Next Save Area)\n         C     R15,STACKEND        Check If Stack Has Overflowed\n         JL    #&SYSNDX            B. If Not\n         ABEND 1                   User Abend\n#&SYSNDX STM   R0,R14,0(R15)       Save Registers 0 Through 14\n         MVC   15*4(4,R15),STACK15 Save R15 As Well\n         AHI   R15,16*4            A(Next Save Area)\n         ST    R15,STACKNX@        Save Next Save Area Address\n         BALR  R11,0               Initialize Subroutine Base\n         USING *,R11\n         MEND  ,\n\n         MACRO ,\n&NAME    #RESTORE &R15=\n&NAME    DS    0H\n         AIF   ('&R15' EQ '').REST030\n         AIF   ('&R15'(1,1) EQ '(').REST010\n         LA    R15,&R15            Set Return Code\n         AGO   .REST020\n.REST010 ANOP  ,\n         AIF   ('&R15' EQ '(R15)').REST020\n         LR    R15,&R15(1)         Set Return Code\n.REST020 ANOP  ,\n         ST    R15,WRKR15          Save Return Code Value\n.REST030 ANOP  ,\n         L     R15,STACKNX@        A(Next Save Area)\n         SHI   R15,16*4            A(Current Save Area)\n         ST    R15,STACKNX@        Restore Next Save Area Address\n         LM    R0,R15,0(R15)       Restore All Registers\n         J     #&SYSNDX\n         #EXEC ,                   Executed Statements\n         LTORG ,                   Literal Pool\n#&SYSNDX DS    0H\n         AIF   ('&R15' EQ '').REST040\n         L     R15,WRKR15          Restore Return Code Value\n.REST040 ANOP  ,\n         MEND  ,\n\n         MACRO ,\n&NAME    #CALL &RTN\n&NAME    L     R15,=A(&RTN)        A(Processing Routine)\n         BALR  R14,R15             Call Subroutine\n         MEND  ,\n\n         EJECT 1\nLWATMGR  #START ,                  Start Mainline                      *\n               BASE=(R12,R11),     Define Base Register(s)             *\n               WKDSECT=WRKLWATM,   Define Work Area Name               *\n               LOC=BELOW,          Acquire Work Area Below The Line    *\n               REG1=R8,            Command Parameter List              *\n               AMODE=31,RMODE=ANY, Execute In AMODE 31, RMODE Any      *\n               USING=(PSA,0,CPPL,R8),                                  *\n               LEVEL=#V01R001      Version Identifier\n\n*-------\n*        Initialize Save Area Stack Pointers\n*-------\n         LA    R1,STACK            A(Start Of Save Area Stack)\n         ST    R1,STACKNX@         Save \"Next\" Address\n         AH    R1,=AL2(STACKLEN)   A(End Of Save Area Stack)\n         ST    R1,STACKEND         Save \"End\" Address\n\n         MVI   BLANKS,C' '         Initialize BLANKS Area\n         MVC   BLANKS+1(L'BLANKS-1),BLANKS\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Locate and Validate The LWA                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         L     R14,PSAAOLD         A(ASCB)\n         USING ASCB,R14\n         L     R14,ASCBASXB        A(ASXB)\n         USING ASXB,R14\n         L     R14,ASXBLWA         A(LWA)\n         ST    R14,WRKLWA@         Save LWA Address\n         USING LWA,R14\n\n         C     R14,LWAPPTR         Check If LWA Points To Itself\n         BNE   LWA00400            B. If Not\n         CLC   LWALWA,=C'   LWA  ' Check LWA Identifier\n         BNE   LWA00400            B. If Valid\n\n         MVC   WRKPRMLB,LWAPRMLB   Save Original LWA Flag Value\n\n*-------\n*        Save The Authorization Table Pointer Addresses\n*-------\n         LA    R0,LWATAP           A(IKJEFTAP Pointer)\n         ST    R0,WRKTAPP@\n         LA    R0,LWATAPLN         A(IKJEFTAP Length)\n         ST    R0,WRKTAPL@\n         MVC   WRKTAPL,LWATAPLN    Save IKJEFTAP Length\n         TM    LWAPRMLB,LWATAPST   Did IKJEFTAP Come From //STEPLIB\n         BZ    LWA00100            B. If Not\n         OI    WRKTAPF,WRK$STEP\nLWA00100 DS    0H\n         LA    R0,LWATE2           A(IKJEFTE2 Pointer)\n         ST    R0,WRKTE2P@\n         LA    R0,LWATE2LN         A(IKJEFTE2 Length)\n         ST    R0,WRKTE2L@\n         MVC   WRKTE2L,LWATE2LN    Save IKJEFTE2 Length\n         TM    LWAPRMLB,LWATE2ST   Did IKJEFTE2 Come From //STEPLIB\n         BZ    LWA00200            B. If Not\n         OI    WRKTE2F,WRK$STEP\nLWA00200 DS    0H\n         LA    R0,LWATE8           A(IKJEFTE8 Pointer)\n         ST    R0,WRKTE8P@\n         LA    R0,LWATE8LN         A(IKJEFTE8 Length)\n         ST    R0,WRKTE8L@\n         MVC   WRKTE8L,LWATE8LN    Save IKJEFTE8 Length\n         TM    LWAPRMLB,LWATE8ST   Did IKJEFTE8 Come From //STEPLIB\n         BZ    LWA00300            B. If Not\n         OI    WRKTE8F,WRK$STEP\nLWA00300 DS    0H\n         LA    R0,LWATNS           A(IKJEFTNS Pointer)\n         ST    R0,WRKTNSP@\n         LA    R0,LWATNSLN         A(IKJEFTNS Length)\n         ST    R0,WRKTNSL@\n         MVC   WRKTNSL,LWATNSLN    Save IKJEFTNS Length\n         TM    LWAPRMLB,LWATNSST   Did IKJEFTNS Come From //STEPLIB\n         BZ    LWA00500            B. If Not\n         OI    WRKTNSF,WRK$STEP\n         B     LWA00500\n         DROP  R14\n\nLWA00400 DS    0H\n         MVC   WRKDATA(#MSG001L),#MSG001\n         TPUT  WRKDATA,#MSG001L    Write Message\n         B     LWAEXIT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Check Current Authorization Level                            *\n*                                                                     *\n*---------------------------------------------------------------------*\nLWA00500 DS    0H\n         TESTAUTH STATE=YES,       Check If Already In                 *\n               RBLEVEL=1           Supervisor State\n         LTR   R15,R15\n         BNZ   LWA00600            B. If Not (Modeset Required)\n\n         OI    WRKFLAG,$SUPER      Remember \"Supervisor State\"\n\nLWA00600 DS    0H\n         TESTAUTH FCTN=1           Check If APF Authorized\n         LTR   R15,R15\n         BNZ   LWA00700            B. If Not\n\n         OI    WRKFLAG,$APF        Remember \"APF Authorized\"\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Parse The Input Command Buffer                               *\n*                                                                     *\n*---------------------------------------------------------------------*\nLWA00700 DS    0H\n         L     R0,CPPLUPT          A(UPT)\n         ST    R0,WRKUPT@\n         L     R0,CPPLECT          A(ECT)\n         ST    R0,WRKECT@\n\n         LA    R1,WRKPPL           A(Parse Parameter List)\n         USING PPL,R1\n         MVC   PPLUPT,WRKUPT@      Set UPT  Address\n         MVC   PPLECT,WRKECT@      Set ECT  Address\n         LA    R0,WRKECB\n         ST    R0,PPLECB           Save ECB Address\n         XC    WRKECB,WRKECB\n         L     R0,=A(PCL)          A(Parse Command List)\n         ST    R0,PPLPCL           Save PCL Address\n         MVC   PPLCBUF,CPPLCBUF    Copy Command Buffer Address\n         LA    R0,WRKPDL1\n         ST    R0,PPLANS           Save PDL Address\n         DROP  R1\n\n         CALLTSSR EP=IKJPARS,      Invoke Parse Routine                *\n               MF=(E,WRKPPL)\n         LTR   R15,R15             Check Parse Return Code\n         BNZ   LWAEXIT             B. If Command Syntax Error\n\n         L     R10,WRKPDL1         A(PDL)\n         USING MAINPCL,R10\n         LA    R1,PARMLIB\n\n         L     R2,=A(X'FFFF')      L(IEFPRMLB Message Buffer)\n         GETMAIN RU,LV=(R2),LOC=ANY\n         ST    R1,WRKMSGB@         Save IEFPRMLB Message Buffer Address\n         ST    R2,WRKMSGBL         Save IEFPRMLB Message Buffer Length\n         EJECT 1\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Add A New Command/Program To The Specified Table             *\n*        - A new entry will be added to the end of a table.           *\n*                                                                     *\n*     Syntax:                                                         *\n*        LWATMGR ADD                                                  *\n*              { AUTHTSF  | AUTHCMD  | AUTHPGM  | NOTBKGND }          *\n*                NAME(command/program)                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         CLI   FUNCKW+1,$ADD       Check For 'ADD' Keyword\n         BNE   LWA01500            B. If Not\n\n         #CALL CHECKTAB            Check If A Table Was Specified\n         BNZ   LWAEXIT             B. If Not\n\n         MVC   WRKINS1(4),=AL2(4+4,#MSG0061)\n         MVC   WRKINS1+4(8),=C'NAME    '\n         LA    R1,NAME             A(Keyword)\n         #CALL SAVEKW              Check For \"NAME\" Keyword\n         BZ    LWAEXIT             B. If Not Specified\n         MVC   WRKNAMEL,WRKDATAL   Save \"NAME\" Value Length\n         MVC   WRKNAME,WRKDATA     Save \"NAME\" Value\n\n         OI    WRKFLAG,$MSG_F      Issue \"Found\" Message\n         #CALL FINDNAME            Find The Table Entry's Address\n         BNZ   LWAEXIT             B. If Entry Already Exists\n\n         #CALL COPYTAB             Ensure Table Is In Our Address Space\n         BZ    LWAEXIT             B. If Table Does Not Exist\n\n*-------\n*        Increase The Size Of The Current Table\n*-------\n         #CALL AUTH                Get Into Supervisor State, Key Zero\n         BNZ   LWAEXIT             B. If Not Authorized\n\n         LH    R3,WRKTABL          Load Calculated Table Length\n         AH    R3,WRKTABEL         Add Length Of One Entry\n         GETMAIN RU,LV=(R3),SP=252,LOC=BELOW\n         ST    R1,WRKAUTH@         Save Authorized Table Address\n         STH   R3,WRKAUTHL         Save Authorized Table Length\n\n         L     R4,WRKTAB@          A(Current Table)\n         #MVCL (R1),(R4),LEN=(R3)  Copy Table To Authorized Storage\n\n         L     R15,WRKAUTH@        A(Authorized Storage Table)\n         AH    R15,WRKAUTHL        A(End Of Authorized Storage Table)\n         SH    R15,WRKTABEL        A(Last Entry In Authorized Table)\n\n         LH    R14,WRKTABEL        L(Table Entry)\n         #EXEC -R14,MVC,0(*-*,R15),BLANKS\n         CLC   WRKTABEL,=AL2(10)   Check For IKJEFTNS Table\n         BNE   LWA00800            B. If Not\n         MVC   0(2,R15),=X'FFFF'   Change Last Entry To A Terminator\n\nLWA00800 DS    0H\n         L     R1,WRKTAB@@         A(Table Address In LWA)\n         MVC   WRKTAB@,0(R1)       Save Old Table Address\n         MVC   0(4,R1),WRKAUTH@    Point To New Table\n         L     R1,WRKTABL@         A(Table Length In LWA)\n         MVC   WRKTABL,0(R1)       Save Old Table Length\n         MVC   0(2,R1),WRKAUTHL    Set To New Table Length\n\n         ICM   R1,15,WRKTAB@       A(Previous Table)\n         BZ    LWA00900            B. If No Previous Table\n         SLR   R0,R0\n         ICM   R0,3,WRKTABL        A(Previous Table Length)\n         BZ    LWA00900            B. If No Previous Table\n         FREEMAIN RU,A=(1),LV=(0),SP=252\n\n*-------\n*        Scan Current Table For The 1st Empty Slot & Insert New Entry\n*-------\nLWA00900 DS    0H\n         MVC   WRKTAB@,WRKAUTH@    Set New Table Address\n         MVC   WRKTABL,WRKAUTHL    Set New Table Length\n\n         L     R3,WRKTAB@          A(Start Of New Table)\n         LR    R15,R3\n         AH    R15,WRKTABL         A(End Of Table)\n         ST    R15,WRKTABE@\n         AHI   R3,16               A(1st Entry)\n\nLWA01000 DS    0H\n         CLC   WRKTABEL,=AL2(8)    Check For Normal Table Entry\n         BNE   LWA01100            B. If Not\n         CLC   0(8,R3),BLANKS      Check For Empty Slot\n         BNE   LWA01300            B. If Not\n         MVC   0(8,R3),WRKNAME     Insert New Name\n         B     LWA01400\n\nLWA01100 DS    0H\n         CLC   0(2,R3),=X'0000'    Check For Null Slot\n         BE    LWA01200            B. If Yes\n         CLC   0(2,R3),=X'FFFF'    Check For Terminator Slot\n         BNE   LWA01300            B. If Not\nLWA01200 DS    0H\n         MVC   0(2,R3),WRKNAMEL    Insert New Name Length\n         MVC   2(8,R3),WRKNAME     Insert New Name\n         B     LWA01400\n\nLWA01300 DS    0H\n         AH    R3,WRKTABEL         A(Next Entry In Table)\n         C     R3,WRKTABE@         Check For End Of Table\n         BL    LWA01000            B. If Not\n\n         #CALL DEAUTH              Return To Original State & Key\n         B     LWAEXIT             This Branch Should Never Be Taken\n\nLWA01400 DS    0H\n         #CALL DEAUTH              Return To Original State & Key\n\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0021)\n         LH    R0,WRKNAMEL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         MVC   WRKINS1+4(8),WRKNAME\n         MVC   WRKINS2(4),=AL2(4+*-*,#MSG0022)\n         LH    R0,WRKCMDNL\n         AHI   R0,4\n         STH   R0,WRKINS2\n         MVC   WRKINS2+4(8),WRKCMDNM\n\n         LHI   R0,3                Message Contains 3 Segments\n         L     R1,=A(#MSG002)      A(Added Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         LA    R3,WRKINS2          A(Insert #2)\n         #CALL PUTLINE             Write Message\n         B     LWAEXIT\n         EJECT 1\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Delete An Entry From The Specified Table                     *\n*        - Remove an existing entry from within a table.              *\n*                                                                     *\n*     Syntax:                                                         *\n*        LWATMGR DELETE                                               *\n*              { AUTHTSF  | AUTHCMD  | AUTHPGM  | NOTBKGND }          *\n*                NAME(command/program)                                *\n*                                                                     *\n*---------------------------------------------------------------------*\nLWA01500 DS    0H\n         CLI   FUNCKW+1,$DELETE    Check For 'DELETE' Keyword\n         BNE   LWA01700            B. If Not\n\n         #CALL CHECKTAB            Check If A Table Was Specified\n         BNZ   LWAEXIT             B. If Not\n\n         MVC   WRKINS1(4),=AL2(4+4,#MSG0061)\n         MVC   WRKINS1+4(8),=C'NAME    '\n         LA    R1,NAME             A(Keyword)\n         #CALL SAVEKW              Check For \"NAME\" Keyword\n         BZ    LWAEXIT             B. If Not Specified\n         MVC   WRKNAMEL,WRKDATAL   Save \"NAME\" Value Length\n         MVC   WRKNAME,WRKDATA     Save \"NAME\" Value\n\n         OI    WRKFLAG,$MSG_NF     Issue \"Not_Found\" Message\n         #CALL FINDNAME            Find The Table Entry's Address\n         BZ    LWAEXIT             B. If Entry Not Found\n\n         #CALL COPYTAB             Ensure Table Is In Our Address Space\n         BZ    LWAEXIT             B. If Table Does Not Exist\n\n         #CALL AUTH                Get Into Supervisor State, Key Zero\n         BNZ   LWAEXIT             B. If Not Authorized\n\n         L     R5,WRKTAB@\n         A     R5,WRKNAMEO         A(Current Table Entry)\n         L     R4,WRKTAB@\n         AH    R4,WRKTABL          A(End Of Current Table)\n         ST    R4,WRKTABE@\n         LR    R3,R5\n         AH    R3,WRKTABEL         A(Next Entry In Table)\n         SR    R4,R3               Calculate Remaining Length\n         #MVCL (R5),(R3),LEN=(R4)  Shift Out Entry To Be Deleted\n\n         L     R4,WRKTABE@         A(End Of Table)\n         SH    R4,WRKTABEL         A(Last Entry In Table)\n         LH    R14,WRKTABEL\n         #EXEC -R14,MVC,0(*-*,R4),BLANKS\n         CLC   WRKTABEL,=AL2(10)   Check For IKJEFTNS Table\n         BNE   LWA01600            B. If Not\n         MVC   0(2,R4),=X'FFFF'    Change Entry To Terminator\n\nLWA01600 DS    0H\n         #CALL DEAUTH              Return To Original State & Key\n\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0031)\n         LH    R0,WRKNAMEL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         MVC   WRKINS1+4(8),WRKNAME\n         MVC   WRKINS2(4),=AL2(4+*-*,#MSG0032)\n         LH    R0,WRKCMDNL\n         AHI   R0,4\n         STH   R0,WRKINS2\n         MVC   WRKINS2+4(8),WRKCMDNM\n\n         LHI   R0,3                Message Contains 3 Segments\n         L     R1,=A(#MSG003)      A(Removed Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         LA    R3,WRKINS2          A(Insert #2)\n         #CALL PUTLINE             Write Message\n         B     LWAEXIT\n         EJECT 1\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Display Information About The Specified Table(s)             *\n*        - Report on the table location, attributes and contents.     *\n*                                                                     *\n*     Syntax:                                                         *\n*        LWATMGR DISPLAY                                              *\n*              { AUTHTSF  | AUTHCMD  | AUTHPGM  | NOTBKGND | ALL }    *\n*                                                                     *\n*---------------------------------------------------------------------*\nLWA01700 DS    0H\n         CLI   FUNCKW+1,$DISPLAY   Check For 'DISPLAY' Keyword\n         BNE   LWA02200            B. If Not\n\n         CLI   APKW+1,$AUTHTSF     Check For \"AUTHTSF\" Keyword\n         BE    LWA01800            B. If Yes\n         CLI   E2KW+1,$AUTHCMD     Check For \"AUTHCMD\" Keyword\n         BE    LWA01800            B. If Yes\n         CLI   E8KW+1,$AUTHPGM     Check For \"AUTHPGM\" Keyword\n         BE    LWA01800            B. If Yes\n         CLI   NSKW+1,$NOTBKGND    Check For \"NOTBKGND\" Keyword\n         BE    LWA01800            B. If Yes\n         MVI   APKW+1,$AUTHTSF\n         MVI   E2KW+1,$AUTHCMD\n         MVI   E8KW+1,$AUTHPGM     Default to \"LWATMGR DISPLAY ALL\"\n         MVI   NSKW+1,$NOTBKGND\n\nLWA01800 DS    0H\n         CLI   APKW+1,$AUTHTSF     Check For 'IKJEFTAP' Keyword\n         BNE   LWA01900            B. If Not\n         L     R5,WRKTAPP@\n         ICM   R5,15,0(R5)         A(IKJEFTAP Table)\n         BZ    LWA01900            B. If Not Available\n         MVC   WRKTABNM,=C'AUTHTSF '\n         ST    R5,WRKTAB@          Save Table Address\n         IVSK  R15,R5              Get Storage Key\n         STC   R15,WRKTABPK        Save Table Key\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         MVC   WRKTABL,WRKTAPL     Save Length Found in LWA\n         MVC   WRKTABF,WRKTAPF     Save Table Flag\n         #CALL DISPTAB             Display Table Information\n\nLWA01900 DS    0H\n         CLI   E2KW+1,$AUTHCMD     Check For 'IKJEFTE2' Keyword\n         BNE   LWA02000            B. If Not\n         L     R5,WRKTE2P@\n         ICM   R5,15,0(R5)         A(IKJEFTE2 Table)\n         BZ    LWA01900            B. If Not Available\n         MVC   WRKTABNM,=C'AUTHCMD '\n         ST    R5,WRKTAB@          Save Table Address\n         IVSK  R15,R5              Get Storage Key\n         STC   R15,WRKTABPK        Save Table Key\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         MVC   WRKTABL,WRKTE2L     Save Length Found in LWA\n         MVC   WRKTABF,WRKTE2F     Save Table Flag\n         #CALL DISPTAB             Display Table Information\n\nLWA02000 DS    0H\n         CLI   E8KW+1,$AUTHPGM     Check For 'IKJEFTE8' Keyword\n         BNE   LWA02100            B. If Not\n         L     R5,WRKTE8P@\n         ICM   R5,15,0(R5)         A(IKJEFTE2 Table)\n         BZ    LWA02100            B. If Not Available\n         MVC   WRKTABNM,=C'AUTHPGM '\n         ST    R5,WRKTAB@          Save Table Address\n         IVSK  R15,R5              Get Storage Key\n         STC   R15,WRKTABPK        Save Table Key\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         MVC   WRKTABL,WRKTE8L     Save Length Found in LWA\n         MVC   WRKTABF,WRKTE8F     Save Table Flag\n         #CALL DISPTAB             Display Table Information\n\nLWA02100 DS    0H\n         CLI   NSKW+1,$NOTBKGND    Check For 'IKJEFTNS' Keyword\n         BNE   LWAEXIT             B. If Not\n         L     R5,WRKTNSP@\n         ICM   R5,15,0(R5)         A(IKJEFTNS Table)\n         BZ    LWAEXIT             B. If Not Available\n         MVC   WRKTABNM,=C'NOTBKGND'\n         ST    R5,WRKTAB@          Save Table Address\n         IVSK  R15,R5              Get Storage Key\n         STC   R15,WRKTABPK        Save Table Key\n         MVC   WRKTABEL,=AL2(10)   Set Table Entry Length\n         MVC   WRKTABL,WRKTNSL     Save Length Found in LWA\n         MVC   WRKTABF,WRKTNSF     Save Table Flag\n         #CALL DISPTAB             Display Table Information\n         B     LWAEXIT\n         EJECT 1\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Reload The Tables From A Load Module                         *\n*        - Load an assembled version of the IKJTABLS alias entry.     *\n*                                                                     *\n*     Syntax:                                                         *\n*        LWATMGR RELOAD                                               *\n*              { AUTHTSF  | AUTHCMD  | AUTHPGM  | NOTBKGND | ALL }    *\n*                LOADLIB(dataset)                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nLWA02200 DS    0H\n         CLI   FUNCKW+1,$RELOAD    Check For 'RELOAD' Keyword\n         BNE   LWA03200            B. If Not\n\n         CLI   APKW+1,$AUTHTSF     Check For \"AUTHTSF\" Keyword\n         BE    LWA02300            B. If Yes\n         CLI   E2KW+1,$AUTHCMD     Check For \"AUTHCMD\" Keyword\n         BE    LWA02300            B. If Yes\n         CLI   E8KW+1,$AUTHPGM     Check For \"AUTHPGM\" Keyword\n         BE    LWA02300            B. If Yes\n         CLI   NSKW+1,$NOTBKGND    Check For \"NOTBKGND\" Keyword\n         BE    LWA02300            B. If Yes\n         MVI   APKW+1,$AUTHTSF\n         MVI   E2KW+1,$AUTHCMD\n         MVI   E8KW+1,$AUTHPGM     Default to \"LWATMGR RELOAD ALL\"\n         MVI   NSKW+1,$NOTBKGND\n\n*-------\n*        Allocate & Open The Specified \"LOADLIB\" Library\n*-------\nLWA02300 DS    0H\n         ICM   R1,15,LOADLIB       A(Fully Qualified Data Set Name)\n         BZ    LWA02800            B. If Not Available\n         LH    R2,LOADLIB+4        L(Fully Qualified Data Set Name)\n\n         LA    R0,WRKDDN           A(DDName Buffer)\n         ST    R0,WRKDDPDE\n         LHI   R0,8                L(DDName Buffer)\n         STH   R0,WRKDDPDE+4\n         MVC   WRKDDN,BLANKS       Initialize DDName\n\n         LA    R0,WRKDSN           A(Quoted Data Set Name Area)\n         ST    R0,WRKDSPDE\n         MVC   WRKDSN,BLANKS\n         MVI   WRKDSN,C''''        Insert Leading Quote\n         #EXEC -R2,MVC,WRKDSN+1(*-*),0(R1)\n         LA    R1,WRKDSN+1+1(R2)   A(End Of Data Set Name)\n         MVI   0(R1),C''''         Insert Ending Quote\n         AHI   R1,1                A(End Of Data Set Name)\n         LA    R2,WRKDSN           A(Start Of Data Set Name)\n         SR    R1,R2               Calculate Length Of Data Set Name\n         STH   R1,WRKDSPDE+4       Save Quoted Data Set Name Length\n\n         ICM   R1,15,LOADLIB+8     A(Member Name)\n         BNZ   LWA02900            B. If Member Specified (Not Allowed)\n\n         ALLOC DSN=WRKDSPDE,DISP=SHR,                                  *\n               DDNTO=WRKDDN,                                           *\n               ERROR=LWA03000\n\n*-------\n*        Acquire An Initial Buffer To Contain The Loaded Module\n*-------\n         LHI   R2,4*1024           L(Directed Load Buffer)\n         GETMAIN RU,LV=(R2),LOC=ANY\n         ST    R1,WRKLOAD@         Save Directed Load Buffer Address\n         ST    R2,WRKLOADL         Save Directed Load Buffer Length\n\n*-------\n*        Load The \"AUTHTSF\" Module & Anchor It Off Of The LWA\n*-------\n         CLI   APKW+1,$AUTHTSF     Check For \"AUTHTSF\" Keyword\n         BNE   LWA02400            B. If Not\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHTSF '\n         MVC   WRKTABNL,=AL2(8)\n         MVC   WRKTABNM,=C'IKJEFTAP'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         MVI   WRKVFLGS,LWATAPLD   Set \"Loaded\" Flag\n\n         MVC   WRKTAB@@,WRKTAPP@   Set Table Pointer Address\n         L     R15,WRKTAB@@\n         MVC   WRKTAB@,0(R15)      Set Table Address\n         MVC   WRKTABL@,WRKTAPL@   Set Table Length Address\n         L     R15,WRKTABL@\n         MVC   WRKTABL,0(R15)      Set Table Length\n\n         #CALL LOADIT              Load The Table\n\n*-------\n*        Load The \"AUTHCMD\" Module & Anchor It Off Of The LWA\n*-------\nLWA02400 DS    0H\n         CLI   E2KW+1,$AUTHCMD     Check For \"AUTHCMD\" Keyword\n         BNE   LWA02500            B. If Not\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHCMD '\n         MVC   WRKTABNL,=AL2(8)\n         MVC   WRKTABNM,=C'IKJEFTE2'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         MVI   WRKVFLGS,LWATE2LD   Set \"Loaded\" Flag\n\n         MVC   WRKTAB@@,WRKTE2P@   Set Table Pointer Address\n         L     R15,WRKTAB@@\n         MVC   WRKTAB@,0(R15)      Set Table Address\n         MVC   WRKTABL@,WRKTE2L@   Set Table Length Address\n         L     R15,WRKTABL@\n         MVC   WRKTABL,0(R15)      Set Table Length\n\n         #CALL LOADIT              Load The Table\n\n*-------\n*        Load The \"AUTHPGM\" Module & Anchor It Off Of The LWA\n*-------\nLWA02500 DS    0H\n         CLI   E8KW+1,$AUTHPGM     Check For \"AUTHPGM\" Keyword\n         BNE   LWA02600            B. If Not\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHPGM '\n         MVC   WRKTABNL,=AL2(8)\n         MVC   WRKTABNM,=C'IKJEFTE8'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         MVI   WRKVFLGS,LWATE8LD   Set \"Loaded\" Flag\n\n         MVC   WRKTAB@@,WRKTE8P@   Set Table Pointer Address\n         L     R15,WRKTAB@@\n         MVC   WRKTAB@,0(R15)      Set Table Address\n         MVC   WRKTABL@,WRKTE8L@   Set Table Length Address\n         L     R15,WRKTABL@\n         MVC   WRKTABL,0(R15)      Set Table Length\n\n         #CALL LOADIT              Load The Table\n\n*-------\n*        Load The \"NOTBKGND\" Module & Anchor It Off Of The LWA\n*-------\nLWA02600 DS    0H\n         CLI   NSKW+1,$NOTBKGND    Check For \"NOTBKGND\" Keyword\n         BNE   LWA02700            B. If Not\n         MVC   WRKCMDNL,=AL2(8)\n         MVC   WRKCMDNM,=C'NOTBKGND'\n         MVC   WRKTABNL,=AL2(8)\n         MVC   WRKTABNM,=C'IKJEFTNS'\n         MVC   WRKTABEL,=AL2(10)   Set Table Entry Length\n         MVI   WRKVFLGS,LWATNSLD   Set \"Loaded\" Flag\n\n         MVC   WRKTAB@@,WRKTNSP@   Set Table Pointer Address\n         L     R15,WRKTAB@@\n         MVC   WRKTAB@,0(R15)      Set Table Address\n         MVC   WRKTABL@,WRKTNSL@   Set Table Length Address\n         L     R15,WRKTABL@\n         MVC   WRKTABL,0(R15)      Set Table Length\n\n         #CALL LOADIT              Load The Table\n\n*-------\n*        Free The \"LOADLIB\" Library\n*-------\nLWA02700 DS    0H\n         FREE  DDN=WRKDDPDE        Free Any Allocated Data Set\n         B     LWAEXIT\n\n*-------\n*        Issue Error Messages\n*-------\nLWA02800 DS    0H\n         LHI   R0,1                Message Contains 1 Segment\n         L     R1,=A(#MSG015)      A(Required Keyword Missing)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\n         LHI   R15,8               Set Return Code\n         B     LWAEXIT\n\nLWA02900 DS    0H\n         LHI   R0,1                Message Contains 1 Segments\n         L     R1,=A(#MSG016)      A(Member Not Allowed)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\n         LHI   R15,8               Set Return Code\n         B     LWAEXIT\n\nLWA03000 DS    0H\n         S99FAIL ,                 Issue Dynamic Allocation Error\n\n         LHI   R15,8               Set Return Code\n         B     LWAEXIT\n\nLWA03100 DS    0H\n         LHI   R0,1                Message Contains 1 Segments\n         L     R1,=A(#MSG017)      A(OPEN Failed)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\n         LHI   R15,8               Set Return Code\n         B     LWAEXIT\n         EJECT 1\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Replace An Entry In The Specified Table                      *\n*        - Change an entry in one of the authorization tables.        *\n*                                                                     *\n*     Syntax:                                                         *\n*        LWATMGR REPLACE                                              *\n*              { AUTHTSF  | AUTHCMD  | AUTHPGM  | NOTBKGND }          *\n*                NAME(command/program)                                *\n*                NEWNAME(command/program)                             *\n*                                                                     *\n*---------------------------------------------------------------------*\nLWA03200 DS    0H\n         CLI   FUNCKW+1,$REPLACE   Check For 'REPLACE' Keyword\n         BNE   LWA03500            B. If Not\n\n         #CALL CHECKTAB            Check If A Table Was Specified\n         BNZ   LWAEXIT             B. If Not\n\n         MVC   WRKINS1(4),=AL2(4+4,#MSG0061)\n         MVC   WRKINS1+4(8),=C'NAME    '\n         LA    R1,NAME             A(Keyword)\n         #CALL SAVEKW              Check For \"NAME\" Keyword\n         BZ    LWAEXIT             B. If Not Specified\n         MVC   WRKNAMEL,WRKDATAL   Save \"NAME\" Value Length\n         MVC   WRKNAME,WRKDATA     Save \"NAME\" Value\n\n         OI    WRKFLAG,$MSG_NF     Issue \"Not Found\" Message\n         #CALL FINDNAME            Find The Table Entry's Address\n         BZ    LWAEXIT             B. If Entry Not Found\n\n         MVC   WRKINS1(4),=AL2(4+7,#MSG0061)\n         MVC   WRKINS1+4(8),=C'NEWNAME '\n         LA    R1,NEWNAME          A(Keyword)\n         #CALL SAVEKW              Check For \"NAME\" Keyword\n         BZ    LWAEXIT             B. If Not Specified\n         MVC   WRKNEWNL,WRKDATAL   Save \"NAME\" Value Length\n         MVC   WRKNEWN,WRKDATA     Save \"NAME\" Value\n\n         MVC   WRKTMPNL,WRKNAMEL   Save Name Length\n         MVC   WRKTMPN,WRKNAME     Save Name\n\n         MVI   APKW+1,0            Reset\n         MVI   E2KW+1,0             Table Keywords\n         MVI   E8KW+1,0              To Only\n         MVI   NSKW+1,0               The One\n         L     R15,WRKKW@              Where \"NAME\" Entry\n         MVI   1(R15),1                 Was Found\n\n         MVC   WRKNAMEL,WRKNEWNL   Change To \"NEWNAME\" Value Length\n         MVC   WRKNAME,WRKNEWN     Change To \"NEWNAME\" Value\n         OI    WRKFLAG,$MSG_F      Issue \"Found\" Message\n         #CALL FINDNAME            Find The Table Entry's Address\n         BNZ   LWAEXIT             B. If Entry Not Found\n\n         MVC   WRKNAMEL,WRKTMPNL   Restore Name Length\n         MVC   WRKNAME,WRKTMPN     Restore Name\n\n         #CALL COPYTAB             Ensure Table Is In Our Address Space\n         BZ    LWAEXIT             B. If Table Does Not Exist\n\n         L     R5,WRKTAB@          A(Current Table)\n         A     R5,WRKNAMEO         A(Current Table Entry)\n\n         CLC   WRKTABEL,=AL2(8)    Check For Normal Table Entry\n         BNE   LWA03300            B. If Not\n         #CALL AUTH                Get Into Supervisor State, Key Zero\n         BNZ   LWAEXIT             B. If Not Authorized\n         MVC   0(8,R5),WRKNEWN     Overlay With New Entry Name\n         #CALL DEAUTH              Return To Original State & Key\n         B     LWA03400\n\nLWA03300 DS    0H\n         #CALL AUTH                Get Into Supervisor State, Key Zero\n         BNZ   LWAEXIT             B. If Not Authorized\n         MVC   0(2,R5),WRKNEWNL    Overlay With New Entry Name Length\n         MVC   2(8,R5),WRKNEWN     Overlay With New Entry Name\n         #CALL DEAUTH              Return To Original State & Key\n\nLWA03400 DS    0H\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0041)\n         LH    R0,WRKNAMEL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         MVC   WRKINS1+4(8),WRKNAME\n         MVC   WRKINS2(4),=AL2(4+*-*,#MSG0042)\n         LH    R0,WRKNEWNL\n         AHI   R0,4\n         STH   R0,WRKINS2\n         MVC   WRKINS2+4(8),WRKNEWN\n         MVC   WRKINS3(4),=AL2(4+*-*,#MSG0043)\n         LH    R0,WRKCMDNL\n         AHI   R0,4\n         STH   R0,WRKINS3\n         MVC   WRKINS3+4(8),WRKCMDNM\n\n         LHI   R0,4                Message Contains 4 Segments\n         L     R1,=A(#MSG004)      A(Replacement Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         LA    R3,WRKINS2          A(Insert #2)\n         LA    R4,WRKINS3          A(Insert #3)\n         #CALL PUTLINE             Write Message\n         B     LWAEXIT\n         EJECT 1\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Replace The Tables With IKJTSOxx Input Data                  *\n*        - Validate an IKJTSOxx member and load any/all tables.       *\n*                                                                     *\n*     Syntax:                                                         *\n*        LWATMGR UPDATE                                               *\n*              { AUTHTSF  | AUTHCMD  | AUTHPGM  | NOTBKGND | ALL }    *\n*                PARMLIB(dataset(member))                             *\n*                                                                     *\n*---------------------------------------------------------------------*\nLWA03500 DS    0H\n         CLI   FUNCKW+1,$UPDATE    Check For 'UPDATE' Keyword\n         BNE   LWA03900            B. If Not\n\n         #CALL CHECKTAB            Check If A Table Was Specified\n         BNZ   LWAEXIT             B. If Not\n\n         #CALL READPARM            Read The Specified Parmlib Member\n\n*-------\n*        Update 'IKJEFTAP' Table If Requested\n*-------\n         CLI   APKW+1,$AUTHTSF     Check For 'AUTHTSF' Keyword\n         BNE   LWA03600            B. If Not\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHTSF '\n         #CALL BUILDCMD            Build CBUF From PARMLIB Section\n         BNZ   LWA03600            B. If Section Not Found\n\n         LA    R1,WRKPPL           A(Parse Parameter List)\n         USING PPL,R1\n         XC    WRKECB,WRKECB\n         L     R0,=A(PARMPCL)      A(Parse Command List)\n         ST    R0,PPLPCL           Save PCL Address\n         MVC   PPLCBUF,WRKCBUF@    Copy Command Buffer Address\n         LA    R0,WRKPDL2\n         ST    R0,PPLANS           Save PDL Address\n         DROP  R1\n\n         CALLTSSR EP=IKJPARS,      Invoke Parse Routine                *\n               MF=(E,WRKPPL)\n         LTR   R15,R15             Check Parse Return Code\n         BNZ   LWAEXIT             B. If Command Syntax Error\n\n         MVC   WRKTABNM,=C'IKJEFTAP'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         #CALL BUILDTAB            Build Replacement Table\n         BNZ   LWAEXIT             B. If Table Construction Failed\n\n         MVC   WRKTAB@@,WRKTAPP@   Set Table Pointer Address\n         MVC   WRKTABL@,WRKTAPL@   Set Table Length Address\n         MVC   WRKTABL,WRKTAPL     Set Length Found in LWA\n         MVC   WRKTABF,WRKTAPF     Set Table Flag\n         OI    WRKPRMLB,LWATAPST   Set \"Came From //STEPLIB\" Flag\n         MVI   WRKVFLGS,LWATAPLD   Set \"Loaded\" Flag\n         #CALL REPTABLE            Replace The Table With A New One\n         BNZ   LWAEXIT             B. If Replace Failed\n\n         IKJRLSA WRKPDL2           Release The Parse Storage\n         XC    WRKPDL2,WRKPDL2\n\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0141)\n         MVC   WRKINS1+4(8),WRKCMDNM\n         LH    R0,WRKCMDNL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         LHI   R0,2                Message Contains 2 Segments\n         L     R1,=A(#MSG014)      A(Section Updated From Parmlib)\n         LA    R2,WRKINS1          A(Insert #1)\n         #CALL PUTLINE             Write Message\n\n*-------\n*        Update 'IKJEFTE2' Table If Requested\n*-------\nLWA03600 DS    0H\n         CLI   E2KW+1,$AUTHCMD     Check For 'AUTHCMD' Keyword\n         BNE   LWA03700            B. If Not\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHCMD '\n         #CALL BUILDCMD            Build CBUF From PARMLIB Section\n         BNZ   LWA03700            B. If Section Not Found\n\n         LA    R1,WRKPPL           A(Parse Parameter List)\n         USING PPL,R1\n         XC    WRKECB,WRKECB\n         L     R0,=A(PARMPCL)      A(Parse Command List)\n         ST    R0,PPLPCL           Save PCL Address\n         MVC   PPLCBUF,WRKCBUF@    Copy Command Buffer Address\n         LA    R0,WRKPDL2\n         ST    R0,PPLANS           Save PDL Address\n         DROP  R1\n\n         CALLTSSR EP=IKJPARS,      Invoke Parse Routine                *\n               MF=(E,WRKPPL)\n         LTR   R15,R15             Check Parse Return Code\n         BNZ   LWAEXIT             B. If Command Syntax Error\n\n         MVC   WRKTABNM,=C'IKJEFTE2'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         #CALL BUILDTAB            Build Replacement Table\n         BNZ   LWAEXIT             B. If Table Construction Failed\n\n         MVC   WRKTAB@@,WRKTE2P@   Set Table Pointer Address\n         MVC   WRKTABL@,WRKTE2L@   Set Table Length Address\n         MVC   WRKTABL,WRKTE2L     Set Length Found in LWA\n         MVC   WRKTABF,WRKTE2F     Set Table Flag\n         OI    WRKPRMLB,LWATE2ST   Set \"Came From //STEPLIB\" Flag\n         MVI   WRKVFLGS,LWATE2LD   Set \"Loaded\" Flag\n         #CALL REPTABLE            Replace The Table With A New One\n         BNZ   LWAEXIT             B. If Replace Failed\n\n         IKJRLSA WRKPDL2           Release The Parse Storage\n         XC    WRKPDL2,WRKPDL2\n\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0141)\n         MVC   WRKINS1+4(8),WRKCMDNM\n         LH    R0,WRKCMDNL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         LHI   R0,2                Message Contains 2 Segments\n         L     R1,=A(#MSG014)      A(Section Updated From Parmlib)\n         LA    R2,WRKINS1          A(Insert #1)\n         #CALL PUTLINE             Write Message\n\n*-------\n*        Update 'IKJEFTE8' Table If Requested\n*-------\nLWA03700 DS    0H\n         CLI   E8KW+1,$AUTHPGM     Check For 'AUTHPGM' Keyword\n         BNE   LWA03800            B. If Not\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHPGM '\n         #CALL BUILDCMD            Build CBUF From PARMLIB Section\n         BNZ   LWA03800            B. If Section Not Found\n\n         LA    R1,WRKPPL           A(Parse Parameter List)\n         USING PPL,R1\n         XC    WRKECB,WRKECB\n         L     R0,=A(PARMPCL)      A(Parse Command List)\n         ST    R0,PPLPCL           Save PCL Address\n         MVC   PPLCBUF,WRKCBUF@    Copy Command Buffer Address\n         LA    R0,WRKPDL2\n         ST    R0,PPLANS           Save PDL Address\n         DROP  R1\n\n         CALLTSSR EP=IKJPARS,      Invoke Parse Routine                *\n               MF=(E,WRKPPL)\n         LTR   R15,R15             Check Parse Return Code\n         BNZ   LWAEXIT             B. If Command Syntax Error\n\n         MVC   WRKTABNM,=C'IKJEFTE8'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         #CALL BUILDTAB            Build Replacement Table\n         BNZ   LWAEXIT             B. If Table Construction Failed\n\n         MVC   WRKTAB@@,WRKTE8P@   Set Table Pointer Address\n         MVC   WRKTABL@,WRKTE8L@   Set Table Length Address\n         MVC   WRKTABL,WRKTE8L     Set Length Found in LWA\n         MVC   WRKTABF,WRKTE8F     Set Table Flag\n         OI    WRKPRMLB,LWATE8ST   Set \"Came From //STEPLIB\" Flag\n         MVI   WRKVFLGS,LWATE8LD   Set \"Loaded\" Flag\n         #CALL REPTABLE            Replace The Table With A New One\n         BNZ   LWAEXIT             B. If Replace Failed\n\n         IKJRLSA WRKPDL2           Release The Parse Storage\n         XC    WRKPDL2,WRKPDL2\n\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0141)\n         MVC   WRKINS1+4(8),WRKCMDNM\n         LH    R0,WRKCMDNL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         LHI   R0,2                Message Contains 2 Segments\n         L     R1,=A(#MSG014)      A(Section Updated From Parmlib)\n         LA    R2,WRKINS1          A(Insert #1)\n         #CALL PUTLINE             Write Message\n\n*-------\n*        Update 'IKJEFTNS' Table If Requested\n*-------\nLWA03800 DS    0H\n         CLI   NSKW+1,$NOTBKGND    Check For 'NOTBKGND' Keyword\n         BNE   LWAEXIT             B. If Not\n         MVC   WRKCMDNL,=AL2(8)\n         MVC   WRKCMDNM,=C'NOTBKGND'\n         #CALL BUILDCMD            Build CBUF From PARMLIB Section\n         BNZ   LWAEXIT             B. If Section Not Found\n\n         LA    R1,WRKPPL           A(Parse Parameter List)\n         USING PPL,R1\n         XC    WRKECB,WRKECB\n         L     R0,=A(PARMPCL)      A(Parse Command List)\n         ST    R0,PPLPCL           Save PCL Address\n         MVC   PPLCBUF,WRKCBUF@    Copy Command Buffer Address\n         LA    R0,WRKPDL2\n         ST    R0,PPLANS           Save PDL Address\n         DROP  R1\n\n         CALLTSSR EP=IKJPARS,      Invoke Parse Routine                *\n               MF=(E,WRKPPL)\n         LTR   R15,R15             Check Parse Return Code\n         BNZ   LWAEXIT             B. If Command Syntax Error\n\n         MVC   WRKTABNM,=C'IKJEFTNS'\n         MVC   WRKTABEL,=AL2(10)   Set Table Entry Length\n         #CALL BUILDTAB            Build Replacement Table\n         BNZ   LWAEXIT             B. If Table Construction Failed\n\n         MVC   WRKTAB@@,WRKTNSP@   Set Table Pointer Address\n         MVC   WRKTABL@,WRKTNSL@   Set Table Length Address\n         MVC   WRKTABL,WRKTNSL     Set Length Found in LWA\n         MVC   WRKTABF,WRKTNSF     Set Table Flag\n         OI    WRKPRMLB,LWATNSST   Set \"Came From //STEPLIB\" Flag\n         MVI   WRKVFLGS,LWATNSLD   Set \"Loaded\" Flag\n         #CALL REPTABLE            Replace The Table With A New One\n         BNZ   LWAEXIT             B. If Replace Failed\n\n         IKJRLSA WRKPDL2           Release The Parse Storage\n         XC    WRKPDL2,WRKPDL2\n\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0141)\n         MVC   WRKINS1+4(8),WRKCMDNM\n         LH    R0,WRKCMDNL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         LHI   R0,2                Message Contains 2 Segments\n         L     R1,=A(#MSG014)      A(Section Updated From Parmlib)\n         LA    R2,WRKINS1          A(Insert #1)\n         #CALL PUTLINE             Write Message\n         B     LWAEXIT\n         EJECT 1\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Replace The Tables With 8 Character List Data                *\n*        - Rebuild tables With 8 Byte Name List structure.            *\n*        - Note: The List contains \"--name--\" to identify which table.*\n*                                                                     *\n*     Syntax:                                                         *\n*        LWATMGR BUILD                                                *\n*                LIST(dataset\u00dd(member)\u00a8)                              *\n*                                                                     *\n*---------------------------------------------------------------------*\nLWA03900 DS    0H\n         CLI   FUNCKW+1,$BUILD     Check For 'BUILD' Keyword\n         BNE   LWAEXIT             B. If Not\n\n         CLI   APKW+1,$AUTHTSF     Check For \"AUTHTSF\" Keyword\n         BE    LWA04000            B. If Yes\n         CLI   E2KW+1,$AUTHCMD     Check For \"AUTHCMD\" Keyword\n         BE    LWA04000            B. If Yes\n         CLI   E8KW+1,$AUTHPGM     Check For \"AUTHPGM\" Keyword\n         BE    LWA04000            B. If Yes\n         CLI   NSKW+1,$NOTBKGND    Check For \"NOTBKGND\" Keyword\n         BE    LWA04000            B. If Yes\n         MVI   APKW+1,$AUTHTSF\n         MVI   E2KW+1,$AUTHCMD\n         MVI   E8KW+1,$AUTHPGM     Default to \"LWATMGR BUILD ALL\"\n         MVI   NSKW+1,$NOTBKGND\n\nLWA04000 DS    0H\n         ICM   R1,15,REC8          A(Fully Qualified Data Set Name)\n         BZ    LWA02800            B. If Not Available\n         LH    R2,REC8+4           L(Fully Qualified Data Set Name)\n\n*-------\n*        Allocate The Input Library\n*        - As we only use the 1st 8 bytes, the LRECL of the input file\n*          can be anything as low as 8.\n*          Anything after the 1st 8 bytes is disreguarded.\n*-------\n         LA    R0,WRKDDN           A(DDName Buffer)\n         ST    R0,WRKDDPDE\n         LHI   R0,8                L(DDName Buffer)\n         STH   R0,WRKDDPDE+4\n         MVC   WRKDDN,BLANKS       Initialize DDName\n\n         LA    R0,WRKDSN           A(Quoted Data Set Name Area)\n         ST    R0,WRKDSPDE\n         MVC   WRKDSN,BLANKS\n         MVI   WRKDSN,C''''        Insert Leading Quote\n         #EXEC -R2,MVC,WRKDSN+1(*-*),0(R1)\n         LA    R1,WRKDSN+1+1(R2)   A(End Of Data Set Name)\n         MVI   0(R1),C''''         Insert Ending Quote\n         AHI   R1,1                A(End Of Data Set Name)\n         LA    R2,WRKDSN           A(Start Of Data Set Name)\n         SR    R1,R2               Calculate Length Of Data Set Name\n         STH   R1,WRKDSPDE+4       Save Quoted Data Set Name Length\n\n         XC    WRKMNPDE(6),WRKMNPDE\n         MVC   WRKMEMNM,BLANKS\n         ICM   R1,15,REC8+8        A(Member Name)\n         BZ    LWA04100            B. If Not Available\n         LA    R0,WRKMEMNM         A(Member Name)\n         ST    R0,WRKMNPDE\n         LHI   R0,8                L(Member Name)\n         STH   R0,WRKMNPDE+4\n         LH    R2,REC8+12          L(Member Name)\n         #EXEC -R2,MVC,WRKMEMNM(*-*),0(R1)\n\nLWA04100 DS    0H\n         ALLOC DSN=WRKDSPDE,DISP=SHR,                                  *\n               MEMBER=WRKMNPDE,                                        *\n               DDNTO=WRKDDN,                                           *\n               ERROR=LWA03000\n\n         L     R14,=A(OPENSTUB)    A(24-Bit Exit Routine)\n         MVC   WDCBEXIT,0(R14)     Initialize Exit Stub\n         L     R14,=A(DCBEXIT)     A(31-Bit Exit Routine)\n         BSM   R14,0               Set Current AMode\n         STCM  R14,15,REAL@-OPENSTUB+WDCBEXIT\n         LA    R0,WDCBEXIT         A(24-Bit Exit Stub)\n         ST    R0,DCBEXIT@         Store In Exlst Plist\n         MVI   DCBEXIT@,X'85'      Open Exit Is Last In List\n\n         L     R15,=A(MODCBF)\n         MVC   WRKDCB,0(R15)       Copy DCB To Work Area\n         MVC   DCBDDNAM-IHADCB+WRKDCB,WRKDDN\n         L     R15,=A(MODCBEF)\n         MVC   WRKDCBE,0(R15)      Copy DCBE To Work Area\n         LA    R15,WRKDCBE         A(DCBE)\n         ST    R15,DCBDCBE-IHADCB+WRKDCB\n\n         L     R15,=A(MODOPEN)\n         MVC   WRKOPEN,0(R15)\n         OPEN  (WRKDCB),           Open The \"LIST\" Data Set            *\n               MF=(E,WRKOPEN)\n         TM    DCBOFLGS-IHADCB+WRKDCB,DCBOFOPN\n         BZ    LWA03100            B. If OPEN Failed\n\n*-------\n*        Read The \"List\" Into Storage.\n*-------\n         L     R4,WRKMSGB@         A(Start Of Data Buffer)\n         LR    R1,R4\n         A     R1,WRKMSGBL         A(End Of Data Buffer)\n         ST    R1,WRKMSGBE         Save End Address\nLWA04200 DS    0H\n         GET   WRKDCB              Get Next Record From LIST Data Set\n\n         TM    0(R1),X'BF'         Check For Blank/Null 1st Character\n         BE    LWA04200            B. If Yes\n         C     R4,WRKMSGBE         Check For End Of Buffer\n         BNE   LWA04300            B. If Not\n\n         LR    R5,R1               Save Current Record Address\n         LR    R6,R4               A(Logical End Of Current Buffer)\n\n         L     R4,WRKMSGB@         A(Start Of Data Buffer)\n         L     R3,WRKMSGBL         L(Current Data Buffer)\n         SR    R6,R4               Calculate Used Data Buffer Length\n\n         L     R2,WRKMSGBL         L(Current Data Buffer)\n         SLL   R2,1                Double The Length\n         GETMAIN RU,LV=(R2),LOC=ANY\n         ST    R1,WRKMSGB@         Save New Buffer Address\n         ST    R2,WRKMSGBL         Save New Buffer Length\n\n         #MVCL (R1),(R4),LEN=(R6)  Copy The Previous Used Portion\n\n         FREEMAIN RU,A=(R4),LV=(R3)  Free The Old Data Buffer\n\n         L     R4,WRKMSGB@\n         LR    R1,R4\n         A     R1,WRKMSGBL         A(End Of Data Buffer)\n         ST    R1,WRKMSGBE         Save End Address\n         AR    R4,R6               A(End Of Used Portion Of Buffer)\n\n         LR    R1,R5               Restore Current Record Address\n\nLWA04300 DS    0H\n         MVC   0(8,R4),0(R1)       Copy The Current Record's Entry\n         LA    R4,8(,R4)           A(Next Slot In Data Buffer)\n         B     LWA04200            Read Until End Of File\n\nLWA04400 DS    0H\n         ST    R4,WRKMSGBE         Save Logical End Of Buffer Address\n\n         L     R15,=A(MODCLOSE)\n         MVC   WRKCLOSE,0(R15)\n         CLOSE (WRKDCB),           Close The \"LIST\" Data Set           *\n               MF=(E,WRKCLOSE)\n\n         FREE  DDN=WRKDDPDE        Free Any Allocated Data Set\n\n*-------\n*        Process 'IKJEFTAP' List If Requested\n*-------\n         CLI   APKW+1,$AUTHTSF     Check For \"AUTHTSF\" Keyword\n         BNE   LWA04500            B. If Not\n\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHTSF '\n         MVC   WRKTABNL,=AL2(8)\n         MVC   WRKTABNM,=C'IKJEFTAP'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         MVC   WRKNAME,=C'---AP---'\n         #CALL LISTTAB             Create Table From LIST\n         BNZ   LWA04500            B. If LIST Not Created\n\n         MVC   WRKTAB@@,WRKTAPP@   Set Table Pointer Address\n         MVC   WRKTABL@,WRKTAPL@   Set Table Length Address\n         MVC   WRKTABL,WRKTAPL     Set Length Found in LWA\n         OI    WRKPRMLB,LWATAPST   Set \"Came From //STEPLIB\" Flag\n         MVI   WRKVFLGS,LWATAPLD   Set \"Loaded\" Flag\n         #CALL REPTABLE            Replace The Table With A New One\n         BNZ   LWAEXIT             B. If Replace Failed\n\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0211)\n         MVC   WRKINS1+4(8),WRKCMDNM\n         LH    R0,WRKCMDNL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         LHI   R0,2                Message Contains 2 Segments\n         L     R1,=A(#MSG021)      A(Section Updated From Parmlib)\n         LA    R2,WRKINS1          A(Insert #1)\n         #CALL PUTLINE             Write Message\n\n*-------\n*        Process 'IKJEFE2P' List If Requested\n*-------\nLWA04500 DS    0H\n         CLI   E2KW+1,$AUTHCMD     Check For \"AUTHCMD\" Keyword\n         BNE   LWA04600            B. If Not\n\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHCMD '\n         MVC   WRKTABNL,=AL2(8)\n         MVC   WRKTABNM,=C'IKJEFTE2'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         MVC   WRKNAME,=C'---E2---'\n         #CALL LISTTAB             Create Table From LIST\n         BNZ   LWA04600            B. If LIST Not Created\n\n         MVC   WRKTAB@@,WRKTE2P@   Set Table Pointer Address\n         MVC   WRKTABL@,WRKTE2L@   Set Table Length Address\n         MVC   WRKTABL,WRKTE2L     Set Length Found in LWA\n         OI    WRKPRMLB,LWATE2ST   Set \"Came From //STEPLIB\" Flag\n         MVI   WRKVFLGS,LWATE2LD   Set \"Loaded\" Flag\n         #CALL REPTABLE            Replace The Table With A New One\n         BNZ   LWAEXIT             B. If Replace Failed\n\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0211)\n         MVC   WRKINS1+4(8),WRKCMDNM\n         LH    R0,WRKCMDNL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         LHI   R0,2                Message Contains 2 Segments\n         L     R1,=A(#MSG021)      A(Section Updated From Parmlib)\n         LA    R2,WRKINS1          A(Insert #1)\n         #CALL PUTLINE             Write Message\n\n*-------\n*        Process 'IKJEFE8P' List If Requested\n*-------\nLWA04600 DS    0H\n         CLI   E8KW+1,$AUTHPGM     Check For \"AUTHPGM\" Keyword\n         BNE   LWA04700            B. If Not\n\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHPGM '\n         MVC   WRKTABNL,=AL2(8)\n         MVC   WRKTABNM,=C'IKJEFTE8'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         MVC   WRKNAME,=C'---E8---'\n         #CALL LISTTAB             Create Table From LIST\n         BNZ   LWA04700            B. If LIST Not Created\n\n         MVC   WRKTAB@@,WRKTE8P@   Set Table Pointer Address\n         MVC   WRKTABL@,WRKTE8L@   Set Table Length Address\n         MVC   WRKTABL,WRKTE8L     Set Length Found in LWA\n         OI    WRKPRMLB,LWATE8ST   Set \"Came From //STEPLIB\" Flag\n         MVI   WRKVFLGS,LWATE8LD   Set \"Loaded\" Flag\n         #CALL REPTABLE            Replace The Table With A New One\n         BNZ   LWAEXIT             B. If Replace Failed\n\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0211)\n         MVC   WRKINS1+4(8),WRKCMDNM\n         LH    R0,WRKCMDNL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         LHI   R0,2                Message Contains 2 Segments\n         L     R1,=A(#MSG021)      A(Section Updated From Parmlib)\n         LA    R2,WRKINS1          A(Insert #1)\n         #CALL PUTLINE             Write Message\n\n*-------\n*        Process 'IKJEFNSP' List If Requested\n*-------\nLWA04700 DS    0H\n         CLI   NSKW+1,$NOTBKGND    Check For \"NOTBKGND\" Keyword\n         BNE   LWAEXIT             B. If Not\n\n         MVC   WRKCMDNL,=AL2(8)\n         MVC   WRKCMDNM,=C'NOTBKGND'\n         MVC   WRKTABNL,=AL2(8)\n         MVC   WRKTABNM,=C'IKJEFTNS'\n         MVC   WRKTABEL,=AL2(10)   Set Table Entry Length\n         MVC   WRKNAME,=C'---NS---'\n         #CALL LISTTAB             Create Table From LIST\n         BNZ   LWAEXIT             B. If LIST Not Created\n\n         MVC   WRKTAB@@,WRKTNSP@   Set Table Pointer Address\n         MVC   WRKTABL@,WRKTNSL@   Set Table Length Address\n         MVC   WRKTABL,WRKTNSL     Set Length Found in LWA\n         OI    WRKPRMLB,LWATNSST   Set \"Came From //STEPLIB\" Flag\n         MVI   WRKVFLGS,LWATNSLD   Set \"Loaded\" Flag\n         #CALL REPTABLE            Replace The Table With A New One\n         BNZ   LWAEXIT             B. If Replace Failed\n\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0211)\n         MVC   WRKINS1+4(8),WRKCMDNM\n         LH    R0,WRKCMDNL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         LHI   R0,2                Message Contains 2 Segments\n         L     R1,=A(#MSG021)      A(Section Updated From Parmlib)\n         LA    R2,WRKINS1          A(Insert #1)\n         #CALL PUTLINE             Write Message\n         B     LWAEXIT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Terminate                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\nLWAEXIT  DS    0H\n         #CALL CLEANUP             Free All Acquired Storage\n\n         #STOP ,                   Terminate\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Constants                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LTORG ,                   Literal Pool\n         #EXEC ,                   Executed Statements\n\nMODCBU   DCB   DDNAME=*,DSORG=PO,RECFM=U,MACRF=R,BUFNO=1,              *\n               DCBE=*-*\nMODCBUL  EQU   *-MODCBU            DCB Parameter List Length\nMODCBEU  DCBE  EODAD=LOAD0900,SYNAD=LOADSYN\nMODCBEUL EQU   *-MODCBEU           DCBE Parameter List Length\n\nMODCBF   DCB   DDNAME=*,DSORG=PS,RECFM=FB,MACRF=GL,                    *\n               DCBE=*-*\nMODCBFL  EQU   *-MODCBF            DCB Parameter List Length\nMODCBEF  DCBE  EODAD=LWA04400\nMODCBEFL EQU   *-MODCBEF           DCBE Parameter List Length\n\nMODOPEN  OPEN  *-*,MF=L\nMODOPENL EQU   *-MODOPEN           OPEN Parameter List Length\n\nMODCLOSE CLOSE *-*,MF=L\nMODCLOSEL EQU  *-MODCLOSE          CLOSE Parameter List Length\n\nMODLOAD  LOAD  SF=L\nMODLOADL EQU   *-MODLOAD           LOAD Parameter List Length\n\n#MSG001  DC    C'LWA001I LWA control block is not valid'\n#MSG001L EQU   *-#MSG001\n\n#MSG002  #MSG  'LWA002I '''' added to '''' table'\n#MSG0021 EQU   9,8                 Insert Offset & Length\n#MSG0022 EQU   21,8                Insert Offset & Length\n\n#MSG003  #MSG  'LWA003I '''' removed from '''' table'\n#MSG0031 EQU   8,8                 Insert Offset & Length\n#MSG0032 EQU   25,8                Insert Offset & Length\n\n#MSG004  #MSG  'LWA004I '''' replaced with '''' in '''' table'\n#MSG0041 EQU   9,8                 Insert Offset & Length\n#MSG0042 EQU   26,8                Insert Offset & Length\n#MSG0043 EQU   32,8                Insert Offset & Length\n\n#MSG005  #MSG  'LWA005I Command Is Not Authorized'\n\n#MSG006  #MSG  'LWA006I '''' Keyword Is Missing'\n#MSG0061 EQU   9,8                 Insert Offset & Length\n\n#MSG007  #MSG  'LWA007I Required Table Keyword Not Specified'\n\n#MSG008  #MSG  'LWA008I  At  Key   '\n#MSG0081 EQU   8,26                Insert Offset & Length\n#MSG0082 EQU   12,8                Insert Offset & Length\n#MSG0083 EQU   17,2                Insert Offset & Length\n#MSG0084 EQU   18,17               Insert Offset & Length\n#MSG0085 EQU   19,7                Insert Offset & Length\n\n#MSG009  #MSG  'LWA009I      '\n#MSG0091 EQU   8,8                 Insert Offset & Length\n#MSG0092 EQU   9,8                 Insert Offset & Length\n#MSG0093 EQU   10,8                Insert Offset & Length\n#MSG0094 EQU   11,8                Insert Offset & Length\n#MSG0095 EQU   12,8                Insert Offset & Length\n#MSG0096 EQU   13,8                Insert Offset & Length\n\n#MSG010  #MSG  'LWA010I '''' already exists in '''' table'\n#MSG0101 EQU   9,8                 Insert Offset & Length\n#MSG0102 EQU   30,8                Insert Offset & Length\n\n#MSG011  #MSG  'LWA011I '''' Not Found'\n#MSG0111 EQU   9,8                 Insert Offset & Length\n\n#MSG012  #MSG  'LWA012I PARMLIB Must Be Specified with a member name'\n\n#MSG013  #MSG  'LWA013I PARMLIB READ failed, RC=X''''  RS=X'''' '\n#MSG0131 EQU   34,8                Insert Offset & Length\n#MSG0132 EQU   42,8                Insert Offset & Length\n\n#MSG014  #MSG  'LWA014I '''' table updated from PARMLIB'\n#MSG0141 EQU   9,8                 Insert Offset & Length\n\n#MSG015  #MSG  'LWA015I LOADLIB Keyword Is Missing'\n\n#MSG016  #MSG  'LWA016I MEMBER name can not be specified'\n\n#MSG017  #MSG  'LWA017I OPEN Failed for '''' '\n#MSG0171 EQU   25,44               Insert Offset & Length\n\n#MSG018  #MSG  'LWA018I '''' LOAD failed, RC=X''''  RS=X'''' '\n#MSG0181 EQU   9,8                 Insert Offset & Length\n#MSG0182 EQU   29,8                Insert Offset & Length\n#MSG0183 EQU   37,8                Insert Offset & Length\n\n#MSG019  #MSG  'LWA019I '''' Table loaded from '\n#MSG0191 EQU   9,8                 Insert Offset & Length\n#MSG0192 EQU   29,8                Insert Offset & Length\n\n#MSG020  #MSG  'LWA020I '''' is not a valid ALIAS in '\n#MSG0201 EQU   9,8                 Insert Offset & Length\n#MSG0202 EQU   35,8                Insert Offset & Length\n\n#MSG021  #MSG  'LWA021I '''' table updated from LIST'\n#MSG0211 EQU   9,8                 Insert Offset & Length\n\n#MSG022  #MSG  'LWA022I This Program Requires An ISPF Environment.  ISP*\n               QRY Return Code  '\n#MSG0221 EQU   71,8                Insert Offset & Length\n\nBLANKLNE #MSG  '          '\nBLANKINS EQU   2,80                Insert Offset & Length\n         EJECT 1\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DCB Open Exit Stub - Copied to Work Area (below the line).   *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\n         DROP  ,\n         USING *,R15\nOPENSTUB DS    0H\n         N     R1,CLEAR1ST         CLEAR HIGH ORDER BYTE\n         ICM   R15,15,REAL@        A(31-BIT EXIT ROUTINE)\n         BSM   0,R15               B. TO 31 BIT CODE\n         DS    0F                  ALIGNMENT\nREAL@    DS    AL4                 A(31-BIT EXIT ROUTINE)\nCLEAR1ST DC    X'00FFFFFF'         CLEAR MASK\nSTUBLEN  EQU   *-OPENSTUB\n         POP   USING\n\nDCBEXIT  #DCBEXIT ,                Real (Amode 31) Exit Routine\n\nFINDBLANK DC   256X'00'\n         ORG   FINDBLANK+C' '\n         DC    C' '                Find First Blank\n         ORG   ,\n\nFINDCHAR DC    AL1(*-FINDCHAR)\n         ORG   FINDCHAR+C' '\n         DC    X'00'               Skip Over Any Blanks\n         ORG   ,\n\nCONVCONT DC    256AL1(*-CONVCONT)\n         ORG   CONVCONT+C'+'\n         DC    C' '                Convert \"+\" To Blanks\n         ORG   CONVCONT+C'-'\n         DC    C' '                Convert \"-\" To Blanks\n         ORG   ,\n\nCONVDASH DC    256AL1(*-CONVDASH)\n         ORG   CONVDASH+C' '\n         DC    C'-'                Convert Blanks To Dashes\n         ORG   ,\n\nHEXTABLE DC    C'0123456789ABCDEF'\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Subroutines                                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Get Into Supervisor State Key Zero                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nAUTH     #SAVE ,                   Save All Registers\n\n         TM    WRKFLAG,$SUPER      Check If Already In Supervisor State\n         BO    AUTH0100            B. If Yes\n         TM    WRKFLAG,$APF        Check If Module Is APF Authorized\n         BZ    AUTH0200            B. If Not (Error)\n\n         MODESET MODE=SUP          Get Into Supervisor State\n         OI    WRKFLAG,$SETSUP     Remember Superviosr State Was Set\n\nAUTH0100 DS    0H\n         IPK   ,\n         STC   R2,WRKOPSWK         Save Original Protect Key\n\n         SPKA  0                   Get Into Key Zero\n         OI    WRKFLAG,$SETKEY0    Remember KEY0 Was Set\n\n         LHI   R15,0               Set Return Code\n         B     AUTHEXIT\n\nAUTH0200 DS    0H\n         LHI   R0,1                Message Contains 1 Segment\n         L     R1,=A(#MSG005)      A(Error Message)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\n         LHI   R15,8               Set Return Code\n\nAUTHEXIT #RESTORE R15=(R15)        Restore All Registers\n\n         LTR   R15,R15             Set Condition Code\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Build Command Buffer From IKJTSOxx Section                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nBUILDCMD #SAVE ,                   Save All Registers\n\n         L     R5,WRKBUFF@         A(Start Of Parmlib Buffer)\n         USING PRM_READ_BUFFER,R5\n         L     R6,PRM_BUFF_SIZE_NEEDED\n         LA    R6,PRM_RECORDS(R6)  A(End Of Parmlib Buffer)\n         LA    R5,PRM_RECORDS      A(1st Parmlib Record)\n         DROP  R5\n\n*-------\n*        Find The Start Of The Requested IKJTSOxx Section\n*-------\nBUIC0100 DS    0H\n         CR    R5,R6               Check For End Of Buffer\n         BNL   BUIC0900            B. If Yes\n\n         L     R15,=A(FINDCHAR)\n         TRT   0(72,R5),0(R15)     Find The 1st Non-Blank\n         BZ    BUIC0700            B. If All Blanks\n\n         CLC   WRKCMDNM,0(R1)      Check For Current Command\n         BE    BUIC0800            B. If Match Found\n\nBUIC0200 DS    0H\n         CLC   0(72,R5),BLANKS     Check For Blank Line\n         BE    BUIC0500            B. If Yes (End Of Command)\n\n         LA    R1,71(,R5)          A(End Of Current Record)\nBUIC0300 DS    0H\n         CLI   0(R1),C' '          Check For Non-Blank\n         BNE   BUIC0400            B. If Found\n         BCT   R1,BUIC0300         Back Up And Loop To Last Non-Blank\n\nBUIC0400 DS    0H\n         CLI   0(R1),C'+'          Check for Continuation Character\n         BE    BUIC0600            B. If Yes\n         CLI   0(R1),C'-'          Check for Continuation Character\n         BE    BUIC0600            B. If Yes\n\nBUIC0500 DS    0H\n         AHI   R5,80               A(Next Record)\n         B     BUIC0100            Keep Searching For Section\n\nBUIC0600 DS    0H\n         AHI   R5,80               A(Next Record)\n         CR    R5,R6               Check For End Of Buffer\n         BL    BUIC0200            B. If Not\n         B     BUIC0100            Keep Searching For Section\n\nBUIC0700 DS    0H\n         AHI   R4,80               A(Next Record)\n         B     BUIC0100            Keep Searching For Section\n\n*-------\n*        Find The End Of The Requested IKJTSOxx Section\n*-------\nBUIC0800 DS    0H\n         ST    R1,WRKCMD@          Save Command Section Start Address\n\nBUIC0900 DS    0H\n         LR    R1,R5               A(Start Of Current Record)\n         CLC   0(72,R5),BLANKS     Check For Blank Line\n         BE    BUIC1300            B. If Yes (End Of Command)\n\n         LA    R1,71(,R5)          A(End Of Current Record)\nBUIC1000 DS    0H\n         CLI   0(R1),C' '          Check For Non-Blank\n         BNE   BUIC1100            B. If Found\n         BCT   R1,BUIC1000         Back Up And Loop To Last Non-Blank\n\nBUIC1100 DS    0H\n         CLI   0(R1),C'+'          Check for Continuation Character\n         BE    BUIC1200            B. If Yes\n         CLI   0(R1),C'-'          Check for Continuation Character\n         BE    BUIC1200            B. If Yes\n\n         LA    R1,1(,R1)           A(End Of Current Section)\n         B     BUIC1300\n\nBUIC1200 DS    0H\n         AHI   R5,80               A(Next Record)\n         CR    R5,R6               Check For End Of Buffer\n         BL    BUIC0900            B. If Not\n         LR    R1,R6               A(End Of Buffer)\n\n*-------\n*        Build A Command Buffer From This Section's Data\n*-------\nBUIC1300 DS    0H\n         ST    R1,WRKCMDE@         Save Command Section End Address\n         SL    R1,WRKCMD@          Calculate Section Length\n         AHI   R1,4                Add CBUF Header Length\n\n         LR    R3,R1\n         C     R3,WRKCBUFL         Check If Buffer Is Large Enough\n         BNH   BUIC1500            B. If Yes\n\n         ICM   R1,15,WRKCBUF@      A(Old Command Buffer)\n         BZ    BUIC1400            B. If No Previous Buffer\n         L     R0,WRKCBUFL         L(Old Command Buffer)\n         FREEMAIN RU,A=(1),LV=(0)\n\nBUIC1400 DS    0H\n         GETMAIN RU,LV=(R3),LOC=ANY\n         ST    R1,WRKCBUF@         Save New Command Buffer Address\n         ST    R3,WRKCBUFL         Save New Command Buffer Length\n\nBUIC1500 DS    0H\n         L     R5,WRKCBUF@         A(Start Of Command Buffer)\n\n         L     R1,WRKCMDE@         A(End Of Current Section)\n         SL    R1,WRKCMD@          Calculate Section Length\n         L     R14,WRKCMD@         A(Start Of Current Section)\n         STH   R1,0(,R5)           Save Command Length In Header\n         LA    R0,4(,R5)           A(Start Of Command Area)\n         #MVCL (R0),(R14),LEN=(R1) Move Section To Command Buffer\n\n         LH    R1,WRKCMDNL         L(Current Section Command)\n         LA    R1,5(R1,R5)         Point Past Command Name\n         L     R2,WRKCBUFL         L(Current Command Buffer Length)\n         SH    R2,=AL2(4)          Subtract CBUF Header Length\n         SH    R2,WRKCMDNL         Subtract Length Of Command Name\n         L     R15,=A(FINDCHAR)\n         #EXEC -R2,TRT,0(*-*,R1),0(R15)                                *\n\n         LA    R2,4(,R5)           A(Start Of Command)\n         SR    R1,R2               Calculate Offset To 1st Operand\n         STH   R1,2(,R5)           Save Offset In Header\n\n         LH    R4,0(,R5)           L(Command)\n         LA    R5,4(,R5)           A(Command)\nBUIC1600 DS    0H\n         LR    R3,R4               Copy Remaining Length\n         CHI   R3,255              Check If Length Is Too Large\n         BNH   BUIC1700            B. If Not\n         LHI   R3,255              Else. Set Length To Maximum\n\nBUIC1700 DS    0H\n         L     R15,=A(CONVCONT)\n         #EXEC -R3,TR,0(*-*,R5),0(R15)                                 *\n                                   Remove Continuation Chars from CBUF\n         AHI   R3,1\n         LA    R5,0(R3,R5)         A(Past Translated Portion)\n         SR    R4,R3               Calculate Remaining Length\n         BP    BUIC1600            B. If There Is More Command Data\n\n         LHI   R15,0               Set Return Code\n         B     BUICEXIT\n\nBUIC1800 DS    0H\n         MVC   WRKINS1(4),=AL2(*-*,#MSG0061)\n         MVC   WRKINS1+4(8),WRKCMDNM\n         LH    R1,WRKCMDNL         L(Current Section Command)\n         AHI   R1,4                Add Msg Prefix Length\n         STH   R1,WRKINS1          Save Message Length\n\n         LHI   R0,2                Message Contains 2 Segments\n         L     R1,=A(#MSG006)      A(Error Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\n         LHI   R15,8               Set Return Code\n\nBUICEXIT #RESTORE R15=(R15)        Restore All Registers\n\n         LTR   R15,R15             Set Condition Code\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Build Table From Parsed Names List                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nBUILDTAB #SAVE ,                   Save All Registers\n\n         MVC   WRKR15,=A(8)        Set Default Return Code\n\n         L     R10,WRKPDL2         A(PDL)\n         USING TSOXXPCL,R10\n\n*-------\n*        Calculate The Number Of Specified Names\n*-------\n         LA    R5,LIST             A(Start Of 'NAMES')\n         SLR   R6,R6               Initialize Entry Counter\nBUIT0100 DS    0H\n         AHI   R6,1                Increment Entry Count\n         CLC   8(4,R5),=X'FF000000'\n         BE    BUIT0200            B. If End Of List\n         L     R5,8(,R5)           A(Next NAME In List)\n         B     BUIT0100            Else. Keep Counting\n\n*-------\n*        Add 1 To The Table Entry Count And Create a KEY8 Table\n*-------\nBUIT0200 DS    0H\n         AHI   R6,1                Add 1 To Entry Count\n         ST    R6,WRKTABCT         Save Entry Count\n\n         MH    R6,WRKTABEL         Calculate Required Table Size\n         AHI   R6,16               Add Table Header Length\n\n         GETMAIN RU,LV=(R6),LOC=ANY\n         ST    R1,WRKTEMP@         Save Table Address\n         STH   R6,WRKTEMPL         Save Table Length\n\nBUIT0300 DS    0H\n         L     R0,WRKTEMP@         A(Key8 Table Storage)\n         LH    R1,WRKTEMPL         L(Key8 Table Storage)\n         #BLANK (R0),LEN=(R1),PAD=C' '\n\n         L     R3,WRKTEMP@         A(Key8 Table Storage)\n         MVC   0(8,R3),WRKTABNM    Insert Table Name\n         MVC   8(8,R3),=C' PARMLIB'\n         AHI   R3,16               A(Start Of Table Entries)\n\n         LA    R5,LIST             A(Start Of 'NAMES')\nBUIT0400 DS    0H\n         L     R1,0(,R5)           A(Current NAME)\n         LH    R2,4(,R5)           L(Current NAME)\n\n         CLC   WRKTABEL,=AL2(8)    Check For Normal Table Entry\n         BE    BUIT0500            B. If Yes\n         STH   R2,0(,R3)           Save NAME Length\n         AHI   R3,2                Advance Past Length\nBUIT0500 DS    0H\n         #EXEC -R2,MVC,0(*-*,R3),0(R1)\n         AHI   R3,8                Advance To Next Entry\n\n         CLC   8(4,R5),=X'FF000000'\n         BE    BUIT0600            B. If End Of List\n         L     R5,8(,R5)           A(Next NAME In List)\n         B     BUIT0400\n\nBUIT0600 DS    0H\n         CLC   WRKTABEL,=AL2(8)    Check For Normal Table Entry\n         BE    BUIT0700            B. If Yes\n         MVC   0(2,R3),=X'FFFF'    Set End Of List\n\nBUIT0700 DS    0H\n         MVC   WRKR15,=A(0)        Set Return Code\n\nBUITEXIT DS    0H                  Restore All Registers\n         L     R15,WRKR15          Load Return Code\n         #RESTORE R15=(R15)        Restore All Registers\n\n         LTR   R15,R15             Set Condition Code\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Ensure At Least One Table Name Was Specified                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nCHECKTAB #SAVE ,                   Save All Registers\n         SLR   R15,R15             Initialize Return Code\n\n         CLI   APKW+1,$AUTHTSF     Check For \"AUTHTSF\" Keyword\n         BE    CHECEXIT            B. If Yes\n         CLI   E2KW+1,$AUTHCMD     Check For \"AUTHCMD\" Keyword\n         BE    CHECEXIT            B. If Yes\n         CLI   E8KW+1,$AUTHPGM     Check For \"AUTHPGM\" Keyword\n         BE    CHECEXIT            B. If Yes\n         CLI   NSKW+1,$NOTBKGND    Check For \"NOTBKGND\" Keyword\n         BE    CHECEXIT            B. If Yes\n\n         LHI   R0,1                Message Contains 1 Segment\n         L     R1,=A(#MSG007)      A(No Table Message)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\n         LHI   R15,8               Set Return Code\n\nCHECEXIT #RESTORE R15=(R15)        Restore All Registers\n\n         LTR   R15,R15             Set Condition Code\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Perform Program Termination Cleanup                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nCLEANUP  #SAVE ,                   Save All Registers\n\n         IKJRLSA WRKPDL1           Release The Main Parse Storage\n         XC    WRKPDL1,WRKPDL1\n\n         IKJRLSA WRKPDL2           Release The SubCommand Parse Storage\n         XC    WRKPDL2,WRKPDL2\n\nCLEA0100 DS    0H\n         ICM   R1,15,WRKBUFF@      A(Parmlib Read Buffer)\n         BZ    CLEA0200            B. If Not Available\n         ICM   R0,15,WRKBUFFL      L(Parmlib Read Buffer)\n         BZ    CLEA0200            B. If Not Available\n         XC    WRKBUFF@,WRKBUFF@\n         FREEMAIN RU,A=(1),LV=(0)\n\nCLEA0200 DS    0H\n         ICM   R1,15,WRKMSGB@      A(Buffer)\n         BZ    CLEA0300            B. If Not Available\n         ICM   R0,15,WRKMSGBL      L(Buffer)\n         BZ    CLEA0300            B. If Not Available\n         XC    WRKMSGB@,WRKMSGB@\n         FREEMAIN RU,A=(1),LV=(0)\n\nCLEA0300 DS    0H\n         ICM   R1,15,WRKCBUF@      A(Buffer)\n         BZ    CLEA0400            B. If Not Available\n         ICM   R0,15,WRKCBUFL      L(Buffer)\n         BZ    CLEA0400            B. If Not Available\n         XC    WRKCBUF@,WRKCBUF@\n         FREEMAIN RU,A=(1),LV=(0)\n\nCLEA0400 DS    0H\n         ICM   R1,15,WRKTEMP@      A(Buffer)\n         BZ    CLEA0500            B. If Not Available\n         SLR   R0,R0\n         ICM   R0,3,WRKTEMPL       L(Buffer)\n         BZ    CLEA0500            B. If Not Available\n         XC    WRKTEMP@,WRKTEMP@\n         FREEMAIN RU,A=(1),LV=(0)\n\nCLEA0500 DS    0H\n         ICM   R1,15,WRKLOAD@      A(Buffer)\n         BZ    CLEANXIT            B. If Not Available\n         ICM   R0,15,WRKLOADL      L(Buffer)\n         BZ    CLEANXIT            B. If Not Available\n         XC    WRKLOAD@,WRKLOAD@\n         FREEMAIN RU,A=(1),LV=(0)\n\nCLEANXIT #RESTORE ,                Restore All Registers\n\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Insert The Current Loaded Module                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nCOPYLOAD #SAVE ,                   Save All Registers\n         #CALL AUTH                Get Into Supervisor State, Key Zero\n         BNZ   COPLEXIT            B. If Not Authorized\n\n         LH    R3,WRKMODL          Load Module Length\n         GETMAIN RU,LV=(R3),SP=252,LOC=BELOW\n         ST    R1,WRKAUTH@         Save Authorized Table Address\n         STH   R3,WRKAUTHL         Save Authorized Table Size\n\n         L     R4,WRKMOD@          A(Loaded Module)\n         #MVCL (R1),(R4),LEN=(R3)  Copy Module To Authorized Storage\n\n         L     R1,WRKTAB@@         A(Table Address In LWA)\n         MVC   WRKTAB@,0(R1)       Save Old Table Address\n         MVC   0(4,R1),WRKAUTH@    Point To New Table\n         MVC   WRKTABL,0(R1)       Save Old Table Address\n         L     R1,WRKTABL@         A(Table Length In LWA)\n         MVC   0(2,R1),WRKAUTHL    Set To New Table Length\n\n         L     R14,WRKLWA@         A(LWA)\n         USING LWA,R14\n\n         OC    LWAVFLGS,WRKVFLGS   Ensure \"LOADED\" Flag Is On\n\n         DROP  R14\n\n         ICM   R1,15,WRKTAB@       A(Previous Table)\n         BZ    COPYL100            B. If No Previous Table\n         SLR   R0,R0\n         ICM   R0,3,WRKTABL        A(Previous Table Length)\n         BZ    COPYL100            B. If No Previous Table\n         XC    WRKTAB@,WRKTAB@\n         XC    WRKTABL,WRKTABL\n         FREEMAIN RU,A=(1),LV=(0),SP=252\n\nCOPYL100 DS    0H\n         #CALL DEAUTH              Return To Original State & Key\n         LHI   R15,0               Set Return Code\n\nCOPLEXIT #RESTORE R15=(R15)        Restore All Registers\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Copy The Current Table To One With A Known Length            *\n*                                                                     *\n*        If The Table Length Is Not Known, The User May Be Using      *\n*        A Version That is Loaded From LPA (Un-Alterable).            *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nCOPYTAB  #SAVE ,                   Save All Registers\n         SLR   R0,R0\n         ICM   R0,3,WRKTABL        Check If Length Is Already Known\n         BNZ   COPYEXIT            B. If Yes (No Need To Copy)\n\n         #CALL GETLEN              Determine Length Of Current Table\n         BZ    COPYEXIT            B. If No Current Table\n         STH   R15,WRKTABL         Set Current Table Length\n\n         #CALL AUTH                Get Into Supervisor State, Key Zero\n         BNZ   COPYEXIT            B. If Not Authorized\n\n         LH    R3,WRKTABL          Load Calculated Table Length\n         GETMAIN RU,LV=(R3),SP=252,LOC=BELOW\n         ST    R1,WRKAUTH@         Save Authorized Table Address\n         LR    R2,R1\n         STH   R3,WRKAUTHL         Save Authorized Table Length\n\n         L     R4,WRKTAB@          A(Current Table)\n         #MVCL (R1),(R4),LEN=(R3)  Copy Table To Authorized Storage\n\n         L     R1,WRKTAB@@         A(Table Address In LWA)\n         MVC   0(4,R1),WRKAUTH@    Point To New Table\n         MVC   WRKTAB@,WRKAUTH@\n         L     R1,WRKTABL@         A(Table Length In LWA)\n         MVC   0(2,R1),WRKAUTHL    Set To New Table Length\n\n         #CALL DEAUTH              Return To Original State & Key\n\nCOPYEXIT #RESTORE ,                Restore All Registers\n\n         SLR   R15,R15\n         ICM   R15,3,WRKTABL       Set Condition Code\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Return To Original State And Key                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nDEAUTH   #SAVE ,                   Save All Registers\n\n         TM    WRKFLAG,$SETKEY0    Check If Changed To Key Zero\n         BZ    DEAU0100            B. If Not\n\n         IC    R2,WRKOPSWK         Load Original Protect Key\n         SPKA  0(R2)               Return To Original Key\n         NI    WRKFLAG,255-$SETKEY0\n\nDEAU0100 DS    0H\n         TM    WRKFLAG,$SETSUP     Check If Changed To Superviosr State\n         BZ    DEAUEXIT            B. If Not\n\n         MODESET MODE=PROB         Return To Problem State\n         NI    WRKFLAG,255-$SETSUP\n\nDEAUEXIT #RESTORE ,                Restore All Registers\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Display A Table's Information And Contents                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nDISPTAB  #SAVE ,                   Save All Registers\n\n*-------\n*     LWA008I ________(________________) AT ________ KEY __ LEN=_____\n*-------\n\n         MVC   WRKINS1(4),=AL2(4+26,#MSG0081)\n         MVC   WRKINS1+4(8),WRKTABNM\n         MVI   WRKINS1+4+8,C'('\n         MVC   WRKINS1+4+8+1(16),BLANKS\n         ICM   R5,15,WRKTAB@       A(Current Table)\n         BZ    DISP0100            B. If No Table\n         MVC   WRKINS1+4+8+1(16),0(R5)\nDISP0100 DS    0H\n         MVI   WRKINS1+4+8+1+16,C')'\n         MVC   WRKINS2(4),=AL2(4+8,#MSG0082)\n         UNPK  WRKINS2+4(9),WRKTAB@(5)\n         L     R15,=A(HEXTABLE-C'0')\n         TR    WRKINS2+4(8),0(R15)\n         MVI   WRKINS2+4+8,C' '\n         MVC   WRKINS3(4),=AL2(4+2,#MSG0083)\n         UNPK  WRKINS3+4(3),WRKTABPK(2)\n         L     R15,=A(HEXTABLE-C'0')\n         TR    WRKINS3+4(2),0(R15)\n         MVI   WRKINS3+4+2,C' '\n         MVC   WRKINS4(4),=AL2(4+9+8,#MSG0084)\n         MVC   WRKINS4+4(28),BLANKS\n         SLR   R1,R1\n         ICM   R1,3,WRKTABL\n         BZ    DISP0200\n         MVC   WRKINS4+4(4),=C'LEN='\n         CVD   R1,WRKDBL\n         OI    WRKDBL+7,X'0F'\n         UNPK  WRKINS4+8(5),WRKDBL\n         MVC   WRKINS4+8+5(8),=C' Decimal'\n\nDISP0200 DS    0H\n         MVC   WRKINS5(4),=AL2(4+L'#MSG0085,#MSG0085)\n         MVC   WRKINS5+4(28),BLANKS\n         TM    WRKTABF,WRK$STEP    Check If Table Came From //STEPLIB\n         BZ    DISP0300            B. If Not\n         MVC   WRKINS5+4(7),=C'STEPLIB'\n         B     DISP0400\nDISP0300 DS    0H\n         ICM   R0,3,WRKTABL        Check If A Length Exists In The LWA\n         BNZ   DISP0400            B. If Yes (Parmlib Or //STEPLIB)\n         MVC   WRKINS5+4(28),BLANKS\n         MVC   WRKINS5+4(3),=C'LPA'\n\nDISP0400 DS    0H\n         LHI   R0,6                Message Contains 6 Segments\n         L     R1,=A(#MSG008)      A(Informational Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         LA    R3,WRKINS2          A(Insert #2)\n         LA    R4,WRKINS3          A(Insert #3)\n         LA    R5,WRKINS4          A(Insert #4)\n         LA    R6,WRKINS5          A(Insert #5)\n         #CALL PUTLINE             Write Message\n\n*-------\n*     LWA002I ________ ________ ________ ________ ________ ________\n*-------\n         ICM   R9,15,WRKTAB@       A(Current Table)\n         BZ    DISPEXIT            B. If No Table\n         LR    R2,R9               Save Starting Address\n         XC    WRKTABE@,WRKTABE@   Reset End Of Table Address\n         AHI   R9,16               Advance Past Table Header\n\n         SLR   R1,R1\n         ICM   R1,3,WRKTABL        L(Current Table)\n         BZ    DISP0500            B. If Table Has Blank Terminator\n         AR    R2,R1               A(End Of Table)\n         ST    R2,WRKTABE@         Save End Of Table Address\n\nDISP0500 DS    0H\n         MVC   WRKINS1(4),=AL2(4+8,#MSG0091)\n         MVC   WRKINS1+4(28),BLANKS\n         MVC   WRKINS2(4),=AL2(4+8,#MSG0092)\n         MVC   WRKINS2+4(28),BLANKS\n         MVC   WRKINS3(4),=AL2(4+8,#MSG0093)\n         MVC   WRKINS3+4(28),BLANKS\n         MVC   WRKINS4(4),=AL2(4+8,#MSG0094)\n         MVC   WRKINS4+4(28),BLANKS\n         MVC   WRKINS5(4),=AL2(4+8,#MSG0095)\n         MVC   WRKINS5+4(28),BLANKS\n         MVC   WRKINS6(4),=AL2(4+8,#MSG0096)\n         MVC   WRKINS6+4(28),BLANKS\n\n         #CALL GETNAME             Get Current Program/Command Name\n         BZ    DISPEXIT            B. If Terminator Slot Found\n         MVC   WRKINS1+4(8),WRKNAME\n         AH    R9,WRKTABEL         A(Next Slot In Table)\n         ICM   R0,3,WRKTABL        L(Current Table)\n         BZ    DISP0600            B. If Table Must Have A Terminator\n         C     R9,WRKTABE@         Check For End Of Table\n         BNL   DISP1200            B. If End Encountered\n\nDISP0600 DS    0H\n         #CALL GETNAME             Get Current Program/Command Name\n         BZ    DISP1200            B. If Terminator Slot Found\n         MVC   WRKINS2+4(8),WRKNAME\n         AH    R9,WRKTABEL         A(Next Slot In Table)\n         ICM   R0,3,WRKTABL        L(Current Table)\n         BZ    DISP0700            B. If Table Must Have A Terminator\n         C     R9,WRKTABE@         Check For End Of Table\n         BNL   DISP1200            B. If End Encountered\n\nDISP0700 DS    0H\n         #CALL GETNAME             Get Current Program/Command Name\n         BZ    DISP1200            B. If Terminator Slot Found\n         MVC   WRKINS3+4(8),WRKNAME\n         AH    R9,WRKTABEL         A(Next Slot In Table)\n         ICM   R0,3,WRKTABL        L(Current Table)\n         BZ    DISP0800            B. If Table Must Have A Terminator\n         C     R9,WRKTABE@         Check For End Of Table\n         BNL   DISP1200            B. If End Encountered\n\nDISP0800 DS    0H\n         #CALL GETNAME             Get Current Program/Command Name\n         BZ    DISP1200            B. If Terminator Slot Found\n         MVC   WRKINS4+4(8),WRKNAME\n         AH    R9,WRKTABEL         A(Next Slot In Table)\n         ICM   R0,3,WRKTABL        L(Current Table)\n         BZ    DISP0900            B. If Table Must Have A Terminator\n         C     R9,WRKTABE@         Check For End Of Table\n         BNL   DISP1200            B. If End Encountered\n\nDISP0900 DS    0H\n         #CALL GETNAME             Get Current Program/Command Name\n         BZ    DISP1200            B. If Terminator Slot Found\n         MVC   WRKINS5+4(8),WRKNAME\n         AH    R9,WRKTABEL         A(Next Slot In Table)\n         ICM   R0,3,WRKTABL        L(Current Table)\n         BZ    DISP1000            B. If Table Must Have A Terminator\n         C     R9,WRKTABE@         Check For End Of Table\n         BNL   DISP1200            B. If End Encountered\n\nDISP1000 DS    0H\n         #CALL GETNAME             Get Current Program/Command Name\n         BZ    DISP1200            B. If Terminator Slot Found\n         MVC   WRKINS6+4(8),WRKNAME\n         AH    R9,WRKTABEL         A(Next Slot In Table)\n         ICM   R0,3,WRKTABL        L(Current Table)\n         BZ    DISP1100            B. If Table Must Have A Terminator\n         C     R9,WRKTABE@         Check For End Of Table\n         BNL   DISP1200            B. If End Encountered\n\nDISP1100 DS    0H\n         LHI   R0,7                Message Contains 7 Segments\n         L     R1,=A(#MSG009)      A(Program/Command Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         LA    R3,WRKINS2          A(Insert #2)\n         LA    R4,WRKINS3          A(Insert #3)\n         LA    R5,WRKINS4          A(Insert #4)\n         LA    R6,WRKINS5          A(Insert #5)\n         LA    R7,WRKINS6          A(Insert #6)\n         #CALL PUTLINE             Write Message\n\n         ICM   R0,3,WRKTABL        L(Current Table)\n         BZ    DISP0500            B. If Table Must Have A Terminator\n         C     R9,WRKTABE@         Check For End Of Table\n         BL    DISP0500            B. If More Entries Exist\n         B     DISPEXIT            Else. Terminate\n\n*-------\n*        Display The Last Entry\n*-------\nDISP1200 DS    0H\n         LHI   R0,7                Message Contains 7 Segments\n         L     R1,=A(#MSG009)      A(Program/Command Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         LA    R3,WRKINS2          A(Insert #2)\n         LA    R4,WRKINS3          A(Insert #3)\n         LA    R5,WRKINS4          A(Insert #4)\n         LA    R6,WRKINS5          A(Insert #5)\n         LA    R7,WRKINS6          A(Insert #6)\n         #CALL PUTLINE             Write Message\n\nDISPEXIT DS    0H\n         LHI   R0,1                Message Contains 1 Segment\n         L     R1,=A(BLANKLNE)     A(Blank Line Message)\n         #CALL PUTLINE             Write Message\n\n         #RESTORE ,                Restore All Registers\n         BR    R14                 Return To Caller\n         POP   USING\n\n*-------\n*        Save The Contents Of The Current Table Entry\n*-------\n         PUSH  USING\nGETNAME  #SAVE ,                   Save All Registers\n         MVC   WRKNAME,BLANKS      Initialize Output Area\n         LR    R1,R9               Set Start Of Entry Name\n         LHI   R2,8                Set Length For MVC\n         CLC   WRKTABEL,=AL2(10)   Check For IKJEFTNS Table\n         BNE   GETN0100            B. If Not\n         ICM   R2,3,0(R9)          Load Command Length\n         BZ    GETNEXIT            B. If Null Entry\n         CLC   0(2,R9),=X'FFFF'    Check For Terminating Entry\n         BE    GETNEXIT            B. If Yes\n         LA    R1,2(,R1)           Advance Past Length Field\n\nGETN0100 DS    0H\n         #EXEC -R2,MVC,WRKNAME(*-*),0(R1)\n\nGETNEXIT #RESTORE ,                Restore All Registers\n\n         TM    WRKNAME,X'BF'       Check If Entry Name Is Null\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Locate The Currently Specified \"NAME\"                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nFINDNAME #SAVE ,                   Save All Registers\n         SLR   R6,R6               Initialize \"FOUND\" Keyword Address\n\n*-------\n*        Search The AUTHTSF Table\n*-------\n         CLI   APKW+1,$AUTHTSF     Check For 'IKJEFTAP' Keyword\n         BNE   FIND0200            B. If Not\n         LA    R6,APKW             A(Current Keyword)\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHTSF '\n         MVC   WRKTABNL,=AL2(8)\n         MVC   WRKTABNM,=C'IKJEFTAP'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         MVC   WRKTAB@@,WRKTAPP@   Save Table Pointer Address\n         MVC   WRKTABL@,WRKTAPL@   Save Table Length Address\n         L     R3,WRKTAPP@\n         ICM   R3,15,0(R3)         A(IKJEFTAP Table)\n         BZ    FIND0200            B. If Not Available\n         ST    R3,WRKTAB@          Save Table Address\n         MVC   WRKTABL,WRKTAPL     Save Table Length\n         LA    R4,16(,R3)          A(1st Entry)\n         SLR   R1,R1\n         ICM   R1,3,WRKTAPL        L(Table In LWA)\n         BZ    FIND0100            B. If Length Is Zero\n         AR    R1,R3               A(End Of Table)\n         ST    R1,WRKTABE@\nFIND0100 DS    0H\n         CLI   0(R4),C' '          Check For End Of Table\n         BE    FIND0200            B. If Table Ends\n         CLC   0(8,R4),WRKNAME     Check If \"NAME\" Was Found\n         BE    FIND0900            B. If Yes\n         AH    R4,WRKTABEL         A(Next Table Entry)\n         ICM   R0,3,WRKTAPL        L(Table In LWA)\n         BZ    FIND0100            B. If Terminator Must Exist\n         C     R4,WRKTABE@         Check For End Of Table\n         BL    FIND0100            B. If More Entries\n\n*-------\n*        Search The AUTHCMD Table\n*-------\nFIND0200 DS    0H\n         CLI   E2KW+1,$AUTHCMD     Check For 'IKJEFTE2' Keyword\n         BNE   FIND0400            B. If Not\n         LA    R6,E2KW             A(Current Keyword)\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHCMD '\n         MVC   WRKTABNL,=AL2(8)\n         MVC   WRKTABNM,=C'IKJEFTE2'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         MVC   WRKTAB@@,WRKTE2P@   Save Table Pointer Address\n         MVC   WRKTABL@,WRKTE2L@   Save Table Length Address\n         L     R3,WRKTE2P@\n         ICM   R3,15,0(R3)         A(IKJEFTE2 Table)\n         BZ    FIND0400            B. If Not Available\n         ST    R3,WRKTAB@          Save Table Address\n         MVC   WRKTABL,WRKTE2L     Save Table Length\n         LA    R4,16(,R3)          A(1st Entry)\n         SLR   R1,R1\n         ICM   R1,3,WRKTE2L        L(Table In LWA)\n         BZ    FIND0300            B. If Length Is Zero\n         AR    R1,R3               A(End Of Table)\n         ST    R1,WRKTABE@\nFIND0300 DS    0H\n         CLI   0(R4),C' '          Check For End Of Table\n         BE    FIND0400            B. If Table Ends\n         CLC   0(8,R4),WRKNAME     Check If \"NAME\" Was Found\n         BE    FIND0900            B. If Yes\n         AH    R4,WRKTABEL         A(Next Table Entry)\n         ICM   R0,3,WRKTAPL        L(Table In LWA)\n         BZ    FIND0300            B. If Terminator Must Exist\n         C     R4,WRKTABE@         Check For End Of Table\n         BL    FIND0300            B. If More Entries\n\n*-------\n*        Search The AUTHPGM Table\n*-------\nFIND0400 DS    0H\n         CLI   E8KW+1,$AUTHPGM     Check For 'IKJEFTE8' Keyword\n         BNE   FIND0600            B. If Not\n         LA    R6,E8KW             A(Current Keyword)\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHPGM '\n         MVC   WRKTABNL,=AL2(8)\n         MVC   WRKTABNM,=C'IKJEFTE8'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         MVC   WRKTAB@@,WRKTE8P@   Save Table Pointer Address\n         MVC   WRKTABL@,WRKTE8L@   Save Table Length Address\n         L     R3,WRKTE8P@\n         ICM   R3,15,0(R3)         A(IKJEFTE8 Table)\n         BZ    FIND0600            B. If Not Available\n         ST    R3,WRKTAB@          Save Table Address\n         MVC   WRKTABL,WRKTE8L     Save Table Length\n         LA    R4,16(,R3)          A(1st Entry)\n         SLR   R1,R1\n         ICM   R1,3,WRKTE8L        L(Table In LWA)\n         BZ    FIND0500            B. If Length Is Zero\n         AR    R1,R3               A(End Of Table)\n         ST    R1,WRKTABE@\nFIND0500 DS    0H\n         CLI   0(R4),C' '          Check For End Of Table\n         BE    FIND0600            B. If Table Ends\n         CLC   0(8,R4),WRKNAME     Check If \"NAME\" Was Found\n         BE    FIND0900            B. If Yes\n         AH    R4,WRKTABEL         A(Next Table Entry)\n         ICM   R0,3,WRKTAPL        L(Table In LWA)\n         BZ    FIND0500            B. If Terminator Must Exist\n         C     R4,WRKTABE@         Check For End Of Table\n         BL    FIND0500            B. If More Entries\n\n*-------\n*        Search The NOTBKGND Table\n*-------\nFIND0600 DS    0H\n         CLI   NSKW+1,$NOTBKGND    Check For 'IKJEFTNS' Keyword\n         BNE   FIND1000            B. If Not\n         LA    R6,NSKW             A(Current Keyword)\n         MVC   WRKCMDNL,=AL2(8)\n         MVC   WRKCMDNM,=C'NOTBKGND'\n         MVC   WRKTABNL,=AL2(8)\n         MVC   WRKTABNM,=C'IKJEFTNS'\n         MVC   WRKTABEL,=AL2(10)   Set Table Entry Length\n         MVC   WRKTAB@@,WRKTNSP@   Save Table Pointer Address\n         MVC   WRKTABL@,WRKTNSL@   Save Table Length Address\n         L     R3,WRKTNSP@\n         ICM   R3,15,0(R3)         A(IKJEFTNS Table)\n         BZ    FIND1000            B. If Not Available\n         ST    R3,WRKTAB@          Save Table Address\n         MVC   WRKTABL,WRKTNSL     Save Table Length\n         LA    R4,16(,R3)          A(1st Entry)\n         SLR   R1,R1\n         ICM   R1,3,WRKTNSL        L(Table In LWA)\n         BZ    FIND0700            B. If Length Is Zero\n         AR    R1,R3               A(End Of Table)\n         ST    R1,WRKTABE@\nFIND0700 DS    0H\n         ICM   R0,3,0(R4)          Load Command Length\n         BZ    FIND1000            B. If Null Entry\n         CLC   0(2,R4),=X'FFFF'    Check For Terminating Entry\n         BE    FIND1000            B. If Yes\n         CLC   0(2,R4),WRKNAMEL    Check If Lengths Match\n         BNE   FIND0800            B. If Not\n         LH    R1,WRKNAMEL         L(NAME)\n         #EXEC -R1,CLC,2(*-*,R4),WRKNAME\n         BE    FIND0900            B. If NAME Found\nFIND0800 DS    0H\n         AH    R4,WRKTABEL         A(Next Table Entry)\n         ICM   R0,3,WRKTAPL        L(Table In LWA)\n         BZ    FIND0700            B. If No Length In LWA\n         C     R4,WRKTABE@         Check For End Of Table\n         BL    FIND0700            B. If More Entries\n         B     FIND1000            B. If Not Found\n\n*-------\n*        \"NAME\" Found.  Return It's Address To Caller\n*-------\nFIND0900 DS    0H\n         ST    R6,WRKKW@           Save \"FOUND\" Keyword Address\n\n         LR    R5,R4               A(Current Table Entry)\n\n         LR    R15,R5\n         SL    R15,WRKTAB@         Calculate Entry Offset\n         ST    R15,WRKNAMEO\n\n         TM    WRKFLAG,$MSG_F      Check If Message Requested\n         BZ    FINDEXIT            B. If Not\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0101)\n         MVC   WRKINS1+4(8),WRKNAME\n         LH    R0,WRKNAMEL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         MVC   WRKINS2(4),=AL2(4+*-*,#MSG0102)\n         MVC   WRKINS2+4(8),WRKCMDNM\n         LH    R0,WRKCMDNL\n         AHI   R0,4\n         STH   R0,WRKINS2\n         LHI   R0,3                Message Contains 3 Segments\n         L     R1,=A(#MSG010)      A(Not Found Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         LA    R3,WRKINS2          A(Insert #2)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\n         B     FINDEXIT\n\n*-------\n*        \"NAME\" Not Found.  Issue Messaged If Requested\n*-------\nFIND1000 DS    0H\n         SLR   R5,R5               Indicate Entry Not Found\n\n         TM    WRKFLAG,$MSG_NF     Check If Message Requested\n         BZ    FINDEXIT            B. If Not\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0111)\n         MVC   WRKINS1+4(8),WRKNAME\n         LH    R0,WRKNAMEL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         LHI   R0,2                Message Contains 2 Segments\n         L     R1,=A(#MSG011)      A(Not Found Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\nFINDEXIT DS    0H\n         NI    WRKFLAG,255-($MSG_NF+$MSG_F)\n\n         #RESTORE R15=(R5)         Restore All Registers\n\n         LTR   R15,R15             Set Condition Code\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Determine Length Of Table                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nGETLEN   #SAVE ,                   Save All Registers\n\n         SLR   R15,R15\n         ICM   R15,3,WRKTABL       Load Table Length From LWA\n         BNZ   GETLEXIT            B. If Length Exists\n\nGETL0100 DS    0H\n         L     R15,WRKTAB@@        A(Current Table Pointer)\n         ICM   R15,15,0(R15)       A(Current Table)\n         BZ    GETLEXIT            B. If No Table Exists\n         ST    R15,WRKTAB@         Save Current Table Address\n         AHI   R15,16              A(1st Table Entry)\n\nGETL0200 DS    0H\n         CLC   WRKTABEL,=AL2(10)   Check For IKJEFTNS Table\n         BNE   GETL0300            B. If Not\n         ICM   R0,3,0(R15)         Check For Null Entry (Terminator)\n         BZ    GETL0500            B. If Yes\n         CLC   0(2,R15),=X'FFFF'   Check For Terminating Entry\n         BE    GETL0500            B. If Yes\n         B     GETL0400\n\nGETL0300 DS    0H\n         TM    0(R15),X'BF'        Check For Blank/Zero Entry\n         BZ    GETL0500            B. If Yes (Terminator)\n\nGETL0400 DS    0H\n         AH    R15,WRKTABEL        A(Next Entry In Table)\n         B     GETL0100            B. Check Next Entry\n\nGETL0500 DS    0H\n         AH    R15,WRKTABEL        A(End Of Terminating Entry)\n\nGETLEXIT #RESTORE R15=(R15)        Restore All Registers\n\n         LTR   R15,R15             Set Condition Code\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n         EJECT 1\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Build A Table From The 8 Byte LIST File                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nLISTTAB  #SAVE ,                   Save All Registers\n\n*-------\n*        Find The Table Id And Count It's Entries\n*-------\n         L     R4,WRKMSGB@         A(Start Of Data Buffer)\nLIST0100 DS    0H\n         C     R4,WRKMSGBE         Check For End Of Buffer\n         BNL   LIST0800            B. If Id Not Found\n         CLC   WRKNAME,0(R4)       Check For Current Table Id\n         BE    LIST0200            B. If Yes\n         AHI   R4,8                A(Next LIST Entry)\n         B     LIST0100            Keep Searching\n\nLIST0200 DS    0H\n         AHI   R4,8                A(Start Of Table Names)\n         ST    R4,WRKPARM@         Save 1st Entry Address\n         SLR   R5,R5               Initialize Entry Counter\n\nLIST0300 DS    0H\n         C     R4,WRKMSGBE         Check For End Of Buffer\n         BNL   LIST0400            B. If End Reached\n         CLI   0(R4),C'-'          Check For \"Id\" Entry\n         BE    LIST0400            B. If Next Id Found\n         AHI   R4,8                A(Next LIST Entry)\n         AHI   R5,1                Add 1 To Entry Count\n         B     LIST0300            Keep Counting Entries\n\nLIST0400 DS    0H\n         ST    R5,WRKPARM#         Save Entry Count\n\n         LTR   R5,R5               Check Entry Count\n         BZ    LIST0800            B. If No Entries In Table\n\n*-------\n*        Add 1 To The Table Entry Count And Create a KEY8 Table\n*-------\n         AHI   R5,1                Add 1 To Entry Count\n         ST    R5,WRKTABCT         Save Entry Count\n\n         MH    R5,WRKTABEL         Calculate Required Table Size\n         AHI   R5,16               Add Table Header Length\n\n         GETMAIN RU,LV=(R5),LOC=ANY\n         ST    R1,WRKTEMP@         Save Table Address\n         STH   R5,WRKTEMPL         Save Table Length\n\n         L     R0,WRKTEMP@         A(Key8 Table Storage)\n         LH    R1,WRKTEMPL         L(Key8 Table Storage)\n         #BLANK (R0),LEN=(R1),PAD=C' '\n\n         L     R3,WRKTEMP@         A(Key8 Table Storage)\n         MVC   0(8,R3),WRKTABNM    Insert Table Name\n         MVC   8(8,R3),=C' PARMLIB'\n         AHI   R3,16               A(Start Of Table Entries)\n\n*-------\n*        Insert All The LIST Entries Into The KEY8 Table\n*-------\n         L     R5,WRKPARM@         A(1st Entry Name)\n         L     R6,WRKPARM#         Load Entry Count\nLIST0500 DS    0H\n         CLC   WRKTABEL,=AL2(8)    Check For Normal Table Entry\n         BE    LIST0600            B. If Yes\n         LA    R1,8(,R5)           A(End Of Current Entry)\n         L     R15,=A(FINDBLANK)\n         TRT   0(8,R5),0(R15)      Find The First Blank\n         SR    R1,R5               Calculate Entry's Value Length\n         STH   R1,0(,R3)           Save NAME Length\n         AHI   R3,2                Advance Past Length\nLIST0600 DS    0H\n         MVC   0(8,R3),0(R5)       Insert LIST Entry\n         AHI   R3,8                Advance To Next Entry\n         AHI   R5,8                Advance To Next LIST Entry\n         BCT   R6,LIST0500         Process All LIST Entries\n\n         CLC   WRKTABEL,=AL2(8)    Check For Normal Table Entry\n         BE    LIST0700            B. If Yes\n         MVC   0(2,R3),=X'FFFF'    Set End Of List\n\nLIST0700 DS    0H\n         LHI   R15,0               Set Return Code\n         B     LISTEXIT\n\nLIST0800 DS    0H\n         LHI   R15,8               Set Return Code\n\nLISTEXIT #RESTORE R15=(R15)        Restore All Registers\n         LTR   R15,R15             Set Condition Code\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Load A Table From An IKJTABLS Alias Load Module              *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nLOADIT   #SAVE ,                   Save All Registers\n\n         L     R15,=A(MODCBU)\n         MVC   WRKDCB,0(R15)       Copy DCB To Work Area\n         MVC   DCBDDNAM-IHADCB+WRKDCB,WRKDDN\n         L     R15,=A(MODCBEU)\n         MVC   WRKDCBE,0(R15)      Copy DCBE To Work Area\n         LA    R15,WRKDCBE         A(DCBE)\n         ST    R15,DCBDCBE-IHADCB+WRKDCB\n\n         LA    R14,LOAD0900        A(Return From SYNAD Routine)\n         ST    R14,WRKR14          And From End-Of-Data\n         ST    R14,DCBEEODA-DCBE+WRKDCBE\n\n         L     R15,=A(MODOPEN)\n         MVC   WRKOPEN,0(R15)\n         OPEN  (WRKDCB),           Open The \"LOADLIB\" Data Set         *\n               MF=(E,WRKOPEN)\n         TM    DCBOFLGS-IHADCB+WRKDCB,DCBOFOPN\n         BZ    LOAD0700            B. If OPEN Failed\n\n*-------\n*        Issue BLDL To Allow Subsequent Load From Unauthorzed Library\n*-------\n         XC    WRKBLDL(WRKBLDLL),WRKBLDL\n         MVC   WRKBLDE#,=AL2(1)    Set Entry Length\n         MVC   WRKBLDEL,=AL2(L'WRKBLDLI) Set Directory Entry Length\n\n         LA    R2,WRKBLDLI         A(Directory Information)\n         USING PDS2,R2\n         MVC   PDS2NAME,WRKTABNM   Set Module Name\n\n         BLDL  WRKDCB,WRKBLDL      Search For Module Information\n         LTR   R15,R15             Check If Module Found\n         BNZ   LOAD0900            B. If Not\n\n         TM    PDS2INDC,PDS2ALIS   Check If Module Is An Alias\n         BZ    LOAD0900            B. If Not\n\n         SLR   R3,R3\n         ICM   R3,7,PDS2STOR       L(Module)\n         BZ    LOAD0900            B. If No Module\n         DROP  R2\n\n         C     R3,WRKLOADL         Check If Buffer Is Large Enough\n         BNH   LOAD0200            B. If Entire Module Will Fit\n         ICM   R1,15,WRKLOAD@      A(Buffer)\n         BZ    LOAD0100            B. If Not Available\n         ICM   R0,15,WRKLOADL      L(Buffer)\n         BZ    LOAD0100            B. If Not Available\n         FREEMAIN RU,A=(1),LV=(0)\nLOAD0100 DS    0H\n         GETMAIN RU,LV=(R3),LOC=BELOW\n         ST    R1,WRKLOAD@         Save Buffer Address\n         ST    R3,WRKLOADL         Save Buffer Length\n\n*-------\n*        Load The Requested Module Into Temporary Storage\n*-------\nLOAD0200 DS    0H\n         L     R15,=A(MODLOAD)\n         MVC   WRKLOAD,0(R15)\n         L     R2,WRKLOAD@         A(Directed Load Storage)\n\n         LOAD  EPLOC=WRKTABNM,                                         *\n               DCB=WRKDCB,LSEARCH=YES,ADRNAPF=(R2),                    *\n               ERRET=LOAD0800,SF=(E,WRKLOAD)\n\n         ST    R0,WRKMOD@          Save Module Entry Point\n         MVC   8(8,R2),=C' PARMLIB'  Simulate Data From IKJTSOxx\n\n         DELETE EPLOC=WRKTABNM     Remove The Module\n\n*-------\n*        Read The LOAD Module To Determine The CSECT Length\n*-------\n         FIND  WRKDCB,WRKTABNM,D   Point To Start Of Member\n\nLOAD0300 DS    0H\n         GETBUF WRKDCB,R6\n         ST    R6,WRKDCBBU         Save DCB Buffer Address\n\n         READ  DECB,SF,WRKDCB,(R6),'S',MF=E\n         CHECK DECB                Wait For I/O To Complete\n\n         USING CESD,R6\n         USING ESDDATA,CESDATA\n         CLI   CESDIDEN,CESDRCD    Check For CESD Record\n         BNE   LOAD0300            B. If Not\n\n         #BLKLEN DECB,R2           Get Length Of Current Block\n         AR    R2,R6               A(End Of Buffer)\n         ST    R2,WRKDCBBE         Save DCB Buffer End Address\n\nLOAD0400 DS    0H\n         C     R6,WRKDCBBE         Check For End Of Buffer\n         BNL   LOAD0300            B. If Buffer Complete\n         CLC   ESDNAME,WRKTABNM    Check For CESD For Our Module\n         BNE   LOAD0500            B. If Not\n         SLR   R3,R3\n         ICM   R3,7,ESDCLEN        Get CSECT Length\n         B     LOAD0600\n\nLOAD0500 DS    0H\n         LA    R6,16(,R6)          A(Next ESD Entry)\n         B     LOAD0400            Loop Through Buffer\n         DROP  R6\n\nLOAD0600 DS    0H\n         STH   R3,WRKMODL          Save CSECT Length\n\n         #CALL COPYLOAD            Copy And Save Address/Length In LWA\n\n         MVC   WRKINS1(4),=AL2(4+8,#MSG0191)\n         MVC   WRKINS1+4(8),WRKTABNM\n         MVC   WRKINS2(4),=AL2(4+*-*,#MSG0192)\n         MVC   WRKINS2+4(46),WRKDSN\n         LH    R1,WRKDSPDE+4       L(Quoted Data Set Name)\n         AHI   R1,4\n         STH   R1,WRKINS2\n         LHI   R0,3                Message Contains 3 Segments\n         L     R1,=A(#MSG019)      A(Table Loaded Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         LA    R3,WRKINS2          A(Insert #2)\n         #CALL PUTLINE             Write Message\n\n         LHI   R15,0               Set Return Code\n         B     LOAD1000\n\nLOAD0700 DS    0H\n         LHI   R0,2                Message Contains 1 Segments\n         MVC   WRKINS1(4),=AL2(4+8,#MSG0171)\n         MVC   WRKINS1+4(8),WRKDDN\n         L     R1,=A(#MSG017)      A(OPEN Failed)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\n         LHI   R15,8               Set Return Code\n         B     LOAD1000\n\nLOAD0800 DS    0H\n         ST    R15,WRKRCODE        Save Return Code\n         ST    R1,WRKREASN         Save Reason Code\n\n         MVC   WRKINS1(4),=AL2(4+8,#MSG0181)\n         MVC   WRKINS1+4(8),WRKTABNM\n         MVC   WRKINS2(4),=AL2(4+8,#MSG0182)\n         UNPK  WRKINS2+4(9),WRKRCODE(5)\n         L     R15,=A(HEXTABLE-C'0')\n         TR    WRKINS2+4(8),0(R15)\n         MVI   WRKINS2+4+8,C' '\n         MVC   WRKINS3(4),=AL2(4+8,#MSG0183)\n         UNPK  WRKINS3+4(9),WRKREASN(5)\n         L     R15,=A(HEXTABLE-C'0')\n         TR    WRKINS3+4(8),0(R15)\n         MVI   WRKINS3+4+8,C' '\n         LHI   R0,4                Message Contains 4 Segments\n         L     R1,=A(#MSG018)      A(Load Failed Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         LA    R3,WRKINS2          A(Insert #2)\n         LA    R4,WRKINS3          A(Insert #3)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\n         LHI   R15,8               Set Return Code\n         B     LOAD1000\n\nLOAD0900 DS    0H\n         MVC   WRKINS1(4),=AL2(4+8,#MSG0201)\n         MVC   WRKINS1+4(8),WRKTABNM\n         MVC   WRKINS2(4),=AL2(4+*-*,#MSG0202)\n         MVC   WRKINS2+4(46),WRKDSN\n         LH    R1,WRKDSPDE+4       L(Quoted Data Set Name)\n         AHI   R1,4\n         STH   R1,WRKINS2\n         LHI   R0,3                Message Contains 3 Segments\n         L     R1,=A(#MSG020)      A(Table Loaded Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         LA    R3,WRKINS2          A(Insert #2)\n         #CALL PUTLINE             Write Message\n\n         LHI   R15,8               Set Return Code\n         B     LOAD1000\n\nLOAD1000 DS    0H\n         TM    DCBOFLGS-IHADCB+WRKDCB,DCBOFOPN\n         BZ    LOADEXIT            B. If OPEN Failed\n         L     R15,=A(MODCLOSE)\n         MVC   WRKCLOSE,0(R15)\n         CLOSE (WRKDCB),           Close The \"LOADLIB\" Data Set        *\n               MF=(E,WRKCLOSE)\n\nLOADEXIT #RESTORE R15=(R15)        Restore All Registers\n\n         LTR   R15,R15             Set Condition Code\n         BR    R14                 Return To Caller\n         POP   USING\n\n         PUSH  USING\nLOADSYN  #SAVE ,                   Save All Registers\n         LR    R4,R13              Save Work Area Address\n         DROP  R13\n         USING WRKLWATM,R4\n\n         SYNADAF ACSMETH=BPAM,PARM1=(1)\n         MVC   WRKINS1(4),=AL2(4+82,BLANKINS)\n         MVC   WRKINS1+4(78),50(R1)\n\n         SYNADRLS ,                Release Synad Message Buffer\n\n         LR    R13,R4              Restore Dynamic Work Area\n         DROP  R4\n         USING WRKLWATM,R13\n\n         LHI   R0,2                Message Contains 2 Segments\n         L     R1,=A(BLANKLNE)     A(Blank Line)\n         LA    R2,WRKINS1          A(Insert #1)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\n         #RESTORE ,                Restore All Registers\n\n         L     R14,WRKR14          A(Synad Return Address)\n         BR    R14\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PUTLINE Subroutine                                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nPUTLINE  #SAVE ,                   Save All Registers\n         TM    WRKFLAG,$ERROR      Check For Error Message\n         BO    PUTL0100            B. If Yes\n         CLI   NOMSGSKW+1,$NOMSGS  Check For 'NOMSG' Keyword\n         BE    PUTLEXIT            B. If Yes\n\nPUTL0100 DS    0H\n         STM   R0,R7,WRKOLD        Save Output Line Descriptors\n\n         L     R3,WRKUPT@          A(UPT)\n         L     R4,WRKECT@          A(ECT)\n\n         XC    WRKECB,WRKECB       Clear ECB\n         PUTLINE PARM=PUTLINEL,UPT=(R3),ECT=(R4),ECB=WRKECB,           *\n               OUTPUT=(WRKOLD,TERM,SINGLE,INFOR),                      *\n               MF=(E,WRKIOPL)      Write The Message\n\nPUTLEXIT DS    0H\n         NI    WRKFLAG,255-$ERROR\n\n         #RESTORE ,                Restore All Registers\n\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PARMLIB Data Set Read Subroutine                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nREADPARM #SAVE ,                   Save All Registers\n\n         XC    WRKPARM@,WRKPARM@   Clear 1st Parmlib Record Address\n         XC    WRKPARM#,WRKPARM#   Clear Parmlib Record Count\n\n         LA    R0,WRKDDN           A(DDName Buffer)\n         ST    R0,WRKDDPDE\n         LHI   R0,8                L(DDName Buffer)\n         STH   R0,WRKDDPDE+4\n         MVC   WRKDDN,BLANKS\n\n*-------\n*        Validate And Allocate The PARMLIB Data Set\n*-------\n         CLI   PARMLKW+1,$PARMLIB  Check For 'PARMLIB' Keyword\n         BNE   READ0400            B. If Not\n         ICM   R1,15,PARMLIB       A(Fully Qualified Data Set Name)\n         BZ    READ0400            B. If Not Available\n         LH    R2,PARMLIB+4        L(Fully Qualified Data Set Name)\n\n         LA    R0,WRKDSN           A(Quoted Data Set Name Area)\n         ST    R0,WRKDSPDE\n         MVC   WRKDSN,BLANKS\n         MVI   WRKDSN,C''''        Insert Leading Quote\n         #EXEC -R2,MVC,WRKDSN+1(*-*),0(R1)\n         LA    R1,WRKDSN+1+1(R2)   A(End Of Data Set Name)\n         MVI   0(R1),C''''         Insert Ending Quote\n         AHI   R1,1                A(End Of Data Set Name)\n         LA    R2,WRKDSN           A(Start Of Data Set Name)\n         SR    R1,R2               Calculate Length Of Data Set Name\n         STH   R1,WRKDSPDE+4       Save Quoted Data Set Name Length\n\n         MVC   WRKMEMNM,BLANKS\n         ICM   R1,15,PARMLIB+8     A(Member Name)\n         BZ    READ0400            B. If Not Available\n         LH    R2,PARMLIB+12       L(Member Name)\n         #EXEC -R2,MVC,WRKMEMNM(*-*),0(R1)\n\n         ALLOC DSN=WRKDSPDE,DISP=SHR,                                  *\n               DDNTO=WRKDDN,                                           *\n               ERROR=READ0500\n\n*-------\n*        Use Parmlib Services To Read The Entire IKJTSOxx Member\n*-------\n         L     R1,WRKBUFF@         A(Previous Storage Buffer)\n         ICM   R0,15,WRKBUFFL      Check If A Buffer Already Exists\n         BNZ   READ0200            B. If Yes\n         MVC   WRKBUFFL,=A(PRM_READ_BUFFER_LEN+(1024*80))\nREAD0100 DS    0H\n         L     R0,WRKBUFFL\n         GETMAIN RU,LV=(R0),LOC=ANY\nREAD0200 DS    0H\n         XC    0(PRM_READ_BUFFER_LEN,R1),0(R1)\n         ST    R1,WRKBUFF@\n         LR    R3,R1\n         USING PRM_READ_BUFFER,R3\n         MVC   PRM_READ_BUFF_SIZE,WRKBUFFL\n\n         L     R2,WRKMSGBL         L(IEFPRMLB Messages Buffer)\n         L     R4,WRKMSGB@         A(IEFPRMLB Messages Buffer)\n         USING PRM_Message_Buffer,R4\n         XC    PRM_MESSAGE_HEADER,PRM_MESSAGE_HEADER\n         ST    R2,PRM_MSG_BUFFER_SIZE\n         DROP  R4\n\n         IEFPRMLB REQUEST=READMEMBER,                                  *\n               DDNAME=WRKDDN,                                          *\n               MEMNAME=WRKMEMNM,                                       *\n               READBUF=(R3),                                           *\n               BLANK72=NO,                                             *\n               MSG=NO,                                                 *\n               CALLERNAME=LWAMODID,                                    *\n               RSNCODE=WRKREASN,                                       *\n               RETCODE=WRKRCODE,                                       *\n               MF=(E,WRKPRMPL,COMPLETE)\n\n         LTR   R15,R15\n         BZ    READ0300\n         CLC   WRKRCODE,=A(PRMLB_REQUEST_FAILED)\n         BNE   READ0600            B. If Not Request Failed\n         CLC   WRKREASN,=A(PRMLB_READ_BUFFER_FULL)\n         BNE   READ0600            B. If Not Buffer Full\n\n         L     R5,PRM_BUFF_SIZE_NEEDED\n         A     R5,=A(100*80)       Allow For 100 More Records\n         MVC   WRKBUFFL,PRM_BUFF_SIZE_NEEDED\n         L     R0,PRM_READ_BUFF_SIZE\n\n         FREEMAIN RU,A=(R3),LV=(0)\n         XC    WRKBUFF@,WRKBUFF@\n         B     READ0100\n\n*-------\n*        Return 1st Record Address And Number Of Records\n*-------\nREAD0300 DS    0H\n         ICM   R5,15,PRM_TOTAL_RECORDS\n         BZ    READEXIT            B. If No Records In Member\n         LA    R4,PRM_RECORDS      A(1st Record)\n\n         ST    R5,WRKPARM#         #(Returned Records)\n         ST    R4,WRKPARM@         A(1st Record)\n         B     READEXIT\n\n*-------\n*        PARMLIB Not Specified Or DSN/Member Not Specified\n*-------\nREAD0400 DS    0H\n         LHI   R0,1                Message Contains 1 Segment\n         L     R1,=A(#MSG012)      A(Error Message)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n         B     READEXIT\n\n*-------\n*        PARMLIB Could Not Be Allocated\n*-------\nREAD0500 DS    0H\n         S99FAIL ,\n         B     READEXIT\n\n*-------\n*        PARMLIB Read Failed\n*-------\nREAD0600 DS    0H\n         MVC   WRKINS1(4),=AL2(4+8,#MSG0131)\n         UNPK  WRKINS1+4(9),WRKRCODE(5)\n         L     R15,=A(HEXTABLE-C'0')\n         TR    WRKINS1+4(8),0(R15)\n         MVI   WRKINS1+4+8,C' '\n         MVC   WRKINS2(4),=AL2(4+8,#MSG0132)\n         UNPK  WRKINS2+4(9),WRKREASN(5)\n         L     R15,=A(HEXTABLE-C'0')\n         TR    WRKINS2+4(8),0(R15)\n         MVI   WRKINS2+4+8,C' '\n         LHI   R0,3                Message Contains 3 Segments\n         L     R1,=A(#MSG013)      A(Informational Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         LA    R3,WRKINS2          A(Insert #2)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n         B     READEXIT\n\n*-------\n*        TERMINATE                                                    *\n*-------\nREADEXIT DS    0H\n         FREE  DDN=WRKDDPDE        Free Any Allocated Data Set\n\n         #RESTORE ,                Restore All Registers\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Replace The Entire Table                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nREPTABLE #SAVE ,                   Save All Registers\n         LHI   R15,0               Set Return Code\n\n         XC    WRKTAB@,WRKTAB@     Clear Previous Table Address\n         L     R5,WRKTAB@@         A(Current Table Address Address)\n         L     R6,WRKTABL@         A(Current Table Length Address)\n         ICM   R14,15,0(R5)        A(Current Table)\n         BZ    REPT0100            B. If No Previous Table\n         ST    R14,WRKTAB@         Save Old Table Address\n\n*-------\n*        Acquire A New Table And Anchor It In The LWA\n*-------\nREPT0100 DS    0H\n         #CALL AUTH                Get Into Supervisor State, Key Zero\n         BNZ   REPTEXIT            B. If Not Authorized\n\n         SLR   R2,R2               Clear New Table Address\n         SLR   R3,R3\n         ICM   R3,3,WRKTEMPL       L(Replacement Table)\n         BZ    REPT0200            B. If No New Table\n\n         GETMAIN RU,LV=(R3),SP=252,LOC=BELOW\n         ST    R1,WRKAUTH@         Save Authorized Table Address\n         LR    R2,R1\n         STH   R3,WRKAUTHL         Save Authorized Table Length\n\n         L     R4,WRKTEMP@         A(New Table Address)\n         #MVCL (R1),(R4),LEN=(R3)  Copy New Table To Authorized Storage\n\n         ST    R2,0(,R5)           Save New Table Address\n         STH   R3,0(,R6)           Save New Table Length\n\n         L     R14,WRKLWA@         A(LWA)\n         USING LWA,R14\n\n         MVC   LWAPRMLB,WRKPRMLB   Reset //STEPLIB Flags In LWA\n         OC    LWAVFLGS,WRKVFLGS   Ensure \"LOADED\" Flag Is On\n\n         DROP  R14\n\n*-------\n*        Release The Old Table's Storage If A Length Was Available\n*-------\nREPT0200 DS    0H\n         ICM   R1,15,WRKTAB@       A(Previous Table)\n         BZ    REPT0300            B. If No Previous Table\n         SLR   R0,R0\n         ICM   R0,3,WRKTABL        A(Previous Table Length)\n         BZ    REPT0300            B. If No Previous Table\n         FREEMAIN RU,A=(1),LV=(0),SP=252\n\nREPT0300 DS    0H\n         #CALL DEAUTH              Return To Original State & Key\n\n         LHI   R15,0               Set Return Code\n\nREPTEXIT #RESTORE R15=(R15)        Restore All Registers\n\n         LTR   R15,R15             Set Condition Code\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Save Current Keyword's Operand                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nSAVEKW   #SAVE ,                   Save All Registers\n         XC    WRKDATAL,WRKDATAL   Initialize Operand Length\n         MVC   WRKDATA,BLANKS      Initialize Operand Value\n\n         ICM   R2,15,0(R1)         A(NAME)\n         BZ    SAVE0900            B. If Not Available\n         ICM   R3,3,4(R1)          L(NAME)\n         BZ    SAVE0900            B. If Not Available\n         STH   R3,WRKDATAL         Save Operand Length\n         #EXEC -R3,MVC,WRKDATA(*-*),0(R2)\n         B     SAVEEXIT\n\nSAVE0900 DS    0H\n         LHI   R0,2                Message Contains 2 Segments\n         L     R1,=A(#MSG006)      A(Error Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\nSAVEEXIT #RESTORE ,                Restore All Registers\n\n         TM    WRKDATA,X'BF'       Check If A Name Exists\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Dynamic Work Area                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         #STARTWA PATCH=NO\n\n         DYNSPACE ,                Dynamic Allocation Area\n         DS    XL256               In Case Of Overflow\n\n         IEFPRMLB MF=(L,WRKPRMPL)\nPUTLINEL PUTLINE MF=L              PUTLINE Parameter List\n         READ  DECB,SF,*-*,*-*,'S',MF=L\n\nWRKCALL  CALL  ,(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),VL,MF=L\nWRKLINK@ DS    A                   ISPLINK ROUTINE ADDRESS\n\nBLANKS   DS    CL80                Initialized Blanks\n\nWRKDBL   DS    D\nWRKECB   DS    F                   ECB\nWRKECT@  DS    A                   ECT Address\nWRKUPT@  DS    A                   UPT Address\n\nWRKVFLGS DS    X                   LWAVFLGS\nWRKFLAG  DS    X                   General Flag Byte\n$SUPER   EQU   X'80'               - Entered In Supervisor State\n$APF     EQU   X'40'               - Module Is APF Authorized\n$SETSUP  EQU   X'20'               - Changed To Supervisor State\n$SETKEY0 EQU   X'10'               - Changed To Key Zero\n$MSG_NF  EQU   X'08'               - Issue \"Not Found\" Message\n$MSG_F   EQU   X'04'               - Issue \"Found\" Message\n$ERROR   EQU   X'02'               - This Is An Error Message\n$EDITTAB EQU   X'01'               - Table Specified For EDIT\n\nWRKOPSWK DS    X                   Original PSW Key\n\n         CNOP  0,4\nWRKINS1  DS    AL2,AL2,CL80        PUTLINE Message Insert #1\nWRKINS2  DS    AL2,AL2,CL80        PUTLINE Message Insert #2\nWRKINS3  DS    AL2,AL2,CL80        PUTLINE Message Insert #3\nWRKINS4  DS    AL2,AL2,CL80        PUTLINE Message Insert #4\nWRKINS5  DS    AL2,AL2,CL80        PUTLINE Message Insert #5\nWRKINS6  DS    AL2,AL2,CL80        PUTLINE Message Insert #6\n\nWRKIOPL  DS    4F                  IOPL\nWRKLWA@  DS    A                   LWA Address\nWRKOLD   DS    F                   Number Of Message Segments\n         DS    A                   A(Message Text)\n         DS    A                   A(Message Insert 1)\n         DS    A                   A(Message Insert 2)\n         DS    A                   A(Message Insert 3)\n         DS    A                   A(Message Insert 4)\n         DS    A                   A(Message Insert 5)\n         DS    A                   A(Message Insert 6)\n\nWRKPPL   DS    7F                  PPL\nWRKPDL1  DS    A                   PDL\nWRKPDL2  DS    A                   PDL (IKJTSOxx Section Parse)\n\nWRKKW@   DS    A                   Keyword Matching Found Table\n\nWRKDDPDE DS    A,AL2,CL8           DD Name PDE\nWRKDDN   EQU   WRKDDPDE+6,8        DD Name\nWRKDSPDE DS    A,AL2,CL46          Data Set Name PDE\nWRKDSN   EQU   WRKDSPDE+6,46       Data Set Name\nWRKMNPDE DS    A,AL2,CL8           Member Name PDE\nWRKMEMNM EQU   WRKMNPDE+6,8        Member Name\n\nWRKZDSN  DS    CL44                ISPF Message DSName\nWRKUPDTE DS    C                   Edit Performed Update (Y/N)\nWRKSEL1  DS    C                   ISPF Selection Option\nWRKSEL2  DS    C                   ISPF Selection Option\nWRKSEL3  DS    C                   ISPF Selection Option\nWRKSEL4  DS    C                   ISPF Selection Option\n\n         CNOP  0,4\nWRKCMDNL DS    AL2                 IKJTSOxx Section Command Length\nWRKCMDNM DS    CL8                 IKJTSOxx Section Command\n\nWRKCMD@  DS    A                   IKJTSOxx Buffer Section Start\nWRKCMDE@ DS    A                   IKJTSOxx Buffer Section End\n\nWRKCBUF@ DS    A                   Command Buffer Address\nWRKCBUFL DS    F                   Command Buffer Length\n\nWRKR13   DS    F                   Register 13 Save Area\nWRKR14   DS    F                   Register 14 Save Area\nWRKR15   DS    F                   Register 15 Save Area\n\nWRKREASN DS    F                   IEFPRMLB Reason Code\nWRKRCODE DS    F                   IEFPRMLB Return Code\nWRKBUFF@ DS    A                   IEFPRMLB Return Buffer Address\nWRKBUFFL DS    F                   IEFPRMLB Return Buffer Length\nWRKMSGB@ DS    A                   IEFPRMLB Returned Message Buffer\nWRKMSGBL DS    F                   IEFPRMLB Returned Message Buffer Len\nWRKMSGBE DS    A                   End Of Buffer\n\nWRKCURB@ DS    A                   Current Buffer Address\nWRKCURBL DS    F                   Remaining Buffer Length\n\nWRKPARM@ DS    A                   First Parmlib Record Address\nWRKPARM# DS    F                   Number Of Parmlib Records Returned\n\nWRKDATAL DS    AL2                 Current Keyword's Operand Length\nWRKDATA  DS    CL80                Current Keyword's Operand\nWRKNAMEL DS    AL2                 Current Command/Program Name Length\nWRKNAME  DS    CL8                 Current Command/Program Name\nWRKNAMEO DS    A                   Current Entry's Offset In Table\nWRKNEWNL DS    AL2                 New Command/Program Name Length\nWRKNEWN  DS    CL8                 New Command/Program Name\nWRKTMPNL DS    AL2                 Save Area For NAME Length\nWRKTMPN  DS    CL8                 Save Area For NAME\n\nWRKTABNL DS    AL2                 Current Table Name Length\nWRKTABNM DS    CL8                 Current Table Name\nWRKTAB@@ DS    A                   Current Table Address Pointer\nWRKTAB@  DS    A                   Current Table Address\nWRKTABCT DS    F                   Current Command List Count\nWRKTABE@ DS    A                   Current Table End Address\nWRKTABPK DS    X                   Current Table PSW Key\nWRKTABF  DS    X                   Current Table Flags\nWRK$STEP EQU   X'80'   1... ....   Table Was Loaded From //STEPLIB\nWRKTABEL DS    AL2                 Current Table Entry Length\nWRKTABX@ DS    A                   Current Table End Address\nWRKTABL@ DS    A                   Current Table LWA Length Address\nWRKTABL  DS    AL2                 Current Table LWA Length\n\nWRKTEMP@ DS    A                   Temporary KEY8 Table Address\nWRKTEMPL DS    H                   Temporary KEY8 Table Length\n\nWRKAUTH@ DS    A                   New KEY0 Table Address\nWRKAUTHL DS    H                   New KEY0 Table Length\n\nWRKPRMLB DS    X                   Original LWAPRMLB Value\n\n         CNOP  0,4\nWRKDCB   DS    CL(MODCBUL)         DCB\n         CNOP  0,4\nWRKDCBE  DS    CL(MODCBEUL)        DCBE\n         CNOP  0,4\nWRKOPEN  DS    CL(MODOPENL)        OPEN Parameter List\n         CNOP  0,4\nWRKCLOSE DS    CL(MODCLOSEL)       CLOSE Parameter List\n         CNOP  0,4\nWRKLOAD  DS    XL(MODLOADL)        LOAD Parameter List\n\nWRKDCBBU DS    A                   DCB Buffer Address\nWRKDCBBE DS    A                   DCB Buffer End Address\n\nWRKLOAD@ DS    A                   Directed Load Buffer Address\nWRKLOADL DS    F                   Directed Load Buffer Length\n\nWRKBLDL  DS    0H\nWRKBLDE# DS    H                   Number Of Entries In List\nWRKBLDEL DS    H                   Length Of Entries In List\nWRKBLDLI DS    XL58                Returned Directory Information\nWRKBLDLL EQU   *-WRKBLDL           BLDL Parameter List Length\n\nWRKMOD@  DS    A                   Loaded Module Address\nWRKMODL  DS    H                   Loaded Module Length\n\nWRKTAPP@ DS    A                   IKJEFTAP Table Pointer Address\nWRKTAPL@ DS    A                   IKJEFTAP Table Length Address\nWRKTAPL  DS    AL2                 IKJEFTAP Table Length In LWA\nWRKTAPF  DS    C                   IKJEFTAP Flags\n         DS    X\n\nWRKTE2P@ DS    A                   IKJEFTE2 Table Pointer Address\nWRKTE2L@ DS    A                   IKJEFTE2 Table Length Address\nWRKTE2L  DS    AL2                 IKJEFTE2 Table Length In LWA\nWRKTE2F  DS    C                   IKJEFTE2 Flags\n         DS    X\n\nWRKTE8P@ DS    A                   IKJEFTE8 Table Pointer Address\nWRKTE8L@ DS    A                   IKJEFTE8 Table Length Address\nWRKTE8L  DS    AL2                 IKJEFTE8 Table Length In LWA\nWRKTE8F  DS    C                   IKJEFTE8 Flags\n         DS    X\n\nWRKTNSP@ DS    A                   IKJEFTNS Table Pointer Address\nWRKTNSL@ DS    A                   IKJEFTNS Table Length Address\nWRKTNSL  DS    AL2                 IKJEFTNS Table Length In LWA\nWRKTNSF  DS    C                   IKJEFTNS Flags\n         DS    X\n\nDCBEXIT@ DS    F                   DCB Open Exit Pointer\nWDCBEXIT DS    CL(STUBLEN)         24-Bit DCB Open Exit Stub\n\nSTACK15  DS    F                   Stack Save Area\nSTACKNX@ DS    A                   Next Save Area On The Stack\nSTACKEND DS    A                   End Of Stack Address\nSTACK    DS    (10*16)F            Register Save Area Stack\nSTACKLEN EQU   *-STACK             Length Of Save Area Stack\n         #STOPWA ,\n         EJECT 1\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Command Parameters                                           *\n*                                                                     *\n*     Syntax:                                                         *\n*                                                                     *\n*        LWATMGR ADD                                                  *\n*             { AUTHTSF  | AUTHCMD  | AUTHPGM  | NOTBKGND }           *\n*               NAME(command/program)                                 *\n*                                                                     *\n*        LWATMGR BUILD                                                *\n*               LIST(dataset(member))                                 *\n*                                                                     *\n*        LWATMGR DELETE                                               *\n*             { AUTHTSF  | AUTHCMD  | AUTHPGM  | NOTBKGND }           *\n*               NAME(command/program)                                 *\n*                                                                     *\n*        LWATMGR DISPLAY                                              *\n*             { AUTHTSF  | AUTHCMD  | AUTHPGM  | NOTBKGND | ALL }     *\n*                                                                     *\n*        LWATMGR RELOAD                                               *\n*             { AUTHTSF  | AUTHCMD  | AUTHPGM  | NOTBKGND | ALL }     *\n*               LOADLIB(dataset)                                      *\n*                                                                     *\n*        LWATMGR REPLACE                                              *\n*             { AUTHTSF  | AUTHCMD  | AUTHPGM  | NOTBKGND }           *\n*               NAME(command/program)                                 *\n*               NEWNAME(command/program)                              *\n*                                                                     *\n*        LWATMGR UPDATE                                               *\n*             { AUTHTSF  | AUTHCMD  | AUTHPGM  | NOTBKGND | ALL }     *\n*               PARMLIB(dataset(member))                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PRINT NOGEN\n\nPCL      IKJPARM DSECT=MAINPCL\n\nFUNCKW   IKJKEYWD DEFAULT='DISPLAY'\n         IKJNAME 'ADD',ALIAS='ANY'\n$ADD     EQU   1\n         IKJNAME 'BUILD'\n$BUILD   EQU   2\n         IKJNAME 'DELETE'\n$DELETE  EQU   3\n         IKJNAME 'DISPLAY'\n$DISPLAY EQU   4\n         IKJNAME 'RELOAD'\n$RELOAD  EQU   5\n         IKJNAME 'REPLACE'\n$REPLACE EQU   6\n         IKJNAME 'UPDATE'\n$UPDATE  EQU   7\n\nALLKW    IKJKEYWD ,\n         IKJNAME 'ALL',INSERT='IKJEFTAP IKJEFTE2 IKJEFTE8 IKJEFTNS'\nAPKW     IKJKEYWD ,\n         IKJNAME 'IKJEFTAP',ALIAS=('TAP','AUTHTSF')\n$AUTHTSF EQU   1\nE2KW     IKJKEYWD ,\n         IKJNAME 'IKJEFTE2',ALIAS=('TE2','AUTHCMD')\n$AUTHCMD EQU   1\nE8KW     IKJKEYWD ,\n         IKJNAME 'IKJEFTE8',ALIAS=('TE8','AUTHPGM')\n$AUTHPGM EQU   1\nNSKW     IKJKEYWD ,\n         IKJNAME 'IKJEFTNS',ALIAS=('TNS','NOTBKGND')\n$NOTBKGND EQU  1\n\nNAMEKW   IKJKEYWD ,\n         IKJNAME 'NAME',SUBFLD=NAMESUBF\n\nNEWCMDKW IKJKEYWD ,\n         IKJNAME 'NEWNAME',SUBFLD=NEWSUBF\n\nPARMLKW  IKJKEYWD ,\n         IKJNAME 'PARMLIB',                                            *\n               SUBFLD=PARMSUBF\n$PARMLIB EQU   1\n\nLOADKW   IKJKEYWD ,\n         IKJNAME 'LOADLIB',                                            *\n               SUBFLD=LOADSUBF\n\nREC8KW   IKJKEYWD ,\n         IKJNAME 'LIST',                                               *\n               SUBFLD=REC8SUBF\n\nNOMSGSKW IKJKEYWD ,\n         IKJNAME 'NOMESSAGES',ALIAS='NOMSG'\n$NOMSGS  EQU   1\n\nNAMESUBF IKJSUBF  ,\nNAME     IKJIDENT 'NAME',FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=8,         *\n               PROMPT='Command Or Program Name'\n\nNEWSUBF  IKJSUBF  ,\nNEWNAME  IKJIDENT 'NEWNAME',FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=8,      *\n               PROMPT='New Command Or Program Name'\n\nPARMSUBF IKJSUBF  ,\nPARMLIB  IKJPOSIT DSNAME,USID,UPPERCASE,                               *\n               PROMPT='IKJTSOXX Input Data Set'\n\nLOADSUBF IKJSUBF  ,\nLOADLIB  IKJPOSIT DSNAME,USID,UPPERCASE,                               *\n               PROMPT='IKJTABLS Load Library'\n\nREC8SUBF IKJSUBF  ,\nREC8     IKJPOSIT DSNAME,USID,UPPERCASE,                               *\n               PROMPT='Table List Data Set'\n\n         IKJENDP ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        IKJTSOXX Statements                                          *\n*                                                                     *\n*        Syntax:                                                      *\n*                                                                     *\n*        AUTHCMD  NAMES(...LIST...)                                   *\n*        AUTHPGM  NAMES(...LIST...)                                   *\n*        NOTBKGND NAMES(...LIST...)                                   *\n*        AUTHTSF  NAMES(...LIST...)                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nPARMPCL  IKJPARM DSECT=TSOXXPCL\n\nNAMESKW  IKJKEYWD ,\n         IKJNAME 'NAMES',SUBFLD=LISTSUBF\n\nLISTSUBF IKJSUBF  ,\nLIST     IKJIDENT 'NAME',LIST,                                         *\n               FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=8,                   *\n               PROMPT='Command Or Program Name'\n\n         IKJENDP ,\n\n         PRINT GEN\n\n         IKJEFLWA ,                LOGON Work Area\n\n         IEFZPMAP ,                IEFPRMLB Parameter List\n         IEFZPRC ,                 IEFPRMLB Return Codes\n\n         IHAPDS ,                  PDS / PDSE Directory Entry\n         IHARLD ,                  Linkage Editor Records\n         IHADCBE ,                 Data Control Block Extension\n         IKJEFFDF DFDSECT=YES,DFDSEC2=YES\n\n         #DSECTS ALLOC,ASCB,ASXB,CVT,DCB,PSA,TSO\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LWATMGR$": {"ttr": 7684, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00T\\x01\\x081?\\x01\\x082\\x9f\\x13Q\\x00\\x1e\\x00\\x1e\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2008-11-08T00:00:00", "modifydate": "2008-11-24T13:51:54", "lines": 30, "newlines": 30, "modlines": 0, "user": "JCL"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,ESD,RLD,BATCH)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.FILE452.MACLIB    <== DAN'S MACROS\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT477.FILE797(LWATMGR)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,4),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY   LWATMGR\n SETSSI  CB477797\n SETCODE AC(1)\n NAME    LWATMGR(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LWATMGR@": {"ttr": 7686, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x01\\x01\\x082o\\x01\\x082o\\x02\\x00\\x00@\\x00?\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T02:00:01", "lines": 64, "newlines": 63, "modlines": 0, "user": "HELP"}, "text": ")F Purpose -\n     This program allows you to display and update the authorized\n     command tables that have been loaded into your address space.\n)X Syntax -\n         LWATMGR ADD      {table-name}   NAME(name)\n         LWATMGR BUILD    {table-name}   LIST(dsname\u00dd(member)\u00a8)\n         LWATMGR DELETE   {table-name}   NAME(name)\n         LWATMGR DISPLAY  {table-name}\n         LWATMGR RELOAD   {table-name}   LOADLIB(dsname)\n         LWATMGR REPLACE  {table-name}   NAME(old)  NEWNAME(new)\n         LWATMGR UPDATE   {table-name}   PARMLIB(dsname(member))\n\n   The table names are:    AUTHTSF\n                           AUTHCMD\n                           AUTHPGM\n                           NOTBKGND\n         Or \"ALL\" to process all of the above.\n)O Functions -\n))ADD   - This will add a new command or program name into the\n          specific table.\n\n   Example: LWATMGR ADD AUTHPGM NAME(mypgmnm)\n\n))BUILD - This will re-create multiple tables at one time by\n          reading the 1st 8 bytes from the LIST data set.  The\n          LIST data set entries must follow specific identifier\n          records. \"---AP---\" for the AUTHTSF table, \"---E2---\"\n          for the AUTHCMD table, \"---E8---\" for the AUTHPGM table\n          and '---NS---' for the NOTBKGND table.  If a list\n          section within this input file contains no entries the\n          table will not be updated.\n          As the LIST data set only uses the 1st 8 bytes of each\n          record, the LRECL may be as little as 8.  This allows\n          for a lot of tables in a very small amount of space.\n\n   Example: LWATMGR BUILD ALL LIST(fb8.pds(list01))\n\n))DELETE - This will remove an existing command or program name from\n          the specific table.\n\n   Example: LWATMGR DELETE AUTHPGM NAME(mypgmnm)\n\n))DISPLAY - This will display information about the various\n            authorization tables and their contents.\n            This function allows you to specify a table of \"ALL\" or\n            specify no table name at all which will default to \"ALL\".\n\n   Example: LWATMGR DISPLAY ALL\n\n))RELOAD - This allows you to load loadmodule versions of the various\n           tables.  The input LOADMODULE library must have the tables\n           linked as alias names to IKJTABLS.\n\n   Example: LWATMGR RELOAD LOAD(test.loadlib)\n\n))REPLACE - This allows you to replace an entry in a specific table.\n\n   Example: LWATMGR REPLACE AUTHPGM NAME(iebcopy) NEWNAME(XYZcopy)\n\n))UPDATE - This allows you to update tables based on input with\n           synatax identical to the IKJTSOxx parmlib member.\n\n   Example: LWATMGR UPDATE ALL PARMLIB('SYS1.PARMLIB(IKJTSO99)')\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MACLIB": {"ttr": 7688, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x10\\x01\\x17\\x11?\\x01\\x17\\x11?\\x14#>\\x1d>\\x1d\\x00\\x00\\xd4\\xc1\\xc3\\xd3\\xc9\\xc2@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2017-04-23T00:00:00", "modifydate": "2017-04-23T14:23:10", "lines": 15901, "newlines": 15901, "modlines": 0, "user": "MACLIB"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "MACLIBO": {"ttr": 14088, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\t\\x01\\x082o\\x01\\x17\\x11?\\x14\"3D3D\\x00\\x00\\xe7\\xd4\\xc9\\xe3@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2017-04-23T14:22:09", "lines": 13124, "newlines": 13124, "modlines": 0, "user": "XMIT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "RDHSVCA8": {"ttr": 19463, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00Y\\x01\\x11\\x08o\\x01\\x19\"o\\x08\\x13\\x00\\x12\\x00\\x12\\x00\\x03\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2011-03-27T00:00:00", "modifydate": "2019-08-14T08:13:59", "lines": 18, "newlines": 18, "modlines": 3, "user": "SBGOLOB"}, "text": "//IBMUSERS JOB (0,0),'TEST',NOTIFY=&SYSUID,\n//             CLASS=A,MSGCLASS=X,MSGLEVEL=(1,1)\n//*\n//** INSERT/REMOVE/REPLACE an SVC - or - Dump the SVCTABLE\n//*\n//*    This job was created for the purpose of testing the SVC\n//*  install program.  This jobstream installs RDHAPSVC which is\n//*  the SVC that provides APF Authorization in an ISPF\n//*  environment.\n//*\n//*UMP      EXEC PGM=RDHINSTL,PARM=DUMP\n//*REMOVE   EXEC PGM=RDHINSTL,PARM='REMOVE,RDHAPSVC,168'\n//*REPLACE  EXEC PGM=RDHINSTL,PARM='REPLACE,RDHAPSVC,168'\n//*\n//INSERT    EXEC PGM=RDHINSTL,PARM='INSERT,RDHAPSVC,168'\n//STEPLIB  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB  <== AUTHORIZED LIBRARY\n//SYSPRINT DD  SYSOUT=*\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SAMPLIST": {"ttr": 19465, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x082\\x8f\\x01\\x082\\x8f\\x00E\\x00C\\x00C\\x00\\x00\\xe7\\xd4\\xc9\\xe3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-23T00:00:00", "modifydate": "2008-11-23T00:45:00", "lines": 67, "newlines": 67, "modlines": 0, "user": "XMIT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "SAMPLOAD": {"ttr": 19467, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x082\\x8f\\x01\\x082\\x8f\\x00H\\x00Z\\x00Z\\x00\\x00\\xe7\\xd4\\xc9\\xe3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-23T00:00:00", "modifydate": "2008-11-23T00:48:00", "lines": 90, "newlines": 90, "modlines": 0, "user": "XMIT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "SAMPPARM": {"ttr": 19470, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00I\\x01\\x081O\\x01\\x082\\x9f\\x02G\\x029\\x022\\x00\\x00\\xc4\\xc1\\xe3\\xc1@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2008-11-09T00:00:00", "modifydate": "2008-11-24T02:47:49", "lines": 569, "newlines": 562, "modlines": 0, "user": "DATA"}, "text": "AUTHCMD NAMES(          /* AUTHORIZED COMMANDS      */      +\n    $$               +\n    $HOWMVS          +\n    $MDSMAIN         +\n    ABUDSN           +\n    AD               +\n    ADB2UTIL         +\n    ADDDIR           +\n    ADDFILE          +\n    ADDGROUP         +\n    ADDSD            +\n    ADDUSER          +\n    ADIR             +\n    ADNR             +\n    ADYOPCMD         +\n    AF               +\n    AG               +\n    AHOWMVS          +\n    ALD              +\n    ALF              +\n    ALG              +\n    ALTDIR           +\n    ALTDSD           +\n    ALTER            +\n    ALTFILE          +\n    ALTGROUP         +\n    ALTUSER          +\n    ALU              +\n    APCACBL          +\n    APCANB           +\n    APCARB           +\n    APCAUB           +\n    APFCMD           +\n    ASUB             +\n    AU               +\n    BACKUP           +\n    BCMDEL           +\n    BCMDEL1          +\n    BCMNAUTH         +\n    BCMNUPD          +\n    BDATA            +\n    BDMNUPD          +\n    BINDDATA         +\n    BLKUPD           +\n    BUDDSN           +\n    BUDGET           +\n    CAE$BQRY         +\n    CANCELU          +\n    CAS9UDTN         +\n    CDELPAIR         +\n    CDMRSTAT         +\n    CDSCB            +\n    CESTPAIR         +\n    CHKPT            +\n    CINMX            +\n    CLCHECK          +\n    CNVTCAT          +\n    CO               +\n    COFDMON          +\n    CONNECT          +\n    CONSPROF         +\n    CPSCB            +\n    CQUERYSG         +\n    CQX              +\n    CRECOVER         +\n    CSCAN            +\n    CSUSPEND         +\n    DCAS             +\n    DD               +\n    DDIR             +\n    DEF              +\n    DEFINE           +\n    DEL              +\n    DELDIR           +\n    DELDSD           +\n    DELETE           +\n    DELFILE          +\n    DELGROUP         +\n    DELUSER          +\n    DF               +\n    DG               +\n    DITTO            +\n    DITTOA           +\n    DITTOU           +\n    DMRSHR           +\n    DRI              +\n    DU               +\n    ERWMAUTH         +\n    EX               +\n    EXP              +\n    EXPORT           +\n    EYU9XENF         +\n    EZAZSSI          +\n    EZBREINI         +\n    EZBTNINI         +\n    FCESTABL         +\n    FCQUERY          +\n    FCWITHDR         +\n    FTPD             +\n    FTPDNS           +\n    GJTRUCBS         +\n    IEBCOPY          +\n    IKJEHDSF         +\n    IKJEHDS1         +\n    IKJPRMLB         +\n    IM               +\n    IMP              +\n    IMPORT           +\n    IOBSNMP          +\n    IQIEXPN          +\n    IQIMAIN          +\n    IQIQUERY         +\n    IQIQUIT          +\n    IRRDPI00         +\n    ISPICP           +\n    ISRPCP           +\n    LBADV            +\n    LBAGENT          +\n    LD               +\n    LDATA            +\n    LDIR             +\n    LDIRECT          +\n    LF               +\n    LFILE            +\n    LG               +\n    LISTB            +\n    LISTBC           +\n    LISTD            +\n    LISTDATA         +\n    LISTDS           +\n    LISTDSD          +\n    LISTGRP          +\n    LISTUSER         +\n    LLWA             +\n    LMRKTSO          +\n    LOCKTERM         +\n    LOOK             +\n    LPQ              +\n    LPR              +\n    LPRM             +\n    LPROC            +\n    LSLT             +\n    LU               +\n    MAKEUSER         +\n    MIMTSO           +\n    MODDVIPA         +\n    MU               +\n    MVPMAIN          +\n    MVPXDISP         +\n    MVSCPCMD         +\n    NAMEDXFR         +\n    NAMED4           +\n    NDVRC1           +\n    NETSTAT          +\n    NSUPDATE         +\n    NSUPDAT4         +\n    NYPPW            +\n    OC               +\n    OMPROUTE         +\n    OP               +\n    OPER             +\n    OPERATOR         +\n    OPINFO           +\n    OPING            +\n    OPSCMD           +\n    OPSCONSL         +\n    OPSOSCMD         +\n    OPSPARM          +\n    OPSREPLY         +\n    OPSTAT           +\n    OPSWTO           +\n    OSNMPD           +\n    OTRACERT         +\n    PACKRAT          +\n    PARMLIB          +\n    PASSWORD         +\n    PDIR             +\n    PDSCLEAN         +\n    PDSEAUTH         +\n    PE               +\n    PERMDIR          +\n    PERMFILE         +\n    PERMIT           +\n    PF               +\n    PHRASE           +\n    PING             +\n    POPPER           +\n    PRINT            +\n    PW               +\n    Q                +\n    QUEUE            +\n    Q522             +\n    RACDCERT         +\n    RACFSIM          +\n    RACLINK          +\n    RACONVRT         +\n    RACPRIV          +\n    RALT             +\n    RALTER           +\n    RDEF             +\n    RDEFINE          +\n    RDEL             +\n    RDELETE          +\n    RE               +\n    RECEIVE          +\n    RELOGON          +\n    REMOVE           +\n    REPRO            +\n    RESOLVE          +\n    REVIEW           +\n    REVVSAM          +\n    REXCPCMD         +\n    RL               +\n    RLIST            +\n    RLOAD            +\n    RLOADA           +\n    RMM              +\n    RPF              +\n    RPFE             +\n    RSH              +\n    RSHD             +\n    RVARY            +\n    SAMENDM          +\n    SDSF             +\n    SE               +\n    SEARCH           +\n    SECURE           +\n    SEND             +\n    SETC             +\n    SETCACHE         +\n    SETPASSW         +\n    SETPW            +\n    SETPW2           +\n    SETR             +\n    SETROPTS         +\n    SETUSER          +\n    SHCDS            +\n    SM               +\n    SMTP             +\n    SNTPD            +\n    SPACE            +\n    SPY              +\n    SR               +\n    SRDIR            +\n    SRF              +\n    SRFILE           +\n    SRSTAT           +\n    STEPLIB          +\n    STEPLIBN         +\n    SU               +\n    SYNC             +\n    SYSPROG          +\n    TEAEXTSO         +\n    TERM             +\n    TERMINAL         +\n    TESTA            +\n    TESTAUTH         +\n    TMONCICS         +\n    TMONDB2          +\n    TMONIMS          +\n    TMONMVS          +\n    TRACERTE         +\n    TRANSMIT         +\n    TRAPFWD          +\n    TRMD             +\n    TSOENQ           +\n    TSOSMS           +\n    TSUB             +\n    UKEYCSA          +\n    USAT             +\n    USIT             +\n    USOT             +\n    USUT             +\n    VERIFY           +\n    VFY              +\n    VIEWUSER         +\n    VLFNOTE          +\n    VMCF             +\n    VU               +\n    WAITT            +\n    WHOENQ           +\n    WSSTAT           +\n    XD               +\n    XDCCALLA         +\n    XDCCMDA          +\n    XF               +\n    XMDSMAIN         +\n    XMIT             +\n    XTRCUSER         +\n    XU               +\n    YKCONMSG         +\n    ZAP              +\n    ZAP$             +\n    ZAPV             +\n    USWT             +\n    LWACMD           +\n    LWATMGR          +\n    LWATMGW          +\n    LWATMGX          +\n    LWATMGY          +\n    LWATMGZ          +\n                     )\n                        /*                          */\nAUTHPGM NAMES(          /* AUTHORIZED PROGRAMS      */      +\n    ADRDSSU      +\n    ALPAUTH      +\n    APCACBL      +\n    APCANB       +\n    APCARB       +\n    APCAUB       +\n    APFPGM       +\n    ARMAUTH      +\n    CONSPROF     +\n    CSFDAUTH     +\n    CSFDPKDS     +\n    CTMAES       +\n    CTMDFL       +\n    CTMRUN       +\n    CTRCTR       +\n    CTRSPL       +\n    EMCICS61     +\n    EMCSNAP      +\n    EMCTF        +\n    EMCTFU       +\n    EQQMINOR     +\n    ERWMAUTH     +\n    FDRABR       +\n    FDRABRUT     +\n    FDRCPK       +\n    FDREPORT     +\n    FDRMONA      +\n    FDRPASA      +\n    FDRQUERY     +\n    FDRSRSA      +\n    GIMSMP       +\n    GJTRUCBS     +\n    ICADCFGS     +\n    ICADCT       +\n    ICADDCT      +\n    ICADFTPD     +\n    ICADIKED     +\n    ICADPFTP     +\n    ICADSLOG     +\n    ICADSOCK     +\n    ICADSOXD     +\n    ICADSTAK     +\n    ICHDSM00     +\n    ICHUEX00     +\n    ICHUT100     +\n    ICHUT200     +\n    ICHUT400     +\n    IDCAMS       +\n    IEBCOPY      +\n    IKJEFF76     +\n    IOEAGFMT     +\n    IOEAGSLV     +\n    IOEBAK       +\n    IOEBOS       +\n    IOECM        +\n    IOEDCEER     +\n    IOEDFSXP     +\n    IOEFTS       +\n    IOEGRWAG     +\n    IOEMAPID     +\n    IOENEWAG     +\n    IOESALVG     +\n    IOESCOUT     +\n    IOESMBPW     +\n    IOEUDBG      +\n    IOEZADM      +\n    IRMAUTH      +\n    IRRDIP00     +\n    IRRDPI00     +\n    IRRDSC00     +\n    IRRUT100     +\n    IRRUT200     +\n    IRRUT400     +\n    ITPENTER     +\n    JCLSRB       +\n    KEPSTCTO     +\n    KOBROUTR     +\n    KOBSPFAU     +\n    LOCKTERM     +\n    MIMTSO       +\n    MVPXDISP     +\n    NDVRC1       +\n    OBROUTR      +\n    OBSPFAU      +\n    OLDCOPY      +\n    OMCICS       +\n    OMEGAMON     +\n    OMSPFAU      +\n    PDSCLEAN     +\n    PDSCLEAR     +\n    PDSEAUTH     +\n    PDSFAST      +\n    PING         +\n    PSIPCTL      +\n    RESOLVE      +\n    REVVSAM      +\n    REXCPCMD     +\n    SAMENDM      +\n    SCRAMRE      +\n    SDSF         +\n    SYSPROG      +\n    TESTENQ      +\n    TMONMVS      +\n    TMSIOCAP     +\n    TMSSCR       +\n    TSOENQ       +\n    TSOSPA       +\n    WHOENQ       )\n                        /*                          */\nNOTBKGND NAMES(         /* COMMANDS WHICH MAY NOT BE */  +\n                        /* ISSUED IN THE BACKGROUND  */  +\n   OPER     OPERATOR    /*                           */ +\n   TERM     TERMINAL    /*                           */ +\n   ZAP      ZAPX        )\n                        /*                           */\nAUTHTSF NAMES(          /* PROGRAMS TO BE AUTHORIZED */  +\n    $$           +\n    AAATHCHK     +\n    AACMD001     +\n    AACMD002     +\n    AACMD003     +\n    AACMD004     +\n    AACMD005     +\n    AACMD006     +\n    AACMD007     +\n    AACMD008     +\n    AACMD009     +\n    AACMD014     +\n    AACMD015     +\n    AACNG001     +\n    AACNG002     +\n    AACNG003     +\n    AAGRPUSR     +\n    AAPSWCHK     +\n    AAREP011     +\n    APFCMD       +\n    BACKUP       +\n    BBSDTCPA     +\n    BCMNUPD      +\n    BDMNUPD      +\n    CADU4804     +\n    CADU4805     +\n    CAT01IKB     +\n    CAZ2CTSO     +\n    CDSCB        +\n    CSCCOPY      +\n    CSFDAUTH     +\n    CSFDPKDS     +\n    EMCICS61     +\n    EMCSNAP      +\n    EMCTF        +\n    EMCTFU       +\n    EOUCCSYM     +\n    EQQMINOR     +\n    ERWMAUTH     +\n    EX           +\n    FDRABR       +\n    FDRABRUT     +\n    FDRCPK       +\n    FDREPORT     +\n    FDRMONA      +\n    FDRPASA      +\n    FDRQUERY     +\n    FDRSRSA      +\n    GIMSMP       +\n    GJTRUCBS     +\n    IAMRECVR     +\n    ICADCFGS     +\n    ICADCT       +\n    ICADDCT      +\n    ICADFTPD     +\n    ICADIKED     +\n    ICADPFTP     +\n    ICADSLOG     +\n    ICADSOCK     +\n    ICADSOXD     +\n    ICADSTAK     +\n    ICHDSM00     +\n    ICHUT100     +\n    ICHUT200     +\n    ICHUT400     +\n    ICQASLI0     +\n    IEBCOPY      +\n    IKJEFF76     +\n    IM           +\n    IOEAGFMT     +\n    IOEAGSLV     +\n    IOEBAK       +\n    IOEBOS       +\n    IOECM        +\n    IOEDCEER     +\n    IOEDFSXP     +\n    IOEFTS       +\n    IOEGRWAG     +\n    IOEMAPID     +\n    IOENEWAG     +\n    IOESALVG     +\n    IOESCOUT     +\n    IOEUDBG      +\n    IOEZADM      +\n    IRRDPI00     +\n    IRRDSC00     +\n    IRRUT100     +\n    IRRUT200     +\n    IRRUT400     +\n    JCLSRB       +\n    LSLT         +\n    MIMTSO       +\n    MNAPFPRC     +\n    MNCDTPRC     +\n    MNCD2PRC     +\n    MNGRPPRC     +\n    MNLLTPRC     +\n    MNLPAPRC     +\n    MNPPTPRC     +\n    MNRACPRC     +\n    MNRAUPRC     +\n    MNRFRPRC     +\n    MNSMFPRC     +\n    MNSM4PRC     +\n    MNSTCPRC     +\n    MNSVCPRC     +\n    MXI          +\n    MXITSF       +\n    NDVRC1       +\n    OBROUTR      +\n    OBSPFAU      +\n    OLDCOPY      +\n    OMCICS       +\n    OMEGAMON     +\n    OMSPFAU      +\n    PDSCLEAN     +\n    PDSEAUTH     +\n    PDSFAST      +\n    PMGLAUTH     +\n    PSIPCTL      +\n    PTLTSRB      +\n    RCFRESET     +\n    REATSF       +\n    SAMENDM      +\n    TMONMVS      +\n    TMSIOCAP     +\n    FCHNADJG     +\n    TMSSCR       )\n                        /*                           */\nSEND                    /* SEND COMMAND DEFAULTS     */  +\n   OPERSEND(ON)         /*                           */ +\n   USERSEND(ON)         /*                           */ +\n   SAVE(ON)             /*                           */ +\n   CHKBROD(OFF)         /*                           */ +\n   LOGNAME(SYS1.BRODCAST)  /*                        */\nALLOCATE                /* ALLOCATE COMMAND DEFAULT  */ +\n   DEFAULT(OLD)         /*                           */\nTRANSREC                   /*                        */ +\n   NODESMF((NODENAME,SMF)) /*                        */ +\n   CIPHER(YES)          /*                           */ +\n   SPOOLCL(B)           /*                           */ +\n   OUTWARN(10000,20000) /*                           */ +\n   OUTLIM(15000000)     /*                           */ +\n   VIO(SYSALLDA)        /*                           */ +\n   LOGSEL(LOG)          /*                           */ +\n   LOGNAME(MISC)        /*                           */ +\n   DAPREFIX(TUPREFIX)   /*                           */ +\n   USRCTL(NAMES.TEXT)   /*                           */ +\n   SYSOUT(*)            /*                           */\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SHOWTPV$": {"ttr": 19722, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00W\\x00\\x91\\x12?\\x01\\x19!/\\x10X\\x00\\x1d\\x00\\x0e\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "1991-05-03T00:00:00", "modifydate": "2019-07-31T10:58:57", "lines": 29, "newlines": 14, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,BATCH)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(SHOWTPVT)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY   SHOWTPVT\n SETCODE AC(0)\n SETSSI  CB497731\n NAME    SHOWTPVT(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SHOWTPVT": {"ttr": 19724, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00R\\x00\\x804_\\x01\\x192\\x1f\\x10\\x02\\x030\\x01\\xcf\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1980-12-10T00:00:00", "modifydate": "2019-11-17T10:02:52", "lines": 816, "newlines": 463, "modlines": 0, "user": "SBGOLOB"}, "text": "         TITLE ' SHOW AND EXPLAIN ALL TPVT FIELDS  '\n************************************************************\n*        'SHOWTPVT' OR 'LIST TPVT FIELDS AND EXPLAIN THEM' *\n************************************************************\n         SPACE\n*\n*        This program is in the Public Domain.\n*\n*        THIS PROGRAM WAS CONSTRUCTED FROM THE LPSCB PROGRAM,\n*        WHICH WAS:\n*        WRITTEN BY. BILL GODFREY,  PLANNING RESEARCH CORPORATION.\n*        INSTALLATION. PRC COMPUTER CENTER INC, MCLEAN VA.\n*        DATE WRITTEN. OCTOBER 19 1979.\n*        DATE UPDATED. MAY 10, 1995   SAM GOLOB\n*                      NOV 28, 2016   SAM GOLOB\n*                      MAR 10, 2017   SAM GOLOB\n*        DATE CHANGED. JAN 02, 2019   SAM GOLOB\n*\n*        ATTRIBUTES. RE-ENTRANT.\n*\n*        COMMENTS.\n*            THIS TSO COMMAND SHOWS ALL THE FIELDS OF THE\n*            UNDOCUMENTED IBM CONTROL BLOCK, TPVT, SHORT FOR\n*            \"TSO PARMLIB VECTOR TABLE\", DESCRIBED BY THE IBM\n*            INTERNAL MACRO, IKJTPVT, WRITTEN IN PL/X ONLY.\n*\n*            OF COURSE WE DON'T HAVE THE ORIGINAL IBM MACRO.\n*            WE HAVE RECONSTRUCTED THE IKJTPVT MACRO IN\n*            ASSEMBLER LANGUAGE, AND OUR DESCRIPTION OF IT,\n*            AND ITS FIELDS, IS INCLUDED IN THIS SOURCE CODE.\n*            THE FIELD NAMES IN OUR ASSEMBLER COPY OF THE\n*            MACRO HAVE TO BE CONSIDERED AS ENTIRELY OUR OWN\n*            DESCRIPTIONS, EVEN THOUGH SOME OF THEM MAY\n*            CLOSELY RESEMBLE THEIR POSSIBLE IBM DESCRIPTIONS\n*            (WHICH WE DON'T REALLY KNOW).\n*\n*        CHANGE LOG:\n*           JDM - JIM MARSHALL\n*           SBG - SAM GOLOB\n*\n*     These remarks pertain to the LPSCB program:\n*     JDM    02APR91 - ADDED DSECTS TO REPLACE HARDCODED OFFSETS JDM1\n*     SBG    28NOV16 - LIST 8 HEX DIGIT ADDRESSES INSTEAD OF 6.\n*                      CHANGED AMODE TO 31. DIDN'T SEEM TO HURT.\n*     SBG    10MAR17 - FIXES FOR 8-CHARACTER USERIDS.\n*                      DEPENDS ON TSVT+6 BYTE. PROGRAM DEPENDS ON\n*                      TSVT NOW, WHICH IT DIDN'T DEPEND ON BEFORE.\n*\n*     The remarks from here on, pertain to the SHOWTPVT program:\n*     SBG    02JAN19 - Changed the program to display fields in the\n*                      undocumented TPVT only.  It is now a new\n*                      program, but many pieces of the old program\n*                      remain.\n*\n*                      Please note that the TPVTUMXL field described\n*                      in the TPVT, indicating whether 8-character\n*                      userids are supported or not, seems to be just\n*                      an \"indicator of status\" and not a switch to\n*                      turn the 8-character userid capability on or\n*                      off.\n*\n*                      The \"real switch\", that turns 8-character userid\n*                      support on or off, is located at the TSVT+6\n*                      location for one byte.\n*\n*                      This program actually reports the status of\n*                      both bytes.  The \"real switch\" byte status is\n*                      reported in the header of this program, where\n*                      it says:  8-CHARACTER USERID SUPPORT IS: ON|OFF\n*                      while the TPVTUMXL byte is reported in the\n*                      detail part of the program below.\n*\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   14,HEX\n         MEND\n         SPACE\n         MACRO\n&NAME    MSGZ  &AREA,&LEN\n         LA    1,&AREA\n         LA    0,&LEN\n         BAL   R14,PUTLINE\n         MVC   LINE,LINE-1\n         MEND\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*    This macro must be included in this assembly, and is our         *\n*    interpretation of IBM's \"internal use only\" control block        *\n*    macro, IKJTPVT (which we haven't ever actually seen).            *\n*  The names in this macro have been adjusted for format with CBMACS. *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         MACRO\n         IKJTPVT\nTPVT     DSECT                         TSO PARMLIB VECTOR TABLE\nTPVT_ID  DS    CL4'TPVT'            00 BLOCK ID\nTPVT_LEN DS    H'72'                04 LENGTH OF TPVT\n****     DS    H'220'                  LENGTH OF TPVT\nTPVT_VERS DS   FL1'2'               06 VERSION\nTPVT_MEM1 DS  0C'IKJTSO00'          07 CURRENT PARMLIB MEMBER  HTE25E2\nTPVTFIL1 DS    X                 (above field was moved one byte down)\nTPVT_MEM DS    CL8'IKJTSO00'        08 CURRENT PARMLIB MEMBER  HTE26E2\nTPVT_GEN DS    F                    10 PARMLIB generation count\nTPVTCTLT DS    V(CTLT)              14 IKJCTLT\nTPVTCTLTLEN  DS F'60'               18 length of CTLT\n         DS    4X                   1C\nTPVTSEND DS    V(SCB)               20 IKJEESCB   (SYS1.BRODCAST)\nTPVTALPL DS    V(ALPL)              24 ALPL       (ALLOCATE defaults)\nTPVTTEST DS    V(TPT)               28 TPT (TEST)\nTPVTXPRMD DS   V(XPRM)              2C INMXPARM   (XMIT)\nTPVTCONSOLE DS V(CNPRM)             30 IKJCNPRM   (CONSOLE)\nTPVTFCVEC DS   A,F                  34 FCVE       (Platform commands)\nTPVTHELP DS    V(HCB)               3C IKJEFHCB   (HELP)\nTPVTPPVEC DS   A,F                  40 PPVE       (Platform programs)\n           ORG  TPVT+X'4C'\nTPVTLOGON DS   X                    4C IKJTSOxx LOGON KEYWORD\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* The following bit settings must correspond to the same bit settings *\n* in the TSVTFLG1 field of the TSVT (TSVT + X'5') - lower nibble only *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nTPVTPHRS  EQU  X'08'                Password phrase support active\nTPVTAPPL  EQU  X'04'                LOGON applid verification active\nTPVTLGNH  EQU  X'02'                LOGONHERE support is active\nTPVTLGPC  EQU  X'01'                LOGONPREPROMPT is active\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nTPVTUMXL  DS   X                4D  MAXIMUM NUMBER OF CHARS IN USERID\n*   This is a reflection of the value in TSVTUMXL, but the \"real      *\n*   switch\" where the system \"decides\" if 8-character userids are     *\n*   allowed, appears to be TSVT+X'6', not in this value.              *\n*   Permissible values:  X'00' for pre z/OS 2.3 systems               *\n*                        X'07' for z/OS 2.3 with 8-char uids off.     *\n*                        X'08' for z/OS 2.3 with 8-char uids on.      *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n           ORG  TPVT+X'50'\nTPVTDSNAM  DS  CL44'SYS1.PARMLIB'   50 dsname\nTPVTVOLSER DS  CL6'SYSCAT'          7C VOLSER\n           DS  2X\nTPVTSYSNAM DS  CL8'P390'            84 from system\nTPVTUSERID DS  CL8'IBMUSERM'        8C by userid\nTPVTHHMMSS DS  CL8'16:59:56'        94 at hh:mm:ss\nTPVTYYMMDD DS  CL10'1998-10-29'     9C on yyyy-mm-dd\nTPVTCPUIDP DS  XL2                  A6 CPUID prefix\nTPVTCPUID  DS  F                    A8 CPUID\nTPVTMODEL  DS  H                    AC CPU Model\nTPVTUPDTIM DS  XL4                  AA Update Time\nTPVTUPDDAT DS  XL4                  B2 Update Date\nTPVTFEATURE DS  X                   B6 Feature\n*              X'80'            Dynamic Broadcast Feature is available\nTPVTFEATVER DS X                    B7 Feature Version\n         ORG   TPVT+X'DC'              end of TPVT\n         MEND\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         GBLC  &SYSLVL\n&SYSLVL  SETC  'ESA'                 370 OR ESA ?\n*                                    SET ESA FOR TSO/E VERSION 2\n*                                    SET 370 FOR MVS/370.\n*   LOOK AT YOUR LEVEL OF IKJUPT TO SEE HOW MUCH CAN DISPLAY.\n*   SEE BELOW LABEL :    DOUPT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         PRINT ON,GEN\nSHOWTPVT AMODE 31                                                JDM1\nSHOWTPVT RMODE 24                                                JDM1\nSHOWTPVT CSECT\n         USING *,R12,R10\n         B     @PROLOG-*(,15)\n         DC    AL1(11),CL11'SHOWTPVT '\n         DC    CL16' &SYSDATE &SYSTIME '\n         DC    CL16' Public Domain '\n@SIZE    DC    0F'0',AL1(1),AL3(@DATAL)\n@PROLOG  STM   14,12,12(R13)       SAVE REGISTERS\n         LR    R12,R15             LOAD BASE REGISTER\n         LA    R10,2048(,R12)      Load second base\n         LA    R10,2048(,R10)\n         LR    R2,R1               PARM POINTER\n         USING CPPL,R2\n         L     R0,@SIZE            WORKAREA SUBPOOL AND LENGTH\n         GETMAIN R,LV=(0)\n         LR    R9,R1               INITIALIZE WORKAREA POINTER\n         USING @DATA,R9\n         SPACE 1\n         ST    R13,4(,R9)          CHAIN SAVEAREA\n         ST    R9,8(,R13)          CHAIN SAVEAREA\n         LR    R13,R9              UPDATE SAVEAREA POINTER\n         SPACE\n         MVI   LINE-1,C' '\n         XC    LINKAREA(8),LINKAREA\n         SPACE\n************************************************************\n*        SET UP IOPL FOR PUTLINE                           *\n************************************************************\n         SPACE\n         LA    R15,MYIOPL\n         USING IOPL,R15\n         MVC   IOPLUPT(4),CPPLUPT\n         MVC   IOPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,IOPLECB\n         XC    MYECB,MYECB\n         LA    R0,MYPTPB\n         ST    R0,IOPLIOPB\n         DROP  R15\n         SPACE\n         L     R15,CVTPTR          POINT TO CVT                  JDM1\n         USING CVTMAP,R15          GET ADDRESSABILITY            JDM1\n         TM    CVTPUTL,X'80'       IS PUTLINE LOADED? (VS2)      JDM1\n         BNO   PUTLOAD             NO - BRANCH TO LOAD\n         L     R15,CVTPUTL         YES - USE CVTPUTL             JDM1\n         DROP  R15                                               JDM1\n         B     PUTLOADX            BRANCH AROUND LOAD\nPUTLOAD  LA    R0,=CL8'IKJPUTL '\n         LOAD  EPLOC=(0)\n         LR    R15,R0              GET ENTRY ADDRESS\n         LA    R15,0(,R15)         CLEAR HI BYTE FOR DELETE ROUTINE\nPUTLOADX ST    R15,MYPUTLEP        SAVE PUTLINE ENTRY ADDRESS\n         SPACE\n         SPACE 1\n************************************************************\n*        SET UP PPL FOR PARSE                              *\n************************************************************\n         SPACE\n         LA    R15,MYPPL\n         USING PPL,R15\n         MVC   PPLUPT(4),CPPLUPT\n         MVC   PPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,PPLECB\n         XC    MYECB,MYECB\n         L     R0,=A(MYPCL)\n         ST    R0,PPLPCL\n         LA    R0,MYANS\n         ST    R0,PPLANS\n         MVC   PPLCBUF(4),CPPLCBUF\n         ST    R13,PPLUWA\n         DROP  R15\n         SPACE 1\n************************************************************\n*        CALL THE PARSE SERVICE ROUTINE                    *\n************************************************************\n         SPACE 1\n         LR    R1,R15              POINT TO PPL\n         L     R15,CVTPTR          POINT TO CVT                  JDM1\n         USING CVTMAP,R15          GET ADDRESSABILITY            JDM1\n         TM    CVTPARS,X'80'       IF HI ORDER BIT NOT ON        JDM1\n         BNO   PARSELNK               THEN DO LINK, NOT CALL\n         L     R15,CVTPARS         CVTPARS                       JDM1\n         DROP  R15                                               JDM1\n         BALR  R14,R15             CALL IKJPARS\n         B     PARSEEXT            SKIP AROUND LINK\nPARSELNK DS    0H\n         LINK  EP=IKJPARS,SF=(E,LINKAREA)\nPARSEEXT DS    0H\n         SPACE 1\n         LTR   R15,R15\n         BNZ   EXIT12\n         L     R3,MYANS\n         USING IKJPARMD,R3\n         L     R4,CPPLPSCB\n         CLI   ALLKW+1,1           'ALL SPECIFIED'\n         BE    TESTTSVT\n         CLI   REALKW+1,2          'REAL' SPECIFIED\n         BNE   TESTTSVT            NO, BRANCH\n         L     R1,CVTPTR           YES, FIND PSCB VIA JSCB       JDM1\n         USING CVTMAP,R1           GET ADDRESSABILITY            JDM1\n         L     R1,CVTTCBP          POINT TO NEW TCB WORD         JDM1\n         L     R1,4(,R1)           POINT TO OLD TCB WORD         JDM1\n         DROP  R1                                                JDM1\n         USING TCB,R1              ADDRESSABILITY TO TCB         JDM1\n         L     R1,TCBJSCB          GET JSCB ADDRESS              JDM1\n         DROP  R1                                                JDM1\n         USING IEZJSCB,R1          GET ADDRESSABILITY            JDM1\n         L     R1,JSCBPSCB         GET PSCB ADDRESS              JDM1\n         ST    R1,SAVEPSCB         SAVE IT EVEN IF WE DON'T USE IT\n         DROP  R1                                                JDM1\n         LTR   R4,R1               IS THERE A PSCB\n         BZ    EXIT12              NO, BRANCH\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        TEST FOR PRESENCE OF 8-CHARACTER USERID SUPPORT            *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nTESTTSVT DS    0H                  TEACH PGM ABOUT 8-CHAR ID SUPPORT\n         ST    R6,SAVER6A          SAVE WORK REGISTER\n         XC    FLAG1,FLAG1         CLEAR FLAG\n         L     R6,16               CVT\n         L     R6,X'9C'(,R6)       TSVT\n         ST    R6,TSVTADDR         SAVE ADDRESS OF TSVT\n         L     R6,X'4C'(,R6)       TPVT ADDRESS\n         ST    R6,TPVTADDR         SAVE ADDRESS OF TPVT\n         L     R6,TSVTADDR         RELOAD TSVT ADDRESS FOR TEST\n         TM    6(R6),X'08'         IS THIS FIELD 08?\n         BO    TEST8CHR            FLIP FLAG BIT\n         CLI   6(R6),X'00'         IS IT 00, THE OLD WAY?\n         BE    TEST8END            YES. DON'T FLIP ANYTHING\nTEST7CHR DS    0H                  NOT 00 AND NOT 08.\n         OI    FLAG1,X'01'         SUPPORT ON BUT 7-CHAR UID LIMIT\n         B     TEST8END            THEN GET OUT\nTEST8CHR DS    0H                  8-CHAR SUPPORT IS ON\n         OI    FLAG1,X'02'         SUPPORT ON AND 8-CHAR UID LIMIT\nTEST8END DS    0H                  END OF ROUTINE\n         L     R6,SAVER6A          RESTORE WORK REGISTER\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                  PRINT TITLE OF THIS REPORT                       *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         MVC   LINE,LINE-1\n         MVC   LINET(45),TITLELIT     Program title\n         BAL   R8,MSG\n         MVC   LINE,LINE-1\n         MVC   LINET(45),TITLEUND     Underlines\n         BAL   R8,MSG\n         MVC   LINE,LINE-1\n         MVC   LINET(44),TITLEEX0     Explanation of program purpose\n         BAL   R8,MSG\n         MVC   LINET(44),TITLEEX1     Underlines\n         BAL   R8,MSG\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*   IF 8-CHARACTER USERID SUPPORT IS PRESENT, THEN SEND MESSAGE     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*              It is important to know if there exists              *\n*              8-character userid support.                          *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nEIGHTCID DS    0H\n         CLI   FLAG1,X'00'         NO 8-CHARACTER SUPPORT\n         BE    EIGHTOUT            THEN GET OUT\n         TM    FLAG1,X'01'         SUPPORT IS PRESENT BUT NOT ON\n         BO    EIGHTOFF            THEN REPORT IT\n         TM    FLAG1,X'02'         SUPPORT IS PRESENT AND IS ON\n         BO    EIGHTON             THEN REPORT IT\n*                                  MSG IF 8-CHAR UID'S IN EFFECT\nEIGHTOFF DS    0H                       OFF\n         MVI   LINE-1,X'40'             BLANK MSG LINE\n         MVC   LINE,LINE-1\n         MVC   LINEU(L'MSG04),MSG04      YES, BUT\n         BAL   R8,MSG                   SUPPORT IS TURNED OFF\n         B     EIGHTOUT\nEIGHTON  DS    0H                       ON\n         MVI   LINE-1,X'40'             BLANK MSG LINE\n         MVC   LINE,LINE-1\n         MVC   LINEU(L'MSG05),MSG05      YES, AND\n         BAL   R8,MSG                   SUPPORT IS TURNED ON\n         B     EIGHTOUT\nEIGHTOUT DS    0H\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                 PRINT THE ADDRESS OF THE TPVT                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         L     R4,TPVTADDR\n         HEX   LINE+33,4,TPVTADDR\n         MVC   LINE+17(L'MSG01),MSG01\n         MSGZ  LINE,L'MSG01+28\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                  PRINT REPORT TITLE HEADERS                       *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         MVC   LINE,LINE-1\n         MVC   LINE(49),TITLEHDR\n         BAL   R8,MSG\n         MVC   LINE,LINE-1\n         MVC   LINE(49),TITLEHUN\n         BAL   R8,MSG\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                FORMAT FIELDS OF THE TPVT LAYOUT                   *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGOTTPVT  DS    0H\n         USING TPVT,R4\n         MVC   LINE,LINE-1\n         L     R4,TPVTADDR\n         MVC   LINETXT,TEXT_ID\n*        HEX   LINEX,4,TPVT_ID\n         MVC   LINEX(4),TPVT_ID\n         MVC   LINEC(24),=C'Control block identifier'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXT_LEN\n         HEX   LINEX,2,TPVT_LEN\n         MVC   LINEC(18),=C'TPVT length in hex'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXT_VER\n         HEX   LINEX,1,TPVT_VERS\n         MVC   LINEC(18),=C'TPVT version level'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXT_FL1\n         HEX   LINEX,1,TPVTFIL1\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXT_MEM\n*        HEX   LINEX,8,TPVT_MEM\n         MVC   LINEX(8),TPVT_MEM\n         MVC   LINEC(32),=C'PARMLIB member filling this TPVT'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXT_GEN\n         HEX   LINEX,4,TPVT_GEN\n         MVC   LINEC(32),=C'TPVT generation number, fullword'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXT_CTL\n         HEX   LINEX,4,TPVTCTLT\n         MVC   LINEC(32),=C'CTLT addr, points to auth tables'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTCTLN\n         HEX   LINEX,4,TPVTCTLTLEN\n         MVC   LINEC(25),=C'CTLT control block length'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTRSV1\n         HEX   LINEX,4,TPVT+X'1C'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTSEND\n         HEX   LINEX,4,TPVTSEND\n         MVC   LINEC(33),=C'IKJEESCB-SEND PARMLIB contr block'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTALPL\n         HEX   LINEX,4,TPVTALPL\n         MVC   LINEC(29),=C'ALPL addr, default allocation'\n         L     R8,TPVTALPL\n         TM    12(R8),X'80'\n         BO    ALPLOLD\n         TM    12(R8),X'40'\n         BO    ALPLSHR\n         B     ALPLEND\nALPLOLD  DS    0H\n         MVC   LINEC+30(3),=C'OLD'\n         B     ALPLEND\nALPLSHR  DS    0H\n         MVC   LINEC+30(3),=C'SHR'\nALPLEND  DS    0H\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTTEST\n         HEX   LINEX,4,TPVTTEST\n         MVC   LINEC(32),=C'TPT addr, TEST cmd control block'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTXPRM\n         HEX   LINEX,4,TPVTXPRMD\n         MVC   LINEC(32),=C'INMXPARM address-SEND parameters'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTCNSL\n         HEX   LINEX,4,TPVTCONSOLE\n         MVC   LINEC(30),=C'TSO CONSOLE command parameters'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTFCVE\n         HEX   LINEX,4,TPVTFCVEC\n         MVC   LINEC(31),=C'Address-PLATFORM commands table'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTHELP\n         HEX   LINEX,4,TPVTHELP\n         MVC   LINEC(26),=C'Address-HELP datasets list'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTPPVE\n         HEX   LINEX,4,TPVTPPVEC\n         MVC   LINEC(31),=C'Address-PLATFORM programs table'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTRSV2\n         HEX   LINEX,8,TPVT+X'44'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTLOGO\n         HEX   LINEX,1,TPVTLOGON\n         MVC   LINEC(27),=C'LOGON option fields - bits:'\n         BAL   R8,MSG\n         MVC   LINEC(30),TEXTLG1A\n         BAL   R8,MSG\n         MVC   LINEC(30),TEXTLG1B\n         BAL   R8,MSG\n         MVC   LINEC(30),TEXTLG1C\n         BAL   R8,MSG\n         MVC   LINEC(30),TEXTLG1D\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTUMXL\n         HEX   LINEX,1,TPVTUMXL\n         MVC   LINEC(30),=C'8-char userid status indicator'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTRSV3\n         HEX   LINEX,2,TPVT+X'4E'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTDSNM\n         MVC   LINEX(44),TPVTDSNAM\n         MVC   LINE+58(14),=C'PARMLIB dsname'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTVOLS\n         MVC   LINEX(6),TPVTVOLSER\n         MVC   LINE+58(14),=C'and its volser'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTRSV4\n         HEX   LINEX,2,TPVT+X'82'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTSNAM\n         MVC   LINEX(8),TPVTSYSNAM\n         MVC   LINEC(25),=C'ID of this system or LPAR'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTUSID\n         MVC   LINEX(8),TPVTUSERID\n         MVC   LINEC(32),=C'Who did the last PARMLIB update?'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTTIME\n         MVC   LINEX(8),TPVTHHMMSS\n         MVC   LINEC(30),=C'Time HH:MM:SS when it was done'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTDATE\n         MVC   LINEX(10),TPVTYYMMDD\n         MVC   LINEC(32),=C'Date YYYY-MM-DD when it was done'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTCPIP\n         HEX   LINEX,2,TPVTCPUIDP\n         MVC   LINEC(12),=C'CPUID prefix'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTCPUI\n         HEX   LINEX,4,TPVTCPUID\n         MVC   LINEC(21),=C'CPUID of this machine'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTMODN\n         HEX   LINEX,2,TPVTMODEL\n         MVC   LINEC(16),=C'CPU model number'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTUPDT\n         HEX   LINEX,4,TPVTUPDTIM\n         MVC   LINEC(30),=C'Hexadecimal TIME when updated.'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTUPDD\n         HEX   LINEX,4,TPVTUPDDAT\n         MVC   LINEC(30),=C'Hexadecimal DATE when updated.'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTFEAT\n         HEX   LINEX,1,TPVTFEATURE\n         MVC   LINEC(13),=C'Feature codes'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTFEAV\n         HEX   LINEX,1,TPVTFEATVER\n         MVC   LINEC(15),=C'Feature version'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTRSV5         SPLIT THE RESERVE AREA\n         HEX   LINEX,18,TPVT+X'B8'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTRS5A         INTO TWO LINES.\n         HEX   LINEX,18,TPVT+X'CA'\n         BAL   R8,MSG\n         SPACE\nTSVTEND  B     EXIT0\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*     ROUTINE TO SHOW HEXADECIMAL VALUES AS DISPLAY CHARACTERS      *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      MVC   1(1,R15),0(R1)      MOVE BYTE\n         UNPK  0(3,R15),1(2,R15)   UNPACK\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)         INCREMENT OUTPUT PTR\n         LA    R1,1(,R1)           INCREMENT INPUT PTR\n         BCT   R0,HEX              DECREMENT LENGTH, THEN LOOP\n         MVI   0(R15),C' '         BLANK THE TRAILING BYTE\n         BR    R14                 RETURN TO CALLER\nHEXTAB   DC    C'0123456789ABCDEF' TRANSLATE TABLE\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMSG      LA    R1,LINE             DISPLAY A MESSAGE W/PUTLINE\n         LA    R0,72\n         BAL   R14,PUTLINE\n         MVC   LINE,LINE-1\n         BR    R8\n         SPACE\n************************************************************\n*        PUTMSG ROUTINE                                    *\n************************************************************\n         SPACE\nPUTMSG   STM   R14,R1,PUTSAVE\n         XC    MYOLD(8),MYOLD\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPM\n         LA    R14,1               NO. OF MESSAGE SEGMENTS\n         ST    R14,MYOLD\n         LA    R14,MYSEG1          POINT TO 1ST SEGMENT\n         ST    R14,MYOLD+4\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         LA    R15,MYSEG1+4\n         CLC   0(3,R1),=C'IKJ'     IS DATA PRECEEDED BY MESSAGE ID?\n         BE    *+16                YES - BRANCH\n         LA    R14,1(,R14)         ADD 1 TO LENGTH\n         MVI   0(R15),C' '         INSERT LEADING BLANK\n         LA    R15,1(,R15)         BUMP POINTER\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   0(0,R15),0(R1)      MOVE MESSAGE IN\n         EX    R14,*-6\n         LA    R1,MYIOPL\n         L     R15,MYPUTLEP\n         SPACE\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYOLD),ENTRY=(15),MF=(E,(1))\n         SPACE\n         LM    R14,R1,PUTSAVE\n         BR    R14\n         SPACE\n************************************************************\n*        PUTLINE ROUTINE                                   *\n************************************************************\n         SPACE\nPUTLINE  STM   R14,R1,PUTSAVE\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPB\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   MYSEG1+4(0),0(R1)   MOVE TEXT IN\n         EX    R14,*-6\n         LA    R1,MYIOPL\n         L     R15,MYPUTLEP\n         SPACE\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYSEG1,DATA),ENTRY=(15),MF=(E,(1))\n         SPACE\n         LM    R14,R1,PUTSAVE\n         BR    R14\n         SPACE 1\nEXIT0    SR    R15,R15             RETURN CODE ZERO\n         B     EXIT\nEXIT12   LA    R15,12              RETURN CODE 12\nEXIT     LR    R2,R15              SAVE RETURN CODE\nEXITX    LR    R15,R2              RESTORE RETURN CODE\n         LR    R1,R13              POINT R1 TO AREA TO BE FREED\n         L     R0,@SIZE            SUBPOOL AND LENGTH\n         L     R13,4(,R13)         RESTORE PREVIOUS SAVEAREA\n         ST    R15,16(,R13)        STORE RETURN CODE FOR LM\n         FREEMAIN R,A=(1),LV=(0)\n         LM    14,12,12(R13)       LOAD RETURN ADDRESS AND RC\n         BR    14                  RETURN\n         SPACE\n************************************************************\n*        CONSTANTS                                         *\n************************************************************\n         SPACE\n         LTORG\n         SPACE\nMODLPTPM PUTLINE OUTPUT=(1,TERM,SINGLE,INFOR),                         X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE\nMODLPTPB PUTLINE OUTPUT=(1,TERM,SINGLE,DATA),                          X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE\n         DS    0F\nBLANKS   DC    C'                '\nMSG01    DC    C'TPVT ADDRESS:'\nMSG02    DC    C'UPT FROM PSCB   '\nMSG02A   DC    C'UPT FROM CPPL   '\nMSG03    DC    C'ECT ADDRESS '\nMSG04    DC    C'8-CHARACTER USERID SUPPORT IS: OFF'\nMSG05    DC    C'8-CHARACTER USERID SUPPORT IS: ON '\nTITLELIT DC    C'SHOW TPVT - TSO PARMLIB VECTOR TABLE - FIELDS'\nTITLEUND DC    C'---- ----   --- ------- ------ -----   ------'\nTITLEEX0 DC    C'  Display of Common Storage Deriving from   '\nTITLEEX1 DC    C'        the IKJTSOxx PARMLIB member         '\nTITLEHDR DC    C'  addr  field        value            explanation'\nTITLEHUN DC    C'  ----  -----        -----            -----------'\nTEXT_ID  DC    C'    +0  TPVT_ID     '        4 BYTES\nTEXT_LEN DC    C'    +4  TPVT_LEN    '        2 BYTES\nTEXT_VER DC    C'    +6  TPVT_VERS   '        1 BYTE\nTEXT_FL1 DC    C'    +7  TPVT_FILLER1'        1 BYTE\nTEXT_MEM DC    C'    +8  TPVT_MEM    '        8 BYTES\nTEXT_GEN DC    C'   +10  TPVT_GEN    '        4 BYTES\nTEXT_CTL DC    C'   +14  TPVTCTLT    '        4 BYTES\nTEXTCTLN DC    C'   +18  TPVTCTLTLEN '        4 BYTES\nTEXTRSV1 DC    C'   +1C  RESERVED 1  '        4 BYTES\nTEXTSEND DC    C'   +20  TPVTSEND    '        4 BYTES\nTEXTALPL DC    C'   +24  TPVTALPL    '        4 BYTES\nTEXTTEST DC    C'   +28  TPVTTEST    '        4 BYTES\nTEXTXPRM DC    C'   +2C  TPVTXPRMD   '        4 BYTES\nTEXTCNSL DC    C'   +30  TPVTCONSOLE '        4 BYTES\nTEXTFCVE DC    C'   +34  TPVTFCVEC   '        8 BYTES\nTEXTHELP DC    C'   +3C  TPVTHELP    '        4 BYTES\nTEXTPPVE DC    C'   +40  TPVTPPVEC   '        8 BYTES\nTEXTRSV2 DC    C'   +44  RESERVED 2  '        8 BYTES\nTEXTLOGO DC    C'   +4C  TPVTLOGON   '        1 BYTE\nTEXTUMXL DC    C'   +4D  TPVTUMXL    '        1 BYTE\nTEXTRSV3 DC    C'   +4E  RESERVED 3  '        2 BYTES\nTEXTDSNM DC    C'   +50  TPVTDSNAM   '       44 BYTES\nTEXTVOLS DC    C'   +7C  TPVTVOLSER  '        6 BYTES\nTEXTRSV4 DC    C'   +82  RESERVED 4  '        2 BYTES\nTEXTSNAM DC    C'   +84  TPVTSYSNAM  '        8 BYTES\nTEXTUSID DC    C'   +8C  TPVTUSERID  '        8 BYTES\nTEXTTIME DC    C'   +94  TPVTHHMMSS  '        8 BYTES\nTEXTDATE DC    C'   +9C  TPVTYYMMDD  '       10 BYTES\nTEXTCPIP DC    C'   +A6  TPVTCPUIDP  '        2 BYTES\nTEXTCPUI DC    C'   +A8  TPVTCPUID   '        4 BYTES\nTEXTMODN DC    C'   +AC  TPVTMODEL   '        2 BYTES\nTEXTUPDT DC    C'   +AE  TPVTUPDTIM  '        4 BYTES\nTEXTUPDD DC    C'   +B2  TPVTUPDDAT  '        4 BYTES\nTEXTFEAT DC    C'   +B6  TPVTFEATURE '        1 BYTE\nTEXTFEAV DC    C'   +B7  TPVTFEATVER '        1 BYTE\nTEXTRSV5 DC    C'   +B8  RESERVED 5  '       18 BYTES\nTEXTRS5A DC    C'   +CA  RESERVED 5A '       18 BYTES\nTEXTLG1A DC    C'Password Phrase Support     08'\nTEXTLG1B DC    C'Applid Verification         04'\nTEXTLG1C DC    C'LOGONHERE Support           02'\nTEXTLG1D DC    C'Password Preprompt Support  01'\n         SPACE\n************************************************************\n*        PARSE PCL                                         *\n************************************************************\n         SPACE\n         PRINT GEN\nMYPCL    IKJPARM\nREALKW   IKJKEYWD\n         IKJNAME 'CPPL'\n         IKJNAME 'REAL'\nUPTKW    IKJKEYWD\n         IKJNAME 'UPT'\nECTKW    IKJKEYWD\n         IKJNAME 'ECT'\nALLKW    IKJKEYWD\n         IKJNAME 'ALL'\n         IKJENDP\n         PRINT GEN\n         SPACE\n************************************************************\n*        DSECTS                                            *\n************************************************************\n         SPACE\n@DATA    DSECT\n         DS    18F                 REGISTER SAVEAREA\nDOUBLE   DS    D                   DOUBLEWORD WORK AREA\nLINKAREA DS    2F\nADDRESS  DS    F\nTSVTADDR DS    F                   TSVTADDR\nTPVTADDR DS    F                   TPVTADDR\nUPTADDR  DS    F                   UPT FROM PSCB\nUPTADDRC DS    F                   UPT FROM CPPL\nECTADDR  DS    F\nSAVER6A  DS    F\nSAVER9A  DS    F\nSAVEPSCB DS    F                   WE DON'T USE IT, BUT WE HAVE IT\nMYPPL    DS    7F\nMYANS    DS    F\nMYECB    DS    F                   USED BY PUTLINE ROUTINE\nMYIOPL   DS    4F                  USED BY PUTLINE ROUTINE\nMYPTPB   DS    3F                  USED BY PUTLINE ROUTINE\nMYPUTLEP DS    F                   USED BY PUTLINE ROUTINE\nMYOLD    DS    2F                  USED BY PUTLINE ROUTINE\nMYSEG1   DS    2H,CL100            USED BY PUTLINE ROUTINE\nPUTSAVE  DS    4F                  USED BY PUTLINE ROUTINE\nFLAG1    DS    X\n*                                  X'00' IF NO 8-CHAR UID SUPPORT\n*                                  X'01' IF 8-CHAR SUPPORT BUT NOT ON\n*                                  X'02' IF 8-CHAR SUPPORT IS ON\nLINEB    DS    C                   LINE-1\nLINE     DS    CL120\nLINETXT  EQU   LINE,20\nLINEX    EQU   LINE+21\nLINEC    EQU   LINE+38\nLINET    EQU   LINE+8\nLINEU    EQU   LINE+13\nENTRY    DS    F                1  LOADED ENTRY POINT OF TODCNVRT\nPARAM    DS    5F               2  PARAMETER LIST FOR TODCNVRT PROGRAM\nCLOCK    DS    D                3  TARGET AREA OF STCK INSTRUCTION\nTIMEZONE DS    F                4  FILLED IN FROM CVTTZ\nANSWER   DS    CL64             5  ANSWER PLACE FOR TODCNVRT PROGRAM\n         DS    C\nTIMEFMT  DS    CL64                FORMAT FOR DATE AND TIME DISPLAY\nOPTION   DS    C\nWORKA    DS    10D\nPARMSAVE DS    F\n@DATAL   EQU   *-@DATA\n         SPACE 1                                                 JDM1\n         CVT   DSECT=YES,LIST=NO                                 JDM1\n         SPACE 1                                                 JDM1\n         PRINT ON,GEN\n         IKJTCB DSECT=YES,LIST=NO                                JDM1\n         SPACE 1                                                 JDM1\n         IKJPSCB\n         SPACE\n         IKJTPVT\n         SPACE\n         IEZJSCB                                                 JDM1\n         SPACE\n         IKJCPPL\n         SPACE\n         IKJIOPL\n         SPACE\n         IKJPPL\n         SPACE\n         IKJUPT\n         SPACE\n         IKJECT\n         SPACE\n         PRINT OFF\n         YREGS\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STEPLIB": {"ttr": 20228, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x12\\x01\\x14\"/\\x01\\x14\"/\\x15\\x08\\x08\\x18\\x08\\x18\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-08-10T00:00:00", "modifydate": "2014-08-10T15:08:12", "lines": 2072, "newlines": 2072, "modlines": 0, "user": "SOURCE"}, "text": "STEPLIB  TITLE '- STEPLIB - COMMAND PROCESSOR'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Support Email Address: zOS.JES2@Gmail.com                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*                 |                                                   *\n*  S T E P L I B  |       TSO STEPLIB COMMAND PROCESSOR               *\n*                 |                                                   *\n*------------------                                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n* COMMNAD SYNTAX:                                                     *\n*                                                                     *\n*        STEPLIB ADD DATASETS(DSNAME LIST) FIRST|LAST NOMSGS          *\n*        - ADDS THE DSNAME LIST TO THE EXISTING STEPLIB.              *\n*                                                                     *\n*        STEPLIB ALLOCATE DATASETS(DSNAME LIST) SHR REUSE NOMSGS      *\n*        - ALLOCATES A NEW STEPLIB & CLOSES/FREES THE OLD.            *\n*                                                                     *\n*        STEPLIB FREE NOMSGS                                          *\n*        - CLOSES/FREES THE OLD STEPLIB.                              *\n*                                                                     *\n*        STEPLIB LIST                                                 *\n*        - DISPLAYS THE STEPLIB DDNAME AND DATASETS.                  *\n*                                                                     *\n*        STEPLIB REMOVE DATASETS(DSNAME LIST) NOMSGS                  *\n*        - REMOVES THE DSNAME LIST FROM THE EXISTING STEPLIB.         *\n*                                                                     *\n*        STEPLIB SAVE                                                 *\n*        - CREATES A CLIST VARIABLE (&STEPLIB) TO BE USED TO SAVE     *\n*          THE CURRENT STEPLIB'S DATASET NAME LIST.                   *\n*                                                                     *\n*        STEPLIB STACK DATASETS(DSNAME LIST) FIRST|LAST NOMSGS        *\n*        - ADDS THE DSNAME TO THE STEPLIB, EVEN IF IT IS ALREADY      *\n*          PART OF THE CONCATENATION.                                 *\n*                                                                     *\n*        STEPLIB DESTACK DATASETS(DSNAME LIST) NOMSGS                 *\n*        - REMOVES THE 1ST OCCUANCE OF A DSNAME FROM THE STEPLIB.     *\n*                                                                     *\n*        STEPLIB ... APFCHK                                           *\n*        - AFTER THE FUNCTION IS PERFORMED, CHECK IF THE LIBRARIES    *\n*          WITHIN THE STEPLIB ARE IN THE APF LIST.                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*     HISTORY:          - JAN 13,1996 -  RE-WRITTEN FROM OLD \"MODS\"   *\n*              #DD99244 - SEP 01,1999 -  VARIOUS BUG FIXES:           *\n*              - IF OLD STEPLIB DDNAME IS \"STEPLIB\" BYPASS \"UNALLOC\". *\n*              - GET \"REAL\" NAME FROM CATALOG IN CASE AN ALIAS WAS    *\n*                SPECIFIED ON THE \"STEPLIB REMOVE\".                   *\n*              - FIX REMOVAL OF \"LAST\" DATASET FROM LIST.             *\n*              #DD99245 - SEP 02,1999 -  IF THE ORIGINAL DDNAME       *\n*                FOR A STEPLIB IS NOT A \"$TEP\" PREFIX, IT IS FREE'D   *\n*                AND RE-ALLOCATED WITH THE $TEP000# DDNAME.           *\n*              #DD01068 - MAR 09,2001 -  RECOGNIZE LIBRARIES THAT     *\n*                ARE ALREADY IN THE CURRENT STEPLIB WHEN PERFORMING   *\n*                AN \"ADD\" FUNCTION.                                   *\n*              #DD01072 - MAR 13,2001 -  ADD \"STACK\"/\"DESTACK\".       *\n*              #DD01073 - MAR 14,2001 -  ADD \"APFCHK\".                *\n*              #DD01095 - APR  5,2001 -  CORRECTIVE FIXES.            *\n*              #DD01250 - SEP  7,2001 -  FIX \"DESTACK\" PROCESSING.    *\n*              #DD04108 - APR 17,2004 -  ADD ESTAE AROUND OPEN        *\n*                                        TO PROTECT AGAINST ABENDS,   *\n*                                        ESPECIALLY S913'S.           *\n*              #DD05026 - JAN 26,2005 -  CHECK FOR A REAL \"JOBLIB\".   *\n*              #DD05031 - JAN 31,2005 -  CORRECT NULL STEPLIB DDNAME. *\n*              #DD08098 - APR  7,2008 -  STEPLIB \"VERSION\" FUNCTION.  *\n*              #DD08099 - APR  8,2008 -  ISSUE OPEN FAILED MSG FOR    *\n*                                        EACH FAILED DSN.             *\n*              #DD08112 - APR 21,2008 -  CORRECT APF/SMS CHECK.       *\n*              #DD08268 - SEP 24,2008 -  ALLOW FOR BATCH TMP.         *\n*                                     -  ADD DEBUG CODE.              *\n*              #DD08350 - DEC 15,2008 -  NO TRACE WHEN PARSE ERROR    *\n*              #DD09027 - JAN 27,2009 -  PAUSE BEFORE BATCH EXIT.     *\n*              #DD09101 - APR 11,2009 -  USE BRANCH ENTRY CIRB.       *\n*                                        FIX FOR Z11 PMR 49446,756    *\n*                                        (D78 abend).                 *\n*              #DD09103   APR 13,2009 -  CHANGE TO USE SCHEDIRB.      *\n*              #DD09199   JUL 18,2009 -  LEAVE NON-ZERO TCBJLIB ALONE.*\n*   1.16 -     #DD10050   Feb 19,2010 -  Build DCB/DCBE for >= r1.12  *\n*                       (Thanks to Jan Ott for heads up & assistance).*\n*   1.17 -     #DD10106   Apr 16,2010 -  JES3 Support.                *\n*   1.18 -     #DD10177   Jun 10,2010 -  Create &STEPLIB Variable.    *\n*   1.19 -     #DD12060   Feb 29,2012 -  Correction for EAV support.  *\n*   1.20 -     #JR14048   Feb 17,2014 -  Use 24-bit address for RBCDE.*\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         ACONTROL OPTABLE(ZS3)     ASSEMBLY OPTCDE TABLE\n         SPLEVEL  SET=6            SPECIFY OS/390 R2 MACRO FORMAT\n         SYSSTATE ARCHLVL=2        ASSEMBLY REQUIRES Z/ARCHITECTURE\n         SYSSTATE OSREL=ZOSV1R13   ASSEMBLY REQUIRES Z/OS 1.13 & HIGHER\n\nSTEPLIB  #START ,                  START PROCEDURE                     *\n               AMODE=CAP31,        EXECUTE IN 31-BIT ADDRESSING MODE   *\n               APARS=,             NO NEED FOR APAR \"ZAP\" SLOTS        *\n               RMODE=24,           EXECUTE IN 24-BIT RESIDENCY MODE    *\n               BASE=(R12,R11),     DEFINE BASE REGISTER(S)             *\n               COPY=YES,           INSERT COPYRIGHT NOTICE             *\n               COPYYR=1996,        COPYRIGHT YEAR                      *\n               WKDSECT=STEPWRK,    DEFINE WORKAREA NAME                *\n               LEVEL=#V001R20                                  #DD14048\n\n         USING PSA,0\n\n         ST    R1,WRKCPPL@         Save CPPL Address           #DD10106\n         LR    R8,R1               A(CPPL)\n         USING CPPL,R8\n\n         MVC   WRKUPT@,CPPLUPT     SAVE A(UPT)\n         MVC   WRKECT@,CPPLECT     SAVE A(ECT)\n\n         L     R15,PSATOLD         LOAD TCB  ADDRESS           #DD08268\n         USING TCB,R15                                         #DD08268\n         MVC   WRKJSTCB,TCBJSTCB   SAVE JOBSTEP TCB ADDRESS    #DD08268\n         L     R14,TCBJSCB         LOAD JSCB ADDRESS           #DD08268\n         USING IEZJSCB,R14                                     #DD08268\n         L     R14,JSCBACT         LOAD ACTIVE JSCB ADDRESS    #DD08268\n         L     R14,JSCBSSIB        LOAD SSIB ADDRESS           #DD08268\n         USING SSIB,R14                                        #DD08268\n         MVC   WRKTYPE,SSIBJBID    \"J\", \"T\" OR \"S\"             #DD08268\n         MVC   WRKSSID,SSIBSSID    Save Subsystem Identifier   #DD10106\n         DROP  R14,R15                                         #DD08268\n\n*        SSIBJBID is unreliable when running under JES3.       #DD10106\n         CLI   WRKSSID,SSIBJES2    Check For JES2 Subsystem    #DD10106\n         BE    STEP0100            B. If Yes (JBID Is Reliable)#DD10106\n         L     R14,PSAAOLD         A(ASCB)                     #DD10106\n         USING ASCB,R14                                        #DD10106\n         ICM   R14,15,ASCBOUCB     A(OUCB)                     #DD10106\n         USING OUCB,R14                                        #DD10106\n         MVI   WRKTYPE,C'S'                                    #DD10106\n         TM    OUCBYFL,OUCBSTT+OUCBMNT Started Task Or Mount?  #DD10106\n         BNZ   STEP0100            B. If Yes                   #DD10106\n         MVI   WRKTYPE,C'T'                                    #DD10106\n         TM    OUCBYFL,OUCBLOG     Check For Logon             #DD10106\n         BO    STEP0100            B. If Yes                   #DD10106\n         MVI   WRKTYPE,C'J'        Treat All Others As Jobs    #DD10106\n         DROP  R14                                             #DD10106\n\nSTEP0100 DS    0H                                              #DD10106\n         L     R2,CVTPTR           A(CVT)                      #DD10050\n         USING CVTMAP,R2                                       #DD10050\n         TM    CVTOSLV5,CVTZOS_V1R12                           #DD10050\n         BZ    STEP0200            B. If Not z/OS R1.12 or >   #DD10050\n         OI    WRKFLAG1,WRK$R112   Set z/OS R1.12 flag         #DD10050\n         DROP  R2                                              #DD10050\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        FIND THE NEXT \"$TEP####\" TO USE AS THE NEW STEPLIB DDNAME    *\n*        NOTE: THIS DDNAME IS USED TO ALLOCATE THE DATASETS WITHIN    *\n*              THE IKJPARS VALIDATION SUBROUTINE.                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP0200 DS    0H                                              #DD10050\n         MVC   WRKDDNEW,=CL8'$TEP0001'\nSTEP0300 DS    0H                                              #DD99245\n         LA    R2,WRKDDNEW         A(\"NEW\" FAKE STEPLIB DDNAME)#DD99245\n         TIOTSCAN DDN=(R2),NOK=STEP0400  SCAN THE TIOT         #DD99245\n         PACK  WRKDBL1,WRKDDNEW+4(4)                           #DD99245\n         AP    WRKDBL1,=P'+1'      INCREMENT STEPLIB DD NUMBER #DD99245\n         OI    WRKDBL1+7,X'0F'                                 #DD99245\n         UNPK  WRKDDNEW+4(4),WRKDBL1                           #DD99245\n         B     STEP0300                                        #DD99245\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CLOSE & RE-OPEN THE STEPLIB TO RETRIEVE THE DDNAME           *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP0400 DS    0H                                              #DD99245\n         L     R4,PSATOLD          A(TCB)                      #DD99245\n         USING TCB,R4                                          #DD99245\n         L     R5,TCBTCT           A(TCT)                      #DD99245\n         USING SMFTCT,R5                                       #DD99245\n         L     R6,TCTLCTAD         A(LCT)                      #DD99245\n         ST    R6,WRKLCT@          SAVE LCT ADDRESS            #DD99245\n\n         L     R5,TCBJSCB          A(JSCB)                     #DD01068\n         USING IEZJSCB,R5                                      #DD01068\n         L     R5,JSCBACT          A(ACTIVE JSCB)              #DD01068\n         L     R5,JSCDSABQ         A(QDB)                      #DD01068\n         USING QDB,R5                                          #DD01068\n         MVC   WRKDSAB@,QDBFELMP   SAVE DSAB ADDRESS           #DD01068\n         DROP  R4,R5                                           #DD01068\n\n         LA    R0,CLOSEIRB         A(STEPLIB CLOSE ROUTINE)    #DD01068\n         LA    R1,WRKDDOLD         A(OLD DDNAME RETURN ADDRESS)#DD01068\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY      #DD01068\n\n         LA    R0,OPENIRB          A(STEPLIB OPEN ROUTINE)     #DD01068\n         LA    R1,WRKDDOLD         A(OLD STEPLIB DDNAME)       #DD01068\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY      #DD01068\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PARSE THE STEPLIB COMMAND BUFFER                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LA    R1,WRKPPL           LOAD PPL ADDRESS\n         USING PPL,R1\n         MVC   PPLUPT,CPPLUPT      SET UPT ADDRESS\n         MVC   PPLECT,CPPLECT      SET ECT ADDRESS\n         LA    R15,WRKECB\n         ST    R15,PPLECB          SET ECB ADDRESS\n         XC    WRKECB,WRKECB\n         MVC   PPLPCL,=A(STEPPCL)  SET PCL ADDRESS\n         LA    R15,WRKANS@\n         ST    R15,PPLANS          SET PDL ADDRESS\n         MVC   PPLCBUF,CPPLCBUF    SET COMMAND BUFFER ADDRESS\n         ST    R13,PPLUWA          PASS WRKDSECT TO VALIDATION EXIT\n         DROP  R1,R8                                           #DD10106\n\n         CALLTSSR EP=IKJPARS,MF=(E,WRKPPL)\n         L     R8,WRKANS@          LOAD PDL ADDRESS\n         USING IKJPARMD,R8\n         #SETRC (R15)              SET RETURN CODE\n         LTR   R15,R15             CHECK PARSE RETURN CODE\n         BZ    STEP0500            B. IF SUCCESSFUL            #DD99245\n\n*-------\n*        FREE ANY ALLOCATED DATASETS IF THE PARSE ROUTINE FAILED\n*-------\n         TM    WRKFLAG1,WRK$1STD   CHECK IF 1ST DATASET ALLOCATED\n         BZ    STEPEXIT            B. IF NOT                   #DD08350\n         LA    R0,WRKDDNEW         A(STEPLIB DDNAME)\n         ST    R0,WRKDDN@\n         LA    R0,L'WRKDDNEW       L(STEPLIB DDNAME)\n         STH   R0,WRKDDN@+4\n         FREE  PERM,DDN=WRKDDN@    FREE THE \"NEW\" STEPLIB DATASETS\n         B     STEPEXIT                                        #DD08350\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        RE-ALLOCATE THE CURRENT STEPLIB IF THE OLD STEPLIB WAS       *\n*        A \"REAL\" STEPLIB. (IE. //STEPLIB WITHIN THE LOGON PROC)      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP0500 DS    0H                                              #DD99245\n         TM    WRKFLAG1,WRK$ABND   CHECK FOR \"OPEN\" ABEND      #DD08099\n         BO    STEP6000            B. IF YES                   #DD08268\n\n         CLI   $TEPFUNC+1,$VERSION CHECK FOR \"VERSION\" FUNC.   #DD08098\n         BE    STEP5900            B. IF YES                   #DD08098\n\n         CLI   $TEPFUNC+1,$FREE    CHECK FOR \"FREE\" FUNCTION   #DD99245\n         BE    STEP1500            B. IF YES                   #DD99245\n         CLI   $TEPFUNC+1,$LIST    CHECK FOR \"LIST\" FUNCTION   #DD99245\n         BE    STEP2500            B. IF YES                   #DD05031\n\n         MVC   WRKDDTMP,=CL8'$TEP0001'                         #DD99245\nSTEP0600 DS    0H                                              #DD99245\n         LA    R2,WRKDDTMP         A(\"NEW\" FAKE STEPLIB DDNAME)#DD99245\n         TIOTSCAN DDN=(R2),NOK=STEP0700  SCAN THE TIOT         #DD99245\n         PACK  WRKDBL1,WRKDDTMP+4(4)                           #DD99245\n         AP    WRKDBL1,=P'+1'      INCREMENT STEPLIB NUMBER    #DD99245\n         OI    WRKDBL1+7,X'0F'                                 #DD99245\n         UNPK  WRKDDTMP+4(4),WRKDBL1                           #DD99245\n         B     STEP0600                                        #DD99245\n\n*-------\n*        CLOSE THE PREVIOUSLY ALLOCATED \"REAL\" STEPLIB\n*-------\nSTEP0700 DS    0H                                              #DD99245\n         CLC   =C'JOBLIB ',WRKDDOLD CHECK FOR \"REAL\" JOBLIB DD #DD05026\n         BE    STEP0800            B. IF YES                   #DD05026\n         CLC   =C'STEP',WRKDDOLD   CHECK FOR \"REAL\" STEPLIB DD #DD01068\n         BNE   STEP1500            B. IF NOT                   #DD01068\nSTEP0800 DS    0H                                              #DD05026\n         LA    R0,CLOSEIRB         A(STEPLIB CLOSE ROUTINE)    #DD99245\n         LA    R1,WRKDDOLD         A(OLD DDNAME RETURN ADDRESS)#DD99245\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY      #DD99245\n\n*-------\n*        SCAN THE DSAB CHAIN FOR THE OLD STEPLIB DDNAME\n*-------\n         NI    WRKFLAG1,255-WRK$1STD                           #DD99245\n\n         ICM   R5,15,WRKDSAB@      A(DSAB)                     #DD01068\n         BZ    STEP1500            B. IF CHAIN DOES NOT EXIST  #DD99245\n         USING DSABID,R5                                       #DD99245\n\nSTEP0900 DS    0H                                              #DD99245\n         L     R4,DSABSIOT         A(SIOT)                     #DD99245\n         USING INDMSIOT,R4                                     #DD99245\n         CLC   SCTDDNAM,WRKDDOLD   CHECK PREV. STEPLIB DDNAME  #DD99245\n         BE    STEP1000            B. IF FOUND                 #DD99245\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)                #DD99245\n         BNZ   STEP0900            B. IF ANOTHER DSAB EXISTS   #DD99245\n         B     STEP1500            ELSE. UNABLE TO FIND DDNAME #DD99245\n\n*-------\n*        ALLOCATE THE 1ST DSNAME TO THE NEW STEPLIB DDNAME\n*-------\nSTEP1000 DS    0H                                              #DD99245\n         L     R1,SJFCBPTR         A(JFCB)                     #DD99245\n         USING INFMJFCB,R1                                     #DD99245\n         MVC   WRKDSN1,JFCBDSNM    SAVE THE CURRENT DSN        #DD99245\n         DROP  R1                                              #DD99245\n         LA    R0,WRKDSN1                                      #DD99245\n         ST    R0,WRKDSN@          A(CURRENT STEPLIB DSNAME)   #DD99245\n         LA    R0,L'WRKDSN1                                    #DD99245\n         STH   R0,WRKDSN@+4        L(CURRENT STEPLIB DSNAME)   #DD99245\n\n         TM    WRKFLAG1,WRK$1STD   CHECK IF 1ST DSN ALLOCATED  #DD99245\n         BO    STEP1100            B. IF YES                   #DD99245\n         OI    WRKFLAG1,WRK$1STD   REMEMBER 1ST DSN ALLOCATED  #DD99245\n         LA    R0,WRKDDTMP                                     #DD99245\n         ST    R0,WRKDDN@          A(CURRENT STEPLIB DDNAME)   #DD99245\n         LA    R0,L'WRKDDTMP                                   #DD99245\n         STH   R0,WRKDDN@+4        L(CURRENT STEPLIB DDNAME)   #DD99245\n         ALLOC PERM,DSN=WRKDSN@,DISP=SHR,                      #DD99245*\n               DDN=WRKDDN@,FLAG1=S99NOCNV+S99NOMNT             #DD99245\n         LTR   R15,R15             CHECK ALLOCATION RETURN CODE#DD99245\n         BZ    STEP1300            B. IF SUCCESSFUL            #DD99245\n         B     STEP1200            ELSE. ISSUE ALLOC ERROR MSG #DD99245\n\n*-------\n*        CONCATENATE THE REMAINING DSNAMES TO THE NEW STEPLIB DDNAME\n*-------\nSTEP1100 DS    0H                                              #DD99245\n         ALLOC PERM,DSN=WRKDSN@,DISP=SHR,                      #DD99245*\n               DDNTO=WRKDDRET,FLAG1=S99NOCNV+S99NOMNT          #DD99245\n         LTR   R15,R15             CHECK ALLOCATION RETURN CODE#DD99245\n         BNZ   STEP1200            B. IF ALLOCATION FAILED     #DD99245\n\n         MVC   WRKCCTU1(4),=AL2(DCCDDNAM,2)                    #DD99245\n         MVC   WRKCCDD1(2),=AL2(8) SET LENGTH OF DDNAME        #DD99245\n         MVC   WRKCCDD2(2),=AL2(8) SET LENGTH OF DDNAME        #DD99245\n         MVC   WRKCCTU2(4),=AL2(DCCPERMC,0)                    #DD99245\n         MVC   WRKCCDD1+2(8),WRKDDTMP                          #DD99245\n         MVC   WRKCCDD2+2(8),WRKDDRET                          #DD99245\n         ALLOC VERB=S99VRBCC,TU=(WRKCCTU1,WRKCCTU2)            #DD99245\n         LTR   R15,R15             CHECK CONCAT RETURN CODE    #DD99245\n         BZ    STEP1300            B. IF CONCAT SUCCEEDED      #DD99245\n\n*-------\n*        PROCESS ALLOCATION/CONCATENATION ERRORS\n*-------\nSTEP1200 DS    0H                                              #DD99245\n         L     R2,WRKCPPL@         A(CPPL)                     #DD10106\n         S99FAIL CP=YES,CPPL=(R2), ISSUE ALLOC FAILURE MESSAGE #DD10106*\n               MF=(E,WRKFAIL)                                  #DD10106\n         #SETRC 8                  INDICATE AN ERROR OCCURRED  #DD01073\n         B     STEP6000                                        #DD08268\n\n*-------\n*        CHECK IF NEXT DSAB IS A CONCATENATION OF THE STEPLIB\n*-------\nSTEP1300 DS    0H                                              #DD99245\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)                #DD99245\n         BZ    STEP1400            B. IF END OF DSAB CHAIN     #DD99245\n         L     R4,DSABSIOT         A(SIOT)                     #DD99245\n         CLC   SCTDDNAM,BLANKS     CHECK FOR CONCATENATION     #DD99245\n         BE    STEP1000            B. IF YES                   #DD99245\n         DROP  R4,R5                                           #DD99245\n\n*-------\n*        OPEN THE NEWLY ALLOCATED STEPLIB\n*-------\nSTEP1400 DS    0H                                              #DD99245\n         LA    R0,OPENIRB          A(STEPLIB OPEN ROUTINE)     #DD99245\n         LA    R1,WRKDDTMP         A(NEW STEPLIB DDNAME)       #DD99245\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY      #DD99245\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS THE \"STEPLIB ADD\" FUNCTION                           *\n*             OR THE \"STEPLIB STACK\" FUNCTION                         *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP1500 DS    0H                                              #DD01073\n         L     R15,=A(MSG008I6)                                #DD10177\n         MVC   WRKFUNC,0(R15)                                  #DD10177\n         CLI   $TEPFUNC+1,$STACK   CHECK FOR \"STACK\" FUNCTION  #DD01072\n         BE    STEP1600            B. IF YES                   #DD01072\n         CLI   $TEPFUNC+1,$ADD     CHECK FOR \"ADD\" FUNCTION\n         BNE   STEP2100            B. IF NOT\n         L     R15,=A(MSG008I1)                                #DD10177\n         MVC   WRKFUNC,0(R15)                                  #DD10177\nSTEP1600 DS    0H                                              #DD01072\n         CLI   $TEPDSNS+1,$DSNS    CHECK IF DATASET NAMES SPECIFIED\n         BNE   STEPERR1            B. IF NOT\n         TM    WRKFLAG1,WRK$1STD   CHECK IF ANY DSNS TO ADD    #DD01095\n         BO    STEP1700            B. IF YES                   #DD01095\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION   #DD01095\n         BE    STEP5200            B. IF YES (DO \"APFCHK\")     #DD01095\n         LA    R0,1                SET NUMBER OF SEGMENTS      #DD01095\n         L     R1,=A(MSG010I)      'DATASET ALREADY IN STEPLIB'#DD10106\n         SLR   R2,R2                                           #DD01095\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD01095\n         B     STEP5200                                        #DD01095\nSTEP1700 DS    0H                                              #DD01095\n         L     R4,PSATOLD          A(TCB)\n         USING TCB,R4\n         ICM   R2,15,TCBJLB        A(STEPLIB DCB)\n         BZ    STEP2200            B. IF ONE DOES NOT EXIST (ALLOCATE)\n         DROP  R4\n         TM    WRKDDOLD,X'BF'      CHECK IF A STEPLIB EXISTS   #DD05031\n         BZ    STEP2200            B. IF NOT                   #DD05031\n\n*-------\n*        CLOSE THE PREVIOUSLY ALLOCATED STEPLIB\n*-------\n         LA    R0,CLOSEIRB         A(STEPLIB CLOSE ROUTINE)\n         LA    R1,WRKDDOLD         A(OLD DDNAME RETURN ADDRESS)\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY\n         LTR   R15,R15             CHECK IF CLOSE WAS SUCCESSFUL\n         BNZ   STEP6000            B. IF NOT                   #DD08268\n\n*-------\n*        CONCATENATE THE NEW DATASET(S) WITH THE OLD STEPLIB DATASETS\n*-------\n         MVC   WRKCCTU1(4),=AL2(DCCDDNAM,2)\n         MVC   WRKCCDD1(2),=AL2(8) SET LENGTH OF DDNAME\n         MVC   WRKCCDD2(2),=AL2(8) SET LENGTH OF DDNAME\n         MVC   WRKCCTU2(4),=AL2(DCCPERMC,0)\n         MVC   WRKCCDD1+2(8),WRKDDNEW\n         MVC   WRKCCDD2+2(8),WRKDDOLD\n         CLI   $TEPOPTS+1,$FIRST   CHECK FOR \"FIRST\" OPTION\n         BE    STEP1800            B. IF YES\n         MVC   WRKCCDD1+2(8),WRKDDOLD\n         MVC   WRKCCDD2+2(8),WRKDDNEW\nSTEP1800 DS    0H\n         ALLOC VERB=S99VRBCC,TU=(WRKCCTU1,WRKCCTU2)\n         LTR   R15,R15             CHECK CONCATENATION RETURN CODE\n         BZ    STEP1900            B. IF CONCATENATION SUCCEEDED\n\n*-------\n*        IF CONCATENATION FAILS, ISSUE MESSAGE & REINSTATE OLD STEPLIB\n*-------\n         L     R2,WRKCPPL@         A(CPPL)                     #DD10106\n         S99FAIL CP=YES,CPPL=(R2), ISSUE ALLOC FAILURE MESSAGE #DD10106*\n               MF=(E,WRKFAIL)                                  #DD10106\n         LA    R0,OPENIRB          A(STEPLIB OPEN ROUTINE)\n         LA    R1,WRKDDOLD         A(OLD STEPLIB DDNAME)\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY\n         TM    WRKFLAG1,WRK$1STD   CHECK IF 1ST DATASET ALLOCATED\n         BZ    STEP6000            B. IF NOT                   #DD08268\n         LA    R0,WRKDDNEW         A(STEPLIB DDNAME)\n         ST    R0,WRKDDN@\n         LA    R0,L'WRKDDNEW       L(STEPLIB DDNAME)\n         STH   R0,WRKDDN@+4\n         FREE  PERM,DDN=WRKDDN@    FREE THE STEPLIB DDNAME\n         #SETRC 8                  INDICATE AN ERROR OCCURRED  #DD01073\n         B     STEP6000                                        #DD08268\n\n*-------\n*        RE-OPEN THE CONCATENATED STEPLIB\n*-------\nSTEP1900 DS    0H\n         CLI   $TEPOPTS+1,$FIRST   CHECK FOR \"FIRST\" OPTION\n         BE    STEP2000            B. IF YES\n         MVC   WRKDDNEW,WRKDDOLD   NEW STEPLIB DDNAME TO SAME AS BEFORE\n\nSTEP2000 DS    0H\n         LA    R0,OPENIRB          A(STEPLIB OPEN ROUTINE)\n         LA    R1,WRKDDNEW         A(NEW STEPLIB DDNAME)\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY\n         LTR   R15,R15             CHECK IF OPEN SUCCEEDED\n         BNZ   STEPERR3            B. IF NOT                   #DD08099\n\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION\n         BE    STEP6000            B. IF YES                   #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS\n         L     R1,=A(MSG001I)      'STEPLIB EXTENDED'          #DD10106\n         SLR   R2,R2\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE\n         B     STEP5200                                        #DD01073\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS THE \"STEPLIB ALLOCATE\" FUNCTION                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP2100 DS    0H\n         L     R15,=A(MSG008I2)                                #DD10177\n         MVC   WRKFUNC,0(R15)                                  #DD10177\n         CLI   $TEPFUNC+1,$ALLOC   CHECK FOR \"ALLOCATE\" FUNCTION\n         BNE   STEP2300            B. IF NOT\n         CLI   $TEPDSNS+1,$DSNS    CHECK IF DATASET NAMES SPECIFIED\n         BNE   STEPERR1            B. IF NOT\n         L     R4,PSATOLD          A(TCB)\n         USING TCB,R4\n         ICM   R2,15,TCBJLB        A(STEPLIB DCB)\n         BZ    STEP2200            B. IF ONE DOES NOT EXIST\n         DROP  R4\n         TM    WRKDDOLD,X'BF'      CHECK IF A STEPLIB EXISTS   #DD05031\n         BZ    STEP2200            B. IF NOT                   #DD05031\n\n*-------\n*        CLOSE & FREE THE PREVIOUSLY ALLOCATED STEPLIB\n*-------\n         LA    R0,CLOSEIRB         A(STEPLIB CLOSE ROUTINE)\n         LA    R1,WRKDDOLD         A(OLD DDNAME RETURN ADDRESS)\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY\n         LTR   R15,R15             CHECK IF CLOSE WAS SUCCESSFUL\n         BNZ   STEP6000            B. IF NOT                   #DD08268\n         LA    R0,WRKDDOLD         A(OLD STEPLIB DDNAME)\n         ST    R0,WRKDDN@\n         LA    R0,L'WRKDDOLD       L(OLD STEPLIB DDNAME)\n         STH   R0,WRKDDN@+4\n         CLC   =C'$TEP',WRKDDOLD   CHECK FOR \"FAKE\" STEPLIB DD #DD99244\n         BNE   STEP2200            B. IF NOT                   #DD99244\n         FREE  PERM,DDN=WRKDDN@    FREE THE OLD STEPLIB DDNAME\n\n*-------\n*        OPEN THE NEWLY ALLOCATED STEPLIB\n*-------\nSTEP2200 DS    0H\n         LA    R0,OPENIRB          A(STEPLIB OPEN ROUTINE)\n         LA    R1,WRKDDNEW         A(NEW STEPLIB DDNAME)\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY\n         LTR   R15,R15             CHECK IF OPEN SUCCEEDED\n         BNZ   STEPERR3            B. IF NOT                   #DD08099\n\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION\n         BE    STEP6000            B. IF YES                   #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS\n         L     R1,=A(MSG002I)      'STEPLIB ALLOCATED'         #DD10106\n         SLR   R2,R2\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE\n         B     STEP5200                                        #DD01073\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS THE \"STEPLIB FREE\" FUNCTION                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP2300 DS    0H\n         L     R15,=A(MSG008I3)                                #DD10177\n         MVC   WRKFUNC,0(R15)                                  #DD10177\n         CLI   $TEPFUNC+1,$FREE    CHECK FOR \"FREE\" FUNCTION\n         BNE   STEP2500            B. IF NOT\n         L     R4,PSATOLD          A(TCB)\n         USING TCB,R4\n         ICM   R2,15,TCBJLB        A(STEPLIB DCB)\n         BZ    STEPERR2            B. IF ONE DOES NOT EXIST    #DD01072\n         DROP  R4\n         TM    WRKDDOLD,X'BF'      CHECK IF A STEPLIB EXISTS   #DD05031\n         BZ    STEPERR2            B. IF NOT                   #DD05031\n\n*-------\n*        CLOSE & FREE THE PREVIOUSLY ALLOCATED STEPLIB\n*-------\n         LA    R0,CLOSEIRB         A(STEPLIB CLOSE ROUTINE)\n         LA    R1,WRKDDOLD         A(OLD DDNAME RETURN ADDRESS)\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY\n         LTR   R15,R15             CHECK IF CLOSE WAS SUCCESSFUL\n         BNZ   STEP6000            B. IF NOT                   #DD08268\n\n         LA    R0,WRKDDOLD         A(OLD STEPLIB DDNAME)\n         ST    R0,WRKDDN@\n         LA    R0,L'WRKDDOLD       L(OLD STEPLIB DDNAME)\n         STH   R0,WRKDDN@+4\n         CLC   =C'$TEP',WRKDDOLD   CHECK FOR \"FAKE\" STEPLIB DD #DD99244\n         BNE   STEP2400            B. IF NOT                   #DD99244\n         FREE  PERM,DDN=WRKDDN@    FREE THE OLD STEPLIB DDNAME\n\nSTEP2400 DS    0H\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION\n         BE    STEP6000            B. IF YES                   #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS\n         L     R1,=A(MSG003I)      'STEPLIB FREED'             #DD10106\n         SLR   R2,R2\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE\n         B     STEP5200                                        #DD01073\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS THE \"STEPLIB LIST\" FUNCTION                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP2500 DS    0H\n         L     R15,=A(MSG008I4)                                #DD10177\n         MVC   WRKFUNC,0(R15)                                  #DD10177\n         CLI   $TEPFUNC+1,$LIST    CHECK FOR \"LIST\" FUNCTION\n         BNE   STEP2900            B. IF NOT                   #DD10177\n\n*-------\n*        CHECK IF THERE IS CURRENTLY A STEPLIB\n*-------\n         L     R4,PSATOLD          A(TCB)\n         USING TCB,R4\n         ICM   R2,15,TCBJLB        A(STEPLIB DCB)\n         BZ    STEPERR2            B. IF ONE DOES NOT EXIST    #DD01072\n         DROP  R4\n         TM    WRKDDOLD,X'BF'      CHECK IF A STEPLIB EXISTS   #DD05031\n         BZ    STEPERR2            B. IF NOT                   #DD05031\n\n*-------\n*        SCAN THE DSAB CHAIN FOR THE START OF THE STEPLIB DD\n*-------\n         ICM   R5,15,WRKDSAB@      A(DSAB)                     #DD01068\n         BZ    STEP6000            B. IF CHAIN DOES NOT EXIST  #DD08268\n         USING DSABID,R5\n\nSTEP2600 DS    0H\n         L     R4,DSABSIOT         A(SIOT)\n         USING INDMSIOT,R4\n         CLC   SCTDDNAM,WRKDDOLD   CHECK FOR THE STEPLIB DDNAME\n         BE    STEP2700            B. IF FOUND\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)\n         BNZ   STEP2600            B. IF ANOTHER DSAB EXISTS\n         B     STEP6000            ELSE. UNABLE TO FIND OLD DDN#DD08268\n\n*-------\n*        ONCE 1ST DSAB ENTRY FOUND DISPLAY ASSOCIATED DSNAMES\n*-------\nSTEP2700 DS    0H\n         MVC   WRKINSRT(4),=AL2(12,39)   LENGTH+4/OFFSET       #DD01095\n         MVC   WRKINSRT+4(8),WRKDDOLD\n         LA    R0,2                SET NUMBER OF SEGMENTS\n         L     R1,=A(MSG006I)      '$TEPNNNN LIST:'            #DD10106\n         LA    R2,WRKINSRT\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE\n\nSTEP2800 DS    0H\n         L     R1,SJFCBPTR         A(JFCB)\n         USING INFMJFCB,R1\n         MVC   WRKINSRT(4),=AL2(48,11)   LENGTH+4/OFFSET       #DD01095\n         MVC   WRKINSRT+4(44),JFCBDSNM\n         DROP  R1\n         LA    R0,2                SET NUMBER OF SEGMENTS\n         L     R1,=A(MSG007I)      '- DSNAME'                  #DD10106\n         LA    R2,WRKINSRT\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE\n\n*-------\n*        CONTINUE PROCESSING DSAB'S TILL NON STEPLIB DD FOUND\n*-------\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)\n         BZ    STEP5200            B. IF END OF DSAB CHAIN     #DD01073\n         L     R4,DSABSIOT         A(SIOT)\n         CLC   SCTDDNAM,BLANKS     CHECK IF NEXT IS A CONCATENATION\n         BE    STEP2800            B. IF YES\n         DROP  R4,R5\n         B     STEP5200            ELSE. END OF LIST           #DD01073\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS THE \"STEPLIB SAVE\" FUNCTION                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP2900 DS    0H                                              #DD10177\n         CLI   $TEPFUNC+1,$SAVE    CHECK FOR \"SAVE\" FUNCTION   #DD10177\n         BNE   STEP3800            B. IF NOT                   #DD10177\n\n*-------\n*        Create Blank &STEPLIB Variable\n*-------\n         MVC   CVARCODE,=A(TSVEUPDT)  \"Update\"                 #DD10177\n         LA    R0,CVARCODE                                     #DD10177\n         ST    R0,CVAREC@                                      #DD10177\n         MVC   CVARN,=CL8'STEPLIB' Set Variable Name           #DD10177\n         LA    R0,CVARN            A(Variable Name)            #DD10177\n         ST    R0,CVARN@                                       #DD10177\n         LA    R0,CVARN@                                       #DD10177\n         ST    R0,CVARNPT@                                     #DD10177\n         MVC   CVARL,=F'7'         Set Variable Name Length    #DD10177\n         LA    R0,CVARL            A(Variable Name Length)     #DD10177\n         ST    R0,CVARNLN@                                     #DD10177\n         LA    R0,BLANKS           A(Variable Data)            #DD10177\n         ST    R0,CVARD@                                       #DD10177\n         LA    R0,CVARD@                                       #DD10177\n         ST    R0,CVARDPT@                                     #DD10177\n         XC    CVARDL,CVARDL                                   #DD10177\n         LA    R0,CVARDL           A(Variable Data Length)     #DD10177\n         ST    R0,CVARDLN@                                     #DD10177\n         LA    R0,CVARTKN          A(Token)                    #DD10177\n         ST    R0,CVARTKN@                                     #DD10177\n         OI    CVARTKN@,X'80'      Set End Of List             #DD10177\n         l     R15,CVTPTR          A(CVT)                      #DD10177\n         USING CVTMAP,R15                                      #DD10177\n         L     R15,CVTTVT          A(TVT)                      #DD10177\n         USING TSVT,R15                                        #DD10177\n         L     R15,TSVTVACC        A(IKJCT441)                 #DD10177\n         DROP  R15                                             #DD10177\n         LA    R1,CVARPARM         A(IKJCT441 Parameter List)  #DD10177\n         BALR  R14,R15             Call IKJCT441               #DD10177\n\n*-------\n*        Count The Number Of STEPLIB Data Sets\n*-------\n         L     R4,PSATOLD          A(TCB)                      #DD10177\n         USING TCB,R4                                          #DD10177\n         ICM   R2,15,TCBJLB        A(STEPLIB DCB)              #DD10177\n         BZ    STEPERR2            B. IF ONE DOES NOT EXIST    #DD10177\n         DROP  R4                                              #DD10177\n         TM    WRKDDOLD,X'BF'      CHECK IF A STEPLIB EXISTS   #DD10177\n         BZ    STEPERR2            B. IF NOT                   #DD10177\n\n         ICM   R5,15,WRKDSAB@      A(DSAB)                     #DD10177\n         BZ    STEPERR2            B. IF CHAIN DOES NOT EXIST  #DD10177\n         USING DSABID,R5                                       #DD10177\n\n         SLR   R6,R6               Initialize STEPLIB Counter  #DD10177\nSTEP3000 DS    0H                                              #DD10177\n         L     R4,DSABSIOT         A(SIOT)                     #DD10177\n         USING INDMSIOT,R4                                     #DD10177\n         ST    R4,WRKSTEP@         Save SIOT Address           #DD10177\n         CLC   SCTDDNAM,WRKDDOLD   CHECK FOR THE STEPLIB       #DD10177\n         BE    STEP3100            B. IF FOUND                 #DD10177\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)                #DD10177\n         BNZ   STEP3000            B. IF ANOTHER DSAB EXISTS   #DD10177\n         B     STEPERR2            ELSE. UNABLE TO FIND STEPLIB#DD10177\n\nSTEP3100 DS    0H                                              #DD10177\n         AHI   R6,1                Increment DataSet Counter   #DD10177\n\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)                #DD10177\n         BZ    STEP3200            B. IF END OF DSAB CHAIN     #DD10177\n         L     R4,DSABSIOT         A(SIOT)                     #DD10177\n         CLC   SCTDDNAM,BLANKS     CHECK IF NEXT IS A CONCATENATION 177\n         BE    STEP3100            B. IF YES                   #DD10177\n         DROP  R4,R5                                           #DD10177\n\n*-------\n*        Allocate Storage For &STEPLIB Variable\n*-------\nSTEP3200 DS    0H                                              #DD10177\n         MHI   R6,47               Calculate Space Required    #DD10177\n         ST    R6,WRKVARL          Save Length Of Buffer       #DD10177\n         GETMAIN RU,LV=(R6),LOC=BELOW                          #DD10177\n         ST    R1,WRKVAR@          Save Buffer Address         #DD10177\n         ST    R1,WRKVARC@                                     #DD10177\n         #BLANK (R1),LEN=(R6)      Blank The Entire Buffer     #DD10177\n\n*-------\n*        Save The STEPLIB DataSet Names\n*-------\n         L     R5,WRKVAR@          A(Beginning Of Buffer)      #DD10177\n\n         L     R4,WRKSTEP@         A(1st STEPLIB SIOT)         #DD10177\n         USING INDMSIOT,R4                                     #DD10177\nSTEP3300 DS    0H                                              #DD10177\n         L     R1,SJFCBPTR         A(JFCB)                     #DD10177\n         USING INFMJFCB,R1                                     #DD10177\n         MVI   WRKINSRT,C''''      Insert Leading Quote        #DD10177\n         MVC   WRKINSRT+1(44),JFCBDSNM                         #DD10177\n         DROP  R1                                              #DD10177\n         MVC   0(45,R5),WRKINSRT   Save Current DataSet Name   #DD10177\n         AHI   R5,44               A(Last Possible Position)   #DD10177\nSTEP3400 DS    0H                                              #DD10177\n         CLI   0(R5),C' '          Check For End Of Dsname     #DD10177\n         BNE   STEP3500            B. If End Found             #DD10177\n         BCT   R5,STEP3400         Back Up & Keep Checking     #DD10177\n\nSTEP3500 DS    0H                                              #DD10177\n         MVI   1(R5),C''''         Insert Trailing Quote       #DD10177\n         AHI   R5,3                Point Past Inserted Dsname  #DD10177\n\nSTEP3600 DS    0H                                              #DD10177\n         ICM   R4,15,SIOTNPTR      A(Next SIOT)                #DD10177\n         BZ    STEP3700            B. If No More SIOTs         #DD10177\n         CLC   SCTDDNAM,BLANKS     Check If Another STEPLIB    #DD10177\n         BE    STEP3300            B. If Yes                   #DD10177\n         DROP  R4                                              #DD10177\n\nSTEP3700 DS    0H                                              #DD10177\n         SL    R5,WRKVAR@          Calculate Total Length      #DD10177\n\n         MVC   CVARD@,WRKVAR@      A(Variable Data)            #DD10177\n         ST    R5,CVARDL           Save Variable Length        #DD10177\n\n         l     R15,CVTPTR          A(CVT)                      #DD10177\n         USING CVTMAP,R15                                      #DD10177\n         L     R15,CVTTVT          A(TVT)                      #DD10177\n         USING TSVT,R15                                        #DD10177\n         L     R15,TSVTVACC        A(IKJCT441)                 #DD10177\n         DROP  R15                                             #DD10177\n         LA    R1,CVARPARM         A(IKJCT441 Parameter List)  #DD10177\n         BALR  R14,R15             Call IKJCT441               #DD10177\n\n*-------\n*        Release Storage Used For &STEPLIB Variable\n*-------\n         L     R5,WRKVAR@                                      #DD10177\n         L     R6,WRKVARL                                      #DD10177\n         FREEMAIN RU,A=(R5),LV=(R6)                            #DD10177\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS THE \"STEPLIB REMOVE\" FUNCTION                        *\n*             OR THE \"STEPLIB DESTACK\" FUNCTION                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP3800 DS    0H\n         L     R15,=A(MSG008I7)                                #DD10177\n         MVC   WRKFUNC,0(R15)                                  #DD10177\n         CLI   $TEPFUNC+1,$DESTACK CHECK FOR \"DESTACK\" FUNCTION#DD01072\n         BE    STEP3900            B. IF YES                   #DD01072\n         CLI   $TEPFUNC+1,$REMOVE  CHECK FOR \"REMOVE\" FUNCTION\n         BNE   STEP5200            B. IF NOT                   #DD01073\n         L     R15,=A(MSG008I5)                                #DD10177\n         MVC   WRKFUNC,0(R15)                                  #DD10177\nSTEP3900 DS    0H                                              #DD01072\n         CLI   $TEPDSNS+1,$DSNS    CHECK IF DATASET NAMES SPECIFIED\n         BNE   STEPERR1            B. IF NOT\n\n*-------\n*        CHECK IF THERE IS CURRENTLY A STEPLIB\n*-------\n         L     R4,PSATOLD          A(TCB)\n         USING TCB,R4\n         ICM   R2,15,TCBJLB        A(STEPLIB DCB)\n         BZ    STEPERR2            B. IF ONE DOES NOT EXIST    #DD01072\n         DROP  R4\n         TM    WRKDDOLD,X'BF'      CHECK IF A STEPLIB EXISTS   #DD05031\n         BZ    STEPERR2            B. IF NOT                   #DD05031\n\n*-------\n*        CLOSE THE PREVIOUSLY ALLOCATED STEPLIB\n*-------\n         LA    R0,CLOSEIRB         A(STEPLIB CLOSE ROUTINE)\n         LA    R1,WRKDDOLD         A(OLD DDNAME RETURN ADDRESS)\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY\n         LTR   R15,R15             CHECK IF CLOSE WAS SUCCESSFUL\n         BNZ   STEP6000            B. IF NOT                   #DD08268\n\n*-------\n*        SCAN THE DSAB CHAIN FOR THE OLD STEPLIB DDNAME\n*-------\n         NI    WRKFLAG1,255-WRK$1STD\n\n         ICM   R5,15,WRKDSAB@      A(DSAB)                     #DD01068\n         BZ    STEP6000            B. IF CHAIN DOES NOT EXIST  #DD08268\n         USING DSABID,R5\n\nSTEP4000 DS    0H\n         L     R4,DSABSIOT         A(SIOT)\n         USING INDMSIOT,R4\n         CLC   SCTDDNAM,WRKDDOLD   CHECK FOR PREVIOUS STEPLIB DDNAME\n         BE    STEP4100            B. IF FOUND\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)\n         BNZ   STEP4000            B. IF ANOTHER DSAB EXISTS\n         B     STEP5200            ELSE. CAN'T FIND STEPLIB    #DD01073\n\n*-------\n*        SCAN THE USER SPECIFIED LIST FOR A MATCHING STEPLIB DSNAME\n*-------\nSTEP4100 DS    0H\n         L     R1,SJFCBPTR         A(JFCB)\n         USING INFMJFCB,R1\n         MVC   WRKDSN1,JFCBDSNM    SAVE THE CURRENT DATASET NAME\n         DROP  R1\n\n         LA    R3,$TEPLIST         A(1ST USER SPECIFIED DSNAME)\nSTEP4200 DS    0H\n         L     R2,0(,R3)           A(SPECIFIED DSNAME)\n         LH    R1,4(,R3)           L(SPECIFIED DSNAME)\n         MVC   WRKDSN2,BLANKS      CLEAR DSNAME AREA           #DD99244\n         #EXEC -R1,MVC,WRKDSN2(*-*),0(R2)                      #DD99244\nSTEP4300 DS    0H                                              #DD01072\n         MVC   WRKLOCAT(MODLLOCL),MODLLOC                      #DD99244\n         LA    R0,WRKDSN2                                      #DD99244\n         ST    R0,WRKLOCAT+4       SAVE DSNAME ADDRESS         #DD99244\n         LA    R0,WRKAREA                                      #DD99244\n         ST    R0,WRKLOCAT+12      SAVE WORK AREA ADDRESS      #DD99244\n         LOCATE WRKLOCAT           CONVERT ALIAS TO REAL NAME  #DD99244\n         CLC   WRKDSN1,WRKDSN2     COMPARE DSNAMES             #DD99244\n         BNE   STEP4400            B. IF MATCH NOT FOUND       #DD01250\n         CLI   $TEPFUNC+1,$DESTACK CHECK FOR \"DESTACK\" FUNCTION#DD01250\n         BNE   STEP4800            B. IF NOT                   #DD01250\n         MVI   0(R2),X'FF'         DESTROY DSNAME SO THAT ONLY #DD01250\n*                                  1ST OCCURANCE IS REMOVED.   #DD01250\n         B     STEP4800                                        #DD01250\nSTEP4400 DS    0H                                              #DD01250\n         CLI   24(R3),X'FF'        CHECK FOR END OF LIST\n         BE    STEP4500            B. IF YES\n         L     R3,24(,R3)          A(NEXT DSNAME PDE)\n         B     STEP4200            SCAN TILL END OF LIST\n\n*-------\n*        ALLOCATE THE DSNAME TO THE NEW STEPLIB DDNAME\n*-------\nSTEP4500 DS    0H\n         LA    R0,WRKDSN1\n         ST    R0,WRKDSN@          A(CURRENT STEPLIB DSNAME)\n         LA    R0,L'WRKDSN1\n         STH   R0,WRKDSN@+4        L(CURRENT STEPLIB DSNAME)\n\n         TM    WRKFLAG1,WRK$1STD   CHECK IF 1ST DATASET ALLOCATED\n         BO    STEP4600            B. IF YES\n         OI    WRKFLAG1,WRK$1STD   REMEMBER 1ST DATASET WAS ALLOCATED\n         LA    R0,WRKDDNEW\n         ST    R0,WRKDDN@          A(CURRENT STEPLIB DDNAME)\n         LA    R0,L'WRKDDNEW\n         STH   R0,WRKDDN@+4        L(CURRENT STEPLIB DDNAME)\n         ALLOC PERM,DSN=WRKDSN@,DISP=SHR,                              *\n               DDN=WRKDDN@,FLAG1=S99NOCNV+S99NOMNT\n         LTR   R15,R15             CHECK ALLOCATION RETURN CODE\n         BZ    STEP4800            B. IF SUCCESSFUL\n         B     STEP4700            ELSE. ISSUE ALLOCATION ERROR MSG\n\n*-------\n*        CONCATENATE THE DSNAME TO THE NEW STEPLIB DDNAME\n*-------\nSTEP4600 DS    0H\n         ALLOC PERM,DSN=WRKDSN@,DISP=SHR,                              *\n               DDNTO=WRKDDRET,FLAG1=S99NOCNV+S99NOMNT\n         LTR   R15,R15             CHECK ALLOCATION RETURN CODE\n         BNZ   STEP4700            B. IF ALLOCATION FAILED\n\n         MVC   WRKCCTU1(4),=AL2(DCCDDNAM,2)\n         MVC   WRKCCDD1(2),=AL2(8) SET LENGTH OF DDNAME\n         MVC   WRKCCDD2(2),=AL2(8) SET LENGTH OF DDNAME\n         MVC   WRKCCTU2(4),=AL2(DCCPERMC,0)\n         MVC   WRKCCDD1+2(8),WRKDDNEW\n         MVC   WRKCCDD2+2(8),WRKDDRET\n         ALLOC VERB=S99VRBCC,TU=(WRKCCTU1,WRKCCTU2)\n         LTR   R15,R15             CHECK CONCATENATION RETURN CODE\n         BZ    STEP4800            B. IF CONCATENATION SUCCEEDED\n\n*-------\n*        PROCESS ALLOCATION/CONCATENATION ERRORS\n*-------\nSTEP4700 DS    0H\n         L     R2,WRKCPPL@         A(CPPL)                     #DD10106\n         S99FAIL CP=YES,CPPL=(R2), ISSUE ALLOC FAILURE MESSAGE #DD10106*\n               MF=(E,WRKFAIL)                                  #DD10106\n         #SETRC 8                  INDICATE AN ERROR OCCURRED  #DD01073\n         B     STEP6000                                        #DD08268\n\n*-------\n*        CHECK IF NEXT DSAB IS A CONCATENATION OF THE STEPLIB\n*-------\nSTEP4800 DS    0H\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)\n         BZ    STEP4900            B. IF END OF DSAB CHAIN     #DD99244\n         L     R4,DSABSIOT         A(SIOT)\n         CLC   SCTDDNAM,BLANKS     CHECK IF NEXT IS A CONCATENATION\n         BE    STEP4100            B. IF YES\n         DROP  R4,R5\n\n*-------\n*        OPEN THE NEWLY ALLOCATED STEPLIB\n*-------\nSTEP4900 DS    0H                                              #DD99244\n         LA    R0,WRKDDOLD         A(OLD STEPLIB DDNAME)\n         ST    R0,WRKDDN@\n         LA    R0,L'WRKDDOLD       L(OLD STEPLIB DDNAME)\n         STH   R0,WRKDDN@+4\n         CLC   =C'$TEP',WRKDDOLD   CHECK FOR \"FAKE\" STEPLIB DD #DD99244\n         BNE   STEP5000            B. IF NOT                   #DD99244\n         FREE  PERM,DDN=WRKDDN@    FREE THE OLD STEPLIB DDNAME\n\nSTEP5000 DS    0H                                              #DD99244\n         TM    WRKFLAG1,WRK$1STD   CHECK IF ALL DATASETS REMOVED\n         BZ    STEP5100            B. IF YES\n\n         LA    R0,OPENIRB          A(STEPLIB OPEN ROUTINE)\n         LA    R1,WRKDDNEW         A(NEW STEPLIB DDNAME)\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY\n         LTR   R15,R15             CHECK IF OPEN SUCCEEDED\n         BNZ   STEPERR3            B. IF NOT                   #DD08099\n\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION\n         BE    STEP6000            B. IF YES                   #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS\n         L     R1,=A(MSG004I)      'STEPLIB SHRUNK'            #DD10106\n         SLR   R2,R2\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE\n         B     STEP5200                                        #DD01073\n\n*-------\n*        INDICATE THAT ALL DATASETS WERE REMOVED FROM THE STEPLIB\n*-------\nSTEP5100 DS    0H\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION\n         BE    STEP6000            B. IF YES                   #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS\n         L     R1,=A(MSG003I)      'STEPLIB DEACTIVATED'       #DD10106\n         SLR   R2,R2\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE\n         B     STEP6000                                        #DD08268\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS THE \"APFCHK\" KEYWORD                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP5200 DS    0H                                              #DD01073\n         CLI   $TEPAPF+1,$APFCHK   CHECK FOR \"APFCHK\" KEYWORD  #DD01073\n         BNE   STEP6000            B. IF NOT                   #DD08268\n\n         LA    R0,CLOSEIRB         A(STEPLIB CLOSE ROUTINE)    #DD01073\n         LA    R1,WRKDDOLD         A(OLD DDNAME RETURN ADDRESS)#DD01073\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY      #DD01073\n\n         LA    R0,OPENIRB          A(STEPLIB OPEN ROUTINE)     #DD01073\n         LA    R1,WRKDDOLD         A(OLD STEPLIB DDNAME)       #DD01073\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY      #DD01073\n\n         TM    WRKDDOLD,X'BF'      CHECK IF A STEPLIB EXISTS   #DD01073\n         BZ    STEP6000            B. IF NOT                   #DD08268\n         L     R4,PSATOLD          A(TCB)                      #DD01073\n         USING TCB,R4                                          #DD01073\n         ICM   R2,15,TCBJLB        A(STEPLIB DCB)              #DD01073\n         BZ    STEP6000            B. IF ONE DOES NOT EXIST    #DD08268\n         DROP  R4                                              #DD01073\n\n         ICM   R5,15,WRKDSAB@      A(DSAB)                     #DD01073\n         BZ    STEP6000            B. IF CHAIN DOES NOT EXIST  #DD08268\n         USING DSABID,R5                                       #DD01073\n\nSTEP5300 DS    0H                                              #DD01073\n         L     R4,DSABSIOT         A(SIOT)                     #DD01073\n         USING INDMSIOT,R4                                     #DD01073\n         CLC   SCTDDNAM,WRKDDOLD   CHECK FOR THE STEPLIB DDNAME#DD01073\n         BE    STEP5400            B. IF FOUND                 #DD01073\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)                #DD01073\n         BNZ   STEP5300            B. IF ANOTHER DSAB EXISTS   #DD01073\n         B     STEP6000            ELSE. CAN'T FIND STEPLIB    #DD08268\nSTEP5400 DS    0H                                              #DD01073\n         L     R1,SJFCBPTR         A(JFCB)                     #DD01073\n         USING INFMJFCB,R1                                     #DD01073\n         MVC   WRKDSN2,JFCBDSNM                                #DD01073\n         DROP  R1                                              #DD01073\n         MVC   WRKLOCAT(MODLLOCL),MODLLOC                      #DD01073\n         LA    R0,WRKDSN2                                      #DD01073\n         ST    R0,WRKLOCAT+4       SAVE DSNAME ADDRESS         #DD01073\n         LA    R0,WRKAREA                                      #DD01073\n         ST    R0,WRKLOCAT+12      SAVE WORK AREA ADDRESS      #DD01073\n         LOCATE WRKLOCAT           CONVERT ALIAS TO REAL NAME  #DD01073\n         MVC   WRKVOL,WRKAREA+6    SAVE VOLUME SERIAL          #DD01073\n\n         CSVAPF REQUEST=QUERY,     CHECK IF IN APF LIST        #DD01073*\n               DSNAME=WRKDSN2,                                 #DD01073*\n               VOLTYPE=ANY,VOLUME=WRKVOL,                      #DD01073*\n               RETCODE=WRKCSVRC,RSNCODE=WRKCSVRS,              #DD01073*\n               MF=(E,WRKCSVPL)                                 #DD01073\n         ICM   R1,15,WRKCSVRC      CHECK IF \"IN APFLIST\"       #DD01073\n         BZ    STEP5800            B. IF YES                   #DD01073\n         CHI   R1,4                CHECK FOR RETURN CODE 4     #DD08112\n         BNE   STEP5500            B. IF NOT                   #DD08112\n         CLC   =X'0401',WRKCSVRS+2 CHECK FOR SMS APF LIBRARY   #DD08112\n         BE    STEP5800            B. IF YES                   #DD08112\n\nSTEP5500 DS    0H                                              #DD08112\n         #SETRC 12                 INDICATE AN ERROR OCCURRED  #DD01073\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION   #DD01073\n         BE    STEP5800            B. IF YES                   #DD01073\n         MVC   WRKINSRT(4),=AL2(48,9)    LENGTH+4/OFFSET       #DD01095\n         MVC   WRKINSRT+4(L'WRKDSN2),WRKDSN2                   #DD01073\n         LA    R1,WRKINSRT+4+L'WRKDSN2-1                       #DD01073\nSTEP5600 DS    0H                                              #DD01073\n         TM    0(R1),X'BF'         CHECK FOR END OF DSNAME     #DD01073\n         BNZ   STEP5700            B. IF FOUND                 #DD01073\n         BCT   R1,STEP5600         KEEP LOOPING BACKWARDS      #DD01073\nSTEP5700 DS    0H                                              #DD01073\n         LA    R1,1(,R1)           A(END OF INSERT BUFFER)     #DD01073\n         LA    R2,WRKINSRT         A(START OF INSERT BUFFER)   #DD01073\n         SR    R1,R2               CALCULATE INSERT LENGTH     #DD01073\n         STCM  R1,3,WRKINSRT       SET INSERT LENGTH           #DD01073\n\n         LA    R0,2                SET NUMBER OF SEGMENTS      #DD01073\n         L     R1,=A(MSG009I)      'DSNAME IS NOT IN APF LIST' #DD10106\n         LA    R2,WRKINSRT                                     #DD01073\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD01073\n\nSTEP5800 DS    0H                                              #DD01073\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)                #DD01073\n         BZ    STEP6000            B. IF END OF DSAB CHAIN     #DD08268\n         L     R4,DSABSIOT         A(SIOT)                     #DD01073\n         CLC   SCTDDNAM,BLANKS     CHECK FOR CONCATENATION     #DD01073\n         BE    STEP5400            B. IF YES                   #DD01073\n         B     STEP6000            ELSE. ALL DONE CHECKING     #DD08268\n         DROP  R5                                              #DD09103\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS THE \"VERSION\" KEYWORD                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP5900 DS    0H                                              #DD08098\n         L     R15,=A(MSG011I)                                 #DD10106\n         MVC   WRKMSG(MSG011IL),0(R15)                         #DD10106\n         MVC   MSG011I1+WRKMSG,STEPLIB+32                      #DD08098\n         MVC   MSG011I2+WRKMSG,STEPLIB+36                      #DD08098\n         MVC   WRKINSRT(4),=AL2(14,46)   LENGTH+4/OFFSET       #DD08098\n         MVC   WRKINSRT+4(10),=C'CCYY/MM/DD'                   #DD08098\n         MVC   WRKINSRT+4(4),STEPLIB+21                        #DD08098\n         MVC   WRKINSRT+9(2),STEPLIB+25                        #DD08098\n         MVC   WRKINSRT+12(2),STEPLIB+27                       #DD08098\n\n         LA    R0,2                SET NUMBER OF SEGMENTS      #DD08098\n         LA    R1,WRKMSG           '$TEP011I VERSION:'         #DD08098\n         LA    R2,WRKINSRT         ASSEMBLY DATE & TIME        #DD08098\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD08098\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PRODUCE A TCB/RB STRUCTURE LIST FOR DEBUGGING                *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP6000 DS    0H                                              #DD08268\n         CLI   $TEPMSGS+1,$DEBUG   CHECK FOR \"DEBUG\" OPTION    #DD08268\n         BNE   STEPEXIT            B. IF NOT                   #DD08268\n\n         L     R4,PSATOLD          A(CURRENT TCB)              #DD08268\n         USING TCB,R4                                          #DD08268\n         MVC   WRKJSTCB,TCBJSTCB   SAVE JOBSTEP TCB ADDRESS    #DD08268\n\n         L     R4,PSAAOLD          A(ASCB)                     #DD08268\n         USING ASCB,R4                                         #DD08268\n         L     R4,ASCBASXB         A(ASXB)                     #DD08268\n         USING ASXB,R4                                         #DD08268\n         L     R4,ASXBFTCB         A(REGION CONTROL TASK TCB)  #DD08268\n         USING TCB,R4                                          #DD08268\n\n         L     R15,=A(TRC001I)                                 #DD10050\n         MVC   WRKMSG(TRC001IL),0(R15)                         #DD10050\n         LA    R0,1                SET NUMBER OF SEGMENTS      #DD08268\n         LA    R1,WRKMSG           '$TEP009I TCB DATA'         #DD08268\n         SLR   R2,R2                                           #DD08268\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD08268\n\nSTEP6100 DS    0H                                              #DD08268\n         L     R15,=A(TRC001B)                                 #DD10050\n         MVC   WRKMSG(TRC001BL),0(R15)                         #DD10050\n         CL    R4,WRKJSTCB         IS THIS THE JOBSTEP TCB ?   #DD08268\n         BNE   STEP6200            B. IF NOT                   #DD08268\n         MVC   TRC001B1+WRKMSG,=C'(JSTCB)'                     #DD08268\n\nSTEP6200 DS    0H                                              #DD08268\n         ST    R4,WRKHEXIN         INPUT WORD                  #DD08268\n         BAL   R14,FULLCHAR        CONVERT TO CHARACTER        #DD08268\n         MVC   TRC001B2+WRKMSG,WRKHEXOU                        #DD08268\n         CL    R4,PSATOLD          CHECK FOR CURRENT TCB       #DD08268\n         BNE   STEP6300            B. IF NOT                   #DD08268\n         MVI   TRC001B3+WRKMSG,C'*'                            #DD08268\n\nSTEP6300 DS    0H                                              #DD08268\n         MVC   TRC001B4+WRKMSG,=C'UNKNOWN'                     #DD08268\n         ICM   R6,15,TCBRBP        A(TOP RB)                   #DD08268\n         BZ    STEP6700            B. IF NONE                  #DD08268\n         USING RBSECT,R6                                       #DD08268\nSTEP6400 DS    0H                                              #DD08268\n         CLI   RBSTAB1,RBFTPRB     CHECK FOR PRB               #DD08268\n         BE    STEP6500            B. IF YES                   #DD08268\n         ICM   R6,7,RBLINKB        A(NEXT RB)                  #DD08268\n         BNZ   STEP6400            B. IF ANOTHER EXISTS        #DD08268\n         B     STEP6700            ELSE. SKIP IT               #DD08268\n\nSTEP6500 DS    0H                                              #DD08268\n         SLR   R1,R1                                           #JR14048\n         ICM   R1,7,RBCDE1         A(CDE/LPDE)                 #JR14048\n         BZ    STEP6600            B. IF NONE                  #DD08268\n         USING CDENTRY,R1                                      #DD08268\n         MVC   TRC001B4+WRKMSG,CDNAME                          #DD08268\n         DROP  R1                                              #DD08268\n\nSTEP6600 DS    0H                                              #DD08268\n         MVC   TRC001B5+WRKMSG,BLANKS                          #DD08268\n         ICM   R1,15,TCBJLB        A(JOBLIB/STEPLIB)           #DD08268\n         BZ    STEP6700            B. IF NONE                  #DD08268\n         MVC   TRC001B5+WRKMSG,=C'-LNKLST-'                    #DD08268\n         L     R2,CVTPTR           A(CVT)                      #DD08268\n         USING CVTMAP,R2                                       #DD08268\n         CL    R1,CVTLINK          CHECK FOR LINKLIST          #DD08268\n         BE    STEP6700            B. IF NOT                   #DD08268\n         DROP  R2                                              #DD08268\n         LH    R1,DCBTIOT-IHADCB(,R1)                          #DD08268\n         A     R1,TCBTIO           A(TIOT ENTRY)               #DD08268\n         MVC   TRC001B5+WRKMSG,4(R1)                           #DD08268\n\nSTEP6700 DS    0H                                              #DD08268\n         MVC   WRKHEXIN,TCBJLB     INPUT WORD                  #DD08268\n         BAL   R14,FULLCHAR        CONVERT TO CHARACTER        #DD08268\n         MVC   TRC001B6+WRKMSG,WRKHEXOU                        #DD08268\n\n         LA    R0,1                SET NUMBER OF SEGMENTS      #DD08268\n         LA    R1,WRKMSG           '$TEP009I TCB DATA'         #DD08268\n         SLR   R2,R2                                           #DD08268\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD08268\n\n         LR    R1,R4               A(CURRENT TCB)              #DD08268\n         ICM   R4,15,TCBLTC        A(DAUGHTER TCB)             #DD08268\n         BNZ   STEP6100                                        #DD08268\n         ICM   R4,15,TCBNTC-TCB(R1)                            #DD08268\n         BNZ   STEP6100            A(SISTER TCB)               #DD08268\n         DROP  R4,R6                                           #DD08268\n\n         B     STEPEXIT                                        #DD08268\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS ANY ERRORS                                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEPERR1 DS    0H\n         #SETRC 8                  INDICATE AN ERROR OCCURRED  #DD01073\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION   #DD01073\n         BE    STEP6000            B. IF YES                   #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS\n         L     R1,=A(MSG005I)      'MISSING STEPLIB DSNAMES'   #DD10106\n         SLR   R2,R2\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE\n         B     STEP6000                                        #DD08268\n\nSTEPERR2 DS    0H                                              #DD01072\n         #SETRC 8                  INDICATE AN ERROR OCCURRED  #DD01073\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION   #DD01073\n         BE    STEP6000            B. IF YES                   #DD08268\n         LA    R0,2                SET NUMBER OF SEGMENTS      #DD01072\n         L     R1,=A(MSG008I)      'STEPLIB NOT ALLOCATED'     #DD10106\n         LA    R2,WRKFUNC                                      #DD01072\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD01072\n         B     STEP6000                                        #DD08268\n\nSTEPERR3 DS    0H                                              #DD08099\n         #SETRC 20                 INDICATE AN ERROR OCCURRED  #DD08099\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION   #DD08099\n         BE    STEP6000            B. IF YES                   #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS      #DD08100\n         L     R1,=A(MSG012I)      'STEPLIB OPEN FAILED'       #DD10106\n         SLR   R2,R2                                           #DD08099\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD08099\n         B     STEP6000                                        #DD08268\n\nSTEPERR4 DS    0H                                              #DD08268\n         #SETRC 28                 INDICATE AN ERROR OCCURRED  #DD08268\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION   #DD08268\n         BE    STEP6000            B. IF YES                   #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS      #DD08268\n         L     R1,=A(MSG014I)      'STEPLIB NOT AUTHORIZED'    #DD10106\n         SLR   R2,R2                                           #DD08268\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD08268\n         B     STEP6000                                        #DD08268\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        TERMINATE                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEPEXIT DS    0H\n         CLI   WRKTYPE,C'J'        CHECK FOR BATCH JOB         #DD09027\n         BNE   STEPEX99            B. IF NOT (DON'T PAUSE)     #DD09027\n\n         CLI   WRKANS@,X'FF'       Check If PDL returned       #DD10106\n         BE    STEPEX99            B. If Not                   #DD10106\n         ICM   R8,15,WRKANS@       Load PDL Address            #DD10106\n         BNP   STEPEX99            B. If No PDL                #DD10106\n         USING IKJPARMD,R8                                     #DD10106\n\n         L     R1,PAUSEPDE         A(PDE)                      #DD09027\n         ICM   R1,15,0(R1)         LOAD TIME TO WAIT           #DD09027\n         BZ    STEPEX99            B. IF NO WAITING            #DD09027\n         M     R0,=F'100'          CONVERT TO HUNDREDTHS       #DD09027\n         ST    R1,WRKTIME          SAVE HUNDREDTHS OF SECONDS  #DD09027\n         STIMER WAIT,BINTVL=WRKTIME WAIT FOR ANY HUNG IRB RTN  #DD09027\n\nSTEPEX99 DS    0H                                              #DD09027\n         IKJRLSA WRKANS@           RELEASE ANSWER BUFFER STORAGE\n         #STOP ,                   TERMINATE\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CREATE IRB TO PERFORM FUNCTION UNDER MAIN TASK'S TCB.        *\n*                                                                     *\n*        OPEN & CLOSE ARE DONE IN AN IRB SO THAT THE DCB BUFFERS      *\n*        ARE ASSOCIATED WITH THE TCB.                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\nSENDIRB  DS    0H\n         STM   R0,R15,WRKSEND      SAVE ALL REGISTERS          #DD09101\n         ST    R1,WRKREGS          PASS ROUTINE PARAMETER LIST\n         XC    WRKREGS+4(4),WRKREGS+4                          #DD09103\n         ST    R13,WRKREGS+8       PASS WORK AREA ADDRESS      #DD08268\n\n         MODESET MODE=SUP,KEY=ZERO\n\n         L     R6,WRKLCT@          A(LCT)                      #DD09101\n         L     R4,LCTTCBAD-LCT(R6) A(TCB)                      #DD09101\n         ST    R4,WRKTCB@                                      #DD09103\n\n         LA    R0,WRKREGS                                      #DD09103\n         ST    R0,WRKPARM@         A(PARAMETERS)               #DD09103\n\n         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=USE        #DD09103\n\n         SCHEDIRB EPPTR=WRKSEND,   ADDRESS OF IRB ENTRY POINT  #DD09103X\n               TCBPTR=WRKTCB@,     ADDRESS OF TCB,             #DD09103X\n               MODE=SUPR,          RUN IN SUPERVISOR STATE     #DD09103X\n               KEY=SUPR,           RUN IN KEY ZERO             #DD09103X\n               PARAMPTR=WRKPARM@,  PASS ADDRESS OF PARAMETERS  #DD09103X\n               MF=(E,WRKSCH,COMPLETE)                          #DD09103\n\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=USE                   #DD09103\n\n         MODESET MODE=PROB,KEY=NZERO\n\n         WAIT  ECB=WRKREGS+4       WAIT FOR THE EXIT TO END\n\n         CLI   $TEPMSGS+1,$DEBUG   CHECK FOR \"DEBUG\" OPTION    #DD08268\n         BNE   SEND0400            B. IF NOT                   #DD08268\n         ICM   R0,15,WRKDCB@       CHECK IF DCB ADDRESS EXISTS #DD08268\n         BZ    SEND0400            B. IF NOT                   #DD08268\n\n         L     R15,=A(TRC002I)                                 #DD10050\n         MVC   WRKMSG(TRC002IL),0(R15)                         #DD10050\n         MVC   TRC002I1+WRKMSG,WRKIRB                          #DD08268\n         MVC   WRKHEXIN,WRKDCB@    INPUT WORD                  #DD08268\n         BAL   R14,FULLCHAR        CONVERT TO CHARACTER        #DD08268\n         MVC   TRC002I2+WRKMSG,WRKHEXOU                        #DD08268\n         MVC   TRC002I3+WRKMSG,=C'Obtained'                    #DD08268\n         CLI   WRKIRB,C'O'         CHECK FOR \"OPEN\"            #DD08268\n         BE    SEND0300            B. IF YES                   #DD08268\n         MVC   TRC002I3+WRKMSG,=C'Released'                    #DD08268\nSEND0300 DS    0H                                              #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS      #DD08268\n         LA    R1,WRKMSG           '$TEP009I DCB ADDRESS:\"     #DD08268\n         SLR   R2,R2                                           #DD08268\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD08268\n\nSEND0400 DS    0H                                              #DD08268\n         LH    R15,WRKREGS+6       RETURN EXIT RETURN CODE\n         LM    R0,R14,WRKSEND      RESTORE RETURN ADDRESS      #DD09101\n         BR    R14                 RETURN TO CALLER\n         DROP  R8\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ASYNCRONOUS EXIT TO CLOSE THE STEPLIB DD STATEMENT.          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         PUSH  USING\n         DROP  ,\nCLOSEIRB DS    0H\n         LR    R12,R15             A(EXIT ENTRY POINT)\n         USING CLOSEIRB,R12\n         USING PSA,0\n\n         LR    R9,R1               A(INPUT PARAMETER)\n         L     R7,0(,R9)           A(STEPLIB DDNAME SAVE AREA)\n         L     R13,8(,R9)          RE-ESTABLIST WORK AREA      #DD08268\n         USING STEPWRK,R13                                     #DD08268\n         MVC   WRKIRB,=C'CLOSE'    TRACE CURRENT REQUEST       #DD08268\n\n         MVC   0(8,R7),BLANKS      CLEAR RETURN DDNAME AREA    #DD99245\n\n         L     R4,PSATOLD          A(TCB)\n         USING TCB,R4\n         L     R5,TCBTCT           A(TCT)\n         USING SMFTCT,R5\n         L     R6,TCTLCTAD         A(LCT)\n         USING LCT,R6\n         L     R2,LCTJOBLB         A(JOBLIB DCB)\n         SLR   R0,R0\n         ST    R0,LCTJOBLB         ZERO LCT'S STEPLIB POINTER\n\nCLOSE100 DS    0H\n         ICM   R4,15,TCBTCB        A(NEXT LOWER TCB)\n         BZ    CLOSE200            B. IF AT END\n         C     R2,TCBJLB           CHECK FOR MATCHING DCB POINTER\n         BNE   CLOSE100            B. IF NOT LEAVE ALONE\n         ST    R0,TCBJLB           ZERO CURRENT TCB'S STEPLIB POINTER\n         B     CLOSE100            CONTINUE TILL END OF TCBS\n\nCLOSE200 DS    0H\n         LTR   R2,R2               CHECK IF A STEPLIB EXISTED  #DD99245\n         BZ    CLOSE400            B. IF NOT                   #DD99245\n\n         L     R4,PSATOLD          A(TCB)\n         L     R3,TCBTIO           A(TIOT)                     #DD10106\n         L     R1,TCBLTC           A(LAST TASK TCB)\n         MVC   TCBTIO,TCBTIO-TCB(R1)\n         MVI   0(R9),128           SET CLOSE OPTION\n         CLOSE ((R2)),MF=(E,(R9))\n         ST    R3,TCBTIO           RESTORE A(TIOT)             #DD10106\n         MVC   0(8,R7),DCBDDNAM-IHADCB(R2)\n\n         CLI   WRKTYPE,C'J'        CHECK FOR BATCH JOB         #DD08268\n         BE    CLOSE300            B. IF YES (FREE STEPLIB)    #DD08268\n         CLI   0(R7),C'$'          CHECK FOR \"$TEP...\"         #DD09050\n         BNE   CLOSE400            B. IF NOT                   #DD99245\n\nCLOSE300 DS    0H                                              #DD08268\n         ST    R2,WRKDCB@          SAVE FOR DEBUG MESSAGE      #DD08268\n         LHI   R3,MODLDCBL         Pre r1.12 DCB Length        #DD10050\n         TM    WRKFLAG1,WRK$R112   Check if z/OS R1.12 or >    #DD10050\n         BNO   *+8                 B. If Not                   #DD10050\n         AHI   R3,MODDCBEL         Add DCBE Length             #DD10050\n         STORAGE RELEASE,ADDR=(R2),SP=253,LENGTH=(R3),         #DD10050*\n               CALLRKY=YES,TCBADDR=TCBJSTCB                    #DD08268\n\nCLOSE400 DS    0H                                              #DD99245\n         SLR   R0,R0               SET SUCCESSFUL RETURN CODE\n         POST  4(,R9),(0)          POST WITH RETURN CODE\n         SVC   3                   RETURN TO CALLER\n         POP   USING\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        OPEN ABEND RECOVERY ROUTINE                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING                                           #DD04108\n         DROP  ,                                               #DD04108\n\nESTAERTN DS    0H                                              #DD04108\n         USING *,R15                                           #DD04108\n         CH    R0,=H'12'           RTM PROVIDE AN SDWA?        #DD04108\n         BNE   ESTAE100            B. IF YES                   #DD04108\n         SR    R15,R15             ELSE.                       #DD04108\n         BR    R14                 PERCOLATE                   #DD04108\n\nESTAE100 DS    0H                                              #DD04108\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS     #DD04108\n\n         SETRP RC=4,                                           #DD04108*\n               RETADDR=OPEN0100,   SET RETRY ADDRESS           #DD04108*\n               FRESDWA=YES,        FREE THE SDWA WHEN DONE     #DD04108*\n               REGS=(14,12),       RESTORE CALLER'S REGISTERS  #DD04108*\n               RETREGS=YES,                                    #DD04108*\n               DUMP=NO             DON'T CUT A DUMP            #DD04108\n\n         LTORG ,                   LITERAL POOL                #DD04108\n\n         POP   USING                                           #DD04108\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ASYNCRONOUS EXIT TO OPEN  THE STEPLIB DD STATEMENT.          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         PUSH  USING\n         DROP  ,\nOPENIRB  DS    0H\n         LR    R12,R15             A(EXIT ENTRY POINT)\n         USING OPENIRB,R12\n         USING PSA,0\n\n         LR    R9,R1               A(INPUT PARAMETER)\n         L     R7,0(,R9)           A(STEPLIB DDNAME)\n         L     R13,8(,R9)          RE-ESTABLIST WORK AREA      #DD08268\n         USING STEPWRK,R13                                     #DD08268\n         MVC   WRKIRB,=C'OPEN '    TRACE CURRENT REQUEST       #DD08268\n\n         LA    R0,8                SET FAILURE CODE            #DD99245\n         TM    0(R7),X'BF'         CHECK FOR VALID DDNAME      #DD99245\n         BZ    OPENEXIT            B. IF NOT                   #DD99245\n\n         L     R4,PSATOLD          A(TCB)\n         USING TCB,R4\n         L     R5,TCBTCT           A(TCT)\n         USING SMFTCT,R5\n         L     R6,TCTLCTAD         A(LCT)\n         USING LCT,R6\n         LHI   R3,MODLDCBL         Pre r1.12 DCB Length        #DD10050\n         TM    WRKFLAG1,WRK$R112   Check if z/OS R1.12 or >    #DD10050\n         BNO   *+8                 B. If Not                   #DD10050\n         AHI   R3,MODDCBEL         Add DCBE Length             #DD10050\n         STORAGE OBTAIN,LOC=BELOW,SP=253,LENGTH=(R3),          #DD10050*\n               CALLRKY=YES,TCBADDR=TCBJSTCB                    #DD08268\n         ST    R1,WRKDCB@          SAVE FOR DEBUG MESSAGE      #DD08268\n         LR    R2,R1               A(DCB)\n         MVC   0(MODLDCBL,R2),MODLDCB\n         MVC   DCBDDNAM-IHADCB(,R2),0(R7)\n\n*        Add DCBE As Added by z/OS R1.12 and Higher            #DD10050\n         TM    WRKFLAG1,WRK$R112   Check if z/OS R1.12 or >    #DD10050\n         BNO   OPEN0050            B. If Not                   #DD10050\n         LA    R1,MODLDCBL(,R2)    A(DCBE)                     #DD10050\n         MVC   0(MODDCBEL,R1),MODDCBE                          #DD10050\n         OI    DCBBFALN-IHADCB(R2),DCBH1+DCBH0  DCBE Exists    #DD10050\n         ST    R1,DCBDCBE-IHADCB(,R2) Save DCBE Address in DCB #DD10050\n\nOPEN0050 DS    0H                                              #DD10050\n         L     R3,TCBTIO           A(TIOT)                     #DD10106\n         L     R1,TCBLTC           A(LAST TASK TCB)\n         MVC   TCBTIO,TCBTIO-TCB(R1)\n\n         ESTAE ESTAERTN            ESTABLISH ABEND RECOVERY    #DD04108\n\n         MVI   0(R9),128           SET OPEN OPTION\n         OPEN  ((R2)),MF=(E,(R9))\nOPEN0100 DS    0H                                              #DD04108\n         ESTAE 0                   REMOVE RECOVERY ROUTINE     #DD04108\n\n         ST    R3,TCBTIO           RESTORE A(TIOT)             #DD10106\n\n         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN\n         BO    OPEN0200            B. IF OPEN WAS SUCCESSFUL\n         XC    WRKDCB@,WRKDCB@     RESET FOR DEBUG MESSAGE     #DD08268\n         LHI   R3,MODLDCBL         Pre r1.12 DCB Length        #DD10050\n         TM    WRKFLAG1,WRK$R112   Check if z/OS R1.12 or >    #DD10050\n         BNO   *+8                 B. If Not                   #DD10050\n         AHI   R3,MODDCBEL         Add DCBE Length             #DD10050\n         STORAGE RELEASE,ADDR=(R2),SP=253,LENGTH=(R3),         #DD10050*\n               CALLRKY=YES,TCBADDR=TCBJSTCB                    #DD08268\n         LA    R0,12               SET FAILURE CODE\n         B     OPENEXIT\n\nOPEN0200 DS    0H\n         ST    R2,LCTJOBLB-LCT(,R6) SAVE STEPLIB DCB IN LCT\n\nOPEN0300 DS    0H\n         ICM   R4,15,TCBTCB        A(NEXT LOWER TCB)\n         BZ    OPEN0400            B. IF AT END\n\n         CLC   TCBJLB,=F'0'        CHECK FOR IN-USE JOBLIB     #DD09199\n         BNE   OPEN0300            B. IF YES (LEAVE ALONE)     #DD09199\n\n         ST    R2,TCBJLB           SET NEW STEPLIB POINTER\n         B     OPEN0300            CONTINUE TILL END OF TCBS\n\nOPEN0400 DS    0H\n         SLR   R0,R0               SET SUCCESSFUL RETURN CODE\n\nOPENEXIT DS    0H\n         POST  4(,R9),(0)          POST WITH RETURN CODE\n         SVC   3                   RETURN TO CALLER\n         POP   USING\n\n         #EXEC ,                   EXECUTED STATEMENTS         #DD01068\n         LTORG ,                   LITERAL POOL                #DD01068\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CONVERT FULLWORD TO 8 BYTES PRINTABLE HEX                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING                                           #DD08268\nFULLCHAR DS    0H                                              #DD08268\n         STM   R0,R15,WRKREGS3     SAVE ALL REGISTERS          #DD08268\n         UNPK  WRKHEXOU(9),WRKHEXIN(5)                         #DD08268\n         TR    WRKHEXOU,HEXTABLE-C'0'                          #DD08268\n         MVI   WRKHEXOU+8,C' '                                 #DD08268\n         LM    R0,R15,WRKREGS3     RESTORE ALL REGISTERS       #DD08268\n         BR    R14                 RETURN TO CALLER            #DD08268\n         POP   USING                                           #DD08268\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ISSUE MESSAGE VIA PUTLINE                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\nISSUEMSG DS    0H\n         STM   R0,R14,WRKREGS1     SAVE ALL REGISTERS\n         STM   R0,R2,WRKOLD        #SEGMENTS, SEGMENT1 SEGMENT2\n         L     R4,WRKUPT@          A(UPT)\n         L     R5,WRKECT@          A(ECT)\n         XC    WRKECB,WRKECB\n         PUTLINE PARM=WRKPUTL,UPT=(R4),ECT=(R5),ECB=WRKECB,            *\n               OUTPUT=(WRKOLD,TERM,SINGLE,INFOR),                      *\n               MF=(E,WRKIOPL)\n         LM    R0,R15,WRKREGS1     RESTORE ALL REGISTERS\n         BR    R14                 RETURN TO CALLER\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        OPEN ABEND RECOVERY ROUTINE (FOR VALIDATION ROUTINE)         *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING                                           #DD08099\n         DROP  ,                                               #DD08099\n\nDDALEST  DS    0H                                              #DD08099\n         USING *,R15                                           #DD08099\n         CH    R0,=H'12'           RTM PROVIDE AN SDWA?        #DD08099\n         BNE   DDALEST1            B. IF YES                   #DD08099\n         SR    R15,R15             ELSE.                       #DD08099\n         BR    R14                 PERCOLATE                   #DD08099\n\nDDALEST1 DS    0H                                              #DD08099\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS     #DD08099\n\n         SETRP RC=4,                                           #DD08099*\n               RETADDR=DDALOP10,   SET RETRY ADDRESS           #DD08099*\n               FRESDWA=YES,        FREE THE SDWA WHEN DONE     #DD08099*\n               REGS=(14,12),       RESTORE CALLER'S REGISTERS  #DD08099*\n               RETREGS=YES,                                    #DD08099*\n               DUMP=NO             DON'T CUT A DUMP            #DD08099\n\n         LTORG ,                   LITERAL POOL                #DD08099\n\n         POP   USING                                           #DD08099\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DATASET NAME VALIDITY CHECKING ROUTINE (CONCATENATION)       *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\n         DROP  ,\nDDALLOC  DS    0H\n         USING DDALLOC,R15\n         STM   R14,R12,12(R13)     SAVE ALL REGISTERS\n         LR    R12,R15             SET SUBROUTINE BASE REGISTER\n         DROP  R15\n         USING DDALLOC,R12\n         L     R5,0(,R1)           A(DSNAME PDE)\n         LR    R10,R13             A(ORIGINAL SAVEAREA)\n         L     R9,4(,R1)           A(USER WORKAREA)\n         USING STEPWRK,R9\n         LA    R13,WRKREGS         A(SUBROUTINE SAVE AREA)\n\n*-------                                                       #DD01068\n*        IF THE \"ADD\" FUNCTION IS REQUESTED, DONT CONTINUALLY  #DD01068\n*        ALLOCATE DSNAMES THAT ARE ALREADY ALLOCATED TO THE    #DD01068\n*        STEPLIB.  INDICATE VIA A RETURN CODE OF 4 THAT        #DD01068\n*        \"AT LEAST 1\" OF THE DATASETS TO BE ADDED WERE NOT.    #DD01068\n*-------                                                       #DD01068\n         L     R8,WRKANS@          LOAD PDL ADDRESS            #DD01068\n         USING IKJPARMD,R8                                     #DD01068\n         L     R2,0(,R5)           A(SPECIFIED DSNAME)         #DD01068\n         LH    R1,4(,R5)           L(SPECIFIED DSNAME)         #DD01068\n         MVC   WRKDSN2,BLANKS      CLEAR DSNAME AREA           #DD01068\n         #EXEC -R1,MVC,WRKDSN2(*-*),0(R2)                      #DD01068\n         CLI   $TEPFUNC+1,$ADD     CHECK FOR \"ADD\" FUNCTION    #DD08101\n         BNE   DDAL0400            B. IF NOT                   #DD08101\n         CLC   =C'$TEP',WRKDDOLD   CHECK FOR \"FAKE\" STEPLIB DD #DD08101\n         BNE   DDAL0400            B. IF NOT                   #DD08101\n         MVC   WRKLOCAT(MODLLOCL),MODLLOC                      #DD01068\n         LA    R0,WRKDSN2                                      #DD01068\n         ST    R0,WRKLOCAT+4       SAVE DSNAME ADDRESS         #DD01068\n         LA    R0,WRKAREA                                      #DD01068\n         ST    R0,WRKLOCAT+12      SAVE WORK AREA ADDRESS      #DD01068\n         LOCATE WRKLOCAT           CONVERT ALIAS TO REAL NAME  #DD01068\n         ICM   R6,15,WRKDSAB@      A(DSAB)                     #DD01068\n         BZ    DDAL0400            B. IF CHAIN DOES NOT EXIST  #DD01068\n         USING DSABID,R6                                       #DD01068\nDDAL0100 DS    0H                                              #DD01068\n         L     R4,DSABSIOT         A(SIOT)                     #DD01068\n         USING INDMSIOT,R4                                     #DD01068\n         CLC   SCTDDNAM,WRKDDOLD   CHECK FOR START OF STEPLIB  #DD01068\n         BE    DDAL0200            B. IF FOUND                 #DD01068\n         ICM   R6,15,DSABFCHN      A(NEXT DSAB)                #DD01068\n         BNZ   DDAL0100            B. IF ANOTHER DSAB EXISTS   #DD01068\n         B     DDAL0400            ELSE. NO $TEP#### DDNAME    #DD01068\nDDAL0200 DS    0H                                              #DD01068\n         L     R1,SJFCBPTR         A(JFCB)                     #DD01068\n         USING INFMJFCB,R1                                     #DD01068\n         CLC   JFCBDSNM,WRKDSN2    CHECK FOR MATCHING DSNAME   #DD01068\n         BE    DDAL0300            B. IF ALREADY ALLOCATED     #DD01068\n         DROP  R1                                              #DD01068\n         ICM   R6,15,DSABFCHN      A(NEXT DSAB)                #DD01068\n         BZ    DDAL0400            B. IF END OF CHAIN          #DD01068\n         L     R4,DSABSIOT         A(SIOT)                     #DD01068\n         CLC   SCTDDNAM,BLANKS     CHECK FOR CONCATENATION     #DD01068\n         BNE   DDAL0400            B. IF END OF $TEP###'S      #DD01068\n         B     DDAL0200            ELSE. CONTINUE SEARCHING    #DD01068\n         DROP  R6                                              #DD09103\nDDAL0300 DS    0H                                              #DD01068\n         #SETRC 4                  SET MAINLINE RETURN CODE    #DD01068\n         LA    R15,0               SET VALIDCK RETURN CODE     #DD01068\n         B     DDALEXIT            CONTINUE PARSING            #DD01068\n\nDDAL0400 DS    0H                                              #DD01068\n         LA    R15,0               SET VALIDCK RETURN CODE     #DD01072\n         CLI   $TEPFUNC+1,$REMOVE  CHECK FOR \"REMOVE\" FUNC.    #DD01072\n         BE    DDALEXIT            B. IF YES (DON'T ALLOCATE)  #DD01072\n         CLI   $TEPFUNC+1,$DESTACK CHECK FOR \"DESTACK\" FUNC.   #DD01072\n         BE    DDALEXIT            B. IF YES (DON'T ALLOCATE)  #DD01072\n         TM    WRKFLAG1,WRK$1STD   CHECK IF 1ST DATASET WAS ALLOCATED\n         BO    DDAL0600            B. IF YES\n         LA    R0,WRKDDNEW\n         ST    R0,WRKDDN@          A(CURRENT STEPLIB DDNAME)\n         LA    R0,L'WRKDDNEW\n         STH   R0,WRKDDN@+4        L(CURRENT STEPLIB DDNAME)\nDDAL0500 DS    0H\n         ALLOC PERM,DSN=((R5)),DISP=SHR,                               *\n               DDN=WRKDDN@,FLAG1=S99NOCNV+S99NOMNT\n         MVC   WRKDDN,WRKDDNEW     SAVE CURRENT DDNAME         #DD08099\n         OI    WRKFLAG1,WRK$1STD   REMEMBER 1ST DATASET WAS ALLOCATED\n         LTR   R15,R15             CHECK ALLOCATION RETURN CODE\n         BNZ   DDAL0550            B. IF ALLOCATION FAILED     #DD08099\n         BAL   R14,DDALOPEN        CATCH OPEN FAILURES         #DD08099\n         B     DDALEXIT                                        #DD08099\n\nDDAL0550 DS    0H                                              #DD08099\n         USING S99RB,R14\n         CLC   S99ERROR,=X'0410'   CHECK FOR \"DDNAME IN USE\" ERROR\n         BNE   DDAL0700            B. IF NOT\n         PACK  WRKDBL1,WRKDDNEW+4(4)\n         AP    WRKDBL1,=P'+1'      INCREMENT STEPLIB NUMBER\n         OI    WRKDBL1+7,X'0F'\n         UNPK  WRKDDNEW+4(4),WRKDBL1\n         DROP  R14\n         B     DDAL0500            RETRY ALLOCATION\n\nDDAL0600 DS    0H\n         ALLOC PERM,DSN=((R5)),DISP=SHR,                               *\n               DDNTO=WRKDDRET,FLAG1=S99NOCNV+S99NOMNT\n         MVC   WRKDDN,WRKDDRET     SAVE CURRENT DDNAME         #DD08099\n         LTR   R15,R15             CHECK ALLOCATION RETURN CODE\n         BNZ   DDAL0700            B. IF ALLOCATION FAILED\n         BAL   R14,DDALOPEN        CATCH OPEN FAILURES         #DD08099\n         TM    WRKFLAG1,WRK$ABND   CHECK IF AN ABEND OCCURED   #DD08101\n         BO    DDALEXIT            B. IF YES                   #DD08101\n\n         MVC   WRKCCTU1(4),=AL2(DCCDDNAM,2)\n         MVC   WRKCCDD1(2),=AL2(8) SET LENGTH OF DDNAME\n         MVC   WRKCCDD2(2),=AL2(8) SET LENGTH OF DDNAME\n         MVC   WRKCCTU2(4),=AL2(DCCPERMC,0)\n         MVC   WRKCCDD1+2(8),WRKDDNEW\n         MVC   WRKCCDD2+2(8),WRKDDRET\n         ALLOC VERB=S99VRBCC,TU=(WRKCCTU1,WRKCCTU2)\n         LTR   R15,R15             CHECK CONCATENATION RETURN CODE\n         BZ    DDALEXIT            B. IF CONCATENATION SUCCEEDED\n\nDDAL0700 DS    0H\n         L     R2,WRKCPPL@         A(CPPL)                     #DD10106\n         S99FAIL CP=YES,CPPL=(R2), ISSUE ALLOC FAILURE MESSAGE #DD10106*\n               MF=(E,WRKFAIL)                                  #DD10106\n         LA    R15,12              SET ERROR CODE\n\nDDALEXIT DS    0H\n         LR    R13,R10             A(ORIGINAL SAVE AREA)\n         ST    R15,16(,R13)        OVERLAY R15 IN SAVE AREA\n         LM    R14,R12,12(R13)     RESTORE ALL REGISTERS\n         BR    R14                 RETURN TO IKJPARS\n\n*-------\n*        CATCH OPEN ABENDS (IE. S913)\n*-------\nDDALOPEN DS    0H                                              #DD08099\n         STM   R0,R15,WRKREGS2     SAVE ALL REGISTERS          #DD08099\n\n         MVC   WRKDCB,MODLDCB      FORMAT TEMPORARY DCB        #DD08099\n         MVC   WRKDCBE,MODDCBE     FORMAT TEMPORARY DCBE       #DD12060\n         MVC   DCBDDNAM-IHADCB+WRKDCB,WRKDDN                   #DD08100\n         TM    WRKFLAG1,WRK$R112   Check if z/OS R1.12 or >    #DD12060\n         BNO   DDALOP05            B. If Not                   #DD12060\n         OI    DCBBFALN-IHADCB+WRKDCB,DCBH1+DCBH0 DCBE Exists  #DD12060\n         LA    R1,WRKDCBE          A(DCBE)                     #DD12060\n         ST    R1,DCBDCBE-IHADCB+WRKDCB Save DCBE Address      #DD12060\nDDALOP05 DS    0H                                              #DD12060\n         MVC   WRKOPEN(MODLOPEL),MODLOPEN                      #DD08099\n         MVC   WRKCLOSE(MODLCLOL),MODLCLOS                     #DD08099\n\n         ESTAE DDALEST             ESTABLISH ABEND RECOVERY    #DD08099\n\n         OPEN  WRKDCB,MF=(E,WRKOPEN)                           #DD08099\n         CLOSE WRKDCB,MF=(E,WRKCLOSE)                          #DD08099\n         B     DDALOP20                                        #DD08099\n\nDDALOP10 DS    0H                                              #DD08099\n         ESTAE 0                   REMOVE RECOVERY ROUTINE     #DD08100\n         OI    WRKFLAG1,WRK$ABND   INDICATE \"OPEN\" ABEND       #DD08099\n         #SETRC 24                                             #DD08099\n\n         MVC   WRKINSRT(4),=AL2(48,33)   LENGTH+4/OFFSET       #DD08099\n         MVC   WRKINSRT+4(44),WRKDSN2                          #DD08099\n\n         LA    R0,2                SET NUMBER OF SEGMENTS      #DD08099\n         L     R1,=A(MSG013I)      '$TEP013I OPEN FAILED FOR'  #DD10106\n         LA    R2,WRKINSRT         DSNAME                      #DD08099\n         STM   R0,R2,WRKOLD        COUNT, A(PART1), A(PART2)   #DD08101\n         L     R4,WRKUPT@          A(UPT)                      #DD08101\n         L     R5,WRKECT@          A(ECT)                      #DD08101\n         XC    WRKECB,WRKECB                                   #DD08101\n         PUTLINE PARM=WRKPUTL,UPT=(R4),ECT=(R5),ECB=WRKECB,    #DD08101*\n               OUTPUT=(WRKOLD,TERM,SINGLE,INFOR),              #DD08101*\n               MF=(E,WRKIOPL)                                  #DD08101\n\n         LA    R0,WRKDDN                                       #DD08101\n         ST    R0,WRKDDN@          A(CURRENT STEPLIB DDNAME)   #DD08101\n         LA    R0,L'WRKDDN                                     #DD08101\n         STH   R0,WRKDDN@+4        L(CURRENT STEPLIB DDNAME)   #DD08101\n         FREE  PERM,DDN=WRKDDN@    FREE THE STEPLIB DATASET    #DD08101\n         CLC   WRKDDN,WRKDDNEW     CHECK IF 1ST DATASET        #DD08101\n         BE    DDALOP30            B. IF YES                   #DD08101\n         LA    R0,WRKDDNEW                                     #DD08101\n         ST    R0,WRKDDN@          A(CURRENT STEPLIB DDNAME)   #DD08101\n         LA    R0,L'WRKDDNEW                                   #DD08101\n         STH   R0,WRKDDN@+4        L(CURRENT STEPLIB DDNAME)   #DD08101\n         FREE  PERM,DDN=WRKDDN@    FREE THE STEPLIB DATASET    #DD08101\n         B     DDALOP30                                        #DD08100\n\nDDALOP20 DS    0H                                              #DD08099\n         ESTAE 0                   REMOVE RECOVERY ROUTINE     #DD08099\n         TM    WRKFLAG1,WRK$ABND   CHECK IF AN ABEND OCCURED   #DD08101\n         BZ    DDALOP30            B. IF NOT                   #DD08101\n         LA    R0,WRKDDN                                       #DD08101\n         ST    R0,WRKDDN@          A(CURRENT STEPLIB DDNAME)   #DD08101\n         LA    R0,L'WRKDDN                                     #DD08101\n         STH   R0,WRKDDN@+4        L(CURRENT STEPLIB DDNAME)   #DD08101\n         FREE  PERM,DDN=WRKDDN@    FREE THE STEPLIB DATASET    #DD08101\n\nDDALOP30 DS    0H                                              #DD08100\n         LM    R0,R15,WRKREGS2     RESTORE ALL REGISTERS       #DD08099\n         BR    R14                 RETURN TO CALLER            #DD08099\n\n         LTORG ,                   LITERAL POOL                #DD01068\n         #EXEC ,                   EXECUTED STATEMENTS         #DD01068\n         POP   USING\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CONSTANTS & DYNAMIC WORKAREA                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nHEXTABLE DC    C'0123456789ABCDEF' HEX CONVERSION TABLE        #DD08268\n\nMODLDCB  DCB   DDNAME=*,DSORG=PO,RECFM=U,MACRF=E\n         DS    F                   DCB EXIT LIST (ALA IEFSD164)#DD08268\nMODLDCBL EQU   *-MODLDCB           DCB LENGTH\n\nMODDCBE  DCBE  EADSCB=OK                                       #DD10050\nMODDCBEL EQU   *-MODDCBE           DCBE LENGTH                 #DD10050\n\nMODLOPEN OPEN  (*-*),MF=L          OPEN PARAMETER LIST         #DD08099\nMODLOPEL EQU   *-MODLOPEN                                      #DD08099\nMODLCLOS CLOSE (*-*),MF=L          OPEN PARAMETER LIST         #DD08099\nMODLCLOL EQU   *-MODLCLOS                                      #DD12060\n\nMODLLOC  CAMLST NAME,*-*,,*-*      CATALOG PARAMETER LIST      #DD99244\nMODLLOCL EQU   *-MODLLOC           CATALOG PARAMETER LIST LEN  #DD99244\n\nBLANKS   DC    80C' '              LOTS OF BLANKS              #DD99244\n\nMSG001I  #MSG  '$TEP001I STEPLIB Expanded'\nMSG002I  #MSG  '$TEP002I STEPLIB Activated'\nMSG003I  #MSG  '$TEP003I STEPLIB Deactivated'\nMSG004I  #MSG  '$TEP004I STEPLIB Shrunk'\nMSG005I  #MSG  '$TEP005I Missing STEPLIB Dataset Name(s)'\nMSG006I  #MSG  '$TEP006I STEPLIB Dataset List - DDName():'     #DD01095\nMSG007I  #MSG  '$TEP007I - '\nMSG008I  #MSG  '$TEP008I STEPLIB Not ed, is not allocated'     #DD01072\nMSG008I1 #MSG  'add',OFFSET=21                                 #DD01072\nMSG008I2 #MSG  'allocat',OFFSET=21                             #DD01072\nMSG008I3 #MSG  'fre',OFFSET=21                                 #DD01072\nMSG008I4 #MSG  'list',OFFSET=21                                #DD01072\nMSG008I5 #MSG  'remov',OFFSET=21                               #DD01072\nMSG008I6 #MSG  'stack',OFFSET=21                               #DD01072\nMSG008I7 #MSG  'destack',OFFSET=21                             #DD01072\nMSG009I  #MSG  '$TEP009I  is not an APF authorized library'    #DD01073\nMSG010I  #MSG  '$TEP010I dataset(s) already found in STEPLIB'  #DD01095\nMSG011I  #MSG  '$TEP011I Version:___ Release:__ Assembly Date:' DD08098\nMSG011I1 EQU   4+17,3              INSERT OFFSET & LENGTH      #DD08098\nMSG011I2 EQU   4+29,2              INSERT OFFSET & LENGTH      #DD08098\nMSG011IL EQU   *-MSG011I                                       #DD08098\nMSG012I  #MSG  '$TEP012I STEPLIB OPEN Failed'                  #DD08099\nMSG013I  #MSG  '$TEP013I STEPLIB OPEN Failed for '             #DD08099\nMSG014I  #MSG  '$TEP014I STEPLIB Command is not APF Authorized' DD08268\n\nTRC001I  #MSG  '$TEP901I TCB Address  Program   Tasklib   TCBJLB' 08268\nTRC001IL EQU   *-TRC001I                                       #DD08268\nTRC001B  #MSG  '.         ________    ________  ________  ________' 268\nTRC001BA EQU   4+1,57              INSERT OFFSET & LENGTH      #DD08268\nTRC001B1 EQU   4+1,7               INSERT OFFSET & LENGTH      #DD08268\nTRC001B2 EQU   4+10,8              INSERT OFFSET & LENGTH      #DD08268\nTRC001B3 EQU   4+21,8              INSERT OFFSET & LENGTH      #DD08268\nTRC001B4 EQU   4+22,8              INSERT OFFSET & LENGTH      #DD08268\nTRC001B5 EQU   4+32,8              INSERT OFFSET & LENGTH      #DD08268\nTRC001B6 EQU   4+42,8              INSERT OFFSET & LENGTH      #DD08268\nTRC001BL EQU   *-TRC001B                                       #DD08268\nTRC002I  #MSG  '$TEP902I _____ - DCB Storage at ________ ________'\nTRC002I1 EQU   4+9,5               INSERT OFFSET & LENGTH      #DD08268\nTRC002I2 EQU   4+32,8              INSERT OFFSET & LENGTH      #DD08268\nTRC002I3 EQU   4+41,8              INSERT OFFSET & LENGTH      #DD08268\nTRC002IL EQU   *-TRC002I                                       #DD08268\n\n         #STARTWA PATCH=NO\n         CSVAPF MF=(L,WRKCSVPL)                                #DD01073\n         DYNSPACE ,                DYNAMIC ALLOCATION PARAMETER LIST\n         SCHEDIRB MF=(L,WRKSCH)                                #DD09103\nWRKCLOSE DS    0F,CL(MODLCLOL)     CLOSE PARAMETER LIST        #DD08099\nWRKCSVRC DS    F                   CSVAPF RETURN CODE          #DD01073\nWRKCSVRS DS    F                   CSVAPF REASON CODE          #DD01073\nWRKANS@  DS    A                   RETURNED PDL BUFFER ADDRESS\nWRKAREA  DS    0F,XL265            CATALOG LOCATE WORK AREA    #DD99244\n* THE FOLLOWING \"WRKCC...\" STATEMENTS MUST REMAIN IN ORDER\nWRKCCTU1 DS    AL2,AL2             CONCATENATION DDNAMES TEXT UNIT\nWRKCCDD1 DS    AL2,CL8             PRIMARY DDNAME\nWRKCCDD2 DS    AL2,CL8             SECONDARY DDNAME\nWRKCCTU2 DS    AL2,AL2             CONCATENATION \"PERMANENT\" TEXT UNIT\nWRKDBL1  DS    D                   DOUBLEWORD WORK AREA\nWRKDCB   DS    CL(MODLDCBL)        VALIDATION DCB              #DD08099\nWRKDCBE  DS    CL(MODDCBEL)        VALIDATION DCBE             #DD12060\nWRKDCB@  DS    A                   ACQUIRED/FREE'D DCB ADDRESS #DD08268\nWRKDDN@  DS    A,AL2               CURRENT DATASET'S DDNAME PDE\nWRKDDN   DS    CL8                 VALIDATION DDNAME           #DD08099\nWRKDDNEW DS    CL8                 CURRENT STEPLIB DDNAME\nWRKDDOLD DS    CL8                 ORIGINAL STEPLIB DDNAME\nWRKDDRET DS    CL8                 CURRENT DATASET'S RETURNED DDNAME\nWRKDDTMP DS    CL8                 //STEPLIB REPLACEMENT NAME  #DD99245\nWRKDSAB@ DS    A                   DSAB ADDRESS                #DD01068\nWRKDSN@  DS    A,AL2               CURRENT DATASET NAME PDE\nWRKDSN1  DS    CL44                CURRENT STEPLIB DATASET NAME\nWRKDSN2  DS    CL44                CURRENT \"INPUT\" DATASET NAME\nWRKECB   DS    A                   COMMAND PROCESSOR ECB\nWRKECT@  DS    A                   ECT ADDRESS\nWRKFAIL  DS    6F                  S99FAIL PARAMETER LIST\nWRKFLAG1 DS    X                   FLAG BYTE #1\nWRK$1STD EQU   BIT1   .1.. ....    - 1ST DSNAME ALLOCATED\nWRK$ABND EQU   BIT2   ..1. ....    - ABEND DURING DSN OPEN     #DD08099\nWRK$R112 EQU   BIT3   ...1 ....    - System is z/OS R1.12 or > #DD10050\nWRKFUNC  DS    CL12                REQUESTED FUNCTION INSERT   #DD01072\nWRKINSRT DS    AL2,AL2,CL80        PUTLINE MESSAGE INSERT\nWRKIOPL  DS    4F                  IOPL\nWRKIRB   DS    CL5                 \"OPEN\" OR \"CLOSE\"           #DD08268\nWRKLCT@  DS    A                   LCT ADDRESS                 #DD99245\nWRKTCB@  DS    A                   TCB ADDRESS                 #DD09103\nWRKLOCAT DS    5F                  CATALOG LOCATE PLIST        #DD99244\nWRKMSG   DS    AL2,AL2,CL256       PUTLINE MESSAGE AREA        #DD08098\nWRKOLD   DS    F                   NUMBER OF MESSAGE SEGMENTS\n         DS    A                   A(MESSAGE SEGMENT)\n         DS    A                   A(MESSAGE INSERT SEGMENT)\nWRKOPEN  DS    0F,CL(MODLOPEL)     CLOSE PARAMETER LIST        #DD08099\nWRKPPL   DS    7F                  PARSE PARAMETER LIST\nWRKPSWK  DS    F                   ORIGINAL PSW KEY            #DD08268\nWRKPUTL  PUTLINE MF=L              PUTLINE PARAMETER LIST\nWRKSEND  DS    18F                 REGISTER SAVE AREA          #DD09101\nWRKPARM@ DS    A                   SCHEDIRB PARAMETER POINTER  #DD09103\nWRKREGS  DS    18F                 REGISTER SAVE AREA\nWRKREGS1 DS    18F                 REGISTER SAVE AREA          #DD08268\nWRKREGS2 DS    18F                 REGISTER SAVE AREA          #DD08099\nWRKREGS3 DS    18F                 REGISTER SAVE AREA          #DD08268\nWRKTIME  DS    F                   PAUSE TIME                  #DD09027\nWRKCPPL@ DS    A                   CPPL Address                #DD10106\nWRKUPT@  DS    A                   UPT ADDRESS\nWRKVOL   DS    CL6                 VOLUME OF CURRENT DATASET   #DD01073\n\nWRKHEXIN DS    F                   BINARY TO CHARACTER INPUT   #DD08268\nWRKHEXOU DS    XL8,CL1             BINARY TO CHARACTER OUTPUT  #DD08268\nWRKJLB   DS    CL8                 TASKLIB DDNAME              #DD08268\nWRKJSTCB DS    A                   JOBSTEP TCB ADDRESS         #DD08268\nWRKTYPE  DS    C                   ADDRESS TYPE (T, J, S)      #DD08268\nWRKSSID  DS    X                   Subsystem Identifier        #DD10106\nWRKSTEP@ DS    A                   1st STEPLIB SIOT Address    #DD10177\nWRKVAR@  DS    A                   &STEPLIB Data Address       #DD10177\nWRKVARC@ DS    A                   Current Dsname Address      #DD10177\nWRKVARL  DS    F                   &STEPLIB Data Length        #DD10177\n\nCVARPARM DS    0D                  IKJCT441 Parameter List     #DD10177\nCVAREC@  DS    A                   A(Entry Code)               #DD10177\nCVARNPT@ DS    A                   A(Variable Name Pointer)    #DD10177\nCVARNLN@ DS    A                   A(Variable Name Length Pointer) 0177\nCVARDPT@ DS    A                   A(Variable Data)            #DD10177\nCVARDLN@ DS    A                   A(Variable Data Length)     #DD10177\nCVARTKN@ DS    A                   A(Token)                    #DD10177\n\nCVARCODE DS    F                   Entry Code                  #DD10177\nCVARN@   DS    A                   A(Variable Name)            #DD10177\nCVARN    DS    CL8                 Variable Name               #DD10177\nCVARL    DS    F                   Variable Name Length        #DD10177\nCVARD@   DS    A                   A(Variable Data)            #DD10177\nCVARDL   DS    F                   L(Variable Data)            #DD10177\nCVARTKN  DS    D                   Token                       #DD10177\n         #STOPWA ,\n\n         PRINT NOGEN\n*---------------------------------------------------------------------*\n*                                                                     *\n*        \"STEPLIB\" COMMAND KEYWORDS:                                  *\n*                                                                     *\n*        NOTE: SOME KEYWORDS (SHR & REUSE) ARE THERE SIMPLY TO MAKE   *\n*              THE COMMAND LINE LOOK MORE LIKE AN \"ALLOC\" COMMAND.    *\n*              A PREVIOUS VERSION HOOKED INTO THE \"ALLOC\" COMMAND,    *\n*              AND REMOVED THE \"STEPLIB\" DDNAME RESTRICTION.          *\n*              THIS VERSION WAS CREATED WHEN \"USERMODS\" WERE BEING    *\n*              ELIMINATED FROM THE SYSTEM.                            *\n*                                                                     *\n*---------------------------------------------------------------------*\nSTEPLIB  CSECT ,\n\nSTEPPCL  IKJPARM\n\n$TEPFUNC IKJKEYWD DEFAULT='ALLOCATE'\n         IKJNAME 'ADD'\n         IKJNAME 'ALLOCATE',ALIAS=('OVERRIDE','REPLACE')\n         IKJNAME 'DESTACK',ALIAS='UNSTACK'                     #DD01072\n         IKJNAME 'FREE',ALIAS='CLOSE'\n         IKJNAME 'LIST'\n         IKJNAME 'REMOVE',ALIAS='DELETE'\n         IKJNAME 'SAVE',INSERT='NOMSGS'                        #DD10177\n         IKJNAME 'STACK'                                       #DD01072\n         IKJNAME 'VERSION'                                     #DD08098\n$ADD     EQU     1                                             #DD01072\n$ALLOC   EQU     2                                             #DD01072\n$DESTACK EQU     3                                             #DD01072\n$FREE    EQU     4                                             #DD01072\n$LIST    EQU     5                                             #DD01072\n$REMOVE  EQU     6                                             #DD01072\n$SAVE    EQU     7                                             #DD10177\n$STACK   EQU     8                                             #DD01072\n$VERSION EQU     9                                             #DD08098\n\n$TEPDSNS IKJKEYWD ,\n         IKJNAME 'DATASETS',ALIAS='DSNAMES',SUBFLD=$TEPSUBF\n$DSNS    EQU   1                                               #DD01072\n\n$TEPDISP IKJKEYWD ,\n         IKJNAME 'OLD'                                         #DD01072\n         IKJNAME 'SHR'\n$OLD     EQU   1                                               #DD01072\n$SHR     EQU   2                                               #DD01072\n\n$TEPREUS IKJKEYWD ,\n         IKJNAME 'REUSE'\n\n$TEPOPTS IKJKEYWD DEFAULT='FIRST'\n         IKJNAME 'FIRST',ALIAS=('BEFORE','FRONT')\n         IKJNAME 'LAST',ALIAS=('AFTER','END')\n$FIRST   EQU   1                                               #DD01072\n$LAST    EQU   2                                               #DD01072\n\n$TEPMSGS IKJKEYWD DEFAULT='MSGS'\n         IKJNAME 'MSGS',ALIAS=('LOUD','VERBOSE')\n         IKJNAME 'NOMSGS',ALIAS=('QUIET','TERSE')\n         IKJNAME 'DEBUG'                                       #DD08268\n$MSGS    EQU   1                                               #DD01072\n$NOMSGS  EQU   2                                               #DD01072\n$DEBUG   EQU   3                                               #DD08268\n\n$TEPAPF  IKJKEYWD DEFAULT='NOAPFCHK'                           #DD01073\n         IKJNAME 'APFCHK'                                      #DD01073\n         IKJNAME 'NOAPFCHK'                                    #DD01073\n$APFCHK  EQU   1                                               #DD01073\n$NOAPFCH EQU   2                                               #DD01073\n\n$STEPAUS IKJKEYWD DEFAULT='PAUSE(1)'                           #DD09027\n         IKJNAME 'PAUSE',SUBFLD=$PAUSESF                       #DD09027\n\n$TEPSUBF IKJSUBF\n$TEPLIST IKJPOSIT DSNAME,LIST,USID,UPPERCASE,                          *\n               PROMPT='STEPLIB DATASET NAME(S)',VALIDCK=DDALLOC\n\n$PAUSESF IKJSUBF ,                                             #DD09027\nPAUSEPDE IKJIDENT 'PAUSE',MAXLNTH=1,FIRST=NUMERIC,INTEG        #DD09027\n\n         IKJENDP\n\n         PRINT GEN\n\n*-------\n*        DSECTS\n*-------\n         #DSECTS ALLOC,CVT,DCB,DEB,DSAB,ECT,IQE,LCT,PSA,RB,TCB,TCT,TSO,*\n               ASCB,ASXB,JSCB,QDB,SDWA,SIOT,JFCB,SSIB,RB,CDE,  #DD08268*\n               OUCB                                            #DD10106\n         PRINT NOGEN\n         IHADCBE ,                                             #DD10050\n         IKJTSVT ,           TSO Vector Table                  #DD10177\n         PRINT GEN\n\n         AIF   (D'CVTZOS_V1R12).NOZR112                        #DD10050\nCVTZOS_V1R12  EQU X'02'      z/OS V1R12                        #DD10050\n.NOZR112 ANOP  ,                                               #DD10050\n\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSUB": {"ttr": 20999, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01(\\x00\\x00\\x01\\x06\\x01\\x8f\\x01\\x17\\x11/!U\\r\\xcc\\x04)\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.40", "flags": 0, "createdate": "2006-01-18T00:00:00", "modifydate": "2017-04-22T21:55:00", "lines": 3532, "newlines": 1065, "modlines": 0, "user": "SOURCE"}, "text": "TSUB     TITLE 'TSUB - MAINTAIN LWA-POINTED-TO INCORE TSO AUTH TABLES'\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   Program Name:   TSUB                                              *\n*                                                                     *\n*                   ** This program is in the public domain. **       *\n*                                                                     *\n*  Documentation:   This program is meant to be run as a TSO          *\n*                   command, APF authorized except for the display    *\n*                   functions.                                        *\n*                                                                     *\n*    Environment:   TSO command, APF Authorized.                      *\n*                   PUTLINE interface enabled by APUT, EPUTL.         *\n*                   This program is non-reentrant.                    *\n*                                                                     *\n* Short Function:   This program deals with existing TSO \"auth\"       *\n*                   tables that are pointed to by fields in the       *\n*                   LWA (Logon Work Area) which is created for a      *\n*                   TSO session at LOGON time.  These tables are      *\n*                   the actual tables that your TSO session uses      *\n*                   to determine program authorization.  Many of      *\n*                   the characteristics of these tables can be        *\n*                   changed or reset by the TSUB program.  The        *\n*                   changes that TSUB can do, are of three types:     *\n*                                                                     *\n*                   1.  Replacing or blanking any table entry.        *\n*                   2.  Altering the LWA flags or fields that         *\n*                       determine this table's properties.            *\n*                   3.  Effectively nullifying an entry by            *\n*                       putting a C'?' into it.  This effectively     *\n*                       removes the entry, without nullifying any     *\n*                       of the following table entries.               *\n*                                                                     *\n*                Details:                                             *\n*                                                                     *\n*                   1.  TSUB can substitute a different program name  *\n*                       or insert a blank entry into any valid slot   *\n*                       of a TSO \"auth\" table that belongs to your    *\n*                       TSO session.                                  *\n*                                                                     *\n*                       You can effectively nullify a table           *\n*                       entry without blanking it, using the          *\n*                       \"nullify\" function \"N\" instead of the         *\n*                       \"blanking\" function \"B\".  The nullifying      *\n*                       function inserts a C'?' into the slot,        *\n*                       allowing all following slots to still         *\n*                       work, since a ? entry is not a blank that     *\n*                       delimits the table.                           *\n*                                                                     *\n*                       Blanking (not the last entry) is dangerous    *\n*                       (see below) because it invalidates all the    *\n*                       subsequent non-blank table entries.  But the  *\n*                       technique of blanking an entry can be used    *\n*                       carefully if you are sure of what you want    *\n*                       to accomplish.  That is why we are making     *\n*                       it available.  Use \"N\" instead of \"B\" most    *\n*                       of the time.                                  *\n*                                                                     *\n*                   2.  TSUB can change the characteristics of your   *\n*                       own session's TSO \"auth\" tables, that are     *\n*                       pointed to by the LWA, by means of changing   *\n*                       the LWA (Logon Work Area) settings for each   *\n*                       table.  For example, LWA table lengths can    *\n*                       be supplied or removed.  LWA flags marking    *\n*                       the table as coming from a STEPLIB can be     *\n*                       set, or removed.  Even the physical table     *\n*                       header can be altered to make the table       *\n*                       look as though it came from PARMLIB.          *\n*                                                                     *\n*   Introduction:   At LOGON time for a TSO session, the system       *\n*                   (program IKJEFTP2) copies a set of the E2, E8,    *\n*                   AP, and NS TSO authorization tables into SP 252   *\n*                   protected Key 0 storage which lies in the TSO     *\n*                   user's address space.  These are the tables       *\n*                   WHICH ARE ACTUALLY USED by that TSO session,      *\n*                   and their location is pointed to in the LWA       *\n*                   control block (Logon Work Area, which, by the     *\n*                   way is also created by program IKJEFTP2).  The    *\n*                   duration of these tables is for the life of       *\n*                   that TSO session.  TSO LOGON processing creates   *\n*                   both the LWA itself, and the copies of the auth   *\n*                   tables that the session uses.  TSUB displays      *\n*                   and manipulates this copy of these tables--the    *\n*                   ones that are actually in use. Thus, changes to   *\n*                   these tables are effective immediately, and       *\n*                   their scope affects only the issuing TSO          *\n*                   session.                                          *\n*                                                                     *\n*                   This is why the TSUB program effects \"personal    *\n*                   program authorization\" which does not affect      *\n*                   any other TSO users.  When you're trying out      *\n*                   a new program which needs to be authorized,       *\n*                   and you don't want it to be authorized to         *\n*                   anyone else, this is the technique to use.        *\n*                                                                     *\n*                   Where does TSO get these tables from, at LOGON    *\n*                   time?  Again, to be more specific:                *\n*                                                                     *\n*              Case 1.  The most commonly found source for the auth   *\n*                       tables pointed to in the LWA, is the \"common  *\n*                       storage\" tables created from the active       *\n*                       PARMLIB member IKJTSOxx.  Those are pointed   *\n*                       to by the TPVT control block + X'14' which    *\n*                       is the CTLT.  If the CTLT is the source of    *\n*                       the LWA tables, then lengths of the tables,   *\n*                       and the size of each entry, are copied from   *\n*                       the CTLT into the LWA (Logon Work Area).      *\n*                       Use the program called ASUB to directly       *\n*                       access the public tables from PARMLIB that    *\n*                       are pointed to by the CTLT (undocumented)     *\n*                       control block.  Our program, TSUB, accesses   *\n*                       the copy of those tables which is pointed to  *\n*                       by the LWA, which were created for the TSO    *\n*                       session at LOGON time, and which are unique   *\n*                       to the current TSO session.                   *\n*                                                                     *\n*              Case 2.  If a list of table entries for one or more    *\n*                       of the tables:  E2, E8, AP, or NS is not      *\n*                       found in the IKJTSOxx PARMLIB member that     *\n*                       is currently active, then the table in the    *\n*                       LWA is not copied from the IKJTABLS module    *\n*                       in LPALIB, but it is just pointed to.  Thus   *\n*                       in such a situation, TSUB cannot alter the    *\n*                       particular table.  The actual table is        *\n*                       located in PLPA, in that particular case.     *\n*                                                                     *\n*              Case 3.  If a copy of the IKJTABLS load module         *\n*                       containing csects IKJEFTE2, IKJEFTE8,         *\n*                       IKJEFTAP, and IKJEFTNS is found in an         *\n*                       APF-authorized STEPLIB that the TSO session   *\n*                       has access to (running as an APF authorized   *\n*                       STEPLIB only), then those E2, E8, NS, and AP  *\n*                       tables are copied into the LWA at LOGON       *\n*                       time, from that CSECT in the STEPLIB copy of  *\n*                       IKJTABLS.  Therefore the table entries in     *\n*                       the respective CSECTs of the IKJTABLS in the  *\n*                       authorized STEPLIB are the ones which are in  *\n*                       force for that user's TSO session.  But in    *\n*                       that case, no \"table lengths\" or \"number of   *\n*                       table entries\" from these tables, are         *\n*                       available.  The table is delimited by the     *\n*                       first blank entry in it.  This TSUB program   *\n*                       has the ability to blank any numbered table   *\n*                       entry.  Since a blank entry is a delimiter    *\n*                       for the entire table, and all entries after   *\n*                       the blank entry are no longer used, you       *\n*                       have to be very careful.  Therefore, when     *\n*                       blanking entries, you should usually blank    *\n*                       the last one only, unless you have a very     *\n*                       good reason to blank out a different entry,   *\n*                       other than the last one.  The good news is    *\n*                       that the effect of the TSUB program only      *\n*                       lasts for the duration of this LOGON, and     *\n*                       only for the userid that is currently running *\n*                       the TSUB program.                             *\n*                                                                     *\n*                       Again, use \"nullify\" (action \"N\") instead     *\n*                       of \"blank\" (action \"B\") most of the time.     *\n*                                                                     *\n*            Note - Tables copied from a CSECT in IKJTABLS do not     *\n*                   have lengths associated with them.  They are      *\n*                   delimited by a blank table entry at the end.      *\n*                   Therefore the copy of each such table pointed     *\n*                   to by the LWA, does not have any length           *\n*                   associated with it.  Therefore we can only        *\n*                   judge its length by looking at the first blank    *\n*                   entry that has been found by a forward scan.      *\n*                                                                     *\n*                   This program, TSUB, directly manipulates the      *\n*                   \"live\" authorization tables pointed to by the     *\n*                   LWA.  Supported tables are:  E2, E2, NS and       *\n*                   AP.  The public PP (Platform Program) table       *\n*                   and PC (Platform Command) table, not in the       *\n*                   LWA, are partly supported by this program, if     *\n*                   they had been created by their presence in the    *\n*                   active IKJTSOxx PARMLIB member.                   *\n*                                                                     *\n*    Description:   Display an Auth Table entry from any of the       *\n*                   TSO/E program list tables:  IKJEFTE2, IKJEFTE8,   *\n*                   IKJEFTNS or IKJEFTAP that are in storage.  Or     *\n*                   display the entire table.  Or replace a numbered  *\n*                   entry with a new program name.  Or blank out      *\n*                   any numbered entry.  (Be very careful if you are  *\n*                   attempting to blank an entry.  Blanking an entry  *\n*                   invalidates ALL subsequent entries).  Or          *\n*                   effectively nullify an entry by putting a ?       *\n*                   (queston mark and 7 blanks) into it.  If you are  *\n*                   invoking a display function, then the entire      *\n*                   table is shown, unless you enter a number, and    *\n*                   then, only that slot is shown.  The tables        *\n*                   handled by this program are the actual tables     *\n*                   pointed to by the LWA of the issuing TSO/E        *\n*                   address space, and they lie in that user's        *\n*                   TSO/E address space (unless they were pointed to, *\n*                   and are from an IKJTABLS load module that is in   *\n*                   the LPA list.)                                    *\n*                                                                     *\n*       Function:   To substitute one new program name in the local   *\n*                   incore TSO auth tables, IKJEFTE2, IKJEFTE8, or    *\n*                   IKJEFTAP, IKJEFTNS lists.  This is done to any    *\n*                   numbered entry of each table.  Or else merely to  *\n*                   display the contents of the entire table, or the  *\n*                   contents of any particular numbered entry.        *\n*                                                                     *\n*                   The effect of replacing any program name is       *\n*                   immediate.  The scope of the change, is just for  *\n*                   the issuing current TSO userid.                   *\n*                                                                     *\n*                   You can blank out any numbered entry in any of    *\n*                   the four tables.  But blanking an entry, will     *\n*                   invalidate all subsequent table entries which     *\n*                   follow the blanked entry slot.  So be careful!    *\n*                                                                     *\n*                   Better than blanking an entry, you can \"nullify\"  *\n*                   an entry, which inserts a \"?\" character into the  *\n*                   table entry instead of blanks.  The subsequent    *\n*                   table entries remain valid.  The \"nullify\"        *\n*                   function is \"N\".  The \"blanking\" function is      *\n*                   \"B\".                                              *\n*                                                                     *\n*                   Or, you can use this program to list the complete *\n*                   contents of any of the auth tables which are      *\n*                   incore.                                           *\n*                                                                     *\n*                   Additionally, as described below, you can change  *\n*                   fields in the LWA which characterize the          *\n*                   individual tables--size characteristics and       *\n*                   whether or not the table came from STEPLIB.       *\n*                                                                     *\n*         Syntax:   TSUB ttA nnn pgmname                              *\n*                                                                     *\n*                   Where tt is a table code, and A is an action      *\n*                   code.                                             *\n*                                                                     *\n*                   The table code is a nickname for any of the       *\n*                   TSO/E auth tables which are incore.  They are:    *\n*                                                                     *\n*                   E2 - IKJEFTE2 = AUTHCMD  entry in IKJTSOxx        *\n*                   E8 - IKJEFTE8 = AUTHPGM  entry in IKJTSOxx        *\n*                   AP - IKJEFTAP = AUTHTSF  entry in IKJTSOxx        *\n*                   NS - IKJEFTNS = NOTBKGND entry in IKJTSOxx        *\n*                   PP -            PLATPGM  table in IKJTSOxx        *\n*                   PC -            PLATCMD  table in IKJTSOxx        *\n*                                                                     *\n*                   If the action code is B (blank the numbered       *\n*                   entry), then no program name is required,         *\n*                   but a number is required.  When blanking a        *\n*                   table entry, BE VERY CAREFUL !!!!!                *\n*                                                                     *\n*                   If the action code is N (nullify the numbered     *\n*                   entry), then no program name is required,         *\n*                   but a number is required.  Nullifying a table     *\n*                   entry will insert a \"?\" (question mark) into      *\n*                   that particular table slot, effectively           *\n*                   nullifying that entry, but NOT the entries        *\n*                   which follow, since blanks are the table          *\n*                   delimiters.                                       *\n*                                                                     *\n*     IMPORTANT  >  Under most circumstances, you should use the      *\n*       N O T E  >  \"nullify\" function \"N\" instead of the \"blanking\"  *\n*                >  function \"B\".  N will only nullify that one       *\n*                >  table entry, leaving all subsequent entries       *\n*                >  valid.  Blanking an entry will leave all          *\n*                >  subsequent table entries invalid.                 *\n*                                                                     *\n*       WARNING  >  If you blank out an entry which is not the        *\n*       WARNING  >  last entry in the particular table, then          *\n*       WARNING  >  all subsequent entries in that table are          *\n*       WARNING  >  rendered invalid!  It is best to restore          *\n*       WARNING  >  a non-blank entry to that slot, using the         *\n*       WARNING  >  ttR function, where tt is the table code.         *\n*                   Then you will be able to display the rest         *\n*                   of the table using the ttD function.              *\n*                                                                     *\n*                   If the action code is D (display the given        *\n*                   entry), then no program name is required.         *\n*                   The default action is to display the entire       *\n*                   table, unless a number is entered.  If a          *\n*                   number is present, then only that entry           *\n*                   number is displayed.  If the number is larger     *\n*                   than the number of entries in that particular     *\n*                   table, then an informative error message is       *\n*                   issued, and the program ends with code = 4.       *\n*                                                                     *\n*                   If the action code is R (replace the program      *\n*                   name) then a number (the table entry number)      *\n*                   and a program name are required.  If you want     *\n*                   to blank that slot, instead of putting a          *\n*                   program name into it, then use action code B.     *\n*                   But if you are blanking any slot which is not     *\n*                   the last slot, then PLEASE HEED THE WARNING       *\n*                   THAT IS ABOVE.  Use action \"N\" instead of \"B\"     *\n*                   most of the time.  This will not invalidate       *\n*                   subsequent table entries.                         *\n*                                                                     *\n*                   If the action code is H, then TSUB will replace   *\n*                   the last 8 bytes of the table header with the     *\n*                   literal: C' PARMLIB', as if the table were        *\n*                   created from the IKJTSOxx member in PARMLIB.      *\n*                                                                     *\n*                   If the action code is L, then TSUB will look to   *\n*                   create a length value for that table.  This value *\n*                   is equal to the length of a table with all the    *\n*                   non-blank entries, plus all the potential blank   *\n*                   entries at the end of the table.  So this number  *\n*                   will often reflect more entries than TSO will     *\n*                   actually use.  Additionally, TSUB can change or   *\n*                   blank any one of these entries, because TSUB's    *\n*                   range depends on the number of entries indicated  *\n*                   by the LWA length.  (If there's no length, then   *\n*                   TSUB uses the length of all non-blank entries     *\n*                   plus the first blank, if it exists.)              *\n*                                                                     *\n*                   If the action code is M, then TSUB will look to   *\n*                   create a length value for that table.  This value *\n*                   is equal to the length of a table with all the    *\n*                   non-blank entries, plus one blank entry, if any   *\n*                   perceived blank entries exist at the end of the   *\n*                   table.                                            *\n*                                                                     *\n*                   If the action code is Z, then TSUB will look at   *\n*                   the LWA length value for that table, and it will  *\n*                   zero that length value, whether it already was    *\n*                   zero, or not.                                     *\n*                                                                     *\n*                   If the action code is S, then TSUB will make      *\n*                   the given table look like it came from STEPLIB,   *\n*                   so that a subsequent PARMLIB UPDATE(xx) command   *\n*                   will not overlay the session's auth table.        *\n*                                                                     *\n*                   If the action code is P, then TSUB will make      *\n*                   the given table look like it came from PARMLIB,   *\n*                   so that a subsequent PARMLIB UPDATE(xx) command   *\n*                   will overlay the session's auth table.            *\n*                                                                     *\n*                   If the action code is X, then TSUB will display   *\n*                   all the LPA address ranges (undocumented).        *\n*                                                                     *\n*                   If the PLATCMD or PLATPGM keywords (and at least  *\n*                   one name) were not coded in the active IKJTSOxx   *\n*                   PARMLIB entry, then there is no control block of  *\n*                   names to be pointed to.  The condition is         *\n*                   reported.  If these keywords WERE coded in the    *\n*                   IKJTSOxx member of PARMLIB which is currently     *\n*                   active, then the PC and PP table codes in TSUB    *\n*                   WILL ACT ON THE COMMON STORAGE COPY of THESE      *\n*                   TWO TABLES ONLY.                                  *\n*                                                                     *\n*  Recommendation:  First list the entire table using the \"D\"         *\n*                   action code, and then decide which entry, by      *\n*                   number, that you want to replace.                 *\n*                                                                     *\n*                   Then use the \"R\" action code, to replace the      *\n*                   particular numbered entry you have chosen.        *\n*                                                                     *\n*            Note:  The E2, E8, AP, or NS table which is being        *\n*                   used by the system, can come from either the      *\n*                   IKJTSOxx PARMLIB entry, or it can come from       *\n*                   an IKJTABLS load module which was running         *\n*                   from an APF authorized library as a STEPLIB,      *\n*                   or a default IKJTABLS entry in LPALIB.  Each      *\n*                   CSECT is copied into the TSO user's address       *\n*                   space, albeit in a protected key, and pointed     *\n*                   to by the user's LWA, except in the case of an    *\n*                   IKJTABLS CSECT that is in LPALIB.  These are      *\n*                   the actual auth tables, E2, E8, AP, NS, in        *\n*                   use by that TSO address space.                    *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  Change Log:                                                        *\n*    2008/09/10 - 1.0 - Initial version - Got it to work.             *\n*                       TSUB can blank any slot.  I'm allowing        *\n*                       that for now, because the scope of the        *\n*                       possible damage is only for that TSO          *\n*                       session as long as it is logged on.           *\n*                       The LWA auth tables are all reset by          *\n*                       logging on to that TSO session again.         *\n*                                                                     *\n*    2008/09/15 - 1.0 - Filled in and cleaned up some of the doc.     *\n*                                                                     *\n*    2009/01/28 - 1.0 - Added action codes: H, L, Z, S, P             *\n*                                                                     *\n*         All action codes except D need APF-authorization.           *\n*                                                                     *\n*         What they do:                                               *\n*                                                                     *\n*            H - Add PARMLIB-like table header, in 2nd 8-bytes.       *\n*            L - Supply length of table in LWA with ALL the blanks.   *\n*            M - Supply length of table to first blank, in LWA.       *\n*            Z - Zero the table length marked in the LWA.             *\n*            S - Mark that the table came from STEPLIB, so            *\n*                 someone (else's) PARMLIB UPDATE(xx) won't           *\n*                 overlay it.                                         *\n*            P - Turn off STEPLIB bit in LWA and mark that it         *\n*                 came from PARMLIB.  Now PARMLIB UPDATE(xx)          *\n*                 will overlay the table.                             *\n*            X - (undocumented) Gives LPA storage range display.      *\n*                                                                     *\n*         Other action codes are: (these are the original ones)       *\n*                                                                     *\n*            D - Display table entries by slot number.                *\n*            R - Replace the entry in a given slot, by another one.   *\n*            B - Blank a given table entry, by slot number.           *\n*            N - Nullify a given table entry, by slot number.         *\n*                 (It works by inserting a ? (question mark)          *\n*                  into that table slot.)                             *\n*                                                                     *\n*    2009/02/01 - 1.1 - Fourth and fifth base registers.              *\n*                                                                     *\n*         Improved message clarity.  Told messages to show states,    *\n*          \"before\" and \"after\" any changes were made.                *\n*                                                                     *\n*    2009/02/12 -1.1.26 Fix bug in calculating length of NS table.    *\n*         Fix convoluted logic in calculating table lengths.          *\n*                                                                     *\n*    2009/02/13 -1.1.27 Measure perceived blanks after logical end    *\n*         of the table.  For NS table, blank an entry with X'0000'    *\n*         for the \"length\" field, instead of X'FFFF', to see more     *\n*         perceived blanks, if there are any.                         *\n*                                                                     *\n*    2009/02/16 -1.1.29 Added option M to tailor length to reflect    *\n*         only up to the first blank.  Changed option L to make the   *\n*         LWA length equal to all non-blank entries plus all blank    *\n*         entries too.  Thus the table can be expanded, even if       *\n*         lengths are there.                                          *\n*                                                                     *\n*    2009/02/18 -1.1.31 Cosmetic changes. Put in Version numbers.     *\n*                                                                     *\n*    2009/02/20 -1.1.32 Improved displays for PC and PP tables.       *\n*                       Made sure S,P,H,L,M,Z options for PC and PP   *\n*                       actually do nothing, and say they do nothing. *\n*                       Made \"error display\" messages better.         *\n*                                                                     *\n*    2009/02/24 -1.1.33 Better messages if PLATPGM or PLATCMD tables  *\n*                       are missing.                                  *\n*                                                                     *\n*    2009/03/03 -1.1.34 More cosmetic changes in title & messages.    *\n*                                                                     *\n*    2011/03/24 -1.1.37 If an installation has an \"authorization SVC\" *\n*                       already installed, put in a provision to use  *\n*                       it with conditional assembly.  Of course,     *\n*                       you have to code your own appropriate         *\n*                       invocation code for the SVC, and its number,  *\n*                       in the AUTHON and AUTHOFF macros provided     *\n*                       in this code here.  Otherwise, SETC the &SVC  *\n*                       variable to 'NOSVC'                           *\n*                                                                     *\n*    2016/10/30 -1.1.38 A Blanking function on a table entry will     *\n*                       invalidate all subsequent table entries.      *\n*                       So I introduced a \"nullify\" function \"N\"      *\n*                       which will put a question mark, followed      *\n*                       by seven blanks, into a table entry,          *\n*                       effectively nullifying that entry, without    *\n*                       nullifying all the following entries too.     *\n*                                                                     *\n*    2016/12/07 -1.1.39 Describe the nullify function in HELP.        *\n*                                                                     *\n*    2017/04/21 -1.1.40 Cosmetic + Save parms only after second       *\n*                       base was loaded.  SAVEPARM location           *\n*                       is > +X'1000' off program start.              *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n***********************************************************************\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*       I N S T R E A M    M A C R O S                                *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n***********************************************************************\n*  If you are turning on authorization for this program using a\n*   \"trick SVC\", then do   &SVC  SETC  'SVC'\n*   and put your SVC invocation code in the AUTHON and AUTHOFF macros.\n*\n         LCLC  &SVC,&SVCX\n&SVC     SETC  'NOSVC'\n*&SVC     SETC  'SVC'\nSVNO     EQU   242\n&SVCX    SETC  '242'\n         AIF   ('&SVC' EQ 'NOSVC').SVTEST1\n         AIF   ('&SVC' EQ 'SVC').SVTEST1\n&SVC     SETC  'NOSVC'\n.SVTEST1 ANOP\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         YREGS\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         AIF   ('&SVC' EQ 'NOSVC').NOSVC01\n*  Put your own SVC Auth turn on code here.....\n         MACRO\n&AON     AUTHON\n         ST    R1,SAVER1C\n         L     R1,=C'AUTH'\n         SVC   SVNO\n         L     R1,SAVER1C\n         MEND\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  Put your own SVC Auth turn off code here.....\n         MACRO\n&AOFF    AUTHOFF\n         ST    R1,SAVER1C\n         L     R1,=C'NONE'\n         SVC   SVNO\n         L     R1,SAVER1C\n         MEND\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n.NOSVC01 ANOP\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.\n*  ---------------------------------------------------------------  *\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         STM   R15,R1,HEXSAVE\n         LA    R1,&FROM\n         LA    R0,&LEN\n         LA    R15,&TO\n         BAL   R9,HEX\n         LM    R15,R1,HEXSAVE\n         MEND\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* ------------------------------------------------------------------- *\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\nTSUB     CSECT\nTSUB     AMODE 31\nTSUB     RMODE 24\n         USING *,R15                                                  *\n         B     BEGINN               Eyecatcher\nMAXBLANK DC    F'120'        Guess of max number of blanks after table\n         DC    CL5'TSUB '\nVERS#    DC    CL10'Ver 1.40'\n         DC    CL1' '\n         AIF   ('&SVC' EQ 'SVC').NOSVC00\n         DC    C'&SVC'\n.NOSVC00 ANOP\n         AIF   ('&SVC' EQ 'NOSVC').SVC00\n         DC    C'&SVC'\n         DC    C' '\n         DC    C'&SVCX'\n.SVC00   ANOP\n         DC    CL18' - &SYSDATE &SYSTIME '\n         DC    CL39' This Program is in the Public Domain. '\nBEGINN   DS    0D\n         DROP  R15\n         USING TSUB,R12,R11,R10,R6,R7  Set up base registers.\n         STM   R14,R12,12(R13)\n         LR    R12,R15                 Set up base registers.\n         LA    R11,4095(,R12)       Second base.\n         LA    R11,1(,R11)\n         ST    R1,SAVEPARM          Save CPPL pointer to use later.\n*                                   SAVEPARM is in second base area.\n         LA    R10,4095(,R11)       Third base.\n         LA    R10,1(,R10)\n         LA    R6,4095(,R10)        Fourth base.\n         LA    R6,1(,R6)\n         LA    R7,4095(,R6)         Fifth base.\n         LA    R7,1(,R7)\n         LA    R1,SAVEAREA          Point to new save area\n         ST    R1,8(,R13)           Forward save area chain pointer\n         ST    R13,4(,R1)           Backward save area chain pointer\n         LR    R13,R1               New save area address\n         B     INITCON              Branch past save area\n         SPACE 1\n* -----------------------\nSAVEAREA DC    18F'0'               Non-reentrant save area\n* -----------------------\nINITCON  DS    0H                   Initialize constants to be sure.\n         MVI   OFFFLAG,X'00'\n         MVI   PLATFLG,X'00'\n         MVI   MEASFLG,X'00'\n         MVI   LPAFLAG,X'00'\n         MVI   SHBLFLG,X'00'\n         MVI   LPADFLG,X'00'\n         MVI   NSCHFLG,X'00'\n         MVI   HAVLFLG,X'00'\n         MVI   LWAPFLG,X'00'\n         MVI   LWAMFLG,X'00'\n         MVI   TIDFLAG,X'00'\n         MVI   OLDFLAG,X'00'\n         MVI   FLAGZ,X'00'\n         MVI   LINEB,X'40'\n         MVI   LINAB,X'40'\n         XC    FSTCOUNT,FSTCOUNT\n         XC    FSTNOUNT,FSTNOUNT\n         MVC   FSTFIELD(8),BLANKS\n         MVI   BLANKS-1,X'40'\n         MVC   BLANKS,BLANKS-1\n         MVC   CODEPLAC(2),BLANKS\n         MVC   DISPHDR(16),BLANKS\n         XC    SLOTBIN,SLOTBIN\n         XC    BLNKCNT,BLNKCNT\n         XC    NTRYCNT,NTRYCNT\n         XC    SAVETCUR,SAVETCUR\n         MVC   SLOTSAVE,BLANKS\n         MVC   FSTNAME,BLANKS\n         MVI   CMDBCOPY-1,X'00'\n         MVC   CMDBCOPY,CMDBCOPY-1\n* -----------------------\nGETPSCB  DS    0H                  See if we are allowed to\n*                                  run this program.\n         L     R2,16               POINT TO CVT.\n         L     R2,0(,R2)           POINT TO TCB/ASCB WORDS\n         L     R2,4(,R2)           POINT TO TCB.\n         L     R2,X'B4'(,R2)       POINT TO JSCB.\n         L     R2,X'108'(,R2)      POINT TO PSCB.\n         LA    R2,0(,R2)           CLEAR HIGH BYTE.\n         LTR   R2,R2               ANY PSCB?\n         BZ    EOJ4                GET OUT.  NOT TSO.\n         L     R1,SAVEPARM         Get the address of the CPPL back\n         USING CPPL,R1\n         L     R0,CPPLUPT          Copy CPPL fields for possible\n         ST    R0,SAVEUPT            later use, if needed.\n         L     R0,CPPLPSCB\n         ST    R0,SAVEPSCB\n         L     R0,CPPLECT\n         ST    R0,SAVEECT\n         DROP  R1\n         BAL   R9,PGMTITLE         First display the program title.\n         USING PSCB,R2\nCHEKAUTH DS    0H\n         NOP   GETLWA              Zap to bypass authorization check\n         TM    PSCBATR1,PSCBACCT   ACCT user?\n         BO    GETLWA              Yes.  Continue.\n         TM    PSCBATR1,PSCBCTRL   OPER user?\n         BZ    EOJ4                No.  Get out.\n         DROP  R2\n***** ----- >>>>>\nGETLWA   DS    0H                  Obtain all the relevant fields\n*                                  from the LWA (Logon Work Area)\n         L     R2,X'224'           Point to PSAAOLD\n         L     R2,X'6C'(,R2)       Point to ASXB\n         L     R2,X'14'(,R2)       Point to LWA\n         ST    R2,LWAADDR          Store LWA address\n         USING LWA,R2\n* ------------------------------------------------------------------ *\n*    Save all the relevant information from the LWA, to use later.   *\n* ------------------------------------------------------------------ *\n         ST    R5,SAVER5B          Store original contents of R5\n         L     R5,LWATNS           Pointer to NS table\n         ST    R5,SAVETNS          Save it.\n         L     R5,LWATE2           Pointer to E2 table\n         ST    R5,SAVETE2          Save it.\n         L     R5,LWATE8           Pointer to E8 table\n         ST    R5,SAVETE8          Save it.\n         L     R5,LWATAP           Pointer to AP table\n         ST    R5,SAVETAP          Save it.\n         XR    R5,R5               Clear register to be double sure.\n         LH    R5,LWATNSLN         Length of NS table if available\n         STH   R5,SAVETNSL         Save whatever was there in program.\n         LTR   R5,R5               Has a size been supplied in the LWA?\n         BZ    NONSSIZE            No\n         OI    LWAMFLG,X'40'       Yes. Indicate that in a flag.\nNONSSIZE DS    0H\n         LH    R5,LWATE2LN         Length of E2 table if available\n         STH   R5,SAVETE2L         Save whatever was there in program.\n         LTR   R5,R5               Has a size been supplied in the LWA?\n         BZ    NOE2SIZE            No\n         OI    LWAMFLG,X'20'       Yes. Indicate that in a flag.\nNOE2SIZE DS    0H\n         LH    R5,LWATE8LN         Length of E8 table if available\n         STH   R5,SAVETE8L         Save whatever was there in program.\n         LTR   R5,R5               Has a size been supplied in the LWA?\n         BZ    NOE8SIZE            No\n         OI    LWAMFLG,X'10'       Yes. Indicate that in a flag.\nNOE8SIZE DS    0H\n         LH    R5,LWATAPLN         Length of AP table if available\n         STH   R5,SAVETAPL         Save whatever was there in program.\n         LTR   R5,R5               Has a size been supplied in the LWA?\n         BZ    NOAPSIZE            No\n         OI    LWAMFLG,X'80'       Yes. Indicate that in a flag.\nNOAPSIZE DS    0H\n         L     R5,SAVER5B          Restore original R5 contents\n         MVC   LWAPFLG,LWAPRMLB    Save flags showing which tables\n*                                  came from STEPLIB, if any.\n         DROP  R2\n* ------------------------------------------------------------------ *\n*    At this point we have finished saving things out of the LWA.    *\n* ------------------------------------------------------------------ *\n*    Now we have to find the LPA boundaries.                         *\n* ------------------------------------------------------------------ *\nLPAINFO  DS    0H\n         BAL   R9,GETLPABD         Get list of LPA storage boundaries.\n* ------------------------------------------------------------------ *\n***** ----- >>>>>  We can handle the public Platform Command and     *\n***** ----- >>>>>  Platform Program tables, if they exist.           *\n* ------------------------------------------------------------------ *\nGETPCPP  DS    0H            Info about Platpgm and Platcmd Tables\n         L     R2,16               Point to CVT\n         L     R2,X'9C'(,R2)       Point to TSVT (TSO Vector Table)\n         L     R2,X'4C'(,R2)       Point to TPVT\n         ST    R2,SAVETPVT         Save TPVT address for later use\n         L     R2,X'14'(,R2)       Point to CTLT control block\n         ST    R2,SAVECTLT         Save CTLT address for later use\n         L     R2,SAVETPVT         Load TPVT address back\n         L     R2,X'34'(,R2)       Point to PLATCMD pointer\n         LTR   R2,R2               Is there any?\n         BZ    NOFCVE              No. Say so.\n         ST    R2,SAVEFCVE         Yes. Store the FCVE pointer away.\n         OI    PLATFLG,X'01'       Indicate that FCVE exists.\nTRYPPVE  DS    0H\n         L     R2,SAVETPVT         Load TPVT address back\n         L     R2,X'40'(,R2)       Point to PLATPGM pointer\n         LTR   R2,R2               Is there any?\n         BZ    NOPPVE              No. Say so.\n         ST    R2,SAVEPPVE         Yes. Store the PPVE pointer away.\n         OI    PLATFLG,X'02'       Indicate that PPVE exists.\nTRYPPVEE DS    0H\n         B     CHKOLVER            Skip over relevant error messages.\n* -------------------------------------------------------------- *\n* ------           Error messages if tables don't exist   ------ *\n* -------------------------------------------------------------- *\nNOFCVE   DS    0H\n         APUT  =C'No PLATCMD table found',22\n         B     TRYPPVE\nNOPPVE   DS    0H\n         APUT  =C'No PLATPGM table found',22\n         B     TRYPPVEE\n* ----------------------------------------------------------------- *\n*    There doesn't seem to be a way to tell from an old INMXPARM    *\n*    control block itself, that it is the old version.  So we use   *\n*    the position of the active PARMLIB member name in the TPVT.    *\n* ----------------------------------------------------------------- *\nCHKOLVER DS    0H\n         L     R2,SAVETPVT         Load TPVT address back.\n         CLC   =C'IKJ',7(R2)       Parmlib member name in old position?\n         BNE   PARMSCAN            No. It's a new TSO/E version\n         OI    OLDFLAG,X'01'       Yes. Flag that the system is old.\n* -------------------------------------------------------------- *\n*    After we got the system information we finally start        *\n*     scanning the TSO command for parms, here.                  *\n* -------------------------------------------------------------- *\nPARMSCAN DS    0H\n         L     R1,SAVEPARM         Original R1 from entry to program.\n         LTR   R1,R1               Any CPPL?\n         BZ    EOJ8                No. Get out.\n         L     R1,0(,R1)           Point to Command Buffer\n         LTR   R1,R1               Any Command Buffer?\n         BZ    EOJ4                Get out if none.\n         LH    R3,0(,R1)           Load length.\n         CH    R3,=H'4'            Anything?\n         BNH   EOJ4                No.  Get out.\n         LR    R5,R3               Length of command + 4\n         ICM   R5,14,FULLZERO      Clear high order 3 bytes.\n         ST    R1,CMBUFAD          Save Command Buffer Address\n         LH    R3,2(,R1)           Load offset.\n         ST    R3,OFFSETSV         Save offset value.\n         SR    R5,R3               Subtract offset from full length+4\n         SH    R5,=H'4'            Correct for length of CMDBUFR header\n*                                  in the command buffer.\n         BC    8,EOJC              Zero, Message\n         BC    5,EOJC              Less, or overflow, out.\n         ST    R5,CMBUFEND         Store away the number of bytes left\n         L     R1,CMBUFAD          Load Command Buffer Address\n*\n* ----  Copy command buffer into pgm's buffer so we can control it.\n*\n         STM   R14,R1,SAVE1401     Now save registers 14 thru 1.\n         XR    R14,R14             Clear R14.\n         LH    R14,0(,R1)          Load full command buffer length.\n         S     R14,=F'5'           Subtract 4 for header, 1 for execute\n         ICM   R14,14,FULLZERO     Ensure cmd buffer smaller than 255\n         EX    R14,COPYCMDB        Copy command into pgm's area.\n         LM    R14,R1,SAVE1401     Restore registers 14 thru 1.\n         B     GOGOGO              Jump over executed instruction.\nCOPYCMDB MVC   CMDBCOPY(0),4(R1)   <<< Executed >>>\nGOGOGO   DS    0H\n* ----\n         LA    R2,3                Load register for BCT loop.\n* >>>\n         LA    R1,CMDBCOPY         Point to command in our buffer\n         A     R1,OFFSETSV         Add offset, point to subcommands\n         ST    R1,CHARSTRT         Store starting point away\n* >>>\n         LR    R4,R1               Initialize pointer\n         LA    R4,0(,R4)           to first character of function name.\n         LA    R8,0                Initialize character count\nCUTIDLEN CLI   0(R4),X'40'         Is this character a blank?\n         BE    AFTFIRST            Yes, end of the first parm.\n         CLI   0(R4),X'00'         Is this character hex zero?\n         BE    AFTFIRST            Yes, end of command in buffer copy.\n         LA    R4,1(,R4)           Bump another character\n         LA    R8,1(,R8)           Count another character\n         CR    R8,R5               End of command buffer ?\n         BNL   AFTFIRST            Yes. Get out now.\n         BCT   R2,CUTIDLEN         Try for blank again.\nAFTFIRST DS    0H\n         MVC   TABCODE(8),BLANKS   Clear field\n         BCTR  R8,0                Subtract 1 for execute.\n         L     R1,CHARSTRT         Reload R1 to be sure it's correct.\n         EX    R8,MOVOUTL          Move entered parameter to program.\n         LA    R8,1(,R8)           Restore number of characters\n         AR    R1,R8               Point past last search\n         ST    R1,CHARCONT         Continue from here\n         ST    R8,SAVER8A          Save register\n* ---- >\nSEEIFPRM DS    0H                  Check if a command is here\n         OC    TABCODE(3),BLANKS   Uppercase. Won't affect numbers.\n         CLI   TABCODE+2,C'X'      Special action code, code X.\n         BNE   SEEIFJ01            Not this. Just go on.\n         OI    LPADFLG,X'01'       Set flag to display LPA range.\nSEEIFJ01 DS    0H\n*--*\n         TM    LPADFLG,X'01'       Display LPA range only?\n         BZ    SEEIFK01            No. Do all regular processing.\n         BAL   R9,GETLPRNT         Yes. Display LPA range and exit.\n         B     EOJ0                Out of program with Code 0\nSEEIFK01 DS    0H\n*--*\n         CLI   TABCODE+2,C'R'      Replace the entry in the given slot\n         BE    SEEIF0A1\n         CLI   TABCODE+2,C'B'      Blank the given slot\n         BE    SEEIF0A2\n         CLI   TABCODE+2,C'D'      Display contents of given slot\n         BE    SEEIF0A3              or all slots.\n         CLI   TABCODE+2,C'H'      Alter table header\n         BE    SEEIF0A4\n         CLI   TABCODE+2,C'L'      Supply length for table in LWA\n         BE    SEEIF0A5              including trailing blank entries.\n         CLI   TABCODE+2,C'M'      Supply length for table in LWA plus\n         BE    SEEIF0M5              one trailing blank, if there.\n         CLI   TABCODE+2,C'Z'      Zero length for table in LWA\n         BE    SEEIF0A6\n         CLI   TABCODE+2,C'S'      Say this table came from STEPLIB\n         BE    SEEIF0A7\n         CLI   TABCODE+2,C'P'      Say this table is not from STEPLIB\n         BE    SEEIF0A8\n         CLI   TABCODE+2,C'N'      Are we nullifying an entry?\n         BE    SEEIF0A9\n         B     SEEIF000\nSEEIF0A1 DS    0H\n         OI    OFFFLAG,X'01'       Replace an entry\n         B     SEEIF001\nSEEIF0A2 DS    0H\n         OI    OFFFLAG,X'02'       Blank entry in the last slot\n         B     SEEIF001\nSEEIF0A3 DS    0H\n         OI    OFFFLAG,X'04'       Display an entry or entries\n         B     SEEIF001\nSEEIF0A4 DS    0H\n         OI    OFFFLAG,X'08'       Alter table header\n         B     SEEIF001\nSEEIF0M5 DS    0H                  Short length with one blank\n         OI    SHBLFLG,X'01'\nSEEIF0A5 DS    0H\n         OI    OFFFLAG,X'10'       Supply length for table in LWA\n         B     SEEIF001\nSEEIF0A6 DS    0H\n         OI    OFFFLAG,X'20'       Zero length for table in LWA\n         B     SEEIF001\nSEEIF0A7 DS    0H\n         OI    OFFFLAG,X'40'       Say this table came from STEPLIB\n         B     SEEIF001\nSEEIF0A8 DS    0H\n         OI    OFFFLAG,X'80'       Say this table not from STEPLIB\n         B     SEEIF001\nSEEIF0A9 DS    0H\n         OI    OFFFLAG1,X'10'      Use OFFFLAF1\n         MVI   OFFFLAG,X'00'         instead of OFFFLAG.\n         B     SEEIF001\nSEEIF000 DS    0H                  Wrong function code was entered...\n* --- >                            Display what we entered, plus code\n         MVC   LINE,LINEB          Clear line\n         MVC   LINE(3),TABCODE     Move code in\n         HEX   LINE+6,1,OFFFLAG    Display contents of flag\n         HEX   LINE+8,1,OFFFLAG1\n         MVC   LINE+15(37),=C'Program table code + Function code '\n         APUT  LINE,50\n* --- >\n         BAL   R9,ERRORCOD         Indicate error and display syntax.\n         B     EOJ4                Get out with code = 4.\nSEEIF001 DS    0H                  Which table to change\n         MVC   CODEPLAC(2),TABCODE    Save table code.\n* --- >\n         TM    OFFFLAG,X'04'       Display only--no changes to be made\n         BO    NOBEFORE            Don't show \"before changes\" message\n         STM   R14,R1,SAVE1401     Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGED,L'MESSAGED Say \"after making changes\"\n         LM    R14,R1,SAVE1401     Restore registers 14 thru 1.\nNOBEFORE DS    0H\n* --- >                            Display what we entered, plus code\n         MVC   LINE,LINEB          Clear line\n         MVC   LINE(3),TABCODE     Move code in\n         HEX   LINE+6,1,OFFFLAG    Display contents of flag\n         HEX   LINE+8,1,OFFFLAG1\n         MVC   LINE+15(37),=C'Program table code + Function code '\n         APUT  LINE,50\n* --- >                            Handle each table separately.\n         CLC   TABCODE(2),=C'E2'   Change IKJEFTE2?\n         BE    E2CHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'E8'   Change IKJEFTE8?\n         BE    E8CHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'AP'   Change IKJEFTAP?\n         BE    APCHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'PC'   Change PLATCMD?\n         BE    PCCHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'PP'   Change PLATPGM?\n         BE    PPCHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'NS'   Change IKJEFTNS?\n         BE    NSCHANGE            Yes. Branch.\n         BAL   R9,ERRORCOD         Indicate error and display syntax.\n         B     EOJ4                Invalid code entered.\nEOJ      DS    0H                  END OF JOB\n         L     R13,4(,R13)\n         LR    R15,R5              Put in real return code\n         ST    R15,16(,R13)        Shove it where it belongs\n         L     R14,12(,R13)        R14 and\n         LM    R0,R12,20(R13)        rest of registers\n         BR    R14                 Go back to caller\nEOJ0     DS    0H                  Return code 0\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGR0       Show Return Code 0\n         APUT  MESSAGR0,L'MESSAGR0\n         LA    R5,0                Set CC = 0\n         B     EOJ                 Now end the program\nEOJ4     DS    0H                  Return code 4\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGR4       Show Return Code 4\n         APUT  LINE,L'MESSAGR4\n         L     R5,FULLFOUR         Set CC = 4\n         B     EOJ                 Now end the program\nEOJ8     DS    0H                  Return code 8\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGR8       Show Return Code 8\n         APUT  LINE,L'MESSAGR8\n         L     R5,FULLEIGT         Set CC = 8\n         B     EOJ                 Now end the program\nEOJC     DS    0H                  Return code 12\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGRC       Show Return Code 12\n         APUT  LINE,L'MESSAGRC\n         L     R5,FULLTWLV         Set CC = 12\n         B     EOJ                 Now end the program\n** ---------------------------------------------------------------- **\n**                                                                  **\n**   Different Table Handling Routines                              **\n**   --------- ----- -------- --------                              **\n**                                                                  **\n**  At this point, we have the routines which handle each of the    **\n**  separate types of tables.  E2, E8, AP, and NS, for which the    **\n**  live LWA version is handled.  But we also do the FCVE and       **\n**  PPVE (Platform Command and Platform Program) tables pointed     **\n**  to by the TPVT (TSO Parmlib Vector Table) control block, and    **\n**  those two tables, if they exist, are similarly handled.  But    **\n**  the FCVE and PPVE tables (table codes PC and PP respectively,   **\n**  in this program) are in common storage, and are not in the      **\n**  TSO user's address space.                                       **\n**                                                                  **\n** ---------------------------------------------------------------- **\nE2CHANGE DS    0H                 Handle the E2 table\n         OI    TIDFLAG,X'20'      Show we're doing the E2 table.\n         MVC   TABLEID,=C'E2'     Identify which table\n         BAL   R9,ADJNEXTP        Get to first blank\n         BAL   R9,NAMEPARM        Get rest of parms from the command\n         L     R4,SAVETE2         Point to saved E2 table address\n         ST    R4,TABLSTRT        Store start address of table\n         ST    R4,TABLADDR        Keep start address of table\n*\n         BAL   R9,TESTLPA         Check if table address is in LPA\n         BAL   R9,CHANGEDL        LPA message (conditional)\n         BAL   R9,MEASUR08        Measure the table\n*\n         L     R1,TABLSTRT        Load it back into work register\n**-->>\nE2CHENTY DS    0H                 Show we have a size for E2 table\n         TM    LPAFLAG,X'01'      Is this table in LPA?\n         BO    E2CHYSST           Yes. Don't message the properties.\n         TM    LWAMFLG,X'20'      Do we have a size for the E2 table?\n         BZ    E2CHNOSZ           No.\n         OI    FLAGZ,X'04'        Yes. Flag that we have a size.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1A+6(2),CODEPLAC    Move in table code.\n         HEX   MESSAG1A+57,2,SAVETE2L    Move in length amount\n         MVI   MESSAG1A+61,C'.'          Put period at end.\n         APUT  MESSAG1A,L'MESSAG1A\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     E2CHYSSZ\nE2CHNOSZ DS    0H                 Show message that we have no size\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1B+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1B,L'MESSAG1B\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nE2CHYSSZ DS    0H\n         TM    LWAPFLG,X'20'      Was the E2 table loaded from STEPLIB?\n         BZ    E2CHNOST           No. Say that it wasn't.\n         STM   R14,R1,SAVE1401    Yes. Put out message saying it was.\n         MVC   MESSAG1C+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1C,L'MESSAG1C\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     E2CHYSST\nE2CHNOST DS    0H                 Message. Table not from STEPLIB.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1D+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1D,L'MESSAG1D\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nE2CHYSST DS    0H\n*-*                               Print out table header\n         BAL   R9,PRTABLHD        Table Header Display Routine\n*-*\n         LA    R1,X'10'(,R1)      Bump past header\n         ST    R1,TABLSTRT        Store new start address\n* - -\n         LH    R2,SAVETE2L        Load LWA Table Length\n         LTR   R2,R2              Is it there?\n         BNZ   E2CHHAVB           There is a length, so we use it.\n* - -                             None there, have to guess.\n***\n         LH    R3,ME08LENG        Measured table length.\n***\n         B     E2CHNOHB           And go on.\nE2CHHAVB DS    0H                 We have a table length given.\n         MVC   SAVETCUR,SAVETE2L  This is the length we use for now.\n         LR    R3,R2              Dump the number into R3.\nE2CHNOHB DS    0H\n         L     R4,TABLADDR        Load start address of table\n         AR    R4,R3              Point past the guessed end of table.\n         S     R4,=F'16'          Compensate for 16 byte head start.\n         ST    R4,TABLEND         Store away guessed table end.\n* - -\n         LR    R5,R3              Dump best length into register.\n         SRL   R5,3               Divide by 8.\n         BCTR  R5,0               Actually two fewer entries, because\n         BCTR  R5,0                of the header.\n         ST    R5,TABLENUM        Store the number of entries.\n***\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n***\n* - >\n         LA    R5,8               Size of each E2 table entry\n         ST    R5,TABLESIZ        Store size of each entry\n*                                 We'll stop the search at first blank\n         SR    R4,R5              Point past end of table - guessed.\n         ST    R4,SAVLSLOT        Store this location\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    E2CHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message that nothing changed.\n         B     EOJ0\nE2CHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\n** ---------------------------------------------------------------- **\nE8CHANGE DS    0H                 Handle the E8 table\n         OI    TIDFLAG,X'10'      Show we're doing the E8 table.\n         MVC   TABLEID,=C'E8'     Identify which table\n         BAL   R9,ADJNEXTP        Get to first blank\n         BAL   R9,NAMEPARM        Get rest of parms from the command\n         L     R4,SAVETE8         Point to saved E8 table address\n         ST    R4,TABLSTRT        Store start address of table\n         ST    R4,TABLADDR        Keep start address of table\n*\n         BAL   R9,TESTLPA         Check if table address is in LPA\n         BAL   R9,CHANGEDL        LPA message (conditional)\n         BAL   R9,MEASUR08        Measure the table\n*\n         L     R1,TABLSTRT        Load it back into work register\n**-->>\nE8CHENTY DS    0H                 Deal with the E8 table.             .\n         TM    LPAFLAG,X'01'      Is this table in LPA?\n         BO    E8CHYSST           Yes. Don't message the properties.\n         TM    LWAMFLG,X'10'      Do we have a size for the E8 table?\n         BZ    E8CHNOSZ           No.\n         OI    FLAGZ,X'04'        Yes. Flag that we have a size.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1A+6(2),CODEPLAC    Move in table code.\n         HEX   MESSAG1A+57,2,SAVETE8L    Move in length amount\n         MVI   MESSAG1A+61,C'.'          Put period at end.\n         APUT  MESSAG1A,L'MESSAG1A\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     E8CHYSSZ\nE8CHNOSZ DS    0H\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1B+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1B,L'MESSAG1B\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nE8CHYSSZ DS    0H\n         TM    LWAPFLG,X'10'      Was the E8 table loaded from STEPLIB?\n         BZ    E8CHNOST           No. Say that it wasn't.\n         STM   R14,R1,SAVE1401    Yes. Put out message saying it was.\n         MVC   MESSAG1C+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1C,L'MESSAG1C\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     E8CHYSST\nE8CHNOST DS    0H                 Message. Table not from STEPLIB.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1D+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1D,L'MESSAG1D\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nE8CHYSST DS    0H\n*-*                               Print out table header\n         BAL   R9,PRTABLHD        Table Header Display Routine\n*-*\n         LA    R1,X'10'(,R1)      Bump past header\n         ST    R1,TABLSTRT        Store new start address\n* - -\n         LH    R2,SAVETE8L        Load LWA Table Length\n         LTR   R2,R2              Is it there?\n         BNZ   E8CHHAVB           There is a length, so we use it.\n* - -                             None there, have to guess.\n***\n         LH    R3,ME08LENG        Measured table length.\n***\n         B     E8CHNOHB           And go on.\nE8CHHAVB DS    0H                 We have a table length given.\n         MVC   SAVETCUR,SAVETE8L  This is the length we use for now.\n         LR    R3,R2              Dump the number into R3.\nE8CHNOHB DS    0H\n         L     R4,TABLADDR        Load start address of table\n         AR    R4,R3              Point past the guessed end of table.\n         S     R4,=F'16'          Compensate for 16 byte head start.\n         ST    R4,TABLEND         Store away guessed table end.\n* - -\n         LR    R5,R3              Dump best length into register.\n         SRL   R5,3               Divide by 8.\n         BCTR  R5,0               Actually two fewer entries, because\n         BCTR  R5,0                of the header.\n         ST    R5,TABLENUM        Store the number of entries.\n***\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n***\n* - -\n         LA    R5,8               Size of each E8 table entry\n         ST    R5,TABLESIZ        Store size of each entry\n* - -                             We'll stop the search at first blank\n         SR    R4,R5              Point past end of table - guessed.\n         ST    R4,SAVLSLOT        Store this location\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    E8CHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message that nothing changed.\n         B     EOJ0\nE8CHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\n** ---------------------------------------------------------------- **\nAPCHANGE DS    0H                 Handle the AP table\n         OI    TIDFLAG,X'80'      Show we're doing the AP table.\n         MVC   TABLEID,=C'AP'     Identify which table\n         BAL   R9,ADJNEXTP        Get to first blank\n         BAL   R9,NAMEPARM        Get rest of parms from the command\n* - -\n         L     R4,SAVETAP         Get address of AP table\n         ST    R4,TABLSTRT        Store start address of table\n         ST    R4,TABLADDR        Keep start address of table\n*\n         BAL   R9,TESTLPA         Check if table address is in LPA\n         BAL   R9,CHANGEDL        LPA message (conditional)\n         BAL   R9,MEASUR08        Measure the table\n*\n         L     R1,TABLSTRT        Load it back into work register\n**-->>\nAPCHENTY DS    0H                 Table was made from a IKJTSOxx entry.\n         TM    LPAFLAG,X'01'      Is this table in LPA?\n         BO    APCHYSST           Yes. Don't message the properties.\n         TM    LWAMFLG,X'80'      Do we have a size for the AP table?\n         BZ    APCHNOSZ           No.\n         OI    FLAGZ,X'04'        Yes. Flag that we have a size.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1A+6(2),CODEPLAC    Move in table code.\n         HEX   MESSAG1A+57,2,SAVETAPL    Move in length amount\n         MVI   MESSAG1A+61,C'.'          Put period at end.\n         APUT  MESSAG1A,L'MESSAG1A\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     APCHYSSZ\nAPCHNOSZ DS    0H\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1B+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1B,L'MESSAG1B\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nAPCHYSSZ DS    0H\n         TM    LWAPFLG,X'80'      Was the AP table loaded from STEPLIB?\n         BZ    APCHNOST           No. Say that it wasn't.\n         STM   R14,R1,SAVE1401    Yes. Put out message saying it was.\n         MVC   MESSAG1C+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1C,L'MESSAG1C\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     APCHYSST\nAPCHNOST DS    0H                 Message. Table not from STEPLIB.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1D+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1D,L'MESSAG1D\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nAPCHYSST DS    0H\n*-*                               Print out table header\n         BAL   R9,PRTABLHD        Table Header Display Routine\n*-*\n         LA    R1,X'10'(,R1)      Bump past header\n         ST    R1,TABLSTRT        Store new start address\n* - -\n         LH    R2,SAVETAPL        Load LWA Table Length\n         LTR   R2,R2              Is it there?\n         BNZ   APCHHAVB           There is a length, so we use it.\n* - -                             None there, have to guess.\n***\n         LH    R3,ME08LENG        Measured table length.\n***\n         B     APCHNOHB           And go on.\nAPCHHAVB DS    0H                 We have a table length given.\n         MVC   SAVETCUR,SAVETAPL  This is the length we use for now.\n         LR    R3,R2              Dump the number into R3.\nAPCHNOHB DS    0H\n         L     R4,TABLADDR        Load start address of table\n         AR    R4,R3              Point past the guessed end of table.\n         S     R4,=F'16'          Compensate for 16 byte head start.\n         ST    R4,TABLEND         Store away guessed table end.\n* - -\n         LR    R5,R3              Dump best length into register.\n         SRL   R5,3               Divide by 8.\n         BCTR  R5,0               Actually two fewer entries, because\n         BCTR  R5,0                of the header.\n         ST    R5,TABLENUM        Store the number of entries.\n***\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n***\n* - -\n         LA    R5,8               Size of each AP table entry\n         ST    R5,TABLESIZ        Store size of each entry\n* - -                             We'll stop the search at first blank\n         SR    R4,R5              Point past end of table - guessed.\n         ST    R4,SAVLSLOT        Save this location.\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    APCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message that nothing changed.\n         B     EOJ0\nAPCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\n** ---------------------------------------------------------------- **\nPCCHANGE DS    0H                 Handle the PC table\n         OI    TIDFLAG,X'01'      Show PC table chosen.\n         MVC   TABLEID,=C'PC'\n         TM    PLATFLG,X'01'      Does the table exist?\n         BZ    PCCHAERR           No. Report error.\n         BAL   R9,ADJNEXTP        Get to first blank\n         BAL   R9,NAMEPARM        Get rest of parms from the command\n         L     R2,SAVEFCVE        Get the PC table address\n         LR    R4,R2              Save it off\n         ST    R4,DISPREG         Store register contents for display\n* -- >                            Do Display\n*-*-*->>                          Print the address out so we can see.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1        Clear line area.\n         MVC   LINE(16),=C'Table address:  '\n         HEX   LINE+21,4,DISPREG      Display address in Hex\n         APUT  LINE,35\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n*-*-*->>\n* -- >\n         L     R3,X'8'(,R4)       Point to length of table\n         STH   R3,SAVETCUR        Store it to show non-zero\n         AR    R4,R3              Point just past PC table\n         ST    R4,TABLEND         And mark the projected end of table\n* - -\n         L     R3,X'C'(,R2)       Get number of table entries\n         ST    R3,TABLENUM        Preserve number for table search\n         LA    R3,8               Load table size\n         ST    R3,TABLESIZ        And store it for DISPTABL routine\n** -- **\n***\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         MVC   LINE(22),=C'Table length in Hex:  '\n         HEX   LINE+25,2,SAVETCUR\n         APUT  LINE,45\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n***\n** -- **\n         L     R3,SAVEFCVE        Get the platcmd table start address\n         LA    R3,X'10'(,R3)      Bump past its header\n         ST    R3,TABLSTRT        And store the starting place away\n* - -\n         LA    R5,8               Get 8 bytes ready for subtraction\n         SR    R4,R5              Back up to the last slot\n         ST    R4,SAVLSLOT        Save location of last table slot\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    PCCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message\n         B     EOJ0\nPCCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\nPCCHAERR DS    0H                 Say no PC table exists.\n         MVC   LINE,LINE-1\n         MVC   LINE(43),=C'PC command not valid if no PC table exists.'\n         APUT  LINE,43\n         B     EOJ4\nPCCHAEND DS    0H\n         B     EOJ0\n** ---------------------------------------------------------------- **\nPPCHANGE DS    0H                 Handle the PP table\n         OI    TIDFLAG,X'02'      Show PP table chosen.\n         MVC   TABLEID,=C'PP'\n         TM    PLATFLG,X'02'      Is there a Platpgm table?\n         BZ    PPCHAERR           If no, then display error condition\n         BAL   R9,ADJNEXTP        Get to first blank\n         BAL   R9,NAMEPARM        Get rest of parms from the command\n         L     R2,SAVEPPVE        Get the PP table address\n         LR    R4,R2              Save it off\n         ST    R4,DISPREG         Store PP table address for display\n* -- >                            Do Display\n*-*-*->>                          Print the address out so we can see.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1        Clear line area.\n         MVC   LINE(16),=C'Table address:  '\n         HEX   LINE+21,4,DISPREG      Display address in Hex\n         APUT  LINE,35\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n*-*-*->>\n* -- >\n         L     R3,X'8'(,R4)       Size of PP table in bytes\n         STH   R3,SAVETCUR        Show it's non-zero\n         AR    R4,R3              Point just past the PP table\n         ST    R4,TABLEND         Mark the end of table for DISPTABL\n* - -\n         L     R3,X'C'(,R2)       Get number of table entries\n         ST    R3,TABLENUM        Store that number away for DISPTABL\n         LA    R3,8               Size of each entry\n         ST    R3,TABLESIZ        Store that away too\n** -- **\n***\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         MVC   LINE(22),=C'Table length in Hex:  '\n         HEX   LINE+25,2,SAVETCUR\n         APUT  LINE,45\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n***\n** -- **\n         L     R3,SAVEPPVE        Get start address of PP table\n         LA    R3,X'10'(,R3)      Add 16 to bump past header\n         ST    R3,TABLSTRT        Store search starting address away\n* - -\n         LA    R5,8               Load size of one entry\n         SR    R4,R5              Back up to last slot address\n         ST    R4,SAVLSLOT        And save it off.\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    PPCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message\n         B     EOJ0\nPPCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\nPPCHAERR DS    0H                 Say no PC table exists.\n         MVC   LINE,LINE-1\n         MVC   LINE(43),=C'PP command not valid if no PP table exists.'\n         APUT  LINE,43\n         B     EOJ4\nPPCHAEND DS    0H\n         B     EOJ0\n** ---------------------------------------------------------------- **\nNSCHANGE DS    0H                 Handle the NS table\n         OI    TIDFLAG,X'40'      Show we're doing the NS table.\n         MVC   TABLEID,=C'NS'     Identify which table\n         BAL   R9,ADJNEXTP        Get to first blank\n         BAL   R9,NAMEPARM        Get rest of parms from the command\n         OI    NSCHFLG,X'01'      Show SETTMODE we're doing NS\n* - -\n         L     R4,SAVETNS         Saved location of the NS table\n         ST    R4,TABLSTRT        Store start address of table\n         ST    R4,TABLADDR        Keep start address of table\n*\n         BAL   R9,TESTLPA         Check if table address is in LPA\n         BAL   R9,CHANGEDL        LPA message (conditional)\n         BAL   R9,MEASUR10        Measure the table\n*\n         L     R1,TABLSTRT        Load it to start table search later\n**-->>\nNSCHENTY DS    0H                 Table was made from a IKJTSOxx entry.\n         TM    LPAFLAG,X'01'      Is this table in LPA?\n         BO    NSCHYSST           Yes. Don't message the properties.\n         TM    LWAMFLG,X'40'      Do we have a size for the NS table?\n         BZ    NSCHNOSZ           No.\n         OI    FLAGZ,X'04'        Yes. Flag that we have a size.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1A+6(2),CODEPLAC    Move in table code.\n         HEX   MESSAG1A+57,2,SAVETNSL    Move in length amount\n         MVI   MESSAG1A+61,C'.'          Put period at end.\n         APUT  MESSAG1A,L'MESSAG1A\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     NSCHYSSZ\nNSCHNOSZ DS    0H                 Say we have no size for the NS table\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1B+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1B,L'MESSAG1B\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nNSCHYSSZ DS    0H\n         TM    LWAPFLG,X'40'      Was the NS table loaded from STEPLIB?\n         BZ    NSCHNOST           No. Say that it wasn't.\n         STM   R14,R1,SAVE1401    Yes. Put out message saying it was.\n         MVC   MESSAG1C+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1C,L'MESSAG1C\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     NSCHYSST           Don't put out contradictory messages\nNSCHNOST DS    0H                 Message. Table not from STEPLIB.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1D+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1D,L'MESSAG1D\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nNSCHYSST DS    0H\n*-*                               Print out table header\n         BAL   R9,PRTABLHD        Table Header Display Routine\n*-*\n         LA    R1,X'10'(,R1)      Bump past the table header\n         ST    R1,TABLSTRT        Store new start address for DISPTABL\n* - -\n         LH    R2,SAVETNSL        Load LWA Table Length\n         LTR   R2,R2              Is it there?\n         BNZ   NSCHHAVB           There is a length, so we use it.\n* - -                             None there, have to guess.\n***\n         LH    R3,ME10LENG        Measured table length.\n***\n         B     NSCHNOHB           And go on.\nNSCHHAVB DS    0H                 We have a table length given.\n         MVC   SAVETCUR,SAVETNSL  This is the length we use for now.\n         LR    R3,R2              Dump the number into R3.\nNSCHNOHB DS    0H\n         L     R4,TABLADDR        Load start address of table\n         AR    R4,R3              Point past the guessed end of table.\n*        S     R4,=F'16'          Compensate for 16 byte head start.\n         ST    R4,TABLEND         Store away guessed table end.\n* - -\n         LR    R5,R3              Dump best length into register.\n         S     R5,=F'16'\n         STM   R2,R3,SAVER23      Save work registers.\n         XR    R2,R2              Zero work registers.\n         XR    R3,R3\n         LR    R3,R5              Feed length into work register\n         D     R2,=F'10'          Divide by 10.\n         LR    R5,R3              Save the result.\n         LM    R2,R3,SAVER23      Restore work registers.\n         ST    R5,TABLENUM        Store the number of entries.\n***\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n***\n* - -\n         XR    R5,R5              Clear register\n         LA    R5,10              Size of each NS table entry\n         ST    R5,TABLESIZ        Store size of each table entry\n* - -                             We'll stop the search at first blank\n         SR    R4,R5              Point to Last Slot\n         ST    R4,SAVLSLOT        Save location of last slot\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    NSCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message that nothing changed.\n         B     EOJ0\nNSCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\n** ---------------------------------------------------------------- **\n* ----------------------------------------------------------------- *\n*     Various \"abnormal ending\" routines.                           *\n* ----------------------------------------------------------------- *\nNOTAUTH  DS    0H                     Command not authorized message.\n         APUT  MESSAG2C,L'MESSAG2C\n         APUT  MESSAG2D,L'MESSAG2D\n         B     EOJC\n* ----------------------------------------------------------------- *\nNOE2     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'E2'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\n* ----------------------------------------------------------------- *\nNOE8     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'E8'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\n* ----------------------------------------------------------------- *\nNOAP     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'AP'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\n* ----------------------------------------------------------------- *\nNONS     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'NS'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\n* ----------------------------------------------------------------- *\nNOTNUMER DS    0H                 Message that a parm was not numeric\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEN),MESSAGEN\n         MVC   LINE+21(1),0(R4)\n         APUT  LINE,L'MESSAGEN\n         B     EOJ4\n** ---------------------------------------------------------------- **\n**    Some of the Register and Pointer Save Areas                   **\n** ---------------------------------------------------------------- **\nSAVEPARM DC    F'0'                   Parm address from R1 at entry\nSAVETPVT DC    F'0'                   Address of TPVT control block\nSAVECTLT DC    F'0'                   Address of CTLT control block\nSAVEFCVE DC    F'0'                   Address of Platcmd table if non-0\nSAVEPPVE DC    F'0'                   Address of Platpgm table if non-0\nSAVEUPT  DC    F'0'                   Address of UPT\nSAVEECT  DC    F'0'                   Address of ECT\nSAVEPSCB DC    F'0'                   Address of PSCB\nSAVETNS  DC    F'0'                   Address of NS table\nSAVETE2  DC    F'0'                   Address of E2 table\nSAVETE8  DC    F'0'                   Address of E8 table\nSAVETAP  DC    F'0'                   Address of AP table\nSAVETNSL DC    H'0'                   Length of NS table, if nonzero\nSAVETE2L DC    H'0'                   Length of E2 table, if nonzero\nSAVETE8L DC    H'0'                   Length of E8 table, if nonzero\nSAVETAPL DC    H'0'                   Length of AP table, if nonzero\nSAVETCUR DC    H'0'                   Copied length of current table\nSAVETNEW DC    H'0'                   Changed length of current table\n** ---------------------------------------------------------------- **\nFULLZERO DC    F'0'                   Fullword of numeric 0\nFULLFOUR DC    F'4'                   Fullword 4\nFULLEIGT DC    F'8'                   Fullowrd 8\nFULLTWLV DC    F'12'                  Fullword 12\nSAVE1401 DC    5F'0'                  More for safety\nLWAADDR  DC    F'0'                   Address of LWA control block\n* - - - - - - - - - - - - - - - - - - - - - - - - *\nMOVOUTL  MVC   TABCODE(*-*),0(R1)     EXECUTED\nMOVFSTN  MVC   FSTNAME(*-*),0(R3)     EXECUTED\nMOVSNDN  MVC   SNDNAME(*-*),0(R1)     EXECUTED\nMOVFNUM  MVC   FSTNUME(*-*),0(R3)     EXECUTED\nPACK     PACK  WORKA,0(0,3)          <<< EXECUTED >>>\n** ---------------------------------------------------------------- **\n*          * - - - - - - - - - - - - - - - - - - - - - - - - *\n*          *            S U B R O U T I N E S                *\n*          * - - - - - - - - - - - - - - - - - - - - - - - - *\n** ---------------------------------------------------------------- **\n**  These are executed using a BAL R9,subroutn  instruction.        **\n** ---------------------------------------------------------------- **\nHEX      DS    0H\n         ST    R9,SAVER9A\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         L     R9,SAVER9A\n         BR    R9                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\nHEXSAVE  DS    3F                    Register save for HEX macro\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETNAMES DS    0H                  Get program name from parm.\n         ST    R9,SAVER9B          Save BAL register\n         ST    R2,SAVER2D          Save work register\nGETNAMST DS    0H                  Get rid of leading blanks\n         L     R1,CHARCONT         Point to start of character\n         CLI   0(R1),X'40'         Is it a blank?\n         BNE   GETNAMNZ            No. Get the entire name.\n         LA    R1,1(,R1)           Yes. Bump start place one up.\n         ST    R1,CHARCONT         And store the place away for now.\n         C     R5,=F'1'            End of cmd buffer one away?\n         BNH   EOJ4                Yes. Error.\n         BCTR  R5,0                Subtract one from end count\n         B     GETNAMST            And loop to find first non-blank.\nGETNAMNZ DS    0H                  Got first non-blank. Get whole name.\n         LA    R2,8                BCT initial quantity - 8 chars.\n         LA    R8,0                Character count\n         L     R1,CHARCONT         Load starting place\n         LR    R4,R1               Initialize pointer\n         LA    R4,0(,R4)           to first character of program name.\nGETNAMLU DS    0H                  Loop to get entire name\n         CLI   0(R4),X'40'         First blank?\n         BE    GETNAMGT            Yes, got whole name.\n         CLI   0(R4),X'00'         First hex zeros?\n         BE    GETNAMGT            Yes, got whole name.\n         CR    R8,R5               End of command buffer?\n         BNL   GETNAMGT            Yes. Got all we can get.\n         LA    R8,1(,R8)           Bump character counter.\n         LA    R4,1(,R4)           Bump where we are.\n         BCT   R2,GETNAMLU         Loop back.\nGETNAMGT DS    0H\n         ST    R8,SAVER8A          Save character count\n         ST    R8,FSTCOUNT         Again.\n         CLC   SAVER8A,=F'0'       Is character count (left) 0?\n         BNE   GETREALY            No. Go on processing for name.\n         BAL   R9,MISSPGM2         Say we're missing a program name.\n         B     EOJ4                And get out with code = 4.\nGETREALY DS    0H\n         MVC   FSTCHALF(2),FSTCOUNT+2    Get halfword program length\n         MVC   LINE,LINE-1               Print it in message\n         HEX   LINE,4,SAVER8A\n         MVC   LINE+13(17),=C'Length of command'\n         APUT  LINE,30\n         L     R3,CHARCONT         Load starting place again.\n         BCTR  R8,0                One less for EXECUTE.\n         MVC   FSTNAME(8),BLANKS   Blank entire target field.\n         EX    R8,MOVFSTN          Move program name to target.\n         OC    FSTNAME(8),BLANKS   Uppercase the program name.\n         MVC   LINE,LINE-1         And print its name out.\n         MVC   LINE(8),FSTNAME\n         MVC   LINE+13(17),=C'New program name '\n         APUT  LINE,30\n* - >\nGETNAMEN DS    0H                  Exit this routine.\n         L     R2,SAVER2D          Restore work register\n         L     R9,SAVER9B          Restore BAL register\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nCHANGED  DS    0H                     The \"value was changed\" message.\n         ST    R9,SAVER9C\n         TM    LPAFLAG,X'01'          Is the table within LPA?\n         BO    CHANGEND               Yes. Change already shown.\n         TM    FLAGZ,X'02'            Is parm number past end of table?\n         BO    CHANGEDN               Yes. Bypass all operations here.\n         TM    OFFFLAG,X'01'          Replacement?\n         BO    CHANGEDA               Say what was replaced\n         TM    OFFFLAG,X'02'          Blanking?\n         BO    CHANGEDB               Say what was blanked\n         TM    OFFFLAG,X'04'          Display?\n         BO    CHANGEDD               Skip saying anything was changed.\n         TM    OFFFLAG,X'08'          Change header to \" PARMLIB\"?\n         BO    CHANGEDH               Write message that its done.\n         TM    OFFFLAG,X'10'          Supply lengths in LWA?\n         BO    CHANGEDK               Write appropriate messages.\n         TM    OFFFLAG,X'20'          Zero lengths in LWA?\n         BO    CHANGEDZ               Write appropriate messages.\n         TM    OFFFLAG1,X'10'         Nullifying a table entry?\n         BO    CHANGENU               Write appropriate messages.\n*                                     X'40' dealt with in SETSTEPL\n*                                     X'80' dealt with in NOTSTEPL\n         B     CHANGEND\nCHANGEDA DS    0H                     Replacing a table entry.\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC    Say \"before making changes\".\n         MVC   MESSAG3A+5(4),TABENNUM+6\n         MVC   MESSAG3A+13(2),CODEPLAC     Move in table code.\n         MVC   MESSAG3A+42(8),FSTNAME      Move in program name.\n         APUT  MESSAG3A,L'MESSAG3A    Tell em we changed the value.\n         B     CHANGEND\nCHANGEDB DS    0H                     Blanking a table entry.\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC    Say \"before making changes\".\n         MVC   MESSAG3B+5(4),TABENNUM+6\n         MVC   MESSAG3B+13(2),CODEPLAC     Move in table code.\n         MVC   MESSAG3B+42(8),FSTNAME      Move in program name.\n         APUT  MESSAG3B,L'MESSAG3B    Tell em we changed the value.\n         B     CHANGEND\nCHANGENU DS    0H                     Blanking a table entry.\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC    Say \"before making changes\".\n         MVC   MESSAG3G+5(4),TABENNUM+6\n         MVC   MESSAG3G+13(2),CODEPLAC     Move in table code.\n         MVC   MESSAG3G+42(8),FSTNAME      Move in program name.\n         APUT  MESSAG3G,L'MESSAG3G    Tell em we changed the value.\n         B     CHANGEND\nCHANGEDD DS    0H                     Displaying table entries (entry)\n         TM    OFFFLAG,X'04'\n         BZ    CHANGEDX               Not display? Say what's in slot.\n         CLC   SLOTBIN,=F'0'          Display entire table?\n         BE    CHANGEND               Don't say anything changed.\nCHANGEDX DS    0H                     Say we're displaying 1 slot.\n         MVC   LINE,LINE-1\n         MVC   LINE(30),=C'Display of Slot contents.     '\n         APUT  LINE,30\n         B     CHANGEND\nCHANGEDN DS    0H                     Say nothing changed.\n         APUT  MESSAG2D,L'MESSAG2D\n         B     CHANGEND\nCHANGEDH DS    0H                 Putting \" PARMLIB\" in table header.\n         TM    TIDFLAG,X'03'      Dealing with PC or PP?\n         BNZ   CHANGEDN           Yes. Show nothing was changed.\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC       Say \"before making changes\".\n         APUT  MESSAG3D,L'MESSAG3D\n         BAL   R9,PRTABLHD        Table Header Display Routine\n         B     CHANGEND\nCHANGEDK DS    0H                 \"Supply table lengths\" message.\n         TM    TIDFLAG,X'03'      Dealing with PC or PP?\n         BNZ   CHANGEDN           Yes. Show nothing was changed.\n         MVC   LINE,LINE-1               Print a blank line.\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC       Say \"before making changes\".\n         MVC   MESSAG3E+19(2),TABLEID    Put table id into message.\n         HEX   MESSAG3E+48,2,SAVETCUR    Old message length\n         CLC   TABLEID,=C'NS'            Is it the NS table?\n         BE    CHANGK01\n         HEX   MESSAG3E+60,2,SAVETNEW    8-byte table length\n         B     CHANGK02\nCHANGK01 DS    0H\n         TM    SHBLFLG,X'01'\n         BO    CHANGKA1\n         HEX   MESSAG3E+60,2,TO10LENG    10-byte table length\n         B     CHANGK02\nCHANGKA1 DS    0H\n         HEX   MESSAG3E+60,2,ME10LENG    10-byte table length\nCHANGK02 DS    0H\n         MVI   MESSAG3E+64,C'.'          Finish \"table length\" message.\n         APUT  MESSAG3E,L'MESSAG3E\n*                                        Message after change.\n         MVC   MESSAG1A+6(2),CODEPLAC    Move in table code.\n         HEX   MESSAG1A+57,2,SAVETNEW    New message length\n         MVI   MESSAG1A+61,C'.'          Put period at end.\n         APUT  MESSAG1A,L'MESSAG1A\n         B     CHANGEND\nCHANGEDZ DS    0H                 Zeroing table lengths in the LWA.\n         TM    TIDFLAG,X'03'      Dealing with PC or PP?\n         BNZ   CHANGEDN           Yes. Show nothing was changed.\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC       Say \"before making changes\"\n         MVC   MESSAG3F+19(2),TABLEID\n         HEX   MESSAG3F+33,2,SAVETNEW\n         MVI   MESSAG3F+37,C'.'\n         APUT  MESSAG3F,L'MESSAG3F\n         MVC   MESSAG1B+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1B,L'MESSAG1B\n         B     CHANGEND\nCHANGEND DS    0H\n         L     R9,SAVER9C\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nNAMEPARM DS    0H\n         ST    R9,SAVER9D\n         TM    LPADFLG,X'01'          Displaying LPA range?\n         BO    NAMEPEND               Don't look for a number here.\n*-*\n         TM    OFFFLAG,X'08'          Just changing table header?\n         BO    NAMEPEND               Yes. Then don't look for number.\n*-*\n*-*-*\n         TM    OFFFLAG,X'10'          Supply table length in LWA.\n         BO    NAMEPEND               Yes. Then don't look for number.\n*-*-*\n*-*-*-*\n         TM    OFFFLAG,X'20'          Zero table length in LWA.\n         BO    NAMEPEND               Yes. Then don't look for number.\n*-*-*-*\n*-*-*-*-*\n         TM    OFFFLAG,X'40'          Set on STEPLIB flag for table?\n         BO    NAMEPEND               Yes. Then don't look for number.\n*-*-*-*-*\n*-*-*-*-*-*\n         TM    OFFFLAG,X'80'          Set off STEPLIB flag for table?\n         BO    NAMEPEND               Yes. Then don't look for number.\n*-*-*-*-*-*\n         L     R8,SAVER8A             Get number of characters used\n         CR    R8,R5                  More than what's left?\n         BNL   NAMEBAD1               Yes. Error.\n         C     R5,=F'3'               Is end bigger than 3?\n         BNH   NAMEBAD1               No. Error.\nNAMEGOOD DS    0H\n         S     R5,=F'3'               Subtract 3 from number till end.\n         BAL   R9,GETNUMES            Get the number of the pgm entry.\n         TM    OFFFLAG,X'02'          Are we blanking?\n         BO    NAMEPEND               Yes. Don't need a name parameter\n         TM    OFFFLAG,X'04'          Displaying?\n         BO    NAMEPEND               Yes. No names wanted.\n         TM    OFFFLAG1,X'10'         Nullifying an entry?\n         BO    NAMEPEND               Yes. No names needed.\n         BAL   R9,GETNAMES            Get the name of pgm to shove in.\n         B     NAMEPEND\nNAMEBAD1 DS    0H                     Get here if there's no parameter.\n         TM    OFFFLAG,X'04'          Are we displaying?\n         BO    NAMEPEND               No error. Just get out normally.\n         TM    OFFFLAG,X'02'\n         BO    NAMEBAD2\n         BAL   R9,MISSPGM1            We're replacing. Ask for both.\n         B     EOJ4                   RC = 4\nNAMEBAD2 DS    0H\n         BAL   R9,MISSPGM3\n         B     EOJ4                   RC = 4\nNAMEPEND DS    0H\n         L     R9,SAVER9D\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nADJNEXTP DS    0H                     Get to first blank\n         ST    R9,SAVER9E\n         MVC   CHARSTRT,CHARCONT      Set up\n         L     R1,CHARSTRT\nSEEIFENX DS    0H                     Loop\n         CLI   0(R1),X'40'            First blank?\n         BE    SEEIFENZ               Yes, then end.\n         LA    R1,1(,R1)              Bump to next character\n         ST    R1,CHARSTRT            Store address away\n         B     SEEIFENX               Loop back\nSEEIFENZ DS    0H\n         L     R9,SAVER9E\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         LTORG\n************************************************************\nPGMTITLE DS    0H                     Display program name\n         ST    R9,SAVER9F\n         MVC   LINE,LINE-1            Blank line\n         MVC   LINE,MESSAGET          Move title line in\n         MVC   LINE+56(8),VERS#       Version number into title\n         APUT  LINE,L'MESSAGET        And put out to tube\n         MVC   LINE,LINE-1            Blank line again\n         MVC   LINE,MESSAGEU          Move underlines in\n         APUT  LINE,L'MESSAGEU        And put them out also\n         L     R9,SAVER9F\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nSETTMODE DS    0H                  Routine that does Key 0 stuff.\n         ST    R9,SAVER9G\n         TM    FLAGZ,X'02'         Is parm number past end of table?\n         BO    SETTMEND            Yes. Don't do key zero operations.\n         TM    LPAFLAG,X'01'       Is the table in LPA region?\n         BO    SETTMEND            Yes. Do not attempt to change it.\n* -- >       Test if this command is being run APF Authorized\n         AIF   ('&SVC' EQ 'SVC').DOSVC\n         STM   R15,R1,SAVE1401     Now save registers and test if APF\n         XR    R15,R15                  authorized.\n         TESTAUTH FCTN=1           Are we authorized?\n         LTR   R15,R15             Test the return code.\n         BNZ   NOTAUTH             Not zero, tell not authorized.\n         LM    R15,R1,SAVE1401     Restore registers used by TESTAUTH.\n.DOSVC   ANOP\n* -- >\n         AIF   ('&SVC' EQ 'NOSVC').NOSVC02\n         AUTHON\n.NOSVC02 ANOP\n* -- >      Key Zero ---- Here's where we change the stuff.\nKZ       MODESET KEY=ZERO\n* -\n         TM    OFFFLAG,X'04'       Only displaying entr(ies)?\n         BNZ   ENDKZ               Yes. No Key 0 stuff done.\n         CLI   LPAFLAG,X'01'       Did the table come from LPALIB?\n         BE    ENDKZ               Yes. Don't try to alter table.\n         TM    NSCHFLG,X'01'       Are we doing the NS table?\n         BO    TENSLOT             Yes. Handle its special needs.\nEIGHSLOT DS    0H                  8-character tables.\n*-*                                Altering table header only\n         TM    OFFFLAG,X'08'       Alter table header?\n         BZ    GONOHDRA            No. Escape this section.\n         TM    TIDFLAG,X'03'       Dealing with PC or PP?\n         BNZ   GONOHDRA            Yes. Show nothing was changed.\n         L     R3,HDRADDR          Load header address\n         MVC   8(8,R3),=C' PARMLIB'  Move in standard table header.\n         B     ENDKZ               Get out of supervisor state.\nGONOHDRA DS    0H\n*-*\n*-*-*\n         TM    OFFFLAG,X'30'       Supplying length to LWA field?\n         BZ    GONZLWA1            No. Don't do this routine.\n         BAL   R9,MEASUR08         Measure it.\n         BAL   R9,WHERSIZE         Load size into proper place in LWA.\n         B     ENDKZ               Get out of supervisor state.\nGONZLWA1 DS    0H\n*-*-*\n*-*-*-*-*\n         TM    OFFFLAG,X'40'       Set STEPLIB flag in LWA for table?\n         BZ    NOGSTEP1            No. Skip step.\n         BAL   R9,SETSTEPL         Set the STEPLIB flag on.\n         B     ENDKZ               Get out of supervisor state.\nNOGSTEP1 DS    0H\n*-*-*-*-*\n*-*-*-*-*-*\n         TM    OFFFLAG,X'80'       STEPLIB flag off in LWA for table?\n         BZ    NOGSTOF1            No. Skip step.\n         BAL   R9,NOTSTEPL         Set the STEPLIB flag off.\n         B     ENDKZ               Get out of supervisor state.\nNOGSTOF1 DS    0H\n*-*-*-*-*-*\n         L     R3,OURSLOT          Address of slot to replace name in.\n         TM    OFFFLAG,X'01'       Replacing function here?\n         BZ    BLANKIT             No. Do blanking function.\n         CLC   FSTNAME,BLANKS      Yes. Is new entry non-blank?\n         BE    ENDKZ               No. It is blank. Nothing to do.\n         MVC   0(8,R3),FSTNAME     Non-blank. Move in new pgm name.\n         B     ENDKZ               And get out.\nBLANKIT  DS    0H                  Blank an 8-character table entry\n         TM    OFFFLAG,X'02'       Blanking function here?\n         BZ    NULLIT              No. Try the next possibility.\n         L     R3,OURSLOT          Address of slot entry to blank\n         MVC   0(8,R3),BLANKS      Move the blanks in.\n         B     ENDKZ               And get out.\nNULLIT   DS    0H                  Nullify an entry by inserting ?.\n         TM    OFFFLAG1,X'10'      Nullifying function here?\n         BZ    ENDKZ               No. Can't do anything.\n         L     R3,OURSLOT          Yes. Load current slot number.\n         MVC   0(8,R3),QUEST08     Change it to C'?       '\n         B     ENDKZ               And get out.\nTENSLOT  DS    0H                  10-character tables.\n         L     R3,OURSLOT          Address of slot to replace name in.\n         TM    OFFFLAG,X'01'       Replacing function here?\n         BZ    BLANKTEN            No. Do blanking function.\n         CLC   FSTNAME,BLANKS      Yes. Is new entry non-blank?\n         BE    ENDKZ               No. It is blank. Nothing to do.\n         MVC   0(2,R3),FSTCHALF    Put length of the new program name.\n         MVC   2(8,R3),FSTNAME     Put in the new program name.\n         B     ENDKZ               Get out of supervisor state.\nBLANKTEN DS    0H                  Blank the 10-character table entry\n*-*                                Altering table header only\n         TM    OFFFLAG,X'08'       Alter table header?\n         BZ    GONOHDRB            No. Escape this section.\n         TM    TIDFLAG,X'03'       Dealing with PC or PP?\n         BNZ   GONOHDRB            Yes. Show nothing was changed.\n         L     R3,HDRADDR          Load header address\n         MVC   8(8,R3),=C' PARMLIB'  Move in standard table header.\n         B     ENDKZ               Get out of supervisor state.\nGONOHDRB DS    0H\n*-*\n*-*-*\n         TM    OFFFLAG,X'30'       Supplying length to LWA field?\n         BZ    GONZLWA2            No. Don't do this routine.\n         BAL   R9,MEASUR10         Measure it.\n         BAL   R9,WHERSIZE         Load size into proper place in LWA.\n         B     ENDKZ               Get out of supervisor state.\nGONZLWA2 DS    0H\n*-*-*\n*-*-*-*-*\n         TM    OFFFLAG,X'40'       Set STEPLIB flag in LWA for table?\n         BZ    NOGSTEP2            No. Skip step.\n         BAL   R9,SETSTEPL         Set the STEPLIB flag.\n         B     ENDKZ               Get out of supervisor state.\nNOGSTEP2 DS    0H\n*-*-*-*-*\n*-*-*-*-*-*\n         TM    OFFFLAG,X'80'       STEPLIB flag off in LWA for table?\n         BZ    NOGSTOF2            No. Skip step.\n         BAL   R9,NOTSTEPL         Set the STEPLIB flag off.\n         B     ENDKZ               Get out of supervisor state.\nNOGSTOF2 DS    0H\n*-*-*-*-*-*\n         TM    OFFFLAG,X'02'       Blanking function here?\n         BZ    NULLTEN             No. Can't do anything.\n         L     R3,OURSLOT          Address of slot entry to blank.\n         MVC   0(2,R3),=X'0000'    Move X'FFFF' to mark table end\n         MVC   2(8,R3),BLANKS      And move the blanks to pgm name slot\n         B     ENDKZ               Get out of supervisor state.\nNULLTEN  DS    0H\n         TM    OFFFLAG1,X'10'      Slot nullify function here?\n         BZ    ENDKZ               No. No action here.\n         L     R3,OURSLOT          Yes. Point to current slot in table\n         MVC   0(2,R3),=X'0001'    This is NS, so insert length.\n         MVC   2(8,R3),QUEST08     Insert Question Mark.\n         B     ENDKZ\nENDKZ    DS    0H                  Get ready to get out of Key 0.\n* -\nNZ       MODESET KEY=NZERO\n         AIF   ('&SVC' EQ 'NOSVC').NOSVC03\n         AUTHOFF\n.NOSVC03 ANOP\n* -- >      Back to ordinary life ----\nSETTMEND DS    0H                  Bypass Key 0 stuff.\n         L     R9,SAVER9G\n         BR    R9                  Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nERRORCOD DS    0H                  Give instructions if wrong things\n*                                   were entered, how to do it right.\n         ST    R9,SAVER9H\n         TM    LPADFLG,X'01'\n         BO    ERRORCOE\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSA11L,L'MESSA11L\n         APUT  MESSA11M,L'MESSA11M\n         APUT  MESSA11P,L'MESSA11P\n         APUT  MESSA11A,L'MESSA11A\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSA11C,L'MESSA11C\n         APUT  MESSA11D,L'MESSA11D\n         APUT  MESSA11Z,L'MESSA11Z\n         APUT  MESSA11Y,L'MESSA11Y\n         APUT  MESSA11X,L'MESSA11X\n         APUT  MESSA11W,L'MESSA11W\n         APUT  MESSA11F,L'MESSA11F\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSA11I,L'MESSA11I\n         APUT  MESSA11K,L'MESSA11K\n         APUT  MESSA11J,L'MESSA11J\n         APUT  MESSA11N,L'MESSA11N\n         APUT  MESSA11R,L'MESSA11R\n         APUT  MESSA11Q,L'MESSA11Q\n         APUT  MESSA11O,L'MESSA11O\n*        MVC   LINE,LINE-1\n*        APUT  LINE,30\nERRORCOE DS    0H\n         L     R9,SAVER9H\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMISSPGM1 DS    0H                     Supply a slot number & pgm name.\n         ST    R9,SAVER9I\n         MVC   LINE,LINE-1\n         APUT  MESSA11G,L'MESSA11G\n         L     R9,SAVER9I\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMISSPGM2 DS    0H                     Supply a program name to put in.\n         ST    R9,SAVER9J\n         MVC   LINE,LINE-1\n         APUT  MESSA11E,L'MESSA11E\n         L     R9,SAVER9J\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMISSPGM3 DS    0H                     Supply a slot number to Blank.\n         ST    R9,SAVER9N\n         MVC   LINE,LINE-1\n         APUT  MESSA12Q,L'MESSA12Q\n         L     R9,SAVER9N\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nDISPTABL DS    0H                Scan thru the particular table....\n         ST    R9,SAVER9L          Save BAL register\n         ST    R3,SAVER3A          Save\n         ST    R4,SAVER4A             the\n         ST    R5,SAVER5A                work\n         ST    R2,SAVER2G                   registers.\n*-*\n         TM    OFFFLAG,X'08'     Just altering table header?\n         BO    DISPTSKP          Yes. Don't display table at all.\n*-*\n*-*-*\n         TM    OFFFLAG,X'10'     Just supplying an LWA size?\n         BO    DISPTSKP          Yes. Don't display table at all.\n*-*-*\n*-*-*-*\n         TM    OFFFLAG,X'20'     Zeroing out LWA size?\n         BO    DISPTSKP          Yes. Don't display table at all.\n*-*-*-*\n*-*-*-*-*\n         TM    OFFFLAG,X'40'     Setting table to come from STEPLIB?\n         BO    DISPTSKP          Yes. Don't display table at all.\n*-*-*-*-*\n*-*-*-*-*-*\n         TM    OFFFLAG,X'80'     Setting table not from STEPLIB?\n         BO    DISPTSKP          Yes. Don't display table at all.\n*-*-*-*-*-*\n         XR    R3,R3               Zero\n         XR    R5,R5                  work\n         XR    R2,R2                     registers.\nDISPTSTR DS    0H\n         L     R3,TABLSTRT         Load start address of table\n         L     R2,TABLENUM         Load number of entries in table\n         L     R5,TABLESIZ         Load size of each entry\n         LA    R4,1                Start slot number count at 1\n         ST    R4,SLOTNOW          Store slot number count away\n         ST    R3,OURSLOT          Initialize slot address.\n         CLC   SLOTBIN,=F'0'       If there's no slot num in parameter\n         BE    DISPTLUP            Then bypass error checking\n         C     R2,SLOTBIN          Compare table size to parm number\n         BNL   DISPTLUP            If parm number is LE, then display\nDISPTERR DS    0H                  Else error message and out.\n         MVC   LINE,LINE-1\n         MVC   LINE(22),=C'Slot number specified '\n         L     R1,SLOTBIN          Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         MVC   LINE+34(26),=C'is bigger than table size '\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+60(10),MASK10  Move in the mask\n         ED    LINE+60(10),CVDAREA+3 Make it pretty\n         APUT  LINE,72\n         B     EOJ4\nDISPTLUP DS    0H                  Loop thru the table entries.\n         MVC   LINE,LINE-1\n         MVC   LINE(2),CODEPLAC    Move in table code.\n         MVC   LINE+3(19),=C'Table Entry Number:'\n         CVD   R4,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         MVC   TABENNUM(10),MASK10      Preserve printable slot number\n         ED    TABENNUM(10),CVDAREA+3\n         TM    NSCHFLG,X'01'       Is this the 10-byte NS table entry?\n         BO    DISPTBNS            Yes. Handle separately.\n         MVC   LINE+34(8),0(R3)\n         CLC   LINE+34(8),BLANKS   Is this a blank entry.\n         BNE   DISPTBLK            No.\n         MVC   LINE+34(8),=C'*empty* '   Yes. Don't just show blanks.\n         OI    FLAGZ,X'01'         We found a blank table entry.\n         TM    FLAGZ,X'04'         Do we have table lengths?\n         BO    DISPTBLK            Yes, then use the table lengths\n* -------                           that we have.\n*                                  No table lengths here. So....\n         ST    R3,OURSLOT          Preserve empty slot address\n         ST    R4,SLOTNOW          Also preserve this slot number.\n         B     DISPTYES            And then stop on first blank.\nDISPTBNS DS    0H\n         HEX   LINE+34,2,0(R3)     Display size of this entry\n         MVC   LINE+40(8),2(R3)    Move in program name to slot\n         CLC   LINE+40(8),BLANKS   Is this a blank entry.\n         BNE   DISPTBLK            No.\n         MVC   LINE+40(8),=C'*empty* '   Yes. Don't just show blanks.\n         OI    FLAGZ,X'01'         We found a blank table entry.\n         TM    FLAGZ,X'04'         Do we have table lengths?\n         BO    DISPTBLK            Yes, then use the table lengths\n* -------                           that we have.\n*                                  No table lengths here. So....\n         ST    R3,OURSLOT          Preserve empty slot address\n         ST    R4,SLOTNOW          Also preserve this slot number.\n         B     DISPTYES            And then stop on first blank.\nDISPTBLK DS    0H                  Search each slot number.\n         CLC   SLOTBIN,=F'0'       Has a slot number been specified?\n         BE    DISPTYES            No. Just display all the slots.\n         CLC   SLOTBIN,SLOTNOW     Yes. Then are we at the one we want?\n         BNE   DISPTNOT            No. Just go further and search.\n         OI    FLAGZ,X'08'         We're at the desired slot.\n* ---  Save contents of the current slot which was found - below\n         ST    R3,OURSLOT          Preserve this slot's address\n         LR    R1,R5               Load table entry size\n         BCTR  R1,0                One less for execute\n         EX    R1,MOVESLOT         Save contents of slot for kicks\n         B     DISPTPEX               Branch past executed instruction\nMOVESLOT MVC   SLOTSAVE(*-*),0(R3)    EXECUTED\nDISPTPEX DS    0H\n* ---  Save contents of the current slot which was found - above\nDISPTYES DS    0H                  Print this slot entry\n         APUT  LINE,52\n         TM    FLAGZ,X'01'         Is this a blank table entry?\n         BO    DISPTEND            Yes, end the table search.\n         TM    FLAGZ,X'08'         Are we at the slot # we specified?\n         BO    DISPTEND            Yes. Stop the search.\nDISPTNOT DS    0H                  Bump to next slot and loop back.\n         C     R3,TABLEND          Compare to end from adding bytes.\n         BH    DISPTEND            Past it, then end the search.\n         LA    R3,0(R5,R3)         Bump to next slot\n         ST    R3,OURSLOT          Store its address - important....\n         LA    R4,1(,R4)           Bump count of slot number\n         ST    R4,SLOTNOW          Store new slot number away\n         ST    R2,SAVER2E\n         BCT   R2,DISPTLUP         And loop to examine the new slot.\n*\nDISPTEND DS    0H                  END OF TABLE SEARCH ROUTINE\n* - >                              Display message if desired slot is\n* - >                               past the end of the table.\n         CLC   SLOTBIN,SLOTNOW     Is the parm number past the end?\n         BNH   DISPTNOP            No. Don't report a problem.\n         L     R1,SLOTBIN          Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         MVC   LINE+34(26),=C'exceeds scanned table size'\n         L     R1,SLOTNOW          Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+60(10),MASK10  Move in the mask\n         ED    LINE+60(10),CVDAREA+3 Make it pretty\n         APUT  LINE,72\n         OI    FLAGZ,X'02'         Flag a problem situation.\nDISPTNOP DS    0H\nDISPTSKP DS    0H\n* - >\n         L     R3,SAVER3A          Restore all the work registers.\n         L     R4,SAVER4A\n         L     R5,SAVER5A\n         L     R2,SAVER2G\n         L     R9,SAVER9L          Restore the BAL register.\n         BR    R9                  Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETNUMES DS    0H                  Get the number after the table code\n         ST    R9,SAVER9M           + the action code. If it exists.\n         ST    R2,SAVER2F\nGETNUMST DS    0H                  Get rid of leading blanks\n         L     R1,CHARCONT         Point to start of character\n         CLI   0(R1),X'40'         Is it a blank?\n         BNE   GETNUMNZ            No. Get the entire name.\n         LA    R1,1(,R1)           Yes. Bump start place one up.\n         ST    R1,CHARCONT         And store the place away for now.\n         C     R5,=F'1'            End of cmd buffer one away?\n         BNH   EOJ4                Yes. Error.\n         S     R5,=F'1'            Subtract one from end count\n         B     GETNUMST            And loop to find first non-blank.\nGETNUMNZ DS    0H                  Got first non-blank. Get whole name.\n         LA    R2,5                BCT initial quantity - 5 chars.\n         LA    R8,0                Character count\n         L     R1,CHARCONT         Load starting place\n         LR    R4,R1               Initialize pointer\n         LA    R4,0(,R4)           to first character of program number\nGETNUMLU DS    0H                  Loop to get entire number\n         CLI   0(R4),X'40'         First blank?\n         BE    GETNUMGT            Yes, got whole number\n         CLI   0(R4),X'00'         First hex zeros?\n         BE    GETNUMGT            Yes, got whole number\n         CR    R8,R5               End of command buffer?\n         BNL   GETNUMGT            Yes. Got all we can get.\n* --                               Test EBCDIC number if numeric.\n         CLI   0(R4),X'F0'         Check character if numeric digit.\n         BL    NOTNUMER            Less than X'F0', not a number.\n         CLI   0(R4),X'F9'         More than X'F9'?\n         BH    NOTNUMER            Not a number.\n* --\n         LA    R8,1(,R8)           Bump character counter.\n         LA    R4,1(,R4)           Bump where we are.\n         BCT   R2,GETNUMLU         Loop back.\nGETNUMGT DS    0H                  Got the whole number - examine it.\n         ST    R8,SAVER8A\n         ST    R8,FSTNOUNT         Get halfword value of slot number\n         MVC   FSTNHALF(2),FSTNOUNT+2\n         L     R3,CHARCONT\n         BCTR  R8,0                One less for EXECUTE\n         MVC   FSTFIELD(8),BLANKS  5-char number plus 3 blanks\n         EX    R8,MOVFNUM          Get the number from the parm\n         EX    R8,PACK             Convert it to packed\n         CVB   R0,WORKA            Convert it to Binary\n         ST    R0,SLOTBIN          Store the value for later use\n         MVC   LINE,LINE-1\n         MVC   LINE(8),FSTFIELD    8-char number with blanks\n         MVC   LINE+13(19),=C'Entry slot number  '\n         APUT  LINE,32\n         LA    R8,1(,R8)           Restore number of chars after EX\n         ST    R8,CHARSIZE         Save this value off.\n         AR    R3,R8               Add it to R3 so we start past it.\n         ST    R3,CHARCONT         Store start value for next parm.\nGETNUMEN DS    0H\n         L     R2,SAVER2F\n         L     R9,SAVER9M\n         BR    R9\n* ----------------------------------------------------------------- *\n*      Measure \"8-byte entry\" loaded table.                         *\n* ----------------------------------------------------------------- *\n*      R5 contains the entry point of the table.                    *\n* ----------------------------------------------------------------- *\nMEASUR08 DS    0H                 R5 has beginning address of table.\n         ST    R9,SAVER9O           Save BAL register\n         ST    R5,SAVER5D           Save work register\n         ST    R4,SAVER4B           Save work register\n         L     R5,TABLADDR          Load start of table\n         XC    BLNKCNT,BLNKCNT      Zero the counters\n         XC    NTRYCNT,NTRYCNT\n         LA    R4,16                Count size of header\n         LA    R5,16(,R5)           Bump past header\nME08LOOP DS    0H\n*     Try (real hard) to detect the end of the table  -  below\n         MVC   SAVECHAR(1),0(R5)    Save first character\n         CLC   =C'        ',0(R5)   Is this table entry a blank?\n         BE    ME08BLNK             Yes. Reached virtual end of table\n         CLC   ZEROES8(8),0(R5)     Is this \"entry\" hex zeros?\n         BE    ME08NOBL             Yes. Reached possible junk storage\n         CLC   =C' ',0(R5)          Is first character blank?\n         BE    ME08NOBL             Yes, not a valid table entry.\n         TR    SAVECHAR,TRTPGMNM    Check first char if appropriate.\n         CLI   SAVECHAR,X'02'       Not. probably end of table.\n         BE    ME08NOBL\n         CLC   =C'IKJEFTE2',0(R5)\n         BE    ME08NOBL\n         CLC   =C'IKJEFTE8',0(R5)\n         BE    ME08NOBL\n         CLC   =C'IKJEFTAP',0(R5)\n         BE    ME08NOBL\n         CLC   =C'IKJEFTNS',0(R5)\n         BE    ME08NOBL\n*     Try (real hard) to detect the end of the table  -  above\n         LA    R4,8(,R4)            Count next table entry\n         LA    R5,8(,R5)            Bump to next entry\n         L     R1,NTRYCNT           Increment \"entry count\" counter\n         A     R1,=F'1'\n         ST    R1,NTRYCNT\n         B     ME08LOOP             Loop back till perceived table end\nME08BLNK DS    0H\n         LA    R4,8(,R4)            Add length of blank entry\n         LA    R5,8(,R5)            Bump past blank entry.\n         L     R1,BLNKCNT           Increment \"blank entry\" counter\n         A     R1,=F'1'\n         ST    R1,BLNKCNT\nME08NOBL DS    0H\n         STH   R4,ME08LENG          Store measured length of table.\n         ST    R5,ME08END           And record address of table end.\n         BAL   R9,MESBLK08          Measure more blanks after table.\n         TM    MEASFLG,X'01'        Been here already?\n         BO    ME08NOSH             Don't show count again.\n         BAL   R9,ENTRYDSP          Show number of entries.\nME08NOSH DS    0H\n         OI    MEASFLG,X'01'        Show we did this once.\n         L     R4,SAVER4B           Restore work register\n         L     R5,SAVER5D           Restore work register\n         L     R9,SAVER9O           Restore BAL register\n         BR    R9\nME08END  DS    F                    Store end-of-table address\nME08LENG DS    H                    Store table length\nBL08LENG DS    H                    Store length of blanks\nTO08LENG DS    H                    Store total, nonblank+blank\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMESBLK08 DS    0H                   See how many more blanks we have.\n         ST    R9,SAVER9Y           Save BAL register\n         ST    R5,SAVER5E           Save work register\n         L     R5,ME08END           Start at measured end of table.\nMESBLL08 DS    0H                   Loop\n         CLC   =C'        ',0(R5)   Is this entry a blank?\n         BNE   MESBLE08             Yes. Stop counting blanks.\n         CLC   BLNKCNT,MAXBLANK     Have we exceeded the maximum guess?\n         BH    MESBLE08             Yes. Don't find more blanks.\n         L     R1,BLNKCNT           Increment \"blank entry\" counter\n         A     R1,=F'1'\n         ST    R1,BLNKCNT\n         LA    R5,8(,R5)            Bump to next entry.\n         B     MESBLL08             Loop until no blanks or max.\nMESBLE08 DS    0H\n         L     R1,BLNKCNT           Total count of found blanks\n         LTR   R1,R1\n         BZ    MESBLX08\n         BCTR  R1,0                 Really one less\nMESBLX08 DS    0H\n         SLL   R1,3                 Multiply by 8\n         STH   R1,BL08LENG          Length of blank entries\n         AH    R1,ME08LENG          Add length of non-blank entries\n         STH   R1,TO08LENG          Total length of both\n*>*----\n*        STM   R14,R1,SAVE1401      Save registers 14 thru 1.\n*        MVC   LINE,LINE-1\n*        HEX   LINE,2,ME08LENG\n*        HEX   LINE+10,2,BL08LENG\n*        HEX   LINE+20,2,TO08LENG\n*        APUT  LINE,30\n*        LM    R14,R1,SAVE1401      Load registers 14 thru 1.\n*>*----\n         L     R5,SAVER5E           Restore work register\n         L     R9,SAVER9Y           Restore BAL register\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* ----------------------------------------------------------------- *\n*      Measure \"10-byte entry\" loaded table.                        *\n* ----------------------------------------------------------------- *\n*      R5 contains the entry point of the table.                    *\n* ----------------------------------------------------------------- *\nMEASUR10 DS    0H                 R5 has beginning address of table.\n         ST    R9,SAVER9P           Save BAL register\n         ST    R5,SAVER5D           Save work register\n         ST    R4,SAVER4B           Save work register\n         L     R5,TABLADDR          Load start of table\n         XC    BLNKCNT,BLNKCNT      Zero the counters\n         XC    NTRYCNT,NTRYCNT\n         LA    R4,16                Count size of header\n         LA    R5,16(,R5)           Bump past header\nME10LOOP DS    0H\n         MVC   SAVECHAR(1),2(R5)    Save first character of pgm name\n         MVC   SAVECH08(1),9(R5)    Save last character of pgm name\n         CLC   BLKSTRNG(10),0(R5)   Full blank entry here?\n         BE    ME10BLNK             Yes. Count the blank entry.\n         CLC   ENDSTRNG(10),0(R5)   FFFF plus blank pgm name?\n         BE    ME10BLNK             Yes. Can still be considered blank.\n         CLC   =X'0000',0(R5)       Test-test-test-test-test\n         BE    ME10TEST             Test rest of \"entry\n         B     ME10REST             Not zeros, go on.\nME10TEST DS    0H\n         TR    SAVECHAR,TRTPGMNM    Check for strange character.\n         CLI   SAVECHAR,X'02'       Is it strange?\n         BE    ME10NOBL             Yes. This is not a blank entry.\nME10REST DS    0H\n         CLC   =X'FFFF',0(R5)       Test for end string separately.\n         BNE   ME10TES2             Not. Not at virtual end of table\n         B     ME10NOBL             FFFF alone. Not a blank entry.\nME10TES2 DS    0H\n         TR    SAVECHAR,TRTPGMNM    Check first char not upcase alpha.\n         CLI   SAVECHAR,X'02'       Not. probably end of table.\n         BE    ME10NOBL\n         TR    SAVECH08,TRTPGMNM    Check last char not upcase alpha.\n         CLI   SAVECH08,X'02'       Not. probably end of table.\n         BE    ME10NOBL\n         LA    R4,10(,R4)           Count next table entry\n         LA    R5,10(,R5)           Bump to next entry\n         L     R1,NTRYCNT           Increment \"entry count\" counter\n         A     R1,=F'1'\n         ST    R1,NTRYCNT\n         B     ME10LOOP             Finished this entry, try for more.\nME10BLNK DS    0H\n         LA    R4,10(,R4)           Add length of blank entry\n         LA    R5,10(,R5)           Bump past blank entry.\n         L     R1,BLNKCNT           Increment \"blank entry\" counter\n         A     R1,=F'1'\n         ST    R1,BLNKCNT\nME10NOBL DS    0H\n         STH   R4,ME10LENG          Store measured length of table.\n         ST    R5,ME10END           And record address of table end.\n         BAL   R9,MESBLK10          Measure more blanks after table.\n         TM    MEASFLG,X'01'        Been here already?\n         BO    ME10NOSH             Don't show count again.\n         BAL   R9,ENTRYDSP          Show number of entries.\nME10NOSH DS    0H\n         OI    MEASFLG,X'01'        Show we did this once.\n         L     R4,SAVER4B           Restore work register\n         L     R5,SAVER5D           Restore work register\n         L     R9,SAVER9P           Restore BAL register\n         BR    R9\nME10END  DS    F                    Store end-of-table address\nME10LENG DS    H                    Store table length\nBL10LENG DS    H                    Store length of blanks\nTO10LENG DS    H                    Store total, nonblank+blank\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMESBLK10 DS    0H                   See how many more blanks we have.\n         ST    R9,SAVER9Y           Save BAL register\n         ST    R5,SAVER5E           Save work register\n         L     R5,ME10END           Start at measured end of table.\nMESBLL10 DS    0H                   Loop\n         CLC   =C'        ',2(R5)   Is this entry a blank entry?\n         BNE   MESBLE10             No. End of perceived blanks.\n         CLC   =X'0000',0(R5)       Length is zero?\n         BNE   MESBLE10             No. End of perceived blanks.\n         CLC   =X'FFFF',0(R5)       Real table end?\n         BE    MESBLE10             Yes. Consider it end of table.\n         CLC   BLNKCNT,MAXBLANK     Have we exceeded the maximum guess?\n         BH    MESBLE10             Yes. Don't find more blanks.\n         L     R1,BLNKCNT           Increment \"blank entry\" counter\n         A     R1,=F'1'\n         ST    R1,BLNKCNT\n         LA    R5,10(,R5)           Bump to next entry.\n         B     MESBLL10             Loop until no blanks or max.\nMESBLE10 DS    0H\n         L     R1,BLNKCNT           Number of blank entries\n         LTR   R1,R1\n         BZ    MESBLX10\n         BCTR  R1,0                 Really one less\nMESBLX10 DS    0H\n         STM   R2,R3,SAVER23        Save work registers\n         XR    R2,R2                Clear R2\n         XR    R3,R3                Clear R3\n         LR    R3,R1                Dump count into R2 for mult.\n         M     R2,=F'10'            Multiply by entry size\n         STH   R3,BL10LENG          Store length of blank entries\n         AH    R3,ME10LENG          Add length of non-blank entries\n         STH   R3,TO10LENG          Total length of both\n         LM    R2,R3,SAVER23        Restore work registers\n*>*----\n*        STM   R14,R1,SAVE1401      Save registers 14 thru 1.\n*        MVC   LINE,LINE-1\n*        HEX   LINE,2,ME10LENG\n*        HEX   LINE+10,2,BL10LENG\n*        HEX   LINE+20,2,TO10LENG\n*        HEX   LINE+30,4,BLNKCNT\n*        APUT  LINE,50\n*        LM    R14,R1,SAVE1401      Load registers 14 thru 1.\n*>*----\n         L     R5,SAVER5E           Restore work register\n         L     R9,SAVER9Y           Restore BAL register\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* ------------------------------------------------------------------ *\nWHERSIZE DS    0H                   Point to size field to update.\n* ------------------------------------------------------------------ *\n*    This is executed after MEASUR08 or MEASUR10.                    *\n*    The idea here is to update the appropriate length field for     *\n*      the appropriate table, after having measured the size.        *\n*    This routine is also used for zeroing the table lengths.        *\n*    This routine is executed in supervisor state. Called from       *\n*      the SETTMODE routine.                                         *\n* ------------------------------------------------------------------ *\n*   ***  Note:  We unconditionally update the table lengths.  ***    *\n* ------------------------------------------------------------------ *\n         ST    R9,SAVER9Q           Save BAL register\n         ST    R2,SAVER2B           Save work registers\n         ST    R3,SAVER3C\n         TM    OFFFLAG,X'30'        Are we updating or zeroing lengths?\n         BZ    WHEREXIT             No. We have no business here.\n         L     R2,LWAADDR           Point to the Logon Work Area.\n         USING LWA,R2               Address its fields.\n*-----------------------------*\nWHERCHUZ DS    0H                   Which table are we dealing with?\n*-----------------------------*\n         TM    TIDFLAG,X'20'           E2?\n         BO    WHERE2\n         TM    TIDFLAG,X'10'           E8?\n         BO    WHERE8\n         TM    TIDFLAG,X'80'           AP?\n         BO    WHERAP\n         TM    TIDFLAG,X'40'           NS?\n         BO    WHERNS\n         B     WHEREXIT\n*-----------------------------*\nWHERE2   DS    0H                      Update E2 length\n         TM    SHBLFLG,X'01'\n         BO    WHERE2SH\n         MVC   LWATE2LN(2),TO08LENG    Move length to LWA\n         MVC   SAVETNEW(2),TO08LENG    Save length for message\n         B     WHERE2E\nWHERE2SH DS    0H\n         MVC   LWATE2LN(2),ME08LENG    Move length to LWA\n         MVC   SAVETNEW(2),ME08LENG    Save length for message\nWHERE2E  DS    0H\n*-*-*-*\nWHERE2Z  DS    0H                      If zeroing, then zero E2 length\n         TM    OFFFLAG,X'20'           Zeroing length?\n         BZ    WHE2NOZ1                No. Bypass this.\n         MVC   LWATE2LN(2),=X'0000'    Move length to LWA\n         MVC   SAVETNEW(2),=X'0000'    Save length for message\nWHE2NOZ1 DS    0H\n*-*-*-*\n         B     WHEREXIT                Finished, get out of routine.\n*-----------------------------*\nWHERE8   DS    0H                      Update E8 length\n         TM    SHBLFLG,X'01'\n         BO    WHERE8SH\n         MVC   LWATE8LN(2),TO08LENG    Move length to LWA\n         MVC   SAVETNEW(2),TO08LENG    Save length for message\n         B     WHERE8E\nWHERE8SH DS    0H\n         MVC   LWATE8LN(2),ME08LENG    Move length to LWA\n         MVC   SAVETNEW(2),ME08LENG    Save length for message\nWHERE8E  DS    0H\n*-*-*-*\nWHERE8Z  DS    0H                      If zeroing, then zero E8 length\n         TM    OFFFLAG,X'20'           Zeroing length?\n         BZ    WHE8NOZ1                No. Bypass this.\n         MVC   LWATE8LN(2),=X'0000'    Move length to LWA\n         MVC   SAVETNEW(2),=X'0000'    Save length for message\nWHE8NOZ1 DS    0H\n*-*-*-*\n         B     WHEREXIT                Finished, get out of routine.\n*-----------------------------*\nWHERAP   DS    0H                      Update AP length\n         TM    SHBLFLG,X'01'\n         BO    WHERAPSH\n         MVC   LWATAPLN(2),TO08LENG    Move length to LWA\n         MVC   SAVETNEW(2),TO08LENG    Save length for message\n         B     WHERAPE\nWHERAPSH DS    0H\n         MVC   LWATAPLN(2),ME08LENG    Move length to LWA\n         MVC   SAVETNEW(2),ME08LENG    Save length for message\nWHERAPE  DS    0H\n*-*-*-*\nWHERAPZ  DS    0H                      If zeroing, then zero AP length\n         TM    OFFFLAG,X'20'           Zeroing length?\n         BZ    WHAPNOZ1                No. Bypass this.\n         MVC   LWATAPLN(2),=X'0000'    Move length to LWA\n         MVC   SAVETNEW(2),=X'0000'    Save length for message\nWHAPNOZ1 DS    0H\n*-*-*-*\n         B     WHEREXIT                Finished, get out of routine.\n*-----------------------------*\nWHERNS   DS    0H                      Update NS length\n         TM    SHBLFLG,X'01'\n         BO    WHERNSSH\n         MVC   LWATNSLN(2),TO10LENG    Move length to LWA\n         MVC   SAVETNEW(2),TO10LENG    Save length for message\n         B     WHERNSE\nWHERNSSH DS    0H\n         MVC   LWATNSLN(2),ME10LENG    Move length to LWA\n         MVC   SAVETNEW(2),ME10LENG    Save length for message\nWHERNSE  DS    0H\n*-*-*-*\nWHERNSZ  DS    0H                      If zeroing, then zero NS length\n         TM    OFFFLAG,X'20'           Zeroing length?\n         BZ    WHNSNOZ1                No. Bypass this.\n         MVC   LWATNSLN(2),=X'0000'    Move length to LWA\n         MVC   SAVETNEW(2),=X'0000'    Save length for message\nWHNSNOZ1 DS    0H\n*-*-*-*\n         B     WHEREXIT                Finished, get out of routine.\n*-----------------------------*\nWHEREXIT DS    0H\n         L     R2,SAVER2B              Restore work registers\n         L     R3,SAVER3C\n         L     R9,SAVER9Q\n         BR    R9\n         DROP  R2\nTABLEID  DC    CL2' '\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nSETSTEPL DS    0H                     Routine to turn on STEPLIB flags\n         ST    R9,SAVER9R\n         ST    R2,SAVER2C                Save work register\n         L     R2,LWAADDR\n         USING LWA,R2\nSETSWTBL DS    0H                     Check which table we're seeing\n         TM    TIDFLAG,X'03'          PC OR PP table?\n         BNZ   SETSTEPN               Say nothing changed.\n         TM    TIDFLAG,X'20'          E2?\n         BO    SETSDOE2\n         TM    TIDFLAG,X'10'          E8?\n         BO    SETSDOE8\n         TM    TIDFLAG,X'80'          AP?\n         BO    SETSDOAP\n         TM    TIDFLAG,X'40'          NS?\n         BO    SETSDONS\nSETSDOE2 DS    0H\n         OI    LWAPRMLB,LWATE2ST         STEPLIB flag on for E2\n         B     SETSWTBE\nSETSDOE8 DS    0H\n         OI    LWAPRMLB,LWATE8ST         STEPLIB flag on for E8\n         B     SETSWTBE\nSETSDOAP DS    0H\n         OI    LWAPRMLB,LWATAPST         STEPLIB flag on for AP\n         B     SETSWTBE\nSETSDONS DS    0H\n         OI    LWAPRMLB,LWATNSST         STEPLIB flag on for NS\n         B     SETSWTBE\nSETSWTBE DS    0H                        Print informative message\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC    Say \"before making changes\"\n         MVC   LINE,LINE-1\n         MVC   LINE(71),=C'Table    marked from STEPLIB so PARMLIB UPDA-\n               TE(xx) will not overlay it.'\n         MVC   LINE+6(2),TABLEID\n         APUT  LINE,71\n         B     SETSTEPE\nSETSTEPN DS    0H\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         APUT  MESSAG2D,L'MESSAG2D   Say nothing changed.\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     SETSTEPE\nSETSTEPE DS    0H\n         L     R2,SAVER2C             Restore work register\n         L     R9,SAVER9R\n         DROP  R2\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nNOTSTEPL DS    0H                    Routine to turn off STEPLIB flags\n         ST    R9,SAVER9K\n         ST    R2,SAVER2C             Save work register\n         L     R2,LWAADDR\n         USING LWA,R2\nNOTSWTBL DS    0H                     Check which table we're seeing\n         TM    TIDFLAG,X'03'          PC OR PP table?\n         BNZ   NOTSTEPN               Say nothing changed.\n         TM    TIDFLAG,X'20'          E2?\n         BO    NOTSDOE2\n         TM    TIDFLAG,X'10'          E8?\n         BO    NOTSDOE8\n         TM    TIDFLAG,X'80'          AP?\n         BO    NOTSDOAP\n         TM    TIDFLAG,X'40'          NS?\n         BO    NOTSDONS\nNOTSDOE2 DS    0H\n         NI    LWAPRMLB,X'FF'-LWATE2ST   STEPLIB flag off for E2\n         B     NOTSWTBE\nNOTSDOE8 DS    0H\n         NI    LWAPRMLB,X'FF'-LWATE8ST   STEPLIB flag off for E8\n         B     NOTSWTBE\nNOTSDOAP DS    0H\n         NI    LWAPRMLB,X'FF'-LWATAPST   STEPLIB flag off for AP\n         B     NOTSWTBE\nNOTSDONS DS    0H\n         NI    LWAPRMLB,X'FF'-LWATNSST   STEPLIB flag off for NS\n         B     NOTSWTBE\nNOTSWTBE DS    0H                     Print informative message.\n         MVC   LINE,LINE-1            Print a blank first.\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC    Say \"before making changes\".\n         MVC   LINE,LINE-1\n         MVC   LINE(71),=C'Table    marked from not from STEPLIB. PARML-\n               IB UPDATE(xx) can overlay. '\n         MVC   LINE+6(2),TABLEID      Move table name into message.\n         APUT  LINE,71\n         B     NOTSTEPE\nNOTSTEPN DS    0H\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         APUT  MESSAG2D,L'MESSAG2D   Say nothing changed.\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     NOTSTEPE\nNOTSTEPE DS    0H\n         L     R2,SAVER2C             Restore work register\n         L     R9,SAVER9K\n         BR    R9\n         DROP  R2\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETLPABD DS    0H                  Get storage boundary values for LPA\n         ST    R9,SAVER9S\nGETLSTRT DS    0H\n         ST    R5,SAVER5C          Prepare a bunch of work registers\n         ST    R4,SAVER4C          Prepare a bunch of work registers\n         L     R5,X'10'            Point to CVT.\n         USING CVT,R5              Tell Assembler.\n         L     R4,CVTSMEXT         Point to CVT Extension.\n         USING CVTVSTGX,R4         Tell Assembler.\n         MVC   SAVMLPAS,CVTMLPAS   MLPA start\n         MVC   SAVMLPAE,CVTMLPAE   MLPA end\n         MVC   SAVFLPAS,CVTFLPAS   FLPA start\n         MVC   SAVFLPAE,CVTFLPAE   FLPA end\n         MVC   SAVPLPAS,CVTPLPAS   PLPA start\n         MVC   SAVPLPAE,CVTPLPAE   PLPA end\n         MVC   SAVEMLPS,CVTEMLPS   E-MLPA start\n         MVC   SAVEMLPE,CVTEMLPE   E-MLPA end\n         MVC   SAVEFLPS,CVTEFLPS   E-FLPA start\n         MVC   SAVEFLPE,CVTEFLPE   E-FLPA end\n         MVC   SAVEPLPS,CVTEPLPS   E-PLPA start\n         MVC   SAVEPLPE,CVTEPLPE   E-PLPA end\n         L     R5,SAVER5C          Restore the work registers\n         L     R4,SAVER4C          Restore the work registers\n         L     R9,SAVER9S\n         DROP  R5,R4\n         BR    R9                  Return\n*                                  Constants needed here.\nSAVMLPAS DC    A(0)\nSAVMLPAE DC    A(0)\nSAVFLPAS DC    A(0)\nSAVFLPAE DC    A(0)\nSAVPLPAS DC    A(0)\nSAVPLPAE DC    A(0)\nSAVEMLPS DC    A(0)\nSAVEMLPE DC    A(0)\nSAVEFLPS DC    A(0)\nSAVEFLPE DC    A(0)\nSAVEPLPS DC    A(0)\nSAVEPLPE DC    A(0)\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETLPRNT DS    0H         Routine to Print LPA Range - action code X\n         ST    R9,SAVER9T\n         TM    LPADFLG,X'01'         Code wasn't X. Don't print.\n         BZ    GETLPRTE              Just restore R9 and go on.\n         MVC   LINE,LINE-1\n         MVC   LINE(28),DASHES28\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(28),=C' --- LPA RANGE DISPLAY ---  '\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(28),DASHES28\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(4),=C'MLPA'\n         HEX   LINE+10,4,SAVMLPAS    MLPA range\n         HEX   LINE+20,4,SAVMLPAE\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(4),=C'FLPA'\n         HEX   LINE+10,4,SAVFLPAS    FLPA range\n         HEX   LINE+20,4,SAVFLPAE\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(4),=C'PLPA'      PLPA range\n         HEX   LINE+10,4,SAVPLPAS\n         HEX   LINE+20,4,SAVPLPAE\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(6),=C'E-MLPA'    E-MLPA range\n         HEX   LINE+10,4,SAVEMLPS\n         HEX   LINE+20,4,SAVEMLPE\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(6),=C'E-FLPA'    E-FLPA range\n         HEX   LINE+10,4,SAVEFLPS\n         HEX   LINE+20,4,SAVEFLPE\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(6),=C'E-PLPA'    E-PLPA range\n         HEX   LINE+10,4,SAVEPLPS\n         HEX   LINE+20,4,SAVEPLPE\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(28),DASHES28     Print row of dashes at the bottom\n         APUT  LINE,35\nGETLPRTE DS    0H\n         L     R9,SAVER9T\n         BR    R9\nDASHES28 DC    28C'-'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nPRTABLHD DS    0H\n         ST    R9,SAVER9U\n*                                 Print out table header\n         STM   R14,R1,SAVE1401    Now save registers 14 thru 1.\n         L     R1,TABLADDR        Load table start address.\n         MVC   DISPHDR(16),0(R1)  Move header info to display area.\n         ST    R1,HDRADDR         Store header address for alter\n         MVC   LINE,LINE-1        Clear line\n         MVC   LINE(15),=C'Table Header:  '  Move in title.\n         MVC   LINE+15(16),DISPHDR           Move in title info.\n         APUT  LINE,35\n         MVC   LINE,LINE-1        Clear line for next time\n         LM    R14,R1,SAVE1401    Restore  registers 14 thru 1.\n*-*\n         L     R9,SAVER9U\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n** ---------------------------------------------------------------- **\n**   When this routine is invoked, TABLADDR points to the start     **\n**    of the real table.                                            **\n** ---------------------------------------------------------------- **\nTESTLPA  DS    0H             Test if an address is in any LPA range\n         ST    R9,SAVER9W\n*-*-*->>                          Print the address out so we can see.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1        Clear line area.\n         MVC   LINE(16),=C'Table address:  '\n         HEX   LINE+20,4,TABLADDR     Display address in Hex\n         APUT  LINE,35\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n*-*-*->>\nTESLSTRT DS    0H\n         CLC   TABLADDR,SAVMLPAS      Smaller than MLPA start?\n         BL    TESLTST1\n         CLC   TABLADDR,SAVMLPAE      Larger than MLPA end?\n         BH    TESLTST1\n         OI    LPAFLAG,X'01'          In between, flag it and exit.\n         B     TESLMSG\nTESLTST1 DS    0H\n         CLC   TABLADDR,SAVFLPAS      Smaller than FLPA start?\n         BL    TESLTST2\n         CLC   TABLADDR,SAVFLPAE      Larger than FLPA end?\n         BH    TESLTST2\n         OI    LPAFLAG,X'01'          In between, flag it and exit.\n         B     TESLMSG\nTESLTST2 DS    0H\n         CLC   TABLADDR,SAVPLPAS      Smaller than PLPA start?\n         BL    TESLTST3\n         CLC   TABLADDR,SAVPLPAE      Larger than PLPA end?\n         BH    TESLTST3\n         OI    LPAFLAG,X'01'\n         B     TESLMSG                In between, flag it and exit.\nTESLTST3 DS    0H\n         CLC   TABLADDR,SAVEMLPS      Smaller than E-MLPA start?\n         BL    TESLTST4\n         CLC   TABLADDR,SAVEMLPE      Larger than E-MLPA end?\n         BH    TESLTST4\n         OI    LPAFLAG,X'01'          In between, flag it and exit.\n         B     TESLMSG\nTESLTST4 DS    0H\n         CLC   TABLADDR,SAVEFLPS      Smaller than E-FLPA start?\n         BL    TESLTST5\n         CLC   TABLADDR,SAVEFLPE      Larger than E-FLPA end?\n         BH    TESLTST5\n         OI    LPAFLAG,X'01'          In between, flag it and exit.\n         B     TESLMSG\nTESLTST5 DS    0H\n         CLC   TABLADDR,SAVEPLPS      Smaller than E-PLPA start?\n         BL    TESLMSG\n         CLC   TABLADDR,SAVEPLPE      Larger than E-PLPA end?\n         BH    TESLMSG\n         OI    LPAFLAG,X'01'          In between, flag it and exit.\n         B     TESLMSG\nTESLMSG  DS    0H\n*-*-*->>                          Message the result of the LPA test.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1        Clear line area.\n         TM    LPAFLAG,X'01'      Is the address within LPA?\n         BZ    TESLMSGA           No. Say not.\n         MVC   LINE(40),=C'Table address lies within an LPA region.'\n         B     TESLMSGP           Go send the message.\nTESLMSGA DS    0H\n         MVC   LINE(42),=C'Table address is not within an LPA region.'\nTESLMSGP DS    0H                 Send the message.\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n*-*-*->>\nTESLEND  DS    0H\n         L     R9,SAVER9W\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nCHANGEDL DS    0H                     Say table was in LPALIB so that\n*                                       therefore nothing was changed.\n         ST    R9,SAVER9V\n         TM    LPAFLAG,X'01'          Table was loaded in the LPALIB\n*                                      storage range. Can't change it.\n         BZ    CHANGEEN\n         APUT  MESSAG2E,L'MESSAG2E    Say that table was from LPALIB.\n         APUT  MESSAG2D,L'MESSAG2D    Say that nothing was changed.\nCHANGEEN DS    0H\n         L     R9,SAVER9V\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nENTRYDSP DS    0H\n         ST    R9,SAVER9X\n         TM    TIDFLAG,X'03'      PC or PP table?\n         BNZ   ENTRYEXI           Yes. No display here.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         L     R1,NTRYCNT\n         CVD   R1,CVDAREA\n         MVC   LINE+22(10),MASK10\n         ED    LINE+22(10),CVDAREA+3\n         MVC   LINE(24),=C'Non-blank table entries:'\n         MVC   LINE+35(25),=C'(these are the ones used)'\n         APUT  LINE,65\n         MVC   LINE,LINE-1\n         L     R1,BLNKCNT\n         CVD   R1,CVDAREA\n         MVC   LINE+22(10),MASK10\n         ED    LINE+22(10),CVDAREA+3\n         MVC   LINE(24),=C'Perceived blank entries:'\n         MVC   LINE+35(25),=C'(potential for expansion)'\n         APUT  LINE,65\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nENTRYEXI DS    0H\n         L     R9,SAVER9X\n         BR    R9\nENTRYDEN DS    0H\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n** ---------------------------------------------------------------- **\n**   Here are the rest of the constants for the program.            **\n** ---------------------------------------------------------------- **\nBLKSTRNG DC    XL10'00004040404040404040'\nENDSTRNG DC    XL10'FFFF4040404040404040'\nZEROES8  DC    X'0000000000000000'\nMASK10   DC    XL10'40202020202020202120'\n         DC    C' '\nBLANKS   DC    C'                                            '\nQUEST08  DC    C'?       '     Nullify table entry without terminating\nMESSAGET DC    C'TSUB Command - Display/Change USERID Auth Table Entry -\n               - xxxxxxxx'\nMESSAGEU DC    C'---- -------   ------- ------ ------ ---- ----- ----- -\n                 --------'\nMESSAGEC DC    C'  **--------   AFTER MAKING CHANGES   -------**'\nMESSAGED DC    C'  **--- STATE BEFORE MAKING TABLE CHANGES ---**'\nMESSAG1A DC    C'Table XX pointed to by the LWA has length available. H+\n               ex xxxx '\nMESSAG1B DC    C'Table XX pointed to by the LWA has no lengths. Blanks +\n               will delimit.'\nMESSAG1C DC    C'Table XX pointed to by the LWA came from an APF STEPLI+\n               B.'\nMESSAG1D DC    C'Table XX pointed to by the LWA did not come from an AP+\n               F STEPLIB.'\nMESSAG2C DC    C'Command was not invoked APF authorized.'\nMESSAG2D DC    C'Nothing was changed.  '\nMESSAG2E DC    C'Table is in LPALIB, and we will not attempt to alter i+\n               t.'\nMESSAG3A DC    C'Slot      in XX table has been changed to         .'\nMESSAG3B DC    C'Slot      in XX table has been blanked.            '\nMESSAG3C DC    C'                                                      +\n                  '\nMESSAG3D DC    C'Last 8 bytes of table header altered to \" PARMLIB\". '\nMESSAG3E DC    C'LWA size for table    has been changed from Hex xxxx t+\n               o Hex xxxx.'\nMESSAG3F DC    C'LWA size for table    is now Hex xxxx. '\nMESSAG3G DC    C'Slot      in XX table has been nullified.          '\nMESSA11A DC    C'  Supply a table code TT, followed by an action code A-\n               .'\nMESSA11B DC    C'Supply a program name, as the next parameter.   '\nMESSA11C DC    C'Valid table  codes are:  E2, E8, AP, NS, PC, PP. '\nMESSA11D DC    C'Valid action codes are:  R - replace, B - blank, D - d-\n               isplay,'\nMESSA11Z DC    C'  H - header, L - supply full table length, Z - zero t-\n               able length,'\nMESSA11Y DC    C'  S - mark table from STEPLIB, P - mark table from PAR-\n               MLIB,'\nMESSA11X DC    C'  X - display LPA storage ranges, M - supply minimum t-\n               able length.'\nMESSA11W DC    C'  N - nullify a single entry without invalidating subs-\n               equent entries.'\nMESSA11E DC    C'Please supply a program name.  '\nMESSA11F DC    C'Full command is in the form TTA, TT=table code, A=acti-\n               on code.'\nMESSA11G DC   C'Please supply slot number to change, and program name.'\nMESSA11I DC    C'If D (display) is followed by a slot number, only that-\n                slot is shown.'\nMESSA11J DC    C'R (replace) requires a slot number, followed by a prog-\n               ram name.'\nMESSA11K DC    C'If D is not followed by a number, then the entire tabl-\n               e is displayed.'\nMESSA11L DC    C'  Instructions to use this program:                  '\nMESSA11M DC    C'  ------------ -- --- ---- -------                   '\nMESSA11N DC    C'B (blank) blanks the slot number given. Higher slots a-\n               re invalidated.'\nMESSA11R DC    C'N (nullify) invalidates that slot number. Higher slots-\n                remain valid.'\nMESSA11O DC    C'D does not need APF authorization. All other codes req-\n               uire it.'\nMESSA11P DC    C'TSUB TTA nnn pgmname (nnn optional for D, both require-\n               d for R)'\nMESSA11Q DC    C'Codes: D,H,L,M,Z,P,S,X do not require extra parameters-\n               .'\nMESSA12Q DC    C'Please supply slot number to blank out. BE CAREFUL !'\nMESSAGR0 DC    C'Return Code = 0 '\nMESSAGR4 DC    C'Return Code = 4 '\nMESSAGR8 DC    C'Return Code = 8 '\nMESSAGRC DC    C'Return Code = 12'\nMESSDIAG DC    C'                                            '\nMESSAGEP DC    C'No Parmlib-supplied XX table was found in storage. '\nMESSAGEN DC    C'Supplied character        was not numeric. '\n         SPACE 3\n         LTORG\n         SPACE 3\nCVDAREA  DS    D                   For CVD instruction\nSAVEAPUT DS    2D\nSAVER23  DS    2F                  Save pair of regs R2, R3\nSAVER1A  DS    F                   Save R1 here\nSAVER1B  DS    F                   Save R1 here\nSAVER1C  DS    F                   Save R1 here\nSAVER2A  DS    F                   Save R2 here\nSAVER2B  DS    F                   Save R2 here\nSAVER2C  DS    F                   Save R2 here\nSAVER2D  DS    F                   Save R2 here\nSAVER2E  DS    F                   Save R2 here\nSAVER2F  DS    F                   Save R2 here\nSAVER2G  DS    F                   Save R2 here\nSAVER3A  DS    F                   Save R3 here\nSAVER3B  DS    F                   Save R3 here\nSAVER3C  DS    F                   Save R3 here\nSAVER4A  DS    F                   Save R4 here\nSAVER4B  DS    F                   Save R4 here\nSAVER4C  DS    F                   Save R4 here\nSAVER5A  DS    F                   Save R5 here\nSAVER5B  DS    F                   Save R5 here\nSAVER5C  DS    F                   Save R5 here\nSAVER5D  DS    F                   Save R5 here\nSAVER5E  DS    F                   Save R5 here\nSAVER5F  DS    F                   Save R5 here\nSAVER8A  DS    F                   Save R8 here\nSAVER9A  DS    F                   BAL Register Save Area\nSAVER9B  DS    F                   BAL Register Save Area\nSAVER9C  DS    F                   BAL Register Save Area\nSAVER9D  DS    F                   BAL Register Save Area\nSAVER9E  DS    F                   BAL Register Save Area\nSAVER9F  DS    F                   BAL Register Save Area\nSAVER9G  DS    F                   BAL Register Save Area\nSAVER9H  DS    F                   BAL Register Save Area\nSAVER9I  DS    F                   BAL Register Save Area\nSAVER9J  DS    F                   BAL Register Save Area\nSAVER9K  DS    F                   BAL Register Save Area\nSAVER9L  DS    F                   BAL Register Save Area\nSAVER9M  DS    F                   BAL Register Save Area\nSAVER9N  DS    F                   BAL Register Save Area\nSAVER9O  DS    F                   BAL Register Save Area\nSAVER9P  DS    F                   BAL Register Save Area\nSAVER9Q  DS    F                   BAL Register Save Area\nSAVER9R  DS    F                   BAL Register Save Area\nSAVER9S  DS    F                   BAL Register Save Area\nSAVER9T  DS    F                   BAL Register Save Area\nSAVER9U  DS    F                   BAL Register Save Area\nSAVER9V  DS    F                   BAL Register Save Area\nSAVER9W  DS    F                   BAL Register Save Area\nSAVER9X  DS    F                   BAL Register Save Area\nSAVER9Y  DS    F                   BAL Register Save Area\nCMBUFEND DS    F                   Number of bytes to end of cmd buff\nSAVLSLOT DS    F                   Save place where Key 0 will change\nSLOTBIN  DS    F                   Fullword binary value of slot number\nSLOTNOW  DS    F                   Slot number being searched\nDISPREG  DS    F                   DISPLAY\nCMBUFAD  DS    F                   Command Buffer address\nCHARSTRT DS    F                   Address of first parm character\nCHARCONT DS    F                   Address of next parm character\nCHARSIZE DS    F\nOURSLOT  DS    F                   Address of current slot searched\nFOUNSLOT DS    F\nTABLEND  DS    F                   Estimated or real end addr of table\n* --- >\nTABLSTRT DS    F                   Start address of table\nTABLADDR DS    F                   Store address of current table\nTABLENUM DS    F                   Number of entries in table\nTABLESIZ DS    F                   Size of a table entry\n* --- >\nBLNKCNT  DS    F\nNTRYCNT  DS    F\n* --- >\nOFFSETSV DS    F\nWORKA    DC    D'0'                Work area for CVB\nNUMVSTRT DC    X'00'               Character count of first parm\nNUMCOUTL DC    X'00'               Entered first parm length\nCODEPLAC DS    CL2                 Store entered table code here\nPAD01    DS    CL4                 Filler\nSAVECHAR DS    X\nSAVECH08 DS    X\nMEASFLG  DS    X\nSHBLFLG  DS    X\nOFFFLAG  DS    X                   What function are we doing?\nOFFFLAG1 DS    X                   Extra function flag\nOLDFLAG  DS    X                   Old system detected if X'01'\nTIDFLAG  DS    X                   Which table are we handling.\nLPAFLAG  DS    X                   Is the table address in the LPA?\nLPADFLG  DS    X                   Do LPA range display.\nPLATFLG  DS    X                   FCVE or PPVE exist.\nHAVLFLG  DS    X                   Have length of table available\nNSCHFLG  DS    X                   Dealing the 10-byte NS table?\nLWAPFLG  DS    X                   LWAPRMLB flag copied into program\n*              X'80'               LWATAPST TAP came from STEPLIB\n*              X'40'               LWATNSST TNS came from STEPLIB\n*              X'20'               LWATE2ST TE2 came from STEPLIB\n*              X'10'               LWATE8ST TE8 came from STEPLIB\nLWAMFLG  DS    X                   Which tables have a size in the LWA.\n*              X'80'               AP has a size in the LWA.\n*              X'40'               NS has a size in the LWA.\n*              X'20'               E2 has a size in the LWA.\n*              X'10'               E8 has a size in the LWA.\nFLAGZ    DS    X\n*              X'01'               Found a blank entry. End table srch.\n*              X'02'               Parm number is past the end of table\n*              X'04'               Table lengths have been supplied.\nPAD02    DS    CL4                 Filler\nFSTNAME  DC    CL8' '              Entered program name for \"Replace\"\nFSTCOUNT DS    F                   Number of characters in FSTNAME\nFSTCHALF DC    H'0'\nPAD03    DS    CL4                 Filler\nTABENNUM DC    CL10' '\nPAD03A   DS    CL4                 Filler\nFSTFIELD DS    0CL8\nFSTNUME  DC    CL5' '\nFSTNUPAD DC    CL3' '\nFSTNOUNT DS    F                   Number of characters in FSTNAME\nFSTNHALF DC    H'0'\nPAD04    DS    CL4                 Filler\nSLOTSAVE DS    CL10\nPAD05    DS    CL4                 Filler\nSNDNAME  DC    CL8' '\nSNDCOUNT DS    F                   Number of characters in SNDNAME\nSNDCHALF DC    H'0'\nTABCODE  DC    CL8' '              Original OUTLIM character\n         DS    CL7                 PADDING\nDISPHDR  DS    CL16                Table header display area\n         DS    CL1\nHDRADDR  DS    F                   Address of table header\nCMDBCOPY DS    CL252\n         DS    CL128               PADDING\n         DS    0F                  ALIGN ON FULLWORD\nLINEB    DS    C                   LINE-1\nLINE     DS    CL137               Output line area\nLINET    EQU   LINE+7              Indented line\nLINAB    DS    C                   LINE-1\nLINA     DS    CL137               Output line area\nLINAT    EQU   LINA+7              Indented line\nTRTPGMNM DC    X'02020202020202020202020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'40020202020202020202020202020202'\n         DC    X'02020202020202020202025B02020202'\n         DC    X'0202020202020202020202020202026F'\n         DC    X'02020202020202020202027B7C020202'\n         DC    X'02C1C2C3C4C5C6C7C8C9020202020202'\n         DC    X'02D1D2D3D4D5D6D7D8D9020202020202'\n         DC    X'0202E2E3E4E5E6E7E8E9020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'02C1C2C3C4C5C6C7C8C9020202020202'\n         DC    X'02D1D2D3D4D5D6D7D8D9020202020202'\n         DC    X'0202E2E3E4E5E6E7E8E9020202020202'\n         DC    X'02020202020202020202020202020202'\n         SPACE\n         IKJCPPL\n         IKJPSCB\n         CVT      LIST=YES,DSECT=YES\n         IKJTSVT\n         IKJEFLWA\n         END\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUEMNTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   128                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         EJECT\n         IHAPSA   LIST=YES                                     HD APR88\n         EJECT                                                 HD APR88\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   14,12,12(13)       SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES            RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    1,8(13)            OUR SAVE AREA POINTER\n         ST    13,4(1)            POINTER TO CALLERS SAVE AREA\n         LR    13,1               @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(R13)         POINT TO CALLERS RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 ASSUME BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 ASSUME BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(RML)               MESSAGE LENGTH\n         STH   R15,PUTLEN                 PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    2,R13                    @OUR SAVE AREA\n         LR    3,R15                    SAVE RETURN CODE\n         L     R13,4(R13)               @CALLERS SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,3                    RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END   EPUTL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSUB$": {"ttr": 22532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x000\\x01\\x055O\\x01\\x160O\\x115\\x00\\x1c\\x00\\x1d\\x00\\x00\\xc1\\xe2\\xd4\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2005-12-20T00:00:00", "modifydate": "2016-10-30T11:35:30", "lines": 28, "newlines": 29, "modlines": 0, "user": "ASMJCL"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.B.ASM\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(TSUB)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,9),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(1)\n ENTRY   TSUB\n NAME    TSUB(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSUB#01": {"ttr": 22534, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x13\\x01\\t\\x04\\x8f\\x01\\x19!/\\x14\\x11\\x005\\x00/\\x00\\x00\\xc5\\xe7\\xc1\\xd4\\xd7\\xd3\\xc5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2009-02-17T00:00:00", "modifydate": "2019-07-31T14:11:13", "lines": 53, "newlines": 47, "modlines": 0, "user": "EXAMPLE"}, "text": "Output of command:  TSUB E8D\n\n     This is from a userid that took its tables from PARMLIB.\n     Note the messages below, to that effect.\n\n\nTSUB Command - Display/Change USERID Auth Table Entry - Ver 1.40\n---- -------   ------- ------ ------ ---- ----- -----   --------\nE8D   04     Program table code + Function code\nTable address:      0000B3E8\nTable address is not within an LPA region.\nNon-blank table entries:      33   (these are the ones used)\nPerceived blank entries:       1   (potential for expansion)\nTable E8 pointed to by the LWA has length available. Hex 0120.\nTable E8 pointed to by the LWA did not come from an APF STEPLIB.\nTable Header:  IKJEFTE8 PARMLIB\nNumber of valid entries:      34\nE8 Table Entry Number:         1  ICHUT100\nE8 Table Entry Number:         2  ICHUT200\nE8 Table Entry Number:         3  ICHUT400\nE8 Table Entry Number:         4  ICHDSM00\nE8 Table Entry Number:         5  IRRDSC00\nE8 Table Entry Number:         6  IRRUT100\nE8 Table Entry Number:         7  IRRUT200\nE8 Table Entry Number:         8  IRRUT400\nE8 Table Entry Number:         9  IRRDPI00\nE8 Table Entry Number:        10  CSFDAUTH\nE8 Table Entry Number:        11  ICADCT\nE8 Table Entry Number:        12  ICADDCT\nE8 Table Entry Number:        13  ICADCFGS\nE8 Table Entry Number:        14  ICADPFTP\nE8 Table Entry Number:        15  ICADFTPD\nE8 Table Entry Number:        16  ICADSLOG\nE8 Table Entry Number:        17  ICADSOCK\nE8 Table Entry Number:        18  ICADSOXD\nE8 Table Entry Number:        19  ICADSTAK\nE8 Table Entry Number:        20  ICADIKED\nE8 Table Entry Number:        21  IEBCOPY\nE8 Table Entry Number:        22  IOEGRWAG\nE8 Table Entry Number:        23  IOENEWAG\nE8 Table Entry Number:        24  IOESALVG\nE8 Table Entry Number:        25  IOEBAK\nE8 Table Entry Number:        26  IOEBOS\nE8 Table Entry Number:        27  IOECM\nE8 Table Entry Number:        28  IOEDCEER\nE8 Table Entry Number:        29  IOEDFSXP\nE8 Table Entry Number:        30  IOEFTS\nE8 Table Entry Number:        31  IOEMAPID\nE8 Table Entry Number:        32  IOESCOUT\nE8 Table Entry Number:        33  IOEUDBG\nE8 Table Entry Number:        34  *empty*\n\nReturn Code = 0\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSUB#02": {"ttr": 22536, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00!\\x01\\t\\x04\\x8f\\x01\\x19!/\\x14\\x11\\x00\\x18\\x00\\x05\\x00\\x00\\xc5\\xe7\\xc1\\xd4\\xd7\\xd3\\xc5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2009-02-17T00:00:00", "modifydate": "2019-07-31T14:11:21", "lines": 24, "newlines": 5, "modlines": 0, "user": "EXAMPLE"}, "text": "Output of command:  TSUB APD\n\n     This was from a userid that loaded its tables from PARMLIB.\n     See messages below, in the command output.\n\nTSUB Command - Display/Change USERID Auth Table Entry - Ver 1.40\n---- -------   ------- ------ ------ ---- ----- -----   --------\nAPD   04     Program table code + Function code\nTable address:      0000B7E0\nTable address is not within an LPA region.\nNon-blank table entries:       5   (these are the ones used)\nPerceived blank entries:       1   (potential for expansion)\nTable AP pointed to by the LWA has length available. Hex 0040.\nTable AP pointed to by the LWA did not come from an APF STEPLIB.\nTable Header:  IKJEFTAP PARMLIB\nNumber of valid entries:       6\nAP Table Entry Number:         1  CSFDAUTH\nAP Table Entry Number:         2  LWATMGR\nAP Table Entry Number:         3  IEBCOPY\nAP Table Entry Number:         4  ICQASLI0\nAP Table Entry Number:         5  IKJEFF76\nAP Table Entry Number:         6  *empty*\n\nReturn Code = 0\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSUB#03": {"ttr": 22538, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00)\\x01\\t\\x04\\x8f\\x01\\x19!/\\x14\\x11\\x01<\\x00\\x08\\x00\\x00\\xc5\\xe7\\xc1\\xd4\\xd7\\xd3\\xc5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2009-02-17T00:00:00", "modifydate": "2019-07-31T14:11:29", "lines": 316, "newlines": 8, "modlines": 0, "user": "EXAMPLE"}, "text": "Output of command:  TSUB E2D\n\n    This was on a userid where there was an APF-authorized STEPLIB\n    library that had an IKJTABLS load library assembled from the\n    example on File 185 called ASMTABLS.  Note the message in TSUB\n    to that effect.\n\n\nTSUB Command - Display/Change USERID Auth Table Entry - Ver 1.40\n---- -------   ------- ------ ------ ---- ----- -----   --------\nE2D   04     Program table code + Function code\nTable address:      0000C000\nTable address is not within an LPA region.\nNon-blank table entries:     294   (these are the ones used)\nPerceived blank entries:      30   (potential for expansion)\nTable E2 pointed to by the LWA has no lengths. Blanks will delimit.\nTable E2 pointed to by the LWA came from an APF STEPLIB.\nTable Header:  IKJEFTE276.152\nNumber of valid entries:     295\nE2 Table Entry Number:         1  $$\nE2 Table Entry Number:         2  $HOWMVS\nE2 Table Entry Number:         3  $MDSMAIN\nE2 Table Entry Number:         4  ABUDSN\nE2 Table Entry Number:         5  AD\nE2 Table Entry Number:         6  ADB2UTIL\nE2 Table Entry Number:         7  ADDDIR\nE2 Table Entry Number:         8  ADDFILE\nE2 Table Entry Number:         9  ADDGROUP\nE2 Table Entry Number:        10  ADDSD\nE2 Table Entry Number:        11  ADDUSER\nE2 Table Entry Number:        12  ADIR\nE2 Table Entry Number:        13  ADNR\nE2 Table Entry Number:        14  ADYOPCMD\nE2 Table Entry Number:        15  AF\nE2 Table Entry Number:        16  AG\nE2 Table Entry Number:        17  AHOWMVS\nE2 Table Entry Number:        18  ALD\nE2 Table Entry Number:        19  ALF\nE2 Table Entry Number:        20  ALG\nE2 Table Entry Number:        21  ALTDIR\nE2 Table Entry Number:        22  ALTDSD\nE2 Table Entry Number:        23  ALTER\nE2 Table Entry Number:        24  ALTFILE\nE2 Table Entry Number:        25  ALTGROUP\nE2 Table Entry Number:        26  ALTUSER\nE2 Table Entry Number:        27  ALU\nE2 Table Entry Number:        28  APCACBL\nE2 Table Entry Number:        29  APCANB\nE2 Table Entry Number:        30  APCARB\nE2 Table Entry Number:        31  APCAUB\nE2 Table Entry Number:        32  APFCMD\nE2 Table Entry Number:        33  ASUB\nE2 Table Entry Number:        34  AU\nE2 Table Entry Number:        35  BACKUP\nE2 Table Entry Number:        36  BCMDEL\nE2 Table Entry Number:        37  BCMDEL1\nE2 Table Entry Number:        38  BCMNAUTH\nE2 Table Entry Number:        39  BCMNUPD\nE2 Table Entry Number:        40  BDATA\nE2 Table Entry Number:        41  BDMNUPD\nE2 Table Entry Number:        42  BINDDATA\nE2 Table Entry Number:        43  BLKUPD\nE2 Table Entry Number:        44  BUDDSN\nE2 Table Entry Number:        45  BUDGET\nE2 Table Entry Number:        46  CAE$BQRY\nE2 Table Entry Number:        47  CANCELU\nE2 Table Entry Number:        48  CAS9UDTN\nE2 Table Entry Number:        49  CDELPAIR\nE2 Table Entry Number:        50  CDMRSTAT\nE2 Table Entry Number:        51  CDSCB\nE2 Table Entry Number:        52  CESTPAIR\nE2 Table Entry Number:        53  CHKPT\nE2 Table Entry Number:        54  CINMX\nE2 Table Entry Number:        55  CLCHECK\nE2 Table Entry Number:        56  CNVTCAT\nE2 Table Entry Number:        57  CO\nE2 Table Entry Number:        58  COFDMON\nE2 Table Entry Number:        59  CONNECT\nE2 Table Entry Number:        60  CONSPROF\nE2 Table Entry Number:        61  CPSCB\nE2 Table Entry Number:        62  CQUERYSG\nE2 Table Entry Number:        63  CRECOVER\nE2 Table Entry Number:        64  CSCAN\nE2 Table Entry Number:        65  CSUSPEND\nE2 Table Entry Number:        66  DCAS\nE2 Table Entry Number:        67  DD\nE2 Table Entry Number:        68  DDIR\nE2 Table Entry Number:        69  DEF\nE2 Table Entry Number:        70  DEFINE\nE2 Table Entry Number:        71  DEL\nE2 Table Entry Number:        72  DELDIR\nE2 Table Entry Number:        73  DELDSD\nE2 Table Entry Number:        74  DELETE\nE2 Table Entry Number:        75  DELFILE\nE2 Table Entry Number:        76  DELGROUP\nE2 Table Entry Number:        77  DELUSER\nE2 Table Entry Number:        78  DF\nE2 Table Entry Number:        79  DG\nE2 Table Entry Number:        80  DITTO\nE2 Table Entry Number:        81  DITTOA\nE2 Table Entry Number:        82  DITTOU\nE2 Table Entry Number:        83  DMRSHR\nE2 Table Entry Number:        84  DRI\nE2 Table Entry Number:        85  DU\nE2 Table Entry Number:        86  ERWMAUTH\nE2 Table Entry Number:        87  EX\nE2 Table Entry Number:        88  EXP\nE2 Table Entry Number:        89  EXPORT\nE2 Table Entry Number:        90  EYU9XENF\nE2 Table Entry Number:        91  EZAZSSI\nE2 Table Entry Number:        92  EZBREINI\nE2 Table Entry Number:        93  EZBTNINI\nE2 Table Entry Number:        94  FCESTABL\nE2 Table Entry Number:        95  FCQUERY\nE2 Table Entry Number:        96  FCWITHDR\nE2 Table Entry Number:        97  FTPD\nE2 Table Entry Number:        98  FTPDNS\nE2 Table Entry Number:        99  GJTRUCBS\nE2 Table Entry Number:       100  IEBCOPY\nE2 Table Entry Number:       101  IKJEHDSF\nE2 Table Entry Number:       102  IKJEHDS1\nE2 Table Entry Number:       103  IKJPRMLB\nE2 Table Entry Number:       104  IM\nE2 Table Entry Number:       105  IMP\nE2 Table Entry Number:       106  IMPORT\nE2 Table Entry Number:       107  IOBSNMP\nE2 Table Entry Number:       108  IQIEXPN\nE2 Table Entry Number:       109  IQIMAIN\nE2 Table Entry Number:       110  IQIQUERY\nE2 Table Entry Number:       111  IQIQUIT\nE2 Table Entry Number:       112  IRRDPI00\nE2 Table Entry Number:       113  ISPICP\nE2 Table Entry Number:       114  ISRPCP\nE2 Table Entry Number:       115  LBADV\nE2 Table Entry Number:       116  LBAGENT\nE2 Table Entry Number:       117  LD\nE2 Table Entry Number:       118  LDATA\nE2 Table Entry Number:       119  LDIR\nE2 Table Entry Number:       120  LDIRECT\nE2 Table Entry Number:       121  LF\nE2 Table Entry Number:       122  LFILE\nE2 Table Entry Number:       123  LG\nE2 Table Entry Number:       124  LISTB\nE2 Table Entry Number:       125  LISTBC\nE2 Table Entry Number:       126  LISTD\nE2 Table Entry Number:       127  LISTDATA\nE2 Table Entry Number:       128  LISTDS\nE2 Table Entry Number:       129  LISTDSD\nE2 Table Entry Number:       130  LISTGRP\nE2 Table Entry Number:       131  LISTUSER\nE2 Table Entry Number:       132  LLWA\nE2 Table Entry Number:       133  LMRKTSO\nE2 Table Entry Number:       134  LOCKTERM\nE2 Table Entry Number:       135  LOOK\nE2 Table Entry Number:       136  LPQ\nE2 Table Entry Number:       137  LPR\nE2 Table Entry Number:       138  LPRM\nE2 Table Entry Number:       139  LPROC\nE2 Table Entry Number:       140  LSLT\nE2 Table Entry Number:       141  LU\nE2 Table Entry Number:       142  LWATMGR\nE2 Table Entry Number:       143  MAKEUSER\nE2 Table Entry Number:       144  MIMTSO\nE2 Table Entry Number:       145  MODDVIPA\nE2 Table Entry Number:       146  MU\nE2 Table Entry Number:       147  MVPMAIN\nE2 Table Entry Number:       148  MVPXDISP\nE2 Table Entry Number:       149  MVSCPCMD\nE2 Table Entry Number:       150  NAMEDXFR\nE2 Table Entry Number:       151  NAMED4\nE2 Table Entry Number:       152  NDVRC1\nE2 Table Entry Number:       153  NETSTAT\nE2 Table Entry Number:       154  NSUPDATE\nE2 Table Entry Number:       155  NSUPDAT4\nE2 Table Entry Number:       156  NYPPW\nE2 Table Entry Number:       157  OC\nE2 Table Entry Number:       158  OMPROUTE\nE2 Table Entry Number:       159  OP\nE2 Table Entry Number:       160  OPER\nE2 Table Entry Number:       161  OPERATOR\nE2 Table Entry Number:       162  OPINFO\nE2 Table Entry Number:       163  OPING\nE2 Table Entry Number:       164  OPSCMD\nE2 Table Entry Number:       165  OPSCONSL\nE2 Table Entry Number:       166  OPSOSCMD\nE2 Table Entry Number:       167  OPSPARM\nE2 Table Entry Number:       168  OPSREPLY\nE2 Table Entry Number:       169  OPSTAT\nE2 Table Entry Number:       170  OPSWTO\nE2 Table Entry Number:       171  OSNMPD\nE2 Table Entry Number:       172  OTRACERT\nE2 Table Entry Number:       173  PACKRAT\nE2 Table Entry Number:       174  PARMLIB\nE2 Table Entry Number:       175  PASSWORD\nE2 Table Entry Number:       176  PDIR\nE2 Table Entry Number:       177  PDSCLEAN\nE2 Table Entry Number:       178  PDSEAUTH\nE2 Table Entry Number:       179  PE\nE2 Table Entry Number:       180  PERMDIR\nE2 Table Entry Number:       181  PERMFILE\nE2 Table Entry Number:       182  PERMIT\nE2 Table Entry Number:       183  PF\nE2 Table Entry Number:       184  PHRASE\nE2 Table Entry Number:       185  PING\nE2 Table Entry Number:       186  POPPER\nE2 Table Entry Number:       187  PRINT\nE2 Table Entry Number:       188  PW\nE2 Table Entry Number:       189  Q\nE2 Table Entry Number:       190  QUEUE\nE2 Table Entry Number:       191  Q522\nE2 Table Entry Number:       192  RACDCERT\nE2 Table Entry Number:       193  RACFSIM\nE2 Table Entry Number:       194  RACLINK\nE2 Table Entry Number:       195  RACONVRT\nE2 Table Entry Number:       196  RACPRIV\nE2 Table Entry Number:       197  RALT\nE2 Table Entry Number:       198  RALTER\nE2 Table Entry Number:       199  RDEF\nE2 Table Entry Number:       200  RDEFINE\nE2 Table Entry Number:       201  RDEL\nE2 Table Entry Number:       202  RDELETE\nE2 Table Entry Number:       203  RE\nE2 Table Entry Number:       204  RECEIVE\nE2 Table Entry Number:       205  RELOGON\nE2 Table Entry Number:       206  REMOVE\nE2 Table Entry Number:       207  REPRO\nE2 Table Entry Number:       208  RESOLVE\nE2 Table Entry Number:       209  REVIEW\nE2 Table Entry Number:       210  REVVSAM\nE2 Table Entry Number:       211  REXCPCMD\nE2 Table Entry Number:       212  RL\nE2 Table Entry Number:       213  RLIST\nE2 Table Entry Number:       214  RLOAD\nE2 Table Entry Number:       215  RLOADA\nE2 Table Entry Number:       216  RMM\nE2 Table Entry Number:       217  RPF\nE2 Table Entry Number:       218  RPFE\nE2 Table Entry Number:       219  RSH\nE2 Table Entry Number:       220  RSHD\nE2 Table Entry Number:       221  RVARY\nE2 Table Entry Number:       222  SAMENDM\nE2 Table Entry Number:       223  SDSF\nE2 Table Entry Number:       224  SE\nE2 Table Entry Number:       225  SEARCH\nE2 Table Entry Number:       226  SECURE\nE2 Table Entry Number:       227  SEND\nE2 Table Entry Number:       228  SETC\nE2 Table Entry Number:       229  SETCACHE\nE2 Table Entry Number:       230  SETPASSW\nE2 Table Entry Number:       231  SETPW\nE2 Table Entry Number:       232  SETPW2\nE2 Table Entry Number:       233  SETR\nE2 Table Entry Number:       234  SETROPTS\nE2 Table Entry Number:       235  SETUSER\nE2 Table Entry Number:       236  SHCDS\nE2 Table Entry Number:       237  SM\nE2 Table Entry Number:       238  SMTP\nE2 Table Entry Number:       239  SNTPD\nE2 Table Entry Number:       240  SPACE\nE2 Table Entry Number:       241  SPY\nE2 Table Entry Number:       242  SR\nE2 Table Entry Number:       243  SRDIR\nE2 Table Entry Number:       244  SRF\nE2 Table Entry Number:       245  SRFILE\nE2 Table Entry Number:       246  SRSTAT\nE2 Table Entry Number:       247  STEPLIB\nE2 Table Entry Number:       248  STEPLIBN\nE2 Table Entry Number:       249  SU\nE2 Table Entry Number:       250  SYNC\nE2 Table Entry Number:       251  SYSPROG\nE2 Table Entry Number:       252  TEAEXTSO\nE2 Table Entry Number:       253  TERM\nE2 Table Entry Number:       254  TERMINAL\nE2 Table Entry Number:       255  TESTA\nE2 Table Entry Number:       256  TESTAUTH\nE2 Table Entry Number:       257  TMONCICS\nE2 Table Entry Number:       258  TMONDB2\nE2 Table Entry Number:       259  TMONIMS\nE2 Table Entry Number:       260  TMONMVS\nE2 Table Entry Number:       261  TRACERTE\nE2 Table Entry Number:       262  TRANSMIT\nE2 Table Entry Number:       263  TRAPFWD\nE2 Table Entry Number:       264  TRMD\nE2 Table Entry Number:       265  TSOENQ\nE2 Table Entry Number:       266  TSOSMS\nE2 Table Entry Number:       267  TSUB\nE2 Table Entry Number:       268  UKEYCSA\nE2 Table Entry Number:       269  USAT\nE2 Table Entry Number:       270  USIT\nE2 Table Entry Number:       271  USOT\nE2 Table Entry Number:       272  USUT\nE2 Table Entry Number:       273  VERIFY\nE2 Table Entry Number:       274  VFY\nE2 Table Entry Number:       275  VIEWUSER\nE2 Table Entry Number:       276  VLFNOTE\nE2 Table Entry Number:       277  VMCF\nE2 Table Entry Number:       278  VU\nE2 Table Entry Number:       279  WAITT\nE2 Table Entry Number:       280  WHOENQ\nE2 Table Entry Number:       281  WSSTAT\nE2 Table Entry Number:       282  XD\nE2 Table Entry Number:       283  XDCCALLA\nE2 Table Entry Number:       284  XDCCMDA\nE2 Table Entry Number:       285  XF\nE2 Table Entry Number:       286  XMDSMAIN\nE2 Table Entry Number:       287  XMIT\nE2 Table Entry Number:       288  XTRCUSER\nE2 Table Entry Number:       289  XU\nE2 Table Entry Number:       290  YKCONMSG\nE2 Table Entry Number:       291  ZAP\nE2 Table Entry Number:       292  ZAP$\nE2 Table Entry Number:       293  ZAPLWA\nE2 Table Entry Number:       294  ZAPV\nE2 Table Entry Number:       295  *empty*\n\nReturn Code = 0\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSUB#04": {"ttr": 22544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x006\\x01\\t\\x04\\x8f\\x01\\x19!/\\x14\\x11\\x00\\x1e\\x00\\t\\x00\\x00\\xc5\\xe7\\xc1\\xd4\\xd7\\xd3\\xc5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2009-02-17T00:00:00", "modifydate": "2019-07-31T14:11:36", "lines": 30, "newlines": 9, "modlines": 0, "user": "EXAMPLE"}, "text": "Output of command:  TSUB E2R 295 CQX\n\n     This command replaces the former contents of slot 294, which\n     had been empty, with the program name entry CQX.  This has the\n     effect of allowing execution of the CQX command as an APF\n     authorized program.\n\n\nTSUB Command - Display/Change USERID Auth Table Entry - Ver 1.40\n---- -------   ------- ------ ------ ---- ----- -----   --------\n\n  **--- STATE BEFORE MAKING TABLE CHANGES ---**\nE2R   01     Program table code + Function code\n295          Entry slot number\n00000003     Length of command\nCQX          New program name\nTable address:      0000C000\nTable address is not within an LPA region.\nNon-blank table entries:     294   (these are the ones used)\nPerceived blank entries:      30   (potential for expansion)\nTable E2 pointed to by the LWA has no lengths. Blanks will delimit.\nTable E2 pointed to by the LWA came from an APF STEPLIB.\nTable Header:  IKJEFTE276.152\nNumber of valid entries:     295\nE2 Table Entry Number:       295  *empty*\n\n  **--------   AFTER MAKING CHANGES   -------**\nSlot  295 in E2 table has been changed to CQX     .\n\nReturn Code = 0\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSUB#05": {"ttr": 22785, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00C\\x01\\t\\x04\\x8f\\x01\\x19!/\\x14\\x11\\x01U\\x00\\x08\\x00\\x00\\xc5\\xe7\\xc1\\xd4\\xd7\\xd3\\xc5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2009-02-17T00:00:00", "modifydate": "2019-07-31T14:11:43", "lines": 341, "newlines": 8, "modlines": 0, "user": "EXAMPLE"}, "text": "Output of command:  TSUB E2L   (compare TSUB E2M - example TSUB#06)\n\n     This command measures the length of the IKJEFTE2 table in\n     the user's address space, to (and including) all trailing blank\n     table entries.  Then that length is plugged into the LWA field\n     which is supposed to contain the length of the IKJEFTE2 table.\n     The messages below, tell you what happened.  Another TSUB E2D\n     command will tell you the resulting state of the E2 table.\n\n\nTSUB Command - Display/Change USERID Auth Table Entry - Ver 1.40\n---- -------   ------- ------ ------ ---- ----- -----   --------\n\n  **--- STATE BEFORE MAKING TABLE CHANGES ---**\nE2L   10     Program table code + Function code\nTable address:      0000C000\nTable address is not within an LPA region.\nNon-blank table entries:     295   (these are the ones used)\nPerceived blank entries:      29   (potential for expansion)\nTable E2 pointed to by the LWA has no lengths. Blanks will delimit.\nTable E2 pointed to by the LWA came from an APF STEPLIB.\nTable Header:  IKJEFTE276.152\nNumber of valid entries:     296\n\n  **--------   AFTER MAKING CHANGES   -------**\nLWA size for table E2 has been changed from Hex 0000 to Hex 0A30.\nTable E2 pointed to by the LWA has length available. Hex 0A30.\n\nReturn Code = 0\n\n-----------------------------------------------------------------\n\nTSUB Command - Display or Change Auth Table or Entry\n---- -------   ------- -- ------ ---- ----- -- -----\nE2D   04     Program table code + Function code\nTable address:      0000C000\nTable address is not within an LPA region.\nNon-blank table entries:     295   (these are the ones used)\nPerceived blank entries:      29   (potential for expansion)\nTable E2 pointed to by the LWA has length available. Hex 0A30.\nTable E2 pointed to by the LWA came from an APF STEPLIB.\nTable Header:  IKJEFTE276.152\nNumber of valid entries:     324\nE2 Table Entry Number:         1  $$\nE2 Table Entry Number:         2  $HOWMVS\nE2 Table Entry Number:         3  $MDSMAIN\nE2 Table Entry Number:         4  ABUDSN\nE2 Table Entry Number:         5  AD\nE2 Table Entry Number:         6  ADB2UTIL\nE2 Table Entry Number:         7  ADDDIR\nE2 Table Entry Number:         8  ADDFILE\nE2 Table Entry Number:         9  ADDGROUP\nE2 Table Entry Number:        10  ADDSD\nE2 Table Entry Number:        11  ADDUSER\nE2 Table Entry Number:        12  ADIR\nE2 Table Entry Number:        13  ADNR\nE2 Table Entry Number:        14  ADYOPCMD\nE2 Table Entry Number:        15  AF\nE2 Table Entry Number:        16  AG\nE2 Table Entry Number:        17  AHOWMVS\nE2 Table Entry Number:        18  ALD\nE2 Table Entry Number:        19  ALF\nE2 Table Entry Number:        20  ALG\nE2 Table Entry Number:        21  ALTDIR\nE2 Table Entry Number:        22  ALTDSD\nE2 Table Entry Number:        23  ALTER\nE2 Table Entry Number:        24  ALTFILE\nE2 Table Entry Number:        25  ALTGROUP\nE2 Table Entry Number:        26  ALTUSER\nE2 Table Entry Number:        27  ALU\nE2 Table Entry Number:        28  APCACBL\nE2 Table Entry Number:        29  APCANB\nE2 Table Entry Number:        30  APCARB\nE2 Table Entry Number:        31  APCAUB\nE2 Table Entry Number:        32  APFCMD\nE2 Table Entry Number:        33  ASUB\nE2 Table Entry Number:        34  AU\nE2 Table Entry Number:        35  BACKUP\nE2 Table Entry Number:        36  BCMDEL\nE2 Table Entry Number:        37  BCMDEL1\nE2 Table Entry Number:        38  BCMNAUTH\nE2 Table Entry Number:        39  BCMNUPD\nE2 Table Entry Number:        40  BDATA\nE2 Table Entry Number:        41  BDMNUPD\nE2 Table Entry Number:        42  BINDDATA\nE2 Table Entry Number:        43  BLKUPD\nE2 Table Entry Number:        44  BUDDSN\nE2 Table Entry Number:        45  BUDGET\nE2 Table Entry Number:        46  CAE$BQRY\nE2 Table Entry Number:        47  CANCELU\nE2 Table Entry Number:        48  CAS9UDTN\nE2 Table Entry Number:        49  CDELPAIR\nE2 Table Entry Number:        50  CDMRSTAT\nE2 Table Entry Number:        51  CDSCB\nE2 Table Entry Number:        52  CESTPAIR\nE2 Table Entry Number:        53  CHKPT\nE2 Table Entry Number:        54  CINMX\nE2 Table Entry Number:        55  CLCHECK\nE2 Table Entry Number:        56  CNVTCAT\nE2 Table Entry Number:        57  CO\nE2 Table Entry Number:        58  COFDMON\nE2 Table Entry Number:        59  CONNECT\nE2 Table Entry Number:        60  CONSPROF\nE2 Table Entry Number:        61  CPSCB\nE2 Table Entry Number:        62  CQUERYSG\nE2 Table Entry Number:        63  CRECOVER\nE2 Table Entry Number:        64  CSCAN\nE2 Table Entry Number:        65  CSUSPEND\nE2 Table Entry Number:        66  DCAS\nE2 Table Entry Number:        67  DD\nE2 Table Entry Number:        68  DDIR\nE2 Table Entry Number:        69  DEF\nE2 Table Entry Number:        70  DEFINE\nE2 Table Entry Number:        71  DEL\nE2 Table Entry Number:        72  DELDIR\nE2 Table Entry Number:        73  DELDSD\nE2 Table Entry Number:        74  DELETE\nE2 Table Entry Number:        75  DELFILE\nE2 Table Entry Number:        76  DELGROUP\nE2 Table Entry Number:        77  DELUSER\nE2 Table Entry Number:        78  DF\nE2 Table Entry Number:        79  DG\nE2 Table Entry Number:        80  DITTO\nE2 Table Entry Number:        81  DITTOA\nE2 Table Entry Number:        82  DITTOU\nE2 Table Entry Number:        83  DMRSHR\nE2 Table Entry Number:        84  DRI\nE2 Table Entry Number:        85  DU\nE2 Table Entry Number:        86  ERWMAUTH\nE2 Table Entry Number:        87  EX\nE2 Table Entry Number:        88  EXP\nE2 Table Entry Number:        89  EXPORT\nE2 Table Entry Number:        90  EYU9XENF\nE2 Table Entry Number:        91  EZAZSSI\nE2 Table Entry Number:        92  EZBREINI\nE2 Table Entry Number:        93  EZBTNINI\nE2 Table Entry Number:        94  FCESTABL\nE2 Table Entry Number:        95  FCQUERY\nE2 Table Entry Number:        96  FCWITHDR\nE2 Table Entry Number:        97  FTPD\nE2 Table Entry Number:        98  FTPDNS\nE2 Table Entry Number:        99  GJTRUCBS\nE2 Table Entry Number:       100  IEBCOPY\nE2 Table Entry Number:       101  IKJEHDSF\nE2 Table Entry Number:       102  IKJEHDS1\nE2 Table Entry Number:       103  IKJPRMLB\nE2 Table Entry Number:       104  IM\nE2 Table Entry Number:       105  IMP\nE2 Table Entry Number:       106  IMPORT\nE2 Table Entry Number:       107  IOBSNMP\nE2 Table Entry Number:       108  IQIEXPN\nE2 Table Entry Number:       109  IQIMAIN\nE2 Table Entry Number:       110  IQIQUERY\nE2 Table Entry Number:       111  IQIQUIT\nE2 Table Entry Number:       112  IRRDPI00\nE2 Table Entry Number:       113  ISPICP\nE2 Table Entry Number:       114  ISRPCP\nE2 Table Entry Number:       115  LBADV\nE2 Table Entry Number:       116  LBAGENT\nE2 Table Entry Number:       117  LD\nE2 Table Entry Number:       118  LDATA\nE2 Table Entry Number:       119  LDIR\nE2 Table Entry Number:       120  LDIRECT\nE2 Table Entry Number:       121  LF\nE2 Table Entry Number:       122  LFILE\nE2 Table Entry Number:       123  LG\nE2 Table Entry Number:       124  LISTB\nE2 Table Entry Number:       125  LISTBC\nE2 Table Entry Number:       126  LISTD\nE2 Table Entry Number:       127  LISTDATA\nE2 Table Entry Number:       128  LISTDS\nE2 Table Entry Number:       129  LISTDSD\nE2 Table Entry Number:       130  LISTGRP\nE2 Table Entry Number:       131  LISTUSER\nE2 Table Entry Number:       132  LLWA\nE2 Table Entry Number:       133  LMRKTSO\nE2 Table Entry Number:       134  LOCKTERM\nE2 Table Entry Number:       135  LOOK\nE2 Table Entry Number:       136  LPQ\nE2 Table Entry Number:       137  LPR\nE2 Table Entry Number:       138  LPRM\nE2 Table Entry Number:       139  LPROC\nE2 Table Entry Number:       140  LSLT\nE2 Table Entry Number:       141  LU\nE2 Table Entry Number:       142  LWATMGR\nE2 Table Entry Number:       143  MAKEUSER\nE2 Table Entry Number:       144  MIMTSO\nE2 Table Entry Number:       145  MODDVIPA\nE2 Table Entry Number:       146  MU\nE2 Table Entry Number:       147  MVPMAIN\nE2 Table Entry Number:       148  MVPXDISP\nE2 Table Entry Number:       149  MVSCPCMD\nE2 Table Entry Number:       150  NAMEDXFR\nE2 Table Entry Number:       151  NAMED4\nE2 Table Entry Number:       152  NDVRC1\nE2 Table Entry Number:       153  NETSTAT\nE2 Table Entry Number:       154  NSUPDATE\nE2 Table Entry Number:       155  NSUPDAT4\nE2 Table Entry Number:       156  NYPPW\nE2 Table Entry Number:       157  OC\nE2 Table Entry Number:       158  OMPROUTE\nE2 Table Entry Number:       159  OP\nE2 Table Entry Number:       160  OPER\nE2 Table Entry Number:       161  OPERATOR\nE2 Table Entry Number:       162  OPINFO\nE2 Table Entry Number:       163  OPING\nE2 Table Entry Number:       164  OPSCMD\nE2 Table Entry Number:       165  OPSCONSL\nE2 Table Entry Number:       166  OPSOSCMD\nE2 Table Entry Number:       167  OPSPARM\nE2 Table Entry Number:       168  OPSREPLY\nE2 Table Entry Number:       169  OPSTAT\nE2 Table Entry Number:       170  OPSWTO\nE2 Table Entry Number:       171  OSNMPD\nE2 Table Entry Number:       172  OTRACERT\nE2 Table Entry Number:       173  PACKRAT\nE2 Table Entry Number:       174  PARMLIB\nE2 Table Entry Number:       175  PASSWORD\nE2 Table Entry Number:       176  PDIR\nE2 Table Entry Number:       177  PDSCLEAN\nE2 Table Entry Number:       178  PDSEAUTH\nE2 Table Entry Number:       179  PE\nE2 Table Entry Number:       180  PERMDIR\nE2 Table Entry Number:       181  PERMFILE\nE2 Table Entry Number:       182  PERMIT\nE2 Table Entry Number:       183  PF\nE2 Table Entry Number:       184  PHRASE\nE2 Table Entry Number:       185  PING\nE2 Table Entry Number:       186  POPPER\nE2 Table Entry Number:       187  PRINT\nE2 Table Entry Number:       188  PW\nE2 Table Entry Number:       189  Q\nE2 Table Entry Number:       190  QUEUE\nE2 Table Entry Number:       191  Q522\nE2 Table Entry Number:       192  RACDCERT\nE2 Table Entry Number:       193  RACFSIM\nE2 Table Entry Number:       194  RACLINK\nE2 Table Entry Number:       195  RACONVRT\nE2 Table Entry Number:       196  RACPRIV\nE2 Table Entry Number:       197  RALT\nE2 Table Entry Number:       198  RALTER\nE2 Table Entry Number:       199  RDEF\nE2 Table Entry Number:       200  RDEFINE\nE2 Table Entry Number:       201  RDEL\nE2 Table Entry Number:       202  RDELETE\nE2 Table Entry Number:       203  RE\nE2 Table Entry Number:       204  RECEIVE\nE2 Table Entry Number:       205  RELOGON\nE2 Table Entry Number:       206  REMOVE\nE2 Table Entry Number:       207  REPRO\nE2 Table Entry Number:       208  RESOLVE\nE2 Table Entry Number:       209  REVIEW\nE2 Table Entry Number:       210  REVVSAM\nE2 Table Entry Number:       211  REXCPCMD\nE2 Table Entry Number:       212  RL\nE2 Table Entry Number:       213  RLIST\nE2 Table Entry Number:       214  RLOAD\nE2 Table Entry Number:       215  RLOADA\nE2 Table Entry Number:       216  RMM\nE2 Table Entry Number:       217  RPF\nE2 Table Entry Number:       218  RPFE\nE2 Table Entry Number:       219  RSH\nE2 Table Entry Number:       220  RSHD\nE2 Table Entry Number:       221  RVARY\nE2 Table Entry Number:       222  SAMENDM\nE2 Table Entry Number:       223  SDSF\nE2 Table Entry Number:       224  SE\nE2 Table Entry Number:       225  SEARCH\nE2 Table Entry Number:       226  SECURE\nE2 Table Entry Number:       227  SEND\nE2 Table Entry Number:       228  SETC\nE2 Table Entry Number:       229  SETCACHE\nE2 Table Entry Number:       230  SETPASSW\nE2 Table Entry Number:       231  SETPW\nE2 Table Entry Number:       232  SETPW2\nE2 Table Entry Number:       233  SETR\nE2 Table Entry Number:       234  SETROPTS\nE2 Table Entry Number:       235  SETUSER\nE2 Table Entry Number:       236  SHCDS\nE2 Table Entry Number:       237  SM\nE2 Table Entry Number:       238  SMTP\nE2 Table Entry Number:       239  SNTPD\nE2 Table Entry Number:       240  SPACE\nE2 Table Entry Number:       241  SPY\nE2 Table Entry Number:       242  SR\nE2 Table Entry Number:       243  SRDIR\nE2 Table Entry Number:       244  SRF\nE2 Table Entry Number:       245  SRFILE\nE2 Table Entry Number:       246  SRSTAT\nE2 Table Entry Number:       247  STEPLIB\nE2 Table Entry Number:       248  STEPLIBN\nE2 Table Entry Number:       249  SU\nE2 Table Entry Number:       250  SYNC\nE2 Table Entry Number:       251  SYSPROG\nE2 Table Entry Number:       252  TEAEXTSO\nE2 Table Entry Number:       253  TERM\nE2 Table Entry Number:       254  TERMINAL\nE2 Table Entry Number:       255  TESTA\nE2 Table Entry Number:       256  TESTAUTH\nE2 Table Entry Number:       257  TMONCICS\nE2 Table Entry Number:       258  TMONDB2\nE2 Table Entry Number:       259  TMONIMS\nE2 Table Entry Number:       260  TMONMVS\nE2 Table Entry Number:       261  TRACERTE\nE2 Table Entry Number:       262  TRANSMIT\nE2 Table Entry Number:       263  TRAPFWD\nE2 Table Entry Number:       264  TRMD\nE2 Table Entry Number:       265  TSOENQ\nE2 Table Entry Number:       266  TSOSMS\nE2 Table Entry Number:       267  TSUB\nE2 Table Entry Number:       268  UKEYCSA\nE2 Table Entry Number:       269  USAT\nE2 Table Entry Number:       270  USIT\nE2 Table Entry Number:       271  USOT\nE2 Table Entry Number:       272  USUT\nE2 Table Entry Number:       273  VERIFY\nE2 Table Entry Number:       274  VFY\nE2 Table Entry Number:       275  VIEWUSER\nE2 Table Entry Number:       276  VLFNOTE\nE2 Table Entry Number:       277  VMCF\nE2 Table Entry Number:       278  VU\nE2 Table Entry Number:       279  WAITT\nE2 Table Entry Number:       280  WHOENQ\nE2 Table Entry Number:       281  WSSTAT\nE2 Table Entry Number:       282  XD\nE2 Table Entry Number:       283  XDCCALLA\nE2 Table Entry Number:       284  XDCCMDA\nE2 Table Entry Number:       285  XF\nE2 Table Entry Number:       286  XMDSMAIN\nE2 Table Entry Number:       287  XMIT\nE2 Table Entry Number:       288  XTRCUSER\nE2 Table Entry Number:       289  XU\nE2 Table Entry Number:       290  YKCONMSG\nE2 Table Entry Number:       291  ZAP\nE2 Table Entry Number:       292  ZAP$\nE2 Table Entry Number:       293  ZAPLWA\nE2 Table Entry Number:       294  ZAPV\nE2 Table Entry Number:       295  CQX\nE2 Table Entry Number:       296  *empty*\n\nReturn Code = 0\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSUB#06": {"ttr": 22791, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x18\\x01\\t\\x04\\x8f\\x01\\x19!/\\x14\\x13\\x01V\\x00\\x08\\x00\\x00\\xc5\\xe7\\xc1\\xd4\\xd7\\xd3\\xc5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2009-02-17T00:00:00", "modifydate": "2019-07-31T14:13:18", "lines": 342, "newlines": 8, "modlines": 0, "user": "EXAMPLE"}, "text": "Output of command:  TSUB E2M    (like E2L except the new length\n                                 only includes ONE blank at the end.)\n\n     This command measures the length of the IKJEFTE2 table in\n     the user's address space, to (and including) the first blank\n     table entry.  Then this length is plugged into the LWA field\n     which is supposed to contain the length of the IKJEFTE2 table.\n     The messages below, tell you what happened.  Another TSUB E2D\n     command will tell you the resulting state of the E2 table.\n\n\nTSUB Command - Display/Change USERID Auth Table Entry - Ver 1.40\n---- -------   ------- ------ ------ ---- ----- -----   --------\n\n  **--- STATE BEFORE MAKING TABLE CHANGES ---**\nE2M   10     Program table code + Function code\nTable address:      0000C000\nTable address is not within an LPA region.\nNon-blank table entries:     295   (these are the ones used)\nPerceived blank entries:      29   (potential for expansion)\nTable E2 pointed to by the LWA has length available. Hex 0A30.\nTable E2 pointed to by the LWA came from an APF STEPLIB.\nTable Header:  IKJEFTE276.152\nNumber of valid entries:     324\n\n  **--------   AFTER MAKING CHANGES   -------**\nLWA size for table E2 has been changed from Hex 0A30 to Hex 0950.\nTable E2 pointed to by the LWA has length available. Hex 0950.\n\nReturn Code = 0\n\n-----------------------------------------------------------------\n\nTSUB Command - Display/Change USERID Auth Table Entry - Ver 1.40\n---- -------   ------- ------ ------ ---- ----- -----   --------\nE2D   04     Program table code + Function code\nTable address:      0000C000\nTable address is not within an LPA region.\nNon-blank table entries:     295   (these are the ones used)\nPerceived blank entries:      29   (potential for expansion)\nTable E2 pointed to by the LWA has length available. Hex 0950.\nTable E2 pointed to by the LWA came from an APF STEPLIB.\nTable Header:  IKJEFTE276.152\nNumber of valid entries:     296\nE2 Table Entry Number:         1  $$\nE2 Table Entry Number:         2  $HOWMVS\nE2 Table Entry Number:         3  $MDSMAIN\nE2 Table Entry Number:         4  ABUDSN\nE2 Table Entry Number:         5  AD\nE2 Table Entry Number:         6  ADB2UTIL\nE2 Table Entry Number:         7  ADDDIR\nE2 Table Entry Number:         8  ADDFILE\nE2 Table Entry Number:         9  ADDGROUP\nE2 Table Entry Number:        10  ADDSD\nE2 Table Entry Number:        11  ADDUSER\nE2 Table Entry Number:        12  ADIR\nE2 Table Entry Number:        13  ADNR\nE2 Table Entry Number:        14  ADYOPCMD\nE2 Table Entry Number:        15  AF\nE2 Table Entry Number:        16  AG\nE2 Table Entry Number:        17  AHOWMVS\nE2 Table Entry Number:        18  ALD\nE2 Table Entry Number:        19  ALF\nE2 Table Entry Number:        20  ALG\nE2 Table Entry Number:        21  ALTDIR\nE2 Table Entry Number:        22  ALTDSD\nE2 Table Entry Number:        23  ALTER\nE2 Table Entry Number:        24  ALTFILE\nE2 Table Entry Number:        25  ALTGROUP\nE2 Table Entry Number:        26  ALTUSER\nE2 Table Entry Number:        27  ALU\nE2 Table Entry Number:        28  APCACBL\nE2 Table Entry Number:        29  APCANB\nE2 Table Entry Number:        30  APCARB\nE2 Table Entry Number:        31  APCAUB\nE2 Table Entry Number:        32  APFCMD\nE2 Table Entry Number:        33  ASUB\nE2 Table Entry Number:        34  AU\nE2 Table Entry Number:        35  BACKUP\nE2 Table Entry Number:        36  BCMDEL\nE2 Table Entry Number:        37  BCMDEL1\nE2 Table Entry Number:        38  BCMNAUTH\nE2 Table Entry Number:        39  BCMNUPD\nE2 Table Entry Number:        40  BDATA\nE2 Table Entry Number:        41  BDMNUPD\nE2 Table Entry Number:        42  BINDDATA\nE2 Table Entry Number:        43  BLKUPD\nE2 Table Entry Number:        44  BUDDSN\nE2 Table Entry Number:        45  BUDGET\nE2 Table Entry Number:        46  CAE$BQRY\nE2 Table Entry Number:        47  CANCELU\nE2 Table Entry Number:        48  CAS9UDTN\nE2 Table Entry Number:        49  CDELPAIR\nE2 Table Entry Number:        50  CDMRSTAT\nE2 Table Entry Number:        51  CDSCB\nE2 Table Entry Number:        52  CESTPAIR\nE2 Table Entry Number:        53  CHKPT\nE2 Table Entry Number:        54  CINMX\nE2 Table Entry Number:        55  CLCHECK\nE2 Table Entry Number:        56  CNVTCAT\nE2 Table Entry Number:        57  CO\nE2 Table Entry Number:        58  COFDMON\nE2 Table Entry Number:        59  CONNECT\nE2 Table Entry Number:        60  CONSPROF\nE2 Table Entry Number:        61  CPSCB\nE2 Table Entry Number:        62  CQUERYSG\nE2 Table Entry Number:        63  CRECOVER\nE2 Table Entry Number:        64  CSCAN\nE2 Table Entry Number:        65  CSUSPEND\nE2 Table Entry Number:        66  DCAS\nE2 Table Entry Number:        67  DD\nE2 Table Entry Number:        68  DDIR\nE2 Table Entry Number:        69  DEF\nE2 Table Entry Number:        70  DEFINE\nE2 Table Entry Number:        71  DEL\nE2 Table Entry Number:        72  DELDIR\nE2 Table Entry Number:        73  DELDSD\nE2 Table Entry Number:        74  DELETE\nE2 Table Entry Number:        75  DELFILE\nE2 Table Entry Number:        76  DELGROUP\nE2 Table Entry Number:        77  DELUSER\nE2 Table Entry Number:        78  DF\nE2 Table Entry Number:        79  DG\nE2 Table Entry Number:        80  DITTO\nE2 Table Entry Number:        81  DITTOA\nE2 Table Entry Number:        82  DITTOU\nE2 Table Entry Number:        83  DMRSHR\nE2 Table Entry Number:        84  DRI\nE2 Table Entry Number:        85  DU\nE2 Table Entry Number:        86  ERWMAUTH\nE2 Table Entry Number:        87  EX\nE2 Table Entry Number:        88  EXP\nE2 Table Entry Number:        89  EXPORT\nE2 Table Entry Number:        90  EYU9XENF\nE2 Table Entry Number:        91  EZAZSSI\nE2 Table Entry Number:        92  EZBREINI\nE2 Table Entry Number:        93  EZBTNINI\nE2 Table Entry Number:        94  FCESTABL\nE2 Table Entry Number:        95  FCQUERY\nE2 Table Entry Number:        96  FCWITHDR\nE2 Table Entry Number:        97  FTPD\nE2 Table Entry Number:        98  FTPDNS\nE2 Table Entry Number:        99  GJTRUCBS\nE2 Table Entry Number:       100  IEBCOPY\nE2 Table Entry Number:       101  IKJEHDSF\nE2 Table Entry Number:       102  IKJEHDS1\nE2 Table Entry Number:       103  IKJPRMLB\nE2 Table Entry Number:       104  IM\nE2 Table Entry Number:       105  IMP\nE2 Table Entry Number:       106  IMPORT\nE2 Table Entry Number:       107  IOBSNMP\nE2 Table Entry Number:       108  IQIEXPN\nE2 Table Entry Number:       109  IQIMAIN\nE2 Table Entry Number:       110  IQIQUERY\nE2 Table Entry Number:       111  IQIQUIT\nE2 Table Entry Number:       112  IRRDPI00\nE2 Table Entry Number:       113  ISPICP\nE2 Table Entry Number:       114  ISRPCP\nE2 Table Entry Number:       115  LBADV\nE2 Table Entry Number:       116  LBAGENT\nE2 Table Entry Number:       117  LD\nE2 Table Entry Number:       118  LDATA\nE2 Table Entry Number:       119  LDIR\nE2 Table Entry Number:       120  LDIRECT\nE2 Table Entry Number:       121  LF\nE2 Table Entry Number:       122  LFILE\nE2 Table Entry Number:       123  LG\nE2 Table Entry Number:       124  LISTB\nE2 Table Entry Number:       125  LISTBC\nE2 Table Entry Number:       126  LISTD\nE2 Table Entry Number:       127  LISTDATA\nE2 Table Entry Number:       128  LISTDS\nE2 Table Entry Number:       129  LISTDSD\nE2 Table Entry Number:       130  LISTGRP\nE2 Table Entry Number:       131  LISTUSER\nE2 Table Entry Number:       132  LLWA\nE2 Table Entry Number:       133  LMRKTSO\nE2 Table Entry Number:       134  LOCKTERM\nE2 Table Entry Number:       135  LOOK\nE2 Table Entry Number:       136  LPQ\nE2 Table Entry Number:       137  LPR\nE2 Table Entry Number:       138  LPRM\nE2 Table Entry Number:       139  LPROC\nE2 Table Entry Number:       140  LSLT\nE2 Table Entry Number:       141  LU\nE2 Table Entry Number:       142  LWATMGR\nE2 Table Entry Number:       143  MAKEUSER\nE2 Table Entry Number:       144  MIMTSO\nE2 Table Entry Number:       145  MODDVIPA\nE2 Table Entry Number:       146  MU\nE2 Table Entry Number:       147  MVPMAIN\nE2 Table Entry Number:       148  MVPXDISP\nE2 Table Entry Number:       149  MVSCPCMD\nE2 Table Entry Number:       150  NAMEDXFR\nE2 Table Entry Number:       151  NAMED4\nE2 Table Entry Number:       152  NDVRC1\nE2 Table Entry Number:       153  NETSTAT\nE2 Table Entry Number:       154  NSUPDATE\nE2 Table Entry Number:       155  NSUPDAT4\nE2 Table Entry Number:       156  NYPPW\nE2 Table Entry Number:       157  OC\nE2 Table Entry Number:       158  OMPROUTE\nE2 Table Entry Number:       159  OP\nE2 Table Entry Number:       160  OPER\nE2 Table Entry Number:       161  OPERATOR\nE2 Table Entry Number:       162  OPINFO\nE2 Table Entry Number:       163  OPING\nE2 Table Entry Number:       164  OPSCMD\nE2 Table Entry Number:       165  OPSCONSL\nE2 Table Entry Number:       166  OPSOSCMD\nE2 Table Entry Number:       167  OPSPARM\nE2 Table Entry Number:       168  OPSREPLY\nE2 Table Entry Number:       169  OPSTAT\nE2 Table Entry Number:       170  OPSWTO\nE2 Table Entry Number:       171  OSNMPD\nE2 Table Entry Number:       172  OTRACERT\nE2 Table Entry Number:       173  PACKRAT\nE2 Table Entry Number:       174  PARMLIB\nE2 Table Entry Number:       175  PASSWORD\nE2 Table Entry Number:       176  PDIR\nE2 Table Entry Number:       177  PDSCLEAN\nE2 Table Entry Number:       178  PDSEAUTH\nE2 Table Entry Number:       179  PE\nE2 Table Entry Number:       180  PERMDIR\nE2 Table Entry Number:       181  PERMFILE\nE2 Table Entry Number:       182  PERMIT\nE2 Table Entry Number:       183  PF\nE2 Table Entry Number:       184  PHRASE\nE2 Table Entry Number:       185  PING\nE2 Table Entry Number:       186  POPPER\nE2 Table Entry Number:       187  PRINT\nE2 Table Entry Number:       188  PW\nE2 Table Entry Number:       189  Q\nE2 Table Entry Number:       190  QUEUE\nE2 Table Entry Number:       191  Q522\nE2 Table Entry Number:       192  RACDCERT\nE2 Table Entry Number:       193  RACFSIM\nE2 Table Entry Number:       194  RACLINK\nE2 Table Entry Number:       195  RACONVRT\nE2 Table Entry Number:       196  RACPRIV\nE2 Table Entry Number:       197  RALT\nE2 Table Entry Number:       198  RALTER\nE2 Table Entry Number:       199  RDEF\nE2 Table Entry Number:       200  RDEFINE\nE2 Table Entry Number:       201  RDEL\nE2 Table Entry Number:       202  RDELETE\nE2 Table Entry Number:       203  RE\nE2 Table Entry Number:       204  RECEIVE\nE2 Table Entry Number:       205  RELOGON\nE2 Table Entry Number:       206  REMOVE\nE2 Table Entry Number:       207  REPRO\nE2 Table Entry Number:       208  RESOLVE\nE2 Table Entry Number:       209  REVIEW\nE2 Table Entry Number:       210  REVVSAM\nE2 Table Entry Number:       211  REXCPCMD\nE2 Table Entry Number:       212  RL\nE2 Table Entry Number:       213  RLIST\nE2 Table Entry Number:       214  RLOAD\nE2 Table Entry Number:       215  RLOADA\nE2 Table Entry Number:       216  RMM\nE2 Table Entry Number:       217  RPF\nE2 Table Entry Number:       218  RPFE\nE2 Table Entry Number:       219  RSH\nE2 Table Entry Number:       220  RSHD\nE2 Table Entry Number:       221  RVARY\nE2 Table Entry Number:       222  SAMENDM\nE2 Table Entry Number:       223  SDSF\nE2 Table Entry Number:       224  SE\nE2 Table Entry Number:       225  SEARCH\nE2 Table Entry Number:       226  SECURE\nE2 Table Entry Number:       227  SEND\nE2 Table Entry Number:       228  SETC\nE2 Table Entry Number:       229  SETCACHE\nE2 Table Entry Number:       230  SETPASSW\nE2 Table Entry Number:       231  SETPW\nE2 Table Entry Number:       232  SETPW2\nE2 Table Entry Number:       233  SETR\nE2 Table Entry Number:       234  SETROPTS\nE2 Table Entry Number:       235  SETUSER\nE2 Table Entry Number:       236  SHCDS\nE2 Table Entry Number:       237  SM\nE2 Table Entry Number:       238  SMTP\nE2 Table Entry Number:       239  SNTPD\nE2 Table Entry Number:       240  SPACE\nE2 Table Entry Number:       241  SPY\nE2 Table Entry Number:       242  SR\nE2 Table Entry Number:       243  SRDIR\nE2 Table Entry Number:       244  SRF\nE2 Table Entry Number:       245  SRFILE\nE2 Table Entry Number:       246  SRSTAT\nE2 Table Entry Number:       247  STEPLIB\nE2 Table Entry Number:       248  STEPLIBN\nE2 Table Entry Number:       249  SU\nE2 Table Entry Number:       250  SYNC\nE2 Table Entry Number:       251  SYSPROG\nE2 Table Entry Number:       252  TEAEXTSO\nE2 Table Entry Number:       253  TERM\nE2 Table Entry Number:       254  TERMINAL\nE2 Table Entry Number:       255  TESTA\nE2 Table Entry Number:       256  TESTAUTH\nE2 Table Entry Number:       257  TMONCICS\nE2 Table Entry Number:       258  TMONDB2\nE2 Table Entry Number:       259  TMONIMS\nE2 Table Entry Number:       260  TMONMVS\nE2 Table Entry Number:       261  TRACERTE\nE2 Table Entry Number:       262  TRANSMIT\nE2 Table Entry Number:       263  TRAPFWD\nE2 Table Entry Number:       264  TRMD\nE2 Table Entry Number:       265  TSOENQ\nE2 Table Entry Number:       266  TSOSMS\nE2 Table Entry Number:       267  TSUB\nE2 Table Entry Number:       268  UKEYCSA\nE2 Table Entry Number:       269  USAT\nE2 Table Entry Number:       270  USIT\nE2 Table Entry Number:       271  USOT\nE2 Table Entry Number:       272  USUT\nE2 Table Entry Number:       273  VERIFY\nE2 Table Entry Number:       274  VFY\nE2 Table Entry Number:       275  VIEWUSER\nE2 Table Entry Number:       276  VLFNOTE\nE2 Table Entry Number:       277  VMCF\nE2 Table Entry Number:       278  VU\nE2 Table Entry Number:       279  WAITT\nE2 Table Entry Number:       280  WHOENQ\nE2 Table Entry Number:       281  WSSTAT\nE2 Table Entry Number:       282  XD\nE2 Table Entry Number:       283  XDCCALLA\nE2 Table Entry Number:       284  XDCCMDA\nE2 Table Entry Number:       285  XF\nE2 Table Entry Number:       286  XMDSMAIN\nE2 Table Entry Number:       287  XMIT\nE2 Table Entry Number:       288  XTRCUSER\nE2 Table Entry Number:       289  XU\nE2 Table Entry Number:       290  YKCONMSG\nE2 Table Entry Number:       291  ZAP\nE2 Table Entry Number:       292  ZAP$\nE2 Table Entry Number:       293  ZAPLWA\nE2 Table Entry Number:       294  ZAPV\nE2 Table Entry Number:       295  CQX\nE2 Table Entry Number:       296  *empty*\n\nReturn Code = 0\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSUB#07": {"ttr": 23043, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x008\\x01\\t\\x04\\x8f\\x01\\x19!/\\x14\\x13\\x01T\\x00\\x07\\x00\\x00\\xc5\\xe7\\xc1\\xd4\\xd7\\xd3\\xc5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2009-02-17T00:00:00", "modifydate": "2019-07-31T14:13:38", "lines": 340, "newlines": 7, "modlines": 0, "user": "EXAMPLE"}, "text": "Output of command:  TSUB E2Z\n\n     This command zeroes the length of the IKJEFTE2 table in the\n     user's address space, as marked in the LWA field that contains\n     the length of the IKJEFTE2 table.  The messages below, tell\n     you what happened.  TSUB E2D tells you the resulting state of\n     the E2 table.\n\n\nTSUB Command - Display/Change USERID Auth Table Entry - Ver 1.40\n---- -------   ------- ------ ------ ---- ----- -----   --------\n\n  **--- STATE BEFORE MAKING TABLE CHANGES ---**\nE2Z   20     Program table code + Function code\nTable address:      0000C000\nTable address is not within an LPA region.\nNon-blank table entries:     295   (these are the ones used)\nPerceived blank entries:      29   (potential for expansion)\nTable E2 pointed to by the LWA has length available. Hex 0950.\nTable E2 pointed to by the LWA came from an APF STEPLIB.\nTable Header:  IKJEFTE276.152\nNumber of valid entries:     296\n\n  **--------   AFTER MAKING CHANGES   -------**\nLWA size for table E2 is now Hex 0000.\nTable E2 pointed to by the LWA has no lengths. Blanks will delimit.\n\nReturn Code = 0\n\n--------------------------------------------------------------------\n\nTSUB Command - Display/Change USERID Auth Table Entry - Ver 1.40\n---- -------   ------- ------ ------ ---- ----- -----   --------\nE2D   04     Program table code + Function code\nTable address:      0000C000\nTable address is not within an LPA region.\nNon-blank table entries:     295   (these are the ones used)\nPerceived blank entries:      29   (potential for expansion)\nTable E2 pointed to by the LWA has no lengths. Blanks will delimit.\nTable E2 pointed to by the LWA came from an APF STEPLIB.\nTable Header:  IKJEFTE276.152\nNumber of valid entries:     296\nE2 Table Entry Number:         1  $$\nE2 Table Entry Number:         2  $HOWMVS\nE2 Table Entry Number:         3  $MDSMAIN\nE2 Table Entry Number:         4  ABUDSN\nE2 Table Entry Number:         5  AD\nE2 Table Entry Number:         6  ADB2UTIL\nE2 Table Entry Number:         7  ADDDIR\nE2 Table Entry Number:         8  ADDFILE\nE2 Table Entry Number:         9  ADDGROUP\nE2 Table Entry Number:        10  ADDSD\nE2 Table Entry Number:        11  ADDUSER\nE2 Table Entry Number:        12  ADIR\nE2 Table Entry Number:        13  ADNR\nE2 Table Entry Number:        14  ADYOPCMD\nE2 Table Entry Number:        15  AF\nE2 Table Entry Number:        16  AG\nE2 Table Entry Number:        17  AHOWMVS\nE2 Table Entry Number:        18  ALD\nE2 Table Entry Number:        19  ALF\nE2 Table Entry Number:        20  ALG\nE2 Table Entry Number:        21  ALTDIR\nE2 Table Entry Number:        22  ALTDSD\nE2 Table Entry Number:        23  ALTER\nE2 Table Entry Number:        24  ALTFILE\nE2 Table Entry Number:        25  ALTGROUP\nE2 Table Entry Number:        26  ALTUSER\nE2 Table Entry Number:        27  ALU\nE2 Table Entry Number:        28  APCACBL\nE2 Table Entry Number:        29  APCANB\nE2 Table Entry Number:        30  APCARB\nE2 Table Entry Number:        31  APCAUB\nE2 Table Entry Number:        32  APFCMD\nE2 Table Entry Number:        33  ASUB\nE2 Table Entry Number:        34  AU\nE2 Table Entry Number:        35  BACKUP\nE2 Table Entry Number:        36  BCMDEL\nE2 Table Entry Number:        37  BCMDEL1\nE2 Table Entry Number:        38  BCMNAUTH\nE2 Table Entry Number:        39  BCMNUPD\nE2 Table Entry Number:        40  BDATA\nE2 Table Entry Number:        41  BDMNUPD\nE2 Table Entry Number:        42  BINDDATA\nE2 Table Entry Number:        43  BLKUPD\nE2 Table Entry Number:        44  BUDDSN\nE2 Table Entry Number:        45  BUDGET\nE2 Table Entry Number:        46  CAE$BQRY\nE2 Table Entry Number:        47  CANCELU\nE2 Table Entry Number:        48  CAS9UDTN\nE2 Table Entry Number:        49  CDELPAIR\nE2 Table Entry Number:        50  CDMRSTAT\nE2 Table Entry Number:        51  CDSCB\nE2 Table Entry Number:        52  CESTPAIR\nE2 Table Entry Number:        53  CHKPT\nE2 Table Entry Number:        54  CINMX\nE2 Table Entry Number:        55  CLCHECK\nE2 Table Entry Number:        56  CNVTCAT\nE2 Table Entry Number:        57  CO\nE2 Table Entry Number:        58  COFDMON\nE2 Table Entry Number:        59  CONNECT\nE2 Table Entry Number:        60  CONSPROF\nE2 Table Entry Number:        61  CPSCB\nE2 Table Entry Number:        62  CQUERYSG\nE2 Table Entry Number:        63  CRECOVER\nE2 Table Entry Number:        64  CSCAN\nE2 Table Entry Number:        65  CSUSPEND\nE2 Table Entry Number:        66  DCAS\nE2 Table Entry Number:        67  DD\nE2 Table Entry Number:        68  DDIR\nE2 Table Entry Number:        69  DEF\nE2 Table Entry Number:        70  DEFINE\nE2 Table Entry Number:        71  DEL\nE2 Table Entry Number:        72  DELDIR\nE2 Table Entry Number:        73  DELDSD\nE2 Table Entry Number:        74  DELETE\nE2 Table Entry Number:        75  DELFILE\nE2 Table Entry Number:        76  DELGROUP\nE2 Table Entry Number:        77  DELUSER\nE2 Table Entry Number:        78  DF\nE2 Table Entry Number:        79  DG\nE2 Table Entry Number:        80  DITTO\nE2 Table Entry Number:        81  DITTOA\nE2 Table Entry Number:        82  DITTOU\nE2 Table Entry Number:        83  DMRSHR\nE2 Table Entry Number:        84  DRI\nE2 Table Entry Number:        85  DU\nE2 Table Entry Number:        86  ERWMAUTH\nE2 Table Entry Number:        87  EX\nE2 Table Entry Number:        88  EXP\nE2 Table Entry Number:        89  EXPORT\nE2 Table Entry Number:        90  EYU9XENF\nE2 Table Entry Number:        91  EZAZSSI\nE2 Table Entry Number:        92  EZBREINI\nE2 Table Entry Number:        93  EZBTNINI\nE2 Table Entry Number:        94  FCESTABL\nE2 Table Entry Number:        95  FCQUERY\nE2 Table Entry Number:        96  FCWITHDR\nE2 Table Entry Number:        97  FTPD\nE2 Table Entry Number:        98  FTPDNS\nE2 Table Entry Number:        99  GJTRUCBS\nE2 Table Entry Number:       100  IEBCOPY\nE2 Table Entry Number:       101  IKJEHDSF\nE2 Table Entry Number:       102  IKJEHDS1\nE2 Table Entry Number:       103  IKJPRMLB\nE2 Table Entry Number:       104  IM\nE2 Table Entry Number:       105  IMP\nE2 Table Entry Number:       106  IMPORT\nE2 Table Entry Number:       107  IOBSNMP\nE2 Table Entry Number:       108  IQIEXPN\nE2 Table Entry Number:       109  IQIMAIN\nE2 Table Entry Number:       110  IQIQUERY\nE2 Table Entry Number:       111  IQIQUIT\nE2 Table Entry Number:       112  IRRDPI00\nE2 Table Entry Number:       113  ISPICP\nE2 Table Entry Number:       114  ISRPCP\nE2 Table Entry Number:       115  LBADV\nE2 Table Entry Number:       116  LBAGENT\nE2 Table Entry Number:       117  LD\nE2 Table Entry Number:       118  LDATA\nE2 Table Entry Number:       119  LDIR\nE2 Table Entry Number:       120  LDIRECT\nE2 Table Entry Number:       121  LF\nE2 Table Entry Number:       122  LFILE\nE2 Table Entry Number:       123  LG\nE2 Table Entry Number:       124  LISTB\nE2 Table Entry Number:       125  LISTBC\nE2 Table Entry Number:       126  LISTD\nE2 Table Entry Number:       127  LISTDATA\nE2 Table Entry Number:       128  LISTDS\nE2 Table Entry Number:       129  LISTDSD\nE2 Table Entry Number:       130  LISTGRP\nE2 Table Entry Number:       131  LISTUSER\nE2 Table Entry Number:       132  LLWA\nE2 Table Entry Number:       133  LMRKTSO\nE2 Table Entry Number:       134  LOCKTERM\nE2 Table Entry Number:       135  LOOK\nE2 Table Entry Number:       136  LPQ\nE2 Table Entry Number:       137  LPR\nE2 Table Entry Number:       138  LPRM\nE2 Table Entry Number:       139  LPROC\nE2 Table Entry Number:       140  LSLT\nE2 Table Entry Number:       141  LU\nE2 Table Entry Number:       142  LWATMGR\nE2 Table Entry Number:       143  MAKEUSER\nE2 Table Entry Number:       144  MIMTSO\nE2 Table Entry Number:       145  MODDVIPA\nE2 Table Entry Number:       146  MU\nE2 Table Entry Number:       147  MVPMAIN\nE2 Table Entry Number:       148  MVPXDISP\nE2 Table Entry Number:       149  MVSCPCMD\nE2 Table Entry Number:       150  NAMEDXFR\nE2 Table Entry Number:       151  NAMED4\nE2 Table Entry Number:       152  NDVRC1\nE2 Table Entry Number:       153  NETSTAT\nE2 Table Entry Number:       154  NSUPDATE\nE2 Table Entry Number:       155  NSUPDAT4\nE2 Table Entry Number:       156  NYPPW\nE2 Table Entry Number:       157  OC\nE2 Table Entry Number:       158  OMPROUTE\nE2 Table Entry Number:       159  OP\nE2 Table Entry Number:       160  OPER\nE2 Table Entry Number:       161  OPERATOR\nE2 Table Entry Number:       162  OPINFO\nE2 Table Entry Number:       163  OPING\nE2 Table Entry Number:       164  OPSCMD\nE2 Table Entry Number:       165  OPSCONSL\nE2 Table Entry Number:       166  OPSOSCMD\nE2 Table Entry Number:       167  OPSPARM\nE2 Table Entry Number:       168  OPSREPLY\nE2 Table Entry Number:       169  OPSTAT\nE2 Table Entry Number:       170  OPSWTO\nE2 Table Entry Number:       171  OSNMPD\nE2 Table Entry Number:       172  OTRACERT\nE2 Table Entry Number:       173  PACKRAT\nE2 Table Entry Number:       174  PARMLIB\nE2 Table Entry Number:       175  PASSWORD\nE2 Table Entry Number:       176  PDIR\nE2 Table Entry Number:       177  PDSCLEAN\nE2 Table Entry Number:       178  PDSEAUTH\nE2 Table Entry Number:       179  PE\nE2 Table Entry Number:       180  PERMDIR\nE2 Table Entry Number:       181  PERMFILE\nE2 Table Entry Number:       182  PERMIT\nE2 Table Entry Number:       183  PF\nE2 Table Entry Number:       184  PHRASE\nE2 Table Entry Number:       185  PING\nE2 Table Entry Number:       186  POPPER\nE2 Table Entry Number:       187  PRINT\nE2 Table Entry Number:       188  PW\nE2 Table Entry Number:       189  Q\nE2 Table Entry Number:       190  QUEUE\nE2 Table Entry Number:       191  Q522\nE2 Table Entry Number:       192  RACDCERT\nE2 Table Entry Number:       193  RACFSIM\nE2 Table Entry Number:       194  RACLINK\nE2 Table Entry Number:       195  RACONVRT\nE2 Table Entry Number:       196  RACPRIV\nE2 Table Entry Number:       197  RALT\nE2 Table Entry Number:       198  RALTER\nE2 Table Entry Number:       199  RDEF\nE2 Table Entry Number:       200  RDEFINE\nE2 Table Entry Number:       201  RDEL\nE2 Table Entry Number:       202  RDELETE\nE2 Table Entry Number:       203  RE\nE2 Table Entry Number:       204  RECEIVE\nE2 Table Entry Number:       205  RELOGON\nE2 Table Entry Number:       206  REMOVE\nE2 Table Entry Number:       207  REPRO\nE2 Table Entry Number:       208  RESOLVE\nE2 Table Entry Number:       209  REVIEW\nE2 Table Entry Number:       210  REVVSAM\nE2 Table Entry Number:       211  REXCPCMD\nE2 Table Entry Number:       212  RL\nE2 Table Entry Number:       213  RLIST\nE2 Table Entry Number:       214  RLOAD\nE2 Table Entry Number:       215  RLOADA\nE2 Table Entry Number:       216  RMM\nE2 Table Entry Number:       217  RPF\nE2 Table Entry Number:       218  RPFE\nE2 Table Entry Number:       219  RSH\nE2 Table Entry Number:       220  RSHD\nE2 Table Entry Number:       221  RVARY\nE2 Table Entry Number:       222  SAMENDM\nE2 Table Entry Number:       223  SDSF\nE2 Table Entry Number:       224  SE\nE2 Table Entry Number:       225  SEARCH\nE2 Table Entry Number:       226  SECURE\nE2 Table Entry Number:       227  SEND\nE2 Table Entry Number:       228  SETC\nE2 Table Entry Number:       229  SETCACHE\nE2 Table Entry Number:       230  SETPASSW\nE2 Table Entry Number:       231  SETPW\nE2 Table Entry Number:       232  SETPW2\nE2 Table Entry Number:       233  SETR\nE2 Table Entry Number:       234  SETROPTS\nE2 Table Entry Number:       235  SETUSER\nE2 Table Entry Number:       236  SHCDS\nE2 Table Entry Number:       237  SM\nE2 Table Entry Number:       238  SMTP\nE2 Table Entry Number:       239  SNTPD\nE2 Table Entry Number:       240  SPACE\nE2 Table Entry Number:       241  SPY\nE2 Table Entry Number:       242  SR\nE2 Table Entry Number:       243  SRDIR\nE2 Table Entry Number:       244  SRF\nE2 Table Entry Number:       245  SRFILE\nE2 Table Entry Number:       246  SRSTAT\nE2 Table Entry Number:       247  STEPLIB\nE2 Table Entry Number:       248  STEPLIBN\nE2 Table Entry Number:       249  SU\nE2 Table Entry Number:       250  SYNC\nE2 Table Entry Number:       251  SYSPROG\nE2 Table Entry Number:       252  TEAEXTSO\nE2 Table Entry Number:       253  TERM\nE2 Table Entry Number:       254  TERMINAL\nE2 Table Entry Number:       255  TESTA\nE2 Table Entry Number:       256  TESTAUTH\nE2 Table Entry Number:       257  TMONCICS\nE2 Table Entry Number:       258  TMONDB2\nE2 Table Entry Number:       259  TMONIMS\nE2 Table Entry Number:       260  TMONMVS\nE2 Table Entry Number:       261  TRACERTE\nE2 Table Entry Number:       262  TRANSMIT\nE2 Table Entry Number:       263  TRAPFWD\nE2 Table Entry Number:       264  TRMD\nE2 Table Entry Number:       265  TSOENQ\nE2 Table Entry Number:       266  TSOSMS\nE2 Table Entry Number:       267  TSUB\nE2 Table Entry Number:       268  UKEYCSA\nE2 Table Entry Number:       269  USAT\nE2 Table Entry Number:       270  USIT\nE2 Table Entry Number:       271  USOT\nE2 Table Entry Number:       272  USUT\nE2 Table Entry Number:       273  VERIFY\nE2 Table Entry Number:       274  VFY\nE2 Table Entry Number:       275  VIEWUSER\nE2 Table Entry Number:       276  VLFNOTE\nE2 Table Entry Number:       277  VMCF\nE2 Table Entry Number:       278  VU\nE2 Table Entry Number:       279  WAITT\nE2 Table Entry Number:       280  WHOENQ\nE2 Table Entry Number:       281  WSSTAT\nE2 Table Entry Number:       282  XD\nE2 Table Entry Number:       283  XDCCALLA\nE2 Table Entry Number:       284  XDCCMDA\nE2 Table Entry Number:       285  XF\nE2 Table Entry Number:       286  XMDSMAIN\nE2 Table Entry Number:       287  XMIT\nE2 Table Entry Number:       288  XTRCUSER\nE2 Table Entry Number:       289  XU\nE2 Table Entry Number:       290  YKCONMSG\nE2 Table Entry Number:       291  ZAP\nE2 Table Entry Number:       292  ZAP$\nE2 Table Entry Number:       293  ZAPLWA\nE2 Table Entry Number:       294  ZAPV\nE2 Table Entry Number:       295  CQX\nE2 Table Entry Number:       296  *empty*\n\nReturn Code = 0\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSUB#08": {"ttr": 23049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00I\\x01\\t\\x04\\x8f\\x01\\x19!/\\x14\\x13\\x00\\x1d\\x00\\n\\x00\\x00\\xc5\\xe7\\xc1\\xd4\\xd7\\xd3\\xc5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2009-02-17T00:00:00", "modifydate": "2019-07-31T14:13:49", "lines": 29, "newlines": 10, "modlines": 0, "user": "EXAMPLE"}, "text": "Output of command:  TSUB E2S\n\n     This command throws a bit in the LWA that says that the\n     IKJEFTE2 table came from a STEPLIB, and not from an IKJTSOxx\n     PARMLIB member.  This has the effect that when someone issues\n     a command PARMLIB UPDATE(xx) or SET IKJTSO=xx later, then\n     your IKJEFTE2 table which is now marked that it came from\n     STEPLIB, will not be overlaid from the \"common storage\" copy\n     of the table.\n\n\nTSUB Command - Display/Change USERID Auth Table Entry - Ver 1.40\n---- -------   ------- ------ ------ ---- ----- -----   --------\n\n  **--- STATE BEFORE MAKING TABLE CHANGES ---**\nE2S   40     Program table code + Function code\nTable address:      0000C000\nTable address is not within an LPA region.\nNon-blank table entries:     295   (these are the ones used)\nPerceived blank entries:      29   (potential for expansion)\nTable E2 pointed to by the LWA has no lengths. Blanks will delimit.\nTable E2 pointed to by the LWA came from an APF STEPLIB.\nTable Header:  IKJEFTE276.152\nNumber of valid entries:     296\n\n  **--------   AFTER MAKING CHANGES   -------**\nTable E2 marked from STEPLIB so PARMLIB UPDATE(xx) will not overlay it.\n\nReturn Code = 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSUB#09": {"ttr": 23051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00W\\x01\\t\\x04\\x8f\\x01\\x19!/\\x14\\x13\\x00\\x1e\\x00\\x0b\\x00\\x00\\xc5\\xe7\\xc1\\xd4\\xd7\\xd3\\xc5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2009-02-17T00:00:00", "modifydate": "2019-07-31T14:13:57", "lines": 30, "newlines": 11, "modlines": 0, "user": "EXAMPLE"}, "text": "Output of command:  TSUB E2P\n\n     This command zeroes a bit in the LWA that says that the\n     IKJEFTE2 table came from a STEPLIB, and not from an IKJTSOxx\n     PARMLIB member.  Thus the table is marked that it came from\n     PARMLIB (even if it didn't).  This has the effect that when\n     someone issues a command PARMLIB UPDATE(xx) or SET IKJTSO=xx\n     later, then your IKJEFTE2 table which is now marked that it\n     came from PARMLIB, will be completely overlaid from the\n     \"common storage\" copy of the table.\n\n\nTSUB Command - Display/Change USERID Auth Table Entry - Ver 1.40\n---- -------   ------- ------ ------ ---- ----- -----   --------\n\n  **--- STATE BEFORE MAKING TABLE CHANGES ---**\nE2P   80     Program table code + Function code\nTable address:      0000C000\nTable address is not within an LPA region.\nNon-blank table entries:     295   (these are the ones used)\nPerceived blank entries:      29   (potential for expansion)\nTable E2 pointed to by the LWA has no lengths. Blanks will delimit.\nTable E2 pointed to by the LWA came from an APF STEPLIB.\nTable Header:  IKJEFTE276.152\nNumber of valid entries:     296\n\n  **--------   AFTER MAKING CHANGES   -------**\nTable E2 marked from not from STEPLIB. PARMLIB UPDATE(xx) can overlay.\n\nReturn Code = 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSUB#10": {"ttr": 23053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x03\\x01\\t\\x04\\x8f\\x01\\x19!/\\x14\\x14\\x00\\x1b\\x00\\x07\\x00\\x00\\xc5\\xe7\\xc1\\xd4\\xd7\\xd3\\xc5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2009-02-17T00:00:00", "modifydate": "2019-07-31T14:14:03", "lines": 27, "newlines": 7, "modlines": 0, "user": "EXAMPLE"}, "text": "Output of command:  TSUB E2H\n\n     This command alters the header of the IKJEFTE2 table, which\n     originally came from a STEPLIB, and not from an IKJTSOxx\n     PARMLIB member, to make it look as if it came from an IKJTSOxx\n     PARMLIB member.  The messages tell you what was done.\n\n\nTSUB Command - Display/Change USERID Auth Table Entry - Ver 1.40\n---- -------   ------- ------ ------ ---- ----- -----   --------\n\n  **--- STATE BEFORE MAKING TABLE CHANGES ---**\nE2H   08     Program table code + Function code\nTable address:      0000C000\nTable address is not within an LPA region.\nNon-blank table entries:     295   (these are the ones used)\nPerceived blank entries:      29   (potential for expansion)\nTable E2 pointed to by the LWA has no lengths. Blanks will delimit.\nTable E2 pointed to by the LWA did not come from an APF STEPLIB.\nTable Header:  IKJEFTE276.152\nNumber of valid entries:     296\n\n  **--------   AFTER MAKING CHANGES   -------**\nLast 8 bytes of table header altered to \" PARMLIB\".\nTable Header:  IKJEFTE2 PARMLIB\n\nReturn Code = 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSUB#11": {"ttr": 23055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00$\\x01\\t\\x04\\x9f\\x01\\x19!/\\x14\\x14\\x01U\\x01U\\x00\\x00\\xc5\\xe7\\xc1\\xd4\\xd7\\xd3\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2009-02-18T00:00:00", "modifydate": "2019-07-31T14:14:24", "lines": 341, "newlines": 341, "modlines": 0, "user": "EXAMPLE"}, "text": "TRICKS OF THE TRADE\n\nTSUB E2D, AFTER TSUB E2L followed by TSUB E2R 300 CQX\n\nExplanation.\n\n    The original E2 table had 294 non-blank entries followed by 30 blank\nentries.  Of course, TSO stops when it reaches the first blank, which is\nthe 295th slot.  However, after issuing TSUB E2L, the length of the\ntable (not there before, because the table came from a STEPLIB, and then\nI issued E2P which is not necessary) was increased to enough for 324\nslots.  The main thing here is the TSUB E2L.\n\n    Once the length of the table was increased to 324 slots, even though\nTSO will not honor anything after the first blank, TSUB will be able to\nreplace any of the blank entries with non-blanks.  This is because TSUB\nfigures out how many slots you have, in two ways.  If there is no table\nlength, then TSUB measures the table until the first blank.  If there is\na table length, then TSUB figures out, from that length, how many table\nentries there should be.  From the length of 324 entries, TSUB still has\nthe ability to change one of the later entries to a program name.  You\ncan tell what happened from the TSUB E2D display, because there are 324\nentries, 294 non-blank contiguous entries at the beginning, followed by\nonly 5 blank entries.  That means that the 6th entry is non-blank.\n\n    So theoretically, you can fill in 10 new program names, contiguously\nwhile still leaving the first blank entry, and you can activate them all\nat once, by putting a non-blank entry in the first blank spot, making 11\nnon-blank contiguous entries all of a sudden, which TSO will now honor.\n\n    Nice trick.  Only made possible by the new \"L\" action code.\n\n\nTSUB Command - Display/Change USERID Auth Table Entry - Ver 1.40\n---- -------   ------- ------ ------ ---- ----- -----   --------\nE2D   04     Program table code + Function code\nTable address:      0000C000\nTable address is not within an LPA region.\nNon-blank table entries:     294   (these are the ones used)\nPerceived blank entries:       5   (potential for expansion)\nTable E2 pointed to by the LWA has length available. Hex 0A30.\nTable E2 pointed to by the LWA did not come from an APF STEPLIB.\nTable Header:  IKJEFTE2 PARMLIB\nNumber of valid entries:     324\nE2 Table Entry Number:         1  $$\nE2 Table Entry Number:         2  $HOWMVS\nE2 Table Entry Number:         3  $MDSMAIN\nE2 Table Entry Number:         4  ABUDSN\nE2 Table Entry Number:         5  AD\nE2 Table Entry Number:         6  ADB2UTIL\nE2 Table Entry Number:         7  ADDDIR\nE2 Table Entry Number:         8  ADDFILE\nE2 Table Entry Number:         9  ADDGROUP\nE2 Table Entry Number:        10  ADDSD\nE2 Table Entry Number:        11  ADDUSER\nE2 Table Entry Number:        12  ADIR\nE2 Table Entry Number:        13  ADNR\nE2 Table Entry Number:        14  ADYOPCMD\nE2 Table Entry Number:        15  AF\nE2 Table Entry Number:        16  AG\nE2 Table Entry Number:        17  AHOWMVS\nE2 Table Entry Number:        18  ALD\nE2 Table Entry Number:        19  ALF\nE2 Table Entry Number:        20  ALG\nE2 Table Entry Number:        21  ALTDIR\nE2 Table Entry Number:        22  ALTDSD\nE2 Table Entry Number:        23  ALTER\nE2 Table Entry Number:        24  ALTFILE\nE2 Table Entry Number:        25  ALTGROUP\nE2 Table Entry Number:        26  ALTUSER\nE2 Table Entry Number:        27  ALU\nE2 Table Entry Number:        28  APCACBL\nE2 Table Entry Number:        29  APCANB\nE2 Table Entry Number:        30  APCARB\nE2 Table Entry Number:        31  APCAUB\nE2 Table Entry Number:        32  APFCMD\nE2 Table Entry Number:        33  ASUB\nE2 Table Entry Number:        34  AU\nE2 Table Entry Number:        35  BACKUP\nE2 Table Entry Number:        36  BCMDEL\nE2 Table Entry Number:        37  BCMDEL1\nE2 Table Entry Number:        38  BCMNAUTH\nE2 Table Entry Number:        39  BCMNUPD\nE2 Table Entry Number:        40  BDATA\nE2 Table Entry Number:        41  BDMNUPD\nE2 Table Entry Number:        42  BINDDATA\nE2 Table Entry Number:        43  BLKUPD\nE2 Table Entry Number:        44  BUDDSN\nE2 Table Entry Number:        45  BUDGET\nE2 Table Entry Number:        46  CAE$BQRY\nE2 Table Entry Number:        47  CANCELU\nE2 Table Entry Number:        48  CAS9UDTN\nE2 Table Entry Number:        49  CDELPAIR\nE2 Table Entry Number:        50  CDMRSTAT\nE2 Table Entry Number:        51  CDSCB\nE2 Table Entry Number:        52  CESTPAIR\nE2 Table Entry Number:        53  CHKPT\nE2 Table Entry Number:        54  CINMX\nE2 Table Entry Number:        55  CLCHECK\nE2 Table Entry Number:        56  CNVTCAT\nE2 Table Entry Number:        57  CO\nE2 Table Entry Number:        58  COFDMON\nE2 Table Entry Number:        59  CONNECT\nE2 Table Entry Number:        60  CONSPROF\nE2 Table Entry Number:        61  CPSCB\nE2 Table Entry Number:        62  CQUERYSG\nE2 Table Entry Number:        63  CRECOVER\nE2 Table Entry Number:        64  CSCAN\nE2 Table Entry Number:        65  CSUSPEND\nE2 Table Entry Number:        66  DCAS\nE2 Table Entry Number:        67  DD\nE2 Table Entry Number:        68  DDIR\nE2 Table Entry Number:        69  DEF\nE2 Table Entry Number:        70  DEFINE\nE2 Table Entry Number:        71  DEL\nE2 Table Entry Number:        72  DELDIR\nE2 Table Entry Number:        73  DELDSD\nE2 Table Entry Number:        74  DELETE\nE2 Table Entry Number:        75  DELFILE\nE2 Table Entry Number:        76  DELGROUP\nE2 Table Entry Number:        77  DELUSER\nE2 Table Entry Number:        78  DF\nE2 Table Entry Number:        79  DG\nE2 Table Entry Number:        80  DITTO\nE2 Table Entry Number:        81  DITTOA\nE2 Table Entry Number:        82  DITTOU\nE2 Table Entry Number:        83  DMRSHR\nE2 Table Entry Number:        84  DRI\nE2 Table Entry Number:        85  DU\nE2 Table Entry Number:        86  ERWMAUTH\nE2 Table Entry Number:        87  EX\nE2 Table Entry Number:        88  EXP\nE2 Table Entry Number:        89  EXPORT\nE2 Table Entry Number:        90  EYU9XENF\nE2 Table Entry Number:        91  EZAZSSI\nE2 Table Entry Number:        92  EZBREINI\nE2 Table Entry Number:        93  EZBTNINI\nE2 Table Entry Number:        94  FCESTABL\nE2 Table Entry Number:        95  FCQUERY\nE2 Table Entry Number:        96  FCWITHDR\nE2 Table Entry Number:        97  FTPD\nE2 Table Entry Number:        98  FTPDNS\nE2 Table Entry Number:        99  GJTRUCBS\nE2 Table Entry Number:       100  IEBCOPY\nE2 Table Entry Number:       101  IKJEHDSF\nE2 Table Entry Number:       102  IKJEHDS1\nE2 Table Entry Number:       103  IKJPRMLB\nE2 Table Entry Number:       104  IM\nE2 Table Entry Number:       105  IMP\nE2 Table Entry Number:       106  IMPORT\nE2 Table Entry Number:       107  IOBSNMP\nE2 Table Entry Number:       108  IQIEXPN\nE2 Table Entry Number:       109  IQIMAIN\nE2 Table Entry Number:       110  IQIQUERY\nE2 Table Entry Number:       111  IQIQUIT\nE2 Table Entry Number:       112  IRRDPI00\nE2 Table Entry Number:       113  ISPICP\nE2 Table Entry Number:       114  ISRPCP\nE2 Table Entry Number:       115  LBADV\nE2 Table Entry Number:       116  LBAGENT\nE2 Table Entry Number:       117  LD\nE2 Table Entry Number:       118  LDATA\nE2 Table Entry Number:       119  LDIR\nE2 Table Entry Number:       120  LDIRECT\nE2 Table Entry Number:       121  LF\nE2 Table Entry Number:       122  LFILE\nE2 Table Entry Number:       123  LG\nE2 Table Entry Number:       124  LISTB\nE2 Table Entry Number:       125  LISTBC\nE2 Table Entry Number:       126  LISTD\nE2 Table Entry Number:       127  LISTDATA\nE2 Table Entry Number:       128  LISTDS\nE2 Table Entry Number:       129  LISTDSD\nE2 Table Entry Number:       130  LISTGRP\nE2 Table Entry Number:       131  LISTUSER\nE2 Table Entry Number:       132  LLWA\nE2 Table Entry Number:       133  LMRKTSO\nE2 Table Entry Number:       134  LOCKTERM\nE2 Table Entry Number:       135  LOOK\nE2 Table Entry Number:       136  LPQ\nE2 Table Entry Number:       137  LPR\nE2 Table Entry Number:       138  LPRM\nE2 Table Entry Number:       139  LPROC\nE2 Table Entry Number:       140  LSLT\nE2 Table Entry Number:       141  LU\nE2 Table Entry Number:       142  LWATMGR\nE2 Table Entry Number:       143  MAKEUSER\nE2 Table Entry Number:       144  MIMTSO\nE2 Table Entry Number:       145  MODDVIPA\nE2 Table Entry Number:       146  MU\nE2 Table Entry Number:       147  MVPMAIN\nE2 Table Entry Number:       148  MVPXDISP\nE2 Table Entry Number:       149  MVSCPCMD\nE2 Table Entry Number:       150  NAMEDXFR\nE2 Table Entry Number:       151  NAMED4\nE2 Table Entry Number:       152  NDVRC1\nE2 Table Entry Number:       153  NETSTAT\nE2 Table Entry Number:       154  NSUPDATE\nE2 Table Entry Number:       155  NSUPDAT4\nE2 Table Entry Number:       156  NYPPW\nE2 Table Entry Number:       157  OC\nE2 Table Entry Number:       158  OMPROUTE\nE2 Table Entry Number:       159  OP\nE2 Table Entry Number:       160  OPER\nE2 Table Entry Number:       161  OPERATOR\nE2 Table Entry Number:       162  OPINFO\nE2 Table Entry Number:       163  OPING\nE2 Table Entry Number:       164  OPSCMD\nE2 Table Entry Number:       165  OPSCONSL\nE2 Table Entry Number:       166  OPSOSCMD\nE2 Table Entry Number:       167  OPSPARM\nE2 Table Entry Number:       168  OPSREPLY\nE2 Table Entry Number:       169  OPSTAT\nE2 Table Entry Number:       170  OPSWTO\nE2 Table Entry Number:       171  OSNMPD\nE2 Table Entry Number:       172  OTRACERT\nE2 Table Entry Number:       173  PACKRAT\nE2 Table Entry Number:       174  PARMLIB\nE2 Table Entry Number:       175  PASSWORD\nE2 Table Entry Number:       176  PDIR\nE2 Table Entry Number:       177  PDSCLEAN\nE2 Table Entry Number:       178  PDSEAUTH\nE2 Table Entry Number:       179  PE\nE2 Table Entry Number:       180  PERMDIR\nE2 Table Entry Number:       181  PERMFILE\nE2 Table Entry Number:       182  PERMIT\nE2 Table Entry Number:       183  PF\nE2 Table Entry Number:       184  PHRASE\nE2 Table Entry Number:       185  PING\nE2 Table Entry Number:       186  POPPER\nE2 Table Entry Number:       187  PRINT\nE2 Table Entry Number:       188  PW\nE2 Table Entry Number:       189  Q\nE2 Table Entry Number:       190  QUEUE\nE2 Table Entry Number:       191  Q522\nE2 Table Entry Number:       192  RACDCERT\nE2 Table Entry Number:       193  RACFSIM\nE2 Table Entry Number:       194  RACLINK\nE2 Table Entry Number:       195  RACONVRT\nE2 Table Entry Number:       196  RACPRIV\nE2 Table Entry Number:       197  RALT\nE2 Table Entry Number:       198  RALTER\nE2 Table Entry Number:       199  RDEF\nE2 Table Entry Number:       200  RDEFINE\nE2 Table Entry Number:       201  RDEL\nE2 Table Entry Number:       202  RDELETE\nE2 Table Entry Number:       203  RE\nE2 Table Entry Number:       204  RECEIVE\nE2 Table Entry Number:       205  RELOGON\nE2 Table Entry Number:       206  REMOVE\nE2 Table Entry Number:       207  REPRO\nE2 Table Entry Number:       208  RESOLVE\nE2 Table Entry Number:       209  REVIEW\nE2 Table Entry Number:       210  REVVSAM\nE2 Table Entry Number:       211  REXCPCMD\nE2 Table Entry Number:       212  RL\nE2 Table Entry Number:       213  RLIST\nE2 Table Entry Number:       214  RLOAD\nE2 Table Entry Number:       215  RLOADA\nE2 Table Entry Number:       216  RMM\nE2 Table Entry Number:       217  RPF\nE2 Table Entry Number:       218  RPFE\nE2 Table Entry Number:       219  RSH\nE2 Table Entry Number:       220  RSHD\nE2 Table Entry Number:       221  RVARY\nE2 Table Entry Number:       222  SAMENDM\nE2 Table Entry Number:       223  SDSF\nE2 Table Entry Number:       224  SE\nE2 Table Entry Number:       225  SEARCH\nE2 Table Entry Number:       226  SECURE\nE2 Table Entry Number:       227  SEND\nE2 Table Entry Number:       228  SETC\nE2 Table Entry Number:       229  SETCACHE\nE2 Table Entry Number:       230  SETPASSW\nE2 Table Entry Number:       231  SETPW\nE2 Table Entry Number:       232  SETPW2\nE2 Table Entry Number:       233  SETR\nE2 Table Entry Number:       234  SETROPTS\nE2 Table Entry Number:       235  SETUSER\nE2 Table Entry Number:       236  SHCDS\nE2 Table Entry Number:       237  SM\nE2 Table Entry Number:       238  SMTP\nE2 Table Entry Number:       239  SNTPD\nE2 Table Entry Number:       240  SPACE\nE2 Table Entry Number:       241  SPY\nE2 Table Entry Number:       242  SR\nE2 Table Entry Number:       243  SRDIR\nE2 Table Entry Number:       244  SRF\nE2 Table Entry Number:       245  SRFILE\nE2 Table Entry Number:       246  SRSTAT\nE2 Table Entry Number:       247  STEPLIB\nE2 Table Entry Number:       248  STEPLIBN\nE2 Table Entry Number:       249  SU\nE2 Table Entry Number:       250  SYNC\nE2 Table Entry Number:       251  SYSPROG\nE2 Table Entry Number:       252  TEAEXTSO\nE2 Table Entry Number:       253  TERM\nE2 Table Entry Number:       254  TERMINAL\nE2 Table Entry Number:       255  TESTA\nE2 Table Entry Number:       256  TESTAUTH\nE2 Table Entry Number:       257  TMONCICS\nE2 Table Entry Number:       258  TMONDB2\nE2 Table Entry Number:       259  TMONIMS\nE2 Table Entry Number:       260  TMONMVS\nE2 Table Entry Number:       261  TRACERTE\nE2 Table Entry Number:       262  TRANSMIT\nE2 Table Entry Number:       263  TRAPFWD\nE2 Table Entry Number:       264  TRMD\nE2 Table Entry Number:       265  TSOENQ\nE2 Table Entry Number:       266  TSOSMS\nE2 Table Entry Number:       267  TSUB\nE2 Table Entry Number:       268  UKEYCSA\nE2 Table Entry Number:       269  USAT\nE2 Table Entry Number:       270  USIT\nE2 Table Entry Number:       271  USOT\nE2 Table Entry Number:       272  USUT\nE2 Table Entry Number:       273  VERIFY\nE2 Table Entry Number:       274  VFY\nE2 Table Entry Number:       275  VIEWUSER\nE2 Table Entry Number:       276  VLFNOTE\nE2 Table Entry Number:       277  VMCF\nE2 Table Entry Number:       278  VU\nE2 Table Entry Number:       279  WAITT\nE2 Table Entry Number:       280  WHOENQ\nE2 Table Entry Number:       281  WSSTAT\nE2 Table Entry Number:       282  XD\nE2 Table Entry Number:       283  XDCCALLA\nE2 Table Entry Number:       284  XDCCMDA\nE2 Table Entry Number:       285  XF\nE2 Table Entry Number:       286  XMDSMAIN\nE2 Table Entry Number:       287  XMIT\nE2 Table Entry Number:       288  XTRCUSER\nE2 Table Entry Number:       289  XU\nE2 Table Entry Number:       290  YKCONMSG\nE2 Table Entry Number:       291  ZAP\nE2 Table Entry Number:       292  ZAP$\nE2 Table Entry Number:       293  ZAPLWA\nE2 Table Entry Number:       294  ZAPV\nE2 Table Entry Number:       295  *empty*\n\nReturn Code = 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSUBHELP": {"ttr": 23302, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01(\\x00$\\x01\\x17\\x11?\\x01\\x17\\x11?\\x00$\\x01\\xcf\\x01p\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.40", "flags": 0, "createdate": "2017-04-23T00:00:00", "modifydate": "2017-04-23T00:24:24", "lines": 463, "newlines": 368, "modlines": 0, "user": "HELP"}, "text": "***********************************************************************\n*                                                                     *\n*   Program Name:   TSUB                                              *\n*                                                                     *\n*                   ** This program is in the public domain. **       *\n*                                                                     *\n*  Documentation:   This program is meant to be run as a TSO          *\n*                   command, APF authorized except for the display    *\n*                   functions.                                        *\n*                                                                     *\n*    Environment:   TSO command, APF Authorized.                      *\n*                   PUTLINE interface enabled by APUT, EPUTL.         *\n*                   This program is non-reentrant.                    *\n*                                                                     *\n* Short Function:   This program deals with existing TSO \"auth\"       *\n*                   tables that are pointed to by fields in the       *\n*                   LWA (Logon Work Area) which is created for a      *\n*                   TSO session at LOGON time.  These tables are      *\n*                   the actual tables that your TSO session uses      *\n*                   to determine program authorization.  Many of      *\n*                   the characteristics of these tables can be        *\n*                   changed or reset by the TSUB program.  The        *\n*                   changes that TSUB can do, are of three types:     *\n*                                                                     *\n*                   1.  Replacing or blanking any table entry.        *\n*                   2.  Altering the LWA flags or fields that         *\n*                       determine this table's properties.            *\n*                   3.  Effectively nullifying an entry by            *\n*                       putting a C'?' into it.  This effectively     *\n*                       removes the entry, without nullifying any     *\n*                       of the following table entries.               *\n*                                                                     *\n*                Details:                                             *\n*                                                                     *\n*                   1.  TSUB can substitute a different program name  *\n*                       or insert a blank entry into any valid slot   *\n*                       of a TSO \"auth\" table that belongs to your    *\n*                       TSO session.                                  *\n*                                                                     *\n*                       You can effectively nullify a table           *\n*                       entry without blanking it, using the          *\n*                       \"nullify\" function \"N\" instead of the         *\n*                       \"blanking\" function \"B\".  The nullifying      *\n*                       function inserts a C'?' into the slot,        *\n*                       allowing all following slots to still         *\n*                       work, since a ? entry is not a blank that     *\n*                       delimits the table.                           *\n*                                                                     *\n*                       Blanking (not the last entry) is dangerous    *\n*                       (see below) because it invalidates all the    *\n*                       subsequent non-blank table entries.  But the  *\n*                       technique of blanking an entry can be used    *\n*                       carefully if you are sure of what you want    *\n*                       to accomplish.  That is why we are making     *\n*                       it available.  Use \"N\" instead of \"B\" most    *\n*                       of the time.                                  *\n*                                                                     *\n*                   2.  TSUB can change the characteristics of your   *\n*                       own session's TSO \"auth\" tables, that are     *\n*                       pointed to by the LWA, by means of changing   *\n*                       the LWA (Logon Work Area) settings for each   *\n*                       table.  For example, LWA table lengths can    *\n*                       be supplied or removed.  LWA flags marking    *\n*                       the table as coming from a STEPLIB can be     *\n*                       set, or removed.  Even the physical table     *\n*                       header can be altered to make the table       *\n*                       look as though it came from PARMLIB.          *\n*                                                                     *\n*   Introduction:   At LOGON time for a TSO session, the system       *\n*                   (program IKJEFTP2) copies a set of the E2, E8,    *\n*                   AP, and NS TSO authorization tables into SP 252   *\n*                   protected Key 0 storage which lies in the TSO     *\n*                   user's address space.  These are the tables       *\n*                   WHICH ARE ACTUALLY USED by that TSO session,      *\n*                   and their location is pointed to in the LWA       *\n*                   control block (Logon Work Area, which, by the     *\n*                   way is also created by program IKJEFTP2).  The    *\n*                   duration of these tables is for the life of       *\n*                   that TSO session.  TSO LOGON processing creates   *\n*                   both the LWA itself, and the copies of the auth   *\n*                   tables that the session uses.  TSUB displays      *\n*                   and manipulates this copy of these tables--the    *\n*                   ones that are actually in use. Thus, changes to   *\n*                   these tables are effective immediately, and       *\n*                   their scope affects only the issuing TSO          *\n*                   session.                                          *\n*                                                                     *\n*                   This is why the TSUB program effects \"personal    *\n*                   program authorization\" which does not affect      *\n*                   any other TSO users.  When you're trying out      *\n*                   a new program which needs to be authorized,       *\n*                   and you don't want it to be authorized to         *\n*                   anyone else, this is the technique to use.        *\n*                                                                     *\n*                   Where does TSO get these tables from, at LOGON    *\n*                   time?  Again, to be more specific:                *\n*                                                                     *\n*              Case 1.  The most commonly found source for the auth   *\n*                       tables pointed to in the LWA, is the \"common  *\n*                       storage\" tables created from the active       *\n*                       PARMLIB member IKJTSOxx.  Those are pointed   *\n*                       to by the TPVT control block + X'14' which    *\n*                       is the CTLT.  If the CTLT is the source of    *\n*                       the LWA tables, then lengths of the tables,   *\n*                       and the size of each entry, are copied from   *\n*                       the CTLT into the LWA (Logon Work Area).      *\n*                       Use the program called ASUB to directly       *\n*                       access the public tables from PARMLIB that    *\n*                       are pointed to by the CTLT (undocumented)     *\n*                       control block.  Our program, TSUB, accesses   *\n*                       the copy of those tables which is pointed to  *\n*                       by the LWA, which were created for the TSO    *\n*                       session at LOGON time, and which are unique   *\n*                       to the current TSO session.                   *\n*                                                                     *\n*              Case 2.  If a list of table entries for one or more    *\n*                       of the tables:  E2, E8, AP, or NS is not      *\n*                       found in the IKJTSOxx PARMLIB member that     *\n*                       is currently active, then the table in the    *\n*                       LWA is not copied from the IKJTABLS module    *\n*                       in LPALIB, but it is just pointed to.  Thus   *\n*                       in such a situation, TSUB cannot alter the    *\n*                       particular table.  The actual table is        *\n*                       located in PLPA, in that particular case.     *\n*                                                                     *\n*              Case 3.  If a copy of the IKJTABLS load module         *\n*                       containing csects IKJEFTE2, IKJEFTE8,         *\n*                       IKJEFTAP, and IKJEFTNS is found in an         *\n*                       APF-authorized STEPLIB that the TSO session   *\n*                       has access to (running as an APF authorized   *\n*                       STEPLIB only), then those E2, E8, NS, and AP  *\n*                       tables are copied into the LWA at LOGON       *\n*                       time, from that CSECT in the STEPLIB copy of  *\n*                       IKJTABLS.  Therefore the table entries in     *\n*                       the respective CSECTs of the IKJTABLS in the  *\n*                       authorized STEPLIB are the ones which are in  *\n*                       force for that user's TSO session.  But in    *\n*                       that case, no \"table lengths\" or \"number of   *\n*                       table entries\" from these tables, are         *\n*                       available.  The table is delimited by the     *\n*                       first blank entry in it.  This TSUB program   *\n*                       has the ability to blank any numbered table   *\n*                       entry.  Since a blank entry is a delimiter    *\n*                       for the entire table, and all entries after   *\n*                       the blank entry are no longer used, you       *\n*                       have to be very careful.  Therefore, when     *\n*                       blanking entries, you should usually blank    *\n*                       the last one only, unless you have a very     *\n*                       good reason to blank out a different entry,   *\n*                       other than the last one.  The good news is    *\n*                       that the effect of the TSUB program only      *\n*                       lasts for the duration of this LOGON, and     *\n*                       only for the userid that is currently running *\n*                       the TSUB program.                             *\n*                                                                     *\n*                       Again, use \"nullify\" (action \"N\") instead     *\n*                       of \"blank\" (action \"B\") most of the time.     *\n*                                                                     *\n*            Note - Tables copied from a CSECT in IKJTABLS do not     *\n*                   have lengths associated with them.  They are      *\n*                   delimited by a blank table entry at the end.      *\n*                   Therefore the copy of each such table pointed     *\n*                   to by the LWA, does not have any length           *\n*                   associated with it.  Therefore we can only        *\n*                   judge its length by looking at the first blank    *\n*                   entry that has been found by a forward scan.      *\n*                                                                     *\n*                   This program, TSUB, directly manipulates the      *\n*                   \"live\" authorization tables pointed to by the     *\n*                   LWA.  Supported tables are:  E2, E2, NS and       *\n*                   AP.  The public PP (Platform Program) table       *\n*                   and PC (Platform Command) table, not in the       *\n*                   LWA, are partly supported by this program, if     *\n*                   they had been created by their presence in the    *\n*                   active IKJTSOxx PARMLIB member.                   *\n*                                                                     *\n*    Description:   Display an Auth Table entry from any of the       *\n*                   TSO/E program list tables:  IKJEFTE2, IKJEFTE8,   *\n*                   IKJEFTNS or IKJEFTAP that are in storage.  Or     *\n*                   display the entire table.  Or replace a numbered  *\n*                   entry with a new program name.  Or blank out      *\n*                   any numbered entry.  (Be very careful if you are  *\n*                   attempting to blank an entry.  Blanking an entry  *\n*                   invalidates ALL subsequent entries).  Or          *\n*                   effectively nullify an entry by putting a ?       *\n*                   (queston mark and 7 blanks) into it.  If you are  *\n*                   invoking a display function, then the entire      *\n*                   table is shown, unless you enter a number, and    *\n*                   then, only that slot is shown.  The tables        *\n*                   handled by this program are the actual tables     *\n*                   pointed to by the LWA of the issuing TSO/E        *\n*                   address space, and they lie in that user's        *\n*                   TSO/E address space (unless they were pointed to, *\n*                   and are from an IKJTABLS load module that is in   *\n*                   the LPA list.)                                    *\n*                                                                     *\n*       Function:   To substitute one new program name in the local   *\n*                   incore TSO auth tables, IKJEFTE2, IKJEFTE8, or    *\n*                   IKJEFTAP, IKJEFTNS lists.  This is done to any    *\n*                   numbered entry of each table.  Or else merely to  *\n*                   display the contents of the entire table, or the  *\n*                   contents of any particular numbered entry.        *\n*                                                                     *\n*                   The effect of replacing any program name is       *\n*                   immediate.  The scope of the change, is just for  *\n*                   the issuing current TSO userid.                   *\n*                                                                     *\n*                   You can blank out any numbered entry in any of    *\n*                   the four tables.  But blanking an entry, will     *\n*                   invalidate all subsequent table entries which     *\n*                   follow the blanked entry slot.  So be careful!    *\n*                                                                     *\n*                   Better than blanking an entry, you can \"nullify\"  *\n*                   an entry, which inserts a \"?\" character into the  *\n*                   table entry instead of blanks.  The subsequent    *\n*                   table entries remain valid.  The \"nullify\"        *\n*                   function is \"N\".  The \"blanking\" function is      *\n*                   \"B\".                                              *\n*                                                                     *\n*                   Or, you can use this program to list the complete *\n*                   contents of any of the auth tables which are      *\n*                   incore.                                           *\n*                                                                     *\n*                   Additionally, as described below, you can change  *\n*                   fields in the LWA which characterize the          *\n*                   individual tables--size characteristics and       *\n*                   whether or not the table came from STEPLIB.       *\n*                                                                     *\n*         Syntax:   TSUB ttA nnn pgmname                              *\n*                                                                     *\n*                   Where tt is a table code, and A is an action      *\n*                   code.                                             *\n*                                                                     *\n*                   The table code is a nickname for any of the       *\n*                   TSO/E auth tables which are incore.  They are:    *\n*                                                                     *\n*                   E2 - IKJEFTE2 = AUTHCMD  entry in IKJTSOxx        *\n*                   E8 - IKJEFTE8 = AUTHPGM  entry in IKJTSOxx        *\n*                   AP - IKJEFTAP = AUTHTSF  entry in IKJTSOxx        *\n*                   NS - IKJEFTNS = NOTBKGND entry in IKJTSOxx        *\n*                   PP -            PLATPGM  table in IKJTSOxx        *\n*                   PC -            PLATCMD  table in IKJTSOxx        *\n*                                                                     *\n*                   If the action code is B (blank the numbered       *\n*                   entry), then no program name is required,         *\n*                   but a number is required.  When blanking a        *\n*                   table entry, BE VERY CAREFUL !!!!!                *\n*                                                                     *\n*                   If the action code is N (nullify the numbered     *\n*                   entry), then no program name is required,         *\n*                   but a number is required.  Nullifying a table     *\n*                   entry will insert a \"?\" (question mark) into      *\n*                   that particular table slot, effectively           *\n*                   nullifying that entry, but NOT the entries        *\n*                   which follow, since blanks are the table          *\n*                   delimiters.                                       *\n*                                                                     *\n*     IMPORTANT  >  Under most circumstances, you should use the      *\n*       N O T E  >  \"nullify\" function \"N\" instead of the \"blanking\"  *\n*                >  function \"B\".  N will only nullify that one       *\n*                >  table entry, leaving all subsequent entries       *\n*                >  valid.  Blanking an entry will leave all          *\n*                >  subsequent table entries invalid.                 *\n*                                                                     *\n*       WARNING  >  If you blank out an entry which is not the        *\n*       WARNING  >  last entry in the particular table, then          *\n*       WARNING  >  all subsequent entries in that table are          *\n*       WARNING  >  rendered invalid!  It is best to restore          *\n*       WARNING  >  a non-blank entry to that slot, using the         *\n*       WARNING  >  ttR function, where tt is the table code.         *\n*                   Then you will be able to display the rest         *\n*                   of the table using the ttD function.              *\n*                                                                     *\n*                   If the action code is D (display the given        *\n*                   entry), then no program name is required.         *\n*                   The default action is to display the entire       *\n*                   table, unless a number is entered.  If a          *\n*                   number is present, then only that entry           *\n*                   number is displayed.  If the number is larger     *\n*                   than the number of entries in that particular     *\n*                   table, then an informative error message is       *\n*                   issued, and the program ends with code = 4.       *\n*                                                                     *\n*                   If the action code is R (replace the program      *\n*                   name) then a number (the table entry number)      *\n*                   and a program name are required.  If you want     *\n*                   to blank that slot, instead of putting a          *\n*                   program name into it, then use action code B.     *\n*                   But if you are blanking any slot which is not     *\n*                   the last slot, then PLEASE HEED THE WARNING       *\n*                   THAT IS ABOVE.  Use action \"N\" instead of \"B\"     *\n*                   most of the time.  This will not invalidate       *\n*                   subsequent table entries.                         *\n*                                                                     *\n*                   If the action code is H, then TSUB will replace   *\n*                   the last 8 bytes of the table header with the     *\n*                   literal: C' PARMLIB', as if the table were        *\n*                   created from the IKJTSOxx member in PARMLIB.      *\n*                                                                     *\n*                   If the action code is L, then TSUB will look to   *\n*                   create a length value for that table.  This value *\n*                   is equal to the length of a table with all the    *\n*                   non-blank entries, plus all the potential blank   *\n*                   entries at the end of the table.  So this number  *\n*                   will often reflect more entries than TSO will     *\n*                   actually use.  Additionally, TSUB can change or   *\n*                   blank any one of these entries, because TSUB's    *\n*                   range depends on the number of entries indicated  *\n*                   by the LWA length.  (If there's no length, then   *\n*                   TSUB uses the length of all non-blank entries     *\n*                   plus the first blank, if it exists.)              *\n*                                                                     *\n*                   If the action code is M, then TSUB will look to   *\n*                   create a length value for that table.  This value *\n*                   is equal to the length of a table with all the    *\n*                   non-blank entries, plus one blank entry, if any   *\n*                   perceived blank entries exist at the end of the   *\n*                   table.                                            *\n*                                                                     *\n*                   If the action code is Z, then TSUB will look at   *\n*                   the LWA length value for that table, and it will  *\n*                   zero that length value, whether it already was    *\n*                   zero, or not.                                     *\n*                                                                     *\n*                   If the action code is S, then TSUB will make      *\n*                   the given table look like it came from STEPLIB,   *\n*                   so that a subsequent PARMLIB UPDATE(xx) command   *\n*                   will not overlay the session's auth table.        *\n*                                                                     *\n*                   If the action code is P, then TSUB will make      *\n*                   the given table look like it came from PARMLIB,   *\n*                   so that a subsequent PARMLIB UPDATE(xx) command   *\n*                   will overlay the session's auth table.            *\n*                                                                     *\n*                   If the action code is X, then TSUB will display   *\n*                   all the LPA address ranges (undocumented).        *\n*                                                                     *\n*                   If the PLATCMD or PLATPGM keywords (and at least  *\n*                   one name) were not coded in the active IKJTSOxx   *\n*                   PARMLIB entry, then there is no control block of  *\n*                   names to be pointed to.  The condition is         *\n*                   reported.  If these keywords WERE coded in the    *\n*                   IKJTSOxx member of PARMLIB which is currently     *\n*                   active, then the PC and PP table codes in TSUB    *\n*                   WILL ACT ON THE COMMON STORAGE COPY of THESE      *\n*                   TWO TABLES ONLY.                                  *\n*                                                                     *\n*  Recommendation:  First list the entire table using the \"D\"         *\n*                   action code, and then decide which entry, by      *\n*                   number, that you want to replace.                 *\n*                                                                     *\n*                   Then use the \"R\" action code, to replace the      *\n*                   particular numbered entry you have chosen.        *\n*                                                                     *\n*            Note:  The E2, E8, AP, or NS table which is being        *\n*                   used by the system, can come from either the      *\n*                   IKJTSOxx PARMLIB entry, or it can come from       *\n*                   an IKJTABLS load module which was running         *\n*                   from an APF authorized library as a STEPLIB,      *\n*                   or a default IKJTABLS entry in LPALIB.  Each      *\n*                   CSECT is copied into the TSO user's address       *\n*                   space, albeit in a protected key, and pointed     *\n*                   to by the user's LWA, except in the case of an    *\n*                   IKJTABLS CSECT that is in LPALIB.  These are      *\n*                   the actual auth tables, E2, E8, AP, NS, in        *\n*                   use by that TSO address space.                    *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                                                                     *\n*  Change Log:                                                        *\n*                                                                     *\n*    2008/09/10 - 1.0 - Initial version - Got it to work.             *\n*                       TSUB can blank any slot.  I'm allowing        *\n*                       that for now, because the scope of the        *\n*                       possible damage is only for that TSO          *\n*                       session as long as it is logged on.           *\n*                       The LWA auth tables are all reset by          *\n*                       logging on to that TSO session again.         *\n*                                                                     *\n*    2008/09/15 - 1.0 - Filled in and cleaned up some of the doc.     *\n*                                                                     *\n*    2009/01/28 - 1.0 - Added action codes: H, L, Z, S, P             *\n*                                                                     *\n*         All action codes except D need APF-authorization.           *\n*                                                                     *\n*         What they do:                                               *\n*                                                                     *\n*            H - Add PARMLIB-like table header, in 2nd 8-bytes.       *\n*            L - Supply length of table in LWA with ALL the blanks.   *\n*            M - Supply length of table to first blank, in LWA.       *\n*            Z - Zero the table length marked in the LWA.             *\n*            S - Mark that the table came from STEPLIB, so            *\n*                 someone (else's) PARMLIB UPDATE(xx) won't           *\n*                 overlay it.                                         *\n*            P - Turn off STEPLIB bit in LWA and mark that it         *\n*                 came from PARMLIB.  Now PARMLIB UPDATE(xx)          *\n*                 will overlay the table.                             *\n*            X - (undocumented) Gives LPA storage range display.      *\n*                                                                     *\n*         Other action codes are: (these are the original ones)       *\n*                                                                     *\n*            D - Display table entries by slot number.                *\n*            R - Replace the entry in a given slot, by another one.   *\n*            B - Blank a given table entry, by slot number.           *\n*            N - Nullify a given table entry, by slot number.         *\n*                 (It works by inserting a ? (question mark)          *\n*                  into that table slot.)                             *\n*                                                                     *\n*    2009/02/01 - 1.1 - Fourth and fifth base registers.              *\n*                                                                     *\n*         Improved message clarity.  Told messages to show states,    *\n*          \"before\" and \"after\" any changes were made.                *\n*                                                                     *\n*    2009/02/12 -1.1.26 Fix bug in calculating length of NS table.    *\n*         Fix convoluted logic in calculating table lengths.          *\n*                                                                     *\n*    2009/02/13 -1.1.27 Measure perceived blanks after logical end    *\n*         of the table.  For NS table, blank an entry with X'0000'    *\n*         for the \"length\" field, instead of X'FFFF', to see more     *\n*         perceived blanks, if there are any.                         *\n*                                                                     *\n*    2009/02/16 -1.1.29 Added option M to tailor length to reflect    *\n*         only up to the first blank.  Changed option L to make the   *\n*         LWA length equal to all non-blank entries plus all blank    *\n*         entries too.  Thus the table can be expanded, even if       *\n*         lengths are there.                                          *\n*                                                                     *\n*    2009/02/18 -1.1.31 Cosmetic changes. Put in Version numbers.     *\n*                                                                     *\n*    2009/02/20 -1.1.32 Improved displays for PC and PP tables.       *\n*                       Made sure S,P,H,L,M,Z options for PC and PP   *\n*                       actually do nothing, and say they do nothing. *\n*                       Made \"error display\" messages better.         *\n*                                                                     *\n*    2009/02/24 -1.1.33 Better messages if PLATPGM or PLATCMD tables  *\n*                       are missing.                                  *\n*                                                                     *\n*    2009/03/03 -1.1.34 More cosmetic changes in title & messages.    *\n*                                                                     *\n*    2011/03/24 -1.1.37 If an installation has an \"authorization SVC\" *\n*                       already installed, put in a provision to use  *\n*                       it with conditional assembly.  Of course,     *\n*                       you have to code your own appropriate         *\n*                       invocation code for the SVC, and its number,  *\n*                       in the AUTHON and AUTHOFF macros provided     *\n*                       in this code here.  Otherwise, SETC the &SVC  *\n*                       variable to 'NOSVC'                           *\n*                                                                     *\n*    2016/10/30 -1.1.38 A Blanking function on a table entry will     *\n*                       invalidate all subsequent table entries.      *\n*                       So I introduced a \"nullify\" function \"N\"      *\n*                       which will put a question mark, followed      *\n*                       by seven blanks, into a table entry,          *\n*                       effectively nullifying that entry, without    *\n*                       nullifying all the following entries too.     *\n*                                                                     *\n*    2016/12/07 -1.1.39 Describe the nullify function in HELP.        *\n*                                                                     *\n*    2017/04/21 -1.1.40 Cosmetic + Save parms only after second       *\n*                       base was loaded.  SAVEPARM location           *\n*                       is > +X'1000' off program start.              *\n*                                                                     *\n***********************************************************************\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSUBQUIK": {"ttr": 23556, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01(\\x00\\x12\\x01\\t4O\\x01\\x17\\x11?\\x015\\x00\\x19\\x00\\x1a\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.40", "flags": 0, "createdate": "2009-12-10T00:00:00", "modifydate": "2017-04-23T01:35:12", "lines": 25, "newlines": 26, "modlines": 0, "user": "HELP"}, "text": "TSUB Command - Display/Change USERID Auth Table Entry - Ver 1.40\n---- -------   ------- ------ ------ ---- ----- -----   --------\nttA            Program table code + Function code\n\n  Instructions to use this program:\n  ------------ -- --- ---- -------\nTSUB TTA nnn pgmname (nnn optional for D, both required for R)\n  Supply a table code TT, followed by an action code A.\n\nValid table  codes are:  E2, E8, AP, NS, PC, PP.\nValid action codes are:  R - replace, B - blank, D - display,\n  H - header, L - supply full table length, Z - zero table length,\n  S - mark table from STEPLIB, P - mark table from PARMLIB,\n  X - display LPA storage ranges, M - supply minimum table length.\n  N - nullify a single entry without invalidating subsequent entries.\nFull command is in the form TTA, TT=table code, A=action code.\n\nIf D (display) is followed by a slot number, only that slot is shown.\nIf D is not followed by a number, then the entire table is displayed.\nR (replace) requires a slot number, followed by a program name.\nB (blank) blanks the slot number given. Higher slots are invalidated.\nN (nullify) invalidates that slot number. Higher slots remain valid.\nCodes: D,H,L,M,Z,P,S,X do not require extra parameters.\nD does not need APF authorization. All other codes require it.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSUB36": {"ttr": 23558, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01$\\x00@\\x01\\x06\\x01\\x8f\\x01\\t\\x08o\\x18&\\r\\x15\\x04)\\x00\\x00\\xd6\\xd3\\xc4\\xe2\\xd9\\xc3\\xc5@@@'", "ispf": {"version": "01.36", "flags": 0, "createdate": "2006-01-18T00:00:00", "modifydate": "2009-03-27T18:26:40", "lines": 3349, "newlines": 1065, "modlines": 0, "user": "OLDSRCE"}, "text": "TSUB     TITLE 'TSUB - MAINTAIN LWA-POINTED-TO INCORE TSO AUTH TABLES'\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   Program Name:   TSUB                                              *\n*                                                                     *\n*  Documentation:   This program is meant to be run as a TSO          *\n*                   command, APF authorized except for the display    *\n*                   functions.                                        *\n*                                                                     *\n*    Environment:   TSO command, APF Authorized.                      *\n*                   PUTLINE interface enabled by APUT, EPUTL.         *\n*                   This program is non-reentrant.                    *\n*                                                                     *\n* Short Function:   This program deals with existing TSO \"auth\"       *\n*                   tables that are pointed to by fields in the       *\n*                   LWA (Logon Work Area) which is created for a      *\n*                   TSO session at LOGON time.  These tables are      *\n*                   the actual tables that your TSO session uses      *\n*                   to determine program authorization.  Many of      *\n*                   the characteristics of these tables can be        *\n*                   changed or reset by the TSUB program.  The        *\n*                   changes that TSUB can do, are of two types:       *\n*                                                                     *\n*                   1.  Replacing or blanking any table entry.        *\n*                   2.  Altering the LWA flags or fields that         *\n*                       determine this table's properties.            *\n*                                                                     *\n*                Details:                                             *\n*                                                                     *\n*                   1.  TSUB can substitute a different program name  *\n*                       or insert a blank entry into any valid slot   *\n*                       of a TSO \"auth\" table that belongs to your    *\n*                       TSO session.                                  *\n*                                                                     *\n*                       Blanking (not the last entry) is dangerous    *\n*                       (see below) because it invalidates all the    *\n*                       subsequent non-blank table entries.  But the  *\n*                       technique of blanking an entry can be used    *\n*                       carefully if you are sure of what you want    *\n*                       to accomplish.                                *\n*                                                                     *\n*                   2.  TSUB can change the characteristics of your   *\n*                       own session's TSO \"auth\" tables, that are     *\n*                       pointed to by the LWA, by means of changing   *\n*                       the LWA (Logon Work Area) settings for each   *\n*                       table.  For example, LWA table lengths can    *\n*                       be supplied or removed.  LWA flags marking    *\n*                       the table as coming from a STEPLIB can be     *\n*                       set, or removed.  Even the physical table     *\n*                       header can be altered to make the table       *\n*                       look as though it came from PARMLIB.          *\n*                                                                     *\n*   Introduction:   At LOGON time for a TSO session, the system       *\n*                   copies a set of the E2, E8, AP, and NS TSO        *\n*                   authorization tables into SP 252 protected Key 0  *\n*                   storage which lies in the TSO user's address      *\n*                   space.  These are the tables WHICH ARE ACTUALLY   *\n*                   USED by that TSO session, and their location is   *\n*                   pointed to in the LWA control block (Logon Work   *\n*                   Area).  The duration of these tables is for the   *\n*                   life of that TSO session.  TSO LOGON processing   *\n*                   creates both the LWA itself, and the copies of    *\n*                   the auth tables that are used. TSUB displays and  *\n*                   manipulates this copy of these tables--the ones   *\n*                   that are actually in use. Thus, changes to these  *\n*                   tables are effective immediately, and their       *\n*                   scope affects only the issuing TSO session.       *\n*                                                                     *\n*                   Where does TSO get these tables from, at LOGON    *\n*                   time?                                             *\n*                                                                     *\n*              Case 1.  The most commonly found source for the auth   *\n*                       tables pointed to in the LWA, is the \"common  *\n*                       storage\" tables created from the active       *\n*                       PARMLIB member IKJTSOxx.  Those are pointed   *\n*                       to by the TPVT control block + X'14' which    *\n*                       is the CTLT.  If the CTLT is the source of    *\n*                       the LWA tables, then lengths of the tables,   *\n*                       and the size of each entry, are copied from   *\n*                       the CTLT into the LWA (Logon Work Area).      *\n*                       Use the program called ASUB to directly       *\n*                       access the public tables from PARMLIB that    *\n*                       are pointed to by the CTLT (undocumented)     *\n*                       control block.  Our program, TSUB, accesses   *\n*                       the copy of those tables which is pointed to  *\n*                       by the LWA, which were created for the TSO    *\n*                       session at LOGON time, and which are unique   *\n*                       to the current TSO session.                   *\n*                                                                     *\n*              Case 2.  If a list of table entries for one or more    *\n*                       of the tables:  E2, E8, AP, or NS is not      *\n*                       found in the IKJTSOxx PARMLIB member that     *\n*                       is currently active, then the table in the    *\n*                       LWA is not copied from the IKJTABLS module    *\n*                       in LPALIB, but it is just pointed to.  Thus   *\n*                       in such a situation, TSUB cannot alter the    *\n*                       particular table.  The actual table is        *\n*                       located in PLPA, in that particular case.     *\n*                                                                     *\n*              Case 3.  If a copy of the IKJTABLS load module         *\n*                       containing csects IKJEFTE2, IKJEFTE8,         *\n*                       IKJEFTAP, and IKJEFTNS is found in an         *\n*                       APF-authorized STEPLIB that the TSO session   *\n*                       has access to (running as an APF authorized   *\n*                       STEPLIB only), then those E2, E8, NS, and AP  *\n*                       tables are copied into the LWA at LOGON       *\n*                       time, from that CSECT in the STEPLIB copy of  *\n*                       IKJTABLS.  Therefore the table entries in     *\n*                       the respective CSECTs of the IKJTABLS in the  *\n*                       authorized STEPLIB are the ones which are in  *\n*                       force for that user's TSO session.  But in    *\n*                       that case, no \"table lengths\" or \"number of   *\n*                       table entries\" from these tables, are         *\n*                       available.  The table is delimited by the     *\n*                       first blank entry in it.  This TSUB program   *\n*                       has the ability to blank any numbered table   *\n*                       entry.  Since a blank entry is a delimiter    *\n*                       for the entire table, and all entries after   *\n*                       the blank entry are no longer used, you       *\n*                       have to be very careful.  Therefore, when     *\n*                       blanking entries, you should usually blank    *\n*                       the last one only, unless you have a very     *\n*                       good reason to blank out a different entry,   *\n*                       other than the last one.  The good news is    *\n*                       that the effect of the TSUB program only      *\n*                       lasts for the duration of this LOGON, and     *\n*                       only for the userid that is currently running *\n*                       the TSUB program.                             *\n*                                                                     *\n*            Note - Tables copied from a CSECT in IKJTABLS do not     *\n*                   have lengths associated with them.  They are      *\n*                   delimited by a blank table entry at the end.      *\n*                   Therefore the copy of each such table pointed     *\n*                   to by the LWA, does not have any length           *\n*                   associated with it.  Therefore we can only        *\n*                   judge its length by looking at the first blank    *\n*                   entry that has been found by a forward scan.      *\n*                                                                     *\n*                   This program, TSUB, directly manipulates the      *\n*                   \"live\" authorization tables pointed to by the     *\n*                   LWA.  Supported tables are:  E2, E2, NS and       *\n*                   AP.  The public PP (Platform Program) table       *\n*                   and PC (Platform Command) table, not in the       *\n*                   LWA, are also supported by this program, if       *\n*                   they had been created by their presence in the    *\n*                   active IKJTSOxx PARMLIB member.                   *\n*                                                                     *\n*    Description:   Display an Auth Table entry from any of the       *\n*                   TSO/E program list tables:  IKJEFTE2, IKJEFTE8,   *\n*                   IKJEFTNS or IKJEFTAP that are in storage.  Or     *\n*                   display the entire table.  Or replace a numbered  *\n*                   entry with a new program name.  Or blank out      *\n*                   any numbered entry.  (Be very careful if you are  *\n*                   attempting to blank an entry.  Blanking an entry  *\n*                   invalidates ALL subsequent entries).  If you are  *\n*                   invoking a display function, then the entire      *\n*                   table is shown, unless you enter a number, and    *\n*                   then, only that slot is shown.  The tables        *\n*                   handled by this program are the actual tables     *\n*                   pointed to by the LWA of the issuing TSO/E        *\n*                   address space, and they lie in that user's        *\n*                   TSO/E address space (unless they were pointed to, *\n*                   and are from an IKJTABLS load module that is in   *\n*                   the LPA list.)                                    *\n*                                                                     *\n*       Function:   To substitute one new program name in the local   *\n*                   incore TSO auth tables, IKJEFTE2, IKJEFTE8, or    *\n*                   IKJEFTAP, IKJEFTNS lists.  This is done to any    *\n*                   numbered entry of each table.  Or else merely to  *\n*                   display the contents of the entire table, or the  *\n*                   contents of any particular numbered entry.        *\n*                                                                     *\n*                   The effect of replacing any program name is       *\n*                   immediate.  The scope of the change, is just for  *\n*                   the issuing current TSO userid.                   *\n*                                                                     *\n*                   You can blank out any numbered entry in any of    *\n*                   the four tables.  But blanking an entry, will     *\n*                   invalidate all subsequent table entries which     *\n*                   follow the blanked entry slot.  So be careful!    *\n*                                                                     *\n*                   Or, you can use this program to list the complete *\n*                   contents of any of the auth tables which are      *\n*                   incore.                                           *\n*                                                                     *\n*                   Additionally, as described below, you can change  *\n*                   fields in the LWA which characterize the          *\n*                   individual tables--size characteristics and       *\n*                   whether or not the table came from STEPLIB.       *\n*                                                                     *\n*         Syntax:   TSUB ttA nnn pgmname                              *\n*                                                                     *\n*                   Where tt is a table code, and A is an action      *\n*                   code.                                             *\n*                                                                     *\n*                   The table code is a nickname for any of the       *\n*                   TSO/E auth tables which are incore.  They are:    *\n*                                                                     *\n*                   E2 - IKJEFTE2 = AUTHCMD  entry in IKJTSOxx        *\n*                   E8 - IKJEFTE8 = AUTHPGM  entry in IKJTSOxx        *\n*                   AP - IKJEFTAP = AUTHTSF  entry in IKJTSOxx        *\n*                   NS - IKJEFTNS = NOTBKGND entry in IKJTSOxx        *\n*                                                                     *\n*                   If the action code is B (blank the numbered       *\n*                   entry), then no program name is required,         *\n*                   but a number is required.  When blanking a        *\n*                   table entry, BE VERY CAREFUL !!!!!                *\n*                                                                     *\n*       WARNING  >  If you blank out an entry which is not the        *\n*       WARNING  >  last entry in the particular table, then          *\n*       WARNING  >  all subsequent entries in that table are          *\n*       WARNING  >  rendered invalid!  It is best to restore          *\n*       WARNING  >  a non-blank entry to that slot, using the         *\n*       WARNING  >  ttR function, where tt is the table code.         *\n*                   Then you will be able to display the rest         *\n*                   of the table using the ttD function.              *\n*                                                                     *\n*                   If the action code is D (display the given        *\n*                   entry), then no program name is required.         *\n*                   The default action is to display the entire       *\n*                   table, unless a number is entered.  If a          *\n*                   number is present, then only that entry           *\n*                   number is displayed.  If the number is larger     *\n*                   than the number of entries in that particular     *\n*                   table, then an informative error message is       *\n*                   issued, and the program ends with code = 4.       *\n*                                                                     *\n*                   If the action code is R (replace the program      *\n*                   name) then a number (the table entry number)      *\n*                   and a program name are required.  If you want     *\n*                   to blank that slot, instead of putting a          *\n*                   program name into it, then use action code B.     *\n*                   But if you are blanking any slot which is not     *\n*                   the last slot, then PLEASE HEED THE WARNING       *\n*                   THAT IS ABOVE.                                    *\n*                                                                     *\n*                   If the action code is H, then TSUB will replace   *\n*                   the last 8 bytes of the table header with the     *\n*                   literal: C' PARMLIB', as if the table were        *\n*                   created from the IKJTSOxx member in PARMLIB.      *\n*                                                                     *\n*                   If the action code is L, then TSUB will look to   *\n*                   create a length value for that table.  This value *\n*                   is equal to the length of a table with all the    *\n*                   non-blank entries, plus all the potential blank   *\n*                   entries at the end of the table.  So this number  *\n*                   will often reflect more entries than TSO will     *\n*                   actually use.  Additionally, TSUB can change or   *\n*                   blank any one of these entries, because TSUB's    *\n*                   range depends on the number of entries indicated  *\n*                   by the LWA length.  (If there's no length, then   *\n*                   TSUB uses the length of all non-blank entries     *\n*                   plus the first blank, if it exists.)              *\n*                                                                     *\n*                   If the action code is M, then TSUB will look to   *\n*                   create a length value for that table.  This value *\n*                   is equal to the length of a table with all the    *\n*                   non-blank entries, plus one blank entry, if any   *\n*                   perceived blank entries exist at the end of the   *\n*                   table.                                            *\n*                                                                     *\n*                   If the action code is Z, then TSUB will look at   *\n*                   the LWA length value for that table, and it will  *\n*                   zero that length value, whether it already was    *\n*                   zero, or not.                                     *\n*                                                                     *\n*                   If the action code is S, then TSUB will make      *\n*                   the given table look like it came from STEPLIB,   *\n*                   so that a subsequent PARMLIB UPDATE(xx) command   *\n*                   will not overlay the session's auth table.        *\n*                                                                     *\n*                   If the action code is P, then TSUB will make      *\n*                   the given table look like it came from PARMLIB,   *\n*                   so that a subsequent PARMLIB UPDATE(xx) command   *\n*                   will overlay the session's auth table.            *\n*                                                                     *\n*                   If the action code is X, then TSUB will display   *\n*                   all the LPA address ranges (undocumented).        *\n*                                                                     *\n*                   If the PLATCMD or PLATPGM keywords (and at least  *\n*                   one name) were not coded in the active IKJTSOxx   *\n*                   PARMLIB entry, then there is no control block of  *\n*                   names to be pointed to.  The condition is         *\n*                   reported.  If these keywords WERE coded in the    *\n*                   IKJTSOxx member of PARMLIB which is currently     *\n*                   active, then the PC and PP table codes in TSUB    *\n*                   WILL ACT ON THE COMMON STORAGE COPY of THESE      *\n*                   TWO TABLES ONLY.                                  *\n*                                                                     *\n*  Recommendation:  First list the entire table using the \"D\"         *\n*                   action code, and then decide which entry, by      *\n*                   number, that you want to replace.                 *\n*                                                                     *\n*                   Then use the \"R\" action code, to replace the      *\n*                   particular numbered entry you have chosen.        *\n*                                                                     *\n*            Note:  The E2, E8, AP, or NS table which is being        *\n*                   used by the system, can come from either the      *\n*                   IKJTSOxx PARMLIB entry, or it can come from       *\n*                   an IKJTABLS load module which was running         *\n*                   from an APF authorized library as a STEPLIB,      *\n*                   or a default IKJTABLS entry in LPALIB.  Each      *\n*                   CSECT is copied into the TSO user's address       *\n*                   space, albeit in a protected key, and pointed     *\n*                   to by the user's LWA, except in the case of an    *\n*                   IKJTABLS CSECT that is in LPALIB.  These are      *\n*                   the actual auth tables, E2, E8, AP, NS, in        *\n*                   use by that TSO address space.                    *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  Change Log:                                                        *\n*    2008/09/10 - 1.0 - Initial version - Got it to work.             *\n*                       TSUB can blank any slot.  I'm allowing        *\n*                       that for now, because the scope of the        *\n*                       possible damage is only for that TSO          *\n*                       session as long as it is logged on.           *\n*                       The LWA auth tables are all reset by          *\n*                       logging on to that TSO session again.         *\n*                                                                     *\n*    2008/09/15 - 1.0 - Filled in and cleaned up some of the doc.     *\n*                                                                     *\n*    2009/01/28 - 1.0 - Added action codes: H, L, Z, S, P             *\n*                                                                     *\n*         All action codes except D need APF-authorization.           *\n*                                                                     *\n*         What they do:                                               *\n*                                                                     *\n*            H - Add PARMLIB-like table header, in 2nd 8-bytes.       *\n*            L - Supply length of table in LWA with ALL the blanks.   *\n*            M - Supply length of table to first blank, in LWA.       *\n*            Z - Zero the table length marked in the LWA.             *\n*            S - Mark that the table came from STEPLIB, so            *\n*                 someone (else's) PARMLIB UPDATE(xx) won't           *\n*                 overlay it.                                         *\n*            P - Turn off STEPLIB bit in LWA and mark that it         *\n*                 came from PARMLIB.  Now PARMLIB UPDATE(xx)          *\n*                 will overlay the table.                             *\n*            X - (undocumented) Gives LPA storage range display.      *\n*                                                                     *\n*         Other action codes are: (these are the original ones)       *\n*                                                                     *\n*            D - Display table entries by slot number.                *\n*            R - Replace the entry in a given slot, by another one.   *\n*            B - Blank a given table entry, by slot number.           *\n*                                                                     *\n*    2009/02/01 - 1.1 - Fourth and fifth base registers.              *\n*                                                                     *\n*         Improved message clarity.  Told messages to show states,    *\n*          \"before\" and \"after\" any changes were made.                *\n*                                                                     *\n*    2009/02/12 - 1.1 - Fix bug in calculating length of NS table.    *\n*         Fix convoluted logic in calculating table lengths.          *\n*                                                                     *\n*    2009/02/13 - 1.1 - Measure perceived blanks after logical end    *\n*         of the table.  For NS table, blank an entry with X'0000'    *\n*         for the \"length\" field, instead of X'FFFF', to see more     *\n*         perceived blanks, if there are any.                         *\n*                                                                     *\n*    2009/02/16 - 1.1 - Added option M to tailor length to reflect    *\n*         only up to the first blank.  Changed option L to make the   *\n*         LWA length equal to all non-blank entries plus all blank    *\n*         entries too.  Thus the table can be expanded, even if       *\n*         lengths are there.                                          *\n*                                                                     *\n*    2009/02/18 -1.1.31 Cosmetic changes. Put in Version numbers.     *\n*                                                                     *\n*    2009/02/20 -1.1.32 Improved displays for PC and PP tables.       *\n*                       Made sure S,P,H,L,M,Z options for PC and PP   *\n*                       actually do nothing, and say they do nothing. *\n*                       Made \"error display\" messages better.         *\n*                                                                     *\n*    2009/02/24 -1.1.33 Better messages if PLATPGM or PLATCMD tables  *\n*                       are missing.                                  *\n*                                                                     *\n*    2009/03/03 -1.1.34 More cosmetic changes in title & messages.    *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n***********************************************************************\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*       I N S T R E A M    M A C R O S                                *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n***********************************************************************\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         YREGS\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.\n*  ---------------------------------------------------------------  *\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         STM   R15,R1,HEXSAVE\n         LA    R1,&FROM\n         LA    R0,&LEN\n         LA    R15,&TO\n         BAL   R9,HEX\n         LM    R15,R1,HEXSAVE\n         MEND\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* ------------------------------------------------------------------- *\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\nTSUB     CSECT\nTSUB     AMODE 31\nTSUB     RMODE 24\n         USING *,R15                                                  *\n         B     BEGINN               Eyecatcher\nMAXBLANK DC    F'120'        Guess of max number of blanks after table\n         DC    CL5'TSUB '\nVERS#    DC    CL10'Ver 1.35'\n         DC    CL18' - &SYSDATE &SYSTIME '\nBEGINN   DS    0H\n         DROP  R15\n         USING TSUB,R12,R11,R10,R6,R7  Set up base registers.\n         STM   R14,R12,12(R13)\n         LR    R12,R15                 Set up base registers.\n         ST    R1,SAVEPARM          Save CPPL pointer to use later.\n         LA    R11,4095(,R12)       Second base.\n         LA    R11,1(,R11)\n         LA    R10,4095(,R11)       Third base.\n         LA    R10,1(,R10)\n         LA    R6,4095(,R10)        Fourth base.\n         LA    R6,1(,R6)\n         LA    R7,4095(,R6)         Fifth base.\n         LA    R7,1(,R7)\n         LA    R1,SAVEAREA          Point to new save area\n         ST    R1,8(,R13)           Forward save area chain pointer\n         ST    R13,4(,R1)           Backward save area chain pointer\n         LR    R13,R1               New save area address\n         B     INITCON              Branch past save area\n         SPACE 1\n* -----------------------\nSAVEAREA DC    18F'0'               Non-reentrant save area\n* -----------------------\nINITCON  DS    0H                   Initialize constants to be sure.\n         MVI   OFFFLAG,X'00'\n         MVI   PLATFLG,X'00'\n         MVI   MEASFLG,X'00'\n         MVI   LPAFLAG,X'00'\n         MVI   SHBLFLG,X'00'\n         MVI   LPADFLG,X'00'\n         MVI   NSCHFLG,X'00'\n         MVI   HAVLFLG,X'00'\n         MVI   LWAPFLG,X'00'\n         MVI   LWAMFLG,X'00'\n         MVI   TIDFLAG,X'00'\n         MVI   OLDFLAG,X'00'\n         MVI   FLAGZ,X'00'\n         MVI   LINEB,X'40'\n         MVI   LINAB,X'40'\n         XC    FSTCOUNT,FSTCOUNT\n         XC    FSTNOUNT,FSTNOUNT\n         MVC   FSTFIELD(8),BLANKS\n         MVI   BLANKS-1,X'40'\n         MVC   BLANKS,BLANKS-1\n         MVC   CODEPLAC(2),BLANKS\n         MVC   DISPHDR(16),BLANKS\n         XC    SLOTBIN,SLOTBIN\n         XC    BLNKCNT,BLNKCNT\n         XC    NTRYCNT,NTRYCNT\n         XC    SAVETCUR,SAVETCUR\n         MVC   SLOTSAVE,BLANKS\n         MVC   FSTNAME,BLANKS\n         MVI   CMDBCOPY-1,X'00'\n         MVC   CMDBCOPY,CMDBCOPY-1\n* -----------------------\nGETPSCB  DS    0H                  See if we are allowed to\n*                                  run this program.\n         L     R2,16               POINT TO CVT.\n         L     R2,0(,R2)           POINT TO TCB/ASCB WORDS\n         L     R2,4(,R2)           POINT TO TCB.\n         L     R2,X'B4'(,R2)       POINT TO JSCB.\n         L     R2,X'108'(,R2)      POINT TO PSCB.\n         LA    R2,0(,R2)           CLEAR HIGH BYTE.\n         LTR   R2,R2               ANY PSCB?\n         BZ    EOJ4                GET OUT.  NOT TSO.\n         L     R1,SAVEPARM         Get the address of the CPPL back\n         USING CPPL,R1\n         L     R0,CPPLUPT          Copy CPPL fields for possible\n         ST    R0,SAVEUPT            later use, if needed.\n         L     R0,CPPLPSCB\n         ST    R0,SAVEPSCB\n         L     R0,CPPLECT\n         ST    R0,SAVEECT\n         DROP  R1\n         BAL   R9,PGMTITLE         First display the program title.\n         USING PSCB,R2\nCHEKAUTH DS    0H\n         NOP   GETLWA              Zap to bypass authorization check\n         TM    PSCBATR1,PSCBACCT   ACCT user?\n         BO    GETLWA              Yes.  Continue.\n         TM    PSCBATR1,PSCBCTRL   OPER user?\n         BZ    EOJ4                No.  Get out.\n         DROP  R2\n***** ----- >>>>>\nGETLWA   DS    0H                  Obtain all the relevant fields\n*                                  from the LWA (Logon Work Area)\n         L     R2,X'224'           Point to PSAAOLD\n         L     R2,X'6C'(,R2)       Point to ASXB\n         L     R2,X'14'(,R2)       Point to LWA\n         ST    R2,LWAADDR          Store LWA address\n         USING LWA,R2\n* ------------------------------------------------------------------ *\n*    Save all the relevant information from the LWA, to use later.   *\n* ------------------------------------------------------------------ *\n         ST    R5,SAVER5B          Store original contents of R5\n         L     R5,LWATNS           Pointer to NS table\n         ST    R5,SAVETNS          Save it.\n         L     R5,LWATE2           Pointer to E2 table\n         ST    R5,SAVETE2          Save it.\n         L     R5,LWATE8           Pointer to E8 table\n         ST    R5,SAVETE8          Save it.\n         L     R5,LWATAP           Pointer to AP table\n         ST    R5,SAVETAP          Save it.\n         XR    R5,R5               Clear register to be double sure.\n         LH    R5,LWATNSLN         Length of NS table if available\n         STH   R5,SAVETNSL         Save whatever was there in program.\n         LTR   R5,R5               Has a size been supplied in the LWA?\n         BZ    NONSSIZE            No\n         OI    LWAMFLG,X'40'       Yes. Indicate that in a flag.\nNONSSIZE DS    0H\n         LH    R5,LWATE2LN         Length of E2 table if available\n         STH   R5,SAVETE2L         Save whatever was there in program.\n         LTR   R5,R5               Has a size been supplied in the LWA?\n         BZ    NOE2SIZE            No\n         OI    LWAMFLG,X'20'       Yes. Indicate that in a flag.\nNOE2SIZE DS    0H\n         LH    R5,LWATE8LN         Length of E8 table if available\n         STH   R5,SAVETE8L         Save whatever was there in program.\n         LTR   R5,R5               Has a size been supplied in the LWA?\n         BZ    NOE8SIZE            No\n         OI    LWAMFLG,X'10'       Yes. Indicate that in a flag.\nNOE8SIZE DS    0H\n         LH    R5,LWATAPLN         Length of AP table if available\n         STH   R5,SAVETAPL         Save whatever was there in program.\n         LTR   R5,R5               Has a size been supplied in the LWA?\n         BZ    NOAPSIZE            No\n         OI    LWAMFLG,X'80'       Yes. Indicate that in a flag.\nNOAPSIZE DS    0H\n         L     R5,SAVER5B          Restore original R5 contents\n         MVC   LWAPFLG,LWAPRMLB    Save flags showing which tables\n*                                  came from STEPLIB, if any.\n         DROP  R2\n* ------------------------------------------------------------------ *\n*    At this point we have finished saving things out of the LWA.    *\n* ------------------------------------------------------------------ *\n*    Now we have to find the LPA boundaries.                         *\n* ------------------------------------------------------------------ *\nLPAINFO  DS    0H\n         BAL   R9,GETLPABD         Get list of LPA storage boundaries.\n* ------------------------------------------------------------------ *\n***** ----- >>>>>  We can handle the public Platform Command and     *\n***** ----- >>>>>  Platform Program tables, if they exist.           *\n* ------------------------------------------------------------------ *\nGETPCPP  DS    0H            Info about Platpgm and Platcmd Tables\n         L     R2,16               Point to CVT\n         L     R2,X'9C'(,R2)       Point to TSVT (TSO Vector Table)\n         L     R2,X'4C'(,R2)       Point to TPVT\n         ST    R2,SAVETPVT         Save TPVT address for later use\n         L     R2,X'14'(,R2)       Point to CTLT control block\n         ST    R2,SAVECTLT         Save CTLT address for later use\n         L     R2,SAVETPVT         Load TPVT address back\n         L     R2,X'34'(,R2)       Point to PLATCMD pointer\n         LTR   R2,R2               Is there any?\n         BZ    NOFCVE              No. Say so.\n         ST    R2,SAVEFCVE         Yes. Store the FCVE pointer away.\n         OI    PLATFLG,X'01'       Indicate that FCVE exists.\nTRYPPVE  DS    0H\n         L     R2,SAVETPVT         Load TPVT address back\n         L     R2,X'40'(,R2)       Point to PLATPGM pointer\n         LTR   R2,R2               Is there any?\n         BZ    NOPPVE              No. Say so.\n         ST    R2,SAVEPPVE         Yes. Store the PPVE pointer away.\n         OI    PLATFLG,X'02'       Indicate that PPVE exists.\nTRYPPVEE DS    0H\n         B     CHKOLVER            Skip over relevant error messages.\n* -------------------------------------------------------------- *\n* ------           Error messages if tables don't exist   ------ *\n* -------------------------------------------------------------- *\nNOFCVE   DS    0H\n         APUT  =C'No PLATCMD table found',22\n         B     TRYPPVE\nNOPPVE   DS    0H\n         APUT  =C'No PLATPGM table found',22\n         B     TRYPPVEE\n* ----------------------------------------------------------------- *\n*    There doesn't seem to be a way to tell from an old INMXPARM    *\n*    control block itself, that it is the old version.  So we use   *\n*    the position of the active PARMLIB member name in the TPVT.    *\n* ----------------------------------------------------------------- *\nCHKOLVER DS    0H\n         L     R2,SAVETPVT         Load TPVT address back.\n         CLC   =C'IKJ',7(R2)       Parmlib member name in old position?\n         BNE   PARMSCAN            No. It's a new TSO/E version\n         OI    OLDFLAG,X'01'       Yes. Flag that the system is old.\n* -------------------------------------------------------------- *\n*    After we got the system information we finally start        *\n*     scanning the TSO command for parms, here.                  *\n* -------------------------------------------------------------- *\nPARMSCAN DS    0H\n         L     R1,SAVEPARM         Original R1 from entry to program.\n         LTR   R1,R1               Any CPPL?\n         BZ    EOJ8                No. Get out.\n         L     R1,0(,R1)           Point to Command Buffer\n         LTR   R1,R1               Any Command Buffer?\n         BZ    EOJ4                Get out if none.\n         LH    R3,0(,R1)           Load length.\n         CH    R3,=H'4'            Anything?\n         BNH   EOJ4                No.  Get out.\n         LR    R5,R3               Length of command + 4\n         ICM   R5,14,FULLZERO      Clear high order 3 bytes.\n         ST    R1,CMBUFAD          Save Command Buffer Address\n         LH    R3,2(,R1)           Load offset.\n         ST    R3,OFFSETSV         Save offset value.\n         SR    R5,R3               Subtract offset from full length+4\n         SH    R5,=H'4'            Correct for length of CMDBUFR header\n*                                  in the command buffer.\n         BC    8,EOJC              Zero, Message\n         BC    5,EOJC              Less, or overflow, out.\n         ST    R5,CMBUFEND         Store away the number of bytes left\n         L     R1,CMBUFAD          Load Command Buffer Address\n*\n* ----  Copy command buffer into pgm's buffer so we can control it.\n*\n         STM   R14,R1,SAVE1401     Now save registers 14 thru 1.\n         XR    R14,R14             Clear R14.\n         LH    R14,0(,R1)          Load full command buffer length.\n         S     R14,=F'5'           Subtract 4 for header, 1 for execute\n         ICM   R14,14,FULLZERO     Ensure cmd buffer smaller than 255\n         EX    R14,COPYCMDB        Copy command into pgm's area.\n         LM    R14,R1,SAVE1401     Restore registers 14 thru 1.\n         B     GOGOGO              Jump over executed instruction.\nCOPYCMDB MVC   CMDBCOPY(0),4(R1)   <<< Executed >>>\nGOGOGO   DS    0H\n* ----\n         LA    R2,3                Load register for BCT loop.\n* >>>\n         LA    R1,CMDBCOPY         Point to command in our buffer\n         A     R1,OFFSETSV         Add offset, point to subcommands\n         ST    R1,CHARSTRT         Store starting point away\n* >>>\n         LR    R4,R1               Initialize pointer\n         LA    R4,0(,R4)           to first character of function name.\n         LA    R8,0                Initialize character count\nCUTIDLEN CLI   0(R4),X'40'         Is this character a blank?\n         BE    AFTFIRST            Yes, end of the first parm.\n         CLI   0(R4),X'00'         Is this character hex zero?\n         BE    AFTFIRST            Yes, end of command in buffer copy.\n         LA    R4,1(,R4)           Bump another character\n         LA    R8,1(,R8)           Count another character\n         CR    R8,R5               End of command buffer ?\n         BNL   AFTFIRST            Yes. Get out now.\n         BCT   R2,CUTIDLEN         Try for blank again.\nAFTFIRST DS    0H\n         MVC   TABCODE(8),BLANKS   Clear field\n         BCTR  R8,0                Subtract 1 for execute.\n         L     R1,CHARSTRT         Reload R1 to be sure it's correct.\n         EX    R8,MOVOUTL          Move entered parameter to program.\n         LA    R8,1(,R8)           Restore number of characters\n         AR    R1,R8               Point past last search\n         ST    R1,CHARCONT         Continue from here\n         ST    R8,SAVER8A          Save register\n* ---- >\nSEEIFPRM DS    0H                  Check if a command is here\n         OC    TABCODE(3),BLANKS   Uppercase. Won't affect numbers.\n         CLI   TABCODE+2,C'X'      Special action code, code X.\n         BNE   SEEIFJ01            Not this. Just go on.\n         OI    LPADFLG,X'01'       Set flag to display LPA range.\nSEEIFJ01 DS    0H\n*--*\n         TM    LPADFLG,X'01'       Display LPA range only?\n         BZ    SEEIFK01            No. Do all regular processing.\n         BAL   R9,GETLPRNT         Yes. Display LPA range and exit.\n         B     EOJ0                Out of program with Code 0\nSEEIFK01 DS    0H\n*--*\n         CLI   TABCODE+2,C'R'      Replace the entry in the given slot\n         BE    SEEIF0A1\n         CLI   TABCODE+2,C'B'      Blank the given slot\n         BE    SEEIF0A2\n         CLI   TABCODE+2,C'D'      Display contents of given slot\n         BE    SEEIF0A3              or all slots.\n         CLI   TABCODE+2,C'H'      Alter table header\n         BE    SEEIF0A4\n         CLI   TABCODE+2,C'L'      Supply length for table in LWA\n         BE    SEEIF0A5              including trailing blank entries.\n         CLI   TABCODE+2,C'M'      Supply length for table in LWA plus\n         BE    SEEIF0M5              one trailing blank, if there.\n         CLI   TABCODE+2,C'Z'      Zero length for table in LWA\n         BE    SEEIF0A6\n         CLI   TABCODE+2,C'S'      Say this table came from STEPLIB\n         BE    SEEIF0A7\n         CLI   TABCODE+2,C'P'      Say this table is not from STEPLIB\n         BE    SEEIF0A8\n         B     SEEIF000\nSEEIF0A1 DS    0H\n         OI    OFFFLAG,X'01'       Replace an entry\n         B     SEEIF001\nSEEIF0A2 DS    0H\n         OI    OFFFLAG,X'02'       Blank entry in the last slot\n         B     SEEIF001\nSEEIF0A3 DS    0H\n         OI    OFFFLAG,X'04'       Display an entry or entries\n         B     SEEIF001\nSEEIF0A4 DS    0H\n         OI    OFFFLAG,X'08'       Alter table header\n         B     SEEIF001\nSEEIF0M5 DS    0H                  Short length with one blank\n         OI    SHBLFLG,X'01'\nSEEIF0A5 DS    0H\n         OI    OFFFLAG,X'10'       Supply length for table in LWA\n         B     SEEIF001\nSEEIF0A6 DS    0H\n         OI    OFFFLAG,X'20'       Zero length for table in LWA\n         B     SEEIF001\nSEEIF0A7 DS    0H\n         OI    OFFFLAG,X'40'       Say this table came from STEPLIB\n         B     SEEIF001\nSEEIF0A8 DS    0H\n         OI    OFFFLAG,X'80'       Say this table not from STEPLIB\n         B     SEEIF001\nSEEIF000 DS    0H                  Wrong function code was entered...\n* --- >                            Display what we entered, plus code\n         MVC   LINE,LINEB          Clear line\n         MVC   LINE(3),TABCODE     Move code in\n         HEX   LINE+6,1,OFFFLAG    Display contents of flag\n         MVC   LINE+13(35),=C'Program table code + Function code '\n         APUT  LINE,48\n* --- >\n         BAL   R9,ERRORCOD         Indicate error and display syntax.\n         B     EOJ4                Get out with code = 4.\nSEEIF001 DS    0H                  Which table to change\n         MVC   CODEPLAC(2),TABCODE    Save table code.\n* --- >\n         TM    OFFFLAG,X'04'       Display only--no changes to be made\n         BO    NOBEFORE            Don't show \"before changes\" message\n         STM   R14,R1,SAVE1401     Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGED,L'MESSAGED Say \"after making changes\"\n         LM    R14,R1,SAVE1401     Restore registers 14 thru 1.\nNOBEFORE DS    0H\n* --- >                            Display what we entered, plus code\n         MVC   LINE,LINEB          Clear line\n         MVC   LINE(3),TABCODE     Move code in\n         HEX   LINE+6,1,OFFFLAG    Display contents of flag\n         MVC   LINE+13(35),=C'Program table code + Function code '\n         APUT  LINE,48\n* --- >                            Handle each table separately.\n         CLC   TABCODE(2),=C'E2'   Change IKJEFTE2?\n         BE    E2CHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'E8'   Change IKJEFTE8?\n         BE    E8CHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'AP'   Change IKJEFTAP?\n         BE    APCHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'PC'   Change PLATCMD?\n         BE    PCCHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'PP'   Change PLATPGM?\n         BE    PPCHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'NS'   Change IKJEFTNS?\n         BE    NSCHANGE            Yes. Branch.\n         BAL   R9,ERRORCOD         Indicate error and display syntax.\n         B     EOJ4                Invalid code entered.\nEOJ      DS    0H                  END OF JOB\n         L     R13,4(,R13)\n         LR    R15,R5              Put in real return code\n         ST    R15,16(,R13)        Shove it where it belongs\n         L     R14,12(,R13)        R14 and\n         LM    R0,R12,20(R13)        rest of registers\n         BR    R14                 Go back to caller\nEOJ0     DS    0H                  Return code 0\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGR0       Show Return Code 0\n         APUT  MESSAGR0,L'MESSAGR0\n         LA    R5,0                Set CC = 0\n         B     EOJ                 Now end the program\nEOJ4     DS    0H                  Return code 4\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGR4       Show Return Code 4\n         APUT  LINE,L'MESSAGR4\n         L     R5,FULLFOUR         Set CC = 4\n         B     EOJ                 Now end the program\nEOJ8     DS    0H                  Return code 8\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGR8       Show Return Code 8\n         APUT  LINE,L'MESSAGR8\n         L     R5,FULLEIGT         Set CC = 8\n         B     EOJ                 Now end the program\nEOJC     DS    0H                  Return code 12\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGRC       Show Return Code 12\n         APUT  LINE,L'MESSAGRC\n         L     R5,FULLTWLV         Set CC = 12\n         B     EOJ                 Now end the program\n** ---------------------------------------------------------------- **\n**                                                                  **\n**   Different Table Handling Routines                              **\n**   --------- ----- -------- --------                              **\n**                                                                  **\n**  At this point, we have the routines which handle each of the    **\n**  separate types of tables.  E2, E8, AP, and NS, for which the    **\n**  live LWA version is handled.  But we also do the FCVE and       **\n**  PPVE (Platform Command and Platform Program) tables pointed     **\n**  to by the TPVT (TSO Parmlib Vector Table) control block, and    **\n**  those two tables, if they exist, are similarly handled.  But    **\n**  the FCVE and PPVE tables (table codes PC and PP respectively,   **\n**  in this program) are in common storage, and are not in the      **\n**  TSO user's address space.                                       **\n**                                                                  **\n** ---------------------------------------------------------------- **\nE2CHANGE DS    0H                 Handle the E2 table\n         OI    TIDFLAG,X'20'      Show we're doing the E2 table.\n         MVC   TABLEID,=C'E2'     Identify which table\n         BAL   R9,ADJNEXTP        Get to first blank\n         BAL   R9,NAMEPARM        Get rest of parms from the command\n         L     R4,SAVETE2         Point to saved E2 table address\n         ST    R4,TABLSTRT        Store start address of table\n         ST    R4,TABLADDR        Keep start address of table\n*\n         BAL   R9,TESTLPA         Check if table address is in LPA\n         BAL   R9,CHANGEDL        LPA message (conditional)\n         BAL   R9,MEASUR08        Measure the table\n*\n         L     R1,TABLSTRT        Load it back into work register\n**-->>\nE2CHENTY DS    0H                 Show we have a size for E2 table\n         TM    LPAFLAG,X'01'      Is this table in LPA?\n         BO    E2CHYSST           Yes. Don't message the properties.\n         TM    LWAMFLG,X'20'      Do we have a size for the E2 table?\n         BZ    E2CHNOSZ           No.\n         OI    FLAGZ,X'04'        Yes. Flag that we have a size.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1A+6(2),CODEPLAC    Move in table code.\n         HEX   MESSAG1A+57,2,SAVETE2L    Move in length amount\n         MVI   MESSAG1A+61,C'.'          Put period at end.\n         APUT  MESSAG1A,L'MESSAG1A\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     E2CHYSSZ\nE2CHNOSZ DS    0H                 Show message that we have no size\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1B+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1B,L'MESSAG1B\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nE2CHYSSZ DS    0H\n         TM    LWAPFLG,X'20'      Was the E2 table loaded from STEPLIB?\n         BZ    E2CHNOST           No. Say that it wasn't.\n         STM   R14,R1,SAVE1401    Yes. Put out message saying it was.\n         MVC   MESSAG1C+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1C,L'MESSAG1C\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     E2CHYSST\nE2CHNOST DS    0H                 Message. Table not from STEPLIB.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1D+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1D,L'MESSAG1D\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nE2CHYSST DS    0H\n*-*                               Print out table header\n         BAL   R9,PRTABLHD        Table Header Display Routine\n*-*\n         LA    R1,X'10'(,R1)      Bump past header\n         ST    R1,TABLSTRT        Store new start address\n* - -\n         LH    R2,SAVETE2L        Load LWA Table Length\n         LTR   R2,R2              Is it there?\n         BNZ   E2CHHAVB           There is a length, so we use it.\n* - -                             None there, have to guess.\n***\n         LH    R3,ME08LENG        Measured table length.\n***\n         B     E2CHNOHB           And go on.\nE2CHHAVB DS    0H                 We have a table length given.\n         MVC   SAVETCUR,SAVETE2L  This is the length we use for now.\n         LR    R3,R2              Dump the number into R3.\nE2CHNOHB DS    0H\n         L     R4,TABLADDR        Load start address of table\n         AR    R4,R3              Point past the guessed end of table.\n         S     R4,=F'16'          Compensate for 16 byte head start.\n         ST    R4,TABLEND         Store away guessed table end.\n* - -\n         LR    R5,R3              Dump best length into register.\n         SRL   R5,3               Divide by 8.\n         BCTR  R5,0               Actually two fewer entries, because\n         BCTR  R5,0                of the header.\n         ST    R5,TABLENUM        Store the number of entries.\n***\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n***\n* - >\n         LA    R5,8               Size of each E2 table entry\n         ST    R5,TABLESIZ        Store size of each entry\n*                                 We'll stop the search at first blank\n         SR    R4,R5              Point past end of table - guessed.\n         ST    R4,SAVLSLOT        Store this location\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    E2CHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message that nothing changed.\n         B     EOJ0\nE2CHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\n** ---------------------------------------------------------------- **\nE8CHANGE DS    0H                 Handle the E8 table\n         OI    TIDFLAG,X'10'      Show we're doing the E8 table.\n         MVC   TABLEID,=C'E8'     Identify which table\n         BAL   R9,ADJNEXTP        Get to first blank\n         BAL   R9,NAMEPARM        Get rest of parms from the command\n         L     R4,SAVETE8         Point to saved E8 table address\n         ST    R4,TABLSTRT        Store start address of table\n         ST    R4,TABLADDR        Keep start address of table\n*\n         BAL   R9,TESTLPA         Check if table address is in LPA\n         BAL   R9,CHANGEDL        LPA message (conditional)\n         BAL   R9,MEASUR08        Measure the table\n*\n         L     R1,TABLSTRT        Load it back into work register\n**-->>\nE8CHENTY DS    0H                 Deal with the E8 table.             .\n         TM    LPAFLAG,X'01'      Is this table in LPA?\n         BO    E8CHYSST           Yes. Don't message the properties.\n         TM    LWAMFLG,X'10'      Do we have a size for the E8 table?\n         BZ    E8CHNOSZ           No.\n         OI    FLAGZ,X'04'        Yes. Flag that we have a size.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1A+6(2),CODEPLAC    Move in table code.\n         HEX   MESSAG1A+57,2,SAVETE8L    Move in length amount\n         MVI   MESSAG1A+61,C'.'          Put period at end.\n         APUT  MESSAG1A,L'MESSAG1A\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     E8CHYSSZ\nE8CHNOSZ DS    0H\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1B+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1B,L'MESSAG1B\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nE8CHYSSZ DS    0H\n         TM    LWAPFLG,X'10'      Was the E8 table loaded from STEPLIB?\n         BZ    E8CHNOST           No. Say that it wasn't.\n         STM   R14,R1,SAVE1401    Yes. Put out message saying it was.\n         MVC   MESSAG1C+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1C,L'MESSAG1C\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     E8CHYSST\nE8CHNOST DS    0H                 Message. Table not from STEPLIB.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1D+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1D,L'MESSAG1D\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nE8CHYSST DS    0H\n*-*                               Print out table header\n         BAL   R9,PRTABLHD        Table Header Display Routine\n*-*\n         LA    R1,X'10'(,R1)      Bump past header\n         ST    R1,TABLSTRT        Store new start address\n* - -\n         LH    R2,SAVETE8L        Load LWA Table Length\n         LTR   R2,R2              Is it there?\n         BNZ   E8CHHAVB           There is a length, so we use it.\n* - -                             None there, have to guess.\n***\n         LH    R3,ME08LENG        Measured table length.\n***\n         B     E8CHNOHB           And go on.\nE8CHHAVB DS    0H                 We have a table length given.\n         MVC   SAVETCUR,SAVETE8L  This is the length we use for now.\n         LR    R3,R2              Dump the number into R3.\nE8CHNOHB DS    0H\n         L     R4,TABLADDR        Load start address of table\n         AR    R4,R3              Point past the guessed end of table.\n         S     R4,=F'16'          Compensate for 16 byte head start.\n         ST    R4,TABLEND         Store away guessed table end.\n* - -\n         LR    R5,R3              Dump best length into register.\n         SRL   R5,3               Divide by 8.\n         BCTR  R5,0               Actually two fewer entries, because\n         BCTR  R5,0                of the header.\n         ST    R5,TABLENUM        Store the number of entries.\n***\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n***\n* - -\n         LA    R5,8               Size of each E8 table entry\n         ST    R5,TABLESIZ        Store size of each entry\n* - -                             We'll stop the search at first blank\n         SR    R4,R5              Point past end of table - guessed.\n         ST    R4,SAVLSLOT        Store this location\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    E8CHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message that nothing changed.\n         B     EOJ0\nE8CHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\n** ---------------------------------------------------------------- **\nAPCHANGE DS    0H                 Handle the AP table\n         OI    TIDFLAG,X'80'      Show we're doing the AP table.\n         MVC   TABLEID,=C'AP'     Identify which table\n         BAL   R9,ADJNEXTP        Get to first blank\n         BAL   R9,NAMEPARM        Get rest of parms from the command\n* - -\n         L     R4,SAVETAP         Get address of AP table\n         ST    R4,TABLSTRT        Store start address of table\n         ST    R4,TABLADDR        Keep start address of table\n*\n         BAL   R9,TESTLPA         Check if table address is in LPA\n         BAL   R9,CHANGEDL        LPA message (conditional)\n         BAL   R9,MEASUR08        Measure the table\n*\n         L     R1,TABLSTRT        Load it back into work register\n**-->>\nAPCHENTY DS    0H                 Table was made from a IKJTSOxx entry.\n         TM    LPAFLAG,X'01'      Is this table in LPA?\n         BO    APCHYSST           Yes. Don't message the properties.\n         TM    LWAMFLG,X'80'      Do we have a size for the AP table?\n         BZ    APCHNOSZ           No.\n         OI    FLAGZ,X'04'        Yes. Flag that we have a size.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1A+6(2),CODEPLAC    Move in table code.\n         HEX   MESSAG1A+57,2,SAVETAPL    Move in length amount\n         MVI   MESSAG1A+61,C'.'          Put period at end.\n         APUT  MESSAG1A,L'MESSAG1A\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     APCHYSSZ\nAPCHNOSZ DS    0H\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1B+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1B,L'MESSAG1B\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nAPCHYSSZ DS    0H\n         TM    LWAPFLG,X'80'      Was the AP table loaded from STEPLIB?\n         BZ    APCHNOST           No. Say that it wasn't.\n         STM   R14,R1,SAVE1401    Yes. Put out message saying it was.\n         MVC   MESSAG1C+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1C,L'MESSAG1C\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     APCHYSST\nAPCHNOST DS    0H                 Message. Table not from STEPLIB.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1D+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1D,L'MESSAG1D\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nAPCHYSST DS    0H\n*-*                               Print out table header\n         BAL   R9,PRTABLHD        Table Header Display Routine\n*-*\n         LA    R1,X'10'(,R1)      Bump past header\n         ST    R1,TABLSTRT        Store new start address\n* - -\n         LH    R2,SAVETAPL        Load LWA Table Length\n         LTR   R2,R2              Is it there?\n         BNZ   APCHHAVB           There is a length, so we use it.\n* - -                             None there, have to guess.\n***\n         LH    R3,ME08LENG        Measured table length.\n***\n         B     APCHNOHB           And go on.\nAPCHHAVB DS    0H                 We have a table length given.\n         MVC   SAVETCUR,SAVETAPL  This is the length we use for now.\n         LR    R3,R2              Dump the number into R3.\nAPCHNOHB DS    0H\n         L     R4,TABLADDR        Load start address of table\n         AR    R4,R3              Point past the guessed end of table.\n         S     R4,=F'16'          Compensate for 16 byte head start.\n         ST    R4,TABLEND         Store away guessed table end.\n* - -\n         LR    R5,R3              Dump best length into register.\n         SRL   R5,3               Divide by 8.\n         BCTR  R5,0               Actually two fewer entries, because\n         BCTR  R5,0                of the header.\n         ST    R5,TABLENUM        Store the number of entries.\n***\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n***\n* - -\n         LA    R5,8               Size of each AP table entry\n         ST    R5,TABLESIZ        Store size of each entry\n* - -                             We'll stop the search at first blank\n         SR    R4,R5              Point past end of table - guessed.\n         ST    R4,SAVLSLOT        Save this location.\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    APCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message that nothing changed.\n         B     EOJ0\nAPCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\n** ---------------------------------------------------------------- **\nPCCHANGE DS    0H                 Handle the PC table\n         OI    TIDFLAG,X'01'      Show PC table chosen.\n         MVC   TABLEID,=C'PC'\n         TM    PLATFLG,X'01'      Does the table exist?\n         BZ    PCCHAERR           No. Report error.\n         BAL   R9,ADJNEXTP        Get to first blank\n         BAL   R9,NAMEPARM        Get rest of parms from the command\n         L     R2,SAVEFCVE        Get the PC table address\n         LR    R4,R2              Save it off\n         ST    R4,DISPREG         Store register contents for display\n* -- >                            Do Display\n*-*-*->>                          Print the address out so we can see.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1        Clear line area.\n         MVC   LINE(16),=C'Table address:  '\n         HEX   LINE+21,4,DISPREG      Display address in Hex\n         APUT  LINE,35\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n*-*-*->>\n* -- >\n         L     R3,X'8'(,R4)       Point to length of table\n         STH   R3,SAVETCUR        Store it to show non-zero\n         AR    R4,R3              Point just past PC table\n         ST    R4,TABLEND         And mark the projected end of table\n* - -\n         L     R3,X'C'(,R2)       Get number of table entries\n         ST    R3,TABLENUM        Preserve number for table search\n         LA    R3,8               Load table size\n         ST    R3,TABLESIZ        And store it for DISPTABL routine\n** -- **\n***\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         MVC   LINE(22),=C'Table length in Hex:  '\n         HEX   LINE+25,2,SAVETCUR\n         APUT  LINE,45\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n***\n** -- **\n         L     R3,SAVEFCVE        Get the platcmd table start address\n         LA    R3,X'10'(,R3)      Bump past its header\n         ST    R3,TABLSTRT        And store the starting place away\n* - -\n         LA    R5,8               Get 8 bytes ready for subtraction\n         SR    R4,R5              Back up to the last slot\n         ST    R4,SAVLSLOT        Save location of last table slot\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    PCCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message\n         B     EOJ0\nPCCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\nPCCHAERR DS    0H                 Say no PC table exists.\n         MVC   LINE,LINE-1\n         MVC   LINE(43),=C'PC command not valid if no PC table exists.'\n         APUT  LINE,43\n         B     EOJ4\nPCCHAEND DS    0H\n         B     EOJ0\n** ---------------------------------------------------------------- **\nPPCHANGE DS    0H                 Handle the PP table\n         OI    TIDFLAG,X'02'      Show PP table chosen.\n         MVC   TABLEID,=C'PP'\n         TM    PLATFLG,X'02'      Is there a Platpgm table?\n         BZ    PPCHAERR           If no, then display error condition\n         BAL   R9,ADJNEXTP        Get to first blank\n         BAL   R9,NAMEPARM        Get rest of parms from the command\n         L     R2,SAVEPPVE        Get the PP table address\n         LR    R4,R2              Save it off\n         ST    R4,DISPREG         Store PP table address for display\n* -- >                            Do Display\n*-*-*->>                          Print the address out so we can see.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1        Clear line area.\n         MVC   LINE(16),=C'Table address:  '\n         HEX   LINE+21,4,DISPREG      Display address in Hex\n         APUT  LINE,35\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n*-*-*->>\n* -- >\n         L     R3,X'8'(,R4)       Size of PP table in bytes\n         STH   R3,SAVETCUR        Show it's non-zero\n         AR    R4,R3              Point just past the PP table\n         ST    R4,TABLEND         Mark the end of table for DISPTABL\n* - -\n         L     R3,X'C'(,R2)       Get number of table entries\n         ST    R3,TABLENUM        Store that number away for DISPTABL\n         LA    R3,8               Size of each entry\n         ST    R3,TABLESIZ        Store that away too\n** -- **\n***\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         MVC   LINE(22),=C'Table length in Hex:  '\n         HEX   LINE+25,2,SAVETCUR\n         APUT  LINE,45\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n***\n** -- **\n         L     R3,SAVEPPVE        Get start address of PP table\n         LA    R3,X'10'(,R3)      Add 16 to bump past header\n         ST    R3,TABLSTRT        Store search starting address away\n* - -\n         LA    R5,8               Load size of one entry\n         SR    R4,R5              Back up to last slot address\n         ST    R4,SAVLSLOT        And save it off.\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    PPCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message\n         B     EOJ0\nPPCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\nPPCHAERR DS    0H                 Say no PC table exists.\n         MVC   LINE,LINE-1\n         MVC   LINE(43),=C'PP command not valid if no PP table exists.'\n         APUT  LINE,43\n         B     EOJ4\nPPCHAEND DS    0H\n         B     EOJ0\n** ---------------------------------------------------------------- **\nNSCHANGE DS    0H                 Handle the NS table\n         OI    TIDFLAG,X'40'      Show we're doing the NS table.\n         MVC   TABLEID,=C'NS'     Identify which table\n         BAL   R9,ADJNEXTP        Get to first blank\n         BAL   R9,NAMEPARM        Get rest of parms from the command\n         OI    NSCHFLG,X'01'      Show SETTMODE we're doing NS\n* - -\n         L     R4,SAVETNS         Saved location of the NS table\n         ST    R4,TABLSTRT        Store start address of table\n         ST    R4,TABLADDR        Keep start address of table\n*\n         BAL   R9,TESTLPA         Check if table address is in LPA\n         BAL   R9,CHANGEDL        LPA message (conditional)\n         BAL   R9,MEASUR10        Measure the table\n*\n         L     R1,TABLSTRT        Load it to start table search later\n**-->>\nNSCHENTY DS    0H                 Table was made from a IKJTSOxx entry.\n         TM    LPAFLAG,X'01'      Is this table in LPA?\n         BO    NSCHYSST           Yes. Don't message the properties.\n         TM    LWAMFLG,X'40'      Do we have a size for the NS table?\n         BZ    NSCHNOSZ           No.\n         OI    FLAGZ,X'04'        Yes. Flag that we have a size.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1A+6(2),CODEPLAC    Move in table code.\n         HEX   MESSAG1A+57,2,SAVETNSL    Move in length amount\n         MVI   MESSAG1A+61,C'.'          Put period at end.\n         APUT  MESSAG1A,L'MESSAG1A\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     NSCHYSSZ\nNSCHNOSZ DS    0H                 Say we have no size for the NS table\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1B+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1B,L'MESSAG1B\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nNSCHYSSZ DS    0H\n         TM    LWAPFLG,X'40'      Was the NS table loaded from STEPLIB?\n         BZ    NSCHNOST           No. Say that it wasn't.\n         STM   R14,R1,SAVE1401    Yes. Put out message saying it was.\n         MVC   MESSAG1C+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1C,L'MESSAG1C\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     NSCHYSST           Don't put out contradictory messages\nNSCHNOST DS    0H                 Message. Table not from STEPLIB.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1D+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1D,L'MESSAG1D\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nNSCHYSST DS    0H\n*-*                               Print out table header\n         BAL   R9,PRTABLHD        Table Header Display Routine\n*-*\n         LA    R1,X'10'(,R1)      Bump past the table header\n         ST    R1,TABLSTRT        Store new start address for DISPTABL\n* - -\n         LH    R2,SAVETNSL        Load LWA Table Length\n         LTR   R2,R2              Is it there?\n         BNZ   NSCHHAVB           There is a length, so we use it.\n* - -                             None there, have to guess.\n***\n         LH    R3,ME10LENG        Measured table length.\n***\n         B     NSCHNOHB           And go on.\nNSCHHAVB DS    0H                 We have a table length given.\n         MVC   SAVETCUR,SAVETNSL  This is the length we use for now.\n         LR    R3,R2              Dump the number into R3.\nNSCHNOHB DS    0H\n         L     R4,TABLADDR        Load start address of table\n         AR    R4,R3              Point past the guessed end of table.\n*        S     R4,=F'16'          Compensate for 16 byte head start.\n         ST    R4,TABLEND         Store away guessed table end.\n* - -\n         LR    R5,R3              Dump best length into register.\n         S     R5,=F'16'\n         STM   R2,R3,SAVER23      Save work registers.\n         XR    R2,R2              Zero work registers.\n         XR    R3,R3\n         LR    R3,R5              Feed length into work register\n         D     R2,=F'10'          Divide by 10.\n         LR    R5,R3              Save the result.\n         LM    R2,R3,SAVER23      Restore work registers.\n         ST    R5,TABLENUM        Store the number of entries.\n***\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n***\n* - -\n         XR    R5,R5              Clear register\n         LA    R5,10              Size of each NS table entry\n         ST    R5,TABLESIZ        Store size of each table entry\n* - -                             We'll stop the search at first blank\n         SR    R4,R5              Point to Last Slot\n         ST    R4,SAVLSLOT        Save location of last slot\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    NSCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message that nothing changed.\n         B     EOJ0\nNSCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\n** ---------------------------------------------------------------- **\n* ----------------------------------------------------------------- *\n*     Various \"abnormal ending\" routines.                           *\n* ----------------------------------------------------------------- *\nNOTAUTH  DS    0H                     Command not authorized message.\n         APUT  MESSAG2C,L'MESSAG2C\n         APUT  MESSAG2D,L'MESSAG2D\n         B     EOJC\n* ----------------------------------------------------------------- *\nNOE2     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'E2'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\n* ----------------------------------------------------------------- *\nNOE8     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'E8'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\n* ----------------------------------------------------------------- *\nNOAP     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'AP'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\n* ----------------------------------------------------------------- *\nNONS     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'NS'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\n* ----------------------------------------------------------------- *\nNOTNUMER DS    0H                 Message that a parm was not numeric\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEN),MESSAGEN\n         MVC   LINE+21(1),0(R4)\n         APUT  LINE,L'MESSAGEN\n         B     EOJ4\n** ---------------------------------------------------------------- **\n**    Some of the Register and Pointer Save Areas                   **\n** ---------------------------------------------------------------- **\nSAVEPARM DC    F'0'                   Parm address from R1 at entry\nSAVETPVT DC    F'0'                   Address of TPVT control block\nSAVECTLT DC    F'0'                   Address of CTLT control block\nSAVEFCVE DC    F'0'                   Address of Platcmd table if non-0\nSAVEPPVE DC    F'0'                   Address of Platpgm table if non-0\nSAVEUPT  DC    F'0'                   Address of UPT\nSAVEECT  DC    F'0'                   Address of ECT\nSAVEPSCB DC    F'0'                   Address of PSCB\nSAVETNS  DC    F'0'                   Address of NS table\nSAVETE2  DC    F'0'                   Address of E2 table\nSAVETE8  DC    F'0'                   Address of E8 table\nSAVETAP  DC    F'0'                   Address of AP table\nSAVETNSL DC    H'0'                   Length of NS table, if nonzero\nSAVETE2L DC    H'0'                   Length of E2 table, if nonzero\nSAVETE8L DC    H'0'                   Length of E8 table, if nonzero\nSAVETAPL DC    H'0'                   Length of AP table, if nonzero\nSAVETCUR DC    H'0'                   Copied length of current table\nSAVETNEW DC    H'0'                   Changed length of current table\n** ---------------------------------------------------------------- **\nFULLZERO DC    F'0'                   Fullword of numeric 0\nFULLFOUR DC    F'4'                   Fullword 4\nFULLEIGT DC    F'8'                   Fullowrd 8\nFULLTWLV DC    F'12'                  Fullword 12\nSAVE1401 DC    5F'0'                  More for safety\nLWAADDR  DC    F'0'                   Address of LWA control block\n* - - - - - - - - - - - - - - - - - - - - - - - - *\nMOVOUTL  MVC   TABCODE(*-*),0(R1)     EXECUTED\nMOVFSTN  MVC   FSTNAME(*-*),0(R3)     EXECUTED\nMOVSNDN  MVC   SNDNAME(*-*),0(R1)     EXECUTED\nMOVFNUM  MVC   FSTNUME(*-*),0(R3)     EXECUTED\nPACK     PACK  WORKA,0(0,3)          <<< EXECUTED >>>\n** ---------------------------------------------------------------- **\n*          * - - - - - - - - - - - - - - - - - - - - - - - - *\n*          *            S U B R O U T I N E S                *\n*          * - - - - - - - - - - - - - - - - - - - - - - - - *\n** ---------------------------------------------------------------- **\n**  These are executed using a BAL R9,subroutn  instruction.        **\n** ---------------------------------------------------------------- **\nHEX      DS    0H\n         ST    R9,SAVER9A\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         L     R9,SAVER9A\n         BR    R9                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\nHEXSAVE  DS    3F                    Register save for HEX macro\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETNAMES DS    0H                  Get program name from parm.\n         ST    R9,SAVER9B          Save BAL register\n         ST    R2,SAVER2D          Save work register\nGETNAMST DS    0H                  Get rid of leading blanks\n         L     R1,CHARCONT         Point to start of character\n         CLI   0(R1),X'40'         Is it a blank?\n         BNE   GETNAMNZ            No. Get the entire name.\n         LA    R1,1(,R1)           Yes. Bump start place one up.\n         ST    R1,CHARCONT         And store the place away for now.\n         C     R5,=F'1'            End of cmd buffer one away?\n         BNH   EOJ4                Yes. Error.\n         BCTR  R5,0                Subtract one from end count\n         B     GETNAMST            And loop to find first non-blank.\nGETNAMNZ DS    0H                  Got first non-blank. Get whole name.\n         LA    R2,8                BCT initial quantity - 8 chars.\n         LA    R8,0                Character count\n         L     R1,CHARCONT         Load starting place\n         LR    R4,R1               Initialize pointer\n         LA    R4,0(,R4)           to first character of program name.\nGETNAMLU DS    0H                  Loop to get entire name\n         CLI   0(R4),X'40'         First blank?\n         BE    GETNAMGT            Yes, got whole name.\n         CLI   0(R4),X'00'         First hex zeros?\n         BE    GETNAMGT            Yes, got whole name.\n         CR    R8,R5               End of command buffer?\n         BNL   GETNAMGT            Yes. Got all we can get.\n         LA    R8,1(,R8)           Bump character counter.\n         LA    R4,1(,R4)           Bump where we are.\n         BCT   R2,GETNAMLU         Loop back.\nGETNAMGT DS    0H\n         ST    R8,SAVER8A          Save character count\n         ST    R8,FSTCOUNT         Again.\n         CLC   SAVER8A,=F'0'       Is character count (left) 0?\n         BNE   GETREALY            No. Go on processing for name.\n         BAL   R9,MISSPGM2         Say we're missing a program name.\n         B     EOJ4                And get out with code = 4.\nGETREALY DS    0H\n         MVC   FSTCHALF(2),FSTCOUNT+2    Get halfword program length\n         MVC   LINE,LINE-1               Print it in message\n         HEX   LINE,4,SAVER8A\n         MVC   LINE+13(17),=C'Length of command'\n         APUT  LINE,30\n         L     R3,CHARCONT         Load starting place again.\n         BCTR  R8,0                One less for EXECUTE.\n         MVC   FSTNAME(8),BLANKS   Blank entire target field.\n         EX    R8,MOVFSTN          Move program name to target.\n         OC    FSTNAME(8),BLANKS   Uppercase the program name.\n         MVC   LINE,LINE-1         And print its name out.\n         MVC   LINE(8),FSTNAME\n         MVC   LINE+13(17),=C'New program name '\n         APUT  LINE,30\n* - >\nGETNAMEN DS    0H                  Exit this routine.\n         L     R2,SAVER2D          Restore work register\n         L     R9,SAVER9B          Restore BAL register\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nCHANGED  DS    0H                     The \"value was changed\" message.\n         ST    R9,SAVER9C\n         TM    LPAFLAG,X'01'          Is the table within LPA?\n         BO    CHANGEND               Yes. Change already shown.\n         TM    FLAGZ,X'02'            Is parm number past end of table?\n         BO    CHANGEDN               Yes. Bypass all operations here.\n         TM    OFFFLAG,X'01'          Replacement?\n         BO    CHANGEDA               Say what was replaced\n         TM    OFFFLAG,X'02'          Blanking?\n         BO    CHANGEDB               Say what was blanked\n         TM    OFFFLAG,X'04'          Display?\n         BO    CHANGEDD               Skip saying anything was changed.\n         TM    OFFFLAG,X'08'          Change header to \" PARMLIB\"?\n         BO    CHANGEDH               Write message that its done.\n         TM    OFFFLAG,X'10'          Supply lengths in LWA?\n         BO    CHANGEDK               Write appropriate messages.\n         TM    OFFFLAG,X'20'          Zero lengths in LWA?\n         BO    CHANGEDZ               Write appropriate messages.\n*                                     X'40' dealt with in SETSTEPL\n*                                     X'80' dealt with in NOTSTEPL\n         B     CHANGEND\nCHANGEDA DS    0H                     Replacing a table entry.\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC    Say \"before making changes\".\n         MVC   MESSAG3A+5(4),TABENNUM+6\n         MVC   MESSAG3A+13(2),CODEPLAC     Move in table code.\n         MVC   MESSAG3A+42(8),FSTNAME      Move in program name.\n         APUT  MESSAG3A,L'MESSAG3A    Tell em we changed the value.\n         B     CHANGEND\nCHANGEDB DS    0H                     Blanking a table entry.\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC    Say \"before making changes\".\n         MVC   MESSAG3B+5(4),TABENNUM+6\n         MVC   MESSAG3B+13(2),CODEPLAC     Move in table code.\n         MVC   MESSAG3B+42(8),FSTNAME      Move in program name.\n         APUT  MESSAG3B,L'MESSAG3B    Tell em we changed the value.\n         B     CHANGEND\nCHANGEDD DS    0H                     Displaying table entries (entry)\n         TM    OFFFLAG,X'04'\n         BZ    CHANGEDX               Not display? Say what's in slot.\n         CLC   SLOTBIN,=F'0'          Display entire table?\n         BE    CHANGEND               Don't say anything changed.\nCHANGEDX DS    0H                     Say we're displaying 1 slot.\n         MVC   LINE,LINE-1\n         MVC   LINE(30),=C'Display of Slot contents.     '\n         APUT  LINE,30\n         B     CHANGEND\nCHANGEDN DS    0H                     Say nothing changed.\n         APUT  MESSAG2D,L'MESSAG2D\n         B     CHANGEND\nCHANGEDH DS    0H                 Putting \" PARMLIB\" in table header.\n         TM    TIDFLAG,X'03'      Dealing with PC or PP?\n         BNZ   CHANGEDN           Yes. Show nothing was changed.\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC       Say \"before making changes\".\n         APUT  MESSAG3D,L'MESSAG3D\n         BAL   R9,PRTABLHD        Table Header Display Routine\n         B     CHANGEND\nCHANGEDK DS    0H                 \"Supply table lengths\" message.\n         TM    TIDFLAG,X'03'      Dealing with PC or PP?\n         BNZ   CHANGEDN           Yes. Show nothing was changed.\n         MVC   LINE,LINE-1               Print a blank line.\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC       Say \"before making changes\".\n         MVC   MESSAG3E+19(2),TABLEID    Put table id into message.\n         HEX   MESSAG3E+48,2,SAVETCUR    Old message length\n         CLC   TABLEID,=C'NS'            Is it the NS table?\n         BE    CHANGK01\n         HEX   MESSAG3E+60,2,SAVETNEW    8-byte table length\n         B     CHANGK02\nCHANGK01 DS    0H\n         TM    SHBLFLG,X'01'\n         BO    CHANGKA1\n         HEX   MESSAG3E+60,2,TO10LENG    10-byte table length\n         B     CHANGK02\nCHANGKA1 DS    0H\n         HEX   MESSAG3E+60,2,ME10LENG    10-byte table length\nCHANGK02 DS    0H\n         MVI   MESSAG3E+64,C'.'          Finish \"table length\" message.\n         APUT  MESSAG3E,L'MESSAG3E\n*                                        Message after change.\n         MVC   MESSAG1A+6(2),CODEPLAC    Move in table code.\n         HEX   MESSAG1A+57,2,SAVETNEW    New message length\n         MVI   MESSAG1A+61,C'.'          Put period at end.\n         APUT  MESSAG1A,L'MESSAG1A\n         B     CHANGEND\nCHANGEDZ DS    0H                 Zeroing table lengths in the LWA.\n         TM    TIDFLAG,X'03'      Dealing with PC or PP?\n         BNZ   CHANGEDN           Yes. Show nothing was changed.\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC       Say \"before making changes\"\n         MVC   MESSAG3F+19(2),TABLEID\n         HEX   MESSAG3F+33,2,SAVETNEW\n         MVI   MESSAG3F+37,C'.'\n         APUT  MESSAG3F,L'MESSAG3F\n         MVC   MESSAG1B+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1B,L'MESSAG1B\n         B     CHANGEND\nCHANGEND DS    0H\n         L     R9,SAVER9C\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nNAMEPARM DS    0H\n         ST    R9,SAVER9D\n         TM    LPADFLG,X'01'          Displaying LPA range?\n         BO    NAMEPEND               Don't look for a number here.\n*-*\n         TM    OFFFLAG,X'08'          Just changing table header?\n         BO    NAMEPEND               Yes. Then don't look for number.\n*-*\n*-*-*\n         TM    OFFFLAG,X'10'          Supply table length in LWA.\n         BO    NAMEPEND               Yes. Then don't look for number.\n*-*-*\n*-*-*-*\n         TM    OFFFLAG,X'20'          Zero table length in LWA.\n         BO    NAMEPEND               Yes. Then don't look for number.\n*-*-*-*\n*-*-*-*-*\n         TM    OFFFLAG,X'40'          Set on STEPLIB flag for table?\n         BO    NAMEPEND               Yes. Then don't look for number.\n*-*-*-*-*\n*-*-*-*-*-*\n         TM    OFFFLAG,X'80'          Set off STEPLIB flag for table?\n         BO    NAMEPEND               Yes. Then don't look for number.\n*-*-*-*-*-*\n         L     R8,SAVER8A             Get number of characters used\n         CR    R8,R5                  More than what's left?\n         BNL   NAMEBAD1               Yes. Error.\n         C     R5,=F'3'               Is end bigger than 3?\n         BNH   NAMEBAD1               No. Error.\nNAMEGOOD DS    0H\n         S     R5,=F'3'               Subtract 3 from number till end.\n         BAL   R9,GETNUMES            Get the number of the pgm entry.\n         TM    OFFFLAG,X'02'          Are we blanking?\n         BO    NAMEPEND               Yes. Don't need a name parameter\n         TM    OFFFLAG,X'04'          Displaying?\n         BO    NAMEPEND               Yes. No names wanted.\n         BAL   R9,GETNAMES            Get the name of pgm to shove in.\n         B     NAMEPEND\nNAMEBAD1 DS    0H                     Get here if there's no parameter.\n         TM    OFFFLAG,X'04'          Are we displaying?\n         BO    NAMEPEND               No error. Just get out normally.\n         TM    OFFFLAG,X'02'\n         BO    NAMEBAD2\n         BAL   R9,MISSPGM1            We're replacing. Ask for both.\n         B     EOJ4                   RC = 4\nNAMEBAD2 DS    0H\n         BAL   R9,MISSPGM3\n         B     EOJ4                   RC = 4\nNAMEPEND DS    0H\n         L     R9,SAVER9D\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nADJNEXTP DS    0H                     Get to first blank\n         ST    R9,SAVER9E\n         MVC   CHARSTRT,CHARCONT      Set up\n         L     R1,CHARSTRT\nSEEIFENX DS    0H                     Loop\n         CLI   0(R1),X'40'            First blank?\n         BE    SEEIFENZ               Yes, then end.\n         LA    R1,1(,R1)              Bump to next character\n         ST    R1,CHARSTRT            Store address away\n         B     SEEIFENX               Loop back\nSEEIFENZ DS    0H\n         L     R9,SAVER9E\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         LTORG\n************************************************************\nPGMTITLE DS    0H                     Display program name\n         ST    R9,SAVER9F\n         MVC   LINE,LINE-1            Blank line\n         MVC   LINE,MESSAGET          Move title line in\n         MVC   LINE+56(8),VERS#       Version number into title\n         APUT  LINE,L'MESSAGET        And put out to tube\n         MVC   LINE,LINE-1            Blank line again\n         MVC   LINE,MESSAGEU          Move underlines in\n         APUT  LINE,L'MESSAGEU        And put them out also\n         L     R9,SAVER9F\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nSETTMODE DS    0H                  Routine that does Key 0 stuff.\n         ST    R9,SAVER9G\n         TM    FLAGZ,X'02'         Is parm number past end of table?\n         BO    SETTMEND            Yes. Don't do key zero operations.\n         TM    LPAFLAG,X'01'       Is the table in LPA region?\n         BO    SETTMEND            Yes. Do not attempt to change it.\n* -- >       Test if this command is being run APF Authorized\n         STM   R15,R1,SAVE1401     Now save registers and test if APF\n         XR    R15,R15                  authorized.\n         TESTAUTH FCTN=1           Are we authorized?\n         LTR   R15,R15             Test the return code.\n         BNZ   NOTAUTH             Not zero, tell not authorized.\n         LM    R15,R1,SAVE1401     Restore registers used by TESTAUTH.\n* -- >\n* -- >      Key Zero ---- Here's where we change the stuff.\nKZ       MODESET KEY=ZERO\n* -\n         TM    OFFFLAG,X'04'       Only displaying entr(ies)?\n         BNZ   ENDKZ               Yes. No Key 0 stuff done.\n         CLI   LPAFLAG,X'01'       Did the table come from LPALIB?\n         BE    ENDKZ               Yes. Don't try to alter table.\n         TM    NSCHFLG,X'01'       Are we doing the NS table?\n         BO    TENSLOT             Yes. Handle its special needs.\nEIGHSLOT DS    0H                  8-character tables.\n*-*                                Altering table header only\n         TM    OFFFLAG,X'08'       Alter table header?\n         BZ    GONOHDRA            No. Escape this section.\n         TM    TIDFLAG,X'03'       Dealing with PC or PP?\n         BNZ   GONOHDRA            Yes. Show nothing was changed.\n         L     R3,HDRADDR          Load header address\n         MVC   8(8,R3),=C' PARMLIB'  Move in standard table header.\n         B     ENDKZ               Get out of supervisor state.\nGONOHDRA DS    0H\n*-*\n*-*-*\n         TM    OFFFLAG,X'30'       Supplying length to LWA field?\n         BZ    GONZLWA1            No. Don't do this routine.\n         BAL   R9,MEASUR08         Measure it.\n         BAL   R9,WHERSIZE         Load size into proper place in LWA.\n         B     ENDKZ               Get out of supervisor state.\nGONZLWA1 DS    0H\n*-*-*\n*-*-*-*-*\n         TM    OFFFLAG,X'40'       Set STEPLIB flag in LWA for table?\n         BZ    NOGSTEP1            No. Skip step.\n         BAL   R9,SETSTEPL         Set the STEPLIB flag on.\n         B     ENDKZ               Get out of supervisor state.\nNOGSTEP1 DS    0H\n*-*-*-*-*\n*-*-*-*-*-*\n         TM    OFFFLAG,X'80'       STEPLIB flag off in LWA for table?\n         BZ    NOGSTOF1            No. Skip step.\n         BAL   R9,NOTSTEPL         Set the STEPLIB flag off.\n         B     ENDKZ               Get out of supervisor state.\nNOGSTOF1 DS    0H\n*-*-*-*-*-*\n         L     R3,OURSLOT          Address of slot to replace name in.\n         TM    OFFFLAG,X'01'       Replacing function here?\n         BZ    BLANKIT             No. Do blanking function.\n         CLC   FSTNAME,BLANKS      Yes. Is new entry non-blank?\n         BE    ENDKZ               No. It is blank. Nothing to do.\n         MVC   0(8,R3),FSTNAME     Non-blank. Move in new pgm name.\n         B     ENDKZ               And get out.\nBLANKIT  DS    0H                  Blank an 8-character table entry\n         TM    OFFFLAG,X'02'       Blanking function here?\n         BZ    ENDKZ               No. Can't do anything.\n         L     R3,OURSLOT          Address of slot entry to blank\n         MVC   0(8,R3),BLANKS      Move the blanks in.\n         B     ENDKZ               And get out.\nTENSLOT  DS    0H                  10-character tables.\n         L     R3,OURSLOT          Address of slot to replace name in.\n         TM    OFFFLAG,X'01'       Replacing function here?\n         BZ    BLANKTEN            No. Do blanking function.\n         CLC   FSTNAME,BLANKS      Yes. Is new entry non-blank?\n         BE    ENDKZ               No. It is blank. Nothing to do.\n         MVC   0(2,R3),FSTCHALF    Put length of the new program name.\n         MVC   2(8,R3),FSTNAME     Put in the new program name.\n         B     ENDKZ               Get out of supervisor state.\nBLANKTEN DS    0H                  Blank the 10-character table entry\n*-*                                Altering table header only\n         TM    OFFFLAG,X'08'       Alter table header?\n         BZ    GONOHDRB            No. Escape this section.\n         TM    TIDFLAG,X'03'       Dealing with PC or PP?\n         BNZ   GONOHDRB            Yes. Show nothing was changed.\n         L     R3,HDRADDR          Load header address\n         MVC   8(8,R3),=C' PARMLIB'  Move in standard table header.\n         B     ENDKZ               Get out of supervisor state.\nGONOHDRB DS    0H\n*-*\n*-*-*\n         TM    OFFFLAG,X'30'       Supplying length to LWA field?\n         BZ    GONZLWA2            No. Don't do this routine.\n         BAL   R9,MEASUR10         Measure it.\n         BAL   R9,WHERSIZE         Load size into proper place in LWA.\n         B     ENDKZ               Get out of supervisor state.\nGONZLWA2 DS    0H\n*-*-*\n*-*-*-*-*\n         TM    OFFFLAG,X'40'       Set STEPLIB flag in LWA for table?\n         BZ    NOGSTEP2            No. Skip step.\n         BAL   R9,SETSTEPL         Set the STEPLIB flag.\n         B     ENDKZ               Get out of supervisor state.\nNOGSTEP2 DS    0H\n*-*-*-*-*\n*-*-*-*-*-*\n         TM    OFFFLAG,X'80'       STEPLIB flag off in LWA for table?\n         BZ    NOGSTOF2            No. Skip step.\n         BAL   R9,NOTSTEPL         Set the STEPLIB flag off.\n         B     ENDKZ               Get out of supervisor state.\nNOGSTOF2 DS    0H\n*-*-*-*-*-*\n         TM    OFFFLAG,X'02'       Blanking function here?\n         BZ    ENDKZ               No. Can't do anything.\n         L     R3,OURSLOT          Address of slot entry to blank.\n         MVC   0(2,R3),=X'0000'    Move X'FFFF' to mark table end\n         MVC   2(8,R3),BLANKS      And move the blanks to pgm name slot\n         B     ENDKZ               Get out of supervisor state.\nENDKZ    DS    0H                  Get ready to get out of Key 0.\n* -\nNZ       MODESET KEY=NZERO\n* -- >      Back to ordinary life ----\nSETTMEND DS    0H                  Bypass Key 0 stuff.\n         L     R9,SAVER9G\n         BR    R9                  Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nERRORCOD DS    0H                  Give instructions if wrong things\n*                                   were entered, how to do it right.\n         ST    R9,SAVER9H\n         TM    LPADFLG,X'01'\n         BO    ERRORCOE\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSA11L,L'MESSA11L\n         APUT  MESSA11M,L'MESSA11M\n         APUT  MESSA11P,L'MESSA11P\n         APUT  MESSA11A,L'MESSA11A\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSA11C,L'MESSA11C\n         APUT  MESSA11D,L'MESSA11D\n         APUT  MESSA11Z,L'MESSA11Z\n         APUT  MESSA11Y,L'MESSA11Y\n         APUT  MESSA11X,L'MESSA11X\n         APUT  MESSA11F,L'MESSA11F\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSA11I,L'MESSA11I\n         APUT  MESSA11K,L'MESSA11K\n         APUT  MESSA11J,L'MESSA11J\n         APUT  MESSA11N,L'MESSA11N\n         APUT  MESSA11Q,L'MESSA11Q\n         APUT  MESSA11O,L'MESSA11O\n*        MVC   LINE,LINE-1\n*        APUT  LINE,30\nERRORCOE DS    0H\n         L     R9,SAVER9H\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMISSPGM1 DS    0H                     Supply a slot number & pgm name.\n         ST    R9,SAVER9I\n         MVC   LINE,LINE-1\n         APUT  MESSA11G,L'MESSA11G\n         L     R9,SAVER9I\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMISSPGM2 DS    0H                     Supply a program name to put in.\n         ST    R9,SAVER9J\n         MVC   LINE,LINE-1\n         APUT  MESSA11E,L'MESSA11E\n         L     R9,SAVER9J\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMISSPGM3 DS    0H                     Supply a slot number to Blank.\n         ST    R9,SAVER9N\n         MVC   LINE,LINE-1\n         APUT  MESSA12Q,L'MESSA12Q\n         L     R9,SAVER9N\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nDISPTABL DS    0H                Scan thru the particular table....\n         ST    R9,SAVER9L          Save BAL register\n         ST    R3,SAVER3A          Save\n         ST    R4,SAVER4A             the\n         ST    R5,SAVER5A                work\n         ST    R2,SAVER2G                   registers.\n*-*\n         TM    OFFFLAG,X'08'     Just altering table header?\n         BO    DISPTSKP          Yes. Don't display table at all.\n*-*\n*-*-*\n         TM    OFFFLAG,X'10'     Just supplying an LWA size?\n         BO    DISPTSKP          Yes. Don't display table at all.\n*-*-*\n*-*-*-*\n         TM    OFFFLAG,X'20'     Zeroing out LWA size?\n         BO    DISPTSKP          Yes. Don't display table at all.\n*-*-*-*\n*-*-*-*-*\n         TM    OFFFLAG,X'40'     Setting table to come from STEPLIB?\n         BO    DISPTSKP          Yes. Don't display table at all.\n*-*-*-*-*\n*-*-*-*-*-*\n         TM    OFFFLAG,X'80'     Setting table not from STEPLIB?\n         BO    DISPTSKP          Yes. Don't display table at all.\n*-*-*-*-*-*\n         XR    R3,R3               Zero\n         XR    R5,R5                  work\n         XR    R2,R2                     registers.\nDISPTSTR DS    0H\n         L     R3,TABLSTRT         Load start address of table\n         L     R2,TABLENUM         Load number of entries in table\n         L     R5,TABLESIZ         Load size of each entry\n         LA    R4,1                Start slot number count at 1\n         ST    R4,SLOTNOW          Store slot number count away\n         ST    R3,OURSLOT          Initialize slot address.\n         CLC   SLOTBIN,=F'0'       If there's no slot num in parameter\n         BE    DISPTLUP            Then bypass error checking\n         C     R2,SLOTBIN          Compare table size to parm number\n         BNL   DISPTLUP            If parm number is LE, then display\nDISPTERR DS    0H                  Else error message and out.\n         MVC   LINE,LINE-1\n         MVC   LINE(22),=C'Slot number specified '\n         L     R1,SLOTBIN          Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         MVC   LINE+34(26),=C'is bigger than table size '\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+60(10),MASK10  Move in the mask\n         ED    LINE+60(10),CVDAREA+3 Make it pretty\n         APUT  LINE,72\n         B     EOJ4\nDISPTLUP DS    0H                  Loop thru the table entries.\n         MVC   LINE,LINE-1\n         MVC   LINE(2),CODEPLAC    Move in table code.\n         MVC   LINE+3(19),=C'Table Entry Number:'\n         CVD   R4,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         MVC   TABENNUM(10),MASK10      Preserve printable slot number\n         ED    TABENNUM(10),CVDAREA+3\n         TM    NSCHFLG,X'01'       Is this the 10-byte NS table entry?\n         BO    DISPTBNS            Yes. Handle separately.\n         MVC   LINE+34(8),0(R3)\n         CLC   LINE+34(8),BLANKS   Is this a blank entry.\n         BNE   DISPTBLK            No.\n         MVC   LINE+34(8),=C'*empty* '   Yes. Don't just show blanks.\n         OI    FLAGZ,X'01'         We found a blank table entry.\n         TM    FLAGZ,X'04'         Do we have table lengths?\n         BO    DISPTBLK            Yes, then use the table lengths\n* -------                           that we have.\n*                                  No table lengths here. So....\n         ST    R3,OURSLOT          Preserve empty slot address\n         ST    R4,SLOTNOW          Also preserve this slot number.\n         B     DISPTYES            And then stop on first blank.\nDISPTBNS DS    0H\n         HEX   LINE+34,2,0(R3)     Display size of this entry\n         MVC   LINE+40(8),2(R3)    Move in program name to slot\n         CLC   LINE+40(8),BLANKS   Is this a blank entry.\n         BNE   DISPTBLK            No.\n         MVC   LINE+40(8),=C'*empty* '   Yes. Don't just show blanks.\n         OI    FLAGZ,X'01'         We found a blank table entry.\n         TM    FLAGZ,X'04'         Do we have table lengths?\n         BO    DISPTBLK            Yes, then use the table lengths\n* -------                           that we have.\n*                                  No table lengths here. So....\n         ST    R3,OURSLOT          Preserve empty slot address\n         ST    R4,SLOTNOW          Also preserve this slot number.\n         B     DISPTYES            And then stop on first blank.\nDISPTBLK DS    0H                  Search each slot number.\n         CLC   SLOTBIN,=F'0'       Has a slot number been specified?\n         BE    DISPTYES            No. Just display all the slots.\n         CLC   SLOTBIN,SLOTNOW     Yes. Then are we at the one we want?\n         BNE   DISPTNOT            No. Just go further and search.\n         OI    FLAGZ,X'08'         We're at the desired slot.\n* ---  Save contents of the current slot which was found - below\n         ST    R3,OURSLOT          Preserve this slot's address\n         LR    R1,R5               Load table entry size\n         BCTR  R1,0                One less for execute\n         EX    R1,MOVESLOT         Save contents of slot for kicks\n         B     DISPTPEX               Branch past executed instruction\nMOVESLOT MVC   SLOTSAVE(*-*),0(R3)    EXECUTED\nDISPTPEX DS    0H\n* ---  Save contents of the current slot which was found - above\nDISPTYES DS    0H                  Print this slot entry\n         APUT  LINE,52\n         TM    FLAGZ,X'01'         Is this a blank table entry?\n         BO    DISPTEND            Yes, end the table search.\n         TM    FLAGZ,X'08'         Are we at the slot # we specified?\n         BO    DISPTEND            Yes. Stop the search.\nDISPTNOT DS    0H                  Bump to next slot and loop back.\n         C     R3,TABLEND          Compare to end from adding bytes.\n         BH    DISPTEND            Past it, then end the search.\n         LA    R3,0(R5,R3)         Bump to next slot\n         ST    R3,OURSLOT          Store its address - important....\n         LA    R4,1(,R4)           Bump count of slot number\n         ST    R4,SLOTNOW          Store new slot number away\n         ST    R2,SAVER2E\n         BCT   R2,DISPTLUP         And loop to examine the new slot.\n*\nDISPTEND DS    0H                  END OF TABLE SEARCH ROUTINE\n* - >                              Display message if desired slot is\n* - >                               past the end of the table.\n         CLC   SLOTBIN,SLOTNOW     Is the parm number past the end?\n         BNH   DISPTNOP            No. Don't report a problem.\n         L     R1,SLOTBIN          Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         MVC   LINE+34(26),=C'exceeds scanned table size'\n         L     R1,SLOTNOW          Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+60(10),MASK10  Move in the mask\n         ED    LINE+60(10),CVDAREA+3 Make it pretty\n         APUT  LINE,72\n         OI    FLAGZ,X'02'         Flag a problem situation.\nDISPTNOP DS    0H\nDISPTSKP DS    0H\n* - >\n         L     R3,SAVER3A          Restore all the work registers.\n         L     R4,SAVER4A\n         L     R5,SAVER5A\n         L     R2,SAVER2G\n         L     R9,SAVER9L          Restore the BAL register.\n         BR    R9                  Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETNUMES DS    0H                  Get the number after the table code\n         ST    R9,SAVER9M           + the action code. If it exists.\n         ST    R2,SAVER2F\nGETNUMST DS    0H                  Get rid of leading blanks\n         L     R1,CHARCONT         Point to start of character\n         CLI   0(R1),X'40'         Is it a blank?\n         BNE   GETNUMNZ            No. Get the entire name.\n         LA    R1,1(,R1)           Yes. Bump start place one up.\n         ST    R1,CHARCONT         And store the place away for now.\n         C     R5,=F'1'            End of cmd buffer one away?\n         BNH   EOJ4                Yes. Error.\n         S     R5,=F'1'            Subtract one from end count\n         B     GETNUMST            And loop to find first non-blank.\nGETNUMNZ DS    0H                  Got first non-blank. Get whole name.\n         LA    R2,5                BCT initial quantity - 5 chars.\n         LA    R8,0                Character count\n         L     R1,CHARCONT         Load starting place\n         LR    R4,R1               Initialize pointer\n         LA    R4,0(,R4)           to first character of program number\nGETNUMLU DS    0H                  Loop to get entire number\n         CLI   0(R4),X'40'         First blank?\n         BE    GETNUMGT            Yes, got whole number\n         CLI   0(R4),X'00'         First hex zeros?\n         BE    GETNUMGT            Yes, got whole number\n         CR    R8,R5               End of command buffer?\n         BNL   GETNUMGT            Yes. Got all we can get.\n* --                               Test EBCDIC number if numeric.\n         CLI   0(R4),X'F0'         Check character if numeric digit.\n         BL    NOTNUMER            Less than X'F0', not a number.\n         CLI   0(R4),X'F9'         More than X'F9'?\n         BH    NOTNUMER            Not a number.\n* --\n         LA    R8,1(,R8)           Bump character counter.\n         LA    R4,1(,R4)           Bump where we are.\n         BCT   R2,GETNUMLU         Loop back.\nGETNUMGT DS    0H                  Got the whole number - examine it.\n         ST    R8,SAVER8A\n         ST    R8,FSTNOUNT         Get halfword value of slot number\n         MVC   FSTNHALF(2),FSTNOUNT+2\n         L     R3,CHARCONT\n         BCTR  R8,0                One less for EXECUTE\n         MVC   FSTFIELD(8),BLANKS  5-char number plus 3 blanks\n         EX    R8,MOVFNUM          Get the number from the parm\n         EX    R8,PACK             Convert it to packed\n         CVB   R0,WORKA            Convert it to Binary\n         ST    R0,SLOTBIN          Store the value for later use\n         MVC   LINE,LINE-1\n         MVC   LINE(8),FSTFIELD    8-char number with blanks\n         MVC   LINE+13(19),=C'Entry slot number  '\n         APUT  LINE,32\n         LA    R8,1(,R8)           Restore number of chars after EX\n         ST    R8,CHARSIZE         Save this value off.\n         AR    R3,R8               Add it to R3 so we start past it.\n         ST    R3,CHARCONT         Store start value for next parm.\nGETNUMEN DS    0H\n         L     R2,SAVER2F\n         L     R9,SAVER9M\n         BR    R9\n* ----------------------------------------------------------------- *\n*      Measure \"8-byte entry\" loaded table.                         *\n* ----------------------------------------------------------------- *\n*      R5 contains the entry point of the table.                    *\n* ----------------------------------------------------------------- *\nMEASUR08 DS    0H                 R5 has beginning address of table.\n         ST    R9,SAVER9O           Save BAL register\n         ST    R5,SAVER5D           Save work register\n         ST    R4,SAVER4B           Save work register\n         L     R5,TABLADDR          Load start of table\n         XC    BLNKCNT,BLNKCNT      Zero the counters\n         XC    NTRYCNT,NTRYCNT\n         LA    R4,16                Count size of header\n         LA    R5,16(,R5)           Bump past header\nME08LOOP DS    0H\n*     Try (real hard) to detect the end of the table  -  below\n         MVC   SAVECHAR(1),0(R5)    Save first character\n         CLC   =C'        ',0(R5)   Is this table entry a blank?\n         BE    ME08BLNK             Yes. Reached virtual end of table\n         CLC   ZEROES8(8),0(R5)     Is this \"entry\" hex zeros?\n         BE    ME08NOBL             Yes. Reached possible junk storage\n         CLC   =C' ',0(R5)          Is first character blank?\n         BE    ME08NOBL             Yes, not a valid table entry.\n         TR    SAVECHAR,TRTPGMNM    Check first char if appropriate.\n         CLI   SAVECHAR,X'02'       Not. probably end of table.\n         BE    ME08NOBL\n         CLC   =C'IKJEFTE2',0(R5)\n         BE    ME08NOBL\n         CLC   =C'IKJEFTE8',0(R5)\n         BE    ME08NOBL\n         CLC   =C'IKJEFTAP',0(R5)\n         BE    ME08NOBL\n         CLC   =C'IKJEFTNS',0(R5)\n         BE    ME08NOBL\n*     Try (real hard) to detect the end of the table  -  above\n         LA    R4,8(,R4)            Count next table entry\n         LA    R5,8(,R5)            Bump to next entry\n         L     R1,NTRYCNT           Increment \"entry count\" counter\n         A     R1,=F'1'\n         ST    R1,NTRYCNT\n         B     ME08LOOP             Loop back till perceived table end\nME08BLNK DS    0H\n         LA    R4,8(,R4)            Add length of blank entry\n         LA    R5,8(,R5)            Bump past blank entry.\n         L     R1,BLNKCNT           Increment \"blank entry\" counter\n         A     R1,=F'1'\n         ST    R1,BLNKCNT\nME08NOBL DS    0H\n         STH   R4,ME08LENG          Store measured length of table.\n         ST    R5,ME08END           And record address of table end.\n         BAL   R9,MESBLK08          Measure more blanks after table.\n         TM    MEASFLG,X'01'        Been here already?\n         BO    ME08NOSH             Don't show count again.\n         BAL   R9,ENTRYDSP          Show number of entries.\nME08NOSH DS    0H\n         OI    MEASFLG,X'01'        Show we did this once.\n         L     R4,SAVER4B           Restore work register\n         L     R5,SAVER5D           Restore work register\n         L     R9,SAVER9O           Restore BAL register\n         BR    R9\nME08END  DS    F                    Store end-of-table address\nME08LENG DS    H                    Store table length\nBL08LENG DS    H                    Store length of blanks\nTO08LENG DS    H                    Store total, nonblank+blank\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMESBLK08 DS    0H                   See how many more blanks we have.\n         ST    R9,SAVER9Y           Save BAL register\n         ST    R5,SAVER5E           Save work register\n         L     R5,ME08END           Start at measured end of table.\nMESBLL08 DS    0H                   Loop\n         CLC   =C'        ',0(R5)   Is this entry a blank?\n         BNE   MESBLE08             Yes. Stop counting blanks.\n         CLC   BLNKCNT,MAXBLANK     Have we exceeded the maximum guess?\n         BH    MESBLE08             Yes. Don't find more blanks.\n         L     R1,BLNKCNT           Increment \"blank entry\" counter\n         A     R1,=F'1'\n         ST    R1,BLNKCNT\n         LA    R5,8(,R5)            Bump to next entry.\n         B     MESBLL08             Loop until no blanks or max.\nMESBLE08 DS    0H\n         L     R1,BLNKCNT           Total count of found blanks\n         LTR   R1,R1\n         BZ    MESBLX08\n         BCTR  R1,0                 Really one less\nMESBLX08 DS    0H\n         SLL   R1,3                 Multiply by 8\n         STH   R1,BL08LENG          Length of blank entries\n         AH    R1,ME08LENG          Add length of non-blank entries\n         STH   R1,TO08LENG          Total length of both\n*>*----\n*        STM   R14,R1,SAVE1401      Save registers 14 thru 1.\n*        MVC   LINE,LINE-1\n*        HEX   LINE,2,ME08LENG\n*        HEX   LINE+10,2,BL08LENG\n*        HEX   LINE+20,2,TO08LENG\n*        APUT  LINE,30\n*        LM    R14,R1,SAVE1401      Load registers 14 thru 1.\n*>*----\n         L     R5,SAVER5E           Restore work register\n         L     R9,SAVER9Y           Restore BAL register\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* ----------------------------------------------------------------- *\n*      Measure \"10-byte entry\" loaded table.                        *\n* ----------------------------------------------------------------- *\n*      R5 contains the entry point of the table.                    *\n* ----------------------------------------------------------------- *\nMEASUR10 DS    0H                 R5 has beginning address of table.\n         ST    R9,SAVER9P           Save BAL register\n         ST    R5,SAVER5D           Save work register\n         ST    R4,SAVER4B           Save work register\n         L     R5,TABLADDR          Load start of table\n         XC    BLNKCNT,BLNKCNT      Zero the counters\n         XC    NTRYCNT,NTRYCNT\n         LA    R4,16                Count size of header\n         LA    R5,16(,R5)           Bump past header\nME10LOOP DS    0H\n         MVC   SAVECHAR(1),2(R5)    Save first character of pgm name\n         MVC   SAVECH08(1),9(R5)    Save last character of pgm name\n         CLC   BLKSTRNG(10),0(R5)   Full blank entry here?\n         BE    ME10BLNK             Yes. Count the blank entry.\n         CLC   ENDSTRNG(10),0(R5)   FFFF plus blank pgm name?\n         BE    ME10BLNK             Yes. Can still be considered blank.\n         CLC   =X'0000',0(R5)       Test-test-test-test-test\n         BE    ME10TEST             Test rest of \"entry\n         B     ME10REST             Not zeros, go on.\nME10TEST DS    0H\n         TR    SAVECHAR,TRTPGMNM    Check for strange character.\n         CLI   SAVECHAR,X'02'       Is it strange?\n         BE    ME10NOBL             Yes. This is not a blank entry.\nME10REST DS    0H\n         CLC   =X'FFFF',0(R5)       Test for end string separately.\n         BNE   ME10TES2             Not. Not at virtual end of table\n         B     ME10NOBL             FFFF alone. Not a blank entry.\nME10TES2 DS    0H\n         TR    SAVECHAR,TRTPGMNM    Check first char not upcase alpha.\n         CLI   SAVECHAR,X'02'       Not. probably end of table.\n         BE    ME10NOBL\n         TR    SAVECH08,TRTPGMNM    Check last char not upcase alpha.\n         CLI   SAVECH08,X'02'       Not. probably end of table.\n         BE    ME10NOBL\n         LA    R4,10(,R4)           Count next table entry\n         LA    R5,10(,R5)           Bump to next entry\n         L     R1,NTRYCNT           Increment \"entry count\" counter\n         A     R1,=F'1'\n         ST    R1,NTRYCNT\n         B     ME10LOOP             Finished this entry, try for more.\nME10BLNK DS    0H\n         LA    R4,10(,R4)           Add length of blank entry\n         LA    R5,10(,R5)           Bump past blank entry.\n         L     R1,BLNKCNT           Increment \"blank entry\" counter\n         A     R1,=F'1'\n         ST    R1,BLNKCNT\nME10NOBL DS    0H\n         STH   R4,ME10LENG          Store measured length of table.\n         ST    R5,ME10END           And record address of table end.\n         BAL   R9,MESBLK10          Measure more blanks after table.\n         TM    MEASFLG,X'01'        Been here already?\n         BO    ME10NOSH             Don't show count again.\n         BAL   R9,ENTRYDSP          Show number of entries.\nME10NOSH DS    0H\n         OI    MEASFLG,X'01'        Show we did this once.\n         L     R4,SAVER4B           Restore work register\n         L     R5,SAVER5D           Restore work register\n         L     R9,SAVER9P           Restore BAL register\n         BR    R9\nME10END  DS    F                    Store end-of-table address\nME10LENG DS    H                    Store table length\nBL10LENG DS    H                    Store length of blanks\nTO10LENG DS    H                    Store total, nonblank+blank\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMESBLK10 DS    0H                   See how many more blanks we have.\n         ST    R9,SAVER9Y           Save BAL register\n         ST    R5,SAVER5E           Save work register\n         L     R5,ME10END           Start at measured end of table.\nMESBLL10 DS    0H                   Loop\n         CLC   =C'        ',2(R5)   Is this entry a blank entry?\n         BNE   MESBLE10             No. End of perceived blanks.\n         CLC   =X'0000',0(R5)       Length is zero?\n         BNE   MESBLE10             No. End of perceived blanks.\n         CLC   =X'FFFF',0(R5)       Real table end?\n         BE    MESBLE10             Yes. Consider it end of table.\n         CLC   BLNKCNT,MAXBLANK     Have we exceeded the maximum guess?\n         BH    MESBLE10             Yes. Don't find more blanks.\n         L     R1,BLNKCNT           Increment \"blank entry\" counter\n         A     R1,=F'1'\n         ST    R1,BLNKCNT\n         LA    R5,10(,R5)           Bump to next entry.\n         B     MESBLL10             Loop until no blanks or max.\nMESBLE10 DS    0H\n         L     R1,BLNKCNT           Number of blank entries\n         LTR   R1,R1\n         BZ    MESBLX10\n         BCTR  R1,0                 Really one less\nMESBLX10 DS    0H\n         STM   R2,R3,SAVER23        Save work registers\n         XR    R2,R2                Clear R2\n         XR    R3,R3                Clear R3\n         LR    R3,R1                Dump count into R2 for mult.\n         M     R2,=F'10'            Multiply by entry size\n         STH   R3,BL10LENG          Store length of blank entries\n         AH    R3,ME10LENG          Add length of non-blank entries\n         STH   R3,TO10LENG          Total length of both\n         LM    R2,R3,SAVER23        Restore work registers\n*>*----\n*        STM   R14,R1,SAVE1401      Save registers 14 thru 1.\n*        MVC   LINE,LINE-1\n*        HEX   LINE,2,ME10LENG\n*        HEX   LINE+10,2,BL10LENG\n*        HEX   LINE+20,2,TO10LENG\n*        HEX   LINE+30,4,BLNKCNT\n*        APUT  LINE,50\n*        LM    R14,R1,SAVE1401      Load registers 14 thru 1.\n*>*----\n         L     R5,SAVER5E           Restore work register\n         L     R9,SAVER9Y           Restore BAL register\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* ------------------------------------------------------------------ *\nWHERSIZE DS    0H                   Point to size field to update.\n* ------------------------------------------------------------------ *\n*    This is executed after MEASUR08 or MEASUR10.                    *\n*    The idea here is to update the appropriate length field for     *\n*      the appropriate table, after having measured the size.        *\n*    This routine is also used for zeroing the table lengths.        *\n*    This routine is executed in supervisor state. Called from       *\n*      the SETTMODE routine.                                         *\n* ------------------------------------------------------------------ *\n*   ***  Note:  We unconditionally update the table lengths.  ***    *\n* ------------------------------------------------------------------ *\n         ST    R9,SAVER9Q           Save BAL register\n         ST    R2,SAVER2B           Save work registers\n         ST    R3,SAVER3C\n         TM    OFFFLAG,X'30'        Are we updating or zeroing lengths?\n         BZ    WHEREXIT             No. We have no business here.\n         L     R2,LWAADDR           Point to the Logon Work Area.\n         USING LWA,R2               Address its fields.\n*-----------------------------*\nWHERCHUZ DS    0H                   Which table are we dealing with?\n*-----------------------------*\n         TM    TIDFLAG,X'20'           E2?\n         BO    WHERE2\n         TM    TIDFLAG,X'10'           E8?\n         BO    WHERE8\n         TM    TIDFLAG,X'80'           AP?\n         BO    WHERAP\n         TM    TIDFLAG,X'40'           NS?\n         BO    WHERNS\n         B     WHEREXIT\n*-----------------------------*\nWHERE2   DS    0H                      Update E2 length\n         TM    SHBLFLG,X'01'\n         BO    WHERE2SH\n         MVC   LWATE2LN(2),TO08LENG    Move length to LWA\n         MVC   SAVETNEW(2),TO08LENG    Save length for message\n         B     WHERE2E\nWHERE2SH DS    0H\n         MVC   LWATE2LN(2),ME08LENG    Move length to LWA\n         MVC   SAVETNEW(2),ME08LENG    Save length for message\nWHERE2E  DS    0H\n*-*-*-*\nWHERE2Z  DS    0H                      If zeroing, then zero E2 length\n         TM    OFFFLAG,X'20'           Zeroing length?\n         BZ    WHE2NOZ1                No. Bypass this.\n         MVC   LWATE2LN(2),=X'0000'    Move length to LWA\n         MVC   SAVETNEW(2),=X'0000'    Save length for message\nWHE2NOZ1 DS    0H\n*-*-*-*\n         B     WHEREXIT                Finished, get out of routine.\n*-----------------------------*\nWHERE8   DS    0H                      Update E8 length\n         TM    SHBLFLG,X'01'\n         BO    WHERE8SH\n         MVC   LWATE8LN(2),TO08LENG    Move length to LWA\n         MVC   SAVETNEW(2),TO08LENG    Save length for message\n         B     WHERE8E\nWHERE8SH DS    0H\n         MVC   LWATE8LN(2),ME08LENG    Move length to LWA\n         MVC   SAVETNEW(2),ME08LENG    Save length for message\nWHERE8E  DS    0H\n*-*-*-*\nWHERE8Z  DS    0H                      If zeroing, then zero E8 length\n         TM    OFFFLAG,X'20'           Zeroing length?\n         BZ    WHE8NOZ1                No. Bypass this.\n         MVC   LWATE8LN(2),=X'0000'    Move length to LWA\n         MVC   SAVETNEW(2),=X'0000'    Save length for message\nWHE8NOZ1 DS    0H\n*-*-*-*\n         B     WHEREXIT                Finished, get out of routine.\n*-----------------------------*\nWHERAP   DS    0H                      Update AP length\n         TM    SHBLFLG,X'01'\n         BO    WHERAPSH\n         MVC   LWATAPLN(2),TO08LENG    Move length to LWA\n         MVC   SAVETNEW(2),TO08LENG    Save length for message\n         B     WHERAPE\nWHERAPSH DS    0H\n         MVC   LWATAPLN(2),ME08LENG    Move length to LWA\n         MVC   SAVETNEW(2),ME08LENG    Save length for message\nWHERAPE  DS    0H\n*-*-*-*\nWHERAPZ  DS    0H                      If zeroing, then zero AP length\n         TM    OFFFLAG,X'20'           Zeroing length?\n         BZ    WHAPNOZ1                No. Bypass this.\n         MVC   LWATAPLN(2),=X'0000'    Move length to LWA\n         MVC   SAVETNEW(2),=X'0000'    Save length for message\nWHAPNOZ1 DS    0H\n*-*-*-*\n         B     WHEREXIT                Finished, get out of routine.\n*-----------------------------*\nWHERNS   DS    0H                      Update NS length\n         TM    SHBLFLG,X'01'\n         BO    WHERNSSH\n         MVC   LWATNSLN(2),TO10LENG    Move length to LWA\n         MVC   SAVETNEW(2),TO10LENG    Save length for message\n         B     WHERNSE\nWHERNSSH DS    0H\n         MVC   LWATNSLN(2),ME10LENG    Move length to LWA\n         MVC   SAVETNEW(2),ME10LENG    Save length for message\nWHERNSE  DS    0H\n*-*-*-*\nWHERNSZ  DS    0H                      If zeroing, then zero NS length\n         TM    OFFFLAG,X'20'           Zeroing length?\n         BZ    WHNSNOZ1                No. Bypass this.\n         MVC   LWATNSLN(2),=X'0000'    Move length to LWA\n         MVC   SAVETNEW(2),=X'0000'    Save length for message\nWHNSNOZ1 DS    0H\n*-*-*-*\n         B     WHEREXIT                Finished, get out of routine.\n*-----------------------------*\nWHEREXIT DS    0H\n         L     R2,SAVER2B              Restore work registers\n         L     R3,SAVER3C\n         L     R9,SAVER9Q\n         BR    R9\n         DROP  R2\nTABLEID  DC    CL2' '\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nSETSTEPL DS    0H                     Routine to turn on STEPLIB flags\n         ST    R9,SAVER9R\n         ST    R2,SAVER2C                Save work register\n         L     R2,LWAADDR\n         USING LWA,R2\nSETSWTBL DS    0H                     Check which table we're seeing\n         TM    TIDFLAG,X'03'          PC OR PP table?\n         BNZ   SETSTEPN               Say nothing changed.\n         TM    TIDFLAG,X'20'          E2?\n         BO    SETSDOE2\n         TM    TIDFLAG,X'10'          E8?\n         BO    SETSDOE8\n         TM    TIDFLAG,X'80'          AP?\n         BO    SETSDOAP\n         TM    TIDFLAG,X'40'          NS?\n         BO    SETSDONS\nSETSDOE2 DS    0H\n         OI    LWAPRMLB,LWATE2ST         STEPLIB flag on for E2\n         B     SETSWTBE\nSETSDOE8 DS    0H\n         OI    LWAPRMLB,LWATE8ST         STEPLIB flag on for E8\n         B     SETSWTBE\nSETSDOAP DS    0H\n         OI    LWAPRMLB,LWATAPST         STEPLIB flag on for AP\n         B     SETSWTBE\nSETSDONS DS    0H\n         OI    LWAPRMLB,LWATNSST         STEPLIB flag on for NS\n         B     SETSWTBE\nSETSWTBE DS    0H                        Print informative message\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC    Say \"before making changes\"\n         MVC   LINE,LINE-1\n         MVC   LINE(71),=C'Table    marked from STEPLIB so PARMLIB UPDA-\n               TE(xx) will not overlay it.'\n         MVC   LINE+6(2),TABLEID\n         APUT  LINE,71\n         B     SETSTEPE\nSETSTEPN DS    0H\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         APUT  MESSAG2D,L'MESSAG2D   Say nothing changed.\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     SETSTEPE\nSETSTEPE DS    0H\n         L     R2,SAVER2C             Restore work register\n         L     R9,SAVER9R\n         DROP  R2\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nNOTSTEPL DS    0H                    Routine to turn off STEPLIB flags\n         ST    R9,SAVER9K\n         ST    R2,SAVER2C             Save work register\n         L     R2,LWAADDR\n         USING LWA,R2\nNOTSWTBL DS    0H                     Check which table we're seeing\n         TM    TIDFLAG,X'03'          PC OR PP table?\n         BNZ   NOTSTEPN               Say nothing changed.\n         TM    TIDFLAG,X'20'          E2?\n         BO    NOTSDOE2\n         TM    TIDFLAG,X'10'          E8?\n         BO    NOTSDOE8\n         TM    TIDFLAG,X'80'          AP?\n         BO    NOTSDOAP\n         TM    TIDFLAG,X'40'          NS?\n         BO    NOTSDONS\nNOTSDOE2 DS    0H\n         NI    LWAPRMLB,X'FF'-LWATE2ST   STEPLIB flag off for E2\n         B     NOTSWTBE\nNOTSDOE8 DS    0H\n         NI    LWAPRMLB,X'FF'-LWATE8ST   STEPLIB flag off for E8\n         B     NOTSWTBE\nNOTSDOAP DS    0H\n         NI    LWAPRMLB,X'FF'-LWATAPST   STEPLIB flag off for AP\n         B     NOTSWTBE\nNOTSDONS DS    0H\n         NI    LWAPRMLB,X'FF'-LWATNSST   STEPLIB flag off for NS\n         B     NOTSWTBE\nNOTSWTBE DS    0H                     Print informative message.\n         MVC   LINE,LINE-1            Print a blank first.\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC    Say \"before making changes\".\n         MVC   LINE,LINE-1\n         MVC   LINE(71),=C'Table    marked from not from STEPLIB. PARML-\n               IB UPDATE(xx) can overlay. '\n         MVC   LINE+6(2),TABLEID      Move table name into message.\n         APUT  LINE,71\n         B     NOTSTEPE\nNOTSTEPN DS    0H\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         APUT  MESSAG2D,L'MESSAG2D   Say nothing changed.\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     NOTSTEPE\nNOTSTEPE DS    0H\n         L     R2,SAVER2C             Restore work register\n         L     R9,SAVER9K\n         BR    R9\n         DROP  R2\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETLPABD DS    0H                  Get storage boundary values for LPA\n         ST    R9,SAVER9S\nGETLSTRT DS    0H\n         ST    R5,SAVER5C          Prepare a bunch of work registers\n         ST    R4,SAVER4C          Prepare a bunch of work registers\n         L     R5,X'10'            Point to CVT.\n         USING CVT,R5              Tell Assembler.\n         L     R4,CVTSMEXT         Point to CVT Extension.\n         USING CVTVSTGX,R4         Tell Assembler.\n         MVC   SAVMLPAS,CVTMLPAS   MLPA start\n         MVC   SAVMLPAE,CVTMLPAE   MLPA end\n         MVC   SAVFLPAS,CVTFLPAS   FLPA start\n         MVC   SAVFLPAE,CVTFLPAE   FLPA end\n         MVC   SAVPLPAS,CVTPLPAS   PLPA start\n         MVC   SAVPLPAE,CVTPLPAE   PLPA end\n         MVC   SAVEMLPS,CVTEMLPS   E-MLPA start\n         MVC   SAVEMLPE,CVTEMLPE   E-MLPA end\n         MVC   SAVEFLPS,CVTEFLPS   E-FLPA start\n         MVC   SAVEFLPE,CVTEFLPE   E-FLPA end\n         MVC   SAVEPLPS,CVTEPLPS   E-PLPA start\n         MVC   SAVEPLPE,CVTEPLPE   E-PLPA end\n         L     R5,SAVER5C          Restore the work registers\n         L     R4,SAVER4C          Restore the work registers\n         L     R9,SAVER9S\n         DROP  R5,R4\n         BR    R9                  Return\n*                                  Constants needed here.\nSAVMLPAS DC    A(0)\nSAVMLPAE DC    A(0)\nSAVFLPAS DC    A(0)\nSAVFLPAE DC    A(0)\nSAVPLPAS DC    A(0)\nSAVPLPAE DC    A(0)\nSAVEMLPS DC    A(0)\nSAVEMLPE DC    A(0)\nSAVEFLPS DC    A(0)\nSAVEFLPE DC    A(0)\nSAVEPLPS DC    A(0)\nSAVEPLPE DC    A(0)\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETLPRNT DS    0H         Routine to Print LPA Range - action code X\n         ST    R9,SAVER9T\n         TM    LPADFLG,X'01'         Code wasn't X. Don't print.\n         BZ    GETLPRTE              Just restore R9 and go on.\n         MVC   LINE,LINE-1\n         MVC   LINE(28),DASHES28\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(28),=C' --- LPA RANGE DISPLAY ---  '\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(28),DASHES28\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(4),=C'MLPA'\n         HEX   LINE+10,4,SAVMLPAS    MLPA range\n         HEX   LINE+20,4,SAVMLPAE\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(4),=C'FLPA'\n         HEX   LINE+10,4,SAVFLPAS    FLPA range\n         HEX   LINE+20,4,SAVFLPAE\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(4),=C'PLPA'      PLPA range\n         HEX   LINE+10,4,SAVPLPAS\n         HEX   LINE+20,4,SAVPLPAE\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(6),=C'E-MLPA'    E-MLPA range\n         HEX   LINE+10,4,SAVEMLPS\n         HEX   LINE+20,4,SAVEMLPE\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(6),=C'E-FLPA'    E-FLPA range\n         HEX   LINE+10,4,SAVEFLPS\n         HEX   LINE+20,4,SAVEFLPE\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(6),=C'E-PLPA'    E-PLPA range\n         HEX   LINE+10,4,SAVEPLPS\n         HEX   LINE+20,4,SAVEPLPE\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(28),DASHES28     Print row of dashes at the bottom\n         APUT  LINE,35\nGETLPRTE DS    0H\n         L     R9,SAVER9T\n         BR    R9\nDASHES28 DC    28C'-'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nPRTABLHD DS    0H\n         ST    R9,SAVER9U\n*                                 Print out table header\n         STM   R14,R1,SAVE1401    Now save registers 14 thru 1.\n         L     R1,TABLADDR        Load table start address.\n         MVC   DISPHDR(16),0(R1)  Move header info to display area.\n         ST    R1,HDRADDR         Store header address for alter\n         MVC   LINE,LINE-1        Clear line\n         MVC   LINE(15),=C'Table Header:  '  Move in title.\n         MVC   LINE+15(16),DISPHDR           Move in title info.\n         APUT  LINE,35\n         MVC   LINE,LINE-1        Clear line for next time\n         LM    R14,R1,SAVE1401    Restore  registers 14 thru 1.\n*-*\n         L     R9,SAVER9U\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n** ---------------------------------------------------------------- **\n**   When this routine is invoked, TABLADDR points to the start     **\n**    of the real table.                                            **\n** ---------------------------------------------------------------- **\nTESTLPA  DS    0H             Test if an address is in any LPA range\n         ST    R9,SAVER9W\n*-*-*->>                          Print the address out so we can see.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1        Clear line area.\n         MVC   LINE(16),=C'Table address:  '\n         HEX   LINE+20,4,TABLADDR     Display address in Hex\n         APUT  LINE,35\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n*-*-*->>\nTESLSTRT DS    0H\n         CLC   TABLADDR,SAVMLPAS      Smaller than MLPA start?\n         BL    TESLTST1\n         CLC   TABLADDR,SAVMLPAE      Larger than MLPA end?\n         BH    TESLTST1\n         OI    LPAFLAG,X'01'          In between, flag it and exit.\n         B     TESLMSG\nTESLTST1 DS    0H\n         CLC   TABLADDR,SAVFLPAS      Smaller than FLPA start?\n         BL    TESLTST2\n         CLC   TABLADDR,SAVFLPAE      Larger than FLPA end?\n         BH    TESLTST2\n         OI    LPAFLAG,X'01'          In between, flag it and exit.\n         B     TESLMSG\nTESLTST2 DS    0H\n         CLC   TABLADDR,SAVPLPAS      Smaller than PLPA start?\n         BL    TESLTST3\n         CLC   TABLADDR,SAVPLPAE      Larger than PLPA end?\n         BH    TESLTST3\n         OI    LPAFLAG,X'01'\n         B     TESLMSG                In between, flag it and exit.\nTESLTST3 DS    0H\n         CLC   TABLADDR,SAVEMLPS      Smaller than E-MLPA start?\n         BL    TESLTST4\n         CLC   TABLADDR,SAVEMLPE      Larger than E-MLPA end?\n         BH    TESLTST4\n         OI    LPAFLAG,X'01'          In between, flag it and exit.\n         B     TESLMSG\nTESLTST4 DS    0H\n         CLC   TABLADDR,SAVEFLPS      Smaller than E-FLPA start?\n         BL    TESLTST5\n         CLC   TABLADDR,SAVEFLPE      Larger than E-FLPA end?\n         BH    TESLTST5\n         OI    LPAFLAG,X'01'          In between, flag it and exit.\n         B     TESLMSG\nTESLTST5 DS    0H\n         CLC   TABLADDR,SAVEPLPS      Smaller than E-PLPA start?\n         BL    TESLMSG\n         CLC   TABLADDR,SAVEPLPE      Larger than E-PLPA end?\n         BH    TESLMSG\n         OI    LPAFLAG,X'01'          In between, flag it and exit.\n         B     TESLMSG\nTESLMSG  DS    0H\n*-*-*->>                          Message the result of the LPA test.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1        Clear line area.\n         TM    LPAFLAG,X'01'      Is the address within LPA?\n         BZ    TESLMSGA           No. Say not.\n         MVC   LINE(40),=C'Table address lies within an LPA region.'\n         B     TESLMSGP           Go send the message.\nTESLMSGA DS    0H\n         MVC   LINE(42),=C'Table address is not within an LPA region.'\nTESLMSGP DS    0H                 Send the message.\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n*-*-*->>\nTESLEND  DS    0H\n         L     R9,SAVER9W\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nCHANGEDL DS    0H                     Say table was in LPALIB so that\n*                                       therefore nothing was changed.\n         ST    R9,SAVER9V\n         TM    LPAFLAG,X'01'          Table was loaded in the LPALIB\n*                                      storage range. Can't change it.\n         BZ    CHANGEEN\n         APUT  MESSAG2E,L'MESSAG2E    Say that table was from LPALIB.\n         APUT  MESSAG2D,L'MESSAG2D    Say that nothing was changed.\nCHANGEEN DS    0H\n         L     R9,SAVER9V\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nENTRYDSP DS    0H\n         ST    R9,SAVER9X\n         TM    TIDFLAG,X'03'      PC or PP table?\n         BNZ   ENTRYEXI           Yes. No display here.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         L     R1,NTRYCNT\n         CVD   R1,CVDAREA\n         MVC   LINE+22(10),MASK10\n         ED    LINE+22(10),CVDAREA+3\n         MVC   LINE(24),=C'Non-blank table entries:'\n         MVC   LINE+35(25),=C'(these are the ones used)'\n         APUT  LINE,65\n         MVC   LINE,LINE-1\n         L     R1,BLNKCNT\n         CVD   R1,CVDAREA\n         MVC   LINE+22(10),MASK10\n         ED    LINE+22(10),CVDAREA+3\n         MVC   LINE(24),=C'Perceived blank entries:'\n         MVC   LINE+35(25),=C'(potential for expansion)'\n         APUT  LINE,65\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nENTRYEXI DS    0H\n         L     R9,SAVER9X\n         BR    R9\nENTRYDEN DS    0H\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n** ---------------------------------------------------------------- **\n**   Here are the rest of the constants for the program.            **\n** ---------------------------------------------------------------- **\nBLKSTRNG DC    XL10'00004040404040404040'\nENDSTRNG DC    XL10'FFFF4040404040404040'\nZEROES8  DC    X'0000000000000000'\nMASK10   DC    XL10'40202020202020202120'\n         DC    C' '\nBLANKS   DC    C'                                            '\nMESSAGET DC    C'TSUB Command - Display/Change USERID Auth Table Entry -\n               - xxxxxxxx'\nMESSAGEU DC    C'---- -------   ------- ------ ------ ---- ----- ----- -\n                 --------'\nMESSAGEC DC    C'  **--------   AFTER MAKING CHANGES   -------**'\nMESSAGED DC    C'  **--- STATE BEFORE MAKING TABLE CHANGES ---**'\nMESSAG1A DC    C'Table XX pointed to by the LWA has length available. H+\n               ex xxxx '\nMESSAG1B DC    C'Table XX pointed to by the LWA has no lengths. Blanks +\n               will delimit.'\nMESSAG1C DC    C'Table XX pointed to by the LWA came from an APF STEPLI+\n               B.'\nMESSAG1D DC    C'Table XX pointed to by the LWA did not come from an AP+\n               F STEPLIB.'\nMESSAG2C DC    C'Command was not invoked APF authorized.'\nMESSAG2D DC    C'Nothing was changed.  '\nMESSAG2E DC    C'Table is in LPALIB, and we will not attempt to alter i+\n               t.'\nMESSAG3A DC    C'Slot      in XX table has been changed to         .'\nMESSAG3B DC    C'Slot      in XX table has been blanked.            '\nMESSAG3C DC    C'                                                      +\n                  '\nMESSAG3D DC    C'Last 8 bytes of table header altered to \" PARMLIB\". '\nMESSAG3E DC    C'LWA size for table    has been changed from Hex xxxx t+\n               o Hex xxxx.'\nMESSAG3F DC    C'LWA size for table    is now Hex xxxx. '\nMESSA11A DC    C'  Supply a table code TT, followed by an action code A-\n               .'\nMESSA11B DC    C'Supply a program name, as the next parameter.   '\nMESSA11C DC    C'Valid table  codes are:  E2, E8, AP, NS, PC, PP. '\nMESSA11D DC    C'Valid action codes are:  R - replace, B - blank, D - d-\n               isplay,'\nMESSA11Z DC    C'  H - header, L - supply full table length, Z - zero t-\n               able length,'\nMESSA11Y DC    C'  S - mark table from STEPLIB, P - mark table from PAR-\n               MLIB,'\nMESSA11X DC    C'  X - display LPA storage ranges, M - supply minimum t-\n               able length.'\nMESSA11E DC    C'Please supply a program name.  '\nMESSA11F DC    C'Full command is in the form TTA, TT=table code, A=acti-\n               on code.'\nMESSA11G DC   C'Please supply slot number to change, and program name.'\nMESSA11I DC    C'If D (display) is followed by a slot number, only that-\n                slot is shown.'\nMESSA11J DC    C'R (replace) requires a slot number, followed by a prog-\n               ram name.'\nMESSA11K DC    C'If D is not followed by a number, then the entire tabl-\n               e is displayed.'\nMESSA11L DC    C'  Instructions to use this program:                  '\nMESSA11M DC    C'  ------------ -- --- ---- -------                   '\nMESSA11N DC    C'B (blank) blanks the slot number given. Higher slots a-\n               re invalidated.'\nMESSA11O DC    C'D does not need APF authorization. All other codes req-\n               uire it.'\nMESSA11P DC    C'TSUB TTA nnn pgmname (nnn optional for D, both require-\n               d for R)'\nMESSA11Q DC    C'Codes: H,L,M,Z,P,S,X do not require extra parameters.'\nMESSA12Q DC    C'Please supply slot number to blank out. BE CAREFUL !'\nMESSAGR0 DC    C'Return Code = 0 '\nMESSAGR4 DC    C'Return Code = 4 '\nMESSAGR8 DC    C'Return Code = 8 '\nMESSAGRC DC    C'Return Code = 12'\nMESSDIAG DC    C'                                            '\nMESSAGEP DC    C'No Parmlib-supplied XX table was found in storage. '\nMESSAGEN DC    C'Supplied character        was not numeric. '\n         SPACE 3\n         LTORG\n         SPACE 3\nCVDAREA  DS    D                   For CVD instruction\nSAVEAPUT DS    2D\nSAVER23  DS    2F                  Save pair of regs R2, R3\nSAVER1A  DS    F                   Save R1 here\nSAVER1B  DS    F                   Save R1 here\nSAVER2A  DS    F                   Save R2 here\nSAVER2B  DS    F                   Save R2 here\nSAVER2C  DS    F                   Save R2 here\nSAVER2D  DS    F                   Save R2 here\nSAVER2E  DS    F                   Save R2 here\nSAVER2F  DS    F                   Save R2 here\nSAVER2G  DS    F                   Save R2 here\nSAVER3A  DS    F                   Save R3 here\nSAVER3B  DS    F                   Save R3 here\nSAVER3C  DS    F                   Save R3 here\nSAVER4A  DS    F                   Save R4 here\nSAVER4B  DS    F                   Save R4 here\nSAVER4C  DS    F                   Save R4 here\nSAVER5A  DS    F                   Save R5 here\nSAVER5B  DS    F                   Save R5 here\nSAVER5C  DS    F                   Save R5 here\nSAVER5D  DS    F                   Save R5 here\nSAVER5E  DS    F                   Save R5 here\nSAVER5F  DS    F                   Save R5 here\nSAVER8A  DS    F                   Save R8 here\nSAVER9A  DS    F                   BAL Register Save Area\nSAVER9B  DS    F                   BAL Register Save Area\nSAVER9C  DS    F                   BAL Register Save Area\nSAVER9D  DS    F                   BAL Register Save Area\nSAVER9E  DS    F                   BAL Register Save Area\nSAVER9F  DS    F                   BAL Register Save Area\nSAVER9G  DS    F                   BAL Register Save Area\nSAVER9H  DS    F                   BAL Register Save Area\nSAVER9I  DS    F                   BAL Register Save Area\nSAVER9J  DS    F                   BAL Register Save Area\nSAVER9K  DS    F                   BAL Register Save Area\nSAVER9L  DS    F                   BAL Register Save Area\nSAVER9M  DS    F                   BAL Register Save Area\nSAVER9N  DS    F                   BAL Register Save Area\nSAVER9O  DS    F                   BAL Register Save Area\nSAVER9P  DS    F                   BAL Register Save Area\nSAVER9Q  DS    F                   BAL Register Save Area\nSAVER9R  DS    F                   BAL Register Save Area\nSAVER9S  DS    F                   BAL Register Save Area\nSAVER9T  DS    F                   BAL Register Save Area\nSAVER9U  DS    F                   BAL Register Save Area\nSAVER9V  DS    F                   BAL Register Save Area\nSAVER9W  DS    F                   BAL Register Save Area\nSAVER9X  DS    F                   BAL Register Save Area\nSAVER9Y  DS    F                   BAL Register Save Area\nCMBUFEND DS    F                   Number of bytes to end of cmd buff\nSAVLSLOT DS    F                   Save place where Key 0 will change\nSLOTBIN  DS    F                   Fullword binary value of slot number\nSLOTNOW  DS    F                   Slot number being searched\nDISPREG  DS    F                   DISPLAY\nCMBUFAD  DS    F                   Command Buffer address\nCHARSTRT DS    F                   Address of first parm character\nCHARCONT DS    F                   Address of next parm character\nCHARSIZE DS    F\nOURSLOT  DS    F                   Address of current slot searched\nFOUNSLOT DS    F\nTABLEND  DS    F                   Estimated or real end addr of table\n* --- >\nTABLSTRT DS    F                   Start address of table\nTABLADDR DS    F                   Store address of current table\nTABLENUM DS    F                   Number of entries in table\nTABLESIZ DS    F                   Size of a table entry\n* --- >\nBLNKCNT  DS    F\nNTRYCNT  DS    F\n* --- >\nOFFSETSV DS    F\nWORKA    DC    D'0'                Work area for CVB\nNUMVSTRT DC    X'00'               Character count of first parm\nNUMCOUTL DC    X'00'               Entered first parm length\nCODEPLAC DS    CL2                 Store entered table code here\nPAD01    DS    CL4                 Filler\nSAVECHAR DS    X\nSAVECH08 DS    X\nMEASFLG  DS    X\nSHBLFLG  DS    X\nOFFFLAG  DS    X                   Are we blanking the last entry?\nOLDFLAG  DS    X                   Old system detected if X'01'\nTIDFLAG  DS    X                   Which table are we handling.\nLPAFLAG  DS    X                   Is the table address in the LPA?\nLPADFLG  DS    X                   Do LPA range display.\nPLATFLG  DS    X                   FCVE or PPVE exist.\nHAVLFLG  DS    X                   Have length of table available\nNSCHFLG  DS    X                   Dealing the 10-byte NS table?\nLWAPFLG  DS    X                   LWAPRMLB flag copied into program\n*              X'80'               LWATAPST TAP came from STEPLIB\n*              X'40'               LWATNSST TNS came from STEPLIB\n*              X'20'               LWATE2ST TE2 came from STEPLIB\n*              X'10'               LWATE8ST TE8 came from STEPLIB\nLWAMFLG  DS    X                   Which tables have a size in the LWA.\n*              X'80'               AP has a size in the LWA.\n*              X'40'               NS has a size in the LWA.\n*              X'20'               E2 has a size in the LWA.\n*              X'10'               E8 has a size in the LWA.\nFLAGZ    DS    X\n*              X'01'               Found a blank entry. End table srch.\n*              X'02'               Parm number is past the end of table\n*              X'04'               Table lengths have been supplied.\nPAD02    DS    CL4                 Filler\nFSTNAME  DC    CL8' '              Entered program name for \"Replace\"\nFSTCOUNT DS    F                   Number of characters in FSTNAME\nFSTCHALF DC    H'0'\nPAD03    DS    CL4                 Filler\nTABENNUM DC    CL10' '\nPAD03A   DS    CL4                 Filler\nFSTFIELD DS    0CL8\nFSTNUME  DC    CL5' '\nFSTNUPAD DC    CL3' '\nFSTNOUNT DS    F                   Number of characters in FSTNAME\nFSTNHALF DC    H'0'\nPAD04    DS    CL4                 Filler\nSLOTSAVE DS    CL10\nPAD05    DS    CL4                 Filler\nSNDNAME  DC    CL8' '\nSNDCOUNT DS    F                   Number of characters in SNDNAME\nSNDCHALF DC    H'0'\nTABCODE  DC    CL8' '              Original OUTLIM character\n         DS    CL7                 PADDING\nDISPHDR  DS    CL16                Table header display area\n         DS    CL1\nHDRADDR  DS    F                   Address of table header\nCMDBCOPY DS    CL252\n         DS    CL128               PADDING\n         DS    0F                  ALIGN ON FULLWORD\nLINEB    DS    C                   LINE-1\nLINE     DS    CL137               Output line area\nLINET    EQU   LINE+7              Indented line\nLINAB    DS    C                   LINE-1\nLINA     DS    CL137               Output line area\nLINAT    EQU   LINA+7              Indented line\nTRTPGMNM DC    X'02020202020202020202020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'40020202020202020202020202020202'\n         DC    X'02020202020202020202025B02020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'02020202020202020202027B7C020202'\n         DC    X'02C1C2C3C4C5C6C7C8C9020202020202'\n         DC    X'02D1D2D3D4D5D6D7D8D9020202020202'\n         DC    X'0202E2E3E4E5E6E7E8E9020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'02C1C2C3C4C5C6C7C8C9020202020202'\n         DC    X'02D1D2D3D4D5D6D7D8D9020202020202'\n         DC    X'0202E2E3E4E5E6E7E8E9020202020202'\n         DC    X'02020202020202020202020202020202'\n         SPACE\n         IKJCPPL\n         IKJPSCB\n         CVT      LIST=YES,DSECT=YES\n         IKJTSVT\n         IKJEFLWA\n         END\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUEMNTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   128                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         EJECT\n         IHAPSA   LIST=YES                                     HD APR88\n         EJECT                                                 HD APR88\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   14,12,12(13)       SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES            RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    1,8(13)            OUR SAVE AREA POINTER\n         ST    13,4(1)            POINTER TO CALLERS SAVE AREA\n         LR    13,1               @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(R13)         POINT TO CALLERS RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 ASSUME BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 ASSUME BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(RML)               MESSAGE LENGTH\n         STH   R15,PUTLEN                 PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    2,R13                    @OUR SAVE AREA\n         LR    3,R15                    SAVE RETURN CODE\n         L     R13,4(R13)               @CALLERS SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,3                    RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END   EPUTL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT797/FILE797.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT797", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}