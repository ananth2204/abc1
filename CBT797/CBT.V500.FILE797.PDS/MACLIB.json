{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20170423181538000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1763580, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 23440, "INMRECFM": "FB", "INMDIR": 35, "INMDSNAM": "SBGOLOB.FILE452.MACLIB", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1763580, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1763580, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"SBGOLOB.FILE452.MACLIB": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 23440, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 2226, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "170113", "DS1SCEXT": "b'\\x80[\\x90'", "DS1SCALO": "b'P\\x00\\x00\\x14'", "DS1LSTAR": "b'\\x00\\x1d\\x03'", "DS1TRBAL": "b'U\"'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f?\\x10\\x00\\x04\\x89P`'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f?\\x10\\x00\\x04\\x89P`'", "b\"X\\xf4\\xe3\\x18\\x00\\x00\\x07\\xc2\\x00\\t\\x07\\xc5\\x00\\x02\\x00'\"", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"#BAKR": {"ttr": 2819, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\"\\x01\\x082\\x8f\\x01\\x082\\x8f\\x11C\\x00#\\x00#\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2008-11-23T00:00:00", "modifydate": "2008-11-23T11:43:22", "lines": 35, "newlines": 35, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&LABEL   #BAKR &APARS=5,                RESERVE 5 APAR SLOTS           +\n               &LEVEL=,                 MODULE LEVEL                   +\n               &NAME=                   MODULE NAME (DEFAULT TO MODULE)\n         LCLA  &A\n         LCLC  &N\n         AIF   ('&NAME' EQ '').BK10\n&N       SETC  '&NAME'\n         AGO   .BK30\n.BK10    ANOP  ,\n&N       SETC  '&SYSIN_MEMBER'\n         AIF   ('&N' NE '').BK30\n&N       SETC  '&SYSECT'\n.BK30    ANOP  ,\n&A       SETA  8+8+9                    ALLOW FOR NAME PLUS DATE/TIME\n         AIF   ('&APARS' EQ '').BK40\n&A       SETA  &A+(&APARS*4)            ALLOW FOR APARS\n.BK40    ANOP  ,\n         AIF   ('&LEVEL' EQ '').BK50\n&A       SETA  &A+8                     ALLOW FOR LEVEL ID\n.BK50    ANOP ,\n&LABEL   B     &A+5(0,R15)              BRANCH AROUND ID\n         DC    AL1(&A)                  LENGTH OF PROGRAM ID\n         DC    CL8'&N'                  MODULE NAME\n         DC    CL8' &SYSTIME '          TIME OF ASSEMBLY\n         DC    CL9'&SYSDATC'            DATE OF ASSEMBLY\n         AIF   ('&LEVEL' EQ '').BK60\n         DC    CL8'&LEVEL'              MODULE LEVEL\n.BK60    ANOP  ,\n         AIF   ('&APARS' EQ '').BK70\n         DC    &APARS.CL4' '            APAR SLOTS\n.BK70    ANOP  ,\n         BAKR  R14,0                    SAVE REGS ON STACK AND SET\n*                                        RETURN TO ADDRESS IN R14\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#BALR": {"ttr": 37, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00@C\\x01\\x082o\\x01\\x082o!\\x10\\x00\\x16\\x00\\x16\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 64, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:43", "lines": 22, "newlines": 22, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&LABEL   #BALR &R1,&R2\n.**********************************************************************\n.*                                                                    *\n.*       THIS MACRO IS USED TO GENERATE LINKAGE VIA A POINTER         *\n.*       DEFINED VALUE.  IS SPLEVEL IS ONE, MVS/370 WILL BE CHECKED   *\n.*       FOR AND A BALR USED INSTEAD OF BASSM IF 370 IS RUNNING.      *\n.*                                                                    *\n.**********************************************************************\n         GBLC  &SYSSPLV                 SPLEVEL\n         SPLEVEL TEST\n         AIF   ('&SYSSPLV' EQ '1').LEVEL1\n&LABEL   BASSM &R1,&R2                  MVS/XA LINKAGE\n         MEXIT ,\n.LEVEL1  ANOP  ,\n&LABEL   L     &R1,16                   POINT TO CVT\n         TM    116(&R1),128             MVS/XA ?\n         BO    *+10\n         BALR  &R1,&R2                  MVS/370 LINKAGE\n         B     *+6\n         BASSM &R1,&R2                  MVS/XA LINKAGE\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#BLANK": {"ttr": 39, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x01\\x082o\\x01\\x082o!\\x10\\x00%\\x00%\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:43", "lines": 37, "newlines": 37, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    #BLANK &F,&LEN=,&PAD=C' '\n         LCLC  &L\n         AIF   ('&F' EQ '').BLA0700   ERROR - MISSING FIELD\n         AIF   ('&F'(1,1) EQ '(').BLA0100   FIELD IS A REGISTER\n         AIF   ('&LEN' NE '').BLA0400   LENGTH SPECIFIED\n&L       SETC  'L''&F'\n&NAME    MVI   &F,&PAD\n         MVC   &F+1(&L-1),&F\n         MEXIT ,\n.BLA0100 ANOP  ,\n&NAME    LR    0,&F(1)                  R0 @ FIELD\n         AIF   ('&LEN' NE '').BLA0200   LENGTH CODED\n         LA    1,4095                   R1 HAS DEFAULT LENGTH\n         AGO   .BLA0600                 CONTINUE\n.BLA0200 AIF   ('&LEN'(1,1) EQ '(').BLA0300   LENGTH IS A REGISTER\n         LA    1,&LEN                   R1 HAS LENGTH OF FIELD\n         AGO   .BLA0600                 CONTINUE\n.BLA0300 LR    1,&LEN(1)                R1 HAS LENGTH OF FIELD\n         AGO   .BLA0600                 CONTINUE\n.BLA0400 ANOP  ,\n&NAME    LA    0,&F                     R0 @ FIELD\n         AIF   ('&LEN'(1,1) EQ '(').BLA0500   LEN IS A REGISTER\n         LA    1,&LEN                   R1 HAS LENGTH OF FIELD\n         AGO   .BLA0600                 CONTINUE\n.BLA0500 ANOP  ,\n         LR    1,&LEN(1)                R1 HAS LENGTH OF FIELD\n.BLA0600 ANOP  ,\n         AIF   ('&PAD' EQ '0' OR '&PAD'  EQ 'X''00''').BLA0640\n         LA    15,&PAD                  R15 HAS PAD CHARACTER\n         SLL   15,24                    IN HIGH ORDER BYTE\n         AGO   .BLA0660\n.BLA0640 SR    15,15                    ZERO PAD AND LENGTH\n.BLA0660 MVCL  0,14                     PROPOGATE PAD CHARACTER\n         MEXIT ,\n.BLA0700 MNOTE 8,'BLA001I - No Field Name Specified'\n         MEND  .\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#BLKLEN": {"ttr": 41, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x01\\x082o\\x01\\x082o!\\x10\\x00&\\x00&\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:43", "lines": 38, "newlines": 38, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    #BLKLEN &DECB,&REG,&WKREG=R15,&ACSMETH=BSAM\n         LCLC  &A,&B,&R,&O,&F\n&O       SETC  '4'                 FLAG OFFSET FOR BSAM\n&F       SETC  '128'               'S' FLAG FOR BSAM\n         AIF   ('&ACSMETH' EQ 'BSAM' OR '&ACSMETH' EQ 'BPAM').BLK0100\n         AIF   ('&ACSMETH' NE 'BDAM').BLK0600\n&O       SETC  '5'                 FLAG OFFSET FOR BDAM\n&F       SETC  '64'                'S' FLAG FOR BDAM\n.BLK0100 ANOP  ,\n.*\n&R       SETC  '&REG'\n         AIF   ('&REG' NE '').BLK0200\n&R       SETC  'R1'\n.*\n.BLK0200 AIF   ('&DECB' EQ '').BLK0500\n         AIF   ('&DECB'(1,1) EQ '(').BLK0300\n&A       SETC  '&DECB+'\n&B       SETC  ''\n         AGO   .BLK0400\n.BLK0300 ANOP  ,\n&A       SETC  ''\n&B       SETC  '&DECB'\n.*\n.BLK0400 ANOP  ,\n&NAME    LH    &R,&A.6&B                GET BLKSIZE FROM DECB\n         TM    &A.&O&B,&F               WAS 'S' CODED ON READ ?\n         BZ    *+12                     YES, SKIP DCB STUFF\n         L     &R,&A.8&B                GET DCB ADDRESS\n         LH    &R,62(0,&R)              GET BLKSIZE FROM DCB\n         L     &WKREG,&A.16&B           LOAD IOB ADDRESS\n         SH    &R,14(0,&WKREG)          GET ACTUAL # BYTES READ\n         MEXIT EXIT\n.BLK0500 MNOTE 8,'BLK001A - DECB Address Missing'\n         MEXIT EXIT\n.BLK0600 MNOTE 4,'BLK002A - Invalid Access Method, BSAM Assumed'\n         AGO   .BLK0100                 CONTINUE\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#CATRC": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00\\xe0\\x00\\xe0\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 224, "newlines": 224, "modlines": 0, "user": "MACRO"}, "text": "*---------------------------------------------------------------------*\n* VSAM SETS ERROR CODES IN THE RPL AND THE ACB.  ERROR CODES SET IN   *\n* THE RPL ARE LISTED AND EXPLAINED IN OS/VS VIRTUAL STORAGE ACCESS    *\n* METHOD (VSAM) PROGRAMMER'S GUIDE AND IN OS/VS2 VSAM LOGIC.  THOSE   *\n* SET IN THE ACB TO INDICATE OPEN,CLOSE, OR END OF VOLUME ERRORS ARE  *\n* LISTED AND EXPLAINDED IN OS/VS2 VSAM LOGIC.                         *\n*                                                                     *\n* OS/VS2 CATALOG MANAGEMENT SETS ERROR AND REASON CODES IN CCAPROB.   *\n* (FOR A DESCRIPTION OF THE CCA, SEE \"CATALOG MANAGEMENT CONTROL      *\n* BLOCK DESCRIPTIONS\" IN THE \"DATA AREAS\" SECTION OF OS/VS2 CATALOG   *\n* MANAGEMENT LOGIC.)  CCAPROB INCLUDES AN IDENTIFICATION OF THE       *\n* CATALOG MANAGEMENT MODULE THAT SET THE CODE (CCAMODID), A REASON    *\n* CODE (CCAREASN), AND A RETURN CODE (CCACD1), WICH APPEARS IN R15.   *\n* COMPLETE EXPLANATIONS OF THE ERROR AND RETURN CODES, TOGETHER WITH  *\n* THE APPROPRIATE PROGRAMMER RESPONSES ARE GIVEN IN THE DESCRIPTION   *\n* OF MESSAGE IDC3009I IN OS/VS MESSAGE LIBRARY: VS2 SYSTEM MESSAGES.  *\n* BRIEF DESCRIPTIONS OF THE RETURN CODES ARE GIVEN BELOW:             *\n*---------------------------------------------------------------------*\n\nRCS      EQU   0         OPERATION COMPLETED SUCCESSFULLY.\n\nRCCAT    EQU   4         AN ERROR OCCURRED WHILE PERFORMING OPEN/CLOSE\n*                        PROCESSING FOR A VSAM CATALOG OR A CATALOG\n*                        RECOVERY AREA.  IF NO JOBCAT/STEPCAT DD\n*                        STATEMENT WAS SUPPLIED, DYNAMIC ALLOCATION\n*                        MAY HAVE FAILED BECAUSE THE VOLUME IS\n*                        ALLOCATED EXCLUSIVELY.  THE VOLUME MAY BE\n*                        ALLOCATED EXCLUSIVELY BECAUSE (1) THE DD\n*                        STATEMENT SPECIFIED DEFERRED MOUNT, (2) THE\n*                        VOLUME COUNT IS GREATER THAN THE UNIT COUNT\n*                        ON THE DD STATEMENT, OR (3) A PREVIOUS ACCESS\n*                        METHOD SERVICES COMMAND DEMOUNTED THE VOLUME\n*                        AND CHANGED THE ALLOCATION OF THE VOLUME TO\n*                        EXCLUSIVE.\n\nRCENT    EQU   8         ENTRY DOES NOT EXIST, IF ACTION IS ONE THAT\n*                        LOCATES AN ENTRY, OR ENTRY ALREADY EXISTS, IF\n*                        ACTION IS ONE THAT ADDS AN ENTRY TO THE CATLG.\n\nRCINSP   EQU   20        NOT ENOUGH SPACE IS AVAILABLE IN THE CATALOG\n*                        DATASET.  ANOTHER EXTENT CANNOT BE OBTAINED,\n*                        BECAUSE THERE IS NO MORE SPACE ON THE VOLUME\n*                        IN WHICH THE CATALOG RESIDES OR THE MAXIMUM\n*                        NUMBER OF EXTENTS HAS BEEN REACHED.\n\nRCIOL    EQU   24        PERMANENT READ ERROR IN VSAM CATALOG.\n\nRCIONL   EQU   28        PERMANENT I/O ERROR IN VSAM CATALOG.\n\nRCINCPL  EQU   32        ERROR WAS DETECTED IN THE CATALOG PARAMETER\n*                        LIST (CTGPL).\n\nRCDSNF   EQU   36        DATASET WAS NOT FOUND.\n\nRCVLSZ   EQU   40        VOLUME LIST OR WORK AREA IS TOO SMALL - THE\n*                        REQUIRED LENGTH VALUE IS RETURNED IN THE\n*                        FEEDBACK FIELD.\n\nRCVLSM   EQU   44        WORK AREA IS TOO SMALL; SYSTEM IS UNABLE TO\n*                        RETURN THE REQUIRED SIZE.\n\nRCINFUNC EQU   48        OPERATION IS NOT A VALID ONE.\n\nRCIOU    EQU   52        I/O ERROR WAS DETECTED ON A USER VOLUME.\n*                        AN ATTEMPT TO MODIFY THE VTOC OF THE VOLUME\n*                        ON WHICH A USER-SPECIFIED DATASET IS BEING\n*                        DEFINED OR MODIFIED FAILED BECAUSE OF A READ\n*                        OR WRITE ERROR.\n\nRCSEC    EQU   56        PASSWORD IS INCORRECT.\n\nRCINENT  EQU   60        CATALOG RECORD TYPE IS INVALID.\n\nRCNAME   EQU   64        DATASEET OR INDEX CATALOG RECORD ASSOCIATED\n*                        WITH THE CLUSTER OR ALTERNATE INDEX CATALOG\n*                        RECORD WAS NOT FOUND.\n\nRCNOSP   EQU   68        NO SPACE IS AVAILABLE ON A USER VOLUME.\n\nRCNMNTD  EQU   72        USER VOLUME IS NOT MOUNTED.\n\nRCNUNIT  EQU   76        UNIT IS NOT AVAILABLE FOR MOUNTING USER VOLUME\n*                        OR VOLUME NOT MOUNTED.\n\nRCRELOP  EQU   80        INVALID RELATED OBJECT.  THE OBJECT SPECIFIED\n*                        IN THE RELATED PARAMETER OF THE DEFINE COMMAND\n*                        DOES NOT EXIST OR IS IMPROPER FOR THE OBJECT\n*                        BEING DEFINED.\n\nRCDATE   EQU   84        PURGE DATE HAS NOT EXPIRED.\n\nRCCRAOPC EQU   88        ERROR WITH A CATALOG RECOVERY AREA DEFINE\n*                        OPERATION.\n\nRCDSEXT  EQU   92        DATASET HAS REACHECK THE MAXIMUM NUMBER OF\n*                        EXTENTS.\n\nRCOBTAIN EQU   94        AN OS/VS DADSM OBTAIN REQUEST FAILED DURING\n*                        A VSAM CATALOG DELETE REQUEST.\n\nRCSPANCK EQU   96        ERROR IN SPECIFYING KEY LENGTH, KEY POSITION,\n*                        OR RECORD SIZE FOR AN ALTERNATE INDEX OR A\n*                        SPANNED CLUSTER.\n\nRCRENAME EQU   98        AN UNUSUAL CONDITION OCCURRED DURING ALTER\n*                        NAME OF A UNIQUE OR NONVSAM DATASET.\n\nRCSCRTCH EQU   102       AN OS/VS DADSM SCRATCH REQUEST FAILED DURING\n*                        A VSAM DELETE REQUEST FOR A UNIQUE OR NONVSAM\n*                        DATASET.\n\nRCCATEX  EQU   104       CATALOG EXISTS.\n\nRCNTFMT4 EQU   106       A FMT-4 DSCB PROCESSING ERROR WAS ENCOUNTERED.\n\nRCINFNAM EQU   108       FIELD NAME IS INVALID.\n\nRCINFPL  EQU   112       FIELD PARAMETER LIST (CTGFL) CONTAINS\n*                        INVALID PARAMETERS.\n\nRCCATBAL EQU   116       CATALOG RECORDS ARE INVALID.\n\nRCSYSFLD EQU   120       USER ATTEMPTED TO MODIFY A SYSTEM FIELD OR\n*                        NONEXISTENT FIELD.\n\nRCINCI   EQU   124       CONTROL INTERVAL NUMBER IS INVALID.\n\nRCBLKVCK EQU   128       USER PROVIDED WORK AREA IS OUTSIDE HIS ADDRESS\n*                        SPACE.\n\nRCINPTR  EQU   132       POINTER IS NOT VALID.\n\nRCMISPAR EQU   136       REQUIRED PARAMETER IS MISSING.\n\nRCINCNPM EQU   140       SPECIFIED PARAMETERS ARE INCONSISTENT OR\n*                        CONFLICTING.\n\nRCINENTN EQU   144       ENTRY NAME IS INVALID.\n\nRCVOLOWN EQU   148       VOLUME IS ALREADY OWNED BY ANOTHER VSAM CATLG.\n\nRCDNECAT EQU   152       USER ATTEMPTED TO DELETE A CATALOG THAT IS NOT\n*                        EMPTY.\n\nRCNOSPSA EQU   156       NO SPACE AVAILABLE TO SUBALLOCATE.\n\nRCVNDSPD EQU   160       DELETION OF SPACE OBJECT DID NOT CAUSE VOLUME\n*                        TO BE DELETED.\n\nRCINSSWA EQU   164       NOT ENOUGH STORAGE IS AVAILABLE FOR WORK AREA.\n\nRCINVDTY EQU   168       SPECIFIED DEVICE-TYPE IS NOT SUPPORTED.\n\nRCDUPNVL EQU   172       VOLUME HAS DUPLICATE DATA SPACE NAME.\n\nRCNSPVTC EQU   176       NO SPACE AVAILABLE ON VTOC FOR DSCB.\n\nRCDSNFND EQU   180       DATA SPACE WAS NOT FOUND.\n\nRCDSO    EQU   184       DATA SET IS CURRENTLY OPEN, SO THE CATALOG\n*                        RECORD CANNOT BE MODIFIED.\n\nRCCATUNA EQU   188       THE CATALOG IS UNAVAILABLE.\n\nRCMLRSZ  EQU   192       MAXIMUM LOGICAL RECORD LENGTH SPECIFIED IS\n*                        GREATER THAN 32,761.\n\nRCMCISZD EQU   196       DATA COMPONENT CONTROL INTERVAL SIZE SPECIFIED\n*                        IS GREATER THAN 32,767.\n\nRCMCISZI EQU   200       INDEX COMPONENT CONTROL INTERVAL SIZE\n*                        SPECIFIED IS GREATER THAN 32,767.\n\nRCKEYINC EQU   204       KEY EXTENDS BEYOND END OF RECORD.\n\nRCBUFSIZ EQU   208       BUFFER SIZE IS TOO SMALL.\n\nRCSIZCAL EQU   212       CONTROL INTERVAL SIZE CANNOT BE CALCULATED.\n\nRCVTCBAL EQU   216       VOLUME'S VTOC IS INVALID.\n\nRCDOSVTC EQU   220       DOS VTOC CANNOT BE CONVERTED TO OS/VS VTOC.\n\nRCMXGRP  EQU   224       CATALOG RECORD HAS EXCEEDED THE MAXIMUM NUMBER\n*                        OF SETS OF FIELDS ALLOWED.\n\nRCTSAUTH EQU   226       TEST AUTHORIZATION FAILED.\n\nRCLOCKER EQU   228       ERROR DETECTED IN THE TIME-OF-DAY CLOCK.\n\nRCHIGH   EQU   230       VSAM CATALOG RETRIEVE OF THE CONTROL INTERVAL\n*                        FAILED TO GET A LOW-RANGE RECORD FROM THE VSAM\n*                        CATALOG.\n\nRCSMFER  EQU   232       ERROR DETECTED IN SMF PROCESSING.\n\nRCLEOD   EQU   234       END OF DATA ENCOUNTERED WHILE READING THE LOW\n*                        DATA KEY RANGE OF THE VSAM CATALOG.\n\nRCSPMAPE EQU   236       ERROR DETECTED IN SCANNING THE SPACE MAP.\n\nRCNOUCEN EQU   238       NO USER CATALOG ENTRY IN THE MASTER CATALOG\n*                        FOR CONVERT VOLUME PROCESSING.\n\nRCINDER  EQU   240       REQUIRED DD STATEMENT MISSING.\n\nRCEFRMPH EQU   242       A PHYSICAL I/O ERROR OCCURRED DURING AN ERASE\n*                        OF THE DATASET BEING DELETED.\n\nRCEF     EQU   244       ERASE OPERATION FAILED - DELETE OPERATION WAS\n*                        NOT PERFORMED.\n\nRCVOLENT EQU   248       THE VOLUME CATALOG RECORD (IDENTIFIED WITH A\n*                        CALLER-SUPPLIED VOLUME SERIAL NUMBER) WAS NOT\n*                        FOUND.\n\nRCEFRM   EQU   250       VSAM RECORD MANAGEMENT FOUND A LOGICAL ERROR\n*                        DURING ERASE PROCESSING WHILE DELETING A VSAM\n*                        DATASET.\n\nRCEE     EQU   252       ERROR WAS DETECTED, AND THE OPERATION WAS NOT\n*                        COMPLETED.\n\nRCBADE   EQU   400       ---------------------------------------------\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#CCW": {"ttr": 257, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00@D\\x01\\x082o\\x01\\x082o!\\x10\\x00[\\x00[\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 64, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 91, "newlines": 91, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         #CCW  &LIST=YES\n         GBLB  &####CCW\n         AIF   (&####CCW).MEND\n&####CCW SETB  1\n         AIF   ('&LIST' NE 'NO').BEGIN\n         PUSH  PRINT\n         PRINT OFF\n.BEGIN   ANOP  ,\n.*                    0 1 2 3  4 5 6 7\n.*    FORMAT-0 CCW   CCAAAAAA FFXXKKKK\n.*    FORMAT-1 CCW   CCFFKKKK AAAAAAAA\n*\n*        CCW FLAG BYTE MAPPING  (BITS 32-37 OR 8-15)\n*\nCD       EQU   B'10000000'   CHAIN DATA\nCC       EQU   B'01000000'   CHAIN COMMAND\nSLI      EQU   B'00100000'   SUPPRESS LENGTH INDICATION\nSKIP     EQU   B'00010000'   SKIP\nPCI      EQU   B'00001000'   PROGRAM CONTROLLED INTERRUPT\nIDA      EQU   B'00000100'   INDIRECT DATA ADDRESS\nSUSP     EQU   B'00000010'   SUSPEND\n*\n*        GENERAL COMMAND CODE MAPPING  (BITS 0-7)\n*\nWRITE    EQU   B'00000001'   WRITE\nREAD     EQU   B'00000010'   READ\nNOP      EQU   B'00000011'   NO OPERATION\nSENSE    EQU   B'00000100'   SENSE\nSENSEID  EQU   B'11100100'   SENSE ID\nTIC      EQU   B'00001000'   TRANSFER-IN-CHANNEL\n*\n*        TAPE COMMAND CODE MAPPING\n*\nRBACK    EQU   B'00001100'   READ BACKWARD\nREW      EQU   B'00000111'   REWIND\nRUN      EQU   B'00001111'   REWIND AND UNLOAD\nERG      EQU   B'00010111'   ERASE GAP\nWTM      EQU   B'00011111'   WRITE TAPE MARK\nBSB      EQU   B'00100111'   BACKSPACE BLOCK\nBSF      EQU   B'00101111'   BACKSPACE FILE\nFSB      EQU   B'00110111'   FORWARD SPACE BLOCK\nFSF      EQU   B'00111111'   FORWARD SPACE FILE\nDSE      EQU   B'10010111'   DATA SECURITY ERASE\nM800     EQU   B'11001011'   9 TRACK, 800 BPI\nM1600    EQU   B'11000011'   9 TRACK, 1600 BPI\nM6250    EQU   B'11010011'   9 TRACK, 6250 BPI\n*\n*        DASD COMMAND CODE MAPPING\n*\nRECAL    EQU   B'00010011'   RECALIBRATE\nSEEK     EQU   B'00000111'   FULL SEEK (BBCCHH)\nSEEKC    EQU   B'00001011'   SEEK CYLINDER (00CCHH)\nSEEKH    EQU   B'00011011'   SEEK HEAD (0000HH)\nSPCNT    EQU   B'00001111'   SPACE COUNT\nSFM      EQU   B'00011111'   SET FILE MASK\nSSEC     EQU   B'00100011'   SET SECTOR\nDEFEXT   EQU   B'01100011'   DEFINE EXTENT\nLOCREC   EQU   B'01000111'   LOCATE RECORD\nMT       EQU   B'10000000'   MUILITRACK ON (OR'ED WITH CMD CODE)\n*\nSHAEQ    EQU   B'00111001'   SEARCH HOME ADDRESS EQUAL (CCHH)\nSIDEQ    EQU   B'00110001'   SEARCH ID EQUAL (CCHHR)\nSIDHI    EQU   B'01010001'   SEARCH ID HIGH  (CCHHR)\nSIDHEQ   EQU   B'01110001'   SEARCH ID HIGH OR EQUAL (CCHHR)\nSKEQ     EQU   B'00101001'   SEARCH KEY EQUAL\nSKHI     EQU   B'01001001'   SEARCH KEY HIGH\nSKHEQ    EQU   B'01101001'   SEARCH KEY HIGH OR EQUAL\n*\nRHA      EQU   B'00011010'   READ HOME ADDRESS\nDRHA     EQU   B'00001010'   DIAGNOSTIC READ HOME ADDRESS\nRCT      EQU   B'00010010'   READ COUNT (CCHHRKDD)\nRR0      EQU   B'00010110'   READ RECORD 0\nRDT      EQU   B'00000110'   READ DATA\nRKD      EQU   B'00001110'   READ KEY AND DATA\nRCKD     EQU   B'00011110'   READ COUNT, KEY AND DATA\nRMCKD    EQU   B'01011110'   READ MULTIPLE COUNT, KEY AND DATA\nRSEC     EQU   B'00100010'   READ SECTOR\n*\nWHA      EQU   B'00011001'   WRITE HOME ADDRESS\nDWHA     EQU   B'00001001'   DIAGNOSTIC WRITE HOME ADDRESS\nWR0      EQU   B'00010101'   WRITE RECORD 0\nWDT      EQU   B'00000101'   WRITE DATA\nWKD      EQU   B'00001101'   WRITE KEY AND DATA\nWCKD     EQU   B'00011101'   WRITE COUNT, KEY AND DATA\nWSCKD    EQU   B'00000001'   WRITE SPECIAL COUNT, KEY AND DATA\nERASE    EQU   B'00010001'   ERASE\n*\n         AIF   ('&LIST' NE 'NO').MEND\n         POP   PRINT\n.MEND    MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#CON": {"ttr": 3844, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x14\\x11/\\x01\\x14\\x11/\\x12H\\x00y\\x00y\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-04-22T00:00:00", "modifydate": "2014-04-22T12:48:32", "lines": 121, "newlines": 121, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    #CON  &A,                      #CON                           X\n               &PATCH=YES,                                             X\n               &F=5,                                                   Z\n               &ORG=,                                                  x\n               &LOAD=YES,                                              x\n               &PREFIX=,                                               x\n               &BASE=                   ADDRESSING MODE\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*       #CON MACRO:                                                  *\n.*                                                                    *\n.*        #CON RESUME - CHANGE FROM THE CODE CSECT TO THE CONSTANT    *\n.*                                                                    *\n.*        #CON REVERT - BACK TO THE BASE CSECT                        *\n.*                                                                    *\n.*        #CON START - DEFINES THE START OF THE CONSTANT SECTION      *\n.*              PATCH=NO - NO PATCH AREA                              *\n.*              PATCH=YES - STANDARD LENGTH PATCH AREA                *\n.*              PATCH=XX - LENGTH XX PATCH                            *\n.*                                                                    *\n.*        #CON END   - THE END OF  THE CONSTANT AREA                  *\n.*                                                                    *\n.*        #CON USING - RESET ADDRESSABILITY TO THE CONSTANT AREA      *\n.*              BASE = RX - SET THE BASE TO RX - OMIT TO GET THE      *\n.*                     DEFAULT BASE = BASE FROM #START                *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n         GBLC  &STA_CONSTANT_SECTION    NAME OF CONSTANT SECT\n         GBLC  &STA_CONSTANT_BASE       BASE OF CONSTANT SECT\n         GBLC  &CONS_SECT,&CONS_STYP\n         GBLC  &STA_CONSTANT_LABEL\n         GBLA  &#PATCHN            Patch\n         GBLB  &STA_CONST,&SMODE   Have generated constants\n         LCLA  &N\n         LCLC  &BEGIN\n         LCLC  &CSNAME\n         AIF   ('&A' NE 'USING').MORE\n         AIF   (T'&BASE NE 'O').SETBASE\n&STA_CONSTANT_LABEL USING &STA_CONSTANT_SECTION,&STA_CONSTANT_BASE\n         AIF   ('&LOAD' EQ 'NO').SKLOAD\n         #RBL  &STA_CONSTANT_BASE,&STA_CONSTANT_SECTION\n.SKLOAD  ANOP  ,\n         MEXIT ,\n.SETBASE ANOP  ,\n&STA_CONSTANT_LABEL USING &STA_CONSTANT_SECTION,&BASE\n         #RBL  &BASE,&STA_CONSTANT_SECTION\n         MEXIT ,\n.MORE    ANOP  ,\n         AIF   ('&A' EQ '').ERR\n         AIF   ('&A' EQ 'START').START\n         AIF   ('&A' EQ '#START').STARTAA  From within #START\n         AIF   ('&A' EQ 'RESUME').RESUME\n         AIF   ('&A' EQ 'REVERT').REVERT\n         AIF   ('&A' EQ 'END').END\n         AIF   ('&A' EQ 'DROP').DROP\n.ERR     MNOTE 8,'OPERANDS IN ERROR'\n.STARTAA ANOP  ,\n.START    ANOP ,\n&CONS_SECT SETC '&SYSECT'\n&CONS_STYP SETC '&SYSSTYP'\n&STA_CONSTANT_SECTION LOCTR ,\n         AIF   (&STA_CONST).GCONST Already have constants\n         DC    CL8'&CONS_SECT'     Module name\n         DC    A(&CONS_SECT)       .and address\n&STA_CONST SETB 1\n.GCONST  ANOP  ,\n         AIF   ('&A' EQ '#START').REVERT From within #START\n         MEXIT ,\n.RESUME  ANOP  ,\n&CONS_SECT SETC '&SYSECT'\n&CONS_STYP SETC '&SYSSTYP'\n&CONS_STYP SETC 'LOCTR'\n&CSNAME  SETC  '&PREFIX&STA_CONSTANT_SECTION'\n&CSNAME  SETC  '&CSNAME'(1,8)\n&CSNAME  LOCTR ,\n         AIF   ('&PREFIX' EQ '').SKPREF\n         AIF   (&SMODE).SKPREF\n&SMODE   SETB  1\n*&CSNAME AMODE 31\n*&CSNAME RMODE ANY\n.SKPREF  ANOP  ,\n         MEXIT ,\n.END     ANOP  ,\n         LTORG ,\n&CONS_SECT &CONS_STYP ,  RESUME INTIAL SECTION\n&CONS_SECT LOCTR ,  RESUME INTIAL SECTION\n         AIF   ('&PATCH' EQ 'NO').ST00500\n&#PATCHN SETA  &#PATCHN+1\n&N       SETA  &#PATCHN\n&BEGIN   SETC  '&CONS_SECT'\n         AIF   ('&ORG' EQ '').Z\n&BEGIN   SETC  '&ORG'\n.Z       PUSH  PRINT\n         PRINT ON,GEN,DATA\n         AIF   ('&F' EQ 'S').FIXED\n@PSIZE&N EQU   ((*-&BEGIN+99)/100)*&F\n&STA_CONSTANT_SECTION LOCTR ,\n@PATCH&N DC    25S(*)                   MODULE PATCH AREA\n         ORG   @PATCH&N\n         DC    ((@PSIZE&N+1)/2)S(*)\n         ORG   ,\n&CONS_SECT &CONS_STYP ,  RESUME INTIAL SECTION\n&CONS_SECT LOCTR ,  RESUME INTIAL SECTION\n         POP   PRINT\n         MEXIT ,\n.FIXED   ANOP  ,\n&STA_CONSTANT_SECTION LOCTR ,\n         DC    28S(*)                   MODULE PATCH AREA\n&CONS_SECT &CONS_STYP ,  RESUME INTIAL SECTION\n&CONS_SECT LOCTR ,  RESUME INTIAL SECTION\n         POP   PRINT\n.ST00500 ANOP  ,\n         MEXIT ,\n.REVERT  ANOP  ,\n&CONS_SECT &CONS_STYP ,  RESUME INTIAL SECTION\n&CONS_SECT LOCTR ,  RESUME INTIAL SECTION\n         MEXIT ,\n.DROP    ANOP  ,\n         DROP  C\n.MEND    MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#CONBASE": {"ttr": 3846, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x14\\x11/\\x01\\x14\\x11/\\x12H\\x00\\x07\\x00\\x07\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-04-22T00:00:00", "modifydate": "2014-04-22T12:48:32", "lines": 7, "newlines": 7, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         #CONBASE &CONSTANT\n         GBLC  &STA_CONSTANT_SECTION    NAME OF CONSTANT SECTION\n         USING &STA_CONSTANT_SECTION,&CONSTANT\n         #RBL  &CONSTANT,&STA_CONSTANT_SECTION GET BASE OF CONSTANT\n         MEXIT ,\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#COPY": {"ttr": 6917, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00W\\x01\\x160\\x7f\\x01\\x160\\x7f\\x12#\\x00S\\x00S\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2016-11-02T00:00:00", "modifydate": "2016-11-02T12:23:57", "lines": 83, "newlines": 83, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&LABEL   #COPY &FUNC,&BR=NO,&SIZE=,&WHO=,&YEAR=\n.**********************************************************************\n.*                                                                    *\n.*     THIS MACRO IS USED TO INSERT THE NECESSARY COPYRIGHT           *\n.*     NOTICE INTO BOTH THE LISTING AND THE OBJECT CODE.  NOTE        *\n.*     THAT MNOTES PRINT REGARDLESS OF USE OF PRINT NOGEN.            *\n.*                                                                    *\n.*     THE MACRO HAS TWO FUNCTIONS, 'SET' AND 'GEN'.  'SET' IS        *\n.*     USED TO ESTABLISH THE NAME OF THE COPYRIGHT HOLDER AND/OR      *\n.*     SET THE GLOBAL &#COPYSZ FOR USE IN AN OUTER MACRO.  'GEN'      *\n.*     IS CODED TO ACTUALLY GENERATE THE COPYRIGHT.  IF NEITHER       *\n.*     IS CODED, 'GEN' IS ASSUMED.                                    *\n.*                                                                    *\n.**********************************************************************\n         GBLA  &#COPY\n         GBLA  &#COPYSZ                 TOTAL SIZE OF STRING IN BYTES\n         GBLC  &#COPYYR                 YEAR OF COPYRIGHT\n         GBLC  &#COPYWH                 NAME OF COPYRIGHT HOLDER\n         LCLA  &N\n         LCLC  &X,&Y\n.*\n&X       SETC  '&SYSDATC'(1,4)\n         AIF   ('&YEAR' EQ '').NOYEAR\n&#COPYYR SETC  '&YEAR'\n.NOYEAR  ANOP  ,\n.*\n         AIF   ('&WHO' NE '').EXPLW     NAME CODED ?\n         AIF   ('&#COPYWH' NE '').SIZE  FIRST TIME THRU ?\n&#COPYWH SETC  'zOS.JES2@Gmail.com'     SET DEFAULT NAME\n         AGO   .SIZE                    GO SET SIZE\n.*\n.EXPLW   ANOP  ,                        EXPLICIT NAME CODED\n&#COPYSZ SETA  0                        MUST RESET SIZE\n         AIF   ('&WHO'(1,1) NE '''').NOQUOTE\n&N       SETA  K'&WHO-2                 STRIP APOSTROPHES\n&#COPYWH SETC  '&WHO'(2,&N)\n         AGO   .SIZE\n.NOQUOTE ANOP  ,\n&#COPYWH SETC  '&WHO'                   UNQUOTED EXPLICIT NAME\n.*\n.SIZE    AIF   ('&SIZE' NE '').EXPL     IS SIZE CODED ?\n         AIF   (&#COPYSZ NE 0).FUNC\n&#COPYSZ SETA  ((42+K'&#COPYWH+1)/2)*2  EVEN DEFAULT SIZE\n         AGO   .FUNC\n.EXPL    ANOP  ,\n&#COPYSZ SETA  ((&SIZE+1)/2)*2          ROUNDED EXPLICIT SIZE\n.*\n.FUNC    ANOP  ,\n         AIF   (&#COPY NE 0).FUNC1\n&#COPY   SETA  1\n         AIF   ('&#COPYYR' NE '').YEAROK\n&#COPYYR SETC  '1985, &X'\n&#COPYSZ SETA  &#COPYSZ+6\n         AGO   .FUNC1\n.YEAROK  ANOP  ,\n         AIF   ('&#COPYYR' EQ '&X').FUNC1\n&#COPYYR SETC  '&#COPYYR., &X'\n&#COPYSZ SETA  &#COPYSZ+6\n.FUNC1   ANOP  ,\n         AIF   ('&FUNC' EQ 'SET').MEND\n         AIF   ('&FUNC' EQ '' OR '&FUNC' EQ 'GEN').GEN\n         MNOTE 4,'Invalid Function &FUNC, GEN Assumed'\n.*\n.GEN     ANOP  ,                        GENERATE THE COPYRIGHT\n         AIF   ('&BR' EQ 'NO').NOBR     BRANCH NEEDED ?\n&N       SETA  &#COPYSZ+4\n         B     *+&N                     BR AROUND COPYRIGHT NOTICE\n.NOBR    ANOP  ,\n*\n         MNOTE '*        (C) Copyright &#COPYYR &#COPYWH.'\n         MNOTE '*        Program Property Of &#COPYWH.'\n         MNOTE '*        All Rights Reserved.'\n MNOTE '*        No part of this program may be reproduced, stored'\n MNOTE '*        in a retrieval system or transmitted in any form'\n MNOTE '*        or by any means, including photocopying, recording,'\n MNOTE '*        electronic, mechanical or otherwise without the'\n MNOTE '*        written consent of the copyright holder.'\n*\n&N       SETA  &#COPYSZ-22\n&LABEL   DC    CL&N.' (C) Copyright &#COPYYR &#COPYWH  '\n         DC    CL22' All Rights Reserved.'\n.MEND    MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#CTGFL": {"ttr": 2823, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x06\\x01\\x11\\x14?\\x01\\x11\\x14?\\tB\\x00\\xcf\\x00\\xcf\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2011-05-23T00:00:00", "modifydate": "2011-05-23T09:42:06", "lines": 207, "newlines": 207, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    #CTGFL &FLDNAME,               NAME OF CTGFL TO BE BUILT      X\n               &DATA=,                  ADDR OF DATA FOR FIELD         X\n               &CHAIN=,                 ADDR OF CTGFL FOR TESTS        X\n               &TYPE=REQUEST,           TYPE OF CTGFL (TEST OR REQ)    X\n               &MF=L,                   MACRO FORMAT (LIST OR EXEC)    X\n               &GROUP=,                 GROUP CODE OF FIELD            X\n               &PREFIX=CTG              PREFIX FOR LABEL GENERATION\n.*\n.*       Note:\n.*           The #CTGFL/#CTGPL & #GETFL macros are used in building\n.*           SVC 26 parameter lists.\n.*           The CSI is now available but at the time that these macros\n.*           were developed this facility was not available.\n.*           Use at your own risk.\n.*\n.*           Please refer to CBT File 689 for SVC 26 parameter list\n.*           documentation.\n.*\n.*\n.* DEFINE LOCAL SET SYMBOLS\n.*\n         LCLA  &I                       LOOP COUNTER\n         LCLB  &REQ                     =1 IF THIS IS A REQUEST TYPE\n         LCLB  &TST                     =1 IF THIS IS A TEST TYPE\n         LCLC  &NOENT                   SET TO NUMBER OF FIELDS\n         LCLC  &COND                    SET TO HEX VALUE FOR TEST\n         LCLC  &CTBL(19)                TABLE TO TRANSLATE TEST CONDS\n         LCLC  &LABEL                   DEFINITION OF LABEL\n         LCLC  &IX                      SET TO &SYSNDX VALUE\n         LCLC  &REG                     USED WHEN REG ADDR SPECD\n.*\n.* INITIALIZE SET SYMBOLS TO NONSTANDARD DEFAULTS\n.*\n&NOENT   SETC  '01'                     1 ENTRY IF NOT MULTITYPE\n&IX      SETC  '&SYSNDX'                INITIALIZE SHORT INDEX\n&LABEL   SETC  '&PREFIX'(1,4)           ONLY USE FOUR CHARS FROM PREF\n&LABEL   SETC  '&LABEL.&IX'             GENERATE A UNIQUE LABEL\n.*\n&CTBL(1) SETC  'EQ'                     --+\n&CTBL(2) SETC  'NE'\n&CTBL(3) SETC  'GT'\n&CTBL(4) SETC  'LT'\n&CTBL(5) SETC  'GE'\n&CTBL(6) SETC  'LE'                     THIS TABLE PROVIDES\n&CTBL(7) SETC  'Z'\n&CTBL(8) SETC  'ON'                     A REFERENCE TO DETERMINE\n&CTBL(9) SETC  'MX'\n&CTBL(11) SETC 'CTGFLDEQ'               TEST CONDITIONS FROM\n&CTBL(12) SETC 'CTGFLDNE'\n&CTBL(13) SETC 'CTGFLDGT'               INPUT MNEMONICS\n&CTBL(14) SETC 'CTGFLDLT'\n&CTBL(15) SETC 'CTGFLDGE'\n&CTBL(16) SETC 'CTGFLDLE'\n&CTBL(17) SETC 'CTGFLDZ'\n&CTBL(18) SETC 'CTGFLDON'\n&CTBL(19) SETC 'CTGFLDMX'               --+\n.*\n.*  PARSE THE FIELDNAME PARAMETER\n.*\n.FLD1    ANOP  ,\n         AIF   ('&FLDNAME' EQ '').ERR1   ERROR IF NO FIELDNAME\n         AIF   ('&FLDNAME' NE 'MULTITYP').FEND\n&NOENT   SETC  '04'                     MULTITYP HAS 4 ENTRIES\n.FEND    ANOP  ,\n.*\n.*  PARSE THE TYPE PARAMETER\n.*\n.TYPE1   ANOP  ,\n         AIF   (N'&TYPE NE 1).TYPE2      CHECK FOR REQUEST TYPE\n         AIF   ('&TYPE' NE 'REQUEST').ERR2\n&REQ     SETB  1                         SET REQUEST TYPE FLAG\n         AGO   .TEND                    END OF TYPE PARSE\n.TYPE2   AIF   (N'&TYPE NE 2).ERR2       CHECK FOR (TEST,COND) TYPE\n         AIF   ('&TYPE(1)' NE 'TEST').ERR2\n&TST     SETB  1                         SET TEST TYPE FLAG\n&I       SETA  1                        SET UP TO SEARCH COND TABLE\n.TYPE3   AIF   ('&TYPE(2)' EQ '&CTBL(&I)').TYPE4   FOUND MNEMONIC\n&I       SETA  &I+1                     INCREMENT COUNTER\n         AIF   (&I GT 9).ERR5            MNEMONIC NOT FOUND => ERROR\n         AGO   .TYPE3                   KEEP SEARCHING\n.TYPE4   ANOP  ,\n&I       SETA  &I+10                    INDEX INTO HEX CODE TABLE\n&COND    SETC  '&CTBL(&I)'              SET COND CODE HEX VALUE\n.TEND    ANOP  ,\n.*\n.*  PARSE THE DATA PARAMETER\n.*\n.DATA1   ANOP  ,\n         AIF   ('&DATA' EQ '').DEND      CHECK IF DATA SUPPLIED\n         AIF   (N'&DATA NE 2).ERR3       CHECK IF DATA VALID\n.DEND    ANOP  ,\n.*\n.*  PARSE THE MF PARAMETER\n.*\n.MF1     ANOP  ,\n         AIF   (N'&MF NE 1).MF2          CHECK FOR MF=?\n         AIF   ('&MF' NE 'L').ERR4       NOT MF=L => ERROR\n         AGO   .LFORM1                  PRODUCE LIST FORM OF CTGFL\n.MF2     AIF   (N'&MF NE 2).ERR4         MF NOT (?,?) => ERROR\n         AIF   ('&MF(1)' NE 'E').ERR4    MF NOT (E,?) => ERROR\n         AGO   .EFORM1                  PRODUCE EXECUTE FORM OF CTGFL\n.MEND    ANOP  ,\n.*\n.* GENERATE THE LIST FORM OF THE CTGFL\n.*\n.LFORM1  ANOP  ,\n&NAME    DS    0F                       #CTGFL MACRO JAN 21 1980\n         DC    X'&NOENT'                NO OF LEN/ADDR ENTRIES\n         AIF   (&TST).LFORM2             FILL IN CONDITION FIELD\n         DC    X'00'                    NOT A TEST CTGFL\n         AGO   .LFORM3                  CONTINUE WITH CTGFL\n.LFORM2  ANOP  ,\n         DC    AL1(&COND)               TEST CONDITION\n.LFORM3  ANOP  ,\n         AIF   ('&GROUP' EQ '').LFORM4   NO GROUP CODE SPECD\n         DC    C'&GROUP'                TYPE (GROUP) CODE\n         AGO   .LFORM5\n.LFORM4  ANOP  ,\n         DS    C                        RESERVED\n.LFORM5  ANOP  ,\n         DS    X                        TEST RESULTS\n         DS    XL4                      WORKAREA\n         DC    A(&LABEL)                ADDR OF FIELDNAME\n         AIF   ('&CHAIN' EQ '').LFORM6   NO CHAIN SPECIFIED\n         DC    A(&CHAIN)                ADDR OF CTGFL FOR TESTS\n         AGO   .LFORM7\n.LFORM6  ANOP  ,\n         DS    A                        RESERVED\n.LFORM7  ANOP  ,\n         AIF   ('&DATA' NE '').LFORM8    NO DATA SPECIFIED\n&I       SETA  &NOENT*2                 NUMBER OF WORDS FOR DATA\n         DS    &I.A                     LEN/ADDR OF DATA\n         AGO   .LFORM9\n.LFORM8  DC    A(&DATA(2))              DATA LENGTH\n         DC    A(&DATA(1))              DATA ADDRESS\n         AIF   ('&NOENT' EQ '01').LFORM9   NOT A MULTITYP CTGFL\n         DS    6A                       LEN/ADDR FOR MULTITYP\n.LFORM9  ANOP  ,\n&LABEL   DC    CL8'&FLDNAME'            NAME OF THE FIELD\n         MEXIT ,\n.*\n.* GENERATE THE EXECUTE FORM OF THE CTGFL MACRO\n.*\n.EFORM1  ANOP  ,\n         PUSH  USING                    #CTGFL MACRO JAN 21 1980\n         USING CTGFL,15                 ADDRESS THE CTGFL\n         AIF   ('&MF(2)'(1,1) EQ '(').EREGS   TEST IF REG SPECD\n&NAME    LA    15,&MF(2)                REG 1 -> CTGFL\n         AGO   .EBLD                    GO BUILD PARM LIST\n.EREGS   ANOP  ,\n&REG     SETC  '&MF(2)'(2,K'&MF(2)-2)   STRIP THE PARENTHESIS\n&NAME    LR    15,&REG                  REG 1 -> CTGFL\n.EBLD    ANOP  ,\n         MVI   CTGFLDNO,X'&NOENT'       NUMBER OF ENTRIES\n         AIF   (NOT &TST).EFORM3              NOT BUILDING A TEST CTGFL\n         MVI   CTGFLDCD,&COND           TEST CONDITION\n.EFORM3  AIF   ('&GROUP' EQ '').EFORM4        NO GROUP CODE SPECIFIED\n         MVI   CTGFLDGC,C'&GROUP'       TYPE (GROUP) CODE\n.EFORM4  ANOP  ,\n         AIF   ('&FLDNAME'(1,1) EQ '(').FLDREG   TEST IF REG SPECD\n         LA    0,=CL8'&FLDNAME'         SAVE ADDRESS OF\n         ST    0,CTGFLDNM               THE FIELD NAME\n         AGO   .ECHAIN\n.FLDREG  ANOP  ,\n&REG     SETC  '&FLDNAME'(2,K'&FLDNAME-2) STRIP THE PARANTHESIS\n         ST    &REG,CTGFLDNM            SAVE FIELD NAME ADDRESS\n.ECHAIN  ANOP  ,\n         AIF   ('&CHAIN' EQ '').EFORM5        NO CHAIN CTGFL\n         AIF   ('&CHAIN'(1,1) EQ '(').ECREG   CHAIN SPECD BY REG\n         LA    0,&CHAIN                 SAVE ADDRESS OF\n         ST    0,CTGFLCHN               THE CTGFL FOR TESTS\n         AGO   .EFORM5\n.ECREG   ANOP  ,\n&REG     SETC  '&CHAIN'(2,K'&CHAIN-2)   GET RID OF PARENS\n         ST    &REG,CTGFLCHN            SET PTR TO CTGFL FOR TEST\n.EFORM5  AIF   ('&DATA' EQ '').EFORM7         NO DATA POINTERS\n         AIF   ('&DATA(2)'(1,1) EQ '(').EDREG2   LENGTH SPECD BY REG\n         LA    0,&DATA(2)               SAVE THE LENGTH\n         ST    0,CTGFLNG                OF THE FIELD DATA\n         AGO   .EFORM6\n.EDREG2  ANOP  ,\n&REG     SETC  '&DATA(2)'(2,K'&DATA(2)-2) GET RID OF PARENS\n         ST    &REG,CTGFLNG             SET DATA LENGTH\n.EFORM6  AIF   ('&DATA(1)'(1,1) EQ '(').EDREG1   ADDR SPECD BY REG\n         LA    0,&DATA(1)               SAVE THE ADDRESS\n         ST    0,CTGFLPT                OF THE FIELD DATA\n         AGO   .EFORM7\n.EDREG1  ANOP  ,\n&REG     SETC  '&DATA(1)'(2,K'&DATA(1)-2) GET RID OF PARENS\n         ST    &REG,CTGFLPT             SET POINTER TO DATA\n.EFORM7  ANOP  ,\n         POP   USING\n         MEXIT ,\n.*\n.* ERROR MESSAGES ISSUED FROM THIS MACRO\n.*\n.ERR1    MNOTE 8,'No Field Name Specified'\n         MEXIT ,\n.ERR2    MNOTE 8,'Invalid TYPE Parameter'\n         MEXIT ,\n.ERR3    MNOTE 8,'Invalid DATA Parameter'\n         MEXIT ,\n.ERR4    MNOTE 8,'Invalid MF Parameter'\n         MEXIT ,\n.ERR5    MNOTE 8,'Invalid TEST Condition'\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#CTGFV": {"ttr": 3073, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x06\\x01\\x11\\x14?\\x01\\x11\\x14?\\tB\\x01\\x85\\x01\\x85\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2011-05-23T00:00:00", "modifydate": "2011-05-23T09:42:06", "lines": 389, "newlines": 389, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    #CTGFV &TYPE=,                 CATALOG RECORD TYPE            X\n               &OPTIONS=,               CATLG MGMT SERVICES OPTIONS    X\n               &NUMBER=,                ELEMENT NUMBER OF CMSPCATR     X\n               &DATA=,                  CLUSTERS DATA  CTGFV           X\n               &INDEX=,                 CLUSTERS INDEX CTGFV           X\n               &VOLUME=,                SPACE CTGFV                    X\n               &FILE=,                  ADDRESS OF JCL DD STATEMENT    X\n               &ENTRY=,                 ENTRY NAME CTGFL               X\n               &SEC=,                   SECURITY INFORMATION CTGFL     X\n               &OWNER=,                 OWNER IDENTIFICATION CTGFL     X\n               &EXPDT=,                 EXPIRATION DATE CTGFL          X\n               &CREDT=,                 CREATION DATE CTGFL            X\n               &VOLSER=,                VOLUME SERIAL NUMBER LIST      X\n               &KEY=,                   KEY RANGE LIST                 X\n               &DEVT=,                  DEVICE TYPE CTGFL              X\n               &SPACE=,                 SPACE ALLOCATION CTGFL         X\n               &AMDSB=,                 AMDSB CTGFL                    X\n               &SEQ=,                   SEQUENCE NUMBER CTGFL          X\n               &ATTR=,                  DATASET ATTIBUTES CTGFL        X\n               &BUFFSIZ=,               BUFFER SIZE CTGFL              X\n               &RECSIZ=,                AVERAGE RECORD SIZE CTGFL      X\n               &GDGLIM=,                GDG LIMIT CTGFL                X\n               &EXIT=,                  EXCEPTION EXIT PARAMETER LIST  X\n               &GDGATTR=,               GDG ATTRIBUTES CTGFL           X\n               &TRUENM=,                TRUE NAME CTGFL                X\n               &PASSWRD=,                RELATED OBJECT'S PASSWORD     X\n               &FEEDBK=,                CRA FEEDBACK AREA              X\n               &MF=L                    MACRO FORMAT\n.**********************************************************************\n         LCLC  &REG\n.*\n.*       Note:\n.*           The #CTGFL/#CTGPL & #GETFL macros are used in building\n.*           SVC 26 parameter lists.\n.*           The CSI is now available but at the time that these macros\n.*           were developed this facility was not available.\n.*           Use at your own risk.\n.*\n.*           Please refer to CBT File 689 for SVC 26 parameter list\n.*           documentation.\n.*\n.**********************************************************************\n.*  PARSE THE MF PARAMETER                                            *\n.**********************************************************************\n.MF1     ANOP  ,\n         AIF   (N'&MF NE 1).MF2               CHECK FOR MF=?\n         AIF   ('&MF' EQ 'L').LFORM1          NOT MF=L => ERROR\n.MF2     AIF   (N'&MF NE 2).MFERR             MF NOT (?,?) => ERROR\n         AIF   ('&MF(1)' EQ 'E').EFORM1       MF NOT (E,?) => ERROR\n.MFERR   ANOP  ,\n         MNOTE 8,'Invalid MF Parameter' ERROR *  INVALID MF=\n         MEXIT ,\n.**********************************************************************\n.* GENERATE THE LIST FORM OF THE #CTGFV MACRO                         *\n.**********************************************************************\n.LFORM1  ANOP  ,\n         MNOTE 8,'List Form Not Available At This Time'\n         MEXIT ,\n.**********************************************************************\n.* GENERATE THE EXECUTE FORM OF THE #CTGFV MACRO                      *\n.**********************************************************************\n.EFORM1  ANOP  ,\n         PUSH  USING\n         USING CTGFV,15                 ADDRESS THE CTGFV\n         AIF   ('&MF(2)'(1,1) EQ '(').EFORM2   CHECK IF REG SPECIFIED\n&NAME    LA    15,&MF(2)                >>--> FIELD VECTOR TABLE\n         AGO   .TYPE1\n.EFORM2  ANOP  ,\n&REG     SETC  '&MF(2)'(2,K'&MF(2)-2)   STRIP THE PARENTHESIS\n&NAME    LR    15,&REG                  >>--> FIELD VECTOR TABLE\n.**********************************************************************\n.* UPDATE THE TYPE FIELD                                              *\n.**********************************************************************\n.TYPE1   ANOP  ,\n         AIF   ('&TYPE'(1,1) EQ '(').TYPE2    CHECK IF REG SPECIFIED\n         MVI   CTGFVTYP,&TYPE           INSERT RECORD TYPE\n         AGO   .OPTION1\n.TYPE2   ANOP  ,\n&REG     SETC  '&TYPE'(2,K'&TYPE-2)     STRIP THE PARENTHESIS\n         STC   &REG,CTGFVTYP            INSERT RECORD TYPE\n.**********************************************************************\n.* UPDATE THE CATALOG MANAGEMENT SERVICES PROCESSING OPTIONS          *\n.**********************************************************************\n.OPTION1 ANOP  ,\n         AGO   .NUMBER1\n.**********************************************************************\n.* UPDATE THE ELEMENT NUMBER OF CMSPCATR                              *\n.**********************************************************************\n.NUMBER1 ANOP  ,\n         AIF   ('&NUMBER' EQ '').DATA1        SKIP IF NOT SPECIFIED\n         AIF   ('&NUMBER'(1,1) EQ '(').NUMBER2 CHECK IF REG SPECIFIED\n         MVI   CTGFVELM,&NUMBER         INSERT ELEMENT NUMBER\n         AGO   .DATA1\n.NUMBER2 ANOP  ,\n&REG     SETC  '&NUMBER'(2,K'&NUMBER-2) STRIP THE PARENTHESIS\n         STC   &REG,CTGFVELM            INSERT ELEMENT NUMBER\n.**********************************************************************\n.* UPDATE THE ADDRESS OF THE CLUSTER'S DATA CTGFV                     *\n.**********************************************************************\n.DATA1   ANOP  ,\n         AIF   ('&DATA' EQ '').INDEX1         SKIP IF NOT SPECIFIED\n         AIF   ('&DATA'(1,1) EQ '(').DATA2    CHECK IF REG SPECIFIED\n         LA    R0,&DATA                 SAVE ADDRESS OF THE\n         ST    R0,CTGFVDCH              CLUSTER'S DATA CTGFV\n         AGO   .INDEX1\n.DATA2   ANOP  ,\n&REG     SETC  '&DATA'(2,K'&DATA-2)     STRIP THE PARENTHESIS\n         ST    &REG,CTGFVDCH            SAVE DATA PORTION CTGFV\n.**********************************************************************\n.* UPDATE THE ADDRESS OF THE CLUSTER'S INDEX CTGFV                    *\n.**********************************************************************\n.INDEX1  ANOP  ,\n         AIF   ('&INDEX' EQ '').VOLUME1       SKIP IF NOT SPECIFIED\n         AIF   ('&INDEX'(1,1) EQ '(').INDEX2   CHECK IF REG SPECIFIED\n         LA    R0,&INDEX                SAVE ADDRESS OF THE\n         ST    R0,CTGFVICH              CLUSTER'S INDEX CTGFV\n         AGO   .VOLUME1\n.INDEX2  ANOP  ,\n&REG     SETC  '&INDEX'(2,K'&INDEX-2)   STRIP THE PARENTHESIS\n         ST    &REG,CTGFVICH            SAVE INDEX PORTION CTGFV\n.**********************************************************************\n.* UPDATE THE ADDRESS OF THE SPACE CTGFV                              *\n.**********************************************************************\n.VOLUME1 ANOP  ,\n         AIF   ('&VOLUME' EQ '').FILE1        SKIP IF NOT SPECIFIED\n         AIF   ('&VOLUME'(1,1) EQ '(').VOLUME2   CHECK IF REG SPECIFIED\n         LA    R0,&VOLUME               SAVE ADDRESS OF THE\n         ST    R0,CTGFVVCH              SPACE CTGFV\n         AGO   .FILE1\n.VOLUME2 ANOP  ,\n&REG     SETC  '&VOLUME'(2,K'&VOLUME-2) STRIP THE PARENTHESIS\n         ST    &REG,CTGFVVCH            SAVE SPACE CTGFV\n.**********************************************************************\n.* UPDATE THE ADDRESS OF THE ASSOCIATED JCL DD STATEMENT              *\n.**********************************************************************\n.FILE1   ANOP  ,\n         AIF   ('&FILE' EQ '').ENTRY1         SKIP IF NOT SPECIFIED\n         AIF   ('&FILE'(1,1) EQ '(').FILE2    CHECK IF REG SPECIFIED\n         LA    R0,&FILE                 SAVE ADDRESS OF THE\n         ST    R0,CTGFVIND              JCL DD STATEMENT\n         AGO   .ENTRY1\n.FILE2   ANOP  ,\n&REG     SETC  '&FILE'(2,K'&FILE-2)     STRIP THE PARENTHESIS\n         ST    &REG,CTGFVIND            SAVE JCL DD STMT ADDR\n.**********************************************************************\n.* UPDATE THE ADDRESS OF THE ENTRY NAME CTGFL                         *\n.**********************************************************************\n.ENTRY1  ANOP  ,\n         AIF   ('&ENTRY' EQ '').SECUR1        SKIP IF NOT SPECIFIED\n         AIF   ('&ENTRY'(1,1) EQ '(').ENTRY2   CHECK IF REG SPECIFIED\n         LA    R0,&ENTRY                SAVE ADDRESS OF THE\n         ST    R0,CTGFVENT              ENTRY NAME CTGFL\n         AGO   .SECUR1\n.ENTRY2  ANOP  ,\n&REG     SETC  '&ENTRY'(2,K'&ENTRY-2)   STRIP THE PARENTHESIS\n         ST    &REG,CTGFVENT            SAVE ENTRY NAME CTGFV\n.**********************************************************************\n.* UPDATE THE ADDRESS OF THE SECURITY INFORMATION CTGFL               *\n.**********************************************************************\n.SECUR1  ANOP  ,\n         AIF   ('&SEC' EQ '').OWNER1          SKIP IF NOT SPECIFIED\n         AIF   ('&SEC'(1,1) EQ '(').SECUR2    CHECK IF REG SPECIFIED\n         LA    R0,&SEC                  SAVE ADDRESS OF THE\n         ST    R0,CTGFVSTY              SECURITY INFO CTGFL\n         AGO   .OWNER1\n.SECUR2  ANOP  ,\n&REG     SETC  '&SEC'(2,K'&SEC-2)       STRIP THE PARENTHESIS\n         ST    &REG,CTGFVSTY            SAVE SECURITY CTGFV\n.**********************************************************************\n.* UPDATE THE ADDRESS OF THE OWNER IDENTIFICATION CTGFL               *\n.**********************************************************************\n.OWNER1  ANOP  ,\n         AIF   ('&OWNER' EQ '').EXPDT1        SKIP IF NOT SPECIFIED\n         AIF   ('&OWNER'(1,1) EQ '(').OWNER2   CHECK IF REG SPECIFIED\n         LA    R0,&OWNER                SAVE ADDRESS OF THE\n         ST    R0,CTGFVOWN              OWNER IDENT CTGFL\n         AGO   .EXPDT1\n.OWNER2  ANOP  ,\n&REG     SETC  '&OWNER'(2,K'&OWNER-2)   STRIP THE PARENTHESIS\n         ST    &REG,CTGFVOWN            SAVE SECURITY CTGFV\n.**********************************************************************\n.* UPDATE THE ADDRESS OF THE EXPIRATION DATE CTGFL                    *\n.**********************************************************************\n.EXPDT1  ANOP  ,\n         AIF   ('&EXPDT' EQ '').CREDT1        SKIP IF NOT SPECIFIED\n         AIF   ('&EXPDT'(1,1) EQ '(').EXPDT2   CHECK IF REG SPECIFIED\n         LA    R0,&EXPDT                SAVE ADDRESS OF THE\n         ST    R0,CTGFVEXP              EXPIRY DATE CTGFL\n         AGO   .CREDT1\n.EXPDT2  ANOP  ,\n&REG     SETC  '&EXPDT'(2,K'&EXPDT-2)   STRIP THE PARENTHESIS\n         ST    &REG,CTGFVEXP            SAVE EXPIRY DATE CTGFV\n.**********************************************************************\n.* UPDATE THE ADDRESS OF THE CREATION DATE CTGFL                      *\n.**********************************************************************\n.CREDT1  ANOP  ,\n         AIF   ('&CREDT' EQ '').VOLSER1       SKIP IF NOT SPECIFIED\n         AIF   ('&CREDT'(1,1) EQ '(').CREDT2   CHECK IF REG SPECIFIED\n         LA    R0,&CREDT                SAVE ADDRESS OF THE\n         ST    R0,CTGFVCRE              CREATE DATE CTGFL\n         AGO   .VOLSER1\n.CREDT2  ANOP  ,\n&REG     SETC  '&CREDT'(2,K'&CREDT-2)   STRIP THE PARENTHESIS\n         ST    &REG,CTGFVCRE            SAVE CREATE DATE CTGFV\n.**********************************************************************\n.* UPDATE THE ADDRESS OF THE VOLUME SERIAL NUMBER LIST                *\n.**********************************************************************\n.VOLSER1 ANOP  ,\n         AIF   ('&VOLSER' EQ '').KEY1         SKIP IF NOT SPECIFIED\n         AIF   ('&VOLSER'(1,1) EQ '(').VOLSER2   CHECK IF REG SPECIFIED\n         LA    R0,&VOLSER               SAVE ADDRESS OF THE\n         ST    R0,CTGFVVLT              VOLUME SERIAL LIST\n         AGO   .KEY1\n.VOLSER2 ANOP  ,\n&REG     SETC  '&VOLSER'(2,K'&VOLSER-2) STRIP THE PARENTHESIS\n         ST    &REG,CTGFVVLT            SAVE VOLUME SERIAL LIST\n.**********************************************************************\n.* UPDATE THE ADDRESS OF THE KEY RANGE LIST                           *\n.**********************************************************************\n.KEY1    ANOP  ,\n         AIF   ('&KEY' EQ '').DEVT1           SKIP IF NOT SPECIFIED\n         AIF   ('&KEY'(1,1) EQ '(').KEY2      CHECK IF REG SPECIFIED\n         LA    R0,&KEY                  SAVE ADDRESS OF THE\n         ST    R0,CTGFVRNG              KEY RANGE LIST\n         AGO   .DEVT1\n.KEY2    ANOP  ,\n&REG     SETC  '&KEY'(2,K'&KEY-2)       STRIP THE PARENTHESIS\n         ST    &REG,CTGFVRNG            SAVE KEY RANGE LIST\n.**********************************************************************\n.* UPDATE THE ADDRESS OF THE DEVICE TYPE CTGFL                        *\n.**********************************************************************\n.DEVT1   ANOP  ,\n         AIF   ('&DEVT' EQ '').SPACE1         SKIP IF NOT SPECIFIED\n         AIF   ('&DEVT'(1,1) EQ '(').DEVT2    CHECK IF REG SPECIFIED\n         LA    R0,&DEVT                 SAVE ADDRESS OF THE\n         ST    R0,CTGFVDVT              DEVICE TYPE CTGFL\n         AGO   .SPACE1\n.DEVT2   ANOP  ,\n&REG     SETC  '&DEVT'(2,K'&DEVT-2)     STRIP THE PARENTHESIS\n         ST    &REG,CTGFVRNG            SAVE DEVICE TYPE CTGFL\n.**********************************************************************\n.* UPDATE THE ADDRESS OF THE SPACE ALLOCATION INFORMATION CTGFL       *\n.**********************************************************************\n.SPACE1  ANOP  ,\n         AIF   ('&SPACE' EQ '').AMDSB1        SKIP IF NOT SPECIFIED\n         AIF   ('&SPACE'(1,1) EQ '(').SPACE2   CHECK IF REG SPECIFIED\n         LA    R0,&SPACE                SAVE ADDRESS OF THE\n         ST    R0,CTGFVSPC              SPACE ALLOCATION CTGFL\n         AGO   .AMDSB1\n.SPACE2  ANOP  ,\n&REG     SETC  '&SPACE'(2,K'&SPACE-2)   STRIP THE PARENTHESIS\n         ST    &REG,CTGFVSPC            SAVE DEVICE TYPE CTGFL\n.**********************************************************************\n.* UPDATE THE ADDRESS OF THE AMDSB CTGFL                              *\n.**********************************************************************\n.AMDSB1  ANOP  ,\n         AIF   ('&AMDSB' EQ '').SEQ1          SKIP IF NOT SPECIFIED\n         AIF   ('&AMDSB'(1,1) EQ '(').AMDSB2   CHECK IF REG SPECIFIED\n         LA    R0,&AMDSB                SAVE ADDRESS OF THE\n         ST    R0,CTGFVAMD              AMDSB CTGFL\n         AGO   .SEQ1\n.AMDSB2  ANOP  ,\n&REG     SETC  '&AMDSB'(2,K'&AMDSB-2)   STRIP THE PARENTHESIS\n         ST    &REG,CTGFVAMD            SAVE AMDSB CTGFL\n.**********************************************************************\n.* UPDATE THE ADDRESS OF THE FILE SEQUENCER NUMBER CTGFL              *\n.**********************************************************************\n.SEQ1    ANOP  ,\n         AIF   ('&SEQ' EQ '').ATTR1           SKIP IF NOT SPECIFIED\n         AIF   ('&SEQ'(1,1) EQ '(').SEQ2      CHECK IF REG SPECIFIED\n         LA    R0,&SEQ                  SAVE ADDRESS OF THE\n         ST    R0,CTGFVFSN              FILE SEQUENCE CTGFL\n         AGO   .ATTR1\n.SEQ2    ANOP  ,\n&REG     SETC  '&SEQ'(2,K'&SEQ-2)       STRIP THE PARENTHESIS\n         ST    &REG,CTGFVFSN            SAVE FILE SEQUENCE CTGFL\n.**********************************************************************\n.* UPDATE THE ADDRESS OF THE DATA SET ATTRIBUTES CTGFL                *\n.**********************************************************************\n.ATTR1   ANOP  ,\n         AIF   ('&ATTR' EQ '').BUFFER1        SKIP IF NOT SPECIFIED\n         AIF   ('&ATTR'(1,1) EQ '(').ATTR2    CHECK IF REG SPECIFIED\n         LA    R0,&ATTR                 SAVE ADDRESS OF THE\n         ST    R0,CTGFVATR              DSN ATTRIBUTE CTGFL\n         AGO   .BUFFER1\n.ATTR2   ANOP  ,\n&REG     SETC  '&ATTR'(2,K'&ATTR-2)     STRIP THE PARENTHESIS\n         ST    &REG,CTGFVATR            SAVE DSN ATTRIBUTE CTGFL\n.**********************************************************************\n.* UPDATE THE ADDRESS OF THE BUFFER SIZE CTGFL                        *\n.**********************************************************************\n.BUFFER1 ANOP  ,\n         AIF   ('&BUFFSIZ' EQ '').RECLEN1     SKIP IF NOT SPECIFIED\n         AIF   ('&BUFFSIZ'(1,1) EQ '(').BUFFER2   CHECK IF REG SPEC\n         LA    R0,&BUFFSIZ              SAVE ADDRESS OF THE\n         ST    R0,CTGFVBUF              FILE BUFFER SIZE CTGFL\n         AGO   .RECLEN1\n.BUFFER2 ANOP  ,\n&REG     SETC  '&BUFFSIZ'(2,K'&BUFFSIZ-2) STRIP THE PARENTHESIS\n         ST    &REG,CTGFVBUF            SAVE BUFFER SIZE CTGFL\n.**********************************************************************\n.* UPDATE THE ADDRESS OF THE AVERAGE RECORD SIZE CTGFL                *\n.**********************************************************************\n.RECLEN1 ANOP  ,\n         AIF   ('&RECSIZ' EQ '').GDGLIM1      SKIP IF NOT SPECIFIED\n         AIF   ('&RECSIZ'(1,1) EQ '(').RECLEN2   CHECK IF REG SPECIFIED\n         LA    R0,&RECSIZ               SAVE ADDRESS OF THE\n         ST    R0,CTGFVLRS              AVERAGE REC SIZE CTGFL\n         AGO   .GDGLIM1\n.RECLEN2 ANOP  ,\n&REG     SETC  '&RECSIZ'(2,K'&RECSIZ-2) STRIP THE PARENTHESIS\n         ST    &REG,CTGFVLRS            SAVE AVG REC SIZE CTGFL\n.**********************************************************************\n.* UPDATE THE ADDRESS OF THE GDG LIMIT CTGFL                          *\n.**********************************************************************\n.GDGLIM1 ANOP  ,\n         AIF   ('&GDGLIM' EQ '').EXIT1        SKIP IF NOT SPECIFIED\n         AIF   ('&GDGLIM'(1,1) EQ '(').GDGLIM2   CHECK IF REG SPECIFIED\n         LA    R0,&GDGLIM               SAVE ADDRESS OF THE\n         ST    R0,CTGFVLMT              GDG LIMIT CTGFL\n         AGO   .EXIT1\n.GDGLIM2 ANOP  ,\n&REG     SETC  '&GDGLIM'(2,K'&GDGLIM-2) STRIP THE PARENTHESIS\n         ST    &REG,CTGFVLMT            SAVE GDG LIMIT CTGFL\n.**********************************************************************\n.* UPDATE THE ADDRESS OF THE EXCEPTION EXIT PARAMETER LIST            *\n.**********************************************************************\n.EXIT1   ANOP  ,\n         AIF   ('&EXIT' EQ '').GDGATT1        SKIP IF NOT SPECIFIED\n         AIF   ('&EXIT'(1,1) EQ '(').EXIT2    CHECK IF REG SPECIFIED\n         LA    R0,&EXIT                 SAVE ADDRESS OF THE\n         ST    R0,CTGFVEXT              GDG LIMIT CTGFL\n         AGO   .GDGATT1\n.EXIT2   ANOP  ,\n&REG     SETC  '&EXIT'(2,K'&EXIT-2)     STRIP THE PARENTHESIS\n         ST    &REG,CTGFVEXT            SAVE GDG LIMIT CTGFL\n.**********************************************************************\n.* UPDATE THE ADDRESS OF THE GDG ATTIBUTES CTGFL                      *\n.**********************************************************************\n.GDGATT1 ANOP  ,\n         AIF   ('&GDGATTR' EQ '').RELATE1     SKIP IF NOT SPECIFIED\n         AIF   ('&GDGATTR'(1,1) EQ '(').GDGATT2   CHECK IF REG SPEC\n         LA    R0,&GDGATTR              SAVE ADDRESS OF THE\n         ST    R0,CTGFVGAT              GDG ATTRIB CTGFL\n         AGO   .RELATE1\n.GDGATT2 ANOP  ,\n&REG     SETC  '&GDGATTR'(2,K'&GDGATTR-2) STRIP THE PARENTHESIS\n         ST    &REG,CTGFVGAT            SAVE GDG ATTR CTGFL\n.**********************************************************************\n.* UPDATE THE ADDRESS OF THE TRUE NAME CTGFL                          *\n.**********************************************************************\n.RELATE1 ANOP  ,\n         AIF   ('&TRUENM' EQ '').PASS1        SKIP IF NOT SPECIFIED\n         AIF   ('&TRUENM'(1,1) EQ '(').RELATE2   CHECK IF REG SPEC\n         LA    R0,&TRUENM               SAVE ADDRESS OF THE\n         ST    R0,CTGFVNAM              TRUE NAME CTGFL\n         AGO   .PASS1\n.RELATE2 ANOP  ,\n&REG     SETC  '&TRUENM'(2,K'&TRUENM-2) STRIP THE PARENTHESIS\n         ST    &REG,CTGFVNAM            SAVE TRUE NAME CTGFL\n.**********************************************************************\n.* UPDATE THE ADDRESS OF THE RELATED OBJECT'S PASSWORD                *\n.**********************************************************************\n.PASS1   ANOP  ,\n         AIF   ('&PASSWRD' EQ '').FEEDBK1     SKIP IF NOT SPECIFIED\n         AIF   ('&PASSWRD'(1,1) EQ '(').PASS2   CHECK IF REG SPEC\n         LA    R0,&PASSWRD              SAVE ADDRESS OF THE\n         ST    R0,CTGFVPWD              RELATED OBJECTS PASSWORD\n         AGO   .FEEDBK1\n.PASS2   ANOP  ,\n&REG     SETC  '&PASSWRD'(2,K'&PASSWRD-2) STRIP THE PARENTHESIS\n         ST    &REG,CTGFVPWD            SAVE PASSWORD ADDRESS\n.**********************************************************************\n.* UPDATE THE ADDRESS OF THE CRA FEEDBACK AREA                        *\n.**********************************************************************\n.FEEDBK1 ANOP  ,\n         AIF   ('&FEEDBK' EQ '').MEXIT        SKIP IF NOT SPECIFIED\n         AIF   ('&FEEDBK'(1,1) EQ '(').FEEDBK2   CHECK IF REG SPEC\n         LA    R0,&FEEDBK               SAVE ADDRESS OF THE\n         ST    R0,CTGFVWKA              CRA FEEDBACK AREA\n         AGO   .MEXIT\n.FEEDBK2 ANOP  ,\n&REG     SETC  '&FEEDBK'(2,K'&FEEDBK-2) STRIP THE PARENTHESIS\n         ST    &REG,CTGFVWKA            SAVE CRA FEEDBACK ADDR\n.**********************************************************************\n.MEXIT   ANOP  ,\n         POP   USING\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#CTGPL": {"ttr": 5121, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x007\\x01\\x16 \\x1f\\x01\\x16 \\x1f\\x14\\x18\\x02<\\x02<\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2016-07-19T00:00:00", "modifydate": "2016-07-19T14:18:37", "lines": 572, "newlines": 572, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    #CTGPL &FUNC,                  USER REQUESTED FUNCTION        X\n               &WORK=,                  ADDR OF WORKAREA               X\n               &FIELDS=,                LIST OF CTGFL ADDRESSES        X\n               &CRI=,                   ADDR OF CTLG REC IDENTIFIER    X\n               &FV=,                    ADDR OF CTGFV                  X\n               &NT=,                    ADDR OF CTGNT                  X\n               &CATALOG=,               ADDR OF CATALOG NAME OR ACB    X\n               &CVOL=,                  ADDR OF CVVOL NAME             X\n               &TYPE=,                  TYPE OF CATALOG RECORD REF'D   X\n               &NEWNAME=,               ADDR OF NEW OBJECT NAME        X\n               &DDNAME=,                ADDR OF JCL DD ASSOC WITH REQ  X\n               &JSCB=,                  ADDR OF JSCB                   X\n               &PASSWRD=,               ADDR OF USER SUPPLIED PASSWD   X\n               &OPTIONS=,               LIST OF OPTIONS REQUESTED      X\n               &DSORG=,                 DATASET ORG. FOR SUPERLOCATE   X\n               &MF=L                    MACRO FORMAT (DEFAULT=LIST)\n.*\n.*       NOTE:\n.*           THE #CTGFL/#CTGPL & #GETFL MACROS ARE USED IN BUILDING\n.*           SVC 26 PARAMETER LISTS.\n.*           THE CSI IS NOW AVAILABLE BUT AT THE TIME THAT THESE MACROS\n.*           WERE DEVELOPED THIS FACILITY WAS NOT AVAILABLE.\n.*           USE AT YOUR OWN RISK.\n.*\n.*           PLEASE REFER TO CBT FILE 689 FOR SVC 26 PARAMETER LIST\n.*           DOCUMENTATION.\n.*\n.**********************************************************************\n.*                                                                    *\n.* DEFINE LOCAL SET SYMBOLS                                           *\n.*                                                                    *\n.**********************************************************************\n         LCLB  &O(32)                   FOUR OPTION BYTES\n         LCLC  &OMN(44)                 OPTION MNEMONICS\n         LCLA  &OBI(44)                 OPTION BIT\n         LCLA  &I,&J,&K,&L              LOOP COUNTERS\n         LCLC  &BYTE                    WORK STORAGE\n         LCLB  &CMS                     CMS OPTIONS REQUESTED\n         LCLC  &OPTN                    CMS OPTION BIT STRING\n         LCLB  &FMT2                    FORMAT-2 WORK AREA\n         LCLC  &REG                     REGISTER OPERAND\n         LCLC  &WRKAREA                 WORKAREA POINTER\n         LCLC  &WRKLEN                  WORKAREA LENGTH\n         LCLC  &WRKFMT2                 FORMAT-2 WORKAREA\n.*\n&OMN(1)  SETC  'BYPSS'                  --+\n&OMN(2)  SETC  'MAST'\n&OMN(3)  SETC  'CI'\n&OMN(4)  SETC  'UPD'\n&OMN(5)  SETC  'READ'\n&OMN(6)  SETC  'NAME'\n&OMN(7)  SETC  'CNAME'\n&OMN(8)  SETC  'GENLD'\n&OMN(9)  SETC  'EXT'\n&OMN(10) SETC  'NSVS'                   DEFINE A TABLE OF\n&OMN(11) SETC  'ERASE'                  VALID OPTIONS\n&OMN(12) SETC  'SMF'\n&OMN(13) SETC  'REL'\n&OMN(14) SETC  'GTALL'\n&OMN(15) SETC  'PURG'\n&OMN(16) SETC  'VMNT'\n&OMN(17) SETC  'RCATN'\n&OMN(18) SETC  'GTNXT'\n&OMN(19) SETC  'UCRAX'\n&OMN(20) SETC  'DELRC'\n&OMN(21) SETC  'DISC'\n&OMN(22) SETC  'OVRID'\n&OMN(23) SETC  'CNVTC'\n&OMN(24) SETC  'SCR'\n&OMN(25) SETC  'BOTH'\n&OMN(26) SETC  'SUPLT'\n&OMN(27) SETC  'GDGL'\n&OMN(28) SETC  'SRH'\n&OMN(29) SETC  'NUM'\n&OMN(30) SETC  'AM0'\n&OMN(31) SETC  'LBASE'\n&OMN(32) SETC  'NODOCAT'\n&OMN(33) SETC  'NPROF'\n&OMN(34) SETC  'COIN'\n&OMN(35) SETC  'BYPMT'\n&OMN(36) SETC  'TIOT'\n&OMN(37) SETC  'ICFC'\n&OMN(38) SETC  'ICFOR'\n&OMN(39) SETC  'GFLIC'\n&OMN(40) SETC  'SWAP'\n&OMN(41) SETC  'RESM'\n&OMN(42) SETC  'CDI'\n&OMN(43) SETC  'NDISC'\n&OMN(44) SETC  'NOCON'                  --+\n.*\n&OBI(1)  SETA  1                        --+\n&OBI(2)  SETA  2\n&OBI(3)  SETA  3\n&OBI(4)  SETA  4\n&OBI(5)  SETA  5\n&OBI(6)  SETA  6\n&OBI(7)  SETA  7\n&OBI(8)  SETA  8\n&OBI(9)  SETA  9                        DEFINE THE TABLE OF BIT\n&OBI(10) SETA  9                        POSITIONS CORRESPONDING\n&OBI(11) SETA  10                       TO THE OPTIONS\n&OBI(12) SETA  10\n&OBI(13) SETA  10\n&OBI(14) SETA  10\n&OBI(15) SETA  11\n&OBI(16) SETA  11\n&OBI(17) SETA  11\n&OBI(18) SETA  12\n&OBI(19) SETA  12\n&OBI(20) SETA  12\n&OBI(21) SETA  13\n&OBI(22) SETA  14\n&OBI(23) SETA  14\n&OBI(24) SETA  15\n&OBI(25) SETA  16\n&OBI(26) SETA  20\n&OBI(27) SETA  21\n&OBI(28) SETA  22\n&OBI(29) SETA  23\n&OBI(30) SETA  24\n&OBI(31) SETA  25\n&OBI(32) SETA  26\n&OBI(33) SETA  27\n&OBI(34) SETA  28\n&OBI(35) SETA  29\n&OBI(36) SETA  30\n&OBI(37) SETA  31\n&OBI(38) SETA  32\n&OBI(39) SETA  10\n&OBI(40) SETA  11\n&OBI(41) SETA  13\n&OBI(42) SETA  15\n&OBI(43) SETA  25\n&OBI(44) SETA  25                       --+\n.*\n.**********************************************************************\n.*                                                                    *\n.* PARSE THE FUNCTION PARAMETER                                       *\n.*                                                                    *\n.**********************************************************************\n.FUNC1   ANOP  ,                        START OF FUNCTION PARSE\n         AIF   ('&FUNC' EQ 'LOCATE').FLOC     GO SET LOCATE BITS\n         AIF   ('&FUNC' EQ 'LSPACE').FLSP     GO SET LSPACE BITS\n         AIF   ('&FUNC' EQ 'UPDATE').FUPD     GO SET UPDATE BITS\n         AIF   ('&FUNC' EQ 'DEFINE').FDEF     GO SET DEFINE BITS\n         AIF   ('&FUNC' EQ 'ALTER').FALT      GO SET ALTER BITS\n         AIF   ('&FUNC' EQ 'DELETE').FDEL     GO SET DELETE BITS\n         AIF   ('&FUNC' EQ 'LISTCAT').FLCT    GO SET LISTCAT BITS\n         AIF   ('&FUNC' EQ 'CONVERT').FCON    GO SET CONVERTV BITS\n         AIF   ('&FUNC' EQ 'GFL').FGFL        GO SET GFL BITS\n         AIF   ('&FUNC' EQ 'CNL').FCNL        GO SET CNL BITS\n         AGO   .ERR1                    INVALID FUNCTION\n.FLOC    ANOP  ,\n&O(17)   SETB  0                              SET OPTION BITS\n&O(18)   SETB  0                              ON FOR THE\n&O(19)   SETB  1                              LOCATE FUNCTION\n         AGO   .FEND\n.FLSP    ANOP  ,\n&O(17)   SETB  0                              SET OPTION BITS\n&O(18)   SETB  1                              ON FOR THE\n&O(19)   SETB  0                              LSPACE FUNCTION\n         AGO   .FEND\n.FUPD    ANOP  ,\n&O(17)   SETB  0                              SET OPTION BITS\n&O(18)   SETB  1                              ON FOR THE\n&O(19)   SETB  1                              UPDATE FUNCTION\n         AGO   .FEND\n.FGFL    ANOP  ,\n&O(17)   SETB  1                              SET OPTION BITS\n&O(18)   SETB  0                              ON FOR THE\n&O(19)   SETB  1                              GFL FUNCTION\n         AGO   .FEND\n.FCNL    ANOP  ,\n&O(17)   SETB  1                              SET OPTION BITS\n&O(18)   SETB  1                              ON FOR THE\n&O(19)   SETB  0                              CNL FUNCTION\n         AGO   .MUT1\n.FDEF    ANOP  ,\n&OPTN    SETC  '00001000'               SET CMS OPTIONS FOR DEFINE\n         AGO   .FCMS\n.FALT    ANOP  ,\n&OPTN    SETC  '00010000'               SET CMS OPTIONS FOR ALTER   #DD\n         AGO   .FCMS\n.FDEL    ANOP  ,\n&OPTN    SETC  '00011000'               SET CMS OPTIONS FOR DELETE\n         AGO   .FCMS\n.FLCT    ANOP  ,\n.* TN    SETC  '00100000'               SET CMS OPTIONS FOR LISTCAT\n&OPTN    SETC  '00100001'               SET CMS OPTIONS FOR LISTCAT\n         AGO   .FCMS\n.FCON    ANOP  ,\n&OPTN    SETC  '00110000'               SET CMS OPTIONS FOR CONVERTV\n         AGO   .FCMS\n.FCMS    ANOP  ,\n&O(17)   SETB  1                         SET OPTION BITS\n&O(18)   SETB  0                         FOR CMS TYPE\n&O(19)   SETB  0                         REQUEST\n&CMS     SETB  1                         SET CMS FLAG\n.FEND    ANOP  ,\n.**********************************************************************\n.*                                                                    *\n.* CHECK FOR WORKAREA PARAMETER                                       *\n.*                                                                    *\n.**********************************************************************\n.WORK1   ANOP  ,\n         AIF   ('&WORK' EQ '').ERR2      NO WORKAREA SPECD ERROR\n&WRKAREA SETC  '&WORK(1)'               SETUP WORKAREA POINTER\n&WRKLEN  SETC  '&WORK(2)'               SETUP WORKAREA LENGTH\n&WRKFMT2 SETC  '&WORK(3)'               SET FORMAT 2 WORKAREA FLAG\n&FMT2    SETB  0                        RESET FORMAT-2 WORKAREA FLAG\n         AIF   ('&WRKFMT2' EQ '').MUT1   CHECK FOR FORMAT-2 WORKAREA\n         AIF   ('&WRKFMT2' NE 'FORMAT2').ERR3\n&FMT2    SETB  1                        SET FORMAT-2 WORKAREA FLAG\n&CMS     SETB  1                         SET CMS FLAG\n.**********************************************************************\n.*                                                                    *\n.* CHECK FOR THE VARIOUS MUTUALLY EXCLUSIVE PARAMETERS                *\n.*                                                                    *\n.**********************************************************************\n.MUT1    ANOP  ,\n         AIF   (('&CRI' NE '') AND ('&FV' NE '') AND                   *\n               ('&NT' NE '')).ERR4\n         AIF   (('&CATALOG' NE '') AND ('&CVOL' NE '')).ERR4\n         AIF   (('&NEWNAME' NE '') AND ('&DDNAME' NE '')).ERR4\n         AIF   (('&JSCB' NE '') AND ('&PASSWRD' NE '')).ERR4\n.**********************************************************************\n.*                                                                    *\n.* CHECK THE OPTIONS PARAMETER LIST                                   *\n.*                                                                    *\n.**********************************************************************\n.OPT1    ANOP  ,                        START OF OPTION PARSE\n&O(24)   SETB  1                        CTGAM0 ALWAYS ON FOR CTGPL\n&I       SETA  0                        INIT I TO LOOP THRU OPTIONS\n.OSCAN   ANOP  ,\n         AIF   (&I GE N'&OPTIONS).OEND   FINISHED ALL OPTIONS\n&I       SETA  &I+1                     INCREMENT I\n&J       SETA  0                        INIT J TO LOOP THRU OPTS LIST\n.OSRCH   ANOP  ,\n         AIF   (&J GT 44).ONFND          OPT SPECD NOT FOUND IN LIST\n&J       SETA  &J+1                     INCREMENT J\n         AIF   ('&OMN(&J)' NE '&OPTIONS(&I)').OSRCH   KEEP SEARCHING\n&K       SETA  &OBI(&J)                 SET K TO BIT POSITION OF OPT\n&O(&K)   SETB   1                        SET OPTION BYTE AT K\n         AIF   ('&OMN(&J)' NE 'SUPLT').OSCAN   CHECK FOR SUPERLOCATE\n&O(17)   SETB  0                              RESET CMS FLAG\n         AIF   ('&WRKFMT2' NE '').OSCAN       CHECK FOR FMT2 WRKAREA\n&CMS     SETB  0                              RESET CMS FLAG\n         AGO   .OSCAN                   GO GET NEXT SPECD OPTION\n.ONFND   ANOP  ,\n         MNOTE 4,'INVALID OPTION, &OPTIONS(&I)' WARN USER ABOUT OPT\n         AGO   .OSCAN                   GO GET NEXT SPECD OPTION\n.OEND    ANOP  ,\n.**********************************************************************\n.*                                                                    *\n.* PARSE THE MF PARAMETER                                             *\n.*                                                                    *\n.**********************************************************************\n.MF1     ANOP  ,\n         AIF   (N'&MF NE 1).MF2          CHECK FOR ONLY 1 PARM\n         AIF   ('&MF' NE 'L').ERR5       IF SO IT MUST BE LIST FORM\n         AGO   .LFORM1\n.MF2     ANOP  ,\n         AIF   (N'&MF NE 2).ERR5         CHECK FOR TWO PARMS\n         AIF   ('&MF(1)' NE 'E').ERR5    IF SO MUST BE EXECUTE FORM\n         AGO   .EFORM1\n.**********************************************************************\n.*                                                                    *\n.*             GENERATE THE LIST FORM OF THE MACRO                    *\n.*                                                                    *\n.**********************************************************************\n.LFORM1  ANOP  START                    OF LIST FORM OF MACRO\n.**********************************************************************\n.*                                                                    *\n.* PARSE THE FIELDS PARAMETER                                         *\n.*                                                                    *\n.**********************************************************************\n.FLD1    ANOP  ,\n&NAME    DS    0F                       #CTGPL MACRO AUG 12 1982\n&BYTE    SETC  '&O(1)&O(2)&O(3)&O(4)&O(5)&O(6)&O(7)&O(8)'\n         DC    B'&BYTE'                 FIRST  OPTION BYTE\n&BYTE    SETC  '&O(9)&O(10)&O(11)&O(12)&O(13)&O(14)&O(15)&O(16)'\n         DC    B'&BYTE'                 SECOND OPTION BYTE\n&BYTE    SETC  '&O(17)&O(18)&O(19)&O(20)&O(21)&O(22)&O(23)&O(24)'\n         DC    B'&BYTE'                 THIRD  OPTION BYTE\n&BYTE    SETC  '&O(25)&O(26)&O(27)&O(28)&O(29)&O(30)&O(31)&O(32)'\n         DC    B'&BYTE'                 FOURTH OPTION BYTE\n         AIF   ('&CRI' EQ '').LFORM2     NO CRI SPECIFIED\n         DC    A(&CRI)                  CTLG REC IDENTIFIER\n         AGO   .LFORM4\n.LFORM2  ANOP  ,\n         AIF   ('&FV' EQ '').LFORM3      NO FV SUPPLIED\n         DC    A(&FV)                   ADDR OF CTGFV\n         AGO   .LFORM4\n.LFORM3  ANOP  ,\n         AIF   ('&NT' EQ '').LFORM3B     NO NT SUPPLIED\n         DC    A(&NT)                   ADDR OF CTGNT\n         AGO   .LFORM4\n.LFORM3B ANOP  ,\n         DS    A                        RESERVED\n.LFORM4  ANOP  ,\n         AIF   ('&CATALOG' EQ '').LFORM5      NO CATALOG SPECIFIED\n         DC    A(&CATALOG)              ADDR OF CTLG NAME / ACB\n         AGO   .LFORM7\n.LFORM5  ANOP  ,\n         AIF   ('&CVOL' EQ '').LFORM6    NO CVOL SPECIFIED\n         DC    A(&CVOL)                 ADDR OF CVOL NAME\n         AGO   .LFORM7\n.LFORM6  ANOP  ,\n         DS    A                        RESERVED\n.LFORM7  ANOP  ,\n         AIF   ('&WRKAREA' EQ '').LFORM7B\n         DC    A(&WRKAREA)              ADDR OF WORKAREA\n         AGO   .LFORM7C\n.LFORM7B ANOP  ,\n         DC    A(0)                     ADDR OF WORKAREA\n.LFORM7C ANOP  ,\n         DC    A(&WRKAREA)              ADDR OF WORKAREA\n         AIF   (NOT &CMS).LFORM8         CMS => OPTION HERE\n         DC    B'&OPTN'                 CMS OPTION BYTE\n         DS    X                        RESERVED\n         AGO   .LFORM10\n.LFORM8  ANOP  ,\n         AIF   ('&DSORG' EQ '').LFORM9   SUPERLOCATE DSORG ?\n         DC    CL2'&DSORG'              DSORG FOR SUPERLOCATE\n         AGO   .LFORM10\n.LFORM9  ANOP  ,\n         DS    CL2                      RESERVED\n.LFORM10 ANOP  ,\n         AIF   ('&TYPE' EQ '').LFORM11   NO RECORD TYPE SPECIFIED\n         DC    CL1'&TYPE'               CATALOG RECORD TYPE\n         AGO   .LFORM12\n.LFORM11 ANOP  ,\n         DS    CL1                      RESERVED\n.LFORM12 ANOP  ,\n&I       SETA  N'&FIELDS                GET NUMBER OF FIELDS\n         DC    AL1(&I)                  NO OF CTGFL ENTRIES\n         AIF   ('&DDNAME' EQ '').LFORM13   NO DDNAME ADDR SPECIFIED\n         DC    A(&DDNAME)               ADDRESS OF DD NAME\n         AGO   .LFORM15\n.LFORM13 ANOP  ,\n         AIF   ('&NEWNAME' EQ '').LFORM14     NO NEWNAME ADDR SPECIFIED\n         DC    A(&NEWNAME)              ADDR OF NEW NAME FOR OBJ\n         AGO   .LFORM15\n.LFORM14 ANOP  ,\n         DS    A                        RESERVED\n.LFORM15 ANOP  ,\n         AIF   ('&JSCB' EQ '').LFORM16   NO JSCB ADDR SPECIFIED\n         DC    A(&JSCB)                 ADDR OF JSCB\n         AGO   .LFORM18\n.LFORM16 ANOP  ,\n         AIF   ('&PASSWRD' EQ '').LFORM17   NO PASSWORD ADDR GIVEN\n         DC    A(&PASSWRD)              ADDR OF PASSWORD\n         AGO   .LFORM18\n.LFORM17 ANOP  ,\n         DS    A                        RESERVED\n.LFORM18 ANOP  ,\n&I       SETA  1                        INIT FOR LOOP THRU CTGFLS\n.LFORM19 ANOP  ,\n         AIF   (N'&FIELDS EQ 0).LFORM20    LEAVE AFTER ALL CTGFLS DONE\n         AIF   (&I GT N'&FIELDS).LFORM20   LEAVE AFTER ALL CTGFLS DONE\n         DC    A(&FIELDS(&I))           ADDR OF CTGFL\n&I       SETA  &I+1                     INCREMENT I\n         AGO   .LFORM19\n.LFORM20 ANOP  ,\n         MEXIT ,\n.**********************************************************************\n.*                                                                    *\n.* DEFINE THE EXECUTE FORM OF THE MACRO                               *\n.*                                                                    *\n.**********************************************************************\n.EFORM1  ANOP  ,\n         PUSH  USING                    #CTGPL MACRO AUG 12 1982\n         USING CTGPL,15                 ADDRESS THE CTGPL\n         AIF   ('&MF(2)'(1,1) EQ '(').EREGS   TEST IF REG SPECD\n&NAME    LA    15,&MF(2)                REG 15 -> CTGPL\n         AGO   .EBLD                    GO BUILD PARM LIST\n.EREGS   ANOP  ,\n&REG     SETC  '&MF(2)'(2,K'&MF(2)-2)   STRIP THE PARENTHESIS\n&NAME    LR    15,&REG                  REG 15 -> CTGPL\n.EBLD    ANOP  ,\n&BYTE    SETC  '&O(1)&O(2)&O(3)&O(4)&O(5)&O(6)&O(7)&O(8)'\n         MVI   CTGOPTN1,B'&BYTE'        FIRST  OPTION BYTE\n&BYTE    SETC  '&O(9)&O(10)&O(11)&O(12)&O(13)&O(14)&O(15)&O(16)'\n         MVI   CTGOPTN2,B'&BYTE'        SECOND OPTION BYTE\n&BYTE    SETC  '&O(17)&O(18)&O(19)&O(20)&O(21)&O(22)&O(23)&O(24)'\n         MVI   CTGOPTN3,B'&BYTE'        THIRD  OPTION BYTE\n&BYTE    SETC  '&O(25)&O(26)&O(27)&O(28)&O(29)&O(30)&O(31)&O(32)'\n         MVI   CTGOPTN4,B'&BYTE'        FOURTH OPTION BYTE\n         AIF   ('&CRI' EQ '').EFORM2     NO CRI SPECIFIED\n         AIF   ('&CRI'(1,1) EQ '(').ECRIR   CHECK FOR REGS SPECD\n         LA    0,&CRI                   SAVE CTLG REC IDENTIFIER\n         ST    0,CTGENT\n         AGO   .EFORM2\n.ECRIR   ANOP  ,\n&REG     SETC  '&CRI'(2,K'&CRI-2)       STRIP PARENS\n         ST    &REG,CTGENT              SAVE CTLG REC IDENTIFIER\n.EFORM2  ANOP  ,\n         AIF   ('&FV' EQ '').EFORM3      NO FV SUPPLIED\n         AIF   ('&FV'(1,1) EQ '(').EFVR       CHECK FOR REGS SPECD\n         LA    0,&FV                    SAVE CTGFV POINTER\n         ST    0,CTGFVT\n         AGO   .EFORM3\n.EFVR    ANOP  ,\n&REG     SETC  '&FV'(2,K'&FV-2)         STRIP PARENS\n         ST    &REG,CTGFVT              SAVE CTGFV POINTER\n.EFORM3  ANOP  ,\n         AIF   ('&NT' EQ '').EFORM3B     NO NT SUPPLIED\n         AIF   ('&NT'(1,1) EQ '(').EFNT       CHECK FOR REGS SPECD\n         LA    0,&NT                    SAVE CTGNT POINTER\n         ST    0,CTGDNT\n         AGO   .EFORM3B\n.EFNT    ANOP  ,\n&REG     SETC  '&NT'(2,K'&NT-2)         STRIP PARENS\n         ST    &REG,CTGDNT              SAVE CTGNT POINTER\n.EFORM3B ANOP  ,\n         AIF   ('&CATALOG' EQ '').EFORM5      NO CATALOG SPECIFIED\n         AIF   ('&CATALOG'(1,1) EQ '(').ECATR   CHECK FOR REGS SPECD\n         LA    0,&CATALOG               SAVE CTLG NAME POINTER\n         ST    0,CTGCAT\n         AGO   .EFORM6\n.ECATR   ANOP  ,\n&REG     SETC  '&CATALOG'(2,K'&CATALOG-2) STRIP PARENS\n         ST    &REG,CTGCAT              SAVE CTLG NAME / ACB\n         AGO   .EFORM6\n.EFORM5  ANOP  ,\n         AIF   ('&CVOL' EQ '').EFORM6    NO CVOL SPECIFIED\n         AIF   ('&CVOL'(1,1) EQ '(').ECVLR    CHECK FOR REGS SPECD\n         LA    0,&CVOL                  SAVE CTLG CVOL POINTER\n         ST    0,CTGCVOL\n         AGO   .EFORM6\n.ECVLR   ANOP  ,\n&REG     SETC  '&CVOL'(2,K'&CVOL-2)     STRIP PARENS\n         ST    &REG,CTGCVOL             SAVE CTLG CVOL POINTER\n.EFORM6  ANOP  ,\n         AIF   ('&WRKAREA' EQ '').EFORM8\n         AIF   ('&WRKAREA'(1,1) EQ '(').EWRKR   CHECK FOR REGS SPECD\n         LA    0,&WRKAREA               SAVE WORK AREA POINTER\n         ST    0,CTGWKA\n         AIF   ('&WRKLEN' EQ '').EFORM7   CHECK IF LENGTH SPECIFIED\n         AIF   ('&WRKFMT2' NE '').EFORM6B\n         XC    &WRKAREA+2(2),&WRKAREA+2 CLEAR RETURNED LENGTH\n         AGO   .EFORM7\n.EFORM6B ANOP  ,\n         XC    &WRKAREA+4(4),&WRKAREA+4 CLEAR RETURNED LENGTH\n         MVI   &WRKAREA+7,8             INDICATE HEADER LENGTH\n         AGO   .EFORM7\n.EWRKR   ANOP  ,\n&REG     SETC  '&WRKAREA'(2,K'&WRKAREA-2) STRIP PARENS\n         ST    &REG,CTGWKA              SAVE CTLG REC IDENTIFIER\n         AIF   ('&WRKLEN' EQ '').EFORM7   CHECK IF LENGTH SPECIFIED\n         AIF   ('&WRKFMT2' NE '').EFORM6C\n         XC    2(2,&REG),2(&REG)        CLEAR RETURNED LENGTH\n         AGO   .EFORM7\n.EFORM6C ANOP  ,\n         XC    4(4,&REG),4(&REG)        CLEAR RETURNED LENGTH\n         MVI   7(&REG),8                INDICATE HEADER LENGTH\n.EFORM7  ANOP  ,\n         AIF   ('&WRKLEN' EQ '').EFORM8   CHECK IF LENGTH SPECIFIED\n         AIF   ('&WRKLEN'(1,1) EQ '(').EWRKLR\n&REG     SETC  '0'\n         LA    &REG,&WRKLEN             LOAD WORK AREA LENGTH\n         AGO   .ESTLEN\n.EWRKLR  ANOP  ,\n&REG     SETC  '&WRKLEN'(2,K'&WRKLEN-2) STRIP PARENS\n.ESTLEN  ANOP  ,\n         AIF   ('&WRKAREA'(1,1) NE '(').ESTWLEN   CHECK FOR REGS SPECD\n&WRKAREA SETC  '0&WRKAREA'\n.ESTWLEN ANOP  ,\n         AIF   ('&WRKFMT2' NE '').ESTWLE2\n         STH   &REG,&WRKAREA            SAVE LENGTH OF WRK AREA\n         AGO   .EFORM8\n.ESTWLE2 ANOP  ,\n         ST    &REG,&WRKAREA            SAVE LENGTH OF WRK AREA\n.EFORM8  ANOP  ,\n         AIF   (NOT &CMS).EFORM9         CMS => OPTION HERE\n         MVI   CTGDSORG,B'&OPTN'        CMS OPTION BYTE\n         AIF   (NOT &FMT2).EFORM10\n         OI    CTGDSORG,CTGF2WKA        FORMAT-2 WORK AREA\n         AGO   .EFORM10\n.EFORM9  ANOP  ,\n         AIF   ('&DSORG' EQ '').EFORM10       SUPERLOCATE DSORG ?\n         MVC   CTGDSORG,=CL2'&DSORG'    DSORG FOR SUPERLOCATE\n.EFORM10 ANOP  ,\n         AIF   ('&TYPE' EQ '').EFORM11  NO RECORD TYPE SPECIFIED\n         AIF   ('&TYPE'(1,1) EQ '(').EFRM10B\n         MVI   CTGTYPE,C'&TYPE'         CATALOG RECORD TYPE\n         AGO   .EFORM11\n.EFRM10B ANOP  ,\n&REG     SETC  '&TYPE'(2,K'&TYPE-2)     STRIP PARENS\n         MVC   CTGTYPE,0(&REG)          CATALOG RECORD TYPE\n.EFORM11 ANOP  ,\n&I       SETA  N'&FIELDS                GET NUMBER OF FIELDS\n         AIF   (&I EQ 0).EFORM12        SKIP IF NO FIELDS\n         MVI   CTGNOFLD,&I              NUMBER OF FIELDS\n.EFORM12 ANOP  ,\n         AIF   ('&DDNAME' EQ '').EFORM13      NO DDNAME ADDR SPECIFIED\n         AIF   ('&DDNAME'(1,1) EQ '(').EDDNR   CHECK FOR REGS SPECD\n         LA    0,&DDNAME                SAVE ADDR OF JCL\n         ST    0,CTGDDNM                DD CARD ASSOC WITH REQ\n         AGO   .EFORM14\n.EDDNR   ANOP  ,\n&REG     SETC  '&DDNAME'(2,K'&DDNAME-2) STRIP PARENS\n         ST    &REG,CTGDDNM             SAVE ADDR OF DD CARD\n         AGO   .EFORM14\n.EFORM13 ANOP  ,\n         AIF   ('&NEWNAME' EQ '').EFORM14     NO NEWNAME ADDR SPECIFIED\n         AIF   ('&NEWNAME'(1,1) EQ '(').ENNMR   CHECK FOR REGS SPECD\n         LA    0,&NEWNAME               SAVE ADDR OF\n         ST    0,CTGNEWNM               OBJECTS NEW NAME\n         AGO   .EFORM14\n.ENNMR   ANOP  ,\n&REG     SETC  '&NEWNAME'(2,K'&NEWNAME-2) STRIP PARENS\n         ST    &REG,CTGNEWNM            SAVE ADDR OF NEW NAME\n.EFORM14 ANOP  ,\n         AIF   ('&JSCB' EQ '').EFORM15   NO JSCB ADDR SPECIFIED\n         AIF   ('&JSCB'(1,1) EQ '(').EJSBR    CHECK FOR REGS SPECD\n         LA    0,&JSCB                  SAVE ADDR OF\n         ST    0,CTGJSCB                JSCB\n         AGO   .EFORM16\n.EJSBR   ANOP  ,\n&REG     SETC  '&JSCB'(2,K'&JSCB-2)     STRIP PARENS\n         ST    &REG,CTGJSCB             SAVE ADDR OF JSCB\n         AGO   .EFORM16\n.EFORM15 ANOP  ,\n         AIF   ('&PASSWRD' EQ '').EFORM16     NO PASSWORD ADDR GIVEN\n         AIF   ('&PASSWRD'(1,1) EQ '(').EPSWR   CHECK FOR REGS SPECD\n         LA    0,&PASSWRD               SAVE ADDR OF CALLER\n         ST    0,CTGPSWD                SUPPLIED PASSWORD\n         AGO   .EFORM2\n.EPSWR   ANOP  ,\n&REG     SETC  '&PASSWRD'(2,K'&PASSWRD-2) STRIP PARENS\n         ST    &PASSWRD,CTGPSWD         SAVE PTR TO PASSWORD\n.EFORM16 ANOP  ,\n&I       SETA  1                        INIT FOR LOOP THRU CTGFLS\n.EFORM17 ANOP  ,\n         AIF   (&I GT N'&FIELDS).EFORM19      LEAVE AFTER ALL DONE\n&J       SETA  (&I-1)*4                 SET J TO OFFSET IN CTGPL\n         AIF   ('&FIELDS(&I)'(1,1) EQ '(').EFLDR   CHECK FOR REG SPEC\n         LA    0,&FIELDS(&I)            SAVE CTGFL POINTER\n         ST    0,CTGFIELD+&J\n         AGO   .EFORM18\n.EFLDR   ANOP  ,\n&REG     SETC  '&FIELDS(&I)'(2,K'&FIELDS(&I)-2) STRIP PARENS\n         ST    &REG,CTGFIELD+&J         SAVE CTGFL POINTER\n         AGO   .EFORM18\n.EFORM18 ANOP  ,\n&I       SETA  &I+1                     INCREMENT I\n         AGO   .EFORM17                 SCAN THRU ALL FIELD ADDR'S\n.EFORM19 ANOP  ,\n         POP   USING\n         MEXIT ,\n.**********************************************************************\n.*                                                                    *\n.* ERROR MESSAGES ISSUED BY THIS MACRO                                *\n.*                                                                    *\n.**********************************************************************\n.ERR1    ANOP  ,\n         MNOTE 8,'INVALID FUNCTION SPECIFIED'\n         MEXIT ,\n.ERR2    ANOP  ,\n         MNOTE 8,'NO WORKAREA SPECIFIED'\n         MEXIT ,\n.ERR3    ANOP  ,\n         MNOTE 8,'INVALID 3RD PARAMETER IN WORKAREA FIELD'\n         MEXIT ,\n.ERR4    ANOP  ,\n         MNOTE 8,'MUTUALLY EXCLUSIVE PARAMETERS SPECIFIED'\n         MEXIT ,\n.ERR5    ANOP  ,\n         MNOTE 8,'INVALID MACRO FORMAT SPECIFIED'\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DATE": {"ttr": 259, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x01\\xaa\\x01\\xaa\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 426, "newlines": 426, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,                   |\n&LABEL   #DATE &TO,&FROM=,&FORMAT='YYDDD',&LIST=YES\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*       TO     (REQUIRED) - OUTPUT BUFFER (WORKDATE OR (R2-R15))     *\n.*                                                                    *\n.*       FROM=             - SUPPLIED DATE (FULLWORD OR (R0-R15))     *\n.*                                                                    *\n.*       FORMAT= DAYOFWEEK - DAY OF WEEK (SUNDAY-SATURDAY)            *\n.*               CCYY      - CENTURY & YEAR (1988)                    *\n.*               DDD       - JULIAN DATE (000-365)                    *\n.*               MMM       - MONTH OF YEAR (JAN-DEC)                  *\n.*               DD        - DAY OF MONTH (01-31)                     *\n.*               MM        - MONTH OF YEAR (01-12)                    *\n.*               YY        - YEAR (88)                                *\n.*               #D        - NUMBER OF DAYS IN YEAR                   *\n.*               WD        - DAY OF THE WEEK (MON=1...SUN=7)          *\n.*                                                                    *\n.*       LIST=   YES|NO    - PRINT GENERATION OPTION                  *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*       NOTE: THIS MACRO DOES NOT PERFORM ALL THE TESTS NECESSARY    *\n.*             TO CHECK FOR A LEAP YEAR.  THIS SHOULDN'T BE A PROBLEM *\n.*             UNLESS THE YEAR BEING TESTED IS 1900 OR 2100.          *\n.*             BY THEN IT WILL HAVE BEEN FIXED.                       *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n         GBLB  &STF(10)            |\n         GBLC  &STPREF             |\n         LCLA  &A,&B,&C,&D,&N      |\n         LCLB  &F,&G,&H            |\n         LCLC  &K,&P,&Q,&X,&REG    |\n&N       SETA  0                   | INITALIZE LABEL COUNTER\n&STF(8)  SETB  1                   | INDICATE #STARTWA FIELDS WANTED\n&X       SETC  'DT&SYSNDX'         | GENERATE LABEL PREFIX\n&P       SETC  '&STPREF.DBL1'      | DOUBLE WORD WORKAREA #1\n&Q       SETC  '&STPREF.DBL2'      | DOUBLE WORD WORKAREA #2\n         AIF   ('&LIST' EQ 'YES').DAT0100\n         AIF   ('&LIST' NE 'NO').DATERR1\n         PUSH  PRINT\n         PRINT NOGEN\n.DAT0100 ANOP  ,                   |\n         AIF   ('&LABEL' EQ '').DAT0200\n&LABEL   DS    0H                  #DATE MACRO - START\n.DAT0200 ANOP  ,                   |\n*-------\n*        #DATE INITIALIZATION\n*-------\n         AIF   ('&TO' EQ '').DATERR2\n         AIF   ('&FROM' EQ '').DAT0500\n         AIF   ('&FROM'(1,1) EQ '(').DAT0300\n         ICM   R0,15,&FROM         R0 HAS DATE - 0CYYDDDF\n         AGO   .DAT0400            |\n.DAT0300 ANOP  ,                   |\n&REG     SETC  '&FROM'(2,K'&FROM-2)\n         AIF   ('&REG' EQ 'R0' OR '&REG' EQ '0').DAT0400\n         LR    R0,&REG             R0 HAS DATE - 0CYYDDDF\n.DAT0400 ANOP  ,                   |\n         C     R0,&X.P             CHECK IF VALID DATE WAS SUPPLIED\n         BE    &X.A                B. IF NOT\n         LTR   R0,R0               CHECK IF VALID DATE WAS SUPPLIED\n         BNZ   &X.B                B. IF YES\n&X.A     DS    0H\n.DAT0500 ANOP  ,                   |\n         L     R1,16               LOAD CVT ADDRESS\n         L     R0,56(,R1)          R0 HAS DATE - 0CYYDDDF (CVTDATE)\n&X.B     DS    0H\n         AIF   ('&TO'(1,1) EQ '(').DAT0600\n         LA    R1,&TO              R1 HAS DESTINATION FIELD ADDRESS\n         AGO   .DAT0700            |\n.DAT0600 ANOP  ,                   |\n&REG     SETC  '&TO'(2,K'&TO-2)\n         LR    R1,&REG             R1 HAS DESTINATION FIELD ADDRESS\n.DAT0700 ANOP  ,                   |\n&A       SETA  K'&FORMAT-2         | LENGTH OF FORMAT FIELD\n&B       SETA  0                   | INDEX INTO FORMAT\n&K       SETC  '&FORMAT'(2,K'&FORMAT-2)\n         MVC   0(&A,R1),&X.Q\n.DAT0800 ANOP  ,                   |\n&C       SETA  &A-&B               | CALCULATE # OF REMAINING BYTES\n         AIF   (&C LT 9).DAT0900   | IF 8 TO GO, CONTINUE\n         AIF   ('&K'(&A-&C+1,9) EQ 'DAYOFWEEK').DAT1200\n.DAT0900 ANOP  ,                   |\n         AIF   (&C LT 4).DAT1000   | IF 3 TO GO, CONTINUE\n         AIF   ('&K'(&A-&C+1,4) EQ 'CCYY').DAT1400\n.DAT1000 ANOP  ,                   |\n         AIF   (&C LT 3).DAT1100   | IF 2 TO GO, CONTINUE\n         AIF   ('&K'(&A-&C+1,3) EQ 'DDD').DAT1600\n         AIF   ('&K'(&A-&C+1,3) EQ 'MMM').DAT1800\n.DAT1100 ANOP  ,                   |\n         AIF   (&C LT 2).DAT3000   | IF 1 TO GO, EXIT\n         AIF   ('&K'(&A-&C+1,2) EQ 'DD').DAT2000\n         AIF   ('&K'(&A-&C+1,2) EQ 'MM').DAT2200\n         AIF   ('&K'(&A-&C+1,2) EQ 'YY').DAT2400\n         AIF   ('&K'(&A-&C+1,2) EQ '#D').DAT2600\n         AIF   ('&K'(&A-&C+1,2) EQ 'WD').DAT2800\n&B       SETA  &B+1                | POINT TO NEXT CHARACTER\n&D       SETA  &D+1                | POINT TO NEXT CHARACTER\n         AGO   .DAT0800            |\n.*                                 |\n.DAT1200 ANOP  ,                   |\n&N       SETA  &N+1                BUMP LABEL COUNTER\n*-------\n*        CONVERT \"DAYOFWEEK\" INTO DAY OF THE WEEK\n*-------\n         XC    &P,&P               CLEAR WORK AREA #1\n         XC    &Q,&Q               CLEAR WORK AREA #2\n         AIF   (&D EQ 0).DAT1300   |\n         LA    R1,&D.(,R1)         ADVANCE OUTPUT AREA POINTER\n&D       SETA  0                   | RESET INDEX INTO AREA\n.DAT1300 ANOP  ,                   |\n         STCM  R0,12,&P+6          SAVE \"CCYY\"\n         MVO   &Q+6(2),&P+6(2)\n         OI    &Q+7,X'0F'          CONVERT TO \"CYYF'\n         CVB   R15,&Q\n         SLR   R14,R14\n         D     R14,&X.R            DIVIDE YEAR BY LOOP FACTOR\n         LA    R15,&X.T            LOAD \"1ST DAY OF YEAR\" TABLE ADDRESS\n         IC    R14,0(R14,R15)      LOAD DAY INDEX\n         STH   R0,&P+6             SAVE DDDF\n         OI    &P+7,X'0F'          ENSURE SIGN IS VALID\n         CVB   R15,&P              CONVERT DATE TO JULIAN\n         AR    R15,R14             ADD INDEX TO CURRENT DATE\n         SLR   R14,R14\n         D     R14,&X.S            DIVIDE BY NUMBER OF DAYS IN A WEEK\n         LA    R15,&X.U            LOAD \"DAY OF WEEK\" TABLE ADDRESS\n&X.C&N   DS    0H\n         CH    R14,0(,R15)         CHECK FOR DAY KEY\n         BE    &X.D&N              B. IF FOUND\n         LA    R15,14(,R15)        ADVANCE TO NEXT TABLE ENTRY\n         B     &X.C&N\n&X.D&N   DS    0H\n         MVC   0(9,R1),2(R15)      INSERT - DAYOFWEEK\n&B       SETA  &B+9                | POINT TO NEXT CHARACTER\n&D       SETA  &D+9                | POINT TO NEXT CHARACTER\n&G       SETB  1                   | INDICATE TABLE GENERATION REQUIRED\n         AGO   .DAT0800            |\n.*                                 |\n.DAT1400 ANOP  ,                   |\n*-------\n*        CONVERT \"CCYY\" INTO CURRENT CENTURY & YEAR\n*-------\n         XC    &P,&P               CLEAR WORK AREA #1\n         AIF   (&D EQ 0).DAT1500   |\n         LA    R1,&D.(,R1)         ADVANCE OUTPUT AREA POINTER\n&D       SETA  0                   | RESET INDEX INTO AREA\n.DAT1500 ANOP  ,                   |\n         STCM  R0,8,&P+3           SAVE # OF CENTURIES PAST 20TH\n         LA    R15,19              LOAD STARTING POINT\n         A     R15,&P              ADD # OF CENTURIES PAST 20TH\n         CVD   R15,&P              CONVERT NUMBER TO DECIMAL\n         UNPK  0(2,R1),&P+6(2)\n         OI    1(R1),X'F0'\n         LR    R15,R0              LOAD YEAR IN 0CYYDDDF FORMAT\n         STCM  R15,4,3(R1)         SAVE \"YY\"\n         SRL   R15,4               CONVERT TO   00CYYDDD FORMAT\n         STCM  R15,4,2(R1)         SAVE \"CY'\n         OI    2(R1),X'F0'         CONVERT X'0889' TO X'F8F9' (IE. 89)\n         OI    3(R1),X'F0'\n&B       SETA  &B+4                | POINT TO NEXT CHARACTER\n&D       SETA  &D+4                | POINT TO NEXT CHARACTER\n         AGO   .DAT0800            |\n.*                                 |\n.DAT1600 ANOP  ,                   |\n*-------\n*        CONVERT \"DDD\" INTO JULIAN DATE\n*-------\n         XC    &P,&P               CLEAR WORK AREA #1\n         AIF   (&D EQ 0).DAT1700   |\n         LA    R1,&D.(,R1)         ADVANCE OUTPUT AREA POINTER\n&D       SETA  0                   | RESET INDEX INTO AREA\n.DAT1700 ANOP  ,                   |\n         STH   R0,&P+6             SAVE DDDF\n         OI    &P+7,X'0F'          ENSURE SIGN IS VALID\n         UNPK  0(3,R1),&P+6(2)\n&B       SETA  &B+3                | POINT TO NEXT CHARACTER\n&D       SETA  &D+3                | POINT TO NEXT CHARACTER\n         AGO   .DAT0800            |\n.*                                 |\n.DAT1800 ANOP  ,                   |\n&N       SETA  &N+1                BUMP LABEL COUNTER\n*-------\n*        CONVERT \"MMM\" INTO MONTH OF YEAR\n*-------\n         XC    &P,&P               CLEAR WORK AREA #1\n         XC    &Q,&Q               CLEAR WORK AREA #2\n         AIF   (&D EQ 0).DAT1900   |\n         LA    R1,&D.(,R1)         ADVANCE OUTPUT AREA POINTER\n&D       SETA  0                   | RESET INDEX INTO AREA\n.DAT1900 ANOP  ,                   |\n         STCM  R0,12,&P+6          SAVE \"CCYY\"\n         MVO   &Q+6(2),&P+6(2)\n         OI    &Q+7,X'0F'          CONVERT TO \"CYYF'\n         CVB   R15,&Q\n         STH   R15,&P+6\n         LA    R14,&X.V            LOAD ADDRESS OF NON-LEAP YEAR TABLE\n         TM    &P+7,3              CHECK IF YEAR DIVISIBLE BY 4\n         BNZ   &X.E&N              B. IF NOT\n         LA    R14,&X.V+2          LOAD ADDRESS OF LEAP     YEAR TABLE\n&X.E&N   DS    0H\n         STH   R0,&P+6             SAVE DDDF\n         CVB   R15,&P\n         CH    R15,0(,R14)         CHECK FOR DESIRED MONTH\n         BH    &X.F&N              B. IF FOUND\n         LA    R14,10(,R14)        LOAD ADDRESS OF NEXT MONTH\n         B     &X.E&N\n&X.F&N   DS    0H\n         CLI   2(R14),C'X'         CHECK FOR LEAP YEAR\n         BE    &X.G&N              B. IF YES\n         LA    R14,2(,R14)         LOAD ADDRESS OF CURRENT MONTH\n&X.G&N   DS    0H\n         MVC   0(3,R1),3(R14)      INSERT - MMM\n&B       SETA  &B+3                | POINT TO NEXT CHARACTER\n&D       SETA  &D+3                | POINT TO NEXT CHARACTER\n&F       SETB  1                   | INDICATE TABLE GENERATION REQUIRED\n         AGO   .DAT0800            |\n.*                                 |\n.DAT2000 ANOP  ,                   |\n&N       SETA  &N+1                BUMP LABEL COUNTER\n*-------\n*        CONVERT \"DD\" INTO DAY OF THE MONTH\n*-------\n         XC    &P,&P               CLEAR WORK AREA #1\n         XC    &Q,&Q               CLEAR WORK AREA #2\n         AIF   (&D EQ 0).DAT2100   |\n         LA    R1,&D.(,R1)         ADVANCE OUTPUT AREA POINTER\n&D       SETA  0                   | RESET INDEX INTO AREA\n.DAT2100 ANOP  ,                   |\n         STCM  R0,12,&P+6          SAVE \"CCYY\"\n         MVO   &Q+6(2),&P+6(2)\n         OI    &Q+7,X'0F'          CONVERT TO \"CYYF\"\n         CVB   R15,&Q\n         STH   R15,&P+6\n         LA    R14,&X.V            LOAD ADDRESS OF NON-LEAP YEAR TABLE\n         TM    &P+7,3              CHECK IF YEAR DIVISIBLE BY 4\n         BNZ   &X.H&N              B. IF NOT\n         LA    R14,&X.V+2          LOAD ADDRESS OF LEAP     YEAR TABLE\n&X.H&N   DS    0H\n         STH   R0,&P+6             SAVE DDDF\n         OI    &P+7,X'0F'          ENSURE SIGN IS VALID\n         CVB   R15,&P\n         CH    R15,0(,R14)         CHECK FOR DESIRED MONTH\n         BH    &X.I&N              B. IF FOUND\n         LA    R14,10(,R14)        LOAD ADDRESS OF NEXT MONTH\n         B     &X.H&N\n&X.I&N   DS    0H\n         SH    R15,0(,R14)         CALCULATE DAY OF CURRENT MONTH\n         CVD   R15,&P\n         UNPK  &Q.(3),&P+6(2)\n         MVC   0(2,R1),&Q+1        INSERT - DD\n         OI    1(R1),X'F0'\n&B       SETA  &B+2                | POINT TO NEXT CHARACTER\n&D       SETA  &D+2                | POINT TO NEXT CHARACTER\n&F       SETB  1                   | INDICATE TABLE GENERATION REQUIRED\n         AGO   .DAT0800            |\n.*                                 |\n.DAT2200 ANOP  ,                   |\n&N       SETA  &N+1                BUMP LABEL COUNTER\n*-------\n*        CONVERT \"MM\" INTO MONTH OF THE YEAR\n*-------\n         XC    &P,&P               CLEAR WORK AREA #1\n         XC    &Q,&Q               CLEAR WORK AREA #2\n         AIF   (&D EQ 0).DAT2300   |\n         LA    R1,&D.(,R1)         ADVANCE OUTPUT AREA POINTER\n&D       SETA  0                   | RESET INDEX INTO AREA\n.DAT2300 ANOP  ,                   |\n         STCM  R0,12,&P+6          SAVE \"CCYY\"\n         MVO   &Q+6(2),&P+6(2)\n         OI    &Q+7,X'0F'          CONVERT TO \"CYYF\"\n         CVB   R15,&Q\n         STH   R15,&P+6\n         LA    R14,&X.V            LOAD ADDRESS OF NON-LEAP YEAR TABLE\n         TM    &P+7,3              CHECK IF YEAR DIVISIBLE BY 4\n         BNZ   &X.J&N              B. IF NOT\n         LA    R14,&X.V+2          LOAD ADDRESS OF LEAP     YEAR TABLE\n&X.J&N   DS    0H\n         STH   R0,&P+6             SAVE DDDF\n         CVB   R15,&P\n         CH    R15,0(,R14)         CHECK FOR DESIRED MONTH\n         BH    &X.K&N              B. IF FOUND\n         LA    R14,10(,R14)        LOAD ADDRESS OF NEXT MONTH\n         B     &X.J&N\n&X.K&N   DS    0H\n         CLI   2(R14),C'X'         CHECK FOR LEAP YEAR\n         BE    &X.L&N              B. IF YES\n         LA    R14,2(,R14)         LOAD ADDRESS OF CURRENT MONTH\n&X.L&N   DS    0H\n         MVC   0(2,R1),6(R14)      INSERT - MM\n&B       SETA  &B+2                | POINT TO NEXT CHARACTER\n&D       SETA  &D+2                | POINT TO NEXT CHARACTER\n&F       SETB  1                   | INDICATE TABLE GENERATION REQUIRED\n         AGO   .DAT0800            |\n.*                                 |\n.DAT2400 ANOP  ,                   |\n*-------\n*        CONVERT \"YY\" INTO CURRENT YEAR\n*-------\n         AIF   (&D EQ 0).DAT2500   |\n         LA    R1,&D.(,R1)         ADVANCE OUTPUT AREA POINTER\n&D       SETA  0                   | RESET INDEX INTO AREA\n.DAT2500 ANOP  ,                   |\n         LR    R15,R0              LOAD YEAR IN 0CYYDDDF FORMAT\n         STCM  R15,4,1(R1)         SAVE \"YY\"\n         SRL   R15,4               CONVERT TO   00CYYDDD FORMAT\n         STCM  R15,4,0(R1)         SAVE \"CY'\n         OI    0(R1),X'F0'         CONVERT X'0889' TO X'F8F9' (IE. 89)\n         OI    1(R1),X'F0'\n&B       SETA  &B+2                | POINT TO NEXT CHARACTER\n&D       SETA  &D+2                | POINT TO NEXT CHARACTER\n         AGO   .DAT0800            |\n.*                                 |\n.DAT2600 ANOP  ,                   |\n&N       SETA  &N+1                BUMP LABEL COUNTER\n*-------\n*        CONVERT \"#D\" INTO NUMBER OF DAYS IN THE YEAR\n*-------\n         XC    &P,&P               CLEAR WORK AREA #1\n         XC    &Q,&Q               CLEAR WORK AREA #2\n         AIF   (&D EQ 0).DAT2700   |\n         LA    R1,&D.(,R1)         ADVANCE OUTPUT AREA POINTER\n&D       SETA  0                   | RESET INDEX INTO AREA\n.DAT2700 ANOP  ,                   |\n         STCM  R0,12,&P+6          SAVE \"CCYY\"\n         MVO   &Q+6(2),&P+6(2)\n         OI    &Q+7,X'0F'          CONVERT TO \"CYYF'\n         CVB   R15,&Q\n         STH   R15,&P+6            SAVE \"00YY\"\n         MVC   0(2,R1),=Y(365)     ASSUME NON-LEAP YEAR\n         TM    &P+7,3              CHECK IF YEAR DIVISIBLE BY 4\n         BNZ   &X.M&N              B. IF NOT\n         MVC   0(2,R1),=Y(366)     SET NUMBER TO LEAP YEAR DAYS\n&X.M&N   DS    0H\n&B       SETA  &B+2                | POINT TO NEXT CHARACTER\n&D       SETA  &D+2                | POINT TO NEXT CHARACTER\n         AGO   .DAT0800            |\n.*                                 |\n.DAT2800 ANOP  ,                   |\n&N       SETA  &N+1                BUMP LABEL COUNTER\n*-------\n*        CONVERT \"WD\" INTO CURRENT NUMERICAL DAY OF THE WEEK\n*-------\n         XC    &P,&P               CLEAR WORK AREA #1\n         XC    &Q,&Q               CLEAR WORK AREA #2\n         AIF   (&D EQ 0).DAT2900   |\n         LA    R1,&D.(,R1)         ADVANCE OUTPUT AREA POINTER\n&D       SETA  0                   | RESET INDEX INTO AREA\n.DAT2900 ANOP  ,                   |\n         STCM  R0,12,&P+6          SAVE \"CCYY\"\n         MVO   &Q+6(2),&P+6(2)\n         OI    &Q+7,X'0F'          CONVERT TO \"CYYF'\n         CVB   R15,&Q\n         SLR   R14,R14\n         D     R14,&X.R            DIVIDE YEAR BY LOOP FACTOR\n         LA    R15,&X.T            LOAD \"1ST DAY OF YEAR\" TABLE\n         IC    R14,0(R14,R15)      LOAD DAY INDEX\n         STH   R0,&P+6             SAVE DDDF\n         OI    &P+7,X'0F'          ENSURE SIGN IS VALID\n         CVB   R15,&P              CONVERT DATE TO JULIAN\n         AR    R15,R14             ADD INDEX TO CURRENT DATE\n         SLR   R14,R14\n         D     R14,&X.S            DIVIDE BY DAYS IN A WEEK\n         LA    R15,&X.U            LOAD \"DAY OF WEEK\" TABLE\n&X.N&N   DS    0H\n         CH    R14,0(,R15)         CHECK FOR DAY KEY\n         BE    &X.O&N              B. IF FOUND\n         LA    R15,14(,R15)        ADVANCE TO NEXT TABLE ENTRY\n         B     &X.N&N\n&X.O&N   DS    0H\n         MVC   0(2,R1),12(R15)     INSERT - DAY OF THE WEEK\n&B       SETA  &B+2                | POINT TO NEXT CHARACTER\n&D       SETA  &D+2                | POINT TO NEXT CHARACTER\n&G       SETB  1                   | INDICATE TABLE REQUIRED\n         AGO   .DAT0800            |\n.*                                 |\n.DAT3000 ANOP  ,                   |\n         B     &X.W                BRANCH AROUND CONSTANTS\n*-------\n*        #DATE CONSTANTS AND CONVERSION TABLES\n*-------\n&X.P     DC    0F'0',X'0000000F'   PACKED DECIMAL ZEROS\n&X.Q     DC    C&FORMAT            FORMAT FIELD OVERLAY\n         AIF   (NOT &G).DAT3100\n&X.R     DC    F'28'               1ST DAY OF YEAR DIVISION FACTOR\n&X.S     DC    F'7'                DAY OF WEEK DIVISION FACTOR\n&X.T     DS    0H                  DAY OF WEEK TABLE (1ST DAY OF YEAR)\n         DC    X'00020304050001'\n         DC    X'02030506000103'\n         DC    X'04050601020304'\n         DC    X'06000102040506'\n&X.U     DS    0H                  DAY OF WEEK TABLE (DAY OF WEEK)\n         DC    H'0',CL10'Saturday  ',C'06'\n         DC    H'1',CL10'Sunday    ',C'07'\n         DC    H'2',CL10'Monday    ',C'01'\n         DC    H'3',CL10'Tuesday   ',C'02'\n         DC    H'4',CL10'Wednesday ',C'03'\n         DC    H'5',CL10'Thursday  ',C'04'\n         DC    H'6',CL10'Friday    ',C'05'\n.DAT3100 ANOP  ,                   |\n         AIF   (NOT &F).DAT3200\n&X.V     DS    0H                  DAY OF MONTH/MONTH OF YEAR TABLE\n         DC    AL2(334,335),CL6'XDec12'\n         DC    AL2(304,305),CL6'XNov11'\n         DC    AL2(273,274),CL6'XOct10'\n         DC    AL2(243,244),CL6'XSep09'\n         DC    AL2(212,213),CL6'XAug08'\n         DC    AL2(181,182),CL6'XJul07'\n         DC    AL2(151,152),CL6'XJun06'\n         DC    AL2(120,121),CL6'XMay05'\n         DC    AL2(090,091),CL6'XApr04'\n         DC    AL2(059,060),CL6'XMar03'\n         DC    AL2(031,031),CL6'XFeb02'\n         DC    AL2(000,000),CL6'XJan01'\n.DAT3200 ANOP  ,                   |\n&X.W     DS    0H                  #DATE MACRO - END\n         AGO   .MEND               |\n.DATERR1 MNOTE 8,'#DATE1E - \"LIST=\" Parameter Is Invalid (YES Or NO)'\n         AGO   .MEND               |\n.DATERR2 MNOTE 8,'#DATE2E - \"TO\" Positional Parameter Is Missing'\n         AGO   .MEND               |\n.MEND    ANOP  ,                   |\n         AIF   ('&LIST' EQ 'YES').MEND2\n         POP   PRINT\n.MEND2   ANOP  ,                   |\n         MEND  ,                   |\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#DCBEXIT": {"ttr": 2821, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x06\\x01\\x11\\x14?\\x01\\x11\\x14?\\tB\\x00\\x9a\\x00\\x9a\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2011-05-23T00:00:00", "modifydate": "2011-05-23T09:42:06", "lines": 154, "newlines": 154, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    #DCBEXIT &ASCII=NO,            RECFM=D SUPPORT                X\n               &BLOCK=YES,              BLOCKING BY DEFAULT            X\n               &CSECT=NO,               GENERATE NEW CSECT             X\n               &EXTEND=,                EXTENDED DCB LOGIC             X\n               &LRECL=80,               DEFAULT LRECL                  X\n               &BLKSIZE=,               DEFAULT BLKSIZE                X\n               &PPC=NO                  UNLIKE CONCAT SUPPORT\n         LCLC  &L,&LABEL,&P\n***********************************************************************\n*\n*        DCB EXIT TO SET DEFAULT LRECL & BLKSIZE\n*\n.*       NOTE-  THIS CODE WILL FUNCTION ON ANY LEVEL OF OS/VS\n.*\n&P       SETC  'DCB&SYSNDX'\n&L       SETC  'OPENBLK'\n&LABEL   SETC  'OPENBLK'\n         AIF   ('&NAME' EQ '').NONAME\n&LABEL   SETC  '&NAME'\n&L       SETC  '&NAME'\n.NONAME  AIF   ('&CSECT' NE 'YES').BOTH\n.CSECT   ANOP  ,\n&L       CSECT ,\n&L       SETC  ' '\n.BOTH    ANOP  ,\n         PUSH  USING\n         DROP  ,\n         USING IHADCB,R1\n         USING &LABEL,R15\n         SPACE 1\n&L       LH    R0,DCBLRECL              GET ORIGINAL LRECL\n         LH    R3,DCBBLKSI                     AND   BLKSIZE\n         SPACE 1\n         LTR   R0,R0                    IS LRECL NON-ZERO ?\n         BNZ   &P.A                     YES, USE IT AS-IS\n         LA    R0,&LRECL                OTHERWISE USE DEFAULT\n         SPACE 1\n&P.A     MVC   DCBBLKSI(1),DCBRECFM     ISOLATE F/V/U REC TYPE\n         NI    DCBBLKSI,DCBRECL\n         AIF   ('&ASCII'(1,1) EQ 'N').NOASCII\n         SPACE 1\n         TM    DCBRECFM,DCBRECD         FORMAT-D RECORDS ?\n         BZ    *+8                      NO, SKIP\n         MVI   DCBBLKSI,DCBRECV         YES, TREAT LIKE FORMAT-V\n         SPACE 1\n.NOASCII LTR   R3,R3                    BLKSIZE STILL ZERO ?\n         BNZ   &P.D                     NO, LEAVE ALONE\n         LR    R3,R0                    YES, SET BLKSIZE = LRECL\n         SPACE 1\n         TM    DCBBLKSI,DCBRECU         IS THIS TYPE-U\n         BNM   &P.E                     YES, BRANCH\n         AIF   ('&BLOCK'(1,1) NE 'Y').BASIC\n         SPACE 1\n         L     R2,16                    POINT TO CVT\n         L     R2,0(0,R2)               POINT TO TCB WORDS\n         L     R2,4(0,R2)               POINT TO OLD TCB\n         L     R2,12(0,R2)              POINT TO TIOT\n         AH    R2,DCBTIOT               POINT TO TIOT ENTRY\n         ICM   R2,7,17(R2)              GET UCB ADDRESS\n         BZ    &P.C                     IF NO UCB, NO BLOCKING\n         TM    18(R2),160               TAPE OR DASD ?\n         BZ    &P.C                     NEITHER, DO NOT BLOCK\n         LA    R4,8                     ASSUME DASD FACTOR OF 256\n         TM    18(R2),128               TAPE ?\n         BZ    &P.B                     NO, SKIP\n         LA    R4,10                    TAKE TAPE FACTOR OF 1024\n&P.B     LA    R3,24                    BLOCKSIZE IS FACTOR*24 AND\n         SLL   R3,0(R4)                 IS ROUNDED DOWN FOR F-TYPE\n         B     &P.D                     SKIP BDW ALLOWANCE\n         SPACE 1\n.BASIC   ANOP  ,\n&P.C     CLI   DCBBLKSI,DCBRECV         IS THIS V-TYPE ?\n         BNE   &P.D                     NO, NO OFFSET\n         LA    R3,4(0,R3)               YES, ALLOW 4 BYTES FOR BDW\n         SPACE 1\n&P.D     CLI   DCBBLKSI,DCBRECF         IS THIS F-TYPE ?\n         BNE   &P.F                     NO, ALL DONE\n         SR    R2,R2\n         DR    R2,R0                    YES, MAKE BLKSIZE EVEN\n         MR    R2,R0                         MULTIPLE OF LRECL\n         CR    R3,R0                    ENSURE RESULT NOT ZERO\n         BH    &P.F                     OKAY, ALL DONE\n         LR    R3,R0                    SET BLKSIZE TO LRECL\n         NI    DCBRECFM,255-DCBRECBR    NO BLOCKING\n         B     &P.F                     ALL DONE\n         SPACE 1\n&P.E     OI    DCBRECFM,DCBRECU         MAKE RECFM=U EXPLICIT\n         NI    DCBRECFM,255-(DCBRECBR+DCBRECSB)   NEITHER B NOR S\n         SR    R0,R0                    SET LRECL TO ZERO\n         SPACE 1\n&P.F     STH   R0,DCBLRECL              SET ACTUAL LRECL\n         AIF   ('&BLKSIZE' EQ '').NOBLKSI\n         LTR   R3,R3                    IS BLKSIZE STILL ZERO?\n         BNZ   &P.H                     B. IF NOT\n         L     R3,&P.G                  OTHERWISE USE DEFAULT\n         B     &P.H                     BYPASS CONSTANT\n&P.G     DC    A(&BLKSIZE)              USER DEFINED DEFAULT BLKSIZE\n.NOBLKSI ANOP  ,\n&P.H     STH   R3,DCBBLKSI              SET ACTUAL BLKSIZE\n         AIF   ('&PPC'(1,1) EQ 'N').NOPPC\n         SPACE 1\n         TM    DCBOFLGS,DCBOFPPC        UNLIKE CONCATENATION ?\n         BZR   R14                      NO, RETURN TO OPEN\n         MVI   IHADCB,255               SET FLAG\n.NOPPC   ANOP  ,\n         BR    R14                      RETURN TO OPEN\n         SPACE 1\n         AIF   ('&EXTEND' EQ '').SKIP2\n         SPACE 1\n.*\n.*  DCB  PREFIX FORMAT -\n.*\n.*  -8   DS    X  ID BYTE=X'ED'\n.*  -7   DS    B  RECFM\n.*  -6   DS    H  LRECL\n.*  -4   DS    H  BLKSIZE\n.*  -2   DS    B  OPTCD BITS\n.*  -1   DS    X  BUFNO\n.*\n         USING &EXTEND,R15\n&EXTEND  LA    R0,8                     DCB PREFIX LENGTH\n         SR    R1,R0                    BACK UP TO PREFIX\n         USING IHADCB-8,R1\n         SPACE 1\n         CLI   IHADCB-8,237             EXTENDED DCB ?\n         BNE   &P.I                     NO, SKIP EXTENSIONS\n         SPACE 1\n         CLI   DCBRECFM,0\n         BNZ   *+10\n         MVC   DCBRECFM,IHADCB-7        SET DEFAULT RECFM\n         SPACE 1\n         ICM   R0,3,DCBLRECL\n         BNZ   *+10\n         MVC   DCBLRECL,IHADCB-6        SET DEFAULT LRECL\n         SPACE 1\n         ICM   R0,3,DCBBLKSI\n         BNZ   *+10\n         MVC   DCBBLKSI,IHADCB-4        SET DEFAULT BLKSIZE\n         SPACE 1\n         OC    DCBOPTCD,IHADCB-2        SET FORCED OPTCD BITS\n         SPACE 1\n         CLI   DCBBUFNO,0\n         BNZ   *+10\n         MVC   DCBBUFNO,IHADCB-1        SET DEFAULT BUFNO\n         SPACE 1\n&P.I     LA    R1,IHADCB                POINT TO BASIC DCB\n         LA    R0,&EXTEND-&LABEL\n         SR    R15,R0\n         BR    R15                      BRANCH TO MAIN EXIT\n         SPACE 1\n.SKIP2   ANOP  ,\n         POP   USING\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DCLSW": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00\\xb7\\x00\\xb7\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 183, "newlines": 183, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    #DCLSW &INIT=0,&MF=D,&GENERIC=\n         GBLA  &DCLDSW#             COUNTER OF # OF SWITCH BYTES\n         GBLA  &DCLGSW#             COUNTER OF # OF GENERIC BYTES\n         GBLB  &DCLDSWD(99)         DEFER DECLARE INDICATIORS\n         GBLC  &DCLDSWN(99)         SWITCH BYTE NAMES\n         GBLC  &DCLDSWB(800)        SWITCH BIT NAMES\n         GBLC  &DCLGSWN(99)         GENERIC SWITCH BYTE NAMES\n         GBLC  &DCLGSWB(99)         GENERIC SWITCH BIT PREFIXES\n         LCLA  &A,&B,&C,&D,&E       LOCAL WORK SYMBOLS\n         LCLB  &F,&G\n         LCLC  &K,&L,&M,&P\n         AIF   ('&GENERIC' EQ '').DCL0200   NO GENERIC, CONTINUE\n.*\n.* THE FOLLOWING IS FOR THE GENERIC= OPTION\n.*\n&DCLGSW# SETA  &DCLGSW#+1           INCREMENT GENERIC SWITCH NUMBER\n&DCLGSWN(&DCLGSW#) SETC '&NAME'     SET SWITCH NAME\n&DCLGSWB(&DCLGSW#) SETC '&GENERIC'   SET GENERIC PREFIX\n         AIF   ('&NAME' NE '').DCL0100   THERE WAS A NAME, EXIT\n&DCLGSWN(&DCLGSW#) SETC '&GENERIC'   SET SWITCH NAME TO PREFIX\n.DCL0100 MEXIT                       EXIT\n.DCL0200 AIF   ('&MF' NE 'L').DCL2300   NOT MF=L, CONTINUE\n.*\n.* THE FOLLOWING IS FOR MF=L\n.*\n         AIF   ('&NAME' EQ '').DCL1200   IF NO NAME, DO ALL\n&A       SETA  0                    START OF LOOP COUNTER\n.DCL0300 AIF   (&A GE &DCLDSW#).DCL3400   ERROR - SWITCH NOT FOUND\n&A       SETA  &A+1                 GET NEXT SWITCH\n         AIF   ('&NAME' NE '&DCLDSWN(&A)').DCL0300   NO MATCH, LOOP\n         AIF   (NOT &DCLDSWD(&A)).DCL3500   ERROR - NOT DEFERRED\n&DCLDSWD(&A) SETB 0                 RESET DEFER BIT\n&K       SETC  '&DCLDSWN(&A)'       GET SWITCH BYTE NAME\n&K       DC    AL1(&INIT)           #DCLSW MACRO, JUNE 29TH, 1979\n&C       SETA  &A*8-7               INDEX TO FIRST SWITCH BIT NAME\n&L       SETC  '&DCLDSWB(&C+0)'     GET SWITCH BIT NAME\n         AIF   ('&L' EQ '').DCL0400   NULL, CONTINUE\n&L       EQU   X'80'                1... ...\n.DCL0400 ANOP\n&L       SETC  '&DCLDSWB(&C+1)'     GET SWITCH BIT NAME\n         AIF   ('&L' EQ '').DCL0500   NULL, CONTINUE\n&L       EQU   X'40'                .1.. ...\n.DCL0500 ANOP\n&L       SETC  '&DCLDSWB(&C+2)'     GET SWITCH BIT NAME\n         AIF   ('&L' EQ '').DCL0600   NULL, CONTINUE\n&L       EQU   X'20'                ..1. ...\n.DCL0600 ANOP\n&L       SETC  '&DCLDSWB(&C+3)'     GET SWITCH BIT NAME\n         AIF   ('&L' EQ '').DCL0700   NULL, CONTINUE\n&L       EQU   X'10'                ...1 ...\n.DCL0700 ANOP\n&L       SETC  '&DCLDSWB(&C+4)'     GET SWITCH BIT NAME\n         AIF   ('&L' EQ '').DCL0800   NULL, CONTINUE\n&L       EQU   X'08'                .... 1..\n.DCL0800 ANOP\n&L       SETC  '&DCLDSWB(&C+5)'     GET SWITCH BIT NAME\n         AIF   ('&L' EQ '').DCL0900   NULL, CONTINUE\n&L       EQU   X'04'                .... .1.\n.DCL0900 ANOP\n&L       SETC  '&DCLDSWB(&C+6)'     GET SWITCH BIT NAME\n         AIF   ('&L' EQ '').DCL1000   NULL, CONTINUE\n&L       EQU   X'02'                .... ..1\n.DCL1000 ANOP\n&L       SETC  '&DCLDSWB(&C+7)'     GET SWITCH BIT NAME\n         AIF   ('&L' EQ '').DCL1100   NULL, CONTINUE\n&L       EQU   X'01'                .... ...1\n.DCL1100 MEXIT                      EXIT\n.DCL1200 ANOP\n&A       SETA  0                    INDEX OF SWITCH BYTES\n&B       SETA  &DCLDSW#             GET NUMBER OF SWITCHES\n.DCL1300 AIF   (&A GE &B).DCL2200   FINISHED, EXIT\n&A       SETA  &A+1                 POINT TO NEXT ONE\n         AIF   (NOT &DCLDSWD(&A)).DCL1300   SKIP IF DEFER BIT NOT ON\n&DCLDSWD(&A) SETB 0                 RESET DEFER BIT\n&K       SETC  '&DCLDSWN(&A)'       GET SWITCH BYTE NAME\n&K       DC    AL1(&INIT)           #DCLSW MACRO, JUNE 29TH, 1979\n&C       SETA  &A*8-7               POINT TO FIRST SWITCH BIT NAME\n&L       SETC  '&DCLDSWB(&C+0)'     GET SWITCH BIT NAME\n         AIF   ('&L' EQ '').DCL1400   NULL, CONTINUE\n&L       EQU   X'80'                1... ...\n.DCL1400 ANOP\n&L       SETC  '&DCLDSWB(&C+1)'     GET SWITCH BIT NAME\n         AIF   ('&L' EQ '').DCL1500   NULL, CONTINUE\n&L       EQU   X'40'                .1.. ...\n.DCL1500 ANOP\n&L       SETC  '&DCLDSWB(&C+2)'     GET SWITCH BIT NAME\n         AIF   ('&L' EQ '').DCL1600   NULL, CONTINUE\n&L       EQU   X'20'                ..1. ...\n.DCL1600 ANOP\n&L       SETC  '&DCLDSWB(&C+3)'     GET SWITCH BIT NAME\n         AIF   ('&L' EQ '').DCL1700   NULL, CONTINUE\n&L       EQU   X'10'                ...1 ...\n.DCL1700 ANOP\n&L       SETC  '&DCLDSWB(&C+4)'     GET SWITCH BIT NAME\n         AIF   ('&L' EQ '').DCL1800   NULL, CONTINUE\n&L       EQU   X'08'                .... 1..\n.DCL1800 ANOP\n&L       SETC  '&DCLDSWB(&C+5)'     GET SWITCH BIT NAME\n         AIF   ('&L' EQ '').DCL1900   NULL, CONTINUE\n&L       EQU   X'04'                .... .1.\n.DCL1900 ANOP\n&L       SETC  '&DCLDSWB(&C+6)'     GET SWITCH BIT NAME\n         AIF   ('&L' EQ '').DCL2000   NULL, CONTINUE\n&L       EQU   X'02'                .... ..1\n.DCL2000 ANOP\n&L       SETC  '&DCLDSWB(&C+7)'     GET SWITCH BIT NAME\n         AIF   ('&L' EQ '').DCL2100   NULL, CONTINUE\n&L       EQU   X'01'                .... ...1\n.DCL2100 AGO   .DCL1300             LOOP BACK TO DO NEXT SWITCH\n.DCL2200 MEXIT                      FINISHED, EXIT\n.DCL2300 AIF   ('&MF' NE 'E').DCL2600   NOT MF=E, CONTINUE\n.*\n.* THE FOLLOWING IS FOR MF=E\n.*\n&A       SETA  0                    INDEX INTO POSITIONAL PARMS\n&B       SETA  N'&SYSLIST           GET NUMBER OF SWITCH BITS\n         AIF   (&B EQ 0).DCL3600    ERROR - NO SWITCH BITS PRESENT\n         AIF   ('&NAME' EQ '').DCL3700   ERROR - NO NAME SUPPLIED\n&DCLDSW# SETA  &DCLDSW#+1           POINT TO NEXT SWITCH BYTE NAME\n&C       SETA  &DCLDSW#*8-7         POINT TO FIRST SWITCH BIT NAME\n&DCLDSWN(&DCLDSW#) SETC '&NAME'     SAVE SWITCH BYTE NAME\n         AIF   (&B LT 9).DCL2400    LESS THAN 9 SWITCHES, CONTINUE\n         MNOTE 4,'DCL001I - Only First 8 Switches Used'\n&B       SETA  8                    SET MAX TO 8\n.DCL2400 ANOP\n&A       SETA  &A+1                 POINT TO NEXT SWITCH\n         AIF   (&A GT &B).DCL2500   FINISHED, EXIT\n&K       SETC  '&SYSLIST(&A)'       GET SWITCH BIT NAME\n         AIF   ('&K' EQ '').DCL2400   A NULL, IGNORE IT\n&DCLDSWB(&A+&C) SETC '&K'           SAVE SWITCH BIT NAME\n         AGO   .DCL2400             LOOP THRU ALL 8 SWITCH BIT NAMES\n.DCL2500 MEXIT                      EXIT\n.DCL2600 AIF   ('&MF' EQ 'D').DCL2700   MF=D, CONTINUE\n         MNOTE 4,'DCL002I - MF=&MF Invalid, MF=D Assumed'\n.DCL2700 ANOP\n.*\n.* THE FOLLOWING IS FOR MF=D\n.*\n&A       SETA  0                    INDEX INTO POSITIONAL PARMS\n&B       SETA  N'&SYSLIST           GET NUMBER OF SWITCH BITS\n         AIF   (&B EQ 0).DCL3600    ERROR - NO SWITCH BITS PRESENT\n         AIF   ('&NAME' EQ '').DCL3000   NO NAME SUPPLIED, CONTINUE\n&DCLDSW# SETA  &DCLDSW#+1           POINT TO NEXT SWITCH BYTE NAME\n&C       SETA  &DCLDSW#*8-8         POINT TO FIRST SWITCH BIT NAME\n&DCLDSWN(&DCLDSW#) SETC '&NAME'     SAVE SWITCH BYTE NAME\n&DCLDSWD(&DCLDSW#) SETB 1           SET DEFER BIT ON\n         AIF   (&B LT 9).DCL2800    LESS THAN 9 SWITCHES, CONTINUE\n         MNOTE 4,'DCL001I - Only First 8 Switches Used'\n&B       SETA  8                    SET MAX TO 8\n.DCL2800 ANOP\n&A       SETA  &A+1                 POINT TO NEXT SWITCH\n         AIF   (&A GT &B).DCL2900   FINISHED, EXIT\n&K       SETC  '&SYSLIST(&A)'       GET SWITCH BIT NAME\n         AIF   ('&K' EQ '').DCL2800   A NULL, IGNORE IT\n&DCLDSWB(&A+&C) SETC '&K'           SAVE SWITCH BIT NAME\n         AGO   .DCL2800             LOOP THRU ALL 8 SWITCH BIT NAMES\n.DCL2900 MEXIT                      EXIT\n.DCL3000 ANOP\n&C       SETA  0                    BIT NUMBER, IN A BYTE\n.DCL3100 ANOP\n&E       SETA  &E+1                 GENERATED SWITCH BYTE NUMBER\n&P       SETC  'DCL&SYSNDX&E'       GENERATE A SWITCH BYTE NAME\n&DCLDSW# SETA  &DCLDSW#+1           POINT TO NEXT SWITCH BYTE NAME\n&C       SETA  0                    INDEX OF BITS\n&DCLDSWN(&DCLDSW#) SETC '&P'        SAVE SWITCH BYTE NAME\n&DCLDSWD(&DCLDSW#) SETB 1           SET DEFER BIT ON\n.DCL3200 AIF   (&C EQ 8).DCL3100    NEED NEW BYTE, GO GET IT\n&C       SETA  &C+1                 POINT TO NEXT BIT\n&A       SETA  &A+1                 POINT TO NEXT SWITCH\n&K       SETC  '&SYSLIST(&A)'       GET SWITCH BIT NAME\n         AIF   ('&K' EQ '').DCL3300   A NULL, IGNORE IT\n&DCLDSWB(&DCLDSW#*8-8+&C) SETC '&K'   SAVE SWITCH BIT NAME\n.DCL3300 AIF   (&A LT &B).DCL3200   LOOP THRU ALL BITS\n         MEXIT                      EXIT\n.DCL3400 MNOTE 8,'DCL003A - Switch \"&NAME\" Not Found'\n         MEXIT\n.DCL3500 MNOTE 8,'DCL004A - Switch \"&NAME\" Not Previously Deferred'   *\n         MEXIT\n.DCL3600 MNOTE 8,'DCL005A - No Switches Present'\n         MEXIT\n.DCL3700 MNOTE 8,'DCL006A - MF=E Requires A Name To Be Supplied'\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#DIRSCAN": {"ttr": 262, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00+\\x00+\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 43, "newlines": 43, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    #DIRSCAN &DCB,&MEMPTR=,&NEXT=,&LAST=,&COUNTER=,&WKREG=\n         LCLC  &L,&M,&N,&X\n         AIF   ('&DCB' EQ '').DIR04     ERROR - NO DCB\n         AIF   ('&MEMPTR' EQ '').DIR05  ERROR - NO MEMPTR\n         AIF   ('&NEXT' EQ '').DIR06    ERROR - NO NEXT\n         AIF   ('&LAST' EQ '').DIR07    ERROR - NO LAST\n         AIF   ('&WKREG' EQ '').DIR08   ERROR - NO WORK REG\n&L       SETC  '&WKREG'                 PICK UP WORK REGISTER\n&M       SETC  '&MEMPTR'                MEMBER POINTER\n&N       SETC  '&COUNTER'               COUNTER\n&X       SETC  '&SYSNDX'                AND THE INDEX\n&NAME    B     DIR&X.1                  GO READ FIRST DIRECTORY BLOCK\n&NEXT    IC    R1,11(0,&M)              ISOLATE LENGTH\n         SLL   R1,27                    OF NEXT ENTRY\n         SRL   R1,26\n         LA    &M,12(R1,&M)             POINT TO NEXT ENTRY\n         CLR   &M,&L                    HAVE WE REACHED END OF BLOCK?\n         BL    DIR&X.2                  NO, GO TEST FOR LAST ENTRY\nDIR&X.1  GET   &DCB                     READ IN A DIRECTORY BLOCK\n         AIF   ('&N' EQ '').DIR03       NO COUNTER, CONTINUE\n         AIF   ('&N'(1,1) EQ '(').DIR02 COUNTER, IS A REG\n         LA    R15,1                    INCREMENT COUNTER OF # BLOCKS\n         A     R15,&N\n         ST    R15,&N\n         AGO   .DIR03\n.DIR02   LA    &N(1),1(0,&N(1))         INCREMENT COUNTER OF # BLOCKS\n.DIR03   LH    &L,0(0,R1)               GET LENGTH OF BLOCK\n         LA    &L,0(R1,&L)              POINT TO LAST USED BYTE\n         LA    &M,2(0,R1)               POINT TO FIRST ENTRY\nDIR&X.2  CLI   0(&M),255                IS THIS END OF DIRECTORY ?\n         BE    &LAST                    YES, TAKE EXIT\n         MEXIT ,\n.DIR04   IHBERMAC 1006,DCB\n         MEXIT ,\n.DIR05   IHBERMAC 1006,MEMPTR\n         MEXIT ,\n.DIR06   IHBERMAC 1006,NEXT\n         MEXIT ,\n.DIR07   IHBERMAC 1006,LAST\n         MEXIT ,\n.DIR08   IHBERMAC 1006,WKREG\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DSECTS": {"ttr": 6919, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x003\\x01\\x160\\x7f\\x01\\x160\\x7f\\x12V\\x05\\x19\\x05\\x19\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-11-02T00:00:00", "modifydate": "2016-11-02T12:56:33", "lines": 1305, "newlines": 1305, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         #DSECTS &LIST=NO,&TYPE=\n.*---------------------------------------------------------------------\n.*\n.*  GEN SEQUENCE -\n.*\n.*       PSA CSD SVT LCCA LCCAT PCCA PCCAT GDA LDA CPAB CVT SCVT DCCVT\n.*       ASCB ASXB ASVT SRB TCB DCTCB OUCB OUXB SIOT TIOT TCT LCT SCT\n.*       JCT JMR JMUD JSCB ATTCH SCB SMCA BASEA CSCB CIB ECB ACB RPL\n.*       DCB DECB JFCB JFCBX JFCBE DEB IOB IOSB IPIB ATB IOCM UCB UCM\n.*       WQE RQE DSCB DSAB RB IQE CDE LPDE LLE XL QCB QEL PSCB ECT UPT\n.*       SDWA FRRS WSAVT TSB CPPL PPL CSPL CSOA IOPL ALLOC AMDSB CAXWA\n.*       CCA CICB CTGCV CAMLST CTGFL CTGFV CTGPL CTGVL CTGWA EDT UPL\n.*       ZB502 ZB505 ZB506 QMPA JESCT SSCVT SSVT SSIB SSOB SSAT JCTX\n.*       DSNT PCCB SWB WPL SCTX IOBE\n.*\n.* --------------------------------------------------------------------\n.*\n.*  GROUP NAMES-\n.*      DM -     ACB DCB DEB DECB DSAB DSCB IOB JFCB RPL\n.*      ENQ -    QCB QEL\n.*      IO -     ACB DCB DEB DECB ECB IOB IOBE JFCB RPL RQE UCB\n.*      JOB -    ASCB CIB CSCB ECB JMR JMUD JSCB TCT TIOT\n.*      PROG -   CDE LLE LPDE RB XL\n.*      SUBSYS - JESCT SSCT SSIB SSOB SSVT\n.*      SWA -    DSNT JCT JCTX JFCB JFCBE LCT SCT SIOT SCTX\n.*      SWAM -   ZB502 ZB505 ZB506 QMPA\n.*      SYS -    CVT DCCVT ECB PSA CSD QCB QEL SCVT UCB UCM\n.*      TASK -   SCB TCB TCT TIOT\n.*      TSO -    CPPL ECT JSCB PSCB TSB UPT PPL IOPL\n.*      VSAM -   ACB RPL\n.*\n.* --------------------------------------------------------------------\n.*\n.*      TO INCLUDE NEW DSECTS THE FOLLOWING STEPS ARE NECESSARY-\n.*      1) DEFINE A GLOBAL SWITCH, FORMAT &RCPXXXX\n.*      2) INSERT A SWITCH SETTING(S) FOR THE NEW SWITCH AS FOLLOWS\n.*         &RCPXXXX SETB ('&O' EQ 'KEY' OR &RCPXXXX)\n.*         WHERE KEY IS THE OPERAND WHICH REQUESTS THE DSECT\n.*         ONE SETB IS REQUIRED FOR EACH KEY REQUIRED, EG. THE\n.*         ACRONYM FOR THE DATA AREA, THE GENERIC NAME, AND ANY ALIASES\n.*      3) DETERMINE WHERE IN THE ASSEMBLY YOU WANT THE DSECT TO APPEAR\n.*         AND INSERT THE FOLLOWING STATEMENTS-\n.*                  AIF   (NOT &RCPXXXX AND NOT &ALL).NOXXXX\n.*                  TITLE 'DATA AREA NAME'\n.*         XXXX     DSECT (IF NECESSARY)\n.*                  DSECTMACRONAME LIST=&LIST (IFNECESSARY)\n.*         .NOXXXX  ANOP\n.*\n.* --------------------------------------------------------------------\n         GBLB  &RCPACB(2)\n         GBLB  &RCPACEE(2)\n         GBLB  &RCPALLC(2)\n         GBLB  &RCPASCB(2)\n         GBLB  &RCPASSB(2)\n         GBLB  &RCPASVT(2)\n         GBLB  &RCPASXB(2)\n         GBLB  &RCPATB(2)\n         GBLB  &RCPATCH(2)\n         GBLB  &RCPBASE(2)\n         GBLB  &RCPCDE(2)\n         GBLB  &RCPCIB(2)\n         GBLB  &RCPCPAB(2)\n         GBLB  &RCPCPPL(2)\n         GBLB  &RCPCSCB(2)\n         GBLB  &RCPCSD(2)\n         GBLB  &RCPCSPL(2)\n         GBLB  &RCPCTLG(2)\n         GBLB  &RCPCVAF(2)\n         GBLB  &RCPCVT(2)\n         GBLB  &RCPDACA(2)\n         GBLB  &RCPDCB(2)\n         GBLB  &RCPDCBE(2)\n         GBLB  &RCPDCVT(2)\n         GBLB  &RCPDEB(2)\n         GBLB  &RCPDECB(2)\n         GBLB  &RCPDSAB(2)\n         GBLB  &RCPDSCB(2)\n         GBLB  &RCPDSNT(2)\n         GBLB  &RCPDSERV(2)\n         GBLB  &RCPDTCB(2)\n         GBLB  &RCPECB(2)\n         GBLB  &RCPECT(2)\n         GBLB  &RCPEDT(2)\n         GBLB  &RCPFRRS(2)\n         GBLB  &RCPGDA(2)\n         GBLB  &RCPGEPL(2)\n         GBLB  &RCPIOB(2)\n         GBLB  &RCPIOBE(2)\n         GBLB  &RCPIOPL(2)\n         GBLB  &RCPIOSB(2)\n         GBLB  &RCPIPA(2)\n         GBLB  &RCPIPIB(2)\n         GBLB  &RCPIQE(2)\n         GBLB  &RCPJCT(2)\n         GBLB  &RCPJCTX(2)\n         GBLB  &RCPJES(2)\n         GBLB  &RCPJFCB(2)\n         GBLB  &RCPJFCX(2)\n         GBLB  &RCPJMR(2)\n         GBLB  &RCPJMUD(2)\n         GBLB  &RCPJSCB(2)\n         GBLB  &RCPLCCA(2)\n         GBLB  &RCPLCCT(2)\n         GBLB  &RCPLCT(2)\n         GBLB  &RCPLDA(2)\n         GBLB  &RCPLLE(2)\n         GBLB  &RCPLPDAT(2)\n         GBLB  &RCPLPDE(2)\n         GBLB  &RCPLWA(2)\n         GBLB  &RCPMEPL(2)\n         GBLB  &RCPMNPL(2)\n         GBLB  &RCPMQAA(2)\n         GBLB  &RCPOUCB(2)\n         GBLB  &RCPOUXB(2)\n         GBLB  &RCPPCCA(2)\n         GBLB  &RCPPCCB(2)\n         GBLB  &RCPPCCT(2)\n         GBLB  &RCPPPL(2)\n         GBLB  &RCPPSA(2)\n         GBLB  &RCPPSCB(2)\n         GBLB  &RCPQDB(2)\n         GBLB  &RCPQCB(2)\n         GBLB  &RCPQEL(2)\n         GBLB  &RCPQMPA(2)\n         GBLB  &RCPQUAA(2)\n         GBLB  &RCPRB(2)\n         GBLB  &RCPRCVT(2)\n         GBLB  &RCPRMCT(2)\n         GBLB  &RCPRMCTZ(2)\n         GBLB  &RCPRPL(2)\n         GBLB  &RCPRQE(2)\n         GBLB  &RCPSCB(2)\n         GBLB  &RCPSCT(2)\n         GBLB  &RCPSCTX(2)\n         GBLB  &RCPSCVT(2)\n         GBLB  &RCPSDWA(2)\n         GBLB  &RCPSEPL(2)\n         GBLB  &RCPSIOT(2)\n         GBLB  &RCPSIOTX(2)\n         GBLB  &RCPSMCA(2)\n         GBLB  &RCPSRB(2)\n         GBLB  &RCPSSS(2)\n         GBLB  &RCPSSAT(2)\n         GBLB  &RCPSVT(2)\n         GBLB  &RCPSWB(2)\n         GBLB  &RCPTCB(2)\n         GBLB  &RCPTCT(2)\n         GBLB  &RCPTIOT(2)\n         GBLB  &RCPTSB(2)\n         GBLB  &RCPUCB(2)\n         GBLB  &RCPUCBCX(2)\n         GBLB  &RCPUCBG(2)\n         GBLB  &RCPUCM(2)\n         GBLB  &RCPUPT(2)\n         GBLB  &RCPWPL(2)\n         GBLB  &RCPWQE(2)\n         GBLB  &RCPWSVT(2)\n         GBLB  &RCPXL(2)\n         GBLB  &RCPXSB(2)\n         GBLB  &RCPZ4UV(2)\n         GBLB  &RCPZ502(2)\n         GBLB  &RCPZ505(2)\n         GBLB  &RCPZ506(2)\n.*\n         LCLA  &OP\n         LCLC  &O\n         LCLB  &ALL,&PRT\n         GBLC  &ZPRINT              IBM MACRO PRINT CONTROL\n         GBLC  &ZCBPRINT            ANOTHER IBM PRINT CTL\n         LCLC  &SAVEZ\n         LCLC  &SAVEZCB\n&SAVEZ   SETC  '&ZPRINT'            SAVE CURRENT VALUE\n&SAVEZCB SETC  '&ZCBPRINT'          SAVE CURRENT VALUE\n&ZPRINT  SETC  '&LIST'              SET IBM PRINT CONTROL\n&ZCBPRINT SETC '&LIST'              SET ANOTHER IBM CONTROL\n&PRT     SETB  ('&LIST' EQ 'YES')\n&ALL     SETB  (N'&SYSLIST EQ 1 AND '&SYSLIST(1)' EQ 'ALL')\n         AIF   (&ALL).DSE0200\n.DSE0100 AIF   (&OP EQ N'&SYSLIST).DSE0200\n&OP      SETA  &OP+1\n&O       SETC  '&SYSLIST(&OP)'\n.*\n.*  SET UP REQUESTED CONTROL SWITCHES\n.*\n&RCPACB(1)  SETB ('&O' EQ 'ACB'   OR '&O' EQ 'VSAM' OR &RCPACB(1))\n&RCPACB(1)  SETB ('&O' EQ 'DM'    OR &RCPACB(1))\n&RCPACB(1)  SETB ('&O' EQ 'IO'    OR &RCPACB(1))\n&RCPACEE(1) SETB ('&O' EQ 'ACEE'  OR &RCPACEE(1))\n&RCPALLC(1) SETB ('&O' EQ 'ALLOC' OR '&O' EQ 'ALLOCX' OR &RCPALLC(1))\n&RCPASCB(1) SETB ('&O' EQ 'ASCB'  OR &RCPASCB(1))\n&RCPASSB(1) SETB ('&O' EQ 'ASSB'  OR &RCPASSB(1))\n&RCPASCB(1) SETB ('&O' EQ 'JOB'   OR &RCPASCB(1))\n&RCPASVT(1) SETB ('&O' EQ 'ASVT'  OR &RCPASVT(1))\n&RCPASXB(1) SETB ('&O' EQ 'ASXB'  OR &RCPASXB(1))\n&RCPASXB(1) SETB ('&O' EQ 'JOB'   OR &RCPASXB(1))\n&RCPATB(1)  SETB ('&O' EQ 'ATB'   OR &RCPATB(1))\n&RCPATCH(1) SETB ('&O' EQ 'ATTCH' OR &RCPATCH(1))\n&RCPBASE(1) SETB ('&O' EQ 'BASEA' OR &RCPBASE(1))\n&RCPBASE(1) SETB ('&O' EQ 'MSRDA' OR &RCPBASE(1))\n&RCPCDE(1)  SETB ('&O' EQ 'CDE'   OR &RCPCDE(1))\n&RCPCDE(1)  SETB ('&O' EQ 'PROG'  OR &RCPCDE(1))\n&RCPCIB(1)  SETB ('&O' EQ 'CIB'   OR &RCPCIB(1))\n&RCPCIB(1)  SETB ('&O' EQ 'JOB'   OR &RCPCIB(1))\n&RCPCPAB(1) SETB ('&O' EQ 'CPAB'  OR &RCPCPAB(1))\n&RCPCPPL(1) SETB ('&O' EQ 'CPPL'  OR &RCPCPPL(1))\n&RCPCPPL(1) SETB ('&O' EQ 'TSO'   OR &RCPCPPL(1))\n&RCPCSCB(1) SETB ('&O' EQ 'CSCB'  OR &RCPCSCB(1))\n&RCPCSCB(1) SETB ('&O' EQ 'JOB'   OR &RCPCSCB(1))\n&RCPCSD(1)  SETB ('&O' EQ 'CSD'   OR &RCPCSD(1))\n&RCPCSD(1)  SETB ('&O' EQ 'SYS'   OR &RCPCSD(1))\n&RCPCSPL(1) SETB ('&O' EQ 'CSOA'  OR &RCPCSPL(1))\n&RCPCSPL(1) SETB ('&O' EQ 'CSPL'  OR &RCPCSPL(1))\n&RCPCSPL(1) SETB ('&O' EQ 'TSO'   OR &RCPCSPL(1))\n&RCPCTLG(1) SETB ('&O' EQ 'CATLG' OR &RCPCTLG(1))\n&RCPCTLG(1) SETB ('&O' EQ 'CTLG'  OR &RCPCTLG(1))\n&RCPCVAF(1) SETB ('&O' EQ 'CVAF'  OR &RCPCVAF(1))\n&RCPCVT(1)  SETB ('&O' EQ 'CVT'   OR &RCPCVT(1))\n&RCPCVT(1)  SETB ('&O' EQ 'SYS'   OR &RCPCVT(1))\n&RCPDACA(1) SETB ('&O' EQ 'DACA'  OR &RCPDACA(1))\n&RCPDCB(1)  SETB ('&O' EQ 'DCB'   OR &RCPDCB(1))\n&RCPDCB(1)  SETB ('&O' EQ 'DM'    OR &RCPDCB(1))\n&RCPDCB(1)  SETB ('&O' EQ 'IO'    OR &RCPDCB(1))\n&RCPDCBE(1) SETB ('&O' EQ 'DCBE'  OR &RCPDCBE(1))\n&RCPDCVT(1) SETB ('&O' EQ 'SYS'   OR &RCPDCVT(1))\n&RCPDEB(1)  SETB ('&O' EQ 'DEB'   OR &RCPDEB(1))\n&RCPDEB(1)  SETB ('&O' EQ 'DM'    OR &RCPDEB(1))\n&RCPDEB(1)  SETB ('&O' EQ 'IO'    OR &RCPDEB(1))\n&RCPDECB(1) SETB ('&O' EQ 'DECB'  OR &RCPDECB(1))\n&RCPDECB(1) SETB ('&O' EQ 'DM'    OR &RCPDECB(1))\n&RCPDECB(1) SETB ('&O' EQ 'IO'    OR &RCPDECB(1))\n&RCPDSAB(1) SETB ('&O' EQ 'DM'    OR &RCPDSAB(1))\n&RCPDSAB(1) SETB ('&O' EQ 'DSAB'  OR &RCPDSAB(1))\n&RCPDSCB(1) SETB ('&O' EQ 'DM'    OR &RCPDSCB(1))\n&RCPDSCB(1) SETB ('&O' EQ 'DSCB'  OR &RCPDSCB(1))\n&RCPDSNT(1) SETB ('&O' EQ 'DSNT'  OR &RCPDSNT(1))\n&RCPDSNT(1) SETB ('&O' EQ 'SWA'   OR &RCPDSNT(1))\n&RCPDSERV(1) SETB ('&O' EQ 'DSERV' OR &RCPDSERV(1))\n&RCPECB(1)  SETB ('&O' EQ 'ECB'   OR &RCPECB(1))\n&RCPECB(1)  SETB ('&O' EQ 'IO'    OR &RCPECB(1))\n&RCPECB(1)  SETB ('&O' EQ 'JOB'   OR &RCPECB(1))\n&RCPECB(1)  SETB ('&O' EQ 'SYS'   OR &RCPECB(1))\n&RCPECT(1)  SETB ('&O' EQ 'ECT'   OR &RCPECT(1))\n&RCPECT(1)  SETB ('&O' EQ 'TSO'   OR &RCPECT(1))\n&RCPEDT(1)  SETB ('&O' EQ 'EDT'   OR &RCPEDT(1))\n&RCPFRRS(1) SETB ('&O' EQ 'FRRS'  OR &RCPFRRS(1))\n&RCPGDA(1)  SETB ('&O' EQ 'GDA'   OR &RCPGDA(1))\n&RCPGEPL(1) SETB ('&O' EQ 'GEPL'  OR &RCPGEPL(1))\n&RCPIOB(1)  SETB ('&O' EQ 'DM'    OR &RCPIOB(1))\n&RCPIOB(1)  SETB ('&O' EQ 'IO'    OR &RCPIOB(1))\n&RCPIOB(1)  SETB ('&O' EQ 'IOB'   OR &RCPIOB(1))\n&RCPIOBE(1) SETB ('&O' EQ 'IO'    OR &RCPIOBE(1))\n&RCPIOBE(1) SETB ('&O' EQ 'IOBE'  OR &RCPIOBE(1))\n&RCPIOPL(1) SETB ('&O' EQ 'IOPL'  OR &RCPIOPL(1))\n&RCPIOPL(1) SETB ('&O' EQ 'TSO'   OR &RCPIOPL(1))\n&RCPIOSB(1) SETB ('&O' EQ 'IOSB'  OR &RCPIOSB(1))\n&RCPIPA(1)  SETB ('&O' EQ 'IPA'   OR &RCPIPA(1))\n&RCPIPIB(1) SETB ('&O' EQ 'IPIB'  OR &RCPIPIB(1))\n&RCPIQE(1)  SETB ('&O' EQ 'IQE'   OR &RCPIQE(1))\n&RCPJCT(1)  SETB ('&O' EQ 'JCT'   OR &RCPJCT(1))\n&RCPJCT(1)  SETB ('&O' EQ 'SWA'   OR &RCPJCT(1))\n&RCPJCTX(1) SETB ('&O' EQ 'JCTX'  OR &RCPJCTX(1))\n&RCPJCTX(1) SETB ('&O' EQ 'SWA'   OR &RCPJCTX(1))\n&RCPJES(1)  SETB ('&O' EQ 'JESCT' OR &RCPJES(1))\n&RCPJFCB(1) SETB ('&O' EQ 'DM'    OR &RCPJFCB(1))\n&RCPJFCB(1) SETB ('&O' EQ 'IO'    OR &RCPJFCB(1))\n&RCPJFCB(1) SETB ('&O' EQ 'JFCB'  OR &RCPJFCB(1))\n&RCPJFCB(1) SETB ('&O' EQ 'SWA'   OR &RCPJFCB(1))\n&RCPJFCX(1) SETB ('&O' EQ 'DM'    OR &RCPJFCX(1))\n&RCPJFCX(1) SETB ('&O' EQ 'IO'    OR &RCPJFCX(1))\n&RCPJFCX(1) SETB ('&O' EQ 'JFCBE' OR &RCPJFCX(1))\n&RCPJFCX(1) SETB ('&O' EQ 'JFCBX' OR &RCPJFCX(1))\n&RCPJFCX(1) SETB ('&O' EQ 'SWA'   OR &RCPJFCX(1))\n&RCPJMR(1)  SETB ('&O' EQ 'JMR'   OR &RCPJMR(1))\n&RCPJMR(1)  SETB ('&O' EQ 'JOB'   OR &RCPJMR(1))\n&RCPJSCB(1) SETB ('&O' EQ 'JOB'   OR &RCPJSCB(1))\n&RCPJSCB(1) SETB ('&O' EQ 'JSCB'  OR &RCPJSCB(1))\n&RCPJSCB(1) SETB ('&O' EQ 'TSO'   OR &RCPJSCB(1))\n&RCPLCCA(1) SETB ('&O' EQ 'LCCA'  OR &RCPLCCA(1))\n&RCPLCCT(1) SETB ('&O' EQ 'LCCAT' OR &RCPLCCT(1))\n&RCPLCT(1)  SETB ('&O' EQ 'LCT'   OR &RCPLCT(1))\n&RCPLCT(1)  SETB ('&O' EQ 'SWA'   OR &RCPLCT(1))\n&RCPLDA(1)  SETB ('&O' EQ 'LDA'   OR &RCPLDA(1))\n&RCPLLE(1)  SETB ('&O' EQ 'LLE'   OR &RCPLLE(1))\n&RCPLLE(1)  SETB ('&O' EQ 'PROG'  OR &RCPLLE(1))\n&RCPLPDAT(1) SETB ('&O' EQ 'LPDAT' OR &RCPLPDAT(1))\n&RCPLPDE(1) SETB ('&O' EQ 'LPDE'  OR &RCPLPDE(1))\n&RCPLPDE(1) SETB ('&O' EQ 'PROG'  OR &RCPLPDE(1))\n&RCPLWA(1)  SETB ('&O' EQ 'LWA'   OR &RCPLWA(1))\n&RCPMEPL(1) SETB ('&O' EQ 'MEPL'  OR &RCPMEPL(1))\n&RCPMNPL(1) SETB ('&O' EQ 'MNPL'  OR &RCPMNPL(1))\n&RCPMQAA(1) SETB ('&O' EQ 'MQAA'  OR &RCPMQAA(1))\n&RCPOUCB(1) SETB ('&O' EQ 'OUCB'  OR &RCPOUCB(1))\n&RCPOUXB(1) SETB ('&O' EQ 'OUXB'  OR &RCPOUXB(1))\n&RCPPCCA(1) SETB ('&O' EQ 'PCCA'  OR &RCPPCCA(1))\n&RCPPCCB(1) SETB ('&O' EQ 'PCCB'  OR &RCPPCCB(1))\n&RCPPCCT(1) SETB ('&O' EQ 'PCCAT' OR &RCPPCCT(1))\n&RCPPPL(1)  SETB ('&O' EQ 'PPL'   OR &RCPPPL(1))\n&RCPPPL(1)  SETB ('&O' EQ 'TSO'   OR &RCPPPL(1))\n&RCPPSA(1)  SETB ('&O' EQ 'PSA'   OR &RCPPSA(1))\n&RCPPSA(1)  SETB ('&O' EQ 'SYS'   OR &RCPPSA(1))\n&RCPPSCB(1) SETB ('&O' EQ 'PSCB'  OR &RCPPSCB(1))\n&RCPPSCB(1) SETB ('&O' EQ 'TSO'   OR &RCPPSCB(1))\n&RCPQCB(1)  SETB ('&O' EQ 'ENQ'   OR &RCPQCB(1))\n&RCPQCB(1)  SETB ('&O' EQ 'QCB'   OR &RCPQCB(1))\n&RCPQCB(1)  SETB ('&O' EQ 'SYS'   OR &RCPQCB(1))\n&RCPQDB(1)  SETB ('&O' EQ 'QDB'   OR &RCPQDB(1))\n&RCPQEL(1)  SETB ('&O' EQ 'ENQ'   OR &RCPQEL(1))\n&RCPQEL(1)  SETB ('&O' EQ 'QEL'   OR &RCPQEL(1))\n&RCPQEL(1)  SETB ('&O' EQ 'SYS'   OR &RCPQEL(1))\n&RCPQMPA(1) SETB ('&O' EQ 'QMPA'  OR &RCPQMPA(1))\n&RCPQMPA(1) SETB ('&O' EQ 'SWAM'  OR &RCPQMPA(1))\n&RCPQUAA(1) SETB ('&O' EQ 'QUAA'  OR &RCPQUAA(1))\n&RCPRB(1)   SETB ('&O' EQ 'PROG'  OR &RCPRB(1))\n&RCPRB(1)   SETB ('&O' EQ 'RB'    OR &RCPRB(1))\n&RCPRCVT(1) SETB ('&O' EQ 'RCVT'  OR &RCPRCVT(1))\n&RCPRMCT(1) SETB ('&O' EQ 'RMCT'  OR &RCPRMCT(1))\n&RCPRMCTZ(1) SETB ('&O' EQ 'RMCTZ'  OR &RCPRMCTZ(1))\n&RCPRPL(1)  SETB ('&O' EQ 'DM'    OR &RCPRPL(1))\n&RCPRPL(1)  SETB ('&O' EQ 'IO'    OR &RCPRPL(1))\n&RCPRPL(1)  SETB ('&O' EQ 'RPL'   OR '&O' EQ 'VSAM' OR &RCPRPL(1))\n&RCPRQE(1)  SETB ('&O' EQ 'IO'    OR &RCPRQE(1))\n&RCPRQE(1)  SETB ('&O' EQ 'RQE'   OR &RCPRQE(1))\n&RCPSCB(1)  SETB ('&O' EQ 'SCB'   OR &RCPSCB(1))\n&RCPSCB(1)  SETB ('&O' EQ 'TASK'  OR &RCPSCB(1))\n&RCPSCT(1)  SETB ('&O' EQ 'SCT'   OR &RCPSCT(1))\n&RCPSCT(1)  SETB ('&O' EQ 'SWA'   OR &RCPSCT(1))\n&RCPSCTX(1) SETB ('&O' EQ 'SCTX'  OR &RCPSCTX(1))\n&RCPSCTX(1) SETB ('&O' EQ 'SWA'   OR &RCPSCTX(1))\n&RCPSCVT(1) SETB ('&O' EQ 'SCVT'  OR &RCPSCVT(1))\n&RCPSCVT(1) SETB ('&O' EQ 'SYS'   OR &RCPSCVT(1))\n&RCPSDWA(1) SETB ('&O' EQ 'SDWA'  OR &RCPSDWA(1))\n&RCPSEPL(1) SETB ('&O' EQ 'SEPL'  OR &RCPSEPL(1))\n&RCPSIOT(1) SETB ('&O' EQ 'SIOT'  OR &RCPSIOT(1))\n&RCPSIOT(1) SETB ('&O' EQ 'SWA'   OR &RCPSIOT(1))\n&RCPSIOTX(1) SETB ('&O' EQ 'SIOTX' OR &RCPSIOTX(1))\n&RCPSIOTX(1) SETB ('&O' EQ 'SWA'   OR &RCPSIOTX(1))\n&RCPSMCA(1) SETB ('&O' EQ 'SMCA'  OR &RCPSMCA(1))\n&RCPSMCA(1) SETB ('&O' EQ 'SMF'   OR &RCPSMCA(1))\n&RCPSRB(1)  SETB ('&O' EQ 'SRB'   OR &RCPSRB(1))\n&RCPSSAT(1) SETB ('&O' EQ 'SSAT'  OR &RCPSSAT(1))\n&RCPSSS(1)  SETB ('&O' EQ 'SSCT'  OR &RCPSSS(1))\n&RCPSSS(1)  SETB ('&O' EQ 'SSIB'  OR &RCPSSS(1))\n&RCPSSS(1)  SETB ('&O' EQ 'SSOB'  OR &RCPSSS(1))\n&RCPSSS(1)  SETB ('&O' EQ 'SSVT'  OR &RCPSSS(1))\n&RCPSSS(1)  SETB ('&O' EQ 'SUBSYS' OR &RCPSSS(1))\n&RCPSVT(1)  SETB ('&O' EQ 'SVT'   OR &RCPSVT(1))\n&RCPSWB(1)  SETB ('&O' EQ 'SWB'   OR &RCPSWB(1))\n&RCPTCB(1)  SETB ('&O' EQ 'TASK'  OR &RCPTCB(1))\n&RCPTCB(1)  SETB ('&O' EQ 'TCB'   OR &RCPTCB(1))\n&RCPTCT(1)  SETB ('&O' EQ 'JOB'   OR &RCPTCT(1))\n&RCPTCT(1)  SETB ('&O' EQ 'TASK'  OR &RCPTCT(1))\n&RCPTCT(1)  SETB ('&O' EQ 'TCT'   OR &RCPTCT(1))\n&RCPTIOT(1) SETB ('&O' EQ 'DM'    OR &RCPTIOT(1))\n&RCPTIOT(1) SETB ('&O' EQ 'IO'    OR &RCPTIOT(1))\n&RCPTIOT(1) SETB ('&O' EQ 'JOB'   OR &RCPTIOT(1))\n&RCPTIOT(1) SETB ('&O' EQ 'TASK'  OR &RCPTIOT(1))\n&RCPTIOT(1) SETB ('&O' EQ 'TIOT'  OR &RCPTIOT(1))\n&RCPTSB(1)  SETB ('&O' EQ 'TSB'   OR &RCPTSB(1))\n&RCPTSB(1)  SETB ('&O' EQ 'TSO'   OR &RCPTSB(1))\n&RCPUCB(1)  SETB ('&O' EQ 'IO'    OR &RCPUCB(1))\n&RCPUCB(1)  SETB ('&O' EQ 'SYS'   OR &RCPUCB(1))\n&RCPUCB(1)  SETB ('&O' EQ 'UCB'   OR &RCPUCB(1))\n&RCPUCBCX(1) SETB ('&O' EQ 'UCBCX' OR &RCPUCBCX(1))\n&RCPUCBG(1) SETB ('&O' EQ 'IOCM'  OR &RCPUCBG(1))\n&RCPUCBG(1) SETB ('&O' EQ 'IOCOM' OR &RCPUCBG(1))\n&RCPUCBG(1) SETB ('&O' EQ 'UCBLOOK' OR &RCPUCBG(1))\n&RCPUCM(1)  SETB ('&O' EQ 'SYS'   OR &RCPUCM(1))\n&RCPUCM(1)  SETB ('&O' EQ 'UCM'   OR &RCPUCM(1))\n&RCPUPT(1)  SETB ('&O' EQ 'TSO'   OR &RCPUPT(1))\n&RCPUPT(1)  SETB ('&O' EQ 'UPT'   OR &RCPUPT(1))\n&RCPWPL(1)  SETB ('&O' EQ 'WPL'   OR &RCPWPL(1))\n&RCPWQE(1)  SETB ('&O' EQ 'WQE'   OR &RCPWQE(1))\n&RCPWSVT(1) SETB ('&O' EQ 'WSAVT' OR &RCPWSVT(1))\n&RCPXL(1)   SETB ('&O' EQ 'PROG'  OR &RCPXL(1))\n&RCPXL(1)   SETB ('&O' EQ 'XL'    OR &RCPXL(1))\n&RCPXSB(1)  SETB ('&O' EQ 'XSB'   OR &RCPXSB(1))\n&RCPZ4UV(1) SETB ('&O' EQ 'ZB4UV' OR &RCPZ4UV(1))\n&RCPZ502(1) SETB ('&O' EQ 'SWAM'  OR &RCPZ502(1))\n&RCPZ502(1) SETB ('&O' EQ 'ZB502' OR &RCPZ502(1))\n&RCPZ505(1) SETB ('&O' EQ 'EPA'   OR &RCPZ505(1))\n&RCPZ505(1) SETB ('&O' EQ 'SWAM'  OR &RCPZ505(1))\n&RCPZ505(1) SETB ('&O' EQ 'ZB505' OR &RCPZ505(1))\n&RCPZ506(1) SETB ('&O' EQ 'EPA'   OR &RCPZ506(1))\n&RCPZ506(1) SETB ('&O' EQ 'SWAM'  OR &RCPZ506(1))\n&RCPZ506(1) SETB ('&O' EQ 'ZB506' OR &RCPZ506(1))\n         AGO   .DSE0100\n.*\n.*  SET UP DEPENDENCIES\n.*\n.DSE0200    ANOP  ,\n&RCPASCB(1) SETB (&RCPASCB(1) OR &RCPASXB(1))     ASXB  -->  ASCB\n&RCPCSCB(1) SETB (&RCPCSCB(1) OR &RCPCIB(1))      CIB   -->  CSCB\n&RCPCVT(1)  SETB (&RCPCVT(1)  OR &RCPEDT(1))      EDT   -->  CVT\n&RCPCVT(1)  SETB (&RCPCVT(1)  OR &RCPQMPA(1))     QMPA  -->  CVT\n&RCPCVT(1)  SETB (&RCPCVT(1)  OR &RCPSCVT(1))     SCVT  -->  CVT\n&RCPCVT(1)  SETB (&RCPCVT(1)  OR &RCPZ505(1))     ZB505 -->  CVT\n&RCPCVT(1)  SETB (&RCPCVT(1)  OR &RCPZ506(1))     ZB506 -->  CVT\n&RCPJES(1)  SETB (&RCPJES(1)  OR &RCPEDT(1))      EDT   -->  JESCT\n&RCPJES(1)  SETB (&RCPJES(1)  OR &RCPQMPA(1))     QMPA  -->  JESCT\n&RCPJES(1)  SETB (&RCPJES(1)  OR &RCPSSS(1))      SUBSYS-->  JESCT\n&RCPJES(1)  SETB (&RCPJES(1)  OR &RCPZ505(1))     ZB505 -->  JESCT\n&RCPJES(1)  SETB (&RCPJES(1)  OR &RCPZ506(1))     ZB506 -->  JESCT\n&RCPJFCB(1) SETB (&RCPJFCB(1) OR &RCPJFCX(1))     JFCBX -->  JFCB\n&RCPLCCA(1) SETB (&RCPLCCA(1) OR &RCPLCCT(1))     LCCAT -->  LCCA\n&RCPOUCB(1) SETB (&RCPOUCB(1) OR &RCPOUXB(1))     OUXB  -->  OUCB\n&RCPPCCA(1) SETB (&RCPLCCA(1) OR &RCPPCCT(1))     PCCAT -->  PCCA\n&RCPPSA(1)  SETB (&RCPPSA(1)  OR &RCPJMR(1))      JMR   -->  PSA\n&RCPTCB(1)  SETB (&RCPTCB(1)  OR &RCPTCT(1))      TCT   -->  TCB\n&RCPTCT(1)  SETB (&RCPTCT(1)  OR &RCPJMR(1))      JMR   -->  TCT\n.*\n         AIF   ('&TYPE' EQ '').DSE0300\n         AIF   ('&TYPE' EQ 'DEFER        '(1,K'&TYPE)).DSE0500\n.DSE0300 ANOP  ,\n         AIF   (&PRT).DSE0400\n         PUSH  PRINT\n         PRINT OFF\n.DSE0400 ANOP  ,\n         AIF   (NOT &RCPPSA(1) AND NOT &ALL OR &RCPPSA(2)).NOPSA\n&RCPPSA(2) SETB 1\n         TITLE 'PREFIXED SAVE AREA'\nPSA      DSECT ,\n*        IHAPSA LIST=YES\n         IHAPSA LIST=YES\n.NOPSA   ANOP  ,\n         AIF   (NOT &RCPCSD(1) AND NOT &ALL OR &RCPCSD(2)).NOCSD\n&RCPCSD(2) SETB 1\n         TITLE 'COMMON SYSTEM DATA AREA'\n*        IHACSD ,\n         IHACSD ,\n         AIF   (D'CSD_CPU_ALIVE_ADDR).CSD11 Skip if 1.11+ macs\n         ORG   CSDDIAG+88\nCSD_CPU_ALIVE_ADDR  DC   A(0) CPU alive mask pointer. Points to a\n*                             bitmask on a double word boundary (for\n*                             compare and swap) that is\n*                             ECVTMaxMPNumBytesInMask bytes long where\n*                             the first (CVTMAXMP+1) bits are valid.\n*                                                                  @LAA\nCSD_BYLPAR_CP_MASK_ADDR DC A(0) Pointer to mask of processors defined\n*                             as standard processors - not necessarily\n*                             online.  Points to a bitmask on\n*                             a double word boundary (for compare and\n*                             swap) that is ECVTMaxMPNumBytesInMask\n*                             bytes long where the first (CVTMAXMP+1)\n*                             bits are valid.                      @LAA\nCSD_BYLPAR_ZAAP_MASK_ADDR DC A(0) Pointer to mask of processors defined\n*                             as special processors - not necessarily\n*                             online.  Points to a bitmask on\n*                             a double word boundary (for compare and\n*                             swap) that is ECVTMaxMPNumBytesInMask\n*                             bytes long where the first (CVTMAXMP+1)\n*                             bits are valid.                      @LAA\nCSD_BYLPAR_ZIIP_MASK_ADDR DC A(0) Pointer to mask of processors defined\n*                             as zIIP processors - not necessarily\n*                             online.  Points to a bitmask on\n*                             a double word boundary (for compare and\n*                             swap) that is ECVTMaxMPNumBytesInMask\n*                             bytes long where the first (CVTMAXMP+1)\n*                             bits are valid.                      @LAA\nCSD_CPUS_GOING_ON_OR_OFF_MASK_ADDR DC A(0) Pointer to mask of CPUs\n*                             configured on or off during a reporting\n*                             interval.  Points to a bitmask on a\n*                             double word boundary (for compare and\n*                             swap) that is ECVTMaxMPNumBytesInMask\n*                             bytes long where the first (CVTMAXMP+1)\n*                             bits are valid.                      @LAA\nCSD_CPUS_MANIPULATED_BY_WLM_ADDR DC A(0)  Pointer to mask of CPUs\n*                             manipulated by WLM. If bit x is on, then\n*                             WLM put the CPU into its current state\n*                             (online or offline).  Points to a\n*                             bitmask on a double word boundary (for\n*                             compare and swap) that is\n*                             ECVTMaxMPNumBytesInMask bytes long where\n*                             the first (CVTMAXMP+1) bits are valid.\n*                                                                  @LAA\nCSD_CPUS_VARIED_OFFLINE_BY_OPERATOR_ADDR DC A(0) Pointer to mask of\n*                             CPUs configured offline by the operator.\n*                             Points to a bitmask on a double word\n*                             boundary (for compare and swap) that is\n*                             ECVTMaxMPNumBytesInMask bytes long where\n*                             the first (CVTMAXMP+1) bits are valid.\n*                                                                  @LAA\nCSD_CPUS_TAKEN_OFFLINE_BY_ACR_ADDR DC A(0) Pointer to mask of CPUs\n*                             configured offline by ACR.  Points to a\n*                             bitmask on a double word boundary (for\n*                             compare and swap) that is\n*                             ECVTMaxMPNumBytesInMask bytes long where\n*                             the first (CVTMAXMP+1) bits are valid.\n*                                                                  @LAA\n.CSD11   ANOP  ,\n.NOCSD   ANOP  ,\n         AIF   (NOT &RCPSSAT(1) AND NOT &ALL OR &RCPSSAT(2)).NOSSAT\n&RCPSSAT(2) SETB 1\n         TITLE 'SUB SYSTEM AFFINITY TABLE'\n*        IHASSAT ,\n         IHASSAT ,\n.NOSSAT  ANOP  ,\n         AIF   (NOT &RCPSVT(1) AND NOT &ALL OR &RCPSVT(2)).NOSVT\n&RCPSVT(2) SETB 1\n         TITLE 'SUPERVISOR VECTOR TABLE'\n*        IHASVT ,\n         IHASVT ,\n.NOSVT   ANOP  ,\n         AIF   (NOT &RCPSWB(1) AND NOT &ALL OR &RCPSWB(2)).NOSWB\n&RCPSWB(2) SETB 1\n*        IEFSWB ,\n         IEFSWB ,\n.NOSWB   ANOP  ,\n         AIF   (NOT &RCPLCCA(1) AND NOT &ALL OR &RCPLCCA(2)).NOLCCA\n&RCPLCCA(2) SETB 1\n         TITLE 'LOGICAL CONFIGURATION COMMUNICATION AREA'\n*        IHALCCA ,\n         IHALCCA ,\n.NOLCCA  ANOP  ,\n         AIF   (NOT &RCPLCCT(1) AND NOT &ALL OR &RCPLCCT(2)).NOLCCT\n&RCPLCCT(2) SETB 1\n         TITLE 'LCCA VECTOR TABLE'\n*        IHALCCAT ,\n         IHALCCAT ,\n.NOLCCT  ANOP  ,\n         AIF   (NOT &RCPPCCA(1) AND NOT &ALL OR &RCPPCCA(2)).NOPCCA\n&RCPPCCA(2) SETB 1\n         TITLE 'PHYSICAL CONFIGURATION COMMUNICATION AREA'\n*        IHAPCCA ,\n         IHAPCCA ,\n.NOPCCA  ANOP  ,\n         AIF   (NOT &RCPPCCB(1) AND NOT &ALL OR &RCPPCCB(2)).NOPCCB\n&RCPPCCB(2) SETB 1\n*        IEFPCCB ,\n         IEFPCCB ,\n.NOPCCB  ANOP  ,\n         AIF   (NOT &RCPPCCT(1) AND NOT &ALL OR &RCPPCCT(2)).NOPCCT\n&RCPPCCT(2) SETB 1\n         TITLE 'PCCA VECTOR TABLE'\n*        IHAPCCAT ,\n         IHAPCCAT ,\nPCCATEND EQU   *\n.NOPCCT  ANOP  ,\n         AIF   (NOT &RCPGDA(1) AND NOT &ALL OR &RCPGDA(2)).NOGDA\n&RCPGDA(2) SETB 1\n         TITLE 'VSM GLOBAL DATA AREA'\n*        IHAGDA ,\n         IHAGDA ,\n.NOGDA   ANOP  ,\n         AIF   (NOT &RCPLDA(1) AND NOT &ALL OR &RCPLDA(2)).NOLDA\n&RCPLDA(2) SETB 1\n         TITLE 'VSM LOCAL DATA AREA'\n*        IHALDA ,\n         IHALDA ,\n.NOLDA   ANOP  ,\n         AIF   (NOT &RCPCPAB(1) AND NOT &ALL OR &RCPCPAB(2)).NOCPAB\n&RCPCPAB(2) SETB 1\n         TITLE 'VSM CELL POOL ANCHOR BLOCK'\n*        IHACPAB ,\n         IHACPAB ,\n.NOCPAB  ANOP  ,\n         AIF   (NOT &RCPCVT(1) AND NOT &ALL OR &RCPCVT(2)).NOCVT\n&RCPCVT(2) SETB 1\n         TITLE 'COMMUNICATION VECTOR TABLE'\n*        CVT   LIST=YES,DSECT=YES,PREFIX=YES\n         CVT   LIST=YES,DSECT=YES,PREFIX=YES\nCVT      EQU   CVTMAP\n         IHAECVT LIST=YES,DSECT=YES\n.NOCVT   ANOP  ,\n         AIF   (NOT &RCPSCVT(1) AND NOT &ALL OR &RCPSCVT(2)).NOSCVT\n&RCPSCVT(2) SETB 1\n         TITLE 'SECONDARY COMMUNICATION VECTOR TABLE'\n*        IHASCVT LIST=YES\n         IHASCVT LIST=YES\n.NOSCVT  ANOP  ,\n         AIF   (NOT &RCPASCB(1) AND NOT &ALL OR &RCPASCB(2)).NOASCB\n&RCPASCB(2) SETB 1\n         TITLE 'ADDRESS SPACE CONTROL BLOCK'\n*        IHAASCB ,\n         IHAASCB ,\n.NOASCB  ANOP  ,\n         AIF   (NOT &RCPASSB(1) AND NOT &ALL OR &RCPASSB(2)).NOASSB\n&RCPASSB(2) SETB 1\n         TITLE 'ADDRESS SPACE SECONDARY BLOCK'\n*        IHAASSB LIST=YES\n         IHAASSB LIST=YES\n.NOASSB  ANOP  ,\n         AIF   (NOT &RCPASXB(1) AND NOT &ALL OR &RCPASXB(2)).NOASXB\n&RCPASXB(2) SETB 1\n         TITLE 'ADDRESS SPACE EXTENSION BLOCK'\n*        IHAASXB ,\n         IHAASXB ,\n.NOASXB  ANOP  ,\n         AIF   (NOT &RCPASVT(1) AND NOT &ALL OR &RCPASVT(2)).NOASVT\n&RCPASVT(2) SETB 1\n         TITLE 'ADDRESS SPACE VECTOR TABLE'\n*        IHAASVT ,\n         IHAASVT ,\n.NOASVT  ANOP  ,\n         AIF   (NOT &RCPSRB(1) AND NOT &ALL OR &RCPSRB(2)).NOSRB\n&RCPSRB(2) SETB 1\n         TITLE 'SERVICE REQUEST BLOCK'\n*        IHASRB ,\n         IHASRB ,\n.NOSRB   ANOP  ,\n         AIF   (NOT &RCPTCB(1) AND NOT &ALL OR &RCPTCB(2)).NOTCB\n&RCPTCB(2) SETB 1\n         TITLE 'TASK CONTROL BLOCK'\n*        IKJTCB LIST=YES\n         IKJTCB LIST=YES\n.NOTCB   ANOP  ,\n         AIF   (NOT &RCPOUCB(1) AND NOT &ALL OR &RCPOUCB(2)).NOOUCB\n&RCPOUCB(2) SETB 1\n         TITLE 'SRM USER CONTROL BLOCK'\n*        IRAOUCB ,\n         IRAOUCB ,\n.NOOUCB  ANOP  ,\n         AIF   (NOT &RCPOUXB(1) AND NOT &ALL OR &RCPOUXB(2)).NOOUXB\n&RCPOUXB(2) SETB 1\n         TITLE 'SRM USER EXTENSION BLOCK'\n*        IHAOUXB ,\n         IHAOUXB ,\n.NOOUXB  ANOP  ,\n         AIF   (NOT &RCPSIOT(1) AND NOT &ALL OR &RCPSIOT(2)).NOSIOT\n&RCPSIOT(2) SETB 1\n         TITLE 'STEP INPUT/OUTPUT TABLE'\nSIOT     DSECT ,\n*        IEFASIOT ,\n         IEFASIOT ,\nSIOTL    EQU   176\n.NOSIOT  ANOP  ,\n         AIF   (NOT &RCPSIOTX(1) AND NOT &ALL OR &RCPSIOTX(2)).NOSIOTX\n&RCPSIOTX(2) SETB 1\n         TITLE 'STEP INPUT/OUTPUT TABLE EXTENSION'\n*        IEFSIOTX ,\n         IEFSIOTX ,\nSIOTEXTL EQU   *-SIOTX\n.NOSIOTX ANOP  ,\n         AIF   (NOT &RCPTIOT(1) AND NOT &ALL OR &RCPTIOT(2)).NOTIOT\n&RCPTIOT(2) SETB 1\n         TITLE 'TASK INPUT OUTPUT TABLE'\nTIOT     DSECT ,\n*        IEFTIOT1 ,\n         IEFTIOT1 ,\n.NOTIOT  ANOP  ,\n         AIF   (NOT &RCPTCT(1) AND NOT &ALL OR &RCPTCT(2)).NOTCT\n&RCPTCT(2) SETB 1\n         TITLE 'TIMING CONTROL TABLE'\n*        IEFTCT ,\n         IEFTCT ,\n.NOTCT   ANOP  ,\n         AIF   (NOT &RCPLCT(1) AND NOT &ALL OR &RCPLCT(2)).NOLCT\n&RCPLCT(2) SETB 1\n         TITLE 'LINKAGE CONTROL TABLE'\nLCT      DSECT ,\n*        IEFALLCT ,\n         IEFALLCT ,\n.NOLCT   ANOP  ,\n         AIF   (NOT &RCPSCT(1) AND NOT &ALL OR &RCPSCT(2)).NOSCT\n&RCPSCT(2) SETB 1\n         TITLE 'STEP CONTROL TABLE'\nSCT      DSECT ,\n*        IEFASCTB ,\n         IEFASCTB ,\n.NOSCT   ANOP  ,\n         AIF   (NOT &RCPSCTX(1) AND NOT &ALL OR &RCPSCTX(2)).NOSCTX\n&RCPSCTX(2) SETB 1\n         TITLE 'STEP CONTROL TABLE EXTENSION'\nSCTX     DSECT ,\n*        IEFSCTX DSECT=NO\n         IEFSCTX DSECT=NO\n.NOSCTX  ANOP  ,\n         AIF   (NOT &RCPJCT(1) AND NOT &ALL OR &RCPJCT(2)).NOJCT\n&RCPJCT(2) SETB 1\n         TITLE 'JOB CONTROL TABLE'\nJCT      DSECT ,\n*        IEFAJCTB ,\n         IEFAJCTB ,\n.NOJCT   ANOP  ,\n         AIF   (NOT &RCPJCTX(1) AND NOT &ALL OR &RCPJCTX(2)).NOJCTX\n&RCPJCTX(2) SETB 1\n         TITLE 'JOB CONTROL TABLE EXTENSION'\nJCTX     DSECT ,\n*        IEFJCTX ,\n         IEFJCTX ,\n.NOJCTX  ANOP  ,\n         AIF   (NOT &RCPJMR(1) AND NOT &ALL OR &RCPJMR(2)).NOJMR\n&RCPJMR(2) SETB 1\n         TITLE 'JOB MANAGEMENT RECORD'\n*        IEFJMR ,\n         IEFJMR ,\nJMRCBLEN EQU    *-JMR\n.NOJMR   ANOP  ,\n         AIF   (NOT &RCPJSCB(1) AND NOT &ALL OR &RCPJSCB(2)).NOJSCB\n&RCPJSCB(2) SETB 1\n         TITLE 'JOB STEP CONTROL BLOCK'\n*        IEZJSCB ,\n         IEZJSCB ,\nJSCB     EQU   IEZJSCB\n.NOJSCB  ANOP  ,\n         AIF   (NOT &RCPATCH(1) AND NOT &ALL OR &RCPATCH(2)).NOATTCH\n&RCPATCH(2) SETB 1\n         TITLE 'ATTACH (SVC 42) PARAMETER LIST'\n*        IEZATTCH ,\n         IEZATTCH ,\n.NOATTCH ANOP  ,\n         AIF   (NOT &RCPSCB(1) AND NOT &ALL OR &RCPSCB(2)).NOSCB\n&RCPSCB(2) SETB 1\n         TITLE 'STAE CONTROL BLOCK'\n*        IHASCB ,\n         IHASCB ,\n.NOSCB   ANOP  ,\n         AIF   (NOT &RCPSMCA(1) AND NOT &ALL OR &RCPSMCA(2)).NOSMCA\n&RCPSMCA(2) SETB 1\n         TITLE 'SYSTEM MANAGEMENT FACILITIES CONTROL AREA (SMCA)'\n*        IEESMCA ,\n         IEESMCA ,\nSMCA     EQU   SMCABASE\n.NOSMCA  ANOP  ,\n         AIF   (NOT &RCPBASE(1) AND NOT &ALL OR &RCPBASE(2)).NOBASEA\n&RCPBASE(2) SETB 1\n         TITLE 'MASTER SCHEDULER RESIDENT DATA AREA (BASEA)'\n*        IEEBASEA ,\n         IEEBASEA ,\nBASEA    EQU   BASE\n.NOBASEA ANOP  ,\n         AIF   (NOT &RCPCSCB(1) AND NOT &ALL OR &RCPCSCB(2)).NOCSCB\n&RCPCSCB(2) SETB 1\n         TITLE 'COMMAND SCHEDULING CONTROL BLOCK'\nCSCB     DSECT ,\n*        IEECHAIN ,\n         IEECHAIN ,\n.NOCSCB  ANOP  ,\n         AIF   (NOT &RCPCIB(1) AND NOT &ALL OR &RCPCIB(2)).NOCIB\n&RCPCIB(2) SETB 1\n         TITLE 'COMMAND INPUT BUFFER'\nCIB      DSECT ,\n*        IEZCIB ,\n         IEZCIB ,\n.NOCIB   ANOP  ,\n         AIF   (NOT &RCPECB(1) AND NOT &ALL OR &RCPECB(2)).NOECB\n&RCPECB(2) SETB 1\n         TITLE 'EVENT CONTROL BLOCK'\n*        IHAECB ,\n         IHAECB ,\n.NOECB   ANOP  ,\n         AIF   (NOT &RCPACB(1) AND NOT &ALL OR &RCPACB(2)).NOACB\n&RCPACB(2) SETB 1\n         TITLE 'ACCESS METHOD CONTROL BLOCK (ACB)'\n*        IFGACB ,\n         IFGACB ,\nACB      EQU   IFGACB\n.NOACB   ANOP  ,\n         AIF   (NOT &RCPACEE(1) AND NOT &ALL OR &RCPACEE(2)).NOACEE\n&RCPACEE(2) SETB 1\n         TITLE 'ACCESSOR ENVIRONMENT ELEMENT (ACEE)'\n*        IHAACEE ,\n         IHAACEE ,\n.NOACEE  ANOP  ,\n         AIF   (NOT &RCPRPL(1) AND NOT &ALL OR &RCPRPL(2)).NORPL\n&RCPRPL(2) SETB 1\n         TITLE 'REQUEST PARAMETER LIST'\n*        IFGRPL ,\n         IFGRPL ,\nRPL      EQU   IFGRPL\n.NORPL   ANOP  ,\n         AIF   (NOT &RCPDACA(1) AND NOT &ALL OR &RCPDACA(2)).NODACA\n&RCPDACA(2) SETB 1\n         TITLE 'DEVICE ALLOCATION COMMUNICATION AREA'\n*        DACA  ,\n         DACA  ,\n.NODACA  ANOP  ,\n         AIF   (NOT &RCPDCB(1) AND NOT &ALL OR &RCPDCB(2)).NODCB\n&RCPDCB(2) SETB 1\n         TITLE 'DATA CONTROL BLOCK'\n*        DCBD  DSORG=(BX,DA,IS,PO,PS,XA,XE),DEVD=(BS,DA,RD,PC,PR,TA,WT)\n         DCBD  DSORG=(BX,DA,IS,PO,PS,XA,XE),DEVD=(BS,DA,RD,PC,PR,TA,WT)\nDCB      EQU   IHADCB\n.NODCB   ANOP  ,\n         AIF   (NOT &RCPDCBE(1) AND NOT &ALL OR &RCPDCBE(2)).NODCBE\n&RCPDCBE(2) SETB 1\n         TITLE 'DATA CONTROL BLOCK EXTENSION'\n*        IHADCBE ,\n         IHADCBE\n.NODCBE  ANOP  ,\n         AIF   (NOT &RCPDECB(1) AND NOT &ALL OR &RCPDECB(2)).NODECB\n&RCPDECB(2) SETB 1\n         TITLE 'DATA EVENT CONTROL BLOCK'\n*        IHADECB ,                      (SUPPLANTS IECTDECB)\n         IHADECB ,\nIECTDECB EQU   DECB                     (DSECT NAME USED BY BTAM)\n.NODECB  ANOP  ,\n         AIF   (NOT &RCPJFCB(1) AND NOT &ALL OR &RCPJFCB(2)).NOJFCB\n&RCPJFCB(2) SETB 1\n         TITLE 'JOB FILE CONTROL BLOCK'\nJFCB     DSECT ,\n*        IEFJFCBN LIST=YES\n         IEFJFCBN LIST=YES\n.NOJFCB  ANOP  ,\n         AIF   (NOT &RCPJFCX(1) AND NOT &ALL OR &RCPJFCX(2)).NOJFCBX\n&RCPJFCX(2) SETB 1\n         TITLE 'JOB FILE CONTROL BLOCK EXTENSION'\nJFCBX    DSECT ,\n*        IEFJFCBX ,\n         IEFJFCBX ,\nJFCBXLEN EQU   *-JFCBX\n         EJECT ,\n*        IEFJFCBE ,\n         IEFJFCBE ,\n.NOJFCBX ANOP  ,\n         AIF   (NOT &RCPDEB(1) AND NOT &ALL OR &RCPDEB(2)).NODEB\n&RCPDEB(2) SETB 1\n         TITLE 'DATA EXTENT BLOCK'\n*        IEZDEB LIST=YES\n         IEZDEB LIST=YES\nIECTDEB  EQU   DEB                      (DSECT NAME USED BY BTAM)\n.*DEBSYSPG EQU   DEPOPATB+1,3,C'A'        (FROM IECTDEB MAPPING)\n.NODEB   ANOP  ,\n         AIF   (NOT &RCPGEPL(1) AND NOT &ALL OR &RCPGEPL(2)).NOGEPL\n&RCPGEPL(2) SETB 1\n         TITLE 'GROUP EXIT PARAMETER LIST (GEPL)'\n*        IXCYGEPL ,\n         IXCYGEPL ,\n.NOGEPL  ANOP  ,\n         AIF   (NOT &RCPMEPL(1) AND NOT &ALL OR &RCPMEPL(2)).NOMEPL\n&RCPMEPL(2) SETB 1\n         TITLE 'MESSAGE EXIT PARAMETER LIST (MEPL)'\n*        IXCYMEPL ,\n         IXCYMEPL ,\n.NOMEPL  ANOP  ,\n         AIF   (NOT &RCPMNPL(1) AND NOT &ALL OR &RCPMNPL(2)).NOMNPL\n&RCPMNPL(2) SETB 1\n         TITLE 'MESSAGE NOTIFY EXIT PARAMETER LIST (MNPL)'\n*        IXCYMNPL ,\n         IXCYMNPL ,\n.NOMNPL  ANOP  ,\n         AIF   (NOT &RCPMQAA(1) AND NOT &ALL OR &RCPMQAA(2)).NOMQAA\n&RCPMQAA(2) SETB 1\n         TITLE 'MESSAGE CONTROL QUERY ANSWER AREA (MQAA)'\n*        IXCYMQAA ,\n         IXCYMQAA ,\n.NOMQAA  ANOP  ,\n         AIF   (NOT &RCPQUAA(1) AND NOT &ALL OR &RCPQUAA(2)).NOQUAA\n&RCPQUAA(2) SETB 1\n         TITLE 'QUERY ANSWER AREA (QUAA)'\n*        IXCYQUAA ,\n         IXCYQUAA ,\n.NOQUAA  ANOP  ,\n         AIF   (NOT &RCPSEPL(1) AND NOT &ALL OR &RCPSEPL(2)).NOSEPL\n&RCPSEPL(2) SETB 1\n         TITLE 'STATUS EXIT PARAMETER LIST (SEPL)'\n*        IXCYSEPL ,\n         IXCYSEPL ,\n.NOSEPL  ANOP  ,\n         AIF   (NOT &RCPIOB(1) AND NOT &ALL OR &RCPIOB(2)).NOIOB\n&RCPIOB(2) SETB 1\n         TITLE 'INPUT OUTPUT BLOCK'\n*        IEZIOB ,\n         IEZIOB ,\nIECTIOB  EQU   IOBSTDRD                 (DSECT NAME USED BY BTAM)\n.NOIOB   ANOP  ,\n         AIF   (NOT &RCPIOBE(1) AND NOT &ALL OR &RCPIOBE(2)).NOIOBE\n&RCPIOBE(2) SETB 1\n         TITLE 'INPUT OUTPUT BLOCK EXTENSION'\n*        IOSDIOBE ,\n         IOSDIOBE ,\n.NOIOBE  ANOP  ,\n         AIF   (NOT &RCPIOSB(1) AND NOT &ALL OR &RCPIOSB(2)).NOIOSB\n&RCPIOSB(2) SETB 1\n         TITLE 'I/O SUPERVISOR BLOCK (IOSB)'\n*        IECDIOSB ,\n         IECDIOSB ,\n.NOIOSB  ANOP  ,\n         AIF   (NOT &RCPIPA(1) AND NOT &ALL OR &RCPIPA(2)).NOIPA\n&RCPIPA(2) SETB 1\n         TITLE 'INITIALIZATION PARAMETER AREA (IPA)'\n*        IHAIPA DSECT=YES\n         IHAIPA DSECT=YES\n.NOIPA   ANOP  ,\n         AIF   (NOT &RCPIPIB(1) AND NOT &ALL OR &RCPIPIB(2)).NOIPIB\n&RCPIPIB(2) SETB 1\n         TITLE 'I/O SUPERVISOR PURGE INTERFACE BLOCK (IPIB)'\n*        IECDIPIB ,\n         IECDIPIB ,\n.NOIPIB  ANOP  ,\n         AIF   (NOT &RCPATB(1) AND NOT &ALL OR &RCPATB(2)).NOATB\n&RCPATB(2) SETB 1\n         TITLE 'IOS ATTENTION TABLE'\n*        IECDATB\n         IECDATB ,\n.NOATB   ANOP  ,\n         AIF   (NOT &RCPUCBG(1) AND NOT &ALL OR &RCPUCBG(2)).NOUCBG\n&RCPUCBG(2) SETB 1\n         TITLE 'IOS COMMUNICATIONS AREA'\n*        IECDIOCM\n         IECDIOCM ,\n.NOUCBG  ANOP  ,\n         AIF   (NOT &RCPUCB(1) AND NOT &ALL OR &RCPUCB(2)).NOUCB\n&RCPUCB(2) SETB 1\n         TITLE 'UNIT CONTROL BLOCK'\n*        IEFUCBOB LIST=YES,PREFIX=YES\n         IEFUCBOB LIST=YES,PREFIX=YES\n.NOUCB   ANOP  ,\n         AIF   (NOT &RCPUCBCX(1) AND NOT &ALL OR &RCPUCBCX(2)).NOUCBCX\n&RCPUCBCX(2) SETB 1\n         TITLE 'UCB TAPE CLASS EXTENSION'\n*        IECUCBCX ,\n         IECUCBCX ,\n.NOUCBCX ANOP  ,\n         AIF   (NOT &RCPUCM(1) AND NOT &ALL OR &RCPUCM(2)).NOUCM\n&RCPUCM(2) SETB 1\n         TITLE 'UNIT CONTROL MODULE'\n*        IEECUCM FORMAT=NEW,LIST=YES\n         IEECUCM FORMAT=NEW,LIST=YES\n.NOUCM   ANOP  ,\n         AIF   (NOT &RCPWPL(1) AND NOT &ALL OR &RCPWPL(2)).NOWPL\n&RCPWPL(2) SETB 1\n         TITLE 'WRITE TO OPERATOR PARAMETER LIST'\n*        IEZWPL\n         IEZWPL ,\nWPLRFLEN EQU   *-WPLRF\n.NOWPL   ANOP  ,\n         AIF   (NOT &RCPWQE(1) AND NOT &ALL OR &RCPWQE(2)).NOWQE\n&RCPWQE(2) SETB 1\n         TITLE 'WRITE TO OPERATOR QUEUE ELEMENT'\n*        IHAWQE\n         IHAWQE ,\n.NOWQE   ANOP  ,\n         AIF   (NOT &RCPRQE(1) AND NOT &ALL OR &RCPRQE(2)).NORQE\n&RCPRQE(2) SETB 1\n         TITLE 'REQUEST QUEUE ELEMENT'\n*        IECDRQE ,\n         IECDRQE ,\n.NORQE   ANOP  ,\n         AIF   (NOT &RCPDSCB(1) AND NOT &ALL OR &RCPDSCB(2)).NODSCB\n&RCPDSCB(2) SETB 1\n         TITLE 'DATA SET CONTROL BLOCK - FORMAT 1'\nDSCB     DSECT ,\n         IECSDSL1 1\n         TITLE 'DATA SET CONTROL BLOCK - FORMAT 2'\n         ORG   DSCB\n         IECSDSL1 2\n         TITLE 'DATA SET CONTROL BLOCK - FORMAT 3'\n         ORG   DSCB\n         IECSDSL1 3\n         TITLE 'DATA SET CONTROL BLOCK - FORMAT 4'\n         ORG   DSCB\n         DS    XL44                     KEY\n         IECSDSL1 4\n         TITLE 'DATA SET CONTROL BLOCK - FORMAT 5'\n         ORG   DSCB\n         IECSDSL1 5\n         TITLE 'DATA SET CONTROL BLOCK - FORMAT 6'\n         ORG   DSCB\n         IECSDSL1 6\n.NODSCB  ANOP  ,\n         AIF   (NOT &RCPDSNT(1) AND NOT &ALL OR &RCPDSNT(2)).NODSNT\n&RCPDSNT(2) SETB 1\n         TITLE 'DATA SET NAME TABLE'\nDSNT     DSECT ,\n*        IEFDSNT ,\n         IEFDSNT ,\n.NODSNT  ANOP  ,\n         AIF   (NOT &RCPDSAB(1) AND NOT &ALL OR &RCPDSAB(2)).NODSAB\n&RCPDSAB(2) SETB 1\n         TITLE 'DSAB QUEUE DESCRIPTOR BLOCK'\n*        IEFZB4D5 ,\n         IEFZB4D5 ,\n         TITLE 'DATA SET ASSOCIATION BLOCK'\n*        IHADSAB ,\n         IHADSAB ,\n.NODSAB  ANOP  ,\n         AIF   (NOT &RCPRB(1) AND NOT &ALL OR &RCPRB(2)).NORB\n&RCPRB(2) SETB 1\n         TITLE 'REQUEST BLOCK'\n*        IHARB ,\n         IHARB LIST=&LIST\n.NORB    ANOP  ,\n  AIF   (NOT &RCPXSB(1) AND NOT &ALL OR &RCPXSB(2)).NOXSB\n&RCPXSB(2) SETB 1\n         TITLE 'EXTENDED STATUS BLOCK'\n*        IHAXSB ,\n         IHAXSB LIST=&LIST\n.NOXSB   ANOP  ,\n         AIF   (NOT &RCPIQE(1) AND NOT &ALL OR &RCPIQE(2)).NOIQE\n&RCPIQE(2) SETB 1\n         TITLE 'INTERRUPTION QUEUE ELEMENT'\n*        IHAIQE ,\n         IHAIQE ,\nIQE      EQU   IQESECT\n.NOIQE   ANOP  ,\n         AIF   (NOT &RCPCDE(1) AND NOT &ALL OR &RCPCDE(2)).NOCDE\n&RCPCDE(2) SETB 1\n         TITLE 'CONTENTS DIRECTORY ENTRY'\n*        IHACDE ,\n         IHACDE ,\n.NOCDE   ANOP  ,\n         AIF   (NOT &RCPLPDE(1) AND NOT &ALL OR &RCPLPDE(2)).NOLPDE\n&RCPLPDE(2) SETB 1\n         TITLE 'LINK PACK DIRECTORY ENTRY'\n*        IHALPDE ,\n         IHALPDE ,\n.NOLPDE  ANOP  ,\n         AIF   (NOT &RCPLWA(1) AND NOT &ALL OR &RCPLWA(2)).NOLWA\n&RCPLWA(2) SETB 1\n         TITLE 'LOGON WORK AREA'\n*        IKJEFLWA ,\n         IKJEFLWA ,\n.NOLWA   ANOP  ,\n         AIF   (NOT &RCPLLE(1) AND NOT &ALL OR &RCPLLE(2)).NOLLE\n&RCPLLE(2) SETB 1\n         TITLE 'LOAD LIST ELEMENT'\n*        IHALLE ,\n         IHALLE ,\n.NOLLE   ANOP  ,\n         AIF   (NOT &RCPXL(1) AND NOT &ALL OR &RCPXL(2)).NOXL\n&RCPXL(2) SETB 1\n         TITLE 'EXTENT LIST'\n*        IHAXTLST ,\n         IHAXTLST ,\n.NOXL    ANOP  ,\n         AIF   (NOT &RCPQCB(1) AND NOT &ALL OR &RCPQCB(2)).NOQCB\n&RCPQCB(2) SETB 1\n         TITLE 'GRS QUEUE CONTROL BLOCK'\n*        ISGQCB ,\n         ISGQCB ,\n.NOQCB   ANOP  ,\n         AIF   (NOT &RCPQDB(1) AND NOT &ALL OR &RCPQDB(2)).NOQDB\n&RCPQDB(2) SETB 1\n         TITLE 'QUEUE DESCRIPTOR BLOCK'\n*        IHAQDB DSECT=YES\n         IHAQDB DSECT=YES\n.NOQDB   ANOP  ,\n         AIF   (NOT &RCPQEL(1) AND NOT &ALL OR &RCPQEL(2)).NOQEL\n&RCPQEL(2) SETB 1\n         TITLE 'GRS QUEUE ELEMENT'\n*        ISGQEL ,\n         ISGQEL ,\n.NOQEL   ANOP  ,\n         AIF   (NOT &RCPPSCB(1) AND NOT &ALL OR &RCPPSCB(2)).NOPSCB\n&RCPPSCB(2) SETB 1\n         TITLE 'PROTECTED STEP CONTROL BLOCK'\n*        IKJPSCB ,\n         IKJPSCB ,\n.NOPSCB  ANOP  ,\n         AIF   (NOT &RCPECT(1) AND NOT &ALL OR &RCPECT(2)).NOECT\n&RCPECT(2) SETB 1\n         TITLE 'ENVIRONMENT CONTROL TABLE'\n*        IKJECT ,\n         IKJECT ,\nECTLEN   EQU   *-ECT\n.NOECT   ANOP  ,\n         AIF   (NOT &RCPUPT(1) AND NOT &ALL OR &RCPUPT(2)).NOUPT\n&RCPUPT(2) SETB 1\n         TITLE 'USER PROFILE TABLE'\n*        IKJUPT ,\n         IKJUPT ,\nUPTLNGTH EQU   *-UPT\n.NOUPT   ANOP  ,\n         AIF   (NOT &RCPSDWA(1) AND NOT &ALL OR &RCPSDWA(2)).NOSDWA\n&RCPSDWA(2) SETB 1\n         TITLE 'SYSTEM DIAGNOSTIC WORK AREA'\n*        IHASDWA ,\n         IHASDWA ,\n.NOSDWA  ANOP  ,\n         AIF   (NOT &RCPFRRS(1) AND NOT &ALL OR &RCPFRRS(2)).NOFRRS\n&RCPFRRS(2) SETB 1\n         TITLE 'FUNCTION RECOVERY ROUTINE (FRR) STACK'\n*        IHAFRRS ,\n         IHAFRRS ,\n.NOFRRS  ANOP  ,\n         AIF   (NOT &RCPWSVT(1) AND NOT &ALL OR &RCPWSVT(2)).NOWSAVT\n&RCPWSVT(2) SETB 1\n         TITLE 'GLOBAL WORK/SAVE AREA VECTOR TABLE'\n*        IHAWSAVT CLASS=GLOBAL\n         IHAWSAVT CLASS=GLOBAL\n         TITLE 'LOCAL WORK/SAVE AREA VECTOR TABLE'\n*        IHAWSAVT CLASS=LOCAL\n         IHAWSAVT CLASS=LOCAL\n         TITLE 'CPU WORK/SAVE AREA VECTOR TABLE'\n*        IHAWSAVT CLASS=CPU\n         IHAWSAVT CLASS=CPU\n.NOWSAVT ANOP  ,\n         AIF   (NOT &RCPTSB(1) AND NOT &ALL OR &RCPTSB(2)).NOTSB\n&RCPTSB(2) SETB 1\n         TITLE 'TERMINAL STATUS BLOCK AND EXTENSION'\n*        IKJTSB LIST=YES,EXT=YES\n         IKJTSB LIST=YES,EXT=YES\n.NOTSB   ANOP  ,\n         AIF   (NOT &RCPCPPL(1) AND NOT &ALL OR &RCPCPPL(2)).NOCPPL\n&RCPCPPL(2) SETB 1\n         TITLE 'COMMAND PROCESSOR PARAMETER LIST'\n*        IKJCPPL ,\n         IKJCPPL ,\n.NOCPPL  ANOP  ,\n         AIF   (NOT &RCPPPL(1) AND NOT &ALL OR &RCPPPL(2)).NOPPL\n&RCPPPL(2) SETB 1\n         TITLE 'TSO PARSE PARAMETER LIST'\n*        IKJPPL ,\n         IKJPPL ,\nPPLLEN   EQU   *-PPL\n.NOPPL   ANOP  ,\n         AIF   (NOT &RCPCSPL(1) AND NOT &ALL OR &RCPCSPL(2)).NOCSPL\n&RCPCSPL(2) SETB 1\n         TITLE 'TSO COMMAND SCAN PARAMETER LIST && OUTPUT AREA'\n*        IKJCSPL ,\n         IKJCSPL ,\nCSPLLEN  EQU   *-CSPL\n         SPACE 2\n*        IKJCSOA ,\n         IKJCSOA ,\nCSOALEN  EQU   *-CSOA\n.NOCSPL  ANOP  ,\n         AIF   (NOT &RCPIOPL(1) AND NOT &ALL OR &RCPIOPL(2)).NOIOPL\n&RCPIOPL(2) SETB 1\n         TITLE 'TSO INPUT/OUTPUT PARAMETER LIST'\n*        IKJIOPL ,\n         IKJIOPL ,\nIOPLLEN  EQU   *-IOPL\n.NOIOPL  ANOP  ,\n         AIF   (NOT &RCPALLC(1) AND NOT &ALL OR &RCPALLC(2)).NOALLOC\n&RCPALLC(2) SETB 1\n         TITLE 'DYNAMIC ALLOCATION PARAMETER LIST'\n*        IEFZB4D0 ,\n         IEFZB4D0 ,\n         TITLE 'DYNAMIC ALLOCATION TEXT UNIT KEYS'\n*        IEFZB4D2 ,\n         IEFZB4D2 ,\n         TITLE 'DAIRFAIL PARAMETER LIST'\n.*       IKJEFFDF DFDSECT=YES,DFDSEC2=YES\n         IKJEFFDF DFDSECT=YES,DFDSEC2=YES\n.NOALLOC ANOP  ,\n         AIF   (NOT &RCPCTLG(1) AND NOT &ALL OR &RCPCTLG(2)).NOCTLG\n&RCPCTLG(2) SETB 1\n         TITLE 'ACCESS METHOD DATA STATISTICS BLOCK'\n*        IDAAMDSB ,\n         IDAAMDSB ,\n         TITLE 'CATALOG AUXILIARY WORK AREA'\n*        IGGCAXWA ,\n         IGGCAXWA ,\nCAXLEN   EQU   *-IGGCAXWA\n         TITLE 'CATALOG COMMUNICATION AREA'\n*        IGGCCA ,\n         IGGCCA ,\n         TITLE 'CATALOG COMMUNICATION AREA EXTENSION'\n*        IGGCCX ,\n         IGGCCX ,\n         TITLE 'CATALOG INTEGRITY CONTROL BLOCK'\n*        CICB  ,\n         CICB  ,\n         TITLE 'CATALOG CONTROL VOLUME LIST'\n*        IEZCTGCV ,\n         IEZCTGCV ,\n         TITLE 'CATALOG CAMLST PARAMETER LIST'\n*        IEZCAML ,\n         IEZCAML ,\n         TITLE 'CATALOG FIELD PARAMETER LIST'\n*        IEZCTGFL ,\n         IEZCTGFL ,\n         TITLE 'CATALOG FIELD VECTOR TABLE'\n*        IEZCTGFV ,\n         IEZCTGFV ,\n         TITLE 'CATALOG PARAMETER LIST'\n*        IEZCTGPL ,\nIEZCTGPL DSECT ,\n         IEZCTGPL\n         TITLE 'CATALOG VOLUME LIST'\n*        IEZCTGVL ,\n         IEZCTGVL ,\n         TITLE 'CATALOG WORK AREA'\n*        IEZCTGWA ,\n         IEZCTGWA ,\n         TITLE 'CATALOG MANAGEMENT RETURN CODES'\n*        COPY  #CATRC\n         COPY  #CATRC\n.NOCTLG  ANOP  ,\n         AIF   (NOT &RCPCVAF(1) AND NOT &ALL OR &RCPCVAF(2)).NOCVAF\n&RCPCVAF(2) SETB 1\n         TITLE 'CVAF PARAMETER LIST'\n*        ICVAFPL ,\n         ICVAFPL ,\n         TITLE 'CVAF BUFFER LIST'\n*        ICVAFBFL ,\n         ICVAFBFL ,\n.NOCVAF  ANOP  ,\n         AIF   (NOT &RCPEDT(1) AND NOT &ALL OR &RCPEDT(2)).NOEDT\n&RCPEDT(2) SETB 1\n         TITLE 'ELIGIBLE DEVICES TABLE AND UCB POINTER LIST'\n*        IEFZB421 ,\n         IEFZB421 ,\n         SPACE 3\n*        IEFZB461 ,\n         IEFZB461 ,\n.NOEDT   ANOP  ,\n         AIF   (NOT &RCPZ4UV(1) AND NOT &ALL OR &RCPZ4UV(2)).NOZ4UV\n&RCPZ4UV(2) SETB 1\n         TITLE 'IEFAB4UV/IEFEB4UV PARAMETER LIST'\n*        IEFZB4UV ,\n         IEFZB4UV ,\n.NOZ4UV  ANOP  ,\n         AIF   (NOT &RCPZ502(1) AND NOT &ALL OR &RCPZ502(2)).NOZ502\n&RCPZ502(2) SETB 1\n         TITLE 'SWA BLOCK HEADER'\n*        IEFZB502 ,\n         IEFZB502 ,\nSWPSIZE  EQU   *-ZB502\n.NOZ502  ANOP  ,\n         AIF   (NOT &RCPZ505(1) AND NOT &ALL OR &RCPZ505(2)).NOZ505\n&RCPZ505(2) SETB 1\n         TITLE 'SWA MANAGER EXTERNAL PARAMETER AREA - LOCATE MODE'\n*        IEFZB505 ,\n         IEFZB505 ,\nZB505L   EQU   *-ZB505\n.NOZ505  ANOP  ,\n         AIF   (NOT &RCPZ506(1) AND NOT &ALL OR &RCPZ506(2)).NOZ506\n&RCPZ506(2) SETB 1\n         TITLE 'SWA MANAGER EXTERNAL PARAMETER AREA - MOVE MODE'\n*        IEFZB506 ,\n         IEFZB506 ,\n.NOZ506  ANOP  ,\n         AIF   (NOT &RCPQMPA(1) AND NOT &ALL OR &RCPQMPA(2)).NOQMPA\n&RCPQMPA(2) SETB 1\n         TITLE 'QUEUE MANAGER PARAMETER AREQ (QMPA)'\n*        IEFQMNGR ,\n         IEFQMNGR ,\n.NOQMPA  ANOP  ,\n         AIF   (NOT &RCPJES(1) AND NOT &ALL OR &RCPJES(2)).NOJES\n&RCPJES(2) SETB 1\n         TITLE 'JES CONTROL TABLE'\n*        IEFJESCT ,\n         IEFJESCT ,\n.NOJES   ANOP  ,\n         AIF   (NOT &RCPSSS(1) AND NOT &ALL OR &RCPSSS(2)).NOSSS\n&RCPSSS(2) SETB 1\n         TITLE 'SUBSYSTEM COMMUNICATIONS VECTOR TABLE'\n*        IEFJSCVT ,\n         IEFJSCVT ,\n         TITLE 'SUBSYSTEM VECTOR TABLE'\n*        IEFJSSVT ,\n         IEFJSSVT ,\n         TITLE 'SUBSYSTEM IDENTIFICATION BLOCK'\n*        IEFJSSIB ,\n         IEFJSSIB ,\n         TITLE 'SUBSYSTEM OPTIONS BLOCK'\n*        IEFJSSOB (SO,CS,JS,AL,EN,ET,WT,CM,US,JT,RQ,DM,VS,DA,RR,CF,\n*              SI,CI,AG)\n         IEFJSSOB (SO,CS,JS,AL,EN,ET,WT,CM,US,JT,RQ,DM,VS,DA,RR,CF,    X\n               SI,CI,AG)\n.NOSSS   ANOP  ,\n         AIF   (NOT &RCPRCVT(1) AND NOT &ALL OR &RCPRCVT(2)).NORCVT\n&RCPRCVT(2) SETB 1\n         TITLE 'RACF COMMUNICATIONS VECTOR TABLE'\n*        ICHPRCVT ,\n         ICHPRCVT ,\n.***NOTE: THE FOLLOWING STATEMENTS CAN BE REMOVED ONCE OUR\n.***      ASSEMBLY BASE IS Z/OS 1.5 OR HIGHER\n         AIF   (D'RCVTML2F).RCVT15   SKIP IF Z/OS 1.5 MACLIB\nRCVTML2F EQU   RCVTSINT+L'RCVTSINT,1 DEFINE 1.5 LEVEL FIELD\nRCVTSBYS EQU   X'10'                 DEFINE 1.5 LEVEL FLAG\n.RCVT15  ANOP  ,\n.NORCVT  ANOP  ,\n         AIF   (NOT &RCPLPDAT(1) AND NOT &ALL OR &RCPLPDAT(2)).NOLPDAT\n&RCPLPDAT(2) SETB 1\n         TITLE 'SYSEVENT LPAR CAPACITY DATA PARAMETER LIST'\n*        IRALPDAT\n         IRALPDAT TITLE=NO,LIST=&LIST\n         AIF   (D'LPDATIMGMSULIMIT).LPDAT80 SKIP IF 1.11 MACLIB\nLPDATIMGMSULIMIT EQU LPDATRESERVED,4,C'F' DEFINE 1.11 FIELD\nLPDATSERVICEUNUSEDGROUPCAPACITY EQU LPDATSERVICECAPPEDTIME+4,4,C'F'\n.LPDAT80 ANOP  ,\n         GBLC  &IRALPDAT_INCLUDED    IBM GLOBAL\n&IRALPDAT_INCLUDED SETC 'YES'        SET IBM GLOBAL\n.NOLPDAT ANOP  ,\n         AIF   (NOT &RCPRMCT(1) AND NOT &ALL OR &RCPRMCT(2)).NORMCT\n&RCPRMCT(2) SETB 1\n         TITLE 'SYSTEM RESOURCES MANAGER CONTROL TABLE (RMCT)'\n*        IRARMCT\n         IRARMCT ,\n         AIF   (D'RMCTX3).RMCT30     Skip if RMCTZ ptr defined\nRMCTX3   EQU   RMCTR01,4,C'F'  Define ptr to RMCTZ\n.RMCT30  ANOP  ,\n.NORMCT  ANOP  ,\n         AIF   (NOT &RCPRMCTZ(1) AND NOT &ALL OR &RCPRMCTZ(2)).NORMCTZ\n&RCPRMCTZ(2) SETB 1\n         TITLE 'RMCT EXTENSION 3 (RMCTZ)'\n*        IRARMCTZ\n         IRARMCTZ ,\n.NORMCTZ ANOP  ,\n         AIF   (NOT &RCPDSERV(1) AND NOT &ALL OR &RCPDSERV(2)).NODSERV\n&RCPDSERV(2) SETB 1\n         TITLE 'IAZDSERV'\n*        IAZDSERV\n         IAZDSERV ,\n         AIF   (D'DSRVSZE8).DSRV8\nDSRVSVR8 EQU   8                   Service version number of\n*                                  IAZDSERV - z/OS 2.1\n         ORG   DSERV+X'88'\nDSRVCATC DS    A                   Pointer to CAT/GRPOBJ cache\n*                                  if NOT a live version and\n*                                  cache is requested.\nDSRVSZE8 EQU   *-DSERV             DSERV Version 8 fixed\n*                                  parameter length\n.DSRV8   ANOP  ,\n.NODSERV ANOP  ,\n         TITLE ' '\n&ZPRINT  SETC  '&SAVEZ'        RESTORE IBM PRINT CONTROL\n&ZCBPRINT SETC '&SAVEZCB'      RESTORE OTHER IBM PRINT CONTROL\n         AIF   (&PRT).DSE0500\n         POP   PRINT\n.DSE0500 MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#ENVIRON": {"ttr": 3076, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x12\\x06/\\x01\\x12\\x06/\"\"\\x00-\\x00-\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-03-02T00:00:00", "modifydate": "2012-03-02T22:22:03", "lines": 45, "newlines": 45, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&L       #ENVIRON &TSO=,&BATCH=,&STC=,&SCR=15\n         LCLC  &X                   SYSNDX\n&X       SETC  '&SYSNDX'\n&L       L     &SCR,548             GET @ ASCB\n         AIF   ('&BATCH' NE '' OR '&STC' NE '').ENV0100   TSO\n         CLC   60(4,&SCR),=F'0'     TSB POINTER ZERO?\n         BNE   &TSO                 NO, TAKE TSO EXIT\n         MEXIT\n.ENV0100 AIF   ('&TSO' NE '' OR '&STC' NE '').ENV0200   BATCH\n         CLC   172(4,&SCR),=F'0'    JOBNAME POINTER ZERO?\n         BNE   &BATCH               NO, TAKE BATCH EXIT\n         MEXIT\n.ENV0200 AIF   ('&TSO' NE '' OR '&BATCH' NE '').ENV0300   STC\n         CLC   60(4,&SCR),=F'0'     TSB POINTER ZERO?\n         BNE   ENV&X.1              YES, GIVE UP\n         CLC   172(4,&SCR),=F'0'    NO, JOBNAME POINTER ZERO?\n         BE    &STC                 YES, TAKE STC EXIT\nENV&X.1  DS    0H\n         MEXIT\n.ENV0300 AIF   ('&STC' NE '').ENV0400   TSO AND BATCH\n         CLC   60(4,&SCR),=F'0'     TSB POINTER ZERO?\n         BNE   &TSO                 NO, TAKE TSO EXIT\n         CLC   172(4,&SCR),=F'0'    YES, JOBNAME POINTER ZERO?\n         BNE   &BATCH               NO, TAKE BATCH EXIT\n         MEXIT\n.ENV0400 AIF   ('&BATCH' NE '').ENV0500   TSO AND STC\n         CLC   60(4,&SCR),=F'0'     TSB POINTER ZERO?\n         BNE   &TSO                 NO, TAKE TSO EXIT\n         CLC   172(4,&SCR),=F'0'    YES, JOBNAME POINTER ZERO?\n         BE    &STC                 YES, TAKE STC EXIT\n         MEXIT\n.ENV0500 AIF   ('&TSO' NE '').ENV0600   BATCH AND STC\n         CLC   172(4,&SCR),=F'0'    JOBNAME POINTER ZERO?\n         BNE   &BATCH               YES, TAKE BATCH EXIT\n         CLC   60(4,&SCR),=F'0'     NO, TSB POINTER ZERO?\n         BE    &STC                 YES, TAKE STC EXIT\n         MEXIT\n.ENV0600 ANOP                       TSO, BATCH AND STC\n         CLC   60(4,&SCR),=F'0'     TSB POINTER ZERO ?\n         BNE   &TSO                 NO, TAKE TSO EXIT\n         CLC   172(4,&SCR),=F'0'    YES, JOBNAME POINTER ZERO?\n         BNE   &BATCH               NO, TAKE BATCH EXIT\n         B     &STC                 YES, TAKE STC EXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#EXEC": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00\\x87\\x00\\x87\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 135, "newlines": 135, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    #EXEC &REG,&INST,&D,&S,&X\n         GBLA  &EXECUTN            CURRENT EXECUTE NUMBER\n         GBLA  &EXECUTL            CURRENT EXECUTE STATEMENT NUMBER\n         GBLC  &EXECUTI(255)       INSTRUCTION CODE\n         GBLC  &EXECUTD(255)       DESTINATION\n         GBLC  &EXECUTS(255)       SOURCE\n         GBLC  &EXECNAM            EXECUTE INSTRUCTION NAME\n         LCLA  &I,&J               WORK COUNTERS\n         LCLB  &MINUS              \"-RX\" SPECIFIED\n         LCLC  &INS,&OP1,&OP2      CURRENT INSTRUCTION & OPERANDS\n         LCLC  &RRR                CURRENT REGISTER VALUE\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.* THIS MACRO ENABLES A PROGRAMMER TO EXECUTE AN INSTRUCTION          *\n.* WITHOUT THE NECESSITY FOR REMEMBERING TO CODE THE INSTRUCTIONS     *\n.* LATER ON IN THE PROGRAM.  FOR INSTANCE, IF A MVC INSTRUCTION IS    *\n.* TO BE EXECUTED, WITH THE THE MACHINE LENGTH OF THE DESTINATION     *\n.* WITHIN REGISTER 4, THE FOLLOWING SHOULD BE CODED.                  *\n.*           LABEL    #EXEC R4,MVC,TARGET,SOURCE                      *\n.* IF THE ACTUAL TARGET FIELD LENGTH IS LOCATED IN REGISTER 4, THE    *\n.* FOLLOWING INSTRUCTION WILL CONVERT THE LENGTH TO THE MACHINE       *\n.* LENGTH THEN EXECUTE THE INSTRUCTION.                               *\n.*           LABEL    #EXEC -R4,MVC,TARGET,SOURCE                     *\n.*                                                                    *\n.* ONLY TWO OPERAND INSTRUCTIONS ARE SUPPORTED.                       *\n.* THE MACRO ACCUMULATES ALL UNIQUE INSTRUCTIONS ENTERED, IGNORING    *\n.* ANY DUPLICATES.                                                    *\n.* WHEN #EXEC IS CODED WITH NO OPERANDS, IT EXPANDS INTO THE          *\n.* NECESSARY INSTRUCTIONS.  EACH INSTRUCTION HAS A UNIQUE NAME IN     *\n.* THE FORM @EXEC###, WHERE ### IS A NUMBER FROM 1-255.               *\n.* THE EXPANSION PROCESS IS SIMILAR TO THAT OF AN LTORG STATEMENT     *\n.* FOR LITERALS.  SEVERAL EXECUTE POOLS CAN BE CREATED, IN A SIMILAR  *\n.* FASHION TO LITERAL POOLS.                                          *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n         AIF   (N'&SYSLIST EQ 0).EXPAND\n         AIF   ('&INST' EQ '').EXPAND\n.*       AIF   (N'&SYSLIST NE 4).ERROR2\n.*\n&RRR     SETC  '&REG'              SET REGISTER VALUE\n&OP1     SETC  '&D'                SET FIRST OPERAND\n&OP2     SETC  '&S'                SET SECOND OPERAND\n.*\n         AIF   (N'&SYSLIST GT 4).CHECK3\n         AIF   ('&INST' EQ 'MVC' OR '&INST' EQ 'CLC').SS1\n         AIF   ('&INST' EQ 'TR' OR '&INST' EQ 'TRT').SS1\n         AIF   ('&INST' EQ 'MVZ' OR '&INST' EQ 'MVN').SS1\n         AIF   ('&INST' EQ 'OC' OR '&INST' EQ 'NC').SS1\n         AIF   ('&INST' EQ 'XC' OR '&INST' EQ 'ED').SS1\n         AIF   ('&INST' EQ 'MVCIN' OR '&INST' EQ 'EDMK').SS1\n.*\n         AIF   ('&INST' EQ 'PACK' OR '&INST' EQ 'UNPK').SS2\n         AIF   ('&INST' EQ 'MVO' OR '&INST' EQ 'ZAP').SS2\n         AIF   ('&INST' EQ 'AP' OR '&INST' EQ 'CP').SS2\n         AIF   ('&INST' EQ 'DP' OR '&INST' EQ 'MP').SS2\n         AIF   ('&INST' EQ 'SP').SS2\n         AGO   .TN\n.CHECK3  ANOP\n         AIF   (N'&SYSLIST GT 5).ERROR2\n         AIF   ('&INST' EQ 'CLM' OR '&INST' EQ 'ICM').SS0\n         AIF   ('&INST' EQ 'STCM').SS0\n         AGO   .TN                 NOT SS, NEEDS NO LENGTH\n.SS0     ANOP  ,\n&OP1     SETC  '&D.,&S'\n&OP2     SETC  '&X'\n         AGO   .TN\n.*\n.*       IF THE DESTINATION ENDS IN A BRACKET, IT IS EITHER A REGISTER\n.*       SPECIFICATION OR ALREADY HAS A LENGTH FIELD SPECIFIED, SO A\n.*       LENGTH FIELD WILL NOT BE APPENDED\n.*\n.SS1     AIF   ('&OP1'(K'&OP1,1) EQ ')').TN\n&OP1     SETC  '&D.(*-*)'          APPEND A LENGTH OF ZERO\n         AGO   .TN\n.*\n.SS2     AIF   ('&OP2'(K'&OP2,1) EQ ')').TN\n&OP2     SETC  '&S.(*-*)'          APPEND A LENGTH OF ZERO\n.*\n.TN      AIF   (&EXECUTN EQ 0).NEW IF FIRST TIME, DO NOT CHECK TABLE\n.*\n.LOOP    ANOP  ,\n&I       SETA  &I+1\n         AIF   (&I GT &EXECUTN).NEW\n         AIF   ('&OP1' NE '&EXECUTD(&I)').LOOP\n         AIF   ('&OP2' NE '&EXECUTS(&I)').LOOP\n         AIF   ('&INST' NE '&EXECUTI(&I)').LOOP\n&J       SETA  &I+&EXECUTL         ADD CURRENT EXECUTE STATEMENT NUMBER\n         AGO   .GENEX\n.*\n.NEW     ANOP  ,\n&EXECUTN SETA  &EXECUTN+1\n         AIF   (&EXECUTN GT 255).ERROR\n&EXECUTI(&EXECUTN) SETC '&INST'\n&EXECUTD(&EXECUTN) SETC '&OP1'\n&EXECUTS(&EXECUTN) SETC '&OP2'\n&J       SETA  &EXECUTN+&EXECUTL   ADD CURRENT EXECUTE STATEMENT NUMBER\n.GENEX   AIF   ('&RRR' EQ '').NAMEIT\n&MINUS   SETB  0                   TURN OFF \"-\" FLAG\n         AIF   ('&RRR'(1,1) NE '-').GENEX2\n&MINUS   SETB  1                   TURN ON  \"-\" FLAG\n&RRR     SETC  '&RRR'(2,K'&RRR-1)  REMOVE \"-\" FROM REGISTER VALUE\n         SHI   &RRR,1              DECREMENT FOR EXECUTE COMMAND\n.GENEX2  ANOP  ,\n&NAME    EX    &RRR,@EXEC&J\n.MEXIT   MEXIT ,\n.*\n.ERROR   MNOTE 8,'Number Of #EXEC Macros Exceeds Upper Limit (255)'\n         MEXIT ,\n.ERROR2  MNOTE 8,'Invalid Number Of Operands'\n         MEXIT ,\n.*\n.*   IF &REG IS NULL, #EXEC WAS CALLED FROM WITHIN ANOTHER MACRO.\n.*   THE GLOBAL SETC VARIABLE &EXECNAM IS SET TO THE INSTRUCTIONS\n.*   LABEL FOR USE BY THE CALLING MACRO.\n.*\n.NAMEIT  ANOP  ,\n&EXECNAM SETC  '@EXEC&J'                SET VARIABLE\n         MEXIT ,\n.*\n.*   IF #EXEC WAS CODED, WITH NO OPERANDS, GENERATE EXECUTE COMMANDS.\n.*\n.EXPAND  ANOP  ,\n&I       SETA  0                   INITIALIZE COUNTER\n.LOOP1   ANOP  ,\n&I       SETA  &I+1                ADD 1 TO COUNTER\n         AIF   (&I GT &EXECUTN).EXIT1\n&INS     SETC  '&EXECUTI(&I)'\n&J       SETA  &I+&EXECUTL         ADD CURRENT EXECUTE STATEMENT NUMBER\n@EXEC&J  &INS  &EXECUTD(&I),&EXECUTS(&I)\n         AGO   .LOOP1\n.EXIT1   ANOP  ,\n&EXECUTL SETA  &EXECUTN+&EXECUTL   SET CURRENT EXECUTE STATEMENT NUMBER\n&EXECUTN SETA  0                   RESET TABLE COUNTER\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#FPOST": {"ttr": 1042, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00\\x0c\\x00\\x0c\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 12, "newlines": 12, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,                   FASTPOST/QUICKPOST\n&NAME    #FPOST &ECB,&CODE\n         LCLC  &P\n&NAME    IHBINNRA &ECB,&CODE\n&P       SETC  'IHB&SYSNDX'\n         ICM   0,8,=X'40'               INSERT POST BIT TO HI BYTE\n         ICM   15,15,0(1)               LOAD ECB\n         BM    &P                       AND IF WAIT BIT ON, GO TO POST\n         CS    15,0,0(1)                SET POST BIT IF ECB UNCHANGED\n         BE    &P+2                     AND IF SUCCESSFUL, SKIP POST\n&P       SVC   2                        ISSUE POST SVC\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#FREE": {"ttr": 264, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00\\x17\\x00\\x17\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 23, "newlines": 23, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    #FREE &T,&A=\n         GBLA  &RCPSWS(10)\n         GBLC  &RCPPRE\n         LCLC  &P,&LABEL\n&P       SETC  '&RCPPRE'\n&LABEL   SETC  '&NAME'\n         AIF   (&RCPSWS(3) EQ 0).E1\n         AIF   ('&A' EQ '(0)' OR '&A' EQ '' OR '&A' EQ '(R0)').F2\n         AIF   ('&A'(1,1) EQ '(').FR\n&LABEL   L     R0,=A(&A)                LOAD STORAGE ADDRESS\n&LABEL   SETC  ''\n         AGO   .F2\n.FR      LR    R0,&A(1)                 LOAD STORAGE ADDRESS\n&LABEL   SETC  ''\n.F2      ANOP  ,\n&LABEL   L     R1,0(,R13)               LOAD MODULE COMM. AREA ADDR\n         L     R15,&P.A#FRE-&P.MCA(,R1) LOAD FREE ROUTINE ADDRESS\n         BALR  R14,R15                  FREE REQUESTED STORAGE\n         MEXIT ,\n.E1      MNOTE 8,'LIFO Option Not Specified On BEGIN Macro'\n&LABEL   DS    0H\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#GET": {"ttr": 266, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00\\x17\\x00\\x17\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 23, "newlines": 23, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    #GET  &T,&LV=\n         GBLA  &RCPSWS(10)\n         GBLC  &RCPPRE\n         LCLC  &P,&LABEL\n&P       SETC  '&RCPPRE'\n&LABEL   SETC  '&NAME'\n         AIF   (&RCPSWS(3) EQ 0).E1\n         AIF   ('&LV' EQ '(0)' OR '&LV' EQ '' OR '&LV' EQ '(R0)').G2\n         AIF   ('&LV'(1,1) EQ '(').GR\n&LABEL   L     R0,=A(&LV)               LOAD LENGTH VALUE\n&LABEL   SETC  ''\n         AGO   .G2\n.GR      LR    R0,&LV(1)                LOAD LENGTH VALUE\n&LABEL   SETC  ''\n.G2      ANOP  ,\n&LABEL   L     R1,0(0,R13)              LOAD MODULE COMM AREA ADDR\n         L     R15,&P.A#GET-&P.MCA(0,R1) LOAD GET ROUTINE ADDRESS\n         BALR  R14,R15                  GET REQUESTED STORAGE\n         MEXIT ,\n.E1      MNOTE 8,'LIFO Option Not Specified On BEGIN Macro'\n&LABEL   #NULL ,\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#GETFL": {"ttr": 513, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00F\\x00F\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 70, "newlines": 70, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&NAME    #GETFL &FLD,                   ADDR OF CTGFL BEING ACCESSED   &\n               &A,                      STRG OR REG TO GET ADDR        &\n               &L,                      STRG OR REG TO GET LENGTH      &\n               &ZERO=                   BRANCH ADDRESS\n.*********************************************************************\n.*                                                                   *\n.*   THIS MACRO IS USED TO RETRIEVE A PARTICULAR FIELD IN A CATALOG  *\n.* PARAMETER LIST.  THE FORMAT IS:                                   *\n.*      #GETFL CTGFLADDR,PTR(,LENREG)                                *\n.*            CTGFLADDR -- IS THE ADDRESS OF THE CTGFL FROM WHICH    *\n.*                         DATA IS TO BE RETRIEVED.                  *\n.*            PTR -------- IS THE ADDRESS OR REGISTER WHERE THE      *\n.*                         ADDRESS OF THE DATA WILL BE PLACED.       *\n.*                         VALID REGS (1-14)                         *\n.*            LENREG ----- IS THE ADDRESS OR REGISTER WHERE THE      *\n.*                         LENGTH OF THE DATA IS TO BE PLACED.       *\n.*            ZERO= ------ IS THE ADDRESS TO BE BRANCHED TO IF THE   *\n.*                         POINTER FIELD IS ZERO                     *\n.*                                                                   *\n.*  NOTE. THE MACROS IEZCTGPL AND IEZCTGFL MUST BE CODED TO USE      *\n.*        THIS MACRO.                                                *\n.*                                                                   *\n.*********************************************************************\n         LCLC  &REG                         *\n         AIF   ('&FLD' EQ '').E1            *\n         AIF   ('&A' EQ '').E2              *\n         PUSH  USING                        |\n         USING CTGFL,15                     | ADDRESS THE CTGFL\n         AIF   ('&FLD'(1,1) EQ '(').FR      *\n&NAME    LA    15,&FLD                      | REG 1 -> CTGFL\n         AGO   .L1                          *\n.FR      ANOP                               *\n&REG     SETC  '&FLD'(2,K'&FLD-2)           * STRIP PARENTHESIS\n&NAME    LR    15,&REG                      | REG 1 -> CTGFL\n.L1      AIF   ('&A'(1,1) EQ '(').AR        * PTR SPECD BY REG\n         AIF   ('&ZERO' NE '').L11          * CHECK FOR ZERO=\n         L     0,CTGFLPT                    | PUT THE ADDRESS OF THE\n         ST    0,&A                         | DATA INTO STORAGE\n         AGO   .L2                          *\n.L11     ANOP                               *\n         ICM   0,B'1111',CTGFLPT            | GET POINTER TO DATA\n         ST    0,&A                         | DATA INTO STORAGE\n         BZ    &ZERO                        | CHECK FOR ZERO POINTER\n         AGO   .L2                          *\n.AR      ANOP                               *\n&REG     SETC  '&A'(2,K'&A-2)               * STRIP PARENTHESIS\n         AIF   ('&ZERO' NE '').AR1          * CHECK FOR ZERO=\n         L     &REG,CTGFLPT                 | GET POINTER TO DATA\n         AGO   .L2                          *\n.AR1     ANOP                               *\n         ICM   &REG,B'1111',CTGFLPT         | GET POINTER TO DATA\n         BZ    &ZERO                        | CHECK FOR ZERO POINTER\n.L2      AIF   ('&L' EQ '').L3              * SKIP IF NO LENGTH REQUEST\n         AIF   ('&L'(1,1) EQ '(').LR        * LENGTH TO GO IN REGISTER\n         L     0,CTGFLNG                    | SAVE THE LENGTH OF THE\n         ST    0,&L                         | DATA INTO STORAGE\n         AGO   .L3                          *\n.LR      ANOP                               *\n&REG     SETC  '&L'(2,K'&L-2)               * STRIP PARENTHESIS\n         L     &REG,CTGFLNG                 | GET LENGTH OF DATA\n.L3      ANOP                               *\n         DROP  15                           | REMOVE ADDRESSABILITY\n         POP   USING                        |\n         MEXIT ,                            *\n.E1      MNOTE 8,'FIELD Address Missing'    *\n         MEXIT ,                            *\n.E2      MNOTE 8,'FIELD Result Pointer Missing'\n         MEXIT ,                            *\n         MEND  ,                            *\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#GOIF": {"ttr": 515, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00\\xca\\x00\\xca\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 202, "newlines": 202, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&NAME    #GOIF &SW,&ON=,&OFF=,&ANY=,&NOTALL=,&MIXED=\n         GBLA  &DCLDSW#             COUNTER OF # OF SWITCH BYTES.\n         GBLA  &DCLGSW#             COUNTER OF # OF GENERIC BYTES.\n         GBLB  &DCLDSWD(99)         DEFER DECLARE INDICATORS.\n         GBLC  &DCLDSWN(99)         SWITCH BYTE NAMES.\n         GBLC  &DCLDSWB(800)        SWITCH BIT NAMES.\n         GBLC  &DCLGSWN(99)         GENERIC SWITCH BYTE NAMES.\n         GBLC  &DCLGSWB(99)         GENERIC SWITCH BIT PREFIXES.\n         LCLA  &A,&B,&C,&D,&E       LOCAL WORK SYMBOLS.\n         LCLB  &F(20),&G\n         LCLC  &K(20),&L(20),&M,&N,&O,&P(2),&Q\n         AIF   ('&ON&OFF&ANY&NOTALL&MIXED' EQ '').GOI3400   ERROR.\n.*\n.* FIRST LOCATE THE SWITCHES.\n.*\n         AIF   ('&SW' EQ '').GOI3500   ERROR - NO SWITCHES.\n&A       SETA  N'&SW                GET # SWITCHES REQUESTED.\n&B       SETA  0                    INDEX INTO SUPPLIED SWITCHES.\n&C       SETA  &DCLDSW#*8           POINT TO LAST DECLARED SWITCH.\n&E       SETA  0                    COUNTER OF # BYTES FOUND.\n.GOI0100 AIF   (&B EQ &A).GOI1300   FINISHED, EXIT SEARCH.\n&B       SETA  &B+1                 POINT TO NEXT SWITCH.\n&M       SETC  '&SYSLIST(1,&B)'     GRAB SUPPLIED SWITCH.\n&G       SETB  0                    RESET NOT FLAG.\n&D       SETA  1                    INDEX INTO # DECLARED SWITCHES.\n         AIF   ('&M'(1,4) NE 'NOT-').GOI0200   NO NOT, CONTINUE.\n&G       SETB  1                    TURN NOT FLAG ON.\n&M       SETC  '&M'(5,K'&M-4)       STRIP OFF NOT.\n.GOI0200 AIF   (&DCLDSW# EQ 0).GOI0400   NO DECLARED, TRY GENERICS.\n.GOI0300 AIF   ('&M' EQ '&DCLDSWB(&D)').GOI0600   FOUND HIM.\n&D       SETA  &D+1                 INDEX TO NEXT BIT.\n         AIF   (&D LE &C).GOI0300   KEEP LOOKING.\n.GOI0400 AIF   (&DCLGSW# EQ 0).GOI3600   ERROR - SWITCH NOT FOUND.\n&D       SETA  1                    INDEX INTO # GENERIC SWITCHES.\n.GOI0500 AIF   ('&M'(1,K'&DCLGSWB(&D)) EQ '&DCLGSWB(&D)').GOI0700\n&D       SETA  &D+1                 NOT HIM, INDEX TO NEXT PREFIX.\n         AIF   (&D LE &DCLGSW#).GOI0500   KEEP LOOKING.\n         AGO   .GOI3600             ERROR - SWITCH NOT FOUND.\n.*\n.* INCOMING SWITCH IA A DECLARED SWITCH.\n.*\n.GOI0600 ANOP\n&D       SETA  (&D+7)/8             INDEX TO DECARED BYTE NAME TABLE.\n&N       SETC  '&DCLDSWN(&D)'       GET BYTE NAME.\n         AGO   .GOI0800             CONTINUE.\n.*\n.* INCOMING SWITCH IA A GENERIC SWITCH.\n.*\n.GOI0700 ANOP\n&N       SETC  '&DCLGSWN(&D)'       GET BYTE NAME.\n.*\n.* ADD SWITCH BYTE AND SWITCH BIT NAME TO A TABLE AS FOLLOWS:\n.*\n.*    - IF THE BYTE NAME IS NOT IN THE TABLE, ADD IT.\n.*    - IF IT IS BUT THE NOT FLAGS DONT MATCH, ADD IT AS A NEW ENTRY.\n.*    - OTHERWISE, CONCATENATE THE NEW SWITCH BIT NAME TO THE OLD\n.*      SWITCH BIT NAME, WITH A '+' SIGN IN BETWEEN.\n.*\n.GOI0800 AIF   (&E EQ 0).GOI1100    FIRST ENTRY, CONTINUE.\n&D       SETA  1                    INDEX INTO FOUND TABLES.\n.GOI0900 AIF   ('&N' EQ '&K(&D)').GOI1000   MATCHING NAME, CONTINUE.\n&D       SETA  &D+1                 POINT TO NEXT ENTRY.\n         AIF   (&D LE &E).GOI0900   KEEP LOOKING.\n         AGO   .GOI1100             THIS GUY IS NEW.\n.GOI1000 AIF   (&G EQ &F(&D)).GOI1200   SAME SEX TOO...\n&D       SETA  &D+1                 POINT TO NEXT ENTRY.\n         AIF   (&D LE &E).GOI0900   KEEP LOOKING.\n.*\n.* THIS ENTRY IS A NEW BYTE NAME.\n.*\n.GOI1100 ANOP\n&E       SETA  &E+1                 BUMP COUNTER OF # FOUND.\n&K(&E)   SETC  '&N'                 SAVE BYTE NAME.\n&L(&E)   SETC  '&M'                 SAVE BIT NAME.\n&F(&E)   SETB  (&G)                 SAVE NOT FLAG.\n         AGO   .GOI0100             GO, GET NEXT SUPPLIED SWITCH.\n.*\n.* THIS ENTRY IS AN OLD ENTRY.\n.*\n.GOI1200 ANOP\n&L(&E)   SETC  '&L(&E).+&M'         CONCATENATE SWITCH BIT NAMES.\n         AGO   .GOI0100             GO, GET NEXT SUPPLIED SWITCH.\n.*\n.* THE FOLLOWING IS FOR WHEN ALL SWITCHES BELONG TO THE SAME BYTE.\n.*\n.GOI1300 AIF   (&E EQ 0).GOI3500    ERROR - NO SWITCHES CODED.\n         AIF   (&E GT 1).GOI2400    MORE THAN 1, CONTINUE.\n&NAME    TM    &K(1),&L(1)\n         AIF   ('&ON' EQ '').GOI1500   NO ON, CONTINUE.\n         AIF   ('&ON'(1,1) EQ '(').GOI1400   REGISTER, CONTINUE.\n         BO    &ON                  BRANCH IF ON.\n         AGO   .GOI1500             CONTINUE.\n.GOI1400 ANOP\n         BOR   &ON(1)               BRANCH IF ON.\n.GOI1500 AIF   ('&OFF' EQ '').GOI1700   NO OFF, CONTINUE.\n         AIF   ('&OFF'(1,1) EQ '(').GOI1600   REGISTER, CONTINUE.\n         BZ    &OFF                 BRANCH IF OFF.\n         AGO   .GOI1700             CONTINUE.\n.GOI1600 ANOP\n         BZR   &OFF(1)              BRANCH IF OFF.\n.GOI1700 AIF   ('&MIXED' EQ '').GOI1900   NO MIXED, CONTINUE.\n         AIF   ('&MIXED'(1,1) EQ '(').GOI1800   REGISTER, CONTINUE.\n         BM    &MIXED               BRANCH IF MIXED.\n         AGO   .GOI1900             CONTINUE.\n.GOI1800 ANOP\n         BMR   &MIXED(1)            BRANCH IF MIXED.\n.GOI1900 AIF   ('&ANY' EQ '').GOI2100   NO ANY, CONTINUE.\n         AIF   ('&ANY'(1,1) EQ '(').GOI2000   REGISTER, CONTINUE.\n         BNZ   &ANY                 BRANCH IF ANY ON.\n         AGO   .GOI2100             CONTINUE.\n.GOI2000 ANOP\n         BNZR  &ANY(1)              BRANCH IF ANY ON.\n.GOI2100 AIF   ('&NOTALL' EQ '').GOI2300   NO NOTALL, CONTINUE.\n         AIF   ('&NOTALL'(1,1) EQ '(').GOI2200   REGISTER, CONTINUE.\n         BNO   &NOTALL              BRANCH IF NOT ALL ON.\n         AGO   .GOI2300             CONTINUE.\n.GOI2200 ANOP\n         BNOR  &NOTALL(1)           BRANCH IF NOT ALL ON.\n.GOI2300 MEXIT                      EXIT.\n.*\n.* THE FOLLOWING IS FOR 2 OR MORE BYTES.\n.*\n.GOI2400 ANOP\n&N       SETC  ''                   DEFAULT TO NON-REGISTER BRANCH.\n&O       SETC  '&NAME'              SAVE THE NAME.\n         AIF   ('&MIXED' NE '').GOI3700   ERROR - CANT HANDLE MIXED.\n&A       SETA  N'&ON+N'&OFF+N'&ANY+N'&NOTALL   GET # EXITS.\n         AIF   (&A NE 1).GOI3800    ERROR - CANT HANDLE MORE THAN 1.\n&B       SETA  0                    INDEX OF TESTS.\n         AIF   ('&ON' NE '').GOI2500   GO HANDLE ON.\n         AIF   ('&OFF' NE '').GOI2600   GO HANDLE OFF.\n         AIF   ('&ANY' NE '').GOI3000   GO HANDLE ANY.\n         AIF   ('&NOTALL' NE '').GOI3100   GO HANDLE NOTALL.\n         MNOTE 16,'GOI999X - This Macro Has a Bug In It...'\n.GOI2500 ANOP\n&A       SETA  4                    SET LENGTH OF FINAL BRANCH.\n&P(1)    SETC  'O'                  BRANCH MASK.\n&P(2)    SETC  'Z'                  BRANCH MASK WHEN 'NOT-'.\n&M       SETC  '&ON'                GET EXIT PARAMETER.\n         AIF   ('&ON'(1,1) NE '(').GOI2700   NOT A REGISTER, CONT.\n&A       SETA  2                    SET BRANCH LENGTH = 2.\n&N       SETC  'R'                  REGISTER OP CODE.\n&M       SETC  '&ON'(2,K'&ON-2)     STRIP OFF BRACKETS.\n         AGO   .GOI2700             CONTINUE.\n.GOI2600 ANOP\n&A       SETA  4                    LELNGTH OF FINAL BRANCH.\n&P(1)    SETC  'Z'                  BRANCH MASK.\n&P(2)    SETC  'O'                  BRANCH MASK WHEN 'NOT-'.\n&M       SETC  '&OFF'               GET EXIT PARAMETER.\n         AIF   ('&OFF'(1,1) NE '(').GOI2700   NOT A REGISTER, CONT.\n&A       SETA  2                    SET BRANCH LENGTH =2.\n&N       SETC  'R'                  STRIP OFF BRACKETS.\n&M       SETC  '&OFF'(2,K'&OFF-2)   STRIP OFF BRACKETS.\n.GOI2700 ANOP\n&A       SETA  (&E-1)*8+&A          INITIAL BRANCH AROUND LENGTH.\n.GOI2800 AIF   (&B GE &E).GOI3300   FINISHED, GET THE HELL OUT.\n&B       SETA  &B+1                 N, GET NEXT TEST.\n&O       TM    &K(&B),&L(&B)\n&O       SETC  ''                   ONLY WANT LABEL ONCE.\n&Q       SETC  '&P(&F(&B)+1)'       ESTIMATE THE BRANCH LENGTH.\n         AIF   (&B EQ &E).GOI2900   LAST ONE, GO DO FINAL BRANCH.\n         BN&Q  *+&A\n&A       SETA  &A-8                 DECREMENT BRANCH LENGTH.\n         AGO   .GOI2800             LOOP THRU ALL TESTS.\n.GOI2900 B&Q&N &M                   EXIT IF CONDITION SATISFIED.\n         MEXIT                      EXIT.\n.GOI3000 ANOP\n&P(1)    SETC  'Z'                  BRANCH MASK.\n&P(2)    SETC  'O'                  BRANCH MASK FOR 'NOT-'.\n&M       SETC  '&ANY'               GET PARAMETER.\n         AIF   ('&ANY'(1,1) NE '(').GOI3200   NOT A REGISTER, CONT.\n&N       SETC  'R'                  REGISTER OP CODE.\n&M       SETC  '&ANY'(2,K'&ANY-2)   STRIP OFF BRACKETS.\n         AGO   .GOI3200             CONTINUE.\n.GOI3100 ANOP\n&P(1)    SETC  'O'                  BRANCH MASK.\n&P(2)    SETC  'Z'                  BRANCH MASK FOR 'NOT-'.\n&M       SETC  '&NOTALL'            PICK UP PARAMETER.\n         AIF   ('&NOTALL'(1,1) NE '(').GOI3200   NOT A REGISTER, CONT.*\n&N       SETC  'R'                  REGISTER OP CODE.\n&M       SETC  '&NOTALL'(2,K'&NOTALL-2)   STRIP OFF BRACKETS.\n.GOI3200 AIF   (&B GE &E).GOI3300   FINISHED, GET THE HELL OUT.\n&B       SETA  &B+1                 GET NEXT TEST.\n&O       TM    &K(&B),&L(&B)\n&O       SETC  ''                   WANT LABEL ONLY ONCE.\n&Q       SETC  '&P(&F(&B)+1)&N'     GET BRANCH MASK.\n         BN&Q  &M\n         AGO   .GOI3200             LOOP THRU ALL TESTS.\n.GOI3300 MEXIT                      EXIT.\n.GOI3400 MNOTE 8,'GOI001A - No Branch Conditions Specified'\n         MEXIT                      EXIT.\n.GOI3500 MNOTE 8,'GOI002A - No Switches Specified'\n         MEXIT                      EXIT.\n.GOI3600 MNOTE 8,'GOI003A - Switch &M Not Declared'\n         MEXIT                      EXIT.\n.GOI3700 MNOTE 8,'GOI004A - \"MIXED\" Parameter Not Supported When'\n         MNOTE 0,'          More Than 1 Byte Is Being Tested'\n         MEXIT\n.GOI3800 MNOTE 8,'GOI005A - Multiple Tests Not Supported When'\n         MNOTE 0,'          More Than 1 Byte Is Being Tested'\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#ICALL": {"ttr": 3078, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x14\\x11/\\x01\\x14\\x11/\\x12H\\x001\\x001\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-04-22T00:00:00", "modifydate": "2014-04-22T12:48:32", "lines": 49, "newlines": 49, "modlines": 0, "user": "MACRO"}, "text": ".*********************************************************************.\n.*                                                                   *.\n.*  USED WITH #IPROC,  #ICALL, #IPEND.                               *.\n.*                                                                   *.\n.*                                                                   *.\n.*        #ICALL  CALLS THE SPECIFIED INTERNAL SUBROUTINE            *.\n.*                                                                   *.\n.*********************************************************************.\n         MACRO\n&NAME    #ICALL &RTN,&LINKREG=R14,&ERROR=,&AMODE=\n         GBLB  &STF(24)            FLAGS FROM #START\n         LCLC  &REG\n         AIF   ('&RTN'(1,1) EQ '(').REGFORM\n         AIF   (&STF(19)).RBR      RELATIVE BRANCHES?\n&NAME    L     &LINKREG,=A(&RTN)   PICK UP ADDRESS OF SUB-ROUTINE\n         AGO   .AMODE\n.RBR     ANOP  ,\n&NAME    LARL  &LINKREG,&RTN       LOAD ROUTINE ADDRESS\n.AMODE   AIF   ('&AMODE' EQ '31').AM31\n         AIF   ('&AMODE' EQ '64').AM64\n         BASR  &LINKREG,&LINKREG   BASR TO SUB-ROUTINE\n         AGO   .ERRCHK\n.AM31    OILH  &LINKREG,X'8000'    PASS CONTROL IN 31 BIT MODE\n         AGO   .BASSM\n.AM64    OILL  &LINKREG,X'0001'    PASS CONTROL IN 64 BIT MODE\n.BASSM   BASSM &LINKREG,&LINKREG   BASSM TO SUB-ROUTINE\n         AGO   .ERRCHK\n.REGFORM ANOP\n&REG     SETC  '&RTN'(2,K'&RTN-2)\n         AIF   ('&AMODE' EQ '31').RAM31\n         AIF   ('&AMODE' EQ '64').RAM64\n&NAME    BASR  &LINKREG,&REG       BASR TO SUB-ROUTINE\n         AGO   .ERRCHK\n.RAM31   ANOP  ,\n&NAME    OILH  &REG,X'8000'        PASS CONTROL IN 31 BIT MODE\n         BASSM &LINKREG,&REG       BASSM TO SUB-ROUTINE\n         AGO   .ERRCHK\n.RAM64   ANOP  ,\n&NAME    LA    &REG,1(,&REG)       PASS CONTROL IN 64 BIT MODE\n         BASSM &LINKREG,&REG       BASSM TO SUB-ROUTINE\n.ERRCHK  AIF   (T'&ERROR EQ 'O').NERR\n         LTR   R15,R15             WAS THERE AN ERROR?\n         AIF   (&STF(19)).RBR002   RELATIVE BRANCHES?\n         BNZ   &ERROR              YES - GO TO ERROR ROUTINE\n         AGO   .NERR\n.RBR002  JNZ   &ERROR              YES - GOTO ERROR ROUTINE\n.NERR    ANOP  ,\n         MEXIT ,\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#IKJPSCB": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00:\\x00:\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 58, "newlines": 58, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         #IKJPSCB ,\n         IKJPSCB ,\n\n**********************************************************************\n*                                                                    *\n*   MAP THE INSTALLATION DEFINED FIELDS IN THE PSCB.                 *\n*                                                                    *\n*  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+ *\n*  |00 |01 |02 |03 |04 |05 |06 |07 |08 |09 |10 |11 |12 |13 |14 |15 | *\n*  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+ *\n*  |           |                   |   |           |               | *\n*  |<-PSBCUTL->|<-- PSCBUFLG ------+-->|<-PSCBUIDL>|<-- PSCBUMLL ->| *\n*  |                               |                               | *\n*  |<--------- PSCBUSR1 ---------->|<--------- PSCBUSR2 ---------->| *\n*  |                                                               | *\n*  |<------------------------ PSCBATR2 --------------------------->| *\n*                                                                    *\n*   PSCBATR2 -- THE LABEL GIVEN TO THE ENTIRE 16 BITS OF USER DATA   *\n*   PSCBUSR1 -- THE FIRST 8 BITS OF USER DATA                        *\n*   PSCBUSR2 -- THE SECOND 8 BITS OF USER DATA                       *\n*   PSBCUTL  -- BITS 0 THRU 2 REPRESENT A THREE BIT NUMBER WHICH     *\n*               INDICATES THE LIMIT OF CPU TIME THE SESSION MAY RUN  *\n*               WITHOUT TERMINAL I/O.  000 = 1 MIN, 001 = 2 MINS,    *\n*               ETCETERA WITH 111 = 8 MINS (THE ABSOLUTE MAXIMUM).   *\n*   PSCBUFLG -- BITS 3 THRU 8 OF THE USER DATA FIELD ARE USED AS     *\n*               BIT FLAGS                                            *\n*   PSCBUIDL -- BITS 9 THRU 11 REPRESENT A THREE BIT NUMBER WHICH    *\n*               INDICATES THE AMOUNT OF TIME A USER WILL BE LEFT     *\n*               LOGGED ON WHILE IDLE IN MULTIPLES OF FIVE MINUTES.   *\n*               (ZEROES IN THIS FIELD IMPLIES THAT A DEFAULT VALUE   *\n*               BE USED)                                             *\n*   PSCBUMLL -- BITS 12 THRU 15 REPRESENT A 4 BIT NUMBER FROM 1 TO   *\n*               12 WHICH IS THE ORDINATE OF THE MONTH DURING WHICH   *\n*               THE USER LAST LOGGED ON (ZEROES IN THIS FIELD WILL   *\n*               DISABLE MONTHLY PASSWORD PROMPTING)                  *\n*                                                                    *\n**********************************************************************\n         ORG   PSCBATR2           BACK TO INSTALLATION FIELDS\n\nPSCBUSR1 DS    B                  FIRST BYTE OF USER FIELDS\nPSCBUTL  EQU   B'11100000'        CPU SPIN LIMIT - 3-BIT NBR IS ONE    X\n                                  LESS THAN LIMIT IN MINUTES\n*        EQU   B'00010000'        RESERVED FOR FUTURE USE\n*        EQU   B'00001000'        RESERVED FOR FUTURE USE\nPSCBSPMT EQU   B'00000100'        PROMPT FOR SUB-ACCOUNT\nPSCBPPMT EQU   B'00000010'        PROMPT FOR PROGRAMMER NAME\nPSCBUCP  EQU   B'00000001'        USER ALLOWED TO CHANGE PASSWORD\n\nPSCBUSR2 DS    B                  SECOND BYTE OF USER FIELDS\n*        EQU   B'10000000'        RESERVED FOR FUTURE USE\nPSCBUDFI EQU   B'01110000'        IDLE TIME LIMIT IN 5-MINUTE UNITS    X\n                                  ZERO MEANS NO LIMIT IF 3270\nPSCBUDFT EQU   B'00100000'        NON-3270 DEFAULT IS TEN MINUTES\nPSCBUMPC EQU   B'00001111'        IF ANY BITS ON THEN USER WILL BE     X\n                                  PROMPTED FOR NEW PSWD EVERY MONTH\n         ORG   ,\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#IKJUPT": {"ttr": 1799, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00\\x1f\\x00\\x1f\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 31, "newlines": 31, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         #IKJUPT ,\n.**********************************************************************\n.*                                                                    *\n.*       \"CUSTOM\" TSO USER PROFILE TABLE MAPPING                      *\n.*                                                                    *\n.*       THIS MACRO INVOKES IKJUPT TO MAP THE STANDARD USER PROFILE   *\n.*       TABLE.  IN ADDITION IT DEFINES UPTUSER FIELDS.               *\n.*                                                                    *\n.**********************************************************************\n\n         IKJUPT ,\n\n         ORG   UPTUSER            UPTUSER FIELD DEFINITIONS\n         IEZBITS ,\nUPTSTACK DS    C                  XPCF STACK DELIMETER CHARACTER\nUPTEXIT  DS    C                  XPCF EXIT  DELIMETER CHARACTER\n\nUPTFLAGS DS    B                  XPCF FLAG BYTE\nUPTTRACE EQU   BIT0               - XPCF TRACE\nUPTINTER EQU   BIT1               - XPCF INTERACTIVE TRACE\nUPTRES20 EQU   BIT2               - *  RESERVED FOR TESTING.\nUPTRES10 EQU   BIT4               - *\nUPTDBC   EQU   BIT4               - DBC USER FLAG\nUPTAVERB EQU   BIT5               - ACCESS VERBOSITY FLAG\nUPTRSVD  EQU   BIT6+BIT7          - RESERVED FOR FUTURE USE\n\nUPTSPARE DS    XL7                RESERVED FOR FUTURE USE\n\n         ORG   ,\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#INSTACK": {"ttr": 1801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00\\x14\\x00\\x14\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 20, "newlines": 20, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         #INSTACK &DSECT=INSTACK\n*\n*        I/O SERVICE ROUTINE INSTACK MAP\n*\n         SPACE\n         AIF   ('&DSECT' EQ 'NO').ND\n&DSECT   DSECT ,\n.ND      ANOP\nINSCODE  DS    XL1   TYPE OF ELEMENT\nINSDATA  EQU   X'80' DATASET/TERMINAL\nINSSTOR  EQU   X'40' STORAGE SOURCE/TERMIN DLM\nINSINDD  EQU   X'20' INPUT DD PRESENT\nINSOTDD  EQU   X'10' OUTPUT DD PRESENT\nINSEXEC  EQU   X'08' EXEC COMMAND ELEMENT\nINSPROM  EQU   X'04' PROMPTING ALLOWED\nINSPROC  EQU   X'02' PROCEDURE ELEMENT\nINSLIST  EQU   X'01' LIST OPTION\nINADLSD  DS    AL3   LSD/IODSD ADDRESS\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#IOSRL": {"ttr": 1803, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00\\x0f\\x00\\x0f\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 15, "newlines": 15, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         #IOSRL &DSECT=IOSRL\n*\n*        I/O SERVICE ROUTINE WORK AREA MAP\n*\n         AIF   ('&DSECT' EQ 'NO').ND\n\n&DSECT   DSECT ,\n.ND      ANOP  ,\nIOSTELM  DS    A     CURRENT ELEMENT ADDRESS\nIOSBELM  DS    A     BOTTOM ELEMENT ADDRESS\nIOSTLEN  DS    XL2   TOTAL STACK SIZE\nIOSNELM  DS    XL2   NOT USED\n         DS    A     RESERVED\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#IPEND": {"ttr": 3848, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x14\\x11/\\x01\\x14\\x11/\\x12H\\x00-\\x00-\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-04-22T00:00:00", "modifydate": "2014-04-22T12:48:32", "lines": 45, "newlines": 45, "modlines": 0, "user": "MACRO"}, "text": ".*********************************************************************.\n.*                                                                   *.\n.*  USED WITH #IPROC, #ICALL, #IPEND.                                *.\n.*                                                                   *.\n.*                                                                   *.\n.*        IPEND RESTORES REGISTERS FROM THE STACK AND RETURNS        *.\n.*                USING 'PR'                                         *.\n.*                                                                   *.\n.*   RESTR0R1=YES - RESTORES ENTRY R0,R1 VALUES ON RETURN            *.\n.*   RESTR15=YES - RESTORES R15 ON RETURN                            *.\n.*                                                                   *.\n.*********************************************************************.\n         MACRO ,\n&NAME    #IPEND &RESTR0R1=,&RESTR15=\n         GBLB  &STF(24)\n         GBLA  &IPROC#             UNIQUE ID OF PREVIOUS IPEND\n         GBLC  &STNAME             MAIN CSECT NAME\n         LCLB  &R0R1\n         LCLB  &R15\n&R0R1    SETB  ('&RESTR0R1' EQ 'YES' OR '&RESTR0R1' EQ 'Y')\n&R15     SETB  ('&RESTR15' EQ 'YES' OR '&RESTR15' EQ 'Y')\n         AIF   (&R0R1 AND &R15).RBOTH\n         AIF   (&R0R1).RR0R1\n         AIF   (&R15).RR15\n&NAME    PR    ,                   RESTORE GPR/AR 2-14 AND RETURN\n         AGO   .CDONE\n.RBOTH   ANOP  ,\n&NAME    EREGG 15,1                RESTORE GPR/AR 15-0\n         AGO   .CONT\n.RR0R1   ANOP  ,\n&NAME    EREGG 0,1                 RESTORE GPR/AR 0-1\n         AGO   .CONT\n.RR15    ANOP  ,\n&NAME    EREGG 15,15               RESTORE GPR/AR 15\n.CONT    ANOP  ,\n         PR    ,                   RESTORE GPR/AR 2-14\n.CDONE   ANOP  ,\n         AIF   (&STF(19)).RELADD\n         #EXEC ,                   GENERATE ANY EX TARGETS\n         LTORG ,                   GENERATE LOCAL LITERAL POOL\nIPEND&IPROC# DS 0H                 FORCE ALIGNMENT\n.RELADD  ANOP  ,\n         POP   USING               RESTORE USING STATUS\n&STNAME  LOCTR ,                   RESTORE MAIN CSECT\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#IPROC": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x14\\x11/\\x01\\x14\\x11/\\x12H\\x00P\\x00P\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-04-22T00:00:00", "modifydate": "2014-04-22T12:48:32", "lines": 80, "newlines": 80, "modlines": 0, "user": "MACRO"}, "text": ".*********************************************************************.\n.*                                                                   *.\n.*  USED WITH #IPROC, #ICALL, #IPEND                                 *.\n.*                                                                   *.\n.*        IPROC allows subroutines to be used in a #START enviro     *.\n.*          General and access registers are saved in the stack      *.\n.*           using the BAKR instruction.                             *.\n.*                                                                   *.\n.*        MODE=DEFINE - sets up small work areas                     *.\n.*        WA=Y        - This subroutine has its own WA               *.\n.*                                                                   *.\n.*********************************************************************.\n         MACRO ,\n&NAME    #IPROC &MODE=,&BASEREG=R10,&LINKREG=R14,&WA=N,&BASE2=,        +\n               &ZEROWA=Y,&ARZERO=Y,&MAINWA=N\n         GBLA  &IPNUMWA            Number of workareas\n         GBLA  &IPNUMWD            Number of workareas declared\n         GBLB  &STF(24)\n         GBLC  &STWANAM\n         LCLA  &WAN\n         AIF   ('&MODE' EQ '').IPRO050\n         AIF   ('&WA' EQ 'N').IPRO005  \"&WA\" SPECIFIED\n         MNOTE 4,'WA IGNORED WHEN MODE IS SPECIFIED'\n.IPRO005 ANOP  ,\n         AIF   ('&MODE' EQ 'DEFINE').IPRO030\n         MNOTE 12,'INVALID VALUE SPECIFIED FOR MODE - \"&MODE\"'\n         MEXIT ,\n.IPRO030 ANOP  ,\nIPROCARZ DS    9F                  ZEROS TO INIT ACC REGS\n         AIF   (&IPNUMWA EQ 0).IPRO048\n&WAN     SETA  1\n.IPRO042 ANOP  ,\n         DS    0D\nIPRWA&WAN DS   XL(IPRWAD&WAN.L)\n&WAN     SETA  &WAN+1\n         AIF   (&WAN LE &IPNUMWA).IPRO042\n.IPRO048 ANOP  ,\n         MEXIT ,\n.IPRO050 ANOP  ,\n         GBLA  &IPROC#             SYSIDX of this IPROC\n         GBLC  &STPREF             MODULE PREFIX\n         LCLC  &SUBRNAM            SUBROUTINE LABEL\n         LCLC  &BR                 BASE REGISTER TO USE\n         LCLC  &LR                 LINK REGISTER TO USE\n         LCLC  &BRGS               EXPRESSION FOR USING\n&IPROC#  SETA  &SYSNDX             SET NUMBER FOR THIS IPROC\n&BR      SETC  '&BASEREG'          SET BASE REGISTER TO USE\n&LR      SETC  '&LINKREG'          SET LINK REGISTER TO USE\n&BRGS    SETC  '&BR'\n         AIF   ('&MAINWA' NE 'Y').Skipmwa\n         USING &STWANAM,R13     Main work area\n.Skipmwa anop  ,\n         AIF   ('&BASE2' EQ '').IPRO055\n&BRGS    SETC  '&BRGS'.',&BASE2'\n.IPRO055 ANOP  ,\n&SUBRNAM SETC  '&STPREF.SUBRT'\n&SUBRNAM LOCTR ,\n         PUSH  USING               SAVE USING STATUS\n&NAME    BAKR  &LR,0               SAVE GPRs & ARs\n         AIF   ('&ARZERO' NE 'Y').IPRO057\n         LAM   AR2,AR10,IPROCARZ   CLEAR THE ACCESS REGISTERS\n.IPRO057 AIF   (&STF(19)).RELADD   Relative addressing?\n         BALR  &BR,0               OBTAIN LOCAL\n         USING (*,IPEND&IPROC#),&BRGS ADDRESSABILITY\n         LAE   &BR,0(&BR,0)        ENSURE CLEAN BASE AND AR\n         AIF   ('&BASE2' EQ '').IPRO060\n         LAE   &BASE2,2048(,&BR)   SET UP\n         LA    &BASE2,2048(,&BASE2)  SECOND BASE\n.IPRO060 ANOP  ,\n.RELADD  ANOP  ,\n         AIF   (&IPNUMWA EQ &IPNUMWD).IPRO065\n         MNOTE 12,'PREVIOUS IPROC WA NOT DECLARED WITH #IWA START'\n.IPRO065 ANOP  ,\n         AIF   ('&WA' EQ 'N').IPRO070\n&IPNUMWA SETA  &IPNUMWA+1\n         USING IPRWAD&IPNUMWA,IPRWA&IPNUMWA\n         AIF   ('&ZEROWA' NE 'Y').IPRO070\n         XC    IPRWA&IPNUMWA,IPRWA&IPNUMWA  CLEAR WORKAREA\n.IPRO070 ANOP  ,\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#LABELS": {"ttr": 1805, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00R\\x00R\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 82, "newlines": 82, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,                            TAPE LABELS\n&NAME    #LABELS &DSECT=YES\n         AIF   ('&DSECT' NE 'YES').#LBLCS\nLBLDSECT DSECT\n.#LBLCS  ANOP\nDXLBL    DS    0CL80\nVOLLABI  DS    CL3                          LABEL IDENTIFIER\nVOLNO    DS    CL1                          VOLUME LABEL NUMBER\nVOLSERNO DS    CL6                          VOLUME SERIAL NUMBER\nVOLSEC   DS    CL1\n         DS    0CL10                        RESERVED\nVOLVTOC  DS    CL5                          VTOC ADDRESS (CCHHR)\n         DS    CL5                          RESERVED\n         DS    CL10                         RESERVED\n         DS    CL10                         RESERVED\nVOLOWNER DS    CL10                         OWNER NAME AND ADDRESS CODE\n         DS    CL29                         RESERVED\n\n***********************************************************************\n*\n*        ANSI VOLUME LABEL AREA\n*        (ANSI AND IBM STANDARD LABEL DIFFERENCES)\n*\n***********************************************************************\n\n         ORG   DXLBL+37\nAVOLOWNR DS    CL14                     OWNER IDENTIFICATION\n         DS    CL28                     RESERVED\nLABSTAND DS    CL1                      LABEL STANDARD LEVEL\n\n***********************************************************************\n*\n*        FILE LABEL 1 AREA - SEE 'DATA SET LABEL -- FL1'\n*\n***********************************************************************\n\n         ORG   DXLBL\nFL1LABI  DS    CL3                          LABEL IDENTIFIER\nFL1NO    DS    CL1                          FILE LABEL NUMBER\nFL1ID    DS    CL17                         FILE IDENTIFIER\nFL1FILSR DS    CL6                          FILE SERIAL NUMBER\nFL1VOLSQ DS    CL4                          VOLUME SEQUENCE NUMBER\nFL1FILSQ DS    CL4                          FILE SEQUENCE NUMBER\nFL1GNO   DS    CL4                          GENERATION NUMBER\nFL1VNG   DS    CL2                          VERS. NUMBER OF GENERATION\nFL1CREDT DS    CL6                          CREATION DATE\nFL1EXPDT DS    CL6                          EXPIRATION DATE\nFL1FSEC  DC    C'0'                         FILE SECURITY INDICATOR\nFL1BLKCT DS    CL6                          BLOCK COUNT\nFL1SYSCD DS    CL13                         SYSTEM CODE\nFL1RES   DS    0CL7                         RESERVED\n         DS    CL1                          RESERVED\nFL1RES1  DS    CL6                          RESERVED\n\n***********************************************************************\n*\n*        FILE LABEL 2 AREA - SEE 'DATA SET LABEL -- FL2'\n*\n***********************************************************************\n\n         ORG   FL1ID\nFL2RECFM DS    CL1                          RECORD FORMAT\nFL2BLKL  DS    CL5                          BLOCK LENGTH\nFL2LRECL DS    CL5                          RECORD LENGTH\nFL2DEN   DS    CL1                          DENSITY\nFL2FILP  DS    CL1                          FILE POSITION\nFL2JSID  DS    0CL17                        JOB/STEP IDENTIFICATION\nFL2JOBD  DS    CL8                          JOB IDENTIFICATION\nFL2JSSP  DC    C'/'                         SLASH\nFL2STEPD DS    CL8                          STEP IDENTIFICATION\nFL2TRTCH DS    CL2                          TAPE RECORDING TECHNIQUE\nFL2CNTRL DS    CL1                          CARRAIGE CONTROL CHARACTER\n         DS    CL1                          RESERVED FOR FUTURE USE\nFL2BLKA  DS    CL1                          BLOCK ATTRIBUTE\n         DS    CL1                          RESERVED\nFL2DRID  DS    0CL7                         TAPE DRIVE ID\n         DS    CL2                          RESERVED\nFL2ID    DS    CL5                          ID OF CREATING DRIVE\nFL2DSIND DS    CL1                          DATA SET INDICATOR FIELD\nFL2RES   DS    CL32                         RESERVED\n         ORG   ,\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#MODE": {"ttr": 517, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00\"\\x00\"\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 34, "newlines": 34, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&LABEL   #MODE &WHAT,&R=R14\n         GBLC  &SYSSPLV             SPLEVEL\n         SPLEVEL TEST\n         AIF   ('&SYSSPLV' NE '1').LEVEL2\n         AIF   ('&R' EQ 'R14' OR '&R' EQ '14').LEVEL1\n         MNOTE 12,'**** R=&R Invalid - Must Be R14 When SPLEVEL=1'\n         MEXIT ,\n.LEVEL1  AIF   ('&WHAT' EQ '24').SET124\n         AIF   ('&WHAT' EQ '31').SET131\n         MNOTE 8,'**** Operand Must Be ''24'' Or ''31'''\n         MEXIT ,\n.SET124  ANOP  ,\n&LABEL   LA    &R,*+8                   POINT AFTER BRANCH\n         B     890                      GO THROUGH PSARET\n         MEXIT ,\n.SET131  ANOP  ,\n&LABEL   LA    &R,*+12                  POINT AFTER BRANCH\n         O     &R,=X'80000000'          SET AMODE-31 BIT\n         B     890                      GO THROUGH PSARET\n         MEXIT ,\n.LEVEL2  AIF   ('&WHAT' EQ '24').SET224\n         AIF   ('&WHAT' EQ '31').SET231\n         MNOTE 8,'**** Operand Must Be ''24'' Or ''31'''\n         MEXIT ,\n.SET224  ANOP  ,\n&LABEL   LA    &R,*+6                   POINT AFTER BSM\n         BSM   0,&R                     SET ADDRESSING MODE\n         MEXIT ,\n.SET231  ANOP  ,\n&LABEL   LA    &R,*+10                  POINT AFTER BSM\n         O     &R,=X'80000000'          SET AMODE-31 BIT\n         BSM   0,&R                     SET ADDRESSING MODE\n.MEND    MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#MODID": {"ttr": 519, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00\\x97\\x00\\x97\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 151, "newlines": 151, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&LABEL   #MODID &VERS,&LVL,&BR=NO,&ID=\n         GBLA  &#COPYSZ\n         GBLB  &STBEG                   START/BEGIN PRESENT\n         LCLA  &N(12),&D,&Y,&M,&X\n         LCLC  &MON(12),&DAY,&YR,&VRS,&LEV,&MTH,&IDENT,&Q\n         AIF   (NOT &STBEG).EXPAND\n*  #MODID REDUNDANT DUE TO #START/BEGIN MACRO -- IGNORED\n         MEXIT ,\n.EXPAND  ANOP  ,\n&MON(1)  SETC  'Jan'\n&MON(2)  SETC  'Feb'\n&MON(3)  SETC  'Mar'\n&MON(4)  SETC  'Apr'\n&MON(5)  SETC  'May'\n&MON(6)  SETC  'Jun'\n&MON(7)  SETC  'Jul'\n&MON(8)  SETC  'Aug'\n&MON(9)  SETC  'Sep'\n&MON(10) SETC  'Oct'\n&MON(11) SETC  'Nov'\n&MON(12) SETC  'Dec'\n.*\n.*   SET UP ARRAY FOR NUMBER OF DAYS PER MONTH\n.*\n&N(1)    SETA  31\n&N(2)    SETA  28\n&N(3)    SETA  31\n&N(4)    SETA  30\n&N(5)    SETA  31\n&N(6)    SETA  30\n&N(7)    SETA  31\n&N(8)    SETA  31\n&N(9)    SETA  30\n&N(10)   SETA  31\n&N(11)   SETA  30\n&N(12)   SETA  31\n.*\n.*   PARSE OPERANDS (IF ANY)\n.*\n         AIF   ('&VERS' EQ '' OR T'&VERS EQ 'O').NOVERS\n         AIF   (K'&VERS GT 1).ERR1\n         AIF   ('&VERS' LT '1' OR '&VERS' GT '9').ERR1\n         AIF   ('&SYSECT' EQ '').ERR4\n.*\n.*   IF NO VERSION NUMBER SPECIFIED, ASSUME VERSION 0\n.*\n&VRS     SETC  '&VERS'\n         AGO   .CKLVL\n.NOVERS  ANOP  ,\n&VRS     SETC  '0'\n.*\n.*   SAME FOR LEVEL NO.\n.*\n.CKLVL   ANOP  ,\n         AIF   ('&LVL' EQ '' OR T'&LVL EQ 'O').NOLVL\n         AIF   (K'&LVL GT 1).ERR2\n         AIF   ('&LVL' LT '0' OR '&LVL' GT '9').ERR2\n&LEV     SETC  '&LVL'\n         AGO   .GETDATE\n.NOLVL   ANOP  ,\n&LEV     SETC  '0'\n.*\n.*   GET THE DATE AND CONVERT IT TO JULIAN. THIS IS MESSY BUT IT'S\n.*   THE ONLY WAY TO FIT IT INTO THE FORMAT. USE THE FORMAT OF THE DATE\n.*   RETURNED TO DETERMINE WHICH ASSEMBLER WE ARE USING.\n.*\n.GETDATE ANOP  ,\n&D       SETA  0\n&M       SETA  0\n         AIF   ('&SYSDATE'(3,1) EQ '/').NOTG\n         MNOTE 12,'Assembler G Must Not Be Used'\n         MEXIT ,\n.*\n.*   BUILD THE DAY FOR THE JULIAN DATE FROM THE ARRAY ABOVE\n.*\n.LOOP1   ANOP  ,\n&M       SETA  &M+1\n         AIF   (&M GT 12).ERR3\n         AIF   ('&SYSDATE'(3,3) EQ '&MON(&M)').FOUND\n&D       SETA  &D+&N(&M)\n         AGO   .LOOP1\n.FOUND   ANOP  ,\n&DAY     SETC  '&SYSDATE'(6,2)\n&X       SETA  &DAY\n&D       SETA  &D+&X\n         AIF   ('&SYSDATE'(1,2) EQ '00').NOTLEAP\n&YR      SETC  '&SYSDATE'(1,2)\n&X       SETA  &YR\n         AIF   (((&X/4)*4)-&X NE 0).NOTLEAP\n         AIF   (&M LT 3).NOTLEAP\n&D       SETA  &D+1\n         AGO   .NOTLEAP\n.NOTG    ANOP  ,\n&M       SETA  &M+1\n         AIF   (&M GT 12).ERR3\n&MTH     SETC  '&SYSDATE'(1,2)\n&X       SETA  &MTH\n         AIF   (&M EQ &X).ADD\n&D       SETA  &D+&N(&M)\n         AGO   .NOTG\n.ADD     ANOP  ,\n&DAY     SETC  '&SYSDATE'(4,2)\n&X       SETA  &DAY\n&D       SETA  &D+&X\n         AIF   ('&SYSDATE'(7,2) EQ '00').NOTLEAP\n&YR      SETC  '&SYSDATE'(7,2)\n&X       SETA  &YR\n         AIF   (((&X/4)*4)-&X NE 0).NOTLEAP\n         AIF   (&M LT 3).NOTLEAP\n&D       SETA  &D+1\n.NOTLEAP ANOP  ,\n.*\n.*   PLAY A SILLY GAME TO ADD LEADING ZEROS\n.*\n         AIF   (K'&D EQ 3).GOOD\n         AIF   (K'&D EQ 2).TWO\n&DAY     SETC  '00&D'\n         AGO   .CHKBR\n.TWO     ANOP  ,\n&DAY     SETC  '0&D'\n         AGO   .CHKBR\n.GOOD    ANOP  ,\n&DAY     SETC  '&D'\n.CHKBR   ANOP  ,\n&Q       SETC  '#&VRS&LEV&YR&DAY'\n         AIF   ('&BR' EQ 'NO').EQU\n         #COPY SET\n         B     &Q+&#COPYSZ                   AROUND THE DC'S\n.EQU     ANOP  ,\n.*\n.*   EQUATE MODID TO CSECT NAME SO IT WILL SHOW IN LKED MAP\n.*\n.*       ENTRY &Q     (THIS IS UTTERLY USELESS IN AN SMP ENVIRONMENT)\n         DC    CL8'&Q'                  MODULE ID\n&IDENT   SETC  '&SYSECT'\n         AIF   ('&ID' EQ '' OR T'&ID EQ 'O').DEFLT\n&IDENT   SETC  '&ID'\n.DEFLT   DC    CL8'&IDENT'              CSECT NAME\n         DC    CL8'&SYSTIME'            TIME OF COMPILE\n&Q       #COPY GEN                      COPYRIGHT NOTICE\n*\n         MEXIT ,\n.ERR1    MNOTE 12,'Version Number Is Invalid'\n         MEXIT ,\n.ERR2    MNOTE 12,'Level Number Is Invalid'\n         MEXIT ,\n.ERR3    MNOTE 16,'More Than 12 Months, You Are In Trouble'\n         MEXIT ,\n.ERR4    MNOTE 12,'No CSECT Name Coded'\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#MSG": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00H\\x00H\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 72, "newlines": 72, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    #MSG  &OFFSET=0,&TYPE=ABSOLUTE,&ALIGN=\n         GBLA  &RCPTXTL\n         LCLA  &L,&I\n         LCLC  &A,&C\n&L       SETA  4                       START WITH HEADER LENGTH\n&I       SETA  1\n         AIF   (N'&SYSLIST EQ 0).EXIT\n&A       SETC  'AL2'\n         AIF   ('&ALIGN' NE 'YES').NOALIGN\n&A       SETC  'Y'\n.NOALIGN ANOP  ,\n         AIF   (N'&SYSLIST GT 1).TTYPE\n         AIF   ('&SYSLIST(1)'(1,1) NE '''').ERROR\n         RCPTXTL &SYSLIST(1)\n&L       SETA  &RCPTXTL+4\n&NAME    DC    &A.(&L,&OFFSET)\n         DC    C&SYSLIST(1)\n\n         MEXIT\n.TTYPE   AIF   ('&TYPE' EQ 'SYMBOLIC'(1,K'&TYPE)).SYM\n         AIF   ('&TYPE' EQ 'ABSOLUTE'(1,K'&TYPE)).LOOP1\n         MNOTE 4,'TYPE=&TYPE Invalid, TYPE=ABSOLUTE Used'\n.LOOP1   ANOP  ,\n         AIF   ('&SYSLIST(&I)'(1,1) NE '''').ERROR\n         RCPTXTL &SYSLIST(&I)\n&L       SETA  &L+&RCPTXTL             INCREMENT LENGTH\n&I       SETA  &I+2                    INCREMENT INDEX\n         AIF   (&I LE N'&SYSLIST).LOOP1\n&NAME    DC    Y(&L,&OFFSET)           SEGMENT LENGTH AND OFFSET\n&I       SETA  0\n&L       SETA  0\n.LOOP2   ANOP  ,\n&I       SETA  &I+1\n         AIF   (&I GT N'&SYSLIST).EXIT\n&L       SETA  &L+K'&SYSLIST(&I)-2\n         DC    C&SYSLIST(&I)\n&I       SETA  &I+1\n         AIF   ('&SYSLIST(&I)' EQ '').LOOP2\n&C       SETC  '&SYSLIST(&I)'\n&C       EQU   &L\n         AGO   .LOOP2\n\n.EXIT    ANOP  ,\n         MEXIT\n.SYM     AIF   ('&NAME' EQ '').NONAME\n         AIF   (K'&NAME GT 7).LENGT7\n&NAME    DC    &A.(&L,&OFFSET)\n&I       SETA  0\n.LOOP3   ANOP  ,\n&I       SETA  &I+1\n         AIF   (&I GT N'&SYSLIST).SETL\n         AIF   ('&SYSLIST(&I)'(1,1) NE '''').ERROR2\n         DC    C&SYSLIST(&I)\n&I       SETA  &I+1\n         AIF   ('&SYSLIST(&I)' EQ '').LOOP3\n&C       SETC  '&SYSLIST(&I)'\n&C       EQU   *-&NAME-4\n         AGO   .LOOP3\n.SETL    ANOP  ,\n&NAME.L  EQU   *-&NAME                 TOTAL SEGMENT LENGTH\n\n         MEXIT\n.NONAME  MNOTE 8,'NAME Operand Required With TYPE=SYMBOLIC'\n         MEXIT\n.LENGT7  MNOTE 8,'NAME Must Be 1-7 Chars With TYPE=SYMBOLIC'\n         MEXIT\n.ERROR   MNOTE 8,'Message Segments Should Be Entered In Quotes'\n         MEXIT\n.ERROR2  MNOTE 8,'Message Segments Should Be Entered In Quotes'\n&NAME.L  EQU   *-&NAME                 TOTAL SEGMENT LENGTH\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#MVCL": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x005\\x005\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 53, "newlines": 53, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&NAME    #MVCL &TO,&FROM,&LEN=\n.*\n.*       MVCL USING REGISTERS - 0,1 & 14,15\n.*\n         LCLC  &L,&REG\n         AIF   ('&FROM' EQ '').MVC0900  ERROR - MISSING FIELD\n         AIF   ('&TO' EQ '').MVC1000    ERROR - MISSING FIELD\n         AIF   ('&NAME' EQ '').MVC0100\n&NAME    DS    0H\n.*\n.MVC0100 ANOP\n         AIF   ('&TO'(1,1) EQ '(').MVC0200 FIELD IS A REGISTER\n         LA    0,&TO               >>---> OUTPUT FIELD\n         AGO   .MVC0300\n.MVC0200 ANOP\n&REG     SETC  '&TO'(2,K'&TO-2)\n         AIF   ('&REG' EQ '0' OR '&REG' EQ 'R0').MVC0300\n         AIF   ('&REG' EQ 'r0').MVC0300\n         LR    0,&REG              >>---> OUTPUT FIELD\n.MVC0300 ANOP\n         AIF   ('&LEN' NE '').MVC0400\n         AIF   ('&TO'(1,1) EQ '(').MVC1100\n         LA    1,L'&TO             LOAD OUTPUT LENGTH\n         AGO   .MVC0600             CONTINUE\n.MVC0400 ANOP\n         AIF   ('&LEN'(1,1) EQ '(').MVC0500   LENGTH IS A REGISTER\n         LA    1,&LEN              LOAD OUTPUT LENGTH\n         AGO   .MVC0600             CONTINUE\n.MVC0500 ANOP\n&REG     SETC  '&LEN'(2,K'&LEN-2)\n         AIF   ('&REG' EQ '1' OR '&REG' EQ 'R1').MVC0600\n         AIF   ('&REG' EQ 'r1').MVC0600\n         LR    1,&REG              LOAD OUTPUT LENGTH\n.MVC0600 ANOP  ,\n         AIF   ('&FROM'(1,1) EQ '(').MVC0700 FIELD IS A REGISTER\n         LA    14,&FROM            >>---> INPUT FIELD\n         AGO   .MVC0800\n.MVC0700 ANOP\n&REG     SETC  '&FROM'(2,K'&FROM-2)\n         AIF   ('&REG' EQ '14' OR '&REG' EQ 'R14').MVC0800\n         AIF   ('&REG' EQ 'r14').MVC0800\n         LR    14,&REG             >>---> INPUT FIELD\n.MVC0800 ANOP  ,\n         LR    15,1                COPY INPUT LENGTH TO OUTPUT LENGTH\n         MVCL  0,14                MOVE CHARACTER LONG\n         MEXIT\n.MVC0900 MNOTE 8,'MVC001A - \"TO\" FIELD NOT SPECIFIED'\n         MEXIT\n.MVC1000 MNOTE 8,'MVC002A - \"FROM\" FIELD NOT SPECIFIED'\n         MEXIT\n.MVC1100 MNOTE 8,'MVC002A - \"LENGTH\" NOT SPECIFIED'\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#NULL": {"ttr": 4099, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x14\\x11/\\x01\\x14\\x11/\\x12H\\x00\\x05\\x00\\x05\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-04-22T00:00:00", "modifydate": "2014-04-22T12:48:32", "lines": 5, "newlines": 5, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    #NULL ,\n         AIF   ('&NAME' EQ '').MEND\n&NAME    DS    0H\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PATCH": {"ttr": 4101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x14\\x11/\\x01\\x14\\x11/\\x12H\\x00\"\\x00\"\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-04-22T00:00:00", "modifydate": "2014-04-22T12:48:32", "lines": 34, "newlines": 34, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&LABEL   #PATCH &F=5,&ORG=\n         GBLA  &#PATCHN\n         GBLB  &USINGRELATIVE           RELATIVE BASE\n         LCLA  &N\n         LCLC  &BEGIN\n         LCLC  &TYPE\n&#PATCHN SETA  &#PATCHN+1\n&N       SETA  &#PATCHN\n&BEGIN   SETC  '&SYSECT'\n&TYPE    SETC  'S(*)'\n         AIF   (NOT &USINGRELATIVE).PAT0100\n&TYPE    SETC  'AL2(*-@PATCH&N)'\n.PAT0100 ANOP  ,\n         AIF   ('&ORG' EQ '').PAT0200\n&BEGIN   SETC  '&ORG'\n.PAT0200 PUSH  PRINT\n         PRINT ON,GEN,DATA\n         AIF   ('&F' EQ 'S').PAT0300\n@PSIZE&N EQU   ((*-&BEGIN+99)/100)*&F\n@PATCH&N DC    28&TYPE                  MODULE PATCH AREA\n         ORG   @PATCH&N\n&LABEL   DC    ((@PSIZE&N+1)/2)&TYPE\n         ORG   ,\n         AGO   .MEXIT\n.PAT0300 ANOP  ,\n         AIF   ('&LABEL' NE '').PAT0400\n@PATCH&N DC    28&TYPE                  MODULE PATCH AREA\n         AGO   .MEXIT\n.PAT0400 ANOP  ,\n&LABEL   DC    28&TYPE                  MODULE PATCH AREA\n.MEXIT   ANOP  ,\n         POP   PRINT\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RBL": {"ttr": 4103, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x14\\x11/\\x01\\x14\\x11/\\x12H\\x00\\x0e\\x00\\x0e\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-04-22T00:00:00", "modifydate": "2014-04-22T12:48:32", "lines": 14, "newlines": 14, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&LABEL   #RBL  &REG,&ADDRESS\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*       This macro enables you to load an acon into a register       *\n.*       when there is no code base register.                         *\n.*       i.e.  it works with relative addressing                      *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n         CNOP  0,4\n&LABEL   BRAS  &REG,*+8            address the adcon\n         DC    A(&ADDRESS)\n         L     &REG,0(&REG,0)      Pick up address (use 0 base)\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#REGS": {"ttr": 4105, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x14\\x11/\\x01\\x14\\x11/\\x12H\\x005\\x005\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-04-22T00:00:00", "modifydate": "2014-04-22T12:48:32", "lines": 53, "newlines": 53, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         #REGS &TYPE=BAL\n         GBLB  &REGS,&REGS##(3)\n         AIF   ('&TYPE' EQ 'NONE').COMMON\n         AIF   ('&TYPE' NE 'AR' AND '&TYPE' NE 'BOTH').BAL\n         AIF   (&REGS##(1)).MEXIT\n&REGS##(1) SETB 1\nAR0      EQU   0                        ACCESS REGISTER EQUATES\nAR1      EQU   1\nAR2      EQU   2\nAR3      EQU   3\nAR4      EQU   4\nAR5      EQU   5\nAR6      EQU   6\nAR7      EQU   7\nAR8      EQU   8\nAR9      EQU   9\nAR10     EQU   10\nAR11     EQU   11\nAR12     EQU   12\nAR13     EQU   13\nAR14     EQU   14\nAR15     EQU   15\n         AIF   ('&TYPE' NE 'BOTH').COMMON\n.BAL     AIF   (&REGS##(2)).MEXIT\n&REGS##(2) SETB 1\n         AIF   (&REGS).COMMON           &REGS ALSO IN IBM YREGS MACRO\n&REGS    SETB  1\nR0       EQU   0                        STANDARD REGISTER EQUATES\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n.*\n.COMMON  AIF   (&REGS##(3)).MEXIT\n&REGS##(3) SETB 1\n         IEZBITS ,                      EQUATES FOR BIT SETTINGS\nFF       EQU   255                      GENERAL PURPOSE EQUATES\nBF       EQU   255-C' '\nX0       EQU   00\nVL       EQU   X'80000000'\n.MEXIT   MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RELBR": {"ttr": 4107, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x14\\x11/\\x01\\x14\\x11/\\x12H\\x00P\\x00P\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-04-22T00:00:00", "modifydate": "2014-04-22T12:48:32", "lines": 80, "newlines": 80, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         #RELBR &OPSYN=YES\n         GBLA  &SYSALVL\n         GBLB  &RELBRON            Only want to do this once\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*       This macro enables the conversion of a traditional           *\n.*       register based module to a relative branch module.           *\n.*                                                                    *\n.*       It is recommended that a base register still be used for     *\n.*       the first page of code and a base register be used for       *\n.*       the data area (constants and literals).                      *\n.*                                                                    *\n.*       All B type instructions can still be coded as before,        *\n.*       they will automatically be converted to their relative       *\n.*       equivalent. If for some reason a B type instruction is       *\n.*       required, simply code it with a # in front.                  *\n.*                                                                    *\n.*       e.g.   to code a branch to 4 beyond R14 use:                 *\n.*                                                                    *\n.*       #B    4(,R14)                                                *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n         AIF   (&RELBRON).MEXIT    Not the first time\n&RELBRON SETB  1                   Set true\n         PUSH  PRINT\n         PRINT  OFF\n         AIF   ('&OPSYN' EQ 'NO').NOOP\n#BC      OPSYN BC\n#B       OPSYN B\n#BE      OPSYN BE\n#BNE     OPSYN BNE\n#BO      OPSYN BO\n#BNO     OPSYN BNO\n#BZ      OPSYN BZ\n#BNZ     OPSYN BNZ\n#BH      OPSYN BH\n#BNH     OPSYN BNH\n#BL      OPSYN BL\n#BNL     OPSYN BNL\n#BM      OPSYN BM\n#BNM     OPSYN BNM\n#BP      OPSYN BP\n#BNP     OPSYN BNP\n#BAL     OPSYN BAL\n#BAS     OPSYN BAS\n#BCT     OPSYN BCT\n#BXH     OPSYN BXH\n#BXLE    OPSYN BXLE\n.*\nBC       OPSYN BRC\nB        OPSYN J\nBE       OPSYN JE\nBNE      OPSYN JNE\nBO       OPSYN JO\nBNO      OPSYN JNO\nBZ       OPSYN JZ\nBNZ      OPSYN JNZ\nBH       OPSYN JH\nBNH      OPSYN JNH\nBL       OPSYN JL\nBNL      OPSYN JNL\nBM       OPSYN JM\nBNM      OPSYN JNM\nBP       OPSYN JP\nBNP      OPSYN JNP\nBAL      OPSYN BRAS\nBAS      OPSYN BRAS\nBCT      OPSYN BRCT\nBXH      OPSYN BRXH\nBXLE     OPSYN BRXLE\n.NOOP    ANOP  ,\n         SYSSTATE TEST\n         AIF   (&SYSALVL NE 0).SKIPALL\n         PRINT  ON\n         SYSSTATE ARCHLVL=1\n.SKIPALL ANOP  ,\n         POP   PRINT\n.MEXIT   MEXIT ,\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#RLIF": {"ttr": 4109, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x14\\x11/\\x01\\x14\\x11/\\x12H\\x00\\x11\\x00\\x11\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-04-22T00:00:00", "modifydate": "2014-04-22T12:48:32", "lines": 17, "newlines": 17, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&LABEL   #RLIF &REG,&ADDRESS\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*       This macro enables you to load an acon into a register       *\n.*       when there is no code base register.                         *\n.*       i.e.  it works with relative addressing (requires #START)    *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n         GBLB  &STF(24)\n         AIF   (&STF(19)).REL\n&LABEL   L     &REG,&ADDRESS       Normal load\n         MEXIT ,\n.REL     ANOP  ,\n&LABEL   LARL  &REG,&ADDRESS       Pick up address\n         L     &REG,0(,&REG)       Pick up actual value\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#RLLI": {"ttr": 4111, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x14\\x11/\\x01\\x14\\x11/\\x12H\\x00\\x0b\\x00\\x0b\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-04-22T00:00:00", "modifydate": "2014-04-22T12:48:33", "lines": 11, "newlines": 11, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&LABEL   #RLLI &REG,&LITERAL\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*       This macro enables you to get the address of a 'literal'     *\n.*       in a baseless routine. The literal can be anything that is   *\n.*       the operand of a DC instruction                              *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n&LABEL   LARL  &REG,=&LITERAL    address the literal\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#SET": {"ttr": 2051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00\\x9b\\x00\\x9b\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 155, "newlines": 155, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    #SET  &Z\n         GBLA  &DCLDSW#             COUNTER OF # OF SWITCH BYTES\n         GBLA  &DCLGSW#             COUNTER OF # OF GENERIC BYTES\n         GBLB  &DCLDSWD(99)         DEFER DECLARE INDICATORS\n         GBLC  &DCLDSWN(99)         SWITCH BYTE NAMES\n         GBLC  &DCLDSWB(800)        SWITCH BIT NAMES\n         GBLC  &DCLGSWN(99)         GENERIC SWITCH BYTE NAMES\n         GBLC  &DCLGSWB(99)         GENERIC SWITCH BIT PREFIXES\n         LCLA  &A,&B,&C,&D,&E       LOCAL WORK SYMBOLS\n         LCLB  &F(20),&G\n         LCLC  &K(20),&L(20),&M,&N,&O,&P,&Q,&SW(20),&MK(20),&MSK(20)\n         AIF   (N'&SYSLIST EQ 0).SET2900   ERROR - NO SWITCHES\n.*\n.* FIRST ISOLATE ALL SWITCHES\n.*\n&O       SETC  '&NAME'              BUT FIRST GRAB THE LABEL\n         AIF   ('&SYSLIST(1)'(1,1) EQ '(').SET0400   LIST, CONTINUE\n&A       SETA  N'&SYSLIST           GET # PARAMETERS\n&B       SETA  1                    INDEX INTO PARAMETERS\n&C       SETA  1                    INDEX INTO FOUND SWITCHES\n.SET0100 ANOP\n&SW(&C)  SETC  '&SYSLIST(&B)'       ISOLATE SWITCH\n&MK(&C)  SETC  'ON'                 DEFAULT MASK TO ON\n         AIF   (&B EQ &A).SET0800   NO MORE, EXIT\n         AIF   ('&SYSLIST(&B+1)' EQ '').SET0300   NO MASK, CONTINUE\n         AIF   ('&SYSLIST(&B+1)' EQ 'ON').SET0300   ON, CONTINUE\n         AIF   ('&SYSLIST(&B+1)' EQ 'OFF').SET0200   OFF, CONTINUE\n         AIF   ('&SYSLIST(&B+1)' EQ 'FLIP').SET0200   FLIP, CONTINUE\n        MNOTE 4,'SET001I - Mask &SYSLIST(&B+1) Invalid, ''ON'' Assumed'\n         AGO   .SET0300             CONTINUE\n.SET0200 ANOP\n&MK(&C)  SETC  '&SYSLIST(&B+1)'     SAVE MASK\n.SET0300 ANOP\n&C       SETA  &C+1                 BUMP FOUND INDEX\n&B       SETA  &B+2                 BUMP PARAMETER INDEX\n         AIF   (&B GT &A).SET0900   NO MORE, EXIT\n         AGO   .SET0100             LOOP THROUGH ALL SWITCHES\n.SET0400 ANOP\n&M       SETC  'ON'                 DEFAULT MASK TO ON\n         AIF   ('&SYSLIST(2)' EQ '' OR '&SYSLIST(2)' EQ 'ON').SET0600\n         AIF   ('&SYSLIST(2)' EQ 'OFF').SET0500   OFF, CONTINUE\n         AIF   ('&SYSLIST(2)' EQ 'FLIP').SET0500   FLIP, CONTINUE\n         MNOTE 4,'SET002I - Mask &SYSLIST(2) Invalid, ''ON'' Assumed'\n         AGO   .SET0600             CONTINUE\n.SET0500 ANOP\n&M       SETC  '&SYSLIST(2)'        SAVE MASK\n.SET0600 ANOP\n&A       SETA  N'&Z                 PICK UP NUMBER OF SWITCHES\n&B       SETA  1                    INDEX INTO SWITCHES\n&C       SETA  1                    INDEX INTO FOUND SWITCHES\n.SET0700 ANOP\n&SW(&C)  SETC  '&Z(&B)'             SAVE SWITCH\n&MK(&C)  SETC  '&M'                 SAVE MASK\n&C       SETA  &C+1                 BUMP FOUND INDEX\n&B       SETA  &B+1                 BUMP SWITCH INDEX\n         AIF   (&B GT &A).SET0900   FINISHED, EXIT\n         AGO   .SET0700             LOOP THRU ALL SWITCHES\n.SET0800 ANOP\n&C       SETA  &C+1                 KEEP THE NEXT INSTRUCTION HAPPY\n.*\n.* THEN LOCATE THE SWITCHES\n.*\n.SET0900 ANOP\n&A       SETA  &C-1                 GET # SWITCHES REQUESTED\n         AIF   (&A EQ 0).SET2900    ERROR - NO SWITCHES\n&B       SETA  0                    INDEX INTO SUPPLIED SWITCHES\n&C       SETA  &DCLDSW#*8           POINT TO LAST DECLARED SWITCH\n&D       SETA  1                    INDEX INTO # DECLARED SWITCHES\n&E       SETA  0                    COUNTER OF # BYTES FOUND\n.SET1000 AIF   (&B EQ &A).SET2200   FINISHED, EXIT SEARCH\n&B       SETA  &B+1                 POINT TO NEXT SWITCH\n&M       SETC  '&SW(&B)'            GRAB SUPPLIED SWITCH\n.SET1100 AIF   (&DCLDSW# EQ 0).SET1300   NO DECLARED, TRY GENERICS\n.SET1200 AIF   ('&M' EQ '&DCLDSWB(&D)').SET1500   FOUND HIM\n&D       SETA  &D+1                 INDEX TO NEXT BIT\n         AIF   (&D LE &C).SET1200   KEEP LOOKING\n.SET1300 AIF   (&DCLGSW# EQ 0).SET3000   ERROR - SWITCH NOT FOUND\n&D       SETA  1                    INDEX INTO # GENERIC SWITCHES\n.SET1400 AIF   ('&M'(1,K'&DCLGSWB(&D)) EQ '&DCLGSWB(&D)').SET1600\n&D       SETA  &D+1                 NOT HIM, INDEX TO NEXT PREFIX\n         AIF   (&D LE &DCLGSW#).SET1400   KEEP LOOKING\n         AGO   .SET3000             ERROR - SWITCH NOT FOUND\n.*\n.* INCOMING SWITCH IS A DECLARED SWITCH\n.*\n.SET1500 ANOP\n&D       SETA  (&D+7)/8             INDEX TO DECARED BYTE NAME TABLE\n&N       SETC  '&DCLDSWN(&D)'       GET BYTE NAME\n         AGO   .SET1700             CONTINUE\n.*\n.* INCOMING SWITCH IS A GENERIC SWITCH\n.*\n.SET1600 ANOP\n&N       SETC  '&DCLGSWN(&D)'       GET BYTE NAME\n.*\n.* ADD SWITCH BYTE AND SWITCH BIT NAME TO A TABLE AS FOLLOWS:\n.*\n.*    - IF THE BYTE NAME IS NOT IN THE TABLE, ADD IT\n.*    - IF IT IS BUT THE MASKS DONT MATCH, ADD IT AS A NEW ENTRY\n.*    - OTHERWISE, CONCATENATE THE NEW SWITCH BIT NAME TO THE OLD\n.*      SWITCH BIT NAME, WITH A '+' SIGN IN BETWEEN\n.*\n.SET1700 AIF   (&E EQ 0).SET2000    FIRST ENTRY, CONTINUE\n&D       SETA  1                    INDEX INTO FOUND TABLES\n.SET1800 AIF   ('&N' EQ '&K(&D)').SET1900   MATCHING NAME, CONTINUE\n&D       SETA  &D+1                 POINT TO NEXT ENTRY\n         AIF   (&D LE &E).SET1800   KEEP LOOKING\n         AGO   .SET2000             THIS GUY IS NEW\n.SET1900 AIF   ('&MK(&B)' EQ '&MSK(&D)').SET2100   SAME SEX TOO..\n&D       SETA  &D+1                 POINT TO NEXT ENTRY\n         AIF   (&D LE &E).SET1800   KEEP LOOKING\n.*\n.* THIS ENTRY IS A NEW BYTE NAME\n.*\n.SET2000 ANOP\n&E       SETA  &E+1                 BUMP COUNTER OF # FOUND\n&K(&E)   SETC  '&N'                 SAVE BYTE NAME\n&L(&E)   SETC  '&M'                 SAVE BIT NAME\n&MSK(&E) SETC  '&MK(&D)'            SAVE MASK\n         AGO   .SET1000             GO, GET NEXT SUPPLIED SWITCH\n.*\n.* THIS ENTRY IS AN OLD ENTRY\n.*\n.SET2100 ANOP\n&L(&D)   SETC  '&L(&D).+&M'         CONCATENATE SWITCH BIT NAMES\n         AGO   .SET1000             GO, GET NEXT SUPPLIED SWITCH\n.*\n.* NOW TO DO SOME REAL WORK\n.*\n.SET2200 AIF   (&E EQ 0).SET2900    ERROR - NO SWITCHES CODED\n&A       SETA  1                    INDEX INTO FOUND SWITCHES\n.SET2300 ANOP\n.SET2400 AIF   ('&MSK(&A)' EQ '').SET2500   OMITTED, ASSUME ON\n         AIF   ('&MSK(&A)' EQ 'ON').SET2500   ON, CONTINUE\n         AIF   ('&MSK(&A)' EQ 'OFF').SET2600   OFF, CONTINUE\n         AIF   ('&MSK(&A)' EQ 'FLIP').SET2700   FLIP, CONTINUE\n         MNOTE 4,'SET003I - Mask &MSK(&A) Invalid, ''ON'' Assumed'\n.SET2500 ANOP\n&O       OI    &K(&A),&L(&A)\n         AGO   .SET2800             CONTINUE\n.SET2600 ANOP\n&O       NI    &K(&A),255-(&L(&A))\n         AGO   .SET2800             CONTINUE\n.SET2700 ANOP\n&O       XI    &K(&A),&L(&A)\n.SET2800 ANOP\n&O       SETC  ''                   CLEAR LABEL\n&A       SETA  &A+1                 BUMP INDEX OF SWITCHES\n         AIF   (&A LE &E).SET2300   LOOP THRU ALL SWITCHES\n         MEXIT                      EXIT\n.SET2900 MNOTE 8,'SET004A - No Switches Specified'\n         MEXIT                      EXIT\n.SET3000 MNOTE 8,'SET005A - Switch &M Not Declared'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#SETRC": {"ttr": 4113, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x14\\x11/\\x01\\x14\\x11/\\x12H\\x00\\x17\\x00\\x17\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-04-22T00:00:00", "modifydate": "2014-04-22T12:48:33", "lines": 23, "newlines": 23, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&NAME    #SETRC &R,&FIELD=,&FORCE=N\n&NAME    #NULL ,\n         GBLB  &STWA                ON MEANS A WORK AREA EXISTS\n         GBLC  &STPREF              WORK AREA PREFIX\n         LCLC  &F                   USED TO HOLD FIELD NAME\n         AIF   ('&FIELD' EQ '').SET0100   NO FIELD, CONTINUE\n&F       SETC  '&FIELD'             PICK UP FIELD NAME\n         AGO   .SET0200             CONTINUE\n.SET0100 AIF   (NOT &STWA).SET0600   ERROR - NO FIELD PROVIDED\n&F       SETC  '&STPREF.RCODE'      PICK UP WORK AREA RC FIELD\n.SET0200 AIF   ('&R' EQ '').SET0400 ASSUME R15 HAS RETURN CODE\n         AIF   ('&R'(1,1) EQ '(').SET0300   R IS A REGISTER\n         LA    R15,&R               R15 HAS RETURN CODE\n         AGO   .SET0400             CONTINUE\n.SET0300 LR    R15,&R(1)            R15 HAS RETURN CODE\n.SET0400 AIF   ('&FORCE' EQ 'Y' OR  '&FORCE' EQ 'YES').SET0500\n         CL    R15,&F               COMPARE NEW RC TO CURRENT RC\n         JNH   *+8                  KEEP THE HIGHEST\n.SET0500 ST    R15,&F               RETURN CODE\n         MEXIT                      EXIT\n.SET0600 MNOTE 8,'SET001I - MISSING FIELD NAME'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SIFT": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00@D\\x01\\x082o\\x01\\x082o!\\x10\\x00X\\x00X\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 64, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 88, "newlines": 88, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    #SIFT &VEC,&REG,&VER=YES,&ERR=,&WORK=R0\n         LCLA  &I,&J\n         LCLB  &B\n         LCLC  &R,&ERRLBL\n&ERRLBL  SETC  'SIF&SYSNDX.E'\n&R       SETC  'R15'                    SET DEFAULT INDEX REG\n&B       SETB  ('&VEC(N'&VEC)' EQ '*')  IF NOOP AS LAST ELEMENT\n         AIF   ('&REG' EQ '').NE\n&R       SETC  '&REG'                   OR OVERRIDE REG\n.*\n.NE      AIF   ('&VER' EQ 'YES').VERIFY\n*   CODE OPTIMIZED FOR VER=NO\n&NAME    B     *+4(&R)                  ENTER BRANCH TABLE\n         AGO   .SIFT\n.VERIFY  ANOP  ,\n         AIF   (N'&VEC GT 4).BRTAB\n.XPLICIT ANOP  ,\n&I       SETA  0\n&NAME    LTR   &R,&R                    CHECK IF ZERO\n.CHLOOP  AIF   (&I GE N'&VEC).CHEND\n&J       SETA  &I*4\n&I       SETA  &I+1\n         AIF   (&I EQ 1).BIF\n         C     &R,=F'&J'                CHECK CODE\n.BIF     AIF   ('&VEC(&I)' EQ '').ERRBX\n         AIF   ('&VEC(&I)' EQ '*').ENDBRX\n         BE    &VEC(&I)                 BR IF EQUAL\n         AGO   .CHLOOP\n.ERRBX   BE    &ERRLBL                  TO ERROR IF EQUAL\n         AGO   .CHLOOP\n.ENDBRX  ANOP  ,\n         BE    &ERRLBL+4                TO NSI AFTER MACRO\n         AGO   .CHLOOP\n.CHEND   ANOP  ,\n         AIF   ('&ERR' EQ '').EXAST1\n&ERRLBL  B     &ERR                     ERROR BRANCH\n         MEXIT ,\n.*\n.EXAST1  ANOP  ,\n&ERRLBL  EX    0,*                      ERROR  (ABEND 0C3)\n         MEXIT ,\n.*\n.BRTAB   ANOP\n&NAME    LCR   &WORK,&R\n&I       SETA  1                        BYPASS ZERO CASE\n         AIF   ('&VEC(1)' EQ '').ERRB\n         AIF   ('&VEC(1)' EQ '*').ENDBR\n         BZ    &VEC(1)                  BRANCH IF ZERO CODE\n         AGO   .MORECHK\n.ERRB    BZ    &ERRLBL                  BRANCH IF ZERO CODE ERROR\n         AGO   .MORECHK\n.ENDBR   ANOP  ,\n&J       SETA  N'&VEC*4-4*&B\n         BZ    &ERRLBL+&J               BRANCH IF ZERO CODE\n.MORECHK NR    &WORK,&R                 CHECK CODE\n         SRA   &WORK,2                  MULTIPLE OF 4?\n         BNP   &ERRLBL                  NO, ERROR\n&J       SETA  4*(N'&VEC-1)             CONSTANT GOOD INDEX RANGE\n         CL    &R,=F'&J'                OVER MAX?\n         BNH   &ERRLBL.(&R)             ENTER BRANCH TABLE IF GOOD\n         AIF   ('&ERR' EQ '').BLOW\n&ERRLBL  B     &ERR                     ELSE GO TO ERROR\n         AGO   .SIFT\n.*\n.BLOW    ANOP  ,                        VER=YES, NO ERR EXIT\n&ERRLBL  EX    0,*                      ELSE BLOW UP  (ABEND 0C3)\n.*\n.SIFT    ANOP  ,\n&I       SETA  &I+1\n         AIF   (&I GT N'&VEC).MEND\n         AIF   ('&VEC(&I)' EQ '').EXAST NULL ARG\n         AIF   ('&VEC(&I)' EQ '*').NOP  '*' -- GEN NO-OP\n         B     &VEC(&I)                  *\n         AGO   .SIFT\n.*\n.EXAST   AIF   ('&ERR' EQ '' AND '&VER' EQ 'NO').EX0C3\n         B     &ERRLBL                   *  INVALID CASE\n         AGO   .SIFT\n.EX0C3   EX    0,*                       *  INVALID CASE\n         AGO   .SIFT\n.*\n.NOP     AIF   (&I EQ N'&VEC).MEND       '*' TABLE ENTRY\n&J       SETA  4*(N'&VEC-&I+1)-4*&B\n         B     *+&J                      *  TO NSI AFTER MACRO\n         AGO   .SIFT                    CLOSE LOOP\n.*\n.MEND    MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#START": {"ttr": 3585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x14\\x11/\\x01\\x14\\x11/\\x12H\\x03\\xfc\\x03\\xfc\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-04-22T00:00:00", "modifydate": "2014-04-22T12:48:33", "lines": 1020, "newlines": 1020, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    #START ,                       #START MACRO                   X\n               &AMODE=,                 ADDRESSING MODE                X\n               &APARS=5,                RESERVE 5 APAR SLOTS           X\n               &BASE=,                  1 OR MORE BASE REGISTERS       X\n               &BNDRY=,                 WHAT GETMAIN TO LOOK LIKE      X\n               &CAPREG=,                REGISTER TO SAVE CAP WORD      X\n               &CONSTANT=,              REQUEST A CONSTANT SECTION     X\n               &CONPREF=,               REQUEST A LABELLED USING       X\n               &COPY=NO,                GENERATE COPYRIGHT             X\n               &COPYYR=,                COPYRIGHT YEAR                 X\n               &CSECT=YES,              GENERATE A CSECT STATEMENT     X\n               &ENTRY=YES,              GENERATE AN ENTRY STATEMENT    X\n               &ENUC=,                  EXTENDED NUCLEUS NAME          X\n               &EXTKEY=,                SVC EXECUTION KEY              X\n               &ID=,                    GENERATE ID INFORMATION        X\n               &ISA=,                   INITIAL STACK AREA SIZE        X\n               &LEVEL=,                 MODULE LEVEL (SMP ID)          X\n               &LINK=YES,               LINK USED 'BALR 14,15'         X\n               &LOC=,                   WHERE TO GETMAIN FROM          X\n               &OPSYN=YES,              USE #RELBR IF REQUIRED         X\n               &PATCH=,                 PATCH AREA REQUIRED            X\n               &PREFIX=,                PREFIX FOR GENERATED SYMBOLS   X\n               &REG0=,                  REGISTER 0 TO BE SAVED         X\n               &REG1=,                  REGISTER 1 TO BE SAVED         X\n               &REGS64=NO,              RTN USES 64 BIT REGS           X\n               &#REGS=BAL,              TYPE OF REGISTER EQUATES       X\n               &RMODE=,                 RESIDENCY MODE                 X\n               &RSECT=NO,               READ-ONLY CONTROL SECTION      X\n               &SAVE=YES,               SAVE REGISTERS (YES/NO)        X\n               &SP=,                    SUBPOOL FOR WORK DSECT         X\n               &SPLEVEL=,               MVS LEVEL (1/2)                X\n               &STORAGE=N,              USE STORAGE OR GETMAIN         X\n               &SVAREA=YES,             SAVE AREA REQUIRED (YES/NO)    X\n               &SVC=,                   ROUTINE IS/IS NOT AN SVC       X\n               &USING=,                 AREAS TO BE MAPPED             X\n               &WKCSECT=,               NAME OF WORK CSECT             X\n               &WKDSECT=                NAME OF WORK DSECT\n.*\n.* DEFINE SYMBOLS NEEDED\n.*\n         GBLA  &STWAC                   COUNTER FOR DEFERED WA DEFINES\n         GBLA  &#COPYSZ\n         GBLB  &USINGRELATIVE           RELATIVE BASE\n         GBLB  &STBEG                   START/BEGIN PRESENT\n         GBLB  &STWA                    INDICATES CSECT HAS A WORK AREA\n         GBLB  &STF(24)                 CONTROL FLAG BITS, AS FOLLOWS:\n         GBLB  &GOIFREL                 USE RELATIVE\n.*                                       (01) - PROC OPTION CODED\n.*                                       (02) - MAIN OPTION CODED\n.*                                       (03) - LIFO OPTION CODED\n.*                                       (04) - WKCSECT OPTION CODED\n.*                                       (05) - WKDSECT OPTION CODED\n.*                                       (06) - #START HAS BEEN CODED\n.*                                       (07) - ROUTINE IS AN SVC\n.*                                       (08) - WORK FIELDS WANTED\n.*                                       (09) - SVAREA=NO OPTION\n.*                                       (10) - SAVE=YES OPTION\n.*                                       (11) - RSECT=YES OPTION\n.*                                       (12) - SVC=(YES,BRANCH)\n.*                                       (13) - ENUC CAPPING\n.*                                       (14) - PATCH AREA REQUEST\n.*                                       (15) - MODID LABEL GENERATED\n.*                                       (16) - CONSTANT SECTION\n.*                                       (17) - STORAGE=YES\n.*                                       (18) - EXTKEY=\n.*                                       (19) - RELATIVE ADDR\n.*                                       (20) - CONSTANT SECT\n.*                                       (21) - LABELED USING  FOR\n.*                                              CONSTANT CSECT\n.*                                       (22) - 64 BIT REGS\n.*                                       (23) - #BAKR USED\n         GBLC  &#COPYYR\n         GBLC  &STACREG                 CAPWORD SAVE REGISTER\n         GBLC  &STAGREG                 GET/FREEMAIN FORMAT\n         GBLC  &STAMODE                 MODULE'S CAPPED AMODE\n         GBLC  &STAXKEY                 SVC EXECUTION KEY\n         GBLC  &STISASZ                 LIFO ISA SIZE\n         GBLC  &STLEVEL                 MODULE LEVEL\n         GBLC  &STNAME                  MAIN CSECT NAME\n         GBLC  &STPREF                  PREFIX CHARACTERS\n         GBLC  &STSPN                   SUBPOOL NUMBER\n         GBLC  &STWAD(1000)             WORK AREA DEFERED STACK\n         GBLC  &STWANAM                 WORK AREA NAME\n         GBLC  &SYSSPLV                 SPLEVEL\n         GBLC  &STA_CONSTANT_SECTION    NAME OF CONSTANT SECTION\n         GBLC  &STA_CONSTANT_BASE       BASE OF CONSTANT SECTION\n         GBLC  &STA_CONSTANT_LABEL      LABELLED CSECT\n         GBLC  &STRMODE                 RMODE USED\n         GBLC  &STMODEA                 AMODE USED\n         GBLB  &STAMODE31               AMODE 31 (#STACK)\n         LCLA  &A,&B,&C,&D,&E,&Q        LOCAL\n         LCLB  &F,&G,&H,&I,&J,&QQ,&R2,&R3,&R4,&RRREGS WORK\n         LCLB  &CR2,&CR3,&CR4      FOR CONSTANT SECT REGS\n         LCLC  &CB                 CONSTANT BASE\n         LCLC  &K,&L,&M,&N,&O,&P,&W     SYMBOLS\n.*\n.* INITIALIZE SYMBOLS, SET UP PREFIX, PICK UP ALL OPERANDS\n.*\n&USINGRELATIVE SETB 0               DEFAULT NOT RELATIVE\n&GOIFREL SETB  0\n&STAXKEY SETC  '&EXTKEY'\n&STLEVEL SETC  '&LEVEL'\n&STMODEA SETC  ''\n&STRMODE SETC  ''\n         SPLEVEL TEST                   GET ORIGINAL SPLEVEL\n&STAGREG SETC  'RU'                     GET/FREEMAIN FORMAT\n         AIF   ('&LOC' EQ '').ST00100\n&W       SETC  ',LOC=&LOC'\n.ST00100 ANOP  ,\n.*\n&STWAC   SETA  1                        INITIALIZE WORK FIELD STACK\n&STBEG   SETB  1                        START/BEGIN PRESENT\n&STWA    SETB  0                        CLEAR ALL GLOBAL SYMBOLS\n&STF(1)  SETB  0\n&STF(2)  SETB  0\n&STF(3)  SETB  0\n&STF(4)  SETB  0\n&STF(5)  SETB  0\n&STF(6)  SETB  1                        FLAG TO SAY  #START\n&STF(7)  SETB  0\n&STF(9)  SETB  0\n&STF(10) SETB  0\n&STF(11) SETB  0\n&STF(13) SETB  0\n&STF(14) SETB  ('&PATCH' EQ 'YES' OR '&PATCH' EQ 'Y')\n&STF(14) SETB  (&STF(14) OR ('&PATCH' EQ '' AND '&WKDSECT' NE ''))\n&STF(17) SETB  ('&STORAGE'(1,1) EQ 'Y')\n&STF(18) SETB  ('&STAXKEY' NE '')\n&STF(19) SETB  ('&BASE' EQ 'REL' OR '&BASE' EQ 'RELATIVE' OR &STF(19))\n&STF(22) SETB  ('&REGS64' EQ 'Y' OR '&REGS64' EQ 'YES')\n&STF(23) SETB  0                    NOT #BAKR\n         AIF   (NOT &STF(19)).NRBS\n&USINGRELATIVE SETB 1               USING RELATIVE BASE\n&GOIFREL SETB  1\n.NRBS    ANOP   ,\n         AIF   (&STF(21)).ST00110\n&STA_CONSTANT_LABEL  SETC '&CONPREF'\n&STF(21) SETB  ('&CONPREF' NE '')\n.ST00110 ANOP  ,\n&#COPYYR SETC  ''                       PASS YEAR TO #COPY\n         AIF   ('&COPYYR' EQ '').ST00300\n&#COPYYR SETC  '&COPYYR'                PASS YEAR TO #COPY\n.ST00300 ANOP  ,\n&STWANAM SETC  ''\n&STAMODE SETC  ''\n&STACREG SETC  '&CAPREG'\n&QQ      SETB  ('&COPY' NE 'NO')        COPYRIGHT SWITCH\n         #COPY SET                      SET COPYRIGHT LENGTH\n.*\n.*\n         AIF   ('&NAME' EQ '').ST99010  ERROR - MISSING CSECT NAME\n         AIF   ('&CSECT'(1,1) EQ 'N').ST00400\n&STNAME  SETC  '&NAME'                  SAVE MAIN CSECT NAME\n.ST00400 ANOP  ,\n.*\n         AIF   ('&ENUC' EQ '' OR '&SYSSPLV' NE '2').ST00500\n&STNAME  SETC  '&ENUC'                  SAVE MAIN CSECT NAME\n.ST00500 ANOP  ,\n         AIF   ('&WKDSECT&WKCSECT' EQ '').ST00600\n         AIF   ('&SAVE' NE 'YES').ST99040\n         AIF   ('&SVAREA' NE 'YES').ST99050\n.ST00600 ANOP  ,\n.*\n&K       SETC  '&STNAME.XXX'(1,3)\n         AIF   ('&CSECT'(1,1) EQ 'Y').ST00700\n&K       SETC  '&NAME.XXX'(1,3)\n         AIF   ('&WKDSECT&WKCSECT' EQ '').ST00700\n&K       SETC  '&WKDSECT&WKCSECT.XXX'(1,3)\n.ST00700 ANOP  ,\n&STF(12) SETB  ('&SVC' EQ '(YES,BRANCH)')\n&G       SETB  ('&SVC' EQ 'YES' OR '&SVC' EQ '(YES)' OR &STF(12))\n         AIF   ('&SVC' NE '').ST00800\n&F       SETB  ('&K' EQ 'IGC' OR '&K' EQ 'IGG' OR '&K' EQ 'IGX')\n.ST00800 ANOP  ,\n&STF(7)  SETB  (&F OR &G)               SET SVC SWITCH\n.*\n         AIF   (NOT &STF(7)).ST01100\n         AIF   ('&WKCSECT' EQ '').ST00900\n         IHBERMAC 1020,WKCSECT,SVC\n&J       SETB  1\n.ST00900 ANOP  ,\n         AIF   ('&BASE' EQ '' OR &STF(19)).ST01000\n         IHBERMAC 1020,BASE,SVC\n&J       SETB  1\n.ST01000 ANOP  ,\n         AIF   (&J).MEND\n.*\n.ST01100 ANOP  ,\n         AIF   ('&PREFIX' EQ '').ST01300   NO PREFIX, CONTINUE\n         AIF   (K'&PREFIX GT 3).ST01200    PREFIX NEEDS TO BE CUT\n&STPREF  SETC  '&PREFIX'                ESTABLISH PREFIX\n         AGO   .ST01400                 CONTINUE\n.ST01200 ANOP  ,\n&STPREF  SETC  '&PREFIX'(1,3)           TRUNCATE PREFIX\n         AGO   .ST01400                 CONTINUE\n.ST01300 ANOP  ,\n&STPREF  SETC  '&K'                     SET PREFIX TO CSECT 3 CHAR\n.ST01400 ANOP  ,\n&P       SETC  '&STPREF'                MAKE PREFIX EASIER TO WORK WITH\n.*\n&STSPN   SETC  '253'                    SET DEFAULT SUBPOOL FOR SVC\n         AIF   (&STF(7)).ST01500        USE SUBPOOL 253 FOR SVC\n&STSPN   SETC  '1'                      SET DEFAULT SUBPOOL TO 1\n.ST01500 ANOP  ,\n         AIF   ('&SP' EQ '').ST01600    NO SUBPOOL CODED, CONTINUE\n&STSPN   SETC  '&SP'                    PICK UP SUBPOOL\n.ST01600 ANOP  ,\n.*\n&A       SETA  N'&SYSLIST               PICK UP NUMBER OF PARAMETERS\n&B       SETA  0                        INDEX OF PARAMETER\n.ST01700 ANOP  ,\n&B       SETA  &B+1                     POINT TO NEXT PARAMETER\n         AIF   (&B GT &A).ST02000       GOT ALL POSITIONAL PARAMETERS\n&K       SETC  '&SYSLIST(&B)'           PICK UP PARMATER\n         AIF   ('&K' NE 'PROC').ST01800 NOT PROC PARAMETER, CONT\n&STF(1)  SETB  1                        INDICATE PROC PARAMETER\n         AGO   .ST01700                 CONTINUE WITH NEXT PARAMETER\n.ST01800 ANOP  ,\n         AIF   ('&K' NE 'PROC(MAIN)').ST01900   NOT MAIN PARM, CONT\n&STF(1)  SETB  1                        INDICATE PROC PARAMETER\n&STF(2)  SETB  1                        INDICATE MAIN PARAMETER\n         AGO   .ST01700                 CONTINUE WITH NEXT PARAMETER\n.ST01900 ANOP  ,\n         AIF   ('&K' NE 'LIFO').ST01700 NOT LIFO PARM, CONTINUE\n&STF(3)  SETB  1                        INDICATE LIFO PARAMETER\n         AGO   .ST01700                 CONTINUE  WITH NEXT PARAMETER\n.ST02000 ANOP  ,\n         AIF   ('&WKDSECT' EQ '').ST02100   NO WORK DSECT, CONTINUE\n&STF(5)  SETB  1                        INDICATE WORK AREA IS A DSECT\n&STWA    SETB  1                        INDICATE WORK AREA IS PRESENT\n&STWANAM SETC  '&WKDSECT'               SAVE WORK AREA NAME\n.ST02100 ANOP  ,\n         AIF   ('&WKCSECT' EQ '').ST02200   NO WORK CSECT, CONTINUE\n         AIF   (&STF(1)).ST99030        ERROR - PROC\n         AIF   (&STF(5)).ST99020        ERROR - WKDSECT\n&STF(4)  SETB  1                        INDICATE WORK AREA IS A CSECT\n&STWA    SETB  1                        INDICATE WORK AREA IS PRESENT\n&STWANAM SETC  '&WKCSECT'               SAVE WORK AREA NAME\n.*\n         AIF   ('&SP' EQ '').ST02200    NO SUBPOOL PARAMETER, CONTINUE\n         IHBERMAC 1016,SP,WKCSECT\n.*\n.ST02200 ANOP  ,\n.*       REGS64 ONLY VALID WITH PROC OR PROC,LIFO, BUT NOT\n.*       PROC(MAIN)\n         AIF   (&STF(22) AND (NOT &STF(1))).ST99090\n         AIF   (&STF(22) AND &STF(2)).ST99090\n.*\n         AIF   ('&ISA' EQ '').ST02300   NO ISA PARM, CONTINUE\n         AIF   (&STF(2) AND &STF(3)).ST02300   PROC(MAIN) AND LIFO?\n         MNOTE 4,'ST1002I - ISA IGNORED WITHOUT PROC(MAIN) AND LIFO'\n.ST02300 ANOP  ,\n         AIF   (NOT &STF(1)).ST02400    NOT PROC OPTION, CONTINUE\n         AIF   (&STF(5)).ST02400        WKDSECT OPTION, CONTINUE\n&STWANAM SETC  '&P.WA'                  GENERATE WORK AREA NAME\n&STWA    SETB  1                        INDICATE A WORK AREA PRESENT\n&STF(5)  SETB  1                        INDICATE WKDSECT OPTION\n.*\n.* NOW START WITH PRELIMINARIES, ETC\n.*\n.ST02400 ANOP  ,\n         AIF   ('&SPLEVEL' EQ '').ST02500\n         AIF   ('&SPLEVEL' EQ '&SYSSPLV').ST02500\n         SPLEVEL SET=&SPLEVEL\n.*\n.ST02500 ANOP  ,\n         AIF   ('&RSECT'(1,1) EQ 'Y').ST02700\n         AIF   ('&CSECT'(1,1) EQ 'N').ST02600\n&STNAME  CSECT ,                        #START MACRO\n         AIF   (T'&CONSTANT EQ 'O').ST02800\n&STF(20) SETB  1                   SET FLAG FOR CONSTANT SECTION\n&STA_CONSTANT_SECTION SETC '$CN'.'&STNAME'(4,*)\n&STA_CONSTANT_BASE SETC '&CONSTANT'\n&STNAME  CSECT ,                        #START MACRO\n         AGO   .ST02800\n.ST02600 ANOP  ,\n&NAME    DS    0D                       #START MACRO\n         AIF   ('&ENTRY'(1,1) EQ 'N').ST02800\n         ENTRY &NAME\n         AGO   .ST02800\n.ST02700 ANOP  ,\n&STNAME  RSECT ,                        #START MACRO\n         AIF   (T'&CONSTANT EQ 'O').ST02800\n&STF(20) SETB  1                   SET FLAG FOR CONSTANT SECTION\n&STA_CONSTANT_SECTION SETC '$CN'.'&STNAME'(4,*)\n&STA_CONSTANT_BASE SETC '&CONSTANT'\n&STNAME  RSECT ,                        #START MACRO\n&STF(11) SETB  1\n.*\n.ST02800 ANOP  ,\n&CB      SETC  '&STA_CONSTANT_BASE'\n         AIF   ('&ENUC' EQ '').ST03200\n         AIF   ('&AMODE' EQ '').ST02900\n         IHBERMAC 1016,AMODE,ENUC\n.ST02900 ANOP  ,\n         AIF   ('&RMODE' EQ '').ST03000\n         IHBERMAC 1016,RMODE,ENUC\n.ST03000 ANOP  ,\n&STNAME  AMODE 31\n&STNAME  RMODE ANY\n&STMODEA SETC  '31'\n&STRMODE SETC  'ANY'\n         AIF   ('&SYSSPLV' NE '2').ST03600\n&STF(13) SETB  1                        FLAG FOR BSM RETURN\n         SPACE 1\n&NAME    RSECT ,                        FRONT-END MODULE FOR CODE\n&NAME    AMODE ANY                      TO RESIDE IN EXTENDED NUCLEUS\n&NAME    RMODE 24                       WHICH IS BRANCH-ENTERABLE\n         L     R15,8(0,R15)             LOAD ADDRESS OF REAL MODULE\n         BSM   R14,R15                  BRANCH AND HANDLE AMODE\n         DC    H'0'\n         DC    A(&STNAME+X'80000000')   ADDRESS OF REAL MODULE\n         SPACE 1\n         AIF   (&STF(11)).ST03100\n&STNAME  CSECT ,                        RESUME MAIN CSECT\n         AGO   .ST03600\n.ST03100 ANOP  ,\n&STNAME  RSECT ,                        RESUME MAIN RSECT\n         AGO   .ST03600\n.ST03200 ANOP  ,\n         AIF   ('&AMODE' EQ '').ST03400\n         AIF   ('&AMODE' EQ 'CAP24' OR '&AMODE' EQ 'CAP31').ST03300\n&STAMODE31 SETB (('&AMODE' EQ 'ANY') OR ('&AMODE' EQ '31'))\n&STNAME  AMODE &AMODE\n&STMODEA SETC  '&AMODE'\n         AGO   .ST03400\n.ST03300 ANOP  ,\n&STAMODE SETC  '&AMODE'(4,2)            SAVE CAPPED AMODE\n&STAMODE31 SETB ('&STAMODE' EQ '31')\n&STNAME  AMODE ANY\n&STMODEA SETC  'ANY'\n         AIF   ('&RMODE' NE '').ST03500\n&STNAME  RMODE 24\n&STRMODE SETC  '24'\n         AGO   .ST03600\n.ST03400 ANOP  ,\n         AIF   ('&RMODE' EQ '').ST03600\n.ST03500 ANOP  ,\n&STNAME  RMODE &RMODE\n&STRMODE SETC  '&RMODE'\n.ST03600 ANOP  ,\n         #REGS TYPE=&#REGS\n         AIF   (&STF(7)).ST07900        GO TO SVC SECTION\n.*\n         SPACE 1\n         AIF   ('&ID' EQ 'YES').ST03700\n         AIF   ('&ID' EQ 'NO').ST04400\n         AIF   ('&CSECT'(1,1) NE 'N').ST03700\n         J     *+14                     SKIP SUB-ROUTINE NAME\n         DC    AL1(8)                   LENGTH OF SUB-ROUTINE NAME\n         DC    CL8'&NAME'               SUB-ROUTINE NAME\n*\n         AGO   .ST04400\n.ST03700 ANOP  ,\n&Q       SETA  30+&#COPYSZ*&QQ\n         AIF   ('&LEVEL' EQ '').ST03800\n&Q       SETA  &Q+8                     ALLOW FOR LEVEL\n.ST03800 ANOP  ,\n         AIF   ('&APARS' EQ '').ST03900\n&Q       SETA  &Q+(&APARS*4)            ALLOW FOR APARS\n.ST03900 ANOP  ,\n         B     &Q.(0,R15)               BRANCH AROUND PROGRAM ID\n*\n&Q       SETA  &Q-5-&#COPYSZ*&QQ\n         DC    AL1(&Q)                  LENGTH OF PROGRAM ID\n         AIF   (&STF(15)).ST04000       BIF LABEL GENERATED\n&P.MODID DC    CL8'&NAME '              MODULE NAME\n&STF(15) SETB  1                        SET LABEL GENERATED\n         AGO   .ST04100                 GEN REST OF MODID\n.ST04000 ANOP  ,\n         DC    CL8'&NAME '              MODULE NAME\n.ST04100 ANOP  ,\n         DC    CL8' &SYSTIME '          TIME OF ASSEMBLY\n         DC    CL9'&SYSDATC'            DATE OF ASSEMBLY\n         AIF   ('&LEVEL' EQ '').ST04200\n         DC    CL8'&LEVEL'              MODULE LEVEL\n.*\n.ST04200 ANOP  ,\n         AIF   ('&APARS' EQ '').ST04300\n         DC    &APARS.CL4' '            APAR SLOTS\n.*\n.ST04300 ANOP  ,\n         AIF   ('&COPY' EQ 'NO').ST04400\n         #COPY GEN                      COPYRIGHT NOTICE\n*\n.ST04400 ANOP  ,\n         AIF   ('&SAVE' NE 'YES').ST04500\n         STM   R14,R12,12(R13)          SAVE CALLER'S REGISTERS\n&STF(10) SETB  1\n.*\n.ST04500 ANOP  ,\n         AIF   (NOT &STF(19)).ST04510 RELATIVE BASE\n         #RELBR OPSYN=&OPSYN\n.ST04510 ANOP  ,\n         AIF   (NOT &STF(20)).ST04520 NOT CONSTANT\n&CR2     SETB  (&CR2 OR '&CB' EQ '2' OR '&CB' EQ 'R2')\n&CR3     SETB  (&CR3 OR '&CB' EQ '3' OR '&CB' EQ 'R3')\n&CR4     SETB  (&CR4 OR '&CB' EQ '4' OR '&CB' EQ 'R4')\n         #CON  #START\n&STA_CONSTANT_LABEL USING &STA_CONSTANT_SECTION,&STA_CONSTANT_BASE\n         #RBL  &STA_CONSTANT_BASE,&STA_CONSTANT_SECTION\n.ST04520 ANOP  ,\n         AIF   (&STF(19)).ST05500 RELATIVE BASE\n         AIF   ('&BASE' NE '').ST04800   BASE SPECIFIED, CONTINUE\n.*\n         AIF   (&STF(1) OR &STF(3) OR &STF(4) OR &STF(5)).ST04600\n         AGO   .ST05500                 BASE WILL BE R13 (LATER)\n.ST04600 ANOP  ,\n         AIF   ('&LINK' EQ 'NO').ST04700 'BALR 14,15'?\n         LA    R12,0(0,R15)             LOAD BASE REGISTER WITH EPA\n         USING &NAME,R12\n         AGO   .ST05500                 CONTINUE\n.ST04700 ANOP  ,\n         BALR  R12,0                    GET\n&P.BASE  DS    0H                       . BASE\n         USING &P.BASE,R12              . REGISTER\n         AGO   .ST05500                 CONTINUE\n.*\n.ST04800 ANOP  ,\n         AIF   ('&LINK' EQ 'NO').ST04900 'BALR 14,15'?\n         LA    &BASE(1),0(0,R15)        LOAD BASE REGISTER WITH EPA\n         AIF   ('&BASE'(1,1) EQ '(').ST05100\n         USING &NAME,&BASE\n         AGO   .ST05000                 CONTINUE\n.ST04900 ANOP  ,\n         BALR  &BASE(1),0               GET\n&P.BASE  DS    0H                       . BASE\n         AIF   ('&BASE'(1,1) EQ '(').ST05100\n         USING &P.BASE,&BASE            . REGISTER\n.ST05000 ANOP  ,\n&R2      SETB  (&R2 OR '&BASE' EQ '2' OR '&BASE' EQ 'R2')\n&R3      SETB  (&R3 OR '&BASE' EQ '3' OR '&BASE' EQ 'R3')\n&R4      SETB  (&R4 OR '&BASE' EQ '4' OR '&BASE' EQ 'R4')\n         AGO   .ST05500                 ONLY ONE BASE REG\n.ST05100 ANOP  ,\n&K       SETC  '&BASE'(2,K'&BASE-2)     REMOVE PARENS\n         AIF   ('&LINK' EQ 'NO').ST05200 'BALR 14,15'?\n         USING &NAME,&K\n         AGO   .ST05300                 CONTINUE\n.ST05200 ANOP  ,\n         USING &P.BASE,&K\n.ST05300 ANOP  ,\n&A       SETA  1\n.ST05400 ANOP  ,\n&R2      SETB  (&R2 OR '&BASE(&A)' EQ '2' OR '&BASE(&A)' EQ 'R2')\n&R3      SETB  (&R3 OR '&BASE(&A)' EQ '3' OR '&BASE(&A)' EQ 'R3')\n&R4      SETB  (&R4 OR '&BASE(&A)' EQ '4' OR '&BASE(&A)' EQ 'R4')\n&A       SETA  &A+1\n         AIF   ('&BASE(&A)' EQ '').ST05500   NO MORE, CONTINUE\n         LA    &BASE(&A),2048(0,&BASE(&A-1))\n         LA    &BASE(&A),2048(0,&BASE(&A))\n         AGO   .ST05400\n.*\n.ST05500 ANOP  ,\n         AIF   (&STF(1) OR &STF(3) OR &STF(4) OR &STF(5)).ST05900\n         AIF   ('&SVAREA' NE 'YES').ST05800\n.*\n.* FOLLOWING IS FOR NO FRILLS INLINE SAVE AREA\n.*\n         LR    R14,R13                  SAVE CALLERS SAVE AREA ADDRESS\n         CNOP  0,4\n         LA    R13,*+8-&NAME.(0,R15)    POINT TO SAVE AREA\n         B     72(0,R13)                BR AROUND SAVE AREA\n         AIF   (&STF(19)).ST05600  BASE IS RELATIVE\n         AIF   ('&BASE' NE '').ST05600\n         USING *,R13                    ADDRESSABILITY\n.ST05600 ANOP  ,\n&K       SETC  ''\n         AIF   ('&STAMODE' EQ '').ST05700\n&K       SETC  '&P.CAPWD'\n.ST05700 ANOP  ,\n&K       DC    18F'0'                   SAVE AREA\n         ST    R14,4(0,R13)             CHAIN SAVE\n         ST    R13,8(0,R14)             AREAS TOGETHER\n         AGO   .ST07600                 CONTINUE\n.*\n.* FOLLOWING IS FOR SVAREA=NO OPTION\n.*\n.ST05800 ANOP  ,\n&STF(9)  SETB  1                        REMEMBER FOR #STOP\n         AIF   ('&BASE' NE '').ST07600\n         USING &NAME,R15                ADDRESSABILITY\n         AGO   .ST07600                 CONTINUE\n.*\n.* FOLLOWING IS FOR WKCSECT OPTION\n.*\n.ST05900 ANOP  ,\n         AIF   (&STF(1) OR &STF(5)).ST06000   PROC OR WKDSECT, CONT\n         LR    R15,R13                  SAVE CALLER'S SAVE AREA ADRRESS\n         AIF   (NOT &STF(19)).ST05910 RELATIVE BRANCHING?\n         #RBL  R13,&WKCSECT        LOAD ADDRESS OF SAVE\n         AGO   .ST05920\n.ST05910 ANOP  ,\n         L     R13,=A(&WKCSECT)         AND PICK UP ADDRESS OF NEW ONE\n.ST05920 ANOP  ,\n         USING &WKCSECT,R13             ESTABLISH ADDRESSABILITY\n         ST    R15,4(0,R13)             CHAIN SAVE\n         ST    R13,8(0,R15)             AREAS TOGETHER\n         XC    &P.RCODE,&P.RCODE        CLEAR RETURN CODE FIELD\n         AGO   .ST07600                 CONTINUE\n.*\n.* FOLLOWING IS FOR WKDSECT OPTION WHEN NO PROC(MAIN) OR PROC OPTIONS\n.*\n.ST06000 ANOP  ,\n         AIF   (&STF(1) OR &STF(2)).ST06300   PROC OR MAIN, CONTINUE\n&RRREGS  SETB  1                        REGS WILL BE ALTERED\n         AIF   (NOT &STF(18)).ST06050\n         IPK   ,                        GET CURRENT PROTECT KEY\n         LR    R4,R2                    COPY TO TEMPORARY REGISTER\n         MNOTE '         MODESET EXTKEY=&STAXKEY'\n         MODESET EXTKEY=&STAXKEY\n.ST06050 ANOP  ,\n         AIF   (&STF(17)).ST06100\n         MNOTE '         GETMAIN &STAGREG,LV=&P.WALEN&W,SP=&STSPN'\n         GETMAIN &STAGREG,LV=&P.WALEN,LOC=&LOC,SP=&STSPN,BNDRY=&BNDRY\n         AGO   .ST06200\n.ST06100 ANOP  ,\n.*       ADD SUPPORT FOR CALLRKY TO HANDLE SP=230 PROPERLY\n         MNOTE '         STORAGE OBTAIN,LENGTH=&P.WALEN,LOC=&LOC,SP=&STX\n               SPN,BNDRY=&BNDRY,CALLRKY=YES'\n         STORAGE OBTAIN,LENGTH=&P.WALEN,LOC=&LOC,SP=&STSPN,            X\n               BNDRY=&BNDRY,CALLRKY=YES\n.ST06200 ANOP  ,\n.*       REMOVE USE OF R2 AS PART OF AR MODE SUPPORT\n         ST    R1,8(0,R13)              CHAIN TO PREVIOUS\n         LR    R0,R1                    R0 -> WORK AREA\n         #RBL  R1,&P.WALEN              R1 = LENGTH OF WORK ARE\n         SR    R15,R15                  R15 HAS PAD BYTE & ZERO LENGTH\n         MVCL  R0,R14                   CLEAR WORK AREA\n         L     R1,8(0,R13)              R1 -> WORK AREA\n         ST    R13,4(0,R1)              BACK CHAIN SAVE AREA\n         LR    R13,R1                   PT TO WORK AREA AND SAVE AREA\n         USING &WKDSECT,R13             ESTABLISH ADDRESSABILITY TO IT\n         AGO   .ST07600                 CONTINUE\n.*\n.* FOLLOWING IS FOR PROC OPTION WITHOUT MAIN OR LIFO OPTION\n.*\n.ST06300 ANOP  ,\n&N       SETC  '&STWANAM'               PICK UP WORK AREA NAME\n.ST06400 ANOP  ,\n         AIF   (&STF(2) OR &STF(3)).ST06500   MAIN OR LIFO, CONTINUE\n         L     R15,0(0,R13)             PT TO COMMUNICATIONS AREA\n         L     R15,&P.#O-&P.MCA(0,R15)  PT TO EXTERNAL DUMMY SECTION\n         #RLIF R1,&P.QCON               GET OFFSET TO WORK AREA\n         AR    R15,R1                   GET OFFSET TO WORK AREA\n         ST    R15,8(0,R13)             CHAIN SAVE AREAS\n         ST    R13,4(0,R15)             AREAS TOGETHER\n         MVC   0(4,R15),0(R13)          COPY POINTER TO COMM AREA\n         LR    R13,R15                  PT TO WORK AREA AND SAVE AREA\n         USING &N,R13                   ESTABLISH ADDRESSABILITY TO IT\n         XC    &P.RCODE,&P.RCODE        CLEAR RETURN CODE FIELD\n         AIF   (NOT &STF(22)).ST06450   NOT REGS64\n         STMH  R0,R12,&P.HISAVE         SAVE HIGH WORDS\n.ST06450 ANOP  ,\n         AGO   .ST07600                 CONTINUE\n.*\n.* FOLLOWING IS FOR PROC(MAIN) OPTION, WHEN NO LIFO OPTION\n.*\n.ST06500 ANOP  ,\n         AIF   (&STF(3)).ST06900        LIFO OPTION, CONTINUE\n         AIF   (NOT &STF(18)).ST06600\n         IPK   ,                        GET CURRENT PROTECT KEY\n         LR    R4,R2                    COPY TO TEMPORARY REGISTER\n         MNOTE '         MODESET EXTKEY=&STAXKEY'\n         MODESET EXTKEY=&STAXKEY\n.ST06600 ANOP  ,\n&RRREGS  SETB  1                        REGS WILL BE ALTERED\n         AIF   (&R2).ST99060            REGISTER 2 NOT SUPPORTED BASE\n         AIF   (&R3).ST99070            REGISTER 3 NOT SUPPORTED BASE\n         AIF   (&R4).ST99080            REGISTER 4 NOT SUPPORTED BASE\n         AIF   (&CR2).ST99060           REGISTER 2 NOT SUPPORTED BASE\n         AIF   (&CR3).ST99070           REGISTER 3 NOT SUPPORTED BASE\n         AIF   (&CR4).ST99080           REGISTER 4 NOT SUPPORTED BASE\n         #RLIF R3,&P.GSIZE              R0 HAS LENGTH OF WORK AREA CXD\n         AIF   (&STF(17)).ST06700\n         MNOTE '         GETMAIN &STAGREG,LV=(R3)&W,SP=&STSPN,BNDRY=PAGX\n               E'\n         GETMAIN &STAGREG,LV=(R3),LOC=&LOC,SP=&STSPN,BNDRY=PAGE\n         AGO   .ST06800\n.ST06700 ANOP  ,\n.*       ADD SUPPORT FOR CALLRKY TO HANDLE SP=230 PROPERLY\n         MNOTE '         STORAGE OBTAIN,LENGTH=(R3),LOC=&LOC,SP=&STSPN,X\n               BNDRY=PAGE,CALLRKY=YES'\n         STORAGE OBTAIN,LENGTH=(R3),LOC=&LOC,SP=&STSPN,BNDRY=PAGE,     X\n               CALLRKY=YES\n.ST06800 ANOP  ,\n.*       REMOVE USE OF R2 AS PART OF AR MODE SUPPORT\n         ST    R1,8(0,R13)              CHAIN TO PREVIOUS\n         LR    R0,R1                    R0 -> WORK AREA\n         LR    R1,R3                    R1 = WORK AREA LENGTH\n         SR    R15,R15                  R15 HAS PAD BYTE & ZERO LENGTH\n         MVCL  R0,R14                   CLEAR WORK AREA\n         L     R1,8(0,R13)              R1 -> WORK AREA\n         LR    R15,R13                  SAVE CALLER'S SAVE AREA ADDRESS\n         LR    R13,R1                   PT TO EXTERNAL DUMMY SECTION @\n         #RLIF R14,&P.QCON              PICK\n         AR    R13,R14                  PT TO WORK AREA\n         ST    R15,4(0,R13)             BACK CHAIN SAVE AREA\n         USING &N,R13                   ESTABLISH ADDRESSABILITY TO IT\n         XC    &P.RCODE,&P.RCODE        CLEAR RETURN CODE FIELD\n         ST    R1,&P.#O                 STORE DUMMY SECTION @ IN MCA\n         LA    R15,&P.MCA               PT TO MCA\n         ST    R15,0(0,R13)             STORE IT IN WORD 1 OF SAVE AREA\n         AGO   .ST07600                 CONTINUE\n.*\n.* FOLLOWING IS FOR PROC AND LIFO OPTIONS, WITHOUT MAIN OPTION\n.*\n.ST06900 ANOP  ,\n         AIF   (&STF(2)).ST07000        MAIN OPTION, CONTINUE\n&RRREGS  SETB  1                        REGS WILL BE ALTERED\n.*       REMOVE USE OF R2 AS PART OF AR MODE SUPPORT\n         #RBL  R3,&P.WALEN              R3 = LENGTH OF WORK\n         LR    R0,R3                    R0 TOO\n         L     R1,0(R13)                PT TO MCA\n         L     R15,&P.#GET-&P.MCA(R1) PT TO LIFO GET ROUTINE\n         BALR  R14,R15                  GET WORK AREA FROM LIFO STACK\n         ST    R1,8(R13)                CHAIN SAVE AREA\n         LR    R0,R1                    R0 -> WORK AREA\n         LR    R1,R3                    R1 = WORK AREA LENGTH\n         SR    R15,R15                  R15 HAS PAD BYTE & ZERO LENGTH\n         MVCL  R0,R14                   CLEAR WORK AREA\n         L     R1,8(R13)                R1 -> WORK AREA\n         ST    R13,4(R1)                BACK CHAIN SAVE AREA\n         L     R0,0(R13)                PROPOGATE MCA ADDRESS\n         ST    R0,0(R1)                 .\n         AIF   ('&SAVE' NE 'YES').ST06990 SKIP IF SAVE=NO\n         AIF   ('&SVAREA' NE 'YES').ST06990\n         AIF   (NOT &RRREGS).ST06990\n.*\n.* DELAY RELOADING R13 AND MAPPING IT ...\n.*\n         AIF   (NOT &STF(18)).ST06975\n         ST    R4,&P.IPK             SAVE ORIGINAL PROTECT KEY\n.ST06975 ANOP  ,\n         LM    R14,R4,12(R13)         RESTORE REGISTERS\n         L     R13,8(R13)             R1 -> NEW WORK AREA\n         USING &N,R13            ESTABLISH ADDRESSABILITY TO IT\n         AIF   (NOT &STF(22)).ST06950   NOT REGS64\n         STMH  R0,R12,&P.HISAVE         SAVE HIGH WORDS\n.ST06950 ANOP  ,\n         AGO   .ST07750               CONTINUE\n.*\n.ST06990 ANOP  ,\n         LR    R13,R1                   PT TO WORK AREA\n         USING &N,R13                   ESTABLISH ADDRESSABILITY TO IT\n         AIF   (NOT &STF(22)).ST06993   NOT REGS64\n         STMH  R0,R12,&P.HISAVE         SAVE HIGH WORDS\n.ST06993 ANOP  ,\n         AIF   (NOT &STF(18)).ST06996\n         ST    R4,&P.IPK             SAVE ORIGINAL PROTECT KEY\n.ST06996 ANOP  ,\n         AGO   .ST09900               CONTINUE\n.*\n.* AND NOW FOR THE FINALE, THIS IS FOR PROC, MAIN, AND LIFO OPTIONS\n.*\n.ST07000 ANOP  ,\n&RRREGS  SETB  1                        REGS WILL BE ALTERED\n&STISASZ SETC  '16*1024'                SET DEFAULT ISA SIZE\n         AIF   ('&ISA' EQ '').ST07200   NO ISA PARAMETER, CONTINUE\n         AIF   ('&ISA'(K'&ISA,1) EQ 'K').ST07100   ISA SIZE IS IN K\n&STISASZ SETC  '&ISA'                   PICK UP ISA SIZE\n         AGO   .ST07200                 CONTINUE\n.ST07100 ANOP  ,\n&STISASZ SETC  '&ISA'(1,K'&ISA-1)'*1024' CONVERT K TO 1024 BYTES\n.ST07200 ANOP  ,\n         AIF   (NOT &STF(18)).ST07300\n         IPK   ,                        GET CURRENT PROTECT KEY\n         LR    R4,R2                    COPY TO TEMPORARY REGISTER\n         MNOTE '         MODESET EXTKEY=&STAXKEY'\n         MODESET EXTKEY=&STAXKEY\n.ST07300 ANOP  ,\n         AIF   (&R2).ST99060            R2 USED ? YES, BAD BASE\n         AIF   (&R3).ST99070            R3 USED ? YES, BAD BASE\n         AIF   (&R4).ST99080            R4 USED ? YES, BAD BASE\n         AIF   (&CR2).ST99060           R2 USED ? YES, BAD BASE\n         AIF   (&CR3).ST99070           R3 USED ? YES, BAD BASE\n         AIF   (&CR4).ST99080           R4 USED ? YES, BAD BASE\n         #RLIF R3,&P.GSIZE              R3 HAS LENGTH OF WORK AREA\n         AIF   (&STF(17)).ST07400\n         MNOTE '         GETMAIN &STAGREG,LV=(R3)&W,SP=&STSPN,BNDRY=PAGX\n               E'\n         GETMAIN &STAGREG,LV=(R3),LOC=&LOC,SP=&STSPN,BNDRY=PAGE\n         AGO   .ST07500\n.ST07400 ANOP  ,\n.*       ADD SUPPORT FOR CALLRKY TO HANDLE SP=230 PROPERLY\n         MNOTE '         STORAGE OBTAIN,LENGTH=(R3),LOC=&LOC,SP=&STSPN,X\n               BNDRY=PAGE,CALLRKY=YES'\n         STORAGE OBTAIN,LENGTH=(R3),LOC=&LOC,SP=&STSPN,BNDRY=PAGE,     X\n               CALLRKY=YES\n.ST07500 ANOP  ,\n.*       REMOVE USE OF R2 AS PART OF AR MODE SUPPORT\n         ST    R1,8(0,R13)              CHAIN SAVE AREA\n         LR    R0,R1                    R0 -> WORK AREA\n         LR    R1,R3                    R1 = WORK AREA LENGTH\n         SR    R15,R15                  R15 HAS PAD BYTE & ZERO LENGTH\n         MVCL  R0,R14                   CLEAR WORK AREA\n         L     R1,8(0,R13)              R1 -> WORK AREA\n         ST    R13,4(0,R1)              BACK CHAIN SAVE AREA\n         LR    R13,R1                   LOAD WORK AREA ADDRESS\n         USING &N,R13                   ESTABLISH ADDRESSABILITY TO IT\n*\n* INITIALIZE MODULE COMMUNICATIONS AREA WITH POINTERS TO LIFO STACK\n* AND LIFO GET/FREE ROUTINES\n*\n         ST    R1,&P.#O                 STORE DYNAMIC STORAGE ADDRESS\n         AIF   (&STF(19)).ST07510       IN RELATIVE MODE\n         A     R1,=A(&P.WALEN)          DETERMINE STACK ORIGIN\n         AGO   .ST07520\n.ST07510 ANOP  ,\n         #RBL  R1,&P.WALEN\n         A     R1,&P.#O                 DETERMINE STACK ORIGIN\n.ST07520 ANOP  ,\n         ST    R1,&P.#S                 STACK ORIGIN POINTER\n         ST    R1,&P.#N                 CURRENT STACK POINTER\n         LA    R15,&P.MCA               PT TO MCA\n         ST    R15,0(0,R13)             STORE IN WORD 1 OF SAVE AREA\n         #RLIF R14,&P.GSIZE             LOAD SIZE OF INITIAL STACK AREA\n         AR    R14,R13                  COMPUTE STACK END ADDRESS\n         ST    R14,&P.#E                STORE IT INTO MCA\n         AIF   (&STF(19)).ST07530\n         MVC   &P.#GET(8),=V(#####GET,####FREE)\n         AGO   .ST07540\n.ST07530 ANOP  ,\n         CNOP  0,4\n         BRAS  R14,*+12            GET ADDRESS OF VCONS\n         DC    V(#####GET,####FREE)\n         MVC   &P.#GET(8),0(R14)   MOVE VCONS TO SAVE\n.ST07540 ANOP  ,\n.*\n.* RESTORE REGISTERS WHICH HAVE BEEN CORRUPTED\n.*\n.ST07600 ANOP  ,\n         AIF   (NOT &STF(18)).ST07700\n         ST    R4,&P.IPK                SAVE ORIGINAL PROTECT KEY\n.ST07700 ANOP  ,\n         AIF   ('&SAVE' NE 'YES').ST09900 SKIP IF SAVE=NO SPECIFIED\n         AIF   ('&SVAREA' NE 'YES').ST09900\n         AIF   (NOT &RRREGS).ST09900\n         L     R1,4(0,R13)              PT TO CALLER'S SAVE AREA\n         LM    R14,R4,12(R1)            RESTORE REGISTERS\n.ST07750 ANOP  ,\n         AIF   (&CR2).ST99060           REGISTER 2 NOT SUPPORTED\n         AIF   (&CR3).ST99070           REGISTER 3 NOT SUPPORTED\n         AIF   (&CR4).ST99080           REGISTER 4 NOT SUPPORTED\n.*\n.* RESYNCH BASE REGISTERS R2 OR R3 NEEDED ?\n.*\n         AIF   (NOT (&R2 OR &R3 OR &R4)).ST09900\n.*\n         LA    &BASE(1),0(,R15)         SET BASE REGISTER AGAIN\n&A       SETA  2\n.ST07800 ANOP  ,\n         AIF   ('&BASE(&A)' EQ '').ST09900   NO MORE, CONTINUE\n         LA    &BASE(&A),2048(0,&BASE(&A-1))\n         LA    &BASE(&A),2048(0,&BASE(&A))\n&A       SETA  &A+1\n         AGO   .ST07800\n.*\n.*       SVC LINKAGE IS GENERATED HERE\n.*\n.ST07900 ANOP  ,\n***********************************************************************\n*                                                                     *\n         AIF   (&G).ST08000\n*        THE 'SVC' OPTION OF #START HAS BEEN DEFAULTED TO             *\n*        FOR THIS CSECT NAME.  (CODE 'SVC=NO' TO SUPPRESS IT).        *\n         AGO   .ST08100\n.ST08000 ANOP  ,\n*        THE 'SVC' OPTION OF #START HAS BEEN SELECTED                 *\n.ST08100 ANOP  ,\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*    THE PROLOG AND EPILOG CODE WILL BE GENERATED ACCORDING TO MVS    *\n*    SVC LINKAGE STANDARDS.  WHEN THE SVC GETS CONTROL THE            *\n*    REGISTERS ARE PRE-SET IN A DIFFERENT FASHION THAN FOR NORMAL     *\n*    LINKAGE.  REGS 6 AND 15 DIFFER DEPENDING ON TYPE OF ENTRY:       *\n*    CASE (A) IS FOR TYPES 1,2,3,6, AND THE FIRST LOAD OF A TYPE      *\n*    4.  CASE (B) REFERS TO THE SUBSEQUENT LOADS OF A TYPE-4 SVC      *\n*    (ENTERED VIA XCTL).                                              *\n*                                                                     *\n*          0,1   SAME INFO AS WHEN THE SVC WAS ISSUED                 *\n*          2     UNPREDICTABLE                                        *\n*          3     ADDRESS OF THE CVT                                   *\n*          4     ADDRESS OF THE CURRENT TCB                           *\n*          5     ADDRESS OF THE CURRENT REQUEST BLOCK (RB)            *\n*          6     (A) - ENTRY POINT ADDRESS OF THE SVC ROUTINE         *\n*                (B) - UNPREDICTABLE                                  *\n*          7     ADDRESS OF THE CURRENT ASCB                          *\n*          8-12  UNPREDICTABLE                                        *\n*          13    SAME INFO AS WHEN THE SVC WAS ISSUED (SEE BELOW)     *\n*          14    RETURN ADDRESS                                       *\n*          15    (A) - SAME INFO AS WHEN THE SVC WAS ISSUED           *\n*                (B) - ENTRY POINT ADDRESS OF THE SVC ROUTINE         *\n*                                                                     *\n*   **NOTE**  REGISTER 13 MAY OR MAY NOT POINT TO A SAVE AREA.  IN    *\n*             ANY CASE, SVC ROUTINES MUST NEVER ATTEMPT TO SAVE       *\n*             REGISTERS THERE BECAUSE (1) THE SAVE AREA MAY BE IN     *\n*             USE ALREADY AND (2) THE SVC RUNS IN KEY ZERO AND        *\n*             COULD OVERLAY DATA.  THE SYSTEM HAS SAVED ALL THE       *\n*             CALLERS REGISTERS FOR YOU, AND WILL RESTORE ALL         *\n*             EXCEPT R0, R1, AND R15.                                 *\n*                                                                     *\n*    WHEN THE PROLOG IS COMPLETE, ALL THE REGISTERS WILL BE LOADED    *\n*    AS DESCRIBED ABOVE, EXCEPT FOR REGISTERS 12 AND 13.              *\n*    REGISTER 12 WILL BE SET UP AS THE BASE REGISTER FOR THE MODULE.  *\n         AIF   (NOT &STWA).ST08200\n*    REGISTER 13 WILL POINT TO THE GETMAINED SAVE/WORK AREA.          *\n         AGO   .ST08300\n.ST08200 ANOP  ,\n*    REGISTER 13 WILL BE SET TO ZEROS.                                *\n.ST08300 ANOP  ,\n         AIF   (NOT &STWA).ST08400\n         AIF   (K'&NAME GT 6 OR &STF(12)).ST08400\n*                                                                     *\n*   THE CODE GENERATED HERE USES SVC-TYPE GETMAIN/FREEMAIN MACROS.    *\n*   IT CANNOT BE USED WITH SVC TYPES 1 AND 6 BECAUSE THEY CANNOT      *\n*   ISSUE ANY SVCS.  TYPE 1 MAY USE BRANCH-ENTRY SERVICES.            *\n.ST08400 ANOP  ,\n         AIF   (NOT &STF(12)).ST08500\n*                                                                     *\n*   THE CODE GENERATED HERE USES BRANCH ENTRY GETMAIN AND FREEMAIN    *\n*   MACROS.  THIS SVC MUST BE TYPE 1, OR REQUEST THE LOCAL LOCK VIA   *\n*   THE SVCTABLE.                                                     *\n.ST08500 ANOP  ,\n*                                                                     *\n***********************************************************************\n         EJECT ,\n.*\n         BASR  R12,0                    SET UP SVC BASE REGISTER\n         USING *,R12\n.*\n         AGO   .ST08600\n         USING CVTMAP,R3\n         USING TCB,R4\n         USING RBBASIC,R5\n         USING ASCB,R7\n         #DSECTS CVT,TCB,RB,ASCB,TYPE=DEFER MAP 'EM LATER, PLEASE\n.*\n.ST08600 ANOP  ,\n         AIF   ('&ID' EQ 'NO').ST09100\n         SPACE 1\n&Q       SETA  30+&#COPYSZ*&QQ\n         AIF   ('&LEVEL' EQ '').ST08700\n&Q       SETA  &Q+8                     ALLOW FOR LEVEL\n.ST08700 ANOP  ,\n         AIF   ('&APARS' EQ '').ST08800\n&Q       SETA  &Q+(&APARS*4)            ALLOW FOR APARS\n.ST08800 ANOP  ,\n         B     *+&Q                     BRANCH AROUND ID\n&Q       SETA  &Q-5-&#COPYSZ*&QQ\n         DC    AL1(&Q)                  LENGTH OF PROGRAM ID\n         DC    CL8'&NAME '              MODULE NAME\n         DC    CL8' &SYSTIME '          TIME OF ASSEMBLY\n         DC    CL9'&SYSDATC '           DATE OF ASSEMBLY\n         AIF   ('&LEVEL' EQ '').ST08900\n         DC    CL8'&LEVEL'              MODULE LEVEL\n.ST08900 ANOP  ,\n         AIF   ('&APARS' EQ '').ST09000\n         DC    &APARS.CL4' '            APAR SLOTS\n.ST09000 ANOP  ,\n         AIF   ('&COPY' EQ 'NO').ST09100\n         #COPY GEN                      36-BYTE COPYRIGHT\n         SPACE 1\n.*\n.ST09100 ANOP  ,\n         AIF   (NOT &STF(18)).ST09200\n         IPK   ,                        GET CURRENT PROTECT KEY\n         LR    R4,R2                    COPY TO TEMPORARY REGISTER\n         MNOTE '         MODESET EXTKEY=&STAXKEY'\n         MODESET EXTKEY=&STAXKEY\n.ST09200 ANOP  ,\n         AIF   (&STWA).ST09300\n.* REG 13 IS ZEROED.  IT MIGHT OTHERWISE BE USED AS A SAVE AREA\n.* POINTER LEADING TO VERY SUBTLE INTEGRITY PROBLEMS.  CLEARING IT\n.* ENSURES THAT AN 0C4 ABEND WILL OCCUR IF AN ATTEMPT IS MADE TO\n.* SAVE VIA R13  (EVEN IN KEY ZERO).\n         SR    R13,R13                  TAKE OUT INSURANCE\n         AGO   .ST09900                 NO FRILLS ENTRY STYLE\n.*\n.ST09300 ANOP  ,\n         AIF   (&STF(1) OR &STF(2)).ST09800\n         LR    R2,R15                   SAVE REGS\n         LR    R10,R0\n         LR    R11,R1\n         AIF   (&STF(17)).ST09500\n         AIF   (&STF(12)).ST09400\n         MNOTE '         GETMAIN &STAGREG,LV=&P.WALEN&W,SP=&STSPN'\n         GETMAIN &STAGREG,LV=&P.WALEN,LOC=&LOC,SP=&STSPN\n         AGO   .ST09600\n.ST09400 ANOP  ,\n         LR    R9,R14                   SAVE REG 14\n         MNOTE '         GETMAIN &STAGREG,LV=&P.WALEN&W,SP=&STSPN,BRANCX\n               H=YES'\n         GETMAIN &STAGREG,LV=&P.WALEN,LOC=&LOC,SP=&STSPN,BRANCH=YES\n         LR    R14,R9                   RESTORE REG 14\n         L     R3,16                    RESTORE CVT POINTER\n         AGO   .ST09600\n.ST09500 ANOP  ,\n.*       ADD SUPPORT FOR CALLRKY TO HANDLE SP=230 PROPERLY\n         MNOTE '         STORAGE OBTAIN,LENGTH=&P.WALEN,LOC=&LOC,SP=&STX\n               SPN,BNDRY=&BNDRY,CALLRKY=YES'\n         STORAGE OBTAIN,LENGTH=&P.WALEN,LOC=&LOC,SP=&STSPN,            X\n               BNDRY=&BNDRY,CALLRKY=YES\n.ST09600 ANOP  ,\n         LR    R13,R1                   R13 POINTS TO WORK AREA\n         USING &WKDSECT,R13             ADDRESSABILITY\n         LR    R0,R1\n         AIF   (&STF(19)).ST09610       RELATIVE MODE\n         L     R1,=A(&P.WALEN)          R1 = LENGTH OF WORK\n         AGO   .ST09630\n.ST09610 ANOP  ,\n         #RBL  R1,&P.WALEN              R1 = LENGTH OF WORK\n.ST09630 ANOP  ,\n         SR    R9,R9\n         MVCL  R0,R8                    CLEAR THE WORK AREA\n         LR    R0,R10                   RELOAD REGS\n         LR    R1,R11\n         LR    R15,R2\n         ST    R14,0(0,R13)             STASH RETURN ADDRESS\n         AIF   (NOT &STF(18)).ST09700\n         ST    R4,&P.IPK                SAVE ORIGINAL PROTECT KEY\n.ST09700 ANOP  ,\n         AGO   .ST09900\n.*\n.ST09800 ANOP  ,\n         MNOTE 12,'OPTION NOT YET CODED'\n         MEXIT ,\n.*\n.* FINISH UP WITH USING, REG0, REG1 PARMS\n.*\n.ST09900 ANOP  ,\n         AIF   ('&USING' EQ '').ST10200 NO USING PARAMETER, CONT\n&A       SETA  1                        COUNTER OF NUMBER OF OPERANDS\n&B       SETA  N'&USING                 PICK UP # OF OPTIONS ON USING\n.ST10100 ANOP  ,\n         AIF   (&A GT &B).ST10200       NO MORE, CONTINUE\n&K       SETC  '&USING(&A)'             PICK US ADDRESS\n&L       SETC  '&USING(&A+1)'           PICK UP REGISTER\n         AIF   ('&K' EQ '' OR '&L' EQ '').ST99000   MISSING PARMS\n         USING &K,&L\n&A       SETA  &A+2                     POINT TO NEXT SET\n         AGO   .ST10100                 ON TO THE NEXT PAIR\n.*\n.ST10200 ANOP  ,\n         AIF   ('&STAMODE' EQ '').ST10700\n         AIF   (NOT &STF(19)).OLDCD DO NOT USE RELATIVE CODE\n         SPACE 1\n         AIF   ('&SYSSPLV' NE '1').ST10310\n         L     R15,16                   POINT TO CVT\n         TM    116(R15),128             IS THIS MVS/XA ?\n         BZ    &P.CAP00                 NO, DO NOT CAP\n.ST10310 ANOP  ,\n         BRAS  R15,*+4\n         LA    R15,&P.CAP00-*(R15)      POINT AFTER BSM\n         AIF   ('&STAMODE' EQ '24').ST10410\n         CNOP  0,4\n         BRAS  R14,*+8                  OUR AMODE IS 31\n         DC    X'80000000'\n         O     R15,0(R14)               R14 POINTS TO 80000000\n.ST10410 ANOP  ,\n         CNOP  0,4\n         BRAS  R14,*+8                  R14 POINTS TO NEXT INS\n         DC    A(&P.RRR14)              INTO EPILOG\n         L     R14,0(R14)               R14 -> &P.RRR14\n         AGO   .RESCD\n.OLDCD   ANOP  ,                   NON-RELATIVE\n         LA    R14,&P.RRR14             POINT INTO CAP EPILOG\n         AIF   ('&SYSSPLV' NE '1').ST10300\n         L     R15,16                   POINT TO CVT\n         TM    116(R15),128             IS THIS MVS/XA ?\n         BZ    &P.CAP00                 NO, DO NOT CAP\n.ST10300 ANOP  ,\n         LA    R15,&P.CAP00             POINT AFTER BSM\n         AIF   ('&STAMODE' EQ '24').ST10400\n         O     R15,=X'80000000'         OUR AMODE IS 31\n.ST10400 ANOP  ,\n.RESCD   ANOP  ,\n         BSM   R14,R15                  SAVE AND SET AMODE\n         AIF   ('&STACREG' EQ '').ST10500\n&P.CAP00 LR    &STACREG,R14             SAVE CAP WORD IN REG\n         AGO   .ST10600\n.ST10500 ANOP  ,\n&P.CAP00 ST    R14,&P.CAPWD             SAVE CAP WORD\n.*\n.ST10600 ANOP  ,\n         AIF   ('&REG0&REG1' EQ '').ST10900\n         SPACE 1\n.*\n.ST10700 ANOP  ,\n         AIF   ('&REG0' EQ '').ST10800  NO REG0, CONTINUE\n         LR    &REG0,R0                 SAVE REGISTER 0\n.ST10800 ANOP  ,\n         AIF   ('&REG1' EQ '').ST10900  NO REG1  CONTINUE\n         LR    &REG1,R1                 SAVE REGISTER 1\n.ST10900 ANOP  ,\n         MEXIT ,\n.*\n.ST99000 MNOTE 4,'ST1003I - REQUIRED OPERAND MISSING ON USING PARM'\n         MEXIT ,\n.ST99010 IHBERMAC 1006,NAME\n         MEXIT ,\n.ST99020 IHBERMAC 1304,WKCSECT,WKDSECT\n         MEXIT ,\n.ST99030 IHBERMAC 1020,WKCSECT,PROC\n         MEXIT ,\n.ST99040 MNOTE 12,'ST1004I - SAVE=&SAVE INVALID WITH WORKAREA'\n         MEXIT ,\n.ST99050 MNOTE 12,'ST1005I - SVAREA=&SVAREA INVALID WITH WORKAREA'\n         MEXIT ,\n.ST99060 MNOTE 12,'ST1006I - R2 NOT SUPPORTED AS BASE REGISTER'\n         MEXIT ,\n.ST99070 MNOTE 12,'ST1007I - R3 NOT SUPPORTED AS BASE REGISTER'\n         MEXIT ,\n.ST99080 MNOTE 12,'ST1007I - R4 NOT SUPPORTED AS BASE REGISTER'\n         MEXIT ,\n.ST99090 MNOTE 12,'REGS64 ONLY VALID WITH PROC OR PROC,LIFO'\n         MEXIT ,\n.MEND    MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#STARTWA": {"ttr": 4115, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x14\\x11/\\x01\\x14\\x11/\\x12H\\x00\\xb5\\x00\\xb5\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-04-22T00:00:00", "modifydate": "2014-04-22T12:48:33", "lines": 181, "newlines": 181, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         #STARTWA &LTORG=YES,&WALLY=MAYBE,&PATCH=\n.*\n.* DEFINE SYMBOLS NEEDED, NOTE ALL GLOBALS ARE FROM #START MACRO\n.*\n         GBLA  &EXECUTN                 EXECUTE MACRO COUNTER\n         GBLA  &SPFCNT                  ISPLINK VERB COUNT\n         GBLA  &STWAC                   COUNTER FOR DEFERED WA DEFINES\n         GBLB  &STWA                    INDICATES CSECT HAS A WORK AREA\n         GBLB  &STF(24)                 CONTROL FLAG BITS, AS FOLLOWS:\n.*                                       (01) - PROC OPTION CODED\n.*                                       (02) - MAIN OPTION CODED\n.*                                       (03) - LIFO OPTION CODED\n.*                                       (04) - WKCSECT OPTION CODED\n.*                                       (05) - WKDSECT OPTION CODED\n.*                                       (06) - #START HAS BEEN CODED\n.*                                       (07) - ROUTINE IS AN SVC\n.*                                       (08) - WORK FIELDS WANTED\n.*                                       (09) - SVAREA=NO OPTION\n.*                                       (10) - SAVE=YES OPTION\n.*                                       (11) - RSECT=YES OPTION\n.*                                       (12) - SVC=(YES,BRANCH)\n.*                                       (13) - ENUC CAPPING\n.*                                       (14) - PATCH AREA REQUIRED\n.*                                       (18) - EXTKEY= OPTION CODED\n.*                                       (22) - 64 BIT REGS\n.*                                       (23) - #STACK\n.*\n         GBLC  &STPREF                  PREFIX CHARACTERS\n         GBLC  &STWANAM                 WORK AREA NAME\n         GBLC  &STAMODE                 MODULE'S CAPPED AMODE\n         GBLC  &STACREG                 CAPWORD SAVE REGISTER\n         GBLC  &STISASZ                 LIFO ISA SIZE\n         GBLC  &SYSSPLV                 SPLEVEL\n         GBLC  &STWAD(1000)             WORK AREA DEFERED STACK\n         LCLA  &A,&B,&C,&D,&E           LOCAL\n         LCLB  &F,&G,&H,&I,&J           WORK\n         LCLC  &K,&L,&M,&N,&O,&P        SYMBOLS\n.*\n.* INITIALIZE SYMBOLS, SET UP PREFIX, PICK UP ALL OPERANDS\n.*\n&P       SETC  '&STPREF'                MAKE PREFIX EASIER TO WORK WITH\n         AIF   (NOT &STF(6)).ST90100    ERROR - NO #START MACRO CODED\n         AIF   (NOT &STWA).ST90200      ERROR - NO WORK AREA SPECIFIED\n         AIF   ('&LTORG' NE 'YES').ST00300   NO LTORG, CONTINUE\n         SPACE 1\n         AIF   (&EXECUTN EQ 0).ST00100       NO POOL, CONTINUE\n*        #EXEC ,                        EXECUTE POOL\n         #EXEC ,\n         SPACE 1 ,\n.ST00100 ANOP  ,\n         AGO   .ST00200\n         AIF   (&SPFCNT EQ 0).ST00200       NO ISPLINK VERBS, CONTINUE\n*        ISPLINK ,                      ISPF VERBS\n         ISPLINK ,\n         SPACE 1 ,\n.ST00200 ANOP  ,\n         LTORG ,                        LITERAL POOL\n         SPACE 1 ,\n.ST00300 ANOP  ,\n         AIF   ('&PATCH' EQ 'NO').ST00500\n         AIF   ('&PATCH' EQ '' AND NOT &STF(14)).ST00500\n         AIF   ('&PATCH' EQ '' AND &STF(20)).ST00500\n         AIF   ('&PATCH' EQ 'YES' OR '&PATCH' EQ 'Y' OR '&PATCH' EQ '')X\n               .ST00400\n         SPACE 1\n         #PATCH F=&PATCH                EXPLICIT PATCH SIZE\n         AGO   .ST00500\n.ST00400 ANOP  ,\n         #PATCH ,                       DEFAULT PATCH SIZE\n.ST00500 ANOP  ,\n.*\n.* THE FOLLOWING IS FOR WKCSECT OPTION\n.*\n         AIF   (NOT &STF(4)).ST00600    NOT WORK CSECT, CONTINUE\n&STWANAM CSECT ,                        #STARTWA MACRO\n         DS    18F                      SAVE AREA\n         AGO   .ST00900                 CONTINUE\n.*\n.* THE FOLLOWING IS FOR WKDSECT OPTION, WITH OR WITHOUT PROC AND LIFO\n.* OPTIONS, BUT NOT WITH THE MAIN OPTION\n.*\n.ST00600 ANOP  ,\n         AIF   (&STF(2)).ST00700        MAIN OPTION, CONTINUE\n&STWANAM DSECT ,                        #STARTWA MACRO\n         AIF   (&STF(23)).ST00650       NO SAVE AREA WITH BAKR\n         DS    18F                      SAVE AREA\n         AIF   (NOT &STF(22)).ST00650   NOT 64 BIT REGS\n&P.HISAVE DS   13F                      SAVE HIGH WORDS R0-R12\n.ST00650 ANOP  ,\n         AGO   .ST00900                 CONTINUE\n.*\n.* THE FOLLOWING IS FOR PROC AND MAIN OPTIONS, BUT NOT LIFO\n.*\n.ST00700 ANOP  ,\n         AIF   (&STF(3)).ST00800        LIFO OPTION, CONTINUE\n&STWANAM DSECT ,                        #STARTWA MACRO\n         DS    18F                      STANDARD SAVE AREA\n&P.MCA   DS    0F                       MODULE COMMUNICATIONS AREA\n&P.#O    DS    A                        ORIGIN OF GETMAINED AREA\n         AGO   .ST00900                 CONTINUE\n.*\n.* THE FOLLOWING IS FOR PROC, MAIN, AND LIFO OPTIONS\n.*\n.ST00800 ANOP  ,\n&STWANAM DSECT ,                        #STARTWA MACRO\n         DS    18F                      STANDARD SAVE AREA\n&P.MCA   DS    0F                       MODULE COMMUNICATIONS AREA\n&P.#O    DS    A                        ORIGIN OF GETMAINED AREA\n&P.#GET  DS    V(#####GET)              PTR TO LIFO GET ROUTINE\n&P.#FRE  DS    V(####FREE)              PTR TO LIFO FREE ROUTINE\n&P.#S    DS    A                        PTR TO START OF LIFO STACK\n&P.#E    DS    A                        PTR TO END OF LIFO STACK\n&P.#N    DS    A                        PTR TO NEXT FREE AREA\n.*\n.* THE FOLLOWING IS COMMON TO ALL TYPES OF WORK AREAS\n.*\n.ST00900 ANOP  ,\n         AIF   ('&WALLY' EQ 'NO').ST01000\n         AIF   (NOT &STF(8) AND '&WALLY' NE 'YES').ST01000\n&P.DBL1  DS    D\n&P.DBL2  DS    D\n&P.DBL3  DS    D\n&P.DBL4  DS    D\n&P.WORD1 DS    F\n&P.WORD2 DS    F\n&P.WORD3 DS    F\n&P.WORD4 DS    F\n&P.HALF1 DS    H\n&P.HALF2 DS    H\n&P.HALF3 DS    H\n&P.HALF4 DS    H\n&P.BYTE1 DS    C\n&P.BYTE2 DS    C\n&P.BYTE3 DS    C\n&P.BYTE4 DS    C\n&P.FLAG1 DS    X\n&P.FLAG2 DS    X\n&P.FLAG3 DS    X\n&P.FLAG4 DS    X\n.ST01000 ANOP  ,\n&STF(8)  SETB  0                        TURN BACK OFF\n         AIF   (&STF(23)).ST01050       NO RCODE IF #STACK\n&P.RCODE DS    F                        RETURN CODE FIELD\n.ST01050 ANOP  ,\n         AIF   ('&STAMODE' EQ '' OR '&STACREG' NE '').ST01100\n&P.CAPWD DS    A                        USED BY CAPPING SUPPORT\n.ST01100 ANOP  ,\n         AIF   (NOT &STF(18)).ST01200\n&STF(18) SETB  0                        TURN BACK OFF\n&P.IPK   DS    A                        INITIAL PROTECT KEY\n.ST01200 ANOP  ,\n&A       SETA  &STWAC                   PICK UP # DEFERRED WORK FIELDS\n&B       SETA  -1                       SET UP INDEX COUNTER\n.ST01300 ANOP  ,\n&B       SETA  &B+2                     POINT TO NEXT ELEMENT ON STACK\n         AIF   (&B GE &A).ST01800       NO MORE, CONTINUE\n&K       SETC  '&STWAD(&B)'             PICK UP LABEL\n&L       SETC  '&STWAD(&B+1)'           PICK UP OPERAND\n&C       SETA  K'&L                     PICK UP LENGTH OF OPERAND\n         AIF   ('&L'(&C,1) EQ '''').ST01600   THIS IS A DC\n         AIF   ('&L'(&C,1) NE ')').ST01700    THIS IS A DS\n.ST01400 ANOP  ,\n&C       SETA  &C-1                     BY SCANNING BACKWARDS\n         AIF   (&C LT 2).ST01700        ERROR - NO LEFT PARENTHESIS\n         AIF   ('&L'(&C,1) EQ '(').ST01500   FOUND THE LEFT\n         AGO   .ST01400                 GO CONTINUE SCAN\n.ST01500 ANOP  ,\n         AIF   ('&L'(&C-1,1) EQ 'L').ST01700   ITS A DS WITH LENGTH\n.ST01600 ANOP  ,\n&K       DC    &L                       DEFERRED WORK FIELD\n         AGO   .ST01300                 GO GET NEXT ELEMENT ON STACK\n.ST01700 ANOP  ,\n&K       DS    &L                       DEFERRED WORK FIELD\n         AGO   .ST01300                 GO GET NEXT ELEMENT ON STACK\n.ST01800 ANOP  ,\n         MEXIT ,                        EXIT\n.ST90100 MNOTE 4,'ST3001A - #START MACRO NOT CODED IN THIS PROGRAM'\n         MEXIT ,\n.ST90200 MNOTE 4,'ST3002A - #START MACRO NOT DEFINED WITH WORKAREA'\n.MEND    MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#STOP": {"ttr": 3329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x14\\x11/\\x01\\x14\\x11/\\x12H\\x01\\xd2\\x01\\xd2\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-04-22T00:00:00", "modifydate": "2014-04-22T12:48:33", "lines": 466, "newlines": 466, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    #STOP &RC=,                    RETURN CODE                    X\n               &R0=,                    R0 CONTENTS TO PASS BACK       X\n               &R1=,                    R1 CONTENTS TO PASS BACK       X\n               &WKREG=R9,               RC SAVE REGISTER               X\n               &USE=BR                  RETURN TYPE (BR/BSM/SVC/PSARET)\n.*\n         SPLEVEL TEST                   OBTAIN SPLEVEL VALUE\n.*\n&NAME    #NULL ,                        #STOP MACRO\n.*\n.* DEFINE SYMBOLS NEEDED\n.*\n         GBLA  &STWAC                   COUNTER FOR DEFERED WA DEFINES\n         GBLB  &STWA                    INDICATES CSECT HAS A WORK AREA\n         GBLB  &STF(24)                 CONTROL FLAG BITS, AS FOLLOWS:\n.*                                       (01) - PROC OPTION CODED\n.*                                       (02) - MAIN OPTION CODED\n.*                                       (03) - LIFO OPTION CODED\n.*                                       (04) - WKCSECT OPTION CODED\n.*                                       (05) - WKDSECT OPTION CODED\n.*                                       (06) - #START HAS BEEN CODED\n.*                                       (07) - ROUTINE IS AN SVC\n.*                                       (08) - WORK FIELDS WANTED\n.*                                       (09) - SVAREA=NO OPTION\n.*                                       (10) - SAVE=YES OPTION\n.*                                       (11) - RSECT=YES OPTION\n.*                                       (12) - SVC=(YES,BRANCH)\n.*                                       (13) - ENUC CAPPING\n.*                                       (18) - EXTKEY= OPTION\n.*                                       (22) - 64 BIT REGS\n.*                                       (23) - #BAKR\n         GBLC  &STACREG                 CAPWORD SAVE REGISTER\n         GBLC  &STAGREG                 GET/FREEMAIN FORMAT\n         GBLC  &STAMODE                 MODULE'S CAPPED AMODE\n         GBLC  &STAXKEY                 SVC EXECUTION KEY\n         GBLC  &STISASZ                 LIFO ISA SIZE\n         GBLC  &STNAME                  MAIN CSECT NAME\n         GBLC  &STPREF                  PREFIX CHARACTERS\n         GBLC  &STSPN                   SUBPOOL NUMBER\n         GBLC  &STWAD(1000)             WORK AREA DEFERED STACK\n         GBLC  &STWANAM                 WORK AREA NAME\n         GBLC  &SYSSPLV                 SPLEVEL\n         LCLA  &A,&B,&C,&D,&E           LOCAL\n         LCLB  &F,&G,&H,&I,&J           WORK\n         LCLC  &K,&L,&M,&N,&O,&P        SYMBOLS\n         LCLC  &XX1,&XX2,&R2\n         AIF   (NOT &STF(23)).ST00050\n         MNOTE 12,'#STOP NOT VALID AFTER #BAKR'\n         MEXIT ,\n.ST00050 ANOP  ,\n&XX1     SETC  'BR'\n&XX2     SETC  'R14'\n         AIF   ('&STAMODE' NE '').ST00400 USE BR IF CAPPING\n         AIF   ('&USE' NE 'BSM' AND NOT &STF(13)).ST00100\n&XX1     SETC  'BSM'\n&XX2     SETC  '0,R14'\n         AIF   ('&SYSSPLV' NE '1').ST00400\n         MNOTE 4,'**WARNING** USE=BSM CHANGED TO USE=PSARET BECAUSE SPLX\n               EVEL=1'\n         AGO   .ST00300\n.ST00100 ANOP  ,\n         AIF   ('&USE' NE 'SVC').ST00200\n&XX1     SETC  'SVC'\n&XX2     SETC  '3'\n.ST00200 ANOP  ,\n         AIF   ('&USE' NE 'PSA' AND '&USE' NE 'PSARET').ST00400\n.ST00300 ANOP  ,\n&XX1     SETC  'B'\n&XX2     SETC  '890'\n.ST00400 ANOP  ,\n.*\n.* INITIALIZE SYMBOLS, SET UP PREFIX, PICK UP ALL OPERANDS\n.*\n&P       SETC  '&STPREF'                PICK UP PREFIX\n&N       SETC  '&STWANAM'               PICK UP WORK AREA NAME\n.*\n         AIF   (&STF(7)).ST04800        SVC EXIT HERE\n.*\n.*\n.* THE FOLLOWING IS PRELIMINARIES, ETC\n.*\n         AIF   ('&R0' EQ '' AND '&R1' EQ '').ST01200   NO R0 OR R1\n&R2      SETC  'R13'\n         AIF   (&STF(09)).ST00600       SAVE=NO OPTION ?\n         L     R2,4(0,R13)              PT TO CALLER'S SAVE AREA\n&R2      SETC  'R2'\n.ST00600 ANOP  ,\n         AIF   ('&R0' EQ '').ST00900   NO R0, CONTINUE\n         AIF   ('&R0' EQ '0' OR '&R0' EQ 'R0').ST00800   0 OR R0\n         AIF   ('&R0' EQ '(0)' OR '&R0' EQ '(R0)').ST00800\n         AIF   ('&R0'(1,1) EQ '(').ST00700   ANOTHER REGISTER\n         AIF   (NOT &STF(22)).ST00650   NOT 64 BIT REGS\n         LGHI  R0,&R0                   R0 HAS RETURN VALUE\n         AGO   .ST00800\n.ST00650 ANOP  ,\n         LA    R0,&R0                   R0 HAS RETURN VALUE\n         AGO   .ST00800                 CONTINUE\n.ST00700 ANOP  ,\n         AIF   (NOT &STF(22)).ST00750   NOT 64 BIT REGS\n         LGR   R0,&R0(1)                R0 HAS RETURN VALUE\n         AGO   .ST00800\n.ST00750 ANOP  ,\n         LR    R0,&R0(1)                R0 HAS RETURN VALUE\n.ST00800 ANOP  ,\n         ST    R0,20(&R2,0)             IN SAVE AREA\n         AIF   (NOT &STF(22)).ST00900   NOT 64 BIT REGS\n         STCMH R0,15,&P.HISAVE          SAVE HIGH WORD\n.ST00900 ANOP  ,\n         AIF   ('&R1' EQ '').ST01200    NO R1, CONTINUE\n         AIF   ('&R1' EQ '1' OR '&R1' EQ 'R1').ST01100   1 OR R1\n         AIF   ('&R1' EQ '(1)' OR '&R1' EQ '(R1)').ST01100\n         AIF   ('&R1'(1,1) EQ '(').ST01000   ANOTHER REGISTER\n         AIF   (NOT &STF(22)).ST00950   NOT 64 BIT REGS\n         LGHI  R1,&R1                   R1 HAS RETURN VALUE\n         AGO   .ST01100\n.ST00950 ANOP  ,\n         LA    R1,&R1                   R1 HAS RETURN VALUE\n         AGO   .ST01100                 CONTINUE\n.ST01000 ANOP  ,\n         AIF   (NOT &STF(22)).ST01050   NOT 64 BIT REGS\n         LGR   R1,&R1(1)                R1 HAS RETURN VALUE\n         AGO   .ST01100\n.ST01050 ANOP  ,\n         LR    R1,&R1(1)                R1 HAS RETURN VALUE\n.ST01100 ANOP  ,\n         ST    R1,24(&R2,0)             IN SAVE AREA\n         AIF   (NOT &STF(22)).ST01200   NOT 64 BIT REGS\n         STCMH R1,15,&P.HISAVE+4        SAVE HIGH WORD\n.ST01200 ANOP  ,\n         AIF   ('&RC' EQ '').ST01400    NO RETURN CODE SUPPLIED\n         AIF   ('&RC'(1,1) EQ '(').ST01300   RETURN CODE IS A REG\n         LA    R15,&RC                  R15 HAS RETURN CODE\n         AGO   .ST01600                 CONTINUE\n.ST01300 ANOP  ,\n         AIF   ('&RC' EQ '(15)' OR '&RC' EQ '(R15)').ST01600\n         LR    R15,&RC(1)               R15 HAS RETURN CODE\n         AGO   .ST01600                 CONTINUE\n.ST01400 ANOP  ,\n         AIF   (NOT &STWA).ST01500      NO WORK AREA, CONTINUE\n         L     R15,&P.RCODE             R15 HAS RETURN CODE\n         AGO   .ST01600                 CONTINUE\n.ST01500 ANOP  ,\n         SR    R15,R15                  SET RETURN CODE TO ZERO\n.*\n.* THE FOLLOWING IS FOR NO WORK AREA OPTION, WKCSECT OPTION, AND THE\n.* PROC OPTION BUT NOT PROC(MAIN), LIFO OR PLAIN WKDSECT OPTIONS\n.*\n.ST01600 ANOP  ,\n         AIF   (&STF(2) OR &STF(3)).ST01900   MAIN OR LIFO, CONTINUE\n         AIF   (&STF(5) AND NOT &STF(1)).ST01900   WKDSECT, CONTINUE\n         AIF   (NOT &STF(10)).ST02500   SAVE=NO OPTION ?\n         AIF   ('&STAMODE' EQ '').ST01800 CAPPED CODE ?\n         AIF   ('&STACREG' EQ '').ST01700\n         LR    R2,&STACREG              RETRIEVE CAP WORD\n         AGO   .ST01800\n.ST01700 ANOP  ,\n         L     R2,&P.CAPWD              RETRIEVE CAP WORD\n.ST01800 ANOP  ,\n         AIF   (&STF(9)).ST02500        SVAREA=NO OPTION ?\n         L     R13,4(0,R13)             RESTORE CALLER'S SAVE AREA\n         AGO   .ST02500                 BR TO COMMON CODE\n.*\n.* THE FOLLOWING IS FOR A PLAIN WKDSECT OPTION\n.*\n.ST01900 ANOP  ,\n         AIF   (&STF(2) OR &STF(3)).ST03400   MAIN OR LIFO, CONTINUE\n         LR    R1,R13                   SAVE WORK AREA ADDRESS\n         AIF   ('&STAMODE' EQ '').ST02100 CAPPED CODE ?\n         AIF   ('&STACREG' EQ '').ST02000\n         LR    R2,&STACREG              RETRIEVE CAP WORD\n         AGO   .ST02100\n.ST02000 ANOP  ,\n         L     R2,&P.CAPWD              RETRIEVE CAP WORD\n.ST02100 ANOP  ,\n         AIF   (NOT &STF(18)).ST02150\n         L     R3,&P.IPK                LOAD ORIGINAL PROTECT KEY\n.ST02150 ANOP  ,\n         AIF   (NOT &STF(10)).ST02800   JUMP IF SAVE=NO\n         L     R13,4(0,R13)             RESTORE CALLER'S SAVE AREA\n         LR    &WKREG,R15               SAVE RETURN CODE\n         AIF   (&STF(17)).ST02200\n         MNOTE '         FREEMAIN &STAGREG,LV=&P.WALEN,A=(1),SP=&STSPN'\n         FREEMAIN &STAGREG,LV=&P.WALEN,A=(1),SP=&STSPN\n         AGO   .ST02300\n.ST02200 ANOP  ,\n.*       ADD SUPPORT FOR CALLRKY TO HANDLE SP=230 PROPERLY\n         MNOTE '         STORAGE RELEASE,LENGTH=&P.WALEN,ADDR=(1),SP=&SX\n               TSPN,CALLRKY=YES'\n         STORAGE RELEASE,LENGTH=&P.WALEN,ADDR=(1),SP=&STSPN,CALLRKY=YES\n.ST02300 ANOP  ,\n         AIF   (NOT &STF(18)).ST02400\n         SPKA  0(R3)                    RETURN TO ORIGINAL PROTECT KEY\n.ST02400 ANOP  ,\n         LR    R15,&WKREG               RESTORE RETURN CODE\n.*\n.ST02500 ANOP  ,\n         AIF   ('&STAMODE' EQ '').ST02700 CAPPED CODE ?\n         AIF   ('&SYSSPLV' NE '1').ST02600\n         L     R1,16                    POINT TO CVT\n         TM    116(R1),128              IS THIS MVS/XA ?\n         BZR   R2                       NO, DO NOT CAP\n.ST02600 ANOP  ,\n         BSM   0,R2                     RESUME CALLER'S AMODE\n&K       SETC  '&P.RRR14'\n.ST02700 ANOP  ,\n&K       L     R14,12(0,R13)            RESTORE REGISTER 14\n         LM    R0,R12,20(R13)           RESTORE REGISTERS 0-12\n         &XX1  &XX2                     RETURN TO CALLER\n         SPACE 1\n         MEXIT ,\n.*\n.ST02800 ANOP  ,\n         LR    R13,R15                  SAVE RETURN CODE\n         L     R0,=A(&P.WALEN)\n         AIF   (&STF(17)).ST02900\n         MNOTE '         FREEMAIN &STAGREG,LV=&P.WALEN,A=(1),SP=&STSPN'\n         FREEMAIN &STAGREG,LV=&P.WALEN,A=(1),SP=&STSPN\n         AGO   .ST03000\n.ST02900 ANOP  ,\n.*       ADD SUPPORT FOR CALLRKY TO HANDLE SP=230 PROPERLY\n         MNOTE '         STORAGE RELEASE,LENGTH=&P.WALEN,ADDR=(1),SP=&SX\n               TSPN,CALLRKY=YES'\n         STORAGE RELEASE,LENGTH=&P.WALEN,ADDR=(1),SP=&STSPN,CALLRKY=YES\n.ST03000 ANOP  ,\n         AIF   (NOT &STF(18)).ST03100\n         SPKA  0(R3)                    RETURN TO ORIGINAL PROTECT KEY\n.ST03100 ANOP  ,\n         LR    R15,R13                  SET RETURN CODE\n         AIF   ('&STAMODE' EQ '').ST03300 CAPPED CODE ?\n         AIF   ('&SYSSPLV' NE '1').ST03200\n         L     R1,16                    POINT TO CVT\n         TM    116(R1),128              IS THIS MVS/XA ?\n         BZR   R2                       NO, DO NOT CAP\n.ST03200 ANOP  ,\n         BSM   0,R2                     RESUME CALLER'S AMODE\n&K       SETC  '&P.RRR14'\n.ST03300 ANOP  ,\n&K       &XX1  &XX2                     RETURN TO CALLER\n         SPACE 1\n         MEXIT ,\n.*\n.* FOLLOWING IS FOR PROC, LIFO OPTIONS\n.*\n.ST03400 ANOP  ,\n         AIF   (&STF(2)).ST04000        MAIN OPTION, CONTINUE\n         LR    R1,R13                   SAVE WORK AREA ADDRESS\n         AIF   ('&STAMODE' EQ '').ST03600 CAPPED CODE ?\n         AIF   ('&STACREG' EQ '').ST03500\n         LR    R2,&STACREG              RETRIEVE CAP WORD\n         AGO   .ST03600\n.ST03500 ANOP  ,\n         L     R2,&P.CAPWD              RETRIEVE CAP WORD\n.ST03600 ANOP  ,\n         AIF   (NOT &STF(22)).ST03650   NOT 64 BIT REGS\n         LMH   R0,R12,&P.HISAVE         RESTORE HIGH WORDS\n.ST03650 ANOP  ,\n         L     R13,4(R13)            RESTORE CALLER'S SAVE AREA\n         ST    R15,16(R13)           STORE RETURN CODE\n         LR    R0,R1                    PT TO AREA TO FREE\n         L     R1,0(R13)                PT TO MODULE COMM AREA\n         L     R15,&P.#FRE-&P.MCA(R1)   PT TO LIFO FREE ROUTINE\n         BALR  R14,R15                  GO FREE WORK AREA FROM STACK\n.ST03700 ANOP  ,\n         AIF   ('&STAMODE' EQ '').ST03900 CAPPED CODE ?\n         AIF   ('&SYSSPLV' NE '1').ST03800\n         L     R1,16                    POINT TO CVT\n         TM    116(R1),128              IS THIS MVS/XA ?\n         BZR   R2                       NO, DO NOT CAP\n.ST03800 ANOP  ,\n         BSM   0,R2                     RESUME CALLER'S AMODE\n&K       SETC  '&P.RRR14'\n.ST03900 ANOP  ,\n&K       LM    R14,R12,12(R13)          RESTORE CALLER'S REGISTERS\n         &XX1  &XX2                     RETURN TO CALLER\n         SPACE 1\n         MEXIT ,                        EXIT\n.*\n.* FOLLOWING IS FOR PROC(MAIN) WITH OR WITHOUT LIFO OPTION\n.*\n.ST04000 ANOP  ,\n         L     R1,0(0,R13)              R1 HAS MCA ADDRESS\n         L     R1,&P.#O-&P.MCA(0,R1)    PT TO GETMAINED AREA\n         AIF   ('&STAMODE' EQ '').ST04200 CAPPED CODE ?\n         AIF   ('&STACREG' EQ '').ST04100\n         LR    R2,&STACREG              RETRIEVE CAP WORD\n         AGO   .ST04200\n.ST04100 ANOP  ,\n         L     R2,&P.CAPWD              RETRIEVE CAP WORD\n.ST04200 ANOP  ,\n         AIF   (NOT &STF(18)).ST04250\n         L     R3,&P.IPK                LOAD ORIGINAL PROTECT KEY\n.ST04250 ANOP  ,\n         L     R13,4(0,R13)             RESTORE CALLER'S SAVE AREA\n         ST    R15,16(0,R13)            STORE RETURN CODE\n         #RLIF R15,&P.GSIZE             R15 = LENGTH OF LIFO STACK\n         LR    R0,R15                   R0 HAS LENGTH OF LIFO STACK\n         AIF   (&STF(17)).ST04300\n         MNOTE '         FREEMAIN &STAGREG,LV=(0),A=(1),SP=&STSPN'\n         FREEMAIN &STAGREG,LV=(0),A=(1),SP=&STSPN\n         AGO   .ST04400\n.ST04300 ANOP  ,\n.*       ADD SUPPORT FOR CALLRKY TO HANDLE SP=230 PROPERLY\n         MNOTE '         STORAGE RELEASE,LENGTH=(0),ADDR=(1),SP=&STSPN,X\n               CALLRKY=YES'\n         STORAGE RELEASE,LENGTH=(0),ADDR=(1),SP=&STSPN,CALLRKY=YES\n.ST04400 ANOP  ,\n         AIF   (NOT &STF(18)).ST04500\n         SPKA  0(R3)                    RETURN TO ORIGINAL PROTECT KEY\n.ST04500 ANOP  ,\n         AIF   ('&STAMODE' EQ '').ST04700 CAPPED CODE ?\n         AIF   ('&SYSSPLV' NE '1').ST04600\n         L     R1,16                    POINT TO CVT\n         TM    116(R1),128              IS THIS MVS/XA ?\n         BZR   R2                       NO, DO NOT CAP\n.ST04600 ANOP  ,\n         BSM   0,R2                     RESUME CALLER'S AMODE\n&K       SETC  '&P.RRR14'\n.ST04700 ANOP  ,\n&K       LM    R14,R12,12(R13)          RESTORE CALLER'S REGISTERS\n         &XX1  &XX2                     RETURN TO CALLER\n         SPACE 1\n         AGO   .ST06400                 GO TO LIFO CHECK\n.*\n.* FOLLOWING IS FOR SVC TYPE LINKAGES\n.*\n.ST04800 ANOP  ,\n         AIF   ('&R0' EQ '').ST05000   NO R0, CONTINUE\n         AIF   ('&R0' EQ '0' OR '&R0' EQ 'R0').ST05000   0 OR R0\n         AIF   ('&R0' EQ '(0)' OR '&R0' EQ '(R0)').ST05000   0 OR R0\n         AIF   ('&R0'(1,1) EQ '(').ST04900   ANOTHER REGISTER\n         LA    R0,&R0                   R0 HAS RETURN VALUE\n         AGO   .ST05000                 CONTINUE\n.ST04900 ANOP  ,\n         LR    R0,&R0(1)                R0 HAS RETURN VALUE\n.*\n.ST05000 ANOP  ,\n         AIF   ('&R1' EQ '').ST05200    NO R1, CONTINUE\n         AIF   ('&R1' EQ '1' OR '&R1' EQ 'R1').ST05200   1 OR R1\n         AIF   ('&R1' EQ '(1)' OR '&R1' EQ '(R1)').ST05200   1 OR R1\n         AIF   ('&R1'(1,1) EQ '(').ST05100   ANOTHER REGISTER\n         LA    R1,&R1                   R1 HAS RETURN VALUE\n         AGO   .ST05200                 CONTINUE\n.ST05100 ANOP  ,\n         LR    R1,&R1(1)                R1 HAS RETURN VALUE\n.*\n.ST05200 ANOP  ,\n         AIF   ('&RC' EQ '').ST05400    NO RETURN CODE SUPPLIED\n         AIF   ('&RC' EQ '(15)' OR  '&RC' EQ '(R15)').ST05600\n         AIF   ('&RC'(1,1) EQ '(').ST05300   RETURN CODE IS A REG\n         LA    R15,&RC                  R15 HAS RETURN CODE\n         AGO   .ST05600                 CONTINUE\n.ST05300 ANOP  ,\n         LR    R15,&RC(1)               R15 HAS RETURN CODE\n         AGO   .ST05600                 CONTINUE\n.ST05400 ANOP  ,\n         AIF   (NOT &STWA).ST05500      NO WORK AREA, CONTINUE\n         L     R15,&P.RCODE             R15 HAS RETURN CODE\n         AGO   .ST05600                 CONTINUE\n.ST05500 ANOP  ,\n         SR    R15,R15                  SET RETURN CODE TO ZERO\n.*\n.ST05600 ANOP  ,\n         AIF   (&STF(2) OR &STF(3)).ST05700     MAIN OR LIFO\n         AIF   (&STWA).ST05700          WORK AREA TO FREE\n         &XX1  &XX2                     RETURN TO SVC IH\n         SPACE 1\n         AGO   .ST06400\n.*\n.ST05700 ANOP  ,\n         L     R14,0(0,R13)             RELOAD RETURN ADDRESS\n         LR    R4,R15                   SAVE RETURN CODE\n         LR    R2,R0\n         LR    R5,R1\n         AIF   (NOT &STF(18)).ST05800\n         L     R3,&P.IPK                LOAD ORIGINAL PROTECT KEY\n.ST05800 ANOP  ,\n         LR    R1,R13                   WORK AREA ADDR IN REG 1\n         AIF   (&STF(17)).ST06000\n         AIF   (&STF(12)).ST05900\n         MNOTE '         FREEMAIN &STAGREG,LV=&P.WALEN,A=(1),SP=&STSPN'\n         FREEMAIN &STAGREG,LV=&P.WALEN,A=(1),SP=&STSPN\n         AGO   .ST06100\n.ST05900 ANOP  ,\n         LR    &WKREG,R14               SAVE REG 14\n         MNOTE '         FREEMAIN &STAGREG,LV=&P.WALEN,A=(1),SP=&STSPN,X\n               BRANCH=YES'\n         FREEMAIN &STAGREG,LV=&P.WALEN,A=(1),SP=&STSPN,BRANCH=YES\n         LR    R14,&WKREG               RESTORE REG 14\n         AGO   .ST06100\n.ST06000 ANOP  ,\n.*       ADD SUPPORT FOR CALLRKY TO HANDLE SP=230 PROPERLY\n         LR    &WKREG,R14               SAVE REG 14\n         MNOTE '         STORAGE RELEASE,LENGTH=&P.WALEN,ADDR=(1),SP=&SX\n               TSPN,CALLRKY=YES'\n         STORAGE RELEASE,LENGTH=&P.WALEN,ADDR=(1),SP=&STSPN,CALLRKY=YES\n         LR    R14,&WKREG               RESTORE REG 14\n.ST06100 ANOP  ,\n         AIF   (NOT &STF(18)).ST06200\n         SPKA  0(R3)                    RETURN TO ORIGINAL PROTECT KEY\n.ST06200 ANOP  ,\n         LR    R0,R2                    RELOAD REGS\n         LR    R1,R5\n.ST06300 ANOP  ,\n         LR    R15,R4\n         &XX1  &XX2                     RETURN TO SVC IH\n         SPACE 1\n.*\n.* THE FOLLOWING IS FOR PROC(MAIN) AND LIFO OPTIONS\n.*\n.ST06400 ANOP  ,\n         AIF   (NOT &STF(3)).MEND       NOT LIFO, ALL FINISHED\n         AIF   (T'#####GET NE 'U').MEND AVOID DUPLICATE DEFINITION\n***********************************************************************\n*\n*        LIFO STACK GET/FREE STORAGE ROUTINES\n*\n         PUSH  USING\n         DROP  ,\n*                                       R1 POINTS TO MCA\n#####GET RSECT ,                        LIFO GET ROUTINE\n#####GET AMODE ANY\n#####GET RMODE ANY\n         AHI   R0,7                     ROUND REQUEST UP TO\n         LHI   R15,-8                   A DOUBLEWORD BOUNDARY\n         NR    R0,R15                   .\n         A     R0,&P.#N-&P.MCA(R1)   PT TO NEXT FREE LIFO SLOT\n         CL    R0,&P.#E-&P.MCA(R1)   IF WE'VE GONE PAST THE END\n         JH    &P.GA                 OF THE STACK, ABEND\n         L     R15,&P.#N-&P.MCA(R1)     PT TO ALLOCATED SLOT\n         ST    R0,&P.#N-&P.MCA(R1)      SAVE ADDR. OF NEXT SLOT\n         LR    R1,R15                   MOVE SLOT POINTER\n         BR    R14                      RETURN TO CALLER, R1 @ SLOT\n*        ABEND 1000,DUMP                STACK TOO SMALL, USE ISA=\n&P.GA    LA    R1,1000                  LOAD ABEND CODE\n         LHI   R15,1                    CREATE THE MOST SIGNIF.\n         SLL   R15,31                   . BIT\n         OR    R1,R15                   TURN ON DUMP FLAG\n         SVC   13                       ISSUE ABEND SVC\n         SPACE 1\n         ENTRY ####FREE                 LIFO FREE ROUTINE\n####FREE CL    R0,&P.#S-&P.MCA(R1)      ENSURE THE ADDRESS\n         JL    &P.FA                    TO BE FREE'ED\n         CL    R0,&P.#E-&P.MCA(R1)     IS WITHIN THE BOUNDARIES\n         JH    &P.FA                    OF THE CUR.STACK ELEM.\n         AHI   R0,7                    FORCE AREA TO BE FREE'ED\n         LHI   R15,-8                   TO DOUBLEWORD BOUNDARY\n         NR    R0,R15                   .\n         ST    R0,&P.#N-&P.MCA(R1)   SAVE @ NEXT FREE LIFO SLOT\n         BR    R14                      RETURN TO CALLER\n*\n&P.FA    LA    R1,1001                  LOAD ABEND CODE\n         LHI   R15,1                    CREATE THE MOST SIGNIF.\n         SLL   R15,31                   . BIT\n         OR    R1,R15                   TURN ON DUMP FLAG\n         SVC   13                       ISSUE ABEND SVC\n         SPACE 1\n         CNOP  0,4                      GET FULLWORD BOUNDARY\n         POP   USING                    KILL ADDRESSABILITY\n         SPACE 1\n         AIF   (&STF(11)).ST06600\n&SYSECT  CSECT ,                        RESUME MAIN PROGRAM CSECT\n         MEXIT ,\n.ST06600 ANOP  ,\n&SYSECT  RSECT ,                        RESUME MAIN PROGRAM RSECT\n.MEND    MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#STOPWA": {"ttr": 4353, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x14\\x11/\\x01\\x14\\x11/\\x12H\\x00d\\x00d\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-04-22T00:00:00", "modifydate": "2014-04-22T12:48:33", "lines": 100, "newlines": 100, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         #STOPWA ,                      #STOPWA MACRO\n.*\n.* DEFINE SYMBOLS NEEDED, NOTE ALL GLOBALS ARE FROM #START MACRO\n.*\n         GBLA  &STWAC                   COUNTER FOR DEFERED WA DEFINES\n         GBLB  &STWA                    INDICATES CSECT HAS A WORK AREA\n         GBLB  &STF(24)                 CONTROL FLAG BITS, AS FOLLOWS:\n.*                                       (01) - PROC OPTION CODED\n.*                                       (02) - MAIN OPTION CODED\n.*                                       (03) - LIFO OPTION CODED\n.*                                       (04) - WKCSECT OPTION CODED\n.*                                       (05) - WKDSECT OPTION CODED\n.*                                       (06) - #START HAS BEEN CODED\n.*                                       (07) - ROUTINE IS AN SVC\n.*                                       (08) - WORK FIELDS WANTED\n.*                                       (09) - SVAREA=NO OPTION\n.*                                       (10) - SAVE=YES OPTION\n.*                                       (11) - RSECT=YES OPTION\n.*                                       (12) - SVC=(YES,BRANCH)\n.*                                       (13) - ENUC CAPPING\n.*                                       (14) - PATCH AREA REQUEST\n.*                                       (18) - EXTKEY= OPTION\n.*\n         GBLC  &STPREF                  PREFIX CHARACTERS\n         GBLC  &STWANAM                 WORK AREA NAME\n         GBLC  &STNAME                  MAIN CSECT NAME\n         GBLC  &STAMODE                 MODULE'S CAPPED AMODE\n         GBLC  &STACREG                 CAPWORD SAVE REGISTER\n         GBLC  &STISASZ                 LIFO ISA SIZE\n         GBLC  &SYSSPLV                 SPLEVEL\n         GBLC  &STA_CONSTANT_SECTION\n         GBLC  &STWAD(1000)             WORK AREA DEFERED STACK\n         LCLA  &A,&B,&C,&D,&E           LOCAL\n         LCLB  &F,&G,&H,&I,&J           WORK\n         LCLC  &K,&L,&M,&N,&O,&P        SYMBOLS\n         LCLC  &CSNAME                  SAVE CSECT NAME\n.*\n.* INITIALIZE SYMBOLS, SET UP PREFIX\n.*\n&P       SETC  '&STPREF'                MAKE PREFIX EASIER TO WORK WITH\n         AIF   (NOT &STF(6)).ST90100    ERROR - NO #START MACRO CODED\n         AIF   (NOT &STWA).ST90200      ERROR - NO WORK AREA SPECIFIED\n.*\n.* THE FOLLOWING IS COMMON TO ALL WORKAREAS\n.*\n         DS    0D                       FORCE WORK AREA TO DWD BOUNDARY\n&P.WALEN EQU   *-&STWANAM               LENGTH OF WORK AREA\n.*\n.* THE FOLLOWING IS FOR THE PROC OPTION ONLY\n.*\n         AIF   (NOT &STF(1)).ST00200    NO PROC OPTION, CONTINUE\n         AIF   (&STF(2)).ST00200        MAIN OPTION, CONTINUE\n         AIF   (&STF(3)).ST00100        LIFO OPTION, CONTINUE\n         AIF   (&STF(23)).ST00200       #STACK W/O LIFO\n         SPACE 1\n&P.MCA   DSECT ,                        MODULE COMMUNICATIONS AREA\n&P.#O    DS    A                        ORIGIN OF GETMAINED AREA\n         AGO   .ST00200                 CONTINUE\n.*\n.* THE FOLLOWING IS FOR PROC AND LIFO OPTIONS, BUT NOT MAIN\n.*\n.ST00100 ANOP  ,\n         SPACE 1\n&P.MCA   DSECT ,                        MODULE COMMUNICATIONS AREA\n&P.#O    DS    A                        ORIGIN OF GETMAINED AREA\n&P.#GET  DS    V(#####GET)              PTR TO LIFO GET ROUTINE\n&P.#FRE  DS    V(####FREE)              PTR TO LIFO FREE ROUTINE\n&P.#S    DS    A                        PTR TO START OF LIFO STACK\n&P.#E    DS    A                        PTR TO END OF LIFO STACK\n&P.#N    DS    A                        PTR TO NEXT FREE AREA\n.*\n.* THE FOLLOWING IS COMMON FOR ALL WORK AREA TYPES\n.*\n.ST00200 ANOP  ,\n&CSNAME  SETC  '&STNAME'\n         AIF   (&STF(11)).ST00300\n&CSNAME  CSECT ,                        RESUME MAIN PROGRAM CSECT\n         AGO   .ST00400\n.ST00300 ANOP  ,\n&CSNAME  RSECT ,                        RESUME MAIN PROGRAM RSECT\n.ST00400 ANOP  ,\n         AIF   (NOT &STF(2)).ST00600    NOT PROC(MAIN), CONTINUE\n         AIF   (&STF(3)).ST00500        SKIP CXD IF LIFO\n&P.GSIZE CXD   ,                        GET CUMULATIVE WORK AREA LENGTH\n         AGO   .ST00600\n.ST00500 ANOP  ,\n&P.GSIZE DC    A(&STISASZ)              ISA SIZE REQUESTED\n.ST00600 ANOP  ,\n         AIF   (NOT &STF(1)).ST00700    NOT PROC OPTION, CONTINUE\n         AIF   (&STF(3)).ST00700        SKIP IF LIFO\n         AIF   (&STF(23)).ST00700       SKIP IF #STACK\n&P.QCON  DC    Q(&STWANAM)              OFFSET TO EXTNL DUMMY SECTION\n.ST00700 ANOP  ,\n         SPACE 1\n         MEXIT ,\n.ST90100 MNOTE 4,'ST4001A - #START MACRO NOT CODED IN THIS PROGRAM'\n         MEXIT ,\n.ST90200 MNOTE 4,'ST4002A - #START MACRO NOT DEFINED WITH WORKAREA'\n.MEND    MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#TIME": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00\\xe3\\x00\\xe3\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 227, "newlines": 227, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,                   |\n&LABEL   #TIME &TO,&FROM=,&FORMAT='HHMMSSTH',&CLOCK=24,&PAD='0',       *\n               &LIST=YES\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*       TO     (REQUIRED) - OUTPUT BUFFER (WORKTIME OR (R2-R15))     *\n.*                                                                    *\n.*       FROM=             - SUPPLIED TIME (FULLWORD OR (R0-R15))     *\n.*                                                                    *\n.*       FORMAT= HH        - HOUR (00-23)                             *\n.*               MM        - MINUTES (00-60)                          *\n.*               SS        - SECONDS (00-60)                          *\n.*               TH        - TENTHS & HUNDREDTHS OF SECONDS           *\n.*               AM|PM     - PART OF DAY (MORNING OR AFTERNOON)       *\n.*                                                                    *\n.*       CLOCK=  12|24     - STANDARD OR MILITARY CLOCK OPTION        *\n.*                                                                    *\n.*       PAD=    '0'       - 1 BYTE PAD CHARACTER FOR HH ENCLOSED     *\n.*                           WITHIN QUOTES                            *\n.*                                                                    *\n.*       LIST=   YES|NO    - PRINT GENERATION OPTION                  *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n         GBLB  &STF(10)            |\n         GBLC  &STPREF             |\n         LCLA  &A,&B,&C,&D         |\n         LCLB  &F,&G,&H,&I         |\n         LCLC  &K,&P,&Q,&X,&REG    |\n&STF(8)  SETB  1                   | INDICATE #STARTWA FIELDS WANTED\n&X       SETC  'TM&SYSNDX'         | GENERATE LABEL PREFIX\n&P       SETC  '&STPREF.DBL1'      | DOUBLE WORD WORKAREA #1\n&Q       SETC  '&STPREF.DBL2'      | DOUBLE WORD WORKAREA #2\n         AIF   ('&LIST' EQ 'YES').TIM0100\n         AIF   ('&LIST' NE 'NO').TIMERR1\n         PUSH  PRINT\n         PRINT NOGEN\n.TIM0100 ANOP  ,                   |\n         AIF   ('&LABEL' EQ '').TIM0200\n&LABEL   DS    0H                  #TIME MACRO - START\n.TIM0200 ANOP  ,                   |\n&A       SETA  K'&PAD              | LENGTH OF PAD FIELD\n         AIF   (&A NE 3).TIMERR2   | IF NOT 3 BYTES, ERROR\n*-------\n*        #TIME INITIALIZATION\n*-------\n         AIF   ('&TO' EQ '').TIMERR3\n         AIF   ('&CLOCK' EQ '12').TIM0300\n         AIF   ('&CLOCK' NE '24').TIMERR4\n.TIM0300 ANOP  ,                   |\n         AIF   ('&FROM' EQ '').TIM0600\n         AIF   ('&FROM'(1,1) EQ '(').TIM0400\n         ICM   R0,15,&FROM         R0 HAS TIME - HHMMSSTH\n         AGO   .TIM0500            |\n.TIM0400 ANOP  ,                   |\n&REG     SETC  '&FROM'(2,K'&FROM-2)\n         AIF   ('&REG' EQ 'R0' OR '&REG' EQ '0').TIM0500\n         LR    R0,&REG             R0 HAS TIME - HHMMSSTH\n.TIM0500 ANOP  ,                   |\n         C     R0,&X.D             CHECK FOR MAXIMUM TIME OF DAY\n         BH    &X.A                B. IF TOO HIGH\n         LTR   R0,R0               CHECK FOR MINIMUM TIME OF DAY\n         BNZ   &X.B                B. IF NOT TOO LOW\n&X.A     DS    0H\n&F       SETB  1                   | INDICATE CONSTANTS REQUIRED\n.TIM0600 ANOP  ,                   |\n         TIME  DEC                 GET CURRENT TIME OF DAY\n&X.B     DS    0H\n         AIF   ('&TO'(1,1) EQ '(').TIM0700\n         LA    R1,&TO              R1 HAS DESTINATION FIELD ADDRESS\n         AGO   .TIM0800            |\n.TIM0700 ANOP  ,                   |\n&REG     SETC  '&TO'(2,K'&TO-2)\n         LR    R1,&REG             R1 HAS DESTINATION FIELD ADDRESS\n.TIM0800 ANOP  ,                   |\n&A       SETA  K'&FORMAT-2         | LENGTH OF FORMAT FIELD\n&B       SETA  0                   | INDEX INTO FORMAT\n&K       SETC  '&FORMAT'(2,K'&FORMAT-2)\n         MVC   0(&A,R1),&X.C\n.TIM0900 ANOP  ,                   |\n&C       SETA  &A-&B               | CALCULATE # OF REMAINING BYTES\n         AIF   (&C LT 2).TIM2200   | IF 1 TO GO, EXIT\n         AIF   ('&K'(&A-&C+1,2) EQ 'HH').TIM1000\n         AIF   ('&K'(&A-&C+1,2) EQ 'MM').TIM1400\n         AIF   ('&K'(&A-&C+1,2) EQ 'SS').TIM1600\n         AIF   ('&K'(&A-&C+1,2) EQ 'TH').TIM1800\n         AIF   ('&K'(&A-&C+1,2) EQ 'AM').TIM2000\n         AIF   ('&K'(&A-&C+1,2) EQ 'PM').TIM2000\n&B       SETA  &B+1                | POINT TO NEXT CHARACTER\n&D       SETA  &D+1                | POINT TO NEXT CHARACTER\n         AGO   .TIM0900            |\n.*                                 |\n.TIM1000 ANOP  ,                   |\n*-------\n*        CONVERT \"HH\" INTO HOURS\n*-------\n         XC    &P,&P               CLEAR WORK AREA #1\n         XC    &Q,&Q               CLEAR WORK AREA #2\n         AIF   (&D EQ 0).TIM1100   |\n         LA    R1,&D.(,R1)         ADVANCE OUTPUT AREA POINTER\n&D       SETA  0                   | RESET INDEX INTO AREA\n.TIM1100 ANOP  ,                   |\n         STCM  R0,8,&P+7           SAVE \"HH\"\n         MVO   &Q+6(2),&P+7(1)\n         OI    &Q+7,X'0F'          CONVERT TO \"0HHF'\n         AIF   ('&CLOCK' EQ '24').TIM1200\n&G       SETB  1                   | INDICATE CONSTANTS REQUIRED\n&I       SETB  1                   | INDICATE CONSTANTS REQUIRED\n         CL    R0,&X.E             CHECK IF CURRENT TIME IS PAST 12:59\n         BL    *+14                B. IF NOT\n         SP    &Q+6(2),&X.G\n         OI    &Q+7,X'0F'          CONVERT TO \"0HHF'\n.TIM1200 ANOP  ,                   |\n         UNPK  0(2,R1),&Q+6(2)\n&REG     SETC  '&PAD'(2,K'&PAD-2)  |\n         AIF   ('&REG' EQ '0').TIM1300\n         CLI   0(R1),C'0'          CHECK IF 1ST BYTE IS ZERO\n         BNE   *+8                 B. IF NOT\n         MVI   0(R1),C&PAD         INSERT PAD CHARACTER\n.TIM1300 ANOP  ,                   |\n&B       SETA  &B+2                | POINT TO NEXT CHARACTER\n&D       SETA  &D+2                | POINT TO NEXT CHARACTER\n         AGO   .TIM0900            |\n.*                                 |\n.TIM1400 ANOP  ,                   |\n*-------\n*        CONVERT \"MM\" INTO MINUTES\n*-------\n         XC    &P,&P               CLEAR WORK AREA #1\n         XC    &Q,&Q               CLEAR WORK AREA #2\n         AIF   (&D EQ 0).TIM1500   |\n         LA    R1,&D.(,R1)         ADVANCE OUTPUT AREA POINTER\n&D       SETA  0                   | RESET INDEX INTO AREA\n.TIM1500 ANOP  ,                   |\n         STCM  R0,4,&P+7           SAVE \"MM\"\n         MVO   &Q+6(2),&P+7(1)\n         OI    &Q+7,X'0F'          CONVERT TO \"0MMF'\n         UNPK  0(2,R1),&Q+6(2)\n&B       SETA  &B+2                | POINT TO NEXT CHARACTER\n&D       SETA  &D+2                | POINT TO NEXT CHARACTER\n         AGO   .TIM0900            |\n.*                                 |\n.TIM1600 ANOP  ,                   |\n*-------\n*        CONVERT \"SS\" INTO SECONDS\n*-------\n         XC    &P,&P               CLEAR WORK AREA #1\n         XC    &Q,&Q               CLEAR WORK AREA #2\n         AIF   (&D EQ 0).TIM1700   |\n         LA    R1,&D.(,R1)         ADVANCE OUTPUT AREA POINTER\n&D       SETA  0                   | RESET INDEX INTO AREA\n.TIM1700 ANOP  ,                   |\n         STCM  R0,2,&P+7           SAVE \"SS\"\n         MVO   &Q+6(2),&P+7(1)\n         OI    &Q+7,X'0F'          CONVERT TO \"0SSF'\n         UNPK  0(2,R1),&Q+6(2)\n&B       SETA  &B+2                | POINT TO NEXT CHARACTER\n&D       SETA  &D+2                | POINT TO NEXT CHARACTER\n         AGO   .TIM0900            |\n.*                                 |\n.TIM1800 ANOP  ,                   |\n*-------\n*        CONVERT \"TH\" INTO TENTHS & HUNDREDTHS OF SECONDS\n*-------\n         XC    &P,&P               CLEAR WORK AREA #1\n         XC    &Q,&Q               CLEAR WORK AREA #2\n         AIF   (&D EQ 0).TIM1900   |\n         LA    R1,&D.(,R1)         ADVANCE OUTPUT AREA POINTER\n&D       SETA  0                   | RESET INDEX INTO AREA\n.TIM1900 ANOP  ,                   |\n         STCM  R0,1,&P+7           SAVE \"TH\"\n         MVO   &Q+6(2),&P+7(1)\n         OI    &Q+7,X'0F'          CONVERT TO \"0THF'\n         UNPK  0(2,R1),&Q+6(2)\n&B       SETA  &B+2                | POINT TO NEXT CHARACTER\n&D       SETA  &D+2                | POINT TO NEXT CHARACTER\n         AGO   .TIM0900            |\n.*                                 |\n.TIM2000 ANOP  ,                   |\n*-------\n*        CONVERT \"AM\" OR \"PM\" INTO THE CURRENT PART OF THE DAY\n*-------\n         AIF   (&D EQ 0).TIM2100   |\n         LA    R1,&D.(,R1)         ADVANCE OUTPUT AREA POINTER\n&D       SETA  0                   | RESET INDEX INTO AREA\n.TIM2100 ANOP  ,                   |\n&H       SETB  1                   | INDICATE CONSTANTS REQUIRED\n         MVI   0(R1),C'A'          SET TO \"AM\"\n         CL    R0,&X.F             CHECK IF CURRENT TIME IS PAST NOON\n         BL    *+8                 B. IF NOT\n         MVI   0(R1),C'P'          CHANGE TO \"PM\"\n&B       SETA  &B+2                | POINT TO NEXT CHARACTER\n&D       SETA  &D+2                | POINT TO NEXT CHARACTER\n         AGO   .TIM0900            |\n.*                                 |\n.TIM2200 ANOP  ,                   |\n         B     &X.H                BRANCH AROUND CONSTANTS\n*-------\n*        #TIME CONSTANTS\n*-------\n&X.C     DC    C&FORMAT            FORMAT FIELD OVERLAY\n         AIF   (NOT &F).TIM2300    | BYPASS UNNECESSARY CONSTANTS\n&X.D     DC    A(X'23595999')      MAXIMUM TIME VALUE PER DAY\n.TIM2300 ANOP  ,                   |\n         AIF   (NOT &G).TIM2400    | BYPASS UNNECESSARY CONSTANTS\n&X.E     DC    A(X'12595999')      MAXIMUM TIME TILL 1PM\n.TIM2400 ANOP  ,                   |\n         AIF   (NOT &H).TIM2500    | BYPASS UNNECESSARY CONSTANTS\n&X.F     DC    A(X'12000000')      MAXIMUM TIME TILL PM\n.TIM2500 ANOP  ,                   |\n         AIF   (NOT &I).TIM2600    | BYPASS UNNECESSARY CONSTANTS\n&X.G     DC    PL2'+12'            VALUE TO SUBTRACT IF TIME PAST 12:59\n.TIM2600 ANOP  ,                   |\n&X.H     DS    0H                  #TIME MACRO - END\n         AGO   .MEND\n.TIMERR1 MNOTE 8,'#TIM01A - \"LIST=\" Parameter Is Invalid (YES Or NO)'\n         AGO   .MEND               |\n.TIMERR2 MNOTE 8,'#TIM02A - \"PAD=\" Parameter Is Invalid'\n         AGO   .MEND               |\n.TIMERR3 MNOTE 8,'#TIM03A - \"TO=\" Parameter Is Missing'\n         AGO   .MEND               |\n.TIMERR4 MNOTE 8,'#TIM04A - \"CLOCK=\" Parameter Is Invalid (12 OR 24)'\n         AGO   .MEND               |\n.MEND    ANOP  ,                   |\n         AIF   ('&LIST' EQ 'YES').MEND2\n         POP   PRINT\n.MEND2   ANOP  ,                   |\n         MEND  ,                   |\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#TSOTERM": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00\\x19\\x00\\x19\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 25, "newlines": 25, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&NAME    #TSOTERM &OBTAIN,&IF3270=,&IFTWX=,&IF2741=\n         AIF  ('&OBTAIN' EQ '' OR '&OBTAIN' EQ 'UCB' OR                X\n               '&OBTAIN' EQ 'TYPE').OOKAY\n         IHBERMAC 1001,OBTAIN,&OBTAIN\n         MEXIT ,\n.OOKAY   ANOP  ,\n&NAME    L     0,=X'FF000000'           TERMTYPE ENTRY CODE\n         SVC   94                       TERMINAL CONTROL SVC\n         AIF   ('&IF3270&IFTWX&IF2741' NE '').TYPE\n         AIF   ('&OBTAIN' EQ 'TYPE').TYPE\n         AIF   ('&OBTAIN' NE 'UCB').MEND\n         N     15,=X'FFFF0000'          PICK UP UCB\n         MEXIT ,\n.TYPE    N     15,=X'000000FF'          PICK UP TERMINAL TYPE\n         AIF   ('&IF2741' EQ '').T3270\n         CLM   15,1,=AL1(12)            IS THIS A 2741 ?\n         BE    &IF2741                  BRANCH IF YES\n.T3270   AIF   ('&IF3270' EQ '').TTWX\n         CLM   15,1,=AL1(4)             IS THIS A 3270 ?\n         BE    &IF3270                  BRANCH IF YES\n.TTWX    AIF   ('&IFTWX'  EQ '').MEND\n         CLM   15,1,=AL1(16)            IS THIS A TWX ?\n         BE    &IFTWX                   BRANCH IF YES\n.MEND    MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALLOC": {"ttr": 5377, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x01\\x90\\x01\\x90\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:32", "lines": 400, "newlines": 400, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&NAME    ALLOC &DUMMY,&PERM,&DSN=,&DDN=,&DDNRET=,&MEMBER=,&DISP=,      X\n               &VOL=,&UNIT=,&SYSOUT=,&FREE=,&COPIES=,&LABEL=,          X\n               &BLKSIZE=,&DEN=,&DSORG=,&KEYLEN=,&LRECL=,&RECFM=,       X\n               &PASWORD=,&DSNRET=,&MF=AUTO,&PREFIX=,&ERROR=,           X\n               &SPACE=,&F=,&FILE=,&DA=,&QNAME=,&DSORGRT=,              X\n               &VOLRET=,&DCBDSN=,&DCBDDN=,&SPECIAL=,&DDNTO=,           X\n               &FORMS=,&DEST=,&SSREQ=,&FORUSER=,&TU=,&DSNPDE=,         X\n               &DEFER=,&UNITCNT=,&DATACLAS=,&MGMTCLAS=,&STORCLAS=,     X\n               &VERB=S99VRBAL,&HOLD=,&OK=,&FLAG1=,                     X\n               &FLG11=,&FLG12=,&FLG21=,&FLG22=\n.**********************************************************************\n.*                                                                    *\n.*    THIS MACRO PROVIDES A DYNAMIC ALLOCATION FUNCTION BY BUILDING   *\n.*    A DYNAMIC ALLOCATION PARAMETER LIST AND INVOKING SVC 99.        *\n.*    IT FIRST SETS UP A WORKAREA ENVIRONMENT FOR THE PARAMETER LIST  *\n.*    AND THEN TESTS THE KEYWORDS SUPPLIED AND INVOKES INNER MACROS   *\n.*    TO BUILD THE TEXT UNITS. THE INNER MACROS THEMSELVES USE INNER  *\n.*    MACROS TO UPDATE GLOBAL VARIABLES, STORE TEXT UNIT POINTERS ETC *\n.*    THERE ARE THREE WAYS OF SPECIFYING THE WORK AREA ADDRESS.       *\n.*    A) MF=AUTO, MF=G, MF=(E,ADDRESS,LNTHSYMB).                      *\n.*    IN THE FIRST FORM, AN INNER MACRO DYNSPACE IS CALLED TO NAME    *\n.*    A WORK AREA, THE NAME BEING RETURNED IN THE GLOBAL SETC         *\n.*    VARIABLE &DYNSP. A DSECT IS CREATED TO MAP THIS AREA.           *\n.*    THE GLOBAL VARIABLES &DTUO (TEXT UNIT OFFSET COUNTER) AND       *\n.*    &DTUPO (TEXT UNIT POINTER OFFSET ACCUMULATOR) ARE SET TO ZERO.  *\n.*    THESE ACCUMULATORS ARE UPDATED AS EACH TEXT UNIT PROCESSOR      *\n.*    AQUIRES STORAGE. AFTER ALL TEXT UNITS HAVE BEEN BUILT, THE      *\n.*    AMOUNT OF SPACE USED IS CALCULATED, AND THE DYNSPACE MACRO IS   *\n.*    THEN CALLED AGAIN TO LOG THE AMOUNT NEEDED. DYNSPACE SETS A     *\n.*    GLOBAL VARIABLE &DYNSPQ TO THE HIGHEST AMOUNT ANY ALLOC OR      *\n.*    FREE MACRO REQUESTED, AND WHEN CALLED WITH THE EXPAND OPTION,   *\n.*    (NO OPERANDS OR NAME FIELD SUPPLIED), EXPANDS INTO A DS FOR     *\n.*    THAT QUANTITY. (SEE DYNSPACE)                                   *\n.*    MF=G SPECIFIES THAT THE ALLOC MACRO ENTER THE BEGIN MACRO       *\n.*    WORKAREA TO ACQUIRE THE STORAGE NECESSARY. IT DOES THIS VIA     *\n.*    THE RCPDS MACRO. (SEE RCPDS). HOWEVER, IF THE ALLOC MACRO IS    *\n.*    CALLED SEVERAL TIMES WITH THIS OPTION, A LOT OF STORAGE WILL BE *\n.*    USED UP, AS THE STORAGE WILL NOT BE SHARED. THUS, THIS FORM     *\n.*    SHOULD ONLY BE USED IF THE ALLOC/FREE MACRO IS ONLY TO BE USED  *\n.*    ONCE OR TWICE DURING AN ASSEMBLY.                               *\n.*    MF=E CAUSES THE MACRO TO USE A USER SPECIFIED WORK AREA. THE    *\n.*    SECOND PARAMETER GIVES THE NAME OF THE WORKAREA, AND AN         *\n.*    OPTIONAL THIRD PARAMETER IS THE NAME OF A SYMBOL TO BE EQUATED  *\n.*    TO THE LENGTH OF THE REQUIRED WORK AREA.                        *\n.*                                                                    *\n.*    DYNAMIC ALLOCATION FUNCTIONS ARE SIMILAR TO THOSE AVAILABLE     *\n.*    WITH JCL, USING THE SAME KEYWORDS. HOWEVER, CERTAIN FORMATS     *\n.*    ARE SLIGHTLY DIFFERENT. FOR INSTANCE, CERTAIN KEYWORDS CAN      *\n.*    HAVE VARYING PARAMETERS, EG DATASET NAME, DDNAME, VOLSER ETC.   *\n.*    PROVISION IS MADE FOR BOTH VARIABLE SPECIFICATION.              *\n.*    IN THE ABSOLUTE FORM, THE PARAMETER IS ENTERED IN QUOTES,       *\n.*    E.G.   ALLOC DSN='SYS1.LINKLIB',DISP=SHR                        *\n.*    HOWEVER, THIS NAME REMAINS FIXED FOR THE ASSEMBLY.              *\n.*    IN THE VARIABLE FORMAT, THE ADDRESS OF A LOCATOR IS SPECIFIED,  *\n.*    WHERE THE LOCATOR CONSISTS OF A SIX BYTE FIELD, THE FIRST 4     *\n.*    BYTES OF WHICH POINT TO THE PARAMETER, WHILE THE NEXT TWO       *\n.*    CONTAIN THE LENGTH.                                             *\n.*    EG          ALLOC DSN=LOCATOR                                   *\n.*       LOCATOR  DC    A(DSN),Y(12)                                  *\n.*       DSN      DC    C'SYS1.LINKLIB'                               *\n.*                                                                    *\n.*       NUMERIC QUANTITIES E.G. COPIES= FOR SYSOUT, SHOULD EITHER    *\n.*       SPECIFY A NUMERIC VALUE, COPIES=3,                           *\n.*       A VALUE IN A REGISTER, COPIES=(R3),                          *\n.*       OR THE NAME OFF A FULLWORD CONTAINING THE VALUE,             *\n.*          COPIES=NUMCOPYS, WHERE NUMCOPYS IS THE NAME OF A          *\n.*       FULLWORD FIELD.                                              *\n.*                                                                    *\n.*       OTHER KEYWORDS SUCH AS DISP= CAN ONLY HAVE THE ABSOLUTE      *\n.*       FORM, AND VALUES SHOULD NOT BE ENTERED WITHIN QUOTES.        *\n.*       ADDITIONAL FACILITIES NOT AVAILABLE WITH JCL ARE THE         *\n.*       RETURN BY THE SYSTEM OF INFORMATION ON THE DATASET, EG       *\n.*       DSORG. THIS IS DONE BY SPECIFYING DSORGRT=SYMBOL, WHERE      *\n.*       SYMBOL IS A SYMBOL WHICH WILL BE EQUATED TO A TWO BYTE       *\n.*       FIELD CONTAINING THE DSORG TYPE (SEE JOB MANAGEMENT,         *\n.*       SUPERVISOR AND TSO).                                         *\n.*       THE SYSTEM CAN ALSO GENERATE AND RETURN A DDNAME. THIS IS    *\n.*       CARRIED OUT BY ENTERING DDNTO=(ADDR1,ADDR2,,...)             *\n.*       WHERE ADDR1,ADDR2 ETC ARE THE NAMES OF 8 BYTE FIELDS WHICH   *\n.*       ARE TO RECEIVE THE DDNAME.                                   *\n.*       FOR FURTHER INFORMATION ON DYNAMIC ALLOCATION, SEE           *\n.*       JOB MANAGEMENT, SUPERVISOR AND TSO.                          *\n.*                                                                    *\n.**********************************************************************\n         GBLA  &RCPDYN            COUNTER FOR NO ENTRIES TO MACRO\n         GBLA  &DTUO              OFFSET TO TEXT UNITS\n         GBLA  &DTUPO             OFFSET TO TEXT UNIT POINTERS\n         GBLB  &RCPS99(2)         TELL RCPDSECT NEED DSECTS\n         GBLC  &DYNP              PREFIX FOR LABELS FOR THIS CALL\n         GBLC  &DYNSP         NAME FOR AUTOMATIC STORAGE ALLOC\n         LCLA  &DDNRTO,&DSNRTO         FOR EQUATES FOR RETURNED FLDS\n         LCLA  &VOLRTO,&DSRGRTO        FOR EQUATES FOR RETURNED FIELDS\n         LCLA  &I                 COUNTER\n         LCLB  &DSECT             DSECT NEEDED FOR STORAGE, MF=E\n         LCLC  &C,&P,&T,&PAR,&LBL\n.*\n.*   THE ALLOC MACRO PROVIDES A DYNAMIC ALLOCATION FUNCTION,\n&RCPS99(1)     SETB           1\n&RCPDYN  SETA  &RCPDYN+1          INCEREMENT COUNTER\n&DYNP    SETC  'DYN&RCPDYN' SET DEFAULT PREFIX\n&P       SETC  '&DYNP'\n.*\n.*     CHECK FOR MUTUALLY EXCLUSIVE KEYWORDS\n.*\n         RCPMUEXC (DSN=,&DSN),(DA=,&DA),(DSNPDE=,&DSNPDE),             X\n               (DSNRET=,&DSNRET),(SYSOUT=,&SYSOUT),                    X\n               (QNAME=,&QNAME)    MUTUALLY EXCLUSIVE KEYWORDS\n         RCPMUEXC (DDN=,&DDN),(FILE=,&FILE),(F=,&F),                   X\n               (DDNRET=,&DDNRET),(DDNTO=,&DDNTO)\n.*\n.*     CHECK FOR KEYWORD DEPENDENCIES\n.*\n         RCPMUDEP (DSN=,&DSN),(MEMBER=,&MEMBER)  MEMBER NEEDS DSN\n         RCPMUDEP (SYSOUT=,&SYSOUT),(COPIES=,&COPIES),                 X\n               (DEST=,&DEST),(FORMS=,&FORMS),(HOLD=,&HOLD)\n.*\n.*     IF ANY MUTUALLY EXCLUSIVE KEYWORDS WERE SPECIFIED,\n.*     MNOTES WOULD HAVE BEEN GENERATED. THE REST OF THE MACRO\n.*     CODE WILL IGNORE THE SUPERFLUOUS KEYWORDS.\n.*     I.E. IF DSN= AND SYSOUT= WERE SPECIFIED, SYSOUT=WOULD BE IGNORED\n.*\n         AIF   ('&NAME' EQ '').NONAME  SKIP IF NO NAME\n&NAME    DS    0H\n.NONAME  ANOP\n         AIF   ('&PREFIX' EQ '').TMF\n         AIF   (K'&PREFIX LT 4).POK\n         MNOTE 4,'PREFIX TOO LONG, 1ST 4 CHARS USED'\n&DYNP    SETC  '&PREFIX'(1,4)\n&P       SETC  '&DYNP'\n         AGO   .TMF\n.POK     ANOP\n&DYNP    SETC  '&PREFIX'\n&P       SETC  '&DYNP'\n.TMF     AIF   ('&MF(1)' EQ 'G').GEN\n         AIF   ('&MF' NE 'AUTO').TMFE\nNAME     DYNSPACE             GET NAME FOR SPACE\n         LA    R1,&DYNSP               LOAD ADDRESS OF PARAM LIST\n         USING &P.DS,R1                USE GENERATED DSECT\n&T       SETC  'A'\n&PAR     SETC  '&DYNSP+4'\n&DSECT   SETB  1\n         AGO   .START\n.TMFE    AIF   ('&MF(2)' NE '').E2OK\n         MNOTE 4,'PLIST ADDRESS OMITTED, MF=G USED'\n         AGO   .GEN\n.E2OK    ANOP\n&DSECT   SETB  1\n         AIF   ('&MF(2)' EQ '(').RMFE\n         LA    R1,&MF(2)               LOAD PARAM LIST ADDRESS\n         USING &P.DS,R1                USE GENERATED DSECT\n         AGO   .START\n.RMFE    AIF   ('&MF(2)' EQ '(R1)' OR '&MF(2)' EQ '(1)').START\n         LR    R1,&PAR                 LOAD S99 PARAM LIST ADDRESS\n         AGO   .START\n.GEN     LA    R1,&P.RBP               LOAD ADDRESS OF S99 RBP\n.START   LA    R15,&P.RB               LOAD ADDRESS OF S99 RB\n         USING S99RB,R15\n         XC    0(&P.LEN,R1),0(R1)      ZERO PARAMETER LIST\n         ST    R15,0(R1)               AND STORE IN RB POINTER\n         MVI   0(R1),X'80'             SET HIGH ORDER BIT ON RB PTR\n         MVI   S99RBLN,20              MOVE IN LIST LENGTH\n         MVI   S99VERB,&VERB           MOVE IN VERB CODE\n         AIF   ('&FLAG1' EQ '').NOFLAG1\n         MVI   S99FLAG1,&FLAG1         MOVE IN FLAG BYTE\n.NOFLAG1 ANOP\n         AIF   ('&FLG11' EQ '').NOFLG11\n         MVI   S99FLG11,&FLG11         MOVE IN FLAG BYTE\n.NOFLG11 ANOP\n         AIF   ('&FLG12' EQ '').NOFLG12\n         MVI   S99FLG12,&FLG12         MOVE IN FLAG BYTE\n.NOFLG12 ANOP\n         AIF   ('&FLG21' EQ '').NOFLG21\n         MVI   S99FLG21,&FLG21         MOVE IN FLAG BYTE\n.NOFLG21 ANOP\n         AIF   ('&FLG22' EQ '').NOFLG22\n         MVI   S99FLG22,&FLG22         MOVE IN FLAG BYTE\n.NOFLG22 ANOP\n         LA    R14,&P.TUP              LOAD ADDRESS OF TU POINTERS\n         ST    R14,S99TXTPP            STORE ADDRESS IN S99 RB\n         LA    R15,&P.TU               POINT TO SPACE FOR TEXT UNITS\n         USING S99TUNIT,R15\n&DTUO    SETA  0\n&DTUPO   SETA  0\n         AIF   ('&SSREQ' EQ 'YES').SSREQ\n.TDSN    AIF   ('&DSN&DA' NE '').DSN\n         AIF   ('&DSNPDE' NE '').DSNPDE\n         AIF   ('&DSNRET' NE '').DSNRT\n         AIF   ('&SYSOUT' NE '').SYSOUT\n         AIF   ('&DUMMY' EQ 'DUMMY').DUMMY\n         AIF   ('&PERM' EQ 'DUMMY').DUMMY\n         AIF   ('&QNAME' NE '').QNAME\n.TDDN    AIF   ('&DDN&FILE&F' NE '').DDN\n         AIF   ('&DDNRET&DDNTO' NE '').DDNRT\n.TFREEC  AIF   ('&FREE' NE '').FREEC\n.TUNIT   AIF   ('&UNIT&VOL' NE '').UNIT\n.TDEFER  AIF   ('&DEFER' EQ 'YES').DEFER\n.TDCLAS  AIF   ('&DATACLAS' NE '').DCLAS\n.TMCLAS  AIF   ('&MGMTCLAS' NE '').MCLAS\n.TSCLAS  AIF   ('&STORCLAS' NE '').SCLAS\n.TVOLRET AIF   ('&VOLRET' NE '').VOLRET\n.TDSRGO  AIF   ('&DSORGRT' NE '').DSORGRT\n.TLABEL  AIF   ('&LABEL' NE '').LABEL\n.TPSWD   AIF   ('&PASWORD' NE '').PASWORD\n.TFORUSE AIF   ('&FORUSER' NE '').FORUSER\n.TTU     AIF   ('&TU' NE '').TU\n.TDISP   AIF   ('&DISP' NE '').DISP\n.TSPACE  AIF   ('&SPACE' NE '').SPACE\n.TLRECL  AIF   ('&LRECL' NE '').DCB\n         AIF   ('&DEN' NE '').DCB\n         AIF   ('&RECFM' NE '').DCB\n         AIF   ('&BLKSIZE' NE '').DCB\n         AIF   ('&DSORG' NE '').DCB\n         AIF   ('&KEYLEN' NE '').DCB\n.TDCBDSN AIF   ('&DCBDSN' NE '').DCBDSN\n.TDCBDDN AIF   ('&DCBDDN' NE '').DCBDDN\n.TPERM   AIF   ('&PERM' EQ 'PERM' OR '&PERM' EQ 'PERMANENT').PERM\n         AIF   ('&DUMMY' EQ 'PERM' OR '&DUMMY' EQ 'PERMANENT').PERM\n.TSPECI  AIF   ('&SPECIAL' NE '').SPECIAL\n         AGO   .SVC99\n.SSREQ   RCPSSREQ\n         AGO   .TDSN\n.DSN     RCPDSN &DSN&DA,&MEMBER\n         AGO   .TDDN\n.DSNPDE  RCPDSNPD &DSNPDE\n         AGO   .TDDN\n.DSNRT   RCPDSNRT &DSNRET\n&DSNRTO  SETA  &DTUO-44\n         AGO   .TDDN\n.SYSOUT  RCPSYSOU &SYSOUT,COPIES=&COPIES,DEST=&DEST,                   X\n               FORMS=&FORMS,HOLD=&HOLD\n         AGO   .TDDN\n.DUMMY   RCPDUMMY &DUMMY\n         AGO   .TDDN\n.QNAME   RCPQNAME &QNAME\n         AGO   .TDDN\n.DDN     RCPDDN &DDN&F&FILE\n         AGO   .TFREEC\n.DDNRT   RCPDDNRT &DDNRET\n&DDNRTO  SETA  &DTUO-8\n         AGO   .TFREEC\n.FREEC   RCPSYSOU FREE=&FREE\n         AGO   .TUNIT\n.UNIT    RCPUNIT &UNIT,&VOL\n         AIF   ('&UNITCNT' EQ '').TDEFER\n         RCPUNITC &UNITCNT\n         AGO   .TDEFER\n.DEFER   RCPDEFER ,\n         AGO   .TDCLAS\n.DCLAS   RCPDCLAS &DATACLAS\n         AGO   .TMCLAS\n.MCLAS   RCPMCLAS &MGMTCLAS\n         AGO   .TSCLAS\n.SCLAS   RCPSCLAS &STORCLAS\n         AGO   .TVOLRET\n.VOLRET  RCPVOLRT &VOLRET\n&VOLRTO  SETA  &DTUO-6\n         AGO   .TDSRGO\n.DSORGRT RCPDSRGR &DSORGRT\n&DSRGRTO SETA  &DTUO-2\n         AGO   .TLABEL\n.LABEL   RCPLABEL &LABEL\n         AGO   .TPSWD\n.PASWORD RCPPSWD &PASWORD\n         AGO   .TFORUSE\n.FORUSER RCPFORUS &FORUSER\n         AGO   .TTU\n.TU      RCPTU &TU\n         AGO   .TDISP\n.DISP    RCPDISP &DISP\n         AGO   .TSPACE\n.SPACE   RCPSPACE &SPACE\n         AGO   .TLRECL\n.DCB     RCPDDCB LRECL=&LRECL,DEN=&DEN,RECFM=&RECFM,BLKSIZE=&BLKSIZE,  X\n               DSORG=&DSORG,KEYLEN=&KEYLEN\n         AGO .TDCBDSN\n.DCBDSN  RCPDCBDS &DCBDSN\n         AGO .TDCBDDN\n.DCBDDN  RCPDCBDD &DCBDDN\n         AGO   .TPERM\n.PERM    RCPPERM\n         AGO   .TSPECI\n.SPECIAL RCPSPEC &SPECIAL\n.SVC99   ANOP\n&DTUPO   SETA  &DTUPO-4\n         SPACE\n         MVI   &P.TUP+&DTUPO,X'80'     SET HIGH ORDER BIT ON TEXT PTRS\n         RCPSR2 UNSAVE\n&DTUPO   SETA  &DTUPO+4\n         AIF   (NOT &DSECT).DYNA\n         DROP  R1,R15                  DEACTIVATE ADDRESSABILITY\n         LA    R14,4(R1)               POINT TO REQUEST BLOCK\n.DYNA    ANOP\n*        DYNALLOC                      CALL DYNAMIC ALLOCATION\n         DYNALLOC\n         AIF   (NOT &DSECT).LTR\n         USING &P.RB,R14               SET UP ADDRESSABILITY\n**       NOTE  R14 HAS RB ADDRESS, R15 HAS SVC 99 RETURN CODE        **\n.LTR     AIF   ('&ERROR' EQ '' AND '&OK' EQ '').TDDTO\n         LTR   R15,R15                 TEST ALLOCATION RETURN CODE\n         AIF   ('&ERROR' EQ '').TOK\n         AIF   ('&ERROR'(1,1) EQ '(').TERRR\n         AIF   ('&ERROR'(1,1) EQ '''').TERRM\n         JNZ   &ERROR                  BRANCH IF NON ZERO\n         AGO   .TOK\n.TERRM   ANOP\n&C       SETC  '&ERROR'(2,K'&ERROR-2)\n&LBL     SETC  '&P&SYSNDX'\n         JZ    &LBL                    BRANCH AROUND ERROR MACRO\n         &C\n&LBL     DS    0H\n         AGO   .TOK\n.TERRR   ANOP\n&C       SETC  '&ERROR'(2,K'&ERROR-2)\n         JNZR  &C                      BRANCH IF NON ZERO\n.TOK     AIF   ('&OK' EQ '').TDDTO\n         AIF   ('&OK'(1,1) EQ '(').TOKR\n         JZ    &OK                     BRANCH IF ZERO\n         AGO   .TDDTO\n.TOKR    ANOP\n&C       SETC  '&OK'(2,K'&OK-2)\n         JZR   &C                      BRANCH IF ZERO\n.TDDTO   AIF   ('&DDNTO' EQ '').RESERVE\n&I       SETA  0\n.DDNTOL  ANOP\n&I       SETA  &I+1\n         AIF   ('&DDNTO(&I)' EQ '').RESERVE\n         AIF   ('&DDNTO(&I)'(1,1) EQ '(').DDNTOR\n         MVC   &DDNTO(&I).(8),&P.TU+&DDNRTO\n         AGO   .DDNTOL\n.DDNTOR  ANOP\n&C       SETC  '&DDNTO(&I)'(2,K'&DDNTO(&I)-2)\n         MVC   0(8,&C),&P.TU+&DDNRTO\n         AGO   .DDNTOL\n.RESERVE AIF   (&DSECT).RESDS\n         SPACE 1\n***********************************************************************\n**       RESERVE SPACE FOR DYNALLOC PARAMETER LIST                   **\n***********************************************************************\n         RCPDS\n.SSP     ANOP\n&P.RBP   DS    F                       SVC 99 REQ BLOCK POINTER\n&P.RB    DS    5F                      SVC 99 REQUEST BLOCK\n&P.TUP   DS    CL&DTUPO                SPACE FOR TEXT POINTERS\n         AIF   (&DTUO EQ 0).DTU21\n&P.TU    DS    CL&DTUO                 SPACE FOR TEXT UNITS\n         AIF   (&DSNRTO EQ 0).TDDNRTO\n&DSNRET  EQU   &P.TU+&DSNRTO           OFFSET TO RETURNED DSN\n.TDDNRTO AIF   ('&DDNRET' EQ '').DTU11\n&DDNRET  EQU   &P.TU+&DDNRTO           OFFSET TO RETURNED DDNAME\n.DTU11   AIF   (&VOLRTO EQ 0).DTU12\n&VOLRET  EQU   &P.TU+&VOLRTO           OFFSET TO RETURNED VOLSER\n.DTU12   AIF   (&DSRGRTO EQ 0).DTU10\n&DSORGRT EQU   &P.TU+&DSRGRTO          OFFSET TO RETURNED DSORG\n         AGO   .DTU10\n.DTU21   ANOP\n&P.TU    DS    0C                      NO SPACE NEEDED FOR TEXT UNITS\n.DTU10   ANOP\n&P.LEN   EQU   *-&P.RBP                LENGTH OF SPACE USED\n         AIF   (&DSECT).DSP\n         RCPDS\n         SPACE 3\n         AGO   .EXIT\n.RESDS   ANOP\n         AIF   ('&DYNSP' EQ '').SP3\n         DYNSPACE ADD\n.SP3     SPACE\n&P.DS    DSECT ,                       DSECT TO MAP SVC 99 DATA\n         AGO   .SSP\n.DSP     AIF   ('&MF(3)' EQ '').END1\n&MF(3)   EQU   &P.LEN                  LENGTH OF AREA\n.END1    ANOP\n&SYSECT  CSECT ,\n         SPACE 3\n.EXIT    MEND\n         EJECT\nTALLOC   BEGIN WKDSECT=WORKAREA\nA        ALLOC DSN='SYS1.LINKLIB',DISP=SHR,ERROR=S99FAIL,              X\n               DDNAME='DD1'\n         EJECT\nB        ALLOC DSN='SYS1.LINKLIB',SYSOUT=A,DISP=OLD,                   X\n               ERROR=S99FAIL,FREE=CLOSE\n         EJECT\nC        ALLOC DSN=DSN/(R6)/,DISP=(NEW,DELETE),                        X\n               SPACE=(TRK,((R7),1),RLSE,CONTIG),                       X\n               DDNTO=DDN,ERROR=S99FAIL\n         EJECT\nD        ALLOC DSNPDE=A,DISP=SHR,ERROR=S99FAIL,COPIES=3\n         EJECT\nE        ALLOC DSN=(R5)/(R6)/,MEMBER='ABCDEF',DDN=DDN/8/,              X\n               QNAME='FRED',MF=(E,ALLOCPL,#ALLOCPL)\n         EJECT\nS99FAIL  S99FAIL\n         EJECT\n         BEGINWKA\nDDN      DS    CL8\nDSN      DS    CL44\nALLOCPL  DS    CL(#ALLOCPL)\n         EXITWKA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BEGIN": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x01x\\x01x\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 376, "newlines": 376, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    BEGIN &ID=YES,&WKDSECT=,&WKCSECT=,&REG0=,&REG1=,&PREFIX=,     X\n               &NOPARM=,&SP=1,&PARSEP=,&PARSWKA=,&REGS=YES,&PARSERR=,  X\n               &CHECKID=,&BASE=R12,&PDLREG=R11,&PDLNAME=IKJPARMD,      X\n               &PCL=,&ZEROIZE=,&INITRTN=,&SAVESUF=,&SAVEPRE=,          X\n               &CPPLPTR=,&USING=,&ISA=,&CELL=,&ESDPRFX=,&LOAD=\n.*\n         GBLB  &STBEG                   START/BEGIN PRESENT\n         GBLB  &RCPRCP,&RCPIOPL(2),&RCPCP,&RCPRENT,&RCPPPL(2)\n         GBLB  &RCPDFPL(2),&RCPDFPB(2)  DEFAULT PARM LIST/BLOCK\n         GBLA  &#COPYSZ                 COPYRIGHT NOTICE SIZE\n         GBLA  &RCPSWS(10)              ENVIRONMENT SWITCHES\n         GBLA  &RCPBGN#                 COUNTER OF TIMES BEGIN ISSUED\n         GBLB  &RCPECT(2),&RCPUPT(2),&RCPPSCB(2),&RCPS99(2),&RCPCPPL(2)\n         GBLB  &RCPSTPB(2),&RCPPTPB(2),&RCPGTPB(2),&RCPPGPB(2)\n         GBLB  &RCPLSD(2)\n         GBLB  &RCPBRGS\n         GBLC  &RCPSPN,&RCPPRE,&RCPWKDS,&RCPWKCS\n         LCLA  &I,&J,&L\n         LCLB  &ESDDATE\n         LCLC  &P,&CHARVAR,&C\n         LCLC  &R2\n         #COPY SET                      COPYRIGHT NOTICE\n&STBEG   SETB  1                        START/BEGIN PRESENT\n&J       SETA  N'&SYSLIST\n&R2      SETC  'R2'\n&RCPBGN# SETA  &RCPBGN#+1               INCREMENT BEGIN MACRO COUNT\n         AIF   ('&REG1' EQ '').TRCP\n&R2      SETC  '&REG1'\n.TRCP    AIF   (NOT &RCPRCP).TESTOPT TEST FOR 2ND ENTRY TO MACRO\n&RCPIOPL(1) SETB 0\n&RCPCP   SETB  0\n&RCPRENT SETB  0\n&RCPPPL(1) SETB 0\n&RCPECT(1) SETB 0\n&RCPUPT(1) SETB 0\n&RCPPSCB(1) SETB 0\n&RCPSTPB(1) SETB 0\n&RCPPTPB(1) SETB 0\n&RCPPGPB(1) SETB 0\n&RCPGTPB(1) SETB 0\n&RCPDFPL(1) SETB 0\n&RCPSWS(1) SETA 0\n&RCPSWS(2) SETA 0\n&RCPSWS(3) SETA 0\n&RCPSWS(4) SETA 0\n&RCPSWS(5) SETA 0\n&RCPSWS(6) SETA 0\n&RCPSWS(7) SETA 0\n&RCPSWS(8) SETA 0\n&RCPSWS(9) SETA 0\n&RCPWKDS SETC  ''\n&RCPWKCS SETC  ''\n&RCPPRE  SETC  ''\n.TESTOPT ANOP  ,\n&RCPRCP  SETB  1\n.NEXTOPT AIF  (&I GE &J).ENDOPT\n&I       SETA  &I+1\n&C       SETC  '&SYSLIST(&I)'\n         AIF   ('&C' NE 'CP').T1\n&RCPCP   SETB  1\n         AGO   .NEXTOPT\n.T1      AIF   ('&C' NE 'TERMIO').T2\n&RCPIOPL(1) SETB 1\n         AGO   .NEXTOPT\n.T2      AIF   ('&C' NE 'PARSE' AND '&C' NE 'PARS').T3\n&RCPPPL(1) SETB 1\n         AGO   .NEXTOPT\n.T3      AIF   ('&C' NE 'RENT').T4\n&RCPRENT SETB  1\n         AGO   .NEXTOPT\n.T4      AIF   ('&C' NE 'DYNALOC').T5\n&RCPS99(1) SETB 1\n         AGO   .NEXTOPT\n.T5      AIF   ('&C' NE 'PUTL' AND '&C' NE 'PUTLINE').T6\n&RCPPTPB(1) SETB 1\n&RCPIOPL(1) SETB 1\n         AGO   .NEXTOPT\n.T6      AIF   ('&C' NE 'GETL' AND '&C' NE 'GETLINE').T7\n&RCPIOPL(1) SETB 1\n&RCPGTPB(1) SETB 1\n         AGO   .NEXTOPT\n.T7      AIF   ('&C' NE 'STACK' AND '&C' NE 'FLUSH').T8\n&RCPIOPL(1) SETB 1\n&RCPSTPB(1) SETB 1\n         AGO   .NEXTOPT\n.T8      AIF   ('&C' NE 'PUTGET').T9\n&RCPIOPL(1) SETB 1\n&RCPPGPB(1) SETB 1\n         AGO   .NEXTOPT\n.T9      AIF   ('&C' NE 'ECT').T10\n&RCPECT(1) SETB 1\nECTSWS   DCLSW GENERIC=ECT\n         AGO   .NEXTOPT\n.T10     AIF   ('&C' NE 'UPT').T11\n&RCPUPT(1) SETB 1\nUPTSWS   DCLSW GENERIC=UPT\n         AGO   .NEXTOPT\n.T11     AIF   ('&C' NE 'PSCB').T12\n&RCPPSCB(1) SETB 1\nPSCBATR1 DCLSW GENERIC=PSCB\n         AGO   .NEXTOPT\n.T12     AIF   ('&C' NE 'LSD').T13\n&RCPLSD(1) SETB 1\n         AGO   .NEXTOPT\n.T13     AIF   ('&C' NE 'ESDDATE').T14\n&ESDDATE SETB  1\n         AGO   .NEXTOPT\n.T14     AIF   ('&C' NE 'NOSAVEAREA').T15\n&RCPSWS(1) SETA 1                       INDICATE NO SAVEAREA\n         AGO   .NEXTOPT\n.T15     AIF   ('&C' NE 'NOSAVE').T16\n&RCPSWS(1) SETA 2                       INDICATE NOSAVE\n         AGO   .NEXTOPT\n.T16     AIF   ('&C' NE 'DFLT' AND '&C' NE 'DEFAULT').T17\n&RCPDFPL(1) SETB 1\n         AGO   .NEXTOPT\n.T17     AIF   ('&C' NE 'PROC').T18\n&RCPSWS(2) SETA 1\n         AGO   .NEXTOPT\n.T18     AIF   ('&C' NE 'PROC(MAIN)').T19\n&RCPSWS(2) SETA 2\n         AGO   .NEXTOPT\n.T19     AIF   ('&C' NE 'LIFO' AND '&ISA' EQ '').T20\n&RCPSWS(3) SETA 1\n         AGO   .NEXTOPT\n.T20     ANOP  ,\n         AIF   ('&C' EQ '').NEXTOPT    IGNORE NULL OPERANDS\n.INVOPT  MNOTE 4,'''&C'' Operand Invalid. Ignored'\n         AGO   .NEXTOPT\n.ENDOPT  ANOP  ,\n.TESTPRE AIF   (K'&PREFIX GT 0).TPRELEN\n&P       SETC  'RCP'\n         AIF   (&RCPBGN# EQ 1).SETPRE\n&P       SETC  'XX&RCPBGN#'(K'&RCPBGN#,3)\n         AGO   .SETPRE\n.TPRELEN AIF   (K'&PREFIX LE 3).PREFOK\n         MNOTE 1,'Prefix Must Be 1 To 3 Characters Long. First 3 Used'\n&P       SETC  '&PREFIX'(1,3)\n         AGO   .SETPRE\n.PREFOK  ANOP  ,\n&P       SETC  '&PREFIX'\n.SETPRE  ANOP  ,\n&RCPPRE  SETC  '&P'                     SET GLOBAL BEGIN PREFIX\n.TESTNM  AIF   ('&NAME' NE '').NAMEOK\n         MNOTE 8,'Name Operand Required'\n         MEXIT ,\n.NAMEOK  ANOP  ,\n&NAME    CSECT ,\n         AIF   ('&REGS' NE 'YES' OR &RCPBRGS).NOREGS\n\n&RCPBRGS SETB  1\n         #REGS ,\n.NOREGS  ANOP  ,\n         EJECT ,\n         AIF   (NOT &ESDDATE).TPRFX\n&C       SETC  '@'\n         AIF   ('&ESDPRFX' EQ '').ESDOK  IF ESDPRFX= NOT OVERRIDDEN\n.TPRFX   AIF    ('&ESDPRFX' EQ '').ENDESD  IF ESDPRFX NOT SPEC, SKIP\n&C       SETC  '&ESDPRFX'               GET ESD DATE PREFIX\n         AIF    (K'&C LT 3).ESDOK          CHECK LENGTH (MUST BE < 3)\n         MNOTE 4,'First Two Chars Of ESD Date Prefix Used'\n&C       SETC  '&ESDPRFX'(1,2)          GET 1ST 2 CHARS\n.ESDOK   ANOP  ,\n&C       SETC  '&C'.'&SYSDATE'(1,2).'&SYSDATE'(4,2).'&SYSDATE'(7,2)\n&C       EQU   &NAME                    PROVIDE EXTERNAL SYMBOL\n         ENTRY &C                       CONTAINING ASSEMBLY DATE\n\n.ENDESD  ANOP  ,\n&RCPPRE  SETC  '&P'\n.TESTID  AIF   ('&ID' EQ '' OR '&ID' EQ 'NO').STM\n         AIF   ('&ID' EQ 'YES' OR '&ID' EQ '*').STANDID\n         AIF   ('&ID'(1,1) EQ '''').QID\n&L       SETA  K'&ID+21\n         AIF   (&L/2 EQ (&L+1)/2).L1EVEN\n&L       SETA  &L+1+&#COPYSZ\n.L1EVEN  B     &L.(,R15)                BRANCH AROUND ID\n&L       SETA  K'&ID+16+&#COPYSZ\n         DC    AL1(&L)                  LENGTH OF ID\n         DC    C'&ID'                   MODULE ID\n         AGO   .DATE\n.QID     ANOP  ,\n&L       SETA  K'&ID+19\n         AIF   (&L/2 EQ (&L+1)/2).L2EVEN\n&L       SETA  &L+1+&#COPYSZ\n.L2EVEN  B     &L.(0,R15)               BRANCH AROUND ID\n&L       SETA  K'&ID+14+&#COPYSZ\n         DC    AL1(&L)                  LENGTH OF ID\n         DC    C&ID                     MODULE ID\n.DATE    DC    CL8' &SYSTIME'           TIME OF ASSEMBLY\n         DC    CL8'&SYSDATE'            DATE OF ASSEMBLY\n         #COPY GEN                      COPYRIGHT NOTICE\n         AGO   .STM\n.STANDID ANOP  ,\n&L       SETA  30+&#COPYSZ\n         B     &L.(0,R15)               BRANCH AROUND ID\n&L       SETA  &L-5\n         DC    AL1(&L)                  LENGTH OF ID\n         DC    CL8'&NAME'               MODULE NAME\n         DC    CL8' &SYSTIME'           TIME OF ASSEMBLY\n         DC    CL9'&SYSDATE'            DATE OF ASSEMBLY\n         #COPY GEN                      COPYRIGHT NOTICE\n*\n.STM     STM   R14,R12,12(R13)          SAVE CALLER'S REGISTERS\n         AIF   ('BASE(1)' NE '').BASEOK\n         LA    R12,0(0,R15)             LOAD BASE REGISTER WITH EP\n         USING &NAME,R12                ESTABLISH ADDRESSABLITY\n         AGO   .BASEEND\n.BASEOK  LA    &BASE(1),0(0,R15)        LOAD BASE REGISTER WITH EP\n         USING &NAME,&BASE(1)           ESTABLISH ADDRESSABILITY\n         AIF   ('&BASE(2)' EQ '').BASEEND\n         LA    &BASE(2),2048(0,&BASE(1))\n         LA    &BASE(2),2048(0,&BASE(2))\n         USING &NAME+4096,&BASE(2)\n         AIF   ('&BASE(3)' EQ '').BASEEND\n         LA    &BASE(3),2048(0,&BASE(2))\n         LA    &BASE(3),2048(0,&BASE(3))\n         USING &NAME+8192,&BASE(3)\n.BASEEND AIF   (&RCPSWS(1) GT 0).NOSAVER  TEST FOR NOSAVEAREA OPT\n         AIF   (&RCPSWS(2) GT 0).PROC  TEST FOR PROC OPTION\n         AIF   ('&WKDSECT' NE '').RENTOPT\n         AIF   ('&WKCSECT' NE '').CSOPT\n         AIF   (NOT &RCPCP AND NOT &RCPRENT).INLINE\n&RCPWKDS SETC  '&P.DSECT'\n         AGO   .DSGET\n.NOSAVER AIF   ('&WKCSECT&WKDSECT' NE '').NSWK\n.NSTCP   AIF   (&RCPCP).NSCP\n.NSCONT  AGO   .CONTINU\n.NSWK    MNOTE 8,'WKCSECT= And WKDSECT= Not Compatible With NOSAVEAREA X\n               Option'\n         AGO   .NSTCP\n.NSCP    MNOTE 8,'CP Option Not Compatible With NOSAVEAREA Option'\n         AGO   .NSCONT\n.PROC    RCPPROC WKCSECT=&WKCSECT,WKDSECT=&WKDSECT,                    X\n               REG1=&REG1,REG0=&REG0,ISA=&ISA,SAVEPRE=&SAVEPRE,        X\n               SAVESUF=&SAVESUF,SP=&SP\n         AGO   .SETRC0\n.INLINE  LR    R15,R13                  SAVE CALLERS SAVE AREA ADDRESS\n         CNOP  0,4\n         LA    R13,*+8\n         B     *+76                     BRANCH AROUND\n         DC    18F'0'                   SAVE AREA\n         ST    R15,4(0,R13)             CHAIN SAVE\n         ST    R13,8(0,R15)             AREAS TOGETHER\n         AGO   .USING\n.RENTOPT ANOP  ,\n&RCPWKDS SETC  '&WKDSECT'\n&RCPWKCS SETC  ''\n\n.DSGET   ANOP  ,\n         AIF   ('&SAVEPRE' NE '' OR '&SAVESUF' NE '').RCPSAVE\n         RCPDS ,\n         DS    9D                       RESERVE SPACE FOR SAVE AREA\n&P.RCODE DS    F                        RETURN CODE\n         RCPDS ,\n\n         AGO   .DSGET2\n.RCPSAVE RCPSAVE &SAVEPRE,&SAVESUF\n.DSGET2  AIF   ('&REG1' EQ '').TESTR0\n&R2      SETC  '&REG1'\n.TESTR0  AIF   ('&REG0' EQ '').GETMAIN\n         LR    &REG0,R0                 SAVE REGISTER 0 CONTENTS\n.GETMAIN LR    &R2,R1                   SAVE REGISTER 1 CONTENTS\n         GETMAIN RU,LV=&P.WKLEN,SP=&SP,LOC=BELOW\n&RCPSPN  SETC  '&SP'\n&RCPRCP  SETB  1\n         AIF   ('&ZEROIZE' NE 'YES').NZERO\n         LR    R14,R1                   SAVE WORK AREA POINTER\n         LR    R0,R1                    R0 POINTS TO WORK AREA\n         L     R1,=A(&P.WKLEN)          R1 HAS LENGTH OF WORK AREA\n         SR    R15,R15                  R15 HAS PAD BYTE & ZERO LENGTH\n         MVCL  R0,R14                   CLEAR WORK AREA\n         LR    R1,R14                   RESTORE W/A POINTER\n.NZERO   ST    R13,4(0,R1)              CHAIN SAVE\n         ST    R1,8(0,R13)              AREAS TOGETHER\n         LR    R13,R1                   LOAD SAVE AREA ADDRESS\n         USING &RCPWKDS,R13             ESTABLISH ADDRESSABILITY TO IT\n         AGO   .SETRC0\n\n.CSOPT   ANOP  ,\n&RCPRCP  SETB  1\n&RCPWKDS SETC  ''\n&RCPWKCS SETC  '&WKCSECT'\n         RCPDS ,\n         DS    9D                       RESERVE SPACE FOR SAVE AREA\n&P.RCODE DC    F'0'                     RETURN CODE\n         RCPDS ,\n\n         LR    R15,R13                  SAVE CALLER'S SAVE AREA ADRRESS\n         L     R13,=A(&WKCSECT)         AND PICK UP ADDRESS OF NEW ONE\n         USING &WKCSECT,R13             ESTABLISH ADDRESSABILITY TO IT\n         ST    R15,4(0,R13)             CHAIN SAVE\n         ST    R13,8(0,R15)             AREAS TOGETHER\n.SETRC0  XC    &P.RCODE,&P.RCODE        SET RETURN CODE TO ZERO\n         AIF   ('&INITRTN' EQ '').BUILD\n         AIF   ('&INITRTN(2)' EQ '').INITBAL\n         AIF   ('&INITRTN(2)'(1,1) EQ '(').INITREG\n         B     &INITRTN(1)             BRANCH TO INITIALIZATION ROUTINE\n&CHARVAR SETC  '&INITRTN(2)'\n&CHARVAR DS    0H                       PROVIDE RETURN ADDRESS\n         AGO   .BUILD\n.INITREG ANOP  ,\n&C       SETC  '&INITRTN(2)'(2,K'&INITRTN(2)-2)\n         BAL   &C,&INITRTN(1)           BAL TO INITIALIZATION RTN\n         AGO   .BUILD\n.INITBAL BAL   R14,&INITRTN(1)          BAL TO INITIALIZATION ROUTINE\n.BUILD   AIF   ('&LOAD' EQ '').NOLOAD\n         EJECT ,\n***********************************************************************\n**       LOAD SOME MODULES NEEDED BY THIS ROUTINE                    **\n***********************************************************************\n\n         LR    R14,R1                   PRESERVE REGISTER 1\n&I       SETA  0\n.LOADLOP ANOP  ,\n&I       SETA  &I+1\n         AIF   (&I GT N'&LOAD).ENDLOAD\n         AIF   (&I EQ 1 OR &I EQ &I/2*2).DOLOAD\n\n.DOLOAD  MNOTE '         RCPLOAD &LOAD(&I)'\n         RCPLOAD &LOAD(&I)\n\n         AGO   .LOADLOP\n.ENDLOAD LR    R1,R14                   RESTORE REGISTER 1\n.NOLOAD  ANOP  ,\n         AIF   (NOT &RCPCP).USING\n         AIF   (&RCPCPPL(2)).BPCPPL\n         EJECT ,\n&RCPCPPL(2) SETB 1\n         IKJCPPL\n&NAME    CSECT ,\n\n.BPCPPL  ANOP  ,\n         RCPDS ,\n&P.CPPL  DS    A                        SAVE ADDRESS OF CPPL HERE\n&P.ECB   DS    F                        I/O SERVICE ROUTINE ECB\n         RCPDS ,\n\n         AIF   ('&RCPWKDS' NE '').TCPPLP\n         LR    &R2,R1                   LOAD PARM ADDRESS\n.TCPPLP  AIF   ('&CPPLPTR' EQ '').STCPPL\n         AIF   (N'&CPPLPTR EQ 2).OKCPPLP\n         MNOTE 8,'Invalid CPPLPTR Options'\n         AGO   .STCPPL\n.OKCPPLP L     &CPPLPTR(1),&CPPLPTR(2)(&R2) LOAD CPPL ADDRESS\n         ST    &CPPLPTR(1),&P.CPPL      SAVE CPPL ADDRESS\n         USING CPPL,&CPPLPTR(1)         ADDRESS CPPL DSECT\n         AGO   .XCECB\n.STCPPL  ST    &R2,&P.CPPL              SAVE CPPL ADDRESS\n         USING CPPL,&R2                 ADDRESS CPPL\n.XCECB   XC    &P.ECB,&P.ECB            ZERO ATTENTION ECB\n         AIF   ('&CHECKID(1)' EQ '').BIOPL\n         RCPCKID &CHECKID\n.BIOPL   AIF   (NOT &RCPIOPL(1)).BDFPL\n         RCPIOPL ,\n.BDFPL   AIF   (NOT &RCPDFPL(1)).BPARS\n         RCPDFPL ,\n.BPARS   AIF   (NOT &RCPPPL(1)).CONTINU\n         RCPPPL PCL=&PCL,NOPARM=&NOPARM,PARSEP=&PARSEP,                X\n               PARSWKA=&PARSWKA,PARSERR=&PARSERR,PDLREG=&PDLREG,       X\n               PDLNAME=&PDLNAME\n.CONTINU ANOP  ,\n.USING   AIF   ('&USING' EQ '').EXIT\n\n&L       SETA  1\n&I       SETA  N'&USING\n.USING2  AIF   (&L GT &I).EXIT\n         AIF   ('&USING(&L)' EQ '' OR '&USING(&L+1)' EQ '').USINGE\n         USING &USING(&L),&USING(&L+1)\n&L       SETA  &L+2\n         AGO   .USING2\n.USINGE  MNOTE 4,'Required Operand(s) Missing On USING Keyword'\n&L       SETA  &L+2\n         AGO   .USING2\n.EXIT    EJECT ,\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BEGINWKA": {"ttr": 2056, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00(\\x00(\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 40, "newlines": 40, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         BEGINWKA &LTORG=YES\n         GBLA  &EXECUTN,&RCPSWS(10)\n         GBLB  &RCPS99(2)\n         GBLC  &RCPPRE,&RCPWKDS,&RCPWKCS\n         LCLC  &P,&QNAME\n         AIF   ('&LTORG' NE 'YES').RCPDS\n         AIF   (&EXECUTN EQ 0).LIT\n***********************************************************************\n**       E X E C U T E D   I N S T R U C T I O N   P O O L           **\n***********************************************************************\n\n         #EXEC ,\n\n.LIT     ANOP  ,\n***********************************************************************\n**             L I T E R A L      P O O L                            **\n***********************************************************************\n\n         LTORG ,\n.EJECT   EJECT ,\n.RCPDS   AIF   (&RCPSWS(1) GT 0).EXIT\n         AIF   (&RCPSWS(2) EQ 0).RCPDS2\n         AIF   (&RCPSWS(2) EQ 1 AND &RCPSWS(3) EQ 1).RCPDS2\n.*      IF PROC AND LIFO, NO QCON OR CXD\n&P       SETC  '&RCPPRE'\n         AIF   (&RCPSWS(2) EQ 1).QCON\n&P.CXD   CXD   ,                        CUMULATIVE WORK AREA LENGTH\n.QCON    ANOP  ,\n&QNAME   SETC  '&RCPWKDS'\n         AIF   ('&RCPWKDS&RCPWKCS' EQ '&RCPWKDS').QCGEN\n&QNAME   SETC  '&P.DSEC'\n&P.DSEC  DSECT ,                        PRIOR DEFINITION FOR QCON\n&SYSECT  CSECT ,\n.QCGEN   ANOP  ,\n&P.QCON  DC    Q(&QNAME)                EXTERNAL DUMMY SECTION OFFSET\n.RCPDS2  RCPDS ,\n         AIF   (NOT &RCPS99(1)).EXIT\n         DYNSPACE ,\n.EXIT    MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BLOCKLEN": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00$\\x00$\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 36, "newlines": 36, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    BLOCKLEN &DECB,&REG,&WKREG=R15,&ACSMETH=BSAM\n         LCLC  &A,&B,&R,&O,&F\n&O       SETC  '4'\n&F       SETC  '128'\n         AIF   ('&ACSMETH' EQ 'BSAM' OR '&ACSMETH' EQ 'BPAM').SETR\n         AIF   ('&ACSMETH' NE 'BDAM').E2\n&O       SETC  '5'\n&F       SETC  '64'\n.SETR    ANOP  ,\n&R       SETC  '&REG'\n         AIF   ('&REG' NE '').FDECB\n&R       SETC  'R1'\n.FDECB   AIF   ('&DECB' EQ '').E1\n         AIF   ('&DECB'(1,1) EQ '(').RDECB\n&A       SETC  '&DECB+'\n&B       SETC  ''\n         AGO   .START\n.RDECB   ANOP  ,\n&A       SETC  ''\n&B       SETC  '(0,&DECB(1))'\n.START   ANOP  ,\n&NAME    TM    &A.&O&B,&F               WAS 'S' CODED ON READ?\n         BO    *+12                      YES, GET BLOCKSIZE FROM DCB\n         LH    &R,&A.6&B                 ELSE GET IT FROM DECB\n         B     *+12                     SKIP DCB CODE\n         L     &R,&A.8&B                GET DCB ADDRESS\n         LH    &R,62(0,&R)              GET MAXIMUM BLOCKSIZE FROM DCB\n         L     &WKREG,&A.16&B           LOAD IOB ADDRESS\n         SH    &R,14(0,&WKREG)          SUBTRACT RESIDUAL COUNT\n         MEXIT ,\n.E1      MNOTE 8,'DECB ADDRESS OMITTED'\n         MEXIT ,\n.E2      MNOTE 4,'INVALID ACSMETH CODED, ''BSAM'' ASSUMED'\n         AGO   .SETR\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CICB": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00-\\x00-\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 45, "newlines": 45, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         CICB ,\n***********************************************************************\n*                                                                     *\n*  MACRO NAME = CICB                                                  *\n*                                                                     *\n*  DESCRIPTIVE NAME = CATALOG INTEGRITY CONTROL BLOCK                 *\n*                                                                     *\n*  FUNCTION = THE CICB IS USED BY VSAM CATALOG MANAGEMENT WHEN        *\n*             MOVING THE NONAUTHORIZED USER'S INTERFACE CONTROL       *\n*             BLOCK TO KEY 0, FETCH-PROTECTED STORAGE.                *\n*                                                                     *\n***********************************************************************\nCICB     DSECT\nCICBID   DS    CL4                CICB ID = C\"CICB\"\nCICFLAGS DS    XL1                CONTROL FLAGS\nCICCOUNT EQU   B'10000000'        COUNT MODE\nCICPTRSW EQU   B'01000000'        WORK AREA POINTER IS SWITCHED\nCICFPLOP EQU   B'00100000'        TEST FPL LOOP ERROR\nCICPASWD EQU   B'00010000'        PASSWORD IS TO BE MOVED\n*              B'00001111'        RESERVED\nCICUSKEY DS    XL1                USER KEY\n         DS    XL2                RESERVED\nCICGEOPR DS    XL4                GEOMETRIC PROGRESSION COUNTER\nCICINCRM DS    XL4                INCREMENTAL COUNTER\nCICFVTCN DS    XL4                FVT INCREMENTAL COUNTER\nCICFVTDX DS    XL4                FVT INDEX\nCICSVADR DS    A                  SAVED FPL ADDRESS\nCICFPLDI DS    XL4                FPL DATA INDEX\nCICFPLLP DS    A                  FPL ADDRESS FOR LOOP CHECK\nCICFVTPR DS    A                  FVT ADDRESS\nCICBKPTR DS    A                  POINTER TO BLOCK TO MOVE\nCICBKLNG DS    XL4                LENGTH OF BLOCK TO MOVE\nCICNXTBK DS    A                  POINTER TO NEXT AVAILABLE AREA\nCICRMBYT DS    XL4                REMAINING BYTES IN CISA\nCICGMCNT DS    XL4                COUNT FOR GETMAIN\nCICRAREA DS    A                  POINTER TO USER RETURN AREA\nCICCISAP DS    A                  POINTER TO BEGINNING OF CISA\nCICCISSP DS    A                  POINTER TO SECONDARY CISA\nCICSABYT DS    XL4                BYTES IN SECONDARY CISA\nCICCICAB DS    XL4                BYTES IN PRIMARY CISA\nCICPRFPL DS    A                  PRELMINARY FPL ADDRESS\nCICREGSV DS    F                  REGISTER SAVE AREA\nCICMRGSV DS    F                  MULTIPLE REGISTER SAVE AREA\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DCLSW": {"ttr": 4355, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x14\\x11/\\x01\\x14\\x11/\\x12H\\x01\\n\\x01\\n\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-04-22T00:00:00", "modifydate": "2014-04-22T12:48:33", "lines": 266, "newlines": 266, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    DCLSW &INIT=0,&MF=,&GENERIC=\n.**********************************************************************\n.*                                                                    *\n.*      THIS MACRO ALLOWS A PROGRAMMER TO DEFINE SWITCHES FOR LATER   *\n.*      USE BY GOIF,SET,RESET & FLIP MACROS. IT ALSO GENERATES        *\n.*      ASSEMBLY STATEMENTS DEFINING THE SWITCHES IF MF=L OR G (DFLT) *\n.*      THERE ARE SEVERAL WAYS OF USING THIS MACRO                    *\n.*                                                                    *\n.*      TO DECLARE A SWITCH BYTE WITH UP TO 8 SWITCH BITS IN IT, CODE *\n.*                                                                    *\n.*      NAME    DCLSW  BIT1<,BIT2,BIT3>                               *\n.*                                                                    *\n.*      MISSING BITS CAN BE SPECIFIED BY CODING TWO ADJACENT COMMAS   *\n.*                                                                    *\n.*                                                                    *\n.*      TO DECLARE SWITCH BITS WITHOUT CARE FOR THE BYTE IN WHICH     *\n.*      THEY OCCUR, THE NAME FIELD SHOULD BE LEFT BLANK. A NAME       *\n.*      IS GENERATED BY THE MACRO. MORE THAN 8 SWITCHES CAN BE        *\n.*      SPECIFIED USING THIS FORM, NEW BYTES BEING DECLARED AS        *\n.*      NEEDED. IF ANY SPARE BITS REMAIN IN THE BYTE, THESE WILL BE   *\n.*      USED ON SUBSEQUENT CALLS OF THE MACRO WITH THE SAME OPTION.   *\n.*      IF THE PROGRAMMER WANTS TO FORCE A NEW BYTE TO BE CREATED     *\n.*      A SLASH SHOULD BE PLACED AT THE APPROPRAITE POINT, E.G.       *\n.*             DCLSW BIT8,BIT9,/,BIT10      WILL FORCE                *\n.*      BIT10 ONTO A NEW BYTE                                         *\n.*                                                                    *\n.*                                                                    *\n.*                                                                    *\n.*      IF A SET OF SWITCHES ALL BEGINNING WITH A CERTAIN PREFIX      *\n.*      ARE TO BE DEFINED AS BELONGING TO ONE SWITCH GROUP,           *\n.*      THE GENERIC KEYWORD SHOULD BE USED. FOR INSTANCE, IN THE UCB  *\n.*      THERE IS A BYTE CALLED 'UCBTBYT1' CONTAINING 8 BITS WHICH     *\n.*      ALL BEGIN WITH THE PREFIX 'UCB1'. TO DEFINE THIS, CODE        *\n.*                                                                    *\n.*      UCBTBYT1 DCLSW GENERIC=UCB1                                   *\n.*                                                                    *\n.*      IF THE SWITCH NAME IS THE SAME AS THE GENERIC PREFIX, IT      *\n.*      MAY BE OMITTED. WITH THIS FORM, NO ASSEMBLY STATEMENTS ARE    *\n.*      GENERATED AS THE SWITCH IS ASSUMED TO BE DECLARED ELSEWHERE.  *\n.*      IF ANOTHER SWITCH IS EXPLICITLY DEFINED ELSEWHERE BY THE      *\n.*      DCLSW MACRO WITHOUT THE GENERIC OPTION BUT WITH A PREFIX      *\n.*      EQUAL TO THAT DEFINED WITH THE GENERIC OPTION, THE EXPLICIT   *\n.*      DECLARATION WILL BE PICKED UP BY SET,GOIF,RESET & FLIP        *\n.*      MACROS.                                                       *\n.*                                                                    *\n.*      FOUR MACRO FORMS CAN BE SPECIFIED.                            *\n.*      MF=D   (DEFER DECLARATION)                                    *\n.*      MF=E   (DO NOT GENERATE ASSEMBLY STATEMENTS. MUST BE          *\n.*              DECLARED ELSEWHERE)                                   *\n.*      MF=G   (DEFINE WITHIN WORK AREA CSECT/DSECT. SEE BEGIN MACRO) *\n.*      MF=L   (DO ASSEMBLY DECLARATION INLINE)                       *\n.*                                                                    *\n.*      THE INITIAL DEFAULT IS MF=G, AND THE MF IS REMEMBERED FROM    *\n.*      CALL TO MACRO CALL. I.E., IF MF=X IS OMITTED, THE LAST        *\n.*      SPECIFIED MF IS USED, WITH MF=G FOR THE FIRST CALL.           *\n.*                                                                    *\n.*      MF=D DEFERS ASSEMBLY DECLARATION TO LATER IN THE PROGRAM.     *\n.*        TO EXPAND A DEFERRED DECLARATION, CODE THE MACRO WITH NO    *\n.*        POSITIONAL OPERANDS. THIS WILL EXPAND INTO A DECLARATION    *\n.*        OF A SINGLE NAMED SWITCH GROUP IF THE NAME FIELD IS         *\n.*        PRESENT, OR TO ALL DEFERRED SWITCHES IF THE NAME FIELD IS   *\n.*        LEFT BLANK.   E.G.                                          *\n.*                                                                    *\n.*        SWITCH1  DCLSW BIT1,BIT2,,BIT4,MF=D   DEFINES A SWITCH      *\n.*        *                              WITH 3 BITS, BUT DOES NOT    *\n.*        *                              GENERATE ASSEMBLER.          *\n.*        SWITCH1  DCLSW                 WOULD WOULD EXPAND INTO      *\n.*       +SWITCH1  DC    AL1(0)          DECLARE SWITCH BYTE          *\n.*       +BIT1     EQU   128             DECLARE SWITCH BIT           *\n.*       +BIT2     EQU   64              DECLARE SWITCH BIT           *\n.*       +BIT4     EQU   8               DECLARE SWITCH BIT           *\n.*                                                                    *\n.*       NOTE THE OMISSION OF BIT3, WITH THE OMISSION OF EQU FOR 32   *\n.*       DCLSW WILL NOT INADVERTENTLY DECLARE A SWITCH TWICE,         *\n.*       WHICH COULD HAPPEN IF A GLOBAL DECLARATION OF DEFERRED BITS  *\n.*       WAS TO FOLLOW A DEFERRED DECLARATION OF A SINGLE SWITCH      *\n.*       GROUP. MF=G IS USEFUL WHEN IT IS WISHED TO DECLARE A SWITCH  *\n.*       GROUP IN THE MIDDLE OF A CONTROL BLOCK SOMEWHERE NEAR THE    *\n.*       END OF THE ASSEMBLY. IN ORDER FOR GOIF,FLIP,SET & RESET      *\n.*       TO RECOGNIZE A SWITCH, THE DCLSW MUST HAVE DECLARED THE      *\n.*       SWITCH EARLIER ON IN THE ASSEMBLY. HENCE MF=D MUST BE USED.  *\n.*       IF THE SWITCH DEFINITIONS ARE CONTAINED IN ANOTHER MACRO,    *\n.*       DCLSW WITH MF=E WILL DEFINE THE SWITCH FOR GOIF,SET,FLIP &   *\n.*       RESET, AND THE MAPPING MACRO WILL DECLARE THE SWITCH FOR     *\n.*       ASSEMBLER.                                                   *\n.*                                                                    *\n.*       THE SWITCH BYTE CAN BE SET TO AN INITIAL VALUE BY CODING     *\n.*       THE INIT= KEYWORD.                                           *\n.*    E.G.                                                            *\n.*          SW1     DCLSW BIT1,BIT2,BITX,INIT=(BIT1+BITX)             *\n.*                                                                    *\n.*          INIT= DEFAULTS TO 0. IT CANNOT BE SPECIFIED WITH          *\n.*                               MF=E OR MF=D                         *\n.*                                                                    *\n.**********************************************************************\n         GBLA  &RCPDSW#,&RCPGSW#       COUNTER FOR DECLARED SWITCHES\n         GBLA  &RCPDSWX,&RCPDSWY       POINTERS FOR SPARE BITS\n         GBLB  &RCPDSWD(99)            DEFER DECLARE INDICATORS\n         GBLC  &RCPDSWN(99)            SWITCH BYTE NAMES\n         GBLC  &RCPDSWB(800)           SWITCH BIT NAMES\n         GBLC  &RCPGSWN(99)            GENERIC SWITCH BYTE NAMES\n         GBLC  &RCPGSWB(99)            GENERIC SWITCH BIT PREFIXES\n         GBLC  &RCPPRE                 BEGIN MACRO PREFIX\n         GBLC  &RCPDSWF                MACRO FORMAT\n         LCLA  &I,&J,&K,&L             LOCAL COUNTERS\n         LCLB  &MFE,&MFG               MACRO FORM SWITCHES\n         LCLC  &C\n         AIF   ('&GENERIC' NE '').GENERIC  IF GENERIC REQD, GO DO IT\n         AIF   ('&SYSLIST(1)' EQ '').DECLARE  IF NO SWITCHES, EXPANSION\n.*                                        OF DEFERRED SWITCHES REQD\n         AIF   ('&RCPDSWB(1)' NE '').START  SKIP IF NOT 1ST TIME THRU\n&RCPDSWB(1) SETC '128'                  INITIALIZE BIT SETTINGS\n&RCPDSWB(2) SETC '64'\n&RCPDSWB(3) SETC '32'\n&RCPDSWB(4) SETC '16'\n&RCPDSWB(5) SETC '8'\n&RCPDSWB(6) SETC '4'\n&RCPDSWB(7) SETC '2'\n&RCPDSWB(8) SETC '1'\n&RCPDSWF SETC  'G'                     SET INITIAL DFLT MF=G\n.START   AIF   ('&MF' EQ '').NOMF      IF MF NOT SPECIFIED, USE DFLT\n         AIF   ('&MF' EQ 'D').MFOK     CHECK MF SPECIFICATION\n         AIF   ('&MF' EQ 'G' OR '&MF' EQ 'E' OR '&MF' EQ 'L').MFOK\n         MNOTE 4,'MF=&MF INVALID, MF=&RCPDSWF USED'\n         AGO   .NOMF\n.MFOK     ANOP\n&RCPDSWF SETC   '&MF'                  SAVE NEW MF\n.NOMF    ANOP\n&MFE     SETB   ('&RCPDSWF' EQ 'E' OR '&RCPDSWF' EQ 'D')\n.*                BIT &MFE INDICATES THAT NO ASSEMBLY STATEMENTS ARE\n.*                TO BE GENERATED. VALID FOR MF=G AND MF=E\n&MFG     SETB   ('&RCPDSWF' EQ 'G')\n&J       SETA   N'&SYSLIST\n         AIF   ('&NAME' EQ '').NONAME  IF NO NAME SPECIFIED, BRANCH\n&RCPDSW# SETA  &RCPDSW#+1              INCREMENT SWITCH COUNTER\n&K       SETA  &RCPDSW#*8              POINT TO 1 BELOW BIT NAME\n.*                                     ARRAY ENTRY FOR THIS BYTE\n&RCPDSWN(&RCPDSW#) SETC '&NAME'        SET SWITCH BYTE NAME\n&RCPDSWD(&RCPDSW#) SETB ('&RCPDSWF' EQ 'D') SET DEFER BIT IF MF=D\n         AIF   (&J LT 9).LT9SW         UP TO 8 SWITCH BITS ALLOWED\n         MNOTE 8,'MORE THAN 8 SWITCHES DECLARED FOR A NAMED BYTE'\n         MNOTE *,' - ONLY FIRST 8 USED'\n&J       SETA  8                       SET MAX TO 8\n.LT9SW   AIF   (NOT &MFG).LABEL        IF MF\u00ac=G, BYPASS RCPDS\n         RCPDS                         ENTER WORK AREA DSECT\n.LABEL   AIF   (&MFE).LOOP1            IF MF=D OR E, DO NOT DO DS\n&NAME    DC    AL1(&INIT)              DECLARE SWITCH BYTE\n.LOOP1   ANOP\n&I       SETA  &I+1                    POINT TO NEXT POSIT PARAM\n         AIF   (&I GT &J).EXITL1       IF DONE, EXIT LOOP1\n&C       SETC  '&SYSLIST(&I)'          SAVE SWITCH NAME\n         AIF   ('&C' EQ '').LOOP1      IF NULL, GO GET NEXT\n&RCPDSWB(&I+&K) SETC '&C'              STORE IN BIT NAME ARRAY\n         AIF   (&MFE).LOOP1            SKIP EQU IF MF=D OR E\n&C       EQU   &RCPDSWB(&I)            DECLARE SWITCH BIT\n         AGO   .LOOP1                  GET NEXT ENTRY\n.EXITL1  AIF   (NOT &MFG).EXIT         EXIT IF MF\u00ac=G\n         RCPDS                         RETURN TO PROGRAM CSECT\n.EXIT    MEXIT\n.**********************************************************************\n.*                                                                    *\n.*       THE FOLLOWING IS PERFORMED IF NO SWITCH BYTE NAME WAS        *\n.*       SPECIFIED. A NAME IS GENERATED AND THE SWITCH BITS DECLARED  *\n.*       IN IT. ANY SPARE FIELDS CAN BE USED BY FOLLOWING DCLSW       *\n.*       MACROS. ONCE ALL 8 FIELDS HAVE BEEN USED UP, ANOTHER SWITCH  *\n.*       BYTE IS OBTAINED AND NAMED. THE PROGRAMMER CAN REQUEST A NEW *\n.*       BYTE BY PLACING A / IN PLACE OF A SWITCH NAME. &RCPDSWX      *\n.*       POINTS TO THE CURRENT SWITCH BYTE AND &RCPDSWY HAS THE BIT   *\n.*       POSITION WITHIN THAT BYTE (1-8)                              *\n.*                                                                    *\n.**********************************************************************\n.NONAME  AIF   (&RCPDSWX EQ 0).NONAME1 IF 1ST TIME, GET NEW BYTE\n&K       SETA  (&RCPDSWX-1)/8          GET SWITCH BYTE NO\n&MFE     SETB  (&RCPDSWD(&K))          SET MFE SWITCH IF DEFER BIT ON\n.LOOP2   AIF   (&I GE &J).EXIT\n&I       SETA  &I+1\n         AIF   ('&SYSLIST(&I)' EQ '/').NEWBYTE  SWITCH NAME OF '/'\n.*                                     INDICATES NEW BYTE REQUESTED\n&RCPDSWY SETA  &RCPDSWY+1              INCREMENT BIT NO\n         AIF   (&RCPDSWY GT 8).NEWBYTE IF > 8, NEED NEW BYTE\n.LOOP2C  ANOP\n&RCPDSWX SETA  &RCPDSWX+1               ELSE INCREMENT BIT NAME PTR\n         AIF   ('&SYSLIST(&I)' EQ '').LOOP2  IF NULL, GET NEXT\n&RCPDSWB(&RCPDSWX) SETC '&SYSLIST(&I)'  STORE SW BIT NAME\n         AIF   (&MFE).LOOP2             IF MF=E OR MF=D DON'T DO EQU\n&C       SETC  '&SYSLIST(&I)'\n&C       EQU   &RCPDSWB(&RCPDSWY)       DECLARE SWITCH BIT\n         AGO   .LOOP2\n.NONAME1 ANOP\n&I       SETA  1                       POINT TO 1ST ELEMENT\n.NEWBYTE ANOP\n&RCPDSW# SETA  &RCPDSW#+1              INCREMENT SW BYTE NO\n&RCPDSWX SETA  &RCPDSW#*8              GET SW BIT NO. ***\n&RCPDSWY SETA  1                       SET BIT NO\n&MFE     SETB  ('&RCPDSWF' EQ 'D')     SET MFE FLAG IF MF=D\n.*                        MF=E IS INVALID FOR UNNAMED SW BYTES\n&RCPDSWD(&RCPDSW#) SETB (&MFE)         SET DEFER BIT IN ARRAY\n        AIF    ('&RCPPRE' EQ '').PREFNUL IF NO PREFIX ON BEGIN MACRO\n&C      SETC   '&RCPPRE.SW&RCPDSW#'    SET SWITCH NAME\n         AGO    .LOOP2D\n.PREFNUL ANOP\n&C       SETC  'SWITCH&RCPDSW#'        SET SWITCH NAME\n.LOOP2D  ANOP\n&RCPDSWN(&RCPDSW#) SETC '&C'           STORE SW BYTE NAME\n         AIF   (&MFE).LOOP2E           IF MF=D, DON'T DO DC\n         AIF   (NOT &MFG).LOOP2DC      IF MF\u00ac=G, SKIP RCPDS\n         RCPDS                         ENTER WORK AREA\n.LOOP2DC ANOP\n&C       DC    AL1(&INIT)              DECLARE SWITCH\n         AIF   (NOT &MFG).LOOP2E\n         RCPDS                         RESUME PROGRAM CSECT\n.LOOP2E  AIF   ('&SYSLIST(&I)' NE '/').LOOP2C  IF NOT SLASH, RESUME\n&RCPDSWY SETA &RCPDSWY-1              GETS BUMPED UP LATER\n         AGO   .LOOP2                  ELSE GET NEXT POSIT PARM\n.******************************************************************\n.*       IF NO SWITCH BIT NAMES WERE SPECIFIED, DECLARE FUNCTION  *\n.*       IS REQUESTED. IF NO NAME FIELD SPECIFIED, DECLARE ALL    *\n.*       SWITCHES WHOSE DEFER BIT IS ON, AND RESET THE DEFER BIT  *\n.*       IF A NAME FIELD IS SPECIFIED, JUST DECLARE THAT SWITCH   *\n.*       BYTE                                                     *\n.******************************************************************\n.DECLARE AIF ('&NAME' EQ '').DECALL   IF NO NAME, DO ALL\n.DECL1   AIF   (&I GE &RCPDSW#).NOTDEC IF DONE ALL, SW NOT FOUND\n&I       SETA  &I+1                    GET NEXT SWITCH\n         AIF   ('&NAME' NE '&RCPDSWN(&I)').DECL1\n         AIF   (NOT &RCPDSWD(&I)).NOTDEF  IF DEFER BIT NOT ON, ERROR\n&J       SETA  &I                      SET J=I\n&I       SETA  &I-1                    DECREMENT I\n         AGO   .DECL2                  NOW CAN USE DECALL CODE\n.NOTDEC  MNOTE 'SWITCH BYTE &NAME NOT PREVIOUSLY DECLARED'\n         MEXIT\n.NOTDEF  MNOTE 'DECLARATION OF SWITCH BYTE &NAME DID NOT HAVE MF=D'\n         MEXIT\n.DECALL  ANOP\n&J       SETA  &RCPDSW#                SET SCAN UPPER LIMIT\n.DECL2   AIF   (&I GE &J).EXIT\n&I       SETA  &I+1\n         AIF   (NOT &RCPDSWD(&I)).DECL2  SKIP IF DEFER BIT NOT ON\n&RCPDSWD(&I) SETB 0                    RESET DEFER BIT\n&C       SETC  '&RCPDSWN(&I)'          GET SWITCH BYTE NAME\n&C       DC    AL1(&INIT)              DECLARE SWITCH BYTE\n&K       SETA  &I*8                    POINT 1 BELOW 1ST SW BIT\n&L       SETA  0\n.DECL3   AIF   (&L GE 8).DECL2         DO FOR EACH BIT\n&L       SETA  &L+1\n&C       SETC  '&RCPDSWB(&K+&L)'       GET SW BIT NAME\n         AIF   ('&C' EQ '').DECL3       AND SKIP IF NULL SW NAME\n&C       EQU   &RCPDSWB(&L)            DECLARE SWITCH BIT\n         AGO   .DECL3                  REPEAT FOR EACH BIT\n.**********************************************************************\n.*       FOR GENERIC= OPTION, ANOTHER SET OF ARRAYS IS MAINTAINED.    *\n.*       THESE ARE SEARCHED LAST. WITH THIS OPTION, A PROGRAMMER CAN  *\n.*       INFORM DCLSW THAT ALL SWITCHES BEGINNING WITH A CERTAIN      *\n.*       PREFIX BELONG TO A PARTICULAR SWITCH BYTE. HOWEVER, NO       *\n.*       VALIDITY CHECKING CAN BE PERFORMED AS THE INDIVIDUAL NAMES   *\n.*       ARE NOT DECLARED. NO ASSEMBLER STATEMENTS ARE GENERATED      *\n.*       WITH THIS OPTION.                                            *\n.**********************************************************************\n.GENERIC ANOP\n&RCPGSW# SETA  &RCPGSW#+1              INCREMENT GENERIC SW NO\n&RCPGSWN(&RCPGSW#) SETC '&NAME'        SET SWITCH NAME\n&RCPGSWB(&RCPGSW#) SETC '&GENERIC'     SET GENERIC PREFIX\n         AIF   ('&NAME' NE '').END     IF NAME SPECIFIED, EXIT\n&RCPGSWN(&RCPGSW#) SETC '&GENERIC'      ELSE SET SW BYTE NAME = PREFIX\n.END     MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DEFAULT": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00`\\x00`\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 96, "newlines": 96, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&NAME    DEFAULT &DSN=,&BUFFER=,&ERROR=,&NOTCAT=,&QUAL=\n         GBLB  &RCPDFPL(2)\n         GBLC  &EXECNAM,&RCPPRE,&RCPDFEP,&RCPDFER\n         LCLA  &I,&J\n         LCLC  &R,&DFPB,&ENDLAB,&LABEL,&P1,&P2,&C\n         AIF   (NOT &RCPDFPL(1)).ERROR1\n&LABEL   SETC  '&NAME'\n&DFPB    SETC  '&RCPPRE.DFPB+DFPB'\n&ENDLAB  SETC  '&RCPPRE&SYSNDX'\n         AIF  (N'&SYSLIST EQ 0 AND '&DSN' EQ '' AND '&BUFFER' EQ '').GO\n         AIF   ('&BUFFER' NE '').BF1\n         AIF   ('&DSN' EQ '').ENDDSN\n&LABEL   LA    R1,&RCPPRE.DSNB          LOAD DSNAME BUFFER ADDRESS\n         AGO   .STR1\n.BF1     AIF   ('&BUFFER'(1,1) EQ '(').RB\n&LABEL   LA    R1,&BUFFER               LOAD ADDRESS OF DSNAME BUFFER\n         AGO   .STR1\n.RB      ANOP  ,\n&LABEL   LA    R1,&BUFFER(1)            LOAD ADDRESS OF DSNAME BUFFER\n.STR1    STCM  R1,7,&DFPB.DSN-DFPB+1    STORE IT IN DFPB\n&LABEL   SETC  ''\n.DSN     AIF   ('&DSN' EQ '').ENDDSN\n         AIF   ('&DSN'(1,1) EQ '(').DSNR\n         TM    &DSN+6,64                WAS DSNAME ENTERED IN QUOTES?\n         BO    &ENDLAB                  IF SO, BYPASS DEFAULT ROUTINE\n         L     R14,&DSN                 LOAD DSNAME ADDRESS\n         LH    R15,&DSN+4                AND LENGTH\n         AGO   .STR15\n.DSNR    TM    6(&DSN(1)),64            WAS DSNAME ENTERED IN QUOTES?\n         BO    &ENDLAB                  IF SO, BYPASS DEFAULT ROUTINE\n         L     R14,0(,&DSN(1))          LOAD DSNAME ADDRESS\n         LH    R15,4(,&DSN(1))          AND LENGTH\n.STR15   STH   R15,0(,R1)               STORE LENGTH INTO DSN BUFFER\n         LA    R0,2(,R1)                POINT PAST 2 BYTE HEADER\n         LA    R1,44                    LOAD MOVE LENGTH\n         ICM   R15,8,=C' '              INSERT PADDING CHARACTER\n         MVCL  R0,R14                   MOVE DSNAME TO BUFFER, AND PAD\n.ENDDSN  ANOP  ,\n.LOOP1   ANOP  ,\n&I       SETA  &I+1\n         AIF   (&I GT N'&SYSLIST).EXITL1\n&C       SETC  '&SYSLIST(&I)'\n         AIF   ('&C' NE 'USERID' AND '&C' NE 'USID').T2\n&P2      SETC  '&P2+DFPBUID'\n         AGO   .LOOP1\n.T2      AIF   ('&C' NE 'MSG' AND '&C' NE 'MESSAGE').T3\n&P2      SETC  '&P2+DFPBMSG'\n         AGO   .LOOP1\n.T3      AIF   ('&C' NE 'RET' AND '&C' NE 'RETQUAL').T4\n&P2      SETC  '&P2+DFPBRET'\n         AGO   .LOOP1\n.T4      ANOP  ,\n         MNOTE 4,'Invalid Option ''&C'', Ignored'\n         AGO   .LOOP1\n.EXITL1  AIF   ('&QUAL' NE '').NQUAL\n.*\n.NQUAL   ANOP  ,\n         AIF   ('&P2' EQ '').GO\n&P2      SETC  '&P2'(2,K'&P2-1)\n&LABEL   MVI   &DFPB.CNTL-DFPB,&P2\n&LABEL   SETC  ''\n.GO      ANOP  ,\n&LABEL   LA    R1,&RCPPRE.DFPL          LOAD PARM LIST ADDRESS\n         AIF   ('&RCPDFEP' EQ '').LINK\n         L     R15,&RCPDFEP             LOAD DEFAULT ROUTINE EP ADDR\n         BALR  R14,R15                  AND INVOKE IT\n         AGO   .ENDLINK\n.LINK    ANOP  ,\n*        INVOKE DEFAULT SERVICE ROUTINE\n         CALLTSSR EP=IKJEHDEF\n.ENDLINK ANOP  ,\n         AIF   ('&ERROR' EQ 'NO').NERR\n         AIF   ('&ERROR' EQ '').TDFER\n&RCPDFER SETC  '&ERROR'\n         AGO   .DFER\n.TDFER   AIF   ('&RCPDFER' EQ '').NERR\n.DFER    CL    R15,=A(4)                DID DEFAULT SUCCEED?\n         BNH   *+12                     YES, OK\n         CL    R15,=A(20)               WAS DATASET NOT IN CATALOG?\n         BNE   &ERROR                   IF NOT, GO TO ERROR ROUTINE\n         AIF   ('&DSN' EQ '').ENDLAB\n.NERR    L     R15,&DFPB.DSN-DFPB       LOAD DSN BUFFER ADDR\n         AIF   ('&DSN'(1,1) EQ '(').DSNR2\n         MVC   &DSN+4(2),0(R15)         UPDATE PDE LENGTH FIELD\n         LA    R15,2(,R15)               POINT PAST HEADER\n         ST    R15,&DSN                  AND UPDATE PDE POINTER\n         AGO   .ENDLAB\n.DSNR2   MVC   4(2,&DSN(1)),0(R15)      UPDATE PDE LENGTH FIELD\n         LA    R15,2(,R15)               POINT PAST HEADER\n         ST    R15,0(,&DSN(1))           AND UPDATE PDE POINTER\n.ENDLAB  ANOP  ,\n&ENDLAB  DS    0H\n.EXIT    MEXIT ,\n.ERROR1  MNOTE 8,'Default Option Not Specified On BEGIN Macro'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DYNSPACE": {"ttr": 5633, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x004\\x004\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:38", "lines": 52, "newlines": 52, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&NAME    DYNSPACE &TYPE\n.*\n.*    THIS IS AN INNER MACRO TO ALLOC/FREE.\n.*    IT IS CALLED TO   A) NAME AN AREA FOR THE PARMLIST\n.*                      B) LOG THE VARIOUS AMOUNTS NEEDED BY\n.*                         EACH, REMEMBERING THE LARGEST.\n.*                      C) GENERATING A DS FOR THE LARGEST AMOUNT.\n.*    THE FIRST TWO FUNCTIONS ARE INVOKED BY ALLOC/FREE MACROS ONLY,\n.*    AND THE THIRD IS USED BY THE PROGRAMMER, EITHER EXPLICITLY,\n.*    OR BY BEGINWKA, IF THE LATTER IS USED.\n.*\n.*     TO INVOKE THE NAMING FUNCTION, ALLOC/FREE GENERATE\n.*     NAME DYNSPACE\n.*     NOTE. THE NAMING OPERATION ONLY GENERATES A NAME ON THE\n.*     FIRST CALL IN THE ASSEMBLY. THE NAME REMAINS THE SAME UNTIL\n.*     DYNSPACE IS CALLED TO EXPAND INTO A DS.\n.*\n.*     THE SECOND FUNCTION IS INVOKED BY THE MACRO CALL\n.*          DYNSPACE ADD\n.*     (NO NAME FIELD AND ONE OPERAND)\n.*     IT USES THE GLOBAL VARIABLES &DTUO AND &DTUPO TO CALCULATE\n.*     THE SPACE FOR THIS REQUEST, AND UPDATES &DYNSPQ ONLY IF THE\n.*     CURRENT REQUEST IS FOR A GREATER AMOUNT\n.*\n.*     THE THIRD FUNCTION IS INVOKED BY CALLING DYNSPACE WITH NO\n.*     NAME OR OPERAND FIELD.\n.*     THIS EXPANDS INTO A DEFINE STORAGE, CLEARS THE DYNSPACE NAME\n.*     GLOBAL SETC, AND THE &DYNSPQ GLOBAL SETA.\n.*     THUS, THE MACRO IS SERIALLY REUSABLE IN ALL FUNCTIONS.\n.*\n         GBLA  &DYNSPQ,&DTUO,&DTUPO,&RCPDYN\n         GBLC  &DYNP,&DYNSP\n         LCLA  &I\n         AIF   ('&NAME' NE '').NAME\n         AIF   ('&TYPE' EQ '').ALLOC\n.*   THE ACCUMULATE FUNCTION IS REQUIRED\n&I       SETA  24+&DTUO+&DTUPO         GET AMOUNT FOR THIS REQUEST\n         AIF   (&I LE &DYNSPQ).EXIT    IF CURRENT < MAX, EXIT\n&DYNSPQ  SETA  &I                      ELSE UPDATE CURRENT MAXIMUM\n         MEXIT\n.NAME    AIF   ('&DYNSP' NE '').EXIT   IF NAME ALREADY EXISTS, EXIT\n&DYNSP   SETC  'DYNSP&RCPDYN'           ELSE GENERATE A NAME\n.EXIT    MEXIT\n.ALLOC   AIF   ('&DYNSP' EQ '').EXIT\n*\n**     RESERVE SPACE FOR ALLOC/FREE MACRO WORK AREA\n*\n&DYNSP   DS    0F,CL&DYNSPQ            RESERVE SPACE\n&DYNSP   SETC  ''                      SET MAX QUANTITY TO 0\n&DYNSPQ  SETA 0\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EXIT": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00H\\x00H\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 72, "newlines": 72, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    EXIT  &RC=,&IKJRLSA=YES,&R14=\n         GBLA  &RCPSWS(10)              ENVIRONMENT SWITCHES\n         GBLB  &RCPPPL(2)\n         GBLC  &RCPPRE,&RCPWKCS,&RCPWKDS,&RCPSPN\n         GBLC  &RCPCLNP\n         LCLC  &P\n&P       SETC  '&RCPPRE'\n         AIF   ('&NAME' EQ '').NONAME\n&NAME    DS    0H\n.NONAME  AIF   ('&P' EQ '').TRLSA\n&P.EXIT  DS    0H\n.TRLSA   AIF   (NOT &RCPPPL(1) OR '&IKJRLSA' EQ 'NO').NRLSA\n***********************************************************************\n**       FREE THE PARSE PDL WORKAREA                                 **\n***********************************************************************\n         IKJRLSA &P.PDLP\n.NRLSA   AIF   ('&RCPWKCS&RCPWKDS' NE '').WAOPT  TEST FOR WORKAREA OPT\n         AIF   ('&RC' EQ '(R15)' OR '&RC' EQ '(15)').RET1\n         AIF   ('&RC' EQ '0' OR '&RC' EQ '').ZEROREG\n         AIF   ('&RC'(1,1) EQ '(').REGRC\n         LA    R15,&RC                  LOAD RETURN CODE\n         AGO   .RET1\n.REGRC   LR    R15,&RC(1)               LOAD RETURN CODE\n         AGO   .RET1\n.ZEROREG SLR   R15,R15                  RETURN CODE = 0\n.RET1    AIF   (&RCPSWS(1) GT 0).RET2 NOSAVE/NOSAVEAREA OPT\n         L     R13,4(0,R13)             RESTORE CALLERS SAVE AREA\n.RET2    AIF   (&RCPSWS(1) EQ 2).RET3  NOSAVE OPTION\n         AIF   ('&R14' NE '').LMR012\n         L     R14,12(0,R13)            RESTORE REGISTER  14\n.LMR012  LM    R0,R12,20(R13)           RESTORE REGISTERS 0-12\n.RET3    AIF   ('&R14' EQ '').RET4\n         AIF   ('&R14'(1,1) EQ '(').R14R\n         L     R14,&R14                 RESTORE REGISTER  14\n         AGO   .RET4\n.R14R    LR    R14,&R14(1)              RESTORE REGISTER  14\n.RET4    BR    R14                      RETURN TO CALLER\n         MEXIT ,\n.WAOPT   AIF   ('&RC' EQ '').RCOK\n         MNOTE 4,'RC= Option Invalid With Current BEGIN Options,'\n         MNOTE *,'    Use SETRC Macro To Set The Return Code'\n.RCOK    AIF   ('&RCPWKCS' NE '').CSOPT WORK CSECT OPTION\n         AIF   (&RCPSWS(2) EQ 1 AND &RCPSWS(3) EQ 0).CSOPT\n         L     R15,&P.RCODE             LOAD RETURN CODE\n         AIF   (&RCPSWS(2) EQ 2).PROCM   PROC(MAIN) OPT\n         LR    R1,R13                   SAVE WORK AREA ADDRESS\n         L     R13,4(0,R13)             RESTORE CALLER'S SAVE AREA\n         ST    R15,16(0,R13)            STORE RETURN CODE\n         AIF   (&RCPSWS(3) EQ 1).LIFOF      LIFO OPTION\n         AGO   .FREE                    WORKAREA TO BE FREED\n.CSOPT   L     R15,&P.RCODE             LOAD RETURN CODE\n         L     R13,4(0,R13)             RESTORE CALLER'S SAVE AREA\n         L     R14,12(0,R13)            RESTORE REGISTER  14\n         LM    R0,R12,20(R13)           RESTORE REGISTERS 0-12\n         BR    R14                      RETURN TO CALLER\n         MEXIT ,\n.FREE    FREEMAIN RU,LV=&P.WKLEN,A=(1),SP=&RCPSPN\n         AGO   .LM\n.LIFOF   ANOP  ,\n*        #FREE A=(R1)                  RETURN WORKAREA TO STACK\n         #FREE A=(R1)\n         AGO   .LM\n.PROCM   L     R1,0(0,R13)              GET MCA ADDRESS\n         L     R1,&P.XDS-&P.MCA(,R1)    LOAD DUMMY SECTION ADDR\n         L     R13,4(0,R13)             RESTORE CALLER'S SAVE AREA\n         ST    R15,16(0,R13)            STORE RETURN CODE\n         L     R0,&P.CXD                LOAD WORK AREA LENGTH\n         FREEMAIN RU,LV=(0),A=(1),SP=&RCPSPN\n.LM      LM    R14,R12,12(R13)          RESTORE THE REGISTERS\n         BR    R14                      RETURN TO CALLER\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EXITWKA": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00K\\x00K\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 75, "newlines": 75, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         EXITWKA\n.*\n.*   THIS MACRO TERMINATES THE WORKAREA CSECT/DSECT STARTED BY\n.*   THE BEGIN MACRO, AND CONTINUED BY THE BEGINWKA MACRO.\n.*   IF THE WORK AREA IS GETMAINED BY BEGIN, IT SUPPLIES A\n.*   SYMBOLIC EQUATE FOR THE WORKAREA LENGTH, SO BEGIN MACRO KNOWS\n.*   HOW BIG AN AREA TO GET.\n.*   THE WORKAREA CSECT/DSECT IS ENTERED AND EXITED BY CALLING THE\n.*   RCPDS MACRO, WHICH SETS THE GLOBAL SETC VARIABLE &RCPDS TO\n.*   THE NAME OF THE PROGRAM CSECT. WITHIN THE PROGRAM CSECT ITSELF,\n.*   &RCPDS CONTAINS A NULL VALUE, AND A TEST FOR THIS IS MADE HERE.\n.*   IF IT IS NULL, THIS MEANS THAT THE USER DID NOT CODE BEGINWKA,\n.*   AND SO BEGINWKA IS INVOKED FOR HIM, BEFORE NORMAL PROCESSING\n.*   CONTINUES.\n.*   A SECONDARY FUNCTION OF THIS PROGRAM IS TO INVOKE MAPPING MACROS.\n.*   EACH MAPPING MACRO HAS A TWO MEMBER GLOBAL BIT ARRAY, BOTH\n.*   INITIALLY SET TO ZERO, EG FOR THE ECT, THE GLOBAL VARIABLE IS\n.*   &RCPECT(2), FOR DYNALLOC &RCPS99(2), FOR IOPL &RCPIOPL(2).\n.*   IF THE FIRST BIT OF THE GLOBAL SETB VARIABLE IS 1, AND THE 2ND\n.*   IS ZERO, THE MAPPING MACRO IS INVOKED. THE 2ND BIT IS THEN SET\n.*   TO ONE TO PREVENT A FURTHER EXPANSION OF THE MAPPING MACRO WITHIN\n.*   THE SAME ASSEMBLY.\n.*  A SECOND CALL TO BEGIN WILL CAUSE THE FIRST BIT TO BE SET TO\n.*  ZERO, HOWEVER THE SECOND BIT WILL BE LEFT UNALTERED.\n.*\n.*  GLOBAL SWITCHES FOR THE ECT, UPT, PSCB, DYNALLOC DSECTS, AND LSD\n         GBLB  &RCPECT(2),&RCPUPT(2),&RCPPSCB(2),&RCPS99(2)\n         GBLB  &RCPLSD(2)\n         GBLA  &RCPSWS(10)              ENVIRONMENT SWITCHES\n.*   GLOBAL VARIABLES FOR THE CURRENT BEGIN PREFIX, WORKAREA DSECT\n.*   NAME, AND PROGRAM CSECT NAME.\n         GBLC  &RCPPRE,&RCPWKDS,&RCPDS,&RCPWKCS\n         LCLC  &P,&CS\n         AIF   ('&RCPDS' NE '').START\n         BEGINWKA ,\n.START   AIF   (&RCPSWS(1) GT 0).NOWK\n&CS      SETC  '&RCPDS'                 PROGRAM CSECT\n         AIF   ('&RCPWKDS&RCPWKCS' EQ '').RCPDS\n         DS    0D                       ALIGN TO DOUBLEWORD\n&P       SETC  '&RCPPRE'\n&P.WKLEN EQU   *-&RCPWKDS&RCPWKCS       LENGTH OF WORK AREA\n         AIF   ('&RCPWKDS&RCPWKCS' NE '&RCPWKCS').RCPDS\n&P.DSEC  DSECT ,\n         DS    CL(&P.WKLEN)             GEN LENGTH FOR QCON\n.RCPDS   RCPDS ,\n         EJECT ,\n.NOWK    AIF   (NOT &RCPECT(1) OR &RCPECT(2)).TRYUPT\n         IKJECT ,\nL#ECT    EQU   *-ECT                    LENGTH OF ECT\n&CS      CSECT ,                        REENTER MAIN CSECT\n         EJECT ,\n&RCPECT(2) SETB 1\n.TRYUPT  AIF   (NOT &RCPUPT(1) OR &RCPUPT(2)).TRYPSCB\n         #IKJUPT ,\nL#UPT    EQU   *-UPT                    LENGTH OF USER PROFILE TABLE\n&CS      CSECT ,                        REENTER MAIN CSECT\n         EJECT ,\n&RCPUPT(2) SETB 1\n.TRYPSCB AIF   (NOT &RCPPSCB(1) OR &RCPPSCB(2)).TRYS99\n         #IKJPSCB ,\nL#PSCB   EQU   *-PSCB                   LENGTH OF PSCB\n&CS      CSECT ,                        REENTER MAIN CSECT\n         EJECT ,\n&RCPPSCB(2) SETB 1\n.TRYS99  AIF   (NOT &RCPS99(1) OR &RCPS99(2)).TRYLSD\n         #DSECTS ALLOC,TYPE=DEFER\n&RCPS99(2) SETB 1\n.TRYLSD  AIF   (NOT &RCPLSD(1) OR &RCPLSD(2)).TRYREST\n         IKJLSD ,\nL#LSD    EQU   *-LSD                    LENGTH OF LSD\n&CS      CSECT ,                        REENTER MAIN CSECT\n         EJECT ,\n&RCPLSD(2) SETB 1\n.TRYREST MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FREE": {"ttr": 5380, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00\\x89\\x00\\x89\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:38", "lines": 137, "newlines": 137, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&NAME    FREE  &UNALC,&DSN=,&DDN=,&MEMBER=,&DISP=,&SYSOUT=,            X\n               &ERROR=,&MF=AUTO,&PREFIX=,&FILE=,&F=,&DA=,&HOLD=\n         GBLA  &RCPDYN            COUNTER FOR NO ENTRIES TO MACRO\n         GBLA  &DTUO              OFFSET TO TEXT UNITS\n         GBLA  &DTUPO             OFFSET TO TEXT UNIT POINTERS\n         GBLB  &RCPS99(2)         TELL RCPDSECT NEED DSECTS\n         GBLC  &DYNP              PREFIX FOR LABELS FOR THIS CALL\n         GBLC  &DYNSP         NAME FOR AUTOMATIC STORAGE ALLOC\n         LCLB  &DSECT             DSECT NEEDED FOR STORAGE, MF=E\n         LCLC  &C,&T,&PAR\n&RCPS99(1)     SETB           1\n&RCPDYN  SETA  &RCPDYN+1          INCEREMENT COUNTER\n&DYNP    SETC  'DYN&RCPDYN' SET DEFAULT PREFIX\n         AIF   ('&NAME' EQ '').NONAME  SKIP IF NO NAME\n&NAME    DS    0H\n.NONAME  ANOP  ,\n         AIF   ('&PREFIX' EQ '').TMF\n         AIF   (K'&PREFIX LT 4).POK\n         MNOTE 4,'PREFIX TOO LONG, 1ST 4 CHARS USED'\n&DYNP    SETC  '&PREFIX'(1,4)\n         AGO   .TMF\n.POK     ANOP\n&DYNP    SETC  '&PREFIX'\n.TMF     AIF   ('&MF(1)' EQ 'G').GEN\n         AIF   ('&MF' NE 'AUTO').TMFE\nNAME     DYNSPACE             GET NAME FOR SPACE\n         LA    R1,&DYNSP               LOAD ADDRESS OF PARAM LIST\n         USING &DYNP.DS,R1             USE GENERATED DSECT\n&T       SETC  'A'\n&PAR     SETC  '&DYNSP+4'\n&DSECT   SETB  1\n         AGO   .START\n.TMFE    AIF   ('&MF(2)' NE '').E2OK\n         MNOTE 4,'PLIST ADDRESS OMITTED, MF=G USED'\n         AGO   .GEN\n.E2OK    ANOP\n&DSECT   SETB  1\n         AIF   ('&MF(2)' EQ '(').RMFE\n         LA    R1,&MF(2)               LOAD PARAM LIST ADDRESS\n&T       SETC  'A'\n&PAR     SETC  '&MF(2)+4'\n         USING &DYNP.DS,R1             USE GENERATED DSECT\n         AGO   .START\n.RMFE    AIF   ('&MF(2)' EQ '(R1)' OR '&MF(2)' EQ '(1)').START\n&PAR     SETC  '&MF(2)'(2,K'&MF(2)-2)\n&T       SETC  'R'\n         LR    R1,&PAR                 LOAD S99 PARAM LIST ADDRESS\n&PAR     SETC  '4&MF(2)'\n         USING &DYNP.DS,R1             USE GENERATED DSECT\n         AGO   .START\n.GEN     LA    R1,&DYNP.RBP            LOAD ADDRESS OF S99 RBP\n&T       SETC  'A'\n&PAR     SETC  '&DYNP.RB'\n.START   LA    R15,&DYNP.RB            LOAD ADDRESS OF S99 RB\n         USING S99RB,R15\n         ST    R15,0(R1)               AND STORE IN RB POINTER\n         XC    4(&DYNP.LEN-4,R1),4(R1) ZERO PARAMETER LIST\n         MVI   S99RBLN,20              MOVE IN LIST LENGTH\n         MVI   S99VERB,S99VRBUN        MOVE IN VERB CODE\n         LA    R14,&DYNP.TUP           LOAD ADDRESS OF TU POINTERS\n         ST    R14,S99TXTPP            STORE ADDRESS IN S99 RB\n         LA    R15,&DYNP.TU            POINT TO SPACE FOR TEXT UNITS\n         USING S99TUNIT,R15\n&DTUO    SETA  0\n&DTUPO   SETA  0\n         AIF   ('&DSN&DA' NE '').DSN\n         AIF   ('&SYSOUT' NE '').SYSOUT\n.TDDN    AIF   ('&DDN&FILE&F' NE '').DDN\n.TDISP   AIF   ('&DISP' NE '').DISP\n.TUNALC  AIF   ('&UNALC' NE '').PERM\n.THOLD   AIF   ('&HOLD' NE '').HOLD\n         AGO   .SVC99\n.DSN     RCPFDSN &DSN&DA,&MEMBER\n         AGO   .TDDN\n.SYSOUT  RCPFSYS &SYSOUT\n         AGO   .TDDN\n.DDN     RCPFDDN &DDN&F&FILE\n         AGO   .TDISP\n.DISP RCPFDISP &DISP\n         AGO   .TUNALC\n.PERM    RCPUNALC\n         AGO   .THOLD\n.HOLD    RCPFHOLD &HOLD\n.SVC99   ANOP\n&DTUPO   SETA  &DTUPO-4\n         SPACE\n         MVI   &DYNP.TUP+&DTUPO,X'80'  SET HIGH ORDER BIT ON TEXT PTRS\n         MVI   &DYNP.RBP,X'80'         SET HIGH ORDER BIT ON RB PTR\n         RCPSR2 UNSAVE\n&DTUPO   SETA  &DTUPO+4\n         AIF   (NOT &DSECT).DYNA\n         DROP  R1,R15                  DEACTIVATE ADDRESSABILITY\n.DYNA    ANOP\n*        DYNALLOC                      CALL DYNAMIC ALLOCATION\n         DYNALLOC\n         AIF   ('&ERROR' EQ '').RESERVE\n         AIF   ('&PAR' EQ '').LTR\n         L&T   R14,&PAR                 LOAD REG 14 WITH ADDRESS OF RB\n         AIF   (NOT &DSECT).LTR\n         USING &DYNP.RB,R14            SET UP ADDRESSABILITY\n.LTR     LTR   R15,R15                 TEST RETURN CODE\n         BNZ   &ERROR                  BRANCH IF NON ZERO\n**       NOTE.  R14 POINTS TO REQUEST BLOCK, R15 HAS RETURN CODE     **\n.RESERVE AIF   (&DSECT).RESDS\n         SPACE\n***********************************************************************\n**       RESERVE SPACE FOR DYNALLOC DATA                             **\n***********************************************************************\n         RCPDS\n.SSP     ANOP\n&DYNP.RBP DS   F                       SVC 99 REQ BLOCK POINTER\n&DYNP.RB  DS   5F                      SVC 99 REQUEST BLOCK\n&DYNP.TUP DS   CL&DTUPO                SPACE FOR TEXT POINTERS\n         AIF   (&DTUO EQ 0).DTU11\n&DYNP.TU  DS   CL&DTUO                 SPACE FOR TEXT UNITS\n         AGO   .DTU10\n.DTU11   ANOP\n&DYNP.TU  DS   0C                      NO SPACE NEEDED FOR TEXT UNITS\n.DTU10   ANOP\n&DYNP.LEN EQU  *-&DYNP.RBP             LENGTH OF SPACE USED\n         AIF   (&DSECT).DSP\n         RCPDS\n         SPACE 3\n         AGO   .EXIT\n.RESDS   ANOP\n         AIF   ('&DYNSP' EQ '').SP3\n         DYNSPACE ADD\n.SP3     SPACE\n&DYNP.DS DSECT                         DSECT TO MAP SVC 99 DATA\n         AGO   .SSP\n.DSP     AIF   ('&MF(3)' EQ '').END1\n&MF(3)   EQU   &DYNP.LEN               LENGTH OF AREA\n.END1    ANOP\n&SYSECT  CSECT\n         SPACE 3\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GOIF": {"ttr": 4357, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x14\\x11/\\x01\\x14\\x11/\\x12H\\x00w\\x00w\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-04-22T00:00:00", "modifydate": "2014-04-22T12:48:33", "lines": 119, "newlines": 119, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&NAME    GOIF  &SW,&ON=,&OFF=,&ONES=,&ZERO=,&MIXED=,&ANY=,&NOTZERO=,   X\n               &NOTONE=,&NOTONES=,&BOTH=,&NONE=,&ALL=,&NOTALL=\n.*********************************************************************\n.*                                                                   *\n.*     THIS MACRO TESTS A SWITCH OR SWITCHES AND BRANCHES IF A TEST  *\n.*     IS SATISFIED. THE SWITCH(ES) MUST HAVE PREVIOUSLY BEEN        *\n.*     DECLARED BY A DCLSW MACRO. AN INNER MACRO RCPLOCSW IS INVOKED *\n.*     TO CHECK THIS OUT AND TO RETURN THE NAME OF THE SWITCH BYTE   *\n.*     IN GLOBAL SETC VARIABLE &RCPDSW1. THE SWITCH BIT NAME IS      *\n.*     RETURNED IN GLOBAL SETC &RCPDSW2. IF MORE THAN 1 SWITCH WAS   *\n.*     SPECIFIED, THEY ARE ALL CONCATENATED WITH INTERVENING PLUS    *\n.*     SIGNS. IN CASE A SWITCH WAS NOT DECLARED, RCPLOCSW ISSUES AN  *\n.*     MNOTE AND SETS &RCPDSW1 TO NULL.                              *\n.*                                                                   *\n.*********************************************************************\n         GBLA  &RCPDSW0                NO OF RETURNED SW BYTES\n         GBLB  &RCPDSW3(20)            INVERT INDICATOR\n         GBLB  &GOIFREL                USE RELATIVE\n         GBLB  &STF(24)                #START/#STACK FLAGS\n         GBLC  &RCPDSW1(20),&RCPDSW2(20)    BYTE NAMES AND BIT NAMES\n         LCLC  &OP\n         RCPLOCSW &SW                  CHECK AND LOCATE SWITCH BYTE\n&OP      SETC  'J'                     ASSUME RELATIVE ADDR\n         AIF   (&STF(19)).REL1         RELATIVE ADDRESSING\n         AIF   (&GOIFREL).REL1         TEST OLD FLAG TOO\n&OP      SETC  'B'                     SET FOR BASE REG USE\n.REL1    ANOP  ,\n         AIF   (&RCPDSW0 EQ 0).ERROR    NO SWS FOUND\n         AIF   (&RCPDSW0 GT 1).GOIFM    MORE THAN ONE SW BYTE\n         AIF   (N'&SW GT 1).GT1         BRANCH IF > 1 SWITCH\n&NAME    TM    &RCPDSW1(1),&RCPDSW2(1)  TEST SWITCH\n         AGO   .TON\n.GT1     ANOP  ,\n&NAME    TM    &RCPDSW1(1),&RCPDSW2(1)  TEST SWITCHES\n.TON     AIF   ('&ON' NE '').ON\n         AIF   ('&ONES' NE '').ONES\n         AIF   ('&BOTH' NE '').BOTH\n         AIF   ('&ALL' NE '').ALL\n.TOFF    AIF   ('&OFF' NE '').OFF\n         AIF   ('&ZERO' NE '').ZERO\n         AIF   ('&NONE' NE '').NONE\n.TMIX    AIF   ('&MIXED' NE '').MIX\n.TANY    AIF   ('&ANY' NE '').ANY\n.TNZ     AIF   ('&NOTZERO' NE '').NZ\n.TNO     AIF   ('&NOTONE' NE '').NO\n.TNOS    AIF   ('&NOTONES' NE '').NOS\n         MEXIT ,\n.ON      AIF   ('&ON'(1,1) EQ '(').ONR\n         &OP.O &ON                      BRANCH IF ON\n         AGO   .TOFF\n.ONR     BOR   &ON(1)                   BRANCH IF ON\n         AGO   .TOFF\n.ONES    AIF   ('&ONES'(1,1) EQ '(').ONESR\n         &OP.O &ONES                    BRANCH IF ONES\n         AGO   .TOFF\n.ONESR   BOR   &ONES(1)                 BRANCH IF ONES\n         AGO   .TOFF\n.BOTH    AIF   ('&BOTH'(1,1) EQ '(').BOTHR\n         &OP.O &BOTH                    BRANCH IF BOTH ON\n         AGO   .TOFF\n.BOTHR   BOR   &BOTH(1)                 BRANCH IF BOTH ON\n         AGO   .TOFF\n.ALL     AIF   ('&ALL'(1,1) EQ '(').ALLR\n         &OP.O &ALL                     BRANCH IF ALL ON\n         AGO   .TOFF\n.ALLR    BOR   &ALL(1)                  BRANCH IF ALL ON\n         AGO   .TOFF\n.OFF     AIF   ('&OFF'(1,1) EQ '(').OFFR\n         &OP.Z &OFF                     BRANCH IF OFF\n         AGO   .TMIX\n.OFFR    BZR   &OFF(1)                  BRANCH IF OFF\n         AGO   .TMIX\n.ZERO    AIF   ('&ZERO'(1,1) EQ '(').ZEROR\n         &OP.Z &ZERO                    BRANCH IF ZERO\n         AGO   .TMIX\n.ZEROR   BZR   &ZERO(1)                 BRANCH IF ZERO\n         AGO   .TMIX\n.NONE    AIF   ('&NONE'(1,1) EQ '(').NONER\n         &OP.Z &NONE                    BRANCH IF NONE ON\n         AGO   .TMIX\n.NONER   BZR   &NONE(1)                 BRANCH IF NONE ON\n         AGO   .TMIX\n.MIX     AIF   ('&MIXED'(1,1) EQ '(').MIXR\n         &OP.M &MIXED                   BRANCH IF MIXED\n         AGO   .TANY\n.MIXR    BMR   &MIXED(1)                BRANCH IF MIXED\n         AGO   .TANY\n.ANY     AIF   ('&ANY'(1,1) EQ '(').ANYR\n         &OP.NZ &ANY                    BRANCH IF ANY ON\n         AGO   .TNZ\n.ANYR    BNZR  &ANY(1)                  BRANCH IF ANY ON\n         AGO   .TNZ\n.NZ      AIF   ('&NOTZERO'(1,1) EQ '(').NZR\n         &OP.NZ &NOTZERO                BRANCH IF NOT ZERO\n         AGO   .TNO\n.NZR     BNZR  &NOTZERO(1)              BRANCH IF NOT ZERO\n         AGO   .TNO\n.NO      AIF   ('&NOTONE'(1,1) EQ '(').NOR\n         &OP.NO &NOTONE                 BRANCH IF NOT ONE\n         AGO   .EXIT\n.NOR     BNOR  &NOTONE(1)               BRANCH IF NOT ONE\n         AGO   .EXIT\n.NOS     AIF   ('&NOTONES'(1,1) EQ '(').NOSR\n         &OP.NO &NOTONES                BRANCH IF NOT ONES\n         AGO   .EXIT\n.NOSR    BNOR  &NOTONES(1)              BRANCH IF NOT ONES\n         AGO   .EXIT\n.GOIFM   ANOP  ,\n         AIF   ('&NOTZERO' NE '').GOIFMX\n&NAME    GOIFM ON=&ON&ALL&BOTH&ONES,NOTALL=&NOTALL&NOTONES&NOTONE,     X\n               ANY=&ANY,OFF=&OFF&NONE,MIXED=&MIXED\n         MEXIT ,\n.GOIFMX  ANOP  ,\n         MNOTE 8,'NOTZERO= IS NOT SUPPORTED FOR MORE THAN ONE SWITCH'\n         MEXIT ,\n.ERROR   AIF   ('&NAME' EQ '').EXIT\n&NAME    DS    0H\n.EXIT    MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GOIFM": {"ttr": 4609, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x14\\x11/\\x01\\x14\\x11/\\x12H\\x00k\\x00k\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-04-22T00:00:00", "modifydate": "2014-04-22T12:48:33", "lines": 107, "newlines": 107, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&NAME    GOIFM &ON=,&OFF=,&MIXED=,&ELSE=,&NOTALL=,&ANY=\n         GBLA  &RCPDSW0                NO OF RETURNED BYTE NAMES\n         GBLB  &RCPDSW3(20)            INVERT INDICATORS\n         GBLC  &RCPDSW1(20),&RCPDSW2(20) BYTE AND BIT NAMES\n         GBLB  &GOIFREL                USE RELATIVE\n         GBLB  &STF(24)                #START/#STACK FLAGS\n         LCLB  &RELOP\n         LCLC  &OP\n         LCLA  &I,&J,&K,&L,&N\n         LCLC  &A,&B,&C,&M(2),&LABEL\n&RELOP   SETB  (&STF(19) OR &GOIFREL)  SET REL ADDR INDICATOR\n&LABEL   SETC  '&NAME'\n&N       SETA  N'&ON+N'&OFF+N'&ANY+N'&NOTALL+N'&ELSE\n         AIF   (K'&MIXED EQ 0).TON\n      MNOTE 4,'MIXED OPTION NOT SUPPORTED WITH MULTIPLE SWITCH BYTES'\n         AIF   (&N EQ 0).EXIT\n.TON     AIF   (K'&ON GT 0).ON\n         AIF   (K'&OFF GT 0).OFF\n         AIF   (K'&ANY GT 0).ANY\n         AIF   (K'&NOTALL GT 0).NOTALL\n         MEXIT OOPS\n.ON      AIF   (&N GT 1).ONPLUS\n&L       SETA  4                       LENGTH OF FINAL BRANCH\n&M(1)    SETC  'O'                     BRANCH MASK\n&M(2)    SETC  'Z'                     BRANCH MASK WHEN INVERTED\n&B       SETC  '&ON'                   BRANCH LABEL\n&OP      SETC  'J'\n         AIF   (&RELOP).RELA\n&OP      SETC  'B'                     ASSUME NOT REL\n.RELA    ANOP  ,\n         AIF   ('&ON'(1,1) NE '(').ONOFF WAS IT A REG?\n&L       SETA  2                       IF SO, FINAL BR LENGTH = 2\n&C       SETC  'R'                     REGISTER OP CODE\n&OP      SETC  'B'\n&B       SETC  '&ON'(2,K'&ON-2)        STRIP BRACKETS\n         AGO   .ONOFF\n.OFF     AIF   (&N GT 1).OFFPLUS\n&L       SETA  4                       LENGTH OF FINAL BRANCH\n&M(1)    SETC  'Z'                     BRANCH MASK\n&M(2)    SETC  'O'                     BRANCH MASK WHEN INVERTED\n&B       SETC  '&OFF'                  BRANCH LABEL\n&OP      SETC  'J'\n         AIF   (&RELOP).RELB\n&OP      SETC  'B'                     ASSUME NOT REL\n.RELB    ANOP  ,\n         AIF   ('&OFF'(1,1) NE '(').ONOFF WAS IT A REG?\n&L       SETA  2                       IF SO, FINAL BR LENGTH = 2\n&C       SETC  'R'                     REGISTER OP CODE\n&OP      SETC  'B'\n&B       SETC  '&OFF'(2,K'&OFF-2)      STRIP BRACKETS\n.ONOFF   ANOP  ,\n&L       SETA  (&RCPDSW0-1)*8+&L        INITIAL BR AROUND LEN\n.ONOFF1  AIF   (&I GE &RCPDSW0).EXIT\n&I       SETA  &I+1\n&LABEL   TM    &RCPDSW1(&I),&RCPDSW2(&I)\n&LABEL   SETC  ''                      ONLY WANT LABEL 1ST TIME\n&A       SETC  '&M(&RCPDSW3(&I)+1)'  BRANCH MASK\n         AIF   (&I EQ &RCPDSW0).ONOFFL GO IF FINAL BRANCH\n         &OP.N&A *+&L\n&L       SETA  &L-8                    DECREMENT BR LENGTH\n         AGO   .ONOFF1\n.ONOFFL  &OP&A&C &B\n         AGO   .EXIT\n.ANY     ANOP  ,\n&M(1)    SETC  'Z'                     BRANCH MASK\n&M(2)    SETC  'O'                     BRANCH MASK IF INVERTED\n&B       SETC  '&ANY'                  BRANCH TO LABEL\n&OP      SETC  'J'\n         AIF   (&RELOP).RELC\n&OP      SETC  'B'                     ASSUME NOT REL\n.RELC    ANOP  ,\n         AIF   ('&ANY'(1,1) NE '(').ANYNALL  CHECK FOR REG\n&C       SETC  'R'                     REG OP CODE\n&OP      SETC  'B'\n&B       SETC  '&ANY'(2,K'&ANY-2)      STRIP OFF BRACKETS\n         AGO   .ANYNALL\n.NOTALL  ANOP  ,\n&M(1)    SETC  'O'                     BRANCH MASK\n&M(2)    SETC  'Z'                     BRANCH MASK IF INVERTED\n&B       SETC  '&NOTALL'               BRANCH TO LABEL\n&OP      SETC  'J'\n         AIF   (&RELOP).RELD\n&OP      SETC  'B'                     ASSUME NOT REL\n.RELD    ANOP  ,\n         AIF   ('&NOTALL'(1,1) NE '(').ANYNALL  CHECK FOR REG\n&C       SETC  'R'                     REG OP CODE\n&OP      SETC  'B'\n&B       SETC  '&NOTALL'(2,K'&NOTALL-2) STRIP OFF BRACKETS\n.ANYNALL AIF   (&I GE &RCPDSW0).ELSE\n&I       SETA  &I+1\n&LABEL   TM    &RCPDSW1(&I),&RCPDSW2(&I)\n&LABEL   SETC  ''                      ONLY WANT LABEL 1ST TIME\n&A       SETC  '&M(&RCPDSW3(&I)+1)&C'   GET BRANCH MASK\n         &OP.N&A &B\n         AGO   .ANYNALL\n.ELSE    AIF   ('&ELSE' EQ '').END\n         AIF   ('&ELSE'(1,1) EQ '(').ELSER\n         &OP   &ELSE\n         MEXIT ,\n.ELSER   BR    &ELSE(1)\n         MEXIT ,\n.ONPLUS  ANOP  ,\n.OFFPLUS MNOTE 'MULTIPLE KEYWORDS NOT SUPPORTED YET'\n.EXIT    AIF   ('&LABEL' EQ '').END\n&LABEL   DS    0H\n.END     MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IDAAMDSB": {"ttr": 1282, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00U\\x00U\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 85, "newlines": 85, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         IDAAMDSB\n*---------------------------------------------------------------------*\n* THE AMDSB CONTAINS STATISTICAL INFORMATION ABOUT RECORD PROCESSING  *\n* IN THE DATASET.  IT ALSO CONTAINS SOME OF THE DATASET'S ATTRIBUTES  *\n* AND SPECIFICATIONS.  THE AMDSB IS BUILT USING THE DATASET OR INDEX  *\n* CATALOG RECORD'S AMDSB SET OF FIELDS, WHEN THE CLUSTER IS OPENED.   *\n* A COPY OF THE AMDSB IS CONTAINED IN THE DATASET'S DATA CATALOG      *\n* RECORD AND, IF THE DATASET IS KEY-SEQUENCED, IN THE INDEX CATALOG   *\n* RECORD.  THE DATA OR INDEX AMB (AMBDSB) POINTS TO ITS ASSOCIATED    *\n* AMDSB.                                                              *\n*---------------------------------------------------------------------*\nIDAAMDSB DSECT ,\nAMDSB    EQU   *\nAMDSBID  DS    X            AMDSB IDENTIFIER, X'60'.\nAMDATTR  DS    X            ATTRIBUTES OF THE DATASET:\nAMDDST   EQU   B'10000000'  KEY SEQUENCED DATASET.\nAMDWCK   EQU   B'01000000'  CHECK EACH RECORD WHEN IT IS WRITTEN.\nAMDSDT   EQU   B'00100000'  SEQUENCE SET IS STORED WITH THE DATA AND IS\n*                           REPLICATED - DUPLICATED AS MANY TIMES AS\n*                           POSSIBLE AROUND THE TRACK.\nAMDREPL  EQU   B'00010000'  ALL INDEX RECORDS ARE REPLICATED -\n*                           DUPLICATED AS MANY TIMES AS POSSIBLE AROUND\n*                           THE TRACK.\nAMDORDER EQU   B'00001000'  USE THE VOLUMES IN THE SAME ORDER AS IN THE\n*                           VOLUME LIST.\nAMDRANGE EQU   B'00000100'  THE DATASET IS DIVIDED INTO KEY RANGES.\nAMDRRDS  EQU   B'00000010'  RELATIVE RECORD DATASET.\nAMDSPAN  EQU   B'00000001'  DATASET CONTAINS SPANNED RECORDS.\nAMDLEN   DS    H            LENGTH OF AMDSB.\nAMDNEST  DS    0H           NO OF ENTRIES IN THE INDEX SECTION.\nAMDAKRKP DS    H            RELATIVE KEY POSITION OF THE ALTERNATE KEY.\nAMDRKP   DS    H            RELATIVE KEY POSITION.\nAMDKEYLN DS    H            KEY LENGTH.\nAMDPCTCA DS    X            PERCENT OF FREE CONTROL INTERVALS IN THE\n*                           CONTROL AREA.\nAMDPCTCI DS    X            PERCENT OF FREE BYTES IN THE CONTROL\n*                           INTERVAL.\nAMDCIPCA DS    H            NUMBER OF CONTROL INTERVALS IN A CONTROL\n*                           AREA.\nAMDFSCA  DS    H            NUMBER OF FREE CONTROL INTERVALS IN A\n*                           CONTROL AREA.\nAMDFSCI  DS    XL4          NUMBER OF FREE BYTES PER CONTROL INTERVAL.\nAMDCINV  DS    F            CONTROL INTERVAL SIZE.\nAMDLRECL DS    F            MAXIMUM RECORD SIZE.\nAMDHLRBA DS    0F           RELATIVE BYTE ADDRESS (RBA) OF THE HIGH-\n*                           LEVEL INDEX RECORD (KSDS).\nAMDNSLOT DS    F            NUMBER OF RECORD SLOTS PER CONTROL INTERVAL\n*                           (RRDS).\nAMDSSRBA DS    0F           RELATIVE BYTE ADDRESS (RBA) OF THE FIRST\n*                           SEQUENCE-SET RECORD (KSDS).\nAMDMAXRR DS    F            MAXIMUM VALID RELATIVE RECORD NUMBER(RRDS).\nAMDPARDB DS    F            ADDRESS OF THE TO FIRST ARDB\nAMDATTR3 DS    X            ATTRIBUTES:\nAMDUNQ   EQU   B'10000000'  THE DATASET HAS NONUNIQUE KEYS.\nAMDFAULT EQU   B'01000000'  THE DATASET IS STAGED BY CYLINDER FAULT.\nAMDBIND  EQU   B'00100000'  THE DATASET IS STAGED AND BOUND.\nAMDWAIT  EQU   B'00010000'  THE DATASET DESTAGING IS COMPLETED BEFORE\n*                           CONTROL IS RETURNED TO THE PROGRAM THAT\n*                           CLOSES THE DATASET.\nAMDLM    EQU   B'00001000'  THE DATASET IS LOADED.\nAMDLDS   EQU   B'00000100'  LINEAR DATASET\n*        EQU   B'00000011'  RESERVED\nAMDSTRNO DS    X            NUMBER OF CONCURRENT REQUESTS.\nAMDDUI   DS    CL4          RESERVEIMS DBRC USAGE INDICATOR\nAMDBFNO  DS    XL2          NUMBER OF DATA OR INDEX BUFFERS.\nAMDSTAT  DS    0XL48        DATASET STATISTICS:\nAMDSTSP  DS    XL8          OS/VS SYSTEM TIME STAMP.\nAMDNIL   DS    H            NUMBER OF INDEX LEVELS\nAMDNEXT  DS    H            NUMBER OF EXTENTS IN THE DATASET.\nAMDNLR   DS    F            NUMBER OF USER-SUPPLIED RECORDS IN THE\n*                           DATASET.\nAMDDELR  DS    F            NUMBER OF DELETED RECORDS.\nAMDIREC  DS    F            NUMBER OF INSERTED RECORDS.\nAMDUPR   DS    F            NUMBER OF UPDATED RECORDS.\nAMDRETR  DS    F            NUMBER OF RETRIEVED RECORDS.\nAMDASPA  DS    F            NUMBER OF BYTES OF FREE SPACE IN THE\n*                           DATASET.\nAMDNCIS  DS    F            NUMBER OF TIMES A CONTROL INTERVAL WAS\n*                           SPLIT.\nAMDNCAS  DS    F            NUMBER OF TIMES A CONTROL AREA WAS SPLIT.\nAMDEXCP  DS    F            NUMBER OF TIMES EXCP WAS ISSUED BY VSAM I/O\n*                           ROUTINES.\nAMDSBLEN EQU   *-AMDSB\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEFZB4D5": {"ttr": 783, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00\\x0f\\x00\\x0f\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 15, "newlines": 15, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&N       IEFZB4D5\nDSABQDB  DSECT\nDSQDBID  DS    CL4'DSAB'                ID\nDSQATTRS DS    XL2                      QUEUING ATTRIBUTES\nDSQDBLN  DS    AL2                      QDB LENGTH\nDSQNELMS DS    F                        NUMBER OF ELEMENTS ON QUEUE\nDSQFRSTP DS    F                        PTR TO 1ST DSAB\nDSQBADBC EQU   128                      BACKWARD CHAIN IS INCORRECT\nDSQLASTP DS    F                        PTR TO LAST DSAB\nDSQBADFC EQU   128                      FORWARD CHAIN IS INCORRECT\nDSQFDSP  DS    AL2                      DISP OF FWD PTR INTO DSAB\nDSQBDSP  DS    AL2                      DISP OF BACK PTR INTO DSAB\n         DS    F                        NOT USED\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEFZB421": {"ttr": 1284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00f\\x00f\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 102, "newlines": 102, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         IEFZB421\n*/********************************************************************/\n*/*                                                                  */\n*/*                                                                  */\n*/* NAME -  IEFZB421                                                 */\n*/*                                                                  */\n*/* DESCRIPTIVE NAME - ELIGIBLE DEVICES TABLE MAPPING MACRO          */\n*/*                                                                  */\n*/* FUNCTION -                                                       */\n*/*   THE ELIGIBLE DEVICES TABLE (EDT) IS USED BY DEVICE ALLOCATION  */\n*/*   TO ASSOCIATE UNIT DESCRIPTION INFORMATION WITH DEVICE TYPES    */\n*/*   AND DEVICES. IT IS ALSO USED TO DETERMINE THE GROUPS OF DEVICES*/\n*/*   FOR WHICH A PARTICULAR REQUEST IS ELIGIBLE.                    */\n*/*                                                                  */\n*/*   THE TABLE IS CREATED AT SYSGEN AND THE INFORMATION IS PLACED IN*/\n*/*   THE SETS OF SUBTABLES WHICH MAKE UP THE EDT. A HEADER PORTION  */\n*/*   OF THE EDT CONTAINS A POINTER TO THE HEADERS OF EACH SET       */\n*/*   OF SUBTABLES.                                                  */\n*/*                                                                  */\n*/* NOTE -                                                           */\n*/*    THE ELIGIBLE DEVICE TABLE IS A CSECT IN THE LOAD MODULE       */\n*/*    IEFEDTTB IN SYS1.LPALIB.  THE ADDRESS OF THE EDT MAY BE FOUND */\n*/*    AT ANY TIME IN FIELD JESEDT OF THE JESCT VIA THE CVT .        */\n*/*    THE EDT MAY ALSO BE FOUND VIA LOAD EP=IEFEDTTB                */\n*/*                                  ST   R0,@EDTTAB                 */\n*/********************************************************************/\n*\nEDTHDR   DSECT ,JESEDT       ***** HEADER SECTION\nEDTLUVSP DS    A                   PTR TO LOOK-UP-VALUE SECTION\nEDTGENSP DS    A                   PTR TO GENERIC SECTION\nEDTGRPSP DS    A                   PTR TO GROUP SECTION\nEDTUCBSP DS    A                   PTR TO DEVICE NBR SECTION\nEDTMSKTP DS    A                   PTR TO GROUP MASK TABLE\n         DS    A                   RESERVED\nEDTPREFP DS    A                   PTR TO PREFERENCE TABLE\nEDTID    DS    CL8                 EDT ID\nEDTDATE  DS    CL8                 EDT CREATE DATE\nEDTTIME  DS    CL5                 EDT CREATE TIME\n         DS    CL3                 RESERVED\nEDTNAME  DS    C'EDT'              'EDT' IDENTIFIER\nEDTLEVEL DS    C'1'                EDT LEVEL\n*\nLUVSECT  DSECT ,EDTLUVSP     ***** LOOK-UP-VALUE SECTION\nLUVHDR   DS    0D\nLUVENTNO DS    F                   NO. OF ENTRIES\nLUVENTLN DS    F                   SIZE OF EACH ENTRY\nLUVENTRY DSECT , 1ST AT LUVHDR+8\nUNITNAME DS    CL8                 UNIT NAME - IN EBCDIC\nLUVALUE  DS    XL4                 LOOK-UP-VALUE FOR UNITNAME\nLUVGMTP  DS    A                   PTR TO GROUP MASK TABLE ENTRY\nLUVGENNO DS    F                   NO. OF GENERICS IN THIS UNITNAME\nLUVGENP  DS    A                   PTR TO FIRST GENERIC FOR THIS L-U-V\nLUVFLAGS DS    B                   FLAGS\nLUVVAM   EQU   128                 ELIGIBLE FOR VIO DATASETS\nLUVAGMSK EQU   64                  AN ALTERNATE GROUP MASK POINTER     X\n                                   EXISTS IN THIS ENTRY\nLUVMGENS EQU   32                  ALLOCATION OF MULITIPLE GENERICS    X\n                                   WITHIN THIS L-U-V IS VALID\nLUVGENR  EQU   16                  NAME IS A GENERIC\nLUVESOTR EQU   16                  NAME IS AN ESOTERIC\nLUVGGENR EQU   16                  NAME IS A GENERATED GENERIC\n         DS    BL3\nLUVAGMTP DS    A                   ADDR OF ALTERNATE GROUP MASK\n*\nGENSECT  DSECT ,EDTGENSP     ***** GENERIC SECTION\nGENHDR   DS    0D\nGENENTNO DS    F                   NO. OF ENTRIES\nGENENTLN DS    F                   SIZE OF AN ENTRY\nGENENTRY DSECT ,\nGENDEVT  DS    XL4                 GENERIC DEVICE TYPE\nGENGRPNO DS    F                   NO. OF GROUPS FOR DEVICE TYPE\nGENGRPTR DS    A                   PTR TO GROUP ENTRY PTR IN GROUP PTR\n*\nGRPTRTAB DSECT ,             ***** GROUP POINTER TABLE\nGRPTR    DS    F                   PTR TO GROUP SECTION ENTRY\n*\nGRPSECT  DSECT ,EDTGRPSP     ***** GROUP SECTION\nGRPHDR   DS    0D\nGRPENTNO DS    F                   NO. OF ENTRIES (NO. OF GROUPS)\nGRPENTLN DS    F                   SIZE OF AN ENTRY\nGRPENTRY DSECT ,\nGRPID    DS    H                   GROUP IDENTIFIER\nGRPUCBNO DS    H                   NO. OF DEVICES IN GROUP\nGRPUCBI  DS    H                   INDEX INTO DEVICE NUMBER\n*                                  SECTION FOR EACH ENTRY FOR\n*                                  THIS GROUP\n*\nEUCBSECT DSECT ,EDTUCBSP     ***** DEVICE NUMBER SECTION\nEUCBHDR  DS    0D\nEUCBENNO DS    F                   NO. OF ENTRIES\nEUCBENLN DS    F                   SIZE OF AN ENTRY\nEUCBENTY DSECT ,GRPUCBP\nEUCBTPOS DS    CL3                 LIST OF DEVICE NUMBERS\n*\nGRMSKTAB DSECT ,EDTMSKTP     ***** GROUP MASK TABLE\nGMTHDR   DS    0D\nGMTENTNO DS    F                   NO. OF ENTRIES\nGMTENTLN DS    F                   SIZE OF AN ENTRY\nGMTENTRY DSECT ,LUVGMTP\nGRPMASK  DS    B                   BIT MASK\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEFZB461": {"ttr": 1026, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00 \\x00 \\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 32, "newlines": 32, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         IEFZB461\n*/********************************************************************/\n*/*                                                                  */\n*/*                                                                  */\n*/* NAME -  IEFZB461                                                 */\n*/*                                                                  */\n*/* DESCRIPTIVE NAME - UCB POINTER LIST                              */\n*/*                                                                  */\n*/* FUNCTION -                                                       */\n*/*   THIS MACRO MAPS THE ADDRESSES OF THE DEVICES WHICH CORRESPOND  */\n*/*   TO THE DEVICE ADDRESSES IN THE ELIGIBLE DEVICE TABLE (EDT).    */\n*/*   THE GROUP SECTION OF THE EDT CONTAINS THE INDEX TO THE FIRST   */\n*/*   DEVICE ASSOCIATED WITH THE DEVICE GROUP AND THE NUMBER OF      */\n*/*   CONSECUTIVE DEVICES IN THAT GROUP.                             */\n*/*   THE TABLE IS CREATED AT SYSGEN AND THE INFORMATION IS PLACED IN*/\n*/*   THE SETS OF SUBTABLES WHICH MAKE UP THE EDT. A HEADER PORTION  */\n*/*   OF THE EDT CONTAINS A POINTER TO THE HEADERS OF EACH SET       */\n*/*   OF SUBTABLES.                                                  */\n*/*                                                                  */\n*/********************************************************************/\n*\n         SPACE 2\nUPL      DSECT ,                 UCB POINTER LIST MAPPING\nUPLHDR   EQU   UPL               HEADER SECTION FIRST\nUPLID    DS    CL4               CHAR('UPL ')\nUPLNO    DS    F                 NUMBER OF ENTRIES\nUPLRSV01 DS    F                 * RESERVED\nUPLRSV02 DS    F                 * RESERVED\nUPLUCBL  EQU   *                 START OF UCB POINTER ENTRIES\nUPLUCBA  DS    F                 UCB POINTER ENTRY\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEZCAML": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x004\\x004\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 52, "newlines": 52, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         IEZCAML ,\nCAMLSTD  DSECT ,\nCAMOPTN1 DS    B                   FIRST OPTION BYTE\nCAMCVOL  EQU   B'10000000'         - CVOL SPECIFIED\nCAMNUCAM EQU   B'01000100'         - CAMLST MACRO GENERATED-NOT USED\nCAMCAT   EQU   B'00100000'         - CATALOG OR CATBX SPECIFIED\nCAMRECAT EQU   B'00010000'         - RECAT (RE-CATALOG SPECIFIED)\nCAMUNCAT EQU   B'00001000'         - UNCAT OR UCATDX SPECIFIED\nCAMLOCAT EQU   B'00000010'         - LOCATE BY TTR SPECIFIED\nCAMBLOCK EQU   B'00000010'         - LOCATE BY BLOCK SPECIFIED\n*              B'00000001'         - RESERVED\n*\nCAMOPTN2 DS    B                   SECOND OPTION BYTE\nCAMNOALC EQU   B'10000000'         - DO NOT ALLOCATE CVOL\nCAMBLDX  EQU   B'01000000'         - BLDX / CATBX SPECIFIED\nCAMBLDG  EQU   B'00100000'         - BLDG SPECIFIED\nCAMBLDA  EQU   B'00010000'         - BLDA SPECIFIED\nCAMLNKX  EQU   B'00001000'         - LNKX SPECIFIED\nCAMDLTX  EQU   B'00000100'         - DLTX / UCATDX SPECIFIED\nCAMDSCB  EQU   B'00000010'         - DSCB TTR SPECIFIED\nCAMDSCBT EQU   B'00000010'         - DSCB TTR SPECIFIED\nCAMDLTA  EQU   B'00000001'         - DLTA SPECIFIED\n*\nCAMOPTN3 DS    B                   THIRD OPTION BYTE\nCAMDRPX  EQU   B'10000000'         - DRPX SPECIFIED\nCAMDELET EQU   B'01000000'         - INDICATE DELETE OPTION\nCAMRENAM EQU   B'00100000'         - RENAME SPECIFIED\nCAMTIOT  EQU   B'00010000'         - SYSZTIOT IS ENQUEUED EXCLUSIVELY\nCAMEMPTY EQU   B'00001000'         - INDICATE THE EMPTY OPTION\nCAMSLOCB EQU   B'00000100'         - SUPERLOCATE WITH BASE SUPPLIED\nCAMSLOC  EQU   B'00000010'         - SUPERLOCATE\n*              B'.......0'         - THE CALLER SUPPLIED A CAMLST\nCAMAM0   EQU   B'00000001'         - THE CALLER SUPPLIED A CTGPL\n*\nCAMGEN   DS    X                   MAXIMUM GENERATION COUNT FOR GDG\n*\nCAMPTR1  DS    A                   ADDRESS OF NAME OR TTR IF LOCATE\n*\nCAMPTR2  DS    0A                  ADDRESS OF CVOL VOLSER\nCAMCVOLP DS    A                   CVOL VOLUME SERIAL ADDRESS\n*\nCAMPTR3  DS    A                   A) CATLG VOLUME LIST\n*                                  B) ALIAS/HIGH LEVEL INDEX\n*                                  C) LNKX DEVTYPE/VOLSER\n*                                  D) LOCATE WORK AREA\n*\nCAMPTR4  DS    0A                  ADDRESS OF DSCB TTR FOR CATLG\nCAMDSCBP DS    A                   DSCB TTR ADDRESS\n*\nCAMLEN   EQU   *-CAMLSTD           DATA LENGTH\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEZCTGFL": {"ttr": 1288, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00H\\x00H\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 72, "newlines": 72, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         IEZCTGFL ,\nCTGFL    DSECT ,\n*/********************************************************************/\n*/*                                                                  */\n*/*   MACRO NAME = IEZCTGFL                                          */\n*/*                                                                  */\n*/*   DESCRIPTIVE NAME = CATALOG FIELD PARAMETER LIST                */\n*/*                                                                  */\n*/*   FUNCTION = THE FIELD PARAMETER LIST (CTGFL) DEFINES ONE OF     */\n*/*              THE CATALOG RECORD'S FIELDS OR A GROUP OF           */\n*/*              LOGICALLY RELATED FIELDS.  THE CTGFL IS BUILT       */\n*/*              BEFORE AN OS/VS COMPONENT ISSUES THE CATLG          */\n*/*              MACRO INSTRUCTION (SVC 26) TO PROCESS A             */\n*/*              CATALOG RECORD.  THE CTGFL IS USED IN TWO           */\n*/*              SITUATIONS:                                         */\n*/*                (1)  IT IDENTIFIES CATALOG RECORD INFORMATION     */\n*/*                     TO RETRIEVE OR UPDATE.  THE CTGPL CONTAINS   */\n*/*                     THE ADDRESS OF EACH CTGFL USED IN THIS WAY.  */\n*/*                (2)  IT IDENTIFIES CATALOG RECORD INFORMATION     */\n*/*                     TO COMPARE AGAINST CALLER-SUPPLIED DATA.     */\n*/*                     THIS IS A \"TEST\" CTGFL AND IS ADDRESSED BY   */\n*/*                     ANOTHER CTGFL.                               */\n*/*                                                                  */\n*/*   CONTROL BLOCK STRUCTURE = THE CTGFL IS POINTED TO BY THE       */\n*/*                             CCA ('CCAFLPT' OR 'CCATEST').        */\n*/*                                                                  */\n*/*   INCLUDED MACROS = NONE                                         */\n*/*                                                                  */\n*/*   METHOD OF ACCESS = PL/S - NO DECLARES NECESSARY                */\n*/*                                                                  */\n*/*   STATUS = VS/2 RELEASE 3   (CHANGE FLAG @Y30SSXX)               */\n*/*                                                                  */\n*/*   DATE OF LAST CHANGE = 17 JUL 74                                */\n*/*                                                                  */\n*/********************************************************************/\n*\nCTGFLDNO DS    XL1                      NUMBER PAIRS DATA LNG/ADDR\n*\nCTGFLDCD DS    XL1                      TEST CONDITION\nCTGFLDEQ EQU   X'80'                    EQUAL\nCTGFLDNE EQU   X'60'                    NOT EQUAL\nCTGFLDGT EQU   X'20'                    GREATER THAN\nCTGFLDLT EQU   X'40'                    LESS THAN\nCTGFLDGE EQU   X'A0'                    GREATER THAN OR EQUAL\nCTGFLDLE EQU   X'C0'                    LESS THAN OR EQUAL\nCTGFLDZ  EQU   X'80'                    TEST UNDER MASK FOR ZEROES\nCTGFLDON EQU   X'10'                    TEST UNDER MASK FOR ONES\nCTGFLDMX EQU   X'40'                    TEST UNDER MASK FOR MIXED\nCTGFLDGF EQU   X'FF'                    GENERIC FILTER TEST\n*\nCTGFLDGC DS    XL1                      GROUP CODE NUMBER\n*\nCTGFLDRE DS    XL1                      TEST RESULT\nCTGFLDTS EQU   X'01'                    TEST MASK - CTGFLDRE\n*                                       = 0 - SUCCESSFUL TEST,\n*                                       = 1 - TEST FAILED\n*\nCTGFLDWA DS    F                        CATALOG WORK AREA\n*\nCTGFLDNM DS    A                        FIELD NAME ADDRESS\n*\nCTGFLCHN DS    A                        ADDRESS OF NEXT FIELD\n*\n*\nCTGFLDAT DS    0CL8                     PAIRS OF DATA LENGTH/ADDRESS\nCTGFLNG  DS    F                        DATA LENGTH\nCTGFLPT  DS    A                        DATA ADDRESS\n*\n*\nCTGFLLEN EQU   *-CTGFL                  LENGTH OF CTGFL\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IEZCTGFV": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00n\\x00n\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 110, "newlines": 110, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         IEZCTGFV &P=CTG\n&P.FV    DSECT ,\n*/********************************************************************/\n*/*                                                                  */\n*/*   MACRO NAME = IEZCTGFV                                          */\n*/*                                                                  */\n*/*   DESCRIPTIVE NAME = FIELD VECTOR TABLE                          */\n*/*                                                                  */\n*/*   FUNCTION = THE \"CTGFV\" IS BUILT BY THE ACCESS METHOD SERVICES  */\n*/*              UTILITY PROGRAMS AND CONTAINS ADDRESSES OF USER-    */\n*/*              SUPPLIED INFORMATION FIELDS AND LISTS.  THE \"CTGFV\" */\n*/*              IS BUILT WHEN THE USER ISSUES A \"DEFINE\" OR \"ALTER\" */\n*/*              COMMAND.  IF THE USER IS CREATING A CLUSTER, A      */\n*/*              \"CTGFV\" IS BUILT FOR EACH CATALOG RECORD THAT WILL  */\n*/*              BE BUILT TO DESCRIBE THE CLUSTER: THAT IS, ACCESS   */\n*/*              METHOD SERVICES \"DEFINE\" PROCESSING BUILDS A        */\n*/*              \"CLUSTER\" CTGFV, A \"DATA\" CTGFV\", AND, IF THE       */\n*/*              CLUSTER IS KEY-SEQUENCED, AN \"INDEX\" CTGFV.  THE    */\n*/*              \"CTGFV\" IS POINTED TO BY THE \"CTGPL(CTGFVT).  IF    */\n*/*              ACCESS METHOD SERVICES BUILDS MORE THAN ONE \"CTGFV\" */\n*/*              THE \"CLUSTER\" CTGFV IS POINTED TO BY THE \"CTGPL\"    */\n*/*              (CTGFVT) AND THE \"DATA\" AND \"INDEX\" CTGFVS ARE      */\n*/*              POINTED TO BY THE \"CLUSTER\" CTGFV.                  */\n*/*                                                                  */\n*/********************************************************************/\n&P.FVTYP DS    C                  THE CTGFV CONTAINS INFORMATION USED\n*                                 BY THE DEFINE ROUTINES TO BUILD A\n*                                 CATALOG RECORD OF TYPE:\n&P.FVALN EQU   C'A'               NON-VSAM DATA SET\n&P.FVGBS EQU   C'B'               GENERATION DATA GROUP (GDG) BASE\n&P.FVCL  EQU   C'C'               CLUSTER\n&P.FVDTA EQU   C'D'               DATA SET\n&P.FVAIX EQU   C'G'               ALTERNATE INDEX\n&P.FVIDX EQU   C'I'               INDEX\n&P.FVPTH EQU   C'R'               PATH\n&P.FVVOL EQU   C'V'               VOLUME\n&P.FVANM EQU   C'X'               ALIAS NAME\n&P.FVPRO DS    B                  CATALOG MANAGEMENT SERVICES\n*                                 PROCESSING OPTION FLAGS:\n&P.FVAVL EQU   B'10000000'        ALTER: ADD VOLUMES\n&P.FVRVL EQU   B'01000000'        ALTER: REMOVE VOLUMES\n&P.FVNDC EQU   B'00100000'        NO DEVICE-TYPE CONVERSION\n&P.FVDRC EQU   B'00010000'        DEFINE A RECOVERABLE CATALOG\n&P.FVRON EQU   B'00001000'        TURN RACF INDICATOR ON\n&P.FVROF EQU   B'00000100'        TURN RACF INDICATOR OFF\n&P.FVBOF EQU   B'00000010'        TURN BUSY INDICATOR OFF\n*        EQU   B'00000001'        RESERVED\n&P.FVELM DS    X                  ELEMENT NUMBER OF CMSPCATR\n&P.FVFL2 DS    B                  ICF PROCESSING FLAGS\n&P.FVSRC EQU   B'10000000'        SOURCE CATALOG NAME CHANGE\n&P.FVNAL EQU   B'01000000'        DEFINE WITH NO-ALLOCATION\n&P.FVICF EQU   B'00100000'        0=VSAM CATALOG, 1=ICF CATALOG\n&P.FVRCT EQU   B'00010000'        DEFINE WITH RECATALOG\n&P.FVNSD EQU   B'00001000'        NO CATALOG SELF DESCRIBING RECORDS\n&P.FVABS EQU   B'00000100'        SUBALLOCATED DATASET FOR ICF\n*                                 CONVERTCAT\n*        EQU   B'00000011'        RESERVED\n&P.FVDCH DS    A                  ADDRESS OF CLUSTER'S DATA CTGFV\n&P.FVICH DS    A                  ADDRESS OF CLUSTER'S INDEX CTGFV\n&P.FVVCH DS    A                  ADDRESS OF SPACE CTGFV\n&P.FVIND DS    A                  ADDRESS OF ASSOCIATED JCL DD\n*                                 STATEMENT\n&P.FVENT DS    A                  ADDRESS OF ENTRY NAME\n&P.FVSTY DS    A                  ADDRESS OF THE SECURITY INFORMATION\n*                                 CTGFL (PASSWORDS, CODEWORD, AND\n*                                 NUMBER OF TRIES)\n&P.FVOWN DS    A                  ADDRESS OF OWNER IDENTIFICATION CTGFL\n&P.FVEXP DS    A                  ADDRESS OF EXPIRY DATE CTGFL\n&P.FVCRE DS    A                  ADDRESS OF CREATION DATE CTGFL\n&P.FVVLT DS    A                  ADDRESS OF VOLUME SERIAL NUMBER LIST\n&P.FVRNG DS    A                  ADDRESS OF THE KEY RANGE LIST\n&P.FVDVT DS    A                  ADDRESS OF THE DEVTYPE CTGFL (FOR\n*                                 DEFINE NONVSAM ONLY)\n&P.FVSPC DS    0A                 ADDRESS OF THE SPACE ALLOCATION\n*                                 INFORMATION CTGFL\n&P.FVTTR DS    A                  ADDRESS OF THE DSCB'S TTR (FOR DEFINE\n*                                 NONVSAM ONLY)\n&P.FVAMD DS    0A                 ADDRESS OF THE AMDSB CTGFL (FOR\n*                                 DEFINE CATALOG AND DEFINE CLUSTER\n*                                 ONLY)\n&P.FVFSN DS    A                  ADDRESS OF THE FILE SEQUENCE NUMBER\n*                                 CTGFL (FOR DEFINE NONVSAM ONLY)\n&P.FVATR DS    A                  ADDRESS OF DATA SET ATTRIBUTES CTGFL\n&P.FVBUF DS    A                  ADDRESS OF THE BUFFER SIZE CTGFL\n&P.FVLRS DS    A                  ADDRESS OF THE AVERAGE RECORD SIZE\n*                                 CTGFL\n&P.FVLMT DS    0A                 ADDRESS OF THE GDG LIMIT (FOR DEFINE\n*                                 GDG BASE ONLY)\n&P.FVEXT DS    A                  ADDRESS OF EXCEPTION EXIT PARAMETER\n*                                 LIST\n&P.FVGAT DS    0A                 ADDRESS OF THE GDG ATTRIBUTES (FOR\n*                                 DEFINE GDG BASE ONLY)\n&P.FVUPG DS    A                  ADDRESS OF RGATTR PARAMETER LIST\n&P.FVNAM DS    A                  ADDRESS OF THE TRUE NAME CTGFL (FOR\n*                                 DEFINE ALIAS ONLY)\n&P.FVPWD DS    0A                 ADDRESS OF THE RELATED OBJECTS\n*                                 PASSWORD\n&P.FVCPP DS    A                  ADDRESS OF TSO COMMAND PROCESSOR\n*                                 PARAMETER LIST (CPPL TSO COMMAND\n*                                 CALLERS ONLY). IF ZERO, DAIRFAIL\n*                                 MESSAGES WILL BE WTP'S.\n&P.FVWKA DS    0A                 ADDRESS OF THE CRA FEEDBACK AREA\n&P.FVCAT DS    A                  ADDRESS OF SOURCE CATALOG ACB\n&P.FVELT DS    A                  ADDRESS OF EXTENT INFORMATION LIST\n&P.FVRBA DS    A                  ADDRESS OF FPL OF HURBA AND HARBA FOR\n*                                 DATA OR INDEX COMPONENT DURING\n*                                 CONVERTCAT\n&P.FVLEN EQU   *-&P.FV            LENGTH OF FIELD VECTOR TABLE\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IEZCTGPL": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00\\xc9\\x00\\xc9\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 201, "newlines": 201, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         IEZCTGPL ,\nCTGPL    DSECT ,\n*/********************************************************************/\n*/*                                                                  */\n*/*   $MAC(IEZCTGPL):                                                */\n*/*                                                                  */\n*/*   DESCRIPTIVE NAME = CATALOG PARAMETER LIST                      */\n*/*                                                                  */\n*/*   FUNCTION = THE CATALOG PARAMETER LIST (CTGPL) DEFINES THE      */\n*/*              CATALOG MANAGEMENT REQUEST AND ITS OPTIONS, THE     */\n*/*              CATALOG RECORD TO BE PROCESSED, AND THE VSAM        */\n*/*              CATALOG THAT CONTAINES THE RECORD.  THE CTGPL IS    */\n*/*              BUILT BEFORE AN OS/VS COMPONENT ISSUES THE CATLG    */\n*/*              MACRO INSTRUCTION (SVC 26) TO PROCESS A CATALOG     */\n*/*              RECORD.  WHEN THE CATALOG MANAGEMENT ROUTINES       */\n*/*              BUILD A CCA TO SUPPORT THE REQUEST, THE ADDRESS     */\n*/*              OF THE CTGPL IS PUT INTO THE CCA (CCACPL).          */\n*/*                                                                  */\n*/*   CONTROL BLOCK STRUCTURE = THE CTGPL IS POINTED TO BY           */\n*/*                             REGISTER 1.                          */\n*/*                                                                  */\n*/********************************************************************/\nCTGOPTN1 DS    XL1                      FIRST OPTION INDICATOR\nCTGBYPSS EQU   X'80'                    BYPASS\nCTGMAST  EQU   X'40'                    VERIFY MASTER PASSWORD\nCTGCI    EQU   X'20'                    VERIFY CONTROL INDICATOR\nCTGUPD   EQU   X'10'                    VERIFY UPDATE\nCTGREAD  EQU   X'08'                    VERIFY READ\nCTGNAME  EQU   X'04'                    1 - 44-BYTE NAME OR VOLSER\n*                                       0 - ENTRY ID NUMBER\nCTGCNAME EQU   X'02'                    1 - 44-BYTE NAME\n*                                       0 - ACB ADDRESS\nCTGGENLD EQU   X'01'                    GENERIC LOCATE REQUEST\n*\nCTGOPTN2 DS    XL1                      SECOND OPTION INDICATOR\nCTGEXT   EQU   X'80'                    EXTEND(UPDATE)\nCTGNSVS  EQU   X'80'                    CATLG CLEANUP REQUEST\nCTGERASE EQU   X'40'                    ERASE(DELETE)\nCTGSMF   EQU   X'40'                    WRITE SMF(LSPACE)\nCTGREL   EQU   X'40'                    RELEASE(UPDATE)\nCTGGTALL EQU   X'40'                    CONCAT SEARCH (LISTCAT)\nCTGGFLIC EQU   X'40'                    SRCH ONLY 1 CAT(GFL)\nCTGGGFL1 EQU   X'40'                    SEARCH ONLY 1 CAT (GFL)\nCTGPURG  EQU   X'20'                    PURGE (DELETE)\nCTGVMNT  EQU   X'20'                    VOLUME MOUNT CALLER\nCTGRCATN EQU   X'20'                    RTN CAT NAME(GLOC,GFL)\nCTGSWAP  EQU   X'20'                    SWAPSPACE (DEFINE)\nCTGGTNXT EQU   X'10'                    GET NEXT (LIST CTLG)\nCTGUCRAX EQU   X'10'                    UCRA EXTEND OPTION\nCTGDELRC EQU   X'10'                    DELETE RECOVER\nCTGDISC  EQU   X'08'                    DISCONNECT (DELETE)\nCTGRESM  EQU   X'08'                    GFL RESUME FUNCTION\nCTGOVRID EQU   X'04'                    ERASE OVERRIDE (DELETE)\nCTGCNVTC EQU   X'04'                    CONVERT CAT (DELETE SPACE)\n*\nCTGSCR   EQU   X'02'                    SCRATCH SPACE (DELETE)\nCTGCDI   EQU   X'02'                    DATA INDEX ARE MATCHES IF ITS\n*                                       CLUSTER/AIX MATCH FILTER KEY\n*\nCTGBOTH  EQU   X'01'                    CALLER CAN ACCEPT ICF CATALOG\n*                                       ARCHITECTURE\nCTGOPTN3 DS    XL1                      THIRD OPTION INDICATOR\nCTGFUNC  EQU   X'E0'                    HIGH ORDER THREE BITS DEFINE\n*                                       FUNCTION\n*   LOCATE     -   001* ****\nCTGLOC   EQU   X'20'                    LOCATE - BITS ON\n*   LSPACE     -   010* ****\nCTGLSP   EQU   X'40'                    LSPACE - BITS ON\n*   UPDATE     -   011* ****\nCTGUPDAT EQU   X'60'                    UPDATE - BITS ON\n*   CMS FUNCTION - 100* ****\nCTGCMS   EQU   X'80'                    CMS FUNCTION - BITS ON\n*   GFL          - 101* ****\nCTGGFL   EQU   X'A0'                    GFL          - BITS ON\n*   CNL          - 110* ****\nCTGCNL   EQU   X'C0'                    CNL          - BITS ON\n*\nCTGSUPLT EQU   X'10'                    SUPER LOCATE\nCTGGDGL  EQU   X'08'                    GDG LOCATE FUNCTION (CTGWAGB IN\n*                                       CTGWA)\nCTGSRH   EQU   X'04'                    0 - SEARCH MASTER CAT ONLY\n*                                       1 - SEARCH OS CAT FIRST\nCTGNUM   EQU   X'02'                    0 - SEARCH BOTH CATALOGS\n*                                       1 - SEARCH ONE CATALOG\nCTGAM0   EQU   X'01'                    VSAM REQ VERSUS NONVSAM\n*\nCTGOPTN4 DS    XL1                      FOURTH OPTION INDICATOR\nCTGLBASE EQU   X'80'                    LOCATE GDG BASE ONLY\nCTGNDISC EQU   CTGLBASE                 DELETE CATALOG NO DISCONNECT\n*\nCTGNOCON EQU   CTGLBASE                 DELETE CATALOG NO CONNECT\nCTGDOCAT EQU   X'40'                    DO NOT OPEN NEEDED CATLG\nCTGNPROF EQU   X'20'                    NO (RAC) PROFILE SHOULD BE\n*                                       DEFINED OR DELETED\nCTGCOIN  EQU   X'10'                    CONTROLLER INTERCEPT REQUESTED\n*\nCTGBYPMT EQU   X'08'                    BYPASS SECURITY PROMPTING TO\n*                                       SYSTEM OPERATOR\nCTGTIOT  EQU   X'04'                    CALLER OWNS SYSZTIOT EXCLUSIVE\nCTGICFC  EQU   X'02'                    REQUEST ORIENTED TO ICF CATALOG\n*\nCTGICFOR EQU   X'01'                    ICF ONLY REQUEST\nCTGENT   DS    0A                       USER ENTRY ADDRESS OR POINTER\n*                                       TO VOLUME SERIAL NUMBER(LSPACE)\nCTGFVT   DS    0A                       FVT ADDRESS (DEFINE, ALTER)\nCTGDNT   DS    A                        POINTER TO DATA SET NAME TABLE\n*\nCTGCAT   DS    0A                       CATALOG POINTER\n*\nCTGCVOL  DS    A                        CVOL PTR (SUPER LOCATE)\n*\nCTGWKA   DS    A                        WORKAREA ADDRESS\n*\nCTGDSORG DS    CL2                      DATA SET ORG (SUPER LOCATE)\n         ORG   CTGDSORG\nCTGDSOR1 DS    CL1                      BYTE 1\n*   BITS 0-4 DEFINE ORGANIZATION\nCTGOPTNS EQU   X'F8'                    TOP 5 BITS\n*   DEFINE          - 0000 1*** **** ****\nCTGDEFIN EQU   X'08'                    DEFINE\n*   ALTER           - 0001 0*** **** ****\nCTGALTER EQU   X'10'                    ALTER\n*   DELETE          - 0001 1*** **** ****\nCTGDELET EQU   X'18'                    DELETE\n*   LIST CATALOG    - 0010 0*** **** ****\nCTGLTCAT EQU   X'20'                    LIST CATALOG\n*   CONVERTV        - 0011 0*** **** ****\nCTGCNVTV EQU   X'30'                    CONVERTV\n*   CAS CAT OPEN    - 0011 1*** **** ****\nCTGOPEN  EQU   X'38'                    CAS CAT OPEN\n*   CAS CAT CLOSE   - 0100 0*** **** ****\nCTGCLOSE EQU   X'40'                    CAS CAT CLOSE\n*   CAS CAT VVDS    - 0100 1*** **** ****\nCTGVVDS  EQU   X'48'                    CAS CAT VVDS\nCTGF2WKA EQU   X'04'                    FORMAT 2 WORK AREA\nCTGVVRUP EQU   X'02'                    VVDS UPDATE ONLY\nCTGF2SEN EQU   X'01'                    CAN HANDLE 40-2 RC\nCTGDSOR2 DS    CL1                      BYTE 2\nCTGFVFY  EQU   X'80'                    FORCE PASSWORD VERIFICATION -\n*                                       DO NOT CHECK FOR AUTHORIZED\n*                                       CALLER.\nCTGHDLET EQU   X'40'                    HSM HAS DELETED A MIGRATED\n*                                       DATA SET\nCTGHALTL EQU   X'20'                    LOCATE FROM ALTER\nCTGHDLTL EQU   X'10'                    LISTCAT FROM DELETE\nCTGBRCAT EQU   X'08'                    BRANCH ENTRY TO IGGOCLAH -\n*                                       RESTRICTED TO KEY ZERO USE AND\n*                                       CMS FUNCTIONS CTGOPEN,\n*                                       CTGCLOSE, AND CTGVVDS.\n*\n*   BITS 13-15 RESERVED\n*\nCTGTYPE  DS    CL1                      ENTRY TYPE-LISTCAT,DELETE\nCTGTALIN EQU   C'A'                     ALIEN - A\nCTGTGBS  EQU   C'B'                     GDG BASE - B\nCTGTCL   EQU   C'C'                     CLUSTER - C\nCTGTDATA EQU   C'D'                     DATA - D\nCTGTFREE EQU   C'F'                     FREE - F\nCTGTAIX  EQU   C'G'                     ALTERNATE INDEX - G\nCTGTGDS  EQU   C'H'                     GDS - H\nCTGTINDX EQU   C'I'                     INDEX - I\nCTGTLIB  EQU   C'L'                     LIBRARYENTRY - L\nCTGTVVR  EQU   C'K'                     VSAM VOLUME RECORD\nCTGTMCAT EQU   C'M'                     MASTER CATALOG - M\nCTGTPGSP EQU   C'P'                     PAGE SPACE - P\nCTGTPATH EQU   C'R'                     PATH - R\nCTGTPTH  EQU   C'R'                     PATH - R\nCTGTTNAM EQU   C'T'                     ICF TRUE NAME\nCTGTUCAT EQU   C'U'                     USER CATALOG - U\nCTGTVOL  EQU   C'V'                     VOLUME - V\nCTGTANM  EQU   C'X'                     ALIAS BASE -X\nCTGTUPG  EQU   C'Y'                     UPGRADE - Y\nCTGTJES3 EQU   X'01'                    JES3 SUPERLOCATE REQUEST\nCTGMULTY EQU   X'FF'                    MULTIPLE TYPES - 'FF'X\n*\nCTGNOFLD DS    XL1                      NUMBER FIELD POINTERS\nCTGDDNM  DS    0A                       DD NAME ADDRESS\nCTGNEWNM DS    0A                       NEWNAME ADDRESS - ALTER\nCTGFILTR DS    0A                       GFL FILTER KEY ADDRESS\nCTGPROB  DS    0XL4                     PROBLEM DETERMINATION\nCTGMODID DS    0CL2                     MODULE IDENTIFICATION\nCTGFDBK  DS    XL2                      SUPER LOCATE FEEDBACK\nCTGFBFLG DS    0XL2                     SUPER LOCATE FLAGS\nCTGREASN DS    0XL2                     ERROR REASON CODE\nCTGREAS1 DS    XL1                      HIGH ORDER BYTE ZERO\nCTGPAR   EQU   X'80'                    PARALLEL MOUNT - SUPER LOC\nCTGKEEP  EQU   X'40'                    FORCED KEEP = SUPER LOCATE\nCTGGDGB  EQU   X'20'                    GDG BASE LOCATED\nCTGNGDSN EQU   X'10'                    GDG NAME GENERATED\nCTGCLV   EQU   X'08'                    CANDIDATE VOLUME LIST\n*        6-8  RESERVED\nCTGREAS2 DS    XL1                      REASON CODE LOW BYTE\n*\nCTGJSCB  DS    0A                       JSCB ADDRESS\nCTGPSWD  DS    A                        PASSWORD ADDRESS\nCTGFIELD DS    A                        FIELD POINTERS - MAY BE MORE\n*                                       THAN ONE\nCTGPLLEN EQU   *-CTGPL                  LENGTH OF CTG WITH ONE FIELD\n*                                       POINTER\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEZCTGVL": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00\\x1e\\x00\\x1e\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 30, "newlines": 30, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         IEZCTGVL &P=CTG\n***********************************************************************\n*                                                                     *\n*  MACRO NAME = IEZCTGVL                                              *\n*                                                                     *\n*  DESCRIPTIVE NAME = CATALOG VOLUME LIST                             *\n*                                                                     *\n*  FUNCTION = THE CTGVL IS BUILT BY THE ISSUER OF A LOCATE REQUEST    *\n*             FOR A DATA-SET NAME.  CATALOG MANAGEMENT USES THE CTGVL *\n*             TO RETURN TO THE CALLER THE VOLUME SERIAL NUMBERS OF    *\n*             THE VOLUMES ON WHICH SPACE IS ALLOCATED TO THE DATA     *\n*             SET.  FOR SUPERLOCATE REQUESTS, THE CTGWA POINTS TO THE *\n*             CTGVL.                                                  *\n*                                                                     *\n*  DATE OF LAST CHANGE = 21 FEB 83                                    *\n*                                                                     *\n***********************************************************************\n&P.VL    DSECT ,\n&P.VLVOL DS    CL6                VOLUME SERIAL NUMBER\n&P.VLDEV DS    XL4                DEVICE TYPE\n&P.VLSEQ DS    XL2                FILE SEQUENCE NUMBER\n&P.VLLX  DS    0X                 VOLUME LIST EXTENSION\n&P.VLTTR DS    0XL3               FOR A SINGLE VOL DSN, THE TTR OF ITS\n*                                 DSCB\n&P.VLNXT DS    0X                 FOR A MULTI-VOLUME DATASET, A\n*                                 REPETITION OF CTGVLVOL, CTGVLDEV, AND\n*                                 CTGVLSEQ FOR THE REST OF THE VOLUMES\n&P.VLLEN EQU   *-&P.VL\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEZCTGWA": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00\\x1f\\x00\\x1f\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 31, "newlines": 31, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         IEZCTGWA &P=CTG\n***********************************************************************\n*                                                                     *\n*  MACRO NAME = IEZCTGWA                                              *\n*                                                                     *\n*  DESCRIPTIVE NAME = CATALOG WORK AREA                               *\n*                                                                     *\n*  FUNCTION = THE CTGWA IS BUILT BY THE CALLER OF CATALOG MANAGEMENT  *\n*             FOR MOST REQUESTS.  THE CTGPL POINTS TO THE CTGWA.      *\n*             THE WORK AREA HAS ONE FORMAT FOR A SUPERLOCATE          *\n*             REQUEST AND ANOTHER FORMAT FOR ALL OTHER REQUESTS.      *\n*                                                                     *\n*  DATE OF LAST CHANGE = 21 FEB 83                                    *\n*                                                                     *\n***********************************************************************\n&P.WA    DSECT ,\n&P.WALNG DS    XL2                      LENGTH OF THE WORK AREA\n* FORMAT FOR A SUPERLOCATE REQUEST\n         ORG   &P.WALNG\n&P.WAVL  DS    A                  ADDRESS OF THE CTGVL (VOLUME LIST)\n&P.WALV  DS    XL2                LENGTH OF THE VOLUME LIST\n&P.WAVCT DS    XL2                NO OF VOLSERS RETURNED IN VSL MINIMUM\n&P.WAUCT DS    XL2                NO OF VOLUMES THAT MUST BE MOUNTED\n* THE FOLLOWING TWO FIELDS ARE FOR A GDG BASE ONLY:\n&P.WAGCT DS    XL2                NO OF GENERATIONS CATALOGED\n*                                 CTGGDGB IN CTGPL IS SET ON (FOR GDGS)\n&P.WAGB  DS    A                  ADDRESS OF 4 BYTE FIELD\n*                                CONTAINING GENERATION LEVEL TO BE USED\n&P.WALEN EQU   *-&P.WA\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IGGCAXWA": {"ttr": 4611, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x12\\x01\\x14\"/\\x01\\x14\"/\\x15\\x15\\x00\\x8c\\x00\\x8c\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2014-08-10T00:00:00", "modifydate": "2014-08-10T15:15:12", "lines": 140, "newlines": 140, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         IGGCAXWA ,\n***********************************************************************\n*                                                                     *\n*  MACRO NAME = IGGCAXWA                                              *\n*                                                                     *\n*  DESCRIPTIVE NAME = CATALOG AUXILIARY WORKAREA                      *\n*                                                                     *\n*  FUNCTION = THE CAXWA IS BUILT WHEN AN OS/VS2 MASTER OR USER        *\n*             CATALOG IS OPENED OR IS BEING CREATED.  THE CAXWA IS    *\n*             USED TO CONTAIN THE ADDRESS OF THE CONTROL BLOCKS AND   *\n*             WORK AREAS NEEDED WHEN A CATALOG SUCH AS THE ALTERNATE  *\n*             TIOT, THE DRWA, AND THE UCB ARE BEING OPENED OR         *\n*             CREATED.  THE CAXWA ALSO CONTAINS FLAGS THAT INDICATE   *\n*             THE TYPE OF PROCESSING BEING PERFORMED ON THE CATALOG   *\n*             AND THE OS/VS COMPONENT THAT INVOKED THE PROCESSING.    *\n*             EACH CAXWA POINTS TO A CATALOG'S ACB.  THE ACB          *\n*             DESCRIBES THE CATALOG AS A KEY-SEQUENCED VSAM DATA SET. *\n*             ALL CAXWAS THAT DESCRIB THE CATALOGS AVAILABLE TO THE   *\n*             USER'S PROGRAM ARE CHAINED TOGETHER.  THE AMCBS         *\n*             (CBSCAXCN) CONTAINS THE ADDRESS OF THE CAXWA CHAIN.     *\n*                                                                     *\n*                                                                     *\n*  CONTROL BLOCK STRUCTURE = THE CAXWA IS POINTED TO BY THE ACB       *\n*             (ACBUAPTR).                                             *\n*                                                                     *\n*  CREATED BY: VSAM CATALOG MANAGEMENT DURING BUILD OR OPEN OF        *\n*              A MASTER OR USER CATALOG.                              *\n*                                                                     *\n*  DATE OF LAST CHANGE = 20 MAY 75                                    *\n*  DATE OF LAST CHANGE = 11 NOV 74                                    *\n*  DATE OF LAST CHANGE = 21 FEB 83                                    *\n*                                                                     *\n***********************************************************************\nIGGCAXWA DSECT\nCAXID    DS    XL1                CONTROL BLOCK IDENTIFIER X\"CA\"\nCAXFLG4  DS    XL1                FLAGS\nCAXF4CSO EQU   B'10000000'        CA SPLIT OCCURRED\nCAXF4CRO EQU   B'01000000'        CONTROL BLOCK REFRESH OCCURED\nCAXF4VFY EQU   B'00100000'        BCS VERIFY (CLAE)\nCAXF4PUT EQU   B'00010000'        BCS PUT (CLEG)\nCAXF4DSC EQU   B'00001000'        CATALOG DISCONNECT\n*        EQU   B'00000111'        RESERVED\n         DS    CL2                RESERVED\nCAXCHN   DS    A                  ADDRESS OF NEXT CAXWA IN THE CHAIN\nCAXFLGS  DS    XL1                FLAGS:\nCAXBLD   EQU   B'10000000'        BUILD REQUEST\nCAXOPN   EQU   B'01000000'        THE CATALOG IS BEING OPENED\nCAXCLS   EQU   B'00100000'        THE CATALOG IS BEING CLOSED\nCAXEOV   EQU   B'00010000'        AN END OF VOLUME IS IN CONTROL\nCAXCMP   EQU   B'00001000'        OPEN/CLOSE/EOF PROCESSING IS COMPLETE\nCAXMCT   EQU   B'00000100'        1-IDENTIFIES AN OS/VS2 MASTER CATALOG\n*                                 0-IDENTIFIES AN OS/VS2 USER CATALOG\nCAXCMR   EQU   B'00000010'        CATALOG MANAGEMENT HAS BEEN CALLED BY\n*                                 ANOTHER CATALOG MANAGEMENT ROUTINE\nCAXSCR   EQU   B'00000001'        1-CATALOG MANAGEMENT (SVC 26) HAS\n*                                 BEEN CALLED BY THE OS/VS SCHEDULER\n*                                 0-CATALOG MANAGEMENT (SVC 26) HAS\n*                                 BEEN CALLED BY AN ACCESS METHOD\n*                                 SERVICES PROCEDURE\nCAXFLG2  DS    XL1                FLAGS:\nCAXF2DT  EQU   B'10000000'        THE CATALOG HAS BEEN DELETED THE\n*                                 FOLLOWING FLAGS ARE SET BY IFG0191X\n*                                 AND IFG0200N:\nCAXF2NDD EQU   B'01000000'        NO DDNAME FOUND\nCAXF2NCR EQU   B'00100000'        UNABLE TO OBTAIN VIRTUAL STORAGE WITH\n*                                 A GETMAIN REQUEST\nCAXF2IOE EQU   B'00010000'        I/O ERROR\nCAXF2CLR EQU   B'00001000'        RPL CLEANUP REQUEST\nCAXF2CA  EQU   B'00000100'        IF AN ERROR OCCURS FREE THE CAXWA\nCAXF2REC EQU   B'00000010'        RECOVERABLE CATALOG\nCAXF2VTU EQU   B'00000001'        VOLUME TIME STAMP UPDATED\nCAXFLG3  DS    XL1                FLAGS:\nCAXF3AT  EQU   B'1000000'         CRA ALTERNATE TIOT EXISTS\nCAXF3ANE EQU   B'0100000'         CRA DOES NOT EXIST\nCAXF3ICF EQU   B'0010000'         ICF TYPE CATALOG\nCAXRAC   EQU   B'0001000'         CATALOG IS RACF-DEFINED\nCAXF3B5  EQU   B'0000110'         NO PASSWORDS\n*              B'....00.'         PASSWORD NOT READ\nCAXF3B6  EQU   B'0000010'         MASTER PASSWORD; NO UPDATE PASSWORD\n*              B'0000100'         MASTER AND UPDATE PASSWORDS\nCAXF3SO4 EQU   B'0000010'         ICF SHARE OPTION 3,4\nCAXF3SHD EQU   B'0000001'         ICF CATALOG ON SHARED DASD\n         DS    CL1                RESERVED (OLD - CAXACT)\nCAXATIOT DS    A                  ADDRESS OF THE ALTERNATE TIOT\nCAXCHWA  DS    A                  ADDRESS OF THE SCHEDULER WORK AREA\nCAXDRWP  DS    0A                 ADDRESS OF THE CATALOG'S DRWA\nCAXVDSPM DS    A                  VVDS PARAMETER LIST FOR CATALOG\nCAXACB   DS    A                  ADDRESS OF THE CATALOG'S ACB\nCAXUCB   DS    A                  ADDRESS OF THE UCB\nCAXCCR   DS    0CL12              CATALOG CONTROL RECORD INFORMATION\nCAXHACI  DS    XL3                CONTROL INTERVAL NUMBER OF THE\n*                                 HIGHEST ALLOCATED CONTROL INTERVAL\n*                                 IN THE CATALOG\nCAXNFCI  DS    XL3                CONTROL INTERVAL NUMBER OF THE NEXT\n*                                 FREE  CONTROL INTERVAL IN THE CATALOG\nCAXCDCI  DS    XL3                NUMBER OF DELETED CONTROL INTERVALS\nCAXFDCI  DS    XL3                CONTROL INTERVAL NUMBER OF THE FIRST\n*                                 DELETED CONTROL INTERVAL IN THE\n*                                 CATALOG\nCAXASID  DS    H                  ASID FOR UCRA ACCESS\nCAXRPLCT DS    H                  NUMBER OF RPLS ASSOCIATED WITH THE\n*                                 CAXWA\nCAXRPL   DS    A                  ADDRESS OF THE FIRST RPL IN THE\n*                                 CAXWA'S RPL CHAIN\nCAXCNAM  DS    0CL44              CATALOG'S DSNAME\nCAXVOLID DS    CL6                CRA VOLUME SERIAL\nCAXRACTS DS    XL4                CRA CREATION TIME STAMP\nCAXRATEP DS    XL4                CRA'S TIOT ENTRY ADDRESS\nCAXRADDN DS    CL8                CRA'S DDNAME\n         DS    CL22               RESERVED FOR CRA\nCAXOPLST DS    0F                 OPEN/CLOSE PARAMETER LIST:\nCOPTS    DS    X                  OPTION FLAGS:\nCENLST   EQU   B'10000000'        END OF LIST INDICATOR\n*        EQU   B'01111111'        RESERVED\nCOPACB   DS    AL3                ADDRESS OF THE CATALOG'S ACB\nCAXOPEWA DS    A                  ADDRESS OF THE OPEN/CLOSE/EOV WORK\n*                                 AREA\nCAXCCA   DS    0A                 ADDRESS OF THE CCA\nCAXPLOCK DS    A                  REPL POST LOCK\nCAXJDE   DS    A                  ADDRESS OF THE JDE\nCAXCRACB DS    A                  ADDRESS OF CRA'S ACB\nCAXRACP  DS    A                  ADDRESS OF RAC PROFILE\nCAXECB   DS    0F                 RPL WAIT ECB\nCAXECBHB DS    B                  RPL WAIT ECB BYTE 1\nCAXECBWB EQU   B'10000000'        WAIT BIT\nCAXECBPB EQU   B'01000000'        POST BIT\n*        EQU   B'00111111'        RESERVED\n         DS    XL3                RESERVED\nCAXASCBP DS    A                  ADDRESS OF THE ASCB\nCAXHRPLW DS    0A                 HUNG RPL WORD\nCAXHRPLC DS    H                  HUNG-UP RPL COUNT\nCAXWNQID DS    H                  RPL WAIT ENQ ID\nCAXLRECL DS    0A                 MAXIMUM ICF CATALOG RECORD SIZE\nCAXSRATS DS    0XL8               ICF TIMESTAMP\nCAXTMSTP DS    XL8                CATALOG CREATION TIMESTAMP\nCAXACT   DS    XL2                CATALOG ACTIVITY COUNT\n         DS    CL14               RESERVED\nCAXLENTH EQU   *-IGGCAXWA         LENGTH OF CAXWA CONTROL BLOCK\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IGGCCA": {"ttr": 2306, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x03\\xf1\\x03\\xf1\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 1009, "newlines": 1009, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         IGGCCA ,\n***********************************************************************\n*                                                                     *\n*     MACRO NAME = IGGCCA                                             *\n*                                                                     *\n*     DESCRIPTIVE NAME = CATALOG COMMUNICATIONS AREA                  *\n*                                                                     *\n*     FUNCTION = THE CCA IS USED BY CATALOG MANAGEMENT TO PASS        *\n*                INFORMATION BETWEEN ITS PROCEDURES.  THE CCA IS      *\n*                BUILT EACH TIME AN OS/VS COMPONENT ISSUES THE CATLG  *\n*                MACRO INSTRUCTION (SVC 26) TO PROCESS A CATALOG      *\n*                RECORD.  THE CCA CONTAINS INFORMATION ABOUT THE      *\n*                CATALOG BEING PROCESSED, AND ABOUT THE CATALOG       *\n*                RECORD AND ITS EXTENSIONS CONTAINED IN EACH OF       *\n*                THE SIX BUFFERS AVAILABLE TO PROCESS THE USER'S      *\n*                REQUEST.                                             *\n*                                                                     *\n*     CONTROL BLOCK STRUCTURE = THE CCA IS POINTED TO BY REGISTER 11  *\n*                                                                     *\n*     INCLUDED MACROS = NONE                                          *\n*                                                                     *\n***********************************************************************\n\nIGGCCA   DSECT ,                    SET BASE TO CCA\nCCAID    DS    XL2                  CCA     ID = 'ACCA'X\nCCASZ    DS    XL2                  SIZE OF CCA\nCCAPROB  DS    0XL4                 PROBLEM DETERMINATION WORD\n*\nCCAMODID DS    CL2                  ERROR MODULE ID\nCCAERRCD DS    0XL2                 ERROR CODES\nCCAREASN DS    0XL1                 SET REASON CODE\nCCACDR   DS    XL1                  REFER REASON CODE\nCCARETRN DS    0XL1                 SET RETURN CODE\nCCACD1   DS    XL1                  REFER REASON CODE\nCCAID2   DS    CL3                  ID=CCA\nCCARACP  DS    XL1                  RAC CHECKED FIELD\n*        DS    XL1                     RESERVED\nCCAFLG0  DS    XL1                  FLAGS\nCCAF0SEQ EQU   B'10000000'          SEQUENTIAL I/O\nCCAF0NSP EQU   B'01000000'          NOTE STRING POSITION\n*        EQU   B'00111111'          RESERVED\nCCACD2   DS    XL1                  RETURN CODE 2\nCCAFLG1  DS    XL1                  FLAGS\nCCAF1LPS EQU   B'10000000'          STOP LOOP IF ON\nCCAF1CNS EQU   B'01000000'          CATALOG NAME SEARCH\nCCAF1LRD EQU   B'00100000'          CCR READ INTO CORE\nCCAF1KEY EQU   B'00010000'          GET BY TRUE NAME\nCCAF1KGE EQU   B'00001000'          GET NEXT\nCCAF1CR  EQU   B'00000100'          CHKPT CCR REQ\nCCAF1UP  EQU   B'00000010'          GET FOR UPDATE\nCCAF1DK  EQU   B'00000001'          DELETE, KEEP CI\nCCAFLG2  DS    XL1                  FLAGS\nCCAF2SYS EQU   B'10000000'          SYSTEM CALLER\nCCAF2NVC EQU   B'01000000'          NO VALIDITY CHECK\nCCAF2CCT EQU   B'00100000'          0 = CONCAT CTLG SEARCH\n*                                   1 = SINGLE CTLG SEARCH\nCCAF2XEQ EQU   B'00010000'          0 = SHARED ENQ,\n*                                   1 = EXCLUSIVE ENQ\nCCAF2RHS EQU   B'00001000'          RECURSIVE CALL TO CATLG\nCCAF2COB EQU   B'00000110'          COMB. OF CATLG OPEN/BUILD\nCCAF2CO  EQU   B'00000100'          CATLG BEING OPENED\nCCAF2CB  EQU   B'00000010'          CATLG OPEN DURING BUILD\nCCAF2SMO EQU   B'00000001'          SEARCH MASTER CATLG ONLY\nCCAFLG3  DS    XL1                  FLAGS\nCCAEXGR1 EQU   B'10000000'          EXIT INDICATOR\nCCAGC4   EQU   B'01000000'          GROUP CODE 4 IN SCNC\nCCAGDSP  EQU   B'00100000'          GENDSP\nCCAEXGR2 EQU   B'00010000'          EXIT INDICATOR\nCCANF    EQU   B'00001000'          NOT FOUND CONDITION\nCCAELC2  EQU   B'00000100'          EXIT INDICATOR\nCCALFT   EQU   B'00000010'          FIRST TIME\nCCAEGREC EQU   B'00000001'          EXIT INDICATOR\nCCAFLG4  DS    XL1                  FLAGS\nCCAF4DRQ EQU   B'10000000'          DEQ REQD\nCCAF4BYS EQU   B'01000000'          BYPASS SECURITY\nCCAGVNC  EQU   B'00100000'          NOT COMPLETE\nCCAGVNF  EQU   B'00010000'          RELREPNO NOT FOUND\nCCAFVNBS EQU   B'00001000'          NO BUFFER SPACE\nCCAGVEX  EQU   B'00000100'          EXIT BIT\nCCAGVNE  EQU   B'00000010'          NON-EXISTENT FIELD\nCCATCOMP EQU   B'00000001'          TEST COMPLETE\nCCAFLG5  DS    XL1                  FLAGS\nCCAMEX2  EQU   B'10000000'          EXIT INDICATOR\nCCAMEX   EQU   B'01000000'          EXIT BIT\nCCAMEX1  EQU   B'00100000'          EXIT BIT\nCCAMODPA EQU   B'00010000'          PUT-ADD\nCCATHIT  EQU   B'00001000'          SUCCESSFUL TEST\nCCATEX   EQU   B'00000100'          EXIT INDICATOR\nCCATEX1  EQU   B'00000010'          EXIT INDICATOR\nCCATEX2  EQU   B'00000001'          EXIT INDICATOR\nCCAFLG6  DS    XL1                  FLAGS\nCCAMCODR EQU   B'10000000'          DEQ REQ SW\nCCADELP  EQU   B'01000000'          DELETED GOP\nCCAMNOSP EQU   B'00100000'          NO SPACE IN MOVE OCCUR\nCCAINIT  EQU   B'00010000'          INSERT INIT SW FOR VAR FIELD\nCCASUPFD EQU   B'00001000'          SUPPRESS FIELD INFO\nCCAREUSE EQU   B'00000100'          RE-USE RECORD AREAS\nCCAEXT   EQU   B'00000010'          EXTRACT IN PROCESS\nCCAMOD   EQU   B'00000001'          MODIFY IN PROCESS\nCCATCB   DS    0A                   PTR TO TCB\nCCALBCYL DS    A                    LABEL CYLINDER DATA PTR\nCCARB    DS    0A                   PTR TO RB\nCCADPL   DS    A                    DADSM PARAMETER LIST PTR\nCCACPL   DS    A                    PTR TO CPL\nCCAACB   DS    A                    PTR TO CATALOG ACB\nCCANPCCB DS    A                    PTR TO NEXT PCCB IN CHAIN\nCCAURAB  DS    A                    PTR TO RAB IN USE\nCCASRCH2 DS    0CL45                ICF SEARCH ARGUMENT\nCCASRCH  DS    0CL44                SEARCH ARGUMENT\nCCASRCHM DS    0CL44                SIGNIFICANT KEY\nCCASRVVD DS    0CL11                \"SYS1.VVDS.V\" NAME PART\nCCASRID  DS    0XL3                 CI NUMBER\nCCASRID2 DS    0XL3                 TOKEN CI NUMBER\nCCASRCIN DS    0XL3                 CI NUMBER\nCCASRCI2 DS    XL3                  TOKEN CI\n         DS    XL8                  RESERVED\nCCASRVVV DS    XL6                  VVDS VOLUME SERIAL\nCCASRVVP DS    XL27                 REMAINDER OF VVDS KEY\nCCASRCHP DS    XL1                  PAD CHARACTER\nCCAFLG13 DS    XL1                  FLAG 13 BYTE\nCCAUDVVR EQU   B'10000000'          UPDATE CATALOG DATA VVR\n*\nCCAUIVVR EQU   B'01000000'          UPDATA CATALOG INDEX VVR\n*\nCCAUSVVR EQU   B'00100000'          UPDATE CATALOG SEQUENCE SET VVR\n*\nCCADQCAT EQU   B'00010000'          REMEMBER SYSIGGV2 ENQ\nCCAGDGDL EQU   B'00001000'          DELETE NONVSAM GDG\nCCASVTNE EQU   B'00000100'          SAVE TRUE NAME BIT\nCCADLNVS EQU   B'00000010'          NONVSAM SCRATCH ERR\nCCANODMP EQU   B'00000001'          PREVENT DUMP\n         DS    XL2                  RESERVED\nCCARAB0  DS    0CL20                RECORD AREA BLOCK 0\nCCAR0FLG DS    XL1                  CCARAB0 FLAGS\nCCAR0UR  EQU   B'10000000'          RAB IN-USE EXT, MOD\nCCAR0U1  EQU   B'01000000'          RAB IN-USE TESTS\nCCAR0U2  EQU   B'00100000'          RAM IN-USE TESTS\nCCAR0WR  EQU   B'00010000'          WRITE IT BEFORE READ\nCCAR0PA  EQU   B'00001000'          PUT-ADD WRITE\n*        EQU   B'00000110'          RESERVED\nCCAR0UPD EQU   B'00000001'          UPDATE BUFFER NOT REUSED\nCCAR0RPL DS    XL1                  LAST ASSIGN, RPL INDEX\n         DS    XL2                  RESERVED\nCCAR0REC DS    A                    PTR TO RECORD AREA\nCCAR0SEG DS    0CL12                SEGMENT PTRS\nCCACPE20 DS    A                    PTR REPEATING CONTROL INFO\nCCACPE30 DS    A                    PTR TO FIRST OCCURRENCE\nCCACPE40 DS    A                    PTR TO END OF RECORD\nCCARAB1  DS    0CL20                RECORD AREA BLOCK 1\nCCAR1FLG DS    XL1                  FLAGS\nCCAR1UR  EQU   B'10000000'          SAME AS CCAR0UR\nCCAR1U1  EQU   B'01000000'          SAME AS CCAR0U1\nCCAR1U2  EQU   B'00100000'          SAME AS CCAR0U2\nCCAR1WR  EQU   B'00010000'          SAME AS CCAR0WR\nCCAR1PA  EQU   B'00001000'          SAME AS CCAR0PA\n*        EQU   B'00000110'          RESERVED\nCCAR1UPD EQU   B'00000001'          SAME AS CCAR0UPD\nCCAR1RPL DS    XL1                  SAME AS CCAR0RPL\n         DS    XL2                  RESERVED\nCCAR1REC DS    A                    SAME AS CCAR0REC\nCCAR1SEG DS    0CL12                SAME AS CCAR0SEG\nCCACPE21 DS    A                    SAME AS CCACPE20\nCCACPE31 DS    A                    SAME AS CCACPE30\nCCACPE41 DS    A                    SAME AS CCACPE40\nCCARAB2  DS    0CL20                RECORD AREA BLOCK 2\nCCAR2FLG DS    XL1                  FLAGS\nCCAR2UR  EQU   B'10000000'          SAME AS CCAR0UR\nCCAR2U1  EQU   B'01000000'          SAME AS CCAR0U1\nCCAR2U2  EQU   B'00100000'          SAME AS CCAR0U2\nCCAR2WR  EQU   B'00010000'          SAME AS CCAR0WR\nCCAR2PA  EQU   B'00001000'          SAME AS CCAR0PA\n*        EQU   B'00000110'          RESERVED\nCCAR2UPD EQU   B'00000001'          SAME AS CCAR0UPD\nCCAR2RPL DS    XL1                  SAME AS CCAR0RPL\n         DS    XL2                  RESERVED\nCCAR2REC DS    A                    SAME AS CCAR0REC\nCCAR2SEG DS    0CL12                SAME AS CCAR0SEG\nCCACPE22 DS    A                    SAME AS CCACPE20\nCCACPE32 DS    A                    SAME AS CCACPE30\nCCACPE42 DS    A                    SAME AS CCACPE40\nCCARAB3  DS    0CL20                RECORD AREA BLOCK 3\nCCAR3FLG DS    XL1                  FLAGS\nCCAR3UR  EQU   B'10000000'          SAME AS CCAR0UR\nCCAR3U1  EQU   B'01000000'          SAME AS CCAR0U1\nCCAR3U2  EQU   B'00100000'          SAME AS CCAR0U2\nCCAR3WR  EQU   B'00010000'          SAME AS CCAR0WR\nCCAR3PA  EQU   B'00001000'          SAME AS CCAR0PA\n*        EQU   B'00000110'          RESERVED\nCCAR3UPD EQU   B'00000001'          SAME AS CCAR0UPD\nCCAR3RPL DS    XL1                  SAME AS CCAR0RPL\n         DS    XL2                  RESERVED\nCCAR3REC DS    A                    SAME AS CCAR0REC\nCCAR3SEG DS    0CL12                SAME AS CCAR0SEG\nCCACPE23 DS    A                    SAME AS CCACPE20\nCCACPE33 DS    A                    SAME AS CCACPE30\nCCACPE43 DS    A                    SAME AS CCACPE40\nCCARAB4  DS    0CL20                RECORD AREA BLOCK 4\nCCAR4FLG DS    XL1                  FLAGS\nCCAR4UR  EQU   B'10000000'          SAME AS CCAR0UR\nCCAR4U1  EQU   B'01000000'          SAME AS CCAR0U1\nCCAR4U2  EQU   B'00100000'          SAME AS CCAR0U2\nCCAR4WR  EQU   B'00010000'          SAME AS CCAR0WR\nCCAR4PA  EQU   B'00001000'          SAME AS CCAR0PA\n*        EQU   B'00000110'          RESERVED\nCCAR4UPD EQU   B'00000001'          SAME AS CCAR0UPD\nCCAR4RPL DS    XL1                  SAME AS CCAR0RPL\n         DS    XL2                  RESERVED\nCCAR4REC DS    A                    SAME AS CCAR0REC\nCCAR4SEG DS    0CL12                SAME AS CCAR0SEG\nCCACPE24 DS    A                    SAME AS CCACPE20\nCCACPE34 DS    A                    SAME AS CCACPE30\nCCACPE44 DS    A                    SAME AS CCACPE40\nCCARAB5  DS    0CL20                RECORD AREA BLOCK 5\nCCAR5FLG DS    XL1                  FLAGS\nCCAR5UR  EQU   B'10000000'          SAME AS CCAR0UR\nCCAR5U1  EQU   B'01000000'          SAME AS CCAR0U1\nCCAR5U2  EQU   B'00100000'          SAME AS CCAR0U2\nCCAR5WR  EQU   B'00010000'          SAME AS CCAR0WR\nCCAR5PA  EQU   B'00001000'          SAME AS CCAR0PA\n*        EQU   B'00000110'          RESERVED\nCCAR5UPD EQU   B'00000001'          SAME AS CCAR0UPD\nCCAR5RPL DS    XL1                  SAME AS CCAR0RPL\n         DS    XL2                  RESERVED\nCCAR5REC DS    A                    SAME AS CCAR0REC\nCCAR5SEG DS    0CL12                SAME AS CCAR0SEG\nCCACPE25 DS    A                    SAME AS CCACPE20\nCCACPE35 DS    A                    SAME AS CCACPE30\nCCACPE45 DS    A                    SAME AS CCACPE40\nCCARPLK  DS    XL1                  ASSIGNED RPL COUNT\nCCARPLF  DS    XL1                  INDEX TO FOUND RPL\nCCARPLX  DS    XL1                  WORK BYTE FOR SUBFUNCTION\n*                                   IGGPRPLM\nCCARPLT  DS    XL1                  WORK BYTE FOR SUBFUNCTION\n*                                   IGGPRPLM\nCCATIQRN DS    0XL6                 TIOT ENQ MINOR NAME\nCCATASID DS    XL2                  ASID\nCCATQDB  DS    XL4                  QDB ADDRESS\nCCASC    DS    XL1                  SEARCH CODE\nCCAQLEN  DS    XL1                  QUALIFIER LENGTH | 0\nCCARPL1  DS    A                    PTR TO RPL IN USE\nCCADESA  DS    0CL44                DADSM EXTENTS SAVEAREA\nCCANDEXT DS    XL1                  COUNT OF EXTENTS\nCCAIXEXT DS    XL1                  EXTENT INDEX VALUE\nCCASSVOL DS    XL2                  DATA SET DIR SEQ NO.\nCCAEXTDE DS    0CL40                EXTENTS DESCRIPTORS\nCCAEXTSS DS    XL2                  DESCRIPTOR SPACE SEQ. NO.\nCCAEXTAD DS    0XL4                 EXTENT STARTING CCHH\nCCAEXTCC DS    XL2                  STARTING CYLINDER\nCCAEXTHH DS    XL2                  STARTING TRACK\nCCAEXTTH DS    XL2                  # TRACKS IN EXT\n         DS    XL32\nCCAASCIK DS    XL1                  COUNT OF CI'S REQD\nCCACRRP  DS    XL1                  RPL USED TO READ CCR\nCCAASCIX DS    XL1                  ASSIGNED CI ARRAY INDEX\nCCAASCI  DS    XL9                  ASSIGNED CI NUMBERS\nCCAEQDQ  DS    0CL16                ENQ/DEQ PARAMETER LIST\nCCAEDXFF DS    XL1                  END OF PL IND BYTE\nCCAEDRLN DS    XL1                  LENGTH OF MINOR NAME\nCCAEDOPT DS    XL1                  ENQ-DEQ OPTIONS\nCCAEDSHR EQU   B'10000000'          1=SHARED, 0=EXCLUSIVE\n*              B'01111111'          OTHER OPT. (SET BY MACRO)\nCCAEDRCD DS    XL1                  ENQ/DEQ RETURN CODE\nCCAEDQNM DS    A                    MAJOR NAME PTR\nCCAEDRNM DS    A                    MINOR NAME PTR\nCCAEDUCB DS    A                    UCB PTR\nCCAMLRET DS    A                    MAIN LINE RTN SAVE AREA PTR\nCCAMSSPL DS    0CL12                STORAGE MGMT WORKAREA\nCCAMNLLP DS    XL4                  LENGTH OF LIST POINTER\nCCAMNPTR DS    A                    ADDRESS OF THE RETURN ADDRESS\n         DS    XL1                  STORAGE MANAGEMENT BYTE\nCCAMNSPL DS    XL1                  REQUIRED SUBPOOL\n         DS    XL2                  STORAGE MANAGEMENT AREA\nCCARPRM  DS    A                    RETURN PARMS\nCCACMS   DS    0CL8                 CMS AREA\nCCACMSWA DS    A                    PTR TO CMS WORK AREA\nCCAEXCMS DS    A                    SECONDARY CMS WORK AREA ADDR\nCCALUME  EQU   *                    START OF FIELD MGMT WORK AREA\n*                                   AND INTERFACE VARIABLES FOR\n*                                   LOCATE, UPDATE, MODIFY, AND\n*                                   EXTRACT ROUTINES\nCCACPE5  DS    A                    ADDR OF OCCURRENCE PTR\nCCACPE51 DS    A                    ALTERNATE PTR TO GOP\nCCACPE52 DS    A                    ALT GOP PTR\nCCACPE53 DS    A                    ALT GOP PTR\nCCACPE6  DS    A                    ADDR OF OCCURRENCE\nCCACPE61 DS    0A                   ALT PTR TO OCCURRENCE\nCCARABSE DS    A                    SAVE EXTRACT CALLER URAB\nCCACPE7  DS    0A                   ADDR OF FIELD VALUE\nCCAIDPT  DS    A                    INSERT DATA ADDR\nCCACPE71 DS    A                    ALT PTR TO FIELD VALUE\nCCAGOPLN DS    XL2                  GROUP OCCURRENCE PTR LENGTH\nCCASL    DS    XL2                  SEQUENCE NUMBER LENGTH\nCCAILNG  DS    XL4                  INSERT LENGTH\nCCAFLPT  DS    0A                   FIELD LIST POINTER\nCCATFLPT DS    A                    FIELD LIST PTR FOR TESTS\nCCARABPT DS    A                    RAB PTR\nCCADICT  DS    CL4                  DICTIONARY INFO\nCCAXCPL  DS    0A                   EXTRACT CPL PTR\nCCAMCPL  DS    A                    MODIFY CPL PTR\nCCARABB  DS    A                    BASE RAB PTR\nCCARABF  DS    A                    FIRST RAB PTR\nCCARABL  DS    A                    LAST RAB PTR\nCCACBASE DS    XL3                  BASE CI NUMBER\nCCAGC    DS    XL1                  GROUP CODE\nCCALREL  DS    0XL2                 LOGICAL RELREPNO\nCCALREL1 DS    XL2                  LOGICAL RELREPNO\nCCASN    DS    0XL2                 SEQUENCE NO.\nCCASN1   DS    XL2                  SEQUENCE NO.\nCCAUSKEY DS    XL1                  USER KEY\nCCAMSFLG DS    XL1                  MISC. FLAGS\nCCACICIN EQU   B'10000000'          INTEGRITY CHECK\n*                                   INCOMPLETE\nCCACPLOK EQU   B'01000000'          CPL IS VALID\nCCASKYSS EQU   B'00100000'          CALLER HAS SYSTEM KEY\n*                                   OR IS IN SUPERVISOR\n*                                   SUPERVISOR STATE\nCCAGDGUY EQU   B'00010000'          AUTHORIZED CALLER\nCCANCIPT EQU   B'00001000'          NEW CIPT BUILT\nCCACISOP EQU   B'00000100'          CIS OPTION.\n*                                        0 - GET TOKEN NAME\n*                                        1 - GET CI TOKEN\nCCACIABK EQU   B'00000010'          CIS ABREVIATED KEY\nCCACIGVN EQU   B'00000001'          CI NAME GIVEN\nCCAIXFPL DS    XL2                  FIELD ARAY INDEX\nCCAIXREL DS    XL2                  INDEX RELREPNO\nCCATNREL DS    XL2                  NEXT RELREPNO\nCCATNUM  DS    XL2                  NO. OF SUCCESSFUL RELREPNOS\nCCATREL  DS    CL32                 SUCCESSFUL REL REPNOS\nCCATNO   DS    XL2                  TOTAL NO. SUCCESSFUL RELREPNOS\nCCATEST  DS    A                    TEST FIELD PTR\nCCARBA   DS    0CL20                EXTENT HOLDER FIELD\nCCACRAVL DS    0CL6                 CRA VOLSER\nCCASS    DS    XL2                  SPACE DESCRIPTOR\n*                                   SEQUENCE NO.\nCCACCHH1 DS    XL4                  CCHH-LOW\nCCACRADT DS    0XL4                 CRA DEVICE TYPE\nCCACCHH2 DS    XL4                  CCHH-HIGH\nCCATT    DS    XL2                  TT-NO. TRACKS\nCCARBA1  DS    XL4                  RBA-LOW\nCCARBA2  DS    XL4                  RBA-HIGH\nCCATLNG  DS    0XL2                 TESTED EXTENT LENGTH\nCCATLEN  DS    XL2                  MODIFIED VAR LENGTH\nCCARBAL  DS    XL2                  RBA EXTENT BALANCE\nCCACNIX  DS    XL2                  COMBINATION NAME INDEX\nCCASMFIX DS    XL2                  DEFINE CATALOG SMF INDEX\nCCAIDPT2 DS    A                    AVAILABLE SPACE IN WORK AREA\nCCAIDPT3 DS    0A                   INCOMPLETE VAR FIELDS\nCCARABSM DS    A                    SAVE MODIFY CALLER URAB\nCCAGVCT  DS    XL2                  COUNTER\nCCANEVV  DS    XL2                  NON-EXISTENT VARIABLE\n*                                   VALUE LENGTH\nCCAGVEXT DS    XL3                  EXTENSION RCD POINTER\nCCANEFV  DS    XL1                  NON-EXISTENT FIXED FALUE\nCCASAVID DS    XL1                  SAVE RECORD ID\nCCAGRGC  DS    0XL1                 GROUP CODE\nCCARCDID DS    XL1                  RECORD ID\nCCAGRHI  DS    0XL2                 HIGH RELREPNO\nCCASSEQ  DS    0XL2                 SAVE SEQ. NO.\nCCAGRHI1 DS    XL2                  HIGH RELREPNO\nCCAIXTPL DS    XL2                  INDEX TO TEST FPL\nCCADLEN  DS    XL2                  MODIFY DELETE LENGTH\nCCADIFF  DS    XL2                  SPACE DIFFERENCE\nCCAREPCT DS    XL2                  RELREPNO COUNT\nCCADISP  DS    XL2                  DISPLACEMENT INTO VAR FIELD\nCCASVCI  DS    XL3                  SAVE CI OF BASE\nCCASVCI1 DS    XL3                  SAVE SPACE CI\nCCADTA   DS    A                    DICTIONARY PTR\nCCACDTA  DS    A                    INDEX COMBO TABLE PTR\nCCADTCT  DS    XL2                  COUNT DICT ENTRIES\nCCACDTCT DS    XL2                  COUNT INDEX COMB TABLE\nCCACWAP  DS    A                    CONTROLLER WORK AREA\nCCASDWAP DS    A                    POINTER TO SDWA\nCCAILNG3 DS    A                    MODIFY LENGTH\nCCAILNG2 DS    A                    MODIFY LENGTH\nCCAALPTR DS    A                    SPACE MNGMT SUB-FUNCTION WA\nCCASMFPT DS    A                    SMF DATA PTR\nCCALCPL  DS    A                    LSPACE CPL PTR - INTERNAL CALL\nCCAFLG7  DS    XL1                  FLAGS\nCCALSP   EQU   B'10000000'          LSPACE INTERNAL CALL\nCCASMFEX EQU   B'01000000'          SMF EXIT INDICATOR\nCCASMFA  EQU   B'00100000'          DO SMF IN MODIFY\nCCASMFBR EQU   B'00010000'          DO GET FOR BASE RECORD\nCCAONCE  EQU   B'00001000'          MOVE ONLY ONE OCCURRENCE\nCCAROREQ EQU   B'00000100'          READ-ONLY REQUEST\nCCAFEOV  EQU   B'00000010'          FORCE EOV\nCCACRABU EQU   B'00000001'          CRA BEING BUILT\nCCAFLG8  DS    XL1                  FLAGS\nCCADSRCL EQU   B'10000000'          DEFINE SPACE\n*                                        RECURSIVE CALL\nCCAVBUFI EQU   B'01000000'          VOL RECORDS BUFFERED\nCCASCRA  EQU   B'00100000'          SUPRESS CRA UPDATES\nCCASCICK EQU   B'00010000'          SUPPRESS CRA CI CHECK\nCCALPIND EQU   B'00001000'          LOOP CONTROL IN BUFFER\n*                                        SCAN FOR GETS\nCCAVRIND EQU   B'00000100'          VOLUME RECORD BUFFER CHAIN\n*                                        TO BE CHECKED\nCCALEOD  EQU   B'00000010'          EOF ON LOW KEYS\nCCAAUCAT EQU   B'00000001'          VOLUME HAS UCAT\nCCAFLG9  DS    XL1                  FLAGS\nCCARABYC EQU   B'10000000'          BYPASS CAT I/O\nCCARAEOV EQU   B'01000000'          CRA EOV\nCCARALRD EQU   B'00100000'          CRA CCR HAS BEEN READ\nCCARACR  EQU   B'00010000'          CRA CCR CHK PT REQD\nCCAUCRA  EQU   B'00001000'          USE UCRA TRANS TAB\nCCARAACT EQU   B'00000100'          CRA ACTIVE\nCCARAICI EQU   B'00000010'          INHIBIT CAT I/O\nCCARESUM EQU   B'00000001'          ON = REPLACE SUM,ELSE\n*                                   OFF = INCREMENT SUM\nCCANORBA DS    XL1                  NO. OF RBA'S THAT ARE\n*                                   NEEDED IN CB STRT\nCCASMFRD DS    A                    SMF RECORD POINTER\nCCASMFCT DS    XL2                  COUNT OF SMF RECORDS\nCCASMFLG DS    0XL2                 SMF RECORD FLAGS\nCCASMFG1 DS    XL1                  SMF FLAGS\nCCASMFUC EQU   B'10000000'          UNCATALOG - SMF RCD 67\n*                                   (ALWAYS SET ON)\nCCASMFDF EQU   B'10000000'          DEFINE - SMF RCD 63\nCCASMFSR EQU   B'01000000'          SCRATCH - SMF RCD 67. SET ON\n*                                   ONLY IF RECORD ID IS D, I OR A\nCCASMFAL EQU   B'01000000'          ALTER - SMF RCD 63\n*              B'00111111'          RESERVED\nCCASMFG2 DS    XL1                  SMF FLAGS FOR ICF\nCCASMFVV EQU   B'10000000'          SMF CALLED BY VVDS MANAGER\nCCASMFIN EQU   B'01000000'          VVR INSERTED\nCCASMFDE EQU   B'00100000'          VVR DELETED\nCCASMFUP EQU   B'00010000'          VVR UPDATED\nCCASMFBY EQU   B'00001000'          BYPASS SMF WRITE IF SHARED\n*                                   CATALOG VVRCFVFY CHANGE ONLY\n*              B'00000111'          RESERVED\nCCASMFLN DS    XL2                  SMF RECORD LENGTH\nCCACHAIN DS    XL3                  CHAIN CI NO. - START OF VOLUME\n*                                   ENTRY TRANSLATION WORKAREA\nCCACI1   DS    XL3                  SAVE CI AREA\nCCACI2   DS    XL3                  SAVE CI AREA\nCCACI3   DS    XL3                  SAVE CI AREA\nCCAVARLN DS    XL2                  INSERT LENGTH\nCCARRAB  DS    A                    RELATIVE BASE RAB ADDR\nCCARBASE DS    A                    RELATIVE BASE RAB ADDR\nCCAVARPT DS    A                    POINTER TO INSERT INFO\nCCADELN  DS    XL2                  DELETE LENGTH\nCCAVAR   DS    CL20                 INSERT INFO SAVE AREA\nCCAVAR1  DS    CL20                 INSERT INFO SAVE AREA\nCCADEL1  DS    XL3                  START DELETE CI\nCCADEL2  DS    XL3                  END DELETE CI\nCCAXLATE DS    CL40                 TRANSLATION WORK AREA\nCCAR14S  DS    XL4                  CLC9 REG 14 SAVE AREA\nCCABMINP DS    0CL8                 INPUT PARAMETERS\nCCABMTRK DS    XL2                  STARTING TRACK\nCCABMLIM DS    XL2                  CHECK LIMIT, NN FOR\nCCABMMIN DS    XL2                  COND CHECK MINIMUM\nCCABMFLG DS    XL1                  STATE AND FUNCTION CODE\nCCABMST  EQU   B'10000000'          STATE TO SET/COND. CHECK\nCCABMCHK EQU   B'01000000'          ON = PERFORM CHECK\nCCABMSET EQU   B'00100000'          ON = PERFORM SET\nCCABMCCK EQU   B'00010000'          ON = PERFORM COND. CHECK\nCCABMLST EQU   B'00001000'          ON = LAST SET REQ (WRITE)\n*              B'00000111'          RESERVED\n         DS    XL1                  RESERVED\nCCABMOUT DS    0CL5                 OUTPUT PARAMETERS\nCCABMONN DS    XL2                  TRK NUMBER (CK/COND)\nCCABMOTR DS    XL2                  STARTING TRK(CONDCHK.)\nCCABMOFG DS    XL1                  OUTPUT FLAGS\nCCABMOST EQU   B'10000000'          STATE OF BITS (CHECK)\n*              B'01111111'          RESERVED\nCCASMFS2 DS    XL1                  SMFG2 SAVE FOR VVR WRITE\n         DS    CL1                  RESRVED\nCCABMPAD DS    CL1                  PADDING CHARACTER\nCCABMGOP DS    A                    CURRENT BIT MASK GOP\nCCABMPTR DS    A                    CURRENT BIT MASK BYTE\nCCABMEND DS    A                    END OF CURRENT BIT MASK\nCCABMBT1 DS    XL2                  BIT COUNT FIRST BYTE\nCCABMBTL DS    XL2                  BIT COUNT LAST BYTE\nCCABMBYT DS    XL2                  NUMBER OF FULL BYTES\nCCABMSTR DS    XL2                  BIT MASK START. TRACK\nCCABMWK1 DS    A                    WORK FIELD\nCCABMWK2 DS    A                    WORK FIELD\nCCABMWK3 DS    A                    WORK FIELD\nCCABMWK4 DS    A                    WORK FIELD\nCCABMRB1 DS    A                    FIRST BIT MAP RAB PTR\nCCABMRB2 DS    A                    SECOND RAB POINTER\nCCATEMPS DS    CL40                 PL/S TEMP AREA\nCCAMNCAT DS    0CL256               CONTIGUOUS AREA FOR\n*                                   TRACKING\nCCAMNAT  DS    0CL248               TRACKING BUFFER\nMNATTOP  DS    XL1                  TOP ENTRY 1ST BYTE\nMNATFULL EQU   B'10000000'          BUFFER FULL\n*              B'01111111'          RESERVED\n         DS    CL239                BODY OF BUFFER\nMNATFLGS DS    XL1                  MOST RECENT ENTRY-1ST BYTE\n*\nMNATVAL  EQU   B'10000000'          VALID ENTRY BIT\n*              B'01100000'          RESERVED\nMNATFCLS EQU   B'00010000'          CLASS 'F' CORE IF OFF\n*              B'00001110'          RESERVED\nMNATSCLS EQU   B'00000001'          CLASS 'S' CORE\nMNATARG1 DS    XL3                  REMAINDER OF 1ST WD\n*\nMNATARG2 DS    A                    MOST RECENT ENTRY-2ND WD\n*\nCCAMNLL  DS    XL1                  G/F MAIN LEN LIST-EOL BYTE\n*\nCCAMNLEN DS    XL3                  G/F MAIN LENGTH\nCCAMNADR DS    A                    G/F MAIN ADDRESS\nCCAARFWA DS    0CL16                SPILL RTN WORK AREA\nARFGMLEN DS    0XL4                 LEN LIST FOR GETMAIN\nARFGMLP  DS    XL1                  END-OF-LIST BYTE\nARFLEN   DS    XL3                  LENGTH\nARFGMADR DS    A                    ADDRESS FOR GETMAIN\nARFSBSCH DS    A                    PTR TO 1ST SPILL BLOCK\nARFSBECH DS    A                    PTR TO LAST SPILL BLOCK\nCCARVFG1 DS    XL1                  RECOVERY FLAGS\nRVCCAV   EQU   B'10000000'          CCA VALID\nRVARFI   EQU   B'01000000'          TRACKING DATA INCOMPLETE\n*\nRVCMSFG  EQU   B'00100000'          CMS FUNCTION CATE\nRVESBO   EQU   B'00010000'          ESTAE BACKOUT IN CONTROL\n*\nRVESBOR  EQU   B'00001000'          ESTAE BACKOUT REGISTER\nRVRPLMFG EQU   B'00000100'          /*RPL MGMT FUNCTION GATE\nRVWG     EQU   B'00000010'          RECOVERY WAIT GATE\nWTOROUT  EQU   B'00000001'          WTOR OUTSTANDING\nCCAFLG12 DS    XL1                  CCA FLAG 12 BYTE\nCCANOPRC EQU   B'10000000'          NO PASSED RECORD\nCCARVVR  EQU   B'01000000'          READ VVR INDICATER\nCCAVDSBE EQU   B'00100000'          VVR BUFFER TOO SMALL\nCCACSLPS EQU   B'00010000'          CIS LOOP STOPPED\nCCAVVRSS EQU   B'00010000'          VVR SEARCH STOPPED\nCCAFCIST EQU   B'00001000'          BUILD FIRST CIST\nCCAFCIPT EQU   B'00000100'          BUILD FIRST CIPT\nCCACISNQ EQU   B'00000010'          CI SUB ISSUED ENQ\nCCASVKGE EQU   B'00000001'          SAVE GET NEXT IND\nCCAGDSLN DS    XL1                  GDS NAME LENGTH\nCCAFLG11 DS    XL1\nCCATNE   EQU   B'10000000'          TRUE NAME ENTRY\nCCATKNRQ EQU   B'01000000'          TOKEN REQUESTED\nCCAGDGBS EQU   B'00100000'          ICF GENERATION DAT SET\n*\nCCAUPGIR EQU   B'00010000'          UPGRADE ICF RECORD\nCCAF11B5 EQU   B'00001000'          B5 AND B6 ON - NO CATLG PASSWORD\n*\nCCAF11B6 EQU   B'00000100'          B5 AND B6 EQUAL TO 01, NO UPDATE\n*                PASSWORD, EQUAL TO 10, THERE IS UPDATE PW\nGOTCORE  EQU   B'00000010'          CORE GOTTEN FOR CRA ACB, CAXWA\n*                                      AND TIOT IN CLAD\nCCADSMF  EQU   B'00000001'          OBTAIN/SCRATCH FAILED\nCCAREGS  DS    0CL348               REGISTER SAVE AREA\n         DS    XL4                  USER SAVE AREA ADDR\nCCAMODNM DS    CL8                  LOAD MODULE NAME\n         DS    CL336\nCCABZSAV DS    0A                   SAVE AREA FOR CLBZ\nCCADSPWA DS    A                    DEFINE SPACE W/A/ PTR\nCCACUMPL DS    A                    CATLG UPGRADE MGMNT\n*                                   PARM LIST PTR\nCCATNQCT DS    XL1                  TIOT ENQ COUNT\nCCASBASE DS    XL3                  SAVE BASE CI\n*                                   FOR UPGD PROCESS\nCCACRACI DS    A                    CRA REC PTR ARRAY AD\nCCARAACB DS    A                    CRA ACB ADDRESS\nCCARARPL DS    A                    CRA RPL ADDRESS\nCCARARBA DS    A                    CRA RBA\nCCARAREC DS    A                    RECORD POINTER\nCCARALSA DS    0A                   CRA LOCAL SAVE AREA\nCCACRABT DS    XL2                  BLOCKS/TRACK FOR CRA RECORD\n*                                   CONSTRUCTION (CLB4)\n         DS    XL2                  RESERVED\nCCAFLG10 DS    XL1                  FLAG BYTE\nCCAINCPL EQU   B'10000000'          INVALID CPL, VAL CK\nCCAPDMW  EQU   B'01000000'          PROB DET MSG PUT\nCCACATAC EQU   B'00100000'          CAT ACTIVE, CRA\nCCARAFEV EQU   B'00010000'          CRA FORCED EOV CH\nCCARARTC EQU   B'00001000'          RECOVERY EXIT, RETURN TO\n*                                        CALLER\nCCAPRANX EQU   B'00000100'          PRIME CRA GONE\nCCADEFUN EQU   B'00000010'          DEFINE UNIQUE SAVE\nENQPCCB  EQU   B'00000001'          PCCB ENQUED ON\nCCASUMTT DS    XL3                  CRA SUM TT VALUE\nCCADICTS DS    XL4                  DATA/INDEX ID TS\nCCARANCA DS    CL8                  NORMAL RECORD BUFFER CHAIN\n*                                    START, END ADDRS\nCCARAVCA DS    CL8                  VOLUME RECORD BUFFER CHAIN\n*                                    START, END ADDRS\nCCAVTS   DS    CL8                  VOLUME TIMESTAMP\nCCAREWKA DS    A                    REUSE WORKAREA ADDR\nCCASMFP  DS    0XL4                 SMF SAVE AREA FOR\n*                                   FOR PROB DETER\nCCASMFMD DS    CL2                  MODULE ID\nCCASMFRC DS    XL1                  REASON CODE\nCCASMFCD DS    XL1                  RETURN CODE\nCCAPROBX DS    0XL4                 AUXILLARY SAVE AREA\n*                                   FOR CCAPROB\nCCAMODDX DS    CL2                  ERROR MODULE ID\nCCAERCDX DS    0XL2                 ERROR CODES\nCCARESNX DS    XL1                  REASON CODE\nCCARETRX DS    XL1                  RETURN CODE\nCCADGDGA DS    0A                   DEL FULL GDG WA\nCCASAVMN DS    A                    SAVE GOTTEN CORE ADDR\nCCAREQDQ DS    0CL16                MULTI FUNCTION PARM LIST.\n*                                   RPL RESOURCE SYSZRPLW\n*                                   USED AS A POST PARM LIST\n*                                   BY IGGPRPLF.\n*                                   USED BY CAS ESTAE ROUTINE\n*                                   IGG0CLA9 FOR ENQ/DEQ ACB\n*                                   RESTART RESOUTCE SYSZACBR.\n*\nCCAREDFF DS    XL1                  END OF PL IND BYTE - X'FF'\n*\nCCAREDLN DS    XL1                  LENGTH OF MINOR NAME\nCCAREDOP DS    XL1                  ENQ-DEQ OPTIONS\nCCAREDSH EQU   B'10000000'          1=SHARED, 0=EXCLUSIVE\n*              B'01111111'             OTHER OPT. (SET BY MACRO)\n*\nCCAREDRC DS    XL1                  ENQ/DEQ RETURN CODE\nCCARMAJN DS    A                    MAJOR NAME PTR\nCCARMINN DS    A                    MINOR NAME PTR\nCCAREUCB DS    A                    UCB PTR\nCCACNAME DS    A                    RECORD NAME POINTER\nCCAXTYPE DS    A                    RECORD TYPE POINTER\nCCAPASRC DS    A                    PTR TO PASSREC FPL\nCCARETRC DS    A                    PTR TO RETVREC FPL\nCCAG00V0 DS    CL8                  G0000V00 QUALIFIER\nCCADTT   DS    A                    DEFINE TRACKING TABLE\nCCAFVT   DS    A                    ADDR OF CURRENT FVT\nCCAURCAP DS    A                    USER RECORD AREA PTR\nCCARAPSV DS    A                    USER RAP SAVE AREA\nCCAR2SAV DS    A                    REGISTER SAVE AREA\nCCAVDSPT DS    A                    VDS PARM LIST\nCCATREC  DS    A                    TARGET RECORD ADDRESS\nCCAWPTR  DS    A                    WORK POINTER\nCCAREC   DS    A                    INPUT RECORD POINTER\nCCARCEND DS    A                    END OF INPUT RECORD\nCCACLEND DS    A                    /*ENDING ADDRESS FOR SEARCH\nCCACELL  DS    A                    CELL POINTER\nCCACOMP  DS    A                    COMPONENT POINTER\nCCASUB   DS    A                    SUB-RECORD POINTER\nCCASUBED DS    A                    SUB-RECORD END PTR\nCCASEND  DS    A                    SUB-RECORD WORK PTR\nCCASTART DS    A                    START OF SEARCH ADDR\nCCAENDAD DS    A                    END OF SEARCH ADDR\nCCASPTR  DS    A                    AN ADDRESS INSIDE A SUB-RECORD\n*\nCCAPEND  DS    A                    ENDING ADDRESS FOR GENERAL\n*                                      PURPOSE SEARCH\nCCASREND DS    A                    ENDING ADDRESS FOR A SEARCH\n*\nCCASAVPT DS    A                    GENERAL PURPOSE SAVE\nCCAVDSPM DS    A                    PTR TO VVDS PARM LIST\nCCAVDSEN DS    A                    PTR TO VVDS RBA ENTRY\nCCAVVR   DS    A                    POINTER TO VVR\nCCAFMPTR DS    0XL24                FIELD INFORMATION POINTERS\n*\nCCAMDSB  DS    A                    POINTER TO AMDSB\nCCADSIF  DS    A                    PTR TO DATASET INFO\nCCASECUR DS    A                    PTR TO SECURITY INFO\nCCAVOLPT DS    A                    PTR TO VOLUME CELL\nCCAVVRVL DS    A                    PTR TO VVR VOLUME INF\nCCASSCPT DS    A                    PTR TO ASSOCIATION\nCCAFMTAB DS    0XL12                FIELD MANAGEMENT IN CORE TABLES/\n*                                      POINTERS\nCCAVVRTB DS    A                    PTR TO VVR TABLE\nCCASCTAB DS    A                    PTR TO CLUSTER ASSOCIATION\n*                                      TABLE\nCCAUPTAB DS    A                    PTR TO UPGRADE ASSOCIATION\n*                                      TABLE\nCCAINRAP DS    A                    INPUT RECORD AREA\nCCAWKRAP DS    A                    INPUT RECORD AREA FOR FSUB AND\n*                                      FGDS\nCCAADPTR DS    A                    POINT OF INSERT FOR FSUB AND\n*                                      FGDS\nCCAEXRCD DS    A                    EXTENSION RECORD\nCCAINDEX DS    XL2                  GENERAL INDEX\nCCAIDX   DS    XL2                  GENERAL INDEX\nCCAMAXRC DS    XL2                  MAX RECORD SIZE\nCCACNTV  DS    XL2                  NO. OF VOLUME CELLS\nCCACOUNT DS    XL2                  NO. OF VVR RETRIEVED\nCCASCNO  DS    XL2                  SEQUENCE NO. OF ASSOCIATION IN\n*                                      ASSOCIATION CELL\nCCAGFST  DS    XL2                  FIRST AIX RELREPNO\nCCAGLST  DS    XL2                  LAST AIX RELREPNO\nCCARFST  DS    XL2                  FIRST PATH RELREPNO\nCCARLST  DS    XL2                  LAST PATH RELREPNO\nCCASUM1  DS    XL2                  GENERAL SUM OF LENGTH\nCCASUM2  DS    XL2                  GENERAL SUM OF LENGTH\nCCAFNFLG DS    XL1                  ICF FIELD MGMT FLAG\nCCATREP  EQU   B'10000000'          REPEATING FIELD\nCCAVARFD EQU   B'01000000'          VARIABLE FIELD\nCCAFLGFD EQU   B'00100000'          FLAG FIELD\nCCACOMB  EQU   B'00010000'          COMBINATION NAME\nCCAEXTYP EQU   B'00001000'          EXTENSION RECORD TYPE\n*                                      0 = VSAM, 1 = GDG\nCCAUPGRD EQU   B'00000100'          UPGRADE REQUEST\nCCAFMLOC EQU   B'00000010'          LOCATE INDICATOR\nCCAFMUPD EQU   B'00000001'          UPDATE INDICATOR\nCCAGRPCD DS    XL1                  GROUP CODE\nCCACCNT  DS    XL1                  /*COMBINATION NAME COUNT\nCCACNT   DS    XL1                  GENERAL COUNTER\nCCASAVCD DS    XL1                  ERROR CODE SAVE AREA\n         DS    XL1                  NOT USED\nCCAFLG14 DS    XL1                  FLAG BYTE 14\nCCARECMV EQU   B'10000000'          PASSED RECORD MOVED\nCCAPRPLM EQU   B'01000000'          CATALOG OBTAINED SYSIGGV2\n*                                      RESOURCE FOR THIS REQUEST\n*\nCCATCBFX EQU   B'00100000'          RPLM SET TCBFX TO PREVENT IRB\n*                                      SCHEDULING\nCCANQSPH EQU   B'00010000'          ENQ ON SPHERE\nCCAMCSRH EQU   B'00001000'          MASTER CATALOG SEARCH\nCCADRSPH EQU   B'00000100'          SPHERE DEQ REQUIRED\nCCADQSPH EQU   B'00000010'          DEQ SPHERE ENQ\nCCAENQEX EQU   B'00000001'          FORCE EXCLUSIVE ENQ\nCCAEXCNT DS    XL1                  NO. OF EXTENSION RECORDS\nCCAEXNO  DS    XL1                  EXTENSION RECORD NO.\nCCAITOKN DS    XL3                  INPUT TOKEN\n         DS    XL2                  NOT USED\nCCASUBLN DS    XL2                  SUB-RECORD LENGTH\nCCADIFFL DS    XL2                  A DELTA LENGTH CHANGE\nCCATLENX DS    XL2                  LENGTH FOR IGGPFITT ROUTINE.\n*                                      (IT IS THE SUB-RECORD LENGTH\n*                                      PLUS DELTA LENGTH CHANGES)\n*\nCCASUM   DS    XL2                  SUM OF LENGTH\nCCATYPE  DS    CL1                  CELL TYPE\nCCAPADNO DS    CL1                  PAD CHARACTER IN EXTENSION\nCCAVER   DS    XL1                  BINARY GDG VERSION NO\nCCAFLAG  DS    XL1                  FLAG BYTE\nCCASW1   EQU   B'10000000'          SWITCH 1\nCCASW2   EQU   B'01000000'          SWITCH 2\nCCASW3   EQU   B'00100000'          SWITCH 3\nCCAEXSW1 EQU   B'00010000'          EXIT SWITCH\nCCABOTH  EQU   B'00001000'          NEED BOTH VOLUME CELL AND VVR\n*                                      VOLUME INFORMATION\nCCAVVRPM EQU   B'00000100'          NEED PRIMARY VVR\nCCAEXFND EQU   B'00000010'          EXTENSION RECORD FIT\n*                                      1=YES, 0=NO\nCCAUPDSP EQU   B'00000001'          SPHERE RECORD HAS TO BE UPDATED\n*\nCCACNTER DS    XL2                  COUNTER\nCCAEXLEN DS    XL2                  EXTENSION RECORD LENGTH TO\n*                                      CREATE\nCCAGEN   DS    XL2                  BINARY GDG GENERATION NUMBER\n*\nCCASTYPE DS    CL1                  SUB-RECORD TYPE\nCCACLASS DS    XL1                  SUBPOOL OF GETMAIN\nCCAGDSGN DS    CL4                  EBCDIC GENERATION NO.\nCCAGDSVR DS    CL2                  EBCDIC VERSION NO.\nCCAVEQDQ DS    0XL16                VVDS ENQ/DEQ PARAMETER LIST\nCCAVEDXF DS    XL1                  END OF PL IND BYTE - X'FF'\nCCAVEDRL DS    XL1                  LENGTH OF MINOR NAME\nCCAVEDOP DS    XL1                  ENQ-DEQ OPTIONS\nCCAVEDSH EQU   B'10000000'          1=SHARED, 0=EXCLUSIVE\n*              B'01111111'          OTHER OPT. (SET BY MACRO)\nCCAVEDRC DS    XL1                  ENQ/DEQ RETURN CODE\nCCAVEDQN DS    A                    MAJOR NAME PTR\nCCAVEDRN DS    A                    MINOR NAME PTR\nCCAVEDUC DS    A                    UCB PTR\nCCAPDOSV DS    CL16                 ESTAE PUSH DOWN LIST\nCCAF2WKA DS    A                    ADDRESS FORMAT 2 WKA\nCCAIQLT  DS    XL2                  CI SUBSTITION ENQ/DEQ LST\n         DS    CL10                 RESERVED\nCCASPSAV DS    XL1                  SAVE SUBPOOL\n         DS    CL3                  NOT USED\nCCASAFPL DS    A                    SAF WA/PARM LIST ADDRESS\nCCACISRT DS    A                    CIS R13 SAVE AREA\nCCAVDS13 DS    A                    VVDS MGR R13 SAVEAREA\nCCAOCPL  DS    A                    ORIGINAL CPL ADDRESS\nCCAARDBP DS    A                    CATALOG ARDB ADDRESS\nCCAVVRLP DS    A                    VVR LOOP CONTROL\nCCACTVVR DS    A                    CATALOG VVR ADDRESS\nCCARCAP0 DS    0XL12                RECORD AREA POINTER 0\nCCARCAR0 DS    A                    RECORD AREA 0 ADDRESS\nCCALCBP0 DS    A                    LOCATE BUFFER POINTER\nCCARCLN0 DS    XL2                  RECORD AREA 0 LENGTH\nCCARCFG0 DS    XL1                  RECORD AREA 0 FLAGS\nCCARCDE0 EQU   B'10000000'          RECORD DELETED\nCCARCUP0 EQU   B'01000000'          UPDATE STATUS\nCCARCFU0 EQU   B'00100000'          FIELD MANAGEMENT UPDATE\nCCARCRP0 EQU   B'00010000'          BUFFER FROM CELL POOL\n*              B'00001111'          RESERVED\nCCARCSP0 DS    XL1                  RECORD AREA 0 SUBPOOL\nCCARCAP1 DS    0XL12                RECORD AREA POINTER 1\nCCARCAR1 DS    A                    RECORD AREA 1 ADDRESS\nCCALCBP1 DS    A                    LOCATE BUFFER POINTER\nCCARCLN1 DS    XL2                  RECORD AREA 1 LENGTH\nCCARCFG1 DS    XL1                  RECORD AREA 1 FLAGS\nCCARCDE1 EQU   B'10000000'          RECORD DELETED\nCCARCUP1 EQU   B'01000000'          UPDATE STATUS\nCCARCFU1 EQU   B'00100000'          FIELD MANAGEMENT UPDATE\nCCARCRP1 EQU   B'00010000'          BUFFER FROM CELL POOL\n*              B'00001111'          RESERVED\nCCARCSP1 DS    XL1                  RECORD AREA 1 SUBPOOL\nCCARCAP2 DS    0XL12                RECORD AREA POINTER 2\nCCARCAR2 DS    A                    RECORD AREA 2 ADDRESS\nCCALCBP2 DS    A                    LOCATE BUFFER POINTER\nCCARCLN2 DS    XL2                  RECORD AREA 2 LENGTH\nCCARCFG2 DS    XL1                  RECORD AREA 2 FLAGS\nCCARCDE2 EQU   B'10000000'          RECORD DELETED\nCCARCUP2 EQU   B'01000000'          UPDATE STATUS\nCCARCFU2 EQU   B'00100000'          FIELD MANAGEMENT UPDATE\nCCARCRP2 EQU   B'00010000'          BUFFER FROM CELL POOL\n*              B'00001111'          RESERVED\nCCARCSP2 DS    XL1                  RECORD AREA 2 SUBPOOL\nCCARCAP3 DS    0XL12                RECORD AREA POINTER 3\nCCARCAR3 DS    A                    RECORD AREA 3 ADDRESS\nCCALCBP3 DS    A                    LOCATE BUFFER POINTER\nCCARCLN3 DS    XL2                  RECORD AREA 3 LENGTH\nCCARCFG3 DS    XL1                  RECORD AREA 3 FLAGS\nCCARCDE3 EQU   B'10000000'          RECORD DELETED\nCCARCUP3 EQU   B'01000000'          UPDATE STATUS\nCCARCFU3 EQU   B'00100000'          FIELD MANAGEMENT UPDATE\nCCARCRP3 EQU   B'00010000'          BUFFER FROM CELL POOL\n*              B'00001111'          RESERVED\nCCARCSP3 DS    XL1                  RECORD AREA 3 SUBPOOL\nCCARCAP4 DS    0XL12                RECORD AREA POINTER 4\nCCARCAR4 DS    A                    RECORD AREA 4 ADDRESS\nCCALCBP4 DS    A                    LOCATE BUFFER POINTER\nCCARCLN4 DS    XL2                  RECORD AREA 4 LENGTH\nCCARCFG4 DS    XL1                  RECORD AREA 4 FLAGS\nCCARCDE4 EQU   B'10000000'          RECORD DELETED\nCCARCUP4 EQU   B'01000000'          UPDATE STATUS\nCCARCFU4 EQU   B'00100000'          FIELD MANAGEMENT UPDATE\nCCARCRP4 EQU   B'00010000'          BUFFER FROM CELL POOL\n*              B'00001111'          RESERVED\nCCARCSP4 DS    XL1                  RECORD AREA 4 SUBPOOL\nCCARCAP5 DS    0XL12                RECORD AREA POINTER 5\nCCARCAR5 DS    A                    RECORD AREA 5 ADDRESS\nCCALCBP5 DS    A                    LOCATE BUFFER POINTER\nCCARCLN5 DS    XL2                  RECORD AREA 5 LENGTH\nCCARCFG5 DS    XL1                  RECORD AREA 5 FLAGS\nCCARCDE5 EQU   B'10000000'          RECORD DELETED\nCCARCUP5 EQU   B'01000000'          UPDATE STATUS\nCCARCFU5 EQU   B'00100000'          FIELD MANAGEMENT UPDATE\nCCARCRP5 EQU   B'00010000'          BUFFER FROM CELL POOL\n*              B'00001111'          RESERVED\nCCARCSP5 DS    XL1                  RECORD AREA 5 SUBPOOL\nCCAFMRAP DS    0XL72                FIELD MANAGEMENT RAP'S, TO BE\n*                                      USED BY FIELD MANAGEMENT ONLY\n*\nCCARCAPU DS    0XL12                RECORD AREA POINTER U\nCCARCARU DS    A                    RECORD AREA U ADDRESS\nCCALCBPU DS    A                    LOCATE BUFFER POINTER\nCCARCLNU DS    XL2                  RECORD AREA U LENGTH\nCCARCFGU DS    XL1                  RECORD AREA U FLAGS\nCCARCDEU EQU   B'10000000'          RECORD DELETED\nCCARCUPU EQU   B'01000000'          UPDATE STATUS\nCCARCFUU EQU   B'00100000'          FIELD MANAGEMENT UPDATE\nCCARCRPU EQU   B'00010000'          BUFFER FROM CELL POOL\n*              B'00001111'          RESERVED\nCCARCSPU DS    XL1                  RECORD AREA U SUBPOOL\nCCARCAPV DS    0XL12                RECORD AREA POINTER V\nCCARCARV DS    A                    RECORD AREA V ADDRESS\nCCALCBPV DS    A                    LOCATE BUFFER POINTER\nCCARCLNV DS    XL2                  RECORD AREA V LENGTH\nCCARCFGV DS    XL1                  RECORD AREA V FLAGS\nCCARCDEV EQU   B'10000000'          RECORD DELETED\nCCARCUPV EQU   B'01000000'          UPDATE STATUS\nCCARCFUV EQU   B'00100000'          FIELD MANAGEMENT UPDATE\nCCARCRPV EQU   B'00010000'          BUFFER FROM CELL POOL\n*              B'00001111'          RESERVED\nCCARCSPV DS    XL1                     RECORD AREA V SUBPOOL\nCCARCAPW DS    0XL12                RECORD AREA POINTER W\nCCARCARW DS    A                    RECORD AREA X ADDRESS\nCCALCBPW DS    A                    LOCATE BUFFER POINTER\nCCARCLNW DS    XL2                  RECORD AREA X LENGTH\nCCARCFGW DS    XL1                  RECORD AREA X FLAGS\nCCARCDEW EQU   B'10000000'          RECORD DELETED\nCCARCUPW EQU   B'01000000'          UPDATE STATUS\nCCARCFUW EQU   B'00100000'          FIELD MANAGEMENT UPDATE\nCCARCRPW EQU   B'00010000'          BUFFER FROM CELL POOL\n*              B'00001111'          RESERVED\nCCARCSPW DS    XL1                  RECORD AREA X SUBPOOL\nCCARCAPX DS    0XL12                RECORD AREA POINTER X\nCCARCARX DS    A                    RECORD AREA X ADDRESS\nCCALCBPX DS    A                    LOCATE BUFFER POINTER\nCCARCLNX DS    XL2                  RECORD AREA X LENGTH\nCCARCFGX DS    XL1                  RECORD AREA X FLAGS\nCCARCDEX EQU   B'10000000'          RECORD DELETED\nCCARCUPX EQU   B'01000000'          UPDATE STATUS\nCCARCFUX EQU   B'00100000'          FIELD MANAGEMENT UPDATE\nCCARCRPX EQU   B'00010000'          BUFFER FROM CELL POOL\n*              B'00001111'          RESERVED\nCCARCSPX DS    XL1                  RECORD AREA X SUBPOOL\nCCARCAPY DS    0XL12                RECORD AREA POINTER Y\nCCARCARY DS    A                    RECORD AREA Y ADDRESS\nCCALCBPY DS    A                    LOCATE BUFFER POINTER\nCCARCLNY DS    XL2                  RECORD AREA Y LENGTH\nCCARCFGY DS    XL1                  RECORD AREA Y FLAGS\nCCARCDEY EQU   B'10000000'          RECORD DELETED\nCCARCUPY EQU   B'01000000'          UPDATE STATUS\nCCARCFUY EQU   B'00100000'          FIELD MANAGEMENT UPDATE\nCCARCRPY EQU   B'00010000'          BUFFER FROM CELL POOL\n*              B'00001111'          RESERVED\nCCARCSPY DS    XL1                  RECORD AREA Y SUBPOOL\nCCARCAPZ DS    0XL12                RECORD AREA POINTER Z\nCCARCARZ DS    A                    RECORD AREA Z ADDRESS\nCCALCBPZ DS    A                    LOCATE BUFFER POINTER\nCCARCLNZ DS    XL2                  RECORD AREA Z LENGTH\nCCARCFGZ DS    XL1                  RECORD AREA Z FLAGS\nCCARCDEZ EQU   B'10000000'          RECORD DELETED\nCCARCUPZ EQU   B'01000000'          UPDATE STATUS\nCCARCFUZ EQU   B'00100000'          FIELD MANAGEMENT UPDATE\nCCARCRPZ EQU   B'00010000'          BUFFER FROM CELL POOL\n*              B'00001111'          RESERVED\nCCARCSPZ DS    XL1                  RECORD AREA Z SUBPOOL\nCCACITKN DS    0XL3                 CI TOKEN\nCCACISTN DS    XL1                  CIST TABLE NUMBER\nCCACISOF DS    XL2                  CIST TABLE OFFSET\nCCAENTNM DS    CL45                 ENTRY NAME\nCCACSNAM DS    0XL46                CIS LENGTH AND NAME\nCCACISLN DS    XL1                  LENGTH OF NAME\nCCACISNM DS    CL45                 CIS NAME\nCCAINAME DS    CL44                 INTERMEDIATE NAME\nCCAKEY   DS    0CL45                KEY MAP\nCCANAME  DS    CL44                 44-BYTE NAME\nCCAPAD   DS    CL1                  1-BYTE PAD CHARACTER\nCCADUMMY DS    0XL52                DUMMY ASSOCIATION INFO\n         DS    XL2                  RESERVED\nCCADUMTP DS    CL1                  TYPE\n         DS    CL3                  RESERVED\nCCADUMKL DS    XL1                  KEY LENGTH\nCCADUMKY DS    0CL45                KEY\nCCADUMNM DS    CL44                 NAME PART OF KEY\nCCADUMPD DS    CL1                  PAD CHARACTER\nCCAPACK1 DS    CL8                  WORK AREA FOR PACKING\nCCAPACK2 DS    CL8                  WORK AREA FOR PACKING\nCCAGDSNM DS    CL9                  PART OF GDS NAME\nCCASCHWA DS    0XL512               SEARCH CAT/SCHED WA\nSCHWA    DS    0XL512\n         DS    XL48\nSCHEN    DS    CL44\nSCHQN    DS    CL44\nSCHACPL  DS    XL48\nSCHLKPL  DS    XL16\nSCHXTBL  DS    XL256\nSCHQPL   DS    0XL56\nSCHNQPL  DS    XL56\nCCADIAG  DS    0XL80                DIAGNOSTIC AREA\n         DS    XL72\nCCALSTID DS    XL4\nCCALSTCL DS    XL4                  LAST PROCEDURE CALLED\nCCAPROBY DS    0XL4                 READ ONLY USE\nCCACISPT DS    XL4                  CI SPLIT COUNT USED BY\n*                                      IGG0CLEG PUT LOGIC\nCCASPHQN DS    0CL16                ENQ/DEQ PARAM\nCCASPXFF DS    XL1                  END OF LIST\nCCASPRLN DS    XL1                  LENGTH OF MINOR NAME\nCCASPOPT DS    XL1                  ENQ-DEQ OPTIONS\nCCASPSHR EQU   B'10000000'          1=SHARED, 0=EXCLUSIVE\n*              B'01111111'          OTHER OPT.\nCCASPRCD DS    XL1                  ENQ/DEQ RETURN CODE\nCCASPQNM DS    A                    MAJOR NAME POINTER\nCCASPRNM DS    A                    MINOR NAME POINTER\nCCASPUCB DS    A                    UCB POINTER\nCCASPMIN DS    0CL88                SHPERE ENQ MINOR NAME\nCCASPHER DS    CL44                 SPHERE NAME\nCCACATAL DS    CL44                 CATALOG NAME\nCCAVVRR  DS    0CL16                READ VVR WORKAREA\nSAVSRATS DS    XL8                  SAVED CAXWA TMSTP\nSAVVVRTS DS    XL8                  SAVED VVR TIMESTAMP\nCCASYNC  DS    XL4                  IGGPSYNC WORKAREA\nCCAVVRNQ DS    0CL16                CAXVDSPM SYNC ENQ\nCCAVVRFF DS    XL1                  END OF PL IND BYTE\nCCAVVRLN DS    XL1                  LENGTH OF MINOR NAME\nCCAVVROP DS    XL1                  ENQ-DEQ OPTIONS\nCCAVVRSH EQU   B'10000000'          1=SHARED, 0=EXCLUSIVE\n*              B'01111111'          OTHER OPT.\nCCAVVRRC DS    XL1                  ENQ/DEQ RETURN CODE\nCCAVMAJN DS    A                    MAJOR NAME POINTER\nCCAVMINN DS    A                    MINOR NAME POINTER\nCCAVVUCB DS    A                    UCB POINTER\nCCACCX   DS    A                    CCX POINTER\nCCAVVRPT DS    A                    VVR CELL POINTER\nCCACVOLA DS    CL88                 CVOL NAMES\nCCACASF1 DS    XL1                  CAS FLAGS BYTE ONE\nCCARECMS EQU   B'10000000'          SAVED RECORD MOVED\nCCAALISF EQU   B'01000000'          ALIAS FOUND IN TABLE\nCCASRISC EQU   B'00100000'          SEARCH ISC FOR RECORD\nCCACASNQ EQU   B'00010000'          CAS-ENQ GOT SYSIGGV2\nCCARLGDS EQU   B'00001000'          RELATIVE GDS NAME\nCCAVSMRM EQU   B'00000100'          IN VSAM RECD MANAGEMNT\nCCANQOLY EQU   B'00000010'          RPLM RESERVE/ENQ ONLY\nCCADQOLY EQU   B'00000001'          RPLF RELEASE/DEQ ONLY\nCCACASF2 DS    XL1                  CAS FLAGS BYTE TWO RSVD\nCCACASF3 DS    XL1                  CAS FLAGS BYTE THREE RSVD\nCCACASF4 DS    XL1                  CAS FLAGS BYTE FOUR RSVD\nCCACASID DS    A                    CAS ENQ/DEQ ASCB POINTER\nCCACATCB DS    A                    CAS ENQ/DEQ TCB POINTER\nCCAR8CAX DS    A                    CAXWA POINTER RPLF\nCCATEMP2 DS    CL164\nCCANQPFX DS    0CL20                CAS ENQ PREFIX\nCCANQTCB DS    A                    TCB ADDRESS\nCCANQECB DS    A                    ECB ADDRESS\nCCANMASI DS    XL4                  MASID VALUE\nCCANMTCB DS    XL4                  MTCB VALUE\nCCANPRFX DS    XL4                  PREFIX FORMAT-WORD\nCCACAS38 DS    0CL16                ENQ/DEQ PARAMETER LIST\nCCACAXFF DS    XL1                  END OF PL IND BYTE -\nCCACARLN DS    XL1                  LENGTH OF MINOR NAME\nCCACAOPT DS    XL1                  ENQ/DEQ OPTIONS\nCCACASHR EQU   B'10000000'          1=SHARED, 0=EXCLUSIVE\n*              B'01111111'          OTHER OPT. (SET BY MACRO)\nCCACARCD DS    XL1                  ENQ/DEQ RETURN CODE\nCCACAQNM DS    A                    MAJOR NAME POINTER\nCCACARNM DS    A                    MINOR NAME POINTER\nCCACAUCB DS    A                    UCB POINTER\nCCAGFL   DS    0CL8                 GFL POINTERS\nCCACFSPT DS    A                    GFL CFS PARM LIST PTR\nCCAGFLPT DS    A                    GFL WORK AREA PTR\nCCAEND   EQU   *                    END OF IBM CCA\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IGGCCX": {"ttr": 2564, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00\\xe5\\x00\\xe5\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 229, "newlines": 229, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         IGGCCX ,\n*/********************************************************************/\n*/*                                                                  */\n*/*   MACRO NAME = IGGCCX                                            */\n*/*                                                                  */\n*/*   DESCRIPTIVE NAME = CATALOG COMMUNICATIONS AREA EXTENSION       */\n*/*                                                                  */\n*/*   FUNCTION = THE CCX IS BUILT AND INITIALIZED IN CSA BY THE      */\n*/*              CAS INTERFACE MODULE.  IT IS USED TO IDENTIFY A     */\n*/*              CAS REQUEST AND CONTAINS THE REQUESTOR'S ASID,      */\n*/*              TCB, ASCB, CCA, AND OTHER REQUIRED INFORMATION.     */\n*/*              THE CCX IS POINTED TO BY THE CRT (CRTCCXPT).        */\n*/*                                                                  */\n*/********************************************************************/\n\nIGGCCX   DSECT ,\nCCXID    DS    CL3             CCX IDENTIFIER = 'CCX'\n         DS    XL1             RESERVED\nCCXSZ    DS    XL2             SIZE OF THE CCX\n         DS    XL2             RESERVED\nCCXCCX   DS    XL4             CCX INDEX IN CRTTABLE\nCCXTCB   DS    A               CALLER'S TCB\nCCXRB    DS    A               CALLER'S RB\nCCXASID  DS    A               CALLER'S ASID\nCCXSRB   DS    A               IGG0CLHC SRB\nCCXPSSRB DS    A               SRB ROUTINE ENTRY POINT\nCCXPRMTR DS    A               RMTR ROUTINE\nCCXOASCB DS    A               CALLER'S ASCB\nCCXNPCCB DS    A               CAS PCCB\nCCXOPCCB DS    A               CALLER'S PCCB\nCCXCWAP  DS    A               CALLER'S WORK AREA\nCCXCIFP  DS    A               RECALL PARAMETER ADDRESS\nCCXPCTOK DS    A               PCLINK TOKEN\nCCXCLX13 DS    A               IGG0CLAH REGISTER 13\nCCXR11S  DS    A               SAVE REGISTER 11\nCCXR14S  DS    A               SAVE REGISTER 14\nCCXECB   DS    A               SERVICE TASK ECB WHICH CONTAINS RETURN\n*                              OR COMPLETION CODE WHEN TASK TERMINATES\nCCXNCPL  DS    A               CAS CPL\nCCXOCPL  DS    A               CALLER'S CPL\nCCXNOFLD DS    A               CALLER'S CTGNOFLD VALUE\nCCXNCCA  DS    A               CAS CCA\nCCXOCCA  DS    A               CALLER'S CCA\nCCXFLG   DS    XL1             CCX FLAGS:\nCCXBCISA EQU   B'10000000'     BIG CISA NEEDED FOR LISTCAT\nCCXSKYSS EQU   B'01000000'     SYSTEM KEY OR SUPERVISOR STATE REQUIRED\nCCXGDGUY EQU   B'00100000'     GOOD GUY\nCCXRESUM EQU   B'00010000'     CCX CAN BE RESUMED\nCCXCASRQ EQU   B'00001000'     CCX IS ON REQUEST QUEUE\nCCXCASPQ EQU   B'00000100'     CCX IS ON PROCESS QUEUE\nCCXCASAQ EQU   B'00000010'     CCX IS ON AVAILABLE QUEUE\nCCXCASAP EQU   B'00000001'     CCX IS ACTIVE\nCCXUSKEY DS    XL1             USER KEY\nCCXERR   DS    XL1             ERROR INDICATOR\nCCXBUKEY DS    XL1             SAVE USER KEY\nCCXRCLWK DS    0XL80           RECALL WORK AREA\nCCXRECAL DS    XL1             RECALL FUNCTION:\n*                              X'01'  DEQ TOPT\n*                              X'02'  DYNAMIC CATALOG OPEN\n*                              X'03'  DYNAMIC ALLOCATION\n*                              X'04'  SECURITY VERIFICATION\n*                              X'05'  FIND CI TOKEN\n*                              X'06'  FIND CI NAME\n*                              X'07'  ENQ\n*                              X'08'  DEQ\n*                              X'09'  RESERVE\n*                              X'0A'  UCRA EXCP\n*                              X'0B'  RENAME\n*                              X'0C'  ERASE\n*                              X'0D'  VSAM CRA DYNAMIC ALLOCATION\n*                              X'0E'  ALLOCATE SVC\n*                              X'0F'  EXTENDED DADSM CALL\nCCXMVFLG DS    XL1             DATA MOVE FLAG:\nCCXMPFLG EQU   B'10000000'     MOVE TO CAS:  0=NO MOVE  1=MOVE DATA\nCCXMSFLG EQU   B'01000000'     MOVE TO USER: 0=NO MOVE  1=MOVE DATA\n*              B'00111111'     RESERVED\nCCXSECFG DS    XL1             SECURITY PROCESSING FLAG\n         DS    XL1             RESERVED\nCCXMSLEN DS    XL2             MVCS LENGTH\n         DS    XL2             RESERVED\nCCXMSTO  DS    A               MVCS TO ADDR\nCCXMSFRM DS    A               MVCS FROM ADDR\nCCXMPLEN DS    XL2             MVCP LENGTH\n         DS    XL2             RESERVED\nCCXMPFRM DS    A               MVCP FROM ADDR\nCCXMPTO  DS    A               MVCP TO ADDR\nCCXMDATA DS    0XL52           MORE PARAMETER DATA\nCCXNOPTR DS    XL1             NUMBER OF POINTERS IN THE PARAMTER LIST\n         DS    XL3             RESERVED\nCCXPMOVE DS    0XL36           MOVED PARAMETERS\nCCXPMPTR DS    A               POINTER IN PARAMETER LIST\nCCXPMLEN DS    XL2             LENGTH OF DATA\n         DS    XL30\nCCXREGLT DS    0XL12           REGISTERS FOR RECALL\nCCXPMREG DS    XL4             REGISTER\n         DS    XL8\nCCXWORK  DS    0XL48           CAS WORK AREA\nCCXNXTBK DS    A               SAVE NEXT BLOCK\nCCXRMBYT DS    A               SAVE NEXT BLOCK\nCCXPROB  DS    A               PROBLEM DETERMINATION AND RECALL\nCCXPROB2 DS    XL4             RECALL RETURN CODE\nCCXTQDB  DS    A               COPIED DSABS QDB POINTER\nCCXDDNM  DS    A               DDNAME POINTER\nCCXWPTR  DS    0A              JFCB WORK AREA POINTER\n         DS    XL1             SWA TYPE\nCCXWTTR  DS    AL3             JFCB POINTER\nCCXEFLG  DS    XL4             EXTRA FLAG:\nCCXF1EQ  EQU   B'10000000'     0=DEQ,  1=FLAG2\nCCXF2EQ  EQU   B'01000000'     0=ENQ,  1=RSV\nCCXTDEQ  EQU   B'00100000'     TIOT DEQUEUE INDICATOR: 0=NO,  1=YES\nCCXDCLU  EQU   B'00010000'     DEQUEUE CLEANUP INDICATOR SET BY ETX1 IF\n*                              DEQ RECALL COULD NOT BE PERFORMED\nCCXPURGE EQU   B'00001000'     SRB SCHEDULE IS NOT ALLOWED\nCCXTERM  EQU   B'00000100'     TERMINATE SERVICE TASK\nCCXWAIT  EQU   B'00000010'     PUT CCX ON THE WAIT QUEUE\nCCXREST  EQU   B'00000001'     RESTART FLAG\nCCXEQDQ1 DS    A               PARAMETER LIST WORD 1\nCCXEQDQ2 DS    A               PARAMETER LIST WORD 2\nCCXEQDQ3 DS    A               PARAMETER LIST WORD 3\nCCXEQDQ4 DS    A               PARAMETER LIST WORD 4\nCCXREGS  DS    XL72            SAVE AREA\nCCXEDR6  DS    A               EQDQ PARAMETER LIST POINTER\nCCXEDR8  DS    A               EQDQ REGISTER 8 SAVE\nCCXEDR11 DS    A               EQDQ CCA POINTER\nCCXUCB   DS    A               UCB ADDRESS\nCCXTSOPW DS    A               TSO PASSWORD POINTER\nCCXUSVRD DS    A               USVR DATA POINTER\nCCXUSVRN DS    A               USVR NAME POINTER\nCCXUSVRL DS    XL4             USVR LENGTH\nCCXLCICB DS    XL4             CICB LENGTH\nCCXOCICB DS    A               CICB POINTER\nCCXQNAME DS    CL8             QNAME\nCCXRNAME DS    CL44            RNAME\nCCXCAS1  DS    0XL72           SRB SAVE AREA, ATTACH PARAMTER LIST, AND\n*                              RMF PARAMETERS\nCCXSTIME DS    XL8             SYSEVENT START TIME\nCCXSSID  DS    XL8             SYSEVENT SUBSYSTEM ID\nCCXSTID  DS    XL8             SYSEVENT TRANSACTION ID\nCCXSUID  DS    XL8             SYSEVENT USER ID\nCCXSTCL  DS    XL8             SYSEVENT CLASS\nCCXSTCB  DS    XL32            SYSEVENT EXTRA\nCCXCAS2  DS    XL24            SAVE AREA2\nCCXCAS3  DS    XL24            SAVE AREA3\nCCXCAS4  DS    XL24            SAVE AREA4\nCCXNTIO  DS    A               CAS TIOT COPY POINTER\nCCXOTIO  DS    A               CALLER'S TIOT POINTER\nCCXLTIO  DS    XL4             LENGTH OF TIOT\nCCXOCVOL DS    A               REQUEST CVOL\nCCXNCVOL DS    A               CAS CVOL POINTER\nCCXOSCWA DS    A               REQUEST SCHWA POINTER\nCCXNSCWA DS    A               CAS SEARCH CATALOG WORK AREA POINTER\nCCXTPTR  DS    A               CAS TEMPORARY POINTER\nCCXACB   DS    A               CATALOG ACB\nCCXRETWA DS    0XL12           DYNAMIC ALLOCATION RETURN AREA\nCCXDDNAM DS    CL8             DDNAME RETURNED\nCCXR15   DS    XL4             RETURN CODE IN REGISTER 15\nCCXCAST  DS    A               CAS SERVICE TASK TCB ADDRESS\nCCXJSCB  DS    A               POINTER TO SERVICE TASK COPIED JSCB\nCCXQDB   DS    XL32            USER QDB\nCCXWKA   DS    0XL8            TEMPORARY WORK AREA\nCCXWKFLG DS    XL1             TEMPORARY FLAG:\nCCXF1LPS EQU   B'10000000'     LOOP FLAG IN CROSS-MEMORY\n*              B'01111111'     RESERVED\n         DS    XL7             RESERVED\nCCXTIME  DS    XL8             STCLK TIME VALUE\nCCXCASID DS    A               CAS ASID\nCCXCASCB DS    A               CAS ASCB POINTER\nCCXWTOR  DS    0XL4            WTOR FLAGS AND ID\nCCXWTORF DS    XL1             WTOR FLAGS:\nCCXWTORP EQU   B'10000000'     WTOR IN-PROGRESS FLAG\n*              B'01111111'     RESERVED\nCCXWTORI DS    XL3             WTOR ID NUMBER\nCCXCITKN DS    0XL3            CI TOKEN\nCCXCISTN DS    XL1             CIST TABLE NUMBER\nCCXCIOF  DS    XL2             CIST OFFSET\nCCXSNAM  DS    0XL46           CIS NAME\nCCXCISLN DS    XL1             CIS LENGTH\nCCXCISNM DS    XL45            KEY MAP\n         DS    XL3             RESERVED\nCCXLCCX  DS    A               SRR LOCK CHAIN\nCCXLASCB DS    A               SRR LOCK ASCB\nCCXLTCB  DS    A               SRR LOCK TCB\nCCXLASID DS    A               SRR LOCK ASID\nCCXLOCK  DS    A               SRR LOCK HEADER ADDRESS\nCCXEMR1  DS    A               EMSG REGISTER 1 SAVE\nCCXEMR2  DS    A               EMSG REGISTER 2 SAVE\nCCXFLAGS DS    0XL4            CCX FLAGS\nCCXFLAG3 DS    XL1             FLAG BYTE 3:\nCCXRBTCB EQU   B'10000000'     ON = CALLER RB POINTS TO XRBLNK (TCB)\nCCXNWTCB EQU   B'01000000'     NEWLY ATTACHED TCB\nCCXLKTCB EQU   B'00100000'     RESUME FROM LOCK ROUTINE\nCCXRECUR EQU   B'00010000'     RECURSIVE SVC 26 IN CAS MEMORY\nCCXADSP  EQU   B'00001000'     ADSP ATTRIBUTE\nCCXBPASS EQU   B'00000100'     SECURITY BYPASS\n*              B'00000011'     RESERVED\n         DS    XL3             RESERVED\nCCXLOCKX DS    XL2             LOCK HELD FLAGS:\nCCXLOCK1 EQU   B'10000000'     CAS LOCK 1 HELD\nCCXLOCK2 EQU   B'01000000'     CAS LOCK 2 HELD\nCCXLOCK3 EQU   B'00100000'     CAS LOCK 3 HELD\nCCXLOCK4 EQU   B'00010000'     CAS LOCK 4 HELD\nCCXLOCK5 EQU   B'00001000'     CAS LOCK 5 HELD\nCCXLOCK6 EQU   B'00000100'     CAS LOCK 6 HELD\nCCXLOCK7 EQU   B'00000010'     CAS LOCK 7 HELD\nCCXLOCK8 EQU   B'00000001'     CAS LOCK 8 HELD\nCCXLOCK9 EQU   B'10000000'     CAS LOCK 9 HELD\nCCXLOCKA EQU   B'01000000'     CAS LOCK A HELD\nCCXLOCKB EQU   B'00100000'     CAS LOCK B HELD\nCCXLOCKC EQU   B'00010000'     CAS LOCK C HELD\nCCXLOCKD EQU   B'00001000'     CAS LOCK D HELD\nCCXLOCKE EQU   B'00000100'     CAS LOCK E HELD\nCCXLOCKF EQU   B'00000010'     CAS LOCK F HELD\n*              B'00000001'     RESERVED\n         DS    XL2             RESERVED\nCCXDDND  DS    A               DATA DDNAME\nCCXDDNI  DS    A               INDEX DDNAME\nCCXCAS2A DS    XL24            SAVE AREA2A IGG0CLHB\nCCXCAS2B DS    XL4             SAVE INTERNAL CCX   IGG0CLX0\nCCXCAS3B DS    XL4             CCXTPTR2  IGG0CLX0\nCCXCAS2C DS    XL24            SAVE AREA2C IGG0CLXA\nCCXCAS2D DS    XL24            SAVE AREA2D IGG0CLXA\nCCXCAS2E DS    XL24            SAVE AREA2E IGG0CLXA\nCCXCAS2F DS    XL24            SAVE AREA2F IGG0CLXE\nCCXCAS2G DS    XL72            SAVE AREA2G IGG0CLHB\nCCXCAS2H DS    XL72            SAVE AREA2H IGG0CLXA\nCCXTOKEN DS    XL4             PC TOKEN IGG0CLXA\nCCXEND   EQU   *               END OF CCX\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IHAQDB": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00\"\\x00\"\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 34, "newlines": 34, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         IHAQDB &DSECT=YES    */\n***********************************************************************\n*                                                                     *\n*                           QUEUE DESCRIPTOR BLOCK                    *\n*                                                                     *\n*    OS/VS2 RELEASE 2, 08/02/72, LEVEL=1                              *\n*                                                                     *\n*    METHOD OF ACCESS                                                 *\n*        BAL   - DSECT IS PRODUCED UNLESS DSECT=NO IS SPECIFIED.      *\n*                USING ON QDB GIVES ADDRESSABILITY FOR ALL SYMBOLS.   *\n*        PL/S  - DCL QDBPTR PTR                                       *\n*                                                                     *\n***********************************************************************\n\n         AIF ('DSECT' EQ 'NO').QDB10\nQDB      DSECT ,\n         AGO   .QDB20\n.QDB10   ANOP  ,\n         DS    0D\nQDB      EQU   *\n.QDB20   ANOP\nQDBQDB   DS    CL4 -          ACRONYM IN EBCDIC -QDB-\nQDBATTR  DS    BL2 -          QUEUE ATTRIBUTES\nQDBRV001 DS    H -            RESERVED\nQDBNELMS DS    F -            NUMBER OF ELEMENTS ON QUEUE\nQDBFELMP DS    A -            POINTER TO FIRST ELEMENT\nQDBLELMP DS    A -            POINTER TO LAST ELEMENT\nQDBFPTDS DS    H -            FORWARD POINTER DISPLACEMENT\nQDBBPTDS DS    H -            BACKWARD POINTER DISPLACEMENT\nQDBPRSZ  DS    H -            PRIORITY FIELD SIZE\nQDBPRDS  DS    H -            PRIORITY FIELD DISPLACEMENT\nQDBRV002 DS    A -            RESERVED\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IHARLD": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00\\xa1\\x00\\xa1\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 161, "newlines": 161, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         IHARLD ,\n*/********************************************************************/\n*/*                                                                  */\n*/*     IHARLD DEFINE RECORDS WRITTEN BY THE LINKAGE EDITOR          */\n*/*        RLD - RELOCATION DICTIONARY AND CONTROL RECORDS           */\n*/*        SYM - SYMBOL RECORDS                                      */\n*/*        CESD - COMPOSITE EXTERNAL SYMBOL DICTIONARY RECORDS       */\n*/*        STT - SCATTER/TRANSLATION RECORDS                         */\n*/*        IDR - CSECT IDENTIFICATION RECORDS                        */\n*/*                                                                  */\n*/*  METHOD OF ACCESS                                                */\n*/*      BAL  - ISSUE THE MACRO 'IHARLD'  (NO OPERANDS)              */\n*/*                                                                  */\n*/********************************************************************/\n*\n*      RELOCATION DICTIONARY (RLD) AND CONTROL (CTL) RECORDS\n*\nRLDCTRL  DSECT ,\nRLDCTLDR DS    0CL16         CONTROL DATA FOR THE RECORD\nRLDIDENT DS    XL1             TYPE OF RECORD IDENTIFIER\nRLDIDR   EQU   X'80'           CSECT IDENTIFICATION RECORD\nRLDSYM   EQU   X'40'           SYM RECORD\nRLDCESD  EQU   X'20'           CESD RECORD\nRLDSTR   EQU   X'10'           SCATTER/TRANS RECORD\nRLDEOM   EQU   X'08'           END OF MODULE\nRLDEOS   EQU   X'04'           END OF SEGMENT\nRLDRLD   EQU   X'02'           RELOCATION DICTIONARY RECORD\nRLDCTL   EQU   X'01'           CONTROL RECORD -- (TEXT FOLLOWS)\nRLDTXT   EQU   X'01'           CONTROL RECORD -- (TEXT FOLLOWS)\nRLDNOTRC EQU   X'F0'           IF ANY OF THE FIRST FOUR BITS IN THIS\n*                              BYTE ARE NON-ZERO, THEN THIS IS NOT\n*                              AN RLD OR CONTROL RECORD\n         DS    XL2           RESERVED\nRLDNRLD  DS    XL1           NUMBER OF RLD AND/OR CONTROL RECORDS\n*                            WHICH FOLLOW THE NEXT BLOCK OF TEXT\nRLDCTLL  DS    H             LENGTH OF CONTROL DATA\nRLDRLDL  DS    H             LENGTH OF RLD DATA\nRLDCCW   DS    0CL8          CHANNEL COMMAND WORD IN CTL\nRLDCMD   DS    XL1             COMMAND CODE\nRLDADDR  DS    AL3             DATA ADDRESS\nRLDFLAG  DS    XL1             COMMAND FLAGS\n         DS    XL1             ** RESERVED\nRLDCNT   DS    FL2             COUNT FIELD\nRLDCTLDD DS    CL240         RLD AND/OR CONTROL DATA\n*\n*    RLD RELOCATION AND POSITION POINTERS\n*\nRLDPTRS  DSECT ,\nRLDRPTR  DS    FL2           RELOCATION POINTER -- CONTAINS THE ENTRY\n*                            NUMBER OF THE CESD ENTRY (OR TRANSLATION\n*                            TABLE ENTRY) THAT INDICATES WHICH SYMBOL\n*                            VALUE IS TO BE USED IN THE COMPUTATION\n*                            OF THE ADDRESS CONSTANTS VALUE\nRLDPPTR  DS    FL2           POSITION POINTER -- CONTAINS THE ENTRY\n*                            NUMBER OF THE CESD ENTRY (OR TRANSLATION\n*                            TABLE ENTRY) THAT INDICATES WHICH CONTROL\n*                            SECTION HOLDS THE ADDRESS CONSTANT\n*\n*    RLD DATA FLAGS FOR AND ADDRESSES OF ADCONS IN RLD RECORDS\n*\nRLDDATA  DSECT ,\nRLDFLAGS DS    XL1\nRLDTYP   EQU   X'F0'          TYPE OF ADDRESS CONSTANT\nRLDTNBR  EQU   X'0F'          '0000'B  NONBRANCH-TYPE (DC A(NAME)\nRLDTBR   EQU   X'10'          '0001'B  BRANCH-TYPE (DC V(NAME)\nRLDTRDV  EQU   X'20'          '0010'B  PSEUDO-REG DISPLACEMENT VALUE\nRLDTRCDV EQU   X'30'          '0011'B  PSEUDO-REG CUMULATIVE\n*                                      DISPLACEMENT VALUE\nRLDNREL  EQU   X'70'          (IF ANY OF THESE BITS ARE NON-ZERO,\n*                              THE ADDRESS IS NOT TO BE RELOCATED)\nRLDUNRES EQU   X'80'          THIS ADDRESS REFERS TO AN UNRESOLVED\n*                             SYMBOL\nRLDLEN   EQU   X'0C'          LENGTH OF ADDRESS CONSTANT\nRLDDIR   EQU   X'02'          DIRECTION OF RELOCATION\n*                                0=POSITIVE, 1=NEGATIVE\nRLDNEXT  EQU   X'01'          NEXT ADCON IS BASED ON: . . .\n*                                1-THE SAME POINTERS . . . . .\n*                                0-A DIFFERENT SET OF POINTERS\nRLDADPTR DS    AL3            POINTER TO THE ADCON\n*\n*    CONTROL DATA (NOTE:  IF BOTH RLD AND CONTROL DATA ARE IN A\n*    RECORD, RLD DATA BEGINS AT THE ADDRESS OF RLDCTLDD AND\n*    CONTROL DATA BEGINS AT THE ADDRESS OF RLDCTLDD PLUS THE\n*    CONTENTS OF RLDRLDL)\n*\nRLDCTRLD DSECT ,\nRLDCESDN DS    FL2            CESD ENTRY NUMBER -- SPECIFIES THE CESD\n*                             ENTRY WHICH CONTAINS THE CONTROL SECTION\n*                             NAME FOR THE FOLLOWING TEXT\nRLDCLENG DS    FL2            LENGTH OF THE RECORD AND/OR LENGTH OF\n*                             CONTROL SECTION\n*\nSYM      DSECT ,              SYMBOL RECORDS\nSYMIDENT DS    XL1\nSYMRCD   EQU   X'40'                   IDENTIFIES IT AS A SYM RECORD\nSYMTYPE  DS    XL1\nSYMLENG  DS    H                       LENGTH OF SYM DATA\nSYMDATA  DS    CL240                   SYM DATA AND ESD DATA\n*\nCESD     DSECT ,              COMPOSITE EXTERNAL SYMBOL DICTIONARY\nCESDIDEN DS    XL1\nCESDRCD  EQU   X'20'                   IDENTIFIES IT AS A CESD RECORD\nCESDRCDN EQU   X'28'                   IDENTIFIES IT AS THE LAST\n*                                      CESD RECORD OF A MODULE\n*                                      WHICH CONTAINS NO TEXT\nCESDFLAG DS    XL1                     FLAG BYTE\nCESDMODE EQU   X'80'               IF SET, BYTE 12 OF ESD CONTAINS\n*                                      AMODE/RMODE/RSECT DATA,\n*                                  ELSE BYTE 12 CONTAINS SEGMENT\n*                                      NUMBER\n         DS    XL2\nCESDFST  DS    H                       ESDID OF FIRST ESD ITEM\nCESDLENG DS    H                       LENGTH OF CESD DATA\nCESDATA  DS    CL240                   CESD DATA\n*\n*      CESD DATA\n*\nESDDATA  CSECT\nESDNAME  DS    CL8                 EXTERNAL NAME (ZERO WHEN TYPE NULL)\nESDTYPE  DS    0XL1                TYPES OF CESD RECORDS\nESDTYPNL EQU   X'07'                   0000 0111 - NULL\nESDTYPSD EQU  X'0F'                   XXXX 0000 - SECTION DEFINITION\nESDTYPER EQU   X'02'                   XXXX 0010 - EXTERNAL REFERENCE\nESDTYPLR EQU   X'03'                   XXXX 0011 - LABEL REFERENCE\nESDTYPPC EQU   X'04'                   XXXX 0100 - PRIVATE CODE\nESDTYPCM EQU   X'05'                   XXXX 0101 - COMMON CODE\nESDTYPPR EQU   X'06'                   XXXX 0110 - PSEUDO REGISTER\nESDTYPWZ EQU   X'0A'                   XXXX 1010 - WEAK EXTERNAL REF\nESDSUBT  DS    XL1                 SUB CLASSIFICATION\nESDSNUL  EQU   X'07'                   0000 0111 - NULL\nESDSMAP  EQU   X'80'                   1XXX XXXX - MAP\nESDSCHA  EQU   X'40'                   X1XX XXXX - CHAIN\nESDSINS  EQU   X'20'                   XX1X XXXX - INSERT\nESDSREP  EQU   X'10'                   XXX1 XXXX - REPLACE OR DELETE\nESDADDR  DS    AL3                 LINKAGE EDITOR ASSIGNED ADDR\n*                                      OF THIS SYMBOL -- ZERO WHEN\n*                                      TYPE IS ER, WX, OR NULL\nESDSEG   DS    XL1                 SEGMENT NUMBER -- ZERO WHEN\n*                                      TYPE IS ER, WX, OR NULL\nESDCLEN  DS    0FL3                LENGTH OF CSECT WHEN TYPE\n*                                      IS SD, PC, CM, OR PR -- ZERO\n*                                      WHEN TYPE IS WX\nESDCID   DS    XL2                 CSECT IDENT -- WHEN TYPE IS LR\n*                                      -- X'06' INDICATES 'NEVER CALL\n         DS    XL1                 LAST BYTE OF LENGTH\n*\nSTT      DSECT ,               SCATTER/TRANSLATION TABLE RECORD\nSTTIDEN  DS    XL1\nSTTRCD   EQU   X'40'                   IDENT AS A SCATTER/TRANS TABLE\nSTTZERO  DS    XL1                     BINARY ZEROS\nSTTLENG  DS    H                       LENGTH OF STT DATA\nSTTDATA  DS    CL1020                  SCATTER/TRANSLATION DATA\n*\nIDR      DSECT ,               CSECT IDENTIFICATION RECORD\nIDRIDEN  DS    XL1\nIDRRCD   EQU   X'80'                   IDENT AS A CSECT IDENT RECORD\nIDRLENG  DS    XL1                     LENGTH OF IDR DATA\nIDRSTYPE DS    XL1                     IDR SUBTYPE\nIDRDATA  DS    CL253                   CSECT IDENT DATA\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IOSDIOVT": {"ttr": 4623, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x08\\x01\\x15\\x07_\\x01\\x15\\x07_ )\\x00>\\x00>\\x00>\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2015-03-16T00:00:00", "modifydate": "2015-03-16T20:29:08", "lines": 62, "newlines": 62, "modlines": 62, "user": "MACRO"}, "text": "         MACRO\n         IOSDIOVT\nIOVT     DSECT                         IOS Vector Table          ESA41\n         DS    C'IOVT'\n         DS    H'476'                  Length of IOVT            RS1106\n         DS    XL2\nIOVTUL31 DS    V(ULUT)                 UCB LOOK-UP TABLE\n         DS    3F\nIOVTCDA  DS    V(CDA)                  Config Data Area\n         DS    1F                      ???\n         DS    A                       IASC ??\n         DS    A                       IOS PIN QUEUE HEADERS\n         DS    A                       IOS PIN QUEUE ELEMENTS\n         DS    1F                      ???\n         DS    A                       TQE\n         DS    6F                      ???\n         DS    A                       CSC\n         DS    1F                      ???\n         DS    A                       IOS 31 BIT DST ENTRIES\n         DS    A                       IOS 24 BIT DST ENTRIES\n         DS    1F                      ???\n         DS    A                       IOS UCB SERVICES PC RTN\n         DS    A                       IODE\n         DS    3F                      ???\n         DS    A                       IOS HASH\n         DS    A                       IOS UCB HASH COLISIONS\n         DS    1F                      ???\n         DS    A                       DDT\n         DS    A                       DDT\n         DS    A                       DDT\n         DS    4F                      ???\n         DS    A                       CAPT\n         DS    2F                      ???\n         DS    A                       DDT\n         DS    A                       DDT\n         DS    1F                      ???\n         DS    A                       DDT\n         DS    A                       IOS CAPTURE UCB SERVICE\n         DS    A                       TRCB\n         DS    2F                      ???\n         DS    1F                      ???\n         DS    A                       MGFQ\n         DS    A                       CMVT\n         DS    A                       CPCT\n         DS    1F                      ???\n         DS    1F                      ???\n         DS    A                       IXSD\n         DS    CL8'SYSIOS01'\n         DS    6F                      ???\n         DS    A                       QDIO\n         DS    1F                      ???\n         DS    A                       SAUT\n         DS    4F                      ???\n         DS    A                       IOS PURGE WORK AREAS\nIOVTFLG1 DS    X                       IOVT-Flag\nIOVTMIDAW EQU   X'08'                  MIDAW ON?\n         DS    XL3                     ???\n         DS    A                       CCAP\n         ORG   IOVT+440                0x1B8                     JH1214\nIOVTULUT DS    D                       UCB V3 look-up table      JH1214\n         ORG   ,                                                 JH1214\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IOSDULUT": {"ttr": 4613, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x12\\x19\\x0f\\x01\\x12\\x19\\x0f\\x133\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xc8\\xd6\\xe6\\xf7\\xf2\\xf1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-07-08T00:00:00", "modifydate": "2012-07-08T13:33:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SHOW721"}, "text": "         MACRO\n         IOSDULUT\nULUT     DSECT                         UCB Look-up Table         ESA41\n         DS    C'ULUT'\nULUTVERS DS    X                       version 1 or 2            RS0405\n         DS    AL1(245)                Subpool\n         DS    XL2,F                   UNUSED,DASB\nULUT1ST  DS    A(ULUENTRY)             FIRST LOOK-UP ENTRY\nULUTUCBC DS    F'561'                  Total number of LOOK-UP Entries\nULUTTAPE DS    F'064'                  number of TAPE LOOK-UP Entries\nULUTCOMM DS    F'032'                  number of COMM LOOK-UP Entries\nULUTDASD DS    F'256'                  number of DASD LOOK-UP Entries\nULUTDISP DS    F'128'                  number of DISP LOOK-UP Entries\nULUTUREC DS    F'032'                  number of UREC LOOK-UP Entries\nULUTCHAR DS    F'008'                  number of CHAR LOOK-UP Entries\nULUTCTCA DS    F'016'                  number of CTCA LOOK-UP Entries\n         ORG   ULUT+132\nULUENTRY DSECT                         UCB LOOK-UP ENTRY\nULUEDEVN DS    X'000D'                 DEVICE NUMBER\nULUEFLGS DS    X'4000'                 Flags\nULUEDYN   EQU  X'40'                   Dynamic UCB\nULUESEQN DS    XL2                     ?\n         DS    XL2                     ?\nULUEUCBP DS    V(UCBOB)                UCB ADDRESS\nULUELEN  EQU   *-ULUENTRY\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IOSDULU2": {"ttr": 4615, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x12\\x19\\x0f\\x01\\x12\\x19\\x0f\\x133\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xc8\\xd6\\xe6\\xf7\\xf2\\xf1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-07-08T00:00:00", "modifydate": "2012-07-08T13:33:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SHOW721"}, "text": "         MACRO\n         IOSDULU2\nULU2     DSECT                         UCB Look-up Table\n         DS    C'ULUT'\nULU2VERS DS    X                       version 1 or 2\n         DS    AL1(245)                Subpool\n         DS    XL2,F                   UNUSED,DASB\n         DS    F,F\nULU21ST  DS    A(UL2ENTRY)             FIRST LOOK-UP ENTRY\nULU2UCBC DS    F'561'                  Total number of LOOK-UP Entries\nULU2TAPE DS    F'064'                  number of TAPE LOOK-UP Entries\nULU2COMM DS    F'032'                  number of COMM LOOK-UP Entries\nULU2DASD DS    F'256'                  number of DASD LOOK-UP Entries\nULU2DISP DS    F'128'                  number of DISP LOOK-UP Entries\nULU2UREC DS    F'032'                  number of UREC LOOK-UP Entries\nULU2CHAR DS    F'008'                  number of CHAR LOOK-UP Entries\nULU2CTCA DS    F'016'                  number of CTCA LOOK-UP Entries\n         ORG   ULU2+264\nUL2ENTRY DSECT                         UCB LOOK-UP ENTRY\nUL2EDEVN DS    X'000D'                 DEVICE NUMBER\nUL2EFLGS DS    X'4000'                 Flags\nUL2EDYN   EQU  X'40'                   Dynamic UCB\nUL2ESEQN DS    XL2                     ?\n         DS    XL2                     ?\nUL2EUCBP DS    V(UCBOB)                UCB ADDRESS\nUL2ELEN  EQU   *-UL2ENTRY\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IOSDULU3": {"ttr": 4617, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x146/\\x01\\x146/\\x08T\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc8\\xd6\\xe6\\xf7\\xf2\\xf2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-12-28T00:00:00", "modifydate": "2014-12-28T08:54:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SHOW722"}, "text": "         MACRO\n         IOSDULU3\nULU3     DSECT                         UCB Look-up Table\n         DS    C'ULUT'\nULU3VERS DS    X                       version 3                 JH1214\n         DS    AL1                     Subpool\n         DS    XL2                     <filler>\n         DS    F                       <filler>\n         DS    F                       <filler>\nULU31ST  DS    D                       FIRST LOOK-UP ENTRY (V3)\n         DS    XL2                     <filler>\n         DS    XL2                     <filler>\nULU3UCBC DS    F                       Total number of LOOK-UP Entries\nULU3TAPE DS    F'064'                  number of TAPE LOOK-UP Entries\nULU3COMM DS    F'032'                  number of COMM LOOK-UP Entries\nULU3DASD DS    F'256'                  number of DASD LOOK-UP Entries\nULU3DISP DS    F'128'                  number of DISP LOOK-UP Entries\nULU3UREC DS    F'032'                  number of UREC LOOK-UP Entries\nULU3CHAR DS    F'008'                  number of CHAR LOOK-UP Entries\nULU3CTCA DS    F'016'                  number of CTCA LOOK-UP Entries\n         ORG   ULU3+264\nUL3ENTRY DSECT                         UCB LOOK-UP ENTRY\nUL3EDEVN DS    X'000D'                 DEVICE NUMBER\nUL3EFLGS DS    X'4000'                 Flags\nUL3EDYN   EQU  X'40'                   Dynamic UCB\nUL3ESEQN DS    XL2                     ?\n         DS    XL2                     ?\nUL3EUCBP DS    V(UCBOB)                UCB ADDRESS\nUL3ELEN  EQU   *-UL3ENTRY\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ISPLINK": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00\\xb9\\x00\\xb9\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 185, "newlines": 185, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    ISPLINK &VERB,&SAVE=,&LIST=,&ERROR=,&OK=\n.**********************************************************************\n         LCLA  &I,&N\n         LCLC  &LABEL              CURRENT INDEXED MACRO LABEL\n         LCLC  &SERVICE            CURRENT SPF SERVICE\n         GBLC  &SPFADDR            ISPLINK SUBROUTINE ADDRESS\n         GBLC  &SPFCALL            ISPLINK PARAMETER LIST ADDRESS\n         GBLA  &SPFCNT             ISPLINK VERB COUNT\n         GBLC  &SPFVRB(255)        ISPLINK VERB NAME\n&LABEL   SETC  'ISPL&SYSNDX'       DEFINE A LABEL INCASE NEEDED\n.**********************************************************************\n         AIF   ('&NAME' EQ '').NONAME\n&NAME    DS    0H\n.NONAME  ANOP  ,\n.**********************************************************************\n         AIF   (N'&SYSLIST EQ 0).EXPAND\n         AIF   ('&VERB' EQ '').EXPAND\n         AIF   ('&VERB' EQ 'LOAD').LOAD010\n         AIF   ('&VERB' EQ 'RELOAD').RELO010\n         AIF   ('&VERB' EQ 'UNLOAD').UNLO010\n         AGO   .SERVICE\n.**********************************************************************\n.LOAD010 ANOP  ,\n         AIF   ('&SAVE' NE '').LOAD020\n         MNOTE 8,'SAVE= Not Supplied'\n         AGO   .MEND\n.LOAD020 ANOP  ,\n         AIF   ('&LIST' NE '').LOAD030\n         MNOTE 8,'LIST= Not Supplied'\n         AGO   .MEND\n.LOAD030 ANOP  ,\n&SPFADDR SETC  '&SAVE'\n&SPFCALL SETC  '&LIST'\n         AIF   ('&ERROR' NE '').LOAD040\n*        LOAD  EP=ISPLINK          LOAD ISPLINK ROUTINE\n         LOAD  EP=ISPLINK\n         AGO   .LOAD060\n.LOAD040 ANOP  ,\n         AIF   ('&ERROR' EQ '*').LOAD050\n*        LOAD  EP=ISPLINK,ERRET=&ERROR\n         LOAD  EP=ISPLINK,ERRET=&ERROR\n         AGO   .LOAD060\n.LOAD050 ANOP  ,\n*        LOAD  EP=ISPLINK,ERRET=&LABEL\n         LOAD  EP=ISPLINK,ERRET=&LABEL\n         ST    R0,&SPFADDR         SAVE ISPLINK ROUTINE ADDRESS\n         B     *+8                 BRANCH AROUND ABEND\n&LABEL   DS    0H\n         EX    0,*                 ABEND S0C3\n         AGO   .MEND\n.LOAD060 ANOP  ,\n         ST    R0,&SPFADDR         SAVE ISPLINK ROUTINE ADDRESS\n         AGO   .MEND\n.**********************************************************************\n.RELO010 ANOP  ,\n         AIF   ('&SAVE' NE '').RELO020\n         MNOTE 8,'SAVE= Not Supplied'\n         AGO   .MEND\n.RELO020 ANOP  ,\n         AIF   ('&LIST' NE '').RELO030\n         MNOTE 8,'LIST= Not Supplied'\n         AGO   .MEND\n.RELO030 ANOP  ,\n&SPFADDR SETC  '&SAVE'\n&SPFCALL SETC  '&LIST'\n         AGO   .MEND\n.**********************************************************************\n.UNLO010 ANOP  ,\n         AIF   ('&SPFADDR' NE  '').UNLO020\n         MNOTE 8,'ISPLINK Was Not Previously Loaded'\n         AGO   .MEND\n.UNLO020 ANOP  ,\n         ICM   R0,15,&SPFADDR      CHECK IF ISPLINK HAS BEEN LOADED\n         BZ    &LABEL              B. IF NOT\n*        DELETE EP=ISPLINK         DELETE ISPLINK ROUTINE\n         DELETE EP=ISPLINK         DELETE ISPLINK ROUTINE\n         XC    &SPFADDR,&SPFADDR   CLEAR ISPLINK ROUTINE ADDRESS\n&LABEL   DS    0H\n         AGO   .MEND\n.**********************************************************************\n.SERVICE ANOP  ,\n         AIF   ('&SPFADDR' EQ  '').NOTLOAD\n         AIF   ('&SPFCALL' NE  '').LOOP010\n.NOTLOAD ANOP  ,\n         MNOTE 8,'ISPLINK Was Not Previously Loaded'\n         AGO   .MEND\n.*------\n.*       CHECK IF SPECIFIED DIALOG SERVICE IS IN CURRENT TABLE\n.*------\n.LOOP010 ANOP  ,\n&SERVICE SETC  '&SYSLIST(1)'\n         AIF   ('&SYSLIST(1)'(1,1) EQ '''').LOOP050\n         AIF   ('&SERVICE' EQ '*').LOOP050\n&I       SETA  0                   INITIALIZE LOOP FACTOR\n.LOOP020 ANOP  ,\n&I       SETA  &I+1                ADD 1 TO COUNTER\n         AIF   (&I LE 255).LOOP030\n         MNOTE 8,'More Than 255 ISPLINK Functions Used'\n         AGO   .MEND\n.LOOP030 ANOP  ,\n         AIF   (&I GT &SPFCNT).LOOP040\n         AIF   ('&SPFVRB(&I)' EQ '&SERVICE').LOOP050\n         AGO   .LOOP020\n.LOOP040 ANOP  ,\n&SPFCNT  SETA  &I\n&SPFVRB(&I) SETC '&SERVICE'\n.LOOP050 ANOP  ,\n&I       SETA  0                   INITIALIZE LOOP FACTOR\n.*------\n.*       CONSTRUCT ISPF DIALOG SERVICES PARAMETER LIST\n.*------\n.NEXTPRM ANOP  ,\n         AIF   (&I GE N'&SYSLIST).ENDLP\n&I       SETA  &I+1\n&N       SETA  4*(&I-1)\n         AIF   (&I EQ 1).VERB\n         AIF   ('&SYSLIST(&I)' EQ '*').NEXTPRM\n         AIF   ('&SYSLIST(&I)' EQ '&SYSLIST(&I-1)').STPARM\n         AIF   ('&SYSLIST(&I)' EQ '').BLANK\n         AIF   ('&SYSLIST(&I)'(1,1) EQ '+').NUMBER\n         AIF   ('&SYSLIST(&I)'(1,1) EQ '-').NUMBER\n         AIF   ('&SYSLIST(&I)'(1,1) EQ '(').REG\n         AIF   ('&SYSLIST(&I)'(1,1) EQ '''').LITERAL\n         AIF   (T'&SYSLIST(&I) EQ 'N').NUMBER\n         AIF   ('&SYSLIST(&I)'(2,1) EQ '(').ADCON\n         AIF   ('&SYSLIST(&I)'(2,1) EQ '''').NUMBER\n         IHBSETR &SYSLIST(&I),R0\n         AGO   .STPARM\n.VERB    ANOP  ,\n         AIF   ('&SYSLIST(&I)'(1,1) EQ '''').LITERAL\n         LA    R0,&VERB            LOAD VERB ADDRESS\n         AGO   .STPARM\n.LITERAL LA    R0,=C&SYSLIST(&I)   LOAD PARAMETER ADDRESS\n         AGO   .STPARM\n.BLANK   LA    R0,0                NULL PARAMETER ADDRESS\n         AGO   .STPARM\n.REG     LR    R0,&SYSLIST(&I)     LOAD PARAMETER ADDRESS\n         AGO   .STPARM\n.ADCON   LA    R0,=&SYSLIST(&I)    LOAD PARAMETER ADDRESS\n         AGO   .STPARM\n.NUMBER  LA    R0,=A(&SYSLIST(&I)) LOAD PARAMETER ADDRESS\n.STPARM  ST    R0,&SPFCALL+&N\n         AGO   .NEXTPRM\n.ENDLP   AIF   (&I GT N'&SYSLIST).CALL\n         AIF   ('&SYSLIST(&I)' EQ '').CALL\n         OI    &SPFCALL+&N,128     SET END OF PARAMETER LIST\n.*------\n.*       CALL THE DIALOG SERVICE ROUTINE\n.*------\n.CALL    ANOP  ,\n         LA    R1,&SPFCALL         LOAD ISPLINK PARAMETER LIST ADDRESS\n         L     R15,&SPFADDR        LOAD ISPLINK ROUTINE ADDRESS\n         BALR  R14,R15             CALL ISPF DIALOG MANAGER SERVICES\n.*------\n.*       PROCESS THE RETURN CODE\n.*------\n         AIF ('&ERROR' EQ '' AND '&OK' EQ '').MEND\n         LTR   R15,R15             CHECK ISPLINK RETURN CODE\n         AIF   ('&OK' EQ '').AFTER1\n         BZ    &OK                 B. IF SUCCESSFUL\n.AFTER1  ANOP  ,\n         AIF   ('&ERROR' EQ '').MEND\n         AIF   ('&ERROR' EQ '*').AFTER2\n         BNZ   &ERROR              B. IF ERROR\n         AGO   .MEND\n.AFTER2  ANOP  ,\n         AIF   ('&OK' NE '').AFTER3\n         BZ    *+8                 B. IF SUCCESSFUL\n.AFTER3  ANOP  ,\n         EX    0,*                 ELSE. ABEND S0C3\n         AGO   .MEND\n.**********************************************************************\n.EXPAND  ANOP  ,\n&I       SETA  0\n.EXLOOP  ANOP  ,\n&I       SETA  &I+1\n         AIF   (&I GT &SPFCNT).RESET\n&SERVICE SETC  '&SPFVRB(&I)'\n&SERVICE DC    CL8'&SPFVRB(&I)'  . *** ISPF CONSTANT ***\n         AGO   .EXLOOP\n.RESET   ANOP  ,\n&SPFCNT  SETA  0\n         AGO   .MEND\n.MEND    MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MASK": {"ttr": 2817, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00z\\x00z\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 122, "newlines": 122, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    MASK  &MASKADR,                SYMBOLIC ADDRESS OF MASK       X\n               &DATAADR,                SYMBOLIC ADDRESS OF DATA       X\n               &MASKLEN,                MAX. LENGTH OF MASK            X\n               &DATALEN                 MAX. LENGTH OF DATA\n         LCLC  &X\n&X       SETC  '&SYSNDX'\n&NAME    STM   0,14,SAVE&X              SAVE REGISTERS\n         SR    15,15                    INITIALIZE R15 TO 0\n         SR    6,6                      INITIALIZE MASK PTR. TO 0\n         SR    7,7                      INITIALIZE DATA PTR. TO 0\n         SR    8,8                      CLEAR REG 8\n         SR    9,9                      CLEAR REG 9\n         MVI   BWFL&X,0\n         IC    8,&MASKADR.(6)           PUT FIRST MASK CHAR IN REG 8\n         IC    9,&DATAADR.(7)           PUT FIRST DATA CHAR IN REG 9\n.AIF1    AIF   (T'&MASKLEN EQ 'N').LA1\n         L     4,&MASKLEN               PUT MAX LENGTH OF MASK IN REG 4\n         AGO   .AIF2\n.LA1     LA    4,&MASKLEN               PUT MAX LENGTH OF MASK IN REG 4\n.AIF2    AIF   (T'&DATALEN EQ 'N').LA2\n         L     5,&DATALEN               PUT MAX LENGTH OF DATA IN REG 5\n         AGO   .AIF3\n.LA2     LA    5,&DATALEN               PUT MAX LENGTH OF DATA IN REG 5\n.AIF3    ANOP  ,\n         CLM   8,1,=C' '                DOES MASK HAVE LEADING BLANKS?\n         BE    SKIP&X                   YES..SKIP LEADING MASK BLANKS\n\nFTST&X   CLM   8,1,=C'?'                IS CURRENT MASK CHAR. A '?' ?\n         BE    BKWD&X               YES..GO HANDLE BACKWARD PROCESSING\n         CLM   8,1,=C'*'                IS CURRENT MASK CHAR. AN '*'?\n         BE    ASTR&X                   YES..GO DO * PROCESSING\n         CLR   8,9                      IS MASK CHAR EQUAL TO DATA\n*                                       CHAR?\n         BE    ADJP&X                   YES..GO ADJUST PTRS TO NEXT\n*                                       MASK CHAR AND DATA CHAR\n         LA    15,4                     NO..SET RETURN CODE\n         B     EXIT&X                   GO EXIT\n\n***********************************************************************\n*              SKIP ANY LEADING BLANKS IN MASK                        *\n***********************************************************************\n\nSKIP&X   IC    8,&MASKADR.(6)           PUT MASK CHAR IN REG 8\n         CLM   8,1,=C' '                IS MASK CHAR BLANK?\n         BNE   FTST&X                   NO..GO CONTINUE PROCESSING\n         LA    6,1(,6)                  YES..POINT TO NEXT CHAR\n         CR    6,4                      IS THIS THE END OF THE MASK?\n         BNE   SKIP&X                   NO..CONTINUE\n         LA    15,16                    YES..MASK IS ALL BLANK..SET RET\n         B     EXIT&X                   CODE AND GO EXIT\n\n***********************************************************************\n*   ? FOUND IN MASK..ELIMINATE TRAILING BLANKS IN MASK AND DATA,      *\n*   AND BEGIN PROCESSING FROM END OF BOTH FIELDS. WHEN ? ENCOUNTERED  *\n*   AGAIN..PROCESSING COMPLETE.                                       *\n***********************************************************************\n\nBKWD&X   TM    BWFL&X,X'80'             ARE WE GOING BACKWARDS ALREADY?\n         BZ    STBK&X                NO..INITIATE BACKWARD PROCESSING\n         CR    3,6                      YES..IS IT THE SAME '?'  ?\n         BE    EXIT&X                   YES..OK..EXIT\n         LA    15,16                NO..MORE THAN ONE ? IN MASK..ERROR\n         B     EXIT&X                   GO EXIT\nSTBK&X   OI    BWFL&X,X'80'             SET BACKWARD INDICATOR\n         LR    3,6                      STORE PTR TO ? IN MASK\n***********************************************************************\n*            ELIMINATE TRAILING BLANKS IN MASK AND DATA               *\n***********************************************************************\n         LR    6,4                      LOAD MAXIMUM LENGTH OF MASK\n         LR    7,5                      LOAD MAXIMUM LENGTH OF DATA\nMASK&X   BCTR  6,0                      DECREASE MAXIMUM LENGTH OF MASK\n         IC    8,&MASKADR.(6)           PUT MASK CHAR IN REG 8\n         CLM   8,1,=C' '                IS MASK CHAR. BLANK?\n         BE    MASK&X                   YES..GO CHECK NEXT ONE\nMEMB&X   BCTR  7,0                      DECREASE MAXIMUM LENGTH OF DATA\n         IC    9,&DATAADR.(7)           PUT DATA CHAR IN REG 9\n         CLM   9,1,=C' '                IS DATA CHAR. BLANK?\n         BNE   FTST&X                   NO..GO CONTINUE PROCESSING..ALL\n*                                       TRAILING BLANKS ELIMINATED\n         LTR   7,7                      ARE WE AT BEGINNING OF DATA?\n         BNZ   MEMB&X                   NO..GO CHECK NEXT CHAR\n         LA    15,4                 YES..DATA IS ALL BLANKS..SET RET\n         B     EXIT&X                   CODE AND EXIT\n\n***********************************************************************\n*                      * FOUND IN MASK                                *\n***********************************************************************\n\nASTR&X   CLM   9,1,=C' '                IS DATA CHAR BLANK?\n         BNE   ADJP&X                NO..MATCH OK..GO ADJUST PTRS\n         LA    15,4                     YES..NO MATCH..SET RETURN CODE\n         B     EXIT&X                   AND GO EXIT\n\n***********************************************************************\n*   INCREASE OR DECREASE PTRS DEPENDING ON WHETHER PROCESSING         *\n*   BACKWARDS OR FORWARDS                                             *\n***********************************************************************\n\nADJP&X   TM    BWFL&X,X'80'             PROCESSING BACKWARDS?\n         BZ    INCR&X                   NO..GO INCREASE PTRS\n         BCTR  6,0                      YES..DECREASE PTRS\n         BCTR  7,0\n         IC    8,&MASKADR.(6)           PUT MASK CHAR IN REG 8\n         IC    9,&DATAADR.(7)           PUT DATA CHAR IN REG 9\n         B     FTST&X                   CONTINUE PROCESSING\n\nINCR&X   LA    6,1(,6)                  INCREASE MASK PTR\n         CR    6,4                      END OF MASK?\n         BE    EXIT&X                   YES..FINISHED..GO EXIT\n         IC    8,&MASKADR.(6)           PUT MASK CHAR IN REG 8\n         CLM   8,1,=C' '                IS MASK CHAR BLANK?\n         BE    EXIT&X                   YES..FINISHED..GO EXIT\n         LA    7,1(,7)                  NO..INCREASE DATA PTR\n         IC    9,&DATAADR.(7)           PUT DATA CHAR IN REG 9\n         B     FTST&X                   GO CONTINUE PROCESSING\n\nBWFL&X   DC    X'00'\nSAVE&X   DS    15F\n\nEXIT&X   LM    0,14,SAVE&X              RESTORE REGISTERS\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPBFRG": {"ttr": 5635, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00\"\\x00\"\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:58", "lines": 34, "newlines": 34, "modlines": 0, "user": "MACRO"}, "text": "         LCLC  &LABEL,&R1,&R14,&R15\n         GBLC  &RCPBFRP,&RCPBFR1,&RCPBFR2,&RCPBFSP\n         AIF   ('&BUFPTR' EQ '').BFRTGP\n&RCPBFRP SETC  '&BUFPTR'\n         AGO   .BFRTWK1\n.BFRTGP  AIF   ('&RCPBFRP' NE '').BFRTWK1\n&RCPBFRP SETC  'R1'\n.BFRTWK1 AIF   ('&WKREGS(1)' EQ '').BFRTG1\n&RCPBFR1 SETC  '&WKREGS(1)'\n         AGO   .BFRTWK2\n.BFRTG1  AIF   ('&RCPBFR1' NE '').BFRTWK2\n&RCPBFR1 SETC  'R14'\n.BFRTWK2 AIF   ('&WKREGS(2)' EQ '').BFRTG2\n&RCPBFR2 SETC  '&WKREGS(2)'\n         AGO   .BFRG1\n.BFRTG2  AIF   ('&RCPBFR2' NE '').BFRG1\n&RCPBFR2 SETC  'R15'\n.BFRG1   ANOP\n         AIF   ('&SPACE' EQ '').BFRG2\n&RCPBFSP SETC  '&SPACE'\n.BFRG2   ANOP\n&LABEL   SETC  '&NAME'\n&R1      SETC  '&RCPBFRP'\n&R14     SETC  '&RCPBFR1'\n&R15     SETC  '&RCPBFR2'\n.BFRTBUF AIF   ('&BUFFER' EQ '').BFRGXIT\n         AIF   ('&BUFFER'(1,1) EQ '(').RBUF\n&LABEL   LA    &R1,&BUFFER             LOAD BUFFER ADDRESS\n&LABEL   SETC  ''\n         AGO   .BFRGXIT\n.RBUF    ANOP\n&LABEL   LR    &R1,&BUFFER(1)          LOAD BUFFER ADDRESS\n&LABEL   SETC  ''\n.BFRGXIT ANOP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPBFRGS": {"ttr": 5637, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00\\x13\\x00\\x13\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:58", "lines": 19, "newlines": 19, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPBFRGS &BUFPTR,&WKREGS\n         GBLC  &RCPBFRP,&RCPBFR1,&RCPBFR2\n         AIF   ('&BUFPTR' EQ '').TGP\n&RCPBFRP SETC  '&BUFPTR'\n         AGO   .TWK1\n.TGP     AIF   ('&RCPBFRP' NE '').TWK1\n&RCPBFRP SETC  'R1'\n.TWK1    AIF   ('&WKREGS(1)' EQ '').TG1\n&RCPBFR1 SETC  '&WKREGS(1)'\n         AGO   .TWK2\n.TG1     AIF   ('&RCPBFR1' NE '').TWK2\n&RCPBFR1 SETC  'R14'\n.TWK2    AIF   ('&WKREGS(2)' EQ '').TG2\n&RCPBFR2 SETC  '&WKREGS(2)'\n         MEXIT\n.TG2     AIF   ('&RCPBFR2' NE '').EXIT\n&RCPBFR2 SETC  'R15'\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPBFSP": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x082o\\x01\\x082o!\\x10\\x00\\t\\x00\\t\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:44", "lines": 9, "newlines": 9, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPBFSP\n         GBLC  &RCPBFSP\n         AIF   ('&RCPBFSP' EQ '0').MEND\n         AIF   ('&RCPBFSP' EQ '').NULL\n         SPACE &RCPBFSP\n         MEXIT\n.NULL    SPACE\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPBTU": {"ttr": 5639, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00\\x11\\x00\\x11\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:58", "lines": 17, "newlines": 17, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPBTU &KEY,&NUM,&PAR\n         LCLA  &L\n.*\n.*  INNER MACRO FOR ALLOC, TO GENERATE TEXT UNITS ENTERED\n.*  IN QUOTES\n.*\n&L       SETA  K'&PAR-2                GET LENGTH OF TEXT UNIT\n         MVI   S99TUKEY+1,&KEY         SET TEXT UNIT KEY\n         MVI   S99TUNUM+1,&NUM         SET NUMBER FIELD\n         MVI   S99TULNG+1,&L           MOVE IN LENGTH\n         MVC   S99TUPAR(&L.),=C&PAR    MOVE IN TEXT UNIT\n&L       SETA  &L+6\n         AIF   (&L/2 EQ (&L+1)/2).LOK\n&L       SETA  &L+1\n.LOK     RCPDINC &L\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPBTU2": {"ttr": 5641, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00\\x13\\x00\\x13\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 19, "newlines": 19, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPBTU &KEY,&NUM,&PAR\n         GBLA  &DTUPO\n         GBLC  &DYNP\n         LCLA  &L\n.*\n.*  INNER MACRO FOR ALLOC, TO BRANCH AROUND TEXT UNIT AND\n.*  CREATE TEXT UNIT\n.*\n&L       SETA  K'&PAR+8                GET LENGTH TO BRANCH AROUND\n         AIF   (&L/2 EQ (&L+1)/2).LOK  MAKE SURE LENGTH IS EVEN\n&L       SETA  &L+1\n.LOK     BAL   R14,*+&L                BRANCH AROUND TEXT UNIT\n&L       SETA  K'&PAR-2\n         DC    Y(&KEY,&NUM,&L),C&PAR   TEXT UNIT\n         LA    R14,0(R14)              CLEAR HIGH ORDER BYTE\n         ST    R14,&DYNP.TUP+&DTUPO    STORE TEXT UNIT ADDRESS\n&DTUPO   SETA  &DTUPO+4\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPCHARS": {"ttr": 4865, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x004\\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00\\x18\\x00\\x18\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:34", "lines": 24, "newlines": 24, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         RCPCHARS &CHARS\n         LCLA  &I,&N\n         LCLC  &V\n         AIF   ('&CHARS(1)' EQ '').EXIT\n***********************************************************************\n**       Character Set Text Unit                                     **\n***********************************************************************\n         MVC   S99TUKEY,=AL2(DALCHARS) Set Key\n&N       SETA  (N'&CHARS)\n         MVI   S99TUNUM+1,&N           Set Count\n         RCPDBUMP 4                    Advance To 1st CHARS Slot\n&N       SETA  (&N+1)              Stop When Less Than Count\n&I       SETA  1                   Initialize Index Counter\n.LOOP    ANOP  ,\n         AIF   ('&CHARS(&I)' EQ '').EXIT\n&V       SETC  '=CL4''&CHARS(&I)'''\n         MVI   S99TULNG+1-S99TUENT(R15),4\n         MVC   S99TUPAR-S99TUENT(4,R15),&V\n         RCPDBUMP 6                    Advance To Next CHARS Slot\n&I       SETA  (&I+1)\n         AIF   (&I LT &N).LOOP\n         RCPDINC ,\n.EXIT    MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RCPCKID": {"ttr": 5643, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00-\\x00-\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 45, "newlines": 45, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&NAME    RCPCKID              &CHECKID\n         GBLB  &RCPECT(2),&RCPPSCB(2)\n         GBLC  &RCPPRE\n         LCLC  &CHARVAR,&P\n         LCLA  &COUNTR,&L\n&P       SETC  '&RCPPRE'\n&RCPPSCB(1) SETB  1\n&RCPECT(1)  SETB  1\n         EJECT\n         SPACE 4\n***********************************************************************\n***  THE USERID OF THE USER IS CHECKED. IF IT IS NOT VALID, THE    ****\n***   COMMAND PRETENDS IT DOES NOT EXIST BY LINKING TO EXEC IN     ****\n***   THE SAME WAY THE TMP DOES IF IT CANNOT FIND THE COMMAND.     ****\n***********************************************************************\n         SPACE 3\n         L     R1,CPPLPSCB             LOAD ADDRESS OF PSCB\n         USING PSCB,R1                 PSCB ADDRESSABILITY\n.NID     ANOP\n&COUNTR  SETA  &COUNTR+1\n         AIF   ('&CHECKID(&COUNTR)' EQ '').ENDID\n&CHARVAR SETC  '&CHECKID(&COUNTR)'\n&L       SETA  K'&CHARVAR\n         AIF   ('&CHARVAR'(1,1) EQ '''').QCID\n         CLC   PSCBUSER(&L),=C'&CHARVAR'  IS THE USERID VALID?\n         BE    &P.IDOK                     YES, BRANCH OUT\n         AGO   .NID\n.QCID    ANOP\n&L       SETA  &L-2\n         CLC   PSCBUSER(&L),=C&CHARVAR    IS THE USERID VALID?\n         BE    &P.IDOK                     YES, BRANCH OUT\n         AGO   .NID\n.ENDID   L     R1,CPPLECT              LOAD ECT ADDRESS\n         SPACE 2\n         USING ECT,R1\n         MVC   ECTPCMD,&P.EXECN        MOVE IN COMMAND NAME\n         DROP  R1                      KILL ECT ADDRESSABILITY\n         L     R1,CPPLCBUF             LOAD CBUF ADDRESS\n         XC    2(2,R1),2(R1)           ZERO OFFSET FIELD\n         L     R1,&P.CPPL              RELOAD CPPL ADDRESS\n         XCTL  EPLOC=&P.EXECN\n&P.EXECN DC    CL8'EXEC'               NAME OF EXEC PROCESSOR\n&P.IDOK  DS    0H\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPDBUMP": {"ttr": 4867, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x004\\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00\\x06\\x00\\x06\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:34", "lines": 6, "newlines": 6, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    RCPDBUMP &L1\n         GBLA  &DTUO\n         AHI   R15,&L1.                Advance To Next TU Slot\n&DTUO    SETA  &DTUO+&L1\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RCPDCLAS": {"ttr": 5645, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00\\t\\x00\\t\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 9, "newlines": 9, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPDCLAS &DCLAS\n         GBLC  &DYNP\n         SPACE 1\n***********************************************************************\n**   BUILD THE DATACLAS TEXT UNIT                                    **\n***********************************************************************\n.BTU     RCPTUBFX DALDACL,14,&DCLAS\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPDDCB": {"ttr": 5647, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00\\x9e\\x00\\x9e\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 158, "newlines": 158, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPDDCB &LRECL=,&DEN=,&RECFM=,&BLKSIZE=,&DSORG=,&KEYLEN=\n.**********************************************************************\n.*                                                                    *\n.* HISTORY OF UPDATES:                                                *\n.*          #ON62764 - FIXING A BUG IN THE DSORG=PO BRANCH.      (ON) *\n.*                                                                    *\n.**********************************************************************\n         GBLC  &DYNP\n         LCLC  &C\n         LCLA  &CTR,&K\n         AIF   ('&LRECL' EQ '').BLK\n***********************************************************************\n**   DCB LRECL TEXT UNIT                                             **\n***********************************************************************\n         MVI   S99TUKEY+1,DALLRECL      SET LRECL KEY\n         MVI   S99TUNUM+1,1             SET NUMBER FIELD\n         MVI   S99TULNG+1,2             SET LENGTH FIELD\n         AIF   (T'&LRECL NE 'N').LA\n         MVC   S99TUPAR(2),=AL2(&LRECL.)    MOVE LRECL TO TEXT UNIT\n         AGO   .LD\n.LA      MVC   S99TUPAR(2),&LRECL       MOVE LRECL TO TEXT UNIT\n.LD      RCPDINC 8\n         SPACE\n.BLK     AIF   ('&BLKSIZE' EQ '').KEY\n***********************************************************************\n**   DCB BLKSIZE TEXT UNIT                                           **\n***********************************************************************\n         MVI   S99TUKEY+1,DALBLKSZ      SET BLKSIZE KEY\n         MVI   S99TUNUM+1,1             SET NUMBER FIELD\n         MVI   S99TULNG+1,2             SET LENGTH FIELD\n         AIF   (T'&BLKSIZE NE 'N').BA\n         MVC   S99TUPAR(2),=AL2(&BLKSIZE)    MOVE BLKSIZE TO TEXT UNIT\n         AGO   .BD\n.BA      MVC   S99TUPAR(2),&BLKSIZE     MOVE BLKSIZE TO TEXT UNIT\n.BD      RCPDINC 8\n         SPACE\n.KEY     AIF   ('&KEYLEN' EQ '').DEN\n***********************************************************************\n**   DCB KEYLEN TEXT UNIT                                            **\n***********************************************************************\n         MVI   S99TUKEY+1,DALKYLEN      SET KEYNEN KEY\n         MVI   S99TUNUM+1,1             SET NUMBER FIELD\n         MVI   S99TULNG+1,1             SET LENGTH FIELD\n         AIF   (T'&KEYLEN NE 'N').KA\n         MVC   S99TUPAR(1),=AL1(&KEYLEN)   MOVE KEYLEN TO TEXT UNIT\n         AGO   .KD\n.KA      MVC   S99TUPAR(1),&KEYLEN      MOVE KEYLEN TO TEXT UNIT\n.KD      RCPDINC 8\n         SPACE\n.DEN     AIF   ('&DEN' EQ '').DSO\n***********************************************************************\n**   DCB   DEN  TEXT UNIT                                            **\n***********************************************************************\n         MVI   S99TUKEY+1,DALDEN        SET  DEN  KEY\n         MVI   S99TUNUM+1,1             SET NUMBER KEY\n         MVI   S99TULNG+1,1             SET LENGTH KEY\n         AIF   (T'&DEN NE 'N').DA\n         AIF   ('&DEN' EQ '0').D1\n&DYNP.DEN EQU   X'03'\n         AGO   .DM\n.D1      AIF   ('&DEN' GT '1').D2\n&DYNP.DEN EQU   X'43'\n         AGO   .DM\n.D2      AIF   ('&DEN' GT '2').D3\n&DYNP.DEN EQU   X'83'\n         AGO   .DM\n.D3      AIF   ('&DEN' GT '3').D4\n&DYNP.DEN EQU   X'C3'\n         AGO   .DM\n.D4      AIF   ('&DEN' NE '4').DE\n&DYNP.DEN EQU   X'D3'\n.DM      MVI   S99TUPAR,&DYNP.DEN       MOVE DENSITY TO TEXT UNIT\n         AGO   .DD\n.DE      MNOTE 8,'&DEN IS INVALID DENSITY,IT IS IGNORED'\n         AGO   .DSO\n.DA      MVC   S99TUPAR(1),&DEN         MOVE DENSITY TO TEXT UNIT\n.DD      RCPDINC 8\n         SPACE\n.DSO     AIF   ('&DSORG' EQ '').REC\n***********************************************************************\n**   DCB DSORG TEXT UNIT                                             **\n***********************************************************************\n         MVI   S99TUKEY+1,DALDSORG      SET DSORG KEY\n         MVI   S99TUNUM+1,1             SET NUMBER FIELD\n         MVI   S99TULNG+1,2             SET LENGTH FIELD\n         AIF   (T'&DSORG NE 'U').DSA\n         AIF   ('&DSORG' NE 'PS').DS2\n&C       SETC  '=X''4000'''\n         AGO   .DSM\n.DS2     AIF   ('&DSORG' NE 'PSU').DS3\n&C       SETC  '=X''4100'''\n         AGO   .DSM\n.DS3     AIF   ('&DSORG' NE 'DA').DS4\n&C       SETC  '=X''2000'''\n         AGO   .DSM\n.DS4     AIF   ('&DSORG' NE 'DAU').DS5\n&C       SETC  '=X''2100'''\n         AGO   .DSM\n.DS5     AIF   ('&DSORG' NE 'PO').DS6\n&C       SETC  '=X''0200'''                                    #ON62764\n         AGO   .DSM\n.DS6     AIF   ('&DSORG' NE 'POU').DSE\n&C       SETC  '=X''0300'''\n.DSM     MVC   S99TUPAR(2),&C           MOVE DSORG TEXT UNIT\n         AGO   .DSD\n.DSE     MNOTE 8,'&DSORG INVALID,IT IS IGNORED'\n         AGO   .REC\n.DSA     MVC   S99TUPAR(2),&DSORG       MOVE DSORG TEXT UNIT\n.DSD     RCPDINC 8\n         SPACE\n.REC     AIF   ('&RECFM' EQ '').EXIT\n**********************************************************************\n**   DCB RECFM TEXT UNIT                                             **\n***********************************************************************\n         MVI   S99TUKEY+1,DALRECFM      SET RECFM KEY\n         MVI   S99TUNUM+1,1             SET NUMBER FIELD\n         MVI   S99TULNG+1,1             SET LENGTH FIELD\n         AIF   (T'&RECFM NE 'U').RA\n&K       SETA  1\n.LOOP    ANOP\n&C       SETC  '&RECFM'(&K,1)\n         AIF   ('&C' NE 'M' AND '&C' NE 'R').R2\n&CTR     SETA  &CTR+2\n         AGO   .ELOOP\n.R2      AIF   ('&C' NE 'A' AND '&C' NE 'G').R3\n&CTR     SETA  &CTR+4\n         AGO   .ELOOP\n.R3      AIF   ('&C' NE 'S').R4\n&CTR     SETA  &CTR+8\n         AGO   .ELOOP\n.R4      AIF   ('&C' NE 'B').R5\n&CTR     SETA  &CTR+16\n         AGO   .ELOOP\n.R5      AIF   ('&C' NE 'D' AND '&C' NE 'T').R6\n&CTR     SETA  &CTR+32\n         AGO   .ELOOP\n.R6      AIF   ('&C' NE 'V').R7\n&CTR     SETA  &CTR+64\n         AGO   .ELOOP\n.R7      AIF   ('&C' NE 'F').R8\n&CTR     SETA  &CTR+128\n         AGO   .ELOOP\n.R8      AIF   ('&C' NE 'U').RE\n&CTR     SETA  &CTR+192\n.ELOOP   AIF (&K EQ K'&RECFM).RX\n&K       SETA  &K+1\n         AGO   .LOOP\n.RX      ANOP\n&DYNP.RECF EQU   &CTR\n         MVI   S99TUPAR,&DYNP.RECF MOVE RECFM TO TEXT UNIT\n         AGO   .RD\n.RE      MNOTE 8,'&RECFM INVALID,IT IS IGNORED'\n         AGO   .EXIT\n.RA      MVC   S99TUPAR(1),&RECFM       MOVE RECFM TO TEXT UNIT\n.RD      RCPDINC 8\n         SPACE\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPDDN": {"ttr": 5649, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00\\x1b\\x00\\x1b\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 27, "newlines": 27, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPDDN &DDN\n         GBLC  &DYNP\n         SPACE 1\n***********************************************************************\n**   BUILD THE DDNAME TEXT UNIT                                      **\n***********************************************************************\n         AIF   ('&DDN'(K'&DDN,1) EQ '/').BTU\n         AIF   ('&DDN'(1,1) EQ '''').Q\n         RCPSR2\n         AIF   ('&DDN'(1,1) EQ '(').R\n         L     R14,&DDN                LOAD ADDRESS OF DDNAME\n         LH    R2,&DDN+4               LOAD LENGTH OF DDNAME\n         AGO   .STH\n.R       L     R14,0&DDN               LOAD ADDRESS OF DDNAME\n         LH    R2,4&DDN                LOAD LENGTH OF DDNAME\n.STH     STH   R2,S99TULNG             STORE DDNAME LENGTH\n         BCTR  R2,0                    DECREMENT FOR EXECUTE\n         EX    R2,&DYNP.MVC            MOVE DDNAME\n         MVI   S99TUKEY+1,DALDDNAM     MOVE IN DDNAME KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         RCPDINC 14\n         MEXIT\n.Q       RCPBTU DALDDNAM,1,&DDN\n         MEXIT\n.BTU     RCPTUBFR DALDDNAM,14,&DDN\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPDDNRT": {"ttr": 5651, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00\\r\\x00\\r\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 13, "newlines": 13, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPDDNRT\n         SPACE 1\n***********************************************************************\n**    DDNAME RETURN TEXT UNIT                                        **\n***********************************************************************\n         MVI   S99TUKEY+1,DALRTDDN     SET RETURN DDNAME KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         MVI   S99TULNG+1,8            SET LENGTH FIELD\n         MVI   S99TUPAR,C' '           INITIALIZE FIELD TO BLANKS\n         MVC   S99TUPAR+1(8-1),S99TUPAR\n         RCPDINC 14\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPDEBUG": {"ttr": 5653, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00\\x13\\x00\\x13\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 19, "newlines": 19, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPDEBUG &ON\n         GBLA  &RCPBGN#,&RCPSWS(10)\n         GBLB  &RCPDBUG\n         GBLC  &RCPPRE,&RCPWKDS,&RCPWKCS\n         AIF   ('&ON' EQ '').TSW\n&RCPDBUG SETB 1\n.TSW     AIF   (&RCPDBUG).DEBUG\n         MEXIT\n.DEBUG   MNOTE *,'RCPBGN# IS &RCPBGN#'\n         MNOTE *,'RCPSWS(1) IS &RCPSWS(1)'\n         MNOTE *,'RCPSWS(2) IS &RCPSWS(2)'\n         MNOTE *,'RCPSWS(3) IS &RCPSWS(3)'\n         MNOTE *,'RCPSWS(4) IS &RCPSWS(4)'\n         MNOTE *,'RCPSWS(5) IS &RCPSWS(5)'\n         MNOTE *,'RCPWKCS IS ''&RCPWKCS'''\n         MNOTE *,'RCPWKDS IS ''&RCPWKDS'''\n         MNOTE *,'RCPPRE IS ''&RCPPRE'''\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPDEFER": {"ttr": 5655, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00\\t\\x00\\t\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 9, "newlines": 9, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPDEFER\n         SPACE\n***********************************************************************\n**     DEFER VOLUME MOUNT TEXT ATTRIBUTE UNIT                        **\n***********************************************************************\n         MVI   S99TUKEY+1,DALDEFER     SET TEXT UNIT KEY\n         RCPDINC  4\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPDFPL": {"ttr": 5657, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x000\\x000\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 48, "newlines": 48, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPDFPL\n         GBLC  &RCPPRE\n         GBLC  &STPREF\n         GBLB  &RCPDFPL(2)\n         GBLB  &RCPDFPB(2)\n         LCLC  &P,&L,&L1\n         EJECT\n         AIF   ('&RCPPRE' NE '').BYPPREF\n&RCPPRE  SETC  '&STPREF'               SET TO #START PREFIX\n.BYPPREF AIF   (&RCPDFPL(2)).BYPDFPL\n&RCPDFPL(1) SETB 1\n&RCPDFPL(2) SETB 1\n&P       SETC  '&RCPPRE'\n         IKJDFPL\nL#DFPL   EQU   *-DFPL                  LENGTH OF DEFAULT PARAM LIST\n         IKJDFPB\nL#DFPB   EQU   *-DFPB                  LENGTH OF DEFAULT PARAM BLOCK\n&SYSECT  CSECT                         RESUME PROGRAM CSECT\n         SPACE 3\n.BYPDFPL RCPDS\n&P.DFPL  DS    CL(L#DFPL)              RESERVE SPACE FOR DFPL\n&P.DFPB  DS    CL(L#DFPB)              RESERVE SPACE FOR DFPB\n&P.DSNB  DS    CL48                    RESERVE SPACE FOR DSNAME BUFFER\n         RCPDS\n         EJECT\n.**********************************************************************\n.**   THIS CODE GENERATES AN DEFAULT SERVICE ROUTINE PARAMETER LIST ***\n.**       AND PARAMETER BLOCK                                       ***\n.**********************************************************************\n         LA    R1,&P.DFPL              LOAD DFPL ADDRESS\n         USING DFPL,R1                 DFPL ADDRESSABLE\n         MVC   DFPLUPT,CPPLUPT         MOVE IN ADDRESS OF UPT\n         MVC   DFPLECT,CPPLECT         MOVE IN ADDRESS OF ECT\n         LA    R15,&P.ECB              LOAD ADDRESS OF ATTN ECB\n         ST    R15,DFPLECB             AND STORE IN DFPL\n         LA    R15,&P.DFPB             LOAD DFBP ADDRESS\n         ST    R15,DFPLDFPB             AND STORE IT IN DFPB\n         DROP  R1\n         USING DFPB,R15                ADDRESS DFPB DSECT\n         XC    DFPB(L#DFPB),DFPB       CLEAR DEFAULT PARAMETER BLOCK\n         MVC   DFPBPSCB,CPPLPSCB       MOVE IN ADDRESS OF PSCB\n         LA    R1,&P.DSNB              LOAD DSNAME BUFFER ADDRESS\n         ST    R1,DFPBDSN               AND STORE IT INTO DFPB\n         MVI   DFPBCODE,DFPB04          SET ENTRY CODE\n         DROP  R15                     DFPB NO LONGER ADDRESSABLE\n         EJECT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPDINC": {"ttr": 5659, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00\\r\\x00\\r\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 13, "newlines": 13, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPDINC &L1\n         GBLA  &DTUO,&DTUPO\n         GBLC  &DYNP\n         AIF   ('&L1' EQ '').T2\n         ST    R15,&DYNP.TUP+&DTUPO    STORE TEXT UNIT ADDRESS\n         LA    R15,&L1.(R15)           BUMP TEXT UNIT PTR TO NEXT SLOT\n&DTUPO   SETA  &DTUPO+4\n&DTUO    SETA  &DTUO+&L1\n         MEXIT\n.T2      ST    R14,&DYNP.TUP+&DTUPO    STORE TEXT UNIT ADDRESS\n&DTUPO   SETA  &DTUPO+4\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPDISP": {"ttr": 5889, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x005\\x005\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 53, "newlines": 53, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPDISP &DISP\n         LCLA  &I\n         LCLB  &B(4)\n         AIF   ('&DISP(1)' EQ '').TD2\n         SPACE\n***********************************************************************\n**     DATA SET INITIAL STATUS                                       **\n***********************************************************************\n&B(1)    SETB  ('&DISP(1)' EQ 'SHR')\n&B(2)    SETB  ('&DISP(1)' EQ 'NEW')\n&B(3)    SETB  ('&DISP(1)' EQ 'MOD')\n&B(4)    SETB  ('&DISP(1)' EQ 'OLD')\n         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK1\n         MNOTE 8,'&DISP(1) IS INVALID, DISP=SHR USED'\n&B(1)    SETB  1\n.OK1     ANOP\n&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)\n         MVC   S99TUKEY(8),=Y(DALSTATS,1,1,X'0&I.00')\n         RCPDINC 8\n.TD2     AIF   ('&DISP(2)' EQ '').TD3\n         SPACE\n***********************************************************************\n**    DATA SET NORMAL DISPOSITION                                    **\n***********************************************************************\n&B(1)    SETB  ('&DISP(2)' EQ 'KEEP')\n&B(2)    SETB  ('&DISP(2)' EQ 'DELETE')\n&B(3)    SETB  ('&DISP(2)' EQ 'CATLG')\n&B(4)    SETB  ('&DISP(2)' EQ 'UNCATLG')\n         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK2\n         MNOTE 8,'&DISP(2) IS INVALID, DISP=(,KEEP) USED'\n&B(1)    SETB  1\n.OK2     ANOP\n&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)\n         MVC   S99TUKEY(8),=Y(DALNDISP,1,1,X'0&I.00')\n         RCPDINC 8\n.TD3     AIF   ('&DISP(3)' EQ '').EXIT\n         SPACE\n***********************************************************************\n**   DATASET CONDITIONAL DISPOSITION                                 **\n***********************************************************************\n&B(1)    SETB  ('&DISP(3)' EQ 'KEEP')\n&B(2)    SETB  ('&DISP(3)' EQ 'DELETE')\n&B(3)    SETB  ('&DISP(3)' EQ 'CATLG')\n&B(4)    SETB  ('&DISP(3)' EQ 'UNCATLG')\n         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK3\n         MNOTE 8,'&DISP(3) IS INVALID, DISP=(,,KEEP) USED'\n&B(1)    SETB  1\n.OK3     ANOP\n&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)\n         MVI   S99TUKEY(8),=Y(DALCDISP,1,1,X'0&I.00')\n         RCPDINC 8\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPDS": {"ttr": 5891, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00\\x1a\\x00\\x1a\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 26, "newlines": 26, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPDS\n         GBLB  &RCPDSBR\n         GBLC  &RCPWKDS,&RCPWKCS,&RCPDS\n         AIF   ('&RCPDS' NE '').RESUME\n&RCPDS   SETC  '&SYSECT'\n         AIF   ('&RCPWKDS' EQ '').CSECT\n&RCPWKDS DSECT ,                        ENTER WORKAREA DSECT\n         MEXIT ,\n.CSECT   AIF   ('&RCPWKCS' EQ '').BRANCH\n&RCPWKCS CSECT ,                        ENTER WORKAREA CSECT\n         MEXIT ,\n.RESUME  AIF   (&RCPDSBR).BRTO\n&RCPDS   CSECT ,                        RESUME PROGRAM CSECT\n&RCPDS   SETC  ''\n         MEXIT ,\n.BRANCH  ANOP  ,\n&RCPDS   SETC  'RCP&SYSNDX'\n&RCPDSBR SETB  1\n         B     &RCPDS                   BRANCH AROUND CONSTANTS\n         MEXIT ,\n.BRTO    ANOP  ,\n&RCPDS   DS    0H\n&RCPDSBR SETB  0\n&RCPDS   SETC  ''\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPDSECT": {"ttr": 5893, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00\\x0b\\x00\\x0b\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 11, "newlines": 11, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&NAME    RCPDSECT &LTORG=YES\n         AIF   ('&LTORG' NE 'YES').RCPDS\n***********************************************************************\n****                  LITERALS                                     ****\n***********************************************************************\n         SPACE 3\n         LTORG\n         EJECT\n.RCPDS   RCPDS\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPDSN": {"ttr": 5895, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00D\\x00D\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 68, "newlines": 68, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPDSN &DSN,&MEM\n         LCLC  &MEMBER\n         GBLC  &DYNP\n         SPACE\n***********************************************************************\n**   BUILD THE DSNAME TEXT UNIT                                      **\n***********************************************************************\n         AIF   ('&DSN'(1,1) EQ '''').Q\n         AIF   ('&DSN'(K'&DSN,1) EQ '/').BD\n         AIF   ('&DSN'(1,1) EQ '(').REG\n         AIF   ('&DSN'  EQ '*').TERM\n         RCPSR2\n         L     R14,&DSN                LOAD ADDRESS OF DSNAME\n         LH    R2,&DSN+4               LOAD LENGTH OF DSNAME\n.STH     STH   R2,S99TULNG             STORE DSNAME LENGTH\n         BCTR  R2,0                    DECREMENT FOR EXECUTE\n         EX    R2,&DYNP.MVC            MOVE DSNAME\n         MVI   S99TUKEY+1,DALDSNAM     MOVE IN DSNAME KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         RCPDINC 50\n         AGO   .TMEMBER\n.REG     L     R14,0&DSN               LOAD ADDRESS OF DSNAME\n         RCPSR2\n         LH    R2,4&DSN                LOAD LENGTH OF DSNAME\n         AGO   .STH\n.TERM    MVI   S99TUKEY+1,DALTERM\n         RCPDINC 4\n         MEXIT\n.BD      RCPTUBFR DALDSNAM,50,&DSN\n         AGO   .TMEMBER\n.Q       RCPBTU DALDSNAM,1,&DSN\n.TMEMBER AIF   ('&MEM' EQ '').EXIT\n         SPACE\n***********************************************************************\n**   BUILD THE MEMBER NAME TEXT UNIT                                 **\n***********************************************************************\n&MEMBER  SETC  '&MEM'\n         AIF   ('&MEM' NE '*').MOK\n         AIF   ('&DSN'(1,1) NE '''').MAST\n         MNOTE 8,'MEMBER=* INVALID WITH QUOTED DSNAME'\n         MEXIT\n.MAST    ANOP\n&MEMBER  SETC  '8+&DSN'\n.MOK     AIF   ('&MEMBER'(1,1) EQ '''').QM\n         AIF   ('&MEMBER'(K'&MEMBER,1) EQ '/').BM\n         RCPSR2\n         AIF   ('&MEMBER'(1,1) EQ '(').RM\n         LH    R2,4+&MEMBER            LOAD LENGTH OF MEMBER NAME\n         LTR   R2,R2                   TEST FOR ZERO\n         BZ    *+30                    IF NO MEMBER, SKIP\n         L     R14,&MEMBER             LOAD ADDRESS OF MEMBER\n         AGO   .STHM\n.RM      LH    R2,4&MEMBER             LOAD LENGTH OF MEMBER\n         LTR   R2,R2                   AND TEST FOR ZERO\n         BZ    *+30                    IF NO MEMBER, SKIP\n         L     R14,0&MEMBER            LOAD ADDRESS OF MEMBER\n.STHM    STH   R2,S99TULNG             STORE LENGTH OF MEMBER\n         BCTR  R2,0                    DECREMENT FOR EXECUTE\n         EX    R2,&DYNP.MVC            MOVE IN MEMBER NAME\n         MVI   S99TUKEY+1,DALMEMBR     MOVE IN MEMBER KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         RCPDINC 14\n         MEXIT\n.BM      RCPTUBFR DALMEMBR,14,&MEMBER\n         MEXIT\n.QM      RCPBTU DALMEMBR,1,&MEMBER\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPDSNPD": {"ttr": 5897, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00\\t\\x00\\t\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 9, "newlines": 9, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPDSNPD &PDE\n         AIF   ('&PDE'(1,1) EQ '(').RPDE\n         RCPDSN &PDE,8+&PDE\n         RCPPSWD 16+&PDE\n         MEXIT\n.RPDE    RCPDSN &PDE,8&PDE\n         RCPPSWD 16(&PDE)\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPDSNRT": {"ttr": 5899, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00\\r\\x00\\r\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 13, "newlines": 13, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPDSNRT\n         SPACE\n***********************************************************************\n**    DSNAME RETURN TEXT UNIT                                        **\n***********************************************************************\n         MVI   S99TUKEY+1,DALRTDSN     SET RETURN DSNAME KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         MVI   S99TULNG+1,44           SET LENGTH FIELD\n         MVI   S99TUPAR,C' '           INITIALIZE FIELD TO BLANKS\n         MVC   S99TUPAR+1(44-1),S99TUPAR\n         RCPDINC 50\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPDSNT": {"ttr": 4869, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00I\\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00&\\x00&\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:49", "lines": 38, "newlines": 38, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         RCPDSNT &DSNT\n         LCLA  &I\n         LCLB  &B(8)\n         AIF   ('&DSNT(1)' EQ '').EXIT\n***********************************************************************\n**       Set DSNType                                                 **\n***********************************************************************\n&B(1)    SETB  ('&DSNT(1)' EQ 'LIBRARY')\n&B(2)    SETB  ('&DSNT(1)' EQ 'PDS')\n&B(3)    SETB  ('&DSNT(1)' EQ 'PIPE')\n&B(4)    SETB  ('&DSNT(1)' EQ 'HFS')\n&B(5)    SETB  ('&DSNT(1)' EQ 'EXTREQ')\n&B(6)    SETB  ('&DSNT(1)' EQ 'EXTPREF')\n&B(7)    SETB  ('&DSNT(1)' EQ 'BASIC')\n&B(8)    SETB  ('&DSNT(1)' EQ 'LARGE')\n         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4) OR &B(5) OR &B(6) OR  *\n               &B(7) OR &B(8)).OK1\n         MNOTE 8,'&DSNT(1) IS INVALID, DSNTYPE=BASIC USED'\n&B(7)    SETB  1\n.OK1     ANOP  ,\n&I       SETA  128*&B(1)+64*&B(2)+32*&B(3)+16*&B(4)+8*&B(5)+4*&B(6)+2*&*\n               B(7)+&B(8)\n         MVC   S99TUKEY,=AL2(DALDSNT)  Set Key\n         MVI   S99TUNUM+1,1            Set Count\n         MVI   S99TULNG+1,1            Set Length\n         MVI   S99TUPAR,&I             Set TU Parameter\n         RCPDINC 8\n         AIF   ('&DSNT(2)' EQ '').EXIT\n***********************************************************************\n**       Set DSNType Version                                         **\n***********************************************************************\n         MVC   S99TUKEY,=AL2(DALDSNV)  Set Key\n         MVI   S99TUNUM+1,1            Set Count\n         MVI   S99TULNG+1,1            Set Length\n         MVI   S99TUPAR,&DSNT(2)       Set TU Parameter\n         RCPDINC 8\n.EXIT    MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RCPDSRGR": {"ttr": 5901, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00\\x0c\\x00\\x0c\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 12, "newlines": 12, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPDSRGR\n         SPACE\n***********************************************************************\n**    DSORG RETURN TEXT UNIT                                         **\n***********************************************************************\n         MVI   S99TUKEY+1,DALRTORG     SET RETURN DSORG KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         MVI   S99TULNG+1,2            SET LENGTH FIELD\n         XC    S99TUPAR(2),S99TUPAR    INITIALIZE FIELD TO ZERO\n         RCPDINC 8\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPDUMMY": {"ttr": 5903, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00\\t\\x00\\t\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 9, "newlines": 9, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPDUMMY &DUMMY\n         SPACE\n***********************************************************************\n**      DUMMY DATASET TEXT UNIT                                      **\n***********************************************************************\n         MVI   S99TUPAR+1,DALDUMMY     MOVE IN DUMMY DS TEXT UNIT KEY\n         RCPDINC 4\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPEATTR": {"ttr": 4871, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00I\\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00\\x1a\\x00\\x1a\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:49", "lines": 26, "newlines": 26, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         RCPEATTR &OPT\n         LCLC  &O,&REG\n         AIF   ('&OPT' EQ '').EXIT\n***********************************************************************\n**       EATTR Text Unit                                             **\n***********************************************************************\n         MVC   S99TUKEY,=AL2(DALEATT)  Set Key\n         MVI   S99TUNUM+1,1            Set Count\n         MVI   S99TULNG+1,1            Set Length\n         AIF   ('&OPT'(1,1) EQ '(').O040\n         AIF   ('&OPT' NE 'NO').O010\n&O       SETC  'X''01'''\n         AGO   .O030\n.O010    AIF   ('&OPT' NE 'OPT').O020\n&O       SETC  'X''02'''\n         AGO   .O030\n.O020    MNOTE 8,'Invalid EATTR Option: &OPT'\n         MEXIT ,\n.O030    MVI   S99TUPAR,&O             Set TU Parameter\n         AGO   .O050\n.O040    ANOP  ,\n&REG     SETC  '&OPT'(2,K'&OPT-2)      Remove Brackets\n         STC   &REG,S99TUPAR           Set TU Parameter\n.O050    RCPDINC 8\n.EXIT    MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RCPEDIT": {"ttr": 5905, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00\\x0b\\x00\\x0b\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 11, "newlines": 11, "modlines": 0, "user": "MACRO"}, "text": "         MACRO - RESERVE SPACE FOR EDIT WORK AREA ONCE ONLY\n         RCPEDIT\n         GBLC  &RCPPRE,&RCPEDIT\n         AIF   ('&RCPEDIT' NE '').MEND\n&RCPEDIT SETC  '&RCPPRE.EDIT'\n         AIF   ('&RCPPRE' NE '').DS\n&RCPEDIT SETC  'RCPEDIT'\n.DS      RCPDS\n&RCPEDIT DS    3D             EDIT MACRO WORK AREA\n         RCPDS\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPENDD": {"ttr": 5907, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00%\\x00%\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 37, "newlines": 37, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&NAME    RCPENDD\n         GBLB  &RCPECT(2),&RCPUPT(2),&RCPPSCB(2),&RCPS99(2)\n         GBLC  &RCPPRE,&RCPWKDS,&RCPDS\n         LCLC  &P,&CS\n&CS      SETC  '&RCPDS'                PROGRAM CSECT\n         AIF   (NOT &RCPS99(1)).TDS\n         DYNSPACE\n.TDS     AIF   ('&RCPWKDS' EQ '').RCPDS\n         DS    0D                      ALIGN TO DOUBLEWORD\n&P       SETC  '&RCPPRE'\n&P.WKLEN EQU   *-&RCPWKDS              LENGTH OF WORK AREA\n.RCPDS   RCPDS\n         EJECT\n         AIF   (NOT &RCPECT(1) OR &RCPECT(2)).TRYUPT\n         IKJECT\n&CS      CSECT                         REENTER MAIN CSECT\n         EJECT\n&RCPECT(2)     SETB           1\n.TRYUPT  AIF   (NOT &RCPUPT(1) OR &RCPUPT(2)).TRYPSCB\n         IKJUPT\n&CS      CSECT                         REENTER MAIN CSECT\n         EJECT\n&RCPUPT(2) SETB  1\n.TRYPSCB AIF   (NOT &RCPPSCB(1) OR &RCPPSCB(2)).TRYS99\n         IKJPSCB\n&CS      CSECT                         REENTER MAIN CSECT\n         EJECT\n&RCPPSCB(2) SETB  1\n.TRYS99  AIF   (NOT &RCPS99(1) OR &RCPS99(2)).TRYREST\n         IEFZB4D0\n         EJECT\n         IEFZB4D2\n&CS      CSECT                         REENTER MAIN CSECT\n         EJECT\n&RCPS99(2) SETB  1\n.TRYREST MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPEROPT": {"ttr": 4873, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00I\\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00\\x17\\x00\\x17\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:49", "lines": 23, "newlines": 23, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         RCPEROPT &OPT\n         LCLA  &I\n         LCLB  &B(4)\n         AIF   ('&OPT' EQ '').EXIT\n***********************************************************************\n**       ERROPT= Text Unit                                           **\n***********************************************************************\n&B(1)    SETB  ('&OPT' EQ 'T')\n&B(2)    SETB  ('&OPT' EQ 'ABE')\n&B(3)    SETB  ('&OPT' EQ 'SKP')\n&B(4)    SETB  ('&OPT' EQ 'ACC')\n         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK1\n         MNOTE 8,'&OPT IS INVALID. EROPT=ABE USED'\n&B(2)    SETB  1\n.OK1     ANOP  ,\n&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)\n         MVC   S99TUKEY,=AL2(DALEROPT) Set Key\n         MVI   S99TUNUM+1,1            Set Count\n         MVI   S99TULNG+1,1            Set Length\n         MVI   S99TUPAR,&I             Set TU Parameter\n         RCPDINC 8\n.EXIT    MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RCPFCB": {"ttr": 4875, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00I\\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00.\\x00.\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:49", "lines": 46, "newlines": 46, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         RCPFCB &NAME,&OPT\n         LCLC  &O,&REG\n         GBLC  &DYNP\n         AIF   ('&NAME' EQ '').M400\n***********************************************************************\n**       FCB Name Text Unit                                          **\n***********************************************************************\n         AIF   ('&NAME'(1,1) EQ '''').M300\n         AIF   ('&NAME'(1,1) EQ '(').M100\n         L     R14,&NAME           A(NAME)\n         LH    R2,&NAME+4          L(NAME)\n         AGO   .M200\n.M100    L     R14,0&DSN           A(NAME)\n         LH    R2,4&DSN            L(NAME)\n.M200    MVC   S99TUKEY,=AL2(DALFCBIM) Set Key\n         MVI   S99TUNUM+1,1            Set Count\n         STH   R2,S99TULNG             Set Length\n         SHI   R2,1\n         EX    R2,&DYNP.MVC            Set TU Parameter\n         RCPDINC 14\n         AGO   .M400\n.M300    RCPBTU DALFCBIM,1,&NAME\n.M400    AIF   ('&OPT' EQ '').EXIT\n***********************************************************************\n**       FCB Option Text Unit                                        **\n***********************************************************************\n         MVC   S99TUKEY,=AL2(DALFCBAV) Set Key\n         MVI   S99TUNUM+1,1            Set Count\n         MVI   S99TULNG+1,1            Set Length\n         AIF   ('&OPT'(1,1) EQ '(').M800\n         AIF   ('&OPT' NE 'ALIGN').M500\n&O       SETC  'X''08'''\n         AGO   .M700\n.M500    AIF   ('&OPT' NE 'VERIFY').M600\n&O       SETC  'X''04'''\n         AGO   .M700\n.M600    MNOTE 8,'FCB OPTION IS NOT \"ALIGN\" OR \"VERIFY\"'\n         MEXIT ,\n.M700    MVI   S99TUPAR,&O             Set TU Parameter\n         AGO   .M900\n.M800    ANOP  ,\n&REG     SETC  '&OPT'(2,K'&OPT-2)      Remove Brackets\n         STC   &REG,S99TUPAR           Set TU Parameter\n.M900    RCPDINC 8\n.EXIT    MEND  ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RCPFDDN": {"ttr": 5909, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00\\x1b\\x00\\x1b\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 27, "newlines": 27, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPFDDN &DDN\n         GBLC &DYNP\n         SPACE\n***********************************************************************\n**        FREE DDNAME TEXT UNIT                                      **\n***********************************************************************\n         AIF   ('&DDN'(1,1) EQ '''').Q\n         AIF   ('&DDN'(K'&DDN,1) EQ '/').B\n         RCPSR2\n         AIF   ('&DDN'(1,1) EQ '(').R\n         L     R14,&DDN                LOAD ADDRESS OF DDNAME\n         LH    R2,&DDN+4               LOAD LENGTH OF DDNAME\n         AGO   .STH\n.R       L     R14,0&DDN               LOAD ADDRESS OF DDNAME\n         LH    R2,4&DDN                LOAD LENGTH OF DDNAME\n.STH     STH   R2,S99TULNG             STORE DDNAME LENGTH\n         BCTR  R2,0                    DECREMENT FOR EXECUTE\n         EX    R2,&DYNP.MVC            MOVE DDNAME\n         MVI   S99TUKEY+1,DUNDDNAM     MOVE IN DDNAME KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         RCPDINC 14\n         MEXIT\n.Q       RCPBTU DUNDDNAM,1,&DDN\n         MEXIT\n.B       RCPTUBFR DUNDDNAM,14,&DDN\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPFDISP": {"ttr": 5911, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00\\x14\\x00\\x14\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 20, "newlines": 20, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPFDISP &DISP\n         LCLB  &B(4)\n         LCLA  &I\n         SPACE\n***********************************************************************\n**       OVERRIDING DISPOSITION                                      **\n***********************************************************************\n&B(1)    SETB  ('&DISP' EQ 'KEEP')\n&B(2)    SETB  ('&DISP' EQ 'DELETE')\n&B(3)    SETB  ('&DISP' EQ 'CATLG')\n&B(4)    SETB  ('&DISP' EQ 'UNCATLG')\n         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK3\n         MNOTE 8,'&DISP IS INVALID, DISP=KEEP USED'\n&B(1)    SETB  1\n.OK3     ANOP\n&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)\n         MVC   S99TUKEY(8),=Y(DUNOVDSP,1,1,X'0&I.00')\n         RCPDINC 8\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPFDSN": {"ttr": 5913, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00@\\x00@\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 64, "newlines": 64, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPFDSN &DSN,&MEM\n         LCLC  &MEMBER\n         GBLC  &DYNP\n         SPACE\n***********************************************************************\n**      FREE DATA SET TEXT UNIT                                      **\n***********************************************************************\n         AIF   ('&DSN'(1,1) EQ '''').Q\n         AIF   ('&DSN'(K'&DSN,1) EQ '/').BD\n         AIF   ('&DSN'(1,1) EQ '(').REG\n         RCPSR2\n         L     R14,&DSN                LOAD ADDRESS OF DSNAME\n         LH    R2,&DSN+4               LOAD LENGTH OF DSNAME\n.STH     STH   R2,S99TULNG             STORE DSNAME LENGTH\n         BCTR  R2,0                    DECREMENT FOR EXECUTE\n         EX    R2,&DYNP.MVC            MOVE DSNAME\n         MVI   S99TUKEY+1,DUNDSNAM     MOVE IN DSNAME KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         RCPDINC 50\n         AGO   .TMEMBER\n.REG     L     R14,0&DSN               LOAD ADDRESS OF DSNAME\n         RCPSR2\n         LH    R2,4&DSN                LOAD LENGTH OF DSNAME\n         AGO   .STH\n.BD      RCPTUBFR DUNDSNAM,50,&DSN\n         AGO   .TMEMBER\n.Q       RCPBTU DUNDSNAM,1,&DSN\n.TMEMBER AIF   ('&MEM' EQ '').EXIT\n         SPACE\n***********************************************************************\n**       FREE MEMBER NAME TEXT UNIT                                  **\n***********************************************************************\n&MEMBER  SETC  '&MEM'\n         AIF   ('&MEM' NE '*').MOK\n         AIF   ('&DSN'(1,1) NE '''').MAST\n         MNOTE 8,'MEMBER=* INVALID WITH QUOTED DSNAME'\n         MEXIT\n.MAST    ANOP\n&MEMBER  SETC  '8+&DSN'\n.MOK     ANOP\n         AIF   ('&MEMBER'(K'&MEMBER,1) EQ '/').BM\n         RCPSR2\n         AIF   ('&MEMBER'(1,1) EQ '(').RM\n         LH    R2,4+&MEMBER            LOAD LENGTH OF MEMBER NAME\n         LTR   R2,R2                   TEST FOR ZERO\n         BZ    *+30                    IF NO MEMBER, SKIP\n         L     R14,&MEMBER             LOAD ADDRESS OF MEMBER\n         AGO   .STHM\n.RM      LH    R2,4&MEMBER             LOAD LENGTH OF MEMBER\n         LTR   R2,R2                   AND TEST FOR ZERO\n         BZ    *+30                    IF NO MEMBER, SKIP\n         L     R14,0&MEMBER            LOAD ADDRESS OF MEMBER\n.STHM    STH   R2,S99TULNG             STORE LENGTH OF MEMBER\n         BCTR  R2,0                    DECREMENT FOR EXECUTE\n         EX    R2,&DYNP.MVC            MOVE IN MEMBER NAME\n         MVI   S99TUKEY+1,DUNMEMBR     MOVE IN MEMBER KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         RCPDINC 14\n         MEXIT\n.BM      RCPTUBFR DUNMEMBR,14,&MEMBER\n         MEXIT\n.QM      RCPBTU DUNMEMBR,1,&MEMBER\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPFHOLD": {"ttr": 5915, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00\\x18\\x00\\x18\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 24, "newlines": 24, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPFHOLD &H\n         AIF   ('&H' EQ 'YES').YES\n         AIF   ('&H' EQ 'NO').NO\n         MNOTE 4,'HOLD PARMETER VALUE INCORRECT - IGNORED'\n         MEXIT\n.YES     ANOP\n         SPACE 1\n***********************************************************************\n**       OVERIDING SYSOUT HOLD TEXT UNIT                             **\n***********************************************************************\n         SPACE 1\n         MVI   S99TUKEY+1,DUNOVSHQ MOVE IN TEXT UNIT KEY\n         RCPDINC 4\n         MEXIT\n.NO      ANOP\n         SPACE 1\n***********************************************************************\n**       OVERIDING SYSOUT NO HOLD TEXT UNIT                          **\n***********************************************************************\n         SPACE 1\n         MVI   S99TUKEY+1,DUNOVSNH MOVE IN TEXT UNIT KEY\n         RCPDINC 4\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPFLASH": {"ttr": 4877, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Q\\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00&\\x00&\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:51", "lines": 38, "newlines": 38, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         RCPFLASH &NAME,&COUNT\n         LCLC  &REG\n         GBLC  &DYNP\n         AIF   ('&NAME' EQ '').M400\n***********************************************************************\n**       Flash Overlay Name Text Unit                                **\n***********************************************************************\n         AIF   ('&NAME'(1,1) EQ '''').M300\n         AIF   ('&NAME'(1,1) EQ '(').M100\n         L     R14,&NAME           A(NAME)\n         LH    R2,&NAME+4          L(NAME)\n         AGO   .M200\n.M100    L     R14,0&DSN           A(NAME)\n         LH    R2,4&DSN            L(NAME)\n.M200    MVC   S99TUKEY,=AL2(DALFFORM) Set Key\n         MVI   S99TUNUM+1,1            Set Count\n         STH   R2,S99TULNG             Set Length\n         SHI   R2,1\n         EX    R2,&DYNP.MVC            Set TU Parameter\n         RCPDINC 10\n         AGO   .M400\n.M300    RCPBTU DALFFORM,1,&NAME\n.M400    AIF   ('&COUNT' EQ '').EXIT\n***********************************************************************\n**       FLASH Count Text Unit                                      **\n***********************************************************************\n         MVC   S99TUKEY,=AL2(DALFCNT)  Set Key\n         MVI   S99TUNUM+1,1            Set Count\n         MVI   S99TULNG+1,1            Set Length\n         AIF   ('&COUNT'(1,1) EQ '(').M800\n         MVI   S99TUPAR,&COUNT         Set TU Parameter\n         AGO   .M900\n.M800    ANOP  ,\n&REG     SETC  '&COUNT'(2,K'&COUNT-2)  Remove Brackets\n         STC   &REG,S99TUPAR           Set TU Parameter\n.M900    RCPDINC 8\n.EXIT    MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RCPFORUS": {"ttr": 5917, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00\\x08\\x00\\x08\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 8, "newlines": 8, "modlines": 0, "user": "MACRO"}, "text": "         MACRO - TO SET UP SVC 99 TEXT UNIT 'FOR USER'\n         RCPFORUS &T\n         SPACE 1\n***********************************************************************\n**       'FOR USER' TEXT UNIT                                        **\n***********************************************************************\n         RCPVCHAR 0,5,&T,N=X'7701'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPFREE": {"ttr": 5919, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00\\t\\x00\\t\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 9, "newlines": 9, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPFREE &FREE\n         SPACE\n***********************************************************************\n**      UNALLOC AT CLOSE TEXT UNIT                                   **\n***********************************************************************\n         MVI   S99TUPAR+1,DALCLOSE     MOVE IN CLOSE TEXT UNIT KEY\n         RCPDINC 4\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPINSUL": {"ttr": 4879, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00\\x08\\x00\\x08\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:53", "lines": 8, "newlines": 8, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         RCPINSUL ,\n***********************************************************************\n**       Insulated Allocation Attribute Text Unit                    **\n***********************************************************************\n         MVC   S99TUKEY,=AL2(DALINSDD) Set Key\n         RCPDINC 4\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RCPIOPL": {"ttr": 6145, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00G\\x00G\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 71, "newlines": 71, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    RCPIOPL\n         GBLC  &RCPPRE\n         GBLB  &RCPIOPL(2)\n         GBLB  &RCPSTPB(2),&RCPPTPB(2),&RCPPGPB(2),&RCPGTPB(2)\n         LCLC  &P,&L,&L1\n&P       SETC  '&RCPPRE'\n         EJECT ,\n         AIF   (&RCPIOPL(2)).BYPIOPL\n&RCPIOPL(2) SETB 1\n         IKJIOPL ,\nL#IOPL   EQU   *-IOPL                   LENGTH OF IO PARAM LIST\n&SYSECT  CSECT ,                        RESUME PROGRAM CSECT\n         SPACE 3\n.BYPIOPL RCPDS ,\n&P.IOPL  DS    CL(L#IOPL)               RESERVE SPACE FOR IOPL\n         RCPDS ,\n         SPACE 5\n***********************************************************************\n***   THIS CODE GENERATES AN I/O SERVICE ROUTINE PARAMETER LIST     ***\n***********************************************************************\n         LA    R1,&P.IOPL               LOAD IOPL ADDRESS\n         USING IOPL,R1                  IOPL ADDRESSABLE\n         MVC   IOPLUPT,CPPLUPT          MOVE IN ADDRESS OF UPT\n         MVC   IOPLECT,CPPLECT          MOVE IN ADDRESS OF ECT\n         LA    R15,&P.ECB               LOAD ADDRESS OF ATTN ECB\n         ST    R15,IOPLECB              AND STORE IN IOPL\n         DROP  R1\n  AIF (&RCPSTPB(1) OR &RCPGTPB(1) OR &RCPPGPB(1) OR &RCPPTPB(1)).I\n         MEXIT ,\n.I       EJECT ,\n         AIF   (NOT &RCPSTPB(1) OR &RCPSTPB(2)).TPT\n         IKJSTPB ,\n&RCPSTPB(2) SETB 1\nL#STPB   EQU   *-STPB                   LENGTH OF STPB\n&SYSECT  CSECT ,\n.TPT     AIF   (NOT &RCPPTPB(1) OR &RCPPTPB(2)).TGT\n         IKJPTPB\n&RCPPTPB(2) SETB 1\nL#PTPB   EQU   *-PTPB                   LENGTH OF PTPB\n&SYSECT  CSECT ,\n.TGT     AIF   (NOT &RCPGTPB(1) OR &RCPGTPB(2)).TPG\n         IKJGTPB ,\n&RCPGTPB(2) SETB 1\nL#GTPB   EQU   *-GTPB                   LENGTH OF GTPB\n&SYSECT  CSECT ,\n.TPG     AIF   (NOT &RCPPGPB(1) OR &RCPPGPB(2)).STO\n         IKJPGPB ,\n&RCPPGPB(2) SETB 1\nL#PGPB   EQU   *-PGPB                   LENGTH OF PGPB\n&SYSECT  CSECT ,\n.STO     SPACE 3\n&L       SETC  ''\n         RCPDS ,\n         AIF   (NOT &RCPSTPB(1)).XPT\n&P.STPB  DS    CL(L#STPB)               RESERVE SPACE FOR STPB\n&L       SETC  '&L.+L#STPB'\n.XPT     AIF   (NOT &RCPPTPB(1)).XGT\n&P.PTPB  DS    CL(L#PTPB)               RESERVE SPACE FOR PTPB\n&L       SETC  '&L.+L#PTPB'\n.XGT     AIF   (NOT &RCPGTPB(1)).XPG\n&P.GTPB  DS    CL(L#GTPB)               RESERVE SPACE FOR GTPB\n&L       SETC  '&L.+L#GTPB'\n.XPG     AIF   (NOT &RCPPGPB(1)).XC\n&P.PGPB  DS    CL(L#PGPB)               RESERVE SPACE FOR PGPB\n&L       SETC  '&L.+L#PGPB'\n.XC      RCPDS ,\n&L1      SETC  '&L'(2,K'&L-1)\n&L       SETC  '&P'.'&L1'(3,4)\n         XC    &L.(&L1.),&L\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPLABEL": {"ttr": 6147, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00\\r\\x00\\r\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 13, "newlines": 13, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPLABEL &L\n         GBLC  &DYNP\n         SPACE 1\n***********************************************************************\n**       EXPIRY DATE TEXT UNIT                                       **\n***********************************************************************\n         AIF   ('&L' NE '').EXPIRY\n         MNOTE 4,'INVALID EXPIRY DATE OPERAND.'\n         MEXIT\n.*       RCPVCHAR DALEXPDT,14,&L\n.EXPIRY  RCPVCHAR DALEXPDL,14,&L        /* LONG FORMAT OF EXPDT */\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPLINK": {"ttr": 6149, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x005\\x005\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 53, "newlines": 53, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&NAME    RCPLINK &MODULE\n         LCLC  &OFFSET,&C\n         AIF   ('&MODULE' EQ '').ERROR\n         AIF   ('&MODULE' NE 'IKJPARS').T1\n&OFFSET  SETC  '524'\n         AGO   .START\n.T1      AIF   ('&MODULE' NE 'IKJDAIR').T2\n&OFFSET  SETC  '732'\n         AGO   .START\n.T2      AIF   ('&MODULE' NE 'IKJEHDEF').T3\n&OFFSET  SETC  '736'\n         AGO   .START\n.T3      AIF   ('&MODULE' NE 'IKJEHCIR').T4\n&OFFSET  SETC  '740'\n         AGO   .START\n.T4      AIF   ('&MODULE' NE 'IKJPUTL').T5\n&OFFSET  SETC  '444'\n         AGO   .START\n.T5      AIF   ('&MODULE' NE 'IKJGETL').T6\n&OFFSET  SETC  '348'\n         AGO   .START\n.T6      AIF   ('&MODULE' NE 'IKJSCAN').T7\n&OFFSET  SETC  '480'\n         AGO   .START\n.T7      AIF   ('&MODULE' NE 'IKJPTGT').T8\n&OFFSET  SETC  '464'\n         AGO   .START\n.T8      AIF   ('&MODULE' NE 'IKJSTCK').T9\n&OFFSET  SETC  '472'\n         AGO   .START\n.T9      ANOP\n&NAME    DS    0H\n*\n MNOTE *,' EP OF &MODULE. NOT IN CVT. STANDARD LINK USED'\n*\n         AGO   .LINK\n.START   ANOP\n&NAME    L     R15,16                  LOAD CVT ADDRESS\n         L     R15,&OFFSET.(R15)       LOAD MODULE ADDRESS\n         LTR   R15,R15                 IS MODULE ADDRESS THERE?\n&C       SETC  'RCP&SYSNDX'\n         BNM   &C.L                     IF NOT, BRANCH TO LINK\n         BALR  R14,R15                  ELSE BALR TO IT\n         B     &C.B                      AND BYPASS LINK\n&C.L     LINK  EP=&MODULE\n&C.B     DS    0H                      BRANCHED TO IF LINK BYPASSED\n         MEXIT\n.LINK    ANOP\n&NAME    LINK  EP=&MODULE\n         MEXIT\n.ERROR   MNOTE 4,'NO MODULE NAME SPECIFIED'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPLOAD": {"ttr": 6151, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00v\\x00v\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 118, "newlines": 118, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    RCPLOAD &MOD,&EP1\n         GBLC  &RCPPTEP,&RCPGTEP,&RCPPGEP\n         GBLC  &RCPDFEP,&RCPSTEP,&RCPPREP\n         GBLC  &RCPPRE\n         LCLA  &I,&J\n         LCLB  &EPXISTS\n         LCLC  &OFFSET,&C,&EP,&MODULE\n&EP      SETC  '&EP1'\n&MODULE  SETC  '&MOD'\n         AIF   ('&MODULE' EQ '').ERROR\n         AIF   ('&MODULE'(K'&MOD,1) NE ')').NOBR\n&I       SETA  K'&MOD\n.LOOP    ANOP  ,\n&I       SETA  &I-1\n         AIF   (&I LT 2).NOLB\n         AIF   ('&MOD'(&I,1) NE '(').LOOP\n&MODULE  SETC  '&MOD'(1,&I-1)\n&J       SETA  K'&MOD-1-&I\n&EP      SETC  '&MOD'(&I+1,&J)\n         RCPDS ,\n&EP      DS    A                        TO STORE MODULE ADDRESS\n         RCPDS ,\n.NOBR    ANOP  ,\n&EPXISTS SETB  ('&EP' NE '')\n         AIF   ('&MODULE' NE 'IKJPARS').T1\n&OFFSET  SETC  '524'\n&RCPPREP SETC  '&EP'\n         AIF   (&EPXISTS).START\n         RCPDS ,\n&RCPPREP SETC  '&RCPPRE.PREP'\n&EP      SETC  '&RCPPREP'\n&RCPPREP DS    A                        TO HOLD ADDRESS OF IKJPARS\n         RCPDS ,\n         AGO   .START\n.T1      AIF   ('&MODULE' NE 'IKJDAIR').T2\n&OFFSET  SETC  '732'\n         AGO   .START\n.T2      AIF   ('&MODULE' NE 'IKJEHDEF').T3\n&RCPDFEP SETC  '&EP'\n&OFFSET  SETC  '736'\n         AIF   (&EPXISTS).START\n&RCPDFEP SETC  '&RCPPRE.DFEP'\n         RCPDS ,\n&RCPDFEP DS    A                        ADDR OF DEFAULT SERVICE ROUTINE\n         RCPDS ,\n&EP      SETC  '&RCPDFEP'\n         AGO   .START\n.T3      AIF   ('&MODULE' NE 'IKJEHCIR').T4\n&OFFSET  SETC  '740'\n         AGO   .START\n.T4      AIF   ('&MODULE' NE 'IKJPUTL').T5\n&RCPPTEP SETC  '&EP'\n&OFFSET  SETC  '444'\n         AIF   (&EPXISTS).START\n&RCPPTEP SETC  '&RCPPRE.PTEP'\n&EP      SETC  '&RCPPTEP'\n         RCPDS ,\n&RCPPTEP DS    A                        ADDR OF PUTLINE ROUTINE\n         RCPDS ,\n         AGO   .START\n.T5      AIF   ('&MODULE' NE 'IKJGETL').T6\n&RCPGTEP SETC  '&EP'\n&OFFSET  SETC  '348'\n         AIF   (&EPXISTS).START\n&RCPGTEP SETC  '&RCPPRE.GTEP'\n&EP      SETC  '&RCPGTEP'\n         RCPDS ,\n&RCPGTEP DS    A                        ADDR OF GETLINE ROUTINE\n         RCPDS ,\n         AGO   .START\n.T6      AIF   ('&MODULE' NE 'IKJSCAN').T7\n&OFFSET  SETC  '480'\n         AGO   .START\n.T7      AIF   ('&MODULE' NE 'IKJPTGT').T8\n&RCPPGEP SETC  '&EP'\n&OFFSET  SETC  '464'\n         AIF   (&EPXISTS).START\n&RCPPGEP SETC  '&RCPPRE.PGEP'\n&EP      SETC  '&RCPPGEP'\n         RCPDS ,\n&RCPPGEP DS    A                        ADDR OF PUTGET ROUTINE\n         RCPDS ,\n         AGO   .START\n.T8      AIF   ('&MODULE' NE 'IKJSTCK').T9\n&RCPSTEP SETC  '&EP'\n&OFFSET  SETC  '472'\n         AIF   (&EPXISTS).START\n&RCPSTEP SETC  '&RCPPRE.STEP'\n&EP      SETC  '&RCPSTEP'\n         RCPDS ,\n&RCPSTEP DS    A                        ADDR OF STACK ROUTINE\n         RCPDS ,\n         AGO   .START\n.T9      ANOP  ,\n         AIF   ('&NAME' EQ '').NONAME\n&NAME    DS    0H\n.NONAME  ANOP  ,\n*\n         MNOTE *,' EP OF &MODULE NOT IN CVT, STANDARD LOAD USED'\n*\n         AGO   .LOAD\n.START   ANOP  ,\n&NAME    L     R15,16                   LOAD CVT ADDRESS\n         L     R0,&OFFSET.(0,R15)       LOAD MODULE ADDRESS\n         LTR   R0,R0                    IS MODULE LOADED ?\n&C       SETC  'RCP&SYSNDX'\n         BM    &C                       IF SO, BYPASS LOAD MACRO\n.LOAD    LOAD  EP=&MODULE\n         AIF   ('&EP' EQ '').EPERR\n&C       ST    R0,&EP                   STORE ENTRY POINT ADDRESS\n         MEXIT ,\n.EPERR   MNOTE 4,'EP RETURN FIELD NOT SPECIFIED'\n         MEXIT ,\n.ERROR   MNOTE 4,'NO MODULE NAME SPECIFIED'\n         MEXIT ,\n.NOLB    MNOTE 4,'INVALID MODULE NAME ''&MOD'''\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPLOCSW": {"ttr": 6153, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00[\\x00[\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 91, "newlines": 91, "modlines": 0, "user": "MACRO"}, "text": "*23456789*12345*78921234567893123456789*\n         MACRO\n         RCPLOCSW &SW\n.********************************************************************\n.*                                                                  *\n.*       INNER MACRO USED BY GOIF, SET, RESET AND FLIP.             *\n.*       THE PARM PASSED IS THE SWITCH OR LIST OF SWITCHES.         *\n.*       RCPLOCSW SCANS THE ARRAYS SET UP BY DCLSW TO SEE IF THE    *\n.*       SWITCH BIT NAMES WERE DECLARED, AND IF A LIST WAS PASSED,  *\n.*       WHETHER ALL THE SWITCH BITS BELONG TO THE SAME BYTE.       *\n.*       RCPLOCSW PASSES BACH THE SWITCH BYTE NAME IN GLOBAL SETC   *\n.*       VARIABLE &RCPDSW1 AND THE SWITCH BIT NAME IN GLOBAL SETC   *\n.*       &RCPDSW2. IF A LIST OF SWITCHES WAS PASSED, &RCPDSW2       *\n.*       CONTAINS THE SWITCH NAMES SEPARATED BY PLUS SIGNS.         *\n.*       IF THE FIRST OR ONLY SWITCH WAS NOT FOUND, &RCPDSW1 IS SET *\n.*       TO NULL. IF A LIST OF SWITCHES IS PASSED AND ANY SWITCH IS *\n.*       NOT DECLARED IN THE SAME SWITCH BYTE AS THE FIRST, AN MNOTE*\n.*       IS ISSUED WARNING OF POSSIBLE ERROR, BUT &RCPDSW1 IS SET   *\n.*       TO THE NAME OF THE SWITCH BYTE CONTAINING THE FIRST SWITCH *\n.*       BIT IN THE LIST.                                           *\n.*                                                                  *\n.********************************************************************\n         GBLA  &RCPDSW#,&RCPGSW#       COUNTER FOR DECLARED SWITCHES\n         GBLA  &RCPDSW0                NO OF SWS FOUND BY RCPLOCSW\n         GBLB  &RCPDSWD(99)            DEFER DECLARE INDICATORS\n         GBLB  &RCPDSW3(20)   INVERT INDICATOR\n         GBLC  &RCPDSWN(99)            SWITCH BYTE NAMES\n         GBLC  &RCPDSWB(800)           SWITCH BIT NAMES\n         GBLC  &RCPGSWN(99)            GENERIC SWITCH BYTE NAMES\n         GBLC  &RCPGSWB(99)            GENERIC SWITCH BIT PREFIXES\n         GBLC  &RCPDSW1(20)            SWITCH BYTE NAMES\n         GBLC  &RCPDSW2(20)            SWITCH BIT NAME(S)\n         LCLA  &I,&J,&K,&L,&M,&N\n         LCLB  &NOT\n         LCLC  &C,&SW1,&SW2\n&RCPDSW0 SETA  0                       INITIALIZE\n&N       SETA  N'&SW                   NO OF SWITCHES ENTERED\n&J       SETA  &RCPDSW#*8+8            INDEX TO LAST DECLARED SW BIT\n.LOOP1   AIF   (&M GE &N).EXIT        LOOP FOR EACH SW\n&M       SETA  &M+1\n&SW2     SETC  '&SW(&M)'               SWITCH TO SEARCH FOR\n         AIF   ('&SW2' EQ '').LOOP1    SKIP IF NULL\n&I       SETA  8                       INDEX TO FIRST DECLARED SW - 1\n&NOT     SETB  0\n         AIF   ('&SW2'(1,1) NE '\u00ac' AND '&SW2'(1,1) NE '-').TNOT2\n&SW2     SETC  '&SW2'(2,K'&SW2-1)       REMOVE NOT SIGN\n&NOT     SETB  1                       INDICATE INVERT FUNCTION\n         AGO   .LOOP1A                 CONTINUE\n.TNOT2   AIF   (K'&SW2 LT 5).LOOP1A    CHECK LENGTH\n         AIF   ('&SW2'(1,4) NE 'NOT-').LOOP1A  WAS SWITCH INVERTED?\n&SW2     SETC  '&SW2'(5,K'&SW2-4)      STRIP OFF 'NOT-'\n&NOT     SETB  1                       INDICATE INVERTED\n.LOOP1A  AIF   (&I GE &J).TGEN         SEARCH NAME ARRAY\n&I       SETA  &I+1\n         AIF   ('&RCPDSWB(&I)' NE '&SW2').LOOP1A\n.*\n.*   WE FOUND IT\n.*\n&L       SETA  (&I-1)/8                INDEX TO BYTE NAME\n&SW1     SETC  '&RCPDSWN(&L)'          GET BYTE NAME\n.FOUNDSW ANOP                          HAVE WE HAD IT BEFORE?\n&K       SETA  0\n.SWL1    AIF   (&K GE &RCPDSW0).NEWSW1\n&K       SETA  &K+1\n         AIF   ('&RCPDSW1(&K)' NE '&SW1').SWL1\n         AIF   (&RCPDSW3(&K) NE &NOT).SWL1  ENSURE INVERT BIT THE SAME\n.*\n.* WE FOUND IT\n.*\n&RCPDSW2(&K) SETC '&RCPDSW2(&K)+&SW2'  CONCATENATE CURRENT SW\n         AGO   .LOOP1                  GO DO NEXT\n.NEWSW1  ANOP\n&RCPDSW0 SETA  &K+1                    NEXT SW BYTE INDEX\n&RCPDSW1(&RCPDSW0) SETC '&SW1'         BYTE NAME\n&RCPDSW2(&RCPDSW0) SETC '&SW2'         BIT NAME\n&RCPDSW3(&RCPDSW0) SETB (&NOT)         SET INVERT INDICATOR\n         AGO   .LOOP1                  GO DO NEXT\n.TGEN    ANOP  SEARCH GENERIC NAME ARRAY\n&I       SETA  0\n&L       SETA  K'&SW2\n.LOOP2   ANOP\n&I       SETA  &I+1\n         AIF   (&I GT &RCPGSW#).NOTFND\n&C       SETC  '&RCPGSWB(&I)'\n         AIF   (&L LT K'&C).LOOP2\n         AIF   ('&SW2'(1,K'&C) NE '&C').LOOP2\n&SW1     SETC  '&RCPGSWN(&I)'\n         AGO   .FOUNDSW                EUREKA\n.NOTFND  MNOTE 8,'SWITCH ''&SW2'' NOT DECLARED'\n         AGO   .LOOP1\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPLOCS1": {"ttr": 6155, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00M\\x00M\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 77, "newlines": 77, "modlines": 0, "user": "MACRO"}, "text": "*23456789*12345*78921234567893123456789*\n         MACRO\n         RCPLOCSW &SW\n.********************************************************************\n.*                                                                  *\n.*       INNER MACRO USED BY GOIF, SET, RESET AND FLIP.             *\n.*       THE PARM PASSED IS THE SWITCH OR LIST OF SWITCHES.         *\n.*       RCPLOCSW SCANS THE ARRAYS SET UP BY DCLSW TO SEE IF THE    *\n.*       SWITCH BIT NAMES WERE DECLARED, AND IF A LIST WAS PASSED,  *\n.*       WHETHER ALL THE SWITCH BITS BELONG TO THE SAME BYTE.       *\n.*       RCPLOCSW PASSES BACH THE SWITCH BYTE NAME IN GLOBAL SETC   *\n.*       VARIABLE &RCPDSW1 AND THE SWITCH BIT NAME IN GLOBAL SETC   *\n.*       &RCPDSW2. IF A LIST OF SWITCHES WAS PASSED, &RCPDSW2       *\n.*       CONTAINS THE SWITCH NAMES SEPARATED BY PLUS SIGNS.         *\n.*       IF THE FIRST OR ONLY SWITCH WAS NOT FOUND, &RCPDSW1 IS SET *\n.*       TO NULL. IF A LIST OF SWITCHES IS PASSED AND ANY SWITCH IS *\n.*       NOT DECLARED IN THE SAME SWITCH BYTE AS THE FIRST, AN MNOTE*\n.*       IS ISSUED WARNING OF POSSIBLE ERROR, BUT &RCPDSW1 IS SET   *\n.*       TO THE NAME OF THE SWITCH BYTE CONTAINING THE FIRST SWITCH *\n.*       BIT IN THE LIST.                                           *\n.*                                                                  *\n.********************************************************************\n         GBLA  &RCPDSW#,&RCPGSW#       COUNTER FOR DECLARED SWITCHES\n         GBLA  &RCPDSW0                NO OF SWS FOUND BY RCPLOCSW\n         GBLB  &RCPDSWD(99)            DEFER DECLARE INDICATORS\n         GBLC  &RCPDSWN(99)            SWITCH BYTE NAMES\n         GBLC  &RCPDSWB(800)           SWITCH BIT NAMES\n         GBLC  &RCPGSWN(99)            GENERIC SWITCH BYTE NAMES\n         GBLC  &RCPGSWB(99)            GENERIC SWITCH BIT PREFIXES\n         GBLC  &RCPDSW1(20)            SWITCH BYTE NAMES\n         GBLC  &RCPDSW2(20)            SWITCH BIT NAME(S)\n         LCLA  &I,&J,&K,&L,&M,&N       LOCAL COUNTERS\n         LCLC  &C,&SW1,&SW2\n&RCPDSW0 SETA  0                       INITIALIZE\n&N       SETA  N'&SW                   NO OF SWITCHES ENTERED\n&J       SETA  &RCPDSW#*8              INDEX TO LAST DECLARED SW BIT\n.LOOP1   AIF   (&M GE &N).EXIT        LOOP FOR EACH SW\n&M       SETA  &M+1\n&SW2     SETC  '&SW(&M)'               SWITCH TO SEARCH FOR\n         AIF   ('&SW2' EQ '').LOOP1    SKIP IF NULL\n&I       SETA  8                       INDEX TO FIRST DECLARED SW - 1\n.LOOP1A  AIF   (&I GE &J).TGEN         SEARCH NAME ARRAY\n&I       SETA  &I+1\n         AIF   ('&RCPDSWB(&I)' NE '&SW2').LOOP1A\n.*\n.*   WE FOUND IT\n.*\n&L       SETA  (&I-1)/8                INDEX TO BYTE NAME\n&SW1     SETC  '&RCPDSWN(&L)'          GET BYTE NAME\n.FOUNDSW ANOP                          HAVE WE HAD IT BEFORE?\n&K       SETA  0\n.SWL1    AIF   (&K GE &RCPDSW0).NEWSW1\n&K       SETA  &K+1\n         AIF   ('&RCPDSW1(&K)' NE '&SW1').SWL1\n.*\n.* WE FOUND IT\n.*\n&RCPDSW2(&K) SETC '&RCPDSW2(&K)+&SW2'  CONCATENATE CURRENT SW\n         AGO   .LOOP1                  GO DO NEXT\n.NENSW1  ANOP\n&RCPDSW0 SETA  &K+1                    NEXT SW BYTE INDEX\n&RCPDSW1(&RCPDSW0) SETC '&SW1'         BYTE NAME\n&RCPDSW2(&RCPDSW0) SETC '&SW2'         BIT NAME\n         AGO   .LOOP1                  GO DO NEXT\n.TGEN    ANOP  SEARCH GENERIC NAME ARRAY\n&I       SETA  0\n&L       SETA  K'&SW2\n.LOOP2   ANOP\n&I       SETA  &I+1\n         AIF   (&I GT &RCPGSW#).NOTFND\n&SW1     SETC  '&RCPGSWN(&I)'\n         AIF   (&L LT K'&SW1).LOOP2\n         AIF   ('&SW1'(1,&L) NE '&SW2').LOOP2\n         AGO   .FOUNDSW                EUREKA\n.NOTFND  MNOTE 4,'SWITCH ''&SW2'' NOT DECLARED'\n         AGO   .LOOP1\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPLOCS2": {"ttr": 6157, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16&?\\x01\\x16&?\\x13\\x06\\x00_\\x00_\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:06:59", "lines": 95, "newlines": 95, "modlines": 0, "user": "MACRO"}, "text": "*23456789*12345*78921234567893123456789*\n         MACRO\n         RCPLOCSW &SW\n.********************************************************************\n.*                                                                  *\n.*       INNER MACRO USED BY GOIF, SET, RESET AND FLIP.             *\n.*       THE PARM PASSED IS THE SWITCH OR LIST OF SWITCHES.         *\n.*       RCPLOCSW SCANS THE ARRAYS SET UP BY DCLSW TO SEE IF THE    *\n.*       SWITCH BIT NAMES WERE DECLARED, AND IF A LIST WAS PASSED,  *\n.*       WHETHER ALL THE SWITCH BITS BELONG TO THE SAME BYTE.       *\n.*       RCPLOCSW PASSES BACH THE SWITCH BYTE NAME IN GLOBAL SETC   *\n.*       VARIABLE &RCPDSW1 AND THE SWITCH BIT NAME IN GLOBAL SETC   *\n.*       &RCPDSW2. IF A LIST OF SWITCHES WAS PASSED, &RCPDSW2       *\n.*       CONTAINS THE SWITCH NAMES SEPARATED BY PLUS SIGNS.         *\n.*       IF THE FIRST OR ONLY SWITCH WAS NOT FOUND, &RCPDSW1 IS SET *\n.*       TO NULL. IF A LIST OF SWITCHES IS PASSED AND ANY SWITCH IS *\n.*       NOT DECLARED IN THE SAME SWITCH BYTE AS THE FIRST, AN MNOTE*\n.*       IS ISSUED WARNING OF POSSIBLE ERROR, BUT &RCPDSW1 IS SET   *\n.*       TO THE NAME OF THE SWITCH BYTE CONTAINING THE FIRST SWITCH *\n.*       BIT IN THE LIST.                                           *\n.*                                                                  *\n.********************************************************************\n         GBLA  &RCPDSW#,&RCPGSW#       COUNTER FOR DECLARED SWITCHES\n         GBLB  &RCPDSWD(99)            DEFER DECLARE INDICATORS\n         GBLC  &RCPDSWN(99)            SWITCH BYTE NAMES\n         GBLC  &RCPDSWB(800)           SWITCH BIT NAMES\n         GBLC  &RCPGSWN(99)            GENERIC SWITCH BYTE NAMES\n         GBLC  &RCPGSWB(99)            GENERIC SWITCH BIT PREFIXES\n         GBLC  &RCPDSW1                SWITCH BYTE NAME\n         GBLC  &RCPDSW2                SWITCH BIT NAME(S)\n         LCLA  &I,&J,&K,&L,&M,&N       LOCAL COUNTERS\n         LCLC  &C\n&RCPDSW2 SETC  '&SW(1)'                EXTRACT 1ST SWITCH BIT\n&J       SETA  &RCPDSW#*8+8            ARRAY POS OF LAST SW BIT\n&I       SETA  8                       ARRAY POS-1 OF 1ST SW BIT\n.LOOP1   AIF   (&I GE &J).TGEN         IF SW NOT FOUND IN 1ST ARRAY,\n.*                                      GO SEARCH GENERIC NAME ARRAY\n&I       SETA  &I+1\n         AIF   ('&RCPDSWB(&I)' NE '&RCPDSW2').LOOP1  LOOK FOR MATCH\n.*\n.*       OK, WE'VE FOUND A MATCH.\n.*\n&I       SETA  (&I-1)/8               GET POS OF SWITCH BYTE\n&RCPDSW1 SETC  '&RCPDSWN(&I)'         MOVE IT TO EXIT PARM VAR\n&I       SETA  &I*8+1                 POINT TO 1ST SW BIT IN IT\n&J       SETA  &I+8                   POINT TO LAST SW BIT IN IT\n&M       SETA  N'&SW                  GET NO OF SWITCHES\n&L       SETA  1\n.*\n.*       NOW WE PROCESS SUBSEQUENT SWITCHES IN THE LIST\n.*\n.LOOP2   AIF   (&L GE &M).EXIT        EXIT WHEN FINISHED\n&L       SETA  &L+1                   POINT TO NEXT SW IN LIST\n&C       SETC  '&SW(&L)'               EXTRACT IT\n&RCPDSW2 SETC  '&RCPDSW2.+&C'           THEN APPEND TO PREVIOUS\n.*\n.*       NOW WE CHECK THAT THE SWITCH IS DECLARED IN THE SAME\n.*       BYTE AS THE FIRST.\n.*\n&N       SETA  &I-1                     POINT TO 1ST BIT POS MINUS 1\n.LOOP3   AIF   (&N GE &J).NM            IF SW NOT FOUND, ISSUE MNOTE\n&N       SETA  &N+1                     POINT TO NEXT\n         AIF   ('&C' NE '&RCPDSWB(&N)').LOOP3  SEARCH FOR MATCH\n         AGO   .LOOP2                   IF FOUND, GO PROCESS NEXT\n.NM      MNOTE 4,'WARNING: SWITCH ''&C'' NOT DECLARED IN SAME BYTE AS  X\n               SWITCH ''&SW(1)'' - LOGIC ERROR MAY OCCUR'\n         AGO   .LOOP2            CONTINUE FOR NEXT SWITCH BIT\n.*\n.*       IF THE SWITCH WAS NOT LOCATED IN THE EXPLICIT NAME ARRAY,\n.*       THE GENERIC NAME ARRAY IS SEARCHED.\n.*\n.TGEN    ANOP\n&I       SETA  0\n&RCPDSW2 SETC  '&SW(1)'                EXTRACT 1ST SWITCH\n&L       SETA  K'&RCPDSW2              GET LENGTH OF 1ST SW\n.LOOP4   AIF   (&I GE &RCPGSW#).ERROR  IF NOT SW NOT DECLARED, ERROR\n&I       SETA  &I+1\n&C       SETC  '&RCPGSWB(&I)'          GET GENERIC PREFIX\n&K       SETA  K'&C                    GET LENGTH OF GENERIC PREFIX\n         AIF   (&L LT &K).LOOP4         AND SKIP IF LEN OF SWITCH NAME\n.*                                          < LEN OF GENERIC PREFIX\n         AIF   ('&RCPDSW2'(1,&K) NE '&C').LOOP4  ALSO SKIP IF NO MATCH\n&RCPDSW1 SETC  '&RCPGSWN(&I)'          SAVE SWITCH BYTE NAME\n&I       SETA   1\n&J       SETA   N'&SW\n.LOOP5   AIF   (&I GE &J).EXIT         EXIT WHEN FINISHED\n&I       SETA   &I+1\n&RCPDSW2 SETC   '&RCPDSW2.+&SW(&I)'     APPEND THIS SWITCH\n         AIF    ('&SW(&I)    '(1,&K) EQ '&C').LOOP5 CHECK PREFIX\n         MNOTE 4,'WARNING: SWITCH ''&SW(&I)'' NOT GENERICALLY EQUAL TO X\n               SWITCH ''&SW(1)'''\n         AGO   .LOOP5\n.ERROR   MNOTE 8,'SWITCH ''&SW(1)'' NOT DECLARED'\n&RCPDSW1 SETC  ''             INDICATE ERROR\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPMCA": {"ttr": 6159, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00\\x17\\x00\\x17\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:09", "lines": 23, "newlines": 23, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         RCPMCA &DSECT=YES\n         GBLC  &RCPPRE\n         GBLA  &RCPSWS(10)\n         LCLC  &P\n         RCPDEBUG\n&P       SETC  '&RCPPRE'\n         AIF   (&RCPSWS(2) NE 2).DSECT\n&P.MCA   DS    0F                       MODULE COMMUNICATIONS AREA\n         AGO   .MCA2\n.DSECT   ANOP  ,\n&P.MCA   DSECT ,                        MODULE COMMUNICATIONS AREA\n.MCA2    ANOP  ,\n&P.XDS   DS    A                        ADDR OF EXTERNAL DUMMY SECTION\n         AIF   (&RCPSWS(3) LT 1).EXIT\n&P.A#GET DS    A                        ADDRESS OF LIFO GET ROUTINE\n&P.A#FRE DS    A                        ADDRESS OF LIFO FREE ROUTINE\n&P.#S    DS    A                        ADDRESS OF CURRENT LIFO STACK\n&P.#E    DS    A                        ADDRESS OF END OF LIFO STACK\n&P.#N    DS    A                        ADDRESS OF NEXT FREE AREA\n&P.#C    DS    A                        ADDRESS OF NEXT LIFO STACK\n&P.#L    DS    F                        LENGTH OF CURRENT LIFO STACK\n.EXIT    MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPMCLAS": {"ttr": 6161, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00\\t\\x00\\t\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:09", "lines": 9, "newlines": 9, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPMCLAS &MCLAS\n         GBLC  &DYNP\n         SPACE 1\n***********************************************************************\n**   BUILD THE MGMTCLAS TEXT UNIT                                    **\n***********************************************************************\n.MCLAS   RCPTUBFX DALMGCL,14,&MCLAS\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPMSVGP": {"ttr": 6401, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00\\x1b\\x00\\x1b\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:09", "lines": 27, "newlines": 27, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPMSVGP &MSVGP\n         GBLC  &DYNP\n         SPACE 1\n***********************************************************************\n**   BUILD THE MSVGP TEXT UNIT                                       **\n***********************************************************************\n         AIF   ('&MSVGP'(K'&MSVGP,1) EQ '/').BTU\n         AIF   ('&MSVGP'(1,1) EQ '''').Q\n         RCPSR2\n         AIF   ('&MSVGP'(1,1) EQ '(').R\n         L     R14,&MSVGP              LOAD ADDRESS OF MSVGP\n         LH    R2,&MSVGP+4             LOAD LENGTH OF MSVGP\n         AGO   .STH\n.R       L     R14,0&MSVGP             LOAD ADDRESS OF MSVGP\n         LH    R2,4&MSVGP              LOAD LENGTH OF MSVGP\n.STH     STH   R2,S99TULNG             STORE MSVGP LENGTH\n         BCTR  R2,0                    DECREMENT FOR EXECUTE\n         EX    R2,&DYNP.MVC            MOVE MSVGP\n         MVI   S99TUKEY+1,DALMSVGP     MOVE IN MSVGP KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         RCPDINC 14\n         MEXIT\n.Q       RCPBTU DALMSVGP,1,&MSVGP\n         MEXIT\n.BTU     RCPTUBFR DALMSVGP,14,&MSVGP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPMUDEP": {"ttr": 6403, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\t\\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00'\\x00'\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:09", "lines": 39, "newlines": 39, "modlines": 0, "user": "MACRO"}, "text": "         MACRO -      TO CHECK FOR MUTUALLY DEPENDENT KEYWORDS\n         RCPMUDEP &A,&RC=4        MNOTE ERROR CODE\n         LCLA  &I,&J\n.*\n.*     THIS IS AN INNER MACRO THAT CAN BE USED TO CHECK\n.*     FOR KEYWORDS THAT ARE DEPENDENT ON OTHER KEYWORDS.\n.*     FOR EXAMPLE IN THE FOLLOWING MACRO:\n.*\n.*     MACRO\n.*     #FRED  &A=,&B=,&C=\n.*     ....\n.*     ....\n.*     MEND\n.*\n.*     IF C=XXX IS ONLY VALID WHEN &B IS SPECIFIED, I.E. IF\n.*     SPECIFICATION OF &C IS ONLY VALID WHEN &B IS SPECIFIED,\n.*     #FRED SHOULD INCLUDE THE FOLLOWING.\n.*\n.*     RCPMUDEP (B=,&B),(C=,&C),RC=NN\n.*\n.*     WHERE NN IS AN MNOTE ERROR CODE.\n.*     IF &B IS NULL, AN MNOTE WILL BE GENERATED FOR\n.*     &C IF &C IS SPECIFIED. IF &B IS SPECIFIED OR &C IS\n.*     NULL, NO MNOTE WILL BE GENERATED.\n.*     ANY NUMBER OF KEYWORDS CAN BE SPECIFIED.\n.*     THE FIRST OPERAND OF A SUBLIST IS THE KEYWORD NAME,\n.*     AND THE SECOND OPERAND IS THE KEYWORD VALUE.\n.*\n         AIF   ('&A(2)' NE '').EXIT    OK IF FIRST KW ENTERED\n&I       SETA  1\n&J       SETA  N'&SYSLIST\n.LOOP    ANOP\n&I       SETA  &I+1                    GET NEXT POSITIONAL\n         AIF   (&I GT &J).EXIT         EXIT IF ALL DONE\n         AIF   ('&SYSLIST(&I,2)' EQ '').LOOP   SKIP IF KEYWORD IS NULL\n         MNOTE &RC,'**** &SYSLIST(&I,1) CAN ONLY BE SPECIFIED WITH &A(1X\n               ), IT IS IGNORED'\n         AGO   .LOOP\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPMUEXC": {"ttr": 6405, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00!\\x00!\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:09", "lines": 33, "newlines": 33, "modlines": 0, "user": "MACRO"}, "text": "         MACRO -   TO CHECK FOR MUTUALLY EXCLUSIVE KEYWORDS\n         RCPMUEXC &RC=4       ERROR CODE FOR MNOTE\n         LCLA  &I,&J\n         LCLC  &C\n.*\n.*   THIS IS AN INNER MACRO WHICH CAN BE USED TO CHECK\n.*   FOR MUTUALLY EXCLUSIVE KEYWORDS.\n.*   FOR INSTANCE, IF A MACRO CALLED 'M' HAS 3 KEYWORDS,\n.*   'A','B','C', EACH OF WHICH IS MUTUALLY EXCLUSIVE,\n.*   THAT MACRO COULD CODE\n.*\n.*   RCPMUEXC (A=,&A),(B=,&B),(C=,&C),RC=N\n.*\n.*   WHERE N IS THE ERROR CODE FOR AN MNOTE (DEFAULT=4).\n.*   THE KEYWORDS ARE SPECIFIED IN HEIRARCHICAL ORDER.\n.*   I.E., IF A=XXXX, THE KEYWORDS B= & C= MUST BE NULL.\n.*   B=XXX IS ONLY VALID IF A=''  AND C=XXXX IS ONLY VALID IF\n.*   B=''. AN MNOTE IS GENERATED FOR EVERY MUTUALLY EXCLUSIVE\n.*   KEYWORD FOUND.\n&J       SETA  N'&SYSLIST     COUNT OF ENTRIES\n.LOOP    ANOP\n&I       SETA  &I+1                    GET NEXT POSIT PARAMETER\n         AIF   (&I GT &J).EXIT         EXIT IF NO MORE POSITIONALS\n         AIF   ('&SYSLIST(&I,2)' EQ '').LOOP IGNORE IF NULL OP\n&C       SETC  '&SYSLIST(&I,1)'        SAVE KEYWORD NAME\n.LOOP2   ANOP\n&I       SETA  &I+1                    GET NEXT POSIT PARAMETER\n         AIF   (&I GT &J).EXIT         EXIT IF ALL DONE\n         AIF   ('&SYSLIST(&I,2)' EQ '').LOOP2 IGNORE IF NULL OP\n         MNOTE &RC,'&SYSLIST(&I,1) MUTUALLY EXCLUSIVE WITH &C, IT IS IGX\n               NORED'\n         AGO   .LOOP2\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPNTU": {"ttr": 6407, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00/\\x00/\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:09", "lines": 47, "newlines": 47, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPNTU &KEY,&LEN,&PAR\n.*\n.*     THIS IS AN ALLOC/FREE MACRO TEXT UNIT PROCESSOR SUBROUTINE\n.*     MACRO. IT BUILDS NUMERIC TYPE TEXT UNITS.\n.*\n         LCLA  &L,&R\n         LCLC  &C\n         GBLC  &RCPTYPE\n.*  ALLOC/FREE INNER MACRO TO SET UP NUMERIC TEXT UNITS\n&L       SETA  1                       DEFAULT LENGTH\n         AIF   ('&LEN' EQ '').NL\n&L       SETA  &LEN\n.NL      MVI   S99TUKEY+1,&KEY         SET KEY FIELD\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         MVI   S99TULNG+1,&L           SET LENGTH FIELD\n         AIF   ('&PAR'(1,1) EQ '(').REG\n         RCPTYPE &PAR                  ANALYSE PARAMETER\n         AIF   ('&RCPTYPE' EQ 'N').NUMERIC\n&R       SETA  4-&L\n         MVC   S99TUPAR(&L),&R+&PAR    MOVE IN QUANTITY\n         RCPDINC 10\n         MEXIT\n.NUMERIC AIF   (&L EQ 1).NL1\n         MVC   S99TUPAR(&L.),=AL&L.(&PAR) MOVE IN QUANTITY\n&R       SETA  &L+6\n         AIF   (&R/2 EQ (&R+1)/2).LOK ENSURE LENGTH EVEN\n&R       SETA  &R+1\n.LOK     RCPDINC &R\n         MEXIT\n.NL1     MVI   S99TUPAR,&PAR           MOVE IN QUANTITY\n         RCPDINC 8\n         MEXIT\n.REG     ANOP\n&C       SETC  '&PAR'(2,K'&PAR-2)\n         AIF   (&L EQ 3).STCM\n         AIF   (&L EQ 2).STH\n         AIF   (&L EQ 1).STC\n         ST    &C,S99TUPAR             STORE TEXT UNIT QUANTITY\n         AGO   .RCPDINC\n.STH     STH   &C,S99TUPAR             STORE TEXT UNIT QUANTITY\n         AGO   .RCPDINC\n.STC     STC   &C,S99TUPAR             STORE TEXT UNIT QUANTITY\n         AGO   .RCPDINC\n.STCM    STCM  &C,7,S99TUPAR           STORE TEXT UNIT QUANTITY\n.RCPDINC RCPDINC 10\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPOPTCD": {"ttr": 4881, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00N\\x00N\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:56", "lines": 78, "newlines": 78, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    RCPOPTCD &CODES\n         LCLA  &CNT,&VAL\n         LCLC  &O,&REG\n         AIF   ('&CODES' EQ '').EXIT\n         AIF   ('&CODES'(1,2) EQ '((').REGS\n&CNT     SETA  0\n&VAL     SETA  0\n.*\n.PROCESS ANOP  ,\n&CNT     SETA  &CNT+1\n&O       SETC  '&CODES(&CNT)'\n         AIF   ('&O' EQ '').DONE\n.*\n.*       OPTCD=R OR OPTCD=J\n         AIF   ('&O' EQ 'R' OR '&O' EQ 'J').A1\n         AGO   .A2\n.A1      ANOP  ,\n&VAL     SETA  &VAL+1\n         AGO   .PROCESS\n.*\n.*       OPTCD=T\n.A2      AIF   ('&O' NE 'T').A3\n&VAL     SETA  &VAL+2\n         AGO   .PROCESS\n.*\n.*       OPTCD=Z\n.A3      AIF   ('&O' NE 'Z').A4\n&VAL     SETA  &VAL+4\n         AGO   .PROCESS\n.*\n.*       OPTCD=A OR OPTCD=Q\n.A4      AIF   ('&O' EQ 'A' OR '&O' EQ 'Q').A5\n         AGO   .A6\n.A5      ANOP  ,\n&VAL     SETA  &VAL+8\n         AGO   .PROCESS\n.*\n.*       OPTCD=F OR OPTCD=H OR OPTCD=O\n.A6      AIF   ('&O' EQ 'F' OR '&O' EQ 'H' OR '&O' EQ 'O').A5\n         AGO   .A8\n.A7      ANOP  ,\n&VAL     SETA  &VAL+64\n         AGO   .PROCESS\n.*\n.*       OPTCD=B\n.A8      AIF   ('&O' NE 'B').A9\n&VAL     SETA  &VAL+128\n         AGO   .PROCESS\n.*\n.A9      MNOTE 8,'INVALID OPTCD= VALUE (&O)'\n         AGO   .PROCESS\n.*\n.DONE    AIF   ('&VAL' EQ '0').EXIT\n         AGO   .OPDATA\n.*\n.REGS    ANOP  ,\n&REG     SETC  '&CODES'(3,K'&CODES-4)  REMOVE DOUBLE PARENS\n***********************************************************************\n**       OPTCD= Text Unit                                            **\n***********************************************************************\n         MVC   S99TUKEY,=AL2(DALOPTCD) Set Key\n         MVI   S99TUNUM+1,1            Set Count\n         MVI   S99TULNG+1,1            Set Length\n         STC   &REG,S99TUPAR           Set TU Parameter\n         RCPDINC 8\n         AGO   .EXIT\n.*\n.OPDATA  ANOP  ,\n***********************************************************************\n**       OPTCD= Text Unit                                            **\n***********************************************************************\n         MVC   S99TUKEY,=AL2(DALOPTCD) Set Key\n         MVI   S99TUNUM+1,1            Set Count\n         MVI   S99TULNG+1,1            Set Length\n         MVI   S99TUPAR,&VAL           Set TU Parameter\n         RCPDINC 8\n.EXIT    MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RCPOUTLI": {"ttr": 4883, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00\\x15\\x00\\x15\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:56", "lines": 21, "newlines": 21, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         RCPOUTLI &OUTLIM\n         LCLC  &REG\n         AIF   ('&OUTLIM' EQ '').EXIT\n***********************************************************************\n**       OUTLIM= Text Unit                                           **\n***********************************************************************\n         MVC   S99TUKEY,=AL2(DALOUTLM) Set Key\n         MVI   S99TUNUM+1,1            Set Count\n         MVI   S99TULNG+1,3            Set Length\n         AIF   (T'&OUTLIM NE 'N').LA\n         MVC   S99TUPAR(3),=AL3(&OUTLIM) Set TU Parameter\n         AGO   .LD\n.LA      AIF   ('&OUTLIM'(1,1) EQ '(').LR\n         MVC   S99TUPAR(3),&OUTLIM     Set TU Parameter\n         AGO   .LD\n.LR      ANOP  ,\n&REG     SETC  '&OUTLIM'(2,K'&OUTLIM-2)\n         STCM  &REG,7,S99TUPAR         Set TU Parameter\n.LD      RCPDINC 10\n.EXIT    MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RCPPERM": {"ttr": 6409, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00\\t\\x00\\t\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:09", "lines": 9, "newlines": 9, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPPERM\n         SPACE\n***********************************************************************\n**     PERMANENTLY ALLOCATED ATTRIBUTE TEXT UNIT                     **\n***********************************************************************\n         MVI   S99TUKEY+1,DALPERMA     SET TEXT UNIT KEY\n         RCPDINC  4\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPPPL": {"ttr": 6411, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00Z\\x00Z\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:09", "lines": 90, "newlines": 90, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    RCPPPL &PCL=,&NOPARM=,&PARSERR=,&PDLREG=R11,                  X\n               &PDLNAME=,&PARSEP=,&PARSWKA=\n         GBLB  &RCPPPL(2),&RCPECT(2)\n         GBLC  &RCPPRE,&RCPPREP\n         LCLC  &P\n&P       SETC  '&RCPPRE'\n         AIF   (&RCPPPL(2)).BPPL\n         EJECT ,\n         IKJPPL ,\nL#PPL    EQU   *-PPL                    LENGTH OF PPL\n&SYSECT  CSECT ,\n         SPACE 1\n&RCPPPL(2) SETB 1\n.BPPL    RCPDS ,\n&P.PPL   DS    CL(L#PPL)                RESERVE SPACE FOR PPL\n&P.PDLP  DS    F                        POINTER TO PDL\n         RCPDS ,\n         SPACE 6\n***********************************************************************\n***   THIS CODE GENERATES A PARSE PARAMETER LIST                    ***\n***********************************************************************\n         XC    &P.PDLP,&P.PDLP          ZERO PDL POINTER\n         AIF   ('&NOPARM(1)' EQ '' OR '&NOPARM(2)' NE '').PB2\n         L     R1,CPPLECT               LOAD ECT ADDRESS\n&RCPECT(1) SETB 1\n         USING ECT,R1                   ECT ADDRESSABLE\n         TM    ECTSWS,ECTNOPD           WERE ANY OPERANDS SUPPLIED ?\n         BO    &NOPARM(1)               NO, BRANCH OUT\n         SPACE 1\n.PB2     LA    R1,&P.PPL                LOAD PPL ADDRESS\n         USING PPL,R1\n         MVC   PPLUPT,CPPLUPT           MOVE IN UPT ADDRESS\n         MVC   PPLECT,CPPLECT           MOVE IN ECT ADDRESS\n         MVC   PPLCBUF,CPPLCBUF         MOVE IN CBUF ADDRESS\n         LA    R15,&P.ECB               LOAD ATTN ECB ADDRESS\n         ST    R15,PPLECB                AND STORE IN PPL\n         LA    R15,&P.PDLP              LOAD PDL POINTER ADDRESS\n         ST    R15,PPLANS                AND STORE IN PPL\n         AIF   ('&PARSWKA' EQ '').PB3\n         AIF   ('&PARSWKA'(1,1) EQ '').PB4\n         LA    R15,&PARSWKA             LOAD ADDRESS OF WORK AREA\n         ST    R15,PPLUWA                AND STORE IN PPL\n         AGO   .PB3\n.PB4     ST    &PARSWKA(1),PPLUWA       STORE ADDRESS OF WORKAREA\n.PB3     AIF   ('&PCL' EQ '').EXIT\n         L     R15,=A(&PCL)             LOAD PCL ADDRESS\n         ST    R15,PPLPCL                AND STORE IN PPL\n         SPACE 2\n         AIF   ('&NOPARM(1)' EQ '' OR '&NOPARM(2)' EQ '').PB5\n         L     R1,CPPLECT               LOAD ECT ADDRESS\n&RCPECT(1) SETB 1\n         USING ECT,R1\n         TM    ECTSWS,ECTNOPD           WERE ANY OPERANDS SUPPLIED ?\n         BO    &NOPARM(1)               NO, BRANCH OUT\n         SPACE 1\n.PB5     AIF   ('&RCPPREP' EQ '').NOPREP\n         L     R15,&RCPPREP             LOAD EP OF IKJPARS\n         BALR  R14,R15                  AND ENTER IT\n         AGO   .PRET\n.NOPREP  ANOP  ,\n         L     R15,16                   LOAD CVT ADDRESS\n         TM    524(R15),128             IS IKJPARS LOADED ?\n         AIF   ('&PARSEP' EQ '').PBL1\n         BZ    &P.LOAD                  NO, BRANCH TO LOAD SVC\n         L     R15,524(R15)             LOAD EP OF IKJPARS\n         ST    R15,&PARSEP              SAVE ITS ADDRESS\n         BALR  R14,R15                  THEN BALR TO IT\n         B     &P.PLNKB                 BYPASS LOAD SVC\n&P.LOAD  LOAD  EP=IKJPARS\n         LR    R15,R0                   LOAD EP OF IKJPARS\n         ST    R15,&PARSEP              SAVE IT\n         BALR  R14,R15                  THEN BALR TO IT\n&P.PLNKB DS    0H\n         AGO   .PRET\n.PBL1    BZ    &P.PLINK                 NO, BRANCH TO LINK SVC\n         L     R15,524(R15)             ELSE LOAD ITS ADDRESS\n         BALR  R14,R15                  AND BALR TO IT\n         B     &P.PLNKB                 BYPASS LINK SVC\n&P.PLINK LINK  EP=IKJPARS\n&P.PLNKB DS    0H\n.PRET    AIF   ('&PARSERR' EQ '').EXIT\n         SPACE 1\n         LTR   R15,R15                  TEST RETURN CODE\n         BNZ   &PARSERR                  AND BRANCH ON NON-ZERO\n         SPACE 1\n         AIF   ('&PDLREG' EQ '' OR '&PDLNAME' EQ '').EXIT\n         L     &PDLREG,&P.PDLP          LOAD PDL ADDRESS\n         USING &PDLNAME,&PDLREG         PDL DSECT ADDRESSABLE\n.EXIT    MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPPRIV": {"ttr": 4885, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x16&?\\x01\\x16&?\\x13\\x08\\x00\\t\\x00\\t\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:08:02", "lines": 9, "newlines": 9, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         RCPPRIV ,\n***********************************************************************\n**       Private Volume Text Unit                                    **\n***********************************************************************\n         MVC   S99TUKEY,=AL2(DALPRIVT) Set Key\n         MVI   S99TUNUM+1,0            Set Count\n         RCPDINC 4\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RCPPROC": {"ttr": 6413, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00\\x9e\\x00\\x9e\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:09", "lines": 158, "newlines": 158, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         RCPPROC &WKCSECT=,&WKDSECT=,                                  X\n               &REG1=,&REG0=,&ISA=,&SAVEPRE=,                          X\n               &SAVESUF=,&SP=\n         GBLA  &RCPSWS(10)\n         GBLC  &RCPPRE,&RCPWKCS,&RCPWKDS\n         GBLC  &RCPSPN\n         LCLC  &P,&C\n         RCPDEBUG\n&P       SETC  '&RCPPRE'\n         AIF   ('&WKCSECT' EQ '').TDS\n&RCPWKCS SETC  '&WKCSECT'\n         AGO   .SETCS2\n.TDS     AIF   ('&WKDSECT' EQ '').SYSECT\n&RCPWKDS SETC  '&WKDSECT'\n         AGO   .SETCS\n.SYSECT  ANOP  ,\n&RCPWKDS SETC  '&SYSECT'\n.SET1    AIF   (K'&RCPWKDS LT 8).LOK\n&RCPWKDS SETC  '&RCPWKDS'(1,4)'&RCPWKDS'(6,3)'1'\n         AGO   .SETCS\n.LOK     ANOP  ,\n&RCPWKDS SETC  '&RCPWKDS.1'\n.SETCS   ANOP  ,\n&RCPWKCS SETC  ''\n.SETCS2  ANOP  ,\n&RCPSWS(4) SETA &RCPSWS(2)-1 SET W/A TO BE FREED OPT IF PROC(MAIN)\n         AIF   ('&ISA' EQ '').NISA\n&RCPSWS(3) SETA 1                       SET LIFO FLAG IF ISA SPEC\n.NISA    ANOP  ,\n         SPACE 2\n         RCPDS ,\n         DS    9D                       SAVE AREA\n&P.RCODE DS    F                        RETURN CODE\n         RCPMCA ,\n         RCPDS ,\n         SPACE 2\n         AIF   ('&REG1' EQ '').TR0\n         LR    &REG1,R1                 SAVE CONTENTS OF REG 1\n.TR0     AIF   ('&REG0' EQ '').TP\n         LR    &REG0,R0                 SAVE CONTENTS OF REG 0\n.TP      AIF   (&RCPSWS(2) EQ 2).PROCMN   PROCMAIN OPTION\n         AIF   (&RCPSWS(3) EQ 1).PL     LIFO OPTION\n         L     R15,0(0,R13)             R15 -> MODULE COMM AREA\n         L     R15,&P.XDS-&P.MCA(0,R15) LOAD EXTERNAL DUMMY SECT ADDR\n         A     R15,&P.QCON              GET OFFSET TO WORK AREA\n         ST    R15,8(0,R13)             CHAIN SAVE\n         ST    R13,4(0,R15)              AREAS TOGETHER\n         MVC   0(4,R15),0(R13)          COPY POINTER TO COMM AREA\n         LR    R13,R15                  LOAD WORK AREA ADDRESS\n         USING &RCPWKCS&RCPWKDS,R13\n         MEXIT ,\n.PL      ANOP  ,\n***********************************************************************\n*        GET WORKAREA FROM LIFO STACK                                 *\n***********************************************************************\n         #GET  LV=&P.WKLEN\n         ST    R1,8(0,R13)              CHAIN SAVE\n         ST    R13,4(0,R1)               AREAS TOGETHER\n         MVC   0(4,R1),0(R13)           PROPAGATE MODULE COMM AREA ADDR\n         LR    R13,R1                   LOAD WORK AREA ADDRESS\n         USING &RCPWKCS&RCPWKDS,R13\n         MEXIT ,\n.PROCMN  L     R0,&P.CXD                LOAD WORK AREA LENGTH\n MNOTE *,'       GETMAIN RU,LV=(0),SP=&SP,BNDRY=PAGE'\n         GETMAIN RU,LV=(0),SP=&SP,BNDRY=PAGE\n         SR    R15,R15                  FROM LENGTH IS ZERO\n         LR    R14,R1                   SAVE WORK AREA ADDRESS\n         L     R1,&P.CXD                LOAD WORK AREA LENGTH\n         LR    R0,R14                   TO ADDRESS\n         MVCL  R0,R14                   CLEAR THE WORK AREA\n         LR    R1,R14                   RESTORE WORK AREA POINTER\n&RCPSPN  SETC  '&SP'\n         LR    R15,R13                  SAVE CALLER'S SAVE AREA ADDR\n         LR    R13,R1                   LOAD EXT DUMMY SECTION ADDR\n         AL    R13,&P.QCON              ADD OFFSET TO WORK AREA\n         ST    R13,8(0,R15)             CHAIN SAVE\n         ST    R15,4(0,R13)              AREAS TOGETHER\n         USING &RCPWKCS&RCPWKDS,R13\n         ST    R1,&P.XDS                STORE DUMMY SECTION ADDR IN    X\n                                         MODULE COMMUNICATIONS AREA\n         LA    R15,&P.MCA               STORE COMMUNICATIONS AREA ADDR\n         ST    R15,0(0,R13)              IN WORD 1 OF SAVE AREA\n         AIF   (&RCPSWS(3) EQ 0 AND '&ISA' EQ '').EXIT\n&RCPSWS(3) SETA 1                       SET LIFO IN CASE ONLY ISA SPEC\n&C       SETC  '&ISA'\n         AIF   ('&ISA' NE '').TK\n&C       SETC  '8192'\n         AGO   .NK\n.TK      AIF   ('&C'(K'&C,1) NE 'K').NK\n&C       SETC  '&C'(1,K'&C-1)'*1024'\n.NK      EJECT ,\n***********************************************************************\n**       INITIALIZE MODULE COMMUNICATIONS AREA WITH POINTERS         **\n**       TO LIFO STACK AND LIFO GET/FREE ROUTINES                    **\n***********************************************************************\n         SPACE 1\n         MVC   &P.A#GET,=A(#####GET)   MOVE LIFO GET AND FREE\n         MVC   &P.A#FRE,=A(####FREE)    ROUTINE ADDRESSES TO MCA\n         L     R15,=Q(#####ISA)        COMPUTE LIFO STACK\n         AL    R15,&P.XDS               PSEUDO REGISTER OFFSET\n         ST    R15,&P.#S                 AND INITIALIZE POINTERS\n         ST    R15,&P.#N                  IN MODULE COMMUNICATIONS AREA\n         L     R14,=A(&C)              LOAD SIZE OF INITIAL STACK AREA\n         ST    R14,&P.#L               STORE THIS IN MCA\n         ALR   R15,R14                  THEN COMPUTE STACK END ADDRESS\n         ST    R15,&P.#E                 AND STORE THIS INTO MCA\n         EJECT ,\n***********************************************************************\n**       LIFO STACK GET/FREE ROUTINES                                **\n***********************************************************************\n         SPACE 1\n#####ISA DXD   CL(&C)                   DEFINE PSEUDO REGISTER FOR ISA\n         SPACE 1\n         PUSH  USING\n         DROP  ,\n         USING &P.MCA,R1                R1 POINTS TO MCA\n#####GET RSECT ,                        LIFO GET ROUTINE\n#####GET AMODE ANY\n#####GET RMODE ANY\n         USING #####GET,R15             R0 CONTAINS LENGTH NEEDED\n         A     R0,&P.F7                 ROUND REQUEST UP TO\n         N     R0,&P.F8                 A DOUBLEWORD BOUNDARY\n         A     R0,&P.#N                 PT TO NEXT FREE LIFO SLOT\n         CL    R0,&P.#E                 IF WE'VE GONE PAST THE END OF\n         BH    &P.GA                    THE STACK, GIVE UP AND ABEND\n         L     R15,&P.#N                PT TO ALLOCATED SLOT\n         ST    R0,&P.#N                 SAVE ADDRESS OF NEXT SLOT\n         LR    R1,R15                   MOVE SLOT POINTER\n         BR    R14                      RETURN TO CALLER, R1 @ SLOT\n*        ABEND 1000,DUMP                STACK TOO SMALL, USE ISA=\n&P.GA    LA    R1,1000                  LOAD ABEND CODE\n         O     R1,&P.X8                 TURN ON DUMP FLAG\n         SVC   13                       ISSUE ABEND SVC\n         SPACE 1\n         ENTRY ####FREE                 LIFO FREE ROUTINE\n         USING ####FREE,R15             R0 CONTAINS ADDRESS\n####FREE CL    R0,&P.#S                 ENSURE THE ADDRESS\n         BL    &P.FA                    TO BE FREE'ED\n         CL    R0,&P.#E                 IS WITHIN THE BOUNDARIES\n         BH    &P.FA                    OF THE CURRENT STACK ELEMENT\n         A     R0,&P.F7                 FORCE AREA TO BE FREE'ED TO\n         N     R0,&P.F8                 DOUBLEWORD BNDRY FOR NEXT GUY\n         ST    R0,&P.#N                 SAVE @ NEXT FREE LIFO SLOT\n         BR    R14                      RETURN TO CALLER\n*        ABEND 1001,DUMP                INVALID AREA ADDRESS\n&P.FA    LA    R1,1001                  LOAD ABEND CODE\n         O     R1,&P.X8                 TURN ON DUMP FLAG\n         SVC   13                       ISSUE ABEND SVC\n         SPACE 1\n         CNOP  0,4                      GET FULLWORD BOUNDARY\n&P.F7    DC    F'7'                     CONSTANTS TO ROUND REQUEST UP\n&P.F8    DC    F'-8'                    TO A DOUBLEWORD BOUNDARY\n&P.X8    DC    X'80000000'              DUMP FLAG FOR ABEND\n         POP   USING                    KILL ADDRESSABILITY\n         SPACE 1\n&SYSECT  CSECT ,                        RESUME MAIN PROGRAM CSECT\n.EXIT    MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPPROT": {"ttr": 4887, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x16&?\\x01\\x16&?\\x13\\x08\\x00\\n\\x00\\n\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:08:02", "lines": 10, "newlines": 10, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         RCPPROT &PROT\n         AIF   ('&PROT' NE 'YES').EXIT\n***********************************************************************\n**       Protect=Yes                                                 **\n***********************************************************************\n         MVC   S99TUKEY,=AL2(DALPROT)  Set Key\n         MVI   S99TUNUM+1,0            Set Count\n         RCPDINC 4\n.EXIT    MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RCPPSWD": {"ttr": 6415, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00\\t\\x00\\t\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:09", "lines": 9, "newlines": 9, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPPSWD &PASSW\n         GBLC  &DYNP\n         SPACE\n***********************************************************************\n**   BUILD THE PASSWORD TEXT UNIT                                    **\n***********************************************************************\n         RCPVCHAR DALPASSW,14,&PASSW\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPQNAME": {"ttr": 6417, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00\\t\\x00\\t\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:20", "lines": 9, "newlines": 9, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPQNAME &QNAME\n         GBLC  &DYNP\n         SPACE\n***********************************************************************\n**   BUILD THE QNAME TEXT UNIT                                       **\n***********************************************************************\n         RCPVCHAR DALQNAME,14,&QNAME\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPRNGE": {"ttr": 6419, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00\\x11\\x00\\x11\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:20", "lines": 17, "newlines": 17, "modlines": 0, "user": "MACRO"}, "text": "         MACRO - BREAK A RANGE PARAMETER INTO TWO\n         RCPRNGE &P\n         GBLC  &RCPRNGE(2)\n         LCLA  &I,&J,&K\n&K       SETA  K'&P\n&RCPRNGE(1) SETC ''\n&RCPRNGE(2) SETC ''\n.LOOP    ANOP\n&I       SETA  &I+1\n         AIF   (&I GT &K).NR\n         AIF   ('&P'(&I,1) NE '-' AND '&P'(&I,1) NE ':').LOOP\n&RCPRNGE(1) SETC '&P'(1,&I-1)\n&RCPRNGE(2) SETC '&P'(&I+1,&K-&I)\n         MEXIT\n.NR      ANOP\n&RCPRNGE(1) SETC '&P'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPSCLAS": {"ttr": 6421, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00\\t\\x00\\t\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:20", "lines": 9, "newlines": 9, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPSCLAS &SCLAS\n         GBLC  &DYNP\n         SPACE 1\n***********************************************************************\n**   BUILD THE STORCLAS TEXT UNIT                                    **\n***********************************************************************\n.BTU     RCPTUBFX DALSTCL,14,&SCLAS\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPSPACE": {"ttr": 6657, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00_\\x00_\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:20", "lines": 95, "newlines": 95, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPSPACE &SPACE\n         GBLA  &RCPSUB#                NO OF SUBLIST ELEMENTS\n         GBLC  &RCPSUBL(100)           SUBLIST ELEMENTS\n.**********************************************************************\n.*    THIS IS AN ALLOC INNER MACRO TO BUILD THE ALLOCATION SPACE\n.*    QUANTITY TEXT UNIT. IT SHOULD BE SPECIFIED AS:-\n.*     SPACE=(TYPE,(PRIMARY,SECONDARY,DIRECTORY),RLSE,CONTIG,ROUND)\n.*   WHERE TYPE IS 'TRK', 'CYL', 'ABSTR' OR A BLOCK QUANTITY\n.*     'CYL' OR 'TRK' SHOULD NOT BE ENTERED IN QUOTES. THE BLOCK\n.*     QUANTITY CAN BE A NUMBER, A REGISTER (IN BRACKETS), OR THE\n.*     NAME OF A FULLWORD CONTAINING THE BLOCK SIZE.\n.**********************************************************************\n         AIF   ('&SPACE(1)' EQ '' OR '&SPACE(1)' EQ 'TRK').TRK\n         AIF   ('&SPACE(1)' EQ 'CYL').CYL\n***********************************************************************\n**        SPACE UNIT IN BLOCKS                                       **\n***********************************************************************\n         RCPNTU DALBLKLN,3,&SPACE(1)  GENERATE BLOCK UNIT TU\n         AGO   .TPRIME        GO TEST PRIME QUANTITY\n.TRK     ANOP  TRACK SPEC REQ OR DEFAULTED\n         SPACE\n***********************************************************************\n**       SPACE QUANTITY IN TRACKS                                    **\n***********************************************************************\n         MVI   S99TUKEY+1,DALTRK       SET TEXT UNIT KEY\n         RCPDINC 4\n         AGO   .TPRIME\n.CYL     ANOP  CYL QUANTITY\n         SPACE 1\n***********************************************************************\n**      SPACE UNIT IN CYLINDERS                                      **\n***********************************************************************\n         MVI   S99TUKEY+1,DALCYL       SET TEXT UNIT KEY\n         RCPDINC 4                     STORE TEXT UNIT ADDR\n.TPRIME  RCPSUBL &SPACE(2)             BREAK UP SUBLIST\n         AIF   (&RCPSUB# EQ 0).TCONTIG\n         AIF   ('&RCPSUBL(1)' EQ '').TSP2\n         SPACE\n***********************************************************************\n**       PRIMARY SPACE QUANTITY                                      **\n***********************************************************************\n         RCPNTU DALPRIME,3,&RCPSUBL(1)\n.TSP2    AIF   (&RCPSUB# LT 2).TCONTIG\n         AIF   ('&RCPSUBL(2)' EQ '').TSP3\n         SPACE\n***********************************************************************\n**       SECONDARY SPACE QUANTITY                                    **\n***********************************************************************\n         RCPNTU DALSECND,3,&RCPSUBL(2)\n.TSP3    AIF   (&RCPSUB# LT 3).TCONTIG\n         AIF   ('&RCPSUBL(3)' EQ '').TCONTIG\n         SPACE\n***********************************************************************\n**       DIRECTORY BLOCK QUANTITY                                    **\n***********************************************************************\n         RCPNTU DALDIR,3,&RCPSUBL(3)\n.TCONTIG AIF  ('&SPACE(3)' EQ 'CONTIG' OR '&SPACE(4)' EQ 'CONTIG').CON\n         AIF   ('&SPACE(3)' EQ 'MXIG' OR '&SPACE(4)' EQ 'MXIG').MXIG\n         AIF   ('&SPACE(3)' EQ 'ALX' OR '&SPACE(4)' EQ 'ALX').ALX\n.TRLSE   AIF   ('&SPACE(3)' EQ 'RLSE' OR '&SPACE(4)' EQ 'RLSE').RLSE\n.TROUND  AIF   ('&SPACE(4)'EQ'ROUND'OR'&SPACE(5)'EQ'ROUND').ROUND\n         MEXIT\n.CON     ANOP\n***********************************************************************\n**      CONTIGUOUS SPACE TEXT UNIT                                   **\n***********************************************************************\n         RCPNTU DALSPFRM,1,8\n         AGO   .TRLSE\n.MXIG    ANOP\n***********************************************************************\n**       MAXIMUM CONTIGUOUS SPACE TEXT UNIT                          **\n***********************************************************************\n         RCPNTU DALSPFRM,1,4\n         AGO   .TRLSE\n.ALX     ANOP\n***********************************************************************\n**       'ALX' SPACE TEXT UNIT                                       **\n***********************************************************************\n         RCPNTU DALSPFRM,1,2\n         AGO   .TRLSE\n.RLSE    ANOP\n***********************************************************************\n**      RELEASE UNUSED SPACE TEXT UNIT                               **\n***********************************************************************\n         MVI   S99TUKEY+1,DALRLSE      SET TEXT UNIT KEY\n         RCPDINC 4\n         AGO   .TROUND\n.ROUND   ANOP\n***********************************************************************\n**      RELEASE UNUSED SPACE TEXT UNIT                               **\n***********************************************************************\n         MVI   S99TUKEY+1,DALROUND     MOVE IN TEXT UNIT KEY\n         RCPDINC 4\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPSPEC": {"ttr": 6659, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00\\r\\x00\\r\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:20", "lines": 13, "newlines": 13, "modlines": 0, "user": "MACRO"}, "text": "         MACRO - SET UP USER DEFINED TEXT UNIT\n         RCPSPEC &T\n         LCLA  &I,&J\n&I       SETA  1\n&J       SETA  K'&T\n         SPACE\n***********************************************************************\n**       PROCESS SPECIAL TEXT UNITS                                  **\n***********************************************************************\n.LOOP    RCPVCHAR &T(&I),&T(&I+2),&T(&I+3),N=&T(&I+1)\n&I       SETA  &I+4\n         AIF   (&I LE &J).LOOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPSR2": {"ttr": 6661, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00\\x14\\x00\\x14\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:20", "lines": 20, "newlines": 20, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPSR2 &A\n         GBLB  &RCPSR2\n         GBLC  &DYNP\n         LCLC  &C\n.*   TO SAVE REG 2 IN REG 0 FOR ALLOC INNER MACROS FIRST TIME ONLY\n.*    IF OPERAND SUPPLIED AND SAVE DONE, RESTORES REG 2 AND\n.*    GENERATES MOVE INSTRUCTION FOR EXECUTE\n         AIF   ('&A' NE '').UNSAVE\n         AIF   (&RCPSR2).EXIT\n&RCPSR2  SETB  1\n         LR    R0,R2                   SAVE CONTENTS OF REGISTER 2\n         MEXIT\n.UNSAVE  AIF   (NOT &RCPSR2).EXIT\n         B     *+10                    SKIP NEXT INSTRUCTION\n&C       SETC  '&DYNP.MVC'\n&C       MVC   S99TUPAR(0),0(R14)      EXECUTED MOVE\n         LR    R2,R0                   RESTORE CONTENTS OF REGISTER 2\n&RCPSR2  SETB  0\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPSSREQ": {"ttr": 6663, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00\\n\\x00\\n\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:20", "lines": 10, "newlines": 10, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPSSREQ\n         SPACE 1\n***********************************************************************\n**       SUBSYSTEM REQUEST TEXT UNIT                                 **\n***********************************************************************\n         SPACE 1\n         MVI   S99TUKEY+1,DALSSREQ MOVE IN TEXT UNIT KEY\n         RCPDINC                   4\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPSUBL": {"ttr": 6665, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x12\\x01\\x16&?\\x01\\x16&?\\x13\\x08\\x00$\\x00$\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:08:12", "lines": 36, "newlines": 36, "modlines": 0, "user": "MACRO"}, "text": "         MACRO - BREAK DOWN A SUBLIST\n         RCPSUBL &L\n         GBLA  &RCPSUB#                NO OF ELEMENTS FOUND\n         GBLC  &RCPSUBL(100)           ELEMENTS\n         LCLA  &I,&J,&K\n&RCPSUB# SETA  0                       INITIALIZE\n         AIF   ('&L' EQ '').EXIT       EXIT IF NULL STRING\n         AIF   ('&L'(1,1) NE '(').NOSUB\n&K       SETA  K'&L-1\n&I       SETA  2\n&J       SETA  1\n.LOOP    ANOP\n&J       SETA  &J+1\n         AIF   (&J  GT &K).LAST\n         AIF   ('&L'(&J,1) NE ',').LOOP\n&RCPSUB# SETA &RCPSUB#+1\n         AIF   (&J EQ &I).NULL\n&RCPSUBL(&RCPSUB#) SETC '&L'(&I,&J-&I)\n&I       SETA  &J+1\n         AGO   .LOOP\n.NULL    ANOP\n&RCPSUBL(&RCPSUB#) SETC ''\n&I       SETA  &J+1\n         AGO   .LOOP\n.LAST    AIF   (&J EQ &I).LASTNUL\n&RCPSUB# SETA  &RCPSUB#+1\n&RCPSUBL(&RCPSUB#) SETC '&L'(&I,&J-&I)\n         AGO   .EXIT\n.LASTNUL ANOP\n&RCPSUB# SETA  &RCPSUB#+1\n&RCPSUBL(&RCPSUB#) SETC ''\n         AGO   .EXIT\n.NOSUB   ANOP\n&RCPSUBL(1) SETC '&L'\n&RCPSUB# SETA 1\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPSUBS": {"ttr": 4889, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x12\\x01\\x16&?\\x01\\x16&?\\x13\\x08\\x00,\\x00,\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:08:12", "lines": 44, "newlines": 44, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         RCPSUBS &SUBSYS\n         AIF   ('&SUBSYS(1)' EQ '').PARM\n***********************************************************************\n**       Subsystem Name Text Unit                                    **\n***********************************************************************\n         AIF   ('&SUBSYS(1)'(1,1) EQ '''').Q\n         RCPSR2 ,\n         AIF   ('&SUBSYS(1)'(1,1) EQ '(').R\n         L     R14,&SUBSYS(1)          A(SubSystem Name)\n         LH    R2,&SUBSYS(1)+4         L(SubSystem Name)\n         AGO   .STH\n.R       L     R14,0&SUBSYS(1)         A(SubSystem Name)\n         LH    R2,4&SUBSYS(1)          L(SubSystem Name)\n.STH     MVC   S99TUKEY,=AL2(DALSSNM)  Set Key\n         MVI   S99TUNUM+1,1            Set Count\n         STH   R2,S99TULNG             Set Length\n         SHI   R2,1\n         EX    R2,&DYNP.MVC            Set TU Parameter\n         RCPDINC 10\n         AGO   .PARM\n.Q       RCPBTU DALSSNM,1,&SUBSYS(1)\n.PARM    AIF   ('&SUBSYS(2)' EQ '').EXIT\n***********************************************************************\n**       Subsystem Parameters Text Unit                               *\n***********************************************************************\n         AIF   ('&SUBSYS(2)'(1,1) EQ '''').QP\n         RCPSR2 ,\n         AIF   ('&SUBSYS(2)'(1,1) EQ '(').RP\n         L     R14,&SUBSYS(2)          A(SubSystem Parameters)\n         LH    R2,&SUBSYS(2)+4         L(SubSystem Parameters)\n         AGO   .STHP\n.RP      L     R14,0&SUBSYS(2)         A(SubSystem Parameters)\n         LH    R2,4&SUBSYS(2)          L(SubSystem Parameters)\n.STHP    MVC   S99TUKEY,=AL2(DALSSPRM) Set Key\n         MVI   S99TUNUM+1,1            Set Count\n         STH   R2,S99TULNG             Set Length\n         SHI   R2,1\n         EX    R2,&DYNP.MVC            Set TU Parameter\n         RCPDINC 254\n         MEXIT ,\n.QP      RCPBTU DALSSPRM,1,&SUBSYS(2)\n         MEXIT ,\n.EXIT    MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RCPSYSOU": {"ttr": 6667, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00H\\x00H\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:20", "lines": 72, "newlines": 72, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPSYSOU &CLASS,&COPIES=,&FREE=,&DEST=,&FORMS=,&HOLD=\n         GBLC  &DYNP\n         LCLC  &C\n         AIF   ('&CLASS(1)' EQ '').TPGN\n&C       SETC  '&CLASS(1)'\n         SPACE\n***********************************************************************\n**       SYSOUT CLASS TEXT UNIT                                      **\n***********************************************************************\n         AIF   ('&C'(1,1) EQ '''').Q\n         AIF   ('&C'(K'&C,1) EQ '/').BS\n         AIF   ('&C'(1,1) EQ '(').REG\n         L     R14,&C                  LOAD ADDRESS OF SYSOUT CLASS\n         MVC   S99TUPAR(1),0(R14)       AND MOVE IT TO TEXT UNIT\n         AGO   .SKEY\n.REG     MVC   S99TUPAR(1),0&C         MOVE SYSOUT CLASS TO TEXT UNIT\n.SKEY    MVI   S99TUKEY+1,DALSYSOU     SET SYSOUT KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         MVI   S99TULNG+1,1            SET LENGTH FIELD\n         RCPDINC 8\n         AGO   .TPGN\n.BS      RCPTUBFR DALSYSOU,14,&C\n         AGO   .TPGN\n.Q       RCPBTU DALSYSOU,1,&C\n.TPGN    AIF   ('&CLASS(2)' EQ '').TCOP\n         SPACE\n***********************************************************************\n**   SYSOUT PROGRAM NAME TEXT UNIT                                   **\n***********************************************************************\n&C       SETC  '&CLASS(2)'\n         RCPVCHAR DALSPGNM,14,&C\n.TCOP    AIF   ('&COPIES' EQ '').TFREE\n         SPACE\n***********************************************************************\n**    SYSOUT COPIES TEXT UNIT                                        **\n***********************************************************************\n         RCPNTU DALCOPYS,1,&COPIES\n.TFREE   AIF   ('&FREE' EQ '').TDEST\n         SPACE\n***********************************************************************\n**     FREE = CLOSE TEXT UNIT                                        **\n***********************************************************************\n         AIF   ('&FREE' EQ 'CLOSE').CLOSEOK\n         MNOTE 4,' **** FREE=&FREE INVALID, FREE=CLOSE USED'\n.CLOSEOK MVI   S99TUKEY+1,DALCLOSE     MOVE IN TEXT UNIT KEY\n         RCPDINC 4\n.TDEST   AIF   ('&DEST' EQ '').TFORMS\n         SPACE\n***********************************************************************\n**       SYSOUT DESTINATION TEXT UNIT                                **\n***********************************************************************\n         RCPVCHAR DALSUSER,14,&DEST\n.TFORMS  AIF   ('&FORMS' EQ '').THOLD\n         SPACE\n***********************************************************************\n**     SYSOUT FORMS NUMBER TEXT UNIT                                 **\n***********************************************************************\n         RCPVCHAR DALSFMNO,14,&FORMS\n.THOLD   AIF   ('&HOLD' EQ '').EXIT\n         SPACE\n***********************************************************************\n**       HOLD SYSOUT TEXT UNIT                                       **\n***********************************************************************\n         SPACE 1\n         AIF   ('&HOLD' EQ 'YES').HOLD\n         AIF   ('&HOLD' EQ 'NO').EXIT\n         MNOTE 4,' **** HOLD=&HOLD INVALID, HOLD=YES USED'\n.HOLD    ANOP\n         MVI   S99TUKEY+1,DALSHOLD MOVE IN TEXT UNIT KEY\n         RCPDINC 4\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPTERM": {"ttr": 6669, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00\\t\\x00\\t\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:20", "lines": 9, "newlines": 9, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPTERM\n         SPACE\n***********************************************************************\n**      TERM  DATASET TEXT UNIT                                      **\n***********************************************************************\n         MVI   S99TUKEY+1,DALTERM      MOVE IN TERM DS TEXT UNIT KEY\n         RCPDINC 4\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPTU": {"ttr": 6671, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00\\x19\\x00\\x19\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:20", "lines": 25, "newlines": 25, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPTU &TU            TEXT UNIT LIST\n         GBLA  &DTUPO         TEXT UNIT POINTER OFFSET\n         GBLC  &DYNP          ALLOC SYMBOL PREFIX\n         LCLA  &I,&J\n         LCLC  &C\n         SPACE 1\n***********************************************************************\n**       ADD SPECIAL TEXT UNITS                                      **\n***********************************************************************\n&J       SETA  N'&TU\n.LOOP    ANOP\n&I       SETA  &I+1\n         AIF   (&I GT &J).EXIT\n         AIF   ('&TU(&I)'(1,1) EQ '(').R\n         LA    R14,&TU(&I)             LOAD TEXT UNIT ADDRESS\n         ST    R14,&DYNP.TUP+&DTUPO     AND STORE IT IN POINTER LIST\n&DTUPO   SETA  &DTUPO+4\n         AGO   .LOOP\n.R       ANOP\n&C       SETC  '&TU(&I)'(2,K'&TU(&I)-2)\n         ST    &C,&DYNP.TUP+&DTUPO     STORE TEXT UNIT ADDR IN PTR LIST\n&DTUPO   SETA  &DTUPO+4\n         AGO   .LOOP\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPTUBFR": {"ttr": 6673, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00<\\x00<\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:20", "lines": 60, "newlines": 60, "modlines": 0, "user": "MACRO"}, "text": "         MACRO  - BUILD TEXT UNIT FROM BUFFER\n         RCPTUBFR &KEY,                TEXT UNIT KEY                   X\n               &L,                     MAXIMUM LENGTH VALUE            X\n               &C,                     TEXT UNIT                       X\n               &N=1                    TEXT UNIT NUMBER\n         GBLC  &EXECNAM\n         LCLC  &C1,&C2\n         LCLA  &I,&K\n         MVI   S99TUKEY+1,&KEY         SET TEXT UNIT KEY\n         AIF   ('&N' EQ '' OR '&N' EQ '1').N1\n         LA    R14,&N                  LOAD TEXT UNIT NUMBER\n         STH   R14,S99TUNUM             AND STORE INTO TEXT UNIT\n         AGO   .ENDN\n.N1      MVI   S99TUNUM+1,1            SET TEXT UNIT NUMBER\n.ENDN    ANOP\n&K       SETA  K'&C\n&I       SETA  &K-1\n.LOOP1   ANOP\n&K       SETA  &K-1\n         AIF   (&K LE 0).STD\n         AIF   ('&C'(&K,1) NE '/').LOOP1\n&C2      SETC  '&C'(&K+1,&I-&K)\n&C1      SETC  '&C'(1,&K-1)\n         AIF   ('&C1'(1,1) NE '(').TC2\n&C1      SETC  '0&C1'\n.TC2     AIF   ('&C2' EQ '0000').V2B\n         AIF   ('&C2' EQ '00').V1B\n         AIF   ('&C2' EQ '0').V0B\n         AIF   ('&C2'(1,1) EQ '(').RL\n         MVI   S99TULNG+1,&C2          SET LENGTH FIELD\n         MVC   S99TUPAR(&C2.),&C1      MOVE IN TEXT UNIT\n         RCPDINC &L\n         MEXIT\n.STD     ANOP\n&K       SETA  &L-6\n         MVI   S99TULNG+1,&K           SET TEXT UNIT LENGTH\n&C1      SETC  '&C'(1,&I)              REMOVE TRAILING SLASH\n         MVC   S99TUPAR(&K),&C1        MOVE IN TEXT UNIT\n         RCPDINC &L\n         MEXIT\n.V2B     LH    R14,&C1                 LOAD TEXT UNIT LENGTH\n         S     R14,=A(4)               EXCLUDE LENGTH OF HEADER\n&C1      SETC  '4+&C1'\n         AGO   .MOVE\n.V1B     LH    R14,&C1                 LOAD TEXT UNIT LENGTH\n&C1      SETC  '2+&C1'\n         AGO   .MOVE\n.V0B     SLR   R14,R14                 CLEAR FOR IC\n         IC    R14,&C1                 INSERT TEXT UNIT LENGTH\n&C1      SETC  '1+&C1'\n         AGO   .MOVE\n.RL      ANOP\n&C2      SETC  '&C2'(2,K'&C2-2)\n         LR    R14,&C2                 LOAD TEXT UNIT LENGTH\n.MOVE    STH   R14,S99TULNG             AND STORE INTO LENGTH FIELD\n         BCTR  R14,0                   GET MACHINE LENGTH\n         #EXEC ,MVC,S99TUPAR-S99TUNIT(0,R15),&C1\n         EX    R14,&EXECNAM            MOVE IN TEXT UNIT\n         RCPDINC &L\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPTUBFX": {"ttr": 6675, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00=\\x00=\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:20", "lines": 61, "newlines": 61, "modlines": 0, "user": "MACRO"}, "text": "         MACRO  - BUILD TEXT UNIT FROM BUFFER\n         RCPTUBFX &KEY,                TEXT UNIT KEY                   X\n               &L,                     MAXIMUM LENGTH VALUE            X\n               &C,                     TEXT UNIT                       X\n               &N=1                    TEXT UNIT NUMBER\n         GBLC  &EXECNAM\n         LCLC  &C1,&C2,&QUOTE\n         LCLA  &I,&K\n&QUOTE   SETC  ''''\n         MVC   S99TUKEY,=AL2(&KEY)     SET TEXT UNIT KEY\n         AIF   ('&N' EQ '' OR '&N' EQ '1').N1\n         LA    R14,&N                  LOAD TEXT UNIT NUMBER\n         STH   R14,S99TUNUM             AND STORE INTO TEXT UNIT\n         AGO   .ENDN\n.N1      MVI   S99TUNUM+1,1            SET TEXT UNIT NUMBER\n.ENDN    ANOP\n&K       SETA  K'&C\n&I       SETA  &K-1\n.LOOP1   ANOP\n&K       SETA  &K-1\n         AIF   (&K LE 0).STD\n         AIF   ('&C'(&K,1) NE '/').LOOP1\n&C2      SETC  '&C'(&K+1,&I-&K)\n&C1      SETC  '&C'(1,&K-1)\n         AIF   ('&C1'(1,1) NE '(').TC2\n&C1      SETC  '0&C1'\n.TC2     AIF   ('&C2' EQ '0000').V2B\n         AIF   ('&C2' EQ '00').V1B\n         AIF   ('&C2' EQ '0').V0B\n         AIF   ('&C2'(1,1) EQ '(').RL\n         MVI   S99TULNG+1,&C2          SET LENGTH FIELD\n         MVC   S99TUPAR(&C2.),=CL&C2.'&C1.' MOVE IN TEXT UNIT\n         RCPDINC &L\n         MEXIT\n.STD     ANOP\n&K       SETA  &L-6\n         MVI   S99TULNG+1,&K           SET TEXT UNIT LENGTH\n&C1      SETC  '&C'(1,&I)              REMOVE TRAILING SLASH\n         MVC   S99TUPAR(&K.),=CL&K.&C1.&QUOTE MOVE IN TEXT UNIT\n         RCPDINC &L\n         MEXIT\n.V2B     LH    R14,&C1                 LOAD TEXT UNIT LENGTH\n         S     R14,=A(4)               EXCLUDE LENGTH OF HEADER\n&C1      SETC  '4+&C1'\n         AGO   .MOVE\n.V1B     LH    R14,&C1                 LOAD TEXT UNIT LENGTH\n&C1      SETC  '2+&C1'\n         AGO   .MOVE\n.V0B     SLR   R14,R14                 CLEAR FOR IC\n         IC    R14,&C1                 INSERT TEXT UNIT LENGTH\n&C1      SETC  '1+&C1'\n         AGO   .MOVE\n.RL      ANOP\n&C2      SETC  '&C2'(2,K'&C2-2)\n         LR    R14,&C2                 LOAD TEXT UNIT LENGTH\n.MOVE    STH   R14,S99TULNG             AND STORE INTO LENGTH FIELD\n         BCTR  R14,0                   GET MACHINE LENGTH\n         #EXEC ,MVC,S99TUPAR-S99TUNIT(0,R15),&C1\n         EX    R14,&EXECNAM            MOVE IN TEXT UNIT\n         RCPDINC &L\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPTXTL": {"ttr": 6677, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00\\x11\\x00\\x11\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:20", "lines": 17, "newlines": 17, "modlines": 0, "user": "MACRO"}, "text": "         MACRO - TO COUNT CHARACTERS IN A STRING\n         RCPTXTL &S\n         GBLA  &RCPTXTL\n         LCLA  &I,&L\n         LCLB  &PAIR\n&RCPTXTL SETA  K'&S-2\n         AIF   (&RCPTXTL LT 2).MEND\n&L       SETA  &RCPTXTL\n&I       SETA  1\n&PAIR    SETB  0\n.LOOP    ANOP  ,\n&I       SETA  &I+1+&PAIR\n         AIF   (&I GT &L).MEND\n&PAIR    SETB  ('&S'(&I,2) EQ '''''' OR '&S'(&I,2) EQ '&&')\n&RCPTXTL SETA  &RCPTXTL-&PAIR\n         AGO   .LOOP\n.MEND    MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPTYPE": {"ttr": 6679, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x12\\x01\\x16&?\\x01\\x16&?\\x13\\x08\\x00\\x0e\\x00\\x0e\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:08:12", "lines": 14, "newlines": 14, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPTYPE &T\n         GBLC  &RCPTYPE\n         LCLA  &I,&K\n&K       SETA  K'&T\n&RCPTYPE SETC  ''\n         AIF   (&K EQ 0).EXIT\n&RCPTYPE SETC  'C'\n.LOOP    ANOP\n&I       SETA  &I+1\n         AIF   ('&T'(&I,1) LT '0' OR '&T'(&I,1) GT '9').EXIT\n         AIF   (&I LT &K).LOOP\n&RCPTYPE SETC  'N'\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPUCS": {"ttr": 4891, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x12\\x01\\x16&?\\x01\\x16&?\\x13\\x08\\x00&\\x00&\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:08:12", "lines": 38, "newlines": 38, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         RCPUCS &NAME,&FOLD,&VERIFY\n         LCLC  &O,&REG\n         GBLC  &DYNP\n         AIF   ('NAME' EQ '').M400\n***********************************************************************\n**       UCS Name Text Unit                                          **\n***********************************************************************\n         AIF   ('&NAME'(1,1) EQ '''').M300\n         AIF   ('&NAME'(1,1) EQ '(').M100\n         L     R14,&NAME           A(NAME)\n         LH    R2,&NAME+4          L(NAME)\n         AGO   .M200\n.M100    L     R14,0&DSN           A(NAME)\n         LH    R2,4&DSN            L(NAME)\n.M200    MVC   S99TUKEY,=AL2(DALUCS)   Set Key\n         MVI   S99TUNUM+1,1            Set Count\n         STH   R2,S99TULNG             Set Length\n         SHI   R2,1\n         EX    R2,&DYNP.MVC            Set TU Parameter\n         RCPDINC 14\n         AGO   .M400\n.M300    RCPBTU DALUCS,1,&NAME\n.M400    AIF   ('&FOLD' NE 'FOLD').M500\n***********************************************************************\n**       UCS Fold Mode Text Unit                                     **\n***********************************************************************\n         MVC   S99TUKEY,=AL2(DALUFOLD) Set Key\n         MVI   S99TUNUM+1,0            Set Count\n         RCPDINC 4\n.M500    AIF   ('&VERIFY' NE 'VERIFY').EXIT\n***********************************************************************\n**       Character Set Verification Text Unit                        **\n***********************************************************************\n         MVC   S99TUKEY,=AL2(DALUVRFY) Set Key\n         MVI   S99TUNUM+1,0            Set Count\n         RCPDINC 4\n.EXIT    MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RCPUNALC": {"ttr": 6681, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00\\t\\x00\\t\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:20", "lines": 9, "newlines": 9, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPUNALC\n         SPACE 1\n***********************************************************************\n**     FREE EVEN IF PERMANENTLY ALLOCATED                            **\n***********************************************************************\n         MVI   S99TUKEY+1,DUNUNALC     SET TEXT UNIT KEY\n         RCPDINC  4\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPUNIT": {"ttr": 6683, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00\\x14\\x00\\x14\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:20", "lines": 20, "newlines": 20, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPUNIT &U,&V\n         GBLC  &DYNP\n         LCLC  &X\n&X       SETC  '&SYSNDX'\n.TPARM1  ANOP\n         AIF   ('&U' EQ '').TPARM2\n         SPACE ,\n***********************************************************************\n**       UNIT NAME TEXT UNIT                                         **\n***********************************************************************\n         RCPVCHAR DALUNIT,14,&U\n.TPARM2  ANOP\n         AIF   ('&V' EQ '').EXIT\n         SPACE ,\n***********************************************************************\n**       VOLUME SERIAL TEXT UNIT                                     **\n***********************************************************************\n         RCPVCHAR DALVLSER,14,&V\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPUNITC": {"ttr": 6685, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00\\x08\\x00\\x08\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:20", "lines": 8, "newlines": 8, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPUNITC &CNT\n         SPACE\n***********************************************************************\n**     UNIT ALLOCATION COUNT TEXT UNIT                               **\n***********************************************************************\n         RCPNTU DALUNCNT,1,&CNT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPVCHAR": {"ttr": 6913, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00)\\x00)\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:20", "lines": 41, "newlines": 41, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPVCHAR &KEY,&LEN,&C,&N=1\n         GBLC  &DYNP\n         AIF   ('&C'(K'&C,1) EQ '/').BM\n         AIF   ('&C'(1,1) EQ '''').QM\n         RCPSR2\n         AIF   ('&C'(1,1) EQ '(').RM\n         AIF   ('&C'(2,1) EQ '(').SM\n         AIF   ('&C'(3,1) EQ '(').SM\n         LH    R2,&C+4                 LOAD LENGTH OF TEXT UNIT\n         LTR   R2,R2                   TEST FOR ZERO\n         BZ    *+30                    IF NO TEXT UNIT, SKIP\n.*       BZ    *+34                    IF NO TEXT UNIT, SKIP\n         L     R14,&C                  LOAD ADDRESS OF TEXT UNIT\n         AGO   .STHM\n.RM      LH    R2,4&C                  LOAD LENGTH OF TEXT UNIT\n         LTR   R2,R2                   AND TEST FOR ZERO\n         BZ    *+30                    IF NO TEXT UNIT, SKIP\n.*       BZ    *+34                    IF NO TEXT UNIT, SKIP\n         L     R14,0&C                 LOAD ADDRESS OF TEXT UNIT\n         AGO   .STHM\n.SM      LH    R2,4+&C                 LOAD LENGTH OF TEXT UNIT\n         LTR   R2,R2                   TEST FOR ZERO\n         BZ    *+30                    IF NO TEXT UNIT, SKIP\n.*       BZ    *+34                    IF NO TEXT UNIT, SKIP\n         L     R14,&C                  LOAD ADDRESS OF TEXT UNIT\n.STHM    STH   R2,S99TULNG             STORE LENGTH OF TEXT UNIT\n         BCTR  R2,0                    DECREMENT FOR EXECUTE\n         EX    R2,&DYNP.MVC            MOVE IN TEXT UNIT\n         MVI   S99TUKEY+1,&KEY         MOVE IN TEXT UNIT KEY\n         AIF   ('&N' EQ '1' OR '&N' EQ '').N1\n         LA    R14,&N                  LOAD TEXT UNIT NUMBER\n         STH   R14,S99TUNUM             AND STORE IT IN TEXT UNIT\n         AGO   .ENDN\n.N1      MVI   S99TUNUM+1,1            SET NUMBER FIELD\n.ENDN    RCPDINC &LEN\n         MEXIT\n.BM      RCPTUBFR &KEY,&LEN,&C\n         MEXIT\n.QM      RCPBTU &KEY,&N,&C\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPVOLC": {"ttr": 4893, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x17\\x01\\x16&?\\x01\\x16&?\\x13\\x08\\x00\\x07\\x00\\x07\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:08:17", "lines": 7, "newlines": 7, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         RCPVOLC &CNT\n***********************************************************************\n**       Volume Count Text Unit                                      **\n***********************************************************************\n         RCPNTU DALVLCNT,1,&CNT\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RCPVOLCT": {"ttr": 4895, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x17\\x01\\x16&?\\x01\\x16&?\\x13\\x08\\x00\\x07\\x00\\x07\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:08:17", "lines": 7, "newlines": 7, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         RCPVOLC &CNT\n***********************************************************************\n**       Volume Count Text Unit                                      **\n***********************************************************************\n         RCPNTU DALVLCNT,1,&CNT\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RCPVOLRT": {"ttr": 6915, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00\\r\\x00\\r\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:20", "lines": 13, "newlines": 13, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         RCPVOLRT\n         SPACE 1\n***********************************************************************\n**    VOLUME SERIAL RETURN TEXT UNIT                                 **\n***********************************************************************\n         MVI   S99TUKEY+1,DALRTVOL     SET RETURN VOLUME SERIAL KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         MVI   S99TULNG+1,6            SET LENGTH FIELD\n         MVI   S99TUPAR,C' '           INITIALIZE FIELD TO BLANKS\n         MVC   S99TUPAR+1(6-1),S99TUPAR\n         RCPDINC 12\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SET": {"ttr": 4359, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x14\\x11/\\x01\\x14\\x11/\\x12H\\x00;\\x00;\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-04-22T00:00:00", "modifydate": "2014-04-22T12:48:33", "lines": 59, "newlines": 59, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&NAME    SET\n.*******************************************************************\n.*                                                                 *\n.*       MACRO TO SET A SWITCH DECLARED BY DCLSW.                  *\n.*       MACRO RCPLOCSW IS USED TO FIND IF THE SWITCH HAS BEEN     *\n.*       DECLARED AND TO LOCATE THE SWITCH BYTE WHOSE NAME IS THEN *\n.*       RETURNED IN GLOBAL SETC &RCPDSW1. &RCPDSW2 IS SET TO THE  *\n.*       SWITCH NAME IF 1 SWITCH IS SPECIFIED, OR TO THE SWITCH    *\n.*       NAMES CONCATENATED TO EACH OTHER WITH INTERVENING PLUS    *\n.*       SIGNS. IF THE SWITCH WAS NOT DECLARED, &RCPDSW1 IS SET    *\n.*       TO NULL BY RCPLOCSW.                                      *\n.*                                                                 *\n.*******************************************************************\n         GBLA  &RCPDSW0                NO OF SWITCH BYTES FOUND\n         GBLB  &RCPDSW3(20)\n         GBLC  &RCPDSW1(20),&RCPDSW2(20) PARMS RETURNED BY RCPLOCSW\n         LCLA  &I,&J,&K,&L\n         LCLC  &MASK\n         LCLC  &LABEL\n&LABEL   SETC  '&NAME'\n&I       SETA  1\n         AGO   .LOOPS\n.LOOP1   AIF   (&I GE N'&SYSLIST).EXIT\n&I       SETA  &I+2\n.LOOPS   RCPLOCSW                      &SYSLIST(&I)     LOCATE SWITCHES\n&J       SETA  0                       CLEAR LOOP COUNTER\n&MASK    SETC  '&SYSLIST(&I+1)'           GET MASK\n         AIF   ('&MASK' EQ 'ON' OR '&MASK' EQ '').ON\n         AIF   ('&MASK' EQ 'OFF').OFF\n         AIF   ('&MASK' EQ 'FLIP').FLIP\n         MNOTE 4,'INVALID SET OPTION ''&MASK'', ''ON'' ASSUMED'\n.ON      AIF   (&J GE &RCPDSW0).LOOP1\n&J       SETA  &J+1\n         AIF   (&RCPDSW3(&J)).ONOFF    BRANCH IF SWS INVERTED\n&LABEL   OI    &RCPDSW1(&J),&RCPDSW2(&J)\n&LABEL   SETC  ''                      ONLY WANT LABEL FIRST TIME\n         AGO   .ON                     CONTINUE\n.ONOFF   ANOP\n&LABEL   NI    &RCPDSW1(&J),255-(&RCPDSW2(&J))\n&LABEL   SETC  ''                      ONLY WANT LABEL FIRST TIME\n         AGO   .ON                     CONTINUE\n.OFF     AIF   (&J GE &RCPDSW0).LOOP1\n&J       SETA  &J+1\n         AIF   (&RCPDSW3(&J)).OFFON    BRANCH IF SWS INVERTED\n&LABEL   NI    &RCPDSW1(&J),255-(&RCPDSW2(&J))\n&LABEL   SETC  ''                      ONLY WANT LABEL FIRST TIME\n         AGO   .OFF                    CONTINUE\n.OFFON   ANOP\n&LABEL   OI    &RCPDSW1(&J),&RCPDSW2(&J)\n         AGO   .OFF                    CONTINUE\n.FLIP    AIF   (&J GE &RCPDSW0).LOOP1\n&J       SETA  &J+1\n&LABEL   XI    &RCPDSW1(&J),&RCPDSW2(&J)\n&LABEL   SETC  ''\n         AGO   .FLIP\n.EXIT    AIF   ('&LABEL' EQ '').END\n&LABEL   DS    0H                      IF ERROR OCCURRED, PROVIDE LABEL\n.END     MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SHI": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00E\\x01\\x082o\\x01\\x082o!\\x10\\x00\\x04\\x00\\x04\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:45", "lines": 4, "newlines": 4, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&N       SHI   &R,&V\n&N       AHI   &R,0-(&V)\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "S99FAIL": {"ttr": 5382, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x16&?\\x01\\x16&?\\x13\\x07\\x00n\\x00n\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-19T00:00:00", "modifydate": "2016-09-19T13:07:20", "lines": 110, "newlines": 110, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&NAME    S99FAIL &RB=(R14),&RC=(R15),&CPPL=,&MF=G,&CP=,&TYPE=ALLOC\n         LCLC  &LBL,&REG\n&NAME    #NULL ,\n         AIF   ('&MF(1)' EQ 'E').FAIL020\n         AIF   ('&MF(1)' EQ 'G').FAIL010\n         MNOTE 4,'&MF(1) IS AN INVALID MF, MF=G USED'\n.FAIL010 ANOP  ,\n         AIF   ('&MF(2)' NE '').FAIL030\n         LA    R1,FAIL&SYSNDX      A(DAIRFAIL PARAMETER LIST)\n         AGO   .FAIL050\n.FAIL020 ANOP  ,\n         AIF   ('&MF(2)' NE '').FAIL030\n         MNOTE 8,'PARAMETER LIST ADDRESS NOT SPECIFIED'\n         MEXIT\n.FAIL030 ANOP  ,\n         AIF   ('&MF(2)' EQ '(R1)' OR '&MF(2)' EQ '(1)').FAIL050\n         AIF   ('&MF(2)'(1,1) EQ '(').FAIL040\n         LA    R1,&MF(2)           A(DAIRFAIL PARAMETER LIST)\n         AGO   .FAIL050\n.FAIL040 ANOP\n&REG     SETC  '&MF(2)'(2,K'&MF(2)-2)\n         LR    R1,&REG             A(DAIRFAIL PARAMETER LIST)\n.FAIL050 ANOP  ,\n         AIF   ('&RB'(1,1) EQ '(').FAIL060\n         AIF   ('&RB' NE '').FAIL070\n         MNOTE 8,'REQ BLOCK ADDRESS NOT SPECIFIED'\n         MEXIT\n.FAIL060 ANOP  ,\n         ST    &RB(1),DFS99RBP-DFDSECTD(,R1)\n         AGO   .FAIL080\n.FAIL070 ANOP  ,\n         LA    R14,&RB             A(REQUEST BLOCK)\n         ST    R14,DFS99RBP-DFDSECTD(,R1)\n.FAIL080 ANOP  ,\n         AIF   ('&RC'(1,1) EQ '(').FAIL090\n         LA    R14,&RC             LOAD ADDRESS OF RETURN CODE\n         ST    R14,DFRCP-DFDSECTD(,R1)\n         AGO   .FAIL100\n.FAIL090 ANOP\n         LA    R14,DFLEN(,R1)      A(RETURN CODE AREA)\n         ST    &RC(1),0(,R14)      SAVE RETURN CODE\n         ST    R14,DFRCP-DFDSECTD(,R1)\n.FAIL100 ANOP  ,\n         LA    R14,=A(0)           A(FULLWORD OF ZEROS)\n         ST    R14,DFJEFF02-DFDSECTD(,R1)\n         LA    R14,DFLEN+4(,R1)    A(ID SWITCHES)\n         ST    R14,DFIDP-DFDSECTD(,R1)\n         AIF   ('&MF(3)' EQ '').FAIL110\n         MVI   DFLEN+4(R1),DFBUFSW\n         AGO   .FAIL120\n.FAIL110 ANOP  ,\n         MVI   DFLEN+4(R1),DFWTP\n.FAIL120 ANOP  ,\n         AIF   ('&TYPE' NE 'ALLOC').FAIL130\n         MVI   DFLEN+4+1(R1),DFSVC99\n         AGO   .FAIL150\n.FAIL130 ANOP  ,\n         AIF   ('&TYPE' NE 'FREE').FAIL140\n         MVI   DFLEN+4+1(R1),DFFREE\n         AGO   .FAIL150\n.FAIL140 ANOP  ,\n         AIF   ('&TYPE' NE 'DAIR').FAIL150\n         MVI   DFLEN+4+1(R1),DFDAIR\n.FAIL150 ANOP  ,\n         AIF   ('&CPPL' EQ '').FAIL160\n         AIF   ('&CPPL'(1,1) EQ '(').FAIL170\n         LA    R14,&CPPL           A(CPPL)\n         ST    R14,DFCPPLP-DFDSECTD(,R1)\n         AGO   .FAIL180\n.FAIL160 ANOP  ,\n         XC    DFCPPLP-DFDSECTD(,R1),DFCPPLP-DFDSECTD(R1)\n         AGO   .FAIL180\n.FAIL170 ANOP  ,\n         ST    &CPPL(1),DFCPPLP-DFDSECTD(,R1)\n.FAIL180 ANOP  ,\n         AIF   ('&MF(3)' EQ '').FAIL200\n         AIF   ('&MF(3)'(1,1) EQ '(').FAIL190\n         LA    R14,&MF(3)\n         ST    R14,DFBUFP-DFDSECTD(,R1)\n         AGO   .FAIL210\n.FAIL190 ANOP  ,\n&REG     SETC  '&MF(3)'(2,K'&MF(3)-2)\n         ST    &REG,DFBUFP-DFDSECTD(,R1)\n         AGO   .FAIL210\n.FAIL200 ANOP  ,\n         XC    DFBUFP-DFDSECTD(,R1),DFBUFP-DFDSECTD(R1)\n.FAIL210 ANOP  ,\n         LINK  EP=IKJEFF18\n         AIF   ('&MF(1)' NE 'G').EXIT\n         SPACE 1\n         RCPDS\n&LBL     SETC  'FAIL&SYSNDX'\n&LBL     DS    0F,XL(DFLEN)   RESERVE SPACE FOR DFDSECTD\n         DS    F              RESERVE SPACE FOR RETURN CODE\n         DS    XL2            RESERVE SPACE FOR ID SWITCHES\n         AIF   ('&MF(3)' EQ '').FAIL220\n         DS    XL(DFLEN2)     RESERVE SPACE FOR DFDSECT2\n.FAIL220 ANOP  ,\n         RCPDS\n.EXIT    MEND\n.*       S99FAIL ,                     - WTO NON-RENT\n.*       S99FAIL MF=(E,PLIST)          - WTO RENT\n.*       S99FAIL MF=(E,PLISTA,PLISTB)  - RETURN MSGS RENT\n.*       LA    R2,DFLIST2\n.*       USING DFDSECT2,R2\n.*       ...\n.*       DROP  R2\n.*PLIST  DS    0F,CL(DFLEN),F,XL2      - STANDARD PARAMETER LIST\n.*PLIST2 DS    0F,CL(DFLEN2)           - REPLY BUFFER PARAMETER LIST\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TERMIO": {"ttr": 1038, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00E\\x01\\x082o\\x01\\x082o!\\x10\\x00\\x97\\x00\\x97\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:45", "lines": 151, "newlines": 151, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    TERMIO &X,&Y,&Z,&OUTPUT=,&INPUT=,&ENTRY=,&ERROR=,             X\n               &TERMPUT=,&TERMGET=,&DELETE=,&DATASET=,&STORAGE=\n         GBLB &RCPPTPB(2),&RCPGTPB(2),&RCPPGPB(2),&RCPSTPB(2)\n         GBLC &RCPPRE,&RCPPTEP,&RCPGTEP,&RCPPGEP,&RCPSTEP\n         GBLC &RCPSTER,&RCPPTER,&RCPGTER,&RCPPGER\n         LCLA  &L,&I,&J\n         LCLB  &FLUSH\n         LCLC  &C,&R\n         AIF   ('&NAME' EQ '').TX\n&NAME    DS    0H\n.TX      AIF   ('&X' EQ '').E1\n&L       SETA  K'&X\n         AIF   (&L GT 7).E2\n         AIF   ('&X' EQ 'FREEBUF'(1,&L)).FREEBUF\n         AIF   ('&X' EQ 'PUTLINE'(1,&L)).PUTLINE\n         AIF   ('&X' EQ 'GETLINE'(1,&L)).GETLINE\n         AIF   ('&X' EQ 'PUTGET '(1,&L)).PUTGET\n         AIF   ('&X' EQ 'STACK  '(1,&L)).STACK\n&FLUSH   SETB  1\n         AIF   ('&X' EQ 'FLUSH  '(1,&L)).STACK\n.E2      MNOTE 8,'&X Is An Invalid Function'\n         MEXIT ,\n.E1      MNOTE 8,'No Operation Specified'\n         MEXIT ,\n.FREEBUF ANOP  ,\n&R       SETC  'R1'\n         AIF   ('&Y' EQ '' OR '&Y' EQ '(1)' OR '&Y' EQ '(R1)').FLR0\n         AIF   ('&Y' EQ 'PUTGET').FPG\n         AIF   ('&Y' EQ 'GETLINE').FGT\n         AIF   ('&Y'(1,1) NE '(').FLR1\n&R       SETC  '&Y(1)'\n         AGO   .FLR0\n.FPG     AIF   (&RCPPGPB(1)).FPG1\n      MNOTE 4,'PUTGET Not Specified On BEGIN Macro, Errors May Occur'\n.FPG1    L     R1,&RCPPRE.PGPB+PGPBIBUF-PGPB  LOAD INPUT LINE ADDRESS\n         AGO   .FLR0\n.FGT     AIF   (&RCPGTPB(1)).FGT1\n         MNOTE 4,'GETL Not Specified On BEGIN Macro, Errors May Occur'\n.FGT1    L     R1,&RCPPRE.GTPB+GTPBIBUF-GTPB  LOAD INPUT LINE ADDRESS\n         AGO   .FLR0\n.FLR1    L     R1,&Y                   LOAD INPUT LINE ADDRESS\n.FLR0    LH    R0,0(0,&R)              LOAD LINE LENGTH\n         FREEMAIN RU,LV=(0),A=(&R),SP=1\n         MEXIT ,\n.PUTLINE AIF   (&RCPPTPB(1)).PUTL1\n         MNOTE 4,'PUTL Not Specified On BEGIN Macro, Errors May Occur'\n.PUTL1   AIF   ('&ENTRY' EQ '').TPTEP\n         AIF   ('&ENTRY' EQ 'NO').PUTL2\n&R       SETC  '(15)'\n         AIF   ('&ENTRY' EQ '(15)').PUTL2\n&RCPPTEP SETC  '&ENTRY'\n         L     R15,&ENTRY              LOAD PUTLINE ENTRY POINT\n         AGO   .PUTL2\n.TPTEP   AIF   ('&RCPPTEP' EQ '').PUTL2\n&R       SETC  '(15)'\n         L     R15,&RCPPTEP            LOAD PUTLINE EP ADDRESS\n.PUTL2   PUTLINE PARM=&RCPPRE.PTPB,MF=(E,&RCPPRE.IOPL),ENTRY=&R,       X\n               OUTPUT=&OUTPUT,TERMPUT=&TERMPUT\n         AIF   ('&ERROR' EQ '').TPTER\n         AIF   ('&ERROR' EQ 'NO').EXIT\n&RCPPTER SETC  '&ERROR'\n.PTER    LTR   R15,R15                 TEST RETURN CODE\n         BNZ   &RCPPTER                 AND BRANCH IF NON ZERO\n         MEXIT ,\n.TPTER   AIF   ('&RCPPTER' NE '').PTER\n.EXIT    MEXIT ,\n.STACK   AIF   (&RCPSTPB(1)).STACK1\n         MNOTE 4,'FLUSH Or STACK Not Specified On BEGIN Macro, Errors MX\n               Ay Occur'\n.STACK1  AIF   ('&ENTRY' EQ '').TSTEP\n         AIF   ('&ENTRY' EQ '').STACK2\n&R       SETC  '(15)'\n         AIF   ('&ENTRY' EQ '(15)' OR '&ENTRY' EQ '(R15)').STACK2\n&RCPSTEP SETC  '&ENTRY'\n         L     R15,&RCPSTEP            LOAD STACK ENTRY POINT ADDRESS\n&R       SETC  '(15)'\n         AGO   .STACK2\n.TSTEP   AIF   ('&RCPSTEP' EQ '').STACK2\n&R       SETC  '(15)'\n         L     R15,&RCPSTEP            LOAD STACK ENTRY POINT ADDRESS\n.STACK2  AIF   (&FLUSH).FLUSH\n         STACK DELETE=&DELETE,STORAGE=&STORAGE,DATASET=&DATASET,       X\n               MF=(E,&RCPPRE.IOPL),PARM=&RCPPRE.STPB,ENTRY=&R\n         AGO   .STER\n.FLUSH   STACK DELETE=ALL,                                             X\n               MF=(E,&RCPPRE.IOPL),PARM=&RCPPRE.STPB,ENTRY=&R\n.STER    AIF   ('&ERROR' EQ '').TSTER\n         AIF   ('&ERROR' EQ 'NO').EXIT\n&RCPSTER SETC  '&ERROR'\n.STLTR   LTR   R15,R15                 TEST RETURN CODE\n         BNZ   &RCPSTER                 AND BRANCH IF NON ZERO\n         MEXIT ,\n.TSTER   AIF   ('&RCPSTER' NE '').STLTR\n         MEXIT ,\n.GETLINE AIF   (&RCPGTPB(1)).GETL1\n         MNOTE 4,'GETL Not Specified On BEGIN Macro, Errors May Occur'\n.GETL1   AIF   ('&ENTRY' EQ '').TGTEP\n         AIF   ('&ENTRY' EQ 'NO').GETL2\n&R       SETC  '(15)'\n         AIF   ('&ENTRY' EQ '(15)').GETL2\n&RCPGTEP SETC  '&ENTRY'\n         L     R15,&ENTRY              LOAD GETLINE ENTRY POINT\n         AGO   .GETL2\n.TGTEP   AIF   ('&RCPGTEP' EQ '').GETL2\n&R       SETC  '(15)'\n         L     R15,&RCPGTEP            LOAD GETLINE EP ADDRESS\n.GETL2   MVI   &RCPPRE.GTPB+2,128     SET TGET FLAG\n         GETLINE PARM=&RCPPRE.GTPB,MF=(E,&RCPPRE.IOPL),ENTRY=&R,       X\n               INPUT=&INPUT,TERMGET=&TERMGET\n         AIF   ('&ERROR' EQ '').TGTER\n         AIF   ('&ERROR' EQ 'NO').GTLR\n&RCPGTER SETC  '&ERROR'\n.GTER    CL    R15,=F'4'               TEST RETURN CODE\n         BH    &RCPGTER                 AND BRANCH IF ERROR\n         AGO   .GTLR\n.TGTER   AIF   ('&RCPGTER' NE '').GTER\n.GTLR    ANOP  ,\n&R       SETC  'R1'\n         AIF   ('&Y' EQ '').GTLR2\n&R       SETC  '&Y'\n.GTLR2   L     &R,&RCPPRE.GTPB+GTPBIBUF-GTPB  LOAD INPUT LINE ADDRESS\n         MEXIT ,\n.PUTGET  AIF   (&RCPPGPB(1)).PGTL1\n        MNOTE 4,'PUTGET Not Specified On BEGIN Macro, Errors May Occur'\n.PGTL1   AIF   ('&ENTRY' EQ '').TPGEP\n         AIF   ('&ENTRY' EQ 'NO').PGTL2\n&R       SETC  '(15)'\n         AIF   ('&ENTRY' EQ '(15)').PGTL2\n         L     R15,&ENTRY              LOAD GETLINE ENTRY POINT\n&RCPPGEP SETC '&ENTRY'\n         AGO   .PGTL2\n.TPGEP   AIF   ('&RCPPGEP' EQ '').PGTL2\n&R       SETC  '(15)'\n         L     R15,&RCPPGEP            LOAD PUTGET EP ADDRESS\n.PGTL2   MVI   &RCPPRE.PGPB+10,128     SET TGET FLAG\n         PUTGET PARM=&RCPPRE.PGPB,MF=(E,&RCPPRE.IOPL),ENTRY=&R,        X\n               OUTPUT=&OUTPUT,TERMGET=&TERMGET,TERMPUT=&TERMPUT\n         AIF   ('&ERROR' EQ '').TPGER\n         AIF   ('&ERROR' EQ 'NO').PGLR\n&RCPPGER SETC  '&ERROR'\n.PGER    CL    R15,=F'4'               TEST RETURN CODE\n         BH    &RCPPGER                 AND BRANCH IF ERROR\n         AGO   .PGLR\n.TPGER   AIF   ('&RCPPGER' NE '').PGER\n.PGLR    ANOP  ,\n&R       SETC  'R1'\n         AIF   ('&Y' EQ '').PGLR2\n&R       SETC  '&Y'\n.PGLR2   L     &R,&RCPPRE.PGPB+PGPBIBUF-PGPB  LOAD INPUT LINE ADDRES\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TIOTSCAN": {"ttr": 1040, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00E\\x01\\x082o\\x01\\x082o!\\x10\\x00k\\x00k\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-11-21T00:00:00", "modifydate": "2008-11-21T21:10:45", "lines": 107, "newlines": 107, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    TIOTSCAN &REG,&WKREG=R0,&NEXT=,&LAST=,&DDN=,&OK=,&NOK=\n         LCLC  &R1,&R2\n         LCLC  &LBL1,&LBL2,&LBL3,&LBL4\n&LBL1    SETC  'TIO&SYSNDX.A'\n&LBL2    SETC  'TIO&SYSNDX.B'\n&LBL3    SETC  'TIO&SYSNDX.C'\n&LBL4    SETC  'TIO&SYSNDX.D'\n&R1      SETC  'R1'                     DEFAULT TO REGISTER 1\n         AIF   ('&REG' EQ '').START     CHECK IF REG= SPECIFIED\n&R1      SETC  '&REG'                   SET TO SPECIFIED REGISTER\n.START   ANOP  ,\n.*--------------------------------------------------------------------*\n.*       LOCATE FIRST TIOT ENTRY                                      *\n.*--------------------------------------------------------------------*\n&NAME    L     &R1,16                   POINT TO CVT\n         L     &R1,0(0,&R1)             POINT TO TCB WORDS\n         L     &R1,4(0,&R1)             POINT TO OLD TCB\n         L     &R1,12(0,&R1)            POINT TO TIOT\n         LA    &R1,24(0,&R1)            PT TO FIRST TIOT ENTRY\n         AIF   ('&DDN' NE '').DDN\n.*--------------------------------------------------------------------*\n.*       SCAN THROUGH THE TIOT SERIALLY                               *\n.*--------------------------------------------------------------------*\n         AIF   ('&NEXT' EQ '').E1       MUST SPECIFY NEXT=\n         AIF   ('LAST' EQ '').E2        MUST SPECIFY LAST=\n         B     &LBL1                    PROCESS THE FIRST ENTRY\n&NEXT    SR    &WKREG,&WKREG\n         IC    &WKREG,0(0,&R1)          LOAD TIOT ENTRY LENGTH\n         AR    &R1,&WKREG               PT TO NEXT TIOT ENTRY\n&LBL1    CLI   0(&R1),0                 CHECK FOR END OF TIOT\n         AIF   ('&LAST'(1,1) EQ '(').LASTR\n         BE    &LAST                    YES, TIOT SCAN EXHAUSTED\n         AGO   .MEXIT\n.LASTR   ANOP  ,\n&R2      SETC  '&LAST'(2,K'&LAST-2)\n         BER   &R2                      YES, TIOT SCAN EXHAUSTED\n         AGO   .MEXIT\n.*--------------------------------------------------------------------*\n.*       SCAN THROUGH THE TIOT SEARCHING FOR A SPECIFIC DDNAME        *\n.*--------------------------------------------------------------------*\n.DDN     ANOP  ,\n         AIF   ('&OK&NOK' EQ '').E3     CHECK IF OK=/NOK= SPECIFIED\n         AIF   ('&OK' NE '').OK\n.*--------------------------------------------------------------------*\n.*       SPECIFIC SEARCH AND NOK= WAS SPECIFIED AND OK= NOT SPECIFIED *\n.*--------------------------------------------------------------------*\n.NOK     ANOP  ,\n         AIF   ('&DDN'(1,1) EQ '(').NOK1\n&LBL2    CLC   =CL8'&DDN',4(&R1)        CHECK FOR MATCHING DDNAME\n         AGO   .NOK2\n.NOK1    ANOP  ,\n&R2      SETC  '&DDN'(2,K'&DDN-2)\n&LBL2    CLC   0(8,&R2),4(&R1)          CHECK FOR MATCHING DDNAME\n.NOK2    ANOP  ,\n         BE    &LBL3\n         SR    &WKREG,&WKREG\n         IC    &WKREG,0(0,&R1)          GET CURRENT ENTRY LENGTH\n         AR    &R1,&WKREG               PT TO NEXT TIOT ENTRY\n         CLI   0(&R1),0                 CHECK FOR END OF TIOT\n         BNE   &LBL2                    IF NOT - KEEP SEARCHING\n         AIF   ('&NOK'(1,1) EQ '(').NOK3\n         B     &NOK                     OTHERWISE - ENTRY NOT FOUND\n         AGO   .NOK4\n.NOK3    ANOP  ,\n&R2      SETC  '&NOK'(2,K'&NOK-2)\n         BR    &R2                      OTHERWISE - ENTRY NOT FOUND\n.NOK4    ANOP  ,\n&LBL3    DS    0H\n         AGO   .MEXIT\n.*--------------------------------------------------------------------*\n.*       SPECIFIC SEARCH AND OK= WAS SPECIFIED                        *\n.*--------------------------------------------------------------------*\n.OK      ANOP  ,\n         AIF   ('&DDN'(1,1) EQ '(').OK1\n&LBL4    CLC   =CL8'&DDN',4(&R1)        CHECK FOR MATCHING DDNAME\n         AGO   .OK2\n.OK1     ANOP  ,\n&R2      SETC  '&DDN'(2,K'&DDN-2)\n&LBL4    CLC   0(8,&R2),4(&R1)          CHECK FOR MATCHING DDNAME\n.OK2     ANOP  ,\n         AIF   ('&OK'(1,1) EQ '(').OK3\n         BE    &OK                      IF SO  - SCAN IS COMPLETE\n         AGO   .OK4\n.OK3     ANOP  ,\n&R2      SETC  '&OK'(2,K'&OK-2)\n         BER   &R2                      IF SO - SCAN IS COMPLETE\n.OK4     ANOP  ,\n         SR    &WKREG,&WKREG\n         IC    &WKREG,0(0,&R1)          GET CURRENT ENTRY LENGTH\n         AR    &R1,&WKREG               PT TO NEXT TIOT ENTRY\n         CLI   0(&R1),0                 CHECK FOR END OF TIOT\n         BNE   &LBL4                    IF NOT - KEEP SEARCHING\n         AIF   ('&NOK' EQ '').MEXIT\n         AIF   ('&NOK'(1,1) EQ '(').OK5\n         B     &NOK                     OTHERWISE - ENTRY NOT FOUND\n         AGO   .MEXIT\n.OK5     ANOP  ,\n&R2      SETC  '&NOK'(2,K'&NOK-2)\n         BR    &R2                      OTHERWISE - ENTRY NOT FOUND\n         AGO   .MEXIT\n.E1      MNOTE 8,'NEXT= Option Not Specified'\n         AGO   .MEXIT\n.E2      MNOTE 8,'LAST= Option Not Specified'\n         AGO   .MEXIT\n.E3      MNOTE 8,'OK= Or NOK= Keywords Not Specified'\n.MEXIT   MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ULUPARM": {"ttr": 4621, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00!\\x01\\x15\\x01O\\x01\\x15\\x01O\\x10H\\x00\"\\x00\"\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2015-01-14T00:00:00", "modifydate": "2015-01-14T10:48:21", "lines": 34, "newlines": 34, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n         ULUPARM ,\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ULUTSCAN - ULUT Table Lookup Routine Parameter List          *\n*                                                                     *\n*---------------------------------------------------------------------*\nULUPARM  DSECT ,\nULURETCD DS    F                   Return Code\n\nULUFLAG1 DS    XL1                 Device Class / Status\nULU$ALL  EQU   B'11111110'         - All Device Classes\nULU$TAPE EQU   B'10000000'         - TAPE Class\nULU$COMM EQU   B'01000000'         - Communications Class\nULU$DASD EQU   B'00100000'         - DASD Class\nULU$DISP EQU   B'00010000'         - Display Class\nULU$UREC EQU   B'00001000'         - Unit Record Class\nULU$CHAR EQU   B'00000100'         - Character Reader Class\nULU$CTC  EQU   B'00000010'         - Channel To Channel Class\nULU$ONL  EQU   B'00000001'         - Online\nULUFLAG2 DS    XL1\n\nULUVOL   DS    CL6                 Volume Serial\nULUDEVN  DS    XL2                 Starting Device Number (Binary)\nULUDEVNC DS    CL4                 Returned Device Number (Character)\n\nULUUCB   DS    D                   A(ULUT Entry)\nULUCOUNT DS    D                   A(Number Of Remaining UCBs)\n\nULUUSEDL EQU   *-ULUPARM           Used Parameter Field Length\n         DS    (ULUPARML-(*-ULUPARM))X  Gas\nULUPARML EQU   100                 Parameter Field Length\n         DC    0S(ULUPARML-ULUUSEDL)    Ensure Not Over-Extended\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ULUTSCAN": {"ttr": 4619, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00!\\x01\\x15\\x01O\\x01\\x15\\x01O\\x10H\\x00\\x8b\\x00\\x8b\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2015-01-14T00:00:00", "modifydate": "2015-01-14T10:48:21", "lines": 139, "newlines": 139, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&LABEL   ULUTSCAN &DEVCLASS=,      Device Class Filter                 *\n               &DEVN=,             Starting Device Number              *\n               &STATUS=,           Device Status Filter                *\n               &VOLSER=,           Volser Filter                       *\n               &LINKAGE=BRANCH,    Invocation Method                   *\n               &MF=\n.*\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*       ULUTSCAN - Perform UCB scanning using the ULUT Table.        *\n.*                                                                    *\n.*       Optional parameters:                                         *\n.*             DEVCLASS=                                              *\n.*              - Device Class Filter:                                *\n.*                - ALL                                               *\n.*                - TAPE                                              *\n.*                - COMM                                              *\n.*                - DASD                                              *\n.*                - DISP                                              *\n.*                - UREC                                              *\n.*                - CHAR                                              *\n.*                - CTC                                               *\n.*             DEVN=                                                  *\n.*              - Starting Device Number                              *\n.*                (Field in ULUPARM is updated after each call).      *\n.*             STATUS=                                                *\n.*              - Device Status Filter:                               *\n.*                - ONLINE                                            *\n.*                (If not specified ALL UCBs are returned).           *\n.*             VOLSER=                                                *\n.*              - Volume Serial Filter:                               *\n.*                - volser or volser mask.                            *\n.*                (\"*\" for any number of characters and               *\n.*                 \"?\" for any single character).                     *\n.*             LINKAGE=                                               *\n.*              - Invocation Method (BRANCH or SYSTEM)                *\n.*                (If BRANCH is used ULUTSCAN must be included).      *\n.*                                                                    *\n.*       Required parameters:                                         *\n.*             MF=                                                    *\n.*              - Parameter List ... (MF=(E,areaname))                *\n.*                (Use 100 byte workarea in case of future updates).  *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         LCLA  &I,&VL,&F,&N\n         LCLB  &B(8)\n         LCLC  &L\n.*\n.**********************************************************************\n.*       DEVCLASS=                                                    *\n.**********************************************************************\n&I       SETA  1\n.DEV0010 AIF   (&I GT N'&DEVCLASS).DEV0030\n         AIF   ('&DEVCLASS(&I)' EQ 'ALL').DEV0020\n&B(1)    SETB  (&B(1) OR '&DEVCLASS(&I)' EQ 'TAPE')\n&B(2)    SETB  (&B(2) OR '&DEVCLASS(&I)' EQ 'COMM')\n&B(3)    SETB  (&B(3) OR '&DEVCLASS(&I)' EQ 'DASD')\n&B(4)    SETB  (&B(4) OR '&DEVCLASS(&I)' EQ 'DISP')\n&B(5)    SETB  (&B(5) OR '&DEVCLASS(&I)' EQ 'UREC')\n&B(6)    SETB  (&B(6) OR '&DEVCLASS(&I)' EQ 'CHAR')\n&B(7)    SETB  (&B(7) OR '&DEVCLASS(&I)' EQ 'CTC')\n&I       SETA  &I+1\n         AGO   .DEV0010\n.DEV0020 ANOP  ,\n&B(1)    SETB  1\n&B(2)    SETB  1\n&B(3)    SETB  1\n&B(4)    SETB  1\n&B(5)    SETB  1\n&B(6)    SETB  1\n&B(7)    SETB  1\n.*\n.**********************************************************************\n.*       STATUS=                                                      *\n.**********************************************************************\n.DEV0030 ANOP  ,\n&B(8)    SETB  ('&STATUS' EQ 'ONLINE')\n.*\n.**********************************************************************\n.*       Initialize Parameter List                                    *\n.**********************************************************************\n         AIF   ('&MF(1)' NE 'E').DEV0090\n         PUSH  USING\n         IHBINNRR &MF(2)           Load Parameter List Into R1\n         LR    R15,R1              A(Parameter List)\n         USING ULUPARM,R15\n&F       SETA  128*&B(1)+64*&B(2)+32*&B(3)+16*&B(4)+8*&B(5)+4*&B(6)+2*&*\n               B(7)+&B(8)\n         MVI   ULUFLAG1,&F         Set Device Class / Status Flag(s)\n.**********************************************************************\n.*       DEVN=                                                        *\n.**********************************************************************\n         AIF   (K'&DEVN EQ 0).DEV0040\n         IHBINNRR &DEVN            Load Parameter List Into R1\n         MVC   ULUDEVN,0(R1)       Set Starting Device Number\n.*\n.**********************************************************************\n.*       VOLSER=                                                      *\n.**********************************************************************\n.DEV0040 ANOP  ,\n         MVI   ULUVOL,C' '         Initialize Volser\n         MVC   ULUVOL+1(L'ULUVOL-1),ULUVOL\n         AIF   ('&VOLSER'(1,1) EQ '(').DEV0050\n&VL      SETA  K'&VOLSER\n         AIF   (&VL EQ 0).DEV0060\n         AIF   (&VL GT 6).DEV0100\n         MVC   ULUVOL(&VL),=C'&VOLSER'\n         AGO   .DEV0060\n.DEV0050 ANOP  ,\n         IHBINNRR &VOLSER          Load Parameter List Into R1\n         MVC   ULUVOL,0(R1)        Set Volser/Mask\n.*\n.**********************************************************************\n.*       Call ULUTSCAN                                                *\n.**********************************************************************\n.DEV0060 ANOP  ,\n         DROP  R15\n         LR    R1,R15              A(Parameter List)\n         AIF   ('&LINKAGE' EQ 'SYSTEM').DEV0070\n         L     R15,=V(ULUTSCAN)    A(ULUT Table Scan Routine)\n         BASR  R14,R15             Get Next UCB Address\n         AGO   .DEV0080\n.DEV0070 ANOP  ,\n         LINK  EP=ULUTSCAN         Get Next UCB Address\n.DEV0080 ANOP  ,\n         POP   USING\n         MEXIT\n.**********************************************************************\n.*       Errors                                                       *\n.**********************************************************************\n.DEV0090 ANOP  ,\n         MNOTE 8,'ULUTSCAN - Invalid MF= Value - &MF(1)'\n         MEXIT ,\n.DEV0100 ANOP  ,\n         MNOTE 8,'ULUTSCAN - VOLSER= is too long - &VOLSER'\n         MEXIT ,\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT797/CBT.V500.FILE797.PDS/MACLIB.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT797/CBT.V500.FILE797.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}